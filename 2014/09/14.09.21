00:00:53 <dfeuer> augur, you can't show other bottom values so well, however.
00:01:18 * hackagebot xml-push 0.0.0.8 - Push XML from/to client to/from server over XMPP or HTTP  http://hackage.haskell.org/package/xml-push-0.0.0.8 (YoshikuniJujo)
00:01:31 <augur> dfeuer: thats also true. i never said you could always compute a string :)
00:01:37 <augur> just that you could define the instances
00:01:53 <augur> > show (cycle [] :: [()])
00:01:55 <lambdabot>  "*Exception: Prelude.cycle: empty list
00:02:08 <augur> haha smart, cycle, very smart
00:02:20 <augur> > show (fix ([] ++) :: [()])
00:02:24 <lambdabot>  mueval-core: Time limit exceeded
00:02:24 <dfeuer> > show $ cycle [3]
00:02:25 <lambdabot>  "[3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,...
00:02:36 <dfeuer> > show $ cycle [3,3]
00:02:37 <lambdabot>  "[3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,...
00:02:57 <augur> that you cant eval some things is tangential to defining the show instances
00:03:17 <dfeuer> But ... how do you show a function?
00:03:36 <augur> show (\x -> b) = "\" ++ show x ++ " -> " ++ show b
00:03:58 <augur> but of course you cant match on functions in haskell so it would have to be a secret definition
00:04:29 <dfeuer> There's no guarantee that a Haskell implementation will be ably to support that sort of thing.
00:04:36 <augur> dfeuer: thats what i said earlier
00:04:41 <dfeuer> Oh.
00:04:45 <augur> :P
00:04:54 <augur> because haskell compiles it, you just have a pile of machine code
00:05:05 <augur> the only way to do it is to bundle the program with the compiled code
00:05:19 <dfeuer> And have a way to find the right spot.
00:05:35 <augur> find the right spot?
00:06:18 <dfeuer> Well, you have to store some sort of source info with each closure or something.
00:06:47 <dfeuer> And since compilation tears everything apart, this will be very tricky.
00:06:48 <augur> dfeuer: yes, tho that shouldnt be too hard i'd wager
00:07:12 <augur> dfeuer: sure compilation tears everything apart, but at compile time you have the lambda terms right there
00:07:45 * hackagebot repline 0.1.0.0 -   http://hackage.haskell.org/package/repline-0.1.0.0 (sdiehl)
00:07:45 * hackagebot xml-push 0.0.0.8 - Push XML from/to client to/from server over XMPP or HTTP  http://hackage.haskell.org/package/xml-push-0.0.0.8 (YoshikuniJujo)
00:08:29 <jle`> what would a show on a function even do?
00:08:47 <oakwhiz> jle`: print abstract syntax tree?
00:09:10 <jle`> hm
00:09:16 <jle`> what about things like ref transp
00:09:24 <jle`> would (f) show the same thing as (id f) ?
00:09:31 <jle`> f and id f are supposed to be identical
00:09:44 <jle`> due to ref transp and stuff, right?
00:09:49 <dfeuer> Yup.
00:09:50 <jle`> would they be shown as different things?
00:10:17 <dfeuer> Quood gestion.
00:14:48 <Thule> What is wrong with this? I get a parse error on the first [: instance Show MyType where
00:14:48 <Thule>   show (MyType aInt aFloat) = aInt
00:14:59 <Thule> sorry wrong paste
00:15:09 <Thule> data MyType = MyType {[(val,poly)] :: [(Float,Int)]}
00:16:03 <augur> jle`, dfeuer: id f is not constructor headed
00:16:24 <augur> you would evaluate it and show the evaluated result, as you always do in haskell
00:16:31 <augur> this has nothing to do with f being a function
00:16:40 <augur> show (id [1,2,3]) == show [1,2,3] == "[1,2,3]"
00:17:06 <dfeuer> augur,  \x y -> x + y   is the same function as  \x y -> y + x. How do you decide which to show?
00:18:25 <augur> dfeuer: its the same function extensionally, but its not the same piece of code
00:19:39 <augur> Thule: thats not a valid record
00:19:47 <Thule> how come?
00:20:15 <augur> Thule: you want something like   data MyType = MyType { xs :: [(Float,Int)] }
00:20:38 <augur> records are like   ConstructorName { fieldName :: type, fieldName :: type, ... }
00:21:12 <Thule> ahhh ok. Thank you... Makes sense..
00:25:06 <beckyconning> does anyone know of an alternative or can give me some tips to rewrite timeout (https://hackage.haskell.org/package/base-4.1.0.0/docs/src/System-Timeout.html) such that it will always wait for the timeout to finish before handling a Maybe?
00:25:15 <vanila> you can implement a show instance for functions a -> b when a is finite and a,b have Show
00:25:33 <vanila> (\x -> case x of V1 -> R1 ; ...)
00:25:34 <phaskell> V1: Which swallow has a higher air-speed velocity? Come Vote https://phabricator.haskell.org/V1
00:25:41 <vanila> this is like a 'normal form' for functions from a finite range
00:27:13 <augur> vanila: thats a silly way to do it, but sure you can do that
00:27:56 <augur> lambdas are just data like any other data, so there's no reason to not have a generic show for it, except in that you compile them into more useful forms
00:27:59 <vanila> It's nice to have the property that if f,g are equal as functions then show f == show g and this gives us that
00:28:17 <augur> vanila: yes, but that depends on what you mean by equal
00:28:34 <augur> \x -> x + 0   and   \x -> 0 + x   are equal and not equal
00:29:24 <vanila> by equal as functions I intend forall x, f x = g x - and I ignore undefined
00:29:37 <augur> vanila: extensional equality is a pain in the ass
00:30:22 <Thule> is there any way to display operators? I need something like show +, and it outputs "+".. any ideas?
00:30:36 <augur> Thule: no, operators are just functions
00:30:46 <augur> and there's no way in haskell to show a function
00:31:15 <augur> i wonder if its possible to define a well-typed language binding constructs are treated like normal data
00:31:18 <Thule> ok thanks
00:31:27 <vanila> Thule, you should create a data structure  data Operator = Plus | Minus | ...,  and then write two functions:  eval Plus = (+) ; ... and display Plus = "+" ; ...
00:31:29 <Thule> I have another way of solving it, so hopefully it'll work :)
00:31:49 <Thule> ah ye. thanks
00:32:32 <augur> like have a special judgment   `n name`   and then have an elim on functions like   G !- M : A -> B  =>  G !- bound(M) name
00:32:41 * hackagebot peyotls 0.1.6.0 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.1.6.0 (YoshikuniJujo)
00:32:55 <augur> probably that wouldnt work. names are meta-components
00:32:56 <augur> hmm
00:34:01 <augur> the only pattern matching on functions thats possible, i guess, is funSplit
00:34:47 <augur> G !- M : A -> B    G !- N : A    G, x : B !- P : C    =>    G !- funSplit(M; N; x.P) : C
00:35:45 <augur> which doesnt even have the usual properties of case like you'd expect from normal PL approaches, but its exactly the right thing proof theoretically
00:36:34 <augur> oh speaking of, i need to continue harassing jonsterling
00:37:04 <vanila> augur, I tend to think of lambda abstraction & function application being parallel to constructors & pattern matching
00:37:19 <augur> vanila: im not sure what you mean
00:38:24 <Thule> Is there any way of getting rid of [] when overriding show for my own type? e.g. I have defined show for MyType to be "a". But when I have [MyType] I get ["a","a"]. Can I get rid of [] and , and get a+a for example?
00:38:45 <vanila> If you look at it in terms of curry-howard it makes sense, data constructors introduce a type and pattern matching eliminates it - similarly lambda abstraction introduces an implication and function application eliminates it
00:38:50 <augur> Thule: not really no
00:39:03 <Thule> ok
00:39:14 <shachaf> Thule: There is a particular way to do it for lists but nothing else.
00:39:17 <vanila> on the other hand, when you look at it in terms fo category theory currying is more fundamental - but I don't prefer that view
00:39:17 <augur> vanila: from a CH perspective, lambdas are no different from other constructors, except that they happen to bind variables
00:39:27 <shachaf> Thule: And you probably shouldn't do it for lists either.
00:39:39 <Thule> howcome?
00:39:44 <shachaf> If Show doesn't do what you want, you might be better off not using it. You can make your own class, or not use a class at all.
00:39:48 <vanila> augur, yeah, that's exactly what I mean :)
00:40:32 <augur> vanila: the pattern matching for functions is the one i described, which is derivable algorithmically in the same way all other pattern matching is
00:42:39 <vanila> is funSplit(M; N; f) = f . M $ N ?
00:48:33 <augur> vanila: not quite
00:48:46 <augur> vanila: in a system with funSplit, there is no ($)/application
00:48:49 <augur> there is only funSplit
00:48:59 <augur> those are two alternative elims for ->
00:49:10 <vanila> interesting!
00:49:15 <augur> you can either have   G !- M : A -> B    G !- N : A   ===>   G !- app(M;N) : B
00:49:54 <augur> or you can have   G !- M : A -> B    G !- N : A    G, y : B !- P : C    ===>   G !- funSplit(M; N; y.P) : C
00:50:04 <augur> analogous to fst/snd  vs  split:
00:50:23 <augur> G !- M : A*B  =>  G !- fst(M) : A  ,  G !- snd(M) : B
00:50:25 <augur> vs
00:50:51 <augur> G !- M : A*B    G, x : A, y : B !- N : C   ==>   G !- split(M; x,y.N) : C
00:51:17 <augur> the nice syntax for   split(M; x,y.N)   is   case M of (x,y) -> N
00:54:04 <vanila> \]
00:54:06 <vanila> oops
00:54:40 <vanila> it might be possible to think of functions a -> b as lookup tables [(a,b)] also
00:55:04 <augur> vanila: yes, if a is enumerable, then a -> b is enumerable
00:55:14 <augur> class Enumerate a where enumerate :: [a]
00:55:25 <augur> where enumerate is the list of all possible a's
00:56:11 <augur> instance Enumerate a => Show (a -> b) where show f = show [ (x, f x) | x <- enumerate ]
00:56:22 <Haskellfant> is there a way to set a thread to sleep forever until I throw an exception to it from another thread?
00:56:26 <augur> er, you also need Show a and Show b of course
01:04:37 <lostman> how can I pre-build some libraries and keep reusing them? that is I want to keep some libs on the side and just point cabal/ghc to also use them
01:13:53 <eisbehr> ghc doesn't use dynamic linking as far as I know.
01:13:59 <eisbehr> If that's what you mean
01:16:30 <Hijiri> haskellfant, you might be able to do what you want with MVars
01:16:44 <Hijiri> a thread that tries to read an MVar will block until the MVar is filled with something
01:17:05 <Hijiri> so instead of sending an exception, you can put something in the MVar
01:17:22 <Haskellfant> Hijiri: yeah i know that, but I thought there might be some other way to do this
01:17:45 * hackagebot xml-push 0.0.0.9 - Push XML from/to client to/from server over XMPP or HTTP  http://hackage.haskell.org/package/xml-push-0.0.0.9 (YoshikuniJujo)
01:17:58 <Hijiri> I can think of a hacky way where you just enclose looped sleep IO action in catch
01:18:16 <Haskellfant> hm mvar seems to be the best solution :)
01:20:18 <Haskellfant> Hijiri: thx for your suggestion
01:47:00 <montagy> what is the diffrent between gtk and gtk3 packages?
01:47:24 <montagy> i want try gtk
01:48:35 <WarzoneCommand> are there any packages/tools  that can help in profiling?
01:49:15 <WarzoneCommand> I'm looking at the .prof file, but I'm not sure I see functions that need obvious improvements
01:49:50 <WarzoneCommand> yet my haskell solution is much slower than I would hope/expect
01:53:46 <pavonia> montagy: gtk is based on Gtk+ 2, gtk3 on Gtk+ 3, so the differences are basically those of the underlaying Gtk version, AFAIK
01:56:32 <montagy> pavonia:thanks,it`s helpfull
02:10:17 <cnphil> WarzoneCommand: maybe try threadscope?
02:12:49 * hackagebot shell-conduit 1.0 - Write shell scripts with Conduit  http://hackage.haskell.org/package/shell-conduit-1.0 (ChrisDone)
02:21:24 <WarzoneCommand> cnphil: Ok ty I'll have a look at that
02:27:50 * hackagebot shell-conduit 1.1 - Write shell scripts with Conduit  http://hackage.haskell.org/package/shell-conduit-1.1 (ChrisDone)
02:36:46 <shiro> hello
02:37:24 <shiona> hello
02:37:39 <shiro> newbie question here, I have been learning haskell for some time now, and I have rewritten some of the standard library for practice
02:37:51 * hackagebot rvar 0.2.0.2 - Random Variables  http://hackage.haskell.org/package/rvar-0.2.0.2 (DominicSteinitz)
02:38:14 <shiro> now I want to make a small project to polish it, but for most user interaction, I need to save states, what is the right way of doing this
02:38:36 <jle`> do you mean save to disk between sessions?
02:38:39 <shiro> for example, what is the right way of writing a program that prints out an increasing number every time the user clicks a button
02:38:48 <shiro> no, in a single session
02:39:34 <shiro> i tried to do the following in my main do block
02:39:37 <shiro> i <- 0
02:39:45 <shiro>  onClicked button (do {i <- return $ inc i; print i})
02:39:54 <shiro> but this does not work, because you can only assign once
02:40:26 <jle`> there are a couple of approaches to this
02:40:33 <shiro> I am all ears
02:40:35 <jle`> what is onClicked here?
02:40:50 <jle`> and are you constrained to printing the answer?
02:40:53 <shiro> it is a gtk2haskell function, it binds a button to a function
02:40:58 <jle`> ah
02:41:10 <shiro> first arg button, second arg function
02:42:13 <shiro> I do not have to print it out, it is still only practice but I need to see if it has changed
02:42:32 <jle`> hm
02:43:13 <shiro> it could be anything, like volume setting for a music player or something similar, this is just a simplified example
02:43:20 <jle`> well, if it was an interactive command line thing, you could have done something like a recursive call, keeping the state in the parameters of the call
02:43:34 <jle`> or composed some forms of state -> (output, state) functions
02:43:40 <jle`> in this case you're working directly with IO
02:43:52 <shiro> I thought about writing to disk and reading but that would be using a hammer on an egg, probably
02:43:57 <jle`> there's a low level way you could do this
02:44:06 <jle`> that isn't too pretty, and wouldn't really scale
02:44:24 <jle`> the haskell runtime (IO) offers a tool for mutable boxes you could access in the course of your IO action
02:44:28 <tero-> I have an AST with many data types (https://hackage.haskell.org/package/yesod-dsl-0.1.1.19/docs/YesodDsl-AST.html) and currently I have a lot of boilerplate with the traversals on this structure. uniplate seems to solve the case for a single data type, e.g. data type for expressions, but what would be the recommended approach for eliminating the boilerplate when traversing multiple types?
02:44:40 <jle`> by that, i mean GHC's runtime
02:44:44 <jle`> it's called IORef
02:44:56 <shiro> ok, I am going to check it on hoogle
02:44:58 <jle`> it would be teh most direct way of exactly doing what you want, here
02:45:15 <jle`> an `IORef a` can be thought of an address/pointer to something of type `a`
02:45:25 <jle`> and you have IO actions that can put stuff in, remove, read, etc. things in that box
02:45:33 <shiro> I just do not want to end up coding C in haskell
02:45:33 <jle`> all within the context of an IO action of course
02:45:51 <jle`> yeah.  well, there are ways to get this to happen in a denotative/functional way
02:45:55 <jle`> which is preferred
02:46:11 <jle`> but it takes a little bit of work to get the abstraction together working in your case
02:46:19 <jle`> unless you are willing to jump in and use a pre-built framework with gui
02:46:35 <shiro> I am willing to learn the right way
02:46:37 <jle`> this is why i mentioned that this way doesn't quite scale :)
02:46:50 <shiro> guess I should read some projects, sadly there aren't many
02:46:56 <jle`> unfortunately :/
02:47:08 <jle`> ocharles has a nice series of posts where he works with threepenny gui and gloss
02:47:15 <jle`> to make stateful and interactive discrete time games
02:47:24 <jle`> with gui/graphics
02:47:25 <shiro> nice, any links?
02:47:41 <jle`> some things here https://ocharles.org.uk/blog/
02:47:48 <shiro> oh :D thanks
02:47:51 <jle`> as for an FRP approach
02:48:01 <jle`> you can look into push/pull FRP frameworks for your backend of choice
02:48:13 <jle`> like: sodium, reactive-banana
02:48:28 <jle`> i think both of the ocharles examples use an imperative approach
02:48:42 <shiro> I guess you have to do it to a degree
02:48:45 <jle`> but FRP is one way you can structure your program logic in a denotative/declarative way
02:49:08 <jle`> for example, in this case, you can "say" that the value of your text box is equal to the number of clicks so far on your button
02:49:15 <jle`> you can declare it that way
02:49:26 <jle`> and FRP would "compile" to the proper imperative actions needed to mkae that happen
02:49:36 <tero-> hm. I'll read the SYB paper before asking more
02:50:00 <shiro> ok, thanks a lot, I am going to read some now
02:50:09 <jle`> the emphasis is that your program that you write is working on "forever" kind of statements
02:50:25 <jle`> it's not "when this happens, do that."  it's "this is how the value of this text box relates to the button and its clicks"
02:50:42 <shiro> yeah, there is no explicit forever but it is basically that
02:50:57 <jle`> this is how things just "are".  not "this then that"
02:51:09 <jle`> like when you write pi = 3.1 in code, you're saying that that's just what pi is :)
02:51:15 <jle`> it's a very haskelley way to approach things, i think
02:51:36 <shiro> yeah, therotically it is something like a constant function
02:51:48 <jle`> it's a static relationship
02:51:50 <jle`> yeah
02:52:07 <jle`> well, for now playing around, you can play with IORefs
02:52:17 <shiro> but lacking an argument because it would not matter anyway
02:52:29 <jle`> but i suggest looking into a denotative framework to structure larger projects
02:52:37 <shiro> yup
02:52:46 <jle`> i don't really know any good sodium/reactive-banana tutorials off the top of my head, sorry
02:52:58 <jle`> but those would probably be the frp implementations most suited to your problem
02:53:05 <jle`> but keep asking questions :)
02:53:20 <shiro> a few basic things with IORef for warming up, then levelling up, nice plan
02:53:47 <jle`> just remember that there's a fundamental difference between the two approaches :)
02:54:24 <shiro> yes sir! :)
02:54:30 <jle`> i do wish that things were in a state where i could directly point to an up to date current tutorial on things like this
02:55:12 <shiro> unpopular language problems
02:55:33 <jle`> tell me about it :)
02:55:50 <jle`> they might be out there though, i might just not know about them
02:56:08 <jle`> the sodium people are pretty active i think...but they also focus a lot on bringing FRP to other languages, so
02:56:37 <shiro> there is something on hackage
02:56:59 <jle`> oh nice :)
02:57:00 <shiro> and this channel seems to be active too, I did not except that actually
02:57:11 <jle`> it's actually the most active channel on freenode or something
02:57:25 <jle`> active hours usually coincide with daytime hours in the US though
02:57:39 <jle`> in general, for some reason
02:58:10 <shiro> that's nighttime for me, which is nice, because batman: school during the day, trying to program in the night :D
02:58:13 <jle`> if you're new to haskell you might also like #haskell-beginners , #nothaskell , and #haskell-game if you are interested in interactive haskell
02:58:44 <shiro> what is haskell-game
02:58:46 <jle`> :P glad it works out :)
02:58:51 <shiro> beginners is obvious but
02:58:56 <jle`> haskell-game is where the game dev people hang out
02:59:10 <jle`> but if you have interactive/gui questions, it's probably a good place for that too
02:59:23 <jle`> since game dev people often care a lot about that
02:59:25 <shiro> yeah, probably
03:00:08 <shiro> thanks again, have a nice day / goodnight
03:00:15 <jle`> you too!  happy haskelling :)
03:01:56 <pie870> salve
03:01:58 <pie870> !list
03:01:58 <monochrom> pie870: http://okmij.org/ftp
03:03:21 <matheus23> hello, I have a cabal question:
03:03:23 <matheus23> I have made 3 cabal projects (developed in a sandbox): A Graphics package, a Widget package and an Application package. The Widget package depends on the Graphics package, the Application package does that as well, and the Application package also depends on the Widget package. Now I changed the Graphics package and said "cabal install --only-dependencies" on the Application package and it reinstalled the Graphics package and compiled th
03:03:25 <matheus23> e Widget package against it. But upon "cabal build" in the Application package I get a "cannot satisfy -package-id" for my graphics package. I just want the Application package to use the latest Graphics package, how can I do that?
03:04:13 <Adeon> did you try removing and creating the sandbox again
03:04:15 <tero-> okay, got it, everywhere (mkT f) works. http://community.haskell.org/~ndm/darcs/uniplate/uniplate.htm had only an example with one type
03:04:26 <Adeon> it sometimes gets confused
03:05:48 <matheus23> Adeon: No I didn't. I'll do that, but I just noticed I might try removing the sandbox source and re-adding it, maybe that helps
03:17:54 * hackagebot codex 0.1.0.5 - A ctags file generator for cabal project dependencies.  http://hackage.haskell.org/package/codex-0.1.0.5 (aloiscochard)
03:17:56 * hackagebot libmpd 0.9.0 - An MPD client library.  http://hackage.haskell.org/package/libmpd-0.9.0 (JoachimFasting)
03:29:10 <ale111> salve
03:29:11 <ale111> !list
03:29:11 <monochrom> ale111: http://okmij.org/ftp
03:29:40 <tero-> if I want to make two transformations without traversing the data structure twice?
03:30:21 <tero-> say, I want to apple f1 :: Apple -> Apple and f2 :: Orange -> Orange
03:31:11 <tero-> can I do better than : (everywhere (mkT f1)) . (everywhere (mkT f2)) ?
03:32:55 * hackagebot persistent-postgresql 2.0.4.1 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-2.0.4.1 (MichaelSnoyman)
04:02:58 * hackagebot libmpd 0.9.0.1 - An MPD client library.  http://hackage.haskell.org/package/libmpd-0.9.0.1 (JoachimFasting)
04:06:19 <Rhianne23>  Hi! I give you some videos. I hope you like! http://tinyurl.com/ozfvxy3
04:31:54 <Guuf> http://lpaste.net/111365 - Can I use lenses/traversals/prisms to get all expVariable from e1 and e2?
04:33:47 <tcberner> Hi
04:35:31 <tcberner> I'm trying to use https://hackage.haskell.org/package/dbus in xmonad. But I get a SocketError: I get the same one when trying to run the example of the dbus-package http://paste.kde.org/puvnjn0if
04:35:52 <tcberner> !
04:36:17 <tcberner> sorry, didn't mean to type an exclamation mark
04:36:46 <Guuf> That’s alright, I needed one anyway.
04:45:58 <lpaste> erikd pasted “hGetContents: invalid argument with cabal 1.20.0.2” at http://lpaste.net/111367
04:46:20 <erikd> any clues on that ^^^^^^^^^^^
04:47:46 <supki> Guuf: you can do it with Plated: http://lpaste.net/7843952386761555968
04:51:56 <Guuf> supki: Great, thanks!
04:54:00 <Guuf> supki: Do you know if it is or is not possible without Plated?
04:59:27 <WarzoneCommand> hmm
04:59:39 <WarzoneCommand> is there a way to make 'fmap' on arrays lazier
05:00:34 <WarzoneCommand> i.e. suppose that I have some array/vector storing ints. And now I fmap some function :: Int -> SomeLareDataStruct over it
05:00:59 <WarzoneCommand> then I don't want it to actually apply that function for all elements, just for the ones I will access at a later time
05:01:16 <WarzoneCommand> (which may only be a very small subset of the elements of the array)
05:02:04 <supki> Guuf: sure, you can write the traversal to get all variables yourself too
05:02:14 <supki> Guuf: (I've annotated the paste)
05:03:11 <supki> Guuf: plate is useful as a building block for complex traversals though
05:03:40 <Guuf> supki: Oh, I see. Then I’ll find a tutorial on that, sounds like I will need it in the future.
05:04:56 <supki> Guuf: I suggest "The essense of the iterator pattern" paper if you haven't read it yet
05:05:53 <supki> it's about traversals in general, I don't know if there's anything about Plated specifically
05:06:09 <Guuf> supki: With Plate, could I write a traverser that finds all variables _except_ the sub-nodes to a ExpProduct node? So the traversal basically doesn’t traverse further down when it reaches an ExpProduct node?
05:06:47 <adimit> The Diagrams documentation says that it probably shouldn't be used for interactive generation of graphics… what should I use instead? (I'm going to draw celestial orbits, etc.)
05:07:06 <phaazon> hm
05:07:11 <phaazon> I tried to install ghc-mod
05:07:23 <phaazon> but cabal install refused since I have lens installed, and it says the plan is dangerous
05:07:47 <phaazon> is there a safe way to say “no problem, just download the downgraded dep, and use it”?
05:08:16 <phaazon> I thought the fact we can still keep old version of a package was exactly designed to solve that issue
05:09:15 <Guuf> supki: I can clearly see that I can just adapt your code to do what I want, but can the Plated library do it easier?
05:11:04 <supki> Guuf: you can write a plate-like thing that doesn't traverse ExpProduct and use it with universeOf
05:11:30 <supki> Guuf: plate itself will always look at all immediate children so it does quite work here
05:12:13 <Guuf> supki: Okay, sounds good! Thank you, you have been of great help.
05:14:36 <mads-> I'm trying to do the Scheme Compiler in Haskell from here : http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing - my code so far http://ideone.com/TxGi8q gives me a parse error parse error (possibly incorrect indentation or mismatched brackets) on line 30. Anyone who can spot my error?
05:17:19 <hexagoxel> mads-: you don't need "in" for the let inside do-notation (29)
05:18:07 <mads-> hexagoxel: That did the trick :)
05:18:11 <mads-> Thaanks.
05:23:02 <hexagoxel> (but you can use "let [bindings] in e" inside do-notation as well; the bindings will be visible only in e; but you need to provide e (that was your error, more or less..))
05:30:45 <Eduard_Munteanu> "let ... in ..." is a full-fledged expression, by the way.
05:31:33 <_1_dani123> fhbh
05:31:40 <_1_dani123> gh
05:35:23 <wei2912> just curious about this; what makes you like haskell? :)
05:36:51 <exio4> it is a beautiful pure functional language
05:37:07 <exio4> has an awesome community
05:41:41 <Eduard_Munteanu> wei2912, interesting type system and abstractions... much unlike other PLs.
05:42:34 <yesthisisuser> very clean and minimalistic syntax
05:43:53 <yesthisisuser> it compiles to native code, which perhaps is not a property of the language itself. but still important for me
05:44:21 <lostman> ok, I'm trying to use shared libraries... I've compiled hashable with --enable shared and put it in /opt/lib and then trying to compile case-insensitive (requires hashable) with 'cabal install --enable-shared --extra-lib-dirs=/opt/lib' but that doesn't work... tells me it can't find hashable
05:44:26 <lostman> how do I use shared libs?
05:53:06 * hackagebot hindent 3.2 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-3.2 (ChrisDone)
05:58:07 * hackagebot structured-haskell-mode 1.0.4 - Structured editing Emacs mode for Haskell  http://hackage.haskell.org/package/structured-haskell-mode-1.0.4 (ChrisDone)
06:27:13 <MagneticDuck> hmm.. is there a nice, simple, haskell-ised way to manange some simple packet manipulation / sending packets / listening on ports, and stuff?
06:27:36 * MagneticDuck checks hackage
06:28:35 <MagneticDuck> I guess there's pcap for catching packets...
06:28:43 <MagneticDuck> but what about manipulating them and sending them?
06:29:32 <MagneticDuck> oh
06:29:36 <MagneticDuck> never mind, pcap does that too
06:31:09 <MagneticDuck> now, whether pcap is nice and haskellised is another matter
06:33:09 * hackagebot vimus 0.1.0 - An MPD client with vim-like key bindings  http://hackage.haskell.org/package/vimus-0.1.0 (SimonHengel)
06:48:44 <HugoDaniel> hi
06:48:53 <HugoDaniel> how can i use the "primitive" package ?
06:48:59 <HugoDaniel> whats it useful for ?
06:50:27 <srhb> HugoDaniel: You can have a look at the packages that depend on primitive and see what they use it for: http://packdeps.haskellers.com/reverse/primitive
06:51:06 <srhb> HugoDaniel: vector might be a nice place to look :)
06:55:12 <srhb> HugoDaniel: Also Data.Prim.Addr is extremely understandable.
06:55:23 <yesthisisuser> Wouldn't it be possible for the compiler to use type inference to resolve most of the ambiguous occurrence "something" errors? Or would that introduce some sort of coercion
06:58:10 <luite> yesthisisuser: it means that it couldn't decide on a specific type using type inference. there's a defaulting mechanism to help it pick one, and ExtendedDefaultRules if you want to give it a bit more power
06:58:59 <HugoDaniel> its hard to sort vector types
07:01:15 <bennofs> HugoDaniel: the "primitive" package provides a nicer interface to the ghc-prim package, which exposes internal GHC primpos (which are implemented in C and often impure)
07:01:34 <srhb> luite: I think the question is more like assume imports Data.List and Data.Map, lookup a x -- could be resolved by the type of x.
07:01:53 <srhb> If it's an assoclist, it's lookup from Data.List, if it's a Map, it's lookup from Data.Map
07:02:38 <srhb> yesthisisuser: Or what?
07:03:28 <HugoDaniel> ah, thankyou bennofs, i was wondering "why use this instead of primops?"
07:04:23 <bennofs> HugoDaniel: the primitive package already wraps the primops in ST/IO and also makes handling the Int -> Int# etc conversation nicer iirc
07:07:11 <yesthisisuser> srhb: I think was luite was saying answers my question. I was thinking of e.g., if you have a function f :: a -> Text; f = null and import null from both Text and Prelude
07:07:41 <yesthisisuser> or f _ = null .. i guess..
07:07:46 <srhb> yesthisisuser: OK, I misunderstood then. :)
07:08:12 * hackagebot unsafely 0.2.0.0 - Flexible access control for unsafe operations and instances  http://hackage.haskell.org/package/unsafely-0.2.0.0 (HiromiIshii)
07:33:14 * hackagebot machines-directory 0.0.0.1 - Directory (system) utilities for the machines library  http://hackage.haskell.org/package/machines-directory-0.0.0.1 (aloiscochard)
07:38:14 * hackagebot buildbox 2.1.4.3 - Rehackable components for writing buildbots and test harnesses.  http://hackage.haskell.org/package/buildbox-2.1.4.3 (BenLippmeier)
07:43:15 * hackagebot ghcjs-dom 0.1.1.0 - DOM library that supports both GHCJS and WebKitGTK  http://hackage.haskell.org/package/ghcjs-dom-0.1.1.0 (HamishMackenzie)
07:43:17 * hackagebot machines-io 0.1.0.0 - IO utilities for the machines library  http://hackage.haskell.org/package/machines-io-0.1.0.0 (aloiscochard)
07:43:19 * hackagebot ghcjs-dom-hello 1.2.0.0 - GHCJS DOM Hello World, an example package  http://hackage.haskell.org/package/ghcjs-dom-hello-1.2.0.0 (HamishMackenzie)
07:43:21 * hackagebot wai-app-static 2.0.1.1 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-2.0.1.1 (MichaelSnoyman)
07:46:53 <mads-> So I have this code : http://ideone.com/xJoSFf - when trying to compile it gives me an error on line 63 "parse error in pattern: char - Possibly caused by a missing 'do'". I don
07:47:05 <mads-> I have no idea what I'm missing. Can anyone give a pointer?
07:49:37 <marchelzo_> what does the | m -> r mean in: MonadReader r m | m -> r?
07:50:03 <dario> mads-: (at least in the paste) it looks like you indented all the lines following "char '(' one space more, so the lexer doesn't recognize it should be one block
07:50:09 <silver> mads-, try removing spaces on lines after "do char '("' line
07:50:39 <silver> leading spaces
07:50:46 <silver> 1 of them
07:50:51 <silver> on each line
07:52:02 <luite> marchelzo_: it's a functional dependency, it means that r is determined by m, i.e. there can only be one r for a given m
07:53:28 <mads-> dario and silver so I should have char '(' aling with the rest of the following lines?
07:53:41 <silver> yes
07:53:56 <silver> so it's one block
07:54:26 <mads-> Then it gives me another error. test.hs:64:13: parse error on input ‘x’
07:54:58 <silver> http://ideone.com/7FlXyW
07:58:46 <mads-> silver: thanks. Now it's complaining some other places as well :) gonna try and fix up the indentation.
08:08:17 * hackagebot websockets 0.9.0.0 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.9.0.0 (JasperVanDerJeugt)
08:11:30 <conal> does anyone whether haddock generation on hackage is broken? the recent package releases i've looked at lack docs.
08:12:50 <nshepperd> yes, t's borked
08:13:17 * hackagebot websockets-snap 0.9.0.0 - Snap integration for the websockets library  http://hackage.haskell.org/package/websockets-snap-0.9.0.0 (JasperVanDerJeugt)
08:20:11 <danilo2> Hello! I'm writing a parser using trifecta and parsers and I'm wondering if anyone has any usage example of "IdentifierStyle" (http://hackage.haskell.org/package/parsers-0.12.1/docs/Text-Parser-Token.html#g:5) ?
08:32:01 <edwardk> danilo2 https://github.com/ermine-language/ermine/blob/master/src/Ermine/Parser/Style.hs#L36
08:32:56 <danilo2> edwardk: Ok, thank you!
08:32:58 <sshine> so if a state monad has the signature s -> (a, s) and a reader monad has the signature e -> a, and you only rarely return the full state, why not simply always use reader monads and end your computation with a call to 'ask'?
08:33:21 <edwardk> sshine: you can 'embed' a reader style calculation into state
08:33:31 <edwardk> for that sort of scenario
08:33:41 <edwardk> where you want to know you have a thing that would commute with other 'readers'
08:34:08 <sshine> edwardk, I don't get that. with s -> (a, s) I sort of have (s ->) as a reader, don't I?
08:34:55 <edwardk> sshine: what i mean is that you can get what you want by defining something like readerState :: (s -> a) -> s -> (a, s) -- by doing what you want, now you have a combinator that takes reader actions and embeds them into state
08:35:01 <edwardk> it does exactly what you want
08:35:23 <edwardk> er (s -> a) -> State s a
08:35:54 <sshine> so Reader s a -> State s a? :P
08:35:56 <edwardk> readerState f = state $ \s -> (f s, s)
08:36:01 <edwardk> yes
08:36:17 <edwardk> but you need the wrapper on State, but there are MonadReader instances for (->) s ;)
08:36:30 <edwardk> er you only need
08:38:19 * hackagebot leksah 0.14.1.0 - Haskell IDE written in Haskell  http://hackage.haskell.org/package/leksah-0.14.1.0 (HamishMackenzie)
08:39:01 <sshine> edwardk, I see how what you're saying is possible, but why not simply use 'Reader s a' and end your blob of actions with an 'ask'? (I think I figured out an answer to my own question: you wouldn't be able to do 'do { foo; bar }' and have foo change the environment for bar.
08:40:05 <edwardk> sshine: state is bigger than reader, you can write that you described, but it is exactly the behavior that readerState does. readerState encapsulates the 'design pattern' you describe as a combinator so you don't have to keep repeating it.
08:40:45 <edwardk> and the idiom you are describing only works within the reader components
08:43:19 * hackagebot persistent 2.0.5 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-2.0.5 (GregWeber)
08:43:21 * hackagebot persistent-mongoDB 2.0.5 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-2.0.5 (GregWeber)
08:43:23 * hackagebot persistent-mysql 2.0.5 - Backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-2.0.5 (GregWeber)
08:43:25 * hackagebot persistent-postgresql 2.0.5 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-2.0.5 (GregWeber)
08:43:27 * hackagebot persistent-sqlite 2.0.5 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-2.0.5 (GregWeber)
08:43:42 <sshine> edwardk, cool! I had to think it over. so the neat thing is that you get reader capabilities on the same type/value that is the state.
08:46:42 <dfeuer> WarzoneCommand, as others have shown me, the profiler can't be trusted if optimization is on :-/
08:47:36 <sshine> edwardk, thanks :)
08:48:13 * dfeuer replaces divMod with something else by executive fiat.
08:48:29 * hackagebot persistent-template 2.0.5 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-2.0.5 (GregWeber)
08:48:31 * hackagebot codex 0.2.0.0 - A ctags file generator for cabal project dependencies.  http://hackage.haskell.org/package/codex-0.2.0.0 (aloiscochard)
08:53:20 * hackagebot vimus 0.1.0.1 - An MPD client with vim-like key bindings  http://hackage.haskell.org/package/vimus-0.1.0.1 (SimonHengel)
08:53:22 * hackagebot wai-websockets 3.0.0.2 - Provide a bridge betweeen WAI and the websockets package.  http://hackage.haskell.org/package/wai-websockets-3.0.0.2 (MichaelSnoyman)
08:58:20 * hackagebot WAVE 0.1.2 - WAVE audio file IO library  http://hackage.haskell.org/package/WAVE-0.1.2 (BartonMassey)
09:00:22 <oakwhiz> ^ wave just got updated
09:00:27 <oakwhiz> that's good
09:11:43 <EvanR> trying to read the source code to figure out how the basic Rand monad works. i could write it myself to see, but thought id check the package. it uses RandT which itself is defined by StateT using generalized newtype deriving ;)
09:11:48 <EvanR> very clear
09:12:30 <EvanR> transformer sound effect
09:12:49 <monochrom> just yesterday I used generalized newtype deriving for a newtype over ContT.
09:13:21 * hackagebot shell-conduit 2.0 - Write shell scripts with Conduit  http://hackage.haskell.org/package/shell-conduit-2.0 (ChrisDone)
09:15:05 <Twey> http://lpaste.net/111373 — how can I get this type to fit?  It evaluates T Bar to Baz Bar, and then complains that Baz Bar ≠ T Bar
09:15:46 <Twey> (in the definition of quux)
09:16:10 <monochrom> Baz and Bar look too alike visually
09:16:14 <Twey> Sorry :þ
09:16:37 <monochrom> I wish programmers did not continue "foo bar" with "baz"
09:17:11 <EvanR> i was thinking that its not that easy for haskell noobs to figure out all this stuff by reading the source, but maybe exposure to the full power of ghc is good for people who need a lot ot consider at once
09:17:19 <Twey> monochrom: http://lpaste.net/111374
09:17:22 <Hafydd> I wish programmers did not continue "" with "foo" and "foo bar".
09:17:33 <monochrom> nice, thanks
09:19:09 <monochrom> this is Quux saying "T /= Bar". this is independent of "T Authur = Bar Authur".
09:19:34 <monochrom> you're having "(Quux T) Arthur" not "Quux (T Authur)"
09:20:03 <Twey> monochrom: But it only wants Bar because it's seeing that bar ∷ Bar Arthur, right?
09:21:11 <Twey> monochrom: bar :: T Arthur, so I'd expect that Quux bar :: Quux T Arthur
09:21:30 <Twey> (if not by default, at least with the type annotations)
09:21:47 <monochrom> you could "bar = undefined" to test your hypothesis
09:22:01 <fiatjaf> anyone using this? http://elm-lang.org/
09:22:09 <Twey> monochrom: Same error, but what does that tell me?
09:22:17 <Twey> monochrom: Bar :: T Arthur is fine
09:22:45 <Twey> monochrom: More-M WE: http://lpaste.net/111374
09:23:22 * hackagebot WAVE 0.1.3 - WAVE audio file IO library  http://hackage.haskell.org/package/WAVE-0.1.3 (BartonMassey)
09:23:42 <monochrom> no, I really want "bar = undefined".
09:23:54 <Twey> Oh, you mean in Quux
09:24:10 <Twey> monochrom: That compiles (quux = Quux undefined)
09:24:35 <monochrom> no, not in Quux. I seriously want "bar :: T Arthur; bar = undefined"
09:24:53 <Twey> monochrom: Sure.  I did that.  It gave the same error.
09:25:06 <Twey> I'm just confused as to why you asked for it
09:26:40 <Twey> I find it interesting that `Quux undefined` typechecks, but `Quux (undefined :: T Arthur)` doesn't.
09:27:00 <Twey> What could it be inferring for the type of undefined in the former case?
09:27:33 <coppro> Twey: your lpaste expired.
09:27:38 <monochrom> put a type hole there and ask ghc
09:27:42 * Twey blinks.
09:27:47 <Twey> coppro: I didn't know that happened
09:27:53 <Twey> monochrom: It says it wants ‘T Arthur’ there.
09:28:09 <Twey> monochrom: But if I put (undefined :: T Arthur) in, it doesn't type-check.
09:29:16 <Twey> (with the error given before)
09:29:31 <monochrom> can one say that T's kind is * -> * ? I think not.
09:29:34 <uiiuiu> Twey: You don't need to use the value constructor with undefined
09:29:56 <uiiuiu> Twey: just specify a type like this: undefined :: Type.
09:30:57 <Twey> *Main> :k T
09:30:59 <Twey> T :: * -> *
09:31:01 <Twey> uiiuiu: Sorry?
09:32:15 <lostman> is there any way to distribute compiled libraries? I've been banging my head against the wall trying to figure this out. Same architecture, same location; Just want to unpack a bunch of pre-built libraries and be done with it
09:32:39 <Twey> coppro, monochrom: http://lpaste.net/111376
09:32:42 <Fuuzetsu> saying what your problem is might be of help, lostman
09:33:29 <uiiuiu> Twey: Quux undefined typechecks because undefined has type a, which matches every type.  Quux (undefined :: T Arthur) doesn't because either the value constructor Quux doesn't accept the type T Arthur or T Arthur is an invalid type itself.
09:34:14 <Twey> uiiuiu: Nope, T Arthur is the type that GHC wants at this point — see the hole output in http://lpaste.net/111376
09:34:19 <coppro> Twey: still not seeing it
09:34:23 <danilo2> Hello! I'm using trifecta to create a parser. I'm using the IdentifierStyle to specify identifier parser. But when I'm trying to parse a simple program using "ident identStyle *> char 'a'" it parses ok, but also prints " error: unspecified error" What can cause the error? (cc: edwardk)
09:34:24 <lostman> Fuuzetsu: I want to be able to deploy an app to a server and want it to be quick. 'cabal sandbox init && cabal install' takes annoyingly long and if I delete my sandbox I have to start from scratch
09:34:31 <uiiuiu> Twey, sorry I cannot open the link right now.
09:34:36 <Fuuzetsu> Twey: your link is blank
09:34:38 <lostman> after compiling haskell-src-exts for N-th time, I'm getting a bit tired of this
09:34:47 <Twey> Hang on, I don't understand what's going on with lpaste
09:34:58 <uiiuiu> Try dpaste or some such.
09:35:17 <Twey> uiiuiu, monochrom, coppro: http://hastebin.com/oveqovutiw.hs
09:36:29 <Twey> Fuuzetsu: ^
09:36:50 <coppro> Twey: T is an argument to Quux
09:37:02 <Twey> coppro: Right
09:37:04 <coppro> Quux T Arthur is a different type from Quux Bar Arthur
09:37:19 <Twey> coppro: Right
09:37:59 <coppro> Quux (undefined :: T Arthur) causes "T Arthur" to be normalized, so the result is of type Quux Bar Arthur, which does not unify to Quux T Arthur
09:38:08 <Twey> coppro: Right.
09:38:49 <Twey> I would like to prevent that normalization somehow so I can construct a value of type Quux T Arthur
09:39:02 <Twey> (and I find it interesting that the normalization doesn't occur if I don't give a type annotation)
09:39:41 <coppro> There's nothing to normalize
09:39:54 <coppro> You would have to put the annotation on the outside to make it work, I think
09:40:01 <coppro> (Quux undefined :: Quux T Arthur)
09:40:42 <Twey> coppro: Right, but why?  Why doesn't it normalize the type after inference just the same as if I had given the type myself?  I find this behaviour highly counter-intuitive.
09:41:25 <coppro> Twey: I need to go do a few things. I can try to explain afterward. Or maybe someone else will beat me to it
09:41:57 <Twey> coppro: I think I understand what's happening; I just don't understand the rationale behind it.
09:42:09 <Twey> (or how I can get around it to construct a value of the type I gave without using undefined, more importantly)
09:43:24 * hackagebot truelevel 0.1.3 - Audio file compressor-limiter  http://hackage.haskell.org/package/truelevel-0.1.3 (BartonMassey)
09:44:40 <danilo2> Hello! Woiuld somebody be so nice and look at this simple trifecta parser? It outputs an error, but should not. Whats funny - it parses the string correctly: http://lpaste.net/111378
09:47:54 <vanila> I there a book that walks you through writing a compiler for a functional language?
09:47:58 <danilo2> ahh nvm - the parser is ok, the word was reserved, stupid me :D
09:48:51 * geekosaur was just about to ask about that
09:49:13 <geekosaur> still, "unspecified error" is kinda poor for that
09:49:52 <silver> vanila, for basic stuff see http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
09:50:28 <vanila> silver, Isn't that just an interpreter?
09:53:22 <silver> vanila, yeah
09:54:09 <vanila> I've got interpreters ok mostly I think
09:55:20 <exio4> an "naive" interpreter is actually really easy to write in haskell, just take a tree and 'evaluate' it!
09:55:23 <exio4> a*
09:56:39 <vanila> but then how could I write a compiler?
09:56:56 <vanila> for a simple FP lang
09:57:45 <EvanR> theres a book you can read, implementation of functional programming languages
09:58:19 <EvanR> about making machine code for a functional program
09:59:12 <silver> well, you can make interpreter into the compiler just by interpreting a string without interactivty (aside from input)
10:00:15 <EvanR> i assumed he wanted to go all the way in some sense and would not be satisfied with way easier ways to interpret "compiler"
10:00:24 <bvad> Hey, I'm having a small problem with haskell-mode in emacs. It seems as if flycheck/flymake doesn't locate modules only installed in my cabal sandbox. C-c C-c and C-c C-l works fine
10:00:37 <bvad> Any ideas what's causing it?
10:01:31 <simpson> silver, EvanR, vanila: Partial evaluation is a cheap and easy way to generate a compiler from an interpreter. Note, however, that making an *efficient* partial evaluator is very difficult.
10:01:35 <coppro> Twey: So I don't know if GHC could delay the normalization there. But in general, that wouldn't really help
10:02:00 <coppro> It's just special casing what is ultimately an undecidable unification, so GHC doesn't attepmt it
10:03:24 <silver> and this might interest you: https://www.coursera.org/course/compilers https://github.com/steshaw/plt-study#compiler-construction
10:03:25 * hackagebot sounddelay 0.1.0.1 - Audio delay line  http://hackage.haskell.org/package/sounddelay-0.1.0.1 (BartonMassey)
10:03:27 * hackagebot STL 0.2.0.2 - STL 3D geometry format parsing and pretty-printing  http://hackage.haskell.org/package/STL-0.2.0.2 (bergey)
10:03:35 <silver> vanila, ^
10:04:36 <vanila> cheers!
10:04:51 <vanila> simpson, I love the sound of that and i want tto try it but first i want to try more standard technique
10:05:16 <Angee23>  Here some videos. I hope you like them! http://tinyurl.com/ozfvxy3
10:07:05 <Fuuzetsu> that spammer sure is persistent
10:07:38 <monochrom> one day, we may see: "<JudiDench80> Here are some videos. I hope you like them!"
10:07:42 <oleo> lol
10:09:16 <oakwhiz> here are some monads, I hope you like them
10:10:01 <oleo> oaakaaaaaayyyyy, we're convinced of you pussies........
10:10:03 <Fuuzetsu> if they named themselves MonadProfunctor23 they might get more clicks
10:10:05 <oleo> lol
10:13:26 * hackagebot truelevel 0.1.3.1 - Audio file compressor-limiter  http://hackage.haskell.org/package/truelevel-0.1.3.1 (BartonMassey)
10:14:01 <simpson> Man, Bart's on a roll today.
10:18:26 * hackagebot sounddelay 0.1.0.2 - Audio delay line  http://hackage.haskell.org/package/sounddelay-0.1.0.2 (BartonMassey)
10:28:42 <danilo2> Helo! Could anybody give me any hints what is the best method to use two state monads over Trifecta parser? One of them would handle indentations and I want it to be a separate library, and the other is just normal parsing state.
10:40:55 <Cale> danilo2: You probably mean two state (monad transformers). You can simply apply two StateT's but having a subtle distinction between get and lift get is a bit obnoxious. You might instead want to make a new transformer, which is a newtype of StateT itself, and new operations in place of get/put which are specialised better to the operations you'd be doing with indentation.
10:42:25 <danilo2> Cale: Oh, making newtype of StateT would be easy. I was thinking about writing something like that from scratch, but this way its a lot simplier, thank you :)
10:43:16 <heiz> hello! Tell me please how this class should be defined correctly "class CostFunction f a b => GradientDescent f a where grad :: f -> a -> f". Obviously that type variable `b' is not in scope, but class GradientDescent in my mind should be parametried only with f and a.
10:43:57 <Cale> heiz: Well, not knowing what CostFunction is, it's hard to make a recommendation there
10:44:07 <Cale> Did you perhaps mean CostFunction f a a?
10:44:36 <heiz> Sorry, "class CostFunction f a b | f a -> b where ..."  here it is
10:44:45 <Cale> Ah, I see
10:44:58 <Cale> That's actually quite interesting
10:45:09 <Cale> You might be better off making b an associated type
10:45:15 <Cale> i.e.
10:45:38 <Cale> class CostFunction f a where type B f a; ...
10:45:43 <hexagoxel> danilo2: also, there is multistate package (disclaimer: self-promotion)
10:45:54 <Cale> (you probably have a better name than B)
10:46:40 <Cale> and then use B f a in place of occurrences of b in the remainder of the definition of course
10:47:10 <heiz> that makes sense. I'll think about it. Thank you.
10:47:57 <danilo2> hexagoxel: Oh, that is very nice, thank you
10:52:38 <dfeuer> @tell edwardk Is there a reason Data.List.NonEmpty doesn't have ++?
10:52:38 <lambdabot> Consider it noted.
10:53:22 <prophile> dfeuer: there's (<>)
10:53:29 <dfeuer> Ah, good point.
10:54:04 <jackdempsey> hey folks, working through http://www.seas.upenn.edu/~cis194/hw/04-poly.pdf for some fun, exercise 14 at the moment. I can get it done using allCaps = map (isUpper . fromJust . safeHead) but the fromJust feels wrong
10:54:22 <jackdempsey> then again, given his seeming desire for the use of safeHead I can’t really avoid it can I?
10:55:05 <Qfwfq> fromJust . safeHead == head
10:55:40 <prophile> :t all
10:55:41 <lambdabot> (a -> Bool) -> [a] -> Bool
10:56:11 <Fuuzetsu> if only it was called safeHead
10:56:12 <monochrom> map (isUpper . fromJust . safeHead) ["", "Blah"] will have a problem. see the 3rd test case given.
10:56:12 <prophile> :t maybe
10:56:13 <lambdabot> b -> (a -> b) -> Maybe a -> b
10:56:17 <Fuuzetsu> :t listToMaybe
10:56:18 <lambdabot> [a] -> Maybe a
10:56:21 <Fuuzetsu> who thought that was a good idea!
10:56:32 <monochrom> therefore, clearly you cannot use fromJust.
10:56:40 <prophile> :t maybe False isUpper
10:56:41 <lambdabot> Maybe Char -> Bool
10:56:51 <notdan> :t maybe False isUpper
10:56:51 <lambdabot> Maybe Char -> Bool
10:56:52 <Revol> :t maybe False isUpper
10:56:53 <lambdabot> Maybe Char -> Bool
10:57:13 <prophile> we have established that :t does not change between runs
10:57:30 <StoneToad> wait, you must always run 3 tests!
10:57:32 <monochrom> in fact, safeHead is exactly right, it gives you all necessary information
10:58:17 <Qfwfq> 'fmap isUpper . safeHead' indicates everything you care about with one value, I think.
10:59:48 <Sorella> prophile: but no one knows when an alien from the sky might shot down their lasers in the right position, at the right time, to flip lambdabot's result for :t, it's still possible! :)
11:00:04 <prophile> only #haskell would be so vigilant
11:00:36 <geekosaur> cosmic rays, man >.>
11:05:01 <dfeuer> We need a Semigroup => Monoid proposal, don't we?
11:05:10 <dfeuer> Yes, yes we d.
11:05:12 <dfeuer> do.
11:05:38 <jackdempsey> @monochrom thanks, taken away for a sec, but appreciate you responding
11:05:38 <lambdabot> Unknown command, try @list
11:06:54 <dfeuer> jackdempsey, you mean @tell monochrom
11:08:48 <exio4> @pl \f1 x y z -> f1 x x x y y y z z z x x x
11:08:50 <lambdabot> join . ((flip . (flip .)) .) . join . ((flip . (flip .)) .) . join . ((flip . (flip .)) .) . flip flip id . ((flip . (ap .)) .) . flip flip id . ((flip . (ap .)) .) . flip flip id . (ap .) . flip flip id . (ap .) . join . join
11:09:05 <monochrom> no, just delete the @
11:09:56 <monochrom> I wouldn't want to say "this is not twitter" otherwise, but @ is already taken by lambdabot here, and lambdabot was here before twitter
11:10:30 <monochrom> twitter as the latecomer should simply have avoided clashing with lambdabot's convention!
11:11:00 <jackdempsey> catching up here…just made obvious realization that fromJust Nothing es no bueno
11:11:02 <Qfwfq> dfeuer: We need a Magma proposal, with the same interface as Semigroup.
11:12:20 <tac_> We need a proposal for a class with a binary operation with identity that need not be associative!
11:12:33 <tac_> What are subtraction and exponentiation to do is this semigroup-biased world?
11:12:54 <tac_> and division too
11:13:00 * Qfwfq giggles
11:13:10 <jackdempsey> and duh re: @, don’t IRC much these days.
11:18:08 <zq> does haskell permit unicode escapes in string literals? like "\uNNNN"
11:20:15 <mauke> just use normal escapes
11:20:23 <mauke> haskell strings are unicode anyway
11:21:04 <Fuuzetsu> > length "\uNNNNabc"
11:21:05 <lambdabot>  <hint>:1:10:
11:21:05 <lambdabot>      lexical error in string/character literal at character 'u'
11:21:22 <zq> i'm not sure what that means. what's the syntax for a character literal, say, \u00A0?
11:21:34 <mauke> > '\128'
11:21:35 <lambdabot>  '\128'
11:21:41 <zq> so it's base 10?
11:21:44 <zq> ugh
11:21:48 <mauke> yes, of course
11:21:53 <mauke> > "\xa0"
11:21:54 <lambdabot>  "\160"
11:22:02 <mauke> use \x if you want hex
11:22:40 <monochrom> \u00A0 is just some other programming languages' notation
11:22:40 <zq> thank you.
11:23:14 <monochrom> for a non-partisan notation, use the official unicode notation: U+00A0
11:26:12 <zq> monochrom: i love my shift key too much for that
11:27:30 <mauke> I also like perl's notation: \x{a0}
11:29:19 <Haskellfant> i'm reading through the concurrent part of parallel and concurrent programming in haskell and i've got a question about thread leakage: here http://chimera.labs.oreilly.com/books/1230000000929/ch11.html#sec_conc-withasync it says that the thread of async would be leaked if the main thread got an exception, does that mean that killing the main thread does not automatically kill all spawned threads or could
11:29:21 <Haskellfant> this only occur in a more complex example where we are not talking about the main thread immediately exiting
11:30:24 <allyraza> hello
11:30:27 <allyraza> everyone
11:30:39 <allyraza> I am trying to install snap
11:30:55 <jackdempsey> prophile: just seeing your :t lines now. had no idea there was a lowercase maybe
11:31:45 <allyraza> the package has been installed successfully but when I cannot run it form the command line
11:31:46 <jackdempsey> where is that even from?
11:32:18 <mauke> @index maybe
11:32:18 <lambdabot> Data.Maybe, Prelude
11:33:07 <RedNifre> > "\U+1E9E"
11:33:08 <lambdabot>  <hint>:1:3:
11:33:08 <lambdabot>      lexical error in string/character literal at character 'U'
11:33:32 * hackagebot keter 1.3.4 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-1.3.4 (MichaelSnoyman)
11:33:40 <mauke> > "\x1E9E"
11:33:41 <lambdabot>  "\7838"
11:33:50 <allyraza> anyone guys?
11:33:59 <Fuuzetsu> Haskellfant: leaked as in you can't get back at it from your program; your OS will clean such rogue threads when your main exits
11:34:05 <vanila> allyraza, maybe ~/.cabal/bin/snap ?
11:34:24 <allyraza> vanila: there is no bin under .cabal
11:34:43 <vanila> hm that's what I use, sorry i don't know any other ideas
11:35:39 <Fuuzetsu> Haskellfant: but reading that again, maybe I'm wrong ;)
11:35:39 <geekosaur> os x? ~/Library/Haskell/bin
11:36:15 <hexagoxel> > text "\x1E9E"
11:36:16 <lambdabot>  ẞ
11:36:18 <RedNifre> > "\x10330"
11:36:19 <lambdabot>  "\66352"
11:36:29 <Haskellfant> Fuuzetsu: isn't this using the threads of haskell instead of os threads? so how can the os clean those up
11:36:49 <RedNifre> does lambdabot output UTF-8?
11:37:05 <Fuuzetsu> RedNifre: always
11:37:21 <mauke> > text "\66352"
11:37:22 <lambdabot>  𐌰
11:37:35 <RedNifre> Oh, that one works.
11:37:48 <RedNifre> Guess I have no 1E9E in my font.
11:38:01 <RedNifre> > text "\20AC"
11:38:02 <lambdabot>  AC
11:38:08 <RedNifre> > text "\x20AC"
11:38:09 <lambdabot>  €
11:38:23 <mauke> it's the other way round here
11:38:34 <mauke> 1E9E seems to be an uppercase ß
11:38:54 <RedNifre> It is. And 10330 is a gothic letter A, which works on my machine.
11:39:00 <benmachine> I didn't know there *was* an uppercase ß
11:39:39 <hexagoxel> but, all the words starting with ..!
11:39:46 <dfeuer> @tell thomie, is that MIN_VERSION_base CPP macro going to be defined everywhere it needs to be?
11:39:46 <lambdabot> Consider it noted.
11:40:03 <mauke> you better hope @tell has a smart nick parser
11:40:12 <mauke> otherwise it's going to look for someone named "thomie,"
11:40:20 <dfeuer> @tell thomie is that MIN_VERSION_base CPP macro going to be defined everywhere it needs to be?
11:40:21 <lambdabot> Consider it noted.
11:40:28 <dfeuer> Whoops.
11:40:40 <mauke> STRAẞE
11:40:44 <dfeuer> Thank you, mauke.
11:40:53 <mauke> (also, @ask exists :-)
11:41:22 <dfeuer> mauke, I know, but I've never used it; I assume it's just another name for @tell?
11:42:09 <thomie> dfeuer: it's used everywhere, so I guess so
11:42:56 <dfeuer> thomie, I just don't know much about the CPP environment, and whether it will be defined in those other projects you linked me to on github.
11:43:45 <mauke> @tell dfeuer a statement
11:43:45 <lambdabot> Consider it noted.
11:43:48 <mauke> @ask dfeuer a question?
11:43:49 <lambdabot> Consider it noted.
11:44:06 <mauke> I guess you're going to find out :-)
11:44:23 <allyraza> I am having trouble with snap package
11:44:32 <hexagoxel> @tell hexagoxel, lets test both the self-message and the nick parser
11:44:32 <lambdabot> Consider it noted.
11:44:46 <allyraza> anybody? I tried #snapframework but not luck channel is dead
11:44:53 <allyraza> no*
11:45:00 <hexagoxel> ah, nickparser failed
11:45:07 <sivteck> allyraza, did you use sandbox?
11:45:08 <dfeuer> @messages
11:45:38 <allyraza> sivteck: no
11:45:57 <allyraza> I just installed haskell and cabal install
11:46:02 <allyraza> snap
11:46:46 <dfeuer> thomie, it looks like that might only work in the GHC stuff. I guess I'll need to use the compiler version as a proxy?
11:47:35 <danilo2_> Hello! Does Trifecta / parsers have any operator precedence parser built in like the parsec? Or do I have to built it from scratch ?
11:48:41 <thomie> dfeuer: grep -R -l 'MIN_VERSION_base' * | awk -F '/' '{print $1}'  | sort | uniq
11:49:21 <mizu_no_oto> danilo2_: you might try asking edwardk.
11:49:54 <sivteck> allyraza, i am not sure, but try cabal exec sh and snap init
11:50:07 <dfeuer> thomie, I don't understand what point you're trying to make.
11:50:26 <thomie> dfeuer: it's already used in those packages, so you can use it too
11:50:41 <dfeuer> Ohhhh.
11:50:43 <thomie> dfeuer: I believe it's a cabal macro actually
11:50:45 <dfeuer> OK.
11:51:10 <mizu_no_oto> I'm trying to run a test in a cabal sandbox.  When running "cabal test", I'm getting the error "<command line>: cannot satisfy -package-id mypackage-0.1.0.0-inplace".  Anyone have any clue what I'm doing wrong?
11:51:10 <dfeuer> I guess if they've gone and joined some shady cabal, we'll just let them be that way.
11:52:01 <jackdempsey> > (maybe True isUpper) (Just 'h')
11:52:03 <lambdabot>  False
11:52:11 <jackdempsey> > (maybe True isUpper) (Nothing)
11:52:13 <lambdabot>  True
11:52:34 <jackdempsey> the second surprises me a bit…
11:52:52 <jackdempsey> is it a sort of vacuous truth?
11:53:04 <monochrom> maybe True isUpper x = case x of Nothing -> True
11:53:32 <RedNifre> a missing text is actually all upper case. and also all lower case.
11:53:42 <benzrf> jackdempsey: what's surprising about it
11:53:46 <monochrom> you have to choose between vacuous truth and vacuous falsehood
11:53:52 <jackdempsey> yea
11:54:11 <benzrf> jackdempsey: it's Nothing, so it uses the default...
11:54:21 <benzrf> > maybe False isUpper Nothing
11:54:22 <lambdabot>  False
11:54:24 <RedNifre> You don't ask "Do I have an uppercase string?", you ask "Is this text uppercase?" to which the answer is "yes" if there is no text.
11:54:50 <monochrom> vacuity is not the only strange corner case.
11:54:53 <hexagoxel> allyraza: you could just use "cabal install -v2" to get a bit more info about where it puts stuff..
11:54:55 <jackdempsey> RedNifre: not sure i agree but doesn’t matter :-)
11:55:17 <monochrom> monochrom exists uniquely and therefore "monochrom is the best monochrom" and "monochrom is the worst monochrom" are both true, too :)
11:56:02 <allyraza> hexagoxel: does not show anything
11:56:15 <allyraza> about paths
11:57:55 <RedNifre> If somebody asks you "Did you return the lawn mower?" and you don't recall having borrowed one, you can answer "yeah, sure" ;)
11:58:34 * hackagebot basic-prelude 0.3.9 - An enhanced core prelude; a common foundation for alternate preludes.  http://hackage.haskell.org/package/basic-prelude-0.3.9 (MichaelSnoyman)
11:58:53 <jackdempsey> ok so this works
11:58:54 <jackdempsey>  all id $  map ((maybe False isUpper) . safeHead)
11:58:58 <benzrf> monochrom: my mother was an only child and apparently her father would introduce her as 'his eldest daughter'
11:59:10 <jackdempsey> the maybe True being different than maybe False bit also surprised me
11:59:18 <jackdempsey> hahaha
11:59:19 <monochrom> but you don't have to answer. you can ask back instead. "did I borrow the lawn mower?" it is usually wiser to ask back instead of answer.
11:59:20 <thomie> dfeuer: http://www.haskell.org/cabal/users-guide/developing-packages.html#conditional-compilation
12:00:19 <hexagoxel> allyraza: huh i just tried that for some random package, and there was lots of stuff, including paths.
12:01:19 <danilo2_> mizu_no_oto: Ok, I'll ask him :)
12:01:28 <danilo2_> edwardk: Does Trifecta / parsers have any operator precedence parser built in like the parsec? Or do I have to built it from scratch ?
12:01:29 <allyraza> hexagoxel: okay I tried cabal install -v2 now it diplays package name
12:01:34 <allyraza> but no path
12:01:49 <simpson> danilo2_: Yeah, it does
12:02:04 <edwardk> danilo2_: http://hackage.haskell.org/package/parsers-0.12.1/docs/Text-Parser-Expression.html
12:02:41 <simpson> danilo2_: https://hackage.haskell.org/package/parsers-0.12.1/docs/Text-Parser-Expression.html
12:02:50 <simpson> Curses, foiled again.
12:02:52 <danilo2_> edwardk: Ahh, I somehow missed that. Sorry for such straightforward question and thank you!
12:02:53 <hexagoxel> allyraza: ah, sorry, i meant "cabal install -v2 snap"
12:03:09 <simpson> Stupid slow SSH connection. :T
12:03:11 <danilo2_> simpson: thank you also! :)
12:03:15 <allyraza> hexagoxel: that's what I tried
12:03:32 <allyraza> Reading available packages...
12:03:32 <allyraza> Choosing modular solver.
12:03:33 <allyraza> Resolving dependencies...
12:03:34 <allyraza> All the requested packages are already installed:
12:03:36 <allyraza> snap-0.13.2.9
12:03:38 <allyraza> Use --reinstall if you want to reinstall anyway.
12:03:40 <allyraza> World file is already up to date.
12:03:44 <allyraza> sorry
12:04:16 <joyfulmantis> If I want to install a cabal package from source, and I already have all of its dependencies,  I just do 'cabal build' in the source directory right?
12:04:29 <monochrom> cabal is like IO actions. different people running the same command get different results.
12:05:04 <RedNifre> jackdempsey OTOH if you go out eating something with your friends, when you are finished and want to check if you all can leave and you ask "Did everybody finish their meal?" and everyone answers "yes", even the ones that weren't hungry and didn't actually HAVE a meal, an all yes answer is more useful than dealing with "I can't answer that" "Why not?" "Because I didn't have a meal" "Arg!".
12:06:05 <jackdempsey> Sure!
12:06:07 <jackdempsey> all depends on context
12:06:17 <hexagoxel> (hmm interesting; while cabal does not register executables, it won't reinstall an executable if the corresponding library is already installed? thats rather inconsistent..)
12:06:25 <jackdempsey> it was surprising to me that in teh context of no char isUpper would say sure, Nothing is capatilized
12:06:32 <jackdempsey> maybe it’s just looking at the N
12:06:33 <jackdempsey> ;-)
12:06:50 <monochrom> if you go out eating with your friends, you easily see who have meals and who don't have meals, and can filter out whatever the latter say.
12:07:07 <monochrom> it is not like you're IRCing with your friends and therefore cannot see.
12:07:11 <dv-> > isUpper Nothing
12:07:12 <lambdabot>  Couldn't match expected type ‘GHC.Types.Char’
12:07:13 <lambdabot>              with actual type ‘Data.Maybe.Maybe a0’
12:07:51 <jackdempsey> if someone asks if I have a million dollars in my bank accoutn and i don’t have a bank account “yes” seems wrong :-)
12:08:20 <jackdempsey> still need to review the maybe True isUpper and maybe False isUpper. can’t say i grok that yet. also watching my son so…hard to keep cogent thought
12:08:29 <RedNifre> "Yes, I actually have a milion dollars in each of my bank accounts!"
12:09:15 <exio4> and now 2==3?
12:10:36 <RedNifre> You can't get 2==3 since saying "One of my bank accounts has 2 dollars and another one has 3" would be wrong if you don't have a bank account.
12:12:07 <RedNifre> But, yeah, it would be more practical to have hasAMillionDollarInOneOfHisAccounts :: Person -> Maybe Boolean
12:12:32 <hexagoxel> allyraza: well, one option is cabal install -v3 --reinstall snap, just to get the info. but that may break stuff, and there might be better ways to proceed. hard to diagnose with the info given.
12:12:55 <Fuuzetsu> RedNifre: True | False | AccountNotFound
12:13:05 <RedNifre> As in "Nothing" meaning "While it would be logically possible to answer that question, I prefer to not answer it because the question probably makes no sense in any context"
12:13:42 <RedNifre> AccountNotFound is not a good answer to the question "does he have a million dollars in his account?"
12:13:47 <allyraza> hexagoxel: I removed everything going to do a fresh install
12:13:54 <allyraza> upgrading to 7.8.3
12:13:57 <allyraza> thank you!
12:13:58 <RedNifre> I prefer Nothing as in "No Answer"
12:14:07 <Fuuzetsu> RedNifre: The fundamental problelm here is that you already assume the person has a bank account so you failed on that front
12:14:22 <joyfulmantis> guys I want to install a dependendecy for an install using 'cabal install' from source, how would I do that and get cabal to recognize it?
12:14:25 <Fuuzetsu> your type should rather be PersonWithBankAccount -> Bool
12:14:55 <Fuuzetsu> joyfulmantis: go into source directory and type in ‘cabal install’?
12:15:10 <Fuuzetsu> if you're using sandboxes then cabal sandbox add-source is your friend IIRC
12:16:03 <joyfulmantis> ah cabal install works for source dircetorys as well as hackage, thanks
12:17:48 <lethjakman> hey, has anyone built any websites in haskell? I'm considering playing with it for my personal blog. it's between haskell and Go at the moment.
12:17:57 <lethjakman> just wondering how your experiences were.
12:18:02 <lethjakman> I know haskell is supposed to be a bit tougher to get into
12:18:44 <allyraza> lethjakman: try snap
12:18:46 <sivteck> lethjakman, you can build static websites with hakyll
12:18:49 <vanila> lethjakman, I prefer haskell to go a lot
12:18:51 <silver> yeah, some people did
12:19:13 <silver> also yesod is an option
12:19:16 <allyraza> I built rest services with snap
12:19:28 <RedNifre> Can't speak about Haskell yet since I'm very new to it, but Go got frustrating very quickly, since it is very, very low level.
12:19:59 <vanila> I was hoping go would be a good language to replace C for a lot of things, but it kind of disappointed me
12:20:12 <MP2E> same here vanila :(
12:20:16 <benzrf> rust
12:20:20 <benzrf> rusty!
12:20:23 <MP2E> yes, rust is our savior :P
12:20:38 <MP2E> well, haskell really is, but rust for low level tasks
12:20:42 <MP2E> heh
12:20:51 <vanila> in particular lack of TCO, excessively anal compiler errors, having "goto", lacks the ability to write well typed polymorphic code
12:21:30 <vanila> the community was really nasty when I brought up these things (because they're serious problems and no one wants to admit it)
12:21:34 <hexagoxel> lethjakman: maybe have a look at https://github.com/bholst/blog
12:21:37 <simpson> TCO doesn't matter. Generics matter.
12:21:50 <MP2E> vanila: try bringing up generics to them, it's sad and funny at the same time
12:21:56 <simpson> Also yeah, a compilation model that makes implementing a good REPL impossible is not a good thing.
12:22:03 <MP2E> 'generics don't matter for real world programming'
12:22:03 <vanila> it's basically a sad state of a language, there's so much that's been learned about programming language design that they completly ignore
12:22:05 <vanila> it's python 2.0
12:22:10 <MP2E> I actually had someone say that to me
12:22:12 <MP2E> haha
12:22:14 <RedNifre> I really didn't like all that if err!=nil that you type in Go. I much prefer exceptions or Maybe.
12:22:32 <vanila> yeah and error handling is done in a terrible way, so easy to forget to check errors!
12:22:58 <Gurkenglas> It depends whether one asked "Does he have a million dollars in his account" or "Does he have a million dollars in one of his accounts"; the first case assumes a map from people to their bank accounts, and therefore any implementation that mistakenly allows the question to be asked about someone with no bank account should at least have the decency to throw an exception in that case; the second case mathematically
12:22:58 <Gurkenglas>  determines the answer for the case of no account, and should follow the natural implementation of (>0) . length . filter (==1000000)
12:23:07 <Gurkenglas> Huh, that took a while to write.
12:23:21 <RedNifre> I guess Go is fine if you know that your project will never, ever get complex later on. Which I wouldn't count on.
12:24:04 <simpson> vanila: Python permits generic code design and reuse, has real objects, can be independently implemented without generation of machine code, doesn't care if you use exceptions, was designed to be readable, doesn't tie you to a horrible type system...
12:25:01 <Johannes13> I think I have a small problem understanding foldr with infinite lists:
12:25:12 <Johannes13> map' f = foldr (\x acc -> (f x):acc) []
12:25:16 <RedNifre> So, if I have no accounts, I have a million dollars in my account, but I don't have a million dollars in one of my accounts, because my account isn't one of my accounts :)
12:25:21 <Johannes13> take 5 (map' (+3) [1..])
12:26:02 <vanila> simpson, good points, thank you!
12:27:21 <Johannes13> Why does "take 5 (foldr (\x acc -> (x+3):acc) [] [1..])" work? I thought it will start from the end of the infinite list and...
12:27:51 <mauke> no, it starts at the beginning
12:28:02 <mauke> in particular, your "acc" isn't really an accumulator
12:28:04 <shiona> magic of non-strictness
12:28:22 <mauke> it doesn't represent the past (what's been done so far) but the future (the foldr of the rest of the list)
12:28:49 <Gurkenglas> @src foldr
12:28:49 <lambdabot> foldr f z []     = z
12:28:49 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:28:56 <mauke> and (x+3):acc doesn't force its evaluation
12:29:18 <Johannes13> yeah, right
12:29:34 <monochrom> Johannes13: it does not start from the end. (some other languages do. ignore them.) read my http://www.vex.net/~trebla/haskell/lazy.xhtml
12:30:13 <Johannes13> ok, thanks. Just viewed the problem from the wrong spot.
12:30:22 <mauke> the crucial bit here is that 'foldr f z (x : xs) = f x (foldr f z xs)' calls f immediately
12:30:33 <mauke> because evaluation proceeds outside-in
12:30:48 <Johannes13> still learning haskall, but I already like it.
12:31:02 <Gurkenglas> RedNifre, if it is possible that you have no account, the question "Do you have a million dollars in your account" should not be formable
12:31:03 <mauke> hmm, I should say "transfers control to f"
12:31:23 <monochrom> 1+(2+3) does not start with 2+3. it starts with 1+... "oh darn, I guess I have to do 2+3 first". laziness has this slight disadvantage of overhead.
12:31:45 <Johannes13> I like laziness.
12:32:03 <monochrom> but False && (True && False) will not start from True && False.
12:32:07 <Johannes13> and I love map, reduce etc.
12:32:14 <monochrom> will not even care.
12:32:27 <mauke> @src (&&)
12:32:27 <lambdabot> True  && x = x
12:32:27 <lambdabot> False && _ = False
12:32:43 <mauke> I like how this is a simple library function
12:32:52 <mauke> other languages need a special case in the compiler
12:32:53 <zwer> > False && undefined
12:32:54 <lambdabot>  False
12:33:16 <monochrom> therefore foldr (&&) whatever [False, xxx, yyy, ...] is O(1).
12:33:36 <Johannes13> > True && undefined
12:33:37 * hackagebot purescript 0.5.6 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.5.6 (PhilFreeman)
12:33:37 <lambdabot>  *Exception: Prelude.undefined
12:37:05 <Johannes13> $? neat
12:38:32 <platinuum> @help
12:38:32 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:38:37 <platinuum> list
12:38:43 <platinuum> @list
12:38:43 <lambdabot> What module?  Try @listmodules for some ideas.
12:38:46 <platinuum> @listmodules
12:38:47 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
12:39:10 <platinuum> @src (div)
12:39:10 <lambdabot> Source not found. :(
12:39:33 <platinuum> @src (map)
12:39:34 <lambdabot> Source not found.
12:39:40 <platinuum> @src foldr
12:39:41 <lambdabot> foldr f z []     = z
12:39:41 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:39:41 <Revol> foldr f z (x:xs) = f x (foldr f z xs)
12:39:42 <Revol> and (x+3):acc doesn't force its evaluation
12:39:57 <geekosaur> it doesn't have a full source database, and it's an exact match so won't find those. also consider /query lambdabot
12:45:03 <platinuum> ah thanks geekosaur, dont wana spam the channel :p
12:55:08 <dfeuer> ARGH. I just realized dropWhileEnd has the wrong name :-/
12:55:35 <dfeuer> It should probably be called dropWhileEnd', and dropWhileEnd should have gotten the && arguments flipped.
12:55:48 <dfeuer> Well, maybe.
12:55:51 <dfeuer> Forget that.
12:56:08 <dfeuer> Yeah, forget that. The name is fine.
12:56:13 <dfeuer> It's just ... hmm
12:56:27 <dfeuer> There are two ways to go, and each is lazier in a different way.
12:58:10 <dfeuer> takeWhileEnd is another story. It's entirely strict in the spine no matter what.
13:14:21 <Peaker> ghci is sooo slow :(  TH is terrible
13:15:08 <dfeuer> Buh. I'm really not happy that there's only one dropWhileEnd function when there are two functions that deserve the name.
13:15:20 <Peaker> Perhaps TH should be split to TH-that-can-depend-on-imports,  and TH-that-can-depend-only-on-this-module, so the latter (which is more useful!) will be able to avoid rerunning TH if only imports changed. Keep the splices
13:15:21 <dfeuer> I'm also not happy that there's no takeWhileEnd.
13:15:49 <Peaker> Haskell really needs to improve in the compile speed department
13:16:03 <Peaker> How are the GHC competitors with compile times?
13:23:48 <earthy> what GHC competitors? :)
13:26:46 <dfeuer> Yes, if someone had realized that takeWhileEnd should exist when they were writing dropWhileEnd, I think they'd have named it dropWhileEnd' instead :-/
13:26:51 <dfeuer> BYE
13:28:59 <sinelaw> which part of ghc compilation is the bottleneck?
13:29:07 <sinelaw> ghc is kinda slow.
13:29:44 <jmcarthur> probably the optimizations. they usually run to a fixpoint.
13:29:56 <daniell> I get a type error when raising an error: http://pastebin.com/4u7N5hdF  What am I doing wrong?
13:30:14 <geekosaur> parentheses
13:30:44 <monochrom> heh, yeah, error ("number " ++ show n ++ ...)
13:30:50 <geekosaur> error "number "++(show n)++" not in the tree"          is parsed as: (error "number") ++ (show n) ++ ...
13:30:59 <daniell> ah
13:31:34 <daniell> geekosaur: thanks, how am I still doing this wrong after 2 weeks >_>
13:31:47 <monochrom> haha
13:31:57 <monochrom> but precedences are always hard to remember
13:32:04 <daniell> 600 lines and counting, still making super rookie mistakes >_>
13:32:10 <geekosaur> it takes some getting used to. haskell's function application without parens is kinda opposite pretty much every other language out there (aside from other ML family and Lisp)?
13:43:32 <ircbrowse> haskell's function application is just like lisp's
13:43:42 * hackagebot binary-strict 0.4.7.1 - Binary deserialisation using strict ByteStrings  http://hackage.haskell.org/package/binary-strict-0.4.7.1 (DominicSteinitz)
13:44:04 * ircbrowse sneaks away again
13:48:43 * hackagebot binary-strict 0.4.8.1 - Binary deserialisation using strict ByteStrings  http://hackage.haskell.org/package/binary-strict-0.4.8.1 (DominicSteinitz)
13:54:12 <ocharles> Does anyone have a cyclic list structure with support for dropping the current focus and closing the whole?
13:56:42 <geekosaur> kinda sounds like a zipper?
13:57:54 <Fuuzetsu> geekosaur: it's OK, at least LISP compensates by putting parenthesis around everything else
13:58:01 <ocharles> geekosaur: sure
13:58:12 <ocharles> I just don't want to do the hard work :)
13:59:28 <ocharles> the only implementation I've found so far doesn't have delete, which is the important operation I need
13:59:57 <geekosaur> delete is just popping an element off one side or the other into the focus?
14:00:05 <mauke> ([a], [a])
14:03:22 <vanila> ocharles, what about a mutable array
14:03:40 <ocharles> i could do that, but it'd be nice to find a pure solution
14:03:42 <vanila> [a,b,c,d] to cycle you move everything by one [b,c,d,a]
14:03:45 <ocharles> fully pure, that is
14:03:51 <vanila> and to drop you just make it shorted [c,d,a]
14:04:28 <ocharles> I'm not sure how much copying that entails too
14:06:33 <Hayley23>  Here some videos. I hope you like them! http://tinyurl.com/ozfvxy3
14:09:57 <Fuuzetsu> brb #freenode, going to ask if this crap can be regexed
14:11:25 <uiiuiu> ocharles: what about a vector instead of a linked list? vectors' tail, init, etc. are O(1).
14:11:31 <monochrom> @pl \y -> m >>= \n -> n y
14:11:32 <lambdabot> (m >>=) . flip id
14:12:01 <cdk> :t flip id
14:12:02 <lambdabot> b -> (b -> c) -> c
14:12:17 <monochrom> this one can be thought of as flip ($)
14:20:09 <jfischoff> johnw: is it feasible to not use the filesytem when interacting with git? Eg. commit using a tree of handles (or some in-memory stream type)?
14:28:46 * hackagebot miniutter 0.4.4.1 - Simple English clause creation from arbitrary words  http://hackage.haskell.org/package/miniutter-0.4.4.1 (MikolajKonarski)
14:52:39 <Haskellfant> so for parallel code i can just use -N 8 to use 8 threads, can i do the same for concurrent code that uses a lot of forkio?
14:53:04 <Haskellfant> or if not how am i able to use multiple cores with concurrent code
14:53:47 * hackagebot vty 5.2.2 - A simple terminal UI library  http://hackage.haskell.org/package/vty-5.2.2 (CoreyOConnor)
14:54:22 <dfeuer> Is there a package to show as much as possible of a value when part of it may be undefined?
14:57:24 <hexagoxel> dfeuer: data-pprint can do that, iirc
14:57:50 <dfeuer> Thanks, hexagoxel.
15:01:18 <hexagoxel> (the "time limits" example on http://pnyf.inf.elte.hu/fp/Show_en.xml)
15:03:01 <monochrom> Haskellfant: yes, -N 8 applies to forkIO too
15:03:40 <Haskellfant> monochrom: great thx
15:05:36 <monochrom> @unmtl StateT s (Cont r) a
15:05:36 <lambdabot> s -> (Cont r) (a, s)
15:06:02 <monochrom> @unmtl ContT r (State s) a
15:06:03 <lambdabot> (a -> (State s) r) -> (State s) r
15:06:40 <monochrom> @unmtl ContT r (StateT s I) a
15:06:40 <lambdabot> (a -> (StateT s I) r) -> (StateT s I) r
15:06:43 <monochrom> heh
15:13:19 <gamegoblin> @pl \x y z -> z
15:13:20 <lambdabot> const (const id)
15:34:43 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://is.gd/xJt4FF'
15:34:43 --- topic: set by glguy on [Thu Sep 18 09:24:53 2014]
15:35:03 <coiler3> true, it just return the first element
15:35:11 <monochrom> it just mechanically does "const john woo -> john" whether john is a director or a prime minister
15:35:17 <coiler3> which is inc
15:35:26 <coiler3> oh ok i get it :D
15:35:47 <coiler3> thanks guys
15:37:24 <Fuuzetsu> RyanGlScott: Not that I know of but maybe something like randomRs could work for you?
15:38:43 <RyanGlScott> Fuuzetsu: I was just hoping to same some typing, e.g., (a,b,c,d) <- randomIO instead of (,,,) <$> randomIO <*> randomIO <*> randomIO <*> randomIO
15:39:23 <RyanGlScott> Fuuzetsu: Although randomRs would do the trick in some cases, so thanks for showing me that.
15:40:17 <Fuuzetsu> [a, b, c, d] <- take 4 <$> randomRs yourgen
15:40:44 <Fuuzetsu> well, my types aren't quite right here but hopefully you get the idea
15:40:58 <RyanGlScott> I was thinking in cases where a, b, c, and d aren't the same type
15:41:09 <benzrf> :t randomIO
15:41:10 <lambdabot> Random a => IO a
15:41:14 <Fuuzetsu> take 4 $ randoms g
15:41:17 <benzrf> is there not
15:41:30 <benzrf> instance (Random a, Random b) => Random (a, b)?
15:41:36 <Fuuzetsu> RyanGlScott: oh, ok, then I think you'll have to roll something yourself
15:41:37 <Fuuzetsu> benzrf: no
15:41:40 <benzrf> how odd
15:42:25 <Fuuzetsu> the random package sure gets lots of downloads, 20k just this month, I don't remember the last time I had to use it…
15:42:41 <Fuuzetsu> maybe when reading LYAH few years ago
15:43:48 <benzrf> hmmmmmm.... can you think of many type classes where `instance (TheClass a, TheClass b) => TheClass (a, b)' doesnt hold
15:43:52 * hackagebot mvc-updates 1.1.0 - Concurrent and combinable updates  http://hackage.haskell.org/package/mvc-updates-1.1.0 (GabrielGonzalez)
15:43:58 <benzrf> wait hold on a second that pattern
15:44:10 <benzrf> that pattern of (TheClass a, TheClass b) becoming TheClass (a, b)
15:44:29 <benzrf> that's Applicative!
15:44:36 <benzrf> or, like, something]
15:44:50 <RyanGlScott> Go on
15:44:54 <benzrf> i dunno
15:44:59 <benzrf> maybe there's a way of formalizing that
15:45:06 <benzrf> when typeclasses are applicative
15:45:39 <RyanGlScott> Unfortunately, I don't think that's the case for Random a either
15:45:59 <benzrf> it isnt?
15:46:08 <benzrf> what're the Random methods
15:46:28 <RyanGlScott> Nope, random just defines instances for basic types (Bool, Char, and numeric types)
15:46:58 <benzrf> o i thought you meant such an instance was impossible
15:47:02 <benzrf> write a pull request!!
15:47:03 <exio4> benzrf: are you suggesting we get meta type-classes?
15:47:33 <benzrf> exio4: we need dependent type-classes so that we don't need this meta nonsense
15:47:34 <benzrf> :y
15:48:52 * hackagebot xml-push 0.0.0.10 - Push XML from/to client to/from server over XMPP or HTTP  http://hackage.haskell.org/package/xml-push-0.0.0.10 (YoshikuniJujo)
15:55:31 <joneshf-laptop_> is there an easy way to do cross compilation with ghc?
15:55:41 <joneshf-laptop_> like, create a win exe from linux
15:58:27 <benzrf> actually does anybody know if there's a formalization like what i'm talking about
15:59:08 <benzrf> how the existence of SomeClass (a, b) if (SomeClass a, SomeClass b) looks like Applicative
15:59:10 <dmj`> joneshf-laptop_: you can compile to llvm
15:59:23 <Fuuzetsu> benzrf: ‘looks like’ is not a very good thing to formalise
16:01:01 <benzrf> no im wondering if that particular looks-like is the tip of a legitimate iceberg or if it's superficial
16:03:54 <MP2E> benzrf: what you're looking for I think is a Monoidal http://blog.ezyang.com/2012/08/applicative-functors/
16:04:02 <MP2E> which is equivalent to Applicative, yes
16:04:33 <benzrf> sweeet
16:05:03 <benzrf> i want my language to only use HLists, not 'tuples'
16:06:56 <uiiuiu> Is there shorter way to pattern-match on a value constructor accepting multiple arguments than (Constr {})?
16:07:18 <dncr> http-conduit is installed but I cannot "import Network.HTTP.Conduit". "ghc-pkg check" says nothing. How do I figure out what's going on?
16:08:23 <benzrf> MP2E: no wait
16:08:26 <benzrf> MP2E: i meant on type classes
16:08:30 <benzrf> that's stuff i already know
16:08:54 * hackagebot swish 0.9.1.0 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.9.1.0 (DouglasBurke)
16:10:00 <MP2E> oh okay
16:10:57 <zcd> is haskell-platform still the proper installation method
16:11:26 <benzrf> odang i think i see how applicatives are monoidal functors
16:11:44 <benzrf> a monoidal functor is a functor that acts as a monoid homomorphism where the monoids are the monoidal structures of the categories the functor maps between, right
16:13:06 <MP2E> yeah
16:13:18 <MP2E> that sounds right anyway :P
16:20:04 <HeladoDeBrownie> uiiuiu, I think that's as short as it gets unless you use a more general pattern.
16:20:29 <codehero> what is the Data.Text equivalent to putStrLn? if there is any?
16:20:47 <HeladoDeBrownie> @hoogle Text -> IO ()
16:20:49 <lambdabot> Data.Text.IO putStr :: Text -> IO ()
16:20:49 <lambdabot> Data.Text.Lazy.IO putStr :: Text -> IO ()
16:20:49 <lambdabot> Data.Text.IO putStrLn :: Text -> IO ()
16:21:02 <codehero> ah, okay. so i need Text.IO
16:21:05 <codehero> thank you
16:21:07 <coiler3> I'm looking at how Maybe is an instance of Eq ( "instance Eq a => Eq (Maybe a) ..."), so I see the restriction on a being Eq itself. So why does it work with "Nothing"?
16:21:38 <HeladoDeBrownie> coiler3, what do you mean by "work"?
16:21:39 <Hafydd> coiler3: it defaults to (), I think.
16:21:49 <Hafydd> :t let x = Nothing in x == x
16:21:50 <lambdabot> Bool
16:21:54 <coiler3> I mean, why does "Nothing == Nothing" work
16:22:01 <Hafydd> :t let x = Nothing in (x == x, x)
16:22:02 <HeladoDeBrownie> coiler3, because (==) is defined that way for Maybe.
16:22:02 <lambdabot> (Bool, Maybe a)
16:22:23 <Hafydd> Oh, well, it defaults to (), or something when compiled.
16:22:39 <coiler3> ()?
16:22:43 <HeladoDeBrownie> Hafydd, not sure what you're saying gets defaulted, I don't think what you're referring to has anything to do with the Eq instance.
16:23:15 <coiler3> HeladoDeBrownie - I see the implementation, but I also see that it requires the 'a' in "Maybe a" to be Eq
16:23:19 <HeladoDeBrownie> Hafydd, or, are you talking about what happens when the a is ambiguous?
16:23:38 <HeladoDeBrownie> coiler3, sure, that just lets you make the equality comparison on Just work.
16:23:39 <coiler3> but, for Nothing, what is the 'a'?
16:24:01 <HeladoDeBrownie> coiler3, Nothing :: forall a. Maybe a, meaning it's a value of every type constructed with Maybe.
16:24:03 <Hafydd> Oh, I was mistaken. It actually gives an "ambiguous type" error.
16:24:19 <benzrf>       
16:24:22 <HeladoDeBrownie> coiler3, so, basically, take your pick.
16:24:43 <benzrf> i think i see coiler3's question
16:24:56 <benzrf> are universally quantified variables considered to satisfy any typeclass?
16:25:04 <coiler3> but if it can be "anything", then how does haskell know it's "Eq"?
16:25:43 <eazar001> @info eq
16:25:44 <lambdabot> eq
16:25:47 <eazar001> @info Eq
16:25:48 <lambdabot> Eq
16:26:04 <oakwhiz> > (Nothing :: Maybe Int) == (Nothing :: Maybe String)
16:26:05 <coiler3> something like that benzrf...
16:26:05 <lambdabot>  Couldn't match type ‘[GHC.Types.Char]’ with ‘GHC.Types.Int’
16:26:05 <lambdabot>  Expected type: Data.Maybe.Maybe GHC.Types.Int
16:26:06 <lambdabot>    Actual type: Data.Maybe.Maybe GHC.Base.String
16:26:07 <eazar001> i think it can be anything that is part of Eq
16:26:16 <eazar001> not anything literally
16:26:38 <eazar001> oh maybe i didn't see top question
16:27:11 <eazar001> oh i get you now (sorry misunderstood)
16:27:38 <coiler3> or maybe it's just because "Nothing" isn't defined with the type parameter, haskell can infer that the type parameter can match according to context?
16:27:39 <volty> hi, a beginner question:  I have a list of functions accepting one arg. How can I invoke them and collect back the results?
16:27:55 <eazar001> I think Maybe a is = Just a | Nothing
16:28:00 <coiler3> it is
16:28:24 <eazar001> so in that case, it as long as a is part of Eq you should be good
16:28:39 <eazar001> a Just 5 :: Maybe Int
16:28:44 <codehero> @hoogle Text -> Eq
16:28:44 <lambdabot> Did you mean: Text -> Ordering
16:28:45 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
16:28:45 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
16:28:46 <eazar001> would check out but if you did :
16:28:53 <codehero> @hoogle Text -> Ordering
16:28:53 <lambdabot> Data.Text.Lazy compareLength :: Text -> Int64 -> Ordering
16:28:54 <lambdabot> Data.Text compareLength :: Text -> Int -> Ordering
16:28:54 <lambdabot> Prelude compare :: Ord a => a -> a -> Ordering
16:28:55 <eazar001> Just 5 >> Nothing :: Maybe Int
16:29:04 <codehero> hmm
16:29:04 <eazar001> then that's still a Maybe a part of Eq a
16:29:06 <HeladoDeBrownie> coiler3, well the type must be known at compile time, or else you get an ambiguity error. So if you actually use (==), the compiler has to be able to figure out what a is based on how you used it
16:29:18 <eazar001> Just 5 >> Nothing :: Maybe Int
16:29:28 <eazar001> so that is one way of making it work i guess
16:29:42 <MP2E> volty: depends, do you want all of the functions applied to one value, and then accumulate the results in a list? or should the functions take different inputs (from another list)? Finally, do the functions all have the same type of output?
16:29:49 <codehero> duh. i just want to compare two Text...
16:30:15 <eazar001> Just 5 == Nothing
16:30:17 <eazar001> there you go
16:30:32 <eazar001> don't know why i was using (>>)
16:30:42 <HeladoDeBrownie> coiler3, you'll also get an error if the type (call it T) you chose does not have an Eq instance in scope and you tried to use the Eq instance for Maybe T
16:31:05 <volty> MP2E: both, i'm going now with single value, and will try to >>= in front if I succeed forming a nice function
16:31:14 <volty> yes, same type
16:31:19 <codehero> oh, okay. it works with == duh
16:31:34 <HeladoDeBrownie> coiler3, does that help? Sorry if I'm a bit unclear on what you're asking
16:32:08 <benzrf> :t Just 5 *> Nothing
16:32:10 <lambdabot> Maybe b
16:32:19 <eazar001> > Just (const) == Nothinig
16:32:20 <lambdabot>  Not in scope: data constructor ‘Nothinig’
16:32:20 <lambdabot>  Perhaps you meant ‘Nothing’ (imported from Data.Maybe)
16:32:27 <eazar001> > Just 5 == Nothing
16:32:29 <lambdabot>  False
16:32:34 <eazar001> > Just (const) == Nothing
16:32:35 <lambdabot>  No instance for (GHC.Classes.Eq (a0 -> b0 -> a0))
16:32:35 <lambdabot>    arising from a use of ‘GHC.Classes.==’
16:32:38 <eazar001> there you go
16:32:40 <MP2E> volty : zipWith ($) functionList $ cycle value
16:32:58 <eazar001> there's a case where Nothing will fail ^
16:33:07 <benzrf> yes but
16:33:11 <benzrf> why does Nothing == Nothing
16:33:12 <coiler3> I'm still not sure how something like "Nothing==Nothing" would work
16:33:16 <benzrf> coiler3: lol
16:33:33 <eazar001> > Nothing == Nothing :: Maybe (a -> a)
16:33:34 <lambdabot>  Couldn't match expected type ‘Data.Maybe.Maybe (a1 -> a1)’
16:33:35 <lambdabot>              with actual type ‘GHC.Types.Bool’
16:33:39 <HeladoDeBrownie> Ohhh
16:33:42 * benzrf has an idea
16:33:48 <benzrf> @let class NoImpls
16:33:50 <lambdabot>  .L.hs:153:1:
16:33:50 <lambdabot>      No parameters for class ‘NoImpls’
16:33:50 <lambdabot>      (Use NullaryTypeClasses to allow no-parameter classes)
16:33:50 <lambdabot>      In the class declaration for ‘NoImpls’
16:33:50 <eazar001> > Nothing == Nothing :: Maybe (a -> b -> a)
16:33:52 <HeladoDeBrownie> The defaulting might have had something to do with it, sorry I discounted that
16:33:52 <lambdabot>  Couldn't match expected type ‘Data.Maybe.Maybe (a1 -> b1 -> a1)’
16:33:52 <lambdabot>              with actual type ‘GHC.Types.Bool’
16:33:52 <benzrf> @let class NoImpls a
16:33:55 <lambdabot>  Defined.
16:34:12 <benzrf> @let f :: NoImpls a => Maybe a -> Int; f = cons t3
16:34:13 <lambdabot>  .L.hs:156:10:
16:34:13 <lambdabot>      Not in scope: ‘t3’
16:34:13 <lambdabot>      Perhaps you meant one of these:
16:34:13 <lambdabot>        ‘to’ (imported from Control.Lens),
16:34:13 <lambdabot>        ‘t’ (imported from Debug.SimpleReflect),
16:34:14 <benzrf> @let f :: NoImpls a => Maybe a -> Int; f = const 3
16:34:15 <lambdabot>  Defined.
16:34:18 <benzrf> > f Nothing
16:34:20 <lambdabot>  Ambiguous occurrence ‘f’
16:34:20 <lambdabot>  It could refer to either ‘L.f’, defined at L.hs:156:1
16:34:21 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.f’,
16:34:23 <lambdabot>                           imported from ‘Debug.SimpleReflect’ at L.hs:118:1-26
16:34:24 <benzrf> > L.f Nothing
16:34:24 <eriksensei> volty: map ($ 42) [(+1),(*10)]
16:34:25 <lambdabot>                           (and originally defined in ‘simple-reflect-0.3.2:De...
16:34:27 <lambdabot>  No instance for (L.NoImpls a0) arising from a use of ‘L.f’
16:34:31 <benzrf> !!!
16:34:33 <benzrf> wtf?
16:34:41 <benzrf> so it DOESNT assume that the a may be an instance of the class
16:35:07 <benzrf> > (Nothing :: Maybe a) == (Nothing :: Maybe a)
16:35:09 <lambdabot>  True
16:35:14 <benzrf> >*{
16:35:28 <HeladoDeBrownie> I'm pretty dang sure a concrete type must be chosen for Nothing, so the question would be which? Maybe () might make sense indeed.
16:35:35 <benzrf> HeladoDeBrownie: no
16:35:40 <benzrf> 07:34 < benzrf> > (Nothing :: Maybe a) == (Nothing :: Maybe a)
16:35:40 <benzrf> 07:34 < lambdabot>  True
16:35:45 <eazar001> (Nothing :: Maybe (a -> b -> a)) == Nothing
16:35:49 <eazar001> > (Nothing :: Maybe (a -> b -> a)) == Nothing
16:35:50 <MP2E> volty: come to think of it, 'functionList <*> pure value' might work too
16:35:50 <lambdabot>  No instance for (GHC.Classes.Eq (a0 -> b0 -> a0))
16:35:50 <volty> eriksensei: nice, thx :), thx MP2E too
16:35:50 <lambdabot>    arising from a use of ‘GHC.Classes.==’
16:35:56 <MP2E> np
16:35:56 <HeladoDeBrownie> benzrf, that doesn't mean there isn't one being chosen, does it?
16:36:11 <volty> yes, nice hints
16:36:15 <benzrf> HeladoDeBrownie: nothing becomes chosen
16:36:21 <benzrf> not how the system Works
16:36:28 <eazar001> hmmm, i get : No instance for (Eq (a0 -> b0 -> a0))
16:36:30 <HeladoDeBrownie> For one thing this is what ghci does, but runhaskell gives you an ambiguity error as you'd expect.
16:36:44 <benzrf> @let otherF :: Eq a => Maybe a -> Int; otherF = const 3
16:36:45 <lambdabot>  Defined.
16:36:47 <eazar001> hmmm, so i guess Nothing by itself with no declaration
16:36:48 <benzrf> > otherF Nothing
16:36:49 <lambdabot>  3
16:36:53 <benzrf> oh
16:36:57 <benzrf> m-maybe it IS defaulting ;-;
16:36:59 <oakwhiz> It's kind of weird how there are different Nothings
16:37:04 <benzrf> > otherF (Nothing :: Maybe a)
16:37:06 <lambdabot>  3
16:37:24 <benzrf> @let instance NoImpl Int
16:37:24 <lambdabot>  .L.hs:161:10:
16:37:25 <lambdabot>      Not in scope: type constructor or class ‘NoImpl’
16:37:25 <lambdabot>      Perhaps you meant ‘NoImpls’ (line 153)
16:37:27 <zwer> > (Nothing :: Eq a => Maybe a) == Nothing
16:37:28 <benzrf> @let instance NoImpls Int
16:37:29 <lambdabot>  True
16:37:29 <lambdabot>  Defined.
16:37:34 <benzrf> > L.f Nothing
16:37:36 <lambdabot>  No instance for (L.NoImpls a0) arising from a use of ‘L.f’
16:37:36 <lambdabot>  The type variable ‘a0’ is ambiguous
16:37:36 <lambdabot>  Note: there is a potential instance available:
16:37:36 <lambdabot>    instance [safe] L.NoImpls GHC.Types.Int -- Defined at L.hs:161:10
16:37:37 <RegEchse> I find myself often doing the following: suppose i have a monad m. In chained binds i want to map some function f :: a -> b  over the current monadic value x :: m a, so i do   x >>= return . f  . However, since i'd write that a lot, and since i haven't been able to find a "(>>-)" (that would allow me to write x >>- f), i'm wondering if i might be doing "sth. wrong" (or if i'm just too haskell nooby to "see
16:37:39 <eriksensei> volty: there are a lot of other ways of course, some a bit more explicit
16:37:39 <RegEchse> the right way") ...  (Of course i can define (>>-) easily, e. g. via flip fmap, but since hoogle got me nothing useful about that type signature i'm still wondering ...)  Any hints/opinions/...?
16:37:40 <benzrf> aha
16:37:46 <benzrf> yep seems you're right
16:37:53 <benzrf> i was being dumb!
16:38:04 <HeladoDeBrownie> Don't worry, I displayed my share of dumbness earlier as well :)
16:38:12 <coiler3> did you reach some conclusion guys? :)
16:38:22 <eazar001> yea, it seems to default to a general eq class
16:38:28 <HeladoDeBrownie> coiler3, I think (Nothing == Nothing) defaults to using the Maybe () instance.
16:38:43 <coiler3> what is this "()"?
16:38:52 <eazar001> unit, discard
16:38:53 <HeladoDeBrownie> coiler3, unit type. Only constructor is (), unit.
16:38:59 <eazar001> which is instance of show
16:39:10 <eazar001> ??
16:39:13 <HeladoDeBrownie> Take care not to be confused by the type and term having the same appearance.
16:39:23 <eazar001> yea
16:41:22 <benzrf> liked
16:41:24 <benzrf> *like
16:41:26 <benzrf> data Unit = Unit
16:41:29 <benzrf> data () = ()
16:41:52 <eazar001> > () == ()
16:41:53 <lambdabot>  True
16:42:01 <oakwhiz> :t ()
16:42:03 <lambdabot> ()
16:42:03 <adarc> hey, if i'm in ghci's repl and I launch a function which runs forever printing out something every second for example.. is it possible to "reload" the source and cause that code to stop running? like a fresh reload
16:42:16 <volty> hoogle: Failed to download: http://old.hackage.haskell.org/packages/archive/00-hoogle.tar.gz
16:42:22 <oakwhiz> :k ()
16:42:23 <lambdabot> *
16:42:24 <zwer> ctrl+c isn't stopping it?
16:42:36 <volty> trying to guess what's wrong i saw that i have to hoogle versions
16:43:07 <volty> hoogle-4.2.23  hoogle-4.2.26
16:43:11 <adarc> zwer, nah it's in the background.. ie, somethin that I forkIO $ forever $ ...
16:43:17 <SparkySparkyBoom> hi
16:43:24 <Peaker> burnt by waitForProcess not working correctly without -threaded for the Kth time, arrrg
16:43:24 <volty> should I try to remove  & reinstall everything (kubuntu) ?
16:43:30 <SparkySparkyBoom> i need some help debugging
16:43:41 <SparkySparkyBoom> is this the appropriate place to ask for help
16:43:46 <adarc> obviously I should have a way to simply destroy the thread by ID etc, but I'm wondering if there's a simpler way when messing around in repl
16:43:48 <SparkySparkyBoom> or should i ask in #haskell-beginners
16:43:50 <volty> and in which module <*> is defined ?
16:44:11 <eazar001> Control.Applicative
16:44:14 <MP2E> import Control.Applicative
16:44:19 <volty> thx
16:44:31 <k00mi> SparkySparkyBoom: you can ask here
16:44:41 <benzrf> SparkySparkyBoom: nice nick o3o
16:44:56 <SparkySparkyBoom> benzrf: ;)
16:45:09 <MP2E> sparky sparky boom boom man! *grabs air glider and flies away*
16:45:10 <lpaste> ssb pasted “LinkChecker” at http://lpaste.net/7969027211720130560
16:45:34 <SparkySparkyBoom> ^ thats what im having trouble with
16:45:48 <SparkySparkyBoom> ive got IOs wrapping IOs wrapping more IOs
16:46:32 <SparkySparkyBoom> it's just a simple link checker
16:47:15 <SparkySparkyBoom> the errors seem to be happening at http://lpaste.net/7969027211720130560#line27
16:48:07 <Cale> SparkySparkyBoom: I'll have a look
16:48:29 <Cale> Okay, first most obvious problem: you have two arguments to return there
16:48:37 <Cale> Why?
16:49:07 <SparkySparkyBoom> it returns a list of references that are broken
16:49:15 <Cale> You're passing it  (runner brokenPairs to link)  which is an IO action
16:49:18 <Cale> and then links
16:49:39 <Cale> which is whatever the result of runX is there
16:49:53 <Cale> Ordinarily, return only takes a single argument
16:50:20 <SparkySparkyBoom> the result of runX is an IO String
16:50:55 <Cale> So, runX $ doc //> hasName "a" >>> getAttrValue "href" itself is an IO String, you mean?
16:51:02 <Cale> So then links is simply a String
16:51:08 <SparkySparkyBoom> and doesnt the $ make it so that the entire right hand side is evaluated first
16:51:11 <SparkySparkyBoom> yes
16:51:24 <Cale> f $ x is simply f x
16:51:31 <Cale> It doesn't control evaluation order at all
16:51:36 <Cale> It's just low precedence
16:51:50 <Cale> (also, evaluation order doesn't matter here)
16:52:27 <k00mi> Cale: links is not an argument to return, the indentation is quite confusing
16:52:32 <Cale> oh
16:52:40 <Cale> right, there's an extra ) there
16:52:46 <Cale> it's an argument to map
16:52:56 <SparkySparkyBoom> yes
16:53:04 <Cale> You should align it with the "(\link -> ..." on the line above :)
16:53:06 <Cale> But okay
16:53:09 <SparkySparkyBoom> sorry about the indentation
16:53:17 <Cale> The next problem is the type of list this map is producing
16:53:30 <SparkySparkyBoom> i need to flatten it?
16:53:32 <Cale> It appears to be a list of IO actions
16:53:48 <Cale> You probably want to be executing those IO actions instead
16:53:57 * hackagebot keystore 0.6.0.0 - Managing stores of secret things  http://hackage.haskell.org/package/keystore-0.6.0.0 (ChrisDornan)
16:54:08 <Cale> It is possible to produce a list of IO actions from something and execute them at some future point, but the type would be different.
16:54:14 <mmachenry> Hello.
16:54:45 <Cale> So you probably really want to have something like:
16:54:52 <mmachenry> Anyone in the Haskell meetup scene in Western Europe?
16:55:22 <Cale> rs <- forM links $ \link -> do l <- link; runner brokenPairs to link
16:55:42 <mmachenry> Also does anyone know of any library defined operators that are "flip ($)" ?
16:55:55 <Cale> and then rs will be a list of the results of applying runner in each case, so a list of lists
16:55:55 <HeladoDeBrownie> mmachenry, (&) from lens
16:55:56 <pjdelport> :t (&)
16:55:57 <lambdabot> a -> (a -> b) -> b
16:56:01 <eriksensei> & in lens?
16:56:10 <Cale> and so you might want to return (concat rs) then
16:56:11 <mmachenry> Ah… I had been told (#) and I was looking for the wrong thing.
16:56:13 <mmachenry> Thanks :)
16:56:26 <HeladoDeBrownie> mmachenry, it'd probably be a bad idea to include lens just for the sake of (&) though :)
16:56:26 <geekosaur> # was proposed at one point, and may have been used in early versions
16:56:29 <pjdelport> lens would be kind of heavy to import just for that, though.
16:56:41 <k00mi> mmachenry: diagrams and some other libs use (#)
16:56:42 <Cale> Why do people even want flip ($)?
16:57:01 <pjdelport> Rather just say "(&) = flip ($)" at the top of modules where you want it.
16:57:12 <vanila> Cale, it's a bad habit of reading left to right
16:57:26 <vanila> object.method1().method2();
16:57:38 <mmachenry> k00mi: Had trouble finding that. Sad it's not more standard. It is quite useful.
16:57:42 <benzrf> vanila: i like that!!!
16:57:49 <benzrf> i'm not Hebrew
16:57:53 <vanila> it's a bad idea to try to emulate this style in haskell
16:57:53 <HeladoDeBrownie> Yeah, and what's with (.) being backwards for that matter? f . g should mean f happens first and *then* g! /s
16:58:21 <Cale> HeladoDeBrownie: If you're talking about evaluation order, then f *does* happen before g :)
16:58:33 <mmachenry> HeladoDeBrownie: It's more common in most math books to do it the way Haskell does.
16:58:41 <Cale> (f . g) x -> f (g x)  and then f is evaluated
16:58:48 <Cale> (and applied to (g x))
16:58:59 <HeladoDeBrownie> Cale, I was being intentionally vague with my wording so as to emulate the thought pattern I was poking fun at. :)
16:59:14 <mmachenry> But compose's ordering is debatable. I've seen both.
16:59:24 <vanila> it's not debatable
16:59:28 <bcap> need some help with this function: http://lpaste.net/111388
16:59:36 <Cale> SparkySparkyBoom: If you want, I can grab HXT and see if I can straight this out for you if you're still having trouble
16:59:38 <mmachenry> vanila: I'm debating it now ;)
16:59:39 <bcap> why does it complains about max receiveing too many arguments?
16:59:47 <SparkySparkyBoom> Cale: yes please :D
16:59:51 <SparkySparkyBoom> im so stuck
16:59:53 <Cale> SparkySparkyBoom: I think you might be confused about the need to execute IO actions
17:00:03 <Cale> SparkySparkyBoom: and the difference between IO String and String, for instance
17:00:29 <Cale> An IO String looks nothing like a String, it's a program which if you were to execute it, would produce a String
17:00:42 <Cale> e.g. the relationship is like the difference between /bin/ls and a list of files
17:00:42 <HeladoDeBrownie> bcap, it's actually the reverse in this case
17:00:44 <HeladoDeBrownie> @type max
17:00:45 <lambdabot> Ord a => a -> a -> a
17:00:56 <SparkySparkyBoom> and the <- notation produces the string?
17:01:07 <Cale> SparkySparkyBoom: When you write v <- x inside a do-block, it means "execute the action x, and call its result v"
17:01:09 <Cale> yeah
17:01:14 <eriksensei> bcap: you're passing a tuple to max
17:01:16 <SparkySparkyBoom> i see
17:01:17 <Cale> So, if x :: IO String, then v :: String in that case
17:01:20 <HeladoDeBrownie> bcap, max "takes two arguments" and you're giving it one
17:01:37 <Cale> SparkySparkyBoom: and then the whole do-block itself becomes an IO action
17:01:50 <bcap> so the hint should not be "too many arguments", right?
17:01:54 <Cale> SparkySparkyBoom: which if executed will execute each of the actions listed in turn
17:02:05 <SparkySparkyBoom> ah
17:02:12 <SparkySparkyBoom> the whole laziness thing
17:02:16 <Cale> That's not laziness
17:02:26 <Cale> It's just that IO actions are values
17:02:32 <HeladoDeBrownie> bcap, eh, it only says "Possible cause". I'm not sure how it determines that, and it is misleading in this case, but I guess it's not wrong per se.
17:02:33 <Cale> Evaluating those values does nothing
17:02:45 <Cale> so laziness (i.e. the evaluation order) doesn't play a role here
17:02:48 <bcap> eriksensei where am I passing a tuple? x is a singe Ord while listMax returns a single Ord also
17:02:55 <Cale> Only *executing* IO actions causes their effects to happen
17:02:57 <HeladoDeBrownie> bcap, (x, listMax xs) is a tuple.
17:03:09 <Cale> and execution doesn't happen automatically
17:03:15 <Cale> (not as part of evaluation)
17:03:29 <Cale> any more than opening /bin/ls in a text editor would produce a list of files
17:03:30 <benzrf> SparkySparkyBoom: do-blocks do NOT execute actions
17:03:33 <benzrf> they construct them
17:03:36 <bcap> oh
17:03:38 <benzrf> SparkySparkyBoom: when i say:
17:03:39 <HeladoDeBrownie> bcap, perhaps you wanted: max x (listMax xs)
17:03:40 <benzrf> do
17:03:42 <benzrf>   v <- getLine
17:03:44 <bcap> yeah, thats the correct
17:03:46 <benzrf>   putStrLn v
17:03:52 <bcap> im still learning haskell
17:03:56 <benzrf> SparkySparkyBoom: that's building an IO action that does that
17:03:57 <Cale> Well, do-blocks expess the fact that certain actions ought to be executed (at some point)
17:03:59 <benzrf> it's NOT running it
17:04:08 <HeladoDeBrownie> bcap, I take it you were going off the call syntax of your favorite non-Haskell language? Yeah, it is different
17:04:16 <benzrf> SparkySparkyBoom: what language do you hail from
17:04:18 <bcap> not used to putting parenthesis around the whole call and not the arguments
17:04:22 <Cale> but yeah, the do-block as a whole just becomes one of these actions
17:04:25 <vanila> in object.method1().method2(); you invoke methods on an object and then the result it computes so it makes sense to do it in this order, on the other hand (f . g) x = f (g x) is applying the function f to the result of g on x. composing the other way would be backwards look: (g # f) x = f (g x)
17:04:27 <Cale> waiting to happen
17:04:29 <SparkySparkyBoom> benzrf: java
17:04:32 <SparkySparkyBoom> and scala
17:04:33 <HeladoDeBrownie> bcap, well, parens are only needed for grouping, and often not at all.
17:04:41 <eriksensei> bcap: you were doing so in other places though
17:04:43 <bcap> HeladoDeBrownie yeap, indeed =)
17:04:51 <bcap> still learning hskell
17:04:54 <Cale> SparkySparkyBoom: Now, we should also say something about return
17:05:06 <SparkySparkyBoom> Cale: i think i understand reutrn
17:05:09 <vanila> Haskells (.) is already defined in the standard library and everyone uses it, if you break that convention you're making your code harder to read for others and giving up the opportunity to get comfortable with other peoples haskell code
17:05:10 <HeladoDeBrownie> bcap, basically, the thing to get used to is that you write a space for function application. Also, that every function has precisely one parameter. :)
17:05:11 <SparkySparkyBoom> it just injects a value
17:05:13 <Cale> SparkySparkyBoom: return is a function which takes some value, and produces an action which does nothing except to produce that value
17:05:21 <Cale> (when executed)
17:05:25 <bcap> the main issue is, if you stop learning in themiddle, a lot of things your lernt reverts and mixes with other experiences
17:05:29 <SparkySparkyBoom> oh
17:05:36 <bcap> i was writing some bizarre mix of python and haskell
17:05:46 <HeladoDeBrownie> max is in fact a function that returns a function, for example
17:05:56 <Cale> SparkySparkyBoom: The result of the action which you construct using a do-block is the result of the last action in it
17:06:04 <HeladoDeBrownie> But we usually just elide that since it's so common and say it's a function of two parameters
17:06:08 <Cale> SparkySparkyBoom: So, return is useful for determining what that result will be
17:06:26 <benzrf> SparkySparkyBoom: do you know about monads yet?
17:06:26 <Cale> SparkySparkyBoom: Or more generally whenever you need a no-op action for some reason
17:06:36 <bcap> HeladoDeBrownie yeap, I noticed that, carrying is natural in haskell to the point you only have functions that take one argument
17:06:42 <SparkySparkyBoom> benzrf: a bit
17:06:49 <benzrf> bcap: y'mean currying?
17:06:50 <SparkySparkyBoom> ive heard them referred to as containers
17:06:53 <benzrf> SparkySparkyBoom: ew no
17:06:53 <Cale> Well, let's stick with IO first
17:06:57 <bcap> yeap
17:07:09 <Cale> The container analogy can work, but it works very poorly with IO
17:07:19 <datura> SparkySparkyBoom: many containers are monads, but there are many more monads that are not containers
17:07:19 <benzrf> :t (>>=) `asAppliedTo` (undefined :: IO a)
17:07:20 <lambdabot> IO a -> (a -> IO b) -> IO b
17:07:24 <Cale> It's better to think of IO actions as being like executable program scripts
17:07:32 <benzrf> SparkySparkyBoom: (>>=) :: IO a -> (a -> IO b) -> IO b
17:07:40 <Cale> and do-notation as being a way to glue those scripts together into larger ones
17:07:43 <bcap> thanks for the help guys
17:08:04 <SparkySparkyBoom> benzrf: i used one of those in my program =<<
17:08:06 <benzrf> SparkySparkyBoom: given a runnable action and a callback that produces a new action, make an action that consists of running the first arg, passing the result to the callback, then running the result of the callback
17:08:09 <bcap> btw, I thinks its probably way easier to learn haskell as your first language
17:08:12 <benzrf> SparkySparkyBoom: i.e.
17:08:15 <benzrf> getLine >>= putStrLn
17:08:16 <eriksensei> bcap: good luck with the depythonizing ;)
17:08:20 <bcap> the paradigm break from a non functional languageu is quite high
17:08:26 <benzrf> is an action that runs getLine, then passes the result to putStrLn, then runs the result of that
17:08:35 <benzrf> :t getLine
17:08:36 <lambdabot> IO String
17:08:37 <benzrf> :t putStrLn
17:08:39 <lambdabot> String -> IO ()
17:08:45 <benzrf> SparkySparkyBoom: (>>=) :: IO a -> (a -> IO b) -> IO b
17:08:45 <vanila> it's ok to learn haskell as a second/third/.. language but you should approach with a beginners mind
17:08:55 <eriksensei> bcap: yeah, it's a shame it isn't taught more at uni
17:09:02 <SparkySparkyBoom> like pipes
17:09:37 <Cale> I'm not sure we even really need to introduce (>>=) here?
17:09:40 <Cale> I suppose we could
17:09:45 <Cale> do-notation is enough
17:10:06 <Cale> If you understand do-notation, then x >>= f is the same thing as do v <- x; f v
17:10:15 <Cale> which is the same thing as do v <- x; w <- f v; return w
17:10:20 <bcap> eriksensei thanks! I like this paradigm breaks. It forces your mind to go up one level to understand different concepts. You discover and exercise new patterns. I thinks thats the closest as exercising intelligence as it gets
17:10:49 <bcap> * I think thats the closest as it gets to exercising intelligence
17:10:58 <bcap> didnt make sense previously
17:11:41 <HeladoDeBrownie> s/the closest/as close/ is better written, but you were understood
17:12:16 <Cale> SparkySparkyBoom: So, if x :: IO a, and f :: (a -> IO b), then (x >>= f) :: IO b is the IO action which will first run x, getting some result, say v, then run the action (f v), returning its result.
17:12:19 <datura> SparkySparkyBoom: ever wondered why with nested loops, nested callbacks, nested error checking, nested resource allocation/deallocation the same code is repeated at each level, but you still cannot separate the nesting from the interesting "meat" of the code?
17:12:35 <Cale> SparkySparkyBoom: It's really the other way around: do-notation is syntax sugar for uses of (>>=)
17:12:45 <SparkySparkyBoom> datura: it's just the way it has to be
17:12:49 <eriksensei> bcap: i agree, and there's a lot of interesting stuff to learn on the functional side fo the fence
17:13:44 <Cale> SparkySparkyBoom: Or is it?
17:13:45 <benzrf> SparkySparkyBoom: heck nah
17:14:02 <benzrf> haskell makes up for the slight clunkiness of its IO with the ability to abstract over that shit!!!
17:14:09 <benzrf> first-class effects are SWEET
17:14:10 <SparkySparkyBoom> Cale: my eyes have a tendency to glaze over type signatures
17:14:17 <datura> SparkySparkyBoom: the different nesting structures have something in common. they are all monads ;)
17:14:18 <Cale> I also disagree about IO being clunky in any way
17:14:42 <Cale> SparkySparkyBoom: Yeah, but I need to show them to you, so that you'll get used to them :)
17:14:44 <bcap> eriksensei indeed! The last year i got used to do functional stuff inside python to the point I felt I needed bigger guns. When I started learning functional programming in haskell i rediscovered programming itself in a more mathematical and advanced way. Its fun
17:14:49 <HeladoDeBrownie> SparkySparkyBoom, types are important to understand
17:15:11 <Cale> SparkySparkyBoom: So, if you prefer, x is an IO action with some result of type a
17:15:24 <SparkySparkyBoom> HeladoDeBrownie: thats how i was able to understand some of the http parts of the code
17:15:28 <Cale> and f is a function which takes an argument of type a, and produces IO actions with results of type b
17:16:15 <Cale> and (>>=) connects those two things together in the way that seems obvious: producing an IO action with a result of type b that will first execute the IO action with result of type a
17:16:31 <Cale> and then apply the function to that result to get an IO action having a result of type b
17:16:39 <bcap> eriksensei when i was back at university we where taught that recursion was cool but was "stuff hard to understand to show-offs". From that point on the for loop was engraved in my practice of programming. Took 7 years to start looking at this in a different way
17:16:42 <Cale> and then it'll execute *that* action, returning the result as its own
17:17:01 <bcap> "stuff hard to understand for show-offs"
17:17:03 <Cale> Which is a mouthful
17:17:20 <SparkySparkyBoom> Cale: easily expressed in a type signature
17:17:22 <SparkySparkyBoom> thank you
17:17:27 <Cale> But you might prefer to just stare at  (x >>= f) = (do v <- x; f v)
17:17:33 <bcap> and today recursion makes much more sense to me than iteration
17:17:36 <SparkySparkyBoom> yes!
17:18:07 <bcap> the world and nature itself is close to recursion loops than to iteration loops
17:18:11 <eriksensei> bcap: good comp sci curricula are not all that common unfortunately
17:18:58 <Cale> SparkySparkyBoom: So, let's look at a handy library function, which I think should illustrate the usefulness of treating these actions as values a bit
17:19:12 <eriksensei> bcap: absolutely, even though in practice a lot of recursive things are done using folds and such
17:19:29 <Cale> SparkySparkyBoom: sequence :: [IO a] -> IO [a] is a function which takes a list of IO actions, and produces an action that'll run them all, collecting a list of the results
17:20:07 <Cale> Because actions are values which we have to be very explicit about executing, it's easy to write things like this without accidentally having actions blowing up in our face, let's do it:
17:20:13 <Cale> sequence [] = ...
17:20:17 <eazar001> @type sequence
17:20:18 <lambdabot> Monad m => [m a] -> m [a]
17:20:23 <Cale> If the list is empty, we just want to produce an empty list
17:20:43 <SparkySparkyBoom> Cale: are we rewriting it?
17:20:44 <Cale> We have a way to take a value and produce an IO action that'll always result in that value without doing anything, which is return
17:20:49 <Cale> yeah, we're writing it :)
17:20:53 <bcap> eriksensei and my curricula was not bad! the point is there is a lot of programmers that just learnt to program, and thats all. To properly write code you need to understand programming foundations, and math is one big foundation
17:20:53 <Cale> sequence [] = return []
17:21:03 <Cale> and now the more interesting case:
17:21:08 <Cale> sequence (x:xs) = ...
17:21:23 <Cale> Well, first we want the resulting IO action to execute x...
17:21:28 <Cale> sequence (x:xs) = do v <- x; ...
17:21:51 <Cale> and then we want to execute the rest of the list, thankfully, we have a function available which does this, the one we're writing:
17:21:56 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; ...
17:22:17 <Cale> and then we just need to combine the initial result with the rest and return the combined list:
17:22:22 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
17:22:24 <bcap> eriksensei in the end of the day, you write code to emulate some aspect of reality. You need to better understand reality in all of its levels to better code
17:22:45 <SparkySparkyBoom> ah
17:22:50 <Cale> cool?
17:22:53 <SparkySparkyBoom> yes
17:22:58 <eazar001> Can anbody please concisely state to me a (global) motivating reason to learn arrows?
17:23:14 <eazar001> (within the context of haskell)
17:23:34 <Cale> So, this function acts as a kind of primordial loop: if we can decide ahead of time what should happen on each iteration and build a list of actions, this function will stitch the list of iterations together into a single action
17:23:54 <hpc> eazar001: it gets you in the right frame of mind for learning more interesting things
17:24:18 <eazar001> hpc: besides foundational reasons?
17:24:27 <eazar001> hpc: within the context of data structures preferrably
17:24:28 <Cale> We can use it to implement a foreach loop, which takes some list of values, and then a loop body which is a function of the elements of the list being iterated over, and does the obvious thing:
17:24:34 <eazar001> (i do appreciate your input though)
17:25:03 <Cale> foreach xs body = ... map body xs ... -- we apply the body function to each of the elements of the list, getting a list of actions to be performed
17:25:08 <hpc> ah
17:25:21 <Cale> foreach xs body = sequence (map body xs) -- and then apply sequence to glue them together
17:25:32 <Cale> So here,  foreach :: [a] -> (a -> IO b) -> IO [b]
17:25:47 <hpc> arrows have some problems that keep them from being useful in a lot of scenarios
17:25:48 <Cale> A more general version of this is available from Control.Monad as forM
17:26:05 <hpc> but they're very close to the right abstraction
17:26:12 <merijn> eazar001: Not really, arrows are not that useful as, say applicative/monad or category
17:26:23 <SparkySparkyBoom> Cale: arent we wasting memory by using sequence?
17:26:31 <SparkySparkyBoom> oh wait nvm
17:26:35 <SparkySparkyBoom> the values matter
17:26:37 <hpc> for instance, if you take away arr it's really handy for writing DSLs
17:26:41 <Cale> Well, we're collecting a list of results, they might matter
17:26:47 <SparkySparkyBoom> right
17:26:48 <merijn> eazar001: They have a few, limited use cases, most of which are ruined by the current design of Arrow (i.e. the presence of arr)
17:26:53 <Cale> There's another version forM_ which discards them
17:27:06 <Cale> Monad is a general interface to things M similer to IO, which have some definition of return :: a -> M a, and (>>=) :: M a -> (a -> M b) -> M b
17:27:27 <Cale> Functional programmers love writing these data types which behave like miniature programming languages and get interpreted somehow
17:27:43 <Cale> and monad generalises over a fairly wide range of them
17:27:55 <Cale> so that we don't have to write things like sequence and forM and such over and over
17:27:57 <eazar001> i see, well i guess i'll try to take a more foundational/academic approach if decide to pick it up then
17:28:01 <SparkySparkyBoom> http://hackage.haskell.org/package/base-4.7.0.1/docs/src/Control-Monad.html#forM_
17:28:03 <Cale> That's really all there is to it :)
17:28:07 <Cale> yes
17:28:16 <SparkySparkyBoom> it's so simple
17:28:18 <SparkySparkyBoom> XD
17:28:50 <ramfjord> Hey guys, I've been struggling with what seems like a simple problem for a while
17:29:01 <ramfjord> I have a typeclass Column
17:29:07 <volty> how can I  map [1..5] to produce [($ 1), ($ 2) ... ] ?
17:29:16 <ramfjord> NamedColumn and UnnamedColumn are the only two instances
17:29:31 <ramfjord> how can I group a list of Columns by their type
17:29:36 <Cale> volty: map (\x -> ($ x)) [1..5]
17:29:45 <Cale> volty: or  map (flip ($)) [1..5]
17:29:53 <volty> wonderful
17:29:59 <ramfjord> eg [UnnamedColumn UnnamedColumn NamedColum] => [[UnnamedColumn, UnnamedColumn], [NamedColumn]]
17:30:14 <Cale> ramfjord: I don't think what you want is a type class.
17:30:25 <Cale> (in the first place)
17:30:29 <ramfjord> ?
17:30:34 <vanila> ramfjord, you could use [Either NamedColumn UnnamedColum] -> ([NamedColumn],[UnnamedColumn])
17:30:36 <Cale> ramfjord: Well, what's the type of that list?
17:30:56 <Cale> ramfjord: Noting that all its elements *must* have the same type
17:31:11 <Cale> (because otherwise, you wouldn't know what to do with them when you took them out again)
17:31:17 <ramfjord> the reason I used a typeclass was so that I could have a list of Columns
17:31:32 <Cale> ramfjord: That's not what type classes do
17:31:46 <ramfjord> I guess the last list doesn't ahve a valid type
17:31:57 <Cale> Type classes won't let you put elements of different types in a single list.
17:31:59 <ramfjord> what I actually want is to parse it into a list of [SelColumnGroup]
17:32:15 <ramfjord> data SelColumnGroup = NamedColumnGroup   [NamedColumn] | UnnamedColumnGroup [UnnamedColumn]
17:34:43 <lpaste> Cale pasted “LinkChecker: this compiles at least” at http://lpaste.net/111391
17:34:49 <Cale> SparkySparkyBoom: ^^
17:34:59 <ramfjord> so yeah, ideally groupColumns :: [Column] -> [SelColumnGroup]
17:35:40 <lpaste> Cale revised “LinkChecker: this compiles at least”: “No title” at http://lpaste.net/111391
17:35:56 <benzrf> what is this 'revise'
17:36:00 <lpaste> Cale revised “LinkChecker: this compiles at least”: “No title” at http://lpaste.net/111391
17:36:09 <Cale> there, just tidied things up a little
17:36:22 <Cale> benzrf: That means I edited it
17:36:44 <benzrf> i mean since when is that a thing that lpaste supports
17:36:57 <Cale> benzrf: Since... quite some time now
17:37:04 <Cale> I don't know exactly
17:37:06 <erisco> considering the definition of a Functor in Category theory, how did Haskell get its definition of a Functor?
17:37:07 <Cale> Some months?
17:37:23 <Cale> erisco: A Functor is pretty much an endofunctor on the category of Haskell types
17:37:50 <Cale> erisco: Right? You have a type constructor f which sends types to types (objects to objects)
17:37:59 <Cale> and then you have fmap :: (a -> b) -> (f a -> f b)
17:38:03 <Cale> which sends arrows to arrows
17:38:04 <athan> Can you use record syntax with newtypes?
17:38:09 <k00mi> yes
17:38:17 <athan> k00mi: Thanks :)
17:38:20 <erisco> Cale, the Haskell types are the objects?
17:38:24 <Cale> erisco: yeah
17:38:30 <benzrf> erisco: yes the category Hask is much like the category set
17:38:32 <benzrf> *Set
17:38:36 <benzrf> but with types instead of sets!
17:39:38 <k00mi> ramfjord: if C is a type class, there is no such thing as values of type C
17:40:32 <erisco> Cale, why choose an endofunctor?
17:40:37 <Cale> erisco: hm?
17:40:52 <Cale> erisco: Because we have little capacity for directly representing arrows of other categories
17:41:10 <Cale> (at least, not in such a natural way)
17:41:53 <k00mi> ramfjord: if you describe what you want to do we might be able to help you
17:42:03 <Cale> SparkySparkyBoom: anyway, hopefully the changes I made make sense to you now :)
17:43:12 <ramfjord> k00mi: thanks.  I'm trying to parse SQL, to get blocks of named/unnamed columns
17:43:21 <ramfjord> I want these to be separate for formatting purposes
17:43:24 <SparkySparkyBoom> Cale: yea im fiddling around with the code to see what errors i get if i do something differently
17:43:47 <ramfjord> I've got parser that returns a list of columns
17:43:50 <SparkySparkyBoom> also i didnt know that forM and mapM were just reversed
17:44:22 <ramfjord> parseColumns :: GenParser Char st [Column]
17:44:39 <ramfjord> and I'd like to somehow get a [SelColumnGroup] back
17:44:42 <ramfjord> to format it later
17:44:46 <k00mi> what's Column?
17:45:04 <ramfjord> hmm
17:45:12 <ramfjord> perhaps it would be simpler to paste some code
17:45:15 <k00mi> is it a typeclass or a datatype?
17:45:35 <ramfjord> typeclass
17:45:56 <erisco> Cale, why does Functor not include a -> f a?
17:46:15 <benzrf> erisco: that's not part of a functor
17:46:17 <erisco> Cale, (a -> b) -> (f a -> f b) is mapping the arrows, if I understand correctly
17:46:24 <erisco> Cale, but what maps the objects?
17:46:25 <benzrf> erisco: anyway, not all Functor instances support that
17:46:32 <k00mi> ramfjord: then that doesn't work, because, again, there is no such thing as values of type Column
17:46:36 <benzrf> erisco: the type constructor
17:46:43 <benzrf> A -> Maybe A
17:47:39 <volty> do { x <- a; y <- b; [(x,y)] } // how do I achieve the same without do ? (with >>=  ... )
17:47:40 <k00mi> ramfjord: what you want is a sum type, I think that is what your SelColumnGroup is
17:47:57 <benzrf> volty: liftA2 (,) a b
17:48:00 <benzrf> or
17:48:02 <coppro> volty: a (\x -> b (\y -> [(x, y)]))
17:48:04 <coppro> err
17:48:06 <k00mi> ramfjord: so why not return [SelColumnGroup] directly?
17:48:08 <benzrf> (,) <$> a <*> b
17:48:11 <coppro> volty: a >>= (\x -> b >>= (\y -> [(x, y)]))
17:48:43 <shiona> @undo do { x <- a; y <- b; [(x,y)] }
17:48:44 <lambdabot> a >>= \ x -> b >>= \ y -> [(x, y)]
17:49:20 <volty> what is @undo ?
17:49:22 <eazar001> hmmm, i didn't know about @undo
17:49:28 <volty> supposed to simplify ?
17:49:30 <eazar001> it desugars a do-block
17:49:32 <eazar001> apparently
17:49:55 <shiona> that's what it does. It does not simplify the unsugared code at all
17:50:03 <shiona> or at least it looks like that to me
17:50:03 <erisco> @undo do 5
17:50:04 <lambdabot> 5
17:50:17 <eazar001> @undo do {putStrLn "hello world"}
17:50:17 <lambdabot> putStrLn "hello world"
17:50:19 <erisco> making sure it covers that odd case
17:50:39 <eazar001> @undo do {putStrLn "hello world"; return (1,2)}
17:50:39 <lambdabot> putStrLn "hello world" >> return (1, 2)
17:50:42 <volty> i am playing around (think it's the best way to learn) and came with the weirdest map (flip ($)) a >>= flip map (b >>=  flip (:) [] . (,))
17:50:43 <HeladoDeBrownie> @. pl undo do { x <- a; y <- b; [(x,y)] }
17:50:43 <lambdabot> (b >>=) . flip flip [] . ((:) .) . (,) =<< a
17:50:54 <HeladoDeBrownie> ... Yeah that's not code you should probably write :P
17:50:55 <eazar001> man that's ugly
17:51:07 <erisco> :t (flip ($)) a >>= flip map (b >>=  flip (:) [] . (,)
17:51:08 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
17:51:14 <erisco> :t (flip ($)) a >>= flip map (b >>=  flip (:) [] . (,))
17:51:15 <lambdabot>     Couldn't match expected type ‘[(b0 -> (a0, b0)) -> b]’
17:51:15 <lambdabot>                 with actual type ‘(Expr -> c0) -> c0’
17:51:16 <lambdabot>     Probable cause: ‘flip’ is applied to too few arguments
17:51:33 <eazar001> hahah, pointless undo
17:52:19 <ramfjord> k00mi: I couldn't get the parser to accept the correct tokens trying that
17:52:26 <ramfjord> though it was what I was trying originally
17:52:32 <ramfjord> so I suppose I should look into that
17:52:38 <erisco> Cale, hm no I misunderstood... let me think again =\
17:53:05 <erisco> volty, so your thing does not seem to type check
17:53:12 <erisco> oh wait
17:53:22 <erisco> :t map (flip ($)) a >>= flip map (b >>=  flip (:) [] . (,))
17:53:23 <lambdabot>     Couldn't match expected type ‘[a]’ with actual type ‘Expr’
17:53:23 <lambdabot>     In the second argument of ‘map’, namely ‘a’
17:53:23 <lambdabot>     In the first argument of ‘(>>=)’, namely ‘map (flip ($)) a’
17:53:43 <Sorella> HeladoDeBrownie: I'm pretty sure Kmett's libraries have similar levels of pointlessness :P
17:53:52 <erisco> :t \a b -> map (flip ($)) a >>= flip map (b >>=  flip (:) [] . (,))
17:53:53 <lambdabot> [a] -> [a1] -> [(a1, a)]
17:53:56 <volty> no, I do not care about that, i just started with >>= trying to get rid of /x and /y  passing
17:54:15 <erisco> :t zip
17:54:16 <lambdabot> [a] -> [b] -> [(a, b)]
17:54:26 <erisco> volty, looks like you wrote zip :)
17:54:29 <exio4> flip zip!
17:54:31 <volty> lot to learn, the brain needs thinking & time to fix all the logic
17:55:15 <k00mi> ramfjord: if you can't figure it out you can always paste the code (on lpaste.net) and ask for help here
17:57:32 <no-doz> brains need sleep
17:58:02 <ramfjord> k00mi: yeah, I was just tidying and putting it all in one file: http://lpaste.net/111394
17:58:40 <volty> no-doz: i was thinking about today -- the most important requirement for good programming is enough sleeping
17:58:43 <ramfjord> but it's now more of a parsec question
17:58:59 <no-doz> volty :)
17:59:42 <erisco> :t curry id -- my favourite volty
17:59:43 <lambdabot> a -> b -> (a, b)
17:59:56 <erisco> :t uncurry id
17:59:57 <lambdabot> (b -> c, b) -> c
18:00:08 <erisco> and that one
18:00:25 <tsani> oh, curry id is really neat.
18:00:37 <volty> bzzzzzzz
18:00:46 <jle`> @djinn (b -> c, b) -> c
18:00:47 <lambdabot> f (a, b) = a b
18:01:01 <jle`> @djinn a -> b -> (a, b)
18:01:02 <lambdabot> f a b = (a, b)
18:01:30 <Iceland_jack> @ty fst <*> snd
18:01:32 <lambdabot> (a -> b, a) -> b
18:02:06 <k00mi> ramfjord: what doesn't work?
18:03:09 <ramfjord> k00mi: I added the tests that I've been running at the bottom
18:03:18 <redtricycle> what do people use for cookie jars?
18:03:52 <eazar001> storing money
18:03:55 <eazar001> and storing cookies
18:05:33 <no-doz> :t fromMaybe
18:05:34 <lambdabot> a -> Maybe a -> a
18:05:36 <no-doz> :t maybe
18:05:36 <lambdabot> b -> (a -> b) -> Maybe a -> b
18:06:21 <jle`> :t foldr
18:06:22 <lambdabot> (a -> b -> b) -> b -> [a] -> b
18:07:00 <erisco> :t uncurry uncurry
18:07:01 <lambdabot> (a -> b -> c, (a, b)) -> c
18:07:04 <erisco> :t uncurry curry
18:07:06 <lambdabot> ((b, b1) -> c, b) -> b1 -> c
18:08:06 <k00mi> ramfjord: pull out the sepBy and it will work, but it might not be exactly what you want
18:08:26 <ramfjord> which sepBy?
18:09:03 * hackagebot mvc-updates 1.1.1 - Concurrent and combinable updates  http://hackage.haskell.org/package/mvc-updates-1.1.1 (GabrielGonzalez)
18:09:14 <k00mi> ramfjord: both
18:10:04 <ramfjord> k00mi: in selColumnGroup?
18:10:10 <k00mi> yes
18:11:10 <k00mi> selColumnGroup = sepBy1 (try (NamedColumnGroup <$> selNamedColumn) <|> (UnnamedColumnGroup <$> selUnnamedColumn)) comma
18:11:30 <vanila> How does garbage collection work for statically typed languages? If you erase all the type information how does GC know how to handle the data?
18:12:24 <erisco> benzrf, so fmap is the mapping of arrows, and the type constructor is the mapping of objects?
18:12:34 <benzrf> ye
18:12:59 <benzrf> erisco: also, the Category class is for other categories whose objects are haskell types and whose morphisms are haskell values
18:13:04 <shiona> vanila: I would assume the data itself is discarded as well
18:13:09 <benzrf> @src Category
18:13:09 <lambdabot> Source not found. Abort, Retry, Panic?
18:13:13 <benzrf> hmm
18:13:19 <benzrf> well,
18:13:23 <benzrf> class Category cat where
18:13:27 <benzrf>   id :: cat a a
18:13:36 <benzrf>   (.) :: cat b c -> cat a b -> cat a c
18:13:59 <benzrf> erisco: a value of type cat a b is a morphism from a to b in your new category
18:14:02 <erisco> benzrf, might the arrows not be mapped to functions? is that just a simplification in Haskell?
18:14:21 <benzrf> erisco: well, not all of the possible categories are isomorphic to Hask
18:14:23 <ramfjord> k00mi: I'll take a look at a second - a problem may also be that I wasn't matching spaces after an unnamedColumn
18:14:30 <benzrf> er, Categories
18:14:42 <benzrf> erisco: for example,
18:14:50 <erisco> I am still talking about Functor
18:14:52 <benzrf> o
18:14:59 <benzrf> erisco: what do you mean
18:15:02 <Fuuzetsu> benzrf: you mean equivalent?
18:15:07 <benzrf> Fuuzetsu: eek yes
18:15:09 <benzrf> whatever
18:15:42 <benzrf> erisco: what do you mean
18:15:53 <benzrf> erisco: oh well not all functors are instances of Functor
18:16:03 <benzrf> only endofunctors on Hask whose object mappings are type constructors
18:16:15 <Hodapp> What defines whether something can be non-strict or not? Is it just whether or not it is defined inductively?
18:16:21 <benzrf> and whose morphism mappings can be expressed as computable haskell functions
18:16:23 <DannyFritz> i'm trying to learn haskell and working on project euler problem #1, i'm having a hard time figuring out how to define a value. http://codepad.org/aApusV35
18:17:01 <Fuuzetsu> DannyFritz: you're missing a ‘=’ after ‘main’
18:17:04 <benzrf> DannyFritz: you want `main = print problem1'
18:17:40 <DannyFritz> omg, thanks guys. i was going nuts
18:18:44 <eazar001> let numbers = union [3,6..999] [5,10..999] in (sum numbers)
18:18:49 <erisco> benzrf, perhaps I mean something like   class Functor (f :: * -> *) (a1 :: * -> * -> *) (a2 :: * -> * -> *) where fmap :: a1 a b -> a2 (f a) (f b)
18:18:51 <eazar001> > let numbers = union [3,6..999] [5,10..999] in (sum numbers)
18:18:53 <lambdabot>  233168
18:19:12 <DannyFritz> eazar001: you can use lets in subsequent lets?
18:19:19 <DannyFritz> er wait, nvm
18:19:28 <eazar001> DannyFritz: yes
18:19:28 <erisco> benzrf, because the arrows do not have to be functions
18:19:33 <eazar001> DannyFritz: but i didn't do that
18:20:26 <eazar001> > let x = 5 in let y = x*x in y
18:20:29 <lambdabot>  25
18:20:44 <eazar001> let x = 5 in let y = x*x in 2*x*y
18:20:47 <DannyFritz> awesome to see. :)
18:20:47 <eazar001> > let x = 5 in let y = x*x in 2*x*y
18:20:50 <lambdabot>  250
18:20:54 <ramfjord> k00mi: I can't get your versions types correct
18:21:15 <eazar001> yea, at the basic level, anything you can do in ML, you cann do in haskell
18:21:29 <eazar001> for the most part i guess
18:21:31 <erisco> benzrf, maybe Functor in Haskell is slightly simplified, and also worth noting that multi parameter type classes might not have been around at the time
18:21:42 <jle`> typically it's more idiomatic to do let x = 5; y = x*x in y
18:21:43 <benzrf> erisco: yeah exactly
18:21:49 <benzrf> like i said,
18:21:50 <ramfjord> k00mi: but it looks like it will just give me a single column in each group
18:21:54 <dibblego> I think edwardk's talk on Hask is relevant here
18:21:54 <benzrf> 09:15 < benzrf> erisco: oh well not all functors are instances of Functor
18:21:54 <benzrf> 09:15 < benzrf> only endofunctors on Hask whose object mappings are type constructors
18:21:57 <benzrf> 09:15 < benzrf> and whose morphism mappings can be expressed as computable haskell functions
18:22:02 <ramfjord> k00mi: even if I do get it grouped
18:22:06 <erisco> benzrf, but is my multi parameter interpretation of a Functor correct?
18:22:10 <eazar001> DannyFritz: what jle` said, but i was just trying to show it's "possible"
18:22:10 <jle`> the first way is more useful if you want to explicitly say what is recursive and what isn't, etc.
18:22:13 <benzrf> yes as far as i can tell
18:22:29 <benzrf> also i'd use c and d for the categories it maps between
18:26:54 <DannyFritz> >> let x = 5; y = x*x in y
18:26:59 <DannyFritz> > let x = 5; y = x*x in y
18:27:01 <lambdabot>  25
18:28:20 <jle`> as for lets in lets, lets are just normal statements
18:28:41 <jle`> they're actually pretty easily reducable, too
18:29:04 <benzrf> reducible
18:29:17 <jle`> let x = 5 in (let y = x * x in 2*x*y)  ==> let x = 5 in (2*x*(x*x)) ==> 2*(5*(5*5))
18:29:36 <jle`> i'm pretty sure i meant reduckable...can be re-made into ducks
18:36:03 <erisco> benzrf, I was trying to think of arrows other than functions in Haskell, and it seems to be that Either is not one of them
18:36:48 <erisco> benzrf, because it is not composable it seems
18:36:50 <benzrf> erisco: make a poset category with type-level nats
18:37:04 <benzrf> i did, it was fun o3o
18:37:15 <benzrf> erisco: on the easier side, ever heard of kleisli categories??
18:37:33 <erisco> at a point, yes, but I forget
18:37:45 <erisco> does that give you apply?
18:37:51 <benzrf> i dunno
18:37:53 <benzrf> but
18:38:39 <benzrf> if you have a category C an endofunctor M which is part of a monad, then you can construct a category Kleisli(C) where a morphism from A to B is a morphism in C from A to M(B)
18:38:59 <benzrf> er, that'd be Klesili(C, M) or something actually
18:39:11 <benzrf> in haskell terms, Kleisli m a b = a -> m b
18:39:23 <benzrf> composition is kleisli composition, aka (>=>)
18:39:38 <benzrf> a -> m b and b -> m c become a -> m c
18:39:46 <benzrf> :k Kleisli
18:39:48 <lambdabot> (* -> *) -> * -> * -> *
18:39:55 <erisco> I was hoping to find something more pedestrian, but there are not too many * -> * -> * things
18:40:07 <benzrf> :t (C..) `asAppliedTo` Kleisli putStrLn
18:40:08 <lambdabot> Kleisli IO String () -> Kleisli IO a String -> Kleisli IO a ()
18:40:42 <benzrf> erisco: that's pretty pedestrian
18:40:53 <benzrf> newtype Kleisli m a b = Kleisli (a -> m b)
18:40:58 <erisco> in Haskell terms it certainly is not
18:41:12 <benzrf> Kleisli m is a Category instance where m is a mona
18:41:13 <benzrf> d
18:41:42 <erisco> oh, why not I try (,)
18:41:54 <benzrf> erisco: aka a poset category basically
18:42:00 <benzrf> oh wait no
18:42:05 <jle`> are you looking for neat Category instances you might already know
18:42:51 <benzrf> instance (Monad m) => Category (Kleisli m) where id = return; (.) = (>=>)
18:42:52 <benzrf> ezpz
18:45:14 <jle`> (<=<)
18:45:59 <erisco> jle`, I am just screwing around to try and understand the relationship between what little Category Theory I am learning and Haskell
18:47:05 <erisco> hrm, cannot do (,)... I can define composition but not identity
18:48:54 <eazar001> :t (>=>)
18:48:55 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
18:49:08 <eazar001> :i Category
18:49:53 <Fuuzetsu> no :i in lambdabot
18:50:22 <benzrf> sadly ;-;
18:50:22 <eazar001> yea, i'm pretty sure this is the dozenth time i've made this mistake =P
18:50:34 <benzrf> erisco: do a poset category!!!
18:50:37 <merijn> erisco: I wouldn't try to hard, there's not really any obvious/close relationship to be found
18:50:59 <Fuuzetsu> a category generated by a poset or Pos?
18:51:05 <benzrf> poset
18:51:19 <benzrf> erisco: every monoid gives rise to a category
18:51:20 <benzrf> do that!
18:52:35 <erisco> I am specifically trying to find instances for the generalized Functor class I defined that do not exclusively use functions as the arrows
18:52:37 <rodlogic_> when I read "Generative Functors" how is that different than just "Functors"?
18:55:10 <benzrf> 09:50 < benzrf> erisco: every monoid gives rise to a category
18:55:10 <benzrf> 09:50 < benzrf> do that!
18:55:26 <benzrf> then functors will  be monoid homomorphisms :-)
19:00:53 <dfeuer> Whoa... How long does cabal update usually take?
19:01:12 <gamegoblin> merijn: you around?
19:02:03 <merijn> gamegoblin: Yeah
19:02:22 <gamegoblin> Didn’t you link me to that haskellforall post about using data-defined interfaces (rather than typeclasses)
19:02:44 <merijn> Sounds like something I'd do :)
19:02:51 <gamegoblin> It was just yesterday or the day before
19:03:02 <dfeuer> ARGH. Someone recommended data-pprint, and I'd really like to try it, but the Hackage package at least is base < 4.7.
19:03:28 <gamegoblin> merijn: anyway, totally blew my mind
19:03:34 <merijn> dfeuer: "cabal get" -> change upper bound -> install OR "caball install --allow-newer"? :)
19:03:37 <dfeuer> Er .... well.... it needs a hashable version that needs that, I guess.
19:04:02 <dfeuer> merijn, cabal is another mystery I will have to tackle once I have some clue about git.
19:04:38 <merijn> gamegoblin: That's actually how GHC implements typeclasses (it's not the only way, I believe UHC does things differently), but GHC just translates them to dictionaries that get passed as extra argument (if GHC can statically determine the dictionary it can actually inline the lookup, making typeclasses cheaper than, for example, OO method lookups)
19:05:09 <dfeuer> Actually, merijn, I don't have a clue how to interpret these errors.
19:05:39 <merijn> dfeuer: In that case, manually install hashable with changed upper bound and then repeat?
19:06:59 <dfeuer> merijn, this is the error, in case it means something to you: http://lpaste.net/2276599341399408640
19:07:40 <gamegoblin> what’s the time comlexity of pattern matching on a tuple. i.e. if I have an 9-tuple and have a function like get7th (_,_,_,_,_,_,x,_,_) = x, is that constant time?
19:07:47 <gamegoblin> complexity*
19:07:50 <vanila> yes, it's O(1)
19:08:06 <vanila> in general a pattern match is O(1), because it's fixed
19:08:17 <gamegoblin> Was wondering how ghc implements tuples under the hood. I imagine somewhat similar to a C-struct, but I dunno
19:08:20 <vanila> that said your pattern match takes one operation
19:08:30 <vanila> but (_,(_,(_,(_,(_,(_,x)))))) takes 7
19:08:41 <dfeuer> In general almost nothing is *really* O(1).
19:08:42 <systemfault> Is (2/) is partial? How is it called?
19:08:57 <Iceland_jack> > (2/) 0
19:08:59 <tabemann> (2/) 3
19:08:59 <lambdabot>  Infinity
19:09:16 <dfeuer> merijn, does that error mean something to you?
19:09:30 <tabemann> note that it is partially applied, not a partial function, which is a completely different thing
19:09:58 <merijn> dfeuer: Yeah, looks like hashable has a constraint that doesn't allow 7.8, try manually installing hashable with a relaxed upper bound
19:10:00 <systemfault> tabemann: That's a weird one to me..
19:10:13 <merijn> systemfault: It's called an "operator section"
19:10:42 <dfeuer> merijn, I'm not entirely sure how to do that (by which I mean I have no idea).
19:10:45 <merijn> systemfault: A "partial function" is a function that crashes on some inputs (the opposite of a partial function is a "total function"
19:10:49 <tabemann> well, (2 /) is also a partial function per se
19:11:01 <tabemann> because it is not defined on 0
19:11:03 <merijn> dfeuer: I just said how, "cabal get" -> edit cabal file -> cabal install
19:11:07 <merijn> tabemann: Not true
19:11:07 <dfeuer> Yes; that's what confused me, tabemann.
19:11:10 <merijn> tabemann: Depends on the type
19:11:13 <merijn> > 2/0
19:11:14 <lambdabot>  Infinity
19:11:19 <merijn> There, no crash
19:11:36 <merijn> systemfault: An example of a partial function is head/tail
19:11:37 <merijn> > head []
19:11:39 <lambdabot>  *Exception: Prelude.head: empty list
19:11:42 <dfeuer> > (2 `quot`) 0
19:11:43 <lambdabot>  *Exception: divide by zero
19:11:43 <tabemann> (2 :: Int) / (0:: Int)
19:11:52 <merijn> tabemann: Type error
19:11:53 <systemfault> merijn: I see
19:11:58 <merijn> tabemann: Int is not fractional :)
19:12:15 <merijn> systemfault: Anyway, (2/) is an operator section, which is a way of partially applying operators
19:12:23 <tabemann> (2 :: Int) `div` (0:: Int)
19:12:27 <dfeuer> But `quot` and (GRRRR) `mod` work on Integral things.
19:12:32 <systemfault> merijn: Thank you :)
19:12:32 <tabemann> > (2 :: Int) `div` (0:: Int)
19:12:34 <lambdabot>  *Exception: divide by zero
19:12:50 <DannyFritz> how would i filter a set by mod 3 === 0 or mod 5 === 0
19:12:56 * dfeuer shoots arrows at mod while looking at it funny.
19:12:57 <DannyFritz> er, a list
19:13:34 <merijn> :t filter (\x -> x `mod` 3 == 0 || x `mod` 5 == 0)
19:13:36 <lambdabot> Integral a => [a] -> [a]
19:13:54 <merijn> > filter (\x -> x `mod` 3 == 0 || x `mod` 5 == 0) [1..10]
19:13:55 <lambdabot>  [3,5,6,9,10]
19:14:09 * hackagebot fix-imports 1.0.4 - Program to manage the imports of a haskell module  http://hackage.haskell.org/package/fix-imports-1.0.4 (EvanLaforge)
19:14:17 <merijn> Right, back to being productive (i.e., netflix)
19:15:37 <dfeuer> DannyFritz, actually, if you want to know if the remainder is *0*, and the divisor is known to be *positive*, you should use `rem` instead of `mod`.
19:16:15 <dfeuer> Actually, for knowing if it's zero, you might not even need a positive divisor; not sure.
19:16:42 <DannyFritz> can i not shadow names in `let` statements? http://codepad.org/NYJfT8Zz
19:17:09 <athan> Is it okay to ask for an associated-type style function in a class definition? Like this: http://lpaste.net/111398 ?
19:17:13 <dfeuer> Yeah, it looks like `rem` is always good for checking for congruence like that, and it's faster than mod.
19:17:25 <tabemann> DannyFritz: you can shadow names, but if a name is on both sides of the = it is treated as being a recursive reference
19:18:26 <dfeuer> DannyFritz, I don't think you're doing anything wrong with that, except the 1.2 where you mean 1,2
19:18:36 <geekosaur> yeh
19:18:54 <geekosaur> you are using something that was forced to Fractional by `1.2` in a context requiring Integral
19:18:56 <DannyFritz> omg, dfeuer thanks. i don't know why i'm failing to understand the errors so much
19:19:00 <geekosaur> so it threw a type error
19:19:14 <eazar001> > let filtered = filter (\x -> x `mod` 3 == 0 || x `mod` 5 == 0) x in sum filtered
19:19:16 <lambdabot>  Couldn't match expected type ‘[a1]’
19:19:16 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’
19:19:16 <lambdabot>  Relevant bindings include
19:19:16 <lambdabot>    filtered :: [a1] (bound at <interactive>:1:5)
19:19:38 <geekosaur> some people claim hugs' errors are easier than ghc's. I never did get the hang of interpreting them; ghc's procide enough information to decipher them, with hugs you have to guess
19:19:43 <eazar001> > let filtered = filter (\x -> x `mod` 3 == 0 || x `mod` 5 == 0) [1..20] in sum filtered
19:19:45 <lambdabot>  98
19:19:57 <dfeuer> Unfortunately (perhaps?) Haskell's type system is always open to the possibility that some day something will be both Integral and Fractional.
19:21:34 <eazar001> sum > [x | xs <- [1..20], xs `mod` 3 == 0 || xs `mod` 5 == 0]
19:21:39 <eazar001> > sum [x | xs <- [1..20], xs `mod` 3 == 0 || xs `mod` 5 == 0]
19:21:41 <lambdabot>  0 + x + x + x + x + x + x + x + x + x
19:22:20 <Hafydd> dfeuer: I think that would be sensible for integers modulo prime p.
19:22:26 <eazar001> > sum [xs | xs <- [1..20], xs `mod` 3 == 0 || xs `mod` 5 == 0]
19:22:28 <lambdabot>  98
19:22:33 <dfeuer> Hafydd, point!
19:22:36 <Hafydd> Maybe not fromRational, though...
19:22:45 <dfeuer> Hrrr.
19:22:53 <DannyFritz> is there a good way to composing (\v -> v `mod` 3 == 0 || v `mod` 5 == 0) instead of a lambda
19:23:24 <DannyFritz> i guess create a function that does it
19:23:25 <geekosaur> there are certainly ways. the ones that come to mind I would not call good
19:23:49 <eazar001> http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
19:23:55 <DannyFritz> alright thanks. this room has been super helpful
19:24:03 <eazar001> DannyFritz: for primes and stuff ^
19:24:27 <eazar001> lazy merging for efficient pseudo sieve prime generator
19:24:33 <DannyFritz> eazar001: i was thinking of creating a naive infinite list for prime generation for now
19:24:41 <shachaf> liftA2 (||) (\v -> v `mod` 3 == 0) (\v -> v `mod` 5 == 0) is one sort of thing you could do.
19:25:15 <eazar001> DannyFritz: that works, but this implementation is only about 10 lines more, and it is way more efficient
19:25:26 <eazar001> and it teaches you idiomatic haskell usage ... to an extent
19:25:57 <DannyFritz> is that using || as an infix?
19:26:09 <shachaf> No.
19:26:37 <DannyFritz> heh, it would be using it as a non-infix
19:26:42 <MP2E> ( ) around an infix operator makes it used as if it were a regular function
19:26:51 <MP2E> infix function, I should say
19:26:53 <MP2E> as it's not an operator.
19:27:20 <DannyFritz> i think i saw backticks were used to infix any function
19:27:27 <MP2E> yes
19:27:33 <MP2E> `div` or `mod`
19:32:31 <DannyFritz> > 1e10
19:32:33 <lambdabot>  1.0e10
19:33:03 * DannyFritz should problem leave ghci open
19:33:14 <dfeuer> Hafydd, https://ghc.haskell.org/trac/ghc/ticket/9624#ticket
19:33:24 <shachaf> You can also /msg lambdabot.
19:36:30 <eazar001> you can also install lambdabot into your ghci if you like it so much
19:36:56 <eazar001> (what i did)
19:39:11 * hackagebot xmpipe 0.0.0.3 - XMPP implementation using simple-PIPE  http://hackage.haskell.org/package/xmpipe-0.0.0.3 (YoshikuniJujo)
19:40:06 <dfeuer> merijn, it looks like Criterion requires an old version of hashable while the pretty-printer needs a new version. Or something.
19:40:21 <dfeuer> Criterion seems to want other old stuff too.
19:41:38 <dfeuer> I think I get the concept of Cabal sandboxes, but I don't get the concept of how to make enough sandboxes to do a variety of things without blowing up your hard drive.
19:42:24 <tabemann> upper bounds on package versions considered harmful
19:42:49 <RyanGlScott> Is there an equivalent to Show and Read for Text?
19:43:11 <RyanGlScott> Without having to convert to and from Strings?
19:43:14 <eazar001> dfeuer: certain sandboxes, i believe, have a lot of "overlap"
19:43:37 <eazar001> so maybe one strong in networking can be used over and over again for a variety of packages
19:44:07 <dfeuer> eazar001, there's also the challenge of having different *tools* in different sandboxes, but different *programs* need various tools, and sometimes different tools at different times.
19:44:10 <eazar001> try to do minimal ghc build, and i think that will maximize your sanadbox potential
19:44:24 <eazar001> dfeuer: yea, it's a bit of an art
19:44:42 <dfeuer> I might need Criterion one moment, and data-pprint at another, and QuickCheck some other....
19:50:32 <tabemann> why do people even put upper bounds on package versions in their packages; there's really no way one can know what future package versions one's package will be incompatible with, so why even guess?
19:51:20 <geekosaur> there have been lomg arguments over that. the breakages are much much worse if you claim you support every new version and something changes in a new major version
19:52:53 <geekosaur> lazy devs ALWAYS insist this is a non-issue, then "oh that was a one-off" every time it happens. by the time you hit 3 ecosystem-breaking changes like that in a week (has happened a couple of times) that sounds hollow --- yet devs will be right back to "that never happens" shortly after most of hackage has had its packages edited to get around the breakages
19:53:05 <dfeuer> geekosaur, the point is that there's no way to know if that will happen or not.
19:53:17 <geekosaur> "yup, that never happens, except every time a core package has a new major version that breaks everything"
19:53:34 <tabemann> dfeuer: exactly
19:53:51 <geekosaur> no, but it's easier to slip the upper version --- especially since cabal provides a flag to ignore them --- than to fix everything after it does happen
19:54:12 <geekosaur> but yes, you being lazy is far more important than everyone trying to install apackage being SOL after containers revs, yep
19:54:21 <TheMoonMaster> So I have a cabal sandbox and keep getting "Could not find module ‘Text.ParserCombinators.Parsec’" and that "It is a member of the hidden package ‘parsec-3.1.6’."
19:54:29 <tabemann> where do you place the upper bound, though, if you're guessing about a version that doesn't even exist yet
19:54:31 <TheMoonMaster> Then below it I get the same message, but with 3.1.5
19:54:36 <TheMoonMaster> Any ideas on how to fix that?
19:54:52 <geekosaur> it means you have both installed and neither specified in your cabal file
19:54:54 <TheMoonMaster> parsec is in my build-depends
19:55:19 <geekosaur> huh. think we'd need to see detailed (cabal install -v3) output then
19:55:40 <TheMoonMaster> I'm not specifying a version, maybe that's it?
19:56:03 <geekosaur> that allows it to try either one. but if both are excluded by other dependencies then you would see this, I think
19:56:12 <geekosaur> which is why I asked for the verbose output
19:56:19 <TheMoonMaster> Sure, let me grab it real quick
19:57:52 <geekosaur> tabemann: the real problem is that specifying an upper version causes breakage at the point where you see it, not specifying it causes breakage at a distance and usually involving more packages
19:58:40 <geekosaur> so not specifying it is saying "f*** everyone else, I got mine" and everyone else gets to clean up the pieces
19:59:21 <geekosaur> instead of the package causing the problem being broken, its distant dependents shatter
20:01:51 <TheMoonMaster> http://lpaste.net/7926160410154106880
20:04:13 <TheMoonMaster> geekosaur: Tried specifying, no dice.
20:07:14 <geekosaur> OH
20:07:30 <geekosaur> you have two versions of parsec3 installed
20:07:42 <geekosaur> "Text.ParserCombinators.Parsec" is parsec2
20:07:49 <geekosaur> "Text.Parsec" is parsec3
20:08:05 <DannyFritz> haskell keeps telling me my types are too general. http://codepad.org/u1cgClwO
20:08:11 <TheMoonMaster> "Could not find module ‘Text.Parsec’"
20:08:13 <TheMoonMaster> Hah
20:08:18 <TheMoonMaster> No luck tonight for me.
20:08:46 <geekosaur> mm, actually it looks like parsec3 should have the backward compatibility stuff anyway
20:09:07 <geekosaur> this isn't making a lot of sense to me unfortunately, I think you need someone better at cabal internals
20:09:36 <TheMoonMaster> Sure, I'll sleep on it and bother with it tomorrow.
20:09:40 <TheMoonMaster> Thanks for the help geekosaur
20:09:51 <geekosaur> DannyFritz, when you say the type is (a -> a) you are explicitly saying there are no constraints. but you are using (<=) which means you need at least Ord a
20:10:16 <DannyFritz> geekosaur: i also just realized my infinite list is very wrong
20:10:22 <geekosaur> and you are using sum which requires (Num a)
20:10:22 <DannyFritz> geekosaur: thanks
20:10:38 <geekosaur> so the correct generalized type is (Ord a, Num a) => a -> a
20:11:25 <geekosaur> (and once again, the fact that codepad uses hugs means that it gives you an error message that doesn't tell you either of those things)
20:11:57 <DannyFritz> i'm running it in ghc locally, but the errors are so verbose too
20:12:21 <geekosaur> they are verbose, but they give you key information. ghc should have mentioned both Ord and Num being missing, and how it determined that
20:12:44 <geekosaur> hugs didn't mention either, just that maddening "not general enough"
20:14:17 <DannyFritz> i wish ghc had colors in the output
20:14:35 <jmct> anyone have experience with the wreq library?
20:14:39 <jollygood> how is that extension called that allows different data definitions to use same field names?
20:14:56 <DannyFritz> thanks for the help geekosaur
20:17:04 <geekosaur> jollygood, http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#disambiguate-fields (DisambiguateRecordFields)
20:17:16 <geekosaur> plus I gather there's a new one coming in 7.10
20:18:21 <jollygood> what makes it different/better?
20:19:03 <DannyFritz> sometimes i feel like all the stuff on SO about haskell are programming gold entries.
20:19:09 <DannyFritz> golf*
20:26:41 <jollygood> oh, DisambiguateRecordFields is weaker than I thought. I thought the function name could be disambiguated as well.
20:27:34 <justin_smith> bitemyapp: hey man, I have a weird unicorn request, it's OK if no such thing exists, but if there were an intro level haskell thing with a focus on graphs and graph algorithms I would consume it eagerly
20:31:20 <athan> What would be a good, visual example of Alternative's `many` or `some`?
20:31:35 <athan> It loops when I use a list :/
20:32:00 <bitemyapp> justin_smith: hi!
20:32:04 <monochrom> a parser is a good example. but I don't know whether you consider parsers visual.
20:32:23 <monochrom> for example in Parsec, Alternative's many = Parsec's many.
20:32:28 <jollygood> is there an extension that allows this?  data Dog = Dog { name :: String }  data Person { name ::String }.  where I could use 'name dog'  and  'name person'  without having to qualify module names and without Ambiguous occurrence error
20:32:30 <justin_smith> bitemyapp: hello
20:32:38 <Fuuzetsu> jollygood: no
20:32:53 <Fuuzetsu> you can use a typeclass like HasName but it's probably not what you want
20:33:22 <jollygood> manually creating a typeclass for each common field would be a pain
20:33:36 <monochrom> "many (char 'x')" does not loop, it succeeds and stops at the first non-'x'. similarly some.
20:33:40 <jollygood> if it can be done automatically though that would be neat
20:33:43 <bitemyapp> justin_smith: adding a section to learnhaskell
20:33:44 <Fuuzetsu> jollygood: you can use vinyl to achieve what you want then
20:33:47 <bitemyapp> justin_smith: you will be linked momentarily.
20:34:08 <justin_smith> bitemyapp: awesome, thanks
20:34:28 <monochrom> however, many and some are meant to loop for several other Alternatives.
20:34:29 <jollygood> Fuuzetsu I will look into that thanks
20:34:50 <Fuuzetsu> no problem; it will let you use the same function on two different records as long as they have the property
20:35:04 <merijn> justin_smith: Hold on, I have a bunch of papers on functional graph algorithms, I think
20:35:23 <justin_smith> merijn: awesome, the more the merrier, thank you :)
20:36:40 <merijn> ah, bollocks, I think I deleted them for not being useful enough to me
20:36:58 <merijn> There's quite a bunch if you just google scholar for haskell/functional graph processing
20:36:59 <athan> monochrom: Ahh okay. Maybe there's an instance for (-> a)?
20:37:08 <splintax> i guess zippers are relevant to graph traversal. https://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf
20:38:29 <justin_smith> merijn: cool, I'll check it out. I am new enough to haskell that I figured asking here would be more productive than random googling in terms of getting solid stuff - I'd hate to jump into something that was a misleading introduction (even though it is decent intermediate material)
20:39:37 <merijn> justin_smith: Well, there were some decent papers explaining the techniques of FGL (Functional Graph Library) and things on DFS in haskell, that I remember. I guess it depends on the kinda graph processing you're doing
20:39:54 <bitemyapp> merijn: this is in the stuff I am adding to my guide.
20:40:07 <bitemyapp> merijn: I've got the papers for FGL and the structured graph/PHOAS stuff in the pipe.
20:41:33 <mbuf> I would like to know what is the difference between a property in Haskell and functions that can assert condition checks on data, say with if statements in Haskell
20:41:49 <mbuf> a property as defined as functions in a type class
20:43:02 <splintax> mbuf: i'm still confused as to what you mean by a property
20:43:26 <merijn> Also, note that haskell doesn't have if statements, only "if-then-else" expressions
20:43:38 <mbuf> splintax, property as used in QuickCheck, for example, http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck1
20:43:58 <mbuf> merijn, yes, sorry, if-then-else statements
20:46:07 <splintax> mbuf: i guess there is no difference then? QuickCheck is just a library
20:46:25 <mbuf> splintax, okay
20:46:27 <splintax> it saves you the trouble of writing those if-then-else expressions yourself
20:46:57 <HeladoDeBrownie> mbuf, "a property as defined as functions in a type class" Sounds like you're talking about methods.
20:48:00 <HeladoDeBrownie> mbuf, "property" is a term used specifically by QuickCheck and can be understood in terms of that library's interface; it's not a general Haskell term.
20:48:05 <mbuf> HeladoDeBrownie, sorry about my terminology; so, the data types that are instances of these type classes implement these methods?
20:48:18 <HeladoDeBrownie> mbuf, basically.
20:48:57 <mbuf> HeladoDeBrownie,  if I have an XML tag say <foo class='bar'>, and it is mandatory that every foo tag have a class 'bar', how can this dependent data type be represented in Haskell?
20:50:29 <HeladoDeBrownie> mbuf, I'm not familiar enough with XML to give you a full representation, but you could either use so-called "smart constructors", which give you a value of a type but enforce some constraints themselves, or there may be other ways to encode certain properties in types, even if not as nicely as in a truly dependently typed language.
20:50:49 <mbuf> HeladoDeBrownie, thanks!
20:51:07 <HeladoDeBrownie> For example, using type-level strings (which exist in some extension, I forget which), you could have a type WithClass "bar" that you parameterize your XML element on.
20:51:30 <HeladoDeBrownie> That's just a rough example, your actual code will probably not do quite that.
20:51:35 <mbuf> HeladoDeBrownie, okay
20:53:38 <monochrom> I have a fable to tell.
20:53:57 <HeladoDeBrownie> For a common example of encoding properties in types, consider data Nat = Zero | Succ Nat and Vec (length :: Nat) a where Null :: Vec Zero a ; Cons :: a -> Vec l a -> Vec (Succ l) a. (This requires DataKinds and GADTs.)
20:54:19 <HeladoDeBrownie> s/Vec/data Vec/
20:54:36 <monochrom> A client wants a program that behaves simply this: if you input 5, it outputs "hi"; if you input 7, it outputs "hello"; if you input other things, it outputs "error".
20:54:47 <vanila> mbuf, data XML = Foo String | ...
20:56:01 <jollygood> I want this :|. https://ghc.haskell.org/trac/haskell-prime/wiki/TypeDirectedNameResolution
20:56:33 <vanila> jollygood, what does this solve that typeclasses dont?
20:57:47 <jollygood> vanila you don't have to manually create a new typeclass for every common field (and instances of that typeclass for all the objects sharing a field)
20:58:10 <jle`> but typeclasses were invented to solve that in the first place :P
20:58:13 <jle`> we saw that as a *problem*
20:58:16 <jle`> not a solution :P
20:58:30 <jollygood> boilerplate is a solution?
20:58:39 <vanila> jollygood, what if records automaically created a typeclass?
20:58:48 <vanila> I mean instantiated
20:59:10 <HeladoDeBrownie> monochrom, there's more to the fable, right?
20:59:17 <monochrom> Blackadder says, he has a cunning plan: he will use dependently-typed numbers to store the input. if you input 5, his program constructs a dependently-typed number that says "I am 5" at the type level; if you input 7, similarly with s/5/7/; if you input something else, it constructs something else that I don't bother to think up. after that stage, another stage examines the dependent types of the thing constructed and dispatch on it to the right output.
20:59:19 <HeladoDeBrownie> Oh.
20:59:32 <monochrom> But he is doing such an XY problem.
20:59:48 <jle`> making sure that everything that used (+) and (>>=) etc. behaved in predctable ways and can be reasoned with meaningfully...and also that anything that implements (+) also implements (-), was a big achievement :)
21:00:04 <jollygood> vanila I don't know, I am not sure I like the idea of having one class for every common field
21:00:22 <monochrom> if you want an internal representation at all, "data T = X | Y | Z" is all you need. no need for dependent types and type level guarantees that "it is 5"
21:00:36 <jle`> and also being able to write code that worked on all things that impelmented (+), generically
21:00:46 <jle`> and give it a meaninggful type signature
21:01:58 <HeladoDeBrownie> monochrom, I think I would have responded differently had dependent types not been explicitly mentioned; that said, yeah, DT is not the first way that comes to mind for solving either the earlier problem or the one in your fable :P
21:02:59 <HeladoDeBrownie> Really there's not much point in abstracting something unless you're going to actually use the abstraction.
21:03:36 <HeladoDeBrownie> case x of 5 -> ... ; 7 -> ... ; _ -> ... -- done
21:04:19 * hackagebot vimus 0.2.0 - An MPD client with vim-like key bindings  http://hackage.haskell.org/package/vimus-0.2.0 (SimonHengel)
21:04:56 <yyttr3> I'm trying to make a program using SDL to work with SDL2, does anyone know what to do with SDL.withOpenGL? I can't figure out what to turn it into. It's the only problem with the program.
21:09:19 * hackagebot pandoc-citeproc 0.6 - Supports using pandoc with citeproc  http://hackage.haskell.org/package/pandoc-citeproc-0.6 (JohnMacFarlane)
21:11:23 <jollygood> vanila typeclass approach would have one advantage, though, we could write generic code.  useName :: HasName a => a -> ....  . and, if such an extension existed, it would work on all the records with a name field
21:11:41 <vanila> that's a cool insight
21:12:10 <jollygood> are we just theorizing or does such an extension already exist?
21:15:05 <merijn> jollygood: There is work in GHC HEAD on overloaded record accessors
21:15:14 <merijn> jollygood: With luck it should be available in ghc 7.10
21:15:37 <jollygood> merijn how will it work? auto generated typeclasses for every field?
21:15:46 <merijn> jollygood: https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields
21:21:47 <justin_smith> bitemyapp: I see some stuff on your learnhaskell repo, is it ready for digging into or still in progress?
21:22:04 <bitemyapp> justin_smith: dive into that. the FGL stuff is more or less pre-eminent.
21:22:16 <justin_smith> awesome, thanks for being super responsive about this
21:22:30 <bitemyapp> justin_smith: the basics of the situation are that you want a graph representation that looks like a tree as much as possible or you're going to end up resorting to something like ST to make a conventional representation of a graph efficient.
21:22:37 <bitemyapp> justin_smith: the "tree" thing is why I added the structured graph bits.
21:23:10 <bitemyapp> justin_smith: admittedly it's mostly compiler hackers futzing around with the PHOAS/structured graph stuff but I thought you might be able to glean something from it. Example code for the shortest path algorithms were linked to for the FGL stuff.
21:23:24 <bitemyapp> justin_smith: if you find better material or anything in there problematic, *let me know* so I can improve it please.
21:23:36 <justin_smith> bitemyapp: ahh, OK. In my clojure experiments I was using the "atom full of edges plus atom full of vertexes" approach, but if there is something better that looks more like a tree, that's cool
21:24:20 <bitemyapp> justin_smith: replace atom with MVar and toss in Vector and you've got a plausible graph representation in Haskell, but that's relying on mutability to do the heavy-lifting for you.
21:24:30 <justin_smith> right
21:24:32 <bitemyapp> justin_smith: FGL is interesting because of the purity. Whether that's worth it or not depends on what you're doing.
21:24:46 <justin_smith> awesome, it's a great start, thanks
21:25:35 <bitemyapp> justin_smith: the reason for the tree representation is that it makes immutability...uh...possible.
21:25:41 <justin_smith> right
21:28:14 <justin_smith> though one can do an immutible type that carries a set of vertices and a mapping of vertex to edges, it makes traversal more indirect but it doesn't need to be mutable (it's easier that way though)
21:28:59 <bitemyapp> justin_smith: well I'd be curious to see what you think of the FGL author's implementation
21:29:32 <justin_smith> cool, I'll check some of this stuff out, and plan on getting back to you on that
21:30:19 <damex|home> hello, is xmonad/haskell friendly with tab formatting? im starting to use xmonad again (was using it at 2009-2011 or so) and want to format config;
21:34:21 * hackagebot purescript 0.5.6.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.5.6.1 (PhilFreeman)
21:34:23 * hackagebot persistent 2.0.5.1 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-2.0.5.1 (GregWeber)
21:34:25 * hackagebot persistent-mongoDB 2.0.6 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-2.0.6 (GregWeber)
21:35:33 <araujo> hello :)
21:36:02 <vanila> hi!
21:37:15 <jTT> hi, has anyone ever run into the problem of emacs freezing while coding in haskell? This is really odd, but occassionally, it gets real slow and then stops responding. using GNU emacs 24.3.1 on Mac OSX
21:37:41 <jTT> only the buffer with the current haskell file open though
21:39:43 <damex|home> jTT, its fine on linux
21:40:33 <jTT> yeah, i have never had this issue before
21:40:47 <jTT> there is no clear pattern…:|
21:40:48 <zwer> fine in here too, on both windows and linux. what modes are you using?
21:41:15 <dmj`> jTT: are you using ghc-mod?
21:41:24 <jTT> haskell-doc-mode and haskell-indentation
21:44:22 * hackagebot purescript 0.5.6.2 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.5.6.2 (PhilFreeman)
21:47:23 <bmuk> Is there a way for a function to behave a certain way when given one type and another when given a different type?
21:48:12 <shachaf> Maybe.
21:48:29 <shachaf> (It depends on what you mean.)
21:48:38 <bmuk> http://dmwit.com/volume/
21:48:58 <jle`> bmuk: if you mean completely different (call a completely different function based on the input type), it's in general not a recommended thing for almost all use cases.  but there are mechanisms in haskell to be able to do those things in disciplined way when tehre is a benefit
21:49:06 <jle`> it's possible you mean different things, though
21:49:20 <bmuk> Scroll to the end. I want to extend this alert function to only round when it is given a Double, but just show otherwise
21:49:32 <jle`> if you want to have it work on one of two types, you could pass in an (Either a b), and handle a Left differently than a Right, for instnace
21:50:02 <jTT> Hi, is there a function similar to concat for something like Maybe [ Maybe [Text]] -> Maybe [Text]?
21:50:23 <bmuk> jle`: that would work, but I can see where I may want to do something with the data before I show it for more than two types
21:51:20 <jle`> jTT: look at Data.Traversable, it might have something for you there
21:51:31 <jTT> kk thx
21:51:33 <jle`> or possibly Data.Foldable ... possibly.
21:51:36 <jle`> most likely the former
21:52:59 <bmuk> maybe a typeclass?
21:54:22 * hackagebot gitit 0.10.5.1 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.10.5.1 (JohnMacFarlane)
21:55:24 <TerribleAtlas> ?
21:55:50 <TerribleAtlas> who wants to shape the world?
21:56:43 <jTT> who doesnt
21:57:07 <TerribleAtlas> fair enough
21:57:14 <jle`> bmuk: typeclass is the mechanism i was referring to earlier, but it's considered bad practice in almost all use cases
21:57:42 <TerribleAtlas> except where im from everyone just exists
21:57:59 <jle`> so it's one of those things that is like...don't do it unless you understand why you sohuldn't do it
21:59:03 <bmuk> jle`: my use case is that I have a general function that takes Show a => a, and I would like to format floating point numbers with round.
21:59:40 <bmuk> But I would like to use the same function to show other values that shouldn't or can't be rounded
22:00:05 <tac-tics> It sounds like you would either need to use a Newtype and give a new Show instance for floats
22:00:09 <bmuk> Maybe I am thinking too much into this and I could just write a wrapper
22:00:13 <tac-tics> or else, typeclasses might not be what you want
22:01:06 <jle`> newtype wrapper sounds like the best option i think
22:02:04 <dmj`> bmuk: what kind of data are you representing with floats?
22:03:09 <bmuk> dmj`: xmonad has a functions for controlling the volume. They take a Double for the amount of change, and return a Double for the current volume
22:04:03 <bmuk> I don't really care about anything after 2 significant digits, but I would like to use this funtion to display the current time as well as anything else I can think of in the future, and would like to write this as DRY as possible
22:04:53 <jle`> you'll get a lot of varied opinions, but in general, new typeclasses are almost always a bad idea...especially if they are just used to prevent code duplication
22:05:04 <Helen23>  Hi! I give you some videos. I hope you like! http://tinyurl.com/ozfvxy3
22:05:23 <bmuk> I agree with you, it was simply the first thing that came to mind as far as how to solve this.
22:05:37 <jle`> :)
22:05:39 <jle`> you're not alone :)
22:05:44 <jle`> i've reached for typeclasses in the past too
22:05:47 <bmuk> I can see why it would be a bad idea - a typeclass is overkill here
22:07:07 <jle`> yeah...it can also be pretty obfuscating, and it kills a lot of ability to reason with types
22:07:28 <jle`> and they're not first-class
22:08:20 <bmuk> I think the simplest solution would be a new function, roundAlert = alert . round
22:09:16 <bmuk> The only problem with that is that I have to keep track of what type I am calling alert with, instead of alert handling that for me. But I suppose that isn't that big of a deal
22:09:43 <jle`> usually it's better to err on the side of something the compiler can typecheck for you
22:11:17 <bmuk> well it is possible I may not want to round ALL integrals I pass to alert, I just know I do want these particular ones rounded.
22:13:52 <bmuk> In that case do you think the new function is a good idea, or is it still better to make a newtype wrapper?
22:16:00 <trap_exit> this here is a genuine question: so I just got a surface 3 pro ... I used to use linux + mbp ... what haskell setups do you guys use after downloading haskell platform?
22:16:13 <trap_exit> is there some visual studio haskell thingy, or do I just install vim / emacs and go from there ?
22:17:32 <bmuk> there's this - http://leksah.org/
22:18:04 <bmuk> But I think most people use emacs or vim. Though notepad++ or any text editor should work
22:19:32 <trap_exit> hmm
22:19:34 <dmj`> trap_exit: you can use fpcomplete's ide
22:19:36 <trap_exit> IK wonder if leksah is easier to install on windows
22:19:44 <trap_exit> dmj`: you mean eclipse + fp completge?
22:20:21 <dmj`> trap_exit: just fpcomplete in the web browser, can code and deploy online
22:20:35 <trap_exit> wtf
22:20:35 <trap_exit> this soudns like magic
22:20:36 <trap_exit> is it open source
22:20:39 <trap_exit> can i run it locally?
22:21:00 <dmj`> trap_exit: there's integration with emacs
22:21:24 <dmj`> trap_exit: locally I don't think so, since the code compiles on their servers in a container
22:21:30 <dmj`> iirc
22:21:41 <jle`> you can deploy your own local server version though
22:21:50 <jle`> but i don't think you can use it as a standalone client
22:21:59 <dmj`> trap_exit: https://www.fpcomplete.com/
22:22:33 <dmj`> microsoft research attempt to create a visual haskell, but it fell through, paper is missing now... http://research.microsoft.com/apps/pubs/default.aspx?id=67496
22:22:35 <bmuk> I just want the current local time (Hour and minutes), Data.Time.Clock seems like overkill here (though obviously it can be done). Is there a simpler way?
22:22:39 <dmj`> attempted*
22:24:37 <dmj`> bmuk: import Data.Time; (y,m,d) <- (toGregorian . utctDay) `fmap` getCurrentTime
22:25:11 <trap_exit_> what do you mean
22:25:14 <trap_exit_> standalone vs local ?
22:26:16 <trap_exit_> jle`: ^^
22:27:36 <bmuk> dmj`++
22:27:42 <gamegoblin> For a simple enum-like data type, such as data Bool = True | False, how many bytes does a True or False value take?
22:28:52 <jle`> trap_exit_: as in, you'd have to have your own server running it, and logging onto that
22:29:06 <merijn> gamegoblin: That question doesn't really have an answer, as data is not guaranteed to have runtime representation
22:29:17 <gamegoblin> merijn: once the thunk is evaluated
22:29:38 <merijn> I'm not talking about laziness
22:30:11 <gamegoblin> elaborate
22:30:23 <merijn> I'm saying there might not be any memory representation for data at all. i.e. every pattern match just compiles to a specific jump statement
22:30:49 <jle`> also i could write my own haskell implementation where every ADT takes up 6 TB no matter what
22:31:01 <zRecursi`> It will explode your brain if you always think about "thunk" when programming :)
22:31:23 <merijn> I'm not sure how often this happens, but the STG paper mentions some data types just get turned into vectored returns without runtime representation
22:31:36 <shachaf> merijn: vectored-returns doesn't really happen anymore.
22:31:44 <merijn> shachaf: Really?
22:31:44 <wz1000> When I do (x <- getLine) in ghci, why is it immediately evaluated?
22:31:47 <shachaf> @where ptr-tag talks about it.
22:31:47 <lambdabot> http://research.microsoft.com/~simonpj/papers/ptr-tag/index.htm
22:32:17 <wz1000> Shouldn't it be evaluted when I do stuff with x?
22:32:45 <shachaf> gamegoblin: You could say that it's one pointer, so probably eight bytes.
22:33:14 <merijn> Did anyone ever benchmark 32bit vs 64bit performance of haskell?
22:33:15 <shachaf> Only two Bool values ever exist, so it just points to one of the static ones. Nothing is allocated.
22:33:27 <gamegoblin> shachaf: are pointers 8 bytes or 4? 8 byte pointers would be huge.
22:33:46 <wz1000> gamegoblin: depends on the computer architecture
22:33:52 <shachaf> gamegoblin: That depends on whether you have 32-bit or 64-bit GHC.
22:34:05 <shachaf> 64-bit pointers are eight bytes, surprisingly enough.
22:34:11 <MP2E> 64 bit GHC uses 8 byte pointers yes
22:34:19 <MP2E> but x86_64 itself uses 8 byte pointers
22:34:23 <vanila> gamegoblin, The best way to answer this would be to look at the generated assembly
22:34:23 <MP2E> this is not a GHC specific thing
22:34:24 <jle`> but we haven't even said we're talking about GHC
22:34:32 <jle`> we're talking about haskell
22:34:35 <vanila> GHC is basically the only haskell compiler
22:34:46 <wz1000> gamegoblin: You need eight bytes to address more than ~4 GB of ram
22:34:52 <jle`> but is he asking about Haskell the language...?  things that haskell has to, by definition, follow?
22:34:54 <merijn> vanila: That's no true, there's at least like 3
22:34:54 <MP2E> haskell does not matter when answering 'what size pointers is in generated code'
22:34:56 <jle`> or is he talking about working with GHC
22:35:03 <gamegoblin> jle`: I was referring to GHC
22:35:07 <jle`> ah, okay :)
22:35:11 <jle`> that simplifies the discussion
22:35:12 <merijn> vanila: There's UHC and augustss compiler
22:35:13 <MP2E> The size of the generated pointers is specific to the architecture only
22:35:15 <MP2E> >_>
22:35:19 <gamegoblin> As I think someone on here once said something along the lines of "to me, GHC is haskell"
22:35:27 <splintax> wz1000: it's just a ghci quirk https://www.haskell.org/ghc/docs/7.0.4/html/users_guide/interactive-evaluation.html
22:35:35 <splintax> GHCi does more than simple expression evaluation at the prompt. If you type something of type IO a for some a, then GHCi executes it as an IO-computation.
22:36:28 <jle`> i like thinking about haskell the language sometimes :/
22:36:47 <jle`> also, things are complicated these days with ghcjs and ghc-ios becoming important players
22:36:53 <wz1000> jle`: what does haskell have to follow regarding performance and runtime representation? Don't you just have to abide by haskell syntax for your language to be called 'haskell'?
22:36:56 <MP2E> the jle haskell compiler! Oh wait we already have a jhc :V
22:37:10 <jle`> wz1000: there are some required things
22:37:17 <vanila> gamegoblin, http://lpaste.net/111402
22:37:21 <jle`> but they all hae to do with semantics
22:38:29 <wz1000> jle`: Yes, but you can take a trillion cycles to add numbers and have a 42 petabyte fixed size for all data types and still be called haskell, right?
22:38:50 <jle`> yes :) it doesn't say *everything* about implementation
22:41:21 <wz1000> Are there any languages with a ZFC complete type system?
22:42:01 <wz1000> By that I mean, it should be possible to statically prove everything that can be proven using ZFC
22:42:40 <shachaf> Who cares about ZFC?
22:43:08 <wz1000> shachaf: Who doesn't?
22:43:58 <shachaf> Most people.
22:52:02 * simpson raises hand
22:54:27 * hackagebot Elm 0.13 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.13 (EvanCzaplicki)
22:59:28 * hackagebot elm-repl 0.3 - a REPL for Elm  http://hackage.haskell.org/package/elm-repl-0.3 (EvanCzaplicki)
23:04:00 <bmuk> I am trying to pass the current time to my alert function, however there is no show for IO String.
23:04:41 <bmuk> Without using UnsafePerformIO, is there a way I can show the current time?
23:06:30 <Hafydd> bmuk: why do you need to show IO String to use the value?
23:06:47 <jle`> show (IO String) wouldn't show the time, anyway
23:06:51 <Hafydd> Does the computation that eventually displays it not occur in IO?
23:07:03 <jle`> does `cat /bin/ls` show the current directory?
23:07:18 <bmuk> jle`: that's true.
23:07:50 <shachaf> What an insightful analogy.
23:07:52 <bmuk> I have time = formatTime defaultTimeLocale "%I%M" `fmap` getZonedTime
23:07:59 <jle`> shachaf: i think i owe it to someone
23:08:10 <jle`> :P
23:08:24 <bmuk> jle`++
23:08:28 <jle`> @quote /bin/ls
23:08:29 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
23:09:07 <bmuk> but I am trying call alert with this time function
23:09:11 <jle`> for the record i actualyl just tried cat /bin/ls to make sure i wasn't insane
23:09:28 * hackagebot pit 0.2.0 - Account management tool.  http://hackage.haskell.org/package/pit-0.2.0 (chiro)
23:09:30 <jle`> bmuk: what is the type of your alert function?
23:09:57 <jle`> it's hard to say without further context
23:10:07 <bmuk> Show a => a -> X ()
23:10:20 <jle`> what is X?
23:10:25 <jle`> does it allow arbitrary IO effects?
23:10:27 <bmuk> the X monad
23:10:51 <bmuk> it exists in main, moves windows around, etc, so I'm assuming it does
23:10:51 <jle`> oh, from xmonad
23:10:54 <jle`> how cute
23:10:59 <jle`> is it a MonadIO?
23:11:09 <shachaf> Maybe you should ask in #xmonad.
23:11:10 <jle`> well, it might be able to move windows around and not allow *arbitrary* effects
23:11:34 <jle`> just because you can do X () -> IO (), doesn't mean that X can execute arbitrary effects.  it might onyl be able to encapsulate a limited number of effects in its ADT
23:11:36 <bmuk> shachaf: I figured this was more of a haskell issue
23:11:58 <shachaf> Well, in #haskell I would tell you to understand how I/O works in Haskell in general before worrying about this specific case. But maybe in #xmonad there would be a different philosophy.
23:12:05 <jle`> for example, i have a function (Maybe () -> IO ()), m2io (Just x) = print "just"; m2io Nothing = print "nothing"
23:12:35 <jle`> even though i have a Maybe a -> IO a, the Maybe i put in still can't describe arbitrary IO
23:12:44 <jle`> so yeah, you might have some more luck asking people about X
23:12:45 <bmuk> I see what you are saying.
23:13:07 <jle`> if X has a MonadIO instance, it means that it has a function (IO a -> X a)
23:13:20 <jle`> meaning X can represent any arbitrary IO action
23:13:42 <bmuk> also meaning I can run the time function and actually get out a string
23:13:44 <bmuk> right?
23:13:55 <jle`> meaning that you can create an X () that represents getting and printing the time
23:14:10 <jle`> you can create an `X ()`, from composition and lifting and binding, etc., that represents getting and printing the time
23:14:29 * hackagebot elm-get 0.1.3 - Tool for sharing and using Elm libraries  http://hackage.haskell.org/package/elm-get-0.1.3 (EvanCzaplicki)
23:14:30 <jle`> and if you have that, you can just (>> myTimeGetter) to your alert function, and it'll alert and print the time
23:15:24 <jle`> (on an unrelated topic, it's a real shame that MonadIO is locked away in mtl for some reason)
23:15:37 <bmuk> Is it incorrect to think of that as running my time function?
23:15:39 <jle`> oh
23:15:42 <jle`> it's in Transformers
23:15:53 <jle`> bmuk: it's more accurate to say that you can create an X that runs your time function
23:16:01 <jle`> that...represents running your time function
23:16:21 <shachaf> Well, foo :: IO String isn't a function.
23:16:22 <splintax> so that's why it's called xmonad
23:16:33 <jle`> yeah, shachaf is right. sorry
23:16:48 <bmuk> shachaf: it's a function that takes no arguments
23:17:08 <bmuk> isn't it?
23:17:09 <jle`> bmuk: that's not a very useful definition of function :P
23:17:59 <jle`> also, in Haskell, function is a part of a type
23:18:02 <bmuk> well how is that different from a function foo :: a -> IO String, foo _ = print "hello"
23:18:04 <jle`> a -> b represents a function type
23:18:19 <jle`> so if the type doesn't have a (->), it can't really be called a function according to the language of the type system
23:18:25 <shachaf> bmuk: All functions take one argument.
23:18:39 <bmuk> because that is the kind of (->)?
23:18:47 <bmuk> :k (->)
23:18:48 <lambdabot> * -> * -> *
23:19:24 <shachaf> Because that's the meaning of the word "function".
23:19:44 <shachaf> A function is something that has type A -> B for some types A and B.
23:21:50 <bmuk> I see, I had a wrong intuition because I was thinking about functions such as f(x) = 1, but they still have a domain and codomain.
23:22:13 <adas> i think foo :: IO String not being a function makes sense if the type of a function is (-> a)
23:22:25 <bmuk> foo :: IO String has neither, but rather exists in a domain
23:22:57 <bmuk> shachaf++
23:23:50 <bmuk> jle`: the X monad in fact has a monadIO instance
23:23:57 <shachaf> A "domain" is a property of a function. foo :: IO String has a type.
23:24:55 <bmuk> You're right. is there an analog of the notion of type in pure math?
23:25:23 <splintax> yes, this is what "type theory" is about
23:25:29 <ibid> the notion of type originated in math :)
23:25:43 <bmuk> ah :)
23:25:52 <splintax> the introduction chapter of homotopytypetheory.org/2013/06/20/the-hott-book/ is a good introduction to that side of things
23:29:00 <yyttr3> Is there a gentle introduction to haskell 2010 like there is for 98?
23:29:22 <shachaf> They are very similar. Use the 98 introduction.
23:30:17 <yyttr3> It's still completely relevant after 15 years?
23:30:49 <shachaf> No major changes were made between Haskell 98 and Haskell 2010.
23:30:58 <shachaf> If you know Haskell 98 you can pick up Haskell 2010 easily.
23:31:19 <yyttr3> I see, thank you.
23:32:39 <merijn> Hell, I'm not even sure I know the differences, other than the overdue removals of DatatypeContexts and NPlusK
23:33:02 <chintanparikh> Hey people. Apologies in advanced if this is a dumb question. I'm looking to learn Haskell, but I typically only get passionate enough to learn a language if I can actually build useful things in it that take advantage of the language. So I know Ruby and C pretty well - do y'all have any intro project suggestions that would show me why Haskell is useful if I already know those languages?
23:34:30 * hackagebot elm-reactor 0.1 - Interactive development tool for Elm programs  http://hackage.haskell.org/package/elm-reactor-0.1 (EvanCzaplicki)
23:34:46 <shachaf> The difference between Haskell and Ruby/C is bigger than the difference between Ruby and C.
23:35:22 <shachaf> I would say that jumping right into "building useful things" is actually not a helpful way to learn the language.
23:35:41 <chintanparikh> shachaf: Usually I go and learn the basics of it, but unless I build something, I get bored pretty quickly
23:36:08 <yyttr3> Langauges are a medium for thought, so the purpose of learning new languages should be to expand your ability to reason about problems. You can build useful things in any language.
23:36:14 <merijn> chintanparikh: The problem is that the basics are probably completely different from any language you know
23:36:45 <chintanparikh> merijn: Hmm, okay. I guess I'm intrigued enough to at least put in a little groundwork. Any recommended reading materials?
23:36:46 <MP2E> You can make anything in Haskell, same as any turing complete language, not sure where the notion came from that haskell is a restrictive in use
23:36:56 <MP2E> it's only 'restrictive' in that it's harder to write incorrect programs
23:36:57 <merijn> So "learn th basics" might take cosiderably more time than you're used to
23:36:59 <copumpkin> you can build all sorts of (terribly designed) useful things in PHP, and many people do. Learning a new language is about far more than just cobbling something together
23:37:09 <yyttr3> Learn you a haskell is a good book. Free too!
23:37:18 <Haskellfant> @where lyuah
23:37:18 <lambdabot> I know nothing about lyuah.
23:37:21 <merijn> chintanparikh: There's Learn You a Haskell, available for free online. I've heard good things about Bird's book
23:37:21 <MP2E> yeah learn you a haskell is good
23:37:28 <MP2E> @where lyah
23:37:28 <lambdabot> http://www.learnyouahaskell.com/
23:37:31 <Haskellfant> ah :)
23:38:05 <chintanparikh> Thanks people! Reading it now. Is this channel usually okay with beginner questions?
23:38:26 <yyttr3> They've been really helpful to me, and i've just started learning haskell.
23:38:28 <jle`> chintanparikh: yeah :D
23:38:35 <merijn> chintanparikh: Real World Haskell is more "practically-minded", but 1) it glosses over some details that LYAH covers better 2) it's rather old, so a lot of the libraries discussed have evolved and the code snippets won't compile as-is. That being said, most of the libraries discussed still follow the same design as covered in the book, so figuring them out from the docs should be easy after reading RWh
23:38:40 <jle`> there's also #haskell-beginners , too :)
23:39:19 <shachaf> Yes. Especially if you mean "beginner to Haskell", and not "beginner to asking questions". But either one works, really.
23:42:45 <bmuk> shachaf: you mentioned earlier that I should learn how IO works before tackling this particular use case (I was actually able to get it working, though). I am very interested in how IO works - could you point me to some resources
23:43:50 <shachaf> Hmm, that depends on how much Haskell you know.
23:45:40 <bmuk> I feel I have an intermediate knowledge of Haskell. Knowledge of the major typeclasses, I know what monads are. I try to understand category theory, but I have to battle my intuition :) I'm sure you remember our discussion about arrows
23:46:02 <shachaf> Category theory is not necessary and probably barely useful.
23:46:35 <bmuk> okay. I find it interesting regardless
23:46:57 <shachaf> Oh, sure, it's interesting, but not for figuring out how I/O works.
23:47:23 <shachaf> But you said you know what monads are. IO (and X, in your case) is a monad. That should almost give you enough information to solve your problem.
23:48:18 <bmuk> yes, and I was able to solve it - X is an instance of MonadIO, and provides a function io which is IO a -> X a
23:49:00 <shachaf> Oh, that was the issue you were running into, and why you wanted unsafePerformIO. OK.
23:49:10 <shachaf> Then maybe you already know everything I have to say.
23:49:24 <bmuk> I'm still interested in how IO actually works. I understand Maybe, Either, Reader, Writer, State, etc.
23:49:46 <cnphil> Well, I found Real World Haskell's introduction to monads and functors much more intuitive than LYAH's. When I finished LYAH, I felt like I know what a monad is, but I don't know how to do anything with it. RWH actually makes you build 3 monads before telling you they are called monads.
23:50:28 <jle`> bmuk: i wrote this blog.jle.im/entry/first-class-statements , which may or may not be helpful :)
23:50:31 <chintanparikh> I'm on http://learnyouahaskell.com/starting-out at Baby's first functions - for some reason ghci is giving me "unknown command ':1'"
23:50:34 <chintanparikh> Any ideas?
23:50:44 <merijn> bmuk: There are two separate issues here
23:51:05 <arbn> chintanparikh: :l
23:51:06 <merijn> bmuk: One is "what does the IO mean, conceptually" and two "how is it actually implemented"
23:51:08 <shachaf> bmuk: Oh, well, it's abstract. Doesn't matter how it works.
23:51:18 <arbn> chintanparikh: Not :1
23:51:26 <chintanparikh> arbn: Hah, of course. Thanks!
23:52:04 <merijn> bmuk: For writing code, 1 is far more helpful than 2 :)
23:52:21 <shachaf> merijn: Unfortunately it's kind of meaningless.
23:52:53 <merijn> shachaf: Is this going to be the "is IO really a monad because of concurrency"-issue or another one I don't know yet?
23:53:08 <bmuk> merijn: I understand (FSVO understanding) 1 - I have heard the /bin/ls analogy before, and I understand what that means, but not much else. 2 I have no clue.
23:53:29 <shachaf> merijn: Well, what does IO mean?
23:53:53 <shachaf> bmuk: You shouldn't care how IO is implemented unless you're reading generated code or implementing GHC or low-level code or something.
23:54:26 <merijn> shachaf: I was referring to the whole "program fragments" conceptualisation of IO
23:54:40 <bmuk> shachaf: I get that it isn't necessarily relevant, but that doesn't mean it isn't interesting
23:54:43 <slomo> is there something to convert an Errno into a String without involving exceptions?
23:54:56 <merijn> shachaf: If we're talking (denotational) semantics when I say "mean", then I'm going to preemptively give up :)
23:56:00 <shachaf> merijn: OK, then sure.
23:57:00 <merijn> bmuk: Ok, if we're talking "interesting things" then the ST monad might be more interesting to learn
23:57:17 <merijn> bmuk: See this paper for an introduction: https://research.microsoft.com/apps/pubs/default.aspx?id=67053
23:57:18 <shachaf> ST? Really?
23:57:36 <shachaf> That seems way too complicated to me.
23:58:13 <merijn> bmuk: Although, the problem is that that doesn't really fit the idea of IO very well, as IO brings problems like "what is the semantics of concurrent operations", where it's much easier to ignore the implementation and only talk semantics
23:58:36 <merijn> shachaf: Is ST that difficult? I found it rather easy, but I realise my perception may be skewed
23:59:14 <bmuk> shachaf: I have faith in my ability to work through material I don't understand
23:59:34 <merijn> bmuk: If you get confused by that, just bail out and ignore it until later. It's not really important for writing practical code
