00:00:05 <merijn> yyttr3: That sounds like a recipe for race conditions
00:00:19 <merijn> yyttr3: If you want to read to a file you already have open, use the Handle you have
00:01:24 * hackagebot yesod-core 1.2.20.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.20.1 (MichaelSnoyman)
00:03:24 <yyttr3> I see, thank you. It works now xD dumb problem I suppose.
00:05:52 <adas> SSD helps as well
00:07:50 * hackagebot reactive-haskell 0.0.1 - minimal fork of io-reactive  http://hackage.haskell.org/package/reactive-haskell-0.0.1 (Heather)
00:07:50 * hackagebot yesod-core 1.2.20.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.20.1 (MichaelSnoyman)
00:08:11 <Fuuzetsu> adas: an alternative way is to use a package manager with binary caches which does Haskell + docs
00:08:14 <Fuuzetsu> (like nix)
00:09:23 <dgg_> I am a total newbie in Haskell where do I start…
00:10:02 <MP2E> @where lyah
00:10:02 <lambdabot> http://www.learnyouahaskell.com/
00:10:11 <MP2E> that link is a pretty good start
00:10:54 <ekuam> > 2 + 2
00:10:57 <lambdabot>  4
00:11:18 <ekuam> > "hello," ++ " world"
00:11:20 <lambdabot>  "hello, world"
00:11:32 <Lutin`> Tried to implement some stuff from Permutation Group Algorithms by Seress in Python because my two classmates only know Python. But it just doesn't feel right.
00:12:02 <Fuuzetsu> yeah, having classmates who only know Python wouldn't feel right in any situation
00:12:05 <Lutin`> Abstract math doesn't feel right in a dynamically typed language
00:12:05 <Fuuzetsu> only one way to fix it
00:12:06 <MP2E> hahah
00:12:07 <Lutin`> haha
00:12:14 <Lutin`> *zing*
00:12:52 <Axman6> find new friends!
00:12:54 <Axman6> >_>
00:13:02 <Haskellfant> or teach them haskell
00:13:13 <Lutin`> That's my plan
00:14:26 <tdammers> or use Haskell to build yourself some new friends
00:15:04 <Lutin`> Well it's an independent study where there's only 3 of us in the class
00:15:33 <Axman6> lpsmith: does postgres-simple support much in the way of PostGIS functionality?
00:15:35 <ekuam> friendomorphism
00:20:54 <spacekitteh> is there an equivalent of Applicative for Comonads?
00:21:08 <jle`> spacekitteh: i think you'll find one in comonads
00:21:23 <jle`> er, comonad
00:21:29 <jle`> oh
00:21:31 <jle`> it's not there
00:21:33 <jle`> where did it go?
00:22:54 * spacekitteh shrugs
00:24:07 <pjdelport> spacekitteh: Applicative without pure actually works for Comonads.
00:24:34 <spacekitteh> what is the equivalent of pure?
00:25:09 <spacekitteh> oh an algebra
00:26:05 <pjdelport> spacekitteh: http://hackage.haskell.org/package/semigroupoids-4.2/docs/Data-Functor-Apply.html#t:Apply
00:27:01 <pjdelport> spacekitteh: Maps are a good example of things that are applicative functors in the Apply sense, but that don't have an equivalent of pure
00:27:30 <spacekitteh> huh ok cool
00:28:29 <spacekitteh> wtf why does edward put his own functor class in there
00:28:30 <pjdelport> spacekitteh: And just like Functor, you can think of that Apply as being common ground between both monads and comonads (and the full Applicative and Coapplicative, with pure and extract respectively)
00:28:38 <pjdelport> spacekitteh: That's probably just re-exported.
00:28:50 <spacekitteh> ah right
00:30:34 <sivteck> ls
00:32:31 <Lutin`> I wonder if I could get them to learn Coq..
00:32:58 <Fuuzetsu> Agda is what you want them to learn
00:33:10 <spacekitteh> learn coq! :D
00:38:30 <Lutin`> btw if anyone is interested in Permutation Group Algorithms by Seress, send me a /msg
00:43:49 <spacekitteh> is there a way to specify the prelude used? at the command line so one doesn't have to do a language pragma + explicit import?
00:43:57 <merijn> Fuuzetsu: I don't really agree, it depends on what you wanna do
00:44:13 <merijn> spacekitteh: Nope, what's wrong with a language pragma?
00:44:27 <spacekitteh> merijn: makes it feel second class
00:44:41 <merijn> That's because it is...
00:44:48 <spacekitteh> it shouldn't be \o/
00:47:48 * hackagebot idris 0.9.14.3 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.14.3 (CarterSchonwald)
01:15:03 <sinelaw> In HM/"algo W" type inference, variables represent "type schemes" so that polymorphism allows them to be used in different contexts
01:15:39 <sinelaw> how does the algorithm limit function arguments' types?
01:15:49 <sinelaw> e.g. in \x -> x x
01:16:40 <sinelaw> in the abstraction, the algorithm assigns to argument "x" a type scheme: "x" -> (forall a. a)
01:16:55 <sinelaw> what's the next step?
01:17:05 <sinelaw> (when encountering the first x expression)
01:21:29 <vanila> sinelaw, when trying to infer the types it has to perform unification
01:21:46 <sinelaw> vanila, between all occurances of the variable?
01:22:55 <vanila> sinelaw, so assuming x :: p -> q, then to infer the type of x x we have to unify p = p -> q
01:23:40 <vanila> the occurs check will say this can't be unified
01:24:23 <vanila> that was applying the type rule:   f :: p -> q,  x :: a,   p = a  |-  f x :: q
01:24:24 <sinelaw> vanila, right, but when is this done? on every occurrence of a an "x" expression?
01:24:34 <sinelaw> in the inference algorithm
01:25:02 <vanila> sinelaw, so  \x -> x x  is a lambda node containing an application node that contains two variable nodes
01:25:40 <vanila> inference apply each type rule and recursively analyse the subnodes
01:26:27 <vanila> so it infers that \x -> x x has type a -> b for some variables a,  and then checks that with the assumption x :: a,  x x has type b
01:26:46 <vanila> then it applies the rule for function application and unification fails so it determined that the expression can't be typed
01:27:38 <sinelaw> how are type schemes used then?
01:27:49 <sinelaw> without type schemes  I can see how it works.
01:28:33 <sinelaw> e.g. in \x -> (x 1, x True)
01:28:50 <vanila> :t \x -> (x 1, x True)
01:28:51 <lambdabot>     No instance for (Num Bool) arising from the literal ‘1’
01:28:51 <lambdabot>     In the first argument of ‘x’, namely ‘1’
01:28:51 <lambdabot>     In the expression: x 1
01:29:57 <sinelaw> a valid type is :: a -> a -> (Int, Bool)
01:30:08 <sinelaw> (a -> a)
01:30:09 <vanila> that's not a valid type
01:30:16 <vanila> (forall a. a -> a) -> (Int, Bool)  could work
01:30:20 <vanila> but this wouldn't be inferred
01:30:24 <sinelaw> yes, that's what I meant.
01:31:09 <sinelaw> so I can't see what type schemes are used for during inference
01:31:29 <sinelaw> another example: f x = x;  y = (f 1, f True)
01:31:51 <sinelaw> f gets a type scheme: forall a. a -> a
01:31:52 <vanila> sinelaw, so when you run type inference on f it will infer that it has type a -> a for some logic variable a
01:32:13 <vanila> sinelaw, on completing that it generalizes all the free vars giving the type  forall a. a -> a
01:32:51 <vanila> then you infer the type of y, and this involves checking the applications f 1 and f True - both of which work this time because of the forall a., they get tried with fresh type variables
01:33:14 <vanila> as opposed to in the previous example where the type variables for x were shared across x 1 and x True
01:34:31 <sinelaw> ok, so how do we decide whether or not the type variable is shared?
01:35:51 <vanila> sinelaw, well in the first example type inference will analyse (x 1, x True) in the context x :: a  (where a is some type variable)
01:36:09 <vanila> in the second case, it will analyse (f 1, f True) in the context f :: forall a. a -> a
01:36:42 <vanila> so once it checks x 1 :: b, this will have unified a = Int -> b,  and proceed to check x True in the context  x :: Int -> b, which fails
01:37:40 <jumblesale_> Hey, I'm really new to this and I'm trying to figure out a function which allows you to define what arithmetic function you want to apply during a fold and I cna't figure out where I'm going wrong. This is what I've got so far:
01:37:42 <vanila> in the second case, f 1 will be checked by instantiating the type of f with a = Int, and then f True will be checked in the same context f :: forall a. a -> a
01:37:47 <jumblesale_> arithmetic :: (Num a) => (a -> a) -> [a] -> a
01:37:48 <jumblesale_> arithmetic f stack = foldl (\acc x -> f acc x) 0 stack
01:38:06 <vanila> jumblesale_, delete the type signature and let haskell infer it for you
01:38:20 <trap_exit> https://gist.github.com/anonymous/e4d6c9141e3c9685a0e9
01:38:24 <trap_exit> https://gist.github.com/anonymous/e4d6c9141e3c9685a0e9 wtf wt fwtf
01:38:26 <vanila> jumblesale_, the code is correct but (a -> a) is a unary function, when you needed a -> a -> a, a binary one (since you do f acc x)
01:38:34 <jumblesale_> Ahhhhh
01:38:37 <jumblesale_> Thanks!
01:38:49 <sinelaw> vanila, top of page 5 here: http://www.grabmueller.de/martin/www/pub/AlgorithmW.pdf
01:39:15 <sinelaw> bottom of 4 / top of 5
01:40:02 <sinelaw> when encountering a variable expression, it always does the same thing: lookup a type scheme in the environment and instantiate a new type variable
01:43:53 <sinelaw> so in \x -> x x, the two x's will get separate type variables, and occurs check will miss it
01:45:03 <vanila> sinelaw, if the code is hard to understand or confusing it migth be better to implement it from scratch yourself
01:45:07 <yitz> trap_exit: your package db got corrupted somehow
01:45:20 <sinelaw> vanila, I did and it worked except for generalization
01:45:27 <sinelaw> so \x -> x x actually did fail
01:45:37 <vanila> but the other example didn't work?
01:45:38 <sinelaw> (i didn't use type schemes at all)
01:45:48 <trap_exit> yitz: what files should I kill to solve this problem ?
01:46:03 <sinelaw> the only thing that didn't work was: let f x = x; y = (f 1, f True)
01:46:12 <sinelaw> there was no "forall"
01:46:14 <sinelaw> so it fialed.
01:46:27 <yitz> trap_exit: fastest is usually just uninstall hp and reinstall
01:46:32 <sinelaw> I'm trying to add generalization
01:46:47 <vanila> sinelaw, it sounds like you have done it all correct so far and just need to implement let generalization - that's good
01:46:51 <trap_exit> I killed ~/.cabal, ~/.ghc, and ~/Library/Haskell
01:46:54 <trap_exit> but it's not sufficient
01:47:00 <vanila> sinelaw, does your syntax for types include a forall quantifier?
01:47:20 <sinelaw> no, because I follow SPJ and this paper which both use a concept of type schemes
01:47:35 <sinelaw> type schemes are not types
01:47:35 <Enigmagic> trap_exit: run `ghc-pkg list text`
01:47:43 <yitz> trap_exit: run the uninstaller in /Library/Haskell/current/bin
01:47:55 <vanila> ok
01:47:59 <trap_exit> eh,
01:48:01 <trap_exit> fuck cabal
01:48:01 <sinelaw> they are the generalized signature, e.g. "forall a. a" is a type scheme, "a" is a type
01:48:03 <trap_exit> I'm going to go use nix
01:48:14 <trap_exit> yitz Enigmagic: thanks for attempt to help though
01:48:14 <yitz> trap_exit: that will get delete the whole thing. then just reinstall from the dmg.
01:48:28 <yitz> trap_exit: heh good luck
01:48:30 <vanila> I guess that could simplify things a little since you aren't going to implement checking involving higher rank types
01:49:19 <vanila> sinelaw, and does type scheme hold a list of which variables are/are not quantified?
01:49:23 <vanila> as well as the type itself
01:49:40 <yitz> trap_exit: i do everything in a cabal sandbox, always. avoids all those problems. but yeah, when nix becomes more mature, i may well move to that.
01:49:58 <yitz> trap_exit: some people use docker. sounds like overkill to me.
01:50:14 <sinelaw> the type environemnt is a map: variable name -> type scheme, and the type scheme is a pair ([type variable names] , type with some names in it)
01:50:22 <trap_exit> yitz: well, nix just finished installing x in virtualbox
01:50:26 <trap_exit> so I'm bout ot give it a spin
01:50:34 <vanila> sinelaw, okay so lets look at an example
01:50:44 <yitz> trap_exit: cool! you mean nixos, not just nix?
01:50:55 <sinelaw> example: x
01:50:55 <trap_exit> right, nixos
01:50:57 <vanila> sinelaw, if g has type scheme forall b. b -> a (represented by ([b],b -> a) I guess)   then (f,f)
01:51:26 <trap_exit> yitz: we seem to have similar interest; what do you do?
01:51:28 <sinelaw> f or g?
01:51:29 <yitz> trap_exit: wow, the whole thing. sounds great. i really want to try that when i have time one of these days.
01:51:41 <yitz> trap_exit: i program in haskell for a living.
01:51:55 <trap_exit> yitz: do you live @ the end of a rainbow ?
01:51:58 <vanila> sinelaw, *in (g,g) 'a' will be shared across but each time you infer the type of g you will create a rfesh logic variable in place of b, e.g.  (g :: b1 -> a, g :: b2 -> a)
01:51:59 <trap_exit> which company?
01:52:00 <ginmaniac> Hey let's say I have a function `add :: Num a => a -> a -> a` why I is it that `:t add 3 :: Num a => a -> a`, but `let x = add 3 :: Integer -> Integer`? Isn't Integer in the second case still an instance of Num?
01:52:12 <yitz> trap_exit: http://suite-sol.com
01:52:22 <sinelaw> vanila, right.
01:52:51 <vanila> I hope that helps !
01:53:03 <vanila> is anything unclear?
01:53:23 <yitz> ginmaniac: DMR
01:53:25 <trap_exit> yitz: so you guys build a todo lsit for the enterprise ?
01:53:38 <yitz> ginmaniac: == "The Dreaded Monomorphism Restriction"
01:53:42 <sinelaw> vanila, yes but I'll be back later. :) thanks a lot!
01:53:48 <ginmaniac> yitz: thanks, I look that up.
01:53:48 <sinelaw> we're getting there.
01:54:50 <vanila> sinelaw, I prefer to put foralls into the type syntax because it allows you to check types involving higher rank but I can see the benfit of this approach too
01:54:59 <yitz> trap_exit: automation for managing and publishing large sets of documents. mostly technical documentation.
01:55:12 <sinelaw> that actually sounds simpler
01:55:31 <yitz> trap_exit: now we have a great knowlege base product though, integrated with DITA publication.
01:56:27 <yitz> trap_exit: and a DITA-to-online-help engine. both of those in haskell. based on our haskell DITA engine.
01:56:42 <trap_exit> yitz: what is DITA ?
01:57:07 <yitz> trap_exit: kind of like "docbook for the enterprise". an XML publishing format.
02:00:17 <yitz> @google the dreaded monomorphism restriction
02:00:18 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
02:00:19 <lambdabot> Title: Monomorphism restriction - HaskellWiki
02:07:55 * hackagebot websockets 0.9.0.1 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.9.0.1 (JasperVanDerJeugt)
02:17:03 <yitz> @where+ tdmr http://www.haskell.org/haskellwiki/Monomorphism_restriction
02:17:03 <lambdabot> Done.
02:21:47 <AshyIsMe> does lambdabot not have Data.Text in scope?
02:23:24 <yitz> > T.pack "hello"
02:23:25 <lambdabot>  Not in scope: ‘T.pack’
02:23:26 <lambdabot>  Perhaps you meant ‘BS.pack’ (imported from Data.ByteString)
02:23:42 <yitz> > Text.pack "hello"
02:23:43 <lambdabot>  Not in scope: ‘Text.pack’
02:23:48 <yitz> > Data.Text.pack "hello"
02:23:49 <lambdabot>  Not in scope: ‘Data.Text.pack’
02:24:00 <yitz> AshyIsMe: hmm. maybe not.
02:26:56 <AshyIsMe> http://lpaste.net/111469
02:27:03 <AshyIsMe> that's what i was hoping to do
02:27:22 <AshyIsMe> works in ghci but i was hoping to show those fsharp weenies a thing or two
02:27:39 <AshyIsMe> (that haskell is more verbose and not as convenient in this case :/ )
02:32:29 <ekuam> perl -CS -E 'use utf8; say $_%2==0 ? "⬛ ▤ ⬛ ▤ ⬛ ▤ ⬛ ▤" : "▤ ⬛ ▤ ⬛" . ($_==5 ? " ♙ ⬛ ▤ ⬛" : " ▤ ⬛ ▤ ⬛") for 1..8'
02:33:44 <ekuam>  > text . join $ [if n `mod` 2 == 0 then "\n⬛ ▤ ⬛ ▤ ⬛ ▤ ⬛ ▤" else "\n▤ ⬛ ▤ ⬛" ++ if n == 5 then " ♙ ⬛ ▤ ⬛" else " ▤ ⬛ ▤ ⬛" | n <- [1..8]]
02:33:47 <ekuam> > text . join $ [if n `mod` 2 == 0 then "\n⬛ ▤ ⬛ ▤ ⬛ ▤ ⬛ ▤" else "\n▤ ⬛ ▤ ⬛" ++ if n == 5 then " ♙ ⬛ ▤ ⬛" else " ▤ ⬛ ▤ ⬛" | n <- [1..8]]
02:33:49 <lambdabot>  ▤ ⬛ ▤ ⬛ ▤ ⬛ ▤ ⬛
02:33:49 <lambdabot>  ⬛ ▤ ⬛ ▤ ⬛ ▤ ⬛ ▤
02:33:50 <lambdabot>  ▤ ⬛ ▤ ⬛ ▤ ⬛ ▤ ⬛
02:33:50 <lambdabot>  ⬛ ▤ ⬛ ▤ ⬛ ▤ ⬛ ▤
02:33:50 <lambdabot>  ▤ ⬛ ▤ ⬛ ♙ ⬛ ▤ ⬛
02:35:01 <vanila> ekuam, amazing :)
02:35:19 <doismellburning> ekuam: is that unicode chess chars? (this font sucks :()
02:35:30 <AshyIsMe> > text "testing"
02:35:32 <lambdabot>  testing
02:35:46 <AshyIsMe> is this public? https://www.fpcomplete.com/project/63997/1mh9SkD791
02:36:00 <ekuam> doismellburning: https://dl.dropboxusercontent.com/u/41152078/unicode.html?q=%E2%99%99%E2%AC%9B%E2%96%A4
02:36:33 <ekuam> AshyIsMe: looks like it
02:37:20 <doismellburning> ekuam: oh my font was ok, it just did the shading oddly, thanks!
02:39:06 <AshyIsMe> feel free to make me look foolish with a shorter version: https://twitter.com/AaronAsh2/status/514347753959215104
03:05:33 <mroman_> So... System.Random uses a different algorithm on different plattforms/different versions?
03:29:59 <r444> AshyIsMe: yeah
03:44:37 <kazagistar> im running into a silly pattern with attoparsec... in my do, I alternate lines with "a <- takeTill <X>; takeWhile <X>; b <- takeTill <Y>; takeWhile <Y>; etc..." should I just build a custom combinator for this, or am I just missing something obvious?
03:45:58 <kazagistar> for context, I am just trying out this toy problem http://www.reddit.com/r/dailyprogrammer/comments/2h5b2k/09222014_challenge_181_easy_basic_equations/
03:53:03 * hackagebot coordinate 0.0.10 - A representation of latitude and longitude  http://hackage.haskell.org/package/coordinate-0.0.10 (TonyMorris)
04:04:45 <peddie> :t (<*)
04:04:47 <lambdabot> Applicative f => f a -> f b -> f a
04:04:52 <peddie> kazagistar: ^
04:07:47 <kazagistar> wait, are we talking about the (->)  instance of applicative?
04:08:03 <peddie> what?
04:08:12 <peddie> I thought we were talking about attoparsec
04:08:22 <peddie> OH I apologize, I didn't see the <X> <X> repetition
04:08:26 <kazagistar> I repeat X and Y in that example above, yeah
04:08:39 <peddie> sorry friend, I don't have any suggestions
04:08:57 <kazagistar> all good, I think I found a better solution for this instance at least :P
04:09:02 <peddie> what was it?
04:09:37 <kazagistar> using nicer, more context applicable preexisting combinators and never touching takewhile or taketill
04:09:46 <peddie> fair enough :)
04:10:09 <kazagistar> string, signed, and endOfLine
04:10:52 <kazagistar> instead of some horrible "a <- fmap read (takeTill (/= 'x'))"
04:11:06 <kazagistar> "a <- signed" muuuuuch nicer
04:12:09 <kazagistar> ill post it as soon as I figure out the perfect place to put my one and only type annotation :P
04:19:50 <kazagistar> oh my, there is a "double" in attoparsec, I guess I dont even need any type annotations
04:22:32 <ClaudiusMaximus> what's the current state of gui in ghci?  i want to display an image and use the repl to manipulate it, and also bind actions to mouse events in the image window from the repl
04:26:01 <marvimias> I submitted this issue: https://github.com/gwern/mueval/issues/3
04:26:05 <marvimias> Anyone know a fix?
04:28:17 <jrc12> i had a question with regard to the IO monad
04:28:45 <marvimias> Anyone?
04:28:53 <jrc12> if i do getString :: (String -> Bool) -> IO String getString f = do   s <- getLine   if f s then return [] else fmap (s ++) $ getString f
04:29:03 <jrc12> ok thats badly formatted
04:29:15 <jrc12> getString f = do
04:29:21 <jrc12> s <- getline
04:29:39 <jrc12> if f s then rest urn [] else fmap (s ++) $ getString f
04:30:44 <jrc12> ok this is better - http://pastebin.com/JvanxmPC
04:31:31 <jrc12> running it with getString null
04:31:39 <jrc12> doubles the output
04:32:11 <jrc12> however on inserting a print in the middle the output is proper
04:34:01 <jrc12> anybody?
04:34:34 <kazagistar> um, I am not sure I get you...
04:34:42 <kazagistar> "however on inserting a print in the middle the output is proper"
04:34:44 <hexagoxel> can you post the output you got and what you expected/want
04:34:56 <kazagistar> I think it is a lazyness confusion?
04:35:02 <hexagoxel> you have not asked a clear question yet..
04:35:19 <jrc12> yep, will do
04:35:22 <jrc12> just a sex
04:35:24 <jrc12> sec*
04:36:13 <int-e> marvimias: you can remove Control.Monad.Instances from the default import list in Mueval/Context.hs
04:36:21 <adas> can someone please help me with this? http://www.reddit.com/r/haskell/comments/2h7qji/haskell_documentation_woes/
04:36:28 <kazagistar> jrc12: are you trying to write "read terminate command is entered"?
04:37:25 <zq> what is up with nearly every package on hackage missing docu links?
04:37:40 <jrc12> this includes both versions and the respective output
04:37:40 <jrc12> http://pastebin.com/FPwbEKvn
04:37:50 <adas> zq: tell me about it.. burning my hair since the day before
04:40:37 <jrc12> is the question clear?
04:41:04 <adas> i tried dash-haskell.. but its not working for some reason. either that or I don't know how to use it properlly
04:41:37 <hexagoxel> jrc12: yes, mom
04:42:47 <kazagistar> jrc12: huh, I get different output on the first example... it works for me
04:42:54 <hexagoxel> same
04:43:18 <hexagoxel> (at least in ghci..)
04:43:24 <kazagistar> yeah, same
04:43:52 <kazagistar> @let getString f = do { s <- getLine; if f s then return [] else fmap (s ++) $ getString f }
04:43:56 <lambdabot>  Defined.
04:44:11 <kazagistar> wait, lambdabot does not do IO, wtf
04:44:32 <triliyn> > getString
04:44:34 <lambdabot>  <([Char] -> Bool) -> IO [Char]>
04:44:43 <kazagistar> > getString null
04:44:45 <lambdabot>  <IO [Char]>
04:44:50 <kazagistar> oh, I see
04:45:11 <kazagistar> it does IO just fine, it just does not evaluate it :P
04:45:13 <jrc12> wait.. i was trying that from ghci running within emacs
04:45:40 <kazagistar> @undefine
04:45:40 <lambdabot> Undefined.
04:45:41 <jrc12> Trying it in the shell straight produces appropriate output
04:45:49 <jrc12> sorry^
04:46:22 <kazagistar> no probs, helps me take my mind off attoparsec not having a useful error :(
04:46:47 <hexagoxel> large git rebase here :D
04:56:45 <adas> any app for browsing documentation from command line?
04:57:06 <adas> documentation that is installed locally
05:00:57 <jroberts> Ohla
05:01:53 <hexagoxel> adas: hoogle
05:02:05 <jroberts> Is there a language extension or something which allows different patterns of the same function to be in different files?
05:04:17 <Haskellfant> adas: maybe this is what you're looking for https://github.com/chrisdone/haskell-docs
05:06:04 <adas> Haskellfant: i just installed it and checked it out.. no offense to the author but i dont think it is ready yet
05:06:23 <adas> or im jumping to conclusions too soon
05:06:24 <Haskellfant> haven't tried it myself so i can't comment on it
05:06:52 <adas> Haskellfant: i can't seem to list everything exposed by a module..
05:07:28 <adas> and the only way to search is something like "haskell-docs head" or "haskell-docs Data.List head"
05:07:36 <Haskellfant> well create issues :)
05:07:41 <adas> : )
05:10:08 <adas> done
05:11:09 <adas> hexagoxel: hoogle is useless unfortunately .. it cant seem to generate databases from the installed documentation..
05:11:36 <adas> it needs the source files to generate the .hoo db files
05:11:53 <adas> and i don't wanna do "hoogle data all" .
05:12:01 <adas> hope im correct
05:12:13 <hexagoxel> adas: yeah i interpreted your question differently
05:13:07 <adas> wish it was as simple as "pydoc -p 20000 127.0.0.1"
05:29:30 <TheMoonMaster> Anyone know how I'd shell out some input from a haskell program to less to page the content?
05:32:09 <jroberts> In theory ghci ... | less
05:32:13 <doismellburning> TheMoonMaster: more detail please? what do you mean "some input to less"?
05:32:52 <doismellburning> TheMoonMaster: do you mean "I do some printing in the middle of my app and want paging functionality and think less can help"?
05:34:56 <yitz> TheMoonMaster: see the process library.
05:37:12 <yitz> TheMoonMaster: you would have to figure out how to pass your data to less *and* pass stdin through to less. it's possible, but might not be worth the trouble.
05:38:01 <simon> what's a safer alternative to read/readIO using String? I only know Data.Readable (Text, ByteString).
05:38:57 <yitz> @type  Text.Read.readMaybe
05:38:58 <lambdabot> Read a => String -> Maybe a
05:39:53 <simon> thanks! I was looking at Network.CGI.Protocol.maybeRead. :)
05:40:21 <yitz> simon: that's safer, still using String. See also Data.Text.Read and Data.Text.Lazy.Read
05:41:25 <yitz> simon: those are only for numeric types though.
05:41:36 <adas> finally solved it
05:42:07 <adas> if anyone is curious .. all i did was "ssh -X me@dockercontainer"
05:42:11 <adas> and then ran firefox
05:43:00 <adas> now i can browse the docs properly from the host using firefox running on the container which is using the xserver on the host
05:43:11 * hackagebot satchmo 2.8.1 - SAT encoding monad  http://hackage.haskell.org/package/satchmo-2.8.1 (JohannesWaldmann)
05:43:12 <yitz> adas: haha right. i was going to say lynx.
05:49:00 <TheMoonMaster> jroberts: I mean FROM a haskell program
05:49:02 <TheMoonMaster> Not pass it to it from the CLI
05:51:27 <adas> firefox? lynx? not the same
05:51:31 <geekosaur> createProcess (proc "less" []) {std_in = CreatePipe}
05:52:04 <niklas123> hi, does anyone know a good tutorial for type interference trees ?
05:52:20 <vanila> niklas123, What is that?
05:52:33 * geekosaur wonders if interference is a typo for inference
05:52:40 <geekosaur> (or possibly an autoincorrect)
05:54:37 <niklas123> inference ^^
05:54:54 <vanila> I stil don't know what it is
05:57:53 <niklas123> it's for deducting the data type of an expression, in this case haskell functions
06:12:28 <latk> I've just started to read about frp. I would presume that it is not really applicable to multiplayer games ?
06:18:18 <Laquendi> if you ask 10 frp advocates you will get at least 11 different answers
06:18:22 <geekosaur> I would expect it to be applicable but one of your event sources is going to be status reports from the other players
06:18:45 <geekosaur> that said I coul d not give you an answer in detail; how you plumb it is going to differ between FRP implementations
06:27:07 <latk> Hmm, okay. I guess I need to read a bit more - I don't currently see how it can scale to a semi complicated system
06:28:15 * hackagebot htsn 0.1.1 - Parse XML files from The Sports Network feed.  http://hackage.haskell.org/package/htsn-0.1.1 (MichaelOrlitzky)
06:34:57 <raveline> Hello, a comment on a recent paper on lwn.net says that "let bar = foo in print (length bar + length bar)"  "might leak memory". I'm not sure I understand why, could someone give me pointers ?
06:35:40 <ekuam> it's a potential space leak, yes
06:35:44 <ekuam> not a memory leak
06:36:17 <ekuam> consider foo = [1 .. 10000]
06:36:20 <raveline> OK
06:36:40 <ekuam> if you do length [1 .. 10000], length will consume the list while it's being generated
06:36:50 <ekuam> i.e. the whole list will never exist in memory
06:36:57 <raveline> yep
06:37:14 <ekuam> but with length bar + length bar you have two references to the same list
06:37:42 <ekuam> so the first length will traverse the list, forcing it to be created, but it can't be freed yet because the second bar still has a reference to it
06:37:47 <raveline> So it will stay in memory ?
06:37:58 <ekuam> yes, until the second length starts running
06:38:09 <Haskellfant> raveline: out of interest, could you link the paper?
06:38:10 <raveline> Ah yes, but once the second length start running, it iwll be freed.
06:38:31 <Haskellfant> raveline: yeah, but to compute the length you never need to have the complete list in memory
06:38:44 <raveline> Haskellfant : Of course, but you'll need a subscription to access it directly through the url. It's there : http://lwn.net/Articles/612042/
06:38:52 <Haskellfant> i have one
06:38:56 <Haskellfant> thx
06:39:00 <raveline> Haskellfant : You're welcome.
06:39:47 <raveline> ekuam and Haskellfant, if I understand correctly, the issue is that we'll store in memory more than what was necessary
06:39:55 <Haskellfant> exactly
06:40:10 <raveline> ekuam and Haskellfant, however, it is not a leak in the traditional meaning, because when this expression will be completely evaluated, memory will be properly freed
06:40:17 <Haskellfant> yep
06:40:41 <ekuam> right
06:40:45 <raveline> OK ! Thank you very much !
06:41:01 <bennofs> Note that GHC might do common subexpression elemination (CSE) and replace it with let bar = foo; l = length bar in print (l + l), which will not have this spaceleak I think
06:41:07 <geekosaur> also, while specific cases of it could in theory be recognized and handled by the compiler, the general case is intractible
06:41:18 <ekuam> http://www.haskell.org/haskellwiki/Space_leak#Holding_a_reference_for_a_too_long_time
06:41:30 <bennofs> But CSE is not always done in GHC, so I'm not sure if it will actually trigger in this case
06:41:45 <raveline> I see.
06:42:28 <geekosaur> CSE isn't always done because, while sometimes (as here) it would be a win, sometimes it *creates* these instead of fixing them
06:42:56 <yitz> in fact cse is almost never done, for that reason.
06:43:15 <yitz> it's very hard to determine in general when it would be a win
06:43:40 <raveline> well compiler optimisation is supposed to be rather tricky, isn't it !
06:44:43 <yitz> raveline: in some ways it's much easier in haskell, due to nice properties like referential transparency. but here, it's still hard. :)
06:44:58 <raveline> Anyway thanks again to everyone for their help !
06:47:11 <Mr_Pony> mooo
06:51:45 <yitz> very interesting. the misleading and somewhat confused post raveline was referring to was by droundy, the original author of darcs.
06:53:17 * hackagebot git-monitor 3.1.1.2 - Passively snapshots working tree changes efficiently.  http://hackage.haskell.org/package/git-monitor-3.1.1.2 (JohnWiegley)
06:53:19 * hackagebot git-gpush 3.1.0.1 - More intelligent push-to-GitHub utility.  http://hackage.haskell.org/package/git-gpush-3.1.0.1 (JohnWiegley)
06:54:23 <sgronblo> how do i get cabal to show me the versions of installed packages?
06:55:53 <johnw> sgronblo: ghc-pkg list
07:00:33 <sgronblo> does this take sandboxes into account?
07:00:54 <bergmark> no, use cabal sandbox hc-pkg list
07:02:24 <sgronblo> ah this worked, thanks
07:10:18 <albeit> Hey all, I have an infuriating problem with sockets that I can't seem to solve... a thread is unable to receive the last few multicast messages sent by a sibling thread, unless I delay a little bit after each send. (Other programs receive all the messages fine). I would hugely appreciate if someone could take a look... http://lpaste.net/111476
07:12:02 <srenatus> > 2+2
07:12:04 <lambdabot>  4
07:12:14 <bennofs> albeit: is BS strict or lazy ByteString?
07:12:41 <albeit> bennofs: BS is strict, LBS is lazy
07:13:25 <albeit> bennofs: Just changed everything to strict bytestrings, and no dice
07:14:12 <opqdonut> albeit: TCP?
07:14:18 <albeit> Even other Haskell programs, with the same code, but in a different process, are able to receive everything successfully. It just when they share a process, or sibling thread, or something...
07:14:28 <albeit> opqdonut: UDP Multicast, datagrams
07:14:29 <opqdonut> ah, UDP obviously
07:15:13 <bennofs> albeit: UDP doesn't guarrante that packets get delivered at all iirc
07:15:46 <albeit> Nope, but other programs, running at the exact same time, receive them fine... so I don't know why this program/thread would be failing...
07:15:51 <opqdonut> could the recv be reading two messages?
07:16:28 <opqdonut> try recvFrom instead?
07:16:45 <geekosaur> I think the real problem is that there is no such thing as EOF on a UDP socket, so you need some artificial delay to make sure you don't exit the program with packets still in flight
07:16:59 <geekosaur> with TCP youd be able to wait on the socket returning EOF
07:17:08 <albeit> opqdonut: I'll try recvFrom
07:17:11 <bennofs> geekosaur: there is a threadDelay at the end of main
07:17:29 <albeit> geekosaur: Yeah the threadDelay I was hoping would keep the program running indefinitely while packets are in flight
07:17:33 <opqdonut> geekosaur: that's a valid point but I think packets not being received is a valid problem too
07:18:00 <opqdonut> albeit: I'm not quite sure what Network.Socket does but in C you'd use recvfrom for UDP
07:18:22 <geekosaur> I think what I'm getting at is something is interacting somewhere, I saw the top level threadDelay but something is getting torn down too early?
07:19:07 <geekosaur> also recvFrom should not matter here? what it gets you that you normally want is sender information, since UDP sockets are not "connected"
07:19:10 <joneshf-laptop_> how does cardinality work with polymorphic functions, e.g. `a -> a` has `a^a` inhabitants, but I thought there was exactly one function of this type?
07:19:16 <homesitter> hi
07:19:21 <k00mi> albeit: the process will terminate as soon as the main thread finishes, all other threads are killed
07:19:22 <joneshf-laptop_> do yo have to choose an `a` first in order to get an actual number?
07:19:29 <joneshf-laptop_> erm, cardinality...
07:19:31 <albeit> opqdonut, geekosaur: recvFrom didn't help
07:19:37 <geekosaur> exactly
07:19:46 <k00mi> albeit: so as soon as you send the last message, the process terminates including your receive thread
07:20:00 <albeit> k00mi: Even with the threadDelay in there?
07:20:17 <k00mi> oh I missed the one at the end
07:20:33 <geekosaur> wem
07:20:36 <geekosaur> erm
07:20:46 <geekosaur> :t Control.Concurrent.threadDelay
07:20:47 <lambdabot> Int -> IO ()
07:21:17 <albeit> The process stays up, so I think the threadDelay is working
07:21:43 <geekosaur> > (read :: String -> Int) (show (1000*1000*1000*1000))
07:21:45 <lambdabot>  1000000000000
07:21:56 <geekosaur> ok, does fit at least on 64 bit
07:22:18 <albeit> Ha good catch, I just tried to throw in a huge number... phew it fits
07:22:22 <geekosaur> > (read :: String -> Int32) (show (1000*1000*1000*1000))
07:22:24 <lambdabot>  -727379968
07:22:50 <albeit> (On 64-bit... but even if I reduce that delay number same issue happens)
07:23:14 <geekosaur> hm, actually... where is multicastSender from?
07:23:24 <geekosaur> I am wondering if it's somehow created buffered
07:23:37 <albeit> geekosaur: network-multicast pacakge https://hackage.haskell.org/package/network-multicast
07:24:10 <albeit> geekosaur: Even if other programs are able to receive those multicast packets fine, the multicastSender may still be at fault?
07:24:40 <geekosaur> with other programs, the main program exiting does not kill the receiver and the packets get flushed at program exit
07:25:04 <albeit> Ah
07:25:08 <geekosaur> when the receiver is a thread in the same program, buffered packets get flushed at about the same time that the receiver thread is killed
07:25:21 <funrep_> anyone been able to bypass the dependency issues with shm? (https://github.com/chrisdone/structured-haskell-mode/issues/83), i tried the presesnted fix but i just got "Dependency tree exhaustively searched."
07:26:21 <bennofs> funrep_: try cabal install structured-haskell-mode --constraint="haskell-src-exts ==0.15.0.1"
07:26:42 <geekosaur> oh, right, this is all low level, no buffering
07:26:59 <geekosaur> yet another simple obvious and wrong solution >.<
07:27:06 <funrep_> bennofs: i get same error
07:27:31 <geekosaur> (and I'm about to vanish into a call)
07:27:35 <albeit> geekosaur: Nooooo
07:27:51 <albeit> geekosaur: Well, I'll look into multicast buffering, so if I can figure it out
07:27:58 <geekosaur> it doesn't buffer
07:28:05 <bennofs> funrep_: ok, then try adding --max-backjumps=-1 to that command
07:28:05 <geekosaur> I was thinking that your sockets were Handles
07:28:15 <geekosaur> but they're file descriptors, so no buffering
07:29:03 <funrep_> same error: http://lpaste.net/2781587083368595456
07:29:49 <bennofs> funrep_: oh, s/0.15.0.1/1.15.0.1
07:29:50 <albeit> geekosaur: Tried using forkOS instead of forkIO (wild gamble), still no dice
07:30:19 <albeit> Might try fiddling with out the receiving socket is configured
07:30:26 <geekosaur> yeh, I would not expect that to matter (if it did, you would have found a GHC I/O manager bug, I think)
07:30:28 <funrep_> bennofs: oh, thanks! works now
07:33:14 <albeit> geekosaur: The other odd thing, if I remove a few lines from the file, it receive them all fine. It's when the file is too large / too many lines that it starts to fail...
07:33:46 <hyPiRion> So, uh, is it possible to make "data Term f = In (f (Term f))" a functor?
07:34:16 <hyPiRion> I'd guess not as f is * -> *
07:34:16 <johnw> if f is a functor, it should be trivial
07:34:25 <bennofs> hyPiRion: yes, if f is a Functor too
07:34:51 <bennofs> oh wait, no
07:35:03 <hyPiRion> Yes, it is. Uh, how would you actually make it a functor? I'm a bit confused on how to actually do it
07:35:06 <bennofs> hyPiRion: that has the wrong kind, your right
07:35:12 <hyPiRion> ah. alright
07:35:20 <bennofs> @let data Term f = In (f (Term f))
07:35:23 <lambdabot>  Defined.
07:35:26 <bennofs> :k Term
07:35:27 <lambdabot> (* -> *) -> *
07:35:42 <johnw> ah, I see
07:35:44 <johnw> hyPiRion: see http://hackage.haskell.org/package/category-extras-0.52.1/docs/Control-Functor-Fix.html
07:35:55 <johnw> it's not a functor there eihter
07:36:26 <johnw> neither in http://hackage.haskell.org/package/unification-fd-0.5.0/docs/Data-Functor-Fixedpoint.html
07:36:32 <bennofs> @hackage data-fix -- better package to get Fix from
07:36:32 <lambdabot> http://hackage.haskell.org/package/data-fix -- better package to get Fix from
07:36:36 <hyPiRion> johnw: alright, thanks
07:37:05 <johnw> ah, data-fix is nice and simple
07:37:15 <johnw> i'll use that in future, since I usually just recode it all since it's so small
07:37:25 <k00mi> albeit: try posting to the mailing list
07:37:49 <bennofs> johnw: if you want it a little bit more advanced, I like recursion-schemes :)
07:37:52 <bennofs> @hackage recursion-schemes
07:37:53 <lambdabot> http://hackage.haskell.org/package/recursion-schemes
07:37:58 <albeit> k00mi: Okay. Which mailing list? ;)
07:38:07 <johnw> yeah, I find recursion-schemes a bit complex
07:38:12 <dario> @hackage nonexisting
07:38:12 <lambdabot> http://hackage.haskell.org/package/nonexisting
07:38:16 <dario> i see
07:38:26 <k00mi> albeit: haskell@haskell.org
07:38:59 <k00mi> albeit: or rather haskell-cafe@haskell.org
07:39:14 <albeit> k00mi: Cool thanks
07:39:15 <opqdonut> yeah -cafe is more apropos
07:39:17 <bennofs> johnw: ah, I found 'para' quite useful (which data-fix doesn't have)
07:39:27 <albeit> k00mi, opqdonut, geekosaur: Thanks for the help btw!
08:00:33 <zipper> Which is the best way to install cabal on archlinux? pacman?
08:05:25 <albeit> Is it normal practice to add attachments to the email when sending a post to haskell-cafe?
08:18:23 * hackagebot BNFC 2.7.0.0 - A compiler front-end generator.  http://hackage.haskell.org/package/BNFC-2.7.0.0 (GregoireDetrez)
08:22:56 <ion> What’s the nicest LLVM library?
08:30:29 <yitz> ion: ghc
08:32:05 <yitz> albeit: no. post them elsewhere and link to them.
08:32:24 <albeit> yitz: Shoot, too late...
08:32:32 <yitz> heh. oh well.
08:33:01 <yitz> albeit: i would guess that mailman is configured to scrub them.
08:33:19 <albeit> Maybe I should just respond to my own thread with links to the files?
08:33:22 <yitz> albeit: what's the subject? i'll look for it and see.
08:33:48 <albeit> yitz: "Multicast receiver thread fails to receive last few messages"
08:35:32 <yitz> albeit: nope. the attachments came through ok. they're small files - no harm done.
08:35:43 <albeit> Great thanks for checking
08:35:46 <yitz> albeit: unless that binary data file contains malware or something.
08:36:12 <yitz> ;)
08:36:24 <albeit> yitz: It's pretty much text... probably should have renamed it so
08:36:35 <albeit> yitz: Any chance you have any insights into the issue? :)
08:37:47 <yitz> albeit: hmm, i wonder what it would do if you piped it into screen where ^A introduces control commands...
08:39:19 <albeit> Not sure what that means! Pipe the output to screen? Its already being output to stdout?
08:39:39 <HeladoDeBrownie> GNU screen is a terminal multiplexer program
08:39:59 <DannyFritz> gnu screen or tmux are amazin
08:41:42 <yitz> albeit: read the haddock comments about recvFrom here: http://hackage.haskell.org/package/network-2.6.0.2/docs/Network.html
08:42:21 <monochrom> screen should be able to tell apart stdout ^A from keyboard ^A
08:43:05 <mroman_> is there a System.Random that guarantees that the same seed will produce the same numbers?
08:43:34 <hiptobecubic> isn't that what the seed is for?
08:43:36 <albeit> yitz: I'm using recvFrom from Network.SOcket.ByteString, would those comments still apply?
08:43:45 <yitz> albeit: oh sorry, you appear to be using the bytestring interface which is much better
08:44:09 <mroman_> hiptobecubic: it's supposed to
08:44:13 <yitz> albeit: my comment about screen was a joke. sorry.
08:44:35 <mroman_> but somebody else compiled my program and by using the same it produces different numbers
08:44:43 <mroman_> *using the same seed
08:46:17 <mroman_> ",0 0 61rn5.+" when executed in the interpreter I compiled on my machine produces {43 29 21 40 58}
08:46:40 <mroman_> somebody else compiled my interpreter and the same program produces {21 7 61 18 36}
08:47:34 <mroman_> and I'm using randomRs (lo,ho) (mkStdGen seed)
08:49:24 <ion> mroman: I have used http://hackage.haskell.org/package/DRBG HashDRBGWith SHA512 with a constant key for a source of repeatable pseudorandomness.
08:50:31 <ion> mroman: https://github.com/ion1/buzhash-haskell/blob/wip-i-will-force-push-here/tests/Table.hs
08:51:54 <mroman_> I really need them to be reproducable
08:52:09 <mroman_> well.. not really
08:52:21 <mroman_> nobody used random functions so far in programs afaik
08:52:38 <mroman_> but it means you can't debug them locally and run them online if the numbers won't match
08:53:15 <mroman_> (since the online interpreter produces different numbers for the same seed)
08:54:29 <ion> HashDRBG and HmacDRBG are checked against NIST test vectors AFAIK.
08:54:32 <monochrom> I wonder if: compiler version makes a difference; 32-bit vs 64-bit makes a difference.
08:55:24 <monochrom> indeed, if the code simply says "Int", then 32-bit vs 64-bit GHC makes a difference.
08:55:34 <eyebloom> Is there an quick way to offset every key in a Data.IntMap by some constant?
08:55:48 <benzrf> jj
08:55:59 <mroman_> @type randomRs
08:56:00 <lambdabot> (Random a, RandomGen g) => (a, a) -> g -> [a]
08:56:15 <mroman_> @type mkStdGen
08:56:16 <lambdabot> Int -> StdGen
08:56:53 <monochrom> you want to look at the internal of StdGen and its RandomGen instance code
08:58:05 <benzrf> > mkStdGen 3434
08:58:07 <lambdabot>  3435 1
08:58:14 <benzrf> > next $ mkStdGen 3434
08:58:16 <lambdabot>  (137407398,137448090 40692)
08:59:21 <Sonderblade> is there a function in haskell that takes a sequence and a function, and produces a sequence of pairs where the first element is the original and the second is the mapped one?
08:59:57 <ion> zip xs (map f xs)
09:00:10 <ion> map (id &&& f) xs
09:00:31 <sx> ion: why limit to map?
09:00:41 <yitz> albeit: still - could it be that you really are reading all of the data, but just throwing it away when you do "take 100"?
09:00:58 <albeit> :t (&&&  ord)
09:00:59 <lambdabot> (Char -> c) -> Char -> (c, Int)
09:01:09 <ion> sx: Oh, your Haskell doesn’t have map = fmap yet? :-P
09:01:40 <sx> ion: nope, which haskell are you talking about? ;)
09:01:55 <Sonderblade> ion: what does &&& do?
09:02:07 <ion> > (f &&& g) x
09:02:09 <albeit> yitz: I don't think so... the sender is sending by lines, so each line should be in a separate datagram. Even If output the entire BS it doesn't show the last few lines
09:02:09 <lambdabot>  No instance for (GHC.Show.Show c'0)
09:02:09 <lambdabot>    arising from a use of ‘M56314464098878872694050.show_M56314464098878872694...
09:02:10 <lambdabot>  The type variable ‘c'0’ is ambiguous
09:02:10 <lambdabot>  Note: there are several potential instances:
09:02:10 <lambdabot>    instance [safe] GHC.Show.Show
09:02:25 <ion> > (f &&& g) x :: (Expr, Expr)
09:02:27 <lambdabot>  (f x,g x)
09:02:46 <albeit> That's pretty nifty
09:03:18 <Crockeo> From the official documentation (for (&&&)): "Fanout: send the input to both argument arrows and combine their output."
09:04:00 <albeit> yitz: It's just so odd because if I make the file its sending from smaller, everything works fine.
09:11:57 <ion> sx: Hmm, i don’t suppose https://phabricator.haskell.org/D235 also generalizes map. That would have been nice.
09:13:27 * hackagebot Ketchup 0.4.1 - A super small web framework for those who don't like big and fancy codebases  http://hackage.haskell.org/package/Ketchup-0.4.1 (Hamcha)
09:41:23 <nyuszika7h> > do { let s = Set.fromList [1,2,3]; putStrLn "{" ++ (intercalate "," $ map show $ S.toList s) ++ "}" }
09:41:26 <lambdabot>  <hint>:1:101: parse error on input ‘}’
09:41:32 <nyuszika7h> > do { let s = Set.fromList [1,2,3]; putStrLn "{" ++ (intercalate "," $ map show $ S.toList s) ++ "}"; }
09:41:32 <albeit> Is there an easy to concat every two items in a list? ["ab", "cd", "ef", "gh", "ij"] -> ["abcd", "efgh", "ij"]
09:41:33 <lambdabot>  <hint>:1:100: parse error on input ‘;’
09:41:52 <nyuszika7h> > do { let s = Set.fromList [1,2,3]; putStrLn $ "{" ++ (intercalate "," $ map show $ S.toList s) ++ "}"; }
09:41:53 <lambdabot>  <hint>:1:102: parse error on input ‘;’
09:41:58 * nyuszika7h sighs
09:42:44 <ij> albeit, split pkg has chunksBy. (foldr1 (++) . chunksBy 2) would do the trick, I think.
09:42:57 <funrep_> im following this guide to setup emacs: http://tim.dysinger.net/posts/2014-02-18-haskell-with-emacs.html, but i get this error: http://lpaste.net/7205888604998991872 when installing haskell-mode
09:43:14 <funrep_> im on the step where i evaluate the buffer i pasted the el-get stuff in
09:43:20 <ij> albeit, Sorry, chunk or splitBy. http://hackage.haskell.org/package/split-0.1.1/docs/Data-List-Split.html
09:43:50 <ReinH> funrep_: If you can't get help in here there is also #haskell-emacs, fyi :)
09:44:02 <sm> woah
09:44:04 <nyuszika7h> @let s = Set.fromList [1,2,3]
09:44:05 <lambdabot>  .L.hs:154:5:
09:44:05 <lambdabot>      Not in scope: ‘Set.fromList’
09:44:05 <lambdabot>      Perhaps you meant one of these:
09:44:05 <lambdabot>        ‘Seq.fromList’ (imported from Data.Sequence),
09:44:05 <lambdabot>        ‘S.fromList’ (imported from Data.Set),
09:44:06 <funrep_> i could ask there too, thanks
09:44:11 <nyuszika7h> @let s = S.fromList [1,2,3]
09:44:13 <lambdabot>  Defined.
09:44:28 <nyuszika7h> > putStrLn $ "{" ++ (intercalate "," $ map show $ S.toList s) ++ "}" -- is there a better way to do this?
09:44:30 <lambdabot>  Ambiguous occurrence ‘s’
09:44:30 <lambdabot>  It could refer to either ‘L.s’, defined at L.hs:154:1
09:44:30 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.s’,
09:44:30 <lambdabot>                           imported from ‘Debug.SimpleReflect’ at L.hs:118:1-26
09:44:30 <lambdabot>                           (and originally defined in ‘simple-reflect-0.3.2:De...
09:44:42 <nyuszika7h> @let testSet = S.fromList [1,2,3]
09:44:43 <lambdabot>  Defined.
09:44:48 <ReinH> funrep_: Looks like you are missing makeinfo, which is in the texinfo package (on debian/ubuntu at least): sudo apt-get install texinfo
09:44:51 <nyuszika7h> > putStrLn $ "{" ++ (intercalate "," $ map show $ S.toList testSet) ++ "}"
09:44:53 <lambdabot>  <IO ()>
09:44:59 <nyuszika7h> ಠ_ಠ
09:45:04 <nyuszika7h> > "{" ++ (intercalate "," $ map show $ S.toList testSet) ++ "}"
09:45:06 <lambdabot>  "{1,2,3}"
09:45:10 <nyuszika7h> there, sorry for the spam
09:45:10 <ReinH> (note that it's texinfo, not textinfo ;)
09:45:48 <funrep_> ReinH: aa thanks (tried apt-get install makeinfo and assumed it was not related to that)
09:45:49 <ij> > foldr1 (++) . chunk 2 $ ["ab", "cd", "ef", "gh", "ij"]
09:45:51 <lambdabot>  ["ab","cd","ef","gh","ij"]
09:45:55 <ReinH> funrep_: it's a rather annoying hidden (unreported) dependency for a number of things, like bash
09:46:04 <ReinH> funrep_: np
09:46:24 <ReinH> (like building bash from source, that is)
09:47:06 <ij> > map (foldr1 (++)) . chunksOf 2 $ ["ab", "cd", "ef", "gh", "ij"]
09:47:08 <lambdabot>  ["abcd","efgh","ij"]
09:47:09 <ij> albeit, ^
09:47:15 <albeit> ij: Great, thanks
09:48:07 <ij> albeit, Btw, you highlighted me with your example output. :)
09:48:24 <albeit> You were made to answer it!
09:50:08 <dfeuer> All righty then. There are two sensible semantics for dropWhileR for lists (one more element-strict, one more spine-strict). There are two sensible semantics for takeWhileR for lists, both spine-strict but one more element-strict than the other. I'm struggling to figure out sensible semantics for spanR.
09:50:43 <dfeuer> #8345
09:51:05 <Cale> dfeuer: dropWhileR?
09:51:27 <Cale> spanR?
09:51:30 <dfeuer> Cale, look at Data.List.dropWhileEnd
09:51:39 <eazar001> @hoogle dropWhileR
09:51:39 <lambdabot> Data.Sequence dropWhileR :: (a -> Bool) -> Seq a -> Seq a
09:51:40 <dfeuer> Consider the order of the operands to &&
09:51:53 <eazar001> @type dropWhile
09:51:54 <lambdabot> (a -> Bool) -> [a] -> [a]
09:52:27 <dfeuer> You can do a very similar thing with takeWhile, except there's no way to avoid being strict in the spine.
09:53:28 <ReinH> ij: foldr (++) [] instead or foldr1 (++)
09:53:55 <ij> Why?
09:53:57 <dfeuer> @src dropWhileEnd
09:53:58 <lambdabot> Source not found. You type like i drive.
09:54:25 <ij> ReinH, Oh, it'll fail when there's only one output?
09:54:25 <ReinH> Empty lists
09:54:26 <Cale> dfeuer: dropWhileEnd is a bit of a funny thing, it's not really analogous to dropWhile in the obvious way
09:54:29 <timmy_tofu> Anyone else having trouble recently with ghc-mod and hlint? I'm getting package dependency can't be met errors on a sandbox I just set up, didn't used to have this problem. The version it references seems fine
09:54:31 <ij> right
09:54:51 <ij> albeit, ^
09:55:04 <ReinH> They are otherwise equivalent since [] is the identity for (++)
09:55:13 <Cale> and actually, the documentation is wrong
09:55:31 <dfeuer> Cale, no, it's not; you're right about that. But it has a takeWhileish analogue. And like I said, two different reasonable ways to order those operands.
09:56:10 <dfeuer> Cale, the documentation is indeed wrong.
09:56:15 <dfeuer> I did not even notice that.
09:57:16 <dfeuer> er...
09:57:19 <beckyconning> whats the best way to perform two IO actions but only return the IO from one?
09:57:27 <dfeuer> No, Cale, I read the wrong thing. What's wrong in the documentation?
09:57:32 <Haskellfant> i'm trying to use attoparsec, but when i do “parse takeText "foobar"” i always get a partial
09:57:43 <Cale> Er, actually, no it's fine, I was confused
09:57:50 <merijn> beckyconning: "only return the IO from one" <- that doesn't make sense, do you mean only return the *result* of one?
09:57:51 <Haskellfant> how can i get a result when the string terminates?
09:57:56 <Haskellfant> so a DONE
09:58:10 <Haskellfant> ah Done i mean
09:58:11 <eazar001> beckyconning: make the last statement the io you want to return
09:58:30 <Cale> beckyconning: I'm going to assume you're looking for x >> y or  do { x ; y }
09:58:36 <merijn> beckyconning: The answer is "(>>) :: Monad m => m a -> m b -> m b"
09:58:44 <Cale> (That would assume you meant to say result)
09:59:06 <Cale> If you want to return the result of the other, you could write  do { v <- x; y; return v }
10:00:57 <beckyconning> thanks : )
10:02:19 <merijn> Haskellfant: You want to either 1) feed the partial result an empty Text to terminate or 2) use parseOnly
10:02:53 <beckyconning> merjin's on a roll : )
10:03:39 <merijn> More fun than debugging C++ linking errors >.>
10:03:42 <Haskellfant> merijn: what exactly do you mean by feeding it an empty Text?
10:05:16 <merijn> Haskellfant: 'feed myResult ""'
10:05:37 <kini> I'm reading a paper which says "In Agda, new data types can be defined using a syntax similar to Haskell's syntax for GADTs (Peyton Jones et al. 2006)."
10:05:48 <Haskellfant> merijn: now, i feel stupid, thx :)
10:05:52 <kini> I thought GADT syntax was modeled after Agda's syntax for inductive types... am I mistaken?
10:09:55 <Haskellfant> why does parseOnly from Data.Attoparsec.Text return Either String a and not Either Text a?
10:12:34 <dmj`> Haskellfant: String probably contains the error message
10:14:09 <Haskellfant> dmj`: yeah, figured that out now, sorry for asking so stupid questions
10:14:53 <dmj`> Haskellfant: that was not a stupid question
10:15:06 <eazar001> what's wrong with using Text for the error message?
10:15:25 <eazar001> is that a bad design choice or something?
10:16:00 <Haskellfant> eazar001: i guess there is just not really a need for it
10:16:07 <geekosaur> short strings that are destined for direct output often make more sense as String
10:16:15 <dmj`> eazar001: text is a seperate package, why introduce a new dependency just to handle error messages... in this case it could be though, since text is included
10:26:29 <lpsmith> hmm, can the scientific package handle NaNs and Infinities?
10:26:43 <Qfwfq> Just used unsafeCoerce for the first time. I feel really.. dirty.
10:27:19 <Qfwfq> Is there a support club for this sort of thing?
10:28:27 <peddie> Qfwfq: try #agda
10:30:42 <albeit> If I write to a Chan with writeChan in one thread, and read from it with readChan, why would my readChan be reading the same value multiple times?
10:31:22 <merijn> albeit: Did you write it multiple times?
10:32:14 <albeit> merijn: Argh, yeah, now I need to fiture out why its doing that...
10:32:57 <merijn> Debug.Trace to the rescue :p
10:33:33 * hackagebot azurify 0.4.0.5 - A simple library for accessing Azure blob storage  http://hackage.haskell.org/package/azurify-0.4.0.5 (ArnoVanLumig)
10:33:35 * hackagebot Spock 0.6.6.0 - Another Haskell web framework for rapid development  http://hackage.haskell.org/package/Spock-0.6.6.0 (AlexanderThiemann)
10:40:07 <albeit> Is it most likely that writing to a socket with sendTo is faster than reading from a socket with recvFrom and then adding the packet to a Chan?
10:46:17 <geekosaur> Chan has a mutex associated with it, so there would definitely be overhead. how significant, I couldn't say
10:47:12 <albeit> geekosaur: Btw, I think the mailing list solved my issue. The Linux socket buffer was overflowing as I wasn't reading from the socket fast enough, so it was just dropping packets.
10:47:23 <geekosaur> saw that, yes
10:47:38 <geekosaur> linux takes the approach that UDP is unreliable anyway so why bother?
10:48:00 <albeit> Yeah, makes sense, and a huge relief to know why
10:52:33 <bryanedds> holy god, we got enough people in this room nowadays?!
10:53:01 <bryanedds> I'm an F# programmer, and I cam here seeking advice on generalizing a type.
10:53:42 <bryanedds> Here's my type - http://lpaste.net/111478
10:53:46 <exio4> we're not enough
10:53:55 <bryanedds> I'm trying to write bind for it
10:53:59 <merijn> bryanedds: What do you mean "nowadays"? There have been >600 people in here for years...
10:53:59 <etandel> #haskell is very large for a long time
10:54:24 <bryanedds> been a loooong time since I've been here
10:54:56 <bryanedds> I want the bind to change 'a in Handlet
10:55:18 <bryanedds> First question - do I even have anything resembling a monad?
10:55:58 <merijn> Doubtful, a is contravariant
10:56:23 <bryanedds> what if I made 'a be the entire handler?
10:56:29 <bryanedds> in bind, I mean
10:57:27 <bryanedds> hmm... then I'd lose too much specificty...
10:57:42 <bryanedds> well, do I have anything here?
10:58:49 <bryanedds> I added my map and filter fns - http://lpaste.net/111478
10:59:33 <bryanedds> neither of those seem to relate to bind in any way
11:00:21 <etandel> the real "holy god" moment for me here is that there are people that actually use F#. Oo. You're the first one I've seen.
11:00:34 <triliyn> bryanedds: I think that could be a contravariant functor. I'm not sure that would help you write filter though
11:02:26 <bryanedds> I'll look at what a contravariant functor is, then
11:02:54 <triliyn> Actually, I'm not even entirely sure it would let you write your map function, since it passes the World too
11:03:15 <Cale> bryanedds: It's one which instead of preserving the direction of arrows, swaps them
11:03:15 <triliyn> A contravariant functor is a functor that can be mapped over "in reverse", kind of
11:03:36 <triliyn> Functor fmap is Functor f => (a -> b) -> f a -> f b
11:03:49 <bryanedds> I somehow feel like my flows are reversed
11:03:56 <bryanedds> I'll add the usage code -
11:03:57 <triliyn> Contravariant functors instead of Contravariant f => (a -> b) -> f b -> f a
11:04:08 <triliyn> *instead have
11:04:37 <johnw> another way to say it is that a contravariant functor maps over inputs
11:05:05 <josephle> johnw: what an intuitive way to put it! :)
11:05:27 <bryanedds> updated - http://lpaste.net/111478
11:05:59 <triliyn> I like to describe it as "a (covariant) functor can spit things out, and a contravariant functor can eat things"
11:06:15 <triliyn> But I'm not sure how useful that would be to people other than me
11:06:37 <Cale> bryanedds: If you wanted something monad-like (but not really a monad, since this is contravariant), you could consider how you might implement  join : ('a Handlet) Handlet -> 'a Handlet -- I don't think there's a natural way to do that here.
11:06:42 <bryanedds> I wonder if I could turn this into a covarian functor - as I said, this implementation somehow seems inverted
11:07:22 <c_wraith> I just think of it as reversing the function.  (a -> b) -> (f a -> f b) preserves the function direction.  (a -> b) -> (f b -> f a) reverses the function - for some definition of reverse.
11:08:31 <bryanedds> The reason I want to generalize this is that I feel like there's something wrong with it, and if I can generalize, it will more likely be the correct design
11:08:36 <bryanedds> is that wrong intuition?
11:08:45 <Cale> That's not a bad intuition
11:09:03 <bryanedds> I wonder if it serves me here
11:13:28 <ouuiio> could anyone help me to understand the original de bruijn paper?
11:13:34 <hexagoxel> @src ($)
11:13:35 <lambdabot> f $ x = f x
11:13:39 <hexagoxel> bryanedds: ^^
11:14:06 <ouuiio> that is, "lambda calculus notation with nameless dummies"
11:14:17 <eazar001> hmmm, contravariance and covariance reminds me a little of mode abstraction
11:14:26 <eazar001> in logic languages
11:14:39 <bryanedds> hexagoxel, I wish I could use a better operator symbol
11:14:59 <bryanedds> but unfortunatey the symbol character determines associativity in F#
11:15:17 <bryanedds> and the only right-assoc symbol is either ^ or **
11:16:14 <bryanedds> F# is fine, you just have to hack your way through its small limitations
11:16:16 <josephle> ouuiio, is this a paper on debruijn indices?
11:16:23 <bryanedds> It really needs macros, however
11:17:04 <bryanedds> BTW, ya, I can definitely see how I have a cofunctor here
11:17:44 <bryanedds> It makes me feel better that I at least have something
11:18:37 * hackagebot heist 0.14.0 - An Haskell template system supporting both HTML5 and XML.  http://hackage.haskell.org/package/heist-0.14.0 (DougBeardsley)
11:18:39 * hackagebot snap 0.13.3 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.13.3 (DougBeardsley)
11:19:16 <bryanedds> TIL H in Haskell is silent
11:19:29 <fizbin> Where?
11:19:43 <bryanedds> >> An Haskell template system supporting both HTML5 and XML.  http://hackage.haskell.org/package/heist-0.14.0 (DougBeardsley)
11:19:56 <monochrom> oh, haha
11:20:27 <ion> An historical realization
11:21:11 <bryanedds> ahistorical
11:22:40 <eazar001> an historical
11:22:57 <eazar001> i think this might be an odd case
11:24:50 <bryanedds> An Haskellian realization :)
11:25:01 <eazar001> if the combination of letters form a morpheme that roughly sounds like a vowel, then "an" might be justified
11:25:32 <eazar001> but this is extemporaneous reasoning; i.e. not based on memorization of rules (so i don't know if this is right)
11:25:43 <eazar001> oh well ... this isn't #linguistics, so nvm
11:26:12 <geekosaur> it's english, it doesn't make sense :p
11:26:33 <eazar001> hah, human languages in general don't make sense
11:26:38 <eazar001> but yea english is pretty bastardized
11:27:32 <geekosaur> (and for the second time this week I'm trying to remember what I think is an H. Beam Piper quote about English being about as legitimate as the other offspring between Norman soldiers and Saxon barmaids)
11:27:56 <eazar001> haha
11:28:27 <johnnyrichard> Anyone make web applications with haskell?
11:30:58 <doismellburning> johnnyrichard: people in #haskell-web and #yesod probably do
11:31:41 <johnnyrichard> doismellburning: thx
11:36:19 <camm> Hi guys. I have a question. Could anyone of you help me, please?
11:36:30 <joelteon> not unless you tell us what it is
11:36:44 <joelteon> iterating through the set of all possible questions is not feasible
11:37:39 <camm> Ok. I'd like to understand this: "mod :: Integral a => a -> a -> a"
11:37:50 <johnnyrichard> doismellburning: #haskel-web not have anybody
11:38:12 <glguy> johnnyrichard: If you have a question more specific than if anyone uses Haskell for web you should ask that
11:38:14 <doismellburning> johnnyrichard: that's because you missed an l
11:38:49 <doismellburning> un-miss that l
11:39:09 <johnnyrichard> doismellburning: i miss l just here
11:39:49 <johnnyrichard> doismellburning: have six users
11:40:01 <Haskellfant> i've got a function a -> STM b and Either c a, now i want to apply the function to the either but i need to get STM (Either c b) out of it. The functor instance of Either only gives me Either c (STM b). I can of course manually achieve this with either (const (return ())) function eithervalue, but i feel like i should be able to achieve this using functor/applicative/monad instances
11:40:02 <johnnyrichard> doismellburning: all are AFK
11:40:51 <oakwhiz> johnnyrichard: http://happstack.com/page/view-page-slug/9/happstack-lite
11:41:48 <johnnyrichard> oakwhiz: thanks, i need to go
11:45:21 <eazar001> @type void
11:45:22 <lambdabot> Functor f => f a -> f ()
11:45:36 <eazar001> @type const (return ())
11:45:37 <lambdabot> Monad m => b -> m ()
11:46:26 <eazar001> > fmap (const ())
11:46:27 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
11:46:27 <lambdabot>    arising from a use of ‘M6815491964297844326496.show_M6815491964297844326496’
11:46:28 <lambdabot>  The type variable ‘a0’ is ambiguous
11:46:28 <lambdabot>  Note: there are several potential instances:
11:46:28 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
11:53:39 * hackagebot snaplet-amqp 1.0.0.0 - Snap framework snaplet for the AMQP library  http://hackage.haskell.org/package/snaplet-amqp-1.0.0.0 (ParnellSpringmeyer)
11:55:50 <RegEchse> Haskellfant: i dunno what STM is, but assuming it's a monad, isn't  liftM function eithervalue  what you want?
11:57:00 <monochrom> @type liftM either
11:57:01 <lambdabot> Monad m => m (a -> c) -> m ((b -> c) -> Either a b -> c)
11:57:15 <monochrom> @type liftM2 either
11:57:16 <lambdabot> Monad m => m (a -> c) -> m (b -> c) -> m (Either a b -> c)
11:58:46 <Haskellfant> RegEchse: it is a monad, the problem is that liftM will give me Either a (STM b), i need the stm outside
11:59:43 <RegEchse> oh, i didn't read carefully, sorry
12:02:07 <Haskellfant> monochrom: if that's directed to me (sorry if it's not) it doesn't look quite right. first my function is a -> m b and not m (a -> c) and second i want to pass in an Either not a second function wrapped in a monad
12:03:27 <monochrom> yes, realized that it did not fit.
12:03:43 <monochrom> I was experimenting.
12:03:48 <Haskellfant> :)
12:08:41 * hackagebot snaplet-amqp 1.0.1.0 - Snap framework snaplet for the AMQP library  http://hackage.haskell.org/package/snaplet-amqp-1.0.1.0 (ParnellSpringmeyer)
12:12:23 <chirpsalot> Uhmmm. I have this program https://github.com/Chobbes/MooXtract/blob/master/MooXtract.hs and my student submitted a .tar.gz but NAMED it a .zip. Since it checks file extensions for figuring out how to extract it this tries to extract using https://hackage.haskell.org/package/zip-archive-0.2.3.4/docs/Codec-Archive-Zip.html
12:12:58 <chirpsalot> Which gives me this lovely error message when the program hits the imposter .zip file "Data.Binary.Get.runGet at position 4: Did not find end of central directory signature"
12:13:11 <chirpsalot> Is there a way to catch this and handle this nicely?
12:13:22 <ion> http://hackage.haskell.org/package/magic
12:13:34 <chirpsalot> ion: is that even remotely portable?
12:13:41 <chirpsalot> Wasn't sure what to search for :).
12:14:24 <chirpsalot> ion: I ask because I know file returns different things on my mac as opposed to GNU file on linux.
12:14:37 <ion> I’m afraid i don’t know offhand.
12:14:41 <phaazon> oh, edwardk, there’s no FromJSON instance for V* in linear; is that normal? I’d expect something like [1,2] for a V2 a for instance
12:14:47 <burp> libmagic bsd vs libmagic gnu? :D
12:14:48 <burp> dunno
12:15:05 <edwardk> phaazon: that'd make linear pick up an aeson dependency?
12:15:15 <phaazon> that would indeed
12:15:20 <phaazon> is that a problem?
12:15:27 * edwardk cringes
12:15:30 <ion> :-D
12:15:40 <phaazon> woh
12:15:46 <edwardk> its been a problem for adoption for other packages of mine to incur a dependency on aeson
12:15:47 <phaazon> it’s surprising from you
12:15:47 <chirpsalot> ion: this is my fear, anyway :). It's not possible to catch that runtime error and handle it somewhat sanely is it?
12:15:56 <phaazon> when I see the zlib in… lens ;)
12:16:07 <edwardk> the difference is aeson has a set of dependencies that is mostly disjoint from everything else i depend on
12:16:11 <chirpsalot> extractArchiveFile just returns IO (), so it won't have exceptions?
12:16:23 <edwardk> and unlike aeson, zlib is _in the platform_ so everyone should have it installed
12:16:23 <phaazon> that’s sad
12:16:43 <phaazon> edwardk: I guess everyone using linear use JSON formatting as well
12:16:48 <ion> It would be p. nice if packages could have parts that are marked as “enhancing” other named packages and cabal would compile them wheneverr the user installs both packages simultaneously.
12:16:59 <geekosaur> considering hwo many people seem to think the platform is the root of everything that is wrong with haskell...
12:17:01 <edwardk> phaazon: those things seem rather completely disjoint to me =P
12:17:24 <edwardk> phaazon: if aeson were picked up by the platform it'd be an easy sell to me
12:17:31 <phaazon> they don’t to me, since writing a video game will use json
12:17:36 <phaazon> ok
12:17:37 <phaazon> I got it :)
12:17:42 <phaazon> I’ll keep the instances mine
12:17:44 <geekosaur> they're working on it. aeson sprouted a dependency on an unstable librarty
12:17:46 <phaazon> mouhahaha!
12:17:53 <edwardk> phaazon: since writing a game using javascript might ;)
12:18:15 <phaazon> to me, javascript and json are, in the end, disjoint
12:18:21 <bryanedds> where do cofunctors arise in Haskell?
12:18:23 <eazar001> Haskellfant: so you're looking to make STM (Either e a) ?
12:18:23 <edwardk> geekosaur: that was what panicked mzero and company, right as it seemed a sure win to have it go in there was a big hullabaloo about scientific, etc.
12:18:32 <geekosaur> yep
12:18:37 <edwardk> bryanedds: cofunctor = functor. its not a thing
12:18:42 <geekosaur> and tbh I agree with it, given how often scientific was changing
12:18:42 <edwardk> bryanedds: contravariant functors exist
12:18:53 <bryanedds> sry, _contravariant_ functors
12:19:23 <edwardk> bryanedds: they always arise from a use of (->) (or not using the argument) which is the only thing we have that swaps variance.
12:19:39 <bryanedds> (sometimes they're called cofunctors from my reading, btw)
12:20:03 <edwardk> bryanedds: which was a mistake pushed by one or two folks that we've been seeking to eradicate ;)
12:20:16 <hexagoxel> :t Data.Traversable.mapM :: Monad m => (a -> m b) -> Either c a -> m (Either c b) -- Haskellfant
12:20:17 <lambdabot> Monad m => (a -> m b) -> Either c a -> m (Either c b)
12:20:19 <chirpsalot> ion: looks like it will depend on whatever magic database you have, so it's not going to be very portable :(.
12:20:33 <bryanedds> edwardk, maybe you can help me with my issue
12:20:43 <edwardk> co vs contra is one of the most common mistakes folks made and picking bad vocabulary just exacerbates the problem ;)
12:20:55 <edwardk> bryanedds: whats up?
12:21:38 <bryanedds> I have a structure that I'm not comfortable with
12:21:40 <bryanedds> http://lpaste.net/111478
12:22:15 <edwardk> with an a occuring in negative position there, so Handlet is contravariant
12:22:47 <ouuiio> josephle: yes
12:22:55 <RegEchse> Haskellfant: ah, now it stroke me!  use Data.Traversable.mapM
12:23:16 <RegEchse> :t Data.Traversable.mapM
12:23:18 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
12:23:30 <RegEchse> that's exactly what you want, no? :)
12:23:42 * hackagebot rest-gen 0.16.0.1 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.16.0.1 (ErikHesselink)
12:23:53 <edwardk> bryanedds: what makes you uncomfortable with it?
12:24:00 <hexagoxel> RegEchse: :p
12:24:20 <RegEchse> oh
12:24:22 <RegEchse> :D
12:24:24 <RegEchse> i didn't read up
12:24:26 <RegEchse> :D
12:24:28 <RegEchse> sry
12:25:11 <RegEchse> hexagoxel: but i came up with it myself, i swear! :D
12:25:36 <sinelaw> edwardk, where else would variance swapping occur?
12:25:44 <sinelaw> besides ->, in theory
12:25:45 <zipper> What does `cabal install -j` do? It's not in the docs.
12:26:07 <eazar001> > let a = fmap (const $ Right 5) $ return 4 :: STM (Either String Int
12:26:09 <lambdabot>  <hint>:1:68:
12:26:10 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
12:26:19 <eazar001> > let a = fmap (const $ Right 5) $ return 4 :: STM (Either String Int)
12:26:20 <lambdabot>  not an expression: ‘let a = fmap (const $ Right 5) $ return 4 :: STM (Either...
12:26:32 <eazar001> > fmap (const $ Right 5) $ return 4 :: STM (Either String Int)
12:26:34 <lambdabot>  Not in scope: type constructor or class ‘STM’
12:26:34 <lambdabot>  Perhaps you meant ‘ST’ (imported from Control.Monad.ST.Safe)
12:26:47 <sinelaw> eazar001, /msg lambdabot
12:26:48 <ouuiio> josephle: it's a 14 page paper.  in section 6 they introduce a new notation, which I'm failing to understand.
12:27:07 <edwardk> sinelaw: if you had any other connectives in the type system that were primitive that had negative position. (arguments to pi types?)
12:27:18 <hexagoxel> zipper: cabal help install | grep "\-j"
12:27:48 <bryanedds> sorry, got distracted
12:28:16 <bryanedds> I feel like my type might be sloppy, and / or, my combinators are backwards somehow
12:28:36 <bryanedds> the closest thing I have to a more general structure is a contrafunctor
12:28:37 <zipper> hexagoxel: Thanks
12:28:48 <bryanedds> but it's not exactly that either
12:29:03 <edwardk> bryanedds: well it _is_ contravariant, you can do more with it though
12:30:10 <bryanedds> have you seen this structure in similar scenarios before - EG - purely functional event combinators?
12:30:17 <edwardk> bryanedds: there are lots of things that are 'contravariant plus other stuff' http://hackage.haskell.org/package/contravariant-1.2/docs/Data-Functor-Contravariant-Divisible.html
12:30:24 <edwardk> and yes, i've seen the pattern
12:30:38 <edwardk> Erik Meijer has made sort of a cottage industry out of selling variants on this ;)
12:30:40 <Haskellfant> hexagoxel, RegEchse: perfect, thx for your help
12:31:02 <edwardk> you've got the basic idea of his notion of a "reactive" programming framework there as an observer.
12:31:15 <edwardk> observables form a monad in his framework, and observers are contravariant like what you describe
12:31:15 <bryanedds> right, exactly
12:31:25 <sinelaw> contravariance in subtyping is a big word. for non-math geeks it's impossible to understand the relation to the concept, which really just says that "this type parameter's "inheritance" must be the opposite (contra) of the type itself"
12:31:34 <bryanedds> I don't think I have a monad though, right?
12:31:44 <edwardk> bryanedds: what you have is the observer, not the observable
12:31:48 <edwardk> lets define the observer =)
12:31:52 <ouuiio> edwardk: since you wrote the bound package, you may have read the original de Bruijn paper on de Bruijn indices, haven't you?
12:32:02 <edwardk> er observable
12:32:35 <bryanedds> right, I couldn't figure out how to define observable
12:32:45 <bryanedds> I just get totally lost
12:33:06 <edwardk> newtype Observable a = Observable { observe :: Handlet a -> IO (World -> World) }  -- or something like that. without effects in your world its trickier to define
12:33:27 <edwardk> ou take the handlet and change the world, giving back an action to unsubscribe
12:34:02 <edwardk> bryanedds: this code is broken, but it gets the idea: https://github.com/ekmett/reactor/blob/master/Reactor/Observable.hs#L36
12:34:13 <edwardk> bryanedds: https://github.com/ekmett/reactor/blob/master/Reactor/Observer.hs#L17
12:34:26 <edwardk> the Observable is the monad, etc. the Observer is the contravariant thing paired with it
12:34:39 <bryanedds> ah ok
12:35:02 <bryanedds> I have another related issue if you don't mind
12:35:04 <edwardk> you notify the Observable about a new Observer and it hands you a subscription you can use the shut off the firehose of events
12:35:12 <edwardk> go for it, though i'm heading out soon
12:35:52 <bryanedds> ok, I defined fold as well, but it's very sloppy since I can't use in-place mutation
12:35:53 <bryanedds> http://lpaste.net/111478
12:35:59 <edwardk> ouuiio: this one? http://alexandria.tue.nl/repository/freearticles/597619.pdf
12:36:25 <albeit> What downsides does enabling "-fno-omit-yields" have?
12:36:43 <bryanedds> Is there a way to define fold in a pure functional way without having to hang the accumulator on the world?
12:37:18 <edwardk> bryanedds: you can carry it in an observer that is itself observable, but that is just being suspended in the world, anyways
12:37:39 <bryanedds> hmm
12:37:46 <edwardk> e.g. you can write a combinator that takes an observable to a new observable
12:38:02 <bryanedds> how might that be typed?
12:38:02 <bezirg> I want to install happy through cabal-install. How can I instruct cabal-install to build & install the happy executable but remove its library dependencies afterwards?
12:39:49 <edwardk> bryanedds: foldl :: (r -> a -> r) -> r -> Observable a -> Observable r -- which fires off its final answer when you tell it there is no more input in the reactive model
12:39:54 <timmy_tofu> bezirg: install into a sandbox and move the executable
12:40:17 <bryanedds> ok
12:40:54 <bryanedds> So, in my case, I'm guessing the Address type is the core of the Observable value?
12:41:24 <edwardk> bryanedds: alternately scanl :: (r -> a -> r) -> r -> Observable a -> Observable r -- which fires off its answers after every fold step
12:41:41 <edwardk> i don't quite know what your "Address" notion is, as that is peculiar to your chosen implementation
12:41:54 <bryanedds> oh, sorry, it's not explicit in the code I showed you
12:42:10 <edwardk> i model these things as concurrent processes that spawn other messages and things that have to happen by message passing
12:42:14 <bryanedds> Anything that can be observed is at an address
12:42:34 <ouuiio> edwardk: yes, in section 6 they talk about a sequence of NF expressions and introduce a notation for that.  could you explain what they mean by the term "sequence"?  there's an example expression in (4.1), how can it be split?
12:42:42 <edwardk> so basically what we have here is a slightly more generalized notion of an Address that is typed, we call it an Observable a ;)
12:43:19 <bryanedds> ah, ok
12:43:26 <bryanedds> I think I understand :)
12:43:33 <Cale> edwardk: In what way is that code broken btw?
12:43:37 <edwardk> bryanedds: it may not be a perfect translation for what you are doing
12:43:39 <Cale> (just out of curiosity)
12:43:59 <bryanedds> I will dig more - thanks edwardk
12:44:07 <edwardk> Cale: it used a broken implementation of a work stealing deque. ryan newton fixed it and i repackaged it, but i never fed it back into this work
12:44:15 <edwardk> as this was just me trying to understand reactive
12:45:26 <edwardk> Cale: i also figured out better Task implementations since then
12:45:41 <edwardk> ouuiio: its been a long time since i read the paper
12:46:40 <edwardk> ouuiio: and i confess i only remember reading through it in passing to try to get a sense of what was going on, before moving to things with more modern vocabulary
12:46:52 <ouuiio> edwardk: oh, okay.  I'll try to find something else to learn from.  I thought it may be a good idea to start from the original.
12:47:23 <edwardk> ouuiio: it can be though reading older notation can get tough at times =)
12:47:30 <ouuiio> edwardk: Would the paper by McBride be a good replacement?
12:47:47 <ouuiio> "I'm not a number, I'm a free variable," IIRC.
12:47:55 <edwardk> anything by mcbride is worth reading. ;) whether you emerge from it with an understanding is another matter ;)
12:48:04 <ouuiio> Haha
12:48:45 <edwardk> conor was clearly a standup comedian in a previous life.
12:48:45 <Cale> The funny thing about mathematics is that it's often easy to come up with fake historical accounts of the order in which things came about that are much better than the real one.
12:48:53 <edwardk> Cale++
12:49:00 <ouuiio> I definitely like Conor's sense of humor, but some things are just above my head right now.
12:49:28 <roconnor> man, the category of cppo has terrible properties. :(
12:49:43 <roconnor> How am I suppose to define language semantics with this!
12:49:46 <johnw> roconnor: like what?
12:49:56 <roconnor> like no initial object.
12:51:00 <roconnor> oh wait, maybe I only need a final object.
12:51:38 <johnw> cppo has no initial, but it has final
12:51:42 <johnw> cppo⊥ has got them both
12:51:48 <bryanedds> right, because you can start with induction and work your way backwards
12:52:13 <roconnor> cppo⊥ seems like a stupid category, despite it's wonderful properties.
12:52:29 <sinelaw> what's a sane way to pass "nice to have" context information in a type checker? specifically the location in the original source code
12:52:38 <monochrom> I forgot, what does cppo⊥ add to cppo?
12:52:52 <johnw> monochrom: http://www.cs.gunma-u.ac.jp/~hamana/Papers/cpo.pdf
12:52:53 <roconnor> monochrom, only strict functions.
12:53:14 <johnw> (see slide 5)
12:53:21 <roconnor> johnw, I wish those slides were an actual paper.
12:53:28 <johnw> yes, true
12:55:00 <statusfailed> Has anyone played about with Tekmo's "morte" language?
12:55:47 <roconnor> I'm trying to write lax-semantics for a core language with Elliot-Palmer style reduction under case statements, but I don't even understand traditional semantics.
12:55:58 <roconnor> apparently.
12:56:11 <statusfailed> I know some of those words
12:57:06 <roconnor> statusfailed, Don't feel bad; I made up half of those words.
12:57:51 <statusfailed> roconnor: I'm used to it by now anyway :p
12:57:52 <johnw> roconnor: does this help at all: http://www.itu.dk/people/biering/papers/domain.pdf
12:58:08 <sinelaw> roconnor, what's "Elliot-Palmer style reduction"
12:58:38 <statusfailed> sinelaw: I want to say it's made up but I can't be sure
12:59:04 <sinelaw> ha
12:59:04 <bryanedds> this is interesting, in my case, all event streams are infinite
12:59:20 <bryanedds> whereas yours can be finite and end
13:12:00 <Hulgurrk> Hello
13:23:42 <dfeuer> Why aren't type family instance declarations allowed to overlap.
13:23:46 * hackagebot heist 0.14.0.1 - An Haskell template system supporting both HTML5 and XML.  http://hackage.haskell.org/package/heist-0.14.0.1 (DougBeardsley)
13:33:24 <merijn> dfeuer: They must be globally unique
13:33:34 <merijn> dfeuer: open world, etc.
13:33:41 <merijn> dfeuer: You might want closed type families?
13:35:11 <dfeuer> merijn, maybe?
13:35:17 <dfeuer> No.
13:36:09 <merijn> dfeuer: Well, that's your two options: 1) no overlap or 2) closed type families
13:37:27 <merijn> dfeuer: What are you trying to do?
13:39:34 <dfeuer> merijn, the vague notion is something like what Data.Vector.Unboxed does, adapting a container to different element types. The unboxiness is a bit weird, but suppose I wanted a Set to specialize to Int, Char, anything Ord, and then fall back on anything Eq.
13:40:09 <merijn> dfeuer: For adapting a type to different elments you want data families
13:40:25 <merijn> dfeuer: But then you don't get to overlap either
13:43:47 * hackagebot snap 0.13.3.1 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.13.3.1 (DougBeardsley)
13:43:49 * hackagebot persistent-template 2.0.7 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-2.0.7 (GregWeber)
13:43:51 * hackagebot persistent 2.0.7 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-2.0.7 (GregWeber)
13:43:53 * hackagebot persistent-mongoDB 2.0.7 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-2.0.7 (GregWeber)
13:56:15 <daniell> How do I specify typeclass constraints for multiple arguments? http://pastebin.com/BSnfe1aS
13:57:05 <iteratee> Got ghc-7.8.3 working on arm, debian jessie.
13:57:13 <glguy> daniell: You put the constraints on the functions that need them and not the data types
13:58:46 <arianvp_> is there a version of maximum that returns Maybe?
13:59:19 <glguy> :t maximumOf folded -- there is in `lens` at least, not in base
13:59:20 <lambdabot> (Foldable f, Ord a) => f a -> Maybe a
13:59:45 <merijn> daniell: Just do "data BinTree a b = Leaf b | Node a (BinTree a b) (BinTree a b) deriving (Show)"?
14:00:01 <arianvp_> Too bad the code tester that our uni uses only supports haskell-platform
14:00:02 <arianvp_> :(
14:00:21 <bor0_> hello. I have this piece of code http://lpaste.net/111484. I want to use "when a b" behaviour, but when I do "when (x == "hello") runCommand "echo OK"" it does not quote work. I am guessing I need to somehow lift this to IO (), but how?
14:00:48 <mauke_> bor0_: no, you need to add parens
14:01:52 <bor0_> still doesn't work...
14:02:11 <bor0_> it can't match System.Process.Internals.ProcessHandle against ()
14:02:36 <glguy> bor0_: If you pasted the code that didn't work we'd be able to give better advice
14:02:54 <bor0_> here it is: http://lpaste.net/175549156067115008
14:03:14 <bor0_> > runCommand "echo test"
14:03:16 <lambdabot>  Not in scope: ‘runCommand’
14:04:30 <glguy> bor0_: http://lpaste.net/175549156067115008
14:04:39 <glguy> Because    when :: Monad m => Bool -> m () -> m ()
14:04:48 <glguy> and    runCommand :: String -> IO ProcessHandle
14:05:10 <glguy> like you were saying, () wasn't matching ProcessHandle
14:05:51 <bor0_> aha,... and I thought I had tried something like     when (x == "hello") (runCommand "echo OK" >>= \_ -> return ()) (equivalent to your >>), but I guess I'll go with the void one. it seems more readable :)
14:06:42 <Janice23>  You can find funny videos here. http://tinyurl.com/ozfvxy3
14:07:00 <glguy> bor0_: Rather than ignoring the processhandle, you should probably call waitForProcess on it
14:08:18 <daniell> glguy: thanks =) merijn That didn't work, I still have to do the typeclass constraint at function level
14:08:59 <glguy> daniell: merjin's suggestion wasn't independent of mine
14:09:09 <glguy> was*&
14:09:32 <glguy> If you want your type to be Show-able you'd want that deriving clause
14:10:27 <merijn> bor0_: Use void
14:10:29 <merijn> :t void
14:10:31 <lambdabot> Functor f => f a -> f ()
14:10:46 <merijn> "void (runCommand "echho OK")"
14:10:49 <daniell> glguy: but what difference does it make if I use  "deriving Show" in the type? will the compiler complain earlier when I try to instantiate a type where the type variables are not Showable?
14:10:59 <merijn> daniell: Yes
14:11:22 <daniell> ah nm wasn't -> was =p
14:11:37 <merijn> daniell: It will derive: "instance (Show a, Show b) => Show (BinTree a b)"
14:11:47 <daniell> merijn: ah nice well that is good to remember
14:11:59 <merijn> daniell: i.e. 'a' and 'b' being a show instance is a prerequisite for BinTree a b being a show instance
14:12:19 <merijn> daniell: The nice thing is that you can still put unshowable things into BinTree, you just won't be able to show the result
14:13:00 <daniell> merijn: well, it's not enough to use that, and then use a and b type in a function that Shows them, without putting type constraints in the function definition
14:13:29 <merijn> daniell: You will always have to put that constraint on the function
14:13:34 <merijn> You can't avoid it
14:13:42 <daniell> merijn: Ah, so when I put unShowable things in Bintree, it doesn't derive Show, but when I do, it does.
14:13:53 <merijn> daniell: It always derive show
14:15:05 <merijn> daniell: But "instance (Show a, Show b) => Show (BinTree a b)" says "IF 'a' has an instance of show AND 'b' has an instance of show THEN 'BinTree a b' has an instance of show"
14:15:15 <merijn> daniell: It is, effectively, a polymorphic instance
14:20:27 <roconnor> sinelaw, Elliot-Palmer is when you optimisitically reduce all branches of a case statement simultaneously in hopes that the results are all the same.
14:20:27 <roconnor> I don't know the proper name for this strategy.
14:20:27 <sinelaw> where did you get that name then?
14:20:28 <roconnor> Conal and Luke talk about this sort of thing.
14:20:35 <sinelaw> oh ok.
14:20:52 <sinelaw> what do you mean by "results are all the same"?
14:21:07 <sinelaw> isn't only one of them needed?
14:21:42 <roconnor> you reduce the term under case analysis and all the branches at the same time. ...
14:22:01 <roconnor> if the term reduces to head normal form, you pick the branch and kill the others.
14:22:51 <Haskellfant> If a thread can't handle an exception i want it to throw the exception to the main thread so I can handle it there. Is this already abstracted somewhere or do I need to abstract it myself/pass in the ThreadId of the main threads to all other threads and do this manually
14:22:54 <roconnor> if all the branches terminate first and they all have the same head normal form you suspend the case analysis and return the head of the hnf.
14:23:57 <sinelaw> roconnor, but how likely is that? why would there be a case at all
14:24:05 <Haskellfant> ah forkFinally looks good
14:26:03 <statusfailed> what's the difference between "id :: forall a. a -> a" and "id :: a -> a" ?
14:26:05 <roconnor> the standard example is to define or x y = case x of True -> True; False -> y
14:26:13 <merijn> statusfailed: In haskell? Nothing
14:26:21 <statusfailed> merijn: oh :)
14:26:26 <zipper> I am having a problem with cabal install heppy. The error is: setup: `The program happy is required but it could not be found `
14:26:27 <roconnor> sinelaw, in this example or undefined True = True
14:26:33 <statusfailed> merijn: ... thanks :)
14:26:40 <roconnor> sinelaw, and or True undefined = True
14:26:41 <merijn> statusfailed: All haskell functions have an implicit forall at the left for all unintroduced variables
14:26:44 <shachaf> statusfailed: Well, it depends on the body of id. But probably nothing.
14:27:00 <shachaf> (It only depends on it because of an extension called ScopedTypeVariables.)
14:27:14 <sinelaw> roconnor, ok, I see
14:27:45 <shachaf> Come to think of it, it's pretty strange that the way the type is written influences the behavior of the body.
14:27:57 <joseph07> zipper: make sure that you have installed the happy package and that the executable is on your path
14:27:59 <zipper> Yet I am running cabal install happy and it seems to be installing.
14:28:18 <benmachine> shachaf: is it possible to change the behaviour of code with scoped type variables, or can you only fix it/break it?
14:28:21 <zipper> joseph07: All I did was run cabal install happy.
14:28:44 <benmachine> roconnor: so this is basically like unamb?
14:28:47 <roconnor> statusfailed, id :: forall a. a -> a will make the variable 'a' available when ScopedVariables is enabled.
14:29:03 <shachaf> benmachine: It's possible to change the code. I had an example once.
14:29:13 <shachaf> mauke_: Maybe you have it in your extension-detecting file?
14:29:20 <benmachine> shachaf: fair enough, that doesn't surprise me so much
14:29:21 <joseph07> zipper: Did you succeed in installing happy?
14:29:23 <roconnor> benmachine, but built into the core semantics of the language. ... if only I understood denotational semantics better.
14:29:36 <zipper> joseph07: No, that was the error it gave me.
14:29:42 <shachaf> benmachine: There's one or two places where type variables become scoped without forall.
14:29:59 <benmachine> shachaf: yeah, class or instance declarations I think? it's a bit unfortunate
14:30:04 <shachaf> Right.
14:30:13 <mauke_> shachaf, benmachine: https://github.com/mauke/poly.poly/blob/master/poly.poly
14:30:34 <joseph07> zipper: Can you pastebin the command you issued and the output?
14:31:31 <benmachine> mauke_: hah, nice
14:32:19 <sinelaw> disturbing
14:32:25 <sinelaw> ;)
14:32:35 <conal> roconnor: the branch results needn't be the same. their greatest lower bound is a lower bound for the result of the laxer case/conditional.
14:32:57 <sinelaw> I am a phrase in English.
14:33:09 <conal> ... which was Luke's insight, iirc.
14:34:10 <roconnor> conal, I was playing a little loose with my description.  What I intend is that if all branches result in the same constructor then the case analysis is suspended and that constructor is exposed (via a commuting transform).  The case analysis would resume if it is demanded.
14:34:39 <conal> roconnor: yeah. that sort of thing.
14:35:17 <sinelaw> what if the term doesn't terminate
14:35:44 <roconnor> sinelaw, the term under case analysis?
14:35:46 <monochrom> then you call it a nonterm, because it nonterminates  *duck*
14:35:56 <conal> sinelaw: lub has the right meaning for various forms of bottom, including non-termination.
14:36:29 <conal> Here's the puzzle: http://conal.net/blog/posts/lazier-functional-programming-part-1 .
14:36:34 <roconnor> sinelaw, if the case analysis doesn't terminate and not all branches have the same head constructor, then the whole case statement is non-terminating.
14:36:42 <sinelaw> oh you already gave an example for that. it makes sense for "or", but does it always make sense?
14:36:53 <zipper> joseph07: Ok it just worked. I don't know what changed.
14:37:00 <joseph07> zipper: megic!
14:37:03 <joseph07> zipper: *magic
14:37:16 <zipper> joseph07: Seriously weird
14:37:18 <benmachine> sinelaw: when it doesn't make sense you don't use it, I guess
14:37:25 <sinelaw> I mean if all branches terminate, but no the term under case analysis
14:38:08 <monochrom> sinelaw, is it Haskell, or is it something more ideal?
14:38:18 <sinelaw> it is whatever roconnor says
14:38:27 <flyingfisch> how is haskell pronounced? is the emphasis on the first or last syllable?
14:38:38 <monochrom> first. unlike Pascal :)
14:38:44 <flyingfisch> k thanks
14:38:45 <sinelaw> ok, I see.
14:38:48 <RegEchse> haskEll sounds sooo awkward :D
14:38:49 <flyingfisch> been looking all over
14:38:54 <roconnor> sinelaw, this commuting transformation is a nice property, so I'm fairly sure it makes sense.
14:39:06 <flyingfisch> i kept pronouncing it as haskELL
14:39:16 <flyingfisch> like to rhyme with pascal
14:39:22 <flyingfisch> so thanks
14:39:27 <benmachine> I pronounce it haskle
14:39:35 <dfeuer_> merijn, I guess it just seems like there should be a way to get something akin to OverlappingInstances for type families. I would imagine incoherence could be made non-fatal by allowing a "hidden" associated type that is only exposed to members of the class. Of course, my imagination could be entirely wrong.
14:39:40 <benmachine> but who knows if that is right
14:39:46 <benmachine> other people, presumably
14:39:58 <monochrom> a lot of people pronounce Haskell like Pascal. and their friends, naturally, misunderstand that they want to re-learn Pascal :)
14:40:19 <benmachine> dfeuer_: I have this vague impression that overlappingness with type families is scarier than with functional dependencies, and that's one of the few ways they're differenct
14:40:45 <mitchty> is there a ipa pronunciation guide?
14:40:57 <dfeuer_> Yeah, I'm probably all wrong, benmachine.
14:41:03 <monochrom> but the world is symmetric. there are also a lot people who pronounce Pascal like Haskell :)
14:41:16 <sinelaw> roconnor, so if the case term is non-terminating, when the commuted code evaluates the constructor's parameters then the non-termination will happen
14:41:21 <sinelaw> IIUC
14:41:33 <benmachine> dfeuer_: I cannot overstate the vagueness of my impression :P
14:41:49 <dfeuer_> benmachine, I cannot overstate the probability that I am wrong.
14:41:51 <sinelaw> so the non-termination isn't swept under the rug
14:41:55 <flyingfisch> could someone explain this to me? http://pastebin.com/NUbzXz0u
14:42:06 <benmachine> sinelaw: what's wrong with sweeping nontermination under the rug?
14:42:36 <benmachine> it seems clear to me that roconnor's semantics imply that case undefined of () -> True should be True
14:43:24 <RegEchse> "but the world is symmetric" :D  if that were true, physicists wouldn't search so hard to fand some symmetries :P
14:43:28 <glguy> flyingfisch: Maybe paste the error you got and then ask a question about the part of the erro ryou don't understand?
14:43:28 <RegEchse> monochrom: ^
14:43:30 <sinelaw> benmachine, what about case undefined of True -> Just 1; False -> Just 2
14:43:40 <monochrom> flyingfisch: "length l" is pinned at Int, it is not a general Integral
14:44:00 <benmachine> sinelaw: oh, I see, sure, that would be Just undefined
14:44:02 <roconnor> sinelaw, when/if the commuted code evaluates the constructor's parameters, then the case analysis will resume including evaluating all branches again.  If all branches yeild another constructor that is the same in all branches, another commuting transform is done and the case analysis is suspended again.
14:44:24 <sinelaw> roconnor, nice
14:44:51 <sinelaw> in haskell I assume it first fully evaluates the case term?
14:45:45 <tommd> sinelaw: not fully, no.
14:45:51 <roconnor> sinelaw, in (simplified) haskell, case evaluates the term to head normal form and uses the head constructor to choose a branch.
14:46:16 <sinelaw> aha
14:46:17 <sinelaw> ok
14:46:35 <dfeuer_> flyingfisch, do not try to fix this by using genericLength, unless you have a good reason. If you need length in another form, use fromIntegral . length instead.
14:47:36 <benmachine> roconnor: one thought that occurs is that you might get further if you assume while evaluating the branches that the term matched the pattern
14:47:52 <benmachine> roconnor: e.g. case x of False -> True; True -> x might give True
14:48:30 <roconnor> benmachine, I hadn't considered that.
14:48:52 * hackagebot bake 0.0 - Continuous integration library.  http://hackage.haskell.org/package/bake-0.0 (NeilMitchell)
14:49:02 <benmachine> on the other hand, if there are GADTs involved this might be scary
14:49:15 <benmachine> maybe. might not, not sure
14:55:27 <flyingfisch> dfeuer_: ah ok
14:57:38 <joshkirklin> Is there a type for floating numbers constrained to a certain range?
14:58:42 <monochrom> no
14:59:37 <merijn> monochrom: Huh? I pretty sure I saw something like that, just not in base
14:59:40 <joshkirklin> well alright then
15:00:03 <merijn> Oh, there's even fixed precision in base
15:00:27 <monochrom> but fixed precision is orthogonal to constrained range.
15:00:31 <merijn> True
15:01:03 <merijn> But I'm willing to bet that your interpretation of constrained range is more sophisticated than the average question askwer :)
15:01:18 <merijn> joshkirklin: So what do you want, constrained range or fixed precision...
15:01:40 <joshkirklin> well in this case I'd specifically like to have values in the range 0 to 1.
15:01:51 <joshkirklin> and be typesafe with those values
15:02:18 <joshkirklin> I'm not particularly versed in dependent types so I'm not sure if this stretches into that realm
15:02:28 <monochrom> I have a cunning plan.
15:03:11 <monochrom> the sigmoid function is an isomorphism between R and (0,1).
15:03:53 <joshkirklin> if you're going where I think you're going, that's a neat trick
15:03:54 * hackagebot phantom-state 0.1.0.0 - Phantom State Monad Transformer. Like State Monad, but without values.  http://hackage.haskell.org/package/phantom-state-0.1.0.0 (DanielDiaz)
15:04:01 <monochrom> yes :)
15:04:07 <joshkirklin> although there will obviously be computational overhead
15:10:34 <TheMoonMaster> Anyone know how I can send output to LESS from haskell? Basically just like `echo hi | less` but make the program do it?
15:10:42 <johnw> nice, i've wanted phantom-state before
15:10:59 <amf> with Data.Time, how do i get the UTCTime out of IO ? i naively thought liftIO would magically work
15:11:00 <MP2E> TheMoonMaster: | grabs stdout from the program on the left, so if your program is printing to stdout then it will work as intended
15:11:02 <geekosaur> TheMoonMaster, did you see my comment earlier?
15:11:19 <johnw> amf: you can't get anything out of IO
15:11:29 <johnw> amf: you can only work with the value from within IO
15:11:31 <roconnor> johnw, this paper is great!
15:11:36 <johnw> but, in IO, you can always pass it to a pure function
15:11:38 <johnw> roconnor: nice!
15:11:59 <amf> johnw: well that now clears up the mega confusion i had over IO
15:12:26 <roconnor> also, general recursion sucks.
15:12:35 <pythonnut> @pl \f, x, y -> f(x), f(y)
15:12:35 <lambdabot> (line 1, column 8):
15:12:36 <lambdabot> unexpected "y"
15:12:36 <lambdabot> ambiguous use of a non associative operator
15:12:36 <geekosaur> TheMoonMaster: (h, _, _, _) <- createProcess (proc "less" []) {std_in = CreatePipe}
15:12:45 <geekosaur> then output stuff to h
15:12:54 <geekosaur> (hPutStrLn h whatever)
15:14:10 <pythonnut> @pl \f x y -> f(x) f(y)
15:14:10 <lambdabot> join flip
15:14:18 <TheMoonMaster> Oh, I missed it, sorry.
15:14:21 <TheMoonMaster> I'll try that out, thanks.
15:14:22 <heiz> Hi! I'm trying define something like "instance (CostFunction p, Num (Res p)) => CostFunction (SSE p)" and got error "cannot construct the infinite type". More code https://gist.github.com/arkrost/67fe3b876ec3f2ad8ea5 How can I deal with it?
15:15:12 <pythonnut> @pl \f (x, y) -> (f(x), f(y))
15:15:12 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
15:15:30 <arianvp_> :t _
15:15:32 <lambdabot>     Found hole ‘_’ with type: t
15:15:32 <lambdabot>     Where: ‘t’ is a rigid type variable bound by
15:15:32 <lambdabot>                the inferred type of it :: t at Top level
15:15:36 <arianvp_> yay holes
15:15:52 <pythonnut> @pl \(x, y) -> ((f x), ( fy))
15:15:52 <lambdabot> flip (,) fy . f . fst
15:15:57 <pythonnut> @pl \(x, y) -> ((f x), (fy))
15:15:58 <lambdabot> flip (,) fy . f . fst
15:16:01 <pythonnut> @pl \(x, y) -> ((f x), (f y))
15:16:01 <lambdabot> f *** f
15:16:19 <pythonnut> @pl \(x, y) -> ((f_a_long_function_name x), (f_a_long_function_name y))
15:16:19 <lambdabot> f_a_long_function_name *** f_a_long_function_name
15:17:45 <TheMoonMaster> geekosaur: That doesn't actually show less though, just makes it in the background I assume?
15:18:18 <RegEchse> pythonnut:  let both = join (***),  then  both a_really_long_function_name    (but only if x and y are the same type, i guess)
15:18:19 <geekosaur> it uses whatever your program's stdout is. if that isn't the terminal then you need to do something more involved
15:18:37 <roconnor> johnw, what I am still missing is semantics of values of polymorphic type.
15:18:50 <TheMoonMaster> Right now that's ALL it's doing is creating that and piping some output to the handle
15:19:12 <solidus-river> what libs should i look at if i want to check the feasability of making a streaming service in haskell
15:19:18 <solidus-river> conduit / pipes?
15:19:42 <geekosaur> specifically you need to open the controlling terminal directly (/dev/tty) and then pass that handle as `std_out = UseHandle the_tty` inside the braces
15:20:25 <TheMoonMaster> Hah, that sounds interesting!
15:20:56 <erikd> solidus-river: pretty sure either would be fine. i've used conduit quite extensively.
15:21:17 <pythonnut> RegEchse Thanks!
15:22:52 <Fuuzetsu> It finally happened, I add lens to my project's dependencies without even writing a line of code first ;(
15:23:11 <johnw> roconnor: possible: http://www.diku.dk/~stovring/papers/mscs10.pdf, see page 660 onward
15:24:19 <Kinnison> :-)
15:26:13 <joelteon> petition to replace Prelude with Control.Lens
15:30:22 <johnw> i just learned about &~ in lens, and I'm still kind of blown away by it
15:30:37 <johnw> zoom is also very sexy
15:30:43 <johnw> I think lens is the best way of dealing with State
15:31:06 <Welkin> @info (&~)
15:31:06 <lambdabot> (&~)
15:31:12 <Welkin> :t (&~)
15:31:13 <lambdabot> s -> State s a -> s
15:34:00 <stefan_1> hello, doing some newbie problems, I was wondering if someone could take a look at this and give me feedback on how things could be done more idiomatically? http://lpaste.net/111495
15:34:11 <johnw> it lets you treat a value as if it were in a State so that you can apply operators like .=
15:34:45 <joelteon> example
15:36:08 <fread2282> joelteon: petition to put lens in the HP
15:36:33 <obb> is there a way to export all my bindings from ghci into a file?
15:36:46 <Welkin> fread2282: cabal install lens
15:37:55 <Welkin> obb: I've never thought of doing that
15:38:07 <Welkin> I have no idea
15:38:09 <josephle> stefan_1: I think your code is fine. Readability is what's most important
15:38:24 <systemfault> :/ From my noob perspective... Lenses look like they were written by a Perl addict.
15:38:34 <Welkin> but it is better to write code longer than a couple lines in a file and load it into ghci
15:38:52 <obb> unfortunately can't scroll because i have generated too much output :D
15:39:19 <Welkin> use the up arrow to go back to previous input
15:39:21 <obb> and browsing through the history is too tiresome
15:39:39 <Welkin> hm, would bash store it in the bach history?
15:39:41 <Welkin> bash*
15:39:47 <stefan_1> josephle, cool thanks for having a look
15:39:54 <josephle> bash_history has a line limit
15:39:56 <Welkin> or does it ignore it because it is inside a running process?
15:40:08 <obb> it is ignored afaik
15:40:28 <hexagoxel> ghci has persistent history, too
15:40:38 <hexagoxel> don't ask me where :D
15:40:48 <josephle> stefan_1: you might want to flush the stdout buffer at the beginning of promptFor, but that's just nitpicky :)
15:41:00 <obb> yeah i made a list with all the days in a century. pretty sure, that this filled the buffer
15:41:58 <hexagoxel> history does not contain output..
15:42:37 <hexagoxel> ah, it is ~/.ghc/ghci_history
15:43:23 <merijn> obb: I would generally recommend just writing code in a file and loading the file into ghci
15:45:01 <obb> yes i'll do that from now on
15:45:10 <obb> not so important anyway
15:45:48 <obb> would just be nice to look at my entire code. i was surprised how easy some things are in haskell
15:47:06 <monochrom> entering code at the ghci prompt is nice when you don't want to save it. :)
15:50:18 <hiptobecubic> can it not dump history to a file or something?
15:51:27 <monochrom> it already dumps all history to the same file behind your back :)
15:51:30 <solidus-river> what networking libs would you guys recommend for persistant socket / websocket based connections
15:52:26 <monochrom> but "all history" contains too much stuff
15:54:37 <jayunit100> can i define a list type, in haskell, such that the list type always has a multiple of 3 elements?
15:55:46 <joseph07> jayunit100: You could do type List3 a = [(a, a, a)]
15:58:04 <joelteon> data TripleList a = TripleCons a a a (TripleList a) | Nil
15:58:07 <moriarty> nerds galore
15:58:30 <joelteon> you're the one on freenode
15:58:55 <moriarty> joelteon, a typical haskell bastard - http://math.sfsu.edu/beck/images/math_text.jpg
15:59:22 <joelteon> yep
15:59:30 <MP2E> hahah
16:06:21 <AshyIsMe> is this public? https://www.fpcomplete.com/user/AaronAsh/chess-board
16:06:35 <AshyIsMe> i can't see where to set a project sharing permissions on fpcomplete
16:07:31 <Hijiri> well I can see the project
16:07:39 <AshyIsMe> ah cool
16:11:55 <NemesisD> does anyone have a good explanation as to why Parsec doesn't default to backtracking?
16:12:09 <merijn> "efficiency"
16:12:09 <jayunit100> cartset (a,b,c,d,e,f):pts <-- for some reason, i get a parse error there on character 1.
16:12:28 <NemesisD> if i understand the limitations correctly, unless you use "try", if a parser gets halfway through a token and blows up, your input is hosed
16:12:40 <merijn> NemesisD: Also: http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/
16:12:42 <Axman6> jayunit100: needs to be ((...):pts)
16:13:11 <jayunit100> but wouldnt that error be on column 6 ?  Why is it on column 1?
16:13:18 <jayunit100> thanks Axman6 ....
16:13:23 <Axman6> who knows =)
16:14:42 <jayunit100> sounds like a bug in ghc
16:14:43 <jayunit100> :)
16:16:00 <Axman6> well, it's probably that the whole declaration is wrong if parts of its left hand side are wrong
16:25:14 <burp> so is mueval still working with current ghc?
16:27:48 <burp> yea it does :)
16:44:33 <Fuuzetsu> I have [Either b c] and (c → Either b d), what's a nice way to get out [Either b d] ?
16:44:42 <lpaste> srhb pasted “No title” at http://lpaste.net/111499
16:44:59 <Fuuzetsu> @djinn (c -> Either b d) -> [Either b c] -> [Either b d]
16:45:00 <lambdabot> Error: Undefined type []
16:45:00 <srhb> When I try to run fay on a file, I get that error in my sandbox. However, both packages appear to be present. What might the problem be?
16:45:08 <Fuuzetsu> oh, forgot, no recursive data types…
16:45:13 <arianvp_> :(
16:45:26 <Fuuzetsu> bet Agda can tell me!
16:45:54 <Fuuzetsu> :t map fmap
16:45:55 <lambdabot> Functor f => [a -> b] -> [f a -> f b]
16:46:50 <dibblego> Fuuzetsu: traverse or mapM
16:46:53 <arianvp_> Fuuzetsu: if the list has (Left 1) for example
16:47:02 <arianvp_> how would you call   c -> Either b d?
16:47:10 <arianvp_> as we have no way to pass a c
16:47:14 <arianvp_> as only b is given
16:47:22 <Fuuzetsu> ??
16:47:24 <josephle> the fact that you have (Either b c) and (c -> Either b d) smells strongly of bind...
16:47:29 <Fuuzetsu> we're getting c from [Either b c]
16:47:48 <Fuuzetsu> josephle: yes, it does, which is why I'm asking
16:48:42 <simpson> :t mapM
16:48:43 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
16:48:53 <Fuuzetsu> r f ds = map (>>= f) ds
16:48:55 <dibblego> sorry not traverse
16:49:01 <dibblego> map (>>=)
16:49:04 <simpson> :t sequence
16:49:04 <lambdabot> Monad m => [m a] -> m [a]
16:49:14 <josephle> yeah, (map (>>= f)) was my first attempt
16:49:17 <NemesisD> i'm trying to use parsec to parse a simple double: so 3 and 1.3 are both valid. i need to eat digits followed by . or put everything back, but try $ many digit >> char '.'  applies against "1" consumes the 1. whats up with that
16:49:26 <Fuuzetsu> map (>>= f) has the right type but looks fishy
16:49:36 <dibblego> @type map . (>>=)
16:49:37 <lambdabot> Monad m => m a -> [a -> m b] -> [m b]
16:49:57 <Fuuzetsu> @pl f g = map (>>= g)
16:49:57 <lambdabot> f = map . (=<<)
16:49:59 <Fuuzetsu> tsk
16:50:01 <dibblego> flipped
16:50:17 <josephle> heh
16:50:39 <arianvp_> :t f
16:50:40 <lambdabot> FromExpr a => a
16:50:51 <arianvp_> :t map . (=<<)
16:50:52 <lambdabot> Monad m => (a -> m b) -> [m a] -> [m b]
16:51:02 <josephle> Is it fishy because you think there is a simpler solution?
16:51:06 <Fuuzetsu> yes
16:51:24 <arianvp_> map . (=<<) is probably the simplest you'll get
16:51:39 <dibblego> there is no simpler than (map . (=<<)) but it raises the question about manually stacking monads
16:54:02 * hackagebot bsparse 0.0.1 - A simple unassuming parser for bytestring  http://hackage.haskell.org/package/bsparse-0.0.1 (VincentHanquez)
16:54:04 * hackagebot bsparse 0.0.2 - A simple unassuming parser for bytestring  http://hackage.haskell.org/package/bsparse-0.0.2 (VincentHanquez)
16:56:28 <mhall_> hey, i have a newbie question: i wanted to install hlint, and i saw that the apt package was 1.8.53 and cabal had version 1.9.5; i used cabal install but i still don't have access to `hlint` from the command line? do i need to do something else to get it into my bin directory?
16:57:04 <zomg> mhall_: iirc you may have to put ~/.cabal/bin to $PATH
16:57:18 <mhall_> zomg: ok thank you
16:59:02 * hackagebot hoauth2 0.4.2 - hoauth2  http://hackage.haskell.org/package/hoauth2-0.4.2 (HaishengWu)
17:00:47 <johnw> joelteon: still there?
17:01:00 <johnw> joelteon: (1,2) &~ do { _1 .= 3; _2 .= 4 }
17:01:03 <joelteon> johnw: neat
17:01:19 <johnw> yeah, it makes "fly by" mutations really cheap and easy
17:03:03 <Welkin> why would you want to mutate?
17:03:17 <johnw> if you have a value that you need to transform through a series of steps
17:03:22 <johnw> you could do it with function composition, of course
17:03:31 <johnw> this is just a really easy to do it in imperative style
17:03:48 <johnw> especially if lots of disjoint lenses are the points of mutation
17:04:01 <HeladoDeBrownie> Welkin, note that the above example is really not mutation at all, it only somewhat resembles mutation as it might appear in an imperative language
17:04:15 <johnw> I use the word "mutation" to mean: a new value generated from an old one
17:04:23 <johnw> not "changing a memory location in place"
17:04:35 <HeladoDeBrownie> Good clarification
17:25:45 <Fuuzetsu> @hoogle m [a] -> [m a]
17:25:49 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
17:25:50 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
17:25:50 <lambdabot> Data.List inits :: [a] -> [[a]]
17:32:04 <mhall_> hi again, another newbie question: i installed both HTF and test-framework packages in cabal and now I have two Test.Framework modules...I think i want to just try test-framework as it has more downloads on hackage. how can i remove HTF?
17:32:33 <merijn> mhall_: "ghc-pkg unregister HTF"
17:32:56 <merijn> mhall_: That leaves the files installed, but invisible to GHC, you can just manually delete the HTF files if you care that much about disk space
17:33:11 <mhall_> merijn: thanks!
17:48:18 <prinsen> How would you distribute a haskell executable for a certain platform?
17:48:52 <MP2E> Build it statically and distribute it. Though you could do it with dynamic libs too, just take care to bundle the dynamics libs it uses
17:49:11 <MP2E> building with static libraries is easiest because often you can just ship the executable
17:49:37 <prinsen> Can you cross compile with GHC?
17:49:47 <MP2E> yep, i've done it personally and it works pretty well
17:49:51 <MP2E> Template haskell doesn't work yet though
17:50:01 <MP2E> not in cross compilation mode i mean
17:50:41 <prinsen> MP2E: Hmm, my project is 4-5 libraries and a executable. the backbone is a large TH library
17:50:53 <MP2E> you can actually get TH to work with this utility https://github.com/RichiH/git-annex/blob/master/Build/EvilSplicer.hs
17:51:03 <MP2E> as the name implies, it's a bit of an evil hack
17:51:36 <MP2E> it uses the host GHC to generate the splices and then you can patch them in to the source and compile it with the cross compiler
17:51:47 <MP2E> I used it to get lens to work on android and singletons
17:52:03 <prinsen> MP2E: Cross compilation can wait :) Do I compile the libraries as static, or just link them statically?
17:52:24 <josephle> any reason why you shouldn't listen to the comments and use ZeroTH instead? :P
17:52:38 <MP2E> josephle: i couldn't get zeroth to work
17:52:51 <MP2E> tried it first
17:52:58 <josephle> that's a good reason
17:53:34 <josephle> it also seems unmaintained since 2009
17:53:51 <MP2E> prinsen: linking them statically won't work if the libraries weren't built statically. but GHC builds statically by default i think so you should be able to link statically
17:53:56 <MP2E> yep :<
17:53:57 <prinsen> and I do generate LARGE amounts of code
17:54:12 <exio4> wouldn't a virtual machine be easier to setup?
17:54:25 <MP2E> At the moment, certainly
17:54:42 <MP2E> hopefully when cross TH support lands it will be convenient, though
17:54:55 <exio4> (or, from lin to win, wine+ghc?)
17:55:36 <MP2E> at the moment yes, when cross TH support lands it'll be about the same
17:55:47 <MP2E> it's the choice between installing a mingw inside of wine or outside of wine :P
17:57:25 <MP2E> (speaking of which, I should be looking at serializing template-haskell)
17:57:43 <MP2E> or making it serializable rather :V
17:59:07 * hackagebot bsparse 0.0.3 - A simple unassuming parser for bytestring  http://hackage.haskell.org/package/bsparse-0.0.3 (VincentHanquez)
18:07:00 <prinsen> MP2E: Can't find information on cross compilation in GHC (only how to cross-compile the compiler itself)
18:08:54 <mhall_> hi all, so i was trying to wipe all my installed packages and start over, i accidentally deleted the packages.cache file and now ghc-pkg and ghci won't start, does anyone know how to get this file back?
18:09:37 <mhall_> * nevermind i figured it out: ghc-pkg recache
18:10:23 <mhall_> ** maybe not, didn't do anything :(
18:13:59 <mhall_> anyone know what action i need to take to get the package.cache file back?
18:14:07 <mhall_> nothing is working
18:15:42 <mhall_> ** i think i figured it out. need to remove packages.conf.d and use ghc-pkg init packages.conf.d
18:16:31 <heatsink> I don't see a package.cache file in my GHC or cabal directories
18:17:03 <mhall_> it's in .ghc/x86_64-linux-7.6.3/packages.conf.d
18:17:15 <heatsink> Oh, that file
18:17:18 <mhall_> i figured it out
18:17:24 <heatsink> That's the package database
18:18:47 <heatsink> I hope you didn't delete all the packages, though
18:19:08 * hackagebot mangopay 1.9.6 - Bindings to the MangoPay API  http://hackage.haskell.org/package/mangopay-1.9.6 (FelipeLessa)
18:19:48 <heatsink> Some packages are strongly dependent on the compiler, and I don't think they can be installed separately.
18:42:43 <cofibrant> suppose i'd normally define a monad instance like "instance Monad Thing where ...."
18:43:06 <cofibrant> suppose instead of "Thing" i want to allow just generally a "t" where "t" is an instance of some other types
18:43:10 <cofibrant> is there a way to do that?
18:43:24 <cofibrant> I tried "instance Monad (Thingable t) => t where ...
18:43:38 <cofibrant> but it didn't work, because its total nonsense.
18:43:43 <tsani> instance Thingable t => Monad t where
18:43:56 <cofibrant> sweet
18:44:08 <geekosaur> may need FlexibleInstances extension?
18:44:21 <geekosaur> actually that one should be ok, I think
18:44:32 <HeladoDeBrownie> cofibrant, you might run into problems if you also want to have other instances with that same head minus the constraint
18:44:55 <cofibrant> yeah, it's saying "FlexibileInstances" thing
18:45:00 <HeladoDeBrownie> s/minus/but regardless of/
18:45:17 <cofibrant> i have: instance (Thingable t, Fooable t) => Monad t where ...
18:45:44 <HeladoDeBrownie> Sure, and I'm saying you'd run into problems if you also had instance (Barable t) => Monad t where ...
18:45:49 <geekosaur> and yes, instances match before applying a constraint, so if you have some things that have the constraint and some that don't you can run into weird issues.
18:45:50 <HeladoDeBrownie> for instance
18:46:06 <HeladoDeBrownie> Erm, pun not initially intended but awesome in retrospect ;P
18:46:29 <cofibrant> :)
18:48:02 <meoblast001> suppose i have: wipFunction total success_total selected = (success_total - selected) / (success_total - 1)
18:48:15 <meoblast001> i'm getting "Could not deduce (b ~ a)"... i don't understand how
18:48:51 <cofibrant> HeladoDeBrownie: i'm still getting an error - "Constraint is no smaller than the instance head ..."
18:48:59 <HeladoDeBrownie> meoblast001, that function alone compiles fine for me, can you give more context?
18:49:11 <cofibrant> and it wants "UndecidableInstances" to allow that
18:49:14 <HeladoDeBrownie> meoblast001, the complete error message might also help.
18:49:37 <meoblast001> are you guys anti-pastebin people?
18:49:47 <Welkin> no, we are pro lpaste
18:49:55 <Welkin> @lpaste
18:49:55 <lambdabot> Haskell pastebin: http://lpaste.net/
18:50:15 <meoblast001> i'll use gist
18:50:17 <meoblast001> i'm anti-pastebin-without-expiration-date
18:50:35 <meoblast001> https://gist.github.com/meoblast001/9478f97ed66e266a8991
18:50:36 <cofibrant> adding that thing does allow it to work, though ....
18:51:09 <HeladoDeBrownie> cofibrant, I've never run into that particular error and don't understand what it means. Perhaps someone else will know, or searching the web might help.
18:51:23 <cofibrant> HeladoDeBrownie: cheers for your help
18:52:40 <HeladoDeBrownie> cofibrant, by the way, one way to get around instance clashes is to write an instance for a newtype that you defined expressly for that purpose.
18:52:55 <HeladoDeBrownie> That's done, e.g., in Data.Monoid, among other places.
18:53:46 <HeladoDeBrownie> This does imply the minor tradeoff of wrapping any values you want to use the instance with in the newtype constructor.
18:54:19 <cofibrant> HeladoDeBrownie: thanks; i don't understand instances yet well enough to try that; so i'll have to do some reading.
18:58:10 <HeladoDeBrownie> cofibrant, in particular I would suggest looking at Any and All, which are newtypes over Bool, and represent two different valid ways to make Bool a monoid.
18:58:45 <HeladoDeBrownie> While the problem that resolves is not quite the same as your situation, I think the solution may be the same.
18:59:09 <cofibrant> thanks; will check them out!
19:06:58 <etrepum> If any of you all use exercism.io at all, it's a good time to give code reviews in the Haskell track. There's a whole ton of submissions in there today due to some press in Wired.
19:08:19 <cofibrant> etrepum: cool!
19:08:44 <etrepum> I usually do most of it myself, but there's a whole lot more activity than I have time for today :)
19:09:15 <shachaf> You can't do anything without logging in?
19:09:17 <HeladoDeBrownie> Would be nice if I could login with OpenID
19:11:14 <tabemann> what's the most straightforward way to turn a Char into a Word8 when I know that the Char is <= 255 and I don't want to deal with the ByteString as a String or Text because I don't want to commit to any particular encoding
19:11:44 <shachaf> fromIntegral . chr?
19:12:03 <shachaf> By chr I mean ord
19:12:15 <HeladoDeBrownie> I thought String was about as encoding-neutral as possible except that it consists of Chars?
19:12:25 <Welkin> > ord 0x1
19:12:28 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Char)
19:12:28 <lambdabot>    arising from the literal ‘1’
19:12:30 <Welkin> > chr 0x1
19:12:32 <lambdabot>  '\SOH'
19:13:19 <etrepum> shachaf: nope
19:13:23 <Cale> > length "\SOH"
19:13:25 <lambdabot>  1
19:13:27 <Cale> > length "\SO"
19:13:28 <lambdabot>  1
19:13:31 <tabemann> HeladoDeBrownie: I'm writing an IRC client, and I want to be able to theoretically handle other people speaking in UTF-8, latin-1, and other encodings
19:13:33 <Cale> > length "\SO\&H"
19:13:34 <lambdabot>  2
19:14:09 <Welkin> > length '\SOH'
19:14:11 <lambdabot>  Couldn't match expected type ‘[a0]’
19:14:11 <lambdabot>              with actual type ‘GHC.Types.Char’
19:14:15 <Welkin> > length "\SOH"
19:14:17 <lambdabot>  1
19:14:17 <Welkin> > length "\S"
19:14:19 <lambdabot>  <hint>:1:10:
19:14:19 <lambdabot>      lexical error in string/character literal at character 'S'
19:14:29 <shachaf> Please experiment with lambdabot in /msg.
19:14:32 <HeladoDeBrownie> tabemann, sorry, I misread. So is it that you want [Word8] or equivalent?
19:14:36 <tabemann> and right now I'm just trying to chop the incoming IRC protocol data into lines, which I can do at a binary protocol level without committing myself to any given encoding
19:15:04 <Welkin> I'm writing an irc bot too
19:15:08 <Cale> tabemann: You might just want to use ByteString
19:15:10 <tabemann> HeladoDeBrownie: I want Char -> Word8
19:15:10 <HeladoDeBrownie> tabemann, perhaps zooming out would help. I'm not seeing why just ByteStrings wouldn't do the job.
19:15:11 <Welkin> the protocol is... messay
19:15:13 <Welkin> messy*
19:15:18 <tabemann> Cale: I am using ByteString
19:15:50 <HeladoDeBrownie> tabemann, I guess what I'm wondering is where you're getting these Chars from that you want to convert
19:16:00 <Welkin> tabemann: why not use lambdabot's source as a reference?
19:16:02 <HeladoDeBrownie> and if maybe you could ask for something instead that isn't a Char
19:16:09 <Cale> tabemann: In which case, you can split on occurrences of 10 perhaps.
19:16:56 <shachaf> etrepum: They should fix that!
19:17:00 <tabemann> wait, I can convert as UTF-8 anyways
19:17:08 <tabemann> as what I want to convert is just "\r\n"
19:17:31 <tabemann> which is the same in ASCII, UTF-8, and latin-1
19:17:34 <Welkin> convert to what?
19:17:42 <tabemann> a ByteString
19:17:58 <etrepum> shachaf: well, I'm not sure that would make much sense given what the site is about and how it's supposed to work
19:18:11 <Welkin> > ord "\r\n"
19:18:11 <HeladoDeBrownie> tabemann, my network program detects \r\n within a ByteString before decoding. It seemed the best decision to me.
19:18:12 <lambdabot>  Couldn't match expected type ‘GHC.Types.Char’
19:18:12 <lambdabot>              with actual type ‘[GHC.Types.Char]’
19:18:22 <Welkin> > ord '\r'
19:18:24 <lambdabot>  13
19:18:55 <tabemann> HeladoDeBrownie: I want to do the same; I want to chop up the ByteString into smaller ByteStrings based on \r\n before I decode those individual ByteStrings
19:19:13 * hackagebot xml-push 0.0.0.11 - Push XML from/to client to/from server over XMPP or HTTP  http://hackage.haskell.org/package/xml-push-0.0.0.11 (YoshikuniJujo)
19:19:17 <Welkin> break doesn't work?
19:19:20 <Welkin> :t break
19:19:21 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
19:19:27 <HeladoDeBrownie> tabemann, I use Data.ByteString.hGetLine and strip '\r' manually using unsnoc
19:19:40 <tabemann> actually I'm intending on doing my whole protocol decoding in terms of ByteStrings
19:20:39 <tabemann> hmm stripping out \r before breaking with \n would handle malformed IRC protocol data that has only \n for newlines, despite the standard specifically specifying \r\n
19:20:52 <tabemann> but what IRC server is going to put out such malformed data?
19:21:09 <HeladoDeBrownie> tabemann, oh, yeah, my specification is different I suppose. I'm writing a MUD server that handles both \n and \r\n endings.
19:21:35 <nshepperd> there's also BSC.lines
19:21:50 <nshepperd> er, Data.ByteString.Char8.lines
19:22:07 <HeladoDeBrownie> tabemann, actually you don't need to strip out \r first, you can grab up to \n first then check the end for \r
19:22:10 <nshepperd> I wonder if that handles \r\n
19:22:31 <HeladoDeBrownie> hGetLine does that, it grabs up to \n and discards the \n
19:23:25 <Welkin> unsnoc looks like a clean way to do it if you want to check for the existence of \r
19:23:49 <tabemann> BSC.lines breaks on just \n
19:24:42 <HeladoDeBrownie> Too bad there are no ByteString-returning procedures that pay attention to the line mode of the handle
19:24:58 <HeladoDeBrownie> Or if there are, I haven't seen them
19:25:01 <tabemann> that seems like one of the few legitimate cases where one would want to use Data.ByteString.Char8, parsing a text/binary protocol that contains text that needs to be parsed and binary data that can't be decoded
19:25:22 <tabemann> where the text is guaranteed by the protocol standard to be ASCII
19:25:39 <Welkin> irc is usually utf-8
19:25:56 <Welkin> or some form of utf
19:26:10 <HeladoDeBrownie> Well checking for \r\n at ByteString level is as if your specification said to search for two particular arbitrary bytes that happen to have that representation in ASCII
19:26:27 <HeladoDeBrownie> Which I imagine is how the IRC protocol is defined, is it not?
19:26:32 <nshepperd> well, I'm not sure the irc protocol says it has to be ascii but in practice it is
19:26:35 <tabemann> I'm going to be decoding it into UTF-8 in most cases, but I'm going to be doing that at a higher level
19:27:02 <nshepperd> because the spec was written before people cared about distinguishing 'characters' from 'bytes'
19:27:05 <nshepperd> or something
19:27:13 <HeladoDeBrownie> tabemann, do you only need to decode certain parts of messages, like spoken text?
19:27:15 <Welkin> it was written in 1993
19:27:29 <Welkin> well, at least the one I'm looking at
19:27:58 <tabemann> HeladoDeBrownie: the messages are composed of parts that are pure data, despite it being designed to be human-readable, and text that is actually meant for user consumption
19:28:27 <tabemann> I'm intending on only UTF-8 decoding the parts that are actual text meant for the user
19:28:41 <HeladoDeBrownie> Okay, that's basically what I figured
19:28:50 <Welkin> you mean like the start of heading characters that wrap CTCP requests?
19:28:59 <HeladoDeBrownie> So you're essentially doing the decoding after/during parsing
19:29:16 <tabemann> I'm doing the decoding after parsing, yes
19:30:31 <Welkin> this is the best resource I found so far on the irc specification http://www.irchelp.org/irchelp/rfc/ctcpspec.html
19:31:03 <tabemann> I'm reading this: http://tools.ietf.org/html/rfc2812
19:32:12 <tabemann> hmm I could be lazy and just UTF-8 decode the entire messages *before* parsing them, as all the protocol data is ASCII, but that feels lazy
19:32:13 <Welkin> the link I posted has some nice examples in it
19:32:34 <HeladoDeBrownie> tabemann, is that basically indicating it's non-normative?
19:33:00 <tabemann> what do you mean?
19:33:09 <HeladoDeBrownie> "It does not specify an Internet standard of any kind." and the "informative" label
19:33:23 <HeladoDeBrownie> Or am I misinterpreting those?
19:33:45 <HeladoDeBrownie> "informational"*
19:33:48 <tabemann> that probably means that it's not *officially* standardized
19:33:53 <HeladoDeBrownie> Ah
19:34:08 <HeladoDeBrownie> As in, no standards body has sanctioned it?
19:34:49 <tabemann> that it hasn't gone through all the IETF processes for making something an official standard
19:34:56 <HeladoDeBrownie> Got it
19:35:19 <RchrdB> HeladoDeBrownie, almost none of the IETF RFCs are marked as official standards. :|
19:35:21 <HeladoDeBrownie> tabemann, on the topic of decoding before parsing: That sounds like a bad idea. Aren't there non-encoding bytes sent over IRC?
19:36:30 <RchrdB> I think that pretty much the only IETF RFCs which are marked "INTERNET STANDARD" instead of "INFORMATIONAL" are a bunch of trivial things like the TCP echo service.
19:37:00 <tabemann> decoding before parsing would completely disallow special handling of encodings, e.g. treating certain users' messages as latin-1 or various two-byte encodings instead of UTF-8
19:37:32 <tabemann> it would work in practice for most cases, but it feels sloppy
19:38:42 <RchrdB> It sounds like you're both agreeing that parsing IRC messages while it's still in a ByteString is the cleanest approach.
19:39:00 <HeladoDeBrownie> That's about my understanding of the conversation as well.
19:42:42 <tabemann> the only thing with this is that I'm going to be having to use a lot of Data.ByteString.Char8, which I don't really like the idea of
19:44:17 <tabemann> but it will work nonetheless because all of the IRC protocol data is pure ASCII text
19:44:46 <bryanedds> ah, I need my Haskell people's again...
19:44:57 <bryanedds> Can somebody help me write bind - http://lpaste.net/111503
19:45:09 <bryanedds> Frankly, I don't even know what the semantics should be
19:45:10 <HeladoDeBrownie> tabemann, what do you need Data.ByteString.Char8 for?
19:45:36 <HeladoDeBrownie> bryanedds, that looks like an ML dialect
19:45:39 <bryanedds> Also, I doubt I have the types right
19:46:16 <tabemann> HeladoDeBrownie: parsing the IRC protocol data, because the IRC protocol data is still human-readable ASCII
19:46:23 <bryanedds> F#, but noone in F# room seems to know enough to structure generalization
19:46:48 <bryanedds> *about structure generalization
19:47:38 <HeladoDeBrownie> bryanedds, if you want help here, it might be better to phrase your problem in terms of Haskell
19:47:52 <Cale> bryanedds: You may want to begin with join
19:48:14 <bryanedds> Do my types look ok otherwise, Cale?
19:48:20 <bryanedds> (I'll try join)
19:48:25 <Cale> I think so
19:49:35 <bryanedds> It's so hard to proceed with generalization when I'm not even sure my types are right
19:49:59 <bryanedds> Cale, in this case, what would be the semantics of join?
19:50:10 <Cale> Well, that's an interesting question :)
19:50:46 <Cale> So, you're taking an ('a Observable) Observable, and somehow collapsing it to just an ('a Observable)
19:50:59 <shachaf> whoa, join is a confusing name. it has nothing to do with orders
19:51:15 <Cale> shachaf: lol
19:51:40 <shachaf> I was never confused by it until just now, so I suppose it's not that confusing.
19:51:58 <Cale> shachaf: It would be even more confusing if we also had meet
19:51:58 <shachaf> I,I class Functor w => Comonad w where meet :: w a -> w (w a); ...
19:52:04 <Cale> yeah
19:52:04 <Cale> lol
19:53:19 <shachaf> Clearly return should be called bottom and extract should be called top.
19:53:29 <Cale> :D
19:53:46 <bryanedds> I don't... even know where to begin
19:54:03 <shachaf> bryanedds: Sorry, I'm saying unhelpful nonsense.
19:54:35 <bryanedds> no worries, that's what IRC is for :)
19:56:31 <Cale> bryanedds: It may be helpful to see the definitions of the other types involved in these signatures
19:56:41 <Cale> bryanedds: If they're at all necessary anyway
19:57:02 <Cale> Do you suppose this stuff ought to work if World and EventHandling and Address are completely arbitrary?
19:58:03 <bryanedds> just a sec
19:58:21 <Cale> (I've never used F# either, so the notation is a little baroque)
19:58:39 <Cale> (but I think I understand the better part of it)
19:59:24 <bryanedds> http://lpaste.net/111505
19:59:57 <Cale> and World?
20:00:00 <bryanedds> The World is a large record type that contain everything in the game, including subscription maps.
20:00:04 <Cale> ah
20:00:09 <bryanedds> I'll try to post something coherent
20:00:39 <Cale> Can we do something important given an Address and a World?
20:00:54 <Cale> That's a bit vague, I know
20:01:14 <Cale> It's just, hard to understand what you're trying to do
20:01:30 <bryanedds> Yes, all game entities are retreived from the world via an address
20:01:37 <Cale> and in which sense Observer makes sense as a name :)
20:01:58 <Cale> I suppose it makes sense in that there's a function of 'a in there
20:02:05 <Cale> But then there's all this other stuff
20:02:15 <bryanedds> added world
20:02:17 <bryanedds> http://lpaste.net/111505
20:02:18 <Welkin> are you using baroque as a perjorative?
20:02:25 <Welkin> I don't understand why people do that
20:02:43 <Welkin> baroque music and art is incredible
20:03:17 <Makoryu> That's the common use of the term
20:03:28 <Welkin> like nimrod
20:03:36 <Welkin> popular usage changed the meaning
20:03:47 <Cale> Irregularly shaped; whimsical, grotesque, odd. (‘Originally a jeweller's term, soon much extended in sense.’ Brachet.) Applied spec. to a florid style of architectural decoration which arose in Italy in the late Renaissance and became prevalent in Europe during the 18th century. Also absol. as n. and transf. in reference to other arts.
20:04:03 <usr> Anyone know about black holes
20:04:38 <Cale> I'm using it in exactly the first sense that the OED lists :)
20:05:36 <bryanedds> The way events work in my engine is that there is a World.subscribe method that takes an address, a handler, and the current world and produces a new world with that subscription mapped
20:05:57 <bryanedds> when an event happens, any subscriptions are located and invoked, with the world threaded through
20:06:27 <bryanedds> what I'm trying to do is have a more reactive system in addition to the engine's current event system
20:07:04 <bryanedds> similar to F# event combinators (map, filter, etc), but immutable
20:07:39 <Cale> Okay
20:07:51 <Cale> So we have this ('a Observable) Observable
20:07:56 <Welkin> is F# a "hybrid" language like ocaml?
20:08:15 <bryanedds> F# is ocaml derivative
20:08:20 <Welkin> I know
20:08:28 <Welkin> but does it have oop facilities?
20:08:32 <Cale> We can match on that, and we get an Address, say addr, and a function f : ('a Observable) Observer -> World -> World
20:08:46 <bryanedds> yes, based on .Net's
20:09:03 <bryanedds> ok
20:09:23 <Cale> Our goal is to produce an 'a Observable, so we need to produce an appropriate Address, and a function of type 'a Observer -> World -> World
20:09:34 <Cale> Question 1: Should we use the same Address?
20:09:59 <bryanedds> um
20:10:02 <bryanedds> hmm
20:10:51 <bryanedds> so, in this context, the Address is the simulant in the world that can be observed (I think)
20:11:21 <Cale> addr is the only Address value that we have in context
20:11:28 <merijn> How do I get cabal to include .h files in sdist?
20:11:37 <merijn> Should I put them under extra-source-files?
20:11:40 <Cale> so if it's not right, then something is wrong with the design of your types, or we can't get a monad out of this
20:12:23 <bryanedds> well, maybe we don't need addr?
20:12:42 <Cale> Well, we need some Address value
20:12:58 <Cale> because we're trying to construct something of type 'a Observable
20:13:30 <bryanedds> maybe addr maps to Observer.SubscriberAddress?
20:13:41 <Cale> (Or perhaps the definition of Observable shouldn't have an Address in it?)
20:13:54 <bryanedds> that maybe true too
20:13:55 <Cale> Why is that Address there?
20:14:08 <bryanedds> I just kind of stuck it in there because it seemed 'right'
20:14:49 <Cale> okay, if you're not married to the idea, let's discard that field and see where we can get with the rest of ti
20:14:50 <Cale> it*
20:15:06 <bryanedds> I was thinking 'well, how can we observe anything without an address?'
20:15:17 <bryanedds> so I plopped it in there, totally guessing
20:15:31 <bryanedds> not married to any of this :)
20:17:08 <Cale> Well, I don't really know what it means to observe something, but it makes sense that a manner in which we can take one of these contravariant 'a Observer things and modify the World as a consequence of it is at the very least a functor
20:17:21 <Cale> and it's easier to see how to write return for it
20:17:33 <Cale> return will also cause you trouble with that Address field
20:17:44 <Cale> Which address does  return v  have? :)
20:17:58 <bryanedds> no idea :)
20:18:51 <bryanedds> I guess observing in this context means to register a subscription in the world's subscription map
20:19:43 <bryanedds> so when the event happens, the subscriptions can be found and executed, threading the world through the process
20:20:06 <Cale> So, actually, let's think about return : 'a -> 'a Observable  a little more
20:20:18 <bryanedds> ok
20:20:30 <Cale> So, given some value of type 'a
20:20:41 <Cale> we need to produce a function of type 'a Observer -> World -> World
20:21:02 <AshyIsMe> man cabal has issues
20:21:07 <Cale> which means we're given some o : 'a Observer, and w : World
20:21:12 <AshyIsMe> what's the status of fixing the whole sandbox problem?
20:21:14 <Cale> and we need to make a new World
20:21:21 <Welkin> AshyIsMe: what sandbox problem?
20:21:28 <AshyIsMe> seems silly that im recompiling the world for each project
20:21:30 <bryanedds> Do you know what 'a Observer -> World -> World is supposed to mean?
20:21:47 <Cale> I know it's a function type, and I think that's all I need to know for now ;)
20:21:59 <bryanedds> I'm modelling this after contrafunctors, and I just kind of guessed that :)
20:22:28 <Cale> So, okay, inside that o : 'a Observer, we have a useful looking function:  Handler : 'a -> World -> EventHandling * World
20:22:48 <bryanedds> yes
20:22:51 <Cale> and we have an 'a and we have a World
20:23:07 <Cale> So we could apply this to get an EventHandling (which we'll discard), and a new World
20:23:23 <bryanedds> And EventHandling is really simple - it just tells if the event was handled or should keep propagating to other subscribers
20:23:53 <Cale> Awkwardly, there are many other World values hanging around which could also satisfy us
20:24:17 <bryanedds> ya, hopefully some of this can be simplified
20:24:20 <Cale> In particular, we could apply unsubscribe : World -> World, and there's also this World field, which provides another
20:24:56 <Cale> But making use of Handler seems appropriate, since we get to use our value of type 'a
20:25:22 <bryanedds> Handler defines what happens when an event is pblished
20:25:58 <bryanedds> so return will use Handler?
20:26:16 <bryanedds> ah no wait
20:26:21 <Cale> So, return v becomes the Observable which, given some Observer, will modify a world by applying Handler to v
20:26:26 <Cale> Does that sound sensible?
20:26:59 <bryanedds> i don't know - I'll try to understand
20:27:31 <Cale> The goal is to make a computation which in some sense "does nothing but to have v as its result"
20:27:35 <bryanedds> where would the given Observer come from? I don't see it in the signature
20:27:39 <Cale> But "result" is weird here :)
20:27:48 <Cale> because we're inverting control a couple times
20:28:20 <Cale> return : 'a -> 'a Observable
20:28:39 <Cale> and 'a Observable is essentially equal to 'a Observer -> World -> World
20:28:55 <Cale> So, return : 'a -> 'a Observer -> World -> World, more or less
20:29:52 <Cale> I think that extra World field in Observer is going to bite us when we implement join
20:29:54 <Cale> but we'll see
20:30:06 <Cale> also possibly the Address bit
20:30:30 <bryanedds> ya, I'm trying to get my head around the semantics of return here
20:30:49 <bryanedds> I find it nearly impossible to think unless I've already got the semantics
20:30:57 <Cale> This is like the continuation monad, but fucked up with lots of extra stuff that we don't use
20:31:03 <Cale> :)
20:31:35 <bryanedds> I would like to simplify it, but we do need to thread the World through the Handler at least
20:31:53 <bryanedds> and have to have EventHandling come out of the handler as well
20:32:09 <Cale> What does the EventHandling tell us?
20:32:56 <bryanedds> It tells us whether the event has been handled or if it has to propagate to other handlers
20:33:03 <Cale> Let me make a much simplified version of this which might be useless to you, but should be easier to understand
20:33:10 <bryanedds> like in WinForms event handling
20:33:22 <Cale> Actually, can you read Haskell?
20:33:28 <bryanedds> somewhat
20:33:40 <Cale> Yeah, this shouldn't be too bad :)
20:33:47 <bryanedds> I can't write it so good is all :)
20:35:01 <bryanedds> Mind if I throw one more stick in your spokes?
20:35:46 <bryanedds> Here are the publish, subscribe, and unsibscribe definitions - http://lpaste.net/111509
20:36:21 <bryanedds> In this case I only use CustomSub, so the various other event types can be ignored
20:38:54 <dfeuer_> @hoogle Void#
20:38:56 <lambdabot> No results found
20:39:30 <erikd> dfeuer_: i think Void@ is in GHC.Prim
20:39:37 <dfeuer_> Thanks, erikd.
20:40:03 <dfeuer_> But, erikd, you are apparently wrong.
20:40:16 <erikd> won't be the first time :-)
20:48:04 <dfeuer_> erikd, actually, you're right
20:50:18 <NemesisD> has anyone noticed the "within" combinator for quickcheck not working properly?
20:51:38 <NemesisD> i notice the package has a NO_TIMEOUT cpp flag but i would think i would have to explicitly set that
21:00:28 <sgronblo> my cabal install yesod seems to be stuck while trying to download xss-sanitize...
21:02:47 <sgronblo> wtf...
21:05:36 <sgronblo> http://stackoverflow.com/questions/19105108/cabal-install-hangs-installing-yesod-platform seems like same problem as this...
21:08:31 <Fuuzetsu> http://hackage.haskell.org/package/unix-time-0.3.3/docs/Data-UnixTime.html#g:5 why god
21:08:37 <Fuuzetsu> udtMicroSecnods :: !Int32
21:08:46 <sgronblo> getting redirected to this url http://hackage.haskell.org/package/xss-sanitize-0.3.5.4/xss-sanitize-0.3.5.4.tar.gz which seems to not download properly in the browser either...
21:08:47 <Fuuzetsu> Sec*no*ds
21:08:49 <Fuuzetsu> just end me
21:09:50 <sgronblo> is this url broken just for me or?
21:09:52 * monochrom sends SIGTERM to Fuuzetsu
21:11:04 <Fuuzetsu> I'm going to make sure I don't use that name
21:11:08 <Fuuzetsu> I'll just use positional args
21:11:17 <Fuuzetsu> …even the example code uses the typo
21:11:20 <Fuuzetsu> surely something is up here
21:16:38 <sgronblo> should it take more than 5 minutes to build cabal?
21:16:53 <shachaf> It could.
21:16:54 <sgronblo> oh seems like it finally finished
21:17:39 <shachaf> You're having a hard time getting it all down.
21:18:32 <lpaste> Cale pasted “this much works (for bryanedds)” at http://lpaste.net/111511
21:18:41 <Cale> bryanedds: ^^
21:18:49 <bryanedds> awesome, thsnkd@@
21:19:10 <sgronblo> argh, this fucking xss-sanitize...
21:19:20 <bryanedds> ha, trying to type sideways
21:19:24 <Cale> bryanedds: This is really just a convoluted way of writing what is more or less the Cont Change monad
21:19:42 <Cale> though, there is this additional matter of the unsubscribes
21:19:55 <Cale> I haven't thought enough about what monad transformer that would be
21:20:00 <sgronblo> and uh, i just did cabal install cabal-install which mentioned something about installing cabal 1.20.x
21:20:19 <sgronblo> but when i do cabal install --reinstall yesod -v3 it shows that the http client header used is still cabal-install/1.18.x
21:20:29 <merijn> sgronblo: oh :(
21:20:32 <Cale> bryanedds: I also don't know if this code has anything like the semantics you're looking for, I just know that it typechecks :)
21:20:34 <merijn> sgronblo: NEVER do --reinstall
21:20:55 <sgronblo> merijn: jeez, why does the option exist then...
21:20:57 <Cale> bryanedds: If we didn't have the unsubscribes, and the code was parameterised over the type that I called Change
21:21:07 <merijn> sgronblo: For people who know what they're doing
21:21:09 <Cale> bryanedds: then this would be the only code we could possibly write that would typecheck
21:21:15 <merijn> sgronblo: There's a reason it tells you not to use it
21:21:27 <merijn> sgronblo: Anyway, most likely reason for cabal still being the old version is wrong path
21:21:30 <bryanedds> still, it's a great help
21:21:42 <sgronblo> im digging myself deeper into a hole
21:22:00 <merijn> sgronblo: Try "cabal --version", if that says 1.18 your PATH is wrong
21:22:09 <sgronblo> merijn: what should the path be?
21:22:10 <Cale> bryanedds: It makes things quite confusing that Observer and Observable are such similar words
21:22:21 <bryanedds> ya, that's true
21:22:28 <Cale> bryanedds: I tried to use o for Observable variables and obs for Observer variables
21:22:42 <merijn> sgronblo: The path where cabal installs binaries (including itself!) depends on your OS
21:23:04 <merijn> I forgot where it is on linux, but you need to make sure that direcotry is on your PATH before the one with the old cabal-install
21:24:13 <Cale> bryanedds: I am unsure that choosing unsubscribe = unsubscribe obs is the right thing to do in joinObservable
21:24:23 <Cale> bryanedds: We might also choose unsubscribe = id there
21:25:15 <Cale> But it's possible that's the right thing, anyhow
21:25:22 <merijn> sgronblo: .cabal/config should have an entry indicating where it installs
21:25:44 <Cale> bryanedds: I didn't really think about what this code was doing when I wrote it, I just let the types force my hand.
21:26:01 <sgronblo> ok... i apparently must have changed my PATH quite recently and hadnt reread it in this terminal tab...
21:26:30 <sgronblo> so if i already started a failed install --reinstall, should i do an uninstall to get back to stable ground or?
21:27:38 <merijn> sgronblo: Basically, anything that depended on what you reinstalled is potentially broken
21:27:50 <merijn> sgronblo: If that's nothing, you're good, if it's a lot, that's a bummer
21:28:00 <sgronblo> shouldnt be a lot
21:28:29 <merijn> sgronblo: Safest way to stable ground is "ghc-pkg unregister <package>" for whatever you reinstalled. That will make GHC forget about it. If anything depends on it, ghc-pkg will complain
21:28:55 <merijn> sgronblo: unregister anything ghc-pkg complains about until it succesfully unregisters, then install those things again
21:29:15 <carter> merijn: or just rm -rf ~/.ghc :)
21:29:32 <merijn> carter: That's a waste if he only has like 3 packages depending on whatever he reinstalled
21:29:48 <sgronblo> i seem to be back to this problem of this non-starting xss-sanitize package DL
21:29:49 <carter> true, but it always works
21:29:50 <merijn> sgronblo: incidentally, unregister/install is the only sane way to upgrade packages
21:30:07 <sgronblo> why is this all so confusing and difficult?
21:30:26 <carter> sgronblo: because merjin explains it that way :)
21:30:27 <sgronblo> let me talk to the manager
21:30:37 <merijn> sgronblo: Because GHC aggressively inlines across packages, meaning dependencies of X may have a lot of code from X inlined
21:30:47 <carter> yup
21:30:55 <merijn> sgronblo: If you upgrade X then the package using (old) inlined code can't possibly work
21:31:13 <merijn> sgronblo: That's the way GHC fakes doing whole program optimisation
21:31:46 <carter> yup
21:31:48 <sgronblo> ok i see the problem there
21:31:57 <sgronblo> however, any idea why this download seems to be stalling
21:32:03 <carter> ?
21:32:07 <sgronblo> is hackage still broken?
21:32:31 <merijn> sgronblo: --reinstall is basically the same as "replace X anyway and cross your fingers everything depending on X still works"
21:32:46 <sgronblo> i get 301 redirected to this http://hackage.haskell.org/package/xss-sanitize-0.3.5.4/xss-sanitize-0.3.5.4.tar.gz then it just says "Recovering connection to hackage.haskell.org"
21:33:13 <carter> sgronblo: when you do cabal install xss-sanitize-0.3.54 ?
21:34:06 <sgronblo> same thing
21:34:11 <sgronblo> its not downloadable
21:34:21 <carter> huh
21:34:52 <carter> sgronblo: ummmi works for me
21:34:56 <carter> what cli commands are you literally typing
21:34:58 <carter> literalllly
21:35:08 <carter> ~/D/repoScratcher $ cabal get xss-sanitize-0.3.5.4
21:35:09 <carter> Unpacking to xss-sanitize-0.3.5.4/
21:35:09 <carter> worked
21:35:19 <sgronblo> same command as you except i fixed 54 -> 5.4 and ran again with -v3
21:36:17 <sgronblo> the download cant be very large right?
21:36:35 <sgronblo> doing your get command now seems to be stalled for almost 2 minutes
21:36:47 <carter> ohhh
21:36:53 <carter> wait
21:36:54 <carter> no
21:36:56 <carter> literally
21:36:59 <carter> what did you type
21:37:00 <carter> literally
21:37:23 <carter> does "cabal get xss-sanitize-0.3.5.4" do anything?
21:37:39 <sgronblo> no, as i said. its stalled completely for 3 minutes now.
21:37:54 <sgronblo> saying "Downloading xss-sanitize-0.3.5.4..."
21:37:55 <carter> try it in a new terminal tab
21:38:14 <sgronblo> i tried putting the redirected url into the browser earlier and it stalled too
21:38:19 <carter> or wget http://hackage.haskell.org/package/xss-sanitize-0.3.5.4/xss-sanitize-0.3.5.4.tar.gz
21:38:21 <carter> ok
21:38:22 <carter> well
21:38:24 <carter> both work for me
21:38:32 <carter> so i think the problem is your local DNS or proxy or whatever
21:45:00 <dmj`> cabal unpack xss-sanitize?
21:47:44 <carter> good point, what version of cabal is he using
21:50:10 <sgronblo> i just updated by using cabal install cabal-install so im at 1.20.0.3
21:50:52 <dmj`> sgronblo: does cabal unpack xss-sanitize work for you?
21:51:49 <sgronblo> umm doesnt that also have to download the file first?
21:52:01 <sgronblo> it gets stuck in exactly the same place
21:53:00 <monochrom> does it get stuck downloading other packages too? for example acme-php
21:53:06 <sgronblo> i was able to dl a few other packages before cabal install yesod got stuck at the xss-sanitize package
21:53:23 <sgronblo> worked fine
21:53:38 <monochrom> that is going to be very strange.
21:54:20 <monochrom> I have a long-shot theory that some network security software between you and hackage notices the "xss" string and blocks it.
21:55:54 <carter> sgronblo: ooo
21:55:55 <carter> ok
21:55:58 <carter> i know whats going on
21:56:01 <carter> or at least part of it
21:56:23 <monochrom> pray tell
21:56:33 <dmj`> sgronblo: can you git clone it?
21:56:39 <sgronblo> monochrom: that would be a pretty retarded thing to block, but corporate IT security and retardation have never been far from each other.
21:56:41 <carter> yesod only works with stackage
21:56:59 <carter> like, at this point, the yesod stack is only supported with stacked
21:57:13 <carter> use snap if you want things to work sans stacked :)
21:57:19 <carter> *stackage
21:58:28 <sgronblo> dmj`: you mean this repo?
21:58:29 <sgronblo> https://github.com/gregwebs/haskell-xss-sanitize
21:58:56 <sgronblo> yeah no problem there...
21:59:07 <carter> you mean https://github.com/yesodweb/haskell-xss-sanitize ?
21:59:15 <Total_1mmersion> Is it a bad idea to use the Read and Show type classes for parsing and printing a simple language?
21:59:29 <carter> Total_1mmersion: Read and Show are meant for debugging
21:59:40 <carter> not for humans
21:59:43 <Total_1mmersion> that's all I needed, thanks =)
21:59:54 <carter> heh
22:00:14 <sgronblo> carter: yeah that one works too...
22:00:24 <carter> sgronblo: anywyas
22:02:07 <dmj`> Total_1mmersion: depends on how complicated your task is, I use Text.Read (readMaybe) for things all the time, since it's a pure way to perform a read
22:02:22 <dmj`> if its complicated use a parser
22:02:50 <sgronblo> carter: anyways?
22:02:55 <sgronblo> im screwed
22:02:59 <carter> sgronblo: use stackage if you want yesod
22:03:01 <carter> dont use yesod
22:03:07 <dmj`> carter: lol
22:03:37 <carter> sgronblo: so many people starting off with haskell go "ohhhh, yesod seems cool, lets try that.  AHHHH, where'd my legs go"
22:05:03 <carter> i think people like their limbs
22:05:15 <sgronblo> i already invested a lot of time learning yesod so i cant switch at the moment.
22:05:20 <carter> ok
22:05:24 <carter> then use stackage for now
22:05:27 <carter> @google stackage
22:05:28 <lambdabot> http://www.haskell.org/haskellwiki/Stackage
22:05:28 <lambdabot> Title: Stackage - HaskellWiki
22:05:35 <carter> whateer that is
22:07:12 <sgronblo> that page could definitely go into a little more depth
22:07:24 <carter> google around some more
22:07:26 <carter> point being
22:07:30 <carter> if you're doing yesod stack
22:07:33 <carter> use stackage
22:07:48 <carter> snoyman at this point only supports using yesod via stackage afaik
22:07:55 <sgronblo> really???
22:08:16 <sgronblo> i dont remember reading anything about stackage in his yesod book
22:08:23 <carter> his book is old
22:09:01 <merijn> Also, isn't there #yesod too
22:09:03 <merijn> ?
22:09:07 <carter> who knows
22:09:13 <carter> :)
22:09:16 <merijn> Pretty sure people there can give more concrete advice
22:09:18 <carter> yeah
22:09:33 <carter> basically yesod has unique .... design choices in how the build dep works
22:09:46 <carter> that mean that people who use yesod often have ... unique ways of making things work
22:10:01 <sgronblo> yes there is #yesod but its very inactive
22:10:08 <carter> sgronblo: email snoyman for help
22:10:11 <carter> he's very helpful
22:10:14 <carter> and never on irc
22:10:39 <merijn> He's reasonably active on SO too, no?
22:10:55 <merijn> Presumably there'd be a yesod mailing list somewhere...
22:11:21 <carter> who knows
22:11:27 <carter> poiint being
22:11:27 <dmj`> sgronblo: have you considered snap? It's relatively straight forward
22:11:30 <carter> yes
22:11:32 <carter> snap is nice
22:12:11 <carter> sgronblo: i'm planning to try using snap for an application that needs to handle 1-10k request per second per server
22:12:46 <sgronblo> dmj`: i might try it sometime later, but the thing is we have some "implement a web service" event in my company tomorrow and i really wanted to try using haskell and chose yesod because i was able to get the book for cheap off oreilly.
22:12:55 <sgronblo> so now all my eggs are in the yesod basket
22:13:04 <carter> sgronblo: scotty is simpler
22:13:08 <carter> for that
22:13:14 <dmj`> sgronblo: what kind of service?
22:13:17 <carter> http://hackage.haskell.org/package/scotty
22:13:34 <carter> if you just wanna make a dumb rest endpoint, scotty is plenty
22:13:35 <sgronblo> and they are falling to the ground one by one thanks to this weird download problem
22:13:48 <carter> sgronblo: what country / network are you on?
22:13:49 <carter> in
22:13:56 <sgronblo> well can we just stay on the yesod line for now? :)
22:13:57 <carter> are you on some sort of vpn?
22:13:58 <carter> what OS?
22:14:00 <carter> no
22:14:04 <carter> sgronblo: i wanna debug this shit
22:14:07 <carter> give me info :)
22:14:39 <sgronblo> im in japan, no vpn, but some corporate network which i dont really know too many details about how its set up. and sadly mac os x.
22:14:49 <carter> what version of OS X?
22:14:51 <dmj`> sgronblo: here's an example of a haskell service, http://vimeo.com/59109358, video + code included. One day to build a web service is a little aggressive if you ask me :P
22:15:06 <sgronblo> dmj`: aggressive?
22:15:17 <carter> sgronblo: ... i've helped make sure OS X has worked this past year
22:15:21 <sgronblo> carter: an older one, again because of shitty corporate IT practices
22:15:23 <carter> i think its your corp fire wall
22:15:27 <carter> what verion?
22:15:34 <sgronblo> 10.8.5
22:15:37 <carter> ok
22:15:43 <carter> that should be fine with ghc 7.8.3
22:15:47 <carter> what version of xcode?
22:15:48 <dmj`> sgronblo: dependending on how sophisticated you want to be sure
22:15:54 <sgronblo> we have some shitty full disk encryption software that prevents an easy upgrade to mavericks
22:16:09 <carter> whats ghc --version say?
22:16:24 <carter> and whats gcc --version say
22:16:27 <carter> and clang --version say
22:16:31 <carter> and ghc --info
22:16:32 <dhrosa> why are there so many haskell packages on hackage that don;t build
22:16:40 <carter> dhrosa: history
22:16:43 <carter> they be old
22:16:50 <sgronblo> xcode seems to be at 6.0.1 according to app store
22:17:00 <carter> ok
22:17:04 <dhrosa> but, things like hoogle and stuff depend on them
22:17:07 <carter> so pretty recent
22:17:09 <dhrosa> and assumedly someone has used hoogle recently
22:17:10 <carter> dhrosa: on what
22:17:16 <dhrosa> mostly haskell-src-exts
22:17:26 <sgronblo> ghc --version -> The Glorious Glasgow Haskell Compilation System, version 7.8.3, I installed the latest platform quite recently after reading about the improvements made for os x
22:17:28 <carter> dhrosa: ... you mean the docs arent online
22:17:28 <akagr> Hi everyone. Do I need to know the math of it to be proficient in haskell?
22:17:31 <dhrosa> no
22:17:34 <dmj`> akagr: no
22:17:38 <dhrosa> carter: I mean I can't build it with cabal install
22:17:41 <dhrosa> akagr: not at all
22:17:47 <carter> dhrosa: what version?
22:17:48 <carter> old ones?
22:17:49 <shachaf> The math of what?
22:17:49 <sgronblo> clang --version -> Apple LLVM version 5.0 (clang-500.2.79) (based on LLVM 3.3svn)
22:18:00 <carter> i built haskell src exts this afternoon
22:18:02 <carter> sgronblo: ok
22:18:05 <dhrosa> what's weird is that I got it to build on my desktop like a week ago
22:18:10 <carter> sgronblo: ooo
22:18:11 <carter> ok
22:18:12 <dhrosa> but it won't build on my laptop
22:18:17 <akagr> dmj` tutorials keep dropping hints about mathematical things and how they would help
22:18:18 <Cookieman> hi, imperative programmer here. in other languages i usually use loops and assignments and I/O to console. are there any fundamental things i should know before writing I/O console programs in haskell? i'm getting kinda sick of writing functions in GHCI
22:18:21 <carter> sgronblo: you have  cabal install 1.20 right?
22:18:31 <carter> sgronblo: heres what i want you do do
22:18:41 <carter> rm ~/.cabal/config ; cabal update
22:18:47 <merijn> Cookieman: ghci is pretty poor for writing code
22:18:59 <akagr> Cookieman: why don't you write functions in files and then run them or load them in ghci
22:19:00 <merijn> Cookieman: I would recommend writing code in an editor and then loading it into ghci to play with
22:19:25 <Cookieman> merijn: i do run code in an editor and load into ghci
22:19:33 <Cookieman> i mean write*
22:20:01 <sgronblo> carter: cabal --version -> cabal-install version 1.20.0.3
22:20:05 <carter> ok
22:20:06 <merijn> Cookieman: "interact" is a decent simple way to start writing shell-utility like things
22:20:09 <merijn> :t interact
22:20:11 <lambdabot> (String -> String) -> IO ()
22:20:19 <carter> sgronblo: so  do that config wipe + update
22:20:26 <Cookieman> merijn: i'll check into that
22:20:29 <carter> then do rm ~/.ghc
22:20:39 <carter> then do cabal install cabal-install
22:20:47 <carter> sgronblo: i'm going nuclear!
22:20:53 <sgronblo> carter: hehe thanks
22:21:00 <merijn> Is there a cabal thingy for including header files in sdist or should I just list them in extra-source-files?
22:21:00 <carter> sgronblo: does wget work locally for you?
22:21:11 <carter> merijn: forget
22:21:18 <carter> merijn: be conservative
22:21:23 <carter> tis 2am or whatever
22:21:27 <carter> why not both?
22:21:31 <sgronblo> carter: wget for what?
22:21:40 <carter> wget for the hackage urls
22:21:59 <sgronblo> i didnt try wgetting that url yet
22:22:11 <carter> try that
22:22:24 <carter> sgronblo: or the https version of the urls
22:22:35 <carter> there was a recent migration to cloudflare
22:22:41 <carter> so there could be some weird dns issue?
22:22:46 <sgronblo> carter: ok, will try after this nuking is done
22:23:00 <carter> sgronblo: nuking shoudl be pretty fast
22:23:56 <carter> sgronblo: fun fact, you can cabal install URL
22:24:12 <carter> eg cabal install http://hackage.haskell.org/package/vector-0.10.11.0/vector-0.10.11.0.tar.gz
22:24:16 <carter> should work
22:24:29 <carter> try with https to mix things up :)
22:25:30 <Cookieman> btw i am new to this IRC stuff how would i reply to people with that ping noise
22:25:42 <carter> pong?
22:25:50 <sgronblo> ok, so now i finished reinstalling cabal-install. is it ok to retry my yesod install now?
22:26:02 <carter> sgronblo: in a sandbox?
22:26:12 <carter> mkdir sgronProject
22:26:23 <carter> cd sgronProject ; cabal sandbox init ; cabal install yesod
22:26:29 <carter> THOUGH
22:26:37 <carter> i think you should use stackage in said sanbox
22:26:45 <AshyIsMe> Cookieman: you can usually tab complete usernames at the start of a message, depends on your irc client though
22:26:48 <carter> http://www.stackage.org/
22:26:58 <Cookieman> AshyIsMe: ah i got it
22:27:02 <carter> http://www.stackage.org/stackage/364f3589de34912a631c3e57e3839e033b6c5553
22:27:02 <sgronblo> but i am supposed to install yesod first so i can yesod init the site and then create the sandbox?
22:27:07 <Cookieman> AshyIsMe: it's tab for me
22:27:10 <carter> sgronblo: no clue
22:27:18 <carter> i never use yesod  :)
22:29:06 <sgronblo> i feel like this process gives you way too many ways to fuck things up.
22:29:45 <carter> thats why i dont use yesod :)
22:30:00 <carter> sgronblo: i once tried to build git-annex in a sandbox last yar
22:30:09 <carter> the defualt build has a yesod web app
22:30:13 <carter> it conflicaed with itself
22:30:22 <carter> thus my stnace
22:35:27 <sgronblo> https://github.com/fpco/stackage/wiki/Stackage-Server-FAQ#whats-the-difference-between-inclusive-and-exclusive-snapshots can someone explain this. are foo and bar related somewhow. and if they are how could the thing work if bar was left out of the snapshot?
22:35:45 <carter> no clue
22:35:48 <carter> i don't use stackage
22:35:51 <carter> because i don't use yesod :)
22:36:53 <sgronblo> snoyman forgot to explain if my snapshot should be inclusive or exclusive
22:37:12 <carter> email him and ask :)
22:37:22 <carter> he's very repsonsible
22:37:26 <carter> *responsive
22:37:39 <sgronblo> my "cabal config file" means something in my global .cabal dir?
22:37:58 <trap_exit> is fpcomplete basically heroku for haskell ?
22:38:21 <carter> no, i think thats called heroku
22:38:33 <carter> or mebe clever cloud
22:38:36 <carter> or whatever
22:39:32 <sgronblo> these instructions need more proofreading
22:39:42 <Total_1mmersion> What does this line under instances of Parser for attoparsec mean? ~ * a ByteString => IsString (Parser a)
22:39:46 <sgronblo> it says add this to your config, but when you expand the thing it says to replace a line
22:40:07 <Total_1mmersion> I understand that => separates type class restrictions from the type
22:40:18 <Total_1mmersion> But what does the ~ and * mean?
22:40:23 <carter> sgronblo: dont replace
22:40:27 <carter> put in front of
22:41:12 <sgronblo> carter: heh, thats not what the instructions are saying...
22:41:18 <carter> soke
22:41:28 <carter> you can do it this wya
22:41:29 <carter> :)
22:41:45 <carter> only matters if you want exclusive
22:41:52 <carter> well
22:41:53 <carter> idk
22:41:55 <carter> i dont use stackage
22:42:06 <sgronblo> am I the only one who thinks this all seems very messy
22:42:29 <sgronblo> haskell infrastructure needs to be greatly improved
22:42:56 <zRecursive> first discard "lazy" :)
22:42:58 <carter> yesod makes it wors
22:44:28 <zRecursive> I'd like a strict haskell instead of the current lazy one
22:44:53 <sgronblo> just use a lot of ! ?
22:44:56 * Enigmagic would like a pony
22:45:41 <sgronblo> im getting so confused by this now...
22:45:53 <carter> Enigmagic: a mecha pony!
22:45:55 <vanila> zRecursive, ocaml?
22:46:04 <vanila> it lacks a lot of nice features haskell has though
22:46:18 <vanila> typeclasses and higher kinds
22:46:23 <vanila> and gadts
22:46:30 <Enigmagic> and multicore
22:46:31 <Enigmagic> :P
22:46:58 <vanila> there/s also diciple
22:46:58 <zRecursive> vanila: "+" is even not polymorphic in ocaml, i.e. we need "+." for float :)
22:47:00 <vanila> but i dont know how good it is
22:47:11 <AshyIsMe> sgronblo: i just had to recompile the whole world in a sandbox because this small project was likely to break a bunch of packages according to cabal :/
22:47:17 <vanila> zRecursive, to be honest numbers are so painful in haskell I think ocaml does them better
22:47:41 <AshyIsMe> im not sure why you can't have multiple versions of the same library installed at the same time on your machine
22:48:12 <carter> vanila: ... hah
22:48:12 <vanila> oh my friend just informed me that ocaml has GADTs
22:48:54 <zRecursive> really ?
22:49:14 <carter> kinda
22:49:28 * hackagebot unbound-generics 0.0.0.90 - Reimplementation of Unbound using GHC Generics  http://hackage.haskell.org/package/unbound-generics-0.0.0.90 (AlekseyKliger)
22:52:38 <sgronblo> so i am supposed to have ~/.cabal/bin before the haskell platforms cabal bin right?
22:53:15 <carter> sgronblo: ....... how did you install ghc?
22:53:16 <carter> and yes
22:53:18 <carter> definitely
22:53:45 <carter> ghcformacosx.github.io is the nicest zero config  ghc install for OS X
22:53:47 <sgronblo> "In Mac OS X, cabal installs binaries to: $HOME/Library/Haskell/bin."
22:54:13 <sgronblo> this is so fragmented
22:54:17 <Arahael> sgronblo: Haskell setup does seem to be messy, but that, to me, seems to be a combination of being very specific with versions, and a tendency to have packages use other packages in turn.  Maybe the dependency managment mechanism is less mature than other tools.
22:54:26 <Arahael> sgronblo: (I'm also very new to this, and share the same pain)
22:54:41 <sgronblo> my stress level is rising fast
22:55:10 <carter> well
22:55:12 <carter> i'm done
22:55:35 <sgronblo> i just want to do "package-manage-command install yesod", not worry about whether ive installed pure ghc or the platform, or using yesod or stackage
22:55:50 <Arahael> sgronblo: Also cabal seems to be doing too much in my opinion - it's very easy to mix ghc compilers and the like, which just makes things messy.
22:55:58 <carter> the real problem here is yesod
22:56:13 <carter> if you werne't stuck on that, we'd have written a web app already this evening
22:56:16 <Arahael> Ah, the relative maturity of each package also makes a difference, too. :/
22:56:28 <carter> nope
22:56:38 <sgronblo> carter: it worked fine for me at home yesterday though
22:56:48 <carter> thats why yesod is such a pain
22:56:50 <carter> :)
22:57:02 <carter> and why snoyman has stackage
22:57:12 <carter> so that every package will be guaranteed to build together
22:58:42 <sgronblo> i thought that was the job of cabal?
23:00:59 <carter> no
23:01:06 <carter> cabal just finds when version constraints are happy
23:01:13 <carter> yesod has crazy ass constraints
23:01:34 <sgronblo> what exactly does cabals freeze do?
23:01:51 <sgronblo> its not like creating a gem lock file?
23:02:19 <carter> kinda? i dont use it
23:02:27 <carter> freeze is mostly meant to support yesod style dev
23:02:31 <sgronblo> how do you handle dependencies then?
23:02:33 <carter> or end applications
23:02:40 <carter> by writing constraints
23:02:46 <carter> sgronblo: ... i write array computation stuff
23:06:35 <merijn> carter: \o/
23:07:01 <merijn> carter: Systems software sucks, because debugging is a pain. But systems software rocks, because dependencies are so much easier ;)
23:07:22 <carter> merijn: i also just dont use yesod :)
23:07:25 <carter> which helps
23:07:27 <merijn> That too
23:07:41 <carter> yesod is the leading cause of new people rage quitting haskell (i'd do that too)
23:07:46 <carter> :)
23:07:51 <carter> its unfortunate
23:08:10 <merijn> Last week I ran into someone having trouble compiling his app, because cabal died on his dependencies. Turns out it has like 138 (direct, not transitive!) dependencies...
23:09:08 <carter> ew
23:09:12 <carter> sooo a
23:09:18 <merijn> Of course it's then called "cabal hell" when it can't succeed to find a plan with no broken packages
23:09:20 <carter> you can do --max-backjumps=-1
23:09:25 <carter> merijn: no
23:09:31 <carter> cabal hell in the modern form is cute
23:09:37 <carter> aint real cabal hell
23:09:37 <Enigmagic> --better-solver=true
23:09:40 <Enigmagic> :P
23:09:47 <carter> Enigmagic: when we getting that willis
23:09:49 <carter> :)
23:09:57 <Enigmagic> once i retire ;-)
23:09:57 <carter> Enigmagic: got the pm?
23:10:03 <merijn> carter: I know, I keep lecturing people to stop complaining about "cabal hell"
23:10:07 <Enigmagic> yeah, i don't really know much about the mtl issue though
23:10:08 <splintax> carter: you don't use yesod because you don't do web, or because you think there are better alternatives?
23:10:15 <merijn> It's really just "my dependencies suck hell"
23:10:16 <carter> i've used snap and scotty
23:10:22 <carter> mostly the latter
23:10:25 <carter> i mean former
23:10:26 <carter> snap
23:10:43 <splintax> i'm just trying to learn yesod now (after giving up in the past for the reasons you mentioned) and finally having some success
23:10:49 <carter> coool
23:10:52 <merijn> I see people struggling with json and web and then I'm so happy writing parsers for binary protocols, etc. :)
23:11:11 <splintax> it seems really cool but compilation errors are really hard to read because of TH
23:11:18 <merijn> The web is a pile of kludges and ill-considered design >.>
23:11:46 <carter> splintax: ... hence another reason for my suggestions :)
23:11:54 <eyebloom> merijn: Amen
23:12:03 <carter> i'm trying to find that stack over flow whatever post
23:12:07 <carter> where neil ghani or someone
23:12:16 <carter> has this really wonderful rant about referential transparency
23:12:20 <carter> does anyone know what i'm tlkaingabout
23:12:31 <splintax> i would like to hear from anyone who has had experiences switching between haskell web frameworks
23:12:58 <carter> i've used a few
23:13:04 <carter> they're all fine
23:13:09 <sgronblo> i finally got started with yesod recently after intensifying up my haskell studies and reading the yesod book. but today has been super frustrating.
23:13:20 <carter> BUT yesod makes people mad
23:13:41 <carter> because they go "oh, all this docs, wait .... how do i build / install it? where are my pants? are you my mother?"
23:13:56 <sgronblo> im in rage, but im not quitting
23:14:19 <carter> ahhh, uday reddy
23:14:20 <splintax> yeah. the docs are good, but it kinda sucks how most of the code samples are standalone test apps
23:14:34 <splintax> and they don't use the scaffolding that you're encouraged to use by starting a project with 'yesod init'
23:15:19 <sgronblo> i think one big problem seems to be that goal posts are moving too much
23:15:53 <carter> aka : yesod has huge refactors  a lot
23:16:04 <sgronblo> tibbe: you know fredrik jones?
23:21:23 <sgronblo> doesnt cabal allow you to specify a specific set of packages that the package author used for writing the latest version of his package?
23:23:41 <sgronblo> im having trouble figuring out exactly what kind of hell cabal hell is
23:24:17 <AshyIsMe> a recursive one
23:25:09 <dhrosa> a terrible terrible place
23:25:23 <usr> Congratulations India, first country to have a sattelite orbiting mars on it's first attempt, also the cheapest mission ($74m) to date ever conducted for space.
23:26:31 <shachaf> usr: You've been saying a lot of off-topic things in this (and other) channels. This channel is mostly for talking about Haskell.
23:27:00 <usr> I understand, but this is an achievement that should be known around the world.
23:27:05 <shachaf> Ugh, s/[()]//g
23:28:23 <shachaf> It's still quite off-topic for this channel.
23:31:43 <carter> sgronblo: cabal hell hasn't existed for ... like half a decade
23:31:51 <carter> it was a really terrible place
23:32:00 <carter> to get all the libs I wanted to use to install
23:32:13 <carter> i'd have to cabla install the entire transitive dependency graph all at once
23:32:20 <carter> or anything else will break everything else
23:32:28 <carter> beause it'd reinstall all the deps
23:32:55 <vanila> that sounds like what happens when i use cabal :|
23:32:58 <vanila> dontknow what im doing wrong
23:33:04 <sgronblo> to me this is hell though
23:33:39 <carter> yesod requires stackage
23:33:45 <carter> if you're not using stackage, dont use yesdo
23:33:50 <carter> yesDONT :)
23:33:54 <sgronblo> im trying out stackage right now
23:33:56 <carter> ok
23:33:58 <carter> :)
23:34:05 <sgronblo> but i have no idea if i got the setting absolutely right
23:34:31 <sgronblo> but i am still curious about learning more about what the purpose of cabal is
23:34:44 <sgronblo> i always thought it was supposed to be like npm or gem
23:34:59 <carter> yes and no
23:35:04 <carter> also its 230am
23:35:07 <sgronblo> well maybe ive forgotten all the bad moments ive had using them
23:35:08 <carter> so i'm usless
23:35:19 <sgronblo> hehe, maybe bedtime?
23:35:33 <carter> sgronblo: sooo, with npm/gem/pip, a lot of the problems are deferred till runtime
23:35:40 <carter> cabal surfaces them earlier
23:35:41 <carter> :)
23:35:42 <Axman6> Cabal has sort of turned into that, but I don't think it was originally designed as a package manager as such (someone correct me if I'm wrong)
23:36:08 <carter> its not a package manager in the distro sense
23:36:09 <carter> and never will be
23:36:20 <carter> bernalex has a very very articulate way of explaining the diff
23:36:29 <carter> partly because he's a maintainer of a distro package manager
23:36:46 <carter> a language lib installation manager has very very little to do with a distro verision manager
23:38:23 <sgronblo> i dont care how the software is classified i just want things to work and be easy
23:38:52 <carter> sgronblo: yes, but if you dont listen to peoples suggestions about whats easy, do you really want easy? :)
23:39:00 <carter> i'm crashing
23:39:16 <carter> but if someone says "try X instead of Y, if you want the easier  / simpler thing"
23:39:24 <carter> why not ?
23:39:36 <splintax> is the easier/simpler thing stackage?
23:39:40 <carter> nope
23:39:47 <carter> :)
23:39:49 <carter> at least
23:39:50 <carter> not for me
23:39:55 <carter> if it works for you great
23:40:00 <carter> but thats not how i work best :)
23:40:16 <splintax> what is the easier/simpler thing in this context?
23:40:46 <sgronblo> i think carter is saying "dont use yesod"
23:40:50 <carter> :)
23:40:58 <splintax> ah, i thought we were complaining about cabal
23:41:01 <carter> nope
23:41:12 <splintax> i certainly feel like i've ended up in cabal hell many times this year
23:41:12 <carter> you thoguht you were
23:41:15 <carter> nope
23:41:17 <carter> hyou've not
23:41:23 <sgronblo> im too inexperienced with this ecosystem to know where to put the blame
23:41:32 <dhrosa> why is yesod particularly impossible to use with cabal?
23:41:37 <dhrosa> I've never gotten it working before
23:41:37 <sgronblo> and i dont understand why stackage is necessary
23:41:40 <carter> dhrosa: because its designed to mess with you
23:41:43 <carter> idk
23:41:43 <sgronblo> hehe
23:41:55 <joelteon> usually what you have to do to get yesod working is invoke the command "cabal install"
23:42:01 <joelteon> i can understand though
23:42:05 <dhrosa> also why the hell does cabal not install happy
23:42:13 <carter> dhrosa: because you didn't install it
23:42:15 <joelteon> why doesn't cabal install gcc
23:42:22 <carter> or freebsd
23:42:24 <dhrosa> when it's needed as a build tool
23:42:24 <carter> or
23:42:27 <carter> dhrosa: how
23:42:36 <carter> dhrosa: patches welcome
23:42:36 <joelteon> gcc is also needed as a build tool
23:42:39 <carter> yeah
23:42:45 <carter> and why isn't GHC cabalized
23:42:49 <splintax> couldn't cabal be given the ability to specify executables as a dependency?
23:42:53 <carter> yes
23:42:56 <carter> but it doesn't build them
23:43:02 <carter> it jsut says "oh, you need that"
23:43:12 <carter> you dont want to dep on happy the lib
23:43:19 <joelteon> a C preprocessor is also needed as a build tool
23:43:22 <carter> yeah
23:43:29 <joelteon> which one should cabal install
23:43:31 <carter> joelteon: i'll let you take over i'm tired
23:43:36 <joelteon> okay
23:43:48 <Enigmagic> a shitty user experience is also desired when using cabal-install
23:44:04 <Enigmagic> right?
23:44:17 <Enigmagic> at least it's good at something
23:44:28 <joelteon> i wish things would go wrong with cabal for me so i could understand
23:44:56 <splintax> http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml documents a few of the things that have confused and irritated me
23:45:03 <splintax> particularly the shared/dynamic libraries bit
23:45:10 <Enigmagic> i think it's a bit silly to say it shouldn't know about happy when it has hardcoded rules internally to run happy.
23:45:50 <joelteon> it also has rules to run the C compiler, though
23:47:17 <Enigmagic> sure, but better error messages for tools that are available (and primarily installed) through hackage wouldn't hurt anyone
23:47:39 <sgronblo> wow .xhtml
23:48:01 <splintax> i thought the "install alex/happy" error messages were clear enough
23:48:46 <splintax> but it's kind of baffling as a new user why these things are exceptions to the normal rule that cabal can install all your build dependencies automatically, provided that they are on hackage
23:48:52 <sgronblo> my attempt at installing yesod through stackage seems to possibly have stalled
23:50:27 <dhrosa> I'm trying to install ihaskell, and am failing miserable
23:50:39 <dhrosa> one of its random 10000 dependencies doesn't build
23:52:31 <sgronblo> mo dependencies, mo problems
23:52:47 <lostman> dhrosa: it doesn't install into a clean sandbox?
23:53:06 <merijn> splintax: Very simple answer: cabal is not a package manager, it has no way to check whether happy/alex are installed beyond checking whether they're in your path
23:53:20 <eazar001> sgronblo: did you install with minimal GHC install, or with haskell-platform setup?
23:53:32 <sgronblo> haskell-platform
23:53:36 <Enigmagic> merijn: but it does have a way of checking this for libraries..
23:53:38 <merijn> splintax: GHC has a databases of installed libraries (and only libraries, because that's all GHC cares about) and cabal queries that to figure out what's installed
23:53:51 <eazar001> sgronblo: hmmm you might wanna try minimal GHC
23:53:54 <merijn> Enigmagic: It does not, it queries GHC for installed libraries
23:53:55 <eazar001> and sandbox
23:54:10 <sgronblo> eazar001: ugh... id rather not uproot my whole install again
23:54:11 <eazar001> this usually works for me, with no problems
23:54:17 <Enigmagic> merijn: ghc-pkg, sure. it also registers them using ghc-pkg.
23:54:27 <eazar001> sgronblo: you don't have this binary install on your distro?
23:54:39 <merijn> Enigmagic: ghc-pkg doesn't have a way of registering binaries, though
23:54:46 <sgronblo> im using steve jobs distro
23:54:54 <eazar001> sgronblo: someone once criticized me for haskell-platform, and now i realize why
23:54:59 <eazar001> sgronblo: ahhhh, i see
23:55:03 <eazar001> nvm then
23:55:04 <sgronblo> was it carter?
23:55:07 <eazar001> no
23:55:29 <Enigmagic> merijn: it would probably be easier to fix ghc-pkg to register binaries than to talk about it on irc all the time tho ;-)
23:55:31 <eazar001> sgronblo: basically, usually you don't want platform if you're on linux
23:55:36 <merijn> eazar001: It depends, many linux package managers screw up the platform in various ways, cutting it up, etc.
23:55:47 <eazar001> sgronblo: i don't know shit about windows, mac, etc. though
23:55:49 <merijn> eazar001: On windows and OSX platform binaries have always been solid for me
23:56:01 <eazar001> merijn: yea, this makes sense
23:56:08 <sgronblo> well the main problem today that caused me to go on a stackage rampage was that there was one depedency that was impossible to even download
23:56:39 <eazar001> i've heard nightmare stories about yesod
23:56:46 <eazar001> i personally mess with snap, so i don't know
23:57:10 <eazar001> i do know that snoyberg is a really nice, responsive dev thouogh
23:57:13 <eazar001> and he documents well
23:57:25 <eazar001> so those are pluses in his favor
23:57:36 <tdammers> yesod is an impressive piece of work
23:57:52 <tdammers> I'm still not using it, but that's because it's too heavyweight for my taste
23:58:04 <tdammers> I err on the side of simplicity, all else being equal
23:58:13 <eazar001> yea
23:58:18 <sgronblo> yeah, but now id like to know why yesod requires this stackage thing
23:59:29 <tdammers> not sure, it didn't use to
