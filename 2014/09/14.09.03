00:00:04 <c_wraith> "the first really long line of my file is a huge list of language pragmas" :)
00:01:03 <c_wraith> I'm still shocked that I actually turned on MonoLocalBinds today.  First time I've ever had a reason to *enable* that.
00:01:03 <merijn> Man, I was happy with 7.8, because not supporting anything pre-7.8 seemed reasonable, but if I don't find a solution this means once again installing HEAD and not supporting anything pre-7.10 >.>
00:01:31 <merijn> Assuming these supposed GADT fixed land soon-ish
00:01:46 <beckyconning> is there a better way of decision making on a list of Maybes all having Just constructors than making a decision based on the length the result of passing that list to catMaybes?
00:02:31 <Clint> beckyconning: are you trying to decide whether or not there are Nothings in the list?
00:02:33 <merijn> beckyconning: So you wanna short-circuit if one of them is *not* Just?
00:02:34 <c_wraith> beckyconning: sequence ?
00:02:51 <c_wraith> > sequence [Just 1, Just 2, Just 3]
00:02:53 <lambdabot>  Just [1,2,3]
00:02:57 <c_wraith> > sequence [Just 1, Nothing, Just 3]
00:02:59 <lambdabot>  Nothing
00:03:05 <beckyconning> Clint + Merjin yes
00:03:13 <beckyconning> c_wraith: thanks : )
00:03:26 <c_wraith> :t traverse
00:03:27 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
00:03:37 <merijn> :t T.sequence
00:03:37 <c_wraith> I guess that's basically the same.
00:03:38 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
00:04:15 <c_wraith> Well, not the same.  It's a special case.
00:08:30 * hackagebot http-client 0.3.8.2 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.3.8.2 (MichaelSnoyman)
00:08:30 * hackagebot hakaru 0.1.3 - A probabilistic programming embedded DSL  http://hackage.haskell.org/package/hakaru-0.1.3 (z)
00:18:36 <jonseymour> merijn: ok, still don't think I have completely understood, but the explanation about runST getting to choose the type of 's' makes sense. the fact that you can create objects in which 's' is unbound is kind of mysterious. I take it that this is precisely what support for rank-2 types enables?
00:18:54 <lpaste> hiratara pasted “Seems that :sprint of ghci doesn't work well” at http://lpaste.net/110440
00:19:01 <merijn> jonseymour: Oh, that's easy
00:19:24 <merijn> @let data Whoo s a = Whoo a
00:19:27 <lambdabot>  Defined.
00:19:30 <merijn> :t Whoo 'c'
00:19:31 <lambdabot> Whoo s Char
00:19:42 <merijn> jonseymour: unbound 's' :)
00:19:58 <merijn> jonseymour: The 's' in ST is just a phantom type
00:20:00 <Cale> jonseymour: Rank 2 types means that you can write functions whose arguments are *required* to be polymorphic
00:20:31 <Cale> jonseymour: As a simpler example, consider  f rev = (rev [1,2,3], rev "hello")
00:20:33 <merijn> jonseymour: (They're called phantoms because they have no "body", i.e. they don't appear at the value level, only in the types)
00:20:56 <Cale> jonseymour: This won't typecheck using plain Hindley-Milner or Haskell 98 types.
00:21:30 <hiratara> Hi. I always get _ when I run :sprint with my build of ghc-8.3.1 (on ubuntu). Is it a bug of ghc? http://lpaste.net/110440
00:21:55 <Cale> (because [1,2,3] and "hello" will be required to unify with the same type variable, and their types don't match)
00:22:18 <shachaf> hiratara: It sounds like the monomorphism restriction.
00:22:28 <shachaf> What if you use let x :: Int; x = 1 + 2 ?
00:22:33 <Cale> (or the lack thereof)
00:22:34 <jfischoff> What is the easiest way to make a GUI based text editor in Haskell that supports font color?
00:22:50 <merijn> jfischoff: vty-ui
00:23:03 <merijn> oh, wait
00:23:04 <merijn> GUI
00:23:11 <hiratara> shachaf: Oh, I under stand it. Thanks for your advice.
00:23:16 <merijn> I was confused there for a second
00:23:28 <Cale> jonseymour: With a rank-2 type, you can write  f :: (forall a. [a] -> [a]) -> ([Integer], [Char])
00:23:38 <jfischoff> merijn: its a good alternative, I’m not convinced it must be a GUI app
00:23:41 <jonseymour> merijn: ok, I'll play around with the example in ghci to see if I can understand the implications of declarations like that
00:23:45 <shachaf> hiratara: I mean that it sounds like a *lack* of the monomorphism restriction, this time.
00:23:54 <shachaf> Anyway, yes.
00:24:34 <jonseymour> Cale: thank you for the clarifier
00:27:10 <hiratara> shachaf: Yes, I was wrong. It's not a bug of ghc and I could solve my problem by your advice. Thank you :)
00:27:51 <lericson_> what is rank-n type? does it relate to the linear algebra concept of rank?
00:27:55 <jfischoff> merijn: vty-ui doesn’t have sophicated typography. You get 8 styles.
00:28:05 <Cale> lericson_: It doesn't
00:31:04 <c_wraith> lericson_: Rank-N types mean (loosely) that you can pass around explicitly-polymorphic functions.
00:31:13 <augur> lericson_: a rank-n type is a type which allows `forall` to be used wherever you llike
00:31:34 <c_wraith> augur: not wherever you like..  only if the top-level type constructor is (->)
00:31:49 <c_wraith> augur: err, backwards..  Only if it's an argument to (->)
00:31:56 <augur> c_wraith: is that so? hmm
00:32:13 <augur> like you cant have Foo (forall a. a -> a) as a type?
00:32:19 <c_wraith> augur: correct
00:32:23 <augur> how weird!
00:32:34 <c_wraith> augur: that's what the ImpredicativeTypes extension enables.  In theory, if it wasn't broken
00:32:48 <augur> but haskell is already impredicative
00:32:54 <c_wraith> It doesn't really work.
00:33:09 <c_wraith> It half-works, if you use a *ton* of type annotations.
00:33:29 <c_wraith> But even then, you sometimes get mysterious errors about types that appear to be identical not matching
00:34:09 <Cale> lericson_: A type has rank 0 if it has no foralls anywhere in it (i.e. it is monomorphic). A type has rank n+1 if either: 1) it has rank n;  2) it is of the form A -> B where A has rank n and B has rank n+1;  3) it is of the form forall a. A where A has rank n+1
00:36:09 <lericson_> it would really help to learn abstract algebra before looking at haskell, wouldn't it
00:36:09 <c_wraith> augur: there's no real urgency to get ImpredicativeTypes working properly, because you can always simulate it with newtype wrappers around Rank-N functions.
00:36:36 <Cale> For example, Int -> Int has rank 0,  forall a. a -> a has rank 1,  Int -> (forall a. a -> a) also has rank 1, while  (forall a. a -> a) -> Int  has rank 2.
00:36:37 <c_wraith> lericson_: eh.  Not hugely.  It helps for following some discussion, but it isn't necessary to use the language.
00:37:14 <lericson_> c_wraith: for example monomorphism might be nice to know what it means
00:37:24 <Cale> Unless you want to read technical papers on how the type system is implemented, it's not necessary to know exactly what the rank of types are
00:37:28 <c_wraith> lericson_: That's not an algebra term.  :)
00:37:43 <c_wraith> lericson_: that's sort of a back-formation from the much more common term "polymorphic"
00:37:47 <Cale> Basically, higher-rank types are ones which have foralls occurring in argument positions.
00:37:52 <lericson_> c_wraith: it is though, and i bet the computer science name comes from mathematics
00:37:59 <lericson_> oh
00:38:24 <Cale> lericson_: There are two definitions for monomorphism: one from algebra, and one which just means "not polymorphic"
00:38:42 <lericson_> ah
00:38:49 <merijn> lericson_: i.e. "Maybe Int" is monomorphic, "Maybe a" is polymorphic
00:39:00 <c_wraith> lericson_: See? I didn't even know about the algebra term, and it hasn't hurt me. :)
00:39:02 <jfischoff> How old is the term `monomorphic`?
00:39:22 <lericson_> alright, sounds like i have a lot to learn
00:39:48 <c_wraith> GHC provides you with nearly infinite stuff to learn.  Mostly because it adds new stuff as fast as you can learn it. :)
00:39:55 <Cale> The one from algebra means a function (or homomorphism, or arrow in a category) f with the property that for all other functions (etc.) g_1 and g_2, whenever f . g_1 = f . g_2, then we have g_1 = g_2
00:40:00 <Cale> Where . is composition
00:40:25 <Cale> i.e. it's a function you can "cancel on the left"
00:40:28 <lericson_> actually i would be happy to receive comments on an assignment i did, a very simple one. http://pb.lericson.se/p/twEzAb/
00:41:42 <lericson_> Cale: aha i see
00:41:47 <lericson_> Cale: so f is injective
00:42:00 <Cale> lericson_: Yeah, for plain functions, that's what it amounts to
00:42:18 <Cale> lericson_: For other categories, it might not be exactly the same thing as injectivity
00:42:32 <c_wraith> I'm not even sure what injectivity means for other categories
00:42:51 <Cale> c_wraith: They need to be concrete categories :)
00:43:13 <Cale> Injectivity means injectivity of the underlying functions
00:43:16 <mr-> Is a concrete category one with a forgetful functor to Set?
00:43:19 <Cale> yes
00:43:25 <mr-> nice :-)
00:44:44 <lpaste> mbuf pasted “How to write a show function for Date?” at http://lpaste.net/110441
00:45:15 <Cale> mbuf: At the very least, you left out the parens around your Date
00:45:32 <Cale> mbuf: What you wrote amounts to passing 4 arguments to show
00:45:45 <c_wraith> lericson_: the use of Data.Set seems to be mildly overkill, but it's certainly not incorrect.
00:45:50 <mbuf> Cale, sorry where are the parens missing?
00:46:01 <Cale> show (Date 14 September 2014)
00:46:31 <mbuf> Cale, ahh! nice
00:49:59 <c_wraith> lericson_: unrelated to the quality of your work - is it common to get assignments that are clearly imported from english-language instruction that ask you to do things that don't make sense in swedish, like the last segment using the wrong alphabet? :)
00:50:39 <funfunctor> side project https://github.com/victoredwardocallaghan/systemk I started writing a systemd replacement in Haskell for fun should anyone care
00:51:17 <Cale> funfunctor: What is systemd?
00:51:44 <Cale> oh, like init
00:51:57 <Cale> and friends
00:52:02 <funfunctor> Cale: yea, I thought it would be fun to model it as a kind of Monad
00:52:08 <merijn> Cale: The "lets replace the really robust and trusted init code with a complicated 'do everything' monstrosity, because how could *that* possible threaten system stability"-project
00:52:22 <Cale> :D
00:52:50 <funfunctor> well I don't plan to implement anything like systemd's functionality but that is kind of the point :p
00:52:59 <funfunctor> its more of a library
00:53:17 <funfunctor> any way more code soon.. going to spend a couple of hours
00:54:56 <Sgeo> Imagine if, when writing an instance method, if you tried to use that method on a value of a different instance, it tried to use the defintiion yo were defining instead...
00:55:02 <Sgeo> That's what I just hit in Racket >:(
01:00:11 <funfunctor> hmmm I wonder if Applicative Functors could be useful to model some init IO behavior merijn ?
01:04:44 <jle`> um is there a foldr (<|>) empty somewhere
01:04:56 <jle`> @hoogle MonadPlus m => [m a] -> m a
01:04:59 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
01:04:59 <lambdabot> Data.Foldable msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
01:04:59 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
01:05:03 <jle`> oh yeah
01:05:07 <jle`> er
01:05:16 <jle`> @hoogle Alternatve f => [f a] -> f a
01:05:17 <lambdabot> Warning: Unknown class Alternatve
01:05:17 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
01:05:17 <lambdabot> Test.QuickCheck.Gen oneof :: [Gen a] -> Gen a
01:09:00 <Enigmagic> :t asum
01:09:01 <lambdabot>     Not in scope: ‘asum’
01:09:01 <lambdabot>     Perhaps you meant one of these:
01:09:01 <lambdabot>       ‘F.asum’ (imported from Data.Foldable),
01:09:09 <Enigmagic> :t Data.Foldable.asum
01:09:10 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
01:09:17 <Enigmagic> ^^
01:28:33 * hackagebot json-schema 0.6.1.1 - Types and type classes for defining JSON schemas.  http://hackage.haskell.org/package/json-schema-0.6.1.1 (AdamBergmark)
01:49:06 <osa1> liftM5 D arbitrary arbitrary arbitrary arbitrary arbitrary <*> arbitrary <*> arbitrary
01:49:09 <osa1> >.<
02:10:58 <lericson_> how do i write the very comon (f . g)(x) nicely?
02:11:06 <lericson_> can i avoid parentheses?
02:11:30 <Haskellfant> f . g $ x
02:11:33 <MP2E> ^
02:11:34 <AbigailBuccaneer> (f . g)(x), (f . g) x, f (g x), f . g $ x
02:11:42 <lericson_> doesn't seem to work, i'll have to look into it
02:11:43 <AbigailBuccaneer> whatever looks nicest to you
02:12:36 <lericson_> ok so the real case is a little bit more contrived
02:12:44 <lericson_> i have `skyffla s  = everyOther s ++ (skyffla . everyOther . tail) s` but rewriting it to `skyffla s  = everyOther $ s ++ skyffla . everyOther . tail $ s` doesn't help
02:12:46 <yoeight> Hi. I uploaded a package to hackage 4 days ago but it hasn't built my documentation yet
02:13:05 <yoeight> url/reports still reports []
02:13:38 <yoeight> Does Hackage build schedule change lately ?
02:13:45 <lericson_> istm the cons operator : is really annoying :-)
02:13:47 <AbigailBuccaneer> lericson_, ($) binds less tightly than any other operator
02:14:01 <lericson_> alright
02:14:05 <AbigailBuccaneer> so what you've got there is (everyOther) (s  ++ skyffla . everyOther . tail ) (s)
02:14:23 <lericson_> so some parentheses are inevitable?
02:14:41 <AbigailBuccaneer> i mean you could rewrite it with let/in instead of parentheses but that's not a win
02:14:52 <AbigailBuccaneer> unless your paren keys are broken on your keyboard they'd be much prefered here
02:15:04 <lericson_> i just don't want my programs turning into lisp
02:16:03 <lericson_> perhaps this is better for readability `skyffla s  = (everyOther s) ++ (skyffla . everyOther . tail $ s)`
02:16:32 <AbigailBuccaneer> lericson_, you should be able to drop the first set of parens, but otherwise yeah, that's very readable to me
02:16:33 <osfameron> there's nothing wrong with parens.  $ helps you not have *too many*, and can make things a little easier to refactor
02:17:54 <lericson_> what about composing curried functions? i.e. ((f x) . (g y)) z, i would want to write it (f $ x . g $ y) z but i suppose it won't do what i mean (rather it would be (f (x . g y)) z, no?)
02:18:32 <lericson_> (f (x . g)) y?
02:19:13 <AbigailBuccaneer> f x . g y $ z ?
02:19:27 <lericson_> that works?
02:19:30 * lericson_ facepalm
02:19:34 <AbigailBuccaneer> i.. think so? it's early in the morning
02:19:40 <lericson_> it does
02:19:54 <AbigailBuccaneer> f x . g y $ z = (f x . g y) z = ((f x) . (g y)) z
02:20:04 <lericson_> so many parentheses dropped now :D
02:20:16 <bergmark> @pl ((f x) . (g y)) z
02:20:16 <lambdabot> f x (g y z)
02:20:22 <bergmark> boo
02:20:32 <bergmark> @pl ((f x) . (g y))
02:20:32 <lambdabot> f x . g y
02:20:44 <AbigailBuccaneer> bergmark, ...good point
02:21:26 <lericson_> @pl f x . g y $ z
02:21:27 <lambdabot> f x (g y z)
02:21:47 <lericson_> that is a very helpful tol
02:21:49 <lericson_> +o
02:22:59 <bernalex> it's clever too
02:23:20 <bernalex> @pl f a _ = a
02:23:20 <lambdabot> f = const
02:23:27 <bernalex> @pl f _ b = b
02:23:27 <lambdabot> f = const id
02:23:29 <bernalex> etc :-]
02:24:45 <lericson_> :t (.)
02:24:47 <lambdabot> (b -> c) -> (a -> b) -> a -> c
02:25:02 <AbigailBuccaneer> :t (fmap fmap fmap fmap fmap)
02:25:03 <lambdabot> Functor f => (a1 -> b) -> (a -> a1) -> f a -> f b
02:28:11 <lericson_> i can see how $ is useful in refactoring
02:28:27 <lericson_> @pl f . g $ x
02:28:27 <lambdabot> f (g x)
02:28:30 <lericson_> @pl f . g   x
02:28:30 <lambdabot> f . g x
02:28:43 <AbigailBuccaneer> :t ($) $ ($)
02:28:43 <lambdabot> (a -> b) -> a -> b
02:29:14 <bernalex> $ is just a monomorphic id where a is (a -> b). :-]
02:31:47 <lericson_> is it possible to write this better?
02:31:48 <lericson_> medellangd s = (fromIntegral $ numChars s)
02:31:48 <lericson_>              / (fromIntegral $ numWords s)
02:32:47 <osfameron> you can do something clever with arrows (iirc) to abstract out the s
02:32:50 <osfameron> but that's pretty clear, no?
02:33:28 <lericson_> it is
02:33:35 <lericson_> it's just very duplicate
02:33:42 * hackagebot cuda 0.6.5.0 - FFI binding to the CUDA interface for programming NVIDIA GPUs  http://hackage.haskell.org/package/cuda-0.6.5.0 (TrevorMcDonell)
02:35:02 <bernalex> you can use ap to get rid of the s but it won't look beautiful
02:35:12 <lericson_> then let's not
02:35:18 <bernalex> ap ((/) . fromIntegral . numChars) (fromIntegral .numWords) -- or something
02:35:58 <bernalex> you could get rid of repeating fromIntegral a few ways I guess. but none that would be more terse than just uh leaving it like it is.
02:36:23 <lericson_> perhaps it would just be better to abstract divFromIntegral a b = (fromIntegral a) / (fromIntegral b)
02:36:40 <bernalex> yep
02:36:42 <lericson_> but that's OCD level stuff right there
02:36:48 <lericson_> surprised haskell doesn't have something like it?
02:36:51 <adimit> is djinn defunct now? It doesn't build with my GHC, because -Wl apparently isn't a valid option (anymore?)
02:37:18 <thebnq> might be able to use ratio somehow
02:37:24 <bernalex> lericson_: let's start by asking, do you need it to be an integral
02:37:33 <lericson_> bernalex: sadly i do, not my decision
02:37:52 <lericson_> it's an assignment for school and there's some automated testing tool
02:38:04 <bernalex> and integral division would be wrong?
02:38:15 <bernalex> i.e. you need integral source numbers and fractional division?
02:38:18 <AbigailBuccaneer> can you ask lambdabot for function definitions given their name?
02:38:18 <lericson_> yes, it needs to do fractions
02:38:25 <bernalex> AbigailBuccaneer: a few
02:38:28 <lericson_> i guess the source functions could be changed
02:38:30 <bernalex> @source id
02:38:30 <lambdabot> Unknown command, try @list
02:38:32 <bernalex> @src id
02:38:32 <lambdabot> id x = x
02:38:35 <AbigailBuccaneer> @src on
02:38:35 <lambdabot> (*) `on` f = \x y -> f x * f y
02:38:45 <AbigailBuccaneer> thaaat's the one
02:39:05 <lericson_> bernalex: but i think of it like this: the number of words in a text *is* an integer, and so is the number of characters.
02:39:19 <lericson_> bernalex: so it would be a little odd to rewrite it as a fractional
02:39:20 <AbigailBuccaneer> ((/) `on` fromIntegral) (numChars s) (numWords s)
02:39:39 <bernalex> I would definitely not use `on` lol
02:39:57 <bernalex> I've warmed up to flip and const after over a year of haskell, but not `on`. :-P
02:40:22 <funfunctor> anyone up for a discussion about how one would model runlevels and systems daemons using pure data structures/primitives.. I need to form a picture
02:40:38 <lericson_> bernalex: off topic regarding flips https://www.youtube.com/watch?v=SngYwMsxJ4U
02:41:21 <lericson_> how does on work? i don't understand what the multiplication will do
02:41:36 <Cale> funfunctor: You might want to take some inspiration from Propellor http://hackage.haskell.org/package/propellor
02:41:40 <funfunctor> I was thinking something like data RunLevel = RunLevel0 | RunLevel1 | .. deriving (Show,Eq,Ord) and then putting that in a stack
02:41:41 <AbigailBuccaneer> lericson_, (*) is a general binary function argument, not a multiplication
02:41:55 <lericson_> right
02:42:02 <AbigailBuccaneer> it could be rewritten as: on g f x y = g (f x) (f y)
02:42:05 <lericson_> general binary function argument, everybody knows that
02:42:09 <lericson_> ;)
02:42:12 <funfunctor> Cale: hmm thanks
02:42:17 <Cale> funfunctor: It's a tool for ensuring that the *rest* of the system configuration is in order :)
02:42:29 <lericson_> AbigailBuccaneer: sounds like what i want tbh
02:42:42 <AbigailBuccaneer> lericson_, it was an argument because it was defined on the left, it's gotta be a binary function because of how it's used on the right. it's general because it's not specifically multiplication ;)
02:43:01 <funfunctor> Cale: not sure what that means exactly yet but i'm looking over it now..
02:44:19 <lericson_> on isn't defined in my ghci, AbigailBuccaneer
02:44:32 <ion> @hoogle on
02:44:34 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
02:44:35 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
02:44:35 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
02:44:37 <AbigailBuccaneer> lericson_, import Data.Function (on)
02:44:53 <AbigailBuccaneer> oh lambdabot can hoogle? i've been hoogling myself like a DARN FOOL
02:45:11 <trap_exit> for 3d graphics, we have OpenGL + modeling specs; for sound synthesis -- is there some mathematical equiv? i.e. if I wanted to create a 3d cat, I open up a 3d modeler and start modeling; how does one synthesize a cat's meow if I wnated to do sound synthesis?
02:45:19 <bernalex> @quote hoogle
02:45:19 <lambdabot> Hoogle says: "Roses are Red, Violets are Blue, Hoogle rocks, Homage to you"
02:45:46 <trap_exit> haskell school of sound = music synthesis, but no meow / woof synthesis afaik
02:46:22 <funfunctor> Cale: yea, well this is not what I am thinking about at the moment.. I just want to think about the pure core first
02:46:47 <Cale> trap_exit: I dunno, that's hard. You might start by recording some sounds and examining their Fourier transforms, and then picking out the most obvious features and trying to describe those.
02:47:03 <trap_exit> Cale: so basically do it in a data driven way
02:47:05 <trap_exit> that makes sense
02:47:11 <trap_exit> maybe I should collete lots of youtube videos
02:47:25 <trap_exit> and train a deep learning neural network for synthesizeing cat meows
02:47:39 <funfunctor> Cale: latter I will lift it though readerT and stateT and then up into the IO monad providing various IO actions that can later be used to change the machine runlevel states
02:47:49 <funfunctor> Cale: if that makes sense?
02:48:13 <funfunctor> Cale: in many ways a page out of XMonad's book
02:49:20 <Mysterious_Light> Is it correct that foldr (flip f) e == foldl f e . reverse?
02:49:44 <Cale> Mysterious_Light: For finite lists.
02:50:06 <Mysterious_Light> Can lambdabot derive such equivalence?
02:50:13 <Cale> no
02:50:24 <Cale> It's always true that foldl f e = foldr (flip f) e . reverse
02:50:41 <Cale> But for example,
02:50:46 <Mysterious_Light> for finite or anyway?
02:50:50 <Cale> In all cases
02:50:54 <Cale> > foldr (:) [] [1..]
02:50:56 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
02:51:01 <bernalex> Mysterious_Light: check out graham hutton's fold paper
02:51:08 <Cale> > foldl (flip (:)) [] . reverse $ [1..]
02:51:12 <lambdabot>  mueval-core: Time limit exceeded
02:51:19 <bernalex> Mysterious_Light: IDR it's name but I probably link it https://secure.plaimi.net/~alexander/haskell.html
02:52:00 <Cale> You can simulate foldl with foldr, but not quite the other way around.
02:53:19 <bernalex> s/it's/its
02:53:40 <Mysterious_Light> thank you, i'll read this paper
02:53:44 * hackagebot tasty-ant-xml 1.0.0.9 - Render tasty output to XML for Jenkins  http://hackage.haskell.org/package/tasty-ant-xml-1.0.0.9 (OliverCharles)
02:56:41 <trap_exit> why would anyone ever used foldl
02:56:44 <trap_exit>  instead of foldl' ?
02:56:59 <trap_exit> I cna't think of a good reason for foldl besides "interview question to see if intervierwee understand laziness"
02:57:14 <Cale> trap_exit: Well, in many cases the difference doesn't matter, because they get optimised to the same thing
02:57:47 <Cale> The original intention of the Prelude was that the compiler should be able to turn foldl into foldl' when that's a reasonable thing to do.
02:57:56 <bernalex> Cale: my exact thoughts. it hardly matters for most programs.
02:57:57 <Cale> But beyond that, reverse is an example
02:58:04 <trap_exit> dumb question: when is it not a reasonable thin gto do?
02:58:36 <Cale> reverse is ever so slightly more efficient with foldl rather than foldl' if you don't need the entire result
02:58:45 * hackagebot protobuf 0.2.0.4 - Google Protocol Buffers via GHC.Generics  http://hackage.haskell.org/package/protobuf-0.2.0.4 (NathanHowell)
02:58:50 <Cale> Well, making certain assumptions.
02:59:04 <bernalex> last uses foldl too
02:59:13 <bernalex> it allows fusion
02:59:30 <AbigailBuccaneer> @src last
02:59:30 <lambdabot> last [x]    = x
02:59:30 <lambdabot> last (_:xs) = last xs
02:59:30 <lambdabot> last []     = undefined
02:59:50 <bernalex> last = foldl (\_ x -> x) (errorEmptyList "last")
03:00:02 <bernalex> the one lambdabot spat out is ifdef USE_REPORT_PRELUDE
03:00:32 <trap_exit> i'm sorry
03:00:40 <trap_exit> in these cases, does foldl equal foldl' performance
03:00:42 <trap_exit> or does foldl beat foldl' ?
03:00:46 <bernalex> depends
03:00:51 <AbigailBuccaneer> @src foldl
03:00:52 <lambdabot> foldl f z []     = z
03:00:52 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
03:00:53 <AbigailBuccaneer> @src foldl'
03:00:53 <lambdabot> foldl' f a []     = a
03:00:53 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
03:01:13 <trap_exit> i'm geniunely curious since, in My.Prelude, I export foldl' but I don't export foldl
03:01:16 <bernalex> that's not foldl lol
03:01:21 <bernalex> foldl should be
03:01:24 <bernalex> foldl k z0 xs = foldr (\(v::a) (fn::b->b) (z::b) -> fn (k z v)) (id :: b -> b) xs z0
03:01:45 <bernalex> which is INLINED
03:02:58 <bernalex> uhm sorry that should be foldl'
03:03:01 <Cale> trap_exit: Let f = flip (:) for brevity and consider  foldl f [] [1,2,3] -> foldl f (f [] 1) [2,3] -> foldl f (f (f [] 1) 2) [3] -> foldl f (f (f (f [] 1) 2) 3) [] -> f (f (f [] 1) 2) 3
03:03:05 <bernalex> oh no it's not
03:03:06 <bernalex> that was foldl
03:03:09 <bernalex> foldl' should be
03:03:12 <bernalex> foldl' k z0 xs = foldr (\(v::a) (fn::b->b) (z::b) -> z `seq` fn (k z v)) (id :: b -> b) xs z0
03:03:15 <Cale> trap_exit: Now, if we only want the first element of the reversed list, say
03:03:26 <Cale> trap_exit: we only need to evaluate a single f, the outermost one
03:03:34 <bernalex> but I gotta go to lunch
03:03:41 <Cale> -> 3 : (f (f [] 1) 2)
03:03:55 <Cale> and we're possibly done here
03:04:21 <Cale> e.g. if we were matching the reversed list against the pattern (x:xs), we'd be done
03:04:52 <Cale> If we used foldl', then we'd have wasted a bunch of work evaluating f [] 1 and f (f [] 1) 2
03:05:52 <Cale> ping timeout, so rude! :D
03:11:28 <trap_exit> is there a way to tell ghc "output for me a single *c file" ?
03:11:40 <trap_exit> I wnat to write my code in haskell, then import it into xcode to be caleld from swift
03:11:41 <Cale> trap_exit: what was the last line you saw from me?
03:12:04 <trap_exit> so I want (1) my ghc code, (2) all libraries I depend on, and (3) the entireity of the ghc runtime as a singl e*.c file to include into my xcode/swift project
03:12:32 <trap_exit> Cale: I don't recall, xcode6-beta + itumes updating ios8 froze my machine
03:12:35 <trap_exit> we were discugging foldl vs foldl'
03:12:46 <trap_exit> you mentioned something about reverse and someone mentioned something about fusion
03:12:46 <Cale> trap_exit: Let f = flip (:) for brevity and consider  foldl f [] [1,2,3] -> foldl f (f [] 1) [2,3] -> foldl f (f (f [] 1) 2) [3] -> foldl f (f (f (f [] 1) 2) 3) [] -> f (f (f [] 1) 2) 3
03:12:56 <Cale> trap_exit: Now, if we only want the first element of the reversed list, say
03:13:00 <Cale> trap_exit: we only need to evaluate a single f, the outermost one
03:13:03 <Cale> -> 3 : (f (f [] 1) 2)
03:13:07 <Cale> and we're possibly done here
03:13:12 <Cale> e.g. if we were matching the reversed list against the pattern (x:xs), we'd be done
03:13:16 <Cale> If we used foldl', then we'd have wasted a bunch of work evaluating f [] 1 and f (f [] 1) 2
03:13:32 <trap_exit> ah
03:13:32 <trap_exit> so foldl may be useful
03:13:40 <Cale> You can imagine cases where f is perhaps more expensive still
03:13:41 <trap_exit> if the output list is being consume lazily ?
03:13:45 <Cale> yes
03:13:50 * hackagebot lens-sop 0.1.0.2 - Computing lenses generically using generics-sop  http://hackage.haskell.org/package/lens-sop-0.1.0.2 (AndresLoeh)
03:13:54 <Cale> Or whatever structure is being output
03:14:14 <trap_exit> alright
03:14:14 <trap_exit> I buy this argument
03:17:06 <Cale> trap_exit: GHC doesn't really compile to C
03:17:47 <trap_exit> Cale: what does GHC compile to?
03:18:11 <Cale> trap_exit: Even with -fvia-C, it compiles to broken C code, which after compiling with GCC, the resulting assembly is mangled. But -fvia-C is deprecated, I don't even know if it's in the new versions of GHC
03:18:22 <Cale> Normally, GHC compiles directly to native code
03:18:28 <Cale> There's also an LLVM backend
03:18:45 <dramforever> Today my math teacher told me that 0 ** 0 does not make sense, just like 1/0
03:18:53 <trap_exit> hmm
03:18:59 <Cale> dramforever: Usually 0^0 is defined to be 1
03:19:05 <dramforever> But at least here python, ruby and haskell gives 1
03:19:07 <trap_exit> so is there -anyway_ beside ghcjs/javascript, to write ipad apps in haskell?
03:19:16 <Cale> dramforever: Moreover, this is required in order for many things to make sense
03:19:17 <trap_exit> dramaforever: 0 ^ 0 or 0 * 0 ?
03:19:21 <dramforever> I don't know if it makes sense
03:19:24 <Cale> 0^0
03:19:36 <dramforever> :t (**)
03:19:37 <lambdabot> Floating a => a -> a -> a
03:19:40 <dramforever> :t (^)
03:19:41 <lambdabot> (Num a, Integral b) => a -> b -> a
03:19:48 <thebnq> exponentiation is weird in general
03:19:51 <Cale> dramforever: Consider, e.g. the series expansion of the exponential function exp(x) = sum over k >= 0 of x^k / k!
03:20:11 <Cale> If 0^0 were undefined, then this formula would be broken at x = 0
03:20:30 <dramforever> That would be a special case, I think...
03:21:02 <Cale> hm?
03:21:09 <dramforever> I'm in China, I don't know if other country has different 0^0's
03:21:09 <Cale> Most power series have this special case
03:21:19 <Cale> Well, they might!
03:21:44 <Cale> But most mathematicians and people who have thought about what 0^0 ought to be defined as come to the conclusion that 0^0 = 1 is the most useful definition.
03:22:09 <Cale> Note also that n^m is in general the number of functions from a set of size m to a set of size n.
03:22:09 <dramforever> Maybe math is weird here in China
03:22:27 <Cale> Highschool teachers often leave 0^0 undefined
03:22:31 <Cale> Everyone else defines it
03:22:45 <dramforever> do universities define it?
03:22:48 <Cale> Typically, yes
03:23:02 <Cale> If not explicitly, then they rely on its definition a whole lot.
03:23:38 <dramforever> Yeah, we all hoped that 0^0 == 1
03:23:51 * hackagebot async 2.0.1.6 - Run IO operations asynchronously and wait for their results  http://hackage.haskell.org/package/async-2.0.1.6 (SimonMarlow)
03:23:53 * hackagebot json-sop 0.1.0.2 - Generics JSON (de)serialization using generics-sop  http://hackage.haskell.org/package/json-sop-0.1.0.2 (AndresLoeh)
03:24:02 <thebnq> this often comes down to the whole exponentiation is not repeated multiplication business
03:24:06 <Cale> If you wish for something to be true in mathematics, you can simply demand that it be true.
03:24:23 <Cale> The worst that will happen is that the notions of true and false will become identified ;)
03:24:55 <dramforever> do when bored: modify Prelude so that 0^0 and 0**0 throws ZeroToThePowerOfZero error, and see what breaks
03:24:59 <Cale> But for things like how a function is defined at a point where it otherwise wouldn't be, that will never create a contradiction, you're allowed to define functions separately at each point.
03:25:03 <trap_exit> so is ghc / ipad imposisble?
03:25:12 <Cale> trap_exit: No?
03:25:20 <tdammers> the Gödel thing, right? you can get a system that is boringly incomplete, interestingly incomplete, or useless
03:25:24 <Cale> trap_exit: You can generate ARM code with GHC, and there's iOS support.
03:25:25 <trap_exit> Cale: how do I use ghc on ipad then?
03:25:41 <dramforever> Cale, like we have sqrt(-1) = undefined before, then we have sqrt(-1) = i?
03:25:47 <Cale> (I think iPad is ARM, isn't it?)
03:26:02 <dramforever> Cale, ARM-ish, I would say
03:26:04 <trap_exit> Cale: ah, I should have googled "ghc ios" rather than "ghc xcode" http://www.haskell.org/haskellwiki/IPhone is helpful
03:26:06 <Cale> dramforever: yeah, you can always extend the domain of a function to include more points if you like
03:26:29 <dramforever> If only it's well accepted
03:26:42 <trap_exit> oh man
03:26:42 <trap_exit> I need to build a cross compiler?
03:27:16 <dramforever> trap_exit: I think xcode mac -> iphone is a cross-though-not-so-cross compiler
03:27:17 <trap_exit> damn it, wtf does ghc output? and how do I intercept at that layer?
03:27:17 <nshepperd> you can extend the domain of a function to anywhere; just remember to prove your theorems again on the new domain ;)
03:27:40 <Cale> trap_exit: things are supposed to be smoother in new (post 7.8?) GHCs
03:27:49 <Cale> I'm not sure exactly in what way...
03:27:51 <trap_exit> i'm on 7.8.3
03:27:56 <dramforever> nshepperd: now we are learning about f(x) = x^0 and g(x) = 1 not being the same function
03:28:01 <MP2E> yeah, cross compiling to ARM is not too bad
03:28:04 <trap_exit> we have agreed on the sale
03:28:07 <trap_exit> we're just still negotiating the price
03:28:11 <MP2E> GHC's cross compilation support is pretty good, albeit missing Template Haskell support
03:28:15 <Cale> dramforever: Of course, they are the same function if you take my definition :)
03:28:36 <zomg> Hah, in my Quora Digest email.. "Do most Haskell users think JavaScript sucks"... What kind of answers does this guy expect to get to that... Of course he'll get "Yeah it sucks"...
03:28:39 <dramforever> Conclusion on the 0^0 problem: "0^0" looks like glasses!
03:28:43 <Cale> dramforever: Well! One could argue that neither of those really defines a function, without first expressing what the domain and codomain ought to be.
03:29:03 <luite_> MP2E: i think that can be fixed in 7.10
03:29:13 <jle`> dramforever: i wouldn't really say "only if it's well-accepted"
03:29:14 <luite_> MP2E: if i have time to port the mechanism ghcjs uses back to ghc
03:29:15 <dramforever> Cale, we default to whatever the expression is defined to accept
03:29:15 <AbigailBuccaneer> dramforever: Well! One could argue that those glasses make you look like a nerd.
03:29:15 <Cale> zomg: It sucks in exactly the same way that assembly language sucks, and the solution to the problem is the same.
03:29:18 <MP2E> luite_: I would love to see that fixed :)
03:29:24 <jle`> dramforever: you can extend anything to anything if you want
03:29:34 <trap_exit> MP2E: can I pm you ?
03:29:35 <jle`> dramforever: invent new points ad-hoc, even
03:29:42 <MP2E> trap_exit: sure!
03:29:43 <Cale> dramforever: Right, but that doesn't really tell you the codomain either
03:29:44 <jle`> dramforever: how useful it is...?  that's a different story :P
03:30:07 <nshepperd> > let 0^0 = 5 in 0^0
03:30:07 <Cale> dramforever: Which you'll probably just take to be R regardless.
03:30:09 <lambdabot>  5
03:30:18 <zomg> Cale: I find it funny how people go on massive rants about it in the answers as if a language designed for a completely different purpose than haskell could somehow not have certain issues if considered from the perspective of it not being same as haskell :D
03:30:26 <dramforever> nshepperd: you are overriding (^)
03:30:29 <jle`> dramforever: invent your own abstractions, don't let anybody tell you what is accepted or what is not in terms of what abstractions and things you can invent.  the judge at the end is how useful these new things you invent actaully are
03:30:36 <luite_> MP2E: would you be interested in helping?
03:30:45 <nshepperd> shadowing (^), but yeah
03:30:52 <dramforever> To all, not in math exams
03:30:59 <MP2E> luite_ : I would, what can I do to help?
03:31:10 <dramforever> by "not" I mean defining 0^0 = 1
03:31:24 <Cale> zomg: Well, I would expect most of the problems to be completely reasonable. A lot of the reasons that Haskell are good still apply if Haskell is used in place of Javascript
03:31:47 <jle`> dramforever: 0^0 can mean whatever you want, they are arbitrary symbols.  if you talk to someone about it, of course, you ahve to agree on what meaning you two are talking about, or on the differences.
03:31:56 <Cale> zomg: and thankfully, you can use Haskell in place of Javascript now, and I even know some people in industry who are doing this :)
03:32:04 <luite_> MP2E: well the implementation is separate from GHC now, it relies on all template-haskell data structures being serializable, so a start would be to make a patched TH package
03:32:08 <Cale> zomg: (GHCJS is a thing)
03:32:43 <jle`> dramforever: if i'm doing math, and 0^0 being defined leads to a consistent framework that ends up being very useful in a wide variety of situations, then at least i can say, before i say any conclusions, "assuming 0^0 is defined as ___, ..."
03:32:52 <dramforever> Conclusion: haskell is not for maths
03:33:13 <Cale> ???
03:33:20 <Cale> lol
03:33:51 <jle`> haskell is pretty good for maths :)
03:33:52 * hackagebot haskell-packages 0.2.4.2 - Haskell suite library for package management and integration with Cabal  http://hackage.haskell.org/package/haskell-packages-0.2.4.2 (RomanCheplyaka)
03:33:58 <zomg> Cale: oh does ghcjs no longer produce a massively oversized runtime?
03:34:12 <jle`> math does not mean following a bunch of arbitrary rules laid down by a government and following them to their conclusion
03:34:18 <MP2E> luite_: Okay, I think I can handle that :)
03:34:20 <dramforever> jle`: incompatible with some parts of high school math
03:34:36 <jle`> well...what do you want to use haskell for?
03:34:44 <nshepperd> high school maths is not good for maths ;]
03:35:05 <dramforever> jle`: programming
03:35:23 <jle`> (**)/(^) are functions and tools given to you to solve the problem at hand.  if they aren't useful, you can always define new ones
04:06:46 <destructaball> hi there, I'm a new user and I'm having quite a bit of trouble installing ghc-mod using cabal, and I can't find a solution online. Is this an appropriate place to ask for help?
04:12:49 <trap_exit> destructaball : have you beenhelped yet?
04:14:36 <destructaball> no I haven't been yet
04:15:02 <destructaball> whenever I try to install it cabal says monad-journal-0.2.3.0 failed during the final install step. The exception was:
04:15:05 <destructaball> /tmp/pkgConf-monad-journal-0.2.312270.0: hGetContents: invalid argument
04:15:37 <destructaball> (invalid byte sequence) (Sorry about all the messages my client messed up a bit), what do you think I should do)
04:19:38 <osa1> can I use CPP to check if base >=4.7 ?
04:29:23 <destructaball> oh don't worry I sorted it I just needed to switch my character encoding to UTF-8 by typing "LANG=GB.utf-8" into bash
04:42:54 <Zeedox> Does anyone here do any GUI programming (on Windows)? I've been trying Haskell out a bit, but the GUI recommendation page is a bit overwhelming. Most have been pretty big frameworks, but I'd just like to try out something small.
04:53:52 <beckyconning> is there a way to do something like sequence when your "Just"s are of different types? i.e. make a decision based on whether any of a collection of Maybe's are Nothing or not.
04:54:16 <tdammers> beckyconning: Maybe monad?
04:55:55 <tdammers> beckyconning: depends on the kind of decision you want though
04:56:58 <beckyconning> tdammers: you're probably right as its just a default value thing. sorry if its a silly question i'm new to haskell. that really helped though : )
04:57:16 <beckyconning> i was wondering off and you've turned me back towards where i came from lol : P
05:02:34 <mr-> For some reason I immediately thought "data Foo = forall a. Foo (Maybe a)", make a list of those and something like "all (\(Foo x) -> isNothing x)" but I don't think that's an answer you should use, beckyconning
05:06:55 <luite_> zomg: depends on what you consider oversized. it's about 60kB minified/compressed in the current version for simple programs, should improve a bit more when the new optimizer is ready
05:08:21 <benmachine> mr-: yeah Foo is basically an overcomplicated boolean :)
05:09:57 <luite_> zomg: i'm mostly aiming for slower growth with bigger programs with more deps
05:11:02 <luite_> zomg: example of a bigger program, the purescript compiler http://hdiff.luite.com/tmp/try-purescript.jsexe/
05:12:56 <l0cust> how are things this morning?
05:13:11 <lericson_> @hoogle group
05:13:13 <lambdabot> Data.List group :: Eq a => [a] -> [[a]]
05:13:13 <lambdabot> Data.ByteString.Lazy group :: ByteString -> [ByteString]
05:13:13 <lambdabot> Data.ByteString.Lazy.Char8 group :: ByteString -> [ByteString]
05:18:01 <zomg> luite_: yeah that's not too bad then
05:32:40 <luite_> zomg: i still wouldn't recommend it without reservations for things like a shop where initial (uncached) render time is of highest importance, but over time it should become more and more usable
05:33:54 <luite_> zomg: parse and startup/jit overhead on a desktop is ~60ms in firefox
05:36:26 <lericson_> !hoogle unionBy
05:36:36 <lericson_> @hoogle unionBy
05:36:39 <lambdabot> Data.List unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
05:50:25 <Philonous> Can I not use pattern guards within a multi-way if?
06:04:15 <SwashBuckla> I get a bug when I try and run this code: http://learnyouahaskell.com/for-a-few-monads-more (logNumber example)
06:04:57 <SwashBuckla> has Control.Monad.Writer changed since LYAH was written?
06:05:23 <Fuuzetsu> it would help if you said what the bug was
06:07:25 <Philonous> SwashBuckla, Yes, Writer is now WriterT Identity
06:08:53 <SwashBuckla> so I can replace all instances of `Writer` with `WriterT Identity`?
06:08:54 <Philonous> SwashBuckla, I think it's was a mistake to use the constructor in the first place. It should probably be (tell ["got Number: " ++ show x] >> return x)
06:09:12 <Philonous> SwashBuckla, You also have to use different constructors
06:09:49 <Philonous> SwashBuckla, Oh, and no, you don't have to replace the type, it's still Writer, but it's not a type alias rather than a data type
06:09:58 <Philonous> it's now*
06:10:19 <SwashBuckla> a type synonym?
06:10:29 <Philonous> Yeah, type Writer = WriterT Identity
06:11:56 <Philonous> Or rather, type WriterT w = WriterT w Identity
06:13:45 <SwashBuckla> logNumber x = (WriterT . Identity) (x, ["Got number: " ++ show x])
06:14:31 <Philonous> logNumber x = tell ["Got number: " ++ show x] >> return x
06:14:56 <SwashBuckla> I've not come across tell, so oddly enough, this seems more tangible
06:15:13 <SwashBuckla> :t tell
06:15:13 <lambdabot> MonadWriter w m => w -> m ()
06:15:18 <Philonous> @source tell
06:15:18 <lambdabot> Unknown command, try @list
06:15:24 <SwashBuckla> @list tell
06:15:24 <lambdabot> tell provides: tell ask messages messages-loud messages? clear-messages auto-reply auto-reply? clear-auto-reply
06:15:54 <amar^> what is the the most concise defn of algebraic data types
06:15:57 <amar^> ?
06:16:30 <Philonous> tell w = WriterT (return ((), w))
06:25:30 <lericson_> i have `data Foo = String (A | B)`, can i have a function that is only defined for two Foos that are both either A or B?
06:25:43 <lericson_> like f (Foo _ A) (Foo _ A) = ...
06:27:34 <Fuuzetsu> That data type does not make sense, can you explain what it's meant to be?
06:28:22 <Fuuzetsu> was it meant to be ‘data Foo = Foo String (Either A B)’?
06:39:21 <L8D> Fuuzetsu: It's a record with a String and an Either
06:39:33 <L8D> What library should I use for a REST API?
06:40:10 <td123> so, I wanted to ask if anyone has a good example of testing code that uses a web service (rest api). I've read some approachs to testing such code. 1. mocking passing in a function which is the actual callout as a param, 2. using typeclasses to define an interface and working with a custom type that defines an instance of that class (which includes all the endpoints)
06:40:33 <nick____> > take 5 [1..]
06:40:35 <lambdabot>  [1,2,3,4,5]
06:40:52 <nick____> @hoogle ZipList
06:40:53 <lambdabot> Control.Applicative ZipList :: [a] -> ZipList a
06:40:54 <lambdabot> Control.Applicative newtype ZipList a
06:40:54 <lambdabot> Control.Applicative getZipList :: ZipList a -> [a]
06:41:16 <nick____>  @unmtl StateT s IO a
06:41:27 <nick____> @unmtl StateT s IO a
06:41:27 <lambdabot> s -> IO (a, s)
06:42:40 <haha_> @unmtl StateT s Maybe a
06:42:40 <lambdabot> s -> Maybe (a, s)
06:42:51 <haha_> @unmtl MaybeT (State s) b
06:42:51 <lambdabot> (State s) (Maybe b)
06:43:08 <haha_> @unmtl MaybeT (State s) a
06:43:09 <lambdabot> (State s) (Maybe a)
06:46:07 <latro`a> @ haha_, lambdabot does take queries
06:48:29 <fds4345> In my program, I'm able to do `let x = (1::Int) / (2::Int)` without a typeerror. `x` is then an int. But I can't do this in ghci. So confused
06:49:07 <fds4345> @unmtl (1::Int) / (2::Int)
06:49:08 <lambdabot> Plugin `unmtl' failed with: DataKinds is not enabled
06:49:20 <fds4345> @unmtl ((1::Int) / (2::Int))
06:49:20 <lambdabot> Plugin `unmtl' failed with: DataKinds is not enabled
06:49:24 <tdammers> fds4345: you need to enable some extension
06:49:26 <L8D> fds4345: How are you usinh "let" in your program?
06:49:26 <benmachine> fds4345: you should not be able to do that unless you've reassigned /
06:49:30 <tdammers> ScopedTypeVariables IIRC
06:50:16 <tac_> fds4345: that shouldn't work even in a full program
06:50:16 <benmachine> tdammers: to be blunt, I doubt that has anything to do with it
06:50:16 <Enigmagic> tdammers: you can do that without scoped type variables
06:50:16 <tdammers> right
06:50:32 <tdammers> wait, yeah, `let` in ghci is magic :D
06:50:36 <benmachine> basically / is only supposed to work on fractional types, Int is not fractional
06:50:43 <L8D> holy shit like 15 people just exploded at this poor guy
06:51:03 <benmachine> it's normal that #haskell gives you three answers to your question
06:51:14 <benmachine> it's slightly unfortunate that in this case there are three mutually contradictory answers
06:51:20 <benmachine> oh well :/
06:51:27 <L8D> I got 0 :O
06:51:34 <benmachine> maybe your question was hard
06:51:45 <benmachine> or you were unlucky
06:51:54 <fds4345> L8D: Ah, it was just me misinterpreting the error. GHC was choosing to show me another class of error before that one so I couldn't see it in the IDE even though it was there.
06:52:04 <fds4345> fromIntegral sorted it
06:52:15 <k00mi> L8D: what was your question?
06:52:15 <L8D> fds4345: good job!
06:52:31 <L8D> k00mi: What library should I use for writing REST APIs behind nginx
06:53:03 <L8D> because my bosses are allowing me to use haskell in our new project.
06:53:42 <Enigmagic> L8D: i like to start with scotty
06:53:44 <L8D> There's Yesod, Snap, Rest and Scotty that I know of,
06:54:03 <L8D> Enigmagic: Yeah, as a node.js express dev it looks very familiar
06:54:56 <k00mi> yep, scotty is quite simple, a good start if you want to get something working quickly
06:55:37 <tdammers> nice thing about scotty is that it's fairly small and doesn't make a lot of assumptions
06:55:59 <L8D> What about DB io?
06:56:16 <L8D> Is there something in specific or should I just use hand-rolled SQL queries
06:56:26 <tdammers> various options
06:56:27 <McManiaC> > id 5
06:56:29 <lambdabot>  5
06:56:39 <tdammers> you can use HDBC and write your own queries
06:56:48 <tdammers> or you can use an abstraction layer like Persistent
06:57:04 <L8D> Thanks
06:57:24 <McManiaC> > let m = Data.Map.empty :: Data.Map Int (Data.Map Int ()) in m & at 5 . _Just . at 2 ?~ ()
06:57:26 <lambdabot>  Not in scope: type constructor or class ‘Data.Map’Not in scope: type constru...
06:57:35 <tdammers> you could even forgo a relational database entirely and use acid-state instead
06:57:36 <McManiaC> > let m = Data.Map.empty :: Data.Map.Map Int (Data.Map.Map Int ()) in m & at 5 . _Just . at 2 ?~ ()
06:57:37 <lambdabot>  Not in scope: type constructor or class ‘Data.Map.Map’Not in scope: type con...
06:57:44 <L8D> I'm using aeson is still the defacto JSON lib for haskell
06:57:59 <McManiaC> meh
06:58:13 <McManiaC> anyway, any tip on how to modify nested maps using lenses?
06:58:25 <McManiaC> at 5 . _Just . at 2 ?~ ... wont do it
06:58:35 <McManiaC> it'll stay empty :(
06:58:49 <k00mi> L8D: you could check out this new servant thing: http://alpmestan.com/posts/2014-07-26-announcing-servant.html
06:59:17 <k00mi> may or may not be good for what you want to do
07:02:14 <k00mi> McManiaC: the _Just will not match
07:02:22 <McManiaC> yeah i figured
07:04:34 <bennofs> McManiaC: is there a difference for your program between a) the outer map not containing the key at all and b) the outer map containing an empty map at the key?
07:05:17 <bennofs> McManiaC: if that difference doesn't matter, you can use at 5 . non Map.empty . at  ?~ ...
07:05:38 <bennofs> > Just 3 ^. non 0
07:05:40 <lambdabot>  3
07:05:46 <bennofs> > Just 3 & non 0 %~ 0
07:05:48 <lambdabot>  No instance for (GHC.Show.Show a0)
07:05:49 <lambdabot>    arising from a use of ‘M545278450682584379124501.show_M5452784506825843791...
07:05:49 <lambdabot>  The type variable ‘a0’ is ambiguous
07:05:49 <lambdabot>  Note: there are several potential instances:
07:05:49 <lambdabot>    instance [safe] GHC.Show.Show
07:05:51 <bennofs> > Just 3 & non 0 .~ 0
07:05:53 <lambdabot>  Nothing
07:07:26 <bennofs> > Nothing ^. non 0
07:07:29 <lambdabot>  0
07:12:01 <McManiaC> bennofs: oh, I tried it with non but I must have done something wrong :) thanks
07:13:05 <McManiaC> ugh, why does non require Eq a on Maybe a
07:14:26 <McManiaC> got it
07:14:38 <McManiaC> at 5 . non' _Empty . at 3 ?~ ..
07:14:40 <bennofs> McManiaC: Because Just 3 & non 0 .~ 0 must be Nothing, so it needs to compare to 0
07:15:57 <lpaste> Rarr pasted “FFI import and export the same function” at http://lpaste.net/110446
07:16:11 <Rarr> Hello, one question: Using FFI export i export a Haskell function, and later using FFI import, i import it so I can send it away as a pointer to function (or use it if i'd like to). Are there any downsides to this approach ? http://lpaste.net/110446
07:33:55 <lpaste> benmachine revised “100 reasons I prefer Java to Haskell”: “No title” at http://lpaste.net/110448
07:38:34 <ChristianS> hm, the paste doesn't quite live up to its title
07:40:13 <augur> i think its rather funny. :)
07:40:16 <augur> benmachine: :D
08:09:33 <SwashBuckla> $ cabal update    cabal: <socket: 284>: invalid argument
08:09:48 <SwashBuckla> can you shed some light on this? google is unfortunately unhelpful on this
08:12:48 <yitz> SwashBuckla: problem with your internet connection, possibly. or a problem with hackage.
08:15:53 <hexagoxel> :t either (return.Left) (map Right) . sequence -- this thing is not predefined anywhere, is it?
08:15:54 <lambdabot> [Either a b] -> [Either a b]
08:18:56 <SwashBuckla> my internet connection is fine
08:19:19 <SwashBuckla> I can ping hackage
08:19:33 <SwashBuckla> what port does cabal use?
08:20:00 <c_wraith> it just uses http
08:20:09 <SwashBuckla> hmm
08:20:29 <SwashBuckla> how about socket:280 invalid argument?
08:21:22 <SwashBuckla> our network using a caching proxy
08:21:37 <c_wraith> that's probably breaking it in one way or another
08:21:47 <SwashBuckla> hmm
08:22:00 <SwashBuckla> is there any way around this?
08:22:33 <c_wraith> how does the proxy insert itself?
08:22:46 <SwashBuckla> 127.0.0.1:3128
08:23:18 <c_wraith> I know that port..  That's squid.  But the question was more "how do applications know to use it?"
08:23:39 <tdammers> (iow, who manages your network settings?)
08:23:42 <SwashBuckla> the LAN settings point to it as a HTTP proxy
08:23:54 <SwashBuckla> oh, I don't know, our boss?
08:24:09 <SwashBuckla> the sysadmin
08:24:30 <c_wraith> unless everyone is running their own copy of squid, that's a bit confusing
08:24:47 <SwashBuckla> I don't think I am
08:24:54 <SwashBuckla> but that's how it's configured
08:25:01 <c_wraith> 127.0.0.1 is always "this computer"
08:25:06 <SwashBuckla> yes
08:25:21 <tdammers> which means squid would be running locally, on your machine
08:25:40 <Fuuzetsu> is there an actual implementation as a package of McBride's Klesli paper?
08:25:51 <tdammers> a more typical setup would be running squid on another machine in the network and pointing everyone there
08:26:24 <tdammers> (added benefit is that everyone gets to use the same cache, making it more efficient)
08:26:59 <hseg> I seem to recall explicit type application was coming to GHC. Anyone have a link?
08:27:33 <athan> list comprehensions are confusing.
08:27:33 <Fuuzetsu> hseg: what would that do?
08:27:37 <c_wraith> hseg: I don't know that it's finalized yet
08:28:48 <hseg> Fuuzetsu: IIRC, you would have nicer syntax for saying, e.g. (Proxy :: Proxy Foo)
08:28:59 <zwer> athan what part confuses you?
08:29:00 <c_wraith> Fuuzetsu: it would allow you to set the concrete type of a type variable without writing out the full type.
08:29:14 <yitz> SwashBuckla: set up your own proxy with ssh -D via some computer on the outside. if your boss doesn't mind.
08:29:15 <Fuuzetsu> cool
08:29:20 <hseg> c_wraith: You know where the discussion is happening?
08:29:25 <c_wraith> Fuuzetsu: hseg's example would become something like (Proxy @ Foo) in the example I saw
08:29:33 <c_wraith> hseg: I don't
08:29:37 <Fuuzetsu> another meaning for @?
08:29:38 <athan> zwer: I have this sense that "pulling instances" from lists, ie: [x | x <- someList] should be done in parallel with each other ><
08:30:05 <c_wraith> Fuuzetsu: well, @ is reserved syntax, so at least that would minimize collisions.  It's far from final.
08:30:08 <tdammers> yitz: that requires changing the proxy setting on your end; if you can do that, just disabling the proxy would be my first approach
08:30:21 <athan> zwer: currently I'm trying to enumerate the triangle numbers, and I'm shooting myself in the foot because it seems as though I only have access to the last known value of my recursive comprehension
08:30:47 <yitz> SwashBuckla: once we figured out that someone who had that same problem was using K9. disabling that solved the problem. ;)
08:30:51 <zort> Hi y'all, the Haskell wiki says this http://web.archive.org/web/20140529211116/http://legacy.cs.uu.nl/daan/download/parsec/parsec.html (user guide to Parsec) is old, is there an up-to-date replacement?
08:31:21 <c_wraith> Fuuzetsu: but yes, it would be adding a meaning something like "make the first type variable in the type of the previous expression be the following type"
08:31:31 <SwashBuckla> yitz: ok thanks :)
08:31:35 <zwer> athan can you show your lsit comprehension
08:32:52 <c_wraith> Fuuzetsu: also, using @ would be handy because it has special precedence - the same as {}.  That'd mean fewer parens
08:33:11 <athan> zwer: Here's my attempt, i just have this sense that I don't have arbitrary access to the elements in the list: `tri = 1 : [ (x+1)+<sumOfTriSoFar> | x <- tri ]
08:33:20 <athan> I just don't know how to full in the sum so far :/
08:33:22 <yitz> tdammers: does it? if you can set up a tunnel to hackage (maybe even not using -D) on some port and point cabal to it, shouldn't that work?
08:33:45 <jollygood> what is a better alternative to data Animal = Dog {... } | Cat { ...} ? a type safe variant of that, basically
08:33:47 <SwashBuckla> yitz: that fixed it
08:33:51 <SwashBuckla> I was running K9
08:34:08 <yitz> SwashBuckla: haha, i nailed that one! :)
08:34:08 <SwashBuckla> it seems someone just installed it on my desktop (I inherited this computer from someone)
08:34:11 <Fuuzetsu> c_wraith: {} precedence always weirds me out
08:34:22 <tdammers> yitz: ah, right, yeah, if it's just that one program, yes
08:34:24 <c_wraith> SwashBuckla: ah, does that kill outbound http connections that it deems "suspicious"?
08:34:24 <Fuuzetsu> it binds tighter than application…
08:35:16 <c_wraith> Fuuzetsu: and isn't that kind of what you'd want here?   read @ Int "123"
08:35:34 <SwashBuckla> c_wraith: I am not sure
08:35:41 <Fuuzetsu> yeah, just making a note
08:35:51 <Fuuzetsu> it would be weird as hell to read
08:35:58 <SwashBuckla> c_wraith: is cabal connecting using naughty words?
08:36:25 <c_wraith> Fuuzetsu: thankfully, it's something you wouldn't use that often. :)
08:36:31 <hseg> c_wraith: Wait, what happens if you let GHC infer the signature of the type? How do you know what order to pass the types in?
08:36:56 <SwashBuckla> HTTP 4.0/GET "http://hackage.haskell.org/poo-poo-bums"
08:36:58 <jollygood> athan would be easier if you could post compilable code, as well as the output you expected
08:37:03 <Fuuzetsu> I convert {}s to lenses to avoid the weird precedence ;P
08:37:04 <hseg> Fuuzetsu: It's slightly weird, although if you read Core or System F you'll see stuff like that often.
08:37:13 <lpvb> what should I read to learn category theory
08:37:24 <hseg> Fuuzetsu: :). I convert them to lenses just for the operators.
08:37:41 <Fuuzetsu> lpvb: I'm currently reading Category Theory for Computing Science.
08:37:54 <Fuuzetsu> I like it although I can see I'll need at least 3 readings
08:37:55 <c_wraith> hseg: I'm assuming that it applies to type variables in the order they appear in the signature - that order is deterministic.  But it would be awkward to want to apply something to only the third type variable
08:38:05 <benmachine> Fuuzetsu: I find the precedence a tiny bit more intuitive if you don't have a space between the constructor name and the {
08:38:20 <Fuuzetsu> benmachine: that's just ugly
08:38:36 <Fuuzetsu> what I'll often do is foo $ bar { … }
08:38:38 <Fuuzetsu> even though $ is not needed
08:39:06 <athan> jollygood: But... but.... I can't think of a way to make it correct... I'm trying to get `1 : 3 : 6 : 10 : 15 : 21...`, though
08:39:15 <yitz> SwashBuckla: not sure, but it seems that K9 takes a "white list" approach. if it isn't sure that what you're trying to do is just view a safe web page in your browser, don't allow it.
08:39:16 <hseg> c_wraith: Yes, but why would GHC type \x y -> x as forall a b. a -> b -> a instead of forall b a. a -> b -> a ?
08:40:00 <c_wraith> hseg: Oh.  I was ignoring the order of type variable appearance in a forall, since that isn't deterministic.
08:40:16 <hseg> Fuuzetsu: One more book for the list. Where do you find all these books? Does your library stock them?
08:40:49 <hseg> c_wraith: Yup, which is why I'd be shocked if this were allowed for functions without explicit foralls in their signatures.
08:41:01 <Fuuzetsu> one day I discovered a small section between the Computer Science and Maths parts of the floor which stocked few CT books so I hoarded them all
08:41:06 <c_wraith> hseg: why?  Just ignore them, and everything's deterministic
08:41:11 <Fuuzetsu> in my uni library that is
08:41:51 <c_wraith> hseg: no matter what order you put things in the forall, no matter what you name the type variables...  positionally, the first one is the first argument and the result.  the second one is the ignored argument
08:41:54 <hseg> Fuuzetsu: You're lucky. My uni is more MBA/engineering focused, so we don't have that many theoretical books
08:41:58 <yitz> @oeis 1 3 6
08:41:59 <lambdabot>  Triangular numbers: a(n) = C(n+1,2) = n(n+1)/2 = 0+1+2+...+n.[0,1,3,6,10,15,...
08:42:16 <athan> yitz: Holy crap...
08:42:20 <Fuuzetsu> hseg: maybe your library is part of inter-library loans thing?
08:42:29 <msafi> Guys, I'm trying to get my IDE to compile and run a Haskell file. It's asking me for 'Executable Name', 'Program arguments', and 'Working directory'. Do you know what I should provide for these values?
08:42:41 <jollygood> athan I don't think sumOfTriSoFar> is expressable with list comprehensions
08:42:48 <msafi> Here's a screenshot of what's going on http://i.imgur.com/DHJdFGy.png
08:42:55 <hseg> Fuuzetsu: Maybe. Should've rephrased that to "old uni". Although they might allow guests to borrow books.
08:43:03 <Fuuzetsu> ah
08:43:23 <c_wraith> athan: you can do it *super* inefficiently with a list comprehension and the `inits` function. :)
08:43:25 <msafi> I have installed the Haskell Platform
08:43:42 <c_wraith> athan: however, that turns what should be O(n) additions into O(n^2) additions
08:43:54 <yitz> > scanl (+) [1..]
08:43:55 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
08:43:55 <lambdabot>    arising from a use of ‘M50401498372706388225619.show_M50401498372706388225...
08:43:55 <lambdabot>  The type variable ‘t0’ is ambiguous
08:43:55 <lambdabot>  Note: there are several potential instances:
08:43:55 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
08:44:01 <yitz> > scanl1 (+) [1..]
08:44:02 <lambdabot>  [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276...
08:44:07 <athan> c_wraith: Thank you
08:44:13 <hseg> c_wraith: That's all fine and well for terms, but what do you do with types? ((\x y -> x) :: forall a b. a -> b -> a) @Int is distinct from ((\x y -> x) :: forall b a. a -> b -> a) @Int
08:44:39 * hackagebot cndict 0.2.1 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  http://hackage.haskell.org/package/cndict-0.2.1 (DavidHimmelstrup)
08:45:09 <athan> yitz: :O
08:45:23 <c_wraith> hseg: how?  In either case, the first type variable (ignoring forall clauses) is a
08:45:26 <levi> msafi: Assuming it's using cabal to build, the build output would be in dist/build/<packagename>/<binaryname>
08:46:15 <msafi> levi: I guess by 'executable name' it means what program will be used to 'execute' your code?
08:46:25 <c_wraith> > [sum xs | xs <- inits [1..]] -- athan, this is super-terrible. :)
08:46:28 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
08:46:40 <athan> c_wraith: Perfect!
08:46:52 <levi> msafi: I guess it could be asking what name to use for the executable, in which case it doesn't really matter.
08:47:00 <c_wraith> athan: it's asymptotically slower than yitz's version
08:47:09 <levi> msafi: Try stuff and see what happens?
08:47:12 <msafi> levi: no, that's not what its asking.
08:47:19 <yitz> > inits [1..] -- athan, to see how c_wraith's works
08:47:20 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1...
08:47:27 <msafi> levi: it's asking about the compiler binary
08:47:55 <yitz> c_wraith: the absolute fastest is @oeis of course
08:48:13 <c_wraith> yitz: that depends on how fast your internet connection is. :)
08:48:36 <levi> msafi: I'm sorry, you have more experience with this particular IDE than I do. I don't think many here use an IDE.
08:49:41 * hackagebot persistent-template 2.0.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-2.0.1 (GregWeber)
08:49:49 <athan> yitz, c_wraith: Have you guys ever gotten into alchemy?
08:49:51 <msafi> levi: okay, so what if I ask about the location of the binary that takes your Haskell code and compiles it, where is that located after you install the Haskell Platform?
08:50:28 <hseg> c_wraith: That doesn't fit in with the design decision that non-prenex signatures should be accepted, so ((\x y -> x) :: forall a. a -> forall b. b -> a) @Int and ((\x y -> x) :: forall b a. a -> b -> a) @Int should be accepted and should differ.
08:50:49 <levi> msafi: I really doubt that's what the screenshot you posted is asking for. But the answer to that will depend on which OS you're using.
08:50:53 <yitz> athan: i gave it up after i made an error and then it took me weeks to change back from being a rabbit
08:51:04 <msafi> levi: OS X 10.9
08:51:11 <yitz> athan: someone needs to come up with typesafe alchemy
08:51:38 <levi> msafi: Try typing 'which ghc' at a shell prompt; that should tell you where ghc is installed.
08:52:06 <hseg> athan: You haven't seen anything yet. Look up the reverse state monad, the reflection library and the hask library for some real brainbending stuff. Or anything by oleg.
08:52:18 <msafi> Cool. I'll try that, levi.
08:52:42 <athan> yitz, hseg: I feel like I need some altars or something...
08:52:46 <c_wraith> hseg: explicit type application doesn't play with non-prenex types anyway.  You can't explicitly apply a type to s in runST, for instance.
08:53:19 <c_wraith> hseg: I mean, the whole reason they're non-prenex is that they're polymorphic - they can't have a type applied explicitly
08:54:40 <hseg> c_wraith: Non-prenex means that the foralls are distributed among the signature, so stuff like forall a. a -> (forall b. b -> a). ST uses rank-2 types, which is a related but different beast.
08:55:41 <c_wraith> hseg: Hmm.  I was taught that prenex just means "rank 1"
08:56:11 <l0cust> GitHub is being very slow today
08:56:20 <hseg> https://en.wikipedia.org/wiki/Prenex_normal_form
08:56:31 <dolio> (forall a. a -> forall b. b -> a) would probably be considered rank-1.
08:56:43 <c_wraith> dolio: I could consider it to be so
08:56:55 <msafi> levi: you're right. It wasn't asking for what I was thinking.
08:56:58 <dolio> forall on the right of an arrow wouldn't increase rank.
08:57:05 <msafi> I'll have to do more research, levi.
08:57:17 <levi> The foralls increase rank when in contravariant position, IIRC.
08:57:19 <Fuuzetsu> wasn't there talk about idiom brackets?
08:57:41 <Sonderblade> does #haskell have any book recommendations for cathegory theory in a programming context?
08:58:03 <c_wraith> hseg: in any case, with all rank 1 types, placement of foralls is irrelevant.  the order that type variables appear in the signature outside of foralls is obvious and deterministic.  That's all it needs for explicit type application to be resolvable.
08:58:09 <levi> Sonderblade: Awodey's Category Theory might be a good one.
08:58:53 <Sonderblade> levi: might? you haven't read it? :)
08:59:32 <hseg> c_wraith: A) you mean that the first typevar is unified with the first parameter, etc? B) That doesn't seem to be the case from GHC Trac's example of non-PNF type application: https://ghc.haskell.org/trac/ghc/wiki/TypeApplication
08:59:44 <levi> Sonderblade: Not past the first chapter or so. He has some video lectures from the Oregon Summer School for PL theory stuff.
08:59:45 <hseg> Sonderblade: It's recommended quite often.
09:01:15 <lpaste> SwashBuckla pasted “Profiling haskell functions” at http://lpaste.net/110451
09:01:20 <dolio> The order of variables is not deterministic once you have type classes.
09:01:33 <SwashBuckla> how would I profile gcd'' versus gcd'''?
09:55:53 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://is.gd/xJt4FF'
09:55:53 --- topic: set by glguy on [Fri Aug 15 13:29:35 2014]
09:56:21 <dspies> yitz: But Archive Manager gives the error: "Could not create the hard link file:///home/dspies/ghc-7.8.3-i386-unknown-linux-deb7/ghc-7.8.3/utils/haddock/dist/build/tmp/haddock"
09:56:56 <aj3211> For an Arrow a, is it possible to write a function a b [c] -> [a b c] and its inverse [a b c] -> a b [c]. I'm basing this on arrows as exponentiation and lists as products so (c*c*c..)^r = c^r*c^r...
09:59:06 <ReinH> levi: :)
09:59:48 <ReinH> aj3211: are list products? Tuples are products.
10:02:55 <Twey> aj3211: But a  r ~> [c]   is a r^(c × c × … × c), not (c × c × … × c)^r
10:03:25 <Twey> Oh wait, no, never mind
10:03:39 <ReinH> You can distribute arrows across products:
10:03:40 <ReinH> > let both f = first f >>> second f in both succ (1,2)
10:03:41 <lambdabot>  (2,3)
10:04:05 <dspies> yitz: I uninstalled everything haskell-related from aptitude, cabal, ghc, haskell-platform, etc.
10:04:16 <dspies> yitz: And I'm still getting that error
10:04:27 <Twey> Mm, but a list is (c⁰ + c¹ + c² + c³ + …), not merely (c × c × c × …)
10:04:45 <Twey> And exponentiation doesn't distribute across addition
10:04:53 <dspies> http://lpaste.net/110454
10:07:03 <fizbin> > let both f = f *** f in both succ (1,2)
10:07:05 <lambdabot>  (2,3)
10:07:28 <benmachine> there is a bijection between (A → B) × (A → C) and A → (B × C)
10:08:15 <fizbin> ReinH: Better to distribute that way, since I think it's possible for (first f >>> second f), (f ** f), and (second f >>> first f) to be subtly different.
10:08:22 <dspies> > let fibs = 1 : (zipWith (+) fibs (0 : fibs)) in take 30 fibs
10:08:23 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
10:08:25 <fizbin> But I'd need to double-check the arrow laws.
10:08:38 <ReinH> fizbin: sure
10:09:02 <ReinH> fizbin: although the default impl of (***) is f *** g = first f >>> second g
10:10:38 <benmachine> fizbin: it is true that they can be different, although some people think that's a mistake
10:11:07 <fizbin> Well, like I said, I need to look through the laws carefully to see if doing that violates any.
10:11:09 <benmachine> for example, in the Kleisli case, first f >>> second g and second g >>> first f differ in the order of the effects
10:11:29 <benmachine> it is my belief that this is within the current set of laws
10:12:05 <benmachine> (certainly it would be very strange if Kleisli m was not a law-abiding Arrow instance, given that it's supplied by Control.Arrow)
10:12:25 <fizbin> Hrm. Well, the laws as given in the docs apply only to 'first' and 'arr'.
10:13:01 <benmachine> Cale has worked with arrows a bit and thinks that arr shouldn't exist and that more things should commute
10:14:52 <ReinH> fizbin: *shrug*
10:16:16 <fizbin> Yeah, it looks like the most sensible interpretation of the laws as written says that (first f >> second g) needs to be the same as (second g >> first f) only if either 'f' or 'g' is (arr someFunc). If both are arrow not created with arr, the expressions can differ.
10:16:31 <fizbin> Oops, pretend I used >>> there.
10:19:51 * hackagebot cabalg 0.2.7 - alias for cabal install from given git repo  http://hackage.haskell.org/package/cabalg-0.2.7 (DmitryMalikov)
10:20:09 <aj3211> the list type is a product right? as for a list = c^0 + c^1 + c^2.. doesnt that enumerate the all values of the list type rather than a single value which takes the form c^n
10:21:22 <fizbin> aj3211: Except you should allow that haskell also has infinite lists.
10:21:51 <fizbin> Which will never show up in that enumeration you've got there.
10:22:06 <aj3211> i see. but that should not stop us writing a recursive definition right?
10:23:00 <fizbin> Well... no, but I guess I don't see what you're getting at. The basic recursive definition of list-like structures is quite well known.
10:23:25 <fizbin> data MyList a = MyNil | MyCons a (MyList a)
10:25:10 <wz1000> Is there any way of having typeclass variables in haskell?
10:25:26 <merijn> wz1000: What do you mean by that?
10:25:33 <aj3211> i meant this with regard to the previous question of defining Arrow a => [a b c] -> a b [c] and a b [c] -> [a b c]. Is it possible to do so based on the bijection (A -> B) x (A -> C) = A -> (BxC)
10:25:44 <c_wraith> merijn: damn it.  again!  when are we setting up a schedule? :)
10:25:53 <merijn> c_wraith: :D
10:26:05 <merijn> c_wraith: That's what you get for not being a ICFP either :p
10:26:38 <c_wraith> merijn: pfft.  I'm just gonna go offline all night in protest.  In...  a bunch of hours.  When it's night.
10:26:53 <merijn> It's ok, I should start working anyway :p
10:29:16 <Philonous> aj3211, I'm surprised by the idea that Arrows are exponentiation. Consider type «KMaybe a b = Maybe a -> Maybe b» (the Kleisli-arrow over Maybe), that's clearly not the same as b^a, is it?
10:29:49 <c_wraith> Philonous: is that the Kleisli arrow?  I thought that was a -> Maybe b
10:29:55 <wz1000> merijn: I wanted a function of the form ' if' :: (c x, c y) => Bool -> x -> y -> (x | y)' . I realize this is weird and requires dependent typing, but that got me to ask the question whether you could even work with generic unknown typeclasses in haskell.
10:30:13 <Philonous> c_wraith, Errr, right. Still, it's not b ^ a
10:30:37 <ReinH> Philonous: No, it's not b ^ a
10:30:40 <c_wraith> (b + 1) ^ a    :)
10:30:41 <benmachine> sure it is
10:30:44 <benmachine> just not in Hask :)
10:30:54 <ReinH> But it is exponentiation because Kleisli is closed.
10:31:03 <benmachine> actually I might be making stuff up
10:31:16 <benmachine> but if I am then ReinH is making up the same stuff which at least marginally increases the probability that it is true
10:31:48 <ReinH> (Kleisli is a CCC, and closed categories have exponents)
10:32:29 <benmachine> ReinH: do you happen to know in what generality that is true? is it true for all Kleisli categories? presumably at least the underlying category has to be CC?
10:32:29 <Philonous> ReinH, That argument is circular,
10:32:50 <wz1000> Basically, if' is guaranteed to return a value that belongs to typeclass 'c', no matter what its arguments. The fact that the value belongs to 'c' is enough to carry out all further computaions.
10:32:59 <ReinH> Philonous: It is not, is is of the form if P then Q, P therefore Q
10:33:07 <ReinH> If a category is closed then it has exponents.
10:33:14 <ReinH> Kleisli is closed, therefore it has exponents.
10:33:28 <fizbin> I think the issue is that exponents of types are defined in a particular category. The Arrow (->) yields the exponents in the category Hask that we're used to, whereas the Arrow Kleisli leads to exponents in the Kleisli category, which is a bit weird and unfamiliar.
10:33:38 <benmachine> ReinH: it's not unreasonable to argue that Kleisli is closed *because* it has exponents :)
10:34:15 <benmachine> wz1000: it's possible to do what you want, but it's often not that helpful
10:34:30 <ReinH> Hmm, I might be wrong about Kleisli being CCC
10:34:43 <benmachine> wz1000: you need some extensions, either higher-rank polymorphism or existential datatypes
10:35:19 <benmachine> wz1000: then you can have values that are, say, "AnyShow", but all you can do with them is call Show methods on them
10:35:22 <fizbin> We're talking about b^a , where b and a are Haskell types, as though it's obvious what that means. And it means different things in the category Hask (the category of haskell types, where arrows are functions between types) than in the category where arrows are given by Kleisli operators.
10:35:33 <benmachine> wz1000: often that's not much more useful than just having a String :)
10:35:56 <vramana> I am installed SublimeHaskell package for my ST3. After restarting it gave an error that it didn't find hdevtools and asked me to install it. When i tried to install it https://gist.github.com/vramana/5d8125ffed8a3fa72fc3 It was giving this. What should I do?
10:36:01 <benmachine> wz1000: moreover, notice that it's easy to make your function return Either a b
10:36:01 <Philonous> ReinH, You are arguing that Kleisli has exponents because it is closed, but to say it is closed _means_ that it has exponents (among other things). Isn't that begging the question?
10:36:28 <ReinH> Philonous: I see what you're saying, which is why I'm trying to verify that Kleisli is actually closed.
10:37:05 <wz1000> benmachine: This came up because I wanted to get a value out of an Either a b :P
10:38:04 * benmachine dinner time
10:38:16 <wz1000> So, what you are saying is that I move my 'c' dependent computations inside the if?
10:38:19 <gennady> If I am understanding currying right is it basically recursion?
10:38:20 <c_wraith> wz1000: the best way to eliminate an Either is with the either function
10:38:36 <fizbin> gennady: Uh, no.
10:38:39 <c_wraith> :t either -- wz1000
10:38:41 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
10:38:46 <fizbin> @type curry
10:38:47 <lambdabot> ((a, b) -> c) -> a -> b -> c
10:38:53 <fizbin> @type uncurry
10:38:54 <lambdabot> (a -> b -> c) -> (a, b) -> c
10:39:08 <c_wraith> wz1000: The two input types have different code paths, but they end up at the same result type
10:39:18 <gennady> :|
10:39:19 <wz1000> Ah
10:39:57 <blairio> I don't suppose someone could explain why a piece of code I'm writing doesn't work? (1st week in haskell)
10:40:01 <c_wraith> wz1000: I guess pattern matching is equivalent in cases not involving crazy language extensions
10:40:02 <fizbin> gennady: "Currying" means taking a function that takes two parameters, and turning it into a function that takes one parameter, and returns another function that takes the other parameter. Some languages call this "partial function application"
10:40:21 <BeardedCoder> blairio: link to code?
10:40:25 <c_wraith> blairio: put it on lpaste, put the link here, and someone will take a look
10:40:30 <c_wraith> @where lpaste
10:40:31 <lambdabot> http://lpaste.net/new/haskell
10:40:37 <Philonous> blairio, Well, it's easy enough to find out. Just put it into a pastebin (preferably including the error message) and post it here
10:40:46 <gennady> But when you give it two doesn't it "call itself" again with the second parameter?
10:41:02 <wz1000> Also, Is it possible to pattern match on GADTs?
10:41:02 <c_wraith> gennady: nope
10:41:16 <tremon> gennady: no. the the result of a curry operation is a new function, not the original function
10:41:20 <c_wraith> wz1000: yes, but you need to specify the type of the expression being matched, because it can't infer it
10:41:22 <blairio> http://lpaste.net/110460
10:41:24 <gennady> Ohhh
10:41:27 <Philonous> fizbin, No, partial function application is something different
10:41:40 <gennady> Ok thanks, guess I should re-read this part a bit slower.
10:42:10 <c_wraith> gennady: currying and partial application go together very nicely.  You can think of it as "each argument you provide removes an arrow"
10:42:37 <josephle> blairio: div isn't an infix operator. You can fix this my making it `div`
10:42:55 <c_wraith> gennady: (+) :: Int -> Int -> Int,  (+) 5 :: Int -> Int,   (+) 5 3 :: Int
10:42:56 <ReinH> Philonous: I thought that closed categories were defined as those with internal homs and so on, and that having exponents was not a part of the definition.
10:43:23 <fizbin> Philonous: Oh, I suppose. Partial function application though is equivalent to currying and then applying that argument.
10:43:29 <gennady> Ah ok, making a lot more sense now.
10:43:33 <josephle> > 4 `div 2 -- blairio
10:43:35 <lambdabot>  <hint>:1:8: parse error on input ‘2’
10:43:40 <josephle> > 4 `div` 2 -- blairio
10:43:41 <lambdabot>  2
10:43:42 <Philonous> fizbin, Hmm, maybe.
10:45:20 <blairio> Wow, sorry, not used to anything other than infix
10:45:41 <ReinH> fizbin: currying and partial application are different things
10:46:04 <josephle> blairio: a cool trick is that surrounding a function with ` will make it infix
10:46:11 <ReinH> a curried function can then be partially applied
10:47:04 <ReinH> http://en.wikipedia.org/wiki/Currying#Contrast_with_partial_function_application
10:48:22 <blairio> josephle: Awesome! Thanks. Second thing, how do I handle types here so that I can get an un-rounded result
10:48:45 <gennady> ReinH, in lyah they are making it seem pretty close to the same thing though.
10:49:05 <josephle> :t (\) -- blario
10:49:05 <gennady> "So how is that beneficial to us? Simply speaking, if we call a function with too few parameters, we get back a partially applied function, meaning a function that takes as many parameters as we left out."
10:49:05 <lambdabot> parse error on input ‘)’
10:49:08 <wz1000> c_wraith: How would you pattern match on something like 'data List n a where Nil :: List Zero a; Cons :: a -> List n a -> List (Succ n) a' where 'Zero' and 'Succ a' are empty types. How would you write an append function for this type?
10:49:10 <josephle> :t (/) -- blario
10:49:11 <lambdabot> Fractional a => a -> a -> a
10:49:24 <Philonous> gennady, I always thought it was suspicious that lyah was so close to "liar"
10:49:37 <gennady> :|
10:49:37 <ReinH> gennady: that is just partial application though
10:49:49 <ReinH> gennady: do they call it currying?
10:50:11 <josephle> blairio: if you use the division operator, haskell should be able to infer the type you want
10:50:20 <gennady> Eh, good point.
10:50:31 <ReinH> if you have an Int, you can use fromIntegral
10:50:32 <josephle> > 4 / 2 -- blairio
10:50:33 <lambdabot>  2.0
10:50:34 <ReinH> :t fromIntegral
10:50:35 <lambdabot> (Num b, Integral a) => a -> b
10:50:44 <ReinH> in fact any instance of Integral
10:51:05 <josephle> :t sum
10:51:06 <lambdabot> Num a => [a] -> a
10:52:32 <josephle> blairio: as ReinH says, you'll probably need fromIntegral for (length xs)
10:52:39 <merijn> wz1000: You'd need to implement a type level "add" function so that "append :: List n a -> List m a -> List (Add n m) a"
10:53:23 <ReinH> :t \xs -> sum xs / genericLength xs
10:53:25 <lambdabot> Fractional a => [a] -> a
10:53:34 <benzrf> do't use genericlength
10:53:39 <ReinH> ^ this is commonly used to demonstrate an average function in Haskell
10:53:41 <benzrf> or so im told at every turn
10:53:47 <ReinH> but it's bad
10:54:00 <ReinH> sum xs / fromIntegral (length xs) won't be much better though
10:54:02 <merijn> ReinH: Really inefficient average too
10:54:10 <ReinH> Yes.
10:54:12 <merijn> It'll keep xs live too long :)
10:54:21 <ReinH> merijn: it'll also traverse it twice :)
10:54:47 <vramana> I installed SublimeHaskell package for my ST3. After restarting it gave an error that it didn't find hdevtools and asked me to install it. When i tried to install it https://gist.github.com/vramana/5d8125ffed8a3fa72fc3 It was giving this. What should I do?
10:55:01 <blairio> Haha, for now I'm just trying to wrap my head around the syntax. How would you cretae a more efficient average?
10:55:20 <ReinH> blairio: compute the sum and the length at the same time and divide at the end
10:56:40 <ReinH> It's actually somewhat complicated to get it right because of non-strictness
10:56:59 <ReinH> you want to use constant space and linear time
10:57:28 <ReinH> Complicated enough that libraries have been written to help you do it properly, in fact. ;) https://hackage.haskell.org/package/foldl
10:57:34 <blairio> So would that mean creating a method that records how many numbers it counts as it adds them, and returns a tuple?
10:58:21 <Odda> Given a typeclass, say class Event e ..., how can I force a list [ instance1, intance2 ] to be a list of Event other than having a new type that wraps this in a constructor paramter, e.g. Event => EventStream ... ?
10:58:24 <ReinH> blairio: yes, except tuples are lazy, so you need a strict pair. Like I said, complicated. :)
10:58:31 <josephle> blairio: that's a good idea! Non-strictness can haunt your dreams later :)
10:58:46 <ReinH> Odda: you can use an existential, but that's considered an antipattern
10:58:52 <ReinH> @google haskell existential antipattern
10:58:52 <fizbin> >let avg' [] s n = (fromIntegral s) / (fromIntegral n); avg' (x:xs) s n = let s' = s+x; n'=succ n in s' `seq` n' `seq` avg' xs s' n'; avg xs = avg' xs 0 0 in avg [1..5] :: Double
10:58:54 <lambdabot> http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
10:58:54 <lambdabot> Title: Haskell Antipattern: Existential Typeclass | Luke Palmer
10:59:05 <ReinH> Odda: ^ gives a good overview of the solution and why you might not want to use it :)
10:59:30 <ReinH> fizbin: complicated :)
10:59:35 <Odda> ReinH: thanks, I'll have a look.
11:00:01 <fizbin> > let avg' [] s n = (fromIntegral s) / (fromIntegral n); avg' (x:xs) s n = let s' = s+x; n'=succ n in s' `seq` n' `seq` avg' xs s' n'; avg xs = avg' xs 0 0 in avg [1..6] :: Double
11:00:03 <lambdabot>  3.5
11:00:56 <fizbin> Or I suppose you could use bangpatterns, but I never seem to be able to get those to work the way I want.
11:01:28 <ReinH> fizbin: http://hackage.haskell.org/package/strict-0.3.2/docs/Data-Strict-Tuple.html :)
11:01:49 <ReinH> > 1 :|: 2
11:01:50 <josephle> blairio: Have you learned about higher-order functions yet? A good exercise would be to build your tuple using a foldl
11:01:50 <lambdabot>  Not in scope: data constructor ‘:|:’
11:01:54 <ReinH> oh well
11:02:02 <ReinH> Oh wrong.
11:02:18 <ReinH> Still not in scope though
11:02:19 * ReinH shrugs
11:02:24 <Odda> ReinH: I saw a really neat example using typefamilies, but I just made the transition from c#, so I haven't gotten my head around it yet. Seemed so easy in the example, but when I tried to serialize it to bson, it bit my face off...
11:02:45 <ReinH> Odda: heh... how many different types do you want in your list?
11:03:02 <blairio> :t (\) -- josephle
11:03:03 <lambdabot> parse error on input ‘)’
11:03:04 <ReinH> Sometimes the easiest thing is to make a sum type of them all if there are few enough
11:03:20 <Odda> ReinH: a whole load, trying to rebuild an exising event sourcing system in haskell
11:03:25 <ReinH> Ah
11:04:09 <Philonous> > uncurry ((/) `on` getSum) . foldMap (\x -> (Sum x, Sum 1)) $ [1..10]
11:04:10 <josephle> blairio: I made the same mistake, heh
11:04:11 <lambdabot>  5.5
11:04:18 <josephle> :t (/)
11:04:19 <lambdabot> Fractional a => a -> a -> a
11:04:48 <blairio> :t (/)
11:04:50 <lambdabot> Fractional a => a -> a -> a
11:04:54 <Philonous> Oh, that second Sum isn't even necessary
11:05:01 <blairio> haha, how do these commands work?
11:05:01 <Philonous> > uncurry ((/) `on` getSum) . foldMap (\x -> (Sum x, 1)) $ [1..10]
11:05:03 <lambdabot>  5.5
11:05:06 <merijn> Odda: Type families and serialisation/etc. don't play well together
11:05:22 <merijn> Odda: Because the result type depends on the input you're reading, which requires dependent typing
11:05:55 <silver> is there a way to restrict a to A (or promoted type 'A if we talk in terms of DataKinds extension) in the following https://dpaste.de/0rjC (using some extensions)?
11:06:30 <Odda> ReinH: this one, https://gist.github.com/Fristi/7327904, looked so beautiful and fit for purpose. I thought I try some slight modifications, and that'd solve most of my initial problems
11:07:07 <ReinH> Odda: interesting
11:07:09 <merijn> silver: "data Bar :: Foo -> * where"
11:07:23 <merijn> silver: Then explicitly write "Bar A"
11:07:36 <Odda> merijn: thanks, I thought i could mark the events with type, and then the deserialization would be as elegant
11:08:40 <Odda> and without the typefamilies, it got bloated really quickly. I suspect there is some spinal c# kicking in
11:10:54 <blairio> :josephle I'm afraid I know a small programming background, but they're slow on the cs front. Higher order function?
11:11:34 <Odda> I think the 'seed' function in the above example was a nice touch as well, I had't come up with a way to 'emit' the initial object, which is implied by the first event in the stream
11:11:39 <josephle> blairio: if you haven't heard about them yet, don't worry. They'll come up as you keep studying haskell
11:13:07 <athan> Is there a way to chain multiple elements of a list comprehension? For instance: `[x, 2 * x | x <- [1..]]`?
11:15:09 <Fuuzetsu> concat [[x, 2 * x] | x <- [1 ..]]?
11:15:16 <int-e> athan: you can do [y | x <- [1..], y <- [x, 2*x]]
11:15:55 <ReinH> blairio: a function that returns a function. In Haskell these show up almost everywhere.
11:15:58 <ReinH> :t (+)
11:15:59 <lambdabot> Num a => a -> a -> a
11:16:07 <athan> int-e, Fuuzetsu: Augh haugh haugh! :{D
11:16:13 <ReinH> (+) is a function that takes a number and returns (a function that takes another number and adds them together).
11:16:19 <athan> (that's supposed to be the steriotypical french-guy laugh)
11:16:28 <ReinH> > let add1 = (+) 1 in add1 2
11:16:30 <lambdabot>  3
11:16:34 <blairio> Ah, ok that makes sense
11:16:41 <ReinH> :t fmap
11:16:41 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:16:56 <blairio> So haskell's lazy evaluation is all about higher order functions?
11:17:08 <int-e> blairio: not at all.
11:17:12 <ReinH> fmap is a function that takes a function and returns another function that operates on another type
11:17:23 <ReinH> you can read it as (a -> b) -> (f a -> f b)
11:18:10 <int-e> blairio: functional programming is about higher order functions; laziness is completely independent from that.
11:18:16 <ReinH> blairio: Strictly speaking (pun intended), Haskell does not do lazy evaluation. Haskell talks about strictness. GHC implements non-strictness using lazy evaluation.
11:18:42 <ReinH> And strictness and higher order functions are not really related
11:20:18 <blairio> K, two questions, a note on notation "(a -> b) -> (f a -> f b)" I've seen this used but the way it's used sometimes makes -> behave like a comma in method parameters in java
11:20:26 <lpaste_> dfeuer pasted “filterM-foldr fusion” at http://lpaste.net/1711487816837365760
11:20:50 <ReinH> Lazy evaluation is: left-most outermost expression reduction, expressions evaluated only when needed, each expression once evaluated is replaced by the result, and sharing is employed to avoid duplicated evaluation of the same expression.
11:20:51 <dfeuer> I just pasted a hypothetical filterM/foldr fusion law. I'm wondering if it's valid.
11:21:11 <blairio> public (f a -> f b) functionX( a,b)
11:21:29 <josephle> blairio: in haskell, there is a concept called "currying" which allows this to happen
11:21:34 <josephle> :t curry -- blairio
11:21:36 <lambdabot> ((a, b) -> c) -> a -> b -> c
11:21:45 <josephle> :t uncurry -- blairio
11:21:46 <lambdabot> (a -> b -> c) -> (a, b) -> c
11:21:48 <ReinH> (an expression that can be reduced is called a reducible expression, or redex)
11:21:55 <ReinH> (what is the plural of redex? redexen?)
11:22:28 <Fuuzetsu> say I have a data type such as data Foo = A Int | B Int () | C Int [()] | D Int …, is there a nice way to factor-out the Int?
11:22:58 <monochrom> I think I've only seen "redexes" for the plural
11:23:10 <ReinH> blairio: in Haskell we tend to prefer curried functions, i.e., functions of the form a -> b -> c rather than (a, b) -> c
11:23:20 <ReinH> monochrom: I'm going to make a push for redexen ;)
11:23:29 <Fuuzetsu> redexi
11:23:34 <dfeuer> redexigons.
11:23:41 <ReinH> although curry and uncurry allow you to convert between them freely
11:23:43 <blairio> So, I've seen a little about currying, would this be an instance of it? 2+3+4 (1 expression) v. 2+(3+4)
11:23:53 <monochrom> ok! start writing blogs and making podcasts that say "redexen"!
11:23:57 <int-e> dfeuer: I think you're missing a `return` on the left-hand side on line 2.
11:23:58 <StoneToad> Fuuzetsu: only way I'm aware of uses nexted types
11:24:04 <StoneToad> nested*
11:24:12 <ReinH> :t curry
11:24:13 <lambdabot> ((a, b) -> c) -> a -> b -> c
11:24:30 <josephle> blairio: not quite, that's associativity, which is a property of some operators
11:24:34 <Fuuzetsu> mhm
11:24:59 <monochrom> 2+3+4 has always been (2+3)+4, in all languages.
11:25:09 <blairio> Sorry, when I used the bracketing there, I was trying to represent the bracketed part as a function input
11:25:14 <dfeuer> int-e, oh, yeah. Of course.
11:25:25 <ReinH> blairio: compare these two things:
11:25:29 <StoneToad> Fuuzetsu: I think that's one of the selling points for the view function stuff
11:25:31 <lpaste_> dfeuer revised “filterM-foldr fusion”: “No title” at http://lpaste.net/1711487816837365760
11:25:32 <ReinH> > let addTuple (a,b) = a + b in addTuple (2,3)
11:25:33 <lambdabot>  5
11:25:40 <ReinH> > let addTuple (a,b) = a + b in curry addTuple 2 3
11:25:41 <lambdabot>  5
11:25:54 <StoneToad> view patterns*
11:26:24 <zwer> > uncurry (+) (2,3)
11:26:24 <monochrom> still no, blairio, for example, SML's + does not do currying, and still 2+3+4 means (2+3)+4. you are again equating two unrelated topics.
11:26:25 <lambdabot>  5
11:26:31 <ReinH> monochrom: I will find a way to use "redexen" on the podcast as often as possible ;)
11:26:38 <int-e> dfeuer: and yes, that should be valid, noting that 'return' is never strict, because  return undefined >> m === m.
11:27:59 <Fuuzetsu> hm I'm so behind on Haskell Cast
11:33:47 <silver> merijn, what do you mean by explicitly write "Bar A"? the way I'm trying to do is something like this: https://dpaste.de/gN9T
11:33:55 <Sorella> blairio, currying is just the notion of encoding a multi-argument function as a series of 1-argument function. It isn't even related to how those functions are applied.
11:35:34 <silver> so D B won't typecheck
11:36:25 <blairio> Hmm, so I guess I was thinking about something like a recursive process, instead of SUM(1, 2, 3) you can have a function which takes a funtion as an argument, like SUM(SUM(1,2),3 )
11:37:58 <blairio> But currying isn't as simple as stringing functions together
11:39:49 <zwer> in a language that uses parenthesis for function application callina curried function would look like this: func(1)(2)(3)
11:39:49 <josephle> so suppose you could partially apply SUM, e.g. SUM(1)
11:39:50 <Sorella> blairio, Unless `SUM(a, b)` returns a function, that isn't taking a function as argument either. In strict impure languages, you'll usually evaluate all the arguments to a function before invoking that function. In non-strict/pure languages, you're passing an expression, which the engine might decide to reduce whenever it thinks it should.
11:40:24 <Sorella> blairio, currying is simple the thing of taking `add(a, b) = ...` and writing it as `add = (a) => (b) => ...`
11:42:02 <Sorella> And different from partial application, you can transform a multi-argument function into a curried function (through a "curry" operation), and a curried function into a multi-argument function. It's just about how you encode the function's arity, rly.
11:42:17 <lpaste_> dfeuer revised “filterM-foldr fusion”: “No title” at http://lpaste.net/1711487816837365760
11:45:55 <blairio> So I'm new to the notation here, something like 'isPrime :: Int -> Bool' makes sense as a map of an int to a truth value, but how do i read " `add = (a) => (b) => ...` "
11:46:41 <seyvu> I have "cabal-version: >= 1.20" in my project file but I get a weird error telling me that "... requires Cabal library version -any && >=1.20 but no suitable version is installed.". Yet "cabal --version" returns "cabal-install version 1.20.0.3 using version 1.20.0.0 of the Cabal library"
11:46:45 <shachaf> blairio: I don't know. That doesn't look like valid Haskell code.
11:47:14 <int-e> dfeuer: http://lpaste.net/4306528089535414272 is my attempt to derive this law in some detail.
11:47:38 <quchen> blairio: You can't have multiple "=>" in a type signature. Did you mean to say "->" instead?
11:48:15 <blairio> I'm not sure, that code was sent to me
11:48:38 <quchen> Then send back "parse error" ;-)
11:48:49 <shachaf> quchen: That doesn't look like a type signature in the first place, so that's not relevant.
11:49:16 <Sorella> blairio, ah, sorry, I didn't use Haskell notation. That would be `add (a, b) = ... :: (a, b) -> c` vs `add = \a -> \b -> ... :: a -> b -> c`
11:49:19 <quchen> Oh, I didn't see the "=" there.
11:49:21 <shachaf> auchen: Also: You can't? Is this a strictly Haskell 2010 thing?
11:49:30 <shachaf> s/./q/
11:49:36 <dfeuer> Thanks, int-e! I started by defining filterM in terms of foldr (which is probably a good idea for real), and then the rest was a bit .... guessy.
11:50:00 <quchen> shachaf: GHCi rejected it, but let me double-check that. Maybe GHC's constraint kinds allow those kinds of type sigs.
11:50:45 <shachaf> No constraint kinds needed.
11:50:48 <dfeuer> I kind of doubt there's any way to do anything terribly *useful* with that law from a library perspective without falling into a Wadlerian full deforestation, but it's interesting nonetheless.
11:51:08 <shachaf> :t let f :: Show a => Eq a => a -> a -> String; f x y | x == y = show x | otherwise = "" in f
11:51:09 <lambdabot> (Show a, Eq a) => a -> a -> String
11:51:28 <shachaf> Officially this isn't allowed by the Haskell report. But it probably ought to be.
11:52:33 <int-e> dfeuer: well, at least it avoids allocating the intermediate list.
11:52:37 <dfeuer> It seems to make a lot more sense than the Report syntax.
11:53:50 <oisin888> I'm having a little trouble wrapping my head around serialization and deserialization. I am using the Binary package. I want to send a message to a server containg a command and a message (Command, ___msg___). Commands are just a simple data type: Command = Join | Leave | ... The problem is, that depending on the comand, the message may be a different data type. How do i resolve this?
11:54:00 <dfeuer> int-e, one question is whether it's better than, worse than, or the same as what you get without it in, say, the list monad. I'm ... really not sure.
11:54:01 <quchen> I guess it's a matter of taste. I like having the tuple-like notation because it forces nice grouping in code and looks bad, so it discourages type sigs with a bazillion of constraints.
11:54:53 <shachaf> I also think forall should be in the Haskell report.
11:54:59 <quchen> Oh yes.
11:55:07 <quchen> Maybe for Haskell 2014.
11:55:17 <dfeuer> I think forall *with ScopedTypeVariables semantics* should be in the Haskell report.
11:55:19 <shachaf> If you like forall then surely you must like =>
11:55:23 <quchen> That's the new standard that's going to be released next year for at least 3 years to come ;-)
11:56:05 <blairio> K, thanks for the help guys
11:56:29 <quchen> Maybe I can be converted to liking =>. I never had enough trouble with it to care much to be honest. foralls on the other hand make the logic of type sigs more obvious, for the brain and the eye.
11:56:45 <dfeuer> oisin888, it sounds like you don't want to send a command *and* a message, but really a command *with* a message.
11:57:03 <dfeuer> If you put your message *in* your command, your troubles may be over.
11:57:07 <oisin888> dfeuer: I guess so - I don't instantly see the difference
11:57:20 <dfeuer> oisin888, that's because I worded it badly.
11:57:49 <oisin888> dfeuer: I model it as (Command, Message) and decode :: ByteString -> (Command, Message - aka String)
11:57:52 <oisin888> Is that a poor choice?
11:58:17 <dfeuer> oisin888, instead of sending (GoForward, thisFar), I think you should probably send (GoForward thisFar)
11:58:46 <dfeuer> oisin888, your type just doesn't work at all if different commands need different types of messages.
11:59:40 <dfeuer> I mean, there are ways you can do things like that with existentials, but it's probably not a good idea.
11:59:42 <oisin888> dfeuer: Right - that makes sense to me - as an example, if I wanted two Commands = UpdateInput | ClientJoin which required two message types, Input and ClientName, respectively, I would model it like
11:59:54 <oisin888> data Command a = UpdateInput a ...?
12:00:04 <nshepperd> Command = Join JoinData | Leave LeaveData | ...
12:00:24 <oisin888> Oh, wow, that makes it a lot easier.
12:00:27 <oisin888> Thank you both!
12:00:32 <dfeuer> I would probably go with what nshepperd suggests, yeah.
12:01:22 <oisin888> It's funny, but the only pattern matching difference is a comma - which makes a huge change.
12:01:47 <Odda> ReinH: I think that link hit the nail on the head, thanks!
12:03:21 <Fuuzetsu> are k+n patterns still frowned upon?
12:03:35 <sinelaw> *frown*
12:03:43 <shachaf> They are no longer part of Haskell.
12:03:46 <dfeuer> int-e, your filterM paste has a missing xs on the rhs of various places. You inherited it from my error.
12:04:06 <int-e> dfeuer: had :)
12:04:08 <Fuuzetsu> OK well that solves that problem then
12:04:14 <nshepperd> let fn (foo+1) = bar?
12:04:42 <dfeuer> Aren't n+k patterns back now that GHC has all sorts of fancy machinery in the pattern system?
12:05:07 <Fuuzetsu> I guess I can just use a guard
12:05:12 <nshepperd> seems scary to try and match something that isn't a constructor
12:05:24 <quchen> dfeuer: If you really want n+k patterns I suggest you just re-enable the deprecated feature instead of going wild with pattern synonyms or stuff
12:05:31 <quchen> Step 2, feel dirty :>
12:05:35 <nshepperd> almost satanic
12:05:55 <quchen> nshepperd: 2 isn't a constructor, but "matching" it like "foo 3 = 42" is quite useful.
12:06:06 <quchen> So we still have "n patterns".
12:06:09 <dfeuer> quchen, I would guess it would probably require a  :+ operator or something to do it with the new machine?
12:06:12 <int-e> quchen: haha, was that intentional ...
12:06:22 <int-e> quchen: matching 2 as 3 will hardly ever work indeed.
12:06:45 <dfeuer> Unfortunately, pattern matching on floating point is allowed :-(
12:07:15 <quchen> dfeuer: That makes matching "0.1 + 0.2" even funnier.
12:08:01 <dfeuer> I think only Integral literals should be available for pattern matching.
12:08:14 <dfeuer> Let me restate taht....
12:08:26 <quchen> I think data constructors should also be matchable.
12:08:41 <dfeuer> Well yes, of course. And strings, and characters.
12:09:29 <quchen> And string-likes and list-likes.
12:09:35 <quchen> (IsList and IsString stuff)
12:09:50 <dfeuer> But numeric literals should only be matchable as Integral things, I think.
12:10:04 <Fuuzetsu> we have IsList?
12:10:06 <dfeuer> Because matching on floating point is icky.
12:10:41 <geekosaur> in 7.8, yes
12:11:05 <Fuuzetsu> I assume it lets me to match on : and [], what do I need to enable?
12:11:10 <quchen> Fuuzetsu: -XOverloadedLists
12:11:13 <Fuuzetsu> cool
12:11:16 <quchen> Maybe without the terminating s
12:11:20 <shachaf> > let f 3 = "yes"; f Otherwise = "no" in f 2
12:11:22 <lambdabot>  "yes"
12:11:25 <dfeuer> Because Haskell, unlike GHC, can generally maintain the fiction that data Integer = 0 | 1 | -1 | 2 | -2 ...
12:12:00 <quchen> dfeuer: The Eq constraint introduced would like to object :-þ
12:12:42 <quchen> Oh, you mean because Haskell demands Eq => Num
12:12:49 <quchen> Sneaky.
12:12:56 <dfeuer> Ugh.
12:13:42 <dfeuer> Num has been a horrible, horrible hack from the beginning.
12:14:57 <dfeuer> Num and Enum both should be shot.
12:15:26 <dfeuer> Enum should be (at least?) three different classes. And Num ... what the hell is a number?
12:16:04 <quchen> dfeuer: A Number is something you can add, subtract, multiply, negate and convert from an Integer. Whatever that means.
12:16:14 <geekosaur> Num-inous
12:17:41 <dfeuer> quchen, yeah, except that some of them can't be negated, and some of them are only partially convertable....
12:18:43 <quchen> let f x = x+x-x*(-x) :: (Multipliable a, Addable a, Subtractable a, Negatable a) => a
12:20:10 <dfeuer> quchen, it's a general mismatch between Haskell and math. The mathematician says that a ring consists of a set with two operations, each of which form monoids over the set, but Haskell says there's only one monoid instance per type....
12:20:18 <dfeuer> And so on.
12:20:35 <quchen> dfeuer: The problem with this is that Double doesn't obey a lot of laws from math.
12:21:02 <dfeuer> quchen, there's trouble also from Nat in various forms, which can't be negated.
12:21:37 <quchen> Don't get me wrong, I see your point. But you should also consider how tremendously useful floating point numbers are in practice.
12:21:48 <dfeuer> And even fromInteger :: Integer -> Int is problematic because it's either not total (as current Haskell) or not one-to-one.
12:22:19 <quchen> I think fromInteger is total; everything involving finite numbers is done mod (2^something).
12:22:22 <benzrf> int-e: can we get type families in lambdabot already ;-;
12:22:47 <dfeuer> quchen, oh, they're useful all right. But they're not normal numbers, and pattern matching on them is very wonky.
12:23:16 <dfeuer> > fromInteger (2^70)
12:23:17 <lambdabot>  1180591620717411303424
12:23:21 <dfeuer> > fromInteger (2^71)
12:23:22 <lambdabot>  2361183241434822606848
12:23:25 <dfeuer> > fromInteger (2^71)::Int
12:23:26 <lambdabot>  can't find file: L.hs
12:23:28 <dfeuer> > fromInteger (2^71)::Int
12:23:30 <lambdabot>  0
12:24:03 <dfeuer> I guess you're right quchen.
12:24:41 <quchen> Pattern matching on Double is probably a side effect of allowing Int, Integer and custom integer types to be matched against.
12:24:59 <quchen> I would put it into the "possible, but don't use it" region.
12:26:34 <tnks> so, is colon-prefixing special in Haskell for infixing type names?
12:26:46 <tnks> we think we just ran into that now. . . just double-verifying.
12:26:58 <quchen> Yes, leading colons on infix means "data constructor".
12:27:03 <quchen> colon*
12:27:49 <quchen> You can think of the colon as the only upper-case symbol in terms of the syntax.
12:28:38 <dfeuer> But GHC does a weird thing when you give  it a special option that lets you use *non-colon-prefixed* symbols as *type* constructors.
12:28:58 <dfeuer> Because symbols are useful for type constructors and much less useful for type variables.
12:29:08 <Odda> is there a way of getting hold of 'name' in data Test { name :: String }, through a string that is passed in? process :: String -> ... (like process "name" ...)
12:29:30 <dfeuer> Odda, I can't tell what you're asking.
12:29:42 <merijn> He want's a String to function mapping
12:29:54 <Sornaensis> how do I urlencode strings
12:29:56 <merijn> And now, not really
12:30:01 <merijn> s/now/no
12:30:07 <Odda> merijn: yeah, that's it
12:30:10 <Sornaensis> so that + symbols etc are preserved as escape codes
12:30:13 <ReinH> Odda: maybe you want a Map?
12:30:47 <ReinH> Sornaensis: http://hackage.haskell.org/package/HTTP-4000.0.7/docs/Network-HTTP-Base.html#3
12:30:57 <dfeuer> Oh. Yech. GHC has some weird dynamic stuff, but I don't know how any of that works.
12:31:20 <ReinH> I would not recommend using GHC's weird dynamic stuff.
12:31:32 <merijn> dfeuer: n+k patterns are still a GHC extension, but they're not in the report and no longer default
12:31:40 <Odda> ReinH: maybe, toying with the notion of having a 'payload' in data Event that is aware of EventType, that can invoke (or fail to) a function
12:31:43 <ReinH> merijn: n+k was removed though?
12:31:49 <merijn> ReinH: No
12:32:05 <merijn> Just do -XNPlusKPatterns (or whatever the name was)
12:32:13 <quchen> n+k was removed from Haskell in H10, but using an extension they're still available in GHC.
12:32:21 <quchen> For compatibility only, of course.
12:32:23 <merijn> They're no longer default and they're not Haskell2010, but they still exist
12:32:24 <Odda> (while I search the internet for a proper solution)
12:32:45 <dfeuer> merijn, I have no current plans to use them. I'm just thinking the concept is a better fit for Haskell *now* than it was when they were introduced.
12:32:51 <ReinH> Ah, they were removed in Haskell2010, but exist in GHC?
12:32:57 <merijn> Odda: What exactly are you trying to do?
12:33:04 <merijn> ReinH: No longer on by default in GHC either
12:33:10 <ReinH> merijn: yep
12:33:14 <merijn> ReinH: But yes
12:33:26 <ReinH> merijn: Well, now that I know that, I might rework my thing about natural induction to use them.
12:33:39 <monochrom> Odda: do not store a name of a function. that's indirect and full of XY problems. store the function itself, directly.
12:34:10 <ReinH> monochrom: the issue there is (de)serialization, no?
12:34:14 <Odda> merijn: a deserialied Event has a certain type, and that payload, in lack of a better term, knows how to call a method on the aggregate it should act on
12:34:43 <Odda> merijn: it's still the deserialization that throws me
12:34:47 <merijn> Odda: So what's wrong with "data Event = MyEvent1 | MyEvent2 | MyEvent3", etc?
12:35:17 <Sornaensis> thanks whoever linked that
12:35:41 <ReinH> Sornaensis: yw
12:35:43 <Odda> merijn: I haven't gotten my head around getting out back out of mongodb with the event intact and type aware
12:36:01 <ReinH> Odda: um, this is not an answer to your question, but are you using mongodb as a store of record for event sourcing?
12:36:37 <ReinH> mongodb is not consistent enough to be a store of record o_O
12:36:49 <ReinH> if it drops a single event on the floor your whole system is broken
12:36:56 <Odda> ReinH: Yeah, that's it. I was initially planning on using event store
12:37:15 <ReinH> I would strongly recommend against mongodb for this
12:37:42 <ReinH> OT, but I don't want you to build a broken system :/
12:37:43 <Odda> ReinH: Ok. What is the preferred solution for something like this?
12:38:09 * merijn would recommend against mongodb for anything except a cache, and even then...
12:38:19 <Odda> ReinH: You're right:)
12:38:34 <nicoo> merijn: Why not? It is webscale :>
12:38:53 <Odda> So how would a event sourcing solution look in Haskell? Using postgres?
12:38:59 <joelteon> the tls package used to have a specific record field for client certificates, what happened to that?
12:39:02 <Odda> and persistent perhaps?
12:39:03 <ReinH> Depends on your requirements, but something with a strong consistency guarantee is essential
12:40:09 <Odda> ReinH: yeah, for now it's just for learning, trying to get my head around porting stuff
12:40:20 <monochrom> /dev/null is webscale and more predictable than most systems.
12:40:28 <ReinH> monochrom: <3
12:40:39 <ReinH> PostgreSQL would certainly be a better choice than mongodb
12:40:47 <merijn> monochrom: It is not that we have /dev/null as a service!
12:40:51 <merijn> s/not/now
12:40:52 <Sindy> pong
12:40:52 <ReinH> So would a flat file, though.
12:41:04 <monochrom> /dev/zero if you prefer to get output :)
12:41:10 <ReinH> ha
12:41:11 <merijn> http://devnull-as-a-service.com/
12:41:24 <ReinH> merijn: <3
12:41:31 <benzrf> int-e: i could also go for some datakinds in lambdabot
12:43:12 -Sindy(~dalnet@5.46.214.84)-  www.superonline.eu/chat/
12:43:54 <benzrf> Sindy: pls no
12:43:57 <Fuuzetsu> foo <$> liftA3 Bar x y z -- this seems strange, is there a nice way to pull foo onto the RHS?
12:44:16 <Taneb> Anyone know of somewhere in the UK that does summer internships using Haskell?
12:44:26 <Taneb> Looking for something for next summer
12:44:52 <monochrom> thanks merijn :)
12:45:00 <Fuuzetsu> Taneb: probably a better chance to look for remote work
12:45:19 <Taneb> Fuuzetsu, no harm in asking :)
12:45:20 --- mode: ChanServ set +o monochrom
12:45:43 --- mode: monochrom set +b *!*@5.46.214.84
12:45:50 --- kick: Sindy was kicked by monochrom (Sindy)
12:45:58 <pjdelport> Fuuzetsu: liftA3 (foo . Bar) x y z ?
12:46:00 <benzrf> Fuuzetsu: compose it
12:46:02 <Odda> ReinH: just on a side note, but is this kind of drop fairly common on mongodb?
12:46:09 <Fuuzetsu> pjdelport: that doesn't work
12:46:15 <benzrf> Fuuzetsu: use a 3-compose
12:46:21 <benzrf> theres probably one in data.function somewhere
12:46:25 <Fuuzetsu> .:?
12:46:28 <pjdelport> True, yeah.
12:46:42 <benzrf> @hoogle (d -> e) -> (a -> b -> c -> d) -> (a -> b -> c -> e)
12:46:44 <ReinH> Odda: I'm not sure how common it is these days, but it does happen, and mongodb is *not* designed to be a store of record
12:46:45 <lambdabot> No results found
12:46:50 <pjdelport> I think you'll need .:. from that composition package
12:46:51 <benzrf> @nobotsnack
12:46:51 <lambdabot> :)
12:46:53 <merijn> Taneb: Look in Scotland
12:47:02 <Taneb> merijn, oh?
12:47:04 <quchen_> I heard they make compilers in Glasgow
12:47:10 <benzrf> Fuuzetsu: u could write a lambda
12:47:11 <merijn> Taneb: Bunch of universities doing haskell there
12:47:29 <merijn> Not sure they do internships, but you could try and see if anyone has money
12:47:32 <Fuuzetsu> benzrf: defeats the point, might as well have foo <$> then
12:47:45 <merijn> Taneb: Could always try getting an internship at MSR :)
12:47:55 <merijn> Taneb: I'd have a fun topic for you! ;)
12:48:01 <benzrf> Fuuzetsu: yep
12:48:08 * merijn mumbles something about -XImpredicativeTypes
12:48:09 <Taneb> merijn, I've checked, I don't think they like people who haven't at least started a PhD
12:48:12 <Fuuzetsu> merijn: it's not nice to push work onto interns!
12:49:10 <Taneb> And I'm only a little undergrad
12:49:17 <ReinH> A nice append-only store written in Haskell might be a fun and useful project, actually
12:49:21 <merijn> Fuuzetsu: I'm an intern myself...
12:50:51 --- mode: monochrom set -b *!*@5.46.214.84
12:50:55 <Taneb> merijn, are interns allowed to take littler interns?
12:50:55 --- mode: monochrom set -o monochrom
12:51:11 <monochrom> hrm, "it's interns all the way down"? :)
12:51:17 <Fuuzetsu> -XInternFamilies
12:52:06 <Fuuzetsu> 1 example, 1 failure
12:52:07 <Fuuzetsu> ;(
12:52:21 <agatam> Taneb: you don't want to be merijn's intern, he's writing C++ all day long :P
12:52:38 <Taneb> agatam, thanks for the heads up :)
12:53:23 <knyon> Anyone use Shake? I'm trying to create a rule that uses an environment variable. Conceptually, a rule like `"$HOME/foo" *> \out = ...`.
12:53:45 <Twey> Fuuzetsu: foo <$> Bar <$> x <*> y <*> z
12:53:56 <Twey> Oh wait, no.  ☹
12:54:02 <Fuuzetsu> that's even worse
12:54:34 <Fuuzetsu> it's OK I moved on from that now, I'm onto fixing runtime failures now
12:54:54 <gregnwosu> is this the correct channel for questions on cabal?
12:55:07 <monochrom> I googled for "shake builder". totally not what I meant, and totally right. :) it has to be "shake build system".
12:55:11 * hackagebot limp 0.3.0.0 - representation of Integer Linear Programs  http://hackage.haskell.org/package/limp-0.3.0.0 (amosrobinson)
12:55:13 * hackagebot limp-cbc 0.3.0.0 - bindings for integer linear programming solver Coin/CBC  http://hackage.haskell.org/package/limp-cbc-0.3.0.0 (amosrobinson)
12:55:26 <quchen_> There's also #cabal I think, but for basic questions you're fine here, gregnwosu
12:55:35 <Fuuzetsu> Pretty sure there is no #cabal
12:55:45 <quchen_> Hm, nevermind.
12:55:46 <Fuuzetsu> oh, must be a new channel
12:56:02 <Fuuzetsu> look at all those folk who joined it and never noticed it was dead and unpopulated ;P
12:56:06 <gregnwosu> thanks beaming to #cabal
12:56:07 <Twey> Fuuzetsu: (fmap . fmap . fmap) foo Bar <$> x <*> y <*> z
12:56:09 <luite_> Fuuzetsu: what was that problem with haddock? did they have a really old ghc snapshot labeled as 7.8.3 ?
12:56:28 <Fuuzetsu> luite_: yeah, turns out the guy reporting it was the GHC packager for Fedora and he packaged the wrong commit
12:56:39 <Fuuzetsu> so his GHC wasn't actually 7.8.3
12:57:00 <luite_> Fuuzetsu: the change happened a while ago so he must've been off by a fair margin....
12:57:33 <Fuuzetsu> the PatSyn change happened fairly soon before 7.8.3 release
12:57:48 <xelxebar> Anyone interested in Haskellizing a bit of math? Specifically, the summation in this link: http://math.stackexchange.com/questions/918494/nested-sum-encountered-in-maclaurin-expansion-of-e-x2.
12:57:58 <luite_> Fuuzetsu: oh ok, i might be thinking of the other change then
12:58:09 <luite_> anyway glad that it's not some really weird cpp issue :)
12:58:14 <Fuuzetsu> yes, as am I
12:58:20 <Fuuzetsu> CPP issues are so bad
12:59:03 <lhuang7`> hey guys, I am new to haskell and try to use pargma
12:59:06 <levi> Source preprocessors are of the devil. :P
12:59:09 <lhuang7> I got a question
12:59:38 <lhuang7`> how can I use pargma to run certain function depending on the dependencies version..
13:00:08 <Fuuzetsu> You can use CPP for that, not {-# LANGUAGE … #-} pragmas
13:01:00 <quchen_> Using LANGUAGE to call different functions is mauke territory, and should be only that.
13:02:12 <xelxebar> I hacked together a direct tree representation and then collapse over it, but it is really slow: http://lpaste.net/110465. Forgive the ugly code; I've just begun hacking at Haskell.
13:04:59 <polymer> @help
13:04:59 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:05:14 <polymer> @help list
13:05:14 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
13:05:52 <polymer> @list
13:05:52 <lambdabot> What module?  Try @listmodules for some ideas.
13:05:58 <polymer> @listmodules
13:05:58 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
13:06:12 <polymer> @list irc
13:06:12 <lambdabot> irc has no visible commands
13:06:20 <polymer> @list poll
13:06:20 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result poll-close poll-remove
13:07:49 <Fuuzetsu> @list haddock
13:07:49 <lambdabot> haddock provides: index
13:07:55 <Fuuzetsu> @haddock index
13:07:55 <lambdabot> Unknown command, try @list
13:08:08 <Fuuzetsu> whatever
13:12:26 <pavonia> @index head
13:12:26 <lambdabot> Data.List, Prelude
13:14:45 <nh2> can I have some biased opinions about what regex package I should use?
13:15:08 <nh2> it appears to me that all the regex packages are made by the same person
13:18:03 <joelteon> regex-tdfa is fast and pure haskell
13:18:09 <joelteon> regex-pcre is faster and not pure haskell
13:18:42 <nh2> joelteon: do they accept the same input? There tend to be 1000s of regex flavours
13:18:52 <joelteon> they all implement the classes in regex-base
13:19:21 <merijn> nh2: The usual opinion is to use a parser instead of regexes :)
13:19:26 <nh2> but those classes are only about what types they accept as regexes, not what is *inside* the regexes and how they are to be interpreted
13:19:36 <joelteon> but why would you want to know what's inside the regex
13:20:05 <nh2> merijn: I have a regular language and want the time and space guarantees of regular parsing
13:20:42 <mauke_> ... guarantees?
13:20:45 <nh2> joelteon: I mean: it doesn't say if they interpret the input as basic posix regex, extended posix regex, perl posix regex, perl posix regex with whatever extra features etc.
13:20:47 <merijn> Which guarantees?
13:21:00 <joelteon> nh2: I'm pretty sure the documentation pages do say so
13:21:09 <merijn> Also, getting attoparsec to have deterministic space consumption is pretty easy
13:21:16 <mauke_> "perl posix"?
13:21:40 <nh2> mauke_: sorry, perl regex of course
13:21:57 <mauke_> only perl has perl regex, so that one's out
13:22:12 <joelteon> well, regex-pcre has perl compatible regular expressions
13:22:36 <mauke_> also known as lpbd (like perl but different)
13:24:13 <geekosaur> pseudocompatible
13:25:47 <nh2> mauke_, merijn: linear time of text input length
13:26:41 <latk> I'm using persistent with postgres, and am getting an error "libpq: failed". Are there some tools to aid my diagnosis of this ?
13:26:55 <merijn> nh2: Attoparsec can easily do that if you don't write a backtracking parser
13:27:02 <mauke_> nh2: which regex engine guarantees that?
13:27:12 <merijn> nh2: Also, regex's totally need backtracking
13:28:01 <nh2> merijn: no, they don't need to backtrack if you don't have backreferences
13:28:33 <nh2> mauke_: if I write regexes I'm guaranteed not to accidentally do that
13:28:43 <mauke_> do what?
13:28:46 <jle`> generalize :: Monad m => Identity a -> m a
13:28:48 <jle`> should be a part of base
13:29:04 <mauke_> :t return . runIdentity
13:29:05 <lambdabot> Monad m => Identity b -> m b
13:29:12 <merijn> nh2: What? Yes they do...
13:29:18 <jle`> mauke_: yeah, but it should be a part of base ;_;
13:29:22 <mauke_> no
13:29:29 <merijn> jle`: mmorph?
13:29:35 <merijn> @hackage mmorph
13:29:36 <lambdabot> http://hackage.haskell.org/package/mmorph
13:29:37 <jle`> merijn: yeah, it's in mmorph
13:29:41 <merijn> jle`: Thank me later :)
13:29:46 <jle`> i feel like it's a fundamental part of what Identity represents
13:29:56 <jle`> or at least it should be in mtl/transformers
13:30:12 <jle`> wait, is Identity in base, or transformers?
13:30:30 <merijn> jle`: Base, I'm pretty sure
13:30:37 <avaritia> hmm how many concepts do i need to know to implement some haskell programs?
13:30:53 <jle`> avaritia: hm.  probably how to use a text editor
13:30:55 <mauke_> how do you count concepts?
13:31:01 <merijn> avaritia: Depends on what kind of program and how much you care about it's performance :p
13:31:02 <jle`> either an online or on a compuer
13:31:08 <avaritia> well lets say which key concepts do i need to know
13:31:10 <avaritia> apart from monads
13:31:15 <jle`> you don't need to know monads
13:31:16 <mauke_> you don't need monads
13:31:22 <jle`> i don't know how this idea got spread around
13:31:24 <avaritia> well i know monads anyways ;x
13:31:27 <latk> Is there some way to run a stack-trace from cabal ?
13:31:32 <latk> on exception
13:31:35 <jle`> avaritia: do you know how to use a computer?
13:31:42 <merijn> latk: You mean upon building
13:31:42 <avaritia> jle`: some may argue
13:31:47 <merijn> jle`: Not being very helpful, tbh
13:31:56 <jle`> hm. i'll back out :)
13:32:13 <mauke_> avaritia: main = putStr "Hello, world!\n"
13:32:17 <mauke_> that's concept #1
13:32:35 <mauke_> main = interact id  -- #2
13:32:52 <latk> merijn: er, possibly I do, maybe I'm confused with terminology. I want to get a stack-trace when an exception is raised, which presumably I have to enable at build time.
13:32:53 <avaritia> i'll rephrase which concepts will give me biggest boost of productivity/time spent learning
13:33:12 <mauke_> main = interact (unlines . map (show . length) . lines)
13:33:49 <avaritia> and if i want to code ui?
13:34:15 <hiptobecubic_> avaritia, patience and willingness to accept that it's not going to look like python or C++ are the main things that seem to differentiate successful haskell learners from the rest
13:34:48 <pablo|> avaritia: maybe Functional Reactive Programming
13:35:05 <avaritia> pablo|: anything apart from that?
13:35:08 <pablo|> avaritia: also, this list is amazing: http://dev.stephendiehl.com/hask/
13:35:33 <nh2> merijn: http://swtch.com/~rsc/regexp/regexp1.html
13:35:51 <avaritia> pablo|: thx
13:37:16 <hiptobecubic_> pablo|, i note that GUI programming isn't actually in that list.
13:37:41 <pablo|> hiptobecubic_: no, but a lot of other useful things are
13:37:47 <mauke_> nh2: that page is wrong
13:38:21 <nh2> mauke_: how so?
13:38:57 <mauke_> "In contrast, there are no regular expressions that are pathological for the Thompson NFA implementation."
13:39:15 <mauke_> yeah, try running /(([ab]{999}){999}){999}/ on that thing
13:39:23 <mauke_> make that 0,999 each
13:39:32 <mauke_> or maybe not
13:40:04 <justgage> Hi haskellers, I'm pretty new with Functional Programing in generel and I'm trying to wrap my head around Monads, I'm wondering what is their use? Is it to be an "adapter" to convert between two different types? Or what is it exactly?
13:40:28 <mauke_> justgage: each monad has a different use
13:41:10 <Taneb> justgage, monads are types that implement the Monad typeclass (a typeclass is kind of like an abstract class or an interface)
13:41:15 <merijn> Don't "try to understand monads", see: http://dev.stephendiehl.com/hask/#monads
13:41:15 <sipa> justgage: don't try to grasp "monads"
13:41:30 <sipa> justgage: grasp the IO type, the list type, the maybe type
13:41:43 <sipa> justgage: at some point you'll realize they have something in common
13:41:54 <mauke_> it's like birds. what *are* birds? we just don't know.
13:42:18 <jle`> justgage: you have useful types, that are all independent and useful in their own way, with their useful utility functions.  like any type.  sometimes some utility functions share some parallel properties, but that's t really that important at all...as much as the usefulness of the utility functions each for their own type
13:42:20 <justgage> sipa: thanks for the link
13:42:29 <justgage> er merijn I mean
13:42:42 <jle`> justgage: "understanding monads" is not a practical or meaningful goal :)
13:42:49 <sipa> i learnt about monads in theory, it didn't help
13:43:04 <sipa> start using some of them, and yoy'll get it
13:43:32 <jle`> use the types not because they're monads, but because they're useful types :P
13:43:33 <justgage> So basically your saying they are too abstract to really try to "define" them, it's just easier to understand them in application?
13:44:14 <mauke_> monads are pointy functors with a join
13:44:31 <simon> mauke_, tacoidal?
13:44:31 <Fuuzetsu> how can I stitch 4x Word8 into Word32?
13:44:31 <jle`> justgage: not even that.  using types helps you understand types in application.  using binary trees help you learn binary trees.  their monad-ness affects their usefulness very little (beside sproviding generic functions)
13:44:54 <mgaare> there should be a competition for who can make the worst "understanding monads" tutorial
13:44:55 <dolio> They're not too abstract to explain in general, but most people probably don't come to understand them via hearing the explanation.
13:45:00 <mauke_> it's not technically hard to define monads, but that doesn't really help your intuition
13:45:40 <jle`> justgage: you're just going to be using a lot of objects and types that are very useful, and useful on their own right.  every object/type is a separately useful thing for different purposes.  Monad is a pattern where you can sort of match up some of the API's together, but that doesn't change that the API is useful in and of itself
13:45:58 <mauke_> Fuuzetsu: fromIntegral them, then multiply and add (or shift and bit-or)
13:46:07 <RchrdB> Fuuzetsu, in C I'd do it with addition, and shifts. The bit shift functions are in Data.Bits
13:46:19 <RchrdB> *same as in C, I mean
13:47:03 <jle`> justgage: you can define monad pretty easily, but it doesn't really help in practice.  monad-ness doesn't make the type useful.  the type makes the type useful
13:47:19 <dolio> mauke_: Also, I imagine it might depend on what 'pathological' means, and what you have written may not be considered a 'regular expression'.
13:47:38 <justgage> Ok thanks guys, well I guess I'll just get working on learning about typeclasses/FP/haskell in generel
13:47:55 <mauke_> dolio: it's a regex in practice
13:47:57 <dolio> I.E. your notation is illegal, and when you write out the regular expression it means, the behavior is no longer pathological.
13:48:06 <mauke_> illegal?!
13:48:24 <RchrdB> mauke_, (fwiw, (+) and (.|.) are identical when there are definitely no coinciding 1 digits in either number.
13:48:45 <Fuuzetsu> ok I think I can abuse conversions in bytestring to do what I want instead
13:48:57 <RchrdB> wait, why am I telling you that? Oh. Because + and shiftL is just as good as | and shiftL. =)
13:49:17 <mauke_> and shiftL is just as good as *
13:49:42 <RchrdB> quite
13:49:43 <dolio> mauke_: Yeah. You used notation that is 1 billion times shorter than the regular expression it means. :)
13:50:13 <dolio> Clearly cheating.
13:50:24 <cite-reader> I still like the bitwise ops when I'm shuffling bits together. It more clearly expresses what I *mean* even when there's other ways to do the same thing.
13:50:33 <mauke_> using regular expressions as search patterns is clearly cheating, too
13:50:43 <mauke_> they describe sets of strings
13:52:11 <mauke_> dolio: the article isn't talking about pure theory. it's arguing that perl can and should use the thompson algorithm to do whatever it does in practice
13:52:20 <dolio> Ah.
13:52:38 <dolio> Is that even possible?
13:52:50 <mauke_> depends
13:53:05 <mauke_> what exactly does your question mean?
13:53:06 <mauke_> :-)
13:53:54 <dolio> It means, does Thompson NFA include all the non-regular stuff that perl regexes can actuall do? Or was it just arguing that it should detect regexes that can be handled by Thompson NFA and conditionally use it then?
13:54:48 <dspies> I'm getting an error when I try to install scion-browser
13:54:53 <RchrdB> The latter, I think, because backreferences are unlimitedly evil.
13:54:54 <lpaste_> dspies pasted “Failure when installing scion-browser” at http://lpaste.net/110467
13:55:57 <pablo|> btw, is there any really good ui library for haskell? Bindings for foreign libraries are just imperative code in the IO monad. I'd prefer declarative approach, but Haskell native libraries tend to lack features
13:56:50 <mauke_> dolio: there's a lot of handwaving. the only major issue it acknowledges is "Even so, it would be reasonable to use Thompson's NFA simulation for most regular expressions, and only bring out backtracking when it is needed. A particularly clever implementation could combine the two, resorting to backtracking only to accommodate the backreferences."
13:57:12 <dspies> why is the lpaste page blank?
13:57:15 <silver> I think it is hard to implement and maintain UI libraries, also kinda boring
13:57:19 <sinelaw> pablo|, conal elliot has done some work in that direction. what sort of UI are you tring to build
13:57:56 <pablo|> sinelaw: not building anything particular
13:57:56 <lpaste_> dspies pasted “Failure when installing scion-browser” at http://lpaste.net/110470
13:57:57 <mauke_> dolio: I don't think the author understands exactly how non-regular "regexes" actually are
13:58:14 <pablo|> sinelaw: in C++ i would just use Qt
13:58:21 <dolio> pablo|: If you're okay with web-gui, there's threepenny and reactive banana.
13:58:31 <pablo|> sinelaw: i wonder if there is some library that could compete with that
13:59:05 <dolio> mauke_: Heh.
13:59:33 <mauke_> it starts at AB|A vs. A|AB and only gets worse from there
13:59:34 <dspies> I'll try pasting just the error part
14:00:33 <lpaste_> dspies pasted “Failure when installing scion-browser” at http://lpaste.net/110471
14:00:46 <dspies> There it is
14:01:11 <dspies> hello?
14:02:14 <athan> There isn't a cons for vectors, is there :(
14:02:37 <dolio> There might be. It's a pretty bad operation, though.
14:02:55 <dspies> > kimberling = let interleave (x : xs) ys = x : interleave ys xs in interleave [1..] kimberling
14:02:56 <lambdabot>  <hint>:1:12: parse error on input ‘=’
14:03:16 <dspies> > let kimberling = let interleave (x : xs) ys = x : interleave ys xs in interleave [1..] kimberling in kimberling
14:03:18 <lambdabot>  [1,1,2,1,3,2,4,1,5,3,6,2,7,4,8,1,9,5,10,3,11,6,12,2,13,7,14,4,15,8,16,1,17,9...
14:03:42 <dolio> Data.Vector.Generic.cons
14:04:01 <Peaker> merijn: ok, posted proposal to haskell-libs
14:04:02 <dolio> Note that it's O(n).
14:04:08 <merijn> Peaker: \o/
14:04:11 <Peaker> (it's my first mail there, so not sure if I'm following the rules properly)
14:04:21 <merijn> Peaker: ha
14:04:26 <merijn> Peaker: rules :p
14:04:30 <pablo|> > rules
14:04:31 <lambdabot>  Not in scope: ‘rules’
14:04:49 <merijn> Peaker: The entire list is pretty ad hoc and informal :)
14:04:50 <dspies> anyone? Please? I've already re-installed cabal like 6 times today
14:05:13 <dspies> Does haskell actually work or is it just a joke?
14:05:37 <Peaker> merijn: it seems all the mails follow some conventions though :)
14:05:44 <mauke_> dspies: haskell is a purely fictional programming language
14:06:03 <dspies> mauke_: So I'm coming to believe
14:06:16 <dspies> Why don't things ever compile?
14:06:33 <Peaker> dspies: that's not a cabal problem
14:06:37 <Peaker> dspies: seems like a package problem
14:06:44 <friden> dspies: when you least expect it, it will
14:06:53 <dspies> Peaker: so how do I install scion-browser then?
14:07:00 <MutsuZ> selam
14:07:05 <merijn> dspies: Ask whoever develops scion-browser?
14:07:21 <pablo|> you could try a different version
14:07:23 <merijn> I dunno why some random package happens to contain broken haskell code...
14:07:29 <Caly22>  Hi! I give you some videos. I hope you like! http://bit.ly/1mFMmyS
14:07:45 <Peaker> dspies: trying to install it in a sandbox now
14:07:54 <Peaker> dspies: will see if I get the same problem or if I can help
14:08:13 <Peaker> dspies: what ghc version are you on?
14:08:20 <dspies> 7.8.3
14:08:53 <Peaker> ok, I'm on 7.8.2, it'll probably behave the same :)
14:09:16 <Peaker> dspies: if you use cabal sandboxes you won't have to "reinstall cabal"
14:09:32 <merijn> I don't see how reinstall cabal could ever fix a broken package
14:09:51 <dspies> If I install things in a different order it will choose different versions
14:09:54 <Peaker> merijn: sometimes it prevents the "butterfly problem"
14:09:58 <dspies> and this isn't the problem I've had all day
14:10:05 <dspies> it's just the latest one
14:10:20 * hackagebot criterion 1.0.1.0 - Robust, reliable performance measurement and analysis  http://hackage.haskell.org/package/criterion-1.0.1.0 (BryanOSullivan)
14:10:44 <Peaker> dspies: well, cabal problems are improving with time, and a few tricks (like "--constraint" "--allow-newer", "--dry-run", "-v") let you work around most of the trouble. But it's not smooth sailing indeed
14:11:11 <merijn> Peaker: Those are not cabal problems, they are package problems
14:11:22 <dspies> I'm just trying to install the three requirements to use EclipseFP: scion-browser, buildwrapper, and hoogle
14:11:34 <dspies> I finally got to buildwrapper and hoogle
14:11:39 <dspies> so just one left to go
14:11:49 <merijn> People should stop blaming poor cabal for problems in their dependencies. Cabal hell is almost entirely eliminated
14:12:14 <dspies> If it manages to install in a sandbox, maybe I can just get eclipse to use the sandboxed version
14:12:19 <sshine> one cabal hell for me is that I'm trying to install pandoc, but my computer gets so hot that it shuts down.
14:12:29 <merijn> sshine: Also not cabal hell
14:12:34 <Peaker> merijn: Well, lots and lots of the trouble are because of th e"butterfly problem"
14:12:48 <Peaker> merijn: it's more of a ghc-pkg problem than a cabal problem, perhaps, but that's not an important distinction
14:12:57 <merijn> People these days throw around "cabal hell" for every time a "cabal" command doesn't produce the result they wanted...
14:13:17 <Peaker> merijn: also, signature imports/exports (ala backpack) rather than version deps would go a long way
14:13:42 <merijn> Cabal hell is the term for when cabal would silently upgrade packages and silently break/corrupt half your package database
14:14:09 <merijn> These days the only real problem is "this package has an impossible or really hard dependency graph and cabal gives up on finding a solution"
14:14:51 <Peaker> merijn: but if you envision a more powerful system than cabal, many of the "package problems" would go away
14:14:52 <SwashBuckla> c_wraith: this is now fixed! https://github.com/bos/criterion/issues/61
14:14:53 <dspies> or better: it finds a solution using all packages from back in the middle ages and now you can't install anything else
14:15:06 <merijn> Peaker: Sure, backpack will be really cool :)
14:15:06 <Peaker> merijn: a major problem still is "this requires unsafe reinstalls, screw you"
14:15:28 <merijn> Peaker: But blaming that on cabal is unfair, it's not cabal's fault :)
14:15:34 <Peaker> whose fault is it?
14:15:39 <Peaker> ghc-pkg?
14:15:43 <merijn> The ecosystem/package authors
14:15:49 <Peaker> I disagree
14:16:28 <Peaker> C depends on B==1 and A<1.    D depends on B==1 and A>1
14:16:39 <Peaker> Nothing here is unreasonable in any of the packages
14:16:53 <merijn> Peaker: Right, they're just incompatible
14:17:01 <merijn> That's not cabal's fault
14:17:02 <Peaker> merijn: but not inherently incompatible
14:17:11 <pablo|> you could maybe install two versions of A
14:17:12 <Peaker> I mean: B depends on A-any
14:17:18 <pablo|> in different slots
14:17:21 <Peaker> merijn: you want to have C and D installed independently
14:17:28 <merijn> Peaker: Perhaps not, but that requires a dependency system more complex than what cabal/GHC can handle
14:17:31 <Peaker> merijn: but you can't because B==1 can only be installed once
14:17:49 <lpvb> cabal started installing my binaries to /Users/lpvb/Library/Haskell/bin. How can I move it back to /Users/lpvb/.cabal/bin?
14:17:50 <merijn> Peaker: Right, because GHC can't deal with anything else
14:17:50 <Peaker> you want to install B==1,A<1   and separately: B==1,A>1
14:17:59 <Peaker> so it's ok with you if I blame GHC? :)
14:18:14 <Peaker> because this GHC problem is the source of tons of what is named "cabal hell"
14:18:16 <atota> is it possible to cross compile a reasonbale complex haskell program(not ghc) for another platform?
14:18:29 <jfischoff> ghc-pkg is to blame, but cabal could explain the situation better
14:18:50 <jfischoff> additionally have the ability to recursively uninstall and reinstall would be an “ok” stop gap
14:19:10 <Peaker> well, I'm fine with people blaming "cabal" as a code-name for "Haskell package management", whether the actual part responsible is "cabal" or "ghc-pkg"
14:19:13 <dspies> just finished trying to install in a sandbox, same problem still
14:19:18 * jfischoff nods
14:19:50 <Peaker> and thus "cabal hell" is still a real problem, but we may call it more accurately "ghc hell" or "GNU/Cabal-GHC hell" :)
14:19:57 <pablo|> cabal is a good build system
14:20:04 <jfischoff> yes it is
14:20:04 <pablo|> package manager.... not so much
14:20:11 <jfischoff> it is fine
14:20:13 <Peaker> It's not a very good build system :(
14:20:21 <Peaker> "cabal build" takes *seconds* before it invokes ghc to build stuff
14:20:25 <Peaker> so slow :(
14:20:43 <Peaker> I end up using "cabal build -v" just so I can copy&paste the "ghc" command to run it faster
14:20:46 <jfischoff> yeah I meant it is a good package manager but the competition is not that great
14:21:04 <Peaker> the cabal commands are soo slow
14:21:07 <luite_> Peaker: imagine compiling that thing to js and running that on node.js :p
14:21:24 <Fuuzetsu> WEB SCALE
14:21:26 <Fuuzetsu> ASYNC
14:21:37 <jfischoff> There is a lot of low hanging fruit in the cabal world
14:21:46 <luite_> Fuuzetsu: hehe yeah, but somewhat sluggish. it's what ghcjs does
14:22:03 <jfischoff> at work we only really use the solver
14:22:19 <jfischoff> we parse the output of -v3 to learn the package versions
14:22:26 <jfischoff> and use our own build system
14:22:35 <jfischoff> so I agree with Peaker, it is slow
14:22:46 <monochrom> heh
14:22:50 <luite_> hmm
14:23:09 <Peaker> related point: what makes GHC (even at -O0) so slow, compared with other typed language compilers? (Go, D, etc)
14:23:18 <luite_> jfischoff: i wonder how much work that was to build, compared to improving cabal :)
14:23:19 <monochrom> to be fair, the dependency chasing problem is NP-hard
14:23:22 <Peaker> Compilation is a major bottleneck of my development cycles
14:23:38 <Fuuzetsu> maybe GHC works harder ;)
14:23:41 <Peaker> monochrom: but that's the part almost nobody complains about!
14:23:49 <jfischoff> luite_: I would roll some of our scripts into cabal somehow
14:23:53 <luite_> monochrom: cabal build doesn't have to resolve though, usually
14:24:09 <Peaker> do Haskell's type system features really cost that much more to run?
14:24:45 <levi> It would be interesting to see a profiler output of which compile phases end up taking most of the time in a big build.
14:24:59 <monochrom> type inference is quite a bit harder than type checking
14:25:11 <Peaker> "Compiling Language.Haskell.Exts.Annotated.Syntax" <-- for more than 20 seconds just now!
14:25:36 <Fuuzetsu> haskell-src-exts takes forever
14:25:39 <monochrom> -O0 also does some rewrites despite -O0
14:25:41 <Peaker> monochrom: I think the type inference/checking part is actually cheap
14:25:54 <dspies> How do I contact the developer.  I found his GitHub page and his blog, but no email address
14:26:03 <Peaker> (perhaps not as cheap as in other languages, but not the expensive part)
14:26:07 <Peaker> dspies: of scion-browser?
14:26:12 <dspies> Peaker: yes
14:26:17 <Fuuzetsu> dspies: go one one of his commits and stick .patch after the URL
14:26:23 <Fuuzetsu> it should reveal his e-mail
14:26:26 <Peaker> dspies: make a pull request at https://github.com/JPMoresmau/scion-class-browser ?
14:26:53 <Peaker> Fuuzetsu: neat trick!
14:27:05 <Fuuzetsu> one weird trick that makes developers HATE spammers!
14:27:24 <merijn> Peaker: GHC fakes whole program optimisation with aggressive cross-module/package inlining
14:27:25 <levi> Haskell tends to be pretty high-level code compared to Go/D, and GHC seems to be organized to be clear and to enable fancy optimizations rather than to be fast at compiling.
14:27:32 <Peaker> compiling haskell-src-exts is making my laptop an oven
14:27:33 <merijn> Peaker: Which means compilation is really slow
14:27:39 <Peaker> merijn: at -O0?
14:27:45 <merijn> Ah, I dunno
14:28:03 <merijn> There's some things (like records with large number of fields) that are known to make GHC slow
14:28:25 <levi> One of the primary goals of Go was to be fast to compile.
14:28:29 <merijn> Peaker: Is the problem that compilation is slow when you only wanna typecheck?
14:28:46 <Fuuzetsu> levi: is that so you can find out faster at runtime that your program is broken?
14:29:23 <levi> Fuuzetsu: I'm sure that the typical C-like language development cycle was a motivating factor, yeah.
14:29:34 <merijn> Peaker: 'cause if so, you should use -fno-code
14:29:42 <merijn> Peaker: Also, if you think GHC is slow...
14:29:45 <Peaker> merijn: but that doesn't generate the .hi files needed to type-check the next modules!
14:30:25 <merijn> Peaker: My current (fairly small!) C++ code base takes >5 mins to compile on a beefy cluster node
14:30:40 <Peaker> merijn: C code is much better in that regard, but also very slow. But why compare to the worst?
14:30:46 <Peaker> merijn: Compare to D, Go, Java, ..
14:30:47 <levi> And as D was written by a compiler writer, compile speed was definitely a factor in its language design as well.
14:31:10 <Peaker> levi: I don't see what language features make a language slow or fast to compile (without optimizations, at least)
14:31:25 <Peaker> The differences seem negligible
14:31:31 <Peaker> but the compile time differences are huge
14:32:51 <athan> Hey guys, I think I came up with a new list combinator, im not sure though... I call it "chainWhile": http://lpaste.net/110474
14:33:17 <merijn> athan: Looks like monad-loops?
14:33:31 <Fuuzetsu> athan: Warning: use camelCase
14:33:39 <athan> :S
14:33:42 <levi> Peaker: Well, take C++ as a dysfunctional example of how language features can affect compile time negatively.
14:33:46 <athan> merijn: I'm not sure
14:33:53 <athan> Fuuzetsu: NEVAAAA___!!!!
14:34:27 <Fuuzetsu> pointless repetition of ‘n’
14:34:38 <athan> I thought it would make it more readable...
14:34:40 <merijn> athan: Also, you can implement it in two functions
14:34:42 <Fuuzetsu> you could save 3 characters!
14:34:50 <athan> merijn: !
14:35:09 <athan> Fuuzetsu: Yi keeps crashing when I paste in >10 lines :/
14:35:15 <merijn> :t \p f -> takeWhile p . iterate f
14:35:16 <lambdabot> (a -> Bool) -> (a -> a) -> a -> [a]
14:35:29 <merijn> bam! :)
14:35:29 <athan> merijn: Nice!!
14:35:36 <athan> too cool, thank you!!
14:35:38 <mauke_> pl might abominate that nicely
14:35:38 <Fuuzetsu> athan: likely, give me the lines
14:35:49 <Fuuzetsu> actually open an issue on GitHub
14:36:24 <sshine> @pl \p f -> takeWhile p . iterate f
14:36:24 <lambdabot> (. iterate) . (.) . takeWhile
14:36:27 <athan> Fuuzetsu: will do, I'll get to it tomorrow
14:36:31 <Fuuzetsu> ok great
14:36:38 <pablo|> p = const False
14:36:40 <Fuuzetsu> we have a lot of problems and not a lot of hackers ;/
14:36:55 <athan> Fuuzetsu: I'm no hacker :#
14:36:58 <pablo|> chainWhile p f a = [a]
14:37:04 <Fuuzetsu> become one by hacking Yi ;P
14:37:11 <pablo|> (\p f -> takeWhile p . iterate f) = []
14:37:13 <Peaker> levi: mostly the #include vs. import thing is very understandable
14:37:21 <Peaker> levi: #include is terrible for compile times. But Haskell has import, not #include
14:37:24 <Peaker> levi: so it can be fast
14:37:42 <Peaker> levi: Also C++ unboxes everything (which I love, btw), which hurts compile times, but Haskell doesn't
14:37:59 <Peaker> It does seem Haskell makes all the right choices that enable fast compilation (except inference, but that's cheap anyway!) and yet compile times are horrid
14:38:11 <Peaker> I'm pretty sure that "deriving" is terribly slow in Haskell
14:38:23 <Fuuzetsu> is there an easy way to ask ‘how much memory is allocated to this thing?’
14:38:41 <Fuuzetsu> (I realise sharing &c makes this hard to answer well)
14:39:06 <Peaker> Fuuzetsu: perhaps the Vacuum stuff?
14:39:39 <kmspriyatham> are there any small-ish haskell projects to work on?
14:40:21 <levi> Peaker: Compiling Haskell (at least the way GHC does it) involves a lot of desugaring and transformation steps that Go/D/Java don't have.
14:40:48 <Peaker> levi: I am almost sure that the costs aren't there, though
14:41:04 <Fuuzetsu> Peaker: interesting, going to try out vacuum-cairo
14:41:05 <Peaker> (desugaring and the close-to-syntax transforms are really cheap, source files are small)
14:41:27 <Peaker> levi: not sure what transformation steps are involved
14:42:34 <Fuuzetsu> …or I would if its dependency wasn't marked as broken, zzz
14:42:34 <levi> I dunno, that's a lot of tree-walking. You can mostly get to IR in a language like Go/D/Java without ever building a single intermediate representation.
14:43:14 <Peaker> dspies: finally hit your error!
14:43:36 <epta> > let x :: IO (Maybe a) -> IO (Maybe a) -> IO (Maybe a); x f g = do { resf <- f; case resf of Just r -> return $ Just r; Nothing -> g }
14:43:38 <lambdabot>  not an expression: ‘let x :: IO (Maybe a) -> IO (Maybe a) -> IO (Maybe a); x...
14:43:45 <epta> How to generalize it a litle bit?
14:43:49 <dspies> Peaker: Good to know, it's not just me
14:44:11 <Peaker> dspies: I see it uses opaque template haskell there :(
14:44:11 <merijn> epta: MaybeT?
14:44:22 <merijn> @umtl MaybeT IO a
14:44:22 <lambdabot> IO (Maybe a)
14:44:39 <shachaf> merijn: Does MaybeT have some sort of "catch"?
14:45:02 <Qfwfq> Just . fromMaybe, I guess?
14:45:03 <merijn> shachaf: In what way?
14:45:24 * hackagebot leveldb-haskell 0.3.1 - Haskell bindings to LevelDB  http://hackage.haskell.org/package/leveldb-haskell-0.3.1 (KimAltintop)
14:45:48 <epta> merijn: maybe, i dunno. How will stuff inside {} look like in that case?
14:46:20 <levi> Peaker: Everything has to go to Core, then through Core-to-Core transformations, then to STG, and then through one of the codegen paths.
14:46:28 <shachaf> merijn: Something like catch for a typical exception monad, except without an argument?
14:46:34 <shachaf> It would look a lot like what epta wrote.
14:47:25 <merijn> oh, good point
14:47:28 <levi> Peaker: I have no idea if that the primary culprit in compile time differences, but I doubt it's a trivial difference.
14:47:39 <merijn> I guess MaybeT doesn't really help here
14:47:54 <Peaker> shachaf: instance MonadError e m => MonadError e (MaybeT m)   Defined in Control.Monad.Error.Class'.  has: catchError :: m a -> (e -> m a) -> m a
14:48:39 <pablo|> shachaf: what would catch do? check if some value is Nothing?
14:48:39 <shachaf> Peaker: That doesn't look like it does what I want.
14:49:04 <monochrom> MaybeT has a mplus, too
14:49:14 <Peaker> shachaf: oops, it just forwards it to the inner monad
14:49:14 <merijn> oh!
14:49:15 <shachaf> Oh, maybe what I want is just mplus.
14:49:18 <d-snp> :( there's apparently a bug in cabal that prevents people from installing packages, and it's been fixed and merged into master for a month, but they still haven't released it :S
14:49:18 <merijn> monochrom++
14:49:19 <shachaf> monochrom++
14:49:24 <monochrom> \∩/
14:49:44 <d-snp> and for some reason you can't uninstall a cabal package? it makes no sense :(
14:49:47 <merijn> Yeah, I think epta's code is just mplus for MaybeT?
14:50:04 <merijn> d-snp: Because cabal doesn't track installed packages, it uses ghc's package database
14:50:05 <shachaf> Of course, <|> is a better name.
14:50:14 <merijn> d-snp: Use "ghc-pkg unregister"
14:50:27 <polymer> C++ has multiple implmenetations of sequences with different performance characteristics, using iterators as a common interface. Does haskell also have multiple datastructures with different performance characteristics? And if so, how does the standard library try to maintain a common interface for the different datastructures?
14:50:30 <merijn> d-snp: That doesn't delete the files, but makes ghc forget the package exists
14:50:41 <shachaf> MonadPlus is a monoid in two different categories of endofunctors!
14:50:42 <Peaker> dspies: The TH there is annoying and broken, not sure how to fix it, but I guess if you -ddump-splices you can examine the generated code
14:51:10 <d-snp> merijn: my packages got installed into ~/.cabal, and ghc-pkg unregister doesn't find it
14:51:15 <shachaf> I mean, an instance of MonadPlus.
14:51:16 <Peaker> polymer: There are some common interfaces, but they don't cover everything you might want to do
14:51:18 <Qfwfq> monochrom++
14:51:26 <merijn> d-snp: Then you broke something pretty badly...
14:51:27 <Peaker> polymer: if it's just iteration, then that's covered (Functor, Foldable, Traversable)
14:51:29 <dspies> Does anyone else here use EclipseFP?
14:51:33 * monochrom is full of wisdom :)
14:51:45 <Peaker> polymer: (though only for polymorphic containers, not monomorphic ones)
14:52:16 <pablo|> there is MonoFoldable etc
14:52:21 <pablo|> and lenses
14:52:27 <shachaf> MonoFoldable is kind of awful. :-(
14:52:37 <merijn> polymer: There's not really something like that in haskell, as the notion of iterators (like those in C++) doesn't make as much sense in an immutable language
14:52:41 <monochrom> please don't fold up monochrom!
14:52:48 <dspies> What do people use for development then? Is there anything as good as EclipseFP?
14:52:56 <joelteon> vim
14:53:06 <merijn> dspies: Most people here vim/emacs, and some others use sublime
14:53:10 <pablo|> i wanted to use MonoTraversable once, then realized i can just use a Traversal from lens
14:53:17 <merijn> Or whatever they're already comfortable with
14:53:29 <dspies> How do you create a multi-file project in emacs (I've asked this before with no satisfactory answers)?
14:54:13 <polymer> merijn: Well the fact that iterators are mutable isn't the important part, what's important is that sequences are essentially functions from integers.
14:55:07 <sshine> dspies, I just open the different files.
14:55:16 <polymer> Peaker: I suppose I was less worried about the current state in practice, and more worried about how you would solve these sorts of problems in Haskell. So if iteration is covered, that's awesome. Can you link to a discussion that shows how you would use a common interface for arrays vs lists in haskell?
14:55:20 <sinelaw> is there something like Show but that outputs nicer  (e.g. indented) output?
14:55:25 <pablo|> polymer: so, a function from integers is basically a list, thats Foldable!
14:55:35 <monochrom> dspies, I have very low expectations. therefore, I don't require my environment to be "project-aware". I just have it open multiple files, no frills. if this is lower than what you mean, then I don't know how to do it.
14:55:42 <dspies> Can emacs handle the setup and .cabal files automatically?
14:56:06 <Peaker> polymer: I don't know about a link.. but both could for example be instances of Functor and Foldable
14:56:17 <pablo|> polymer: http://www.haskell.org/haskellwiki/Typeclassopedia
14:56:27 <polymer> Thanks!
14:57:00 <dspies> Can I get emacs to underline or highlight lines where compilation fails?
14:57:01 <pablo|> um, thats for foldable etc
14:57:28 <monochrom> yes, that one is done by haskell-mode
14:57:46 <dspies> monochrom: but haskell-mode only seems to be able to work with single-file projects
14:58:03 <dspies> monochron: How do I make haskell-mode aware of the other files in my project?
14:58:10 <monochrom> again, I do not know what that means, and probably don't want to know.
14:58:38 <dspies> monochrom: If one module depends on others, then it can't be compiled in a vacuum
14:58:56 <Peaker> dspies: install flycheck
14:59:08 <monochrom> all I know, haskell-mode can embed ghci, and when embedded ghci contains an error message, then clicking that error message brings me to the line referred to.
14:59:10 <Peaker> dspies: it has Haskell support
14:59:18 <Peaker> dspies: and shows bad lines (better yet, bad tokens in lines)
14:59:21 <chrisdone> dfeuer: you need to specify the same author as your irc nick in the channel you want to announce in. it's a simple way to avoid announcer spam
14:59:58 <monochrom> ghci knows how to load interdependent modules.
15:00:23 <merijn> polymer: Most types essentially implement map, for the polymorphic types (like vector, array and list) this just becomes fmap. For monomorphic containers like ByteString, unboxed vectors, etc. they tend to just have their own map
15:00:39 <merijn> :t Data.ByteString.map
15:00:40 <lambdabot> (Word8 -> Word8) -> BSC.ByteString -> BSC.ByteString
15:01:44 <merijn> polymer: In general iteration tends to always look like one of a few operations (e.g. map, fold, filter) and only the types change (a little)
15:02:26 <Peaker> note C++ iterators support various interesting mutations and Haskell doesn't generalize on such a notion (quite rare in the Haskell world)
15:02:41 <chrisdone> peaker: D's iterators too
15:02:56 <polymer> One more question, Suppose I didn't know that the foldable type class existed, and somebody came along and saw my code, but noticed that it would be an excellent candidate for the foldable type class. Assuming they couldn't change my code, how hard would it be for them to make it recognizable as a valid instance of foldable?
15:03:09 <pablo|> a zipper is pretty similar to a C++ iterator
15:03:35 <shachaf> polymer: It would be an orphan instance, which isn't very good.
15:03:42 <shachaf> Because what if two different people did the same thing?
15:03:45 <Peaker> polymer: they can make an "orphan instance" for Foldable of your data-type, but some of the Haskell community would frown upon that
15:03:58 <Peaker> shachaf: then the eventual linkage should get an error?
15:04:05 <Peaker> (that would be a nice solution)
15:04:51 <shachaf> Peaker: Sure, that's what happens when you try to import two modules that define the same instance.
15:05:06 <dolio> Except in GHC.
15:06:05 <Peaker> shachaf: a compile time error is not that scary in that case because it is a true problem
15:06:12 <Peaker> but inability to define orphans is also a true problem
15:06:22 <Peaker> so it's really nice to be able to define them and get errors if conflicts arise
15:06:50 <shachaf> Well, you can define orphans.
15:06:58 <L8D> orphans!
15:08:09 <monochrom> it is not hard at all for the someone to submit a patch that includes the instance code, thereby averting an orphan instance crisis.
15:08:46 <bezirg> hi ppl, so I was thinking abt haskell (GHC) green threads. Let's say we have 10 threads running and communicating with each other. Some times these threads become blocked waiting on mvars. Is there a way to keep track of how much time they are actually unblocked?  Like a timer. If it is possible, do u think it adds a lot of overhead?
15:09:01 <monochrom> or s/patch/pull request/ if patch is too old-school for you
15:10:46 <AndChat|600084> Is this just my ignorance, or is using filterM with IO or strict ST problematic? It *looks*, at least, like it doesn't do any actual filtering until it's gone through the whole list and run the supplied predicate computation for each.
15:11:15 <monochrom> @type filterM
15:11:17 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
15:11:52 <dspies> Is there a hello-world tutorial for haskell-mode?
15:12:01 <monochrom> how do you know the order of those events you said?
15:12:14 <polymer> orphan instance is a sad name...The goal of my questions, is to find a language feature which assumes as little as possible. That is, if I define a function on a function of integers. Then it should work on anything which can be interpreted as a function of integers. So if somebody makes some really crappy container class which is non-standard and annoying, but you can still refer to its
15:12:15 <polymer> elements by integers, then the algorithm will work on it (with minimal code).
15:12:22 <dspies> If someone can just show me how to create a "hello world" program I think I can figure out the rest from there
15:12:28 <dfeuer_> monochrom: I don't *know* it. That's why I'm asking.
15:13:51 <monochrom> where is the source code of filterM? let us read it carefully.
15:13:55 <chrisdone> monochrom: the other day someone emailed me two files of their changes, complete with windows newline endings
15:14:24 <dfeuer_> But ... I believe that IO and strict ST tend to do one thing before another. To do otherwise in this case requires knowing that the stuff in the argument to return is safe, to avoid an error happening before it's supposed to.
15:14:28 <chrisdone> they had access to the git repo. they didn't push, didn't email a patch, but the actual files. i was much disappoint
15:14:42 <monochrom> disbelieve in yourself.
15:14:59 <chrisdone> so deep. like matrix
15:15:16 <merijn> polymer: There's only one thing that can function as a function on integers, and that's a function on integers?
15:15:16 <dfeuer_> monochrom: it's at https://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Monad.html
15:15:30 <pablo|> polymer: don't worry about orphan instances too much
15:16:26 <monochrom> do you know what its implementation is saying?
15:16:32 <merijn> polymer: But you could just partially apply the lookup function for a container to get a function on integers, so I don't see why you'd need a class?
15:16:51 <shachaf> I offer my own tautology: Don't worry about orphan instances too little, either.
15:17:33 <shachaf> They're worth avoiding almost wherever possible.
15:17:41 <merijn> bezirg: Google ThreadScope
15:19:08 <bezirg> merijn: thx for threadscope, I knew about it. But, I have a concurrent application and I want at runtime (in the concurrent program itself) to have these timings available, not like profiling
15:19:11 <dfeuer_> monochrom: it appears to be saying (when interpreted in IO): take the first element of the list; apply p to get a computation. Run the computation and bind the result. Run the action that you get by applying filterM to the rest of the list. Return either the element consed to that, or just that, depending on what p x yielded.
15:19:25 <dfeuer_> Please don't pick too much at the poor language use in my last sentence.
15:19:37 <merijn> bezirg: You might be able to get access to GHC's runtime system's event queue and try to abuse that?
15:19:38 <polymer> merijn: I don't know if I would need a class. I was curious about how a haskeller would write algorithms, assuming as little as possible about their inputs.
15:20:05 <merijn> polymer: Well, with cheap and convenient first class function it's much easier to wrap things to get the input you want
15:20:16 <monochrom> your description is correct.
15:20:39 <dfeuer_> monochrom: what that *looks* like to me is that it builds a chain of closures holding list elements and predicate computation results, then later puts them together to actually filter things.
15:20:42 <monochrom> I do not know what is "actual filtering". it is ambiguous.
15:20:47 <bezirg> merijn: hmm is that possible? can you direct me to some haddock of this RTS event queue? and do u think this will add a big overhead?
15:20:56 <merijn> polymer: i.e. if you have a function "(Int -> a) -> Foo" and "Array a" then you'd just partially apply the "Array a -> Int -> a" function with the array to index
15:21:25 <monochrom> but this does go through the whole list and run the supplied predicate computation for each, before giving you any list.
15:21:39 <dfeuer_> monochrom: what I mean is that it seems that if almost all elements are filtered out, and there are many elements, then this could defeat GC.
15:21:40 <merijn> bezirg: http://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-Event.html ?
15:21:47 <merijn> bezirg: Horrifically unportable, of course
15:21:48 <bezirg> merijn: thx
15:21:56 <dfeuer_> Unless something I don't know about prevents that.
15:21:56 <Peaker> polymer: when stuff is immutable and you can convert it to other forms, it is less pressing to "code to an interface" (though that is of course still nice).  With mutability, it is essential to work on the object with the correct identity whatever its type may be. With immutability there's no identity you can just convert
15:22:00 <merijn> bezirg: oh, wait
15:22:04 <merijn> bezirg: That's just for IO
15:22:06 <monochrom> that is also correct.
15:22:06 <merijn> bezirg: hmm
15:23:20 <merijn> bezirg: hmm, I can see how to emit events, but I dunno if you can inspect them at runtime?
15:23:24 <merijn> bezirg: Consult #ghc?
15:23:36 <bezirg> merijn: ok I will
15:24:18 <dfeuer_> monochrom: *if* my guess is correct, then IO and strict ST would prefer a strict version of filterM. One that does something like accumulate the filtered list in reverse, then returns the reverse of that.
15:26:12 <monochrom> this is no stricter than what you have now.
15:26:49 <angelic_sedition> can I purchase a haskell?
15:26:59 <hiptobecubic_> Absolutely
15:26:59 <dfeuer_> monochrom: it's stricter in that it would strictify a lazy monad like list.
15:27:35 <hiptobecubic_> angelic_sedition, I accept bitcoin.
15:27:36 <monochrom> although other lists can be lazy, this one produced by filterM is not.
15:29:16 <dfeuer_> monochrom: if filterM is used for something like the list monad, it does produce a lazy list. The modified reversing filterM' would not produce a list lazily even in those cases. So it would not be a drop-in replacement or anything.
15:29:20 <dolio> > filterM const [1..] True
15:29:21 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Bool)
15:29:21 <lambdabot>    arising from the literal ‘1’
15:29:34 <polymer> Peaker, merijn: Your answers both seem to amount to, "it's easy enough you don't have to worry as much as you might think." Which would be cool. As a kind of "challenge", to help me understand how you think about this. Sort a list of numbers represented as a function from integers mod 5 to integers. You don't have to actually answer the question. If its easy say so, if there are aspects that
15:29:34 <polymer> are strange then I would like to know what they are etc.
15:29:50 <monochrom> could we stick to filterM under IO?
15:30:06 <dfeuer_> Sure!
15:30:19 * dfeuer_ sits down to hear monochrom's lesson.
15:30:30 <monochrom> then I am saying, doing the reverse trick is no stricter than not doing the reverse trick.
15:30:36 <polymer> Peaker, merijn: and assuming you could answer that question, would that be a good practical interface in Haskell land?
15:30:53 <dfeuer_> In IO, yes, they are the same except for efficiency.
15:30:54 <monochrom> and not doing the reverse trick is no lazier
15:31:10 <dfeuer_> Right.
15:31:10 <merijn> polymer: What does a "numbers represented as a function from integers mod 5 to integers" mean
15:31:30 <Peaker> polymer: same question from me :)
15:31:40 <monochrom> I am fine with comparing efficiency. have you empirically compared? or just theorizing?
15:31:51 <roboguy_> polymer: I'm not totally sure what you mean. Something like sort (map listAsFn [0..4])?
15:32:03 <pablo|> polymer: sortWtf f = sort (map f [0..4]) -- probably what you mean
15:32:08 <monochrom> because if you're just theorizing, then my theory disagrees with yours.
15:32:17 <dfeuer_> monochrom: I haven't even looked at the Core. I had this thought well away from my computer...
15:32:26 <dfeuer_> What's your theory, monochrom?
15:32:27 <dolio> There is a sense in which the reverse version is stricter.
15:32:29 <pablo|> polymer: i woudn't represent a list as a function though
15:32:45 * merijn resists guessing
15:32:47 <pjdelport> polymer: Any sorting algorithm implementation will be heavily dependent on the characteristics of the data structure you use for the list (assuming you mean an abstract collection) of numbers.
15:32:54 <dolio> In various ways, depending on how you write it.
15:33:05 <roboguy_> pablo|: well, it can be reasonable to represent a list as a function, but not really in this way
15:33:11 <pjdelport> polymer: An actual [] list might use a a merge sort; an Array might use a quicksort
15:33:21 <pablo|> roboguy_: yea, like a build function
15:33:25 <monochrom> the current filterM takes Θ(n) memory. the reverse trick takes Θ(n) memory. they are asymptotically equivalent.
15:33:36 <pjdelport> polymer: A set or similar might just use a traversal of an internal sorted tree.
15:33:44 <pjdelport> So it really all depends on what you mean by "list"
15:33:45 <monochrom> claims about different constant multipliers will have to be measured, not theorized.
15:34:26 <dfeuer_> monochrom: that's not true. They are not O(n) vs. O(n). They are O(n) vs. O(m).
15:34:40 <dfeuer_> If I am correct.
15:34:57 <dfeuer_> Number of elements of input vs. number of elements of output.
15:35:53 <dfeuer_> dolio: stricter how?
15:36:00 <monochrom> I see. you're right.
15:36:31 <dolio> The result will be less defined in various ways depending on the predicate.
15:37:10 <dfeuer_> How is that? I assume you're talking about a lazy predicate, but how does that affect it?
15:38:17 <dolio> If you filterM [1..1000] with p x | x == 3 = return undefined | otherwise = ..., then the current filterM will successfully yield 1:2:3:undefined.
15:38:55 <dolio> The reverse version will either successfully yield undefined, or will bomb part way through the computation.
15:38:58 <dfeuer_> Oh, that!
15:39:01 <dolio> Depending on how you write it.
15:40:56 <dolio> Sorry, 1:2:undefined
15:41:36 <dfeuer_> dolio: you are right of course. But I wonder if there's another way to do it without getting into lazy reverse messes....
15:42:29 <dfeuer_> Plain difference lists won't do the trick
15:42:46 <polymer> So, I'm okay at mathematics. And when mathematicians say list, what they mean is that you can enumerate the elements of whatever it is you care about. And their way of formally thinking about this is to see lists as equivilant to functions on integers (where function means a rule taking one thing to something else). By saying Integers mod 5, I was saying the list had 5 elements, each of which
15:42:46 <polymer> can be referred to with the numbers 0 through 4. In my eyes, this formalism means anything which can be enumerated at all, should be representable via an interface which behaves like a function. Any attempt to work with containers, must somehow, be a function in some sense. Perhaps not specifying this was confusing. The goal of the question, was to encourage ya'll to specify what these terms
15:42:46 <polymer> mean to you in the context of haskell. C++ uses iterators, and I can demonstrate that these iterators are just functions in the above sense, I wanted to know what "iterators" are in haskell.
15:43:23 <roboguy_> polymer: in that case, normal lists
15:43:45 <Peaker> polymer: so you want to sort a list of 5 integers? :P
15:44:09 <polymer> Peaker: the important point, is this algorithm should work on anything, that I can prove, is a list of 5 integers.
15:44:17 <roboguy_> polymer: or maybe anything with, for example, an instance of the Foldable class
15:44:32 <roboguy_> that would probably cover it
15:44:48 <roboguy_> or maybe Traversable
15:44:53 <monochrom> I disbelieve that mathematicians model a 5-item list by integers mod 5. I have a degree in math and I have seen enough what mathematicians actually say.
15:45:12 <Peaker> polymer: again, if it is a list of 5 ints in *any* representation, then you can convert it to a list of 5 integers in Haskell.  There's no object identity that needs to be preserved like in other languages
15:46:10 <Fuuzetsu> does anyone know what happened to the optparse-applicative test-suite?
15:46:17 <dolio> Mathematicians also have habits of ignoring things that matter to computer programmers.
15:46:18 <polymer> monochrome: they don't, they model lists by functions :p
15:46:20 <Fuuzetsu> it seems to have vanished between when moving to 0.10
15:46:40 <merijn> I consider myself a mathematician an I model lists using lists...
15:47:02 <dfeuer_> polymer: mathematicians will model the same thing many ways depending on what they're trying to do.
15:47:04 <monochrom> ok, my bad in omissive wording.
15:47:15 <katsh> merijn: do you know what math buildings are?
15:47:15 <merijn> polymer: Anyway, your example boils down to "sort (map f [0..4])"
15:47:17 <dolio> Per Martin-löf modeled lists using lists, too.
15:47:32 <merijn> dolio: Actually, I guess I should be using paths
15:47:33 <monochrom> I disbelieve that mathematicians model a 5-item by a function with domain Z_5. OK?
15:47:42 <merijn> dolio: Bob Harper told me it's paths all the way down!
15:47:56 <monochrom> s/5-item/5-item list/
15:47:57 <dolio> I'm not sure that's accurate.
15:48:06 <merijn> polymer: Well, "\f -> sort (map f [0..4])", I guess
15:48:26 <polymer> monochrom: I wouldn't even say mathematicians "model" exactly. But anything I can prove about a map from z_5 to something else, will be a proof about a 5 element list of that something else.
15:48:27 <merijn> Where f is a function from integers mod 5 to whatever has an Ord instance
15:48:37 <josephle> merijn: depends on which way is down :P
15:48:46 <merijn> josephle: All ways are down!
15:48:55 <merijn> It's paths up, down, left and right!
15:49:06 <polymer> and thank you all for answer my question.
15:49:15 <roboguy_> that wouldn't be a very useful way to model lists. For one, you need to pass the domain (as a list presumably) along with the function itself
15:49:18 <dfeuer_> dolio: I think what I'm attempting is impossible in principle, but not necessarily in practice. More importantly, giving the function its own name eliminates any concerns.
15:49:39 <dolio> dfeuer_: I'm not sure what you were attempting, exactly.
15:49:51 <dolio> Were you going to rewrite filterM for IO and stuff?
15:49:56 <roboguy_> polymer: my best guess is that Traversable is the closest to what you're looking for
15:50:03 <roboguy_> ultimately
15:50:13 <dolio> A lot of things would benefit from the reverse version for various reasons.
15:50:39 <dolio> But it is not the same as the existing version.
15:51:02 <dfeuer_> dolio: yeah, prett much. Based on what you said (which I should have recognized from our previous discussion of filter and reverse!) I think it makes sense to have a strict filterM' version.
15:51:03 <monochrom> here is one thing you have a difference in being able to prove: you can prove that a function from Z_5 to X is a function. you cannot prove that a "list", as a value of an abstract data type, is a function. well, it's abstract.
15:51:19 <pablo|> what is a function?
15:52:40 <dolio> The accumulate-then-reverse version avoids stack overflows in many cases, for instance.
15:52:45 <levi> Naturals and Lists have the same mathematical structure, so modeling a 5-element list as the Natural 5 seems reasonable. But Z_5 is not much like a list.
15:53:30 <polymer> monochrome: I'm not sure I know what you mean. In vector<int> x;, x[n] takes whatever n is to some integer. This is a function.
15:54:22 <dfeuer_> Yes, dolio, I think you are right that it is not the same, and I think I am right that both versions are valuable.
15:54:23 <monochrom> is it a function? or is it isomorphic to a function?
15:54:51 <monochrom> if it is merely isomorphic to a function, then first you need to state which ismorphism you use.
15:56:35 <monochrom> if x(n) is illegal, then x is not a function.
15:56:51 <polymer> monochrome: I'm curious what you mean by this: "list is a value of an abstract data type"
15:56:52 <pablo|> the domain can be a lifted type
15:57:18 <pablo|> and x[n] for n > x.size() equal _|_
15:57:24 <polymer> monochrome: in c++ I have algorithms which work on passed functions, and I just forward the [] operator.
15:57:45 <monochrom> in Haskell you can forward the !! operator
15:58:26 <pablo|> but... is a (const _|_) function an empty list, or [undefined], or cycle [undefined] ?
15:58:32 <monochrom> when a programmer says "an abstract data type", a mathematician says "axiomatization"
15:58:47 <monochrom> for example, Euclid's "point" and "line" are abstract data types.
15:59:33 <monochrom> for example, Zermelo and Fraenkel's "set" is an abstract data type.
16:01:16 <popl> shachaf++ # Welcome to zombocom.
16:01:17 <roboguy_> polymer: essentially, there are many different ways that you can encode those data as a function. So it isn't a function *itself*, but there are ways to encode the data *as* a function. It's less concrete than a function
16:01:49 <polymer> monochrom: so when you say you can't show lisp as a value of an abstract datatype is a function, you mean that assuming a list is a primitive you can't reconstruct the concept of a function with it?
16:01:56 <polymer> *list
16:02:16 <popl> Crap, I was scrolled up to yesterday morning.
16:04:00 <lectrick> Is there any way to compare or pattern match on an anonymous function that is equivalent to another anonymous function?
16:04:21 <levi> Mathematicians who want to build all of math on some foundational concept have traditionally used "set" rather than "function" as the basic concept. Lambda calculus was initially an attempt to build on "function" as primitive, but Haskell is far enough removed from pure untyped lambda calculus that it's not reasonable to think of everything in Haskell as a function.
16:04:50 <polymer> I don't really want to think of everything in terms of functions, that was just an example.
16:04:59 <chrisdotcode> is there any reasons template-haskell isn't in base?
16:05:37 <merijn> lectrick: No, you can't compare functions
16:05:50 <shachaf> There's no such thing as an anonymous function.
16:06:00 <merijn> lectrick: Well, you could give both functions input and see what comes out
16:06:01 <shachaf> Or, maybe, "anonymous function" is a syntactic concept.
16:06:14 <lpvb> I have a sum type of simple data I want to write to a binary file, would I just do mapM_ put [sum types] ?
16:06:34 <levi> polymer: Well, if that was just an example, then suffice it to say that Haskell does have a pretty nice set of broad and far-reaching abstractions; they're just not quite the same ones C++ uses.
16:06:39 <roboguy_> polymer: well, if you're looking for something that provides a general interface to things that can be "iterated" or "traversed", like I said either Foldable or Traversable is probably what you're looking for
16:06:47 <merijn> chrisdotcode: template haskell is not available on all platforms GHC is
16:07:02 <chrisdotcode> merijn: TH is GHC-specific, then?
16:07:07 <merijn> chrisdotcode: Yes
16:07:19 <chrisdotcode> merijn: got it.
16:07:20 <merijn> Well, mayb
16:07:25 <dolio> Also moving things out of base is good.
16:07:29 <chrisdotcode> I'm assuming that's because TH uses the GHI API?
16:07:36 <merijn> I mean, conceptually nothing is stopping anyone else from implementing TH for some other compiler
16:07:54 <merijn> But in practice, only GHC uses TH
16:08:35 <polymer> levi, roboguy_: the original question has been answered. And I appreciate the time you spent. The later discussion really is a little more philosophical then I really even have a stomach for. The point of the connection is that a function abstraction is good enough for lists (I think). and I wanted to investigate demonstrating something fit an abstraction to work with an old algorithm. People
16:08:35 <polymer> have shown that this is indeed possible.
16:08:37 <chrisdotcode> Because also in practice, GHC is the standard compiler, I'<m assuming
16:09:52 <dolio> Functions are not really a good abstraction for lists. I guess GHC can accomplish it, but it's not great.
16:10:18 <dolio> For instance, in your C++ example, x[n] is not (or, should not be) well-defined for all n.
16:10:36 <dolio> So you need to restrict your domain, depending on the size of the list.
16:10:40 <polymer> dolio: well in the actual example, I also pass a lower and upper bound.
16:10:45 <dolio> But the size of the list does not appear in the type.
16:10:58 <dolio> For the type of lists.
16:11:00 <polymer> dolio: I would love to have the size in types, but that isn't really practical.
16:11:14 <merijn> polymer: Basically, in haskell you only have data types and functions and the only two ways to interact with datatypes other than pattern matching is functions. Haskell happens to be really good at throwing functions around, so generally it's easy enough to adapt interfaces "on the spot"
16:11:35 <roboguy_> I would imagine that a Church encoding would generally be a better way to represent a list as a function rather than a function with a subset of natural numbers as it's domain, if you really wanted to represent a list as a function
16:11:42 <dolio> I'm not talking about what you'd like. I'm saying that the type of 'all lists' does not have any one size to use.
16:12:02 <dolio> So you need to do some fancy stuff to build that out of functions from domains of a specific size.
16:12:12 <tac_> x[n] in C++ could mean darn near anything :)
16:12:51 <dolio> It is possible to do this.
16:13:28 <dolio> And the type of lists would look like: ∃ n. Fin n -> a
16:13:35 <dolio> But that is, of course, not a function.
16:13:45 <dolio> Only lists of a specific size are functions.
16:14:23 <dolio> (∃ n. Fin n -> a) is a pair of a size and a function operating on that size.
16:14:33 <shachaf> I,I Cofin n
16:14:41 <shachaf> I hope there's a better name for Cofin.
16:14:56 <dolio> I like calling it Countable.
16:14:58 <tac_> cofin seems entirely appropriate to me :)
16:16:25 <kmspriyatham> runhaskell still points to ghc 7.6.3, even after I have updated to HP 2014. how do I change it?
16:16:34 <polymer> dolio: I actually have thought about a couple of those issues. And I've played around with a function defined on a graph, which has traversal functions. Although I think you're overestimating the difficulties. If I can define a function which could take a function of z_n for arbitrary n, and then use that n in the code, that would be fine. The input type wouldn't be a function, but the actual
16:16:34 <polymer> function used in the code would be a function.
16:17:18 <polymer> But I don't actually want to remake the wheel, and the part I cared about was mapping new objects to old abstractions.
16:17:36 <roboguy_> dolio: couldn't you turn that into a dependent function type if you really it to completely be a function?
16:17:56 <dolio> Well, you can always encode whatever you want as a function in some way.
16:18:04 <dolio> Given the right system.
16:18:12 <dolio> Multiple ways, even.
16:18:16 <roboguy_> dolio: right, that's what I thought
16:18:28 <roboguy_> polymer: hmm, could you provide some code? maybe that would help some
16:19:02 <dolio> (∀r. (a -> r -> r) -> r -> r) is another way to represent lists, and that is actually a function type.
16:20:21 <lpvb> is there a better way to do this? it looks so redundant: http://lpaste.net/110479
16:20:37 * hackagebot html-conduit 1.1.1 - Parse HTML documents using xml-conduit datatypes.  http://hackage.haskell.org/package/html-conduit-1.1.1 (MichaelSnoyman)
16:20:37 <lpvb> all the types of MyType are Words and Ints
16:21:17 <roboguy_> lpvb: mapM could help a little
16:21:44 <lpvb> I can't stick the m,nc,nbo etc in a list because they're not the same type
16:21:44 <roboguy_> or mapM_ specifically
16:21:52 <roboguy_> oh
16:21:57 <lpvb> words and ints
16:22:29 <lpvb> is the only way to get around thsi boilerplate with template haskell?
16:22:33 <lpvb> how about lenses?
16:23:48 <shachaf> What do lenses have to do with it?
16:24:24 <shachaf> I don't think there's really a straightforward way to improve it.
16:24:49 <polymer> roboguy_: Well I've successfully sorted lists via function notation in c++. So I don't really have any technical problems. Honestly, I was sort of motivated to learn haskell because of the iterate function. I built this while thinking of that graph structure I illuded to. Seeing this independently exist suggested that I might think in a more functional way then the c++ people do. So I came
16:24:50 <polymer> over to ask about how abstraction facilities work thinking I might invest time to learn the language.
16:25:09 <shachaf> You could make it look better syntactically, but you'll still need to apply a polymorphic function to each of those values.
16:25:42 <lpvb> ok
16:26:42 <shachaf> > let infixr *; (*) :: Show a => a -> String -> String; x * y = show x ++ y in True * 15 * "hi" * "" -- you can pretend this is a list
16:26:45 <lambdabot>  "True15\"hi\""
16:27:00 <shachaf> If OverloadedLists had been made differently then it could be an option here.
16:27:47 <roboguy_> polymer: you said you're looking for something kinda like C++ iterators, right? see if this looks about right:
16:27:57 <shachaf> You could write sequence_ [put a, put b, put c] or something.
16:28:00 <roboguy_> > F.foldl' (+) 0 [1,2,3,4]
16:28:01 <lambdabot>  10
16:28:07 <polymer> \msg monochrom
16:28:10 <roboguy_> > F.foldl' (+) 0 (V.fromList [1,2,3,4])   -- This is using a vector
16:28:12 <lambdabot>  Not in scope: ‘V.fromList’
16:28:12 <lambdabot>  Perhaps you meant one of these:
16:28:12 <lambdabot>    ‘M.fromList’ (imported from Data.Map),
16:28:12 <lambdabot>    ‘S.fromList’ (imported from Data.Set),
16:28:12 <lambdabot>    ‘IM.fromList’ (imported from Data.IntMap)
16:28:18 <roboguy_> > F.foldl' (+) 0 (S.fromList [1,2,3,4])   -- This is using a set
16:28:20 <lambdabot>  10
16:28:29 <roboguy_> I guess lambdabot doesn't have Data.Vector
16:29:10 <pjdelport> lpvb: If you're doing that for multiple types, you could define some helpers like:
16:29:10 <pjdelport> put5 a b c d e = put a *> put b *> ...
16:29:10 <pjdelport> get5 f = f <$> get <*> get ...
16:30:04 <pjdelport> lpvb: Then you'd say put = put9 mytype; get = get9 MyType
16:30:39 <pjdelport> sorry, put = mytype put9
16:30:57 <pjdelport> where mytype would be a destructor for MyType a la either, maybe, bool, etc.
16:32:41 <lpvb> pjdelport: I guess that's acceptable
16:34:49 <pjdelport> You could perhaps call those helpers liftGet<N> and liftPut<N>
16:36:01 <sinelaw> Peaker, you still up?
16:36:36 <polymer> roboguy_: those all work because they are instances of foldable right?
16:37:36 <roboguy_> polymer: yep. and you can make an instance of Foldable for any new type, as long as you can make an instance that satisfies the appropriate laws (the laws ensure that the intuition about it being "foldable" holds)
16:38:16 <roboguy_> actually, Foldable might not have explicit laws now that I think about it
16:39:40 <pjdelport> Foldable does have a few laws: they're in terms of the List folding functions.
16:39:43 <pjdelport> (and toList)
16:41:13 <lectrick> merijn: Yeah, the Haskellers over here don't think it's even feasible to compare 2 functions: http://stackoverflow.com/questions/4328620/comparing-functions-in-haskell
16:41:28 <roboguy_> polymer: it's pretty general too. They give an example using Trees in the documentation for Foldable (you can also see a list of the built in instances) http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Foldable.html#t:Foldable
16:42:12 <pjdelport> The Foldable doesn't explicitly give the laws for the fold and foldMap methods, but they presumably should be "fold == mconcat . toList" and "foldMap f == mconcat . map f . toList"
16:42:46 <shachaf> fold = foldMap id
16:42:52 <shachaf> But foldMap f = foldMap f . toList isn't true.
16:43:14 <shachaf> Because lists aren't free monoids!
16:43:39 <eitan_chatav> shachaf: they're not?
16:43:45 <shachaf> Not in Haskell.
16:43:57 <eitan_chatav> y?
16:44:04 <polymer> roboguy_: That is really cool. But suppose I had square x = x*x. And I wanted to sum square(1), square(2), square(3), square(4). Can I do that without packaging that in a list? Given the answers so far, I'm pretty sure the answer to that is yes.
16:44:12 <shachaf> I was just talking about this in another channel the other day.
16:44:23 <shachaf> > foldMap (\x -> Last (Just x)) $ Node 0 [Node 1 undefined, Node 2 []]
16:44:25 <lambdabot>  Last {getLast = Just 2}
16:44:26 <shachaf>  > foldMap (\x -> Last (Just x)) . F.toList $ Node 0 [Node 1 undefined, Node 2 []]
16:44:36 <shachaf> > foldMap (\x -> Last (Just x)) . F.toList $ Node 0 [Node 1 undefined, Node 2 []]
16:44:37 <lambdabot>  Last {getLast = *Exception: Prelude.undefined
16:44:56 <roboguy_> polymer: well, it depends on what exactly you mean by "packaging that in a list", but I'd say probably yeah. I'd do it as sum (map square [1..4])
16:45:26 <roboguy_> > let square x = x * x in sum (map square [1..4])
16:45:28 <lambdabot>  30
16:46:03 <roboguy_> you can generalize that to any Foldable instance actually, with fold
16:46:31 <roboguy_> or actually just sum from Foldable
16:46:40 <shachaf> roconnor would deny this, of course.
16:47:08 <eitan_chatav> shachaf: is the issue that [a] includes infinite lists?
16:47:22 <shachaf> No -- if anything [a] is not infinite enough.
16:47:29 <shachaf> It can only be infinite in one direction.
16:47:40 <shachaf> http://hackage.haskell.org/package/fmlist-0.8/docs/Data-FMList.html is a free monoid.
16:48:25 <silver> woah
16:48:33 <eitan_chatav> finite lists of elements of a set under append is the free monoid generated by a set
16:49:14 <polymer> roboguy_: wait...I would square[1..4] work even if square was square :: int -> int?
16:49:22 <polymer> square had type*
16:49:33 <roboguy_> polymer: square does have the type Int -> Int
16:49:38 <roboguy_> I'm using map to map it over the list
16:49:51 <polymer> roboguy_: oh duh >_<, of course.
16:50:10 <shachaf> OK, well, infinite lists do exist, so if you only count finite things, lists still don't work.
16:50:10 <roboguy_> polymer: there is an (generalized) equivalent of map for other structures called fmap
16:52:31 <dolio> Being finite isn't part of the definition of being free.
16:52:42 <eitan_chatav> what is your objection to thinking of ([a],[],++) as a free monoid generated by a if not the fact that it supports infinite lists?
16:53:25 <shachaf> dolio: Well, not directly.
16:53:39 <shachaf> But free monoids in the usual sense are finite sequences, right?
16:53:41 <eitan_chatav> the definition of Free : Set -> Monoid is adjoint to Forget : Monoid -> Set
16:54:08 <dolio> Yes, but you've thrown that out the window already, because you're talking about messy Haskell semantics.
16:54:19 <eitan_chatav> lol, fair...
16:54:35 <dolio> So you have to figure out what the definition of freeness means for that.
16:55:23 <eitan_chatav> meh, I'm fine with fast and loose reasoning, thinking about Hask as Set
16:55:55 <dolio> Yes, but if you do that, [] is going to work.
16:56:21 <Algebr> General OS question, when I hit tab, what char is that? Or rather, what is that exactly? and how can I find that out on my own later, is there some tbale like the ascii command prints out?
16:56:34 <hpc> you mean \t?
16:56:46 <Algebr> hpc: really? that simple?
16:56:46 <monochrom> tab is U+0009
16:56:49 <roboguy_> Algebr: well, you can find out the ascii code this way
16:56:51 <roboguy_> > ord '\t'
16:56:51 <geekosaur> ASCII 9 (HT)
16:56:52 <lambdabot>  9
16:57:03 <hpc> > [chr 0, ..]
16:57:05 <lambdabot>  <hint>:1:9: parse error on input ‘..’
16:57:14 <hpc> > [chr 0 ..]
16:57:16 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
16:57:16 <geekosaur> on a unixlike, you may have /usr/share/misc/ascii
16:57:19 <monochrom> there are tons of ASCII and Unicode tables
16:57:34 <Algebr> wait, so when you're in a shell and hit tab, its actually the '\t' char?
16:57:42 <geekosaur> Algebr: yes
16:57:47 <roboguy_> Algebr: in the same way that return is a '\n'
16:57:59 <roboguy_> yeah
16:58:07 <geekosaur> or control-I. (note that in a GUI, it's using events and not characters, so control-I and TAB may do different things)
16:58:33 <monochrom> \t and \n are some programming languages's notation, including Haskell, but don't be surprised if something doesn't recognize them
16:58:55 <shachaf> dolio: So what's a free monoid in Hask?
16:59:01 <Algebr> neat, thanks!
16:59:18 <dolio> You linked to one, right?
16:59:40 <dolio> It's clearly going to have infinite values, though.
16:59:54 <shachaf> Yes.
17:02:03 <eitan_chatav> If we're going to ignore bottom, might as well ignore infinite lists
17:02:15 <shachaf> That seems excessive.
17:02:26 <eitan_chatav> infinite lists are codata, the largest fixed point solution
17:02:38 <eitan_chatav> i meant possibly-infinite lists
17:02:48 <eitan_chatav> finite lists are the smallest fixed point solution
17:02:52 <dolio> If you want to use data, a leaf binary tree that you've hidden the implementation of so that people can only foldMap on it probably works.
17:03:19 <shachaf> Yes, I have a data type like that.
17:03:23 <dolio> If you imagine it's a quotient.
17:03:31 <shachaf> I was hoping to be able to do something better but it doesn't seem very plausible.
17:03:35 <eitan_chatav> I think it's ok to think of data types as encompassing both the data and codata
17:03:57 <hpc> > do Nothing -- shachaf ;)
17:03:59 <lambdabot>  Nothing
17:06:03 <c|ient> Hello
17:06:13 <eitan_chatav> I mean, hell, list isn't even a Monad if you include infinite lists...
17:06:20 <eitan_chatav> nor a Monoid
17:06:27 <shachaf> It's not?
17:06:40 <eitan_chatav> what's infinite ++ xs
17:06:46 <shachaf> infinite
17:06:58 <eitan_chatav> it's equal to infinite?
17:14:02 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://is.gd/xJt4FF'
17:14:02 --- topic: set by glguy on [Fri Aug 15 13:29:35 2014]
17:16:49 <tel> Is there a good library for polynomials over arbitrary variables?
17:17:01 <tel> I see toysolver and HaskellForMaths
17:17:07 <tel> both are quite extensive, though
17:24:57 <heatsink> What are you doing with the polynomials?
17:28:12 <tel> solving sets of equations in them
17:36:16 <heatsink> Ah.  I dunno.
17:36:31 <tabemann> hmm how do I not resort to unsafeIOToSTM here
17:37:04 <monochrom> have an STM action return an IO action. outside atomically, join it.
17:39:42 <monochrom> join (atomically ( (readTChan x >> return getLine) `orElse` (readTChan y >> return getContents) )
17:41:06 <tabemann> I should've remembered that
17:41:13 <CrazyM4n_> are Left and Right reserved keywords?
17:41:20 <monochrom> no, not reserved
17:41:29 <CrazyM4n_> so will doing http://prntscr.com/4jggp4 be allowed?
17:41:30 <tabemann> no
17:41:43 <CrazyM4n_> it just kinda threw me off that sublime text highlighted them
17:41:50 <monochrom> it's taking forever to load
17:41:59 <CrazyM4n_> "data Directions = Up | Down | Left | Right"
17:42:15 <monochrom> it is legal. but you will run into name clashes with Prelude
17:42:18 <shachaf> It's better to write text, either in here or in hpaste.org, than to take screenshots of your code.
17:42:34 <CrazyM4n_> i took a screenshot to show how it was highlighted weird
17:42:43 <shachaf> Your editor is highlighting standard library definitions. That's like highlighting "printf" in C.
17:42:59 <CrazyM4n_> yea, i get that now
17:43:07 <monochrom> as a programmer, you should learn to trust no program, for example trust no editor's colouring :)
17:43:17 <CrazyM4n_> anyway, since i'm not useing prelude or data.maybe, i should be good to go?
17:43:23 <CrazyM4n_> *using
17:43:35 <Exio4> i actually trust it, when my whole file is red, i guess some " is missing!
17:43:36 <monochrom> you are always using Prelude.
17:43:37 <tabemann> prelude is imported unless you explicitly don't import anything from it
17:43:52 <CrazyM4n_> oh. ok
17:44:04 <monochrom> Data.Maybe has nothing to do with Left and Right.
17:44:11 <tabemann> it's Either
17:44:26 <CrazyM4n_> oh, I always get them confused
17:44:27 <CrazyM4n_> haha
17:44:38 <CrazyM4n_> so I should probably not use those
17:45:52 <tabemann> even if you were to exclude Either's constructors from your imports, I probably wouldn't recommend naming a constructor Right or Left
17:46:10 <CrazyM4n_> I just renamed all of them
17:46:11 <CrazyM4n_> thanks
17:46:41 <tabemann> even though it's actually common for modules to provide functions with identical names to functions in the Prelude... but always to provide similar functionality but with, say, different types
17:58:43 <fread2282> is there a better way to do http://lpaste.net/110484 ?
18:01:30 <marchelzo_> fread2282: 27 has four syllables
18:04:44 <CrazyM4n_> how do you flush the std out buffer in order to use putChar?
18:04:44 <roboguy_> fread2282: you could make that into a list of triples with the first two elements containing the upper and lower bound and the third element the number of syllables. Then you can run through it and find which one matches
18:05:21 <jr_> Hola. How do I make a for loop in haskell?
18:05:27 <roboguy_> CrazyM4n_: hFlush stdout flushes stdout
18:05:37 <roboguy_> jr_: depends on what you're doing
18:05:43 <CrazyM4n_> thanks
18:05:44 <jr_> roboguy_: parsing a list
18:05:45 <tabemann> what do you want this for loop for?
18:05:58 <tabemann> map, or foldr, or foldl', or filter, etc. are what you want
18:05:59 <roboguy_> jr_: well, more specifically than that
18:06:00 <jr_> roboguy_: I just want to print each element in a list of strings
18:06:09 <roboguy_> mapM_ print stringList
18:06:23 <roboguy_> or, if you prefer, forM_ stringList print
18:06:23 <tabemann> unless you need to do something monadic, where then you want mapM, mapM_, foldM, foldM_, etc.
18:07:26 <jr_> roboguy_: is this possible?
18:07:26 <CrazyM4n_> so, i'm having more trouble than i should be with this
18:07:43 <roboguy_> jr_: yeah. that's how you would do it: forM_ stringList print
18:08:06 <CrazyM4n_> http://sprunge.us/dhgD i have this
18:08:09 <jr_> roboguy_: thanks
18:08:16 <CrazyM4n_> but it
18:08:17 <CrazyM4n_> wait
18:08:22 <CrazyM4n_> i forgot to import system.IO
18:08:24 <CrazyM4n_> never mind lol
18:09:29 <CrazyM4n_> actually, for some reason it won't print all the characters from putChar until the program ends, even when I use hFlush
18:09:46 <CrazyM4n_> i don't get exactly why
18:10:04 <roboguy_> CrazyM4n_: what if you used putStr [c] instead?
18:10:14 <CrazyM4n_> good idea
18:10:15 <CrazyM4n_> thanks
18:10:31 <roboguy_> also, you might want to make sure that the branch you're expecting it to reach is actually getting reached
18:10:52 * hackagebot x11-xim 0.0.9.0 - A binding to the xim of X11 graphics library  http://hackage.haskell.org/package/x11-xim-0.0.9.0 (YoshikuniJujo)
18:11:35 <CrazyM4n_> it is, i know that for sure
18:11:45 <CrazyM4n_> the rest of the effects are happening
18:12:28 <fread2282> is there a function which e.g. (27 -> 2, 75 -> 7)?
18:12:34 <roboguy_> CrazyM4n_: hmm, also you might want to make sure head stack isn't an unprintable character code
18:12:45 <CrazyM4n_> it will be, in some cases
18:12:54 <Makoryu`> fread2282: Hmmm....
18:12:56 <roboguy_> if it's unprintable it won't print
18:12:57 <geekosaur> :t (`div` 10)
18:12:58 <lambdabot> Integral a => a -> a
18:12:59 <CrazyM4n_> i get that
18:13:19 <CrazyM4n_> https://github.com/CrazyM4n/brainfunge/blob/master/brainfunge.hs line 33 if you want context
18:13:32 <Makoryu`> > 27 `div` 10 -- fread2282
18:13:33 <roboguy_> CrazyM4n_: oh, I was just looking at that earlier today actually
18:13:33 <lambdabot>  2
18:13:54 <CrazyM4n_> oh, I posted it on reddit yesterday
18:14:05 <Makoryu`> fread2282: What types do you want to apply that to, though
18:14:19 <fread2282> Makoryu`: 11..99
18:14:41 <CrazyM4n_> so f x = x `div` 10 should work
18:14:43 <Makoryu`> Well, those would be values
18:15:00 <Makoryu`> I meant (eg.) Int vs. Float
18:15:12 <fread2282> yeah. ints
18:15:21 <roboguy_> CrazyM4n_: you should definitely consider a case statement when you can do pattern matching over guards
18:15:25 <fread2282> (or other whole numbers)
18:15:26 <Makoryu`> > 32.1 `div` 10
18:15:28 <lambdabot>  No instance for (GHC.Show.Show a0)
18:15:28 <lambdabot>    arising from a use of ‘M59688686278996200521360.show_M59688686278996200521...
18:15:28 <lambdabot>  The type variable ‘a0’ is ambiguous
18:15:28 <lambdabot>  Note: there are several potential instances:
18:15:29 <lambdabot>    instance [safe] GHC.Show.Show
18:15:53 * hackagebot wai-app-file-cgi 3.0.1 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-3.0.1 (KazuYamamoto)
18:16:01 <CrazyM4n_> meh, i don't really see much of a difference
18:16:10 <CrazyM4n_> i mean
18:16:16 <CrazyM4n_> would it really be worth it to change it all?
18:16:23 <roboguy_> CrazyM4n_: you would only need to type program `getFromArray` (x, y) once haha
18:16:33 <CrazyM4n_> oh.
18:16:35 <roboguy_> no ==s and you wouldn't even need an Eq instance for your type
18:16:36 <CrazyM4n_> well then
18:16:41 <CrazyM4n_> refactoring it right now
18:16:42 <CrazyM4n_> thanks lol
18:17:02 <roboguy_> np
18:17:55 <NemesisD> have any of you guys used haste? I'm trying to determine if i should install it into my project sandbox or not
18:18:03 <polymer> roboguy_: Is it a common problem for different people to define logically identical type classes?
18:18:56 <trap_exit> why does haskell hate C? why does GHC not output *.c code? Isn't C basically portable assembly? What exactly about C does GHC hate ?
18:19:12 <joelteon> C? portable?
18:19:16 <monochrom> no, why does C hate Haskell? why does gcc not output *.hs code?
18:19:24 <roboguy_> polymer: hmm, for type classes? I don't *think* so, generally. Foldable, for example, is in the standard library so no one would be likely to define an identical one
18:19:29 <joelteon> why doesn't the JVM produce C code?
18:19:30 <geekosaur> trap_exit, going through C means (a) NOT portable, unless you want utter crap performance (b) poor optimization
18:19:40 <hpc> why doesn't php produce forth code?
18:19:45 <joelteon> why doesn't Ruby...yeah
18:19:51 <monochrom> answer: because if gcc output *.hs code, the code would use 7 layers of monad transformers and be very, very inefficient.
18:20:06 <geekosaur> the -fvia-C option still exists for porting, you'll find both -fllvm and -fasm are much better
18:20:28 <CrazyM4n_> can i use a case statement into a do block?
18:20:30 <geekosaur> also the output C is not something you can understand readily
18:20:48 <geekosaur> there is something wrong with that question... but the naïve answer is yes
18:20:52 <roboguy_> polymer: there might be overlap sometimes though. I suspect that the Arrow type class is mostly just a combination of Profunctor, Choice and Strong
18:20:57 <geekosaur> (case is an expression, like everything else in haskell)
18:21:09 <CrazyM4n_> i mean, as in
18:21:16 <heatsink> via-C used to depend on the mangler which was removed
18:21:16 <CrazyM4n_> _ -> do ......
18:21:19 <heatsink> what does it do now?
18:21:24 <geekosaur> note that, since it is an expression, if you want to use do syntax in case selectors, you muse use `do` again
18:21:28 <joelteon> do blocks are expressions, like everything else in haskell
18:21:43 <roboguy_> CrazyM4n_: yep
18:21:51 <CrazyM4n_> kk
18:21:52 <roboguy_> CrazyM4n_: do blocks are just normal expressions
18:21:53 <geekosaur> do is slightly odd, it syntactically is statement-like but creates an expression
18:22:57 <CrazyM4n_> yea, it works perfectly
18:23:06 <CrazyM4n_> thanks for that suggestion btw, it looks so much nicer
18:24:13 <trap_exit> hmm
18:24:24 <trap_exit> this seems to make haskell harder than necessary for cross compiling for portable devices
18:24:36 <trap_exit> I guess it does makes sense for haskell to not output C though
18:24:42 <geekosaur> -fvia-C still exists for cross compiling
18:24:43 <roboguy_> CrazyM4n_: sure! you might want to consider moving the pattern matches to the right at least one space so it is more visually separate. I'm surprised case expressions don't require that actually, some similar things do
18:25:00 <roboguy_> (so it is more visually separate from the "case ..." line that is)
18:25:00 <CrazyM4n_> roboguy_: sounds good
18:25:03 <trap_exit> geekosaur: I heard it is broken
18:25:04 <geekosaur> although -fllvm is probably better for cross compiling to llvm-supported platforms
18:25:30 <roboguy_> trap_exit: some haskell compilers do
18:26:15 <geekosaur> hm, think I saw something go by about the evil mangler being removed, possibly it should have been replaced by `cat` since that's all it was on most platforms anyway
18:26:22 <CrazyM4n_> so, another problem
18:26:24 <geekosaur> I recall it only doing anything interesting on alpha and sparc
18:26:29 <CrazyM4n_> putChar wasn't the thing that wasn't working
18:26:41 <geekosaur> and if you care about those than you have bigger problems than ghc
18:26:43 <CrazyM4n_> putStr was actually holding all the things I wanted to print until the very end
18:26:57 <trap_exit> roboguy_: referring to jhc?
18:26:58 <geekosaur> CrazyM4n_, that would be laziness
18:27:00 <monochrom> stdout is usually line-buffered, yes
18:27:06 <roboguy_> trap_exit: yeah. I think that has a C generation backend
18:27:07 <monochrom> no, not laziness
18:27:08 <geekosaur> or line buffering, yes
18:27:22 <CrazyM4n_> oh wait. i just realized that the hFlush call was in the wrong area of the code
18:27:22 <monochrom> http://www.vex.net/~trebla/haskell/IO.xhtml#lazynot
18:27:24 <CrazyM4n_> let me move it
18:27:38 <geekosaur> so you can turn off buffering, http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/haskell2010-1.1.1.0/System-IO.html#v:hSetBuffering
18:27:53 <geekosaur> you can see both effects actually
18:27:57 <CrazyM4n_> nah, I can just do it the normal way :P
18:28:09 <CrazyM4n_> it works now
18:29:38 <heatsink> Probably got rid of the assembly-language hacks in the mangler and kept the slow C path.
18:30:52 <geekosaur> the mangler had a C path? afaik it was only invoked on .s files
18:31:53 <heatsink> The mangler ran on .s files produced by gcc
18:32:19 <geekosaur> yes, so what's the slow C path?
18:32:19 <heatsink> It implemented tail calls, replacing function entry and exit code that the C compiler produced
18:33:17 <heatsink> The alternative C path implements tail calls with a dispatch loop.
18:34:01 <monochrom> is that similar to trampolining?
18:34:23 <heatsink> Haskell functions are compiled to C functions that return the address of the next function to execute.  The dispatch loop actually does the call.
18:34:37 <heatsink> I don't know trampolining.
18:34:51 <monochrom> then it is similar to trampolining to me :)
18:36:05 <monochrom> http://www.vex.net/~trebla/tail.html represents my understanding of trampolining done in javascript. be sure to see also its source code.
18:36:16 <heatsink> ok
18:36:23 <AndChat|600084> @tell Cale I wrote up my understanding of foldl-as-foldr at http://www.haskell.org/haskellwiki/Foldl_as_foldr_alternative I'd appreciate your comments, corrections, etc.
18:36:23 <lambdabot> Consider it noted.
18:38:24 <monochrom> in javascript, I do not return an address of the next procedure, I return the next procedure itself. at least conceptually.
18:41:38 <hpc> the mangler still exists?
18:41:38 <hpc> i thought that got cut out in the move to ghc 7
18:41:44 <heatsink> Javascript lets you use the variable 'cont2' before its definition?
18:41:55 <monochrom> yes!
18:42:08 <CrazyM4n_> so, is there a way to only input one character in haskell? or at least trim the \n character at the end?
18:42:34 <monochrom> I spent forever reading the ECMA doc to learn it :)
18:43:04 <heatsink> heh
18:44:21 <roboguy_> CrazyM4n_: does getChar work? Do you need it to work without enter being pressed?
18:44:31 <monochrom> it's indirect in the doc. the doc says this: imagine two passes when reading code, the first pass just looks for "var" declarations and "function" declarations to discover the relevant names... the 2nd pass looks at the rest of the code, honouring the names discovered in the 1st pass.
18:44:41 <vramana> Why is this invalid? zipWith (++ " " ++) ["foo", "bar", "baz"] ["fighters", "hoppers", "aldrin"] I am just trying to understand reason.
18:44:59 <roboguy_> vramana: what does (++ " " ++) do?
18:45:07 <CrazyM4n_> i just want it to not capture the \n character, on second thought
18:45:13 <CrazyM4n_> so i can just filter it
18:45:19 <CrazyM4n_> err
18:45:22 <hiptobecubic> roboguy_, generalized sections :)
18:45:44 <heatsink> I guess it is trampolining.
18:45:48 <roboguy_> CrazyM4n_: getChar would probably work then
18:45:55 <CrazyM4n_> i'm using getChar
18:46:01 <CrazyM4n_> i realized that it's actually a fault in my code
18:46:22 <CrazyM4n_> that ends up running getChar twice
18:46:27 <vramana> roboguy_: If x and y are arguments then I thought it should do x ++ " " ++ y
18:46:32 <roboguy_> > (++ " " ++)   -- <- this is the problem vramana
18:46:33 <lambdabot>  <hint>:1:11: parse error on input ‘)’
18:46:54 <roboguy_> : ((++ " "),     (" " ++))
18:46:58 <roboguy_> :t ((++ " "),     (" " ++))
18:46:59 <lambdabot> ([Char] -> [Char], [Char] -> [Char])
18:47:41 <roboguy_> vramana: haskell doesn't support that kind of section syntax
18:48:22 <vramana> Okay I just wanted it know if there was any special reason thanks
18:48:54 <roboguy_> vramana: an explicit lambda would probably be best, but you could also write (++) . (++ " ") if you want pointless style
18:49:47 <marchelzo_> Why is it that certain features in haskell require language pragmas in order for GHC to recognize them? Why not just have them on by default?
18:50:21 <marchelzo_> like monad comprehensions. it seems very convenient
18:50:25 <roboguy_> marchelzo_: without the language pragmas, it is Haskell 2010
18:50:38 <roboguy_> the language pragma indicates that it is an extension to Haskell 2010
18:50:39 <monochrom> do you like them on, all of them, by default?
18:50:51 <roboguy_> also, there's a *lot* of them
18:51:04 <vramana> roboguy_: Nice.
18:51:04 <monochrom> do you like TemplateHaskell on by default? do you like IncoherentInstances on by default?
18:51:05 <marchelzo_> monochrom: maybe not all of them, but it seems that some of them are useful enough that they should be default
18:51:13 <roboguy_> some of them could confuse things
18:51:24 <AndChat|600084> Be Cale here?
18:51:34 <monochrom> ok, but everyone has a different opinion on which ones they like on by default. so, whom should I listen to?
18:52:14 <roboguy_> marchelzo_: the funny thing is that monad comprehensions used to be the default back in the day
18:52:27 <marchelzo_> roboguy_: Why was that changed?
18:52:31 <benzrf> incoherent instances?
18:52:40 <roboguy_> marchelzo_: I think it was considered too confusing for beginners
18:52:43 <tabemann> marchelzo_: ostensibly to make it easier for newbies
18:54:33 <monochrom> language design is a decision made in a huge trade-off space. someone's decision is going to be disagreed by some others.
18:55:12 <AndChat|600084> Which is a valid concern—overly general types make for bad error messages.
18:55:19 <marchelzo_> sure. I was merely curious being a beginner myself
18:56:33 <roboguy_> benzrf: I think it generalizes overlapping instances in some way, but I was never totally clear on the specifics of it
18:56:35 <gennady> This was my solution to euler problem 6 is there a more elegant solution? http://lpaste.net/3969569200581640192
18:57:12 <roboguy_> gennady: well, foldr (+) 0 is unnecessarily lazy, I'd suggest foldl' (+) 0 or just sum
18:57:13 <marchelzo_> gennady: there are solutions to the euler problems on the haskell website that you could look at and compare with your own
18:57:13 <gennady> Oh, found it. Wow. one liner
18:57:18 <gennady> :(
18:57:28 <gennady> Yeah just saw that marchelzo_ thanks
19:00:31 <gennady> I dont know to much about that roboguy_ I was googling for what I was trying to achieve with suming a list than hoogle'd it.
19:00:46 <gennady> I thought using ' was for making your own functions of the same name for some reason.
19:01:13 <monochrom> sometimes yes, actually
19:01:13 <roboguy_> gennady: ' is for anything
19:01:24 <roboguy_> gennady: in this case, it means that it is the strict version of foldl
19:01:35 <monochrom> oleg uses ' for space in names, for example list'iterator
19:02:00 <gennady> roboguy_, So its a different version of foldl than?
19:02:12 <roboguy_> > foldr (+) 0 [1..10000000]
19:02:17 <lambdabot>  mueval-core: Time limit exceeded
19:02:18 <lambdabot>  mueval: ExitFailure 1
19:02:21 <roboguy_> > foldl' (+) 0 [1..10000000]
19:02:23 <lambdabot>  50000005000000
19:02:31 <roboguy_> ^ gennady: that's a demonstration of the problem
19:02:46 <gennady> foldr have to go across the list twice or something?
19:03:20 <roboguy_> gennady: no. basically, foldr builds up a huge thunk instead of evaluating it as it goes. so you have something like 1 + (2 + (3 + (4 + (5 ...)))) being stored until the very end
19:03:25 <roboguy_> instead of just storing a single integer
19:03:38 <gennady> Ohh ok
19:03:56 <roboguy_> foldl looks like (((1 + 2) + 3) + 4) + ..., but foldl' evaluates the first, inner part before the next part
19:04:12 <roboguy_> I've never seen a use of foldl that wouldn't be better as foldl' actually
19:04:33 <gennady> So why is there no foldr' then?
19:04:35 <roboguy_> in foldr, on the other hand, the laziness *can* be handy. just not in this case
19:04:58 <monochrom> foldr' does not improve anything
19:05:03 <roboguy_> gennady: well, how would it work? it has to reach the end before it gets a 99999 + 100000
19:05:30 <roboguy_> if we pretend that has the right number of 0s
19:05:37 <gennady> Oh
19:05:42 <gennady> Heh
19:05:43 <gennady> yeah
19:06:16 <roboguy_> this is also why foldl/foldl' don't work on infinite lists, but foldr does
19:07:07 <CrazyM4n_> so how would i go along getting a char that isn't newline
19:07:45 <gennady> Thanks roboguy_, monochrom! :)
19:08:01 <roboguy_> CrazyM4n_: hmm, getChar works for me... what's it doing?
19:08:18 <CrazyM4n_> i don't want to be able to get a newline char
19:08:29 <CrazyM4n_> so i'm making a function that just recalls getChar if it is a newline
19:08:29 <roboguy_> what should it do if you do get a newline char?
19:08:34 <roboguy_> oh
19:08:45 <CrazyM4n_> but i don't know how well it will work
19:08:50 <monochrom> in what sense? the user can always enter anything, including newline, to your program. how can it be forbidden?
19:08:55 <geekosaur> maybe also wants termios to not have to read line at a time
19:09:02 * dfeuer wonders when Cale will show up.
19:09:23 <dfeuer> Does Cale tend to show up sometime around this time of day? I really can't remember.-
19:09:23 <CrazyM4n_> i'm just saying that if the user just enters a newline, it just recalls getChar
19:09:52 <monochrom> ok. loop = do { c <- getChar; if c=='\n' then loop else return c }
19:10:03 <roboguy_> dfeuer: http://ircbrowse.net/nick/Cale
19:10:11 <CrazyM4n_> oh, that's a lot easier than what i'm doing
19:10:29 <dfeuer> roboguy_, whoa....
19:11:14 <CrazyM4n_> thanks, it works
19:12:08 <dfeuer> I guess that means Cale will likely show up sometime in the next hour or so.
19:13:27 <roboguy_> dfeuer: you didn't know you're being *monitored* by robots in this channel, haha
19:13:40 <roboguy_> complete with collected statistics
19:13:46 <monochrom> I like robots
19:14:05 <Markz> robots are polite
19:14:09 <joelteon> My quote on IRC Browse is "whoops".
19:14:14 <monochrom> http://www.last.fm/robots.txt
19:14:34 <CrazyM4n_> that's great
19:14:36 <monochrom> (the last 3 Disallow lines, specifically :) )
19:14:56 <tac_> heh nice monochrom
19:15:41 <dfeuer> @quote dfeuer
19:15:41 <lambdabot> No quotes match. That's something I cannot allow to happen.
19:16:16 <sevak> >product []
19:16:23 <sevak> > product []
19:16:25 <lambdabot>  can't find file: L.hs
19:16:31 <monochrom> try again. race condition.
19:16:39 <sevak> > product []
19:16:41 <lambdabot>  1
19:16:58 <sevak> hehe thanks, I'm wondering, why does that equal 1?
19:17:06 <tabemann> 1 is the multiplicative identity
19:17:12 <sevak> hi monochrom btw
19:17:18 <sevak> hmm
19:17:19 <roboguy_> wow, that's a very smooth verbosity graph http://ircbrowse.net/nick/Cale?recent=false
19:17:21 <CrazyM4n_> http://hackage.haskell.org/package/base-4.7.0.1/docs/src/Data-List.html#product
19:17:21 <monochrom> because I would like product xs * product ys = product (xs ++ ys)
19:17:54 <monochrom> therefore product [] * product ys = product ys. this contrains product [] formally. as opposed to intuitively.
19:18:02 <roboguy_> > sum []
19:18:03 <lambdabot>  0
19:18:14 <monochrom> http://www.vex.net/~trebla/homework/empty.html
19:21:04 * hackagebot hspec-snap 0.1.0.0 - A library for testing with Hspec and the Snap Web Framework  http://hackage.haskell.org/package/hspec-snap-0.1.0.0 (DanielPatterson)
19:21:11 <sevak> hmm, thank you guys, I think I understand at least part of it; I'll have to do a little reading
19:22:56 <dfeuer> Quick: A want a nice simple function for a folding example. I don't want (:) and I don't want anything that's commutative.
19:23:21 <dfeuer> Simple simple simple is best.
19:23:39 <monochrom> perhaps (++)? concat xss = foldr (++) [] xss
19:23:57 <monochrom> @type foldr (++) []
19:23:58 <lambdabot> [[a]] -> [a]
19:24:12 <dfeuer> monochrom, to be more specific, I don't want a function that deals in lists--too much confusion potential.
19:24:47 <dfeuer> I want a function of type a->b->b for some a and b, and I want it not to be commutative and not to have [] in its type signature.
19:25:16 <dfeuer> er ...  sorry..  i actually want   a->b->a.
19:25:24 <dfeuer> For a left folding example.
19:25:35 <dfeuer> STRIKEOUT.
19:26:01 <dfeuer> monochrom, any other ideas, now that I went and changed the rules?
19:26:09 <dolio> const
19:26:16 <lpvb> if I want a cabal package's binary only should I just download the package, build, and copy to system bin? or should I cabal install it and then unregister it?
19:26:23 <dfeuer> dolio, that's *too* simple!
19:26:25 <monochrom> subtraction is non-commutative
19:26:41 <copumpkin> (.)
19:26:51 <dfeuer> Aaaaaaand copumpkin wins it!
19:26:56 <dfeuer> maybe.
19:26:58 <monochrom> yeah, that's nice
19:26:59 <dfeuer> No.
19:27:03 <dfeuer> Yeah, it's nice.
19:27:05 <copumpkin> you don't want it to be associative either?
19:27:14 <dfeuer> But I'm trying to write something for beginners...
19:27:14 <copumpkin> or not homogeneous?
19:27:27 <dfeuer> Or semi-beginners.
19:27:27 <copumpkin> "you have a list o' functions. You wanna compose them all"
19:27:39 <dfeuer> Let me start over with what I'm trying to do.
19:27:40 <copumpkin> the apostrophe is crucial
19:27:45 <dfeuer> I just wrote http://www.haskell.org/haskellwiki/Foldl_as_foldr_alternative
19:28:15 <dfeuer> And I realized it couldl probably be improved by working through a concrete example instead of the general case.
19:28:39 <lpvb> cross product is non commutative
19:28:52 <monochrom> perhaps subtraction is good enough
19:29:04 <lpvb> division too
19:29:14 <dfeuer> And I think it will be easiest to keep track of what's going on with something non-commutative.  Maybe i'm wrong about that.
19:29:36 <monochrom> foldl (-) 4 [a,b,c] = ((a-b)-c)-4 IIRC
19:29:46 <dfeuer> Yuck.
19:29:51 <dfeuer> No, subtraction stinks.
19:29:56 <monochrom> why?
19:30:13 <dfeuer> It's too wild for my taste.
19:30:20 <copumpkin> you need more formal requirements :P
19:30:23 <dfeuer> Heh.
19:30:26 <copumpkin> "it should be associative"
19:30:30 <monochrom> hmm, I wonder what counts as wild
19:30:39 <dfeuer> Yeah, it should be associative.
19:30:43 <copumpkin> okay
19:30:47 <monochrom> because I was thinking "Map's insert" but that's my idea of too wild
19:31:06 <dfeuer> monochrom, what's wrong with Map's insert?
19:31:17 <dfeuer> I actually think that might be a great example....
19:31:18 <monochrom> requires knowing about Map
19:31:36 <dfeuer> I don't need a map; just a set.
19:31:49 <monochrom> ok, requires knowing about Set.
19:31:52 <dfeuer> And very little knowledge is required for that.
19:32:07 <monochrom> alright, good to hear that Set's insert may be good
19:32:17 <dfeuer> Familiarity with the Set ADT generally seems reasonable to assume for this purpose.
19:32:48 <dfeuer> BTW, general comments on how to improve the explanation on that page would be appreciated too.
19:32:50 <monochrom> it's really like (:) except not called (:) :)
19:33:04 <dfeuer> monochrom, yep! Which is perfectly fine.
19:35:34 <RyanGlScott> Is there a Floating type such that minBound is 0.0 and maxBound is 1.0?
19:35:43 <tabemann> hmm someone a while back was complaining about needing an Ord instance to use Set, and I just realized that why didn't I recommend they use HashSet, as long as they can have a Hashable instance for their type...
19:36:34 <monochrom> yeah, HashSet is a good suggestion.
19:36:57 <monochrom> at the end of the day, you cannot avoid all of {Ord, Hashable, Eq}.
19:37:19 <monochrom> P.S. if you can only afford Eq, expect slow algorithms
19:38:52 <monochrom> if you're already at the end of the day, what is P.S. after even that?
19:39:04 <tabemann> people often forget that you can even have hash-based data structures in Haskell
19:39:12 <monochrom> answer: the end of the night. "and a new day, has begun!"
19:39:55 <monochrom> haha I did mention that choice in my data structure course. "you can hash, but then use the hash code in a binary search tree!"
19:40:22 <tabemann> or better yet, a hash array-mapped trie
19:40:42 <monochrom> I didn't get to trie
19:41:20 <tabemann> the people who complain about how you can't have hash tables in Haskell without resorting to the IO monad obviously don't know about HAMTs
19:42:41 <tabemann> which, yes, are O(log n) for most operations... but more like O(log_16 n) so they still are fast for large quantities of entries
19:43:20 <tabemann> okay I'm abusing big-O notation there
19:43:30 <tabemann> as strictly the base isn't part of the big-O
19:44:15 <lpvb> RyanGlScott: use a smart constructor over a wrapped floating type http://www.haskell.org/haskellwiki/Smart_constructors
19:50:04 <lpvb> (and implement Bounded for it)
19:51:43 <splintax> in the context of a stackoverflow question about the Ord constraint on Data.Set: "Obviously, mathematical sets can be uncountable infinite – you won’t be able to represent that in all generality with a computer, or even a Turing machine."
19:52:06 <splintax> sounds kinda wrong to me but i can't think of a way to represent a type with uncountably infinite values in haskell
19:55:21 <splintax> maybe haskell types can only represent recursively enumerable sets, ie. not R
19:57:37 <splintax> lots of misleading equivalences between real and Float/Double when you google "haskell real" :/
19:59:11 <monochrom> in Fortran, they called floating point numbers "real". the stigma sticks.
19:59:42 <monochrom> you know, the joke "God is real, unless declared integer"
20:01:03 <monochrom> how many of you have not heard that joke?
20:01:06 <sohum> splintax: I'm pretty sure the reals and the computable numbers are distinct sets http://en.wikipedia.org/wiki/Computable_number
20:01:20 <splintax> maybe you can create a type CauchySequence and construct the reals that way
20:01:43 <monochrom> you will only ever construct computable Cauchy sequences
20:02:08 <sohum> splintax:  http://math.stackexchange.com/questions/462790/are-there-any-examples-of-non-computable-real-numbers
20:02:13 <monochrom> at the end of the day, this may not be a serious limitation
20:03:23 <monochrom> nice, Chaitin stuff :)
20:03:37 <splintax> hmm yeah. maybe it indicates a problem with the mathematical definition though ;)
20:03:42 <cbarrett> "the set of computable numbers is only countable" from that stack exchange link
20:03:52 <cbarrett> Er sorry, from wikipedia
20:03:57 <splintax> given the name, the case for real numbers being real is surprisingly weak
20:03:59 <monochrom> Chaitin stuff is the best thing since Kolmogorov stuff, when it comes to uncomputables :)
20:04:10 <cbarrett> (Although it's not cited)
20:04:39 <cbarrett> splintax: I think it's "real" in that it's the infinity of the continuum which was at the time assumed to be very real.
20:04:59 <monochrom> oh, back in several hundred years ago, it was not obvious what kind of serious questions the real numbers would raise. :)
20:05:01 <cbarrett> IIRC space has not been proven quantized yet but it's certainly not outside the realm of possibility
20:05:31 <splintax> at this point my uninformed opinion is that it's more likely than not
20:05:55 <splintax> afaik there is no evidence that continuums really exist in nature?
20:06:21 <cbarrett> not a physicist but doesn't relativity operate on continuous space?
20:06:33 <monochrom> naming is hard. every good name you think up today will be proven inadequate two hundred years later.
20:06:58 <monochrom> relativity does. but relativity is limited.
20:07:37 <cbarrett> so is QM ;)
20:08:07 <splintax> hmm good point
20:08:52 <splintax> i'm not sure if this happens to Real Physicists but it seems like people tend to think of QM as the more fundamental theory for some reason
20:09:02 <monochrom> yes, QM is also limited. so the jury is still out on what really is space.
20:09:05 <splintax> probably because it sounds cooler
20:09:26 <cbarrett> almost certainly not because it sounds cooler
20:09:33 <cbarrett> at least I really really hope not
20:09:56 <monochrom> QM is more fundamental when you don't have a huge mass. and you really don't have a huge mass usually.
20:10:00 <splintax> by "people" i mean people like me whose knowledge of QM comes mostly from pop science documentaries
20:10:37 <monochrom> and QED has already taken in special relativity
20:11:39 <monochrom> black hole is where neither is more fundamental than the other. they both break.
20:12:39 <monochrom> but other than that, GR rules the star sky, and QM rules the microscopic.
20:16:18 <cbarrett> thanks for the info, had no idea
20:19:21 <comp_> what's the usual way to pass a haskell list to a C function using FFI ?
20:20:53 <monochrom> not sure about usual, but the least work (for programmer) is store into an array, give array to C. least work because the standard library already has tools for it.
20:21:49 <monochrom> Foreign.Marshal.Array look for withArray etc
20:22:41 <bmuk> What are some books I should look into to deepen my knowledge of Category Theory? Specifically as it applies to haskell?
20:23:24 <comp_> that requires that haskell first convert the whole list into an array, and later once the C function finishes, convert the array back as a list right? I guess there is no way to directly work with haskell lists in C ?
20:23:50 <monochrom> when the C function finishes, throw away the array
20:23:55 <comp_> I mean, avoiding the convertion and using the list data type directly in C
20:24:26 <geekosaur> you kinda don't really want to do that
20:24:27 <monochrom> no C interface for Haskell list
20:24:45 <geekosaur> maybe you meant an array or vector type? Storable vectors should be directly usable in C
20:24:56 <geekosaur> remember, Haskell lists are singly linked lists
20:25:51 <monochrom> perhaps you should start with vector on the Haskell side to begin with. especially if you're planning mutable.
20:25:54 <comp_> yes, but since I don't know anything about their implementation, I can't just create a singly linked list in C and assume it's gonna be the same. Anyway, I guess I'll go with that library monochrom mentioned.
20:26:28 <splintax> bmuk: i think it's normal to study some topology, group theory, and basic type theory before tackling category theory, have you looked into those areas?
20:26:52 <comp_> well it's not really relevant, I was just implementing a couple of different sorting algorithms in C, and thought it would be interesting to call them from ghci
20:27:32 <comp_> at the same time I try to implement them in haskell, to see the differences (imperative vs functional)
20:27:38 <geekosaur> comp_, one of the problems with Haskell data types from C is that Haskell data types are normally lazy
20:27:52 <geekosaur> which means that instead of a data value, you may have a thunk
20:28:51 <bmuk> splintax: Not yet. I am taking Calc 1 right now, but it is pretty easy for me. I just got done watching ekmett's talk on Hask and it's fascinating to me. I want to know more.
20:29:30 <comp_> is there any good source to learn about algorithms in functional programming? I know there is okasaki's book for data structures...
20:34:18 <tel> Anyone have a trick for making Arbitrary Void work?
20:34:20 <bmuk> comp_: I haven't read it yet but I have heard pearls of functional algorithm design by richard bird is good
20:34:35 <tel> such that generate arbitrary :: IO [Void] is always []
20:34:46 <beckyconning> is there a better way of reverting to a default value if any of a collection of maybes which may have different Just types are Nothing than how i've done it here in parseMessage? https://gist.github.com/beckyconning/40e49374286beb1a972d#file-gistfile1-hs-L40
20:35:02 <beckyconning> i imagine it might need a change in the approach i'm taking over the whole file
20:35:07 <beckyconning> #noob
20:35:28 <comp_> great, I'll keep it in mind bmuk. Thanks everyone for the good answers :)
20:35:48 <beckyconning> the only thing i can think of is to create a maybe3 function
20:36:00 <splintax> bmuk: cool. when i first looked into category theory i got really confused by these: https://en.wikipedia.org/wiki/Commutative_diagram
20:36:15 <splintax> they often seem to get presented with no explanation or link to what they actually mean
20:36:29 <beckyconning> splintax: i totally agree
20:36:52 <tac_> commutative diagrams are the "equals sign" of category theory
20:37:27 <splintax> i found it easier to grasp the idea of a category because i was already familiar with the idea of defining abstract sets that satisfy certain axioms from topology and group theory classes
20:37:47 <bmuk> splintax: do you know of any good books to start me off in that direction?
20:38:14 <splintax> not really, tbh. i would probably recommend looking into a MOOC
20:38:30 <splintax> even if you just want to get a complete set of notes for 1 semester and read through it at your own pace
20:38:33 <bmuk> I have seen those before, I always thought they were functors - that map objects in one category to objects in another
20:38:38 <beckyconning> the last maths class i took was when i was 15 years old : P i'm making my way back to maths from Perl -> C -> Obj-c -> Ruby -> Javascript -> 'Functional' Javascript -> Haskell -> Maths
20:39:15 <tac_> bmuk: see ##categorytheory
20:39:37 <bmuk> splintax++ tac_++
20:39:46 <tac_> they have a standard set of book recommendations: Awodey, B. Pierce, and I forgetthe other
20:39:51 <tac_> there are also free books
20:39:54 <Clint> beckyconning: you can use monadic binding there to clean it up
20:40:00 <tac_> but do note: all books on category theory are terrible
20:40:20 <tac_> and none are simultaneously 1) written for programmers, and 2) worth reading
20:41:02 <beckyconning> clint: thanks! any suggested reading or an example to get me started? : ) i understand bind but my brain is a bit fuzzy this afternoon and i'm not sure how to apply it to this.
20:41:23 <splintax> bmuk: http://ocw.mit.edu/courses/mathematics/18-703-modern-algebra-spring-2013/Syllabus/ and http://ocw.mit.edu/courses/mathematics/18-901-introduction-to-topology-fall-2004/ look similar to what i did
20:41:23 <tac_> CT isn't a useful tool for programmers, IMO. The best you can do with it is backwards justify other things you learn about.
20:41:31 <bmuk> I don't mind it not being written for programmers. I'm kind of looking for something I won't understand, I'll look things up that I don't understand along the way. That may be overly optimistic though
20:42:04 <tac_> It explains why monoids, monads, functors, applicatives are all useful. But it's really a mathematicians' tool
20:42:14 <tac_> heh
20:42:30 <tac_> Awodey's book is pretty good, IMO
20:43:05 <tac_> Pierce is more aimed at programming langauges, but it's terse and doesn't really explain natural transformations or adjunctions particularly well
20:43:32 <tac_> If you like abstract algebra, there's a book by Aluffi that's really good called Algebra Chapter 0
20:43:49 <splintax> tac_: CT is the ultimate result (so far) of iteratively wondering "can this be generalised?", though, and this skill is arguably quite useful for programmers
20:43:58 <tac_> It doesn't really get too heavy with categories until the last three chapters, but it does show how basic CT can be very useful in mathematics
20:44:28 <tac_> splintax: True. But programmers also have a word for overgeneralization
20:44:46 <tac_> "Architect Astronaut" :)
20:45:20 <tac_> category theorists are almost transdimensional with how detacthed their definitions are from things people can intuit
20:45:47 <tac_> 'astronaut' is not severe enough a term ;)
20:45:50 <Clint> > fromMaybe 0 $ do x <- Just 5; y <- Nothing; z <- Just 9; return $ x+y+z -- beckyconning
20:45:51 <lambdabot>  0
20:46:00 <Clint> > fromMaybe 0 $ do x <- Just 5; y <- Just 7; z <- Just 9; return $ x+y+z -- beckyconning
20:46:02 <lambdabot>  21
20:46:22 <Clint> @undo do x <- Just 5; y <- Just 7; z <- Just 9; return $ x+y+z
20:46:23 <lambdabot> Just 5 >>= \ x -> Just 7 >>= \ y -> Just 9 >>= \ z -> return $ x + y + z
20:46:23 <bmuk> tac_: when does generalization become a bad thing?
20:46:29 <beckyconning> Clint: thanks!
20:46:31 <bmuk> when it takes too long?
20:46:58 <tac_> bmuk: At the point where it begins increasing complexity again, rather than reducing it.
20:47:05 <splintax> bmuk: look up "architecture astronaut"
20:47:35 <bmuk> complexity as in time complexity or complexity of the code itself
20:47:36 <splintax> in my experience those people are rarely the same kind of people who enjoy the "mathematical style" of endless generalisation though
20:47:47 <tac_> You have a complex system, and a naive understanding of it. You abstract away some parts and your system becomes simpler as your understanding grows.
20:47:57 <tac_> But there is overhead in maintaining the understanding.
20:49:52 <cbarrett> Evolution of a Haskell Programmer is a humorous look at this.
20:50:03 <cbarrett> http://www.willamette.edu/~fruehr/haskell/evolution.html
20:50:21 <bmuk> cbarrett: I have seen that. I didn't understand most of it, admittedly lol
20:50:45 <cbarrett> There's actually a lot of good ideas in there lol
20:51:12 <cbarrett> I am sad to say that I understand nearly all of it, ~4 years after picking up Haskell.
20:51:21 <tac_> heh
20:53:02 <tel> cbarrett I am sad to say that I pretty routinely do far worse things now... I kind of think the post-doc version is pretty : s
20:53:10 <cbarrett> tel: i know, right??
20:53:51 <cbarrett> I was talking to a friend from the Netherlands, knew some folks who spent 6 years working on a company over there that used primarily Haskell
20:53:56 <cbarrett> he asked them what insights they had learned
20:54:05 <cbarrett> What new branches of math they'd uncovered, etc
20:54:35 <bmuk> Does anyone else have the problem that they use functions as the base unit of abstraction in other programming languages after haskell? i.e. today I made a twitter bot in python, bunch of top level functions, interweave values through functions, it was pointed out on reddit it would be much simpler in a class.
20:54:40 <cbarrett> They reported that they had mostly abandoned heavy type level programming and concentrated on writing simple value level stuff.
20:55:13 <cbarrett> bmuk: I had nearly that exact same experience writing some scripts to interact with a JSON API in Python
20:55:15 <tel> cbarrett I find that to be true in practice as well... it's easy to get astronomical and important to remember to pull back on complexity
20:55:59 <tel> bmuk I've implemented pure profunctor lenses in Javascript on multiple occassions—so yes : )
20:56:09 <bmuk> https://github.com/bmuk/EchoBot/blob/master/echobot.py
20:56:32 <cbarrett> tel: *nod* I think it's the mark of a true expert -- knowing the exact minimum level of goofy tricks necessary to accoplish a given thing
20:56:43 <cbarrett> I certainly have that in languages I've been writing longer than Haskell
20:56:52 <edwardk> tel: i knew i was forgetting a step
20:57:32 <bmuk> Someone said they had no idea what remove_echo was doing and the recursion and split-join was problematic. I can't even think of another good way to do what I want to do there :/
20:57:46 <tel> edwardk I started poking around with it in Swift too and then realized my masochism had reached a limit
20:58:14 <bmuk> edwardk - really enjoyed your Hask talk on YouTube
20:58:25 <edwardk> bmuk: thanks =)
20:59:00 * edwardk tries to get a couple of hours of sleep before the talks start tomorrow.
20:59:28 <tel> edwardk You're presenting, right? Break a leg, tomorrow!!
20:59:40 <edwardk> doing a lens workshop in the afternoon
20:59:48 <cbarrett> bmuk: hmm, re: remove_echo I think you could probably use filter, yeah?
21:00:03 <bmuk> cbarrett: does python have filter?
21:00:06 <cbarrett> yea
21:00:25 <cbarrett> https://docs.python.org/2/library/functions.html#filter
21:00:30 <cbarrett> It can even be lazy
21:00:40 <bmuk> That would make it easier to understand
21:01:21 <cbarrett> Python's standard library has a pretty arbitrary deliniation between free functions and member functions of various collection types
21:01:39 <cbarrett> So I think it would come out looking somewhat ugly.
21:01:57 <bmuk> You think I should keep it the way it is?
21:02:01 <cbarrett> No
21:02:16 <cbarrett> Just a general remark on Python
21:02:40 <bmuk> Is there anything else that you think I should change?
21:02:40 <cbarrett> you might also use one of those comprehension things
21:03:16 <cbarrett> " ".join([x for x in text.split() if x != self.name])
21:03:27 <cbarrett> blah
21:04:25 <cbarrett> bmuk: I might drop the clean_author function in favor of a local. You're not invoking it more than once
21:04:36 <cbarrett> and hey if you've got statements, might as well use them
21:04:59 <bmuk> That's true. Thank you for looking it over, I'll probably do just that
21:05:05 <cbarrett> no problemo
21:05:54 <bmuk> Sorry if this is answered elsewhere, I can't really tell from the website. What is the function of the #nothaskell group?
21:08:34 <goglosh> why this error guys ? ¡http://lpaste.net/110489
21:08:36 <cbarrett> I don't think it's quite that well defined.
21:08:59 <tel> bmuk: I think the idea is to focus on building an even more supportive community around teaching Haskell with a special focus on promoting diversity
21:09:00 <cbarrett> The biggest features are the Code of Conduct and the focus on outreach on FP
21:10:03 <bmuk> ah, so it's more for help with learning haskell? I was directed there from ##categorytheory for a reading list
21:10:04 <tel> bmuk: maybe not "promoting diversity", more like ensuring comfort and safety to enable diversity
21:10:17 <tel> and yeah, definitely teaching oriented
21:10:30 <tac_> cbarrett: code of conduct? outreach?
21:10:54 <cbarrett> what are you asking about specifically? sorry I'm not following from your questions
21:11:02 <tac_> ahh
21:11:08 <tel> tac_ http://www.haskellnow.org/wiki/CodeOfConduct http://www.haskellnow.org/wiki/OutreachResources ?
21:20:02 <bmuk> I think hlint does what I want - is there something that will judge the quality of my code? I don't necessarily want to bother the internet with every small piece of code I write, but I do want to become a better programmer, and write better code.
21:20:28 <Welkin> read code
21:20:46 <Welkin> well written code
21:21:12 <Welkin> read gghc base
21:21:15 <Welkin> ghc*
21:21:50 <bmuk> How do I judge whether project x is well written? I suppose I can assume if is popular it is well written?
21:21:56 <Welkin> perhaps edwardk's libraries as well, like lens
21:22:21 <rusk101> Hello everyone. I have a quick question. Im trying to use the any (<5) [1,2,3,4,5] but with 2 conditions like <5 and >3. any suggestions?
21:22:30 <Welkin> I've heard xmonad is well written, if old
21:22:43 <rusk101> any (<5 && >3) [1,2,3,4]
21:22:59 <tel> rusk101 any (\x -> x < 5 && x > 3) [1..5] :)
21:23:06 <rusk101> TYVM
21:23:23 <slack1256> I want to do 'cabal exec ghc --make src/Sync.hs'
21:23:29 <tel> rusk101: more cleverly: any (liftA2 (&&) (< 5) (> 3)) [1..5]
21:23:31 <tac_> rusk101: You can write your own combinator for that, but there's no "standard" combinator for that
21:23:50 <bmuk> rusk101: also [x | x <- [1..5], x < 5, x > 3]
21:24:00 <slack1256> yet cabal always return cabal: unrecognized 'exec' option `--make src/Sync.hs
21:24:18 <slack1256> how can I make cabal exec know that --make is a flag of ghc
21:24:27 <tac_> > let andalso f g x = f x && g x in ((<5) `andalso` (>3)) <$> [1,2,3,4,5,6,7]
21:24:29 <lambdabot>  [False,False,False,True,False,False,False]
21:24:40 <tac_> > let andalso f g x = f x && g x in filter ((<5) `andalso` (>3)) [1,2,3,4,5,6,7]
21:24:41 <lambdabot>  [4]
21:25:03 <tac_> slack1256: isn't it just one hyphen?
21:25:05 <solirc> I think for TDD it could be useful if we could have type signatures without an accompanying binding, where GHC introduces that binding as `error (srcLoc ++ ": undefined")` + emits a warning
21:25:08 <tac_> slack1256: -make, not --make?
21:25:20 <solirc> Has that been proposed somewhere?
21:25:56 <solirc> I did not manage to Google up a corresponding GHC ticket
21:26:11 <tac_> solirc: it would be nice if undefined bindings had implicit holes
21:26:18 <slack1256> cabal: unrecognized 'exec' option `-make'
21:26:21 <tel> > let andalso = liftA2 (&&) in filter ((< 5) `andalso` (> 3)) [1..7]
21:26:23 <lambdabot>  [4]
21:26:48 <jle`> andAlso is nice
21:26:56 <solirc> slack1256: put a -- after the exec
21:27:15 <jle`> :t liftA2 (&&)
21:27:16 <lambdabot> Applicative f => f Bool -> f Bool -> f Bool
21:27:51 <jle`> :t \f g x -> f x && g x
21:27:52 <lambdabot> (t -> Bool) -> (t -> Bool) -> t -> Bool
21:27:56 <slack1256> solirc: that did the trick
21:28:00 <jle`> hm.
21:28:03 <slack1256> thanks!
21:28:11 <jle`> :t \fs x -> all ($ x) fs
21:28:12 <lambdabot> [a -> Bool] -> a -> Bool
21:28:20 <jle`> @pl \f x -> all ($ x) fs
21:28:20 <lambdabot> const (flip all fs . flip id)
21:28:23 <jle`> ew
21:28:28 <solirc> slack1256: I really think that cabal could be clever enough to figure this out
21:29:00 <jle`> oh
21:29:16 <begriffs> How do I get the values out of two "C.Source IO B.ByteString"s to compare them?
21:29:17 <solirc> just do not treat anything after the exec as cabal options ...
21:29:28 <begriffs> (where C is Conduit...forgot to mention)
21:29:56 <solirc> begriffs: You have to "consume" both of them
21:30:07 <jle`> @pl \fs x -> all ($ x) fs
21:30:07 <lambdabot> flip (all . flip id)
21:30:18 <slack1256> solirc: nah, just better docs to tell that 'cabal exec [FLAGS] -- COMMAND [ [ARGS...]]' instead of 'cabal exec [FLAGS] COMMAND [-- [ARGS...]]'
21:30:27 <jle`> @pl \x -> all ($ x) fs
21:30:28 <lambdabot> flip all fs . flip id
21:31:17 <jle`> > filter (\x -> all ($ x) [(< 5), (> 3)]) [1..7]
21:31:21 <lambdabot>  [4]
21:34:25 <bmuk> :t liftA2
21:34:25 <tel> > filter (and . T.sequenceA [(< 5), (> 3)]) [1..7]
21:34:25 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
21:34:27 <lambdabot>  [4]
21:34:50 <bmuk> :t (&&)
21:34:50 <lambdabot> Bool -> Bool -> Bool
21:35:08 <jle`> tel: ah, yeah
21:35:16 <jle`> well you can just use sequence too :)
21:36:17 <tel> When I do a lot of these predicate combinations I like to define
21:37:35 <tel> let { (<&&>) = liftA2 (&&); let (<||>) = liftA2 (||); let fnot = fmap not } in (> 3) <&&> (< 5) <||> fnot even
21:37:41 <tel> :t let { (<&&>) = liftA2 (&&); let (<||>) = liftA2 (||); let fnot = fmap not } in (> 3) <&&> (< 5) <||> fnot even
21:37:41 <merijn> man, I feel like my twitter is filled with hilarious ICFP outtakes that I don't get, because I'm not there...
21:37:42 <lambdabot> parse error on input ‘}’
21:37:44 <tel> aw
21:38:24 <jle`> i think you can just do let a = b; c = d; in ...
21:38:31 <jle`> er. without the last semicolon i think
21:39:10 <tel> ah
21:39:28 <tel> > let (<&&>) = liftA2 (&&); let (<||>) = liftA2 (||); let fnot = fmap not in (> 3) <&&> (< 5) <||> fnot even $ 10
21:39:29 <lambdabot>  <hint>:1:112:
21:39:29 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
21:39:57 <jle`> one let per in
21:39:59 <tel> > let { (<&&>) = liftA2 (&&); (<||>) = liftA2 (||); fnot = fmap not } in (> 3) <&&> (< 5) <||> fnot even $ 10
21:40:01 <lambdabot>  False
21:40:14 <tel> there we are
21:40:20 <jle`> nice
21:40:51 <tel> but yeah, I define those guys often when writing, say, parsers with finnicky character classes
21:41:00 <jle`> <&&> and <||> are useful etc. in their polymorphic forms too
21:42:02 <jle`> ...is there a lens for this?
21:42:11 <tel> jle` I've only ever used them at (a -> Bool) but I might just not be clever enoug
21:44:03 <tel> There's always a lens for it! Uh... `mapped &&~ _` is sort of close
21:44:05 <dfeuer> Far be it from me to speak ill of any fusion rule, but ... what is the point of the fusion rule for head?
21:44:42 <dfeuer> Why would you ever want head to fuse with a list producer?
21:44:54 <Welkin> jle`, there is an app for that!
21:45:11 <Welkin> I haven't seen one of those ads for years now
21:47:17 <tel> dfeuer maybe just a case of "why not"?
21:48:33 <dfeuer> tel, that's how I feel about filterM, but head is a bit different, I think.
21:49:45 <stalintrotsky> oh, I didn't realize <&&> and <||> were already a popular operator for something
21:50:02 <jle`> :t (<||>)
21:50:02 <lambdabot>     Not in scope: ‘<||>’
21:50:03 <lambdabot>     Perhaps you meant one of these:
21:50:03 <lambdabot>       ‘<|>’ (imported from Control.Applicative),
21:50:03 <stalintrotsky> I had them defined as something in a project
21:50:28 <tel> stalintrotsky "popular" is probably not the word for it :)
21:50:35 <jonseymour> G'day. I was wondering if there had been any formal consideration of Tony Morris's alternative to the AMP proposal (e.g. http://tonymorris.github.io/blog/posts/applicative-do/). That is, has it been considered and rejected or not formally considered?
21:50:38 <stalintrotsky> oh
21:50:45 <Welkin> stalintrotsky, which one is it, stalin or trotsky?
21:50:53 <tel> stalintrotsky more like "internal function I find worth talking about but never exporting"
21:51:00 <haasn> Sometimes I wish we had class Boolean a where true :: a; false :: a; (&&) :: a -> a -> a; (||) :: a -> a -> a; not :: a -> a  and the laws being given by https://en.wikipedia.org/wiki/Boolean_algebra#Laws
21:51:34 <haasn> Being able to write filter (this || that) would be so elegant
21:51:57 <tel> haasn There's http://hackage.haskell.org/package/Boolean-0.2.1/docs/Data-Boolean.html
21:52:14 <haasn> Interesting
21:53:43 <tel> haasn Conal built it to make some deep embedding syntax nicer—fran maybe?
21:53:47 <merijn> jonseymour: applicative do is not an alternative for AMP
21:54:23 <merijn> jonseymour: The idea behind applicativedo is that do notation does not always require the full power of monad and the applicative implementation of some functions may be more efficient
21:54:43 <merijn> jonseymour: The idea is to make do-notation desugar to applicative, to make use of this extra efficiency
21:54:47 <tel> jonseymour ApplicativeDo is being somewhat pushed by the facebook team, too, I imagine
21:54:53 <merijn> Yeah
21:55:10 <merijn> Simon's talk on HaXe (or whatever the name was) has some example of where this would matter
21:55:45 <tel> Haxl is really interesting like that since the Applicative instance truly differs only in improved parallelism and efficiency
21:55:47 <jonseymour> perhaps I misread Tony's paper, but I thought he was suggesting altering the class hierarchy in a different way to the AMP proposal (e.g. introducing an Apply class as well)
21:55:59 <tel> ApplicativeDo ===> completely transparent speedups
21:56:17 <conal> haasn: see the "Boolean" package
21:57:15 <jonseymour> e.g. Functor => Apply => Applicative => Monad
21:57:18 <merijn> jonseymour: There's proponents of an Apply class too, but that's mostly orthogonal to ApplicativeDo
21:58:06 <jonseymour> ok, I guess that's the debate I am interested in. the one about whether to include Apply or not
21:58:16 <merijn> I don't think it's likely to happen
21:58:30 <merijn> Apply adds too little power
21:59:02 <merijn> jonseymour: i.e. the list of things that could be made Apply instances, but not Applicative is tiny (I don't even know of any)
21:59:12 <jonseymour> do these questions get discussed in comp.lang.haskell.libraries?
21:59:13 <merijn> jonseymour: So the logic goes that you may as well just use Applicative
21:59:21 <jle`> and i don't think you can think of too many meaningful laws for it without the greater context of Applicative
21:59:33 <merijn> jonseymour: libraries@, ghc-devs@ and glasgow-haskell-users@ see a fair amount of discussion
21:59:48 <merijn> Lack of laws is indeed another issue
21:59:55 <merijn> It's why Pointed is dropping from favour
22:00:03 <merijn> No laws, so hard to reason about
22:00:56 <merijn> jonseymour: I've seen the pointed/apply discussion pop on libraries@ a couple of times in the past 2 or so years
22:01:17 <jonseymour> ok, thanks… FWIW, I don't have an opinion either way ( I way too much of a novice ), but I thought it was an interesting question from, I guess, a sociological perspective
22:01:29 <jonseymour> (managing a breaking change to the API)
22:02:29 <merijn> jonseymour: That's one reason it's unlikely to happen :)
22:02:50 <merijn> jonseymour: A breaking change needs a compelling benefit, Apply is lacking in that department :p
22:03:11 <jonseymour> well, as I understand it the breaking change is already happening (e.g. introducing Applicative between Functor and Monad)
22:03:58 <Welkin> how does that break anything?
22:04:36 <dfeuer> OK, I made some major edits to my little Wiki page, http://www.haskell.org/haskellwiki/Foldl_as_foldr_alternative , and I'm wondering what people think. I'm also wondering how to make it look like something other than the Great Wall of Text.
22:05:03 <Welkin> dfeuer, use paragraphs and sub headings
22:05:13 <merijn> Welkin: Datatypes that don't have an Applicative instance need it or they will stop compiling
22:05:27 <merijn> jonseymour: Yes, and it's been postponed for years
22:05:27 <jle`> Welkin: a lot of libraries do not define Applicative instances for their Monads
22:05:36 <jle`> so...oops
22:05:48 <jle`> or executables, too
22:05:52 <lpvb> so I can't do seeking in Data.Binary right?
22:05:53 <merijn> jonseymour: But a significant portion of the community feels the pain of NOT fixing this is greater than breaking it will be
22:06:09 <dfeuer> Welkin, how do you make paragraphs on that thing? If I put an extra line, I get a *huge* gap. And I don't really think there are any sensible subheadings for it, although maybe I can figure something out.
22:06:11 <Welkin> well, it's better to fix things early than wait
22:06:42 <jonseymour> right. So, I guess Tony's point was that without Apply, a similar sort of error was going to be committed, although I take your point that perhaps the value of a separate Apply class is not seen to be high
22:07:52 <Welkin> dfeuer, you want to have a large gap between the text and code
22:08:01 <Welkin> it needs visual separation
22:08:05 <dfeuer> Unfortunately, I think there may be efficiency reasons to avoid an overly deep class hierarchy.
22:08:09 <tel> jonseymour There's a lot of reason to want a really fine-grained typeclass hierarchy—but there's a lot of pain involved in that as well. Library manitainers end up having to write numbers of instances in the square of the number of classes
22:08:18 <dfeuer> Welkin, OK....
22:08:49 <jonseymour> tel: right.
22:08:52 <tel> jonseymour so it's always a power/weight tradeoff
22:09:39 <jonseymour> ok, thank you all for your insights
22:09:45 <tel> even if you magic away breaking people's code
22:10:37 <merijn> jonseymour: Well, we have years of evidence about the value of Applicative
22:10:56 <merijn> jonseymour: I've never seen Apply in the wild OR encountered a datatype which would an Apply instance, but not Applicative
22:11:35 <dfeuer> Welkin, do you think it's better now?
22:11:41 <jonseymour> merijn: right.
22:11:49 <merijn> I mean, Applicative has been around since 2005/2006? And it's rampantly taken over lots of the ecosystem
22:13:37 <Welkin> dfeuer, much better
22:13:48 * dfeuer would like to see the Num class ditched. Put in Semigroup, Monoid, Group, Ringoid, Ring (maybe a few more ringy things), and then maybe later figure out what a "number" is.
22:14:02 <dfeuer> But that will never ever happen.
22:14:05 <jonseymour> merijn: ok, thanks for your insights
22:14:09 <merijn> dfeuer: That has lots of trouble too
22:14:15 <merijn> dfeuer: Like, which monoid?
22:14:21 <dfeuer> Thanks, Welkin. To my eye the spaces look huge now, much as they were too small before.
22:14:28 <jonseymour> also tel, dfeuer and Welkin
22:14:28 <dfeuer> merijn, yes, that is a problem.
22:14:35 <dfeuer> merijn, also which semigroup.
22:14:55 <dfeuer> Which suggests the whole class system is pretty shady for doing mathematics. Which it is.
22:15:32 <merijn> Right, back to attempting to make GHC dance to my tune...
22:16:02 * dfeuer offers to dance with merijn.
22:16:09 <lpvb> I need random binary parsing, any libraries?
22:16:11 <tel> dfeuer yes, but! :(
22:16:17 <merijn> lpvb: binary
22:16:18 <tel> Ring!
22:16:20 <dfeuer> But only if the music isn't techno.
22:16:26 <lpvb> merijn: I can't seek backwards
22:16:36 <merijn> lpvb: Why do you need to?
22:16:43 <tel> I so wish Ring => Num
22:16:54 <tel> just get rid of abs, signum
22:17:01 <dfeuer> tel, of course, the mathematicians can never agree on what exactly a ring should be ....
22:17:04 <merijn> dfeuer: Actually, turns out a guy I met at OPLSS is working on fixing the GADT bug I'm having :)
22:17:20 <tel> class IsInteger i where fromInteger :: Integer -> i
22:17:25 <dfeuer> merijn, I don't know what OPLSS is, but I'm glad t hear it!
22:17:38 <merijn> dfeuer: Oregon Programming Languages Summer School :)
22:17:49 <tel> dfeuer I'm find with a little ambiguity there so long as Ring doesn't have abs/signum : )
22:18:05 <tel> abs = error "Nothing I care about has absolute value"
22:18:10 <dfeuer> merijn, I don't know wwhat that is either, but it sounds like fun.
22:18:27 <dfeuer> tel, so you work with unordered rings mostly?
22:18:46 <lpvb> merijn: because I don't want to parse the entire file, I just want to parse specific random offsets
22:19:05 <merijn> lpvb: Right, but binary just has a "skip" functionality?
22:19:18 <tel> dfeuer it's more of an indication of value rather than whether or not it could be defined
22:19:56 <merijn> lpvb: Or use hSeek and start reading from a specific offset?
22:19:56 <lpvb> merijn: but when I skip and parse that offset, I can't go back to an earlier offset to parse
22:20:06 <dfeuer> tel, the fact that you don't care about it is really quite irrelevant. The real problem is when it doesn't make sense.
22:20:11 <lpvb> the offsets are themselves parsed from the file
22:20:28 <merijn> lpvb: I don't know of any files that can't be parsed sequentially and I've parsed some weird formats
22:20:31 <monochrom> can you afford to: first decide you want exactly n random offsets, then generate n random offsets, then sort them, and read them sequentially, from lowest to highest?
22:20:34 <merijn> lpvb: Which file format
22:20:58 <tel> dfeuer I'm aware in a global sense. I'm just whining.
22:21:28 <dfeuer> Absolute value at least is meaningful in the complex numbers. But signum? Does that make any sense at all?
22:21:30 * hackagebot scat 1.1.0.1 - Generates unique passwords for various websites from a single password.  http://hackage.haskell.org/package/scat-1.1.0.1 (RomainEdelmann)
22:21:45 * merijn sighs
22:21:59 <merijn> I just don't know how to make GHC do what I want :(
22:22:03 * dfeuer offers merijn a beer.
22:22:17 <merijn> Or rather, I guess I do know, it's just that GHC doesn't know it yet :)
22:22:22 <lpvb> merijn: it's a game data format meant to be mmap'd with audio and bitmap offset tables
22:22:27 <dfeuer> merijn, like I think I told you, just put on blinders to those pattern match warnings and wait for them to go away.
22:23:13 <merijn> dfeuer: The problem is that is basically the same as not taking all this effort to statically type it and this was already a hacky attempt to work around what I actually wanted to do
22:23:42 <merijn> dfeuer: So if it doesn't work I might as well go back to the drawing board and try and improvise a different approach
22:25:34 <merijn> Unfortunately I'm out of ideas there too :p
22:25:59 <merijn> I should just go reread all GHC extensions and see if there's anything useful :p
22:27:25 <merijn> I guess I haven't tried abusing FunDeps yet...
22:27:37 <merijn> Which is unfortunate as I don't really understand them >.>
22:32:01 * Cale chuckles at his own quotes on his ircbrowse.net page. I forgot I'd said most of these things.
22:32:20 <merijn> :)
22:32:37 <merijn> hah
22:32:48 <merijn> You can see I spend a lot of time being stuck waiting for compiles this month :D
22:33:20 <Cale> Nothing like long compile times for tanking your ability to be productive
22:34:26 <dfeuer> CALE!
22:34:28 <merijn> I'm currently at 3 mins to compile, 3-5 minutes to run tests, but my colleague's new branch already has 10 minute compile times :(
22:34:29 <Cale> hi
22:34:47 <merijn> And this is not on slow desktops, this is on dedicated fat boxes...
22:35:27 <merijn> (oh and 3-5 mins to dump core as is inevitable)
22:35:28 <dfeuer> merijn, what's wrong with waiting for the next version of GHC for your code to be entirely verified by the compiler?
22:35:31 <Cale> There has to be something wrong with my verbosity graph. There's no way there are as many lines in which I used 0 words as lines in which I used 23.
22:36:51 <dfeuer> Cale, I really wanted your feedback on http://www.haskell.org/haskellwiki/Foldl_as_foldr_alternative
22:37:13 <dfeuer> Since you spend a bunch of time helping me with that stuff.
22:38:20 <Cale> I am confused :)
22:38:57 <Cale> hmm
22:39:04 <dfeuer> THAT'S NOT GOOD.
22:39:26 <haasn> I like how ircbrowse.net lists my quote as “Oh, wait”
22:39:34 <haasn> That is probably the line I have sent most in here
22:39:37 <merijn> oh, wow
22:39:58 <merijn> Why did I not realise the utility of nullary type classes for global configurations?
22:40:32 <Cale> merijn: Otherwise known as "definitions"
22:40:35 <dfeuer> Cale, you may also want to consider this earlier version, before I tried to make things very concrete: http://www.haskell.org/haskellwiki/index.php?title=Foldl_as_foldr_alternative&oldid=58737
22:40:46 <dfeuer> If you think that one's better, I can revert.
22:41:09 <Cale> Yeah, the whole "stuffy" thing and specialisation to insert was weird
22:41:31 <mauke> “inb4 list” — mauke
22:41:45 <dfeuer> Cale, should I revert it?
22:41:51 <Cale> dfeuer: It's up to you!
22:42:01 <dfeuer> Cale, I'm asking for YOUR opinion.
22:42:15 <Cale> I'd stick with foldl :)
22:42:20 <dfeuer> Ooookay.
22:42:58 <haasn>     “This channel is long overdue for a few sanity checks.” — shachaf
22:43:53 <dfeuer> Cale, so what do you think of the foldl version? Is there any way I could make it easier to understand?
22:46:23 <dolio> dfeuer: I can't make this foldrW stuff actually fuse anything.
22:46:35 * dfeuer offers everyone egg creams.
22:47:01 <dfeuer> dolio, that's ... unfortunate. I haven't tried it myself yet. are enough things INLINE?
22:48:12 <merijn> Cale: Shush! :p
22:48:55 <dfeuer> Whatcha talkin' about, merijn
22:52:55 <merijn> dfeuer: Cale pointing out that nullary class instances "are just definitions" :)
22:53:05 <Sensored> if anyone cares
22:53:10 <dfeuer> Ah.
22:53:14 <Sensored> i fixed cabal by nuking all of ghc and ghc platform
22:53:21 <Sensored> nuking macports ghc
22:53:29 <Sensored> installing haskell platform from the online package
22:53:47 <Sensored> and then configuring ghc to use gcc48 NOT gcc42
22:53:57 <Sensored> gcc42 will make things properly up to a point
22:54:03 <merijn> Sensored: Oh, you installed from macports? Yeah, I don't think anyone really uses macports or brew to install GHC
22:54:03 <Sensored> then make you very confused later
22:54:13 <Sensored> i did a long time ago and forgot about it
22:54:13 <dfeuer> dolio, I tried foldl (+) 0 (eft 1 1000) with that and got fusion.
22:54:22 <Sensored> so i was using the macports cabal, with the ghc-platform ghc
22:54:28 <merijn> Sensored: Which version of OSX?
22:54:28 <Sensored> which i mean, techinically works except i was usig gcc42
22:54:35 <Sensored> the one before mavericks
22:54:39 <Sensored> i suppose that's mountain lion?
22:54:43 <merijn> Yeah
22:55:00 <dfeuer> That all sounds very Macky.
22:55:05 <Sensored> yeh.
22:55:09 <Sensored> is it worth upgrading?
22:55:36 <dfeuer> Yes. It seems Haskellers prefer NixOS.
22:55:45 <Sensored> no, hah
22:55:47 <Sensored> i mean
22:55:53 <Sensored> upgrading my mac to mavericks
22:56:00 <merijn> Well, I've been having some resource issues, but 1) I'm not sure that's OSX rather than Proxifier (which I've started using) and 2) my macbook is pretty old
22:56:10 <Sensored> im mostly afraid of stuff breaking
22:56:23 <Sensored> i remember when i went to mountain lion, Xcode had a lot of problems
22:56:25 <merijn> Proxifier seems a pretty shoddy app, but it's the only way to get unfiltered internet at work
22:56:29 <dfeuer> Sensored, I don't know. As I'm fond of telling my mother when she asks me questions about hers, I do not have a Mac.
22:56:39 <Sensored> oh and a lot of ports break
22:56:41 <merijn> Sensored: Well, Haskell Platform now works with Mavericks XCode, so \o/
22:56:44 <Sensored> hmm okay
22:56:49 * merijn doesn't use that many ports
22:56:50 <Sensored> merijn: out of the box?
22:57:04 <Sensored> i had to at least install gcc48 and point ghc to use that instead of clang
22:57:05 <dolio> dfeuer: I'm not using the stuff from the repository. I'm just rolling my own stuff.
22:57:13 <merijn> Sensored: Yes, the main reason for the long platform delay was fixing GHC to cope with the fact that gcc was dropped for clang
22:57:15 <Sensored> i also need ports because i like to use wine
22:57:20 <Sensored> ah
22:57:23 <dfeuer> dolio, you have to use some RULES with it...
22:57:25 <Sensored> wait, so ghc works with clang?
22:57:28 <merijn> Sensored: 7.8 can work with clang
22:57:29 <dolio> No shit.
22:57:38 <merijn> Sensored: Platform version of 7.8 does by default
22:57:40 <Sensored> wtf no it doesnt
22:57:44 <Sensored> it breaks on my clang
22:57:46 <dfeuer> Well, I didn't know where you were erring....
22:57:53 <dfeuer> :P
22:57:54 <merijn> Sensored: Lemme rephrase
22:58:09 <merijn> Sensored: It at least works with the clang that ships with Mavericks' XCode
22:58:14 <Sensored> ah ok
22:58:16 <merijn> Sensored: For details ask carter when he wakes up
22:58:22 <Sensored> my clang must be out of date or something
22:58:23 <merijn> Sensored: He's the expert on ghc + clang
22:58:40 <merijn> Although he'll probably be busy most day due to ICFP
22:58:48 * dfeuer has the feeling Carter would be a bad person to awaken abruptly.
22:59:33 <merijn> Anyone got a copy of "Type Classes with Functional Dependencies" for me?
23:01:22 <dfeuer> merijn, what is that? Book? Article?
23:01:37 <merijn> dfeuer: Paper
23:01:46 <merijn> But my university proxy is acting up, so I can't get a copy
23:01:50 <dfeuer> merijn, THAT WAS EASY:  http://web.cecs.pdx.edu/~mpj/pubs/fundeps-esop2000.pdf
23:02:28 <merijn> dfeuer: Google Scholar kept licking me to a different file at pdx.edu >.> Thanks!
23:02:33 <dfeuer> Unless you can't access the web, merijn, in which case I guess I could email you....
23:03:23 <merijn> Naah, this works
23:03:29 <dfeuer> Kay.
23:04:00 <dfeuer> me should probably learn how to actually use git...
23:04:08 <dfeuer> *sigh*
23:04:58 <merijn> dfeuer: I have a handy cheat for you :)
23:05:12 <dfeuer> Oh?
23:05:12 <merijn> dfeuer: Learn to use Mercurial instead and then you use hg-git :p
23:05:21 <dfeuer> What is Mercurial?
23:05:30 <dfeuer> Is that even more complicated?
23:05:38 <dfeuer> Is it, perhaps, mercurial as well?
23:05:58 <merijn> dfeuer: Distributed version control, pretty much the same underlying model as git, started around the same time. The UI is *much* more userfriendly, though
23:06:15 <dfeuer> Ah. And hg-git?
23:06:23 <merijn> hg-git does lossless (mostly) two-way translation
23:06:49 <dfeuer> And why haven't these projects merged?
23:06:52 <merijn> I say mostly because git doesn't store file copies/moves, so Mercurial loses that info, other than it's fine
23:07:15 <merijn> hg-git has a bunch of additional dependencies
23:07:38 <dfeuer> I mean why hasn't Mercurial merged with git?
23:07:40 <merijn> Clones are slightly slower than pure git, but for small batches of commits the difference is negligible
23:07:56 <merijn> dfeuer: Oh, because they have slightly different focus
23:08:02 <merijn> in terms of workflow, etc.
23:08:08 <dfeuer> Hrm.
23:10:07 <merijn> I might be biased, I started learning mercurial as my first vcs, I tried git a couple of times (since all my colleagues use it) but I just get to confused usually
23:14:15 <dolio> Mercurial tries to be good, and git tries to be bad. :)
23:14:26 <dolio> Very different focus.
23:14:49 <merijn> dolio: Man, I can't wait for evolve to be production ready!
23:14:58 <merijn> I've been playing with it for a bit, it'll be so cool
23:16:24 <dolio> Haven't heard of that.
23:17:11 <dolio> Anyhow, this isn't really the place to be discussing vcs stuff.
23:17:41 <merijn> dolio: http://hg-lab.logilab.org/doc/mutable-history/html/obs-concept.html
23:17:44 <dolio> dfeuer: I literally copied the foldl and eft stuff into my file, and all their rules, and I still get no rules fired.
23:17:55 <merijn> (http://hg-lab.logilab.org/doc/mutable-history/html/ for more details and background)
23:18:42 <dfeuer> dolio, that's ... weird. I did the same and it worked for me.
23:18:52 <dfeuer> What was your test expression, dolio?
23:19:30 <dolio> foldl (+) 0 (eft 0 300)
23:21:05 <dfeuer> dolio, I get Rule fired: foldrW/buildW
23:21:23 <dolio> This is with -ddump-rule-firings?
23:21:33 <dfeuer> Yeah.
23:22:49 <dfeuer> You didn't accidentally forget -O2 or some such silly thing, did you?
23:24:42 <dolio> No.
23:25:15 <dfeuer> dolio, I stuck my test case in a separate module. Could that somehow have made a difference?
23:25:27 <dolio> No. I just tried that.
23:25:34 <dfeuer> What version ?
23:26:28 <dfeuer> I get fusion with 7.8.3 and also 7.9.
23:26:35 <dolio> 7.6.3, 7.8.3 and head from a few days ago.
23:27:02 <dfeuer> And 7.6.3.
23:27:09 <dfeuer> Yeah, this is weird...
23:27:29 <dfeuer> My head is a little older than yours, but I don't think that's the issue.
23:28:21 <dfeuer> dolio, I assume you copied the INLINE pragmas too? I mean, ... I don't want to come off sounding insulting or something, but it's working for me....
23:28:37 <dolio> Yes, I copied those.
23:29:20 <dfeuer> So it sounds like we did the same things with the same versions of GHC and the same code, and got totally different results. That makes no sense, so something must be different.
23:31:49 <dolio> Well, copying the whole file seems to work for no apparent reason.
23:32:06 <dfeuer> Ooooooookay.
23:32:18 <dfeuer> Call it a sacred mystery.
23:32:39 <dfeuer> By the way, it calls for ExistentialTypes but it doesn't actually seem to need them, as far as I can tell.
23:32:59 <dfeuer> er...  ExistentialQuantification I mean.
23:33:10 <dolio> There's an easy way to test.
23:33:19 <dfeuer> I commented that line out, and it still compiled...
23:33:54 <dfeuer> I assume that's what you meant.
23:34:06 <dolio> Yes.
23:38:06 <dolio> filter (>20) (eft 0 1000) doesn't fuse. Unsurprisingly.
23:47:43 <trap_exit> does any one have, for educational purposes, a good tutorial on how to implement Simply Typed Lambda Calculus w/ Type Inference in ahskell ?
23:47:46 <trap_exit> this is not for production use
23:47:56 <trap_exit> I just want to wirte it in haskell to learn the algorithm (I think it's called the W algorithm or something)
23:48:04 <trap_exit> feed me knowledge!
23:51:12 <edofic> http://www.grabmueller.de/martin/www/pub/AlgorithmW.pdf
23:51:25 <edofic> step by step implementation in haskell
23:51:33 <trap_exit> OMG
23:51:44 <trap_exit> edofic ++
23:52:25 <trap_exit> don't you hate it
23:52:30 <trap_exit> when you ask a question, and someone gives you exactly waht you want
23:52:39 <trap_exit> so then you have to go off and do work instead of goofing off on IRC ?
23:52:55 <edofic> I think this is actually bitter-sweet :)
