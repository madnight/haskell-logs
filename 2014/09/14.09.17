00:00:22 <jle`> but you say you're using catch
00:00:26 <jle`> :t catch
00:00:28 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
00:01:18 <jle`> so you are looking to fully evaluate something and handle any exceptions that are raised in the process of evaluating it :)
00:01:31 * hackagebot tickle 0.0.4 - A port of @Data.Binary@  http://hackage.haskell.org/package/tickle-0.0.4 (TonyMorris)
00:03:42 <Hijiri> I'm thinking of starting over with the mahjong library I talked about wanting to make a while ago
00:04:08 <Hijiri> when looking for patterns in a particular group of tiles would it be good to put them in a histogram?
00:05:15 <Hijiri> in japanese mahjong you can have groups of three same tiles, four same tiles, three consecutive tiles of the same suit, or a pair
00:05:26 <mroman_> trap_exit: I suggest using fromMaybe in such cases
00:05:46 <Hijiri> there are some tiles that have a numerical value and a suit, and others are just that tile
00:05:48 <mroman_> or at least use case foo of { Just x -> ok...; Nothing -> errHandling; }
00:06:02 <trap_exit> mroman_: that's not the question I'm asking :-)
00:06:03 <Hijiri> They sort of form a "suit" in that there are multiple tiles like that, eg red green white dragon
00:06:16 <trap_exit> I'm curious if catch + deepseq can catch all exceptions.
00:06:18 <Hijiri> but they don't interact with each other like a suiot
00:07:21 <theme2> hi
00:07:23 <theme2> I'm back
00:07:30 <Hijiri> hi
00:08:24 * hackagebot blaze-builder 0.3.3.4 - Efficient buffered output.  http://hackage.haskell.org/package/blaze-builder-0.3.3.4 (SimonMeier)
00:08:24 * hackagebot tickle 0.0.4 - A port of @Data.Binary@  http://hackage.haskell.org/package/tickle-0.0.4 (TonyMorris)
00:10:55 <blueonyx> :t fromMaybe
00:10:56 <lambdabot> a -> Maybe a -> a
00:11:06 <blueonyx> :t maybe
00:11:07 <lambdabot> b -> (a -> b) -> Maybe a -> b
00:14:00 <mroman_> @type catch
00:14:01 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
00:14:20 <mroman_> Can you actually catch undefined with catch?
00:14:27 <merijn> mroman_: "maybe"
00:14:51 <merijn> mroman_: undefined, pattern match failure and all those other things are *theoretically* catchable, but practically nearly impossible to catch
00:15:20 <merijn> Their exception only gets thrown when their thunk is evaluated, which due to laziness may happen *after* catch has already returned
00:15:39 <mroman_> merijn: lol
00:15:45 <merijn> > return undefined `catch` \(SomeException _) -> return (Just 1)
00:15:47 <lambdabot>  <IO (Maybe Integer)>
00:15:48 <mroman_> That sounds disturbing.
00:15:50 <merijn> err
00:15:52 <merijn> anyway
00:16:04 <merijn> mroman_: You should avoid "throw" like the plague for the same reason
00:16:17 <jle`> it all has to do with the semantics of what errors and eceptions actually mean in Haskell
00:16:24 <merijn> Use throwIO, the IO will *force* the exception to be raised before catch can return
00:16:50 <merijn> :t throwIO
00:16:51 <lambdabot> Exception e => e -> IO a
00:16:54 <merijn> :t throw
00:16:55 <lambdabot> Exception e => e -> a
00:17:38 <jle`> in a way, `undefined`/`error` are really semantically identical (when not in IO) to infinite loops and non-terminating computations
00:17:43 <merijn> mroman_: Basically, catch will execute all side effects in its input argument before returning and "throwIO"'s side-effect is "raises an exception"
00:17:54 <merijn> Also, what jle` said
00:18:06 <Hijiri> they're both bottom, right?
00:18:32 <jle`> yeah
00:18:39 <jle`> it's only inside IO that they are given some special meaning
00:18:52 <jle`> as a tool provided by the runtime system
00:19:03 <blueonyx> so if you deepseq catch can catch anything?
00:19:25 <merijn> blueonyx: Yes, no, maybe, just use throwIO instead :p
00:19:34 <jle`> you really have to think about what it even means to evaluate/catch
00:19:43 <jle`> intuition from other languages might be harmful here
00:20:06 <jle`> remember that deepseq acts the same way that seq acts
00:20:19 <jle`> seq x y means "when you evaluate y, evaluate x"
00:20:41 <jle`> so you can type deepseq x y all you want (if you want to force x)...but if you never use y, x is never evaluated
00:21:44 <jle`> if you deepseq an IO action, you are actually only deepseqing the data structure containing the instructions for the action...you are not forcing it to run
00:21:46 <blueonyx> hm let me check how hint handles compile errors
00:23:10 <jle`> btw, the `spoon` library from hackage attempts to make some of this a little more easy to reason about...using unsafePerformIO, of all things.
00:23:46 <mroman_> Theres also evaluate $!!
00:23:52 <jle`> just be aware it breaks semantics pretty heavily v.v
00:24:30 <mroman_> For my interpreter I use timeout foo $ evaluate $!! interpret code
00:24:33 <mroman_> It covers most cases
00:26:09 <blueonyx> :t evaluate
00:26:10 <lambdabot> a -> IO a
00:26:14 <mroman_> Generally I remember that deepseqing stuff like map (succ) [1..] is of no use
00:26:34 <mroman_> if you want to have a timeout
00:26:56 <jle`> if i am lazy and the thing i am trying to force is Show, i just print it
00:26:58 <jle`> >_>
00:27:14 <mroman_> because map (succ) [1..] returns pretty much immediately
00:27:16 <jle`> don't judge pls
00:27:32 <mroman_> jle`: You should print it to /dev/null .
00:28:01 <jle`> but then my code doesn't look like it's doing something anymore
00:28:10 <blueonyx> i have a too step process, i get the code which evaluates to a function, so i have to report compile errors, if there are none i get data to evaluate the function
00:28:17 <jle`> to the people watching me from over my sohulder
00:28:33 <blueonyx> now i have to catch stuff like non-exhaustive patterns etc
00:28:38 <epta> how do you guys check that particular cabal project have no redundant dependencies?
00:28:42 <blueonyx> s/too/two/
00:31:33 <theme2> Heh... I sped up my program from 2 mins to 1.5 mins
00:31:47 <theme2> by using IntSet instead of Set Int
00:32:12 <theme2> Now, I still can't figure out what is "ARR_WORDS" doing in my heap profile
00:32:27 <slack1256> Warning: Couldnt figure out linker information
00:32:35 <slack1256> anyone getting that with ghc 7.8.3
00:32:36 <slack1256> ?
00:33:09 <blueonyx> slack1256: yes
00:33:26 <blueonyx> slack1256: workaround is LANGUAGE=en
00:33:34 <blueonyx> +my
00:35:05 <slack1256> I'm gonna try it out.
00:35:06 <blueonyx> slack1256: https://ghc.haskell.org/trac/ghc/ticket/8825
00:38:26 <Axman6> theme2: http://stackoverflow.com/questions/7241470/what-is-arr-words-in-a-ghc-heap-profile first link when googling "ghc ARR_WORDS"
00:38:58 <theme2> The thing is, I'm not using arrays of any kind
00:39:09 <Axman6> are you using ByteString or Text?
00:39:13 <theme2> nope
00:39:16 <theme2> no text parsing
00:39:22 <theme2> except simple output
00:39:50 <theme2> which is nothing more than printStrLn with "blah blah "++ show whatever
00:40:19 <theme2> I've just realized I can categorize heap usage by module
00:40:36 <theme2> And it says it's in module SYSTEM
00:40:42 <theme2> any idea what it is?
00:41:49 <Axman6> how big is your project? any reason you can't just share the code?
00:41:56 <theme2> Ah right
00:42:01 <theme2> Silly me
00:42:16 * theme2 opens pastebin
00:43:15 <theme2> It's a personal project. hehe
00:44:03 <slack1256> blueonyx: It works, I'm gonna check out that ticket, thanks.
00:45:38 <theme2> http://pastebin.com/YfvcUrYT
00:46:05 <theme2> This is my code that seems to be leaking some memory
00:48:10 <theme2> Any idea why does it use so much memory for "ARR_WORDS" in module "SYSTEM"?
00:50:15 <Axman6> computing IntSet.fromList [2..x] every time seems needlessly wasteful, why not just insert x into the same set every iteration?
00:51:41 <theme2> hmm
00:52:43 <Axman6> (well, x and x-1)
00:53:20 <theme2> well... it can't be the bottleneck, right?
00:53:34 <Axman6> I would guess isPrime is using arrays though
00:55:22 <Axman6> hmm, doesn't look like it
00:55:25 <int-e> Axman6: it doesn't though.
00:55:46 <theme2> I don't see any arrays in http://hackage.haskell.org/package/primes-0.2.1.0/docs/src/Data-Numbers-Primes.html
00:56:19 <jle`> is `join seq` indistinguishable from `id` in all meaningful ways?
00:56:59 <theme2> strange
00:58:24 <haasn> jle`: I'd say so
00:58:45 <theme2> Axman6: any ideas?
00:59:12 <jle`> i have been pondering it
00:59:27 <jle`> but i don't think there's too much to think about it
01:00:31 <theme2> Finding memoy leaks in haskell is hard
01:00:39 <Axman6> theme2: yeah no idea, not without profiling it myself anyway
01:01:09 <theme2> it uses about 90 seconds on my machine
01:01:40 <theme2> for some reason it uses most of the time to process the x=110 case
01:05:34 <theme2> It uses less than a second for x = 2,4,...,108
01:05:40 <theme2> yet it uses so much time for x=110
01:05:47 <theme2> Is 110 special or something?
01:32:25 <Total_1mmersion> Has anyone installed the Haskell Platform (with AMP, GHC 7.8 I believe) on Ubuntu through the package manager? I keep getting GHC 7.6.
01:33:08 <theme2> heh
01:33:18 <theme2> I never realized I was using ghc 7.6
01:33:27 <theme2> :/
01:33:31 <spacekitteh> um isn't AMP only in 7.10
01:34:06 <shachaf> There has been no release of GHC with Applicative as a superclass of Monad.
01:34:19 <Total_1mmersion> ah you're right, sorry about that
01:34:37 <spacekitteh> Total_1mmersion: add hvr's PPA and grab a head
01:35:05 <Total_1mmersion> How do I add that PPA? I know the command is something like add-apt ppa:??
01:35:11 * spacekitteh shrugs
01:37:41 <mr-> Total_1mmersion: Why don't you just get the binary from haskell.org and install it?
01:38:53 <hexagoxel> can anybody confirm that cabal configure/cabal install produces almost no output even with -v3, if the --preference flag is being used?
01:39:36 <hexagoxel> oh wait, nevermind
01:40:09 <bahamas> what's the state of GUI toolkits in haskell?
01:40:48 * hexagoxel fell into the trap of using ">" in the commandline to specify a constraint..
01:42:12 * spacekitteh giggles and hugs hexagoxel 
01:42:14 <spacekitteh> there there
01:43:23 * hackagebot halberd 0.1.2.9 - A tool to generate missing import statements for Haskell modules.  http://hackage.haskell.org/package/halberd-0.1.2.9 (ErikHesselink)
01:45:34 <spacekitteh> whelp, time to make an FRP library
01:49:36 <jle`> gluck spacekitteh
01:49:53 <jle`> welcome to the club
01:50:25 <bahamas> so, any good candidate to do GUI programming in haskell?
01:50:37 <jle`> bahamas: i've heard good things about threepenny?
01:50:51 <bahamas> jle`: I was reading a reddit thread about that now
01:50:53 <mr-> bahamas: depending on what GUI means, gloss is awesome
01:50:56 <bahamas> along with reactive-banana
01:51:12 <bahamas> mr-: I'm referring to a desktop app
01:52:36 <trap_exit> anyoen here familiar with csound, supercollider, or pure data? I'm trying to pick one of them to use to do basic sound effects from Haskell, but I don't know what to pick
02:05:59 <splintax> int-e: is your fork of lambdabot the most actively maintained one right now? just want to get a personal instance running, but i'm having build errors and the project doesn't seem to have a clear owner...
02:31:12 <yitz> splintax: it int-e doesn't seem to be around, you can use lambdabot to leave a message
02:31:31 <splintax> ha ha
02:31:43 <splintax> curious to hear from anyone who has successfully built lambdabot recently, anyway
02:32:02 <MP2E> it wasn't a joke >_>
02:32:12 <MP2E> you can use @tell
02:33:56 <splintax> i know, but i was hoping to get some advice now! i'm impatient!
03:11:26 <wnxm> Hello, I'm trying to find the latest documentation for a package on hackage but for some unfathomable reason, I just can't find it on the package's hackage page.
03:11:36 <wnxm> The package specifically is Text (http://hackage.haskell.org/package/text)
03:11:53 <wnxm> but I'm sure I couldn't find the doc for any other packages (without going through google)
03:12:51 <wnxm> so... what's up with that? Have I just missed something or is the doc really not accessible from packages' pages?
03:17:28 <hexagoxel> wnxm: hackage normally builds the doc, but seems to have more or less stopped doing that since.. like 2 weeks. while it is possible to manually upload docs, few maintainer bother. afaik, hackage servers are supposed to be upgraded soon (and resume building docs automatically)
03:20:56 <wnxm> are there some alternatives available in the meantime?
03:21:46 <chrisdotcode> Of hackage? Doesn't fpcomplete have a mirror?
03:22:32 <silver> wnxm, it should be possible to download source of package from, for example, github and build the docs manually
03:22:38 <hexagoxel> 1) use an older version's docs 2) download package, build docs locally
03:23:11 <nshepperd> or read source code, which I've been doing...
03:23:26 <hexagoxel> (using github is not strictly necessary; the packages from hackage themself are fine)
03:24:04 <hexagoxel> (see "cabal get")
03:24:09 <silver> oh indeed
03:24:12 <silver> forgot about that
03:24:30 <silver> silly me
03:25:09 <wnxm> Actually, I just figured out the doc is available from the debian repos
03:25:17 <wnxm> which seems like the simplest solution for me
03:25:42 <wnxm> Anyway, thanks for the info
03:38:09 <mmachenry> Any London Haskellers around?
03:38:48 <doismellburning> mmachenry: yes
03:39:07 <mmachenry> I just landed in London.
03:40:41 <mmachenry> I'm heading out of here in a day or two. Wondering if any Haskellers want to get a drink in London later.
03:58:28 * hackagebot cabal-dependency-licenses 0.1.0.0 - Compose a list of a project's dependencies with their licenses  http://hackage.haskell.org/package/cabal-dependency-licenses-0.1.0.0 (JasperVanDerJeugt)
04:03:29 * hackagebot cabal-dependency-licenses 0.1.0.1 - Compose a list of a project's transitive dependencies with their licenses  http://hackage.haskell.org/package/cabal-dependency-licenses-0.1.0.1 (JasperVanDerJeugt)
04:08:19 <krgn_> is it possible to specify parallel building in the cabal file itself?
04:12:28 <bergmark> krgn_: no, but you can specify it in your cabal config
04:12:55 <bergmark> i don't think it makes sense for the package author to decide this for me
04:13:49 <krgn_> bergmark: ah true
04:13:53 <tdammers> indeed
04:14:06 <krgn_> bergmark: thanks!
04:15:02 <krgn_> do'h, its even in there commented out
04:16:52 <MasterMastic> Is there any way to place markers in .eventlogs from my code? (I'm threadscoping a benchmark and would like to know which function starts where. If there isn't a way to do that - any tips on how to cope?)
04:24:54 <dcoutts> MasterMastic: yes, you can emit custom events
04:28:11 <dcoutts> MasterMastic: oh, wait, even better
04:28:27 <dcoutts> I'd forgotten if I'd got this in already, but seems I have
04:28:37 <dcoutts> MasterMastic: using Debug.Trace.traceMarker
04:28:49 <dcoutts> you can emit a marker that will appear as a bookmark in threadscope
04:29:25 <dcoutts> and the use case is indeed for delimiting the start/end of things of interest, or phases or whatever
04:30:15 <dcoutts> MasterMastic: you just need to be using a sufficiently recent version of ghc and threadscope to have the marker functionality
04:30:46 <MasterMastic> dcoutts: Thank you very much! I'll check it right away.
04:30:57 <dcoutts> np
04:31:01 <dcoutts> hope it's useful
04:32:06 <MasterMastic> Incredibly :)
04:34:26 <zomg> I recall a few discussions about learning haskell here, and whether or not it's more difficult for someone who hasn't done any programming before vs. non-fp langs
04:34:51 <zomg> My gf is interested in learning to program, and I showed her some web dev stuff as she wants to learn that
04:35:07 <hpc> it might be a little different, but they're very different
04:35:09 <zomg> She's never done any programming before
04:35:43 <zomg> I gave her a quick glance at javascript, and then some comparable haskell functions
04:35:53 <zomg> she had a much easier time understanding the haskell ones :)
04:36:10 <MasterMastic> Must be a keeper ;)
04:36:17 <zomg> ha, yep
04:39:12 <hpc> the big thing will be getting her to the point of being able to test her own code easily, and knowing the best places to look stuff up
04:39:45 <mroman_> Haskell's always a keeper :P
04:40:02 <hpc> from there, it's going to just be having the programming mindset and gradually gaining experience
04:42:43 <zomg> Yeah
04:43:57 <stefan_1__> hpc: what is "the programming mindset"?
04:45:05 <MasterMastic> stefan_1__: it's being a duck lunatic - http://ultrafactsblog.com/post/97179478026/just-dazed-kierenwalkerpds
04:45:26 <MasterMastic> Just go ballistic on them and you can call yourself a software developer
04:47:55 <stefan_1__> and i have been talking to my rubber duck in the bathtub this whole time
04:54:27 <pjdelport> zomg: Coolness!
04:55:20 <pantsman-> zomg: I explained pure functions to my wife (who has never programmed before) and she said, "aren't all languages like that? That just makes sense.@
04:55:35 <pantsman-> ugh, Apple keyboard. @ = "
05:25:32 <SwashBuckla> Advantage Kinesis <3
05:26:12 <hyPiRion> Hrm, is it possible to list all the dependencies of the cabal project you're working on (with version numbers)?
05:26:43 <doismellburning> cabal freeze?
05:27:11 <johnw> hyPiRion: cabal init will do that
05:27:15 <Tor_> hello, i am new to learning haskell, where can i find helpful tutorials?
05:27:21 <johnw> just temporarily move your .cabal file, and then use cabal.init
05:27:27 <johnw> "cabal init"
05:27:35 <johnw> Tor_: haskell.org should have links to several
05:27:43 <Tor_> ty
05:27:49 <Taneb> Tor_:
05:27:53 <Taneb> @where LYAH
05:27:53 <lambdabot> http://www.learnyouahaskell.com/
05:27:55 <sivteck> Tor_, this might help, https://github.com/bitemyapp/learnhaskell
05:28:00 <Tor_> thanks!!!!
05:30:59 <hyPiRion> johnw: so uh, is there a way to do this programmatically? I want to embed version numbers in the application I ship, so I'd like to dump it to a file in a build step.
05:31:30 <johnw> hyPiRion: see the cabal-bounds tool
05:31:45 <johnw> it was designed for exactly that use case, I believe
05:31:47 <hyPiRion> johnw: alright, I'll have a look. thanks
05:40:30 <MasterMastic> I generated an event-log for just like 10 seconds of work and the file gets to be around 800mb, and threadscope isn't handling that well.. is there anything I can do to help it? perhaps log less somehow?
05:44:20 <oakwhiz> MasterMastic: log to tmpfs
05:45:43 <MasterMastic> oakwhiz: I'm on Windows, but yeah that's clever, I'll try with RAM disk. I'll give it a shot.
05:52:53 <ph88> is there a way to design a GUI for haskell in a UI designer and still have the programmed compiled to a single file?  i've read this, but it loads an xml at runtime it seems http://book.realworldhaskell.org/read/gui-programming-with-gtk-hs.html
05:53:45 <Tor_> any other haskell channels reccomended?
05:54:46 <tdammers> Tor_: #haskell-blah. Not technically a haskell channel though, more like (everything but [haskell) and stupid parenthesis jokes]
05:55:03 <Tor_> lol k ty
05:55:51 * mjrosenb asked yesterday... how do I convert an Int/Integer to a hex string?
05:57:33 <opqdonut> mjrosenb: Numeric.showHex
05:57:41 <mroman_> mjrosenb: Data.Digits or Numeric
05:58:28 <Tor_> another random question , i guess, any good java channels? note, not javascript
05:58:32 <opqdonut> > Numeric.showHex 1887 "" -- mjrosenb
05:58:34 <lambdabot>  "75f"
05:58:54 <mroman_> > map (\x -> "0123456789ABCDEF" !! x) $ digits 16 1887
05:58:55 <lambdabot>  Not in scope: ‘digits’
05:58:55 <lambdabot>  Perhaps you meant one of these:
05:58:55 <lambdabot>    ‘BSC.inits’ (imported from Data.ByteString.Char8),
05:58:55 <lambdabot>    ‘BSLC.inits’ (imported from Data.ByteString.Lazy.Char8),
05:58:55 <lambdabot>    ‘inits’ (imported from Data.List)
05:59:05 <mjrosenb> wait, where did the f come from?
05:59:21 <mroman_> > 0x75F
05:59:23 <lambdabot>  1887
05:59:26 <mjrosenb> err.
05:59:27 <opqdonut> from the value 1887 :)
05:59:28 <mjrosenb> d'oh.
05:59:29 <mjrosenb> right
05:59:30 <mjrosenb> hex.
06:00:23 <mjrosenb> ok, but the second argument *is* something that gets appended to the string, right?
06:00:28 <mroman_> @hoogle showAtBase
06:00:30 <lambdabot> No results found
06:00:31 <mjrosenb> > showHex 1000 "World"
06:00:32 <mroman_> hm
06:00:32 <lambdabot>  "3e8World"
06:01:07 <opqdonut> mroman_: it's showIntAtBase
06:01:46 <opqdonut> mjrosenb: yeah the return value of showHex is ShowS, which is just String -> String
06:01:56 <opqdonut> mjrosenb: the whole ShowS thing is just a performance optimization, mostly
06:05:38 <pjdelport> Tor_: #haskell-beginners is good for longer discussions and questions you might have. (It's less high-volume than this channel)
06:05:48 <quchen> mjrosenb: showIntAtBase and all the other ShowS-using functions implement their own thing similar to a DList.
06:06:10 <wz1000> Is it possible for an undirected graph to me a meaningful Applicative?
06:06:12 <mjrosenb> DList?
06:06:21 <quchen> They basically replace string concatenation by function composition for better performance.
06:06:38 <mjrosenb> quchen: yeah.  that makes sense.
06:06:39 <quchen> LYAH has a section on DLists ("difference lists").
06:07:05 <mjrosenb> quchen: I just had a brain fart while looking at the result from before, and got very confused.
06:07:24 <prophile> wz1000: would Graph a have a as the edges or the nodes?
06:07:48 <prophile> and if the edges what would the nodes be or if the nodes what would the edges be?
06:08:23 <wz1000> posco: nodes. Let the edges be ints for simplicity.
06:08:46 <wz1000> sorry, I meant prophile
06:08:53 <prophile> hm
06:09:07 <Tor_> hey guys how do i calculate the numbers of 1 + 1?
06:09:11 <prophile> so I don't think so
06:09:19 <prophile> because I *think* that's approximately (a -> a -> [Int])
06:09:21 <pjdelport> > 1 + 1
06:09:22 <lambdabot>  2
06:09:25 <pjdelport> Tor_: As in that?
06:09:38 <prophile> (in essence you give it two nodes and it tells you what edges are between them)
06:09:44 <prophile> and I don't think that's a Functor
06:10:11 <prophile> because a is in negative position
06:11:23 <quchen> 1+1 can be many things, depending on what 1 and + mean. If it's the Integer 1 then the result is of course the Integer 2. But there are many other Num instances.
06:11:52 <wz1000> prophile: If you implement a graph as a set of nodes and edges, Won't the functor instance be the one which transforms every node into something else while keeping the structure of the graph?
06:11:52 <quchen> Fully written out, "1+1" is actually interpreted as "fromIntegral 1 + fromIntegral 1".
06:12:59 <pjdelport> wz1000: That seems reasonable.
06:13:04 <wz1000> quchen: Lets derive the value using ZFC.
06:13:05 <pjdelport> wz1000: What would <*> do for that, though?
06:13:13 <quchen> Let's not.
06:13:41 <wz1000> pjdelport: I have no idea. Thats what I was asking.
06:13:43 <prophile> wz1000: so having it look something like [(a, a, Int)]?
06:14:03 <prophile> a list of pairs of nodes along with weights?
06:14:20 <wz1000> For simplicity, lets have unlabled edges.
06:14:28 <prophile> so [(a, a)]?
06:14:48 <prophile> in which case yes, that's Compose [] ((->) Bool)
06:15:51 <wz1000> prophile: yes will do, although I wanted something like ([a],[(a,a)]) to allow orphan nodes.
06:16:28 <quchen> How about `Map a (Set a)`, which is a node with a set of outgoing target edges
06:16:58 <quchen> Or `Vector (a, Vector a)` if you want to allow duplicates
06:17:21 <pjdelport> wz1000: You could perhaps do something akin to the default instance for []: for f <*> x, apply every node in f to every node in x, propagating the edges for each combination?
06:18:24 <pjdelport> and have 'pure a' construct a singleton graph
06:18:44 <pjdelport> so "pure f <*> x" and "f <*> pure x" would do the obvious things.
06:18:46 <wz1000> How would the edges be propogated?
06:19:26 <wz1000> If have have graphs with two different structures, how would you apply one to the other?
06:21:01 <pjdelport> wz1000: I vaguely visualize something akin to "instantiating" the one graph in the context of each node of the other graph, and making links between the resulting nodes based on the latter.
06:22:44 <wz1000> Lets think about implementing join for a graph.
06:23:35 * hackagebot snaplet-amqp 0.1.2.3 - Snap framework snaplet for the AMQP library  http://hackage.haskell.org/package/snaplet-amqp-0.1.2.3 (ParnellSpringmeyer)
06:23:55 <wz1000> How would you squash a graph of graphs into a graph?
06:25:48 <pjdelport> wz1000: So if you have two two-node graphs f - g and a - b, you might end up with a square graph:
06:25:48 <pjdelport> f a -- g a
06:25:48 <pjdelport>  |      |
06:25:48 <pjdelport> f b -- g b
06:26:49 <pjdelport> If f and g were unconnected in the first graph, then you would have the same nodes except with the f a -- f b and f b -- g b edges disconnected.
06:26:54 <wz1000> Why are there no diagonals?
06:27:07 <pjdelport> And if a and b were unconnected, you would have the other pair of connections broken.
06:27:59 <wz1000> Cool
06:28:20 <wz1000> Does this satisfy the laws for applicative?
06:28:35 * hackagebot snaplet-amqp 0.1.2.4 - Snap framework snaplet for the AMQP library  http://hackage.haskell.org/package/snaplet-amqp-0.1.2.4 (ParnellSpringmeyer)
06:28:54 <wz1000> Specifically composition.
06:29:35 <wz1000> It does satisfy homomorphism and identity.
06:31:40 <wz1000> So basically, there is an edge between two nodes (f a) and (g b) iff f == g or a == b?
06:33:48 <pjdelport> wz1000: I would say there is an edge between any two (f x) and (f' x') if either of f and f' or x and x' were connected in the original graphs.
06:35:39 <pjdelport> wz1000: The way i visualize it is that or an application of graph f - g to graph a - b, you can think of first putting the entire graph on the left "inside" each node on the right: (f a - g a) -- (f b - g b)
06:36:50 <pjdelport> And then you connect all the nodes of the inner sub-graphs based on the outer graph's connection.
06:37:00 <pjdelport> So yeah, actually, based on that, there should be diagonals, like you said. :)
06:37:34 <pjdelport> So applying two completely-connected graphs would always result in a new completely-connect graph.
06:38:23 <blogle_> exit
06:38:48 <wz1000> blogle_: I won't
06:39:14 <pjdelport> And applying two unconnected graphs would result in an unconneced graph.
06:39:41 <blogle_> sorry, changed irc clients and not used to the new cli
06:39:52 <blogle_> forgive my blunders
06:40:03 <pjdelport> So in the above example again, if you broke the a - b connection, you would have the result (f a - g a), (f b - g b), with only those connections.
06:44:43 <wz1000> pjdelport: I think I find your first thing more intuitive. (f a) seems to be further away from (g b) than from (f b) or (g a)
06:45:30 <pjdelport> wz1000: You're right. I'm not entirely sure which intuitive approach would pan out here.
06:47:32 <pjdelport> Because the result of a substitution like (f a - g a) -- (f b - g b) is guaranteed to have each node filled with a sub-graph of the same shape, you would be able to "zip" them based on whether there's an outer connection.
06:47:42 <pjdelport> Instead of connecting every possible combination of nodes of the two sub-graphs.
06:47:57 <pjdelport> OTOH, that doesn't generalize to defining join.
06:48:30 <Phillemann> I have "newtype GameDataM a = GameDataM { runGameData :: ConduitM A B (RandT StdGen M) a } deriving(MonadRandom)" (where A,B,C are appropriate types). However, ghc cannot derive MonadRandom and says I should use a standalone 'deriving instance' declaration. I'm not sure why and what to do.
06:48:43 <Phillemann> It _can_ derive Monad, though.
06:49:31 <pjdelport> wz1000: It would be good to hack some code out and try QuickCheck properties against it. :)
06:50:57 <wz1000> pjdelport: I don't have access to ghc for the next few days :(
06:52:01 <Tor_> im trying to make a calculator in haskkel
06:52:05 <Tor_> any pointers?
06:53:08 <wz1000> Tor_: No, haskell doesn't have explicit pointers :P
06:53:10 <osfameron> Tor_: surely that depends on how far you've got and what you want it to do... you'll have to give more details
06:54:03 <pjdelport> Tor_: Here's one tutorial for that kind of thing: https://www.fpcomplete.com/user/adlew/calculator
06:54:47 <pjdelport> Tor_: Check out https://www.youtube.com/playlist?list=PL_xuff3BkASMOzBr0hKVKLuSnU4UIinKx too perhaps
06:57:03 <quchen> wz1000: IORefs are very similar to pointers in practice.
06:58:05 <copumpkin> instance Num (IORef a)
06:58:07 <copumpkin> >_>
07:03:27 <meretrix> Is there any safe way to read from a handle without having to worry about exceptions?
07:04:18 <nshepperd> my haskell calculator is /usr/bin/ghci :)
07:04:44 <negatratoron__> repl as calculator
07:04:57 <negatratoron__> same here
07:05:43 <nshepperd> copumpkin: haha, the only way I can see to implement that involves unsafePerformIO and a lot of nondeterminism
07:07:51 <nick___> very nice video <pjdelport>
07:09:36 <nshepperd> of course + has to be pure, and you can only read, write and create IORefs in IO, so... (a + b) = unsafePerformIO $ ((+) <$> readIORef a <*> readIORef b) >>= newIORef
07:10:20 <nshepperd> whee, now your results depend on evaluation order
07:11:11 <quchen> nshepperd: (+) does not have to be pure.
07:11:32 <nshepperd> :t (+)
07:11:33 <lambdabot> Num a => a -> a -> a
07:11:45 <quchen> All sensible instances I know are pure, but nothing inherently prevents impure Nums.
07:12:35 <nshepperd> you can write an instance Num (IO (IORef a)), sure
07:14:17 <SwashBuckla> generating hoogle database is taking... forever
07:14:29 <SwashBuckla> at least, it's been on 0% for the last 30 minutes
07:15:08 <SwashBuckla> Extracting tar file downloads/cabal.index
07:15:09 <SwashBuckla> # cabal.tar (for downloads/cabal.index)
07:15:16 <SwashBuckla> (0%)
07:16:12 <nshepperd> although, I think copumpkin was talking about a Num instance that does pointer arithmetic
07:17:36 <nshepperd> that sort of evilness is beyond me
07:32:42 <yhvh> hey, I'm trying to remember a paper written about haskell in an amusing style, it featured interactions between named individuals, one of whom was a mathematician - all working at some company. Ring any bells?
07:33:40 <benzrf> sounds almost familiars.................
07:34:34 <Philonous> Is it possible that the same code as a top level function would type check while it wouldn't as a where clause?
07:34:48 <Philonous> (In the presence of GADTs)
07:35:41 <Philonous> Or put differently: Is polymorphic recursion not possible in a where clause?
08:03:40 * hackagebot radium 0.2 - Chemistry  http://hackage.haskell.org/package/radium-0.2 (klangner)
08:04:15 <pjdelport> yhvh: http://sebfisch.github.io/haskell-regexp/regexp-play.pdf ?
08:05:00 <oakwhiz> when I try to build the bytestring-0.9.1.10 package in cabal, I get an error: ghc.exe: unrecognised flag: -fno-method-sharing
08:05:14 <oakwhiz> I'm using the Haskell Platform on Windows at the moment
08:06:27 <fgc> pjdelport: Your conversaion above reminds me of this: http://math.mit.edu/~dspivak/informatics/talks/CMU2014-01-23.pdf
08:06:39 <oakwhiz> maybe I just have to use the latest version.
08:07:15 <geekosaur> Philonous, see http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#mono-local-binds ?
08:07:58 <frerich> Hi, does anybody here have a moment to help me with optimizing a little interpreter I wrote? It's a Brainfuck interpreter which I hope to make faster. I did a profiling build, ran with '+RTS -s' and say that it uses only 3MB of memory and 99.8% productivity, so GC doesn't seem to be the issue. The start of the '+RTS -p -hy' output is at http://lpaste.net/111158 which shows that 'exec' (a heavily recursive function)
08:07:59 <frerich>  is where most of the time is spent. The allocation graph at http://s13.postimg.org/dkd8rpz3b/brainfuck.png shows that there's a fairly constant usage, too.
08:07:59 <frerich> The 'exec' function which is at the top of the profiling output is defined at https://github.com/frerich/brainfuck/blob/master/src/Data/Language/Brainfuck/Interpreter.hs#L35 -- it simply dispatches various instructions.
08:08:13 <frerich> Oops, sorry for the funky linebreak.
08:09:07 <frerich> I *think* the profiling output is a bit deceiving because 'exec' is recursive, but then - I can't imagine what might be the costly part of it. Most of it deals with getting/setting values in a mutable (unboxed) vector of Ints
08:10:03 <frerich> '-O2' didn't make any difference unfortunately. I read that vectors can benefit greatly from the llvm backend, but I don't have that here (I'm on Windows).
08:12:50 <yhvh> pjdelport: thanks!
08:13:40 * hackagebot random-fu 0.2.6.1 - Random number generation  http://hackage.haskell.org/package/random-fu-0.2.6.1 (DominicSteinitz)
08:20:13 <KorriX> Hello! Is there any way of defining constrained instance using QuasiQuotation?
08:23:41 * hackagebot unlit 0.1.0.0 - Tool to convert literate code between styles or to code.  http://hackage.haskell.org/package/unlit-0.1.0.0 (pepijnkokke)
08:24:20 <Gonzih> I just found out about helm project (game engine in haskell). But I don't see lot of activity on github and can't find good examples. Where should I look?
08:27:48 <Cale> Gonzih: I don't know where you can find examples, but there's what looks like pretty decent Haddock documentation here: http://hackage.haskell.org/package/helm
08:28:41 * hackagebot effect-monad 0.6.1 - Embeds effect systems into Haskell using parameteric effect monads  http://hackage.haskell.org/package/effect-monad-0.6.1 (DominicOrchard)
08:28:52 <Gonzih> Cale: true, my bad :)
08:28:55 <Cale> Gonzih: also http://hackage.haskell.org/package/elerea
08:29:11 <vanila> Gonzih, I think that Helm is under active development but it's slow paced
08:30:31 <Cale> Elerea is being used on Wayward Tide, which is another game from Chucklefish, the company that's also in the process of making Starbound.
08:31:21 <Cale> http://blog.chucklefish.org/?p=154
08:31:37 <Forkk> So are any of the major FRP libraries out there mature enough for production use? I'm fine with living on the bleeding edge a bit, but I'm a little concerned about performance.
08:31:50 <michaelt> frerich: foldM is the problem. I've heard that it tends to be a loser, and this seems 8 - 10 x as fast, just using dumb recursion http://sprunge.us/VJXA
08:32:04 <michaelt> frerich: or part of the problem.
08:33:41 * hackagebot multistate 0.1.3.1 - like mtl's ReaderT/StateT, but more than one contained value/type.  http://hackage.haskell.org/package/multistate-0.1.3.1 (lspitzner)
08:34:17 <frerich> michaelt: uh-oh, let me try that. I thought foldM was so nice! :-)
08:35:04 <systemfault> Is there any book/documentation/tutorial/anything about how to build applications in a functional way?
08:36:03 <systemfault> Now that I have 'haskell basics', I would like to know how to build/modularize/think about FP architectural patterns .. etc
08:37:50 <frerich> michaelt : Did you modify the .cabal file somehow (e.g. adding/removing -O2), or did you configure/build with some custom flags? Or did you just do 'cabal configure && cabal build' after cloning?
08:38:20 <frerich> michaelt: Also - how did you figure out that foldM might be the (well, one) culprit? Just an educated guess? :-)
08:38:27 <KKK|ZLINE> I HATE NIGGERS AND JEWS AND FAGGOTS AND PUSSIES
08:38:42 <KKK|ZLINE> I HATE NIGGERS AND JEWS AND FAGGOTS AND PUSSIES
08:40:30 <frerich> michaelt: Indeed, it's a *lot* faster...
08:45:26 <michaelt> frerich: I just did cabal configure && cabal build  I had heard complaints about foldM  .  Maybe getCell at could do with strictness clarification too?
08:45:53 <michaelt> i wonder how foldM is defined ....
08:46:20 <frerich> michaelt: Hrmm.. maybe, yeah. To be honest, I said 'maybe X' a couple of times already while trying to make this program faster. I'm somewhat surprised about foldM making that big a difference - especially since it never showed up in the profiling output
08:47:00 <kuyatzu> michaelt: http://hackage.haskell.org/package/base-4.7.0.1/docs/src/Control-Monad.html#foldM look it up
08:47:10 <frerich> michaelt: Doesn't help that hlint - as soon as I use manual recursion - suggests 'Why not use foldM?' :-}
08:47:11 <michaelt> kuyatzu: yeah i'm looking
08:47:33 <frerich> Maybe it would have helped if foldM was inlined?
08:47:35 <michaelt> note that the docs say "just like foldl'
08:48:55 <michaelt> basically i inlined the definition it seems
08:50:49 <xcthulhu> Is prefering `Control.Arrow.>>>` to `(.)` and `Control.Lens.&` to `($)` contrary to idiomatic Haskell?
08:51:01 <michaelt> frerich: one thing I was wondering about -- this could be dumb -- was the Machine type. It has a mutable vector inside. This suggests to me that you want exec :: Machine -> Instruction -> IO ()
08:51:39 <michaelt> then the compiler can see in advance that there's no new mutable vector being returned.  This would involve changing the Machine type though.
08:51:57 <frerich> michaelt: Yeah, maybe. My original idea was to be able to 'chain' exec calls (using folDM).
08:51:59 <xcthulhu> …I have been programming Clojure for a while (having learned Haskell first and now coming back to it)… and I find it hard to read/think backwards like I used to in Haskell
08:53:19 <osfameron> backwards?
08:54:09 <xcthulhu> Yeah, so in the Category of Haskell Functions, `(Control.Arrow.>>>) = flip (.)`
08:54:43 <xcthulhu> And likewise `(Control.Lens.&) = flip ($)`
08:55:30 <michaelt> xcthulhu: osfameron thinks you're the one who's thinking backwards
08:56:01 <xcthulhu> That’s why I asked
08:56:59 <xcthulhu> But I can’t help but observe that F# has their own thrush combinator |> …
08:59:26 <nshepperd> i dunno, composing functions like f . g . h = \x -> f (g (h x)) seems pretty natural to me now
09:01:09 <nshepperd> but I might use >>> for things that are "effectful"
09:01:35 <nshepperd> in some vague sense
09:09:38 <zealotmonkey> how's everybody tonight?
09:10:12 <sithrak> monkey free since 3 years
09:10:21 <sithrak> ;P
09:10:22 <Gurkenglas> michealt:
09:10:26 <Gurkenglas> @src foldM
09:10:26 <lambdabot> foldM _ a []     = return a
09:10:26 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
09:11:09 <michaelt> @src foldl
09:11:09 <lambdabot> foldl f z []     = z
09:11:09 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
09:14:16 <sm> I installed hledger-web-0.23.3 on windows yesterday, and the executable was 25M. Another ghc executable (cabal) looked large (quite a few Mb as well. I wonder why
09:14:59 <kgadek> hi. any idea how to convert 3-typle to 2-tuple (drop 2nd elem) using lens?
09:15:33 <kgadek> I suppose the type should be `conv :: Lens (a,b,c) (a,c) (a,b,c) (a,c)`, right?
09:18:54 <glguy> :t (\f (x,y,z) -> fmap (\(x',z') -> (x',y,z')) (f (x,z)))  :: Lens (a,b,c) (a',b,c') (a,c) (a',c')
09:18:54 <lambdabot> Functor f => ((a, c) -> f (a', c')) -> (a, b, c) -> f (a', b, c')
09:18:57 <glguy> kgadek ^
09:20:59 <kgadek> yeah, thanks!
09:23:37 <supki> :t view (runGetter ((,) <$> Getter _1 <*> Getter _3))
09:23:38 <lambdabot> (Field1 s s a1 a1, Field3 s s a a, MonadReader s m) => m (a1, a)
09:27:44 <albeit> Is there a class for Text similar to "Show" for String?
09:32:03 <geekosaur> not /per se/, and I think Text has enough overhead that builders are used instead?
09:32:17 <toblerone> albeit: you mean something similar to (TextShow a) => a -> Text?
09:34:18 * hackagebot yesod-auth 1.3.4.6 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.3.4.6 (GregWeber)
09:36:55 <Forkk> Is there anyone here who could offer some advice on reactive programming?
09:38:18 <Cale> Maybe me
09:38:21 <Cale> I dunno
09:38:28 <Cale> Depends what advice
09:38:59 <Forkk> well, I'm trying to figure out how I can produce events from IO
09:39:08 <Forkk> basically, I have a bunch of network connections
09:39:19 * hackagebot yi-rope 0.2.1.11 - A rope data structure used by Yi  http://hackage.haskell.org/package/yi-rope-0.2.1.11 (MateuszKowalczyk)
09:39:34 <Forkk> and I need to produce events from them
09:40:03 <Cale> "events" in which sense?
09:40:34 <Forkk> in the FRP sense
09:40:43 <Cale> FRP libraries usually have some way to run the computation where you put in data at the top level for events
09:41:18 <Forkk> yeah, my issue is that the network connections aren't at the top level of the application
09:41:38 <Forkk> and they will also not stay constant. i.e, new connections may be added
09:43:45 <Cale> I'm sure the details will vary based on what FRP framework you're using, but possibly the solution is to have something like an Event of Events, or Behaviour of Events.
09:44:28 <Forkk> I'm using netwire, but I'm open to switching to something else at this point
09:45:57 <toblerone> Why is it that my parsec parsers seem to always infer the Identity monad as its base monad? For instance, why is ":t Foo <$> (lexeme letter)" the type "ParsecT String u Identity (Foo Char)"?
09:46:14 <toblerone> is it the use of (<$>)?
09:46:31 <Cale> toblerone: It's probably the type of lexeme or letter
09:48:12 <Cale> toblerone: Note that if you're using a TokenParser, this type is defined as GenTokenParser String st Identity
09:48:19 <toblerone> Cale: hmm, well indeed this particular instance of lexeme is inferred as using Identity, but hoogling lexeme shows that any Monad would do...
09:48:19 <toblerone> ah
09:50:25 <toblerone> Cale: Ah great thanks a lot
09:50:29 <toblerone> that fixed it
09:50:36 <toblerone> that was driving me crazy : )
09:53:35 <lpaste> NemesisD pasted “typeable” at http://lpaste.net/111160
09:54:01 <NemesisD> could someone take a look at that? i must be missing something. i'm not sure why it isn't working
09:54:20 * hackagebot snaplet-amqp 0.1.2.5 - Snap framework snaplet for the AMQP library  http://hackage.haskell.org/package/snaplet-amqp-0.1.2.5 (ParnellSpringmeyer)
09:55:16 <merijn> NemesisD: the 'a' for your undefined is not the 'a' in your type signature
09:55:22 <merijn> NemesisD: You want ScopedTypeVariables
09:55:36 <NemesisD> merijn: i thought that but i added that pragma and no dice
09:55:43 <merijn> By default type variables are scoped per type signature
09:55:58 <jedai> NemesisD: You must explicitly introduce the type variable with forall a .
09:55:59 <merijn> NemesisD: ScopedTypeVariables needs an explicit forall to bring variables into scope
09:56:12 <merijn> forall a . Typeable a => ...
09:56:16 <toblerone> is there any way to get GHC to tell you why it infers a particular type for a given expression?
09:56:31 <NemesisD> ah! thank you!
09:56:42 <merijn> toblerone: Not really, depending on what you mean as "why"
09:57:14 <NemesisD> out of curiosity, is there any runtime cost to this approach that i'm using or is it all decided at compile time
09:57:18 <merijn> toblerone: If GHC is inferring confusing things, ensure you have type annotations for your top level functions/variables
09:57:26 <merijn> NemesisD: All compile time
09:57:31 <jedai> toblerone: Not really but you may look at the type of the piece or use a hole (_) to see what the context infer
09:57:44 <merijn> NemesisD: GHC does type erasure, meaning types don't exist at runtime
09:58:00 <merijn> jedai: I figured he wanted to know *why* GHC inferred what it did
09:58:32 <toblerone> merijn: Yeah, I'm not sure how such a feature would look like in practice...
09:58:49 <NemesisD> merijn: cool! i thought that was right but wanted to make sure typeable didn't screw all that up. also: is using undefined in this way considered good style or is there another way i should do it?
09:58:56 <jedai> merijn: IF this is what he wish, there is no way that I know, though most inference is pretty simple to follow manually
09:59:26 <jedai> merijn: Though with recent additions to the type system, it is not as simple now ... :-)
10:00:09 <kqr> is there an easy way to construct data types such that functions in the value have access to other fields of the same value?
10:00:28 <merijn> toblerone: There was some work at IFL2013 on debugging/explaining type inference to programmers, but nothing really practical yet
10:00:52 <merijn> NemesisD: Nowadays it's more common to use Proxy for that, rather than "undefined"
10:01:01 <kqr> or i'm dumb. I can just create a function that produces such a value
10:01:02 <yitz> kqr: what does "have access"
10:01:04 <yitz> mean?
10:01:22 <kqr> yitz, I was thinking something along the lines of
10:01:23 <jedai> NemesisD: undefined is fine, though in some library, you'll see a "as" value defined to make it more natural to read.
10:02:01 <kqr> yitz, data Thing a = Thing { key :: a, contains :: a -> Bool }
10:02:13 <kqr> yitz, where "contains" will compare its argument to the "key"
10:02:17 <kqr> yitz, sorry for dumb example
10:02:32 <toblerone> well in this particular instance, I couldn't figure out why my parsec parsers were inferred as using the Identity monad. After a while of searching, I figured out that the LanguageDef type alias specifies the use of the Identity monad. I guess I would've liked it to have told me that "this parser uses the identity monad because of your use of lexem
10:02:33 <toblerone> e, etc etc"
10:02:39 <NemesisD> merijn: Proxy from tagged?
10:02:54 <merijn> NemesisD: Proxy is in base these days
10:03:04 <fizbin> Is it possible to run pure code from inside the IO monad and catch places where pure code calls "error" or "undefined"?
10:03:10 <merijn> fizbin: Not reliably
10:03:25 <yitz> kqr: you would either run the comparison when you construct the value, and store a Bool, or when you access it, and have a function Thing a -> (a, Bool) (or something)
10:03:49 <kqr> yitz, I can't run the comparison when I construct the value, because I don't yet know which value I will compare it to
10:04:01 <monochrom> this netsplit is behaving like pure errors in IO :)
10:04:10 <NemesisD> merijn: damn, looks like i don't have access to that in base 4.6.x
10:04:12 <yitz> kqr: ok, then, when you access it.
10:04:15 <bennofs> merijn: does evaluate + force + catch not work?
10:04:32 <kqr> yitz, but how will the lookup function know what value key has?
10:04:32 <monochrom> anyway, see Control.Exception.evaluate
10:04:43 <jedai> fizbin: you can catch those as exceptions though you have to be careful that your pure code is completely evaluated in your catch handler
10:05:04 <fizbin> Okay, I'll look at that. It may be because of incomplete evaluation that I'm missing it.
10:05:08 <kqr> yitz, essentially, lookup thing arg = arg == key thing
10:05:13 <yitz> because you would use a function of type Thing a -> Bool or Thing a -> (a, Bool) or whatever to do the comparison.
10:05:14 <kqr> yitz, except I don't want to pass the thing as an argument
10:06:54 <merijn> bennofs: Only catches undefined/errors encountered up to WHNF
10:07:15 <bennofs> merijn: I was refering to force as defined in the deepseq package
10:07:31 <merijn> Maybe, I dunno
10:08:26 <fizbin> The errors I care about would be caught by evaluating to WHNF. It just hadn't occurred to me that I might not even be reaching WHNF...
10:09:50 <yitz> > head $ "foo" : error "Bang !" -- fizbin
10:09:52 <lambdabot>  "foo"
10:10:23 <merijn> fizbin: Which is why you shouldn't use error/undefined for signalling errors
10:10:23 <fizbin> yitz: Yes, I'm aware of that. The errors I care about aren't hidden like that.
10:10:54 <tremon> kqr: how about a constructor thing n = Thing n (==n) ?
10:11:14 <fizbin> merijn: I'm using it for errors that indicate something seriously wrong with the program, not for input validation. Basically, if there's input that can trigger this, I have a bug in my code.
10:11:33 <fizbin> That is, internal data inconsistency errors.
10:11:39 <kqr> tremon, yup that's what I'm going with currently
10:11:44 <kqr> tremon, I was just curious if I missed something
10:12:21 <stolaruk> Any opinions regarding the IntelliJ plugin?
10:15:49 <tremon> kqr: I don't think you have. For that to work, you would need an implicit "this" pointer, which haskell doesn't have fafaik. Your compare function would be Thing -> a -> Bool. The first parameter can be curried, but not implicitly
10:24:21 * hackagebot multistate 0.1.3.2 - like mtl's ReaderT/StateT, but more than one contained value/type.  http://hackage.haskell.org/package/multistate-0.1.3.2 (lspitzner)
10:28:32 <khyperia> I've installed mueval, but whenever I try running it, it spits out a warning about Control.Monad.Instances instead of the expression result. Is there any way around that, or an alternative program?
10:30:13 <halvorg> Using haskell-mode in emacs, is there a way to make the indentation width ignore the line length?
10:30:48 <halvorg> like if I want to break a long line into multiple lines, starting at character 130 kind of defeats the purpose
10:31:09 <halvorg> ignore the previous line length*
10:32:45 <halvorg> https://gist.github.com/halvorgb/a9456e9b6ba9e01a74aa <- an example
10:33:41 <ReinH> halvorg: Well, you do need to respect layout.
10:33:53 <ReinH> But in that case it's not a problem
10:34:02 <ReinH> Which indent mode are you using?
10:34:16 <ReinH> Also there's #haskell-emacs btw
10:34:21 * hackagebot chatter 0.2.0.0 - A library of simple NLP algorithms.  http://hackage.haskell.org/package/chatter-0.2.0.0 (RoganCreswick)
10:34:30 <srhb> ReinH: Nice, did not know.
10:34:47 <halvorg> ReinH: respect layout, what does that mean?
10:34:57 <ReinH> the layout rules for code indentation
10:35:05 <Qfwfq> That's a cool package.
10:35:10 <ReinH> (Haskell is a whitespace aware language)
10:35:33 <ReinH> See also http://en.wikibooks.org/wiki/Haskell/Indentation
10:35:45 <halvorg> ok
10:36:12 <ReinH> halvorg: I think as a practical matter you can use shift-tab or whatever the keybind is to switch to a previous indent position or whatever the terminology is
10:36:32 <ReinH> chrisdone might know if there's a way to make the default indent behavior what youw ant
10:37:17 <halvorg> ReinH: I have this tab-cycle thing, which either aligns the line right underneath the other (which breaks layout rule) or at the end (which yields looong lines)
10:37:21 <halvorg> but ill read those docs
10:37:40 <ReinH> Ah, yeah.
10:38:27 <ReinH> A meta solution might be to introduce more names for things and to generally try to structure your code to avoid stair-steppiness
10:39:18 <Cale> Back when I used to use emacs, there was a simple indent mode
10:39:20 <ReinH> put "/category" sessionValidation where sessionValidation = ...
10:39:30 <Cale> The "smart" one was terrible
10:39:45 <ReinH> Cale: haskell-mode has 3 now, but I don't use any of them because I use structured-haskell-mode
10:39:58 <ReinH> So I don't really know how they behave
10:40:41 <NemesisD> are type level naturals expensive memory/cpu wise at compile time for larger numbers?
10:40:49 <tanmaig> Hi! I would like to setup  cabal upload so that it works with a local hackage server, instead of running a cabal sdist and manually updating packages. Any pointers please?
10:42:16 <pjdelport> NemesisD: Depends what flavor, i'm sure.
10:42:56 <NemesisD> pjdelport: ok so actually, would the flavor that just nests Succ constructors be expensive at runtime?
10:43:14 <NemesisD> seems like that could build some big data structures
10:43:15 <pjdelport> NemesisD: For large integers, definitely, yeah.
10:43:38 <pjdelport> Representing N requires O(N) space by that definition, obviously. :)
10:43:55 <pjdelport> And computations would also not be fast.
10:44:10 <NemesisD> so it would be much more lightweight if that could be lifted to the type level, such that the actual data is something like an integer
10:44:32 <pjdelport> Right; that's what the new TypeLits and related work does, as i understand it.
10:44:50 <Qfwfq> Well except that the compiler can't reason as well about TypeLits as it can lifted peano numerals.
10:45:49 <NemesisD> i guess smart constructors are a good workaround if you control the codebase end to end
10:46:24 <NemesisD> but it does poison every site where a value is constructed to handle the invalid data case at runtime
10:49:22 * hackagebot yesod-pagination 2.0.0 - Pagination in Yesod  http://hackage.haskell.org/package/yesod-pagination-2.0.0 (JoelTaylor)
10:50:37 <mietek> @OlegFacts
10:50:37 <lambdabot> Unknown command, try @list
10:53:08 <WraithM> @list
10:53:08 <lambdabot> What module?  Try @listmodules for some ideas.
10:53:12 <WraithM> @listmodules
10:53:12 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
10:56:18 <Guest24987> @pl \x -> (filter . isSuffixOf ".asdf") <$> (getDirectoryContents =<< x)
10:56:18 <lambdabot> (filter . isSuffixOf ".asdf" <$>) . (getDirectoryContents =<<)
10:57:25 <Guest24987> \x -> (filter $ isSuffixOf ".asdf") <$> (getDirectoryContents =<< x)
10:57:29 <Guest24987> @pl \x -> (filter $ isSuffixOf ".asdf") <$> (getDirectoryContents =<< x)
10:57:30 <lambdabot> (filter (isSuffixOf ".asdf") <$>) . (getDirectoryContents =<<)
10:59:02 <dfeuer> Hmmmm. I wonder if that's the problem...
10:59:12 <frerich_> When inspecting the output generated by running a program with ‘+RTS -p’, I can see the number of allocations done by various functions. Is there some documentation on what triggers allocations? In my case, I saw that the small ‘getCellAt’ function ( http://lpaste.net/111164 ) is responsible for roughyl 20% of the allocations in my program, but I don’t understand why that is.
10:59:23 * hackagebot Boolean 0.2.2 - Generalized booleans and numbers  http://hackage.haskell.org/package/Boolean-0.2.2 (ConalElliott)
10:59:27 <frerich_> I could probably try applying ‘seq’ to various things, but that would be just guesswork.
11:03:34 <alrunner4> frerich_: might want to try http://www.haskell.org/haskellwiki/Performance/Strictness#Rule_of_Thumb_for_Strictness_Annotation if you want getCellAt to be strict
11:05:08 <frerich_> alrunner4: Thanks, that looks interesting. In general though - is it plausible to consider imposing more strictness in order to get rid of allocations?
11:05:27 * frerich_ wonders where everybody else learned this stuff from :)
11:05:56 <alrunner4> trial and error, mostly. lots of error.
11:07:56 <phaazon> haddock still not running on hackagedb?
11:08:35 <alrunner4> strictness annotation will only get you so far with reducing allocations, though, since you're just getting rid of the thunk, but for small functions that can be a big chunk of its total allocation
11:12:07 <frerich_> alrunner4: Thanks for the Wiki pointer, the ‘Performance’ section has a lot of useful ideas. I’ll try ‘+RTS -hc’ to see who is allocating the memory and’+RTS -hb’ to see how it’s used.
11:12:35 <bennofs> frerich_: I often find -hy (by type) quite useful as well
11:16:32 <fizbin> :t either fail return
11:16:33 <lambdabot> Monad m => Either String a -> m a
11:21:56 <albeit> Is there a clean way to do this? "\x -> if f x then (Just x) else Nothing"
11:23:44 <bennofs> :t \f -> mfilter f . return :: (a -> Bool) -> a -> Maybe a
11:23:45 <lambdabot>     Couldn't match type ‘a1 -> Bool’ with ‘Maybe a1’
11:23:45 <lambdabot>     Expected type: (a1 -> a1 -> Bool) -> a1 -> Maybe a1
11:23:45 <lambdabot>       Actual type: (a1 -> a1 -> Bool) -> a1 -> a1 -> Bool
11:23:59 <glguy> :t \f x -> x <$ guard (f x) -- maybe cleaner?
11:24:00 <lambdabot> (MonadPlus f, Functor f) => (a -> Bool) -> a -> f a
11:24:24 * hackagebot oeis 0.3.6 - Interface to the Online Encyclopedia of Integer Sequences (OEIS)  http://hackage.haskell.org/package/oeis-0.3.6 (BrianLewis)
11:24:33 <bennofs> :t (\f -> mfilter f . return) :: (a -> Bool) -> a -> Maybe a
11:24:34 <lambdabot> (a -> Bool) -> a -> Maybe a
11:25:37 <albeit> Great thanks
11:25:40 <alrunner4> :t \ f -> guard . f
11:25:41 <lambdabot> MonadPlus m => (a -> Bool) -> a -> m ()
11:27:32 <pjdelport> :t \f x -> bool empty (pure x) (f x)
11:27:33 <lambdabot> Alternative f => (a -> Bool) -> a -> f a
11:28:05 <pjdelport> Or if you're feeling more masochistic:
11:28:05 <pjdelport> :t \f -> bool empty . pure <*> f
11:28:06 <lambdabot> Alternative f => (a -> Bool) -> a -> f a
11:29:04 <hughfdjackson> :) morning all
11:29:24 <hughfdjackson> perhaps this is an out-of-place question; is there any good, stable, widely used future library in haskell?
11:29:37 <glguy> bennofs: I was surprised to learn that mfilter went all the way back to base 4.3
11:30:05 <mgaut72> what is the correct style choice if I have a function declaration that is really long.  To clarify, the name and the parameters is long.  Should I have "longFunctionasdfasdf longArguments   =\n..."
11:30:26 <mgaut72> that is, a newline after the equal sign?
11:30:58 <pjdelport> mgaut72: There's probably no one correct thing.
11:31:30 <mgaut72> is there something maybe "more idiomatic"?
11:31:33 <pjdelport> Readability matters most. Maybe paste something to lpaste, for critique?
11:31:43 <mgaut72> pjdelport: sure
11:32:35 <monochrom> = is a good condidate for breaking lines. there are other good candidates.
11:32:59 <pjdelport> Shorter names are also something to consider. :)
11:33:15 <pjdelport> (Of course, naming things is one of the two hardest problems in computer science.)
11:33:32 <hughfdjackson> monochrom: sometimes if you're seeing long *looooong* names, you might not have descriptive enough types
11:33:36 <bennofs> Newline before equals sign also works
11:33:51 <hughfdjackson> findAddress :: String -> String vs findAddress :: UserId -> Address
11:34:26 <hughfdjackson> (not that I'm saying that applies in your case, but sometimes wrappers have helped me be more descriptive with short parameter names)
11:34:30 <monochrom> why are you telling me that?
11:34:42 <pjdelport> Yeah, type aliases can be great for documentation.
11:34:55 <lpaste> mgaut72 pasted “style_question” at http://lpaste.net/111166
11:34:57 <glguy> type aliases can be a disaster for reading code, too
11:35:01 <Cale> They also act as negative documentation though
11:35:35 <Cale> In that, if you want to use something whose type is specified with many aliases, it can require additional work tracking down the definitions to unfold the aliases manually
11:35:51 <mgaut72> pjdelport: shorter names would be nice, but I need to pattern match on nested data types
11:35:53 <hughfdjackson> Cale: good point
11:36:22 <monochrom> also, the "findAddress :: UserId -> Address" example comes from http://techblog.realestate.com.au/the-abject-failure-of-weak-typing/ and they are at least newtypes, not type aliases.
11:36:49 <hughfdjackson> monochrom: was rooting about for that ^^ it was the the article that convinced me to use it more in scala
11:36:56 <hughfdjackson> to (so far) good effect
11:37:08 <Cale> Yeah, newtypes are at least slightly better in that the type system enforces *something* even if that isn't really as much as we'd like it to be
11:37:50 <hughfdjackson> :) anyhow, i'm derailing - sorry about that
11:38:24 <lpaste> pjdelport annotated “style_question” with “Using where-clause helper” at http://lpaste.net/111166#a111167
11:39:28 <lpaste> hexagoxel annotated “style_question” with “style_question (annotation)” at http://lpaste.net/111166#a111168
11:40:03 <pjdelport> mgaut72: For that kind of thing, i actually like using a where-clause helper. I annotated your paste with a variation.
11:40:31 <mgaut72> pjdelport: thanks.  What if my functionname + params is even longer though?
11:41:17 <mgaut72> hexagoxel: I feel kind of dirty about using 'do' notation when I really don't need it (such as your example).
11:41:22 <pjdelport> mgaut72: I sometimes go as far as saying "some very long ... definition = foo", and then define foo along with a bunch of other things in a big where clause.
11:41:32 <pjdelport> mgaut72: That's not everyone's taste, of course. :)
11:41:56 <pjdelport> mgaut72: You could maybe even use *> there?
11:42:03 <pjdelport> Applicative instead of Monad :)
11:42:10 <mgaut72> pjdelport: of course.  I just want to minimize eye-bleeding if people actually read my code
11:42:30 <joshsz> Hi! Is there a way for me to automatically get an index out of instance definitions of a class? like `data Foo = Bar | Baz`, and I want to get that Bar is in position 0, Baz in position 1, etc
11:42:39 <pjdelport> mgaut72: It depends a bit on the problem, too... i like to do that when i can give meaningful names to the parts of the expression.
11:42:41 <joshsz> other than writing a function to explicitely do it
11:42:59 <mgaut72> pjdelport: I have been sprinkling some applicativeness into my parser, but its not the first thing that comes to my mind.  maybe I will look into applicative more
11:43:09 <pjdelport> mgaut72: For example, the "validate'" name there hopefully gives an immediate suggestion of what it's supposed to do, without having only the details.
11:43:17 <mgaut72> thanks all for the feedback
11:43:39 <mgaut72> gotta run to class
11:43:43 <pjdelport> So in the above example too, "foo" would be something more meaningful, that captures the intent of the entire body.
11:44:03 <solarus> joshsz: just add deriving Enum to you data definition and then you can use fromEnum Bar etc
11:44:13 <joshsz> ah, good, thanks! :)
11:45:06 <pjdelport> joshsz: Depending on what exactly you want to do with the index, the Ix class might also be of interest.
11:45:23 <pjdelport> Enum lets you use it in list enumerations, like [foo..bar], while Ix lets you use it to index Arrays
11:45:42 <pjdelport> (You can derive both.)
11:45:49 <joshsz> pjdelport: also interesting, thanks a lot!
11:47:57 <tanmaig> Hi! I would like to setup  cabal upload so that it works with a local hackage server, instead of running a cabal sdist and manually updating packages. Any pointers please?
11:47:58 <lpaste> hexagoxel revised “style_question (annotation)”: “No title” at http://lpaste.net/111168
11:54:52 <hexagoxel> tanmaig: there is remote-repo line in ~/.cabal/config maybe you can just switch that?
11:55:21 <tanmaig> @hexagoxel: I did. But that just sets my remote repo
11:55:21 <lambdabot> Unknown command, try @list
11:55:26 <tanmaig> So cabal install works
11:56:11 <hexagoxel> no idea then, sorry
12:00:03 <latk> Any opinions in the best way to split a Text on upper-case letters? So "ThisAndThat" would become "This And That"
12:00:14 <latk> I guess break is more accurate than split
12:02:39 <ReinH> Naively? Capture starting on an isUpper character until the next isUpper character?
12:03:45 <latk> That is basically what I was thinking of - just wondered if there were a better way!
12:05:42 <ReinH> It's linear, what more do you want? :p
12:06:09 <monochrom> Data.Text has break and span.
12:06:23 <vanila> cabal install hakyll
12:06:24 <vanila> does not work
12:06:36 <ReinH> vanila: I had to use a hsenv iirc :/
12:06:39 <latk> ReinH: Fair point :p
12:06:44 <ReinH> It's rather frustrating, I agree.
12:07:17 <ReinH> You might have success with our OS package manager, although I suggest that with some reluctance
12:07:20 <ReinH> *your
12:07:38 <vanila> ill try ruby
12:09:26 * hackagebot snaplet-amqp 0.1.3.0 - Snap framework snaplet for the AMQP library  http://hackage.haskell.org/package/snaplet-amqp-0.1.3.0 (ParnellSpringmeyer)
12:13:46 <augustl> is it possible to make a function so that f "foo" calls a different implementation than f "bar"? I.e. dispatch depending on [Char] value
12:14:22 <augustl> hmm, this is just pattern matching isn't it :)
12:15:14 <dv-> you can literally write f "bar" = ...; f "foo" = ...
12:19:30 <augustl> but due to the way all functions are curried, it's not possible to have https://gist.github.com/augustl/f54f99a87a415f4dfca7 somehow not take the "3rd" argument children depending on the value of the first String argument?
12:20:14 <augustl> failing run-time by ignoring the "children" isn't really an option :)
12:20:21 <albeit> :t (\x -> x <$ guard (f x))
12:20:22 <lambdabot>     Could not deduce (FromExpr Bool) arising from a use of ‘f’
12:20:22 <lambdabot>     from the context (MonadPlus f, Show a, Functor f)
12:20:22 <lambdabot>       bound by the inferred type of
12:20:38 <augustl> dv-: thanks btw :)
12:21:45 <capisce> what do I import to get <$ ?
12:22:06 <albeit> capisce: Its in Data.Functor and Control.Applicative
12:22:27 <MagneticDuck> capisce: check the "hoogle" commandline util
12:22:33 <MagneticDuck> or visit www.haskell.org/hoogle
12:24:14 <capisce> MagneticDuck: got it
12:27:25 <CXXVIIta> is it possible to use map over a two tuple by applying a function that expects data types found in the fst and snd slots of the tuple, and returns a single type?
12:28:06 <CXXVIIta> map fst tuple seems to work fine, however im not able to call map (f fst snd) tuple
12:29:39 <orbisvicis> I wanted to be able to use standard functions on empty lists, so I wrote "maybeList xs    = if null xs then Nothing else Just xs". Is this pointless, given Nothing and [] are similar ? Is there a better approach than "fmap maximum $ maybeList l"
12:29:55 <capisce> CXXVIIta: is uncurry what you want?
12:30:03 <capisce> CXXVIIta: uncurry f tuple
12:30:12 <etandel> uncurry <3
12:30:40 <MagneticDuck> uncurry const === fst
12:30:48 <MagneticDuck> uncurry (flip const) == snd
12:31:29 <pjdelport> :t listToMaybe
12:31:30 <lambdabot> [a] -> Maybe a
12:31:32 <pjdelport> orbisvicis: -^
12:31:52 <pjdelport> orbisvicis: Oh, nevermind.
12:32:02 <CXXVIIta> cheers capisce
12:32:29 <pjdelport> orbisvicis: There is http://hackage.haskell.org/package/semigroups-0.8.3/docs/Data-List-NonEmpty.html and such
12:33:04 <pjdelport> which has nonEmpty :: [a] -> Maybe (NonEmpty a)
12:34:13 <orbisvicis> pjdelport: I guess that validates my approach?
12:35:10 <pjdelport> orbisvicis: Well, it depends what exactly you want to do!
12:36:48 <pjdelport> orbisvicis: For example, one alternative to maximum would be foldl' max foo
12:37:12 <pjdelport> Perhaps "foldl' max minBound" if you have a Bounded type, for example.
12:38:23 <orbisvicis> pjdelport: interesting, i hadn't though about that.
12:39:23 <orbisvicis> acctually I'm trying to rewrite one of my explicitly recursive functions. when I figure it out, ill be back looking for input
12:50:16 <augustl> I have an API that currently takes a string, but I really only want it to take a-z and no other chars. Any ways to enforce that compile time for string constants? By not using strings, maybe? :)
12:50:43 <augustl> I don't ever intend my code to take user provided strings as input
12:51:47 <haasn> Not really, but you can force it at runtime quite easily by using a custom datatype with a hidden constructor (and overloaded string literals)
12:54:02 <arash_> augustl, Yep, what haasn says, check this out: http://www.haskell.org/haskellwiki/Smart_constructors
12:54:03 <augustl> haasn: I see, tnx
12:56:23 <augustl> what I'm actually trying to do: generate HTML/XML with pure haskell syntax, no strings. But the keys and values of tag attributes are strings, and keys can only contain a-z and -, not start with -, and so on.
12:57:27 <augustl> currently it looks like this tagToString(div' [("class", "row"), ("id", "main")] [p' [] [], input' [("type", "text")]]), which returns "<div class=\"row\" id=\"main\"><p></p><input type=\"text\"></div>"
12:57:46 <monochrom> module Text.XHtml does that (smart constructors). comes with GHC, you already have it.
12:57:57 <augustl> ah, will look that up, thanks :)
12:59:28 * hackagebot snaplet-amqp 0.1.3.1 - Snap framework snaplet for the AMQP library  http://hackage.haskell.org/package/snaplet-amqp-0.1.3.1 (ParnellSpringmeyer)
13:04:00 <gdoteof> something up with wai-app-static ? when my buddy does cabal install wai-app-static it gets a type error
13:04:12 <gdoteof> originally trying to to install a yesod app ; but couldn't get past that point
13:05:00 <gdoteof> inside of a fresh cabal sandbox
13:06:26 <sm> try also #yesod, and show a paste
13:06:54 <sm> also check the yesod/wai-app-static bug tracker, sometimes there are good clues there
13:20:35 * RyNet Welcome RyNet and his first time here!
13:38:20 <blogle> #sel-columbia
13:38:24 <Itkovian> Good evening
13:38:55 <blogle> sorry, I am really struggling to get used to this new client...
13:39:02 <blogle> please disregard
13:41:36 <Itkovian> Anybody any idea how to use cassava (https://hackage.haskell.org/package/cassava) for simply counting fields in a CSV file, i.e., the actual field contents do not matter. Right now I am using a foldl' over a Data.Csv.Streaming Record [ByteString]. But it's still much much slower compared to Python
13:42:09 <Itkovian> OTOH, I am not sure the Python implementation actually gives a damn about the correctness of the 'parsing', if you can call it that
13:42:22 <Itkovian> It's a friends challenge to speed thing up, alike the language shootout
13:43:09 <merijn> Itkovian: If you don't care about correctness, does that mean there's no fancy quoting, just like "every comma is a field separator"?
13:43:28 <Itkovian> I do care about it, well, I think the Haskell code cares
13:43:34 <kadoban> If raw speed is the goal, it seems like something you could do manually in not much time that's pretty close to optimal
13:43:38 <Itkovian> Or at least I;d like to believe it does
13:43:48 <merijn> Itkovian: No, I mean do you care about that in the result?
13:44:20 <Itkovian> no, yes, I do care about that. comma's inside a "" string should not be considered a field separator
13:44:28 <monochrom> you can test python's csv parser with hello,"mono,chrom"
13:44:30 * hackagebot aig 0.2 - And-inverter graphs in Haskell.  http://hackage.haskell.org/package/aig-0.2 (RobertDockins)
13:44:32 * hackagebot abcBridge 0.11 - Bindings for ABC, A System for Sequential  Synthesis and Verification  http://hackage.haskell.org/package/abcBridge-0.11 (RobertDockins)
13:44:54 <merijn> Ah, actually, even then you can still probably improve on speed by handrolling a parser using attoparsec
13:45:17 <kadoban> Yeah, it seems like it'd be almost trivial in attoparsec...or not very hard by hand either
13:46:08 <monochrom> a lot of "python does it fast" is really "python calls a fast C lib".
13:46:40 <merijn> Just a lot of "skipWhile (\c -> c /= ',' && c /= '"')", etc. together with a proper parser for '/" quoted values (which are just "skipWhile (\c -> c /= '"')"
13:46:49 <simpson> Or one uses one of the three production-ready Python JITs.
13:46:59 <merijn> That should turn into nearly C speeds in attoparsec
13:47:02 <joseph07> http://bit.ly/1qLINKm
13:47:21 <joseph07> ^ So you want to write your own CSV code
13:47:25 <merijn> I'm guessing the haskell CSV thing you're parsing is adding quite some overhead compared to that
13:47:28 <monochrom> I am not sure, to be frank, of the value of comparing the speeds of 100 lines of Haskell code against one single QBASIC primitive.
13:47:42 <merijn> joseph07: Not relevant
13:48:12 <merijn> joseph07: If we're doing benchmark gaming you only care about parsing the benchmark correctly
13:48:16 <merijn> So the format is fixed
13:50:04 <monochrom> it's ok to be tangential :)
13:50:27 <sinelaw> hey Peaker
13:50:32 <monochrom> https://www.youtube.com/watch?v=N2JFgfc7c70  <-- tangential :)
13:50:41 <srhb> monochrom: You mean it's not a... *sin*
13:50:43 <Peaker> sinelaw: hey
13:50:46 <srhb> Badum tisch...
13:51:02 <sinelaw> I just realized i need what I think you called generalization
13:51:09 <sinelaw> on function applications
13:51:31 <sinelaw> so that the function type is not specialized permanently after the first call
13:51:32 <monochrom> yikes. generalizing function application is a rabbit hole. it's abstractions all the way down.
13:52:18 <sinelaw> monochrom, heh...i'm talking about type inference
13:52:54 <monochrom> I see.
13:53:38 <sinelaw> Peaker, in SPJ he uses "type schemes"
13:53:56 <Axioplase> @pl \f g -> f &&& g >>> arr (\(a,b) -> a b)
13:53:56 <lambdabot> flip flip (arr (ap fst snd)) . ((>>>) .) . (&&&)
13:54:02 <Itkovian> merijn nah, it does it OK as well :)
13:54:21 <monochrom> yeah, even the original HM paper has to make a special provision for "let f x = ... in ..." because you want to support "let f x = x in (f True, f 4)"
13:54:32 <Peaker> sinelaw: yeah, like in the AlgoW-Step-by-Step paper
13:54:52 <Peaker> sinelaw: the generalization is of "let" bindings (and "global" bindings), not of function applications
13:54:56 <Axioplase> @pl \f g -> f &&& g >>> arr (uncurry ($))
13:54:56 <lambdabot> flip flip (arr (uncurry id)) . ((>>>) .) . (&&&)
13:55:34 <sinelaw> Peaker, I think we mean the same thing. I mentioned application because that "collapses" a function's type to a specific union
13:55:52 <merijn> Itkovian: I'm not saying it's not ok for like real work, but when you mention "challenge/language shootout", I assume you're trying to win :p
13:56:24 <Itkovian> Yeah, exactly :)
13:56:34 <Peaker> sinelaw: no no -- the "collapse" is called "instantiate" and it happens whenever you use a variable
13:56:42 <Peaker> sinelaw: not when you apply functions
13:56:42 <merijn> Itkovian: With attoparsec you can probably turn the entire thing in a tight inner loop of a few ASM instructions if you do it right :)
13:56:53 <sinelaw> Peaker, see monochrom's example above
13:56:54 <Peaker> sinelaw: let/global -> generalize.   var -> specialize
13:56:59 <Itkovian> Current code is at https://bitbucket.org/Itkovian/csv-game/src/f5a3d60f6845dfc67a890e2f75ab2b55d916a6d3/haskell/scsv.hs?at=haskelll_field_count
13:57:04 <Itkovian> if you can see that
13:57:04 <sinelaw> that's what I mean
13:57:12 <sinelaw> (f True, f 4)
13:57:22 <sinelaw> ^^ should not fail
13:57:25 <Peaker> sinelaw: yes, "f" is generalized because of the "let"
13:57:41 <Peaker> sinelaw: and then ((f <-- instantiate happens here) True, (f <-- also here) 4)
13:57:48 <Peaker> sinelaw: the application happens after the instantiation
13:57:58 <monochrom> yeah, the HM paper attach this to "what to do about let"
13:58:02 <Peaker> sinelaw: f could be a non-function too, and still generalized
13:58:02 <sinelaw> ok
13:58:17 <sinelaw> not in my language :)
13:58:19 <Peaker> sinelaw: let f = 5 in (f, f) :: (Int, Double)
13:58:56 <Peaker> sinelaw: but it still makes sense to generalize "let" and specialize "var", rather than function application specifically -- though not sure you want to generalize let in your language?
14:00:11 <merijn> Itkovian: Have you tried using the LLVM backend?
14:01:24 <Peaker> Does anyone know of any Applicative-based parser that uses the restrictive nature of applicative (+some sort of "fix" prim) to restrict the parser to CFG and make it much faster than monadic parsers?
14:01:46 <Peaker> it seems such an obvious thing to do, but it seems all the parsing frameworks are monadic
14:03:04 <earthy> um.
14:03:19 <earthy> http://www.cs.uu.nl/wiki/HUT/ParserCombinators ?
14:03:27 <Itkovian> merijn erm ... not sure. plain ghc 7.8.3 on OSX ghc --make -O2
14:03:43 <Itkovian> will give it a shot, if I can find the test imput file :)
14:03:51 <sinelaw> Peaker, there is no "let"
14:04:04 <sinelaw> there is either "function" (analogous to let for functions)
14:04:09 <sinelaw> or "var" (let for non-functions)
14:04:35 <sinelaw> actually
14:04:39 <sinelaw> var is also for functions.
14:05:26 <Peaker> sinelaw: do you want "function" and "var" to always declare polymorphic variables? That get re-instantiated with specific type at every use site?
14:06:05 <sinelaw> only if the type of the var is not a function
14:06:21 <sinelaw> var x = 3 ---> no generalization
14:06:33 <Peaker> sinelaw: well, generalization of "Int" would simply be "Int" :)
14:06:34 <sinelaw> function f().... var x = f  ---> yes generalization
14:06:45 <Peaker> sinelaw: so may as well say "always generalize those"?
14:07:05 <sinelaw> the negative case is: var x = 3; then later: x = false;
14:07:20 <Peaker> sinelaw: generalize finds all the type vars that are introduced in that expression (do not appear in the var-scope) and puts a "forall" for those in the type
14:07:41 <Peaker> sinelaw: so for "var x = 3" generalize is a no-op
14:12:04 <khyperia> Is there an alternative to mueval? On GHC 7.8 it spits out a warning instead of the output (warning is Control.Monad.Instances deprecated)
14:15:46 <cwraith> khyperia: isn't that just a function of what it imports by default?  Change the prefix file it's using.
14:16:15 <khyperia> how?
14:17:30 <chrisdone> is hackage building documentation again yet?
14:19:04 <merijn> Itkovian: fyi --make is redundant it's been the default in ghc for several releases :)
14:19:23 <Itkovian> I had no idea.
14:19:25 <merijn> Itkovian: llvm is -fllvm, I dunno if you need any other options
14:19:25 <Itkovian> dang
14:19:37 <Itkovian> -O9999 preferably
14:19:57 <merijn> Itkovian: For some programs LLVM is significantly faster than the native backend (although for others the native backend is faster, so experiment)
14:20:02 <glguy> chrisdone: Not that I know of, but there's a script you can try if your goal is to upload documentation for your own projects
14:20:11 <merijn> Itkovian: Especially tight ASM loops can benefit from LLVM
14:21:08 <Itkovian> OK, apparently llvm is called gcc on my mac
14:21:11 <Itkovian> who knew
14:21:43 <amf> is there an easy way to take 2 elements from a list and turn them into a tuple?
14:22:38 <merijn> Itkovian: Which OSX? Mavericks and friends don't have gcc anymore
14:22:40 <c_wraith> Itkovian: well, clang is called gcc.  but llvm isn't clang.
14:23:02 <merijn> Itkovian: gcc is just clang, which indeed is not llvm
14:23:15 <Itkovian> Apple LLVM version 5.1 (clang-503.0.40) (based on LLVM 3.4svn)
14:23:27 <Itkovian> no I know that clang itself is not llvm
14:23:35 <Itkovian> but gcc --version gave the above
14:23:47 <Itkovian> I'm confused, haven't been following this too long
14:23:55 <merijn> clang is part of the llvm project
14:24:08 <geekosaur> Itkovian, (a) ghc does not compile to C code; (b) you can't use ghc's LLVM backend without installing a full LLVM (Apple just ships a compiler built with LLVM, but not LLVM itself)
14:24:22 <Itkovian> right
14:24:24 <Itkovian> got it
14:24:33 <chrisdone> glguy: okies, thanks
14:25:02 <merijn> Itkovian: Anyway, llvm has a high level assembly and optimisers for it and GHC can output LLVM asm and then have LLVM optimise that asm and compile it to machine code
14:25:13 <Itkovian> Yeah, that I know
14:25:54 <Itkovian> I once toyed around with work we did on compiler optimisations and work somebody else did (not sure who anymore) with ghc and llvm
14:26:06 <Itkovian> leading to a lack of benchmarks (big ones in any case)
14:39:32 * hackagebot Nomyx-Language 0.7.0 - Language to express rules for Nomic  http://hackage.haskell.org/package/Nomyx-Language-0.7.0 (CorentinDupont)
14:39:34 * hackagebot Nomyx-Core 0.7.0 - A Nomic game in haskell  http://hackage.haskell.org/package/Nomyx-Core-0.7.0 (CorentinDupont)
14:39:36 * hackagebot Nomyx-Web 0.7.0 - Web gui for Nomyx  http://hackage.haskell.org/package/Nomyx-Web-0.7.0 (CorentinDupont)
14:39:38 * hackagebot Nomyx 0.7.0 - A Nomic game in haskell  http://hackage.haskell.org/package/Nomyx-0.7.0 (CorentinDupont)
14:42:26 <cschneid> nomic!
14:42:55 <latk> I'm writing aeson instances for some enum types that I have. E.g. SomeThingA becomes "Some Thing A". The toJSON instance works fine, but it fails on fromJSON. I'm matching parseJSON on (String str), and then processing str. Is this not the correct approach ?
14:47:04 <Itkovian> merijn up to which version is llvm supported? i.e.m not 3.5 since it borks
14:47:47 <glguy> latk: Make sure the outermost JSON value is either an object or an array when you're going from  ByteString -> Value
14:48:22 <glguy> latk: Or paste some snippet of code that you expected to work but which did not
14:49:08 <khyperia> alright, thanks c_wraith, I set up the flags to be "mueval -n -l ImportFile.hs -e [code]" and it works
14:49:28 <c_wraith> khyperia: yeah, I didn't remember the options - just how mueval works.
14:51:03 <latk> http://lpaste.net/111177
14:51:26 <latk> So I can do encode Mr and it all works fine
14:51:50 <latk> but decode $ encode [Mr] :: Maybe PreTitle gives me Nothing
14:51:56 <latk> ..
14:51:56 <latk> omg
14:52:02 <latk> it should be Maybe [PreTitle]
14:52:05 <glguy> decode will only decode an array or object
14:52:19 <latk> yeah, that was it
14:52:21 <latk> i'm an idiot
14:52:29 <glguy> oh, just the wrong type?
14:52:37 <latk> i was casting it as the wrong thing :p
14:52:59 <latk> eg :: Maybe PreTitle not :: Maybe [PreTitle]
14:54:01 <kadoban> Those aren't casts, just as a matter of terminology.
14:54:30 <latk> yeah I know.. come to think of it, I don't actually know the correct word. Constraints ?
14:54:41 <c_wraith> latk: annotation/ascription
14:54:56 <latk> c_wraith: Good to know, thanks.
14:57:34 <srhb> Sometimes we call them type signatures, too.
14:58:08 <latk> I thought type signatures were just when they were given for functions, not when you are forcing a value that can take many types to take a specific one
14:58:30 <srhb> Same thing really. ie. consider the type of id
14:58:42 <latk> huh, true
14:59:01 <silver_> you're not forcing, you're helping compiler to figure out the type
14:59:08 <jayunit100h> xMean l = xSum(l) / xlength(l) -- why does that fail witha "no instance for Fractional Int" ?
14:59:10 <srhb> Well, you may be constraining something to be less general.
14:59:29 <glguy> jayunit100h: Because Int isn't an instance of Fractional
14:59:32 <latk> silver_:  Even if you are, I dunno, printing a Num ?
14:59:39 <latk> that could be anything
14:59:45 <latk> (that is a Num)
15:00:15 <srhb> latk: You mean things like read . show $ 42 ?
15:00:33 <latk> srhb: yeah
15:00:42 <glguy> jayunit100h: try,   xMean l = xSum l / fromIntegral (xlength l)
15:00:45 <srhb> Yeah, there's often no way for the compiler to figure out what type you meant there without help.
15:01:02 <srhb> (Because it has to choose instances for Read and Show)
15:01:13 <jayunit100h> hmm how do i make the typ signature work so that i can return a fractional ?
15:02:32 <latk> Yeah, I realise that.. but I guess I wouldn't have thought of that as something that has a "correct" value, so in my mind that is constraining it rather than helping  the compiler find the true type. I suppose it is just a semantic difference though
15:03:18 <srhb> latk: Yeah I think you have the right intuition. The compiler knows that it needs a type with certain instances, but can't decide on which alone. :)
15:03:20 <jayunit100h> thanks for the help ill be back later ! glguy
15:03:33 <silver_> well yeah, all I meant is to say that you can't force a String to become Int magically like you can in some other languages by "casting"
15:03:58 <latk> silver_:  Hah, no sure. It was a good point :)
15:04:34 * hackagebot ghc-mod 5.1.0.2 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-5.1.0.2 (DanielG)
15:09:03 <nh2> hi guys, can somebody try and reproduce a ghc-pkg behaviour for me?
15:09:55 <nh2> namely if you `mv ~/.ghc/x86_64-linux-7.8.3/package.conf.d/package.cache` to somewhere and do `ghc-pkg recache`, does it create a new one?
15:11:18 <srhb> nh2: Yes, if I specify --user at least
15:13:21 <nh2> srhb: thanks. Which ghc-pkg --version?
15:13:33 <srhb> nh2: 7.8.3
15:15:42 <nh2> srhb: ok thanks!
15:15:51 <srhb> nh2: Sure :)
15:19:34 * hackagebot snaplet-mandrill 0.1.0.1 - Snap framework snaplet for the Mandrill API library.  http://hackage.haskell.org/package/snaplet-mandrill-0.1.0.1 (ParnellSpringmeyer)
15:24:15 <begriffs> I'd like to work with a candidate package from hackage in my project. I pulled it into a git submodule but I'm not sure how to reference it in my .cabal file. Any ideas?
15:26:59 <nh2> maybe you need cabal sandbox add-source?
15:27:03 <nh2> begriffs: this
15:27:50 <begriffs> Thanks, I'll give it a try. So anyone else developing this package will need to themselves add-source too after doing sandbox init?
15:28:06 <nh2> begriffs: I believe so
15:28:17 <srhb> If the version you need is not on Hackage, yeah.
15:28:21 <nh2> maybe not if you check in the cabal.config file or so
15:28:40 <nh2> or cabal.sandbox.config
15:29:34 * hackagebot ses-html 0.1.0.0 - Send html emails written in Haskell  http://hackage.haskell.org/package/ses-html-0.1.0.0 (DavidJohnson)
15:31:13 <alrunner4> add-sources are in .cabal-sandbox/add-source-timestamps, though
15:34:35 * hackagebot snaplet-mandrill 0.1.0.2 - Snap framework snaplet for the Mandrill API library.  http://hackage.haskell.org/package/snaplet-mandrill-0.1.0.2 (ParnellSpringmeyer)
15:50:22 <volty> hi. So I cannot use same names across different data definitions?  is this fixed? will it be fixed? when it will be fixed ?
15:50:56 <geekosaur> why do you think it must be fixed?
15:51:04 <volty> eh ????
15:51:13 <kadoban> volty: You mean can you have two constructors with the same name in the same module? No, you can't...and that's not a bug.
15:51:41 <kadoban> volty: What are you trying to do?
15:51:55 <volty> data Point =  Point { x :: Float, y :: Float }, ok? I cannot have another data def with x as a member, right ?
15:52:12 <Iceland_jack> volty: That should be fixed in the next version with OverloadedRecordSyntax
15:52:29 <merijn> Assuming that is done for 7.10
15:52:33 <volty> nice Iceland_jack, thx, have any idea when ?
15:52:57 <Iceland_jack> volty: No
15:53:18 <gienah> volty: https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields
15:53:23 <Iceland_jack> 7.10 should happen around February next year, but I can't say the extension will be included
15:53:26 <volty> geekosaur: show some respect -- because not everybody is learning haskell to toy around :)
15:53:44 <volty> thx :)
15:53:55 <geekosaur> you failed to provide enough information for me to know you meant something that's moderlately obscure
15:54:24 <geekosaur> also I don't see where what I said was disrespectful, so much as confused...
15:55:32 <Cognizance> MMM
15:55:43 <volty> geekosaur: but you didn't ask for more info :) // but nm, since you did not get it (my fault) I consider your answer ("why do you think ... ") dropped, thx anyway
15:56:05 <geekosaur> (to be clear: my confusion, not yours)
15:57:13 <glguy> geekosaur: Don't second guess yourself, yours was a fine question
15:58:45 * geekosaur will also note that the whole record/field thing has been an open "bug" for what, a decade now? longer? and only tiny changes ever happen because nobody can agree on a real fix...
15:59:04 <geekosaur> (well, someone can, actually. it's called lens :p )
15:59:20 <hpc> lens has type signature problems
16:00:01 <hpc> (namely, they aren't great hinting for what each operator does)
16:00:36 <Fuuzetsu> what packages should I be looking at for cyclic graphs?
16:00:49 <glguy> hpc: Do you have an example of one that seems hard?
16:01:10 <hpc> :t (^.)
16:01:11 <lambdabot> s -> Getting a s a -> a
16:01:15 <volty> let's say I have a data Point = Point { x :: Float, y ::Float) and I want to move it by giving a displacement as a Point or tuple (x,y). Do I have to write different functions (moveByPoint, moveByTuple) or it can be achieved by some means of "overloading"?  (I come from Ruby, C++)
16:01:23 <hpc> (that was totally picked at random)
16:01:45 <hpc> (also it's not the best example)
16:02:03 <hpc> too sleepy to hoogle for a good one
16:02:05 <Fuuzetsu> volty: you can use typeclasses for such a thing but it seems pointless
16:02:25 <glguy> hpc: Once you know what a Getting is that one is actually pretty straight forward
16:02:32 <Fuuzetsu> or you could make instances for the stuff from lens which is a bit more on-steroids approach of what you want to do but that also seems pointless
16:02:44 <volty> Fuuzetsu: what's the haskellish approach ?
16:02:56 <vanila> volty, I would use (x,y) everywhere
16:03:01 <vanila> then you don't need Point datatype
16:03:05 <glguy> Getting a s a    gets an a out of an optic that visits a's in s's
16:03:11 <Fuuzetsu> vanila: types are good, shush
16:03:23 <vanila> Fuuzetsu, Do not tell me to shush
16:03:24 <hpc> oh good, now i need to know what an optic is
16:03:24 <glguy> and given an s you get an a back
16:03:26 <hpc> and how it visits
16:03:30 <Fuuzetsu> vanila: but I just did
16:03:34 <vanila> @ops
16:03:35 <lambdabot> Maybe you meant: pl oeis docs
16:03:39 <vanila> @where ops
16:03:39 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
16:03:44 --- mode: ChanServ set +o dcoutts
16:03:54 * hpc much prefers abstract property getter managers
16:03:55 <shachaf> vanila: ?
16:04:06 --- mode: ChanServ set -o dcoutts
16:04:07 <trap_exit> ? why are ops asked ?
16:04:08 <glguy> hpc: optics are the foundation of the lens package
16:04:19 * dcoutts wonders why he was summoned
16:04:27 <vanila> dcoutts, because of Fuuzetsu
16:04:28 <glguy> there's the things like _1   _Left   yourLens
16:04:29 <trap_exit> we should have a new rule ... whenever ops are called, somenoe gets kick banned
16:04:42 <MP2E> heh
16:04:46 <hpc> :t _1
16:04:47 <lambdabot> (Field1 s t a b, Functor f) => (a -> f b) -> s -> f t
16:04:50 <hpc> blech
16:04:58 <glguy> Are you trying to learn or be difficult?
16:05:06 <hpc> both ;)
16:05:08 <trap_exit> what did Fuuzetsu do wrong, besides picking a nick that is hard to type ?
16:05:15 <glguy> OK, take care
16:05:18 <hpc> ta
16:05:26 <geekosaur> trap_exit, npot always viable, sometimes someone calls for ops for spam and then freenode deals first
16:06:05 <geekosaur> (fairly often for those "i hope u like them" videos spams, in fact)
16:06:34 <glguy> hpc: but one last thing, the type signatures are reported in the haddocks are much better than what :t will give you.   _1 :: Lens s t a b
16:06:37 * dcoutts determines that in this case people can sort things out in a civilised way themselves and disappears
16:06:40 <glguy> http://hackage.haskell.org/package/lens-4.4.0.2/docs/Control-Lens-Tuple.html
16:06:55 <glguy> so if you're trying to understand something you'll do better to look at the haddocks
16:06:58 <glguy> due to type aliases
16:07:02 <trap_exit> meta question: does "anyone feel that they program haskell better while fasting?" <-- does this belong in #haskell or #haskell-blah ?
16:07:10 <vanila> dcoutts, It'd be nice if you could at least suggest that being rude to people like that isn't ok here
16:07:30 <shachaf> vanila: Probably better to handle something like this by saying something in #haskell-ops rather than @where ops directly in here.
16:07:34 <glguy> moderation discussion is welcome in #haskell-ops
16:07:37 <glguy> and off-topic in this channel
16:07:59 <Fuuzetsu> This got about 5 minutes more attention that it deserved
16:08:09 <Fuuzetsu> than*
16:08:09 <benzrf> trap_exit: probly -blah
16:08:11 <benzrf> idk
16:08:27 <abracadabra_> hi!
16:08:32 <Fuuzetsu> abracadabra_: hello
16:08:36 <vanila> glguy, last time I asked for help there shapr was very nasty me and after I left to escape it he continued to insult me in here
16:08:38 <dcoutts> vanila: I think Fuuzetsu wasn't meaning to be rude, but I'm sure Fuuzetsu now knows that you felt it was rude. I think that's probably enough for now.
16:08:48 <vanila> dcoutts, ok, thank you
16:08:49 <abracadabra_> I'm trying to install the linux binaries for Haskell, v 7.8.3
16:08:59 <abracadabra_> but when I run the activate-hs script
16:09:04 <singularai> hey does anyone have experience using template haskell to define functions that call c files? I'm having an issue with template haskell not linking soon enough
16:09:06 <abracadabra_> I get the error message "ghc root not found"
16:09:09 <abracadabra_> how do I fix this?
16:09:23 <hpc> glguy: yeah, that's much more clear
16:09:24 <glguy> vanila: Whether you got the outcome you wanted or not, it's off topic here
16:09:29 <abracadabra_> note that this is a vanilla linux installation on which I only had ghc installed before now attempting to get the latest haskell
16:09:31 <vanila> dcoutts, I think that sarcastically mocking me by saying "oh I just did" suggests that he did intend to be rude though
16:09:37 <hpc> specifically the examples that don't go full polymorphic:
16:09:38 <hpc> _1 :: Lens (a,b) (a',b) a a'
16:09:45 <vanila> glguy, alright
16:09:46 <Fuuzetsu> vanila: take it to -ops if you don't like it
16:09:50 <hpc> significantly easier to see how it works
16:10:17 <trap_exit> this seems far less rude then things I regularly say in #haskell :-)
16:11:16 <glguy> hpc: Yes, lots of the operators, even the ones that aren't tied to a typeclass will have examples of valid/useful instantiations
16:11:57 <rodlogic_> Control.Applicative's Const - when people usually use this?
16:12:19 <dibblego> rodlogic_: lens, for example
16:12:35 <glguy> rodlogic_: When they have a generic combinator which, when instantiated to Const, provides the behavior they want
16:12:50 <glguy> > view _1 ('a','b') -- uses Const
16:12:51 <lambdabot>  'a'
16:13:00 <Axman6> :t view
16:13:01 <lambdabot> MonadReader s m => Getting a s a -> m a
16:13:12 <glguy> type Getting r s a = (a -> Const r a) -> s -> Const r s
16:13:24 <dibblego> Functor f => (a -> f b) -> s -> f t
16:13:34 <dibblego> let f = Const r
16:13:45 <dibblego> (a -> Const r b) -> s -> Const r t
16:14:19 <rodlogic_> So basically I can add a type level 'tag' (the phantom type) to a value with zero cost at runtime?
16:15:04 <trap_exit> aren't tags removed at compile time?
16:15:32 <Axman6> there are no types after it's compiled, they're all stripped
16:15:40 <joelteon> no at runtime
16:16:07 <rodlogic_> I was creating my own version of Const until I realized it already exists. The only downside is that it doesn't implement Show
16:16:32 <Fuuzetsu> newtype
16:21:40 <volty> read it, force lens to space and there will be a nice progress (using oo like constructs), maybe with imported & qualified modules too --- if the compiler knows the type it can invoke the right function  without us prefixing the right version (e.g. Data.ByteString.putStr ). Am I wrong?
16:38:15 <joelteon> wow, persistent has been having some serious trouble these last few days -_-
16:38:48 <alrunner4> what's wrong with persistent?
16:39:26 <joelteon> it went from 2.0.0 to 2.0.3.1 in about three days
16:40:21 <alrunner4> well, 2.0 sounds like a big change, so plenty of new bugs to be found, i guess
16:42:30 <trap_exit> nonsense
16:42:33 <trap_exit> haskell code has no bugs
16:42:54 <c74d> ô_o
16:43:15 <joelteon> and all the persistent stuff is in the same repository, so it can all get pushed out at once, but esqueleto isn't
16:44:41 <Fuuzetsu> I was just saying this in #yi but I spent 5 days forming about 6000 lines of changes commit succesfully compiling only twice in that period and it seems I haven't introduced any obvious bugs
16:44:57 <Fuuzetsu> just make the types align ;)
16:52:39 <alrunner4> according to github's measurement, persistent is 91% C, so perhaps that's where all the bugs are
16:53:18 <Fuuzetsu> 100% of bugs in 91% of source
16:54:54 <alrunner4> i think github is a bit misled by the 5MB of sqlite's C source, though
17:01:06 <rqiu> Hi, can someone please let me know what this the best way to show code in this forum except pasting to the chat room?
17:01:18 <Fuuzetsu> @where lpaste
17:01:18 <lambdabot> http://lpaste.net/new/haskell
17:01:19 <geekosaur> @paste
17:01:19 <lambdabot> Haskell pastebin: http://lpaste.net/
17:01:21 <shachaf> hpaste.org
17:01:22 <geekosaur> heh
17:01:30 <Fuuzetsu> shachaf: Is hpaste back?
17:01:30 <shachaf> lpaste.net is an unofficial synonym for hpaste.org
17:01:59 <Fuuzetsu> Right, but old pastes are still lost.
17:02:03 <geekosaur> other way around?
17:02:19 <geekosaur> hpaste redirects to lpaste. and the pastes that were there all seem to be on lpaste
17:02:32 <rqiu> you guys are great
17:02:34 <geekosaur> I have certainly been able to refer to them, with manual url editing
17:02:37 <Fuuzetsu> geekosaur: But hpaste was first and lpaste was created when hpaste was lost for a bit
17:02:44 <rqiu> so, here it is: http://lpaste.net/111179
17:03:04 <Fuuzetsu> rqiu: don't use hard tabs
17:03:14 <rqiu> can someone please show me how to fix the indentation for this multiply table func?
17:03:19 <geekosaur> yes, but hpaste is no longer the official one. (another thing was that as more FP groups have started to use it, I tgink the decision was to go with a more FP-general name: lambda-paste)
17:03:42 <geekosaur> if you check the channel dropdown, it seems to have gotten around a bit :)
17:03:58 <rqiu> @Fuuzetsu: will fix it next time, thanks
17:03:58 <lambdabot> Unknown command, try @list
17:04:18 <shachaf> Why is hpaste no longer official?
17:04:44 <rqiu> @where lpaste
17:04:44 <lambdabot> http://lpaste.net/new/haskell
17:05:06 <Fuuzetsu> rqiu: see the annotation at http://lpaste.net/111179
17:05:17 <Fuuzetsu> also please don't use @-style addressing, it triggers lambdabot
17:05:26 <shachaf> Oh well, not worth arguing about anyway.
17:05:46 <Fuuzetsu> shachaf: becase hpaste was lost for few weeks, was it not?
17:06:22 * geekosaur should go dig out the discussion where the maintainer decided to make it more fp-generic instead of haskell-specific
17:07:18 <shachaf> The domain had temporary ownership issues but those are resolved.
17:07:32 <rqiu> the func generates the table correctly, but the indentation seems to be hard to get right without breaking this one-liner
17:07:46 <Fuuzetsu> rqiu: Also, I don't mean ‘don't use tabs in pastes’, I mean ‘don't use tabs in Haskell source’. http://urchin.earth.li/~ian/style/haskell.html is the standard reference.
17:08:01 <rqiu> yes, i got it.
17:08:14 <rqiu> i will change my sublime text setting
17:08:18 <Fuuzetsu> rqiu: You should simply break up your massive if into more functions.
17:10:26 <rqiu> ok, i guess it is probably the best option
17:14:09 <rqiu> http://lpaste.net/111180
17:15:33 <Fuuzetsu> Cool.
17:22:33 <Fuuzetsu> is there an easy way to have a ghc-options flag inside the cabal file depending on GHC version used?
17:22:43 <Fuuzetsu> apparently -flate-dmd-anal is no-go on 7.6.3
17:23:17 <kadoban> That sounds like a command line switch someone would make up as a joke :)
17:25:12 <Fuuzetsu> I wish everyone just used 7.8.3 already
17:34:40 * hackagebot growler 0.1.0.1 - A revised version of the scotty library that attempts to be simpler and more performant.  http://hackage.haskell.org/package/growler-0.1.0.1 (IanDuncan)
18:05:39 <xp_prg> hi all, is it possible to run haskell in a browser?
18:06:07 <hpc> it can be compiled to javascript
18:06:22 <bms1> xp_prg: There are several projects which compile Haskell to javascript. Is that what you're looking for?
18:06:25 <xp_prg> but like is there a way to just get it to run in a browser from a browser?
18:06:36 <xp_prg> like I want a plnkr with hasell in it
18:07:14 <bms1> I'm not sure what you're asking
18:07:27 <xp_prg> so I want to add the code I want to execute in the browser in haskell, hit run and it just starts running int he browser
18:07:39 <xp_prg> like skulpt for python
18:07:54 <bms1> xp_prg: tryhaskell.org?
18:08:32 <xp_prg> but I can't seem to save my code and share it using that
18:08:40 <xp_prg> unless I am wrong?
18:08:48 <bms1> xp_prg: fpcomplete.com has a web IDE
18:08:55 <xp_prg> if I am wrong it would be the first time
18:09:31 <xp_prg> bms1 that runs haskell?
18:10:03 <bms1> I realize it's not super easy to find from there: https://www.fpcomplete.com/business/haskell-center/overview/
18:11:15 <benzrf> hey!
18:11:22 <benzrf> is there a library for free algebraic structures?
18:11:43 <shachaf> What would be in such a library?
18:11:58 <xp_prg> thanks bms1
18:12:16 <xp_prg> bms1 can I share some haskell code and embed it in my web page somehow using that?
18:12:38 <bms1> fpcomplete has their school of Haskell: see https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/sum-types for example
18:12:41 <benzrf> shachaf: a data type that creates a free group or free abelian group or whatever given another type
18:12:44 <benzrf> or something
18:12:50 <bms1> But I'm not sure if you can share it outside of their ecosystem
18:12:56 <benzrf> like how lists are the free monoid
18:13:04 <shachaf> There's no easy type for a free group that you can express in Haskell.
18:13:11 <benzrf> i know
18:13:15 <benzrf> i mean functions along with it
18:13:20 <benzrf> for mult/div
18:13:24 <shachaf> There's (forall r. Group r => (a -> r) -> r), but that one isn't so great.
18:13:27 <benzrf> potentially rings and stuff? idk
18:14:06 <copumpkin> I thought there was
18:14:13 <benzrf> shachaf: i figure it'd probably need an Eq constraint :|
18:14:41 <copumpkin> [(Either Nat Nat, a)]
18:14:51 <benzrf> copumpkin: ooh, interesting
18:15:02 <copumpkin> (I think?)
18:15:08 <benzrf> no wait
18:15:08 <copumpkin> I just made that up
18:15:10 <shachaf> copumpkin: Well, that type is too big.
18:15:16 <benzrf> i dont think that works
18:15:24 <copumpkin> treat the Either as all ints but 0
18:15:46 <shachaf> What do you mean?
18:16:20 <copumpkin> it's a nonzero positive or negative power of the element in question
18:16:26 <shachaf> I guess you're talking about something with a smart multiplication, not just concatenation.
18:16:37 <shachaf> I just mean that the type has equivalent inhabitants.
18:16:38 <gdoteof> i know this is yesod specific, but i don't think anyone has responded int here for months
18:16:54 <benzrf> shachaf: yeah that's pretty unavoidable
18:16:57 <benzrf> smart mult yes
18:17:05 <copumpkin> yeah, I don't think you can get away from that
18:17:15 <gdoteof> http://lpaste.net/111188  I can't deduce the type error; but it seems like getUrlRender is expexting a path with a amster or something
18:17:27 <copumpkin> but I think the type is the right size
18:17:28 <shachaf> Then sure, [(Bool,a)] or whatever is fine modulo laws.
18:17:38 <copumpkin> well, I mean I wouldn't need a fancy equivalence relation
18:17:41 <shachaf> [(Left 1,A),(Right 1,A)] /= []
18:17:55 <shachaf> Maybe I don't understand what you mean.
18:18:06 <benzrf> ''''''''''''''''
18:18:16 <copumpkin> hmm, maybe you're right, I can't prevent that
18:18:22 <benzrf> probably you'd just use smart constructors!
18:18:31 <copumpkin> I was hoping to avoid that :)
18:18:50 <benzrf> freeGroup Atom * freeGroup Molecule
18:18:59 <shachaf> I can't think of a straightforward way to make a type for it.
18:19:00 <benzrf> Atom * Molecule
18:19:19 <benzrf> shachaf: [(Bool, a)] seems right?
18:19:30 <cccccccc> Could someone help me with upgrading cabal on ubuntu 14.04?  I did cabal install cabal-install and the terminal said it installed 1.20 but when I run cabal -V it resolves to 1.16
18:19:31 <shachaf> No, because [(False,x),(True,x)] /= x
18:19:38 <benzrf> shachaf: well yes
18:19:42 * hackagebot ses-html 0.2.0.0 - Send HTML formatted emails using Amazon's SES REST API with blaze  http://hackage.haskell.org/package/ses-html-0.2.0.0 (DavidJohnson)
18:19:48 <benzrf> but you wouldnt be able to get there from the smart constructors!
18:19:59 <shachaf> You can do whatever you want with a smart constructor.
18:20:12 <benzrf> i mean that the module wouldnt export anything but the smart constructor
18:20:27 <copumpkin> Map a [Nat], where the naturals are treated cumulatively? :)
18:20:35 <benzrf> @let newtype FreeGroup a = FreeGroup {unGroup :: [(Bool, a)]}
18:20:38 <lambdabot>  Defined.
18:20:39 <copumpkin> oh wait, NEL Nat
18:20:46 <benzrf> NEL?
18:20:49 <copumpkin> non-empty list
18:20:53 <benzrf> oh
18:20:59 <benzrf> How so
18:21:38 <alrunner4> cccccccc: your path probably doesn't have your user .cabal/bin before wherever your other cabal is
18:21:45 <xp_prg> bms1?
18:22:13 <bms1> xp_prg: yes?
18:22:14 <copumpkin> hmm no still too big
18:22:45 <shachaf> The type I gave works but is terrible.
18:22:53 <copumpkin> the polymorphic one?
18:22:56 <shachaf> Yes.
18:22:56 <benzrf> shachaf: how SO
18:22:58 <copumpkin> that's a general construction, sure
18:23:21 <shachaf> copumpkin: Well, it's not nearly as terrible before you add inverses.
18:23:52 <copumpkin> why do inverses make it more terrible?
18:23:59 <shachaf> Because it doesn't collapse them.
18:24:03 <copumpkin> oh sure
18:24:05 <shachaf> For a free monoid it's more or less fine.
18:24:07 <xp_prg> bms1 I want to put haskell in an iframe using fpcomplete and put it on my website is that possible?
18:24:19 <shachaf> But I guess we're above concerns like that in here.
18:24:24 <copumpkin> :)
18:24:25 <benzrf> :t (<++>)
18:24:26 <lambdabot>     Not in scope: ‘<++>’
18:24:26 <lambdabot>     Perhaps you meant one of these:
18:24:26 <lambdabot>       ‘<+>’ (imported from Control.Arrow),
18:24:27 <benzrf> hm
18:24:33 <shachaf> benzrf: What?
18:24:39 <benzrf> seeing if it was in scope..
18:24:56 <bms1> xp_prg: I'm not sure. As I showed with that link, I know you can share code fragments on their site, but I don't know if you can do it elsewhere
18:25:01 <shachaf> That seems better suited for /msg.
18:25:06 <benzrf> sigh!
18:25:22 <xp_prg> I heart you for showing me that bms1
18:25:47 <benzrf> is there an xor
18:26:23 <cccccccc> alrunner4: How would I go about fixing that
18:26:39 <benzrf> :t xor
18:26:40 <lambdabot> Bits a => a -> a -> a
18:26:43 <benzrf> meh.
18:27:02 * shachaf sighs too.
18:27:51 <xp_prg> what are all the popular languages right now?  its like java, c++, javascript, haskell, prolog, anything else?
18:28:02 <xp_prg> well perl
18:28:06 <xp_prg> also python
18:28:10 <alrunner4> cccccccc: export PATH=$(HOME)/.cabal/bin:$PATH
18:28:36 <pjdelport> I'm not sure if Perl and Prolog belong in there.
18:28:39 <alrunner4> cccccccc: add to your ~/.profile or what have you
18:28:53 <xp_prg> they are not popular?
18:28:53 <zwer> or haskell to be fair
18:29:09 <pjdelport> Haskell is comparatively popular
18:29:23 <xp_prg> some languages are better at things then other languages
18:29:25 <Axman6> Haskell: Popular by influence, not by use
18:29:43 <xp_prg> what I want is a language that mimics how the brain works
18:29:45 <pjdelport> But, that's probably not a very useful question to answer.
18:29:51 <xp_prg> can I explain it?
18:30:02 <Axman6> xp_prg: chaotic and unpredictable?
18:30:12 <pjdelport> xp_prg: There's a quote: the only intuitive user interface is the nipple. Everything else is learned. :)
18:30:17 <xp_prg> chaos that prunes to predicatablity
18:30:28 <pjdelport> That applies to programming languages too.
18:31:08 <xp_prg> well, I want to discover the famous algorithms that were best solved by a certain language
18:31:19 <xp_prg> like dna was perl
18:31:33 <xp_prg> artificial intelligence was prolog and lisp
18:31:51 <xp_prg> fast running code was c and c++
18:32:18 <xp_prg> java was for people too retarded to use c++
18:32:33 <xp_prg> javascript was an accident that never went away
18:33:17 <xp_prg> typescript was/is javascript ++
18:33:49 <xp_prg> python was easy for scientific non-programmers to use instead of c++/c
18:34:17 <shachaf> copumpkin: Tell me if you figure it out. I suspect it's not possible.
18:34:28 <benzrf> @let groupConcat [] ys = ys; groupConcat (x@(xsign, xv):xs) ys | ((tsign:tv):ts) <- tail, xv == tv, xsign != tsign = ts | otherwise = x:tail where tail = xs `groupConcat` ys
18:34:29 <lambdabot>  .L.hs:161:50:
18:34:29 <lambdabot>      Not in scope: ‘!=’
18:34:29 <lambdabot>      Perhaps you meant one of these:
18:34:29 <lambdabot>        ‘!’ (imported from Data.Array), ‘M.!’ (imported from Data.Map),
18:34:29 <lambdabot>        ‘IM.!’ (imported from Data.IntMap)
18:34:37 <benzrf> @let groupConcat [] ys = ys; groupConcat (x@(xsign, xv):xs) ys | ((tsign:tv):ts) <- tail, xv == tv, xsign /= tsign = ts | otherwise = x:tail where tail = xs `groupConcat` ys
18:34:38 <lambdabot>  .L.hs:162:17:
18:34:38 <lambdabot>      Couldn't match expected type ‘[a]’ with actual type ‘(a, [a])’
18:34:38 <lambdabot>      Relevant bindings include
18:34:38 <lambdabot>        tail :: [[a]] (bound at .L.hs:163:9)
18:34:38 <copumpkin> shachaf: yeah, I thought about it some more and then lost interest :)
18:34:39 <lambdabot>        ys :: [[a]] (bound at .L.hs:160:34)
18:34:42 <benzrf> :|
18:34:45 * benzrf goes to pm
18:35:53 <benzrf> oh, the problem was simple
18:36:00 <benzrf> sweet.
18:36:58 <cccccccc> thanks alrunner4!
18:37:49 <benzrf> @let free = [(True, x)]; neg = reverse . map (first not); (·) = groupConcat
18:37:51 <lambdabot>  Defined.
18:38:21 <benzrf> > free 3 · free 4 · neg (free 4) · free 5
18:38:22 <lambdabot>  Couldn't match expected type ‘a0 -> [(GHC.Types.Bool, a)]’
18:38:22 <lambdabot>              with actual type ‘[(GHC.Types.Bool,
18:38:22 <lambdabot>                                  Debug.SimpleReflect.Expr.Expr)]’Couldn't mat...
18:38:22 <lambdabot>              with actual type ‘[(GHC.Types.Bool,
18:38:22 <lambdabot>                                  Debug.SimpleReflect.Expr.Expr)]’Couldn't mat...
18:38:30 <benzrf> -_-
18:39:10 <benzrf> oh crud i forgot an arg to free
18:39:17 <benzrf> @let free' x = [(True, x)]
18:39:18 <lambdabot>  Defined.
18:39:26 <benzrf> > free' 3 · free' 4 · neg (free' 4) · free' 5
18:39:28 <lambdabot>  [(True,3),(True,5)]
18:39:30 <benzrf> sweet
18:39:48 <benzrf> free groups eh
18:40:13 <Algebr> Throwing this out there cause lots of theory people usually here. I'm taking an intro to computational learning theory course, at Perceptron/Winnow right now. Anyone that has taken this type of theory course before have any kind of insights or pointers?
18:44:43 * hackagebot ses-html 0.2.0.1 - Send HTML formatted emails using Amazon's SES REST API with blaze  http://hackage.haskell.org/package/ses-html-0.2.0.1 (DavidJohnson)
18:48:23 <chrisdotcode> can anyone tell me how I can differentiate the following pattern matches? -Wall warns they're the same:
18:48:23 <chrisdotcode> f (x:[]) = ...
18:48:23 <chrisdotcode> f (x:xs) = ...
18:48:40 <coppro> they're not
18:48:45 <chrisdotcode> I understand that [] is a valid value for xs, but how else can I specify I want to match on the case where there's only one element left?
18:48:55 <shachaf> I think the problem is differentiating GHC warnings from each other.
18:49:11 <shachaf> I suggest posting your full code and full warning on hpaste.org
18:49:41 <chrisdotcode> Warning: Pattern match(es) are overlapped In an equation for ‘processCommits’:
18:49:41 <chrisdotcode> processCommits repo (c : []) = ...
18:49:41 <chrisdotcode> processCommits repo (c : cs) = ...
18:49:59 <coppro> chrisdotcode: they are overlapped, yes, because cs could match "[]"
18:50:14 <chrisdotcode> Right, I understand that much, but [] could technically be different
18:50:18 <chrisdotcode> shachaf says they're entirely different
18:50:29 <coppro> They're not entirely different, they definitely overlap
18:50:40 <zwer> chrisdotcode did you put them in the reversed order?
18:50:54 <zwer> I only get `Pattern match(es) are non-exhaustive' warning
18:51:03 <coppro> it's not a problem per se, but I guess there's a warning for that with -Wall enabled
18:51:10 <shachaf> chrisdotcode: Please post full actual code and full actual warning. :-)
18:51:23 <coppro> ^
18:51:27 <zwer> I am using -fwarn-incomplete-patterns, not -Wall, by the way
18:51:35 <chrisdotcode> Will do
18:51:59 <shachaf> If the problem was always where you thought it was, you would hardly ever have questions.
18:55:37 <lpaste> chrisdotcode pasted “Pattern matching warning” at http://lpaste.net/111195
18:55:45 <chrisdotcode> Essentially, I'm using gitlib to iterate through some commits, and store information about a repository.
18:56:32 <shachaf> Your very first pattern has an _, so it matches every list.
18:56:37 <zwer> order of the pattern matches matter.. _ matches everything, and it always matches over other two
18:56:46 <chrisdotcode> Shoot
18:56:47 <shachaf> (See? The problem is never where you look.)
18:56:52 <chrisdotcode> _ goes last, always, right?
18:57:14 <chrisdotcode> Thanks a lot, guys.
18:57:18 <shachaf> It goes wherever you want. But patterns are matched in order.
18:57:23 <chrisdotcode> Right.
18:59:28 <jayunit100h> hi haskell.  what does the "=>" defined to mean?  what is it called normally (in ruby its called a rocket iirc)
19:00:19 <shachaf> It is usually not called anything. It constrains a type.
19:00:33 <chrisdotcode> "Type constraint-er"
19:01:25 <jayunit100h> Num a => a -- this means "a has to be of type Num" .   is that correct ?
19:01:34 <shachaf> It's syntax, unlike most things that look like operators in Haskell.
19:01:37 <coppro> yes
19:01:42 <shachaf> Well, that's what the "Num a" part means.
19:01:54 <jayunit100h> it seems weird that haskell generates "Num a => a"  .  isnt that redundant? why not just say "Num => a"
19:02:07 <jayunit100h> so what is the part on the right hand side
19:02:11 <shachaf> No. Look at more types to get an idea of what => is for.
19:02:34 <shachaf> (Or don't yet, because type classes should be introduced as late as possible compared to most Haskell features.)
19:02:47 <shachaf> But look at the type of (+), for instance, if you want an example.
19:02:59 <tabemann> for most things, one shouldn't be using any type classes aside from those in the prelude
19:03:14 <jayunit100h> looks like a subtypeing mechanism
19:03:20 <tabemann> it's not subtyping
19:03:27 <tabemann> it's a type constraint
19:03:40 <jayunit100h>  i notice that string doesnt have a "=>" but Int does.
19:03:44 <zwer> jayunit100h how would you express this? (Num a, Ord b) => a -> a -> b
19:03:46 <shachaf> sort is a better example. Num is the scow of type classes.
19:04:04 <ethoma7329> I want to install Criterion with the most recent Haskell platform. But cabal install Criterion warns me "cabal: The following packages are likely to be broken by the reinstalls:
19:04:05 <ethoma7329> unordered-containers-0.2.4.0
19:04:05 <ethoma7329> case-insensitive-1.1.0.3"
19:04:06 <shachaf> jayunit100h: What?
19:04:07 <tabemann> Eq and Ord are good examples of type classes
19:04:17 <ethoma7329> Is there a way to get around this?
19:05:20 <ethoma7329> As in, it seems like whenever I want to install a package, it breaks other packages via its need for updated dependencies
19:05:33 <jayunit100h> sort is a better example?
19:05:34 <orbisvicis> I'd like some suggestions: https://gist.github.com/anonymous/d138325016f5f03c844f. I need to get the longest element of a list, Nothing if an empty list. The original idea was to convert an empty list to Nothing (one), but the nothing value, conceptually, should be the maximum operation, not the list. In (two) I tried to fold a list to Maybe, but it requires the use of the clunky (f) function. Is there a better approach ?
19:06:05 <shachaf> jayunit100h: Imagine you were writing a function to sort a list of things.
19:06:12 <shachaf> You might try to write sort :: [a] -> [a]
19:06:37 <shachaf> But that doesn't work, because sort doesn't know what sort of things it's sorting.
19:06:51 <shachaf> Maybe it's a list of functions, and it's not even possible to compare functions.
19:06:58 <jayunit100h> num doesnt have a "=>"
19:07:01 <shachaf> So instead we write sort :: Ord a => [a] -> [a]
19:07:35 <jayunit100h> shachaf: hi, okay, yes your right,
19:07:50 <shachaf> It's certainly my right.
19:08:20 <jayunit100h> haha . okay, so "Ord"
19:08:35 <shachaf> "Ord a" means "things of type a can be compared"
19:08:42 <jayunit100h> has several instances, i see, such as int/float and so on.
19:08:54 <jayunit100h> makes sense.  analagous to javas comparable.
19:09:22 * jayunit100h shudders at the consequences to saying java in this room :)
19:09:23 <shachaf> you should capitalize your type names. otherwise it gets confusing
19:10:06 <tabemann> Haskell types are always capitalized
19:10:27 <jayunit100h> shachaf: okay, so you are saying that the "=>" is a syntactical element that separates type metadata from the signature of the function.
19:11:01 <shachaf> I'm not saying that, but you can say that if you want.
19:11:18 <jayunit100h> haha :) ok.  well... is it true?
19:11:47 <shachaf> Close enough.
19:12:00 <cccccccccc> hey I'm having trouble install postgresql-libpq, when I run cabal install for it it says ExitFailure 1
19:12:35 <benzrf> cccccccccc: and what lead to such an error
19:13:08 <cccccccccc> benzrf: setup: You need to install postgresql-server-dev-X.Y for building a server-side extension or libpq-dev for building a client-side application.
19:16:19 <benzrf> cccccccccc: hmmm, i wonder what you should do
19:17:10 <cccccccccc> benzrf: okay well I did a cabal install for both postgresql.. and lipq-dev and it didn't work
19:17:47 <jayunit100h> hmm , even with fromIntegral, I still get "No instance for (Fractional Int)" as an error when divinding two numbers
19:17:55 <jayunit100h> xSum(l) / fromIntegral (xlength l)
19:17:58 <benzrf> cccccccccc: look at the package name
19:18:00 <jayunit100h> -- fails ^^
19:18:04 <benzrf> thats a system package
19:18:26 <shachaf> jayunit100h: Post your full code and full error message on hpaste.org. The problem isn't where you think it is.
19:19:13 <jayunit100h> http://lpaste.net/111198
19:19:42 <shachaf> (/) is used for fractional divison, not integer division.
19:20:11 <shachaf> fromIntegeral doesn't help you because it just turns an Int into an Int. xSum only works on Ints.
19:20:31 <shachaf> Also, that's not your full code (it doesn't have xlength) and it doesn't have an error message.
19:21:06 <tabemann> you want `div` for integer division
19:21:09 <shachaf> Also: In Haskell function application is written as "f x", not "f(x)".
19:21:23 <jayunit100h> ok thanks
19:21:26 <shachaf> tabemann: Probably jayunit100h doesn't want integer division in the first place.
19:21:37 <shachaf> It makes for a bad mean.
19:23:10 <tabemann> in theory one could use f(x), f(x,y), f(x,y,z), etc. but no one does that - Haskell isn't SML after all, and that would lose all the advantage of partial application
19:23:53 * tabemann doesn't know why the SML people don't use currying
19:24:45 * hackagebot yesod-auth-oauth2 0.0.7 - Library to authenticate with OAuth 2.0 for Yesod web applications.  http://hackage.haskell.org/package/yesod-auth-oauth2-0.0.7 (PatrickBrisbin)
19:25:35 <benzrf> :t (//)
19:25:36 <lambdabot> Ix i => Array i e -> [(i, e)] -> Array i e
19:25:38 <benzrf> :t (///)
19:25:39 <lambdabot>     Not in scope: ‘///’
19:25:39 <lambdabot>     Perhaps you meant one of these:
19:25:39 <lambdabot>       ‘//=’ (imported from Control.Lens),
19:26:09 <benzrf> @let x /// y = x · neg y
19:26:12 <lambdabot>  Defined.
19:26:40 <benzrf> > free 'x' /// (free 'x' /// free 'y')
19:26:42 <lambdabot>  Couldn't match expected type ‘GHC.Types.Char
19:26:42 <lambdabot>                                -> [(GHC.Types.Bool, a)]’
19:26:42 <lambdabot>              with actual type ‘[(GHC.Types.Bool,
19:26:42 <lambdabot>                                  Debug.SimpleReflect.Expr.Expr)]’Couldn't mat...
19:26:42 <lambdabot>                                -> [(GHC.Types.Bool, a)]’
19:27:07 <benzrf> eek
19:27:10 <shachaf> benzrf: Please use lambdabot to test your code before posting it to the channel, to reduce bot spam.
19:27:13 <benzrf> where's it getting that from
19:28:11 <benzrf> oh right it's free'
19:28:20 <benzrf> > free' 'x' /// (free' 'x' /// free' 'y')
19:28:21 <lambdabot>  [(True,'x'),(True,'y'),(False,'x')]
19:28:33 <benzrf> sweet
19:28:48 <benzrf> i wonder how much more difficult a free abelian group would be >.>
19:29:59 <tabemann> question
19:30:16 <tabemann> when someone raises an IOError, can one catch it by catching IOException?
19:30:34 <shachaf> tabemann: ":i IOError" in ghci confirms it.
19:32:18 <shachaf> benzrf: I've said this to you several times before but you keep going. :-(
19:33:07 <tabemann> I find it interesting to see what people feed into lambdabot
19:33:14 <tabemann> and to see what lambdabot does
19:34:16 <shachaf> Yes, lambdabot is a valuable service for this channel.
19:35:09 <tabemann> stupid question, I've asked it before here but got no response, but what happens if you try to cancel a thread that is in Network.Socket.recv; does it cancel immediately, or does it wait until the recv is complete?
19:36:14 <benzrf> @check \v -> (v :: [(Bool, Char)]) /// v == []
19:36:16 <lambdabot>  +++ OK, passed 100 tests.
19:36:21 <benzrf> cool.
19:37:24 <tabemann> anyone know?
19:38:01 <benzrf> tabemann: i do not, but im sure somebody here does
19:39:08 <tabemann> it's probably a matter of whether it's using the IO manager or it's calling directly out to C; I'd hope it uses the IO manager, but as I don't know anything of its implementation...
19:43:07 <mizu_no_oto> I'm having trouble with 'cabal install --dependencies-only --enable-tests'.  It's failing with something like "cabal: could not resolve dependencies: trying: foo (user goal) rejecting: foo:!test (global constraint requires opposite flag selection) trying: foo:*test".  Any idea what I'm doing wrong?
19:43:33 <shachaf> mizu_no_oto: Global constraint might be something in ~/.cabal/config?
19:47:59 <tabemann> dammit, from reading the source, it appears that it blocks on recv
19:48:10 <tabemann> c_recv is "unsafe"
19:48:53 <tabemann> what what the... that means it blocks *all* threads, and "recv" can run for an indefinite period of time unless made nonblocking
19:49:07 <tabemann> *wait what the
19:51:55 <rusk101> Hello there. Can somebody take a looksie? it is about left and right quotients in formal languages. http://lpaste.net/111196
19:54:45 <ethoma7329> Does anyone else have trouble downloading cabal packages because the needed dependency updates break other packages?
19:55:16 <ethoma7329> Like I can't install Criterion package without breaking two others
20:01:41 <ethoma7329> FYI, found solution to my problems at http://www.haskell.org/haskellwiki/Cabal/Survival
20:09:57 <Dolomite_> lord there are lotta people here.
20:11:52 <Dolomite_> um, so I'm learning haskell for a college course and my textbook is "learn you a haskell for a great good" which is fine but using GHCi about half the instructions I try fail
20:12:15 <Dolomite_> for instance, trying to use the infix notation
20:12:52 <Dolomite_> "div 6 3" returns 0 but "6 'div' 3" just gives an error
20:12:57 <monochrom> do you mean for example "infixr 4 ***"?
20:13:38 <monochrom> ` and ' are different. look carefully. use `
20:13:45 <Dolomite_> oh that's a tilde?
20:13:47 <tabemann> Dolomite: that's supposed to be 6 `div` 3, with backticks
20:13:58 <monochrom> not called tilde. tilde is ~
20:13:59 <eazar001> > 6 `div` 3
20:14:01 <lambdabot>  2
20:14:09 <Dolomite_> OIC
20:14:12 <c74d> Dolomite_: ` is grave accent, not tilde
20:14:26 <eazar001> or you can say backquote
20:14:30 <eazar001> or backtick too, i think
20:14:53 <monochrom> and Tilda is http://www.imdb.com/name/nm0842770/ :)
20:15:04 <c74d> it’s “grave accent” in Unicode
20:15:16 <eazar001> ha
20:16:07 <eazar001> > div 6 3
20:16:08 <lambdabot>  2
20:16:16 <Dolomite_> right I meant mod
20:16:17 <c74d> “backtick” isn’t even a listed alternative name, which wasn’t what I expected
20:16:18 <Dolomite_> sorry really tired
20:16:41 <Dolomite_> I mean I wouldn't normally resort to an irc channel unless I was at my limit
20:16:44 <eazar001> Dolomite_: it's cool
20:17:07 <Dolomite_> so I have at least 2 other mysteries bothering me.
20:17:28 <Fuuzetsu> so, can *your* editor use Control.Lens for its configuration? ;)
20:17:52 <Dolomite_> way too newb to even know what that is.
20:18:19 <Dolomite_> but um, the examples I'm looking at for function... definitions? all just begin with a name.
20:18:20 <c74d> extemporaneous Yi propagandizing? :)
20:18:20 <Fuuzetsu> Well, that was aimed at a wider audience rather than you specifically.
20:18:34 <Dolomite_> I have to type "let myfunction etc..."
20:18:52 <tabemann> I'd be impressed by Yi if it allowed you to script it while it run, without having to restart it
20:18:54 <Fuuzetsu> c74d: damn right, I finished adding some bugs today and just got my config to compile with all the changes so I'm feeling pretty good
20:19:05 <tabemann> which is what I plan on doing with the IRC client I'm working on
20:19:19 <c74d> were you adding bugs intentionally?
20:19:21 <tabemann> Yi should have a REPL
20:19:39 <Fuuzetsu> tabemann: Well the idea is that we serialise the state, recompile, restart, kind of like XMonad
20:19:52 <Fuuzetsu> It does not work perfect but it's not like you wipe your whole session
20:20:22 <tabemann> I'm doing a runtime compilation of code which is then loaded dynamically as plugins
20:20:43 <Fuuzetsu> Interesting. Do you have much in a way of that?
20:22:04 <eazar001> @botsnack
20:22:05 <lambdabot> :)
20:22:07 <tabemann> I plan on making that available as general functionality to the user, so they can compile and load arbitrary code at runtime; right now I just have some very basic examples separate from my main codebase
20:22:20 <monochrom> Dolomite_: some of those are meant to be entered into a file, then in GHCi you say :load
20:22:41 <monochrom> I'm pretty sure somewhere in chapter 1 this is said.
20:24:25 <Fuuzetsu> tabemann: you should swing by once you get something more going
20:24:40 <Fuuzetsu> c74d: not intentionally of course
20:24:55 <tabemann> oh, I've still got a lot of work to do
20:25:42 <Fuuzetsu> hm, this is an interesting bug, I seem to have made a grave mistake of deleteTrailingWhitespaceB also delete newlines.
20:25:51 <Fuuzetsu> I should not have made this run before saving the file in question.
20:33:28 * Fuuzetsu hopes to one day verify Yi in Agda, at least parts
20:35:32 <chrisdotcode> :t tail
20:35:33 <lambdabot> [a] -> [a]
20:37:43 <tac_> > tail []
20:37:44 <lambdabot>  *Exception: Prelude.tail: empty list
20:37:52 * tac_ gasps audibly.
20:38:16 <MP2E> yep, tail is unsafe! :P
20:39:03 <Fuuzetsu> it has been known to eat children
20:44:39 <Dolomite_> Thanks for the help helpful people.
20:44:46 <Dolomite_> I'm sure I'll be back.
20:46:34 <AshyIsMe> Fuuzetsu: are you using yi as your main editor?
20:47:13 <Fuuzetsu> No, I need to squash enough bugs and get enough performance out for it to not be annoying first.
20:47:19 <Fuuzetsu> – posted from my emacs, as usual
20:51:21 <AshyIsMe> haha ah yeap
20:52:10 <Fuuzetsu> I actually managed to get on IRC from Yi months ago but there are concurrency things we need to figure out first before that's viable, currently it's pretty much serial…
21:14:50 <cwl> where is `forall` function defined? `forall $ \tuple -> over _1 f tuple == (\(fst, snd) -> (f fst, snd)) tuple` https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial
21:15:27 <cwl> found it -_-|||
21:15:33 <shachaf> I searched for "forall" and there's a -- yes.
21:15:38 <cwl> https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial#-sidenote--what-is-that-forall-thing--
21:29:50 * hackagebot arith-encode 0.7.0 - A practical arithmetic encoding (aka Godel numbering) library.  http://hackage.haskell.org/package/arith-encode-0.7.0 (emc2)
21:39:51 * hackagebot datalog 0.2.0.1 - An implementation of datalog in Haskell  http://hackage.haskell.org/package/datalog-0.2.0.1 (TristanRavitch)
21:44:51 * hackagebot datalog 0.2.0.2 - An implementation of datalog in Haskell  http://hackage.haskell.org/package/datalog-0.2.0.2 (TristanRavitch)
21:56:18 <lpaste> Ray pasted “multiply table” at http://lpaste.net/111206
21:56:27 <rqiu> finally got the alignment working for the multiply table - http://lpaste.net/111206
21:56:31 <rqiu> comments welcome
21:58:56 <toblerone> rqiu: one thing you could do is use printf to handle formatting your output
21:59:55 <toblerone> you can have it properly align the columns for you
22:00:56 <rqiu> can i set the width dynamically based on the maximum length of the largest number?
22:01:16 <toblerone> uh, lemme double check, but I think you could...
22:04:05 <rqiu> it might be harder than this current solution, i guess
22:12:49 <toblerone> yeah, I suppose the only complication i see is that printf is effectively an n-ary function and you can't give it a list as an argument
22:13:36 <toblerone> if you could easily do that, the rest would be straightforward.
22:20:26 <rqiu> @toblerone: thanks
22:20:27 <lambdabot> Unknown command, try @list
22:21:17 <rqiu> toblerone: thanks
22:22:21 <toblerone> either way, its no big deal. I'm just commenting. : )
22:44:42 <iobender> anyone on?
22:45:05 <kadoban> several hundred at least
22:56:40 <jle`> can i unload prelude on ghci?
22:56:47 <jle`> interactively in the middle of a session?
22:59:54 * hackagebot persistent-template 2.0.3.2 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-2.0.3.2 (MichaelSnoyman)
23:28:19 <fragamus> does anyone know of something that will generate all possible subsets given a set and subset size
23:28:50 <Gonzih> premutations?
23:29:00 <Gonzih> permutations*
23:29:01 <fragamus> combinations
23:29:26 <fragamus> not ordered
23:30:10 <Gonzih> fragamus: something like that? http://stackoverflow.com/questions/14267196/fast-obtention-of-all-the-subsets-of-size-n-in-haskell
23:31:18 <fragamus> ooh nice
23:32:56 <Gonzih> enjoy! :)
23:40:19 <splintax> anyone know any good documentation on how dependency resolution and linking works in cabal?
23:40:58 <splintax> i keep ending up in cabal hell and i feel like cabal could be improved, but i don't fully understand what happens when cabal resolves dependencies
23:49:17 <felixn> splintax: ya it sucks
23:49:43 <felixn> nodejs has better dependency management
23:50:13 <felixn> splintax: http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
23:50:18 <idea-man> whats new with haskell folks?
23:50:22 <idea-man> :)
23:50:47 <jorgn> hi yall
23:50:57 <jorgn> im lookn for some insight into algebraic data types
23:51:10 <jorgn> tryna wrap my head around it
23:51:16 <jorgn> them*
23:51:30 <felixn> jorgn: lots of tuts out there, basically once you learn it it's hard to live without
23:51:43 <felixn> Swift (from apple), Haxe, and Rust all have it
23:53:00 <felixn> it's like nested Enums
23:53:10 <felixn> and switch statements that are actually useful
23:54:33 <jorgn> i just dont get how to pull one of the variables that compose the ADT out cleanly
23:54:58 <c_wraith> ADTs are only half the story
23:54:58 <felixn> yea you could use records
23:55:08 <c_wraith> Pattern matching is the other half, and just as important.
23:55:09 <felixn> so you get a function to pull a value out
23:56:05 <felixn> myfunction (MyDataType var1 var2 var3) = var1 + var2 + var3 -- you can use pattern matching to pull values out as well
23:56:28 <jorgn> huh
23:56:57 <felixn> jorgn: this is a good read on it http://learnyouahaskell.com/making-our-own-types-and-typeclasses
23:57:22 <felixn> they even touch on that question
23:57:56 <felixn> now someone help me setup nfs with kerberos
23:58:01 <jorgn> dude
23:58:02 <jorgn> thank you
23:58:05 <jorgn> so much
23:58:20 <felixn> the check is in the mail?
23:58:26 <jorgn> https://wiki.debian.org/NFS/Kerberos
23:58:33 <jorgn> ofcourse ;)
23:58:33 <felixn> lol thanks
