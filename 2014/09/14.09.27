00:01:11 <vanila> I think so but you shouldn't take my word for it!
00:02:54 <Vince_swFlorida> I fear that I may be distracting the meditative comtemplation being practiced in the channel.  I don't want to alter the vibes of bliss with my inquisitiveness.
00:03:27 <vanila> haha no worries ask all you want
00:03:58 <Vince_swFlorida> Why wouldn't I want to take your word for it?   I don't hear any words to the contrary being raised.
00:07:10 <Vince_swFlorida> Ok .. why do you write interpreters for programming languages with haskell instead of pascal (for instance)?
00:07:46 <vanila> beacuse it has algebraic data types that let you easily define the abstract syntax of a language
00:08:03 * hackagebot dash-haskell 1.0.0.0 - Command line tool to generate Dash docsets (IDE docs) from package haddock  http://hackage.haskell.org/package/dash-haskell-1.0.0.0 (jfeltz)
00:08:03 * hackagebot text-show 0.2.0.0 - Efficient conversion of values into Text  http://hackage.haskell.org/package/text-show-0.2.0.0 (ryanglscott)
00:09:37 <Vince_swFlorida> Oh my now you just made my day, vanila!  The heart of my programming of Darwin_OP is going to be the algebraic geometry that translates meaning into movement.
00:10:14 <vanila> wow ! good luck
00:11:19 <Vince_swFlorida> Thanks for that preliminary insight into the mathematical treasures that lay within haskell, vanila!
00:12:15 <vanila> yeah there is a lot of those waiting to be found
00:12:49 <Vince_swFlorida> Are you working in the USA, vanila?
00:12:52 <vanila> no
00:13:20 <Vince_swFlorida> Where? If you don't mind me asking.
00:13:25 <vanila> UK
00:13:47 <Vince_swFlorida> I see.... still too close to USA for comfort.
00:15:29 <nshepperd> there's a haskell user's group here in melbourne, by the way
00:15:40 <Vince_swFlorida> Oh wow!
00:15:44 <nshepperd> I intended to go to a meetup this week, but I forgot
00:16:03 <Fuuzetsu> are folds over Text slow as ass or am I measuring something wrong
00:16:05 <nshepperd> MHUG: http://www.meetup.com/Melbourne-Haskell-Users-Group/
00:16:09 <Vince_swFlorida> Glad you didn't forget to tell me about it!
00:17:07 <Vince_swFlorida> I'm on it!  Thanks for the memory!
00:17:35 <nshepperd> every day I'm glad for what I haven't forgotten. I am a naturally forgetful person
00:18:53 <Fuuzetsu> nshepperd: but you could be forgetting all the other stuff you don't remember you have forgotten!
00:19:35 <nshepperd> it's endless!
00:19:52 <dmj`> you can't forget to remember what you forgot
00:20:29 <Vince_swFlorida> Got it tucked away in Word.
00:21:15 <nshepperd> oh wow: http://hackage.haskell.org/package/tardis-0.3.0.0/docs/Control-Monad-Tardis.html
00:21:33 <Vince_swFlorida> That way it doesn't matter that I've already forgot it ... 'cause it's there in Word no matter what!
00:23:42 <Vince_swFlorida> If they meet regularly, I will plan to make their November meeting.  That is if I don't forget.
00:25:07 <Vince_swFlorida> I've packed this last URL away in Word to safe keeping but I don't know what it's good for!
00:26:51 <Haskellfant> nshepperd: interesting, I didn't even know there was such a thing as a reverse state monad
00:27:52 <vanila> http://conway.rutgers.edu/~ccshan/wiki/blog/posts/TPDC_2011/ there's also a Primer (time travelling film) monad
00:29:02 <Vince_swFlorida> Wow ... A net split ... I thought that was a thing of the past!
00:29:16 <vanila> it's not a netsplit :P
00:29:33 <vanila> freenode is run by rather interesting folk
00:29:41 <Vince_swFlorida> What was it ... an earthquake?
00:29:46 <Arahael> Nope, not a netsplit.  That's a... massive kline.
00:29:54 <vanila> they set up traps that if someone joins a certain channel, they get k-lined and removed from the server
00:30:07 <vanila> now there are hundreds of people who connect to IRC through "irccloud"
00:30:19 <vanila> and a trickster just told one of them to join one of these trap channels
00:30:41 <Vince_swFlorida> Oh, like being shoved out of the air lock while visiting the Moon Station.
00:30:50 <ion> That’s pretty hilarious.
00:30:57 <Arahael> To be fair, this technique falls into the "damned if you do it, damned if you don't" - and freenode has found it's slightly better if they do it. :/
00:31:34 <rioch> I'd like to write some bdd tests. I've found hspec, but I was hoping for something with support for cucumber/gherkin-like feature files. Does such a thing exist for haskell?
00:31:50 <Haskellfant> so their banning everybody connecting through irccloud?
00:31:50 * Vince_swFlorida tucks an emergency oxygen tank up under my armpit.
00:31:54 <Haskellfant> that seems strange
00:32:51 <Arahael> Haskellfant: The observation is that particular bots frequent particular channels which are extremely uncommonly frequented by humans.
00:32:58 * hackagebot yi-rope 0.2.2.0 - A rope data structure used by Yi  http://hackage.haskell.org/package/yi-rope-0.2.2.0 (MateuszKowalczyk)
00:33:00 <Arahael> Haskellfant: Or illegal.
00:33:34 <Arahael> Haskellfant: And by klining such bots, which is done on an ip address range (iirc), you remove a certain percentage of script kiddies.
00:33:44 <Haskellfant> Arahael: hm k
00:33:54 <Haskellfant> as long as I don't get k-lined I'm ok with it :)
00:35:06 <Vince_swFlorida> I'm not so sure ... since I'm hoping to hire some script kiddies or oldies to write the scripts for my knowledge categories.
00:35:31 <Haskellfant> Vince_swFlorida: if their banned from irc they have more time to work for you
00:35:57 <Vince_swFlorida> Ahhhhhhhhhhhhhh yesss now that's a horse of a different color.
00:36:57 * Fuuzetsu will code for money ;)
00:37:14 <Haskellfant> Fuuzetsu: most people here probably will :)
00:37:31 <Vince_swFlorida> Where located Fuuzetsu?
00:37:46 <Fuuzetsu> UK
00:38:03 <Vince_swFlorida> Sorry ... Out of my comfort zone.
00:39:58 * Fuuzetsu goes back to hoping his bank doesn't cut his resources off
00:40:59 <Vince_swFlorida> Time for me to shut my eyes for awhile... have a great one ... if not for mun, then at least work for fun!
00:41:36 <vanila> see ya!
00:42:18 <Vince_swFlorida> Thanks for you tolerance of my ignorance and for the great suggestions I've gathered! (Like being in a Garden of Eden!)
00:42:49 <Fuuzetsu> oo, apparently Student Finance are sending money few days earlier than I initially thought, thank god for that
00:48:48 <rioch> Is TDD necessary when programming in haskell?
00:50:28 <Haskellfant> I prefer type driven development :)
00:50:59 <Fuuzetsu> I thought he *was* asking about type-driven
00:51:26 <Haskellfant> tdd usually stands for test driven development
00:51:53 <Fuuzetsu> you came to the wrong neighbourhood
00:52:04 <rioch> What is type driven development? (ps. I have yet to write anything beyond hello world in haskell - be nice!)
00:52:37 <shachaf> It is a bit of a joke.
00:52:58 <Fuuzetsu> rioch: it is the idea that we use types and other such static assurances to write probably-correct code, rather than having to come up with a multitude of tests for everything ever in hopes of catching bugs
00:53:07 <Fuuzetsu> no bugs to catch if your types don't allow for them ;)
00:53:14 <nshepperd> supposedly QuickCheck is the bee's knees
00:53:20 <nshepperd> I haven't used it myself though
00:53:32 <shachaf> The idea of test-driven development is that you write tests first, and they specify a bunch of behavior that helps guide you toward writing the right code.
00:53:50 <Fuuzetsu> shachaf: He's asking what type-driven is.
00:54:21 <shachaf> The idea of "type-driven development" is that your types are so expressive that they help in the same way as tests in writing the write code.
00:54:21 <rioch> How does the type system/quickcheck prevent the programming implementing something correct (it runs) but does the wrong thing?
00:54:53 <nshepperd> err, QuickCheck is a testing framework, that is
00:55:16 <shachaf> In practice Haskell's types are usually not so expressive. But they are statically checked at compile-time, and many things that they do they do much better than unit tests.
00:56:38 <Fuuzetsu> rioch: Well, consider something simple like dealing with lists. A common function like ‘head’ might cause runtime problems: the list might be empty &c You could of course tests everywhere that your list is not empty and try to deal with it, or you could simply use a data type that ensures there's always at least one element in the list, making ‘head’ safe in every scenario, meaning you'll never run into a bug due to an empty list where
00:56:38 <Fuuzetsu> you didn't expect it.
00:57:55 <rioch> So with TDD and BDD you write tests first. I'm a bit lost of where to start with haskell. It's beginning to sound like I should start by defining some types. Is that a fair assumption?
00:58:43 <Fuuzetsu> Yep, sounds good.
00:58:44 <nshepperd> people frequently start by writing the type signature of the function they are trying to write
00:59:07 <nshepperd> I find it useful
00:59:16 <Fuuzetsu> I don't know how you'd start writing something in Haskell without writing down some types first, you need to work over *something*
01:04:15 <michi7x7> type driven development aka. "make the code so complicated that it is literally impossible for it to behave in a wrong way"
01:06:06 <Haskellfant> michi7x7: exactly :)
01:06:32 <simpson> Or just hack it out.
01:07:05 <simpson> Simple is better than complex; complex is better than complicated. Make your prototype work before worrying about whether the types are perfect.
01:20:12 <dfeuer> WTF does iswspace do? It's some foreign import used to implement isSpace, but ... what?
01:20:38 <shachaf> What it says?
01:21:46 <dfeuer> shachaf, what it says *where*?
01:22:04 <shachaf> In the name?
01:22:06 <shachaf> @google what does the function iswspace do?
01:22:08 <lambdabot> http://www.opengroup.org/onlinepubs/9699919799/functions/iswspace.html
01:22:08 <lambdabot> Title: iswspace
01:22:33 <dfeuer> Oh I see now. It's locale-dependent. UGH.
01:23:27 <shachaf> Hmm, so it is.
01:24:58 <shachaf> It's a reasonable function to have regardless of locale-dependence.
01:28:02 <dfeuer> shachaf, I suppose so, but that dependence seems unfortunate. The external environment changes program semantics in a way that may not always be so obvious. I wouldn't even be surprised if there were safety issues involved.
01:31:05 <michi7x7> locales have always been a huge problem
01:31:42 <michi7x7> most unix tools probably just do setlocale("C")
01:32:14 <dfeuer> michi7x7, I also don't see any general Haskell locale support.
01:32:24 <dfeuer> Just time stuff.
01:33:28 <michi7x7> i18n is nothing the runtime or os should do for you (imho)
01:34:16 <michi7x7> Haskell also does not provide any translations of error messages
01:34:48 <dfeuer> Why didn't anything get done with https://ghc.haskell.org/trac/ghc/attachment/ticket/1473/space.hs ?  Use unsigned comparison for that \b..\r range, and the rest just like Yitzchak Gale or Ketil Malde's version.
01:35:41 * dfeuer goes to sleeeeeeeep.
01:43:03 * hackagebot twitter-conduit 0.0.7 - Twitter API package with conduit interface and Streaming API support.  http://hackage.haskell.org/package/twitter-conduit-0.0.7 (TakahiroHimura)
01:46:07 <vincenzo> ciao
01:46:52 <vincenzo> film
01:59:05 <Fuuzetsu> how come there's no Monoid m => Semigroup m instance in the semigroups package?
01:59:43 <Fuuzetsu> oh, there's this WrappedMonoid thing, guess I can use that
01:59:52 <shachaf> For the same reason there's no Monad m => Applicative m instance and so on.
02:00:26 <Fuuzetsu> mhm
02:01:12 <shachaf> I don't get it.
02:02:03 <Haskellfant> shachaf: that one should come with 7.10 :)
02:02:14 <michi7x7> http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
02:02:29 <shachaf> I'll be happy to see it primarily to see people stop using that acronym.
02:02:46 <Haskellfant> which acronym?
02:03:21 <shachaf> Never mind.
02:04:54 <Fuuzetsu> There are no acronyms happening here.
02:05:54 <Fuuzetsu> According to InternetSlang.com, mhm is the same as mhmm which means ‘Yes, sure, OK’.
02:23:29 <k00mi> Fuuzetsu: the reason there is no such instance is that it would overlap with every other instance
02:23:56 <Fuuzetsu> -XOverlappingInstances
02:23:57 <Fuuzetsu> ;^)
02:24:44 <k00mi> it won't do what you might think it does
02:25:27 <Fuuzetsu> I'm just kidding
02:26:45 <k00mi> ok, I wasn't quite sure how serious you are ;-)
03:07:23 <volty> hi,  I have to change the values of some html attributes, and substitute certain tags. Can you suggest me a library that has documentation with examples for that purpose?
03:09:02 <Fuuzetsu> volty: http://adit.io/posts/2012-04-14-working_with_HTML_in_haskell.html
03:09:29 <Fuuzetsu> hxt in general can make this pretty easy as long as your files are human-sized (< tens of MBs)
03:10:36 <volty> Fuuzetsu: going to read, thx
03:18:10 * hackagebot radium-formula-parser 0.1 - Chemistry  http://hackage.haskell.org/package/radium-formula-parser-0.1 (klangner)
03:23:11 * hackagebot radium 0.3 - Chemistry  http://hackage.haskell.org/package/radium-0.3 (klangner)
03:35:44 <yashi> Is there something that takes an existing list and gives me back a new list with the Nth item replaced by an element I specify?
03:36:15 <shachaf> Not in base. It's not a great operation for lists.
03:36:56 <yashi> What do you mean not great?
03:37:43 <Ferdirand> performance in O(N) ?
03:37:52 <sbidin> I could swear this pattern was once required to be surrounded with parens. True?
03:38:10 <sbidin> > let x:_ = [1] in x
03:38:12 <lambdabot>  1
03:38:18 <shachaf> Not required.
03:38:26 <shachaf> f (x:_) requires parentheses, though.
03:38:36 <vanila> sbidin, you're defining x with this, its not a pattern to a function
03:38:48 <vanila> > let f (x:_) = [1] in f [1]
03:38:50 <lambdabot>  [1]
03:38:53 <yashi> So you want me to use a fixed size list instead?
03:39:10 <sbidin> So weird. It seems every tutorial I've ever read surrounded it with parens everywhere. Thanks!
03:39:16 <vanila> in this case you need parens, since let f x:_ = [1] in f [1] parses as let (f x):_
03:39:23 <vanila> because functions bind tighter than opreators
03:40:51 <k00mi> yashi: we can't say without knowing more about what you're trying to do
03:43:12 * hackagebot leveldb-haskell 0.4.2 - Haskell bindings to LevelDB  http://hackage.haskell.org/package/leveldb-haskell-0.4.2 (KimAltintop)
03:44:05 <yashi> OK, I came up with this: replaceItemInList indx list newItem = (fst (splitAt indx list)) ++ newItem : (drop 1 (snd (splitAt indx list))). I realize it's extremely inefficient. How can I improve it?
03:44:21 <vanila> yashi, factor splitAt out like this:
03:44:40 <vanila> replaceItemInList indx list newItem = (fst spl) ++ newItem : (drop 1 (snd spl)) where spl = splitAt indx list
03:44:56 <yashi> cool
03:44:59 <yashi> thanks
03:45:02 <vanila> you can even get rid of fst and snd now using
03:45:17 <vanila> replaceItemInList indx list newItem = start ++ newItem : (drop 1 rest) where (start,rest) = splitAt indx list
03:45:28 <yashi> nice
03:46:38 <yashi> Now I need to write the same thing, but for a 2D list.
03:46:59 <vanila> yashi, one way to represent a 2D grid is this  (Int,Int) -> Cell
03:47:11 <vanila> so you get the cells out like this: grid (3,2)
03:47:54 <vanila> if you use a representation like that, you can write   updateCell newPos newValue grid = \coordinate -> if coordinate == newPos then newValue else grid coordinate
03:48:13 * hackagebot leveldb-haskell 0.5 - Haskell bindings to LevelDB  http://hackage.haskell.org/package/leveldb-haskell-0.5 (KimAltintop)
03:48:18 <k00mi> note that will append newItem if the list has less than indx elements
03:49:24 <yashi> vanila: I'm not sure what you mean by "get cells out like this". If my list is [[1,-1,1],[1,1,1],[-1,-1,-1]] then I could get it's (0,0) element like [[1,-1,1],[1,1,1],[-1,-1,-1]] (0,0)?
03:49:44 <vanila> [[1,-1,1],[1,1,1],[-1,-1,-1]] represents a grid using [[Cell]]
03:50:00 <vanila> A different way to represent grids is using (Int,Int) -> Cell
03:51:12 <yashi> vanila: How does it work then? I'm used to writing functions like myfunc param = param+1
03:51:43 <yashi> so I would have grid (i,j) = what?
03:52:18 <vanila> grid (0,0) = 1 ; grid (1,0) = -1 ; grid (2,0) = 1
03:52:26 <vanila> grid (0,1) = 1 ; grid (1,1) = 1 ; grid (2,1) = 1
03:52:46 <vanila> grid (0,2) = -1 ; grid (1,2) = -1 ; grid (2,2) = -1
03:52:51 <yashi> That seems rather inefficient as far as notation goes
03:53:18 <vanila> I use this in my sokoban game
03:53:21 <AshyIsMe> haha uh oh
03:53:31 <AshyIsMe> cabal: out of memory (requested 2097152 bytes)
03:53:36 <yashi> My eventual goal is to generate an NxN grid of random 1's or -1's and feed it into my functions.
03:53:43 <AshyIsMe> on a vm with 512mb ram for a bot i want to run
03:57:12 <lnostdal> hi, what's the "standard" (i guess defacto) IDE or editor Haskell users use?       i mean for e.g. Clojure it's pretty much Emacs (with cider plugin)
03:57:32 <AshyIsMe> emacs and vim as far as i can tell
03:57:44 <lnostdal> ok, cool
03:57:46 <fizruk> :t \n f -> sequence . take n . iterate (>>= f) . return
03:57:47 <lambdabot> Monad m => Int -> (a -> m a) -> a -> m [a]
03:57:51 <fizruk> @pl \n f -> sequence . take n . iterate (>>= f) . return
03:57:51 <lambdabot> ((sequence .) .) . (. ((. return) . iterate . (=<<))) . (.) . take
03:58:19 <AshyIsMe> lnostdal: if you're a vim user: hasktags, syntastic and ghc-mod are all well integrated
04:00:06 <gfixler> lnostdal: I found Vim to be very capable with Clojure
04:00:12 <gfixler> with a few plugins
04:03:25 <arboris> where can I find the documentation for type classes that have a type declaration in them, like the class IsList l where type Item l... etc?
04:03:59 <lnostdal> gfixler: yes, but emacs+cider is more common there
04:04:38 <Fuuzetsu> *Yi.Rope> Yi.Rope.takeWhile isSpace r
04:04:38 <Fuuzetsu> YiString {fromRope = fromList [Chunk {chunkSize = 1, _fromChunk = "c"}]}
04:04:40 <Fuuzetsu> spot the bug ;(
04:05:10 <ClaudiusMaximus> arboris: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-families.html#assoc-decl
04:05:23 <arboris> oh, so they are called type families
04:05:26 <arboris> thanks
04:05:55 <arboris> i was looking for such a feature to model OCaml modules
04:08:50 <dramforever> is there a function (a -> c -> Maybe a) -> [a] -> ([a], [a]) that does a stateful takeWhile?
04:08:58 <dramforever> oooh, should be span
04:09:02 <dramforever> :t Data.List.span
04:09:03 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
04:09:13 <dramforever> But span is not stateful
04:10:07 <shachaf> I'm not sure where c is coming from.
04:11:03 <fizruk> should be smth like (a -> State s (Maybe a)) -> [a] -> State s ([a], [a])  I guess
04:11:07 <dramforever> sorry, should be (s -> a -> Maybe s) -> [a] -> ([a], [a]) ... I was thinking about "char" and "a" and realized that the list should be [a] and got mixed up
04:11:28 <dramforever> fizruk: spanM...
04:11:49 <fizruk> dramforever: what do you need that for anyway?
04:12:09 <shachaf> Now my question is where s comes from.
04:12:21 <dramforever> fizruk: lexing-ish thing
04:12:21 <shachaf> But fizruk's question is also good.
04:12:28 <bennofs> shachaf: you'd probably also need an exrta initial s
04:13:07 <dramforever> yeah, and let's forget about the monad-less one and talk about spanM
04:14:14 <fizruk> dramforever: can you solve your problem with regexes?
04:15:27 <dramforever> fizruk: maybe not...you know regexs are Problem -> (Problem, Problem)
04:16:30 * dramforever is not doing anything serious and is just thinking about random stuff
04:17:58 <dramforever> forget about it...maybe i'll write my own
04:18:31 <{AS}> so regex is join (,)?
04:20:59 <arboris> is there a way to create fixed length c arrays with the foreign function interface?
04:23:15 * hackagebot leveldb-haskell 0.5.1 - Haskell bindings to LevelDB  http://hackage.haskell.org/package/leveldb-haskell-0.5.1 (KimAltintop)
04:23:49 <fizruk> arboris: like allocaArray ?
04:24:00 <fizruk> arboris: see Foreign.Marshal.Array
04:24:08 <fizruk> https://hackage.haskell.org/package/base-4.7.0.1/docs/Foreign-Marshal-Array.html
04:24:59 <AshyIsMe> damn
04:25:09 <AshyIsMe> cant cabal install lens with only 512mb ram apparently
04:25:59 <arboris> fizruk: No, that gives you just a Ptr a, for some Storable a
04:26:29 <fizruk> arboris: that is exactly what a C array is
04:26:53 <arboris> fizruk, no it isn't, something like double a[1000];
04:27:05 <arboris> is not the same as a ptr to a double
04:27:19 <arboris> the compiler knows the difference
04:27:35 <fizruk> what do you gain from that difference?
04:27:45 <arboris> static guarantees
04:27:51 <arboris> and you can call sizeof(a)
04:28:00 <arboris> and get sizeof(double)*1000
04:29:11 <arboris> well technically it is not a call, but a macro
04:30:53 <arboris> they are also potentially allocated differently
04:32:00 <arboris> because their size is known at compile time
04:32:28 <fizruk> I guess you can deal with “arrays” using Data.Vector.Storable then
04:32:57 <mauke_> sizeof can't be a macro
04:33:16 * hackagebot yi-rope 0.3.0.0 - A rope data structure used by Yi  http://hackage.haskell.org/package/yi-rope-0.3.0.0 (MateuszKowalczyk)
04:33:23 <mauke> arboris: if you could create arrays, how would you use that?
04:42:08 <trap_exit> this is waayaaay off topic, but perhaps someone can help me: I have a mbp 13 ... I can't install OSX (tried internet recovery), ubuntu, or centos on it
04:42:12 <trap_exit> how do I check if the SSD is fucked ?
04:42:31 <trap_exit> so I believe the SSD has problems ... which is why I can't install anythning on it anymore ... but I don't know how to run tests without an OS
04:46:33 <heaumer> trap_exit: is there any error message somewhere in the installs process?
04:46:41 <trap_exit> no
04:46:47 <trap_exit> it's just like "an errror occured" (on centos)
04:46:58 <trap_exit> a circle with a line through it (Mac OSX)
04:47:06 <trap_exit> and ubuntu: installs, but ffeezes on startx
04:47:19 <trap_exit> this is a jlike 2010, 2011 mbp 13"
04:48:01 <arboris> mauke: I would use it just as I would use something with type (Ptr a, Int), except that in C the compiler could generate more efficient code for the case it knew the size statically, i guess that does not matter since GHC would not have such optimizations
04:48:30 <mauke> arboris: more efficient code? how?
04:48:50 <arboris> mauke, it knows the address of the Ptr at compile time
04:49:08 <mauke> arboris: no, it doesn't
04:49:24 <mauke> arboris: but assume it did. how would that lead to more efficient code?
04:49:28 <arboris> if you declare something as double a[12];
04:49:32 <arboris> sure it does
04:49:38 <mauke> no, it doesn't
04:49:48 <vanila> if you think it does or doesn't, give a reason why
04:49:55 <vanila> you can't just make claims without evidence
04:49:59 <mauke> yes, I can
04:50:34 <arboris> well, i believe it would reserve place in the data segment for 12 doubles
04:50:49 <mauke> could you answer my question?
04:51:06 <vanila> arboris, that's right but when the OS creates the  process it will have its own new adderss space - so the pointer might be different each time
04:52:55 <arboris> mauke, if it knows the address it can prefetch the array
04:53:05 <mauke> what does that mean?
04:53:17 <vanila> arboris, Hi
04:53:23 <mauke> give me actual source code and compilation results
04:53:40 <mauke> or even made up source code
04:54:56 <arboris> vanila, ok that is true but shouldn't be the translation be transparent to the program, that is if the compiler assumes it starts address 0
04:55:11 <vanila> I see
04:55:36 <mauke> the compiler can't assume that
04:55:57 <mauke> otherwise you get into trouble with constant folding
04:56:00 <arboris> mauke, well that is easy if the array is not statically allocated, you can do this by hand
04:56:18 <mauke> you've lost me
04:56:24 <arboris> by accessing the elements of the array before actually using them so that it is in a cache line
04:56:35 <arboris> that's what i meant by prefetching
04:56:45 <vanila> so may I ask how this relates to haskell programming?
04:56:50 <mauke> what's a cache line? what does this have to do with code?
04:57:06 <mauke> what is supposed to be "more efficient" about anything?
04:57:55 <arboris> hm, cpus have caches
04:58:03 <mauke> no, let's go back to code
04:58:07 <mauke> I like talking about code
04:58:12 <arboris> ok, well
04:58:30 <mauke> you said the compiler could generate more efficient code
04:58:32 <arboris> all i was trying to say was that in C it is nice to have a statically allocated buffer
04:59:13 <mauke> I don't see how it's "nice"
04:59:24 <doismellburning> #haskell-blah ?
04:59:35 <fizruk> vanila: original question was whether it is possible to create C “arrays” through Haskell FFI, now I guess they are fighting about C having “2” types of “arrays”
05:00:00 <mauke> I don't feel like I'm fighting
05:00:20 <mauke> just trying to figure out whether these assertions are based on facts
05:00:26 <fizruk> this may be poor wording, sorry :)
05:00:52 <mauke> (and if so, what facts exactly? and then I can start about thinking how to do the same thing in haskell)
05:01:05 <mauke> *thinking about
05:01:15 <boris``> statically vs dynamically allocated arrays?
05:01:28 <rom1504> boris``: you lose
05:01:38 <arboris> mauke, ok well you can write something like for(int i; i < sizeof(a); i++) { ... }, where you somewhere declared double a[N]; for N some constant
05:01:47 <mauke> yes
05:01:52 <arboris> the compiler knows that sizeof(a) is some constant
05:02:03 <mauke> that's probably a bug, btw
05:02:13 <arboris> int i = 0
05:02:26 <mauke> oh, I didn't even see that
05:02:36 <mauke> sizeof a is the number of bytes in a, not elements
05:03:07 <arboris> well
05:03:19 <arboris> the point is you have static information about the size of the array
05:03:24 <mauke> if N is small (1 or 2), the compiler might unroll the loop
05:03:42 <mauke> but I doubt it'd do that for medium or bigger N
05:03:45 <arboris> which you don't if you dynamically allocate it
05:03:52 <arboris> thats all
05:03:54 <vanila> arboris, In haskell you could use tuples
05:03:59 <mauke> arboris: how does that information help with code generation?
05:04:03 <vanila> e.g. (Int, (Int, (Int, (Int, ()))))
05:04:10 <mauke> arboris: you keep avoiding that point
05:05:13 <mauke> (now that I think about it, you can do dynamic unrolling. that's exactly what duff's device is about)
05:05:45 <boris``> loop unrolling doesn't buy you much anyways
05:05:46 <arboris> mauke: it depends on the code
05:06:23 <arboris> mauke: in cuda for example knowing the size of an array statically buys you more parallelism
05:06:52 <mauke> parallelism + global variables?
05:06:55 <mauke> fun
05:07:17 <arboris> mauke, well no you would use templates in this case and duffs device to dispatch
05:07:45 <mauke> (C has no templates)
05:07:54 <mauke> also, what
05:09:10 <arboris> mauke, think about how you would do vector reduction on a gpu
05:09:31 <arboris> mauke, also i was just trying to give an example
05:09:58 <arboris> if you don't believe me that it is good to know the size of an array statically fine
05:10:28 <arboris> also you can declare an array in a function body, so there is no need to have a global variable
05:10:31 <mauke> we've sort of shifted over from known address to known size
05:11:01 <arboris> known address helps in different situations
05:11:33 <mauke> besides, we're talking about the FFI
05:11:43 <mauke> local variables are irrelevant
05:12:32 <mauke> (because if it's part of an interface, it's not local anymore)
05:12:42 <silver> mauke, http://en.wikipedia.org/wiki/C11_(C_standard_revision) see _Generic :)
05:12:46 <CasW> Hey guys, can you explain to me why I get "Not in scope: data constructor `rose'" in here? http://pastebin.com/YQrh955a
05:13:18 <mauke> CasW: because there is no data constructor called Rose in that code and you're trying to use it
05:13:26 <mauke> and the error message says Rose, not rose
05:14:05 <CasW> Yeah, you're right, that was a typo, but how do I access that `Rose' data type, then?
05:14:11 <mauke> silver: ok, now what?
05:14:19 <fizruk> CasW start with lowercase letter
05:14:20 <mauke> CasW: the constructor is called :>
05:14:28 <silver> mauke, nothing really, just sayin'
05:14:39 <fizruk> CasW: root (a :> rose) = a
05:15:02 <fizruk> and note that [rose] would pattern match only singleton list
05:15:12 <CasW> Ah, you're right, thanks! It compiles!
05:15:53 <mauke> silver: http://www.youtube.com/watch?v=2zU_lK_5Ryw
05:16:03 <mauke> fizruk: aah
05:16:42 <fizruk> CasW: so if you wrote it “root (a :> [rose]) = a” it would not work on e.g sample = 1 :> [sample, sample]
05:16:56 <silver> mauke, nice thanks
05:17:22 <CasW> Yeah, exactly, while if you write (a :> rose), rose would be the list itself, instead of a list of the 'rose' object
05:17:38 <mauke> in an expression/pattern, [foo] is equivalent to (foo : [])
05:18:00 <mauke> where : and [] are the two list constructors
05:22:53 <arboris> mauke, yes you are right from a FFI perspective it is sort of pointless
05:23:22 <arboris> it would be nice to be able to assert that a C array has a fixed known size
05:23:49 <mauke> what do you mean by that?
05:23:58 <mauke> (in some sense every C array has a fixed size)
05:24:22 <arboris> size known at compile time
05:24:36 <zereraz> hello, can someone explain me this error http://lpaste.net/111710
05:25:32 <Jeanne-Kamikaze> zereraz, you need to give the list a type
05:25:51 <zereraz> Jeanne-Kamikaze: why?
05:25:52 <Eduard_Munteanu> zereraz, loop has a too general type
05:25:53 <Jeanne-Kamikaze> [a] is Show only if a is Show
05:26:04 <Jeanne-Kamikaze> and there's nothing saying a is Show
05:26:13 <Eduard_Munteanu> loop :: Show a => [a] -> IO ()
05:26:14 <mauke> zereraz: because the type determines how the list is printed
05:26:25 <zereraz> oh
05:26:26 <Eduard_Munteanu> Er, missing the Show.
05:26:37 <zereraz> so how to tell the type of list?
05:26:49 <Jeanne-Kamikaze> impose it, or do what Eduard_Munteanu said
05:26:52 <mauke> zereraz: what type do you want?
05:27:11 <zereraz> It is an list of integers
05:27:17 <zereraz> so I just want to print it at the moment
05:27:30 <mauke> zereraz: loop :: [Integer] -> IO ()
05:27:32 <mauke> would be one way
05:27:34 <Eduard_Munteanu> Give loop a type signature.
05:28:18 <zereraz> it works
05:28:20 <zereraz> thanks allot
05:29:12 <mauke> http://4.bp.blogspot.com/_D_Z-D2tzi14/S8TRIo4br3I/AAAAAAAACv4/Zh7_GcMlRKo/s1600/ALOT.png
05:29:55 <Jeanne-Kamikaze> http://cdn.memes.mugglenet.com/2014/2/8/memes.mugglenet.com_5200_1391917318.jpg
05:37:07 <CasW> Hm, is it possible to transpose tuples? I have Board = (Row, Row, Row) and Row = (Field, Field, Field), and I want to transpose the board
05:38:20 <bakibour> Why not introduce a new type Column?
05:38:27 <vanila> CasW, let a (x,_,_) = x ; b (_,y,_) = y ; c (_,_,z) = z then  transpose (f1,f2,f3) = ((a f1, a f2, a f3),(b f1, b f2, b f3),(c f1, c f2, c f3))
05:38:36 <bakibour> And just put the rows in columns.
05:39:42 <CasW> Because I don't know if I'm allowed to, it's for an excercise for my study ;-) Vanila: I like your solution, it's beautiful! :-P
05:43:36 <bakibour> How can i constraint or impose some structural requirement on a type of a type family?
05:53:22 * hackagebot pit 0.3.1 - Account management tool.  http://hackage.haskell.org/package/pit-0.3.1 (chiro)
05:53:24 * hackagebot gtk2hs-hello 1.1.0.0 - Gtk2Hs Hello World, an example package  http://hackage.haskell.org/package/gtk2hs-hello-1.1.0.0 (HamishMackenzie)
05:54:49 <bms1> bakibour: can you be more specific?
05:55:18 <bakibour> bms1: Sec
05:57:21 <hvr> wasn't there a way to qualify  function/variables in the current module explicitly?
05:58:19 <bms1> hvr: You mean to give kinds to the type variables?
05:58:37 <bakibour> bms1: https://gist.github.com/b0urb4k1/b04891331adf1dfcd902
05:58:50 <hvr> bms1: no, rather if I define something that clashes with e.g. Prelude (but I don't want to hide nor import Prelude qualified)
05:59:13 <bakibour> What i would like to do is to be able to say that the Move type has to be derived from some typeclass or somesuch.
05:59:15 <bms1> oh
05:59:22 <bakibour> Eg that it is a Monoid for example
06:00:15 <bms1> bakibour: My first thought is to make a multiparam type class and add that as a class constraint
06:00:49 <Eduard_Munteanu> Or put constraints on methods.
06:01:06 <bakibour> Hm hm hm
06:01:18 <bms1> The second is that you could add your own mappend and mempty inside the Game typelass
06:01:24 <bakibour> Well i make it a parameter the type is not governed by the type class
06:01:49 <Eduard_Munteanu> bakibour, use a fundep
06:02:13 <bakibour> Arent type families supposed to be equivalent?
06:02:27 <Eduard_Munteanu> class Monoid b => Game a b | a -> b where
06:03:23 * hackagebot radium-formula-parser 0.2 - Chemistry  http://hackage.haskell.org/package/radium-formula-parser-0.2 (klangner)
06:03:26 <Eduard_Munteanu> They aren't really, at least currently... there are things you can write with typeclasses that you can't write with type families.
06:04:19 <Eduard_Munteanu> The equivalence and discussion around it is theoretical, AFAIU.
06:04:45 <bakibour> Hm hm hm
06:05:24 <bakibour> Well but if i make that Move type a parameter it is not originating from the typeclass itself.
06:05:59 <bakibour> I mean it is just beeing really picky i guess but what i thought to want to model is that the game solely is governing the type.
06:06:00 <Eduard_Munteanu> bakibour, what do you mean originating from the typeclass?
06:06:26 <bakibour> It i think of a move in a certain game it is just something that is part of the game.
06:06:33 <bakibour> It can not be a parameter of that game.
06:06:42 <bakibour> Philosophically speaking.
06:08:34 <Eduard_Munteanu> bakibour, you can treat 'Game a b' as introducing 'b' as a constraint... e.g. foo :: Game a b => {-# here 'b' is your Move a #-}
06:09:09 <Eduard_Munteanu> bakibour, as if you wrote    foo :: (Game a, b ~ Move a) => ...
06:10:03 <sgronblo> How does #define work in Haskell? Same as C?
06:10:11 <bakibour> Whats the sqiggly?
06:10:24 <Eduard_Munteanu> bakibour, type equality constraint
06:10:40 <Eduard_Munteanu> sgronblo, yes
06:12:20 <bakibour> Is there any reason why i can not impose constraints like that on the inner type?
06:12:40 <bakibour> I mean like that it is not possible to do that because there are limitations to the type system
06:13:13 <bakibour> Or is it just something that is usually not required and thus omitted because you have other means to achive this?
06:13:25 <Eduard_Munteanu> bakibour, type families (and type functions in general) have to be total... you'd be restricting the domain to something smaller than '*'.
06:14:22 <bakibour> But i can do that on typeclass level as well with deriving right?
06:14:49 <bakibour> Or would that require you to have dependent types then?
06:15:06 <Eduard_Munteanu> bakibour, no, the typeclass constraints are still total, regardless of whether an instance exists or not
06:15:31 <Eduard_Munteanu> bakibour, Monoid X :: Constraint exists regardless of whether X is a monoid.
06:16:27 <exio4> I haven't checked the whole conv, but it seems that you want something like http://blog.omega-prime.co.uk/?p=61?
06:17:00 <bakibour> checking sec
06:17:38 <Eduard_Munteanu> bakibour, one possible alternative would be   class Game a where type IsMove a :: * -> Constraint   but haven't tested it.
06:19:03 <bakibour> exio4: I think that this goes in the direction yes.
06:19:40 <Eduard_Munteanu> Actually nevermind, you still can't add Monoid in the typeclass definition.
06:21:12 <Eduard_Munteanu> bakibour, also same reason you can't put contexts on data types
06:21:14 <latk> is there a way to invoke cabal run with flags  ?
06:22:05 <bakibour> Eduard_Munteanu: Hm i see, is it just me not beeing used to this kind of stuff or is it... i dont want to say a problem but i find it a bit unconveinient.
06:22:33 <bakibour> As in it is not the ordering you would usually think about modeling this problem.
06:22:58 <bakibour> Hm or it might not be, you also could argue that the game is composed of these types.
06:23:13 <Eduard_Munteanu> Even with the old DatatypeContexts, if 'data Monoid a => Foo a = ...', then Foo X actually exists regardless of whether Monoid X is true.
06:23:17 <bakibour> And that you have to provide it from the outside by parameterizing it that way.
06:23:54 <exio4> oh sorry
06:24:09 <exio4> this was what I wanted to post http://blog.omega-prime.co.uk/?p=127
06:25:08 <Eduard_Munteanu> DataKinds might let you restrict the domain of a type function but it wouldn't be convenient either.
06:27:27 <exio4> bakibour: I guess ConstraintKinds is what you want?
06:27:30 <bakibour> It gets even worse i guess when id like to put in the game state as in inner type ...
06:27:51 <bakibour> exio4: let me reread it
06:28:10 <exio4> it is a different post
06:28:35 <exio4> I posted the wrong link, had both tabs open :P
06:30:57 <AshyIsMe> hmm that's weird
06:31:18 <AshyIsMe> mueval works on osx but in linux it's telling me that Control.Monad.Error is deprecated
06:31:26 <AshyIsMe> same version of ghc
06:31:29 <AshyIsMe> 7.6.3
06:32:49 <bakibour> exio4: I think is might be it.
06:33:01 <bakibour> But i fail to see what i would have to add as a type then.
06:33:25 * hackagebot haste-compiler 0.4.2.1 - Haskell To ECMAScript compiler  http://hackage.haskell.org/package/haste-compiler-0.4.2.1 (AntonEkblad)
06:33:37 <exio4> the "Index constraints" part is what you want to do, I think?
06:34:28 <bakibour> exio4: I guess :) but i do not see yet how i can require that the type provided is a Monoid yet.
06:34:44 <exio4> oh, for the default implementation?
06:35:45 <bakibour> exio4: https://gist.github.com/b0urb4k1/b04891331adf1dfcd902 i want to force you here to make Move a Monoid.
06:36:31 <rudi_s> Hi. Can I run function in the State monad in another function in the StateT .. IO monad? I want to use a callback function with State so it can't do IO in another function which needs IO and access to the same state. Thanks.
06:37:40 <bennofs> :t state . runState
06:37:41 <lambdabot> MonadState s m => State s a -> m a
06:37:53 <bennofs> :t state . runState :: State s a -> StateT s IO a
06:37:54 <lambdabot> State s a -> StateT s IO a
06:40:08 <exio4> bakibour: I don't really know, I thought you wanted a constraint for a specific implementation
06:41:00 <bakibour> No i want to constraint the class so every instance has to fulfill the constraint.
06:42:40 <exio4> but doesn't that mean that your function doesn't belong to the typeclass?
06:43:18 <exio4> I haven't played much with typeclasses though, I can't say much about them
06:46:31 <arianvp_> > quickCheck (\xs -> (length (permutations xs)) == ((length xs)^2))
06:46:33 <lambdabot>  <IO ()>
06:46:40 <arianvp_> quickCheck says this is false! but it's true :/
06:47:00 <arianvp_> oh wait it isnt
06:47:01 <arianvp_> nvm
06:48:25 <mauke> @check \xs -> (length (permutations xs)) == ((length xs)^2)
06:48:26 * hackagebot kansas-lava-papilio 0.1.0 - Kansas Lava support files for the Papilio FPGA board  http://hackage.haskell.org/package/kansas-lava-papilio-0.1.0 (GergoErdi)
06:48:27 <lambdabot>  *** Failed! Falsifiable (after 1 test):
06:48:27 <lambdabot>  []
06:48:38 <mauke> > permutations []
06:48:40 <lambdabot>  [[]]
06:49:18 <rudi_s> bennofs: Thanks. So is this right way to handle it or did I misunderstand you? test f = do { x <- get; let (_,y) = runState f x ; put x } where f is in State and test is in StateT .. IO?
06:49:44 <bennofs> rudi_s: no, do test f = state $ runState f
06:51:00 <mornfall> arianvp_: how would that be true?
06:51:02 <rudi_s> bennofs: Ah, perfect. Thank you.
06:51:22 <arianvp_> mornfall: it isn't I was mistaken :P
06:51:28 <mauke> @check \xs -> (length (permutations xs)) /= ((length xs)^2)
06:51:30 <arianvp_> mornfall: it should be   (length xs)!
06:51:30 <lambdabot>  *** Failed! Falsifiable (after 2 tests):
06:51:30 <lambdabot>  [()]
06:53:26 * hackagebot kansas-lava-shake 0.1.0 - Shake rules for building Kansas Lava projects  http://hackage.haskell.org/package/kansas-lava-shake-0.1.0 (GergoErdi)
06:56:12 <exio4> permutations is n!
06:56:51 <mauke> @check \xs -> length (permutations xs) == product (zipWith pure [1 ..] xs)
06:56:55 <lambdabot>  (0 tests) (1 test) (2 tests) (3 tests) (4 tests) (5 tests) (6 tests) (7 test...
06:57:09 <bennofs> > permutations [()]
06:57:10 <lambdabot>  [[()]]
06:58:27 * hackagebot vado 0.0.2 - Runs commands on remote machines using ssh  http://hackage.haskell.org/package/vado-0.0.2 (HamishMackenzie)
07:01:23 <exio4> > (\x → x) 'a'
07:01:25 <lambdabot>  'a'
07:01:33 <exio4> oh, neat, it works with →
07:02:13 <Twey> exio4: There's an extension UnicodeSyntax that makes →, ←, ∷, ∀, ★ work as expected
07:03:05 <Moogly2012> how would you use those characters on a regular American keyboard?
07:03:17 <exio4> didn't know that → and ← worked
07:03:19 <Moogly2012> o.o
07:05:16 <mauke> > undefined ∷ 1
07:05:17 <lambdabot>  Expected a type, but ‘1’ has kind ‘GHC.TypeLits.Nat’
07:05:26 <mauke> sweet
07:05:48 <mauke> @kind 2 + 2
07:05:49 <lambdabot> Not in scope: type constructor or class ‘+’
07:07:31 <davean> Then you did
07:07:35 <davean> mischan
07:07:49 <exio4> now we need "∄x. x"!
07:09:14 <mauke> I thought that was spelled Void -> x
07:09:51 <exio4> wanted to make a little reference to total functional programming :P
07:13:28 * hackagebot unlit 0.3.0.3 - Tool to convert literate code between styles or to code.  http://hackage.haskell.org/package/unlit-0.3.0.3 (pepijnkokke)
07:23:33 <Redz> in a spot where (.) and ($) is possible, which one should i use?
07:23:58 <dibblego> (f . g $ x) is better form than (f $ g $ x)
07:25:01 <Redz> ditto
07:38:30 * hackagebot hadoop-tools 0.2 - Tools for working with Hadoop.  http://hackage.haskell.org/package/hadoop-tools-0.2 (JacobStanley)
07:47:19 <ryantm_> There seems to be a problem with Hackage where the documentation is not building for particular projects. Project maintainers seem to be saying the problem is with a Hackage buildbot not getting around to building the documentation. Is this correct?
07:48:14 <ryantm_> example: https://github.com/yesodweb/persistent/issues/308
07:48:17 <Hijiri> I think so
07:53:42 <ryantm_> I found this issue about it: https://github.com/haskell/hackage-server/issues/145
07:54:57 <ryantm_> Does everyone practically doing work use their own docs on their computer?
07:55:31 <ryantm_> It seems like it's been a problem for almost a year.
07:57:54 <AshyIsMe> damn
07:58:02 <AshyIsMe> seems that mueval is broken on linux at the moment
07:58:08 <AshyIsMe> but not on osx which is weird
07:58:45 <AshyIsMe> the tests.sh script is failing with Control.Monad.Error is deprecated errors
08:00:38 <michaelt> AshyIsMe: https://github.com/gwern/mueval seems to have a patch to take account of such things
08:03:33 <AshyIsMe> ah cheers
08:04:38 <AshyIsMe> michaelt: hmm, that's the one im seeing the issue in, is there a fork somewhere?
08:04:49 <lf94> Do some of you think Haskell is easier than Python?
08:05:09 <lf94> Or more expressive?
08:07:07 <michaelt> AshyIsMe: oh, wait, yes, it isn't dealing with the Control.Monad.Error business? ... Do thing work if you strike the paranoid uses of  -Wall in the .cabal file?
08:07:36 <hamso> Hi! I'm new here :)
08:07:57 <AshyIsMe> michaelt: i'll try that now
08:08:26 <AshyIsMe> lf94: i wouldnt say haskell is easier than python, i came from an imperative background though
08:08:37 <AshyIsMe> apparently if you learn haskell as your first language it's fine
08:09:48 <Th30n> lf94: I think it depends on the person and background whether it is easier. But regarding expresiveness I think in some segments it definitely is.
08:09:50 <michaelt> lf94: the elements are very easy if you stick with the spirit high school algebra and maybe elementary logic class. Then later it's hard; then later it's easy; then impossible; etc.
08:10:09 <lf94> AshyIsMe: I wouldn't say that either; I just want to see others' perspectives.
08:10:13 <michaelt> lf94: all along though, it's very beautiful.
08:11:03 <lf94> I do use Haskell and I feel Python is still more expressive, but I haven't done anything crazy with Haskell yet...
08:11:27 <hiptobecubic> lf94, what do you mean by expressive?
08:12:34 <lf94> hiptobecubic: that's a tough question
08:14:57 <hiptobecubic> then what are we even talking about?
08:16:25 <dfeuer> hiptobecubic, consider how hard it would be to write a Python interpreter in Haskell. Next consider how hard it would be to write a Haskell interpreter in Python.
08:17:02 <AshyIsMe> michaelt: hmm, removing -Wall didnt remove the error, it's weird that im not getting it on osx
08:18:02 <michaelt> AshyIsMe: I'm finding it confusing. The "Control.Monad.Error" warning can only be coming from transformers-0.4 Is that the version that came with your ghc?
08:18:19 <michaelt> I mean the one you have on the linux machine
08:18:33 * hackagebot tagged-exception-core 2.0.0.0 - Reflect exceptions using phantom types.  http://hackage.haskell.org/package/tagged-exception-core-2.0.0.0 (PeterTrsko)
08:18:46 <michaelt> I think that's right
08:18:50 <monochrom> ghc 7.8 comes with transformers-0.3. 0.4 has to be brought in separately
08:19:19 <monochrom> but of course cabal feels like bringing in multiple versions behind your back
08:19:36 <joe9> I understand getZonedTime and getCurrentTime. I am trying to get the time in a timeZone that is not the local time zone. Any suggestions on how to do that, please?
08:19:49 <joe9> > fmap (formatTime defaultTimeLocale "%Y%m%d%H%M%S%Z") getCurrentTime
08:19:51 <lambdabot>  Not in scope: ‘formatTime’Not in scope: ‘defaultTimeLocale’Not in scope: ‘ge...
08:20:11 <joe9> fmap (formatTime defaultTimeLocale "%Y%m%d%H%M%S") getZonedTime
08:20:24 <michaelt> monochrom: that's what i thought. Maybe AshyIsMe should see if there's a local transformers that needs to be junked.  I notice  I have constraint: transformers installed  in my .cabal file
08:20:49 <joe9> not sure how to change the getZonedTime to get the current time in a different time zone than the local time zone.
08:21:46 <michaelt> AshyIsMe: or just build mueval in a sandbox, so that it only sees the globally installed transformers
08:22:05 <michaelt> AshyIsMe: I think that's how it would work
08:22:32 <AshyIsMe> hmm, how do i check which packages i have installed?
08:22:44 <michaelt> ghc-pkg list
08:22:51 <michaelt> ghc-pkg list transformers
08:23:47 <AshyIsMe> ah yeap, that's it
08:23:47 <michaelt> there will be two chunks of packages one global, one from ~./.cabal
08:24:00 <AshyIsMe> 0.3.0.0 on my mac, and 0.4.1.0
08:24:13 <michaelt> ghc-pkg unregister transformers will tell you what will happen before doing anything
08:24:17 <AshyIsMe> er, 0.4.1.0 on the linux machine
08:24:49 <michaelt> (You should perhaps add the version number of the local one, thought it will default to that)
08:25:12 <michaelt> oh wait, that's confusing again ...
08:25:38 <michaelt> does the linux machine also have an 0.3 somewhere
08:26:17 <michaelt> I expected a 0.3 to have come with the compiler as monochrom says
08:27:10 <AshyIsMe> no, only the 0.4
08:28:09 <AshyIsMe> oh maybe i installed ghc incorrectly
08:28:23 <AshyIsMe> apt-get install ghc cabal-install  # that's what i did <-
08:28:53 <zq> is there a short hand for pattern matching on a : b : c : xs?
08:29:55 <michaelt> that should in principal be okay, maybe they have a ghc that uses 0.4 .  It's just that mueval is not ready for this, though I can't reproduce the situation well enough to try stuff ...
08:29:58 <bms1> zq: you realize that that's only 3 characters of "syntatic overhead" already, right? it's hard to beat that
08:30:01 <ChaseTrains> zup bitches. Why use null list instead of list == []?
08:30:25 <fizruk> ChanServ: == requires Eq
08:30:29 <fizruk> :t (==)
08:30:30 <lambdabot> Eq a => a -> a -> Bool
08:30:33 <fizruk> :t (== [])
08:30:34 <lambdabot> Eq t => [t] -> Bool
08:30:37 <fizruk> :t null
08:30:38 <lambdabot> [a] -> Bool
08:30:45 <michaelt> or case ls of [] -> 0; x:xs -> 17
08:30:57 <ChaseTrains> what? I don't get it.
08:31:01 <fizruk> ChanServ: null works for much more lists
08:31:07 <AshyIsMe> michaelt: i'll try specifying 0.3.0.0 explicitly
08:31:17 <fizruk> ChaseTrains: try [(+)] == []
08:31:22 <ChaseTrains> I just heard the word "haskell" for the first time in my life 3 hours ago.
08:31:27 <zq> bms1: huh?
08:31:34 <zq> bms1: it isn't 3 chars
08:31:52 <zq> suppose i want to pattern match on [Either a b]
08:31:54 <bms1> zq: each ':'. The rest you need anyway to bind to variables
08:32:09 <zq> read again
08:32:20 <michaelt> AshyIsMe: i suspect that will just make trouble since other stuff is build against transformers-0.4 already.  It would be better to figure out why the build is failing for a dumb error message that shouldn't matter
08:32:22 <fizruk> ChaseTrains: (==) for lists compares two lists element-wise, but you need to know at compile-time that you can compare elements!
08:32:31 <michaelt> I mean, a dumb deprecation warning
08:32:37 <fizruk> ChaseTrains: but you can’t compare functions (for example)
08:32:50 <zq> bms1: for instance, ((Right True):(Left False):(Right False):rest)
08:32:56 <fizruk> ChaseTrains: so you can’t compare lists of functions
08:33:10 <ChaseTrains> hmm.. that'll probably make sense later. Thanks fizruk
08:33:18 <bms1> zq: oh. take a look at pattern synonyms there
08:33:18 <fizruk> ChaseTrains: so you can’t use fs == [], if fs is a list of functions
08:33:56 <fizruk> ChaseTrains: null on the other hand uses pattern matching, which does not put any constraints on list elements
08:34:02 <fizruk> @src null
08:34:02 <lambdabot> null []     = True
08:34:03 <lambdabot> null (_:_)  = False
08:34:17 <ChaseTrains> thanks
08:34:22 <michaelt> ChaseTrains: if you are writing something like "if null ls then ... else ..." then you can probably write if ls == [] and the like. It will just have a narrower inferred type
08:34:54 <geekosaur> except (null ls) avoids needing the Eq constraint
08:34:55 <bms1> zq: (also, those inner parens are unnecessary there)
08:35:15 <zq> bms1: they're not?
08:35:41 <bms1> zq: No, because function application binds more tightly than anything (including all infix operators such as ':')
08:35:53 <zq> :t let mech (Right 3, Left 4, Right 9):xs = xs; mech x:xs = x : mech xs in mech
08:35:54 <lambdabot> Parse error in pattern: mech
08:35:59 <bms1> It's the same on the left as it is on the right
08:35:59 <fizruk> ChaseTrains: also, pattern matching is preferrable (to multiple comparing function) in general because compiler can tell if you are not considering all possible cases
08:36:00 <michaelt> geekosaur: right, that's what fizruk was saying
08:36:20 <zq> :t let mech (Right 3:Left 4:Right 9:xs) = xs; mech (x:xs) = x : mech xs in mech
08:36:21 <lambdabot> (Num t1, Num t, Eq t1, Eq t) => [Either t t1] -> [Either t t1]
08:36:21 <bms1> zq: You still need the outer parens
08:36:24 <zq> sweet
08:36:33 <zq> bms1: didn't know, thanks!
08:36:51 <hyde> Not sure if this is the right place to complain about haskell platform for Windows, but I'll do it anyway:
08:36:54 <hyde> it added a bunch of folders to system PATH. Please don't do that... If you want to provide paths for command prompt, add a command prompt shortcut to the start menu, with those paths. For an example, see for example the command prompt shortcuts added by Qt SDK or MSVS. If you want to provide paths for GUI applications from environment, use a custom
08:36:54 <hyde> environment variable similar to JAVA_HOME.
08:37:00 <bms1> no problem! the associativity stuff works just like it would on the right hand side of a definition
08:39:42 <AshyIsMe> michaelt: it's successfully building, but when im trying to use mueval to evaluate some haskell strings is when im getting the error
08:40:07 <AshyIsMe> this is a bare system so ive just removed all cabal packages and am trying with just 0.3.0.0
08:40:24 <hamso> How does Real World Haskell differ *subjectively* from LYAH?
08:40:54 <michaelt> hamso: neither of them is a person.
08:41:36 <michaelt> AshyIsMe: I'm at a loss. Maybe you should raise an issue?
08:41:39 <hamso> michaelt: still, which one would you recommend to someone?
08:41:55 <fizruk> hamso: RWH is more real world and also is more like a reference to me, I’d recommend LYAH first
08:41:59 <michaelt> hamso: if you don't know any Haskell, LYAH I guess
08:43:36 <michaelt> hamso: also, because it's more 'real world' the actual text relies on definite libraries; so you bump into errors arising from new versions. They are all simple and can be explained here; but they might be a little dispiriting
08:43:54 <michaelt> hamso: That was a remark about RWH
08:44:14 <hamso> michaelt: ah, I see.
08:44:39 <hamso> I've already gone through half of LYAH before (a month or so ago).
08:44:45 <michaelt> The code samples are a little 'out of date' though in simple ways.
08:45:22 <Norfair> Hi
08:45:41 <michaelt> hamso: so you could try RWH, just don't panic about compiler errors with the samples, people will instantly know what to tell you on here.
08:46:33 <hamso> I'll just keep a tmux split open then!
08:47:00 <Norfair> Uhm, I'm not really sure how to start a conversation here, but I have a question regarding type definitions
08:47:23 <Clint> you start by asking your question and hoping that you don't get ignored
08:48:00 <Norfair> haha :D Well, I defined a Symbol as something for which there is an empty one defined, and (==) works on it
08:48:03 <Norfair> so
08:48:14 <Norfair> class Eq a => Symbol a where empty ::a
08:48:23 <Norfair> so far, so good, right?
08:48:35 * hackagebot make-package 1.2.0 - Make a cabalized package  http://hackage.haskell.org/package/make-package-1.2.0 (PhilippBalzarek)
08:49:05 <Norfair> Now, I want to define a Str(ing) as a list of symbols
08:49:13 <Norfair> but this doesn't do the trick:
08:49:20 <Norfair> type Symbol a => String a = [a]
08:49:24 <monochrom> michaelt: ghc 7.6 or older did not come with any transformers. we should have asked what ghc version.
08:49:29 <bms1> Norfair: you want to make a datatype, not a type class
08:49:41 <monochrom> however, "apt-get install ghc" cannot possibly give 7.8.
08:49:46 <bms1> "class" in Haskell is different from "class" in, say, Java
08:49:47 <michaelt> monochrom: yes, I meant to have done that somewhere in there.
08:50:07 <bms1> data Symbol = Empty
08:50:14 <bms1> type Str = [Symbol]
08:50:17 <michaelt> monochrom: ah. everything is coming together.
08:50:29 <Norfair> hmm, that's not exactly what I mean
08:50:34 <Norfair> you see, I go on to do this
08:50:54 <Norfair> instance Symbol Char where empty = 'ε'
08:51:24 <Norfair> but anything for which you define an empty form that can be compared with (==) should work
08:51:38 <bms1> oh okay
08:52:37 <michaelt> AshyIsMe: does ghc-pkg list transformers now show two versions? If so you should scrap 0.4 and put "constraint: transformers installed" in your HOME/.cabal/config
08:52:38 <bms1> Then the syntax is something like
08:52:46 <beanandgone> is there a LinkedHashMap (from Java) data structure in Haskell?
08:53:50 <bms1> Norfair: Well, you could do: data Str where MkStr :: Symbol a => [a] -> Str
08:54:03 <bennofs> beanandgone: I don't know Java, what is a LinkedHashMap?
08:54:12 <sagittarian|2> Norfair: you're doing something that's much harder than it looks, you can't have a [Symbol] because Symbol is a class, not a type
08:54:27 <michaelt> monochrom: yes, I was implicitly putting the transformers-ghc connection into the past
08:54:27 <beanandgone> it basically keeps order of insertion
08:54:36 <beanandgone> http://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html
08:55:40 <simpson> beanandgone: No, but you can make one yourself by doing what Java does and combining a list and a hashmap. (Or a list and map.)
08:55:44 <michaelt> AshyIsMe:  If the warnings are about Control.Monad.Error they are coming from transformers-0.4 which you shouldn't have. I think that's a right account of everything we know so far.
08:56:11 <beanandgone> simpson: ok, thanks
08:57:34 <joe9> Is there a getZonedTime that I can pass the timezone as a parameter?
09:00:54 <ChaseTrains> why "repeat 5" instead of "cycle [5]"?
09:01:55 <michaelt> > take 100 (repeat 5) == take 100 (cycle [5])
09:01:58 <lambdabot>  True
09:02:22 <ChaseTrains> dafuq do we need repeat 4 dawg?
09:03:16 <michaelt> ChaseTrains: because you dont know in advance how many 4's you'll need, for example?
09:04:01 <ChaseTrains> yeah, but mah niggah, ya'll can use cycle [4] instead of repeat 4. It's redundant, now isn't it?
09:04:05 <monochrom> "repeat 4 dawg" is a type error, I'm afraid.
09:04:27 <monochrom> please do not say "niggah". next time it'll be a ban.
09:04:55 <hamso> Sense prevails on this channel, I see. Good.
09:05:07 <michaelt> ChaseTrains: for example if I have a list of lines of various lengths, but want I might add an infinite list of empty spaces to each of them, then crop them all at 50 characters; then I know everything has 50 chars and can use e.g. transpose or whatever
09:05:17 <ChaseTrains> monochrom: cat
09:05:36 <michaelt> yipe.
09:06:10 <rudi_s> I have a general "display" method which displays the current state of my program (a -> IO ()). Now I want to use it UI.NCurses, but that uses Curses () (which embeds IO ()). Can I somehow pass the Curses as IO so the signature of my display methods doesn't have to change?
09:06:33 <ChaseTrains> michaelt: I mean, that "repeat 5" is redundant when there is "cycle [5]"
09:06:55 <michaelt> ChaseTrains: if that's a problem, you'll have nothing but problems with Haskell
09:07:37 <simpson> ChaseTrains: Haskell is not a "there should be one, and preferably only one, way to do it" language.
09:08:04 <michaelt> ChaseTrains: in any case, I think that the compiler will find 'repeat x' easier to manipulate and crush.
09:08:22 <michaelt> ChaseTrains: can't say I'm sure though
09:09:36 <ChaseTrains> kk
09:09:49 <ChaseTrains> is it possible to write quake 3 in haskell?
09:10:00 <simpson> Sure.
09:11:30 <joof> I think carmack was doing that a while back
09:11:41 <joof> or at least one of the quakes / doom series
09:12:23 <joof> I've been learning FRP which should be good for games
09:12:42 <joof> and you can bind to openGL pretty easily
09:13:25 <simpson> Just like in any other language, you can write a stateful loop that updates game state based on incoming events and renders stuff to the screen.
09:13:37 * hackagebot tersmu 0.2 - A semantic parser for lojban  http://hackage.haskell.org/package/tersmu-0.2 (mbays)
09:13:43 <Hodapp> joof: what FRP framework (if any) are you working with?
09:14:18 <joof> Hodapp: yampa
09:14:21 <Hodapp> alrighty
09:14:31 <joof> I'm not well versed in any of them yet
09:14:34 <catern> argh
09:14:36 <Hodapp> I was looking at that one a year or two ago but had to cut that project short for some reason I forget
09:14:58 <catern> is there some quick and dirty solution I can use to just get the equivalent of "cabal install hakyll" to work
09:15:03 <catern> I just want to update my blog :(
09:15:25 <catern> I tried using http://www.stackage.org/ but it fails too
09:15:26 <joof> sandbox init; cabal install hakyll
09:15:32 <joof> :P
09:15:33 <catern> also failed
09:16:03 <catern> should I talk in more detail about the failure of any of these?
09:16:08 <joof> yes
09:16:31 <catern> which one, I mean?
09:16:40 <catern> they all failed in different ways
09:16:50 <catern> currently I'm on stackage, I guess
09:16:56 <monochrom> catern, what failure did you get? is it simply that hackage is unresponsive?
09:16:59 <catern> It's saying
09:17:02 <catern>     Could not find module ‘GHC.IOBase’
09:17:03 <catern>     Perhaps you meant GHC.Base (from base)
09:17:11 <catern> also,     Could not find module ‘Control.OldException’
09:17:12 <catern>     Perhaps you meant Control.Exception (from base)
09:17:40 <catern> monochrom: no, the builds are failing for various reasons
09:17:41 <joof> just to keep from anything silly... cabal update?
09:18:06 <catern> cabal update && cabal install hakyll gives same output
09:18:20 <catern> oh, i should mention that this failure is happening while installing strict-concurrency
09:19:03 <Clint> catern: it sounds like you're running an ancient version of ghc
09:19:29 <catern> ghc --version tells me 7.8.3
09:19:43 <mauke> it sounds like you're running a too modern version of ghc
09:19:59 <catern> aw
09:20:02 <joof> lol
09:20:10 <catern> (I'm on Arch if it's helpful)
09:20:10 <mauke> one that doesn't have OldException anymore
09:20:24 <simpson> catern: That'd be your problem.
09:21:37 <DarkCthulhu> In this type I created, at http://pastebin.com/2fdFnPHH , I am able to write "Simple True" and "Simple False". How do I use the Select constructor?
09:21:43 <monochrom> perhaps hakyll is a bit old
09:21:44 <catern> but, but, I am using stackage with http://www.stackage.org/stackage/f6eedcd9c26db5e9006e0a4321b268e09cf366fe and it says 7.8
09:22:12 <catern> or I guess all the packages weren't updated?
09:22:28 <catern> anyway, I guess the way to fix stuff if I continue on this path is to downgrade my ghc?
09:22:39 <monochrom> DarkCthulhu, an example is Select (Simple True) (Simple False). there are more varieties.
09:23:17 <catern> which, well, I don't really want to do
09:23:46 <joof> yeah I've been really considering switching to nixos from arch
09:23:49 <monochrom> you could edit hakyll for today's ghc, or hire someone to do it.
09:23:58 <joof> I feel like you should be able to get it going somehow though
09:24:04 <catern> should I retry with Hackage (so I can see what the error was - I didn't note it down) or should I downgrade my ghc?
09:24:24 <DarkCthulhu> monochrom, Ah.. the type needs to be applied that way? I can't simply do Select True False?
09:24:43 <monochrom> right.
09:24:44 <Clint> catern: you should ask jaspervdj to get hakyll into stackage
09:25:09 <catern> jaspervdj: please get hakyll into stackage :)
09:25:24 <DarkCthulhu> monochrom, I understand, but doesn't (something something) evaluate as a function with the second thing being an argument usually?
09:25:49 <jacereda> hi, newbie here...
09:25:56 <DarkCthulhu> monochrom, Ohh.. is it because it starts with a capital letter, that it is a type and hence that isn't the case?
09:26:19 <jacereda> I'm trying to figure out what's wrong with this definition (and wondering if there's a better way)
09:26:42 <jacereda> instance Show Clock where
09:26:42 <jacereda>     show c = toString $ unsafePerformIO $ showClock c
09:26:42 <jacereda>         where showClock :: Clock -> IO JSString
09:26:42 <jacereda>               showClock c = ffi "(function(c){return ''+c;})"
09:27:18 <monochrom> Select's type is G -> G -> G. its two parameters have to have type G, not Bool.
09:27:46 <jacereda> also, wondering what's the best way to share code :-)
09:27:55 <DarkCthulhu> monochrom, Right. Got it. ty :)
09:28:02 <monochrom> post on lpaste.net
09:29:07 <monochrom> unsafePermIO is very wrong to begin with. but I suppose you don't want to talk about it.
09:29:12 <jacereda> Got it... http://lpaste.net/111718#a111718
09:29:45 <monochrom> but I don't know anything about Clock, JSString, or ffi.
09:31:30 <jacereda> ok, I don't have any special attachment to unsafePerformIO :-) What would be the idiomatic way to make something an instance of Show when interfacing to Javascript? (I'm using Haste if that matters)
09:35:15 <Forgetaboutit> how do I describe a fixed number of expressions in Parsec?
09:35:29 <Forgetaboutit> many1 expr is too greedy
09:35:41 <Forgetaboutit> * `many1 expr`
09:37:16 <Forgetaboutit> nevermind, I missed `count`
09:37:17 <mauke> what do you mean, too greedy?
09:37:26 <bergey> What's your clock type like?  Is it some sort of Date / Time type, or is it always about the current time?
09:37:38 <Forgetaboutit> mauke: my `many1 expr` tries to match too much
09:37:58 <Forgetaboutit> mauke: I only want to parse a fixed number of occurences
09:38:09 <bergey>  I think it's fine to use unsafePerformIO with the ffi if the expression is actually referentially transparent:
09:38:43 <jacereda> It's a current time class...
09:39:24 <bergey> f str = unsafePerformIO $ ffi "someJSFunction $str"  :: String -> String
09:39:44 <bergey> Then I would expect the proper Haskell type to include IO.
09:40:08 <bergey> currentTime = ffi "Date.now()" :: IO JSDate
09:40:22 <DarkCthulhu> monochrom, Is there some way to avoid typing (Simple True) and (Simple False) every time?
09:41:07 <DarkCthulhu> monochrom, Like some way to "assign" type Simple to True and remember it.
09:41:27 <bergey> And if you need a Show instance, maybe it's just the trivial `show _ = "<Clock>"`.  Although it's nicer if Show instances are always valid Haskell, which is hard when the FFI is involved.
09:42:09 <monochrom> you can define "my_true = Simple True" and "my_false = Simple False". you can choose shorter names for them.
09:42:48 <DarkCthulhu> monochrom, ah.. how is it that such an assignment works?
09:43:27 <monochrom> it works the same as all definitions.
09:43:38 <jacereda> bergey, I really need to show the JS string at least... how would you turn an IO JSAny into a plain String to implement Show?
09:44:07 <DarkCthulhu> monochrom, It gives me <interactive>:92:9: parse error on input `='
09:44:44 <monochrom> put them in the same file you put your "data G = ..." declaration. reload.
09:45:00 <bergey> jacereda: Do you understand the problem with unsafePerformIO, or should I try to explain it?
09:45:47 <DarkCthulhu> monochrom, ah.. that works. But why doesn't it work in interactive?
09:45:56 <monochrom> bergey, interestingly, the only significance of unsafePerformIO in this case is to ask javascript to do the show for you. it's one of those acceptable cases.
09:46:31 <monochrom> if you absolutely want to write a definition in interactive, "let my_true = Simple True".
09:47:01 <arryl> [x ++ y| x <- ['a','b'], y <- ['1','2','3']]  .....  why is that wrong?
09:47:08 <monochrom> but I don't understand why anyone would do it. the next :load or :reload will lose it.
09:47:30 <shiona> arryl: you are trying to use ++ on chars, you need lists (eg. strings)
09:47:34 <monochrom> arryl, because 'a'++'1' is wrong
09:47:34 <tabemann> arryl: (++) concatenates *lists* - x and y are not lists
09:47:48 <DarkCthulhu> monochrom, I see your point. I'm just wondering about why it requires a let on interactive and doesn't within the module.
09:47:52 <bergey> monochrom: Perhaps I misunderstood the Clock type.  If the string isn't about the current time when `show` is called, then fine.
09:48:05 <arryl> oh kay
09:48:06 <jacereda> bergey, please do... my guess is that it could lead to unsafe code due to 'undefined's and so, but maybe I'm wrong
09:48:07 <arryl> thanx
09:48:29 <monochrom> it seems to be convenience for whoever wrote the parser for interactive, DarkCthulhu.
09:48:49 <jacereda> I have a function newClock :: IO Clock
09:48:56 <jacereda> so I do clk <- newClock
09:49:08 <DarkCthulhu> monochrom, Hmm.. okay. ty
09:49:08 <jacereda> and I just want to do an 'alert $ show clk'
09:49:26 <jacereda> I don't want to print the clock value
09:49:37 <jacereda> just want to know if it's properly instantiated
09:50:53 <BMeph> DarkCthulhu: The interactive session is "automagically" considered to be (IO a), so it's treated as if it's in a "virtual" do-expression.
09:51:08 <avaritia> hey assuming that i'm writing a chess engine, what's the best way to represent a chessboard in haskell?
09:51:14 <bergey> I have to go; maybe monochrom can answer.
09:51:19 <DarkCthulhu> BMeph, Ohhh.. that makes sense!
09:51:25 <jacereda> bergey, thanks
09:51:26 <avaritia> the only one that comes to my mind is mutable vector
09:51:39 <avaritia> which is not as pure as i'd want it to
09:51:48 <arboris> jacereda, you just need a Show instance for Clock
09:51:51 <DarkCthulhu> BMeph, The interactive prompt is an "imperative"-ish place to work?
09:52:11 <jacereda> arboris, yes, that's what I'm trying to implement
09:52:24 <jacereda> http://lpaste.net/111718#a111718
09:52:33 <BMeph> DarkCthulhu: FSVO "imperative," sure, let's go with that. ;)
09:52:51 <vanila> jacereda, why does it use unsafePerformIO?
09:53:13 <DarkCthulhu> BMeph, :) ty
09:54:32 <arboris> jacereda, this seems really strange, how is Clock represented>
09:54:39 <arboris> is it an opaque type?
09:55:11 <jacereda> Here is the full thing: http://lpaste.net/111721
09:55:32 <tabemann> the copying expense of using a two-dimensional array shouldn't be *that* bad, and while you could do a HashMap from (x, y) to a given piece, and that would be less copying expense because you wouldn't be copying the entire board on each operation, the total amount of space taken up by a single board, before you take into account sharing betwen boards, would be greater
09:55:40 <jacereda> I don't even know if newtype is the right thing here
09:55:53 <sagittarian|2> avaritia: data Chessboard = Pos1 | Pos2 | Pos3 -- etc
09:56:52 <avaritia> sagittarian|2: infinite adt containing all possble chessboard positions? ;)
09:57:10 <sagittarian|2> it's not infinite
09:57:15 <vanila> jacereda, something like this maybe? http://lpaste.net/111721 - this may not work exactly as written by hopefully the idea gets across
09:57:55 <arboris> jacereda: hm this is sort of broken, if you want to use a newtype you should declare it as newtype Clock = Clock { unClock :: JsAny }
09:58:26 <arboris> if you then have an instance of Show for JsAny things would look better
09:58:39 <arboris> there is no need for unsafePerformIO
09:58:40 <arboris> at all
09:58:49 <vanila> How do you do it without?
10:00:01 <jacereda> arboris, but would that instantiate a string even when I remove my debugging code calling show, right?
10:01:30 <arboris> if it is just for debugging you might aswell just declare an instance that displays "<clock>" or something like that
10:02:24 <jacereda> arboris, I want to see the Javascript representation, "<clock>" won't give me much information
10:02:50 <arboris> jacereda, but the javascript representation is not immutable
10:05:35 <arboris> you could also write a function Clock -> IO String, that displays the current state of the clock
10:05:42 <arboris> and not create an instance of show
10:05:48 <arboris> if you then want to debug
10:05:52 <arboris> just use trace
10:06:20 <jacereda> arboris, ok, I'm starting to see the light... so show isn't always the answer when dealing with bindings to external JS code...
10:06:59 <arboris> jacereda, the function Clock -> IO String could be basically what you used in your instance of Show, just without unsafePerformIO
10:07:25 <arboris> the type also reflects better the fact that a Clock changes in time.
10:07:37 <jacereda> arboris, got it, thanks!
10:07:39 <arboris> at least sort of
10:07:53 <avaritia> sagittarian|2: but it contains a lot of positions doesnt it? or do i misunderstand something?
10:08:00 <arboris> for debugging you can always use trace, as your escape hatch
10:08:11 <arboris> not unsafePerformIO directly
10:08:13 <sagittarian|2> avaritia: depends on what you consider a lot
10:08:44 <avaritia> sagittarian|2: something of order 2^30?
10:08:53 <tabemann> it's rather impractical to have an ADT that contains every chess position
10:10:05 <avaritia> tabemann: what would you suggest then? preferably avoiding O(n) board modification and a monad
10:10:59 <sagittarian|2> ye of little faith
10:11:22 <sagittarian|2> avaritia: avoiding a monad?
10:11:32 <tabemann> avaritia: you could always use a HashMap from (x, y) to your pieces
10:11:46 <tabemann> then when you make a modification you aren't copying your entire board
10:13:36 <avaritia> tabemann: but then still its around O(logn) ?
10:13:41 * hackagebot persistent-postgresql 1.3.1.3 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-1.3.1.3 (MichaelSnoyman)
10:14:48 <avaritia> sagittarian|2: well if i go with vector monad i can just simply code the entire thing in C++
10:15:08 <tabemann> do you really need O(1)? and mind you that chess boards aren't that big, so 64 is not a very big n
10:15:13 <sagittarian|2> sounds like a plan
10:15:44 <monochrom> you have at most 32 chess pieces. this means n <= 32. O(log n) <= O(log 32).
10:16:38 <sagittarian|2> > log 32 / log 2
10:16:40 <lambdabot>  5.0
10:16:47 <avaritia> tabemann: yes but the problem i'm having is the fact that minmax is quite computationally heavy hmm
10:16:58 <copumpkin> > logBase 2 32
10:17:00 <lambdabot>  5.0
10:17:20 <avaritia> tabemann: so i'm landing with something 5x slower , which means that it might be 5x weaker as well
10:17:33 <copumpkin> o.O
10:17:53 <avaritia> well i consider 1/5th of positions in the same time?
10:18:00 <copumpkin> that's only if your piece lookup is your prime source of computation
10:18:25 <monochrom> I do not agree that an immutable HashMap is 5 times slower than mutable array.
10:18:39 <monochrom> you will backtrack. you will backtrack all the time. no?
10:18:44 <avaritia> yes
10:19:00 <monochrom> backtracking means that you have to copy all mutable data all the time.
10:19:21 <avaritia> valid argument
10:19:33 <bennofs> monochrom: or do make move / unmake move
10:19:44 <copumpkin> then you have to keep track of the make/unmake data
10:19:48 <copumpkin> which you then need to apply
10:20:01 <copumpkin> which costs time (and space)
10:20:24 <Enigmagic> if only there were a better way ;-)
10:20:29 <copumpkin> yeah!
10:20:31 <copumpkin> >_>
10:21:05 <avaritia> but in case of map solution i also have to remove (x,y) from map, and add new (x,y) representing new piece position hmm
10:21:09 <monochrom> in theory, undo is faster than full copy. in practice, undo is error-prone, you will have bugs, so you can't brag about speed any more. "if it doesn't have to be correct, I know how to do it 1000x faster."
10:21:37 <carter> is albert online? :)
10:22:01 <monochrom> albert = monochrom
10:22:18 <carter> monochrom: i'll remember eventually!
10:22:27 <carter> monochrom: the short answer is triangle inequality
10:22:38 <tabemann> you're probably better off just using the HashMaps rather than either full-copying your mutable datastructures or having to maintain undo data
10:22:57 <carter> monochrom: (i can elaborate more)
10:23:05 <carter> just wanted to move that chatter off cafe
10:23:11 <monochrom> I think I want the long answer, yeah.
10:23:13 <carter> ok
10:23:15 <carter> so
10:23:29 <carter> hrmm
10:23:30 <jmcarthur> wait, so the long answer goes to irc instead of email? :P
10:23:34 <carter> jmcarthur: yes,
10:23:45 <carter> to prevent that thread from zombieing
10:23:46 <jmcarthur> seems backwards
10:23:49 <avaritia> tabemann: true
10:24:01 <carter> i want people to stop saying "but floats aren' behaving how i expect"
10:24:12 <carter> on that thread
10:24:22 <monochrom> I disagree with those people, too.
10:24:30 <carter> the way they "expect"
10:24:41 <CindyLinz> no expect.. XD
10:24:41 <carter> will result in games and graphics and physics and everything
10:24:47 <carter> taking 10-1000x longer
10:24:50 <carter> to do the same amount of work
10:25:08 <carter> jmcarthur: i feel like the float haters would get very angry if they knew what people do in game dev :)
10:25:34 <carter> monochrom: i need to load the thinking back in
10:25:50 <carter> right now i'm trying to focus on writing a bound based version of the ghc core ast
10:25:57 <carter> monochrom: gimme 5 min :)
10:26:11 <monochrom> I accept floating point for what it is and even am grateful for it. I am curious about a weaker notion of transitive relation.
10:26:48 <carter> so lets consider equality to be defined as
10:26:52 <monochrom> I am also grateful for its Num, Ord, Eq instances. I have seen OCaml and not going back.
10:27:06 <carter> a \in Nbr(radius,b) ===  "a == b"
10:27:20 <carter> that is
10:27:48 <carter> a ==_r b :=   if dist a b <= r then True else False
10:27:55 <carter> with me so far?
10:28:20 <carter> standard "corner case handling" float Eq sets r=0
10:28:22 <monochrom> tautologically, float haters hate all those who use float successfully. this includes not just game devs, but also scientists.
10:28:33 <carter> with me so far?
10:28:43 <monochrom> yes
10:28:57 <carter> so i could say a weaker notion of transitivitity
10:29:00 <carter> could be for example
10:29:24 <benneh> is there a difference between "fix f = f (fix f)" and "fix f = x where x = f x"?
10:29:43 <jmcarthur> i appreciate floating point, but do wish that i could write polymorphic code that relies on laws. the ability to use my code with instances that don't satisfy the laws (which admittedly are only my expectation and not actually in the spec or docs) annoys me. that the standard library includes such instances annoys me more.
10:29:50 <monochrom> with lazy evaluation, "x where x = f x" saves memory
10:30:01 <carter> a ==_(r1) b && b ==_(r2) c  implies   a ==_(r1+r2) c
10:30:07 <jmcarthur> i think there's some tension here, and it shouldn't be brushed off as "floating point hate"
10:30:08 <carter> which is really just the triangle inequality
10:30:09 <monochrom> err, maybe not. reuses memory and saves re-computing.
10:30:14 <carter> jmcarthur: yeah
10:30:27 <carter> but the laws of float are not the laws of rational / exact number reps
10:30:33 <benmachine> jmcarthur: that's roughly the angle I take on it, too. I've no problem with floating point existing, but I do have a problem with it promising things it can't deliver
10:30:37 <jmcarthur> yes, hence the objections
10:30:38 <benmachine> can't or doesn't want to
10:31:01 <carter> monochrom: see what i mean about triangle inequality being a weaker version of transitivity?
10:31:09 <monochrom> ah, you want to use a different radius
10:31:20 <carter> you can of course define something stronger
10:31:29 <carter> or weaker
10:31:50 <monochrom> hrm. this is a very dependent relation! (as in dependent types)
10:31:55 <jmcarthur> anyway, that's my say, and now i leave
10:32:06 <carter> monochrom: eg, if you could do   a ==_(r1) b && b ==_(r2) c  implies   a ==_(max(r1,r2)) c
10:32:13 <carter> it'd behave more teh way you expect
10:32:18 <carter> and theres stuff where thats the case
10:32:32 <carter> norm(a+b) <= max(norm a, norm b)
10:32:49 <carter> monochrom: this goes back to my point about floating point laws being geometrical
10:33:42 <carter> monochrom: i hope this shows that well :)
10:33:53 <carter> if yiou wanna try to expand/expound on that, go crazy :)
10:33:58 <carter> i'm tryig to do other things
10:34:11 <monochrom> I have not thought of changing the radius.
10:34:47 <carter> granted, you dont always want to have this weak a notion
10:34:59 <carter> but its one that works here
10:35:12 <carter> you can conside  f-transitivity
10:35:27 <carter> that relates the composite distance bound to the constituent parts
10:35:36 <carter> and have the sum and max versions be those
10:36:00 <monochrom> I understand now. it's interesting. thank you.
10:36:22 <carter> np
10:36:30 <carter> monochrom: should i reshare that on cafe I guess
10:36:31 <carter> ?
10:36:35 <carter> i like thinking things out by tlaking :)
10:36:42 <monochrom> I don't know. it's up to you.
10:45:57 <DarkCthulhu> http://pastebin.com/v2CH45hp Why doesn't this data definition work?
10:46:20 <vanila> DarkCthulhu, you're not allowed to  use the name 0, try O instead?
10:46:21 <vanila> or Zero
10:46:27 <monochrom> you can't use a digit for a constructor name
10:46:47 <DarkCthulhu> http://learnyouahaskell.com/making-our-own-types-and-typeclasses
10:46:57 <DarkCthulhu> In here, data Int = 0 | 1 | ... was defined
10:47:01 <DarkCthulhu> I thought that was valid
10:47:06 <monochrom> no, that's pseudocode.
10:47:14 <DarkCthulhu> ah
10:47:24 <mauke> "we can think of the Int type as being defined like this"
10:47:33 <mauke> "It's not actually defined like this"
10:48:40 <DarkCthulhu> ahh.. I see
10:48:44 <bennofs> Also, Int can represent negative numbers too
10:51:18 <DarkCthulhu> How does one compose data definitions? If for example, I have that type G from http://pastebin.com/v2CH45hp
10:51:35 <DarkCthulhu> Oh wait.. nvm
10:54:47 <tuusj> probably a newbie question, but I can't seem to figure out what is happening, when I enter let a = 1:2 in Ghci, it gives me type (Num [a], Num a) => [a]. If I write this in a file, then load it in ghci, it does not compile. I was wondering if there are some language extensions at play here?
10:56:10 <benzrf> tuusj:
10:56:11 <benzrf> :t (:)
10:56:12 <lambdabot> a -> [a] -> [a]
10:56:18 <geekosaur> could be, but `let a = ...` without an `in` is specific to do expressions, not valid at the top level of a compiled file
10:56:29 <benzrf> tuusj: numeric literals are polymorphic to anything with a Num instance
10:56:30 <geekosaur> ghci sort of pretends to be the inside of a "do"
10:56:49 <geekosaur> so, for one you have a syntax error if you put `let a = 1:2` directly.
10:57:17 <alrunner4> it's not a syntax error
10:57:20 <sinelaw> this is kinda surprising
10:57:27 <sinelaw> it's not a syntax error, it's a type error
10:57:33 <geekosaur> I think if you have just `a = 1:2` in a source file, so that it is syntactically correct, then you get the same weird type that ghci gives you
10:57:51 <geekosaur> ...wat
10:58:05 <sinelaw> ghci is being strange ehere
10:58:07 <sinelaw> *here
10:58:08 <tuusj> benzrf: so the answer is that the int is working as both a list and a number
10:58:26 <benzrf> tuusj: no
10:58:29 <sinelaw> maybe because it doesn't evaluate let expressions until you use them?
10:58:32 <benzrf> the 1 has type a and the 2 has type [a]
10:58:51 <benzrf> :t (:)
10:58:53 <lambdabot> a -> [a] -> [a]
10:59:04 <geekosaur> the type it infers makes sense
10:59:06 <benzrf> the 1 and the 2 have different types here :u
10:59:15 <geekosaur> remember, a numeric literal gets fromInteger wrapped around it
10:59:45 <geekosaur> so 2 is required to be a list by (:), and is (fromInteger (2::Integer)) per the Haskell Report
10:59:57 <geekosaur> where fromInteger :: Num a => Integer -> a
11:00:12 <geekosaur> so you get a strange inferred type
11:00:48 <geekosaur> but, *by itself*, it is not obviously wrong; some people do define lists as Num instances, in which case it would be a perfectly acceptable expression
11:01:16 <MagneticDuck> uhm. I think I don't quite understand exceptions
11:01:34 <geekosaur> (remember that typeclasses are open world. it's valid until someone uses it in a way that can't be satisfied with the instances currently in scope, not invalid at definition because the instances needed aren't in scope)
11:01:42 <MagneticDuck> handle (const (return False) . (id :: SomeException -> SomeException))
11:01:47 <MagneticDuck> ^ is there a neater way of writing that?
11:02:02 <tuusj> so then the question is how the 2 can act as a list?
11:02:18 <benzrf> tuusj: if theres an instance.
11:02:20 <sinelaw> @pl const (return False) . (id :: SomeException -> SomeException)
11:02:20 <lambdabot> (line 1, column 47):
11:02:20 <lambdabot> unexpected '>'
11:02:20 <lambdabot> expecting operator
11:02:25 <benzrf> tuusj: look:
11:02:30 <sinelaw> @pl const (return False) . id
11:02:30 <lambdabot> const (return False)
11:02:31 <geekosaur> because you wrote 2 but the language definition requires it to be read as fromInteger (2::Integer)
11:02:31 <mauke> :t handle (\SomeException{} -> return False)
11:02:33 <lambdabot> IO Bool -> IO Bool
11:02:47 <sivteck> > let 30 = 21 in 34
11:02:49 <lambdabot>  34
11:02:51 <sinelaw> duh.
11:02:52 <benzrf> @let class Pointed a where point :: a -- tuusj
11:02:54 <lambdabot>  Defined.
11:03:03 <geekosaur> so, if you can find a Num instance for lists somewhere, fromInteger (2::Integer) can validly produce a list
11:03:05 <MagneticDuck> sinelaw: you apparently don't understand Exceptions
11:03:09 <benzrf> @let instance Pointed Int where point = 0 -- tuusj
11:03:11 <lambdabot>  Defined.
11:03:37 <MagneticDuck> sinelaw: "No instance for "Exception e0" arising from a use of 'handle'[...]
11:03:37 <bennofs> :t handling_ _SomeException (return False)
11:03:39 <lambdabot>     Ambiguous occurrence ‘handling_’
11:03:39 <lambdabot>     It could refer to either ‘Control.Exception.Lens.handling_’,
11:03:39 <lambdabot>                              imported from ‘Control.Exception.Lens’ at /home/lambda/.lambdabot/State/L.hs:46:1-29
11:03:40 <benzrf> @let instance Pointed a => Num [a] where (+) = (++); fromInteger n = replicate n point
11:03:41 <lambdabot>  .L.hs:164:35:
11:03:41 <lambdabot>      Couldn't match expected type ‘Int’ with actual type ‘Integer’
11:03:41 <lambdabot>      In the first argument of ‘replicate’, namely ‘n’
11:03:43 <lambdabot>      In the expression: replicate n point
11:03:50 <benzrf> oops
11:03:53 <bennofs> :t Control.Exception.Lens.handling_ _SomeException (return False)
11:03:54 <lambdabot>     Found hole ‘_SomeException’
11:03:55 <lambdabot>       with type: Getting (First a0) SomeException a0
11:03:55 <lambdabot>     Where: ‘a0’ is an ambiguous type variable
11:03:56 <benzrf> @let instance Pointed a => Num [a] where (+) = (++); fromInteger n = replicate (fromInteger n) point
11:03:57 <lambdabot>  .L.hs:162:10: Warning:
11:03:57 <lambdabot>      No explicit implementation for
11:03:57 <lambdabot>        ‘*’, ‘abs’, ‘signum’, and (either ‘negate’ or ‘-’)
11:03:58 <lambdabot>      In the instance declaration for ‘Num [a]’
11:04:00 <lambdabot>  
11:04:01 <mauke> benzrf: STOP
11:04:05 <MagneticDuck> mauke: wasn't aware of the SomeException constructor
11:04:06 <benzrf> > [1, 2, 3] + [4]
11:04:08 <benzrf> mauke: :{
11:04:09 <lambdabot>  No instance for (GHC.Show.Show t0)
11:04:10 <geekosaur> and yes, this may not make direct sense to you. neither do some other kinds of actually-useful numbers, such as quaternions
11:04:11 <lambdabot>    arising from a use of ‘M17619228243700521586485.show_M17619228243700521586...
11:04:13 <lambdabot>  The type variable ‘t0’ is ambiguous
11:04:14 <lambdabot>  Note: there are several potential instances:
11:04:16 <lambdabot>    instance [safe] GHC.Show.Show
11:04:39 <geekosaur> which are weird as all get-out to people familiar only with integers and reals
11:06:50 <DarkCthulhu> http://pastebin.com/cCYDzB4v
11:07:08 <DarkCthulhu> WHy can't I do Select (Simple True) (Simple False) anymore?
11:07:27 <DarkCthulhu> Couldn't match expected type `G' with actual type `V' it tells me.
11:07:30 <monochrom> the two V's are different.
11:07:31 <vanila> use Select V V
11:07:46 <vanila> oh sory ignore that
11:08:00 <mauke> DarkCthulhu: because Select takes a value of type G, but Simple True has type V
11:08:17 <DarkCthulhu> But isn't type V one of the values G could have?
11:08:21 <lnostdal> hi guys, i'm looking for a simple (bare bone) http server for haskell ..     i came across mighttpd, but it seems to be a standalone reverse proxy instead of a http server library (??) .....    yesod is so big and confusing it even has its own <create new yesod project skeleton> tools to deal with it all (wai, warp, mighty, ....bah)  ..     i just want to call a simple library function "startServer 8080 myHandler" (or something...) from
11:08:21 <lnostdal> my haskell code   ...it seems everything wants to be entire platforms, instead of just small libraries x)
11:08:26 <mauke> DarkCthulhu: no
11:08:39 <bennofs> lnostdal: maybe warp?
11:08:40 <mauke> DarkCthulhu: the V in G is a *data* constructor, unrelated to the type V
11:08:45 <bennofs> @hackage warp
11:08:45 <lambdabot> http://hackage.haskell.org/package/warp
11:09:12 <bennofs> also see
11:09:16 <bennofs> @hackage wai
11:09:16 <lambdabot> http://hackage.haskell.org/package/wai
11:09:26 <lnostdal> bennofs: yes, but what _is_ warp? .. it is mentioned many places, and seems to have many names ..    the official "warp" (??) hasn't seen a update since 2011
11:09:44 <DarkCthulhu> mauke, ohhhh.. How would I make it work and take the type?
11:09:46 <bennofs> lnostdal: look at those two links
11:09:55 <mauke> DarkCthulhu: Select V V
11:10:30 <sinelaw> lnostdal, try snap
11:10:32 <lnostdal> bennofs: yes, wai seems close to what i'm looking for
11:10:47 <DarkCthulhu> mauke, Then it would prevent me from composing "Select"s right?
11:10:48 <bennofs> lnostdal: you'd use wai with warp as backend
11:10:53 <mauke> DarkCthulhu: yes
11:11:12 <DarkCthulhu> mauke, But I want that behavior, which lets me compose multiple G's.
11:11:29 <mauke> DarkCthulhu: you could also do data G = V V | Select G G
11:11:46 <mauke> then Select (V (Simple True)) (V Zero) is valid
11:11:52 <mauke> and maybe rename one of the Vs
11:11:56 <lnostdal> *shrug*
11:12:34 <lnostdal> look at this: http://nodejs.org/   "an example: webserver"
11:12:46 <DarkCthulhu> mauke, I would need to explicitly do (V (Simple True)) then? Is there some way to keep that definition and make "Select (Simple True) (Simple False)" work?
11:13:00 <DarkCthulhu> Why doesn't it infer that type
11:13:22 <mauke> DarkCthulhu: data G = Simple Bool | Zero | Select G G
11:13:31 <mauke> what do you mean by infer?
11:13:37 <catern> I can compile my hakyll site.hs just fine, but running ./site build gives me
11:13:38 <catern> site: Prelude.chr: bad argument: 3453056
11:13:50 <catern> i pray that this has an easy fix
11:13:50 <mauke> > chr 3453056
11:13:52 <lambdabot>  *Exception: Prelude.chr: bad argument: 3453056
11:13:55 <mauke> nice
11:14:02 <vanila> lnostdal, you could look through http://hackage.haskell.org/packages/search?terms=http+server
11:14:05 <mauke> > ord maxBound
11:14:07 <lambdabot>  1114111
11:14:09 <catern> mauke: hm?
11:14:13 <vanila> lnostdal, it's just there's so much garbage on hackage these days, it's really hard to find the good libs
11:14:19 <lnostdal> actually, this looks close: https://github.com/yesodweb/wai/tree/master/wai
11:14:24 <lnostdal> vanila: yes! ..so much mess x)
11:14:31 <vanila> this looks okay http://hackage.haskell.org/package/tighttp
11:14:37 <bennofs> lnostdal: also, scotty
11:14:43 <bennofs> @hackage scotty
11:14:44 <lambdabot> http://hackage.haskell.org/package/scotty
11:14:59 <athan> is `quickCheck` supposed to generate only one test case? Or do I have to supply some magic arguments to `quickCheckWith`?
11:15:13 <DarkCthulhu> mauke, I see. If I do split it into multiple data definitions, I must explicitly do something like "(V (Simple True))" when passing in right? The right thing would be to keep it in one single data definition?
11:16:14 <mauke> DarkCthulhu: depends on what you're trying to do
11:16:20 <rudi_s> Hi. What's a clean way to abort the program if there's an exception in any thread. E.g. thread 3 tries to open a file and fails, I'd like to notice this and terminate the program. Thanks.
11:18:04 <mauke> rudi_s: forkIOFail m = forkIO (m `onException` exitFailure) and use that instead of forkIO?
11:18:21 <DarkCthulhu> mauke, Got it.. ty :)
11:19:10 <lnostdal> ok, some of these look nice ..thanks :)
11:19:28 <DarkCthulhu> mauke, On another note, is it possible to just alias a type? Just to separate out the definitions. What I want to say is something like this: Select G G, where G could be the type V, or something else.
11:19:47 <rudi_s> mauke: I haven't tried that, but exitFailure in another thread doesn't seem to have any effect on the program here.
11:19:51 <mauke> I don't understand the second half but aliases can be done with 'type'
11:19:58 <mauke> such as type String = [Char]
11:20:03 <mauke> rudi_s: :-(
11:20:44 <mauke> rudi_s: you could be naughty and use exitImmediately 127 :-)
11:20:47 <rudi_s> The thread stops, but all other continue to run.
11:20:59 <DarkCthulhu> mauke, Ah.. I'm asking in the context of http://pastebin.com/buYdcw1G . I don't want a new constructor V for type V within G. I want to say that they could actually be equivalent. Is that possible?
11:21:17 <vanila> DarkCthulhu, that's not possible
11:21:19 <mauke> DarkCthulhu: no
11:21:24 <vanila> the compiler wouldn't know which type somehing is
11:21:42 <rudi_s> Yeah, I could use _exit or similar. But I'd prefer a clean solution and I think this situation should be common enough that somebody has a good solution for it.
11:21:43 <mauke> every constructor belongs to exactly one type
11:22:06 <DarkCthulhu> ah.. okay. I think I get it
11:23:16 <DarkCthulhu> What is the use of newtype?
11:23:25 <ClaudiusMaximus> @hoogle throwTo
11:23:26 <lambdabot> Control.Exception.Base throwTo :: Exception e => ThreadId -> e -> IO ()
11:23:26 <lambdabot> GHC.Conc.Sync throwTo :: Exception e => ThreadId -> e -> IO ()
11:23:27 <lambdabot> Control.Exception throwTo :: Exception e => ThreadId -> e -> IO ()
11:23:43 <ClaudiusMaximus> rudi_s: throw the exit failure exception to the main thread's id?
11:24:22 <mauke> @quote mauke newtype
11:24:23 <lambdabot> mauke says: <mauke> a newtype is like an existing type but wearing glasses and a fake mustache  <mauke> and a sign saying "you've never seen me before"
11:25:06 <mauke> DarkCthulhu: it's for when you want something that the type checker treats as a different type, but the runtime representation is the same as an existing type
11:25:11 <fizruk> does Safe Haskell allow FFI calls?
11:25:39 <vanila> What would be a simple sort of language/thing I could defin as an AST in haskell and try compiling to x86?
11:25:51 <rudi_s> ClaudiusMaximus: Thanks, that should work. Still not a nice solution IMHO.
11:25:54 <mauke> DarkCthulhu: ZipList might be interesting
11:25:57 <DarkCthulhu> mauke, haha.. okay.. It's the inverse of what I wanted.
11:26:46 <mauke> vanila: simple arithmetic
11:26:55 <mauke> vanila: also, brainfuck
11:27:30 <vanila> thanks!
11:29:37 <hamso> night guys
11:32:08 <arielsanflo> hello
11:32:09 <arielsanflo> i am from colombia
11:35:00 <benzrf> hello arielsanflo
11:35:45 <benzrf> DarkCthulhu: the actual non-implementation-detail semantics of newtypes are pretty subtle
11:36:21 <benzrf> DarkCthulhu: but as a rule of thumb, juse use them when you need a different version of an existing type for tax reasons
11:36:31 <benzrf> *just
11:36:51 <benzrf> DarkCthulhu: if you have a legitimately different type that just so happens to only have 1 field of another type
11:36:56 <benzrf> it could go either waynr
11:36:57 <benzrf> *way
11:37:57 <DarkCthulhu> benzrf, Ah.. okay. I don't think I've run into a reason to use them yet.
11:43:06 <arielsanflo> if anyone can help or give me an idea of how to search a list of integers in another list of integers example [1,3,4] [1,4,5,6,1,3,4]
11:43:06 <arielsanflo> if this return is true or false if this done in haskell
11:43:07 <arielsanflo> thank you very much who can help me
11:44:04 <arielsanflo> [1,3,4] [1,4,5,6,1,3,4] true
11:44:46 <arielsanflo> [1,2,4][1,7,8,9] false
11:44:46 <mauke> > [1,3,4] `isInfixOf` [1,4,5,6,1,3,4]
11:44:49 <lambdabot>  True
11:45:00 <monochrom> isInfixOf is in module Data.List
11:45:13 <arielsanflo> fine thanks
11:45:24 <arielsanflo> my english is so so
11:45:26 <monochrom> alternatively you can read its source code to see how to do it
11:48:37 <arielsanflo> muchas gracias
11:48:42 <arielsanflo> find thanks
11:50:41 <codehero> let trajectory x v a = ( (x * tan(a))) + (0.5 * (-10) * (x / (v * cos(a))^2))
11:50:47 <codehero> @let trajectory x v a = ( (x * tan(a))) + (0.5 * (-10) * (x / (v * cos(a))^2))
11:50:48 <lambdabot>  Defined.
11:50:59 <monochrom> @type trajectory
11:51:00 <codehero> trajectory 1 9.5 40
11:51:01 <lambdabot> Floating a => a -> a -> a -> a
11:51:09 <codehero> > trajectory 1 9.5 40
11:51:11 <lambdabot>  -1.2417672412773189
11:51:21 <codehero> why doesn't this work?
11:51:58 <codehero> x should be about 1.16 but for some reason it's not
11:52:02 <codehero> and it's negative..
11:52:27 <monochrom> I thought you said x was 1 in "trajectory 1 9.5 40"
11:53:32 <mauke> looks like it works fine
11:53:35 <monochrom> could you explain to me, step by step, why the correct answer is near 1.16?
11:53:49 * hackagebot bindings-lxc 0.2 - Direct Haskell bindings to LXC (Linux containers) C API.  http://hackage.haskell.org/package/bindings-lxc-0.2 (NickolayKudasov)
11:54:07 <ClaudiusMaximus> > trajectory 1 9.5 (40 * pi / 180)
11:54:09 <lambdabot>  0.7446903131140197
11:54:45 <codehero> monochrom: umm. yes y should be 1.16. sorry
11:55:03 <codehero> wait
11:55:06 <codehero> huh
11:55:19 <jle`> so i can use byteStringHex from Data.ByteString.Builder to convert a bytestring into a hex representation
11:55:23 <jle`> anyone know how i can go backwards?
11:56:58 <codehero> ah yes. it should be 0.74
11:57:08 <codehero> had the wrong variables in my calculator >.<
11:58:37 <FledRebel> With my sandbox building cleanly with all its dependencies how can I list the version of each dependency so I can set them in my cabal file?  I want to avoid the case where updates to those dependencies break the build.
11:59:12 <joe9> Any suggestions on how to debug this, please? http://codepad.org/Rys4QI4N "cabal: /usr/bin/ghc: permission denied" is the error
11:59:48 <joe9> which ghc: /usr/bin/ghc
12:00:05 <joe9> and I can do ghc --version:  http://codepad.org/Wba0aVpJ
12:00:11 <FledRebel> I should mention I'm working in a cabal sandbox and I would want to list the versions of the packages in that sandbox.
12:02:13 <mauke> joe9: strace?
12:02:27 <joe9> mauke: ok, thanks. will see how to use strace.
12:04:11 <joe9> mauke: thanks for the idea. good one.
12:04:55 <bennofs> joe9: have you found the problem?
12:05:10 <joe9> bennofs: not yet.
12:05:17 <mauke> strace -o wtf.log -f cabal install happy
12:05:40 <joe9> mauke: figured it out. I have a read only root filesystem and that is causing the issue.
12:05:50 <joe9> when I remounted as rw to install strace.
12:06:02 <joe9> I tried the same cabal install command and it worked fine.
12:06:11 <bennofs> joe9: do you have ro /tmp as well?
12:06:18 <joe9> now, I need to figure out why cabal is bothered with a read only root.
12:06:34 <joe9> bennofs: no, /tmp, /var, and /home/j are rw.
12:07:30 <joe9>  http://codepad.org/GFY56hcv
12:07:32 <rudi_s> I have a program here which uses mvars. Now when my program does nothing for two minutes it aborts with "thread blocked indenfinaetely in an mvar operation". But that's not true, it just does nothing for 2 minutes because it waits on input from a file. What can I do to fix this?
12:08:07 <joe9> rudi_s: I recall trying MVar once and giving up and using Chan instead.
12:08:42 <beckyconning> how come where x :: a -> b -> a and y :: a -> a, a function z :: a -> b -> a; z = y . x can raise errors? this is the example in question https://gist.github.com/anonymous/9e590695403cda99cf3e
12:09:09 <rudi_s> joe9: Actually I'm not even using mvars actively. But I use MSampleVar which uses them internally AFAIK.
12:09:22 <joe9> rudi_s: oh, ok.
12:09:48 <rudi_s> I can't use Chan in my case because I want to use the "last" value only, not intermediate results (in case the second part of the calculation takes too long).
12:10:34 <mauke> beckyconning: (f . g) x y = (f (g x)) y = f (g x) y
12:10:37 <mauke> beckyconning: not f (g x y)
12:11:08 <mauke> rudi_s: figure out where your deadlock is?
12:13:50 * hackagebot lxc 0.1 - High level Haskell bindings to LXC (Linux containers).  http://hackage.haskell.org/package/lxc-0.1 (NickolayKudasov)
12:14:41 <catchmrbharath> I was going through the upenn haskell course and I was doing HW 7 (http://www.seas.upenn.edu/~cis194/hw/07-folds-monoids.pdf). The last time I learnt a lot from review of my code and it would be great if somebody could review HW 7 for me. The link to the source is  https://github.com/catchmrbharath/upenn_haskell/tree/master/dickens
12:15:24 <catchmrbharath> The files that I have changed are JoinList.hs, JoinListBuffer.hs, Scrabble.hs, and JoinListBufferEditor.hs
12:15:34 <beckyconning> catchmrbharath: i would but i'm still on homework 3 : P
12:15:57 <catchmrbharath> beckyconning: :)
12:15:59 <beckyconning> hope you find someone up to it though!
12:16:23 <CrazyM4n> After coming from a foray into J, I love how readable Haskell is
12:16:49 <mjrosenb> does the latest TypeCompose work with ghc-6.8.3?
12:16:51 <mjrosenb> err
12:16:58 <mjrosenb> 7.8.3
12:17:23 <mjrosenb> I think that is the second time I've made that typo.
12:18:11 <mjrosenb> also, does hackage store the sha256sum of its tarballs anywhere?
12:18:24 <CrazyM4n> http://lpaste.net/563938908295921664 vs. http://rosettacode.org/wiki/Mandelbrot_set#J
12:18:48 <CrazyM4n> Also, lPaste suggests I use guards there, but is that nested if statement ok?
12:19:16 <rudi_s> mauke: Ah, facepalm .. found it. Of course it was my mistake .. just looked at the wrong places. Thanks.
12:19:33 <rudi_s> (Would be great if ghc could tell which mvar it is though.)
12:19:42 <catchmrbharath> CrazyM4n: I think guards add a lot to readability
12:20:09 <CrazyM4n> catchmrbharath: I´ll try rewriting it with guards and see how I like it
12:20:46 <mauke> CrazyM4n: what do you mean, "try"? you can just copy the code from the suggestion
12:21:09 <tia_rose_lake> hi guys!
12:21:09 <CrazyM4n> Oh, I didn´t know that it did it automatically
12:21:12 <CrazyM4n> Haha
12:21:28 <CrazyM4n> That really does look a lot better
12:21:45 <tia_rose_lake> Anyone want to check out my youtube channel?
12:22:03 <simpson> tia_rose_lake: Is it Haskell-related?
12:22:04 <tia_rose_lake> http://www.youtube.com/user/tialake98
12:22:15 <CrazyM4n> spam bot?
12:22:22 <tia_rose_lake> what is haskell?
12:22:28 <tia_rose_lake> I am a real person thank you
12:22:29 <simpson> tia_rose_lake: Wrong channel.
12:22:43 <tia_rose_lake> Oh
12:22:44 <monochrom> I agree. wrong channel to advertise.
12:22:48 <tia_rose_lake> sry
12:22:54 <CrazyM4n> It´s ok
12:23:01 <tia_rose_lake> Isn't this a general chat channel
12:23:08 <monochrom> no. there is none.
12:23:09 <tia_rose_lake> just askin
12:23:18 <CrazyM4n> No, it´s a channel to talk about a programming language, Haskell
12:23:29 <tia_rose_lake> ohhhh
12:23:31 <tia_rose_lake> sry
12:24:14 <CrazyM4n> lPaste has got a lot of nerve to put spaces between ¨x^2¨ :P
12:25:34 <monochrom> lpaste has a lot of transistors but no nerve :)
12:26:06 <catchmrbharath> monochrom: nice one!
12:26:16 <CrazyM4n> hah
12:26:30 <mauke> I agree with hlint
12:26:36 <mauke> put spaces around your operators
12:26:56 <CrazyM4n> for the most part, I do. ¨x ^ 2¨ just looks weird to me though
12:27:06 <mauke> write more C :-)
12:27:06 <arielsanflo> help
12:27:33 <ChristianS> arielsanflo: how?
12:27:38 <arielsanflo> http://codepad.org/M30kSEDl
12:27:45 <CrazyM4n> so is there an easier way to apply a function to a 2d list than just nesting maps?
12:28:03 <arielsanflo> gracias por la ayuda
12:28:09 <arielsanflo> find thanks
12:28:12 <mauke> CrazyM4n: not really
12:28:35 <CrazyM4n> Aw, ok
12:28:37 <mauke> [1,2,2]??
12:29:14 <Zekka> CrazyM4n: What owuld an easier way entail?
12:29:18 <mauke> I don't understand this function
12:29:42 <CrazyM4n> Zekka: a function that just maps over a list no matter it´s dimensions
12:29:48 <mauke> what happened to [9,6]?
12:29:53 <CrazyM4n> Zekka: I could just write a helper function though
12:30:15 <mauke> > (map . map) show [[], [1], [2,3,4]]
12:30:17 <lambdabot>  [[],["1"],["2","3","4"]]
12:30:31 <Zekka> CrazyM4n: You might consider wrapping your lists in a newtype wrapper
12:30:37 <mauke> > map show [[], [1], [2,3,4]]
12:30:39 <lambdabot>  ["[]","[1]","[2,3,4]"]
12:30:42 <CrazyM4n> Wow, you can just do (map . map)... I never knew that
12:30:45 <Zekka> or better, using an actual grid implementation if that's something someone has provided
12:30:51 <CrazyM4n> I always put them inside of each other
12:30:57 <mauke> "dimensions" is a fuzzy thing
12:31:04 <Zekka> :t map
12:31:05 <lambdabot> (a -> b) -> [a] -> [b]
12:31:06 <Zekka> :t map . map
12:31:08 <lambdabot> (a -> b) -> [[a]] -> [[b]]
12:31:17 <Zekka> and, obligatory
12:31:21 <Zekka> :t fmap
12:31:22 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:31:23 <Zekka> :t fmap . fmap
12:31:25 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
12:31:30 <joe9> mauke: failing cabal install : http://codepad.org/rfe65Oox
12:31:30 <mauke> :t fmap fmap fmap
12:31:32 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
12:31:48 <joe9> on another machine with a similar read only root fs: it works fine.
12:32:00 <joe9> but, I have ghc-7.8.3 on the working machine.
12:32:05 <jle`> CrazyM4n: map turns an (a -> b) into an ([a] -> [b]).  So mapping it again turns an ([a] -> [b]) into an ([[a]] -> [[b]]) :)
12:32:16 <CrazyM4n> I see
12:32:17 <CrazyM4n> Thanks
12:32:28 <jle`> f :: a -> b; map f :: [a] -> [b]; map (map f) :: [[a]] -> [[b]]
12:32:39 <mauke> joe9: what does process 6314 do after that?
12:32:49 <joe9> mauke: this is on the working machine: http://codepad.org/xkPVxoRo
12:32:53 <jle`> CrazyM4n: interestingly enough, zipWith works the same way
12:32:59 <jle`> f :: a -> b -> c
12:33:04 <catchmrbharath> mauke: Zekka Can you please review this for me. Repost: I was going through the upenn haskell course and I was doing HW 7 (http://www.seas.upenn.edu/~cis194/hw/07-folds-monoids.pdf). The last time I learnt a lot from review of my code and it would be great if somebody could review HW 7 for me. The link to the source is  https://github.com/catchmrbharath/upenn_haskell/tree/master/dickens
12:33:04 <mauke> joe9: yes, but where's the error?
12:33:05 <jle`> zipWith f :: [a] -> [b] -> [c]
12:33:14 <jle`> zipWith (zipWith f) :: [[a]] -> [[b]] -> [[c]]
12:33:23 <CrazyM4n> I just never thought of (map . map) before, I would always do that as map (map show)
12:33:23 <mjrosenb> > map (map f) [[1,2,3],[4,5,6]]
12:33:25 <lambdabot>  No instance for (GHC.Show.Show b0)
12:33:25 <lambdabot>    arising from a use of ‘M43784947170195244867870.show_M43784947170195244867...
12:33:25 <lambdabot>  The type variable ‘b0’ is ambiguous
12:33:25 <lambdabot>  Note: there are several potential instances:
12:33:25 <lambdabot>    instance [safe] GHC.Show.Show
12:33:26 <joe9> mauke, I think I screwed up with the paste's. very sorry about that.
12:33:30 <jle`> CrazyM4n: ah, ok :)
12:33:31 <Zekka> catchmrbharath: Looking
12:33:36 <jle`> yeah, f (g x) = (f . g) x
12:33:50 <CrazyM4n> I knew that, but still, it flew over my head :P
12:33:54 <mjrosenb> > f 3
12:33:54 <catchmrbharath> Zekka: Thank you
12:33:55 <lambdabot>  No instance for (GHC.Show.Show a0)
12:33:55 <lambdabot>    arising from a use of ‘M64090140004449587447882.show_M64090140004449587447...
12:33:55 <lambdabot>  The type variable ‘a0’ is ambiguous
12:33:55 <lambdabot>  Note: there are several potential instances:
12:33:55 <lambdabot>    instance [safe] GHC.Show.Show
12:33:58 <mjrosenb> > f a
12:33:59 <lambdabot>  No instance for (GHC.Show.Show a0)
12:34:00 <lambdabot>    arising from a use of ‘M5042134497526576697894.show_M5042134497526576697894’
12:34:01 <lambdabot>  The type variable ‘a0’ is ambiguous
12:34:03 <lambdabot>  Note: there are several potential instances:
12:34:05 <lambdabot>    instance [safe] GHC.Show.Show
12:34:07 <mjrosenb> did we break that recently?
12:34:12 <mauke> no
12:34:18 <jle`> :t zipWith . zipWith . zipWith
12:34:19 <lambdabot> (a -> b -> c) -> [[[a]]] -> [[[b]]] -> [[[c]]]
12:34:27 <mauke> mjrosenb: typical varargs result ambiguity
12:34:27 <CrazyM4n> :t map . map . map
12:34:28 <lambdabot> (a -> b) -> [[[a]]] -> [[[b]]]
12:34:37 <mauke> CrazyM4n: consider 'flip id'
12:34:43 <arielsanflo> The function takes a number (n) and compares it with the elements of a list [1,3,4, .....] and returns less than n in the first list and the highest in the segunta ([1. ...], [])
12:35:05 <mauke> it's not relevant, but I like seeing people consider it and breaking their brain
12:35:10 <CrazyM4n> :t flip id
12:35:11 <lambdabot> b -> (b -> c) -> c
12:35:15 <CrazyM4n> whaaat
12:35:19 <CrazyM4n> wait
12:35:22 <mjrosenb> mauke: foldl f a [b,c,d] totally used to work.  Are my examples different from that?
12:35:25 <jle`> arielsanflo: sounds like partition?
12:35:32 <mauke> mjrosenb: yes
12:35:35 <jle`> :t partition
12:35:36 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
12:35:46 <jle`> arielsanflo: oh nvm. i'm not sure what you are asking
12:35:50 <CrazyM4n> ah, I get what flip id does now
12:35:53 <jle`> it reurns less than n?
12:35:53 <Zekka> catchmrbharath: Why isn't JoinList a monoid?
12:35:55 <mauke> :t foldl
12:35:57 <lambdabot> (b -> a -> b) -> b -> [a] -> b
12:35:59 <joe9> mauke: errored version: http://codepad.org/suwmucqs on ghc 7.6.3
12:36:00 <benmachine> arielsanflo: is the input list sorted?
12:36:20 <mjrosenb> mauke: interesting.
12:36:22 <merijn> Zekka: JoinList? What's that? Are you thinking of DList?
12:36:28 <mauke> mjrosenb: (b -> a -> b) nails down the result type of f because b is known (it's the type of a, which is Expr)
12:36:30 <Zekka> merijn: He asked me to go over his code
12:36:34 <Zekka> He defines a type called JoinList
12:36:38 <Zekka> https://github.com/catchmrbharath/upenn_haskell/blob/master/dickens/JoinList.hs
12:36:40 <phaazon> hey, just being curious out of nowhere
12:36:45 <joe9> mauke: does that make sense?
12:36:48 <phaazon> is NonEmpty a comonad?
12:36:50 <phaazon> I guess it is
12:36:55 <mjrosenb> mauke: aah, gotcha.
12:37:07 <phaazon> extract would be the head
12:37:49 <mauke> joe9: ok, that's super weird
12:37:52 <jle`> phaazon: thank about the laws
12:37:53 <Zekka> It looks to me like he could just define a monoid instance for JoinList when m is a monoid
12:37:56 <jle`> *think
12:38:02 <Zekka> and then he wouldn't have to define extra redundant operations
12:38:03 <mauke> joe9: I don't understand what cabal thinks it's trying to do there
12:38:13 <catchmrbharath> Zekka: I was thinking of that as the homework does not do that. But the main reason I think is that, JoinList is a generic data type, and the contents need not have a monoidic structure. In the case it is used, it can be a monoid
12:38:16 <phaazon> oh
12:38:20 <phaazon> something like
12:38:26 <phaazon> return . extract = id
12:38:29 <benzrf> monoidal
12:38:37 <phaazon> which doesn’t stand for NonEmpty
12:38:48 <Zekka> catchmrbharath: Isn't that what "instance (Monoid m) => Monoid (JoinList m a) where" would say?
12:38:49 <benzrf> Identity is both a monad and a comonad!
12:38:50 <benmachine> phaazon: return doesn't in general exist for comonads
12:38:51 <jle`> i don't think comonad laws have anything to do with return
12:39:02 <benmachine> I think NonEmpty is a comonad though
12:39:05 <benmachine> with duplicate = tails
12:39:13 <benzrf> are comonads comonoids in a category of endofunctors
12:39:25 <phaazon> comonoids?
12:39:25 <mauke> it just gives up after the W_OK check
12:39:31 <benmachine> benzrf: probably.
12:39:32 <merijn> NonEmpty should be a comonad, yes
12:39:32 <Zekka> benzrf: I think so, not totally sure
12:39:36 <phaazon> comonoids hm
12:39:40 <phaazon> one coempty
12:39:41 <mauke> and I have no idea why it does those checks in the first place
12:39:42 <benzrf> phaazon: like monoids, but with the arrows flipped!!
12:39:44 <Zekka> You can duplicate them or completely get rid of them, right?
12:39:45 <phaazon> and a function that takes two values
12:39:48 <phaazon> and output a function?
12:39:58 <merijn> Wait, what would a comonoid be?
12:39:59 <benmachine> benzrf: you say that as if sarcastic, but that's literally what they are
12:40:01 <Zekka> comempty :: m -> (); comappend :: m -> (m, m)
12:40:04 <benzrf> benmachine: um no
12:40:09 <benzrf> i was not being sarcastic at all
12:40:12 <Zekka> They're not too interesting in Hask
12:40:17 <benmachine> benzrf: I assumed from the !! :P
12:40:27 <phaazon> wut :D
12:40:30 <benzrf> i like exclamation points lately
12:40:31 <jle`> extract . duplicate = id
12:40:38 <benzrf> or maybe even explanation points
12:40:40 <jle`> fmap extract . duplicate = id
12:40:49 <jle`> duplicate . duplicate = fmap duplicate . duplicate
12:40:50 <joe9> mauke: I did "strace -o /tmp/strace.ro.log -f cabal install happy"
12:40:54 <Zekka> But yeah, isn't extract to comempty what return is to mempty?
12:41:03 <benmachine> Zekka: yes
12:41:05 <Zekka> Ditto for comappend and duplicate?
12:41:12 <benmachine> yes
12:41:31 <CrazyM4n> http://lpaste.net/3736607399897726976 So I have this. How would I make it so that for every b value, a new array is started inside the top array?
12:41:33 <mauke> joe9: cabal is crazy ¯\(°_o)/¯
12:41:42 <benmachine> I suppose you have to think about a the dual of a monoid object, rather than the dual of a monoid per se
12:41:52 <catchmrbharath> Zekka: I did not get your question. I think with instance (Monoid m) => Monoid (JoinList m a), I will have to have methods that define how mappend works on a also.
12:42:04 <benmachine> because like Zekka says, comonoids in the usual context are boring
12:42:10 <merijn> catchmrbharath: No, why?
12:42:12 <catchmrbharath> Zekka: `a` also
12:42:15 <mauke> CrazyM4n: example result?
12:42:24 <Zekka> catchmrbharath: That's not what the type of (+++) says
12:42:27 <sinelaw> when running cabal update, why do I get: cabal: /home/user.../.cabal: does not exist
12:42:33 <Zekka> Your (+++) looks like renamed mappend to me
12:42:34 <sinelaw> (.cabal does exist!)
12:42:42 <CrazyM4n> > [a :+ b | a <- [(-2)..2],b <- [(-2)..2]]
12:42:43 <lambdabot>  [(-2) :+ (-2),(-2) :+ (-1),(-2) :+ 0,(-2) :+ 1,(-2) :+ 2,(-1) :+ (-2),(-1) :...
12:42:45 <mauke> have you tried strace
12:42:46 <joe9> mauke: any suggestions on how to go about fixing it, please? update ghc to 7.8.3 or just reinstall cabal?
12:42:48 <merijn> sinelaw: Wrong user permissions/owner?
12:43:09 <mauke> joe9: I don't understand what's wrong, so no. try talking to the cabal maintainers?
12:43:09 <CrazyM4n> Uh, a and b are backwards right now
12:43:12 <nitrix> Hello, I was wondering what would be the idiomatic approach in Haskell to have two methods (put and get) on an object. I'm doing a file system and each "Endpoint" thing needs to supply their own backend to put and get objects.
12:43:19 <joe9> mauke, ok, thanks.
12:43:21 <sinelaw> merijn, nope
12:43:29 <nitrix> In C, it'd be a struct with function pointers. They won't change during their lifetime though.
12:43:33 <CrazyM4n> > [a :+ b | b <- [(-2),(-1.9)..2], a <- [(-2),(-1.9)..2],]
12:43:35 <lambdabot>  <hint>:1:56: parse error on input ‘]’
12:43:41 <merijn> nitrix: Record of functions?
12:43:42 <geekosaur> nitrix: most idiomatic is not to use methods, but records
12:43:42 <CrazyM4n> > [a :+ b | b <- [(-2),(-1.9)..2], a <- [(-2),(-1.9)..2]]
12:43:44 <lambdabot>  [(-2.0) :+ (-2.0),(-1.9) :+ (-2.0),(-1.7999999999999998) :+ (-2.0),(-1.69999...
12:43:46 <mauke> > [ [a :+ b | a <- [-2 .. 2] ] | b <- [-2 .. 2] ]
12:43:48 <lambdabot>  [[(-2) :+ (-2),(-1) :+ (-2),0 :+ (-2),1 :+ (-2),2 :+ (-2)],[(-2) :+ (-1),(-1...
12:43:59 <Zekka> nitrix: Although typeclasses would also work, see above
12:44:06 <CrazyM4n> oh, that easy? what´s going on there mauke?
12:44:07 <merijn> nitrix: "data Handle = Handle { put :: Foo -> IO (); get :: IO Foo }"?
12:44:09 <jle`> typeclasses are hardly an idiomatic approach
12:44:18 <mauke> CrazyM4n: uh, list comprehensions?
12:44:23 <merijn> Zekka: Typeclasses are a terrible idea for things like this
12:44:27 <nitrix> merijn: Appreciated, thanls.
12:44:33 <CrazyM4n> Well yea, but I don´t get how | does that
12:44:39 <catchmrbharath> Zekka: Ah! yeah. Actually instantiating a Monoid instance of JoinList will simplify things a lot
12:44:44 <mauke> CrazyM4n: ?
12:44:52 <jle`> CrazyM4n: it's just syntax
12:44:54 <mjrosenb> Is there a way to print out the version of a package that was bundled with ghc? e.g. Containers
12:45:06 <Zekka> merijn: What's wrong with them here? I prefer records but not that much more
12:45:14 <CrazyM4n> Then I guess I don´t really know the list comprehension syntax
12:45:15 <mauke> > map (\b -> map (\a -> a :+ b) [-2 .. 2]) [-2 .. 2]
12:45:17 <lambdabot>  [[(-2) :+ (-2),(-1) :+ (-2),0 :+ (-2),1 :+ (-2),2 :+ (-2)],[(-2) :+ (-1),(-1...
12:45:20 <mauke> same thing
12:45:23 <catchmrbharath> Zekka: I just followed the homework doc and did not think of that :). Thanks!!
12:45:28 <merijn> nitrix: And you can even make them polymorphic, suppose you want a handle that serialises 'a' just make it "data Handle a = Handle { put :: a -> IO (); get :: IO a }"
12:45:31 <CrazyM4n> Ohhh, that makes a little more sense
12:45:36 <Zekka> If you don't know exactly what the type of your endpoints are -- i.e., if anyone can write their own endpoint -- don't typeclasses + existentials work better?
12:45:38 <jle`> typeclasses are literally almost always a bad idea
12:45:47 <merijn> Zekka: Because it leads down the slippery road of existential antipattern
12:45:50 <benmachine> Zekka: http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
12:45:55 <Zekka> benmachine: Reading
12:46:00 <Clint> mjrosenb: dpkg -L ghc | grep containers-
12:46:00 <cyco> hey
12:46:01 <merijn> Zekka: existential typeclasses are almost always the wrong thing :)
12:46:03 <jle`> typeclasses aren't first class
12:46:07 <nitrix> merijn: Right. Haskell's great for that :)
12:46:15 <Zekka> merijn: I use them a lot so let me read
12:46:17 <jle`> normal data types are
12:46:27 <mjrosenb> Clint: that makes some assumptions...
12:46:34 <Clint> your question was vague
12:46:39 <CrazyM4n> mauke: I see what you did there, I didn´t see the extra lists and thought that you just had more than one | there
12:46:39 <benmachine> I think that existentials + typeclasses do have valid uses, but they suffer from being often used when they are not necessary and only complicate things
12:46:39 <CrazyM4n> Thanks
12:46:50 <mauke> CrazyM4n: there's an extension for that, too :-)
12:46:52 <sinelaw> merijn, I moved my homedir
12:46:53 <Guest96274> can someone tell me some good freenode channels where i can meet a hacker
12:46:55 <mauke> parallel list comprehensions
12:47:04 <sinelaw> merijn, cabal is still looking for it in the old place
12:47:06 <Zekka> Guest96274: What do you want to ask the hacker about?
12:47:07 <jle`> i think one of the only advantages in typeclasses are being able to put laws on them and reason about them.  using them as function containers is a bit weird for a global non-first class mechanism
12:47:13 <Zekka> It's a term that means a lot of things
12:47:14 <CrazyM4n> Guest96274: Try the channel list?
12:47:19 <mauke> > [ (x,y) | x <- [1 .. 3] | y <- ['a' .. 'c'] ]
12:47:21 <lambdabot>  [(1,'a'),(2,'b'),(3,'c')]
12:47:26 <merijn> benmachine: Sure, but most usecases I've seen for existentials + typeclasses have been "I've been doing obscene gadt thingies and can't convince GHC I'm right without Typeable existenials" :p
12:47:26 <CrazyM4n> There are probably even people here who could help you
12:47:32 <Guest96274> well i am a hacker but just a biggner
12:47:44 <Guest96274> so i need lill bit of help
12:47:53 <Guest96274> sorry for my bad englissh
12:47:55 <Zekka> What do you mean by "hacker"?
12:48:09 <CrazyM4n> If it´s with a programming language that you´re having trouble with, you could find a channel for that language
12:48:12 <Zekka> someone who does malicious things? Someone who writes lots of software? Someone who does golf?
12:48:14 <Guest96274> a person who can snatch freedom
12:48:25 <edwardk> benmachine: NonEmpty _is_ a comonad, though tails is ever so slightly wrong
12:48:39 <edwardk> benmachine: tails changes 'shape' by adding an element
12:48:42 <edwardk> > tails [1,2,3]
12:48:44 <lambdabot>  [[1,2,3],[2,3],[3],[]]
12:48:46 <monochrom> Zekka, I think I see why a type class helps. but I doubt that you know the full consequences of existential quantification.
12:48:55 <edwardk> note that you started with a 3 element list, but wound up with 4
12:49:10 <Zekka> monochrom: I don't know too much about the implementation
12:49:11 <sinelaw> merijn, apparently the absolute path to .cabal is hardcoded in .cabal/config
12:49:12 <edwardk> benmachine: if you fix that then you get the 'tails' comonad for NonEmpty
12:49:13 <benmachine> edwardk: well, tails :: NonEmpty a -> NonEmpty (NonEmpty a), right
12:49:14 <mjrosenb> ahh, ghc-pkg list
12:49:20 <Zekka> Unless you mean a different kind of consequences
12:49:25 <monochrom> no, I am not talking about implementation either.
12:49:27 <edwardk> benmachine: you need to drop the [] case basically
12:49:32 <benmachine> edwardk: ok, cool
12:49:36 <benmachine> thanks
12:49:36 <edwardk> then its NonEmpty a -> NonEmpty (NonEmpty a)
12:49:37 <Guest96274> any one good with android wifi hacking here>?
12:49:43 <mjrosenb>  semigroups (>=0.8 && <0.10)
12:49:45 <CrazyM4n> How do you use the bigfloat equivalent in haskell?
12:49:49 <mjrosenb> oh really?
12:49:51 <merijn> Zekka: The consequences of existenials is usually writing lots of unnecessary boiler plate code that goes away if you use records
12:49:51 <Zekka> Guest96274: THere might be someone but this channel's not really about that AFAIK
12:49:51 <mjrosenb> :-(
12:49:54 <benzrf> edwardk: monad time
12:49:55 <mjrosenb> that is awful.
12:50:07 <merijn> CrazyM4n: Perhaps you want Rational/arbitrary precision?
12:50:08 <edwardk> mjrosenb: who has that bound?
12:50:16 <merijn> CrazyM4n: bigfloat is not really a sensible term
12:50:21 <mjrosenb> edwardk: grapefruit-frp
12:50:31 <edwardk> mjrosenb: sounds like time to submit a patch ;)
12:50:36 <Guest96274> what are you guys talking about can i get in
12:50:40 <CrazyM4n> merijn: I´m just thinking it would be called something like that, like how it´s called BigFloat or BigNum in other language
12:50:47 <monochrom> suppose you say "data E = forall a. Num a => a". then suppose you receive two values x, y of type E. do you know that you are not allowed to: case x of E a -> case y of E b -> a+b. the a+b will be a type error.
12:50:57 <CrazyM4n> merijn: But yea, that´s what I´m looking for
12:50:57 <Zekka> Guest96274: A lot of us are Haskell programmers, where Haskell is a programming language
12:51:02 <mjrosenb> edwardk: I'm trying to install it so I can learn it
12:51:07 <merijn> CrazyM4n: Integer are bignums, but you need to specify which kinda of semantics you want in case of float
12:51:21 <merijn> CrazyM4n: Ratio provides you with fractions that are always exact
12:51:29 <mjrosenb> edwardk: not go diving into the code base, and figure out how it works from the inside out :-(
12:51:32 <merijn> > (2 % 3) + (3 % 5)
12:51:34 <lambdabot>  19 % 15
12:51:36 <CrazyM4n> merijn: Well, I need a number that has a decimal point in it, that is arbitarily precise
12:51:49 <Guest96274> can you atleast suggest me a good channel filled with hackers
12:51:57 <CrazyM4n> merijn: I can´t have the 1.900000001, 1.800000002 buisness here
12:51:57 <merijn> CrazyM4n: I'm not sure whether such a type exists or makes sense
12:52:06 <tabemann> what do you mean by "hackers"? I assume you don't mean the old meaning of the term
12:52:07 <merijn> CrazyM4n: What would you have for an infinite decimal?
12:52:19 <Zekka> merijn: I haven't written too muh code in that style a while ago, but later I'll probably write some existentials/etc. code and some records code and see how they compare as far as style goes
12:52:26 <CrazyM4n> merijn: Hold on, let me get the ruby equivalent that I remember
12:52:29 <merijn> CrazyM4n: You can either have a fixed precision (i.e. precise up to N decimal places) or Ratio
12:52:36 <Guest96274> what what do you mean hackers
12:52:37 <Zekka> I think I can think of some specific differences but I don't think I have an intuitive sense of how my code will look different right at the moment
12:52:48 <Guest96274> i am looking for some people who can hack
12:52:55 <pjdelport> Guest96274: This channel is for the Haskell programming language.
12:52:57 * tabemann prefers the old meaning, and tends to regard the people identified by the "new" meaning as common criminals
12:53:10 <CrazyM4n> Like, accounts and things? Those aren´t really hackers, they are criminals
12:53:12 <athan> How can I combine two Properties like boolean `&&` and `||` in QuickCheck? Something like `(x === y) && (y === x)`? I just want the (&&) function, if that helps :S
12:53:15 <merijn> tabemann: The new meaning has overlap with the old one, though
12:53:26 <benzrf> :k Property
12:53:28 <lambdabot> *
12:53:35 <mauke> Guest96274: what do you mean by "hack"?
12:53:36 <benzrf> @hoogle Property -> Property -> Property
12:53:37 <mjrosenb> Guest96274: I'm pretty good at hacking.  I turned a tree into firewood last weekend.
12:53:37 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
12:53:37 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
12:53:37 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
12:53:41 <benzrf> huh
12:53:41 <CrazyM4n> merijn: Ok, well how do I use the numbers that are precise up to n decimal places?
12:53:50 <pjdelport> mauke: "Android wifi hacking"
12:53:54 * hackagebot hoq 0.3 - A language based on homotopy type theory with an interval type  http://hackage.haskell.org/package/hoq-0.3 (valis)
12:53:55 <merijn> CrazyM4n: Look at Data.Fixed
12:53:56 <CrazyM4n> merijn: Also, I meant http://www.ruby-doc.org/core-2.1.3/Bignum.html
12:54:00 <mauke> pjdelport: what do you mean by "hacking"?
12:54:11 <CrazyM4n> merijn: I´ll take a look at that, thanks
12:54:17 <pjdelport> mauke: That's what they said.
12:54:25 <mauke> pjdelport: I know, that's why I asked
12:54:37 <monochrom> . o O ( ELI5 what is hacker )
12:54:46 <pjdelport> mauke: I don't know, but nothing savory, from the sound of it. :P
12:54:56 <mauke> ("X is an X that is also Y" is not a definition of X)
12:55:00 <merijn> CrazyM4n: None of that pages actually tells you about what exactly it does for floats :(
12:55:22 <monochrom> . o O ( f is a function that calls f )
12:55:22 <merijn> tabemann: I have a friend studying malware obfuscation, some of that stuff is a downright work of art
12:55:33 <CrazyM4n> merijn: Hold on, I have a ruby interpreter, I´ll show you
12:56:20 <merijn> CrazyM4n: Showing doesn't tell me anything. I wanna know how they handle infinite/repeating decimals, like 1/3 and pi
12:56:35 <CrazyM4n> merijn: You know, I don´t know
12:56:37 <tabemann> merijn: I respect the people involved in security development (and trying to compromise it), but tend to view a lot of the people known as "hackers" these days as criminals, especially when they have no real knowledge of the technical nature of what they are doing
12:56:39 <merijn> Well, I guess since it's binary I mean 1/10 since I think 1/3 is finite
12:56:43 <CrazyM4n> merijn: It´s probably truncated
12:56:44 <mauke> has anyone mentioned CReal yet?
12:56:49 <merijn> mauke: Ah, no
12:56:53 <monochrom> 1/3 is not finitary either
12:56:56 <merijn> I keep forgetting it exists
12:57:51 <merijn> tabemann: Sure, I think the issue of "being a hacker" is not legality, but innovation and creativity in making systems do what they weren't intended to do.
12:58:13 <CrazyM4n> http://prntscr.com/4qw93n
12:58:15 <merijn> CrazyM4n: Right, but it helps to decide whether that is what you want, or not :)
12:58:44 <merijn> CrazyM4n: For example, ratio represents "1/3" and "1/10" with "infinite" precission, but can't handle, for example 'e' or pi
12:58:47 <CrazyM4n> merijn: I just need a number that I can continually add decimals without floating point errors
12:58:54 * hackagebot pointfree 1.0.4.8 - Tool for refactoring expressions into pointfree form  http://hackage.haskell.org/package/pointfree-1.0.4.8 (BenMillwood)
12:58:56 * hackagebot ghcid 0.1 - GHCi based bare bones IDE  http://hackage.haskell.org/package/ghcid-0.1 (NeilMitchell)
12:59:03 <mauke> use Rational
12:59:07 <CrazyM4n> merijn: It probably doesn´t matter, the floating point errors will be tiny in the long run
12:59:15 <CrazyM4n> I just don´t like them
12:59:23 <tabemann> merijn: except that the public now calls anyone who downloads a script from somewhere and runs it, without understanding what it really does, a "hacker"
12:59:38 <CrazyM4n> But that´s the media
12:59:42 <nitrix> merijn: Wouldn't a class/instance approach makes more sense for my get/put endpoints?
12:59:48 <CrazyM4n> ¨who is this hacker 4chan¨
12:59:57 <merijn> nitrix: What do you think that will gain you?
13:00:40 <CrazyM4n> So, now that I have a 2d list
13:00:46 <CrazyM4n> How could I display that to the screen?
13:00:57 <CrazyM4n> Preferrably in a window, but console output would be OK
13:01:01 <mauke> print thatList
13:01:03 <nitrix> merijn: Well I'm thinking composition. EndpointLocal and EndpointRemote might not exactly be the same, but they'd share both a get/put operation in common that is like the minimum requirement to be a Endpoint.
13:01:04 <CrazyM4n> I could map over it and print
13:01:06 <CrazyM4n> i guess
13:01:38 <CrazyM4n> I don´t want to, but I guess I have to map and print
13:01:39 <merijn> nitrix: But you can already do that with my type, no? You can put arbitrary functions with the right type into that record...
13:02:10 <CrazyM4n> Is there anything in haskell similar to ¨viewmat¨ in J?
13:02:33 <CrazyM4n> http://prntscr.com/4qwb0b
13:02:38 <merijn> nitrix: "localEndpoint :: Handle a; localEndpoint = Handle { get = localGet; put = localPut }; remoteEndpoint :: Handle a; remoteEndpoint = Handle { get = remoteGet; put = remotePut }"
13:03:12 <merijn> nitrix: You can use whatever you want to implement localGet/localPut
13:04:21 <athan> benzrf: Thanks anyway, it's  (.&&.) :/
13:04:28 <nitrix> I get it but there, localEndpoint and remoteEndpoint are just objects of a type Handle.
13:04:51 <nitrix> They do not have they own separate type and there's no inheritance/composition either.
13:05:05 <mjrosenb> https://gist.github.com/252e598283efcbdc88c4 -- sweet
13:05:19 <mjrosenb> I have only a minimal understanding of what that is telling me
13:05:22 <CrazyM4n> Is there an equivalent to http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.imshow in haskell?
13:05:26 <merijn> nitrix: No, but haskell has no inheritance anyway and you can reuse as much code as you want
13:05:48 <merijn> nitrix: hold on, I'm working on a library that exposes a "socket" API, I'll paste some simplified example
13:06:07 <monochrom> but you find that you may use -fcontext-stack=N to try harder, don't you?
13:06:24 <nitrix> merijn: If it was only of your comment, I'd think it's retarded, but because I read enough Haskell, I'll just assume you don't understand what I want to do.
13:06:24 <monochrom> the context stack is used for deciding UndecidableInstances
13:06:35 <nitrix> I really doubt that's a limitation of the language.
13:07:52 <mjrosenb> monochrom: I am not entirely sure how to pass that in.
13:07:56 <nitrix> I just want different things/type/record or however you call it, to have different operations possible where at least a subset is required to be a valid Endpoint type, which is what will be used throughtout the program.
13:08:04 <monochrom> ghc -fcontext-stack=30 ...
13:08:16 <mjrosenb> monochrom: I suspect runhaskell Setup.hs build -fcontext-stack=30 isn't going to cut it.
13:08:22 <lpaste> merijn pasted “socket type” at http://lpaste.net/111729
13:08:45 <beckyconning> i made snake in haskell : ) https://github.com/beckyconning/haskell-snake/blob/master/Snake.hs
13:09:00 <beckyconning> wasd to move
13:09:07 <merijn> nitrix: That's how I implement a socket interface in my ZMQ code (well, slightly simplified, it abuse {-# LANGUAGE KitchenSink #-}, but I tried to hide that in the paste)
13:09:08 <mjrosenb> beckyconning: awesome.  you got fruit placement to work?
13:09:40 <monochrom> then it has to be runhaskell Setup.hs configure --ghc-options='-fcontext-stack=30'
13:09:47 <Zekka> merijn: What's the KitchenSink extension do?
13:10:00 <beckyconning> mjrosenb: yes : )
13:10:01 <merijn> nitrix: My state initialisation code is just a normal function that is shared between all similar sockets and I have small wrappers for the socket specific stuff that operate on the socket's structures
13:10:05 <merijn> Zekka: It was a joke :)
13:10:13 <merijn> Zekka: I mean it has like 10 language pragma's
13:10:14 <Zekka> This sounds like something I should be using!
13:10:37 <nitrix> merijn: Both your pub and dealer function returns IO Socket objects.
13:10:40 <mjrosenb> monochrom: cool, that may have worked?
13:10:53 <Zekka> merijn: I'm actually going to be writing a program in a bit, I think, that I originally planned to use existentials/typeclasses for
13:10:58 <Zekka> I'll let you know if I run into any grief
13:11:02 <nitrix> merijn: You still don't understand.
13:11:03 <chrisdone> anybody know ATS?
13:11:06 <CrazyM4n> Guys, I finally finished a mandelbrot fractal renderer! It only took like 2 months!
13:11:07 <monochrom> I don't know. it depends on how undecidable your undecidable instances are.
13:11:16 <merijn> Zekka: The actual code starts with: {-# LANGUAGE ConstraintKinds, DataKinds, GADTs, KindSignatures, PolyKinds, RankNTypes, TypeFamilies, TypeOperators #-}
13:11:36 <monochrom> I fear ATS. it's like assembly language of proofs.
13:11:37 <Zekka> merijn: Although there's nothing evil about the actual extensions list, as far as I can tell
13:11:41 <merijn> nitrix: No, my dealer/pub object return "an IO action that will create a socket"
13:12:08 <merijn> nitrix: I do understand, you want to have different types and I'm asking you "why would you want that?"
13:12:20 <chrisdone> monochrom: i'm learning it and simplfy baffled by the syntactical choices
13:12:39 <monochrom> it may be worse. assembly language of proofs requiring type annotations
13:12:46 <catchmrbharath> beckyconning: Nice!! i will have to try doing that, after learing to do IO :)
13:12:50 <merijn> Zekka: I try to avoid the "bad" extensions, I just use a lot of the good ones ;)
13:12:54 <tabemann> I can somewhat understand Agda and Idris code when I see it, but ATS is utterly opaque to me
13:12:56 <nitrix> merijn: Okay, how would you write your program if you had a TCPSocket and a UDPSocket ?
13:12:58 <chrisdone> who  makes “:<cloref1>” and “t@ype” language keywords? and how are they derived?
13:13:00 <nitrix> merijn: It's exactly what I have.
13:13:02 <catchmrbharath> learning* how to do IO
13:13:38 <CrazyM4n> What´s a good ASCII color scheme? Like, what characters should I use to represent intensity?
13:13:44 <monochrom> catchmrbharath, do you want to learn IO from my http://www.vex.net/~trebla/haskell/IO.xhtml ?
13:13:46 <tabemann> ITS feels ridiculously complex to me
13:13:51 <mauke> I've made "END IF" a keyword (including the space) :-)
13:13:54 <Zekka> IIRC monochrom's tutorial is alrigh
13:13:56 <Zekka> alright*
13:14:06 <tabemann> whereas, say, Idris feels like a dependently-typed, strict version of Haskell, in comparison
13:14:08 <merijn> nitrix: You said you had a common interface, you want your types to reflect the implementation, but there's no good reason to do that. Types should reflect the *interface*. If your types have different interfaces, then how would a typeclass help?
13:14:14 <tabemann> *ATS
13:14:40 <chrisdone> tabemann: here's my progresss working through the book: https://gist.github.com/chrisdone/c23251e8b975dc805876
13:15:15 <catchmrbharath> monochrom: Thanks! WIll do that.
13:15:18 <merijn> nitrix: My "Socket" type supports the common interface of all my endpoints. Making a typeclass for that interface superfluous. If there is no common interface, how are you expecting a typeclass to help?
13:15:21 <vanila> Do you write proofs when you use ATS ?
13:15:22 <benzrf> >strict languages
13:15:46 <nitrix> merijn: There's one common interface but I don't want to be restricted to that interface.
13:15:48 <vanila> wait a sec, this ATS looks like ocaml
13:15:51 <chrisdone> i'm not sure why it doesn't support parametric polymorphism in data types. perhaps because it would require unboxing
13:15:51 <vanila> didn't it used to look like C?
13:16:21 <chrisdone> vanila: it may be the way i'm formatting it. here's a comparison between how the author of ATS formats ATS and how i format it: https://gist.github.com/chrisdone/3cbda530e525addb1dc3
13:16:33 <vanila> http://www.ats-lang.org/htdocs-old/ this is ATS1 which looks like C
13:16:33 <tabemann> ATS is ML-derived, yes
13:16:37 <merijn> nitrix: The actual code itself is slightly more flexible as I do support operations for specific types (which is why there's a "Pub" and "Dealer" in the type and my socketOperation function has a fancy type to support socket specific operations)
13:16:41 <vanila> I guess they revampd it and gave it an ocaml syntax
13:16:59 <nitrix> merijn: Okay, just forget it, you're driving me nuts.
13:17:05 <vanila> hmm its kind of camlish originally, oh well
13:17:07 <chrisdone> it does have things like #define and stuff like that
13:17:19 <monochrom> CrazyM4n: colouring is not part of ASCII. however, there is an ANSI standard for that, but I forgot what it says. it contains a lot of '\x1B' and '['. people say "ANSI colour".
13:17:34 <codehero> > trajectory 8 9.5 (40 * pi / 180)
13:17:35 <lambdabot>  5.957522504912157
13:17:41 <codehero> hmm
13:17:42 <monochrom> although, since ANSI is US, I should say "ANSI color".
13:17:46 <Zekka> Yeah, google "ansi formatting" or something to the effect
13:17:48 <mauke> "\e[3%dm" and "\e[m"
13:17:50 <CrazyM4n> No, I don´t mean color literally
13:17:56 <mauke> think aalib
13:18:08 <CrazyM4n> I mean what characters should I use in order to represent intensity of a point
13:18:17 <CrazyM4n> If that makes sense
13:18:18 <CrazyM4n> Like
13:18:24 <CrazyM4n> # is the darkest character
13:18:27 <Zekka> Oh, I get you
13:18:31 <CrazyM4n> Yea
13:18:51 <mauke> http://aa-project.sourceforge.net/gallery/
13:18:57 <geekosaur> that would be aalib type stuff, yes
13:18:59 <Zekka> You could look up the characters Dwarf Fortress uses for stones of various degrees of "chiseled", although IIRC they're heavily unicode
13:19:00 <monochrom> I don't get it. but I half get it.
13:19:12 <CrazyM4n> http://prntscr.com/4qwi96 This is what I have, I´m not very good at this
13:19:25 <monochrom> ah, ASCII art. that's an old art.
13:19:35 <CrazyM4n> Kind of... but it´s mathy
13:20:04 <chrisdone> it seems rather than a polymorphic function like:
13:20:04 <chrisdone>   swap (a,b) = (b,a)
13:20:04 <chrisdone> you have to define a "template":
13:20:04 <chrisdone>   fun {a,b : t@ype} swap ((x,y) : (a,b)) = (y,x)
13:20:25 <chrisdone> i'm not sure if there's good reason for this that will become clear later when i get to the dependent types and linear types chapters
13:20:46 <vanila> linear types could be very interesting
13:21:00 <monochrom> tangentially, mplayer can play movies as ASCII art. that horrifies me a great deal. imagine: playing Matrix as ASCII art...
13:21:05 <chrisdone> yeah, that's the main thing i'm interested in. statically checked memory management
13:21:10 <vanila> I wonder what kind of programs I can write in linear lambda calculus
13:21:14 <CrazyM4n> http://prntscr.com/4qwj69 Does this look a bit better?
13:21:20 <vanila> I think you need to mix in non-linear stuff for real work
13:21:23 <doismellburning> monochrom: it's quite useful
13:21:31 <edwardk> vanila: linear ones =)
13:21:31 <doismellburning> monochrom: I've legitimately watched films like that
13:21:39 <CrazyM4n> monochrom: That sounds awesome though
13:21:45 <merijn> CrazyM4n: oh, that's pretty neat
13:22:04 <chrisdone> monochrom: that's probably the only way you can make the Sex and the City movie less offensive to watch
13:22:05 <edwardk> vanila: did you ever read baker's linear lisp? http://home.pipeline.com/~hbaker1/LinearLisp.html
13:22:05 <CrazyM4n> merijn: http://lpaste.net/6999044247038984192
13:22:07 <merijn> Are there any good type theory books on linear types?
13:22:25 <vanila> ATTAPL has a really nice intro
13:22:37 <vanila> I just had  alook at wadlers paper and I guess its important but i didnt get much out of it
13:22:53 <edwardk> vanila: walker's article at the start of attapl is a nice introduction
13:23:18 <codehero> great
13:23:31 <codehero> for some reason it still doesn't work :/
13:23:35 <CrazyM4n> How do you send console output to a file on windows?
13:23:40 <edwardk> vanila: the issue i generally have with them is that you often need polymorphism in the way you use the substructural lattice in ways that is pretty awful to work with
13:23:42 <merijn> attapl? is that the Pierce's TaPL follow on?
13:23:51 <edwardk> merijn: yeah the book he edited after tapl
13:23:59 <merijn> ok, that was already on my list
13:24:09 <merijn> Although I should probably finish TaPL first one of these days...
13:24:15 <vanila> edwardk, that definitely sounds like a nightmare year
13:24:17 <vanila> yeah*
13:24:40 <edwardk> merijn: its a good book, lots of insights into other areas of type systems that pierce didn't get to cover in tapl
13:24:53 <edwardk> though finishing tapl would be more important =)
13:25:39 <mjrosenb> wat.  ghc is telling me i have conflicting definitions between .hs and .hs-boot
13:25:52 <mjrosenb> but they are the same.
13:26:28 <tabemann> are they being inferred to being from different package versions, something that GHC typically doesn't display to the user?
13:28:57 * hackagebot lxc 0.1.1 - High level Haskell bindings to LXC (Linux containers).  http://hackage.haskell.org/package/lxc-0.1.1 (NickolayKudasov)
13:28:58 * hackagebot git-annex 5.20140927 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20140927 (JoeyHess)
13:29:06 <CrazyM4n> http://sprunge.us/KPVV I feel so accomplished!
13:29:24 <mjrosenb> tabemann: all types are from this package.
13:29:42 <tabemann> then that can't be it
13:31:28 <zq> is it possible to get cabal to print the current dependencies of a project?
13:32:04 <codehero> @let trajectory x v a = ( (x * tan(a))) + (0.5 * (-10) * (x / (v * cos(a))**2))
13:32:05 <lambdabot>  .L.hs:166:1: Warning:
13:32:05 <lambdabot>      Pattern match(es) are overlapped
13:32:05 <lambdabot>      In an equation for ‘trajectory’: trajectory x v a = ...
13:32:05 <lambdabot>  
13:32:05 <lambdabot>  <no location info>:
13:32:17 <codehero> hmm
13:32:25 <codehero> @clear
13:32:25 <lambdabot> Maybe you meant: clear-auto-reply clear-messages clear-topic learn
13:32:31 <codehero> @help
13:32:32 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:32:38 <codehero> @reset
13:32:38 <lambdabot> Say again?
13:32:52 <codehero> i'm sad now. thank you lambdabot
13:32:55 <codehero> @list
13:32:56 <lambdabot> What module?  Try @listmodules for some ideas.
13:33:07 <codehero> @let trajectory x v a = ( (x * tan(a))) + (0.5 * (-10) * (x / (v * cos(a))**2))
13:33:08 <lambdabot>  .L.hs:166:1: Warning:
13:33:08 <lambdabot>      Pattern match(es) are overlapped
13:33:08 <lambdabot>      In an equation for ‘trajectory’: trajectory x v a = ...
13:33:08 <lambdabot>  
13:33:08 <lambdabot>  <no location info>:
13:33:11 <mauke> heh, @list is gone
13:33:16 <codehero> WHY?
13:33:37 <codehero> @let trajectory2 x v a = ( (x * tan(a))) + (0.5 * (-10) * (x / (v * cos(a))**2))
13:33:38 <lambdabot>  Defined.
13:33:46 <codehero> well. okay. ugly but dosn't matter
13:33:53 <codehero> > trajectory 8 9.5 (40 * pi / 180)
13:33:55 <lambdabot>  5.957522504912157
13:34:07 <codehero> > trajectory 3 9.5 (40 * pi / 180)
13:34:09 <lambdabot>  2.2340709393420592
13:34:13 <codehero> and it still doesn't work
13:34:15 <codehero> yaaay
13:34:24 <mauke> this isn't ghci
13:34:50 <tabemann> you're using trajectory, when you've defined trajectory2
13:34:58 <tabemann> you want @undefine trajectory
13:35:06 <mauke> undefine doesn't take arguments
13:35:16 <codehero> @undefine trajectory
13:35:17 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
13:35:23 <mauke> toldyouso
13:35:24 <codehero> @undefine
13:35:24 <lambdabot> Undefined.
13:35:33 <codehero> thank you :)
13:35:41 <codehero> @let trajectory x v a = ( (x * tan(a))) + (0.5 * (-10) * (x / (v * cos(a))**2))
13:35:42 <lambdabot>  Defined.
13:35:45 <codehero> > trajectory 3 9.5 (40 * pi / 180)
13:35:47 <lambdabot>  2.2340709393420592
13:35:58 <codehero> hmm
13:36:17 <mauke> @pl ( (x * tan(a))) + (0.5 * (-10) * (x / (v * cos(a))**2))
13:36:18 <lambdabot> x * tan a + x / (v * cos a) ** 2 * 0 . 5 * -10
13:36:33 <mauke> wow, pl doesn't understand fractional literals
13:37:03 <monochrom> oh, 0 . 5, hehe
13:37:08 <codehero> hmm. the order looks wrong
13:37:22 <mauke> yes, but at least all those parens are gone
13:37:29 <chrisdone> haskell's innovation of havings type sig decls compared with the inline stuff in ML is sooo good
13:37:46 <monochrom> on April 1st, lpaste's hlint should suggest: "you have 0.5, why not 0 . 5" :)
13:37:57 <codehero> lol :D
13:38:32 <chrisdone> monochrom: hehe
13:38:37 <codehero> maybe haskell uses the wrong type for the job?
13:38:37 <monochrom> chrisdone, ML has non-inline type sig decls too, but they belong to module sigs.
13:38:46 <chrisdone> "you have drop 1, why not tail?"
13:38:55 <codehero> @t trajectory
13:38:56 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
13:39:04 <CrazyM4n> I wonder how many people would take lpaste´s things for granted
13:39:08 <chrisdone> monochrom: does it have expression sigs?
13:39:10 <mauke> > 0xf0rd
13:39:11 <CrazyM4n> And it would ruin their code
13:39:12 <lambdabot>  Not in scope: ‘rd’
13:39:12 <lambdabot>  Perhaps you meant one of these:
13:39:12 <lambdabot>    ‘id’ (imported from Data.Function),
13:39:12 <lambdabot>    ‘C.id’ (imported from Control.Category),
13:39:12 <lambdabot>    ‘r’ (imported from Debug.SimpleReflect)
13:39:15 <codehero> thesaurus help
13:39:15 <chrisdone> like (foo :: Int)
13:39:18 <codehero> @thesaurus help
13:39:19 <lambdabot> Error: 550 invalid database, use SHOW DB for list
13:39:22 <codehero> lol
13:39:35 <monochrom> given that historical precedent, I would say that Haskell's type sig decls came from getting rid of ML modules
13:39:59 <chrisdone> blergh
13:40:09 <monochrom> ML has expression type annotations too
13:40:30 <TMVector> Hi, guys! What do you use as an IDE for writing Haskell?
13:40:31 <tabemann> that looked like a netsplit... except the message was "ping timeout: 260 seconds"... what the
13:40:37 <tabemann> EMACS
13:40:37 <Zekka> TMVector: Vim
13:40:38 <agatam> emacs..
13:40:41 <Zekka> (Emacs is good too)
13:41:06 <TMVector> Any good plugins for vim?
13:41:07 <monochrom> anyway, Haskell type decls may come from getting rid of ML modules and finding a new home for homeless type decls.
13:41:15 <mauke> > "scam" `isPrefixOf` reverse "emacs"
13:41:17 <lambdabot>  True
13:41:59 <bmuk> mauke: It's a conspiracy
13:42:25 <doismellburning> TMVector: I just use vim2hs
13:42:43 <chrisdone> monochrom: right. it's fortunate because it's so much better than mixing the types with the code
13:42:47 <mauke> > (map head . words) "escape meta alt control shift"
13:42:48 <lambdabot>  "emacs"
13:43:14 <chrisdone> and that whole "types over here in this module declaration or .h file" and "code here without types" thing is wacky
13:43:37 <monochrom> chrisdone, you are not supposed to write types inline in ML, you are supposed to write type decls in module signatures.
13:43:38 <tabemann> > (map head . words) "eight megabytes and constantly swapping"
13:43:40 <lambdabot>  "emacs"
13:43:50 <chrisdone> monochrom: right, that's even wackier
13:44:03 <monochrom> it's just a different culture
13:44:22 <chrisdone> it seems like IDE culture
13:44:34 <chrisdone> it assumes people can just hit a key to get the type
13:45:24 <monochrom> however, if you say, "why not do both, type decls in both module signatures and module implementations", then I guess I must agree.
13:45:49 <zq> ls
13:46:01 <monochrom> $
13:46:08 <sinelaw> cabal is totally screwed since I moved my homedir
13:46:08 <sinelaw> I tried deleting .cabal but even after that it seems to look for things in the old location
13:46:26 <chrisdone> .
13:46:26 <chrisdone> ..
13:46:27 <chrisdone> zq-selfies/
13:46:57 <monochrom> sinelaw, there are stuff under $HOME/.ghc, take a look.
13:47:13 * tabemann wonders if there's any IRC clients out there with a built-in shell
13:47:19 <monochrom> alternatively, read my http://www.vex.net/~trebla/haskell/sicp.xhtml
13:47:42 <lnostdal> hi, how would one do something like this:     formatTime defaultTimeLocale "%T" getCurrentTime >>= putStrLn
13:47:43 <monochrom> I hope not. it would be so vulnerable to shocking
13:47:44 <arbn> tabemann: Emacs
13:48:03 <mauke> getCurrentTime >>= ...
13:48:15 <sinelaw> monochrom, cool! thanks.
13:48:17 <monochrom> lnostdal: I think you're just missing a <$>. formatTime defaultTimeLocale "%T" <$> getCurrentTime >>= putStrLn
13:48:19 <tabemann> arbn:  yes, I forgot that Emacs is an operating system (and Linux is a device driver)
13:48:56 <mauke> getCurrentTime >>= putStrLn . formatTime defaultTimeLocale "%T"
13:48:58 * hackagebot ghcid 0.1.1 - GHCi based bare bones IDE  http://hackage.haskell.org/package/ghcid-0.1.1 (NeilMitchell)
13:50:55 <chrisdone> hehehe
13:51:03 <chrisdone> neil is gonna be sick of GHCi quickly
13:51:40 <hvr> why?
13:52:01 <monochrom> I want to know, too
13:52:28 <chrisdone> when he's used to the setup as part of his workflow and decides to extend it and realises GHCi isn't meant to be used programmatically
13:52:32 <Peaker_> Why are Rosetta code's Haskell examples trolled with terrible pointless code? :P
13:53:45 <monochrom> hmm, that may be true
13:53:48 <chrisdone> Peaker: IMO all rosetta haskell code examples should contain import Unsafe.Coerce and an implementation of a Data.Map-based histogram
13:54:02 <monochrom> I used to use the SML repl programmatically.
13:55:29 <Johannes13> @src join
13:55:30 <lambdabot> join x = x >>= id
13:55:51 <benzrf> more like
13:55:52 <tabemann> isn't the SML repl though closer to the normal source code, though, as in you can just paste in your source code and it will just work?
13:56:00 <benzrf> x >>= f = join (fmap f x)
13:56:16 <chrisdone> hvr: btw ghc-server is in pretty decent shape, but i think i need to borrow some things from GHCi. i tried loading in a large codebase with loadTargets and it segfaults half way through. GHCi doesn't, so i think there's some subtle configuration i'm missing. haven't touched it in a while, though. the segfault kinda ruined my mood
13:56:40 <monochrom> I used it this way. I wrote a Java program that needed the service of a theorem prover. I chose HOL4. HOL4 repl is simply SML repl plus loading up a lib, no magic. so my Java program talked to an SML repl, really. the commands I sent and the outputs I would get were restricted, it worked ok.
13:57:01 <tabemann> when they make Functor a superclass of Monad, will they also make it so that you can define monads in terms of join and fmap instead of in terms of >>= and return?
13:57:26 <benzrf> tabemann: one can only hope
13:57:54 <ion> tabemann: I hear not yet, due to including join in Monad having an unfortunate interaction with the roles feature or something like that, i don’t know the details.
13:57:58 <Johannes13> http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal#Missing_superclasses
13:59:52 <monochrom> there was only one magic I had to perform by myself. some theorem-prover commands may non-terminate. (it's a theorem prover.) I had to send SIGINT to abort those commands. Java doesn't let me do it to spawned processes. I wrote a C middleman for it. My Java program would send U+03 to the middleman, the middleman would send SIGINT to the theorem prover.
14:00:23 <monochrom> as a result, I'm proud to say that I have learned to write a select loop :)
14:02:10 <tabemann> I'd've probably've just written a JNI/JNA function to do that
14:02:56 <monochrom> yes, JNI should be better. I was too lazy to learn.
14:03:11 <monochrom> "man select" is so much easier :)
14:03:23 <Johannes13> JNA sounds easier - you don't have to write C
14:04:12 <tabemann> I've worked with JNI (never with JNA), and it was a pain to work with for any more than the most trivial things... but simply "send SIGNIT to process <id>" is pretty trivial
14:04:49 <tabemann> supposedly Sun made JNI deliberately hard to work with to discourage people from writing code that used it
14:05:27 <chrisdone> wait, a company acted unfairly?
14:05:36 <chrisdone> unsafePerformRadicalAssertion
14:05:51 <monochrom> JNA did not exist at that time. we're talking about Java circa 1.1. there was not even Swing.
14:06:11 <Peaker_> I wrote some Haskell code to generate all my JNI boilerplate for me
14:06:40 <Peaker_> (in a project I needed some JNI)
14:06:48 <chrisdone> classic
14:07:47 <lnostdal> what about this?      getCurrentTime >>= formatTime defaultTimeLocale "%T"         or          getCurrentTime >>= \x -> formatTime defaultTimeLocale "%T" x            doesn't seem to work; i'm trying to bind the result of this to a variable now
14:08:33 <monochrom> getCurrentTime >>= \x -> let y = formatTime defaultTimeLocale "%T" x in ...
14:09:10 <monochrom> alternatively, use do-notation. do { ... ; x <- getCurrentTime ; let { y = formatTime defaultTimeLocale "%T" x } ; ... }
14:13:37 <tabemann> couldn't you do y <- (formatTIme defaultTImeLocale "%T") <$> getCurrentTime
14:14:53 <lnostdal> what's <$>     ..?      i get "not in scope: `<$>`"    doing that
14:15:05 <Haskellfant> (<$>) = fmap
14:15:09 <geekosaur> import Control.Applicative
14:15:10 <lnostdal> i'm reading tutorials etc. atm
14:15:16 <Haskellfant> it's exported from Data.Functor or Control.Applicative
14:16:51 <beckyconning> hi i made haskell in snake! i mean... *cough* at the moment its like 170 lines and i'd love to see if anyone can make it shorter, more mathematically sound and or prettier. someone said something about golf. anyway, this is the first thing i've written in haskell so there is likely lots to fix so here is the repo : )
14:16:52 <beckyconning> https://github.com/beckyconning/haskell-snake
14:18:56 <monochrom> software is like snake. the more food you give, the longer it grows. until one day, it's so spaghetti, it runs into itself.
14:19:26 <beckyconning> *mind blown*
14:19:39 <lnostdal> thanks guys .. my first haskell web hack: http://4dwnre62brvfzj5l2bazq6kkztliskwnf6bzzh7z3nnsfqmrwckq.b32.i2p.us/ ..   heh, now i just need to figure all this out; it's hard to google some of this syntax sugar :>
14:20:22 <tabemann> lnostdal: but yeah, (<$>) is very useful for things like where you want foo >== \x -> return $ bar x, but want to avoid all the lambdas and like, so you can instead just have bar <$> foo
14:20:26 <monochrom> that looks more like a bitcoin address than a hostname :)
14:21:09 <Eduard_Munteanu> It is a darknet host.
14:21:09 <silver> i2p
14:21:15 <Qfwfq_> Assuming that's a HTTP gateway to an I2P service.
14:21:30 <silver> child porn there probably
14:21:55 <lnostdal> Qfwfq_: yeah, inproxy to i2p
14:22:15 <lnostdal> nice for testing stuff .. heh ..    i don't have to do port forwarding   android phone --> laptop
14:23:08 <Qfwfq_> Anyway, it's a web page that renders its own source code, no pornography to be seen.
14:23:29 <lnostdal> yeah, and it shows the server clock ..   yay
14:23:38 <tabemann> little nit - in Haskell we normally use camelCase for identifiers
14:24:30 <lnostdal> ok
14:24:36 <mkscrg> has anyone hit linker errors with unexposed modules in a cabal library?
14:25:07 <tabemann> also Data.ByteString.Char8 is kind of deprecated.... (even though I'm using it in a project myself)
14:25:41 <lnostdal> what do you use instead?    something wai related didn't want the String  type ......i think
14:26:02 <mkscrg> private modules Foo.Common.Bar and Foo.Common.Baz are re-exported in exposed module Foo.Common
14:26:22 <mkscrg> ld complains it can't find Foo.Common.Bar when linking the library against a test suite in the same project
14:27:01 <lnostdal> damn, this thing is quite fast ..  testing with apache bench now .. but only using 1 core
14:27:05 <gfixler> beckyconning: this is the *first* thing you've written in Haskell?
14:27:09 <freeman42> a function add 3 can be expressed as (+3) how can a function that adds 3 and then multiplies by 4 can be expressed in haskell in a similar concise way?
14:27:14 <beckyconning> gfixler: yes
14:27:31 <mkscrg> freeman42: (* 4) . (+ 3)
14:27:47 <gfixler> beckyconning: when did you start learnin Haskell?
14:27:50 <beckyconning> i mean, i did two homeworks from the yorgy course then i was bored so i made this
14:27:51 <freeman42> mkscrg, thank you :D functiona composition, it makes sense now
14:28:05 <gfixler> beckyconning: do you have an FP background?
14:28:07 <beckyconning> gfixler: i started three weeks ago
14:28:07 <mkscrg> freeman42: you're welcome!
14:28:15 <tabemann> lnostdal: I'd Use Data.ByteString.UTF8 (even though that's kinda deprecated itself), or Data.Text.Encoding (even though that requires converting through Data.Text first)
14:28:18 <napping> freeman42: I wouldn't take numeric expressions any farther
14:28:18 <mkscrg> has anyone seen those kinds of ld errors with cabal?
14:28:27 <lnostdal> ok, tabemann
14:28:30 <gfixler> beckyconning: that's a very impressive learning period, IMO
14:28:30 <beckyconning> gfixler: javascript : ) i've used lots of promises and stuff so i had a head start for sure
14:28:38 <tabemann> I'd probably just use Data.ByteString.UTF8.fromString here
14:29:03 <napping> tabemann: is there a better replacement for known ASCII data?
14:29:23 <beckyconning> gfixler: really? i thought i was being slow lol! thanks : )
14:29:54 <khumba> mkscrg, do you have the unexposed modules listed in other-modules?
14:29:55 <tabemann> well known ASCII data will produce an ASCII bytestring if you convert it with UTF8, due to those Unicode codepoints directly mapping onto the equivalent bytes of data
14:29:55 <gfixler> beckyconning: this is well beyond me, and I started back around Christmas
14:30:04 <gfixler> haven't made it to monads yet
14:30:15 <argent0> cabal exec 'ghc --version'
14:30:15 <argent0> cabal: The program 'ghc' version >=6.4 is required but the version of
14:30:15 <argent0> /usr/bin/ghc could not be determined.
14:30:22 <mkscrg> khumba: i don't
14:30:23 <beckyconning> i've had a lot of help from #haskell : )
14:30:33 <CrazyM4n> Has anyone had any luck getting SDL to work on windows?
14:30:33 <argent0>  I got that error trying to install ELM-lang. Any idea of what my be
14:30:34 <argent0>                           going on?
14:30:44 <khumba> mkscrg, try that; you need *all* modules listed in the cabal file.
14:30:56 <mkscrg> khumba: ouch
14:31:01 <gfixler> beckyconning: they are quite helpful
14:31:01 <mkscrg> khumba: that seems insane
14:32:06 <mkscrg> khumba: i do see that in the cabal user guide now. thanks for the heads up
14:32:08 <beckyconning> gfixler: did you play it? : D
14:32:23 <gfixler> beckyconning: not yet
14:32:26 <joof> CrazyM4n: http://jpmoresmau.blogspot.com/2010/05/haskell-sdl-on-windows-check-hacking.html
14:32:37 <khumba> mkscrg, so, it seems to be required for linking.  It's also definitely required if you want to upload your package to Hackage, because the tarball that "cabal sdist" creates won't include any modules not explicitly listed at some point.
14:32:42 <tabemann> lnostdal: oh I see it's using a *lazy* ByteString there
14:33:05 <tabemann> there is Data.ByteString.Lazy.UTF8 too
14:33:12 <mkscrg> khumba: yeah, that matches my limited understanding of how cabal works
14:33:16 <gfixler> beckyconning: looks like I'm missing some things
14:33:37 <tabemann> which you might want Data.ByteString.Lazy.UTF8.fromString instead of Data.ByteString.Lazy.Char8.pack
14:33:38 <beckyconning> could you tell me what they are so i can learn how to do a cabal file and add them to it?
14:33:39 <SwashBuckla> beckyconning: that's really cool
14:33:49 <gfixler> beckyconning: Could not find module `Control.Monad.Loops'
14:33:52 <mkscrg> khumba: from a higher level perspective, it seems like you shouldn't have to list every source file in a project...
14:34:07 <beckyconning> gfixler: thanks
14:34:23 <gfixler> beckyconning: I'm on ghc 7.6.3
14:34:24 <mkscrg> khumba: it's enough to make me consider keeping everything in the same directory and double compiling for the test-suite
14:35:02 <nitrix> What is this error? 'IO' is applied to too many types, in the type 'IO String()'
14:35:08 <nitrix> Neeeevermind.
14:35:09 <lnostdal> tabemann: yep, the lazy one works :)
14:35:17 <nitrix> I solved it, just didn't clear my buffer on IRC.
14:37:01 <beckyconning> SwashBuckla: thanks! : )
14:37:06 <khumba> mkscrg, still doesn't help with the Hackage issue, but yeah it's a pain for sure.  I'm using a git pre-commit script to ensure that all repo files are included in the sdist.
14:40:22 <SwashBuckla> beckyconning: I wrote a snake clone in Elm a while back: https://github.com/spanners/snake-elm
14:40:49 <SwashBuckla> I should add self-collision like you have done
14:40:51 <SwashBuckla> :)
14:41:17 <beckyconning> cool!
14:41:56 <nitrix> How do I invoke a function member of a record?
14:42:11 <nitrix> I tried endpointLocal.get with not success.
14:42:36 <mkscrg> khumba: got it, that makes a lot of sense for library repos
14:43:29 <tabemann> nitrix: get endpointLocal ...
14:44:11 <nitrix> Really?
14:44:13 <gigamonkey> I'm using Options.Applicative and defining a positional argument with a default value. I can do that like this:
14:44:16 <nitrix> tabemann: Where does the `get` comes from?
14:44:16 <gigamonkey> goal = argument str ( metavar "GOAL" <> help "The pants goal" ) <|> pure "compile"
14:44:29 <tabemann> nitrix: you named your member "get"
14:44:47 <gigamonkey> But the help string knows about GOAL and the help text but not about the default value.
14:45:10 <nitrix> tabemann: Right. Isn't that prone to name collisions though?
14:45:10 <gigamonkey> Is there some other way to provide a default value?
14:45:10 <beckyconning> gfixler: i worked out how to do cabal files and added the depends but there might still be some missing.
14:45:10 <tabemann> nitrix: yes - in each record in a module, each member name must be unique
14:45:25 <tabemann> so "get" isn't a very good name
14:45:25 <Clint> gigamonkey: showDefault
14:47:55 <tabemann> I typically name my records "<some identifier for type><name>" like "connManager" for a connection manager in a Connection type
14:47:55 <tabemann> if you prefix each of your record names you're less likely to have collisions
14:47:55 <mjrosenb> https://gist.github.com/29d4e79c56d83c29a4ef ok, any idea what is wrong here?
14:47:55 <tabemann> note that this seems like a pain for someone used to C, C++, Java, C#, etc. where each type has its own separate namespace
14:47:55 * mjrosenb is back where his laptop has internet!
14:50:40 <mjrosenb> tabemann: fwiw, C does not have namespaces
14:50:40 <nitrix> mjrosenb: C has namespaces, you're incorrect.
14:50:40 <gigamonkey> Clint: sweet, thanks
14:50:40 <nitrix> mjrosenb: But they are seen as tags actually.
14:50:40 <tabemann> mjrosenb: I mean that in C, each struct has its own internal namespace for its members, so you don't have to name all of your structs with non-colliding member names
14:50:40 <waynr> d
14:50:40 <mjrosenb> tabemann: ahh, that is true.
14:50:40 <nitrix> tabemann: It was indeed my first reaction. I suppose I'll get used to it.
14:50:40 <Sorella> tabemann: leave the names in the module itself, export lenses?
14:50:40 <nitrix> tabemann: I ended up with getPage and putPage for a Endpoint type.
14:50:40 <khumba> mkscrg, agreed though, would be awesome if cabal could detect that all for you.
14:50:40 <Sorella> Oh, though this doesn't solve the problem of having to solve the name collisions on the module importing yours
14:50:40 <beckyconning> how can i test to see if i have all the depends i need in a cabal package file?
14:50:40 <khumba> Guess things like the CPP extension make it difficult.
14:52:40 * mjrosenb doesn't really think of C structs as being namespaces, but that is certainly a valid viewpoint.
14:52:40 <tabemann> Sorella: they need to import your type qualified.... or better yet, don't expose your records to outside modules whenever possible
14:52:40 <Sorella> mjrosenb: the difference is mostly that people will use a projection operator for accessing fields in C, Haskell people will just compose functions that handle that part of the data structure.
14:52:40 <Sorella> PureScript and other languages that support extensible records will also use a projection operator, though.
14:52:40 <khumba> beckyconning, I thought building would fail if you're missing a dependency...  no?
14:54:42 <khumba> At least, that's been my experience; ghc or cabal tells me what package to add.
14:58:46 <beckyconning> khumba: good : ) just wanted to check.
14:58:50 <beckyconning> thanks
14:59:37 <khumba> yep!
15:04:32 <bitemyapp> I tried passing a multiline function to lambdabot for pointfree but it's not parsing it, despite it working fine in ghci.
15:04:39 <bitemyapp> it has nested do blocks in it.
15:04:43 <bitemyapp> any ideas?
15:04:55 <bitemyapp> @pl pipelineFn query = do a <- fetchFn query; case mapM decodeFn a of; (Left  err) -> return $ Left err; (Right res) -> do b <- makeIoOnlyObj res; return $ Right b
15:04:56 <lambdabot> (line 1, column 41):
15:04:56 <lambdabot> unexpected ';'
15:04:56 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
15:05:06 <bitemyapp> maybe I need to get rid of the $s?
15:05:35 <bitemyapp> @pl pipelineFn query = do a <- fetchFn query; case mapM decodeFn a of; (Left  err) -> return (Left err); (Right res) -> do b <- makeIoOnlyObj res; return (Right b)
15:05:35 <lambdabot> (line 1, column 41):
15:05:35 <lambdabot> unexpected ';'
15:05:35 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
15:05:40 <jle`> try brackets and stuff
15:05:45 <bitemyapp> jle`: I had those earlier, still barfed.
15:05:45 <jle`> sometimes that does something
15:05:49 <jle`> well
15:05:56 <jle`> try @. pl undo
15:06:01 <bitemyapp> I'll try them.
15:06:09 <bitemyapp> jle`: @. pl undo?
15:06:11 <bitemyapp> oh.
15:06:20 <bitemyapp> @. pl undo pipelineFn query = do a <- fetchFn query; case mapM decodeFn a of; (Left  err) -> return (Left err); (Right res) -> do b <- makeIoOnlyObj res; return (Right b)
15:06:21 <lambdabot> (line 1, column 69):
15:06:22 <lambdabot> unexpected '{'
15:06:22 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
15:06:27 <bitemyapp> @undo pipelineFn query = do a <- fetchFn query; case mapM decodeFn a of; (Left  err) -> return (Left err); (Right res) -> do b <- makeIoOnlyObj res; return (Right b)
15:06:27 <lambdabot> pipelineFn query = fetchFn query >>= \ a -> case mapM decodeFn a of { (Left err) -> return (Left err); (Right res) -> makeIoOnlyObj res >>= \ b -> return (Right b)};
15:06:55 <bitemyapp> @pl pipelineFn query = fetchFn query >>= \ a -> case mapM decodeFn a of { (Left err) -> return (Left err); (Right res) -> makeIoOnlyObj res >>= \ b -> return (Right b)};
15:06:55 <lambdabot> (line 1, column 69):
15:06:55 <lambdabot> unexpected '{'
15:06:55 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
15:07:10 <bitemyapp> jle`: come on. What cockamamie parser is it using?
15:07:27 <bitemyapp> that version also works fine from ghci.
15:08:01 <bitemyapp> pointfree barfs on it too, but less informatively.
15:09:25 <bitemyapp> @pl pipelineFn query = fetchFn query >>= \ a -> case mapM decodeFn a of { (Left err) -> return (Left err); (Right res) -> makeIoOnlyObj res >>= \ b -> return (Right b)}
15:09:25 <lambdabot> (line 1, column 69):
15:09:25 <lambdabot> unexpected '{'
15:09:26 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
15:09:43 <bitemyapp> @pl pipelineFn query = fetchFn query >>= \ a -> case mapM decodeFn a of (Left err) -> return (Left err); (Right res) -> makeIoOnlyObj res >>= \ b -> return (Right b)
15:09:44 <lambdabot> (line 1, column 82):
15:09:44 <lambdabot> unexpected '>'
15:09:44 <lambdabot> expecting operator
15:09:57 <bitemyapp> sorry, taking it to priv chat. Hoped somebody in here would know what I was doing wrong.
15:10:10 <prophile> I don't think @pl copes with case expressions
15:10:10 <sagittarian|2> what are you trying to do?
15:10:14 <prophile> try (|||) or either
15:10:20 <prophile> :t either
15:10:21 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
15:10:43 <sagittarian|2> :t (|||)
15:10:45 <lambdabot> ArrowChoice a => a b d -> a c d -> a (Either b c) d
15:11:00 <prophile> for a = (->), (|||) and either are equivalent
15:11:01 <bitemyapp> prophile: clean up somebody's code.
15:11:27 <sagittarian|2> what's an ArrowChoice?
15:11:36 <bitemyapp> prophile: I thought there was something neater than 'either'/||| possible because it looked like lifted bimap return + >>=
15:11:57 <bitemyapp> so that's what I was really trying to do but wanted a pointfree version to look at.
15:12:00 <sagittarian|2> man, haskell has too many types, can't we get by with just ints chars and lists?
15:12:09 <bitemyapp> I guess rewriting into either means I might get the pl version I want.
15:12:15 <kvanb> lol sagittarian|2
15:12:16 <srhb>  sagittarian|2 Try JS!
15:12:25 <kvanb> Hey, if you try JS you can have one type
15:12:34 <kvanb> it's an ADT with every type inside
15:12:35 <srhb> kvanb: Too slow. :P
15:12:40 <kvanb> and no compiler warnings!!!1111one
15:12:53 <mjrosenb> can .hs-boot not infer the role of a newtype, when its constructor is present?
15:12:55 <sagittarian|2> don't be hating on JS
15:13:02 <kvanb> it's my day job
15:13:05 <kvanb> I can hate on it if I want to
15:14:08 <mjrosenb> kvanb: js totally has multiple types.  they're basically meaningless, but it has types!
15:15:04 <sagittarian|2> JavaScript, keeping debugging interesting since 1995!
15:18:43 <tabemann> hmm to me languages like JavaScript are only interesting if the only typing you know about is that in, say, C, C++, Java, C#, etc. and are ignorant of type inference
15:21:52 <beckyconning> javascript is good. there are type systems you can add to it. the built in tag type things are next to rubbish though
15:22:24 <Sorella> mjrosenb:  JS is untyped eh
15:22:51 <Sorella> You can plug a type system on top of it (e.g.: Flow, which is logical types from Typed Racket, and TypeScript)
15:22:58 <shiona> well, I consider it typed, just very loosely
15:23:54 <beckyconning> Sorella: yeah : ) i like http://gcanti.github.io/tcomb/
15:24:21 <volty> hi, hxt, I have :   doc >>= \d -> runX . xshow $ d //> hasAttr "bgcolor"          // can smb. tell me how can I change that attribuite ?  (on found nodes, or on the whole doc)
15:24:53 <Sorella> Those look more like contracts than types to me
15:25:55 <Sorella> Higher-order and dependent contracts are fun too. Though you can't check most of it at compile time =/
15:25:56 <sagittarian|2> beckyconning: do you have a link for flow?
15:26:13 <sagittarian|2> oops, i mean Sorella
15:26:17 <tabemann> yeah, from looking at that that's not actually static types
15:26:52 <mjrosenb> Sorella: well, values have types, not variables.
15:27:03 <Sorella> sagittarian|2: Facebook hasn't released it yet. They gave a talk recently about it, and by what they described it's basically Typed Racket ported to JS. Sam Tobin-Hochstadt has plenty of papers on Typed Racket
15:27:09 * tabemann is having to work with groovy at work, and is rueing it, because so many bugs that would be caught at compile-time in Java are simply not caught until run-time in it
15:27:20 <sagittarian|2> okay thanks
15:27:23 <Sorella> (And I'm not sure I got his name correctly)
15:27:23 <beckyconning> sagittarian|2: https://code.facebook.com/atscale
15:27:58 <merijn> tabemann: But, but, dynamic!
15:27:59 <beckyconning> writing javascript without unit-tests is like, well, i never want to do it again lol!
15:28:36 <tabemann> merijn: I for one would give up the ability to dynamically add members to classes to have real static types, even if they're just those of Java
15:28:54 * mjrosenb is very surprised by how little javascript he knows.
15:29:04 <Cale> volty: I... might be able to remember well enough how to use HXT. :)  I think you want changeAttrValue
15:29:24 <tabemann> what annoys me about Groovy is that even though it does have optional type annotations, they're next to useless because they're only typechecked *at runtime* anyways
15:29:24 <shiona> tabemann: even better: I'm working with experimental technology in javascript. Every browser (and every version) seems to have different non-documented implementation
15:29:46 <Sorella> tablemann, you can add things dynamically to an object and check it statically: extensible records + row polymorphism <3
15:29:58 <kvanb_> dynamically typed languages are not shitty until you use something like Haskell
15:30:09 <kvanb_> the other guys in my group are like "so what" when I winge about javascript
15:30:20 <kvanb_> and they dont understand why I ask them to do compulsary javadoc type annotations on eveyrthing
15:30:24 <volty> Cale: thx, going to try
15:30:38 <Sorella> Only two languages with row polymorphism and extensible records I know are PureScript and Elm though, and the latter doesn't have higher-kinded polymorphism, which is a bummer
15:30:45 <Cale> volty: If you have trouble with it, I can probably install hxt and give it a shot myself
15:31:50 <tabemann> once you learn Haskell, all other languages are shit
15:32:07 <tabemann> except maybe Agda, Idris, etc.
15:32:17 <Cale> tabemann: Not entirely true, there are some other good languages... yeah, like Agda and Idris and such :)
15:32:38 <rom1504> ocaml
15:32:58 <rom1504> well let's not get in that troll, have fun
15:32:59 <volty> Cale: you are very kind but: no, thx — i am evaluating [working with] it - so if I cannot grasp it (or if I find myself frustrated) I'll go the old way
15:33:57 <napping> tabemann: there are a number of runtime things interesting independent of a type system - distribution, runtime code loading, tec
15:34:01 <napping> etc
15:34:02 <Cale> rom1504: Yeah, OCaml's pretty good too :)
15:34:06 * hackagebot rakhana 0.2.0.1 - Stream based PDF library  http://hackage.haskell.org/package/rakhana-0.2.0.1 (YorickLaupa)
15:34:06 <mjrosenb> rust seems pretty nice.
15:34:16 <tabemann> OCaml is like Haskell but impure, strict, lacking type classes or any other ad hoc polymorphism (except for comparison), and with parameterized modules
15:34:54 <mjrosenb> tabemann: and syntax that makes my skin crawl.
15:34:59 <tabemann> I'm not sure if parameterized modules are worth it with all that other stuff
15:35:17 <Cale> It seems a little bit sad that people designing new languages often seem just totally unaware of what's been going on in the last 20 years or so of programming language research.
15:35:31 <sagittarian|2> tabemann: so what's the difference between OCaml and java?
15:35:43 <napping> there's also row-variable polymorphism, used for records (classes) and variants
15:35:49 <tabemann> mjrosenb: when I worked in OCaml I found myself having add all kinds of extra begin...ends in places to deal with usability bugs in OCaml's syntax
15:36:05 <tabemann> sagittarian|2: what
15:36:10 <Cale> sagittarian|2: A lot. OCaml has pattern matching, you can reasonably do functional programming in it.
15:36:21 <sagittarian|2> ah java with pattern matching, got it
15:36:22 <vanila> Cale, it sucks :(
15:36:23 <sagittarian|2> so scala then
15:36:40 <Sorella> sagittarian|2: O'Caml works :D
15:36:41 <merijn> tabemann: You forgot structural subtyping
15:36:44 <Cale> sagittarian|2: No, it looks an awful lot more like Haskell than Scala does.
15:36:57 <LunarJetman> would you rather have a green clarinet or a red tuba? https://www.youtube.com/watch?v=a86R9nmwHj8#t=191
15:36:58 <Sorella> But subtyping is awful =/
15:37:06 <merijn> Sorella: No OO subtyping
15:37:09 <tabemann> merijn: that too
15:37:15 <troned> So when can we program smartphones with Haskell?
15:37:17 <merijn> Sorella: Structural subtyping is different from OO subtyping
15:37:28 <merijn> troned: Soonish, there's experimental ARM cross compilation support
15:37:37 <sagittarian|2> troned: i think you can now
15:37:42 <Sorella> merijn: eh, same thing, no? Don't you still lose information or something?
15:37:45 <LunarJetman> troned: I was part of the team that invented the smartphone.
15:37:48 * tabemann can't imagine how one could compare OCaml with Java
15:37:51 <sagittarian|2> isn't there ghc support for targeting ios?
15:37:53 <gfixler> beckyconning: http://lpaste.net/816275546970259456
15:37:57 <Sorella> Compared to structural typing with row polymorphism
15:38:00 <tabemann> the only thing the two have in common is that they are strict, impure, and have object systems
15:38:02 <troned> I mean for real. Writing professional apps, full support.
15:38:16 <merijn> troned: The more people test and help, the sooner it will be
15:38:24 <sagittarian|2> tabemann: impure, strict, lacking typeclasses is what you said
15:38:24 <gfixler> beckyconning: haven't used cabal before, but read up on getting the latest for it and did that first
15:38:38 <sagittarian|2> not knowing any more, i thought it sounded like java
15:38:40 <Sorella> (TypeScript uses structural subtyping as well, afaik)
15:38:41 <troned> merijn, where do I help?
15:38:43 <tabemann> sagittarian|2: well the vast majority of languages out there are likw that
15:38:46 <tabemann> *like
15:39:02 <Cale> sagittarian|2: Those also apply to, e.g. scheme
15:39:11 <beckyconning> gfixler: thanks for giving it another go, does anyone else have any ideas about this error? http://lpaste.net/816275546970259456
15:39:17 <sagittarian|2> true, but scheme ahs macros, so all is forgiven
15:39:20 <tabemann> pure and lazy are exceptions rather than the rule, so to lump languages together just because they are impure and strict is to ignore a lot of other characteristics that they have
15:40:04 * tabemann kind of forgot that OCaml had an object system, since it is rarely used, and he himself never used it when he worked in OCaml
15:40:22 <Sorella> sagittarian|2: the major problem with Scheme macros is that they don't compose
15:40:40 <arboris> ocamls module system is much better compared to typeclasses
15:40:48 <merijn> troned: Go to https://ghc.haskell.org/trac/ghc/wiki/Platforms check the ARM build links, try it out, report bugs/problems/help expand the docs
15:40:50 <vanila> Sorella, how do you mean they don't compose? you can make macros that expand into more macros
15:40:51 <gfixler> beckyconning: could it be the age of my ghc?
15:40:53 <napping> tabemann: I don't think it's popular among O'Caml programmers, but it's one of the more interesting language features for someone coming from Haskell
15:41:00 <sagittarian|2> okay, so what other languages *are* pure and lazy?
15:41:09 <arboris> miranda
15:41:20 <tabemann> clean
15:41:21 <vanila> sagittarian|2, haskell is the only lazy language
15:41:22 <napping> tabemann: I'm not sure about classes, but the object types themselves are basically just row-variable polymorphism
15:41:26 <gfixler> beckyconning: 7.6.3 - current default in Ubuntu 14.04 for the haskell-platform package
15:41:28 <Cale> arboris: They're technically equivalent, but are more useful for different tasks
15:41:44 <mkscrg> anybody have experience converting between ByteString.Builder and Blaze.ByteString.Buidler?
15:41:50 <bjz> vanila: seems like a pretty sweeping claim to make
15:42:08 <arboris> hm, no they are not, they become almost equivalent if you throw in newtype and type families
15:42:21 <arboris> but even then they are more straightforward to use
15:42:23 <gfixler> beckyconning: cabal-install version 1.21.1.0
15:42:28 <bjz> sagittarian|2: Ocaml doesn't have inheritance, afaik. Also, from what I hear the 'O' in Ocaml isn't actually used all that much. So yeah, in practice very much not like Java.
15:42:31 <mkscrg> seems like blaze, compiled with a newer bytestring, should offer a converter...
15:42:49 <beckyconning> gfixler: try pulling the latest?
15:42:57 <napping> arboris: then why are modules not used for things like Eq and Ord very much at all?
15:43:04 <beckyconning> gfixler: i removed the 4.7.x.x version thingies
15:43:07 <Cale> arboris: http://www.cse.unsw.edu.au/~chak/papers/modules-classes.pdf
15:43:31 <tabemann> in practice type classes are much more useful to use for many things, and parameterized modules are kind of heavy-handed and coarse-grained in what they can do
15:43:38 <tabemann> even if they are theoretically more poweful
15:43:42 <tabemann> *powerful
15:43:55 <napping> much nicer for actually combining parameterized implementations of things
15:44:20 <arboris> Cale, well as I said if you throw in type families or whatever they are called
15:44:24 <Cale> Yeah, for example, making use of the monad abstraction when multiple monads are involved is much more awkward with parameterised modules than with type classes.
15:44:25 <arboris> originally they were not
15:45:48 <tabemann> one key advantage of type classes over parameterized modules is that type classes type-infer while parameterized modules do not
15:45:50 <mjrosenb> can I ask cabal to pass in a particular flag for a single file?
15:45:58 <Cale> tabemann: Right, exactly
15:46:00 <gfixler> beckyconning: I pulled latest, threw out the cabal file, did `cabal sandbox init` and `cabal install --dependencies-only` and got the same error
15:46:34 <gfixler> btw, my cabal tutorial here uses both --dependencies-only and --only-dependencies - not sure which is correct
15:46:37 <merijn> tabemann: OTOH, being able to depend on a generic "ByteString" (lazy or strict), etc. would be pretty cool
15:46:40 <Cale> Type classes enable type-directed computation, where the inferred type decides what code is used.
15:46:41 <mjrosenb> so, parameterized modules can be nice for some things, but ocaml gets it wrong.
15:46:51 <beckyconning> gfixler: : ( sad! i wish i could get these errors! i did the same and it works here
15:47:04 <gfixler> beckyconning: which versions of things are you using?
15:47:19 <tabemann> merijn: there have been multiple attempts at creating type classes incorporating string-like functionality, such as one aptly named StringLike
15:47:22 <beckyconning> "The Glorious Glasgow Haskell Compilation System, version 7.8.3 "
15:47:35 <merijn> tabemann: I have higher hopes for backpack
15:47:36 <arboris> hm, I think you could actually rather easily define a module that composes two compatible monads into one
15:47:49 <gfixler> beckyconning: maybe that's it; I'm on 7.6.x
15:47:57 <arboris> and then exposes the new bind and return
15:48:54 <beckyconning> gfixler: do you know what version of base that is?
15:48:59 <tabemann> merijn: what's that?
15:49:03 <arboris> napping: because it is more efficient to use non polymorphic instances
15:49:10 <gfixler> beckyconning: I'm not sure what base is
15:49:23 <mjrosenb> beckyconning: I suspect that you specified a base much more recent than you need.
15:49:54 <beckyconning> mjrosenb: i think you're right but obvs i haven't tested on an earlier one... how do you find out your base version?
15:50:01 <Enigmagic> ghc-pkg list base
15:50:04 <arboris> and it is also rather inconvenient
15:50:08 <mjrosenb> beckyconning: base>=4.6.0.1 will probably work.
15:50:38 <gfixler> mjrosenb: this feels like it could use a binary-search build tool
15:50:50 <beckyconning> gfixler: could you do ghc-pkg list base, change the base version in the cabal file to that and then try again? dw if thats too much to ask but it would be nice to know it works on the default ubuntu one : )
15:51:41 <merijn> tabemann: See these posts: http://blog.ezyang.com/category/haskell/backpack/
15:52:15 <beckyconning> gfixler: it would be super cool if you did it as a pull-request too to get the pull-request train started : D
15:52:18 <gfixler> beckyconning: I had 4.6.0.1, as mjrosenb suggested
15:52:46 <arboris> Cale: The paper does not describe how Ocaml Functors are translated, or does it?
15:53:08 <gfixler> beckyconning: changed it to that, redid the sandbox, built with --only-dependencies, and it built!
15:53:25 <arboris> oh ok sorry it does
15:53:33 <mjrosenb> gfixler: the error message cabal-install spat out said exactly what version you have :-)
15:53:50 <gfixler> mjrosenb: I need to remember that I can read things
15:54:31 <beckyconning> gfixler: awesome : )
15:55:31 <gfixler> beckyconning: forked, updating, will send PR
15:55:41 <beckyconning> gfixler: eee! : D
15:56:20 <Cale> arboris: It says that (recursive) functors correspond to (recursive) instance declarations
15:56:40 <beckyconning> #internet
15:57:44 <arboris> Cale: ok, to get the full power Functors you would have to allow OverlappingInstances, right?
15:58:13 <gfixler> beckyconning: PR sent
15:58:14 <Cale> arboris: Possibly, I'm not entirely sure.
15:58:42 <Cale> arboris: There are many cases where this translation wouldn't even be particularly appropriate and you might want to do something entirely different not involving type classes at all.
15:59:10 <Cale> Or even just a little different, using dictionary records in place of instances.
15:59:37 <tabemann> back
15:59:52 <Cale> But similarly, there are many type classes which are just plain inconvenient to use when translated to modules
16:00:48 <tabemann> apparently many people really don't use parameterized modules when programming in MLs, and given up on attempts to make code use them (just because it turns out to be so inconvenient)
16:00:51 <beckyconning> internet success story
16:01:00 <Cale> As others pointed out, a major advantage of type classes over e.g. records of functions or indeed modules, is that instance selection is automatic, and interacts nicely with type inference.
16:01:50 <Cale> Sometimes you don't *want* that automatic instance selection, because you want there to be more than one instance per type
16:01:56 <tabemann> and when one *really* needs different instances, there still always is newtype... which is inconvenient, but less inconvenient on average than having to use parameterized modules everywhere
16:02:17 <arboris> Cale, i've been reading Hindley-Milner Elaboration in Applicative Style by Pottier and what he does there seems rather involved to express in haskell while maintaining the same clean separation
16:02:17 <Cale> But yeah, there's either newtype, or just moving to something which isn't type classes
16:02:33 <pharaun> so if you want to manually decide the instances/etc use record, if you want automatic and there's 1 "correct" instance for each type, typeclass ?
16:02:46 <Cale> pharaun: Roughly, yeah
16:03:49 <tabemann> mind you that type classes compile to just passing around dictionaries anyways... but is more convenient, because those dictionaries are implicit, and is faster, because whenever possible that dictionary-passing is optimized away
16:04:07 <pharaun> hence the "1 correct instance" thing ?
16:04:17 <pharaun> or is there a different reason for this
16:04:49 <arboris> essentially he gives an implementation of Hindley Milner Type inference via constraint solving, exposing the constraint language only as a library
16:05:02 <arboris> via combinators
16:05:12 <arboris> i'm sure it is possible to do the same in haskell
16:05:18 <Cale> pharaun: Well, there is a style which you can use where you go with type classes anyway, and use newtypes to aid selection of instances. QuickCheck does a bunch of that.
16:06:04 <Cale> That can often work out well when there's one "primary" instance, and then you have some less common variations on it
16:06:05 <arboris> Cale, instance selection to be automatic is morally never right
16:06:16 <Cale> hm?
16:06:22 <tabemann> hence types like Any and All (for Bool) and Sum and Product (for numbers)
16:06:57 <Cale> arboris: It's really convenient, and sometimes that convenience is practically required in order to make certain notations usable.
16:06:59 <tabemann> so you can have more than one Monoid instance for Bools, and more than one Monoid instance for numbers
16:08:01 <Cale> and notation really does matter -- if you had to pass an additional parameter to every occurrence of (>>=), it would make the monad abstraction practically unusable.
16:08:04 <tabemann> there's a reason people rarely really use ML parameterized modules, and when they do, only use it for very coarse-grained cases
16:08:13 <tabemann> Cale: exactly
16:08:23 <pharaun> Cale: ah i see
16:08:29 <Cale> and at the same time, the way that modules select the instance makes using different monads in the same scope really awkward
16:10:11 <arboris> yes, but that is a practical matter, there is just not one absolute value defined on the rational numbers for example, there is the ordinary one up to scaling and then there are the p-adic ones
16:10:22 <arboris> there is not one right instance
16:10:35 <tabemann> then you have newtypes corresponding to each case
16:10:48 <arboris> well but that involves an arbitrary choice
16:10:52 <arboris> so it is morally wrong
16:10:53 <tabemann> and those cases are the exception rather than the rule
16:11:11 <arboris> of course in practice it is ok
16:11:15 <tabemann> but it is practically right
16:11:27 <Cale> arboris: I'm not sure I agree with that definition of morality
16:11:39 <Cale> But all right :)
16:11:59 <Cale> (It's interesting that it seems to be a bit different from the sort of morality that category theorists use)
16:12:00 <arboris> category theorists also use evil if someone uses equality instead of isomorphisms
16:12:12 <vanila> unsafeEquality
16:13:25 <merijn> It's paths all the way down!
16:13:57 <merijn> (Whoo! I learned something from Bob Harper, even if only obscure HoTT jokes)
16:14:17 <gfixler> to a haskell newb like me, this cabal thing seems awfully messy
16:14:20 <mjrosenb> boo, grapefruit-frp doesn't have any tests.
16:14:48 <bitemyapp> Given:  Monad m => Query -> IO (EitherT Err m (IO [(SomeObj, IoOnlyObj)]))
16:14:51 <gfixler> I'm following a tutorial just to get sandboxes working, but it's not working
16:15:13 <bitemyapp> can I get IO (Either Err [(SomeObj, IoOnlyObj)]) without pattern matching?
16:15:35 <bitemyapp> That's ostensibly the point of the EitherT but can't figure out how to use the functions from `either` to make it hap'n
16:15:49 <bitemyapp> I end up just rederiving some variation of runEither $ liftM in my attempts to use those functions.
16:16:14 <Cale> bitemyapp: You want to specialise m to Identity?
16:16:29 <Cale> er...
16:16:41 <bitemyapp> Cale: no, not that.
16:16:42 <Cale> Or maybe to IO, and then join at the end
16:16:59 <bitemyapp> Cale: well the problem is it's m1 (m2 (m1 ...)
16:17:00 <benmachine> things I did not know: instance forall a. C (Maybe a) where ... is valid syntax
16:17:09 <bitemyapp> Cale: m1 == IO
16:17:12 <benmachine> and means apparently exactly what it means if you leave the forall out
16:17:22 <bitemyapp> with the case match I can bind the function I'm apply
16:17:24 <bitemyapp> applying*
16:17:28 <mjrosenb> so... has anyoe acutally build grapefruit with ghc7.8.3?
16:20:54 <lpaste> bitemyapp pasted “No title” at http://lpaste.net/111749
16:21:09 <bitemyapp> there's the original version of the function that I'm trying to clean up.
16:21:35 <bitemyapp> the branches look silly to me though: (Left err) -> return $ Left err
16:22:02 <bitemyapp> and the Right match looks like bind over applying the fn to the contents, then return $ Right
16:22:07 <bitemyapp> that seems like boilerplate.
16:22:12 <merijn> bitemyapp: Pretty sure the m1 (m2 (m1 pattern isn't a problem...
16:22:48 <bitemyapp> merijn: I'm trying to get to IO (Either e a) without the case expression.
16:23:32 <bitemyapp> merijn: first attempt was with transformer, but doesn't seem to have changed things much.
16:23:34 <merijn> :t \x -> x >>= (\y -> y >>= (\z -> z >>= (\r -> return (return r))))
16:23:35 <lambdabot> (Monad m1, Monad m) => m (m (m a)) -> m (m1 a)
16:23:39 <merijn> hmm
16:23:41 <merijn> Not quite
16:24:04 <merijn> ok, too lazy to figure that out
16:24:09 <bitemyapp> -_-
16:25:04 <merijn> bitemyapp: I think you want like traverse + join
16:25:10 <merijn> :t T.traverse
16:25:12 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
16:25:23 <bitemyapp> oh that's a good idea.
16:25:39 <merijn> :t \f xs -> join $ T.traverse f xs
16:25:40 <lambdabot> (Traversable m, Applicative m, Monad m) => (a1 -> m a) -> m a1 -> m a
16:25:46 <merijn> eh
16:25:59 <merijn> right
16:26:30 <merijn> oh, wait, I guess that's like fmap traverse
16:26:44 <merijn> :t \f xs -> join (T.traverse f <$> xs)
16:26:46 <lambdabot> (Traversable t, Applicative m, Monad m) => (a -> m b) -> m (t a) -> m (t b)
16:27:02 <bitemyapp> merijn: didn't even need the join.
16:27:07 <merijn> I give up, I would have to first write it out and then simplify, but that sounds like work
16:27:19 <gfixler> newb question: once I've gotten cabal build to work, what do I do with the output? (3 tutorials have ended there)
16:28:01 <merijn> gfixler: Depends on what you mean? Once cabal build is done, it's compiled your stuff
16:28:17 <gfixler> merijn: right, but my stuff was a game
16:28:22 <athan> What would you call a function of a type `a -> Sum`, where Sum is just an arbitrary sum type? monomorphic? Polymorphic? :S
16:28:23 <merijn> gfixler: the dist directory should hold the libraries/executable you build
16:28:24 <gfixler> what do I run to then play what I built/
16:28:38 <bitemyapp> @pl pipelineFn query = do a <- fetchFn query; traverse makeIoOnlyObj (mapM decodeFn a)
16:28:38 <lambdabot> (line 1, column 41):
16:28:38 <lambdabot> unexpected ';'
16:28:39 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
16:28:44 <bitemyapp> @undo pipelineFn query = do a <- fetchFn query; traverse makeIoOnlyObj (mapM decodeFn a)
16:28:45 <lambdabot> pipelineFn query = fetchFn query >>= \ a -> traverse makeIoOnlyObj (mapM decodeFn a);
16:28:59 <gfixler> merijn: is setup-config what I want?
16:29:02 <bitemyapp> @pl pipelineFn query = fetchFn query >>= \ a -> traverse makeIoOnlyObj (mapM decodeFn a);
16:29:02 <lambdabot> (line 1, column 85):
16:29:02 <lambdabot> unexpected ';'
16:29:02 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
16:29:09 <bitemyapp> @pl pipelineFn query = fetchFn query >>= \ a -> traverse makeIoOnlyObj (mapM decodeFn a)
16:29:09 <lambdabot> pipelineFn = (traverse makeIoOnlyObj . mapM decodeFn =<<) . fetchFn
16:29:31 <Hijiri> gfixler, you can just run them
16:29:36 <Hijiri> they're binaries
16:29:37 <merijn> gfixler: Look somewhere under "dist/build/"
16:29:55 <Hijiri> dist/build/bin, or dist/bin or something
16:29:59 <bitemyapp> merijn: glorious. Thank you very much for reminding me traverse existed.
16:30:05 <gfixler> merijn: there's an autogen folder
16:30:16 <gfixler> with a .hs and .h file
16:30:36 <merijn> gfixler: Is your cabal file online somewhere?
16:30:48 <gfixler> it's beckyconning's snake game
16:30:55 <Hijiri> I think the dist/build/projectname folder has the executable
16:31:03 <gfixler> this is bizarre
16:31:06 <Hijiri> I tried cabal building some random project
16:31:09 <merijn> gfixler: assume I have no memory of anything said above the top of my screen :)
16:31:14 <Hijiri> it has both an autogen and projectname folder
16:32:01 <gfixler> http://lpaste.net/7519620624348610560
16:32:08 <gfixler> what is any of that?
16:32:25 <merijn> That's not the cabal file :)
16:32:35 <gfixler> dist-sandbox seems to be a copy of its containing folder
16:33:13 <gfixler> https://github.com/beckyconning/haskell-snake/blob/master/Snake.cabal
16:33:16 <gfixler> merijn: ^^
16:33:34 <merijn> gfixler: Ah, simple answer
16:33:43 <gfixler> we'll see about that :)
16:33:45 <merijn> gfixler: That doesn't build an executable, so there's nothing to wrong
16:33:49 <merijn> s/wrong/run
16:33:50 <gfixler> d'oh
16:33:51 <codygman> ghci seems to have hung on a function I'm debugging and the memory usage keeps rising. This is with ghc 7.8.3, anyone experinced this?
16:34:00 <codygman> hung on a breakpoint I should say
16:34:43 <gfixler> merijn: looks like I've lots more reading to do on cabal - thanks
16:34:46 <codygman> "Stopped at src/MyModule/MyFile.hs", then doesn't return to the ghci prompt, keeps consuming memory... about to Ctrl+c it because it's using 78% of my 8GB ram.
16:34:56 <merijn> gfixler: See this for example definition of an executable https://github.com/haskell/c2hs/blob/master/c2hs.cabal#L78-L90
16:35:09 <codygman> Odd, after ctrl c I can access the variables
16:35:21 <merijn> gfixler: The code even defines a main action, you just need to tell cabal to build a program :)
16:35:55 <gfixler> merijn: I'm about 15 minutes into my usage of cabal, so... gfixler :: MegaNewb
16:36:25 <merijn> gfixler: Basically a cabal file can contain 0 or 1 libraries and 0 or more executables to build
16:36:35 <merijn> They have slightly different options
16:36:42 <gfixler> 1 libraries max?
16:36:56 <merijn> Per package, yes
16:37:24 <gfixler> that link you sent shows what seems to be 4 dependencies
16:37:51 <merijn> gfixler: Correct
16:38:36 <merijn> gfixler: I think you just need "Executable snake" instead of Library and a "main-is" field
16:40:38 <beckyconning> gfixler: i fixed it : )
16:41:11 <beckyconning> gfixler: https://github.com/beckyconning/haskell-snake/commit/89c727e74cbececf9328b5fe66251ac169248008
16:41:16 <gfixler> beckyconning: d'oh - I was halfway through doing that :)
16:41:40 <beckyconning> gfixler: oh cool! thanks!
16:42:15 <ezrios> what exactly do `tell`, `listen`, and `pass` in the Writer monad do?
16:42:19 <beckyconning> gfixler: sorry for beating you to it lol! it might have too recent dependency versions though so maybe you could try it on yours and see?
16:42:27 <gfixler> beckyconning: this is my first Haskell collaboration, meager as it may be
16:42:38 <beckyconning> gfixler: me too! exciting!
16:43:00 <gfixler> \o/
16:43:18 <freeman42> teach a man how to fish and... how do you figure out how to convert a Char to Integer? could only find digitToInt :: Char -> Int on hoogle
16:43:45 <gfixler> beckyconning: that was a much longer dependency install
16:43:45 <ezrios> freeman42: what would such a function do
16:43:49 <ezrios> return the ASCII value?
16:43:50 <shachaf> Which integer do you want to convert it to?
16:44:11 * hackagebot haskell-src-meta 0.6.0.8 - Parse source to template-haskell abstract syntax.  http://hackage.haskell.org/package/haskell-src-meta-0.6.0.8 (BenMillwood)
16:44:11 <ezrios> or are you only interested in Chars '0', '2', ..., '9'
16:44:25 <ezrios> if it's the latter you could easily define such a function by cases
16:44:33 <erikd> @hoogle Num a => [Char] -> a
16:44:35 <lambdabot> Prelude error :: [Char] -> a
16:44:35 <lambdabot> Data.List genericLength :: Num i => [b] -> i
16:44:35 <lambdabot> Debug.Trace trace :: String -> a -> a
16:44:45 <freeman42> ezrios, working on this solution https://dl.dropboxusercontent.com/u/25584776/ShareX/2014-09/2014-09-28_00-43-08.png using show I can get "123" from 123, next I had to map to Integer the char array
16:44:50 <gfixler> beckyconning: it works! I ran right into the wall, as I was trying to use hjkl for navigation
16:45:08 <beckyconning> haha! i use vim too! maybe i should have made it use those hjkl : P
16:45:09 <erikd> @hoogle Integral a => [Char] -> a
16:45:09 <lambdabot> Prelude error :: [Char] -> a
16:45:09 <lambdabot> Debug.Trace trace :: String -> a -> a
16:45:09 <lambdabot> Network.BufferType buf_fromStr :: BufferOp a -> String -> a
16:45:30 <erikd> @hoogle read
16:45:31 <lambdabot> Prelude read :: Read a => String -> a
16:45:31 <lambdabot> Text.Read read :: Read a => String -> a
16:45:31 <lambdabot> GHC.IO.Device read :: RawIO a => a -> Ptr Word8 -> Int -> IO Int
16:46:03 <beckyconning> i wanted to use the arrow keys but they were coming up as \esc and after an hour of trying to find a simple way of working it out i gave up and used wasd
16:46:09 <freeman42> ezrios, shachaf convert as in '1' -> 1 :: Integer
16:46:23 <shachaf> What happens to '+'?
16:46:33 <ezrios> @let charToInt '1' = 1
16:46:35 <lambdabot>  Defined.
16:46:50 <ezrios> @let charToInt '2' = 2
16:46:52 <lambdabot>  Defined.
16:47:10 <ezrios> > map charToInt "121212"
16:47:12 <lambdabot>  [1,2,1,2,1,2]
16:47:14 <freeman42> ezrios, there has to be an easier way :D
16:47:22 <ezrios> freeman42: this is quite easy
16:47:31 <fizruk> :t Data.Char.digitToInt
16:47:32 <lambdabot> Char -> Int
16:47:40 <freeman42> it would be defining 10 cases
16:47:45 <arboris`> freeman42, digitToInt does not do what you want?
16:47:54 <gfixler> beckyconning: yeah, escape in the term is fun - had to use <^[-h> etc for Vim mappings that wanted Alt
16:48:00 <ezrios> @info digitToInt
16:48:00 <lambdabot> digitToInt
16:48:06 <ezrios> thanks lambdabot
16:48:18 <freeman42> arboris, this is a problem on codewars https://dl.dropboxusercontent.com/u/25584776/ShareX/2014-09/2014-09-28_00-47-12.png
16:48:32 <freeman42> they enforce the sigature to be digitize :: Integer -> [Integer] through tests
16:48:44 <arboris`>  > fromEnum 'c'
16:48:46 <ezrios> freeman42: how else would you define this function
16:48:53 <ezrios> except by cases
16:48:54 <beckyconning> gfixler: i made the same game in 9 (contentious) lines of ruby and it was pretty easy to get the arrow keys but haskell didn't like them lol
16:49:05 <shachaf> ezrios: It's the same thing that happened last time you told lambdabot to @info something.
16:49:17 <freeman42> ezrios, I honestly don't know, just assuming there is a better way
16:49:23 <gfixler> beckyconning: 9 - that sounds fun to read
16:49:33 <fizruk> :t Data.Char.ord
16:49:34 <lambdabot> Char -> Int
16:49:37 <beckyconning> gfixler: _contentious_ : P
16:49:39 <fizruk> :t ord
16:49:40 <lambdabot> Char -> Int
16:49:45 <fizruk> > ord ‘1’
16:49:46 <lambdabot>  <hint>:1:5: lexical error at character '\8216'
16:49:53 <arboris`> @info fomEnum
16:49:54 <lambdabot> fomEnum
16:49:55 <fizruk> argh
16:49:55 <gfixler> beckyconning: I once made a 7-line Pac-Man world in AS, and a month later couldn't understand any of it
16:49:59 <beckyconning> gfixler: they are valid lines no ;s or anything and all the syntax is in the ruby docs but they are very long : P
16:50:04 <ezrios> freeman42: http://hackage.haskell.org/package/base-4.7.0.1/docs/src/Data-Char.html#digitToInt
16:50:05 <beckyconning> gfixler: https://gist.github.com/beckyconning/2fc52b23bb52491a88f2
16:50:10 <arboris`> argh why does he not know fromEnum
16:50:19 <ezrios> looks like this goes off ascii
16:50:21 <fizruk> > ord '1'
16:50:23 <lambdabot>  49
16:50:27 <gfixler> beckyconning: but it created a random maze, made a pac-man, took input, allowed movement, handled wall collisions, and turned pac to face the move direction
16:50:39 <fizruk> > ord '9'
16:50:40 <lambdabot>  57
16:50:42 <beckyconning> gfixler: wow that sounds badass : )
16:51:00 <arboris`> anyways you can do what a c programmer does and use fromEnum c - fromEnum '0'
16:51:11 <gfixler> beckyconning: yes, the lines were just like these
16:51:22 <gfixler> 200 chars long
16:51:30 <nshepperd> > fromEnum '0'
16:51:31 <arboris`> that does work because Ascii characters are ordered such that 0..9 are consecutive
16:51:32 <lambdabot>  48
16:51:32 <gfixler> but valid, singular expressions
16:51:54 <ezrios> arboris`: what happens if I specify a character not in [0..9]
16:52:03 <arboris`> obviously you will get nonsense otherwise
16:52:32 <beckyconning> gfixler: this one is like 2028 i think lol!
16:53:19 <ezrios> guess it's a toss up, do you want undefined or nonsense
16:53:20 <arboris`> so if you are not guaranteed that the input contains only digits, you could filter it for example
16:55:30 <arboris`> if you want to only convert a single char, you can easily define a function Char -> Maybe Int
16:55:33 <arboris`> that is safe
16:56:30 <freeman42> ezrios, just looking for a simple solution assuming all are in '0'-'9' range
16:56:50 <merijn> @hoogle Char -> Int
16:56:51 <lambdabot> Data.Char digitToInt :: Char -> Int
16:56:51 <lambdabot> Data.Char ord :: Char -> Int
16:56:51 <lambdabot> Graphics.UI.GLUT.Callbacks.Window Char :: Char -> Key
16:56:59 <merijn> > digitToInt '1'
16:57:01 <lambdabot>  1
16:57:16 <merijn> freeman42: Hoogle is your friend :)
16:57:38 <freeman42> merijn, it has to be Int(eger), that is the problem :)
16:58:03 <merijn> freeman42: What is? The fact that it returns Int?
16:58:07 <yyttr3> I'm trying to create a system to work with finite fields (like GF(23)). I think i'm going about it all wrong. How do I encode finite data types? https://gist.github.com/yyttr3/6dfd015cf016a130139c
16:58:23 <freeman42> merijn, yeah, it is a problem on codewars https://dl.dropboxusercontent.com/u/25584776/ShareX/2014-09/2014-09-28_00-47-12.png
16:58:26 <merijn> yyttr3: Don't use datatypecontexts :(
16:58:39 <merijn> yyttr3: There's a reason they were removed in Haskell2010, they're dumb
16:58:50 <yyttr3> I know, that's why i'm using GADTs now
16:58:59 <merijn> freeman42: fromIntegral
16:59:01 <arboris> @hoogle Integral a => a -> Integer
16:59:02 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
16:59:02 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
16:59:02 <lambdabot> Prelude floatRadix :: RealFloat a => a -> Integer
16:59:10 <merijn> :t fromIntegral . digitToInt
16:59:12 <lambdabot> Num c => Char -> c
16:59:19 <merijn> :t fromIntegral . digitToInt :: Char -> Integer
16:59:20 <lambdabot> Char -> Integer
16:59:59 <arboris> but that will blow up in your face if you give it a character that is not '0'..'9'
17:00:00 <yyttr3> The ModuloGroup, I was trying to define an addition table..
17:00:25 <merijn> arboris: Sure, but he asked for the simple case
17:01:01 <merijn> freeman42: If numerical types are not the one you want, you have two friends
17:01:05 <arboris> also it converts 'a'..'f' into 10..15
17:01:09 <merijn> fromIntegral and realToFrac
17:04:21 <dubosec> So, I am considering installing Hakyll, and the installation tutorial has some text I am supposed to type into something. I know this is probably a silly question with an obvious answer, but where am I supposed to type this text to install hakyll?
17:04:42 <merijn> dubosec: Which OS?
17:04:47 <dubosec> Windows 7
17:04:53 <dubosec> I already have the Haskell Platform
17:05:24 <arboris> try powershell
17:05:25 <dubosec> I am supposed to type cabal install hakyll, preceded by a dollar sign
17:05:30 <merijn> dubosec: Right, you'll want to open a shell (cmd.exe) and type it there. Although I would *strongly* recommend installing powershell as cmd.exe sucks
17:05:31 <arboris> :)
17:05:46 <zipper> dubosec: That can't be for windows
17:05:46 <arboris> isn't that installed by default
17:05:52 <arboris> it is
17:05:52 <merijn> dubosec: $ is the default shell prompt on *nix (the equivalent of "C:\>" in cmd.exe)
17:05:54 <zipper> dubosec: Unless you have bash on windows
17:05:56 <arboris> except $
17:05:59 <zipper> I may be wrong
17:06:02 <freeman42> merijn, it passes the tests ^^ https://dl.dropboxusercontent.com/u/25584776/ShareX/2014-09/2014-09-28_01-03-00.png thank you
17:06:02 <arboris> shouldnt be typed
17:06:10 <merijn> zipper: The tutorial is assuming *nix, most likely
17:06:50 <dubosec> should I get bash  instead of powershell, then?
17:06:53 <zipper> merijn: The preceeding by a dollar sign says it all.
17:07:06 <zipper> dubosec: Look for a windows specific tutorial.
17:07:24 <merijn> zipper: Why? cabal commands are identical on windows
17:07:32 <zipper> I have no idea how windows works anymore.
17:07:44 <arboris> dubosec: haskell platform should have installe cabal.exe in your path
17:07:45 <zipper> merijn: I didn't know that. I shall shut up now.
17:07:49 <arboris> hopefully
17:08:03 <merijn> dubosec: oh, powershell apparently is already installed on Windows 7, so I take back my cmd.exe and say use that :)
17:08:26 <merijn> arboris: It did for me, although it's been awhile since I used haskell on my desktop
17:08:43 <zipper> merijn: Where do you use haskell?
17:08:56 <dubosec> That's nice to know. Er, how do I use cabal to install hakyll? I looked at the folders that were included in the Haskell platform, and there's nothing obvious about cabal
17:09:03 <dubosec> right now I just use the gchi
17:09:06 <arboris> merijin: yeah the last time i used haskell with windows i was surprised how well it worked
17:09:10 <dubosec> *ghci
17:09:26 <arboris> dubosec: open powershell
17:09:30 <merijn> dubosec: 1) open powershell/cmd.exe 2) type "cabal help" 3) report what happens
17:09:44 <merijn> zipper: My macbook and servers
17:09:49 <dubosec> oh
17:09:56 <dubosec> it lists a bunch of helpful info
17:10:02 <zipper> dubosec: cabal install <package-name> is the unix way and if merijn is right it should work on windows too.
17:10:13 <merijn> dubosec: Right, so cabal is installed and in your path. Just run "cabal install hakyll" and cross fingers
17:10:13 <arboris> dubosec: Alternatively 1) install linux in a vm 2) ... 3) profit
17:10:24 <dubosec> oh, I get it now. So I just use my command line to do all of this
17:10:36 <arboris> dubosec, yes
17:10:39 <zipper> dubosec: Yes
17:10:41 <merijn> dubosec: I'm no aware of any GUI tools for cabal, so yes
17:10:50 <arboris> powershell is actually fairly cool
17:11:00 <dubosec> I am working on getting linux back on my machine. I had it on here about two or three months ago, but I ran out of space to keeping using it, or at least to keep using the distribution I had (openSUSE)
17:11:06 <arboris> it understands c# objects instead of only strings I believe
17:11:20 <zipper> arboris: I run zsh I don't know about powershell but I know zsh wins. :)
17:12:01 <arboris> well as I said, it supports passing arbitrary objects between commands, instead of just strings
17:12:07 <merijn> zipper: powershell integrates with .NET and COM objects, so it can directly manipulate those. Which, if you're a .Net/windows person, is pretty useful compared to other shells
17:12:07 <Welkin> nobody uses powershell
17:12:09 <arboris> so it is technically superior
17:12:24 <dubosec> Thanks everone! It all makes sense now
17:12:31 <dubosec> or at least that part does
17:12:35 <merijn> Welkin: Spoken as someone who's not done system administration in a windows environment :)
17:12:35 <arboris> in principle
17:12:41 <arboris> i've never used it
17:12:49 <merijn> Welkin: When I did system admin stuff powershell was used all the time
17:13:14 <arboris> actually a typed shell language would be really cool
17:13:24 <Welkin> if you don't use any windows products, powershell is useless
17:13:36 <Welkin> microsoft*
17:13:38 <zipper> merijn: Sys admin in a windows environment.
17:13:46 <merijn> arboris: Go write your own shell :)
17:13:46 <zipper> That would be my worst nightmare.
17:13:50 <zipper> LOL
17:14:02 <arboris> have better things to do
17:14:10 <arboris> plus it would not integrate well with unix
17:14:20 <merijn> zipper: You say, that, but after doing that (about 1500 desktops) I would *much* rather admin a windows environment like that than *nix
17:14:33 <merijn> I prefer *nix for servers, but certainly not for desktops
17:15:29 <zipper> merijn: Yes for people's desktops yes windows is much easier. Linux is so hard to config for people even in a small office.
17:15:31 <arboris> zipper: they use similar tools to what linux distros provide by default
17:15:54 <arboris> the machines are configured via a central server with only a limited number of configurations
17:16:21 <arboris> if something goes wrong they are simply restored from a fresh image
17:16:43 <tabemann> on the desktop when using windows I prefer to just install cygwin, as I prefer to use the command line, but cmd.exe is a pain, the default installed tools are useless, and I know the GNU toolset much better than whatever's available through powershell anyways
17:16:46 <arboris> i'm doubtful that it would be much easier with linux
17:17:14 <tabemann> at home I just use Linux on the desktop, even if that means things like no Microsoft Office etc.
17:18:22 <merijn> Anyway, let's try to slowly circle back to on topic :p
17:18:34 <zipper> tabemann: I use linux on my desktop but I would die if I had to explain linux to people.
17:18:47 <zipper> merijn: Yes please do :)
17:19:46 <hardydash> Linux is like a being given a ferarri for free, it just takes time to learn how to drive it.
17:21:02 <yyttr3> Can you change your language to haskell on code wars?
17:21:34 <rom1504> hardydash: and windows is a no-licence car
17:23:50 <jr_> Hey guys, I'm supposed to parse a list of tuples and add the snd element's together. I've managed to do it as strings, but I can't seem to be able to sum these guys together. Can anyone look at my code and give me a suggestion? http://pastebin.com/9kHSujm6
17:25:19 <arboris> jr_: why do you use show?
17:25:20 <tabemann> what're you doing with "show" there?
17:25:44 <arboris> also don't use length, that is linear in the list length
17:25:53 <jr_> arboris: tabemann their end result needs to be a string.
17:26:06 <arboris> well then do the sum
17:26:10 <arboris> and then show that
17:26:25 <gfixler> arboris: is it smart enough to not walk past the first element if we're doing == 0?
17:26:31 <jr_> arboris: sum of what? I don't know how to specify a list of 2nd elements of tuple
17:26:32 <tabemann> makeTotal = show . sum . map snd
17:26:55 <jr_> tabemann: thanks
17:26:58 <arboris> you could also use a fold
17:27:27 <gfixler> jr_: is this homework intended to get you familiar with pattern matching or similar?
17:27:29 <benzrf> arboris: thats effectively a fold
17:27:32 <benzrf> thanks to laziness :-D
17:27:35 <arboris> depending on how smart the compiler is sum . map snd won't be fused into one traversal
17:27:49 <benzrf> ghc is pretty smart.
17:27:55 <arboris> i know
17:27:57 <jr_> gfixler: yes. I am essentially making a calculator. This is just a small part of the overall assignment.
17:28:04 <arboris> and it probably will do that
17:28:20 <gfixler> jr_: it's neat that you can compose functions together, but it might be better to understand your version and fix it, for the learning
17:28:22 <jr_> I was thinking of using foldl but I'm not sure about how to go about using it
17:28:25 <arboris> i thought i would just mention that in principle he could try to write a custom fold for practice
17:28:41 <jr_> gfixler: yes
17:28:44 <merijn> arboris: I'm about 100% sure "sum . map snd" is one traversal due to laziness
17:28:49 <merijn> arboris: Don't even need fancy fusion
17:28:59 <arboris>  well that is great
17:29:07 <benzrf> jr_: do you Grok foldr
17:29:13 <benzrf> it's far more important than foldl!
17:29:17 <benzrf> possiblby
17:29:25 <Cale> merijn: Well, if you don't do fusion, you still pay allocation costs you'd rather not, but it will fuse anyway
17:29:26 <jr_> benzrf: I don't know what that is,
17:29:28 <merijn> arboris: The real question is if fusion will turn it into O(1) memory too, if the input list is lazy
17:29:30 <benzrf> :t foldr
17:29:32 <lambdabot> (a -> b -> b) -> b -> [a] -> b
17:29:46 <benzrf> jr_: foldl walks along a list from left to right, eating it
17:29:48 <Cale> Well, it's O(1) memory because of laziness too!
17:29:56 <merijn> Cale: Sure, I'm not saying you don't want fusion
17:30:02 <arboris> merijn: right, and a strict left fold would be constant in memory
17:30:02 <benzrf> jr_: foldr does a tablecloth trick with the list constructors
17:30:03 <Cale> But the allocation costs are twice as high as without
17:30:06 <merijn> Cale: oh yeah, you'r right
17:30:17 <benzrf> jr_: data List a = Nil | Cons a (List a), right?
17:30:19 <gfixler> jr_: what did your teacher go over so far - patterns and recursion only?
17:30:33 <tabemann> you really only want foldr if your function is lazy, and you want foldl' if your function is strict, if direction doesn't matter
17:30:57 <arboris>  > :t foldl'
17:31:05 <tabemann> :t foldl'
17:31:06 <arboris> hm how does lambdabot work
17:31:07 <lambdabot> (b -> a -> b) -> b -> [a] -> b
17:31:12 <jr_> gfixler: he doesn't really go over anything...lol. Uhm we are using a book he has written.built in types, higher order functions, and sequences
17:31:22 <benzrf> oh
17:31:23 <benzrf> jr_: well
17:31:31 <jr_> yeah...
17:31:33 <arboris>  > foldl' (+) 0 [1,2,3,4,5]
17:31:34 <benzrf> jr_: every list is either empty ([]) or a const (1:something)
17:31:34 <benzrf> right?
17:31:36 <dfeuer> Well, yes, but ... sometimes you want to use foldr and play weird games.
17:31:47 <pjdelport> arboris: http://www.haskell.org/haskellwiki/Lambdabot
17:31:47 <jr_> benzrf: yes
17:31:49 <tabemann> the difference between foldl and foldl' is that fold' is strict, and doesn't explode your memory, whereas foldl is lazy, and has the tendency to explode your memory
17:31:56 <jr_> well, except a list of one element
17:31:59 <tabemann> *foldl'
17:32:11 <benzrf> jr_: a list of one element is elem:Nil
17:32:16 <jr_> ah
17:32:19 <jr_> that's right
17:32:20 <benzrf> jr_: foldr replaces each cons with your function and each empty with your starting value
17:32:23 <jr_> the way lists work, i forgot
17:32:27 <jr_> yeah
17:32:28 <arboris> or rather elem:[]
17:32:47 <dfeuer> Except that GHC is good at making foldl not explode when things are simple enough.
17:32:47 <benzrf> jr_: so `foldr (+) 0 (1:2:3:4:[])' becomes `1 + 2 + 3 + 4 + 0'
17:32:48 <pjdelport> foldr (:) [] == id
17:32:52 <pjdelport> (for lists)
17:33:08 <jr_> okay
17:33:26 <benzrf> jr_: once you get used to it it's easier to reason about!
17:33:28 <benzrf> debatably
17:33:34 <jr_> ohhh, so. If I foldr of all snd for the len
17:33:36 <benzrf> it's lazier anyway!
17:33:42 <benzrf> @src foldl
17:33:42 <lambdabot> foldl f z []     = z
17:33:42 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
17:33:43 <benzrf> @src foldr
17:33:44 <lambdabot> foldr f z []     = z
17:33:44 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:33:55 <jr_> erm, no it wouldnt work
17:33:57 <arboris> foldr (\(_,x) r -> x + r) 0
17:33:57 <jr_> hmm
17:34:02 <benzrf> notice how it replaces [] with z and (:) x xs with f x xs
17:34:05 <benzrf> er
17:34:07 <tabemann> foldr (+) 0 (1:2:3:4:[]) is 1 + (2 + (3 + (4 + 0))), i.e. it has the tendency to explode your stack when used with a strict function like (+)
17:34:11 <benzrf> f x (foldr f z xs)
17:34:11 <arboris> should work
17:34:37 <tabemann> note that it is kosher to use foldr with a lazy function like (:)
17:34:39 <gfixler> jr_: your makeTotal function was basically an implementation of a fold, done with pattern matching and recursive calls
17:34:48 <jr_> yeah
17:34:53 <gfixler> you can manually write it out the way you did - nothing wrong with that
17:35:04 <jr_> oh really?
17:35:05 <gfixler> or use the generalization of the idea, which is fold
17:35:19 <jr_> so
17:35:25 <gfixler> jr_: yep - look at the src of foldl benzrf showed up there
17:35:42 <tabemann> @src foldl'
17:35:42 <lambdabot> foldl' f a []     = a
17:35:42 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
17:36:09 <gfixler> it's a little messy looking, but it's the same - handle the empty list, or do the function on the first item, then recursively on the rest of them
17:36:38 <gfixler> the recursion will terminate when the 'rest of them' is empty, and the empty list patern matches
17:36:47 <tabemann> the `seq` means that it forces the equation of the result of f a x, so it doesn't build up thunks in memory
17:37:14 <gfixler> jr_ left
17:37:16 <arboris> he left..
17:37:26 <dfeuer> BOOM
17:37:37 <gfixler> the haskell hug was too much
17:38:19 <gfixler> http://nyulocal.com/wp-content/uploads/2014/03/sad-cat.jpg
17:39:04 <arboris> irc clients need inline image support
17:39:54 <zomg> arboris: I think there's a few hipster irc clients which have that
17:40:07 <gfixler> arboris: that could get intense
17:40:11 * tabemann sometimes wishes that functions could mark in their type signatures which arguments they force
17:40:31 <arboris> like ones build with node-webkit
17:40:33 <tabemann> wait, that doesn't work
17:41:14 <arboris> it would be nice if there were strict and lazy kinds
17:41:29 <arboris> would that work?
17:41:57 <tabemann> because it doesn't tell you whether it is strict on intermediate values, as foldl' is
17:42:18 <Hijiri> comic chat renders the text as images
17:42:20 <Hijiri> does that count
17:42:38 <arboris> that doesn't seem useful
17:42:43 <gfixler> what's wrong with strictFoldl?
17:42:57 <gfixler> or foldlStrict?
17:43:00 <arboris> that is putting the type in the name
17:43:12 <arboris> or part of it
17:43:13 <gfixler> strict is the type?
17:43:28 <gfixler> I thought it was just the implementation
17:43:28 <arboris> part of what should be encoded not in the name
17:43:39 <gfixler> I suppose it does get messy
17:43:45 <gfixler> if you have 3 args, and the middle one is strict
17:43:48 <arboris> hm no not really there is a real difference between lists and streams
17:43:55 <gfixler> or does that even make sense?
17:44:01 <gfixler> if any arg is strict, is the entire function strict?
17:44:15 <gfixler> where is the strictness?
17:44:34 <tabemann> that's why it'd be necessary to mark each individual argument as strict, but that doesn't work either, because what about strictness on passed in function's results but not the functions themselves?
17:44:58 <arboris> ghc has strictness annotations, right?
17:45:03 <arboris> so in principle it is there
17:45:07 <tabemann> and even marking that as strict doesn't work either, because what if a function is evaluated more than once, with different arguments, one time strict and one time lazy?
17:45:08 <rudi_s> I have a general "display" method which displays the current state of my program (a -> IO ()). Now I want to use it UI.NCurses, but that uses Curses () (which embeds IO ()). Can I somehow pass the Curses as IO so the signature of my display methods doesn't have to change?
17:45:45 <Hijiri> If Curses is an instance of MonadIO you can use liftIO
17:46:29 <rudi_s> Hijiri: It is. But how does that work? I can use liftIO to access the IO monad, but I want to pass a function with a signature of a -> Curses ().
17:46:30 <tabemann> arboris: but the idea is so that you can clearly document whether functions are strict on different arguments or not, a property that is very useful to use, but generally not documented
17:46:49 <arboris> tabermann: Clean supports that
17:46:59 <Hijiri> liftIO can change an IO a value to any MonadIO m => m a value
17:47:22 <Hijiri> so you can just make an IO action and stick liftIO on the front, and it'll be whatever MonadIO
17:47:31 <arboris> I think it has four variants of Lists for example
17:47:43 <arboris> head strict, tail strict, strict and lazy
17:47:58 <tabemann> so you can have foo :: MonadIO m => m () ; foo = liftIO $ launchMissiles
17:48:33 <merijn> rudi_s: The haskell ncurses wrapper (and just ncurses itself) are pretty painful, if you wanna do terminal UIs, you may wanna look into vty-ui
17:48:33 <rudi_s> Hijiri: So I change the type signature of my display function to take a MonadIO and then use liftIO to access the IO instance?
17:48:57 <Hijiri> :t liftIO
17:48:58 <lambdabot> MonadIO m => IO a -> m a
17:49:10 <Hijiri> I don't know what you mean by access the IO instance
17:49:17 <Hijiri> IT wouldn't take a MonadIO
17:49:18 <merijn> rudi_s: vty is a pure haskell implementation of curses like terminal drawing and vty-ui is a library on top of it that provides you with widgets like buttons, text fields, etc.
17:49:38 <rudi_s> Hijiri: Well. I have a -> Curses () and pass that to a function which takes a a -> IO (), I don't see how liftIO helps here.
17:49:49 <Hijiri> oh, you can't do that
17:49:58 <Hijiri> well, I don't know enough about the curses library
17:50:01 <Hijiri> or ncurses
17:50:05 <rudi_s> merijn: Please don't get me wrong, but I had bad experience with "pure haskell" reimplementations of stuff. Starting with haskeline ..
17:50:17 <rudi_s> And I know curses.
17:50:39 <Hijiri> you can't do it in general, but maybe there's something specific for curses
17:50:56 <tabemann> maybe there's a runNCurses somewhere
17:51:00 <rudi_s> Hijiri: Hm. I see. Haven't found anything in the curses docs though.
17:51:23 <tabemann> at some point you have to have NCurses a -> IO a
17:51:50 <rudi_s> tabemann: Yeah. There's runCurses, but that resets the terminal after leaving the function.
17:52:07 <tabemann> rudi_s: well yeah, runCurses wraps everything else
17:52:55 <rtn> does anyone know where I can learn about wxHaskell in detail
17:54:06 <tabemann> rudi_s: why do you want to have Curses a -> IO a?
17:54:16 * hackagebot lxc 0.2 - High level Haskell bindings to LXC (Linux containers).  http://hackage.haskell.org/package/lxc-0.2 (NickolayKudasov)
17:54:34 <tabemann> is it because you want to run Curses in a different thread? or inside catch? etc. etc. etc.
17:55:02 <tabemann> I can really see wanting to use Curses inside catch for one
17:56:03 <rudi_s> tabemann: My idea was to support multiple "output" modes and to provide a simple "display" function which displays the current state. Without curses that works fine (just putStrLn), but with curses I must wrap the whole program in a runCurses and then can't use a -> IO () as signature for my display function because curses requires a -> Curses ().
17:56:19 <rudi_s> My program updates the state and calls display when necessary.
17:56:58 <tabemann> call your display function inside your Curses monad with liftIO $ display state
17:58:01 <rudi_s> tabemann: Sure, that works. But my problem is that I don't want to call "display" from inside the curses monad, but from my normal program which doesn't know anything about the output method.
17:59:24 <Laquendi> rudi_s: your whole program needs to be inside curses or it'll reset the terminal constantly
17:59:45 <arboris> rudi_s, just make display :: MonadIO m => a -> m ()
18:00:02 <rudi_s> Laquendi: I know.
18:00:22 <arboris> m = IO is then a special case
18:00:34 <rudi_s> arboris: Ah, nice. That looks good. Thank you.
18:03:29 <tabemann> note that inside display, if it does anything with the IO monad, you need to put liftIO inside wrapping that
18:05:12 <arboris> depending on how you set things up, you could then either pass in the right function, or write a typeclass
18:06:38 <rudi_s> Thanks. Just one more question. Do I have to change all .. -> IO () of the surround function (which call display) to MonadIO m => ... -> m () as well?
18:06:49 <rudi_s> *surrounding
18:07:35 <tabemann> yes
18:08:00 <rudi_s> Good, thank you.
18:08:31 <arboris> depending on your editor it should be really easy to see what has to be changed
18:08:38 <arboris> once you change the signature
18:23:47 <rudi_s> Hm. I still have one issue though. If I want to use forkIO to run part of the program in another thread, I can't use forkIO because it returns a IO (), and not just a MonadIO.
18:24:16 <shachaf> Returns?
18:24:31 <geekosaur> rudi_s, what you said makes no sense...
18:24:37 <shachaf> Ah, the "part of the program" has type IO ()
18:24:38 <geekosaur> IO is the "base" MonadIO
18:24:44 <shachaf> Or, rather, it doesn't.
18:25:25 <rudi_s> geekosaur: Still learning the basics. What I meant was that I can't run forkIO with an action in the Curses monad.
18:27:17 <rudi_s> Either I'm missing something or it seems to be not possible to call a function in the Curses monad from somewhere outside (e.g. from another thread). I guess that's expected, but makes designing a program with multiple output "backends" a little difficult for me.
18:27:19 <khumba> rudi_s, then you can use liftIO to convert your IO () into the MonadIO m => m () of your choice :).
18:27:48 <geekosaur> mm. not sure that'd work anyway, C curses/ncurses not very thread safe
18:28:08 <tabemann> put the body of your program *inside* your output code
18:28:10 <shachaf> You should ask your question very explicitly if you want people to be able to reconstruct what's going on.
18:28:14 <tabemann> and call it from each individual type of output
18:28:31 <shachaf> "I have x :: A, y :: B, and I want the following behavior."
18:29:41 <tabemann> there's probably a reason the ncurses bindings force you to do everything within the Curses monad
18:30:02 <tabemann> including preventing you from running it across different threads
18:30:44 <geekosaur> as I said; it's not threadsafe, and in general it's a very poorly behaved library
18:31:06 <tabemann> generally UI code is not thread-safe anyways
18:31:18 <rudi_s> Yeah. I think so too. - But then I'm interested what would be a good way to separate the calculation part from the output part? Basically my function is a endless-loop which reads data and calculates some values which I want to display.
18:32:03 <rudi_s> And in some configurations that output should be just the terminal (putStrLn) and sometimes curses or maybe gtk or whatever.
18:32:08 <tabemann> put your calculation part in a different thread, and communicate with your display thread through MVars, Chans, or STM
18:33:08 <rudi_s> Hm. My first attempt was using Mvars, Chans but the code felt a little ugly and unstable. I guess I'll have to try that again.
18:33:42 <rudi_s> Thank you all for your suggestions.
18:34:21 <arboris> rudi_s: if you have multiple output methods you could even add a process that has a "subscription" channel
18:34:28 <Fuuzetsu> http://fuuzetsu.co.uk/images/1411867994.png sydney opera house
18:34:32 <tabemann> remember - threads are really lightweight in Haskell
18:35:28 <tabemann> rudi_s: one thing to look at is TQueue with STM - you get the benefits of STM, and yet it is faster than Chan
18:35:30 <arboris> that fans out the data to all listeners
18:35:43 <tabemann> the only disadvantage of TQueue is you can only have one reader
18:36:28 <rudi_s> arboris: For now static configuration is enough, but thanks for the suggestion.
18:36:38 <tabemann> use Chan or TChan though if you need multiple listeners
18:36:38 <rudi_s> tabemann: Haven't used STM yet, will have a look. Thanks.
18:36:58 <tabemann> STM's really neat
18:38:27 <merijn> Yu should prefer Chan if you have many concurrent threads
18:38:42 <merijn> tabemann: "faster than Chan" is an oversimplification
18:38:52 <merijn> The reality is "it depends"
18:39:50 <tabemann> Chan has better performance with higher, well, fan-out than TChan or TQueue?
18:40:07 <merijn> Also, TQueue is not even always better than TChan, it has amortised O(1) append and access, but that means the latency of individual operations can spike a lot
18:40:26 <tabemann> so TQueue has poor realtime characteristics
18:40:31 <merijn> tabemann: It has better performance if you have many blocked listeners, STM suffers from thundering herd problem
18:40:59 <napping> which is TQueue?
18:41:04 <merijn> MVar writes will only ever wakeup a single blocked thread (and therefore the same applies to Chan), TVar will wakeup *all* blocked threads
18:41:36 <tabemann> Chan is non-STM arbitrary listener channels, TChan is STM arbitrary listener channels, TQueue is STM single listener channels
18:42:13 <merijn> tabemann: That's not true
18:42:20 <merijn> You can have arbitrary listeners for TQueue
18:42:25 <dmj`> unagi chan looks cool: https://hackage.haskell.org/package/unagi-chan
18:42:52 <tabemann> merijn: but you can't clone an TQueue
18:43:04 <napping> you can still have multiple threads listening from it
18:43:51 <tabemann> except those threads will each get a random subset of that written to the TQueue, with each item getting received by a single thread, right? i.e. can't be used for broadcast
18:43:56 <napping> yeah
18:44:20 * hackagebot xml-push 0.0.0.15 - Push XML from/to client to/from server over XMPP or HTTP  http://hackage.haskell.org/package/xml-push-0.0.0.15 (YoshikuniJujo)
18:45:07 <tabemann> it seems it can only be used in that way if you *want* each item to be received by a single thread, and you don't care which thread that is
18:45:08 <pharaun> so if i don't need to do STMy thing, Chan may work better?
18:46:07 <napping> sure, it's an important restriction, but that's not exactly what "single listener" suggest to me
18:46:24 <napping> it's not like things segfault or lose messages entirely if you try to listen from multiple threads
18:47:05 <napping> pharaun: yeah, but one the other hand that's only if you have multiple/many threads listening
18:47:39 <napping> If it's a broadcast channel a thundering herd isn't really a problem because you do want all threads to wake up and take an item
18:47:46 <pharaun> true
18:47:47 <napping> take the same item, rather
18:48:15 <napping> But something like dispatching work items to several worker threads, that's where Chan and MVar's block behaviour is exactly what you want
18:48:38 <pharaun> what bout 1 worker, and multiple server
18:48:47 <tabemann> pharaun: that's what STM is good for
18:48:50 <napping> merijn: Do you have any idea what a worst-case O(1)
18:48:56 <napping> would do for performance?
18:49:12 <tabemann> readTQueue server1 `orElse` readTQueue server2 `orElse` readTQueue server3
18:49:12 <pharaun> tabemann: kk
18:49:17 <pharaun> ya
18:49:21 <napping> pharaun: I think that would work fine either way, if it's an unbounded queue
18:49:31 <napping> at least if you mean all the servers pushing into the same queu
18:49:35 <pharaun> tho i have all severs inject into same queue
18:49:44 <pharaun> they push their data + reply queue into the queue
18:49:55 <pharaun> then i process the data and send it back to the server using the reply queue they pushed to me
18:50:02 <tabemann> okay, for that, Chan would work too
18:50:04 <napping> checking blocking on several different sources is exactly what STM is for, though
18:50:39 <pharaun> napping: right, i kinda forgot since :) but yeah chan is what i probably want
18:50:56 <pharaun> been a while since i've read the async/parallel book
18:51:22 <tabemann> for what you're doing, Chan, TChan, and TQueue would all work
18:51:26 <dmj`> Chan is a linked list of MVars
18:51:50 <napping> and TChan a linked list of TVars
18:51:57 <pharaun> cool, good enough for me
18:52:02 <tabemann> and if you've got a single listener and don't care about realtime characteristics, TQueue would work well, whereas Chan is slower, and TChan is even slower
18:52:21 <pharaun> yeah iirc i went with TQueue
18:52:38 <pharaun> since single listener and etc
18:52:43 <tabemann> TQueue is a pair of lists in a TVar
18:52:56 <napping> I'd say it's a purely functional queue in a TVar
18:53:10 <napping> stuff like worst case O(n) comes from the choice of data structure
18:53:37 <pharaun> i should double check the queue i'm using but for my app i think any should suffice till i start focusing on speeding up the whole thing
18:54:56 <napping> Yeah, it's just good to know general guidelines on where the queues are probably suitable.
18:55:16 <napping> Not too worry too much about any particular example
18:56:33 <CrazyM4n> Does SDL 2.0 work with haskell right now?
18:57:53 <dmj`> Crazy4Mn: https://hackage.haskell.org/package/sdl2 ?
18:58:04 <dmj`> CreazyM4n: ^
18:58:07 <dmj`> whatever
18:58:13 <CrazyM4n> Does it work well?
18:58:15 <dmj`> can't spell for beans
18:59:07 <dmj`> CrazyM4n: you should try it out, if it doesn't, make it work well and submit a pull to the author
18:59:16 <napping> CrazyM4n: Have you tried something and it's broken? It think the SDL package are pretty decent bindings, but I don't know if that's sdl2
18:59:21 * hackagebot xml-push 0.0.0.16 - Push XML from/to client to/from server over XMPP or HTTP  http://hackage.haskell.org/package/xml-push-0.0.0.16 (YoshikuniJujo)
18:59:29 <CrazyM4n> I´ve tried the SDL libraries
18:59:30 <napping> Is there some reason you want sdl 2 in particular?
18:59:38 <CrazyM4n> Well, I´m more familiar with it
18:59:40 <CrazyM4n> But not by much
18:59:54 <CrazyM4n> Should I just use legacy SDL?
19:00:32 <napping> Oh, SDL linked to the old one?
19:01:18 <CrazyM4n> Yes
19:01:30 <napping> Ah, well, there seem to be a few more libraries built up around it
19:01:43 <napping> if you want to be able to look at anything anyone else has done, probably just go from SDL
19:02:32 <CrazyM4n> I´ll try to get SDL set up I gues
19:02:35 <CrazyM4n> Windows sucks
19:02:44 <napping> But if you're not following a tutorial or whatever, try that sdl2 package
19:03:31 <CrazyM4n> I´m not, but I will probably need one
19:03:36 <CrazyM4n> So I´ll stick with SDL
19:03:37 <napping> Especially if you're fighting with build issues
19:04:10 <CrazyM4n> I am by no means proficient with SDL. I made half of a game, once, and I have made a couple games in PyGame (python SDL wrapper)
19:04:14 <CrazyM4n> So yea
19:04:14 <napping> huh, looks like SDL doesn't build on 7.8.3 either
19:04:41 <CrazyM4n> I´m still on 7.6.3
19:04:45 <CrazyM4n> I:
19:04:48 <napping> well, you might also be more interested in looking at standard sdl docs
19:04:54 <napping> Okay, should be fine.
19:05:06 <CrazyM4n> There´s that lazyfoo tutorial translated to haskell somewhere
19:05:12 <CrazyM4n> That´s what I used to learn SDL in the first place
19:05:27 <napping> Some of the new stuff in 7.8 including improving Typeable in ways that ended up breaking an import statement
19:06:19 <napping> one-line fix
19:06:31 <merijn> Time to fix it and mail a patch to the maintainer :>
19:07:34 <napping> if typeOf is a member of class Typeable, it's still legal to write import Data.Typeable (Typeable,typeOf,...), right?
19:08:27 <merijn> No idea, try it?
19:09:22 * hackagebot needle 0.1.0.0 - ASCII-fied arrow notation  http://hackage.haskell.org/package/needle-0.1.0.0 (ScrambledEggs)
19:09:24 * hackagebot Hungarian-Munkres 0.1.4 - A Linear Sum Assignment Problem (LSAP) solver  http://hackage.haskell.org/package/Hungarian-Munkres-0.1.4 (kaizhang)
19:13:16 <Eduard_Munteanu> napping, import Data.Typeable(Typeable(typeOf))   ?
19:14:21 <CrazyM4n> Does anyone know how to fix this? http://prntscr.com/4qzu7q
19:17:16 <napping> Eduard_Munteanu: that's the problem I'm fixing
19:17:36 <zerowidth> mitchty: ping
19:17:52 <napping> typeOf is no longer a member of Typeable (I'm not sure if there's a good reason for that)
19:18:11 <Eduard_Munteanu> I think it shouldn't be legal then.
19:18:27 <napping> yeah, that line is the way it's written, and the build is failing because it's not legal
19:18:38 <zerowidth> mitchty: have you found any solution to the -lgmp ld errors with cabal?
19:18:50 <Eduard_Munteanu> napping, you might want to ifdef based on version
19:19:07 <napping> writing import (Class,member) is legal
19:19:11 <napping> or even (Class(),member)
19:19:20 <Eduard_Munteanu> Hm.
19:19:36 <napping> CrazyM4n: looks very broken. Do more basic commands work?
19:19:42 <napping> cabal install --help, maybe?
19:25:42 <CrazyM4n> Praise the lords
19:25:49 <CrazyM4n> SDL installed
19:26:11 <CrazyM4n> napping: I had to run it in msys
19:28:17 <dmj`> CrazyM4n: yea certain C libs won't link properly unless you use MSYS I think
19:29:23 * hackagebot hS3 0.5.9 - Interface to Amazon's Simple Storage Service (S3)  http://hackage.haskell.org/package/hS3-0.5.9 (GregHeartsfield)
19:41:47 <spng453> Why do I have to put my code in a module?
19:42:35 <Eduard_Munteanu> Because modules define scoping and scoping is required.
19:42:49 <shachaf> Where else would you put it?
19:43:17 <napping> You can put it all in one file and not write a "module" line if you want
19:43:40 <shachaf> Sometimes I put my code in IRC.
19:43:54 <Eduard_Munteanu> That gets an implicit module, by the way.
19:44:21 <spng453> OK, I've just never heard that
19:44:35 <napping> yeah, that's the answer that goes "because GHC considers anywhere you put any code to be part of some module, if only implicitly"
19:44:44 <napping> well, I'm not entirely sure what ghci dos
19:44:49 <spng453> Then again, I've never, you know, read production Haskell code
19:45:17 <Eduard_Munteanu> ghci has that L module by default, no? Or was that lambdabot/mueval-only?
19:45:28 <napping> never heard of an L
19:45:40 <CrazyM4n> > (flip id) 2
19:45:41 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable c0)
19:45:42 <lambdabot>    arising from a use of ‘M738212405031690042614946.show_M7382124050316900426...
19:45:42 <lambdabot>  The type variable ‘c0’ is ambiguous
19:45:42 <lambdabot>  Note: there are several potential instances:
19:45:42 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
19:45:45 <shachaf> That is lambdabot.
19:46:15 <CrazyM4n> What's up with lambdabots weird errors
19:46:20 <CrazyM4n> With all the numbers
19:48:15 <dmj`> random number generation is how lambdabot relieves stress
19:51:55 <edwardk_> @botsnack
19:51:56 <lambdabot> :)
19:55:24 <zereraz> hello, why is this not working data shape = Circle Float Float Float | Rectangle Float Float Float Float deriving (Show)
19:55:49 <zereraz> I'm using ghci
19:55:49 <bmuk> Why can't we guarantee that all monads satisfy the monad laws? Wouldn't it be pretty easy to add this functionality (maybe I'm being naive but something like QuickCheck)?
19:56:15 <napping> the halting problem?
19:56:50 <zereraz> ?
19:57:09 <geekosaur> zereraz, Shape not shape
19:57:32 <geekosaur> "shape" would be a type variable, for an actual type it must start with uppercase
19:57:33 <zereraz> geekosaur: but we can put any name in front of data
19:57:40 <napping> the laws mention arbitrary functions, it's not easy to test that something is true for every function
19:57:42 <bmuk> napping: you're saying since we can't know if something will terminate, we can't know it will satisfy the laws?
19:57:43 <johnw> bmuk: the only way to truly know is in a stronger language that is able to construct proof, such as Agda, Coq, Idris; in those language you can prove that a given Monad respects the laws
19:57:49 <zereraz> geekosaur: it has to be capital?
19:57:58 <napping> bmuk: well, more like rice's theorem
19:58:11 <geekosaur> all constructors start with a capital, this means both type constructors like Shape and data constructors like Circle
19:58:37 <zereraz> geekosaur: ok thanks
19:58:54 <napping> The halting problem is just the simplest case of knowing you can't write a program that actually checks some property of another program
19:59:50 <bmuk> napping: maybe it wouldn't work in all cases, but I can see how a simple test suite could generate arbitrary values in the monad and check whether the laws held for all of them?
20:00:14 <CrazyM4n> napping: I don't get how people can extrapolate the halting problem to things like that
20:00:15 <TallerGhostWalt> johnw: so can you veryify the monad laws in agda?
20:00:57 <CrazyM4n> You could contruct a test case and supply it with a lot of values and be able to say with near complete certainty if the monad follows the laws
20:00:59 <Axman6> geekosaur: unless they're infix
20:00:59 <tabemann> the thing is that even QuickCheck can't determine that something will *always* be true
20:01:00 <bmuk> johnw: Are we thinking about adding proof to haskell or would we have to give something up? A while ago we were discussing turing complete vs. total languages. Is that why they are able to prove, because they are not turing complete?
20:01:16 <geekosaur> Axman6, I started to comment on that and decided it was already confusing enough for them...
20:01:21 <zereraz> hello, I am getting this error "The function `main' is not defined in module `Main'"
20:01:24 <Axman6> agreed =)
20:01:31 <zereraz> I just wrote 1 line in the program
20:01:41 <zereraz> data Shape = Circle Float Float Float | Rectangle Float Float Float Float
20:01:41 <Axman6> zereraz: what was the line?
20:01:43 <geekosaur> zereraz, yes, if you are compiling then you need a main
20:01:49 <zereraz> really
20:01:50 <bmuk> tabemann: true, but just like in statistics, as the sample size increases so does our confidence
20:01:52 <Axman6> load it into ghci instead
20:01:54 <tabemann> zereraz: you have to always have a binding main in the Main module of a program
20:01:56 <CrazyM4n> You can use "ghci myfile"
20:02:00 <Axman6> ghci Foo.hs
20:02:01 <napping> bmuk: you can write proofs *about* turing complete languages, it just doesn't work very well to write proofs *in* a Turing complete language (maybe you can do fancy things like isolating a total subset)
20:02:07 <geekosaur> haskell is not a scripting language, but a full programming language that requires a main function, like C / C++ / Java
20:02:11 <zereraz> I did not know that
20:02:18 <Axman6> when use :reload (or :r) to load it again when you make changes
20:02:22 <CrazyM4n> I love that about Haskell
20:02:38 <CrazyM4n> I wish there was a similar interpreted language
20:02:41 <CrazyM4n> Err
20:02:45 <CrazyM4n> Imperative
20:02:53 <Axman6> they exist for C and C++
20:02:57 <zereraz> thanks guys
20:02:58 <CrazyM4n> That you could compile or just interpret
20:03:03 <bmuk> napping: what is it that total languages lack which haskell still has?
20:03:08 <Axman6> CERN has one based on Clang IIRC
20:03:15 <zereraz> I recently started compiling
20:03:15 <napping> CrazyM4n: well, you could look at how Rice's theorem is proved from the halting problem
20:03:19 <zereraz> I used to do ghci always
20:03:21 <tabemann> bmuk: the ability to define functions that don't halt
20:03:50 <bmuk> tabemann: I thought that was what we gained? Why would we want to define functions that don't halt?
20:03:52 <geekosaur> CrazyM4n, it could be done if someone cared enough
20:03:57 <tabemann> and the thing is that the Curry-Howard correspondence doesn't work if your functions aren't total
20:04:06 <napping> bmuk: Requiring a proof along with a definition is a great way of making sure things actually follow the monad laws, it's just a big change to haskell to let you write proofs
20:04:19 <CrazyM4n> I guess, that would be really cool for something like C++ or ruby
20:04:22 <tabemann> total functions allow using functions within types in a dependently-typed language
20:04:41 <tabemann> which Agda, Coq, and Idris are
20:04:43 <bmuk> I agree it would be a big change, but not necessarily an unwelcome one.
20:04:48 <napping> sure, that too
20:04:56 <geekosaur> bmuk: the problem is that proving that a function will always halt means restricting it severely; there are a lot of useful things that cannot be *proven* to always halt, even though they always do in practice
20:05:10 <napping> but being such is big changes is the biggest reason we don't use something like that to enforce the monad laws in Haskell right now
20:05:16 <tabemann> which is why we don't want Haskell to be total
20:05:27 <bmuk> geekosaur: could you give me some examples?
20:05:45 <CrazyM4n> The halting problem paradox is that you can never write a program that tells if something can halt
20:05:56 <geekosaur> I am tempted to point you to the "Bloop and Floop and Gloop" chapter of _Gödel, Escher, Bach_
20:05:59 <CrazyM4n> Because if you were to run that program on itself
20:06:08 <tabemann> totality checkers in languages like Agda, Coq, and Idris rely on things like checking that a parameter always contracts with each level of recursion, or with codata that they always are productive
20:06:22 <tabemann> which is quite a restriction
20:06:30 <CrazyM4n> And make it so that if it outputs "halt" then it doesn't halt
20:06:34 <napping> geekosaur: I'm not sure about "a lot"
20:06:49 <bmuk> tabemann: so your counter must always decrease, etc?
20:07:24 <geekosaur> bmuk, a not so practical example is the Collatz conjecture
20:07:26 <tabemann> bmuk: or a data structure being recursed over must have a constructor removed with each level of recursion
20:08:21 <bmuk> geekosaur: that's the hailstone sequence (or something like it), right?
20:08:28 <geekosaur> similar to, yes
20:08:44 <Axman6> halts :: Program -> Bool; halts = <magic>; confusing p = if halts b then forever id else (); what happens when we run confusing (confusing)
20:08:59 <tabemann> it leads to things like adding extra parameters to functions that are natural numbers that are decremented with each level or recursion just to make sure that *something* is deconstructed
20:09:12 <Axman6> uh, halts (confusing (confusing))
20:10:30 <bmuk> tabemann: I see how it could add boilerplate, or make things confusing, but I think the gains are worth it (but I haven't used a total language so I don't know). It would be really nice to know user defined Eq instances were always reflexive
20:10:55 <napping> CrazyM4n: You can get at other properties from the halting problem. If you want to check whether a function always adds 5 to the input, write a program that tests the function on all inputs and stops only if it finds one where it gets the wrong answer
20:10:59 <bmuk> and that monads, functors, monoids, etal. obeyed their respective laws
20:11:19 <fspoon> hi, I'm trying to install hakyll and it's failing on the strict-concurrency-0.2.4.1 with: Could not find module 'GHC.IOBase' (and Control.OldException'), any suggestions?
20:11:32 <bmuk> Can you have a function with an infinite domain in a total language?
20:11:56 <dmj`> fspoon: I got that today, did you check the github issues?
20:11:57 <pjdelport> bmuk: Integer -> Integer
20:12:20 <bmuk> pjdelport: How can you prove it will halt on all integers?
20:12:42 <bmuk> what if I define it to sleep forever if the integer is 03958340573987543
20:12:48 <pjdelport> bmuk: You can't for all functions of that type, but you certainly can for many ones.
20:13:01 <pjdelport> (i.e., all the ones you can express in a total language)
20:13:17 <tabemann> you can have functions with an infinite domain in a total language
20:13:19 <Axman6> bmuk: but that clearly halts
20:13:24 <Clint> fspoon: this will help with half of it: http://anonscm.debian.org/darcs/pkg-haskell/haskell-strict-concurrency/patches/use-new-exception
20:13:25 <fspoon> dmj`: there's some issues with pandoc installation issues, but nothing specific to strict-concurrency
20:13:25 <tabemann> e.g. any function on a natural number
20:13:44 <tabemann> mind you that proof has nothing to do with testing each possible value
20:13:52 <pjdelport> bmuk: In a total language, you can't express sleep (or even loop) forever, with that type.
20:14:05 <bmuk> pjdelport: I figured as much
20:14:15 <bmuk> so they use proof through induction?
20:15:36 <tux_> Hi, Is it possible to have a signed type-level natural?
20:15:38 <fspoon> Clint: cheers, is this effecting everyone who tries to install hakyll or have I just broken cabal somehow
20:16:04 <merijn> tux_: It depends on how inconvenient a type you're willing to put up with :)
20:16:26 <merijn> tux_: Also, FYI natural numbers, by definition are not signed, I'm guessing you mean integer
20:16:57 <Axman6> tux_: natural implies unsigned btw =)
20:16:59 <tux_> merjin: I'm willing to deal with an inconvenient type
20:17:35 <Axman6> You can have type level Ints right? why not use that?
20:17:36 <Clint> fspoon: i dunno, how is hakyll depending on strict-concurrency?
20:17:48 <merijn> tux_: Define a new kind "Signed" with "Pos :: Natural -> Signed" and "Neg :: Natural -> Signed"?
20:17:59 <merijn> Axman6: No, DataKinds has type level Nat
20:18:15 <merijn> But you can trivially wrap Nat with a positive/negative wrapper and distinguish that way
20:20:02 <tux_> merijin: That's right, but the non trivial part is making a function like
20:20:10 <fspoon> Clint: good question: upon actually reading the damn log looks like I'm somehow installing a version of hakyll which is something like 60 releases behind. At least this sounds easier to debug :)
20:20:14 <tux_> signedNatVal :: forall nat . KnownNat nat => Proxy (Signed nat) -> Integer
20:20:34 <tux_> basically getting the value of the nat
20:21:36 <tux_> > :t natVal
20:21:38 <lambdabot>  <hint>:1:1: parse error on input ‘:’
20:21:47 <tux_> > natVal
20:21:48 <lambdabot>  Not in scope: ‘natVal’
20:22:03 <tux_> > GHC.TypeLits.natVal
20:22:04 <lambdabot>  Not in scope: ‘GHC.TypeLits.natVal’
20:22:35 <tux_> Does LambdaBot not import the GHC libs?
20:24:27 <merijn> :t natVal
20:24:29 <lambdabot> Not in scope: ‘natVal’
20:24:36 <merijn> tux_: I dunno which GHC it uses
20:24:38 <tux_> To summarize my question,creating a singed natural isn't the problem, but rather constructing a function to get the value from the type via Data.Proxy. If anyone have a thought on this pleas let me know!
20:24:40 <merijn> tux_: This stuff is new in 7.8
20:25:01 <merijn> So if lambdabot is running on 7.6 it doesn't have access to this
20:25:06 <geekosaur> @version
20:25:06 <lambdabot> lambdabot 5.0-int-e
20:25:07 <lambdabot> git clone git://github.com/int-e/lambdabot.git
20:25:13 <geekosaur> oh, thought that used to say which ghc\
20:25:15 <geekosaur> :/
20:25:27 <geekosaur> actually I have heard that lambdabot doesn't even build on 7.8
20:25:45 <merijn> tux_: Oh, yeah the whole KnownNat stuff is a bit unclear to me too
20:25:58 <merijn> tux_: Have you looked at the singletons paper? I'm guessing they discuss the design of it
20:26:10 <fspoon> dmj`: in case you had the same issue with hakyll/strict-concurrenct. c
20:26:52 <fspoon> dmj`: whoops, 'cabal install hakyll' was installing some ungodly old version (3.2.0.1), I had to manually set the version in a cabal file to get it to install the latest.
20:27:23 <tabemann> to me it seems, though, that if you're going to be dealing with type level nats you're probably better off just using a dependently-typed language
20:28:02 <merijn> tabemann: Sure, if you don't need actual libraries...
20:28:04 <zereraz> can someone tell me what I did wrong here http://lpaste.net/111756
20:28:18 <zereraz> I don't understand whenever I get parse error
20:28:44 <merijn> zereraz: you try to continue the do block in the else part on line 10
20:28:49 <zereraz> oh
20:28:52 <tux_> running with Agda might be going a bit overboard
20:28:54 <zereraz> merijn: got it
20:29:08 <zereraz> merijn: do block only works the level it is declared?
20:29:09 <merijn> zereraz: if-then-else expects an expression, so you need to add an extra "do" after "then" for it to desugar correctly
20:29:33 <tabemann> Idris is supposed to be a "practical" dependently-typed language, but it is not stable as a development platform yet
20:29:39 <zereraz> merijn: can you explain what that means
20:29:42 <merijn> zereraz: Personally I tend to recommend the do syntactic sugar until you understand how it desugars. For example
20:29:54 <tabemann> Agda isn't practical for doing anything other than theorem-proving
20:29:59 <merijn> @undo do { x <- foo; bar; baz x; return 1 }
20:29:59 <lambdabot> foo >>= \ x -> bar >> baz x >> return 1
20:30:11 <tabemann> and likewise Coq is really primarily a theorem-prover
20:30:12 <merijn> zereraz: That is a single expression
20:30:22 <zwer> zereraz you also don't have else in a second if.
20:30:39 * tabemann would like to see where Idris goes, though, as he can definitely see the place for a practical dependently-typed language
20:30:51 <merijn> @undo do { x <- foo; if blah then blah + 1 else quux + 5; return x }
20:30:51 <lambdabot> foo >>= \ x -> (if blah then blah + 1 else quux + 5) >> return x
20:31:00 <zereraz> zwer: yeah I will fix that thanks
20:31:05 <zwer> zereraz also consider using case
20:31:09 <merijn> zereraz: See, the desugaring doesn't "see inside" the if expression
20:31:11 <zereraz> zwer: will do
20:31:19 <merijn> tabemann: Does Idris have a haskell FFI?
20:31:23 <zereraz> merijn: I got it
20:31:26 <zereraz> merijn: thanks
20:31:30 <merijn> Because that'd be cool
20:31:53 <merijn> zereraz: I also recommend reading this: https://en.wikibooks.org/wiki/Haskell/do_Notation
20:33:44 <zereraz> merijn: I recently read the internal working of do
20:33:55 <zereraz> merijn: I forgot that it would take the if else as 1 block
20:34:35 <merijn> zereraz: Also, note that you're indenting far more than necessary
20:35:17 <merijn> Which another wikibook explains much better than me too https://en.wikibooks.org/wiki/Haskell/Indentation :)
20:36:24 <zereraz> merijn: I don't understand haskell indentation, I used to think I got it, until recently I got problems with indentation
20:36:36 <zereraz> merijn: thanks I'll read it for sure
20:40:22 <tabemann> merijn: can't find anything on Idris having a Haskell FFI
20:40:43 <AshyIsMe> does anyone know where the ShowFun module comes from?
20:40:55 <AshyIsMe> i can "import ShowFun" on my mac but not in this linux vm
20:45:04 <tabemann> what versions of GHC do you have on each?
20:45:04 <scopedTV> AshyIsMe: try hayoo
20:45:38 <scopedTV> AshyIsMe: it should point you to the name of the package
20:49:31 <AshyIsMe> hmm, from the package show
20:49:45 <AshyIsMe> mueval is saying "ShowFun" module not found even though i have the show package installed
20:52:16 <zereraz> can someone explain ,data Person = Person String String ...
20:52:31 <zereraz> how can we define it with Person inside
20:54:12 <AshyIsMe> data <TypeName> = <ConstructorName> <FieldType> ...
20:54:15 <AshyIsMe> that's the syntax
20:54:24 <zereraz> AshyIsMe: ok thanks
20:54:40 <AshyIsMe> so you could have:  data People = Child String | Adult String ...
20:55:27 <zereraz> AshyIsMe: got it
20:55:28 <AshyIsMe> zereraz: this is worth reading (the whole book is too): http://learnyouahaskell.com/making-our-own-types-and-typeclasses
20:56:01 <zereraz> AshyIsMe: I am reading it , got confused on this part
20:56:14 <zereraz> AshyIsMe: I thought it was some recursion
20:56:26 <AshyIsMe> oh yeap
20:58:12 <merijn> zereraz: An important distinction not made in LYAH is the fact that there's TWO different namespaces involved
20:58:17 <zwer> zereraz you can define recursive types. list is one example.
20:58:23 <merijn> zereraz: There's the TYPE namespace and the VALUE namespace
20:58:39 <merijn> zereraz: That definition is defining both a new TYPE and a new VALUE
20:58:40 <zwer> data List a = Cons a (List a) | Nil
20:58:52 <merijn> zereraz: "data PersonType = PersonConstructor String String"
20:59:26 <merijn> zereraz: But since the types and values are in different namespace they can be the same and frequently are for types with only a single constructor, so you don't have to remember the constructor name
21:05:09 <zereraz> merijn: can you explain why constructor name does not matter?
21:05:25 <zereraz> merijn: I understood that they are in different namespace, as we can use the same name
21:06:30 <scopedTV> zereraz: it matters, but there is a convention to use the same name if there is a single ctor, so we don't have to remember two names.
21:07:55 <zereraz> scopedTV: ok got it
21:09:32 * hackagebot esqueleto 2.0.3 - Type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-2.0.3 (MichaelSnoyman)
21:11:33 <milton-friendman> https://www.youtube.com/watch?v=xNc-xhH8kkk communism must be fought
21:12:19 <Axman6> go away
21:12:36 <haasn> @where ops
21:12:36 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
21:12:46 --- mode: ChanServ set +o copumpkin
21:12:49 --- mode: copumpkin set +b *!~Minnie@cpe-142-129-50-121.socal.res.rr.com
21:12:49 --- kick: milton-friendman was kicked by copumpkin (No.)
21:12:57 --- mode: copumpkin set -o copumpkin
21:13:06 <pharaun> haha i was very confused
21:13:09 <pharaun> oh
21:14:33 * hackagebot vado 0.0.3 - Runs commands on remote machines using ssh  http://hackage.haskell.org/package/vado-0.0.3 (HamishMackenzie)
21:15:41 <kaspar_> @pl \xs -> f 1 xs ++ f 2 xs
21:15:42 <lambdabot> ap ((++) . f 1) (f 2)
21:17:34 <pjdelport> (++) <$> f 1 <*> f 2
21:17:58 <kaspar_> pjdelport: thanks
21:18:18 <kaspar_> more readable
21:19:33 * hackagebot classy-prelude 0.10.0 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.10.0 (MichaelSnoyman)
21:19:35 * hackagebot classy-prelude-conduit 0.10.0 - conduit instances for classy-prelude  http://hackage.haskell.org/package/classy-prelude-conduit-0.10.0 (MichaelSnoyman)
21:19:35 <pjdelport> Or, if you have (·<) = flip (<$>); (>·) = (<*>)
21:19:35 <pjdelport> Then you can write: f 1 ·<(++)>· f 2
21:19:37 * hackagebot classy-prelude-yesod 0.10.0 - Provide a classy prelude including common Yesod functionality.  http://hackage.haskell.org/package/classy-prelude-yesod-0.10.0 (MichaelSnoyman)
21:20:11 <pjdelport> (Warning: may cause dirty looks)
21:22:05 <pjdelport> (You could also use -< and >- instead of ·< and >· if you can't type · easily)
21:24:04 <jle`> neatest way to get the diaganol of a list of lists?
21:24:25 <jle`> pjdelport: careful, (-<) may be syntax if you have certain extensions on :)
21:24:33 <pjdelport> jle`: Hence the dirty looks :)
21:25:16 <jle`> > let a = [[1,2,3],[4,5,6],[7,8,9]] in zipWith (!!) a [0..]
21:25:17 <lambdabot>  [1,5,9]
21:25:19 <jle`> heh
21:25:35 <kaspar_> pjdelport: going to use <$> and <*> as it's neat enough
21:25:50 <pjdelport> kaspar_: Yeah, the others aren't *really* serious :)
21:25:51 <oiiuoi> jle`: which extension are you referring to?
21:25:58 <pjdelport> oiiuoi: Arrow syntax
21:26:02 <oiiuoi> ah
21:26:43 <pjdelport> kaspar_: It's just an amusing hack for infix Applicative operators, i think.
21:27:36 <jle`> oiiuoi: {-# LANGUAGE Arrow #-}
21:28:02 <oiiuoi> yeah, I got it, thanks
21:33:57 <nitrix> What does <$> do again?
21:34:44 <merijn> nitrix: fmap
21:40:01 <jle`> kaspar_: i've been fond of liftA2
21:43:20 <gigamonkey> This is no doubt trivial but my brain is shutting down: if I have a [IO Bool] how do I find the first element where the Bool is true?
21:43:58 <napping> what do you mean by "the Bool is true"?
21:44:13 <napping> IO Bool could flip a coin each time you run it
21:44:36 <merijn> He wants to run IO's until one returns true
21:44:43 <gigamonkey> merijn: right
21:44:46 <merijn> @hackage monad-loops --gigamonkey
21:44:46 <lambdabot> http://hackage.haskell.org/package/monad-loops --gigamonkey
21:45:00 <eazar001> @type find
21:45:01 <lambdabot> (a -> Bool) -> [a] -> Maybe a
21:45:06 <eazar001> @type join
21:45:07 <lambdabot> Monad m => m (m a) -> m a
21:46:11 <napping> gigamonkey: ah, then orM in monad-loops sounds good
21:46:17 <eazar001> oh
21:46:22 <eazar001> neat
21:46:44 <napping> I wasn't sure if you wanted an index of the true, or to return the IO Bool itself, or what
21:46:50 <gigamonkey> merijn: so I need a library for that? I thought there was some clever way I was going to be able to do this with lifting the proper thing the proper way.
21:47:02 <gigamonkey> Hang on a sec. I'll get a pointer to the code I have.
21:47:11 <merijn> gigamonkey: naah, you can just implement it yourself
21:47:26 <merijn> gigamonkey: It's probably like a few lines
21:47:38 <merijn> monad-loops is just a package full of convenient examples
21:48:00 <napping> it's not even implemented in any fancy way
21:48:09 <gigamonkey> Here's the function I have: https://github.com/gigamonkey/haskell-skirt/blob/master/skirt.hs#L61
21:48:12 <gigamonkey> Which works fine.
21:48:48 <gigamonkey> But I was thinking I could do: map (\d -> doesFileExist $ combine d file) dirs to get to the [IO Bool]
21:49:17 <napping> you want to end up with the d, so it's probably better to split the predicate
21:49:42 <napping> a findM :: (a -> m Bool) -> [a] -> m (Maybe a)
21:50:08 <gigamonkey> That looks promising.
21:50:20 <CrazyM4n> So does anyone know how to draw directly to the screen using SDL?
21:50:22 <napping> It's called firstM if you use monad-loops
21:50:27 <CrazyM4n> Or is there a better IRC I should ask
21:50:40 <napping> or you can check the code and see it's implemented straightforwardly in monad-loops
21:51:05 <merijn> gigamonkey: You need to manually recurse to abort early
21:51:13 <merijn> Well, or use a fold, I guess
21:51:23 <gigamonkey> merijn: which is what I'm doing, in the one I wrote.
21:51:25 <merijn> But consult monad-loops code for example
21:51:34 <gigamonkey> So maybe I just leave it at that. But I will take a look at that code. Thanks.
21:53:49 <gigamonkey> Yeah, so firstM in monad-loops is basically what I wrote.
21:53:57 <napping> is there an a -> a -> Bool -> a in base?
21:54:00 <zereraz> why can't I do this ' data Vector a = Vector a a a deriving(Num) '
21:54:09 <simpson> CrazyM4n: What are you having trouble with?
21:54:20 <napping> gigamonkey: yeah, just with the type-specific bits lifted out
21:54:27 <CrazyM4n> simpson: I´m trying to make a mandelbrot fractal render directly to the screen
21:54:46 <CrazyM4n> So I wanted to make it just display pixels directly using the haskell SDL bindings
21:55:01 <jle`> napping: there's bool
21:55:03 <CrazyM4n> But frankly, I don´t want to completely learn SDL from the bottom up
21:55:03 <jle`> :t bool
21:55:04 <lambdabot> a -> a -> Bool -> a
21:55:12 <CrazyM4n> And the bindings are pretty confusing
21:55:17 <CrazyM4n> So I´m kinda stuck
21:55:21 <jle`> the argument order is supposed to be patterned after maybe and either
21:55:24 <CrazyM4n> I know the basics of SDL though
21:55:24 <kaspar_> CrazyM4n: try Helm
21:55:26 <jle`> so the "false" case is the first input
21:55:27 <merijn> zereraz: Because Num is not a derivable typeclass
21:55:37 <zereraz> merijn: why
21:55:45 <napping> jle`: thanks, I thought I looked for that, even in Data.Bool
21:55:57 <jle`> napping: i think it is new in 7.8
21:55:59 <CrazyM4n> kaspar_ FRP is so spooky though
21:56:11 <merijn> zereraz: How would it magically know what it should be?
21:56:25 <napping> jle`: yeah, I've got 7.8 and that function, I don't know how I missed it
21:56:42 <CrazyM4n> kaspar_ Okay, Helm actually looks pretty cool
21:56:47 <merijn> zereraz: The derivable typeclasses are all fairly simple and their implementation is easily auto-generated. GHC can hardly automatically invent vector math for you...
21:56:58 <kaspar_> CrazyM4n: if by spooky you mean fun and easy ;)
21:57:16 <CrazyM4n> kaspar_: I just could never find a good tutorial
21:57:20 <CrazyM4n> Or even a good overview
21:57:23 <zereraz> merijn: when we do Vector a = a a a deriving(Eq), and we make 2 vectors a and b, and do a == b
21:57:25 <CrazyM4n> What is FRP in the first place?
21:57:29 <zereraz> merijn: then it says equal
21:57:34 <zereraz> merijn: True
21:57:34 <jle`> CrazyM4n: read conal's paper
21:57:37 <zereraz> merijn: if equal
21:57:39 <merijn> zereraz: Right, because it just does pairwise comparison
21:57:42 <zereraz> merijn: so it checks in order
21:57:49 <zereraz> merijn: it could add in order?
21:58:01 <jle`> :)
21:58:20 <CrazyM4n> FRP seems really cool
21:58:22 <merijn> zereraz: How about multiplication? How would it automatically derive that?
21:58:26 <Eduard_Munteanu> zereraz, if deriving Num
21:58:32 <zereraz> merijn: so they did it on purpose
21:58:40 <zereraz> merijn: so that compiler does not assume
21:58:50 <merijn> zereraz: The compiler does not assume anything, ever
21:58:58 <zereraz> merijn: got it :)
21:59:19 <merijn> zereraz: It's not magical. It's just that specifying equality to blindly compare fields is pretty easy to auto generate, etc.
21:59:36 <kaspar_> CrazyM4n: maybe try Elm first and then Helm
21:59:42 <CrazyM4n> Isn´t that game by chucklefish being written using FRP?
22:00:24 <CrazyM4n> I´ll take a little bit of a look at Elm
22:00:26 <CrazyM4n> Sounds nice
22:01:31 <kaspar_> CrazyM4n: There are good docs and examples for Elm
22:01:36 <kaspar_> so it's easier to get started
22:01:50 <CrazyM4n> I´m just gonna try it out a little
22:01:58 <CrazyM4n> No need to learn it in depth
22:02:49 <napping> CrazyM4n: you might need SDL-gfx
22:02:58 <CrazyM4n> For helm?
22:03:03 <CrazyM4n> Is the base SDL library not enough?
22:03:08 <napping> no, for writing in SDL
22:03:29 <napping> I think writing pixels in plain sdl was pretty annoying, even in C
22:03:50 <napping> http://hackage.haskell.org/package/SDL-gfx-0.6.0/docs/Graphics-UI-SDL-Primitives.html
22:03:52 <CrazyM4n> Elm is pretty sweet
22:04:08 <Eduard_Munteanu> CrazyM4n, what are you drawing?
22:04:16 <napping> otherwise Graphics.UI.SDL.Types has stuff you need to get pointers to the pixel data out of a Surface
22:04:35 <CrazyM4n> Eduard_Munteanu: Mandelbrot fractal, I probably don´t need FRP
22:04:39 <CrazyM4n> It´s cool nonetheless
22:04:58 <Eduard_Munteanu> Ok. I was going to suggest cairo if it was more vector-like.
22:05:25 <kaspar_> Helm actually uses cairo
22:05:33 <CrazyM4n> So maybe not
22:05:44 <CrazyM4n> Though I´ll bookmark Helm, I want to look at it
22:05:47 <CrazyM4n> After I finish this
22:06:09 <jle`> elm is neat
22:06:19 <jle`> what with its exploration of time machines and stuff
22:07:51 <kaspar_> CrazyM4n: You don't need FRP but the drawing APIs are much nicer in Helm/Elm than anywhere I have seen
22:08:14 <napping> The queue in Okasaki'95 is pretty simple
22:08:55 <CrazyM4n> Ah. So, nobody knows any good raster drawing libraries with which I can edit the pixel grid in Haskell?
22:09:37 <napping> An SDL surface contains a pointer to pixel data
22:09:53 <napping> should be fine for a mandelbrot set or whatever
22:10:16 <CrazyM4n> But the bindings aren´t very good (considering it was made for an imperative language)
22:10:39 <CrazyM4n> And it´s hard to write to the pixel grid in the first place
22:10:48 <CrazyM4n> And in Haskell it seems to be such a giant pain
22:10:57 <napping> what sorts of things do you want to do eventually?
22:11:02 <CrazyM4n> Honest
22:11:07 <CrazyM4n> All I want to do
22:11:09 <CrazyM4n> Is just draw it
22:11:19 <CrazyM4n> I don´t even care if it´s an image library at this point
22:11:30 <CrazyM4n> I just want a picture of my fractal :C
22:11:43 <napping> Try vector then
22:11:48 <Eduard_Munteanu> CrazyM4n, just output a PNM then
22:11:58 <CrazyM4n> How could I do that? Is there a default library for that?
22:12:08 <CrazyM4n> Err, I can google it
22:12:11 <Eduard_Munteanu> CrazyM4n, it's trivial to write PNMs yourself
22:12:12 <napping> "vector" is the package name
22:12:25 <Eduard_Munteanu> Binary PNMs.
22:13:03 <CrazyM4n> https://hackage.haskell.org/package/vector This vector?
22:13:08 <napping> yeah
22:13:08 <CrazyM4n> It doesn´t seem very helpful
22:13:27 <kaspar_> @pl \xs -> f 1 xs ++ f 2 xs ++ f 3 xs
22:13:27 <lambdabot> ap ((++) . f 1) (ap ((++) . f 2) (f 3))
22:13:43 <Eduard_Munteanu> CrazyM4n, https://en.wikipedia.org/wiki/Netpbm_format
22:13:47 <CrazyM4n> napping: Does it have something to draw to the screen?
22:14:00 <Eduard_Munteanu> See P6.
22:14:01 <phaskell> P6: https://phabricator.haskell.org/P6 - D82 nofib report (integer-gmp vs. integer-gmp2 v1)
22:14:04 <CrazyM4n> And I´ll look at that, Eduard_Munteanu
22:14:17 <napping> no, but it's a decent place to start for calculating your colors into an array in memory
22:14:52 <jle`> kaspar_: looks like you could do something with the monoid instance of a -> b
22:14:56 <napping> and then write from there to write an image file or get out a pointer (if you use the storable vectors) and pass to an image library as a texture, or whatever
22:15:24 <jle`> :t \f x -> mappend [f 1, f 2, f 3] x
22:15:24 <lambdabot> Num a => (a -> t) -> [t] -> [t]
22:15:36 <jle`> like ... mappend (map f [1,2,3])
22:15:52 <jle`> not mappend, sorry
22:15:55 <jle`> mconcat
22:16:10 <jle`> :t \f x -> mconcat [f 1, f 2, f 3] x
22:16:12 <lambdabot> (Monoid t, Num a) => (a -> t1 -> t) -> t1 -> t
22:16:38 <jle`> oh, but.  mappending and mapping is foldMap
22:16:40 <jle`> :t foldMap
22:16:41 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
22:17:02 <jle`> :t \f x -> foldMap f [1,2,3] x
22:17:02 <lambdabot> (Monoid t, Num a) => (a -> t1 -> t) -> t1 -> t
22:18:09 <jle`> foldMap :: (Int -> a -> b) -> [Int] -> (a -> b)
22:18:17 <jle`> um
22:18:21 <dhrosa> how do the types match up for join = (>>= id)?
22:18:28 <kaspar_> jle`: thanks, mconcat seems to work
22:18:29 <jle`> foldMap :: (Int -> a -> [b]) -> [Int] -> (a -> [b])
22:18:39 <dhrosa> considering >>='s second argument is a (a -> m b)
22:18:46 <jle`> dhrosa: time to play the unification game!
22:18:57 <jle`> if (>>=) takes an (a -> m b), and id is (c -> c)
22:19:04 <kaspar_> was not having much luck with `(++) <$> f 1 <*> f 2 `
22:19:07 <jle`> how can you unify everything?
22:19:36 <jle`> (a -> m b) ~ (c -> c)
22:19:46 <jle`> that implies (a ~ c) and (m b ~ c)
22:19:53 <dhrosa> a ~ m b
22:19:54 <CrazyM4n> PNM files seem pretty good, thanks Eduard_Munteanu
22:20:03 <jle`> dhrosa: yea
22:20:10 <jle`> so what does the type of id get instantiated as?
22:20:23 <dhrosa> m b -> m b?
22:20:27 <jle`> yeah
22:20:38 <jle`> so... putting it all together
22:20:40 <jle`> :t (>>=)
22:20:41 <lambdabot> Monad m => m a -> (a -> m b) -> m b
22:20:58 <jle`> so we know that (a -> m b) is instanciated as (m b -> m b)
22:21:07 <jle`> and we know that because we reasoned that a ~ m b
22:21:11 <gratimax> Annndd we're talking about monads again
22:21:13 <jle`> so if we plug in m b for a's...
22:21:26 <jle`> you get m (m b) -> (m b -> m b) -> m b
22:21:41 <jle`> gratimax: this doesn't really have anything really to do with monads :) just type system unification games
22:22:10 <gratimax> earlier people were talking about mconcat foldmap, etc
22:22:53 <jle`> oh, that is monoids
22:23:13 <jle`> er, Monoids
22:23:30 <kaspar_> ok foldMap is shorter and clearer
22:23:34 <gratimax> Alright, nevertheless the point is #haskell talks about monoids/monads a lot
22:24:29 <tabemann> I wouldn't say monoids/monads, as that implies that monoids and monads are similar, when in fact they are quite different
22:24:31 <Axman6> :t join . fmap
22:24:32 <lambdabot>     Occurs check: cannot construct the infinite type: f ~ (->) (f a)
22:24:33 <lambdabot>     Expected type: (a -> b) -> f a -> f a -> b
22:24:33 <lambdabot>       Actual type: (a -> b) -> f a -> f b
22:24:59 <dhrosa> jle`: thanks.. I think I'm still a but confused, by how that gets rid of one level of the structure
22:25:10 <shachaf> They're similar in all sorts of ways.
22:25:21 <shachaf> Not that that's a productive discussion with this state of channel.
22:25:43 <jle`> dhrosa: perhaps it might help if you look at how it works for particular instances?
22:26:03 <dhrosa> jle`: okay, so (Just 3) >>= id
22:26:05 <jle`> what does (>>= id) do for Maybe? []?
22:26:14 <dhrosa> jle`: err
22:26:19 <dhrosa> oops
22:26:25 <dhrosa> (Just (Just 3)) >>= id
22:26:40 <jle`> (Just x) >>= f = f x
22:26:51 <jle`> so (Just (Just 3)) >>= id = id (Just 3)
22:27:09 <dhrosa> hmm, I think I see
22:29:01 <CrazyM4n> Is there a function that takes a list, and concatenates the elements into one token-seperated string?
22:29:13 <shachaf> What would its type be?
22:29:28 <CrazyM4n> Show a => [a] -> String
22:29:36 <CrazyM4n> Oh.
22:29:40 <CrazyM4n> I could just look taht up
22:29:56 <shachaf> I'm confused by that type.
22:30:00 <CrazyM4n> Doesn´t look like there is one, what should I do?
22:30:07 <CrazyM4n> Well, I can roll it myself
22:30:12 <CrazyM4n> Just by folding with ++
22:30:14 <shachaf> OK, what would it do?
22:30:22 <CrazyM4n> Take a list
22:30:23 <geekosaur> depends on what you men by concatenates the elements.
22:30:26 <CrazyM4n> Of a showable element
22:30:29 <CrazyM4n> And puts them together
22:30:31 <CrazyM4n> In a string
22:30:35 <geekosaur> could be intercalate, could be something like that with show... oh\
22:30:38 <CrazyM4n> With a specified character seperating them
22:30:38 <jle`> CrazyM4n: where does your function take the token to separate things with?
22:30:44 <geekosaur> intercalate token . map show
22:30:45 <shachaf> Writing the first thing you said across five lines doesn't make it much clearer.
22:30:59 <shachaf> I don't understand your type -- what's the "specified character"?
22:31:15 <CrazyM4n> Never mind
22:31:22 <kaspar_> CrazyM4n: unlines? unwords?
22:31:45 <jle`> CrazyM4n: try searching for a function that would take the seperator token :)
22:31:47 <jle`> as an argument
22:31:52 <tac_> CrazyM4n: Intercalate?
22:31:55 <tac_> @type intercalate
22:31:56 <lambdabot> [a] -> [[a]] -> [a]
22:32:10 <tac_> > intercalate " " ["hello", "world"]
22:32:11 <lambdabot>  "hello world"
22:32:26 <tac_> > intercalate " and " ["hello", "world"]
22:32:28 <lambdabot>  "hello and world"
22:32:47 <AshyIsMe> god mueval as behind on package dependencies
22:33:16 <CrazyM4n> Yes, intercalate
22:33:17 <CrazyM4n> Thanks
22:33:23 * shachaf sighs.
22:34:29 <napping> Okasaki's scheduled queue actually has pretty simple code
22:36:08 <CrazyM4n> Sorry sachaf, I´m not very good at explaining things
22:36:31 <pjdelport> > intercalate " " . intercalate "and" $ ["hello", "world"]
22:36:33 <shachaf> An example would be useful. For example, I have ',' and [1,2,3,4], and I want "1,2,3,4"
22:36:33 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘[GHC.Types.Char]’
22:36:33 <lambdabot>  Expected type: [[GHC.Types.Char]]
22:36:33 <lambdabot>    Actual type: [GHC.Types.Char]Couldn't match type ‘GHC.Types.Char’ with ‘[G...
22:36:33 <lambdabot>  Expected type: [[GHC.Types.Char]]
22:36:33 <lambdabot>    Actual type: [GHC.Types.Char]Couldn't match type ‘GHC.Types.Char’ with ‘[G...
22:36:53 <pjdelport> > intercalate " " . intersperse "and" $ ["hello", "world"]
22:36:54 <lambdabot>  "hello and world"
22:40:16 <athan> Do booleans form two monoids? Where conjunction is mappend and True as mempty (inverse for the other one)?
22:40:23 <AshyIsMe> is there a way to tell cabal install to not actually install?  i just want it to tell me what packages it would try to install
22:40:43 <athan> I know it forms a lattice, but I would like to start slow
22:40:44 <napping> there's some flag for that
22:41:25 <tabemann> athan: yes
22:41:33 <athan> tabemann: Thank you
22:41:53 <tabemann> Any and All
22:42:40 <bakibour> Hiho
22:42:47 <pjdelport> To be explicit: Any and All are the two newtype wrappers for Bool, defined in Data.Monoid
22:43:23 <pjdelport> > mconcat $ map All [True, True, True]
22:43:24 <lambdabot>  All {getAll = True}
22:43:25 <bakibour> How would you use an iteratee/enumerator (conceptually) when you deal with structured data?
22:43:30 <pjdelport> > mconcat $ map All []
22:43:31 <lambdabot>  All {getAll = True}
22:43:36 <pjdelport> > mconcat $ map All [True,False]
22:43:38 <lambdabot>  All {getAll = False}
22:44:26 <athan> ahh! Thank you pjdelport & tabemann!
22:44:39 * hackagebot yaml 0.8.9.2 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.9.2 (MichaelSnoyman)
22:48:19 <jle`> /b 16
22:48:22 <jle`> sorry
22:49:27 <DarkCthulhu> I am defining a function which should match the arguments of type Func(Func(Func...(X))) or Func(X). How do I specify a pattern that matches these two?
22:50:25 <DarkCthulhu> It can be several chained calls to Func; no limit.
22:51:00 <jle`> is Func a type here...?
22:51:10 <jle`> a type constructor?
22:51:21 <jle`> can you give more information on what you want to do?
22:51:34 <DarkCthulhu> jle`, I'll make an example and pastebin it. 1 moment
22:51:49 <bakibour> hey jle`
22:51:57 <bakibour> did you check ou GDL yet?
22:51:58 <jle`> hey, sup?
22:52:18 <jle`> i read a bit about it and where it was used, but i haven't dug too deep into it yet
22:52:49 <bakibour> nothing much try to come up with an idea how to get structured data through iteratees/enumerators
22:52:58 <CrazyM4n> Hey guys, thanks for helping
22:53:20 <CrazyM4n> It´s so much better than reading 5 year old fourm posts :P
22:56:13 <fuzzyhorns> so i think im in cabal hell. oading package fast-logger-2.2.0 ... <command line>: can't load .so/.DLL for: /Users/Alex/Documents/Code/haskell/experiments/.cabal-sandbox/lib/x86_64-osx-ghc-7.8.2/fast-logger-2.2.0/libHSfast-logger-2.2.0-ghc7.8.2.dylib (dlopen(/Users/Alex/Documents/Code/haskell/experiments/.cabal-sandbox/lib/x86_64-osx-ghc-7.8.2/fast-logger-2.2.0/libHSfast-logger-2.2.0-ghc7.8.2.dylib, 9): Symbol not found: _directoryzm1zi2zi1zi0_SystemziDirec
22:56:29 <fuzzyhorns> ive tried the google
22:56:37 <fuzzyhorns> i dont get what fast-logger is upset about ._.
22:56:55 <CrazyM4n> Ok, so let me give you guys a ¨completely hypothetical¨ situation
22:57:00 <CrazyM4n> I have a [[Int]]
22:57:09 <CrazyM4n> How would I convert that to a space-delimited string
22:57:29 <napping> you've got two levels of lists there, how should that map to spaces?
22:57:39 <bakibour> I think there is a function called intercalate
22:57:43 <shachaf> CrazyM4n: You should take an example from my example above and give an example.
22:57:46 <CrazyM4n> Yea, It´s kind of weir
22:57:48 <CrazyM4n> Okay.
22:57:54 <CrazyM4n> Actually
22:57:55 <shachaf> I have the list [[1,2,3],[4,5],[],[6,7,8]]
22:58:00 <shachaf> I want:
22:58:02 <CrazyM4n> It´s rectangular
22:58:10 <bakibour> CrazyM4n: http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-List.html#v:intercalate
22:58:14 <fuzzyhorns> should i reinstall haskell -_-
22:58:29 <CrazyM4n> I have: [[1,3,4],[1,2,3]] and want to turn it into ¨1 3 4\n1 2 3¨
22:58:34 <CrazyM4n> And I´m just really confused
22:58:35 <napping> unlines . map unwords
22:58:50 <jle`> see how useful examples can be? :D
22:59:01 <napping> oh, maybe unlines . map (unwords . map show)
22:59:06 <DarkCthulhu> jle`, http://pastebin.com/zuK58cX5
22:59:14 <DarkCthulhu> Here, I want to specify another evaluation rule
22:59:44 <CrazyM4n> Ah, I see napping
23:00:07 <DarkCthulhu> I want to evaluate IsZero c to false, if and only if c evaluates to Fwd ( Fwd ( Fwd.... (Zero)))
23:00:27 <DarkCthulhu> If it is Fwd ( Fwd ( Fwd ... ( Simple True )), that is invalid
23:00:51 <jle`> (btw, eval (IsZero c) | c == Zero = ... is eval (IsZero Zero) = ..
23:01:17 <jle`> DarkCthulhu: you can probably write an "isFwdAllTheWayDown" function
23:01:17 <DarkCthulhu> jle`, I see.. I should replace that rule with that simple variant.
23:01:47 <jle`> isFwdFalse (Fwd Zero) = True; Fwd c = ...?; _ = False
23:01:51 <DarkCthulhu> jle`, I want to check if at the end of the Fwd chain, it is a Zero
23:01:56 <jle`> can you figure out what should be on the second line?
23:02:15 <jle`> the second case
23:02:15 <DarkCthulhu> jle`, Hmm.. let me see
23:02:23 <fuzzyhorns> no matter what i try to do, i can't install persistent via cabal, because it craps out at fast-logger
23:02:23 <CrazyM4n> napping: you´re a godsend dude http://prntscr.com/4r1782
23:02:36 <jrc12> I had a question with regard to isos in lens, if the forward mapping is s -> a, and the backward mapping is b -> t, why does nothing constrain s to be isomorphisc to t, and b to be isomorphic to a?
23:02:43 <napping> cool, looks like it's working
23:03:18 <bakibour> fuzzyhorns: im no cabal expert but it seems you installed it in a sandbox
23:03:31 <CrazyM4n> napping: rendering it at a higher resolution, I´ll take another screenshot
23:03:52 <bakibour> isnt that supposed to just be local so you can just kick that away and start a fresh sandbox without having your global sandbox broken?
23:04:13 <CrazyM4n> http://prntscr.com/4r17ku
23:04:54 <fuzzyhorns> bakibour: so i tried installing it globally in my home directory and i get a diff problem
23:05:03 <fuzzyhorns> persistent-2.0.8 depends on template-haskell-2.9.0.0 which failed to install.
23:05:03 <fuzzyhorns> template-haskell-2.9.0.0 failed during the configure step. The exception was:
23:05:03 <fuzzyhorns> user error (The package 'template-haskell' requires Cabal library version -any
23:05:03 <fuzzyhorns> && >=1.10 but no suitable version is installed.)
23:05:10 <fuzzyhorns> i cant understand why is wrong there
23:05:16 <DarkCthulhu> jle`, http://pastebin.com/fXHjnFhN
23:05:16 <fuzzyhorns> cabal def exists
23:05:22 <fuzzyhorns> so why would it say something like that?
23:05:24 <DarkCthulhu> jle`, Something like that?
23:05:26 <fuzzyhorns> sorry to be so stupid
23:05:45 <jle`> fuzzyhorns: have you tried updating cabal-install?
23:05:50 <bakibour> fuzzyhorns: i know what you mean i am always confused by that stuff also, especially in windows :)
23:05:52 <jrc12>   anyone with regard to the iso's question? :P
23:05:54 <jle`> not sure if that does anything
23:06:03 <DarkCthulhu> jle`, Missed the function name on the last line.
23:06:21 <fuzzyhorns> jle`: i'll try that, pretty sure i am current though :/
23:06:30 <jle`> jrc12: as long as the iso is an iso, what needs to be saida bout he types?
23:06:31 <DarkCthulhu> jle`, But I think I get the approach. So, I pass the argument to this function and check if it evaluates the way I want, before proceeding right?
23:06:51 <jle`> DarkCthulhu: this sounds like something that QuickCheck could help you with :)
23:07:45 <DarkCthulhu> jle`, Ah.. I'll check that out.
23:07:52 <DarkCthulhu> jle`, Thank you :)
23:08:01 <jle`> in terms of checking if your functions are written correctly or not
23:15:33 <AshyIsMe> ok guys, @LambdaTwit is now (tentatively) open for business: https://twitter.com/LambdaTwit
23:15:48 <AshyIsMe> ive wired up mueval to a twitter account
23:15:59 <AshyIsMe> project is here: https://github.com/ashyisme/lambdatwit
23:16:20 <AshyIsMe> currently unicode is broken and will crash it, so that's next on my todo list
23:16:35 <AshyIsMe> feel free to send some test posts at it though
23:17:16 <fuzzyhorns> annnd turns out my user version of cabal was diff from global
23:17:18 <fuzzyhorns> good gravy
23:22:45 <merijn> fuzzyhorns: Whoops, i wasn't paying attention
23:22:53 <merijn> fuzzyhorns: You're trying to install template haskell?
23:23:15 <merijn> fuzzyhorns: The simple answer to your problems is: Stop what you're doing, you're doing it wrong.
23:23:31 <merijn> fuzzyhorns: Template haskell is wired into GHC and *cannot* be upgraded, ever.
23:24:07 <merijn> fuzzyhorns: If a library requires Template Haskell version than you have with your GHC, there is only two solutions: Upgrade your GHC or downgrade your package
23:48:16 <CrazyM4n> Ok
23:48:18 <CrazyM4n> uh
23:48:24 <CrazyM4n> I have a 3d array now
23:48:46 <CrazyM4n> And
23:49:01 <CrazyM4n> :t (unlines . map (unwords . map (unwords . map show)))
23:49:03 <lambdabot> Show a => [[[a]]] -> String
23:49:09 <CrazyM4n> Yea, that´s correct
23:49:11 <CrazyM4n> Hm
23:52:23 <jle`> :t unlines . map unwords . (map . map) unwords . (map . map . map) show
23:52:24 <lambdabot> Show a => [[[a]]] -> String
23:52:37 <jle`> the magic of functor laws
23:54:42 <merijn> I'm not sure that's any clearer :)
23:59:29 <CrazyM4n> http://prntscr.com/4r1gz9
