00:00:02 <merijn> mroman_: You can with my approach
00:00:06 <mroman_> Really?
00:00:09 <mroman_> I don't beleive that.
00:00:35 <merijn> mroman_: Copy my gist into a file, load in ghci and try
00:00:48 <mroman_> btwy our code doesn't compile
00:01:29 <mroman_> Invalid type signature: Nil :: HList []
00:01:34 <merijn> It does, although it requires GHC 7.6, potentially 7.8
00:01:46 <merijn> '[], not []
00:01:55 <mroman_> I have 7.8.3
00:02:02 <tero-> merijn: whoa, magic :)
00:02:12 <merijn> Then it should if you copy + paste exactly as-is
00:02:25 <tero-> is there a runtime penalty involved?
00:02:42 <merijn> tero-: Nope
00:02:54 <merijn> tero-: More magic: https://gist.github.com/merijn/39dc86e345e87276c523 https://gist.github.com/merijn/6130082
00:03:58 <mroman_> merijn: magic.
00:04:12 <merijn> tero-: This is all checked at compile time, the biggest problem is 1) horrific type errors and 2) rather annoying and hard to deal with data coming from "outside" (i.e. files, user input, network)
00:04:46 <merijn> If you need to deal with data coming from outside your program you really want dependent types to do it properly, still, you can do a lot of neat tricks this way :)
00:04:56 <tero-> merijn: impressive :)
00:05:18 <mroman_> merijn: How do type signatures look like with that?
00:05:26 <mroman_> i.e. for a list [Int, String]?
00:05:43 <mroman_> HList Int ': HList String ': Nil?
00:05:47 <merijn> tero-: I can highly recommend reading up on GADTs (the wikibook is good) and type families (I recommend the "Fun with Type Functions" paper)
00:05:59 <merijn> mroman_: Are you familiar with the term "kind"?
00:06:03 <mroman_> yes
00:06:28 <merijn> mroman_: Right, so you know that all values have types of kind *, yes?
00:06:28 <tero-> merijn: I need to prepare with lots of coffee for those
00:06:37 <merijn> tero-: They're pretty easy, tbh :)
00:06:59 <mroman_> merijn: Yep
00:07:18 <mroman_> Data constructor â€˜Consâ€™ comes from an un-promotable type â€˜HListâ€™
00:07:18 <merijn> mroman_: DataKinds allows you to define kind other than * with their own types. It does this by lifting all normal types to the kind level
00:07:23 <Kirsty23>  Hi! I give you some videos. I hope you like! http://tinyurl.com/ozfvxy3
00:07:46 <merijn> mroman_: So "data Foo = Bar | Baz" normally defines a *type* Foo with value constructors Bar and Baz
00:08:05 <mroman_> I've never seen kind [*] though
00:08:13 <merijn> mroman_: With DataKinds on "data Foo = Bar | Baz" defines *two* things 1) a type Foo with value constructors Bar and Baz, as normal
00:08:26 <merijn> mroman_: 2) it defines a new *kind* Foo with *types* Bar and Baz
00:08:50 <mroman_> merijn: Oh. That's some other kind of Kind
00:08:56 <merijn> mroman_: This also works for, for example, lists. So [*] is the kind of lists of types
00:09:01 <mroman_> I know of type-kinds(?)
00:09:04 <merijn> mroman_: i.e. [Int, String] :: [*]
00:09:26 <merijn> mroman_: The ' disambiguates between lifted types and normal types
00:09:53 <mroman_> so. HList '[Int, String]?
00:09:59 <merijn> mroman_: i.e. "[Int] :: *", but "'[Int] :: [*]" and "[ 'Int ] :: [*]" too
00:10:22 <mroman_> I see.
00:10:31 <merijn> mroman_: So I'm defining a GADT, whose type constructor has a *type* of kind [*] as first argument
00:10:44 <merijn> And "Nil :: HList '[]", i.e. an empty type level list
00:11:08 <merijn> "Cons :: a -> HList l -> HList (a ': l)" <- type level append
00:11:43 <shachaf> merijn: [ 'Int ] seems like a confusing thing to talk about.
00:11:53 <merijn> mroman_: So GHC can now *prove* that when I have type "HList (a ': l)" then the constructor *must* be Cons and the first element *must* be an 'a'
00:12:04 <mroman_> This is some serious black magic.
00:12:16 <merijn> mroman_: It's actually similar to creating a list using tuples "(Int, (Char, ()))"
00:12:19 <merijn> mroman_: But prettier :)
00:12:52 <merijn> mroman_: Like I said, I recommend the GADTs wikibook and "Fun with Type Functions" for diving into this sort stuff, see also the other gists I linked to tero-
00:13:22 <merijn> shachaf: I dunno, I think the ' there is harder to miss than with '[Int]
00:14:01 <shachaf> merijn: That would correspond to a lifted data constructor as in data T = Int | ...
00:14:13 <shachaf> Not to the type Int (which isn't ever spelled 'Int)
00:14:33 <merijn> shachaf: oh, yeah, actually that's just wrong
00:14:50 <merijn> shachaf: It's getting late!
00:16:33 <shachaf> Oh, indeed it's wrong because it wouldn't be :: [*] as you said.
00:18:22 <merijn> Right
00:19:07 <shachaf> DataKinds really jammed up the type system.
00:27:23 <cdc_> :t mempty
00:27:24 <lambdabot> Monoid a => a
00:27:34 <jle`> is there some commonly used pattern for the composition of (Int, a) -> b functions?
00:27:37 <cdc_> I always confuse mzero and mempty
00:27:56 <jle`> Int is just a placeholder for a constant type
00:28:03 <cdc_> jle`: Reader Monad?
00:28:11 <jle`> hm
00:28:15 <jle`> oh, i haven't finished
00:28:21 <jle`> every time the function is composed, the Int is bumped up
00:28:23 <jle`> so it's not monadic
00:28:43 <cdc_> Sounds like an iteration with an accumulator?
00:28:54 <cdc_> :t mapAccum
00:28:55 <lambdabot>     Not in scope: â€˜mapAccumâ€™
00:28:55 <lambdabot>     Perhaps you meant one of these:
00:28:55 <lambdabot>       â€˜IM.mapAccumâ€™ (imported from Data.IntMap),
00:29:32 <jle`> so...comp f1 f2 = \(i, x) -> let y = f1 (i, x) in f2 (i+1, y)
00:29:49 <jle`> :t comp f1 f2 = \(i, x) -> let y = f1 (i, x) in f2 (i+1, y)
00:29:50 <lambdabot> parse error on input â€˜=â€™
00:30:00 <jle`> :t \f1 f2 (i, x) -> let y = f1 (i, x) in f2 (i+1, y)
00:30:01 <lambdabot> Num t2 => ((t2, t1) -> t3) -> ((t2, t3) -> t) -> (t2, t1) -> t
00:31:02 <jle`> :t \f1 f2 (i, x) -> let y = f1 (i :: Int, x :: a) in f2 (i+1, y :: b) :: c
00:31:03 <lambdabot>     Couldn't match expected type â€˜aâ€™ with actual type â€˜t1â€™
00:31:03 <lambdabot>       because type variable â€˜aâ€™ would escape its scope
00:31:03 <lambdabot>     This (rigid, skolem) type variable is bound by
00:33:28 <jle`> ((Int, a) -> b) -> ((Int, b) -> c) -> ((Int, a) -> c)
00:36:23 <jle`> :t (Control.Comonad.=>=)
00:36:24 <lambdabot> Control.Comonad.Comonad w => (w a -> b) -> (w b -> c) -> w a -> c
00:37:04 <mroman_> merijn: Can you do head on [*]?
00:37:18 <jle`> i think this breaks several comonad laws though
00:38:09 <jle`> most obviously, extract =>= f is not f
00:39:43 <jle`> extract here sensibly being `snd`
00:41:32 <dibblego> if Int is a semigroup, there are several ways e.g. profunctor
00:41:56 <dibblego> there is also Cokleisli
00:43:25 <jle`> the types are identical to cokleisli but it doesn't follow cokleisli laws because of what i demonstrated
00:43:59 <jle`> i am coming to the conclusion that this isn't really a useful abstraction or thing to generalize on
00:44:45 <dibblego> Cokleisli is a structure and it doesn't have laws
00:45:25 <dibblego> it has a few useful instances
00:45:30 <jle`> hm
00:45:35 <jle`> so it doesn't have aything to do with comonads?
00:45:43 <dibblego> yes it does
00:46:02 <jle`> this would be a cokleisli without any unit
00:46:13 <dibblego> (X,) is a comonad anyway
00:46:28 <dibblego> duplicate :: (x, a) -> (x, (x, a)) -- obvious
00:46:39 <dibblego> copoint :: (x, a) -> x -- snd
00:46:44 <jle`> yeah, it is; but the composition i am looking for is different than the obvious instance of Comonad
00:47:04 <jle`> f1 `comp` f2 = \(i, x) -> let y = f1 (i, x) in f2 (i+1, y)
00:47:08 <dibblego> it is also a profunctor
00:47:36 <jle`> it's not a comonad because unit =>= f is not f ... unit taken to be snd
00:48:08 <dibblego> did you mean (+1) there?
00:48:37 <dibblego> that itself doen't look particularly useful in any abstractions
00:48:54 <jle`> it can be generalzed to \(i, x) -> let y  = f1 (i, x) in f2 (succ i, y)
00:49:01 <jle`> but yeah, i don't think it is very useful as a general abstraction
00:49:47 <jle`> sry all
00:50:56 <jle`> actually, is there anything about kleisli/cokleisli sans unit?
00:51:10 <jle`> where the only law is associativity?
00:51:18 <dibblego> there is semigroupoids and semigroups package
00:51:30 <dibblego> there you will find semi-monads and semi-comonads
00:51:36 <jle`> this would be a..."semicategory"?
00:51:39 <jle`> ah, i'll look there
00:51:42 <dibblego> semigroupoid
00:52:00 <dibblego> class Semigroupoid z where (.) :: z b c -> z a b -> z a c
00:52:36 <jle`> this is new to me
00:53:05 <jle`> i wonder if i know any non-category semigroupoids that i regularly encounter
00:53:10 * jle` wonders
00:53:20 <tdammers> so Semigroupoid is basically just a generalization of function composition?
00:53:26 <tdammers> (informally speaking, that is)
00:53:46 <dibblego> NonEmptyList
00:54:27 <jle`> i'm not seeing semimonads or semicomonads in http://hackage.haskell.org/package/semigroupoids
00:54:51 <dibblego> http://hackage.haskell.org/package/semigroups
00:54:53 <jle`> dibblego: NonEmptyList?  that doesn't look like it has the right kind to be a semigroupoid
00:55:03 <dibblego> wait no
00:55:16 <dibblego> NonEmptyList is a semigroup that is not a monoid
00:55:25 <jle`> yeah
00:55:31 <dibblego> http://hackage.haskell.org/package/semigroupoids-4.2/docs/Data-Functor-Bind.html — semi-monad
00:55:32 <jle`> Max, Min, etc.
00:55:40 <jle`> oh neat, thanks
00:55:42 <dibblego> http://hackage.haskell.org/package/semigroupoids-4.2/docs/Data-Functor-Extend.html — semi-comonad
00:56:15 <jle`> :O
00:56:45 <jle`> so my thing is a bona-fide semi-comonad
00:57:31 <jle`> thank you dibblego.  i didn't even think i would find an answer
00:57:39 <dibblego> np
00:58:52 <jle`> but this only opens up more questions to a new world of semithings
01:05:31 <jle`> is there a name for semi-X in general?
01:09:45 * hackagebot rakhana 0.1.0.1 - Stream based PDF library  http://hackage.haskell.org/package/rakhana-0.1.0.1 (YorickLaupa)
01:17:16 <slehuito> Hi there,
01:17:24 <slehuito> I'm trying to install the latest Haskell Platform (2014.2.0.0) on a fresh Ubuntu 14.04.1.
01:17:31 <slehuito> I'm trying to install the latest Haskell Platform (2014.2.0.0) on a fresh Ubuntu 14.04.1.
01:17:31 <slehuito> After following instruction for "Generic Linux Binaries" at http://www.haskell.org/platform/linux.html, I did a "cabal update", which went OK.
01:17:42 <slehuito> Then I did a "cabal install cabal-install", which failed with "/usr/bin/ld: cannot find -lgmp".
01:17:51 <slehuito> Googling, I found the quite oldish link http://stackoverflow.com/questions/6360724/installing-ghc-binaries-on-linux-cant-find-libgmp-so
01:18:01 <ion> Try installing libgmp-dev
01:18:12 <slehuito> I tried the following two commands, but to no avail:
01:18:20 <slehuito> sudo ln -s /usr/lib/x86_64-linux-gnu/libgmp.so.10.0.5 /usr/lib/libgmp.so
01:18:26 <slehuito> sudo ln -s /usr/lib/x86_64-linux-gnu/libgmp.so.10.0.5 /usr/lib/libgmp.so.3
01:18:34 <slehuito> I still get the linker error.
01:18:51 <slehuito> ion: you mean with apt-get?
01:19:23 <ion> You might want to remove the symlinks you created manually and install that package. With apt, yes.
01:19:43 <slehuito> K, thanks, I'll try this
01:19:46 * hackagebot influxdb 0.7.1 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-0.7.1 (MitsutoshiAoe)
01:31:27 <slehuito> ion: thanks, it worked (well, ld choked again on library "z", but the following link saved me: http://stackoverflow.com/questions/3373995/usr-bin-ld-cannot-find-lz)
01:32:14 <ion> apt-file search libz.so
01:39:49 * hackagebot hint 0.4.2.1 - Runtime Haskell interpreter (GHC API wrapper)  http://hackage.haskell.org/package/hint-0.4.2.1 (DanielGorin)
01:55:36 <aleator> Silly question, but my brain froze and I can't think of a type that *clearly* isn't a monoid
01:55:48 <aleator> Halp?
01:57:33 <ekuam> a -> b
01:57:34 <shachaf> Void
01:58:10 <jle`> (a -> b) can be a Monoid if b is a Monoid ... but that might count for aleator's purposes
01:58:46 <jle`> any Applicative instance gives you a monoid instance for free
02:11:55 <ion> Halp is a monoid.
03:04:58 * hackagebot Zora 1.1.15 - Graphing library wrapper + assorted useful functions  http://hackage.haskell.org/package/Zora-1.1.15 (bgwines)
03:05:21 <pjdelport> aleator: IO
03:06:09 <pjdelport> aleator: Predicate (that is, type Predicate a = a -> Bool)
03:07:13 <pjdelport> (though i guess you can define Any / All like newtypes for Predicate)
03:12:28 <heilkn> hello! If I'm doing a calculation inside a do block, which returns a value inside the Maybe monad. How can I switch inside a maybe do block to chain computations, that could fail?
03:13:01 <MasseR_> heilkn: sorry I couldn't quite understand
03:13:29 <MasseR_> do { a <- return 1; b <- return 2; return (a+b) }
03:14:19 <heilkn> you're inside a do block and have a function mayFail :: a -> m Maybe b
03:14:27 <Cale> heilkn: You mean a -> Maybe b ?
03:14:29 <heilkn> now you like to continue using the maybe value
03:14:39 <Cale> You're using Maybe as a monad, right?
03:14:48 <Cale> Or are you using yet another monad m?
03:14:58 <heilkn> Cale: I'm inside a monad m and getting a value m Maybe b
03:15:04 <Cale> m (Maybe b) rather
03:15:19 <heilkn> now I'd like to chain computations with the maybe value inside the m monad
03:15:24 <Cale> So,  mb <- x; case mb of Nothing -> do ...; Just b -> do ...
03:16:00 <Cale> Or something like that, anyway
03:16:02 <heilkn> yeah, but maybe is a monad, so there should be a nicer way to compose functions without the use of if
03:16:26 <Cale> Well, if you have a bunch of Maybe values, and you want to combine them
03:16:35 <Cale> Then you can use the fact that Maybe is a monad
03:16:54 <heilkn> but how to do this, if one is allready inside a do block of an other monad
03:17:27 <Cale> Perhaps have a nested do-block? I'm not sure exactly what you're doing, so it's a little hard to suggest things.
03:17:56 <Cale> Each 'do' will correspond to only one instance of Monad
03:18:11 <heilkn> something like: myMonadConstructor $ do { a <- functionMayFail 42; /* now use a inside the next function*/; }
03:18:13 <Cale> (unless it's polymorphic, but even then, it'll just be a variable choice of a single monad)
03:18:40 <Cale> Well, if functionMayFail 42 :: m (Maybe b)
03:18:42 <Cale> then a :: Maybe b
03:19:33 <heilkn> yes, so is it possible to write: do { anotherFunction a; }
03:19:47 <Cale> If anotherFunction :: Maybe b -> ...
03:19:57 <Cale> then possibly?
03:20:07 <heilkn> anotherFunction :: b -> m c
03:20:21 <Cale> In that case, what do you want to have happen if  a = Nothing?
03:20:43 <heilkn> the whole thing should return Nothing
03:21:05 <heilkn> that's how the maybe monad works
03:21:17 <Cale> But it's not necessarily how m works...
03:21:44 <heilkn> okay, the endresult should be m Nothing
03:22:04 <Cale> So you could write  fmap anotherFunction a
03:22:27 <Cale> Well, that's probably not what you want
03:23:09 <Cale> I suppose the fancy thing would be using Data.Traversable.mapM
03:23:17 <Cale> But let's not do that
03:23:22 <Cale> Just write
03:23:24 <Cale> case a of
03:23:28 <heilkn> what I'm doing is: getting a value from a database (using) persistent and than trying to execute another query using this result
03:23:28 <Cale>   Nothing -> return Nothing
03:23:35 <Cale>   Just x -> anotherFunction x
03:25:28 <Cale> (This is what the mapM in the instance of Traversable for Maybe basically does, but there's not much harm in doing it by hand.)
03:27:14 <heilkn> not much harm, but it is very verbose
03:27:21 <heilkn> thank you very muc
03:27:23 <heilkn> much
03:27:50 <Cale> It's verbose for now, but more editable, if you're going to expand what it does in each case later
03:28:27 <Cale> Like, if instead of returning Nothing, you later decide that some sort of error report needs to be generated, there's a place to put that
03:28:54 <heilkn> Cale: But it get's nested, once you try to use the result for the next computation
03:29:25 <slomo> does someone know of a simple way to cut a ByteString in random sized (and a random number of) chunks in quickcheck?
03:29:45 <Cale> Well, you could perhaps use MaybeT
03:29:46 <heilkn> Maybe was made for this kind of failing computations, there must be an elegant way to use that inside a monad
03:29:54 <Cale> If you have a lot of them
03:30:01 <heilkn> yeah, I tried, but I don't get that
03:30:20 <Cale> Okay, so for any monad m, there's a monad MaybeT m
03:30:39 <Cale> MaybeT is a monad transformer, so you have  lift :: m a -> MaybeT m a
03:31:03 <Cale> But you also have the constructor: MaybeT :: m (Maybe a) -> MaybeT m a
03:31:36 <Cale> and you have  runMaybeT :: MaybeT m a -> m (Maybe a)
03:31:54 <heilkn> sorry, I have to leave my place now
03:31:57 <heilkn> :(
03:31:58 <Cale> which will typically be applied to your whole overall computation, once you're done chaining together all the possibly failing things
03:32:15 <heilkn> thank you very much for your time!
03:32:16 <Cale> okay, ping me when you get back if you want
03:32:28 <Cale> cheers!
03:33:25 <zcd> for the emacs users, is there a way to open haskell-interactive-mode in a vertical split?
03:50:04 * hackagebot rest-core 0.32.0.1 - Rest API library.  http://hackage.haskell.org/package/rest-core-0.32.0.1 (ErikHesselink)
03:58:54 <XniX23> is there a reason why the order of parameters in fmap and bind is not the same? for instance fmap :: (a->b) -> f a -> f b; bind (a -> m b) -> m a -> m b; would be easier to spot the relation or not?
04:02:01 <hpc> XniX23: your bind is (=<<), which is less commonly used
04:02:01 <oakwhiz> :t (=<<) -- XniX23
04:02:02 <lambdabot> Monad m => (a -> m b) -> m a -> m b
04:02:17 <hpc> do notation uses (>>=) because that's what makes sense for translating imperative-style code
04:02:23 <oakwhiz> :t flip (>>=)
04:02:24 <lambdabot> Monad m => (a -> m b) -> m a -> m b
04:02:49 <MasterMastic> Silly question.. why would one bother with the Reader & State monad, instead of just passing the environment/state information through a parameter?
04:04:06 <XniX23> hpc, but if you think from the point of view as a function that takes 2 params, its the same
04:04:10 <pjdelport> MasterMastic: The functorial / monadic interface lets you work with reader and state actions as values, without having to do all the plumbing explicitly.
04:04:13 <ekuam> MasterMastic: state is a bit fiddly to pass along
04:04:21 <ekuam> but for Reader I often don't bother
04:06:10 <MasterMastic> Could you point me to the differences? it seems like you're just as explicit, only just in a different place in your function signature.
04:07:32 <tdammers> MasterMastic: the difference is in how you compose (or "pipeline") actions
04:08:04 <pjdelport> MasterMastic: Consider using state actions like get and put: you don't actually have to explicitly relay the state variable all the time.
04:08:31 <pjdelport> MasterMastic: State is only mentioned where you actually *use* it, instead of in every bit of code that touches the code that uses it.
04:08:43 <oakwhiz> I made a function to simulate a system until it "settles down." How do I write it in terms of fix?
04:08:45 <oakwhiz> @let simC f x | f x == x = x | otherwise = simC f (f x)
04:08:45 <MasterMastic> Oh I see. But in the case for Reader, it really barely even matters, aye?
04:08:46 <lambdabot>  .L.hs:166:1: Warning:
04:08:46 <lambdabot>      Pattern match(es) are overlapped
04:08:46 <lambdabot>      In an equation for â€˜simCâ€™: simC f x = ...
04:08:46 <lambdabot>  
04:08:46 <lambdabot>  <no location info>:
04:08:55 <oakwhiz> :t simC
04:08:56 <lambdabot> Eq a => (a -> a) -> a -> a
04:09:26 <pjdelport> MasterMastic: For Reader, too: if you have a deeply-nested complex computation that only uses the environment value in a few key places inside it, then Reader lets you write that fairly naturally.
04:10:00 <pjdelport> MasterMastic: Without Reader, you would have to *explicitly* relay the environment value through every level and every step of the computation.
04:10:09 <pjdelport> (That's something that comes up less often, though.)
04:10:31 <MasterMastic> Oh yeah, that's definitely true. Thank you :)
04:11:00 <ekuam> @pl simC f x = if f x == x then x else simC f (f x)
04:11:00 <lambdabot> simC = fix (ap (ap . join . (if' .) . ((==) =<<)) . ((.) =<<))
04:11:11 <oakwhiz> Wow holy crap
04:12:02 <ekuam> do not attempt
04:12:31 <oakwhiz> Well at least it proves my hunch that it's possible
04:13:08 <ekuam> fix (\simC f x -> if f x == x then x else simC f (f x))
04:13:22 <ekuam> but you're probably better off using iterate
04:15:00 <oakwhiz> I was thinking of games like Bejeweled, where you match objects on a game board, the objects are removed from play, and then new objects fill the void, and a match is tested for again, etc.
04:15:25 <oakwhiz> that function (a -> a) -> a -> a fits this role perfectly
04:15:47 <oakwhiz> it keeps going until the system reaches an equilibrium state
04:20:53 <kgadek> hi. trying to pinpoint one detail of Haskell's typechecker (just HS98, no exts): monomorphism restriction could prevent generalization over some type variables on top level. Yet Haskell doesn't allow types of top-level functions to contain unbound type variables. Could you think of any example?
04:25:05 <fizbin> So, I don't know if anyone cares, but yesterday my issue with combining two states in StateT was eventually solved by using a single state that was just a tuple, even though that made some intermediate types nasty.
04:27:14 <fizbin> I resisted it because it'd make the state (MS.HashMap T.Text Value, (IORef [String], IORef [String], MyConfig m)) , which is kind of ugly, but I only needed that full type once.
04:27:58 <jkarni> fizbin: Using the lens library (and in particular makeClassy) allows you to only mention the parts that you need (as a class constraint)
04:28:14 <pjdelport> fizbin: Did you abstract that into a type alias to make future modifications easier?
04:29:13 <fizbin> jkarni: Yeah, just a few nice lens aliases at the top of the let ... in do ... expression that used this type made it tolerable.
04:31:05 <fProgrammer_> I am supposed to write a recursive bayesian filter for a project.. Wondering if a stateless programming language like haskell can be used?
04:31:28 <pjdelport> fProgrammer_: Haskell has excellent support for stateful programming. :)
04:31:48 <pjdelport> So yes, it can certainly be used.
04:32:06 <fizbin> pjdelport: No, since I just have it in one long let ... in do ... expression. If I need to refactor I'll rewrite all the aliases I define in the let expression
04:33:07 <fProgrammer_> pjdelport: you may be right, but I am worried it will be too complex? can you share your experience..
04:33:41 <pjdelport> fProgrammer_: It's hard to say anything in general without knowing any details.
04:35:16 <vozz> If I'm working on a file and I've got a load of imports, and I use a function, how do I figure out which import it's from?
04:36:00 <mroman_> vozz: In ghci with :i
04:36:08 <vozz> mroman_: thanks!
04:36:21 <mroman_> for example :i sortBy will tell you -- defined in Data.List
04:36:28 <fProgrammer_> pjdelport: I'm beginner in haskell, its just too hard to warp my around this thing in haskell, for example: you have a state variable Pt, how do i calculate Pt+1 which is dependent on Pt when I have no mutable objects
04:36:35 <fizbin> vozz: I don't know of a good way to do that, absent a haskell IDE. The so-so way is to start ghci, load the file with :l, then do :i symbol.
04:36:41 <pjdelport> fProgrammer_: Haskell is particularly good at writing code in an equational and mathematical style, so the more your ideas are suited to that, the more naturally Haskell will fit it. It *probably* shouldn't be too complex. How much experience do you have with any other functional languages?
04:36:50 <mroman_> fProgrammer_: modify (succ) ;)
04:37:35 <fizbin> fProgrammer_: let me strip all the proprietary stuff out of this bit of my web config parser, and it'll be a nice example of how to use state...
04:38:01 <pjdelport> fProgrammer_: There are two approaches: The first is rethink the parts of your program in terms of *transformations*: that is, instead of thinking about modifying some shared state, think about taking an input and modifying it into an output, and then just building bigger programs in terms of that.
04:38:24 <fProgrammer_> pjdelport: I used to use mathcad programming language which was essentially functional..
04:38:32 <pjdelport> fProgrammer_: For example, Haskell lets you say things like:
04:38:33 <pjdelport> > iterate (+1) 1
04:38:34 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
04:39:10 <pjdelport> fProgrammer_: That's an infinite stream of modifications to some seed value: you can use any part of it, or transform or modify it as a first-class value. Because Haskell uses lazy evaluation, being infinite isn't a problem.
04:39:12 <fProgrammer_> fizbin: that would be great
04:40:04 <fProgrammer_> pjdelport: yeah that sounds interesting, we have update equations in matrix forms
04:40:14 <fProgrammer_> state update equations*
04:40:15 <pjdelport> fProgrammer_: Haskell does have all kinds of explicit mutable state too, but you probably shouldn't reach for that first. If you don't your program can often be a lot simpler and smaller by expressing it in functional terms.
04:40:15 <mroman_> fProgrammer_: http://codepad.org/EUZKLnDr
04:40:26 <mroman_> That's an minimal example of using state
04:40:34 <mroman_> (using the State Monad)
04:41:13 <fProgrammer_> mroman_: lemme try to understand..
04:42:04 <pjdelport> fProgrammer_: Cool, but remember that state doesn't have to mean *shared* state. Haskell State type is more for the latter; you probably shouldn't worry too much about tackling until you've gained at least some understanding of the Functor and Monad abstractions first.
04:42:24 <pjdelport> fProgrammer_: It's perfectly fine to have a function update :: Matrix -> Matrix
04:42:39 <pjdelport> And then just use that in normal functional ways.
04:43:26 <pjdelport> fProgrammer_: Have you gone through a Haskell tutorial or two?
04:43:38 <fProgrammer_> pjdelport: I've also read that the lazy evaluation becomes a problem (esp performance wise)while doing complex calculations, I see stack overflow questions here and there
04:43:51 <fProgrammer_> pjdelport: yes, I almost finished LYAH
04:44:18 <pjdelport> Cool, then the best approach is probably just to implement your program and ask if you get stuck. :)
04:44:24 <pjdelport> Or paste your code for review.
04:44:53 <fProgrammer_> mroman_: It's straight forward enough, thanks for sharing..
04:44:59 <mroman_> fProgrammer_: I can probably comment the lines a bit better
04:45:11 <mroman_> but inside a State Monad you can ask for the whole state with get
04:45:16 <mroman_> and replace the whole state with put
04:45:28 <mroman_> or use modify which modifies the state by applying some function to it
04:45:31 <pjdelport> fProgrammer_: Having too-lazy evaluation can sometimes be the root of performance issues, in the same way that having too-strict evaluation can be the root of performance problems.
04:45:34 <mroman_> execState returns the final state
04:45:39 <pjdelport> The only answer to either is to profile, and to make things stricter or lazier, depending.
04:47:11 <mroman_> fProgrammer_: Other less popular means to use state are IORefs
04:47:23 <pjdelport> fProgrammer_: As a rule of thumb, i'd recommend not using State or things like IORefs until you've gained some experience with writing code without it.
04:48:00 <fProgrammer_> pjdelport: to elaborate my apprehension: I've to query data from a cassandra database, run some stochastic algorithm, and then return the value... Haskell has low support for cassandra driver.. but writing math code in C/Python/Java is nightmare, hence I stumbled upon Haskell
04:48:06 <pjdelport> They're tools for simplifying and optimizing particular kinds of code, but they should never be the first thing you reach for by default.
04:48:52 <fProgrammer_> mroman_: Thanks, will read on IORefs..
04:48:55 <pjdelport> fProgrammer_: That sounds like a high-level functional pipeline: Cassandra input -> stochastic algorithm -> output
04:49:04 <fizbin> fProgrammer_: Using stateful actions to parse out json sent into a my web service.... at http://lpaste.net/111115
04:49:28 <fizbin> Well, not my web service. My web service with all the proprietary names and stuff swapped out for silly ones.
04:49:37 <mroman_> State can also be (mostly always) passed as an argument to functions
04:50:30 <pjdelport> fProgrammer_: I really do want to emphasize that you almost certainly don't want IORefs yet. First write your program using "plain" Haskell, and then later introduce things like State and IORef if you can see the need, or someone recommends it.
04:51:27 <fProgrammer_> pjdelport: precisely, except now I have to figure out how to maintain state when going through this high level loop multiple times
04:51:36 <pjdelport> The fact that you *can* use mutable state in Haskell does not mean you *should*. :)
04:51:52 <pjdelport> fProgrammer_: Do you have some code to paste?
04:52:32 <pjdelport> fProgrammer_: The first answer is that if your high-level loop is just a function, "maintaining state" just means repeatedly applying it.
04:52:34 <fProgrammer_> pjdelport: not yet, i m just breaking down code in chunks
04:52:37 <fProgrammer_> modules
04:52:44 <pjdelport> > iterate (+1) 1
04:52:46 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
04:52:48 <pjdelport> Like that.
04:53:04 <pjdelport> The "state", there, is just successive values of the iterated function.
04:53:11 <fProgrammer_> pjdelport: I've code in python of recursive bayesian filter
04:53:18 <pjdelport> But both the function and value can be arbitrarily complex.
04:53:33 <pjdelport> You could have iterate complicatedUpdate initialState
04:54:00 <pjdelport> And then just find the desired final state in that list, just for example.
04:54:11 <pjdelport> And there are many more ways to approach it.
04:54:36 <pjdelport> fProgrammer_: You can paste the Python code.
04:54:39 <mjrosenb> is there a way to show an Int or Integer as hex?
04:55:03 <fProgrammer_> fizbin: Thanks, I didnt understand completely, lemme go through it again
04:56:53 <supki> > showHex 27 ""
04:56:55 <lambdabot>  "1b"
04:56:59 <supki> > hex # 27
04:57:01 <lambdabot>  "1b"
04:58:43 <fProgrammer_> pjdelport: Here's link from github repo, it has a kalman filter written in recursive bayesian style https://github.com/manojgudi/gr_python_module/blob/testing/dirty_commits/kf_exp/mykf.py
04:59:08 <mjrosenb>     Not in scope: â€˜hexâ€™
04:59:08 <mjrosenb>     Perhaps you meant â€˜lexâ€™ (imported from Prelude)
04:59:13 <mjrosenb> <interactive>:10:1: Not in scope: â€˜showHexâ€™
04:59:58 <fProgrammer_> perhaps i can clean the code more..
05:02:09 <pjdelport> fProgrammer_: Ah, for the linear algebra stuff, there are probably a bunch of Haskell libraries you can pull in to give the same kind of functionality as NumPy
05:02:24 <alpounet> hmatrix is a good start, usually
05:02:43 <pjdelport> (Someone in the channel who knows more can probably make recommendations.)
05:03:06 <fProgrammer_> pjdelport: thanks
05:03:25 <pjdelport> fProgrammer_: For the random number generation, you might want to look at something like MonadRandom.
05:04:13 <pjdelport> That lets you express computations that use random numbers internally, without having to explicitly thread the random number generation state through them.
05:04:40 <pjdelport> So it's a good fit for that simulation loop you have.
05:04:53 <pjdelport> The simulation loop itself you can probably just write as a function.
05:04:53 <fProgrammer_> pjdelport: oh interesting, one last doubt which might be silly, does using mutable objects in haskell reduce its parallelism
05:06:03 <pjdelport> It depends. GHC will not quite magically parallelize your code for you: however, it will allow you to take pure code, and decorate it with parallelism annotations, which it can then run in parallel. :)
05:06:18 <pjdelport> But that's a bit of a topic on its own.
05:06:43 <fProgrammer_> pjdelport: cool, i'll deal with it when and if i encounter mutable objects
05:07:29 <pjdelport> Right. Generally speaking, using actual mutable types (like the ST stuff, IORefs, etc.) will reduce your opportunities for parallelism.
05:07:38 <pjdelport> Because you're basically just writing imperative code in Haskell then.
05:07:52 <pjdelport> (with all the associated disadvantages)
05:08:50 <pjdelport> Judging from that code, you won't need that: using something to help with the RNG state is the only thing that stands out.
05:08:59 <fProgrammer_> pjdelport: yep makes sense, wonder how haskell deals with thread-safety for shared (mutable)objects.. anyway will google it up
05:09:18 <pjdelport> fProgrammer_: Same as any other imperative language: channels, locks, etc.
05:09:35 <pjdelport> fProgrammer_: However, Haskell also offers better and more powerful tools, like STM. :)
05:10:04 <pjdelport> (and also various kinds of pure parallelism, without explicit concurrency and synchronization)
05:10:25 <fProgrammer_> pjdelport: Wow STMs
05:10:35 <pjdelport> fProgrammer_: If you're really interested, bookmark this book: http://chimera.labs.oreilly.com/books/1230000000929
05:11:03 <fProgrammer_> pjdelport: nice! thanks..
05:11:09 <pjdelport> You can read it online, and it covers pretty much everything you'd want to know to get an overview of parallel and concurrent programming in Haskell
05:11:57 <bernalex> hmm is there a way to write this: n m $ case n of 5 -> +; _ -> *?   that is -- n & m are numbers, and the operator to use on them depends on n.
05:14:29 <Phlogistique> go nixo
05:14:32 <Phlogistique> oops
05:14:48 <pjdelport> foo n m = n # m where (#) = case n of 5 -> (+); _ -> (*)
05:15:58 <bernalex> pjdelport: heh I guess
05:17:59 <bernalex> pjdelport: that's almost what I came up with myself, which was using let
05:19:40 <hexagoxel> (haddock:) i re-export some declaration, but preferably do not want its full documentation to be included (maybe just a note "reexport" and a link to the source). is this possible?
05:26:02 <Sir_Pony> http://img0.joyreactor.com/pics/post/spider-girl-mouth-gif-1490289.gif
05:26:06 <Sir_Pony> creep out warning
05:26:08 <Sir_Pony> enjoy.
05:30:01 <Gonzih> Sir_Pony: cmon, how is that related to haskell?
05:31:35 <vozz> I've written a function with the type signature MonadResource f => FileInfo -> f BSL.ByteString, how would I make it so it is just FileInfo -> BSL.ByteString? Or would it have to be FileInfo -> IO (BSL.ByteString) ?
05:34:50 <alpounet> vozz: if you pick f = Identity, you whould get what you want, wouldn't you?
05:34:50 <Sir_Pony> haskell is cool and that gif is cool
05:34:58 <Sir_Pony> :P
05:35:30 <Cale> Sir_Pony: Really more of a #haskell-blah thing :)
05:35:40 <k00mi> alpounet: no MonadResource instance for Identity though
05:36:23 <k00mi> vozz: what does your function do?
05:37:26 <alpounet> k00mi: right, that wouldn't make much sense anyway. Probably best to stick to IO here I guess. There's probably a reason for this MonadResource constraint anw :)
05:37:34 <vozz> k00mi: It's just supposed to give me the contents of the file: BSL.fromChunks <$> (fileSource f $$ CL.consume)
05:39:24 <k00mi> vozz: you're doing IO, so you definitely need IO in the result type
05:40:11 <k00mi> http://hackage.haskell.org/package/resourcet-1.1.2.3/docs/Control-Monad-Trans-Resource.html#g:2
05:42:15 <vozz> k00mi: aha, I think that did it, thank you!
05:44:00 <k00mi> glad to help, feel free to ask any other questions you have :-)
05:44:41 <hexagoxel> "cabal: internal error when calculating transitive package dependencies" yay
05:45:09 <srhb> Internal error? That sounds buggy.
05:45:47 <hexagoxel> what does "cabal haddock" desugar to?
05:47:00 <hexagoxel> "cabal exec -- haddock foo", for some foo?
05:48:00 <hexagoxel> ah, it is an open issue
05:58:13 <fryguybob> kgadek: I didn't see anyone answer your question, but I think what you are getting at is how can a top-level definition be generalized in face of the monomorphism restriction.  You are free to add the type signature that you desire at the top level, it just isn't infered with the monomorphism restriction.
05:59:09 <pjdelport> (or more accurately, it's inferred but refused?)
05:59:24 <pjdelport> ("no polymorphism for you!")
06:06:18 <bernalex> @let f a b c = fromInteger a + read b + fromIntegral c
06:06:20 <bernalex> :t f
06:06:21 <lambdabot>  Defined.
06:06:21 <lambdabot> FromExpr a => a
06:06:23 <bernalex> :t f
06:06:24 <lambdabot>     Ambiguous occurrence â€˜fâ€™
06:06:24 <lambdabot>     It could refer to either â€˜L.fâ€™,
06:06:24 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:166:1
06:06:27 <bernalex> oops.
06:06:32 <bernalex> @let fooo a b c = fromInteger a + read b + fromIntegral c
06:06:33 <lambdabot>  Defined.
06:06:35 <bernalex> :t fooo
06:06:36 <lambdabot> (Read a, Num a, Integral a1) => Integer -> String -> a1 -> a
06:06:38 <bernalex> OK
06:06:42 <bernalex> > f 1 "2" 3
06:06:43 <lambdabot>  Ambiguous occurrence â€˜fâ€™
06:06:44 <lambdabot>  It could refer to either â€˜L.fâ€™, defined at L.hs:166:1
06:06:44 <lambdabot>                        or â€˜Debug.SimpleReflect.Vars.fâ€™,
06:06:44 <lambdabot>                           imported from â€˜Debug.SimpleReflectâ€™ at L.hs:117:1-26
06:06:44 <lambdabot>                           (and originally defined in â€˜simple-reflect-0.3.2:De...
06:06:47 <bernalex> > fooo 1 "2" 3
06:06:50 <lambdabot>  6
06:06:52 <bernalex> OK
06:07:04 <bernalex> so how would I map a list like "123" into that function in a terse way?
06:07:13 <latk> I'm reading in a page that is supposed to be utf-8 encoded, using Data.Text. However ' seems to be being interpreted as \226\128\153. Any ideas why ?
06:07:18 <latk> page = document
06:08:01 <SwashBuckla> how do I upgrade GHC on the Haskell Platform?
06:08:02 <bernalex> or rather, ["1","2","3"]
06:08:07 <hexagoxel> hah, when i call haddock directly, it runs into an internal error as well :D
06:08:13 <fizbin> latk: What function are you using to read in the document?
06:08:14 <bernalex> my current solution is just
06:08:30 <bernalex> > map (\n -> fooo 1 n 3) ["0","1","2"]
06:08:32 <lambdabot>  [4,5,6]
06:08:43 <bernalex> but something tells me you can do that in a more neat way
06:09:17 <fizbin> SwashBuckla: The usual solution is to upgrade the whole haskell platform.
06:10:08 <fizbin> @pl map (\n -> fooo 1 n 3)
06:10:08 <lambdabot> map (flip (fooo 1) 3)
06:10:23 <bernalex> fizbin: derp
06:10:27 <fizbin> Not neat.
06:10:31 <bernalex> fizbin: why didn't *I* just think of using pl, heh.
06:10:36 <bernalex> but yeah that's not too bad, but not too neat
06:10:58 <fizbin> Another possibility is:
06:11:25 <Kron> I vaguely remember a haskell function/operator that could be used as a kind of argument hole
06:11:30 <Kron> (fooo 1 ??? 3)
06:11:32 <Kron> something like that
06:11:39 <fizbin> > let f1 = fooo 1 in map (`f1` 3) ["0","1","2"]
06:11:40 <lambdabot>  [4,5,6]
06:12:05 <bernalex> Kron: I seem to vaguely remember that from the mailing lists yeah
06:12:14 <Kron> it looked really neat when I ran into it
06:12:23 <Kron> we should find it again, it would be really useful
06:12:27 <mr-> Kron: what is that hole supposed to do? There is _
06:12:37 <Kron> not a typed hole, I'm being metaphorical
06:12:49 <Kron> basically (foo 1 ??? 3) would be something like (\x -> foo 1 x 3)
06:12:59 <latk> fizbin: Looks like it is lazybytestring readfile, so there must be some conversion along the way. Will see what is being done..
06:12:59 <Kron> thuogh it's not "???", it's something else I don't remember
06:13:27 <fizbin> latk: readFile I think uses whatever the "local" encoding is.
06:13:43 <fizbin> I have a variation of readFile I wrote to force utf8. Let me dig it up.
06:14:01 <hexagoxel> Kron: undefined?
06:14:40 <fizbin> readFile' name = do {fh <- openFile name ReadMode ; hSetEncoding fh utf8_bom ; hGetContents fh }  -- though that gets stuff as IO String.
06:14:54 <bernalex> fizbin: btw
06:15:05 <bernalex> map ((flip a b) c) d
06:15:08 <bernalex> is the same as
06:15:18 * hackagebot debian 3.84 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.84 (DavidFox)
06:15:20 * hackagebot cabal-debian 4.17.5 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-4.17.5 (DavidFox)
06:15:31 <bernalex> erm that's not what you had
06:15:33 <bernalex> let me relook
06:15:50 <bernalex> map (flip (f a) c) b
06:16:02 <bernalex> is: map ((`f` a) c) b
06:16:22 <fizbin> Wait, latk, once you have the byte string, how are you turning it into Text ?
06:16:48 <fizbin> @pl ((`f` a) c) b
06:16:48 <lambdabot> (c `f` a) b
06:16:57 <kgadek> fryguybob: thanks for answering! Actually I had problems with stating the exact problem. I was searching for something that would trigger a particular scenario with defaulting & monomorphism restriction: MR limiting the polymorphism of something, and then defaulting making it a particular class. So eg. `sum = foldl (+) 0` did not trigger that, but I found the simple example: `pie = sum $ take 1000000 $ zipWith (/) (iterate
06:16:58 <kgadek> negate 4) [1,3..]` â€” it is inferred as `(Enum a, Fractional a) => a`, afterwards it's defaulted to Double
06:17:18 <kgadek> *had problems with stating the question precisely
06:17:49 <kgadek> *particular instance
06:17:57 <fizbin> Are you turning the byte string into text with decodeUtf8 ?
06:19:07 <bernalex> what was that function... if I have [Nothing, Just 2, Nothing, Nothing], it should give me Just 2
06:19:24 <kgadek> bernalex: mplus ?
06:19:25 <bernalex> [Nothing, Nothing] -> Nothing; [Nothing, Nothing, Just 5, Nothing] -> Just 5; and so on
06:19:28 <bernalex> kgadek: yep, thanks
06:19:36 <Iceland_jack> > msum [Nothing, Just 2, Nothing, Nothing]
06:19:37 <lambdabot>  Just 2
06:19:43 <bernalex> msum rather, yeha
06:19:52 <kgadek> haha, yes :D
06:19:53 <bernalex> but mplus made me remember the naming convention, heh
06:20:19 * hackagebot dimensional-tf 0.3.0.1 - Statically checked physical dimensions, implemented  using type families.  http://hackage.haskell.org/package/dimensional-tf-0.3.0.1 (BjornBuckwalter)
06:20:26 <fryguybob> kgadek: So there if you have  pie :: (Enum a, Fractional a) => a  you can compile fine and get that type.
06:20:31 <Kron> > let (f ? b) = (\a -> f a b) in map (fooo 1 ? 3) ["0", "1", "2"]
06:20:32 <lambdabot>  <hint>:1:6: Parse error in pattern: f ? b
06:21:10 <Kron> > let ((?) f b) = (\a -> f a b) in map (fooo 1 ? 3) ["0", "1", "2"]
06:21:12 <lambdabot>  <hint>:1:6: Parse error in pattern: (?)
06:21:20 <Kron> not sure how to bind operators in lambdabot
06:21:49 <Kron> oh wait, derp
06:21:57 <Kron> > let (?) f b = (\a -> f a b) in map (fooo 1 ? 3) ["0", "1", "2"]
06:21:59 <lambdabot>  [4,5,6]
06:22:16 <Kron> I wonder if there's a library for this already
06:22:22 <CindyLinz> > let f ? b = \a -> f a b in map (fooo 1 ? 3) ["0", "1", "2"]
06:22:23 <lambdabot>  [4,5,6]
06:24:21 <latk> fizbin: So tagsoup cleans up the html, then it is conveted to lazybytestring and parsed by xml-conduit :s
06:26:40 <fizbin> :t let f ? b = \a -> f a b in ?
06:26:42 <lambdabot> parse error on input â€˜?â€™
06:26:54 <fizbin> :t let f ? b = \a -> f a b in (?)
06:26:56 <lambdabot> (t1 -> t2 -> t) -> t2 -> t1 -> t
06:27:07 <fizbin> @hoogle (t1 -> t2 -> t) -> t2 -> t1 -> t
06:27:10 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
06:27:10 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
06:27:10 <lambdabot> Data.IntMap fold :: (a -> b -> b) -> b -> IntMap a -> b
06:28:01 <fizbin> > map (fooo 1 `flip` 3) ["0", "1", "2"]
06:28:03 <lambdabot>  [4,5,6]
06:28:28 <Zouppen> I'd like to call tcdrain() to a Handle because I want to make sure all hardware buffers are written before continuing. However, if I do that using FFI, I get "Interrupted system call". The software I'm writing is for Linux only so it may include Unix specific hacks. How can I call that C function without having problems? In C it works like charm, but via FFI it breaks.
06:28:58 <Zouppen> the device i'm writing to is a serial device
06:29:10 <fizbin> > let (?) = flip in map (fooo 1 ? 3) ["0", "1", "2"] -- if you really want to use (?)
06:29:12 <lambdabot>  [4,5,6]
06:34:10 <geekosaur> Zouppen: http://stackoverflow.com/questions/8456981/runtime-error-with-0mq-haskell-binding-getintopt-interrupted-interrupted-syst the FFI wrapper is using the wrong runtime function
06:34:40 <geekosaur> also a workaround if the program allows rtsopts may be +RTS -v0
06:35:10 <fizbin> :t let f ? b c = f b c in (?)
06:35:11 <lambdabot> Parse error in pattern: b
06:36:03 * geekosaur wonders if that's implicit params interfering
06:37:58 <byorgey> does anyone know if there's a ghci option to make it show explicit foralls in types?
06:38:10 <benzrf> what haskell library can i use to work with quantities measured in units
06:38:15 <byorgey> I tried :set -XExplicitForAll but :t still doesn't show the forall
06:38:15 <benzrf> i want one that can auto-convert
06:38:23 <benzrf> er, by auto-convert i mean understand how units combine
06:38:41 <benzrf> i.e. cancel when i divide meters by meters
06:39:13 <byorgey> http://hackage.haskell.org/package/units, http://hackage.haskell.org/package/dimensional
06:39:19 <benzrf> thank u
06:40:06 <benzrf> byorgey: whats the difrence between them
06:41:03 <byorgey> benzrf: units is newer and uses fancier type features
06:41:12 <byorgey> but I'm not familiar with the differences on a practical level
06:41:30 <byorgey> oh, I found the answer to my question: -fprint-explicit-foralls
06:42:07 <fryguybob> byorgey: I just found it too :D
06:42:23 <byorgey> fryguybob: hehe, thanks =)
06:42:55 <byorgey> I'm lecturing about polymorphism and parametricity in 15 minutes
06:44:16 * benzrf nix-env's -iA nixpkgs.haskellPackages.units
06:44:37 <fryguybob> byorgey: Oooo Have fun!
06:45:33 <byorgey> fryguybob: thanks! =D
06:52:55 <latk> Hm, so I have discovered that even if I just read the basic document (using Data.Text.Lazy.IO.readFile), and then print it, ' is displayed as \226\128\153 in the terminal. Is this just my terminal doing something stupid? The basic document should be utf-8 encoded.
06:53:49 <oakwhiz> latk: shouldn't you use putStrLn instead of print?
06:54:33 <RchrdB> latk, when you say you "print" it, what function are you using?
06:54:50 <latk> Just using traceShowM from Debug.Trace
06:55:01 <latk> Not sure what that actually does under the hood..
06:55:16 <oakwhiz> latk: a cursory stackoverflow search turns up this: https://stackoverflow.com/questions/2086842/using-haskell-to-output-a-utf-8-encoded-bytestring
06:56:01 <latk> oakwhiz: Yeah, I had a read of that - however, I am now using Data.Text, not bytesring. My understanding from the docs of Data.Text is that it should automatically be doing utf-8 ?
06:57:13 <fizbin> well, the whole question is the bytestring -> Text process.
06:57:30 <fizbin> Which is somewhat convoluted, if I read your earlier message correctly.
06:57:38 <RchrdB> latk, Debug.Trace.traceShow uses the (Show a) instance for Text.
06:57:45 <fizbin> Convoluted to the point that I couldn't follow it.
06:59:13 <RchrdB> latk, and the (Show Text) instance is a little reticent about displaying non-ASCII characters.
06:59:26 <latk> fizbin: Originally, yes. I am currently just using readFile from Data.Text.Lazy, to read a saved html file that should be utf-8 encoded. When I then show the results of reading this file, I still see the character ' displayed as \226\128\153.
06:59:41 <RchrdB> \225 \128 \153 is the UTF-8 encoding of a "â€™" character.
06:59:48 <latk> Riiight
06:59:52 <latk> that actually makes sense then
07:00:02 <latk> so there isn't any problem, and I'm just an idiot :p
07:00:05 <latk> as I suspected all along!
07:00:17 <latk> RchrdB: Where do you look up these conversions?
07:00:43 <RchrdB> latk, I strongly disagree with your statement "I'm just an idiot", that's not an idiotic mistake, it's a perfectly reasonable question!
07:01:16 <RchrdB> latk, uh, I did it by running "echo -n "â€™" | hexdump -C" at a terminal.
07:01:21 <latk> RchrdB: Hah, well I have to say the whole text encoding thing is something I have found hugely confusing
07:01:39 <fizbin> Though if you're seeing it displayed that way, I worry that Text isn't reading it properly, and is reading it as three characters.
07:01:41 <geekosaur> as does pretty much everyone
07:02:05 <latk> fizbin: How could I confirm this ?
07:02:14 <geekosaur> yes, that makes me think it's reading it as an iso8859
07:02:45 <RchrdB> I think geekosaur is right.
07:02:49 <latk> Hmm. Could be that my current locale is wrong?
07:02:59 <latk> How can I check what my current locale is ? (on osx)
07:03:03 <RchrdB> How does Data.Text.Lazy.readFile decide what encoding it's reading in?
07:03:22 <fizbin> "system dependent"
07:03:24 <RchrdB> it might use the encoding on the handle, which you can set with IIRC System.IO.hSetEncoding or something.
07:03:32 <geekosaur> latk: it's unusual for OS X to have the wrong locale, although it can happen due to a particular bug
07:03:40 <oakwhiz> http://hackage.haskell.org/package/text-0.7.1.0/docs/Data-Text-Lazy-IO.html
07:03:42 <geekosaur> `locale` at the shell should show
07:03:44 <oakwhiz> "Beginning with GHC 6.12, text I/O is performed using the system or handle's current locale and line ending conventions. "
07:03:56 <latk> LANG="en_GB.UTF-8"
07:03:57 <fizbin> geekosaur: Really? I see OS X having some stupid MacRoman locale all the time.
07:04:28 <latk> I'm on ghc 7.8.3, so it should be using the correct locale :s
07:04:31 <geekosaur> a particular pain point is that under some circumstances "locale" will show "UTF-8" for a locale and this can break other programs somewhat
07:05:01 <geekosaur> (as opposed to en_US.UTF-8 or some other actual locale string)
07:05:09 <RchrdB> latk, try calling hGetEncoding? :)
07:05:09 <latk> hm, actually there is a line "LC_ALL=", and nothing following it
07:05:13 <latk> could this be a problem ?
07:05:14 <geekosaur> fizbin, I have heard of that but have never seen it
07:05:17 <geekosaur> yes
07:05:39 <geekosaur> your locale is "C" (POSIX compatibility default), it'll be reading bytes
07:05:45 <shiona_> has anyone worked with System.Plugins lately?
07:05:55 <geekosaur> export LC_ALL=en_US.UTF-8 (or other appropriate locale)
07:06:01 <shiona_> I came across an error that resembles https://ghc.haskell.org/trac/ghc/ticket/5053 alot
07:06:25 <geekosaur> I thought System.Plugins was bitrotted
07:06:46 <shiona_> oh, is there a non-bitrotted alternative?
07:06:46 <geekosaur> it does do somewhat evil things with ghc internals, so that would not be particularly surprising
07:06:57 <fizbin> readFile' name = do {fh <- openFile name ReadMode ; hSetEncoding fh utf8_bom ; Data.Text.Lazy.IO.hGetContents fh } Â -- I think. Not sure.
07:07:13 <geekosaur> ghc-api has load/unload abilities these days. I don't know offhand if there is a wrapper that is easier to use though
07:07:16 <fizbin> :t let readFile' name = do {fh <- openFile name ReadMode ; hSetEncoding fh utf8_bom ; Data.Text.Lazy.IO.hGetContents fh } in readFile'
07:07:17 <lambdabot> Not in scope: â€˜openFileâ€™
07:07:17 <lambdabot> Not in scope: data constructor â€˜ReadModeâ€™
07:07:17 <lambdabot> Not in scope: â€˜hSetEncodingâ€™
07:07:32 <shiona_> let's see
07:07:43 <fizbin> Okay, so it needs more imports.
07:08:20 <latk> RchrdB: So the encoding si UTF-8
07:08:47 <fizbin> latk: If Text were reading it properly, it would display the character as "\4121"
07:08:52 <latk> Hm
07:09:10 <latk> fizbin: Okay, well at least I know there is a problem then :P
07:09:14 <fizbin> latk: If you're seeing \225\128\153 , then Text is not doing the utf-8 conversion properly.
07:09:27 <shiona_> geekosaur: thanks, this looks lika a good direction
07:09:32 <latk> fizbin: Could you explain why it should display it like this, if \225\128\153 is the correct utf8 ?
07:09:55 <latk> are there mutliple representations of ' or something ?
07:10:09 <geekosaur> latk: because Text should read utf8 and convert it to unicode codepoints internally
07:10:15 <fizbin> > let q :: Data.ByteString.Char8; q = "\225\128\153" in Data.Text.Encoding.decodeUtf8 q
07:10:17 <lambdabot>  Not in scope: type constructor or class â€˜Data.ByteString.Char8â€™Not in scope:...
07:10:17 <geekosaur> \4121 is the representation of that codepoint
07:10:29 <RchrdB> latk, 'cuz \225\128\153 is the values of the bytes that make up a "â€™" codepoint when encoded in UTF-8, but what you want inside a Text variable is the unicode codepoint for "â€™"
07:10:37 <latk> geekosaur: Ah, okay.
07:10:37 <fizbin> Stupid limited lambdabot.
07:10:51 <latk> Hmm
07:11:18 <fizbin> > let q :: Data.ByteString.Char8.ByteString; q = "\225\128\153" in Data.Text.Encoding.decodeUtf8 q
07:11:19 <lambdabot>  Not in scope:
07:11:19 <lambdabot>    type constructor or class â€˜Data.ByteString.Char8.ByteStringâ€™
07:11:19 <lambdabot>  Perhaps you meant â€˜Data.ByteString.Lens.IsByteStringâ€™ (imported from Data.By...
07:11:23 <geekosaur> if you see the individual bytes then it is not reading it as utf8, it's reading bytes
07:12:03 <fizbin> > let q :: Data.ByteString.ByteString; q = "\225\128\153" in Data.Text.Encoding.decodeUtf8 q
07:12:04 <lambdabot>  Not in scope:
07:12:04 <lambdabot>    type constructor or class â€˜Data.ByteString.ByteStringâ€™
07:12:04 <lambdabot>  Perhaps you meant â€˜Data.ByteString.Lens.IsByteStringâ€™ (imported from Data.By...
07:12:05 <latk> geekosaur: Okay, that makes sense
07:12:11 <geekosaur> > let q :: BS; q = "\225\128\153" in q
07:12:13 <lambdabot>  Not in scope: type constructor or class â€˜BSâ€™
07:12:15 <geekosaur> bah
07:12:20 <geekosaur> no idea what it has loaded or how
07:12:38 <simpson> :t BS.pack
07:12:38 <fizbin> > let q :: BS.ByteString; q = "\225\128\153" in Data.Text.Encoding.decodeUtf8 q
07:12:39 <lambdabot> [Word8] -> BSC.ByteString
07:12:40 <lambdabot>  Not in scope: â€˜Data.Text.Encoding.decodeUtf8â€™
07:12:56 <simpson> :t T.decodeUtf8
07:12:57 <lambdabot> Not in scope: â€˜T.decodeUtf8â€™
07:12:59 <Zouppen> geekosaur: thanks for the link. it was not that issue, but I was using throwErrno instead of throwErrnoIfMinus1Retry_. It seems that for some reasons it needs the retry thing. Here's the final source which seems to work perfectly now: https://github.com/koodilehto/kryptoradio/blob/cddeedb636d7aaf9e2e1bd6e8685e90e4ceba727/core/src/Serial.hs#L33
07:13:01 <simpson> Huh, that's strange.
07:13:10 <fizbin> @import Data.Text.Encoding
07:13:10 <lambdabot> Unknown command, try @list
07:13:29 <geekosaur> Zouppen, the ghc runtime uses itimers, so syscalls need to be restarted across them
07:13:43 <ij> Why doesn't this work? http://sprunge.us/idKF
07:14:15 <geekosaur> some syscalls are automatically restarted; most aren't and you must catch EINTR and restart manually. throwErrnoIfMinus1Retry_ abstracts this for the Haskell FFI
07:14:48 <fizbin> ij: What's the type of "f" ?
07:14:57 <geekosaur> insufficient information in that paste
07:15:35 <ij> fizbin, f :: (t, SBoard) -> (SPoint, SBoard)
07:16:06 <fizbin> ij: And what's SPoint?
07:16:14 <latk> Aha! So after I updated the LC_ALL env variable (and then remembered to restart the terminal) it seems to now correctly display it as '
07:16:16 <hexagoxel> would it make sense to bump the package version number right after publishing, so that people working with head can properly encode that dependency?
07:16:29 <fizbin> ij: Haskell is complaining that it can't turn (0, 0) into an SPoint
07:16:35 <hexagoxel> pvp does not mention this, does it?
07:16:46 <Zouppen> geekosaur: ok, nice to know. maybe I should've read more documentation :-) so it should be safe to do it like I'm doing it now?
07:16:50 <fizbin> :t iterate
07:16:51 <lambdabot> (a -> a) -> a -> [a]
07:16:58 <geekosaur> it should be, I think
07:18:17 <fizbin> ij: So you should look at your definition of SPoint, and tell me why it can't turn (0, 0) into an SPoint.
07:19:06 <ij> fizbin, All files of the little project, catted into a compilable file: http://sprunge.us/dGfb
07:19:33 <ij> Oh, wait it indeed isn't a SPoint.
07:20:25 <fizbin> ij: It seems to me then that the type of "f" is SPoint -> (SPoint, SBoard)
07:20:37 <fizbin> And iterate needs a function that's of type a -> a
07:20:51 <ij> This works. "iterate f (((0,0), 0), h)" I just failed to give it the correct type, as you said.
07:21:13 <ij> I was confident that the type I need was something that wasn't actually an SPoint.
07:21:51 <fizbin> Ok
07:22:59 <remdezx> Hello! How ghci handle compile errors? Where can I find it in ghc-api?
07:25:16 <oakwhiz> Why does GHCi freak out here? http://lpaste.net/111119
07:26:16 <ij> Could someone also take a look at my first attempt to backtrack a sudoku puzzle at functions guess{Once,} at 177-181? http://sprunge.us/dGfb?hs It does sort of work, but when I trace what combos it's trying, it seems to be looping on the hardest puzzle, but not the simpler ones.
07:27:57 <ij> The puzzle in question is stored in h, line 188.
07:29:50 <xeno_> so, is there any difference whatsoever between do foo \n bar \n baz and do foo \n bar >> baz ?
07:30:30 * hackagebot persistent 2.0.3.1 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-2.0.3.1 (GregWeber)
07:30:32 * hackagebot persistent-mongoDB 2.0.3.1 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-2.0.3.1 (GregWeber)
07:30:34 * hackagebot persistent-template 2.0.3.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-2.0.3.1 (GregWeber)
07:32:08 <RchrdB> xeno_, inside a "do" notation block, no, they desugar to the same thing.
07:32:34 <RchrdB> do { a; b; c; } gets transformed to (a >> b >> c).
07:32:55 <RchrdB> xeno_, so no, there is no difference. :)
07:33:54 <fizbin> The difference there is all in the audience.
07:34:33 <fizbin> If you think that the code has no (human) audience, it probably still has an audience of yourself six weeks from now trying to figure out what it said.
07:40:32 * hackagebot shake 0.13.3 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.13.3 (NeilMitchell)
07:51:36 <Dtgr> anybody used http://hackage.haskell.org/package/hotswap-0.1.9.13 with recent versions of ghc?
07:52:12 <Dtgr> it compiled fine, but the plugins miss a bunch of symbols starting with ghczmprim_GHCzi...
07:55:08 <geekosaur> Dtgr, sounds like it depends on an outdated ghc (and it's directly accessing primitives)
07:55:32 <geekosaur> which would make it rather sensitively dependent on ghc version
07:56:09 <Dtgr> sounds plausible
07:57:24 <Dtgr> although it's just a simple wrapper over System.Plugins.Load
07:58:49 <geekosaur> oh. System.Plugins is indeed very compiler version dependent, and badly bitrotted
07:59:36 <geekosaur> current ghc-api (as of 7.8.x) supports everything that plugins used to do, properly instead of using the evil internals hacks that plugins used, but some things haven't been ported to use ghc-api yet
08:00:47 <Dtgr> ah, okay. my case is quite simple: I'm just loading .o files during runtime and calling a function inside them. Do you think that is doable on current ghc-api?
08:01:14 <luite> Dtgr: haskell or foreign .o ?
08:01:17 <Dtgr> haskell
08:02:49 <geekosaur> Dtgr, easily. the problem point in the past was unloading
08:03:06 <luite> Dtgr: ah you'd use the GHCi linker then, i'm not sure if you also need the .hi file for that
08:03:33 <Dtgr> well, needing .hi file is not a problem
08:04:11 <geekosaur> needing .hi file is a thing no matter what, if you're loading haskell code
08:05:27 <Dtgr> I'll start exploring ghc-api. Thanks a lot.
08:05:58 <luite> geekosaur: loading a .so should be doable without
08:07:03 <luite> and i'm not sure why it would be needed for a .o, but i'm not too familiar with that part of ghc
08:10:56 <geekosaur> insufficient type information encoded in the symbol name, I think?
08:11:28 <geekosaur> might work for anything that's monomorphic without the .hi
08:12:35 <mroman_> hPutStrLn hndl "foo"; hFlush hndl; takes surprisingly long to arrive at clients
08:12:44 <luite> geekosaur: oh you can call polymorphic things too, but they do have to match exactly.
08:12:58 <mroman_> like 6 seconds
08:14:00 <mroman_> either that or forkIO takes incredibly long to fork
08:15:26 <geekosaur> forkIO takes no time at all. but it doesn't actually "fork", it spawns a spark (very lightweight green thread)
08:15:46 <mroman_> still
08:15:57 <mroman_> my welcome message I send the clients right after forkIO takes sooo long to arrive
08:16:35 <geekosaur> I think we'd have to see actual code
08:16:40 <mroman_> that can be arranged
08:17:05 <mroman_> http://codepad.org/Gd5kiE9d <- voila
08:17:40 <mroman_> it's not production code of course. Just sandbox stuff.
08:17:51 <mroman_> and it won't be production if it takes 6s ;)
08:19:31 <geekosaur> 6s seems rather excessive for just that
08:19:46 <geekosaur> (also hFlush followed by hClose is redundant
08:20:03 <mroman_> the contents of the file comes immediately
08:21:09 <mroman_> I can't reproduce it locally though
08:21:16 <mroman_> but it can't be possibly that slow remotely as well
08:21:41 <geekosaur> (it would be if you had *my* local network, but likely not for the same reason)
08:22:00 <srhb> mroman_: Is the welcome message the ULTTP thing?
08:23:04 <pjdelport> mroman_: You don't have a remote firewall that tries to log the reverse lookup of clients' IP addresses, or something?
08:23:42 <mroman_> srhb: yes
08:23:46 <pjdelport> mroman_: Just a hunch; many "strange delays right after connecting" problems end up being of that flavor.
08:24:27 <mroman_> I don't have a 6s delay when connecting to my apache server
08:24:33 <mroman_> that's all I know so far
08:25:09 <mroman_> but I shall try it at home instead of here
08:25:12 <srhb> Well, I certainly can't reproduce it over the wire either.
08:25:25 <srhb> Nor do I see any reason in Haskell land why you should experience that.
08:25:45 <srhb> mroman_: telnet qtr.dk 15001
08:25:46 * geekosaur would probably resort to tcpdump/wireshark next, tbh
08:25:49 <srhb> And yeah
08:26:03 <pjdelport> mroman_: To narrow it down, try tcpdumping on the remote side?
08:26:16 <pjdelport> Ah, yeah.
08:26:33 <pjdelport> Is it consistently 6s?
08:26:39 <nshepperd> reverse dns is a common culprit of mysterious delays, I've found
08:26:56 <mroman_> pjdelport: Pretty much @6s
08:30:36 <yyttr3> Is there a good way to deal with nested type constructors? Maybe Int is easy to deal with, but something like Either a [Maybe [Char]]
08:30:45 <yyttr3> is a lot uglier to deal with
08:32:06 <ij> Doesn't lens do that? (I might be wrong, I'm a noob)
08:32:18 <ij> By dealing with you mean getting/setting?
08:39:31 <athan> Has anyone here tried to parse get parameters in scotty? I'm thinking of using http-types' Network.HTTP.Types.URI against a matched route, like "/foo/:getParamStuff"
08:39:46 <athan> s/get/http GET
08:40:57 <pjdelport> yyttr3: You could always flatten it to a more domain-specific type. data Fnord a = Foo a | Bar String | Quux
08:41:20 <pjdelport> (depends entirely on what you're aiming for, though)
08:43:25 <pjdelport> Sorry, that should be: data Fnord a = Foo a | Bar [Maybe String] | Quux
08:49:55 <gdoteof_> so.. my executable is like 58M and after stripping it, like 38M.  when i run strings on it, i get lots of superfluous things.. including the string 'histroyofscience'
08:50:35 <gdoteof_> my question is really: how much can i shrink this thing by being more strict in my imports
08:50:55 <gdoteof_> and are there any other things i can do to take definitely superfluous stuff out of my executable
08:51:53 <oakwhiz> gdoteof_: the strip command might shrink it a bit
08:52:16 <oakwhiz> gdoteof_: you could also use an executable packing algorithm like UPX
08:52:34 <highschooler> I was wondering, if anyone knew of any colleges with Computer Science programs that focused on Haskell or functional programming in general? Or would it be a thing most would do, with SICP and scheme and the like?
08:53:08 <doismellburning> highschooler: the first language I was taught as an undergrad was ML
08:53:29 <gdoteof_> oakwhiz: those strings are after stripping it; it is 38M after stripping 58 ebfore
08:54:20 <gdoteof_> specifically i have network.publicsuffixlist  i am not sure i need that
08:54:33 <highschooler> doismellburning:  was it throughout the program or only as an introductory course?
08:54:52 <pjdelport> gdoteof_: http://stackoverflow.com/a/6115703/444705
08:55:30 <pjdelport> gdoteof_: Would linking with -dynamic be possible for your usage?
08:55:30 <oakwhiz> gdoteof_: One option might be to use LLVM to compile your executable instead
08:55:30 <cite-reader> My college started in C of all things, then moved on to Java. The only thing that was taught in a functional language was the first half of Compilers.
08:55:42 <doismellburning> highschooler: bit of both; this was about 10 years ago now, so there was a bit of a later focus on Java for Doing Stuff
08:55:59 <gdoteof_> pjdelport: it wouldn't really.  in fact, the 38M isn't really that big of a deal, just surprisingly large
08:56:13 <gdoteof_> and am trying to get a better understanding of how things are linked in
08:56:48 <pjdelport> gdoteof_: By default, all the haskell libraries you use are statically linked in; -dynamic makes the executable use dynamic linking for that too.
08:57:46 <gdoteof_> pjdelport: and there is no 'partial' import.  if i import a specific function from a module rather than the whole module, that is only helping me keep my head straight and the refrences unambiguous
08:57:47 <highschooler> <doismellburning> <cite-reader>:Would you guys say this would be on par for most colleges today?
08:57:48 <pjdelport> gdoteof_: https://www.haskell.org/ghc/docs/latest/html/users_guide/using-shared-libs.html might interest you
08:58:13 <gdoteof_> doing a partial import still statically links the whole module?
08:58:26 <pjdelport> gdoteof_: Well, dead code elimination should probably take care of eliminating many things.
08:58:40 <pjdelport> I don't know enough about GHC to know how much that affects things here, though.
08:58:46 <pjdelport> (Does anyone else?)
08:59:05 <cite-reader> highschooler: I haven't followed things too closely, but as far as I know it's pretty normal.
08:59:24 <pjdelport> gdoteof_: My assumption would be that GHC will eliminate any definitions in a module that you don't use at all.
08:59:41 <pjdelport> (in an imported module, that is)
09:00:17 <gdoteof_> pjdelport: that used to be my assumption, but isn't anymore
09:00:46 <gdoteof_> re LLVM, i am not too familiar.  if i compile via LLVM is it just as portable, or does it pose an LLVM depedency on the user?
09:00:48 <pjdelport> gdoteof_: Well, for most modules, you probably will end up indirectly depending on most of its code.
09:00:50 <doismellburning> highschooler: no idea sorry
09:00:59 <gdoteof_> pjdelport: ya prob that is what is happening
09:01:18 <pjdelport> gdoteof_: I assume that importing same large module and only using some tiny helper that's independent of all the rest of the code in the module would be the extreme rare case.
09:01:32 <highschooler> <doismellburning> Its all good, I'm currently in junior year of the IB program so I'm trying to figure out what colleges seem like good shots and all that, thanks for the help.
09:01:35 <pjdelport> In most cases, most of the code in a module would end up interlinked: that's why it should be a module. :)
09:03:09 <thoughtpolice> if you have module A, and it depends on module B, and you compile A, B will always be linked in. why? well, GHC compiles full modules into object files so two object files A and B, and a linker typically won't strip unused code in an object file directly AFAIK (but they may strip entirely unused object files OTTOH.)
09:03:34 <pjdelport> Aha.
09:03:50 <thoughtpolice> but also, just because you import one thing from a module does not mean you only need to link against that. it may be the case that when you import 'f' from B, 'f' calls a lot of other stuff inside 'B'. perhaps 'f' itself can be inlined, but GHC may not inline calls to things called by 'f'
09:04:38 <pjdelport> Oh, okay: https://ghc.haskell.org/trac/ghc/wiki/ProjectSuggestions#Compiler
09:04:53 <pjdelport> That lists "Whole-program dead-code detection" as a project suggestion.
09:05:04 <pjdelport> So then GHC doesn't do that yet, presumably.
09:05:11 <thoughtpolice> as a side note, GHC can do something to basically achieve what you want, called "Split Objects", but I wouldn't really recommend enabling it
09:05:22 <thoughtpolice> we use it inside GHC, but we don't really generally support it in the wild
09:05:52 <gdoteof_> extremely helpful discussion, thank you
09:05:54 <geekosaur> interesting, last I checked it was enabled by default for user code on any platform where it wasn't known to completely not work
09:06:40 <thoughtpolice> ("Split Objects" means rather than producing a single object file "A.o" from "A.hs", you instead generate a family of object files, an object file for every function inside 'A'. then the linker actually can eliminate dead object files when it goes to do the final link)
09:07:00 <pjdelport> thoughtpolice: Neat!
09:07:44 <thoughtpolice> geekosaur: AFAIK it's not enabled in general for any user facing code, but you can force it via cabal. we use it to make 'base' and other libraries in GHC smaller to link against, which is worth it for users, but it's probably not good to use beyond that.
09:08:39 <Glenn> Is it any Swedish people in this room?
09:08:48 <pjdelport> It's --enable-split-objs for Cabal and -split-objs for GHC, apparently
09:10:25 <pjdelport> http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html#idp11917776
09:14:57 <benzrf> ruukasu: [Ì²Ì…$Ì²Ì…(Ì²Ì… Í¡Â° ÍœÊ– Í¡Â°Ì²Ì…)Ì²Ì…$Ì²Ì…]
09:15:42 * hackagebot cabal-bounds 0.8.7 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.8.7 (DanielTrstenjak)
09:17:27 <ruukasu> benzrf: please don't spam the channel. #haskell-blah is available if you'd like to do so
09:17:36 <benzrf> ruukasu: i fucking hate you
09:18:12 <geekosaur> o.O
09:18:29 <benzrf> geekosaur: i showed him that face in #haskell-blah, then he reached over and pasted it here so he could see it on his end
09:18:39 <benzrf> [we're near each other irl]
09:19:33 <albeit> If I have a newtype deriving Num,Ord,Real,Integral, if I use a value of "0" (zero) for it, will it work? Like "zeroPrice = 0 :: Price"?
09:19:54 <benzrf> albeit: presumably
09:20:08 <benzrf> albeit: you just need a Num instance for numeric literals
09:20:19 <albeit> benzrf: Ah okay, thanks
09:20:52 <cdk> albeit: the fromInteger function from Num is used for literals
09:20:53 <benzrf> albeit: well, to be precise you need a Num instance that provides fromInteger
09:20:54 <ruukasu> geekosaur: is freebsd your main os?
09:20:56 <joseph07> albeit: I don't know if that will work for non-integer literals though
09:21:30 <xeno_> I got some example code (in Beginning Haskell) that reads two numbers like 'n1 <- fmap read getLine' and then add them with (n1+n2) - which fails, because n1 and n2 are strings...
09:21:54 <geekosaur> ruukasu, OS X is my primary OS, but I have a small loal server-thing running 10.0-RELEASE and a work VM running Centos7
09:22:00 <geekosaur> *local
09:22:08 <xeno_> so what should I do above?
09:22:46 <lumo_e> read :: Int ?
09:22:52 <lumo_e> don't know actually
09:23:22 <pjdelport> xeno_: There's a readLine builtin you can use, by the way, which is equivalent to read <$> getLine.
09:23:34 <geekosaur> that seems wrong, what you described should cause read to be inferred to use String -> Integer instance
09:23:53 <pjdelport> xeno_: <$> (from Control.Applicative) is just the operator version of fmap, if you haven't seen that yet.
09:24:09 <lumo_e> geekosaur, try
09:24:11 <geekosaur> however if you're typing independent lines in ghci instead of using a compiled file, hm, might be fouling type inference
09:24:14 <lumo_e> fmap read getLine :: IO Int
09:24:25 <lumo_e> tried it on ghci right know and it seems to work
09:24:35 <geekosaur> perhaps you meant xeno_ instead of me
09:24:49 <lumo_e> sorry dino
09:24:52 <lumo_e> xeno_,
09:25:11 <pjdelport> xeno_: Consider the following: (+) <$> readLn <*> readLn
09:26:01 <pjdelport> xeno_: That's essentially the same as (+) n1 n2, but uses Applicative to apply (+) to the result of the two readLn actions instead.
09:27:05 <pjdelport> xeno_: It means the same as the following: do n1 <- readLn; n2 <- readLn; return (n1 + n2)
09:27:30 <joseph07> albeit: If you make Price an instance of Rational then you can do things like 5.54 :: Price
09:27:45 <albeit> Okay
09:28:09 <ion> s/Rational/Fractional/
09:28:51 <joseph07> ion: thanks
09:29:30 <joseph07> albeit: Fractional is the class you need to make an instance of. Rational is just a type
09:32:28 <lf94> Is Double in the Fractional class?
09:32:34 <lf94> :t Fractional
09:32:35 <lambdabot> Not in scope: data constructor â€˜Fractionalâ€™
09:32:38 <lf94> :t Double
09:32:39 <lambdabot> Not in scope: data constructor â€˜Doubleâ€™
09:32:43 <cite-reader> :i Double
09:32:49 <lf94> What does i stand for
09:32:52 <cite-reader> Aw, Lambdabot doesn't understand info.
09:32:55 <lf94> Ah
09:33:08 <lf94> :j Double
09:33:32 <cite-reader> Type that into ghci and it'll spit out all the typeclasses Double belongs to.
09:33:36 <cite-reader> Fractional is on the list.
09:33:44 <lf94> I was thinking today, wouldn't it be cool if there was a language where you could declare new primitive types?
09:34:06 <cite-reader> Not sure what you mean by "primitive" type.
09:34:21 <lf94> I know the whole reason of a primitive type is to be as basic as possible
09:34:23 <dhrosa> do you know why some types are primitive types lf94 ?
09:34:48 <lf94> To build other types; To define behavior?
09:34:54 <dhrosa> usually because the processor has special support for fast operations on some type
09:35:14 <dhrosa> no one uses 16-bit floating point numbers because processors use32-bit ones internally
09:35:20 <lf94> Mmmm, didn't think of it that way
09:35:33 <lf94> Ok nevermind what I said X)
09:35:44 * hackagebot scotty-cookie 0.1.0.3 - Cookie management helper functions for Scotty framework  http://hackage.haskell.org/package/scotty-cookie-0.1.0.3 (MartinsMacs)
09:37:49 <geekosaur> common processors don't even do 32-bit floats internally, but 64-bit. they make a 32-bit float type externally visible but implement it by doing 64-bit floats and then truncating separatetely --- which means that (float) math is often a bit slower than (double)
09:38:31 <geekosaur> although you'd probably need a very large loop to see it in practice
09:40:05 <carter> geekosaur: which processor does?
09:40:12 <carter> geekosaur: i dont think thas true
09:40:42 <geekosaur> last I checked that was how intel short floats worked? (also long floats, because they're 80-bit internally and truncated to 64-bit on memory store)
09:40:53 <carter> short floats are not used fro compute
09:41:04 <carter> 16bit floats are just a storage rep
09:41:15 <carter> 32bit floats arent truncated 64 bit ones though
09:41:21 * geekosaur is wondering where he misspoke
09:41:30 <carter> '"don't even do 32-bit floats internally, but 64-bit."
09:41:43 <carter> float is often faster than double
09:42:14 * merijn mumbles something about "number of values fitting in a cache line"
09:42:22 <carter> merijn: thats only part of it
09:42:25 <geekosaur> mm, it's been a while, maybe they changed that again. at one point they only implemented 80-bit internally, truncated on every operation for 32-bit and truncated on store for 64-bit
09:42:43 <carter> geekosaur: ... x87 :P
09:42:47 <carter> ?
09:43:15 <merijn> carter: Sure, but it's one of the easier parts to explain :)
09:43:16 <geekosaur> I think it continued into the Pentiums at least, which didn't use external FPU
09:43:33 <carter> i dont care about any cpu predating nehalem :)
09:44:04 <carter> except in a historical sense
09:46:58 <albeit> Is there a better way to do this? "full = concat [[elemX], listY, [elemZ]]" ?
09:47:41 <lwm> hi folks, I checked #cabal but noone around there, is hackage down? I can't seem to run a 'cabal update' ...
09:47:59 <lwm> ah right .. there is a message up top ...
09:48:10 <lwm> :)
09:48:16 <geekosaur> the topic doesn't claim it is down, just what to do when it is
09:48:35 <geekosaur> I was using hackage's web interface earlier and it seemed okay
09:48:44 <joseph07> albeit: elemX:listY ++ [elemZ]
09:49:59 <lwm> @geekosaur - OK, I think I am missing some text from my irc client ... I just read 'Hackage/haskell.org issues being investigated'
09:49:59 <lambdabot> Unknown command, try @list
09:50:22 <geekosaur> oh, my client is only showing me the end of it :/
09:50:35 <geekosaur> thst said, cabal update just succeeded here
09:51:17 <lwm> hmmm ... must be my connection
09:51:35 <lwm> bolivian wifi ain't so good :|
09:52:12 * geekosaur is leeching wifi from a motel across a 4-lane divided highway with a restaurant in the way...
09:52:30 <benzrf> @check \v l -> length (l :: [Int]) >= v ==> length (take v l) == v
09:52:30 <lambdabot>  : -1: -1:Ambiguous infix expression
09:52:41 <benzrf> @check \v l -> (length (l :: [Int]) >= v) ==> (length (take v l) == v)
09:52:43 <lambdabot>  *** Failed! Falsifiable (after 4 tests and 3 shrinks):
09:52:43 <lambdabot>  -1 []
09:52:46 <benzrf> o_o
09:53:00 <benzrf> @check \v l -> (length (l :: [Int]) >= v && v > -1) ==> (length (take v l) == v)
09:53:01 <lambdabot>  +++ OK, passed 100 tests.
09:57:11 <kludgy2> carter: Float often faster than double? The terrible legacy of x86 register hacks, incomplete specifications and lack of simple permutes. ;) horrors..
10:00:06 <phaazon> @src fromJust
10:00:06 <lambdabot> fromJust Nothing  = undefined
10:00:06 <lambdabot> fromJust (Just x) = x
10:00:12 <phaazon> oh
10:00:19 <phaazon> I thought it was more complex than that
10:00:39 <dhrosa> nope, just pattern matching
10:01:08 <joseph07> @src maybe
10:01:08 <lambdabot> maybe n _ Nothing  = n
10:01:08 <lambdabot> maybe _ f (Just x) = f x
10:01:10 <hexagoxel> is it possible to just include documentation for a package when uploading to hackage, instead of waiting for hackage to build it?
10:01:25 <dhrosa> is that why I can't access parsec 3.1.6 documentation?
10:01:40 <phaazon> Iâ€™m trying to trick around with Void
10:01:45 <phaazon> I have a similar structure than Either
10:02:00 <merijn> hexagoxel: Yes
10:02:09 <merijn> hexagoxel: http://fuuzetsu.co.uk/blog/posts/2014-01-06-Fix-your-Hackage-documentation.html
10:02:12 <phaazon> and I figure out that Either Void could directly have somethinge like : right :: Either Void a -> a
10:02:24 <phaazon> something*
10:02:58 <vanila> right :: Either Void a -> a
10:03:02 <vanila> right (Right right) = right
10:03:19 <merijn> phaazon: How is GHC supposed to figured that "Either Void a" is not "Left undefined"?
10:03:19 <phaazon> right _ = undefined
10:03:21 <phaazon> yes
10:03:41 <phaazon> merijn: I guess no one should use undefined :D
10:03:44 <albeit> If I use Data.Array, and have bounds from say 1 to 9999, but only use indices of the form 5*i (just as example), is that okay?
10:04:09 <merijn> albeit: Would be terribly inefficient, I'm guessing
10:04:16 <phaazon> this is what edward kmett told me when presenting me bound â€“ the open/close expression stuff with Void
10:04:19 <merijn> That means 80% of your array is wasted space
10:05:03 <albeit> merijn: Okay... so if my indices were of the form i+2j, I should instead use indices of the form (i,j)?
10:05:39 <merijn> albeit: I dunno exactly what you're doing. You could consider using IntMap?
10:05:46 * hackagebot radium 0.1 - Chemistry  http://hackage.haskell.org/package/radium-0.1 (klangner)
10:06:06 <phaazon> merijn: maybe could you give me an advice about some snippet?
10:06:07 <albeit> Its for a dynamic programming thing, and I'm using the Array to memoize results because it has O(1) lookup
10:06:45 <hexagoxel> merijn: ah, nice, thanks. (and: yay, just seven steps.. :D)
10:07:00 <phaazon> http://lpaste.net/1249255967493718016 merijn < the idea is lines 59â€“61 and 69
10:07:10 <phaazon> should I just drop the Void, and use Maybe?
10:07:15 <phaazon> I like that Void thing
10:08:28 <merijn> phaazon: What is that added value of having "Dep Void a" instead of just "Maybe a"?
10:09:07 <bitemyapp> Fuuzetsu: might be worth going to "patches accepted"?
10:09:11 <phaazon> merijn: well, the Dep data is either a pending dependency or a resolved one
10:09:20 <phaazon> I thought of that too
10:09:37 <phaazon> if I use Maybe a
10:09:41 <phaazon> I donâ€™t need a Dep type
10:09:48 <merijn> phaazon: So just have "Just a" on the first line and "lk n" on the second?
10:09:50 <phaazon> and I just represent the dependency by its name
10:09:56 <merijn> phaazon: You already have a Maybe...
10:09:57 <shachaf> Dep Void is Identity, not Maybe.
10:10:14 <phaazon> shachaf: Iâ€™m not talking about that
10:10:28 <merijn> shachaf: In a theoretical sense, sure, but in a practical "people need to use this API sense", no
10:10:39 <merijn> In the practical sense this is just poor design
10:10:51 <phaazon> whatâ€™s poor design?
10:11:19 <phaazon> merijn: the main idea of my Dep type is to embed it in types that depend on others
10:11:21 <merijn> phaazon: You're making me pattern match on "Dep Void a" to figure out what the result is, after you've already made me pattern match on Just
10:11:40 <phaazon> merijn: ?
10:11:41 <phaazon> nope
10:11:46 <merijn> phaazon: Name one possible use case of your "Maybe (Dep Void a)" result on line 59
10:11:50 <phaazon> you can use the resolved function
10:11:55 <phaazon> which is Dep n a -> a
10:11:59 <phaazon> no mattern matching there
10:12:09 <merijn> phaazon: resolve only ever returns "Resolved"
10:12:19 <phaazon> damn
10:12:21 <phaazon> youâ€™re right
10:12:23 <phaazon> that sucks
10:12:45 <phaazon> the Maybe (Dep Void a) is Just (Resolved stuff) when the lookup succeeds
10:12:47 <phaazon> otherwise Nothing
10:12:51 <phaazon> that Maybe is mandatory
10:12:53 <merijn> phaazon: No, that follows directly from the type
10:13:12 <merijn> phaazon: You can never return a non-Resolved value for "Dep Void a"
10:13:16 <phaazon> yes
10:13:19 <phaazon> thatâ€™s what I want
10:13:23 <merijn> Therefore "Dep Void a" == Identity == superfluous
10:13:28 <phaazon> Dep Void a is _always_ a resolved value
10:13:32 <merijn> phaazon: Right, so it's useless
10:13:47 <phaazon> so that I can have resolved :: Dep Void a -> a, and not resolved :: Dep n a -> Maybe a
10:13:52 <merijn> "Dep Void a" == "'a', but with an annoying useless pattern match"
10:14:00 <phaazon> yeah
10:14:12 <phaazon> but if the resolve value returns a
10:14:17 <phaazon> thereâ€™s no need for Dep anymore
10:14:23 <phaazon> I can just use n, the name of the dependency
10:14:31 <merijn> Right
10:14:53 <phaazon> the single issue is that I wanted that Dep type to be embedded in values that depend on others
10:14:54 <merijn> I don't really see the point of this whole Dep type anyway
10:14:58 <dhrosa> :/ hoogle fails to build
10:15:19 <dhrosa> src/Web/Server.hs:35:18: Not in scope: 'setOnException'
10:15:21 <phaazon> so that I can â€œproxifyâ€ the value â€“ for resource loading for instance
10:15:25 <phaazon> when everything is loaded
10:15:30 <phaazon> I just resolve everything with Maps
10:15:46 <merijn> phaazon: Superficially it looks like you're reinventing the Maybe monad in an unnecessarily complex manner
10:16:01 <phaazon> Iâ€™d rather say Either
10:17:37 <phaazon> okay, use case: I have a type called Vertices. A Vertices has a value of type VertexFormat. This was quite okay till I decided to use resources loaders. Now, I can load vertex formats on a side, and vertices on other. vertices references vertex formats through names, like String
10:17:41 <phaazon> with dep
10:17:42 <phaazon> Dep*
10:17:50 <phaazon> I just altered the Vertices type to something like :
10:18:09 <phaazon> data Vertices n = Vertices { vformat :: Dep n VertexFormat, â€¦ }
10:18:23 <phaazon> how should I do that without my Dep type?
10:18:40 <Fuuzetsu> bitemyapp: I just don't understand, I'm not disagreeing with him, I just want to know what's this bug he keeps refering to is. Surely it's not the anchor thing which I already pointed out and proved fixed.
10:19:56 <vanila> bitemyapp, where does the name come from?
10:20:04 <merijn> phaazon: I ave no idea what that's supposed to do
10:20:08 <vanila> hi osa1 :)
10:20:28 <osa1> vanila: hi
10:20:37 <phaazon> merijn: well, imagine I donâ€™t do that
10:20:44 <phaazon> the initial implementation is something like
10:20:54 <phaazon> data Vertices = Vertices { vformat :: VertexFormat, â€¦ }
10:20:59 <phaazon> when I write the FromJSON instance
10:21:15 <phaazon> I have something Vertices <$> o .: "format" <*> â€¦
10:21:28 <phaazon> so it expects the VertexFormat to be in the same object
10:21:44 <phaazon> I donâ€™t want that, I want it from external resource
10:22:01 <phaazon> so that "format" is just a String Iâ€™ll be using later to get the actual VertexFormat
10:22:04 <phaazon> got it?
10:22:31 <phaazon> so when I load the Vertices
10:22:36 <phaazon> I just do something like
10:23:01 <phaazon> Vertex  <$> fmap pending (o .: "format") <*> â€¦
10:23:13 <phaazon> Vertices*
10:23:39 <phaazon> if I represent the VertexFormat through a String, first itâ€™s not really well typed to meâ€¦ and secondly I canâ€™t change the type anymore
10:24:01 <phaazon> so I guess that Dep ~ Either type is quite okay, donâ€™t you think?
10:24:42 <merijn> I don't have a sensible response as I don't understand the issue and don't have time to think about it :)
10:24:49 <joseph07> phaazon: why not replace "pending" with a (String -> Maybe VertexFormat)?
10:24:57 <bitemyapp> Fuuzetsu: I dunno. Maybe he's in a fey mood.
10:25:02 <bitemyapp> vanila: what name?
10:25:10 <vanila> youre name
10:25:16 <vanila> im just curious :)
10:25:54 <phaazon> joseph07: well
10:25:59 <phaazon> when the dependency IS resolved
10:26:10 <phaazon> I donâ€™t want to lookup the map every now and then
10:26:21 <phaazon> OR, I can use a phantom type
10:26:22 <phaazon> like
10:26:28 <mroman_> pjdelport: Delay is gone at home
10:26:29 <phaazon> data Dep n a = Dep n
10:26:41 <phaazon> and use that as a functor on Vertices
10:26:49 <joseph07> phaazon: what do you mean by "dependency"?
10:26:54 <mroman_> It's probably some deep package inspection corporate firewall stuff at my workplace
10:26:56 <wz1000> How come haskell links get a lot of upvotes on sites like reddit and hn, but barely anyone comments on them?
10:27:01 <phaazon> Vertices (Dep n a) becomes Vertices n when
10:27:04 <phaazon> yeah well, itâ€™s ugly.
10:27:10 <phaazon> joseph07: well
10:27:19 <phaazon> a value that requires a sharable other value
10:27:28 <phaazon> something that comes from â€œexternalâ€ computation
10:27:43 <phaazon> you do that with pointers / IDs / references in other common languages
10:27:50 <joseph07> phaazon: why does turning a string into a VertexFormat require an external computation?
10:28:10 <phaazon> because I donâ€™t have that VertexFormat yet when building the Vertices
10:28:25 <albeit> :t map (>>^)
10:28:26 <lambdabot> Arrow a => [a b c] -> [(c -> d) -> a b d]
10:28:27 <joseph07> phaazon: okay now I think I understand
10:29:00 <phaazon> joseph07: so I can do something like
10:29:09 <phaazon> let v = Vertices (pending "stuff")
10:29:09 <albeit> Is there a way to "map" over a pair? :: (a -> b) -> (a,a) -> (b,b)?
10:29:11 <mroman_> Can you configure hputStrLn/getLine to use \r\n?
10:29:17 <phaazon> and at some time
10:29:29 <phaazon> v & vformat %~ resolve theMap
10:30:21 <phaazon> oh shit, netsplit?
10:30:36 <joseph07> phaazon: would it perhaps be simpler to represent the "unfinished" Vertices as a function (Map -> Vertices)
10:31:03 <phaazon> nope, it sounds okay to me
10:31:08 <phaazon> I put the String in a closure
10:31:12 <augustl> is there something like clojure's hiccup for haskell? I.e. representing HTML as a data structure, no special syntax
10:31:15 <phaazon> but hm
10:31:45 <carter> kludgy2: no, float is faster because float simd is 2x as wide,
10:31:47 <phaazon> I guess I need to distinguish from â€œunresolvedâ€ and â€œresolvedâ€
10:31:50 <augustl> ugh g2g
10:32:56 <joseph07> phaazon: type UnresolvedVertices = Map -> Vertices
10:33:56 <phaazon> thatâ€™s not that simple I guess
10:34:06 <phaazon> imagine I do the same kind of stuff for a more complex and bigger types
10:34:12 <phaazon> with a lot of dependencies
10:34:19 <phaazon> with different types
10:34:59 <phaazon> furthermore
10:35:18 <phaazon> UnresolvedVertices, how should I embed that?
10:35:28 <phaazon> some kind of Either structure somewhere
10:35:37 <joseph07> phaazon: by embed do you mean persist?
10:35:43 <phaazon> no
10:35:54 <phaazon> I have a Mesh class
10:36:02 <phaazon> that contains a Vertices and other stuff
10:37:16 <joseph07> phaazon: okay, so if the situation is really more complicated, we might need a more complicated solution. But it's best to start with the simplest. If you just need a map to finish building a single type of thing, then a function is what you need, but it sounds like you're looking for a more general solution
10:37:45 <phaazon> yes, because sooner or later Iâ€™ll add materials, textures, shaders, and so on
10:37:51 <phaazon> and itâ€™s the same issue: sharing
10:38:06 <joseph07> phaazon: I think I saw a question from you on reddit
10:38:11 <phaazon> yeah
10:38:22 <phaazon> Iâ€™ve been looking for an answer for a few months now :(
10:38:37 <joseph07> phaazon: okay yes I remember
10:38:49 <phaazon> up to now
10:38:56 <phaazon> I solved the issue 50%
10:39:03 <phaazon> Iâ€™m using an AST to express relation
10:39:15 <phaazon> but for that kind of relation â€“ deferred? â€“ I have no other choice
10:39:21 <phaazon> I need something like a map
10:39:28 <phaazon> and a way to defer the substitution
10:40:00 <joseph07> phaazon: so what I was suggesting generalizes to something like continuations
10:40:22 <joseph07> phaazon: have you read http://www.haskellforall.com/2012/12/the-continuation-monad.html
10:40:53 <phaazon> nope
10:40:56 <phaazon> Iâ€™m gonna read that
10:40:57 <phaazon> thank you
10:43:07 <joseph07> phaazon: good luck! Sorry I didn't have a complete solution
10:43:17 <phaazon> no one has I guess
10:43:25 <phaazon> it might depend on dozens of things
10:43:27 <joseph07> phaazon: not till you find one
10:43:33 <phaazon> for now
10:43:41 <phaazon> I saw a few ones
10:43:46 <phaazon> in the first place
10:43:51 <phaazon> I used something like
10:44:09 <phaazon> data Vertices f = Vertices { vformat :: f VertexFormat, â€¦ }
10:44:19 <phaazon> if f = Identity, itâ€™s a fully resolved
10:44:58 <phaazon> if f = Unresolved String
10:45:03 <phaazon> itâ€™s an unresolved
10:45:18 <phaazon> the thing is, it exposes the internals in the type parameters
10:45:22 <phaazon> which sounds wrong to me
10:45:41 <alphonse23__> is there a unicode value for haskell's bind function >>=?
10:46:33 <joseph07> phaazon: one thing you could do is hide them with a type (or newtype) declaration
10:46:33 <shachaf> No.
10:46:55 <phaazon> yeah
10:46:55 <phaazon> maybe
10:46:56 <Denommus> I'm trying to follow this tutorial: http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements
10:46:59 <phaazon> Iâ€™ll see that
10:47:07 <phaazon> I like the â€œeitherâ€ idea through types
10:47:18 <phaazon> (droping my stupid Dep type, and use the typesystem)
10:47:28 <mroman_> alphonse23__: Did you mean "APL"?
10:47:32 <Denommus> but when creating the variable "def", I have an error: No instance for (Stream s0 m0 Char) arising from a use of â€˜letterâ€™
10:47:33 <Denommus> The type variables â€˜s0â€™, â€˜m0â€™ are ambiguous
10:47:41 <Denommus> sorry for the multiple lines, it was an accident
10:48:26 <alphonse23__> no I don't even know what APL is
10:49:03 <Denommus> oh, forget it. After putting the other functions it worked
10:51:40 <phaazon> oh
10:51:41 <phaazon> oh
10:51:51 <phaazon> or, I can drop the FromJSON instance of my Mesh
10:51:59 <phaazon> still use the VertexFormat directly
10:52:02 <phaazon> and build a new type
10:52:07 <mT37m> does anybody know a protoc implementation that generates haskell? hprotoc doesn't compile for me on windows and it's kinda old
10:52:11 <phaazon> like LazyMesh
10:52:20 <phaazon> that would be Map -> Mesh
10:52:27 <phaazon> and make that an instance of FromJSON
10:52:34 <phaazon> that would solve everything
10:52:36 <phaazon> Iâ€™ll try that :)
10:52:50 <phaazon> itâ€™ll enable me not to modify the existing core types
10:52:52 <phaazon> that would be neat
10:52:57 <joseph07> phaazon: cool! bubble the continuation up
10:53:48 <albeit> Using a Data.Array, it says that it is undefined / bottom when an index is out of bounds. How can I catch that? There is no "lookup" style function...
10:54:14 <c_wraith> albeit: you can always get the bounds from the array, and check to see if the index is in range
10:54:23 <mauke> :t inRange
10:54:24 <lambdabot> Ix a => (a, a) -> a -> Bool
10:54:27 <mauke> :t bounds
10:54:28 <lambdabot> Ix i => Array i e -> (i, i)
10:54:39 <mauke> :t inRange . bounds
10:54:40 <lambdabot> Ix a => Array a e -> a -> Bool
10:55:22 <albeit> Okay... so I have to check and then retrieve, no way to do it all at once and save time? Or would inRange . bounds also be O(1)?
10:55:50 * hackagebot haskell-generate 0.2.1 - haskell-generate  http://hackage.haskell.org/package/haskell-generate-0.2.1 (BennoFuenfstueck)
10:56:04 <c_wraith> albeit: it's as O(1) as ! is
10:56:27 <c_wraith> albeit: (in other words, don't make promises when type class instances are involved)
10:56:31 <phaazon> joseph07: yeah, I donâ€™t know Cont
10:56:37 <albeit> Actually just a clarification, does inRange . bounds check if the index exists in the array, or if the index is in the bounds of the array?
10:56:37 <phaazon> Iâ€™ll read that :)
10:56:42 <phaazon> thank you very much sir! :)
10:56:54 <c_wraith> albeit: if it's in the bounds, it exists
10:56:57 <tommd> We should have computational complexity reflected in the types...
10:57:24 <merijn> albeit: arrays are not supposed to have non-set indices, so you answer is non-sensical
10:57:25 <coppro> class Linear a where
10:57:35 <albeit> Okay
10:57:40 <merijn> albeit: Either the index is in bounds, or it's not.
10:57:49 <joseph07> phaazon: no problem! I'll be lurking on your progress because I'm interested in your progress
10:57:55 <merijn> albeit: If you want indices that can be uninitialised, you should probably use IntMap
10:58:09 <phaazon> joseph07: :)
10:58:22 <phaazon> joseph07: have you read my first few videos from my engine?
10:58:29 <albeit> merijn: My indices are of the form (i,j,k), it'd be nice to keep them separated
10:58:36 <phaazon> joseph07: http://phaazon.net/pub/white_red_lights_attenuations.mp4
10:58:37 <joseph07> phaazon: nope, mostly I just read the reddit thread
10:58:41 <phaazon> nothing fancy yet
10:58:42 <phaazon> but still
10:58:46 <phaazon> Iâ€™m excited :P
10:59:04 <phaazon> the interface is full pure code
10:59:08 <blogle947> I am new to haskell, are there any good resources besides lyah or real world haskell that don't focus so much on theory?
10:59:18 <joseph07> phaazon: looks cool to me!
10:59:24 <phaazon> I implement the engine with the backends idea â€“ thereâ€™s the core library, and you just install backends
10:59:27 <phaazon> :)
10:59:49 <phaazon> Iâ€™ll post more later ;)
10:59:59 <ski> blogle947 : ooi, which theory is it you have trouble with ?
11:00:51 <blogle947> I just want to replace python in my day to day work without reading so much about category theory ....
11:01:23 <ski> i didn't think LYAH or RWH talked much about category theory ?
11:01:31 <mauke> heh, what haskell tutorial talks about CT?
11:01:38 <srhb> Neither really do, no.
11:01:46 <srhb> blogle947: LYAH is about the bare minimum of theory :)
11:02:32 <blogle947> I am saying beyond those two, is there anything good... I am finishing up Lyah and looking for some more material
11:02:44 <srhb> Ah.
11:02:48 <blogle947> its the blogs that really dig into the thoery
11:03:05 <srhb> I think most of the resources that are good afterwards focus on a specific area.
11:03:22 <srhb> I'd suggest getting coding and asking about specifics when you need them. :)
11:03:31 <silver> blogle947, try this http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
11:03:46 <trap_exit> would anyone here be interested in using the following service? you paste in the type of a function + pay $0.99 ... and someone on the internet implements it for you
11:03:57 <trap_exit> so it's like hoogle, but for functions that do not yet exist
11:04:07 <silver> no
11:04:11 <mauke> @djinn a -> (a -> b) -> b
11:04:11 <lambdabot> f a b = b a
11:04:23 <blogle947> @silver, thats exactly what I am interested in
11:04:23 <lambdabot> Unknown command, try @list
11:04:28 <ski> blogle947 : don't read the blogs that dig into theory, for now, if you don't want to ?
11:05:00 <BeardedCoder> nice, only $1. I'd do it. my function would be f :: Application where Application .....
11:05:16 <ski> blogle947 : some of the theory (and often also related practicals) can be interesting, but you don't probably have to read all of it
11:06:42 <blogle947> I don't a little mind the theory so much.. Its when I am trying to figure out whats going on in some code block, and all the resources are way above my head
11:06:56 <blogle947> or assume prior knowledge
11:07:01 <cschneid> I can't get haskell-src-exts to install - are they (and ghc-mod) compatible w/ new ghc?
11:08:38 <tekul> cschsneid: I just had trouble installing ghc-mod with haskell-src-exts 1.16.
11:08:47 <cschneid> yep, that version 1.16
11:08:54 <cschneid> is failing to compile for all sorts of reasons
11:08:54 <tekul> There's a fix in gihub, and it built OK from there. Not sure if that's related
11:09:13 <tekul> I had
11:09:13 <tekul> Language/Haskell/GhcMod/FillSig.hs:147:55:
11:09:14 <tekul>     Constructor â€˜HE.DHeadâ€™ should have 2 arguments, but has been given 3
11:09:41 <mauke> he ded
11:09:45 <tekul> 5.1 doesn't build with src-exts 1.16
11:10:20 <cschneid> I have a bunch of Bool vs. Happy_GHC_Exts.Int# type errors.
11:10:36 <tekul> Sounds different...
11:10:44 <cschneid> ya, I'll check out the github version
11:10:51 <tekul> I used a clean sandbox, so there may be other issues
11:10:53 <cschneid> no biggie, just confirming I'm not doing something overly stupid :)
11:15:38 <bergmark> cschneid: you may have a too old happy binary
11:17:58 <cschneid> bergmark: thanks, looking
11:23:30 <cschneid> bergmark: that did indeed seem to get me past the issue, thanks!
11:25:39 <ski> blogle947 : well, some stuff is simpler, and some is harder
11:26:28 <ski> blogle947 : if you have any particular code in question you're having trouble understanding, then perhaps we could attempt to give pointers to useful information to read to understand it better, or try to explain some of it
11:27:10 <cschneid> tekul: oh, now I hit your error :)
11:27:26 <tekul> Well, that's progress :)
11:28:54 <cschneid> tekul: you said the github version fixed it, how do I point cabal at a live github repo?
11:29:00 <cschneid> or just clone & use the local reference thing
11:29:15 <tekul> Just clone and build from github...
11:29:41 <tekul> That's what I did. 'cabal build' from the ghc-mod checkout
11:32:06 <mightybyte> I'm getting a strange error when I run hasktags.  "hasktags: tags: openFile: resource busy (file is locked)"
11:32:14 <mightybyte> But the tags file does not exist.
11:32:34 <mauke> strace is your friend
11:33:32 <mightybyte> I'm on Mac
11:33:57 <mauke> oh, then probably not
11:34:02 <mauke> dtrace?
11:35:52 * hackagebot boomerang 1.4.4 - Library for invertible parsing and printing  http://hackage.haskell.org/package/boomerang-1.4.4 (JeremyShaw)
11:36:01 <shachaf> I think the similar command was "dtruss".
11:36:41 * ski . o O ( "dtruce" )
11:37:29 <daniell> hey there, I'm using expressions like "let a = [1..10]" a lot in ghci to test my functions. I have to retype those every time I reload my source file. How do I define them in my source file? I get parse errors when I put the "let a = something" expressions in my source file
11:37:50 <silver> "a = [1..10]"
11:38:09 <dhrosa> daniell: without the let, in a source file
11:38:14 <daniell> silver: wow now I feel stupid. Thanks
11:38:27 <dhrosa> no, I think it's just unintuitive  that ghci requires let
11:39:09 <jle`> dhrosa: not stupid :D
11:39:24 <vanila> ghci is like a do
11:39:29 <vanila> do let a = [1..10]
11:39:33 <jle`> also, when i am lazy, i like to just Ctrl+R until i find what i want
11:39:34 <vanila>    print a
11:39:35 <vanila> etc.
11:40:19 <jle`> * daniell: not stupid :D
11:40:24 <daniell> jle`: ah nice, ghci works like bash
11:40:31 <jle`> yeah, it uses readline
11:40:46 <jle`> well, if you have it installed
11:40:48 <ski> expressions is not the same as declarations is not the same as commands. it's not obvious that if one of these are allowed, another would also be allowed
11:41:05 <daniell> it looks so much like the windows command prompt that I didn't realise it has all the handy bash shortcuts
11:41:15 <dhrosa> how can I make ghci stop complaining about macros already being defined?
11:41:23 <dhrosa> I want to override ghci's default search
11:41:28 <dhrosa> nv,
11:41:29 <dhrosa> nvm
11:41:30 <dhrosa> I derped
11:41:37 <dhrosa> my ~/.ghci had TWO searches defined
11:42:03 <jle`> daniell: it's actually more like ghci and bash mutually use readline :)
11:42:34 <jle`> so maybe bash copied from ghci
11:42:37 <jle`> dun dun dun
11:43:01 <ski> daniell : are you running windows ?
11:43:32 <ski> daniell : possibly it is just reusing the cmd window, then
11:43:37 <blogle947> I get most of the base library stuff up to Monads, which I get are like "actions"... I can follow along with some of the parsec stuff, but I don't get whats really going on
11:43:39 <stolaruk> Looks like my sandbox slipped into cabal hell. I am recreating it. What would be my best strategy to avoid the situation I was in? Should I first and foremost "cabal install" the package I was trying to get in the first place?
11:43:50 <blogle947> for instance parse
11:43:50 <blogle947>   :: Text.Parsec.Prim.Stream s Data.Functor.Identity.Identity t =>
11:43:50 <blogle947>      Text.Parsec.Prim.Parsec s () a
11:43:50 <blogle947>      -> SourceName -> s -> Either ParseError a
11:44:22 <ski> blogle947 : yeah, a bit of a mouthful, perhaps
11:44:25 <jle`> blogle947: first of all, because there is no (Monad m) =>..., nothing here has anything to do with Monads :)
11:44:26 <dhrosa> blogle947: the typesignature is slightly nasty, there's a nice type synonym
11:44:41 <jle`> it's actually more a question about the types in Parsec
11:44:43 <jle`> and Identity
11:44:58 <dhrosa> blogle947: Parser a = Text.Parsec.Prim.Parsec s () Identity a iirc
11:45:14 <jle`> hopefully this fact makes the scope of your problem a little more manageable
11:45:20 <blogle947> I thought the () signified a null action and thus monad
11:45:21 <dhrosa> err, where s = String, ByteString, etc
11:45:24 <dhrosa> blogle947: no
11:45:31 <jle`> () is just a normal data type
11:45:32 <dhrosa> blogle947: () is a user state parameter for parsec
11:45:35 <jle`> data () = ()
11:45:37 <dhrosa> blogle947: which for most applications is nothing
11:45:42 <jle`> it's probably the most boring data type
11:45:48 <dhrosa> blogle947: the actual monad here is the Identity monad
11:46:07 <jle`> are you familiar with ADT's?  things you can declare using data Foo a = Bar a | Baz ...?
11:46:17 <ski> blogle947 : `()' is the empty tuple type
11:46:43 <stolaruk> I wouldn't think of it as a tuple per se
11:46:45 <ski> blogle947 : it has just a single (nullary tuple) value, also written `()'
11:46:45 <blogle947> yes stuff like data List a = empty | a : [List a]
11:46:58 <xplat> i sometimes still get annoyed there isn't a unary tuple type :-7
11:47:01 <jle`> yeah, () is just data () = ()
11:47:07 <jle`> the most boring possible data type :)
11:47:23 <ski> blogle947 : while this can be used in place of "no (interesting) result", for monadic actions, it can also be useful in some other places, where you may or may not want to attach some extra additional information to something
11:48:17 <ski> blogle947 : in this case it's saying that some or other "slot" of information as regarding to parsers is chosen to have type `()', and so is effectively chosen to be usused in this case
11:48:34 <jle`> for exampe, some people use Maybe a to represent success (with an a in a Just) or failure (with Nothing).  Maybe Int is a success with an int or a failure.
11:48:44 <jle`> sometimes you just want to say "i succeeded" or "i failed", and not care about what you suceeded with
11:48:49 <jle`> then you'd use Maybe ()
11:48:57 <jle`> (which is equivalent to Bool, but)
11:48:59 <ski> ("unused" because that type only has one value, so you can't really communicate any useful information with it)
11:49:11 <jle`> Maybe () is either Just () (i succeeded, and i don't care what i succeeded with) or Nothing
11:50:05 <blogle947> Ah.... so instead of using Maybe int, and having Just 1 be  success and Nothing as fail you could use Maybe ()?
11:50:25 <xplat> ski: well, i dunno.  you could put a thunk in it that communicates something through a side timing or power draw channel when forced :)  but in theory we ignore that
11:50:28 <albeit> In a type signature, can I use the same character to represent the same type for two different parameterized datatypes? Like :: (Num a) => Foo a -> Bar a -> Baz a?
11:50:39 <xplat> blogle947: yeah, although there you could just use Bool
11:50:42 <dhrosa> albeit: yes
11:50:44 <pantsman-> Maybe () = Bool
11:50:46 <jle`> yeah, Maybe Int means "i succeed with an Int (so i get an Int when i succeed) or i failed".  Maybe () means "i succeeded (but i don't care what i succeeded with) or i failed"
11:50:53 * hackagebot drawille 0.1.0.0 - A port of asciimoo's drawille to haskell  http://hackage.haskell.org/package/drawille-0.1.0.0 (yamadapc)
11:51:03 <jle`> and yeah, Maybe () contains the exact same information as a Bool :P
11:51:15 <jle`> if you didn't have Bool, you could simulate it with a Maybe ()
11:51:22 <dhrosa> except Maybe's a monad, so you can use nice monad tools with it
11:51:34 <jle`> well, Maybe () is not a Monad
11:51:41 <dhrosa> well yes
11:51:42 <xplat> it's a Monoid
11:51:43 <dhrosa> err
11:51:50 <dhrosa> Maybe () is not a monad, but Maybe is
11:51:57 <jle`> yeah :)
11:52:32 <ski> xplat : yah
11:52:59 <jle`> well.  in any case, the point was to show that whenever your data type expects a "type" containing some information (like Maybe and Maybe a), if you want to have it hold no information at all, you can just pass in ()
11:53:32 <jle`> "you expect something with some information here, but i don't need this slot, so i'll just give it ()"
11:54:25 <pantsman-> MVar () is useful as a semaphore
11:54:32 <blogle947> Ok cool, that makes sense... When I see some type declaration that doesn't take an input, for instance symbol :: Parser Char
11:54:40 <blogle947> Does that imply monad?
11:54:57 <c_wraith> blogle947: no.  Monad is a property of types, not values
11:54:58 <jle`> like putStrLn "hello" :: IO ().  IO a expects something for a...you can "contain information" in that a.  but because that aaction doesn't really return any information at all,they put in the information-less type, ()
11:55:23 <c_wraith> blogle947: it happens that Parser is an instance of Monad, but that's irrelevant to this
11:55:36 <ski> blogle947 : `Parser' is a monad. `symbol' there is a monadic *action* (a `Parser'-action, to be more specific)
11:55:41 <jle`> blogle947: i think you might be thinking "Monad" is a bigger thing than it actually is ;)  it acutally doesn't come up all that often, and isn't relevant that often
11:55:54 * hackagebot drawille 0.1.0.1 - A port of asciimoo's drawille to haskell  http://hackage.haskell.org/package/drawille-0.1.0.1 (yamadapc)
11:56:17 <jle`> it's really only rarely relevant
11:56:38 <ski> blogle947 : but as c_wraith said. it wouldn't be necessary for `Parser' to be a monad (and some parsing combinators don't give a monad). but for Parsec, it so happens that it's a monad
11:57:42 <jle`> it's just a normal ol typeclass, like Eq or Ord.  Parser is incidentally an instance of a bunch of things, and not an instance of others.  incidentally, it's an instance of Monad.  Parser a isn't an instance of Eq, for example.
11:57:43 <ski> well, i'd say that `Monad' is a small part of all that `Parser' is
11:59:01 <blogle947> Ok that makes a bit of sense, I am still a bit confused by the type signature though.
11:59:34 <jle`> yeah.  well, in that case, you're going to have to consult what the Parser/Parsec type *is* and what they represent
11:59:35 <blogle947> oneOf "!#$%&|*+-/:<=>?@^_~" obviously checks if a value is in that [char]
12:00:00 <dhrosa> blogle947: your code is winking at me
12:00:01 <jle`> you're not going to get any help from knowing whether or not it is a Monad :)  that part is beside the point
12:00:01 <blogle947> I am referring to the symbol :: Parser Char
12:00:27 <amf> in migrating from String to Data.Text, is there a way to tell parsec / other modules to do T.pack for all the places with String in their return type? i have way too many places that need change
12:00:28 <dhrosa> blogle947: the type signature is irrelevant to the fact that Parser happens to be a monad, it could very well not be a monad and you'd have the same question
12:00:44 <jle`> so Parser Char, the type, represents a parser that parses a Char from an input string
12:01:20 <jle`> `Parser a` in general represents something that consumes an input string and (potentially) parses an `a` from it
12:01:23 <mauke> "parses a Char" is misleading
12:01:33 <jle`> :'(
12:01:33 <mauke> it parses whatever it wants, but it returns a Char
12:01:39 <jle`> ah, yeah.
12:01:40 <jle`> thanks
12:01:56 <jle`> ^^
12:03:06 <LordBimbam> hey guys. i'm trying to run `cabal haddock` with the --html-location option, but it simply ignores it, whatever I use as the value (local and remote paths :/). does someone have an idea what i could be doing wrong?
12:03:33 <blogle947> so wouldn't that be something like Parser a -> string -> char ?
12:04:57 <LordBimbam> i tried for instance, --html-location='http://hackage.haskell.org/package/$pkgid/docs/' and --html-location=/srv/gopher/pub/chatty/'$pkgid'/dist/doc/html/'$pkg', but none of it works
12:05:45 <jle`> blogle947: the parser itself is an object that represents the information necessary to do the parsing
12:05:48 <jle`> it encapsulates it
12:05:54 <assia_t> Anyone knows what the "z" like thing means? https://github.com/roelvandijk/terminal-progress-bar/blob/master/src/System/ProgressBar.hs#L117
12:06:21 <jle`> i think there's a parse function or something that takes a Parser a and a String and returns you a `a` (or an Either Error String).
12:06:54 <jle`> it takes a Parser a object with the "parsing instructions", and a string to parse, "runs" the parser on that string, and outputs the result
12:07:45 <supki> assia_t: it's an alias for Integer
12:07:54 <jle`> so oneOf "!@#$" returns an object/data type that contains instructions on how to parse a String (in the future, when you eventually run it) and return a Char
12:08:18 <assia_t> supki: Thanks... Is that good practice?
12:08:59 <jle`> The reason why we work with objects containing parsing instructions to be run in the future instead of directly parsing everything ourselves is that the Parser library has some pretty neat combinators for combining, manipulating, and trasnforming such objects :)
12:10:40 <jle`> and also the fact that you can pass the objects as normal values is neat too
12:14:28 <blogle947> so Parser is some data type that encapsulates the full type signature, thus the symbol :: Parser Char instead of something like symbol :: string -> char... furthermore you don't immediately parse, because you can join these parsers like symbol >> digit >> letter
12:14:57 <blogle947> roughly?
12:15:15 <c_wraith> blogle947: That's true, though you rarely need to think about the low-level details in practice
12:15:56 * hackagebot drawille 0.1.0.2 - A port of asciimoo's drawille to haskell  http://hackage.haskell.org/package/drawille-0.1.0.2 (yamadapc)
12:16:16 <blogle947> I didn't realize you could encapsulate the type signature so I was just baffled as to what these functions were actually doing. I really appreciate the help!
12:16:28 <jle`> blogle947: actually, the data types don't actually usually contain a String -> Char.  that's not important, though...what's important is the semantics of the parser :)
12:16:43 <jle`> you can just imagine that it encapsulates some instructions for parsing, in however way the library decides
12:16:51 <jle`> that's the magic of abstraction
12:17:06 <dhrosa> blogle947: a function with a type signature Parser Char doesn;t actually parse
12:17:16 <dhrosa> Parser is actually a data structure
12:17:24 <dhrosa> that gets used to actually parse later on in your code
12:17:29 <dhrosa> when you call parse or another function
12:17:51 <dhrosa> Parser Char is a datastructure that represents a parser that will return a Char (if it succeeds)
12:18:38 <dhrosa> you build up a Parser x data structure using the different cominbator functions Parsec provides you, and then that data structure is used to actually parse the input later on
12:19:06 <sinelaw> hi, looking at monad transformers, trying to simplify the following contrived example: https://gist.github.com/sinelaw/812a82efeed97352d557
12:19:08 <pantsman-> in OO design you'd call this function a parser factory :3
12:19:20 <sinelaw> how do I utilize MaybeT to get rid of the 'case ... '?
12:19:25 <sinelaw> and shortcut when the result is Nothing
12:19:26 <sinelaw> ?
12:19:32 <jle`> i likeo to imagine it as containing a sentient little gnome that was created with the knowledge to fulfil its purpose in life of consuming any strings and returning a Char from them if possible.  and you unleash it with the `parse` function.  yes this is how ia ctually think about it.
12:19:54 <blogle947> bahahaha
12:20:07 <jle`> functions like (>>) take two gnomes and they do the fusion dance and they become a new gnome whose new purpose in life is to do the work of both one after the other
12:20:29 <jle`> and who is born with the knowledge needed to do exactly that
12:21:07 <pantsman-> gnomads
12:21:15 <sinelaw> any suggestions on how to simplify this? https://gist.github.com/sinelaw/812a82efeed97352d557
12:21:21 <jle`> sinelaw: how about `guard` ?
12:21:34 <jle`> :t guard
12:21:35 <lambdabot> MonadPlus m => Bool -> m ()
12:21:36 <sinelaw> jle`, what I really want is to shortcut out of the do block
12:21:43 <sinelaw> if the result is Nothing
12:21:44 <jle`> guard would do that for you
12:22:00 <sinelaw> without checking for it explicitly
12:22:02 <jle`> guard False >> f = mzero
12:22:10 <dhrosa> jle`: that was an excellent explanation
12:22:34 <sinelaw> jle`, that's not a shortcut - you still explicitly handle failure
12:22:42 <yesthisisuser> I am trying to stream data from a database using persistent-postgresql and conduit.. This is what I have so far: http://lpaste.net/111128
12:22:50 <yesthisisuser> Am I doing it right?
12:22:53 <blogle947> Ok this is making a lot more sense
12:23:00 <sinelaw> I would wnat it to be something like: x <- makesAMaybe something
12:23:19 <yesthisisuser> persist-postgresql, I should say
12:23:26 <sinelaw> this should unpack Just x, or fail (shortcut) the do block if makesAMaybe returns Nothing
12:23:32 <jle`> oh, you check on a Just, not a Bool
12:23:35 <jle`> try MaybeT
12:23:40 <jle`> :t MaybeT
12:23:41 <lambdabot> Not in scope: data constructor â€˜MaybeTâ€™
12:23:44 <sinelaw> jle`, that code already has MaybeT
12:23:50 <sinelaw> I'm just not sure how to use it
12:23:50 <jle`> no, the constructor
12:23:59 <jle`> MaybeT :: Maybe a -> MaybeT m a
12:24:22 <jle`> er
12:24:29 <jle`> MaybeT :: m (Maybe a) -> MaybeT m a
12:24:34 <jle`> x <- MaybeT makesAMaybe
12:25:12 <jle`> <insert complaint about how constructors with the same name as their types are confusing etc.>
12:25:25 <sinelaw> makesAMaybe :: b -> Maybe a
12:25:43 <sinelaw> no m
12:25:56 * hackagebot HTF 0.12.1.0 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.12.1.0 (StefanWehr)
12:26:26 <jle`> hm. well you could do MaybeT . return $ makesAMaybe something
12:26:32 <jle`> i wonder if there is a simpler way though
12:26:43 <jle`> oh, isn't that hoist
12:27:22 <jle`> hm.
12:28:58 <sinelaw> MaybeT . return :: Maybe a -> MaybeT m a
12:29:05 <sinelaw> right?
12:29:16 <sinelaw> @type lift
12:29:17 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
12:34:16 <jle`> yes
12:34:27 <jle`> lift would be StateT s a -> MaybeT (StateT s) a, in this case
12:34:36 <jle`> which isn't what you want :)
12:35:07 <jle`> i think (MaybeT . return) is what you need...i think there's a general name for it somewhere, but i can't remember it
12:35:57 * hackagebot buildwrapper 0.8.8 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.8.8 (JeanPhilippeMoresmau)
12:37:37 <augustl> why doesn't "data TagAttr = (String, String)" work? Isn't a plain tuple a valid type? Getting "parse error in constructor in data/newtype declaration:"
12:38:12 <mauke> type, yes. data, no
12:38:16 <augustl> hmm, just saw "type". I'll read up on the difference between "data" and "type" :)
12:38:23 <augustl> mauke: tnx :)
12:38:24 <jle`> augustl: data declares an ADT.  type declares a type synonym
12:38:28 <mauke> type makes a new name for an existing type
12:38:28 <jle`> it's a bit confusing
12:38:38 <mauke> data creates a new type
12:38:45 <mauke> newtype ... well
12:38:50 <ski> `type' names an existing type
12:39:04 <mauke> @quote mauke newtype
12:39:04 <lambdabot> mauke says: <mauke> a newtype is like an existing type but wearing glasses and a fake mustache  <mauke> and a sign saying "you've never seen me before"
12:39:35 <jle`> i think everyone has their own ideas on how they would change the names of data/type/newtype if we got a chance to go back in time
12:39:42 <augustl> ah, I see. Thanks, folks :)
12:40:36 <dhrosa> (+ 1 2)
12:41:00 <c_wraith> I don't think I'd change the name of data/type/newtype, but I think I'd change all data declarations to use GADT syntax.
12:41:22 <c_wraith> It's more verbose, but it's also more clear.
12:43:34 <ski> c_wraith : i'd distinguish between field names and field accessor functions
12:44:04 <c_wraith> ski: well, GADT syntax isn't compatible with records, so clearly more work than my idea is necessary.
12:45:03 <ski> there is record syntax for GADTs, see <https://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt>
12:45:07 <sinelaw> @hoogle (MonadTrans t, Monad m) => b a -> t m a
12:45:09 <lambdabot> Control.Monad.Trans.Class lift :: (MonadTrans t, Monad m) => m a -> t m a
12:45:09 <lambdabot> Control.Applicative.Backwards Backwards :: f a -> Backwards f a
12:45:09 <lambdabot> Control.Applicative.Lift Other :: (f a) -> Lift f a
12:45:24 <ski> sinelaw : `b' ?
12:45:42 <sinelaw> ski, in this case t = MaybeT, b = Maybe
12:45:49 <sinelaw> not sure what the relation is  between them...
12:45:52 <c_wraith> ski: huh.  I never have seen that.  Good to know it exists, I suppose.
12:48:06 <ski> sinelaw : and `m' ?
12:48:30 <sinelaw> State
12:48:49 <sinelaw> ski, looking for a generalization of MaybeT . return
12:48:54 <c_wraith> State has the wrong kind to be m
12:49:08 <sinelaw> State something
12:56:10 <jle`> sinelaw: it shows up as `hoist generalize` in mmorph, but only if you imagine Maybe a as a type synonym for MaybeT Identity a
12:56:24 <sinelaw> heh
12:56:28 <jle`> sinelaw: it does State s a -> StateT s m a, Reader r a -> ReaderT r m a
12:56:29 <jle`> etc.
12:56:37 <sinelaw> jle`, but that WILL work for EitherT, eg.?
12:56:37 <jle`> which is analogous to what you want
12:57:00 <jle`> yeah, if you imagine Either e as a type alias as EitherT e Identity
12:57:06 <sinelaw> ok
12:57:08 <sinelaw> thank you
12:57:23 <jle`> it's meant for State s a -> StateT s m a, for example
12:57:29 <jle`> analogoous to Either e a -> EitherT e m a
12:57:42 <jle`> but it only works because State s is a type alias for StateT s Identity
12:57:50 <jle`> so...time to submit a patch to `base`
12:58:44 <jle`> (also analogous to Maybe a -> MaybeT m a)
13:00:06 <ski> wasn't there some package associative monads with monad transformers ?
13:00:16 <ski> s/associative/associating/
13:01:21 <sinelaw> "Monad morphisms solve the common problem of fixing monadic code after the fact..."
13:01:25 <sinelaw> heh, exactly my use case
13:02:55 <Peaker> sinelaw: another simple solution to the same problem is a newtype for your monad stack
13:03:23 <sinelaw> hey Peaker  ;)
13:03:50 <sinelaw> I think I'll just do: x <- MaybeT $ fmap makesAMaybe action
13:05:25 <prophile> if it's just Maybe I think there's functions somewhere for (MonadPlus m) => Maybe a -> m a
13:05:29 <Peaker> sinelaw: hey :)
13:05:36 <prophile> or possibly (Alternative f) => Maybe a -> f a
13:05:51 <Peaker> sinelaw: write a function to go from: Maybe a -> MaybeT m a    outside, it's nicer
13:06:06 <Peaker> sinelaw: prophile knows what he's talking about :)  that's even nicer
13:06:10 <sinelaw> Peaker, it is called "MaybeT . return"
13:06:41 <Peaker> @type maybe empty pure
13:06:42 <lambdabot> Alternative f => Maybe a -> f a
13:06:49 <prophile> ^ nice
13:07:11 <jle`> that's nice
13:07:23 <sinelaw> :)
13:08:14 <prophile> could go for foldMap pure if you use a monoid instance rather than Alternative
13:08:16 <sinelaw> now why didn't I think of that ;)
13:08:23 <prophile> which also generalises nicely to any Foldable rather than just Maybe
13:08:29 <prophile> but that may be going a bit far
13:08:58 * prophile vapourises
13:10:24 <jle`> the thing is that i'm sure that MaybeT m a is already an Alternative or MonadPlus
13:10:53 <jle`> so you can just use maybe empty pure as-is
13:11:48 <jle`> or maybe mzero return etc.
13:12:31 <jle`> but i've historically used MaybeT . return :|
13:13:15 <sinelaw> MaybeT . return is good enough
13:13:35 <sinelaw> it also generalizes to EitherT . return :)
13:26:00 * hackagebot hayland 0.1.0.1 - Haskell bindings for the C Wayland library.  http://hackage.haskell.org/package/hayland-0.1.0.1 (AukeBooij)
13:26:25 <benzrf> is a prophile somebody who really loves pros
13:26:53 <xeno_> crap... how do I get to import Control.Error.Util? I've added the "errors" package, but to no avail... ghc/eclipseFP also doesn't propose anything...
13:26:58 <burp> hayland + xmonad
13:27:17 <codehero> hayland?
13:27:34 <burp> see few lines above
13:28:05 <codehero> oh cool
13:28:14 <codehero> is there already wayland support for xmonad?
13:28:26 <burp> don't think so
13:28:46 <tulcod> codehero: no, that would require... well, basically rewriting xmonad
13:29:02 <codehero> ah, okay
13:33:22 <levi> xmonad is based heavily on the X display model, and wayland uses an entirely different one. But an xmonad-style WM for Wayland would be cool.
13:33:56 <tulcod> levi: admittedly, the "big" window managers basically abstracted away X and now have two "drivers": one for X and one for wayland
13:34:07 <tulcod> so it's not impossible
13:35:13 <tulcod> now, i'm not an xmonad developer, but i'd guess that abstracting it away would be more effort than just rewriting the entire thing
13:36:38 <joseph07> tulcod: XMonad is split into a pure chunk of code for dealing with StackSets, and a chunk of code that realizes a StackSet in X
13:37:13 <eriksensei> Question: when reading ((return .) . (return .)), do you use any sort of cognitive shortcuts in your head to parse what it says? Maybe something along the lines of 'take a function and transform it such that its result is wrapped in two layers of monad'?
13:37:50 <glguy> eriksensei: Code like that is only meant for writing, you wouldn't write code like that if you wanted to read it
13:37:56 <c_wraith> eriksensei: When I see something like that, I rewrite it.
13:38:04 <geekosaur> @unpl ((return .) . (return .))
13:38:04 <lambdabot> (\ e h -> return (return (e h)))
13:38:09 <mroman_> eriksensei: I punch people in the face who write code like that
13:38:11 <geekosaur> is how I read it :p
13:38:12 <eriksensei> i'm trying to understand jaspervdj's digestive-functors library
13:38:35 <mroman_> only in my imagination of course
13:39:02 <tulcod> joseph07: that sounds like a sane design. might be more realistic then.
13:39:06 <eriksensei> that's where i came across it, but now that i'v spent some time staring at it, i'm thinking 'hey, that's not too bad'. so i risk getting punched in the face? :P
13:39:08 <mroman_> but overusing pointfree like that isn't a good thing in my opinion.
13:39:24 <glguy> eriksensei: it's just sloppy
13:39:50 <tulcod> joseph07: do you wore on xmonad?
13:40:05 <eriksensei> glguy, c_wraith, geekosaur: thanks for your comments! :)
13:40:31 <eriksensei> and let's not forget mroman_
13:41:05 <joseph07> tulcod: nope. I just use it a lot, enough that eventually I wanted to look under the covers to make it do more stuff. You can manipulate the stackset directly in pure code and make it do whatever you want in the whole world, which turns out to be cool
13:41:30 <mroman_> eriksensei: At some point you'll recognize certain (.) patterns like that and *can* understand them
13:41:45 <mroman_> but I'll always recommend against using pointfree-style like that ;)
13:41:59 <geekosaur> most of us will, I think.
13:42:02 <eriksensei> mroman_: right, i have the feeling i'm getting to that stage, but it's obviously a bit of a double-edged sword
13:42:35 <geekosaur> there are some who use them heavily, but many of us feel that there's a line somewhere between concision and unreadability and it's a good idea to avoid crossing it
13:43:01 <tulcod> joseph07: hm, that sounds nice. i have this idea that presentation software should really be a window manager with some helper tools, so i've had intentions to look into xmonad for that purpose. never got around to doing it, but what you're saying makes that sound viable
13:44:28 <eriksensei> geekosaur: it did take me a while to see what was going on, but i have to say i'm not sure the alternatives are all much that clearer
13:44:41 <eriksensei> * that much
13:44:51 <dfeuer> HMMM. Fusion is breaking Call Arity for me in dropWhileEnd  :-(
13:46:07 <mroman_> Do the ghc plan to auto-derive applicative instances for Monads?
13:46:45 <joseph07> tulcod: data W.StackSet i l a sid sd = W.StackSet... http://bit.ly/1u3GXSG
13:46:53 <mroman_> because making that an error will break code
13:47:01 <levi> So, it looks like xmonad is written on top of bindings to Xlib; meanwhile, just about everyone else has migrated to XCB, which is an alternate C library that implements the X Protocol. There are Haskell bindings for XCB in the xhb package, though.
13:48:22 <glguy> mroman_: Old code will have to be updated
13:50:59 <tulcod> levi: it's kinda unclear what the state of all these bindings is IMO
14:02:38 <eitan_chatav> what's the name of the function which alternatingly concatenates lists, e.g. \[1,2,3] [4,5,6] -> [1,4,2,5,3,6]?
14:03:10 <doismellburning> @hoogle [a] -> [a] -> [a]
14:03:10 <glguy> You can call it whatever you want, maybe "interleave"?
14:03:12 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
14:03:12 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
14:03:12 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
14:03:24 <eitan_chatav> was hoping it's already in prelude
14:03:38 <doismellburning> :t zip
14:03:39 <lambdabot> [a] -> [b] -> [(a, b)]
14:03:54 <doismellburning> @hoogle [(a,a)] -> [a]
14:03:57 <lambdabot> Data.Ix range :: Ix a => (a, a) -> [a]
14:03:57 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
14:03:57 <lambdabot> Prelude snd :: (a, b) -> b
14:04:17 <glguy> > concat (zipWith (\x y -> [x,y]) [1,2,3] [4,5,6])
14:04:19 <lambdabot>  [1,4,2,5,3,6]
14:04:36 <eitan_chatav> nice
14:04:57 <latk> trying to compile something that requires slightly more ram than that computer has (2097152 reuqested, I have 2049988). Is there something I can do to cause ghc to use slightly less ?
14:05:12 <benzrf> latk: turn off some optimiz8ions
14:05:28 <latk> Ah, good iea
14:05:29 <latk> er ide
14:05:29 <latk> a
14:05:57 <latk> I guess I could always compile on a VM in future - is there some guide anyone can point me at for how to do this ?
14:06:02 * hackagebot multistate 0.1.2 - like mtl's ReaderT/StateT, but more than one contained value/type.  http://hackage.haskell.org/package/multistate-0.1.2 (lspitzner)
14:06:10 <jle`> if only we had list sections
14:06:13 <latk> Not realy sure what sort of stuff I need to do to make it work..
14:06:16 <jle`> [,] = \x y -> [x,y]
14:08:36 <stolaruk> make list from tuple.
14:08:46 <glguy> > zip [1,2,3] [4,5,6] ^..each.each
14:08:48 <lambdabot>  [1,4,2,5,3,6]
14:09:03 <linman32> hi, is there a haskell equivilent to 4clojure.com? 4clojure has practice problems for clojure
14:09:08 <stolaruk> btw anyone prefer to use _1 or _2 over fst and snd
14:09:37 <latk> stolaruk: Is there much speed difference between the two ?
14:09:43 <latk> I would guess lens has a lot of overhead..
14:09:46 <stolaruk> latk: not really
14:09:49 <glguy> Not unless I'm doing something like:    (this . _1 . that) and fst/snd wouldn't fit
14:09:57 <stolaruk> linman32: not sure what 4clojure is, but you might try http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
14:09:59 <jle`> i can't imagine here being much overhead
14:10:05 <glguy> latk: for a lot of stuff lens inlines down to the same code you would have written anyway
14:10:11 <Peaker> glguy: elegant lens use there :)
14:10:13 <latk> Huh, fair enough
14:10:22 <jle`> how about this . view _1 . that
14:10:32 <glguy> only for tuples > 2
14:10:33 <jle`> oh, i misunderstood
14:10:50 <stolaruk> So I had a personal policy to always use _1 and _2 over fst and snd, but recently I decided to not do that anymore
14:11:02 * hackagebot cabal-cargs 0.7.3 - A command line program for extracting compiler arguments from a cabal file.  http://hackage.haskell.org/package/cabal-cargs-0.7.3 (DanielTrstenjak)
14:11:03 <glguy> or if I'm trying to make the code look as close as possible to some other code that needed _1
14:11:04 * hackagebot hsimport 0.6.2 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.6.2 (DanielTrstenjak)
14:11:15 <linman32> stolaruk: looks good thanks
14:11:16 <glguy> so that you could focus on where it was different
14:12:19 <edwardk> latk: lens is designed to inline down to pretty much the same code you'd write directly, and succeeds at doing that for almost everything except some of the crazier folds/traversals.
14:12:36 <edwardk> latk: it can sometimes even be more efficient than the code you'd write directly, because its often better at fusing things into one pass
14:13:03 <latk> edwardk: Hm, perhaps I should look into lens in a bit more detail then !
14:13:07 <eitan_chatav> :t ((.).(.)) concat (zipWith (flip (.) return . (:)))
14:13:08 <lambdabot> [a] -> [a] -> [a]
14:14:01 <glguy> eitan_chatav: If you're paying by the byte you should be able to replace   flip (.) return with (.return)
14:14:13 <eitan_chatav> :-)
14:14:37 <eitan_chatav> is :-) an operator?
14:14:47 <stolaruk> eitan_chatav: You could make it one
14:14:48 <glguy> :- is a constructor
14:14:53 <stolaruk> I think...
14:15:00 <tulcod> stolaruk: hmm, could you?
14:15:04 <stolaruk> the right parents might be an issue
14:15:06 <glguy> ) is a parenthesis and not part of an operator
14:15:10 <stolaruk> ^^ that
14:15:28 <eitan_chatav> :->
14:15:35 <eitan_chatav> i think it's a type operator
14:15:43 <Fuuzetsu> why is GHC so good
14:15:51 <eitan_chatav> natural transformations or something
14:15:57 <stolaruk> I actually rolled my own (<>) as a synonym for mappend long before I realized that this already existed.
14:16:23 <sinelaw> jle`, btw either has hoistEither :: Monad m => Either e a -> EitherT e m a
14:16:42 <Fuuzetsu> what package should I use for fast list append?
14:16:44 <kau> Hi guys! is there a neat way to access the environment variable GHC_PACKAGE_PATH?
14:18:41 <merijn> eitan_chatav: :-> is a constructor operator
14:18:51 <merijn> And also potentially a type operator
14:18:52 <jle`> oh neat
14:19:04 <merijn> @define data Foo a b = a :-> b
14:19:06 <lambdabot>  Defined.
14:19:11 <merijn> :t 1 :-> 'c'
14:19:12 <lambdabot> Num a => Foo a Char
14:20:26 <dfeuer> I'm playing with different implementations of dropWhileEnd, and something goes all wonky with Call Arity if I allow the (equivalent of) ++ to fuse with reverse :-/
14:21:03 * hackagebot twentefp-eventloop-graphics 0.1.0.1 - An eventloop based graphical IO system. Used as Lab Assignments Environment at Univeriteit Twente  http://hackage.haskell.org/package/twentefp-eventloop-graphics-0.1.0.1 (sebaslafleur)
14:22:59 <stolaruk> kau: of course you could always use getEnvironment
14:23:25 <kau> stolaruk: yeah I was wondering if there was a direct binding
14:23:38 <kau> somewhere in the libraries :)
14:23:42 <stolaruk> I dunno
14:26:03 * hackagebot twentefp-number 0.1.0.2 - Lab Assignments Environment at Univeriteit Twente  http://hackage.haskell.org/package/twentefp-number-0.1.0.2 (sebaslafleur)
14:26:05 * hackagebot twentefp-trees 0.1.0.0 - Tree type and show functions for lab assignment of University of Twente. Contains RoseTree and ParseTree  http://hackage.haskell.org/package/twentefp-trees-0.1.0.0 (sebaslafleur)
14:26:07 * hackagebot twentefp-websockets 0.1.0.1 - A fork of the popular websockets package. It is used for the practical assignments of the University of Twente. A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/twentefp-websockets-0.1.0.1 (sebaslafleur)
14:28:38 <kau> How does GHC knows where the package DB is?
14:29:32 <tulcod> kau: i don't think GHC knows, but cabal assumes it's on the hackage server
14:29:34 <kau> "ghc --print-libdir" gives only the global package DB, not the local one
14:29:43 <tulcod> oh nvm me
14:31:09 <kau> I think the path to the global DB is hard coded into GHC when GHC is compiled, but I don't know for the local DB
14:32:48 <geekosaur> local db is hardcoded as well from past discussion here. there are ways to override it though, which cabal-install uses
14:34:37 <kau> Actually I'm trying to figure out how to make Hint work in a sandbox :)
14:35:23 <geekosaur> cabal exec?
14:35:32 <kau> The problem with Hint is that it uses "GHC.Paths.libdir" and not the environment variable by "cabal exec"
14:35:36 <geekosaur> which probably uses GHC_PACKAGE_PATH
14:35:45 <kau> right
14:35:50 <geekosaur> oh. that might be bad, yes
14:36:02 <geekosaur> which means hint needs to be modified, I guess
14:36:03 * hackagebot ad 4.2.1 - Automatic Differentiation  http://hackage.haskell.org/package/ad-4.2.1 (EdwardKmett)
14:36:31 <kau> geekosaur: yes, I'll try to propose a patch if I can
14:37:17 <kau> "GHC.Paths.libdir" is for global db, right? Is there a similar command for the local db?
14:41:04 * hackagebot random 1.1 - random number library  http://hackage.haskell.org/package/random-1.1 (EdwardKmett)
14:47:19 <phaazon> YES!
14:47:55 <phaazon> joseph07: I finally made it
14:47:59 <phaazon> itâ€™s SO great now :)
14:48:36 <joseph07> phaazon: how'd you do it?
14:48:49 <phaazon> https://github.com/phaazon/photon/blob/json_map/Photon/Resource/Mesh.hs
14:48:53 <phaazon> by adding a new type
14:49:05 <phaazon> and make it an instance of FromJSON :)
14:49:17 <stolaruk> I just upgraded Haskell Platform on my Mac (OS X 10.9.4). I have discovered that I can "cabal repel" and load my project w/ no problems. I can also "cabal build" successfully. But if I "runghc" my "Main.hs" (w/ a "-i" argument...), I get a handful of "Could not find module xxx" errors. Anyone know why this might be?
14:50:22 <joseph07> phaazon: Cool!
14:51:04 * hackagebot random 1.0.1.3 - random number library  http://hackage.haskell.org/package/random-1.0.1.3 (EdwardKmett)
14:51:30 <phaazon> yeah
14:51:33 <phaazon> itâ€™s great
14:51:35 <joseph07> phaazon: wow applicative worked really well there
14:51:40 <phaazon> yeah
14:51:46 <phaazon> I love applicative <3
14:51:51 <phaazon> and the extra thing here
14:52:03 <phaazon> I donâ€™t have to modify my core types
14:52:06 <jle`> i didn't know that edwardk was the maintainer of random
14:52:08 <phaazon> which is extremely great
14:52:18 <alrunner4> stolaruk: are you building in a sandbox? cabal repl/build will use sandboxed libraries, while i believe runghc will not.
14:52:30 <jle`> i wonder what's new in 1.1
14:52:32 <stolaruk> alrunner4: Indeed I am knee deep in sand
14:52:45 <edwardk> jle`: core libraries committee is, i'm just the mouthpiece
14:52:46 <jle`> the first minor version bump ever, i think
14:52:48 <jle`> ah, i see
14:52:56 <jle`> oh, random is a part of core
14:53:11 <edwardk> jle`: now it is. it was ryan newton's beforehand
14:53:19 <edwardk> but we had some backlogged issues building up
14:53:21 <jle`> such lore
14:53:24 <edwardk> and hehanded over maintainership
14:53:25 <jle`> must learn
14:53:35 <edwardk> so we took over and made some of the easier changes
14:53:52 <edwardk> we still want more efficient splits, etc. so there will likely be another major release eventually
14:54:07 <jle`> are splits cryptographically sound yet?
14:54:08 <hexagoxel> stolaruk: you know about "cabal run"?
14:54:10 <edwardk> but this should fix the worst of the StdGen spaceleak problems, infelicities in stated bounds of the rng, etc.
14:54:15 <stolaruk> hexagoxel: not really
14:54:19 <edwardk> jle`: that is the next major release concern i think
14:54:22 <stolaruk> hexagoxel: I shall try that
14:54:23 <jle`> i see
14:54:39 <jle`> well people shouldn't be using random for actual crypto anyway, hopefully
14:54:40 <jle`> :|
14:54:50 <stolaruk> Wow "cabal run" worked like a charm!
14:54:52 <stolaruk> Nice.
14:55:06 <stolaruk> I shall now light a cigar.
14:55:12 <dhrosa> is 4 a random number?
14:55:33 <Axman6> sometimes
14:55:40 <koala_man> people never choose even numbers when you ask for a random one
14:56:11 <dhrosa> well, odd numbers are rather odd
14:56:49 <stolaruk> of course 4 is random
14:56:54 <edwardk> jle`: if you ask me for a random one, i'll hand you a one =)
14:56:58 <edwardk> er koala_man
14:57:03 <dhrosa> the edwardk random number generator
14:57:41 <edwardk> if you ask me for a random number, well, time to get out a quantum random number generator =P
14:58:49 <vanila> tf-random should be good for crypto?
14:59:09 <merijn> vanila: Pretty sure it's not
14:59:10 <Peaker> http://xkcd.com/221/
14:59:31 <vanila> the idea of tf random seemed to be like hashing a "path" each time you split a bit 0 for left or 1 for right gets added to the path
14:59:34 <merijn> vanila: The description even mentions it's pseudorandom
14:59:54 <vanila> it holds the internal state of smoething like an MD5 as it goes though, so it doesn't need to carry around a large bit string/path
14:59:59 <merijn> You really want to get high quality entropy from the OS for crypto
15:00:14 <vanila> Skein not md5
15:00:22 <merijn> vanila: "Please note that even though the generator provides very high-quality pseudorandom numbers, it has not been designed with cryptographic applications in mind."
15:00:39 <cite-reader> This synopsis suggests the state space is 32 bits, which... you can brute-force that in two minutes. I wouldn't use this for crypto.
15:00:53 <vanila> merijn, darn it's such a nice language
15:01:30 <cite-reader> Oh, no wait ignore me, I misread that sentence.
15:03:42 <vanila> http://www.haskell.org/wikiupload/7/74/Hiw2012-michal-palka.pdf
15:03:54 <vanila> http://publications.lib.chalmers.se/records/fulltext/183348/local_183348.pdf
15:13:17 <Fuuzetsu> I used ViewPatterns and now GHC won't shut up about non-exhaustive patternsâ€¦
15:13:33 <silasm> so I'm having a surprisingly hard time finding functions to read Ints/Words from Binary/Hex string representations. Is there really not a library for this?
15:14:03 <dhrosa> silasm: there is, one sec
15:14:19 <dhrosa> silasm: http://hackage.haskell.org/package/base-4.7.0.1/docs/Numeric.html
15:14:30 <dhrosa> silasm: readHex
15:14:45 <silasm> dhrosa: thanks, much appreciated.
15:14:54 <dhrosa> silasm: or more generically, readInt can take an arbitrary base
15:15:34 <Fuuzetsu> ok well, seems there are half a decade old bugs about ViewPatterns ;/
15:17:04 <dhrosa> any emacs + haskellers here? I want to make emacs use tab for autocomplete instead of C-/ inside the ghci buffer
15:18:00 <neoq> how do i use this shit
15:19:00 <dhrosa> neoq: what shit?
15:19:08 <hexagoxel> well, what's the type of "shit"?
15:19:57 <dhrosa> shit :: Monad m => Food -> m Shit
15:20:59 <neoq> https://news.ycombinator.com/item?id=7161364
15:24:00 <chrisdotcode> "Haskell is invariant under gender. Really!" haha
15:25:07 <silasm> > let swedish = intersperse 'f'; greeting = "Hello neoq" in swedish greeting
15:25:09 <lambdabot>  "Hfeflflfof fnfefofq"
15:27:30 <Hijiri> what would it mean for a wxHaskell event to have type Event w Int, or anything where the handler isn't something IO a?
15:27:46 <yyttr3> Does there exist an "Inverted" bind? (iBind) :: (Monad m, Monad n) => m a -> (a -> n b) -> n b
15:27:53 <yyttr3> Or anything like it
15:28:23 <dhrosa> that operation doesn't make sense in general for  a monad
15:28:25 <Hijiri> you wouldn't be able to implement it just with monads
15:28:25 <dhrosa> I don't think
15:29:15 <yyttr3> I just need a function to take Just a -> [a] and Nothing -> []
15:29:15 <dhrosa> yyttr3: for example, what would happen if you used iBind Nothing (Identity . (*2)) ?
15:29:26 <Hijiri> I think there's maybeToList
15:29:30 <theshadow1> So I'm trying to use http://www.seas.upenn.edu/~cis194/spring13/lectures.html to learn haskell and I'm working on week 1 and I think I have a solution but I can't seem to get ghci to accept my code https://gist.github.com/theshadow/c23583112c70d8d49e44 the messages I'm seeing are in the comments in the gist. Can anyone help me?
15:29:31 <dhrosa> yyttr3: you can make it specifically for maybe
15:29:34 <Hijiri> :t maybeToList
15:29:35 <dhrosa> yyttr3: there can't exist a general one
15:29:35 <lambdabot> Maybe a -> [a]
15:29:41 <yyttr3> It would return nothing I assume.
15:30:00 <yyttr3> There has to be a way to make a general one.
15:30:01 <dhrosa> yyttr3: it can't, because the return type has to be part of Identity
15:30:04 <dhrosa> Identity has no nothing type
15:30:17 <dhrosa> yyttr3: you'd need MonadPlus or something to possibly make this work
15:30:23 <dhrosa> instead of just Monad
15:30:36 <Fuuzetsu> theshadow1: the guards go before the equals sign
15:30:55 <Fuuzetsu> foo x | â€¦ = â€¦, not foo x = | â€¦ = â€¦
15:31:03 <theshadow1> Fuuzetsu ty
15:31:27 <dhrosa> yyttr3: Nothing only exists for the Maybe monad, a lot of other monads don't have any concept of "nothing"
15:31:32 <yyttr3> Isn't a MonadPlus just a monad that's also a monoid.
15:31:56 <dhrosa> yes, which also means it defines a "zero" value
15:32:26 <dhrosa> yyttr3: unless you know the monad has a "zero" value, your iBind operation can't be made for any arbitrary monad
15:32:39 <shachaf> A monoid in a particular way.
15:32:46 <dhrosa> even then, this still makes little sense
15:32:54 <shachaf> Along with some laws relating the two ways that it's a monoid.
15:32:58 <Fuuzetsu> yyttr3: No, monoids are of a different kind
15:33:06 <yyttr3> In which case mempty (id . (*2)) = mempty where each mempty is for the particular MonadPlus we're talking about.
15:33:17 <shachaf> mzero >>= f = mzero; v >> mzero = mzero
15:33:25 <shachaf> These laws seem very fishy.
15:33:26 <dhrosa> what about using iBind [1, 2, 3] Just
15:33:33 <shachaf> Certainly they're not valid for IO.
15:33:34 <dhrosa> yyttr3: what kind of result do you expect from that
15:33:47 <dhrosa> yyttr3: the return type has to be a Maybe Int
15:33:56 <Fuuzetsu> shachaf: what would mzero be for IO?
15:34:34 <yyttr3> I don't know.
15:34:52 <dhrosa> Fuuzetsu: perhaps a "no-op" action
15:34:56 <shachaf> Fuuzetsu: Ah, the instance is orphan. It's defined in http://hackage.haskell.org/package/transformers-0.4.1.0/docs/src/Control-Monad-Trans-Error.html
15:35:15 <yyttr3> No
15:35:25 <Fuuzetsu> and what an instance that isâ€¦
15:35:37 <yyttr3> iBind [Sum 1, Sum 2, Sum 3] Just = Just Sum 6
15:35:42 <yyttr3> Possibly
15:36:04 <dhrosa> yyttr3: okay sure, you need the thing inside the monad to be a monoid then
15:36:13 <dhrosa> yyttr3: which is okay, but your  original type signature wouldn't work
15:36:33 <Fuuzetsu> I guess it makes for a nice <|> though
15:36:56 <shachaf> What?
15:36:59 <yyttr3> So something like (iBind) :: (Monad n, Monad m, Monoid a, Monoid b) => m a -> (a -> n b) -> n b    could exist.
15:37:14 <dhrosa> yyttr3: sure, there could be a sensisble implementation of that
15:37:29 <exio4> how do you take a value out of a monad though?
15:37:29 <dhrosa> in general
15:37:31 <cite-reader> What happens if m ~ IO?
15:37:35 <shachaf> yyttr3: Huh?
15:37:37 <dhrosa> oh wait
15:37:51 <Fuuzetsu> yyttr3: interesting, now take m = IO, n = Identity and check again
15:38:05 <Fuuzetsu> (or any m /= n)
15:38:08 <shachaf> "take a value out of a monad" doesn't make sense for multiple reasons
15:38:23 <dhrosa> yeah that still doesn't make sense
15:38:48 <Fuuzetsu> you can't just â€˜changeâ€™ a monad
15:39:14 <Fuuzetsu> (just like you can't just take out the value for some definition of take out)
15:39:27 <exio4> I still don't get how that function would work with m = [] if f is (a -> n b) ...?
15:39:36 <Fuuzetsu> exio4: it would not work
15:40:07 <Fuuzetsu> exio4: it would not work for any m /= n
15:40:29 <Fuuzetsu> you just can't implement it
15:40:50 <yyttr3> Look, the main problem I was having was: I had a [Maybe Char] and I needed a String. I would just make a specific implementation, but i've had this problem before with other nested type constructors, I have say a someMonad(someMonad(Int)) and I need a someMonad(Int)
15:41:08 <dhrosa> if they're the same monad, you can just use join
15:41:08 <exio4> heh, so basically it doesn't work when it isn't what we got now :P
15:41:10 <dhrosa> :t join
15:41:11 <lambdabot> Monad m => m (m a) -> m a
15:41:26 <shachaf> Maybe and [] are monads. They're also many other things.
15:41:31 <shachaf> Not everything is about monads.
15:41:38 * Digit just ran through the tryhaskell.org to try to get back into learning Haskell, and has converted some pdf Haskell books to plain text and is playing them with flite in the background for extra subliminal haskell learning
15:41:46 <twanvl_> :t catMaybes
15:41:46 <Fuuzetsu> :t catMaybes
15:41:47 <lambdabot> [Maybe a] -> [a]
15:41:47 <lambdabot> [Maybe a] -> [a]
15:41:49 <theshadow1> https://gist.github.com/theshadow/d8859e7c0e9e08c8f921 in this gist I believe my error is that sum expect [Num] not [Integer] how would I conver? Or should I just use foldr to do the sum myself?
15:41:56 <zwer_b> :t catMaybes
15:41:57 <lambdabot> [Maybe a] -> [a]
15:42:14 <zwer_b> way too late
15:42:16 <Fuuzetsu> theshadow1: such a thing as [Num] does not exist
15:42:17 <dhrosa> theshadow1: no that's not your problem
15:42:29 <shachaf> theshadow1: Num isn't a type.
15:42:31 <yyttr3> I can make handle the specific case, I just just hoping there was something more general
15:42:41 <Digit> bool?
15:42:46 <shachaf> theshadow1: sum :: [Integer] -> Integer, or at least that's a valid type to use it at.
15:42:54 <dhrosa> theshadow1: you want (sum . doubleEveryOther $ xs)
15:43:05 <Fuuzetsu> or sum $ doubleEveryOther xs
15:43:09 <glguy> just:   sum (doubleEveryOther xs) will do
15:43:10 <dhrosa> theshadow1: the problem is that the . operator binds less tightly than function application
15:43:20 <Fuuzetsu> glguy: get out with your parenthesis old man
15:43:26 <dhrosa> theshadow1: haskell interprets your code as (sum . (doubleEveryOther xs)) `mod` `0
15:43:26 <shachaf> yyttr3: Maybe "join . fmap maybeToList" is close to whatever you're trying for.
15:43:45 <dhrosa> theshadow1: (doubleEveryOther xs) returns a [Integer], but compose (.) wants a function
15:43:59 <dhrosa> theshadow1: so you need to use more parenthesis, or $
15:44:26 <theshadow1> Oh, I didn't realize that . required a function I thought it just expected an expression of a function that accepted a single parameter
15:44:44 <dhrosa> theshadow1: that's not it
15:44:53 <Fuuzetsu> theshadow1: function application binds stronger than (.)
15:44:54 <dhrosa> theshadow1: (doubleEveryOther xs) isn't a function or an expression that returns a function
15:45:02 <dhrosa> theshadow1: (doubleEveryOther xs) is of type [Integer]
15:45:12 <Fuuzetsu> theshadow1: f . g x = f . (g x), not (f . g) x
15:45:17 <yyttr3> shachaf : Thank you, thanks for entertaining the question too.
15:45:22 <theshadow1> I see
15:51:53 <kgadek> Good evening (0:46am here) everybody! I want to gather ideas on build systems.
15:51:54 <kgadek> Currently my team uses in-house (ie: quite messy) scripts wrapping around cabal sandboxes to solve cabal hell, allow fairly independent development of components (think: one component = one cabal project), provide "build world" command, etc.
15:51:55 <kgadek> But that's messy :) I'm gathering ideas and will do more research. What's the best way here? Rewrite scripts (with shake perhaps)? Unlift components from subprojects to module level (that'd be awful actually)? Do some other magic?
15:51:56 <kgadek> Oh, one thing: nix is not supported on Windows which rules it out.
15:54:09 <Fuuzetsu> kgadek: AFAIK nix runs just fine on Windows (cygwin)
15:55:00 <Fuuzetsu> wrapping cabal sandboxes is hardly solving cabal hell, just working around it by throwing a lot of computation at it
15:56:21 <kgadek> Fuuzetsu: ok, I'll do the experiments then. // wrapping cabal sandboxes is really nasty. While it's the thing That Worksâ„¢, it builds eg. lens 10x
15:56:53 <Fuuzetsu> yes, when I was on Gentoo I ended up rebuilding lens multiple times a day
15:57:00 <Fuuzetsu> forget multiple branches or versions
15:57:23 <kgadek> ok, so I'll try nix for sure
15:57:28 <kgadek> any other options if nix fails?
15:58:00 <codehero> http://lpaste.net/111141
15:58:08 <codehero> could somebody please tell me what the problem is?
15:58:18 <codehero> it says that map is applied to four arguments
15:58:24 <shachaf> Why don't you tell us what the problem is?
15:58:31 <codehero> but it isn't
15:58:34 <shachaf> I.e. add the complete error message to that paste.
15:59:02 <shachaf> The answer is that elem isn't an infix function. Only symbols and `backtickedNames` are infix.
15:59:07 <glguy> codehero: when you write     (f x) y     it's the same as    f x y
15:59:25 <kgadek> codehero: use `elem` with ticks around
16:00:01 <codehero> awesome! thank you! :)
16:00:27 <shachaf> Also, you should generally trust GHC to know Haskell better than you do. :-)
16:00:35 <shachaf> If it says that map is applied to four arguments, it probably is.
16:00:52 <Thule> Hi. I am new to Haskell and I was told that emacs and haskell-mode is great together. However I have not been able to add haskell-mode to emacs, so I help that one of you guys can help.
16:01:00 <fiatjaf> this channel has a lot of messages when the other channels are quiet.
16:01:07 <codehero> shachaf: yeah. heh
16:01:40 <Thule> When I try to make I get the exception: opening output file: no such file or directory: C:/cygdrive/.../haskell-mode-autoloads.el. I am running win8 with newest cygwin
16:05:58 <kgadek> Thule: using different OS, so my blind guess: change slashes to backslashes in your config file
16:07:20 <Thule> which config file kgadek?
16:07:39 <Fuuzetsu> sure is a lot of beginners today
16:07:58 <Thule> Fuuzetsu well isn't it just good with more people joining the community? :)
16:08:10 <Fuuzetsu> just pointing it out
16:08:11 <codehero> cygwin probably uses slashes
16:08:39 <kgadek> Thule: have you used any tutorial?
16:08:40 <Fuuzetsu> emacs runs on Windows natively, does it not?
16:09:06 <Thule> ye kgadek this one: https://github.com/haskell/haskell-mode
16:10:00 <kgadek> â€¦ok, I'll give up and say :q â€” I use vim, sorry and good luck :)
16:10:29 <Thule> hehe thanks for the try :) Another way is to use M-x update-directory-autoloads from within emacs, but I do not know where to write it in emacs
16:11:20 <kgadek> Thule: you mean how to enter that command?
16:12:27 <Thule> ye kgadek
16:12:39 <kgadek> M means meta means Alt
16:12:42 <kgadek> so press Alt-x
16:12:51 <Thule> ahh great
16:12:53 <Thule> thanks
16:13:29 <benzrf> if i had a trillion dolars
16:13:32 <kgadek> btw, I find it strange that emacs community never dropped that legacy naming in favor of current "Alt" convention
16:13:38 <Fuuzetsu> then you'd have a trillion dollars
16:13:45 <benzrf> i'd bribe the big software companies to be free software ONLY
16:14:06 <Fuuzetsu> kgadek: It's not alt, it's meta, it's just that most systems emulate meta with alt
16:14:06 <athan> If you were trying to share state within a wai application like scotty, how would you do it? Is this what IORefs are for? Probably can't do it with a state monad transformer, because it tries to be concurrent... unless that's possible (but probably turns request handling sequential). Any ideas?
16:15:05 <benzrf> :t atomically
16:15:06 <lambdabot> Not in scope: â€˜atomicallyâ€™
16:15:08 <benzrf> hm
16:15:13 <benzrf> :t Control.Monad.STM.atomically
16:15:14 <lambdabot> GHC.Conc.Sync.STM a -> IO a
16:15:34 <Fuuzetsu> benzrf: with trillion dollars you could pay enough people off to make better free software to begin with
16:15:35 <shachaf> You know, not every function's existence needs to be demonstrated with :t
16:15:44 <kgadek> Fuuzetsu: ok, but I believe my point is still valid. Nobody understands "meta" except for emacs users ;)
16:15:53 <shachaf> If someone doesn't know that atomically exists, the type won't help them much. If they do know that it exists, the type still won't help them much.
16:15:56 <benzrf> Fuuzetsu: [hence the joke]
16:15:56 <athan> benzrf: You're awesome :)
16:15:59 <benzrf>    
16:16:23 <benzrf> shachaf: i was Checking for myself
16:16:29 <Fuuzetsu> kgadek: you know about it and you're not an emacs user; anyone having used pretty much any library dealing with keyboard input knows it
16:16:40 <Fuuzetsu> it's common, it's not just emacs, emacs didn't come up with it
16:16:41 <kgadek> Fuuzetsu: I used emacs
16:17:25 <Fuuzetsu> Are you going to start writing A-x instead of M-x?
16:18:03 <kgadek> frankly, Alt+x is what I always use
16:18:42 <koala_man> Fuuzetsu: isn't it even called "emacs notation"?
16:19:12 <kgadek> Fuuzetsu: actually the whole world seems to use this scheme
16:19:20 <kgadek> (except for emacs users of course ;P )
16:20:19 <Fuuzetsu> koala_man: not that I know of
16:20:33 <Thule> Is there some way to check which packages I have installed?
16:20:34 <trap_exit> so I'm reading http://h2.jaguarpaw.co.uk/posts/strictness-in-types/ ... and I'm wondering (1) is ":->" a type constructor name? (2) can type contructors be _infix_ and (3) is this black magic?
16:20:47 <Fuuzetsu> trap_exit: they can
16:20:54 <Fuuzetsu> there is even -XTypeOperators
16:21:13 <trap_exit> https://www.google.com/?gws_rd=ssl#q=-XTypeOperators
16:21:47 <Fuuzetsu> hm, I thought it was a thing
16:21:52 <Fuuzetsu> maybe it's called something else
16:21:59 <comerijn> TypeOperators is a thing
16:22:12 <Fuuzetsu> https://github.com/ghc/haddock/blob/master/html-test/src/TypeOperators.hs yes it is
16:22:28 <Thule> nvm found it
16:22:28 <Fuuzetsu> Google just being useless
16:22:29 <merijn> http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#type-operators
16:22:54 <Ptival> hello, I'm having trouble figuring out how to have a Snaplet do some sort of serveDirectory, any poiner?
16:23:05 <trap_exit> merijn: thanks!
16:23:19 <trap_exit> Ptival: I'd like to know too if you figure it out
16:23:21 <Fuuzetsu> merijn: are you missing a letter
16:23:36 <merijn> Fuuzetsu: ?
16:23:45 <Fuuzetsu> merijn: wow ok, all this time I was reading it â€˜merijinâ€™
16:23:47 <Fuuzetsu> always
16:24:08 <Fuuzetsu> thanks brain
16:24:22 <Ptival> autocorrect fail :)
16:25:07 <Hijiri> is there a way to force a cabal package to use a newer version of one of its dependencies?
16:25:17 <Fuuzetsu> --allow-newer
16:25:18 <trap_exit> Fuuzetsu: you have too many vowels
16:25:21 <Hijiri> ok, thanks
16:25:57 <Fuuzetsu> trap_exit: just one more than you, end technically uu should be Å«
16:26:23 <trap_exit> can you imagine how expensive that would be on wheel for fortune?
16:26:30 <trap_exit> Å« , e, u, then z
16:27:14 <trap_exit> haskell is amazing
16:27:20 <trap_exit> I like how that when people run into problemw sith haskell
16:27:27 <trap_exit> the right solution is "oh well, new extension"
16:28:09 <merijn> Fuuzetsu: Technically for me it should be Ä³, but freenode doesn't allow unicode in nicknames :(
16:29:08 <systemfault> trap_exit: But then... are you still writing Haskell?
16:29:15 <systemfault> I've been wondering that for a while.
16:30:20 <Fuuzetsu> not Haskell 98 or 2010
16:30:25 <ryantrinkle> what's the right function to use to generalize 'const'? 'pure'?
16:30:25 <ryantrinkle> (generalizing it to a -> f a)
16:30:28 <Fuuzetsu> GHC Haskell ;)
16:30:45 <shachaf> A generalization isn't right on its own.
16:30:55 <shachaf> It depends on what you want to do with it.
16:31:09 <ryantrinkle> shachaf: that's a good point
16:31:25 <ryantrinkle> i was just wondering if this has come up frequently enough for anyone to have written something
16:31:46 <vise890> hi all. I'm trying to install ghc-mod with `cabal install ghc-mod`
16:32:00 <shachaf> What's the right generalization of (.)? fmap or (Control.Category..)?
16:32:43 <shachaf> What's the right generalization of integer addition? Monoid or Semigroup or Group or Ring?
16:32:46 <vise890> this is the output of a (subsequent) retry http://lpaste.net/111142 (the first time was the same)
16:33:28 <glguy> shachaf: Monoid (that was was easy)
16:35:09 <trap_exit> https://www.youtube.com/watch?v=w-I6XTVZXww
16:35:11 <trap_exit> wtf is this valid ?
16:35:21 <trap_exit> I thought these sums are undefined because they do not converge
16:36:13 <ryantrinkle> i guess a better question for me to ask would be: is there any notion of "constness" that has interesting laws, without adding additional functionality?
16:36:30 <coppro> \
16:36:46 <shachaf> ryantrinkle: pure isn't an unreasonable choice.
16:37:03 <shachaf> You can think of "constness" as "has no effects", roughly. Maybe.
16:37:11 <ryantrinkle> yeah, that makes sense
16:37:42 <ryantrinkle> and i think the laws with <*> make sense for const, too
16:38:18 <ryantrinkle> instance Applicative ((->) a) where { pure = const ; (<*>) f g x = f x (g x) }
16:38:24 <shachaf> The Applicative laws are asymmetric. It's such a scow.
16:38:25 <ryantrinkle> straight from 'base'
16:38:37 <ryantrinkle> hm; asymmetric how?
16:38:47 <shachaf> Well, f (a -> b) -> f a -> f b
16:39:00 <shachaf> Compare to liftA2 :: (a -> b -> c) -> f a -> f b -> f c, or to times :: f a -> f b -> f (a,b)
16:39:15 <shachaf> Both of them make for nicer laws than Applicative.
16:40:43 <benzrf> times!!!
16:40:50 <benzrf> wait, what would be the times laws
16:41:15 <benzrf> 07:31 < shachaf> What's the right generalization of integer addition? Monoid or Semigroup or Group or Ring?
16:41:18 <benzrf> shachaf: group, of course
16:42:44 <ryantrinkle> shachaf: interesting
16:43:45 <benzrf> literally the integers are the only infinite cyclic group
16:43:57 <benzrf> thats the definition of integers!!!
16:48:00 * Cale somehow imagines that benzrf is Pokey the Penguin
16:48:21 <c_wraith> That's a weird definition.
16:48:44 <benzrf> Cathy: i wish!
16:48:51 <benzrf> er, callumacrae
16:48:54 <benzrf> .... Cale
16:49:15 <Cale> http://www.yellow5.com/pokey/archive/index567.html
16:49:42 <benzrf> christ i wish i were pokey
16:51:17 <benzrf> pokey the penguin is one of the few comics thats hipstery enough for me to be theoretically willing to wear a shirt of
17:01:18 * hackagebot random 1.0.1.3 - random number library  http://hackage.haskell.org/package/random-1.0.1.3 (EdwardKmett)
17:01:18 * hackagebot ghc-mod 5.1.0.1 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-5.1.0.1 (DanielG)
17:14:40 <Fuuzetsu> is there a package with fast naturals yet?
17:31:14 * hackagebot configuration-tools 0.2.5 - Tools for specifying and parsing configurations  http://hackage.haskell.org/package/configuration-tools-0.2.5 (larsk)
17:39:44 <athan> benzrf: Would you try and wrap STM in the ScottyT transformer, replacing IO...? The normal execution of scotty apps usually follows `scotty 3000 $ do...`, in the `ScottyM ()` monad, but I'm not sure if (or how ) I could turn that into a `ScottyM STM` monad... It looks like `ScottyM = ScottyT  Lazy.Text IO`, where `ScottyT e (m :: *->*) a = ScottyT {runS :: StateT (ScottyState e m) m a}`... Should STM be the `a`? (sorry to bug you btw :/)
17:46:30 <alrunner4> @type Web.Scotty.Trans.scottyT
17:46:32 <lambdabot> Not in scope: â€˜Web.Scotty.Trans.scottyTâ€™
17:46:41 <alrunner4> or not
17:46:41 <benzrf> athan: i duno
17:47:31 <alrunner4> athan: perhaps http://hackage.haskell.org/package/scotty-0.9.0/docs/Web-Scotty-Trans.html#v:scottyT
17:47:47 <athan> benzrf: :(
17:47:56 <zereraz> hello, if I want to use a variable in all functions(like global) I have to pass it in all functions or is there any other way, and is it bad?
17:48:02 <athan> alrunner4: I'll check it out, thanks :)
17:48:17 <zereraz> Like I want to do list operations
17:48:45 <benzrf> zereraz: erm
17:48:51 <benzrf> just define it at the top level?
17:48:52 <benzrf> x = 3
17:48:56 <benzrf> foo n = n + x
17:48:58 <zereraz> ok that works
17:49:06 <zereraz> is it bad?
17:49:15 <zereraz> normally global variables are bad right
17:49:16 <heatsink> Does the variable have the same value in all function calls
17:49:20 <zereraz> yes
17:49:29 <heatsink> Global variables are not bad.
17:49:39 <Fuuzetsu> zereraz: we don't have â€˜variablesâ€™, they don't vary
17:49:43 <zereraz> like if it changes in one function it should reflect that change in other aswell
17:49:46 <Fuuzetsu> you define x to be 3 and that's it
17:49:49 <zereraz> Fuuzetsu: yeah
17:50:02 <heatsink> In languages where you can modify variables, global variables are considered bad because it's hard to keep track of how their values change.
17:50:08 <zereraz> Like I was planning to make a simple to do list
17:50:19 <zereraz> so the list remove, add
17:50:21 <Iceland_jack> Fuuzetsu: They're called variables in Haskell
17:50:24 <Iceland_jack> Just like in mathematics
17:50:25 <zereraz> like stack
17:50:29 <igor__> Hi there! Can anybody recommend a good tutorial on state monad?
17:50:36 <Fuuzetsu> Iceland_jack: hence the â€˜â€™s
17:51:05 <zereraz> I understand that in haskell we don't have side effects
17:51:09 <Iceland_jack> Mutable cells would make it clearer
17:51:14 <zereraz> how do you propose I make it?
17:51:16 <Iceland_jack> Or might anyway :)
17:51:20 <Fuuzetsu> igor__: have you read http://www.haskell.org/haskellwiki/State_Monad ?
17:51:28 <Fuuzetsu> Iceland_jack: please don't suggest such a thing to beginners
17:52:33 <Fuuzetsu> zereraz: define a bunch of functions such as addTask :: TodoList -> Task -> TodoList, then simply glue those together
17:52:36 <igor__> yeah, I've read.. but wanna know if there's something else. Also read from Rwh, but still want a different tutorial or whatever
17:52:49 <Fuuzetsu> igor__: IIRC the wikibook has something too
17:53:00 <igor__> ok, thanks
17:53:08 <Fuuzetsu> igor__: http://en.wikibooks.org/wiki/Haskell/Understanding_monads/State
17:53:10 <benzrf> igor__: do you understand the reader monad?
17:53:22 <zereraz> Fuuzetsu: where Task is a new data ?
17:53:35 <igor__> not everything
17:53:40 <benzrf> igor__: grok reader first
17:53:46 <benzrf> after that, state is kind of like reader+
17:53:55 <heatsink> igor__ left
17:53:56 <Fuuzetsu> zereraz: Yes, Task is the thing you want to add, you simply get out a new TodoList
17:54:21 <zereraz> Fuuzetsu: ok thanks
17:54:36 <benzrf> heatsink: mfw
17:59:02 <zereraz> if a function just prints something then its type signature is :: IO() right?
18:00:06 <shachaf> Something whose type is IO () isn't a function.
18:00:56 <zereraz> ok if a function has 1 print statement in it?
18:01:03 <heatsink> IO computations that print to stdout have type IO ()
18:01:16 <shachaf> heatsink: Well, IO x for some type x.
18:01:17 <heatsink> If a function returns one of these, then its result will have type IO ()
18:01:18 <zereraz> yes it prints to stdout
18:01:38 <zereraz> by return you mean =
18:01:51 <merijn> zereraz: Haskell has no statements
18:01:57 <merijn> zereraz: Only expressions
18:02:04 <zereraz> merijn: ok
18:02:06 <heatsink> yes, the part on the right-hand side of the = evaluates to the function's return value
18:02:23 <zereraz> merijn: I don't exactly know the difference
18:02:31 <zereraz> merijn: statements state
18:02:39 <zereraz> merijn: expressions need to be evaluated?
18:02:48 <adam789654123> i dont get it yet either
18:02:49 <zereraz> heatsink: ok thanks
18:03:00 <adam789654123> but im new to Haskell
18:03:01 <merijn> zereraz: In programming language semantics, expressions have/return a value, whereas statements update state and don't return anything
18:03:17 <zereraz> merijn: nice, got it
18:03:18 <merijn> zereraz: Haskell, having no mutable state, has no use for statements
18:03:38 <zereraz> merijn: in a way haskell has to return
18:03:44 <HeladoDeBrownie> The Report refers to statements as parts of do blocks, but those bear only a surface resemblance to other things called statements and ultimately desugar to expressions anyway.
18:03:44 <merijn> zereraz: The type "IO ()" is the type of "an IO action that does *something* and produces a value of type ()"
18:03:48 <zereraz> merijn: as state cannot be updated
18:05:06 <adam789654123> how does that change language design and usage (statements vs. expressions)?
18:05:35 <adam789654123> not that i need an answer
18:05:40 <adam789654123> just something im wondering
18:05:53 <cjenkin1> adam789654123: It makes reasoning about the code much easier, for one thing
18:06:05 <heatsink> The only langauges I can think of that have _only_ statements are assembly
18:06:07 <adam789654123> thats something to look forward to
18:06:10 <zereraz> adam789654123: I found this http://www.haskellforall.com/2013/07/statements-vs-expressions.html
18:06:13 <HeladoDeBrownie> adam789654123, well, one obvious thing is that instead of mutating an environment of some sort, as would be common in Java or the like, you simply define functions that result in values that you can then use.
18:06:48 <adam789654123> is this related to the usage of `let' in the repl?
18:07:05 <heatsink> The repl imitates the syntax of do
18:07:09 <adam789654123> i get the idea that im masking a global env or something
18:07:09 <HeladoDeBrownie> adam789654123, ghci is weird. The "let" there is based off of the "let" of do expressions.
18:07:13 <merijn> adam789654123: "let" desugars into letn/in
18:07:25 <zereraz> which is an expression
18:07:25 <adam789654123> ok
18:07:37 <merijn> > let x = 3 in x
18:07:39 <lambdabot>  3
18:07:41 <adam789654123> im thinking of a `let' local variable in lisp
18:07:52 <adam789654123> like (let ((x ...
18:08:06 <adam789654123> not that this is whats happening
18:08:08 <merijn> adam789654123: You can think of ghci as "let x = foo" becoming: "let x = foo in {- rest of ghci session here -}"
18:08:20 <adam789654123> yes
18:08:22 <HeladoDeBrownie> adam789654123, Lisp's let makes you specify an expression in which the variables are bound, no? That's what Haskell's let ... in ... does.
18:08:29 <adam789654123> that seems to go along with my thinking
18:08:32 <heatsink> Expression-based languages can manipulate environments.  Scheme does that.
18:08:43 <adam789654123> ok
18:08:58 <heatsink> In a language with statements and expressions, you tend to need ways of turning expressions into statements and vice versa.
18:09:15 <heatsink> For example, C++ recently acquired lambda expressions, which allow you to write statements inside an expression.
18:10:07 <cjenkin1> And the hack for allowing this expression to be either constant or modify the scope it was defined in...
18:10:21 <cjenkin1> *modify variables in the scope
18:10:31 <adam789654123> so the let in haskell is a local binding like in lisp
18:10:44 <HeladoDeBrownie> Sort of. Haskell variables are immutable though.
18:10:51 <adam789654123> yeah
18:10:55 <adam789654123> thats new for me
18:11:33 <cjenkin1> When you need state-y behavior, you wrap it in some kind of monad usually.
18:11:44 <cjenkin1> These have a nice algebraic structure that you can reason about
18:11:52 <HeladoDeBrownie> In practice you can still pretend you have mutability, in various ways depending on your needs. You can use recursion to emulate the updating of a state, for one thing.
18:12:03 <adam789654123> yeah, this is the new stuff that i have to learn
18:12:18 <adam789654123> thats interesting
18:12:30 <cjenkin1> which? or both? ;)
18:12:31 <adam789654123> and it makes sense
18:12:56 <adam789654123> the recursion for state caught my eye
18:13:00 <HeladoDeBrownie> main = sumInputs 0 ; sumInputs x = do { line <- getLine ; let x' = x + read line ; print x' ; sumInputs x' }
18:13:06 <HeladoDeBrownie> Haven't tested that but it shows the general idea
18:13:17 <adam789654123> although im also very interesting in mathematical reasoning
18:13:47 <cjenkin1> Maybe when you get comfortable with Haskell you can try out Agda or Idris :D
18:14:08 * cjenkin1 proselytizes
18:14:15 <adam789654123> i have no idea what to try next
18:14:22 <adam789654123> im just very interested in Haskell
18:14:24 <exio4> using haskell as a gateway drug to Idris!
18:14:31 <adam789654123> its such a unique language
18:14:41 <cjenkin1> Very, and very influential
18:14:59 <adam789654123> which is another perk
18:15:01 <alpha123> Haskell is only a gateway drug to dependent typing :-)
18:15:07 <cjenkin1> ^^^
18:15:25 <adam789654123> but im simply not interested in most mainstream languages
18:15:40 <exio4> dependant types are a hard drug, when you get there, you can't get back
18:15:42 <cjenkin1> adam789654123: These languages make Haskell look mainstream
18:15:44 <adam789654123> probably c is the coolest mainstream language that ive used and had fun with
18:15:51 <cjenkin1> meh
18:16:00 <adam789654123> i also like smalltalk
18:16:05 <alpha123> Pfft, Haskell is mainstream already. Time for Idris!
18:16:05 <cjenkin1> It gets boring really quickly. Take it from someone who does kernel development for a living
18:16:19 <adam789654123> what, c?
18:16:22 <cjenkin1> Smalltalk is pretty cool
18:16:24 <cjenkin1> Yup
18:16:29 <heatsink> You do kernel development and write Agda code?
18:16:39 <adam789654123> i like the potential for playing with pointers
18:16:43 <cjenkin1> heatsink: Even better. I came to Agda from Scala
18:17:02 <alpha123> Slate is pretty cool, it's like Smalltalk except with multiple dispatch and prototypal inheritance
18:17:02 <cjenkin1> And came to Scala from APL (a derivative)
18:17:14 <heatsink> That is a weird path
18:17:17 <alpha123> APL->Scala must have been an interesting switch
18:17:47 <heatsink> adam789654123: Do you know what undefined behavior means?
18:17:50 <cjenkin1> Scala was the only other language that let me handle collections almost as nicely as J.
18:17:55 <adam789654123> heatsink: no
18:18:03 <cjenkin1> That I had learned. Of course, it owes a lot to Haskell
18:18:13 <adam789654123> cjenkin1: APL guy?
18:18:33 <cjenkin1> adam789654123: J technically, but I could find my way around APL if I had too
18:18:59 <adam789654123> cool
18:19:04 <cjenkin1> J = newer APL with ASCII
18:19:09 <adam789654123> ok
18:19:14 <adam789654123> ive looked at it
18:19:25 <adam789654123> but i certainly wouldnt be able to make it sing
18:19:38 <exio4> have you looked at logic PLs?
18:19:39 <cjenkin1> It has its charm but I can't really recommend it
18:19:45 <adam789654123> ok
18:20:28 <adam789654123> be back a bit later. im hungry
18:22:02 <athan> alrunner4: Wait... but... `get :: RoutePattern -> ActionM () -> ScottyM ()`! It's a more specific type!
18:22:24 <heatsink> Haskel users tend to complain about Scala.  But those are users who derive programming abstractions from category theory, so I don't know if their issues affect more typical users.
18:23:33 <hpc> having recently started writing java again, scala reads a lot like "this is the haskell to java's unlambda"
18:23:50 <heatsink> What does java have to do with unlambda?
18:24:05 <hpc> java and unlambda are both very weak in expressiveness
18:24:14 <heatsink> o i c
18:24:26 <heatsink> scala :: java ::: haskell :: unlambda
18:26:14 <hpc> heatsink: http://www.youtube.com/watch?feature=player_detailpage&v=XQ7Lv14sryo#t=9
18:26:17 <hpc> heatsink: ;)
18:27:47 <alrunner4> athan: ? http://hackage.haskell.org/package/scotty-0.9.0/docs/Web-Scotty-Trans.html#v:get RoutePattern -> ActionT e m () -> ScottyT e m ()
18:29:27 <athan> alrunner4: Wtf... I'm looking at 0.9 also
18:30:22 <alrunner4> in the Trans module?
18:30:23 <athan> oop wait
18:30:26 <athan> yeah sorry
18:30:35 <alrunner4> no worries
18:30:37 <athan> thanks again :)
18:31:01 <alrunner4> Monad transformers ftw
18:31:31 <athan> :P
18:36:17 * hackagebot tickle 0.0.2 - A port of @Data.Binary@  http://hackage.haskell.org/package/tickle-0.0.2 (TonyMorris)
18:38:18 <joelteon> @@
18:39:39 <dibblego> heatsink: it is really unhelpful to continue propagating that myth
18:40:47 <dfsfsfs> what space complexity does dlist's append have?
18:40:55 <dfsfsfs> O(n)?
18:41:31 <dibblego> why would it be O(n)?
18:41:39 <hpc> dfsfsfs: it's fixed overhead, iirc
18:41:49 <ij> "dumplement b p@((x, y), v) = seq (trace . show $ p) $ implement b p" this doesn't trace an error, but is being run, because the program fails when (trace . show $ p) is replaced by undefined. What am I doing wrong?
18:46:37 <alrunner4> trace . show $ p :: a -> a , right?
18:48:00 <shachaf> ghci confirms it
18:48:14 <alrunner4> so seq is forcing something ( a -> a ) which never hits the trace thunk
18:48:28 <ij> oh, wait right
18:48:40 <ij> That makes me uneasy.
18:48:44 <shachaf> Oh, that was in response to something.
18:48:55 <alrunner4> :P
18:49:43 <ij> Thank you! I clearly should go to sleep.
18:50:32 <trap_exit> since in my haskell functions, we already have to add type annotations to help the compiler
18:50:40 <trap_exit> why not go all the way and add dependent types to haskell? :-D
18:53:38 <exio4> because types don't exist at runtime
18:58:52 <ij> This is not strictly haskell related, but if http://sprunge.us/ZdUF
18:59:03 <ij> dump \n in my clipboard
19:00:49 * ij rethinks whether they want to post it or not at all.
19:01:18 * hackagebot Clipboard 2.2.0.3 - System clipboard interface.  http://hackage.haskell.org/package/Clipboard-2.2.0.3 (DanielDiaz)
19:12:53 <heatsink> What myth, dibblego?
19:13:18 <dibblego> heatsink: this one, "Haskel users tend to complain about Scala.  But those are users who derive programming abstractions from category theory, so I don't know if their issues affect more typical users."
19:13:58 <dibblego> it seems benign, I know, but it is really damaging to potentially progressive discussion
19:14:36 <benzrf> dibblego: eek!
19:14:41 <benzrf> functions are from mathu
19:16:31 <dibblego> I don't mean to address all those specific issues, only point out that it seems like a benign thing to say, but it really isn't — this single issue has put a big stop to discussions over the years
19:16:46 <heatsink> For instance, the developers of .NET seem to think that higher-kinded types are a rarely-used fringe idea.
19:17:11 <dibblego> yes, they are wrong — but that doesn't mean discussion is stopped right there
19:18:12 <mathu> i bet you they aren't from me
19:18:18 <nshepperd> monads are everywhere!
19:18:22 <triliyn> What are higher-kinded types? Types with kinds like * -> * or more like (* -> *) -> *
19:18:24 <heatsink> I haven't seen much of the discussion, so I don't really understand.  How does it stop discussion?
19:18:37 <heatsink> The latter, triliyn
19:18:53 <heatsink> for example, the Monad class has kind (* -> *) -> Constraint
19:19:20 <goglosh> is there a haskell module something to draw primitives in real time?
19:19:31 <goglosh> like the allegro kind of stuff
19:19:32 <oakwhiz> goglosh: GLFW
19:20:09 <goglosh> thanks
19:20:39 <dibblego> heatsink: well first, it just isn't true. Next, it allows scala users to attribute people into (imaginary) tribes e.g. "the haskell users", so that they can dismiss any useful critique (they are just "category theory users") — and this has been the single biggest stopper to progressive discussion with scala users for many years and continues today. So, I object not just because it is false, but because of the practical consequences
19:20:40 <dibblego> with respect to discussion. I will continue this in #haskell-blah
19:21:12 <oakwhiz> goglosh: I'm using it right now to draw triangles on the screen, if you want geometric primitives, you have to use geometry to make spheres and polyhedrons
19:22:04 <goglosh> I only really care they're animated, I wanna try out swarm intelligence stuff...
19:22:11 <goglosh> but it's openGL so yeah
19:22:43 <tabemann> question
19:22:50 <tabemann> why isn't there a tryReadTMVar?
19:23:57 <merijn> tabemann: Because that's called orElse
19:24:18 <merijn> tabemann: TMVar doesn't block, it retries (which blocks if there's no alternative)
19:24:37 <tabemann> but there's a tryTakeTMVar and a tryPutTMVar
19:25:15 <merijn> tbh, I don't really see much of a usecase for "readTMVar" to begin with
19:25:51 <tabemann> I'm using TMVars as mailboxes for responses from other threads in response to messages sent to them over TQueues
19:26:29 <tabemann> for which readTMVar is quite useful, because they're only going to be written to once, but I might just want to check them more than once, or at least avoid a mistake of clearing it upon checking it a first time
19:26:30 <merijn> tabemann: Semi-unrelated question: Do you have many concurrent readers for those responses?
19:26:44 <tabemann> possibly
19:27:21 <merijn> STM suffers from thundering herd problem, although I guess that if you only ever update a TMVar once, that doesn't really matter
19:28:23 <tabemann> I'm using STM because I find in my code that I have to update many things atomically, and I don't want to deal with the mess that is locking
19:28:50 <tabemann> as what I'm doing isn't that performance-critical, I'd rather have a bit of a performance hit rather than having to deal with fixing locking bugs
19:28:59 <merijn> Sure, it's just a generic warning, because many people seem to not realise the thundering herd issue :)
19:29:59 <merijn> tabemann: But why do you want tryReadTMVar, rather than readTMVar? What will those threads do if there's no response yet?
19:34:17 <tabemann> merijn: I'm just trying to provide both blocking and nonblocking versions of functions to check for responses, just in case that someone wants them (as I'm exposing this via a scripting API)
19:35:00 <merijn> tabemann: Can't you just expose the "blocking" STM action itself so the user can just use "orElse" if they want to poll non-blockingly?
19:35:30 <tabemann> I'm exposing both
19:36:05 <merijn> tabemann: That doesn't really make sense, if you're exposing STM directly, you only need readTMVar
19:36:26 <merijn> tabemann: Because the user can just use orElse to make it unblocking
19:37:00 <tabemann> that assumes that the reason why you wouldn't want to block is if you're waiting for more than one thing at once
19:37:20 <tabemann> not that you're say, doing some continual task, and checking on something at regular intervals
19:37:27 <adas> there is an fpcomplete.com article on how to use the "persistent" library. An example in that article imports "Database.Persist.TH" But I installed the persistent library and am not able to import "Database.Persist.TH" although I can import everything else from the Database.Persist module.
19:37:56 <merijn> tabemann: "fmap Just youAction `orElse` return Nothing" <- voila, unblocking
19:38:17 <merijn> tabemann: So even if they just want to poll, that's trivially doable using orElse
19:39:18 <merijn> or, if your action is "STM ()" then it's just "yourAction <|> return ()"
19:40:22 <merijn> tabemann: Hell, you could just make the tryReadTMVar yourself using readTMVar + orElse
19:41:26 <tabemann> okay, I'm convinced
19:41:34 <tabemann> I'll get rid of the nonblocking API
19:41:54 <adas> anyone?
19:42:38 <barrucadu> adas: You need the persistent-template package for the template haskell stuff
19:43:16 <adas> barrucadu: isn't it supposed to be a part of the persistent library?
19:43:22 <adas> why are they in seperate modules?
19:43:37 <adas> :s/modules/packages
19:44:05 <barrucadu> I guess it's so you don't need to pull in the template-haskell package if you're not actually using it
19:45:24 <adas> barrucadu: thanks
19:51:20 * hackagebot yesod-auth 1.3.4.5 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.3.4.5 (GregWeber)
19:54:18 <merijn> adas: Because Template Haskell doesn't yet work well with cross-compilation and on non x86/x64 platforms
19:54:44 <merijn> adas: If you care about cross-architecture portability it can make sense to split TH off, additionally, TH is GHC only
19:55:53 <adas> merijn: oh.. that clarification made more sense.
20:16:21 * hackagebot jwt 0.4.1 - JSON Web Token (JWT) decoding and encoding  http://hackage.haskell.org/package/jwt-0.4.1 (StefanSaasen)
20:17:20 <chrisdotcode> Guys, is head O(n) or O(1)?
20:17:36 <vanila> chrisdotcode, it's O(1)
20:17:41 <chrisdotcode> thanks, vanila
20:17:47 <chrisdotcode> vanila: tail is O(n), then, right?
20:17:53 <vanila> tail is also O(1)
20:18:27 <chrisdotcode> vanila: You sure?
20:18:30 <vanila> es
20:18:31 <vanila> yes
20:18:38 <vanila> but keep in mind that's when these functions are applied to a list - when you applied head or tail to some complicated computations on a list that will trigger all that stuff to be computed before it do the pattern match for head
20:18:39 <chrisdotcode> Isn't it a linked-list, and doesn't it have to traverse the entirety of the structure?
20:18:48 <vanila> the definitions are as follows
20:18:52 <vanila> head (x : xs) = x
20:18:55 <vanila> tail (x : xs) = xs
20:19:09 <vanila> since it doesn't do any recursion or anything it's O(1)
20:19:12 <chrisdotcode> oh, wow
20:19:15 <chrisdotcode> I'm thinking of...
20:19:19 <chrisdotcode> uh, the opposite of head
20:19:21 <chrisdotcode> not tail
20:19:26 <exio4> last?
20:19:28 <chrisdotcode> last, was?
20:19:30 <chrisdotcode> yes, last.
20:19:32 <exio4> which is O(n)?
20:19:37 <chrisdotcode> slightly mis-matched names, IMO
20:19:41 <nshepperd> 'last' and 'init' are O(n), yes, and pure evil
20:19:53 <chrisdotcode> last is what I was looking for.
20:19:54 <chrisdotcode> thanks guys.
20:20:06 <nshepperd> well, init can be lazy, so it's not so bad, I think
20:21:42 <vanila> @src init
20:21:42 <lambdabot> init [x]    = []
20:21:42 <lambdabot> init (x:xs) = x : init xs
20:21:42 <lambdabot> init []     = undefined
20:22:03 <vanila> so head . init is O(1) thanks to lazyness
20:23:33 <chrisdotcode> (wish they all returned :: Maybe a)
20:23:54 <vanila> chrisdotcode, it would at least be useful to have those functions as well
20:24:03 <vanila> it's weird that they aren't standard
20:24:34 <theme2> HI
20:24:35 <theme2> hi
20:24:37 <vanila> hi
20:24:51 <theme2> Since when did I press the caps lock? :(
20:25:11 <theme2> I have a little question
20:25:22 <theme2> @eval let 2 + 2 = 5 in 2 + 2
20:25:45 <vanila> theme2, that redefines + to a new function which gives 5 when its inputs are pattern matched against 2 and 2
20:25:48 <theme2> > let 2 + 2 = 5 in 2 + 2
20:25:49 <lambdabot>  5
20:26:04 <theme2> vanila: what???
20:26:11 <vanila> hi
20:26:16 <theme2> > let 2+2 = 5 in 3+3
20:26:17 <lambdabot>  *Exception: <interactive>:3:5-11: Non-exhaustive patterns in function +
20:26:21 <theme2> ???
20:26:26 <theme2> what is going on here
20:27:04 <vanila> > let 2+2 = 5 ; 3+x = x in 3+3
20:27:05 <lambdabot>  3
20:27:09 <vanila> > let 2+2 = 5 ; 3+x = x in 3+7
20:27:10 <lambdabot>  7
20:27:14 <theme2> -_-
20:27:17 <vanila> > let f 2 2 = 5 ; f 3 x = x in f 3 7
20:27:18 <lambdabot>  7
20:27:20 <exio4> a new "+" function is defined with 2+2 = 5, but with all other possibles combinations, it is left undefined
20:27:25 <vanila> doesn't matter if you call if + or f or anything else
20:27:46 <theme2> > let 2 + 2 = 5 in 1+1+2
20:27:47 <lambdabot>  *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function +
20:28:19 <theme2> > let 2+2=5; x+y= x-(-y) in 1+1+2
20:28:20 <lambdabot>  5
20:28:25 <theme2> :/
20:28:47 <theme2> Haskell name resolution is weird
20:28:51 <vanila> no its not
20:29:19 <vanila> let <definition> in <body>   binds the name you defined for the scope of <body>
20:29:22 <theme2> well... writing 2 copies of 1 function is usually "overloading" in some languages
20:29:33 <vanila> it's called lexical scope
20:29:44 <exio4> > let 2+2=5; x+y = x Prelude.+ y in 2+3+4+5
20:29:45 <lambdabot>  14
20:29:50 <theme2> so I thought that defining a new "+" in haskell would just add a new pattern to try to match
20:29:56 <theme2> exio4: oh...
20:30:04 <theme2> it's not built in -_-
20:30:06 <exio4> > let 2+2=5; x+y = x Prelude.+ y in (1+1)+(1+1)
20:30:08 <lambdabot>  5
20:30:45 <theme2> > let pi = 3 in pi
20:30:47 <lambdabot>  3
20:31:06 <exio4> theme2: function definitions are "closed", after they are defined, they don't change
20:31:15 <theme2> ok... now we have the "Indiana Pi Bill"
20:32:04 <theme2> lol
20:33:46 <jle`> theme2: it's called shadowing
20:33:53 <jle`> (+) is not special syntax
20:33:56 <jle`> it's just a normal function
20:34:04 <theme2> jle`: Ah right
20:34:14 <jle`> defined in source code somewhere that you can actually look up :)
20:34:19 <theme2> A similar thing exists in other language, after all
20:34:31 <jle`> yeah, most languages have the concept of lexical scope
20:34:35 <exio4> if you are "bored", you can take https://www.coursera.org/course/proglang!
20:34:59 <exio4> it talks about lexical scope, scoping, you even "implement" it yourself!
20:35:03 <jle`> if you define a variable named x somewhere, and but then have a method call that has its own variable named x, refering to x in the function will refer to the x inside the lexical scope of the function
20:35:14 <theme2> btw that reminds me of something
20:35:20 <theme2> http://www.haskell.org/ghc/docs/7.4.2/html/libraries/ghc-prim-0.2.0.0/src/GHC-Prim.html
20:35:35 <jle`> in this case you're defining a new function called (+), and defining it such that 2 + 2 = 5.  and then using it with 2 and 2, to get 5.
20:35:36 <theme2> What are all those "let x = x in x"?
20:36:08 <exio4> > let x in x = x
20:36:09 <lambdabot>  <hint>:1:7: parse error on input â€˜inâ€™
20:36:18 <theme2> > let x = x in x
20:36:21 <lambdabot>  mueval-core: Time limit exceeded
20:36:28 <theme2> that's what I expected
20:36:29 <exio4> oh, got them wrong
20:36:30 <theme2> infinite loop
20:36:49 <jle`> :t let x = x in x
20:36:49 <theme2> infinite loop in http://www.haskell.org/ghc/docs/7.4.2/html/libraries/ghc-prim-0.2.0.0/src/GHC-Prim.html ?
20:36:50 <lambdabot> t
20:37:59 <theme2> I once looked in there, expecting to find something like "embedded C code"/"embedded assembly"
20:38:06 <theme2> But I found infinite loops O_o
20:38:25 <chrisdotcode> alternatively, pattern matching form:
20:38:30 <chrisdotcode> (+) 2 2 = 5
20:38:48 <chrisdotcode> whoops, didnt scroll down
20:38:49 <theme2> chrisdotcode: I already understood that
20:38:58 <chrisdotcode> replied to a comment much earlier
20:39:17 <chrisdotcode> theme2: so you're good?
20:39:26 <theme2> ???
20:39:41 <theme2> understood "after reading the explatations here"
20:40:01 <theme2> :t seq
20:40:02 <lambdabot> a -> b -> b
20:40:05 <theme2> > seq
20:40:06 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
20:40:06 <lambdabot>    arising from a use of â€˜M514313692558271758711880.show_M5143136925582717587...
20:40:06 <lambdabot>  The type variable â€˜b0â€™ is ambiguous
20:40:06 <lambdabot>  Note: there are several potential instances:
20:40:06 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
20:40:19 <theme2> > let x = x in x
20:40:23 <lambdabot>  mueval-core: Time limit exceeded
20:40:39 <theme2> but "seq = let x = x in x" in http://www.haskell.org/ghc/docs/7.4.2/html/libraries/ghc-prim-0.2.0.0/src/GHC-Prim.html
20:40:54 <carter> theme2: nope
20:40:59 <carter> thats just a stub
20:41:08 <carter> theme2: every compiler defined primop gets a dummy defn in that file
20:41:51 <jle`> `let x = x in x` is probably used because it can typecheck against any type
20:41:59 <theme2> Doesn't it enter an infinite loop or something when inlining?
20:42:15 <carter> theme2: nope
20:42:16 <carter> never usd
20:42:21 <carter> just dummy bodies
20:42:36 <carter> every op in the file is a GHC primop it knows how to compiler
20:42:39 <carter> *comple
20:42:47 <theme2> so "magic happens" in "GHC.Prim"?
20:43:16 <carter> theme2: hows & defined in C?
20:43:17 <carter> same idea
20:43:31 <carter> at some point, certain operations have to ahve special compiler knowledge
20:43:44 <theme2> carter: I thought it's defined inside the compiler
20:43:49 <geekosaur> you could say that, while it compiles most things to graphs for the graph reduction engine, it compiles GHC.Prim to direct instructions to that engine
20:44:01 <theme2> The idea of defining it in a library is absurd to me
20:44:05 <theme2> even as a stub
20:44:13 <carter> theme2: how else would you type check code? :)
20:44:26 <theme2> hmm
20:44:32 <carter> theme2: the file is generated from the primops file in the ghc code base
20:44:39 <geekosaur> it's not very absurd to me; it's just encapsulation
20:44:45 <carter> it lets us give docs / types to all the primops
20:44:51 <carter> in the same way as normal haskell code
20:44:54 <geekosaur> better than scattering it randomly all over the ghc code base
20:44:55 <theme2> If it's C/C++ I'd give function prototypes
20:45:05 <carter> theme2: so type signature
20:45:08 <carter> but no impl
20:45:13 <carter> like let x in x
20:45:16 <theme2> ok... same idea
20:45:17 <theme2> got it
20:45:18 <carter> :)
20:45:20 <carter> yeah
20:45:21 <carter> roughly
20:45:21 <jle`> sort of like a header file, huh?
20:45:30 <carter> no
20:45:33 <carter> header files are shitty
20:45:36 <jle`> ;_;
20:45:53 <carter> header files are the worst thing to happen to program modularity in the history of computing
20:46:05 <carter> the reason why c / c++ code bases are bnkers to build
20:46:10 <theme2> well... it probably increases compiling speed...
20:46:15 <carter> theme2: lol nope
20:46:19 <carter> actually makes it worse
20:46:30 <carter> C/ C++ headers work by copy and pasting into the importing module
20:46:55 <theme2> well... I guess the first compiler writers were either lazy or efficient
20:46:58 <merijn> Also known as "christ, why do my compile and link times suck"
20:46:58 <carter> no
20:47:09 <carter> theme2: this is not a matter of first compiler writers
20:47:15 <carter> its called the C / C++ writers
20:47:25 <carter> fortran and Pascal and Oberon and stuff
20:47:30 <carter> they dont have this problem
20:47:33 <jle`> i'd hardly call C compilers the first compilers :P
20:47:34 <carter> SML doesn't have this problem
20:47:36 <carter> yeah
20:47:51 <carter> jle`: but the problems have only persisted in that setting
20:48:50 <theme2> Well... the other way I could think of that has fast compile times is to pre-parse the function prototypes into a seperate file
20:49:01 <theme2> and read from that file when including/importing
20:49:19 <theme2> that's 2 steps
20:51:23 * hackagebot snaplet-amqp 0.1.2.0 - Snap framework snaplet for the AMQP library  http://hackage.haskell.org/package/snaplet-amqp-0.1.2.0 (ParnellSpringmeyer)
20:52:35 <carter> theme2: so like a module system
20:52:39 <carter> with module signatures?
20:53:02 <theme2> well... if you want fast compile times, what else?
20:56:23 * hackagebot snaplet-amqp 0.1.2.1 - Snap framework snaplet for the AMQP library  http://hackage.haskell.org/package/snaplet-amqp-0.1.2.1 (ParnellSpringmeyer)
20:56:55 <carter> theme2: thats all you need
20:56:59 <carter> proper module type signatures
20:57:05 <carter> C/C++ dont do that
20:57:17 <theme2> how does ghc do it?
20:57:23 <carter> ghc has module type sigs
20:57:39 <carter> but we inline a lot between modules to make things fast
20:57:47 <carter> theme2: most things will build a LOT faster at O0
20:58:40 <theme2> Is ghc optimizing by default?
20:58:59 <carter> when you do cli invokation is not
20:59:06 <carter> unless you do -O1 or -O2
20:59:11 <carter> but the deafult setting for optimization
20:59:18 <carter> in your ~/.cabal/config file
20:59:22 <carter> is optimization: True
20:59:26 <carter> which is -O1
20:59:36 <theme2> I've been always wondering why ghc takes quite a few seconds compiling a small piece of code
20:59:45 <carter> theme2: it does A LOT of optimizing
21:00:13 <theme2> As per https://www.haskell.org/ghc/docs/7.6.1/html/users_guide/options-optimise.html
21:00:22 <theme2> some flags are on by default
21:00:34 <theme2> such as "-fcse", "fstrictness"
21:00:36 <carter> yeah
21:00:45 <carter> basically untill you know better
21:00:47 <jamalsa> hello everyone, I have a newbie question about ghci
21:00:51 <carter> stick with O1 when you care about speed
21:00:59 <theme2> jamalsa: ask your question
21:01:03 <carter> and 00 when you wwant quick builds
21:01:07 <carter> jamalsa: bring it on
21:01:10 <carter> i love questions
21:01:17 <theme2> :D
21:01:23 * hackagebot aeson-qq 0.7.4 - JSON quasiquoter for Haskell  http://hackage.haskell.org/package/aeson-qq-0.7.4 (SimonHengel)
21:01:32 <jamalsa> I type 10.8 + 6.4 in ghci but it evaluate to 17.200000000000003 instead of 17.2
21:01:39 <jamalsa> why is it like that?
21:01:47 <theme2> jamalsa: It's called round-off error
21:01:53 <carter> jamalsa: you want rational numers
21:01:56 <carter> try
21:01:59 <augur> theme2: you want > not @eval
21:02:05 <augur> oh whoops. haha
21:02:07 <carter> > 10.8 + 6.4 :: Rational
21:02:08 <tabemann> question
21:02:09 <lambdabot>  86 % 5
21:02:09 <augur> scrolled up :(
21:02:19 <augur> this mouse is so sensitive
21:02:32 <tabemann> what happens if you try to kill a thread that is currently waiting on a socket in Network.Socket.recv?
21:02:33 <theme2> http://en.wikipedia.org/wiki/Round-off_error
21:02:53 <carter> theme2: i dont think jamalsa  needs to learn about floating point just yet :)
21:03:16 <carter> jamalsa: basically floating point style numbers can be either treated as Float, Double, or Rational
21:03:22 <theme2> http://floating-point-gui.de/
21:03:43 <carter> theme2: .... floating point is complicated, lets not bog them down with it ror now
21:03:52 <jamalsa> But why it is only that number? 10.8 + 6.3 or 10.9 + 6.3 give correct result
21:04:07 <theme2> jamalsa: it's never correct
21:04:11 <geekosaur> long story
21:04:12 <theme2> > 10.8+6.3
21:04:14 <lambdabot>  17.1
21:04:19 <theme2> > 10.8+6.3 == 17.1
21:04:21 <lambdabot>  True
21:04:23 <theme2> ???
21:04:33 <carter> :t 1.7
21:04:34 <lambdabot> Fractional a => a
21:04:37 <carter> hah
21:04:40 <theme2> > 10.8::Double+6.3::Double == 17.1::Double
21:04:42 <lambdabot>  <hint>:1:14: parse error on input â€˜6.3â€™
21:04:52 <carter> jamalsa: what ghci version are you at
21:04:54 <theme2> > (10.8::Double)+(6.3::Double) == (17.1::Double)
21:04:55 <lambdabot>  True
21:05:01 <theme2> huh?
21:05:03 <theme2> strange
21:05:13 <carter> > (10.8::Double)+(6.379::Double)
21:05:15 <lambdabot>  17.179000000000002
21:05:18 <carter> HAH
21:05:20 <jamalsa> 7.8.3 on Arch x86_64
21:05:23 <carter> ok
21:05:24 <theme2> maybe just by chance, they were equal
21:05:41 <theme2> rounding in the wrong way
21:05:45 <carter> jamalsa: basically floating point is a way of fitting fraction looking things into a small efficient thing
21:05:51 <carter> that computers can work on efficiently
21:06:02 <theme2> If you display to 2 digit precision, 0.999999999999 is displayed as 1.00
21:06:09 <theme2> I think that is the point
21:06:50 <theme2> from http://floating-point-gui.de/basic/ : "itâ€™s possible for rounding errors in the input numbers to cancel each other out"
21:07:05 <theme2> "In other cases like 0.1 + 0.3, the result actually isnâ€™t really 0.4, but close enough that 0.4 is the shortest number that is closer to the result than to any other floating-point number."
21:07:07 <wyager> What is an efficient mechanism to send data from one thread to *many* others? Split chans and TChans both have much too much overhead
21:07:28 <theme2> It also applies in c and most other programming languages
21:08:04 <theme2> something like "double x=0.0; while(x!=1.0) x+=0.1;" will most likely be an infinite loop in C
21:09:15 <carter> wyager: vs what
21:09:18 <jamalsa> so it means 0.4 displayed in screen is not really 0.4 but something close
21:09:37 <carter> jamalsa: not true
21:09:45 <theme2> jamalso: that's true
21:09:50 <theme2> carter: ???
21:09:56 <theme2> :/
21:10:03 <carter> are you sure that 0.4 isn't representable?
21:10:12 <theme2> carter: yes
21:10:20 <wyager> carter: Just in general. I would like to send a message from one â€œproducerâ€ thread to tens of thousands of â€œconsumerâ€ threads.
21:10:30 <theme2> well... at least as floating point
21:10:32 <wyager> I max out at about 10 threads right now
21:10:40 <carter> wyager: whats the use case
21:11:24 * hackagebot CCA 0.1.5 - preprocessor and library for Causal Commutative Arrows (CCA)  http://hackage.haskell.org/package/CCA-0.1.5 (PaulLiu)
21:11:25 <wyager> carter: There is no specific use case. This is just for fun, to see if I can
21:11:37 <jamalsa> ok thanks theme2 and carter for your answer :)
21:11:39 <carter> wyager: why not have them read from an ioref
21:11:45 <carter> jamalsa: basically floating point is complicated
21:11:51 <carter> but when it sneeded, its needed
21:12:01 <carter> jamalsa: when you dont need floating point, use rational numbers
21:12:05 <wyager> carter: I donâ€™t want one thread to block the others, so it must be a chan. Are there chans constructed from IORefs?
21:12:06 <carter> ::Rational
21:12:07 <jamalsa> ok
21:12:18 <wyager> i.e. one thread reading must not prevent others from reading
21:12:26 <carter> wyager: ohhh
21:12:32 <carter> @hackage unagi-chan
21:12:32 <lambdabot> http://hackage.haskell.org/package/unagi-chan
21:12:43 <carter> but thats not broadcast
21:12:50 <carter> broadcast is werid
21:12:59 <carter> wyager: you really just wanna synchronize
21:13:01 <wyager> Yeah, it must be a broadcast system
21:13:01 <carter> >?
21:13:07 <carter> why
21:13:20 <wyager> Carter: It need not be synchronized exactl
21:13:22 <wyager> *exactly
21:13:33 <wyager> I just need to propagate data to many threads as it is created
21:13:39 <carter> why
21:13:45 <carter> because of a burning need?
21:13:46 <carter>  :)
21:13:49 <wyager> Because thatâ€™s what I want to do for this project :)
21:13:53 <carter> whats the project do
21:14:02 <wyager> Send data from one thread to many :)
21:14:05 <carter> i can't help you get fast code if youre vague
21:14:23 <carter> :)
21:14:25 <carter> hrmm
21:14:28 <wyager> Isnâ€™t there some general advice?
21:14:33 <wyager> Let me give you an example for how this might be used
21:15:18 <wyager> A server accepts TCP connections (10s of thousands). Every time the producer thread makes a new message, all TCP clients get sent a copy of the message. I need a data structure to send the message from the producer thread to all the other ones
21:15:49 <carter> wyager: i'd just make a state variable
21:15:54 <carter> and have each worker reader the current state
21:16:24 * hackagebot snaplet-amqp 0.1.2.2 - Snap framework snaplet for the AMQP library  http://hackage.haskell.org/package/snaplet-amqp-0.1.2.2 (ParnellSpringmeyer)
21:16:27 <wyager> carter: That would be bad. You canâ€™t guarantee that a single thread wonâ€™t get blocked on a slow TCP request and either miss the state or block all the other threads
21:16:33 <wyager> Thatâ€™s why a FIFO is great here
21:16:36 <carter> IORef
21:16:37 <carter> read
21:16:39 <carter> no blocking
21:16:49 <carter> just have the action log be reaable
21:16:53 <carter> but only one person can append to it
21:16:59 <wyager> Yeah, and what happens if I overwrite the IORef before a thread finishes the last TCP send?
21:17:08 <wyager> Yeah, isnâ€™t there already a data structure for that?
21:17:09 <carter> so?
21:17:13 <wyager> I mean, you just described a chan
21:17:16 <carter> nope
21:17:18 <wyager> Then the thread misses a message...
21:17:21 <carter> global IORef
21:17:30 <carter> how would it miss a message
21:17:55 <carter> it read the current pure value in the ioRef (which would be a list of all the messages or whatever)
21:17:59 <carter> and does something
21:18:28 <wyager> Letâ€™s say the producer is sending 500 messages/sec. Average time required to send TCP message is .5ms. On average, itâ€™s fine. But occasionally, it takes 10ms to send a TCP message. In those cases, the sender misses about 5 messages from the producer
21:18:30 <wyager> no bueno
21:18:45 <carter> no
21:18:51 <carter> youre confused
21:19:02 <wyager> In what way? :)
21:19:07 <carter> youre not doing any TCP when talking about threads
21:19:30 <carter> those threads may be doing TCP to some otehr bits of teh world
21:19:32 <carter> sure
21:19:33 <wyager> I certainly am :) Each consumer thread has a TCP connection
21:19:37 <carter> i know
21:19:50 <carter> but that has nothing to do with how they consume messages from another thread
21:20:37 <wyager> If a thread blocks on TCP, and thereâ€™s no FIFO queue, you canâ€™t guarantee that a thread will read the newest value from the IORef before the TCP request completes
21:20:52 <carter> wyager: no
21:21:01 <carter> you have the ioref writer
21:21:07 <carter> cons the newest message ontop
21:21:08 <carter> :)
21:21:41 <wyager> Is this not how most Chans work?
21:21:51 <carter> i'm talking about one ioref
21:21:54 <carter> not this chan stuff
21:21:59 <wyager> Oh
21:22:19 <wyager> OK, alternate issue then
21:22:28 <wyager> Letâ€™s say the following steps happen
21:22:43 <wyager> TCP thread grabs latest value from IORef
21:22:53 <wyager> latest value is d:e:f...
21:23:02 <wyager> where d is the latest message (consed on)
21:23:06 <carter> sure
21:23:08 <wyager> It does a slow TCP request
21:23:16 <wyager> and then it grabs the newest value from the IORef
21:23:18 <wyager> which is now
21:23:23 <wyager> a:b:c:d:e:f...
21:23:26 <wyager> and the top value is a
21:23:30 <carter> sure
21:23:32 <wyager> but the thread never grabbed b or c
21:23:37 <carter> wyager: sooo
21:23:37 <wyager> It just skipped over them
21:23:40 <carter> wyager: thats ok
21:23:45 <carter> because you actually shouldn't be doing it this way
21:23:49 <wyager> I know :)
21:24:00 <wyager> Thatâ€™s why :p
21:24:02 <carter> wyager: you should instead have an ioref to a model of the world
21:24:15 <carter> and just make decisions based upon current model of the world
21:24:22 <carter> not monoidally merging messages
21:24:25 <wyager> That is not a very precise explanation
21:24:36 <carter> wyager: let me be more precise
21:24:43 <carter> i'm writing a haskell program for a friend
21:25:00 <carter> that should be doing 1-10k TCP requests per second with a < 50ms response latency
21:25:05 <carter> to bid in auctions in real time
21:25:15 <carter> each bidder request
21:25:32 <carter> i dont care about how much i've spent on individual previoius requests
21:25:47 <carter> just how much budget is left
21:26:48 <carter> wyager: so instead of having 1 to many
21:26:52 <carter> i have many to 1
21:26:57 <carter> which is just fifo
21:27:06 <carter> which then use to update what the current budget it
21:27:09 <carter> *is
21:27:15 <wyager> That is how 1-to-many chans work, is it not?
21:27:20 <wyager> Just a fifo that everyone reads?
21:27:21 <carter> no
21:27:44 <carter> well
21:27:47 <carter> chans confuse me
21:27:51 <carter> but you also said it was too slow :)
21:28:09 <wyager> I am almost certain I read some explanation of chans that talked about having a â€œholeâ€ at the end of a cons-list, and sending a message to the chan was just â€œfillingâ€ the hole at the end of the cons list
21:28:19 <wyager> So Iâ€™m pretty sure youâ€™re just describing a chan
21:28:22 <carter> no
21:28:28 <carter> i said many to 1
21:28:30 <carter> not 1 to many
21:28:36 <wyager> It is the same thing here
21:28:38 <carter> nope
21:28:41 <carter> they are not the same
21:28:53 <wyager> You say â€œmany to 1â€ meaning â€œmany threads reading a value produced by 1"
21:28:58 <carter> no
21:28:59 <wyager> this is how 1-to-many chans work under the hood
21:29:01 <carter> no
21:29:03 <carter> nononnon
21:29:13 <carter> i said quite the opposite
21:29:30 <carter> i was proposing a wholey different architecture
21:29:45 <carter> many writers into a fifo queue that one thread accumulates
21:29:50 <carter> into a state descriptor
21:29:52 <wyager> Gotcha
21:29:58 <carter> that the othe threads read from to get the current state
21:30:07 <carter> so theres no "did i miss an update message"
21:30:14 <carter> because they're just using the current state of the world
21:30:19 <carter> read from the IORef
21:30:28 <wyager> Well, I donâ€™t need the consumer threads to modify the state. Ever
21:30:37 <wyager> So I donâ€™t see how that could be productive in my example
21:30:44 <carter> they jsut read the ioref
21:30:45 <carter> never modify
21:30:53 <wyager> Which you proposed to be a const-list
21:30:59 <carter> no
21:31:00 <wyager> for which I explained why it would not work
21:31:02 <carter> thats what you wanted
21:31:03 <wyager> *cons
21:31:06 <wyager> No
21:31:11 <carter> whatever, i'm off
21:31:13 <carter> happy hacking
21:31:21 <wyager> cheers
21:31:22 <carter> concurrent data structures are a fiddly place
21:31:31 <carter> do share what works once youre done :)
21:34:58 <wyager> Anyone else have suggestions? I donâ€™t think this is nearly a complicated enough request to warrant that back-and-forth: I have one thread, occassionally producing values. I want lots of other threads to read those values at their liesure.
21:35:24 <carter> wyager: before i forget, was this mvar chan or stm chan?
21:35:39 <wyager> I tried stm
21:35:53 <carter> try the other too!
21:36:14 <wyager> will try now
21:37:01 <carter> i think on single writer many reader workloads, mvar/Ioref based data structures currently exhibit less contention
21:37:10 <wyager> oh excellent
21:37:30 <carter> but thats just because STM currently is too conservative about the transactions
21:37:33 <carter> but i could be totally wrong
21:37:38 <carter> and have no idea what i'm talking about
21:45:07 <wyager> Using MVar-based structures is still pretty bad
21:45:11 <wyager> No noticeable improvement
21:45:57 <wyager> Iâ€™m surprised there arenâ€™t a bunch of recommended ways to do this. This seems like an obvious application of fast green threading
21:47:19 <error424> How would you do it in another language?
21:47:30 <carter> wyager: oooo
21:47:44 <carter> wyager: i know whats going on
21:48:17 <carter> wyager: you do know that for non blocking operations, unless a GC happens, the default context switching rate is 20ms?
21:48:23 <carter> if you enable RTS ops
21:48:31 <carter> you probably want to do -Cs
21:48:40 <wyager> What does that do?
21:48:54 <carter> s= number of seconds before you context switch
21:49:01 <carter> default is 0.02
21:49:18 <carter> if you do -C it switches every time it can
21:49:36 <carter> you could also compile your application with -fno-omit-yields
21:49:50 <carter> wyager: theres more youc an do
21:50:01 <carter> like if you allocating a lot, that can mess wit things
21:50:16 <wyager> OK, so I tried -C
21:50:33 <wyager> No big change. Still baloons to 400% CPU usage at 6 consumer threads
21:50:48 <carter> ummm duh
21:50:53 <wyager> Moving about 750KiB/sec through the threads
21:50:56 <wyager> Which isnâ€™t a whole lot
21:51:01 <carter> youre not doing blocking operations
21:51:04 <carter> well
21:51:07 <carter> also you've not shared the code
21:51:12 <carter> so i cant help no more
21:51:14 <carter> :)
21:51:28 <carter> wyager: write up what you've tried and email cafe for feedback
21:51:36 <carter> 1am aint a good hour to get suggestions :)
21:52:16 <Hijiri> should I be putting yield in my looping threads?
21:52:23 <Hijiri> and if so, do I need them in the main thread too
21:52:23 <wyager> I am sort of surprised there isnâ€™t a haskell wiki article called â€œSo you want to send stuff to a lot of threadsâ€
21:52:39 <wyager> This seems like kind of a trivial question
21:52:41 <carter> wyager: because every concurrent app is different
21:52:47 <carter> theres no magic one true pattern shit
21:52:51 <wyager> This is a very generic concurrency problem
21:53:01 <wyager> There is nothing special about it
21:53:14 <carter> wyager: how are you measuring perf?
21:53:20 <carter> cpu utilization is the wrong measure
21:53:35 <wyager> Spawn the server, connect to it with nc a bunch of times, look at CPU and RAM usage
21:53:51 <carter> oh
21:53:56 <carter> yeah, thats the wrong measure
21:54:04 <carter> you shoud llook at latency/ throughput
21:54:22 <wyager> I donâ€™t care about latency
21:54:29 <wyager> And cpu usage scales with throughput
21:54:35 <carter> not necessarily
21:54:40 <wyager> Yes, I have tested this
21:54:47 <wyager> These are correlated issues
21:54:52 <carter> nope
21:54:59 <carter> thats not always true
21:55:03 <wyager> It is true here
21:55:06 <carter> nope
21:55:39 <wyager> How can you possibly say that after complaining about not knowing whatâ€™s up because you havenâ€™t seen my code?
21:55:53 <wyager> It is extremely obvious to me that this is the case
21:55:58 <carter> why
21:58:36 <wyager> Because there is an obvious linear correlation between the two
21:58:51 <wyager> CPU usage = scale factor * number of connected TCP clients * throughput
21:59:16 <wyager> I have verified this experimentally, and there is no reason this doesnâ€™t make sense
22:01:09 <wyager> I am confused as to why you were so insistent otherwise
22:08:45 <wyager> Alright Iâ€™m going to bed. Thanks :)
22:18:35 <trollolo> lots of haskell programmers...
22:18:45 <trollolo> :-)
22:22:21 <trollolo> are most people here professionals?
22:22:39 <MP2E> there's a good mix
22:23:12 * kuyatzu is not
22:23:31 <MP2E> I'm a self taught coder that just happens to love the language :P
22:24:00 <MP2E> there are academic types, and professionals, most people in the industry don't have one language they work with, instead they usually work with multiple
22:24:10 <exio4> aren't all coders actually "self-taught"?
22:24:44 <exio4> I don't know any _good_ programming course that teaches you how to program in a language but mainly "abstract" concepts!
22:25:45 <MP2E> right.. it wasn't to say "I didn't have any help" it was to say "I'm neither a professional nor in academia"
22:25:53 <MP2E> lol
22:26:19 <MP2E> just a hobbyist that is a fan of the language, anyway
22:26:20 * MP2E shuts up now
22:27:29 <theme2> Excuse me, I'm having problems trying to profile my program
22:28:07 <theme2> I compiled it with profiling
22:28:22 <theme2> wait a sec, I'm stupid
22:28:33 <theme2> I wrote "-RTS" when I meant "+RTS"
22:30:16 <theme2> How do I force ghc to recompile everything from scratch?
22:30:44 <trap_exit> rm -f *.hi *.o; make
22:30:49 <luite> -fforce-recomp
22:30:52 <trap_exit> or even better
22:30:54 <trap_exit> touch **/*.hs; make
22:31:05 <trap_exit> luite : !
22:31:20 <mauke_> who uses make?
22:31:37 <LordBrain> what's wrong with make?
22:31:51 <theme2> luite: I already used that flag
22:32:06 <theme2> I guess my problem is somewhere else
22:32:22 <mauke_> LordBrain: it's rarely needed with haskell
22:32:28 <theme2> Is "-fprof-auto" what I need to compile with profiling?
22:32:36 <theme2> I suspect that I'm missing another flag
22:32:39 <LordBrain> depends what you mean by rare
22:33:01 <solatis> about just as rare as cabal being used for building C projects... ;)
22:33:02 <exio4> theme2: and the problem is...?
22:33:43 <theme2> exio4: It seems like my program doesn't accept "+RTS -p" as valid arguments
22:34:22 <theme2> I'm trying to profile my program
22:34:54 <luite> theme2: -prof
22:35:06 <LordBrain> sometimes you need more control over the build than a cabal file gives, and make gets the job done pretty well
22:35:07 <theme2> luite: doesn't work
22:36:18 <theme2> -_-
22:36:28 * hackagebot esqueleto 2.0.0 - Type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-2.0.0 (FelipeLessa)
22:36:30 * hackagebot tickle 0.0.3 - A port of @Data.Binary@  http://hackage.haskell.org/package/tickle-0.0.3 (TonyMorris)
22:37:52 <theme2> luite: is it "+RTS -prof"?
22:37:53 <exio4> theme2: this works for me: ghc fib.hs -fforce-recomp -fprof-auto -prof
22:38:12 <theme2> ah... compiling stage
22:38:43 <theme2> whoops
22:38:58 <theme2> "Could not find module `Data.Numbers.Primes'"
22:39:00 <theme2> what is this?
22:39:58 <theme2> This error message shows up only after I add -prof
22:40:06 <lambda> theme2, that's a package that you can get from Hackage: cabal install primes
22:40:38 <theme2> lambda: got "All the requested packages are already installed"
22:40:51 <mauke_> looks like you didn't enable profiling in your cabal config
22:40:56 <theme2> ???
22:40:59 <theme2> how?
22:41:14 <theme2> -_-
22:41:31 <Partial_1mmersio> :P
22:41:33 <Partial_1mmersio> whoops
22:41:37 <Partial_1mmersio> nick length limit
22:50:43 <theme2> Excuse me, how do I enable profiling in my cabal config?
22:54:20 <erikd> theme2: 'grep profil .cabal/config' and you should see "-- library-profiling: False". change False to True and remove the '-- ' at the start of the line.
22:56:18 <theme2> thanks
23:00:36 <theme2> heh... my program is currently using 100% of one of my CPUs
23:00:55 <theme2> Something definitely is going wrong in my program
23:01:29 * hackagebot whois 1.2.2 - WHOIS client library.  http://hackage.haskell.org/package/whois-1.2.2 (RickyElrod)
23:01:31 * hackagebot blaze-builder 0.3.3.4 - Efficient buffered output.  http://hackage.haskell.org/package/blaze-builder-0.3.3.4 (SimonMeier)
23:02:05 <theme2> Excuse me, how is it possible that my program used 111 GB?
23:02:11 <theme2> I don't have that much ram
23:02:17 <theme2> total alloc = 111,303,641,976 bytes  (excludes profiling overheads)
23:02:29 <kadoban> That doesn't mean it was all allocated at once.
23:02:35 <theme2> ah... right
23:03:20 <theme2> Does "entries" in the .prof file mean the number of times a function is called?
23:03:47 <theme2> If yes, one of my functions got called 868 million times :/
23:05:40 <jle`> theme2: congrats :)
23:06:05 <theme2> but 111 GB still seems to be at the wrong scale
23:06:38 <exio4> theme2: why?
23:07:26 <theme2> That function is pretty short
23:07:41 <theme2> It shouldn't allocate that many bytes, I hope
23:07:52 <theme2> It does some deep recursion, though
23:08:07 <exio4> you return a new "object", remember!
23:08:25 <theme2> It returns Bool
23:08:27 <theme2> :/
23:10:46 <theme2> There goes one of my CPUs again
23:12:48 <theme2> Heap profile is not helpful at all...
23:13:09 <theme2> got some jagged lines going from left to right
23:13:22 <Axman6> theme2: Haskell programs tent to allocate a lot of data. luckily a) most of it disappears very quickly, and b) allocation is extremely cheap (bump pointer allocation almost all the time)
23:14:01 <theme2> What is "ARR_WORDS"?
23:14:29 <shachaf> It's a constant that's only used on Talk-Like-a-Pirate Day.
23:14:32 <theme2> I'm pretty sure I didn't use an array or something
23:14:47 <theme2> Half of the memory used by ARR_WORDS
23:14:51 <theme2> and half used by Set
23:15:19 <goglosh> shachaf lol
23:16:26 <Axman6> "Yarrrr, de impossible 'appened, tell de captain!"
23:16:55 <theme2> Also, I didn't use any features that advanced
23:17:13 <theme2> so what is this "MUT_ARR_PTRS_CLEAN" doing in my heap profile?
23:17:26 <theme2> and what is "->Any"
23:17:34 <Axman6> no idea without seeing the code and knowing what you're doing
23:17:42 <Axman6> and how you're compiling
23:18:11 <theme2> Compiling "ghc -O2 -fprof-auto -prof calcRing.hs -o profCalcRing -fforce-recomp"
23:19:48 <theme2> I've imported "Data.Numbers.Primes (isPrime)", "Data.Foldable as Fold (any)", "Data.Set as Set","Control.Monad (unless, forM_)"
23:20:00 <theme2> does any of them use some sort of arrays?
23:20:08 <int-e> prime sieve
23:20:22 <theme2> eh?
23:21:18 <theme2> I guess I should force my prime sieve to what I need first :/
23:21:23 <int-e> no, it's not Data.Number.Primes.
23:21:36 <theme2> ???
23:21:57 <int-e> theme2: it's not array based, interestingly enough.
23:22:06 <theme2> O_o
23:22:56 <theme2> I did expect "Set" to use a lot of memory, but I don't know what was "ARR_WORDS"
23:23:19 <int-e> (assuming it's from https://hackage.haskell.org/package/primes-0.2.1.0)
23:23:45 <dhrosa> how do I take advantage of other monads besides Identity with Parsec?
23:23:48 <theme2> it is from there
23:23:52 <dhrosa> I want to use Writer and keep track of stuff
23:24:02 <theme2> dhrosa: monad transformers?
23:24:11 <theme2> that's pretty hard, though
23:24:36 <merijn> theme2: Are you using vectors?
23:24:40 <theme2> nope
23:24:49 <theme2> nothing advanced here
23:25:15 <theme2> The most advanced thing is probably passing "Set"s around in recursion
23:25:24 <kadoban> Hmm, I guess hackage documentation is broken currently or something? Darn. I know there was an easy way in parsec to do that, but I can't remember offhand. You have to just look at what the usual Parser type is defined as, and replace it with your own I believe
23:25:30 <merijn> mutable array? those come to mind first when you mention 'MUT_ARR_PTRS_CLEAN', although ByteString is a source of ARR_WORDS, in my experience
23:25:36 <int-e> theme2: nothing of that is using arrays per se
23:25:56 <theme2> merijn: I don't even know how to use a mutable array
23:26:28 <int-e> right, MUT_ARR_PTRS_CLEAN would be amutable array of haskell objects. IOArray a or STArray s a, or perhaps some vector thing.
23:26:37 <dhrosa> kadoban: I understand sticking in Writer instead of Identity into the ParsecT type signature, but I don't understand where in the process I can take advantage of the monad
23:26:43 <int-e> I'd suspect a hashtable
23:26:43 <dhrosa> where I can insert logging information
23:26:45 <theme2> I don't know how to use IOArray or STArray
23:27:11 <int-e> theme2: well, somebody does :P
23:27:30 <kadoban> Ah. Hmm, I don't recall sorry :-/ I swear I've done it, but I have no memory of having to do something extra to use it.
23:27:45 <theme2> afk for now
23:27:49 <theme2> back later
23:28:05 <int-e> theme2: I think we need to know more about your code to help
23:29:07 <jle`> if you put Writer into ParsecT, then you can use `lift` to do logging stuff, and then when you runParser or what have you, you'd get (l, Either ParseError a)
23:29:28 <jle`> or if ParsecT is a MonadWriter instance then you do'nt even need to manually lift
23:30:19 <Summit01> as a guy who havent touched haskell in years
23:30:29 <Summit01> can anyone point me to the right direction here:
23:30:29 <Summit01>  f a [b] where f is (a->b)
23:30:37 <Summit01> I need to apply all the elements of b to the function f
23:32:13 <dibblego> Summit01: I think you mean, you need to write a function with the type (a -> b) -> a -> [b]
23:32:15 <kadoban> Summit01: If I'm understanding you right, that doesn't look like it's possible with the types you've mentioned...  Anyway, it sounds like the 'map' function you're looking for if that helps.
23:32:29 <jle`> if you have an (a -> b), you can apply it to an [a] by using `map`
23:32:33 <dibblego> (and if so, that is not the same as what kadoban said)
23:32:52 <dibblego> if it is not homework, then there is a function that does this already
23:32:57 <jle`> map turns an (a -> b) into an ([a] -> [b])
23:33:04 <jle`> so you are good to go
23:33:16 <dibblego> well, if not homework, then sequence
23:33:25 <dibblego> if homework, then maybe write it out by hand
23:33:43 <Summit01> no worries not homework :)
23:33:49 <dibblego> sorry that is not sequence
23:33:55 <Summit01> just trying to get back to haskell
23:33:56 <jle`> can you write out your question in types?
23:34:12 <jle`> i feel like you're mixing up types and values in your description possibly, and it's slightly confusing :)
23:34:26 <dibblego> [a -> b] -> a -> [b] is sequence
23:34:48 <jle`> you might say you want to apply an (f :: a -> b) to (xs :: [a]) to get (ys :: [b]), so you want an (a -> b) -> [a] -> [b], in that case
23:36:29 <dibblego> "(f -> a -> [b] where f is (a -> b))" is a possible interpretation
23:40:40 <augustl> programmed for haskell for the first time for a couple of hours yesterday. All my dreams tonight was about type systems, and classifying everything that happened with types. It has begun..
23:44:17 <dibblego> Summit01: what is the exact requirement?
23:46:28 <cydd> hi
23:50:16 <Hijiri> I never remember my dreams because I'm so sleep deprived
23:51:15 <jfeltz> if I've never had to use a custom hash-table, as in, ever, does that mean that I'm not a serious dev?
23:51:30 <merijn> naah
23:51:34 <merijn> hashtables are pretty bad
23:51:51 <merijn> O(n) lookup, worst case
23:52:01 <merijn> Haskell's Map is O(log n) worst case
23:52:15 <jfeltz> I recently reviewed at the O(1 + load-factor) for search/insert that my CS prof's masturbate over, and my reaction is "meh"
23:52:29 <jfeltz> but apparantly alot of interviewers want knowledge in them :(
23:53:02 <merijn> jfeltz: Really? I've only ever been asked "why would a hash table be a bad idea here?"
23:53:09 <AshyIsMe> choosing the correct data structure is 99% of the time far more important that optimising the particular implementation
23:53:19 <dibblego> I refuse jobs that do that kind of thing — highly recommended
23:53:38 <jle`> augustl: :P
23:55:02 <trap_exit> if I use deepseq together with catch, can I catch all exceptions?
23:55:11 <trap_exit> i.e. not catching all exceptions = due to thunking
23:55:18 <trap_exit> but if I deepseq, I can force all the computations
23:57:30 <jle`> exceptions that can occur in the process of evaluation?
23:57:34 <jle`> inside IO?
23:58:53 <trap_exit> outside of IO
23:58:59 <trap_exit> things like "let (Just x) = Nothing"
23:59:12 <trap_exit> or more realistically "let (Just x) = Map.lookup .... "
23:59:46 <jle`> remember that Exception doesn't really make sense outside of IO
