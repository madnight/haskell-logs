00:00:14 <merijn> NonEmpty just has the one datatype "data NonEmpty a = a :| [a]"
00:00:47 <bitemyapp> merijn: right.
00:02:30 <dfeuer> merijn, are you drunk, or asleep, or is there something very deep you're trying to get at?   Your data Message = Foo ByteString | Bar [ByteString]  allows empty messages, and allows two representations of single-string messages.
00:03:02 <merijn> dfeuer: Not if you wrap them with smart constructors
00:03:59 <merijn> Anyway, I'm not sure, it seemed a sensible question a few minutes ago
00:06:35 <dfeuer> That ... doesn't make sense. But another option is data L v a where {Nil :: L Empty a; Cons :: a -> L o a -> L NotEmpty a}
00:06:57 <dfeuer> Or something like that. I'm not drunk, but I am tired, so that could be off.
00:07:49 <mariomystic> Hey.. I have a class like this `class ( Id (a Foo) ~ (k, a Bar) ) => Biz a` where `Id` is an associated type of another class. However it complains about type k. Can I do existential quantification in class constraints?
00:18:38 <nshepperd> wouldn't you use newtype Message = Message (NonEmpty Bytestring) if you need it to be one or more bytestrings
00:19:49 <merijn> nshepperd: How does that make anything better?
00:20:33 <nshepperd> I dunno, but it's the obvious thing to do
00:20:44 <merijn> The problem with NonEmpty is that it considers the mandatory item the "first" item, whereas semantically the "last" item is mandatory
00:21:22 <dfeuer> merijn, did you see my GADT version, where L NotEmpty is the type of non-empty lists?
00:21:57 <merijn> dfeuer: Yeah, but I have to think about how that affects the rest of my code or if that even makes sense
00:22:27 <nshepperd> what's the difference, apart from the fact that `last` is O(n) for a NonEmpty
00:23:25 <dfeuer> merijn, in compiled code, you can actually unsafeCoerce# it to a list ... shady!
00:23:44 <shachaf> merijn: Semantically? They're isomorphic.
00:24:21 <dfeuer> But practically, using NonEmpty lets you use all the stuff edwardk already wrote!
00:24:23 <shachaf> dfeuer: No you can't?
00:24:40 <dfeuer> shachaf, try it :)
00:24:41 <shachaf> Oh, you're talking about a GADT, not NonEmpty.
00:24:44 <dfeuer> Yes.
00:24:56 <dfeuer> NonEmpty is a different beast.
00:25:03 <shachaf> If [] had its constructors in a different order you might be able to unsafeCoerce NonEmpty to []
00:25:25 <shachaf> @quote unsafeCoerce
00:25:26 <lambdabot> cmccann says: someone should implement a dependently-typed unsafeCoerce in Agda, you'd have to provide a proof that the coercion is invalid
00:25:32 <shachaf> @quote unsafeCoerce
00:25:32 <lambdabot> ghc says: Dangerous-looking argument. Probable cause: bad unsafeCoerce#
00:25:39 <shachaf> Hmph.
00:26:09 <merijn> shachaf: I mean as user reading it
00:26:31 <shachaf> merijn: You don't like having to write code that handles [].
00:26:38 <dfeuer> I would really like to be able to declare a type to be represented by a single other one in a simple way so that such things could be done safely, but edwardk says it just ain't gonna happen :-/
00:26:49 <merijn> shachaf: huh, how does that relate to the issue?
00:27:09 <shachaf> That's my guess of what you mean.
00:27:44 <merijn> shachaf: I have a network protocol which sends 0 or more optional ByteString followed by 1 mandatory ByteString
00:27:54 <merijn> shachaf: So lots of manipulation prepends things
00:28:04 <dfeuer> It would be so nice ...     class Represent new old | new -> old where getRepresentation :: new->old   and then the instance declarations would be pure magic.
00:28:23 <merijn> My initial idea was "data Message = Message [ByteString] ByteString" and I was just asking for opinions/inspiration
00:28:37 <shachaf> It doesn't sound particularly nice.
00:28:41 <merijn> shachaf: The way the NonEmpty data constructor seems really inconvenient for manipulating prefixes
00:28:50 <shachaf> merijn: OK, I see. I didn't read the beginning.
00:29:00 <shachaf> Yes.
00:29:24 <capisce> what's the way to refer to the return function of a given monad?
00:30:02 <merijn> capisce: "return in the X monad" or something along those lines
00:30:20 <dfeuer> return :: a -> IO a
00:30:26 <capisce> right
00:30:34 <dfeuer> return :: a -> [a]
00:30:49 <nshepperd> well, you can use the cons / uncons functions instead of the data constructor
00:31:01 <capisce> dfeuer: that's what I was looking for, thanks
00:31:32 <dfeuer> > rettt
00:31:35 <lambdabot>  Return to sender. Address unknown. No such number. No such zone.
00:32:05 <nshepperd> but if the final "mandatory" bytestring has some semantic meaning separate to the other parts, then by all means it makes sense for your message to be Message { parts :: [ByteString], checksum :: ByteString } or whatever
00:32:54 <merijn> nshepperd: Mostly it's just "the message that terminates the set", but as I said lots of stuff manipulates the front, so NonEmpty seems particular annoying for that
00:47:19 * hackagebot fay 0.20.1.4 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.20.1.4 (AdamBergmark)
01:44:43 <edlinde> >@src Maybe
01:45:01 <jle`> @src Maybe
01:45:01 <lambdabot> data Maybe a = Nothing | Just a
01:45:14 <edlinde> thanks
01:45:31 <edlinde> was just wondering how best I can detect whether something is a concrete type?
01:45:40 <jle`> define "concrete type"
01:45:42 <edlinde> so if it cannot take any type parameter
01:45:47 <edlinde> is that good enough?
01:45:52 <jle`> define "detect" :)
01:45:55 <edlinde> like Int?
01:46:02 <edlinde> cmon man :)
01:46:08 <jle`> i mean...on ghci?
01:46:11 <jle`> you can use :k for that
01:46:14 <edlinde> yep
01:46:16 <jle`> in a program?
01:46:20 <jle`> not sure if you can
01:46:27 <jle`> except at compile-time
01:46:29 <edlinde> nah I was just thinking more like.. when I am reading the code snippets in LYAH
01:46:33 <jle`> ah
01:46:40 <jle`> yeah, we have the concept of kinds for that
01:46:47 <jle`> :k Int
01:46:48 <lambdabot> *
01:46:50 <edlinde> I want to know that I am able to figure out that this type is concrete or not
01:46:51 <jle`> :k Maybe
01:46:51 <lambdabot> * -> *
01:47:02 <jle`> values have to be types of kind *
01:47:08 <edlinde> just thinking of simple ways to figure this out
01:47:10 <jle`> "fully saturated" types, perhaps?
01:47:14 <jle`> :k Maybe Int
01:47:15 <lambdabot> *
01:47:26 <edlinde> what is a fully saturated?
01:47:31 <jle`> btw, the word "concrete type" has fallen out of favor a bit in the past year or two, just fyi
01:47:40 <jle`> meaning it doesn't need any more type parameters
01:47:40 <edlinde> meaning its fully applied? and cannot take one param?
01:47:43 <edlinde> ok
01:48:02 <edlinde> jle`: ah I see.. so how should I refer to it then?
01:48:19 <jle`> fully applied/fully saturated is one way.  the others are escaping my mind at the moment
01:48:34 <edlinde> ok yeah fully applied makes sense
01:48:36 <jle`> the thing is that concrete type can also imply monomorphic types
01:48:45 <edlinde> except does it make sense to call “Int” fully saturated?
01:48:48 <jle`> and some other things too
01:48:56 <jle`> hm...i think it does :)
01:49:00 <edlinde> ok
01:49:03 <edlinde> if you say so :)
01:49:17 <edlinde> thanks will keep that in mind
01:49:27 <jle`> some people use concrete to mean monomorphic, so there is some confusion there
01:49:35 <jle`> (a -> b) vs. Int -> Double
01:49:50 <edlinde> ok
01:50:10 <nilg> how to have my program take less RAM? (-O SOMETHING would be great, I don't care if it runs slower)
01:50:40 <nilg> ghc -O TAKE_LESS_RAM_PLEASE
01:51:17 <edlinde> do you know who the LYAH author is?
01:51:24 <edlinde> I think there might be a small type
01:51:34 <edlinde> jle`: would you mind confirming it for me?
01:51:59 <edlinde> In http://learnyouahaskell.com/making-our-own-types-and-typeclasses#kinds-and-some-type-foo
01:52:06 <pantsman> nilg: http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html
01:52:17 <edlinde> It says: Let's apply the type parameter to Maybe and see what the kind of that type is.
01:52:32 <edlinde> but I think it meant to say … Let's apply the type parameter to “Maybe Int” and see what the kind of that type is.
01:52:38 <edlinde> is that right?
01:54:19 <jle`> the author is on the website, but it might be worth noting that he has fallen almost completely off the grid since the publication of his book
01:54:27 <Taneb> edlinde, hmm, to me it feels like it should me Let's apply Maybe to the type parameter etc
01:55:50 <edlinde> jle`: ah thats a shame
01:56:20 <jle`> he is talking about taking Maybe and applying it to Int, to get Maybe Int
01:56:21 <edlinde> ah maybe it does make sense
01:56:29 <edlinde> yeah got it now
01:56:33 <jle`> kind of like taking the function Just and applying it to 5, to get Just 5
01:56:35 <edlinde> I misread it :)
01:56:39 <edlinde> my bad
01:56:42 <jle`> np :)
02:27:46 <poutsi> hey, where does one submit bug reports for haskell.org site content? the topic eludes to some sorta infrastructure problems but this is not it
02:28:29 <nilg> Woohoo, using +RTS -c -RTS has substantially reduce the memory usage of my program but I still need to reduce it further, any idea?
02:40:49 <splintax> nilg: http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/prof-heap.html ?
02:42:56 <yyttr3> I have a question about an instance of Applicative i'm trying to create
02:44:38 <yyttr3> I have two new types  Vector a = Vector [a] and Matrix a = Matrix [Vector a], Vector is a Functor,Applicative,Monoid,Foldable. I'm trying to turn Matrix into an applicative is a bit difficult
02:46:32 <nilg> turns out in my case -O2 is good enough to optimize RAM! No need to use +RTS -c -RTS even, thanks guys for the help
02:47:33 * hackagebot hmatrix 0.16.0.5 - Numeric Linear Algebra  http://hackage.haskell.org/package/hmatrix-0.16.0.5 (AlbertoRuiz)
02:52:34 * hackagebot hmatrix-glpk 0.4.0.2 - Linear Programming based on GLPK  http://hackage.haskell.org/package/hmatrix-glpk-0.4.0.2 (AlbertoRuiz)
02:52:36 * hackagebot persistent-template 2.0.2.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-2.0.2.1 (MichaelSnoyman)
02:52:38 * hackagebot hmatrix-gsl 0.16.0.2 - Numerical computation  http://hackage.haskell.org/package/hmatrix-gsl-0.16.0.2 (AlbertoRuiz)
02:52:40 * hackagebot hmatrix-tests 0.4.1.0 - Tests for hmatrix  http://hackage.haskell.org/package/hmatrix-tests-0.4.1.0 (AlbertoRuiz)
02:55:17 <mbrock> yyttr3: if you define Matrix as Compose Vector Vector, you get many instances for free, including Applicative
02:56:28 <katsh> Reading this tutorial https://www.fpcomplete.com/school/starting-with-haskell/introduction-to-haskell/1-haskell-basics the guy has "x :: Int" and "x = 4" and says value of x cannot be changed
02:56:40 <katsh> but i changed it in the ghci. so what does he mean exactly?
02:57:01 <bergmark> katsh: you don't change it in ghci, you create a new variable with the same name that shadows the other one
02:57:25 <katsh> so different address in memory, but same variable name?
02:57:43 <bergmark> katsh: try this; let x = 1 \n let y = x \n let x = 2 \n y
02:58:25 <katsh> hard copies
02:59:22 <katsh> then what happens to old variable with the same name?
02:59:26 <katsh> floats around in memory?
02:59:51 <bergmark> if there are no references to it the GC will remove it eventually
03:00:34 <katsh> but when i reference the variable, how will it know if i want the old one or new one?
03:01:06 <bergmark> in that example, pretend that the first x gets renamed to x_1 internally, and then y = x_1
03:01:10 <mauke> scoping rules
03:01:55 <katsh> oh i see
03:02:12 <bergmark> katsh: http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-21.html#%_sec_3.2.2
03:02:25 <edlinde> can someone help me understand : data Frank a b  = Frank {frankField :: b a} deriving (Show)
03:02:32 <bergmark> maybe just starting at that section isn't very helpful :-)
03:02:45 <bergmark> edlinde: what don't you understand about it?
03:02:48 <edlinde> so we are building a type called Frank that takes two type parameters a and b
03:03:04 <edlinde> whats ths {frankField :: b a} doing?
03:03:23 <mauke> being a record definition
03:03:55 <katsh> bergmark: thanks. which book is this?
03:03:56 <mauke> data Person = Person{ name :: String, age :: Int }
03:03:56 <edlinde> I haven’t seen it defined like that.. with the “:: b a”
03:04:16 <edlinde> mauke: yep that Person example I get
03:04:28 <shmookey> a Frank has a record 'frankField' of type 'b a'
03:04:33 <bergmark> katsh: Structure and Interpretation of Computer Programs, a true classic
03:04:39 <edlinde> ah I see
03:05:06 <jle`> if we pretended that Maybe had only Just, we could write data Maybe a = Just { fromJust :: a }
03:05:07 <mauke> edlinde: Frank (Just 42) :: Frank Int Maybe
03:05:09 <Iceland_jack> @let data Frank a b = Frank {frankField :: b a} deriving (Show)
03:05:10 <lambdabot>  Defined.
03:05:13 <Iceland_jack> @ty Frank ['a']
03:05:14 <lambdabot> Frank Char []
03:05:15 <Iceland_jack> > Frank ['a']
03:05:16 <lambdabot>  Frank {frankField = "a"}
03:05:33 <Iceland_jack> @ty Frank (Just False)
03:05:34 <lambdabot> Frank Bool Maybe
03:05:47 <jle`> > frankField (Frank ['a'])
03:05:49 <lambdabot>  "a"
03:06:15 <jle`> :t frankField
03:06:16 <lambdabot> Frank a b -> b a
03:06:25 <Iceland_jack> :t Frank
03:06:26 <lambdabot> b a -> Frank a b
03:06:47 <Iceland_jack>     Frank :: [a]     -> Frank a []
03:06:47 <Iceland_jack>     Frank :: Maybe a -> Frank a Maybe
03:06:47 <Iceland_jack>     ...
03:06:56 <edlinde> ahhh info overload
03:07:01 <edlinde> I am not able to read that fast :)
03:07:39 <edlinde> so with Frank [‘a’]  is a = [] and b = ‘a’?
03:07:55 <Iceland_jack> no
03:07:58 <edlinde> hmm
03:08:01 <Iceland_jack> b is [], a is Char
03:08:02 <awestroke> @ty \x -> Frank (Just x)
03:08:03 <lambdabot> a -> Frank a Maybe
03:08:14 <edlinde> ah yeah sorry
03:08:20 <edlinde> yeah I meant the types
03:08:53 <Iceland_jack> edlinde: It may help to you specialize the type 'a'
03:09:02 <Iceland_jack>     data Frank2 b = Frank (b Int)
03:09:14 <Iceland_jack> *Frank2 (b Int)
03:09:22 <Iceland_jack> Here b can be [], Maybe, IO, ...
03:10:27 <mauke> well, 2 b Frank, ..
03:10:37 <jle`> heck, even Frank2 :)
03:10:41 <edlinde> :)
03:11:01 <jle`> wait
03:11:02 <jle`> it can't v.v
03:11:05 <jle`> nvm
03:11:08 <jle`> i should sleep
03:11:26 <edlinde> still a bit confused I must admit
03:11:51 <Iceland_jack> edlinde: You understand how this works?
03:11:51 <Iceland_jack>     data Foo a = MkFoo a a a
03:12:02 <edlinde> yep
03:12:03 <edlinde> I think so
03:12:18 <edlinde> with “MkFoo a a a” being the value constructor
03:12:19 <Iceland_jack> Okay, now you might want one of those to be a list of a's
03:12:25 <mauke> @let data Jesse c = Jesse (c Int) deriving (Read, Show, Eq, Ord)
03:12:26 <lambdabot>  .L.hs:156:24:
03:12:26 <lambdabot>      No instance for (Read (c Int))
03:12:26 <lambdabot>        arising from the first field of ‘Jesse’ (type ‘c Int’)
03:12:26 <lambdabot>      Possible fix:
03:12:26 <lambdabot>        use a standalone 'deriving instance' declaration,
03:12:31 <mauke> teehee
03:12:32 <Iceland_jack>     data Foo a = MkFoo [a] a
03:12:49 <Iceland_jack> But now you've pinned down []
03:13:16 <edlinde> what does it mean that I have pinned it down?
03:13:25 <edlinde> you mean now [a] is a concrete type?
03:13:27 <Iceland_jack> edlinde: Informal way of saying you can't change it
03:13:30 <edlinde> or fully saturated
03:13:56 <edlinde> yeah ok that arg will expect a list of type a’s
03:13:57 <edlinde> ok
03:14:02 <edlinde> then?
03:14:03 <Iceland_jack> I wouldn't use either, you can say that it's not polymorphic over the container
03:14:32 <edlinde> that sounds even more complicated to say :)
03:14:40 <edlinde> anyway I know what you mean
03:14:45 <Iceland_jack> Maybe you want to use a different container like Vector or Seq
03:14:59 <Iceland_jack> so you can write
03:14:59 <Iceland_jack>     data Bar c a = MkBar (c a) a
03:14:59 <edlinde> ok
03:15:10 <Iceland_jack> now
03:15:11 <Iceland_jack>     type Foo a = Bar [] a
03:16:37 <edlinde> hmm
03:16:55 <edlinde> so is your example a fresh one that is starting from    data Bar c a = …. ?
03:17:33 <Iceland_jack> edlinde: 'Bar' is like Foo earlier, except we can change the container type
03:17:44 <mauke> type WTF c = Bar (Bar c)
03:19:23 <Iceland_jack> If we have:
03:19:23 <Iceland_jack>     date Example = MkExample [Int]
03:19:23 <Iceland_jack> then it's always a list of Ints. What if we want a list of Bools? Then we can write:
03:19:23 <Iceland_jack>     data Example' a = MkExample' [a]
03:19:56 <edlinde> ok..
03:20:04 <Iceland_jack> But then it's always a *list* of something, what if we want a Set or Vector of something? Then we can write:
03:20:04 <Iceland_jack>     data Example'' f a = MkExample'' (f a)
03:20:25 <Iceland_jack> edlinde: If the first step (from Example to Example') is not clear, then you should focus on that first
03:20:40 <edlinde> I got the steps now I think
03:21:06 <Iceland_jack> Your original example was complicated by the fact that it reversed the arguments and used record syntax
03:21:16 <edlinde> yeah
03:21:23 <edlinde> just one sec
03:21:26 <Iceland_jack> Sure
03:23:32 <edlinde> ok I think I understood your example.. now I just want to see if I got the previous examples you gave or not
03:23:33 <edlinde> :)
03:24:14 <Iceland_jack> Sounds good, ask if you have further questions
03:24:51 <edlinde> maybe you could go through your Frank example if you like :)
03:24:55 <edlinde> if you have the patience
03:25:31 <Iceland_jack> Do you mean the original:
03:25:31 <Iceland_jack>     data Frank a b = Frank {frankField :: b a} deriving (Show)
03:25:37 <edlinde> which one should I look at you think? before going to the twisted one
03:25:50 <edlinde> in between you had some simpler examples I think
03:25:52 <edlinde> frank2
03:26:19 <Iceland_jack> Hm well, try understanding:
03:26:19 <Iceland_jack>     data Frank2 f a = Frank2 (f a)
03:26:48 <edlinde> data Frank2 b = Frank (b Int)
03:26:53 <edlinde> this is the one I was looking at
03:26:57 <Iceland_jack> Okay sure
03:27:06 <Iceland_jack> edlinde: What can the 'b' be?
03:27:17 <edlinde> any type yeah?
03:27:32 <Iceland_jack> Can it? Could it be 'Float'?
03:27:56 <edlinde> ah sorry
03:28:07 <edlinde> is b a function that must take an Int argument?
03:28:20 <m00nlight> What is the problem when I get "Warning: http error: Network.Browser.request: Error raised ErrorClosed" while using cabal?
03:28:31 <Iceland_jack> It's a type operator that takes any type as an argument
03:28:44 <edlinde> b is?
03:28:51 <Iceland_jack> Yes, b must have kind * -> *
03:28:57 <Iceland_jack> since Int has kind *
03:29:07 <edlinde> data Frank2 b = Frank2 (b Int)
03:29:16 <edlinde> in there haven’t we forced it to just take Int?
03:29:23 <Iceland_jack> Yes
03:29:28 <Iceland_jack> @let data Frank2 b = Frank2 (b Int)
03:29:30 <lambdabot>  Defined.
03:29:32 <Iceland_jack> @kind Frank2
03:29:33 <lambdabot> (* -> *) -> *
03:29:47 <edlinde> yep get the kind
03:30:07 <Iceland_jack> Do you get the constructor type?
03:30:08 <Iceland_jack> @ty Frank2
03:30:09 <lambdabot> b Int -> Frank2 b
03:30:43 <edlinde> I believe I do :)
03:31:07 <edlinde> so it takes a type b with parameter Int and returns a type Fran2 b
03:31:10 <Iceland_jack> @let deriving instance Show (b Int) => Show (Frank2 b)
03:31:11 <lambdabot>  Defined.
03:31:17 <edlinde> is that the right way to think of it
03:31:20 <Iceland_jack> Yes
03:31:22 <edlinde> ok
03:31:32 <Iceland_jack> Can you try passing arguments to Frank2?
03:31:50 <edlinde> thinking
03:32:12 <edlinde> Frank2 Show 2
03:32:13 <edlinde> ?
03:32:31 <edlinde> cannot think of some function that takes just an int
03:32:31 <Iceland_jack> Not quite
03:32:37 <edlinde> Frank2 Just 3
03:32:54 <Iceland_jack> Missing parentheses, but that's a fine example
03:32:57 <edlinde> sorry or should it be :  Frank2 (Just 3)
03:32:58 <Iceland_jack> Try running it with lambdabot
03:33:08 <edlinde> >Frank2 (Just 3)
03:33:18 <srhb> > Frank2 (Just 3)
03:33:20 <lambdabot>  Frank2 (Just 3)
03:33:26 <edlinde> ah needs a space
03:33:29 <srhb> Yep. :)
03:33:29 <Iceland_jack> Now check the type of it
03:33:33 <edlinde> :) thanks
03:33:40 <Iceland_jack> lambdabot can show it because of
03:33:40 <Iceland_jack> <Iceland_jack> @let deriving instance Show (b Int) => Show (Frank2 b)
03:33:40 <Iceland_jack>  
03:33:41 <edlinde> > :t Frank2
03:33:42 <lambdabot>  <hint>:1:1: parse error on input ‘:’
03:33:53 <Iceland_jack> edlinde: Just ':t ' at the front, no '> '
03:33:53 <edlinde> > :t Frank2 (Just 3)
03:33:54 <lambdabot>  <hint>:1:1: parse error on input ‘:’
03:33:57 <edlinde> ah
03:34:08 <edlinde> you mean check type of Frank2?
03:34:16 <edlinde> :t Frank2
03:34:17 <lambdabot> b Int -> Frank2 b
03:34:20 <Iceland_jack> The type of Frank2 applied to your argument
03:34:25 <edlinde> :t Frank2 (Just 3)
03:34:25 <lambdabot> Frank2 Maybe
03:34:27 <Iceland_jack> Right
03:34:38 <edlinde> that makes sense
03:34:43 <Iceland_jack> So, really Frank2 has the type: Maybe Int -> Frank2 Maybe
03:34:50 <edlinde> yep
03:34:53 <Iceland_jack> @ty Frank2 :: Maybe Int -> Frank2 Maybe
03:34:54 <lambdabot> Maybe Int -> Frank2 Maybe
03:35:01 <Iceland_jack> But also:
03:35:02 <Iceland_jack> @ty Frank2 :: [Int] -> Frank2 []
03:35:03 <lambdabot> [Int] -> Frank2 []
03:35:07 <Iceland_jack> > Frank2 [1..10]
03:35:08 <lambdabot>  Frank2 [1,2,3,4,5,6,7,8,9,10]
03:35:13 <Iceland_jack> That's all
03:35:20 <edlinde> cool
03:35:32 <Iceland_jack> But with Frank2, we've hardcoded the Int
03:35:47 <edlinde> yep
03:36:25 <poutsi> answering myself, apparently website bugs are tracked in github at haskell/haskell-platform
03:37:07 <edlinde> didn’t get the Frank2 [1..10] example
03:37:20 <edlinde> did we change the definition of Frank2
03:37:22 <Iceland_jack> No
03:37:23 <edlinde> or its the same
03:37:24 <edlinde> ok
03:37:26 <edlinde> hmm
03:37:28 <Iceland_jack> edlinde: You agreed that Frank2 had the type 'Maybe Int -> Frank2 Maybe'
03:37:32 <Iceland_jack> But it has many types
03:37:33 <edlinde> yes
03:37:50 <Iceland_jack>     Frank2 :: Maybe Int -> Frank2 Maybe
03:37:50 <Iceland_jack>     Frank2 :: [Int]     -> Frank2 []
03:37:50 <Iceland_jack>     Frank2 :: IO Int    -> Frank2 IO
03:38:17 <Iceland_jack> Just depends on what we pick as the 'b :: * -> *'
03:38:30 <edlinde> yeah don’t get the second one
03:38:34 <edlinde> Frank2 :: [Int]    -> Frank2 []
03:38:46 <Iceland_jack> edlinde: [Int] is just sugar for: [] Int
03:38:55 <Iceland_jack> @kind Maybe
03:38:56 <lambdabot> * -> *
03:38:56 <edlinde> ok
03:38:56 <Iceland_jack> @kind []
03:38:57 <lambdabot> * -> *
03:38:58 <Iceland_jack> @kind IO
03:38:59 <lambdabot> * -> *
03:39:27 <edlinde> yeah then Frank2 [1..10] makes sense
03:39:45 <edlinde> we couldn’t have written it as  Frank2 [] .. something right?
03:39:51 <edlinde> I mean to get the 1..10 range
03:39:52 <edlinde> :)
03:40:09 <Iceland_jack> [] means two things on the term and type level respectively
03:40:12 <Iceland_jack> but both of those would work
03:40:15 <Iceland_jack> @kind Frank2 []
03:40:15 <lambdabot> *
03:40:17 <Iceland_jack> > Frank2 []
03:40:19 <lambdabot>  Frank2 []
03:40:31 <edlinde> so we did
03:40:41 <edlinde> > Frank2 [1..10]
03:40:42 <lambdabot>  Frank2 [1,2,3,4,5,6,7,8,9,10]
03:40:48 <edlinde> we cannot do
03:40:54 <edlinde> > Frank2 [] 1..10
03:40:55 <lambdabot>  <hint>:1:12: parse error on input ‘..’
03:41:04 <Iceland_jack> no, but that's wholly unrelated to Frank2
03:41:08 <edlinde> is what I was trying to say
03:41:12 <edlinde> ok
03:41:41 <Iceland_jack> I'm guessing your confusion stems from
03:41:41 <Iceland_jack>     [a] ~ [] a
03:41:41 <Iceland_jack> (where ~ means "is equal type")
03:42:20 <edlinde> yeah I get that
03:42:40 <Iceland_jack> but that's only for the type level
03:42:41 <edlinde> but was just thinking that  “[] a” better fits the type declaration
03:42:44 <capisce> [a] is just a convenient shortcut for [] a?
03:42:55 <edlinde> ok
03:42:56 <Iceland_jack> capisce: For types, yes
03:43:02 <capisce> yeah
03:43:10 <capisce> makes sense
03:43:11 <edlinde> I get the difference now
03:43:16 <edlinde> thanks Iceland_jack
03:43:38 <Iceland_jack> you're welcome
03:45:20 <edlinde> the LYAH example was way more convoluted
03:45:21 <edlinde> :)
03:45:41 <Iceland_jack> Yes it's not an ideal example
03:47:17 <poutsi> anyone here well versed in Yesod? is it possible to have it connect to a db by using env vars to spec the connection?
03:47:40 <edlinde> though I am sure that I might still be mixed up
03:47:40 <edlinde> :)
03:47:52 <edlinde> you think you know it.. till you meet the next example
03:47:53 <edlinde> haha
03:49:41 <edlinde> @let data Example’ a = MkExample’ [a]
03:49:41 <lambdabot>  Parse failed: Illegal data/newtype declaration
03:49:58 <edlinde> Iceland_jack: I got that error when I was just trying out the other examples
03:50:02 <Iceland_jack> use ', not ’
03:50:12 <edlinde> ah
03:50:56 <edlinde> cool I just used 1 instead :)
03:51:00 <edlinde> works
03:56:44 <edlinde> Iceland_jack: last thing
03:56:45 <edlinde> > MkExample1 [1]
03:56:46 <lambdabot>  No instance for (GHC.Show.Show (L.Example1 a0))
03:56:47 <lambdabot>    arising from a use of ‘M335729628971702703325097.show_M3357296289717027033...
03:56:47 <lambdabot>  The type variable ‘a0’ is ambiguous
03:56:47 <lambdabot>  Note: there are several potential instances:
03:56:47 <lambdabot>    instance GHC.Num.Num GHC.Types.Double
03:56:57 <edlinde> getting this error ^
03:57:03 <Iceland_jack> Well you need a Show instance
03:57:16 <Iceland_jack> @let data Example2 a = MkExample2 [a] deriving Show
03:57:18 <lambdabot>  Defined.
03:57:23 <Iceland_jack> > MkExample2 [1]
03:57:24 <lambdabot>  MkExample2 [1]
03:58:01 <edlinde> cool
03:58:02 <edlinde> thanks
03:58:40 <edlinde> did u define MkExample2?
03:58:45 <Iceland_jack> Yes
03:58:47 <edlinde> coz I only had MkExample1
03:58:48 <edlinde> :)
03:58:50 <edlinde> ah ok
03:59:22 <edlinde> ah its the same as Example1 yeah?
03:59:26 <Iceland_jack> yes
03:59:29 <edlinde> ok cool
04:02:29 <poutsi> walp, 's here now fwiw: http://stackoverflow.com/questions/25722740/can-yesods-db-be-configured-with-environment-variables
04:06:53 <Twey> What's the deal with ‘Wye’ in machines?  The Y data type has constructors X ∷ Y a b a, Y ∷ Y a b b, and Z ∷ Y a b (Either a b).  Isn't Z redundant?
04:52:54 * hackagebot imagesize-conduit 1.0.0.4 - Determine the size of some common image formats.  http://hackage.haskell.org/package/imagesize-conduit-1.0.0.4 (mbrock)
04:53:04 <ocharles> Twey: Z is non-deterministic. X and Y are deterministic
04:53:38 <ocharles> I believe if you read from X <|> Y, it has different semantics to reading from Z
04:53:59 <ocharles> (assuming that's why you think Z is redundant)
04:54:53 <angerman> how can I get the ghc compiler to emit the llvm ir?
04:56:06 <quchen> angerman: -ddump-llvm?
04:56:16 <angerman> quchen lets see
04:56:21 <quchen> Sounds like that should do what you asked. I have never used it though.
04:57:46 <angerman> quchen: yep looks like it does :)
04:59:14 <Sir_Pony> good day fellow python killers
04:59:15 <Twey> ocharles: Ah, I see
05:02:39 <vanila> Sir_Pony, python killers? :)
05:02:59 <doismellburning> "python killers"?
05:03:41 <Sir_Pony> Let me explain using a mathematical operator
05:03:49 <Sir_Pony> haskell > python
05:03:52 <vanila> lol
05:04:17 <doismellburning> kerplunk
05:04:22 <vanila> that makes me wonder, are there any points where python beats haskell? things we could solve
05:04:22 <sivteck> > "haskell" > "python"
05:04:24 <lambdabot>  False
05:04:36 <akagr> Hi. I am trying to learn haskell from LYAH but finding it a bit daunting. Is there something I can look into?
05:04:49 <Sir_Pony> vanila, python is object oriented! :O
05:04:53 <doismellburning> akagr: what sort of daunting? what're you struggling with?
05:04:55 <vanila> > "haskell" > "Python"
05:04:56 <lambdabot>  True
05:05:10 <sivteck> ;x
05:05:20 <akagr> doismellburning: types and typeclasses
05:06:10 <doismellburning> akagr: do you have specific questions? (I'm not sure I can provide general help, sorry, as LYAH wfm, but others probably have suggestions)
05:06:40 <akagr> is there some project oriented tutorial? I feel a bit overloaded by theory
05:07:20 <doismellburning> akagr: Real World Haskell (RWH) may be of use (though some of the examples use libraries that have since changed)
05:08:03 <akagr> doismellburning: thanks. I came across it on google but started with LYAH. I'll give that a try
05:09:09 <doismellburning> akagr: I guess actually I started with ParConc (http://chimera.labs.oreilly.com/books/1230000000929) then dropped back to LYAH to fill in fundamentals
05:11:19 <akagr> doismellburning: nice suggestion :)
05:11:35 <doismellburning> akagr: if you have specific questions though, lmk
05:12:08 <doismellburning> akagr: (bwim "sorry I can't be more generally helpful")
05:13:51 <akagr> doismellburning: I may have taken an overdose. Lost sense of what was happening.
05:14:14 <akagr> will give that chapter a couple of more tries before I do anything else anyways
05:14:28 <vanila> geez don't scare me like that i didn't realiz you were talking about too much *haskell*
05:14:38 <doismellburning> akagr: I found "porting code I'd already written over to Haskell" was educational
05:16:27 <barrucadu> I don't think a Haskell overdose is possible.
05:16:51 <Sir_Pony> too much of any good thing is bad for you
05:17:04 <Sir_Pony> i.e. sex, haskell...
05:17:55 <carp> Hi. My dream is to make a 2d game in haskell. In other languages, we very carefully control the order of events for each frame. I am finding it hard to understand something. If programming a game in haskell, can you still control the exact order of things occuring in each frame? Is this fundamentally opposite of how one should be doing things? Games such as Quake, or streetfighter where precision is critical is the type of game Im cons
05:18:51 <xificurC> my VM says ghc: out of memory when installing hlint (compiling Language.Haskell.Exts.Annotated.Syntax to be precise) -_-
05:18:52 <doismellburning> carp: yes, no
05:18:52 <bernalex> carp: no it's well doable. but you might want to read up on FRP, which deals with events in a much more interesting way than the traditional eventqueue/callback/etc ways.
05:18:53 <vanila> carp, you can actualy program in the original imperative style in haskell
05:19:06 <vanila> carp, but  one cool thing about haskell is it also gives you options to do things in totally new ways
05:19:16 <bernalex> carp: uhm *yes* it's well doable, was what I meant to write
05:20:17 <carp> And now Im getting butterflies of excitement all over again!
05:20:18 <yitz> > "Haskell" > "Python" -- oh noes
05:20:19 <lambdabot>  False
05:20:35 <c_wraith> carp: carp http://www.reddit.com/r/haskell/comments/1jj40p/john_carmack_talking_at_length_about_haskell_in/cbff7cp This might be interesting to you, if you haven't seen it
05:20:56 <carp> c_wraith that was what got me here in the first place actually ha
05:21:16 <bernalex> yitz:
05:21:18 <bernalex> > haskell > python
05:21:20 <lambdabot>  True
05:21:23 <bernalex> :-]
05:21:32 <c_wraith> :t haskell
05:21:34 <vanila> have you seen that someone made a BSP viewer in haskell?
05:21:35 <lambdabot> Bool
05:21:41 <vanila> and I think you acn load quake3 levesl and move around in them
05:21:53 <bernalex> vanila: frag
05:21:59 <bernalex> it has bots even
05:22:00 <doismellburning> carp: you may want to look at frag btw, it's a q3 clone
05:22:06 <c_wraith> frag is way more than a BSP viewer
05:22:13 <bernalex> yeah
05:22:22 <c_wraith> unfortunately, frag isn't maintained.  It might be quite hard to build
05:22:22 <yitz> bernalex: hehe
05:22:27 <bernalex> use 7.8 to build it though, unless you have like 24 Gs of RAM lol
05:22:35 <bernalex> c_wraith: builds well on gentoo
05:22:42 <doismellburning> c_wraith: I tried a few months back and it mostly built...
05:22:48 <bernalex> c_wraith: i.e. using our PM :-]
05:23:41 <carp> Thankyou for the replies.
05:23:49 <bernalex> carp: I made a game prototype in haskell once
05:23:55 <bernalex> carp: https://github.com/plaimi/bweakfwu
05:24:24 <c_wraith> bernalex: did Elmer Fudd name it?
05:24:32 <bernalex> carp: carp actually, I have a version with AI somewhere
05:24:35 <bernalex> c_wraith: that was the idea yeah
05:24:46 <Sir_Pony> > haskell > sex
05:24:47 <lambdabot>  Not in scope: ‘sex’
05:24:47 <lambdabot>  Perhaps you meant one of these:
05:24:47 <lambdabot>    ‘lex’ (imported from Prelude), ‘seq’ (imported from Prelude),
05:24:47 <lambdabot>    ‘set’ (imported from Control.Lens)
05:25:03 <bernalex> carp: https://github.com/alexander-b/master-fun/ here is a version that has AI heh
05:25:10 <Sir_Pony> hmmm. :3 :P x3 O.o
05:25:37 <bernalex> carp: it uses a library called gloss, which is very nice for babbys first game in haskell, so I can really recommend you play around with it. check out #haskell-game too!
05:25:51 <Sir_Pony> I have no idea how the bot works :P
05:25:55 <carp> bernalex thankyou
05:30:49 <carp> I remember Carmack talking about his wolfenstein haskell port and saying he had problems with resolving when 2 enemies wanted to both walk into the same square at the same time. Basically how do you decide which gets priority. Things like that.
05:31:32 <vanila> I'm amazed that guy knows about haskell
05:31:38 <vanila> that's so cool
05:31:57 <bernalex> carp: I don't think he meant that it was a problem. I think his point was simply that you can deal with these things a bit differently.
05:32:11 <ko__> hi
05:32:13 <ko__> yo
05:32:45 <carp> I think he said that he didnt solve it but was convinced it wouldnt be a problem if he applied more thought to it.
05:33:06 <bernalex> vanila: he's not very proficient. he's more familiar with the lisp family. though he likes haskell better.
05:33:42 <elevation> > hello
05:33:43 <lambdabot>  Not in scope: ‘hello’
05:33:48 <elevation> > 1+ 1
05:33:50 <lambdabot>  2
05:33:55 <elevation> brillant!
05:34:04 <elevation> >echo brillant
05:34:11 <elevation> > echo brillant
05:34:12 <lambdabot>  Not in scope: ‘echo’Not in scope: ‘brillant’
05:34:23 <Sir_Pony> Is that haskell or bash?
05:34:27 <bernalex> > fix error
05:34:28 <Sir_Pony> echo is bash, right?
05:34:28 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
05:34:30 <bernalex> exceptional even!
05:35:26 <Sir_Pony> > main = putStrLn "hello"
05:35:28 <lambdabot>  <hint>:1:6: parse error on input ‘=’
05:35:41 <Sir_Pony> What language is >...
05:35:50 <Sir_Pony> haskell?
05:35:59 <Sir_Pony> >ls
05:36:05 <elevation> yeah echo is bash
05:36:05 <Sir_Pony> hmmm.
05:36:11 <Sir_Pony> ok
05:36:39 <elevation>  >say 'brillant'
05:36:43 <Sir_Pony> Isn't that a little dangerous? :P
05:36:43 <elevation>  > say 'brillant'
05:36:56 <Sir_Pony> Like, what if I do >rm *
05:37:02 <yitz> > unwords . intersperse "elevation" $ repeat "hello"
05:37:03 <lambdabot>  "hello elevation hello elevation hello elevation hello elevation hello eleva...
05:37:29 <Sir_Pony> > ls
05:37:32 <lambdabot>  Not in scope: ‘ls’
05:37:32 <lambdabot>  Perhaps you meant one of these:
05:37:32 <lambdabot>    ‘s’ (imported from Debug.SimpleReflect),
05:37:32 <lambdabot>    ‘l’ (imported from Debug.SimpleReflect)
05:37:36 <elevation> >unwords . intersperse "brillant" $ repeat "thanks yitz"
05:37:41 <elevation> > unwords . intersperse "brillant" $ repeat "thanks yitz"
05:37:43 <lambdabot>  "thanks yitz brillant thanks yitz brillant thanks yitz brillant thanks yitz ...
05:38:00 * hackagebot hindent 2.4 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-2.4 (ChrisDone)
05:38:01 <elevation> > s 'cookie'
05:38:02 <lambdabot>  Syntax error on 'cookie'
05:38:03 <lambdabot>  Perhaps you intended to use TemplateHaskell
05:45:26 <srhb> lambdabot: Perhaps not.
05:46:18 <srhb> Sir_Pony: lambdabot uses a system to restrict what kind of things can be done. it will not execute IO actions
05:49:14 <nicoo> > putStrLn "Hello, World!"
05:49:15 <lambdabot>  <IO ()>
05:49:18 <nicoo> Sir_Pony: ^
05:51:01 <xificurC> why is hlint throwing me a parse error on this? http://lpaste.net/909105290773790720 . It points to line 6. If I remove rows 2-5 it works ok
05:52:12 <Sir_Pony> ah cool
05:52:58 <michaelt> xificurC: shouldn't you be using fmap, not <$>
05:53:46 <byorgey> xificurC: not sure, looks OK to me.  Does ghc accept it, or does it give the same parse error?
05:53:52 <Twey> ocharles: Would you happen to know how to tell a Machine that there will be no further input, i.e. cause an await to fail?
05:54:01 <xificurC> michaelt: this is from NICTA, they use <$> in the class definition
05:54:16 <ocharles> Twey: no idea, sorry. Never actually written a line of code with machines :)
05:54:18 <xificurC> byorgey: ghci loads it without errors
05:54:21 <michaelt> xificurC: ah, ok sorry
05:55:06 <byorgey> xificurC: in that case it's probably a bug in haskell-src-exts
05:55:23 <Twey> ocharles: Fair enough.  ☺  Thanks anyway.
05:55:55 <byorgey> xificurC: you can check and see what version of haskell-src-exts you have installed.  If it's older than the latest, you could try doing a cabal update and then reinstalling hlint to build it against the latest haskell-src-exts release
05:55:59 <byorgey> in case the bug has been fixed
05:56:18 <ocharles> Twey: if you get anything interesting done I'd be interested in seeing it though :)
05:56:50 <xificurC> this is the error http://sprunge.us/EJjW
05:57:14 <xificurC> byorgey: unfortunately that won't be the case, I just installed hlint, did cabal update then cabal install hlint
05:57:18 <michaelt> ghc already objects xificurC with     (Use InstanceSigs to allow this)
05:58:50 <michaelt> xificurC: or rather, with "    Illegal type signature in instance declaration:" . But maybe I'm still not following.
05:58:58 <sagittarian_> is there a standard function like unwords but where you explicitly provide the glue string?
05:59:29 <michaelt> intercalate or intersperse sagittarian_ ?
06:00:00 <xificurC> michaelt: InstanceSigs is enabled in the file
06:00:07 <michaelt> xificurC: hmm
06:00:53 <sagittarian_> thanks, michaelt
06:03:46 <sagittarian_> how about the opposite, words but where you provide an explicit string to split on?
06:05:54 <Twey> Data.List.Split.splitOn
06:06:21 <Twey> (from split, part of the Platform)
06:06:35 <sagittarian_> thanks, Twey
06:07:39 <sagittarian_> :t splitOn
06:07:40 <lambdabot> Eq a => [a] -> [a] -> [[a]]
06:07:45 <sagittarian_> > splitOn [5, 6] [1..10]
06:07:46 <lambdabot>  [[1,2,3,4],[7,8,9,10]]
06:07:55 <sagittarian_> cool
06:13:54 <michaelt> sagittarian_: Data.Text has intersperse/intercalate/ splitOn as well. The first two tend in particular tend to resurface for libraries that deal with sequential things.
06:15:02 <xificurC> michaelt: out of ideas? :p
06:15:55 <sagittarian_> does anyone else think that haskell is an exceptionally elegant programming language?
06:16:23 <vanila> sagittarian_, in theory yes
06:16:33 <vanila> the implementations don't really express that  though
06:16:41 <michaelt> xificurC: yes, sorry it took me so long to understand the problem...
06:16:45 <sagittarian_> vanila, you mean ghc?
06:17:07 <xificurC> michaelt: heh no need to apologize, it's nice of you to take a look in the first place
06:17:16 <vanila> well it's a really great compiler but it's almost 1GB so it's hard to call it elegant
06:17:26 <sagittarian_> ah okay
06:17:41 <sagittarian_> but i'm talking about the language itself
06:18:14 <Iceland_jack> vanila: What an odd metric for elegance
06:18:34 <sagittarian_> anyway i used to think that ruby was an awesomely elegant language (and i still do), but haskell clearly has it beat
06:18:55 <exio4> Haskell is beautiful, but where are our dependant types? :P
06:19:13 <sagittarian_> exio4, say what?
06:19:26 <sagittarian_> i mean, you have a link that talks about that stuff?
06:19:57 <vanila> I think dependent types would ruin haskell
06:20:14 <Iceland_jack> exio4: ICFP was chock full of people working on dependent types in Haskell, singletons can model fully-fledged dependent types so go right ahead and use that now
06:20:53 <vanila> A nice system would be a good dependently typed language that you can FFI with
06:21:20 <Hodapp> vanila: GO MAKE IT!
06:21:39 <Twey> vanila: Idris…
06:21:41 <vanila> I don't think I ha ve the skills
06:22:07 <Hodapp> I may learn Idris one of these days.
06:22:54 <Hodapp> I guess I should learn Haskell better first...
06:22:56 <Hodapp> and some more of Coq.
06:23:03 <mgsloan> There was also a fair amount of "dependent types in _my_ haskell?!?" at ICFP :)  But I think the general consensus is that if it doesn't detract from the non-dependent subset, lets go ahead with it!
06:23:04 <vanila> well Coq can extract to haskell :)
06:23:05 <Hodapp> and maybe German.
06:23:11 <Hodapp> vanila: it can?
06:23:25 <vanila> so just code in Coq and prove your programs correct and then emit perfect Haskell code from it!
06:23:31 <vanila> Hodapp, yeah, let me find an example to show you!
06:23:34 * hackagebot buildable 0.1.0.0 - Typeclass for builders of linear data structures  http://hackage.haskell.org/package/buildable-0.1.0.0 (IvanMiljenovic)
06:23:36 <Iceland_jack> mgsloan: The most troubling to me was replacing * with U :)
06:23:38 <Hodapp> vanila: If the code's correct then why bother with Haskell? :P
06:23:48 <Hodapp> just generate $whatever_shittacular_language
06:23:53 <Iceland_jack> Univ, Star, Star0, *0, ★₀, ... would all be nicer imo
06:23:57 <Hodapp> yes, I used the word shittacular.
06:24:03 <mgsloan> Iceland_jack: Haha, I wouldn't be against that
06:24:13 <Hodapp> Twey: has Idris a good FFI?
06:24:29 <Sorella> exio4: in Agda :)
06:24:37 <exio4> Iceland_jack: we've lots of extensions, that is neat yeah :P
06:24:40 <mgsloan> The most disturbing to me was the idea that you might need type info in order to resolve whether something is a type constructor or value constructor
06:24:41 <Twey> Hodapp: It's built to, so I hope so!
06:25:20 <Hodapp> Twey: oh, so ostensibly it does?
06:25:29 <mgsloan> I don't think that'll happen, though.  Maybe just a convenient sugar for "Proxy :: " will do
06:26:13 <Sorella> sagittarian_: Haskell is somewhat elegant, but I'd like to have row polymorphism and extensible records. And algebraic effects.
06:26:32 <Twey> mgsloan: That's the nice thing about that approach to dependent types, though — you reduce the level distinction to a normal type distinction.  So distinguishing between them syntactically after that point is like having distinct syntax for string variables vs. integer variables.
06:27:25 <vanila> sorry im having trouble finding it
06:28:19 <enthropy> Sorella you're aware of hlist?
06:29:23 <exio4> what would be a "nice" way to do "f . map f"?
06:29:37 <mgsloan> Twey: Right, but then you've got the historical distinction between the value and type namespaces
06:29:50 <Iceland_jack> @pl \f -> f . map f
06:29:50 <lambdabot> ap (.) map
06:29:59 <vanila> https://code.google.com/p/priority-queues/
06:30:14 <int-e> @type ap (.) map
06:30:15 <lambdabot> ([c] -> c) -> [[c]] -> c
06:30:22 <vanila> Here is an example where the functions were implementd and proved correct in Coq, then a haskell library was created by extracting/compiling it into haskell
06:30:41 <Iceland_jack> @type (.) <*> map
06:30:42 <lambdabot> ([c] -> c) -> [[c]] -> c
06:30:59 <Twey> mgsloan: It's never been all that clear, really, what with value constructors getting capitals and so forth
06:31:08 <int-e> exio4: I think f . map f  is nice already
06:31:14 <Iceland_jack> What int-e said
06:31:18 <Twey> One idea I've heard proposed is that *constructors* (i.e. injective functions) on any level get capitals
06:31:25 <mgsloan> Twey: True, it's certainly a source of confusion for new users
06:31:34 <Hodapp> vanila: thanks!
06:31:43 <vanila> there are more but I wasn't able to find very many sorry
06:31:49 <enthropy> It gets you the first two things, but in some sense it is better to have more restricted types for things for the sake of keeping yourself sane when getting type errors
06:32:01 <sagittarian_> does coq compile to c?
06:32:12 <vanila> sagittarian_, it only targets haskell ocaml and scheme
06:32:15 <sagittarian_> slash, if you're transcompiling your code anyway, why haskell and not c?
06:32:19 <vanila> but you can compile some of those to C
06:32:22 <Hodapp> it looks like Idris compiles to C?
06:32:36 <Iceland_jack> sagittarian_: Haskell is a much easier target from Coq
06:32:41 <sagittarian_> ah okay
06:32:42 <vanila> yeah I think it's just about ease
06:32:48 <Twey> Hodapp: Idris compiles to Epic, which compiles to LLVM
06:32:52 <vanila> building a full blown compiler would be a much more serious job
06:32:56 <Hodapp> Twey: DAMMIT WIKIPEDIA
06:33:08 <exio4> thought some HOF did this, will use f . map f anyway :P
06:33:16 <Twey> I think it might have compiled to C, a long time ago.
06:33:21 <Hodapp> sagittarian_: but, http://plv.csail.mit.edu/bedrock/
06:35:10 <michaelt> Doesn't idris write other things besides llvm now?
06:35:44 <k00mi> idris has about a dozen backends, but the default is still C I think
06:36:22 <vanila> The great thing about Idris is that the compiler is based on "Dependent types need not store their indices"
06:36:25 <michaelt> --codegen TARGET  <select codegen: C, Java, bytecode,  javascript, node, or llvm>
06:39:28 <Twey> michaelt: Oh, I thought that went via emscripten or something.  Okay then.
06:40:40 <michaelt> Twey: I'm with you; it's hard to keep up with the idris crowd these days
06:42:12 <jaga> :q
06:42:32 <michaelt>  :a
06:43:37 * hackagebot buildable 0.1.0.1 - Typeclass for builders of linear data structures  http://hackage.haskell.org/package/buildable-0.1.0.1 (IvanMiljenovic)
06:43:39 * hackagebot buildable 0.1.0.2 - Typeclass for builders of linear data structures  http://hackage.haskell.org/package/buildable-0.1.0.2 (IvanMiljenovic)
06:43:54 <michaelt> Twey: I'm trying to decode some of this `machines` stuff too
06:46:08 <Twey> michaelt: I think I'm slowly getting the basic idea… but it keeps throwing me curveballs :þ
06:48:34 <michaelt> Twey: yes, I am trying to re-implement it without the cps Plan business. I'm trying to figure out the minimum that would permit something like the witty `k` index
06:49:44 <michaelt> Twey: but it is hard to distinguish which of the features are just historically dependent on the enumerator/iteratee business, and which are essential.
06:50:38 <Twey> I would assume none of the former, no?
06:51:32 <michaelt> well, it has features like internalizing Eof
06:52:40 <michaelt> One thing I didn't remember is that the Plan type is not just the church encoding of the Machine type
06:53:47 <Twey> michaelt: Why is Plan in CPS anyway?
06:54:04 <michaelt> I think it was assumed at the time that this would always be faster
06:54:18 <michaelt> It sometimes is, as I have verified ...
06:55:20 <Twey> Aha
06:55:34 <michaelt> Machine doesn't have a monad instance, the applicative instance is of the typical sort that wouldn't agree with a monad instance.
06:55:42 <michaelt> like ZipList and so on
06:56:20 <friden> I have a cabal question, im trying to install Agda, but it seems that cabal is installing and reading at different directories, so the dependency for Happy does not hold. look here for error output: http://pastebin.com/6Dgx3g8T
06:56:25 <friden> anyone knows how to fix it?
06:56:50 <michaelt> Maybe someone will find a way to simplify this new Oleg business so that the choice "to cps or not to cps" will have a sensible answer.
06:57:38 <Twey> I would hope it would be ‘no’
06:57:41 <michaelt> friden: is the newer happy in ~/.cabal/bin
06:58:30 <michaelt> friden: oh i see it is.
06:58:39 * hackagebot diagrams-cairo 1.2.0.2 - Cairo backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-cairo-1.2.0.2 (bergey)
06:58:50 <michaelt> you need to kill the other one, or put ~/.cabal/bin ahead of the other in path or something
06:59:17 <Twey> friden: Probably you need to export PATH="~/.cabal/bin:$PATH"
06:59:36 <Sorella> enthropy: I haven't used HList in Haskell yet. I don't get to use Haskell much, unfortunately.
06:59:52 <friden> Twey: oh, that seems like a good idea
07:00:27 <oy> salve
07:00:32 <srhb> The HIW 2014 talk on Dependent Haskell is pure typegasm. But now I'm sitting here with my hopes probably way too high up.
07:00:33 <srhb> QQ
07:01:37 <michaelt> Twey: but Plan cpses the original pipes type, modulo the witty k business.
07:02:05 <oy> list
07:02:14 <Twey> Ah, I see
07:02:30 <srhb> oy: ?
07:12:35 <friden> michaelt: Twey: thanks, that worked great^^
07:33:58 <aloiscochard> hey guys, someone on #scalaz mention the ability to "zooming into State and Reader" using lenses, do you guys have any pointer how this done in haskell?
07:34:31 <edwardk> e.g. zoom :: Lens' s t -> StateT t a -> StateT s a
07:34:45 <edwardk> that's a grossly simplified signature and wrong but the right idea
07:34:50 <edwardk> e.g. zoom :: Lens' s t -> State t a -> State s a
07:34:52 <edwardk> start there
07:35:00 <edwardk> zoom does the right thing for much more complicated cases as well
07:35:19 <edwardk> so it can edit the state type down inside a complex monad transformer stack
07:42:00 <danilo2> Hello! I've got a strange Haskell problem. I've difined an instance. I'm trying to use it and I'm getting error " No instance for [...] Note: there is a potential instance available [...]" And GHC lists the one instance I defined. The problem is, it did not choose it. I know the open world assumption etc, but thwe instance is identical to what GHC needs - are there any ideas why I could get such error ?
07:43:25 <bergmark> danilo2: does the error mention package versions? are you running this in ghci? is it an orphan instance?
07:43:45 * hackagebot hxt 9.3.1.7 - A collection of tools for processing XML with Haskell.  http://hackage.haskell.org/package/hxt-9.3.1.7 (UweSchmidt)
07:44:52 <danilo2> bergmark: This is just a couple of files, so no package version could be related to this issues (as far as I know). Yes, I'm runing it in GHCI. It is not an orphhan instance
07:46:22 <aloiscochard> edwardk: oh I see, that is very helpful thanks!
07:47:20 <danilo2> bergmark: http://lpaste.net/110720
07:48:27 <danilo2> bergmark: I've just updated the exampel code
07:48:49 <bergmark> danilo2: your type is ambiguous
07:49:51 <danilo2> bergmark: But it should be handled by the instance, shouldnt it? The ambigous part is covered by the type variable "m" in the instance
07:50:15 <bergmark> danilo2: it says it requires that mb ~ PureS
07:51:31 <danilo2> bergmark: Oh, reload the example pelase (I used my notation there). I've got this assumption - look at the instance definition - in particular at "env~m" - it is what aere you talking about - isnt it ?
07:56:19 <Chromett> Hi !
07:56:42 <Chromett> All these ppl and no one speaks ?
07:56:47 <Chromett> O.O
07:57:06 <sipa> it's still early in the US :)
07:57:07 <jmcarthur> Chromett: it happens sometimes
07:57:12 <Redz> hello
07:57:13 <Chromett> Kk ^^
07:57:13 <Redz> is there something like a compiletime equation solver?
07:57:15 <seku> lazy evaluation, i suppose.
07:57:20 <capisce> you want everyone to reply hello?
07:57:21 <Zeedox> Chromett: Discussion have been pretty lively all day.
07:57:37 <capisce> :)
07:58:50 <bergmark> danilo2: i can't pinpoint it, but usually what this means is that it is possible for several instances to match
08:00:56 <Redz> capisce: uhm no. but some people still don't like not to greet. just formal stuff.
08:01:25 <Redz> *get greet.
08:02:14 <danilo2> bergmark: Strange, I've found one more thing. I would be thankful if you look at the annotation.
08:02:26 <capisce> Redz: sorry, I meant Chromett, not you - just saying hello without asking or talking about anything Haskell-related
08:02:26 <Chromett> Please can you tell me how to remove the "x has joined/quit"
08:02:28 <Chromett> ?
08:02:34 <shmookey> Redz: depends how you fine 'equation' i guess
08:02:46 <Zeedox> Chromett: Google your irc client name + hide JOINS
08:02:50 <Chromett> That's the first time that I come on IRC ^^
08:02:54 <shmookey> (if you can definite it in terms of haskell types then probably)
08:03:02 <Chromett> Okay i'll try it
08:03:38 <shmookey> ugh, s/fine/define/ and s/definite/define/
08:03:57 <Zeedox> Chromett: Generally people aren't so glad to discuss things outside of the channel topic, so be careful. :) I think you'll get better help for those things in a more general chat channel.
08:03:58 <bergmark> danilo2: is this in ghci?
08:04:19 <bergmark> oh yeah you said so
08:04:31 <danilo2> bergmark: yes
08:04:33 <Chromett> Thanks guys :P
08:04:37 <bergmark> ghci does some type defaulting sometime so i'd try it in a normal file
08:04:40 <Redz>  shmookey: i know only one definition for 'equation'.
08:06:30 <bergmark> danilo2: for instance, i just happened across this a few minutes ago
08:06:31 <trap_exit> if a ahskell programmer is 10x more productive than a C/javascript programmer
08:06:33 <bergmark> λ> parse id (parseJSON (Number 1))
08:06:34 <Redz> i would be happy to be pointed towards just every package that could be related to what i'm looking for.
08:06:34 <bergmark> Error "when expecting a (), encountered Number instead"
08:06:37 <trap_exit> why hasn't most of the world's software been rewritten in haskel ?
08:07:00 <doismellburning> trap_exit: effort, time
08:07:14 <johnw> trap_exit: cost vs. reward
08:07:14 <trap_exit> yeah
08:07:15 <trap_exit> but haskell is 10x
08:07:23 <Redz> C is used for most stuff. but as you can see, java and c# is ruling.
08:07:28 <trap_exit> johnw: people write open source software for little reward
08:07:29 <bergmark> trap_exit: how many man hours of programming do you think has been spent?
08:07:30 <Redz> *now
08:07:54 <trap_exit> bergmark I do not know
08:07:55 <shmookey> Redz: i don't know of such a package but if you want to to do arbitrary stuff at compile time you could use template haskell
08:08:14 <johnw> trap_exit: then you are asking why most of the world's open source software hasn't been rewritten in Haskell?
08:08:26 <trap_exit> johnw: I am
08:08:31 <Redz> but template haskell is so difficult. :|
08:08:37 <johnw> plenty of those developers are still unaware that Haskell exists
08:08:57 <trap_exit> johnw: yeah, but those are probably not the ones that writen important C/javascript applications
08:09:10 <trap_exit> johnw: i.e. what % of programmers who do useful work don't know that ahskell exists?
08:09:15 <trap_exit> I suspect that % is low
08:09:19 <johnw> how could I ever answer that?
08:09:21 <trap_exit> (though I do not have data / evidence)
08:09:24 <capisce> trap_exit: what would be the point of rewriting working software in Haskell for example?
08:09:38 <trap_exit> capisce: it's easier to reaon about, and thus less buggy
08:10:35 <shmookey> Redz: whether you can solve an equation at compile time using the type system is related to the question of whether you can prove a solution, which is the subject of the curry-howard correspondence
08:10:40 <danilo2> bergmark: Hmm, strange. I'll test it in the file, thanks :)
08:10:55 <capisce> I think there's no consensus on the best way to write the Linux kernel in Haskell for example
08:10:55 <shmookey> interesting topic though probably unhelpful if you're just looking for a package to do it :P
08:11:17 <Zeedox> trap_exit: Haskell isn't suited to every domain.
08:11:19 <Iceland_jack> Linux kernel in Haskell.... sure :)
08:11:30 <Zeedox> (from my experience)
08:11:36 <HairyDude> Loading package gtk-0.12.5.7 ... can't load .so/.DLL for: libgtk-x11-2.0.so (libgtk-x11-2.0.so: cannot open shared object file: No such file or directory)
08:11:50 <trap_exit> outside of OS / real time, I think haskell suffices
08:12:03 <HairyDude> but it's right there in /usr/lib/x86_64-linux-gnu
08:13:11 <Zeedox> trap_exit: Real time is a fairly big subset of all programming, I'd say.
08:13:33 <trap_exit> Zeedox: I don't consider any part of say, IE, Chrome, Firefox, or Office to be 'real time'
08:14:15 <Redz> shmookey: sorry. i mean, i look for something that is compiling an infrastructure/functiontree to solve the equation. the equation itself doesn't need to be solved at compiletime. my idea is to get some compiling optimization advantages.
08:14:45 <Zeedox> trap_exit: Really? Personally I hope for my browser to have very high performance, both speed and memory-wise.
08:14:53 <Redz> and not to need to rewrite a equation at hand.
08:15:09 <trap_exit> Zeedox: I can see a browser being written in Haskell
08:16:06 <Zeedox> trap_exit: Technically most GUI software should be as fast as possible, actually. But I'm no expert on haskell's speed.
08:16:16 <SaBer> I think real time usually refers to firm or hard real time, soft real time is not really real time IMO :)
08:16:20 <shmookey> some of the new a/v apis must edge pretty close to even the tightest definition of 'real time' programming
08:16:22 <SaBer> http://en.wikipedia.org/wiki/Real-time_computing#Criteria_for_real-time_computing
08:16:29 <Zeedox> Trying to learn it myself, but having a hard time choosing a GUI library.
08:16:30 <capisce> trap_exit: in a large scale Haskell applications you have to worry about memory leaks, garbage collection hits, etc, you might have to write in a style that doesn't give you all the benefits that Haskell would give you in a domain unconstrained by performance
08:16:31 <trap_exit> SaBer : agreed
08:16:45 <Redz> there are some nice and fast games written in haskell. where's the problem?
08:17:13 <Redz> in case of realtime.
08:17:18 <capisce> so maybe you don't get that 10x productivity factor any more
08:17:30 <c_wraith> Zeedox: "as fast as possible" has nothing to do with "real time".  real time software is often quite slow - the important part is that real time software guarantees its performance will never be worse than some measure.
08:17:37 <capisce> some of the problems you have to solve are relatively orthogonal to programming language too
08:18:31 <Zeedox> c_wraith: I guess I chose the wrong terminology.
08:18:45 <HairyDude> speaking of GUI libraries... what do I have to do to let the gtk package find libgtk-x11-2.0.so?
08:18:59 <Redz> well, every compiler could be more helpful in automatically finding a better solution for a described problem ... its not a language problem at all.
08:19:37 <Zeedox> I'm mostly a frontendy programmer at the moment, anyway.
08:20:19 <trap_exit> capisce: is this all due to laziness ?
08:20:36 <capisce> trap_exit: not at all
08:20:51 <capisce> you could ask why more software isn't written in OCaml too
08:20:55 <trap_exit> capisce: where else do you get meory leaks / other problems from?
08:21:20 <trap_exit> j/join #ocaml
08:21:23 <Redz> OCaml has an O. ;)
08:22:31 <capisce> when I google for ocaml at least I get a job advert :)
08:23:54 <Redz> well, i like monads.
08:24:58 <alanoth> Hello, everyone
08:25:11 <capisce> trap_exit: btw, is there any research that shows that Haskell makes programmers 10x as productive?
08:25:49 <trap_exit> capisce: I do not have a citation on hand
08:26:00 <trap_exit> though I've read a bunch of essays by imporantt people
08:26:01 <trap_exit> about the productivity gains of ahskell
08:26:05 <alanoth> I am interested in contributing to FOSS, I have studied the first 5 chapters of Real World Haskell. Where can I contribute at this stage?
08:26:36 <alanoth> Anyone who has experience with the SoC, please guide me
08:27:05 <trap_exit> you probably weant to read throgh entireity of RWH
08:27:14 <trap_exit> it's unlikely to find someoen that wants to mentor you until you invest that much effort
08:27:19 <trap_exit> however, you're free to ask questions here
08:27:23 <Zeedox> capisce: There is this one: http://haskell.cs.yale.edu/?post_type=publication&p=366
08:27:39 <alanoth> the entire RWH, thanks. Now I have a specific goal
08:27:42 <capisce> trap_exit: well, a lot of it is speculation I think
08:27:51 <alanoth> Also, any good source of good code
08:28:42 <alanoth> I'm new to functional programming, and still find it hard to believe that software could be written using haskell
08:28:55 <alanoth> Is there any good beginner-friendly haskell codebase out there?
08:28:59 <capisce> trap_exit: other languages are constantly catching up productivity-wise too: http://chriskohlhepp.wordpress.com/lambda-over-lambda-in-cplusplus14/
08:29:21 <capisce> and people used to claim languages like Clojure and Common Lisp are 10x-languages too
08:29:25 <Redz> we still find that its hard to believe that everyone else isn't using Haskell yet. ;)
08:29:25 <c_wraith> alanoth: it's just software.  Like everything else, you start small and build up.
08:30:06 <alanoth> i haven't had much experience with software.
08:30:12 <danilo2> Hello! Would anybody bwe so nice and tell me why the following code does not compile with PolyKinds enabled? http://lpaste.net/110726
08:30:20 <alanoth> I'm looking to gain some experience before the starts of gsoc 15'
08:30:28 <capisce> trap_exit: actual industry successes would weigh much heavier than essays about Haskell being more productive
08:30:42 <Redz> i would use lisp and prolog instead of java and c# . fortunately, there is haskell .
08:30:43 <sm> +1
08:30:56 <capisce> trap_exit: such as Paul Graham's success with Lisp against his contemporary competitors
08:31:07 <trap_exit> eh
08:31:14 <trap_exit> I'm not a big fan of Paul Graham essays
08:31:18 <alanoth> c_wraith: do you know of any considerably sized haskell codebase that a beginner can read
08:31:20 <trap_exit> prevneted me from studying types for a long time
08:31:33 <jmcarthur> alanoth: what do you mean by considerably sized?
08:31:48 <Iceland_jack> alanoth: You may want to lurk around on r/haskell and read toy projects people post there
08:32:04 <Zeedox> capisce: Did you see the paper I linked? While not industry, it is at least a practical example.
08:32:05 <Iceland_jack> but I'd suggest learning more Haskell anyway, 5 chapters in RWH is not that much
08:32:06 <alanoth> a few thousand lines, not like the ones present in RWH
08:32:16 <capisce> trap_exit: well, the truth is he was very productive... also Lisp is highly interactive letting you connect to, inspect, and hotswap parts of a running program for example
08:32:23 <Cale> Paul Graham is a master of using a lot of words to not get a whole lot said.
08:32:28 <vanila> lol
08:32:51 <capisce> Zeedox: ah, thanks
08:32:56 <alanoth> I'm going to buy RWH, is there anything else that I might need?
08:33:20 <alanoth> iceland_jack: thanks for the suggestion
08:33:27 <jmcarthur> alanoth: maybe xmonad?
08:33:43 <c_wraith> alanoth: I've written some, but none have been free.  I'm not sure what's available to point at as a full application that's well-written with free source.  Pandoc, maybe?
08:33:44 <Iceland_jack> XMonad is not going to make sense without knowing monad transformers
08:34:11 <jmcarthur> the thing with xmonad is there isn't actually much business logic there. it's designed to be kind of a generic platform for various extensions.
08:34:19 <alanoth> jmcarthur: will it be readable for a beginner, i haven't read many large codebases yet
08:34:23 <jmcarthur> plus a bunch of ugly X11 stuff
08:34:34 <jmcarthur> but it's all i can think of
08:34:55 <danilo2> bergmark: Ok, I've got it! It was not type defaulting in GHCI. It was error related to PolyKinds!
08:34:55 <jmcarthur> i think beginners would be best off learning the language and then maybe looking at a project to see how it's structured. the specific code almost doesn't matter though
08:34:58 <sgronblo> trap_exit: PG prevented you from studying types?
08:35:00 <alanoth> c_wraith: will rwh be good as my only resource for haskell, should i buy it?
08:35:08 <zwer_> I miss some of the dynamic development from CL's slime.. like being able to recompile functions without restarting the whole environment. I wonder if that would even be possible in haskell
08:35:10 <trap_exit> sgronblo: those essays discourgaed me from taking haskell seriously
08:35:17 <trap_exit> and over valuing lisp
08:35:23 <sm> alanoth: hledger!
08:35:28 <trap_exit> since using haskell, I've found types > macros
08:35:29 <Redz> someone could refactor the stunts/doom game's. isn't easy to get it compiled.
08:36:22 <Redz> and nikki. is the nikki project dead?
08:36:47 <Cale> If you've finished learning the basics of the language, don't forget there are always lots of good papers to read as well. http://www.haskell.org/haskellwiki/Research_papers/Functional_pearls has a list of papers which show examples of good library designs.
08:37:10 <Redz> yeah. tons of papers.
08:37:34 <Zeedox> I both love and hate the haskell community's fondness of papers.
08:37:35 <alanoth> sm: thanks for hledger, it looks like a project that would be considerably easier to read
08:37:41 <gcganley> :t (<**>)
08:37:43 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
08:37:45 <Cale> Zeedox: What's not to love about it?
08:37:46 <sgronblo> trap_exit: did he dis types? I cant remember exactly what his stance was.
08:38:15 <trap_exit> I think the basics stance on types was:
08:38:23 <gcganley> Zeedox: my entire ipad is filled with haskell papers people tell me to read 0.o
08:38:24 <trap_exit> well, let me not put words into his mouth
08:38:31 <capisce> trap_exit: macros have their benefits too, but I'm definitely in favor of static typing... why not both?
08:38:50 <Zeedox> Cale: Not as accessible for laymen. Papers tend to be written in an unnecessarily academical style that can be hard to parse / slow to read. At least > 90% of the ones I've read.
08:38:51 <sgronblo> I'm wondering if lisp programmers like python programmers rationalize that dynamic typing is good because they happen to be using a language that uses it.
08:38:51 <alanoth> thanks once again :)
08:39:18 <Zeedox> gcganley: Yeah, me too, except not exclusively haskell.
08:39:27 <Redz> there is template haskell. i'm sure you can do something similar to macros.
08:40:12 <Iceland_jack> You can to something similar to macros with regular Haskell
08:40:24 <Redz> you can do haskell with lisp.
08:40:42 <Cale> Zeedox: Well, you can usually skip over a lot of the more technical bits of things. Often papers about the type system will use a notation whose heritage is in formal logic, and which is useful to implementors and a concise way to express things if you understand it, but usually not required to actually understand what's going on.
08:40:50 <jollygood> I had a python programmer argue that static typing is useless because it only catches trivial type errors that good unit testing would check
08:41:09 <jollygood> that good unit testing would catch anyway*
08:41:20 <Redz> i still don't need to test my software.
08:41:34 <Cale> jollygood: "Your automatic system is useless because I can do all this manually."
08:41:49 <jollygood> Cale yeah, basically
08:41:50 <rodlogic> ok, I am a bit obsessed with polyvariadic functions. There is an example by Oleg that shows how to implement it for plain functions. I then read something about idiom brackets for applicative functors. Can we use the same polyvariadic technique to hide pure and <*>?
08:42:22 <Cale> jollygood: Nevermind that the number of unit tests required is probably far larger than he thinks.
08:42:37 <Zeedox> Cale: Yeah. I guess it's more of a subjective thing.
08:42:45 <vanila> rodlogic, have you tried? I imagine it would work
08:42:45 <Zeedox> (re: papers)
08:43:10 <rodlogic> vanila: Hi!! I am trying but realizing that I don't fully grok it.
08:44:35 <vanila> rodlogic, which one are you basing it on?
08:44:39 <vanila> http://okmij.org/ftp/Haskell/polyvariadic.html
08:44:43 <vanila> there's a bunch here
08:44:51 <rodlogic> I am trying to modify this one: http://www.haskell.org/haskellwiki/Idiom_brackets
08:45:33 <Iceland_jack> rodlogic: Applicatives/idiom brackets are not for polyvariadic functions (which you shouldn't use anyway in Haskell)
08:45:45 <Iceland_jack> they can lift functions of arbitrary arity but that's different
08:46:43 <rodlogic> Iceland_jack: I want to have an applicative functors that can handle any number of parameters and I would like to hide it using polyvariadic functions
08:46:48 <Cale> "Shouldn't use" is a bit strong, I think.
08:47:05 <Cale> There are lots of cases where functions in Haskell will accept an arbitrary number of arguments
08:47:08 <Iceland_jack> Cale: I'm too tired to add disclaimers to everything, yes quickCheck etc.
08:47:20 <Cale> Even foldr will :)
08:48:30 <rodlogic> (div (p "first paragrash") (p "second paragraph") (p "third"  "paragraph"))
08:48:42 <Cale> > foldr (\x xs a -> (x,a) : xs (a+1)) (const []) "Hello" 0
08:48:43 <lambdabot>  [('H',0),('e',1),('l',2),('l',3),('o',4)]
08:49:13 <Cale> > foldr (\x xs a b -> (x,a,b) : xs (a+1) (b*2)) (\a b -> []) "Hello" 0 1
08:49:14 <lambdabot>  [('H',0,1),('e',1,2),('l',2,4),('l',3,8),('o',4,16)]
08:49:34 <rodlogic> consider the above example: div is the aliassing 'pure'. then I can have 1 or more child elements (the div parameters). Each parameter/child can be it's own applicative functor with 1 to N params etc)
08:50:30 <rodlogic> this works for monoid, but I would like to use an applicative instead
08:52:33 <Cale> I've always thought it a little weird for things that express bits of HTML to be regarded as computations with an (arbitrary) result. People do that sort of thing to abuse do-notation and such, but I'm not sure it's really a great plan.
08:52:49 <Cale> I guess you can get away with it, if you like the notation.
08:53:03 <Zeedox> Cale: What's wrong with it?
08:53:44 <jollygood> I am at the beginning of writing a multiplatform program. 95% of the code will be portable and 5% OS-specific. how would one usually isolate platform-specific code from portable code in ghc?
08:53:45 <Cale> Zeedox: Well, you have a type parameter which is going pretty much unused.
08:54:26 <jollygood> I will split the code into several libraries, and I would like to have one cabal file that can be installed on all the supported OSes
08:54:30 <Cale> jollygood: Perhaps a bit of CPP?
08:55:34 <rodlogic> Cale: in what way it is unused?
08:55:43 <jollygood> #ifdef WIN32\nimport winlib\n#else import posixlib  <- something like that?
08:56:04 <jollygood> I made up the definition btw
08:57:34 <jollygood> I tried to check how System.FilePath does it but there's no source button. http://hackage.haskell.org/package/filepath-1.3.0.2/docs/System-FilePath.html
08:57:49 <Cale> rodlogic: If you're using something like a writer monad to generate HTML, then the results of all your computations are going to have type ()
08:58:23 <Cale> rodlogic: turning (>>) into concatenation, pretty much
08:58:57 <Cale> jollygood: I have a source button
08:59:04 <albeit> I know this snippet can be improved and made more succinct, but not sure the exact form.. any ideas? http://lpaste.net/110727
08:59:05 <Cale> jollygood: It's in the top right, isn't it?
08:59:08 <jollygood> Cale that is odd
08:59:09 <Cale> http://hackage.haskell.org/package/filepath-1.3.0.2/docs/src/System-FilePath.html
08:59:16 <jollygood> ah right
08:59:31 <Chromett> Someone plays LoL here ?
08:59:59 <sipa> Chromett: offtopic
09:00:13 <Chromett> No ? D:
09:00:16 <jollygood> I always click the source button next to the function documentation, didn't even realize it was at the top as well
09:00:19 <Chromett> kk
09:01:17 <Cale> albeit: There's a way using MaybeT, but not sure it's worth the trouble.
09:02:36 <albeit> Cale: Okay, it just seems so verbose for basically doing "f <$> a"... except f is in IO
09:03:00 <rodlogic> Cale:I understand that (div child1 child2 child3) is basically something like child1 <> child2 <> child3. I am basically struggling with the fact that (attrs (attr1 "value") (attr2 "vvv")) have a different type than (div (attrs) child1 child2 child3). How to I preserve the 'parent' context when processing the tree?
09:03:10 <HairyDude> Is there a tutorial for gtk3?
09:03:41 <HairyDude> I've translated the "hello world" glade program to use it except it doesn't quit when I close the window
09:03:44 <rodlogic> Cale: instead of just seeing a string of concats.
09:04:28 <Cale> rodlogic: I'd probably represent addition of attributes as a function which acts on the root of a tree.
09:06:15 <zwer_> HairyDude do you have onDestroy window mainQuit? I recall some of the hello world gtk2hs examples missin that
09:07:36 <Cale> rodlogic: i.e. as simply functions HTML -> HTML or whatever
09:08:04 <vanila> rodlogic, why don't you use div [child1, child2, child3]
09:08:25 <Cale> Yeah, a list makes more sense there too
09:08:35 <rodlogic> vanila: :-) I love the novelty
09:09:04 <vanila> rodlogic, well stepping back a bit: I think you should do a rough spec of the language - then think about embedding as a DSL in a way that types nicely (Ideally not using crazy stuff like you find on olegs homepage)
09:09:14 <Cale> The trouble with making it variadic is that there will be many cases where you end up with type ambiguities
09:09:43 <Cale> (i.e. is this a complete fragment of HTML, or a function which accepts another HTML subtree, or ...)
09:10:06 <rodlogic> Cale a fragment of HTMLd
09:10:11 <Cale> Using lists avoids that problem nicely.
09:11:33 <HairyDude> zwer_: that's not how signals work in gtk3, instead they use a generic on :: object -> Signal object callback -> callback -> IO (ConnectId object)
09:11:55 <HairyDude> zwer_: for example "on closeButton buttonActivated $ do ..."
09:12:00 <albeit> Another snippet I'd like to improve... http://lpaste.net/110728. Showing one possibly attempt, but doesn't seem ideal
09:12:31 <zwer_> HairyDude right.. but it is trivial to translate that to working gtk3, no?
09:12:53 <Cale> albeit: What's wrong with the attempt?
09:13:13 <Cale> albeit: I suppose you have g k repeated
09:13:16 <albeit> Cale: I have to specify the call to g k twice
09:13:20 <Cale> You could maybe use a pattern guard here
09:13:21 <albeit> Cale: Yeah
09:13:23 <HairyDude> zwer_: that's the issue, I can't find an event called "windowDestroy" or the like
09:13:28 <HairyDude> zwer_: in the docs
09:14:02 <zwer_> HairyDude I see
09:14:34 <Cale> case () of _ | Just v <- Map.lookup k m, cond -> f v | otherwise -> g k
09:15:52 <Cale> (depending on the context in which this expression occurs, you might also avoid using the explicit case, but I wanted to make it genuinely equivalent)
09:16:32 <nshepperd> albeit: case (guard cond >> Map.lookup k m) of { Just v -> f v; Nothing -> g k }
09:16:44 <Cale> ah, that's another good way
09:16:56 <albeit> nshepperd: Interesting! Thanks
09:17:03 <nshepperd> monad combinators!
09:19:35 <joelteon> Combinator? I barely know 'er!
09:19:57 * nshepperd golfs it down a bit more: maybe (g k) f (guard cond >> Map.lookup k m)
09:20:30 <nshepperd> it starts to looks like nonsense at that point though :p
09:21:16 <Cale> Yeah, I tend to be wary of using 'maybe', because when I have to change code later, I usually end up rewriting it back into 'case' anyway.
09:23:02 <albeit> My g k was actually Nothing, and f v was Just (f v)... so now its just "f <$> (guard cond >> Map.lookup k m)"!
09:24:44 <nshepperd> it's our best friend, fmap!
09:25:44 <johnw> how about: mfilter cond (f <$> Map.lookup k m)
09:26:44 <nshepperd> :t mfilter
09:26:45 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
09:27:11 <nshepperd> neat
09:27:21 <albeit> Ha just keeps getting better
09:27:52 <johnw> though maybe you'd need: f <$> (mfilter cond (Map.lookup k m))
09:28:27 <nshepperd> code golf is addictive
09:30:52 <albeit> Ah but cond :: Bool, so I think I need to stick with guard instead of mfilter
09:31:15 <johnw> ah
09:31:25 <johnw> yeah, mfilter (const cond) would be it, but is uglier
09:33:40 <simpson> do { guard cond; f <$> M.lookup k m } -- this is what you're headed towards, right?
09:33:59 * hackagebot data-dispersal 1.0.0.0 - Space-efficient and privacy-preserving data dispersal algorithms.  http://hackage.haskell.org/package/data-dispersal-1.0.0.0 (PeterRobinson)
09:34:47 <albeit> simpson: Yes
09:35:21 <albeit> simpson: Though I think I like the non-do version better, unless theres a good to reason to use the do version?
09:35:40 <simpson> albeit: I *like* do-notation. I'm weird that way.
09:36:02 <simpson> (Also I still do lots of imperative programming with Evil Objects and Evil Mutable State.)
09:36:26 <jollygood> heretic
09:38:58 <nshepperd> haskell is the best imperative language
09:39:01 <SrPx> Chief teacher on a lecture on graph theory: "so, sometimes you must prove your algorithm is actually incorrect. This is an important, yet often forgotten part of computer science. Have you guys even seen someone applying this technique?" - someone replies: "like proof by induction?" - "yea, correct!" - "very used in dependent typing" - "dependent what?" - "hmmm.. typing, from type theory" - "I never heard of type theory but might be, in
09:39:07 <SrPx> correct*
09:39:29 <capisce> https://www.youtube.com/watch?v=GSGKEy8vHqg
09:39:47 <capisce> any idea on how to achieve that kind of live coding / live interaction with a running program in Haskell?
09:39:56 <SrPx> not sure why I'm surprised, though, I've asked pretty much every single teacher around and exactly 0 had more than a vague idea of what haskell/type theory/functional programming is
09:40:25 <johnw> it's an important, yet often forgotten part of computer science, clearly
09:41:39 <johnw> ocharles: hey there
09:41:40 <capisce> ah, found http://toplap.org/tidal/
09:41:50 <ocharles> johnw: hi!
09:41:53 <albeit> When defining an Ord instance, is there a way to "compare" multiple things... like "| cond1 = a `compare` b; | cond2 = c `compare` d"?
09:42:08 <albeit> Sort of a fall-through compare until an otherwise
09:42:33 <capisce> http://www.vice.com/read/algorave-is-the-future-of-dance-music-if-youre-an-html-coder
09:42:42 <joelteon> nobody is an html coder
09:42:50 <capisce> not sure why the url says that
09:42:51 <albeit> I guess I mean "| a/=b = compare a b; | c/=d = compare c d; | otherwise = compare e f"
09:42:58 <joelteon> personally, I'm a microsoft word coder
09:43:59 <Cale> Pattern families!
09:44:08 <mauke> albeit: yes, but how is the code related?
09:44:17 <mauke> ah
09:44:26 <mauke> albeit: compare a b <> compare cd <> compare ef
09:44:28 <albeit> mauke: a b c d e f are all part of a datatype
09:44:39 <johnw> after pattern families comes the pattern tribe, and then the pattern city-state
09:44:43 <mauke> +spaces
09:44:51 <albeit> mauke: What is the "<>" function?
09:44:54 <mauke> mappend
09:45:56 <albeit> Cool, thanks
09:46:59 <HairyDude> right, "window closed" seems to be a setFocus event returning Nothing
09:47:52 <jollygood> >"hi" <> " there"
09:47:59 <jollygood> > "hi" <> " there"
09:48:00 <lambdabot>  "hi there"
09:52:08 <mauke> > sortBy (comparing length <> compare) (words "the quick brown fox jumped over the lazy doge")
09:52:09 <lambdabot>  ["fox","the","the","doge","lazy","over","brown","quick","jumped"]
09:52:48 <joelteon> is that instance in base or is it a lambdabot thing?
09:52:59 <Iceland_jack> It's in base
09:53:11 <joelteon> I can't believe I've never seen it before, that's useful
09:53:12 <prophile> http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Monoid.html
09:53:24 <prophile> instance (Monoid b) => Monoid (a -> b)
09:53:33 <Iceland_jack> that's a different instance
09:53:36 <albeit> @pl: (\(a,b) -> (f a, b))
09:53:37 <lambdabot> first f
09:53:54 <joelteon> which one is it, then?
09:53:59 <Iceland_jack>     instance Monoid Ordering
09:54:03 <mauke> it's totally that instance
09:54:08 <prophile> it's a combination of the two
09:54:10 <mauke> stacked twice on top of Ordering
09:54:10 <joelteon> but compare isn't Ordering
09:54:21 <prophile> compare is a -> a -> Ordering
09:54:26 <joelteon> silly Iceland_jack, it's both of them
09:54:30 <Iceland_jack> haha yes right, it's both
09:54:43 <albeit> :t first
09:54:44 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
09:55:04 <albeit> Could anyone briefly explain what the type for first means?
09:55:16 <dzhus> If I have a final-tagless DSL, how do I reinterpret a term from embedding A to embedding B?
09:55:30 <joelteon> albeit, it helps if you rename "a" there
09:55:37 <Iceland_jack> albeit: If a function returns a monoid, it's a monoid
09:55:38 <Iceland_jack> > (show <> show) 4
09:55:39 <lambdabot>  "44"
09:55:40 <joelteon> Arrow (~>) => b ~> c -> (b, d) ~> (c, d)
09:56:21 <Iceland_jack>        (show <> show) 4
09:56:21 <Iceland_jack>     == (\n -> show n <> show n) 4
09:56:23 <albeit> So if I was using it on a pair, a would be (,) correct?
09:56:23 <Iceland_jack> > (\n -> show n <> show n) 4
09:56:25 <lambdabot>  "44"
09:56:26 <joelteon> in fact I think it would be helpful if Arrow type signatures were written that way as a convention
09:56:39 <joelteon> albeit: no
09:56:47 <joelteon> "a" might be (->), or it might be Kleisly
09:56:51 <joelteon> Kleisli
09:57:35 <albeit> Ah I see what you did with "a" there, okay
09:58:05 <joelteon> well, except ~> isn't a valid type variable name
09:58:08 <joelteon> I'll have to check the spec again
09:58:20 <dzhus> well it's kinda floppy
09:58:33 <jedai42> joelteon: it changed in ghc 7.6
09:59:02 <jedai42> joelteon: to allow for genuine type operators that don't need to start with :
09:59:32 <joelteon> varid is (small {small | large | digit | '})<reservedid>
10:00:16 <joelteon> hmm, doesn't look like you can use symbols as type variables at all
10:00:50 <jedai> joelteon: So now you can write "zipShorterFirst :: ( n < m ) => Vec n a -> Vec m b -> Vec n (a,b)"
10:01:08 <joelteon> jedai: right, but I was trying to write a type variable with a symbol name
10:01:28 <jedai> joelteon: right, you could before 7.6 but can't now
10:01:33 <joelteon> oh ok
10:01:36 <joelteon> damn
10:01:38 <HairyDude> ok, finally found it: there's an objectDestroy signal that applies to any GTK object
10:03:35 <jedai> joelteon: there was talk of allowing it if you were declaring it in an explicit forall but I don't know where we are on this subject now
10:04:13 <jedai> joelteon: You could ask on #ghc
10:05:45 <joelteon> Good idea
10:16:02 <prophile> so it seems like newtype L a = L (forall r. Monoid r => (a -> r) -> r) is isomorphic to lists
10:16:15 <prophile> does that generalise to other typeclasses for "free" structures?
10:18:02 <simpson> Hm. Should I feel bad about using `forever` in EitherT?
10:18:31 <merijn> simpson: Why?
10:18:50 <merijn> simpson: That sorta thing is the entire point of forever? :)
10:19:19 <simpson> merijn: Well, 'cause it's not actually forever. It loops only as long as its argument is Right.
10:19:22 <simpson> @src forever
10:19:22 <lambdabot> Source not found. Are you typing with your feet?
10:19:32 <MagneticDuck> is there any way to use a value (not a data constructor) as a pattern in a case statement?
10:19:39 <joelteon> @let awhile = forever
10:19:41 <lambdabot>  Defined.
10:19:55 <simpson> forever a = a >> forever a
10:20:01 <MagneticDuck> nothing is eternal
10:21:13 <albeit> Is there any way to fold through a list, but instead of the fold taking one element at a time, it takes the first two, then the second and third, etc...?
10:21:35 <joelteon> :t ap zip tail [1..10]
10:21:37 <lambdabot> (Num b, Enum b) => [(b, b)]
10:21:39 <joelteon> > ap zip tail [1..10]
10:21:40 <MagneticDuck> taa daa
10:21:41 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
10:21:44 <joelteon> you could fold on that instead
10:22:13 <MagneticDuck> I love how haskell's neat combinators and functional magic make it easy to respond to questions really stylishly
10:22:17 <albeit> Cool, thanks
10:22:34 <MagneticDuck> you have <random problem>? Here, take a handful of pointfree combinators that solves your problem elegantly
10:22:34 <joelteon> or (zip <*> tail) if you like
10:22:45 <MagneticDuck> *solve
10:23:56 <zwer_> > let xs = [1..5] in zip xs (tail xs) -- still the clearest, IMO
10:23:57 <lambdabot>  [(1,2),(2,3),(3,4),(4,5)]
10:24:23 <joelteon> well, unless people know that ap f g is \x -> f x (g x)
10:24:31 <MagneticDuck> ap zip tail === (\x -> zip x (tail x))
10:24:55 <simpson> @src ap
10:24:55 <lambdabot> ap = liftM2 id
10:25:12 <MagneticDuck> @src liftM2
10:25:12 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
10:25:28 <simpson> This works because of (->) as a Monad.
10:25:41 <MagneticDuck> well, ((->) a) is a Monad
10:25:42 <quxbam> i've started learning haskell with wikibooks since two days and I've got an error which i don't understand
10:25:51 <quxbam> why are these functions different?
10:26:01 <quxbam> barf :: [a] -> [a]
10:26:01 <quxbam> barf [] = []
10:26:01 <quxbam> barf a = a
10:26:04 <quxbam>  
10:26:09 <MagneticDuck> TERRIBLE NAME FOR A FUNCTION
10:26:12 <prophile> MagneticDuck: strictly speaking ((->) a, (>>=), const) is a monad
10:26:19 <zwer_> it could be worse
10:26:20 <quxbam> barf2 :: [a] -> [a]
10:26:21 <quxbam> barf2 a | a == [] = [] | otherwise = a
10:26:35 <joelteon> quxbam: one requires an Eq instance
10:26:38 <mauke> quxbam: because (==) is in Eq
10:26:50 <MagneticDuck> prophile: you mean, ((-> a), (.), const)
10:27:00 <quxbam> and why does the first don't need it?
10:27:07 <mauke> quxbam: because it doesn't use (==)
10:27:09 <prophile> MagneticDuck: no, you need join if you're going to define it with (.)
10:27:14 <zachsully> the first just pattern matches
10:27:19 <prophile> (.) is fmap
10:27:20 <MagneticDuck> prophile: x|
10:27:21 <zwer_> if you used null [] in the second it would not require Eq constraint
10:27:27 <MagneticDuck> I'm thinking fast and funny
10:27:31 <joelteon> pattern matching does not use ==
10:27:34 <zwer_> null a, even
10:27:34 <quxbam> interesting
10:27:39 <joelteon> it's compiler magic!
10:27:45 <benzrf> hey is
10:27:47 <mauke> quxbam: pattern matching is built in. (==) is just a library function
10:27:54 <benzrf> hey is there a library for reactive type programming
10:27:59 <benzrf> but for messing around in a repl
10:28:06 <benzrf> so no reactimating just io actions resulting
10:28:08 <benzrf> or something
10:28:30 <quxbam> thank you very much
10:28:37 <prophile> benzrf: reactimating
10:29:03 <benzrf> prophile: oh?
10:29:08 <prophile> what does that mean?
10:29:17 <benzrf> prophile: what is reactimating
10:29:19 <benzrf> pls elaborate
10:29:29 <prophile> I don't know, you said it
10:29:32 <joelteon> well, you're the one that said it
10:29:43 <benzrf> oh i see what you mean
10:29:50 <benzrf> i thought you were proposeing something
10:29:54 <benzrf> *proposing
10:30:04 <prophile> google says that's actually a word from yampa
10:30:05 <prophile> argh
10:30:20 <benzrf> well its in reactive-banana too, so
10:30:45 <prophile> the simplest FRP system is to grab the arrows package and use Automaton (->)
10:30:50 <benzrf> huh?
10:30:54 <benzrf> i dont know arrows
10:31:13 <prophile> ah
10:31:16 <prophile> they're quite good for FRP
10:31:25 <benzrf> how so
10:31:31 <zachsully> how quickly did you pick them up?
10:31:37 <benzrf> also what the hell does an arrow model anyway
10:31:52 <benzrf> some kind of functor to a Control.Category?
10:31:59 <benzrf> with tensorial strength?
10:32:19 <prophile> don't think of "arrow" taking its usual meaning of "morphism" in the context of Hughes arrows
10:32:24 <benzrf> ik
10:32:26 <simpson> benzrf: They generalize functions. That's partially why people like to write them with ~>
10:32:26 <benzrf> but...
10:32:50 <benzrf> i know that C.C models the type of morphisms in a category sharing objects with Hask
10:32:58 <benzrf> then Arrow extends that
10:33:09 <benzrf> based on the type of arr, that looks like a functor to the other cat
10:33:22 <benzrf> but then first & second look vaguely like tensorial strength?!
10:33:26 <prophile> arr is a functor from hask to your Arrow
10:33:27 * benzrf shrugs
10:33:37 <prophile> s/hask/Hask/
10:33:40 <benzrf> what's the point of first & second
10:34:05 <prophile> they give you "context" in your arrows
10:34:10 <gilligan-> evening
10:34:42 <prophile> arrows are easier to learn without fretting about category theory imo
10:35:00 <benzrf> oh nooo
10:35:02 <benzrf> no categories
10:35:08 * benzrf feels lost
10:35:58 <RyanGlScott> Is there a way to convert a Windows HANDLE to a Haskell Handle?
10:37:23 <benzrf> so Arrows are Categories with a functor from Hask
10:37:31 <benzrf> and first/second are for ease of manipulation?
10:37:36 <benzrf> its not principled?
10:37:54 <prophile> yes, it's principled, and yes it's tensorial strength
10:38:07 <benzrf> oh ok
10:38:17 <prophile> and no this isn't generally useful information when you're using them
10:38:19 <prophile> :)
10:39:49 <benzrf> ok...
10:40:00 <benzrf> what's useful about arrows
10:40:00 <albeit> Is there a cleaner way to do this without a list comprehension? "pairs = [(i,j) | i<-[1..numVertices], j<-[1..numVertices], i<j]"
10:40:03 <benzrf> inb4 not much
10:40:11 <benzrf> albeit: looks pretty clean to me
10:40:18 <mauke> looks inefficient to me
10:40:43 <mauke> j <- [i+1 .. numVertices]
10:41:15 <albeit> Aha, better
10:41:35 <benzrf> mauke: and now its monadic instead of applicative
10:41:46 <benzrf> what have u done
10:41:48 <mauke> it's lists
10:41:58 <mauke> we're already monomorphic
10:42:16 <benzrf> bah
10:42:21 <benzrf> use poolymorphic list literals
10:43:31 <akagr> Hello. I am new to haskell. I know that repeat function churns out an infinite list. So how does take 5 repeat 3 works?
10:43:48 <mauke> @src repeat
10:43:48 <lambdabot> repeat x = xs where xs = x : xs
10:43:51 <mauke> @src take
10:43:51 <lambdabot> take n _      | n <= 0 = []
10:43:51 <lambdabot> take _ []              = []
10:43:51 <lambdabot> take n (x:xs)          = x : take (n-1) xs
10:43:54 <mauke> like that, basically
10:44:03 <zwer_> that should have been: take 5 (repeat 3)
10:44:25 <akagr> zwer_: right you are
10:44:30 <simpson> > take 5 (repeat 3)
10:44:32 <lambdabot>  [3,3,3,3,3]
10:45:11 <prophile> benzrf: "things that aren't quite monads"
10:46:51 <prophile> FRP, (weirdly) XML processing, and hax involving static annotations on top of monads
10:47:23 <benzrf> uuuuuuuuh ok..
10:47:24 <fizbin> akagr: What do you mean by "how does it work"?
10:47:26 <benzrf> hmm
10:47:55 <akagr> mauke: thanks. but I know the implementation of take. What I meant was, how come repeat 3 doesn't generate an infinite list here.
10:47:57 <fizbin> akagr: That is, you could be asking a question that shows you haven't quite gotten this whole "lazy evaluation" concept.
10:48:05 <benzrf> all Functors are strong when your tensor product is (,), right
10:48:05 <mauke> akagr: it does
10:48:26 <prophile> benzrf: iirc, yes
10:48:27 <fizbin> akagr: Ah, you are asking about lazy evaluation.
10:48:31 <akagr> fizbin: yes that is exactly it
10:48:37 <benzrf> :t first
10:48:38 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
10:48:44 <mauke> akagr: evaluation goes outermost first
10:49:07 * hackagebot semigroups 0.15.3 - Anything that associates  http://hackage.haskell.org/package/semigroups-0.15.3 (EdwardKmett)
10:49:09 <zwer_> akagr the last function in the chain (in this case, take 5) controls how many items repeat 3 generates
10:49:09 <mauke> take 5 (repeat 3) does the "take" part first
10:49:22 <mauke> repeat 3 is only evaluated as needed
10:49:23 <prophile> benzrf: (***) makes the structure more obvious IMO
10:49:28 <prophile> :t (***)
10:49:29 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
10:49:38 <benzrf> how very monoidal
10:49:42 <fizbin> akagr: So at a low level, which you can sometimes get a peak at with the debugger, the result of (repeat 3) is something like (Cons 3 (*thunk*))
10:50:21 <fizbin> akagr: Where (*thunk*) stands for "stuff that requires more code to run if and when you need the answer"
10:50:32 <prophile> there's also (+++) from ArrowChoice which is similar
10:50:35 <prophile> :t (+++)
10:50:36 <lambdabot> ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
10:50:43 <prophile> just with coproducts rather than products
10:50:44 <exio4> aztek: how would you store an infinite list in finite memory? :P
10:50:55 <benzrf> :t either
10:50:56 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
10:50:58 <benzrf> hm
10:51:15 <prophile> so either is a lot like (|||)
10:51:17 <prophile> :t (|||)
10:51:18 <akagr> fizbin: so the real lazy evaluation is built into haskell? I thought there was something special about these functions
10:51:18 <lambdabot> ArrowChoice a => a b d -> a c d -> a (Either b c) d
10:51:26 <benzrf> akagr: no
10:51:28 <prophile> in fact for a = (->), they're the same
10:51:35 <benzrf> prophile: wait whaa
10:51:43 <benzrf> oh
10:51:47 <benzrf> i misundestood
10:51:51 <benzrf> *misunderstood
10:52:01 <fizbin> akagr: So then "take 3" gets the first element of the infinite list, then when it goes to get the second the computer's internal representation of (repeat 3) expands part of the thunk and the representation of "take 3" is then (Cons 3 (Cons 3 (*thunk*)).
10:52:09 <zwer_> akagr laziness (actually non-strictness) is part of language specification
10:52:53 <fizbin> akagr: In haskell, you have to jump through hoops if you want something evaluated strictly (you almost never do)
10:53:06 <akagr> fizbin zwer_ thanks. I need to wrap my head around it.
10:53:21 <fizbin> In most languages, you have to jump through hoops to get lazy evaluation, if the language syntax allows it at all.
10:53:39 <benzrf> thunk
10:53:40 <akagr> fizbin: that is exactly why it is skipping over me
10:53:41 <benzrf> i thunk too hard
10:53:44 <benzrf> now my brain is broke
10:53:50 <prophile> have a jaffa cake
10:53:54 <merijn> akagr: You are right, in haskell the built-in default is lazy and strictness is something you need to do explicitly
10:54:28 <fizbin> However, non-strictness and immutability go together quite nicely.
10:54:35 <akagr> So if I do a 1 * 2 * 3 * 0 * 4 * 5, will haskell stop after 0?
10:54:58 <fizbin> akagr: It could, I suppose. It's probably more efficient not to.
10:55:02 <mauke> akagr: depends on how (*) is defined for that type
10:55:10 <simpson> (*) is strict for many Nums.
10:55:11 <fizbin> mauke: Point.
10:55:13 <mauke> ((*) is a library function)
10:56:05 <akagr> mauke: yeah. types. got a bit of oho moment when I found you define actual operators and that they are just normal functions
10:56:08 <fizbin> akagr: One way to play with laziness is to do stuff that manipulates values that blow up if evaluated.
10:56:20 <fizbin> akagr: For example:
10:56:36 <albeit> I moved some files around, and compiling still works, but I'm getting warnings like "WARNING in hptSomeThingsBelowUs
10:56:36 <albeit>     missing module Vertex
10:56:36 <albeit>     Probable cause: out-of-date interface files
10:56:36 <albeit> ". How can I fix this?
10:56:41 <fizbin> > let a = [3, 4::Int, 5, undefined, 6] in head a
10:56:44 <lambdabot>  3
10:57:03 <monochrom> actually that only tells you non-strictness, not laziness.
10:57:04 <fizbin> > let a = [undefined, 3, 4::Int, 5, undefined, 6] in head a
10:57:06 <lambdabot>  *Exception: Prelude.undefined
10:57:18 <Schoening> I have only just started to follow this guide to get started with Haskell: http://learnyouahaskell.com/starting-out   But my command prompt keeps saying "Prelude>" rather than "ghci>" like in the guide. Why?
10:57:44 <cschneid> Schoening: it's showing what modules are imported currently, the prompt is fully customizable. Go with it for now
10:58:02 <Schoening> Alright thanks :)
10:58:16 <cite-reader> cschneid: Did we ever get customizable multiline prompts?
10:58:22 <cschneid> cite-reader: no idea.
10:58:28 <cschneid> I just change mine to a lambda. As required.
10:58:29 <monochrom> albeit: "interface files" refers to *.hi files. but I am not sure how relevant it is.
10:58:56 <akagr> fizbin: what did you do there. You queried head of a list which was undefined
10:59:11 <akagr> I understood this much
10:59:19 <fizbin> Right, and that blew up.
10:59:26 <Schoening> :set prompt "ghci> ". doh
10:59:37 <benzrf> i want idiom brackets already gosh
10:59:40 <fizbin> But first, I queried the head of a list that had a defined head, but something in the middle that was undefined.
10:59:50 <fizbin> And that was fine.
11:00:03 <johnw> benzrf: you could always write a "program formatter"
11:00:12 <akagr> fizbin: because haskell didn't need to get that far.. I get it now
11:00:27 <akagr> still this will take some getting used too
11:00:29 <akagr> *to
11:00:55 <fizbin> akagr: Right.
11:01:52 <benzrf> johnw: fie
11:03:25 <WarzoneCommand> Is there a way to write a (closed) type family that can take a type parameter that either is of kind * or of kind * -> * ? (And such that if it is of kind * -> * I can apply it to another type)
11:04:25 <johnw> WarzoneCommand: I can't see how; that's like having a kind family isn't it?
11:04:44 <edlinde> Hi all, need some help understanding the last example in : http://learnyouahaskell.com/making-our-own-types-and-typeclasses#kinds-and-some-type-foo
11:04:51 <edlinde> with Barry :)
11:05:09 <edlinde> given the data type: data Barry t k p = Barry { yabba :: p, dabba :: t k }
11:05:13 <triliyn> WarzoneCommand: I think the latest GHC has kind polymorphism, but if you only want * and * -> *, I don't think there's a way to do that
11:05:20 <edlinde> :k Barry
11:05:21 <edlinde> Barry :: (* -> *) -> * -> * -> *
11:05:21 <lambdabot> Not in scope: type constructor or class ‘Barry’
11:05:27 <monochrom> w00t kind family :)
11:05:31 <cschneid> edlinde: hop into #haskell-beginners
11:06:02 <edlinde> instance Functor (Barry a b) where   fmap f (Barry {yabba = x, dabba = y}) = Barry {yabba = f x, dabba = y}
11:06:04 <WarzoneCommand> Hmm yes somehow I was affraid of that
11:06:36 <edlinde> not getting how the fmap is being used here
11:06:45 <WarzoneCommand> hmm
11:06:54 <edlinde> cschneid: is this a beginner’s question?
11:06:58 <edlinde> :)
11:06:59 <WarzoneCommand> something like Barry may work I guess :D
11:07:43 <cschneid> :info Functor
11:07:53 <johnw> edlinde: I don't see fmap being used, but rather being defined in that last example
11:08:16 <edlinde> johnw: yeah defined .. don’t quite get how that worked
11:08:21 <edlinde> I understood the kind part
11:08:34 <edlinde> the kind of Barry and why it should be that way
11:08:48 <edlinde> but the instance definition has me baffled.. would someone care to explain please?
11:08:51 <monochrom> it is only working on the yabba field.
11:09:00 <edlinde> why though?
11:09:08 <monochrom> it's the author's decision.
11:09:17 <johnw> Functors range over a single type only, in the Barry case 'p'
11:09:36 <edlinde> monochrom: ah so its just an arbitrary decision he made when making this instance?
11:09:40 <johnw> so fmap's 'f' argument can only be applied to the value in yabba, because it's the only one that has the right type
11:09:42 <triliyn> edlinde: it has to turn a Barry t k a into a Barry t k b
11:09:43 <johnw> right
11:09:46 <WarzoneCommand> by the way
11:09:56 <edlinde> I thought it had to be understood in terms of the type definition :(
11:10:01 <WarzoneCommand> why have a third parameter in Barry
11:10:05 <monochrom> I guess it's also forced. yabba is the only field you can work on.
11:10:15 <edlinde> yep
11:10:15 <johnw> this example seems a bit gratuitous to me
11:10:17 <WarzoneCommand> and not: Barry tc p = Barry p (tc p)
11:10:27 <edlinde> man I wasted so much time trying to get it
11:10:36 <johnw> it's not time wasted
11:10:47 <johnw> it'll make the next time a bit easier to understand
11:10:52 <edlinde> it had me more confused
11:11:06 <edlinde> is there a better reference for understanding type, class, instance etc?
11:11:11 <edlinde> with better examples maybe?
11:11:14 <johnw> the typeclassopedia perhaps
11:12:31 <albeit> Is the best way to remove duplicates from a list "Set.toList . Set.fromList" ?
11:12:53 <mauke> depends on the nature of the list
11:12:55 <Denommus> edlinde: what don't you understand?
11:13:15 <albeit> mauke: Its a list of lists, :: [[Int]]
11:13:25 <edlinde> Denommus: its ok now.. I didn’t realize that the instance could be written in any way the author wishes to
11:13:29 <mauke> > nub [1 ..]
11:13:31 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
11:13:34 <mauke> can't do that with a set
11:14:05 <mauke> > nub "can do that with a set"
11:14:06 <lambdabot>  "can dothwise"
11:14:09 * hackagebot clafer 0.3.6.1 - clafer compiles Clafer models to other formats, such as Alloy, XML, HTML, Dot.  http://hackage.haskell.org/package/clafer-0.3.6.1 (mantkiew)
11:14:30 <simpson> > (S.toList . S.fromList) "can do this with a set too"
11:14:31 <lambdabot>  " acdehinostw"
11:14:50 <mauke> > nub "can do this with a set too"
11:14:51 <lambdabot>  "can dothiswe"
11:15:11 <mauke> > (map head . group . sort) "can do this with a set too"
11:15:12 <lambdabot>  " acdehinostw"
11:15:18 <johnw> aka, nub preserves order
11:15:22 <Ankhers> nub also keeps order, if that makes a difference.
11:15:24 <johnw> but is slow as a dog
11:15:35 <mauke> or lightning fast
11:15:40 <chirpsalot> johnw: some dogs are pretty fast?
11:15:50 <johnw> I guess the one in my Dad's house right now could outrun me
11:15:52 <albeit> So if I don't care about order, the S.toList . S.fromList is best?
11:15:53 <mauke> compare nub [1 ..] to S.fromList [1 ..]
11:15:54 <johnw> so don't ask me to sort your list
11:16:15 <chirpsalot> johnw: dogNub.
11:16:19 <johnw> nub is O(n^2)
11:16:22 <Ankhers> johnw: I have confidence you could sort the list faster than a dog...
11:16:52 <mauke> S.fromList is O(inf) on infinite lists
11:16:59 <johnw> touché!
11:17:13 <johnw> yeah, O(inf) algorithms are hard to convince clients of
11:18:42 <chirpsalot> Just convince them that their competitors won't be able to run it in finite time.
11:18:54 <chirpsalot> (ignoring the fact that they can't either)
11:20:58 <chirpsalot> I feel like nub might actually be faster if it were done in place in most cases?
11:21:27 <WarzoneCommand> hmm
11:21:33 <WarzoneCommand> well
11:21:40 <WarzoneCommand> I should have known
11:21:52 <WarzoneCommand> Barry is of course not promotable :(
11:22:14 <chirpsalot> I mean, it's not, but it kind of sounds ridiculous that transforming into a set and then back is faster (I mean, it is obviously).
11:22:47 <RchrdB> chirpsalot, I would be wary of using the entire output of (nub) on finite lists without checking performance against (Data.Set.toList . Data.Set.fromList).
11:22:56 <chirpsalot> Although, (map head . group . sort) is probably the fastest way?
11:23:29 <RchrdB> but the point has been made here that (take 2 . nub) is O(1) while (take 2 . Data.Set.toList . Data.Set.fromList) is O(n*log(n))
11:24:06 <chirpsalot> RchrdB: take 2 . nub is O(1)?
11:24:30 <RchrdB> Sure.
11:24:33 <mauke> only for sufficiently well spread input
11:24:36 <RchrdB> > take 2 . nub $ [1..]
11:24:38 <lambdabot>  [1,2]
11:24:39 <chirpsalot> RchrdB: what if my list has a lot of duplicates?
11:24:48 <mauke> > (take 2 . nub) [0, 0 ..]
11:24:52 <lambdabot>  mueval-core: Time limit exceeded
11:24:53 <RchrdB> Then you're doomed regardless of algorithm.
11:25:13 <RchrdB> mauke, point taken.
11:25:30 <chirpsalot> RchrdB: it's definitely not O(1) in general.
11:26:20 <WarzoneCommand> chirpsalot: the idea is that lazy evaluation will only force the evaluation of O(1) steps
11:26:46 <RchrdB> chirpsalot, yes, my bad. It's O(number of input elements before you get to the second unique element).
11:26:53 <chirpsalot> WarzoneCommand: I don't see that?
11:27:23 <WarzoneCommand> ah, yes, true
11:27:54 <johnw> if we allow an Ord constraint rather than just Eq, we can make nub 3x faster than Data.List.nub: https://gist.github.com/jwiegley/928ec32184aeb99492a3
11:27:57 <monochrom> take 1 (nub xs) is O(1) :)
11:28:14 <chirpsalot> RchrdB: isn't it just O(n^2) in general still?
11:28:19 <WarzoneCommand> chirpsalot: yes
11:28:30 <WarzoneCommand> however, if you take 2 on the result
11:28:49 <WarzoneCommand> then haskell will compute only the first 2 elements
11:28:54 <chirpsalot> WarzoneCommand: take 2 . nub is still O(n^2), though.
11:29:07 <RchrdB> chirpsalot, (take 2 . nub) is not quadratic in anything other than the number 2, which is a constant.
11:29:17 <merijn> RchrdB: wut
11:29:23 <WarzoneCommand> and to do that, it needs the subsequence up until the occurance of the second unique elmeent
11:29:31 <johnw> O(any constant) = O(1)
11:29:48 <merijn> RchrdB: nub needs to traverse the entire list at least once to find the first two things returned by nub
11:29:53 <chirpsalot> RchrdB: doesn't (take 2 . nub) [0, 0..] do an O(n) computation for each 0? I'm probably screwing up laziness.
11:29:55 <RchrdB> merijn, um, no?
11:30:06 <chirpsalot> RchrdB: wait, you might be right.
11:30:14 <chirpsalot> RchrdB: 'cuz filter.
11:30:18 <RchrdB> from memory I think the definition is: nub (a:as) = a : filter (/= a) (nub as)
11:30:25 <zwer_> merijn if the first two elements are unique it can stop right there
11:30:33 <simpson> @src nub
11:30:33 <johnw> albeit: anyway, you can use the code from my gist as a nub replacement in your case, or you can just pass it through Set.from/toList
11:30:33 <lambdabot> nub = nubBy (==)
11:30:38 <chirpsalot> RchrdB: yeah.
11:30:39 <simpson> @src nubBy
11:30:39 <lambdabot> nubBy eq []     = []
11:30:39 <lambdabot> nubBy eq (x:xs) = x : nubBy eq (filter (\ y -> not (eq x y)) xs)
11:30:39 <dfeuer> take k . nub xs is O().
11:30:42 <merijn> zwer_: Sure, so the BEST CASE comlexity is O(1)
11:30:56 <merijn> Worst case complexity is O(n)
11:30:58 <zwer_> indeed, worst case is O(n)
11:31:13 <WarzoneCommand> more specifcially
11:31:14 <merijn> So saying "nub is O(1)" is misleading
11:31:29 <chirpsalot> RchrdB: okay, I agree that it's not O(n^2) and is in fact O(n) where n is the length of the list (or when the second distinct value is encountered).
11:31:31 <WarzoneCommand> O(k) where k is the index of the second unique element
11:31:37 <RchrdB> merijn, at no point in this conversation did anybody say "nub is O(1)"
11:32:12 <dfeuer> take k $ nub xs is O(k*length xs). The *end* of the list is cheap to get once you get there, but that doesn't do anything to help amortized bounds.
11:32:43 <monochrom> . o O ( seq nub () takes O(1) time :) )
11:32:45 <sjouke> I don't know what a constructor is for type classes. I don't know what first order types and recursives types are. If anyone cares to explain these, I could pay you back with an emoticon of your choosing.
11:32:55 <WarzoneCommand> dfeuer: looking at the source it is not
11:33:07 <WarzoneCommand> it is worst case O(k^2)
11:33:19 <WarzoneCommand> err
11:33:21 <WarzoneCommand> scratch that
11:33:24 <merijn> sjouke: Type classes don't have constructors
11:33:27 <monochrom> type classes have no constructor.
11:33:30 <RchrdB> dfeuer, "length xs" there is pessimistic; a tighter bound that fits is the index of the k'th unique element.
11:33:42 <dfeuer> Maybe I got that a bit wrong.
11:33:51 <merijn> sjouke: A recursive type is a type that refers to itself
11:33:54 <WarzoneCommand> it is O(kl), where l is the rank of the kth unique lement
11:34:12 * hackagebot yesod-core 1.2.20 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.20 (MichaelSnoyman)
11:34:14 * hackagebot yesod-form 1.3.15.4 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.15.4 (MichaelSnoyman)
11:34:16 <dfeuer> @src nub
11:34:16 <lambdabot> nub = nubBy (==)
11:34:22 <dfeuer> @src nubBy
11:34:22 <lambdabot> nubBy eq []     = []
11:34:22 <lambdabot> nubBy eq (x:xs) = x : nubBy eq (filter (\ y -> not (eq x y)) xs)
11:34:54 <monochrom> I have not heard of "first order type".
11:34:55 <RchrdB> dfeuer, although your statement is entirely correct because O(f(x)) notation means "the set of all functions which grow at least as quickly as f(x)", not "the set of all functions which grow exactly as quickly as f(x)". (modulo constants) ;)
11:35:12 <linman32> in the example right, what is the best way to generate a list of the variable x?  do x <- getVar
11:35:22 <dfeuer> RchrdB: my phone doesn't have the characters to be more precise :-P
11:35:25 <te-x> hi
11:35:29 <monochrom> hmm, I guess I have heard of "higher order types", so the negation is "first order type".
11:36:16 <monochrom> higher order types store procedures. function types and object types are both higher order types.
11:36:39 <monochrom> I prefer bitcoin to emoticons for payment.
11:37:30 <johnw> monochrom: 🐰
11:37:49 <te-x> I'm sure this comes up a lot of times
11:37:55 <te-x> but I'm learning haskell
11:38:06 <te-x> ~ half-way through learn you a haskell
11:38:13 <te-x> is this a good resourse?
11:38:22 <monochrom> my font set does not have the rabbit face unfortunately.
11:38:24 <coaupiff> te-x: it's an excellent resource
11:38:25 <sjouke> monochrom: are you saying first order types are higher order types?
11:38:28 <ajcoppa> te-x: LYAH is pretty good. we have a friendly and helpful channel in #haskell-beginners that can help too
11:38:33 <negatratoron> in my humble opinion, LYAH is excellent for teaching you the synatx and grammar of haskell
11:38:38 <negatratoron> but not how to put together large programs
11:38:48 <monochrom> no, first order types are not higher order types
11:38:52 <te-x> I feel as if I'm learning to use the language, but I've no clue how it works
11:38:53 <ajcoppa> one other downside is that LYAH doesn't have exercises for you to practice as you learn the material
11:39:10 <coaupiff> te-x: make sure to check out typeclassopedia after LYAH
11:39:35 <monochrom> of all unicode pet faces, if you choose the rabbit face, I can't help but think of a reference to Donnie Darko
11:39:53 <sjouke> monochrom: i can only offer you ฿ as a compromise
11:40:18 <te-x> thanks
11:40:26 <sjouke> thanks for the help monochrom and merijn
11:41:24 <te-x> is there a place that compares something like C to Haskell?
11:41:41 <te-x> I have a hard time knowing if something like pattern recognition is expensive or not
11:41:49 <te-x> *pattern matching
11:42:03 <te-x> and pretty much everything
11:42:24 <te-x> I've no clue what the cpu is doing
11:42:37 <earthy> te-x: that's the point...
11:43:05 <earthy> you shouldn't worry about that *unless* the performance is not where you need it to be, in which case you profile.
11:43:24 <dfeuer> That nubBy looks even worse than it should be ... nub xs = go [] xs where {go _ [] = []; go seen (x:xs) = if x `elem` seen then go xs else go(x:xs)} should allocate far less.
11:44:05 <te-x> yeah I guess, Its just that something like Java or C is easier to understand if something is expensive or not
11:44:33 <monochrom> each basic pattern is O(1).
11:44:41 <dfeuer> Ah, I see. That's the Prelude def. GHC does what I wrote.
11:44:46 <linman32> what is best way to generate a list in a do statement?
11:44:47 <linman32>  do x <- getX
11:45:03 <monochrom> in most cases, GHC even does only a bit mask test for each basic pattern.
11:45:06 <johnw> generate a list in a do statement?
11:45:23 <zwer_> generate a list of what?
11:45:42 <linman32> johnw: yes. for example calling IO getX multiple times [getX, getX, ...]
11:46:03 <zwer_> :t repeatM
11:46:04 <lambdabot>     Not in scope: ‘repeatM’
11:46:04 <lambdabot>     Perhaps you meant one of these:
11:46:04 <lambdabot>       ‘repeat’ (imported from Data.List),
11:46:13 <johnw> do you want to "call" getX, or actually return a list of getX actions?
11:46:25 <monochrom> there cannot be a meaningful Haskell to C explanation because Haskell is so many levels away from C. or at least how GHC does things is.
11:46:31 <linman32> return list of getX actions, and their values
11:46:40 <johnw> and infinite list?
11:46:49 <johnw> wait, actions and their values?  hmm?
11:46:50 <linman32> size of n
11:46:54 <johnw> replicateM
11:46:54 <linman32> yes
11:47:00 <linman32> :t replicateM
11:47:02 <lambdabot> Monad m => Int -> m a -> m [a]
11:47:27 <johnw> and just plain replicate to create the actions, which seems odd
11:47:49 <monochrom> in the same way you cannot find an online explanation of from C to transistors.
11:48:30 <zwer_> linman32 are you sure you need both?
11:48:30 <fizbin> I have some code that I want to be compilable in multiple haskell environments. (That is, I have a 7.4-based haskell on the server because it's Ubuntu 12.04 LTS) How do I get around the issue of needing "import Prelude hiding (catch)" on the old ghc version, but that statement being an error on modern ghc versions?
11:48:54 <johnw> you'd need to use CPP
11:49:12 <johnw> and test for the version of base
11:49:23 <fizbin> Okay; what's the CPP magic to say "base version ..."?
11:49:26 <te-x> I'll stop worrying about costs for now then
11:49:33 <linman32> yes, I think so. GTK call to generate IO (EventBox, Image). then grabbing EventBox
11:49:44 <linman32> zwer_: ^
11:49:45 <johnw> #if MIN_VERSION_base(4, 6, 0)
11:49:45 <zwer_> I believe hiding (catch) will be silently ignored if there's no such exported function
11:50:45 <bennofs> zwer_: it will generate a warning with -Wall iirc
11:50:56 <fizbin> zwer_: That's not been my experience with other imports in the past, but I'll check...
11:51:00 <te-x> between LYAH and CIS 194, wich is better?
11:51:11 <te-x> CIS 194 is reccomended on haskell begginers
11:51:20 <monochrom> both.
11:51:31 <monochrom> the 3rd thing you read is the best.
11:51:42 <te-x> ok :P
11:51:46 <fizbin> Hrm.
11:51:52 <te-x> i'll finish lyah first then
11:51:59 <zwer_> > let xs = repeat (print 10) in sequence xs
11:52:01 <lambdabot>  <IO [()]>
11:52:04 <monochrom> you can read concurrently too
11:52:08 <linman32> johnw: seems to be working. but next hurdle is removing IO from "IO [EventBox]"
11:52:10 <zwer_> or sequence_
11:53:17 <Odda> How can I create a container where the elements are different instances of a typeclass?
11:54:01 <dfeuer> Hmm. That nub makes me think, which is always a dangerous thing. It's an accumulating filter ... filterAccumL f z xs = go z xs where {go z [] = (z,[]); go z (x:xs) = case f z x of {Nothing -> go z xs; Just a -> x:go a xs}}
11:54:19 <dfeuer> Or something like that.
11:54:49 <dfeuer> Odda: you can do that with existentials, but it's generally frowned upon.
11:55:37 <dfeuer> Odda: the experts will encourage you to consider why you want it and suggest you consider alternatives.
11:56:55 <S11001001> @google existential typeclass antipattern
11:56:57 <lambdabot> http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
11:56:57 <lambdabot> Title: Haskell Antipattern: Existential Typeclass | Luke Palmer
11:57:03 <S11001001> Odda: ^^
11:57:09 <Odda> dfeuer: Yeah, I gathered that after being pointed to Luke Palmers post on the anti pattern. It was just so tempting when the one direction is so elegant, f :: (A a) => [a], but havent been able to fold over it the other way.
11:57:17 <tac_> I've never been convinced of that being an "antipattern"
11:57:18 <S11001001> heh
11:57:23 <Odda> S11001001: thanks
11:58:31 <monochrom> (A a) => [a] will not do what you want.
11:59:44 <Odda> that probably didn't make sense. I want to foldl(x y -> apply x y) a in a method with f::(A a) => [a], but I can't pass [B, C] in to it
12:00:06 <jollygood> and luke palmer's answer to some of the comments weren't convincing either. in one he conceeded that his solution can't replace existentials in all cases
12:00:12 <Odda> (and i mean function, not method)
12:01:43 <dfeuer> I'm not convinced either, but I'm not an expert. Clearly, though, some careful
12:01:50 <dfeuer> I'm not convinced either, but I'm not an expert. Clearly, though, some careful thought should be applied.
12:02:03 <monochrom> what is the type of "apply"?
12:03:04 <Odda> monochrom: appl :: (A a) => a -> Aggregate
12:04:53 <monochrom> that can't be right. "apply x y" requires two parameters.
12:05:38 <jollygood> actually he did not even respond, he just ignored the comment. zygoloid: The translation to records seems to fail if you use even a slightly nontrivial example.
12:05:57 <jollygood> search the comment section for the rest
12:06:27 <monochrom> @type foldl
12:06:29 <lambdabot> (b -> a -> b) -> b -> [a] -> b
12:06:56 <monochrom> perhaps you really have A a => Aggregate -> a -> Aggregate
12:06:57 <Odda> monochrom: i'll create a little snippet
12:12:34 <lpaste> Odda pasted “Event” at http://lpaste.net/110733
12:13:59 <monochrom> so I think I just need app.
12:14:38 <monochrom> create this type: data E = forall a. Ev a => E_ctor a
12:15:22 <Odda> monochrom: thanks. that's the gist of mr. palmers post right?
12:16:20 <sinelaw> Peaker, yo
12:16:22 <monochrom> then you may use: foldl (\x (Ev y) -> app y x) initial_customer ys
12:16:36 <monochrom> ys must have type [E].
12:16:53 <Odda> monochrom: lovely, thanks
12:17:32 <monochrom> but I am not convinced that you need this. there are a fixed, pre-known number of things you can change to a customer's record.
12:17:49 <monochrom> I am not even convinced of the need of NameAndAddressChanged.
12:18:03 <deni> I'm having trouble doing an empyt post using wreq. can anyone help?
12:18:13 <bennofs> deni: don't ask to ask, just ask.
12:18:19 <monochrom> data Change = ChangeName String | ChangeAddress String | ChangePassword String.
12:18:38 <bennofs> deni: it probably helps if you post your code to lpaste
12:18:41 <bennofs> @where lpaste
12:18:41 <lambdabot> http://lpaste.net/new/haskell
12:19:32 <Odda> monochrom: yeah, I have that solution working, that plays rather nicely, but I got a sneaking suspicion that some of the customer events might have more than one parameter.
12:20:00 <Odda> that's why i tried the typeclass option
12:20:44 <monochrom> an event is [Change], not single Change.
12:20:47 <chaosmasttter> does someone here know some function that is a "traverse and fold" of a list?
12:21:13 <eitan_chatav> is there a way to hide instance Default [a]?
12:21:21 <monochrom> [ChangeName "monochrm", ChangePassword "black and white"] can be one "event"
12:21:33 <chaosmasttter> something with a type like: Applicative f => [a] -> (a -> b -> (b, f c)) -> b -> (b, f [c])
12:21:59 <Odda> monochrom: ah! that is a brilliant idea
12:22:08 <dzhus> eitan_chatav: why would you do that?
12:22:17 <Odda> monochrom: that solves it
12:22:32 <eitan_chatav> because I want instance Default a => Default [a] where def = [def]
12:22:46 <eitan_chatav> instead of instance Default a where def = []
12:23:09 <Odda> monochrom: thanks for the help
12:23:12 <johnw> you can just do repeat def
12:23:20 <bennofs> @ty fmap runStateT . traverse . fmap StateT -- chaosmasttter
12:23:21 <monochrom> there is also "data DraconianChange = DC { change_name , change_address, change_password :: Maybe String }" if you want to not worry about [ChangeName "monochrm", ChangeName "monomorph"]
12:23:21 <lambdabot> (Traversable t, Functor m, Monad m) => (a -> s -> m (b, s)) -> t a -> s -> m (t b, s)
12:24:33 <eitan_chatav> johnw: I want return def, not repeat def
12:24:59 <johnw> you can generate a list of defaults without needing to force it via an instance
12:25:14 <eitan_chatav> i need to force it via an instance...
12:25:23 <eitan_chatav> in this case
12:25:30 <johnw> then an easy way to do that is with a newtype wrapper
12:25:50 <johnw> newtype List a = List [a], and then give that the Default instance you want
12:26:09 <johnw> otherwise, if you really need the instance on [a], you'll need to create a different type class
12:26:15 <eitan_chatav> yeah, I guess that's the best workaround
12:26:16 <eitan_chatav> thanks
12:26:42 <eitan_chatav> eventually I'll probably break out my own type-class...Default is not quite right for my purposes
12:27:05 <johnw> Default was crafted in the depths of Mordor anyway, so it is to be avoided
12:27:05 <eitan_chatav> i need more like an Example class
12:27:20 <Peaker> sinelaw: yo
12:27:38 <johnw> eitan_chatav: does Arbitrary suite your needs at all?
12:27:38 <chaosmasttter> @ty StateT
12:27:39 <lambdabot> (s -> m (a, s)) -> StateT s m a
12:27:52 <johnw> I mean, if you just need "some inhabitant of the type I don't care what"
12:27:57 <Peaker> shachaf: haven't seen that video, bookmarked for viewing :)
12:28:15 <eitan_chatav> johnw: Arbitrary might be neat in that it would provide me with randomly generated examples
12:29:33 <chaosmasttter> @ty runStateT
12:29:34 <lambdabot> StateT s m a -> s -> m (a, s)
12:33:35 <albeit> What is the lens operation to modify a value in State monad by applying a function to it?
12:34:02 <johnw> %=
12:34:03 <edwardk> %=
12:34:07 <albeit> Thanks
12:34:19 <monochrom> is it just "modify"?
12:34:28 <deni> bennofs: umm that's the question....how to do an empty post with wreq
12:34:49 <deni> bennofs: post "http://example.com" postData
12:34:55 <deni> but i wan't postData to be Nothing
12:35:02 <deni> or empty string or whatever
12:35:20 <shachaf> monochrom: It takes a lens and modifies the part of the state the lens focuses on, not the whole thing.
12:35:49 <edwardk> l %= f = modify (l %~ f) = modify (over l f)
12:36:04 <monochrom> I see, thanks.
12:37:18 <eitan_chatav> johnw: how would I reintroduce the FromJSON instance for newtype List a = List [a]?
12:37:29 <xplat> also l %= f = zoom l (modify f)
12:37:29 <johnw> GeneralizedNewtypeDeriving should do it
12:38:00 <eitan_chatav> oh snap :-)
12:38:16 <eitan_chatav> and that will only engage those classes which I ask to derive, right?
12:38:31 <xplat> right
12:38:49 <dnkndnts> hi, i'm looking at learning haskell now, and i'm not sure if it's the right language for me or not:
12:38:54 <dnkndnts> i'm looking for a language that supports strongly-typed algebra -- in the sense that if i have two numeric types T1 and T2 (e.g., maybe meters and seconds), the operation t1 / t2 would actually return a number of type T1 / T2 (with the subsequent property that t1 / t2 * t2 would return a number of type T1).
12:38:55 <phaskell> T1: SSL for monitor.haskell.org/nagios - https://phabricator.haskell.org/T1
12:38:55 <phaskell> T2: Move wiki to rackspace vm - https://phabricator.haskell.org/T2
12:38:57 <albeit> If I have something like "foo <- gets _bar; bar %= f", I want to be able to pass bar/_bar in as a function... is there any way with lense to have the same thing be a getter and setter?
12:39:20 * hackagebot arbtt 0.8.1.3 - Automatic Rule-Based Time Tracker  http://hackage.haskell.org/package/arbtt-0.8.1.3 (JoachimBreitner)
12:39:54 <edwardk> albeit: blah l = do foo <- use (cloneLens l); cloneLens l %= f
12:40:02 <edwardk> :t (<<%=)
12:40:03 <lambdabot> (Data.Profunctor.Strong p, MonadState s m) => Over p ((,) a) s s a b -> p a b -> m a
12:40:06 <edwardk> or just
12:40:19 <RyanGlScott> Is there a way to get cabal to dump all of its configuration info?
12:40:36 <edwardk> blah l = do foo <- l <<%= f -- will grab the old copy before modifying it
12:40:46 <RyanGlScott> The config file comments out many fields, and I'm not sure what it's defaulting to in some cases.
12:41:10 <albeit> edwardk: Okay... why would "blah l = do foo <- use l; l %= f" not work?
12:41:32 <edwardk> albeit: you can also use the combinators from https://hackage.haskell.org/package/lens-4.4.0.1/docs/Control-Lens-Loupe.html
12:41:57 <edwardk> albeit: because type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t -- both use and %= instantiate f to different type arguments
12:42:39 <edwardk> cloneLens lets you work around that by deriving both from the same argument. The Loupe combinators basically bake that in. However, they aren't the default because they can't gracefully do the right thing when given a traversal, etc. instead unlike the usual combinators
12:43:08 <eacameron> threadscope is revealing what I already suspected: very, very poor work distrobution among threads. Is there a common pitfall that might've ensnared me here?
12:43:21 <albeit> edwardk: Got it, thanks
12:43:27 <eacameron> *distribution
12:43:45 <edwardk> use l      will do the right thing given any Getter, Fold, Traversal, Lens, Iso, Prism, Equality, etc.   -- use (cloneLens l) requires it to be at least a Lens, so only works for Lens, Iso, Equality basically
12:44:35 <eitan_chatav> does GeneralizedNewtypeDeriving often lead to overlapping instances? I'm getting a weird error message
12:45:30 <albeit> edwardk: Does "<<%=" have a name?
12:45:47 <edwardk> yes, (<<%=)   =)
12:45:55 <sinelaw> how to unindent in haskell-mode?
12:46:17 <sinelaw> tired of cycling through tabs line by line
12:46:29 <edwardk> its one of those things that was thrown into the operator soup because it could be done there and fit into the surrounding conventions, but doesn't make for a good combinator name
12:46:39 <tommd> Can anyone shed light on why there is not Storable instance for Storable vectors?  Just because we wouldn't get any sharing and performance would be... tricky?  It would be nice to have a Vector of Vectors (for storable vectors)
12:46:50 <edwardk> tommd: the size isn't consistent
12:46:55 <edwardk> tommd: Storable requires a fixed size
12:47:02 <edwardk> how big of a vector is it isn't visible in the type
12:47:06 <tommd> edwardk: Right, thanks.
12:47:37 <c_wraith> tommd: I have worked on a package that helps with that.  Unfortunately, I think I never updated it for GHC 7.8
12:48:03 <tommd> c_wraith: I can't escape from Vector.Storable right now so I'll be making my own wrapper for it anyway.  Thanks though!
12:48:05 <c_wraith> tommd: *all* my package does is provide a sized wrapper for a couple types with a Storable instance
12:48:30 <albeit> edwardk: Okay. So I now have "foo <- l <<%= f". And f :: a -> b. What if I instead want to use g :: a -> (b, c), where g modifies l and also retrieves something from it (if that makese sense... right now f is Map.insert and I want to change it to insertLookup)
12:48:42 <tommd> c_wraith: Nice.  I can think of decent uses for that.  I also have a vector-tynat sitting around that might be serviceable for this task.
12:48:45 <deni> anyone else using wreq having this issue?
12:49:15 <deni> I'm looking at the types but I can't really figure out anything useful
12:49:28 * hackagebot arbtt 0.8.1.4 - Automatic Rule-Based Time Tracker  http://hackage.haskell.org/package/arbtt-0.8.1.4 (JoachimBreitner)
12:50:00 <edwardk> albeit: a <- l %%= \x -> first (,) x (f x) -- i flipped the argument order on your g function to be g :: a -> (c, b)
12:50:08 <edwardk> er
12:50:15 <edwardk> albeit: a <- l %%= \x -> first ((,) x) (f x) -- i flipped the argument order on your g function to be g :: a -> (c, b)
12:50:58 <albeit> edwardk: Ha okay, maybe just stick to the the <<%= and do the second retrieval on another line
12:51:00 <edwardk> (x, c) <- l %%= \x -> first ((,) x) (f x) -- gets you the original value and the 'meta-data you wanted to read
12:51:54 <edwardk> in general %%= will take a function a -> (b, a) -- and apply it to the portion of the state targeted by a Lens s a in a state s, and given back b as extra info
12:52:07 <edwardk> but you can grab the old value while you are in there of course
12:53:07 <edwardk> > (1,2,3) & _2 %%~ \x -> (x, x+1)
12:53:08 <lambdabot>  (2,(1,3,3))
12:53:51 <edwardk> of course (%%~) = id, so that isn't very interesting in the function case =)
12:53:57 <edwardk> > (1,2,3) & _2 (\x -> (x, x+1))
12:53:58 <lambdabot>  (2,(1,3,3))
12:54:36 <edwardk> for state its fixed to functors that look like (,) e
12:54:55 <edwardk> for (%%~), well f can be any functor at all, as this is just id
12:56:14 <albeit> edwardk: I'll just stare at that for a bit to attempt to understand, but thanks ;)
12:57:46 <vanila> hGetContents: invalid argument (invalid byte sequence)
12:58:09 <vanila> when will this be fixed?
12:58:20 <vanila> in cabal install
13:01:19 <eacameron> vanila: on Windows?
13:01:38 <vanila> arch linux
13:02:22 <eacameron> vanila: Huh, I thought that was a Windows-only problem
13:02:24 <Sornaensis> ♥arch
13:02:35 <sm> vanila: usually can be fixed by ensuring LANG is set
13:02:36 <solidus-river> vanila: are you using hte haskel overlay?
13:03:52 <vanila> export LANG=en_US.UTF-8 isnt fixing it
13:05:20 <sm> what's cabal install doing ? -v3 or strace might tell
13:06:43 <vanila> i dont know
13:06:54 <vanila> its bkocking me using haskell
13:07:23 <fizbin> How do I get cabal to show me the command line it's invoking ghc with?
13:11:49 <brisbin> vanila: does that value appear in the output of locale -a?
13:12:10 <Sornaensis> what's the best library to use for writing ncurses programs in haskell
13:12:33 <benneh> is there a simple way to use SDL with haskell? I've tried installing SDL via cabal, but it just gives me an error message; I've tried installing sdl2 via cabal, but it uses a load of awkward foreign pointer business
13:13:23 <zygentoma> hi!
13:13:54 <zygentoma> I don't seem to understand; how do I remove an element from a Data.Sequence object?
13:14:01 <merijn> Sornaensis: Don't use ncurses and look into vty-ui
13:14:08 <jxv> Sornaensis, try vty instead
13:14:31 * hackagebot Genbank 1.0.0 - Libary for processing the NCBI genbank format  http://hackage.haskell.org/package/Genbank-1.0.0 (FlorianEggenhofer)
13:14:34 <rodlogic> how can I turn this into a functor? newtype DC repr a = DC { unDC :: repr } deriving (Monoid, Show) -- basically a newtype with a phantom type.
13:14:35 <jxv> benneh, you still need the SDL libraries and headers
13:14:46 <merijn> Sornaensis: vty is a pure haskell library for ncurses like terminal operations and vty-ui is a library that provides simple widgets like edit boxes, etc. for vty
13:15:09 <merijn> rodlogic: You realise the functor can only affect that phantom, right?
13:15:18 <enthropy> dnkndnts did you see the dimensional package on hackage?
13:15:26 <zygentoma> I tried: Prelude Seq> let fun (x :< a) = x
13:15:36 <merijn> rodlogic: Your newtype is basically Const :)
13:15:38 <benneh> jxv: I'm using arch and have extra/sdl installed. is that what you mean?
13:15:52 <merijn> rodlogic: http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Applicative.html#t:Const
13:15:53 <dnkndnts> no, i'll check it now
13:16:17 <jxv> benneh, what does the error say exactly?
13:16:39 <zygentoma> ah, now it works, I have to call it: fun (viewl (5 <| (singleton 8)))
13:16:43 <jxv> benneh, oh yes that's what I mean.
13:16:44 <nico-tux> hi people haskell
13:16:47 <rodlogic> merijn: yes, but it is need to help type inference.
13:17:03 <benneh> jxv: Graphics/UI/SDL/Events.hsc:56:23: / Module ‘Data.Typeable’ does not export ‘Typeable(typeOf)’
13:17:20 <merijn> rodlogic: You can just look at the Functor implementation of Const :)
13:17:38 <rodlogic> merijn: thanks
13:18:14 <enthropy> dnkndnts http://www.haskell.org/haskellwiki/Physical_units lists many other options. Proba
13:18:52 <enthropy> bly the best options are either dimensional or units
13:19:59 <dnkndnts> hmm, glancing at the summary pages, they seem to discuss mostly SI units. do they support generic units?
13:20:32 <dnkndnts> i want to be able to use generic units, i.e., dollars or vespene gas, not merely SI-derived types
13:20:50 <sm> vanila: got it working ?
13:21:17 <merijn> dnkndnts: tbh, most of the libraries for dimensions are neat but not really what I would use
13:21:27 <merijn> dnkndnts: I would normally just use newtype around Int
13:21:47 <merijn> dnkndnts: like "newtype Vespene = Vespene Int" and then use that
13:22:12 <merijn> dnkndnts: Especially since you usually don't mix units that often
13:22:36 <jxv> benneh, I don't know. This a supposed fix, maybe compare it to the github repo? http://permalink.gmane.org/gmane.comp.lang.haskell.beginners/13666
13:22:43 <jxv> is a supposed*
13:22:44 <dnkndnts> newtyping around int is something i can do in any language: i'm looking for a language where newtype Vespene(numeric) and newtype second(numeric) will result in a strongly-typed Vespene / Second unit
13:23:17 <dnkndnts> with the additional caveat that i don't want to "instantiate" the units myself (i.e., write a template<Vespene,Second> in my source code)
13:23:36 <merijn> dnkndnts: "newtype Vespene a = Vespene a"?
13:23:59 <albeit> If I have f :: a -> (b, a) and I want it to run twice, so the result is ([b], a) or just ((b,b), a), how can I do that? If theres an easier way than "(foo1, bar') = f bar; (foo2, bar'') = f bar'
13:24:30 <merijn> @unmtl State s a
13:24:30 <lambdabot> s -> (a, s)
13:24:43 <benneh> jxv: gah, so I have to download the source, edit it a bit, and then install the modified local version? is that a thing that cabal can handle?
13:25:00 <merijn> albeit: State monad? But for two invocations that may be overkill
13:25:14 <merijn> benneh: sandboxes support local modified sources
13:25:14 <jxv> you already have the packages in ~/.cabal/packages/hackage.haskell.org
13:25:19 <albeit> merijn: Yeah its just two, I'll just keep it as is
13:25:48 <jxv> also, sandbox^
13:26:32 <jxv> benneh, if that fixes the problem, send a pull request?
13:26:48 <benneh> alright, I'll look into that; thanks for the help
13:26:51 <benneh> jxv: pull request?
13:27:04 <jxv> yes on github
13:27:46 <jxv> or a patch
13:28:29 <dnkndnts> i mean i'm basically looking for a language which is 'aware' of the statement "for any numbers t1 and t2 of type T1 and T2, respectively, the operation t1 / t2 returns a number t of type T such that t * t2 will return a result of type T1."
13:28:29 <phaskell> T1: SSL for monitor.haskell.org/nagios - https://phabricator.haskell.org/T1
13:28:29 <phaskell> T2: Move wiki to rackspace vm - https://phabricator.haskell.org/T2
13:28:42 <albeit> Is there a nicer way to do this? foo = [a | condA] ++ [b | condB]
13:28:49 <sivteck> T1 T2
13:29:20 <sivteck> :I
13:29:30 <benneh> jxv: ok, I shall do
13:29:46 <jophish__> dnkndnts, Could that be done with type families?
13:29:46 <rodlogic> :r
13:30:11 <jxv> if you're lucky benneh, it might be already fix and the hackage package is outdated.
13:30:18 <jxv> fixed*
13:31:17 <benneh> jxv: the first thing I tried was 'cabal update', which I assume would fix everything if that were the case
13:32:15 <enthropy> dnkndnts check out the units package
13:32:38 <merijn> dnkndnts: jophish__: It could be done using type families and an alternate Num hierarchy, but not with the standard Num hierarchy for haskell
13:32:44 <dnkndnts> this one: https://hackage.haskell.org/package/units ?
13:32:57 <enthropy> Custom units aren't really supported by dimensional
13:36:13 <jophish__> merijn, yeah, it doesn't fit with any numeric hierarchy
13:37:11 <dnkndnts> ok, judging by the examples in the units package, i don't think this is what i'm looking for (unless the library provides a stronger abstraction than the examples are using):
13:37:37 <dnkndnts> the reason is that it explicitly specifies all derived types (i.e., speed = length / time) in all of the examples
13:41:55 <merijn> dnkndnts: I believe you can write what you want in haskell, but it'll require a non-trivial amount of custom code and disregarding most (if not all) of the existing numerical hierarchy
13:42:07 <GnuBoi> I'm writing a simple REST server which is going to be consumed by iOS app later, api should provide way to upload image which goes to a static content serving folder in the server and save it's meta data to mongodb. How should I implement this? Should I implement it as one end point which takes multipart/form-data with picture metadata as form-data
13:42:08 <GnuBoi>  or json and image as binary OR should write two endpoint, first which takes metadata and returns id and second image/jpeg or image/png endpoint handler which takes and puts the file in the contents folder. Files are going to be named databaseid.jpeg or databaseid.png.
13:42:18 <GnuBoi> I'm new to Http and stuffs
13:43:27 <dnkndnts> merijn: yeah, that's sort of the impression i'm getting. i can hack around it by trying to fight and trick the type system (i.e., using the numeric types library and representing each base type as a prime number and derived types as composites), but that's just... kind of ridiculous
13:43:45 <dnkndnts> i'm looking for a system already 'conscious' of this rule
13:44:16 <jxv> GnuBoi, I'd suggest through at warp's src, scotty's src, and the HTTP specs.
13:44:23 <albeit> I have this pattern popping up a lot: "do (a,b) <- f; g b; return a". Is there a better way to do that?
13:44:24 <jxv> looking through*
13:44:34 * hackagebot Genbank 1.0.1 - Libary for processing the NCBI genbank format  http://hackage.haskell.org/package/Genbank-1.0.1 (FlorianEggenhofer)
13:46:15 <GnuBoi> jxv:Thanks
13:46:20 <GnuBoi> Looks good
13:48:56 <merijn> dnkndnts: What? No, you can easily get a direct and simple encoding in the type system without much fighting
13:49:20 <merijn> dnkndnts: It'll just be incompatible with the current design of the Num hierarchy, so you'll need to duplicate that for your stuff
13:49:35 * hackagebot either 4.3.1 - An either monad transformer  http://hackage.haskell.org/package/either-4.3.1 (EdwardKmett)
13:49:37 * hackagebot BlastHTTP 1.0.1 - Libary to interface with the NCBI blast REST interface  http://hackage.haskell.org/package/BlastHTTP-1.0.1 (FlorianEggenhofer)
13:49:47 <merijn> dnkndnts: for example, "(*) :: a -> a -> a" is unsuitable for what you want
13:50:07 <merijn> dnkndnts: You need more like a "(*) :: a -> b -> Foo a b" type
13:50:28 <dnkndnts> yes, exactly
13:50:31 <merijn> Which is very doable in haskell, it's just not the default because it's not that common
13:51:20 <merijn> The other reason it's not default is that it'd use a fair amount of {-# LANGUAGE KitchenSink #-}
13:51:33 <dnkndnts> it seems to me the default arithmetic is a bit strange, as T1 * T1 giving type T1 is wrong for... every type i can think of o_O
13:51:34 <phaskell> T1: SSL for monitor.haskell.org/nagios - https://phabricator.haskell.org/T1
13:51:42 <dnkndnts> feet * feet is square feed, not feet
13:51:47 <merijn> dnkndnts: Why? Int * Int == Int
13:51:48 <jophish__> Amazing: "{-# LANGUAGE KitchenSink #-}"
13:51:49 <dnkndnts> seconds * seconds is square seconds, etc.
13:51:56 <dnkndnts> Int is untyped in the calculus
13:52:00 <dnkndnts> it's equivalent to ()
13:52:43 <merijn> jophish__: That's when your files start with 9 language pragma's :)
13:53:14 <jophish__> don't I know it :D
13:53:17 <merijn> dnkndnts: You're just wanting Int to be something it's not
13:53:37 <merijn> Which is ok, but the fact that Int is not what you want doesn't make Int wrong
13:54:04 <merijn> And like I said, you can implement it in haskell, but it'll be a bit of work
13:54:36 * hackagebot memexml 0.0.2 - Library for reading Meme XML output  http://hackage.haskell.org/package/memexml-0.0.2 (FlorianEggenhofer)
13:55:15 <dnkndnts> well, it depends on what you mean by "type". in a mathematical sense (the sense i'm concerned with), int is untyped, so to say int * int returns an int is not an expression on a type: rather, it's a *typless* expression
13:55:38 <dnkndnts> and it's in this mathematical sense that i'm saying operator* is then 'wrong' for every type
13:55:57 <dnkndnts> because it's a product operation that doesn't reflect that logic in the type returned
13:56:02 <merijn> That doesn't make sense, there is no notion of "types" in mathematics, other than what people happen to define ad hocly (unless you're doing like type theory)
13:56:14 <dnkndnts> i'm sure there's a language that does this, i'm just... incapable of googling the right words to find it :(
13:56:24 <monochrom> Mathematica does this.
13:56:49 <merijn> dnkndnts: The natural numbers don't have a type in math and multiplication of natural numbers returns natural numbers
13:57:19 <monochrom> ACL2 does this, too.
13:57:21 <dnkndnts> merijn: yes, that's what i just said. "number" in math is untyped
13:57:23 <merijn> So saying that "int * int = int" is somehow "wrong" or "not mathematical" is disingenuous at best
13:57:40 <dnkndnts> but to say we don't use types in math is just wrong: the pythagorian theorem is true for this exact reason:
13:57:49 <dnkndnts> the sides are *typed* numbers
13:57:56 <dnkndnts> and they follow the exact rule i mentioned at the start
13:58:01 <edwardk> merijn: also note, its not the default because type information only flows one way through the operation
13:58:07 <merijn> The only problem I see with implementing this at the type level is the need to have a numerical solver/simplifier to decide whether two types are equal :)
13:58:29 <merijn> edwardk: I have a reflection question! :)
13:58:36 <dnkndnts> yes, it's certainly a more powerful (i.e., CPU intensive) type check than the current type system
13:58:37 <merijn> edwardk: Although I think I know the answer
13:58:45 <edwardk> (*) lets you know the type of the other argument and the result from just the type of one arg
13:58:46 <edwardk> shoot
13:59:17 <merijn> edwardk: If I reify a typeclass instance for "Foo a" then it's not possible to capture that instance using, for example, "Dict (Foo a)", right?
13:59:21 <monochrom> PVS does the best/worst of both worlds. It uses types, and it uses predicate subtypes.
13:59:55 <merijn> dnkndnts: Implementing a numerical solver/simplifier in haskell's type system would be rather painful :)
14:00:11 <dnkndnts> ok maybe the term i'm looking for is "dependent types"
14:00:16 <edwardk> merijn: reflection just lets you take a term and make a type out of it, then you can reflect it back down. you can of course reflect it back down in a way that you use it to make an instance, but you need to use it in an actual instance
14:00:19 <dnkndnts> i'll have to research it
14:01:15 <monochrom> Mathematica and ACL2 do not use dependent types.
14:01:17 <edwardk> newtype M a s = M { runM :: a }; instance Reifies s (a, a -> a -> a) => Monoid (M a s) where mappend l r = snd (reflect l) l r
14:01:45 <merijn> edwardk: Right, than I'll just stick with my current approach without reflection, because I don't think it'll help me much
14:01:50 <edwardk> merijn: when you 'reify an instance' it gets tied to a quantified variable
14:02:06 <merijn> And loudly complain for the relevant patches to get into 7.10 :)
14:03:50 <dnkndnts> ok no, i don't think "dependent types" is the right word, never mind.
14:03:54 <monochrom> what you desire is also probably orthogonal to dependent types
14:04:37 * hackagebot fb 1.0.5 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-1.0.5 (FelipeLessa)
14:04:39 * hackagebot yesod-auth-fb 1.6.4 - Authentication backend for Yesod using Facebook.  http://hackage.haskell.org/package/yesod-auth-fb-1.6.4 (FelipeLessa)
14:04:40 <merijn> Albeit easy to implement using dependent types :P
14:05:58 <monochrom> Mathematica and ACL2 do things the mathematician way. No types. Only set membership aka predicates.
14:06:24 <Sornaensis> oh neato, vty
14:07:31 <monochrom> Haskell does not do it the mathematician way.
14:07:58 <dnkndnts> i think it's wrong to say "the mathematician way -- no types": the pythagorean theorem is a typed expression
14:08:01 <monochrom> Some people ask, why doesn't Haskell do things the mathematician way? Answer: because it tries to be Haskell, not Mathematica.
14:08:06 <dnkndnts> in fact, all theorems in geometry are typed
14:09:45 <dnkndnts> you can plug it into the axiom i gave at the start: sqrt(T^2 + T^2) returns a value of type T
14:09:47 <zygentoma> Which function gives me the first element in a list fulfilling a predicate?
14:09:52 <dreams> is there a tool that shows you how laziness works step by step?
14:10:03 <johnw> :t findBy
14:10:04 <lambdabot>     Not in scope: ‘findBy’
14:10:04 <lambdabot>     Perhaps you meant one of these:
14:10:04 <lambdabot>       ‘findOf’ (imported from Control.Lens),
14:10:09 <monochrom> I disagree. However, if you insist, then PVS does it. Predicate subtypes.
14:10:17 <johnw> just find
14:10:20 <johnw> :t find
14:10:21 <lambdabot> (a -> Bool) -> [a] -> Maybe a
14:10:42 <zygentoma> johnw: thx
14:11:42 <zygentoma> btw. would something like (head . filter) work as well?
14:11:43 <dnkndnts> please say more than "i disagree." this isn't a matter of opinion: provide a counterexample of any geometric theorem which violates this type axiom (and its friend, T + T always returns T)
14:11:53 <johnw> zygentoma: that would be partial, and should be avoided
14:11:59 <johnw> meaning, what if the list is empty?
14:12:01 <dnkndnts> any "theorem" which violates either of those two axioms is false
14:12:07 <johnw> or if nothing matches the predicte?
14:12:08 <monochrom> I also have a slightly less tautological answer to why Haskell doesn't do things the PVS way. Because Haskell tries to be a programming language, PVS tries to be a specification language.
14:12:23 <zygentoma> johnw: jup
14:12:31 <deni> does anyone have an example of how to process streams with wreq?
14:12:41 <deni> perhaps using pipes?
14:12:47 <dnkndnts> whether haskell should implement this or not is a matter of opinion; whether this is logically correct or not is not. this is universally true.
14:13:53 <monochrom> I disagreed because I have seen a lot of mathematicians' presentations (because I have a BSc in math) and none of them uses a type system.
14:14:18 <dnkndnts> i have a degree in math, too, and i just told you, the pythagorean theorem (and all of geometry) is a typed theorem
14:14:39 <johnw> battle of the degrees!
14:14:45 <dnkndnts> "a^2 + b^2 = c^2 where a, b, and c are the *lengths* of the sides"
14:14:45 <Zeedox> Hi, hopefully it's okay to ask elementary questions. I'm getting a type error on some trivial code I'm trying out: http://dpaste.com/2FE428V
14:14:46 <deni> XD
14:14:49 <dnkndnts> they are not arbitrary integers
14:14:50 <zygentoma> :i find
14:14:52 <dnkndnts> they are typed
14:14:57 <Zeedox> Can't figure out how to make a proper recursive data type.
14:15:09 <johnw> proper?
14:15:10 <dnkndnts> *untyped, arbitrary is the wrong word
14:15:11 <rodlogic> ok, another one of those questions ... is it possible to turn (f a -> f a) from * to * -> * ?
14:15:31 <dnkndnts> the word "length" is a type
14:15:43 <MrFlibble> dnkndnts: what is your opinion on negative zero?
14:15:57 <StoneToad> negative zero is awesome
14:16:39 <xplat> there is no opinion about negative zero.  the FACT about negative zero is it's the same as zero
14:17:06 <dnkndnts> well, the opinion is that it's present in computer engineering as a separate value, but not in math
14:17:08 <xplat> IEEE is in denial of fact
14:17:09 <MrFlibble> xplat: correct; -ve & +ve don't exist.
14:17:19 <dnkndnts> alas, engineers :)
14:17:54 <MrFlibble> I am often castigated in other language channel for saying negative zero doesn't exist.
14:18:08 <vanila> MrFlibble, it does exist
14:18:11 <dnkndnts> it depends on what you mean by "exist"
14:18:19 <dnkndnts> lol
14:18:30 <MrFlibble> -ve 0 doesn't exist, +ve 0 doesn't exist, there is only 0.
14:18:30 <monochrom> clearly, if y exists and x=y, then x exists.
14:18:45 <vanila> yes
14:19:06 <monochrom> but perhaps you can insist that x is a long way to say y.
14:19:14 <dnkndnts> it doesn't "exist" in math, but it certainly exists in my processor
14:20:19 <MrFlibble> math trumps engineering
14:20:21 <Zeedox> Ah, I see, seems I had to use concatMap instead of map.
14:20:25 <Cale> Well, -0 isn't distinct from 0 in usual mathematical treatments of what numbers are, but saying that it doesn't exist isn't quite right. As monochrom just said, if x = y and y exists, then x exists.
14:20:56 <Cale> In IEEE floating point, you have a -0 which is distinct from 0 though.
14:21:18 <dnkndnts> ya, i think the proper question is "is -0 distinct from 0."
14:21:32 <MrFlibble> Cale: nonsense.
14:21:44 <vanila> MrFlibble, Cale is correct
14:21:47 <dnkndnts> then x = y, exists -> y exists is no longer valid
14:21:51 <vanila> also it's not "nonsense" it makes perfect sense
14:21:55 <vanila> if you disagree say it's wrong
14:22:08 <Cale> > isNegativeZero 0
14:22:11 <lambdabot>  False
14:22:13 <Cale> > isNegativeZero (-0)
14:22:15 <lambdabot>  True
14:22:38 <Cale> This function can tell them apart, so they mustn't be equal.
14:22:55 <vanila> MrFlibble, you say that you get castigated for this, but maybe you are just wrong & this is a chance to learn/correct the mistake
14:22:55 <monochrom> floating point is a different story optimized for a different concern.
14:22:55 <dnkndnts> yup, on the hardware, they do exist distinctly
14:23:15 <Cale> However, equality testing will treat them as the same:
14:23:19 <dnkndnts> in accepted math, they do not
14:23:20 <Cale> > 0 == (-0)
14:23:21 <lambdabot>  True
14:23:38 <johnw> i could easily define: data Zahl = Z Bool | S Bool Number, to distinguish negative from positive, and in that system, -0 certainly exists.  So we have to talk about the type we are debating about
14:23:40 <monochrom> every way of mapping mathematical numbers to computer numbers must have problems. you can only trade off.
14:24:16 <monochrom> or, I guess, you can always scorn at every attempt for its problems.
14:24:23 <MrFlibble> Cale: if y = x then y is simply an alias for x it is not something different ergo -0 doesn't exist.
14:24:25 <Zeedox> dnkndnts: When I studied math we used -0 and 0+ plenty in analysis.
14:24:29 <Zeedox> *calculus
14:24:54 <dnkndnts> Zeedox: but were they distinct?
14:25:12 <dzhus> I have class C and instances I1 and I2. Can I reinterpret a term of type I1 back to a polymorphic value to then access it as if it was of type I2?
14:25:13 <Cale> MrFlibble: The statement that there exists x in R, x = -0 is true (where R is the real numbers).
14:25:27 <Cale> MrFlibble: It just happens that 0 = -0
14:25:47 <monochrom> does the integral of x dx from 0 to 1 exist? it is an alias to 1/2.
14:25:49 <dnkndnts> Zeedox: the issue is that in math, they're generally equivalent (i.e., indistinguishable), but on hardware, it is possible to tell the difference
14:25:55 <Zeedox> dnkndnts: Yes. But I guess you could call them limits.
14:26:13 <Sornaensis> negative zero is special ok
14:26:35 <vanila> MrFlibble, 1 + 1 does exist, it's just 2, on the other hand 1/0 does not exist
14:26:50 <monochrom> Java's floating point has (or had?) only one zero. This choice turned out to have problems too.
14:27:01 <Cale> monochrom: Oh? I didn't know that :)
14:27:16 <monochrom> like I said, all you can do is trade one problem for another, or scorn at every trade-off.
14:27:18 <Cale> > 1/0 :: Double
14:27:19 <lambdabot>  Infinity
14:27:23 <Cale> > 1/(-0) :: Double
14:27:25 <lambdabot>  -Infinity
14:27:31 <Cale> ^ Another way to tell them apart
14:27:48 <Cale> monochrom: Does it do away with -Infinity?
14:28:04 <monochrom> no
14:28:08 <Cale> hmm :)
14:28:21 <lpaste> dzhus pasted “Reinterpreting DSL terms in final tagless approach” at http://lpaste.net/8094198999860379648
14:28:35 <monochrom> look for "How Java's Floating-Point Hurts Everyone Everywhere". It was hot.
14:29:07 <dzhus> ugh, does lpaste support only bird-style lhs?
14:29:19 <monochrom> no, lpaste supports everything
14:29:35 <monochrom> oh, nevermind, probably it's exactly what you said.
14:29:58 <dzhus> ;_;
14:30:02 <monochrom> it is not like any simple colourer can recognize \begin{stuff} \end{stuff}
14:30:11 <iXeno_> it's possible that I'm messing up things here, but it seems sequence [] is [], while sequence [Just 1,Just 2] is Just [1,2]
14:30:29 <iXeno_> so that doesn't seem very consistent...
14:30:29 <dzhus> monochrom: I don't think it's much different from balanced parens
14:30:35 <monochrom> it is already hard enough to cope with {- -} :)
14:30:52 <monochrom> well, ask chrisdone to add it :)
14:31:11 <dzhus> well with regexps yes, because balanced pairs are not regular
14:31:17 <jophish__> iXeno_, I think you may have messed things up
14:31:31 <MrFlibble> Cale: dividing by zero is undefined in math
14:31:44 <Cale> MrFlibble: Right, because 0 isn't invertible
14:31:53 <Cale> Where by "in math" we mean "in a ring"
14:32:00 <Cale> or "in a field"
14:32:15 <MrFlibble> math trumps IEEE floating point.
14:32:27 <Cale> I would consider IEEE floating point to be a perfectly acceptable mathematical definition, it just doesn't fit into the usual abstractions we study in mathematics.
14:32:28 <iXeno_> jophish__: nope, I didn't
14:32:39 <iXeno_> jophish__: "sequence" from Control.Monad
14:32:53 <dnkndnts> Cale: agreed
14:33:09 <jophish__> iXeno_, ah, I completely missed 'sequence'
14:33:37 <benmachine> but IEEE reuses a bunch of your pre-existing intuitions and gets them all slightly wrong
14:33:49 <benmachine> this seems bad to me
14:34:11 <dnkndnts> benmachine: nobody's saying it isn't bad
14:34:36 <MrFlibble> I would argue that 1/0 should result in NaN not Infinity
14:34:40 * hackagebot fptest 0.2.1.0 - IEEE754r floating point conformance tests  http://hackage.haskell.org/package/fptest-0.2.1.0 (jrp)
14:34:41 <Cale> benmachine: Yeah, it would usually be improper to call operations "addition" and "multiplication" like that if they didn't satisfy anything like the usual conditions for a ring, at minimum distributivity.
14:34:56 <jophish__> iXeno_, try: sequence [] :: Maybe [()]
14:35:16 <benmachine> addition is not associative, even
14:35:27 <benmachine> it's probably commutative? if you don't look at NaNs too closely?
14:35:28 <jophish__> or in ghci: :t sequence []
14:35:44 <Cale> It's commutative
14:35:48 <Cale> Multiplication as well
14:35:50 <Cale> but that's about it
14:35:57 <dzhus> the world is shattered by IEEE frivolities
14:36:42 <Cale> MrFlibble: Why? I tend to think of Infinity, -Infinity, and NaN as ways of providing information about the failure of convergence of a numerical algorithm. If you ended up evaluating 1/0 somewhere, chances are pretty good that it was because a small positive quantity in the denominator got rounded to 0
14:37:20 <merijn> benmachine: IEEE754 was designed with one clear goal in mind
14:37:46 <dnkndnts> Cale: that's probably the best argument i've ever heard for this behavior. it's mathematically wrong, yes, but it does communicate what happened to you in the only way it can.
14:38:10 <merijn> benmachine: The ability to accurately control and predict the amount of error introduced in numerical algorithms
14:38:32 <merijn> benmachine: Everything else is secondary, now this is not what a lot of programmers want, but that's another issue entirely
14:38:40 <iXeno_> jophish__: thanks :)
14:38:47 <jophish__> iXeno_, no problem
14:38:49 <Cale> "Mathematically wrong" is something that as a mathematician I find difficult to say. Mathematics doesn't really specify a priori how floating point arithmetic ought to work.
14:39:14 <trap_exit> is anyone here using an haskell ide with the atom (github) exitor?
14:39:29 <MrFlibble> Cale: then have a bit that represents small positive quantity.
14:39:40 <Cale> It's just not the behaviour required of a field. If we don't care about IEEE 754 as providing the definition of a field, then it's fine.
14:39:59 <benzrf> trap_exit: atom looks horrifying to me
14:40:06 <Cale> MrFlibble: We have one of those, it's 0 :)
14:40:10 <trap_exit> benzrf: hmm, I was about to try to hack it via haste
14:40:14 <trap_exit> benzrf: why do you hate atom?
14:40:15 <MrFlibble> Cale: utter nonsense.
14:40:25 <benzrf> trap_exit: it looks like a reinvention of emacs using web infrastructure instead of elipse
14:40:28 <benzrf> *elisp
14:40:29 <Cale> MrFlibble: Well, in IEEE 754, that's sort of what 0 represents
14:40:37 <trap_exit> benzrf: that is exactly what I want
14:40:39 <benzrf> i HAVE heard terrible things about elisp
14:40:45 <trap_exit> emacs written in the web
14:40:46 <trap_exit> since elisp sucks
14:40:46 <benzrf> trap_exit: why the fucking would you willingly work with web
14:40:55 <johnw> benzrf: language, please
14:40:57 <trap_exit> because it's portable
14:41:02 <trap_exit> johnw: I don't mind
14:41:04 <MrFlibble> Cale: 1.0 - 1.0 is not a "small positive quantity".
14:41:17 <trap_exit> benzrf: portability, javascript > C
14:41:24 <benzrf> eesh
14:41:27 <trap_exit> benzrf: uniform UI via DOM tree
14:41:32 <benzrf> eeeeeeesh
14:41:50 <trap_exit> have you tried doing UI via Qt, Gtk, or WxWidgets ?
14:41:55 <trap_exit> Dom + SVG is so much better
14:42:38 <johnw> trap_exit: it's not about if you mind or not, but if the channel creates a pleasant atmosphere for all
14:43:12 <kvanb> ^ yes
14:43:25 <albeit> If I want to begin learning category theory, are there any recommended books / articles?
14:43:28 <lpaste> dzhus pasted “Reinterpreting DSL terms in final tagless approach” at http://lpaste.net/110762
14:43:35 <kvanb> and some people have it up at work
14:43:38 <trap_exit> johnw: hmm, given what people read in comments (especially linux kernel), is cussing all that bad for programmers? :-)
14:43:50 <johnw> trap_exit: it's bad for #haskell, is all that I care about :)
14:43:53 <kvanb> so if it's lousy and they're afk from desk or whatever not a good look
14:44:05 <Cale> MrFlibble: But 2^(-1024) "is", and it's semantically equal to that quantity in double precision floating point, along with many others.
14:44:31 <Cale> MrFlibble: The point being that any operation which would produce a positive quantity too small to represent will also produce 0
14:44:53 <trap_exit> johnw: hmm, I can understand why something like "trap_exit: you're a fucking idiot" is bad for #haskell, but where is the harm in "trap_exit: your idea is fucking stupid" ? :-)
14:45:00 <monochrom> albeit: I suggest Benjamin Pierce's "for computer scientists"
14:45:23 <johnw> trap_exit: language like that is offputting to some; we're a big channel, and we hope to include lots of different people here
14:45:37 <trap_exit> johnw: alright, I'm done bugging you about this :-)
14:45:40 <johnw> :)
14:45:41 <trap_exit> thanks for clarifying
14:45:54 <monochrom> I also suggest Fokkinga's "calculational approach", but I guess most people don't want calculational.
14:45:56 <johnw> it's not anything you said that I was taking issue with
14:46:10 <monochrom> also, Pierce's and Fokkinga's have different coverages.
14:46:55 <monochrom> also, I hope that I spelt Pierce correctly :)
14:47:00 <johnw> you did!
14:47:30 <albeit> monochrom: Thanks! Just checking out Amazon for the Pierce book, and someone recommended Barr and Well's "for Computer Science". Have you red that?
14:47:36 <albeit> *read
14:47:44 <Cale> Peirce is the ((P -> Q) -> P) -> P guy
14:47:52 <monochrom> I haven't. I don't have patience for a huge book
14:48:08 <johnw> you mean the Triples book?
14:48:15 <monochrom> I don't know
14:48:44 <dzhus> albeit: there's also a fun book http://www.cs.man.ac.uk/~david/categories/book/ it uses ML
14:48:44 <albeit> johnw, monochrom: Specifically this http://www.math.mcgill.ca/triples/Barr-Wells-ctcs.pdf
14:48:57 <johnw> ah, that on
14:48:59 <monochrom> but I found that I don't even have patience for the slow pace in Conceptual Mathematics
14:49:05 <johnw> I haven't read that yet
14:49:06 <agatam> albeit: Steve Awodey's book is also excellent, there are some videos online (from Oregon Summer School)
14:49:11 <Cale> albeit: If you're looking for a book on category theory, I highly recommend the one by Awodey
14:49:54 <monochrom> (I fully agree that for its purpose, Conceptual Mathematics must take baby steps, just like GEB.)
14:51:13 <monochrom> why is it called the Triples book? they even make the URL that way.
14:51:25 <johnw> that's another book
14:51:47 <johnw> Triples, Toposes and Theories
14:51:54 <johnw> (swap the first two)
14:53:14 <dzhus> is it pretentious to say Topoi instead?
14:53:43 <Cale> That book could use a revision to modernise it a bit, but it might lose the alliteration in its title.
14:53:50 <dnkndnts> ok, so i'm checking out PVS, and here is something awesome I found in their faq (located at http://pvs-wiki.csl.sri.com/index.php/FAQ):
14:53:53 <dnkndnts> "Sometimes assert does not recognize trivial facts such as 2 <= 14. This is a known problem with the current decision procedures"
14:54:02 <dnkndnts> that just makes me... happy
14:54:05 <monochrom> TTT > MTT :)
14:54:22 <Cale> dzhus: I don't think so
14:54:31 <Cale> dzhus: Seems pretty common as well
15:01:06 <agatam> Is there any nicer, shorter (and possibly aimed at a bit more experienced users) cheatsheet than http://cheatsheet.codeslower.com/CheatSheet.pdf ?
15:01:55 <merijn> Cale: Awodey is okay, but it's very much aimed at mathematicians in the sense that he tends to skip facts that follow from more general definitions and then mere mortals like me spend 40 minutes trying to find out why assumption X holds
15:02:23 <Cale> merijn: hm, examples of that?
15:03:03 <merijn> Cale: I'd have to look it up again
15:03:05 <dzhus> agatam: http://dev.stephendiehl.com/hask/
15:04:32 <Cale> merijn: I know that one of his goals was to make it at least somewhat readable for nonmathematicians as well. It might be worth pointing out cases of that to be fixed in later versions :)
15:04:32 <merijn> Cale: Well, one example, not specific to Awodey but CT in general, I spend like weeks being confused due to not realising arrows had an "identity"
15:05:05 <Cale> Isn't that part of the definition of a category?
15:05:09 <albeit> merijn: Did you move to another book then?
15:05:26 <merijn> Cale: Not explicitly
15:05:30 <Cale> Er
15:05:36 <Cale> Maybe I don't know what you mean then :)
15:05:39 <merijn> Cale: I was so confused by the monoid category
15:06:05 <Cale> You're not talking about the identity arrows id_A: A -> A
15:06:12 <agatam> merijn: I'd blame Lars for your confusion, not Awodey :P
15:06:21 <Cale> Who is Lars?
15:06:21 <merijn> Cale: The fact that there can multiple arrows A -> B and there is some oracle that can be compared whether f : A -> B and g : A -> B are the same arrow
15:06:34 <merijn> agatam: I was confused about that before Lars' lecture
15:06:59 <merijn> Cale: i.e. arrows have some form of "identity" that can be compared
15:07:04 <Cale> merijn: Oh, er, well, there isn't an oracle as such, but you're always allowed to ask that question of any mathematical objects.
15:07:06 <vanila> there's no oracle
15:07:07 <agatam> dzhus: thx, that's actually neat :) (although not as short as I was hoping..)
15:07:07 <merijn> Cale: This is not something that's obvious to me
15:07:30 <Cale> It might still be undecidable (even formally) whether two given arrows are equal or not.
15:07:38 <Cale> But you're definitely allowed to ask
15:07:39 <shachaf> merijn: I remember this.
15:07:58 <vanila> = is a relation, rather than a function
15:09:23 <rodlogic> is there a generic way of composing two functors? compose :: f a -> f a -> f a?
15:09:39 <Cale> rodlogic: const
15:09:41 <shachaf> That's only one functor.
15:09:50 <shachaf> (The functor is f.)
15:09:51 <Cale> And yeah, the only functor there (if any) is f
15:09:59 <dzhus> My question is: http://lpaste.net/110762
15:10:10 <Cale> rodlogic: Maybe is a functor, Just 5 isn't
15:10:31 <vanila> rodlogic, you can't like "merge" or append or add them
15:10:47 <vanila> if f was a monoid you could
15:11:05 <shachaf> f is the wrong kind for Monoid
15:11:58 <rodlogic> vanila: I see. So the only option is to resign to a Monoid or deal with a concrete type e.g. [a] -> [a] -> [a] ?
15:12:09 <vanila> yes
15:12:18 <rodlogic> or add the Monoid constraint
15:12:22 <rodlogic> k
15:12:30 <shachaf> There are lots of options.
15:12:41 <shachaf> Alternative is a class that has a method with the type you want.
15:13:18 <rodlogic> shachaf: I really want an append f a ++ f a  or somethinglik that
15:13:50 <shachaf> The first step is to figure out what that means.
15:15:20 <Cale> rodlogic: Which functor in particular are you concerned with?
15:16:18 <f-a> You'll get a warning with -Wall, so one more reason to turn on -Wall <-- whoever wrote this is a poet (and correct)
15:16:26 <rodlogic> it could be [a], but I would like to keep the choice abstract
15:16:38 <Cale> f-a: Not all the things that -Wall warns about are sensible to warn about though.
15:17:09 <rodlogic> What if I do something like : (Monoid (f a), Functor f) => f a -> f a -> f a
15:17:22 <f-a> Cale: that seems <140char, @haskelltips awaits you
15:18:28 <triliyn> rodlogic: that's not any different from Monoid a => a -> a -> a
15:18:29 <Cale> rodlogic: You could do that, sure
15:18:46 <Cale> Yeah, are you actually using the Functor instance there?
15:19:06 <vanila> you don't need to write a type signature
15:19:15 <vanila> just use the operations you want and haskell will actually infer it for you
15:19:18 <triliyn> or well, it's different, but strictly less general
15:19:23 <vanila> for example the monoid plus operation is mplus
15:19:27 <rodlogic> now, what if I woud also like to enable effectful impls there in the concat/append?
15:19:30 <iXeno_> so, "mapM (\a -> Just a) [Just 1]" results in Just [Just 1], but the type of mapM is Monad m => (a -> m b) -> [a] -> m [b]
15:19:35 <iXeno_> I can't get that to add up
15:19:45 <iXeno_> ahw fuck
15:19:46 <iXeno_> forget it
15:20:00 <Cale> rodlogic: Define a monoid which also describes effects?
15:20:38 <Cale> rodlogic: There's nothing about Functor which says "effects"
15:20:48 <Cale> It just means there's a suitable implementation of fmap
15:20:57 <merijn> > mapM (\a -> Just a) [Just 1]
15:20:58 <Cale> If you're not using fmap, you don't need the Functor constraint
15:20:59 <lambdabot>  Just [Just 1]
15:21:15 <merijn> oh, yeah, duh
15:21:58 <Cale> rodlogic: If you mean real effects, then you probably want to involve IO somehow, and that will restrict things a lot more.
15:22:05 <rodlogic> I would like to support pure and effectfull representations. So maybe I should use an applicative?
15:22:25 <Cale> There's nothing about Monoid which restricts you to not be effectful
15:23:03 <Cale> Monoid is just "there is an associative binary operation on these things, and it has an identity element"
15:23:22 <Cale> Those things could be descriptions of effects to be performed, like IO actions
15:24:00 <c_wraith> instance Monoid (STM a) where mappend = mplus ; mempty = mzero
15:24:05 <rodlogic> see this http://www.cs.nott.ac.uk/~gmh/wgp01/hinze-paper.pdf
15:24:17 <c_wraith> I've used that instance before - it's not just theoretical
15:24:27 <lhuang7`> Try to install yesod-bin and run into this error...anyone else is getting this too. transformers-0.4.1.0 was excluded because ghc-7.8.3 requires an installed
15:24:28 <lhuang7`> instance of transformers ==0.3.0.0
15:24:45 <Cale> rodlogic: What about it?
15:24:54 <rodlogic> it defines an Apply typ class that is generic and one instantiation that is pure and another that is in the IO:  (Apply F String A) ⇒ F String → A vs (Apply F (IO ())A)⇒F String →A
15:25:21 <rodlogic> Cale: that was my starting point
15:25:23 <merijn> rodlogic: How does this relate to the use of Monoid?
15:25:48 <rodlogic> well, you can compose the Apply, which means compose the Functor
15:26:02 <Cale> rodlogic: Maybe you should give us some more context, like put your code on hpaste or something. :)
15:26:36 <rodlogic> see (⋄) :: (Functor F,Functor G) ⇒ F String → G String → (F · G) String
15:27:14 <rodlogic> the paper uses this to compose two Apply's
15:28:15 <rodlogic> Cale: I have been chewing more than I can at this point, but that is ok. I am learning along the way.
15:29:46 * hackagebot cuda 0.6.5.0 - FFI binding to the CUDA interface for programming NVIDIA GPUs  http://hackage.haskell.org/package/cuda-0.6.5.0 (TrevorMcDonell)
15:30:01 <Cale> rodlogic: This is basically just some fancy type level hackery to be able to write format specifications and have the remainder of the arguments worked out automatically.
15:30:38 <rodlogic> Cale: I want: a final/tagless encoding of an abstract syntax (I want to keep the underlying representation open, I want to use polyvariadic functions to 'append' (I know this may not be the best choice here, but I would like to get it working). And I want to allow for pure and effectful representations
15:31:29 <jollygood> dnkndnts re: your previous question, did you check out F#? it his units of measure built into the language.
15:31:34 <rodlogic> At the end of the day I want a surface syntax such as: http://lpaste.net/110764
15:31:38 <Cale> Do it with binary append first.
15:32:16 <Cale> Then figure out how to do the extra hackery on top of that to make it variadic
15:32:27 <rodlogic> I also want to add additional constraints. For example: you cannot add a div inside a paragraph
15:32:46 <Cale> Yeah, that should be hard enough without the variadic bit
15:32:53 <vanila> rodlogic, that's lisp
15:32:57 <Cale> (you can use phantom type parameters for that)
15:33:12 <rodlogic> I got that working by taking Oleg's HSXML impl as a starting point
15:33:20 <rodlogic> it uses a monoid
15:34:07 <Cale> Or: do it with list-wise append
15:34:10 <dnkndnts> jollygood: checking it out now, one minute
15:34:10 <rodlogic> so a Builder that deals with the polyvariadic function class hackery. A newtype that helps the type inference and a phantom + relational class constraint that adds constraints
15:34:11 <vanila> rodlogic, you should embed lisp syntax somehow & write an interpreter that produces HTML from it rather than this complex and confusing polyvariadic stuff
15:34:37 <Cale> i.e. just define each of your things-which-would-be-variadic to instead take a single argument which is a list
15:35:04 <Cale> If you can do that, then the transformation to variadic should be as easy as it'll ever be. It'll still make a mess of things
15:35:33 <jollygood> dnkndnts this is a good intro to them. http://blogs.msdn.com/b/andrewkennedy/archive/2008/08/29/units-of-measure-in-f-part-one-introducing-units.aspx
15:35:38 <Cale> But at least it'll be uniform then
15:35:43 <rodlogic> All this is already working with a simple String representation.
15:36:00 <dnkndnts> jollygood: ya, just read it. that actually looks like it... might be exactly what i want.
15:36:02 <rodlogic> the fragment in the hpaste generates an xml string
15:36:32 <vanila> rodlogic: for example http://lpaste.net/110764
15:36:33 <Cale> rodlogic: Yeah, there's a reason why I'm suggesting that you do the other part first :)
15:36:35 <rodlogic> there is simple type class DOM with a few methods: emitAttr, emitElem, emitLiteral
15:36:36 <dnkndnts> jollygood: i've never heard anything about F# in my life -- it's really surprising to me that they would happen to have this, especially when it's apparently quite rare in programming languages
15:36:40 <vanila> I missed some commas
15:36:42 <dnkndnts> jollygood: thanks!
15:37:06 <jollygood> dnkndnts welcome!
15:37:20 <rodlogic> the problem is that I now want to create a representation that does IO and creates a proper tree
15:37:32 <Cale> rodlogic: Modifying programs which use type class hackery to define variadic functions is trickier than it needs to be
15:38:09 <Cale> rodlogic: So, it'd be better to do the other stuff first, and then at the end decide if you want to go through with this translation to make the code unmaintainable
15:38:42 <lpaste> mgaut72 pasted “AST.hs” at http://lpaste.net/110766
15:38:46 <rodlogic> vanila: yes, that could be an option. I do want to use a final encoding though.
15:38:52 <vanila> why?
15:39:24 <rodlogic> because the same syntax will be used on Data.Tree, JSON and Browser DOM
15:39:34 <mgaut72> i have a question about representing a formal grammar as haskell types.  I pasted what I have at http://lpaste.net/110766  the grammar is here; http://www.cs.arizona.edu/classes/cs453/fall14/DOCS/cminusminusspec.html#syntax
15:39:42 <vanila> just use a typeclass to let interpret target different machines
15:39:58 <vanila> interpret :: Interpret i => Lisp -> i
15:40:08 <merijn> mgaut72: What's the question? :)
15:40:54 <mgaut72> my question is: there are sections of repeated code (such as the definition of assg) that needs to be both an expression and a statement.  I made an assignment type, but that seems clunky
15:41:15 <rodlogic> all this is working (statically typed HTML, polyvariadic functions, tagless encoding, etc) http://lpaste.net/110767
15:41:41 <merijn> mgaut72: Why?
15:41:59 <merijn> mgaut72: You could just use a tuple or something, but all-in-all it'll look mostly the same
15:42:26 <Cale> Doesn't seem so clunky to me
15:42:27 <merijn> mgaut72: You could do "type Assignment = (Variable, Expression)", but honestly it's not really any better
15:42:30 <mgaut72> the type of an assign statement is Assign (Assignment (...))
15:42:31 <rodlogic> The piece that is troubling me is the IO
15:42:38 <mgaut72> ok
15:42:54 <Cale> mgaut72: You mean the value of an assign :)
15:42:56 <rodlogic> and being able to define a protocol for the DOM type class that I can use to create a tree or use the browser dom to create elements/attrs
15:43:03 <mgaut72> oops, yes
15:43:05 <merijn> mgaut72: Well, you could make it "Assign Variable Expression" and use tuples elsewhere
15:43:07 <Cale> mgaut72: The type of an assign statement will be Statement :)
15:43:27 <merijn> mgaut72: anyway, I wouldn't worry to much about it
15:43:36 <rodlogic> right now the protocol is  'mappend' and the emitXXX
15:43:46 <Cale> mgaut72: But remember that presumably this representation isn't optimised for humans to type in. That's what your parser is for.
15:44:09 <rodlogic> one question is how to have the same abstract syntax and run it in IO?
15:44:10 <Cale> mgaut72: You just want to choose the representation so that it's easy for your compiler to work with.
15:44:28 <mgaut72> merijn: Cale: thanks.  I am doing a compilers class in haskell, while the rest of the class is doing the traditional flex/yacc stuff.  I just wanted to make sure I was on the right track, since im off on my own as far as the class goes
15:45:11 <Cale> rodlogic: Well, what does "run it in IO" mean?
15:45:29 <merijn> mgaut72: You'll probably have a much easier time than the rest :p
15:45:45 <merijn> mgaut72: I say this having TAed both the compiler and FP courses at our uni ;)
15:46:02 <Cale> rodlogic: It's easy enough to use liftM2 (++) to combine IO actions which produce String values.
15:46:05 <yyttr3> Does something special need to be done to load and get the contents of unicode files? I can't seem to get the contents of a file with unicode characters.
15:46:05 <merijn> mgaut72: Implementing compilers in haskell (and any ML style language, for that matter) == easy mode
15:46:06 <mgaut72> I was just bothered by this representation since writing the test cases seemed really clunky.  But I guess when I get beyond the parsing phase, having those extra types might be usefil
15:46:09 <rodlogic> The implementation of DOM, i.e. the emitXXX has to run in the IO monad since creating browser elements/attributes require IO. But when rendering the same tree on the server you will just use a pure tree
15:46:54 <rodlogic> Cale: but will the bubble IO through the tagless syntax?
15:46:57 <mgaut72> merijn: FP is a bit taboo at my school, except a small group (that convinced me to do it in haskell, Im still a bit of a newb) so its sort of "hard mode" in that I have limited internal resources
15:47:28 <cite-reader> yyttr3: Oh boy. What encoding?
15:47:59 <yyttr3> ó is the only odd character in the file, and if I omit it, the code works.
15:48:10 <cite-reader> Neat. What encoding?
15:48:17 <mgaut72> anyway, thanks merijn and Cale
15:48:39 <Cale> yyttr3: The default behaviour of, e.g. readFile, is to try to read your file using the encoding specified by the system locale.
15:48:50 <Cale> yyttr3: On most Linux setups, this means UTF-8
15:49:39 <yyttr3> Thank you. The Error i'm getting is "hGetContents: invalid argument (invalid byte sequence)"
15:49:41 <kvanb> Cale: thanks for helping me visualise liftM2 better
15:49:56 <kvanb> I always have trouble with liftM(n)
15:50:14 <Cale> yyttr3: hSetEncoding :: Handle -> TextEncoding -> IO ()
15:50:23 <kvanb> but now I think I can see that liftM ~ fmap
15:50:42 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.7.0.1/System-IO.html#t:TextEncoding lists a bunch of useful values of type TextEncoding
15:50:56 <yyttr3> from  do (handle <- openFile f ReadMode) (hSetEncoding handle utf8_dom) (contents <- hGetContents handle)
15:51:03 <yyttr3> I know about hSetEncoding
15:51:08 <yyttr3> I get the same error however.
15:51:16 <merijn> Well
15:51:21 <Cale> You mean utf8_bom
15:51:22 <merijn> Are you actually getting utf8?
15:51:29 <Cale> and is the byte order mark there?
15:51:31 <yyttr3> Yes, bom.
15:51:46 <yyttr3> Byte order mark?
15:52:00 <Cale> Well, that's what bom stands for
15:52:03 <cite-reader> Who wrote a UTF8 file with the BOM? That's badwrong.
15:52:22 <Cale> It should look like 0xEF 0xBB 0xBF at the start of the file
15:52:37 <yyttr3> How would I know how it looked?
15:52:44 <yyttr3> How could I see that
15:52:46 <Cale> od -x myfile?
15:52:54 <cite-reader> Hexdump, or a related program.
15:53:55 <yyttr3>  4641    2c56    4220    464b    4652 Is the start of the file with (od -x file | less)
15:54:03 <Cale> okay, then there's no BOM
15:54:37 <Cale> (and as it happens, utf8_bom should be happy even if the BOM is missing, so that's not likely the issue)
15:55:23 <yyttr3> What is BOM exactly? I'm missing a lot of information that I didn't know existed xD
15:55:55 <cite-reader> The Byte-Order Mark is an innovation for UTF-16 and UTF-32, which informs the decoder what order the bytes of each code unit are in.
15:56:20 <hpc> it uses a byte sequence that is only a valid character in one direction
15:56:26 <hpc> something like FFEF iirc
15:56:45 <Cale> It's EFBBBF
15:56:49 <RchrdB> cite-reader, MS Windows nodepad.exe famously puts the UTF-8 encoding of U+FEFF at the start of any text file saved with the UTF-8 encoding.
15:56:51 <lpaste> monochrom annotated “Reinterpreting DSL terms in final tagless approach” with “one solution” at http://lpaste.net/110762#a110769
15:56:52 <hpc> of course it is
15:57:00 <rodlogic> vanila, Cale, shachaf, merijn: I need to crash now. Thanks for the points, warnings, ideas. I will continue another day.
15:57:05 <rodlogic> pointers
15:57:11 <cite-reader> RchrdB: Yeah, I know, that was a rhetorical question.
15:57:25 <RchrdB> cite-reader, oh, sorry! ^_^
15:57:36 <cite-reader> It's fine, it's obviously hard to tell.
15:57:39 <yyttr3> So would it just be (hSetEncoding handle utf8)? If so that doesn't work either.
15:58:15 <cite-reader> yyttr3: we still don't actually know what encoding your file is in.
15:58:23 <monochrom> @tell dzhus http://lpaste.net/110762#a110769
15:58:23 <lambdabot> Consider it noted.
15:58:31 <yyttr3> How do I figure that out?
15:59:00 <cite-reader> I don't know of a principled way to do it.
15:59:30 <cite-reader> Whenever I run into this kind of thing, I end up trying encodings and then inspecting the output more or less by hand.
15:59:56 <cite-reader> 90-something percent of the time, it ends up being CP1252, but I'm a web dev so.
16:00:56 <RchrdB> yyttr3, there isn't any perfect way, but it's possible to guess the encoding of a text file that's long enough by looking at statistics of which bytes/byte sequences appear how often.
16:01:00 <merijn> cite-reader: There is no principled way to do it
16:01:11 <merijn> cite-reader: There's only trial and error + guessing if you don't know the encoding
16:01:20 <cite-reader> Yeah, I wasn't holding out much hope that there was.
16:01:27 <sveit_> is there a foldable instance for something like "newtype Pair a = (a,a)"?
16:01:50 <sveit_> in fact, is there a package that provides a repository of foldable instances for tuples of large length?
16:02:07 <merijn> I doubt it, since tuples are generally not foldable
16:02:20 <sveit_> merijn, sorry, i meant homogeneous tuples
16:02:24 <sveit_> which should be foldable, no?
16:02:38 <RchrdB> yyttr3, it does amount to just guesswork though, because you can never be sure that the user didn't actually want to write "Â£" on purpose.
16:02:49 <exio4> if it is homogeneous, why not a list?
16:03:16 <yyttr3> Alright, where can I at least find an enumeration of encodings supported by hSetEncoding? I'm looking at the source code on hackage and I can't make any sense of it.
16:03:17 <sveit_> exio4, because sometimes it is useful to have length restriction encoded in the type, for example?
16:04:51 <RchrdB> yyttr3, http://hackage.haskell.org/package/base-4.7.0.1/docs/System-IO.html#t:TextEncoding - shows "latin1", "utf8", "utf8_bom", "utf16"...
16:05:04 <merijn> sveit_: But then why not use lists?
16:05:13 <yyttr3> Thank you.
16:05:29 <merijn> sveit_: Time to learn GADTs and DataKinds and enforce lengths in the type system for your lists :D
16:05:42 <Enigmagic> merijn: he'd still have to define a foldable instance :P
16:06:04 <sveit_> i was hoping i could use something built-in :)
16:06:16 <yyttr3> It was encoded in latin1 for some reason.
16:06:19 <Enigmagic> sveit: it can be done semi-built in using GHC.Generics
16:06:23 <yyttr3> Thanks everyone!
16:06:23 <sveit_> is there a conceptual reason that a list is better than a tuple for homogeneous collections?
16:07:13 <merijn> sveit_: tuples have cheaper indexing (i.e., direct rather than pointer hopping)
16:07:14 <sveit_> also, is there some reference for enforcing list lengths in the typesystem? i've seen some stuff on peano numbers in the typesystem, but that is definitely overkill for me (i think)
16:07:32 <sveit_> merijn, great! performance is also important to me, so another reason to use tuples instead of lists
16:09:08 <RchrdB> sveit, there are a bunch of libraries on Hackage that implement lists with lengths tracked in the type system.
16:09:31 <RchrdB> I'm afraid that I don't know enough about any of them to recommend any of them over any other.
16:09:58 <sveit_> RchrdB, could you name a few so that I could just look at implementations?
16:10:04 <RchrdB> e.g. https://hackage.haskell.org/package/Vec https://hackage.haskell.org/package/fixed-list and https://hackage.haskell.org/package/tagged-list
16:10:40 <RchrdB> sveit, ^ I dug up the above by going to https://hackage.haskell.org/packages/search?terms=list and then picking out all the ones with "length" in the description.
16:10:46 <merijn> sveit_: Actually
16:10:52 <merijn> sveit_: You should look at Vector
16:11:03 <merijn> sveit_: That should have a foldable instance *and* be faster than tuple
16:11:13 <sveit_> Vector is faster than tuple?
16:11:26 <merijn> sveit_: If you intend to fold over the vector I would assume so
16:11:27 <sveit_> for 2-element or 3-element objects?
16:12:07 <RchrdB> sveit, I'd note that as I understand it, having lengths expressed in the type system is a bit difficult in Haskell, because it's not designed from the ground up as a dependently-typed language, though you can more or less implement varying amounts of DT features by turning on either lots or LOTS of GHC's type system extensions.
16:12:09 <merijn> Try and see :)
16:12:24 <merijn> RchrdB: Having lengths expressed in haskell is easy
16:12:29 <yyttr3> Are Monoids useful very often except in the canonical cases? I've been trying to create my own Monads for a while and the code always becomes needlessly complex.
16:12:40 <yyttr3> Monads I mean*
16:12:52 <RchrdB> yyttr3, you accidentally asked two different questions there. Monoid instances are pleasingly easy to use. ;)
16:12:54 <merijn> RchrdB: The tricky bit is indexing, since you can't use normal ints for indexing :)
16:13:11 <merijn> RchrdB: See https://gist.github.com/merijn/39dc86e345e87276c523 as simple example
16:13:15 <yyttr3> I know, i'm tired. I meant Monad :)
16:15:29 <sveit_> this is a frivolous question, but do people that follow the issues think that haskell will be superseded by dependently typed languages at any point in the near future?
16:15:30 <RchrdB> yyttr3, it varies. e.g. libraries like Scotty define action monads that are just a handful of monad transformers wrapped around IO, in order to add features like "get the current request" and "append a header to the current response" with easy mutable-looking (x -> m ()) types, but without having to do anything hacky like use threadlocals.
16:17:26 <merijn> sveit_: Near future? Probably not
16:17:51 <RchrdB> yyttr3, so if you just want to do something straightforward like (say) slap ReaderT on something in order to hand an environment to it, or slap StateT (your_random_number_generator's_state), then defining a custom monad that way is really low-effort for an appreciable gain.
16:17:54 <merijn> sveit_: Most of the existing dependently typed languages are more aimed to be theorem provers than practical programming languages (Coq & Agda)
16:18:17 <merijn> sveit_: Idris is one of the first (that I'm aware of) aimed to be a practical programming language, but it's rather immature
16:18:43 <merijn> sveit_: Additionally, Idris is specifically targeting experienced haskellers as target audience, so mastering haskell is still worthwhile ;)
16:18:50 <sveit_> merijn, do you think haskell will slowly accrue these features? I'm just surprised because in the short time i've been programming haskell, i've found i would like these features
16:19:36 <sveit_> it seems most things that aren't in haskell are things you don't often need (i.e. Lisp macros, although TH is always brought out as a counter-example)
16:19:46 <merijn> sveit_: No, haskell will keep acruing features, but the odds of it becoming truly dependently typed are slim
16:20:05 <merijn> sveit_: It would require a severe overhaul of the type system and you'd lose some features, like type inference
16:21:05 <merijn> sveit_: Type inference for dependent types is not decidable, whereas haskell's type system (without some extensions, like RankNTypes) is completely inferable
16:21:27 <shachaf> merijn: It's not.
16:22:46 <merijn> shachaf: No? How come?
16:23:06 <shachaf> Polymorphic recursion.
16:23:20 <merijn> With typeclasses or in general?
16:23:38 <shachaf> What do you mean?
16:24:03 <shachaf> Polymorphic recursion is uninferrable without type classes, if that's what you mean.
16:24:15 <shachaf> I mean, even without type classes.
16:28:04 <sveit_> so do people tend to work around not having dependent typing, or does there generally turn out to be a better solution floating around?
16:28:46 <merijn> sveit_: Either you encode it the hard way or you just do it without dependent types
16:29:37 <sveit_> merijn, i get that those are the two alternatives :) my question was more that oftentimes there are "better" ways of doing things in haskell if a solution is not already present in the language, or at least an accepted bandaid
16:29:46 <sveit_> like newtypes for multiple instances of the same typeclass
16:30:00 <dfdsfsf> Is [42] in WHNF or not?  I'm in doubt since it can be rewritten as 42 : [].
16:30:01 <sveit_> or newtypes for "polymorphic" instances
16:30:07 <jfischoff> sveit_: in general people use Maybe to get around not having dependent types
16:30:11 <benzrf> dfdsfsf: that's at the syntactic level
16:30:20 <benzrf> dfdsfsf: that gets translated before eval happens
16:30:23 <dfdsfsf> benzrf: elaborate please
16:30:31 <shachaf> dfdsfsf: [42] is a different way of writing (42 : [])
16:30:36 <dfdsfsf> right
16:30:45 <benzrf> like writing 0x10 instead of 16
16:30:48 <benzrf> there's no eval involved
16:30:55 <shachaf> dfdsfsf: (42 : []) is in WHNF, since the outermost constructor -- the (:) -- is evaluated.
16:32:25 <dfeuer> [x,y,z] is a different way to write build(\c n -> c x (c y (c z n)))
16:32:44 <dfdsfsf> shachaf: Same for "42"? Since it's equivalent to '4' : '2' : []?
16:32:57 <shachaf> dfdsfsf: Same for "42", but not for 42. 42 isn't a string.
16:33:07 <shachaf> (Well, usually not.)
16:33:18 <dfdsfsf> Okay, got it. Thanks for the help!
16:33:22 <shachaf> dfeuer: Not in this context.
16:33:33 <shachaf> And anyway I'm not sure why that'd be helpful to say.
16:34:57 <dfeuer> shachaf: I'm being a bit silly.
16:36:23 <monochrom> I just discovered that a pattern "mx@(Ans x)" does not nail mx's type according to the constructor Ans.
16:36:42 <monochrom> http://lpaste.net/110769
16:36:44 <dfdsfsf> shachaf: Oh, one thing: does the term "data constructor" mean the value constructor of a datatype? What about functions like show?
16:36:52 <dfdsfsf> from a to b.
16:37:11 <shachaf> It means the first thing you said.
16:37:16 <shachaf> show is not a constructor.
16:37:35 <monochrom> that may be bigger than the smallest possible example. but it's written with a bigger question in mind.
16:38:31 <dfeuer> Constructors start with capital letters, or if they're symbol-style, they start with colons. The only exceptions I can think of right now are [] and ().
16:38:42 <shachaf> monochrom: I don't follow.
16:39:36 <shachaf> monochrom: Do you mean that mx won't have the same type as (Ans x)?
16:39:46 <shachaf> (Because the latter might be more polymorphic?)
16:40:59 <monochrom> the function definition says "bin mx@(Ans x) my@(Ans y) = ...". the function type has it rank-2, "bin :: C m => (forall n. C n => n) -> (forall n. C n => n) -> C m". mx and my retain their polymorphisms
16:41:12 <shachaf> Oh.
16:42:06 <shachaf> I see now. That's funny, though I guess it makes sense.
16:43:19 <monochrom> previously, I was worrying about "how do I pattern-match and tell the computer I still want the original polymorphic version for another purpose". I'm glad it's that simple.
16:44:28 <dfeuer> monochrom: so what happens to Ans x and Ans y?
16:44:56 <Enigmagic> sveit_: https://gist.github.com/NathanHowell/6c88f1b6752c36904621
16:45:00 <monochrom> they exist too, until garbage-collected
16:46:25 <sveit_> Enigmagic, will have to study that, thanks!
16:48:01 <sveit_> is there a typeclass that provides a "toList"? I'm not really looking for foldable, since i'm ok with the output list having a restricted type (i.e. something with typefamilies)
16:48:37 <dfeuer> monochrom: does that typecheck? I don't understand how it can be valid.
16:48:54 <monochrom> it typechecks :)
16:49:14 <monochrom> I am still trying to come to terms with it, too :)
16:50:16 <Enigmagic> sveit: you can make one with Data.Foldable.foldr pretty easily
16:50:53 <dfeuer> monochrom: it looks like a typechecker bug to me .... What happens when you pass those things Bins of the wrong type?
16:50:56 <Fuuzetsu> what's this about something type checking?
16:51:25 <Enigmagic> :t Data.Foldable.foldr (:) []
16:51:25 <lambdabot> Foldable t => t a -> [a]
16:51:41 <monochrom> what is an example of the wrong type?
16:51:50 <Fuuzetsu> when you use Bool for something
16:52:07 <monochrom> I am also writing a smaller example. we may play with it better.
16:52:07 <dfeuer> Fuuzetsu: http://lpaste.net/110769
16:52:17 <sveit_> Enigmagic, what if there are restrictions on "a" though?
16:52:26 <Enigmagic> sveit_: lke what?
16:52:48 <sveit_> Enigmagic, for example vector has (Data.Generic.Vector v e) as a constraint for all vectors v and element types e
16:52:52 <sveit_> so the ideal function would be
16:52:53 <monochrom> Div Bool will have a type error, but that is more about the nature of evalDiv.
16:53:11 <sveit_> toList :: (GV.Vector v e) => v e -> [e]
16:53:14 <sveit_> for example
16:53:34 <Fuuzetsu> that typechecks?
16:53:44 <monochrom> currently I have polymorphism at kind * -> * because it is closer to the question I was answering. but I can write a kind * example.
16:53:44 <sveit_> but the typeclass would have to be something like "class Listable t e where toList :: t e -> [e]"
16:54:18 <Fuuzetsu> dfeuer: what does GHC say when you put a hole at bin x y = _ ?
16:54:26 <Fuuzetsu> guess I'll load it in…
16:54:31 <monochrom> it typechecks. evalText example = "(1/0)". evalDiv example = Err "divide by (1/0)"
16:54:39 <dfeuer> Fuuzetsu: I'm on Android right now.
16:54:42 <Fuuzetsu> mhm
16:54:50 <Enigmagic> sveit: maybe you want ListLike
16:54:50 <monochrom> how to use GHC hole?
16:55:10 <Enigmagic> @ListLike
16:55:10 <lambdabot> Unknown command, try @list
16:55:13 <triliyn> sveit_: are you sure you don't mean "class Listable t where toList :: t e -> [e]" or "class Listable t e where toList :: t -> [e]"?
16:55:15 <Enigmagic> @hackage ListLike
16:55:15 <lambdabot> http://hackage.haskell.org/package/ListLike
16:55:17 <dfeuer> monochrom: what happens if you court disaster sticking one into an existential box-of-Bin?
16:55:35 <monochrom> court disaster?
16:55:54 <Fuuzetsu> hm, so it does typecheck
16:55:55 * sipa assumes: count?
16:56:03 <dfeuer> monochrom: GHC typed holes are a version of undefined spelled _
16:56:19 <oakwhiz> court disaster = almost cause a disaster
16:56:59 <sipa> thanks!
16:57:02 <geekosaur> court ~~ invite
16:57:13 <geekosaur> or think courtship
16:57:17 <Fuuzetsu>     bin (Ans x) (Text y) = Text "" valid ;P
16:57:19 <oakwhiz> "tempt fate"
16:57:23 <dfeuer> monochrom: data Box = forall m . Bin m => Box (m Int)
16:57:25 <monochrom> "bin mx my = _" leads to "Found hole _ with type: Div Int"
16:57:28 <cdk> sveit_: any Foldable instance allows Foldable f
16:57:28 <BMeph> sipa: court ~ not-quite consummate. ;)
16:57:47 <cdk> sveit_: any Foldable instance allows Foldable f => f a -> [a] with foldr (:) []
16:57:52 <monochrom> oh! the verb "court", I see.
16:58:24 <sveit_> cdk, clearly, but the container type must be polymorphic to be foldable
16:58:27 <dfeuer> I didn't mean to be obscure. "Court disaster" is a common idiom in English.
16:58:32 * BMeph gives monochrom a cyber thumbs-up!
16:58:52 <dfeuer> Well, common enough, anyway.
16:59:06 <monochrom> don't worry, English is my second language, still many idioms I don't know
16:59:07 <sveit_> triliyn, the first is wrong, the second works as well, but just depends on what kind is convenient for t
17:00:06 <Fuuzetsu> interesting: ‘bin clearlyAns@(Ans x) y = clearlyAns’ typechecks in the instance for Text
17:01:14 <triliyn> sveit_: with the class you described, you could separately have "instance Listable [] Int" and "instance Listable [] Char", which seems... weird
17:02:29 <triliyn> Is that intentional?
17:02:42 <Fuuzetsu> ok, it typechecks but it won't let you use it, Could not deduce (n ~ Text) from the context (Bin n)
17:04:56 * hackagebot text 1.2.0.0 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-1.2.0.0 (BryanOSullivan)
17:10:05 <monochrom> Fuuzetsu: in what way it cannot be used? evalText example typechecks and equals "1".
17:10:49 <Fuuzetsu> monochrom: in what way does evalText use the typeclass?
17:11:07 <monochrom> evalDiv example equals Left "divide by 0" which is also right. (originally, Left "divide by (0/1)")
17:11:16 <monochrom> evalText doesn't. but example does.
17:11:34 <Fuuzetsu> oh, I missed that I think
17:12:07 <monochrom> example = one `bin` blablah. in evalText example, while the root bin is nailed to the Text instance, its arguments aren't.
17:14:06 <Fuuzetsu> I see now
17:14:11 <Fuuzetsu> I wonder if there's much utility in this
17:14:33 <trap_exit> now that haskell is becoming too popular, is idris the new research-y langauge in types?
17:15:04 <Fuuzetsu> now, all research is behind extensions
17:15:09 <Fuuzetsu> no*
17:15:43 <trap_exit> is there a dependent type extension?
17:16:00 <Fuuzetsu> some people say there is
17:19:23 <acowley> Some say, it has a dependent type extension, and that it can be used in the Real World. All we know is, it's called Haskell.
17:19:44 <Fuuzetsu> heh
17:20:20 <trap_exit> wtf are you talking about
17:20:22 <heath> it's a bit much to ask, but will a few of you join http://plnkr.co/edit/?p=streamer&s=xXr1dEQEWh6bLY7R and start editing? i'm wanting to see how well plnkr handles 30+ users concurrently editing. ideally in parallel, but just to have 30+ people join would be nice :)
17:20:32 <Fuuzetsu> can Haskell beat The Stig's time on the Top Gear track?
17:21:08 <monochrom> no gear can spin faster than c
17:21:21 <acowley> Yes, but beware that you're not just timing the thunk creation!
17:21:45 <monochrom> @quote monochrom faster.than.c
17:21:45 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
17:22:46 <Fuuzetsu> haha
17:23:59 <acowley> I want to get that on a t-shirt
17:34:59 * hackagebot keystore 0.5.1.0 - Managing stores of secret things  http://hackage.haskell.org/package/keystore-0.5.1.0 (ChrisDornan)
17:35:09 <fragamus> @pl (\x->x `mod` 2 == 1)
17:35:09 <lambdabot> (1 ==) . (`mod` 2)
17:35:28 <fragamus> you guys have any happier ways to do that
17:36:13 <ij> That's a very happy way to do it.
17:36:21 <fragamus> I know
17:36:39 <ij> hmm, it says that it is odd
17:36:41 <ij> :t odd
17:36:42 <lambdabot> Integral a => a -> Bool
17:36:43 <fragamus> But there might be a truly *blissful* way
17:36:54 <fragamus> see!
17:36:54 <codehero> do you know how to get a specific value from a row with persistent sqlite?
17:37:06 <zwer> @src odd
17:37:07 <lambdabot> odd = not . even
17:37:13 <ij> It's not even!
17:37:15 <ij> :D
17:37:29 <codehero> :D
17:37:30 <ij> @src even
17:37:30 <lambdabot> even n = n `rem` 2 == 0
17:37:31 <exio4> lets hope even isn't "not . odd"
17:37:35 <codehero> i can't even
17:37:39 <codehero> a always have to odd
17:41:19 <dhrosa> is there a reverse to >> ?
17:41:31 <dhrosa> I want to execute action a and b, but discard b's result
17:42:11 <exio4> <* ?
17:42:24 <dhrosa> oh, applicative thing?
17:42:47 <exio4> @type (<*)
17:42:48 <lambdabot> Applicative f => f a -> f b -> f a
17:42:50 <exio4> yep
17:43:36 <fragamus> @src rem
17:43:36 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
17:43:55 <dhrosa> thanks!
17:44:31 <benzrf> @src even
17:44:32 <lambdabot> even n = n `rem` 2 == 0
17:44:35 <benzrf> @src odd
17:44:35 <lambdabot> odd = not . even
17:44:43 <benzrf> oh
17:44:45 <dhrosa> even = not . odd
17:44:52 <fragamus> @src rem
17:44:52 <lambdabot> Source not found. Maybe you made a typo?
17:44:58 <benzrf> even 0 = True
17:45:02 <fragamus> @src rem
17:45:03 <benzrf> even n = odd (n - 1)
17:45:04 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
17:45:09 <benzrf> odd n = even (n - 1)
17:45:11 <benzrf> :-)
17:45:15 <fragamus> @src rem
17:45:15 <lambdabot> Source not found. :(
17:45:58 <fragamus> @src mod
17:45:58 <lambdabot> Source not found. Maybe you made a typo?
17:47:12 <codehero> why is it so hard to interface with sqlite?
17:49:02 <acowley> codehero: What package are you using?
17:49:10 <codehero> persist
17:49:14 <codehero> *persistent
17:49:39 <acowley> Are you building a yesod application?
17:50:04 <codehero> no i'm not
17:50:16 <codehero> just a normal haskell application
17:51:08 <acowley> Then, for what it's worth, I'd use direct-sqlite
17:51:32 <acowley> or sqlite-simple
17:51:42 <codehero> okay
17:51:45 <acowley> I kicked the tires on direct-sqlite a while back, at least, but haven't tried sqlite-simple
17:51:46 <codehero> i'll take a look at those
17:51:58 <acowley> They are probably lower level
17:52:48 <codehero> as long as they don't have weird monads i have to deal with i'm fine :P
17:54:05 <acowley> Yeah, I prefer more raw APIs for databases myself, but I certainly see the appeal of more automated solutions
17:54:47 <codehero> i actually have the code that i neeed, with sql queries implemented in c
17:54:54 <codehero> so raw really shouldn't be a problem
17:55:52 <acowley> I'll point out that sqlite-simple depends on direct-sqlite, so which of those you choose shouldn't limit your future options too much
17:57:15 <MR4Y> Hello people. Is there a function that allows me to see the full implementation of another function inside ghci?
17:57:33 <shachaf> No.
17:57:52 <Fuuzetsu> Source is not in general available.
17:58:09 <monochrom> sometimes, even ghci doesn't see the full implementation. it can load machine code.
17:58:37 <MR4Y> So, what I do if I want to see how a standard function is implemented then?
17:58:55 <shachaf> The same thing you do in C.
17:58:56 <Fuuzetsu> look for the source online
17:59:09 <geekosaur> @where hoogle
17:59:09 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
17:59:27 <geekosaur> hm, should the fpcomplete hoogle be mentioned there too?
17:59:36 <Fuuzetsu> hayoo seems more relevant
17:59:45 <Fuuzetsu> oh it's mentioned, sorry
18:07:33 <MR4Y> I see.
18:12:16 <merijn> What's everyone's opinion on dumping in-progress libraries on Hackage? Should they be at least somewhat production ready or is it just "throw it on there as soon as somewhat usable"?
18:13:06 <pharaun> i tossed mine on it and its not quite ready yet :|
18:13:12 <Fuuzetsu> I'd say just chuck it on, no use for it to sit on my hard drive in case someone is interested in using it
18:13:16 <pharaun> ^
18:13:48 <Fuuzetsu> as always, THIS SOFTWARE COMES WITH NO WARRANTY ;)
18:14:36 <merijn> Fuuzetsu: Well, I plan to hack on it at least a little more, so at least the minimal functionality appears to work before chucking it on :p
18:15:08 <Fuuzetsu> well, sure, there's the gap between ‘everything is undefined’ and ‘kind of works’
18:15:52 <Fuuzetsu> just don't keep it local for next 5 years until you finally make your mind up about the API and all abstractions used internally
18:20:32 <merijn> Fuuzetsu: Well, the goal was to get it to "works, but buggy" ASAP and then just throw it up
18:21:15 <Fuuzetsu> sounds good
18:22:53 <dhrosa> is there a clean way of having parsec parse a string, output a message about how it failed at a particular point, then continue parsing the rest of the string
18:22:56 <dhrosa> ?
18:23:02 <dhrosa> I can think of a few contrived /  inefficient ways
18:23:08 <dhrosa> but I want something cleaner
18:23:32 <merijn> That doesn't sound like a failed parse to me
18:23:59 <merijn> dhrosa: Anyway, parsec is a transformers so you can just use IO as a base and use liftIO to print a message?
18:24:14 <dhrosa> well I don't have to literally output a message
18:24:22 <dhrosa> I could store the error message as another parsed token or something
18:24:25 <dhrosa> the IO isn't the important part
18:24:33 <dhrosa> the important part is continuing after an error
18:25:05 * hackagebot diagrams-gtk 1.0.1.3 - Backend for rendering diagrams directly to GTK windows  http://hackage.haskell.org/package/diagrams-gtk-1.0.1.3 (JohnLato)
18:25:13 <merijn> You'll need try to backtrack and then try the next parser
18:28:52 <dhrosa> hmm
18:29:00 <dhrosa> I guess I can have another parser as a fallback
18:29:03 <dhrosa> if the others fail
18:29:30 <merijn> dhrosa: No, I mean you use <|> from Control.Applicative (I guess Parsec exports it's own version too)
18:29:34 <merijn> :t (<|>)
18:29:35 <lambdabot> Alternative f => f a -> f a -> f a
18:29:47 <merijn> dhrosa: That first tries the first parser, if that fails it tries the next
18:31:35 <hii> hi i need some IO help in fpcomplete
18:31:37 <dhrosa> merijn: I understand that, I'll explain more
18:32:52 <hii> how can I make this work in fpcomplete?
18:32:57 <hii> http://lpaste.net/110782
18:33:08 <dhrosa> I'm working on a class assignment where I'm lexing/parsing a C-like language
18:33:14 <hii> i had it before but i then the main function changed
18:33:29 <dhrosa> there's a separate lexing and parsing stage
18:34:09 <dhrosa> the lexing stage has to be able to parse something like 'c' 'x 'g', and understand that there's a 'c' char literal, an uncompleted char literal, and a 'g' char literal
18:34:37 <dhrosa> and identifiy the column number of the syntax error
18:35:39 <LysergicDreams> I'm looking for a package that will let me parse actions as well as flags, "myprog action --param=foobar
18:35:56 * dfeuer finally sort of sees what monochrom's program is doing, sort of. Interesting.
18:36:06 <dfeuer> It's not what I was thinking.
18:36:41 <hii> can snyone help me with this parser http://lpaste.net/110782
18:36:51 <hii> im trying to get it to work in fpcompete
18:37:06 <hii> i know its something with the args but Idk what to do
18:37:13 <dhrosa> i'm not exactly sure how to accomplish this with Parsec, besides making a parser with every possible syntax error
18:37:18 <dhrosa> which is not reasonable
18:38:01 <merijn> dhrosa: What's unreasonable about it? I guess I don't understand what the problem is?
18:38:26 <merijn> How else would you report problems?
18:40:54 * hackagebot cgi 3001.2.1.0 - A library for writing CGI programs  http://hackage.haskell.org/package/cgi-3001.2.1.0 (cheecheeo)
18:40:58 <hii> no one home today?
18:44:35 <Fuuzetsu> some people sure are impatient
18:49:15 <MorpheusBeing> does anyone know to expand tinyurl shortened link to original?
18:49:29 <katsh> http://tabbit.org/n_JXf that doesn't work. but if i replace 'Char' with 'String', it does. why?
18:49:42 <katsh> i only intend on returning a single char
18:50:09 <dhrosa> merijn: the problem is printing out specifically what column the error happened at
18:50:26 <dhrosa> katsh: because show returns a string
18:50:37 <dhrosa> katsh: you want to also call first to just get the first char of the string
18:50:41 <dhrosa> err
18:50:43 <dhrosa> head sorry*
18:51:23 <dhrosa> merijn: while continuing to parse
18:51:29 <katsh> dhrosa: thanks. and yeah, im just fooling around with functions and typeclasses. trying to get the hang. thanks
18:54:15 * dhrosa browses Parsec documentation
18:55:59 <merijn> dhrosa: Parsec keeps track of the current column and line
18:56:20 <dhrosa> merijn: yeah I  just found that
18:56:21 <merijn> dhrosa: So you just need to query that when the parse fails
18:57:04 <lpaste> merijn pasted “Efficient split + prepand” at http://lpaste.net/110784
18:57:20 <merijn> If I need to split of a chunk of a list only to prepend it again later, would this make sense?
19:00:02 <catsup>  
19:06:08 * hackagebot runghc 0.1.0.3 - runghc replacement for fast repeated runs  http://hackage.haskell.org/package/runghc-0.1.0.3 (MikeZuser)
19:16:10 * hackagebot thumbnail 0.8.0 - generate thumbnail image  http://hackage.haskell.org/package/thumbnail-0.8.0 (KatsutoshiItoh)
19:23:36 <dmj`> merijn: depends on when you prepend it
19:23:50 <merijn> dmj`: How so?
19:24:15 <dmj`> merijn: well if you need to prepend it each time you could simply use a fold, but if you need to prepend it later based on some condition you'd need a state
19:24:41 <dmj`> merijn: when do you need to prepend it
19:24:58 <merijn> I need to store the prefix of a list and later prepend that same prefix to another list
19:25:04 <merijn> i.e. each prepend happens only once
19:25:15 <merijn> And I don't need the prefix at all in between
19:27:49 <athan> anyone want to critique my code & possibly help me understand why I'm getting a funny error? SPOILER: It's project euler #18 :/
19:27:52 <dmj`> merijn: yea, seems like a state wouldn't be bad. What's the condition under which a prepend happens
19:28:03 <merijn> dmj`: There is no condition
19:28:08 <merijn> It always happens
19:29:05 <merijn> dmj`: Note, I'm not asking how to store the prepend, I'm asking whether having a splitAt' that creates a DList makes sense, as opposed to, say, just returning ([a], [a])
19:29:17 <athan> ...here's the code, in case someone finds it REALLY interesting... http://lpaste.net/110785
19:31:20 <dmj`> merijn: so is this a question about efficiency or being pragramtic
19:31:28 <merijn> Both
19:31:51 <merijn> i.e. is this a sensibly efficient way or is that "naive" way bette
19:35:13 <carter> merijn: sup
19:35:17 <merijn> carter: ola
19:35:22 <merijn> carter: How was ICFP?
19:35:41 <carter> merijn: noticed how i didn't tweet or irc (or at least not much) for a week
19:35:44 <carter> ?
19:35:45 <carter> :)
19:36:10 <carter> merijn: does that tell you how much fun/ busy it was?
19:36:14 <merijn> carter: :p
19:37:43 <merijn> After a delay with trying to coerce GHC into doing my bidding (I failed) I'm back to trying and get this damn zeromq library into alpha status >.>
19:37:44 <shachaf> s0mbra: What was that all about?
19:38:05 <s0mbra> wft??
19:38:13 <dmj`> merijn: well since splitAt is composed of drop and take which would be O(n), and Data.DList.fromList is O(n) as well since fromList :: [a] -> DList a; fromList = DL . (++), it seems like you won't be gaining much
19:39:14 <merijn> dmj`: Except that this approach there's only one O(n) operation
19:39:38 <carter> merijn: the trick is to design it in a way that GHC helps you
19:40:08 <merijn> carter: I did, but then GHC had a bug which made the design not work :D
19:40:18 <carter> what bug
19:40:29 <carter> merijn: i think your lying, because I don't remember seeing a bug report
19:40:30 <merijn> carter: Broken exhaustiveness check for GADTs
19:40:33 <carter> oh
19:40:34 <dmj`> @def prepender = \num xs -> uncurry (\(x:xs) ys -> x:ys) $ splitAt num xs
19:40:35 <lambdabot>  .L.hs:179:1:
19:40:36 <lambdabot>      Multiple declarations of ‘prepender’
19:40:36 <lambdabot>      Declared at: .L.hs:177:1
19:40:36 <lambdabot>                   .L.hs:179:1
19:40:37 <carter> merijn: theres an easy fix
19:40:43 <merijn> carter: Doubt it?
19:40:50 <merijn> carter: Unless you mean "_"
19:40:52 <dmj`> @def prependertwo = \num xs -> uncurry (\(x:xs) ys -> x:ys) $ splitAt num xs
19:40:54 <lambdabot>  Defined.
19:40:57 <merijn> carter: Which I already have, currently
19:41:02 <carter>  _ = error "impossible branch in GADT foo of function baz"
19:41:04 <dmj`> > prependertwo 4 "aaaabbbb"
19:41:05 <lambdabot>  "abbbb"
19:41:22 <merijn> carter: One of the OPLSS peeps is fixing it already, so hopefully it'll be patched in 7.10 :)
19:41:25 <dmj`> merijn: are you doing multiple prepends?
19:41:29 <merijn> dmj`: No
19:41:30 <carter> merijn: whos doing it
19:41:44 <merijn> eh
19:41:47 * merijn goes to facebook
19:42:24 <merijn> carter: George Karachalias
19:42:52 <carter> oh yeah, i think SPJ even listed  that in his talk
19:43:41 <dmj`> merijn: how large is your list?
19:44:07 <merijn> dmj`: No clue, I get it from the network
19:46:46 <dmj`> merijn: I guess it depends if constants are a factor. How'd you get the lists in the first place? Would a parser be a better choice?
19:47:22 --- mode: ChanServ set +o shachaf
19:47:31 --- mode: shachaf set +b *!*@186.90.125.87
19:48:04 <dfeuer> Oof....
19:48:07 <merijn> dmj`: I get the list by parsing it from the network? I don't really know what sort of answer you're expecting here?
19:48:33 <dmj`> merjin: I guess the quality of my answers are contingent on the information you're willling to share
19:48:49 <merijn> "it's a list of things that comes from the network"
19:48:58 <merijn> I dunno how much more information there is to provide?
19:49:13 <merijn> "how long is it?", well that just depends on whatever I get send, now doesn't it?
19:49:22 <dmj`> merijn: why do you need to prepend information from one list onto another
19:49:24 <merijn> Probably somewhere between 2 to 200?
19:49:35 <merijn> Because that's what the protocol specifies?
19:50:04 <merijn> I need to prepend prefixes from incoming message onto outgoing ones
19:50:46 <sveit_> is there a typeclass for injective or one-to-one mappings (ones that are not necessarily onto)?
19:51:05 --- mode: shachaf set -o shachaf
19:51:14 <shachaf> sveit_: A type class? What sort of class do you have in mind?
19:51:15 * hackagebot yesod-pnotify 0.5.0 - Yet another getMessage/setMessage using pnotify jquery plugins  http://hackage.haskell.org/package/yesod-pnotify-0.5.0 (KatsutoshiItoh)
19:51:54 <sveit_> shachaf, something that would be "class Injective a b where toB :: a -> b; toA :: b -> Maybe a"
19:52:14 <sveit_> since it is one-to-one a -> b, but does not necessarily map a onto b
19:52:25 <shachaf> Which just picks some arbitrary/canonical injection?
19:53:01 <sveit_> well I (the user) would pick it, but i guess yes. somewhat like there are multiple Monoid instances for Integers
19:53:03 <sveit_> or Nums
19:53:29 <dmj`> merijn: are you using a streaming library to perform the prepending action
19:54:21 <Sornaensis> wowee thanks whoever suggested vty
19:54:26 -ChanServ(ChanServ@services.)- glguy added *!*@186.90.125.87 to the AKICK list.
19:54:26 --- kick: e5521 was kicked by ChanServ (Banned: join flood)
19:54:26 --- kick: p220 was kicked by ChanServ (Banned: join flood)
19:54:26 --- kick: k6965 was kicked by ChanServ (Banned: join flood)
19:54:26 --- kick: v5706 was kicked by ChanServ (Banned: join flood)
19:54:26 --- kick: r9597 was kicked by ChanServ (Banned: join flood)
19:54:26 --- kick: n3141 was kicked by ChanServ (Banned: join flood)
19:54:26 --- kick: d977 was kicked by ChanServ (Banned: join flood)
19:54:26 --- kick: o1052 was kicked by ChanServ (Banned: join flood)
19:54:26 --- kick: b2238 was kicked by ChanServ (Banned: join flood)
19:54:26 --- kick: s300 was kicked by ChanServ (Banned: join flood)
19:54:26 --- kick: b7773 was kicked by ChanServ (Banned: join flood)
19:54:26 --- kick: u2424 was kicked by ChanServ (Banned: join flood)
19:54:26 --- kick: c6572 was kicked by ChanServ (Banned: join flood)
19:54:26 --- kick: e5543 was kicked by ChanServ (Banned: join flood)
19:54:26 --- kick: x2718 was kicked by ChanServ (Banned: join flood)
19:54:26 --- kick: x8092 was kicked by ChanServ (Banned: join flood)
19:54:26 --- kick: i6421 was kicked by ChanServ (Banned: join flood)
19:54:26 --- kick: j1817 was kicked by ChanServ (Banned: join flood)
19:54:26 --- kick: y3656 was kicked by ChanServ (Banned: join flood)
19:54:26 --- kick: h5552 was kicked by ChanServ (Banned: join flood)
19:54:26 --- kick: z2967 was kicked by ChanServ (Banned: join flood)
19:54:26 --- kick: p4751 was kicked by ChanServ (Banned: join flood)
19:54:26 --- kick: z6525 was kicked by ChanServ (Banned: join flood)
19:54:36 <Fuuzetsu> woah there
19:54:47 <dreams_> :O
19:54:54 <Fuuzetsu> it's the same spambot as the other day too
19:55:06 <dreams_> they're all spambots?
19:55:25 <Fuuzetsu> it's one ‘person’
19:55:30 <dreams_> heh
19:56:06 <dmj`> merijn: you could put the list into a source, read the first value (prefix), put into an mvar, read the next value, pull the prefix out of the mvar, prepend it, keep going etc.
19:56:45 <sveit_> shachaf, any ideas/comments based on that?
19:57:23 <dreams_> Can someone give me a hint, why the former is more space efficient? I don't get it http://lpaste.net/110788
19:57:45 <shachaf> sveit_: I don't think there's any such class. I'm also not sure what you would use it for.
19:58:23 <sveit_> shachaf, in my particular case, i noticed i had a lot of fromList/toList functions in different typeclasses i was making, just because the mapping was natural and useful
19:58:34 <heatsink> dreams_: It probably evaluates the first argument of (+) first.
19:58:42 <sveit_> my first instinct was to use Foldable, but i was using lots of vectors, which are not polymorphic containers
19:58:49 <Fuuzetsu> dreams_: I suspect it's because in second case it needs to keep the list around to be able to take the head of it and because you last first, the whole thing is evaluated
19:58:59 <sveit_> (along with "polymorphic" containers like pairs and triples)
19:59:06 <heatsink> dreams_: If y is evaluated before x, the list must be saved.  If x is evaluated before y, it needn't be.
19:59:08 <Fuuzetsu> in the first case it takes the head and then takes the last element, throwing away everything on its way
19:59:49 <sveit_> shachaf, so i abstracted to a "listable" class, but at that point i might as well abstract to any such one-to-one mapping
20:00:15 <merijn> dmj`: huh, I think you are really overthinking my question?
20:00:24 <shachaf> sveit_: I missed the discussion on Listable earlier.
20:01:11 <sveit_> shachaf, i think this discussion can be had independently?
20:02:07 <dreams_> heatsink: oh wait, because after x is evaluated, xs wouldn't have pointers to so it can be GC'ed as y traverse the list?
20:02:20 <dmj`> merijn: I can't give a good answer w/o my understanding, sorry :/
20:02:26 <dmj`> more* not my
20:03:09 <dmj`> merijn: I'm assuming you're parsing the network stream w/ attoparsec into an ADT, but some of your fields are lists, and then you need to transform them, is that a correct assumption?
20:03:16 <merijn> dmj`: My only question was whether a custom splitAt with a DList approach made sense over using splitAt and ++
20:03:52 <merijn> My incoming messages are lists of frames and for every incoming message I need to splice of the prefix to later prepend that prefix on another message
20:05:01 <merijn> I was just curious whether that DList-ified split function made more sense than takeWhile/dropWhile or some other splitAt variant
20:05:45 <solatis> does anyone here have a (strong?) opinion on which json library is best? speed is not an issue, elegance is
20:05:50 <heatsink> dreams_: Right.  xs is used for evaluating both x and y.  If x is evaluated and then y, then 'xs' is already unused while the list is being lazily computed, and the front of the list can be collected.
20:06:21 <solatis> should i just stick with text.json?
20:06:54 <heatsink> dreams_: If y is evaluated and then x, then the list is lazily computed while y is evaluated.  Because xs is used to compute x, it can't be collected.
20:07:09 <heatsink> until x is computed.
20:07:31 <dreams_> heatsink: neat. thanks.
20:09:19 <dmj`> merijn: takeWhile and dropWhile will combined be O(n), since it matches on a predicate, take and drop aren't as smart, and would be O(2n). Might be better to make a custom splitAt that uses those.
20:09:51 <dmj`> merijn: I think
20:16:18 * hackagebot taffybar 0.4.2 - A desktop bar similar to xmobar, but with more GUI  http://hackage.haskell.org/package/taffybar-0.4.2 (TristanRavitch)
20:18:21 <katsh> tell :: (Show a) => [a] -> String   this says, no matter how many arguments in the list, they must belong to typeclass Show, correct?
20:18:40 <katsh> sorry, *no matter how many elements in the list argument
20:18:46 <dibblego> katsh: Yes.
20:18:58 <dibblego> (it also says they are of the same type)
20:19:22 <katsh> dont they all have to be?
20:19:28 <dibblego> Yes.
20:19:30 <katsh> (if its in a list, they have to be homogenous)
20:19:32 <katsh> ok
20:46:21 * hackagebot reducers 3.10.3 - Semigroups, specialized containers and a general map/reduce framework  http://hackage.haskell.org/package/reducers-3.10.3 (EdwardKmett)
21:16:30 * hackagebot aeson-qq 0.7.3 - JSON quasiquoter for Haskell  http://hackage.haskell.org/package/aeson-qq-0.7.3 (SimonHengel)
21:20:07 <benzrf> bye
21:29:22 <fresheyeball> @lambdabot
21:29:23 <lambdabot> Unknown command, try @list
21:31:32 * hackagebot uuid 1.3.4 - For creating, comparing, parsing and printing Universally Unique Identifiers  http://hackage.haskell.org/package/uuid-1.3.4 (AntoineLatter)
21:36:32 * hackagebot hspec-wai 0.4.1 - Experimental Hspec support for testing WAI applications (depends on hspec2!)  http://hackage.haskell.org/package/hspec-wai-0.4.1 (SimonHengel)
23:41:12 --- topic: 'Hackage/haskell.org issues being investigated; hackage mirror: http://is.gd/xJt4FF | http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://is.gd/xJt4FF'
23:41:12 --- topic: set by shachaf!~shachaf@unaffiliated/shachaf on [Thu Sep 04 17:50:57 2014]
23:41:12 --- names: list (clog Itkovian southp0105 ddellacosta r444 encima digin4 ioanel Guest1814 mthvedt sivteck NightRa danvet linman32 buckmaster wirrbel milessabin moss1127 djfoote Hermit Iskarlar tommyliu fractalcat dcoutts_ yitz HENK29933 MP2E fxr kerrick ddere ifesdjeen sopvop fragamus samrat Shiza folsen shintah centrx kcj gentleben kyb3r_ ibid cbarrett negatratoron chrisdotcode hamid sbidin araujo mgomezch_ Swizec sakirious Jerryjiggler jrm2k6 Qfwfq WarzoneCommand centrinia)
23:41:12 --- names: list (Wertax dimday anttih capisce reggie1 DrCode Spockz cultofmetatron spaceships AtomicCheese koz reizuki theshadow carlosgaldino Derander jordanl rperry suls NSPragmatic vlion` fergusnoble fall_ codehero jophish_ peddie SuperTux88 Nickeeh raid Blkt cryptoca mgaut72 Boreeas c-rog_ martianboy kawachi thoughtpolice pgiarrusso tranma xaimus Guest52738 tridactyla mmaruseacph2 vikraman FireFly sai__ obcode ch4rl35 otto_s_ jpierre03 Plasmastar PixelCrumbs idoru ttuegel)
23:41:12 --- names: list (milli ij shelf ortmage bgamari Lacriatch tinron dario` Aune T_X trout-senpai dsirenko AfC icarot machineslearn cowtown cmccann vhz koala_man tstc` jayne mindCrime_ annulus elfangor pingu maoe tomku murphy_ Kruppe dogmaT rekahsoft amontez _1126 GaveUp JZTech101 lpvb cjheath malglim MitchW mceier codesoup amesha_ honza bens joefiorini jerrycheung dr_ path[l] shesek eddd kmels cdk archmonk claudiyoh eyenx electrogeek iron_houzi helgikrs2 protein-jesus choosegoose)
23:41:12 --- names: list (flebron imalsogreg crenot hpd coeus shelling_ Th0mas noctux cods poutsi callumacrae zpconn__________ davean1 ValicekB sunfun` albeit_ albel727_ Mokosha_ edwardk_ s_e_ JeanSprouts joelteon neptunepink ephemeron cin_ wjm carter bsmt gereedy_ apaku_ c74d PHO__ yorick_ gws Guest35398 iulian_ Jaak tmct PartyKat1e honkfest1val mrpantou1le dhrosa jix_ emma xiaolin_ nik_89_ petermw_ ggherdov emmanueloga Xorlev_ shennyg jlyndon eamelink staffehn_ jmcc___ ousado_)
23:41:12 --- names: list (blindscreen mno2 nick1234abcd jdjkelly_ akahn Guest78646 manfoo7` tazjin si14_ kmapped oldmanstanley__ seanparsons _tca tobyp lfp cloudhead_ mendez_ jonsterling guampa iXeno hiratara myk__ glguy_ ilmig Zekka jasonjckn Kludgy_ acharles C4Cypher yougogull Angry thetallguy mauke_ shanse conal dibblego zwer erkin juhp dabradley chidy davidfetter thorstadt [mth] Nervkind1 steamboat aarvar edwtjo zeebrah zcd gratimax LordDeath Paprikachu roconnor andyt estulticia)
23:41:12 --- names: list (LysergicDreams xinming dfeuer systemfault tobik yfeldblum merijn milos_co1agen Longlius everett falafel invisibleaxm splintax copumpkin infinity0 plutoniix MorpheusBeing predator117 l0cust nico-tux dpwright amiri_ btc cespinoza Sgeo jedws gienah L8D SparkySparkyBoom jacobw Zigma zanchoPansa Gilfoyle Turboknot13 pyon relrod c-rog michaelneale castor2 nuncanada mitchty_ mada desophos c_wraith ThatOtherPerson bbloom RevJohnnyHealey Cale toors hvr cdidd_ Hodapp)
23:41:12 --- names: list (dyreshark earldouglas dropdrive sellout Excureo poucet joneshf peterhil no_name anon744 vladan DigitalKiwi Laney __main__ Betal antoniy ndeine ivoscc vmeson yan_ npcomp arrdem tumdedum jaykru SSgtSpoon oberstein pavonia Desoxy tv Iceland_jack etabot JagaJaga AntiSpamMeta andares__ nominolo petterw vincom2 Guest42372 sivoais frontendloader stelleg kludgy boot13 dsantiago saurik eristic FledRebel dodgems user___ whaletechno nakal__ funfunctor Atrumx saml)
23:41:12 --- names: list (empyreal oddsignals Soft latk shintahW _ashbreeze_ mikecaruso vital kr4sh Sorella Enji enthropy srhb descender xplat charlie Nik05 augur aloiscochard ninedotnine uber dqd elfenlaid nyuszika7h AbigailBuccaneer thunderrd xahry AdopsMonkey ClarusCogitatio mountaingoat mickk Nanar levi clucroc fling otulp Freundlich yacks terlar nshepperd pii kipras`away Oksana_ dmwit Mon_Ouie yano hpc jedavis tromp Brando753 \q snits johnw katsh Enigmagic jml Boney vili catsup)
23:41:12 --- names: list (vpm s4msung mixi chaptastic mrmanner KingOfKarlsruhe Matrixman_217 geekosaur int-e sshine lpaste fall` ircbrowse Drezil kaol stbuehler linduxed kuyatzu kav Fubar^ Vq Razz codeburg tnks Hardolaf obiwahn spacebug Will| naudiz _d3f Jaxan tamiko haasn cmn zeroskillor tero- bcoppens tomboy64 DasIch perrier alang moop anthraxx42 comboy pharaun kosmikus dmilith Kinnison arch_ armyriad zymurgy Nivim Natch tusj tanath stepcut dolio orb_ Eliel tgkokk darithorn quaestor)
23:41:12 --- names: list (isomorphic ccasin melter pfoetchen Krakarn inr zarul ChristianS kfish Defunk syunull wto ckw pantsman Guest61768 hackagebot cbou mak` Oxyd lambdabot Svedrin plhk delhage farn Kobata ezrios purefn1 Ralith AleXoundOS doshitan FreeFull inuoppai asjo christiansen ByronJohnson alorente Aeriff Guest27658 Willis eikonos adnap BMeph sorind stoned CindyLinz Internet13 bjobjo_ Claudius1aximus mike4 taktoa stvc larrytheliquid__ Xack tg ikkebr robbert nisstyre sea-gull)
23:41:12 --- names: list (burp Twey xpika evi mimi_vx hamishmack theorbtwo wrmsr|somewhere ForNeVeR monochrom lurker6 yaopo tsani jedai joneshf-laptop zugz Rutger` noam Raynes gdoteof Tinned_Tuna1 Tinned_Tuna schlumpi DanC Za-Lord byorgey myme2 edk cow_2001 LoRez swen mikeym ananna deevus Axman6 DarkFox dpn` m00nlight pikhq sm dilinger mr- leon1 indigo heath ps-auxw Maxdamantus ricky Wamanuz alpounet hopnotch MK_FG bjorkintosh kakos lenage lfox Zariel shmookey FragByte saep Yawgmoth)
23:41:12 --- names: list (ninegrid petercommand _flow_ statusbot henrikhodne nicoo jnoah benzrf|offline Tesseraction cap3lla Baughn monsieurp Mortomes_ karls dukedave alinab sixthgear werdna davidthomas jle` abh lahwran Tiktalik ahihi dv- Denommus MrGwen vsayer__ seagreen djahandarie gbarboza effy Belgarion0 go|dfish bitraten1 simpson sarlalian Cryovat PotatoGim davesilva_ tov_ gx^ horlicks_ mattp_ irssi joeyh BrianHV lattenwald tpsinnem hkon_ dh nifty_ Transfusion Jello_Raptor funrep)
23:41:12 --- names: list (bartavelle SethTisue_______ averell Bane^ Khisanth alxgnon jrp6 hegge cursork majoh heikkih opqdonut jasu0 knyppeldynan LaC_OS_X Adeon kjanosz- gargawel b_jonas hiredman flori_ owlglass1 anildigital franckverrot alphonse23_ billymeter avdi zph kirjs_____ HugoDaniel felixsch Walther leifw nect puzza007_ MediumDivision_ eevar_ ThePhoeron bind blenny mearnsh shachaf joe_k stevely iteratee Liskni_si Intensity Floyd_ dreixel serjeem___ JPuff hnjen boegel|work)
23:41:12 --- names: list (zeiris tomprince mornfall sbrg_zzz defanor cross mathu valdyn qrada__ arthur_h1neynet nathanic aleator_ keaml_ sh1ken yukko ggreg_ opto brandonw wormphle1m peltchu_ gseitz Starfire Athas Phillemann onielfa1 SegFaultAX orbital_ tarcwynne_ pmarreck ReinH Guest36935 lacrosse elgot cepheus tekacs Bootvis suvash_away drdo sw1nn mgomes zz_LoRdToLsToI purefn kalz takeey Kabaka trez gspr skarn Raynos spion CARAM keko_ Reiser thamz kalloc dkua mbrcknl Scorchin)
23:41:12 --- names: list (greymalkin xelk sindresorhus korpse_ Diskord IanKelling steshaw aristid sohum anachron mlen wizonesolutions ehamberg S11001001 ]OLI[ dstockwell Nshag c9sould jabbslad___ MiracleBlue billyiii__ srbaker Jo-haN rom1504 geal teehemkay_ Edoxile pnielsen posco wjlroe cjwelborn TallerGhostWalt ixian raphie__ thirsteh_ AlainODea_ anders^^ srcerer taruti PatrickRobotham biscarch himikov XMunkki_ mads- benbangert frms agatam davorak_ dlundy_ helgar froztbyte ryanakca_)
23:41:12 --- names: list (stew caasih javex gandr KorriX_ bd_ deni hanDerPeder koninkje1away mxf dlackty__ chas R2ZER0 paz__ flux kloplop321 mangaba_leitosa mavam julmac jglukasik _5kg drone| comma8 l3kn mankyKitty jrw adrienneleigh Haskellfant jmct idnar jennmoneydollars bgyss strmpnk____ sipa jzelinskie teeteewhy zoglesby cxxviita qr42 tessier GGMethos stass DanC__ ljhms ReyuAway stiell akurilin cyphase k00mi tromp_ d-snp justMaD dixie_ Shapeshifter jackhill tm512 wagle pm5 jlamothe)
23:41:12 --- names: list (kjnilsson theDon Vorpal Adios brisbin tych0 Draconx katis dmead __jrp__ phaer ephess adimit petantik demolithion Sornaensis BeLeKy adlan lericson_ tdammers jcurbo tismith ivan` jungnam mp afleck Karethoth KaneTW fyolnish_ Spacegho- machrider Fuuzetsu cschneid acfoltzer _janne Hugglesworth BeardedCoder integral roo_ AlephNull mrb_bk jrslepak Ornedan_ Dtgr `micro prinsen_ phadej hc zebr NickHu_ luite andrewsw saiam_ kini ski haroldwu SLi ktosiek divyanshu_)
23:41:12 --- names: list (rschulman Bigcheese shouya ch3mical etrepum nkpart cstrahan sclv SenorSenpai David mgaare blz37 dcoutts Fusxfaranto farawayexplorer LeaChim qsuscs z0d Ulrar Someguy123 monty wchun Sagi hyPiRion dagle greeny yam filinep_off maaku ffledgling DustyDingo unsymbol Vbitz m_george bernalex Laquendi aford TDJACR mortberg jlouis ahf phaskell chasecaleb lulf Klumben mgregson eyck_ wting pyrtsa zenzike brixen isomorphismes notori0us brackets mephx agrif connerb bvad)
23:41:12 --- names: list (kardboardb mikeizbicki andyland marsbot dp_wiz_ mandu_ shiona_ joshsz SHODAN mirsal wjt pieter_ mindos_cloud____ jroesch_ superjudge__ andreypopp_ zling_____ MMuse__ adamse natte Cathy masak osnr eyem cwc clementd oubiwann yusukesuzuki banyan bra yrashk felixn ciaranm rtl jchee Clint aupo hbar_ td123 sgronblo mokus__ `0660_ ChongLi Cr8 ion lispy kloeri DanZimm fds4345 qtplatypus Taneb seliopou SaBer Preyer bitemyapp itsmonktastic d3lxa heyj sdx23 pranz jameseb)
23:41:12 --- names: list (feltnerm thebnq mikeplus64 no-doz sodaplayer_ coppro Artpicre lokydor runde_ earthy kshannon_ kaiza_ jonathanj ajcoppa jnott gsilvis oconnore Hafydd cow-orke1 kragniz nw Rylee cjay redtricycle Na6hu7Ud_ cyanoacry CosmicRay epta SolitaryCipher bbastian StoneToad mrkishi solarus cynick fryguybob abc56889 iross lyxia scopedTV sleepynate ParahSailin SwashBuckla zomg M-ou-se sofancy mrshoe hmax TheMoonMaster TakSuyu eL_Bart0- lolocaust mechairo` Cheery MasseR_)
23:41:12 --- names: list (kandinski dowski benmachine canta ivan\ hsc preyalone blast_hardcheese Gracenotes_ Tritlo djapo mroman_ simcity2000 numberten elij marienz raek iota_ lenstr TheMue rieper_ lamilami `bps Arnar_ bergmark flojistik klugez tomejagu1r_away rs0 nulpunkt tippenein eagleflo lusory mrd eazar001 gridaphobe humkubum Pad^ diginet pp^ magicman jin_jin dju Watcher7 Jyppe_ dan64- pdxleif tassmjau liyang_ tlevine BlastHardcheese yeltzooo harski1 ocharles asabil nwf jj2baile)
23:41:12 --- names: list (chirpsalot AshyIsMe thorkilnaur__ liuw [swift] heaumer_ `^_^v ernst zalami Lindrian mrowe jlewis_ rufs absence statusfailed Dashkal maurer mjrosenb bydo _|d0m|_ kmicu amiller sajith_ krakrjak_ Saizan Heffalump JPohlmann OrangeDuck Bwild finnrobi Kithulhu_ aoh noplamodo mami ZsoL notdan_ peder cryon luzie thomassgn betawaffle pygospa danneu friden bjornars nitrix martingale michaelpj_ ft nesqi qrada_ Tene Chousuke_ kqr lpsmith squimmy_ Ke Jonno_FTW Philonous)
23:41:12 --- names: list (mjo andreasrx zerokarmaleft indiv0 mbrock cpa_ semberal- joshc doismellburning McManiaC Paks Igloo aninhumer Kneiva phaazon Tehnix rblackwe tomaw- User932 wollw bbee solirc deavidsedice so cmsd2 shapr mero @ChanServ tomaw jlewis somenick- felipe_ Harbinger knyon xnyhps gidogeek sordina2 barrucadu noddy waynr evax Draggor sunnavy asm89 pi8028 xintron mietek Okasu osfameron Rembane Deewiant slobo kittenso1p jdiez edran sveit Dodek ido rhodesd Gothmog_ Nimatek)
23:41:12 --- names: list (jrib wtw otterdam joachifm supki sokoll danking Plastefuchs wei2912 ziman Ezku_ nikolah Urchin troydm slth qz_ jaspervdj mayski noidi twopoint718)
23:41:18 <merijn> @where hoogle
23:41:19 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
23:41:36 <merijn> Angry: Hoogle is great, it indexes many common packages and lets you search based on type
