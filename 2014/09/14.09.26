00:04:03 <napping> can I get an indented first line nicely with wl-pprint?
00:04:42 <napping> I'd like a layout "block\n   first\n | second\n | rest\nend" that flattens to "block first | second | rest end"
00:28:55 <beckyconning> i can't believe hackage is still down 5 hours later
00:29:19 <simpson> Why not?
00:29:21 <oiuoiu> remember: people who are working on it are volunteers
00:32:13 <{{AS}}> Hi, anyone knows what is happening with cabal?
00:32:21 <vanila> hackage is odwn
00:32:44 <{{AS}}> vanila: Ah, thanks
00:33:31 <srhb> {{AS}}: You can use luites mirror if you need to install packages via cabal
00:33:51 <srhb> {{AS}}: http://comonad.com/reader/2012/hackage-mirror/
00:34:08 <{{AS}}> srhb: Oh thanks, it was just my travis built failing. But it might be useful anyways :)
00:34:14 <srhb> :)
00:34:25 <beckyconning> because this would never happen to npm : P
00:34:39 <srhb> beckyconning: True. A lot bigger though, I imagine.
00:35:43 <srhb> But obviously, the transition should have happened before the server ran out of space. Easy to say that with hindsight though. :-)
00:35:49 <simpson> beckyconning: Are we thinking of the same npm that regularly has small outages and, earlier this year, demanded buyin from the community because it couldn't handle the load placed on it due to poor architecture?
00:36:07 <simpson> All package management sucks. Pretending that somebody got it right is a little bit of a delusion.
00:36:38 <simpson> Sorry, that was rude. I'll shut up now.
00:37:03 <srhb> No package management service should be down due to "oops, suddenly no more space" obviously. :)
00:40:01 <beckyconning> ^
00:40:01 <beckyconning> simpson: i didn't say it was perfect i just haven't ever seen it down for this long despite using it pretty much every day for years : P
00:40:01 <beckyconning> it probably drops for an hour or two way more often than hackage for all i know
00:40:20 <srhb> Anyway, the discussion is moot, it's being fixed and it's taking the time it will due to volunteer work and whatnot. Presumably safeguards will be put in place to avoid this nasty surprise in the future.
00:40:43 <vanila> doesn't someone run a backup?
00:41:02 <srhb> vanila: Not of a full Hackage with build service, docs etc.
00:41:06 <srhb> Not sure how that would even work right now..
00:41:33 <srhb> But at least having a remote-repo-failover: option for cabal would alleviate a lot of troubles.
00:41:43 <beckyconning> ^
00:41:45 <srhb> Also perhaps encouraging people to build local docs more / easier
00:42:10 <beckyconning> i have local docs and hoogle etc on my computer but like
00:42:37 <srhb> I don't, because I'm a lazybutt.
00:42:48 <beckyconning> if we used haskell at work and were trying to deploy to a production or demo server today we would be messed up!
00:43:04 <srhb> You wouldn't, the solution is a google search away, thankfully.
00:43:19 <srhb> If luites mirror did not exist then yes, that would be pretty terribly.
00:43:21 <srhb> terrible*
00:43:25 <vanila> beckyconning, haskell is fine, it just not cabal
00:43:40 <srhb> cabal is an inextricable part of the haskell ecosystem.
00:43:44 <vanila> idea for buisnesses: operate independent of some 3rd party website that's run by volunteers
00:44:14 <srhb> vanila: Stop getting defensive about it, it's OK to have ambitions on behalf of the community as whole. :)
00:44:16 <beckyconning> yeah cabal is required for many build processes. most automated ones work from scratch.
00:44:38 <vanila> cabal is atrocious and terrible
00:44:53 <vanila> I haven't been able to install anything since a few days ago with it because it cant figure out the deps correctly
00:46:44 <beckyconning> also if there is a fix it should be in the topic
00:46:44 <vanila> before that I have to manually edit any UTF-8 characters out of .cabal files, otherwise they can't install
00:46:44 <vanila> because haskell doesn't handle unicode corretly or something?
00:46:44 <srhb> beckyconning: True. Maybe the @ops can do that.
00:46:44 <beckyconning> and on here http://status.haskell.org/
00:46:44 <srhb> I don't know if there's reluctance because it's a private service.
00:46:44 <srhb> beckyconning: You should submit your ideas to the haskell.org team
00:46:53 <srhb> I'm betting a lot of this is forgotten as soon as things are running again if someone doesn't put things in motion :)
00:47:06 <beckyconning> kk i will : )
00:50:25 <vanila> like darcs it gives me low confidence in the capability of haskell
00:50:43 <beckyconning> this ^
00:51:06 <oiuoiu> what do you mean?
00:51:41 <srhb> vanila: What's wrong with darcs?
00:51:56 <vanila> it doesn't work too great
00:52:13 <merijn> vanila: Haskell handles unicode just fine
00:52:35 <merijn> Likely causes of unicode not working is screwing up your environment/terminal settings
00:53:02 <srhb> vanila: Hmm, that's a bit vague, I think darcs is pretty cool. At least compared to git.
00:53:15 <fbrusch_> Hi
00:53:18 <srhb> fbrusch_: Hi.
00:53:21 <fbrusch_> I have a problem with ghc-mod
00:53:29 <srhb> fbrusch_: What's the problem?
00:54:03 <fbrusch_> when checking, it doesn't find the library in the sandbox
00:54:38 <fbrusch_> ex: ghc-mod check types.hs
00:54:41 <fbrusch_> says:
00:54:54 <fbrusch_> types.hs:24:8:Could not find module `Data.Csv.Streaming'It is a member of the hidden package `cassava-0.4.1.0'.Perhaps you need to add `cassava' to the build-depends in your .cabal file....
00:55:04 <srhb> fbrusch_: Is cassave in your build-depends?
00:55:07 <srhb> cassava*
00:55:08 <fbrusch_> yes
00:55:18 <srhb> fbrusch_: Which version of ghc-mod?
00:55:55 <fbrusch_> 5.1.0.2 compiled by GHC 7.6.3
00:56:09 <srhb> Hmm. Then I don't know what the issue might be.
00:56:15 <fbrusch_> if I ghc-mod debug
00:56:39 <fbrusch_> it tells me the options it passes to ghc
00:56:47 <fbrusch_> among which
00:57:15 <fbrusch_> -package-db /home/francesco/playground/haskell/moka/.cabal-sandbox/x86_64-linux-ghc-7.6.3-packages.conf.d
00:57:16 <merijn> I don't think ghc-mod supports cabal, etc.
00:57:33 <fbrusch_> if I pass that manually to ghc
00:57:37 <fbrusch_> it works
00:57:52 <srhb> merijn: It detects the sandbox by itself. It should, anyway
00:58:23 <fbrusch_> seems like it doesn't really pass that to ghc
00:59:33 <srhb> fbrusch_: I'm at a loss, sorry. I'd suggest trying at least to nuke the sandbox and its config file, and see if the problem persists. If it does, I think you'd get more help from posting a bug report on the ghc-mod github.
00:59:51 <fbrusch_> if I withdraw the .cabal file (renaming it to .tmp, for instance), it works
00:59:58 <srhb> Uh..
01:00:01 <fbrusch_> ok, thanks a lot srhb!
01:00:09 <srhb> Yeah, no idea. :-)
01:00:41 <fbrusch_> no worries, i'll post that ;)
01:10:26 <fbrusch_> shrb: i nuked the sandbox, reinstalled deps, and now it works
01:10:35 <fbrusch_> thanks again :)
01:13:09 <srhb> fbrusch_: Magic! :-)
01:23:36 <fbrusch_> ok, maybe i pinned it down: it's the "dist" directory
01:23:58 <fbrusch_> if I rm it, ghc-mod works back
01:35:00 <srhb> Hmm, does anyone know what the correct incantation is for starting interactive-haskell-mode in emacs state with evil? I tried (evil-set-initial-state 'interactive-haskell-mode 'emacs)
01:36:28 <dreams> Hi, I he/quit
01:36:49 <vanila> dreams, huh?
01:38:01 <srhb> Duh, it's haskell-interactive-mode.
01:49:53 <phaazon> hi
01:49:59 <vanila> hi
01:50:03 <phaazon> what’s happening with hackagedb right now?
01:50:10 <phaazon> I can’t upload my new major version :(
01:50:19 <phaazon> got a 502
01:50:21 <vanila> its down, i think they are trying to fix it
01:50:54 <jle`> there is a post on the reddit about the details i think
01:51:07 <phaazon> thank you
01:51:12 <phaazon> I’m going to check that
01:55:35 <sgronblo> phaazon: http://status.haskell.org/
01:55:47 <phaazon> oh nice
01:55:49 <phaazon> thank you
02:04:50 * hackagebot xml-push 0.0.0.14 - Push XML from/to client to/from server over XMPP or HTTP  http://hackage.haskell.org/package/xml-push-0.0.0.14 (YoshikuniJujo)
02:05:02 <srhb> Ermergerd, it lives!
02:05:12 <srhb> rejoice!
02:07:49 <statusbot> Status update: Duncan Coutts was able to get the database into a consistent state again. No data was lost (except for a few hours worth of download stats). -- http://status.haskell.org
02:08:00 <dcoutts_> @arr!
02:08:00 <lambdabot> I'll keel haul ya fer that!
02:08:33 <jle`> the stats :'(
02:08:59 <sgronblo> http://status.haskell.org/ yay
02:09:05 <jle`> all green :D
02:09:26 <sgronblo> ah statusbot beat me to it
02:19:21 <jle`> @free transpose
02:19:22 <lambdabot> $map ($map f) . transpose = transpose . $map ($map f)
02:20:20 <jle`> @free reverse
02:20:21 <lambdabot> $map f . reverse = reverse . $map f
02:20:55 <vanila> @free ((a -> b) -> b) -> b
02:20:56 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
02:21:06 <jle`> i think you need to name it
02:21:16 <vanila> @free pleasework :: ((a -> b) -> b) -> b
02:21:17 <lambdabot> (forall p q. g . p = q . f             =>              g (h p) = k q) => g (pleasework h) = pleasework k
02:21:56 <jle`> @djinn ((a -> b) -> b) -> b
02:21:56 <lambdabot> -- f cannot be realized.
02:22:11 <jle`> so even though pleasework cannot be realized, you still have free theorems about it
02:22:13 <jle`> neat
02:22:24 <vanila> wht is "f" here?
02:22:32 <eazar001> yay!! hackage is up
02:22:51 <vanila> @free pleasework' :: ((a -> b) -> b) -> a
02:22:51 <lambdabot> (forall p q. g . p = q . f             =>              g (h p) = k q) => f (pleasework' h) = pleasework' k
02:22:54 <jle`> vanila: g p q and f are probably all functions
02:28:38 <jle`> @free isJust
02:28:39 <lambdabot> isJust = isJust . $map_Maybe f
02:28:45 <jle`> neat
02:30:04 <jle`> @free replace :: b -> Maybe a -> Maybe b
02:30:04 <lambdabot> $map_Maybe f . replace x = replace (f x) . $map_Maybe g
02:30:09 <jle`> free theorems are cool
02:30:54 <mroman_> @free bar :: a -> a
02:30:54 <lambdabot> f . bar = bar . f
02:30:58 <MP2E> wow lambdabot has a function for listing free theorems?
02:31:04 <mroman_> @free bar :: a -> [a]
02:31:04 <lambdabot> $map f . bar = bar . f
02:31:15 <MP2E> does it show if there's more than one?
02:31:18 <vanila> @free foldr
02:31:19 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
02:32:01 <mroman_> > let bar a = [a] in map (succ) $ map (pred) . bar $ 5
02:32:03 <lambdabot>  [5]
02:32:28 <mroman_> > let bar a = [a] in bar . (pred) $ 5
02:32:30 <lambdabot>  [4]
02:32:46 <mroman_> hu
02:32:50 <jle`> not sure why, but you mapped succ for some reason in the first one
02:32:53 <mroman_> what's $map f . bar = bar . f
02:33:06 <jle`> map f . bar = bar . f
02:33:21 <mroman_> so the $ isn't ($)?
02:33:50 <jle`> > let bar a = [a]; f = succ in ((map f . bar) 5, (bar . f) 5)
02:33:51 <lambdabot>  ([6],[6])
02:33:59 <jle`> no, it's just a part of the identifier
02:34:12 <mroman_> @free concat :: [a] -> [a] -> [a]
02:34:12 <lambdabot> $map f . concat xs = concat ($map f xs) . $map f
02:34:18 <vanila> @free (>>=)
02:34:18 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
02:34:28 <jle`> cannot do typeclasses i think
02:41:05 <NightRa> cabal install cabal-install fails with "cabal: does not exist". What should I do?
02:41:57 <dcoutts_> gah,  we should really fix that error message reporting. It's swallowing a vital bit of info (namely what file it's referring to)
02:43:34 <passy> Hi! I've got a really silly question. If I have a (Show a => Maybe a) and want to do a side-effecting IO operation on the value if it's defined, is there an easier way of doing that than `maybe (return ()) print (Just 5)`?
02:43:58 <NightRa> That was during "Configuring cabal-install-1.20.0.3..."
02:44:20 <vanila> passy, fmap print
02:44:25 <quchen> Nope
02:44:29 <vanila> or >>= print
02:44:31 <lpaste> killy9999 pasted “Type variables escaping scope” at http://lpaste.net/111658
02:44:36 <quchen> Nope
02:44:57 <quchen> vanila: fmap print gives you a Maybe (IO ()). >>= print gives you a type error.
02:44:59 <passy> vanila: But then (print) would have to be in the Maybe Monad, wouldn't it?
02:45:09 <killy9999> is there a way to make the code that I pasted compile?
02:45:20 <killy9999> seems like a fairly simple thing
02:45:21 <jle`> maybe (return ()) f is mapM_ f, btw, from Data.Foldable
02:45:33 <killy9999> but escaping scope of type variables is problematic
02:45:35 <passy> jle`: Ooh, that looks promising!
02:45:36 <jle`> or mapM, too
02:45:49 <dcoutts_> NightRa: you might get a better hint if you re-run with -v, we can see what it was doing just before
02:46:03 <jle`> from Data.Traversable
02:46:18 <jle`> :t mapM_ print `asAppliedTo` Nothing
02:46:19 <lambdabot>     Couldn't match expected type ‘[a]’ with actual type ‘Maybe a0’
02:46:19 <lambdabot>     In the second argument of ‘asAppliedTo’, namely ‘Nothing’
02:46:19 <lambdabot>     In the expression: mapM_ print `asAppliedTo` Nothing
02:46:24 <passy> jle`: I was actually looking at mapM_ but was surprised it took [a].
02:46:25 <jle`> :t F.mapM_ print `asAppliedTo` Nothing
02:46:26 <lambdabot> Show a => Maybe a -> IO ()
02:46:32 <passy> Didn't know there was an implementation in Data.Foldable, too.
02:46:38 <jle`> passy: i think that's going to be changed in the next ghc
02:46:46 <passy> jle`: Fantastic. Thank you!
02:46:53 <jle`> or at least, that's on the agenda
02:47:10 <jle`> :t T.mapM print `asAppliedTo` Nothing
02:47:11 <lambdabot> Show a => Maybe a -> IO (Maybe ())
02:47:20 <NightRa> dcoutts_: Here's the whole -v log
02:47:21 <NightRa> http://lpaste.net/111659
02:47:26 <jle`> so mapM_ is what you probably want, heh
02:47:39 <NightRa> Doesn't seem to give more useful information
02:48:10 <passy> jle`: Yup, that's exactly what I was looking for. Intuitively I thought Prelude.mapM_ would do that for me, I was just confused about the enforced list.
02:48:36 <jle`> you're not the first to think so :)
02:48:47 <jle`> but nice observation
02:48:48 <jle`> :)
02:51:41 <mroman_> @free foo :: f a -> (a -> f (f b)) -> f b
02:51:41 <lambdabot> Extra stuff at end of line
02:51:45 <mroman_> hm
02:52:09 <mroman_> what extra stuff?
02:52:32 <vanila> mroman_, it's not allowed to have f, you can use [] instead
02:52:43 <vanila> @free foo :: [] a -> (a -> [] ([] b)) -> [] b
02:52:43 <lambdabot> $map ($map g) . h = k . f => $map g (foo xs h) = foo ($map f xs) k
02:52:50 <vanila> and just interpret map as fmap
02:55:31 <dcoutts_> NightRa: feel like editing the code?
02:55:49 <NightRa> dcoutts_: What code O.o
02:56:10 <NightRa> dcoutts_: sure, I guess
02:56:18 <dcoutts_> NightRa: Cabal:Distribution.Simple.Utils.topHandler
02:59:00 <NightRa> dcoutts_: Probably not. I don't have any experience with cabal's source
02:59:22 <dcoutts_> NightRa: I can tell you exactly what to change
03:00:11 <dcoutts_> NightRa: in topHandlerWith, replace hPutStr stderr (mesage pname)  with  hPutStr stderr (show ioe)
03:00:11 <NightRa> So I'm cloning it locally now..
03:00:32 <dcoutts_> NightRa: or you can cabal get Cabal, to get the latest released tarball
03:00:46 <dcoutts_> don't need to use the git version
03:01:07 <Rc43> Hello.
03:01:29 <vanila> hi
03:02:02 <Rc43> Could anybody explain what are niches for shake and cabal? Do they intersect?
03:02:06 <Rc43> I understand that shake is supposed to be replacement for make and cabal is more than build tool.
03:02:08 <Rc43> Should I use them together or choose only one?
03:02:13 <NightRa> dcoutts_: What now?
03:02:44 <dcoutts_> NightRa: ok, having done that, install that modified Cabal. Did you use the release tarball or the git version?
03:02:55 <NightRa> release tarball
03:02:59 <dcoutts_> NightRa: ok good
03:03:00 <NightRa> cabal get Cabal
03:03:18 <dcoutts_> NightRa: so then you just cabal install ./Cabal  cabal-install
03:03:26 <dcoutts_> ie the local Cabal, and the hackage cabal-install
03:03:31 <dcoutts_> locally modified Cabal
03:03:42 <dcoutts_> or ./ if you're in the dir already
03:05:03 <NightRa> dcoutts_: Now it's compiling everything.. will take a moment
03:06:53 <dcoutts_> NightRa: if we hit the same problem (remember we're still using the original cabal-install here) then we may have to do the second step manually (which we can do using the modified Cabal)
03:07:05 <NightRa> http://lpaste.net/111660
03:08:40 <NightRa> dcoutts_: Seems to be the same problem indeed
03:09:30 <chris_> Huhu, i have very minor issue. Does any Arch-Linux user know how i can fixed this specific GHC warning? "Couldn't figure out linker information! Make sure you're using GNU gcc, or clang"
03:09:43 <dcoutts_> NightRa: ok, good. So now we cabal get cabal-install; cd cabal-install-x.y/; runghc Setup.hs configure --user
03:10:23 <chris_> compiling is working btw. :]
03:10:58 <NightRa> Seems to pass alright
03:11:51 <dcoutts_> NightRa: ok, then runghc Setup.hs build; runghc Setup.hs install
03:12:15 <dcoutts_> NightRa: it's odd actually, we were expecting the failure at the configure stage (but now with a more detailed error message)
03:12:31 <vanila> How to turn pattern matching into case trees?
03:13:15 <NightRa> It passed
03:13:36 <NightRa> dcoutts_: Yeah, it is odd
03:13:42 <dcoutts_> NightRa: hmm, then you should have the new cabal-install installed ok, but we never did discover the problem
03:13:53 <dcoutts_> NightRa: you can try cabal install cabal-install again :-)
03:14:13 <NightRa> cabal update still says there is a new version of cabal-install...
03:14:15 <NightRa> Will try
03:14:27 <dcoutts_> NightRa: check you're really using the new version you installed
03:14:34 <dcoutts_> e.g. check your %PATH%
03:14:47 <dcoutts_> vanila: see the chapter in SPJs book by Wadler
03:16:01 <NightRa> dcoutts_: Where's the new one supposed to be..
03:16:37 <NightRa> I have the haskell platform bins on the path
03:17:16 <vanila> thank you dcoutts_
03:17:56 <srhb> NightRa: On Linux, it's in ~/.cabal/bin
03:18:59 <dcoutts_> NightRa: it'll be close by to where the config file lives, which you can find with cabal --help
03:19:17 <dcoutts_> NightRa: it's deep in some Users dir on windows (windows standard location for per-user app data)
03:19:46 <NightRa> Will put now on path..
03:19:53 <AshyIsMe> so i could do with a little help:  http://lpaste.net/111661
03:19:58 <srhb> NightRa: Remember it must precede the global one
03:20:06 <AshyIsMe> code is here: https://github.com/AshyIsMe/lambdatwit/blob/master/Main.hs#L143
03:20:42 <AshyIsMe> how do i "execute" something in the context of a certain monad within another monad?
03:20:51 <NightRa> srhb: Thanks for noting that
03:20:56 <AshyIsMe> i realize that question probably doesnt make much sense
03:21:53 <srhb> AshyIsMe: What is call, and what is reply?
03:22:01 <NightRa> dcoutts_: Oh thank you very much! It's now updated
03:22:14 <AshyIsMe> call is from the twitter-conduit library: https://github.com/himura/twitter-conduit/blob/master/Web/Twitter/Conduit/Base.hs#L148-L158
03:22:16 <NightRa> Strange that we couldn't reproduce the error from the source
03:22:30 <AshyIsMe> reply is a couple functions above
03:22:39 <srhb> AshyIsMe: Anyway, the type of conduitmain must be wrong if you're lifting an IO action into it
03:22:48 <dcoutts_> NightRa: you might try cabal install cabal-install again and see if it comes up
03:23:14 <srhb> Well, not "must" but you needn't use liftIO if it really is an IO ()
03:23:37 <srhb> Urgh, I need to read indentation. Forget what I said. I get coffee and look again. :P
03:24:36 <NightRa> dcoutts_: Well, it now install fluently
03:24:43 <dcoutts_> sigh, ok
03:24:45 <NightRa> installs*
03:24:45 <dcoutts_> thanks
03:25:09 <NightRa> dcoutts_: Maybe it was the missing path to cabal's bin directory
03:25:21 <AshyIsMe> (call (reply 123 "blah") is of type TW m0 Status
03:25:31 <NightRa> (as it said it couldn't find it after all)
03:25:36 <AshyIsMe> it's the Status value that i want to get at
03:26:19 <NightRa> dcoutts_: Thank you very much!
03:26:36 <AshyIsMe> and in the context of runTW, call should do a web request
03:26:55 <dcoutts_> NightRa: np, thanks for trying to reproduce the error
03:29:53 <srhb> AshyIsMe: Can't you juts float the liftIO into the T.putStrLn and then get rid of the liftIO in liftIO $ call..?
03:30:07 <srhb> AshyIsMe: I'm not familiar with these libraries, but that do block looks like we're still in a TW context
03:31:17 <AshyIsMe> http://lpaste.net/111661
03:31:30 <AshyIsMe> the second error is what i get if i remove that liftIO
03:32:01 <srhb> AshyIsMe: Did you move the one in \status -> liftIO ... into the putStrLn?
03:34:48 <AshyIsMe> oh
03:35:10 <AshyIsMe> god i have so much more learning to do with haskell
03:35:14 <lpaste> srhb pasted “No title” at http://lpaste.net/111663
03:35:16 <jle`> don't we all
03:35:16 <srhb> Like that?
03:35:19 <jle`> :)
03:35:46 <AshyIsMe> yeah cheers
03:35:48 <AshyIsMe> that's working now
03:35:49 <srhb> AshyIsMe: :)
03:35:58 <AshyIsMe> thanks for that
03:36:15 <Arahael> Very nice. Cabal's sandboxes are even _better_ than most languages.
03:36:23 <AshyIsMe> don't look too far into what the project is yet, i'll announce it when it's working properly :)
03:36:26 <srhb> Arahael: We likes them. We likes them a lot.
03:36:39 <srhb> AshyIsMe: Heh, I'll save the clone for later. Looks exciting though! :D
03:37:11 <srhb> Love the name, too.
03:37:38 <AshyIsMe> hehe, cheers
03:38:19 <Arahael> srhb: Yeah - I used to think python's sandbox was good, but it's really crap compared to this. :)
04:12:29 <lericson_> python sandbox good? :D
04:12:41 <lericson_> it's as safe as a cardboard box
04:46:39 <NikolajK> can general recursion be expressed as catamorphism? that is, can I, with "cata alg *input*", produce every function (where alg some reasonable type, like f a -> a)
04:47:40 <vanila> NikolajK, you can't do e.g. tail on list, without using intermediate result like a tuple
04:48:43 <NikolajK> what does the tuple do here? story the current candidate for the last entry?
04:50:56 <nshepperd> :t asAppliedTo
04:50:58 <lambdabot> (a -> b) -> a -> a -> b
04:51:09 <vanila> > snd . foldr (\x ys -> (x:fst ys,fst ys)) ([],[]) $ "foobar"
04:51:11 <lambdabot>  "oobar"
04:52:55 <krgn__> agundry_: beep
04:54:54 <NikolajK> vanila: is that an answer to my question - if so, I don't understand it
04:55:57 <vanila> NikolajK, you cant implement pred with fold only, you need snd too
04:56:50 <NikolajK> okay… well I what I ment is getting full computation without using anything that smells like recursion, but cata
04:57:05 <NikolajK> product types and their associated functions are allowed
04:57:09 <NikolajK> and much more
04:57:31 <NikolajK> my point is this: could you teach primitive/general recursion fully in the framework of f-algebras
04:57:36 <NikolajK> ?
04:58:09 <vanila> no
04:58:17 <NikolajK> "alg = this is my definition of a function" ==> "cata alg *pass argument* = here is how it execuses"
04:59:06 <MagneticDuck> what should I use to send some word8's over a Network.Socket datagram socket?
04:59:21 <MagneticDuck> not quite sure why I have to import Language.Haskell.TH.Ppr to get bytesToString
04:59:43 <MagneticDuck> (should I use Data.Text? Do I have to unpack to send it?)
05:00:04 * hackagebot antagonist 0.1.0.25 - A web interface to Antisplice dungeons.  http://hackage.haskell.org/package/antagonist-0.1.0.25 (implementation)
05:01:13 <MagneticDuck> uhm x|
05:01:27 <MagneticDuck> I can just use concatMap toEnum
05:01:30 <MagneticDuck> sometimes I'm silly
05:03:54 <MagneticDuck> s/concatMap/map
05:04:28 <deni> who can i speak to if I want to help with making hackage more distributed, load balanced etc... if help is needed and the current setup needs improvements?
05:15:05 * hackagebot informative 0.1.0.2 - A yesod subsite serving a wiki.  http://hackage.haskell.org/package/informative-0.1.0.2 (implementation)
05:18:34 <Heffalump> deni: dcoutts can probably point you in the right direction
05:21:18 <rola> hi, can i lift the (++) and (+) out of "mappend (GL a f) (GL b g) = GL (a ++ b) (f + g)" to get something more like "mappend = … GL (++) (+)"
05:21:30 <deni> dcoutts_: let me know
05:22:49 <vanila> rola: you have to write it out long form because you basically need mappend (which is what you're implementing) to do this
05:23:03 <asfp> What security issues have been found in ghc?
05:23:31 <asfp> (except +RTS options)
05:25:15 <rola> vanila, why?
05:26:22 <bennofs> rola: you can make GL an applicative and then write: mappend a b = GL (++) (+) <*> a <*> b
05:26:53 <bennofs> hmm sorry, that wouldn't work
05:27:02 <bennofs> nvm
05:28:44 <brycelane> vague question, but are emacs and vim the preferred way to work with haskell? I'm coming from scala and love intellij. I find its much slower for me to learn libraries if I cant quickly step into their source code, get completion hints, etc.
05:29:04 <doismellburning> brycelane: I found the IDEA Haskell integration to not be worthwhile
05:29:41 <doismellburning> brycelane: so I use vim, vim2hs, and a hoogle plugin for Alfred
05:29:42 <doismellburning> ymmv
05:29:50 <Haskellfant> is there some shorthand for when cond action; guard cond
05:30:03 <brycelane> doismellburning: I haven't tried it yet, and found eclipseFP promising, but not quite it.
05:32:33 <brycelane> doismellburning, is the haskell-mode for emacs worth checking out? I've tried a few 'set it up' blogs, but it still doesn't seem to work right for me.
05:33:12 <doismellburning> brycelane: pass
05:33:12 <bennofs> Haskellfant: when cond action >> guard cond = when cond action >> when cond mempty = when cond (action >> mempty) = when cond mempty = guard cond, no?
05:34:21 <Haskellfant> bennofs: so you're saying the action won't be executed?
05:34:26 <bennofs> Haskellfant: oh, action >> mempty might not be equavilent to action
05:34:57 <bennofs> oops, I meant action >> mempty = mempty might not hold
05:35:07 * hackagebot informative 0.1.0.3 - A yesod subsite serving a wiki.  http://hackage.haskell.org/package/informative-0.1.0.3 (implementation)
05:35:41 <Haskellfant> hm
05:35:58 <bennofs> Haskellfant: so you can do when cond (action >> mempty)
05:36:00 <Haskellfant> in my case action is putStrLn
05:36:43 <{AS}> bennofs:  I think you meant mzero, right?
05:36:59 <bennofs> Oh yes, I meant mzero, sorry
05:37:09 <Haskellfant> bennofs: looks perfect, thx
05:37:54 <{AS}> bennofs: according to the MonadPlus laws (a >> mzero) should be mzero
05:38:13 <bennofs> {AS}: I read in haskellwiki that that law is controversial
05:38:14 <{AS}> so you where right the first time
05:38:19 <{AS}> Ah
05:38:30 <Haskellfant> {AS}: but if a is an io action it will still get executed, right?
05:39:10 <{AS}> I don't think IO is MonadPlus
05:39:53 <Haskellfant> {AS}: it is
05:40:01 <Haskellfant> defined in transformers-0.4.1.0
05:41:15 <{AS}> Haskellfant:  I can't find it
05:41:38 <{AS}> I mean the instance (not the package)
05:44:21 <krgn__> is it possible to register custom build tasks in cabal?
05:44:31 <dcoutts> yes
05:44:49 <Haskellfant> {AS}: I have to admit I can't find it either
05:44:49 <dcoutts> see the user guide on Custom setup types
05:44:52 <Haskellfant> but my code compiles :)
05:44:58 <Haskellfant> instance MonadPlus IO
05:45:00 <Haskellfant>   -- Defined in ‘transformers-0.4.1.0:Control.Monad.Trans.Error’
05:45:02 <krgn__> dcoutts: ah, instead of simple builds?
05:45:04 <Haskellfant> this is what ghci tells me
05:45:04 <{AS}> I think you are right :)
05:45:23 <krgn__> dcoutts: cool thanks!
05:46:34 <Heffalump> can I configure cabal's --builddir flag with an environment variable?
05:47:05 <dcoutts> Heffalump: sadly not
05:47:58 <Heffalump> how about .cabal/config ?
05:48:18 <Heffalump> (I don't see any option with 'build' in the name, so I worry that the answer is no :-) )
05:48:43 <dcoutts> Heffalump: again, no, because it'd be too global in the .cabal/config, so it's not supported there
05:48:53 <dcoutts> Heffalump: if you want to enable it, it's a one line change
05:49:18 <Heffalump> well, what I really want to do is have different nix build envs use a different dist dir, or alternatively just name it straight off the GHC version I'm using
05:49:26 <Heffalump> so I can have multiple trees simultaneously
05:49:42 <Heffalump> perhaps I can redirect the 'cabal' command itself
06:10:10 * hackagebot bindings-portaudio 0.0.2 - Low-level bindings to portaudio library  http://hackage.haskell.org/package/bindings-portaudio-0.0.2 (FumiakiKinoshita)
06:33:19 <vlopez> hi! i'm working with template haskell, and would like to normalize a type expression before manipulating it further. is there a way to do that?
06:33:29 <vlopez> here's a concrete example: https://stackoverflow.com/questions/26060701/normalize-type-family-instance-within-template-haskell-splice
06:49:21 <labancle> Can anyone explain this type for me: newtype Mu f = InF { outF :: f (Mu f) }
06:49:30 <labancle> ?
06:49:39 <vanila> labancle, sure, it takes a * -> * and builds a recursive type out of it
06:50:00 <vanila> it lets you write  data List a l = Nil | Cons a l
06:50:11 <vanila> and turn that into a proper list data type using  Mu (List a)
06:50:35 <labancle> vanila: What are InF and outF for?
06:50:47 <vanila> InF is the data constructor, and outF is the projector
06:51:03 <hyPiRion> labancle: http://patrickthomson.ghost.io/an-introduction-to-recursion-schemes/
06:51:26 <ion> Given “newtype Foo = InFoo { outFoo :: Bar }”, “InFoo :: Bar -> Foo” and “outFoo :: Foo -> Bar”
06:51:27 <vanila> to write  1 : 2 : []  in this   Mu (List Int),  it'd be   InF (Cons 1 (InF (Cons 2 (InF Nil))))
06:51:43 <hyPiRion> The Mu is equivalent to Term in that definition.
06:51:47 <hyPiRion> blogpost*
06:52:52 <labancle> thanks guys/gals, I'll read this and think about it
07:03:23 <matheus23_> Has anybody of you ever worked on GHC and can tell me where I find the function "showTerm" in GHC as a library? I saw the method in this wiki page: http://www.haskell.org/haskellwiki/GHC/As_a_library
07:04:32 <luite> matheus23_: if you click the link it takes you to the GHC API Haddock page for it?
07:05:05 <matheus23_> luite: thanks. I'm pretty dumb. I didn't see that link, only saw that in code :O thank you :) my bad
07:05:40 <luite> ok :)
07:07:50 <fds4345> Can't figure out how to use foldOf in Lens... anyone?
07:15:56 <albeit> Is there an equivalent of catMaybes for Maps? I need ":: Map a (Maybe b) -> Map a b"
07:16:45 <augur> @hoogle update
07:16:48 <lambdabot> Data.HashTable update :: HashTable key val -> key -> val -> IO Bool
07:16:48 <lambdabot> Data.IntMap.Strict update :: (a -> Maybe a) -> Key -> IntMap a -> IntMap a
07:16:48 <lambdabot> Data.IntMap.Lazy update :: (a -> Maybe a) -> Key -> IntMap a -> IntMap a
07:17:05 <augur> @update Data.Map.update
07:17:05 <lambdabot> Unknown command, try @list
07:17:08 <augur> whoops
07:17:11 <augur> @hoogle Data.Map.update
07:17:12 <lambdabot> Data.Map.Lazy update :: Ord k => (a -> Maybe a) -> k -> Map k a -> Map k a
07:17:12 <lambdabot> Data.Map.Strict update :: Ord k => (a -> Maybe a) -> k -> Map k a -> Map k a
07:17:12 <lambdabot> Data.Map.Lazy updateAt :: (k -> a -> Maybe a) -> Int -> Map k a -> Map k a
07:17:28 <ClaudiusMaximus> @hoogle Data.Map.mapMaybe
07:17:28 <lambdabot> Data.Map.Lazy mapMaybe :: (a -> Maybe b) -> Map k a -> Map k b
07:17:28 <lambdabot> Data.Map.Strict mapMaybe :: (a -> Maybe b) -> Map k a -> Map k b
07:17:28 <lambdabot> Data.Map.Lazy mapMaybeWithKey :: (k -> a -> Maybe b) -> Map k a -> Map k b
07:17:47 <ClaudiusMaximus> albeit: mapMaybe id
07:18:03 <augur> ClaudiusMaximus: \o/
07:18:04 <albeit> :t Data.Map.mapMaybe id
07:18:05 <lambdabot> M.Map k (Maybe b) -> M.Map k b
07:18:16 <albeit> ClaudiusMaximus: Perfect! thanks
07:18:40 <augur> > Data.Map.mapMaybe id (fromList [(1,Nothing), (2,Just "a")])
07:18:42 <lambdabot>  Not in scope: ‘Data.Map.mapMaybe’
07:18:42 <lambdabot>  Perhaps you meant ‘Data.Maybe.mapMaybe’ (imported from Data.Maybe)Not in sco...
07:18:42 <lambdabot>  Perhaps you meant one of these:
07:18:42 <lambdabot>    ‘IM.fromList’ (imported from Data.IntMap),
07:18:42 <lambdabot>    ‘M.fromList’ (imported from Data.Map),
07:18:46 <augur> gr
07:18:50 <augur> > mapMaybe id (fromList [(1,Nothing), (2,Just "a")])
07:18:51 <lambdabot>  Not in scope: ‘fromList’
07:18:52 <lambdabot>  Perhaps you meant one of these:
07:18:52 <lambdabot>    ‘IM.fromList’ (imported from Data.IntMap),
07:18:52 <lambdabot>    ‘M.fromList’ (imported from Data.Map),
07:18:52 <lambdabot>    ‘S.fromList’ (imported from Data.Set)
07:19:04 <augur> > mapMaybe id (M.fromList [(1,Nothing), (2,Just "a")])
07:19:05 <lambdabot>  Couldn't match expected type ‘[Data.Maybe.Maybe b]’
07:19:06 <lambdabot>              with actual type ‘Data.Map.Base.Map
07:19:06 <lambdabot>                                  k0 (Data.Maybe.Maybe [GHC.Types.Char])’
07:19:10 <augur> > M.mapMaybe id (M.fromList [(1,Nothing), (2,Just "a")])
07:19:12 <lambdabot>  fromList [(2,"a")]
07:19:15 <augur> finally
07:19:20 <ion> M.mapMaybe M.id
07:20:15 * hackagebot hourglass 0.2.3 - simple performant time related library  http://hackage.haskell.org/package/hourglass-0.2.3 (VincentHanquez)
07:21:25 <fds4345> anyone know how to use Control.Lens.foldOf to sum a list?
07:22:17 <albeit> @pl \p@(a,b) -> (a, f p)
07:22:17 <lambdabot> (line 1, column 3):
07:22:17 <lambdabot> unexpected "@"
07:22:17 <lambdabot> expecting letter or digit, operator, pattern or "->"
07:22:32 <albeit> @pl \(a,b) -> (a, f (a,b))
07:22:32 <lambdabot> uncurry (liftM2 (.) (,) ((f .) . (,)))
07:22:36 <albeit> Yikes
07:23:11 <ion> fds4345: Why not use sumOf instead?
07:24:06 <simon> albeit, looks arrowy
07:25:43 <zwer> > (fst &&& f) (a,b) :: (Expr, Expr)
07:25:45 <lambdabot>  (a,f (a,b))
07:26:06 <albeit> Wow okay. Thanks zwer
07:26:07 <simon> you beat me, zwer. I always confuse *** and &&&.
07:26:15 <albeit> :t &&&
07:26:16 <lambdabot> parse error on input ‘&&&’
07:26:20 <simon> albeit, &&& is in Control.Arrow
07:26:21 <albeit> :t (&&&)
07:26:22 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
07:26:27 <albeit> :t (***)
07:26:28 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
07:27:10 <simon> I don't think the type for arrows are very readable (not having read about arrows), so I usually just think of them in terms of 2-tuples :)
07:27:21 <albeit> Am I interpreting it right in that &&& only acts on the second element (with tuples), and *** on both?
07:27:30 <simon> s/the type for arrows/the type class that are mentioned in arrow operators/
07:27:39 <simon> albeit, no.
07:28:03 <albeit> > (g *** f) (a,b) :: (Expr, Expr)
07:28:05 <lambdabot>  (g a,f b)
07:28:12 <albeit> > (fst *** f) (a,b) :: (Expr, Expr)
07:28:13 <lambdabot>  Couldn't match type ‘Debug.SimpleReflect.Expr.Expr’
07:28:13 <lambdabot>                with ‘(Debug.SimpleReflect.Expr.Expr, b0)’
07:28:13 <lambdabot>  Expected type: (Debug.SimpleReflect.Expr.Expr,
07:28:13 <lambdabot>                  Debug.SimpleReflect.Expr.Expr)
07:28:13 <lambdabot>                 -> (Debug.SimpleReflect.Expr.Expr, Debug.SimpleReflect.Expr.E...
07:28:44 <exio4> > (fst *** snd) (1,2)
07:28:45 <lambdabot>  Could not deduce (GHC.Num.Num (a0, c'))
07:28:45 <lambdabot>    arising from the ambiguity check for ‘e_112’
07:28:46 <lambdabot>  from the context (GHC.Num.Num (a1, c'), GHC.Num.Num (a, b))
07:28:46 <lambdabot>    bound by the inferred type for ‘e_112’:
07:28:46 <lambdabot>               (GHC.Num.Num (a1, c'), GHC.Num.Num (a, b)) => (a, c')
07:28:50 <exio4> aw
07:29:06 <albeit> Ah one acts on the full pair (for tuples) and one just on the individual element?
07:29:13 <albeit> (For the first argument)
07:29:21 <simon> yes
07:29:34 <simon> one on the full pair, and the other pairwise
07:30:18 <simon> pity lambdabot won't rewrite using arrow operators.
07:30:48 <zmbmartin> I am trying to run 2 spock web servers at the same time. Spock is similar to Scotty -> https://gist.github.com/codedmart/2ac40c53279558df3411
07:30:57 <zmbmartin> Only the first one listed in main is run.
07:31:08 <zmbmartin> How could I run then both?
07:32:28 <Forgetaboutit> hey #haskell, I have a simple Parsec parser that parses a Char stream and returns a String.  But the type signature really scares me: `Stream s m Char => ParsecT s u m Char`. It also requires FlexibleContexts.  I'm wondering whether this is really necessary and how I could simplify it.  I'd appreciate any pointers.
07:33:31 <kstt> bgamari: hi !
07:34:11 <kstt> bgamari: question of the day : how to use your histo-chart package please ?
07:34:42 <bgamari> kstt, hi!
07:34:51 <kstt> I am looking for a way to turn a set of data into something renderable
07:35:01 <simon> Forgetaboutit, one way to simplify is to use :: Parser Char
07:35:03 <bgamari> kstt, it's pretty much the same as Chart
07:35:18 <bgamari> kstt, except for the fact that you need to turn the histogram into a plot
07:35:34 <simon> Forgetaboutit, Parser is a type alias that fixes some of those ParsecT parameters.
07:35:46 <bgamari> kstt, construct the PlotHist as you would in Chart
07:35:56 <bgamari> kstt, and use histToPlot to turn that into a Plot
07:36:04 <kstt> bgamari: so, PlotHist > Plot > ?
07:36:23 <bgamari> kstt, it actually seems there is now a ToPlot class which PlotHist should likely implement
07:36:34 <bgamari> kstt, one moment, I'll push out a new release
07:36:57 <kstt> Indeed, there is such a class.
07:37:11 <simon> Forgetaboutit, e.g. char 'x' :: Parser Char
07:37:23 <Forgetaboutit> simon: Thanks, I will try that :)
07:37:38 <bgamari> kstt, I believe this didn't exist when I initially wrote chart-histogram
07:38:38 <bgamari> kstt, ahhh, I remember the issue
07:39:18 <bgamari> kstt, I need to qualify x and y with constraints
07:39:30 <bgamari> kstt, so it looks like histToPlot is here to stay
07:39:42 <kstt> ok, no problem ! :)
07:40:06 <bgamari> kstt, You might find Test.hs helpful
07:40:13 <kstt> But then, how can I turn this into a Renderable ?
07:40:16 <bgamari> kstt, but don't hesitate to ask if you have questions
07:40:24 <kstt> Ok I'll look !
07:40:27 <bgamari> kstt, The usual toRenderable
07:42:32 <kstt> Indeed, I got confused. Trying right now, Tests will be helpful, I don't know how I missed it :)
07:42:36 <kstt> Thank you !
07:42:41 <albeit> Can &&& work on Maps the same way it works on tuples, except the first element is the key, and second the value?
07:43:08 <Twey> albeit: No
07:43:29 <Twey> albeit: (&&&) isn't actually about tuples at all: it's about functions
07:43:32 <simon> albeit, there is no Arrow k v => Map k v instance.
07:43:53 <Twey> Functions are arrows, so they have (&&&), which happens to use tuples as the product
07:44:00 <simon> ohh.
07:44:14 <Twey> So (&&&) is parametric on the arrow, not on the product
07:44:18 <EvanR> :t (&&&)
07:44:19 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
07:44:49 <simon> Twey, so a b c is an abstraction of 'b -> c'.
07:45:11 <Twey> albeit: But, there is Data.Map.Lazy.mapWithKey, which can be massaged to do it
07:45:23 <Twey> I guess Maps are maybe a bifunctor?
07:46:13 <Twey> simon: Yes.  With TypeOperators we often like to write Arrows as the variable ~>, like so: (&&&) ∷ Arrow (~>) → a ~> b → a ~> b' → a ~> (b, b')
07:46:41 <simon> haha
07:47:53 <noncom> hi!
07:47:56 <noncom> i get this error: http://joxi.ru/X3wlVP3JTJAZYu-qS6g
07:47:57 <Twey> simon: Then it becomes quite obvious that in the function case (~>) = (→).
07:48:04 <noncom> does anyone have an idea on how to fix this?
07:49:21 <Twey> noncom: The ‘websockets’ package is broken (probably depends on a more specific version of ‘network’ than it says.  Contact the maintainer.
07:49:32 <Twey> s/s\./s)./
07:49:52 <noncom> oh..
07:49:58 <Twey> noncom: Or, patch it to use the appropriate version and submit a pull request.
07:50:01 <simon> s/.$/)./
07:50:14 <albeit> So I'm trying to make a function ":: ((a,b) -> IO (Maybe c)) -> [(a,b)] -> IO (Map a c)". Right now my best shot is this (using arrows)... is it "good"? http://lpaste.net/111673
07:50:25 <noncom> i am so haskell noob, just need to compile "tidal"..
07:51:59 <Twey> noncom: What version of network do you have?  ( ghc-pkg list | grep network )
07:52:58 <noncom> Twey: it is network-2.4.2.3
07:53:19 <TallerGhostWalt> noncom: are you running on osx windows or linux?
07:53:21 <Twey> Ah
07:53:32 <TallerGhostWalt> noncom: I have a version running of tidal and could send you the freeze
07:53:43 <TallerGhostWalt> noncom: on both linux and osx
07:53:46 <Twey> « Send data to the socket. The socket must be in a connected state. This function continues to send data until either all data has been sent or an error occurs. If there is an error, an exception is raised, and there is no way to determine how much data was sent. Unix only. »
07:53:49 <TallerGhostWalt> noncom: ubuntu
07:53:52 <noncom> TallerGhostWalt: ummm, windows + cygwin :)
07:54:00 <Twey> It seems it counts as Windows.
07:54:02 <noncom> but ubuntu would be great too!
07:54:07 <Twey> tidal doesn't build on it, I guess
07:54:16 <Twey> It will probably build on Ubuntu, if you want to do it there.
07:54:19 <TallerGhostWalt> noncom: i'll gist a freeze of my build
07:54:56 <TallerGhostWalt> it definitely builds in ubuntu
07:54:57 <noncom> Twey: well, tidal has build wiki guide for windows... maybe it is outdated though..
07:55:18 * hackagebot bspack 0.0.2 - A simple and fast bytestring packer  http://hackage.haskell.org/package/bspack-0.0.2 (nicolasdp)
07:55:21 <noncom> i can go ubuntu if it really needs that
07:55:24 <Twey> noncom: It might just be confused by your setup
07:56:00 <Twey> Hm, the documentation explicitly suggests Cygwin
07:56:12 <TallerGhostWalt> noncom: tidal works great but setting up recording was really hard in ubuntu
07:56:38 <noncom> Twey: sure, what you see on sreenshot is cygwin shell
07:57:52 <MagneticDuck> trying to send some word8's via UDP, but I have a problem: I want the string to be sent using only ASCII encoding, and the encoding used seems to change in function of the character codes I'm sending O.o
07:58:20 <MagneticDuck> e.g. when I send (:[]) $ fromEnum 0, I get "00" as the hex data sent in the packet
07:58:25 <Twey> noncom: Hm, is your GHC also installed within Cygwin, or is that installed from Windows?
07:58:36 <MagneticDuck> but when I send (:[]) $ fromEnum 255, I DON'T get "ff" as the hex data in the packet
07:58:47 <MagneticDuck> I get something strange that's most certainly not "ff"
07:59:26 <MagneticDuck> I actually get "c3bf" as the packet data
07:59:51 <geekosaur> that looks like utf8 to me
07:59:57 <nshepperd> sounds like it's being utf-8 encoded from Char
08:00:05 <MagneticDuck> yeah
08:00:05 <nshepperd> or something
08:00:06 <ion> That’s UTF-8. But if you want something senty using only ASCII encoding, that should be fine, since you will not have bytes ≥ 0x80
08:00:13 <noncom> Twey: i installed ghc with cygwin. actually i followed the instruction absolutely. and tried on two machines. only one of them got this far
08:00:31 <TallerGhostWalt> noncom: that is determined!
08:00:49 <MagneticDuck> ion: doesn't the extended ASCII table include 255 characters?
08:00:59 <Twey> MagneticDuck: No.
08:01:00 <ion> There’s no such thing, or alternatively, everything’s that.
08:01:09 <nshepperd> extended ascii is a dirty lie
08:01:18 <MagneticDuck> Twey: I mean, 256
08:01:33 <MagneticDuck> okahy then.
08:01:42 <MagneticDuck> so, how do I get strings to act as [Word8]?
08:01:50 <Twey> MagneticDuck: There are several hundred encodings that are ‘extended ASCII’, potentially including UTF-8.  None of them is ASCII, though.
08:01:55 <MagneticDuck> or, how do I use Network.Socket to send a [Word8] with UDP?
08:01:59 <Peaker> MagneticDuck: there were many 128..255 extensions to ASCII called "code pages" back before Unicode took hold
08:02:18 <noncom> TallerGhostWalt: you mean what ?
08:02:21 <MagneticDuck> Peaker: ahk
08:02:33 <Twey> MagneticDuck: You probably want to use a ByteString
08:02:43 <MagneticDuck> does Network.Socket support bytestrings?
08:02:51 <MagneticDuck> or does unpacking into a string work
08:02:54 <Twey> https://hackage.haskell.org/package/websockets-0.9.0.1/src/src/Network/WebSockets/Stream.hs — looks like
08:02:54 <Peaker> MagneticDuck: use an AF_INET/Datagram socket (UDP) with the ByteString interface
08:03:11 <Peaker> MagneticDuck: http://hackage.haskell.org/package/network-2.6.0.2/docs/Network-Socket-ByteString.html
08:03:25 <MagneticDuck> ahk
08:03:54 <Twey> noncom: You can ask tibell about your issue — I think his package is relevant.
08:04:14 <Twey> Presumably Cygwin should be detected as *nix, but instead it seems to be considered Windows.
08:05:19 * hackagebot snaplet-ses-html 0.1.0.0 - Snaplet for the ses-html package  http://hackage.haskell.org/package/snaplet-ses-html-0.1.0.0 (DavidJohnson)
08:06:11 <MagneticDuck> question: doesn't the OverloadedStrings pragma make it possible to write bytestrings?
08:06:23 <noncom> Twey: yeah.. proably it thinks it is windows...
08:07:05 <nshepperd> not sure
08:07:52 <ddellacosta> opqdonut: I'm having a really dumb problem with your haskell-exercises (https://github.com/opqdonut/haskell-exercises): "Ambiguous occurrence ‘===’ ..." when I try to run the tests
08:08:01 <nshepperd> MagneticDuck: but if you want to put text into a bytestring you should really probably convert a String with a proper encoding function
08:08:12 <ddellacosta> wondering what stupid thing I'm doing wrong
08:08:32 <MagneticDuck> nshepperd: okay
08:08:55 <quinso> Is there a way to know what pattern I missed that haskell complains "Non-exhaustive patterns in function" about?
08:09:18 <Twey> MagneticDuck: The OverloadedStrings extension makes it possible to use string literals as ByteStrings.  But there are a variety of ways that could be encoded, so you probably want to import the .ByteString.Char8 or .ByteString.Latin1 package
08:09:28 <Twey> quinso: Ask #haskell ;)
08:09:37 <Twey> Usually it's quite obvious
08:09:55 <shachaf> quinso: GHC tells you.
08:10:05 <kstt> MagneticDuck: In a lot of cases literal bytestring are a code smell
08:10:12 <opqdonut> ddellacosta: hmm, W1? have you edited the W1.hs file yet?
08:10:12 <phaskell> W1 Ignore this, there is no way to delete panels. :( - https://phabricator.haskell.org/W1
08:10:15 <shachaf> quinso: At least it tells in the warning at compile-time. So turn on that warning.
08:10:15 <quinso> shachaf: ghci doesn't
08:10:16 <Twey> Often it tells you you forgot to match ‘x’ though.
08:10:22 <quinso> shachaf: and it's an error
08:10:33 <Twey> quinso: Oh, that's rather different.
08:10:40 <shachaf> quinso: Are you talking about "*** Exception: ..."?
08:10:42 <quinso> Twey: http://pastebin.com/yK535M8i the only guess I have is that the 3rd let statement deletes the first one
08:10:43 <ddellacosta> opqdonut: yeah, I have
08:10:50 <quinso> shachaf: yep
08:11:07 <ddellacosta> opqdonut: should I see what output I get with a fresh copy?
08:11:22 <shachaf> quinso: You're defining three different functions here.
08:11:22 <opqdonut> ddellacosta: yeah. that error might be caused by removing or altering a type signature in the file
08:11:33 <Twey> quinso: Yes, ‘let’s do not stack.  If you want multiple clauses for one function, you need to define them all in the same ‘let’.
08:11:35 <ddellacosta> opqdonut: ah, maybe I screwed something up, will try that--thank you!
08:11:36 <quinso> shachaf: really? Can't I partial define them in ghci?
08:11:40 <shachaf> quinso: If you want them all to be one function, put them all on one line separated with semicolons.
08:11:55 <quinso> Twey: shachaf: I see, thanks
08:12:01 <opqdonut> ddellacosta: if a fresh file works ok, I can still have a look at your W1.hs if you can't figure out what's wrong
08:12:11 <shachaf> quinso: And turn on the warning I talked about rather than saying it doesn't exist.
08:12:14 <Twey> let almostLast [x, _] = x; almostLast [] = error "almostLast: empty list"; almostLast (x : xs) = almostLast xs
08:12:26 <quinso> shachaf: I know about that warning
08:12:36 <Twey> quinso: GHCi will warn you too.
08:12:48 <opqdonut> ddellacosta: it's kinda dumb how simple errors can result in weird error messages from the tests. it might make sense for me to split each exercise into its own file. at least then you'd know which one has the problem...
08:12:55 <ddellacosta> opqdonut: hmm, actually when I wipe all the WX.hs files then run make again, then do runhaskell W1Test.hs, I get the same error
08:13:02 <quinso> Is it possible to tell ghci to warn me when I redefine some variable?
08:13:12 <ClaudiusMaximus> quinso: :set -Wall
08:13:18 <ddellacosta> opqdonut: ah, yeah, I was also wondering if there was a way to test things one-by-one, that'd be handy
08:13:18 <Philonous> Are any of the FRP libraries ready for general consumption?
08:13:20 <ClaudiusMaximus> or the particular more specific flag
08:13:24 <shachaf> quinso: Yes, that's also a warning you get with -Wall
08:13:25 <opqdonut> ddellacosta: o-kay. can you paste the full error somewhere?
08:13:31 <opqdonut> ddellacosta: no way to test one-by one really, sorry
08:13:35 <ddellacosta> opqdonut: sure thing, one sec
08:14:01 <Twey> quinso: http://lpaste.net/3881349193637298176
08:14:12 <Twey> Philonous: I'm using Sodium in production.
08:14:31 <ddellacosta> opqdonut: https://gist.github.com/ddellacosta/593f8334b0be02d1dd8b
08:14:43 <quinso> shachaf: ClaudiusMaximus: Nice. I guess I'll try to find if ghci has some kind of .pystartup and add that there
08:14:51 <Twey> quinso: ~/.ghci
08:15:02 <Philonous> Twey, Ah, great! Is it viable for driving UIs? (I remember that netwire didn't target that area)
08:15:15 <Twey> Philonous: Yes
08:15:20 <shachaf> You don't want -Wall because it warns about too many things. You'll want to turn at least one warning off.
08:15:28 <Philonous> Twey, Splendid! Thanks a lot.
08:15:29 <quinso> shachaf: what warning is that?
08:15:39 <shachaf> Something about defaulting.
08:16:03 <opqdonut> ddellacosta: ok I see. can you tell me which version of quickcheck you have? "ghc-pkg latest QuickCheck"
08:16:07 <shachaf> I guess you'll see.
08:16:17 <ddellacosta> opqdonut: QuickCheck-2.7.6
08:17:16 <opqdonut> ddellacosta: yeah, I can reproduce. I'll have a fix in a jiffy
08:17:38 <ddellacosta> opqdonut: awesome.  Thanks for your help, and for making this repo, psyched to go through these for practice. :-)
08:17:47 <opqdonut> (latest quickcheck apparently hsa the same === as I have :)
08:17:57 <ddellacosta> opqdonut: ah, I see, that would make sense given that error!
08:20:24 <egasimus> I'm trying to get the path of the PulseAudio socket via dbus (http://hackage.haskell.org/package/dbus-0.10.4/docs/DBus.html)
08:21:02 <egasimus> And I end up with an object which prints as `Variant (Variant "unix:path=/run/user/1000/pulse/dbus-socket")`
08:21:36 <egasimus> However, running `fromVariant` on it returns `Nothing`; I was expecting it to return `Just "unix:path=..."`
08:21:54 <egasimus> Can anyone help me figure out what I'm doing wrong?
08:23:04 <srhb> egasimus: Could it be that it's defaulting to a wrong a for IsVariant a?
08:23:05 <shachaf> egasimus: fromVariant :: Variant -> Maybe a
08:23:08 <shachaf> Where you get to choose a
08:23:12 <shachaf> What are you choosing a to be?
08:23:54 <bryanedds> Can anyone identity this function by its type: ('a -> 'b -> 'a * bool) -> 'a -> R 'a -> R 'b
08:24:05 <bryanedds> Or maybe tell me what a good name for it might be?
08:24:47 <shachaf> Maybe translate it to Haskell first?
08:25:21 * hackagebot objective 0.3 - Extensible objects  http://hackage.haskell.org/package/objective-0.3 (FumiakiKinoshita)
08:25:46 <egasimus> @srhb, shachaf: what's the syntax to specify `a`? The demo code goes like `let Just names = fromVariant (methodReturnBody reply !! 0)`...
08:25:46 <lambdabot> Unknown command, try @list
08:26:21 <srhb> egasimus: Throw parens around the expressions and :: WhateverYour-A-Is
08:26:30 <bryanedds> (a -> b -> (a, bool)) -> a -> R a -> R b
08:26:48 <shachaf> What's R?
08:26:58 <srhb> egasimus: let foo = (fromVariant bar) :: Maybe Type
08:27:07 <bryanedds> R is a contrafunctor
08:27:31 <shachaf> What, really?
08:27:49 <bryanedds> I can give you a fuller type
08:27:56 <shachaf> Then I don't think this is a good guessing game.
08:28:31 <bryanedds> (a -> b -> w -> (a, bool)) -> a -> R a -> R b
08:28:39 <bryanedds> where w is the state of the world
08:28:44 <egasimus> srhb: okay, making progress here -- `(fromVariant body) :: Maybe Variant` gives me `Just (Variant "unix:path=...")`.
08:28:53 <egasimus> lemme try to unwrap that further...
08:29:11 <srhb> egasimus: That's the IsVariant Variant instance.
08:29:23 <bryanedds> I have a function called scan that is of type (a -> b -> w -> a) -> a -> R a -> R b
08:29:23 <srhb> egasimus: Replace Variant with whatever the type of that unix:path thing is
08:29:46 <bryanedds> the only difference with it is that it calls the contrafunction unconditionally
08:30:17 <bryanedds> do I simply call this conditionalScan?
08:30:29 <bryanedds> or scanIf
08:30:36 <shachaf> What is R?
08:30:39 <bryanedds> I was hoping for something more formal than either
08:30:45 <srhb> egasimus: Or maybe you have to unwrap the Variant first and then what's inside, but I don't think so.
08:30:56 <Philonous> (fromVariant =<< fromVariant body) :: Maybe Text -- egasimus
08:31:16 <gregnwosu> hello does it make sense to have a reader monad that yields another reader monad of a different return type
08:31:29 <bryanedds> http://lpaste.net/111674 - that's R
08:32:13 <fds4345> anyone know the Lens way to apply a fold to a map?
08:32:21 <fds4345> foldOf?
08:32:23 <egasimus> srhb: I think those are nested Variants anyway. I've managed to get at the string inside using `let Just foo = (fromVariant body) :: String` twice, but I don't really understand why `let` works that way...
08:32:36 <albeit> fds4345: Might be worth trying #haskell-lens
08:32:51 <fds4345> albeit: thx
08:32:57 <srhb> egasimus: Because you're pattern matching on the result, it will fail horribly if it's not a Just constructor but a Nothing
08:33:06 <shachaf> egasimus: It doesn't really work, it crashes your program if the Variant type doesn't match.
08:33:10 <bryanedds> I added scan definition, and the definition of what has tentatively become scanIf - http://lpaste.net/111674
08:33:16 <srhb> egasimus: Check what Philonous wrote further up.
08:33:33 <bryanedds> I'm thinking there should be a more formal name for scanIf
08:34:25 <lnostdal> hi guys, i'm interested in reactive programming and i'm a haskell noob ..   just wondering if it is possible to have the compiler type check "reactive networks" in haskell? ..   i mean, e.g. have it detect circular references and stuff?
08:35:03 <fbrusch_> hi everybody
08:35:23 <bryanedds> lnostdal, I believe that's undecidable by any type system
08:35:26 <fbrusch_> I have troubles reading a structure from file
08:36:03 <lnostdal> bryanedds: ok
08:36:16 <bryanedds> but I'm also a haskell noob, so that my advice with a grain of salt
08:36:19 <fbrusch_> I have this: data Graph Stations Stops
08:36:36 <fbrusch_> thanks anyway, in advance :)
08:36:52 <fbrusch_> sometimes just a different point of view can help
08:36:53 <Bubblegum> hello, I want to drop the imperial thinking to become used to Haskell. How?
08:37:00 <Philonous> egasimus, «let (Just foo) = bar in ...» is equivalent to «case bar of Nothing -> error "pattern match failed"; Just foo -> ... »
08:37:17 <vanila> Bubblegum, first step: recursion
08:37:19 <fbrusch_> I compute this big structure
08:37:47 <Peaker> Philonous: not quite equivalent (lazy/irrefutable pattern match)
08:37:51 <fbrusch_> it's deriving Show and Read
08:38:06 <fbrusch_> I write it to file
08:38:14 <fbrusch_> when I try to read it back
08:38:16 <Peaker> let foo = case ... in ...  is equivalent, I think
08:38:28 <fbrusch_> it dies
08:38:34 <fbrusch_> ghci just exits
08:38:38 <fbrusch_> without a reason
08:38:43 <fbrusch_> I mean
08:38:46 <Philonous> Peaker, While I have to admit that I really didn't think of that, I still believe it's a close enough approximation in this case
08:38:47 <fbrusch_> without giving any reason
08:39:13 <Bubblegum> so vanila... by programming or by mathematical recursion or?
08:40:29 <vanila> Bubblegum, yes, recursive programming is an important step
08:43:07 <Bubblegum> okay.. should I try another language first or is haskell also a good source for recursion learning?
08:43:21 <vanila> haskell is very good for learning that
08:46:14 <Bubblegum> okay thanks for your suggestion
08:46:53 <Welkin> any functional language is naturally good for using recursion
08:47:07 <Welkin> don't use python though
08:47:16 <Welkin> it has terrible support for recursion
08:48:27 <opqdonut> ddellacosta: I just pushed a new version. try that
08:48:44 <ddellacosta> opqdonut: awesome, thanks!
08:50:12 <ddellacosta> opqdonut: working!  Thanks again.
08:54:49 <RegEchse> Bubblegum: btw, i think you meant "imperative programming". "imperial troops" are from star wars ;D
08:55:26 <RegEchse> (-programming, +thinking ... whatever)
08:57:31 <quinso> Is there a place where I can see big-O complexity for functions in prelude?
09:10:25 * hackagebot text-show 0.1.0.0 - Efficient conversion of values into Text  http://hackage.haskell.org/package/text-show-0.1.0.0 (ryanglscott)
09:14:37 <quinso> Can anybody help me find where it's said in haskell 2010 language report how algebraic structures should be represented and if lists have to be singly linked lists?
09:18:38 <geekosaur> quinso: libraries report, not language report, I'd guess. you "could" replace lists, your Haskell dialect will simply be incompatible with all others
09:20:15 <quinso> geekosaur: what do you mean by incompatible? I opened haskell 2010 language report and there it says how lists are algebraic data types with : as constructor. Maybe it says something how algebraic data types should be implemented in order to allow reuse of same nodes in multiple objects (like multiple list heads pointing to the same tail)?
09:22:45 <geekosaur> quinso: if (:) is a constructor with the type a -> [a] -> [a] then the only possible implementation is a linked list. the point being that, as a *constructor*, it can be pattern matched.
09:22:55 <geekosaur> and this forces the implementation
09:24:00 <geekosaur> yes, you can implement a function that does "the same thing" but with a more efficient underlying representation. but you can't *pattern match* on it, unless you drag in view patterns or etc.
09:24:14 <quinso> geekosaur: why can't we represent lists with arrays and just copy it entirely and allocate memory for length + one more element whenever we use constructor? Yeah I know that it's extremely inefficient.
09:25:40 <quinso> geekosaur: I am not trying to make a more efficient implementation of lists or anything like that. I am just arguing with a guy who says a compiler may represent lists however it wants.
09:26:17 <vanila> quinso, I compiler could do many things, but it's generally quite rational
09:26:22 <exfalso> hi, in QuickCheck is there a way to fail in the Gen monad telling quickcheck to retry generation?
09:26:28 <geekosaur> quinso, do you have an answer to the pattern matching incompatibility?
09:26:45 <vanila> quinso, one thing to keep in mind with GHC in particular is that it can sometimes optimize programs involving lists into ones without
09:27:19 <geekosaur> and yes, a big part of optimization is list fusion where, specifically *because* it's a linked list, it can be completely optimized away
09:27:46 <geekosaur> elements generated and consumed immediately without ever actually creating the list
09:28:12 <geekosaur> there are also strictness concerns with using an array
09:29:10 <geekosaur> because the spine of the array is by nature strict, whereas the spine of a linked list is lazy
09:29:31 <geekosaur> (this is why list fusion works, in fact)
09:29:39 <quinso> geekosaur: how is it incompatible? Create an array and store meta information about it. When doing pattern matching like (x : xs), create a new array of length N - 1 and store xs in it.
09:30:14 <geekosaur> ...and you think all that extra allocation and copying is an optimization?
09:30:25 <quinso> geekosaur: no, it would be extremely inefficient, I know
09:30:49 <quinso> geekosaur: but I am talking about if it would ok by haskell standard
09:31:31 <geekosaur> again, I point you to the libraries part of the report. as I said earlier, you could make this fit the language part, but you completely break the asymptotics in the libraries report
09:32:01 <quinso> geekosaur: Data.List part?
09:32:34 <geekosaur> that is where I would start, yes. the spec includes both laziness guarantees and asymptotics
09:32:53 <geekosaur> (and a fair number of ghc bugs have covered "optimizations" which violate one or the other)
09:34:14 <quinso> geekosaur: the only function I see a Big-O complexity for is "length"
09:34:56 <quinso> geekosaur: and surely you could make laziness with arrays too
09:35:15 <quinso> maybe
09:35:34 <silasm> quinso: doesn't repa kind of do that?
09:35:38 <geekosaur> it's much easier to force a linked list to have a strict spine than to force an inherently strict-spined data structure like an array to be lazy
09:36:03 <quinso> Something like store all calculated elements in the array and next to that store pointer to a chunk (that's how it's called, right?) that calculates what's next
09:36:04 <geekosaur> maybe you could find a way to do it reliably, but I sure wouldn't want to trust it...
09:36:22 <geekosaur> you're talking about element strictness there, not spine strictness
09:36:38 <quinso> geekosaur: can you explain what is spine strictness and element strictness?
09:36:43 <quinso> silasm: what's repa?
09:37:12 <geekosaur> element strictness is the strictness of the value itself. spine strictness is the strictness of the array slot it lives in
09:37:17 <geekosaur> (in this case)
09:37:29 <quinso> geekosaur: that didn't really explain anything
09:37:30 <geekosaur> but the whole point of the array is those slots are preallocated
09:38:04 <geekosaur> if you're not doing that, why are you bothering to use an array in the first place? but if you are doing it, the spine is by definition strict because it has been preallocated
09:39:34 <geekosaur> maybe another way to look at it: if I create a list with (1 : (2 : (3 : []))), element strictness means the values 1, 2, 3, [] only come into existence when needed; spine strictness means the (:)s only come into existence when needed
09:40:29 * hackagebot CSPM-FiringRules 0.4.3.0 - Firing rules semantic of CSPM  http://hackage.haskell.org/package/CSPM-FiringRules-0.4.3.0 (MarcFontaine)
09:40:31 * hackagebot monad-journal 0.5 - Pure logger typeclass and monad transformer  http://hackage.haskell.org/package/monad-journal-0.5 (DimitriSabadie)
09:40:49 <geekosaur> for some data structures this matters a lot for space usage; again, list fusion is an example here because the spine never needs to come into existence at all
09:41:22 <silasm> quinso: http://hackage.haskell.org/package/repa
09:41:56 <silasm> repa allows you to do some lazy things iirc, but I think it's still mostly used for strict operations.
09:41:56 <quinso> geekosaur: Let's say we have [1..]. So first we just have something pointing to a function. We need 1st and 2nd element - we call it twice and get an array with 2 pointers pointing to those 2 elements and next to it there's a pointer to a function which would be called if we needed the 3rd element, it would copy this array except with 3 slots and put another function next to it.
09:42:02 <geekosaur> another example: [1..] is an infinite list. what is your array representation?
09:42:49 <geekosaur> wow. this is something you could probably do if you were masochistic. it's much harder to get right, much harder to reason about, wastes more space, is much slower
09:43:01 <geekosaur> you *could* do it; the question is why you would ever want to
09:43:05 <quinso> geekosaur: I know
09:43:22 <geekosaur> since it's a clear loss in pretty much any way you look at it
09:43:32 <quinso> Now I am wondering if it would give any single advantage (maybe length being O(1) in some case)
09:44:05 <geekosaur> anything you gain from the array representation, you lose from supporting spine-laziness because it costs so much more
09:44:18 <geekosaur> your length is only O(1) if your spine is strict
09:44:55 <geekosaur> what is the big-O for your proposed [1..] representation? and how do you detect and distinguish it from [1..1000000]?
09:45:07 <geekosaur> when do you switch from one to the other?
09:45:29 * hackagebot postgresql-simple 0.4.5.0 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.4.5.0 (LeonSmith)
09:45:31 * hackagebot CSPM-Frontend 0.10.0.0 - A CSP-M parser compatible with FDR-2.91  http://hackage.haskell.org/package/CSPM-Frontend-0.10.0.0 (MarcFontaine)
09:45:33 * hackagebot CSPM-Interpreter 0.7.0.0 - An interpreter for CSPM  http://hackage.haskell.org/package/CSPM-Interpreter-0.7.0.0 (MarcFontaine)
09:45:34 <geekosaur> sorry, big-O for length on that fake-lazy-spine array?
09:45:35 * hackagebot CSPM-ToProlog 0.5.2.0 - some modules specific for the ProB tool  http://hackage.haskell.org/package/CSPM-ToProlog-0.5.2.0 (MarcFontaine)
09:45:37 * hackagebot CSPM-cspm 0.8.0.0 - cspm command line tool for analyzing CSPM specifications.  http://hackage.haskell.org/package/CSPM-cspm-0.8.0.0 (MarcFontaine)
09:46:03 <geekosaur> (not necessarily on the infinite one, that is obvious. I mean on the whole mechanism for faking a lazy spine)
09:46:22 <quinso> geekosaur: I know one case. Let's say we have [1..10] and call both some function which traverses the whole list and length or (!!). So if we do the function first, our array will be calculated and fully allocated and we would just pretend that it's lazy, but we would still have length and (!!) with O(1).
09:46:25 <EvanR> fake lazy
09:46:34 <geekosaur> the problems just keep piling up, and the apparent advantages get slimmer and slimmer
09:46:49 <monochrom> I am wondering whether this is an exercise of alternative implementation is just for the sake of being alternative.
09:47:27 <quinso> geekosaur: please don't tell me about disadvantages. I don't care and I am not actually going to use it anywhere. I was just wondering if it's legal. So if it's standart-compliant and has any advantage at all, then I know everything I need to know.
09:48:01 <EvanR> you can also store the already-known length of a list with the list
09:48:15 <EvanR> even if somehow you didnt evaluate the list yet
09:48:20 <quinso> EvanR: yeah, but what abotu (!!)?
09:48:39 <EvanR> for something 10 values long its not a problem
09:49:07 <geekosaur> it's technically legal if you keep piling on the hacks for corner cases. the potential for major bugs goes way up with every corner case though; I'd seriously not trust the implementation
09:49:21 <monochrom> Haskell 2010 does not say how to implement. It only says what I should be able to observe if I run my program on your implementation. It doesn't say how efficient your implement has to be either, but you will be competing with several competitors on this anyway.
09:49:40 <EvanR> sounds like c++ ropes idea
09:49:57 <EvanR> cant imagine it being efficient
09:50:23 <monochrom> this is what's wrong with using IRC to settle a debate with a friend who is not on IRC.
09:50:49 <monochrom> an instance of the middleman problem. that friend should come here talk directly.
09:50:50 <geekosaur> it's the kind of thing I naturally shy away from because spiraling complexity is the biggest enemy of implementation
09:51:05 <quinso> monochrom: he's not a friend and I am not even expecting him to agree with me on this. It's still interesting just to know.
09:53:19 <monochrom> in the case of this particular debate, I believe that the only disagreement is on whether one needs to say explicitly "subject to the conditions of running user programs correctly and staying competitive effciency-wise"
09:54:04 <geekosaur> probably. but I'm a sysadmin; I care a lot about that explicit caveat :)
09:54:47 <quinso> The original question was whether the compiler can optimize reverse and represent list as something else therefore not needing to allocate O(N) more memory to do reverse while still having O(N) complexity.
09:55:11 <geekosaur> there's also an aspect of the _Gödel, Escher, Bach_ thing about whether a refrigerator qualifies as a record player
09:55:16 <vanila> quinso, there are two haskell compilers, neither do that
09:55:30 <quinso> vanila: what's the 2nd one?
09:55:34 <vanila> EHC
09:55:52 <geekosaur> erm. then I count 4, or maybe 5
09:55:56 <quinso> What about hugs?
09:56:01 <vanila> hugs is long dead
09:56:18 <geekosaur> gh, jhc, ajhc if you count it (many of its features were merged into jhc), uhc is still being patched by someone, and you mention ehc
09:56:22 <geekosaur> *ghc
09:56:54 <quinso> I've never heard about EHC, the first page of google results doesn't link to it if I query EHC, gentoo doesn't have it in repos. Seems pretty dead to me too.
09:56:55 <geekosaur> they're trying to recover the hugs main repo, which was lost in a machine reshuffling at galois
09:57:22 <EvanR> lol
09:57:40 <vanila> quinso, it's under active development
09:57:53 <vanila> https://github.com/UU-ComputerScience/uhc
09:58:04 <geekosaur> oh, so ehc is actually uhc
09:58:10 <vanila> yeah
09:58:33 <geekosaur> so arguably three main haskell compilers active: ghc, jhc, uhc
09:59:08 <vanila> ah, well JHC is still under active development evidenced by mailin lists http://www.haskell.org/pipermail/jhc/2014-June/thread.html#1106
09:59:16 <vanila> that's cool, any info on this compiler?
09:59:30 <quinso> Hmm. Because of the letter j in jhc I expected it to compile to java machine byte code
09:59:35 <geekosaur> john kinda went on hiatus for a bit, which led to the ajhc fork which was later merged back in
10:00:12 <glguy> geekosaur: They turned that computer off because no one had logged into it in so long
10:00:23 * glguy just walked over and checked with Paul
10:00:25 <geekosaur> I can well imagine :)
10:00:39 <EvanR> is it java or john
10:00:45 <geekosaur> jhc compiles to ANSI C
10:00:48 <geekosaur> so it's not java
10:00:51 <vanila> http://repetae.net/computer/jhc/
10:03:31 <vanila> http://metasepi.org/doc/metasepi-icfp2014.pdf there's some notes on what ajhc produced that got merged
10:04:01 <vanila> "We reimplemented some parts of the NetBSD kernel under the protection of the Haskell type system, using Ajhc"
10:04:05 <vanila> that's pretty crazy
10:04:26 <EvanR> o_O
10:05:20 <vanila> ah
10:05:27 <vanila> JHC can't do monad transformers apparently
10:05:54 <EvanR> good ;)
10:07:59 <shiona> How would you guys represent a Poker hand (say hold em) in haskell given that you had a type Card ready? A list would be easy solution, but the type system could not whine if you happened to have ten card hands. Tuples aren't that easy to work on and I have no idea what kind of data-declaration could be useful
10:09:47 <albeit> shiona: Peano numbers / type arithmetic? Check out section 2 of this http://www.haskell.org/haskellwiki/Smart_constructors
10:10:46 <albeit> (I'm not super familiar with them, just ran into them yesterday and they look cool, and seem to fit your situation)
10:11:49 <vanila> slightly disappointing that atze seems to use GHC for his GUI stufff
10:11:55 <vanila> rather than his own compiler
10:12:02 <shiona> hmm, it seems this could be used to limit that no card has a number greater than 13. Maybe the hand size also.
10:12:23 <shiona> albeit: this is actually really neat use of peano I had never thought of, thanks
10:13:38 <josephle> shiona: if you don't want to do Peanos yourself, there's always Data.Vector.Fixed
10:13:46 <xandemente> Is there a reference like Real World Haskell a bit more updated around?
10:14:29 <shiona> josephle: nice, thanks
10:22:20 <vanila> http://www.cs.uu.nl/foswiki/pub/Ehc/TheArchitectureOfTheUtrechtHaskellCompiler/20090611-hs09-uhcarch.pdf
10:22:24 <vanila> EHC is very well designed
10:26:55 <josephle> what part do you think is well-designed?
10:27:36 <vanila> everything, check out the paper
10:28:01 <vanila> it uses attribute grammars and aspect oriented programming
10:28:18 <vanila> it sounds really hackable
10:28:50 <Welkin> what is the best haskell -> javascript project?
10:28:57 <Welkin> Fay? Haste? ghcjs?
10:29:08 <Welkin> there is also purescript
10:29:09 <phaazon> I’m also interested in that question
10:29:12 <vanila> Welkin, I've not tried it but EHC seems to be able to emit javascript
10:29:19 <vanila> may be worth investigating
10:29:37 <ion> Depends on whether you want the size of the resulting JavaScript code to be measured in kilobytes or megabytes.
10:30:37 <Welkin> well, which offers the most flexibility?
10:30:45 <Welkin> and integration with js libraries
10:34:49 <Welkin> this is interesting: http://haste-lang.org/haskell14.pdf
10:39:04 <bryanedds> what do you call a scan function without a state seed?
10:40:12 <Eduard_Munteanu> bryanedds, scan*1 ?
10:40:17 <Eduard_Munteanu> :t scanl1
10:40:18 <lambdabot> (a -> a -> a) -> [a] -> [a]
10:40:23 <Eduard_Munteanu> :t scanr1
10:40:24 <lambdabot> (a -> a -> a) -> [a] -> [a]
10:40:32 <bryanedds> ah
10:40:47 <bryanedds> not terrible elegant, but it'll work :)
10:40:51 <bryanedds> *terribly
10:43:52 <luite> Welkin: it's interesting, but the single websocket seems to be the achilles heel. i tried to convince Anton after he gave the talk that he should try to do typesafe resynchronization next, so that you can temporarily lose the websocket connection and catch up with the server later. the client should be able to continue working in desynched state for a while
10:44:56 <luite> Welkin: would be pretty cool if that worked in a somewhat general way, but it might be rather difficult to do
10:48:29 <bvad> Hey guys, quick question: I have a value of type 'Result a', where Result is an instance of 'Alternative'. Is it possible to 'lift' this value into a 'Maybe' instead of a 'Result'?
10:48:44 <bvad> That is, without writing the conversion myself of course :)
10:51:40 <albeit> Does making the "field" of an enum type strict do anything? "data Foo = !Bar | !Baz"
10:52:07 <shachaf> It is a syntax error.
10:52:14 <albeit> Oh. Ok
11:00:35 * hackagebot cndict 0.2.4 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  http://hackage.haskell.org/package/cndict-0.2.4 (DavidHimmelstrup)
11:10:41 <albeit> What is the fastest way to render an Int to some form of text with some padding? padInt 5 36 = "00036"
11:11:24 <albeit> Assuming the width of the padding is pretty much constant, but the Int value is not
11:11:59 <mauke_> > printf "%05" 36 :: String
11:12:01 <lambdabot>  "*Exception: printf: formatting string ended prematurely
11:12:03 <mauke_> > printf "%05d" 36 :: String
11:12:05 <lambdabot>  "00036"
11:12:19 <monochrom> printf is from the module Text.Printf, comes with GHC
11:13:02 <albeit> BUt I would guess its not the fastest?
11:14:27 <joelteon> it's unsafe
11:15:02 <albeit> Right now I'm using Data.Text.Format's "left", but it's not very fast
11:15:21 <mauke_> what are you doing to make that the bottleneck of your program?
11:15:36 * hackagebot BNFC 2.7.0.1 - A compiler front-end generator.  http://hackage.haskell.org/package/BNFC-2.7.0.1 (GregoireDetrez)
11:16:07 <albeit> mauke_: Logs, where I'm reading the system time then converting it to a readable format
11:16:28 <mauke_> and not using strftime or something?
11:17:32 <albeit> Hmm I actually didn't know a Hasekll library had access to that
11:18:08 <monochrom> I would think that reading the system time takes much longer already
11:19:01 <albeit> mauke_: Do you know any libraries that use the C version?
11:19:25 <mauke_> no
11:19:30 <albeit> monochrom: Takes a little bit, but the outputting takes quite a bit more
11:20:25 <albeit> Would it be safe to say that exposing C's stftime would be faster than any pure Haskell method?
11:20:37 * hackagebot cndict 0.2.5 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  http://hackage.haskell.org/package/cndict-0.2.5 (DavidHimmelstrup)
11:21:55 <monochrom> no, I am still not convinced. the things I heard is that reading the system time from Haskell (emphasis: I am not talking about reading the system time from C) goes through so many layers that it's dog slow.
11:24:18 <albeit> monochrom: How so? I'm using Data.Time.Clock's getCurrentTime, which uses getPOSIXTime, which just calls C's gettimeofday?
11:25:34 <monochrom> see, it's the FFI call that's slow. do you know how many things the RTS does for switching from Haskell to C and back?
11:25:44 <albeit> monochrom: Nope ;)
11:26:17 <akagr> Hi folks! I am following YAHT and wrote the following code https://www.refheap.com/90726
11:26:24 <johnw> you could make the call faster at the expensive of blocking the Haskell runtime during the call
11:26:28 <albeit> monochrom: What's an alternative to the FFI call?
11:26:29 <avaritia> hmm is it reasonable to write a chess engine in haskell?
11:26:30 <johnw> by marking the FFI import as unsafe
11:26:31 <akagr> I am getting lexical error at line 14 first character
11:26:38 <monochrom> there is no alternative.
11:26:56 <quchen> akagr: Those quotes look like fancy Unicode quotes. Use the normal ones.
11:26:58 <albeit> johnw: As in any Haskell code will be blocked until the call completes?
11:27:23 <johnw> albeit: correct, unsafe trades MUCH faster FFI for non-reentrancy into the RTS
11:27:25 <albeit> monochrom: So there is just no fast way to get the current tie in Haskell?
11:27:33 <albeit> *time
11:27:33 <monochrom> I am predicting that no matter how fast your formatter is, you will see no difference, because the call to getCurrentTIme takes all the time.
11:27:51 <recursion-ninja> Why is Data.Map NOT an instance of Applicative?
11:27:58 <iteratee> johnw: it blocks the current thread, not others, correct?
11:28:05 <monochrom> I am, effectively, saying that when you observe that your logger is slow, it is not because the formatter is slow.
11:28:14 <iteratee> albeit: you want an usafe call to get the time.
11:28:17 <johnw> iteratee: I'm pretty sure that's right, it blocks the current OS thread
11:28:18 <zwer> akagr did you use ’ instead of '?
11:28:28 <johnw> i.e., the capability
11:28:29 <akagr> quchen: indeed thanks!
11:28:49 <akagr> zwer: yes... didn't think the code would have that issue when I copied it
11:28:53 <iteratee> johnw: but if the unsafe call doesn't block, then it's not an issue.
11:28:54 <gregnwosu> getting a weird error in quickCheck
11:28:59 <johnw> iteratee: correct
11:29:19 <gregnwosu> its running on a linux chromebook but it seems to shrink forever
11:29:20 <johnw> iteratee: unsafe can be valuable for calls that are known to be extremely quick and non-reentrant
11:29:28 <albeit> johnw, iteratee: So it blocks the calling OS thread, but if the FFI call itself doesn't block, nothing is blocked?
11:29:35 <akagr> quchen: now I am getting parse error on line 16... what does it mean
11:29:38 <johnw> albeit: right
11:29:39 <iteratee> albeit: exactly.
11:29:50 <monochrom> the poster child for a good use of unsafe is sin
11:29:59 <iteratee> unsafe is a misnomer, it should be non-reentrant.
11:30:46 <iteratee> there are two cases that need to be safe: code that gets haskell callbacks, and code that may block, and you'd like to be able to do other work.
11:31:08 <iteratee> recv is not a good candidate for unsafe
11:31:25 <iteratee> (but that's not how haskell's recv is implemented anyway. Io manager etc)
11:31:29 <akagr> don't bother... it was issue with indentation
11:31:51 <quchen> akagr: That "do" block is poorly aligned, yes.
11:32:07 <quchen> Everything in a do-block should be aligned with the first word after the "do".
11:32:10 <zwer> akagr note that there are readFile and writeFile functions
11:32:15 <albeit> iteratee: What do you mean by code that gets Haskell callbacks? If I call, say, a C function and provide it with a function in my Haskell code to callback?
11:32:15 <zwer> :t readFile
11:32:17 <lambdabot> FilePath -> IO String
11:32:39 <johnw> albeit: unsafe doesn't really mean "unsafe": it means you're taking over some responsibility from a library/RTS, and that if you fail in that responsibility, there are no assurances
11:32:47 <iteratee> albeit: exactly that. You can't use unsafe in that case.
11:32:59 <johnw> in this case, the responsibility of making sure you don't re-enter
11:33:17 <akagr> zwer: thanks. I am following a tutorial. And a rather old (but still good, I think) one
11:33:21 <iteratee> it also means that if the called function blocks, the RTS won't re-enter.
11:33:28 <johnw> right
11:33:31 <albeit> johnw, iteratee: So, assuming the gettimeofday is non-blocking, I should be able to call it "unsafe"ly and have it pretty fast?
11:33:49 <zwer> akagr which one?
11:33:50 <johnw> albeit: the kernel context switch should dwarf the FFI call costs
11:33:52 <supki> recursion-ninja: no way to write 'pure'
11:33:57 <iteratee> even if it does block, it's OK.
11:34:02 <akagr> quchen: did not know that... so just indenting one more block to the right doesn't work for do blocks? It seems fine for everything else
11:34:14 <akagr> quchen: why the special case with do blocks
11:34:29 <akagr> zwer: Yet another haskell tutorial
11:35:01 <albeit> johnw: But wouldn't there also be a kernel context switch if called from a native C program?
11:35:07 <johnw> albeit: indeed
11:35:18 <johnw> what I'm saying is, unsafe should take Haskell's costs pretty much out of the equation
11:35:33 <quchen> akagr: The issue is that after the "do" you already have a function.
11:35:36 <albeit> Ahhh okay, I thought u were saying even with unsafe the context switch would dwarf it
11:35:45 <quchen> The first thing there defines where the do block is aligned at.
11:36:01 <albeit> *even without
11:36:44 <albeit> iteratee: So even if gettimeofday blocks, my OS thread won't block? What do you mean by "it's OK"?
11:36:48 <akagr> quchen: alright. Thanks. I am sure you saved my much head scratching.
11:36:56 <akagr> *me
11:38:12 <akagr> I am still getting a 'not in scope: bracket' error
11:39:11 <akagr> what do I need to import? Things seem to have moved since YAHT. Any ideas where can I get updated info on packages?
11:39:13 <albeit> akagr: What is the "bracket" function on line 32?
11:39:25 <mauke> @hoogle bracket
11:39:26 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
11:39:26 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
11:39:26 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
11:40:29 <akagr> albeit: according to tutorial, it takes three args... the thing to start with, the thing to do at the end even if error occurs, and the thing to do in between
11:40:46 <akagr> which I understand is especially helpful when dealing with files
11:41:07 <albeit> johnw: Ah shoot, it looks like Data.Time.Clock already uses a unsafe ffi call to gettimeofday...
11:41:56 <albeit> akagr: "import Control.Exception"
11:42:44 <monochrom> akagr: Control.Exception is one of those things changed after YAHT. but you can see my http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml
11:42:52 <johnw> albeit: :(
11:43:37 <monochrom> perhaps my next resort is to claim that reading system time is slow fundamentally :)
11:44:33 <monochrom> crossing the syscall layer can credibly be much slower than any slow formatter you could conceive...
11:44:38 <akagr> albeit: yep! :)
11:44:47 <akagr> finally got the code working.
11:44:53 <akagr> thanks guys!
11:45:14 <akagr> monochrom: great! thanks!
11:45:15 <johnw> yeah, kernel context switches are just slow
11:45:29 <albeit> monochrom: Fair enough, gonna time both and see why the formatter is so slow
11:49:34 <akagr> mauke: Is there a difference between the three brackets which lambdabot turned up?
11:54:21 <johnw> akagr: i imagine the second is a re-export of the 1st, and that the last one doesn't use the exception hierarchy, but you'd have to have to read the source to be sure
11:55:12 <akagr> johnw: ok
12:04:24 <monochrom> you probably no longer have Control.OldException on your GHC
12:08:25 <Mona23>  Hi! I give you some videos. I hope you like! http://tinyurl.com/ozfvxy3
12:10:41 * hackagebot persistent 2.0.8 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-2.0.8 (GregWeber)
12:10:43 * hackagebot persistent-mongoDB 2.0.8 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-2.0.8 (GregWeber)
12:10:45 * hackagebot persistent-template 2.0.8 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-2.0.8 (GregWeber)
12:37:53 <sbrg> it is really annoying that wgetting the haskell platform gets me access denied ..
12:38:30 <oiuuoo> sbrg: wget has a flat to change the user-agent, if that's the problem
12:38:34 <oiuuoo> flag*
12:38:42 <sbrg> oiuuoo: I really don't know -- I can try
12:39:23 <sbrg> it seems that did it indeed
12:40:11 <dmj`> sbrg: why not just wget ghc and cabal
12:41:20 <sbrg> dmj`: dunno. haskell platform is a easy package deal? it's not so much one or the other -- rather the fact that denying access to wget is silly..
12:49:53 <Kaligule> Hi there.
12:51:38 <Kaligule> I am searching for a funktion that gives me the name of a number. It would have type Int -> String.
12:51:54 <Kaligule> it would map 3 to "three"
12:52:03 <Kaligule> and 10 to "ten"
12:52:25 <Kaligule> Is there such a funktion or will I have to write it myself?
12:54:45 <sbrg> Kaligule: perhaps in a library
12:54:51 <sbrg> @hoogle Int -> String
12:54:52 <lambdabot> Test.QuickCheck.Text number :: Int -> String -> String
12:54:52 <lambdabot> Test.QuickCheck.Text short :: Int -> String -> String
12:54:52 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
12:56:30 <Kaligule> I hoped so, but I couldn't find it there.
12:57:06 <RegEchse> there's the "numerals" package on hackage (i haven't used it, though).
12:57:48 <RegEchse> Kaligule: it looks like "numerals" is what you want
13:00:29 <greeny> can anyone help me to understand this state monad expression: runState (liftM2 (,) get get) 3
13:00:39 <mauke> what's unclear?
13:00:45 * hackagebot GLUtil 0.8.2 - Miscellaneous OpenGL utilities.  http://hackage.haskell.org/package/GLUtil-0.8.2 (AnthonyCowley)
13:01:29 <Kaligule> RegEchse Thanks a lot :)
13:01:52 <xplat> mauke: why it doesn't use evalState?
13:02:11 <greeny> will the lifting evaluated at first?
13:02:13 <monochrom> perhaps because the author doesn't want it
13:02:27 <mauke> greeny: the outermost function application is run first
13:02:31 <mauke> that would be runState
13:02:56 <mauke> specifically, runState applied to (liftM2 (,) get get)
13:03:14 <monochrom> it may be a distraction to think too much of evaluation order at this time.
13:03:18 <mitchty> anyone used this https://github.com/mchakravarty/language-c-inline for simple c embedding or should i stick to c2hs you think?
13:03:35 <greeny> i suggest in liftM2 the bind will 'conat' the two get methods, or?
13:03:43 <dmj`> greeny: break it down
13:03:56 <dmj`> > flip evalState 3 $ get
13:03:58 <lambdabot>  3
13:04:09 <mauke> :-[
13:04:13 <dmj`> > flip evalState 3 $ (,) <$> get <*> get
13:04:13 <mitchty> wanting to get at the smc on my macbook pro and its all just straight c, but curious how you guys would do things
13:04:15 <lambdabot>  (3,3)
13:04:23 <mauke> greeny: what do you mean by that?
13:04:40 <dmj`> > flip evalState 3 $ do { a <- get; b <- get; return (a, b) }
13:04:42 <lambdabot>  (3,3)
13:05:03 <dmj`> liftM2 is equivalent to \f x y -> f <$> x <*> y
13:05:11 <dmj`> @typ liftM2
13:05:12 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:05:24 <dmj`> @typ \f x y -> f <$> x <*> y
13:05:25 <lambdabot> Applicative f => (a1 -> a -> b) -> f a1 -> f a -> f b
13:05:45 * hackagebot git-annex 5.20140926 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20140926 (JoeyHess)
13:05:49 <greeny> mauke: i dont get how the result state of the first get, become applied to the second get
13:06:06 <mauke> greeny: I don't understand what you mean by "applied to"
13:06:27 <greeny> f.e. this expression: do { a <- get; b <- get; return (a, b) }
13:06:32 <mauke> greeny: liftM2 (,) get get = do { x <- get; y <- get; return ((,) x y) }
13:06:43 <mauke> that's what liftM2 does
13:07:07 <simon> @typ pure f `ap` x `ap` y
13:07:08 <mauke> liftM2 f mx my = do { x <- mx; y <- my; return (f x y) }  -- literally the definition of liftM2
13:07:09 <lambdabot>     Couldn't match expected type ‘m a1’ with actual type ‘Expr’
13:07:09 <lambdabot>     In the second argument of ‘ap’, namely ‘x’
13:07:09 <lambdabot>     In the first argument of ‘ap’, namely ‘pure f `ap` x’
13:07:14 <monochrom> "applied to" is probably a wrong way to look at it
13:07:34 <dmj`> @typ liftM2 (,) getLine getLine
13:07:35 <lambdabot> IO (String, String)
13:08:26 <simon> greeny, "the result state of the first get, become applied to the second get" sounds like the state is itself a function applied to itself??
13:09:02 <greeny> but why can we write do { x <- get; y <- get ...} instead of do {x <- get; y <- get (state_of_first_get)}
13:09:13 <mauke> ah
13:09:24 <mauke> greeny: do you know how do-notation desugars?
13:09:33 <dmj`> greeny: think of it like liftM2 is a surfboard that is riding waves, when the waves dip you can scoop a value at the bottom, then wait until the next one to get the next value, there are many liftM types, liftM3,4 etc
13:09:59 <mauke> greeny: particularly this part: do { v <- X; ... } ==> X >>= \v -> do { ... }
13:10:04 <benzrf> > f x y
13:10:05 <lambdabot>  No instance for (GHC.Show.Show a0)
13:10:06 <lambdabot>    arising from a use of ‘M631031675482876368713544.show_M6310316754828763687...
13:10:06 <lambdabot>  The type variable ‘a0’ is ambiguous
13:10:06 <lambdabot>  Note: there are several potential instances:
13:10:06 <lambdabot>    instance [safe] GHC.Show.Show
13:10:08 <benzrf> > f x y :: Expr
13:10:09 <lambdabot>  f x y
13:10:11 <simon> greeny, 'get' does not take any explicit parameters.
13:10:12 <benzrf> huh
13:10:35 <mauke> greeny: what I mean by that is that using <- in a do block is really a call to >>= and some lambdas
13:10:54 <mauke> greeny: and >>= for State takes care of passing the state around
13:11:08 <simon> greeny, do { x <- get; y <- get; ... } is equivalent to get >>= (\x -> get >>= (\y -> ...)) -- thus you have an inner function ... that has access to both x and y (being equivalent in this case).
13:11:35 <monochrom> benzrf, it's because f, x, y are from Debug.SimpleRelect, the package is simple-reflect, and lambdabot has it.
13:11:57 <greeny> ok thank you mates :) that helps me a lot
13:12:26 <mauke> see also: programmable semicolon
13:13:55 <dmj`> greeny: you can call get as many times as you want and itll just keep pulling the state out
13:15:35 <benzrf> monochrom: IK
13:16:10 <Welkin> benzrf: can you use reactive banana with html/css?
13:16:37 <benzrf> Welkin: huh?
13:16:46 <Welkin> after compiling it to javascript
13:18:06 <dmj`> Welkin: you can use javascript with html
13:18:09 <dmj`> :)
13:23:45 <eagle_fly_> hi everyone
13:24:01 <Welkin> how long is lifenoodles?
13:24:42 <dmj`> eagle_fly_: yo
13:24:53 <Welkin> threepenny looks nice
13:25:21 <Welkin> I'm just looking for a good web UI framework
13:29:47 <eagle_fly_> Could anyone help with a simple problem. I have the following, where I need to find the states connected to initial state 0: type State = Integer tf = [(0,1),(1,2),(1,3),(4,5),(0,6),(6,7)]
13:30:22 <eagle_fly_> I try to use the following: getNeighbors:: State -> [(State,State)] -> [State] getNeighbors s ls = [ from | (to,from) <- ls, s == to]  traverse :: [State] ->  [(State,State)] -> [State] traverse [] _ = [] traverse _ [] = [] traverse (l:ls) ts =  getNeighbors l ts ++ traverse ls ts
13:31:16 <freeman42> beginner question, is it possible to apply a function to all guard values? can't find the right words to duck duck go for that
13:31:24 <Welkin> @lpaste
13:31:24 <lambdabot> Haskell pastebin: http://lpaste.net/
13:31:31 <Welkin> use that to share your code
13:31:40 <Welkin> rather than typing long lines into the channel
13:32:02 <eagle_fly_> ok, thanks!
13:32:15 <Welkin> freeman42: what do you mean?
13:32:18 <lpaste> freeman pasted “apply name ++ to both guards” at http://lpaste.net/111687
13:32:28 <freeman42> Welkin, http://lpaste.net/111687
13:32:35 <tommd> freeman42: Viewpatterns can help!    func (oper -> result) | pred1 result = expr1 ; | pred2 result = expr2
13:33:08 <tommd> Oh, nevermind. I misunderstood what you wanted.
13:33:12 <Eduard_Munteanu> freeman42, ViewPatterns or PatternGuards
13:33:27 <mauke> freeman42: huh?
13:33:43 <lpaste> glguy revised “apply name ++ to both guards”: “No title” at http://lpaste.net/111687
13:34:10 <freeman42> thank you, have to read about them
13:35:18 <glguy> freeman42: that paste is for you
13:35:18 <Welkin> you can use a case statement to do what I think you are looking for
13:36:27 <freeman42> glguy, ah, thanks, I see, hmmm, was hoping there was a more succint syntax
13:36:42 <Welkin> case toUpper (head name) of 'R' -> " plays banjo"; _ -> " does not play banjo"
13:38:14 <eagle_fly_> Ok, my question once again. If I want to find the states connected to state 0, where (0,3) means o is connected to 3. I want to apply traverse recursively, namely  traverse (traverse [0] tf) tf etc until it reaches a fixed point sort of. Anyone knows how to  achieve this? Code at http://lpaste.net/111688
13:38:51 <Welkin> freeman42: http://lpaste.net/111687
13:38:59 <Welkin> is that what you are trying to do?
13:39:17 <glguy> Welkin: No, he doesn't want to type "name ++" twice
13:39:22 <Welkin> oh
13:40:09 <freeman42> Welkin, as glguy mentioned, same functionality as http://lpaste.net/111687
13:41:06 <glguy> eagle_fly_: You'll need to maintain a set of states you've seen so far
13:41:24 <glguy> eagle_fly_: and avoid searches that start at a state you've already searched from
13:44:39 <lpaste> freeman revised “No title”: “No title” at http://lpaste.net/111689
13:44:51 <freeman42> wrong paste, meant to say, same functionality as: http://lpaste.net/revision/111689
13:45:09 <freeman42> was hoping there might be some simple syntax like: http://lpaste.net/111689
13:45:41 <glguy> eagle_fly_: http://lpaste.net/111688
13:47:10 <lpaste> glguy annotated “No title” with “No title (annotation)” at http://lpaste.net/111689#a111695
13:47:21 <glguy> freeman42: That's about as close as you're going to get to that sort of syntax
13:52:18 <freeman42> glguy, cool, the mutiway if :)
13:52:27 <eagle_fly_>  glguy: Thank you very much! This really helps a lot!!! I have a lot of learning to do, but I am really inspired now :)
13:59:37 <Rag_> how do I [f,g,h] and apply to [1,2,3] to get -> [f 1, g 2, h 3]
13:59:49 <Welkin> zipWith
13:59:54 <shachaf> zipWith ($)
14:05:50 * hackagebot NumInstances 1.4 - Instances of numeric classes for functions and tuples  http://hackage.haskell.org/package/NumInstances-1.4 (ConalElliott)
14:08:16 <eagle_fly> glguy++
14:08:54 <Bor0> I have this piece of code: http://lpaste.net/8552370344172716032. I don't like how things are done on line 22. what are other ways of doing this?
14:08:58 <glguy> eagle_fly: Do you understand why it works?
14:09:05 <glguy> Can you reproduce it without looking at it?
14:10:13 <merijn> hmm, if I need a data structure with fast insertion and fast access to the lowest element I want to look at priority queues, right?
14:10:16 <merijn> Any others?
14:10:26 <Bor0> I thought when (fromJust exception == ThreadKilled)  could work, but it does not
14:11:03 <yyttr3> How do I use attoparsecs string command? It requires a Data.ByteString.Internal.Bytestring. So how do I convert a string to that?
14:11:05 <joelteon> you're using isJust *and* fromJust?
14:11:16 <Bor0> it's just an example
14:11:18 <yyttr3> I've looked at the library docs and I can't find anything.
14:11:23 <Eduard_Munteanu> Bor0, you don't know it's an exception, all you know it's show-able
14:11:23 <dmj`> merijn: a dequeue is nice
14:11:27 <Bor0> joelteon, but what's wrong with using both?
14:11:29 <joelteon> yyttr3: overloaded strings
14:11:33 <joelteon> Bor0: pattern matching is faster
14:11:36 <dmj`> Bor0: go = try $ return () will be Right () everytime
14:11:40 <joelteon> yyttr3: or Bytestring.pack
14:11:48 <Bor0> dmj`, I know, it's just an example code :)
14:12:18 <merijn> dmj`: dequeue don't generally have cheap access to a "lowest element", no?
14:12:26 <Bor0> mainly I want to know a different way to handle what line 22 does, this looks hackish to me
14:13:11 <glguy> Bor0: http://lpaste.net/8552370344172716032
14:13:11 <dmj`> merijn: Bankers Dequeue does
14:13:15 <Eduard_Munteanu> Bor0, 'catch'
14:13:28 <glguy> Bor0: and then change the type signature of checkException to work on SomeException
14:13:36 <dmj`> merijn: constant for length, first and last, https://hackage.haskell.org/package/dequeue-0.1.5/docs/Data-Dequeue.html
14:13:52 <seagreen> Anyone know of an especially well written HTTP client library in Haskell? I'm writing one for PayPal and could use a good reference.
14:13:59 <dmj`> Bor0: you're probably killing the os thread since you're not spawning a green thread with forkIO
14:14:03 <merijn> dmj`: I don't want "first" I want "lowest"
14:14:22 <merijn> dmj`: efficient first operation is just FIFO
14:14:37 <dmj`> merijn: oh, I thought about 'last' when I read 'lowest' for some reason
14:14:48 <eagle_fly> glguy: I do understand how it works (I think). I was unsure how to keep the states already visited. And Data.Set seems really useful, I should dig in.
14:14:49 <dmj`> seagreen: I use http-streams for stripe and its great
14:15:16 <dmj`> seagreen: https://github.com/dmjio/stripe-simple/blob/master/src/Web/Stripe/Client/Internal.hs
14:15:18 <merijn> dmj`: I have some ordering and I want efficient insertion and efficient access to the lowest elemtn given my ordering, hence why I thought priority queues
14:15:19 <johnw> seagreen: wreq?
14:15:27 <seagreen> dmj`: Sorry, I didn't ask that clearly. I've settled on wreq . . .
14:15:29 <merijn> I was just checking whether there was anything else I was unaware of
14:15:44 <seagreen> . . . I meant to ask about an actual client lib, like stripe-haskell or something.
14:16:23 <seagreen> Actually I bet hs-stripe is good.
14:16:56 <dmj`> seagreen: no its not, that's why I rewrote it, stripe-simple
14:17:20 <dmj`> seagreen: I use hs-stripe currently
14:17:42 <seagreen> dmj`: Is your rewrite public?
14:18:06 <dmj`> seagreen: it will be soon, it could be now, but I want full stripe api coverage. It covers a *lot* more than hs-stripe
14:18:37 <dmj`> seagreen: and I want a lot of tests, which take so much time to write
14:18:49 <seagreen> Gotchya. I'm getting everything in my lib working fine so far, but as a newb I could use a reference for how to expose my code nicely to the outside.
14:19:15 <Bor0> glguy, now I get Couldn't match expected type `SomeException' with actual type `AsyncException'
14:20:20 <alrunner4> merijn: heaps are log n insert, constant top
14:20:57 <glguy> Bor0: then remove the "fromException" part if you already have an AsyncException
14:21:31 <trap_exit> what's the state of the art in terms of "safe haskell hw submission system" i.e. I want something where (1) Students submit fragments of haskell code (2) I run the code, and (3) I don't have to trust the students
14:23:21 <dmj`> seagreen: hs-stripe uses monad transformers which I didn't see as necessary in the api. For issuing requests I would do so with result <- waithCatch =<< async request, then return an Either for the result. This will catch async exceptions. You could use `catchAny` from enclosed exceptions though. Stripe has a *ton* of optional parameters, so I'm making a seperate function for each, then exposing a base function that users can cust
14:23:21 <dmj`> their requests. The biggest problem is dealing with types, since their are so many. I have a massive types file because of recursive imports a customer has optional charges, charges have a customerId. I recommed refactoring all the common types into their own folder, I'm doing to do this
14:23:30 <dmj`> seagreen: it just takes a long time to do things
14:24:11 <dmj`> I'm going*
14:24:31 <seagreen> dmj`: Thanks so much!
14:26:47 <dmj`> seagreen: will be interesting to see if stripe or paypal puts bitcoin in their api first
14:28:05 <evancz> does anyone know a library that can download files through HTTP that is cross platform?
14:28:21 <seagreen> dmj`: Is stripe-simple destined for GitHub, and if so what's yours?
14:28:55 <dmj`> github.com/dmjio/stripe-simple
14:29:00 <dmj`> https://github.com/dmjio/stripe-simple/tree/master/src/Web/Stripe is the coverage
14:29:18 <evancz> I have found "download" and "download-curl" but it looks like neither will work on windows
14:30:52 * hackagebot hackport 0.4.4 - Hackage and Portage integration tool  http://hackage.haskell.org/package/hackport-0.4.4 (SergeiTrofimovich)
14:31:01 <seagreen> dmj`: Fantastic, between that and https://github.com/jwiegley/github I now have lots of yummy example code.
14:31:13 <dmj`> seagreen: [ (key, value) | (key, Just value) <- params ] is a good trick for optional params
14:32:17 <dmj`> seagreen: do you have a repo for the paypal api?
14:32:49 <Welkin> how do you connect the views with haskell code when cross-compiling to iOS?
14:33:19 <seagreen> Not yet, I just started on it a couple days ago. Want me to ping you here if we open source it?
14:33:31 <dmj`> seagreen: yea definitely
14:33:38 <Rag_> how do I [1,2,3] write it three files file1 should be 1, file2 should have 2 and file should have 3?
14:33:50 <seagreen> dmj`: Sweet! It would be pretty cool for haskell to have great PayPal and Stripe clients.
14:34:05 <Welkin> zipWith writeFile
14:34:31 <Welkin> zipWith writeFile [file1, file2, file3] [1,2,3]
14:34:45 <Welkin> :t writeFile
14:34:46 <lambdabot> FilePath -> String -> IO ()
14:34:56 <Welkin> well, they have to be strings
14:36:12 <Rag_> thanks Welkin
14:38:08 <dmj`> seagreen: I agree
14:41:28 <freeman42> what is using the @ symbol called? eg. areYouPlayingBanjo name@(c:_)
14:41:46 <alrunner4> as patterns
14:41:47 <freeman42> I see it is used for pattern matching, but does it have a name for using that form of it?
14:42:04 <Welkin> I have heard it called at-notation
14:43:06 <alrunner4> https://www.haskell.org/tutorial/patterns.html
14:43:09 <Welkin> LYAH calls them "as patterns"
14:43:25 <freeman42> found here also https://www.haskell.org/tutorial/patterns.html thank you :)
14:43:57 <josephle> it would make sense, since the ML's use "as" (i.e. fun foo (l as (x::y)) = ...)
14:45:15 <bcap> hello fellow haskellers!
14:45:21 <josephle> hello :)
14:45:22 <Welkin> http://www.haskell.org/haskellwiki/Do_notation_considered_harmful
14:45:26 <bcap> simple question (but mayb a complex answer)
14:45:32 <Welkin> nice article
14:45:33 <bcap> why Num is not a subclass of Ord?
14:45:46 <Welkin> there are no subclasses
14:45:49 <bcap> or, idk if haskell has subclasses at all
14:45:51 <bcap> oh
14:45:53 * hackagebot unlit 0.3.0.2 - Tool to convert literate code between styles or to code.  http://hackage.haskell.org/package/unlit-0.3.0.2 (pepijnkokke)
14:46:12 <bcap> but its not a bad rationale to assume that all Num should also be Ord, right?
14:46:19 <merijn> bcap: Not all num are Ord
14:46:25 <bcap> aha
14:46:26 <bcap> !
14:46:27 <josephle> bcap: could you reasonably define an Eq instance for Double?
14:46:28 <merijn> bcap: It is, simple counter example: Complex numbers
14:46:38 <merijn> josephle: Yes, IEEE754 equality
14:46:39 <mauke> josephle: yes
14:46:57 <monochrom> I think that the mention of Double derails the consideration completely
14:47:13 <bcap> josephle you mean because of the floating point error ?
14:47:25 <josephle> fair enough
14:47:28 <merijn> Welkin: Haskell does have subclasses for typeclasses
14:47:36 <merijn> Welkin: For example, Applicative is a subclass of Functor
14:47:53 <bcap> merijn i never studied much complex number
14:48:00 <bcap> merijn didnt know you cant order them
14:48:12 <merijn> subclass just means something different from OO subclass, the same way typeclasses are different from classes
14:48:16 <bcap> got me thinking on that
14:48:23 <mauke> (e -> Integer)
14:48:58 <HeladoDeBrownie> bcap, complex numbers have two components, and they are unordered with respect to each other, so you run into problems trying to decide whether, e.g., 2+3i > 3+2i
14:49:41 <bcap> complex numbers are one of those holes in my education. I just know they exist, but its just too magical. Should study them more
14:49:53 <mauke> no magic
14:50:06 <mauke> just pairs of reals
14:50:10 <bcap> magical in the sense that I just believe in it but does not understand
14:50:21 <Welkin> bcap: x-axis is the real numbers, y-axis is the imaginary numbers
14:50:25 <bcap> magical like in a magical trick
14:53:10 <bcap> so, complex numbers are like 2 dimensional numbers while real numbers are one dimension, right?
14:53:32 <bcap> so to ordenate them you would need some function that transform the 2 dimensions into 1
14:53:45 <Welkin> ordenate?
14:53:52 <bcap> compare them
14:53:57 <mauke> order
14:54:09 <bcap> sorry, english is not my primary lagnauge
14:54:14 <bcap> i meant order
14:54:16 <bcap> or compare
14:54:24 <Peaker_> bcap: you could just "deriving Ord" on the Complex type, but that would be surprising/confusing
14:54:33 <Peaker_> it might still make sense for placing Complex numbers in a Data.Map though
14:54:34 <shachaf> You don't need that, you just need a function that compares two complex numbers.
14:54:44 <shachaf> f :: Complex -> Complex -> Ordering
14:55:28 <bcap> this is just a thought exercise
14:55:29 <Peaker_> Perhaps Haskell should have "Ord" and a separate, empty class to specify that it has the "mathematical" meaning of Ord
14:55:43 <Peaker_> (Complex would be an instance of Comparable, but not Ord, or such)
14:56:27 <merijn> bcap: It's not that you *can't* order Complex numbers, it's just that it's not clear how they *should* be ordered
14:56:44 <merijn> bcap: And the decision was "no ordering is better than a confusing/surprising one"
14:57:02 <bcap> merijn yeap, makes sense, is undefined stuff
14:57:26 <bcap> was just thinking on some possible specific definitions
14:57:50 <bcap> if they all fall in taking a 2 dimensional number and coverting into a one dimensional and them comparing
14:58:05 <bcap> like, if you take by the vector absolute value
14:58:17 <bcap> of the vector that the complex number forms
14:58:26 <RegEchse> "It's not that you *can't* order Complex numbers" <- from a mathematical point of you, you actually "can't". (at least in the sense of a ordered field, and that's what any mathematician would expect)
14:58:40 <bcap> you are like converting a 2 dimensional input into a 1 dimensional output
14:59:15 <bcap> and them comparing this one dimensional thing
14:59:26 <bcap> the thought exercise, what got me curious was
14:59:41 <bcap> if to compare stuff you always need to go to a one dimensional approach
14:59:54 <bcap> if you can only compare one dimensional variables
15:00:05 <bcap> thats what got me curious about now
15:00:11 <bcap> its not even about haskell anymore
15:00:11 <mauke> you can compare strings
15:00:46 <bcap> mauke well, the way we compare strings is one dimensional also
15:00:55 <mauke> is it?
15:01:09 <bcap> yeap
15:01:17 <mauke> how?
15:01:33 <bcap> there always only 2 variables being compared to each other
15:01:46 <bcap> the point is, can we compare things that are not pairs?
15:01:48 <joelteon> well, compare only takes two arguments
15:01:51 <shachaf> Oh. Then only compare two complex numbers to each other. Done.
15:02:05 <bcap> but 2 complex numbers are like 4 numbers going in
15:02:14 <joelteon> But two lists are like a bunch of elements.
15:02:29 <bcap> yeah, but we keep comparing in pairs of those lists
15:02:30 <shachaf> A string is like a whole buncha numbers going on.
15:02:47 <joelteon> Yeah but there are only two parts to a complex number.
15:03:11 <bcap> its an abstract exercise, sorry that this is not about haskell anymore
15:03:33 <joelteon> I'm confused.
15:03:40 <bcap> but the central point of the question is: comparing. Is comparing always a function that takes only 2 arguments?
15:03:47 <bcap> no haskell in the play
15:03:52 <joelteon> Comparing complex numbers is even easier than comparing lists because complex numbers are sort of like 2-element lists.
15:03:53 <bcap> more about mathematics
15:03:56 <Bor0> > sort [[1], [7], [4, 1], [3, 5], [3, 9]]
15:03:58 <lambdabot>  [[1],[3,5],[3,9],[4,1],[7]]
15:04:13 <RegEchse> if this is a mathematical question, then please define "compare"
15:04:15 <RegEchse> t:)
15:04:17 <Bor0> it sort of sorts and groups at the same time. I expect same behaviour with complex numbers
15:04:17 <RegEchse> -t
15:04:45 <bcap> RegEchse yeah, thats the point, Im actually asking if there is any valid defintion of compare that takes more than 2 arguments
15:05:01 <bcap> im probably hitting some core math premisses here
15:05:03 <joelteon> Why would you do that?
15:05:10 <joelteon> Sorting algorithms usually compare two elements at a time anyway.
15:05:12 <Bor0> > sort [(1,2), (3,4), (1,3)]
15:05:14 <lambdabot>  [(1,2),(1,3),(3,4)]
15:05:17 <joelteon> I can't think of times I'd want to compare 3 elements at once.
15:05:19 <bcap> idk, im curious about the way the universe is
15:05:23 <joelteon> That can't just be reduced to 2 elements.
15:05:39 <Welkin> bcap: the universe?
15:05:46 <Welkin> this is just something people made up
15:05:48 <Welkin> numbers
15:05:49 <geekosaur> bcap: the concept of ordering can be generalized, but the standard one works in one dimension on a total order and hence works by comparing two elements.
15:05:53 <Welkin> computers
15:05:54 <Hijiri> complex number s arent two element lists
15:05:57 <bcap> well, yes
15:06:00 <Hijiri> because lists are ordered
15:06:18 <bcap> geekosaur exactly! ordering always works on only 1 dimension
15:06:21 <geekosaur> and, well, in higher dimensions things can vary. so for example there is no meaningful standard ordering for complex numbers, which represent a plane instead of a line
15:07:10 <geekosaur> the question "is 4+3i larger or smaller than 3+4i" is meaningless, or rather has different meanings depending on whether you treat it as polar or rectangular
15:07:30 <bcap> oh crap
15:07:34 <bcap> i really got to go now
15:07:41 <bcap> got to pickup my girlfirend
15:07:47 <bcap> but this is a great discussion
15:07:50 <bcap> at least for me
15:08:07 <bcap> thanks for all that participated
15:08:09 <bcap> and sorry
15:08:27 <Welkin> thanks for the topic
15:10:55 * hackagebot zeromq4-haskell 0.6.2 - Bindings to ZeroMQ 4.x  http://hackage.haskell.org/package/zeromq4-haskell-0.6.2 (ToralfWittner)
15:20:56 * hackagebot rakhana 0.2.0.0 - Stream based PDF library  http://hackage.haskell.org/package/rakhana-0.2.0.0 (YorickLaupa)
15:24:19 <lf94> quick, shell shock in haskell
15:24:59 <monochrom> what is that even supposed to mean?
15:25:55 <Welkin> he is panicking
15:26:02 <Welkin> out of helplessness
15:26:07 <Welkin> that is shell shock
15:26:16 <Welkin> but I doubt he fought in WWI
15:27:33 <nshepperd> either that or he's written a rendition of depeche mode's _Shell Shock_ using Haskore
15:40:52 <lf94> yeah it was just a joke
15:40:59 * hackagebot Hungarian-Munkres 0.1.1 - A Linear Sum Assignment Problem (LSAP) solver  http://hackage.haskell.org/package/Hungarian-Munkres-0.1.1 (kaizhang)
15:45:59 * hackagebot Hungarian-Munkres 0.1.2 - A Linear Sum Assignment Problem (LSAP) solver  http://hackage.haskell.org/package/Hungarian-Munkres-0.1.2 (kaizhang)
15:48:28 <joelteon> maybe it's the bash bug
15:56:00 * hackagebot Hungarian-Munkres 0.1.3 - A Linear Sum Assignment Problem (LSAP) solver  http://hackage.haskell.org/package/Hungarian-Munkres-0.1.3 (kaizhang)
16:13:34 <athan> Why is it that we can make instances of a monad from type variables, like the reader monad in ((->) r), but not a monoid with (a -> Foo)?
16:15:28 <HeladoDeBrownie> athan, a -> Foo is fully applied, a concrete type *. Monad must be * -> *.
16:15:40 <Fuuzetsu> HeladoDeBrownie: he said Monoid
16:15:53 <HeladoDeBrownie> Fuuzetsu, that was a typo, probably. They also said "monad".
16:16:11 <HeladoDeBrownie> Oh.
16:16:21 <merijn> athan: "a -> Foo" is already a Monoid instance...
16:16:25 <Fuuzetsu> athan: Monoid b ⇒ (a → b) is already an instance
16:16:32 <merijn> athan: "instance Monoid b => Monoid (a -> b)"
16:16:35 <athan> merijn: Whiggiity whaaat!!
16:16:38 <HeladoDeBrownie> athan, was "monoid" a typo? I can't make sense of your question if it wasn't.
16:17:18 <athan> HeladoDeBrownie: No, I'm good though, thank you :)
16:17:33 <athan> merijn, Fuuzetsu: That just blew my mind
16:18:49 <athan> merjin: ^ also, did you learn this from personal memory of wanting it before, or did you know it beforehand, somehow? :)
16:19:57 <Fuuzetsu> I thought it was already and checked on Hackage to make sure the instance showed up there
16:21:14 <BMeph> athan: It's been in the (Data.)Monoid class, perhaps from its inception.
16:21:52 <BMeph> athan: Remember the contextual pre-condition, though.
16:22:08 <athan> Hmm, what if I have a monoid out of the functions (a -> Foo),but Foo is _not_ a Monoid?
16:22:19 <HeladoDeBrownie> Chances are, you don't
16:22:25 <athan> BMeph: Hmm, wow
16:22:43 <athan> HeladoDeBrownie: That's why I'm calling it "Foo", I think I found one :P
16:22:57 <HeladoDeBrownie> athan, show it to us, maybe we can summon up a Monoid instance. :)
16:23:27 * BMeph agrees
16:23:56 <HeladoDeBrownie> athan, you'd also have to describe what you want your a -> Foo Monoid to do, so we can also figure out the operation for our underlying instance.
16:24:23 <HeladoDeBrownie> Hmm, Haskell code doesn't parse well in natural sentences :P
16:26:10 <yyttr3> How do I convert a char to a word8?
16:26:41 * BMeph recommends a devout faith! ;þ
16:28:03 <HeladoDeBrownie> yyttr3, you get a lossy conversion at best. Is it possible for you to obtain a Word8 in the first place instead of a Char? What are you doing?
16:29:11 <yyttr3> I'm trying to work with Attoparsec and i'm finding it extremely difficult because of the strange types. The isEndOfLine function takes a word8 which I have a bytestring, but I really need a string anyways.
16:30:13 <HeladoDeBrownie> yyttr3, maybe someone here could help you work it out if you showed some code
16:30:15 <HeladoDeBrownie> yyttr3, but, if you really want to do it, fromIntegral . fromEnum
16:30:32 <glguy> Data.Attoparsec.Text.isEndOfLine :: Char -> Bool
16:31:49 <yyttr3> Ah, thank you. I'm using Data.Attoparsec.Char8.
16:33:08 <HeladoDeBrownie> yyttr3, did you read the docs? That module is deprecated and slated for removal
16:33:43 <EvanR> Text and all the supporting libs are awesome
16:34:01 <HeladoDeBrownie> Data.Attoparsec.ByteString.Char8, which it points to, is apparently okay though, with some caveats spelled out in the docs.
16:34:11 <HeladoDeBrownie> Basically it seems kind of hackish to me.
16:34:13 <yyttr3> I was using it because I can't get .Text to work. Maybe i'm not thinking very well but I can't get any types to match, ever.
16:34:36 <josephle> yyttr3: what do you mean you can't get Text to work?
16:35:11 <josephle> that sounds worrisome
16:35:18 <HeladoDeBrownie> The . was significant
16:35:20 <HeladoDeBrownie> Data.Attoparsec.Text
16:35:45 <josephle> ah, less worrisome, but still somewhat unfortunate
16:36:08 <HeladoDeBrownie> yyttr3, I think if you brought up the problems you're having in this channel, we could probably help
16:36:57 <yyttr3> I think I've might have got it
16:37:09 <athan> What's the specification of a monoid? Associativity of it's operator across all elements, and an identity that's commutative over the operator, right?
16:37:22 <hpc> yes
16:37:25 <josephle> sounds right
16:37:43 <hpc> the identity is also an identity
16:37:46 <hpc> over the operator
16:37:55 <hpc> or under, math b cray cray
16:38:09 <athan> you guys might poop when I publish this
16:38:16 <athan> hpc: Poifect
16:38:25 <yyttr3> https://gist.github.com/yyttr3/933febedd4101686aa83
16:38:39 <yyttr3> I just want to parse an import statement.
16:40:00 <josephle> yyttr3: does this code lead to any error messges?
16:40:03 <josephle> *messages
16:40:22 <josephle> just getting more info so it's easier to debug
16:53:41 <alyula> there ?
16:55:22 <lf94> How well does Haskell do X11
16:55:30 <solatis> if the choice of database is completely irrelevant, which database has the best/most elegant haskell API in the opinion of #haskell ?
16:56:30 <solatis> i'm looking at the CouchDB API right now, that looks pretty sweet
16:56:36 <simpson> lf94: Very well.
16:58:14 <lf94> simpson: any good references you know of?
16:58:38 <lf94> I'm doing this in C first to understand X11 a little better, but would *love* to port it to Haskell after
16:58:58 <simpson> lf94: Using XCB, of course, right?
16:59:53 <simpson> lf94: I believe that http://hackage.haskell.org/package/xhb is the correct package to use.
17:00:27 <lf94> simpson: well...I'm using the traditional xlib api X)
17:00:41 <lf94> Thanks!
17:01:04 <RyanGlScott> Is there an equivalent of parsec's 'try' in base? (i.e., in Text.ParserCombinators.ReadP)?
17:01:04 <simpson> lf94: Oh. Well, have some self-respect and use XCB. :3
17:01:17 <lf94> XCB is way different though x_x
17:01:48 <lf94> Eh I guess it'll only be a few lines of code that'll change
17:02:13 <lf94> I'm basically only using: XCreateSimpleWindow, XColor, XGetGeometry, XOpenDisplay
17:02:21 <lf94> oh and XDrawRectangle
17:05:00 <josephle> RyanGlScott: you can emulate 'try' by using ReadS, although I suspect that is kinda clunky
17:05:32 <Rag_> why doesn't zipWith (writeFile) ["test.txt"] ["this is a test"] create a file?
17:06:11 <RegEchse> why wouldn't it? o.o
17:06:29 <Rag_> i don't see a file :)
17:06:35 <Rag_> after running it
17:06:38 <Rag_> in ghci
17:06:53 <HeladoDeBrownie> Rag_, assuming we have writeFile :: String -> String -> IO (), the result of that is [IO ()], or a list of IO actions, which *could* be executed by the runtime system, but won't automatically.
17:07:07 <josephle> :t sequence
17:07:09 <lambdabot> Monad m => [m a] -> m [a]
17:07:20 <josephle> does that do what I think it does?
17:07:29 <pjdelport> josephle: Probably?
17:08:01 <Rag_> HeladoDeBrownie, that's exactly what's happening.. how do i force it to write?
17:08:16 <josephle> in the context of Rag_'s question, would sequence force the execution of the IO () actions in the list?
17:08:40 <pjdelport> Rag_: In other words, the zipWith only creates a pure list that contains IO actions: ghci won't executing anything unless the value itself is directyl an IO action.
17:08:40 <HeladoDeBrownie> josephle, no, but it would give you an IO action that when executed executes all those IO ().
17:08:49 <pjdelport> You can either sequence the list (which joins all the IO actions into one big IO action)
17:08:55 <HeladoDeBrownie> Rag_, well if you're writing a compiled program, main = sequence_ (zipWith writeFile ["test.txt"] ["this is a test"]) should do.
17:08:57 <pjdelport> or you can use zipWithM_, which essentially does the same thing.
17:09:03 <pjdelport> :t zipWithM_
17:09:05 <lambdabot> Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
17:09:09 <HeladoDeBrownie> Rag_, sequence_ is like sequence but the result is ignored, since you weren't going to need it anyway
17:09:12 <HeladoDeBrownie> @type sequence_
17:09:13 <lambdabot> Monad m => [m a] -> m ()
17:09:20 <HeladoDeBrownie> Just substitute m = IO for now
17:09:30 <pjdelport> :t zipWithM_ writeFile ["test.txt"] ["this is a test"]
17:09:31 <lambdabot> IO ()
17:09:58 <pjdelport> Rag_: The above constructs a single IO action that will do all the writeFile actions that you zip together.
17:10:25 <HeladoDeBrownie> Rag_, the important part is that execution and evaluation are separate things. You can evaluate that IO action but it only gets executed if the runtime system says so.
17:10:30 <HeladoDeBrownie> s/the/an/
17:10:50 <pjdelport> Unlike most other languages, IO actions are true first-class values.
17:10:51 <HeladoDeBrownie> And one way to tell the runtime system to run a particular IO action is to set main to it.
17:15:36 <Rag_> sequence_ (zipWith writeFile ["test.txt"] ["this is a test"]) worked. However the zipWithM_ didnot
17:15:55 <HeladoDeBrownie> zipWithM_ is just sequence_ . zipWith, isn't it?
17:16:28 <HeladoDeBrownie> Rag, the equivalent phrasing would've been: zipWithM_ writeFile ["test.txt"] ["this is a test"]
17:16:30 <josephle> the source says yes
17:17:00 <Rag_> :i zipWithM_
17:17:07 <HeladoDeBrownie> Rag_, keeping in mind that you need to import it from Control.Monad
17:17:10 <josephle> :info zipWithM_
17:17:22 <Rag_> i did do the Control.Monad
17:17:35 <HeladoDeBrownie> Okay, well try the phrasing I gave above
17:17:38 <Hijiri> what is the error message you are getting
17:17:47 <Hijiri> or no error message
17:17:52 <Rag_> no error message
17:18:02 <Rag_> just don't see the file created
17:18:08 <josephle> in the source, "zipWithM_ = sequence_ (zipWith f xs ys)"
17:18:15 <HeladoDeBrownie> Something else is going wrong then, I think.
17:18:38 <Hijiri> It worked for me
17:18:56 <HeladoDeBrownie> Same here
17:19:15 <HeladoDeBrownie> josephle, you're right, I misused (.) above
17:19:39 <pjdelport> zipWithM_ = sequence_ .: zipWith
17:19:44 <HeladoDeBrownie> I made the common mistake of thinking of functions as having multiple parameters :P
17:20:02 <pjdelport> Using (.:) from the composition package.
17:20:17 <solatis> it looks like all the haskelldb packages are quite unmaintained (latest release > 2 years ago, etc) -- is this a reason to worry, or does it just mean that the whole toolchain is very stable?
17:20:21 <sbrg> @hoogle (.:)
17:20:21 <lambdabot> No results found
17:20:38 <Rag_> it works now.. the problem was I was doing return $ ... as the last line in main
17:20:52 <josephle> I wonder if anyone has tried to use the composition package with aeson
17:21:01 <HeladoDeBrownie> Rag_, oh… yeah, it sounds like you misunderstand what return does
17:21:03 <josephle> I can only imagine the annoyance about (.:)
17:21:35 <HeladoDeBrownie> Rag_, return (x :: A) :: IO A. It's an IO action that results in x without doing anything else.
17:21:36 <Rag_> i know what return does in haskell, but old habits die hard
17:21:39 <HeladoDeBrownie> Ah.
17:22:09 <pjdelport> @hackage composition
17:22:09 <lambdabot> http://hackage.haskell.org/package/composition
17:22:14 <pjdelport> sbrg: -^
17:22:49 <josephle> Fortunately, it seems newer languages are eschewing explicit return statements
17:23:14 <HeladoDeBrownie> josephle, I'm not sure that's a good thing under all feature sets
17:23:39 <josephle> I am certain it isn't (for example, coffeescript...)
17:24:18 <HeladoDeBrownie> I was going to use Ruby as an example, but I think I can see what you're referring to
17:24:38 <simon> I was thinking Ruby, and I'm not sure I see why that's good.
17:24:50 <josephle> I think the contexts of Ruby and Coffeescript are not that different
17:24:57 <simon> right.
17:25:29 <josephle> on the other hand, it's not so bad in Swift and Rust
17:29:13 <arbn> josephle: Which new languages don't have explicit return?
17:30:08 <josephle> arbn: it's not that they don't have explicit returns, but more that they discourage them
17:30:19 <arbn> Oh. OK.
17:31:22 <josephle> as long as you're in an imperative context, "if(undesirable_predicate) { return error_value; }" will still exist
17:32:22 <silver> exception all the things!
17:34:38 <arbn> Well, you need 'return' whenever you have more than one value in scope, such that it is not obvious which one is the result of the computation.
17:36:58 <josephle> usually this is "solved" by making the last expression in the sequence be the return value
17:37:26 <josephle> if you want to make a language with implicit returns
17:37:28 <HeladoDeBrownie> You sometimes get undesirable return values then
17:37:59 <HeladoDeBrownie> Could expose internals or otherwise break your interface, unless you go to the hassle of including an explicit harmless return
17:38:15 <josephle> hence the "solved". I think a strong static type system like rust's can help with that problem.
17:38:48 <josephle> since not all expressions have the same type :)
17:39:47 <josephle> also a separation between the notion of expression and statement helps, preventing Ruby's case where "x=1" returns an int
17:41:37 <arbn> This reminds me of C's undefined behavior when one forgets a return statement. On most platforms it will return whatever is left in the return register, which is relavitely often the last value assigned in the function body. :P
17:41:49 <arbn> relatively*
17:41:56 <HeladoDeBrownie> That said, you could sort of say Haskell has a similar issue: You might write do { f ; g } but not actually want g's result, in which case you might write instead void $ do { f ; g } or the like
17:42:10 <HeladoDeBrownie> or else write out return ()
17:42:34 <HeladoDeBrownie> But in that case it's a lot more obvious when you look at the types involved what goes where
17:42:38 <trap_exit> how does haskell interact with randomized data structures
17:42:45 <trap_exit> there are variants of things like sorta-balanced threes
17:42:46 <trap_exit> trees
17:42:52 <trap_exit> where you're like "to insert, flip a coin, then do some ops"
17:43:03 <trap_exit> so they're sorta pure, but they require randomness
17:43:13 <Twey> :t randoms
17:43:14 <lambdabot> (Random a, RandomGen g) => g -> [a]
17:43:19 <HeladoDeBrownie> trap_exit, well, one way would be to be parameterized on a random source, which can be handed purely
17:44:15 <HeladoDeBrownie> So basically a RandomGen g => g will be somewhere in your type
17:44:51 <luite> trap_exit: splittable random generators are something you might be interested in. there was a paper on them last year, on which tf-random is based, i think
17:45:10 <trap_exit> lol, I just finshed reaidn ghte Haste.App paper
17:45:18 <trap_exit> everything in haskell is "read this research paper" :-)
17:45:27 <trap_exit> luite: ps, ghcjs.app would be really badass
17:45:46 <arbn> trap_exit: You could also read the three sentences on "split" in System.Random...
17:46:16 <arbn> Sorry. Two sentences.
17:46:29 <trap_exit> two bullet points
17:46:35 <trap_exit> one of them is one sentence, the other is 2 sentences
17:46:39 <trap_exit> http://hackage.haskell.org/package/random-1.0.0.3/docs/System-Random.html
17:47:21 <luite> trap_exit: yes i still need to clarify some requirements in the cloud haskell proposal. last week i replied there, but then i got caught up in fixing the let-no-escape optimization that took more time than i hoped
17:48:13 <arbn> I like writing programs more than I like reading papers.
17:48:16 <trap_exit> luite: moving questions over to #ghcjs
17:49:25 <trap_exit> arbn: you like writing more than reading? I have the perfect langauge for you, #perl :-)
17:50:39 <nshepperd> I guess you could carry a splittable random source together with the value
17:50:39 <arbn> trap_exit: :) Thankfully I was too young when I started programming to be enticed into Perl.
17:51:03 <luite> trap_exit: the type of split does describe the intent, but this is the reason i mentioned the paper http://hackage.haskell.org/package/random-1.0.0.3/docs/src/System-Random.html#line-375
17:51:46 <arbn> I love that comment.
17:52:15 <nshepperd> well, any random source really. the operation can return the new structure with updated random source included
17:52:49 <nshepperd> that way you can 'hide' the (pseudo-)randomness purely
18:06:28 <Fuuzetsu> that's some nice magic numbers in stdNext
18:06:46 <Fuuzetsu> at least it cites the paper up top
18:07:01 <hpc>     return (createStdGen (sec * 12345 + psec + ct + o))
18:07:18 <hpc> @remember ghc (sec * 12345)
18:07:19 <Fuuzetsu> I'm sure 12345 has a deep statistical meaning
18:07:19 <lambdabot> I will never forget.
18:07:41 <hpc> uhuh
18:07:43 <hpc> sure
18:08:16 <Fuuzetsu> I bet it is more likely to come up than most other 5 digit numbers when a human does the picking!
18:08:20 <hpc> my interpretation of that line is that there are 12345 picoseconds in a second
18:21:07 <brycelane_> is it possible to use a cabal sandbox to install a binary?
18:23:03 <Sonarpulse> instance (Arbitrary a, Arbitrary (Vec n a)) => Arbitrary (Vec (n + 1) a)
18:23:14 <Sonarpulse> gives me "illegal type synonym family application in instance"
18:23:18 <Sonarpulse> workarounds?
18:23:25 <Sonarpulse> Vec is from Clash (HDL)
18:23:39 <Sonarpulse> Nat is GHC.TypeLits
18:23:58 <eazar001> brycelane_: --prefix=/usr/local is one way to install a binary for example
18:25:02 <eazar001> brycelane_: http://www.haskell.org/cabal/users-guide/installing-packages.html
18:26:13 <brycelane_> eazzar001, thanks.
18:53:03 <Sonarpulse> is there a successor function to work with GHC.TypeLit ?
18:53:13 <Sonarpulse> that is what my problem boils down to
18:54:04 <bms1> Sonarpulse: Are you sure it's a problem with Nat, not Vec?
18:54:46 <Sonarpulse> yeah the problem is (1 + n) uses a type familly
18:54:51 <Sonarpulse> which i can't in a instance
18:54:58 <Sonarpulse> if I could do (Su n) the problem would go a way
18:55:07 <Sonarpulse> made a dummy class to confirm this
18:55:22 <bms1> Yeah that makes sense
18:56:18 <Sonarpulse> any idea for a solution?
18:57:00 <Fuuzetsu> can any darcs user tell me how to retrieve the ‘commit hash’ of current revision?
18:58:00 <bms1> Sonarpulse: I don't know what you can do (other than, of course, using your own Nat); that's a bummer, I just started using that Nat type for something too
18:58:24 <Sonarpulse> I think i just need to make my instances with my own nat and vec
18:58:37 <Sonarpulse> and then use my instances to make a (non-recursive) instance for the real deal
18:58:48 <Sonarpulse> pitty the clash hdl had to use that version of Nat
18:59:16 <bms1> Right, it stinks that you have to make your own Vec
19:00:56 <Sonarpulse> oh, maybe i can make a recursive helper function
19:00:58 <Sonarpulse> and then make that instance
19:01:01 <Sonarpulse> (duh)
19:12:10 <Enigmagic> Sonarpulse: ghc's solver isn't fully baked yet for typelits
19:12:54 <Sonarpulse> thanks
19:13:10 <Sonarpulse> hopefully just making a function works
19:13:24 <Enigmagic> Sonarpulse: so if you had an instance for 'Vec 0 a' and 'Vec (n + 1) a'... right now those would overlap
19:13:41 <Sonarpulse> yeah that makes sense
19:14:05 <Sonarpulse> type synnonyms / families probably introduce similar coherency problems
19:15:04 <Enigmagic> yeah, that's why e.g. type synonym instances are disabled by default
19:17:45 <brycelane_> when using tags to 'jump to source' how do you go back?
19:18:23 <mjrosenb> is there a way to get ghci to expand a type alias?
19:19:22 <Enigmagic> :kind! String
19:20:15 <Enigmagic> mjrosenb: assuming you're on 7.8, :kind! works.. i don't remember when it was added
19:20:28 <Enigmagic> might have been 7.6
19:20:36 <mjrosenb> Enigmagic: i was looking for something like :t
19:20:50 <mjrosenb> where I give it an expression, and it gives me the type, but with type aliases expanded.
19:21:17 <Enigmagic> once you have the type, you can use :kind! ..
19:23:07 <mjrosenb> Enigmagic: yeah, I was hoping to not have to copy + paste or retype
19:26:44 <jle`> you can just use :i too i think
19:28:32 <mjrosenb> <interactive>:1:1: parse error on input ‘2’
19:32:06 <Sonarpulse> Can I write a Function "forall n => a -> Vec n a"
19:32:14 <Sonarpulse> I'd need to structurally recur on n
19:32:16 <Sonarpulse> not a
19:32:25 <Sonarpulse> can I do that?
19:34:53 <Sonarpulse> mkay singleton patterns
19:37:29 <Sonarpulse> is it possible to get rid of the singleton arg?
19:37:33 <Sonarpulse> I am worried it is not
19:53:56 <Enigmagic> Sonarpulse: how about using vcopyI or viterateI?
19:54:08 <ddellacosta> this is kind of a meta-question but: where is a good place on IRC to ask questions about the lambda calculus?
19:54:21 <ddellacosta> I suspect there's folks here who could answer but don't want to be too offtopic
19:54:21 <Sonarpulse> well i realized just adding a KnownNat constraint would not cause an issue
19:54:58 * ddellacosta wonders if there is a #plt channel...
19:56:10 <ddellacosta> hrm, not one I can join at least. :-/
19:59:53 <geekosaur> ddellacosta, I don't think there's any ideal place for it. Personally I think it's fine to ask in here, but be ready to take it to -overflow or -offtopic if asked / the channel is busy.
20:00:16 <Sonarpulse> Enigmagic new problem
20:00:26 <ddellacosta> geekosaur: okay, thanks, I appreciate it.  Well, I'll throw it out there and see if I get any takers.
20:00:30 <geekosaur> Especially since ##math can sometimes be a rather daunting place to ask some questions
20:00:33 <Sonarpulse> I am trying to define Ord on vect
20:00:37 <Sonarpulse> and GHC cannot do
20:01:06 <ddellacosta> geekosaur: ah, seems like (anything called) ##math is too broad to know what to ask!
20:01:07 <geekosaur> (and, well, "math" is a rather large subject and lambda calculus and type theory may be seen as rather biche or out of topic by some there)
20:01:12 <Sonarpulse> (n ~ (n1 + 1)) -> (n ~ (n2 + 1)) -> n1 ~ n2
20:01:14 <ddellacosta> yeah, exactly
20:01:21 <arbn> ##logic might be worth a try, too.
20:01:26 <geekosaur> *niche
20:01:29 <ddellacosta> arbn: ah, didn't occur to me, thanks
20:04:52 <ddellacosta> so, I'm having trouble understanding substitution in lambda calculus, specifically the examples given here: https://gist.github.com/ddellacosta/ec53b5e56a4495855dae
20:05:16 <ddellacosta> this is from Lectures on the Curry-Howard Isomorphism by Sørensen and Urzyczyn
20:05:40 <ddellacosta> if anyone can help me grasp what's going on there, I'd be most appreciative
20:06:00 <geekosaur> also: I'm not very good at lambda caculus myself, and that sometimes (especially low usage times like this when few people may be around who can ghelp) it might work better to ask on haskell-cafe
20:06:05 <geekosaur> (mailing list0
20:06:40 <ddellacosta> geekosaur: yeah, that's a fair point, unfortunately I'm on the other side of the world from most folks active on #haskell...
20:07:17 <ddellacosta> maybe I'll try #logic too per arbn's suggestion
20:07:22 <geekosaur> yep, that's hen mailing lists become useful :)
20:07:41 <geekosaur> they're much better at the everyone's-out-of-sync thing
20:07:48 <ddellacosta> yeah
20:08:12 * arbn really wishes he had a script to do set operations on collections of members grouped by IRC channels joined.
20:09:01 <ddellacosta> arbn: ha, seriously
20:10:00 <oiuiui> ddellacosta: what are you having trouble with in the mentioned example?
20:10:18 <ddellacosta> oiuiui: I think the thing in particular that is confusing me is the distinction between the second two examples
20:10:33 <ddellacosta> oiuiui: in particular, how it is that y could be a member of FV(N)
20:11:05 <ddellacosta> oiuiui: I thought that its position means it is, inherently, not free.  But that just means I don't understand whatever notion of scoping (if that's appropriate) is applicable in the lambda calculus
20:11:54 <ddellacosta> oiuiui: oh, and maybe it's obvious but FV(N) is all free variables of N, according to what I'm reading
20:13:04 <oiuiui> ddellacosta: can't it be a poorly-chosen name?  for instance, it could mean that y does not appear in the body
20:13:36 <ddellacosta> oiuiui: sorry, I don't know what you mean. :-(
20:14:25 <oiuiui> I'm just guessing... For example, a function that throws away its argument: \_ -> x
20:14:31 <ddellacosta> oiuiui: I mean, I think the names are very deliberately chosen in these examples
20:15:13 <ddellacosta> oiuiui: and you can see that what happens to y is very much conditional on the set qualifiers given
20:15:31 <ddellacosta> oiuiui: it's just that I don't understand the logic of those set qualifiers at the end. :-/
20:15:43 <ddellacosta> or predicates, not sure what to call those
20:15:52 * ddellacosta needs to get better at math verbiage
20:17:13 <spopejoy> if I make a GADT with recursive types (like the classic Lit/Expr example), what is the preferred way to provide optics? I've rolled my own, but should I be looking at uniplate?
20:20:11 <athan> Is there a container optimized for constructive writes, lookups, but no deletes?
20:28:45 <ddellacosta> ah, for those who care, looks like that bit I was having trouble with has to do with ensuring "freshness:" http://en.wikipedia.org/wiki/Lambda_calculus#Capture-avoiding_substitutions
20:28:55 <arbn> ddellacosta: y *could* be a member of the free variables of N. N can be anything.
20:29:49 <ddellacosta> arbn: yeah, I think I was putting the emphasis on the wrong part of that, it's starting to come clear when I reframe it per the section from the wikipedia article above
20:31:47 <ddellacosta> arbn: but I realize also I'm applying all these rules that I have in my head about substitution and variables that come from a decade of programming, and the point of the lambda calculus is that its got very simple rules, and I need to avoid applying more rules than are actually stated!  Funny how many habits from programming sneak in...
20:32:03 <ddellacosta> *it's got
20:34:00 <Sonarpulse> what is the easiest way to make quickCheck print out things that aren't equal. I did this once by making an instance of (a,a) for some type class, but I don't remember that type class.
20:34:13 <arbn> ddellacosta: Yeah. Compilers and interpreters are pretty good at making sure we don't have to worry about renaming our bound variables to avoid conflicting with a substitution. :P
20:35:04 <ddellacosta> arbn: yeah, exactly, I forget how much I take that for granted!
20:36:28 <arbn> ddellacosta: With the LC, I encourage you to use pencil and paper a lot and pretend to be a machine dumbly applying transformations to the strings already on the page, according to the rules. With practice, the rules will make more sense.
20:36:47 <ddellacosta> arbn: that's a good idea, thanks for the suggestion.
20:37:02 * ddellacosta pulls out his paper notebook and pencil...
20:38:17 <Welkin> ddellacosta: just think in terms of math...
20:38:51 <Welkin> haskell makes me hate programming
20:38:58 <Welkin> it exposes how crappy most languages are
20:39:09 <Sonarpulse> oh well, i'll remember later
20:39:39 <Welkin> and how fragile the process of so-called software "engineering" is
20:41:10 <ddellacosta> Welkin: I have moments like that too, but it's a mixed bag isn't it?  Learning about this stuff also makes me excited for the potential of computation.  It inspires me to be a better programmer and keep trying to apply these highly abstract concepts when I'm doing my day-to-day software engineering kind of development.  For me that's a net win.
20:41:12 <lf94> Welkin: yee
20:41:21 * hackagebot dash-haskell 1.0.0.0 - Command line tool to generate Dash docsets (IDE docs) from package haddock  http://hackage.haskell.org/package/dash-haskell-1.0.0.0 (jfeltz)
20:42:30 <ddellacosta> Welkin: and I should add, learning about Haskell, and more fundamentally--PLT theory, helps me see the connections between things I didn't see before.
20:42:34 <Welkin> imperative programming and the turing machine have held back computing for decades
20:43:15 <Welkin> especially the fact that the cpu is a slave to the clock
20:44:37 * ddellacosta waits for further exegesis from Welkin
20:49:34 <Cale> I'm interested to see how things will play out with memristor-based computation. It seems like functional evaluators might be better suited to run on such devices where memory and computation happen in the same place.
21:03:20 <ddellacosta> argh, now this makes no sense to me: "If x, y, z are distinct variables, then for a certain variable u: ((λx.x yz) (λy.x y z) (λz.x y z))[x := y] = (λx.x yz) (λu.y u z) (λz.y y z)"
21:03:29 <ddellacosta> where the heck is that "u" coming from?
21:03:39 <ddellacosta> is this a mistake?
21:05:41 <dmj`> > (,) <$> getLine <*> getLine
21:05:43 <lambdabot>  <IO ([Char],[Char])>
21:11:19 <arbn> ddellacosta: He's saying that such a "u" exists, so as to satisfy that identity.
21:11:42 <ddellacosta> arbn: ah okay, thanks!
21:13:37 <ddellacosta> arbn: I guess what I'm still stumbling over, though, is how you would go from the left side to the right, in the context of that substitution especially
21:15:38 <ddellacosta> oh, I guess because you want to be able to get z in the end on the rightmost term?  So you need to do substitutions without violating freshness, basically?  Hrmm...
21:16:50 <arbn> ddellacosta: What page? I have the book up now. :P
21:16:52 <ddellacosta> er, no, rather, it allows you to substitute y for x per the substitution without violating freshness.  Sorry #haskell, talking to myself at this point...
21:17:04 <ddellacosta> arbn: um, 16 according to my file
21:17:28 <ddellacosta> arbn: I mean, what you said is making sense, it has to be that
21:17:57 <ddellacosta> arbn: that follows the first example I pasted actually, where if y is a member of FV(N) a z variable is introduced
21:20:12 <arbn> ddellacosta: OK. So... I *think* he's saying that you have to rename the y in that middle expression to... *something* else.
21:21:21 <ddellacosta> arbn: yeah, I'm pretty sure your initial response was right--a "u" term is introduced to satisfy the requirement stated in the previous definition (1.1.13) with regards to y being a member of FV(N)
21:21:32 <arbn> ddellacosta: Yeah.
21:21:37 <ddellacosta> arbn: incidentally, thanks for your help, I really appreciate it!
21:22:12 <ddellacosta> it's so much easier to have someone who can confirm whether or not one's understanding is totally wrong when trying to learn this stuff...
21:24:36 <dfeuer_> Hello, Haskellians.
21:27:08 <Fuuzetsu> no Haskellians here
21:27:34 <arbn> Fuuzetsu: Hey.
21:29:17 <ddellacosta> may be some Haskellites around though
21:30:04 <Fuuzetsu> arbn: hello?
21:31:29 <arbn> Fuuzetsu: Yes?
21:34:40 <Fuuzetsu> nevermind
21:36:50 <ddellacosta> another question for arbn or whoever: I see the forward slash (/) used here and there, but it's not clear to me what that notation means.  For example: Λ = Λ−/=α = {[M]α|M∈Λ−}
21:37:54 <Fuuzetsu> what's the context?
21:38:22 <arbn> Fuuzetsu: ftp://ftp.cs.cmu.edu/user/ftp/usr/rwh/www/home/courses/logic/www-old/handouts/curry-howard.pdf
21:38:29 <ddellacosta> hmm, similarly, backslash: FV(λx.P) = FV(P)\{x};
21:38:47 <ddellacosta> sorry Fuuzetsu, I've been going on about ^ for the last half hour...
21:38:52 <Fuuzetsu> I didn't read up
21:39:03 <Fuuzetsu> that link doesn't work
21:39:16 <Fuuzetsu> the \ there is set difference probably
21:39:21 <ddellacosta> Fuuzetsu: which is basically that I'm trying to educate myself on the basic un-typed (for now) lambda calculus
21:39:24 <ddellacosta> Fuuzetsu: ah, okay, thanks
21:39:39 <Fuuzetsu> ddellacosta: it can't be anything else than set difference really, read what it says
21:39:56 <Fuuzetsu> x is being bound so it can't be in FV(P)
21:40:50 <ddellacosta> Fuuzetsu: is that the same as saying that the result of that is anything in FV(P) other than "x" ?
21:41:09 <ddellacosta> yeah, now I'm recalling seeing that \ for set difference at some point...
21:41:13 <Fuuzetsu> all that says is that the set of free variables in λx.P is precisely the set of free variables in P except without x
21:41:22 <ddellacosta> Fuuzetsu: okay, got it, thanks
21:41:59 <ddellacosta> Fuuzetsu: so does the first example make any sense to you?  Λ = Λ−/=α = {[M]α|M∈Λ−}
21:42:16 <Fuuzetsu> no, it does not
21:42:37 <Fuuzetsu> but I can't reach the pdf you linked
21:43:21 <ddellacosta> specifically that forward slash... "=α" is alpha equivalence
21:43:24 <ddellacosta> how about this one? http://www.gbv.de/dms/goettingen/512021694.pdf
21:43:36 <Fuuzetsu> that works
21:43:51 <Fuuzetsu> …but is just an index ;P
21:43:55 <ddellacosta> d'oh
21:43:58 <Fuuzetsu> however!
21:44:02 <Fuuzetsu> I have that very book on my shelf
21:44:05 <Fuuzetsu> ;P
21:44:09 <ddellacosta> oh, haha
21:44:35 <Fuuzetsu> what page
21:44:46 <ddellacosta> Fuuzetsu: yeah, I'm working through the first section, it's just establishing basics on the lambda calculus
21:44:53 <Fuuzetsu> ok
21:44:53 <ddellacosta> Fuuzetsu: book version page, um...5
21:45:04 <ddellacosta> 4-5
21:45:11 <ddellacosta> the first example is pg.4, sorry
21:45:50 <ddellacosta> Fuuzetsu: and the main thing I was confused by was that forward slash in "Λ−/=α", the rest of that term makes rough sense
21:46:26 * hackagebot text-show 0.2.0.0 - Efficient conversion of values into Text  http://hackage.haskell.org/package/text-show-0.2.0.0 (ryanglscott)
21:46:49 <dfeuer> Why do people seem to still try, at least half-heartedly, to make packages work with Hugs?
21:48:59 <Fuuzetsu> there is no forward slash in the book ddellacosta
21:49:18 <Fuuzetsu> sets of Λ terms don't come up until page 7
21:49:25 <Fuuzetsu> which definition number?
21:49:27 <ddellacosta> Fuuzetsu: ( p_q)
21:49:36 <ddellacosta> Fuuzetsu: ah, okay, one sec
21:49:45 * Fuuzetsu suspects that was meant to actually be ≠α
21:50:03 <ddellacosta> Fuuzetsu: definition 1.1.17.  Sorry, should have given the def # right off the bat
21:50:10 <ddellacosta> ah, that would make sense...
21:50:19 <ddellacosta> well, no, not sure it would
21:50:32 <ddellacosta> which is to say, I'm confused
21:50:35 <Fuuzetsu> I must be looking at different material ;P
21:50:45 <Fuuzetsu> 1.1 has no definitions for me
21:50:54 <ddellacosta> Fuuzetsu: d'oh
21:51:16 <Fuuzetsu> I have 2006 edition (first)
21:51:34 <ddellacosta> huh
21:51:40 <ddellacosta> not sure what this one is
21:52:02 <Fuuzetsu> the only thing that looks familiar to your question is Λ = {[M}α | ∈ Λ⁻}
21:52:19 <Fuuzetsu> where [Ma]α = { N ∈ Λ⁻ | M =α N}
21:52:27 <ddellacosta> Fuuzetsu: maybe this will simplify things: http://expirebox.com/download/6addd4566bc8e75f88a0434e09e7b44a.html
21:52:46 <zcd> @pl \xs n -> take n xs
21:52:46 <lambdabot> flip take
21:53:03 <zcd> @pl \x -> joinPath ["foo", x]
21:53:03 <lambdabot> joinPath . ("foo" :) . return
21:53:22 <Fuuzetsu> ddellacosta: uh, my pdf reader hates it
21:53:33 <Fuuzetsu> does expirebox mess with it or something
21:53:35 <ddellacosta> Fuuzetsu: hahaha, this is hilarious
21:53:50 <Fuuzetsu> error: cannot recognize version marker; warning: trying to repair broken xref; error: No pages in document; mupdf: error: cannot open document
21:54:03 <Fuuzetsu> take a screenshot of the page ;P
21:54:58 <ddellacosta> Fuuzetsu: you are a lovely patient person: http://imgur.com/7nRorBW
21:55:53 <ddellacosta> Fuuzetsu: incidentally, re-reading your previous comments, seems like we must have been looking at the same section, just formatted differently...?
21:56:03 <Fuuzetsu> oh
21:56:09 <Fuuzetsu> I think they use it to denote quotient
21:56:37 <arbn> dfeuer: They do?
21:56:48 <Fuuzetsu> Λ is the quotient set of =α, written Λ⁻/=α
21:56:57 <ddellacosta> Fuuzetsu: ah, like, quotient set as described in the beginning here? http://en.wikipedia.org/wiki/Equivalence_class
21:57:07 <ddellacosta> Fuuzetsu: ah okay, thanks
21:57:18 <dfeuer> arbn, yes, or so it seems. Cabal has some Hugs-specific code, for example.
21:57:42 <ddellacosta> Fuuzetsu: sorry for all that hullabaloo just to answer that simple question. Much appreciated.
21:57:49 <Fuuzetsu> ddellacosta: it is the same notation as used for quotient categories or slice categories
21:58:02 <ddellacosta> Fuuzetsu: sorry, I don't know of those yet. :-(
21:58:14 <Fuuzetsu> well, it's just foo/bar
21:58:15 * ddellacosta files away quotient categories and slice categories for later study
21:59:18 <dfeuer> arbn, there's even some stuff in https://github.com/haskell/cabal/wiki/Source-Guide about Hugs support, but I'm kind of guessing it may be old....
21:59:20 <Fuuzetsu> (notably it's (Λ⁻) / (=α), not …/=…
21:59:24 <Fuuzetsu> )
21:59:48 <arbn> dfeuer: Huh. I know of one person who still uses Hugs, but he's an academic who writes code free of side-effects and just runs it from the interpreter.
22:00:10 <dfeuer> arbn, and why does he use Hugs for that?
22:00:28 <Fuuzetsu> the moment Hugs disappeared from the haskell.org host recently, there were questions
22:00:36 <Fuuzetsu> so there are at least 2 people on the mailing lists using it
22:00:37 <arbn> dfeuer: I don't know. Old habits?
22:01:37 <Fuuzetsu> :t init
22:01:38 <lambdabot> [a] -> [a]
22:01:45 <Fuuzetsu> …this isn't GHCi
22:02:09 <Hafydd> These aren't my lenses.
22:02:26 <Fuuzetsu> no lens in this library ;)
22:10:03 <akagr> Good morning #haskell
22:10:23 <AshyIsMe> im using Control.Monad.forever to do a main loop, is there a way to add in a delay of X seconds between each invocation?
22:10:29 <arbn> akagr: Good morning.
22:11:16 <dfeuer> Just how dead is nhc98?
22:11:44 <Hafydd> AshyIsMe: yes; insert a Control.Concurrent.threadDelay into the action.
22:12:20 <AshyIsMe> ah cheers Hafydd
22:32:13 <dramforever> Is anyone thinking about translating haskell? For example ghc error messages in French, German or *** Exception: Prelude.head: empty list
22:32:33 <dramforever> in Chinese
22:33:16 <dramforever> Maybe the former is easier than the latter
22:35:46 <jle`> hm
22:36:01 <jle`> that particular error message is not on ghc, but from the source of the head function
22:36:16 <Hafydd> ["French", "German"*** Exception: Prelude.head: empty list
22:36:26 <dramforever> nope not that
22:36:42 <dramforever> I mean: 1. ghc error messages in other languages
22:36:44 <jle`> but it might be meaningful to look for i18n options
22:36:50 <jle`> ah
22:36:59 <dramforever> 2. packages in other languages
22:37:30 <dramforever> Haskell Char supports unicode ok-ly, and text is great
22:37:50 <dramforever> yet most things in haskell is English-oriented
22:38:29 <dramforever> The latter is more difficult because we can't possibly have a show that depends on the locale
22:39:21 <dramforever> jle`: maybe you misunderstood me, but I'm talking about i18n, not complaining about the error
22:40:41 <dramforever> Maybe error is the problem. Haskellers are supposed to use throw, since throw is eaiser to catch
22:41:58 <dramforever> I think each package could have a formatErrorMessage :: SomeI18NConfig -> SomeFooBarException -> IO String
22:42:58 <dramforever> where SomeI18NConfig doesn't have to be the same everywhere, but should be easily created according to the current environment
23:05:58 <carter> hehe
23:06:16 <carter> that made me giggel :)
23:11:21 * Vince_swFlorida Is a newbie to Haskell.  Discovered a couple of days ago as an online course listing of Stanford U.  Just beginning to read the book that is online:  Real World Haskellby Bryan O'Sullivan, Don Stewart, and John Goerzen
23:13:29 <pjdelport> Vince_swFlorida: Welcome to Haskell. :)
23:13:32 * Vince_swFlorida Want to know if it will help me to program a Darwin_OP with a hierarchy of integrated AI functions. 
23:13:36 <Vince_swFlorida> Thanks!
23:14:29 <pjdelport> It might.
23:15:18 <pjdelport> What kind of software platform is the Darwin-OP?
23:15:49 <pjdelport> The specifications seem enough to comfortably run Haskell.
23:17:58 * Vince_swFlorida Just for instance, the functions of perceptual and conceptual unitization will be where I start.  With just 1364 functions more to go, not counting actual robotic automation.
23:20:38 * Vince_swFlorida a considerable endeavor that could use more expert help, (I'm a psych. by trade).  But only after I relocate to Melbourne, Aus.
23:21:52 * Vince_swFlorida Anyone here located in Melbourne?
23:23:19 <shachaf> Vince_swFlorida: You don't need to use /me for every message like that. It looks very strange.
23:24:00 <Vince_swFlorida> Pardon me... an old habit ... won't happen again.
23:25:05 * Arahael doesn't think that using '/me' for every message is very strange, but does think that Vince_swFlorida may have a personality identity disorder.
23:26:39 <Vince_swFlorida> Although it won't completely eliminate my innate strangeness, I have to work on that in other ways.... I've been too reclusive for too long, my apologies.
23:28:49 <Arahael> Vince_swFlorida: I was just teasing.
23:29:52 <Vince_swFlorida> Jeese I hope that's not true, No character or personality identity and I'm up the proverbial creek without paddle.
23:31:38 <Arahael> Vince_swFlorida: Anyway.  I hear melb has good coffee.
23:31:49 <Arahael> Should be fun.
23:32:22 <Vince_swFlorida> Let's see it's 4 pm in Aussie land ... so they're all leaving work and going home for supper around this time ... not the best time to call for Aussie assistance.
23:33:21 <vanila> good morning haskell :)
23:33:27 <Vince_swFlorida> Hmmm having fun with Melb coffee... I'd prefer to drink it myself ... just saying.
23:34:16 <Vince_swFlorida> Good evening here in Fl.... but good morning to you vanila.
23:34:48 <Arahael> Vince_swFlorida: Worse. It's saturday.
23:35:09 <Vince_swFlorida> What's so bad about Saturday?
23:35:42 <Arahael> Vince_swFlorida: Australians work monday to friday.
23:35:42 <Vince_swFlorida> Ohhhhhhhhhhhhhhhhhhh
23:36:32 * Vince_swFlorida hits himself on the forehead ... "I coulda had a Monday to Friday!"
23:37:21 <Vince_swFlorida> Yeah ... that is sad!
23:38:58 <Vince_swFlorida> Oh well, as is obvious from that, my arrival here was impulsive and unpremeditated.
23:40:38 <nshepperd> I'm in melbourne, but I don't know anything about anything
23:41:08 <nshepperd> so all I can say is good luck!
23:41:23 <Vince_swFlorida> I'm thinking it best to return another more opportune time when I know something about Haskell the pm.
23:42:08 <Vince_swFlorida> and thanks for the encouragement ... maybe you'll know something about something when I return.
23:42:11 <nshepperd> oh except that Real World Haskell is apparently out of date on some stuff
23:42:54 <nshepperd> the APIs for some libraries like SQL has changed a bit since the book was published
23:43:02 <Vince_swFlorida> Ohhh don't tell me that ... I need to hear the good things only as I begin the long trudge up the learning curve.
23:43:42 <nshepperd> the good news is that haskell is great!
23:43:50 <Vince_swFlorida> Hmmm you're beginning to know too much about what's not good for me to hear.
23:44:21 <Vince_swFlorida> Ooooooooooooooooooh now that's the spirit ... Yay for haskell the great!
23:45:37 <Vince_swFlorida> For one who claims to know less than the minimum... How do you know it's so great?
23:48:26 <Vince_swFlorida> Do you know whether haskell handles signal and image processing well?
23:50:11 <vanila> Vince_swFlorida, it's not something ive done and i think it would require care but im sure it's doable
23:50:35 <Vince_swFlorida> That's good to know, vanila,  thanks.
23:51:18 <Vince_swFlorida> What have you done with haskell, vanila?
23:51:50 <Vince_swFlorida> If you don't mind answering in mixed company, I'd like to know.
23:51:51 <vanila> mostly write interpreters for programming languages
23:52:22 <Vince_swFlorida> Oh, you're a linguistic chic.
23:52:27 <vanila> hehe
23:54:22 <Vince_swFlorida> One of the functions I am interested in capturing has to do with universal linguistics.  i.e., generative, interpretive and expressive grammar.
23:58:20 <Vince_swFlorida> That's gonna take laying down semantic and syntax tracks.
23:59:54 <Vince_swFlorida> Do you find haskell well suited to produce coherent subjects and predicates?
