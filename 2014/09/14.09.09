00:08:50 * hackagebot bindings-portaudio 0 - Low-level bindings to portaudio library  http://hackage.haskell.org/package/bindings-portaudio-0 (FumiakiKinoshita)
00:08:50 * hackagebot artery 0.1.1 - A simple, arrow-based reactive programming  http://hackage.haskell.org/package/artery-0.1.1 (FumiakiKinoshita)
00:13:45 * hackagebot lens 4.4.0.2 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.4.0.2 (EricMertens)
00:15:27 <merijn> If I create a Chan and never read from it, only dupChan it, will I leak space?
00:21:15 <glguy> Merijn from the looks of the code it creates a linked list of mvars. So if you never read of the Chan but don't allow it to garbage collect the head elements it would have to leak
00:22:42 <merijn> glguy: That's what I figured
00:22:57 <glguy> But dup only uses the write side so if you can replace the read side somehow
00:23:01 <merijn> TChan has a broadcast chan option
00:23:05 <glguy> You'll have fixed your leak
00:24:11 <merijn> Yes, but TChan is slower than Chan
00:24:28 <merijn> I wonder why no one ever implemented newBroadcastChan
00:24:45 <pharaun> >_< that was tough
00:24:59 <pharaun> i think i kinda get free monad, gadt, and couple other concept
00:26:53 <pharaun> some days its good some days my head is looking more like a piece of melt goo
00:28:14 <krgn> has anybody here use the api-tools package?
00:33:13 <merijn> glguy: Clearly the better options is to complain on libraries@ and just patch base to have a newBroadcastChan added :)
00:33:51 <glguy> Yeah, my phone just told me about your email. :)
00:36:55 <glguy> It'd be slick, and brittle, if the GC could tell that if you only had a value : dupChan thechan
00:37:12 <glguy> But no other direct access to thechan
00:37:49 <glguy> If the GC could tell the read side was unreachable and collect it :)
00:38:00 <merijn> glguy: I think the GC can potentially already do this
00:38:15 <merijn> glguy: But "can potentially" is not what I want to rely upon to avoid a massive space leak
00:39:01 <glguy> Sure, I just find myself wondering if it can
00:39:41 <merijn> I think it can already if it inlines a bunch of stuff
00:43:48 * hackagebot mono-traversable 0.6.2 - Type classes for mapping, folding, and traversing monomorphic containers  http://hackage.haskell.org/package/mono-traversable-0.6.2 (MichaelSnoyman)
00:45:18 <agatam> I want to have a (static) webpage on a thingy with no haskell (yes, my uni servers suck) and I want to use haskell to build that webpage. is hakyll the way to go?
00:45:29 <merijn> Yeah
00:46:03 <sshine> agatam, yes.
01:06:46 <beckyconning> what does >> mean? i know what >>= means but not >>
01:08:14 <mr-> @src (>>)
01:08:14 <lambdabot> m >> k = m >>= \_ -> k
01:08:19 <mr-> Maybe that's enough, then :-)
01:08:52 * hackagebot graph-rewriting-strategies 0.2.2 - Evaluation strategies for port-graph rewriting systems  http://hackage.haskell.org/package/graph-rewriting-strategies-0.2.2 (JanRochel)
01:08:54 <dv-> @undo do { a; b }
01:08:54 <lambdabot> a >> b
01:09:46 <sgronblo> beckyconning: it binds two monadic computations but ignores the "return value" of the first computation
01:10:06 <sgronblo> maybe some smarter person can clean up my word usage
01:11:01 <beckyconning> cool thanks : )
01:14:37 <sgronblo> im trying to call things that are monads computations now, instead of containers. lets see how far i can get until somebody corrects me.
01:14:56 <joelteon> Maybe isn't a computation
01:15:13 <joelteon> it's a type constructor
01:16:48 <shachaf> As long as you're being careful about vocabulary: Maybe and IO are monads. "Maybe Int" and "Just 5" and "getLine" aren't.
01:17:02 <shachaf> You might be best off with the word "action" for things like "Just 5" and "Nothing" and "getLine".
01:18:43 <beckyconning> wait for left to "complete" then do an "unrelated" right.
01:18:44 <beckyconning> ?
01:19:40 <jle`> every monad has its own unique semantics and purpose somewhat independent of its monadness...why say things like 'monads are containers' or 'monads are computations'?  what's the point?  you won't find a single word to describe all of the many different instances...and even if you do, one could probably contrive an instance.  monad is nothing more than monad.
01:20:44 <jle`> perhaps it is more useful to say "(x) is a class of problems and situations that are aided with a monadic interface."
01:20:45 <Iceland_jack> jle`: You should ask Moggi,
01:21:04 <jle`> it doesn't imply that "all monads are X", or that "monads are X"
01:21:10 <Iceland_jack> "Notions of computations and monads"
01:21:32 <jle`> ;_;
01:22:04 <beckyconning> waitTill 1500 >> putStrLn "Its 15:00"
01:22:14 <superlinux-hp> hi all
01:22:25 <Gonzih> hello
01:22:50 <jle`> hi superlinux-hp and Gonzih
01:22:50 <superlinux-hp> I use debian gnu/linux . and I have a problem in compiling the latest cabal.
01:22:59 <superlinux-hp> hi jle`
01:23:48 <Iceland_jack> Verbatim from the paper: “[…] we distinguish the object A […] from the object TA of computations” ...  “We call T a /notion of computation/, since it abstracts away from the type of values computations may produce. There are many choices for TA corresponding to different notions of computations.”
01:24:01 <superlinux-hp> what i understood is that I have compile Cabal library to be able to get the latest cabal-install. correct?
01:24:14 <sgronblo> Doesn't Maybe's Monad instance imply a computation that can fail at producing a result?
01:24:39 <MP2E> sgronblo: but that's not what a Monad is, that's an instance of a Monad
01:24:46 <jle`> sgronblo: you can make an argument that it does for Maybe...but that wouldn't have anything to do with Monad in general
01:24:50 <jle`> it would have to do with Maybe's Monad instance
01:25:10 <sgronblo> Well I was just getting used to the "computation" idea describing Monads quite well
01:25:16 <jle`> "doesn't [Int] imply a list of Ints?  so isn't [a] just a list of ints?"
01:25:30 <Iceland_jack> sgronblo: (if you're interested: http://www.disi.unige.it/person/MoggiE/ftp/ic91.pdf)
01:25:40 <jle`> i mean, [Int] is a list of Ints, but that's because of the Int part, not because of the [] part
01:25:54 <sgronblo> No. List's Monad implies a computation that can return multiple values?
01:25:57 <Iceland_jack> You'll find Maybe under Example 1.1, partiality
01:26:10 <superlinux-hp> I have this when I build and install Cabal library: Setup: Error: Could not find module: Distribution.Compat.CreatePipe with any
01:26:10 <superlinux-hp> suffix: ["hi"] in the search path: ["dist/build"]
01:26:36 <superlinux-hp> what should I do in this case? this is version 1.20.x of cabal
01:26:54 <jle`> sgronblo: i meant that in the sense of, "when i look at an [Int], i see that it is a list of Ints.  therefore, i can assume that [Double] is also a list of Ints."  nothing to do with monads, per se.
01:27:40 <jle`> i can look at Maybe as representing a computation.  from that, can I say that Monads represent computations...?
01:28:07 <jle`> a square is a shape with four sides.  therefore...do all shapes have four sides?
01:28:25 <jle`> looking at a square and knowing that it is a shape, you might jump to the conclusion that shapes are four-sided things
01:28:53 <jle`> looking at Maybe and knowing that it is a Monad, you might jump to the conclusion that Monads are computations
01:28:55 * hackagebot fpco-api 1.1.1.3 - Simple interface to the FP Complete IDE API.  http://hackage.haskell.org/package/fpco-api-1.1.1.3 (MichaelSnoyman)
01:29:32 <a3f> I can't find a function with the signature `Maybe String -> IO CString`. What would be the proper way to pass an optional C argument to a foreign C function?
01:29:32 <jle`> but we all know that being-a-shape-or-not has nothing to do with having four sides
01:29:42 <a3f> Where optional means == NULL
01:30:15 <a3f> s/C argument/String Argument
01:30:36 <shachaf> nullPtr?
01:30:55 <sgronblo> jle`: yes i understand what you are trying to say
01:32:31 <a3f> shachaf: So nothing readily available? It's quite common in the WinApi for example and I was wondering if there is a function for that already
01:33:00 <shachaf> a3f: What?
01:33:13 <superlinux-hp> can someone here help me install haskell?
01:33:42 <bernalex> superlinux-hp: likely.
01:33:44 <shachaf> Oh, you want to write foo (yourFunction (Just "x")) or foo (yourFunction Nothing)?
01:33:46 <sgronblo> So is there some monad where the computation "description model" breaks down?
01:34:06 <superlinux-hp> bernalex, have you read my question earlier?
01:34:25 <shachaf> "computation" isn't a model, it's a word.
01:34:43 <superlinux-hp> bernalex, cabal is not compiling with me.
01:35:07 <shachaf> It's meant to appeal to intuition, as far as I can tell. Not everyone has the same intuition for the same word.
01:35:15 <bernalex> superlinux-hp: no. what was the problem, and what system do you use
01:35:21 <a3f> shachaf: Exactly
01:35:42 <superlinux-hp> bernalex, debian gnu/linux . the mother debian. not ubuntu.
01:35:44 <shachaf> a3f: No such thing as far as I know.
01:35:54 <bernalex> shachaf: why would anyone say debian and mean ubuntu lol
01:35:58 <bernalex> sorry superlinux-hp ^
01:35:58 <shachaf> a3f: But keep in mind that String and CString probably don't match anyway, at least where the Windows API is concerned?
01:36:01 <bernalex> superlinux-hp: what's the problem?
01:36:17 <shachaf> I think Windows uses UTF-16.
01:36:23 <bernalex> schlumpi: it does
01:36:26 <bernalex> omg
01:36:26 <a3f> shachaf: Ye it's CWString for WinApi. But I just ask generally
01:36:36 <bernalex> I'll just stop autocompleting things now
01:36:36 <superlinux-hp> this is what i have when I build cabal library so then I can build later  cabal-install : Setup: Error: Could not find module: Distribution.Compat.CreatePipe with any
01:36:36 <superlinux-hp> suffix: ["hi"] in the search path: ["dist/build"]
01:36:47 <bernalex> superlinux-hp: did you try https://github.com/bitemyapp/learnhaskell ?
01:37:09 <superlinux-hp> bernalex, I am using this article exactly.
01:37:10 <shachaf> a3f: Given that the function has to encode too, it seems kind of specialized.
01:37:36 <superlinux-hp> I mean I am using https://github.com/bitemyapp/learnhaskell itself.
01:38:12 <bernalex> superlinux-hp: I see. not a debian guy though, sorry. stick around and maybe someone will appear out of the blue and help you. that happens.
01:38:23 <superlinux-hp> ok.
01:38:39 <shachaf> a3f: But I don't know about Windows. Maybe look at what existing win32 bindings do...
01:39:02 <a3f> shachaf: That what I am asking for. The existing win32 Bindings are broken in that regard
01:39:09 <a3f> They don't handle optional arguments at all
01:39:24 <sgronblo> shachaf: i didnt say computation was a model. maybe my wording was a bit poor. "Is there a monad where the idea/notion of monads as computations breaks down?"
01:39:26 <shachaf> Ah. In that case I don't know.
01:39:34 <sgronblo> Iceland_jack: that paper is too hard core for me
01:39:53 <a3f> I want to fix that and wanted to ask first if there is some way so I don't spend too much time doing something wrong :)
01:40:30 <shachaf> I think there aren't that many people in here who use Haskell with the Windows API in particular. Best to ask one of them if you can, though.
01:40:38 <shachaf> sgronblo: I don't know, because that idea in my head is surely different from that idea in your head.
01:40:50 <Iceland_jack> sgronblo: You may benefit from Wadler's paper then: http://ncatlab.org/nlab/files/WadlerMonads.pdf it's not necessary but it's quite nice
01:41:15 <a3f> making a withOptCString or something and using that instead of withCString and changing all the optional arguments to use Maybe would the right way to go then, or?
01:42:02 <ph88> hi guys
01:42:05 <shachaf> In general that sounds like a reasonable approach. But I don't know the specifics of that API and how awkward it would be.
01:42:53 <a3f> And one last thing are the .hsc files for the WinApi aren't automatically generated from headers, right?
01:45:13 <sgronblo> Iceland_jack: i didnt know this paper was so long
01:45:49 <ph88> i'm trying to print 10 times random true or false. But i get an error  https://www.fpcomplete.com/project/61211/rP2StYcWKW
01:48:00 <MP2E> ph88: what's the error? it works for me
01:48:01 <Gonzih> ph88: not type defenition
01:48:10 <Gonzih> ph88: add something like :: [Int]
01:48:25 <ph88> MP2E: errors in messages tab at bottom at the link i included
01:48:39 <ph88> Gonzih: add to where ?
01:48:57 <ph88> is    :: Int     a type cast ?
01:49:08 <Gonzih> ph88: https://www.filepicker.io/api/file/8qh60EmFT0Km3ce5cVnb
01:49:26 <Hafydd> No, it's a type annotation that fixes the type of an expression.
01:49:59 <Gonzih> ph88: haskell has no idea what type random generator should return, you need to help it a little bit
01:50:10 <hyPiRion> I always think of it as help to the compiler
01:50:18 <Hafydd> The compiler uses Hindley-Milner type inference to infer types for all of your variables, but sometimes it cannot unambiguously decide on them.
01:50:30 <ph88> i figured if i put 0 and 1 type interference would figure out it's an int
01:50:30 <Gonzih> ph88: it would be able to figure that out out of content, but print is generic, so there is no solid type information in context
01:50:47 <Hafydd> :t 0
01:50:48 <lambdabot> Num a => a
01:51:03 <Hafydd> 0 could also be of type Double, for example.
01:51:17 <Hafydd> Or Integer, more sensibly for this.
01:51:18 <Gonzih> :t RandomRS
01:51:19 <lambdabot> Not in scope: data constructor ‘RandomRS’
01:51:32 <ph88> yes works now, thanks guys !
01:51:41 <Gonzih> np
01:56:07 <sagittarian> :t toTitle
01:56:08 <lambdabot> Char -> Char
01:56:18 <sagittarian> :t Data.Text.toTitle
01:56:19 <lambdabot> Data.Text.Internal.Text -> Data.Text.Internal.Text
01:56:29 <sagittarian> is there a normal string version of that function?
01:56:46 <bernalex> sagittarian: why do you need one really?
01:57:21 <bergmark> unpack . toTitle . pack
01:57:27 <sagittarian> because i want to work with regular strings?
01:57:36 <bernalex> sagittarian: that sounds like a bad idea already lol
01:57:47 <shmookey> ph88: sometimes it helps make more understandable error messages if you write smaller functions instead of trying to do things in one line
01:57:51 <shmookey> eg: http://pastebin.com/0Nsu9zSD
01:57:57 <sagittarian> are you saying that when dealing with a real program (not fooling around with ghci like i am) i should always use Text not String?
01:58:23 <bernalex> sagittarian: usually. in your case I would just do unpack . toTitle . pack, like bergmark suggested.
01:58:34 <ph88> :)
01:58:43 <bergmark> sagittarian: unless you have a reason not to, use text
01:58:44 <sagittarian> thanks
01:59:13 <bernalex> yeah and your reason not to better be that you need to use bytestring, not that "string is easier" or "avoiding imports" ;-)
01:59:59 <bernalex> honestly though, String isn't so bad for small programs. it's conceptually neat and simple to work with.
02:01:26 <bernalex> I do expect that newer languages will not have String = [Char] though. elm is an example of a lang that decided not to do this. (though, actually, initially String was indeed [Char] in elm too!)
02:01:42 <Gonzih> bernalex: yes, but once you need to add libs that use Text you will be swimming in pack/unpack
02:02:16 <bernalex> Gonzih: well at that point you're not going to use String any more. :-] also, there's, of course, a GHC extension for that.
02:02:21 <Gonzih> bernalex: as far as i remember purescript just uses js strings, right?
02:02:28 <bergmark> if you use text this is often also true since a lot of libraries still use String
02:02:39 <Gonzih> bergmark true
02:02:42 <bergmark> Gonzih: correct
02:03:12 <bergmark> but if you insist on using text eventually maybe new versions/libraries will come out and you can get rid of some of it
02:03:14 <bernalex> Gonzih: AFAIK it uses js strings which is what elm strings compile down to afaik
02:03:59 * hackagebot blaze-builder 0.3.3.3 - Efficient buffered output.  http://hackage.haskell.org/package/blaze-builder-0.3.3.3 (SimonMeier)
02:04:11 <bernalex> I don't think String v. Text is a problem. I don't encounter it in practice. OverloadedStrings would take care of it if I did. Text v. ByteString and lazy v. strict OTOH, I encounter frequently.
02:04:20 <Gonzih> bergmark: yes, all this Text/String stuff in haskell is not good right now
02:04:34 <bernalex> BL.unpack . bleurgch . TL.pack
02:05:12 <Gonzih> bernalex isn't it big overhead doing a lot of transformations like that?
02:06:09 <bernalex> that depends on how often you're doing it, doesn't it. :-] but some libraries use B and some use T, and at the moment that's just how it is, often.
02:07:07 <Gonzih> true, most of the time I just use bunch of helpers that compose pack/unpack calls
02:07:25 <Schoening> This symbol is my most hated symbol in all of programming:     `     I am using a Danish Keyboard. But I think I have to buy an English one. Because for that symbol I have to: Shift + Doubleclick and then delete one of the `
02:07:34 <bernalex> uhhh
02:07:37 <bernalex> you don't need to buy a keyboard
02:07:44 <bernalex> we are not in the typewriter era
02:07:51 <bernalex> keyboard layouts are managed in software these days
02:08:09 <Schoening> I have åæø and I dont know what they are on the english one
02:08:13 <Gonzih> Schoening: ````````````````````` here, use them
02:08:21 <mayski> also programming is generally more pleasant when you switch to US layout
02:08:23 <bernalex> and also you can do whatever you do + space, instead of double
02:08:29 <Schoening> So if I just change it I might not be able to read.
02:08:31 <bernalex> that should give you just one.
02:08:32 <Gonzih> Schoening: you can use two layouts.
02:08:39 <Schoening> Thanks Gonzih I copy them right away
02:08:40 <bernalex> don't look at the keyboard when you are typing
02:08:49 <mayski> regarding parentheses etc
02:08:56 <bernalex> switch to programmer's dvorak and learn to touch type. problem solved. ;-)
02:09:00 <bergmark> Schoening: isn't it just shift+something and then a space?
02:09:09 <Schoening> I know I know.. but for starting out with the US layout it would be useful to be able to read the buttons
02:09:10 <bergmark> but anyway yes, rebind that stuff :P
02:09:25 <bernalex> Schoening: no no no
02:09:33 <bernalex> Schoening: if you do that you will never learn to touch type.
02:09:33 <Schoening> Yeah that works too bergmark.
02:09:33 <Gonzih> Schoening: learn touch typing :)
02:10:01 <Schoening> I'm tryiiiing. Right now I am using around 7-8 fingers
02:10:04 <bernalex> Schoening: switch to programmer's dvorak, and get a printout or a sticky window with the keys for reference. don't look down. you'll be rewarded.
02:10:22 <Schoening> Yeah I heard good things about dvorak
02:10:32 <Gonzih> Schoening: give it few weeks, I spend 2 weeks to learning qwerty touch typing, but switching to Programmer Dvorak took me something like 2 months
02:10:39 <zomg> before you go for dvorak or such, you should probably consider alternatives like colemak too
02:10:56 <zomg> there's supposedly some advantages in colemak over dvorak
02:11:33 <bernalex> zomg: 1. dvorak has actual research behind it, so I'm not too keen on jumping onto colemak. but I agree that you should at least look at it. 2. programmer dvorak has some advantages over non-programmer layouts... for programmers (surprise!).
02:11:54 <zomg> yeah
02:11:55 <Gonzih> zomg: colemak is easier to learn after qwerty, dvorak is faster and much harder
02:12:06 <Gonzih> faster in terms of typing
02:12:07 <sagittarian> the advantages of colemak over dvorak is the ability to keep z x c v in the same place if you're already used to those locations for copy/paste etc commands
02:12:09 <Gonzih> at least in my experience
02:12:10 <bernalex> zomg: the problem I have seen with colemak etc is that they optimise finger travel, but don't consider things like writing with alternating hands and so forth like dvorak does.
02:12:13 <Schoening> The Danish layout is a nightmare.. 7 got / and {  8 got ( and [  etc  a lot of moving around
02:12:25 <sagittarian> if you use emacs that's not important
02:12:27 <zomg> Gonzih: dunno, I seem to recall they had some proof about the speed with colemak too. Been a while since I looked at it, I could never bother with learning either of them properly :p
02:12:27 <bernalex> Schoening: yep, I'm Norwegian. I grew up with US and NO keyboard layouts.
02:12:31 <bernalex> sagittarian: / is a nightmare
02:12:35 <bernalex> ehm Schoening ^
02:12:42 <sagittarian> anyway i really like programmer dvorak
02:12:50 <sagittarian> not having to hit shift for all those symbols is awesome
02:12:52 <Gonzih> zomg anyway both of them are much better then qwerty
02:13:01 <zomg> yeah I switched to the US layout for qwerty from the finnish layout
02:13:03 <MP2E> there's a programmers dvorak?
02:13:05 <MP2E> what's the difference?
02:13:06 <zomg> much better for writing code :P
02:13:11 <Schoening> Hehe
02:13:11 <Gonzih> sagittarian yay! dvp ftw!
02:13:16 <bernalex> MP2E: http://www.kaufmann.no/roland/dvorak/
02:13:22 <MP2E> my roommate has tried to convicne me to switch to dvorak but I've been lazy, my desktop is already quite keybind based :V
02:13:55 <sagittarian> MP2E, programmer dvorak is dvorak for the letter keys, but it puts common programming symbols on the number keys (without shift), and the numbers can be had by using shift
02:14:00 * hackagebot classy-prelude 0.9.5 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.9.5 (MichaelSnoyman)
02:14:02 * hackagebot classy-prelude-conduit 0.9.5 - conduit instances for classy-prelude  http://hackage.haskell.org/package/classy-prelude-conduit-0.9.5 (MichaelSnoyman)
02:14:04 * hackagebot classy-prelude-yesod 0.9.5 - Provide a classy prelude including common Yesod functionality.  http://hackage.haskell.org/package/classy-prelude-yesod-0.9.5 (MichaelSnoyman)
02:14:06 * hackagebot json-schema 0.7.0.1 - Types and type classes for defining JSON schemas.  http://hackage.haskell.org/package/json-schema-0.7.0.1 (AdamBergmark)
02:14:08 <sagittarian> and they're not in ascending order (as in the original dvorak keyboard)
02:14:17 <Schoening> I'm a little scared that switching to something like programmer dvorak will make me suck at using qwerty. qwerty is the default for gaming
02:14:29 <zomg> What does that have to do with anything?
02:14:31 <bernalex> Schoening: nah
02:14:36 <zomg> You don't use the full keyboard for gaming, just like WASD :P
02:14:48 <Schoening> Yeah but I still need to flame
02:14:50 <zomg> lol
02:14:53 <sagittarian> Schoening, you can switch your keyboard just for gaming
02:15:03 <capisce> Schoening: I had to rebind a lot of keys when playing StarCraft II after switching to colemak
02:15:05 <zomg> I don't see what would stop you from typing in dvorak while gaming =)
02:15:08 <Gonzih> Schoening: I'm suck at qwerty nowadays, reality is that it does not matter most of the time. nothing stops me from doing setxkbmap 'us(dvp)' on other machines and I always have my laptop with my
02:15:09 <sagittarian> ah, sucks indeed
02:15:11 <Gonzih> with me*
02:15:13 <zomg> but yeah you would probably just need to rebind your keys
02:15:15 <capisce> if a game doesn't support rebinding that might be a problem
02:15:18 <bernalex> I type very quickly with qwerty still
02:15:32 <bernalex> but I got my first computer at age 3 or something and have been touch typing for many years, heh
02:15:37 <Gonzih> capisce for gaming I still prefer to use qwerty :) to much remappings
02:15:59 <bernalex> so I guess if you don't touch type with qwerty initially, that might affect how incompetent dvp makes you with qwerty.
02:16:03 <Schoening> Most games would need some rebinding yeah. Uhm quick side question. My chat is not scrolling to the bottom anymore here in irc. how to fix
02:16:25 <bernalex> hmmm not really
02:16:28 <Schoening> I touch type with qwerty
02:16:28 <bernalex> you don't have to rebind
02:16:35 <bernalex> many games use hardware keys
02:16:41 <Schoening> The danish one.
02:16:58 <bernalex> i.e. when you type where the 'e' key is printed, it infers this to 'e', not '.' as it is on dvp.
02:17:11 <Gonzih> I think learning touchg typing with dvorak without any qwerty knowledge is good idea, no habbits. for me that was hardest part
02:17:19 <bernalex> yes
02:17:28 <bernalex> like learning haskell without knowing imperative programming ;-)
02:17:32 <Gonzih> :)
02:17:35 <bernalex> I often compare learning dvorak to learning haskell
02:17:38 * christiansen can't deal with danish qwerty
02:17:56 <christiansen> AltGr-Shift-8 for { is just crazy
02:18:07 <Gonzih> :)
02:18:11 <bernalex> yeah. that's on a single key hit here.
02:18:33 <Schoening> I think I am gonna start a kickstarter for a keyboard that uses small "calculator" screens on each key so it can switch instantly :p any backers?
02:18:59 <bernalex> no thanks
02:19:05 <christiansen> it exists
02:19:09 <bernalex> keyboards should not have prints any more than a piano
02:19:10 <Schoening> exactly christiansen lol
02:19:27 <Gonzih> best keyboard is mechanical one :)
02:19:28 <christiansen> http://en.wikipedia.org/wiki/Optimus_Maximus_keyboard
02:19:33 <bernalex> Gonzih: disagree
02:19:39 <bernalex> Gonzih: topre 4 lief!
02:19:59 <Schoening> I read about the one atwood was working on
02:20:37 <Schoening> Thx for the link christiansen very nice
02:20:51 * christiansen just has a kinesis in a hacked us-international layout
02:21:06 <christiansen> the only thing that sucks to type is ö
02:21:17 <capisce> I can heartily recommend the TypeMatrix 2030 keyboard
02:21:32 <christiansen> æøå are just single-altgr things
02:22:14 <Schoening> Lol try ß alt 225
02:22:25 <bernalex> äöë are just alt-gr semi colon + aoe here. or compose " + aoe.
02:22:28 <Schoening> I'm Danish / German
02:22:32 <bernalex> haha
02:22:39 <bernalex> that's just alt-gr+s here
02:22:48 <christiansen> I type mainly English, Danish, Esperanto, and Swedish
02:22:51 <bernalex> or compose s+s of course
02:23:07 <bergmark> i remapped åöäé to alt+aoeu
02:23:19 <bernalex> alt??
02:23:28 <Schoening> Esperanto ? Really :p That is still a thing?
02:23:34 <Gonzih> bernalex :) I'm big fan of cherry mx blue, but never tried topre, so no idea how do they feel
02:23:35 <christiansen> for some
02:23:36 <bergmark> and [](){} to alt+.phtgc
02:23:38 <bernalex> so your WM can't use aoeu? wow that's harsh :-P I'd use alt-gr
02:23:44 <sagittarian> esperanto ftw!
02:23:52 <christiansen> wm keybindings belong on super, imho
02:23:54 <bernalex> wtf you reserve basically all your WM keys for symbols? woah
02:24:01 <bergmark> i'm on a mac so i don't have alt+gr and it doesn't cause any problems
02:24:05 <bernalex> christiansen: I use both alt and super for WMs.
02:24:09 <christiansen> hardcore
02:24:18 <sagittarian> i bet you the number of esperantists in this channel is hundreds of times higher than the % of the population at large
02:24:24 <christiansen> oh hell yes
02:24:34 <bernalex> christiansen: yeah my WM is uh complicated lol. I have 25 workspaces.
02:24:55 <christiansen>  /join #esperantistaj-haskellistoj
02:25:11 <Schoening> I just googled your TypeMatrix 2030 keyboard capisce I felt like looking at the cockpit inside an airplane.
02:25:23 <bernalex> bergmark: macbooks at least have two alts, my ralt is alt-gr. rcommand is compose.
02:25:27 <osfameron> I'd have expected haskellistas to speak lojban instead of esperanto tbh
02:25:46 <bernalex> osfameron: yeah. been meaning to pick up some basics of lojban for fun.
02:25:59 <sagittarian> esperanto is better than lojban, i've tried both
02:26:01 <capisce> Schoening: do you think that's an accurate metaphor for what it would be like to use this eyboard?
02:26:04 <capisce> *keyboard
02:26:08 <osfameron> and pity the poor fools like me who are using windows (as host OS only, obviously I use Linux for actual work) as we have no compose key at all :-(
02:26:26 <bernalex> osfameron: you can probably change that
02:26:36 <Schoening> I don't know. I have never been a pilot
02:26:44 <bernalex> osfameron: I use a WC for playing games, it drives me nuts that dvp doesn't have æøå available for chatting with NO friends.
02:27:04 <osfameron> how do you chat with no friends?
02:29:04 <mr-> dvorak!
02:30:29 <angerman> How can I figure out why cabal wants to install http-client-0.3.3? (e.g. can I ask cabal to tell me which package is requesting http-client-0.3.3?
02:30:55 <Schoening> So dvorak.. Everything is just shift and I wont have to deal with the ctrl+alt ?
02:31:00 <bernalex> angerman: running it with the verbose flag is useful
02:31:10 <bernalex> Schoening: what?
02:32:07 <Schoening> if I want to type something like @ (which is on the 2 button) I have to press ctrl+alt+2
02:32:09 <bernalex> Schoening: I use altgr and compose for things like ō ß å and so on. symbols like {}()[] are reachable without any modifiers.
02:32:18 <bernalex> @ is a single key without modifiers.
02:33:19 <Schoening> When I look at this: http://www.kaufmann.no/roland/dvorak/ It looks like there has to be at least one extra key for brackets
02:33:31 <bernalex> I don't know what you mean
02:33:48 <bernalex> [ and ] are reached without modifiers.
02:33:59 <Schoening> Okay what is a modifier
02:34:02 * hackagebot BlastHTTP 1.0.1 - Libary to interface with the NCBI blast REST interface  http://hackage.haskell.org/package/BlastHTTP-1.0.1 (FlorianEggenhofer)
02:34:04 * hackagebot cndict 0.2.2 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  http://hackage.haskell.org/package/cndict-0.2.2 (DavidHimmelstrup)
02:34:12 <bernalex> shift/alt/altgr/super/ctrl/etc
02:34:40 <bernalex> <> need modifiers though. this guy was likely writing in C or something that isn't so <$>-heavy.
02:35:07 <Schoening> And are you talking about dvorak ?
02:35:10 <elspru> what's the default behaviour for split, when there are no more seperators? does it return (first,null) or?
02:35:12 <sagittarian> yes it's clear that programmer dvorak is not meant for php
02:35:57 <Schoening> Sorry for being so thick. But I look at this image. And I assume that pressing the number buttons are going to type numbers and brackets with 1 modifier: http://www.kaufmann.no/roland/dvorak/images/dvp1.png
02:35:59 <bernalex> Schoening: programmer's dvorak, which is what you linked to.
02:36:06 <bernalex> Schoening: that's wrong.
02:36:13 <bernalex> Schoening: you need a modifier to get the numbers.
02:36:20 <bernalex> shift, to be specific.
02:36:22 <Schoening> Ahh
02:36:44 <bernalex> so num lock is useful for entering your social security number, heh.
02:37:36 <elspru> ?  split
02:37:47 <Gonzih> bernalex or having secondary layout that has normal numbers row
02:38:02 <bernalex> Gonzih: meh
02:38:14 <bernalex> caps lock will also get you numbers fwiw
02:38:42 <bernalex> my caps lock key is control though, so I use num lock instead. or, really, just shift and number row. not a big problem.
02:38:43 <elspru> oh i see now, split returns a list.
02:38:44 <elspru> hmm
02:38:45 <Gonzih> true, but I use capslock to change layouts for example. Some people remap it to ctrl
02:39:15 <bernalex> elspru: what were you trying to do? perhaps
02:39:18 <bernalex> @src split
02:39:18 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
02:39:23 <bernalex> which wouldn't work anyway, heh
02:39:30 <Schoening> Well then. Time to learn dvorak ! And Haskell!
02:40:06 <Schoening> Time to download a language pack for windows!
02:40:10 <bernalex> Schoening: switch to gentoo and i3wm while you're at it ;-)
02:40:36 <MP2E> or nix/xmonad
02:40:37 <MP2E> ;0
02:40:48 <MP2E> ;) *
02:40:54 <elspru> i have a dictionary file, I'm trying to turn into a hashtable/map
02:41:06 <bernalex> MP2E: those are free software too, so I won't argue against them. :-]
02:41:13 <Schoening> Why gento of all the linux os'es?
02:41:39 <leon1> for its legendary status as something you need to install
02:41:40 <silver> sane package management
02:41:42 <bernalex> Schoening: it's the only one that's not fully terrible
02:41:54 <silver> leon1, no, it's actually good :D
02:42:05 <silver> I mean, yes, not terrible
02:42:08 <Schoening> bernalex well that seems totally unbiased for sure :p
02:42:35 <bernalex> Schoening: well, I go nuts using other distros. I think they're pretty much doing everything wrong. Gentoo only does a few things wrong by comparison.
02:42:40 <tdammers> fully terrible as compared to, say, Windows 98?
02:42:57 <bernalex> as opposed to pretty much any other distro
02:42:57 <silver> more like compared to ubuntu
02:43:08 <bernalex> windows 98 is proprietary so that's not even an alternative ;-)
02:43:29 <silver> windows don't even have package management
02:43:33 <tdammers> most mainstream distros aren't completely free either
02:43:36 <leon1> are we counting nonfree software blobs
02:43:45 <bernalex> tdammers: they can be made free quite easily at least
02:43:51 <leon1> stallman warned me about the blobs
02:43:57 <tdammers> bernalex: some, yes. Others, not so much.
02:44:02 <Schoening> I'm probably alone on this in this room but I really like things that are easy to use. Ubuntu is trying to be user friendly
02:44:14 <bernalex> leon1: I'm counting blobs.
02:44:22 <bernalex> Schoening: I think it's terribly unfriendly
02:44:43 <tdammers> Schoening: Ubuntu is only easy to use for trivial tasks... for anything beyond casual use, it is less user friendly than almost any other mainstream distro
02:45:01 <bernalex> Schoening: all those distros that install a bajillion programs that you don't understand, that are all tightly coupled prevent you from making the distro work *for* you. the environment should adapt to you, not the other way around.
02:45:19 <bernalex> that's where gentoo really shines. customisation.
02:45:36 <Schoening> Yeah. But I think I mean for trivial tasks. What do end users need besides installing their apps?
02:45:38 <tdammers> bernalex: I'm in the debian camp as far as practicality goes
02:45:49 <sagittarian> I'm probably alone in on this in this room but I really like things that are easy to use.  PHP is trying to be user friendly
02:46:00 <tdammers> PHP isn't even free software ;)
02:46:23 <Schoening> lol sagittarian that is just offensive lol
02:46:39 <tdammers> heck, PHP isn't even software in the strict sense
02:46:47 <exio4> how dare you say that... in #haskell!
02:46:52 <sagittarian> no offense intended, just trying to make a comparison
02:46:52 <tdammers> also, we're deep in #-blah territory by now
02:47:06 <bernalex> Schoening: I think installing programs is terrible in setups like ubuntu. I need to compile them from scratch to make it work the way I want it to, and to be certain some ubuntu downstream patch hasn't broken it. and also I obviously don't trust ubuntu after their amazon deal. everything is just a PITA in ubuntu.
02:47:39 * doismellburning resets "Days since unoriginal PHP chat in #haskell" counter to 0
02:47:45 <bernalex> I don't think ubuntu even has a free version of firefox easily available.
02:48:03 <Schoening> Yeah the amazon thing was really fishy. I am still on windows at the moment. Just kind of lost. I think I try that gento on my laptop
02:48:32 <bernalex> Schoening: #gentoo is great help. also you can ping me. I'm a dev, so I'm supposed to know how to use Gentoo I guess.
02:48:45 <tdammers> bernalex: yes, and that despite the fact that the same stuff tends to just work on debian, without having to compile anything from scratch
02:48:45 <Schoening> haha ok :)
02:49:03 * hackagebot persistent-mongoDB 2.0.1 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-2.0.1 (GregWeber)
02:49:24 <tdammers> reason I use debian over gentoo is because installing stuff takes mere seconds, even on low-end hardware
02:49:38 <bernalex> tdammers: yeah I'd use debian over ubuntu any day. I mostly trust debian devs to do the Right Thing ethics-wise.
02:50:05 <sagittarian> debian rocks, but i had a laptop that it just didn't work on (networking didn't work), but ubuntu worked great
02:50:07 <sagittarian> go figure
02:50:18 <tdammers> bernalex: yeah, except for the PHP thing... they should have kicked PHP out, from an ethics point of view, but succumbed to the practicalities of staying alive
02:50:37 <shachaf> No language bashing here, please.
02:50:42 <bernalex> tdammers: the haskell way is doing the Right Thing, and then dealwithit.jpeg for the consequences. I really enjoy that.
02:50:43 <tdammers> sagittarian: I bet debian would have worked if you had installed the same proprietary firmware that ship with default Ubuntu
02:50:50 <edlinde> just wanted an opinion from the haskell experts here :) .. I am about to read —> http://learnyouahaskell.com/functors-applicative-functors-and-monoids.. wondering if its best to first read about the type system from http://www.haskell.org/haskellwiki/Typeclassopedia?
02:50:53 <shachaf> In fact this whole conversation doesn't seem like it belongs here at all.
02:50:55 <bernalex> shachaf: it's not about the language itself.
02:51:00 <tdammers> bernalex: that's because Haskell can afford to avoid success at all cost ;)
02:51:06 <Schoening> The Ubuntu amazon thing reminds me of how I always chuckle when windows 8 gets an update and puts the Windows Store icon YET AGAIN on my task bar
02:51:19 <edlinde> would it be ok to first complete LYAH and then read the typeclassopedia?
02:51:21 <sagittarian> PHP isn't a language
02:51:26 <bernalex> edlinde: nope nope
02:51:34 <shachaf> I'm serious.
02:51:34 <bernalex> edlinde: your latter idea has it right
02:51:34 <Schoening> Sorry for de-railing the chatroom from #haskell for this long.
02:51:42 <fdsffsf> Is there an example of the applicative order evaluator for LC written in Haskell?
02:51:45 <shachaf> edlinde: Either would surely be fine.
02:51:48 <bernalex> edlinde: i.e. don't read the typeclassopedia first.
02:51:52 <tdammers> Schoening: are you familiar with #haskell-blah?
02:51:53 <edlinde> bernalex: ok
02:52:08 <bernalex> edlinde: hey hold on I have a link for you
02:52:09 <Schoening> Nope. But it sounds like I should join there too
02:52:10 <edlinde> since I saw there were things like Arrows etc.. that I dont think is covered in LYAH
02:52:15 <silver> Schoening, there is #haskell-blah for any talk not haskell
02:52:22 * tdammers nods
02:52:31 <Schoening> Thx
02:52:45 <bernalex> edlinde: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html -- it has some oversimplifications that I don't like, but it is a pleasant intro
02:52:55 <tdammers> edlinde: typeclassopedia is nice for a slightly bigger picture than what LYAH has to offer
02:53:13 <tdammers> edlinde: but I don't think it'll make a lot of sense without getting some practical experience first
02:53:30 <edlinde> bernalex: that looks good
02:53:55 <edlinde> tdammers: ok so not knowing all that stuff in typeclassopedia won’t kill me? :)
02:54:04 * hackagebot case-insensitive 1.2.0.1 - Case insensitive string comparison  http://hackage.haskell.org/package/case-insensitive-1.2.0.1 (BasVanDijk)
02:54:04 <tdammers> edlinde: certainly not
02:54:06 * hackagebot persistent-mongoDB 2.0.2 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-2.0.2 (GregWeber)
02:54:09 <edlinde> ok
02:54:11 <bernalex> edlinde: it's stuff you'll get into naturally sometime
02:54:25 <edlinde> depends if I will be able to code in Haskell or not
02:54:26 <tdammers> edlinde: just know that it exists, and come back when you need to
02:54:50 <edlinde> it looks like most people that want to start this new project I will be working on are intent on using Scala
02:55:05 <tdammers> as with many things Haskell, you read it, can't make any sense of it, but when you're ready, you'll remember, re-read, and experience an epiphany
02:55:22 <edlinde> but I think Scala still is copying many concepts from Haskell.. so I am just reading up as much on Haskell and practising as I can
02:55:37 <edlinde> tdammers: yeah I get what you mean
02:56:02 <superlinux-hp> is there a function of this signature: Maybe String -> IO CString in Hackage?
02:56:02 <tdammers> scala copies a lot of things from a lot of languages
02:56:15 <tdammers> java, haskell, lisp, smalltalk, ...
02:56:18 <edlinde> the thing is that I know that even with Scala you can write it in a purely functional manner.. and if we do have to go with scala I will try to stay as functional as possible coz I am not a big fan of OO
02:56:27 <edlinde> tdammers: true
02:56:31 <tdammers> sure
02:56:38 <tdammers> you see, you can just take the best from both
02:56:47 <edlinde> thing is I just have a c/c++ background with a lot of scripting
02:56:50 <bernalex> edlinde: well in scala a lot of things are lazy, and side-effects are allowed
02:56:58 <edlinde> I have done Haskell, Lisp, SML and Erlang in the past
02:57:03 <tdammers> purity / immutability is just as useful in OOP as it is in FP
02:57:07 <edlinde> used Erlang recently.. like Erlang too
02:57:17 <edlinde> bernalex: true I saw that too
02:57:20 <bernalex> so in scala you can do const launchMissiles launchOtherMissiles, and without realising that const is strict, you've just launched both missiles.
02:57:55 <edlinde> the more the merrier huh? ;)
02:57:57 <tdammers> nice thing about Haskell is that so many "dangerous" things are explicit and enforced
02:58:13 <edlinde> yep
02:58:51 <fdsffsf> Or, is there a straightforward example showing various evaluation strategies for lambda calculus in Haskell?  Augustss' and Oleg's implementations seem too complex.
02:58:53 <tdammers> but once you're familiar with the concepts, aware of the dangers, and mentally flexible enough to apply the proper solutions, conventions can go a long way in other languages
02:58:58 <srhb> superlinux-hp: What would that function do if the first argument is Nothing? return ""?
02:59:28 <edlinde> the whole debate about using scala for our project is that many programmers only know Java
02:59:28 <srhb> Or rather, allocate an empty CString.
02:59:36 <superlinux-hp> srhb, I don't know. it's a question posted on facebook
02:59:43 <edlinde> so they can write their stuff in Java.. while someone else can write Scala
02:59:47 <superlinux-hp> I have to translate it from Arabic
03:00:15 <srhb> superlinux-hp: http://hackage.haskell.org/package/hsql-postgresql-1.8.2/docs/DB-HSQL-PG-Core.html#v:newCStringElseNullPtr -- from searching Hayoo
03:00:32 <tdammers> edlinde: programmers who know only java are dangerous
03:00:38 <bernalex> edlinde: everyone I've talked to agree that using java libraries from scala is not as nice as you'd like it to be performance-wise, and that it's generally a bad idea™. ymmv.
03:00:41 <edlinde> yeah I know :)
03:00:43 <tdammers> edlinde: first priority should be to teach them more languages
03:01:09 <edlinde> its a shame coz they are all uni students at Masters level
03:01:16 <tdammers> (this isn't java specific; I would never trust a programmer who knows only one language, regardless of which one)
03:01:20 <edlinde> I would think that they would be comfortable coding in many languages
03:01:26 <bernalex> edlinde: I have worked with those. they are no more and no less terrible than someone with no education.
03:01:31 <srhb> edlinde: depends on what they majored in I guess
03:01:36 <edlinde> yeah
03:02:05 <tdammers> I've seen both good and terrible programmers from both the formally-educated and self-taught populations
03:02:11 <edlinde> I used to work in a company where the top guy only knew how to code in Perl… self taught. He was good at it.. but then he never ever let others try out other languages
03:02:14 <bernalex> you can easily find people with master degrees in CS and ACS that only know PHP and Java, and they don't really even know those.
03:02:16 <tdammers> a degree doesn't really say all that much either way
03:02:19 <edlinde> yeah I agree
03:02:41 <tdammers> and a CS degree says even less about someone's programming skills
03:03:00 <bernalex> tdammers: in my experience, what you want to look for is a free software footprint. having to work with others forces you to write more readable code, and of course to *read* others code.
03:03:25 <edlinde> yeah I mean liek you said.. you find cases where self taught coders are awesome and also people with degrees who can do great stuff
03:03:34 <fdsffsf> How's it related to Haskell?
03:03:34 <tdammers> bernalex: hmm, the best indicator I have found so far is that twinkle in the eye
03:03:35 <exio4> what about programmers from the self-taught world?
03:03:41 <edlinde> guess the guy who made Haskell probably had a PhD
03:03:42 <edlinde> :)
03:03:46 <bernalex> edlinde: lol
03:03:54 <bernalex> edlinde: the main haskell guy is SPJ. he only has a bachelor in maths.
03:04:02 <edlinde> still a degree ;)
03:04:15 <tdammers> people who get wet eyes when talking about exceptionally good code tend to be pretty good programmers
03:04:21 <bernalex> but many years away from a PhD. he did receive an honourary ScD though.
03:04:23 <edlinde> but then I have seen some awesome programmers who have no education at all
03:04:31 <edlinde> tdammers: :)
03:04:42 <tdammers> anyway; I've worked in a team of 4 before; two of us were self-taught, the other two had CS degrees
03:05:29 <tdammers> one of the CS folks was an incredible SQL hacker; he'd get to the bottom of whatever hairy SQL Server stuff we'd throw at him, and he'd figure it out
03:05:38 <edlinde> Isn’t this the guy who made Haskell? —> http://en.wikipedia.org/wiki/Haskell_Curry
03:05:41 <bernalex> tdammers: there is a misconception that uni guys are not self-taught. uni doesn't teach you programming. it just punts you in the right direction for the theory.
03:05:45 <edlinde> he was a Prof!
03:05:46 <tdammers> the other one, uhm, made a REALLY stupid mistake at some point
03:05:54 <bernalex> tdammers: the programming itself is very much self-taught :-]
03:05:58 <bernalex> edlinde: no it's named for him
03:06:10 <bernalex> edlinde: he's a mathematician who died before haskell was ever started.
03:06:11 <edlinde> ok
03:06:20 <tdammers> bernalex: I meant "self-taught" as in "never having received a formal education". I am perfectly aware that learning programming is something you have to do for yourself.
03:06:28 <edlinde> but he did give the concepts like currying :)
03:06:57 <tdammers> anyway; the stupid mistake involved not keeping all the available information around, and not having any primary keys declared at all in the database, despite explicit policy
03:07:05 <edlinde> end of the day.. Haskell is super powerful
03:07:07 <edlinde> :)
03:07:32 <tdammers> stuff was tested, seemed to work, made it into production, then we hit an "edge case" that caused us to irreversibly lose about 10k record of an import
03:07:45 <beckyconning> is it ever a good idea to have one type with one constructor and another with a constructor with the same type signature and one with a different one? if so whats the best way of exhausting the pattern matching in the functor from the larger type to the smaller?
03:07:48 <tdammers> bottom line: 100k $ down the drain, CS guy fired.
03:07:53 <beckyconning> if any of that makes sense : P #noob
03:07:56 <edlinde> alright I will get back to work now .. still got to learn a lot ;)
03:12:07 <beckyconning> i think i'm gonna ignore this line of thought until i've learned more
03:12:34 <beckyconning> i think its beyond the scope of this exercise : P
03:13:32 <tdammers> beckyconning: can you paste some code?
03:14:23 <beckyconning> https://www.irccloud.com/pastebin/xpkWIqhP
03:15:02 <beckyconning> tdammers: ^
03:15:06 <tdammers> yup
03:15:41 <tdammers> I don't see an immediate problem with that
03:15:59 <tdammers> but I get the impression that what you are trying to do with this can be done better
03:16:30 <tdammers> first constructor for LogMessage could be `LogMessage KnownLogMessage` instead
03:17:06 <beckyconning> ooh : )
03:17:26 <beckyconning> thanks!
03:19:54 <angerman> just got bitten by network 2.6. Ouch.
03:21:54 <hexagoxel> can haskell-src-exts parse closed type family definitions? i enabled the extension, but get "parse error: where" when trying to parse Data.Either.EqEither type family definition.
03:23:53 <hexagoxel> ah, hmm, there is a ClosedTypeFamily testcase in the testsuite for haskell-src-exts
03:30:32 <Schoening> Could I get a link of the bla channel? Sorry not very good with irc
03:30:52 <srhb> #haskell-blah ?
03:31:05 <srhb> It's usually /join #channel in most clients
03:31:30 <Schoening> ok thx I have been typing it into the web adress lol
03:43:34 <Feuerbach> hexagoxel: it is supported in git master. It'll be released in the next couple of weeks
03:55:51 <dcoutts> @tell dibblego you can list multiple authors (or maintainers or copyright holders) in a .cabal file, separate with commas is standard practice
03:55:51 <lambdabot> Consider it noted.
04:07:17 <a3f> Hi, I just opened an issue at https://github.com/haskell/win32/issues/24 and would like some guidance if that's possible :)
04:14:45 <hexagoxel_> Feuerbach: ah, thanks.
04:16:05 <t4nk036> @pl \x -> f (g (h (x)))
04:16:05 <lambdabot> f . g . h
04:16:20 <t4nk036> @pl \x y -> f (g (h (x))) y
04:16:20 <lambdabot> f . g . h
04:26:15 <yitz> a3f: isn't "" the same as a null ptr?
04:26:41 <zwer> yitz not at all
04:26:46 <a3f> yitz: "" is a pointer to NUL. nullPtr is NULL
04:27:14 <a3f> NUL is the string terminator. NULL is the architecture's reserved pointer constant
04:27:40 <yitz> ah i see.
04:29:18 <yitz> a3f: that does sound like the best api. the problem is that it would be a massive breaking change, wouldn't it?
04:29:49 <Vertue> I have an iHaskell question, is anyone here familiar with it?
04:31:08 <yitz> a3f: another much messier but less breaking approach would be to adopt a standard naming convention for a second version of each of those that omits the optional LPTSTR (/me ducks)
04:31:23 <a3f> yitz: Actually that's what I meant
04:31:43 <a3f> Something like withOptCString
04:31:59 <a3f> and that for CStr, and CWStr and similiar functions
04:32:21 <a3f> I maube should rewrite the issue to make it more obvious :)
04:33:50 * a3f done editing it.
04:42:48 <bluebelle> Is there a better way to update a record wrapped in State monad without having to get first then put?
04:43:43 <bluebelle> oh, modify of course...
04:54:57 <circ-user-29CMi> anyone here?
04:55:08 <tdammers> yes
04:55:13 <tdammers> lots of people
04:55:18 <tdammers> just ask your question
04:58:27 <sagittarian> how do i write a haskell program that takes an arbitrary string in english and outputs the haskell program that implements what the string says to do?
04:59:04 <ibid> good luck with that :)
05:00:43 <flux> simply post that with some offer to some coder-for-hire website, you'll get responses in no-time
05:03:24 <sagittarian> oh you know that's actually a pretty reasonable solution
05:04:00 <sagittarian> write a program that takes your string, posts it to a coder-for-hire website with an offer for someone to implement it, and returns the result when it comes in
05:04:09 <sagittarian> would be very slow though
05:04:18 <k00mi> sagittarian: here's a book on natural language processing in haskell: http://nlpwp.org/
05:04:21 <sagittarian> and because of the network access would need to be IO String -> IO String
05:06:22 <sagittarian> thanks k00mi, even jokes lead to useful info :-)
05:06:47 <tdammers> unsafePerformMechanicalTurk?
05:07:34 <tdammers> (C# folks just throw NotImplementedException and call it a day)
05:09:31 * hackagebot scientific 0.3.3.1 - Numbers represented using scientific notation  http://hackage.haskell.org/package/scientific-0.3.3.1 (BasVanDijk)
05:23:58 <ph88> Could not deduce (a ~ Int) from the context (Integral a)     <-- what's  ~  here ?
05:25:53 <christiansen> type equality
05:25:53 <christiansen> represented as a constraint
05:33:13 <filius> ls
05:33:25 <MagneticDuck> anybody here ever used haste?
05:33:30 <MagneticDuck> I'm having trouble with DOM stuff
05:33:42 <MagneticDuck> #haskell-haste isn't very.. active
05:34:34 * hackagebot Plot-ho-matic 0.4.0.4 - Real-time line plotter for protobuf-like data  http://hackage.haskell.org/package/Plot-ho-matic-0.4.0.4 (GregHorn)
05:34:58 <MagneticDuck> essentially, I'm trying to add elements to the body
05:35:08 <MagneticDuck> and all I can manage to do is somehow delete the body entirely :D
05:35:42 <MagneticDuck> trying (a <- newElem "div" >> addChild documentBody a)
05:35:49 <MagneticDuck> but I'm really just making wild guesses
05:38:13 <shiona_> MagneticDuck: do my limited understanding you are mixing do-notation and .. whatever the other is
05:38:42 <MagneticDuck> pft x|
05:38:44 <shiona_> do ( a <- newElem "div"; addChild documentBody a )  could work
05:38:49 <MagneticDuck> I understand
05:38:53 <MagneticDuck> I was just writing it on one line
05:39:20 <shiona_> (newElem "div" >> addChild documentBody) could also work, not sure
05:39:26 <MagneticDuck> yes
05:39:47 <MagneticDuck> I'm fairly well versed with monads, I was just being sloppy :<
05:39:54 <shiona_> oh, sorry :D
05:40:03 <MagneticDuck> the point at fault here is my understand of haste
05:40:08 <MagneticDuck> understanding*
05:40:26 <shiona_> Ok, I'm of no use there
05:40:35 <MagneticDuck> :(
05:40:39 <MagneticDuck> neither am I
05:41:14 <MagneticDuck> there's nothing in the examples >_>
05:41:32 <MagneticDuck> I'll just look at javascript docs
05:41:39 <MagneticDuck> been a while since I did the js
05:42:15 <MagneticDuck> oh hm.
05:44:26 <shiona_> MagneticDuck: You've most likely found this already, but just in case it's of help: http://haskell-web.blogspot.fi/
05:44:55 <MagneticDuck> cool
05:44:59 <MagneticDuck> I think I solved my problem
05:45:10 <shiona_> nice
05:45:57 <MagneticDuck> I did it
05:45:59 <MagneticDuck> go me
05:46:43 <hexagoxel> cabal does not lock the sandbox while installing stuff into it?
05:54:36 * hackagebot fptest 0.2.2.0 - IEEE754r floating point conformance tests  http://hackage.haskell.org/package/fptest-0.2.2.0 (jrp)
06:15:15 <int-e> Is there something like http://lpaste.net/110796 on hackage? (it's separating the read and write ends of a Chan)
06:17:00 <dcoutts_> int-e: isn't newTarget much like dup ?
06:17:16 <int-e> dcoutts_: sure, if you look at dupChan below
06:22:32 <corkexaminer> anybody know if the hackage builder is generating haddocks at the moment?
06:23:36 <corkexaminer> I uploaded keystore last night but can’t find any indication that any building ahs happened: no haddocs nor could I find any logs
06:24:20 <corkexaminer> our own hackage server mirrorred the package and built everything fine but it is on a later release of hackage where some work has been done on the builder
06:25:19 <int-e> dcoutts_: One could have a dup :: Target a -> IO (Target a); dup (Tgt mv) = do next <- readMVar mv; Tgt <$> newMVar mv, which is something that Chan currently doesn't have, and probably doesn't need because the writing end is always carried around.
06:26:29 <corkexaminer> (I checked the logs like this: http://hackage.haskell.org/package/keystore-0.5.1.0/reports/1/log — returns a 404)
06:26:44 <ph88> Could not deduce (a ~ Int) from the context (Integral a)     <-- what's  ~  here ?
06:26:54 <int-e> ph88: type equality
06:27:17 <dcoutts_> corkexaminer: we just completed a GSoC project which included an improvement to report build results even when it cannot find a build plan
06:27:59 <dcoutts_> corkexaminer: currently the build report format requires a list of all the deps that the package was tried against, which is fine for when a package does not compile, but doesn't cover the case where there's not even a solution
06:28:16 <corkexaminer> indeed — we discussed it on Friday — we have those patches on our own server
06:28:32 <dcoutts_> corkexaminer: so we'll be updating to that code that shortly and then you'll be able to see a build report.
06:29:02 <dcoutts_> corkexaminer: oh, heh, I didn't recognise your irc nick
06:29:28 <dcoutts_> corkexaminer: but the main thing to check is that your package works with 7.6.3, with the previous HP release
06:29:28 <corkexaminer> thought you mightn’t :-)
06:29:52 <dcoutts_> we need to have multiple build bots, using different configurations
06:29:55 <corkexaminer> right — so the build probably broke down because it could not build a coherent dep graph
06:30:06 <dcoutts_> right
06:30:53 <corkexaminer> Ok — 7.6.3 is my workhorse but I am suing a sandbox
06:31:24 <corkexaminer> iriony is I clean built it on 7.8.3 before uploading — need to go back and do the same for 7.6.3
06:31:32 <deech> One of the ICFP 2014 talks "Reflection Without Remorse" mentioned type alignment. What is type alignment?
06:31:51 <corkexaminer> dcoutts_: thanks!
06:33:32 <c_wraith> deech: it just means matching types up in a sequence of type-changing operations.
06:34:38 <edwardk_> deech: you wind up with a list of things like k a b, k b c, k c d, k d e ...
06:34:42 * hackagebot isdicom 0.0.1 - An executable and library to determine if a file is a DICOM file  http://hackage.haskell.org/package/isdicom-0.0.1 (TonyMorris)
06:34:42 <c_wraith> deech: which is a little interesting in the context of that paper, since it's keeping an explicit sequence of type-changing operations reified in memory, so it needs to use data structures that record that properly
06:35:32 <ph88> thx int-e
06:35:41 <edwardk_> deech: data Thrist k a b where Nil :: Thrist k a a; Cons :: k a b -> Thrist k b c -> Thrist k a c -- (though it should probably be Cons :: k b c -> Thrist k a b -> Thrist k a c -- to make a proper "free category"
06:36:51 <ph88> > g <- getStdGen
06:36:53 <lambdabot>  not an expression: ‘g <- getStdGen’
06:37:32 <ph88> o_O
06:38:22 <hyPiRion> > do { g <- getStdGen; return g }
06:38:23 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable
06:38:24 <lambdabot>                     System.Random.StdGen)
06:38:24 <lambdabot>    arising from a use of ‘M43430463242622707213233.show_M43430463242622707213...
06:39:43 * hackagebot isdicom 0.0.2 - An executable and library to determine if a file is a DICOM file  http://hackage.haskell.org/package/isdicom-0.0.2 (TonyMorris)
06:43:51 <ph88> why does this return a tuple ?  https://www.fpcomplete.com/project/61254/covEKvgUPx
06:45:54 <alpounet> ph88: see the docs for 'randomR' on this page: http://hackage.haskell.org/package/random-1.0.1.3/docs/System-Random.html -- it returns the random value you asked for + the "new generator", i.e one with an altered seed so that you don't get the same value next time you call it
06:45:55 <itechjunkie> ph88: Looks like it returns a range.
06:46:56 <Darwin226> This isn't really a haskell question, but if I called a type that's a container for n different types (basically a tuple) a Vector, what would I call a type that's a container for n values of the same type. n some fixed value
06:47:08 <yitz> @type \g -> //www.fpcomplete.com/project/61254/covEKvgUPx
06:47:08 <yitz> 16:42 -!- Jerryjiggler [~jerryjigg@cpe-74-67-8-191.nycap.res.rr.com] has joined #haskell
06:47:10 <lambdabot> parse error on input ‘//’
06:47:11 <yitz> 16:42 -!- alanz [~alanz@105-237-137-236.access.mtnbusiness.co.za] has joined #haskell
06:47:27 <yitz> oops sorry about that.
06:47:48 <yitz> @type \g -> randomR (0 :: Int,1) g
06:47:49 <lambdabot> RandomGen g => g -> (Int, g)
06:48:29 <dfeuer> dcoutts, do you have a moment?
06:48:31 <ph88> how can i have this return a decimal number between 0 and 1 ?  https://www.fpcomplete.com/project/61254/covEKvgUPx
06:48:44 <etandel> Darwin226: a sequence, maybe?
06:48:52 <ph88> thx alpounet i will use randomRs and take 1 instead then
06:48:55 <c_wraith> ph88: do you know what the Int type means?
06:49:11 <etandel> Though I'd rather just call the tuple a tuple and the second thing a vector.
06:49:22 <gunnarsson> Hello, does anyone one of a (standard?) function that performs this list transformation: [1,2,3,4] => [[1,2],[2,3],[3,4]] ?
06:49:33 <Darwin226> etandel: Yeah, I like that better. I'll do that. Thanks
06:49:34 <alpounet> ph88: you must ask for a Double or a Float, giving (0, 1) as the range argument.
06:49:41 <ph88> c_wraith: right :/ sorry about that ... can i put the Type somewhere else ?
06:49:52 <albeit_> > ap zip tail [1,2,3,4]
06:49:54 <lambdabot>  [(1,2),(2,3),(3,4)]
06:50:25 <yitz> ph88: that sounds a little silly. why not just fst (randomR (0, 1) g) if all you need is one value and you don't need the generator after that?
06:50:33 <albeit_> Hmm not to lists though..
06:52:10 <etandel> you can than map \(a,b) -> [a,b]
06:52:16 <ph88> yitz: yes better !
06:52:21 <gunnarsson> albeit_: but it should work with zipWith : or something?
06:52:22 <etandel> then*
06:53:15 <gunnarsson> albeit_: well, thanks
06:53:23 <albeit_> gunnarsson: Not :, but at least zipWith (\a b -> [a,b])
06:53:30 <albeit_> Though I'm sure theres a cleaner way
06:54:13 <gunnarsson> albeit_: I'll let that be an exercise for myself :)
06:54:44 <exio4> @pl \a b -> a:b:[]
06:54:44 <lambdabot> (. return) . (:)
06:56:29 <yitz> > (zipWith (\x y -> [x,y]) <*> tail) [1..5]
06:56:31 <lambdabot>  [[1,2],[2,3],[3,4],[4,5]]
06:56:43 <yitz> nice, albeit_ !
06:58:04 <hyPiRion> Although it includes non-filled lists, this is a good starting point for a more general one
06:58:12 <hyPiRion> @let partition n step xs = case xs of [] -> []; xs' -> take n xs : partition n step (drop step xs)
06:58:13 <lambdabot>  .L.hs:197:28:
06:58:13 <lambdabot>      Ambiguous occurrence ‘partition’
06:58:13 <lambdabot>      It could refer to either ‘L.partition’, defined at .L.hs:194:1
06:58:13 <lambdabot>                            or ‘Data.List.partition’,
06:58:13 <lambdabot>                               imported from ‘Data.List’ at .L.hs:90:1-16
06:58:22 <hyPiRion> ahh.
06:58:36 <hyPiRion> @let partition' n step xs = case xs of [] -> []; xs' -> take n xs : partition n step (drop step xs)
06:58:36 <yitz> > let f = chunksOf 2 . init . tail . concatMap (\x -> [x,x]) in f [1..5]
06:58:37 <lambdabot>  .L.hs:197:28:
06:58:37 <lambdabot>      Couldn't match expected type ‘[a1] -> [[a1]]’
06:58:37 <lambdabot>                  with actual type ‘([a], [a])’
06:58:37 <lambdabot>      Relevant bindings include
06:58:37 <lambdabot>        xs' :: [a1] (bound at .L.hs:197:9)
06:58:39 <lambdabot>  [[1,2],[2,3],[3,4],[4,5]]
06:59:15 <hyPiRion> > partition' 2 1 [1..5]
06:59:16 <lambdabot>  Not in scope: ‘partition'’
06:59:16 <lambdabot>  Perhaps you meant one of these:
06:59:16 <lambdabot>    ‘BS.partition’ (imported from Data.ByteString),
06:59:16 <lambdabot>    ‘IM.partition’ (imported from Data.IntMap),
06:59:16 <lambdabot>    ‘partition’ (imported from Data.List)
06:59:25 <hyPiRion> maybe I should just not attempt these things
06:59:45 <yitz> @type chunksOf
06:59:46 <lambdabot> Int -> [e] -> [[e]]
07:01:50 <yitz> oh the error was for hyPiRion, not me. :)
07:02:18 <yitz> > let f = chunksOf 2 . init . tail . concatMap (\x -> [x,x]) in f [1..5] -- gunnarsson
07:02:18 <hyPiRion> yitz: yeah
07:02:20 <lambdabot>  [[1,2],[2,3],[3,4],[4,5]]
07:02:46 <yitz> gunnarsson: but i like the approach of albeit_ better.
07:02:51 <deech> c_wraith ekmett: Thanks!
07:03:01 <hyPiRion> @let partition' n step xs = case xs of [] -> []; xs' -> take n xs : partition' n step (drop step xs)
07:03:02 <lambdabot>  .L.hs:201:1: Warning:
07:03:02 <lambdabot>      Pattern match(es) are overlapped
07:03:02 <lambdabot>      In an equation for ‘partition'’: partition' n step xs = ...
07:03:03 <gunnarsson> yitz: me too, actually
07:03:04 <lambdabot>  
07:03:05 <lambdabot>  <no location info>:
07:03:32 <hyPiRion> > partition' 3 2 [1..10]
07:03:34 <lambdabot>  Not in scope: ‘partition'’
07:03:34 <lambdabot>  Perhaps you meant one of these:
07:03:34 <lambdabot>    ‘BS.partition’ (imported from Data.ByteString),
07:03:34 <lambdabot>    ‘IM.partition’ (imported from Data.IntMap),
07:03:34 <lambdabot>    ‘partition’ (imported from Data.List)
07:03:41 <hyPiRion> Alright, I give up. Sorry for the spam here
07:04:42 <ph88> does anyone know an editor which has different syntax highlighting for haskell functions and non-functions? (like an Int)
07:05:06 <yitz> > chunksOf 3 [1..10] -- hyPiRion
07:05:07 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
07:05:20 <yitz> hyPiRion: is that what you are trying to implement?
07:07:19 <yitz> > let chunksOf' _ [] = []; chunksOf' n xs = take n xs : chunksOf' n (drop n xs) in chunksOf' 3 [1..10] -- hyPiRion: here's one way
07:07:21 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
07:07:58 <hyPiRion> yitz: but with variadic step
07:09:04 <yitz> > let chunksOf' n = map (take n) . takeWhile (not . null) . iterate (drop n) in chunksOf' 3 [1..10] -- hyPiRion here's another way
07:09:05 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
07:09:29 <yitz> hyPiRion: variadic?
07:09:40 <hyPiRion> > let chunksOf' _ _ [] = []; chunksOf' n step xs = take n xs : chunksOf' n step (drop step xs) in chunksOf' 3 2 [1..10]
07:09:42 <lambdabot>  [[1,2,3],[3,4,5],[5,6,7],[7,8,9],[9,10]]
07:09:48 <hyPiRion> like that ^
07:10:56 <yitz> hyPiRion: ah, i see.
07:13:03 <yitz> > let chunksOf' _ _ [] = []; chunksOf' n step xs = take n xs : chunksOf' n step (drop step xs) in chunksOf' 2 1 [1..10]
07:13:04 <lambdabot>  [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10],[10]]
07:13:30 <yitz> > let chunksOf' _ _ [] = []; chunksOf' n step xs = take n xs : chunksOf' n step (drop step xs) in chunksOf' 2 1 [1..9]
07:13:31 <lambdabot>  can't find file: L.hs
07:13:40 <yitz> > let chunksOf' _ _ [] = []; chunksOf' n step xs = take n xs : chunksOf' n step (drop step xs) in chunksOf' 2 1 [1..9]
07:13:41 <lambdabot>  [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9]]
07:13:58 <yitz> > let chunksOf' _ _ [] = []; chunksOf' n step xs = take n xs : chunksOf' n step (drop step xs) in init $ chunksOf' 2 1 [1..10]
07:14:00 <lambdabot>  [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7],[7,8],[8,9],[9,10]]
07:14:26 <yitz> hyPiRion: so yet another nice solution  of gunnarsson
07:15:55 <gunnarsson> it'd be kinda cool to have a Data.List function named after you, y'kno
07:16:43 <hyPiRion> yitz: right, neat use of init
07:18:18 <albeit_> How do I enable parallel building with building with cabal?
07:18:27 <bennofs> albeit_: -j
07:18:43 <xplat> there are two haskell bindings of libcurl, one of which is v0.1.1, the other hasn't been updated since 2012, which is less bad to use?
07:19:34 <yitz> ah, thrists. they're nice. i think they are the only real solution to problems like this: http://www.haskell.org/pipermail/haskell-cafe/2011-February/089719.html
07:20:15 <dbp> albeit_: If you are using the current release, I think it happens automatically. It used to be flag -j though.
07:20:37 <dbp> oh, bennofs woops. I need to read more carefully
07:20:38 <albeit_> bennofs, dbp: Okay. Is "j" an option for GHC or for cabal?
07:21:01 <dbp> albeit_: cabal.
07:23:07 <arthur_honeynet> @xplat: use wreq instead? http://www.serpentine.com/wreq/
07:23:07 <lambdabot> Unknown command, try @list
07:23:10 <MagneticDuck> uhm
07:23:21 <arthur_honeynet> xplat: use wreq instead? http://www.serpentine.com/wreq/
07:23:28 <MagneticDuck> if I have a library that I want to build and install locally using haste, what dependencies can I use?
07:23:37 <MagneticDuck> .. isn't base available?
07:23:43 <MagneticDuck> haste-inst is telling me I can't use base
07:24:03 * MagneticDuck is confused about haste
07:24:22 <MagneticDuck> wait never mind xD
07:24:40 <xplat> arthur_honeynet: i'm not sure wreq supports everything i need to do
07:27:53 <yitz> xplat: curl has been the standard. it's a good library. but you're right, dons is the maintainer, and he has become nearly invisible lately.
07:28:28 <yitz> xplat: don't know much about curlhs, but it actually looks quite nice, and more complete. could very well be worth a try.
07:34:51 * hackagebot hakyll 4.5.5.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.5.5.0 (JasperVanDerJeugt)
07:37:54 <yitz> xplat: xreq is indeed an interesting pure haskell alternative. another is http-conduit.
07:38:58 <xplat> yeah, neither one has the flexibility of curl in terms of transports though
07:45:01 <_1_Jan-Eric> meet mehr Chicago bulls area
07:52:45 <ph88> is it possible to have two lists of equal length and feed each element from both list to a function?  so [1,2,3]  ["a","b","c"]    func 1 "a"   func 2 "b"   func 3 "c"
07:52:59 <Twey> :t zipWith
07:53:00 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
07:53:03 <cdk> ph88: try zipWith ($)
07:53:21 <ph88> ah good one !
07:53:22 <Twey> zipWith id if the first list is a list of functions
07:54:08 <superlinux-hp> I need how to make a global cabal library download location seen by all users on the system. if I do in ghci :m A_MODULE, it should be seen by any user if I download it as root.
07:54:20 <superlinux-hp> would someone tell me how?
07:56:49 <superlinux-hp> i use Debian Linux
07:58:47 <Gonzih> superlinux-hp sounds like straight way in to cabal hell
07:59:12 <hyPiRion> the deep end of the cabal hell swimming pool
07:59:28 <superlinux-hp> Gonzih, I want to make cabal downloaded libraries go system wide. how?
07:59:28 <christiansen> superlinux-hp: what you're asking for is likely to cause pain in the future - why do you need this? perhaps we can point out a better way
07:59:40 <dcoutts_> superlinux-hp: you can install things system-wide using cabal install --global --rootcmd=sudo
07:59:43 <xplat> out of the cabal frying pan, into the cabal fire
07:59:59 <dcoutts_> superlinux-hp: but as others are saying, it means individual users cannot chose their own package versions so easily
08:00:00 <superlinux-hp> dcoutts,  ok cool!
08:00:16 <superlinux-hp> I am fine with that.
08:00:17 <Gonzih> superlinux-hp clear solution that I can see use soe ppa with haskell packages. But again there is no guarantee that there will be no version collisions with packages installed using just cabal
08:00:23 <superlinux-hp> it's my own laptop.
08:01:04 <Gonzih> superlinux-hp I'm just curios why do you want to do that?
08:01:34 <xplat> if one person was equal to one user you wouldn't need this in the first place, would you?
08:04:25 <superlinux> Gonzih, I have more space in the root partition than that of the home directory.
08:04:56 <Gonzih> superlinux: ln -s ?
08:05:13 <Gonzih> you can also specify different default directory for cabal
08:05:28 <superlinux> yes. how?
08:06:25 <yitz> if there is only one user on the system, using cabal --global like dcoutts_ said shouldn't be any problem
08:06:26 <Gonzih> superlinux http://stackoverflow.com/questions/5832472/how-can-i-change-the-directory-where-cabal-stores-the-documentation
08:07:04 <Gonzih> maybe it's not what you were looking for :)
08:08:46 <xificurC> I started wondering, why are all shells written in C/C++? It's not like it has to be super-lightning-uber-fast. Is there a specific reason to use such a low-level language?
08:09:14 <xificurC> why isn't there a widespread haskell shell, or python shell etc
08:09:31 <xificurC> x shell = shell written in x
08:09:53 <kaol> Think of shell scripts. People mind if those are slow.
08:09:53 <Denommus> xificurC: first, what is a shell to you?
08:10:25 <xificurC> Denommus: bash, zsh, fish, ksh, ...
08:10:26 <Denommus> personally, I see most REPLs as a kind of shell
08:10:41 <Denommus> xificurC: this does not define anything. Is SBCL a shell? What about ghci?
08:11:54 <cpennington> xificurC: ipython is intended to be possible to use as a bash replacement
08:11:55 <HENK29933> I have had luck avoiding cabal hell with the new sandbox option in cabal-install
08:11:58 <HENK29933> ..
08:12:11 <cpennington> (and you can get a haskell mode for ipython)
08:12:13 <xificurC> Denommus: are you asking this because you don't understand my question>
08:12:15 <xificurC> ?
08:12:38 <xplat> kaol: shell scripts don't get fast just because the shell is written in C
08:12:43 <xificurC> Denommus: I didn't define the term shell but people seem to be using it to talk about such things
08:12:46 <Twey> xificurC: They're old, and C was the only thing that was used
08:12:52 <xificurC> I think it's pretty clear what I mean
08:12:52 <Denommus> xificurC: because depending on what you see as a shell the answer will be different
08:13:03 <HENK29933> before you do a cabal build you do 'cabal sanbox && cabal install --only-dependencies'
08:13:09 <Twey> xificurC: But there are plenty of shells written in other languages, like the Scheme shell (scsh) and Microsoft's PowerShell
08:13:14 <Denommus> xificurC: there are some dudes that use Common Lisp as shell. Others use eshell (which is written in Emacs Lisp)
08:13:27 <cpennington> there's also https://github.com/cpennington/h4sh (dons project for haskell shell scripts, which I resurrected a few years ago, but which probably doesn't build anymore/again)
08:13:31 <Denommus> oh, yeah, PowerShell
08:13:43 <xificurC> hm, well let's say anything you can set as your login shell via chsh, is that better?
08:13:46 <Twey> We have a bunch of Haskell libraries for shell scripting
08:14:07 <xplat> it seems most people who write a shell in an HLL write a radical departure from bourne-style shells
08:14:14 <Twey> There's Shelly, and chrisdone's Hell :þ
08:14:39 <Twey> Most people who write a shell write a radical departure from Bourne-style shells
08:14:47 <Twey> (these days)
08:14:56 <xplat> which is often somewhat better for scripting but far worse for routine command-line stuff
08:15:09 <Twey> fish is really the only counterexample I can think of, and even then it's very different in its workings if not its surface syntax
08:15:26 <RchrdB> I found I had the opposite problem with fish.
08:15:27 <Denommus> xificurC: you can set clisp as your login shell. You can set Emacs as your user-space
08:15:56 <xplat> there are a lot of things i love about bourne-style shells.  like i can actually run things from the command line.  also, pipes.
08:16:03 <RchrdB> Most alternative shells like scsh and friends tend to be radically different and bad at interactive use
08:16:05 <xificurC> Denommus: those aren't widespread though
08:16:17 <christiansen> powershell is reasonable for interactive use
08:16:22 <xificurC> my question was why arent there widespread non-C shells
08:16:28 <xificurC> on linux*
08:16:28 <RchrdB> fish is a great counterexample: it's lovely for interactive use.
08:16:39 <christiansen> won't powershell run on mono?
08:16:44 <sipa> xificurC: because the existing C ones work fine
08:16:44 <Twey> Doubt it
08:16:52 <sipa> xificurC: and people value compatibility
08:16:57 <Denommus> xificurC: you never mentioned widespread
08:16:58 <xplat> christiansen: powershell is good for interactive use of things written to be used with powershell.  that's a huge chicken-egg problem
08:16:58 <RchrdB> My problem with fish is that it turns out that I write 1-line or 2-line shell scripts all the time and I have muscle memory for Bourne's syntax already. :|
08:17:08 <xificurC> christiansen: https://github.com/Pash-Project/Pash
08:17:39 <Denommus> xificurC: but the reason is the same for why C is popular: historical context
08:17:41 <christiansen> ok
08:17:48 <xificurC> 17:07:54        xificurC | x shell = shell written in x
08:17:50 <xificurC> oops
08:17:59 <xificurC> 17:07:37        xificurC | why isn't there a widespread haskell shell, or python shell etc
08:18:07 <xificurC> Denommus: I sure did ^
08:18:23 <xificurC> Denommus, sipa. I see
08:18:32 <xificurC> damn compatibility
08:18:35 <Denommus> xificurC: well, you didn't in the first question, and I have not seen the widespread word in the second
08:18:46 <Denommus> xificurC: anyway, PowerShell is an widespread .NET shell
08:18:55 <xificurC> Denommus: that doesn't mean I didn't mention it, does it now :)
08:19:30 <xificurC> well thanks for the short talk, gotta run now
08:19:33 <Denommus> honestly, bash sucks. Zsh sucks less, but it still sucks
08:19:43 <xificurC> Denommus: second that
08:19:46 <Denommus> but... it's popular, so, what could we do?
08:19:59 <xificurC> Denommus: roll our own!
08:20:07 <xplat> the real 'problem' is the unix process model is popular
08:20:24 <Denommus> xificurC: meh, I have other priorities
08:20:59 <Denommus> xplat: piping is cool, but it could easily be seen as function composition (see the pipe operator in OCaml)
08:21:00 <xplat> who wants to try to design a nice language with the constraint that all your args are C strings and all your return values are 8-bit ints?
08:21:42 <xificurC> gotta run, thanks for the talk
08:23:27 <Twey> Denommus: Piping is not function composition: it's pipe composition
08:23:28 <cpennington> xplat: Perhaps one could build a language/shell that falls back to C strings/ints, but that has a more expressive piping language that it can upgrade to between two consenting programs?
08:24:03 <xplat> cpennington: yeah, that was my approach.  but, second system syndrome :(
08:24:40 <cpennington> yeah, definitely an easy trap to fall into
08:24:42 <Denommus> Twey: it's taking the return value from a process and passing it to the next
08:24:42 <xplat> cpennington: tried to make my super-expressive piping language based on iteratees and lenses
08:24:59 <Denommus> Twey: I think Clojure would even call it "threading", for some weird reason
08:25:04 <xplat> Denommus: stdout is not 'return value'
08:25:09 <cpennington> I did kinda like being able to just use haskell functions as programs (h4sh), but never really got enough muscle memory to keep using it
08:25:17 <Denommus> xplat: that depends!
08:25:21 <xplat> (unless you use $(), and then it is)
08:25:28 <Denommus> xplat: PowerShell can pipe .NET objects, for instance
08:26:22 <xplat> Denommus: doesn't it use IEnumerable for that and not the regular return value channel?
08:27:19 <Denommus> xplat: something like that. Anyway, I said "could" because a shell could be written with a different mindset
08:27:35 <yitz> RchrdB: also PowerShell
08:27:42 <Denommus> xplat: another example: Common Lisp REPL's (clisp can even be used as a shell). It uses return values, of course
08:28:21 <Denommus> it doesn't have a shell operation, but you can use function composition instead
08:28:23 <Twey> Denommus: You can pipe infinite streams of values between processes
08:28:30 <Denommus> s/shell operation/pipe operation/
08:28:43 <Denommus> Twey: that is true
08:28:46 <Twey> And the values are not produced until called upon, modulo buffering
08:28:47 <xplat> Denommus: well, yes, you could write a shell with a completely different mindset that passes most info by return values instead of pipes, but then it wouldn't have pipes, would it?
08:29:03 <Denommus> yeah, yeah, I'm wrong
08:29:29 <RchrdB> yitz, hmm?
08:29:58 * hackagebot doctest-discover 0.1.0.3 - Easy way to run doctests via cabal  http://hackage.haskell.org/package/doctest-discover-0.1.0.3 (karun012)
08:30:31 <yitz> RchrdB: sorry, once again forgot that my buffer was scrolled up /:
08:33:05 <RchrdB> yitz, no worries. ^^
08:40:43 <carter> since I know everyone here likes having location info in their messages, check out http://www.reddit.com/r/haskell/comments/2fwwx3/how_to_get_approx_stack_traces_with_profiled/  :)
08:42:30 <nshepperd> '
08:43:24 <nshepperd> 'NB: GHC 7.10 will have much better stack trace tooling than this,' oh my, Functor/Monad/Applicative refactoring *and* error stack traces
08:44:07 <nshepperd> I'm excited for 7.10
08:46:15 <carter> nshepperd: also i cooked up the example in the post like 5 min ago
08:46:29 <carter> and it worked (well, errored) correctly the first time :)
08:47:06 <nshepperd> yeah, errorWithStackTrace looks sweet
08:48:36 <carter> use it for all your error needs
08:48:43 <carter> hrm
08:49:15 <carter> shame that base doesn't use it for all the errors in there
08:54:09 <Clint> plessy
08:54:39 <dfdsfsdf> why does f in pythagoras_cps 2 3 f from this example https://en.wikibooks.org/wiki/Haskell/Continuation_passing_style affect the output? f is not used anywhere in there.
08:54:58 <carter> BUT, i think come 7.10 all exceptions will come with free stack traces
08:55:01 * hackagebot dice-entropy-conduit 1.0.0.1 - Cryptographically secure n-sided dice via rejection sampling.  http://hackage.haskell.org/package/dice-entropy-conduit-1.0.0.1 (PeterRobinson)
08:57:24 <geekosaur> dfdsfsdf, looks to me like it is
08:57:29 <dfeuer> 7.10 will sing *and* dance.
08:57:43 <geekosaur> \k -> ... add_cps x_squared y_squared $ k
08:57:56 <geekosaur> (k being your f)
08:58:40 <dfdsfsdf> geekosaur: so function is basically applied to the value as in map ($ 2) [(*3), (*4)]?
08:59:11 <dfeuer> carter, when did typed holes come in? The greatest newbie-friendly GHC extension since ScopedTypeVariables.
08:59:19 <carter> 7.8
08:59:28 <geekosaur> something like that, yes. that's the point of continuations
09:00:09 <dfdsfsdf> okay, I'll keep that in mind.  thanks, geekosaur.
09:01:09 <dfeuer> We need more advertising of typed holes, I think. And once partial type signatures are ready to roll....
09:03:14 <jle`> typed holes helped me sleep an hour earlier last night
09:04:05 <shapr> dfeuer: are there good examples of typed holes online?
09:04:16 <shapr> Is there a weekly feature spotlight series? :-)
09:04:36 <carter> :t f x = _
09:04:37 <lambdabot> parse error on input ‘=’
09:04:39 <dfeuer> I don't know about examples. There's no weekly feature spotlight.
09:04:40 <johnw> shapr: just use _ where you might have used undefined in the past
09:04:49 <jle`> there's that lens tutorial that used _ a lot
09:04:57 <dfeuer> I don't know if lambdabot has them yet.
09:05:01 <jle`> it do
09:05:01 <dfeuer> > 3 + _
09:05:02 <lambdabot>  Found hole ‘_’ with type: a
09:05:02 <lambdabot>  Where: ‘a’ is a rigid type variable bound by
09:05:02 <lambdabot>             the inferred type of it :: a at Top level
09:05:02 * hackagebot smallcaps 0.5.1.1 - Flatten camel case text in LaTeX files  http://hackage.haskell.org/package/smallcaps-0.5.1.1 (StefanBerthold)
09:05:08 <geekosaur> :t \x -> _
09:05:09 <lambdabot>     Found hole ‘_’ with type: t1
09:05:09 <lambdabot>     Where: ‘t1’ is a rigid type variable bound by
09:05:09 <lambdabot>                 the inferred type of it :: t -> t1 at Top level
09:05:19 <dfeuer> It do seem to have them broken.
09:05:27 <dfeuer> > (3::Int) + _
09:05:28 <lambdabot>  Found hole ‘_’ with type: GHC.Types.Int
09:05:36 <dfeuer> Unless they never handle constraints?
09:05:39 <jle`> that's how it behaves in ghci tho
09:05:43 <jle`> yeah, it's really kinda weird
09:05:54 <carter> dfeuer: theres a ticket about adding more constraint inof
09:06:03 <shapr> johnw: Cool, I've used undefined often to figure out a type.
09:06:42 <carter> you can also name the holes
09:06:52 <carter> _bob _janet _bobHarper _wadler
09:06:59 <carter> or whatever
09:07:00 <dfeuer> Well, aside from the class constraint problem, typed holes are nice.
09:07:04 <carter> yeah
09:07:21 <carter> and they'r on by default because they dont exist for valid haskell programs
09:07:28 <carter> and the haskell spec is only for valid programs
09:09:13 <monochrom> <3 haskell
09:09:37 <jle`> > let foo :: ((Either a (a -> b)) -> b) -> b; foo f = f _
09:09:38 <lambdabot>  can't find file: L.hs
09:09:41 <jle`> > let foo :: ((Either a (a -> b)) -> b) -> b; foo f = f _
09:09:43 <lambdabot>  not an expression: ‘let foo :: ((Either a (a -> b)) -> b) -> b; foo f = f _’
09:09:46 <pqmodn> do they not work in ghci?
09:09:56 <jle`> > let foo :: ((Either a (a -> b)) -> b) -> b; foo f = f _ in ()
09:09:57 <lambdabot>  Found hole ‘_’ with type: Data.Either.Either a (a -> b)
09:09:58 <lambdabot>  Where: ‘a’ is a rigid type variable bound by
09:09:58 <lambdabot>             the type signature for
09:09:58 <lambdabot>               foo :: (Data.Either.Either a (a -> b) -> b) -> b
09:09:58 <lambdabot>             at <interactive>:1:12
09:10:02 <jle`> they should work in ghci
09:10:26 <jle`> > let foo :: ((Either a (a -> b)) -> b) -> b; foo f = f (Right _) in ()
09:10:27 <lambdabot>  Found hole ‘_’ with type: a -> b
09:10:28 <lambdabot>  Where: ‘a’ is a rigid type variable bound by
09:10:28 <lambdabot>             the type signature for
09:10:28 <lambdabot>               foo :: (Data.Either.Either a (a -> b) -> b) -> b
09:10:28 <lambdabot>             at <interactive>:1:12
09:11:02 <jle`> > let foo :: ((Either a (a -> b)) -> b) -> b; foo f = f (Right (_ . Left)) in ()
09:11:03 <lambdabot>  Found hole ‘_’ with type: Data.Either.Either a b0 -> b
09:11:03 <lambdabot>  Where: ‘a’ is a rigid type variable bound by
09:11:03 <lambdabot>             the type signature for
09:11:03 <lambdabot>               foo :: (Data.Either.Either a (a -> b) -> b) -> b
09:11:03 <lambdabot>             at <interactive>:1:12
09:11:10 <jle`> > let foo :: ((Either a (a -> b)) -> b) -> b; foo f = f (Right (f . Left)) in ()
09:11:11 <lambdabot>  ()
09:11:24 <dfdsfsdf> shapr: there's a video on programming with holes, but it doesn't cover the extension iirc http://matthew.brecknell.net/post/hole-driven-haskell/
09:11:26 <pqmodn> in ghci, (3 + _) :: Int , says "Pattern syntax invalid in expression context: _", but ghc interprets it as a typed hole
09:11:28 <jle`> hm that was supposed to be a convincing usage of typed holes but i think it didn't turn out like i expected
09:11:31 <kk_> hello
09:11:38 <jle`> pqmodn: what version are you using?
09:11:43 <pqmodn> 7.8.3
09:12:10 <pqmodn> i also tried ghci -fwarn-typed-holes, just in case it wasn't enabled by default in ghci
09:12:27 <kk_> How would I load a haskell file on startup? adding ":l file.hs" in ghci.conf doesn't seem to work
09:12:46 <vlatkoB> Is there a function "flip' a b = b a" defined somewhere?
09:12:54 <Iceland_jack> @src flip
09:12:54 <lambdabot> flip f x y = f y x
09:13:00 <sagittarian> which is better, a >>> b >>> c or c . b . a?
09:13:12 <sagittarian> i mean in an absolute sense, of course
09:13:24 <jle`> sagittarian: it depends on the context, in general, i would prefer c . b . a
09:13:25 <pqmodn> :t let (\a b -> b a)
09:13:26 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
09:13:32 <pqmodn> :t (\a b -> b a)
09:13:33 <lambdabot> t1 -> (t1 -> t) -> t
09:13:35 <Iceland_jack> @pl \a b -> b a
09:13:35 <lambdabot> flip id
09:13:39 <pqmodn> :t flip ($)
09:13:40 <lambdabot> b -> (b -> c) -> c
09:13:46 <Iceland_jack>     flip id = flip ($)
09:13:50 <vlatkoB> flip is flipping args to function. This one is just swapping it's arguments (and b is function)
09:14:00 <pqmodn> yeah, flip id or flip ($) is what you want
09:14:16 <Iceland_jack> there are also some places that define special operators for flip ($)
09:14:28 <jle`> (&) will be in base in 7.10
09:14:28 <Iceland_jack>     (&), (|>), or something
09:14:32 <vlatkoB> Iceland_jack: I' looking to avoid lambda.
09:14:37 <jle`> in Data.Function
09:14:48 <jle`> > 5 & show
09:14:50 <lambdabot>  "5"
09:14:50 <kk_> How can I execute a haskell file on startup of ghci? adding ":l file.hs" in ghci.conf doesn't work
09:14:56 <Iceland_jack> vlatkoB: 'flip id' works for that, but you shouldn't
09:15:20 <Iceland_jack> or (&) like was mentioned
09:15:25 <vlatkoB> Iceland_jack: Why not?
09:15:35 <jle`> kk_: is file.hs in the folder you are running ghci in?
09:15:43 <jle`> what does "doesn't work" mean?
09:15:49 <jle`> do you get an error message?
09:15:55 <kk_> nothing happens, no error message
09:15:58 <Iceland_jack> There is nothing wrong with lambdas, and 'flip id/($)' is horrid
09:16:09 <kk_> I added absoulte path
09:16:33 <jle`> > (&) 5 show
09:16:35 <lambdabot>  "5"
09:17:30 <pqmodn> > ($) flip ($) 4 succ
09:17:31 <lambdabot>  5
09:18:58 <jle`> > ($) ($) ($) ($) flip ($) 4 succ
09:18:59 <lambdabot>  5
09:19:40 <vlatkoB> jle`: & is not in Data.Function
09:19:48 <jle`> it will be in 7.10
09:20:02 <ij> It originated in lens?
09:20:52 <jle`> the origins of flip ($) predate lens, but i think calling it (&) was probably popularized by lens if not started by it
09:21:10 <jle`> diagrams has (#)
09:21:35 <jle`> (&) sorta makes sense when you chain it, 'do this and that and that'.
09:21:48 <jle`> > 5 & succ & (*2) & show
09:21:49 <lambdabot>  "12"
09:22:09 <jle`> meh i am not a fan still.  i will almost always prefer function composition and application in the correct order
09:22:30 <jle`> :)
09:22:45 <ij> Does it matter really?
09:22:46 <jle`> except maybe in the case of reasoning with monadic effects
09:23:05 <jle`> i think consistent style and readability are important
09:23:30 <jle`> it probably doesn't matter that much but i have chosen this particular issue as my personal pet just for fun :)
09:24:25 <shapr> dfdsfsdf: thanks for the link
09:24:30 <augustss> yo
09:24:59 <dfdsfsdf> np
09:27:40 <augustss> so quiet
09:27:50 <dfdsfsdf> augustss: wait, i have a question
09:28:37 <augustss> ok
09:29:03 <dfdsfsdf> augustss: I've been recently reading your "simpler easier" blog post describing three evaluators.  but it still looks too complex.  are you aware of simple examples describing various evaluation strategies?
09:29:50 <augustss> Hmmm
09:29:59 <ReinH> augustss: o/
09:30:54 <augustss> dfdsfsdf: What is it you think is complex?  Even the evaluator for the untyped lambda calculus?
09:31:13 <dfdsfsdf> right
09:31:22 <dfdsfsdf> the evaluator is the problem
09:32:03 <augustss> Well, there are many ways to write the evaluator.  I decided for the one that I think has the least "trickery" in it; just substitution.
09:32:10 <augustss> But substitution is hard.
09:32:12 <vanila> there's a cool trick called NBE
09:32:24 <vanila> http://strictlypositive.org/Easy.pdf covers it
09:32:28 <augustss> You can use HOAS if you want to cheat.
09:32:42 <ReinH> augustss: or that cool knot tying trick
09:32:48 <vanila> it's only cheating if you get caught
09:32:56 <vanila> :P
09:33:33 <augustss> dfdsfsdf: You can read this for a few variations http://www.cs.uu.nl/wiki/pub/USCS/InterestingPapers/AugustsonLambdaCalculus.pdf
09:33:52 <dfdsfsdf> augustss: Will do! Thanks for the tips.
09:34:06 <augustss> It has the same evaluator, and 3 others.
09:34:16 <eriksensei> hm, reading this makes me wonder whether (&) is like F#'s |> operator?
09:34:23 <johnw> augustss: lennart is that you?
09:34:27 <merijn> eriksensei: It is
09:34:30 <augustss> It is I.
09:34:34 <merijn> johnw: Yes
09:34:35 <johnw> hello!  good to see you on IRC
09:34:48 <augustss> But who are you? :)
09:34:53 <johnw> John Wiegley
09:35:05 <johnw> just saw you a few days ago :)
09:35:20 <augustss> Me and 474 other people.
09:35:33 <johnw> yeah, I figure by the 8th ICFP, people should start to remember who I am
09:35:48 <eriksensei> merijn: ah, just started looking at F# a bit, so good to know.
09:36:10 <syllogismos> what does ! mean in function definition? I'm looking at some haskell code and came across this.
09:36:17 <merijn> augustss: A bit late perhaps, but is there a writeup of the haskell history along the lines of your IFL keynote last year somewhere?
09:36:29 <augustss> syllogismos: It marks an argument as strict.
09:36:32 <merijn> syllogismos: Bang pattern, forces an argument to be strictly evaluated
09:36:51 <syllogismos> ohh..
09:36:56 <augustss> merijn: How about the HoPL paper?
09:37:06 <eriksensei> are there any haskell libraries that define |> in the F# sense? any commonly used ones? hoogle suggests there aren't http://www.haskell.org/hoogle/?hoogle=%7C%3E
09:37:27 <merijn> eriksensei: I doubt it
09:37:28 <dfdsfsdf> eriksensei: what's |> in F#?
09:37:31 <johnw> LYAH uses that notation, IIRC, so you could just define it yourself
09:37:44 <merijn> dfdsfsdf: Reverse function application
09:37:52 <augustss> Isn't |> just flip ($) ?
09:37:54 <merijn> dfdsfsdf: (|>) :: a -> (a -> b) -> b
09:37:58 <merijn> augustss: Yes
09:38:20 <merijn> augustss: ha, I didn't even know HoPL was a thing :) I'll check it out
09:38:21 <augustss> merijn: http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/history.pdf
09:38:57 <augustss> It's a great (but, of course, incomplete) paper.
09:39:19 <eriksensei> johnw: i could, but i just read that (&) is quite common in Haskell, so it might make more sense just to go with that then
09:39:36 <augustss> Lens uses (&)
09:39:50 <Gonzih> eriksensei & is from lense package
09:39:52 <augustss> Personally, I've never used it.
09:39:55 <eriksensei> right, so that would make it more or less common, I guess?
09:39:57 <johnw> eriksensei: fortunately they are all just functions, so you can pick whichever you like
09:40:21 <johnw> i tend to just use flip
09:40:32 <dreams> augustss, are you implying that instantiation is trickier to implement than the G-Machine?
09:40:35 <eriksensei> johnw: i am reminded of a certain xkcd strip ;)
09:41:01 <augustss> dreams: Did I say anything to imply that?
09:41:07 <dfdsfsdf> struggling with the CPS. any help? http://dpaste.com/307N1SX.txt
09:41:07 <eriksensei> yeah, flip is clear, but somehow i find ik sort of jarring to read
09:41:58 <dreams> augustss, eh, nevermind I misread your statement.
09:42:27 <johnw> dfdsfsdf: in your case, isn't the "last step" always just "id'?
09:42:49 <johnw> i'm not sure what your question is though
09:44:18 <dfdsfsdf> johnw: "how do I evaluate it further?" Will print "substitute" xk?
09:44:35 <vanila> pythagoras x y = add (square x) (square y)  gets transformed into   pythagoras' x y k = squarek x $ \x' -> squarek y $ \y' -> addk x' y' k
09:44:38 <ReinH> johnw: hi!
09:44:44 <johnw> ReinH: hi!
09:44:49 <johnw> dfdsfsdf: I still don't know what you mean
09:45:06 <merijn> dfdsfsdf: Well if you want the Int that results from pythagorasCPS you need to get it out by passing in id
09:45:21 <ReinH> I'm going to ICFP next year!
09:45:24 <ReinH> Sad I missed this one
09:45:34 <merijn> ReinH: Pfft, now I'm jealous!
09:45:34 <johnw> cool, next year isn't so far from you
09:45:40 <ReinH> i know!
09:45:47 <vanila> dfdsfsdf, is that useful
09:45:52 <ReinH> merijn: :) btw I'll be in the bay area a lot now, we can try dinner again
09:46:23 <merijn> ReinH: Good, I'll be here for a while :)
09:46:42 <ReinH> :D
09:47:45 <monochrom> dfdsfsdf: pythagorasCPS 2 3 print = squareCPS 2 $ ... etc. There is no longer \print.
09:49:04 <dfdsfsdf> monochrom: okay, will that result in \xk -> xk 4 $ \xSqrd -> \yk -> yk 9 $ \ySqrd -> \addk -> addk (xSqrd + ySqrd)?
09:49:05 <monochrom> And (\xk -> xk (square 2)) (\xSqrd -> stuff) = (\xSqrd -> stuff) (square 2).  You've got to perform function applications.
09:50:06 <monochrom> I'm wondering whether $ makes it harder or easier to see what you should do.
09:50:35 <dfdsfsdf> monochrom: So does \xk -> xk 4 $ \xSqrd -> ... become (\xSqrd -> ... 4)?
09:50:45 <monochrom> no
09:50:55 <monochrom> (\xSqrd -> ...) 4
09:51:04 <vanila> dfdsfsdf,  http://lpaste.net/110799
09:52:43 <dfdsfsdf> vanila: thank you
09:53:16 <dfdsfsdf> vanila: squareCPS 2 is bound to xSqrd, then evaluated, right?
09:53:29 <monochrom> no, square 2 is
09:53:36 <vanila> squareCPS 2 k   computes hte square of 2 and throws that result into the continuation k
09:55:03 <dfdsfsdf> vanila: is there a simpler example?  I understand map ($ 2) [(1*), (2*)], but it doesn't help me here.
09:55:14 <vanila> simpler example of what?
09:55:24 <dfdsfsdf> of CPS
09:55:38 <vanila> This is a good simple example, which part isn't clear?
09:55:48 <kludgy> Question: If I have a 'newtype T a' (T :: * -> *) with an 'instance Foldable T', and I wish to wrap this in another newtype 'S = T SomeType' (S :: *), how do I derive the moral equivalent to 'instance Foldable S'?
09:55:49 <vanila> you correctly CPS transfomred it
09:56:04 <vanila> and the execution of the CPS transformed code is just the same as execution of normal haskell code
09:56:31 <kludgy> Apologies a typo: 'S = S (T SomeType)' (S :: *)
09:57:01 <merijn> kludgy: GeneralizedNewtypeDeriving and "deriving (Foldable)"? Or did that not work?
09:57:02 <dfdsfsdf> vanila: you mean the initial '\print -> \xk ... $ print' paste?
09:57:14 <vanila> no
09:57:29 <dfdsfsdf> then when did I correctly transform it?
09:57:34 <merijn> kludgy: Wait, no
09:57:34 <kludgy> merijn: Haven't tried it yet. :) will do..
09:57:51 <merijn> kludgy: What you type is not well-kinded
09:58:00 <merijn> kludgy: S has kind *
09:58:02 <kludgy> merijn: Yea, the compiler agrees :D
09:58:07 <merijn> kludgy: Therefore it can't be Foldable
09:58:21 <milos_co1agen> hi haskellers! i was reading okasaki's rb-tree functional pearl, and in writing out the code from the paper here: https://github.com/marsmining/learn-hs/blob/master/src/OkasakiRB.hs i'm getting warning in a few functions about non-exhaustive, like eg: ".. for ‘member’: Patterns not matched: _ (T _ _ _ _)". Any Ideas?
09:58:26 <vanila> The definition of pythagorasCPS is correct CPS form of pythagoras
09:58:38 <kludgy> merijn: But you get my intent.. I guess this is one of those cases where type classes do not compose through type constructors?
09:58:42 <vanila> the \print stuff is confusing and I think it's wrong
09:59:12 <dfdsfsdf> vanila: the definition is not mine, I wrote the wrong part
09:59:18 <kludgy> merijn: My current concession is to define a new typeclass to make the instance well-kinded
09:59:28 <merijn> kludgy: It has nothing to do with compose through type constructors, Foldable requires something of kind "* -> *" because you have "Foldable f => f a -> [a]"
09:59:39 <merijn> kludgy: What would the type of that be for S?
09:59:51 <Twey> kludgy: You'd need https://hackage.haskell.org/package/mono-foldable-0.1.0.2/docs/Data-Foldable-Mono.html or something
09:59:54 <lpaste> monochrom annotated “No title” with “zoom in a step” at http://lpaste.net/110799#a110800
09:59:55 <merijn> "S -> ??"
10:00:03 <dfdsfsdf> vanila: I think I'll try to follow the types again.
10:00:04 <vanila> dfdsfsdf, well here: f (g x) would be CPS transformed into  g x $ \y -> f y $ halt
10:00:11 <vanila> you can ignore the types completely
10:00:19 <dfdsfsdf> oh
10:00:19 <kludgy> merijn: Yup I understand. Just looking for a moral equiv
10:00:20 <monochrom> dfdsfsdf: http://lpaste.net/110799#a110800
10:00:43 * hackagebot up 0.1.0.2 - Generates pathnames to up directories  http://hackage.haskell.org/package/up-0.1.0.2 (ThomasEding)
10:01:00 <dfdsfsdf> monochrom: thanks, I'll need some time to digest it.
10:01:08 <kludgy> merijn: Thanks.. looking at MFoldable now
10:01:08 <vanila> Because in strict lambda calculus: f (g x) means:  compute g x and call f with the result
10:01:20 <dfdsfsdf> vanila: I understand.
10:02:00 <vanila> similarly, add (square x) (square y) it's compute square x, compute square y add them: so we get pythagoras' x y k = squarek x $ \x' -> squarek y $ \y' -> addk x' y' k
10:02:43 <dfdsfsdf> vanila: what's the definition of squarek here?
10:03:09 <dfdsfsdf> \k -> k (square x)?
10:03:18 <vanila> just imagine that squarek is primitive
10:03:18 <merijn> kludgy: What's wrong with just a function instead of a typeclass?
10:03:26 <vanila> we can't implement squarek in CPS form
10:03:51 <vanila> because it uses a primitive * that we don't have the CPS version of
10:03:53 <merijn> kludgy: Like "sToList (S x) = toList x"?
10:03:57 <simpson> Rerelearning how to do networking in Haskell. The right way to read from a socket if I would like to not block my current computation is to spin off an async (with Async, probably) and then collect the read when it's ready, right?
10:04:23 <merijn> simpson: Sure
10:04:55 <monochrom> vanila: if squareCPS were given as a primitive, you could just describe it as "give 4 to the continuation". but squareCPS is given as a lambda term, so it's important to show how reducing the lambda term does what you said.
10:05:34 <vanila> hmm I don't agree monochrom
10:05:41 <dfdsfsdf> vanila: does squarek compute the square, then throw the result into the lambda?
10:05:44 * hackagebot Agda 2.4.2 - A dependently typed functional programming language and proof assistant  http://hackage.haskell.org/package/Agda-2.4.2 (AndreasAbel)
10:05:47 <vanila> dfdsfsdf, yes
10:06:04 <monochrom> fine
10:07:27 <dfdsfsdf> vanila: it looks like the >>= chain
10:08:23 <Twey> dfdsfsdf: There's a pretty good reason for that…
10:09:09 <kludgy> merijn: Perhaps. Except I am auto-generating hundreds of types of bounded sequences for interop with an external service.
10:09:40 <dfdsfsdf> why does CPS may boost performance in some cases?
10:10:07 <kludgy> merijn: Just looking to leverage common properties as much as possible.. open to better options.
10:10:11 <merijn> Because "tail call all the things!"
10:11:04 <dfdsfsdf> merijn: so, it may be used to define a tail recursive version of a function, right?
10:11:19 <vanila> in CPS form all calls are tail calls
10:11:28 <vanila> this doesn't change the execution behavior of a program
10:12:19 <vanila> I should be clear: I'm talking about a language like scheme
10:12:34 <vanila> in haskell (lazy) you specify an evaluation order when you CPS it
10:14:04 <dfdsfsdf> vanila: would it be benefitial in, say, python?
10:14:18 <dfdsfsdf> I'm talking about tail recursion.
10:14:25 <vanila> no
10:14:50 <vanila> it doesn't change anything raelly
10:15:24 <vanila> CPS transform is a good way to implement tail call optimization
10:15:35 <vanila> but if you take python code and CPS it you still have python code
10:15:42 <vanila> so it's not going to be efficient
10:16:41 <dfdsfsdf> so, is it all about the recursive process vs. iterative process, as in sicp?
10:16:53 <dfdsfsdf> the goal is not to build a huge stack, right?
10:16:56 <vanila> yes
10:16:58 <vanila> exactly
10:17:02 <dfdsfsdf> finally
10:17:40 <vanila> dfdsfsdf, a tail recursive function in scheme would be able to avoid building up a large stack thanks to tail call optimization
10:17:43 <merijn> Except that in haskell stack growth is not-related to tail calling or not :)
10:17:48 <Guest75821> somefn :: !a -> a
10:17:50 <vanila> merijn++
10:17:51 <dfdsfsdf> and the point of writing pythagorasCPS is to make it tail recursive since the original definition is not, correct?
10:17:56 <vanila> that's a very good point
10:17:56 <merijn> Because haskell doesn't use a stack for function calls
10:18:03 <vanila> dfdsfsdf, no
10:18:16 <vanila> dfdsfsdf, a non tail recursive function would still demand the same amount of memory, even if you CPS transform it
10:18:23 <Guest75821> is it possible in haskell
10:18:36 <Guest75821> I mean complement of type?
10:19:07 <merijn> Guest75821: Depending on how many extensions you wanna use the answer is either "no" or "a little bit"
10:19:23 <merijn> Guest75821: See https://gist.github.com/merijn/6130082
10:19:39 <dfdsfsdf> vanila: I'm not following.  This statement seems to contradict the previous "all CPS functions are tail recursive".
10:19:52 <pqmodn> dfdsfsdf: someone has to eliminate the tail calls
10:19:56 <vanila> dfdsfsdf, I could create an example to show you
10:20:13 <vanila> if you like
10:20:17 <dfdsfsdf> vanila: yes, please
10:20:49 <pqmodn> dfdsfsdf: tail calls without tail call optimization (elimination) will still result in a growing stack
10:21:09 <dfdsfsdf> merijn: Re stack: are you trying to say there's no need to care about tail recursion in haskell?
10:21:16 <dfdsfsdf> pqmodn: ok
10:21:18 <kludgy> merijn: Good lead on MFoldable thanks.. package is deprecated in favor of mono-traversable, so I'll use that.
10:22:14 <merijn> dfdsfsdf: There is *some* need, because lack of tail calls can result in space leaks due to thunks
10:22:26 <merijn> dfdsfsdf: But unlike strict language tail cals are not always necessary
10:22:53 <merijn> dfdsfsdf: Imagine "map f (x:xs) = f x : map f xs" this has terrible (i.e. linear) space complexity in a strict language, but is O(1) in haskell
10:24:11 <vanila> dfdsfsdf,  http://lpaste.net/110801
10:24:20 <simpson> IIUC it still has O(n) space requirements because its caller may choose to keep the entire list alive.
10:24:24 <vanila> f is not tail recursion and builds up a lot of stack
10:24:27 <dmj`> merijn: only in the case xs is [] right?
10:24:32 <vanila> g uses an accumulator and doesn't build up any stack
10:24:41 <vanila> we convert them both to CPS form f* and g*
10:24:58 <vanila> now neither builds up lots of stack because all calls are tail calls
10:25:00 <pqmodn> because it uses guarded recursion, only one step is evaluated, not the recursive call to map?
10:25:23 <vanila> but notice they still take the same memory? That is because f* builds up a bigger and bigger continuation
10:26:00 <vanila> so CPS transform doesn't optimize anything
10:26:14 <vanila> but it puts the program into a format which makes it very easy to do tail call optimization
10:26:18 <dmj`> merijn: oh misread, you said space complexity
10:26:25 <pqmodn> dmj`: i did the same thing :-)
10:26:30 <dfdsfsdf> merijn: is it possible to make map O(1) in other language?
10:26:32 <dmj`> pqmodn: :)
10:26:52 <Guest75821> merijn: sure, we can restrict some types, nice gist. But restricting something like !TYPE is not possible right?
10:27:04 <osfameron> dfdsfsdf: I think that's an implementation detail.  Should be trivial on a quantum computer
10:27:15 <osfameron> dfdsfsdf: you simply run the calculation in multiple parallel universes, in constant time
10:27:16 <johnw> vanila: CPS can elide intermediate data structures in strict languages also
10:27:18 <Sorella> dfdsfsdf: in time complexity or space complexity?
10:27:19 <dfdsfsdf> I don't have one
10:27:42 <dfdsfsdf> space
10:27:49 <Twey> kludgy: You're welcome.  ;þ
10:28:12 <dfdsfsdf> Sorella: do I just need to define it as an iterative process?
10:29:13 <dfdsfsdf> Sorella: I'm referring to https://mitpress.mit.edu/sicp/full-text/sicp/book/node15.html
10:31:03 <dfdsfsdf> vanila: can you repaste it to dpaste?
10:31:09 <dfdsfsdf> lpaste doesn't respond
10:31:12 <vanila> sure
10:31:30 <vanila> http://dpaste.com/3B15GFY
10:31:54 <vanila> johnw, like fold fusion?
10:32:02 <hnoob> if I type ":list []" it says "cannot list source code for []: module GHC.Types is not interpreted".  Is there a way to set up ghci to browse such non-interpreted code?
10:34:37 <dfdsfsdf> hnoob: you could try :i [] to get the defn of []
10:37:10 <hnoob> yep, that's helpful but I'm also interested in looking at the implementation.
10:37:40 <johnw> vanila: more than no intermediate structure is even necessary; you can call the continuation for each "element", and then aggregate the results, aka foldr
10:38:20 <vanila> johnw, oh yes multiple values! that's a really cool thing
10:38:27 <vanila> thanks for bringin that up
10:40:57 <trap_exit> what exactly is it about C
10:41:01 <trap_exit> that makes C a bad target for ghc?
10:41:33 <trap_exit> I should rephrase it about that. What does ASM have over C that makes ASM a better target than C for GHC ?
10:42:06 <vanila> trap_exit, I think that compilers prefer asm because C requires you to be so so careful about not breaking "the standard"
10:42:21 <vanila> and this prohibits you from managing a lot of things by hand that you need to do
10:42:34 <xplat> trap_exit: what ASM has over C is LLVM?
10:42:46 <geekosaur> not by default
10:43:26 <geekosaur> what asm has over C is, in part, that you must either disable optimization and generate "hand-optimized" C code, or let the C compiler do optimizations that are actually pessimizations *for Haskell*
10:44:03 <geekosaur> and if you're generating hand-optimized C, you might as well be writing in assembler anyway
10:44:05 <xplat> well, also with ASM you don't have to compile C and then mangle the ASM with perl to place code next to tables or whatever it is the evil mangler does
10:44:24 <trap_exit> noted
10:44:31 <merijn> trap_exit: C breaks the overhead of functional calls and call stacks
10:44:32 <trap_exit> so it's not that GHC hates C
10:44:33 <hnoob> you have to drop down to asm to get special features like SIMD
10:44:36 <trap_exit> it's that GHC hates all C compilers
10:44:45 <Cale> Yeah, GHC used to compile via C, but it had to mangle the assembly output anyway.
10:44:48 <merijn> s/breaks/brings
10:44:59 <capisce> hnoob: hmm?
10:45:42 <trap_exit> merijn: noted
10:45:44 <vanila> dfdsfsdf, was my writing clear?
10:45:50 * hackagebot keystore 0.5.1.1 - Managing stores of secret things  http://hackage.haskell.org/package/keystore-0.5.1.1 (ChrisDornan)
10:46:26 <xplat> hackagebot: but can it manage a bazaar of secret things?
10:46:34 <johnw> i would have call it treasure-room
10:46:44 <johnw> and put a dragon there to guard it
10:50:26 <monochrom> no, C hates GHC.
10:50:41 <johnw> maybe because it was made to be the last letter?
10:50:50 <monochrom> I don't understand why people try to look at the world C-centric.
10:51:15 <monochrom> C hates Prolog too, for that matter.
10:51:19 <alorente> Is there a way to specify multiple hackage mirrors to fall back to on connection errors? (for a CI system)
10:51:24 <joshc> window 19
10:51:25 <merijn> monochrom: C hates everything :)
10:51:28 <joshc> ...
10:51:29 <monochrom> yes
10:51:40 <merijn> Especially me >.>
10:53:54 <yitz> merijn: C loves segfaults
10:55:41 <yitz> alorente: it would have be done in the CI system or as an external script. cabal has no built-in provision for fallback hackage servers, unless it was added recently.
10:55:44 <monochrom> anthropomorphizing aside, C's only close-to-hardware aspect is exposing data layout. It certainly is not close-to-hardware in terms of control flow, stack, registers.
10:55:52 <merijn> yitz: I wish
10:55:56 <alorente> yitz: rats. Ok, thanks
10:56:03 <merijn> yitz: C loves silently deadlocking and not telling me what's up
10:56:19 <vanila> it should be time to replace C with a better language
10:56:28 <merijn> yitz: I'm pretty sure cabal does
10:56:32 <krishnan_p> Would this channel be an appropriate place to ask questions regarding pipes library? I am a beginner-to-intermediate haskell programmer.
10:56:32 <yitz> alorente: it's not too hard for a script to modify the cabal.config file to change the hackage server, though.
10:56:35 <vanila> (lower level language)
10:56:36 <merijn> yitz: You can specify servers in your config
10:56:45 <merijn> yitz: Or can you only have one server entry?
10:56:47 <vanila> krishnan_p, yes, but i dont know about it
10:57:15 <monochrom> but every non-C compiler exactly needs to access control flow, stack, registers. therefore, every non-C compiler cannot use C meaningfully.
10:57:27 <yitz> merijn: last i looked, multiple servers was an "all" relationship - it tried all of the specified servers, and would fail if any is not working
10:57:44 <monochrom> to wit, you don't usually translate Java to C either.
10:57:55 <monochrom> and you don't translate Scala to C, etc etc
10:58:13 <yitz> merijn: the use for that (which i have used) if you have a local hackage server for your own unpublished packages, and you want cabal to look at both those and the public hackage.
10:58:18 <krishnan_p> OK. I am trying to use pipes to emulate 'cut -d "  " -f 2' in bash. For some reason my pipes code 'processes' only one line. Anybody who can help?
10:58:23 <vanila> I've been trying to compile scheme to C, but failing
10:58:34 <yitz> merijn: heh. yeah, that's worse.
10:58:49 <alpounet> krishnan_p: paste the code on lpaste.net so that people can look into it
10:59:25 <monochrom> I think gcj doesn't translate Java to C either, is that right? It translates Java to some IR that gcc uses.
11:00:02 <Enigmagic> GIMPL or whatever it is probably
11:00:18 <monochrom> also, I can simplify "control flow, stack, registers" to "registers" :)
11:00:42 <cschneid> what's that paper that went over an implementation of bonds / contracts?
11:00:53 <edlinde> do you guys think the Applicatives section in LYAH is good?
11:01:05 <monochrom> does googling "haskell financial" help?
11:01:17 <monochrom> I guess not
11:01:22 <cschneid> there it is!
11:01:24 <cschneid> http://research.microsoft.com/en-us/um/people/simonpj/Papers/financial-contracts/contracts-icfp.htm
11:01:32 <cschneid> didn't come up with the word "contract" until I asked
11:01:41 <monochrom> "haskell contract" works better
11:02:16 <yitz> @google haskell contract
11:02:17 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/verify/
11:02:17 <lambdabot> Title: Static contract checking for Haskell
11:02:37 <monochrom> that may be the design-by-contract kind of contract
11:02:43 <yitz> @google haskell financial contract
11:02:44 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/Papers/financial-contracts/contracts-icfp.htm
11:02:44 <lambdabot> Title: Simon Peyton Jones: papers
11:02:55 <krishnan_p> So, here is my pipes based program and the sample input in comments - http://lpaste.net/110802
11:04:10 <nyuszika7h> is there an equivalent of ** for integers?
11:04:43 <dtz1> sd123
11:04:45 <nyuszika7h> I want an integer result
11:05:10 <nyuszika7h> oh, I could use floor
11:05:26 <monochrom> there are ^, ^^, and **
11:05:28 <yitz> krishnan_p: looks like you never divided the input into lines. so it treats the whole thing as one big line.
11:06:26 <nyuszika7h> ah, ^
11:06:57 <krishnan_p> yitz, hmm. I thought nesting the for would naturally divide the input into lines.
11:07:48 <krishnan_p> yitz, so does it mean that 'for' yields the entire file content as one 'item'?
11:08:04 <yitz> krishnan_p: look at the documentation in Pipes.Tutorial. There are examples of line-by-line processing.
11:11:11 <hexagoxel> krishnan_p: afaik, "for" has nothing to do with this. look at "fromHandle" doc: "Convert a Handle into a byte stream using a default chunk size"
11:13:32 <krishnan_p> hexagoxel, OK. I implemented my pipeline having getLine based examples from pipes-tutorial and replaced that with reading from file handle. Somewhere I have messed things up. thanks
11:14:16 <hexagoxel> (default chunk size is ~32k)
11:15:18 <krishnan_p> hexagoxel, Ideally I need chunking to happen at line boundaries. I dont think it is possible to do that. I must be using the wrong abstraction here.
11:17:06 <Squid_Tamer> Is there a good way to parse non-strings in a similar manner to Parsec? I need to parse weird things like lists of Integers.
11:17:48 <hexagoxel> krishnan_p: look at doc of Pipes.ByteString.lines, maybe? they suggest pipes-text
11:18:21 <merijn> I would be suspicious of your need to do chunking at line boundaries
11:18:29 <merijn> Why do you think you need that?
11:18:31 <kadoban> Squid_Tamer: You can use parsec for arbitrary things like that, but it wasn't the easiest thing in the world when I did it
11:18:52 <krishnan_p> hexagoxel, OK. Thanks for the help. Looks like I need to go back to the tutorial
11:19:03 <Squid_Tamer> kdoban: Thanks, I'll dig deeper into parsec
11:19:13 <Squid_Tamer> I mean kadoban.
11:19:35 <kadoban> (It wasn't terribly hard, but it wasn't documented very well, and I'm marginal at haskell). Sure, I think the thing to look for, off the top of my head, is creating your own "Stream" type or whatever they call it.
11:21:10 <krishnan_p> merijn, I shouldn't be needing it. if magically fromHandle chunked at line boundaries my program would have worked. But it doesn't and isn't expected to. I didn't read its doc carefully, my bad.
11:23:46 <DonManley_> Hi guys. Does anybody know whether it's possible to use the standart library in Fay? E.g. I tried importing "Data.List" but Fay just told me that it coudn't find the module. I'm a haskell noob, so sorry for if the question is stupid
11:26:08 <krishnan_p> hexagoxel, using Pipes.ByteString.lines would mean I need to understand lens and FreeT. Is there an alternative?
11:27:40 <Twey> krishnan_p: What for?
11:28:54 <Twey> Squid_Tamer: Parsec is parameterized over a ‘token’ type, so you can change that and use it on Ints and so on.  But some of the combinators are only defined for Char.
11:30:19 <monochrom> Squid_Tamer: see my http://www.vex.net/~trebla/haskell/parsec-generally.xhtml#token
11:30:56 * hackagebot clckwrks-plugin-page 0.3.6 - support for CMS/Blogging in clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-page-0.3.6 (JeremyShaw)
11:30:57 <krishnan_p> Twey, I am trying to emulate 'cut -d"  " -f 2 <file-name>' behaviour using pipes libraries.
11:31:09 <hexagoxel> krishnan_p: i don't know. maybe merijn can help
11:31:30 <matt1> i'm new to haskell and I'm trying to parse some json with the aeson library. I can't figure out some type stuff can anyone help?
11:31:40 <ernst> can I tell cabal to use a specific c-compiler? setting the CC environment variable didnt seem to have any effect
11:31:41 <hexagoxel> if you keep it close to the tutorial, you could use hGetLine (instead of getLine)
11:31:44 <matt1> here's the a link to the code, with comments
11:31:48 <krishnan_p> Twey, I would like to split the contents of a file into lines for this
11:31:49 <matt1> https://gist.github.com/mr/8d036a19a7c09824d015
11:32:01 <Twey> krishnan_p: Sure, but where does lens come into it?
11:32:08 <krishnan_p> hexagoxel, OK. Let me try that
11:32:12 <matt1> the parseComment function is where I'm having trouble
11:32:21 <Twey> Oh, looks like it uses lens now.  Huh.
11:33:34 <krishnan_p> Twey, hexagoxel suggested that I could use Pipes.ByteString.lines which involves FreeT and some examples involving line-by-line processing in Pipes-ByteString uses lens
11:33:50 <matt1> i'll try to explain a little of what I'm trying to do
11:33:53 <krishnan_p> Twey, phew! For a minute I thought I had muddled everything in my head :)
11:35:07 <Twey> krishnan_p: Still, that's a way to go, I think.  You could also use machines.
11:35:10 <matt1> i'm trying to parse the file that's there into the 'Comment' object I defined above, but I can't figure out how to use values i got in a 'do' block in a statement of a different type
11:36:03 <Squid_Tamer> Twey and monochrom: Thanks for the token stuff. That looks like exactly what I'm looking for.
11:36:35 <Twey> krishnan_p: When trying to construct things with complex types like FreeT, typed holes are really nice (put _ in an expression context, and GHC(i) will give you an error telling you the type it expects in that context)
11:37:36 <Twey> krishnan_p: The only thing you need to know about lens here is that ‘view Pipes.Text.lines’ will give you a function with the type you want
11:37:43 <krishnan_p> Twey, I really want to learn one library well and build some day-to-day utilities and slowly improve my fluency in Haskell
11:38:59 <krishnan_p> Twey, could you give me an example of putting '_' in expression context? I am not sure I got it completely.
11:39:44 <monochrom> krishnan_p, write "x = not _" in a file, give it to GHC, note the error message
11:40:24 <Twey> > not _
11:40:25 <lambdabot>  Found hole ‘_’ with type: GHC.Types.Bool
11:40:31 <monochrom> more fun may be "y = _ False"
11:40:38 <Twey> > _ False
11:40:39 <lambdabot>  Found hole ‘_’ with type: GHC.Types.Bool -> t
11:40:39 <lambdabot>  Where: ‘t’ is a rigid type variable bound by
11:40:39 <lambdabot>             the inferred type of it :: t at Top level
11:41:05 <Twey> (that rigid type of ‘it’ thing bugs me — it's misleading)
11:41:18 <krishnan_p> Twey, what version of ghc should I be in?
11:41:22 <monochrom> 7.8
11:41:29 <Twey> krishnan_p: I think typed holes exist from 7.8
11:41:42 <Twey> You can also name your holes
11:41:48 <Twey> > _foo False
11:41:50 <lambdabot>  Found hole ‘_foo’ with type: GHC.Types.Bool -> t
11:41:50 <lambdabot>  Where: ‘t’ is a rigid type variable bound by
11:41:50 <lambdabot>             the inferred type of it :: t at Top level
11:42:10 <krishnan_p> Twey, it had to happen. I am on 7.4 :( Let me upgrade to 7.8. Probably tomorrow, its already midnight here.
11:42:18 <Twey> (which overlaps with identifier syntax, leading to some confusing errors…)
11:42:23 <Twey> krishnan_p: Ouch, 7.4?
11:42:52 <krishnan_p> Twey, monochrom thanks for the suggestions. I will try them out tomorrow.
11:42:59 <monochrom> you procrastinated twice :)
11:43:22 <Twey> krishnan_p: There's a nice explanation of the FreeT stuff here, by the way: http://hackage.haskell.org/package/pipes-group-1.0.1/docs/Pipes-Group-Tutorial.html
11:43:38 <krishnan_p> Twey, I will look at that. thakns
11:45:36 <krishnan_p> Twey, monochrom thanks, bye
11:46:20 <Twey> 'bye, krishnan_p!
12:06:02 * hackagebot conduit-connection 0.1.0.0 - Conduit source and sink for Network.Connection.  http://hackage.haskell.org/package/conduit-connection-0.1.0.0 (slomo)
12:16:27 <infandum> How can I divide giant integers? Whenever I try to divide huge number x by huge number y, I get NaN.
12:17:06 <dv-> :t div
12:17:06 <lambdabot> Integral a => a -> a -> a
12:17:09 <infandum> I don't care how accurate it is after, like, the accuracy of a double, I just want a non NaN answer
12:17:47 <infandum> dv-: That's integer division, right?
12:18:13 <infandum> dv-: I still need the decimal points, just it can cut off
12:19:27 <dv-> i guess you could div both sides to get them into double range and then use /
12:19:47 <infandum> hmmm
12:19:52 <infandum> let me see
12:20:49 <infandum> dv-: Nope, still says NaN
12:21:12 <srhb> I don't see why you would get NaN with huge numbers though. Surely it must be because you're dividing by zero?
12:21:12 <infandum> my example right now is (product [1..1000] / product [1..999])
12:21:20 <hexagoxel> dv-: Data.Ratio?
12:21:26 <monochrom> perhaps you should show an example. because I don't know how to get it.
12:21:45 <hexagoxel> especially with "Integral a => RealFrac (Ratio a)"
12:21:55 <monochrom> that probably exceeds even the capability of Double
12:22:14 <srhb> Ah, so you have Infinity as the denominator
12:22:19 <infandum> monochrom: It most certainly does, that's why I wonder if I could have a cut off
12:22:21 <infandum> like
12:22:24 <infandum> 10e1000
12:22:26 <infandum> or whatever
12:22:30 <infandum> accuracy
12:22:32 <srhb> infandum: You're not actually dividing integers though. Your products are Fractionals
12:22:40 <infandum> :t product
12:22:41 <lambdabot> Num a => [a] -> a
12:22:54 <srhb> :t (/)
12:22:55 <lambdabot> Fractional a => a -> a -> a
12:23:03 <infandum> yeah
12:23:10 <infandum> that's why I shouldn't use (/) most likely
12:23:19 <srhb> :i Fractional
12:23:26 <srhb> Oh, that's not possible I guess.
12:23:33 <monochrom> > maxBound :: Double
12:23:34 <lambdabot>  No instance for (GHC.Enum.Bounded GHC.Types.Double)
12:23:35 <lambdabot>    arising from a use of ‘GHC.Enum.maxBound’
12:23:39 <xplat> > fromRational (product [1..1000] % product [1..999]) :: Double
12:23:40 <lambdabot>  1000.0
12:24:03 <infandum> xplat: Now, is that integer division or actual division?
12:24:26 <infandum> fromRational (3 % 4) :: Double
12:24:30 <infandum> > fromRational (3 % 4) :: Double
12:24:32 <lambdabot>  0.75
12:24:34 <infandum> ha!
12:24:42 <infandum> that's promising!
12:24:46 <kludgy> Oh wow, how does one derive an instance of Control.Lens.Each.Each for a newtype? Really stuck finding a path from container type to IndexedLensLike..
12:24:47 <srhb> infandum: A different solution would be to use div and rem. :)
12:25:00 <dv-> hexagoxel: that's a more promising suggestion yeah
12:25:04 <infandum> > 3 `div` 4
12:25:05 <lambdabot>  0
12:25:06 <infandum> :(
12:25:11 <infandum> :t rem
12:25:12 <lambdabot> Integral a => a -> a -> a
12:25:18 <infandum> 3 `rem` 4
12:25:24 <infandum> > 3 `rem` 4
12:25:26 <lambdabot>  3
12:25:26 <infandum> bleh
12:25:38 <infandum> I think I'll go with the fromRational
12:25:41 <infandum> thank you all!
12:25:42 <srhb> Sure. :)
12:26:58 <hexagoxel> (ah, i messed up who originally asked the question :)
12:27:39 <xplat> kludgy: GeneralizedNewtypeDeriving?
12:28:15 <xplat> ah, i guess Reach has too many parameters
12:28:22 <xplat> er, Each
12:29:02 <kludgy> xplat: Yea not sure why it fails to auto-derive.. but IndexedLensLike is a beast.. looks like there may be layers on layers of instances to create first.
12:30:13 <xplat> kludgy: there's always #haskell-lens
12:30:26 <kludgy> xplat: cheers I'll ask there :)
12:36:02 <supki> kludgy: assuming you have  newtype T = T { unT :: X }  you should be able to define   each = iso unT T . each
12:56:01 <mthvedt> ok
12:56:09 <mthvedt> sorry wrong window
12:57:52 <albeit_> Are there built-in methods for "safe" maximum/minimum? Something like [a] -> Maybe a, so it works on empty lists?
12:58:36 <monochrom> no, not even in common libs
12:59:01 <monochrom> @type maximum
12:59:02 <lambdabot> Ord a => [a] -> a
12:59:19 <shachaf> Well, Data.Monoid has Max and Min
12:59:46 <shachaf> Wait, no it doesn't.
12:59:49 <shachaf> That's in lens. Never mind.
13:01:41 <joshkirklin> albeit_, you could use listToMaybe . sort as min
13:02:27 <albeit_> joshkirklin: True... just gonna write my own safeMaximum that uses maximum I think
13:02:38 <Iceland_jack> albeit_: What you should do depends on what you need it for
13:03:01 <Iceland_jack> Mainly where in the problem the "error" of an empty list should get handled
13:03:17 <Iceland_jack> A simple case expression may suffice
13:03:30 <albeit_> Iceland_jack: Well, if there is no maximum (empty list), that result is just thrown out... using in a mapMaybe
13:03:53 <kludgy> supki: Thanks for the tip. Will try iso!
13:04:39 <Iceland_jack> albeit_: So you're mapping over a lists of lists?
13:05:10 <albeit_> Iceland_jack: Basically, a  Map of lists
13:05:32 <Iceland_jack> Would something like this help:
13:05:33 <Iceland_jack> ghci> let xs = [ [1,2,3], [], [2,3,4,5] ]
13:05:33 <Iceland_jack> ghci> [ maximum (y:ys) | y:ys <- xs ]
13:05:33 <Iceland_jack> [3,5]
13:06:35 <joshkirklin> That's actually  a neat solution for that specific case
13:06:41 <joshkirklin> I don't use list comprehensions enough
13:07:14 <Iceland_jack> joshkirklin: I use them sparingly but if you need to discard based on pattern matching and use guards at the are quite nice
13:07:14 <albeit_> Iceland_jack: For lists of lists thats great, just gonna use a safeMaximum though
13:07:55 <TallerGhostWalt> for some reason, a program I have writes to a file, when I use it in the foreground but doesn't when I run it in the background
13:08:02 <Iceland_jack> Here's an example of local maxima
13:08:03 <Iceland_jack> > [ m | l:m:r:_ <- tails [1,2,3,4,3,10,3], l < m, m > r ]
13:08:04 <lambdabot>  [4,10]
13:08:52 <Iceland_jack> List comprehensions also become very powerful when you have pattern synonyms, something people should use more often together
13:10:29 <TallerGhostWalt> it is running in a wai server
13:10:33 <TallerGhostWalt> so weird
13:11:19 <joshkirklin> maybe it doesn't have permissions in the background?
13:11:51 <TallerGhostWalt> joshkirklin: could it have permissions to create a file, but not write it?
13:12:00 <TallerGhostWalt> joshkirklin: write to it I mean
13:12:34 <joshkirklin> I'm not sure. Doesn't creation imply writing? or by creating do you mean creating a handle or some such
13:14:17 <TallerGhostWalt> joshkirklin: I mean it creates a folder, then the file in the folder then nothing gets written.
13:14:24 <TallerGhostWalt> I am sure it is something dumb on my end
13:14:27 <TallerGhostWalt> unless it isn't
13:14:29 <TallerGhostWalt> lol
13:14:55 <joshkirklin> TallerGhostWalt, yeah, no idea really
13:16:56 <fizbin> So I had an odd problem with deploying haskell at work, and I thought that #haskell might find it amusing:
13:17:42 <fizbin> We use haskell to compile some stuff into a proprietary binary that's read and used by some programs written in C.
13:18:36 <fizbin> These programs run on multiple different platforms, and the developers writing the configuration that gets compiled into the proprietary binary work on multiple different platforms.
13:18:57 <fizbin> Getting all these people to install haskell wasn't going to happen.
13:19:49 <fizbin> And frankly, the idea of creating and maintaining both a MacOs and Windows binary of my haskell code (including getting a Windows VM on my Mac to compile with) was not a happy one.
13:20:23 <fizbin> The solution was obvious when it was pointed out to me, but I've been dreading doing the deployment for weeks.
13:20:56 <fizbin> The solution: make the haskell bit into a web service, and give the developers who need access to it a simple python client.
13:21:40 <fizbin> That's only been the basic lesson of the software world for the last _twenty years_. Don't know why it took so long to see it.
13:21:44 <monochrom> does this mean clients will talk to some server over the network?
13:22:00 <folsen> why python when they were going to use it in C programs?
13:22:09 <cite-reader> All problems can be solved by shuffling more bytes over the network, except the problem of too many bytes being shuffled over the network.
13:22:45 <monochrom> I am thinking of "invent your own bytecode format". which is another basic lesson of the last 20 years :)
13:22:51 <fizbin> Yeah, but the whole process of using this was going to require checking with the git servers anyway, so...
13:23:23 <monochrom> I see. no objection.
13:23:36 <Jello_Raptor> monochrom: i feel like that's started to get updated into "just use a subset of LLVM" (not a strict subset)
13:30:54 <makalu> if I want to benchmark the running time of a function, how do I measure time (I can't use criterion)?
13:31:22 <makalu> I used System.CPUTime but that's not really useful
13:31:54 <makalu> is there really no time measurement in base? Do I have to use the time package?
13:32:20 <shachaf> What's wrong with using a package that comes with ghc?
13:33:11 <makalu> which package comes with GHC? Time?
13:33:36 <shachaf> Yes.
13:33:45 <makalu> I wasn't aware of that
13:34:25 <kadoban> GHC kind of /is/ Haskell right now anyway, isn't it?
13:34:58 <tibbe> edwardk: do you know how to convert a conventional ast into a-normal form?
13:35:02 <tibbe> edwardk: is there a paper?
13:35:29 <makalu> so with time I would use 'getCurrentTime' from Data.Time.Clock right? Is there a way to convert this into Double?
13:36:11 <ChristianS> kadoban: for most practical purposes, yes
13:36:16 <shachaf> Why do you want to?
13:36:22 <dfdsfsdf> vanila: still around?
13:37:07 <athan> Why isn't there an instance of MonadResource (from Conduit) for IO? How else am I supposed to use `sourceFile`? :E
13:37:11 <vanila> dfdsfsdf, yes
13:37:19 <dfdsfsdf> great
13:37:43 <dfdsfsdf> I have more questions on the CPS. Is it possible to convert any function to the CPS?
13:38:23 <earthy> dfdsfsdf: yes.
13:39:49 <dfdsfsdf> I understand what a cont'n is and what a suspended computation is, but I'm struggling to understand the meaning of the term "a function in the CPS style".
13:40:28 <athan> dfdsfsdf: Have you checked out the paper "value recursion in monadic computations"? They talk about how ContT cannot have any feasible mfix operation - I'm finding out how unique it is, nearly everywhere :)
13:40:56 <dfdsfsdf> ... because this link states https://en.wikibooks.org/wiki/Haskell/Continuation_passing_style that add_cps and square_cps are not really in the cps form.
13:41:31 <dfdsfsdf> athan: no I haven't read it.  I'm struggling to understand even the basics, I don't want to get into the transformer mess.
13:41:54 <athan> dfdsfsdf: Just try to make a `callCC` in haskell, and you'll understand :)
13:42:07 <athan> AUTOBOTS, ROLL OUT
13:42:19 <dfdsfsdf> I don't understand how it works in Scheme either.
13:42:49 <dfdsfsdf> I failed to find its definition in Scheme.
13:42:49 <benzrf> dfdsfsdf: i have a notion of call/cc
13:42:53 <monochrom> call/cc is a built-in or close to built-in in Scheme. it has to be.
13:43:09 <benzrf> dfdsfsdf: have you ever used delimited continuations before
13:43:14 <Gonzih> it's built in
13:43:14 <dfdsfsdf> no
13:43:25 <benzrf> dfdsfsdf: ok, the idea is
13:43:27 <benzrf> when you say this:
13:43:31 <benzrf> oh wait
13:43:32 <monochrom> in haskell it is not a built-in because it is only usable in the Cont or ContT monad, which are also user-defined.
13:43:40 <benzrf> dfdsfsdf: let me explain it in a schemy way first
13:43:46 <benzrf> then you can see how the haskell "Cont" resembles it
13:43:46 <dfdsfsdf> okay
13:43:57 <benzrf> first, delimited continuations are just that... delimited
13:43:58 <monochrom> if you, instead, ask for a call/cc for IO, then it has to be built-in again, just like the Scheme case.
13:44:05 <benzrf> so you have to delimit it like so:
13:44:10 <benzrf> (reset ...code... )
13:44:15 <dfdsfsdf> benzrf: wait...
13:44:26 <benzrf> ?
13:44:28 <dfdsfsdf> maybe I should get the basics first.
13:44:35 <Gonzih> there is fancy call/cc puzzle that was bugging me for some time http://blog.gonzih.me/blog/2013/11/26/yin-yang-callcc-puzzle-in-ruby/
13:44:38 <benzrf> dfdsfsdf: im explaining the basics
13:44:39 <benzrf> :-)
13:44:56 <benzrf> dfdsfsdf: the first step is to delimit your code
13:45:02 <benzrf> by putting it inside a reset
13:45:03 <dfdsfsdf> well, I'm struggling even with the first example here https://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
13:45:14 <benzrf> dfdsfsdf: ignore that for now, focus on 1 thing
13:45:18 <benzrf> alternatively, ignore me and focus on that
13:45:22 <dfdsfsdf> haha
13:45:41 <dfdsfsdf> okay, I'll ignore that for now.
13:45:45 <dfdsfsdf> what did you want to explain?
13:45:56 <benzrf> how delimited continuations work in languages that really have them
13:46:06 <benzrf> and then how haskell's Cont monad 'mimics' it
13:46:33 <dfdsfsdf> What's the relationship between Cont and delim'd cont's?
13:46:40 <benzrf> Cont is like a simulation of TheMoonMaster
13:46:41 <benzrf> *them
13:46:45 <dfdsfsdf> Is Cont a simplification?
13:46:56 <benzrf> no, it's an entirely separate thing that can be used similarly
13:47:04 <benzrf> like the State monad compared to actual state
13:47:10 <dfdsfsdf> okay
13:47:18 <dfdsfsdf> so, go ahead please
13:47:18 <NikolajK> Would you say "concise/intelligent do-blocks" are the main purpose of coding using monads?
13:47:37 <benzrf> dfdsfsdf: ok, first you delimit the area that you will be using continuations in
13:47:39 <dfdsfsdf> NikolajK: What does intelligent do blocks even mean?
13:47:43 <benzrf> (reset <rest of the code>)
13:47:51 <TheMoonMaster> benzrf: wot
13:47:54 <athan> Nikolajk: No weighhhh
13:47:55 <benzrf> TheMoonMaster: mistab
13:47:55 <TheMoonMaster> I'm a simulation?
13:48:01 <benzrf> ;-;
13:48:06 <TheMoonMaster> :(
13:48:16 <athan> Nikolajk: Monads are like... sporks
13:48:18 <benzrf> dfdsfsdf: the rest of the code inside the reset may be any expression
13:48:34 <benzrf> dfdsfsdf: then the result of the reset block is that expression.
13:48:41 <monochrom> I don't think do-notation contains much intelligence. but it is a nice notation, you may call it concise.
13:48:44 <NikolajK> dfdsfsdf: do's which have the operations coming with the functor 'hidden under the hood'
13:48:46 <athan> Nikolajk: That you can mold to your delicacy, and staple together
13:48:56 <benzrf> dfdsfsdf: for example, (reset 3) will be 3
13:49:01 <benzrf> dfdsfsdf: obviously this is not the main point
13:49:05 <shachaf> There is no hood.
13:49:20 <benzrf> dfdsfsdf: you following along?
13:49:42 <dfdsfsdf> benzrf: what does "delimit" mean in this context?
13:49:59 <benzrf> dfdsfsdf: mark off
13:50:08 <dfeuer> dfdsfsdf, it's not the entire rest of the program.
13:50:11 <benzrf> dfdsfsdf: you'll see why in a second
13:50:13 <dfdsfsdf> benzrf: Can you show a concrete example?
13:50:19 <benzrf> dfdsfsdf: you'll see why in a second
13:50:19 <dfdsfsdf> okay
13:50:33 <benzrf> dfdsfsdf: within the confines of the reset block, you may use the shift 'function'
13:50:40 <benzrf> dfdsfsdf: this is the magical bit
13:51:10 <benzrf> dfdsfsdf: when you call shift with a function,
13:51:23 <benzrf> 1. the result of the function will be the result of the reset (it terminates early)
13:51:30 <monochrom> do-notation doesn't even use Functor
13:51:43 <benzrf> 2. the function will be passed a function consisting of the rest of the reset block
13:51:51 <benzrf> which it can call as it pleases
13:51:59 <benzrf> here's an example
13:52:10 <benzrf> (i'm gonna use fakey lisp because i dont recall the stuff)
13:52:18 <dfdsfsdf> okay
13:52:44 <monochrom> it is best to think of "reset" as a block or scope.
13:52:48 <benzrf> (defn twice (f) (progn (f) (f))
13:52:53 <monochrom> also, you can nest it.
13:53:02 <NikolajK> monochrom: do uses monad, so a functor too
13:53:09 <benzrf> (reset (progn (shift twice) (some-effect))
13:53:13 <NikolajK> >== lifts
13:53:27 <benzrf> dfdsfsdf: when the shift is encountered, its argument (twice) will be called with a function representing the rest of the reset block
13:53:33 <dfdsfsdf> NikolajK: do you know how to desugar the do notation?
13:53:41 <NikolajK> yes
13:53:58 <monochrom> that is beside the point, NikolajK.
13:54:18 <NikolajK> mhm
13:54:28 <benzrf> dfdsfsdf: the net effect will be running some-effect twice
13:55:03 <NikolajK> I'd say the fmap of a monad does more than return and join, but that doesn't really matter, really
13:55:38 <NikolajK> but since Haskell people, generally, only lift a function one level up, the do notion seems to be the height of using monads
13:56:13 <dfdsfsdf> benzrf: okay
13:56:49 <NikolajK> a question: fail can be avoided, right? point 9.2. here seems to imply that list comprehension relies on fail
13:56:50 <NikolajK> http://www.haskell.org/tutorial/monads.html
13:57:35 <dfdsfsdf> NikolajK: The minimal complete definition requires >>= and return.
13:57:53 <vanila> dfdsfsdf, sorry I got distracted, what's up?
13:58:00 <NikolajK> dfdsfsdf: don't know how that helps me here
13:58:01 <shachaf> List comprehensions use fail, or are indistinguishable from what they would look like if they did.
13:58:12 <NikolajK> but yes, I have a good, I think, understanding of monads
13:58:27 <NikolajK> less with programming pactice, though
13:58:31 <benzrf> dfdsfsdf: there is 1 other twist
13:58:35 <monochrom> list comprehension "uses" fail iff list comprehension "uses" >>=
13:58:46 <vanila> NikolajK, I think fail = [] or something? I just write [] to fail in list monad
13:58:49 <benzrf> dfdsfsdf: the 'apparent result' of the shift call in the rest of the block
13:59:00 <benzrf> will be whatever you call the rest of the block with
13:59:07 <benzrf> dfdsfsdf: for example
13:59:30 <benzrf> (defn twice-1-2 (f) (progn (f 1) (f 2)))
14:00:02 <benzrf> (reset (let ((n (shift twice))) (print n)))
14:00:12 <benzrf> ^that will print `1\n2'
14:00:46 <benzrf> it's like you're pausing the current program, reifying the paused program, and passing it to the argument of shift
14:00:57 <benzrf> then the argument can say 'ok resume, and the result of shift will be this'
14:01:06 <dfeuer> The pain of avoiding fail is that pattern match and guard failures have to be made explicit.
14:01:11 <benzrf> except that it only resumes as far as the end of the block
14:01:13 <monochrom> that one is trickier, especially since lisp/scheme's "let" is tricky.
14:01:14 <benzrf> hence, delimited
14:01:15 <dfdsfsdf> vanila: I'd like to try converting various functions to the CPS style.  But I'm not sure what the term "CPS style" means since the wiki example doesn't explain that clearly.  In addition, there is a comment, which confuses me, stating that add_cps and square_cps are not in the CPS form.  Why is it important to assume CPS versions of add and square?
14:01:22 <benzrf> monochrom: oh?
14:01:29 <monochrom> wait, where is twice-1-2 used?
14:01:33 <benzrf> monochrom: oh
14:01:35 <benzrf> i meant to use it there
14:01:39 <benzrf> instead of twice
14:01:39 <monochrom> hehe
14:01:40 <benzrf> derp
14:01:46 <benzrf> see this is the kind of thing i trip on
14:01:54 <benzrf> not large-scale stuff, little typos. constantly
14:02:12 <monochrom> does (reset (print (shift twice-1-2))) do the same thing?
14:03:04 <benzrf> it should!
14:03:21 <benzrf> unless i greatly misunderstand
14:04:22 <goglosh> does anyone here know any books on cryptography that use haskell?
14:04:44 <monochrom> the problem with lisp/scheme "let" is that "let n be xxx" is sometimes "let n = xxx" and some other times "n <- xxx".
14:04:46 <dreams> Do you know if Peyton replies to emails?
14:05:19 <Fuuzetsu> he does
14:05:21 <dfeuer> dreams, who is Peyton? Do you mean Simon Peyton-Jones?
14:05:26 <dreams> dfeuer: yes
14:05:32 <shachaf> His name is Simon Peyton Jones, if you want to be pedantic about it.
14:05:35 <dfeuer> He sometimes does.
14:05:39 <dfeuer> Ah.
14:05:41 <monochrom> the surname is Peyton Jones. two words.
14:05:48 <dfeuer> Sorry.....
14:05:53 <shachaf> He talks on the mailing list a lot. But if you have a question you should probably send it to the mailing list rather than to him directly unless it's really specific to him.
14:06:00 <dreams> well I assumed peyton is well known in this community so.
14:06:15 <monochrom> don't feel bad if you didn't know. but now you know. also help spread the word. or two words. :)
14:06:15 <c_wraith> dreams: if you want a short name, SPJ works.
14:06:17 <vanila> dfeuer, Continuation Passing Style means that: You give every procedure an extra argument - the continuation. No procedure "returns" anymore, results are "thrown into the continuation" instead. And every call is a tail call
14:06:18 <Fuuzetsu> there is also Mark Peyton Jones so you never know!
14:06:27 <dreams> shachaf: no I want his opinion on something personally.
14:06:35 <dfeuer> vanila, I'm aware.
14:06:47 <dfdsfsdf> dfeuer: vanila mistyped.
14:06:49 <monochrom> yikes, Mark Jones is Mark Peyton Jones?!
14:06:51 <dfeuer> vanila, the consequences can be a bit mind-bending.
14:07:06 <vanila> dfdsfsdf, functions like * and - are primitives in the language - we need the source code to CPS transform them. Since we don't have that we just assume CPS forms of primitives like + and *
14:07:09 <c_wraith> dfdsfsdf: well, more like mis-tab-completed. :)
14:07:20 <dreams> shachaf: which mailing list by the way?
14:07:36 <shachaf> The one relevant to your question.
14:07:55 <shachaf> monochrom: I am doubtful about that.
14:08:06 <shachaf> He is Mark P. Jones, though.
14:09:56 <dreams> vanila: doesn't that get hard to follow?
14:10:00 <dfdsfsdf> vanila: thanks for the definition. now it's clear, I think.  I'll try to convert a couple of functions to CPS.
14:11:15 <dfdsfsdf> This channel is very supportive.  I'm having a great time learning new things while talking to people.
14:11:23 <HairyDude> @hoogle Read a => String -> Maybe a
14:11:24 <lambdabot> Network.CGI.Protocol maybeRead :: Read a => String -> Maybe a
14:11:25 <lambdabot> Network.CGI readCookie :: (Read a, MonadCGI m) => String -> m (Maybe a)
14:11:25 <lambdabot> Network.CGI readInput :: (Read a, MonadCGI m) => String -> m (Maybe a)
14:11:37 <HairyDude> nothing in base?
14:11:39 <dreams> dfdsfsdf: yes the community is great.
14:12:06 <vanila> dfdsfsdf, If you have trouble CPSing a function just ask
14:12:19 <dfdsfsdf> vanila: will do!
14:12:54 <vanila> dreams, it is actually quite easy to read because it explicitly shows the execution order: e.g. in (f (x) (y)) we don't know if x or y is called first, but CPS shows it
14:13:08 <itechjunkie> also my first day in the channel. I've been quiet so far, but have been pleasantly surprised how understanding people are.
14:13:18 <HairyDude> google for "Hoogle"... "Showing results for google / Search instead for hoogle" click on hoogle: "Did you mean: google"
14:13:52 <dreams> vanila: I tried to read Apple' book on CPS, was a bit hard to follow.
14:14:04 <HairyDude> for some reason Hayoo doesn't grok class constraints
14:14:11 <dreams> vanila: maybe I'm not used to it.
14:14:28 <vanila> dreams, well that book covers loads of stuff - it is hard
14:14:46 <dreams> I'm glad you said that.
14:15:43 <NikolajK> how can I run this:
14:15:43 <NikolajK> [1,2,3] >>= (\ x -> [1,2,3] >>= (\y -> return (x/=y) >>= (\r -> case r of True -> return (x,y)
14:15:43 <NikolajK>                     _    -> fail "")))
14:15:49 <NikolajK> it's the example from above
14:16:05 <NikolajK> I tried writing "main = …" into a file, but it wont work
14:16:16 <S11001001> NikolajK: run ghci and paste it into that
14:16:31 * hackagebot generic-church 0.3.0.0 - Automatically convert Generic instances to and from church representations  http://hackage.haskell.org/package/generic-church-0.3.0.0 (jozefg)
14:16:33 * hackagebot twentefp-rosetree 0.1.0.1 - RoseTree type and show functions for lab assignment of University of Twente.  http://hackage.haskell.org/package/twentefp-rosetree-0.1.0.1 (sebaslafleur)
14:16:48 <NikolajK> it's not liked
14:17:07 <S11001001> NikolajK: liked?
14:17:20 <dfdsfsdf> NikolajK: try [1,2,3] >>= (\ x -> [1,2,3] >>= (\y -> return (x/=y) >>= (\r -> case r of True -> return (x,y); _ -> fail "")))
14:17:30 <dfdsfsdf> returns [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
14:17:40 <NikolajK> you added a semi-colon?
14:17:43 <dfdsfsdf> yes
14:17:46 <NikolajK> k
14:17:47 <c_wraith> NikolajK: by default, ghci doesn't accept multiline input.
14:17:59 <dfdsfsdf> c_wraith: how do I enable it?
14:18:12 <c_wraith> It's one of the :set options.  I don't remember which
14:18:17 <dfdsfsdf> okay
14:18:32 <NikolajK> okay, what I really wanted to find out - and the answer appears to be yes, is that [1,2,3] >>= (\ x -> [1,2,3] >>= (\y -> return (x/=y) >>= (\r -> case r of True -> return (x,y); _ -> []))) does the same
14:18:47 <NikolajK> I got rid of my fail
14:18:59 <c_wraith> nikolah: you could also use guard
14:19:01 <c_wraith> err
14:19:03 <c_wraith> NikolajK:
14:19:20 <NikolajK> where
14:19:43 <NikolajK> so in do, that would be
14:19:45 <c_wraith> [1,2,3] >>= (\ x -> [1,2,3] >>= (\y -> return (x/=y) >>= (guard r >> retuurn (x,y)))
14:19:54 <c_wraith> uh, minus the typo.  hard to type with cat in lap.
14:20:13 <dfdsfsdf> NikolajK: what are you trying to acheive?
14:20:39 <dfdsfsdf> NikolajK: You asked about the do notation and functors, then moved to fail...
14:20:39 <NikolajK> understanding list comprehensions yes/no acceptance rules, how that works
14:21:00 <NikolajK> the do/monad-question was general
14:21:11 <c_wraith> NikolajK: you can treat any boolean segment in a list comprehension as an implicit call to guard
14:21:16 <vanila> im not certain that list comprehensions desugar to monad
14:21:26 <c_wraith> vanila: they don't, though they could.
14:21:34 <vanila> they should..., but what about "|" there's no monadic version
14:22:10 <glguy> It's the second | that gets you, and only get one of those with a different language extension
14:22:18 <c_wraith> There's the MonadComprehensions extension that makes comprehensions desugar to explicit monadic operations
14:22:46 <NikolajK> > do{x<-[1,2,3]; y<-[1,2,3]; r <- return (x/=y); case r of True -> return (x,y); _ -> []}
14:22:47 <lambdabot>  [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
14:22:51 <NikolajK> ha!
14:23:16 <dfdsfsdf> note that you don't need the {}.
14:24:06 <c_wraith> > do { x<-[1,2,3]; y<-[1,2,3]; r <- return (x/=y); guard r ; return (x,y) }
14:24:07 <lambdabot>  [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
14:24:21 <c_wraith> > do { x<-[1,2,3]; y<-[1,2,3]; let r = (x/=y); guard r ; return (x,y) }
14:24:22 <lambdabot>  <hint>:1:54: parse error on input ‘;’
14:24:33 <Iceland_jack> > do { x<-[1,2,3]; y<-[1,2,3]; let { r = (x/=y) }; guard r ; return (x,y) }
14:24:33 <yyttr3> I have a list of strings and I want to print one out, getLine and then print another out. I tried something like :  mapM_ (print >> (\_ -> getLine)) list, but that doesn't work.
14:24:34 <c_wraith> > do { x<-[1,2,3]; y<-[1,2,3]; let {r = (x/=y)}; guard r ; return (x,y) }
14:24:34 <lambdabot>  [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
14:24:35 <lambdabot>  [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
14:25:05 <Iceland_jack> yyttr3: 'print' needs an argument
14:25:06 <exio4> do { x<-[1,2,3]; y<-[1,2,3]; guard (x/=y) ; return (x,y) }
14:25:12 <exio4> err
14:25:13 <exio4> > do { x<-[1,2,3]; y<-[1,2,3]; guard (x/=y) ; return (x,y) }
14:25:15 <lambdabot>  [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
14:25:17 <Iceland_jack> You probably want something like 'putStrLn' for Strings
14:25:28 <yyttr3> I'm trying to make the values in the list the arguements of print.
14:25:46 <Iceland_jack> yyttr3:
14:25:46 <Iceland_jack>     forM_ list $ \value -> do
14:25:46 <Iceland_jack>       print value
14:25:46 <Iceland_jack>       getLine
14:26:26 <yyttr3> I didn't know about forM, thank you.
14:26:28 <NikolajK> > do x<-[1,2,3]; y<-[1,2,3]; (guard (x/=y); return (x,y))
14:26:29 <lambdabot>  <hint>:1:41: parse error on input ‘;’
14:27:06 <Iceland_jack> yyttr3: Written on a single line: forM_ list (\value -> print value >> getLine)
14:28:31 <Iceland_jack> yyttr3: And one for the road:
14:28:31 <Iceland_jack>     sequence_ [ print value >> getLine | value <- list ]
14:28:43 <yyttr3> ha! mapM_ (\value -> print value >> getLine) list
14:28:54 <exio4> forM_ = flip mapM_
14:28:56 <yyttr3> That seqeunce_ is nice though
14:29:00 <yyttr3> I see
14:29:17 <Iceland_jack> Yes if you want to use 'mapM_', but forM_ would be more idiomatic in this case
14:30:25 <yyttr3> Thank you
14:30:48 <Iceland_jack> no problem
14:33:02 <dfdsfsdf> vanila: how do I proceed? http://dpaste.com/1GW5BN0.txt
14:33:51 <Iceland_jack> dfdsfsdf: (What is the result of the normal map in the (x:xs) case?)
14:34:06 <dfdsfsdf> f x : map f xs
14:34:10 <Iceland_jack> Right
14:34:31 <dfdsfsdf> I feel that I need a CPS version of f x too
14:34:37 <dfdsfsdf> But I'm not sure how to do it.
14:34:42 <vanila> yes you do
14:34:44 <vanila> fCPS
14:34:53 <vanila> don't worry about types
14:36:41 <monochrom> benzrf: I see what I was worrying about. "let n = side_effect in print n" uses n exactly once and right away, so it does the same as "print side_effect". this doesn't generalize to using n twice or using n later, e.g., "let n = side_effect in (print 0; print n)" and "let n = side_effect in print (n + n)"
14:36:45 <vanila> dfdsfsdf, how about this http://dpaste.com/3ZE0TH2
14:37:11 <NikolajK> what is this statement again "Haskell is the … procedural language"
14:37:29 <vanila> the final call k (fx : fxs) is not in CPS form because it's a primitive/constructor, you could create consCPS
14:38:57 <vanila> dfdsfsdf, uit could be easier to understand working in scheme
14:40:19 <dfdsfsdf> vanila: your definition of map is incorrect, it seems
14:40:26 <dfdsfsdf> the first line
14:40:36 <dfdsfsdf> must be map f [] = []
14:40:42 <dfdsfsdf> otherwise the patterns are overlapped
14:40:53 <vanila> oops
14:41:10 <dfdsfsdf> but that's not the point
14:42:10 <benzrf> monochrom: i was assuming a strict language
14:42:16 <benzrf> with normal-order, etc
14:42:35 <monochrom> yes, I am too
14:42:59 <monochrom> assume I wrote Scheme in Algol syntax :)
14:43:16 <monochrom> hell, "print side_effect" can't even be Haskell :)
14:46:22 <NikolajK> I had an idea for a t-shirt
14:46:26 <NikolajK> "do
14:46:26 <NikolajK> *some monadic code*
14:46:26 <NikolajK> You even lift!"
14:47:52 <raichoo> Bronad, do you even liftM?
14:51:23 <etandel> lol
14:51:56 <etandel> A bronad in x is just a bronoid in the category of endufunctors of x, what's the problem?"
14:52:14 <etandel> embrofunctors*
14:56:09 <dmj`> bronads
14:57:37 <zomg> Dysfunctional Brogrammers
14:58:36 <raichoo> pro… erm brofunctors \o/
14:58:47 <schell> does hoogle have a way of searching for functions - given wildcards? for instance, i’d like to search for all functions in OpenGL that take a TextureTarget2D as the first param
14:59:11 <silver> @hoogle TextureTarget2D -> a
14:59:12 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
14:59:12 <lambdabot> Prelude id :: a -> a
14:59:12 <lambdabot> Data.Function id :: a -> a
14:59:41 <silver> @hoogle (->) TextureTarget2D
14:59:41 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Specification Texture1DArray :: TextureTarget2D
14:59:41 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Specification Texture2D :: TextureTarget2D
14:59:41 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Specification TextureRectangle :: TextureTarget2D
15:00:08 <schell> silver: oh, check that one out, cool
15:00:27 <silver> I have no idea if it's actually works, just trying to guess
15:03:45 <silver> Searches can be restricted to a particular module with +Module.Name
15:03:50 <schell> silver: thanks all the same :)
15:03:59 <silver> http://www.haskell.org/haskellwiki/Hoogle
15:16:15 <hexagoxel> seems to be equal to the "::TextureTarget2D" query..
15:21:54 <absence> i seem to recall there was some issue about making the join function a Monad member for AMP. is there some info about this, or have i just been dreaming?
15:27:29 <johnw> it was mentioned at ICFP actually, but I've forgotten what was said
15:27:39 <johnw> (or maybe it was at HIW)
15:28:34 <catsup> can anyone explain wtf this means.  to me it makes no sense:  "cabal: cannot configure SDL2-ttf-0.1.0. It requires SDL2 -any"     "There is no available version of SDL2 that satisfies -any"
15:29:21 <merijn> catsup: You don't ahve SDL2 installed?
15:29:27 <catsup> also: $ cabal info SDL2|grep -i installed   ==>   Versions installed: 1.1.0
15:29:29 <johnw> that's just what it means
15:29:53 <catsup> merijn: even if i didn't have it installed, though, it ought to pull it in as a dependency
15:30:07 <catsup> no _available_ version that satisfies -any???
15:30:09 <johnw> what was the original install command?
15:30:33 <catsup> well, i tried a few variations, but 'cabal install sdl2-ttf'
15:30:39 <hnoob> maybe there's a conflict between SDL2 and something else??  seems like you'd get a different error though
15:30:44 <merijn> catsup: cabal can't install non-haskell dependencies
15:30:50 <catsup> i _have_ sdl2 installed tho
15:30:54 <merijn> hmm
15:31:10 <merijn> Are you passing the library directory for it to cabal?
15:31:24 <absence> ah, it's in the wiki. "Left out due to nontrivial breaking interaction with Roles. Will "probably be fixed in the future", but for now it's off the table. "
15:31:36 <dcoutts_> the error message looks like a Haskell lib dependency, not a C lib or pkg-config one
15:31:36 <johnw> ah, yes
15:31:40 <johnw> Richard mentioned it
15:31:47 <johnw> dcoutts_: hello!
15:31:53 <dcoutts_> hia
15:31:56 <absence> sad :(
15:32:07 <il> test
15:32:17 <catsup> dcoutts_: indeed
15:32:46 <catsup> if the problem were finding the sdl2-ttf C library, it'd show up during cabal build
15:33:02 <dcoutts_> catsup: we can help better if you paste a log of what you get when you do cabal install SDL2-ttf
15:33:38 <catsup> i will do that, although it seems to me there is nothing relevant besides what i posted already :/
15:34:05 <johnw> dcoutts_: you open to question about your thesis?
15:34:14 <dcoutts_> catsup: you'd be surprised how often it helps us spot problems
15:34:17 <dcoutts_> johnw: sure
15:34:26 <johnw> ok, bottom of page 65
15:34:29 <dcoutts_> ok...
15:34:34 <johnw> you go from fold T in x A k = x A k to fold T in = id T
15:34:40 <johnw> I can't seem to find a way to justify that step in Coq
15:35:24 * dcoutts_ finds the place...
15:35:54 <johnw> great thesis, btw
15:35:57 <johnw> everyone should read this
15:36:08 <merijn> johnw: What's the topic?
15:36:12 <johnw> stream fusion
15:36:16 <catsup> http://lpaste.net/110807
15:36:27 <johnw> it has the clearest explication of Fix/Mu/Nu and their relationship that I have ever seen -- with proofs
15:36:37 <merijn> johnw: Where do you get the time to read all that? Don't you have to work at your job? :p
15:36:46 <johnw> http://community.haskell.org/~duncan/thesis.pdf
15:36:54 <johnw> merijn: yeah, but I have free time too
15:37:09 <merijn> So do I, but there's only so much of that time that I can read :p
15:37:18 <dcoutts_> johnw: oh isn't that just by uniqueness of identity functions on a given type?
15:37:31 <johnw> ah, hmm... UIPs?
15:37:38 <johnw> "uniqueness of identity proofs"
15:37:44 <johnw> i don't have those axiomatized
15:37:57 <johnw> but I'll dig into that, thanks
15:38:11 <dcoutts_> johnw: if I've got a complicated identity function at type T -> T, then that's equiv to the polymorphic id function instantiated at type T
15:38:28 <dcoutts_> it just has to satisfy the defining equation for id
15:38:59 <dfdsfsdf> vanila: please take a look http://dpaste.com/2ZK3VSJ
15:39:00 <johnw> right, in Coq that's Lemma UIP : forall (x y:U) (p1 p2:x = y), p1 = p2.
15:39:07 <catsup> i tried the top-down solver too.  and i tried an earlier version of cabal-install (1.18.0.5).
15:39:34 <napping> johnw: sounds more like some kind of forall f, (forall x, f x = x) -> f = id
15:39:44 <johnw> ah
15:39:47 <Saizan> johnw: fold T in x A k = x A k  eta reduces to fold T in x = x, i.e. fold T in = \ x -> x
15:40:06 <johnw> that makes more sense, thanks Saizan
15:40:12 <johnw> so not UIP as I was understanding it
15:40:14 <napping> Is that provable?
15:40:33 <vanila> napping, that is  not provable in Coq
15:40:36 <dcoutts_> catsup: oooh, it's simply that there is no package called SDL2, there's one called sdl2
15:40:55 <vanila> it's true but we don't have a way to prove  parametricity results
15:41:13 <Saizan> this is not parametricity, it's just functional extensionality
15:41:21 <vanila> dfdsfsdf, yes, any questions?
15:41:40 <dfdsfsdf> it seems to be correct, is it?
15:41:51 <vanila> Saizan, oh youre right I thought we were talking about (f : forall T, T -> T) -> f = id
15:41:52 <dcoutts_> catsup: thus SDL2-ttf cannot have ever worked, unless people are getting SDL2 from somewhere other than hackage
15:42:03 <vanila> thanks for the correction
15:42:13 <Saizan> np
15:42:39 <Denommus> are there front-end libraries for GHCJS?
15:43:30 <dmj`> Denomus: there is ghcjs-dom
15:43:31 <dcoutts_> johnw: Saizan is right, it's even simpler, which is why I didn't bother even naming the rule I was using there :-)
15:43:32 <c_wraith> Denommus: I'm pretty sure there are a few bindings to existing JS libs
15:43:34 <dmj`> https://hackage.haskell.org/package/ghcjs-dom
15:43:38 <catsup> dcoutts_: OH.  it is using a package named SDL2 from here https://github.com/osa1/hsSDL2 !
15:44:00 <catsup> jesus what an unfortunate choice of name
15:44:03 <Denommus> dmj`: that's pretty "low-level", though, right? Nothing like FRP
15:44:34 <rod_> Hi, does Ghc Work with mosix ?
15:44:41 <dmj`> Denomus: in the examples it has some frp things, https://github.com/ghcjs/ghcjs-examples/
15:44:51 <vanila> dfdsfsdf, yah
15:44:53 <vanila> yeah*
15:45:04 <Denommus> dmj`: ah, thanks
15:45:07 <dcoutts_> johnw: note that those proofs there don't have a great deal of connection to the final stream fusion correctness proofs
15:45:17 <osa1> catsup: use original version of the repo, my fork is very old
15:45:31 <catsup> osa1: OH HELLO!
15:45:34 <catsup> :)
15:45:38 <osa1> catsup: hi :)
15:45:58 <osa1> catsup: hsSDL2-ttf should be working with latest master branch
15:45:59 <dcoutts_> johnw: as those are all proofs relying on parametricity
15:46:18 <osa1> catsup: https://github.com/Lemmih/hsSDL2
15:46:37 <dfdsfsdf> vanila: Great, I think I finally got it.  I'll reimplement more functions tomorrow.  Thanks for your help again.  Without it, I wouldn't be able to get that far.
15:46:39 <catsup> osa1: i'm building it now.  your old fork built already
15:47:01 <osa1> catsup: that works too but it's missing some features because it's old.
15:47:01 <catsup> osa1: should i be using the SDL2-ttf from hackage?
15:47:21 <osa1> catsup: it should be same version with the one at github
15:47:25 <catsup> ok
15:48:09 <catsup> it's building SDL2-ttf now :)
15:48:15 <osa1> catsup: we were planning to replace sdl2 at hackage with hsSDL2 because it's higher level and provides a somewhat more idiomatic API but we never really finished the work.
15:48:20 <osa1> catsup: cool :)
15:49:06 <catsup> didn't build though :/
15:49:10 <osa1> catsup: I really suggest you to use original hsSDL2 instead of my fork. if you find a compilation error just report, even though it's not actively developed several people fix bugs very fast.
15:49:17 <dcoutts_> johnw: and in a later proof it's clear I'm relying on eta-reduction for that kind of step
15:49:19 <osa1> catsup: what's the error?
15:49:20 <catsup> osa1: yeah, i am
15:49:35 <dcoutts_> johnw: the one you asked me about first I mean
15:49:45 <osa1> catsup: I'll just try to build it myself
15:49:53 <catsup> osa1: http://lpaste.net/110811
15:50:03 <osa1> ahh, that error
15:50:06 <osa1> I know that
15:51:34 <osa1> catsup: I'm fixing that in a second. by the way, maintainers of hsSDL2 are hanging at #haskell-game if you need help.
15:51:43 <rod_>  /msg Ski , hi Ski , You showed me the other Day the select fun , i ve added the eval monad, parallel processing is Working, wonder now if i could run ghc runtime On mosix, have you an idea ?
15:52:19 <catsup> osa1: cool, i'm there :)
15:53:03 <osa1> catsup: just try with master, it should work
15:53:15 <osa1> catsup: clone Lemmih/hsSDL2 and install. then clone osa1/hsSDL2-ttf and install
15:56:20 <osa1> we should really create an organization and move all hsSDL2 extensions there.
15:56:53 <catsup> osa1: ok.  thanks a lot :)
15:57:37 <osa1> catsup: no probs. ping us at #haskell-game or just open an issue at github if you have problems.
15:58:04 <catsup> will do.  btw i got it installed successfully :)
15:58:11 <osa1> awesome :)
16:02:32 <davean1> 5/buf15
16:16:46 * hackagebot DAV 1.0.2 - RFC 4918 WebDAV support  http://hackage.haskell.org/package/DAV-1.0.2 (ClintAdams)
16:30:53 <johnw> dcoutts_: yeah, I'm just starting there
16:31:03 <johnw> Saizan: I still can't seem to identify 'x' with 'x a k'
16:31:07 <johnw> what would be the connective?
16:31:42 <dcoutts_> johnw: ok, so long as you realise you'll not depend on any of these lemmas later
16:31:48 <johnw> sure
16:32:04 <dcoutts_> the final results all use data abstraction
16:32:32 <johnw> i wanted a deeper understanding of the stuff you begin with, since it has been of particular interest to me for a while now
16:34:06 <vanila> what's a nice simple example of a monad transformer I could explain tot someone?
16:34:17 <merijn> StateT?
16:34:35 <johnw> yeah, StateT is pretty good
16:34:35 <vanila> merijn, What would I combine it with?
16:34:50 <johnw> IO, or Identity
16:34:51 <monochrom> StateT (Cont r) :)
16:34:55 <vanila> lol
16:34:59 <johnw> lol
16:35:00 <monochrom> oops, StateT s (Cont r)
16:35:06 <vanila> StateT with (Cont r) I have no idea what that even dose
16:35:09 <fizbin> IO would be my choice, or maybe []
16:35:16 <monochrom> more seriously IO or another State may be good
16:35:55 <dcoutts_> johnw: ok, fair enough. Certainly it is interesting and good context (which is why it's there at all!)
16:36:28 <johnw> dcoutts_: the best result so far is that I now have a way of reasoning about functor fixpoints in Coq using Mu
16:36:48 <johnw> I only weakly know about the Fix/Mu isomorphism, and knew that Fix doesn't work
16:36:52 <johnw> s/know/knew
16:37:06 <johnw> this opens up some doors in other areas
16:38:04 <dcoutts_> johnw: btw, as a note for the later results you might try to formalise, you may well be able to give a general proof about the abstraction relation that I only ever gave specific examples of
16:38:24 <johnw> yes, that would be nice
16:40:06 <dcoutts_> johnw: though I now don't recall exactly what that more general property I was trying to prove was... :-)
16:40:21 <dcoutts_> just that it involved stating things in terms of the abstraction relation in general
16:42:13 <johnw> how did you come up with this topic for your thesis?
16:44:40 <dcoutts_> johnw: dons and I were working on fusion for bytestrings
16:46:24 <dcoutts_> johnw: Don and Roman and I ended up doing the stream fusion stuff, mostly the practical side of things, and I did the more theoretical side for my thesis
16:47:24 * dcoutts_ notes that it was Roman Leshchinskiy who first had the idea of adding Skip
16:48:03 <johnw> i've also been studying the relationship between streams as you have them, and pure CPS chains; it seems the difference is essentially that of consumer vs. producer driven value production
16:51:59 <dcoutts_> johnw: right
16:52:16 <yyttr3> What does 0# mean in the prelude?
16:52:27 <yyttr3> I'm reading souce for Data.List
16:52:32 <yyttr3> source*
16:52:49 <yyttr3> Like, Int#,+#
16:52:52 <yyttr3> 0#
16:53:25 <Fuuzetsu> # = omgfast
16:53:42 <merijn> Primitive
16:53:53 <merijn> # types are either primitive or unboxed
16:54:00 <yyttr3> unboxed?
16:54:21 <merijn> yyttr3: Normally haskell datatypes are boxed, i.e. they are pointers to values
16:54:44 <yyttr3> So the normal data types aren't primitive?
16:54:47 <merijn> "Maybe a" is something that contains a *pointer* to an 'a', not an actual 'a'
16:55:06 <mcbears> so Int#, which is the integer type of kind #, is just bits like a C int
16:55:15 <merijn> If it were unboxed it would contain the 'a' directly (but this is not possible with polymorphic code in general)
16:55:38 <yyttr3> So Int is a pointer to an int while Int# is a value
16:55:41 <merijn> yyttr3: primitive == built into the compiler
16:55:46 <yyttr3> What about numbers?
16:55:58 <yyttr3> Nevermind
16:56:03 <yyttr3> I understand
16:57:02 <yyttr3> So boxing from unboxed types is done automatically then?
16:57:13 <merijn> So 0# is a machine word 0 and +# is machine word addition (i.e. ADD assembly instructions)
16:57:39 <merijn> yyttr3: No, you will see that, for example, Int is just "data Int = I# Int#"
16:58:16 <mcbears> notably also, values of unboxed types are unlifted (can't be nonterminating/undefined)
16:58:55 <yyttr3> Is that what allows functions like (+) do be passed? (+) is a reference to (+#). Can you pass an unboxed function (+#) to another function?
16:59:10 <merijn> yyttr3: No, (+) is not a reference to +#
16:59:27 <merijn> The Int instance of (+) is implemented using +#
17:00:12 <dcoutts_> specifically:  I# a + I# b = I# (a +# b)
17:00:23 <yyttr3> Where can I look at the source for more primitive things like +,*, Int, Float, etc
17:00:38 <merijn> None of those are primitive :)
17:00:57 <yyttr3> I said more "Primitive", not primitive per say
17:00:59 <dcoutts_> yyttr3: lots of them are exported from GHC.Exts
17:01:14 <merijn> Also, GHC.Prim
17:01:23 <dcoutts_> yyttr3: if you want to see how the primitives themselves are implemented, you have to look in the compiler sources
17:01:25 <seangrove> Hey all, what is the name of >>=?
17:01:34 * BMeph_ pedants: per se, not per say.
17:01:43 <dcoutts_> seangrove: bind
17:01:56 <seangrove> Thank you dcoutts
17:02:17 <dcoutts_> yyttr3: specifically compiler/prelude/primops.txt.pp
17:29:47 <seangrove> dcoutts_: And the names of <- -> ?
17:32:27 <kludgy> seangrove: <- is sugar for bind, but I've also seen it referred to as 'draw from'. -> is usually referred to as arrow.
17:32:54 <seangrove> kludgy: Thanks, that should help a bit with googling :)
17:32:56 <kludgy> ('draw from' coming from its application to list comprehension I suppose)
17:41:20 <heatsink> You can pronounce <- as "gets"
17:41:59 * hackagebot quickcheck-instances 0.3.9 - Common quickcheck instances  http://hackage.haskell.org/package/quickcheck-instances-0.3.9 (AntoineLatter)
17:42:11 <kludgy> seangrove: If you want to learn about the connection between draw-from and bind, google 'monad comprehensions' ;)  List comprehensions are a result of sequencing the list monad (hoogle sequence), and the concept generalizes to other monads.
17:43:03 <kludgy> seangrove: Rather it generalizes to all monads, to be strictly accurate.
17:43:14 <seangrove> kludgy: I was going through the 'Let's build a browser engine in Haskell Pt. 2.', ended up reading http://www.haskell.org/tutorial/monads.html as a reference, hasn't been too bad
17:43:46 <kludgy> seangrove: (y)
17:44:15 <RyanGlScott> Odd question: what exactly is going on when "let 0 = 1 in 0" is evaluated?
17:44:17 <RyanGlScott> > let 0 = 1 in 0
17:44:19 <lambdabot>  0
17:45:26 <RyanGlScott> Are numeric literals an exception to things that can't be redefined in GHCi?
17:46:16 <RyanGlScott> e.g., "let 1+1=3 in 1+1" evaluates to 3
17:52:49 <merijn> RyanGlScott: You are constructing a bottom pattern match and are immediately ignoring it
17:53:05 <merijn> RyanGlScott: "let 1+1=3" defines a partial function +
17:53:23 <merijn> > case 1 of 0 -> "str"
17:53:25 <lambdabot>  "*Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
17:53:37 <RyanGlScott> So "let 0 = 1 in 0" is effectively equivalent to "let _ = 1 in 0"?
17:54:03 <merijn> > let !0 = 1 in 0
17:54:04 <lambdabot>  *Exception: <interactive>:3:5-10: Non-exhaustive patterns in pattern binding
17:54:15 <merijn> See, strictness makes it break
18:04:57 <haasn> > case 1 of ~0 -> "str"
18:04:59 <lambdabot>  "str"
18:05:37 <haasn> > case 1 of !(~0) -> "str"
18:05:39 <lambdabot>  "str"
18:07:50 <haasn> RyanGlScott: Numeric literals like 0 and 1 are similar to constructors, not like variables
18:08:09 <haasn> If you include a variable in a pattern match, you're binding (defining) it; if you include a constructor in a pattern match, you're matching against it
18:08:21 <haasn> > let Nothing = Nothing in 0
18:08:23 <lambdabot>  0
18:08:51 <haasn> > let Nothing = Just 3 in 0 -- let 0 = 1 in ... works for the same reason this does
18:08:53 <lambdabot>  0
18:09:29 <haasn> > let !Nothing = Just 3 in 0 -- again, adding strictness requires the match to actually succeed even if no bound variables are referenced
18:09:31 <lambdabot>  *Exception: <interactive>:3:5-21: Non-exhaustive patterns in pattern binding
18:09:46 <RyanGlScott> That makes sense, thanks.
18:10:03 <haasn> The patterns “Nothing” and “0” both share the property that neither of them bind any variables
18:10:06 <haasn> Also,
18:10:12 <haasn> > let Nothing+Nothing = 3 in Nothing+Nothing
18:10:13 <lambdabot>  3
18:10:17 <haasn> :t let Nothing+Nothing = 3 in (+)
18:10:18 <lambdabot> Num a => Maybe t -> Maybe t1 -> a
18:12:05 * hackagebot taffybar 0.4.3 - A desktop bar similar to xmobar, but with more GUI  http://hackage.haskell.org/package/taffybar-0.4.3 (TristanRavitch)
18:14:09 <zwer> > case 1 of ~0 -> "str"
18:14:11 <lambdabot>  "str"
18:14:14 <zwer> > case 1 of ~1 -> "str"
18:14:16 <lambdabot>  "str"
18:14:24 <zwer> what is going on here?
18:14:40 <zwer> first time I see ~ used there and it is not making much sense
18:14:40 <haasn> (Numeric literals are indeed somewhat of an exception when it comes to pattern matching, though. Under the hood, numeric literals imitate constructors by using fromInteger for construction and (==) for matching - that is, matching x against 0 succeeds if (x == fromInteger 0) evaluates to True))
18:16:44 <haasn> zwer: ~pattern is equivalent to _ in that it matches everything. Variables can still be bound from “pattern”, and if you try to access them you run the risk of throwing an error at runtime (if the pattern match would otherwise have failed)
18:17:10 <haasn> In this case, no variables are being bound, so you could just as well have replaced the entire pattern by _
18:17:44 <haasn> So both expressions are equal to (case 1 of _ -> "str"), which is equal to just "str"
18:18:42 <haasn> > case Nothing of Just x -> "str"
18:18:44 <lambdabot>  "*Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
18:18:48 <zwer> thanks, got it
18:18:55 <haasn> > case Nothing of ~(Just x) -> "str"
18:18:57 <lambdabot>  "str"
18:18:58 <haasn> > case Nothing of ~(Just x) -> x
18:19:00 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Irrefutable pattern failed for patte...
18:19:35 <dibblego> int-e: ping
18:21:28 <haasn> > case Nothing of Just x -> (3, x) -- pattern match fails instantly
18:21:29 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
18:21:38 <haasn> > case Nothing of ~(Just x) -> (3, x) -- pattern match only fails when actually trying to access ‘x’
18:21:40 <lambdabot>  (3,*Exception: <interactive>:(3,1)-(4,22): Irrefutable pattern failed for pa...
18:21:51 <zwer> do you have an example where this would be useful? failing when accessing the matches variable, instead of during pattern matching.  I can't  really think of one
18:21:58 <zwer> matched*
18:22:07 * hackagebot binary-list 0.3.2.0 - Lists of size length a power of two.  http://hackage.haskell.org/package/binary-list-0.3.2.0 (DanielDiaz)
18:22:20 <haasn> zwer: As the example I just gave shows, ~ can be used to “delay” when something is actually evaluated
18:22:52 <haasn> An example of where this is nontrivial would be when constructing a recursive data structure that depends on itself
18:24:58 <haasn> zwer: One example I know off the top of my head is the reverse State monad
18:26:46 <haasn> It's like State, but the state modification flows “backwards”; do x <- get; put 3; ... -- x refers to 3
18:27:08 * hackagebot parsec 3.1.6 - Monadic parser combinators  http://hackage.haskell.org/package/parsec-3.1.6 (AntoineLatter)
18:27:10 * hackagebot hs-mesos 0.20.0.0 -   http://hackage.haskell.org/package/hs-mesos-0.20.0.0 (IanDuncan)
18:28:25 <mjrosenb> haasn: that is a neat trick.
18:28:33 * mjrosenb tries to think of how that would be implemented.
18:28:55 <haasn> mjrosenb: Do you know how the regular State monad is implemented?
18:30:03 <DanielDiaz> might help: http://hackage.haskell.org/package/transformers-0.4.1.0/docs/Control-Applicative-Backwards.html
18:30:04 <shachaf> With an adjunction!
18:30:13 <mjrosenb> haasn: maybe?
18:30:37 <mjrosenb> haasn: I implemented a state monad, but I have no clue how similar it is to the stdlib's State.
18:30:59 <haasn> mjrosenb: newtype State s a = State { runState :: s -> (a, s) }
18:31:17 <haasn> Write out (>>=) for that, passing the state from one action into the input of the next
18:31:35 <haasn> Then try making it so that the state passes through the functions in the opposite order
18:33:47 <mjrosenb> haasn: just to check, (>>=) :: State s a -> (a -> State s b) -> State s b?
18:33:53 <haasn> Yes
18:40:32 <spopejoy> is there a canonical way to do a running aggregate, e.g. [1,2,3,4] becomes [1,3,6,10]? concat.scanl comes to mind but it seems laborious
18:40:46 <mjrosenb> (State fa) >>= ff = State (\c -> let (c',a) = fa c in runState (ff a) c')
18:41:15 <shachaf> > scanl1 (+) [1,2,3,4]
18:41:16 <mjrosenb> > scanl1 (+) [1,2,3,4]
18:41:16 <lambdabot>  [1,3,6,10]
18:41:17 <lambdabot>  [1,3,6,10]
18:41:47 <shachaf> Unlike e.g. foldl1, scanl1 is not partial on empty lists.
18:42:09 <spopejoy> now, what if I also need to keep the original value, ie [1,2,3,4] -> [(1,1),(2,3) ...] ?
18:42:14 <mjrosenb> shachaf: makes sense
18:42:24 <spopejoy> the foldl1s want the types to be the same
18:42:36 <haasn> zip xs (scanl1 (+) xs)
18:42:44 <spopejoy> ah
18:42:51 * haasn .oO( zip `ap` scanl1 (+) )
18:43:12 <mjrosenb> scanl has a special place in my heart.
18:43:29 <haasn> mjrosenb: Re: (>>=), that's the (>>=) for the regular (“forwards”) version of State, right?
18:43:33 <mjrosenb> it is in a place of eternal contempt.
18:43:35 <mjrosenb> haasn: yes.
18:43:49 <spopejoy> i was half expecting the aztec god of consecutive numbers to make an appearance.
18:43:58 <mjrosenb> haasn: I wrote that with a different defintition of State many years ago, and I have been staring at assembly for the last 10 hours.
18:44:41 <spopejoy> mjrosenb: you prefer scanr . reverse?
18:44:50 <spopejoy> or reverse . scanr . reverse
18:45:35 <mjrosenb> spopejoy: so when I was taking an introduction to functional programming, about two days after we learned about fold, we had our midterm, and needed to derive scanl on the spot, given only its type
18:45:54 <mjrosenb> spopejoy: the class average on that test was 38/100, and I think two people got that question.
18:46:00 <spopejoy> ouch :)
18:46:49 <haasn> mjrosenb: A nice alternative way of writing it is:  x >>= f = State $ \s -> let (a, s') = runState x s; (b, s'') = runState (f a) s' in (b, s'')
18:47:08 <spopejoy> i've been foldl-ing and scanl-ing and i'm worried that if my ds's ever get large i'll wish i had -r'd
18:47:22 <haasn> This makes it pretty transparent which state goes where, from the input (\s -> ...) to the output (s'')
18:47:38 <mjrosenb> haasn: yeah, when I started writing it, I forgot that you could extract fields with their name.
18:48:11 <mjrosenb> then when I went to match on the result of ff a, I remembered "Ahh, there is a better way!"
18:49:57 <mjrosenb> haasn: it is almost like uncurry, with runState stuck in the middle :-)
18:50:55 <haasn> (and ‘f’)
18:51:45 <mjrosenb> haasn: well, f is the first argument to this demented uncurry.
18:52:09 <mjrosenb> I should have said, this is like using uncurry, rather than this is like the definition of uncurry.
18:52:23 * hackagebot hopenpgp-tools 0.9.1 - hOpenPGP-based command-line tools  http://hackage.haskell.org/package/hopenpgp-tools-0.9.1 (ClintAdams)
18:53:10 <spopejoy> > zip <*> scanl1 (+) $ [1,2,3,4]
18:53:11 <lambdabot>  [(1,1),(2,3),(3,6),(4,10)]
18:53:45 <haasn> I was thinking along the lines of: let (a, s') = ... in foo a s'  ===  uncurry foo (...)
18:54:00 <haasn> In this case, uncurry (runState . f)
18:54:16 <haasn> But either way, that's not what started this; rather how to thread reverse state
18:54:27 <mjrosenb> right.
18:55:26 <haasn> All we have to do to turn this into a reverse state monad is change the ordering of the s' and s''
18:55:31 <mjrosenb> so  ReverseState s a = { runRState :: s -> (s,a) }, or does it need a different type?
18:55:45 <haasn> It's the same type
18:55:52 <mjrosenb> that's cool.
18:55:55 <solatis> does anyone here actually use structured-haskell-mode with emacs?
18:55:59 <shachaf> Well, you need a different type to give it a different instance.
18:56:19 <solatis> i'm still trying to get used to it, but some things appear to be a severe problem
18:56:22 <mjrosenb> shachaf: the type that I gave would give it a new name, so they won't conflict.
18:56:33 <shachaf> Right.
18:56:40 <shachaf> (Well, except you were missing a constructor.)
18:56:46 <mjrosenb> solatis: I use emacs with haskell, I'm not sure if I use structured-haskell-mode.
18:56:57 <mjrosenb> shachaf: hush, you.
18:57:07 <solatis> mjrosenb: you would know :)
18:57:14 <haasn> I wish “hush, you.” worked for GHC error messages
18:57:28 <shachaf> -fdefer-type-errors
18:57:30 <haasn> Every time I forget to add a constructor name to a newtype
18:57:42 <shachaf> -fdefer-syntax-errors
18:57:48 <haasn> -fdefer-logic-errors
18:58:07 <mjrosenb> -fdefer-execution
18:58:10 <simpson> Those can't be right. They aren't fun enough.
18:58:27 <simpson> -fundo-printing-type-errors
18:58:29 <simpson> See, "
18:58:35 <simpson> "fun do" it's fun to do it!
18:59:26 <mjrosenb> haasn: yeah, so the way you defined it, since both s' and s'' are bound in the same let, they are mutually recursive with the expressiens that are being bound to them, and you can literally just switch s' and s''.
18:59:36 <monochrom> -fholes
18:59:38 <haasn> mjrosenb: Exactly
18:59:41 <solatis> mjrosenb: just in case you care... https://github.com/chrisdone/structured-haskell-mode
18:59:55 <mjrosenb> solatis: ahh, yeah, I use vanilla haskell-made.
19:00:18 * monochrom has a cunning plan! -fdefer-holes
19:00:54 <solatis> mjrosenb: yeah i'm currently in doubt whether or not i continue 'learning' SHM or whether to just give up.. some things are just too annoying
19:01:13 <solatis> (and it's most likely a pebkac situation)
19:01:41 <solatis> https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md
19:01:46 <solatis> that's a pretty good gem, by the way
19:02:21 <haasn> mjrosenb: Well, in the way I defined it, there's no recursion. But there would be recursion if you swap the s' and s''
19:02:44 <haasn> But we can do this precisely because ‘let’ bindings can be mutually recursive
19:03:21 <mjrosenb> haasn: I like to think of it as always being mutually recursive, just the expression may not use any of the mutually-recursively-bound variables.
19:04:30 <spopejoy> OK next question: that scanl1 (+) xs: is it possible to do this under something like zyxs & (mapped.mapped) %~ magicscanl (+)
19:05:14 <haasn> monochrom: When are we getting -fill-holes?
19:06:23 <mjrosenb> spopejoy: whate are (&) and (%~)?
19:06:35 <haasn> They are most likely functions from the package ‘lens’
19:06:51 <haasn> (&) = flip ($)
19:06:54 <spopejoy> mjrosenb: lens stuff. (&) is ($) reversed, to match the rightward composition of lenses
19:07:11 <spopejoy> (%~) is over
19:07:25 <shachaf> spopejoy: No, you need a traversal.
19:07:44 <mjrosenb> :t over
19:07:45 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
19:07:46 <shachaf> > scanl1Of (traverse.traverse) (+) [[1,2,3],[4,5,6],[7,8,9]]
19:07:47 <lambdabot>  [[1,3,6],[10,15,21],[28,36,45]]
19:08:05 <spopejoy> "scanl1Of" too!
19:09:42 <ezyang> Oh wow! I learned something interesting today
19:10:04 <vanila> what did you learn
19:10:06 <vanila> ?
19:10:33 <ezyang> that you can't implement fmap for Maybe by writing the Nothing case as fmap f x@Nothing = x
19:10:51 <shachaf> ezyang: That part isn't so sad.
19:10:56 <vanila> hmm that isn't interesting
19:11:00 <kvanb> ezyang: is that because the type changes?
19:11:05 <shachaf> ezyang: You can't write fmap for (Either e) by writing fmap f x@(Left _) = x
19:11:05 <ezyang> yes
19:11:16 <ezyang> shachaf: Yes, /that/ is the unfortuante bit
19:11:18 <shachaf> And if you write fmap f (Left x) = Left x, you get an extra allocation.
19:11:19 <shachaf> Yay.
19:11:19 <kvanb> technically as an optimisation you could unsafeCoerce the x
19:11:23 <kvanb> <.<
19:11:32 <shachaf> Yep.
19:11:41 <kvanb> I proposed a compiler optimisation somewhere on trac for ghc to do something similar
19:11:43 <ezyang> it's almost as if you want reverse-GADTs
19:11:56 <ezyang> undo type equality!!
19:11:58 <shachaf> monochrom found something interesting the other day which was vaguely related.
19:12:24 <shachaf> If you have e.g. f :: (forall a. Blah a => a) -> ...; f x@(Constructor ...) = ..., x will remain polymorphic
19:12:33 <kvanb> I have this Pipes pipeline where I threaded this 3-arity tuple-like type through 3 handlers that eventually made a type with all three type params equal
19:12:39 <kvanb> which fused into the single output type
19:12:49 <kvanb> I had to re-construct it each time
19:13:00 <monochrom> unfortunately fmap cannot afford a rank-2 type :)
19:13:01 <kvanb> the original motivation was I'd be in heaven if GHC realised this and coerced them
19:13:28 <ezyang> The problem is that it's unclear how to represent this in System FC
19:13:36 <kvanb> there was a suggestion on the ticket
19:13:39 <kvanb> to extend case to do it
19:13:43 <spopejoy> :( hackage lens docs are missing
19:13:49 <kvanb> I will find the ticket
19:13:53 <shachaf> spopejoy: Click the previous version.
19:13:55 <merijn> spopejoy: Don't you build local docs when installing?
19:14:10 <kvanb> https://ghc.haskell.org/trac/ghc/ticket/9291
19:14:16 <kvanb> ezyang ^
19:14:37 <monochrom> an example is at http://lpaste.net/110769
19:15:22 <kvanb> the suggestion I was talking about was comment 6 by rwbarton
19:15:26 <ezyang> oh, I like SPJ's suggestion
19:15:30 <ezyang> let's make this an STG opt
19:16:30 <ezyang> Hmm, I wonder if this pattern is a union type in disguise
19:16:40 <kvanb> I did some digging and couldn't findmany existing stg opts
19:16:50 <kvanb> so someone really familiar with the stg would have to do it
19:16:56 <ezyang> no, we try to avoid it, because it's untyped
19:17:06 <ezyang> in fact, I think we don't do any, atm
19:17:19 <kvanb> in the back of my mind I forsee that this could be a misoptimisation
19:17:22 <spopejoy> schachaf: my req is to decorate a datastructure with the scanl1'd value. I would think I should first 'mapped.over' my way to the new structure, copying the counting value, and then scanl1Of.traverse to transform it.
19:17:27 <kvanb> but at the same time, theres likely to be big wins in places
19:17:46 <shachaf> spopejoy: I bet you can combine that.
19:17:51 <kvanb> the reason it could be a misoptimisation is because it could cause less junk to be created and more stuff to survive gen1 in the gc
19:17:52 <shachaf> ezyang: Hmm, I wonder if you've thought about unboxed sums at all.
19:17:54 <kvanb> which is bad.
19:18:29 <ezyang> shachaf: not more than most rascals have :P
19:18:39 <ezyang> kvanb: that seems like a silly thing to be worried about
19:19:12 <kvanb> not necessarily. I could craft some code that constipates the gc given the above optimisation, probably
19:19:12 <shachaf> ezyang: How much is that?
19:19:37 <ezyang> just because you can craft it doesn't mean it's legitimate
19:19:59 <ezyang> shachaf: enough to know that it would be annoyingly tricky
19:20:03 <kvanb> it's in everyones best interest to not craft another full laziness pass!
19:20:14 <kvanb> Gosh, half the programs ever written get a perf win by -fno-full-laziness
19:20:31 <ezyang> ok, I see, yes maybe you're right
19:21:23 <shachaf> ezyang: Any details written anywhere?
19:21:44 <ezyang> shachaf: No
19:21:54 <shachaf> It sounds like CSR could be a very useful optimization. But I don't actually know if it would be.
19:21:57 <ezyang> but it's sort of related to the Maybe null pointer optimization
19:22:18 <shachaf> Sure.
19:22:41 <shachaf> It's also related to the whole thing where people switched from Bool to Int#.
19:23:07 <shachaf> It seems like maybe it wouldn't be that tricky to get the optimization just for enumerations.
19:23:52 <kvanb> ezyang: is there a Maybe null pointer optimisation?
19:24:27 <ezyang> no but people have wanted it for a while
19:24:42 <shachaf> I sure hope people don't special-case it in some horrible way.
19:24:56 <ezyang> https://ghc.haskell.org/trac/ghc/ticket/4937
19:25:27 <shachaf> Anyway I was thinking about how well you could make CSR/CSPR work.
19:25:40 <spopejoy> shachaf: here's the ds: (1,[([2],3),([4],5),([6,7],8)]). (_2.traverse._2) is the count value, but I need to preserve it.
19:25:43 <shachaf> I don't know enough about GHC to know how difficult it would be. But it sounds like the answer is "annoyingly tricky".
19:25:53 <spopejoy> > let ds = (1,[([2],3 :: Int),([4],5),([6,7],8)])
19:25:54 <lambdabot>  not an expression: ‘let ds = (1,[([2],3 :: Int),([4],5),([6,7],8)])’
19:26:07 <spopejoy> > define ds = (1,[([2],3 :: Int),([4],5),([6,7],8)])
19:26:08 <lambdabot>  <hint>:1:11: parse error on input ‘=’
19:26:15 <shachaf> Maybe a first step would be "unboxed sums" corresponding to "unboxed tuples".
19:26:27 <shachaf> I don't know what the best representation of that would be.
19:27:43 <ezyang> you've got to store the tag bit somewhere
19:27:46 <spopejoy> @define ds = (1,[([2],3 :: Int),([4],5),([6,7],8)])
19:27:48 <kvanb> hmm, neat. tagging the pointer lets you up to 4 constructors distinguishable without peeking it
19:27:48 <lambdabot>  Defined.
19:28:02 <ezyang> so (Either# Int# Int#) is right out, you just don't have enough bits
19:28:21 <shachaf> I'm fine with an extra register or something for the tag.
19:28:40 <spopejoy> > ds & (_2.mapped) %~ (\a -> (a, snd a))
19:28:43 <lambdabot>  (1,[(([2],3),3),(([4],5),5),(([6,7],8),8)])
19:28:58 <kvanb> well, on 64-bit you have shittons of bits upper
19:29:04 <kvanb> on 32 we're clean out.
19:29:15 <shachaf> E.g. "f :: ... -> Maybe T" into "f :: ... -> (# Int#, T #)", where the T might be _|_ for Nothing.
19:29:20 <kvanb> all the alignment bits have been used up I think
19:29:27 <shachaf> That would be the obvious transformation by hand.
19:29:53 <shachaf> kvanb: You're not *really* supposed to use those. :-)
19:30:05 <kvanb> yes but we won't have petabytes of ram for a little while
19:30:42 <monochrom> from Maybe T to (# Int#, T #) is the Java transformation XD
19:30:55 <shachaf> monochrom: I don't mind as long as the compiler makes it for me.
19:31:07 <spopejoy> > scanl1Of (_2.traverse._2) (+) $ ds & (_2.mapped) %~ (\a -> (a, snd a))
19:31:09 <lambdabot>  (1,[(([2],3),3),(([4],5),8),(([6,7],8),16)])
19:31:21 <spopejoy> shachaf: ^^
19:31:22 <ezyang> I guess Either# a b == (# Bool#, Union# a b #) would work OK
19:31:44 <kvanb> ezyang: gotta generalise it
19:31:47 <kvanb> Bool# -> Int#
19:31:56 <kvanb> What about Either3 a b c
19:32:00 <shachaf> I'd want n-ary sums, sure.
19:32:04 <shachaf> Just like you had n-ary tuples.
19:32:10 <monochrom> \∩/
19:32:14 <shachaf> ezyang: I don't know this Union# thing.
19:32:15 <kvanb> gotta go bye
19:32:22 <shachaf> Does it work with unboxed types?
19:32:28 <ezyang> shachaf: It doesn't exist, I'm justanalogizing with C struct unions
19:32:41 <shachaf> Oh.
19:32:46 <shachaf> Then sure.
19:33:01 <shachaf> You might need do some extra work for the GC to handle it correctly.
19:33:41 <ezyang> the point of unboxed types is that the GC never sees them
19:33:54 <ezyang> erm, unboxed tuples, I mean
19:35:21 <shachaf> In the case of an Enum you could just have the Int#, of course.
19:37:24 <spopejoy> jeez, Control.Lens.Traversal *Of methods are deeeeep
19:37:52 <spopejoy> "methods". Java guy in the room
19:37:52 <edwardk> spopejoy: yeah we wrote a few =)
19:40:06 <begriffs> Has anyone configured vim's tagbar to show Haskell types?
19:41:03 <spopejoy> edwardk: do you see a more efficient (or at least one-pass) way to do a scanl1Of <- mapped %~ operation?
19:41:11 <spopejoy> > ds
19:41:12 <lambdabot>  (1,[([2],3),([4],5),([6,7],8)])
19:41:24 <spopejoy> > scanl1Of (_2.traverse._2) (+) $ ds & (_2.mapped) %~ (\a -> (a, snd a))
19:41:27 <lambdabot>  (1,[(([2],3),3),(([4],5),8),(([6,7],8),16)])
19:41:49 <shachaf> This weird middle-fix syntax thing is kind of hard to read.
19:44:51 <spopejoy> > scanl1Of (_2.traverse._2) (+) . over (_2.mapped) (\a -> (a, snd a)) $ ds
19:44:53 <lambdabot>  (1,[(([2],3),3),(([4],5),8),(([6,7],8),16)])
19:50:51 <mhall> is the concept of 'friend' meaningful in haskell? there's a statement lf LYAH where it says Num is 'friends' with Eq and Show
19:51:07 <edwardk> mhall: not a meaningful notion
19:51:26 <mhall> is what they are saying that there is an instance Num Int, and Int is an instance of Eq and Show?
19:51:35 <geekosaur> also no longer true, I think
19:51:59 <gcganley> mhall: not significant except to explain a concept
19:52:01 <edwardk> it used to be that class (Show a, Eq a) => Num a -- e.g. that Num had superclasses Eq and Num, but that doesn't hold any more in GHC at least
19:52:18 <mhall> okay, thanks
19:52:22 <geekosaur> so, not friends in the C++ sense
19:52:23 <edwardk> there were counter-examples for each
19:52:35 <gcganley> they are just explainsg type class relations
19:53:16 <lpaste> solatis pasted “debugging and memoization” at http://lpaste.net/110822
19:53:28 <solatis> ok, consider that paste
19:53:55 <solatis> are there any optimizations lost when doing 'myfun a = read a' instead of 'myfun = a' ?
19:54:06 <solatis> ehr
19:54:09 <solatis> myfun = read
19:54:10 <solatis> sorry
19:54:29 <solatis> or is it merely a style issue?
19:54:36 <mgaut72> I have a parser for some subset of C written in parsec.  I am interested in some sort of error recovery in my parser (yacc-ish?).  Any thoughts on how to go about this? I know parsec's policy is "fail fast" but still...
19:55:56 <solatis> (or am i asking a silly question?)
19:56:58 <geekosaur> isn't the usual way to use <|>?
19:57:16 <geekosaur> solatis: they should be identical in behavior
19:57:59 <geekosaur> style is one of the reasons to use the expanded form; avoiding the need to write a type signature or otherwise avoid the monomorphism restriction is another
19:59:25 <solatis> i understand, thanks
19:59:39 <solatis> is it generally considered to be a good thing to not having to write a type signature?
19:59:55 <solatis> (as in, let the compiler evaluate it itself?)
20:00:36 <geekosaur> mgaut72, in slightly more detail: use something like parser <|> messageAndErrorRecovery (if parser can consume input before failing, wrap it in try)
20:00:40 <glguy_> solatis, It will also affect performance in some sitations because it changes how inlining works
20:01:02 <geekosaur> solatis, it depends. some people prefer to make use of Haskell's type inference; others have the philosophy of always writing type signatures and often writing them before implementations to help with debugging and development. (I'm one of the latter, mostly)
20:01:06 <geekosaur> but there are arguments for both
20:01:49 <solatis> i come from a c++ background, so being explicit in type signatures is what feels natural to me -- you catch compile-time errors as early as possible
20:01:56 <mgaut72> geekosaur: I understand that I can use "try p1 <|> p2" or some other equivalent, but I might need to know information about why p1 failed to (attempt to) properly recover.  is that possible
20:02:03 <tabemann> writing type signatures avoids the horrid monomorphic restriction
20:02:24 <solatis> let me google that
20:02:39 * hackagebot scotty 0.9.0 - Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp  http://hackage.haskell.org/package/scotty-0.9.0 (SimonHengel)
20:02:53 <geekosaur> @where dmr
20:02:54 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
20:03:10 <geekosaur> (the "d" is for "dreaded", or sometimes stronger words...)
20:04:04 <solatis> aha i get it
20:04:14 <solatis> makes sense, especially when using things like 'read'
20:04:31 * mjrosenb kind of wishes that haskell let me provide partial type signatures.
20:04:51 <mjrosenb> or it does, and I wish I knew how to do that :-p
20:05:38 * tabemann used to never write type signatures except in interfaces when he worked in OCaml, but now he always writes type signatures for top level declarations
20:05:38 <solatis> mjrosenb: http://www.haskell.org/pipermail/ghc-devs/2014-March/004239.html :)
20:06:01 <solatis> yeah i even write type signatures within 'where' clauses
20:06:38 <solatis> for me it allows me to instantly see what a function is supposed to do
20:06:41 <geekosaur> mjrosenb, there are various hacks possible currently
20:06:50 <solatis> without having to understand the function definition
20:06:59 <solatis> (and without having to add comments)
20:07:54 <geekosaur> for example you can use dummy guards which do something that fixes some types, then always fail (or always succeed, but it's often nicer to have the dummy guard be separate from your actual logic)
20:08:00 <mjrosenb> solatis: I think a better solution would be to have an editor that can run type inference, and just display the type of any expression on demand.
20:08:10 <mjrosenb> solatis: that way, you can also get the type of a subexpression.
20:08:56 <geekosaur> mjrosenb, that actually only addresses part of it, because you need enough of a program to be complete for type inference to work when that inference is affected by uses in widely separated places
20:08:57 <mjrosenb> solatis: YEEEEEES.
20:09:20 <mjrosenb> geekosaur: true.
20:09:46 <geekosaur> in addition, when ghc outputs a type error, how closely it can loalize ther actual error depends on how well the types are pinned down --- and the same applies to your IDE, since it's an attribute of type inference
20:09:57 <solatis> mjrosenb: interesting point of view
20:10:17 <geekosaur> the more you pin down your types, the better it can point you to the place you made a mistake instead of trying to guess based on how you used it
20:10:22 * merijn mumbles something about lamdu
20:10:34 <mjrosenb> geekosaur: well, that is where the sub-expressions come in, you can just ask for the type of narrower subexpressions, until you find the thing that isn't what you expect.
20:11:35 <geekosaur> that's fine except when the expression where it *detected* the problem is not where you made the mistake, that's a couple dozen (or hundred) lines earlier or later
20:11:54 <geekosaur> this happens a *lot* with numerics, thanks to the way Num subclasses are architected
20:12:02 <solatis> merijn: you are using lamdu?
20:12:28 <solatis> how stable is it?
20:13:07 <geekosaur> accidentally divide by an Int somewhere, find out where you use the Int elsewhere in an apparently unrelated thing
20:13:18 <geekosaur> type inference does things that people tend not to expect
20:13:31 <mjrosenb> geekosaur: yeah... that is super fun.
20:14:12 <mjrosenb> geekosaur: but still, you use the int 500 lines away, in an expression, which now has the wrong type
20:14:24 <merijn> solatis: No, it doesn't even have a compiler yet, afaik :)
20:14:28 <mjrosenb> you check the types of its constituents, you find that a function has the wrong type
20:14:37 <mjrosenb> go to its definiton, check types there
20:14:47 <mjrosenb> repeat until you get to the variably with the wrong type.
20:14:56 <tabemann> stupid question: from looking at Data.ByteString.UTF8, I found that it defines toString as toString bs = foldr (:) [] bs - which implies it doesn't do any decoding at all... is this right?
20:15:16 <solatis> merijn: then i guess i'll just stick with emacs :)
20:15:31 <solatis> but the effort looks interesting
20:15:44 <geekosaur> yes, but you have to do all that extra searching. if you include the expected type signatures, it can tell you immediately that you used (/) on an Int
20:15:57 <geekosaur> one gets tired of all that tracking stuff down rather quickly in practice
20:16:02 <mjrosenb> merijn: meh, just run it through an interpreter, no need to compile it!
20:16:09 <tabemann> oh I got it
20:17:05 <geekosaur> so I pretty much write type signatures for everything except xmonad's layout hooks (because the types are often longer than the definitions)
20:17:41 * hackagebot boundingboxes 0.2.1 - A generic boundingbox for an arbitrary vector  http://hackage.haskell.org/package/boundingboxes-0.2.1 (FumiakiKinoshita)
20:18:15 <merijn> mjrosenb: There's no interpreter for it either :p
20:18:33 <merijn> tabemann: Data.ByteString.UTF8 where did you find this?
20:18:48 <merijn> tabemann: Are you perhaps refering to the pox most vile, called Char8?
20:19:26 <mjrosenb> merijn: what is wrong with Char8? :-p
20:19:28 <geekosaur> utf8-string package, which is mostly but not completely obsolete at this point
20:19:35 <tabemann> no, I mean Data.ByteString.UTF8
20:19:46 <tabemann> what should I use instead of it?
20:19:54 <merijn> Text.Encoding?
20:19:59 <geekosaur> because there are things that ghc doesn't know to automatically convert encodings for
20:20:33 <geekosaur> and utf8-string is often more convenient especially when writing to an interface that is guaranteed to use only utf8
20:20:45 <octopuscabbage> the list monads bind is essentially just mapping a function to each element in the list correct?
20:21:53 <mjrosenb> ok, so out of curiosity, if I'm actually just dealing with a sequence of bytes, what should I use?
20:21:54 <tabemann> okay, why can't hackage find the package text-1.2.0.0?
20:22:17 <merijn> mjrosenb: ByteString?
20:22:19 <tabemann> or more like why is there no documentation for the package
20:22:29 <merijn> mjrosenb: ByteString has nothing to do with String
20:22:58 <mjrosenb> merijn: doesn't it still do the UTF-16 conversion?
20:23:07 <mjrosenb> I remember looking at it, and thinking it would add too much overhead.
20:23:15 <solatis> mjrosenb: it does? that's crazy!
20:23:16 <merijn> mjrosenb: Wut?
20:23:29 <mjrosenb> my memory from last month is a bit fuzzy.
20:23:29 <merijn> mjrosenb: I think you're way confused with Text
20:23:37 <mjrosenb> merijn: entirely possible!
20:23:43 <solatis> bytestring should be called bytearray imho ;)
20:23:49 <merijn> ByteString is just densely packed word8
20:23:54 <geekosaur> if this question is about Char8, the problem is that it's lossy in the case where the String contains codepoints wider than a byte
20:24:04 <merijn> solatis: It's not an array, though, but yeah it should just be called Bytes
20:24:08 <merijn> solatis: But too late now
20:24:13 <geekosaur> Word8 ensures this can't happen; Char8 just truncates, with no warning
20:24:16 <solatis> yeah or whatever, `string` is just too confusing
20:24:24 <solatis> because people associate string with text
20:25:05 <mjrosenb> yup. nevermind me.
20:25:24 <mjrosenb> I rejected Text because of that, and ByteString for a different reason.
20:25:55 <solatis> mjrosenb: well thanks for that question, being a haskell noob it's great to finally be able to answer a question in #haskell ;)
20:29:27 <tabemann> okay, it seems that I'[ll just use Data.ByteString.UTF8, because all using Data.Text.Encoding will do is force me to go through an extraneous Data.Text intermediate stage when all I really want to do is convert string literals (String values) into UTF8 ByteStrings
20:47:19 <lpaste> blueonyx pasted “state and scope” at http://lpaste.net/110824
20:47:45 * hackagebot secret-sharing 1.0.0.2 - Information-theoretic secure secret sharing  http://hackage.haskell.org/package/secret-sharing-1.0.0.2 (PeterRobinson)
20:48:39 <geekosaur> blueonyx, where scopes to an entire definition. use let
20:50:18 <mjrosenb> geekosaur: I'm not sure that is what their problem is.
20:51:10 <jle`> so i tried implementing different instances for a church-encoded Maybe, data Mayb t a = Mayb { withMayb :: t -> (a -> t) -> t }
20:51:17 <geekosaur> the reason it "works" in the first one is that, with the indentation, the where is scoped to x' (that is, you get: ... >>= \x -> {x' where x' = ...})
20:51:21 <jle`> i was able to do Functor, Applicative, Alternative, Monad, MonadPlus...
20:51:29 <jle`> for (Mayb t)
20:51:38 <jle`> but i'm having trouble with Foldable and I'm not sure if it's possible
20:51:41 <geekosaur> indentation rules are sometimes confusing
20:52:25 <blueonyx> ^ how do you cope with State and scope?
20:52:25 <blueonyx> where to put the let?
20:52:25 <jle`> is Foldable impossible?
20:52:49 <geekosaur> note that in the second, where is outdented relative to the definition of x --- it therefore exists in an outer scope to where x is defined
20:53:32 <lpaste> geekosaur annotated “state and scope” with “state and scope (annotation)” at http://lpaste.net/110824#a110826
20:53:47 <geekosaur> ooh, lpaste bot is back
20:54:35 <jle`> it was a pleasant surprise
20:54:37 <geekosaur> remember that indentation indicates scope. if you have the "where" outdented relative to something, that something will not be visible in the "where".
20:56:26 <geekosaur> possibly if the where were indented more relative to either the word "get" on line 13 or the indentation on line 14, it might work --- but this is not something I like to rely on; I generally consider "where" to be suitable for scoping over multiple definitions and prefer "let. (this is admittedly a personal style thing --- but this does not relieve you from paying attention to indentation)
20:56:50 <blueonyx> geekosaur: hm it doesnt work for me, my ghc 7.6.3 gives "not is scope", but lpaste just reports the redundant do, so is x in scope there?
20:56:50 <blueonyx> not in scope for both cases
20:56:50 <blueonyx> geekosaur: but my actual definition of x' is more komplex, so i want to define it afterwards :/
20:57:25 <geekosaur> lpaste (actually hlint) is not a syntax checker, it is a heuristic style checker
20:57:45 <geekosaur> it will happily check the style of invalid code
20:59:01 <mjrosenb> jle`: isn't fold on Maybe just (fromMaybe zero)? (I forget what the zero of a Monoid is called)
20:59:23 <mjrosenb> ahh, mempty
20:59:46 <geekosaur> I am not exactly sure where the first one is binding the where, scope-wise; I would probably have to feed it to ghc with one of the options to show desugaring
21:00:07 <geekosaur> the second one is clearly wrong but I don't know offhand how to fix the where
21:01:03 <blueonyx> geekosaur: okay, thanks so far, i'll just pass x as parameter
21:01:26 * geekosaur should probably give up for the night, getting too tired...
21:06:20 <jle`> :O
21:09:05 <mjrosenb> jle`: actually everything in the class looks like it is just a function in Data.Maybe, possibly with an argument from Monoid.
21:09:23 <jle`> mjrosenb: the problem is that it's instance Foldable (Mayb t)
21:09:46 <jle`> so fold :: Monoid m => Mayb t m -> m
21:10:03 <jle`> but the type of fromMayb :: t -> Mayb t t -> t
21:10:23 <jle`> so fromMayb mempty :: Monoid m => Mayb m m -> m
21:10:48 <jle`> the t parameter has to be the same as the a parameter to be able to use fromMayb mempty
21:11:10 <jle`> but you can't guaruntee it because it's instance Foldable (Mayb t)
21:11:11 * mjrosenb looks back at the definition of Mayb
21:17:17 <triliyn> jle`: maybe you want data Mayb = Mayb { withMayb :: forall t. t -> (a -> t) -> t }?
21:17:26 <triliyn> *data Mayb a
21:17:45 <jle`> yeah, i'm trying that out now, at the suggestion of copumpkin
21:19:13 <jle`> oh okay
21:19:18 <jle`> yeah i tried it last night and it didn't work
21:19:32 * dfeuer wonders if he could bake a copumpkin copie.
21:19:37 <jle`> it's because i did data Mayb = forall t. Mayb { withMayb :: t -> (a -> t) -> t }
21:19:44 <copumpkin> ah
21:19:45 <copumpkin> that's existential
21:20:10 <jle`> yea
21:20:16 <jle`> silly me :)
21:20:43 <dfeuer> jle`, I don't understand what that type could be used for.
21:21:07 <jle`> it's morally isomorphic to Maybe
21:21:19 <copumpkin> if you make it a newtype, it's exactly isomorphic
21:21:44 <jle`> i say morally because my brain hurts too much to think about bottom stuff
21:21:49 <copumpkin> :)
21:22:03 <jle`> toMaybe :: Mayb a -> Maybe a
21:22:11 <jle`> toMaybe m = withMaybe m Nothing Just
21:22:25 <jle`> dfeuer: it's mostly for funsies
21:22:52 <copumpkin> jle`: intresting also to tinker with church vs. scott encodings of actual recursive types
21:23:05 <jle`> i have to look up scott encodings then
21:23:27 <copumpkin> or do ski's favorite exercise, and define lists by their church encoding
21:23:32 <copumpkin> and then write zipWith
21:23:50 <dfeuer> jle`, I see now that the type I was looking at was the accidentally existential one, which didn't make any sense.
21:23:51 <copumpkin> (note, it's pretty hard, if you don't go via intermediate lists)
21:24:23 <dfeuer> Church encoding meaning lambda calculus stuff?
21:24:57 <jle`> yeah, encode Maybe with only functions
21:27:26 * mjrosenb has had fun with data MMaybe f a = MJust (f a) | MNothing (f ())
21:27:58 <mjrosenb> (at least I think it was f (), it may have just been MNothing.
21:28:21 <dfeuer> pair a b = \ selector -> selector a b
21:28:31 <jle`> is that a type level maybe or sumtin
21:28:45 <dfeuer> fst p = p const
21:28:51 <mjrosenb> jle`: nope, I did it in sml :-p
21:28:57 <jle`> ah
21:29:29 <mjrosenb> jle`: but it is higher order, so when f is the identity, you get regular old maybe.
21:29:31 <dfeuer> snd p = p (const id)
21:29:43 <dfeuer> er ... that's wrong.
21:30:47 <dfeuer> No, that's right, actually.
21:30:51 <mjrosenb> jle`: then lists are: newtype MList a = List (MMaybe MList a)
21:31:00 <jle`> :D
21:31:04 <jle`> i will play with that later, ty
21:32:02 <dfeuer> OK, so with pairs and maybes you get lists, right?
21:32:07 <dfeuer> Or something.
21:32:13 <mjrosenb> oh,
21:32:14 <mjrosenb> right.
21:32:17 <mjrosenb> that isn't list...
21:32:21 <mjrosenb> you need a pair in there.
21:32:22 <mjrosenb> but yes
21:32:29 <mjrosenb> and you can also define trees similarly.
21:33:45 <mjrosenb> what I called MList is data Foo a = Foo (Foo a) | Bar a, /kind/ of an encoding of integers, with a pointless type variable
21:38:27 <mjrosenb> type synonyms need to be fully applied?
21:39:33 <geekosaur> yes
21:40:00 <mjrosenb> bummer.
21:40:06 <mjrosenb> I think I've run afoul that in the past.
21:42:46 <fiore> .
21:43:09 <mjrosenb> ahh, there we go.
21:44:05 <mjrosenb> > Newtype A = F Int; F 4
21:44:06 <lambdabot>  <hint>:1:11: parse error on input ‘=’
21:44:16 <mjrosenb> > newtype A = F Int; F 4
21:44:17 <lambdabot>  <hint>:1:1: parse error on input ‘newtype’
21:44:30 <mjrosenb> ok, guess I need to wrap it in a .... let?
21:44:48 <jle`> no local newtypes unfortunately
21:45:14 <jle`> you have to add a line to L.hs
21:45:18 <jle`> using @let
21:45:25 <mjrosenb> local datatypes?
21:45:34 <jle`> local to a function scope/let block
21:45:34 <mjrosenb> they're equivalent for my needs.
21:45:46 <dfarm> Hi all, I'm looking for a little help with Attoparsec. I'm basically trying to figure out how to parse multiple rows of tab delimited doubles the silly code and a sketch of how I think it should look is at http://lpaste.net/3356419304332460032
21:57:55 <mgaut72> dfarm check out (<*)
21:58:04 <mgaut72> @hoogle (<*)
21:58:06 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
21:58:06 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
21:58:06 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
22:00:24 <dfarm> mgaut72: Awesome, that's exactly what I was looking for.
22:00:52 <mgaut72> dfarm: I just hoogled the type signature
22:01:05 <mgaut72> @hoogle m a -> m b -> ma
22:01:06 <lambdabot> Foreign.Ptr minusPtr :: Ptr a -> Ptr b -> Int
22:01:06 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
22:01:06 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
22:01:34 <mgaut72> haha awk.  on real hoogle that actually gave the result I gave to you
22:01:37 <dfarm> mgaut72: I was trying to sequence things with (.) which I guess doesn't work because it wants functions and skipSpace and double are Parsers
22:02:16 <dfarm> That's good to know. I actually was aware of Hoogle but I didn't think to try it, need to add that to my list of things before asking on IRC.
22:02:37 <mgaut72> dfarm: yea.  you wanted "sequencing" in the Applicative sense
22:03:24 <mjrosenb> mgaut72: I think you forgot a space betwen the last 'm' and 'a'.
22:03:26 <mjrosenb> *between
22:03:43 <mgaut72> mjrosenb: nice catch
22:05:11 <dfarm> I appreciate it
22:22:31 <silasm> > let remove x (y:ys) = if (x==y) then ys else y:remove x ys; remove x [] = []; permutations xs = xs >>= \x -> map (x:) . permutations . remove x $ xs in permutations "123"
22:22:33 <lambdabot>  []
22:22:40 <silasm> can someone explain that to me? o.O
22:22:51 <silasm> I'm not seeing my error there
22:23:56 <BMeph_> silasm: Here's a hint:
22:25:05 <BMeph_> > [] >>= (\x -> map (x:)) $ []
22:25:07 <lambdabot>  Couldn't match expected type ‘[t0] -> t’ with actual type ‘[b0]’Couldn't mat...
22:25:07 <lambdabot>              with actual type ‘[[a0]] -> [[a0]]’
22:25:07 <lambdabot>  Relevant bindings include x :: a0 (bound at <interactive>:1:10)
22:25:17 <BMeph_> > [] >>= (\x -> map (x:)) $ [[]]
22:25:18 <lambdabot>  Couldn't match expected type ‘[[t0]] -> t’ with actual type ‘[b0]’Couldn't m...
22:25:18 <lambdabot>              with actual type ‘[[a0]] -> [[a0]]’
22:25:18 <lambdabot>  Relevant bindings include x :: a0 (bound at <interactive>:1:10)
22:25:43 <BMeph_> Okay, I'm definitely not as clever as I thought I was.... :)
22:26:12 <BMeph_> > [] >>= (\x -> map (x:) $ [])
22:26:14 <lambdabot>  []
22:26:20 <BMeph_> Better.
22:26:48 <silasm> I get that, I'll think about that, thanks.
22:26:52 <RyanGlScott> Is there a site where I can try code snippets in GHC HEAD?
22:27:54 <silasm> ah, that's kinda weird, so my base case needs to be [x] rather than [].
22:28:04 <silasm> Thanks for pointing me in the right direction BMeph_
22:29:10 <silasm> I guess that corresponds to the fact that 0! is kind of specially defined to be 1, neat.
22:30:21 <jedai> silasm: no, rather you should have a base case for permutations and there's exactly one permutation of the empty set
22:32:08 <silasm> jedai: oh yeah! That does work, if you mean `permutations [] = [[]]'
22:32:19 <silasm> that /is/ neater. Thanks.
22:32:22 <jedai> silasm: right :-)
22:36:17 <mjrosenb> @hoogle M (a->b) -> M a -> M b
22:36:18 <lambdabot> Warning: Unknown type M
22:36:18 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
22:36:18 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
22:43:54 <dfarm> So... I updated the paste. I'm trying to add one last wrinkle but failing so far. http://lpaste.net/3356419304332460032
22:46:21 <dfarm> The parsing all works, but to correctly parse the file each section depends on the flag value. I tried pulling each Parser (i.e., blah <- {some Parser}) into it's own function with an if flag .&. ... then {Parser} else {sensible default} but I'm getting all kinds of type errors. So I'm wondering if maybe someone else looking at the paste (what I'd like to
22:46:21 <dfarm> do) can maybe recommend something better (versus fixing the type errors on my probably awful solution)
22:47:27 <mgaut72> why not just "if flag == 1"
22:47:41 <mjrosenb> dfarm: I am somewhat sure you cant use if like that in a do block.
22:47:52 <mjrosenb> mgaut72: because they aren't the same?
22:48:27 <mjrosenb> dfarm: that being said, you probably also want if flag .&. foo /= 0
22:48:35 <mjrosenb> possibly with more parentheses.
22:49:11 <shachaf> Yes, if takes a boolean, not an Int.
22:49:39 <dfarm> mjrosenb: Here's what I tried http://lpaste.net/1840888498496733184
22:49:45 <mgaut72> sorry, I made a goofy assumption about what (.&.) was.  what I meant by that was "you need something that results in bool"
22:50:03 <shachaf> You're probably missing "return" there, at least.
22:50:11 <shachaf> The type of both branches of the if have to match.
22:50:24 <mjrosenb> dfarm: yeah, foo .&. 4 is a Word of some sort (probably), you need a bool, so you should compare with 0.
22:50:51 * mjrosenb doesn't know enough of attoparsec to say if the branches have the same type.
22:51:02 <shachaf> 0 surely doesn't have the right type at any rate.
22:51:56 <dfarm> I think you're right about the missing return, I just wasn't sure if it's return or some special attoparsec constructor I need to put there.
22:53:01 <dfarm> Ah, and I see what you mean on the boolean. *face palm*
22:54:17 <mgaut72> dfarm:  at the end of the day, the attoparsec "Parser" is just a monad, so if you need to put a pure value (that you already have) into a monad, you can use return
22:54:39 <dfarm> mgaut72: Ok.
22:59:26 <dfarm> Ah, that seems to have done it. Still some annoying things to deal with with the file format itself but I think I've now got a working skeleton for everything I need.
22:59:38 <dfarm> Thank you all so much for the help
23:00:58 <mgaut72> dfarm: thanks for getting me to look into applicative parsing.  I have a Parsec based project going right now.  turned out to be pretty useful
23:01:24 <cbarrett> Isnt it?
23:02:11 <dfarm> Yeah, that made it really kind of beautiful
23:03:01 <dfarm> In a "damn I need to get some sleep" kind of way
23:04:11 <cbarrett> dfarm: I recall that the original applicative functors paper talks about parsing as one of the cases the pattern was extracted from
23:04:18 <cbarrett> It's pretty good, recommended reading
23:04:29 <mgaut72> cbarrett: link?
23:05:46 <dfarm> cbarrett: Ok, I'll have to check it out. I've read quite a bit these last few months but this is the first time I'm really using Haskell for anything substantial, so lots of synthesizing going on of the various things I've read (and sometimes forgotten).
23:05:55 <cbarrett> mgaut72: http://strictlypositive.org/IdiomLite.pdf it's here
23:06:01 <cbarrett> I know it's IRC but a please would be nice :(
23:06:23 <mgaut72> cbarrett: sorry, didn't mean to be rude, I was just too excited for something to read =P
23:06:38 <cbarrett> Ah it looks like evaluating, not parsing, was the example
23:08:16 <dfarm> cbarrett: Thanks
23:10:52 <cbarrett> np :)
23:13:01 * hackagebot doctest-discover 0.1.0.4 - Easy way to run doctests via cabal  http://hackage.haskell.org/package/doctest-discover-0.1.0.4 (karun012)
23:14:34 <mgaut72> dfarm: have you felt that attoparsec is "rough around the edges" at all? I don't have any experience with it, but have been using Parsec for a few months.  From what I understand, attoparsec is supposed to be the rough and fast one, whereas parsec is nicer, with better error messages, etc.
23:15:24 <dfarm> mgaut72: Definitely. I was cruising along making good progress on my parser so didn't notice it for awhile then I made a mistake an got "Error: takeWhile"
23:16:34 <dfarm> That was it. I was like "HTF do I debug that?". But as it turns out it's pretty easy because you can run the parser partially, so I just started commenting out things until the parser worked and then uncommented until broke. Tedious but easy.
23:17:06 <dfarm> But yeah, in my very limited experience the error messages aren't just "bad" they're completely useless.
23:17:58 <dfarm> But the files I'm trying to parse are just big dumps of numbers generated from some old C++ code, so the parsing speed was important to me and it's not like I'm trying to parse a programming language or anything.
23:19:09 <mgaut72> the thing that landed me at parsec was the "extra stuff".  both have generally the same combinators, but Parsec had nice things like "expression parsers" and other programming language oriented parsing tools (im trying to do some subset of C)
23:21:01 <mjrosenb> > foldl (\p c -> (scanl (\f _ l -> head l : f (tail l)) (c:) (head p)) `ap` p) [[]] [1,2,3,4]
23:21:03 <lambdabot>  [[4,3,2,1],[4,3,1,2],[4,2,3,1],[4,1,3,2],[4,2,1,3],[4,1,2,3],[3,4,2,1],[3,4,...
23:21:12 <mjrosenb> well, I'm not entirely sure why I did that...
23:22:09 <mjrosenb> also, head l : f (tail l) is ugly as anything I've ever written
23:22:23 <mjrosenb> but I also didn't want to add a case in there.
23:22:30 <dfarm> I think if I were going to try to parse a language I'd definitely use parsec or maybe try trifecta
23:22:39 <silasm> mjrosenb: neither am I... that's incredibly hard to follow. I've been wanting to do permutations with the list monad since I discovered how it worked; why you'd want to do that is beyond me :P
23:22:55 <mjrosenb> dfarm: trifecta sounds /amazing/
23:22:57 <shachaf> mjrosenb: Match on (x:xs) instead?
23:23:13 <cbarrett> Trifecta is quite nice.
23:23:24 <dfarm> I had one of the more aggressive "proponents" of Haskell imply I was stupid for not considering alternatives to parsec/attoparsec on twitter awhile ago, he never said what I should use but I got the impression it was trifecta he was referring to.
23:23:30 <mjrosenb> shachaf: I'd need a let, or a case, both of which will probably be longer?
23:23:48 <shachaf> \(x:xs) ->, if you really want it to crash on empty lists
23:24:01 <mjrosenb> DERP.
23:24:04 <shachaf> Or ~(x:xs) for the same strictness behavior.
23:24:17 <mjrosenb> right.  I forgot haskell allows a /single/ pattern in a lambda
23:25:58 <mjrosenb> ok,the remaining (head p) isn't that bad.
23:26:44 <mjrosenb> @hoogle (a->a) -> (b -> a -> a)
23:26:47 <lambdabot> Data.Sequence iterateN :: Int -> (a -> a) -> a -> Seq a
23:26:47 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
23:26:47 <lambdabot> Data.IntMap.Strict adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
23:27:13 <shachaf> const?
23:28:14 <zenguine> Hey all, question.  Is there a standard recommended set of imports / way of hiding functions that people use to get the fully polymorphic version of prelude?
23:28:14 <mgaut72> dfarm: im totally not hardcore enough for trifecta yet
23:28:32 <zenguine> I want to use mapM, traverse, etc from Data.Foldable and Data.Traversable
23:28:41 <zenguine> while keeping the rest of the prelude functions that don't conflict
23:28:46 <glguy_> ?. pl djinn (a->a) -> (b -> a -> a)
23:28:46 <lambdabot> f = const
23:29:14 <zenguine> what do people do for this? I always want this but it seems there is an annoying amount of legwork and I assume many people have already solved this?
23:30:05 <mjrosenb> zenguine: iirc, import Data.Foldable(mapM, traverse..)
23:33:29 <dfarm> mgaut72: Me neither. Maybe when I can explain why a comonad is like a neighborhood operator and remember that a profunctor isn't for measuring angles.
23:33:53 <glguy_> zenguine, For the name in Foldable and Traversable that conflict with the Prelude definitions I import qualified with F and T. It's quite confusing to use those unqualified. People reading your code expect "foldr" to have a particular type, and the qualifier makes it clear what you're doing
23:35:14 <dfarm> Well, I'm gonna head out for a bit though. Thanks again everyone.
23:35:44 <zenguine> glguy_: but if it is strictly more general why does it make a difference? since Foldable.foldr is strictly more general than Prelude.foldr for instance I don't see how it could cause issues, outside of error message reporting being confusing for newbies
23:36:53 <glguy_> zenguine, It matters because people look at the code and think something is a list because its an argument to a function that takes a list
23:37:17 <glguy_> You won't find a standard recommendation for doing the imports for that because it isn't a standard thing to do
23:38:05 <glguy_> There are plans for the traversable and foldable operations to be exported in prelude in the next GHC or so, but that's not ready yet
23:39:51 <mjrosenb> > foldl (\p c -> scanr (const(\f (h:t) -> h : f t)) (c:) (head p) `ap` p) [[]] [1,2,3,4]
23:39:53 <lambdabot>  [[1,2,3,4],[2,1,3,4],[1,3,2,4],[2,3,1,4],[3,1,2,4],[3,2,1,4],[1,2,4,3],[2,1,...
23:40:02 <mjrosenb> ok, that's all I'm doing with permute this evening.
23:42:57 <zenguine> glguy_: I see
23:46:02 <zenguine> glguy_: Well I look forward to the release where that gets taken care of. Even more so than the AMP, that makes my life significantly better ha.  I'm suprised it hasn't gotten more attention
23:46:06 <vlion> I have a wee issue relating to IO and sequencing: http://pastebin.com/f5q867G6
23:46:35 <vlion> An exception is raised at line 63 (pasted into the code as comment)
23:50:16 <mjrosenb> vlion: Computation hGetContents hdl returns the list of characters corresponding to the unread portion of the channel or file managed by hdl, which is put into an intermediate state, semi-closed. In this state, hdl is effectively closed, but items are read from hdl on demand and accumulated in a special list returned by hGetContents hdl.
23:50:28 <Schoening> http://learnyouahaskell.com/starting-out   seems to say that     conanO'Brien = "It's a-me, Conan O'Brien!"    is a function and that makes me think strings are functions "definitions"
23:50:55 <vlion> mjrosenb: Ah, gotcha.
23:51:22 <shachaf> It's just wrong.
23:52:36 <shachaf> "When a function doesn't take any parameters, we usually say it's a definition (or a name)."
23:52:53 <Schoening> enlighten me!
23:53:26 <shachaf> A function is a thing that has a type ... -> ...
23:53:32 <mgaut72> Schoening: the biggest thing i got out of LYAH is that *everything* is a function.  thats just the beginning.  keep going, it will be rewarding
23:53:44 <shachaf> mgaut72: Unfortunately that thing is wrong.
23:54:02 <shachaf> @google everything is a function in haskell
23:54:04 <lambdabot> http://conal.net/blog/posts/everything-is-a-function-in-haskell
23:54:04 <lambdabot> Title: Conal Elliott » “Everything is a function” in Haskell?
23:54:28 <mgaut72> reading now
23:54:38 <shachaf> conal: The URL of that post is quite misleading, since there's no question mark.
23:55:44 <mjrosenb> If you're used to implementing laziness by wrapping everything in a thunk, then haskell's laziness may feel like everything is a function.
23:56:39 <Schoening> I hope this does not nullify everything else on the lyah page
23:56:51 <shachaf> I would not rely on LYAH alone.
23:57:57 <Schoening> No just trying to get some rudementary stuff done :)
23:58:03 * mjrosenb has never managed to make it through a haskell tutorial :-/
