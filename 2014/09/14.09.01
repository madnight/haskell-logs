00:00:41 <orb_> I have a regular expressions matcher that works via derivatives.
00:00:49 <orb_> Now I'm trying to beef up my typing via GADTs.
00:01:05 <orb_> I have a simplification function, and it's typing is giving me problems:
00:02:50 <orb_> data Re a x where [...] Seq :: Re a x -> Re a y -> Re a (x,y)
00:03:18 <orb_> simplify1 re = case re of [...] Seq (Rep a) (Rep b) | a == b -> FMap (const ([],[])) $ Rep a
00:03:40 <orb_> The compiler doesn't like the test a == b, because I can't tell it that a and b have to have the same type here.
00:03:44 <orb_> How can I make that work?
00:05:55 <dfeuer> Why doesn't newtype work on unboxed types?
00:06:43 <dfeuer> Is there some theoretical reason, or was it just not worth the trouble?
00:06:58 <vanila> orb_, define a nwe operator (===) :: Re a x -> Re a y -> Bool ?
00:08:27 * hackagebot http-client 0.3.8.1 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.3.8.1 (MichaelSnoyman)
00:08:27 * hackagebot hermit 0.6.0.0 - Haskell Equational Reasoning Model-to-Implementation Tunnel  http://hackage.haskell.org/package/hermit-0.6.0.0 (AndrewFarmer)
00:13:41 <orb_> Oh, Data.Typeable seems helpful.
00:18:21 <vanila> what's the point of try to do type safe things with a GADT if you're just going to use data.typeable?
00:20:02 <haasn> Data.Typeable is type safe
00:20:15 <blast_hardcheese> What does "cabal: InstallPlan: internal error: configured package depends on a non-library package" mean?
00:21:02 <blast_hardcheese> I was able to create a cabal sandbox and install this package in it, but when I try to do it in my project's sandbox I get that error
00:21:28 <vanila> haasn, it's only dynamically safe understand assumptions
00:21:33 <vanila> under*
00:29:27 <haasn> Data.Typeable won't let you write unsafeCoerce, unsafePerformIO, or unsafeAnythingElse
00:29:49 <vanila> I'm not claiming that
00:30:59 <haasn> Then I guess it depends on what “safe”​means
00:39:36 <copumpkin> if I have a massive file and am reading it into a lazy bytestring, and I ask for the lazy bytestring's length
00:39:48 <copumpkin> am I going to use up a load of memory by forcing the spine?
00:39:56 <copumpkin> I suppose I probably am
00:40:43 <shachaf> There's no other way to compute the length.
00:40:59 <copumpkin> well, the "massive file" part
00:41:09 <copumpkin> but I know how the lazy bytestring works so no
00:41:28 <shachaf> Well, I mean, the length of a lazy ByteString.
00:41:42 <shachaf> You can stat the file, of course.
00:41:42 <shiona_> shachaf: lazy version is able to read part of the file, understand nobody is consuming it, discard the read part and read the next one (saving memory). Can the strict one do that too?
00:41:57 <copumpkin> shachaf: sure
00:42:23 <shachaf> Oh, if you let the lazy ByteString GC then it won't use up a load of memory, sure.
00:42:31 <shachaf> But it'll still allocate it.
00:44:52 <slomo> does someone have an example how to use peekWord8 of attoparsec when using applicative style and using it to let a parser fail?
01:00:19 <adas> slomo: peekWord8 has type (Parser (Maybe Word8)). i think failure to parse is represented as Nothing
01:00:37 <adas> slomo: actually end of input returns Nothing
01:02:04 <adas> slomo: so you want to peek a byte and see if it is what you want, and fail if not .. without consuming the input?
01:02:15 <slomo> adas: yeah, now i only need to look at that word... and compare it to something ("." in my case), and if it's a dot the parser should fail (and one parser level higher go into a <|> alternative instead)
01:02:37 <slomo> adas: i want it to fail if it *is* something specific :)
01:04:01 <slomo> adas: basically "b <- peekWord8; case Just "." -> fail "blah"; _ -> return ()" or something like that in monadic style
01:04:32 <adas> slomo: and all this without consuming the input?
01:04:34 <slomo> yes
01:04:49 <slomo> well, without consuming that single byte
01:05:08 <adas> slomo: maybe peekWord8 is not the right parser to use in this case
01:05:18 <adas> slomo: any specific reason why you don't want to consume the input?
01:06:02 <slomo> adas: the code after that uses that byte to continue parsing
01:06:36 <adas> slomo: hmmm.. perhaps you're looking for "choice"?
01:06:41 <slomo> adas: basically i was trying to convert this to applicative style: http://hackage.haskell.org/package/irc-0.6.0.1/docs/src/Network-IRC-Parser.html#nicknamePrefix
01:06:48 <slomo> adas: everything else was simple, that one not :)
01:07:39 <slomo> choice only seems to exist in parsec, not attoparsec
01:08:10 <adas> slomo: import Data.Attoparsec.Combinator (choice)
01:14:24 <copumpkin> how is there no function for getting file size?
01:14:39 <copumpkin> I can use hFileSize on a handle
01:14:44 <copumpkin> but then I have to open and close it and such
01:14:49 <copumpkin> or I can use stat in posixland
01:17:45 <copumpkin> withFile path ReadMode hFileSize
01:38:37 * hackagebot rdf4h 1.2.6 - A library for RDF processing in Haskell  http://hackage.haskell.org/package/rdf4h-1.2.6 (RobStewart)
01:38:38 * hackagebot optparse-applicative 0.10.0 - Utilities and combinators for parsing command line options  http://hackage.haskell.org/package/optparse-applicative-0.10.0 (PaoloCapriotti)
02:01:22 <agatam> is there any semi-official irc channel for icfp? #icfp seems suspiciously empty
02:07:29 <mayski> I've never heard of irc channels for conferences
02:07:38 <Haskellfant> does anybody know if icfp and/or haskell symposium talks will be recorded or even broadcasted live?
02:08:14 <AfC> Haskellfant: they're being recorded.
02:08:23 <Haskellfant> AfC: great
02:10:57 <agatam> yesterday's workshops are already on youtube
02:11:00 <agatam> https://www.youtube.com/channel/UCP9g4dLR7xt6KzCYntNqYcw
02:12:53 <jle`> bayhac had a channel
02:13:40 * hackagebot tasty 0.9.0.1 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.9.0.1 (RomanCheplyaka)
02:27:54 <funfunctor> hi
02:29:08 <funfunctor> i'm trying to add haddock coverage as part of my test suite to my project but wish to exclude two build-time generated files from being check
02:30:19 <funfunctor> https://gist.github.com/victoredwardocallaghan/e8efa1225f658c2c0a3b this is my haddock testsuite haskell script
02:31:36 <funfunctor> essentially I want to ignore:
02:31:36 <funfunctor>    0% (  0 /  8) in 'Paths_consoleui'
02:31:37 <funfunctor>    0% (  0 /  4) in 'GitRev'
02:37:41 <JL235> hey, is there any reason I should go with 32-bit haskell over 64-bit haskell on Windows?
02:38:00 <JL235> I am trying out Haskell again
02:38:19 <JL235> and don't wanna go with 64-bit and find out later that I should go with 32-bit for some reason
02:39:59 <trap_exit> how do apps like secret gain their initial userbase?
02:40:02 <trap_exit> wrong channel, sorry
02:45:03 <Cale> JL235: You choose whichever GHC matches the version of Windows you're running
02:45:34 <Cale> (Or Haskell Platform)
02:47:22 <JL235> ok, sometimes there are issues with the 64-bit version of software on Windows, so just checking
02:59:48 <lericson_> hey guys, I'm trying to import my module X that is in the current directory as X.hs (compiled to X.o with `ghc X.hs`) but neither ghci nor ghc -e 'import X' works, what gives?
03:03:41 <bluebelle> lericson_ : In X.hs, is there a  "module X where"?
03:03:50 <lericson_> bluebelle: yes, module F1 where
03:03:57 <lericson_> sorry module X
03:05:35 <Cale> bluebelle: What are you trying to accomplish overall?
03:06:00 <bluebelle> Cale: ???
03:06:01 <Cale> bluebelle: You should put the import declaration in the Haskell source file which is importing it
03:06:13 <bluebelle> Cale : it's lericson's Question
03:06:19 <Cale> oh, sorry!
03:06:20 <Cale> heh
03:06:26 <bluebelle> lericson : Can you try ghc --make X.hs ??
03:06:45 <Cale> lericson_: What are *you* trying to accomplish overall? :D
03:07:34 <vanila> Does anyone know how a compiler can implement delimited continuations?
03:14:09 <lericson_> it seems to do the same thing as without --make, bluebelle
03:14:09 <lericson_> Cale: i am trying to evaluate a function defined in X.hs.
03:14:09 <lericson_> preferably interactively
03:14:10 <funfunctor> vanila: on the llvm binding?
03:14:10 <funfunctor> vanila: you could use llvm modules?
03:14:11 <funfunctor> vanila: you just need to model your state machine then do the AST transform into a LLVM IR representation, JIT it and return the result back into your AST
03:15:47 <vanila> I'm not using llvm but something like that could be very interesting
03:18:10 <funfunctor> vanila: LLVM is very very good ! It makes things a hell of a lot easier once you get the ideas involved
03:18:36 <vanila> alrightm that makes it a little less scary :)
03:19:10 <funfunctor> vanila: it basically reduces writing a compiler down to working out your CFG and your AST representation. Everything else is grunt work
03:20:33 <funfunctor> vanila: this is a truely wonderful tutorial http://www.stephendiehl.com/llvm/
03:20:58 <vanila> thank you!
03:21:07 <funfunctor> no worries :)
03:21:50 <funfunctor> i'm just stuck with a much 'simpler' problem with my compiler project.. Getting my haddock testsuite coverage working properly
03:22:15 <funfunctor> I want it to ignore the build-time generated module Paths_consoleui somehow?
03:22:27 <funfunctor> https://gist.github.com/victoredwardocallaghan/e8efa1225f658c2c0a3b this is my haddock testsuite haskell script
03:24:41 <vanila> What would I do to solve Could not find module `Text.Regex'?
03:24:48 <vanila> when trying to build that with ghc Main.hs
03:25:36 <Cale> lericson_: ghc X.hs -e 'foo' ?
03:25:57 <Cale> lericson_: Or just ghci X.hs and type as many expressions as you like
03:26:05 <vanila> oh it's regex-compat
03:27:58 <vanila> It says "Please create a package description file <pkgname>.cabal", I'm not sure how to see the problem
03:28:21 <vanila> it's unlikely i can help since i am not familiar with haddock but looking anyway
03:32:54 <adas> what is the url of the website that talks about functional programming in general? One that is quite famous in this channel?
03:33:57 <adas> i think it starts with lambda or something. tried "insite:lambda haskell". didn't get what im lookcing for
03:34:12 <shachaf> lambda the ultimate
03:38:14 <adas> shachaf: thanks..thats the one
03:52:55 <trap_exit> what's the best way to learn frp?
03:53:07 <trap_exit> I feel familiar enoguh with haskell + monads + types + type classes to take another stab at FRP
04:09:38 <trap_exit> I know that haskell has if + catch; however, does haskell have cond ?
04:10:20 <nymacro|2> trap_exit: case?
04:10:32 <trap_exit> right
04:10:32 <trap_exit> if + case
04:10:33 <trap_exit> it's 4:0-9 am here
04:10:36 <trap_exit> don't make fun of me :-)
04:10:46 <trap_exit> yeah, so haskell has if + case
04:10:48 <trap_exit> does it also have cond builtin ?
04:11:47 <nymacro|2> I don't know; I'm a haskell newbie. I've never had a cond in any language I've programmed in.
04:12:02 <supki> multiway if is close, I think
04:12:06 <trap_exit> what?
04:12:06 <trap_exit> have you never used lisp?
04:12:25 <simukis_> conds sound very close to guards
04:12:26 <trap_exit> you're not missing out on much
04:12:28 <trap_exit> cond is basically like nested elseifs
04:12:46 <simukis_> also http://hackage.haskell.org/package/cond-0.4.1/docs/Control-Conditional.html#v:cond
04:12:47 <trap_exit> simukis_ : damn, you're right
04:13:30 <trap_exit> are aurds only top level?
04:13:31 <trap_exit> I have this situation where it's like
04:13:43 <trap_exit> foo x = \n let y = .... THEN LOTS OF CONDS
04:13:54 <trap_exit> http://en.wikibooks.org/wiki/Haskell/Control_structures makes it look like guards are top level
04:13:56 <trap_exit> so I can't do the let
04:14:44 <ClaudiusMaximus> trap_exit: you can use guards with case, like case () of _ | blah -> blub | blah2 -> flap
04:14:48 <slomo> trap_exit: you can also do guards in case
04:15:07 <trap_exit> ClaudiusMaximum slomo: I did not know that
04:15:07 <trap_exit> thanks!
04:15:15 <simukis_> you can always do
04:15:16 <simukis_> where go x y z | cond1 = undefined | cond2 = undefined…
04:15:17 <trap_exit> so basically
04:15:21 <trap_exit> guards can be attached any time to a pattenr match ?
04:15:49 <trap_exit> alright, alright, stop showing off arcane haskell knowledge now :-)
04:17:02 <pavonia> > (\x | x < 10 -> x) 5
04:17:03 <lambdabot>  <hint>:1:5: parse error on input ‘|’
04:17:59 <mornfall> is there a haskell platform for armv7l somewhere?
04:18:53 <simukis_> > let x = go where go x | x < 0 = 1 | otherwise = 0 in x 10
04:18:54 <lambdabot>  0
04:22:11 <pjdelport> pavonia: You can do that with the LambdaCase extension:
04:22:11 <pjdelport> ghci> map (\case x | x < 10 -> x | otherwise -> -x) [0..]
04:22:11 <pjdelport> [0,1,2,3,4,5,6,7,8,9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,...
04:22:58 <pjdelport> http://unknownparallel.wordpress.com/2012/07/09/the-long-and-epic-journey-of-lambdacase-2/
04:23:04 <pavonia> pjdelport: Yes, I know. I just wanted to demonstrate that it's not allowed in every pattern match
04:23:17 <pjdelport> pavonia: Ah, oki
04:23:58 * hackagebot qc-oi-testgenerator 1.2.0.3 - Compile time generation of operation invariance tests for QuickCheck  http://hackage.haskell.org/package/qc-oi-testgenerator-1.2.0.3 (goedderz)
04:24:00 * hackagebot th-alpha 0.2.0.0 - Alpha equivalence for TH Exp  http://hackage.haskell.org/package/th-alpha-0.2.0.0 (jkarni)
04:24:13 <mornfall> let's see what happens when I build on armv5tel and run on armv7
04:33:59 * hackagebot riak-protobuf 0.18.0.0 - Haskell types for the Riak protocol buffer API  http://hackage.haskell.org/package/riak-protobuf-0.18.0.0 (MarkHibberd)
04:34:01 * hackagebot riak 0.7.2.0 - A Haskell client for the Riak decentralized data store  http://hackage.haskell.org/package/riak-0.7.2.0 (MarkHibberd)
04:34:58 <osa1> it's amazing how hard writing an equivalent of this one line of Haskell in many languages: `[n, k] <- (map read . words) `fmap` (readFile . head =<< getArgs)`
04:36:34 <trap_exit> OMG
04:36:35 <trap_exit> sections are awesome
04:36:42 <trap_exit> I just learned hot to use them
04:36:44 <trap_exit> filter (== ... ) lst
04:36:53 <trap_exit> is so much nicer than filter (\x -> (x == ... )) let
04:36:54 <trap_exit> so clear
04:36:54 <trap_exit> wow syntax
04:36:55 <Fuuzetsu> they aren't awesome if you have two operators…
04:36:55 <trap_exit> much happiness
04:37:03 <trap_exit> two operators?
04:37:05 <trap_exit> example please
04:37:07 <Fuuzetsu> (a + b +) = no good
04:37:16 <trap_exit> ((a+b)+)
04:37:22 <Fuuzetsu> ugly
04:37:27 <trap_exit> did you just get schooled by a newb?
04:37:34 <osfameron> (c +) where c = a + b
04:37:40 <Fuuzetsu> only newbs put in parenthesis
04:37:45 <trap_exit> lol
04:37:59 <trap_exit> (+$a+b)
04:38:19 <trap_exit> ((+a) . (+b))
04:38:34 <Fuuzetsu> there is a ticket on GHC Trac about different section style
04:38:56 <Fuuzetsu> https://ghc.haskell.org/trac/ghc/ticket/8304
04:44:13 <rod_> Hello , con someone tell me if it is possible to have multiple Show instances for one type ??
04:44:16 <HUIOMguy> So guys
04:44:21 <HUIOMguy> Haskell Vs Ocaml
04:44:26 <HUIOMguy> for finance
04:46:10 <Iceace> Has anyone used Package HXT before? i'm using it to parse an xml which contains information of song lists. It seems that HXT will just return nothing if some songs do not have lrclink or album_title. how can i make it just return empty strings. THE code is here: http://lpaste.net/110338
04:47:25 <Iceace> I've tried something like lrclink' <- getElement "lrclink" <+> (arr $ const "")    -< x , but it does not work correctly.
04:47:49 <HUIOMguy> Guys
04:48:07 <HUIOMguy> what do you think is better for stock trading and finance algorythms haskell vs ocaml
04:48:10 <otulp> rod_: You can only have one instance. But you can wrap your type with a newtype and write the secondary Show for the newtype.
04:50:26 <HUIOMguy>  what do you think is better for stock trading and finance algorythms haskell vs ocaml
04:50:41 <osfameron> HUIOMguy: there's no point just repeating your question
04:50:52 <osfameron> at least, not immediately
04:51:01 <HUIOMguy> Ok
04:51:05 <otulp> HUIOMguy: I'm sure both work fine. Depends on your needs. Your question is very broad.
04:51:21 <rod_> 2 Show instances for type , 1 for prettyprinting , one for file serialisation , possible ??
04:51:29 <HUIOMguy> ok what do you think is easier to learn and use
04:52:24 <avaritia> HUIOMguy: there is one company using ocaml - check jane street
04:52:36 <avaritia> HUIOMguy: havent heard about anything using haskell
04:52:40 <HUIOMguy> yea i checked them out
04:52:51 <bergmark> several companies use haskell in finance
04:52:55 <HUIOMguy> but what about ease of learning and use
04:52:57 <avaritia> like?
04:53:01 <osfameron> http://www.haskell.org/haskellwiki/Haskell_in_industry
04:53:10 <avaritia> HUIOMguy: i sense a troll ;)
04:53:31 <HUIOMguy> ?
04:53:33 <avaritia> osfameron: there have been some accusations on hn that some of these companies are fake
04:53:40 <HUIOMguy> in which way am i trolling here
04:53:53 <HUIOMguy> its a sincere question
04:54:03 <bergmark> fpcomplete and standard chartered are two that use haskell in finance
04:54:17 <osfameron> HUIOMguy: what are you trying to achieve?  personal share trading?  advice for a large team at a bank?  etc.?
04:54:24 <rtpg> This might be slightly OT but is there a tutorial or the like that explains how to properly lex and parse haskell? I'm trying to work on a whitespace-significant language and am having trouble figuring out how to deal with multi-line expressions for example
04:54:26 <osfameron> if it's you personally, then use whatever you know best
04:54:51 <bergmark> HUIOMguy: i think haskell is the easiest language to use once you know it
04:54:56 <HUIOMguy> I am interested in trying to write an algrorythm to rate the viability of companies to buy shares in
04:55:05 <HUIOMguy> but is ocaml easier to learn]
04:55:09 <HUIOMguy> and sorry for my english
04:55:15 <HUIOMguy> its my 3rd language
04:55:19 <bergmark> it's a smaller language, so probably yes
04:55:29 <splintax1> on the other hand, it's a smaller IRC channel
04:56:19 <bhuemer> by that standard, haskell is already more widely adopted than java, yes! :)
04:56:50 <HUIOMguy> ok lets put it this way
04:56:59 <HUIOMguy> scale of one to ten for these factors
04:57:00 <osfameron> my cousin does quant stuffs in C#...
04:57:02 <HUIOMguy> ease of use
04:57:07 <HUIOMguy> ease of learning
04:57:11 <HUIOMguy> synatx ease
04:57:15 <HUIOMguy> functionality
04:57:21 <HUIOMguy> and use in finance
04:57:26 <bergmark> i have no idea how to quantify it on a scale like that
04:57:33 <osfameron> HUIOMguy: I don't think anyone here can tell *you* how easy it will be to understand syntax in any language
04:57:34 <otulp> Well, I'm not qualified to answer that. :)
04:57:36 <HUIOMguy> just guesstimate
04:57:43 <HUIOMguy> :)
04:57:48 <osfameron> HUIOMguy: try learning some haskell, and let us know what you think :-)
04:58:23 <osfameron> HUIOMguy: Q: is Haskell worth learning?  A: Yes.  Q: is Haskell worth *your* time learning *right now*?  A: um, no idea.  you tell us :-)
04:58:24 <bhuemer> @all, if it helps, use a scale ranging from apple to banana
04:58:24 <lambdabot> Unknown command, try @list
04:58:41 <HUIOMguy> ok
04:59:25 <bergmark> HUIOMguy: the only thing i can tell you is that i started learning haskell and ocaml at the same time having done common lisp and sml before, and very quickly i switched completely to haskell because of more expressiveness, more libraries, better compiler errors
04:59:55 <HUIOMguy> ok does anyone here work in the fininacial sector
04:59:57 <HUIOMguy> ?
05:01:39 <avaritia> i'd love to but currently nope
06:11:09 <prophile> @hoogle Ring
06:11:13 <lambdabot> Graphics.UI.GLUT.Objects type Rings = GLint
06:11:13 <lambdabot> Prelude data Ordering :: *
06:11:13 <lambdabot> Data.Ord data Ordering :: *
06:15:14 <augur> is there a way to tell ghci to load everything in a library without making a special re-export file?
06:29:15 * hackagebot btrfs 0.1.0.1 - Bindings to the btrfs API  http://hackage.haskell.org/package/btrfs-0.1.0.1 (MariosTitas)
06:33:59 <lericson_> what are the performance implications of doing tail (tail x) versus drop 2 x?
06:34:16 * hackagebot data-interval 0.5.0 - Interval arithmetic for both open and closed intervals  http://hackage.haskell.org/package/data-interval-0.5.0 (MasahiroSakai)
06:36:19 <Twey> lericson_: Irrelevant
06:36:53 <nexx> I'm no expert but tail tail might iterate twice over x.
06:37:23 <Twey> Nope.  tail is constant-time.
06:37:26 <Twey> @src tail
06:37:26 <lambdabot> tail (_:xs) = xs
06:37:26 <lambdabot> tail []     = undefined
06:37:36 <triliyn> There is a semantic difference though
06:37:37 <nexx> oh, thought about last...
06:37:51 <triliyn> > (drop 2 [1], tail (tail [1]))
06:37:52 <lambdabot>  ([],*Exception: Prelude.tail: empty list
06:38:03 <Twey> Right, the semantic difference is the important bit.  drop 2 [3] = [].  tail (tail [3]) will blow up your program.
06:54:19 * hackagebot one-liner 0.5 - Constraint-based generics  http://hackage.haskell.org/package/one-liner-0.5 (SjoerdVisscher)
06:58:13 <lericson_> Twey et al, thanks for your kind response
06:58:35 <lericson_> tail tail might then be a little better in the case where you expect there to be two heads to drop
07:00:35 <Sonderblade> any description/tutorial/blog post somewhere on how haskell's gc works?
07:01:34 <Sonderblade> looks to me like you could optimize it very well due to haskells immutability
07:02:48 <osfameron> Sonderblade: presumably it's implementation dependent?  so ghc's gc etc.
07:04:20 * hackagebot irc-ctcp 0.1.2.0 - A CTCP encoding and decoding library for IRC clients.  http://hackage.haskell.org/package/irc-ctcp-0.1.2.0 (barrucadu)
07:04:36 <barrucadu> Sonderblade: AFAIK it's not quite that simple, because thunks result in things in the runtime mutating after being allocated
07:05:09 <bennofs> Sonderblade: http://aosabook.org/en/ghc.html contains some information iirc
07:05:30 <bennofs> Sonderblade: see also https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/GC
07:07:27 <Sonderblade> barrucadu: really? otherwise knowing that older objects never can reference younger ones would simplify a lot of things
07:08:22 <Sonderblade> bennofs: thanks
07:08:24 <barrucadu> Sonderblade: Yeah, GHC uses a generational collector, but lazy evaluation still results in some old-to-young pointers being created. I believe it has some heuristics to try and reduce that, though
07:09:52 <zwarn> does anyone know where to find InterpreterLib?
07:22:00 <pjdelport> http://www.haskell.org/haskellwiki/GHC/Memory_Management too
07:24:23 * hackagebot hplayground 0.1.0.4 - a client-side haskell framework that compiles to javascript with the haste compiler  http://hackage.haskell.org/package/hplayground-0.1.0.4 (AlbertoCorona)
07:30:46 --- mode: ChanServ set +o jmcarthur
07:31:11 --- mode: jmcarthur set +b *!*@178.62.181.153
07:31:20 --- mode: jmcarthur set -o jmcarthur
07:34:48 <zwarn> I found a link to the haskell InterpreterLib (library http://www.ittc.ku.edu/Projects/SLDG/projects/project-InterpreterLib.htm)
07:35:02 <zwarn> does anyone know where to find it?
07:35:57 <msafi> Hey guys, is it possible to learn Haskell if you're bad at math or don't have format software engineering background?
07:36:07 <msafi> s/format/formal
07:36:40 <msafi> If so, where should I start learning it?
07:37:34 <Haskellfant> @where lyah
07:37:35 <lambdabot> http://www.learnyouahaskell.com/
07:37:48 <Haskellfant> msafi: yes it is possible and you should probably start by reading that book
07:38:13 <msafi> Cool. Thanks.
07:48:20 <pjdelport> @where wikibook
07:48:21 <lambdabot> http://en.wikibooks.org/wiki/Haskell
07:49:23 <lectual> Hey. Can you have a repl for haskell?
07:49:39 <barrucadu> Yes, see ghci
07:49:40 <Taneb> lectual, you mean like GHCi?
07:49:57 <lectual> Uh, i mean programming live
07:50:11 <Denommus> lectual: like Common Lisp's SLIME?
07:50:21 <lectual> Aye
07:52:59 <Denommus> lectual: I don't know. If you find a way to have cabal repl on the Haskell inferior process, you can use C-x C-d (which is inferior-haskell-send-decl) to it
07:53:05 <tdammers> SLIME goes further than ghci though, right?
07:53:13 <Denommus> lectual: *to send a decl to it
07:56:16 <Denommus> weird, I have configured flycheck to use cabal to check for external modules, but it doesn't work
07:59:32 <kgadek> does anyone have any brilliant ideas how to debug haskell code efficiently? I've just lost several hours to find a trivial bug…
07:59:33 <kgadek> (╯°□°）╯︵ ┻━┻
07:59:44 <kgadek> …i believe better debugging would help a lot
08:15:02 <beid7712> http://vividsx.com/double-timing-wifeava-addams-bill-baileykeiran-lee-lizzie-tucker-fucked-while-playing-console-gamesamantha-saint-madison-ivy-two-hottie-bff-threesomedillion-harper-penetrating-the-pus/
08:15:16 <Fuuzetsu> @where ops
08:15:16 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
08:15:39 --- mode: ChanServ set +o dcoutts_
08:16:03 --- mode: ChanServ set -o dcoutts_
08:16:12 <dfeuer> Somebody fixed it already.
08:16:16 <dcoutts_> so I see
08:19:00 <eacameron1> what's the relationship between +RTS -Nx and forkOS, is forkOS  limited by -N?
08:20:14 <edlinde> hi all, can someone help me understand partially applied functions and curried functions?
08:20:22 <edlinde> reading it from LYAH
08:20:26 <edlinde> not sure I got the concept
08:20:29 <barrucadu> edlinde: What are you having difficulty with?
08:20:41 <edlinde> maybe someone here got a bit of time to clarify this concept for me?
08:20:59 <hpc> don't quote me on this, but going by the haddock forkOS is the same as forkIO, except the new thread is stuck on one processor
08:21:49 <edlinde> was looking at:
08:21:51 <edlinde> multThree :: (Num a) => a -> a -> a -> a
08:21:52 <edlinde> multThree x y z = x * y * z
08:22:08 <hpc> eacameron: er rather, a bound thread is a haskell thread that's stuck on one OS thread
08:22:14 <edlinde> the example was: multThree 3 5 9
08:22:35 <hpc> it's not the OS thread itself, so you can still have many forkOS threads to a single -N thread
08:22:39 <edlinde> it says: multThree :: (Num a) => a -> (a -> (a -> a))
08:22:57 <edlinde> barrucadu: I am not getting this notation
08:23:07 <edlinde> so what is the order of execution?
08:23:12 <barrucadu> edlinde: It's just showing the associativity of ->
08:23:12 <hpc> it's lighter than an OS thread, heavier than a forkIO thread
08:23:44 <barrucadu> multThree is a function which takes a Num a, and returns a function of type Num a => a -> a -> a, which takes a Num a and returns a function of Num a => a -> a (etc)
08:23:49 <edlinde> I get that they are all “a”’s to indicate that all must be of the same type
08:24:35 * hackagebot persistent 2.0.1 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-2.0.1 (GregWeber)
08:24:53 <edlinde> barrucadu: I am confused with this notation —> multThree :: (Num a) => a -> (a -> (a -> a))
08:24:59 <edlinde> I mean how do I read this?
08:25:05 <edlinde> from right to left?
08:25:14 <barrucadu> Left to right
08:25:26 <edlinde> like the one in the innermost braces is the first arg?
08:25:44 <barrucadu> No. The leftmost thing is the first argument
08:25:46 <barrucadu> Are you happy with how to read Num a => a -> a -> a -> a ?
08:26:12 <yitz> edlinde: the type expression x -> y means the thing that has this type takes an x as its argument and returns a y.
08:27:02 <edlinde> the way I have been reading it so far is that Num a is the constraint
08:27:03 <edlinde> then a->a->a->a just means that this function will take 3 args and return 1 value with the same type
08:27:23 <doismellburning> edlinde: correct
08:27:32 <edlinde> is that right?
08:27:32 <edlinde> ok
08:27:43 <yitz> edlinde: since the -> is "associative", that means a type expression with multiple -> implies parens as shown.
08:28:07 <doismellburning> edlinde: but "a function that takes n args" can also be viewed as "a function that takes an argument and returns a function that takes n-1 arguments" (where "a function that takes 0 arguments" is a value)
08:28:09 <edlinde> now with the curried thing… if I am reading it left to right
08:28:09 <edlinde> multThree :: (Num a) => a -> (a -> (a -> a))
08:28:09 <edlinde> lets make this
08:28:23 <edlinde> multThree :: (Num a) => b -> (c -> (d -> e))
08:28:33 <edlinde> just so its easier for me to get the order
08:28:40 <doismellburning> er what
08:28:48 <edlinde> now its saying that I have a function that will take arg “b” and return a function?
08:28:52 <edlinde> at the start
08:29:04 <doismellburning> edlinde: I think misusing type notation is unhelpful
08:29:08 <zwer> all haskell functions take just one argument
08:29:10 <yitz> edlinde: yes, but in haskell, a function which "takes more than one parameter" can be thought of as a function that takes only one parameter and returns a function. that new function is then applied to the remaining parameters.
08:29:11 <edlinde> yeah I know …
08:30:00 <edlinde> ok then going back to the original defn
08:30:03 <edlinde> multThree :: (Num a) => a -> (a -> (a -> a))
08:30:03 <doismellburning> edlinde: imagine `add :: Int -> Int -> Int` so `add 1 2` is 3; `add 1` is a function of type Int -> Int
08:30:12 <yitz> zwer: sort of. they can be thought of that way. in reality, most compilers are smart enough to know about multi parameter functions.
08:30:18 <zwer> `a -> a -> a' is exactly the same as `a -> (a -> a)'
08:30:38 <edlinde> is this saying.. I first get a function that takes “a” (first left) as argument and return function (a->(a->a))?
08:31:17 <zwer> yitz we are talking about semantics at the the language level, what happens under the hood doesn't matter
08:31:29 <edlinde> can u correct what I just wrote above?
08:31:30 <yitz> it means: a function that takes an a and returns something of type a -> a
08:31:34 <edlinde> is that the right way to think about it?
08:32:00 <doismellburning> edlinde: yes
08:32:05 <edlinde> ok
08:32:26 <edlinde> so if we extend your example…  add 1 2 3 (takes 3 args)
08:32:36 <edlinde> initially I am getting a curried function “add 1”
08:32:41 <edlinde> is this my partial fn?
08:32:47 <edlinde> partially applied sorry
08:33:02 <eacameron> hpc: Thanks, that makes sense
08:33:07 <doismellburning> edlinde: er, in my example, add takes 2 arguments
08:33:10 <doismellburning> edlinde: try again?
08:33:23 <yitz> @type let add x y = x + y in add 1
08:33:24 <lambdabot> Num a => a -> a
08:33:34 <edlinde> doismellburning: yeah I am trying to extend what you said to 3 args… just so I am sure I got this :)
08:33:35 <yitz> @type add x y = x + y
08:33:35 <lambdabot> parse error on input ‘=’
08:33:49 <yitz> @type let add x y = x + y in add
08:33:49 <lambdabot> Num a => a -> a -> a
08:34:28 <doismellburning> edlinde: so, `add3 :: Int -> Int -> Int`, then `add 1` is `Int -> Int -> Int`, `add 1 2` is `Int -> Int`
08:34:35 <msafi> Haskellfant: It seems that this book expects you to know math. http://learnyouahaskell.com/starting-out I don't get the part about list comprehensions at all!
08:34:39 <edlinde> doismellburning: so say we got  “add x y z”… then I am getting to start with “add x” which takes arg “y”.
08:34:51 <edlinde> add x is a function that takes arg y and returns another fn
08:35:00 <doismellburning> edlinde: er sorry pretend the "add"s in my last line were "add3"s
08:35:03 <edlinde> then I will apply that returned function to z
08:35:07 <doismellburning> edlinde: yes
08:35:59 <edlinde> should it not be add3 :: Int -> Int -> Int -> Int?
08:35:59 <edlinde> for 3 Int args and one Int return
08:35:59 <edlinde> ?
08:35:59 <edlinde> ok cool
08:36:11 <Haskellfant> msafi: ignore the set notation and read the text to understand what's going on
08:36:17 <doismellburning> edlinde: er, yes, sorry, it's been a long few days
08:36:19 <yitz> zwer: for most people just beginning to learn haskell, the distinction between denotational and operational semantics is confusing. they'll get to it soon. best to just say things that are correct without getting into it.
08:36:35 <msafi> Haskellfant: ok
08:36:36 <edlinde> doismellburning: no worries! :) I appreciate your help
08:36:50 <edlinde> I really want to get this right before I try to move on to more advanced stuff
08:36:50 <edlinde> :)
08:37:21 <doismellburning> edlinde: an example may be useful: `map (add 5) [1,2,3]`
08:38:09 <yitz> > map (add 5) [1, 2, 3]
08:38:10 <lambdabot>  Not in scope: ‘add’
08:38:11 <lambdabot>  Perhaps you meant one of these:
08:38:11 <lambdabot>    ‘odd’ (imported from Prelude), ‘and’ (imported from Data.List),
08:38:11 <lambdabot>    ‘F.and’ (imported from Data.Foldable)
08:38:16 <doismellburning> heh sorry
08:38:20 <yitz> > let add x y = x + y in map (add 5) [1, 2, 3]
08:38:22 <lambdabot>  [6,7,8]
08:38:22 <doismellburning> > map (+5) [1,2,3]
08:38:24 <lambdabot>  [6,7,8]
08:38:40 <doismellburning> I realised infix notation conflicts with my markdown-alike ;)
08:38:47 <doismellburning> hence "add"
08:38:53 <edlinde> will this result in [ (add 5 1), (add 5 2), (add 5 3)] ?
08:38:54 <edlinde> maybe it should be (+)?
08:38:58 <doismellburning> (and didn't want to bother with typeclasses)
08:39:11 <yitz> doismellburning: i think your "add" example is great
08:39:23 <doismellburning> edlinde: yes, the reason I "defined" my own add is to avoid addressing infix + typeclasses
08:39:30 <edlinde> okie
08:39:38 <doismellburning> edlinde: and yes that is the result
08:39:41 <doismellburning> yitz: heh cheers
08:39:45 <yitz> edlinde: yep that works too. in fact that's what we'd be likely to use in real life.
08:39:59 <edlinde> In the map it makes sense
08:40:08 <doismellburning> edlinde: where does it not make sense to you?
08:40:11 <edlinde> I was trying to understand how to read it when you have a function with many args
08:40:28 <doismellburning> -> is left-associative
08:40:29 <edlinde> so basically you partially apply to first arg..
08:40:43 <edlinde> ok
08:40:44 <yitz> doismellburning: look carefully at your hands
08:40:49 <zwer> okkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk
08:40:54 <yitz> heh
08:40:57 * doismellburning looks
08:41:02 <amar^> I know it would dumb question to ask, I understand ADTs are way mooore compassable than safe operator like ?. but for a presentation purpose I wanted a example where ?. fails, I could think of cache example for now
08:41:30 <doismellburning> yitz: I fear I'm insufficiently caffeinated...what am I looking at (beyond "my hands"!)
08:42:07 <yitz> doismellburning: it's right associative
08:42:18 <doismellburning> yitz: ...bugger yes sorry
08:42:28 <doismellburning> -> is right associative, sigh, sorry, thanks yitz
08:42:32 <edlinde> so is it right or left associative?
08:42:34 <yitz> :)
08:42:44 <edlinde> :)
08:42:46 <amar^> like a?.get?.name
08:42:56 <doismellburning> (a -> b) -> c NEQ a -> b -> c EQ a -> (b -> c)
08:43:02 <amar^> is possible but not a??
08:43:08 <edlinde> no wonder I am not getting the hang of this
08:43:08 <edlinde> haha
08:43:14 <amar^> something like this, any obvious example?
08:43:17 <sauvik> nick 54uv1k
08:43:33 <doismellburning> edlinde: heh sorry
08:43:39 <edlinde> no worries
08:43:42 <edlinde> add3 :: Int -> Int -> Int
08:43:49 <edlinde> so hos should I read this
08:43:50 <doismellburning> that was also wrong, sorry
08:43:56 <doismellburning> add3 :: Int -> Int -> Int -> Int
08:44:01 <doismellburning> i.e. takes 3 ints and adds them
08:44:15 <edlinde> yep
08:44:15 <edlinde> here I am assuming we are talking about adding 3 ints right?
08:44:16 <edlinde> not adding 3 to all
08:44:19 <edlinde> yep
08:44:25 <edlinde> ok so lets see
08:44:41 <doismellburning> edlinde: yes because otherwise it would have a signature something like `add3toall :: [Int] -> [Int]`
08:44:43 <edlinde> add3 :: Int -> ( Int -> (Int -> Int))
08:44:49 <doismellburning> edlinde: exactly
08:44:50 <edlinde> true
08:45:06 <edlinde> now how do I read it for say :   “add 3 4 5”
08:45:14 <edlinde> ?
08:45:33 <doismellburning> edlinde: I struggle to find a response other than "exactly as described above"
08:45:51 <doismellburning> edlinde: what do you find different in technique-to-understanding from previously?
08:45:55 <edlinde> Is the innermost (Int -> Int) correspond to “add 3”?
08:45:59 <doismellburning> no
08:46:02 <doismellburning> edlinde: left to right
08:46:27 <doismellburning> edlinde: add3 takes an Int and returns an (Int -> (Int -> Int)), or more conventionally, an Int -> Int -> Int
08:46:30 <doismellburning> er
08:46:35 <doismellburning> edlinde: "add 3" takes an Int and returns an (Int -> (Int -> Int)), or more conventionally, an Int -> Int -> Int
08:46:39 <edlinde> hmmm
08:47:07 <edlinde> ah get you
08:47:16 <edlinde> but then is -> still right associative?
08:47:28 <yitz> edlinde: i think what might be confusing you is that the type expression is not evaluated or executed. it just tells the compiler what type a symbol has. it has no effect at run time.
08:47:37 <edlinde> I got to check the defn of let and right associative :)
08:47:53 <doismellburning> edlinde: yes otherwise Int -> Int -> Int -> Int would not be the same as Int -> (Int -> (Int -> Int))
08:47:55 <edlinde> yitz: I get that
08:48:00 <yitz> ok
08:48:16 <edlinde> but the order in which “add3 5 6 7
08:48:54 <edlinde> “add3 5 6 7” must be understood in the order in which the curried functions are applied
08:48:54 <edlinde> I am just trying to get that :)
08:49:11 <yitz> edlinde: that has to do with precedence when evaluating an expression. it's different than a type signature.
08:49:38 * hackagebot extended-reals 0.1.0.0 - Extension of real numbers with positive/negative infinities  http://hackage.haskell.org/package/extended-reals-0.1.0.0 (MasahiroSakai)
08:49:41 <edlinde> ok
08:49:43 <zwer> function application (a space) is left associative
08:50:22 <zwer> `add3 5 6 7' is the same as `((add3 5) 6) 7
08:50:48 <edlinde> zwer: thanks!
08:50:51 <doismellburning> ah, yes
08:50:58 <edlinde> thats what I wanted to understand
08:51:12 <yitz> edlinde: when we see add3 in the expression, we look up its type, which we presumable have aleady figured out, and we say, ok, this takes an integer, and returns a function. where can we get an integer? oh here's one. etc.
08:51:54 <edlinde> yitz: I got that … but if you see how zwer is showing it in ( )s …. thats how I was trying to understand the function
08:52:06 <edlinde> and I think that is the order in which it will work
08:52:11 <yitz> edlinde: ok, great! zwer++
08:52:13 <silver> yes
08:52:34 <edlinde> but thanks to all of you.. its clearer now :)
08:52:39 <silver> ((add3 5) 6) is a (partially applied) function though
08:53:08 <edlinde> so is (add3 5) yeah?
08:53:09 <silver> same as (add3 5)
08:53:11 <silver> yea
08:53:39 <edlinde> though (add3 5) on its own makes no sense to me :)
08:53:49 <edlinde> it just has to be read as it “returns a function”
08:53:54 <doismellburning> edlinde: why? it's just a function from Int -> Int -> Int
08:53:58 <silver> imagine you have to add bunch of numbers to five
08:54:09 <doismellburning> it may be useful to stop thinking of "partially applied functions" as, well, things
08:54:18 <doismellburning> and just think that functions can return functions
08:54:18 <silver> you create partially applied function add3 5 and run it on a list
08:54:29 <edlinde> yeah doismellburning
08:55:05 <edlinde> I think I get the hang of it now.
08:55:09 <doismellburning> well, I guess then, think of "partially applied function" as a label for "a function returned by another function"
08:55:29 <silver> yeah, I do like that :D
08:55:47 <edlinde> yeah its how I understood it initially
08:56:13 <edlinde> because I was thinking “add3 5” .. is saying “we will start with just 5 and return a partial fn"
08:56:25 <edlinde> which will keep processing the other parts of the list of args
08:59:39 * hackagebot persistent 2.0.1.1 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-2.0.1.1 (GregWeber)
09:13:54 <Twey> lericson_: No, tail . tail will be completely pointless.  Just use ‘drop 2’.
09:14:24 <SwashBuckla> what would be the Monad instance for this type? data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)
09:14:25 <Twey> lericson_: They will most likely optimize to the same thing.  And if they don't then there'll be so little difference between them that it's not worth thinking about.
09:15:14 <SwashBuckla> this post seems to suggest that there is no good instance of Monad for that type: http://stackoverflow.com/a/6799885
09:15:32 <Taneb> Anyone know of a function :: [a] -> (a -> IO [b]) -> IO [b]?
09:16:03 <SwashBuckla> Taneb: http://www.haskell.org/hoogle/?hoogle=%5Ba%5D+-%3E+%28a+-%3E+IO+%5Bb%5D%29+-%3E+IO+%5Bb%5D :(
09:16:03 <Taneb> I think it can be generalized to (Foldable f, Applicative m, Monoid t) => f a -> (a -> m t) -> m t
09:16:07 <yitz> SwashBuckla: correct. Tree is not a monad in a natural way.
09:16:25 <Taneb> SwashBuckla, that Hoogle isn't helpful
09:16:43 <SwashBuckla> sorry
09:16:50 <yitz> SwashBuckla: however, a rose tree - with [Tree a] in place of (Tree a) (Tree a), as in Data.Tree - is a comonad.
09:17:06 <SwashBuckla> yitz: the alternative in the Stack Overflow post is interesting
09:17:36 <silver> @botsnack
09:17:36 <lambdabot> :)
09:17:49 <triliyn> Taneb: I think that would be a combination of fmap concat, sequence, and map
09:18:00 <Taneb> Yeah, I can fake it pretty well
09:19:11 <jomg> Taneb: maybe you'll find something with the arguments reversed
09:19:17 <SwashBuckla> I've not heard of the term comonad before
09:20:29 <yitz> SwashBuckla: yes that kind of tree *is* a monad. interesting. leave it to edwardk.
09:21:11 <yitz> SwashBuckla: it's what you get when you take the definition of a monad and reverse all of the arrows. it
09:21:22 <yitz> SwashBuckla: it's interesting, but far less useful than monad.
09:21:34 <Twey> Taneb: flip $ \xs f -> fmap concat . mapM f xs  has this type
09:21:53 <Taneb> Twey, yeah, that's roughly what I'm going for
09:23:24 <SwashBuckla> yitz: Data.Tree possesses a definition for instance Monad Tree: http://hackage.haskell.org/package/containers-0.2.0.0/docs/src/Data-Tree.html
09:23:26 <Twey> Err, minus the flip
09:23:40 <Twey> Taneb: \xs f -> concat <$> mapM f xs  rather
09:23:54 <Twey> Taneb: You could call it concatMapM
09:25:26 <Twey> (probably with the arguments reversed, though)
09:25:41 <yitz> SwashBuckla: it's a pretty unnatural and arbitray definition, and not useful for much.
09:25:46 <silver> concatForM? :D
09:25:58 <Twey> Heh
09:26:43 <Twey> And it's possible because Data.Tree has arbitrarily many children, so there's a meaningful concept of concatenation
09:31:58 <nshepperd> I wrote a treelike monad for representing game trees for AIs. but it's kind of inside-out wrt Data.Tree
09:32:18 <nshepperd> data Tree a b = Node [a] (a -> Tree a b) | Leaf b
09:33:30 <nshepperd> things with data as leaves seem to naturally turn into monads
09:34:44 <SwashBuckla> yitz: the author of that SO post wrote a package for those trees: https://hackage.haskell.org/package/rope
09:51:30 <Fuuzetsu> so http://hackage.haskell.org/package/optparse-applicative-0.10.0/docs/Options-Applicative-Builder.html#v:option tells me the type is (String -> ReadM a) -> Mod OptionFields a -> Parser a
09:51:55 <Fuuzetsu> and yet if I ask after I import I get option :: Read a => Mod OptionFields a -> Parser a
09:52:07 <Fuuzetsu> does anyone know how I'm meant to pass in own reader?
09:52:30 <Fuuzetsu> perhaps I'm meant to work on parser result and ‘fail’
09:55:34 <monochrom> Fuuzetsu: which version are you using? which version are you reading docs of?
09:56:52 <bergmark> i've used optional, but not option ;-o
09:58:03 <bergmark> Fuuzetsu: this might help you though: https://github.com/faylang/fay/blob/master/src/main/Main.hs#L120
09:58:33 <Fuuzetsu> monochrom: 0.10…
09:58:37 <yitz> Fuuzetsu: monochrom is correct. the type of option has changed.
09:58:39 <listofoptions> mmm caffeine
09:59:02 <Fuuzetsu> maybe my optparse is old somehow
09:59:20 <yitz> Fuuzetsu: i also agree with bergmark though: optional (from Control.Applicative) is very useful :)
09:59:21 <Fuuzetsu>     optparse-applicative-0.9.1.1
09:59:23 <Fuuzetsu> oh, so it is
10:07:30 <Shiela22>  You can find funny videos here. http://bit.ly/1mFMmyS
10:07:49 <luzie> is there a good replacement for Network.URI?
10:18:35 <t7> if i have a parsec parser like 'alphaNum' and i wanna skip all that is not alphaNum
10:18:39 <t7> can i do that?
10:19:25 <Fuuzetsu> many alphaNum *> return ()
10:19:38 <Fuuzetsu> what, that is not
10:19:46 <Fuuzetsu> s/what/wait/
10:21:45 <jfeltz> is there a library for haskell that isn't so fickle about numeric types? I just want to use Haskell for some simple numeric calculations, ala C/C++
10:21:52 <t7> i need inverse or something
10:23:09 <t7> or try OrSkip or something
10:23:17 <geekosaur> jfeltz, if strict typing is not what you want, perhaps Haskell is not the language to use
10:23:28 <jfeltz> geekosaur, hah, okay ;)
10:25:13 <amar^> @type (*) <$> (*) <*> (*)
10:25:14 <lambdabot> (Num (a -> a), Num a) => a -> a -> a
10:25:29 <amar^> can anybody please help me understand...
10:25:42 <c_wraith> amar^: that example is too complicated
10:26:03 <c_wraith> :t (*) <$> (*2) <*> (*3) -- amar^
10:26:04 <lambdabot> Num b => b -> b
10:26:06 <jfeltz> good god, who would put that in production code?
10:26:08 <jfeltz> nvm
10:26:18 <c_wraith> amar^: that example is a *little* less complicated :)
10:27:40 <amar^> okay, so here * gets fmapped over (*2) should give me => (Num a) => a -> a -> a which is (->) (a -> a)
10:27:50 <amar^> is it correct
10:28:01 <c_wraith> amar^: you need to consider what f is in f a
10:28:02 * geekosaur did suppress the urge to point at acme-php :p
10:28:23 <c_wraith> :t fmap
10:28:24 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:29:06 <c_wraith> amar^: if the type of (*2) unifies with `f a`, clearly something interesting is going on
10:30:11 <amar^> hmm, so *2 should be (->) Int
10:30:19 <c_wraith> amar^: you're missing something
10:30:20 <jle`> should it?
10:30:27 <jle`> :t (*2)
10:30:28 <lambdabot> Num a => a -> a
10:30:30 <c_wraith> amar^: primarily, you're missing that (->) takes *two* arguments
10:31:07 <c_wraith> amar^: so, if you want to make things concrete, (*2) :: (->) Int Int
10:31:12 <simpson> jfeltz: Technically, you can do the same thing in Haskell that you'd do in C/C++, using either floats or ints for everything. Haskell just requires you to admit when you're using ints as floats or floats as ints.
10:31:20 <doismellburning> :t (->)
10:31:21 <lambdabot> parse error on input ‘->’
10:31:32 <c_wraith> amar^: Then unify that with `f a` and you get f = (->) Int, a = Int
10:32:14 <amar^> c_wraith: Ah, my mistake...hmm now kinda clear...
10:33:34 <c_wraith> amar^: Once you get that far, the rest should work itself out in a straight forward way..  especially if you play with it with pen & paper.  For things like that, it really is hard to beat pen & paper as an exploratory tool.  It's just shuffling symbols around. :)
10:34:01 <Fuuzetsu> t7: you probably want to take a char (or bigger block) then try to take alphanum and repeat
10:34:33 <t7> i want manyTill that doesnt consume the last one :(
10:35:24 <t7> ah endby ?
10:35:34 <amar^> c_wraith: :) make sense, thank u
10:35:51 <Fuuzetsu> where are you getting endBy from?
10:36:04 <t7> nah i still need notAlphaNum
10:36:09 <t7> ffs!
10:36:46 <Fuuzetsu> just take alphanum and if it suceeds then you know that's it, if it doesn't then take a chunk, remember it and repeat
10:37:18 <t7> it doesnt succeed
10:37:23 <t7> i need to skip when it doesnt
10:37:36 <bennofs> t7: many (notFollowedBy alphaNum) should work
10:37:42 <Fuuzetsu> how about you tell me what you actually need to parse into what ;P
10:38:09 <Twey> t7: skipMany . satisfy $ not . isAlphaNum
10:38:31 <t7> Fuuzetsu: i am trying to get a list of words from string sepereted by anything other than alphanum
10:38:39 <bennofs> @msg augur Have you pasted the linker output somewhere?
10:38:39 <lambdabot> Not enough privileges
10:38:41 <Twey> Fuuzetsu: That's () <$ many alphaNum, or equivalently (with better resource usage) skipMany alphaNum
10:38:44 <bennofs> @tell augur Have you pasted the linker output somewhere?
10:38:44 <lambdabot> Consider it noted.
10:38:53 <eacameron> threadscope is showing that my OS threads are spending most of their time in GC and I'm basically only getting 1 thread worth of work at any given time...is that a common issue with a common solution?
10:39:29 <bennofs> Twey: alphaNum `sepBy` many_ (notFollowedBy alphaNum) ?
10:39:39 * Twey nods.
10:39:39 <bennofs> t7^
10:40:23 <Fuuzetsu> oh parsec
10:40:32 <Fuuzetsu> I was wondering where you all are getting these nice combinators from ;P
10:40:42 <augur> bennofs: hey
10:40:48 <Fuuzetsu> Twey: by the way I wrote Agda builder for nix yesterday!
10:40:54 <Twey> \o/  Nice job
10:41:11 <Twey> Now we can package the one third-party Agda package anyone cares about!
10:41:15 <augur> bennofs: ive just done the (annoying) thing where you trace all the symbols back to the libs and copy them all in
10:41:17 <Fuuzetsu> yep
10:41:21 <augur> bennofs: and that seems to make it work
10:41:22 <t7> ugh
10:41:32 <bennofs> augur: what were the missing libs?
10:41:39 <augur> bennofs: oh a whole bunch
10:42:01 <augur> bennofs: aside from base and rts, things like Cffi, some numeric stuff
10:42:09 <bennofs> ah
10:42:11 <augur> just like 6 or 7 random things
10:42:22 <augur> plus a dylib that wasnt being linked
10:43:21 <bennofs> maybe GHC has a flag to print out what it's linking, that'd be quite usefule
10:43:32 <amar^>  c_wraith: sorry to bother you again, but I have one more very unrelated question
10:44:01 <t7> http://lpaste.net/110348
10:44:07 <t7> that is my incomplete parser
10:44:35 <t7> ah that fails on trailing whitespace :|
10:44:42 <amar^> c_wraith: can you imagine any situation where Groovy's null safe operator will fail to compose, currently I can only imagine Just None case
10:44:58 <t7> is there something like 'not'
10:46:44 <t7> 'lookAhead' saves the day :D
10:46:45 <amar^> sorry they call it "safe navigation operator"
10:48:18 <chrisdone> shachaf: Cale: hpaste.org is a fine domain. i just don't control it, so it's inappropriate for me to rely on it for services that i run
10:48:36 <c_wraith> amar^: don't know enough about it.
10:49:39 <amar^> so its nothing but a syntactic operator for null navigations => you can achieve person.?findJob().?title
10:50:23 <chrisdone> amar^: x.?y is null if x.y is null, right?
10:51:08 <chrisdone> amar^: er, if x is null
10:51:20 <amar^> chrisdone: yup
10:51:21 <chrisdone> amar^: so it's like fmap y x
10:51:56 <chrisdone> except x.y is still y (fromJust x)
10:52:47 <amar^> correct, but its very rigid and not extensible
10:53:29 <amar^> can you think of any example where it will fail, and Maybe will work liek a bullet...I know there are many but couldnt just come with it :(
10:54:00 <amar^> I can imagine Just None case
10:54:02 <chrisdone> it seems the main problem is that x.y is still possible
10:54:16 <chrisdone> you simply have to forget to use .? and you are back to the same old null problem
10:54:25 <c_wraith> chrisdone: I think it's more accurate to say it's like x >>= y, since y could still return a null value
10:54:28 <chrisdone> or have code change so that .? should be needed
10:54:31 <amar^> yeah but there is  a thin, such languages have nullable types
10:54:38 <c_wraith> chrisdone: implicit nulls being allowed everywhere!
10:55:03 <amar^> so if type is not nullable, it cant contain null, so compiler is  aware
10:56:16 <monochrom> t7: I would write like http://lpaste.net/110349
10:56:24 <amar^> yeah and if you do x.y such that x is nullable, I assume compiler will cry, not sure though
11:00:52 <t7> monochrom: "not x"  doesnt exist :( so i have todo manyTill (lookAhead x)
11:01:00 <chrisdone> c_wraith: sure, either comparison works for me. there's no difference if `y' is null because there's no such thing as Just Nothing in these languages. null.?notNullField == notNullObj.nullField
11:03:51 <monochrom> t7: then not . alphaNum
11:04:07 <t7> errr
11:04:19 <t7> there is no   not :: Parser _ -> _
11:04:30 <monochrom> oh, I see, nevermind
11:04:41 <chrisdone> i've implemented that a couple times. bugs me that it doesn't exist
11:04:57 * hackagebot configuration-tools 0.2.4.1 - Tools for specifying and parsing configurations  http://hackage.haskell.org/package/configuration-tools-0.2.4.1 (larsk)
11:05:06 <chrisdone> notFollowedBy exists, though
11:05:25 <chrisdone> https://hackage.haskell.org/package/parsec-3.0.0/docs/Text-Parsec-Combinator.html#v:notFollowedBy
11:05:29 <monochrom> I don't like lookAhead
11:05:43 <chrisdone> heh, its example is: notFollowedBy alphaNum
11:06:09 <chrisdone> you don't need lookAhead for it
11:06:19 <chrisdone> just p *> unexpected "boo"
11:06:30 <monochrom> but I guess if I use try, it's even worse.
11:06:57 <chrisdone> i use try too much in parsec
11:10:12 <statusfailed> I have some code using machines that compiles in GHC 7.6.3 but not 7.8.3- it claims an instance of MonadIO doesn't exist in an imported module, but I can go to that module, copy out the instance, and it works
11:10:23 <statusfailed> Is that an obvious problem with something that changed between versions?
11:10:26 <statusfailed> or should I do a paste :p
11:10:48 <Fuuzetsu> maybe it just got removed?
11:10:55 <statusfailed> "machines" is a library, and the instance is instance MonadIO m => MonadIO (PlanT k o m)
11:11:01 <statusfailed> Fuuzetsu: I am on that version, and it's in the code
11:11:15 <statusfailed> also, both versions of GHC are compiling the same version of the library
11:12:22 <chrisdone> what's a word to describe the choice of {external | internal}?
11:13:19 <statusfailed> chrisdone: can you show us the sentence with a word-hole? :D
11:14:12 <chrisdone> statusfailed: the ____ of the entity is external/internal
11:15:02 <bennofs> chrisdone: visibility? scope?
11:15:10 <chrisdone> statusfailed: like, the cardinality of the set is 62. the arity of the function is 3
11:15:17 <chrisdone> bennofs: hmm, scope, not bad
11:15:29 <chrisdone> locality?
11:15:46 <statusfailed> tricky
11:16:20 <chrisdone> hm, locality makes me think more of continuous distance than discreteness
11:17:41 <statusfailed> are there any similar word pairs with a corresponding word?
11:17:47 <statusfailed> like inverted/everted ?
11:18:21 <monochrom> introvert, extrovert. vertness? :)
11:18:32 <bobbbbb> why wont this compile?
11:18:34 <bobbbbb> http://lpaste.net/110350
11:19:16 <monochrom> that is really big
11:19:24 <bobbbbb> error is at bottom of code http://lpaste.net/110350
11:19:45 <bobbbbb> from here http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Evaluation,_Part_1
11:19:50 <chrisdone> statusfailed: gender: male/female
11:20:09 <eacameron> so if an FFI is marked safe, how does it handle multithreading?
11:20:44 <wouter> > pure 1 :: [Int]
11:20:45 <lambdabot>  [1]
11:20:56 <wouter> > pure 1 :: Maybe Int
11:20:57 <lambdabot>  Just 1
11:21:05 <prophile> bobbbbb: because "No match: " ++ show err is a string
11:21:13 <prophile> and the function is meant to return a LispVal
11:21:14 <monochrom> ("No match: " ++ show err) is clearly String, not LispVal
11:21:37 <statusfailed> chrisdone: ..... well gender wasn't helpful :p
11:22:13 <statusfailed> I vote for monochrom's solution of a new word, but propose "vertity" :p
11:22:34 <chrisdone> statusfailed: modality: "necessary" / "contingent"
11:22:40 <chrisdone> lol
11:23:01 <bobbbbb> oh i see
11:23:04 <chrisdone> sexuality: homosexual / heterosexual
11:23:10 <bobbbbb> i missed that line :P
11:23:34 <monochrom> eacameron: I don't entirely understand your question, but read my http://www.vex.net/~trebla/haskell/ghc-conc-ffi.xhtml
11:23:39 <statusfailed> chrisdone: ternality then ?
11:23:57 <statusfailed> with "aternality" being the state of having neither :D
11:24:10 <statusfailed> or being a seabird
11:24:20 <McManiaC> .
11:25:12 <statusfailed> Here is a paste of my problem: http://lpaste.net/110352
11:25:17 <statusfailed> the magic disappearing typeclass (maybe)
11:25:49 <wouter> > (*) <$> [1, 2, 3]
11:25:51 <lambdabot>  [<Integer -> Integer>,<Integer -> Integer>,<Integer -> Integer>]
11:26:00 <bennofs> statusfailed: what's the version of machines on your system=
11:26:05 <statusfailed> bennofs: 0.2.5
11:26:16 <statusfailed> but now I have sudden doubts :|
11:26:20 <eacameron> monochrom: Ugg...it looks like many of the FFIs in mysql package are marked unsafe, which utterly destroys my highly concurrent program
11:26:42 <monochrom> it may be not so bad if they finish quickly
11:26:46 <statusfailed> bennofs: how do I double check
11:26:55 <bennofs> statusfailed: ghc-pkg list machines
11:27:23 <statusfailed> bennofs: yes, 0.2.5
11:27:24 <monochrom> OTOH mysql calls are expected to block for several seconds all the time. unsafe is unwise for this.
11:27:25 <bennofs> statusfailed: please also ghc-pkg list mtl
11:27:42 <statusfailed> ah I have two versions of mtl
11:27:47 <monochrom> I mean, it is not even sqlite
11:27:53 <statusfailed>    mtl-2.1.3.1
11:27:54 <statusfailed>    mtl-2.2.1
11:27:54 <bennofs> statusfailed: then that's your problem
11:28:01 <wouter> If I do (*) <$> [1,2,3] I get No instance for (Show (a0 -> a0)) arising from a use of `print' why?
11:28:04 <statusfailed> can I do "ghc-pkg unregister mtl--2.1.3.1"  ?
11:28:09 <wouter> lambdabot ok
11:28:11 <chrisdone> use of mysql is also unwise
11:28:22 <bennofs> statusfailed: no, machines is built against the 2.1.3.1 version
11:28:39 <bennofs> statusfailed: and currently has an upper bound < 2.2  on mtl
11:28:53 <statusfailed> oh I see
11:28:56 <monochrom> the poster-child of legit use of unsafe is C math.h's sin and cos :)
11:29:03 <eacameron> chrisdone: you mean the package or the DB?
11:29:06 <statusfailed> bennofs: is there a nice way out here
11:29:12 <bennofs> statusfailed: so you'll need to unregister mtl-2.2
11:29:12 <chrisdone> eacameron: the db =)
11:29:25 <bennofs> statusfailed: and re-install all transitive dependencies
11:29:36 <statusfailed> bennofs: okey dokes, thanks :)
11:30:02 <bobbbbb> why cant I eval this with my code? http://lpaste.net/110350  its at bottom of code
11:30:13 <eacameron> chrisdone: monochrom: I have been trying to figure out why added concurrency increasingly SLOWS my program and finally I thought to check the FFI....I'm pretty sure this is my issue
11:31:30 <bergmark> bobbbbb: you are probably getting a poor error message because you are using `try', try to not do that
11:32:44 <chrisdone> bergmark: i think the opposite
11:32:50 <bobbbbb> i have so many trys though
11:32:51 <chrisdone> parseExpr = parseAtom
11:32:52 <chrisdone>   	 <|> parseString
11:32:52 <chrisdone>   	 <|> parseRatio
11:32:52 <chrisdone>  	 <|> parseComplex
11:32:55 <chrisdone>   	 <|> parseFloat
11:33:00 <chrisdone> parseAtom = do first <- letter <|> symbol
11:33:05 <chrisdone> this will immediately fail on "2"
11:33:22 <monochrom> there is a way to use try and give good messages. there is also a way to use try and give bad messages.
11:34:01 <monochrom> therefore, false dichotomy. (the correct dichotomy is the scope of try and the placement of the message.)
11:34:02 <chrisdone> ah, here it is:
11:34:03 <chrisdone> parseRatio = do x <- many1 digit
11:34:03 <chrisdone>                 char '/'
11:34:13 <chrisdone> hence, your error:
11:34:13 <chrisdone> No match: "lisp" (line 1, column 2):
11:34:13 <chrisdone> unexpected end of input
11:34:13 <chrisdone> expecting digit or "/"
11:34:51 <chrisdone> so either your integer parsing needs to precede ratio parsing, or your ratio parsing needs to be try'd
11:34:58 <merijn> blah, the more I see of stuff at ICFP the sadder I get for not being there :\
11:35:14 <chrisdone> (likely to be the latter, because otherwise your int parsing will fail on 2/3)
11:35:20 <bobbbbb> chrisdone: ok lemme try that ty
11:35:32 <monochrom> someone wrote a blog article on good scope of try and good placement of the message. but he/she wrongly equate good scope of try with good length of definition.
11:38:29 <bobbbbb> chrisdone: i am having some trouble still
11:38:42 <bobbbbb> would you mind editing my code to show me?
11:39:22 <bobbbbb> http://lpaste.net/110350
11:39:24 <statusfailed> bennofs: hm, I did "ghc-pkg unregister mtl; ghc-pkg unregister machines; cabal install machines": all successful, but still the same issue
11:39:44 <bennofs> statusfailed: does ghc-pkg list mtl list only one mtl?
11:40:11 <bennofs> statusfailed: you might also need to do the same for transformers (not sure). Also, you shouldn't need to reinstall machines
11:41:24 <statusfailed> bennofs: yes it does
11:41:30 <statusfailed> i'll look at transformers too
11:41:45 <statusfailed> ah yes, same problem
11:42:07 <simpson> I am sad that it's not possible to pattern-match on Data.Seq.Seq.
11:42:28 <statusfailed> bennofs: woohoo! thanks very much!
11:42:50 <bergmark> simpson: but it is: https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms
11:42:56 <monochrom> Data.Seq? Data.Sequence?
11:43:24 <simpson> Yeah, Data.Sequence, sorry.
11:43:43 <eacameron> monochrom: no they are pretty big queries, they take a second or two each
11:43:53 <simpson> Just fixing up code that uses lists to use Seq instead, and it's requiring a lot more code to be written out.
11:43:56 <monochrom> but you should rejoice, since it provides viewl and viewr, so it is not only possible to pattern-match, it is possible to pattern-match two ways!
11:44:24 <eacameron> do veiewl and viewr "deconstruct" the sequence like ":" does?
11:44:32 <monochrom> yes
11:44:39 <eacameron> ahhh very nice
11:44:51 <chrisdone> huh. was lpaste bot kicked out of #haskell?
11:46:53 <simpson> monochrom: Sure, but it's not possible to write those patterns into function definitions directly. I could do `f [x, y] = ...` before, but I can't do the same thing with Seq.
11:47:23 <ski> augur : "<augur> Cale: lets read the quine paper!" -- which Quine paper ? do you mean the book "Word and Object" ?
11:47:37 <ski> wz1000 : yes
11:47:43 <augur> ski: whichever paper he discusses RT in
11:48:24 <monochrom> let me see if ViewPatterns has a fine print that lets us do that
11:48:31 <Hodapp> I read a quine paper once, but then my notes just ended up duplicating verbatim all of the content of it.
11:49:43 <chrisdone> ah, seems like lpaste was QUIT'd in the netsplit on the 29th and never rejoined the channel. how queer
11:50:23 <monochrom> f (viewl -> x :< (viewl -> y :< (viewl -> EmptyL))) = ... :)
11:51:03 <simpson> monochrom: Well played. Verbose but workable.
11:51:08 <ChristianS> #haskell has become bigger than #python. nice!
11:51:43 <simpson> ChristianS: Note that #python plays with a handicap; only logged-in users can /join #python.
11:51:47 <merijn> ChristianS: #haskell has been bigger than #python for years, I think?
11:52:35 <ski> simpson : for each fixed length, you could define a helper function
11:52:36 <c_wraith> simpson: as of GHC 7.8, you can use -XPatternSynonyms to make it less verbose
11:52:39 <Hodapp> How ironic that #python has to check the type of the user.
11:52:51 <chrisdone> bobbbbb: http://lpaste.net/diff/110353/110355
11:52:53 <c_wraith> Hodapp: nah, it's checking a tag.  python's cool with that.
11:52:56 <chrisdone> bobbbbb: something like that
11:53:29 <simpson> ski: I've been thinking about doing that as well, yeah.
11:54:56 <ChristianS> merijn: when i checked earlier they were usually about the same size, with #python a bit bigger. but since a few weeks or so, #haskell wins.
11:55:23 <chrisdone> haskell has been the biggest language channel for years
11:55:31 <chrisdone> probably it's #python whose size has increased
11:57:27 <merijn> yeah, when I switched from python to haskell a few years back python was around 600 and haskell hovering between 1000-1100
11:57:40 <zygentoma> Hi. How do I load the Queue module into ghci?
11:59:02 <chrisdone> :l Queue
11:59:21 <dfeuer> OK I SHOULD BE GONE NOW.
11:59:28 <Hafydd> w 25
11:59:35 <Hafydd> Whoops.
11:59:37 <zygentoma> chrisdone: okay, thanks.
11:59:38 <bobbbbb> chrisdone: that doesnt fix the error
11:59:52 * dfeuer just spent a bunch of time on things like concat . inits
11:59:56 <zygentoma> seems that I don't have the module installed though … :(
12:00:19 <zygentoma> Do you know how to install it under debian/ubuntu?
12:00:33 <chrisdone> zygentoma: what is the Queue module?
12:00:52 <zygentoma> um …
12:00:55 <monochrom> you cannot use :load for a library module.
12:00:55 <dfeuer> There are probably a lot of Queue modules.
12:01:10 <zygentoma> the one from here I guess … http://stackoverflow.com/questions/8915937/usage-of-queues-in-haskell-module @ chrisdone
12:01:40 <chrisdone> zygentoma: you have that code in a file called Queue.hs?
12:01:50 <monochrom> do you have its source code? in your current directory?
12:01:54 <zygentoma> um … nope
12:02:09 <monochrom> ok, you're loading from an empty disk.
12:02:16 <dfeuer> zygentoma, that is an absurdly inefficient implementation of queues, unless the queues are under, say, ten elements.
12:02:37 <zygentoma> thought there was one, maybe, from the haskell platform …
12:02:58 <zygentoma> oh, i see, it is an implementation …
12:03:11 <dfeuer> zygentoma, not that I know of. But you should look up Okasaki's "banker's queues" and implement those. They're really, really simple.
12:03:37 <zygentoma> dfeuer: thanks a lot
12:04:05 <chrisdone> zygentoma: do you want to implement a queue or use an existing library?
12:04:28 <zygentoma> chrisdone: I'd like to use an existing one
12:04:39 <dfeuer> zygentoma, you can probably find one on Hackage somewhere.
12:04:51 <chrisdone> http://hackage.haskell.org/packages/search?terms=queue
12:05:00 <zygentoma> preferably a standard implementation shipped with ghc as well
12:05:12 <dfeuer> chrisdone, that is not as helpful as you might think.
12:05:34 <chrisdone> dfeuer: fascinating.
12:05:46 <chrisdone> zygentoma: what kind of queue do you want?
12:07:04 <dfeuer> chrisdone, not so much, but I would venture to guess that most people who want banker's queues just implement them themselves, so no one may have bothered to put them on Hackage....
12:07:21 <zygentoma> chrisdone: a simple fifo is all I need
12:07:40 <dfeuer> They are, however, a couple times faster than, say, http://hackage.haskell.org/package/queuelike-1.0.9/docs/Data-Queue-Queue.html
12:08:03 <dfeuer> Because Sequences really are slower than simple queues.
12:08:05 <monochrom> http://hackage.haskell.org/package/stm-2.4.3/docs/src/Control-Concurrent-STM-TQueue.html#TQueue :)
12:08:10 <chrisdone> re-implementing things over and over again makes us no better than the animals
12:08:34 <monochrom> we are already no better than the animals
12:08:36 <merijn> Are banker's queues the double list + reverse with amortised O(1) ones?
12:08:47 <chrisdone> monochrom: shh, the animals will hear
12:08:58 <dfeuer> meretrix, yeah, the absurdly simple ones. Just remember to UNPACK the front and rear lengths.
12:09:07 <Peaker> merijn: I wrote my own Control.Exception primitives that use uninterruptibleMask around the cleanups, and boy what an improvement :) I think this should go into base
12:09:16 <ski> simpson : .. in Mercury, this would just be a reverse mode of a function
12:09:26 <Peaker> merijn: one easy-to-debug deadlock in exchange for tons of cryptic incorrectness bugs and leaks
12:09:46 <Peaker> Really really bad idea to have the cleanups be interruptible
12:09:59 <merijn> Peaker: I'm in favour of campaining for better async safe exception/threading stuff in base
12:10:02 <Peaker> (To make deadlocks less likely, all cleanup invariants are off)
12:10:12 <Peaker> Very very bad trade-off
12:10:34 <simpson> ski: Yeah. I think for now I'm just going to -XViewPatterns and write some helpers.
12:10:38 <merijn> Peaker: Do you still allow allocations to be interruptible?
12:11:00 <Peaker> merijn: yeah, that's completely fine
12:11:13 <Peaker> merijn: no invariants are broken if that code is simply exception safe and cancels the allocation properly
12:11:22 <monochrom> I guess deadlock-avoidance is overrated
12:11:34 <monochrom> or deadlock-fearmongering
12:11:49 <Peaker> monochrom: deadlock avoidance is extremely important, but invariants preservation of bracket/finally cleanups are even more important
12:11:55 <merijn> The fearmongering around uninterruptibleMask is bad
12:12:12 <Peaker> "readMVar", "withMVar" breaking your MVar in the name of avoiding a deadlock is a really bad thing to do
12:12:15 <bennofs> Couldn't there be a variant of mask that throws any exception as a DeadlockException that cannot be caught?
12:12:16 <merijn> A lot of bracket/finally code is not actually async safe
12:12:43 <bennofs> That way, you would get a proper exception and not just a deadlock
12:13:09 <Peaker> bennofs: but it's not necessarily a deadlock to get an exception in cleanup, it may just be postponed
12:13:24 <dfeuer> chrisdone, it's also possible people can't decide whether to use a front and rear length or just hold the difference and count on rotate.... I dunno. I saw one or two implementations on github or somewhere once, but haven't been able to find them lately.
12:13:26 <bennofs> oh right
12:13:32 <merijn> Peaker: Are these primitives on github/whatever somewhere?
12:15:10 <chrisdone> i expect zygentoma doesn't care and just wants an API that does what he wants so he can continue writing his program
12:15:16 <merijn> I'd also be in favour of starting an async exception safety cabal, where people can get others to audit their code fo async exception safety :p
12:15:37 <merijn> Because I'm not sure I trust my own auditing skills to audit my own code :p
12:16:07 <chrisdone> the implicitness of async exceptions are a real PITA, they make haskell code as unpredictable as regular java code
12:16:16 <monochrom> replace auditing skill by verification.
12:16:37 <merijn> monochrom: I'd love to, give me a verification system for async exceptions? :)
12:16:47 <ski> simpson : i suppose one could possibly also use some Template Haskell to solve the "arbitrary list length" generalization of the problem
12:16:50 <dfeuer> chrisdone, when I'm finished with my current list fusion tear, I'll try benchmarking a few queue implementations and attempt to learn to use Cabal and put them on Hackage.
12:17:01 <dfeuer> That could be a while though.
12:17:05 <chrisdone> merijn: Ho, ho, ho! You're confusing theory with practice! — John McCarthy
12:17:20 <merijn> chrisdone: How would you make async exceptions explicit?
12:17:28 <merijn> chrisdone: That doesn't even make any sense?
12:18:21 <merijn> Peaker: Well, the blocking during allocation actually does matter
12:19:30 <Peaker> merijn: why?
12:19:37 <merijn> Peaker: Suppose my initialisation involves 4 steps, 1 of which allocates a resource that needs cleanup, which I return. If any of the other 3 can block and thus get an async exception I could like the final resource as it's cleanup hasn't been setup when my allocation gets interrupted
12:19:58 <Peaker> merijn: but that means your initialization is buggy
12:20:16 <merijn> Peaker: Well, you're welcome to fix it :)
12:20:25 <Peaker> merijn: imagine writing it like:  withABC f = withA $ \a -> withB $ \b -> withC $ \c -> f a b c
12:20:26 <chrisdone> buggy as in not-atomic?
12:20:46 <Peaker> merijn: if during allocation you get an exception the cleanups will happen properly (assuming they are uninterruptible)
12:20:47 <merijn> Peaker: You're assuming the allocation of A, B and C are independent
12:20:52 <Peaker> chrisdone: not installing handlers properly
12:21:03 <Peaker> merijn: this form allows dependency (withB can take "a" as an argument)
12:21:37 <monochrom> it has staged dependence or independence
12:21:47 <monochrom> you may call it lineariable
12:21:53 <monochrom> err, linearizable
12:21:58 * dfeuer is guessing that whatever merijn is saying probably makes some kind of sense...
12:22:00 <chrisdone> bracket (do x <- allocate; putStrLn "woop"; return x) …
12:22:01 <merijn> Peaker: In my example I think I'm fine since I can move the only resource that needs freeing at the end (i.e. I fork a thread that needs to be killed)
12:22:08 <chrisdone> i think is an example of merijn's allocation code
12:22:12 <Peaker> merijn: but you can also use "bracketOnException"
12:22:12 <monochrom> typing is hard, I want my telepathic keyboard now! :)
12:22:15 <merijn> chrisdone: Right
12:22:39 <chrisdone> (i think `putStrLn' yields)
12:22:45 <MagneticDuck> monochrom: well, you can try to learn steno, so that... it becomes even harder, and it's near impossible to write code
12:22:48 <merijn> chrisdone: No, but it involves taking an MVar
12:22:53 <Peaker> chrisdone, merijn: But this is bad, you need to wrap "allocate" with bracketOnException "release", at the very least
12:22:58 <merijn> chrisdone: Which means it potentially blocks, making it interruptible
12:23:08 <Peaker> chrisdone, merijn: And yeah, you need to be careful with putStrLn, I have a wrapper that puts uninterruptibleMask around it
12:23:34 <chrisdone> merijn: right, no explicit call to 'yield' but implicitly it allows the scheduler to interrupt it
12:23:38 <merijn> Peaker: Well, right now I'm reordering the code to allocate that resource last
12:23:49 <merijn> chrisdone: The problem doesn't have to do with yielding
12:23:59 <Peaker> chrisdone, merijn: Unless I'm missing something, I'm pretty sure it's very possible to make allocations be async-exception safe while still allow them without deadlocks (best of all worlds, yay!) though I agree it can be a bit tricky (e.g: putStrLn interrupting you)
12:24:02 <chrisdone> merijn: what does 'yield' mean to you?
12:24:05 <merijn> chrisdone: I'm pretty sure yield is async safe, I don't think it qualifies as blocking?
12:24:11 <tomh-> guys, which haskell GUI library is the most mature these days? (with windows support)
12:24:15 <Peaker> chrisdone, merijn: For cleanups, though, it's no-go -- they must simply be uninterruptible, period.
12:24:19 <merijn> chrisdone: The GHC internal yield?
12:24:38 <chrisdone> merijn: i don't know. whichever you're arguing about =)
12:24:48 <zygentoma> chrisdone: well, thats not the problem, I'd just like to keep the code short, because I'm writing sort of an example code
12:24:55 <merijn> chrisdone: yield to me means: http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Concurrent.html#v:yield
12:25:06 <Peaker> merijn: I'd still suggest wrapping the resource with bracketOnException anyway and when you compose it with the other resources, use ordinary brackets to release it
12:25:32 <merijn> chrisdone: And I'm not sure whether that qualifies as blocking in terms of exceptions
12:25:49 <zygentoma> but now I'll probably just mention that the queue implementation is needed as well and put it on the side or sth. …
12:26:02 <merijn> Peaker: Is there a nicer/cleaner way to work with bracket and friends? Right now they tend to result in a steady march to the right for me...
12:26:19 <merijn> Or a billion one-of name definitions to avoid that
12:28:05 <Peaker> merijn: I think you're supposed to give a "withX" name for each bracket:    withFile .. = bracket (openFile ..) closeFile     and then you can use withX $ \x -> NEWLINE withY $ \y -> ... with no indentation there
12:28:06 <chrisdone> merijn: i think rather in reverse, blocking on IO is to implicitly allow a yield. "let other threads do work on this core"
12:28:29 <MagneticDuck> question: what do you guys do to run a ghci session that loads a module exported by a cabal project that you're actively editing and building?
12:28:33 <Peaker> chrisdone: even allocating yields to other threads, doesn't it?
12:28:48 <dcoutts_> MagneticDuck: cabal repl
12:28:51 <MagneticDuck> it's kind of annoying to have to be constantly killing and restarting ghci, althugh that's what I've done for all my dev until now
12:28:54 <Peaker> chrisdone: I just think of Haskell threads as preemptive (as a good approximation)
12:29:00 <merijn> chrisdone: Blocking on IO implicitly allows a yield, but yielding does not mean blocking, they are different
12:29:09 <MagneticDuck> dcoutts_: sounds cool
12:29:11 <MagneticDuck> what does it do
12:29:16 <merijn> chrisdone: Blocking on an MVar removes a thread from the ready queue, yielding does not
12:29:22 <chrisdone> Peaker: i think so, but if you interrupt that allocation it's fine. the demo was do x <- allocate; interruptible; return x; in this case the allocation completed fine, but its result is now a leak
12:29:30 <merijn> chrisdone: The entire reason to allow interrupting blocked threads is deadlock
12:29:36 <dcoutts_> MagneticDuck: loads a cabal project in ghci
12:29:41 <merijn> chrisdone: A thread that yields (but not blocks) does not risk deadlock
12:30:00 <merijn> chrisdone: Therefore I don't see a reason why yield should incur async exceptions while masked, unlike blocking
12:30:03 <MagneticDuck> dcoutts_: !
12:30:07 <MagneticDuck> dcoutts_: but it's a cabal command
12:30:10 <merijn> chrisdone: Although I don't know the implementation, so can't say for sure
12:30:15 <MagneticDuck> wait, wat??
12:30:31 <MagneticDuck> oh
12:30:33 <MagneticDuck> cool
12:30:39 <MagneticDuck> thanks <3
12:30:42 <dcoutts_> np
12:31:08 <Peaker> chrisdone: but that's why you're supposed to use bracket there and be careful to avoid putStrLn and other interruptible stuff (not to be confused with yielding stuff) in your allocation segment of the bracket
12:31:31 <chrisdone> merijn: i didn't personally mention block anywhere so all your discussion about that is lost on me
12:31:59 <Peaker> chrisdone: "do x <- allocate ; interruptible `onException` release x; return x"
12:32:02 <chrisdone> Peaker: sure. was just putting an example of merijn's as a straw man for discussion
12:32:42 <chrisdone> bracket's first arg should be "atomic". do one thing that can either be interrupted safely or complete entirely
12:32:43 <Peaker> I agree this is somewhat tricky -- but using uninterruptibleMask to avoid this is even worse -- allocations blocking are very useful to cancel with async exceptions
12:32:50 <merijn> chrisdone: We were discussing the problem with blocking on allocation in bracket, you came up with yield
12:32:54 <Peaker> There's simply no alternative to using uninterruptibleMask on the cleanup though
12:33:15 <Peaker> chrisdone: yeah, and you can build that atomicity with "onException" in the inner actions
12:33:25 <chrisdone> merijn: nevermind. you're fixated on a particular meaning of 'yield' i can't shake
12:33:43 <merijn> chrisdone: You said "putStrLn" yields, but yielding and blocking are different, which I was trying to point out
12:34:00 <chrisdone> ok
12:34:20 <Peaker> I think "yielding" is not related to the exceptions stuff, and "blocking" does not necessarily imply "interruptible" (some blocking stuff may be uninterruptible)
12:34:33 <merijn> In that both stop execution of the current thread, but one puts the thread back on the end of the runnable queue, whereas the other removes it from the runnable queue
12:34:33 <Peaker> so the term used by the Control.Exception documentation is "interruptible" operations
12:35:11 <chrisdone> i meant yield just as a word to use for making your atomic thing unatomic
12:35:39 <Peaker> "interruptible" operations temporarily disable "mask" but not "maskUninterruptible".  Which is somewhat confusing!
12:35:40 * dfeuer looks up. merijn, a thread that yields but does not block risks livelocking, which is worse.
12:35:42 <chrisdone> if allocateResource happens in one step, do x <- allocateResource; thing; return x; -- the thing introduces a split in your atomicity
12:36:06 <dfeuer> Well, maybe not exactly. Hmmmph.
12:36:08 <Peaker> chrisdone: Only if "thing" is interruptible
12:36:12 * dfeuer is confused.
12:36:33 <dfeuer> Sorry.
12:36:35 <Peaker> chrisdone: for the relevant meaning of atomicity here (since this is likely to be put in a bracket)
12:36:42 <Peaker> chrisdone: (which will put it under a "mask")
12:37:01 <chrisdone> peaker: hmm, though, what about bind? is:  mask x >> mask y equivalent to mask (x >> y)?
12:37:07 <MagneticDuck> http://ix.io/e8M <-- running this with a 300,000 character Text as input; it take *a huge amount of time*
12:37:27 <Peaker> chrisdone: nope, the former will check for async exceptions between x and y
12:37:55 <chrisdone> right. so perhaps the interruptability of thing doesn't matter?
12:38:00 <MagneticDuck> 20 seconds.
12:38:20 <MagneticDuck> ... isn't Data.Text supposed to handle huge amounts of text gracefully? What's going on? Is it my fault?
12:38:25 <chrisdone> bracket (do x <- mask allocateResource; mask thing; return x)
12:38:30 <chrisdone> is this a correct allocation expression?
12:38:44 <Peaker> chrisdone: the interruptibility of "thing" means that it cancels the "mask" :(
12:38:51 <chrisdone> oh, true
12:39:02 <Peaker> chrisdone: bracket puts a mask over the whole thing
12:39:07 <Peaker> chrisdone: so the masks inside are superfluous
12:39:22 <chrisdone> ah, there lies the problem. i see
12:40:08 <MagneticDuck> btw the list returned is only 1052 entries long
12:40:08 <Peaker> canceling the mask in various arbitrary operations is extremely error-prone. Unfortunately, not doing so is also error-prone
12:40:09 <dfeuer> The problem is that the whole thing appears to be too complicated for anyone to really understand properly.
12:40:48 <Peaker> dfeuer: After a few hours of research, scratching my head after hitting various bugs, it finally all sunk in. And my conclusion is that Control.Exception is currently very very broken!
12:41:03 <Peaker> Fortunately you can wrap it
12:41:29 <merijn> Peaker: I would support a campaign on libraries@ to make the mask uninterruptible
12:41:30 <dfeuer> Peaker, I don't know about Control.Exception, and I don't know much about concurrency, but what's very clear is that concurrency in general is *absurdly* complex.
12:41:34 <merijn> Peaker: eh, cleanup, that is
12:41:38 <chrisdone> peaker: now all you have is runtime bugs!
12:42:07 <Peaker> merijn: only the cleanup mask..
12:42:10 <Peaker> merijn: ah, yeah :)
12:42:38 <Peaker> chrisdone: heh, I fixed all my exception safety bugs! Took a day of tedious debugging
12:42:47 <Peaker> chrisdone: and I replaced Control.Exception with my own one which helped a lot
12:43:03 <dfeuer> Peaker, what's wrong with Control.Exception, if I may ask?
12:43:24 <Peaker> dfeuer: that it doesn't use uninterruptible-mask on cleanup operations (onException, bracket, finally, etc)
12:43:38 <dfeuer> Yeah, I don't know what that means exactly.
12:43:42 <dfeuer> Forget it.
12:44:10 <MagneticDuck> anybody available to help me figure out my misuse of Text?
12:45:09 <Peaker> dfeuer: I can explain if you're interested
12:45:44 <dfeuer> Peaker, I'm interested. I don't have too much time to spend on it right now, but if you want to give the broad overview, I'm listening...
12:46:02 <burp> MagneticDuck: just had a quick look, looks like you unpack stuff into Strings and use [Char] = String functionality
12:46:23 <Peaker> dfeuer: there are 3 states of an IO thread: Normal, Masked(Interruptible), Masked(Uninterruptible).    These states relate to ability to receive async exceptions.
12:46:35 <burp> MagneticDuck: do you need to use Strings, doesn't Text provide what you need alone?
12:47:43 <Peaker> dfeuer: Masked(*) means async exceptions are blocked(wait until the thread unmasks again). However, Masked(Interruptible) also means that certain blocking(ongoing, non-immediate) operations undo the masking state for the duration of their own operation
12:47:55 <MagneticDuck> burp: just for pattern matching
12:48:00 <burp> MagneticDuck: I'm quite certain this is your point of slowness
12:48:06 <MagneticDuck> I'm just unpacking a 4-character string.
12:49:09 <Kaidelong> looking at Free I get the feeling Fix Free is useful somewhere, somehow
12:49:14 <dfeuer> Peaker, that sounds complicated already.
12:49:30 <Peaker> dfeuer: the general idea is that async exceptions let you safely kill a thread
12:49:46 <MagneticDuck> burp: hm.
12:49:48 <Peaker> dfeuer: but if that thread is currently doing something that must not be interrupted (e.g: two operations that must happen both or none)
12:49:55 <c_wraith> Kaidelong: I don't think that is well-kinded
12:50:05 <burp> MagneticDuck: why do you want to pattern match against a String, and not Text?
12:50:08 <Peaker> dfeuer: it can use "mask" around both and then the exceptions happen before/after but not during
12:50:28 <Peaker> dfeuer: but then if one of those operations is, say, takeMVar, which may block indefinitely, it temporarily re-allows exceptions, which is a big headache
12:50:29 <MagneticDuck> burp: okay, I'll change that
12:50:35 <burp> MagneticDuck: I recommend {-# LANGUAGE OverloadedStrings #-}
12:50:38 <linman32> hi, i have type mismatch error: expected `IO t0, b0', actual `f0 a0 -> f0 b1'
12:50:39 <linman32> http://lpaste.net/110356
12:50:43 <Kaidelong> c_wraith: oh that's right, that's not what I meant though
12:50:45 <linman32> does anyone know what the problem is?
12:50:52 <burp> then you don't even need a (pack "</m>")
12:51:10 <Peaker> dfeuer: when you're in Masked(Uninterruptible) everything is simpler (guarantee no async exception will bother you) but then it's easy to deadlock, because anyone trying to throw async exceptions at you is also blocked waiting for you to unmask again
12:51:17 <dfeuer> Peaker, so I guess that means you can't safely takeMVar in such a section?
12:51:26 <Kaidelong> although I can't think of how to express what I was thinking of
12:51:27 <Kaidelong> so maybe it's not possible
12:51:47 <Peaker> dfeuer: sometimes it's fine to get an exception during a "takeMVar" even in a masked zone, (as long as you handle it properly)
12:51:54 <Peaker> dfeuer: getting it right is indeed tricky
12:52:04 <MagneticDuck> burp: I'll try http://ix.io/e8N ?
12:52:15 <Peaker> dfeuer: which is why the standard Haskell libraries get it all wrong!
12:52:19 <burp> MagneticDuck: yea
12:52:31 <Kaidelong> something like "Refl u (forall t. (Flip Free) t) -> Fix u"
12:52:32 <Peaker> merijn: so how do we start the campaign? :)
12:52:44 <MagneticDuck> burp: still takes a long time ._.
12:52:47 <MagneticDuck> 20 seconds
12:52:52 <Kaidelong> Fix ((Flip Free) t)?
12:53:09 <burp> MagneticDuck: ah, then I need to understand what it does :D
12:53:15 <mauke> linman32: what is that fmap doing there?
12:53:23 <c_wraith> Kaidelong: newtype FreeX a = X (Free FreeX a)  ?  (I think that's well-kinded)
12:53:33 <merijn> Peaker: Send a proposal to libraries@ arguing the point and then wait for sane people to +1 it? :p
12:53:42 <MagneticDuck> burp: =P
12:53:48 <linman32> mauke: i don't know. someone may have mistakenly advised to use it here
12:53:50 <merijn> Or back people into corners at ICFP and force them to fix it, unfortunately I'm not at ICFP :p
12:53:52 <MagneticDuck> I'll comment it to make it a bit easier
12:54:13 <Kaidelong> mmm, now that I think of it, I can't see how that'd possibly be any different from Free Identity
12:54:50 <c_wraith> Kaidelong: It is slightly different, in that Pure nodes contain...  more trees!
12:55:01 <c_wraith> Kaidelong: oh wait, no they don't
12:55:19 <burp> MagneticDuck: should it split at </m> or something?
12:55:19 <c_wraith> Kaidelong: then yeah..  It lets you make your trees... tree-er
12:55:25 <MagneticDuck> burp: http://ix.io/e8O
12:55:36 <Kaidelong> do you even get a tree?
12:55:41 <MagneticDuck> I'm doing some very simple xml parsing
12:55:44 <Kaidelong> I don't think you do, actually
12:55:47 <MagneticDuck> I could use a library >_>
12:55:52 <MagneticDuck> but wondering why this doesn't work
12:55:58 <Kaidelong> you need a functor that introduces some kind of structure to get a tree out of Free
12:56:02 <Kaidelong> Free doesn't do that on its own
12:56:18 <c_wraith> Kaidelong: huh.  I guess your right.  The only thing you get is a nested chain of newtype constructors before an eventual Pure node
12:56:21 <dfeuer> Thanks, Peaker.
12:56:22 <c_wraith> *Youre
12:56:26 <c_wraith> *You're.  typing is hard
12:56:42 <dfeuer> HMMMM. That's a problem.
12:57:06 <c_wraith> Kaidelong: though you could also get nested Free constructors...  So in that sense, it's kind of isomorphic to (Nat, a).  (ignoring bottoms)
12:57:24 <Peaker> merijn: ok :)
12:57:27 <dfeuer> The version of scanl' that rewrites back to a simple form ends up making code slower than the version that doesn't try to do that.
12:57:35 <c_wraith> Kaidelong: I suppose that's also true of Free Identity
12:57:42 <Kaidelong> yeah although the Free constructor doesn't encode anything Identity can't
12:57:42 <Kaidelong> yeah
12:57:48 <burp> MagneticDuck: ok, but please never use that thing for parsing :D
12:57:55 <MagneticDuck> burp: what thing?
12:57:56 <burp> with the hardcoded numbers and such
12:58:02 <burp> the thing you have written there ^^
12:58:11 <MagneticDuck> it's a hand coded parser.
12:58:22 <MagneticDuck> it's not a parsing library or a parsing framework or anything
12:58:34 <c_wraith> Kaidelong: I guess the point is that Free is already recursive like that.  You can't make it *more* recursive by feeding it to itself
12:58:34 <MagneticDuck> :D
12:58:45 <eikke__> why is Control.Concurrent.STM.TArray in Control?
12:58:50 <merijn> MagneticDuck: What burp is trying to say is "the performance of that will suck"
12:59:05 <MagneticDuck> merijn: because of hardcoded numbers? >_>
12:59:06 <merijn> eikke__: Same reason the rest of Control.Concurrent is
12:59:23 <Kaidelong> yeah in a sense "Free (Free (Free (Free .." is isomorphic to "Free Identity"
12:59:26 <burp> I was more like meaning the reliability
12:59:30 <MagneticDuck> merijn: but how can I make it faster?
12:59:35 <MagneticDuck> just kind of curious
12:59:36 <linman32> mauke: w/o fmap, the error is: expected `(IO t0, b0)', actual `IO (EventBox, Image)'
12:59:42 <MagneticDuck> I don't see any obvious ways to make that any faster
12:59:44 <MagneticDuck> it's a very simple algorithm
12:59:52 <merijn> MagneticDuck: By using a proper parsing library that's had hours of optimisations ;)
13:00:04 <eikke__> merijn: Control.Concurrent makes sense for things like forkIO and whatnot, but not MVar/TArray/... IMHO
13:00:04 <MagneticDuck> oh well ._.
13:00:09 * hackagebot haste-compiler 0.4.2 - Haskell To ECMAScript compiler  http://hackage.haskell.org/package/haste-compiler-0.4.2 (AntonEkblad)
13:00:14 <Kaidelong> I wonder if that can be generalized somehow
13:00:20 <merijn> eikke__: I don't think the hierarchy makes sense at all
13:00:25 <MagneticDuck> merijn: but should folding through a 300,000 character Text with a simple accumulator be THAT slow?
13:00:27 <MagneticDuck> 20 seconds?
13:00:43 <merijn> eikke__: The whole Control/Data distinction is really arbitrary and only exists for hysterical raisins
13:01:07 <merijn> MagneticDuck: You keep unwrapping and rewrapping the Text in that code
13:01:19 <MagneticDuck> I... I do?
13:01:24 <Kaidelong> IE Free^n F == Free F for all F
13:01:34 <burp> MagneticDuck: use (:) to prepend to lists
13:01:43 <MagneticDuck> http://ix.io/e8O <- newest version
13:01:43 <Kaidelong> and for all n
13:01:48 <burp> MagneticDuck: don't do [x] ++ [a,b,c], use x:[a,b,c]
13:02:02 <MagneticDuck> ..
13:02:06 <MagneticDuck> acc is a list
13:02:22 <burp> yea, I know, but T.pack [char] not
13:02:27 <MagneticDuck> oh
13:02:27 <merijn> MagneticDuck: Why are you trying to write this by hand?
13:02:35 <burp> (T.pack [char]):acc and then reverse in the end
13:03:06 <MagneticDuck> you're saying (reverse $ a:(reverse xs)) is faster than (xs ++ [a])?
13:03:23 <MagneticDuck> merijn: okay I'll use a parser ._.
13:04:02 <MagneticDuck> burp: oh, k
13:04:11 <MagneticDuck> you're saying keep it reversed throughout the algorithm
13:04:14 <MagneticDuck> hm
13:04:19 <merijn> MagneticDuck: With Data.Attoparsec.Text this should be easy to implement, simpler to read and more efficient
13:04:24 <MagneticDuck> well I'll use a parser. cya later
13:04:44 <linman32> hi, have error: expected `(IO t0, b0)', actual `IO (EventBox, Image)'
13:04:47 <linman32> here is url for it
13:04:48 <linman32> http://lpaste.net/110357
13:05:14 <merijn> eikke__: Take for example "Data.Attoparsec", there's no real reason to have that Data prefix. Fortunately libraries are starting the obsession with that Data/Control prefix
13:05:30 <MagneticDuck> linman32: that's a type error
13:05:41 <MagneticDuck> ..and you need to look at your types to fix it
13:06:01 <c_wraith> linman32: the problem is that you're treating an IO value as a tuple
13:06:52 <c_wraith> linman32: you need to move the call to fst into the IO action.  The simplest way to do that is changing that to fmap fst $ ...
13:08:23 <linman32> c_wraith: it worked. thanks
13:10:30 <linman32> c_wraith: so fmap is taking a function that takes a0 spits out b0. and returns a function of b0?
13:10:55 <linman32> c_wraith: also takes a function of a0
13:11:14 <c_wraith> linman32: fmap is...  kind of best described by its type signature.  If I specialize it a bit, it looks like  fmap :: (a -> b) -> IO a -> IO b
13:11:53 <c_wraith> linman32: so it turns fst, which has a type like (c, d) -> c into a function with a type like IO (c, d) -> IO c
13:13:47 <merijn> Peaker: I think GHC should get a system like erlang where you could just "link" processes into a supervisor tree, it'd make this cleanup stuff much easier, I think
13:14:23 <eikke__> merijn: there's some support for that in async afaik, and in distributed-process
13:14:40 <Peaker> merijn: does erlang have a notion of "mask"?
13:14:50 <merijn> eikke__: Async is not suited for the stuff me and Peaker are talking about
13:14:59 <merijn> eikke__: I don't know, tbh
13:15:02 <merijn> err
13:15:07 <merijn> s/eikke__/Peaker
13:15:23 <Peaker> Surely if Erlang has an external resource (e.g: a file) something needs to guarantee its closing, even if that closing blocks
13:15:43 <linman32> c_wraith: ok, starting to understand. the 'a' type represents the tuple, and 'b' type represents the tuples first element
13:15:49 <MagneticDuck> is https://hackage.haskell.org/package/attoparsec-0.10.1.1/docs/Data-Attoparsec-Text.html really an index of all the small parsers / combinators that attroparsec offers?
13:15:58 <c_wraith> linman32: yes
13:16:14 <Fuuzetsu> MagneticDuck: Data.Attoparsec.Combinators too
13:16:22 <MagneticDuck> ahk
13:16:29 <MagneticDuck> was wondering where the combinators were x
13:16:32 <MagneticDuck> *x|
13:16:43 <Fuuzetsu> but combining the two modules that's everything you get from attoparsec but you also get everything from Control.Applicative and Control.Monad
13:17:27 <Peaker> It looks like in Erlang you call explicit "close" which cannot interact well with exceptions
13:17:32 <MagneticDuck> ahk
13:17:36 <Peaker> (without bracket, "withFile" or such)
13:17:55 * merijn goes of to read the error handling chapter of Learn You Some Erlang
13:18:23 <merijn> Peaker: Actually
13:18:30 <merijn> Peaker: Does erlang even have async exceptions?
13:18:54 <Peaker> what about sync exceptions?
13:18:56 <merijn> Peaker: they have "try/after"
13:19:04 <merijn> Peaker: They have a finally clause for handlers
13:20:16 <Peaker> merijn: it does seem to have "exit signals" which seem they're async exceptions
13:20:33 <merijn> Peaker: Right, so you have links where you link a process to another process and then if the linked process dies it sends a message to the other guy
13:21:52 <Peaker> merijn: so in Erlang, either it kills your process right away, or you change the mode to make these kills ordinary messages in your mailbox
13:21:55 <merijn> hmm, there appear to be more violent kills too
13:22:15 <merijn> I'm not sure how those interact with the whole "try/after" thing
13:23:16 <merijn> Does base have a library for a channel that only keeps the latest X messages?
13:23:55 <Peaker> merijn: not sure, but there's the "BoundedChan" package
13:24:26 <merijn> BoundedChan only has channels with a fixed size
13:24:35 <merijn> i.e. when it's full writing blocks
13:24:39 <merijn> But that's not what I want
13:24:49 <Peaker> ah
13:25:06 <merijn> Writes should never block, but old messages should be discarded
13:25:38 <merijn> I need a channel to expose events to the user, but using something unbounded means there's a huge memory leak of the user doesn't poll for events often enough
13:28:24 <merijn> Peaker: Speaking of threads and async, I don't suppose you have any experience getting ThreadScope to work on OSX? :)
13:28:42 <hpc> merijn: make it block when full, make it the user's responsibility?
13:29:19 <merijn> hpc: Unacceptable, that means my main networking/message processing loop would block depending on whether the use checks events
13:30:11 <Peaker> merijn: I don't use OSX, too evil :)
13:30:54 <merijn> Peaker: aww, sad times
13:31:07 <Peaker> merijn: so I asked #erlang, and it seems they have a very different model than Haskell's exceptions, so comparison not really applicable
13:31:34 <merijn> oh?
13:31:48 <Peaker> basically a process is "linked" to its resources so when it dies it cleans up those resources
13:32:49 <merijn> Man, I wish haskell had structural subtyping right now :\
13:33:59 <MagneticDuck> attoparsec question: how do I specify a parser that takes as much of the text as it can until taking any more would begin to take a certain word?
13:34:44 <merijn> MagneticDuck: manyTill ?
13:34:49 <Fuuzetsu> MagneticDuck: sepBy?
13:35:19 <Fuuzetsu> …manyTill is probably a better idea
13:35:21 <merijn> and/or skipMany, depending on your use
13:35:35 <MagneticDuck> manyTill is the winner
13:35:37 <MagneticDuck> huh.
13:35:39 <MagneticDuck> cool
13:39:10 <lpaste> merijn pasted “Lack of structural subtyping woes” at http://lpaste.net/110360
13:39:24 <monochrom> w00t lpaste is back
13:39:28 <merijn> I have essentially a GADT along those lines, except that that doesn't typecheck
13:39:46 <merijn> monochrom: It was gone? I think people are just not selecting a channel to paste too
13:39:53 * Fuuzetsu was hit by a deadlink to hpaste the other day ;_;
13:40:10 <merijn> What's my best way to deal with a GADT field that's shared like that?
13:40:28 <merijn> Having a different name per field would suck and in general the duplication of common fields is annoying
13:43:10 <merijn> Anyone?
13:45:02 <Peaker> merijn: isn't using records like that super ugly due to partiality anyway?
13:45:05 <Fuuzetsu> are there plans to allow name overloading resolved through types? Say what Agda does
13:45:23 <monochrom> type-directed name resolution?
13:45:25 <merijn> Peaker: The presence of certain fields will be encoded in the types
13:45:31 <merijn> Peaker: So it won't be partial
13:45:36 <Peaker> merijn: but that's not what record syntax does?
13:45:37 <merijn> Using missing fields will be a type error
13:45:40 <Fuuzetsu> monochrom: I was going to call it that but I thought I was making the name up ;P
13:45:57 <Taneb> merijn, you can still do FooRec {}
13:45:59 <merijn> Peaker: The records aren't exposed directly and my wrappers will enforce totality
13:46:12 <Peaker> merijn: if you have wrappers anyway, may as well just use non-record products?
13:46:35 <merijn> Peaker: I still need to read the internal code of my library :)
13:47:21 <merijn> Taneb: You mean only using FooRec and initialising the unused field to undefined?
13:47:28 <merijn> That seemed rather ugly :\
13:47:52 <Taneb> @let data Foo = Foo {bar :: Int, baz :: Char}
13:47:52 <lambdabot>  .L.hs:170:1:
13:47:52 <lambdabot>      Multiple declarations of ‘Foo’
13:47:52 <lambdabot>      Declared at: .L.hs:157:1
13:47:52 <lambdabot>                   .L.hs:170:1
13:47:54 <monochrom> merijn: you have a perfectly legitimate type definition. is there any problem?
13:47:59 <Taneb> @let data FooTaneb = Foo {bar :: Int, baz :: Char}
13:48:01 <lambdabot>  Defined.
13:48:07 <Taneb> > FooTaneb {}
13:48:08 <lambdabot>  Not in scope: data constructor ‘FooTaneb’
13:48:15 <Taneb> > bar (FooTaneb {})
13:48:16 <lambdabot>  Not in scope: data constructor ‘FooTaneb’
13:48:20 <Taneb> > bar (Foo {})
13:48:22 <lambdabot>  *Exception: <interactive>:3:6-11: Missing field in record construction L.bar
13:49:06 <merijn> monochrom: It's not legitimate
13:49:11 <merijn> monochrom: It's a type error
13:49:24 <monochrom> yikes
13:49:50 <merijn> monochrom: Record accessors can't be shared amongst constructors with different return types
13:49:57 <merijn> Apparently :)
13:50:06 <monochrom> I see. then too bad.
13:51:11 <merijn> I would like to indicate which field is present based on the return type, but I don't see a simple way of enforcing that, sadly :\
13:51:15 <monochrom> yeah, I guess the type of foo as an accessor cannot have any of these types: Test m Int -> m Bool, Test m Bool -> m Bool, Test m a -> m Bool
13:52:04 <merijn> oh
13:52:08 <merijn> typeclass abuse idea!
13:52:19 <merijn> hmm, actually, no I guess that still doesn't help
13:52:33 <merijn> Because I can't make record field presence depend on said typeclass
13:52:43 <merijn> Like I said, I really just want structural subtyping :(
13:53:53 <monochrom> let me ignore any implementation technique and just talk at the specification level whether a specification is logically consistent with the type system or not
13:54:42 <merijn> Actually, maybe I can abuse PatternSynonyms to fake this...
13:54:52 <merijn> Can you put constraints on a patternsynonym?
13:55:56 <merijn> Time to campaign for a record syntax version of patternsynonyms if it doesn't exist yet :)
13:56:08 <merijn> monochrom: \o/
13:56:19 <merijn> You can put constraints on pattern synonyms according to the docs :D
13:56:22 <monochrom> are you saying, you are specifying a function foo such that foo :: forall a. T a -> Stuff, such that foo (xxx :: T Int) is a type error, but foo (yyy :: T Char) is typechecked?
13:58:05 <merijn> monochrom: Basically, I have a type Socket with kind "SocketType -> *" and readSocket is only available on sometypes
13:58:28 <merijn> monochrom: So I plan to have a constraint like "readSocket :: Readable a => Socket a -> Foo"
13:59:04 <merijn> monochrom: So right now I have a record type that has both a readSocket and writeSocket field, but they're not always both available on a Socket
13:59:37 <merijn> monochrom: But I don't want to duplicate all the other metadata 3 times (readable, writable and both)
14:00:35 <merijn> monochrom: Putting such a constraint on the exported readSocket/writeSocket function is easy, but I'd like to (if possible) avoid setting fields to undefined, because I'm not smart enough to trust myself to get that right all the time :)
14:00:56 <merijn> monochrom: So I was hoping to somehow enforce myself to always set the required one
14:01:07 <monochrom> I don't promote setting fields to undefined, don't worry.
14:01:26 <MagneticDuck> ?!?
14:01:32 <merijn> monochrom: Well, I don't think I can avoid it in this case without duplicating a lot of other stuff
14:01:35 <MagneticDuck> I've already written several parsers and I barely had to debug them
14:01:38 <MagneticDuck> what is this magic...
14:01:51 <MagneticDuck> O.o
14:02:01 <monochrom> you have only written well-studied parsers so far.
14:02:04 <merijn> monochrom: But if I can create a patternsynonym with a constraint then I could enforce that the right fields are always set and the right ones undefined :)
14:02:07 <ski> merijn : sounds like you want "indexed record types"
14:02:09 <MagneticDuck> parsec / attoparsec / other parsers 4 life
14:02:28 <merijn> monochrom: I think he's comparing to his earlier hand rolled parser that was using Text and String pattern matching :)
14:02:36 <c_wraith> data families can be indexed record types!
14:03:04 <ski> merijn : hmm .. or perhaps not quite
14:03:10 <merijn> ski, c_wraith: Wouldn't data families be essentially the same as duplicating my record GADT 3 times what I was trying to avoid?
14:03:32 <c_wraith> merijn: yes, but at least you could talk about it in a uniform way
14:03:49 <monochrom> what is indexed record types (specification, not implementation) and how does data family implement it?
14:03:52 <merijn> c_wraith: So? I can already do that, by duplicating a bunch of stuff and making everything else more error prone
14:04:19 <ski> by an "indexed record type", i mean something like
14:04:27 <ski>   record T :: * -> *
14:04:31 <ski>     where
14:04:32 <merijn> really, I think record syntax for pattern synonyms would make this entire thing go away in a trivial nice way
14:04:32 <c_wraith> monochrom: a record where the fields available in it vary with the type parameters
14:04:40 <ski>     foo :: T a -> Bool
14:04:49 <ski>     bar :: T Int -> Char
14:04:57 <ski>     baz :: T Char -> String
14:05:23 <merijn> ski: Is this actual syntax or made up?
14:05:25 <ski> (here `foo',`bar',`baz' are the accessor/selector functions, not the fields themselves)
14:05:29 <ski> merijn : made up
14:05:45 <c_wraith> monochrom: which, to some extent, GADTs already satisfy.  But GADTs are closed and data families are open - so they have different use cases
14:05:58 <ski> the idea is that every value of type `T a' (for any type `a') will have a field accessed by `foo'
14:06:01 <merijn> c_wraith: Right, but I already have a GADT and I *want* closed
14:06:37 <ski> but only values of type `T Int' will have a field accessed by `bar' (with contents of type `Char')
14:06:49 <ski> and only values of type `T Char' will have a field accessed by `baz' (with contents of type `String')
14:06:49 <c_wraith> merijn: yes, I accept that it may not work for you.  I switched to only answering monochrom's question
14:07:36 <merijn> Anyway, I guess I will use a normal PatternSynonym and put a feature request on trac for record style pattern synonyms :)
14:07:39 <ski> the idea is that when constructing a `T Int' value, you have to provide values for all the fields which could possibly be accessed
14:07:56 <ski> hm, i suppose perhaps one could imagine allowing field accessor specifications like
14:08:13 <ski>     quux :: Readable a => T a -> Blah
14:08:16 <merijn> ski: Wouldn't structural subtyping allow essentially the same thing?
14:08:36 <ski> merijn : i don't see it
14:09:08 <monochrom> if you want both T Int and T Double to have the same field, you may like to make up a type class to cover Int and Double.
14:09:20 <ski> however, one potential problem would be : what if you construct a value of type `T X' somewhere, and in a different module provide an instance for `Readable X' ?
14:09:37 <merijn> monochrom: That's trivial using typefamilies + constraintkinds, though
14:09:48 <ski> then someone who uses both modules would expect to be able to use the `quux' accessor in this `T X' record value
14:10:06 <ski> and so when constructing the value, one ought to specify that field
14:10:12 <ski> but how is one to know about that ?
14:10:48 <monochrom> whoever wrote "instance Readable X" is the only person responsible for that problem.
14:11:16 <c_wraith> yeah, that's a prime example of orphan instances being problematic
14:11:23 <monochrom> so hopefully Readable has enough methods for that person to support quux directly or indirectly
14:11:33 <ski> merijn : so, what is someone later provides (perhaps dummy) instances of `Readable a' for all the relevant `a' indices for your GADT ?
14:11:41 <David> which CSV parser would you recommend for parsing of simple CSVs (guaranteed error-free)? I don't need anything fancy - the simpler, the better
14:12:02 <merijn> ski: I don't have a class constraint
14:12:17 <ski> monochrom : the person who constructed the `T X' value didn't know about the existence of the instance
14:12:18 <David> something that turns "a,b,c,d\ne,f,g" into [[a,b,c,d],[e,f,g]]
14:12:24 <ski> merijn : some other kind of constraint, then ?
14:12:27 <merijn> ski: I have a closed type family constraint using ConstraintKinds, so that's a non-issue
14:12:33 <ski> ok
14:13:19 <ski> monochrom : how's the third party supposed to be able to know that combining these two modules could yield problems ?
14:14:26 <c_wraith> I'd be sympathetic to banning orphan instances entirely, except for the fact that it causes a universe's worth of dependency issues
14:14:41 <monochrom> there are two cases.
14:15:06 <monochrom> A. "instance Readable X" is unimplementable. then we have no problem.
14:15:26 <merijn> Right, I'm fairly postivie I can indeed get all this to work using PatternSynonyms
14:15:38 <merijn> The only thing I lose is record syntax, but I can live with that for now
14:15:43 <monochrom> B. "instance Readable X" is implementable. then let us hope that its methods support quux, rather than just a labeller type class.
14:17:10 <merijn> The only thing that now makes me sad is lack of exhaustiveness warnings on closed typefamilies
14:18:35 <ski> monochrom : i don't see how B could magically affect the other module which constructs the value of type `T X'
14:19:19 <ski> at first, one could expect that the code which constructs this value doesn't need to provide the field accessed by `quux'
14:19:20 <ifesdjeen> hi everyone, is it possible to solve that equation, if I have a type:
14:19:30 <ifesdjeen> data Fold a b = Fold :: (acc -> i -> acc) -> acc -> (acc -> done) -> L.Fold i done
14:19:42 <ifesdjeen> is it possible to still write that `stopCondition` function, since Fold doesn't "publish" it's internal `acc`?..
14:19:59 <ifesdjeen> which would have a following signature: stopCondition :: (i -> acc -> Bool) -> L.Fold i done -> L.Fold i done
14:20:02 <ski> but since `Readable X' can be added later, on second thought it would appear that it *should* provide a value for that field anyway
14:20:07 <monochrom> if T X values do not contain enough information, then "instance Readable X" is unimplementable.
14:20:17 * hackagebot irc-ctcp 0.1.2.1 - A CTCP encoding and decoding library for IRC clients.  http://hackage.haskell.org/package/irc-ctcp-0.1.2.1 (barrucadu)
14:20:46 <ski> but the same argument holds for any type in place of `X', and so `quux :: Readable a => T a -> Blah' isn't better than `quux :: T a -> Blah', from the POV of the person constructing the value of type `T X'
14:21:33 <ski> monochrom : the module defining `T' needs to know about the module defining `Readable', but not vice versa
14:22:02 <ski> monochrom : so i don't see how properties about `T' would affect whether `Readable X' is implementation or not
14:22:12 <ski> s/implementation/implementable/
14:22:39 <merijn> What's the simplest way to force GHC 7.8 and later for a package? Just depend on base >= 4.7?
14:23:08 <ski> ifesdjeen : there's several possible choices here (out of which i can guess which one you probably need here)
14:23:42 <ifesdjeen> ski:  could you give a hint, where I should look? I'm not even sure what to google for, so far all my attempts were completely futile
14:24:02 <ski> ifesdjeen : btw, i asssume you really meant something like `data Fold a b = Fold ((acc -> i -> acc) -> acc -> (acc -> done) -> L.Fold i done)' (which still isn't right)
14:24:02 <ifesdjeen> I've only managed to "decompose" it completely
14:24:17 <ski> ifesdjeen : btw, may i ask if you really intended to not use `a' and `b' in the defininens ?
14:24:43 <ifesdjeen> ah, I thought acc and i would be easier to gasp here, didn't mean to confuse anyone
14:25:05 <ifesdjeen> data Fold i done = Fold ((acc -> i -> acc) -> acc -> (acc -> done) -> L.Fold i done)
14:25:09 <ski> ok, ty
14:25:14 <ifesdjeen> sorry, my bad, I copy-pased wrong thing
14:25:51 <ski> ifesdjeen : (a) parameterize, like e.g. `data Fold acc i done = Fold ((acc -> i -> acc) -> acc -> (acc -> done) -> L.Fold i done)' (or with another argument order than `acc',`i',`done', if you prefer)
14:26:13 <ski> ifesdjeen : sometimes, this is what is appropriate -- but i suspect it isn't, in your case
14:26:39 <ifesdjeen> it is, I would just need to re-implement `foldl` library then...
14:26:58 <ifesdjeen> if there's no other choice, i would just do that, but that was kind of exactly what i wanted to avoid :(
14:27:35 <ski> ifesdjeen : (b) in case you mean for the component/argument of the data constructor to be *polymorphic*, use `data Fold i done = Fold (forall acc. (acc -> i -> acc) -> acc -> (acc -> done) -> L.Fold i done)' -- you'll need to enable the `PolymorphicComponents' language extension for this
14:28:28 <ski> ifesdjeen : in this case, when you construct a value of this type, you must provide a *polymorphic* function. and when you extract the component out of a value of this type, you may use it with any type `acc' you like
14:28:44 <ifesdjeen> oh, nice
14:28:54 <ifesdjeen> yes, it is polymorphic, gladly
14:28:56 <Peaker> merijn: does complaining about base's Control.Exception belong in libraries@ or cafe?
14:29:11 <Peaker> is "base" considered just a library?
14:30:04 <ski> ifesdjeen : (c) in case you mean for each value of the given type to have selected *some* (concrete/specific) type for `acc', but possibly different types `acc' for different values, then use `data Fold i done = forall acc. Fold ((acc -> i -> acc) -> acc -> (acc -> done) -> L.Fold i done)' -- you'll need to enable the `ExistentialQuantification' language extension for this
14:30:50 <merijn> Peaker: libraries@
14:31:00 <ifesdjeen> ski: oh my, thank you so much.
14:31:01 <merijn> Peaker: That's where proposals for library changes go
14:31:08 <ski> ifesdjeen : with this last option, you can do some things that feel "Object-Oriented" (such as the proverbial "list of Widgets", where each Widget in the list could be a different kind of thing, but all sharing the common `Widget' interface)
14:31:17 <Peaker> merijn: but is "base" considered part of ghc/Haskell or a library?
14:31:36 <ifesdjeen> ski: amazing, don't know how to thank you!
14:31:47 <ifesdjeen> ski: thank you very very much
14:31:48 <ski> ifesdjeen : beware though that there seems to be a tendency to overuse the last "existentials" option when it's not warranted
14:31:55 <ifesdjeen> :) ok
14:31:59 <ski> see
14:32:02 <ski> @where existential-antipattern
14:32:03 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
14:32:03 <merijn> Peaker: You can cc ghc-devs@
14:32:44 <ifesdjeen> perfect
14:32:51 <ifesdjeen> gotta dig into it all
14:32:54 <ifesdjeen> whole night ahead
14:32:55 <ski> ifesdjeen : in any case, the problem with the original was that `acc' wasn't *bound* anywhere. every variable must be bound
14:33:14 <ifesdjeen> yup, understand it now
14:33:54 <redtricy1le> What's the easiest way to parse a text file into record syntax?  This is a built-in in Text.read?
14:33:58 <ski> ifesdjeen : a potential forth option would then be to bind the type variable `acc' in some surrounding context
14:34:08 <merijn> argh!
14:34:22 <ski> ifesdjeen : e.g., if Haskell had parameterized modules (like SML,OCaml), the type variable could come from a module parameter
14:34:30 <merijn> Data.Type.Bool.If is mono-kinded :<
14:34:47 <ifesdjeen> oh, interesting
14:35:03 <ifesdjeen> not sure I have the context in my case
14:35:06 <ifesdjeen> but may be an option
14:35:17 <ski> ifesdjeen : or, if Haskell allowed defining data types in a `where' or `let', locally to some definition or expression, the type variable could be bound by the expression, or by the type signature corresponding to the definition
14:35:33 <ifesdjeen> true
14:35:38 <ski> ifesdjeen : but i don't think any of these options are currently available in any Haskell implementation :/
14:36:35 <ifesdjeen> yeah...
14:36:37 <ifesdjeen> which is cool
14:36:46 <ifesdjeen> i think I already have enough to learn :)
14:36:51 <ifesdjeen> it'd be much more
14:39:34 <ski> ifesdjeen : in the (b) option, the component is polymorphic, which means it has a universal type, a type of the shape `forall a. ..a..'
14:39:56 <ifesdjeen> yup, that's what i'm trying to implement right now)
14:40:11 <ski> ifesdjeen : in the (c) option, the component conceptually has existential type, a type of the shape `exists a. ..a..' (which is pseudo-syntax, not actual Haskell)
14:40:29 <ifesdjeen> ok
14:40:35 <ski> if we take the first option
14:40:43 <ski>   data Fold acc i done = MkFold ((acc -> i -> acc) -> acc -> (acc -> done) -> L.Fold i done)
14:40:54 <ski> then the data constructor here has type signature
14:41:04 <ski>   MkFold :: ((acc -> i -> acc) -> acc -> (acc -> done) -> L.Fold i done) -> Fold acc i done
14:41:07 <ski> or, to be explicit
14:41:15 <ski>   MkFold :: forall acc i done. ((acc -> i -> acc) -> acc -> (acc -> done) -> L.Fold i done) -> Fold acc i done
14:41:39 <ski> so, the constructor `MkFold' is polymorphic (the user of it may choose the particular types to use in place of `acc',`i' and `done')
14:41:48 <ifesdjeen> yup, that's exactly how it's done
14:41:51 <ski> now, considering the second option
14:41:54 <ifesdjeen> data Fold a b = forall x . Fold (x -> a -> x) x (x -> b)
14:42:04 <ifesdjeen> ah no
14:42:08 <ifesdjeen> wait it's only x :)
14:42:09 <ifesdjeen> stupid me
14:42:13 <ski>   data Fold i done = MkFold (forall acc. (acc -> i -> acc) -> acc -> (acc -> done) -> L.Fold i done)
14:42:23 <ski> the type signature for the data constructor now is
14:42:35 <ski>   MkFold :: (forall acc. (acc -> i -> acc) -> acc -> (acc -> done) -> L.Fold i done) -> Fold i done
14:42:49 <ski> so, `acc' is here already bound, and it's bound *only* in the argument type
14:42:58 <ski> and, just as before, this is short for
14:43:03 <ifesdjeen> ok
14:43:06 <ski>   MkFold :: forall i done. (forall acc. (acc -> i -> acc) -> acc -> (acc -> done) -> L.Fold i done) -> Fold i done
14:43:17 <merijn> Quick, everyone +1 my proposal on libraries@ ;)
14:43:19 <ski> so `i' and `done' are bound at the "toplevel" of the type
14:43:35 <ifesdjeen> i see
14:43:42 <ski> now, the *user* of `MkFold' can pick any particular types `i' and `done' they wish
14:44:18 <ski> but they have to provide an *argument* to the constructor that is generic/polymorphic in `acc', so that whoever later uses that component can get to pick what actual particular type to use for `acc'
14:44:40 <ski> finally, the last of the three options above
14:45:05 <ski>   data Fold i done = forall acc. MkFold ((acc -> i -> acc) -> acc -> (acc -> done) -> L.Fold i done)
14:45:27 <ifesdjeen> nice
14:45:40 <ski> the `forall acc.' part here, in *front* of the data constructor name, means that (as in the first case), `MkFront' is *polymorphic* in `acc'
14:46:11 <ski> but, since `acc' isn't here a parameter of `Fold' (to the left of `='), we have to *somewhere* annotate where`acc' is to be bound
14:46:18 <ski> so, we here get
14:46:21 <ifesdjeen> ski: I'm afraid I still do not completely understand polymorphic types. I'll read up on them
14:46:50 <ifesdjeen> i mean - I follow everything you say, I just think I'm missing some context :(
14:46:54 <ski> ifesdjeen : i haven't talked about polymorphic types at all here :) .. *values* can be polymorphic
14:46:59 <ifesdjeen> ah
14:47:01 <ski> @type length
14:47:02 <lambdabot> [a] -> Int
14:47:05 <ski> @type Nothing
14:47:06 <lambdabot> Maybe a
14:47:07 <ifesdjeen> i mean - polymorphic components
14:47:18 <ifesdjeen> bad wording
14:47:19 <ski> if we specify a type signature like
14:47:23 <ski>   length :: [a] -> Int
14:47:52 <ski> then (in *most* cases), all unbound type variables are to be treated as bound by `forall' at the "toplevel" of the type in the type signature
14:47:56 <ski> so the above means
14:48:02 <ski>   length :: forall a. [a] -> Int
14:48:39 <ski> and this just means that, for whichever particular type we choose for `a', `length' *can* act as if it had type `[a] -> Int', for *that* choice of `a'
14:48:55 <ski> so, `length's *generic*/*polymorhic* in `a'
14:49:01 <ifesdjeen> aahhhh
14:49:02 <ifesdjeen> ok
14:49:06 <ifesdjeen> yes, udnerstand
14:49:28 <ski> and "polymorphic components" just means that a component/argument of a data constructor is *itself* (expected to be) polymorphic
14:49:40 <ski> as opposed to the data constructor being polymorphic
14:50:10 <ski> when you *use* a polymorphic data constructor, you may choose the actual types
14:50:27 <ifesdjeen> yup, understand that, too
14:51:00 <ski> when you use a data constructor with a polymorphic component/argument, you must provide an argument that is actually polymorphic, so that whoever depacks the value (by pattern-matching) can use whatever type for the type variable that they want to
14:51:15 <ski> ok, going back to the last (c) option above
14:51:24 <ski>   data Fold i done = forall acc. MkFold ((acc -> i -> acc) -> acc -> (acc -> done) -> L.Fold i done)
14:51:30 <ski> here, we have
14:51:31 <ski>   MkFold :: ((acc -> i -> acc) -> acc -> (acc -> done) -> L.Fold i done)
14:51:49 <ski> and this is supposed to hold for *all* types `acc', so we really have
14:51:53 <ski>   MkFold :: forall acc. ((acc -> i -> acc) -> acc -> (acc -> done) -> L.Fold i done)
14:52:11 <ifesdjeen> ok
14:52:16 <ski> also, just as usual, this is also supposed to work for *all* types `i' and `done', so we *really* have
14:52:22 <ski>   MkFold :: forall i done acc. ((acc -> i -> acc) -> acc -> (acc -> done) -> L.Fold i done)
14:52:48 <ifesdjeen> oh, nice
14:52:54 <ski> now, the *only* difference between this, and the (a) case, is that `acc' is no longer a parameter of the `L.Fold i done' at the end !
14:53:07 <ifesdjeen> yup
14:53:11 <ski> now, a (very) short detour through logic
14:53:33 <ifesdjeen> :)
14:53:44 <ski> in logic, `forall a. (..a.. -> ...)', where the latter `...' doesn't mention `a', is equivalent to `(exists a. ..a..) -> ...
14:54:18 <ifesdjeen> that makes sense
14:54:55 <ski> e.g. `forall x. (I_have_eaten x -> I_am_satisfied)' is equivalent to `(exists x. I_have_eaten x) -> I_am_satisfied'
14:55:15 <ifesdjeen> :D
14:55:23 <merijn> ugh
14:55:37 <merijn> Apparently you can't use record syntax in synonyms at all
14:55:41 <ifesdjeen> :D
14:55:52 <ski> in the first case, the claim is that if you first give me a thing `x', then if you demonstrate to me that `I_have_eaten x' is true, then i can demonstrate that `I_am_satisfied' is true
14:56:30 <ski> in the latter case, the claim is that if you give be *both* (i) a thing `x'; and (ii) provide a demonstration that `I_have_eaten x' is true; then i can demonstrate that `I_am_satisfied' is true
14:56:53 <ifesdjeen> true. Yes, now it is more or less obvious for me
14:56:53 <ski> the only difference is whether the thing `x' and the demonstration of `I_have_eaten x' is given one at a time, or both together
14:57:00 <ifesdjeen> yes
14:57:05 <ski> this is very similar to the difference between
14:57:11 <ski>   curriedFoo :: X -> Y -> Z
14:57:11 <ski> and
14:57:18 <ski>   uncurriedFoo :: (X,Y) -> Z
14:57:22 <ski> ok
14:57:32 <ski> so, let's look again at
14:57:37 <ski>   MkFold :: forall i done acc. ((acc -> i -> acc) -> acc -> (acc -> done) -> L.Fold i done)
14:57:55 <ski> since `acc' isn't used in the "result type" part, we can, logically speaking, reformulate this as
14:58:10 <ski>   MkFold :: forall i done. (exists acc. (acc -> i -> acc) -> acc -> (acc -> done) -> L.Fold i done)
14:58:22 <ski> and, let's skip again the initial `forall', to reduce noise somewhat
14:58:26 <ski>   MkFold :: (exists acc. (acc -> i -> acc) -> acc -> (acc -> done) -> L.Fold i done)
14:58:45 <ski> er, actually i mangled up brackets :/
14:58:49 <ski> sorry, i should have said
14:58:52 <ifesdjeen> i understand what you mean
14:58:57 <ski>   MkFold :: forall i done. (exists acc. (acc -> i -> acc) -> acc -> (acc -> done)) -> L.Fold i done
14:59:00 <ski> and
14:59:04 <ski>   MkFold :: (exists acc. (acc -> i -> acc) -> acc -> (acc -> done)) -> L.Fold i done
14:59:08 <ski> ok
14:59:45 <ski> so, in this third option, it's enough that there *exists* *some* type `acc', where the argument has type `(acc -> i -> acc) -> acc -> (acc -> done)', for us to be able to apply the data constructor
15:00:11 <ifesdjeen> yup, I understand
15:00:18 <ski> also, when depacking (with pattern-matching), we can't be sure of *which* type `acc' was used, so we have to be prepared for *any* possible type `acc'
15:00:31 <ski> in short, the depacker of such a value has to be *polymorphic* in `acc' !
15:00:35 <ifesdjeen> it all turned simpler (and more complex) than i thought at same time
15:00:50 <ifesdjeen> true
15:01:00 <ski> *because* `acc' doesn't occur in the result type of the data constructor, the data constructor ends up *hiding* the type `acc'
15:01:16 <ski> this is a kind of *information hiding*
15:01:44 <Fuuzetsu> does anyone if johnw is at ICFP? He seems missing from IRC and that's the only reason I can think of
15:01:45 <ski> as regards to values of type `forall a. ..a..' and values of type `exists a. ..a..', the roles are swapped
15:01:55 * Fuuzetsu was hoping he could have a look at something
15:02:12 <ski> with the first, *producers* have to be prepared for any type `a', while *consumers* get to pick/choose the actual `a'
15:02:28 <ifesdjeen> yup
15:02:38 <ski> with the second, *consumers* have to be prepared for any type `a', while *producers* get to pick/choose the actual `a'
15:02:49 <ski> so these two concepts are *dual* to each other
15:02:51 <ski> which is nice :)
15:03:04 <ifesdjeen> I assume that was the original intention: to hide information, at the first place, although, whenever one needs to get inside, that problem arises
15:03:22 <ski> as a perhaps somewhat more useful example of an existential, consider
15:03:23 <ifesdjeen> yes, very powerful concept
15:04:21 <ski>   data QueueOps a = forall q. QO ({- empty :: -} q) ({- enqueue :: -} a -> q -> q) ({- dequeue :: -} q -> Maybe (q,a))
15:04:36 <ifesdjeen> oh
15:04:56 <ski> the idea being that a particular value of type `QueueOps a' is *one* particular implementation of a queue
15:04:56 <ifesdjeen> interesting
15:05:12 <ski> two different values would be two (possibly) different implementations
15:05:29 <ifesdjeen> huh, true
15:05:39 <ifesdjeen> did you take that example from some particular lib?
15:05:43 <ifesdjeen> or just from your head?
15:05:46 <ski> each value gets to pick its own internal "state" type `q', that is used to represent the current private information needed to keep track of which queue element we're talking about
15:05:50 <ski> from head
15:06:15 <ski> note how this isn't quite like in Object-Orientation
15:06:27 <ski> in fact, this is closer to the idea of Abstract Data Types
15:06:40 <ski> here `q' would correspond to the abstract data type
15:07:06 <ski> and the type `QueueOps a' would correspond to the signature of a module that provides an implementation of queues, for the specific type `a'
15:07:31 <ski> ifesdjeen : now, we could make this more OOy, if we liked, by changing the above into
15:07:38 <friden> i have a question about HXT, im trying to acces a XText field, but i cant get it to work
15:07:57 <ski>   data Queue a = forall q. Q ({- queueState :: -} q) ({- enqueue :: -} a -> q -> q) ({- dequeue :: -} q -> Maybe (q,a))
15:08:03 <ifesdjeen> hm
15:08:14 <ski> ifesdjeen : note how in this case i actually only changed the naming and the first comment :)
15:08:36 <friden> if i have: NTree (XTag "div" [NTree (XAttr "class") [NTree (XText "foo") bar]]
15:08:48 <ifesdjeen> was actually trying to match it ski :)
15:08:52 <ifesdjeen> now i understand,  yes
15:08:53 <ski> but, the intension now is to *bundle* each queue *value* with all the relevant queue operations
15:09:19 <friden> how do i access bar? i can use hasName "div" >>> getAttrValue "class" to get to the last step, but i can go no further :S
15:09:29 <ski> so, in the OO-style, we'd depack the queue state, and the operations, perform the operation we want, and then *repack* the resulting new state with the operations
15:09:54 <ulidtko> in Maybe monad, is there some more concise way to say `if condition then return (result) else Nothing` ?
15:10:12 <ski> ifesdjeen : while, in the ADT approach, we depack the `QueueOps a' "package" *once* at the start, and then pass around values of type `q' "nakedly", without repacking every time
15:10:21 <friden> isText returns any text right? i want to match it against an actual string, "foo"
15:10:55 <ifesdjeen> ski: hmmm... not sure I understand by now...
15:11:09 <ifesdjeen> ski: you mean because we don't have type bounds, there's no need to depack?
15:11:20 <ifesdjeen> i mean because things are bound to the context already
15:12:25 <ski> ifesdjeen : ADT and OO here are two different programming approaches. both are related to existentials, but in different ways. it just so happened here that the actual data type definition i wrote for them became the same (though the *intension* is different)
15:12:52 <ski> ifesdjeen : in the first ADT approach, we could write stuff like
15:13:11 <ski>   frob :: QueueOps Int -> ...
15:13:31 <ski>   frob (QO empty enqueue dequeue) ... = let
15:13:43 <ski>     q0 = enqueue (...) empty
15:13:49 <ski>     q1 = enqueue (...) q0
15:14:10 <ski>     in case dequeue q1 of
15:14:17 <ski>          Nothing -> ...
15:14:30 <ski>          Just (q2,n) -> ...
15:15:21 <ski> ifesdjeen : so, `q0',`q1',`q2',... here all have type `q' (which is the "hidden" type, which `frob' knows nothing about, since the caller of `frob' will choose it, and therefore the body of `frob' is effectively polymorphic in `q')
15:16:06 <ifesdjeen> ok, I understand
15:16:12 <ski> in the second, OO, approach, we'd first define wrappers for the operations (the "methods"/"member functions") :
15:16:26 <ski>   callEnqueue :: a -> Queue a -> Queue a
15:17:09 <ski>   callEnqueue a (Q theQueueState enqueue deque) = Q (enqueue a theQueueState) enqueue dequeue
15:17:19 <ski> and similarly for `dequeue'
15:17:47 <ski> and then we'd pass around values of type `Queue a', calling `callEnqueue' and `callDequeue' on them
15:17:50 <ski> we'd also define a constant
15:18:44 <ski>   makeEmptyFooQueue :: InitialSize -> Queue Int
15:19:21 <ifesdjeen> I see your point
15:19:22 <ski>   makeEmptyFooQueue initialSize = Q (emptyFooQueue initialSize) enqueueFoo dequeueFoo
15:19:56 <ifesdjeen> that approach looks a bit more intuitive for me.. probably because i've at least seen it several times aroudn
15:20:01 <ski> where a "FooQueue" is a particular implementation of a `Queue Int', that happens (for some reason) to want an extra argument of type `InitialSize' for the "constructor" (in the OO sense)
15:20:42 <ski> and `emptyFooQueue',`enqueueFoo',`dequeueFoo' are the actual particular implementations of the operations for "Foo" queues
15:20:47 <zygentoma> why can I write "data Behaelter = UArray Int Int"
15:20:56 <zygentoma> but not
15:20:58 <zygentoma> data Behaelter = UArray Int Int
15:20:59 <zygentoma> data BehaelterMax = UArray Int Int
15:21:14 <ski> zygentoma : data constructor names live in a different namespace than type constructor names
15:21:15 <mauke> because that redefines UArray
15:21:24 <mauke> you can't write x = 1; x = 1 either
15:21:30 <ski> zygentoma : you can't reuse the same data constructor name twice, in the same module
15:21:43 <zygentoma> but I don't define UArray at all, or do I?
15:21:47 <mauke> you do
15:21:59 <ifesdjeen> ski: just wanted to thank you once again. Very kind of you to help me in such a way.
15:22:01 <zygentoma> I thought I defined Behaelter
15:22:03 <ski> ifesdjeen : anyway, consider this last example, for handling sets of `Int's
15:22:06 <mauke> you're defining both
15:22:07 <zygentoma> and BehaelterMax
15:22:20 <mauke> Behaelter is the type; UArray is its data constructor
15:22:25 <zygentoma> Aaahh
15:22:29 <zygentoma> I see
15:22:44 <zygentoma> data Behaelter = Behaelter (UArray Int Int)
15:22:54 <zygentoma> this is what I wanted to do, right?
15:23:06 <ski>   data IntSet = forall s. IS ({- empty :: -} s) ({- singleton :: -} Int -> s) ({- union :: -} s -> s -> s) ({- elem :: -} a -> s -> Bool)
15:23:34 <mauke> zygentoma: maybe, or maybe you wanted a newtype, or just type
15:23:42 <ski> well, let's actually generalize it to any kind of element
15:23:54 <ski>   data Set a = forall s. S ({- empty :: -} s) ({- singleton :: -} a -> s) ({- union :: -} s -> s -> s) ({- elem :: -} a -> s -> Bool)
15:23:59 <ski> we could have
15:24:07 <ifesdjeen> Num s ?
15:24:11 <ifesdjeen> or it doesnt' matter
15:24:13 <zygentoma> mauke: well, newtype gives me the same problem, let me check type
15:24:20 <ski>   someImplementationOfSet :: Ord a => Set a
15:24:42 <ski> ifesdjeen : hm, for consitency's sake, i should say s/Set/SetOps/, to emphasize my point
15:24:51 <ifesdjeen> ok
15:25:02 <zygentoma> mauke: uhm, ya, maybe I wanted type …
15:25:17 <ski> (a value of type `SetOps a' is *not* a particular set (in some particular implementation), it's a particular *implementation* of sets, which we can *use* to build actual set values)
15:25:22 <ski> anyway ..
15:25:45 <halvorg> How do I get ghci to use a sandbox?
15:25:50 <halvorg> is it possible?
15:26:03 <ski> ifesdjeen : now, this only allows using the *standard* ordering on `a'
15:26:12 <ski> let's say we want to be able to use *any* ordering
15:26:13 <ski> so
15:26:24 <barrucadu> halvorg: If you run `cabal repl` in a directory with a sandbox, it'll use that.
15:26:25 <ski>   someImplementationOfSet :: (a -> a -> Ordering a) -> SetOps a
15:26:34 <ski> ifesdjeen : so, we pass in the `compare' operation that we'd like to use
15:27:15 <ski> ifesdjeen : now, using this "ADT" version, note that in the `union' operation, we can now e.g. use the fact that we know that *both* arguments of type `q' (which may be sorted lists or ordered search trees, e.g.) will have been constructed using the *same* ordering on `a'
15:27:24 <halvorg> barrucadu: do you know how to integrate that with emacs haskell mode?
15:27:26 <ski> ifesdjeen : otoh, if we instead consider the "OO" approach :
15:27:37 <ski> data Set a = forall s. S ({- setState :: -} s) ({- singleton :: -} a -> s) ({- union :: -} s -> s -> s) ({- elem :: -} a -> s -> Bool)
15:28:04 <Fuuzetsu> for some category C and (A ∈ C) we have an underlying functor on a slice category (U : C/A -> C) which forgets the indexing (our domains and co-domains are now the same as before indexing), but it doesn't somehow bring back the objects and arrows which were ‘cut-off’ when making the slice category, does it? It seems impossible but maybe I'm missing something.
15:28:14 <ifesdjeen> which is pretty much same, but signatures
15:28:15 <barrucadu> halvorg: No, sorry
15:28:20 <ifesdjeen> err comments
15:28:24 <halvorg> barrucadu: k, thanks.
15:28:25 <ski> ifesdjeen : and accordinly package up the operations `singleton',`union',`elem', then for the `union' case, given two `Set a's we have *no* guarantee that they even use the *same* internal `q' type !
15:28:34 <ski> iow
15:28:40 <halvorg> Is it possible to get a cabal repl/ghci to autorecompile on file changes?
15:28:46 <ski>   callUnion :: Set a -> Set a -> Set a
15:28:52 <ski> has problems
15:29:02 <ifesdjeen> hm, interesting
15:29:16 <ski> ifesdjeen : in the OO world, this problem is known as the "binary method" problem
15:29:26 <ski> the ADT version avoids it
15:30:00 <ski> (in a class-based OO system, there are also ways to avoid it by making more accurate types. OCaml does this, but e.g. Java or Eiffel doesn't)
15:30:40 <ski> (no, not `Num s')
15:31:00 <ifesdjeen> nm, I understood by now
15:31:07 <ifesdjeen> wrt to num
15:31:09 <ski> ifesdjeen : anyway, for some more information on OO vs. ADT, please see the paper "On Understanding Data Abstraction, Revisited" by William R. Cook in 2009-10 at <http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf> (also TaPL has a chapter or two that's relevant)
15:31:14 <ski> @where TaPL
15:31:14 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
15:31:28 <ifesdjeen> ok, gotta read that one, too
15:31:48 <ifesdjeen> very useful
15:33:17 <ski> ifesdjeen : that paper is sortof a follow-up to the (good !) paper "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf>, which you may perhaps also want to check out
15:33:43 <ifesdjeen> will do, too
15:34:22 <ifesdjeen> ski: you're my hero for today. Thanks a ton, once again. Gotta grab some sleep until before dawn in our places. Thank you!
15:35:09 <ski> the TaPL ("Types and Programming Languages", by Benjamin C. Pierce in 2002) one is a book, which i recommend if you're interested in the topic of type systems
15:35:34 <ski> ifesdjeen : ok, good night and dream nice or interesting dreams
15:36:17 <ifesdjeen> :) heh, after such a day will certainly do.
15:40:25 * hackagebot redis-resp 0.2 - REdis Serialization Protocol (RESP) implementation.  http://hackage.haskell.org/package/redis-resp-0.2 (ToralfWittner)
15:40:39 <halvorg> Is there a find that works on maps?
15:40:51 <halvorg> I only see findWithDefault, which isn't what I want.
15:41:09 <darveter> > :t foldl
15:41:10 <lambdabot>  <hint>:1:1: parse error on input ‘:’
15:41:14 <ski> @type foldl
15:41:16 <lambdabot> (b -> a -> b) -> b -> [a] -> b
15:41:24 <halvorg> well ok
15:41:25 <darveter> thanks!
15:42:27 <halvorg> does foldl short circuit though?
15:42:41 <halvorg> (if used as a find)
15:42:44 <hpc> halvorg: filter and then enumerate the keys/values?
15:42:47 <Fuuzetsu> :t fmap
15:42:47 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:43:12 <halvorg> hpc: yep I'll do that
15:43:23 <darveter> @type (\xs-> let g=g; h=g==True in foldl g ([]) xs)
15:43:24 <lambdabot> [a] -> [t]
15:43:26 <halvorg> seems a bit weird for me to filter when I want a 1 or 0 reply though
15:43:37 <darveter> shouldn't that be type error?
15:44:09 <merijn> darveter: Why?
15:44:32 <Fuuzetsu> I'm struggling to reconcile categorical functors with Functor, any resources?
15:44:34 <ski> @type M.filterWithKey
15:44:35 <lambdabot> (k -> a -> Bool) -> M.Map k a -> M.Map k a
15:44:38 <ski> @type \p -> M.toList . M.filterWithKey p
15:44:39 <lambdabot> (k -> a -> Bool) -> M.Map k a -> [(k, a)]
15:44:42 <ski> @type \p -> listToMaybe . M.toList . M.filterWithKey p
15:44:43 <lambdabot> (k -> a -> Bool) -> M.Map k a -> Maybe (k, a)
15:44:46 <merijn> Fuuzetsu: Functor is an endofunctor from hask to hask
15:44:55 <ski> halvorg : anything like that ^ ?
15:45:05 <athan> Is there a language extension that automatically prepends `toNat` from Data.Nat to all (contextual) use cases of literal numbers like 1,2,3,4? (for instance, all occasions where the typechecker actually expects a Nat from an explicit type signature)
15:45:10 <darveter> because foldl should define g's type as function, and in h it is compared with a Boolean.
15:45:22 <Fuuzetsu> merijn: and arrows in Hask are just functions?
15:45:28 <merijn> Fuuzetsu: Fuuzetsu Right
15:45:38 <darveter> merijn: because foldl should define g's type as function, and in h it is compared with a Boolean.
15:45:42 <merijn> Fuuzetsu: And objects in Hask are type
15:45:45 <ski> Fuuzetsu : yes
15:45:48 <Fuuzetsu> how boring
15:45:51 <ski> objects are concrete types
15:45:53 <merijn> Fuuzetsu: :)
15:45:55 <darveter> @type (\xs-> let g=g; h=g==True in foldl g [] xs)
15:45:56 <lambdabot> [a] -> [t]
15:46:00 <athan> unless `toNat` does something crazy for negative integrals, like maintain the same magnitude o.O
15:46:12 <merijn> ski: Mandatory complaint about concrete types being ill-defined term
15:46:19 <prophile> which Data.Nat
15:46:26 <merijn> ski: Did you mean monomorphic, * kinded or both?
15:46:27 <halvorg> ski: that would be "fused together" by ghc?
15:46:47 <ski> halvorg : maybe
15:46:48 <halvorg> I mean, performance isn't exactly critical here, but I'm curious.
15:46:49 <Fuuzetsu> ski: how do we treat things of kind k → ★?
15:47:02 <ski> merijn : `*'-kinded
15:47:37 <merijn> darveter: the problem is that your 'g' is basically 'undefined'
15:47:49 <halvorg> I'll just to find f $ M.tolist theMap
15:47:52 <darveter> yes, I know
15:47:55 <ski> athan : hm, couldn't you define `fromInteger' for `Nat' to call that ?
15:47:57 <halvorg> do*
15:48:01 <athan> :( toNat fails at runtime anyway :(
15:48:02 <darveter> but it is used in two places
15:48:14 <darveter> where same type can not go
15:48:15 <athan> ski: Good idea!
15:48:25 <mauke> > (id 0, id "hi")
15:48:26 <ski> athan : or possibly, this is already done for you :)
15:48:26 <lambdabot>  (0,"hi")
15:48:33 <mauke> magic
15:48:39 <athan> ski: :D
15:48:47 * ski hasn't checked
15:48:54 <merijn> ski: I'm trying to ban the use of "concrete type", because it always leads to confusion since people seem to assign it an arbitrary meaning of their own, which tends to be either monomorphic, * kinded or both and no one ever knows which the speaker means
15:49:00 <darveter> merijn: yes, I know, but it is used in two places where same type can not go
15:49:04 <athan> I'm looking :)
15:49:16 <ski> Fuuzetsu : i'm not sure what you're asking about. treat them for what purpose ?
15:49:31 <merijn> darveter: See mauke's example of id
15:49:43 <darveter> merijn: ah!
15:49:48 <Fuuzetsu> well you say objects are *-kinded and arrows are functions, so what are things of higher kind?
15:49:49 <merijn> :t (undefined 'c', undefined) :: (Bool, Char)
15:49:50 <lambdabot> (Bool, Char)
15:49:53 <ski> merijn : hm, i tend to always use the `*' one. i can't recall encountering the monomorphic one before
15:49:59 <darveter> merijn: ah! thanks. it's polymorphic.
15:50:15 <merijn> ski: Newbies reading LYAH (which also uses the term) seem to use if for monomorphic too
15:50:26 <ski> merijn : though, if you disallow impredicate stuff and higher-rank stuff, they would be monomorphic anyway
15:50:45 <ski> s/impredicate/impredicative/
15:50:57 * ski hasn't read LYAH
15:51:24 <mietek> Any make wizards here?
15:51:36 <mietek> Can't seem to figure out what's the right Freenode channel to ask questions about make
15:52:33 <merijn> ski: Why would * kinded types be monomorphic if you disallow impredicative/higher rank?
15:52:35 <dfeuer> mietek, maybe you can try in #gnu
15:52:42 <mauke> ##toolchain?
15:52:46 <mietek> mauke: aha!
15:52:49 <mietek> dfeuer: thanks
15:52:51 <merijn> ski: Trivial example: Nothing
15:52:58 <sipa> mietek: ##make ?
15:53:02 <dfeuer> No guarantee!
15:53:36 <merijn> :k Maybe a
15:53:37 <lambdabot> Not in scope: type variable ‘a’
15:53:42 <merijn> oh, bah
15:53:47 <dfeuer> :k Maybe
15:53:47 <lambdabot> * -> *
15:53:51 <merijn> :k forall a . Maybe a
15:53:52 <lambdabot> *
15:54:18 <merijn> ski: Unless you're qualifying "Nothing" style polymorphism as higher-rank too?
15:54:20 <ski> merijn : because without higher-rank, you can't express `(forall a. ..a..) -> ...', and `... -> (forall a. ..a..)' is equivalent to `forall a. ... -> ...', so you could treat that as a class of morphisms with no lack of expressivity
15:54:50 <ski> merijn : so your morphisms (interpreted as Haskell functions) would effectively only map between monomorphic stuff
15:56:05 <mietek> sipa: thanks, I didn't try ##..
15:56:05 <ski> (so the global element `\() -> Nothing' would then be a class of morphisms, from `()' to `Maybe a', one for each (monomorphic, since we're predicative) choice of `a')
15:56:21 * ski . o O ( ##mauke )
15:58:03 <halvorg> is there an elegant way to fmap something in do notation?
15:58:18 <halvorg> I have a Maybe A and a function A -> IO ()
15:58:36 <halvorg> I want to do fmap function maybeA
15:58:54 <merijn> halvorg: You'll need to pattern match
15:59:14 <halvorg> _ <- return $ fmap func maybeA isn't very elegant...
15:59:15 <merijn> halvorg: fmap will just give you "Maybe (IO ())" which is not what you want :)
15:59:34 <halvorg> yeah
15:59:40 <jedai> :t traverse
15:59:41 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
16:00:02 <merijn> :t traverse_ -- then
16:00:03 <lambdabot>     Not in scope: ‘traverse_’
16:00:03 <lambdabot>     Perhaps you meant one of these:
16:00:03 <lambdabot>       ‘F.traverse_’ (imported from Data.Foldable),
16:00:06 <halvorg> oh, that looks nice
16:00:09 <merijn> :t F.traverse_ -- then
16:00:10 <lambdabot> (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
16:00:16 <halvorg> thanks
16:00:28 * hackagebot redis-io 0.2 - Yet another redis client.  http://hackage.haskell.org/package/redis-io-0.2 (ToralfWittner)
16:08:12 <lpvb> can someone give me some examples where arrows are more useful than monads and applicatives besides FRP?
16:09:31 <brycelane> if I have more than a Main module in a executable, how do I get it to show up in the REPL?
16:11:12 <merijn> lpvb: The usefulness of arrows are frequently questioned :)
16:11:24 <merijn> lpvb: The Arrow papers have some examples, such as parser
16:11:52 <merijn> brycelane: Load the extra modules too? You can pass multiple .hs files to ghci
16:12:20 <brycelane> I was hoping to do something like `cabal repl "make it work"`
16:12:57 <athan> Is there a way to calculate numbers at compile time, and check their value at compile time, without having to use a dependently typed language?
16:13:33 <tac_> athan: depends what you mean by "check their value"
16:14:05 <merijn> brycelane: If you have a cabal project than cabal repl should work for loading them, but that won't bring their things in scope
16:14:14 <merijn> athan: Sure, use TH
16:14:16 <athan> tac_: Just a simple proposition of >, <, etc. And no values involving monadic code
16:14:18 <athan> !!
16:14:22 <athan> merijn: Ahh
16:14:39 <brycelane> merijn, I know I need to :m Name or import Name, but that doesn't appear to work.
16:14:58 <merijn> brycelane: Oh? Does your cabal file properly list all your modules?
16:15:11 <merijn> brycelane: It should print all modules it's loading
16:15:24 <brycelane> merijn, it should be in the other-modules section, right? And it doesn't print it, I checked.
16:17:55 <merijn> brycelane: Try "cabal repl <executable name>"?
16:18:41 <brycelane> merijn, yes, that only loads the Main module
16:19:23 <brycelane> I'm not explicitly exporting from the missing module, could that be it?
16:22:08 <lpvb> merijn: just parsers? seems like a big undertaking to study arrows for only frp and parsers :(
16:26:16 <merijn> lpvb: I dunno, I forgot the rest of the paper
16:26:38 <merijn> brycelane: You mean the things from the other module are not in scope?
16:27:35 <Fuuzetsu> lpvb: pretty sure it usually goes ‘study thing X → oh hey I can do all this cool stuff with X’ rather than ‘I won't study X until I know what cool stuff I can do with it’
16:28:18 <halvorg> Is it possible to do a liftIO in a STM transaction somehow?
16:28:30 <Fuuzetsu> :t liftIO
16:28:31 <lambdabot> MonadIO m => IO a -> m a
16:28:39 <brycelane> merijn: I mean it doesn't say the module was loaded, and I cannot import it.
16:28:41 <halvorg> oh I just probably need to import it
16:28:43 <halvorg> :D thanks
16:28:44 <lpvb> Fuuzetsu: I read the documentation and hasell.org/arrows , now I'm just looking for use cases
16:28:57 <simpson> halvorg: What's the goal?
16:29:30 <halvorg> I need a timestamp for saving something, and taking the timestamp before the lock is acquired could yield weird results.
16:29:36 <halvorg> if it takes a long time to get the lock
16:29:39 <lpvb> I see that you can split inputs and have many parallel computations but idk why that would be useful
16:29:41 <Fuuzetsu> halvorg: I'm going to say no
16:29:43 <trap_exit> gentlemen of the educated languages, how do I learn how to use FRP ?
16:30:01 <halvorg> Fuuzetsu: meh, i see what u mean.
16:30:41 <merijn> trap_exit: I thought Conal's papers on FRP were pretty good
16:30:58 <trap_exit> he wrote a bunch
16:30:58 <trap_exit> that are slightly different
16:31:01 <trap_exit> is ther ea definitive paper?
16:31:10 <merijn> trap_exit: I'd say this one: http://conal.net/papers/push-pull-frp/
16:31:23 <merijn> trap_exit: Althought the FRAN is also good
16:31:25 <simpson> :t unsafeIOToSTM -- halvorg
16:31:26 <lambdabot> Not in scope: ‘unsafeIOToSTM’
16:31:29 <simpson> halvorg: http://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-Conc-Sync.html#v:unsafeIOToSTM
16:31:34 <merijn> This is sorta of an extension/clarification to the FRAN one
16:31:39 <simpson> Read carefully; it has caveats.
16:31:51 <Fuuzetsu> halvorg: you'd basically be trying to lift IO into something that doesn't do IO until it runs (atomically), you can't roll back and retry effects
16:32:32 <halvorg> yeah I see
16:33:04 <merijn> halvorg: Why not "do { atomically $ takeLock; takeTimestamp }"?
16:33:39 <zygentoma> how do find out about the priority of operators?
16:33:51 <merijn> zygentoma: :i in ghci
16:33:53 <halvorg> merijn: I'm not sure I follow.
16:34:04 <zygentoma> thx merijn
16:34:06 <halvorg> I have a Map key -> (timestamp, somthing..)
16:34:18 <merijn> zygentoma: If it doesn't print any fixity it's the default (infixl 9)
16:34:21 <halvorg> And I want the timestamps to represent the time they were added.
16:34:38 <halvorg> but anyways, this is such an edge case it'll never be a problem
16:34:47 <halvorg> and the unsafeIO things I don't want to touch
16:34:50 <merijn> halvorg: I meant, separate the timestamp from the atomic lock acquisition
16:34:52 <halvorg> interest purely academic
16:36:03 <halvorg> merijn: yeah I could do a write, then take timestamp, then overwrite it again I guess.
16:38:44 <trap_exit> I like http://conal.net/fran/tutorial.htm
16:38:47 <trap_exit> why no one post above?
16:40:48 <athan> Can you put kind signatures and use currying for datatype/type abbreviations? For instance, `type ThreeDim = (,,); type ThreeDim :: * -> *`?
16:41:18 <athan> er, wait
16:41:19 <athan> sorry
16:41:20 <athan> nvm
16:43:07 <merijn> I forget, where is Proxy defined?
16:45:36 <shachaf> Data.Proxy
16:46:30 <merijn> Ah, thanks :)
17:04:22 <Shockk> hello, I'm trying to write some code which uses the acid-state package; I've written code based on the examples provided and stuff but I'm getting a no instance error and can't for the life of me figure out why
17:04:59 <Shockk> I've gisted the code and error, if anyone has experience with this: https://gist.github.com/shockkolate/38fa038cb9ab220ceed9
17:06:13 <Shockk> oh, the line number will be off because I excluded a copyright header; the actual line number of the error is 21
17:06:58 <eriksensei> re ghc's penchant for telling me: 'no instance of C arising from a use of X': why should an instance of C 'arise' from a use of X, as opposed to from a definition of C?
17:07:49 <eriksensei> oh that's funny, i was fiddling with postgresql-simple when getting my 'no instance' :)
17:09:07 <geekosaur> an instance of C won't come from a definition of C (or a definition of X, for that matter). if you try to use X in a way which requires an instance of C, it looks for it then.
17:09:37 <hpc> Shockk: weird
17:10:04 <geekosaur> it's not like X carries a C instance around automagically; an appropriate instance must be in scope, and won't be checked unless something requires it (that is, you use X with a function that has a C constraint)
17:10:30 <Shockk> hpc: I'm very confused
17:10:44 <Fuuzetsu> the two-variable hom functor is not amused: Hom(–,–)
17:11:23 <hpc> Shockk: going off some code i have that works, perhaps change your data definitions so they deriving (Eq, Ord, Read, Show, Data, Typeable)
17:11:59 <eriksensei> geekosaur: I understand what you're saying, but I'm not quite sure I understand how the word 'arise' would apply to that. i'll think about it for a bit
17:12:25 <geekosaur> because it only matters when you pass X to a function that has a C constraint
17:12:48 <hpc> alternatively, the necessary instance might be in Data.Acid.Advanced or Data.Acid.Local
17:13:09 <hpc> it's too late here for me to think harder on it, hopefully that helps
17:13:24 <geekosaur> you may be thinking about types the way you would in Java or C++ where the class is instanced as part of the type definition. in Haskell it is separate, and it is entirely possible for the instance to not be in scope when the type is
17:14:09 <eriksensei> geekosaur: btu wouldn't it amke more sense to say 'could not be found' instead of 'arising'?
17:14:37 <geekosaur> it only comes up because you passed it to a function with a class constraint
17:14:53 <eriksensei> geekosaur: no I (believe I) get how it works, but I never quite understood why the error message is worded in that way
17:15:01 <Shockk> hpc: unfortunately still the same error after adding those
17:15:12 <geekosaur> think of it as a hint about how type resolution and instance resolution work in Haskell
17:15:15 <joelteon> "No instance for X; one could not be found"
17:15:18 <joelteon> that's not very helpful
17:16:00 <geekosaur> the instance has no relevance until you use a function with a class constraint; at that point, the need for an instance arises, and it tries to satisfy it and fails
17:16:14 <eriksensei> right; the *need* for one arises
17:16:15 <sm> is there a way to see more detail on what caused an optparse-applicative parser to fail, than just the usage info ?
17:16:20 <geekosaur> (possibly also this is an English-dialect thing...)
17:16:22 <eriksensei> but not the instance proper
17:16:54 <joelteon> it doesn't say the instance arises from the usage of C
17:17:10 <antho> is it possible to generate an infinite list of different StdGens?
17:18:39 <Shockk> I'm going to try copying one of the examples' data types and get that to work first, then see if I can change it to work with mine
17:19:03 <eriksensei> joelteon: no, it says that the instance *doesn't* arise from a usage of C, right? i think i might be misunderstanding something about the wording perhaps
17:20:06 <geekosaur> I think your confusion might be that you'r reading it as the instance is arising from, but in fact itthe failure to find an instance
17:20:10 <geekosaur> erp
17:21:11 <geekosaur> I think your confusion might be that you'r reading it as "the instance is arising from", but in fact it should be read "the failure to find an instance is arising from" --- the search for an instance came about because of the use of X in a context requiring an instance of C
17:21:13 <joelteon> I think the error message needs a comma
17:21:28 <joelteon> No instance for foo, arising from usage of bar
17:21:33 <eriksensei> eureka!
17:21:52 <eriksensei> thanks guys, that was the missing piece! :D i feel so relieved
17:22:28 <eriksensei> i'll go back and stare at the message for a while to see if i can make it click inside my head now
17:23:39 <joelteon> I thought it used to have a comma but maybe not
17:24:18 <eriksensei> i'll mentally superimpose a comma on there from now on :)
17:24:55 <eriksensei> might make a cool PR for ghc *cough*
17:26:09 <merijn> Is it possible to fake Sigma types more efficiently than the linked list HList approach?
17:30:09 <Shockk> hpc: hm weird, I tried compiling the example, literally wget'd from the website, and it gets the same error :/
17:31:03 <Shockk> oh, apparently it's to do with two different mtl versions installed
17:31:26 <hpc> lol that'd do it
17:35:41 * hackagebot persistent-mysql 2.0.1 - Backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-2.0.1 (GregWeber)
17:35:43 * hackagebot persistent-postgresql 2.0.1 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-2.0.1 (GregWeber)
17:41:37 <Shockk> deleted my ~/.ghc directory and then reinstalled the stuff I needed and I have no error now :D
17:46:08 <McManiaC> good old bruteforce
17:54:25 <cultofmetatron> anyone out there that can help a newbie with a type system question?
17:55:12 <benzrf> cultofmetatron: all of User932
17:55:19 <benzrf> cultofmetatron: dont ask to ask!
18:00:44 * hackagebot extended-categories 0.1.0 - Extended Categories  http://hackage.haskell.org/package/extended-categories-0.1.0 (ian_mi)
18:01:07 <cultofmetatron> ok
18:01:27 <cultofmetatron> I'm trying to write a function to compute the polynomial n of a sine taylor series
18:01:39 <cultofmetatron> taylorPolySine theta n =  (((-1) ^^ n) / (factorial ((2 * n) + 1))) * (theta ^^ (2 * n + 1))
18:02:08 <cultofmetatron> but these types things are confusing the crap out of me
18:02:27 <cultofmetatron> like it throws an error when I try to run it over any 2 tumbers
18:03:29 <cultofmetatron> https://github.com/cultofmetatron/learn-haskell/blob/master/trig/trig.hs
18:04:27 <MP2E> cultofmetatron: your factorial function multiplies everything by 0, thus making any factorial output 0
18:04:36 <MP2E> err wait
18:04:38 <MP2E> hmm
18:04:45 <MP2E> yes
18:04:58 <MP2E> sorry, second guessed myself there
18:05:12 <MP2E> brb
18:05:30 <cultofmetatron> oh thanks for letting me know! can't believ I missed that one
18:05:36 <cultofmetatron> still throws type errors however
18:06:35 <splintax1> the "no instance for show" error?
18:08:10 <cultofmetatron> No instance for (Num b0) arising from the literal `1'
18:08:10 <cultofmetatron>     The type variable `b0' is ambiguous
18:08:10 <cultofmetatron>     Possible fix: add a type signature that fixes these type variable(s)
18:08:12 <cultofmetatron>     Note: there are several potential instances:
18:08:14 <cultofmetatron>       instance Num Double -- Defined in `GHC.Float'
18:08:16 <cultofmetatron>       instance Num Float -- Defined in `GHC.Float'
18:08:18 <cultofmetatron>       instance Integral a => Num (GHC.Real.Ratio a)
18:08:20 <cultofmetatron>         -- Defined in `GHC.Real'
18:08:22 <cultofmetatron>       ...plus three others
18:08:24 <cultofmetatron>     In the first argument of `taylorPolySine', namely `1'
18:08:26 <cultofmetatron>     In the expression: taylorPolySine 1 2
18:08:28 <cultofmetatron>     In an equation for `it': it = taylorPolySine 1 2
18:08:32 <cultofmetatron> woops, ddin't mean to spill teh screen
18:10:42 <benzrf> cultofmetatron: oh noo
18:10:53 <benzrf> cultofmetatron: looks like youve fallen victim to the dreaded monomorphism restriction!
18:10:56 <benzrf> possibly
18:11:35 <benzrf> oh wait
18:11:57 <benzrf> cultofmetatron: :t taylorPolySine
18:12:37 <cultofmetatron> monomorphism restriction?
18:12:41 <cultofmetatron> wghats that?
18:13:27 <benzrf> cultofmetatron: i might be wrong
18:13:34 <benzrf> can u check what type haskell thinks taylorPolySine is
18:14:01 <splintax> afaict the problem is related to this http://www.haskell.org/tutorial/numbers.html
18:14:29 <splintax> the arguments in "taylorPolySine 1 2" are of ambiguous type
18:15:20 <splintax> :t (taylorPolySine 1 2)
18:15:21 <splintax> (taylorPolySine 1 2) :: (Integral b, Fractional b) => b
18:15:21 <lambdabot> Not in scope: ‘taylorPolySine’
18:15:47 <benzrf> ahihi:
18:15:48 <benzrf> *ah
18:15:55 <hakujin> using dupChan to create broadcast chans for client threads; I need to create a sort of reaper thread to read from the original, yeah? forkIO loop where loop = readChan c >> loop
18:15:57 <benzrf> im not sure there are any built in types that are both integral and fractoinal
18:16:40 <benzrf> cultofmetatron: yep thats your problem
18:16:50 <benzrf> cultofmetatron: have you considered doing type conversion or using alternative funcs
18:17:38 <simpson> cultofmetatron: Just pick a more concrete type: taylorPolySine :: Double -> Double -> Double
18:18:10 <splintax> or rather Double -> Int -> Double ;)
18:18:21 <cultofmetatron> ok
18:18:51 <splintax> there's probably a more correct/polymorphic solution to the problem but i can't see it right now
18:19:07 <cultofmetatron> trying this
18:19:18 <cultofmetatron> taylorPolySine :: (Double b, Int a) => b -> a -> b
18:19:18 <cultofmetatron> taylorPolySine theta n =  (((-1) ^^ n) / (factorial ((2 * n) + 1))) * (theta ^^ (2 * n + 1))
18:19:37 -cultofmetatron(~cultofmet@c-98-210-31-139.hsd1.ca.comcast.net)- `Double' is applied to too many type arguments
18:19:37 -cultofmetatron(~cultofmet@c-98-210-31-139.hsd1.ca.comcast.net)-     In the type signature for `taylorPolySine':
18:19:38 <splintax> benzrf meant to write: taylorPolySine :: Double -> Int -> Double
18:19:42 -cultofmetatron(~cultofmet@c-98-210-31-139.hsd1.ca.comcast.net)- `Double' is applied to too many type arguments
18:19:42 -cultofmetatron(~cultofmet@c-98-210-31-139.hsd1.ca.comcast.net)-     In the type signature for `taylorPolySine':
18:19:49 <cultofmetatron> `Double' is applied to too many type arguments
18:19:49 <cultofmetatron>     In the type signature for `taylorPolySine':
18:19:51 <cultofmetatron> and I get
18:20:03 <cultofmetatron> `Double' is applied to too many type arguments
18:20:04 <cultofmetatron>     In the type signature for `taylorPolySine':
18:20:19 <splintax> Double and Int are types, whereas Num and Frac are typeclasses
18:20:32 <splintax> so f :: Double -> Double is a regular function that only works on doubles
18:20:33 <simpson> cultofmetatron: The constraints on the left of => are typeclasses, not types. Use a concrete type signature.
18:21:05 <cultofmetatron> like this: taylorPolySine ::  Double -> Int -> Double
18:21:06 <splintax> whereas f :: Num a => a -> a is a polymorphic function that works on any type which is an instance of Num, which includes Int, Double, etc
18:21:08 <cultofmetatron> ?
18:21:34 <splintax> yes, that's the easy solution to your problem, if you don't need the function to be polymorphic
18:22:05 <cultofmetatron> Couldn't match expected type `Double' with actual type `Int'
18:22:05 <cultofmetatron>     In the second argument of `(*)', namely `n'
18:22:05 <cultofmetatron>     In the first argument of `(+)', namely `(2 * n)'
18:22:07 <cultofmetatron>     In the first argument of `factorial', namely `((2 * n) + 1)'
18:22:09 <cultofmetatron> now I get the error
18:22:24 <tertl3> > :t
18:22:25 <lambdabot>  <hint>:1:1: parse error on input ‘:’
18:22:36 <tertl3> > type
18:22:37 <lambdabot>  <hint>:1:1: parse error on input ‘type’
18:22:39 <simpson> Like I said, you probably want Double -> Double -> Double
18:22:46 <tertl3> > Int
18:22:47 <lambdabot>  Not in scope: data constructor ‘Int’
18:22:48 <lambdabot>  Perhaps you meant one of these:
18:22:48 <lambdabot>    ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
18:22:48 <lambdabot>    ‘InR’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
18:23:10 <tertl3> > PutStrLn "hello parple"
18:23:11 <lambdabot>  Not in scope: data constructor ‘PutStrLn’
18:23:16 <cultofmetatron> whats the diffrence between ^ ^^ and **?
18:23:28 <cultofmetatron> it seems to be throwing erros taht I use ^^ now
18:23:34 <tertl3> > import System.IO ()
18:23:35 <lambdabot>  <hint>:1:1: parse error on input ‘import’
18:23:46 <simpson> tertl3: lambdabot is not ghci. What's up?
18:23:54 <tertl3> hi
18:24:08 <tertl3> im just fiddlin
18:24:16 <geekosaur> can you fiddle in pm?
18:24:17 <tertl3> make it do stuff pls
18:24:47 <cultofmetatron> No instance for (Integral Double) arising from a use of `^^'
18:24:47 <cultofmetatron>     Possible fix: add an instance declaration for (Integral Double)
18:26:58 <McManiaC> cultofmetatron: fromIntegral
18:27:24 <BMeph_> cultofmetatron: ".../ fromIntegral (factorial..." should help. :)
18:28:39 <cultofmetatron> trying this: taylorPolySine theta n =  (((-1) ^^ n) / (fromIntegral (factorial ((2 * n) + 1))) * (theta ^^ (2 * n + 1)))
18:28:44 <McManiaC> cultofmetatron: something like this: http://puu.sh/bhKCw/c8b2eee532.png
18:29:16 <McManiaC> always add type signatures when working with numbers
18:29:25 <McManiaC> otherwise haskells number system is gonna bite you
18:30:35 <cultofmetatron> still getting No instance for (Integral Double) arising from a use of `^^'
18:31:18 <cultofmetatron> wait nvm
18:31:21 <cultofmetatron> h/o
18:31:22 <McManiaC> double check it
18:31:23 <McManiaC> :)
18:31:29 <McManiaC> n should be Int
18:31:38 <McManiaC> or Integer
18:32:07 <cultofmetatron> ok I'm getting somethign out of it
18:32:11 <cultofmetatron> now to double check
18:32:23 <cultofmetatron> man that was crazy
18:32:26 <McManiaC> :D
18:32:26 <simpson> > let f theta n = ((-1) ** n) / ((factorial (2 * n + 1)) * theta ** (2 * n + 1)) in f 2 1
18:32:28 <lambdabot>  Not in scope: ‘factorial’
18:32:49 <cultofmetatron> I've been doing haskell for a few days now. do the types ever start making sense?
18:32:57 <simpson> > let factorial n = if n <= 0 then 1 else factorial (n - 1) * n; f theta n = ((-1) ** n) / ((factorial (2 * n + 1)) * theta ** (2 * n + 1)) in f 2 1
18:32:59 <lambdabot>  -2.0833333333333332e-2
18:33:02 <simpson> cultofmetatron: Sure!
18:33:05 <cultofmetatron> yup thats what I got
18:33:10 <McManiaC> cultofmetatron: numbers are one of the worst types in haskell
18:33:15 <simpson> Numbers are fine.
18:33:40 <McManiaC> …to get used to
18:33:41 <McManiaC> :)
18:33:43 <simpson> The problem is that, for some strange reason, everybody keeps putting IEEE 754 floats into CPUs, and everybody keeps expecting Haskell to execute on CPUs.
18:35:12 <splintax> cultofmetatron: it takes longer than a few days but they start making a lot of sense eventually. i find that it helps to constantly ask ghci for the types of things with ":t foo"
18:35:38 <cultofmetatron> cool
18:35:48 <simpson> Anyway, the splits start making more sense when you see things like Data.Ratio.
18:35:50 <cultofmetatron> its a bit of a culture shock comming from javascript
18:36:06 <simpson> Ah, where you have only one numeric type? Sure.
18:36:24 <cultofmetatron> there's plenty of other bullshits about javascript
18:36:36 <cultofmetatron> typeof(NaN) === 'Number' for one
18:37:17 <cultofmetatron> or that [1, 2, 3, 4].sort() sorts lexographically by default
18:37:49 <cultofmetatron> I'm mostly interested in haskell's promises of reducing runtime errors
18:41:08 <splintax> it's great if you're the kind of javascript developer i am, which is one too lazy to write comprehensive unit tests
18:41:48 <simpson> Just remember that Haskell is no better than any other language at avoiding the maxim that untested code is broken code.
18:42:25 <cultofmetatron> I'm pretty big on unit tests
18:42:39 <tabemann> Haskell just limits wide classes of errors through a powerful system of static typing and through greatly limiting side effects
18:42:51 <cultofmetatron> I heavily use promises because they make it alot easier to write your code with unit testign in mind
18:43:32 <cultofmetatron> and I figure all the really intersting js libraries for functional programmign are ports of haskell libraries
18:43:37 <cultofmetatron> might as well go to the source
18:44:27 <simpson> "The source" is probably the Self and E object environments, BTW.
18:45:10 <nax> simpson, it is just kinda funny how lots of test are useless with a type system like haskell
18:45:20 <nax> (compared to any _dynamic_ pl, obviously)
18:45:29 <tabemann> the only thing is that Haskell relies heavily on type classes, something that don't really exist in JavaScript
18:46:07 <Hodapp> or types.
18:48:31 <tabemann> I remember reading a Groovy book which was like "well dynamicness doesn't matter, because you'd have to write unit tests anyways"... as if static typing didn't rule out whole classes of errors so you wouldn't have to write tests for them in general
18:49:19 * simpson shrugs
18:49:42 <simpson> In my experience, most of what people want are static names and static scope resolution, not static typing, but whatever.
18:50:54 <trap_exit> are the ipads ARM? does GHC compile to ARM? or is my only choice to use ghcjs + javascript on the ipad
18:53:52 <l0cust> trap_exit: ghc has limited support on ARM
18:54:07 <trap_exit> l0cust: so basically "expect stuff to break"
18:54:31 <l0cust> trap_exit: everything works except ghci, so no template haskell
18:54:36 <l0cust> trap_exit: supposedly
18:54:37 <l0cust> I haven't tried it
18:54:44 <trap_exit> oh
18:54:48 <trap_exit> that's actually good enough for me
18:55:30 <l0cust> trap_exit: for your purposes maybe, but some of the libraries you use probably rely on template haskell
18:55:43 <trap_exit> pretty sure it does not
18:55:43 <MP2E> template haskell works too technically, you need to use a tool called EvilSplicer in conjunction with your host GHC. It's pretty hacky, but I used it to get lens and a few other libraries to work
18:55:43 <trap_exit> I don't use lens
18:55:56 <MP2E> tested them on android and they worked fine
18:56:14 <trap_exit> MP2E: why would anyone willingly subject themselves to such pain ?
18:56:22 <l0cust> Alright, I've been stress-testing my cpu for 6 hours now. do you think it's enough?
18:56:52 <trap_exit> did you atleast mine a few dogecoins ?
18:57:03 <l0cust> trap_exit: no, sorry
18:57:16 <MP2E> trap_exit: I'm pretty fascinated by cross compilers, before i came to Haskell I played around with mingw-w64 and a few other cross toolchains so I figured I'd try my hand at getting GHC 7.8 to work on Android
18:57:20 <MP2E> and develop a workflow around it
18:57:24 <MP2E> it was a pretty fun week :P:
18:57:25 <MP2E> :P *
18:57:37 <MP2E> i should really pick that back up actually
18:57:38 <trap_exit> MP2E: oh, you're one of those people who do canadian crosses for fun?
18:57:43 <MP2E> pretty much heh
18:58:05 <MP2E> I got sidetracked by NixOS or it'd probably be further :P
18:58:22 <MP2E> right now it fully "works" but getting it to work is another story
18:58:28 <MP2E> hehe
18:59:15 <McManiaC> can you actually use Haskell with androids UIs somehow?
18:59:34 <McManiaC> or can you only compile "console" applications?
19:00:14 <L8D> I thought that you write Android apps with Elm-PhoneGap
19:00:25 <L8D> instead of Haskell
19:00:34 <MP2E> You use the Android NDK like any other C or C++ application, basically. The entry point is in Java and you have to write the UI and frontend logic (including drawing to the screen) in Java
19:00:42 <MP2E> but you can still render everything and do the real work in Haskell and pass it over
19:00:43 <McManiaC> I have no clue about android dev
19:00:47 <MP2E> similar to what emus do on the Android market today
19:00:51 <MP2E> see : RetroArch
19:01:11 <MP2E> it's kinda annoying though
19:01:18 <MP2E> having to pass input into haskell and pass the output back out
19:01:33 <McManiaC> I see
19:02:32 <MP2E> I wish Google would open the platform up to full natively compiled applications
19:02:37 <l0cust> MP2E: This is why I learned Scala, so I can have a semi-decent java implementation in which I can write Android Apps
19:02:39 <MP2E> but that's another story heh
19:02:43 <l0cust> MP2E: "security issues"
19:03:05 <McManiaC> heh "don't look at our bad code"
19:06:57 <MP2E> oh, one important thing to note: You can run fully native applications if they are in console mode and *if* your phone is rooted
19:07:21 <MP2E> I did that at first as a sanity test
19:07:31 <MP2E> with a prime number summer I think or something
19:07:44 <MP2E> 2 pretty big ifs though that exclude all practical use :)
19:08:01 <MP2E> for consumers, I mean.
19:15:54 * hackagebot LambdaINet 0.2.0.0 - Graphical Interaction Net Evaluator for Optimal Evaluation  http://hackage.haskell.org/package/LambdaINet-0.2.0.0 (PaulLiu)
19:16:52 <lucky> hi folks.  I'm using Aeson to handle some JSON data, I've been deriving Generic to do the heavy work for me but the smallest of snags: one of the JSON objects uses a Haskell keyword as its key value, any suggestions?
19:20:48 <guesting> Does anyone know how to make optparse-applicative optional? So it would require "--input" for instance only if an option is present, and just go by the order of the arguments if no options are present?
19:20:51 <guesting> like
19:21:19 <guesting> "fun -i test -o output" works, but "fun test output" would also work?
19:22:11 <guesting> essentially I want to be able to pipe input using "|" from the command line, but optparse-applicative sees "-" as a literal "-"
19:48:02 <cstrahan> so, just gave my GF a quick 1 hour tutorial on JavaScript (she's never programmed before),
19:48:52 <cstrahan> and her response was something like "what!? you cant just [mutate] variables like that! how could that possibly be maintainable?"
19:49:35 <MP2E> Hehe, I wonder what she'd think of Haskell
19:49:41 <cstrahan> showed her the equivalent Haskell and she like "wow, that reads pretty much like English"
19:50:39 <cstrahan> (and commented on how terse the code was)
19:50:52 <cultofmetatron> the js community is slowly growing towards pure functional style
19:50:53 <cultofmetatron> https://github.com/facebook/immutable-js
19:51:12 <bounb> cstrahan: she's a keeper.
19:51:22 <MP2E> ^
19:51:28 <cultofmetatron> granted you still don't have referential transparency or tail recursion
19:51:36 <MP2E> get a ring with a bind operator on it
19:51:46 <cstrahan> MP2E: lol
19:51:55 <MP2E> (I just wanted to be able to say that hehe)
19:52:31 <cstrahan> i just wish I could get the majority of the industry to see it the same way she does
19:52:45 <dfeuer> It's amazing how very, very long functional programming was "waiting in the wings" for the rest of the world to notice that there was anything valuable there.
19:53:21 <bounb> true words man. ideology blinds us
19:54:39 <bounb> what's functional programming obscuring in the wings
19:57:11 <jle`> cultofmetatron: there's a nice lazy js library out there too :)
19:57:46 <jle`> with real benchmarks to show the performance increases
20:03:37 <L8D> jle`: omg where?!
20:03:59 <L8D> I'm writing an FRP library and that would be so useful
20:26:03 * hackagebot yesod-bin 1.2.12.6 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.12.6 (GregWeber)
20:28:24 <tabraham> hey!
20:29:08 <joelteon> listen!
20:29:38 <MP2E> damnit naggi
20:29:58 <linman32> hi. how is it possible to make this type "EventM Ebutton MouseButton" this type "MouseButton"?
20:30:20 <linman32> *"EButton"
20:32:20 <stolaruk> Is it possible to make "unlines" use "\r\n" on a Mac?
20:32:56 <L8D> stolaruk: Macs don't use \r\n
20:33:11 <stolaruk> Yes I know
20:33:13 <geekosaur> and that kind of thing should be done on input / output, not in the middle
20:33:37 <zugzwanged> is there a way to derive a Bifunctor instance?
20:33:50 <L8D> stolaruk: map init . unlines
20:33:55 <geekosaur> linman32: I suspect you will need to show actual code. beause what you said there by itself sounds like trying to convert a callback to an event, which is kinda nonsense?
20:33:56 <tabraham> why won't this typecheck? http://lpaste.net/110379
20:34:04 <zwer> unline doesn't use "\r\n" anywhere. on windows writing "\n" to a file opened in text mode writes "\r\n"
20:34:20 <L8D> > map init . unlines $ "foo\r\nbar\r\nbaz"
20:34:21 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘[a]’
20:34:21 <lambdabot>  Expected type: [GHC.Base.String] -> [[a]]
20:34:21 <lambdabot>    Actual type: [GHC.Base.String] -> GHC.Base.StringCouldn't match type ‘GHC....
20:34:21 <lambdabot>  Expected type: [GHC.Base.String]
20:34:21 <lambdabot>    Actual type: [GHC.Types.Char]
20:34:33 <L8D> what
20:34:35 <stolaruk> I'm writing a telnet server. Telnet uses "\r\n"
20:34:41 <jmcarthur> zugzwanged: i think it is possible to do, but i don't know of an already programmed way to do it.
20:34:41 <L8D> :t unlines
20:34:42 <lambdabot> [String] -> String
20:34:46 <L8D> oh.
20:35:05 <L8D> stolaruk: intercalate "\r\n"
20:35:12 <L8D> > intercalate "\r\n"
20:35:13 <lambdabot>  <[[Char]] -> [Char]>
20:35:14 <stolaruk> L8D: Yeah that was the only idea I had
20:35:29 <zugzwanged> jmcarthur: no cunning way to use derivability of normal functors? I'm thinking there shouldn't be, but I'm not entirely sure
20:35:30 <L8D> > intercalate "\r\n" "foo\r\nbar\r\nbaz"
20:35:31 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘[GHC.Types.Char]’
20:35:32 <lambdabot>  Expected type: [[GHC.Types.Char]]
20:35:32 <lambdabot>    Actual type: [GHC.Types.Char]
20:35:45 <zwer> > intercalate "\r\n" (words "hello there")
20:35:46 <lambdabot>  "hello\r\nthere"
20:35:52 <stolaruk> ok I'll do it manually
20:36:00 <L8D> I can't write haskell at an interpreter for my life.
20:36:19 <L8D> stolaruk: You call that "doing it manually?"
20:36:21 <linman32> geekosaur:  error is below "ERROR ON LINE BELOW" comment http://lpaste.net/110382
20:36:32 <zugzwanged> jmcarthur: no, I think it is clear that you can't. nevermind, thanks
20:36:51 <stolaruk> L8D: My original question meant to ask if there is a way to tell Haskell to insert "\r\n" automatically when it unlines
20:36:58 <trap_exit> anyone run into sitautions where (1) you have functions are pure and (2) you stick them in a writer monad anyway becasue (3) for debugging purposes, you want to log what it does as the function does the computation ?
20:37:50 <L8D> stolaruk: You could have a definition for unlines at the top of your file
20:38:02 <L8D> stolaruk: Where it uses a C macro to check what OS you're using
20:38:09 <jmcarthur> trap_exit: for debugging pure functions i just use Debug.Trace
20:38:10 <L8D> or something along those lines
20:38:18 <geekosaur> the error doesn't match the code...
20:38:23 <stolaruk> L8D: Ok, yeah. Thnks
20:38:43 <trap_exit> jmcarthur: hmm, that's brilliant
20:38:44 <trap_exit> I like that solution more
20:38:55 * geekosaur doesn't even know what this package is so probably can't answer anyway, but so far there is insufficient information. also what you askedf for has little to do with the actual error you show
20:39:12 <geekosaur> since the error is comparing a function to a Signal of some kind
20:40:17 <linman32> it is from import Graphics.UI.Gtk package
20:41:39 <tabraham> hey, I can't seem to understand why the last line of this short snippet http://lpaste.net/110379 fails to typecheck but works fine in ghci
20:42:23 <linman32> geekosaur: real sorry. that was not the error.. error has been updated http://lpaste.net/110382
20:44:48 <roboguy_> tabraham: it's because the type is ambiguous. Ghci has some extra defaulting so it makes the type concrete
20:45:03 <roboguy_> Note that EmptyTree has a type Tree a
20:45:06 <roboguy_> (for all a)
20:45:26 <roboguy_> this means it can't select an instance for the Eq a => part of the == instance for Tree a
20:45:28 <tabraham> roboguy_: yep! but what does ghci have to make that work
20:45:42 <roboguy_> tabraham: usually it turns ambiguous types like that into ()
20:45:50 <tabraham> ah
20:45:53 <roboguy_> so it probably specifies like EmptyTree :: Tree ()
20:46:07 <tabraham> that's...unexpecte
20:46:08 <tabraham> +d
20:46:35 <tabraham> is there a way to tell what instance is being picked by the compiler?
20:46:53 <tabraham> like in this case Eq ()
20:46:54 <roboguy_> you can give them explicit type annotations
20:47:03 <roboguy_> EmptyTree :: Tree ()
20:47:31 <roboguy_> actually, you only need to give on of them an annotation and it will infer the other
20:48:01 <Cale> tabraham: Yeah, ghci is more aggressive about defaulting the types just because it's more convenient
20:48:03 <tabraham> roboguy_: ...but that won't let me figure out how this sort of ghci magic works :/
20:48:33 <Cale> tabraham: Otherwise, for instance, if you typed [] at the ghci prompt, it wouldn't know which type of list that was, and hence would complain about not knowing which instance of Show to use.
20:49:01 <tabraham> oh, that makes sense
20:49:01 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html#extended-default-rules
20:49:18 <tabraham> Cale++
20:49:38 <tabraham> thanks Cale roboguy_ :)
20:54:17 <linman32> hi i have error. I think i must remove EventM EButton in type def. http://lpaste.net/110382
20:55:41 <roboguy_> linman32: you need to take the MouseButton value "out" of the x with either do notation or >>=
20:56:39 <funfunctor> hi
20:58:44 <dfeuer> Whoa... I have around 8.5GB of GHC on my system. This is not reasonable.
21:00:49 <funfunctor> dfeuer: why is that not reasonable? ~9/1000 for a modern hard disk, so 0.9%
21:00:54 <linman32> roboguy_: so like?      ...if (eventButton >>= x) ==...
21:01:11 <dfeuer> funfunctor, my laptop does not have a hard disk. That is why.
21:01:43 <funfunctor> dfeuer: so compress your filesystem or use the network..
21:01:50 <roboguy_> linman32: not quite. more like, you should use your existing lambda as it is, but you should apply onButtonPress with it with >>=
21:02:18 <funfunctor> dfeuer: I assume this is a complaint because you installed GHC for xmonad or?
21:02:59 <funfunctor> dfeuer: if that is the case, you are welcome to uninstall it as its only needed to build your config
21:03:05 <dfeuer> funfunctor, I can't compress my filesystem without learning to use the relevant utilities. That particular task is not currently on my "need to do" or "particularly want to do" list. :/
21:03:32 <haasn> dfeuer: GHC version?
21:03:33 <dfeuer> funfunctor, I don't even remember what xmonad is. I have three GHC source trees because I've been hacking on the GHC base libraries.
21:03:48 <dfeuer> haasn, 7.9.
21:03:51 <funfunctor> dfeuer: which filesystem is this?
21:03:56 <roboguy_> linman32: your lambda expects a MouseButton, but right now it's getting a EventM EButton MouseButton. So it is of type MouseButton -> EventM EButton ReturnType and you want it to be EventM EButton MouseButton -> EventM EButton ReturnType. luckily, there is something that will turn it into that
21:03:57 <dfeuer> ext4.
21:03:59 <roboguy_> :t (>>=)
21:04:00 <lambdabot> Monad m => m a -> (a -> m b) -> m b
21:04:01 <funfunctor> ugh
21:04:09 <dfeuer> And I don't even remember if I have LVM or not....
21:04:12 <funfunctor> I don't trust ext4 sorry
21:04:13 <dfeuer> But I might.
21:04:34 <dfeuer> funfunctor, oh? You prefer ext3? Or maybe .... VFAT!
21:04:42 <roboguy_> well
21:04:44 <roboguy_> :t (=<<)
21:04:45 <lambdabot> Monad m => (a -> m b) -> m a -> m b
21:04:54 <dfeuer> :t :t
21:04:55 <lambdabot> parse error on input ‘:’
21:04:56 <haasn> dfeuer: Tips to decrease GHC size include “disable profiling”, which tends to cut off more than half, and “use dynamic linking” which should be enabled by default since 7.8 iirc
21:05:06 <haasn> Which cuts off a huge chunk
21:05:10 <funfunctor> dfeuer: no.. I prefer XFS, JFS, ZFS or BTFS even over ext{whatever}
21:05:19 <haasn> Static linking is one of the big reasons why GHC has historically been so huge
21:05:33 <haasn> funfunctor: What does a filesystem have to do with GHC being large?
21:05:43 <dfeuer> haasn, thanks. I kind of need profiling, however. If dynamic linking is enabled by default since 7.8, that shouldn't be the issue.
21:05:52 <funfunctor> dfeuer: depending on the workload. JFS is good for laptops, when batteries randomly runout etc..
21:06:15 <funfunctor> haasn: I was asking as he could switch on dedup
21:06:55 <dfeuer> btrfs was pretty unstable last I checked. ZFS looked interesting. XFS is pretty old, right? I don't know anything about JFS.
21:07:09 <jle`> L8D: http://danieltao.com/lazy.js/
21:07:51 <roboguy_> linman32: does that make sense?
21:08:03 <funfunctor> dfeuer: BTFS is def last on my list for sure, but still above ext4. ZFS is very very good, XFS is exellent and well maintained but just poor for laptops, JFS fills the laptop gap well
21:08:10 <dfeuer> funfunctor, my problem isn't the battery randomly running out but the motherboard or something randomly turning everything off for no reason (sometimes locking up briefly first) and with no trace in the logs.
21:08:38 <funfunctor> dfeuer: Intel box?
21:08:43 <L8D> jle`: awesome thanks
21:09:06 <funfunctor> dfeuer: could be the ME crashing and putting the CPU into reset, pretty much undetectable.
21:09:08 <dfeuer> I'll consider those FSs for my next machine. Yeah, it's pretty much all Intel.
21:09:16 <jle`> L8D: np!  any way i can follow the progress of your js frp library?
21:09:33 <funfunctor> dfeuer: update your firmware
21:09:43 <L8D> jle`: http://github.com/L8D/pancetta
21:09:48 <jle`> neat
21:09:54 <jle`> i wish i could think of good names
21:09:56 <L8D> It's essentially Bacon.js but much more lightweight
21:10:05 <funfunctor> dfeuer: a missconfiguration in the MRC blob for DRAM init can result in the ME randomly resetting your machine
21:10:10 <haasn> I wouldn't recommend XFS unless you have a UPS or battery or some other mechanism to prevent data loss due to power outages
21:10:14 <L8D> like < 4k lightweight
21:10:18 <dfeuer> funfunctor, I sent you pms.
21:10:19 <L8D> and I'm writing documentation now.
21:10:19 <linman32> roboguy_: no =( . it sounds like the x needs to be applied the >>=?
21:10:26 <jle`> L8D: i see
21:12:34 <beckyconning> when making a function can you apply a where to multiple pattern matched equations / is it better to do the thing you are doing in the where in another function? at the moment i'm doing like "functionName var1 = worker var2 where" followed by pattern matching but it seems a bit upside down / not what "worker' functions are for.
21:12:42 <roboguy_> :t (return 'a' >>=)
21:12:43 <lambdabot> Monad m => (Char -> m b) -> m b
21:14:23 <roboguy_> linman32: there are basically two options, you can do something like x >>= (\x' -> ...) or you could do something like (>>= (\x -> ...)). In both cases, the >>= turns a MouseButton -> m ReturnType function into a "m MouseButton -> m ReturnType" function (where m is EventM EButton)
21:15:01 <roboguy_> it's more obvious with the flipped version, =<<, that it takes a "a -> m b" and turns it into "m a -> m b"
21:15:05 <roboguy_> :t (=<<)
21:15:06 <lambdabot> Monad m => (a -> m b) -> m a -> m b
21:15:19 <roboguy_> that can also be written Monad m => (a -> m b) -> (m a -> m b)
21:15:52 <redtricycle> How can I do String->DateTime?
21:15:58 <redtricycle> "2014-08-11T17:30"
21:16:00 <redtricycle> is my string
21:16:07 <redtricycle> with "T" separating the date and the time
21:18:49 <linman32> roboguy_: hmm. error changed http://lpaste.net/110387
21:19:03 <roboguy_> linman32: oh, no. get rid of the first if
21:19:09 <roboguy_> oh wait
21:19:19 <roboguy_> never mind, let's see...
21:19:52 <linman32> roboguy_: get rid of first if?
21:19:58 <roboguy_> no, I misread it
21:21:08 <roboguy_> linman32: you probably want to apply runReaderT after onButtonPress, because EventM is the following type synonym and that is how you would get an IO out of that https://hackage.haskell.org/package/gtk-0.11.0/docs/Graphics-UI-Gtk-Gdk-EventM.html#t:EventM
21:23:50 <linman32> roboguy_: it says runReaderT not in scope
21:24:59 <roboguy_> linman32: it's in Control.Monad.Reader (you can see by clicking on the ReaderT link in the link I gave you above)
21:28:38 <linman32> roboguy_: where should i put runReaderT?  "onButtonPress runReaderT eb (\x..."
21:28:45 <linman32> roboguy_: b/c that gave error
21:29:01 <roboguy_> linman32: no, onButtonPress gives you an EventM ... and you need an IO ...
21:29:03 <linman32> roboguy_: also, i removed the >>=.
21:29:10 <roboguy_> so you apply it to the result of onButtonPress
21:29:12 <roboguy_> keep the >>=
21:31:54 <linman32> roboguy_: result http://lpaste.net/110388
21:36:12 <roboguy_> linman32: hmm, maybe I was looking at the wrong version. let's see...
21:37:44 <roboguy_> oh I see
21:42:12 <roboguy_> get rid of the >>= and the runReaderT. Instead, you'll need something like (\x -> flip runReaderT ... eventButton >>= (\x' -> if ...))
21:43:00 <roboguy_> although, you might want that entire function to be in the EventM monad instead of IO
21:43:22 <roboguy_> I'm not really familiar with the library. You'll need to run the EventM at some point though
21:49:08 <linman32> roboguy_: like this? http://lpaste.net/110389
21:49:16 <linman32> roboguy_: there is error, but i might be doing it wrong
21:49:24 <jare`> might someone direct me to a resource for learning about type operators. I have seen this (:->) many times but am having trouble discovering it meaning by googling for it.
21:49:49 <shachaf> It depends on what library you're using that defines it.
21:49:53 <shachaf> It's not built into Haskell.
21:49:55 <c_wraith> jare`: that's something library-defined.  if you have *no* idea where it's from, try hayoo
21:50:08 <c_wraith> jare`: on the other hand, you probably know what libraries your code is using, and can guess
21:50:22 <roboguy_> linman32: the problem is, you need something to in between runReaderT and eventButton. It looks like you need a Ptr EButton, but I'm not sure how that works unfortunately
21:51:02 <jare`> Ah, I see... So the (:->) in the type is Library defined. Great thank you!
21:52:26 <linman32> roboguy_: ok, thank you for your time and help. perhaps starting w/ first tutorials in gtk is a better idea
21:53:54 <roboguy_> linman32: sure. I wish I could have been more help
21:58:45 <futureperfect> Hello, I just started working on some of the Euler problems I was able to get a working solution to problem 2  http://lpaste.net/6636127988792426496 but am not entirely certian why the second verision didn't work.
22:12:24 <haasn> futureperfect: The first one is an error
22:12:44 <haasn> The second one is an error too
22:13:32 <haasn> futureperfect: In the first version, you use ‘x’ before it's in scope
22:13:44 <haasn> And in the second version, you have a stray ‘H’
22:17:01 <futureperfect> haasn: The fist version returns a value, but it's possibly wrong then? And the stray H is probably just a typo from when I pasted.
22:17:34 <futureperfect> haasn: and thank you very much for your help.
22:18:01 <haasn> If you remove the ‘H’ then the second version looks correct, and the first one should either return 0 or loop indefinitely, depending on what the value of ‘x’ is - which, here, comes from somewhere outside of the definition
22:29:08 <roboguy_> haasn, futureperfect: The second one will hang because it is effectively using filter (<= 4000000) instead of takeWhile
22:35:55 <adas> are typefamilies a way to group a set of typeclasses in the way a typeclass is used to relate a set of types?
22:36:13 <shachaf> No.
22:36:25 <roboguy_> adas: type families are just functions at a type level
22:36:36 <roboguy_> (so no)
22:41:16 <futureperfect> roboguy_: I figured that was the problem was something like that, but am still unsure as to what exactly is happening that makes the program hangs. Just verivied that http://lpaste.net/110395 does in fact work, though I feel like I had tried something very similar the version with 'x' not in scope that returned the same value earlier today.
22:42:00 <futureperfect> roboguy_: so thanks for your help, too.
22:42:07 <roboguy_> futureperfect: If you do something like filter (< 3) [1..], it will hang. This is because filter has no idea if the list its given will look like [... 100, 101, 2, 1, 102, 103 ...]
22:43:08 <roboguy_> filter doesn't know anything about patterns that may or may not be in the list, it just goes through the entire list and keeps everything that matches its predicate
22:43:49 <adas> roboguy_: what you mean "functions at type level"? you mean, functions that returns "Types" as opposed to "values" of a types?
22:43:53 <futureperfect> roboguy_: Ok, I think I understand a bit more clearly what happened now.
22:44:20 <roboguy_> adas: type families are functions that take types and give you types. regular haskell functions take values and give you values
22:45:48 <c_wraith> roboguy_: for extra fun, classes are functions that take types and return values!  In a certain limited way.
22:46:26 <roboguy_> adas: for instance, you might have: type family Ix a where { Ix [a] = Int; Ix (Vector a) = Int; Ix (Map k a) = k }
22:46:31 <adas> roboguy_: oh...its kindof meta.
22:46:33 <roboguy_> c_wraith: true
22:46:55 <roboguy_> like the opposite of a dependent type
22:47:44 <roboguy_> adas: it's useful for lots of type level computations
22:48:35 <roboguy_> for example, you can have a vector that is of a static size that is type checked at compile time and you can write stuff like a statically checked safe index function
22:48:36 <adas> i assume its used if haskell was used to create a language that has a type system ..
22:48:46 <roboguy_> ?
22:48:58 <roboguy_> no, it's just used for haskell code
22:49:20 <roboguy_> maybe embedded DSLs too I guess, but that's still haskell code
22:49:36 <adas> meaning, if someone were to be used to create the type system of another General purpose language, then type families would be used
22:50:05 <roboguy_> what do you mean by create the type system of another language?
22:50:28 <roboguy_> type families are stuff that's checked at compile time, not run time
22:51:01 <adas> roboguy_: coud you tell me what problem does typefamily solve?
22:51:32 <roboguy_> adas: well, that Ix family I gave above is one example. Another example would be type level computations. let me write a quick one up...
22:53:36 <L8D> :t scan
22:53:37 <lambdabot>     Not in scope: ‘scan’
22:53:37 <lambdabot>     Perhaps you meant one of these:
22:53:37 <lambdabot>       ‘scanl’ (imported from Data.List),
22:53:45 <L8D> :t scanl
22:53:46 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
22:53:49 <L8D> :t foldl
22:53:50 <lambdabot> (b -> a -> b) -> b -> [a] -> b
22:54:01 <L8D> o.O
22:54:08 <L8D> oooh
22:55:17 <c_wraith> L8D: yep.  scanl spits out all the intermediate results!
22:55:49 <L8D> I'm trying to figure out the difference between the 'reduce' and 'aggregate' methods in this one library
22:56:04 <L8D> the only difference I see is the order of the arguments
23:00:10 <L8D> yep. confirmed. only difference is the order of the arugments
23:00:12 <L8D> wtf
23:05:58 <roboguy_> adas: well, unfortunately it looks like I'm too tired to write up a good example right now. maybe another time. They can be used to do a kind of metaprogramming with types. they can also be interesting when combined with type classes
23:06:30 * hackagebot filepather 0.3.0 - Functions on System.FilePath  http://hackage.haskell.org/package/filepather-0.3.0 (TonyMorris)
23:07:39 <roboguy_> with a (<=) type family, you can write things kind of like safeIndex :: Proxy (n <= m) -> Proxy n -> Vec m a -> a, given an appropriate statically sized Vec type and it should always catch indexing errors at compile time. I can't quite remember how to get that particular example to work right now though
23:07:44 <adas> roboguy_: np. im searching on google as well
23:08:35 <L8D> jle`: BTW, if you care, I just finished writing the initial documentation for everything
23:11:30 * hackagebot retry 0.5.1 - Retry combinators for monadic actions that may fail  http://hackage.haskell.org/package/retry-0.5.1 (OzgunAtaman)
23:11:32 * hackagebot cassy 0.7.1 - A high level driver for the Cassandra datastore  http://hackage.haskell.org/package/cassy-0.7.1 (OzgunAtaman)
23:20:44 <trap_exit> swift + haskell = world domination
23:20:45 <trap_exit> s/world/osx/
23:21:18 <L8D> trap_exit: how does swift have anything to do with haskell?
23:21:30 <loomer> Good question
23:21:40 <trap_exit> it's hard to write OSX applications in haskell due to the lack of decent bindings
23:21:52 <trap_exit> and Objective-C being sorta weird from a "I like types" background
23:22:05 <trap_exit> swift changes this , in that haskell + swift (for FFI) > haskell + obj-c (for FFI)
23:22:06 <L8D> And swift allows those bindings to be better?
23:22:41 <trap_exit> have you tried programming in swift? it has better support for "higher order functions + types + consts (via let)"; it's definitely closer to haskell than obj-c ever was
23:23:10 <L8D> I'm not an Obj-C dev so no. I stick to phonegap for that
23:23:13 <trap_exit> if only swift had a GC rather than use ARC, it probably wouldn't be too hard to do haskell -> swift compiler
23:23:43 <L8D> Wait...Haskell has a GC?
23:24:06 <trap_exit> L8D: haskell is garbage collected ...
23:24:09 <ski> nope
23:24:17 <trap_exit> L8D: so you use ghcjs + phonegap ?
23:24:19 <trap_exit> ski: what? haskell has no garbage collection?
23:24:24 <L8D> ?!?!?!
23:24:24 <lambdabot> Unknown command, try @list
23:24:28 <ski> implementations of Haskell may have GC
23:24:37 <L8D> Does GHC use GC?
23:24:43 <ski> Haskell is a language. afaik it doesn't mandate a GC
23:24:43 <catchmrbharath> Hi. I was trying out Exercise 4 of http://www.seas.upenn.edu/~cis194/hw/05-type-classes.pdf. I am running into errors and I am not sure what I am doing wrong. Here is the code for Mod 7 exercise -> http://lpaste.net/3628587237236539392. Can somebody take a look?
23:24:46 <trap_exit> how do you handle MVars without GC?
23:24:47 <ski> L8D : yes
23:25:23 <L8D> trap_exit: I use JavaScript + PhoneGap
23:25:31 <catchmrbharath> Code with error -> http://lpaste.net/3628587237236539392
23:25:46 <L8D> but I use a hand-rolled functional composition library and FRP framework
23:26:21 <trap_exit> conditioned on using javascript, I think that's about as good as you can do
23:26:29 <ski> catchmrbharath> :t lit
23:26:31 <trap_exit> though I think ghcjs is better
23:26:40 <L8D> trap_exit: why?
23:26:54 <trap_exit> because ghcjs = write in haskell, it compiles to javascript
23:27:00 <trap_exit> then for any javascript part, you use the javascript ffi
23:28:26 <L8D> trap_exit: The problem is that I need fast and scalable code. GHCJS unfortunately doesn't provide that.
23:28:32 <catchmrbharath> ski: lit :: Integer->a
23:28:47 <L8D> I also have half a dozen libraries I have to hook into.
23:28:51 <ski> catchmrbharath : for `Expr a' ?
23:28:59 <trap_exit> L8D: i have had no performance problems with ghcjs
23:29:15 <ski> catchmrbharath : btw, unless you already are familiar with `data' and `newtype', i'd suggest writing instead something like `newtype Mod7 = MkMod7 Integer deriving (Eq,Show)', to distinguish more clearly between the data constructor and the type constructor
23:29:25 <catchmrbharath> ski: This is the complete code http://lpaste.net/3628587237236539392
23:29:35 <catchmrbharath> ski: yes
23:30:13 <ski> catchmrbharath : hm, please write more spaces in your type signatures. like `add :: a -> a -> a', e.g.
23:30:26 <ski> and `eval :: ExprT -> Integer'
23:31:10 <ski> catchmrbharath : anyway, presumably you should write something like `mul (MkMod7 x) (MkMod7 y) = MkMod7 (..x..y..)', and similarly for the `div' case
23:31:18 <catchmrbharath> ski: Will do that.
23:31:54 <Eliel> How complex is the simplest possible haskell compiler or interpreter? Assuming you just need to compile/interpret a very basic subset of the language.
23:31:58 <ski> catchmrbharath : if you write  mul x y = (x * y) `mod` 7  , then `x' and `y' won't be integers here, but instead of type `Mod7', which you haven't defined `(*)', nor `mod', on
23:32:24 <L8D> Eliel: Interpreter or compiler?
23:32:36 <Eliel> L8D: whichever is simpler, really.
23:32:38 <ski> catchmrbharath : in the definition of `lit' for `Expr Mod7', you don't need the outer brackets around the body
23:32:50 <L8D> an interpreter is not that hard to build, in haskell
23:32:53 <ski> catchmrbharath : nor do you need it in `Expr MinMax'
23:33:23 <L8D> Eliel: You can even use Haskell's syntax parser thingy
23:33:30 <ski> catchmrbharath : and you can write `eval (Add x y) = eval x + eval y' and similarly for the `Mul' case of `eval'
23:33:36 <L8D> And then use the AST to interpret from inside of Haskell
23:34:26 <ski> catchmrbharath : i'd prefer writing `Just (eval ex)' to `Just $ eval ex' -- i see no reason to use `$' here
23:34:36 <Eliel> L8D: ok, but that depends on whatever haskell compiler I use to compile the interpreter with, right?
23:35:09 <L8D> Eliel: No. You can use GHC's syntax parser from inside Haskell as a library.
23:35:26 <L8D> Eliel: Which will allow you to write Haskell code that can interpret the AST
23:35:31 <catchmrbharath> ski: Thanks for the review. I will fix those.
23:35:54 <L8D> Eliel: Otherwise you'll need to write a syntax parser yourself which may or may not be cumbersome
23:36:06 <ski> catchmrbharath : in `Expr Bool', you're testing on a `Bool' (in a guard), and then immediately return a `Bool' -- this is a roundabout way to do things, since you negate the condition guard `x <= 0', either just return `not (x <= 0)' or return `x > 0'
23:36:49 <Eliel> L8D: how complex is GHC's syntax parser library then?
23:37:14 <ski> catchmrbharath : if you want to, you *could* define like `add = (||)' (and similarly for the `mul' case). if you wanted to, you also could say `lit = not . (<= 0)' or `lit = (> 0)'
23:38:42 <catchmrbharath> ski: Yup. That's better.
23:39:26 <ski> catchmrbharath : only do these last suggestions if you understand them, and think they look neater or clearer than the alternative
23:39:38 <catchmrbharath> ski: So when I make a newtype, all the operator functions are inherited for the newtype right?
23:39:49 <ski> the point is to write the code so that it's as readable as possible to *you*
23:39:56 <L8D> Eliel: go read the source code for ghci
23:39:57 <ski> catchmrbharath : nope
23:40:05 <opqdonut> catchmrbharath: no, a newtype is a new type, with no instances
23:40:11 <ski> no functions are inherited for a `newtype'
23:40:36 <opqdonut> catchmrbharath: newtype exists precisely so that you could reimplement some type classes for a type
23:40:50 <catchmrbharath> So when I do a   mul (MkMod7 x) (MkMod7 y) = (x * y) `mod` 7, do I need to redefine `*`?
23:41:16 <opqdonut> no, because the arguments to * are the ints inside the Mod7
23:41:20 <ski> `x' and `y' are `Integer's here, and so is their combination with `*',`mod',`7'
23:41:52 <ski> so, you need to wrap the result with the data constructor for `Mod7', to get back a value of that type again, as expected by the type signature for `mul'
23:41:58 <catchmrbharath> ski:   So when I do a mul (MkMod7 x) (MkMod7 y) = (x * y) `mod` 7, do I need to redefine `*`?
23:42:03 <ski> no
23:42:23 <catchmrbharath> ski: Got it.
23:42:44 <ski> you unwrap the arguments, to get `Integer's. then you compute a new `Integer'
23:42:58 <ski> finally you need to *rewrap* that `Integer' back into `Mod7'
23:43:20 <ski> this is because the type signature for `mul', for `Expr a' is
23:43:23 <ski>   mul :: a -> a -> a
23:43:33 <ski> so, for your current `Expr Mod7', it becomes
23:43:43 <ski>   mul :: Mod7 -> Mod7 -> Mod7
23:44:01 <ski> so, arguments will be `Mod7's, hence you need to unwrap those to get `Integer's
23:44:23 <ski> and, the result is expected to be a `Mod7', hence you need to wrap your `Integer' result
23:44:27 <ski> catchmrbharath : ok ?
23:44:50 <catchmrbharath> ski: Ah got it. Fixed it. Thanks so much!!!
23:44:54 <ski> np
23:45:56 <catchmrbharath> ski: Thanks. I will definitely come back for reviews again for the next few problems :).
23:46:17 * ski wanders off
23:46:34 * hackagebot redis-resp 0.3 - REdis Serialization Protocol (RESP) implementation.  http://hackage.haskell.org/package/redis-resp-0.3 (ToralfWittner)
23:46:37 * hackagebot redis-io 0.3 - Yet another redis client.  http://hackage.haskell.org/package/redis-io-0.3 (ToralfWittner)
23:53:05 <mr-> 08:41 < ski> so, you need to wrap the result with the data constructor for `Mod7', to get back a value of that type again, as expected by the type
23:53:13 <mr-> oops, sorry.
