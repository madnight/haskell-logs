00:00:09 <jle`> type State a = StateT Identity a  ... State is a function that takes an `a` and returns (StateT Identity a)
00:00:12 <zRecursive> System/Process/Internals.hs:283:30: Not in scope: ‘unsafePerformIO’\ncabal: Error: some packages failed to install:   \nprocess-1.1.0.2 failed during the building phase. The exception was: ExitFailure 1,  it is ghc-7.8.x now
00:00:13 <merijn> But the paper is a more in depth introduction
00:00:22 <adas> merijn: yes they are statically checked at compile time to ensure they type check and produce valid types.. so .. although a function to create the type exists.. the type itself does not exist at compile time.. is that correct?
00:00:27 <jle`> foo x = blah blah x
00:00:44 <merijn> adas: Sure it does, how else would it type check?
00:00:46 <netroby> Why you guys love haskell
00:01:15 <jle`> because it loves me :3
00:01:31 <adas> merijn: so what problem does type families solve?
00:01:33 <merijn> jle`++
00:01:54 <merijn> adas: Well, you can write function/types that you couldn't otherwise
00:02:32 <merijn> adas: For example, my first paste defines a function that is "identity for everything EXCEPT () and Int:
00:02:50 <merijn> adas: i.e. "foo 'c'" -> 'c' "foo ()" -> type error
00:03:24 <merijn> adas: You can't implement that function without type families, because there's no way to write "any type EXCEPT x"
00:05:23 <merijn> adas: Type families let you describe more possible types, therefore you can typecheck more possible functions
00:06:48 <jle`> is ("Error" ~ "Message") an error in that GHC tries to unify "Error" with "Message"? >_>
00:07:06 <merijn> jle`: Yeah
00:07:10 <jle`> that's cute
00:07:29 <jle`> is that the typical way to do this?
00:07:35 <merijn> jle`: ~ is type equality/unification and since "Error" and "Message" don't unify, you'll get a "constraint doesn't hold" error
00:07:50 <merijn> "Error" and "constraint" being types of kind Symbol from DataKinds
00:07:52 <jle`> yeah, i see that, heh.
00:08:04 <jle`> but it looks like a bit of a hacky way to represent an error
00:08:11 <jle`> or to "throw" an error
00:08:27 <merijn> jle`: I proposed an explicit way of implementing an error on the GHC mailing list before, but it wasn't a very popular idea
00:08:56 <merijn> I think people were worried about it being too hard to implement
00:08:59 <L8D> wtf
00:09:07 <L8D> how do I use 1.20.0.3
00:09:18 <merijn> jle`: The biggest problem with Restrict is that it's wonky in the presence of typeclass polymorphism
00:09:43 <merijn> jle`: i.e. when you write "foo 1" without "foo (1 :: Int)" GHC complains because it can't prove that '1' is not Int
00:09:49 <jle`> interesitng
00:10:01 <jle`> well, () has a "lawful" Num instance
00:10:20 <jle`> couldn't you do foo 1 :: Int ?
00:10:30 <jle`> or use the result of foo 1 somewhere?
00:10:55 <merijn> jle`: I don't remember whether that was good enough
00:12:50 <AshyIsMe> ooh there's a new haskell platform
00:13:29 <shachaf> Why are Haskell platform releases important to people?
00:14:08 <merijn> shachaf: Because it's so nice and convenient on OSX? :)
00:14:23 <merijn> and windows
00:14:37 <shachaf> It would be nice if there was something nice and convenient that was just GHC + cabal-install.
00:15:06 <merijn> shachaf: Isn't that just "download GHC binaries + download cabal binaries"?
00:15:48 <Haskellfant> merijn: are there cabal binaries outside of distributions? I thought you were supposed to run the bootstrap script which compiles it
00:15:55 <shachaf> OK, so why do people care about the Haskell platform?
00:16:05 <kess> when on earth is haskell going to get a good package manager anyway
00:16:09 <merijn> I thought the plan was to distribute cabal binaries since a month ago or so
00:16:37 <merijn> kess: It has a good dependency tracker/installer already, people just keep using crappy and/or overcomplicated libraries
00:17:04 <merijn> People who complain about cabal have clearly never used any build tools for other languages...
00:17:12 <Haskellfant> merijn: haven't seen them when I needet to get centos + up2date ghc + cabal, but I haven't looked very hard
00:17:16 <vanila> yeah cabal is an absolute nightmare to use
00:17:40 <merijn> Except the people who go like "node.js is much better!" but they gloss over the fact that node.js package management is just "keep a local copy of the source of all of your dependencies"
00:17:41 <kess> cabal is not a package manager
00:18:12 <AshyIsMe> merijn: isnt that what cabal sandboxes does anyway?
00:18:36 <merijn> AshyIsMe: Yes, which is why I don't think "sandbox everything, always" is particularly healthy either
00:19:12 <Haskellfant> sandbox everything is the only thing that keeps me from messing up ~/.ghc
00:20:02 <tdammers> merijn: for javascript, that actually makes sense - after all, the source *is* the product
00:20:30 <tdammers> besides, gem and pip do the same
00:20:33 <AshyIsMe> recompiling the whole world does suck a bit
00:20:59 <AshyIsMe> the benefit is codex can generate tags for almost everything you reference in your project
00:21:18 <AshyIsMe> which is nice for inspecting library code directly in vim (or in emacs too i assume)
00:21:38 <vanila> What would be nice for normal users is a way to install libraries by just using one command
00:22:19 <vanila> like if I want to use whatever-lib, it would be cool to just "haskell install whatever-lib" and I get it, no UTF-8 bugs or weird errors about dependencies or reinstalling the universe
00:22:57 <merijn> vanila: And how do you expect cabal to solve "you're trying to install some obscure library that's been unmaintained for 3 years" for you?
00:23:23 <merijn> Because the cabal problems I see people have here fall generally into two categories 1) installing obscure unmaintained junk and 2) yesod
00:24:27 <AshyIsMe> or obscure unmaintained really cool projects like mueval
00:24:29 <AshyIsMe> haha
00:24:37 <vanila> merijn, those are good points! Regarding (1) we need some better quality control on hackage, removing junk/old stuff. On (2).. not sure maybe the yesod people should fix up their stuff or it be taken off hackage
00:25:04 <vanila> when I search on hackage today I get like 3 pages ofstuff and it's so hard to find out what libs are good
00:25:15 <vanila> in the past, I'd search and thre was only the things I need
00:25:27 <merijn> Hackage has some upcoming stuff like user ratings, AFAIK
00:25:36 <merijn> Usually the number of downloads is a good indicator
00:25:47 <merijn> If it has less than like 5000, it's probably not that great
00:26:30 <merijn> Also checking http://packdeps.haskellers.com/reverse can help
00:27:35 <AshyIsMe> wow there's a lot of red here: http://packdeps.haskellers.com/reverse/aeson
00:27:49 <mroman_> The biggest problem for me is that certain packages want Bytestring x.y.2
00:27:56 <mroman_> and other packages want Bytestring x.y.1
00:27:57 <vanila> What does the red mean?
00:28:03 <mroman_> so I'd have to downgrade Bytestring
00:28:31 <AshyIsMe> vanila: it means that there's newer versions available and that package is limited to older ones only: http://packdeps.haskellers.com/
00:29:12 <tdammers> mroman_: in extreme cases, I have checked out the offending packages locally before, changed their dependencie in the .cabal file, and installed from the local version into my sandbox
00:29:27 <tdammers> mroman_: that doesn't help if you want to publish your own work though, obviously
00:30:47 <merijn> tdammers: I do that + pull request the fix, so I can keep working until the dependencies update
00:32:21 <AshyIsMe> merijn: hackage should link to this packdeps page from each package
00:32:22 * tdammers nods
00:32:53 <AshyIsMe> who's in charge of hackage? can we get them to add that?
00:35:54 <doismellburning> AshyIsMe: looks like a PR to https://github.com/haskell/hackage-server/blob/c95de2cdc85df134c70ea3da68bb1f521d8727d3/Distribution/Server/Pages/Package.hs
00:36:53 <doismellburning> :t (</>)
00:36:54 <lambdabot>     Not in scope: ‘</>’
00:36:54 <lambdabot>     Perhaps you meant one of these:
00:36:54 <lambdabot>       ‘<*>’ (imported from Control.Applicative),
00:37:59 <AshyIsMe> doismellburning: the module forest bit?
00:41:51 <merijn> AshyIsMe: Go to #hackage
00:42:01 <merijn> AshyIsMe: The source is on github and open to pull requests :)
00:42:26 <AshyIsMe> yeah ive just been looking for where it should go, heh
00:42:54 <merijn> AshyIsMe: dcoutts is here and in #hackage and open to answer questions when he's not to busy :)
00:43:09 <doismellburning> AshyIsMe: I have no strong opinions as to where would be a sensible location
00:47:26 <jle`> @hoogle (</>)
00:47:28 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
00:47:28 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
00:47:35 <jle`> doismellburning ^
00:48:46 <AshyIsMe> doismellburning: merijn: i was thinking something as simple as this: http://i.imgur.com/G6r1pz7.png
00:49:10 <AshyIsMe> although i've just noticed that the packdeps site doesnt seem to be tracking all packages
00:49:40 <L8D> is there a way to force an install of haskell-platform on mac?
00:51:41 <doismellburning> jle`: ah cheers (I'd just given up and gone to the s.p.p docs!)
01:11:40 <Fuuzetsu> AshyIsMe: I doubt whole link is necessary, a small button/link would do
01:12:08 <L8D> Fuuzetsu: ...?
01:12:19 <Fuuzetsu> messing with my network, making sure I'm still on
01:23:00 <AshyIsMe> Fuuzetsu: im talking to the guys in #hackage, hackage already has reverse dependency functionality
01:23:13 <AshyIsMe> it's just turned off for performance reasons at the moment
01:23:25 <AshyIsMe> and it's low enough priority that they havent got around to it yet
01:27:14 <Fuuzetsu> AshyIsMe: sure, just saying that iff we're adding a link to the usual reverse dep place, it's spurious to show it all, a small button would do great
01:44:22 <haasn> I love Haskell. You always just focus on doing the “ease bits”​ one by one and eventually they all just fall together to solve the problem you thought was hard initially
01:44:30 <haasn> easy*
01:45:28 <tdammers> either that, or things remain difficult, which is a sign that the solution is either wrong or over-engineered
01:46:04 <haasn> My favorite bit is when you think the function is going to be really complicated but then you realize it's just a composition of like 3 other things you've already written
01:46:18 <tdammers> also, this isn't really a haskell thing - it's just a problem solving strategy that works well, and haskellers are religious about applying it all the time
01:46:24 <haasn> I guess so
01:46:34 <tdammers> the language does reflect the attitude though
01:46:44 <haasn> Haskell makes it easy to abstract out useful components and patterns and re-use them in different places
01:46:48 <doismellburning> haasn: I love meeting in the middle with Haskell
01:47:14 <doismellburning> haasn: like, "here are some easy bits from the bottom, here's my top level function, smoosh"
01:48:27 <jle`> i programmed my IDE to play that smoosh sound when i meet in the middle
01:48:34 <doismellburning> :P
01:49:09 <EnglishGent> Hi all :)
01:49:25 <jle`> top of the mornin
01:49:29 <jle`> (is that irish)
01:49:34 <EnglishGent> hi jle` :)
01:49:39 <EnglishGent> I believe so!
01:49:43 <jle`> hm
01:49:50 <jle`> elo govnah
01:49:59 <EnglishGent> but - I'm only going from popular fiction...
01:50:00 <EnglishGent> :)
01:50:13 <doismellburning> jle`: I tend to prefer the more forthright "oi oi saveloy", but y'know
01:50:45 <EnglishGent> a Haskell question! I know when defining an algebraic data type that every type variable that appears in a constructor must appear on the left of the data type definition
01:50:47 <EnglishGent> i.e.
01:50:59 <EnglishGent> data Either x y = Left x | Right y
01:51:01 <EnglishGent> *not*
01:51:21 <EnglishGent> data Either x = Left x | Right y -- compiler will complain that y does not appear on the left side of the definition
01:51:49 <EnglishGent> but I recently noted that the converse does not apply - a type can be defined containing a type variable that is not used by *any* constructor
01:52:06 <EnglishGent> e.g. data WTree x = Nil | Branch [WTree x]
01:52:16 <EnglishGent> which compiles just fine & does so without warnings
01:52:24 <EnglishGent> is there a sensible reason for allowing this?
01:52:28 <shachaf> Yes.
01:52:34 <EnglishGent> (sorry for long question!) :)
01:52:36 <shachaf> It's called a "phantom type". You can read about it.
01:52:49 <shachaf> @google phantom types
01:52:50 <lambdabot> http://www.haskell.org/haskellwiki/Phantom_type
01:52:50 <lambdabot> Title: Phantom type - HaskellWiki
01:53:15 <EnglishGent> okay - I'll have a look & thanks :)
01:54:24 <EnglishGent> also - a 2nd (related) question - I note that Haskell _can_ derive a functor instance for WTree
01:54:32 <EnglishGent> is there any way to ask it what it derived?
01:54:47 <EnglishGent> because I can't seem to figure out one by hand that the compiler is happy with
01:54:58 <haasn> There's a flag you can pass to GHC, something like -ddump-derived-instances
01:55:10 <haasn> But you should probably figure out how to derive your own Functor instances by hand
01:55:10 <EnglishGent> (how can I apply the function from fmap? there's nothing to apply it to!)
01:55:28 <jle`> EnglishGent: well.  as long as it follows the laws, it's a lawful instance
01:55:33 <EnglishGent> oh - and thanks everyone :)
01:55:37 <jle`> maybe start with an easier case
01:55:38 <haasn> EnglishGent: Think about what happens when you evaluate “map f []”
01:55:57 <jle`> ^^ that's a good one.  what's the type of [] before, and the type of the result?
01:56:29 <jle`> data Phatom x = Phantom
01:56:32 <EnglishGent> [] : forall a. [a] ? (guessing)
01:56:42 <haasn> Yes.
01:56:42 <jle`> thank about the type of the `Phantom` constructor
01:56:53 <jle`> and then the instance should flow from that :)
01:57:38 <jle`> instance Functor Phantom where fmap f p0 = _
01:57:54 * EnglishGent has been poking at Haskell out of personal interest for a while now - but there seems to be an endless array of tricks & language extensions
01:57:54 <jle`> if f :: a -> b, and p0 :: Phantom a...then what has to go in the hole?
01:58:04 <EnglishGent> it's not easy to get beyond beginner level from self-study :|
01:58:14 <jle`> what is the type that the hole is expecting?
01:58:18 <jle`> :t fmap
01:58:19 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:59:45 <EnglishGent> I think I need to read the phantom type article ... I can see how to define fmap for constructors that don't have a type variable (e.g. Nothing in Maybe)
02:00:01 <jle`> this quesiton is a simply one :)
02:00:13 <jle`> fmap :: (a -> b) -> Phantom a -> Phantom b ... right?
02:00:19 <EnglishGent> right
02:00:31 <jle`> so if you give me an (a -> b) and a Phantom a...i'll have to give you a Phantom b, right?
02:00:35 <EnglishGent> b _has_ to be a phantom - it's never uses
02:00:37 <EnglishGent> used*
02:00:38 <jle`> ...where can i get a Phantom b, right?
02:00:42 <jle`> er
02:00:46 <jle`> ...where can i get a Phantom b?
02:00:57 <EnglishGent> please bear in mind, I don't know about Phantom types yet! :)
02:01:15 <jle`> this is just a normal type
02:01:17 <jle`> i defined it earlier
02:01:20 <jle`> let's use less scary names
02:01:30 <jle`> data Kitten a = Flower
02:01:38 <haasn> EnglishGent: What is the type of Nothing?
02:01:38 <EnglishGent> lol! fine :)
02:01:53 <EnglishGent> Nothing : forall a . Maybe a
02:02:01 <haasn> What is the type of Flower?
02:02:09 <jle`> so if i give you an (a -> b) and a Kitten a...you need to give me back a Kitten b
02:02:13 <jle`> how do you construct a Kitten b?
02:02:22 <EnglishGent> by analogy - Flower : forall a. Kitten a
02:02:36 <EnglishGent> just Flower?
02:02:44 <jle`> does Flower type check?
02:03:11 <jle`> flower can unify with :: Kitten b
02:03:16 <jle`> so...it looks like it does
02:03:21 <haasn> (data Kitten a = Flower is the same as data Maybe a = Nothing up to renaming)
02:03:21 <EnglishGent> dunno - don't have access to a running interpreter at the moment - but would expect it to
02:03:34 <jle`> fmap f _ = Flower
02:03:39 <jle`> now...it typechecks
02:03:41 <haasn> (data Maybe a = Nothing | Just a  is the same as data Maybe a = Nothing except with one more constructor)
02:03:43 <jle`> ...does it follow the laws?
02:03:58 <jle`> does fmap id = id?
02:04:04 <EnglishGent> yes
02:04:17 <jle`> fmap id Flower = Flower = id Flower
02:04:34 <jle`> does fmap f . fmap g = fmap (f . g)
02:04:42 <EnglishGent> it has to - there's no choice!
02:04:49 <jle`> fmap f (fmap g Flower) = fmap f Flower = Flower
02:04:55 <jle`> fmap (f . g) Flower = Flower
02:04:57 <jle`> looks like they do
02:05:09 <jle`> so...you might have heard that all functor instances --- if they exist --- are unique
02:05:19 <jle`> so if this is a valid functor instance, then it is the *only* valid functor instance
02:05:32 <EnglishGent> actually that I *hadn't* heard -- but that sounds like an important property
02:06:10 <EnglishGent> do you mean that if something is an instance of functor then there can only be one (upto mathematical equality) definition of fmap for it, such that the definition follows the laws?
02:06:38 <haasn> Yes
02:06:54 * EnglishGent is a humble Java / C# programmer (& fan of Lisp) trying to teach himself Haskell & related math :)
02:07:25 <Qfwfq> EnglishGent: You're the AI guy!
02:07:42 <EnglishGent> that's right Qfwfq! :)
02:07:49 * EnglishGent pleasantly surprised anyone remembers :)
02:08:47 <haasn> Whoa, AIs have gone up significantly in quality since the last time I tried chatting with one
02:09:16 <EnglishGent> :P
02:09:17 <EnglishGent> :)
02:10:26 * EnglishGent is quite happy talking AI / machine learning / etc with anyone who is interested...
02:10:54 <EnglishGent> Haskell is something I hope I am not *that* bad at - but am still trying to wrap my head around it's more esoteric corners
02:12:49 <EnglishGent> and hmm -that (uniqueness) sounds a *very* important property
02:12:56 <EnglishGent> does that apply for any other type classes?
02:13:09 <frankdreban> Is it a lack of natural isos?
02:13:34 * EnglishGent has been interested for a while in the fact that if I give people the type signature of a simple function
02:13:39 <EnglishGent> e.g. foo : [a] -> [a]
02:13:48 <EnglishGent> there are only a few definitions that they are likely to think up
02:13:53 <aleator__> Hi. What's the difference between generative recursion (as talked about by the racket guys) and co-recursion?
02:13:59 <EnglishGent> in spite of the fact that there is an infinite number of them
02:14:01 <vanila> EnglishGent, there's this cool thing called parametricity
02:14:04 <Qfwfq> (Parametricity.)
02:14:23 <EnglishGent> some functions feel much more 'natural' somehow - though I have never been able to formalise that notion
02:14:24 <vanila> when a function is polymorphic it tells you a lot about what it must be
02:14:36 <Qfwfq> EnglishGent: Try 'Theorems for Free'.
02:14:38 <frankdreban> Parametricity factors out the natural isomorphisms, then?
02:14:38 <EnglishGent> vanila - interesting! got a link
02:14:40 <EnglishGent> thank you :)
02:15:15 <jle`> @free foo :: [a] -> [a]
02:15:15 <lambdabot> $map f . foo = foo . $map f
02:15:29 <jle`> EnglishGent: you can tell from the type signature alone that map f . foo = foo . map f
02:15:37 <jle`> we call it a free theorem
02:16:20 <shachaf> Parametricity will only take you so far.
02:16:22 <frankdreban> I know math but that's about it, lol
02:16:48 <shachaf> f [] = []; f (x:xs) = reverse xs is still a perfectly valid function.
02:17:04 <haasn> The fundamental thing here is that since ​foo is polymorphic in the variable ‘a’, there's nothing it can do to the values of type ‘a’
02:17:06 <jle`> :t cycle
02:17:07 <lambdabot> [a] -> [a]
02:17:12 <haasn> So it doesn't matter if you transform ‘a’ to ‘b’ before, or after the operation
02:18:04 <haasn> It's an important consequence of what it means to write a polymorphic function in Haskell - what do you *know* about a type? What can you do with it?
02:18:05 <frankdreban> Oh right, so basically it is natural
02:18:16 <EnglishGent> right - I get that, given that I don't know what 'a' is & that Haskell has no equivalent of Object - I can't *do* anything to an 'a' other than apply 'id' to it
02:18:16 <shachaf> What parametricity means is that a function with a type like yours can only transform the structure of a list somehow. It can't do anything with individual elements other than treat them as black boxes.
02:18:27 <EnglishGent> but I can think of several 'obvious' functions [a] -> [a]
02:18:40 <EnglishGent> id, reverse, rotate left, rotate right
02:18:45 <shachaf> But I don't think that's the question EnglishGent was asking -- people are just pattern-matching and answering the question they know.
02:18:48 <haasn> const []
02:19:13 <EnglishGent> but those are only a tiny fraction of the possibilities -- checking if the list is of a prime length & returning it if it is & an empty list if it is not
02:19:15 <jle`> EnglishGent: can you possibly make any statements about invariants?  things that all implementations must enforce?
02:19:19 <vanila> various permutations, duplication, deletion..
02:19:20 <EnglishGent> is *also* of type [a] -> [a]
02:19:28 <EnglishGent> but that feels distinctly unnatural
02:20:47 <EnglishGent> (a random tangential question - why isn't 'last' defined as 'drop 1' ? it removes the annoying corner case of an error when trying to do it to an empty list)
02:20:57 <jle`> historic purposes i think
02:21:13 <jle`> on what `last` is supposed to represent
02:21:18 <tdammers> [a] -> a is problematic :x
02:21:20 <shachaf> Maybe you mean tail.
02:21:29 <EnglishGent> I do - tail, sorry
02:21:32 <jle`> oh, yeah, i was talking about tail >_>
02:21:35 <tdammers> hehe
02:21:48 * EnglishGent is drinking his morining coffee... please excuse my presently under-caffinated state :)
02:21:48 <shachaf> There's a question of whether you should fail silently or fail loudly with an error message.
02:22:06 <Jookia> Could someone clarify what it means to compose two functors?
02:22:09 <tdammers> in this case, neither :D
02:22:27 <shachaf> tail fails loudly with an error.
02:22:43 <vanila> Jookia, If you define  newtype Compose f g x = Compose { unCompose :: f (g x) }
02:22:49 <jle`> Either e (Maybe a) can be said to be the composition of (Either e) and Maybe
02:22:55 <EnglishGent> I agree shachaf - but in that case I'd like to see the distinction represented in a more regular fashion (e.g. a variant of zip that whines if the two lists are not of equal length, etc)
02:22:58 <jle`> "apply Maybe, then apply Either e to the result"
02:23:06 <vanila> Jookia, then try ot implement  instance (Functor f, Functor g) => Functor (Compose f g)
02:23:22 <jle`> it's the same as function composition
02:23:27 <shachaf> EnglishGent: tail isn't a great function to use. safeTail :: [a] -> Maybe [a] might be better because it's at least injective.
02:23:47 <jle`> f (g x) can be said to be the application of the composition of f and g
02:24:15 <jle`> so (Compose (Either e) Maybe) a is like (f . g) ... is like (Either e . Maybe)
02:24:18 <jle`> er, without the a
02:24:28 <Jookia> hmm, i shall go work this out
02:24:31 <jle`> (Either e) `Compose` Maybe
02:24:32 <jle`> f . g
02:24:41 <EnglishGent> I try to avoid it theses days shachaf - I didn't know about safetail, but I try to use 'drop 1' if that's what I actually mean - or wrap uses of it inside an if-block where I have tested to see if the list is empty
02:24:46 <jle`> (Either e `Compose` Maybe) a     is like ... (f . g) x
02:25:01 <shachaf> There's no such safeTail in the standard library. I'm only saying it might be better.
02:25:33 <EnglishGent> (btw - null is an *awful* name for a function that checks to see if a list is empty
02:25:35 <EnglishGent> )
02:26:19 <shachaf> It's not that bad.
02:26:21 <haasn> A rasonable approximation for safeTail is drop 1
02:26:24 <shachaf> The name, I mean. The function isn't that great.
02:26:26 <ph88> someone experience here with threepenny ?
02:26:31 <jle`> drop 1 is not injective tho
02:26:31 <haasn> > drop 1 []
02:26:33 <lambdabot>  []
02:26:41 <doismellburning> shachaf: why is the function not that great?
02:26:50 <EnglishGent> who on earth came up with that? It's annoying for people with a Lisp background (it's one letter out from 'nil') *and* it conflicts with it's meaning in C/C++/Java/C#
02:26:53 <shachaf> Because booleans aren't that great.
02:27:03 <jle`> i think [a] -> Maybe [a] is a reasonable safeTail that follows in the spirit of the original tail function
02:27:10 <jle`> from back in the lispy days
02:27:17 <haasn> doismellburning: Because pattern matching for [] is usually easier than applying “null” and looking at the Bool that comes out
02:27:18 <jle`> those were the good ol days
02:27:24 <doismellburning> haasn: fair
02:27:28 <EnglishGent> I think what's more important would be 'safeHead'
02:27:32 <haasn> And most of the time, you want to do something in the case where [] *isn't* empty, as well
02:27:35 <jle`> luckily we already have safeHead
02:27:38 <shachaf> Scheme has 'null?
02:27:46 <EnglishGent> you can always throw away an element of a list - always invoke drop
02:27:54 <vanila> EnglishGent, in scheme NULL? is the same as null
02:27:58 <EnglishGent> you *can't* always invoke head
02:28:10 <jle`> safeHead is in base...but under a different name
02:28:15 <EnglishGent> it has the question mark at the end indicating it's a predicate though!
02:28:38 <jle`> hm.  yeah, it has been said that the quality of your code is measured in how many bools you use per line
02:28:47 <EnglishGent> (actually I'd like to see a distinction in the type system between lists that might be empty & lists that *cannot* be empty)
02:29:00 <EnglishGent> I find myself approximating a non-empty list of a as (a, [a])
02:29:09 <jle`> haskell is one of those languages where we have a lot of the ability to avoid bools in cases where bools are traditionally used in other languages
02:29:11 <EnglishGent> which works, but is ugly
02:29:17 <jle`> EnglishGent: a (a, [a]) wrapper is in the containers library
02:29:19 <Qfwfq> semigroups defines NonEmpty
02:29:19 <jle`> er
02:29:22 <jle`> semigroups
02:29:41 <jle`> semigroups defines a (a, [a]) type...and reasonable operations on it
02:29:55 <EnglishGent> ah! another thing I did not know about!
02:30:00 <EnglishGent> linky? :)
02:30:05 <jle`> @hackage semigroups
02:30:05 <lambdabot> http://hackage.haskell.org/package/semigroups
02:30:10 <EnglishGent> thanks :)
02:31:18 <Qfwfq> (:|) being naturally isomorphic to (,) :P
02:31:38 <Qfwfq> Sorry, no, constraints.
02:32:22 <Qfwfq> :( :( :(
02:35:32 <ph88> hey guys .. i try to run example  http://code.haskell.org/plot/examples/Test4.hs  but i get error:  Could not find module `Graphics.UI.Gtk'    what can i do about this ?
02:36:36 <Qfwfq> ph88: That module is provided by the 'gtk' package, apparently.
02:36:54 <ph88> Qfwfq: how can i check if i have this package installed ?
02:37:06 <Qfwfq> 'ghc-pkg list | grep gtk'?
02:37:23 <ph88> nothing shows up
02:37:24 <jle`> hm
02:37:35 <Qfwfq> ph88: 'cabal install gtk'?
02:37:37 <jle`> can i enumerate all possible (Bool -> Bool)s
02:37:38 <ph88> i thought it installed as one of the dependencies of plot
02:37:47 <jle`> table :: [Bool -> Bool]
02:38:15 <Qfwfq> @hackage plot
02:38:15 <lambdabot> http://hackage.haskell.org/package/plot
02:38:28 <Qfwfq> Doesn't list it as a dependency.
02:38:59 <jle`> hm
02:39:24 <Qfwfq> :t [uncurry (x,y) | x <- [True, False], y <- [True, False]]
02:39:25 <lambdabot>     Couldn't match expected type ‘a -> b -> c’
02:39:25 <lambdabot>                 with actual type ‘(Bool, Bool)’
02:39:25 <lambdabot>     In the first argument of ‘uncurry’, namely ‘(x, y)’
02:39:34 <Qfwfq> :t [curry (x,y) | x <- [True, False], y <- [True, False]]
02:39:35 <lambdabot>     Couldn't match expected type ‘(a, b) -> c’
02:39:35 <lambdabot>                 with actual type ‘(Bool, Bool)’
02:39:35 <lambdabot>     In the first argument of ‘curry’, namely ‘(x, y)’
02:39:52 <Qfwfq> How do I program
02:40:19 <Qfwfq> :t [(\x -> y) | x <- [True, False], y <- [True, False]]
02:40:20 <lambdabot> [t -> Bool]
02:40:36 <jle`> that's just shadowing x
02:40:36 <Qfwfq> No no no
02:40:37 <ph88> Qfwfq: i get this error while installing gtk .. do you know what i can do about this?  http://pastebin.com/sjahyyxQ
02:40:51 <Qfwfq> I should sleep.
02:41:24 <EnglishGent> pleasant dreams Qfwfq :)
02:41:28 <jle`> :t liftA2 bool [True, False] [True, False]
02:41:29 <lambdabot> [Bool -> Bool]
02:42:06 <Qfwfq> ph88: One of the dependent packages has incorrect bounds on its dependencies, I think.
02:42:08 <Qfwfq> bai
02:42:17 <jle`> > let allBB = liftA2 bool [True,False] [True,False] in [f x | f <- allBB, x <- [True, False]]
02:42:19 <lambdabot>  [True,True,False,True,True,False,False,False]
02:42:37 <jle`> i think that's all of them
02:43:55 <ph88> anyone an idea what i can do about this error?  http://pastebin.com/sjahyyxQ
02:44:08 <ph88> i dont know what incorrect bound on dependency is ^^
02:46:57 <Maerten> Hi, does anyone know how to speed up yesod-dev ? Whenever I save a hamlet file it automatically recompiles and restarts the app, which is nice, but it takes about 5-10 seconds on my 2012 mbp
02:48:09 <hc> Isn't the hamlet file compiled into the app?
02:50:29 <eevar_> considered giving the other web frameworks a shot?
02:53:07 <ph88> guys i'm sure i installed   Cabal-1.20.0.2    but when i type   cabal --version  i see:   cabal-install version 1.16.0.2
02:53:12 <ph88> how do i activate the newer version ?
02:53:58 * hackagebot yesod-core 1.4.0.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.4.0.1 (MichaelSnoyman)
02:53:59 <ph88> my new version is in ~/.cabal/bin/cabal
02:54:28 <Maerten> hc: yes they are compiled in to the app i think, however i don't understand why a change in one file has to result in a full recompile
02:54:35 <ph88> i added this directory to my path as first entry to $PATH  but it's not working o_O
02:55:02 <Maerten> eevar_: no but as i'm a beginner yesod is quite convenient because most stuff has been already done for me i think
02:58:59 * hackagebot generic-aeson 0.2.0.1 - Derivation of Aeson instances using GHC generics.  http://hackage.haskell.org/package/generic-aeson-0.2.0.1 (AdamBergmark)
02:59:00 * hackagebot ekg-core 0.1.0.2 - Tracking of system metrics  http://hackage.haskell.org/package/ekg-core-0.1.0.2 (JohanTibell)
03:00:29 <ph88> Maerten: what are you makiing with yesod ?
03:00:52 <Kneiva> ph88: you reloaded .bash_profile (or equivalent) or restarted your shell?
03:01:14 <Maerten> ph88: just a simple website where you can register as a user and post some articles, it's just a project to get to know yesod
03:01:48 <Maerten> ph88: anyway because it's so simple (only 3 tables with Database.Persist) and only a few routes (like 3 or 4) I would expect it all to go a little faster...
03:02:01 <sgronblo> Does anyone know what happened to Yesods IForm? Mentioned in the book but seems to be impossible to find in reality.
03:02:16 <Maerten> i mean, i expected development to go faster, instead of having to wait so long on filesave, before i'm able to refresh
03:02:25 <sgronblo> ph88: yeah thats likely a path problem
03:03:03 <sgronblo> you gotta set the PATH correctly and possibly hash -r to rehash the binary lookup cache (or whatever its called)
03:03:27 <tdammers> Maerten: yesod is pretty big, you won't get the fast save-reload-check development cycles like you would with a dynamic language
03:03:55 <tdammers> also, I think yesod really only pays off for larger, more complex projects
03:05:02 <ph88> Kneiva sgronblo http://pastebin.com/KW1fPuLq  i use zsh  and i dont know about rehash binary lookup ... but i did restart my pc and terminal
03:05:53 <ph88> Maerten: which other serverside languages did you use for webdevelopment ?
03:06:25 <Maerten> tdammers: isn't there a way to get yesod to do fast save and reload? maybe disabling some features or not recompiling the full app..
03:06:25 <Kneiva> ph88: and what path does 'which cabal' give?
03:06:43 <Maerten> ph88: php and symfony2 for my job
03:06:51 <ph88>  /usr/bin/cabal
03:07:04 <ph88> Maerten: nice i use that too :)
03:07:20 <sgronblo> ph88: plain ghc or haskell platform?
03:07:26 <ph88> Kneiva: /usr/bin/cabal
03:07:33 <ph88> sgronblo: haskell-platform
03:07:45 <sgronblo> os?
03:08:07 <ph88> sgronblo: ubuntu 14.04
03:08:44 <Maerten> ph88: do you have any experience with yesod?
03:08:56 <ph88> i installed haskell platform before the recent big update .. but since my cabal version was to old to install some stuff i had to install a newer cabal version manually
03:09:10 <sgronblo> did you get some information about which path the binaries will be installed to. I think for OSX with platform you are not supposed to set to ~/.cabal/bin. so you could verify that the path is correct on ubuntu as well.
03:09:29 <ph88> Maerten: no but i was considering whether webdevelopment with haskell would be a good idea. so i researched some packages like yesod
03:10:35 <ph88> sgronblo: i didn't remember any installation information of the haskell-platform   i was setting that directory so that it would use the 1.20 version of cabal (which didnt work)
03:13:13 <Maerten> yeah i think it's interesting to make a simple site, just to try it out. but yesod-dev seems kind of slow with this recompilation.. i'm not the only one who has this problem i see -> https://github.com/yesodweb/yesod/issues/754
03:14:00 * hackagebot coordinate 0.0.11 - A representation of latitude and longitude  http://hackage.haskell.org/package/coordinate-0.0.11 (TonyMorris)
03:14:02 * hackagebot ekg 0.4.0.3 - Remote monitoring of processes  http://hackage.haskell.org/package/ekg-0.4.0.3 (JohanTibell)
03:14:23 <ph88> Maerten: what kind of hardware do you have ?
03:17:45 <Maerten> ph88: macbook pro from 2012.. 2.6ghz
03:18:28 <ph88> should be ok !
03:19:00 * hackagebot ekg-statsd 0.2.0.1 - Push metrics to statsd  http://hackage.haskell.org/package/ekg-statsd-0.2.0.1 (JohanTibell)
03:19:00 <ph88> well you should have faster execution speed, but on small projects that's not very important
03:19:11 <ph88> Maerten: did you try hhvm ?
03:20:47 <jonkri> I'm about to write a software engineering/management master thesis, and I'm considering to do research into Haskell, or functional programming. It should probably be in one of the following fields: Requirements engineering, empirical software engineering, software architecture, or model-driven engineering. Does anyone have any suggestions of relevant topics or papers to read? Thanks!
03:21:57 <jonkri> Oh, quality management is another field. :)
03:22:02 <ph88> jonkri: concurrency and functional programming is a hot topic
03:23:41 <Maerten> ph88: no i didnt spend a lot of time on hhvm, but i might when i decide to not use yesod too much. bbl
03:24:14 <ph88> im worried that im installing all haskell stuff twice because i have two cabals !
03:24:37 <SwashBuckla> we liked it so much
03:24:40 <SwashBuckla> we installed it twice
03:24:48 <ph88> what is the cabal version on the latest haskell-platform version ?
03:25:29 <SwashBuckla> ph88: 1.18.0.5
03:25:48 <SwashBuckla> this is just from my machine
03:25:53 <jonkri> ph88: Thanks, I'll keep that in mind. :)
03:25:58 <SwashBuckla> I am pretty sure I have not upgraded
03:52:34 <srhb> Does anyone using Hakyll know how to expand some fields from a Context _before_ the pandocCompiler is run on it? (Since pandocCompiler munches $foo$ into math, so the field is lost)
03:53:53 <srhb> I guess it isn't actually possible to separate the two.
03:54:03 * hackagebot yesod-core 1.4.0.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.4.0.2 (MichaelSnoyman)
03:54:05 * hackagebot coordinate 0.0.12 - A representation of latitude and longitude  http://hackage.haskell.org/package/coordinate-0.0.12 (TonyMorris)
04:05:31 <beckyconning> i just changed my snake game to have a separate input thread to stop getChar's buffering from creating a long queue of inputs. it works great in ghci but for some reason i can't control the snake when its compiled. does anyone have any clues? https://github.com/beckyconning/haskell-snake/blob/master/Snake.hs
04:10:50 <MagneticDuck> uhm. what's the best way to write, say, a function "IO a -> (IO a, Float)" that measures the amount of time it takes for an IO action to fully and strictly evaluate?
04:11:21 <MagneticDuck> library functions? I can't figure how to get seq working on "IO a"
04:11:36 <ghorn_> i think you need IO a -> IO (a, Float)
04:12:14 <MagneticDuck> yes
04:12:17 <MagneticDuck> typo
04:13:23 <MagneticDuck> I need deepSeq, right?
04:13:53 <MagneticDuck> deepseq*
04:14:51 <beckyconning> (moved it to a different branch https://github.com/beckyconning/haskell-snake/blob/develop-input-thread/Snake.hs)
04:16:14 <MagneticDuck> I don't think I understand deepseq
04:16:26 <MagneticDuck> why can't I just have a function "a -> a" that makes a thing evaluate strictly?
04:16:31 <MagneticDuck> uhm.
04:16:36 <MagneticDuck> I guess that doesn't really make sense
04:16:42 <kazagistar> :t deepseq
04:16:44 <lambdabot> Not in scope: ‘deepseq’
04:16:46 <kazagistar> er
04:16:58 <MagneticDuck> oh, force
04:17:13 <MagneticDuck> okay, I understand
04:17:15 <MagneticDuck> makes sense x|
04:17:24 <kazagistar> yeah, seq is just the more general form
04:17:41 <ph88> i try to run example  http://code.haskell.org/plot/examples/Test4.hs  but i get error:  Could not find module `Numeric.GSL.Statistics'    what can i do about this ?
04:18:23 <MagneticDuck> install the package "statistics"
04:18:28 <MagneticDuck> (I believe)
04:19:03 <ghorn_> i think it's this package: http://hackage.haskell.org/package/hmatrix-gsl-stats-0.2
04:20:38 <MagneticDuck> uhm.
04:21:20 <MagneticDuck> hmm
04:21:26 * MagneticDuck thinks about seq
04:22:11 <kazagistar> MagneticDuck: do you know what Bottom (or _|_ ) is?
04:23:04 <ph88> thx ghorn_
04:23:45 <kazagistar> MagneticDuck: it is the "secret" inhabitant of every type, the error or infinite loop, and the only way to know if something will be bottom is to evaluate
04:24:40 <MagneticDuck> yes I've heard of that
04:25:51 <kgadek> hi. is it possible to write… don't know, maybe template haskell-thingy that would print all local bindings in a function (in a way `:sprint` in GHCi works, so not forcing evaluation)? I'm updating my custom logging/error handling monad transformer (will publicise soon), and that would be massively useful. I don't know much TH so the question is now only about "is it possible" — if that's so, I'll dive full into TH :)
04:26:15 <kgadek> (if that's not possible I'll stay with printf-like variadic functions)
04:26:50 <ph88> guys i have a problem installing hmatrix-gsl-stats http://pastebin.com/VxqhwjaL while following the installation instructions https://github.com/amcphail/hmatrix-gsl-stats/blob/master/INSTALL
04:28:09 <kazagistar> @pl force x = deepseq x x
04:28:10 <lambdabot> force = join deepseq
04:28:26 <MagneticDuck> ph88: https://github.com/amcphail/hmatrix-gsl-stats
04:28:29 <MagneticDuck> it's a cabal package
04:28:31 <MagneticDuck> use cabal install
04:28:47 <MagneticDuck> also, it's already on hadkage
04:28:49 <MagneticDuck> hackage*
04:28:53 <MagneticDuck> do you don't even have to go to github
04:29:19 <ph88> MagneticDuck: please see line 1 of paste http://pastebin.com/VxqhwjaL
04:30:41 <kazagistar> ph88: ah, it seems it depends on the GSL (GNU Scientific Library), so you need to have the header files for that
04:31:35 <kazagistar> ph88: if you are on a linux distro, you can grab those from your package manager
04:33:12 <ghorn_> apt-get install libgsl0-dev
04:33:27 <ghorn_> or something like that
04:39:06 * hackagebot kansas-lava-shake 0.1.1 - Shake rules for building Kansas Lava projects  http://hackage.haskell.org/package/kansas-lava-shake-0.1.1 (GergoErdi)
04:42:48 <ph88> thank you kazagistar & ghorn_
04:43:55 <ph88> plot works finally :)
04:45:41 <tibell> chrisdone, does the ghc-mod/haskell-mode combo work flawlessly for you?
04:46:22 <tibell> chrisdone, every time I try to set up some deeper ghci integration with emacs mode it doesn't work for me, perhaps cause I work on packages that do lots of low-level stuff, like use .hsc files.
05:00:34 <ghorn_> ph88: no problem!
05:04:08 * hackagebot coordinate 0.0.13 - A representation of latitude and longitude  http://hackage.haskell.org/package/coordinate-0.0.13 (TonyMorris)
05:04:13 <ph88> guys the code in display is that gtk code ??  http://code.haskell.org/plot/examples/Test4.hs
05:04:21 <ph88> or is that specific for plot ?
05:04:37 <ph88> because i want to make a dropdown box to select different graphs to view
05:05:03 <asfp> when do you use the Except monad and when do you use the Either monad?
05:11:09 <CaptainK> Well in Revelation 13:17, it's "Except the one who has the mark and Either the name of the beast or the number " if that helps
05:20:01 <ph88> how can i compile my haskell file to binary ?
05:20:10 <ph88> i just used ghci and runhaskell so far
05:24:22 <mads-> ph88: Can't you just use ghc?
05:24:43 <ph88> just   ghc myprogram.hs ?
05:25:09 <ph88> oh ye now i have a .o file
05:26:16 <ph88> hmm i try    sudo chmod +x program.o   ./program.o   but i get:  zsh: exec form error: ./program.o
05:26:26 <ph88> so i think it's not a good executable
05:26:50 <lieven_> did you have a main definition in your myprogram.hs?
05:26:59 <mitu> that's an object file. You should also have a myprogram file that can be executed
05:27:34 <mads-> When I do ghc prog.hs it outputs prog.o. If I do ghc prog.hs -o prog I will have a binary executable prog
05:27:47 <ph88> mitu: right i didnt notice that file yet
05:28:01 <solarus> also if you named your module make sure it says "module Main where" instead of "module Program where"
05:28:20 <ph88> yes works now ^^
05:28:27 <ph88> can i crosscompile too ?
05:28:37 <ph88> i work on linux and like to compile to windows target
05:29:02 <nkar> shelly question: this code http://dpaste.com/0KX20GD requires typing password two times.  is there a way to avoid that other than passing the whole script to sudo?
05:29:09 <mads-> Without knowing about it, I somehow doubt it, ph88
05:31:03 <lieven_> nkar: normally sudo caches credentials unless told not to do that in the config file
05:32:11 <nkar> lieven_: I'm aware of that.  it works as expected in the terminal.
05:32:33 <lieven_> that's weird
05:32:58 <adnap> If GHC can compile Haskell to LLVM, and LLVM can be compiled to ARM, why can't Haskell be compiled for Android phones?
05:34:35 <lieven_> nkar: an alternative is to set up an sudoaskpass command
05:35:13 <geekosaur> adnap: because running native code on Android is painful and requires extra glue; the Android ecosystem is Dalvik
05:35:30 <geekosaur> (a different virtual machine)
05:36:40 <adnap> I'm not talking about creating an Android application
05:36:49 <adnap> Just compiling a ARM binary
05:37:26 <geekosaur> my point is, you can't *do* anything with an ARM binary
05:37:31 <adnap> Yes you can
05:37:34 <t7> ./mybinary
05:37:45 <adnap> You can compile C programs to binarys and run them in any terminal app
05:37:51 <adnap> *binaries
05:38:17 <t7> i thought ghc can do android stuff now?
05:38:45 <geekosaur> I think people have managed to put otgether stuff for a rooted environment. it's just not what people generally mean by targeting Android, and very niche
05:38:53 <silver_> you need some minimal bindings to their libs
05:39:02 <adnap> I feel like my question is being dodged
05:39:38 <adnap> You don't even need root to run such a binary
05:39:43 <silver_> you can do Haskell for Android, it just might require some extra work
05:39:43 <adnap> btw
05:40:04 <geekosaur> you're failing to understand the ramifications of your question.
05:40:20 <geekosaur> "why can't I fly, it's just falling up?!"
05:40:37 <adnap> Can you explain in literal terms rather than metaphors why I am failing to understand?
05:41:07 <geekosaur> sadly, I thing Id have to go the other way. I, and others, have mentioned literal things...
05:41:18 <geekosaur> you seem to think they are "dodging"
05:42:27 <silver_> adnap, http://www.haskell.org/haskellwiki/Android
05:42:33 <geekosaur> you can build ARM executables that operate in a rooted shell environment. most of the system API is not available, so all you can do are simple things.
05:43:36 <geekosaur> many things that you would expect to be available as libraries you could FFI to, are implemented in Dalvik and not as ARM libraries
05:44:42 <geekosaur> there are ways around this, but now your target ecosystem isn't Android rooted command line, but e.g. Cydia with a bunch of someone else's ported ARM-native libraries
05:44:58 <nshepperd> I seem to recall a post on hacker news by a startup building a FRP game in haskell that they had running in Android?
05:45:16 <nshepperd> using sdl
05:45:31 <sgronblo> nshepperd: this http://keera.co.uk/blog/2014/08/13/most-inspiring-green-screen-you-will-ever-see/ ?
05:45:41 <silver_> sure, but have they shared they code? I bet they did a bunch of glue for it to work
05:45:54 <silver_> their code
05:47:08 <nshepperd> yeah that looks like it
05:47:31 <silver_> https://github.com/neurocyte/ghc-android
05:47:34 <adnap> The only interesting thing I found at http://www.haskell.org/haskellwiki/Android was a link to someone who build a GHC cross-compiler for Android, but I'm not sure which architecture. I don't think this relies on LLVM. I wonder why nobody uses GHC to generate LLVM
05:47:52 <hmot> This is my first post, so hi all. I was wondering why prelude's maximum and minimum functions seem to have different behaviour for NaNs: maximum [1,2,3,4,5,6,0/0,5] = 5.0, but minimum ([1,2,3,4,5,6,0/0,5]) = 5
05:48:04 <hmot> oops. Maximum gives 6
05:48:25 <nkar> lieven_: can I use SUDO_ASKPASS without relying on another script?  isn't there a way to get a password upfront and just "pipe" that to sudo?
05:48:40 <theorbtwo> adnap: If it's Android and unspecified arch, that's an arm.  x86 androids are mostly never.
05:49:04 <adnap> There are different versions of ARM though
05:49:16 <geekosaur> theorbtwo, there's more than one "arm". arm7 code won't run on arm6 for example
05:49:39 <ysz> what's the easiest way to change shared library name with cabal?
05:49:46 <ysz> or should i roll my own buildHook?
05:50:00 <adnap> WIthout looking at this cross-compiler, my impression is that it will be very clunky
05:51:18 <geekosaur> hmot: NaN and other IEEE754-isms mostly break the mathematical abstractions that Haskell tends to rely on. this somewhat regularly comes up on the mailing lists (very recently a thread about the Sum and Product monoids not obeying the monoid laws on Float / Double)
05:52:27 <Zouppen> what is good way to allow toggling some features in cabal package. the package consists of multiple binaries and not all of them are required for each user so it would be helpful toggle them off when running cabal install. or should I just split the project into multiple packages even if they share some code?
05:52:29 <hmot> ah, great, thanks
05:54:22 <geekosaur> the general rule is, if you need speed and are willing to cope with a bit of wweirdness, use Float / Double; if you need precision or can't cope with all the corner cases, which Haskell makes more visible than other languages, use something like Rational or CReal
05:54:33 <geekosaur> (CReal requires an extrenal library from Hackage)
05:55:43 <hmot> That sounds reasonable. My hunch would probably be to write my own maxNaN, minNaN functions that explicitly ignore NaNs
05:57:20 <hmot> geekosaur++
05:57:56 <nshepperd> hmot: comparison of NaN with anything else returns False always. presumably minimum is using < to decide whether to keep the old value while traversing the list, which results in it choosing the 0/0 and then immediately discarding it in favour of 5
05:59:31 <geekosaur> yep. that'd be the IEEE754ism. NaN is just strange
05:59:33 <hmot> hmm, so the minimum function could be re-written in prelude to use the > operator on flipped operands, and maybe it would work
05:59:46 <geekosaur> no, because > also always returns False
05:59:56 <geekosaur> NaN is not comparable to anything including itself
06:00:12 <hmot> well, if > always returns false, that would be like NaNs being infinitely large in the minimum function
06:00:26 <hmot> so the minimum function would return the smallest non-NaN double
06:02:30 <hmot> so the 1>2 would return false, so it would pick 1 --- later in the calculation, it would be comparing 1 to NaN, and getting false, indicating that it should keep the 1, and so on ... result: minumum [1,2,3,4,5,6,0/0,5] would be equal to 1, which is at least comforting to people who worry about such things
06:02:44 <nshepperd> it would break if NaN was the first item though, since it would keep the NaN forever
06:02:56 <geekosaur> exactly
06:03:02 <hmot> huh, yeah, that's true
06:03:03 <hmot> ok
06:03:05 <nshepperd> I think it's better to just ignore NaN
06:03:25 <hmot> great
06:03:26 <geekosaur> reasoning about IEEE NaN is a lot like reasoning about undefined/bottom
06:03:35 <nshepperd> or indeed, pre-filter any such list with `filter (not isNaN)`
06:03:39 <geekosaur> it throws unexpected monkey wrenches everywhere
06:09:13 * hackagebot http-test 0.2.4 - Test framework for HTTP APIs  http://hackage.haskell.org/package/http-test-0.2.4 (glutamate)
06:14:28 <ph88> how can i divide my program in several files like this http://pastebin.com/an7A2B2C ??
06:14:39 <ph88> http://i.imgur.com/58DFOWN.png
06:22:13 <AshyIsMe> ph88: have a read of this chapter: http://learnyouahaskell.com/modules#making-our-own-modules
06:22:21 <AshyIsMe> the whole book is well worth the read too
06:22:30 <ph88> ive read that
06:22:31 <mnew> I'm getting seg faults at link time when using llvm-general
06:22:38 <mnew> has anyone else had this?
06:23:42 <AshyIsMe> ph88: that explains how to split code out into separate modules (files)
06:23:55 <ph88> oki
06:24:30 <ph88> does import become before or after module ?
06:24:36 <ph88> in case the module also needs imports
06:25:32 <AshyIsMe> after
06:26:18 <AshyIsMe> ph88: random example of a module here: http://hackage.haskell.org/package/MissingH-1.2.1.0/docs/src/Data-List-Utils.html
06:26:55 <ph88> can i let a do block return a value ?
06:27:58 <srhb> ph88: You can't not.
06:28:11 <srhb> ph88: The value of a do block is the last line in the do block.
06:28:23 <srhb> Well, the last expression.
06:28:34 <mnew> hm, linking against the shared llvm libraries seems to have worked
06:30:14 <ph88> i'm doing    g <- stdGen in a do block  but now i don't know how to do the same in a function
06:30:25 <Maerten> ph88: not sure if you are using yesod-dev, but i made a little bash script that speeds up the save&reload: https://gist.github.com/maerten/2c9152f68e2bbefa93ac
06:30:29 <ph88> g <- getStdGen
06:30:51 <ph88> Maerten: nice .. no i dont use but bookmark anyway since i might in the future
06:30:52 <srhb> ph88: I think you're confused. foo x = do { return x } -- is a function with a do block
06:31:13 <ph88> srhb: ok but how do i make the generator in a function ?
06:31:40 <srhb> ph88: foo x = do { g <- stdGen; ... } ?
06:31:53 <ph88> hhmm
06:31:54 <srhb> I don't know what stdGen is, by the way.
06:32:07 <ph88> so it cant be done without a do block ?
06:32:14 <srhb> ph88: Sure. foo = stdGen
06:32:27 <ph88> o_O
06:32:35 <ph88> why did i had to use <- before ?
06:32:38 <srhb> ph88: Honestly I've no idea what you are trying to do
06:32:54 <srhb> ph88: Because you needed to unwrap it for some reason. I don't know. I haven't followed the conversation until now :)
06:32:59 <exio4> could you show a little example of what you are trying to "achieve"?
06:33:02 <srhb> ph88: What are you trying to do?
06:33:50 <srhb> ph88: It would help to know the type of stdGen, too.
06:33:58 <ph88> srhb: what do you want to know about what i am trying to do ??  i just like one file to contain one sort of functionality
06:34:14 <srhb> ph88: That tells me almost nothing.
06:34:42 <ph88> that's why i put my question what DO you want to know about it ?
06:34:43 <ph88> getStdGen :: IO StdGen
06:34:44 <srhb> ph88: I'm asking because you seem confused about some very basic Haskell topics, and I'd like to help if I can (and you want it)
06:34:52 <ph88> http://hackage.haskell.org/package/random-1.0.0.2/docs/System-Random.html
06:35:02 <srhb> Ok, getStdGen, not stdGen. That helps.
06:36:28 <exio4> ph88: what code is the one that you want to "split"?
06:37:40 <ph88> http://pastebin.com/5jW30v5j  this is File 1  of  http://pastebin.com/an7A2B2C & http://i.imgur.com/58DFOWN.png
06:37:50 <nkar> lieven_: how bad is this?  http://dpaste.com/1RSKJ4C  will the password be exposed somewhere?
06:37:57 <ph88> exio4: nothing to split ... i only have file 1 and file 3 so far and i need to build file 2
06:39:10 <ph88> if i try to run file 1 by itself i get:   Couldn't match expected type `StdGen' with actual type `IO StdGen'
06:39:12 <nkar> lieven_: (a password must be followed by a newline, but that's not the point)
06:39:17 * hackagebot fpco-api 1.2.0 - Simple interface to the FP Complete IDE API.  http://hackage.haskell.org/package/fpco-api-1.2.0 (ChrisDone)
06:39:19 <ph88> because there is no main with IO  like i had before !!!
06:39:39 <ph88> because it was running by itself .. but now it should become a module to  use for file 2
06:40:13 <ph88> so i need to do IO in my getData function i think but i dont know how to do that
06:40:32 <ph88> srhb: ??
06:41:06 <srhb> ph88: You can't do it like that for sure. You need to unwrap the g
06:41:18 <ph88> whats unwrap ?
06:41:19 <srhb> ph88: g >>= \g -> zipWith (realOrDummy ss g) (randomTruth (length freqs) g) freqs
06:41:32 <ph88> whats >>=   ?
06:41:37 <ph88> and  \g
06:41:39 <srhb> ph88: assuming realOrDummy takes a StdGen
06:41:45 <srhb> ph88: Bind and lambda, respectively
06:42:03 <ph88> i will google for    haskell bind
06:42:22 <srhb> ph88: Perhaps try reading LYAH or a similar resource. You'll find it hard to accomplish anything at all in Haskell without this knowledge.
06:42:22 <ph88> does that have to do with monads ?
06:42:25 <srhb> Yes.
06:42:30 <ph88> i didnt cover those yet
06:42:32 <srhb> :t (>>=)
06:42:33 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:42:48 <srhb> ph88: Well, cover it or don't do IO. :)
06:42:54 <ph88> it cant be done without a monad ?
06:43:08 <srhb> Only by making your program pure
06:43:13 <srhb> Ie. no IO at all.
06:43:24 <srhb> (Meaning your random numbers will be the same every time)
06:43:24 <ph88> is monad a space to put something unpure ?
06:43:37 <srhb> ph88: I don't want to summarize what a monad is or is not.
06:43:42 <ph88> ok
06:44:05 <srhb> But we do use them to facilitate IO and other things, yes.
06:44:07 <ph88> are all of the pure functions i wrote now part of that monad ?
06:44:26 <srhb> ph88: Check their types. If they say IO Something -- then they are now actions in the IO Monad
06:45:00 <exio4> I wouldn't try coding "useful" stuff (code with "effects") without some idea of monads in HS
06:45:08 <ph88> is IO infered from g automatically for the IO monad ?
06:45:44 <c_wraith> :t getStdGen
06:45:45 <lambdabot> IO StdGen
06:45:52 <ph88> get being of type   IO StdGen
06:45:58 <c_wraith> ph88: IO is *right* there
06:45:59 <ph88> IO ::  StdGen
06:51:10 <ph88> the monadic classes, Functor, Monad, and MonadPlus. None of the monadic classes are derivable.  <-- what does derivable mean here??  source: http://www.haskell.org/tutorial/monads.html
06:52:09 <AshyIsMe> ph88: it really is worth taking the time to read learn you a haskell in depth
06:52:14 <AshyIsMe> and work throug the examples
06:52:27 <srhb> ph88: I don't think anyone would call Functor a "monadic class" anymore, and the information is outdated. Don't read that page. :)
06:52:44 <AshyIsMe> i came from other languages and first tried to learn haskell as you would any other imperative language
06:52:50 <AshyIsMe> but haskell takes a fair bit of reading first
06:52:52 <tdammers> ph88: my guess would be that you can't write "deriving Monad", at least not without using some language extension
06:55:09 <ph88> ok ill start with the LYAH tutorial then over that one ^^
06:55:37 <srhb> ph88: The gentle haskell tutorial is for Haskell 98.. It's outdated in a lot of sections. :)
06:55:59 <ph88> AshyIsMe: sure thing ! i like to apply it right away though
06:56:04 * geekosaur also wouldn't call it particularly gentle...
07:01:01 <J_Arcane> Oh hey! Useful heads up; NearlyFreeSpeech.net supports Racket v6.1 CGI on their "beta White realm".
07:04:18 <AshyIsMe> ph88: the lyah book has example code throughout that you can play around with yourself :)
07:08:13 <stefan_1__> odd question, has anyone tried using psychedelic substances like LSD or psilocybin to aid their understanding of some of the more abstract concepts of functional programming?
07:08:30 <AshyIsMe> haha
07:08:34 <ahf> lol
07:08:59 <exio4> it is said that haskell is a gateway drug... I don't know to which ones though!
07:09:20 <srhb> I wouldn't be surprised if LSD were one of them. :-)
07:09:21 <SwashBuckla> I thought that XMonad was a gateway drug to Haskell
07:09:33 <SwashBuckla> but Haskell is the hard stuff
07:09:40 <SwashBuckla> the class A
07:10:09 <SwashBuckla> once you've tried it, that's it
07:10:20 <SwashBuckla> physical, mental and spiritual dependency
07:10:25 <jesyspa> SwashBuckla: I wouldn't call it hard stuff if people use it at work.
07:10:44 <SwashBuckla> jesyspa: do they use it addictively?
07:10:58 <jesyspa> Dunno
07:10:59 <SwashBuckla> I've lost many friends to Haskell
07:11:24 <srhb> I'm not convinced that hallucinogenic drugs aid with understanding anything, though. Last I spoke to someone about it, he claimed to have "finally understood photosynthesis" while on 'shrooms. I've never heard such an incoherent explanation of photosynthesis before.
07:11:30 <SwashBuckla> symptoms of addiction include: pedagogy, proselytising, 'selling'
07:11:39 <srhb> That said I would really enjoy "Monads on acid, the tutorial"
07:12:07 <SwashBuckla> some of my brightest pals have been caught teaching others about the benefits of Haskell
07:12:12 <SwashBuckla> they are truly hooked
07:14:11 <tdammers> SwashBuckla: happens to the best
07:15:39 <adas> i have a sandbox and for all packages installed inside the sandbox, i installed the documentation. But for some core packages outside the sandbox which were installed while installing GHC, documentation is missing. How can I install them?
07:17:50 <adas> anyone?
07:28:10 <ph88> omg im totally impressed, GHC can both compile to C AND have LLVM as backend ??
07:28:14 <ph88> that's crazy o_O
07:30:48 <ChristianS> ph88: not sure what you mean by "compile to C", afaik there is a native backend an an llvm backend
07:32:19 <c_wraith> ChristianS: ghc can compile to C, but only if it's built to do so.  It's not very optimized, and only really used for bootstrapping on different platforms.
07:34:28 <ph88> ChristianS:  https://www.haskell.org/ghc/docs/7.6.3/html/users_guide/code-generators.html  4.11.3
07:38:20 <ChristianS> ah, i see, but -fasm and -fllvm are the interesting once i think
07:38:40 <ph88> how is the haskell runtime usually installed for the end user? packages with the program binary or seperate ?
07:39:15 <ChristianS> ph88: by default, ghc compiles everything statically into the binary
07:39:18 <srhb> ph88: If shipping to Haskell users, usually a cabalized project ready to be cabal install'ed. If not to Haskell users, a binary.
07:39:40 <stolaruk> Isn't it part of every binary that is compiled by GHC?
07:40:36 <Haskellfant> by default yes, but afaik you can dynamically link to the runtime
07:40:50 <ph88> oh yes i was wondering why the exec is 1.4MB while if i would write this in C it would be more like 1.4KB
07:41:27 <ph88> but then you get to download some MSVC C++ runtime or lib* on linux (installed by default most of the time)
07:44:02 <ph88> i think soon haskell can be used for the stronger embedded systems through GHC -> LLVM -> ARM backend compiler ... this would be really nice to not having to write only C
07:44:22 * hackagebot cndict 0.3.0 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  http://hackage.haskell.org/package/cndict-0.3.0 (DavidHimmelstrup)
07:44:38 <ph88> only for tiny micrcontrollers garbage collection is not an option
07:45:57 <AshyIsMe> has anyone used twitter-conduit here?
07:46:47 <albeit> I'm trying to time some functions, and getting odd results (http://lpaste.net/111851). Specifically, getting the system time and then writing it to text is significantly slower than the two steps individually... why would this be?
07:48:13 <albeit> From the lpaste, getTime (0.05) + writeTime (12.62) << getWriteTime (15.90)
07:49:27 <AshyIsMe> ph88: there's some projects for generating embedded c code from haskell
07:49:35 <AshyIsMe> ph88: http://hackage.haskell.org/packages/#cat:Embedded
07:49:44 <AshyIsMe> atom and copilot
07:49:48 <AshyIsMe> i havent used them though
07:50:59 <c_wraith> albeit: I think you're reading the units wrong.  Those numbers all look fine to me.
07:51:16 <c_wraith> albeit: pay attention to the difference between us (microseconds) and ns (nanoseconds)
07:52:19 <c_wraith> albeit: the rest is hard to quibble over, with the reported variance.
07:52:26 <albeit> c_wraith: Hmm.. getAndWriteTime = 15.91 us. writeTime = 12.62 us. So getTime should be about 3.29 us, which is 3290 ns... but getTime in reality is 48 ns. Wayy less than 3290 ns.
07:53:10 <c_wraith> albeit: the thing is, those numbers are still not that far apart - and the reported variance is quite high.
07:53:42 <albeit> c_wraith: Ah I see what you mean... few hundred ns variance for the larger numbers
07:54:06 <c_wraith> albeit: either that's a VM, or the system is heavily loaded.  In either case, I wouldn't worry too much about small differences, yet.
07:54:24 * hackagebot aeson 0.8.0.1 - Fast JSON parsing and encoding  http://hackage.haskell.org/package/aeson-0.8.0.1 (BasVanDijk)
07:55:24 <albeit> c_wraith: No VM, Ubuntu 14.04, and no heavy load on the system... why else would they be so large?
07:55:56 <c_wraith> albeit: hmm. Unexpected, then.
07:59:50 <AshyIsMe> how do you catch something from a function that uses monadThrow?
08:00:07 <johnw> you'd need to also require MonadCatch
08:00:18 <johnw> if you're talking about the exceptions package, by edwardk
08:00:37 <johnw> however, I think you only need MonadCatch for the function where you're going to catch
08:04:00 <AshyIsMe> http://hackage.haskell.org/package/twitter-conduit-0.0.7/docs/src/Web-Twitter-Conduit-Base.html#call%27
08:04:06 <AshyIsMe> im using the call function there
08:05:21 <AshyIsMe> getValueOrThrow returns a MonadThrow instance
08:09:31 <yitz> AshyIsMe: it means that the monad in which you run that needs to be capable of throwing. it you want to catch it, your monad also needs to be capable of catching.
08:10:01 <yitz> *if
08:12:56 <AshyIsMe> so if it's not capable of catching, then by default the program crashes and prints the exception?
08:13:57 <yitz> AshyIsMe: most likely. it depends on the implementation of throw for that monad. but yeah.
08:14:27 <yitz> AshyIsMe: anyway, we're beating around the bush. the monad you are almost certainly interested in in this case is called "IO"
08:14:44 <albeit> Are there any Haskell libraries that can write a time to Text? There is formatTime :: a -> String, but it's not Text..
08:14:47 <yitz> AshyIsMe: or some MonadIO thing on top of it
08:15:33 <yitz> @hoogle UTCTime -> Text
08:15:36 <lambdabot> Data.Text.Lazy unfoldr :: (a -> Maybe (Char, a)) -> a -> Text
08:15:36 <lambdabot> Data.Text unfoldr :: (a -> Maybe (Char, a)) -> a -> Text
08:15:36 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
08:17:42 <yitz> albeit: do you need super high performance for huge numbers of time strings? time strings are short, so just packing the String into Text will cost you near zero.
08:19:15 <albeit> yitz: Well, looking to log things roughly every 10-50us with a new timestamp for each log, and using formatTime packed into Text takes about 15us... little nervous its going to fall behind
08:19:36 <cebewee_> I created a new sandbox, tried to install some packages. cabal complains about packages to be broken by reinstalls -- how comes, the sandbox is brand new?
08:20:12 <albeit> yitz: And was thinking building up a Text object may be significantly faster than building up from a bunch of padded String (which I think formatTIme is doing)
08:20:20 <tomejaguar> How do you do multiline WARNING pragma messages?
08:20:27 <yitz> albeit: why not use the fastlogger library then?
08:20:40 <EvanR2> im on osx trying to upgrade cabal install, but cabal update keeps saying theres a new version of cabal install available, even after i install it
08:21:10 <albeit> yitz: Actually didn't know about that! Was doing custom logging, I'll check it out. Thanks!
08:21:12 <cebewee_> EvanR2: You probably don't have ~/.cabal/bin in your path, so you keep calling the old cabal
08:21:17 <EvanR2> ok
08:21:31 <dcoutts> cebewee_: your sandbox is based on your current global package db. If you install things into your sandbox that mask things from the global db then those global ones are no longer usable within your sandbox. However you probably don't care about that so it's ok.
08:22:02 <cebewee_> dcoutts: So, just use --force-reinstalls and be happy?
08:23:16 <albeit> yitz: Correct me if I'm wrong, but fast-logger essentially implements a buffer for log messages? I currently have a Chan of log messages that I think does the same thing
08:24:26 * hackagebot epic 0.9.3.2 - Compiler for a simple functional language  http://hackage.haskell.org/package/epic-0.9.3.2 (AndreasAbel)
08:24:31 <tomejaguar> It seems that pragma messages can't contain linebreaks.  Any workaround?  I don't want to make very long lines!
08:24:31 <yitz> albeit: it has built in multicore support. it's well tested an robust, used extensively in production.
08:25:05 <yitz> albeit: you don't have to worry about spending 15us formatting a date if it's running on its own core
08:26:40 <albeit> yitz: Ah okay, so I would just share a LoggerSet among all threads that need to log, and fast-logger handles getting the logs actually written?
08:26:55 <yitz> right
08:28:51 <cebewee> is there an option which enables GHC to show all missing modules, not only the topmost one?
08:28:57 <yitz> tomejaguar: from the ghc docs: "The layout rule applies in pragmas, so the closing #-} should start in a column to the right of the opening {-#."
08:29:16 <cebewee> as I need to rebuild my sandbox every time I add an dependency, this would be a big time-saver
08:29:50 <EvanR2> "idris depends on language-java which failed to install" o_O
08:29:59 <tomejaguar> yitz: That doesn't seem to be the problem: lexical error in string/character literal at character '\n'.  It just doesn't like newlines in the warning message string
08:30:04 <EvanR2> twlight zone-like error message
08:30:23 <luite> EvanR2: probably missing alex/happy
08:30:40 <EvanR2> i install alex excplicitly and it worked
08:30:52 <EvanR2>  i guess cabal install does not install binaries for you
08:30:55 <yitz> albeit: all that said - it sure would be cool to have a port of Data.Time.Format to Text. :) and i think there actually may be other stuff out there that formats time.
08:31:06 <luite> EvanR2: that is correct
08:31:37 <yitz> tomejaguar: ah, inside the warning message? can't you wrap the pragma so that the message itself is on one line without being overly long?
08:32:28 <yitz> EvanR2: it's part of the haskell platform install
08:32:42 <tomejaguar> yitz: The message itself is over 80 chars.  Perhaps I can use the \ trick
08:32:43 <EvanR2> language-java ?
08:32:55 <yitz> EvanR2: no, alex and happy
08:33:06 <EvanR2> i dont think i used haskell platform
08:33:12 <tomejaguar> yitz: Oh yes that works.
08:33:21 <yitz> tomejaguar: cool!
08:33:22 <tomejaguar> yitz: Just the normal multiline trick with \
08:33:28 <tomejaguar> yitz: Cheers
08:33:39 <yitz> tomejaguar: which pragma?
08:34:46 <danilo2> Hello! Is there any library in Haskell which would choose the most simmilar string to given one? something like GHC does when it finds uknown name?
08:34:53 <lpaste> tomejaguar pasted “Multiline warning” at http://lpaste.net/111853
08:34:58 <tomejaguar> yitz: ^^
08:36:45 <tomejaguar> danilo2: Don't really know, but maybe Levenshtein distance e.g. http://hackage.haskell.org/package/edit-distance.  Just looking up the GHC source might help too.
08:36:49 <johnw> danilo2: https://hackage.haskell.org/package/phonetic-code?
08:37:23 <danilo2> tomejaguar: ok, I will look at it, thank you
08:37:33 <danilo2> johnw: Oh, that is very interesting! thank you very much!~
08:38:21 <yitz> tomejaguar: could you patch the ghc docs to mention that, or at least open a ticket for it? i think multiline string support in pragmas should be mentioned.
08:38:46 <tomejaguar> yitz: Fair enough.  I'll put it on my TODO list.
08:38:52 <yitz> :)
08:39:09 <tomejaguar> yitz: Do you know where the GHC docs source is?  Is it part of the main GHC project?
08:39:27 <yitz> tomejaguar: yes, there's a docs directory
08:39:43 <tomejaguar> OK, I guess I'll file a ticket then.  I dare not check out GHC.
08:39:50 <yitz> heh
08:41:33 <kgadek> I have a problem with c2hs on OS X 10.9. Reduced the problem to `c2hs --cpp=/Developer/NVIDIA/CUDA-6.5/bin/nvcc --cppopts=-ccbin --cppopts=/usr/bin/clang --cppopts=-Xcompiler --cppopts=--stdlib=libstdc++ Device.chs` (Device.chs is from cuda-0.6.5.0 from hackage) which yields the error below:
08:41:34 <kgadek> In file included from <built-in>:170:
08:41:35 <kgadek> <command line>:3:29: error: expected comma in macro parameter list
08:41:36 <kgadek> #define C2HS_MIN_VERSION(mj 1
08:41:37 <kgadek>                             ^
08:41:38 <kgadek> (…)
08:41:44 <kgadek> any idea how to tackle this?
08:42:34 <kgadek> if I could try to get the call to nvcc then I could spot the problem (or I'd go to #cuda )
08:44:47 <t4nk850> newbie question: is there anyway to "name" pattern like with "as" keyword in ocaml? Something like Vec2(x,y,z) as v ...?
08:45:04 <kgadek> t4nk850: v@Vec2(…)
08:45:11 <t4nk850> Thanks!
08:46:38 <kgadek> (for the record — my problem is indeed with nvcc, not c2hs. Going to #cuda)
08:49:28 * hackagebot chart-histogram 0.4.3 - Easily render histograms with Chart  http://hackage.haskell.org/package/chart-histogram-0.4.3 (BenGamari)
08:54:01 <hplus> kgadek: but why?
08:54:36 <kgadek> I got the command: "/Developer/NVIDIA/CUDA-6.5/bin/nvcc -E -x c -ccbin /usr/bin/clang -Xcompiler='--stdlib=libstdc++' -U__BLOCKS__ -D'C2HS_MIN_VERSION(mj,mn,rv)=(mj<=0&&mn<=18&&rv<=2)' Device.chs.h"
08:54:45 <kgadek> this seems okay and *should* work, but it does not
08:54:54 <kgadek> so the issue appears to be with CUDA
08:55:05 <kgadek> I mean: CUDA drivers
08:55:16 <kgadek> (or CUDA toolkit)
08:56:21 <hplus> kgadek: I dont know
09:09:55 <t4nk937> newbie question: I am creating a vec2 class deriving from Num. It seems that I need to implement fromInteger? Is it normal? It is a bit weird that all instance of Num need to implement fromInteger, isn't it? (well, this is just a warning)
09:11:16 <t4nk937> Oh
09:11:32 <t4nk937> actually, the class really makes sense only for scalar values actually
09:11:49 <yitz> t4nk937: yes, the Num class includes fromInteger.
09:12:18 <t4nk937> it does not make any sense to implement vec2 as a member of num basically?
09:12:53 <t4nk937> @yitz: Can I reuse (+) if I do not implement Num?
09:12:53 <lambdabot> Unknown command, try @list
09:13:05 <glguy> The @ is for bot commands and Twitter
09:13:26 <t4nk937> ok
09:13:43 <Saizan> t4nk937: fromInteger is used to desugar numeric literals, and for fromIntegral
09:14:16 <glguy> t4nk937: For Num to make sense for Vectors you have to do the operations point-wise, for example https://hackage.haskell.org/package/linear-1.10.1.1/docs/Linear-V2.html
09:15:12 <t4nk937> glguy: ok. I look at the library code to see that they do
09:16:55 <fer`> hello folks. I'm new to haskell, I need to create a json service in front of a pgsql db, which also needs oauth. Could anyone suggest a framework or a few libraries?
09:17:21 <dmj`> yesod, snap, happstack, scotty
09:17:55 <dmj`> for json, aeson, for oauth, authenticate-oauth
09:18:11 <chrisdone> i'd yesod that
09:18:16 <t4nk937> glguy: linear is interstingly more complicated than my poor crappy code. Thanks!
09:19:05 <chrisdone> install yesod-bin and yesod init, choose "postgresql app" and use the yesod oauth library
09:19:29 <fer`>  does haskell have a better serialization format than json?
09:19:34 <fer`> something like edn (clojure)
09:19:45 <chrisdone> what is edn?
09:20:17 <fer`> like json but lispy and with more stuff
09:20:43 <yitz> t4nk937: you may want to look at numeric-prelude, an alternative prelude that might be more suitable to what you want to do
09:21:02 <fer`> I'm just really looking for a typesafe serialization format
09:21:25 <chrisdone> fer`: so s-expressions?
09:21:27 <t4nk937> yitz: I'll look at it. Right now, I just want to write a small distance field ray tracer a la shadertoy to play with basic maths and haskell.
09:21:39 <yitz> t4nk937: sounds good
09:21:46 <chrisdone> fer`: json is type-safe with haskell
09:21:49 <yitz> chrisdone: oauth2 nowadays, no?
09:22:12 * chrisdone shrugs
09:22:25 <fer`> I guess that's good enough
09:23:52 <t4nk937> yitz: As soon as I have something running, I would like to investigate performance tools and try to see how the compiler stack goes from haskell code to binary. So, let's write some simple code. I saw lot of exciting stuff (stream fusion...) but this is a long way from here to there for me. Let's see :-)
09:24:31 * hackagebot hourglass 0.2.4 - simple performant time related library  http://hackage.haskell.org/package/hourglass-0.2.4 (VincentHanquez)
09:24:33 * hackagebot grid 7.6.3 - Tools for working with regular grids (graphs, lattices).  http://hackage.haskell.org/package/grid-7.6.3 (AmyDeBuitleir)
09:24:36 <fer`> thanks chrisdone dmj`
09:34:32 * hackagebot som 7.2.4 - Self-Organising Maps.  http://hackage.haskell.org/package/som-7.2.4 (AmyDeBuitleir)
09:37:39 <Haskellfant> is there another way to shortcircuit computations in IO then EitherT? it feels clunky having to use lift for nearly everywhere just to be able to exit at two or three points. nesting two or three cases however looks even uglier
09:38:04 <infandum> I have an edgelist where each line is of the format 3,8,4  where 3 and 8 are nodes and 4 is the distance between them. This information appears in a file that is > 50GB. How can I repeatedly loop through this information multiple times to get distances without storing it all in memory?
09:39:33 * hackagebot grid 7.6.4 - Tools for working with regular grids (graphs, lattices).  http://hackage.haskell.org/package/grid-7.6.4 (AmyDeBuitleir)
09:40:16 <merijn> Haskellfant: "It depends"
09:40:35 <merijn> Haskellfant: For "IO ()" there are things like "when", for errors there are things like exceptions
09:41:25 <merijn> Or even just "do { result <- myIO; case result of Left _ -> return (); Right x -> foo x }"
09:41:53 <Haskellfant> merijn: I have a main function that first does some stuff that can fail (like head <$> getArgs) in which case an error message should be printed and otherwise I want to continue with the main part of the function
09:42:18 <chrisdone> a few nested cases isn't that bad
09:42:38 <chrisdone> i for one encourage just telling it like it is, in code
09:42:54 <Haskellfant> I should probably just put all the stuff after the input validation in a separate function
09:43:00 <Haskellfant> than cases don't look so ugly
09:43:05 <chrisdone> +1
09:43:18 <Haskellfant> this function is way too long anyway
09:44:22 <Haskellfant> merijn, chrisdone: thx for your input
09:48:45 <WraithM> I'm getting a warning that I don't understand from GHC. I'm creating a function that replaces the last element of a list, if it's an empty list, create a list with the one element.
09:48:52 <WraithM> Here's the definition:
09:48:52 <WraithM> replaceLast :: a -> [a] -> NonEmpty a
09:48:53 <WraithM> replaceLast y [] = [y]
09:48:53 <WraithM> replaceLast y (_:[]) = [y]
09:48:53 <WraithM> replaceLast y (x:xs) = x <| replaceLast y xs
09:49:03 <WraithM> Note, I'm using OverloadedLists
09:49:14 <WraithM> Here's the warning:
09:49:15 <WraithM> Server.hs:50:1: Warning: Pattern match(es) are non-exhaustive In an equation for ‘replaceLast’: Patterns not matched: _ []
09:49:58 <WraithM> I feel like I'm handling all of the cases... But maybe I'm not thinking correctly about this.
09:52:20 <opqdonut> WraithM: that error looks weird definitely
09:53:29 <Haskellfant> WraithM: maybe you simply have a typo in one of the cases? (happened to me way too often)
09:53:58 <WraithM> Yeah, I've even done stuff like: replaceLast _ [] = error "Can't replace empty list!" as a test, and it gives the same warning.
09:54:14 <opqdonut> with that definition I get an error: Couldn't match expected type `NonEmpty a' with actual type `[a]'
09:54:23 <opqdonut> do you have something like OverloadedLists on
09:54:25 <WraithM> You need OverloadedLists
09:54:27 <WraithM> Yes
09:54:34 * hackagebot creatur 5.6.4 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.6.4 (AmyDeBuitleir)
09:55:28 <WraithM> NonEmpty is from Data.List.NonEmpty
09:55:38 <WraithM> in semigroups
09:57:42 <WraithM> Haskellfant: The code compiles just fine. It's only a warning. Like, I think the compiler, which I'm very very hesitant to blame, is giving me a warning incorrectly.
09:57:48 <opqdonut> WraithM: heh my ghc is too old
09:58:31 <WraithM> :D
09:58:40 <Haskellfant> WraithM: well a typo in one of the functions like replacelast instead of replaceLast will simply make ghc consider it to be a different function, so you had a missing case but your code will still compile.
09:59:07 <WraithM> Ah, yeah, no, that's not it. But thanks though!
09:59:18 <opqdonut> WraithM: anyway, when I change [y] to fromList [y] I don't get a warning
09:59:19 <kau> Hi guys, I started a new Nomyx game on www.nomyx.net
09:59:30 <kau> please join, it will be fun :)
09:59:34 * hackagebot creatur 5.6.5 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.6.5 (AmyDeBuitleir)
09:59:35 <opqdonut> WraithM: maybe you have a non-breaking space or something in there?
09:59:55 <WraithM> Hmmm. I don't think so. Everything compiles and works correctly.
10:00:23 <WraithM> Like, I can't get GHC to produce a warning.
10:00:41 <chrisdone> like, dude
10:01:01 <opqdonut> WraithM: could OverloadedLists be messing with the pattern match against []? try without it?
10:01:04 <WraithM> Bad habbit :/
10:01:07 <WraithM> I know
10:01:11 <opqdonut> but I'm just guessing here
10:01:22 <chrisdone> i don't see your code
10:01:31 <chrisdone> but OverloadedStrings does create funny warnings in pattern exhaustivity checks
10:01:55 <WraithM> replaceLast :: a -> [a] -> NonEmpty a
10:01:56 <WraithM> replaceLast y [] = [y]
10:01:56 <WraithM> replaceLast y (_:[]) = [y]
10:01:56 <WraithM> replaceLast y (x:xs) = x <| replaceLast y xs
10:02:25 <WraithM> opqdonut: Yeah, I'm trying without it right now.
10:02:26 <chrisdone> what's the warning?
10:03:19 <dfeuer> Is there an OverloadedChars extension as well, or are Chars the only literals of kind * that are not polymorphic?
10:03:30 <WraithM> Server.hs:50:1: Warning: Pattern match(es) are non-exhaustive In an equation for ‘replaceLast’: Patterns not matched: _ []
10:03:56 <chrisdone> oh, interesting
10:04:36 <dfeuer> That's really weird, WraithM.
10:04:37 <WraithM> Again, just reiterating from above, I'm using OverloadedLists.
10:05:00 <chrisdone> what GHC version?
10:05:05 <WraithM> 7.8.3
10:05:08 <chrisdone> i don't reproduce it with 7.8.2
10:05:23 <chrisdone> hmm =)
10:06:05 <WraithM> Very interesting! The plot thickens!
10:06:10 <chrisdone> ohhhh
10:06:13 <chrisdone> OverloadedLists
10:06:17 <WraithM> Yes
10:06:18 <chrisdone> oh, then that makes more sense
10:06:31 <WraithM> Ah, okay
10:07:32 <chrisdone> i think the code will be converted to e.g.
10:08:10 <WraithM> Yeah, I don't get a warning when I removed OverloadedLists
10:08:32 <chrisdone> replaceLast y _l | fromList l == foo = …
10:08:36 <chrisdone> or something like that
10:08:46 <WraithM> Ooooohh
10:08:49 <WraithM> That makes sense
10:09:49 <chrisdone> i think. i'm not sure. but you get similar problems with OverloadedStrings
10:10:04 <WraithM> Right
10:10:30 <chrisdone> “List patterns are also overloaded. When the OverloadedLists extension is turned on, the definitions:
10:10:31 <chrisdone> f [] = ...; g [x,y,z] = ...
10:10:31 <chrisdone> will be treated as
10:10:31 <chrisdone> f (toList -> []) = ...; g (toList -> [x,y,z]) = ...”
10:10:33 <WraithM> So, is there a way to still use OverloadedStrings/Lists and not get a warning?
10:13:07 <chrisdone> not sure. it seems pretty badly behaved to  me
10:14:04 <WraithM> Okay, I'll just not use OverloadedLists then.
10:14:06 <WraithM> Good to know.
10:14:13 <WraithM> This is the first time I ever used that extension.
10:14:22 <WraithM> Or at least not pattern match with it.
10:15:01 <chrisdone> i think it's a bug with ViewPatterns
10:15:17 <chrisdone> data T = A T | B | C
10:15:18 <chrisdone> f (id -> C) = undefined
10:15:18 <chrisdone> f (id -> B) = undefined
10:15:18 <chrisdone> f (id -> A _) = undefined
10:15:23 <chrisdone> In an equation for ‘f’: Patterns not matched: _
10:15:35 <WraithM> I actually just tried pattern matching with OverloadedLists on a NonEmpty
10:15:43 <chrisdone> this function is exhaustive, but the warning is there
10:15:46 <WraithM> and it gave me Patterns not matched: []
10:15:55 <opqdonut> chrisdone: well figuring out that it is exhaustive is pretty hard
10:15:58 <chrisdone> i imagine because the `id` could return anything, so it can't be exhaustive
10:16:00 <WraithM> which doesn't make sense for a NonEmpty
10:16:02 <opqdonut> yeah
10:16:23 <opqdonut> hmm, well you could test that it's exhaustive over the return type of the view function
10:16:30 <merijn> GHC's exhaustiveness checks should improve in 7.10
10:16:34 <opqdonut> at least when equations are similar like that
10:16:56 <merijn> Not sure whether that only applies to GADTs, though
10:17:43 <chrisdone> WraithM: if you move your [] case to the bottom and replace with _, you don't get the warning
10:17:48 <chrisdone> but… that's pretty lame
10:18:16 <WraithM> chrisdone: Yes, lame, but I'll take it. Thank you.
10:18:45 <merijn> chrisdone: There's even funnier problems, I've got one where I get an non-exhaustive pattern warning, but adding the pattern results in a type error (that part is intended)
10:19:04 <chrisdone> that's annoying. GADT?
10:19:25 <merijn> yeah
10:20:41 <albeit> If I have a lazy Text, what's the easiest way to insert a character at a specified index?
10:21:15 <merijn> split + concat
10:21:15 <ReinH> merijn: all bets are off with GADTs ;)
10:21:20 <merijn> but that's fairly expensive
10:23:54 <joehillen> http://www.codewars.com/?language=haskell
10:26:36 <J_Arcane> joehillen: That's pretty neat. Site seems hammered though; I just get timeouts on submit.
10:30:37 <chrisdone> albeit: insertAt c = (\(x,y) -> concat [x,singleton c,y]) . splitAt
10:30:41 <chrisdone> albeit: something like that
10:33:09 <albeit> chrisdone, merijn: Thanks
10:33:59 <dfeuer> Split and concat should be a lot cheaper for lazy Text than for String though, right?
10:34:06 <dfeuer> Since it's (I think) chunked?
10:43:55 <fizbin> > sort [1..]
10:43:59 <lambdabot>  mueval-core: Time limit exceeded
10:44:16 <fizbin> > sort [1..123456789]
10:44:21 <lambdabot>  mueval: ExitFailure 1
10:44:34 <fizbin> > sort [1..12345678]
10:44:40 <lambdabot>  mueval: ExitFailure 1
10:44:48 <fizbin> > sort [1..1234567]
10:44:49 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
10:44:53 <jacereda> when writing bindings to external OO libraries, is putting the object as the last argument idiomatic? I mean, so it can be instantiated as:  newFoo >>= setBar 3 >>= setBaz 4 >>= ...
10:45:34 <adnam> jacereda: i think that makes the most sense
10:45:53 <chrisdone> ordering for composition like that is pretty common
10:45:58 <jacereda> ok, thanks
10:46:02 <fizbin> jacereda: I would look at the order of arguments on the functions in Data.Map and Data.Set, and follow that.
10:46:14 <fizbin> (Which will lead you to the same place you already found)
10:48:37 <fizbin> jacereda: Also for argument ordering think of how people might want to call your functions inside a foldr and make doing that convenient.
10:48:45 <jacereda> fizbin, newbie here... why Data.Map? So you can use folds
10:48:46 <jacereda> ?
10:49:12 <jacereda> I see... ok
10:49:48 <codygman-> I'm doing coldfusion at work and it depresses me. Is there a #haskell-recovery for haskeller's who have to work in such mundane languages?
10:49:50 <fizbin> jacereda: I'd use Data.Map as an example because the OO world is pretty uniform about how Maps in an OO language should work, so it forms a good place to look for Haskell <-> OO analogies.
10:50:34 <fizbin> codygman-: Something like http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems ?
10:51:41 <RobDonley> What Haskell library should I learn for finding files and working with directories? There are many packages for this like directory-tree, filemanip and filepather
10:52:00 <codygman-> fizbin: Perhaps doing those during lunch and smoke breaks could be an adequate coping mechanism.
10:52:08 <RobDonley> Which of them is more modern and should I be using? I'm a haskell newbie
10:52:41 <codygman-> RobDonley: http://hackage.haskell.org/package/directory
10:52:50 <codygman-> I use that one
10:54:16 <circ-user-5R2og> hello
10:54:25 <circ-user-5R2og> anyone here uses SublimeHaskell?
10:54:50 <RobDonley> codygman: OK. Thank you.
10:55:36 <dcoutts_> RobDonley: it's certainly useful to be familiar with the basic directory package as codygman- suggests. As for more advanced file search, you may need to review the docs / apis of those other packages you mentioned.
10:56:14 <dcoutts_> RobDonley: and along with directory (System.Directory) you also need to know about System.IO for opening and working with file handles
10:56:24 <dcoutts_> System.IO is from base
10:56:54 <dcoutts_> RobDonley: the other very important one is System.FilePath from the filepath package.
10:57:32 <dcoutts_> RobDonley: those together cover most use cases, and then it's only if you need special directory search that you might want extra packages
10:59:04 <RobDonley> dcoutts_: Ok. I'll study those. Thx.
11:00:04 <gridaphobe> does anyone use cabal's detailed test-suite type? the docs say to use detailed-1.0, but cabal-1.20 says that's not a valid type. if i try the recommended detailed-0.9 instead, i get an error about a non-existent module Distribution.Simple.Test.LibV09
11:00:40 <dcoutts_> gridaphobe: it's actually still at version 0.9, and no there's not much support for it yet
11:00:53 <gridaphobe> ok :)
11:02:29 <dcoutts_> gridaphobe: it's a good idea, but it's not ready yet, needs more work to be convenient.
11:02:30 <luite> i think only one package on hackage uses it
11:03:23 <merijn> So what are you supposed to use? exitcode?
11:03:24 <karshan_> Hello, do you think it is a good idea to have all the node types of an AST for a language (like java for example) to be an instance Traversable ?
11:03:50 <simpson> karshan_: There's a very cool set of things that can be done if it's a Functor, at least.
11:03:54 <merijn> karshan_: If your AST can be a lawful Traversable instance, then yes. But I'm not too convinced it can be
11:04:48 <luite> karshan_: it's useful if you have annotations for an AST, Traversable can then be used to modify them or pull them out
11:04:55 <adnam> karshan_: you may want to look at uniplate
11:05:09 <johnw> is uniplate recommended over syb?
11:05:19 <adnam> depends on what you want to do i suppose
11:05:32 <simpson> Use lens, makeLenses ``YourAST, then use the lens versions of uniplate.
11:05:34 <johnw> I typically use lens where I would have reached for uniplate
11:06:00 <adnam> i've barely touched syb, it seems to be some middle ground between uniplate and generics
11:06:28 <luite> karshan_: but look at the type, you need something in the nodes of type a
11:06:36 <albeit> For anyone familiar with fast-logger, does it evaluate the log str before it adds it to the buffer?  It seems to be doing so in this example... http://lpaste.net/111862. Is there any way to have it convert the time to a string in its own thread?
11:07:17 <johnw> albeit: sure, call addMsg in its own thread
11:07:27 <ReinH> johnw: hi!
11:07:29 <karshan_> Interesting. I'm going to go do some research on Control.Lens.Traversal and uniplate
11:07:34 <johnw> ReinH: hi!!!
11:07:40 <ReinH> johnw: ltns!
11:07:43 <johnw> I know!
11:07:48 <johnw> not since I left for ICFP
11:07:53 <luite> karshan_: also see Data.Data.Lens / Control.Lens.Plated for more convenient tree traversals and pulling out (or rewriting) things of a particular type
11:07:55 <johnw> a month ago today
11:07:58 <ReinH> johnw: welcome back :)
11:08:01 <johnw> thk
11:08:41 <luite> karshan_: Traversal / Traversable don't give you recursive rewrites
11:10:11 <karshan_> luite: I see. So how about for the specific case of say filtering out all nodes of some type within an AST. would Data.Data.Lens/ Control.Lens.Plated be the right way to do that ?
11:10:12 <luite> karshan_: but Control.Lens.Plated does (and it subsumes uniplate, and syb to some extent)
11:10:41 <karshan_> luite: Or having some type constructor*
11:11:21 <albeit> johnw: Aha! So it really is okay to spawn 100,000 new extremely short-lived threads (a new thread every ~10 microseconds)?
11:11:31 <albeit> * every second
11:11:40 <johnw> albeit: they are necessarily "threads"
11:11:44 <johnw> they are *incredibly*
11:11:45 <johnw>  cheap
11:11:46 <johnw> so, yes
11:11:51 <johnw> s/are/aren't
11:12:50 <albeit> johnw: Okay. How are they so cheap? (links would be great if you don't want to explain)
11:13:49 <johnw> (sorry, on the phone, in case anyone else can chime in)
11:14:11 <luite> karshan_: template can give you everything of a particular type out of a structure, you could do something like (stat %~ template . to stringLitToUpper), stringLitToUpper :: StringLit -> StringLit, to rewrite all your string literals in some statement
11:15:16 <karshan_> luite: thats awesome, thanks!
11:15:18 <luite> karshan_: everything needs to be Data and Typeable for that
11:17:15 <luite> karshan_: I'm just in the middle of refactoring the GHCJS intermediate rep and I'm using these things quite often :)
11:18:07 <luite> karshan_: all nodes have some annotation that varies depending on where in the compilation pipeline the code is
11:18:55 <trap_exit> when using the haskell-haste compiler, how do I tell it "don't fucking generate a *.hi file" ? (Prefer answers that do not involve "use ghcjs instead" :-) )
11:19:09 <luite> but those are the best answers!
11:19:45 <luite> trap_exit: i'm assuming it overwrites your native code .hi files and you don't want that?
11:19:48 <trap_exit> luite: implement Haste.App in ghcjs, and I'll probably switch back :-)
11:20:09 <trap_exit> luite: well, I just want all my "ghc ..." go to into .build and my "haste ..." to go into .haste-build
11:20:15 <trap_exit> and only see *.hs files and directories
11:20:30 <luite> trap_exit: if you build with cabal, you can specify a dist dir
11:20:37 <trap_exit> ghc is very obedient, it
11:20:39 <trap_exit> hmmm
11:20:45 <trap_exit> okay
11:20:46 <luite> if you invoke ghc manually, you can use hidir/odir
11:20:47 <trap_exit> I will use cabal then
11:20:55 <trap_exit> yes yes, I got ghc to work
11:20:57 <trap_exit> haste is not listening to me
11:21:18 <luite> i'm not sure if haste supports that directly since it doesn't use the whole ghc command line front end
11:21:29 <trap_exit> luite: ha, it supports it
11:21:29 <karshan_> luite: interesting. I really should try GHCJS out, it looks like its got a lot better. All these lens types have me really confused though, say I have an (a :: CompilationUnit) which has (xs :: MethodInvocation) in it, can I use view and template to view all the xs out ?
11:21:31 <trap_exit> luite: thanks!
11:21:44 <trap_exit> luite: you're amazing, this is like bill gates fixing someone's macbookpro
11:22:00 <circ-user-5R2og>  anyone here uses SublimeHaskell? Or knows where I can get help with it
11:22:28 <glguy> circ-user-5R2og: If you have a question about it you should ask that question directly
11:22:30 <luite> trap_exit: well my macbook pro is broken,d o you think i should ring him up?
11:22:40 <circ-user-5R2og> sorry
11:22:46 <circ-user-5R2og> I'm trying to run it
11:22:58 <circ-user-5R2og> but ModuleInspector fails to compile
11:22:59 <luite> trap_exit: right, that's what i guessed, haste does use parseDynamicFlags, and they are part of that :)
11:23:12 <circ-user-5R2og> and I get a " Not in scope: data constructor `H.PNeg' "
11:23:19 <circ-user-5R2og> Perhaps you meant `H.PRec' (imported from Language.Haskell.Exts)
11:23:24 <trap_exit> luite: oh, I fixed my mbp
11:23:32 <trap_exit> luite: it was the most fucking intense install ever
11:23:46 <circ-user-5R2og> I've tried updating haskell-src-exts, but I already have the latest version
11:23:48 <trap_exit> luite: I had to (1) download [via app store] OSX Lion [not just the wimpy recovery cd tool thing]
11:24:00 <trap_exit> luite (2) take apart the OSX Lion install to find this 4.7 GB file
11:24:04 <luite> karshan_: (a ^.. template) :: [MethodInvocation] will give you a list of all of them
11:24:08 <trap_exit> luite: (3) burn this 4.7 GB file to a usb disk, and boot from there
11:24:31 <codygman-> Does anyone here use hell or shelly (or hell with shelly) or anyother haskell shells?
11:24:42 * hackagebot buildwrapper 0.8.9 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.8.9 (JeanPhilippeMoresmau)
11:26:46 <alrunner4> codygman-: i'm working with Shelly atm
11:28:39 <luite> karshan_: although that assumes that a MethodInvocation doesn't contain another MethodInvocation, if you want that, you probably should use Control.Lens.Plated things
11:29:20 <luite> karshan_: (tree rewrites are not traversals, they'd break the laws)
11:32:22 <circ-user-5R2og> When using SublimeHaskell ModuleInspector fails to compile and I get this error: " Not in scope: data constructor `H.PNeg'     Perhaps you meant `H.PRec' (imported from Language.Haskell.Exts)"
11:32:27 <circ-user-5R2og> anyone knows why?
11:32:27 <luite> karshan_: GHCJS' installation procedure is much better now, thanks to rewritten installation scripts and the change to run Template Haskell and Cabal setup.hs scripts on node.js. libraries are still a bit lacking though, and optimizing code size is tricky. I'm working on the latter now, changing the AST so that the optimizer can do a better job and make it much more minifier-friendly (and also giving us source maps)
11:36:27 <rrradical> are there any tutorials (aside from the docs) on Control.Lens.Plated?
11:38:08 <trap_exit> when using Make, how do I force a command to be executed, but not displayed, i.e. << echo "building-ghc" ... >> <-- this shows the echo commnad, but I wnat the echo command to execute without showing the command
11:38:16 <lispy> when someone says json and lispy in the same sentence it's hard for me to not think they are talking to me
11:38:32 <trap_exit> i don't like lispy languages any more
11:38:50 <trap_exit> haskell, if you squint, supports data as code, code as data, which is sorta lispy
11:38:52 <lispy> no but lispy is my IRC name and my IRL name is jason...
11:39:08 <trap_exit> template haskell is lispy
11:39:11 <luite> rrradical: hmm, not that I know of
11:39:22 <trap_exit> lispy: you should change your legal name to json :-)
11:39:29 <geekosaur> trap_exit, in makefile syntax, precede the command with @
11:39:37 <geekosaur>     @echo "hi"
11:40:14 <trap_exit> geekosaur: worked, thanks! glad to see you survived the meteorites
11:40:20 <lispy> trap_exit: http://www.drdobbs.com/tools/debugging-makefiles/197003338
11:40:42 <lispy> (or maybe I misunderstood the query)
11:40:45 <trap_exit> lispy: I don't need something that complicated ... I just wnat a visual separation of ghc warnings and haste warnings
11:40:52 <trap_exit> lispy: my makefile calls both ghc and haste
11:41:01 <trap_exit> I want to separate ghc and haste warnings, so my brain knows how ot fix it
11:41:08 <trap_exit> (since ghc + haste compile off of the same *.hs files)
11:41:32 <lispy> Sorry, I thought you wanted something else
11:42:04 <trap_exit> nope, not debugging makefiles
11:42:37 <albeit> I have a bunch of threads send log messages to a Logger. To the greatest extent possible, I want them to output according to their timestamp (an Int). Would it make sense to collect them in a sorted list, then when the list gets to a certain size (say 1000 message), output all the collected messages?
11:43:18 <c_wraith> albeit: you're better off just dumping them in the order they're ready, and letting the log analysis software handle the sorting.
11:43:45 <c_wraith> albeit: log analysis software is very good at that now - near-sorted data has good algorithms available specifically because of this problem
11:44:06 <albeit> c_wraith: Any suggestions for log-analysis software?
11:44:17 <napping> also you wouldn't want to lose log entries
11:45:13 <c_wraith> albeit: huh.  I never paid attention.  I let the ops guys handle it, because they were good at it.
11:49:28 <albeit> Hmm... not Haskell specific, but is it possible to read-only a file and react to new writes (from other programs) to that file?
11:50:06 <Hijiri> blaze-html has both toHtml and preEscapedToHtml, does that mean toHtml will escape any HTML in the argument?
11:50:21 <Hijiri> Or do I have to do it explicitly some other way
11:53:30 <srhb> albeit: Sounds like inotify
11:56:28 <srhb> albeit: Something like initINotify >>= addWatch [Modify] filepath whatToDo
11:57:08 <albeit> srhb: That looks perfect, thanks!
11:58:21 <hiptobecubic> This seems like something people in here will have read. I *imagine* it's still a good read, but are there any opinions to the contrary here now? http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf
11:58:59 <hiptobecubic> Not necessarily "don't read it" but more like "It's out of date with respect to _____"
11:59:12 <hiptobecubic> The same way RWH is out of date wrt exception handling
12:05:02 <karshan_> luite: Wow, lenses are amazing. (a ^.. template) :: [MethodInvocation] worked. Unfortunately a MethodInvocation can contain another MethodInvocation. I'm going to try an understand how this works first and then user Control.Lens.Plated. Also installing GHCJS now
12:09:32 <elben> Is there a specific reason why laziness was part of Haskell’s design? That is, does the type system and/or purity produce a language where lazy-by-default is superior or at the very least fitting? Not a haskell programmer, but trying to learn more.
12:09:47 * hackagebot base-prelude 0.1.5 - The most complete prelude formed from only the "base" package  http://hackage.haskell.org/package/base-prelude-0.1.5 (NikitaVolkov)
12:11:06 <shachaf> It is more that laziness was a motivation for keeping purity, if anything.
12:11:14 <shachaf> (Though certainly not the only one.)
12:11:52 <napping> elben: it was the reason for even having Haskell really
12:12:03 <shachaf> Laziness wasn't desirable because of the type system in particular, just for other nice properties.
12:12:14 <napping> Not necessarily because laziness is desireable or whatever
12:12:31 <napping> but because various researchers were studying laziness with their own little languages
12:12:56 <napping> Haskell explicitly started to be a unified lazy research language
12:13:01 <elben> This is an interesting part of Haskell’s history for me, the fact that haskell’s origina main purpose was a united lazy language, but now it’s known more for its type system and purity
12:13:23 <elben> at least that’s what people talk about when arguing for it
12:13:31 <josephle> it's not like you can't do laziness in a strict language
12:13:46 <josephle> the MLs have laziness libraries, for example
12:13:58 <napping> Now, people were studying laziness because it looks like it would be nice, and it's worked well enough
12:14:34 <napping> But yeah, the laziness was a design goal in it's own right
12:14:43 <napping> well, lazy and typed, I think
12:15:31 <davidthomas> elben: Given laziness, there's strong reasons to want purity and a good type system to enforce it...
12:16:17 <davidthomas> (see the SPJ talk entitled "Wearing The Hair Shirt")
12:16:27 <napping> The type system hasn't been much nicer than any ML until recently
12:16:28 <elben> i’ve never thoguht about it that way
12:16:44 <newsham> hi shachaf
12:16:52 <shachaf> hi
12:17:13 <newsham> so are you saying I can make "data Foo a = Stuff | Sorry a"  and then auto derive using Maybe?
12:17:15 <napping> well, type classes are pretty nice, but little fanciness beyond the likes of O'Caml (and missing some stuff like nice modules)
12:17:18 <newsham> with that extension?
12:17:26 <shachaf> newsham: No, only for newtypes (hence the name).
12:17:49 <newsham> oh..  yah.. i'm already familiar with that.. that was what I was suggesting augur use originally
12:17:53 <napping> Getting fancy stuff like GADTs and type families and whatever is relatively recent
12:18:04 <newsham> and he was saying he prefers to have new constructor names for code readability (pattern matching, etc)
12:18:25 <newsham> and so we were saying "it would be neat if you could declare an isomorphism and then ask it to derive using that"
12:18:33 <shachaf> Oh. Well, I did say I don't know of anything for any other isomorphisms.
12:18:46 <newsham> iso Foo Maybe where ...   derivin ....
12:19:07 <newsham> so that you can auto get:   fmap f = fromMaybe . fmap f . toMaybe
12:19:31 <shachaf> Declare an iso and then use over.
12:19:38 <napping> elben: rather, types are a perfectly good reason for saying Haskell is worth looking at compared to other languages, but types aren't necessarily a reason for looking at Haskell in particular
12:19:44 <shachaf> fmap f = over yourIso (fmap f)
12:19:54 <shachaf> That's if you're already using lens, that is.
12:19:55 <napping> laziness and purity are much more unique
12:19:55 <newsham> indeed.  thats the proper way to do it
12:20:03 <newsham> but it owuld be nice if an extension did the boilerplate for you
12:20:16 <newsham> perhaps a TH hack waiting to happen
12:20:51 <newsham> ?hoogle over
12:20:53 <lambdabot> Graphics.UI.GLUT.Callbacks.Window overlayDisplayCallback :: SettableStateVar (Maybe DisplayCallback)
12:20:53 <lambdabot> Graphics.UI.GLUT.Overlay overlayPossible :: GettableStateVar Bool
12:20:53 <lambdabot> Graphics.UI.GLUT.Overlay overlayVisible :: SettableStateVar Bool
12:20:57 <shachaf> It's in lens.
12:21:00 <newsham> danke
12:21:20 <newsham> https://hackage.haskell.org/package/lens-4.4.0.2/docs/Control-Lens-Iso.html
12:23:47 <newsham> lens is still scary to me
12:24:01 <newsham> i'll put it off until october
12:24:10 <simpson> newsham: That's tomorrow.
12:24:16 <newsham> you're clever
12:24:31 <newsham> or at least up on current events :)
12:24:35 <shachaf> lens is simple from the right perspective.
12:24:54 <newsham> shachaf: sure, but its data types are very general, which sometimes makes it hard to approach
12:25:20 <newsham> over :: Profunctor p => Setting p s t a b -> p a b -> s -> t
12:25:36 <napping> I think most of the complexity there is using lens
12:25:54 <newsham> would be neat if the bot had a cmd to simplify types by specializing them
12:26:34 <shachaf> lens types are often simplified by making them more general.
12:26:35 <napping> The types of actual lens like (Functor f) => (a -> f b) -> (s -> f t) are not too bad
12:26:53 <shachaf> Which is why the documentation has a bunch of fake types next to every function.
12:27:36 <napping> Then the huge sprawing mess of the rest of it just answers to the questions like "what cunning choice of Functor f will let me read a value? replace a value?"
12:27:58 <shachaf> Those are only slightly cunning at best.
12:28:11 <newsham> ?blackadder
12:28:11 <lambdabot> Unknown command, try @list
12:28:13 <newsham> :(
12:28:16 <napping> those particular ones are not so bad, no
12:28:47 <shachaf> Start from the perspective of ((a -> b) -> s -> t), and then generalize it by adding f.
12:28:49 <napping> Stuff like that Setting p s t a b bakes in at least some of the specialization that over uses
12:29:18 <shachaf> It's obvious that f=Identity gets you back to the original thing you had. And using Writer for f is the way to log values as you see them.
12:29:26 <napping> instead of writing a higher-rank types that requests you give it a lens that's completely polymorphic in a functor or whatever
12:29:33 <shachaf> It's only a small jump from Writer to COnst
12:32:00 <jacereda> what's the idiomatic way to call a certain number of 'IO ()' functions with the same argument?
12:32:03 <napping> One of the key observations was that a type like (Applicative f) => (a -> t b) -> s -> t b lets you write lenses that refer to some or many functions
12:32:33 <shachaf> jacereda: What's an IO () function?
12:33:07 <napping> so then something like "over" that uses a choice of Functor that's also Applicative would work fine on those too, which is another reason for funny type signatures that are a bit more concrete about how the operator is implemented
12:33:32 <napping> jacereda: mapM_ ($ arg) is probably a decent start
12:34:04 <shachaf> napping: That's only unusual if you think of it from the perspective of lenses.
12:34:25 <shachaf> But e.g. "SECs" by various names have been around for a long time before that.
12:34:38 <shachaf> And adding Applicative is as straightforward a next step as turning map into mapM.
12:34:53 <napping> what's "SECs"?
12:36:21 <shachaf> conal's name for it. http://conal.net/blog/posts/semantic-editor-combinators
12:38:28 <jacereda> napping,shachaf, let me lpaste some code, maybe I'm just having an XY problem...
12:39:28 <jacereda> http://lpaste.net/111877
12:39:45 <Haskellfant> I got a cabal conflict and I have no idea how to resolve this, any ideas? http://sprunge.us/UBMS
12:39:51 <jacereda> as you can see, there're several places where I create an object and then call various setters
12:39:59 <jacereda> those setters don't return any value
12:39:59 <Zouppen> I'm stuck in Debian Wheezy on armhf architecture and I need to build aeson. How in the heck the aeson package is ever built on Debian if it's impossible to build them using cabal? I get "Template Haskell bracket illegal in a stage-1 compiler" when it tries to compile Data.Aeson.TH. I need to recompile it because another dependency requires rebuilding of aeson
12:40:34 <jacereda> that code is too 'C', what would you do to make it more idiomatic?
12:41:28 <ReinH> What is this ".new"?
12:41:30 <Zouppen> My ghc version is 7.4.1 on that platform. Is there any way to build aeson, even an old version of it?
12:41:38 <ReinH> That's the only part that bothers me.
12:42:00 <Zouppen> the issue seems to be Template Haskell and lack of ghci....
12:42:17 <jacereda> My code code is instantiating javascript objects (this is Haste)
12:42:31 <ReinH> Ahh.
12:43:18 <jacereda> new :: IO Clock    new = ffi "(function(){return new THREE.Clock();})"
12:46:00 <hughfdjackson> what's everyone's favourite commandline option parser?
12:46:20 <hughfdjackson> http://www.haskell.org/haskellwiki/Command_line_option_parsers <- there's quite a few choices !
12:46:32 <napping> optparse-applicative is way nicer than GetOpt
12:47:08 <hughfdjackson> napping: awesome - thanks :)
12:47:56 <Haskellfant> is there something wrong with transformers 0.4 or why does even the ghc package depend on 0.3 (and cause my cabal builds to fail)
12:48:45 <napping> I'm not sure what the multi-mode thing is supposed to be, but it shouldn't be different between cmdargs and optparse-applicative if it's something about subcommands
12:49:48 <napping> Is there any way to reflect a functional dependency as an associated type?
12:51:26 <jacereda> napping, so, is this an acceptable use of mapM_? "mapM_ ($ light) [setCastShadow True, setPosition nlpos, setName "light", add scene]"
12:51:34 <jacereda> looks convoluted...
12:52:09 <ReinH> jacereda: I don't think it's any better than just writing them out
12:52:11 <Hijiri> it seems readable to me
12:52:38 <ReinH> I understand what it means but I would prefer setCastShadow True light; setPosition nlpos light ...
12:52:50 <napping> It's a matter of style
12:53:01 <ReinH> Everything is more or less a matter of style
12:53:10 <jacereda> so, is http://lpaste.net/111877 acceptable?
12:53:13 <joseph07> jacereda: It might be nice to extract that pattern to a function, so you could do something like setup light [setCastShadow True...]
12:53:17 <ReinH> I don't think the added line noise is a good tradeoff
12:53:27 <napping> at the very least, I'd try to format the list more nicely
12:54:19 <ReinH> If you're writing do notation you've already chosen to write in an imperative style...
12:54:32 <ReinH> So itt seems like mixed metaphors as well
12:54:44 <napping> sure, but I think extracting this sort of code is a reasonable step in refactoring it to a less imperative style
12:55:07 <jacereda> ReinH, but is there an alternative when interfacing to external javascript libs?
12:55:24 <albeit> How is the garbage collector triggered? Does it require something about to generate a large amount of data to trigger, or does it collected at a regular interval?
12:56:15 <ReinH> jacereda: Do notation can always be desugared.
12:56:35 <ReinH> napping: you can extract that whole block and wrap it with a do though :)
12:56:41 <ReinH> You don't need to write it with mapM_
12:56:59 <jacereda> joseph07, yes, a setup function sounds good
12:57:28 <napping> writing it out explicitly is probably a local maximum in readability, but there's also probably significant improvements from cleaning up things a bit more
12:57:45 <geekosaur> albeit: somewhere in between, as I understand it. in the normal case there's a timer that goes off regularly and maintains a counter; when you do an allocation, the counter is checked and a GC happens if needed. you can also run in a mode which disables the timer and it does it every some number of allocations instead
12:58:22 <jacereda> ReinH, wrap it with a do? like what?
12:58:24 <napping> geekosaur: isn't that thread switching?
12:59:01 <ReinH> jacereda: just take that block, extract it into a function that takes a `light' argument, and use a do at the top of the function
12:59:07 <ReinH> and you can extract it verbatim
12:59:17 <napping> That's especially nice if you can use it multiple times
12:59:38 <napping> But also, having a notion of a "current object" in setup code might be nice
12:59:51 <geekosaur> napping: compare +RTS -Vn to +RTS -Cn
13:00:02 <ReinH> Then you might want to parameterize the light, then you might want to create a light parameters data type, then you might start writing your own DSL for describing your scene :)
13:00:27 <napping> or, working towards a more declarative reading of [setPosition x y, setCastShadow True] as a list of properties
13:00:39 <ReinH> right
13:00:45 <albeit> geekosaur: Thanks
13:00:53 <napping> ReinH: and getting a nice little DSL is exactly why I wouldn't be too quick to write off refactoring through mapM_
13:01:22 <napping> but maybe something like addNew create init = do obj <- create; init obj; add
13:01:30 <ReinH> An alternative would be to change the argument order a bit and use ReaderT
13:01:59 <napping> you shouldn't have "add" in the list of actions if that's what you're going for, though
13:02:20 <napping> maybe addNew scene create init = do obj <- create; init obj; add scene obj
13:03:12 <napping> then you'd get little blocks like addNew scene (Light.newAmbient lc) $ \alight -> do setPosition alpos alight
13:03:36 <jacereda> any way to avoid repeating the 'alight' in all the setters?
13:03:45 <asfp> Does ghc head use transformers 0.4 and mtl 2.2?
13:03:49 <ReinH> That one is a simple eta reduction
13:03:56 <ReinH> well, and desugaring
13:04:17 <ReinH> addNew scene (Light.newAmbient lc) >>= setPosition alpos
13:04:41 <jacereda> but if there's also a setName "foo" after the setPosition?
13:04:49 <jacereda> those setters don't return the object
13:04:59 * ReinH shrugs
13:05:12 <ReinH> if you're really determined to hide the parameters, you can use ReaderT
13:05:42 <jacereda> I could change the bindings to return the object after setting the property if that was more useful, but looks wasteful
13:05:55 <jacereda> and confusing
13:06:10 <napping> I think separately calling the function on each argument is rather clearer than somehow chaining it through
13:06:13 <jacereda> because it isn't returning a new object, just the mutated one
13:06:38 <napping> that's just absurd, and suggests it might be returning a fresh object, or that maybe it doesn't have side effects and just returns a modified object or whatever
13:06:41 <jacereda> ok, so just some refactoring would make it acceptable, right?
13:08:00 <jacereda> and what's the usual way to write a DSL based on an external library? maybe making a dumb wrapper first and then writing the DSL on top?
13:08:07 <srhb> That "How we might abolish cabal hell" post has me feeling all giddy and optimistic. Somehow I think I'll be let down, especially since I have no idea what will happen. :P
13:08:26 <asfp> yes, ghc head uses transformers 0.4.1 but no mtl.
13:08:27 <lpaste> PatientZero pasted “How can I simplify this function?” at http://lpaste.net/111881
13:09:00 <amf> is there a library that is for constructing data "pipelines" of any key / value types where functions that know how to sort / reduce / etc can be derived?
13:09:02 <napping> jacereda: that's probably best, a very straightforward wrapper and then a nice API
13:09:05 <PatientZero> Hi guys - just wrote something quite awkward and inelegant for doing something pretty simple
13:09:12 <PatientZero> same "xxxx" = Just 'X'
13:09:24 <jacereda> ok guys, thanks for your help
13:09:29 <PatientZero> same "xyx" = Nothing
13:10:23 <srhb> PatientZero: foldr (==) True xs ?
13:11:02 <shachaf> PatientZero: same [] = Nothing; same (x:xs) | all (==x) xs = Just x | otherwise = Nothing
13:12:50 <PatientZero> srhb that unfortunately does not work
13:12:56 <srhb> PatientZero: No, I realized you want the x
13:13:02 <srhb> I thought it was just weird filler at first. :-)
13:13:25 <srhb> "WHY WOULD ANYONE WA-- oh.."
13:13:37 <shachaf> foldr (==) True is a pretty strange function anyway.
13:13:39 <Haskellfant> is it possible to configure cabal so that cabal test shows more info than 1 of 1 test suites (1 of 1 test cases) passed.
13:13:58 <srhb> shachaf: No kidding
13:14:07 <Haskellfant> I would like to see the number of examples
13:14:53 <J_Arcane> Is it possible to turn off the nag on first loading a file into ghci from Emacs haskell-mode? I'm just working through some early chapters in Learn You a Haskell, and it's a mite annoying.
13:15:02 <shachaf> srhb: It's true if you have an even numbers of Falses in the list.
13:15:12 <srhb> shachaf: Very useful I tell you!
13:16:29 <J_Arcane> I don't want to 'start a new project' every time I want to load into ghci ...
13:17:04 <egasimus> Another stupid beginner's question: how do I get from `Maybe (IO Something)` to `IO (IO Something)`?
13:17:06 <srhb> J_Arcane: I think you're stuck using the inferior repl for that
13:17:16 <srhb> J_Arcane: haskell-interactive will break without project files
13:17:58 <srhb> J_Arcane: So probably just bind something to inferior-haskell-load-file for one-offs that use your user repo
13:18:20 <shachaf> egasimus: That depends. What do you want to do if it's Nothing? What do you want to do if it's Just (x :: IO Something)?
13:18:28 <shachaf> egasimus: Also, please don't call beginners or questions stupid in here.
13:18:48 <J_Arcane> srhb: Ahh, bugger. Well, I suppose it's no big annoyance, it only does it the once anyway.
13:19:14 <srhb> J_Arcane: I personally use the inferior repl for one-offs like what you find in LYAH. It works fine. I have it bound to C-u C-c C-l
13:19:51 <egasimus> shachaf: good point. :)
13:19:53 <srhb> J_Arcane: You could even wrap it in a detectotron that sees if there's a cabal repo owning this particular file and then decide which process type to start
13:20:14 <PatientZero> srhb: http://hackage.haskell.org/package/base-4.7.0.1/docs/src/GHC-Exts.html#the seems promising
13:20:37 <srhb> PatientZero: Um?
13:20:40 <shachaf> PatientZero: the just crashes if all the elements aren't equal.
13:20:51 <shachaf> PatientZero: But I already gave you an implementation of same above.
13:21:30 <egasimus> shachaf: well, I'm trying to connect to DBus, but if that fails then just move on to the next thing. In both cases I'd like to putStrLn a status message.
13:23:26 <merijn> egasimus: "Maybe (IO Something)" doesn't sound like the correct type for "trying to connect to DBus"
13:23:35 <merijn> egasimus: Don't you want/mean "IO (Maybe Something)"?
13:24:26 <rfn> \quit
13:24:32 <egasimus> merijn: hmm, maybe. let's see if I can make that work.
13:25:44 <merijn> egasimus: i.e. "perform an IO action that tries to connect to DBus and returns Nothing on failure and Just on success"?
13:26:06 <albeit> Is there any way to monitor the garbage collector from within a Haskell program? To tell how "full" the allocation counter is? And maybe even to force collection?
13:26:26 <merijn> albeit: You can force collection, but I'm not sure you can monitor it at run time
13:26:36 <merijn> albeit: There's the memory profiler for monitoring it externally, though
13:27:10 <egasimus> merijn: I think so; but my `open` function already returns `IO Socket`, so I end up with `IO (Maybe (IO Socket))`... how do I unwrap that?
13:27:47 <srhb> Why do you "end up" with that?
13:28:03 <carp_> Hi, anyone here from southwest england?
13:28:08 <albeit> merijn: Ah, perform(Major/Minor)GC, cool
13:28:08 <srhb> I assume open may throw some kind of exception
13:28:34 <geekosaur> albeit: is there a particular reason you need to do that? usually people who think they need to do that have been trained by Java, whose garbage collector seems to need some amount of babying
13:28:35 <egasimus> srhb: pulseConnect :: Maybe String -> IO (Maybe Socket); pulseConnect (Just s) == return $ maybe Nothing (Just . open) $ parseAddress s
13:29:19 <geekosaur> ghc's gc, even on stop-the-world mode, isn't usually as disruptive
13:29:30 <albeit> geekosaur: Not coming from Java, but there are some times in my program where the garbage collector running would be very bad, and other times where I know it has "extra" time to run garbage collecting safely
13:29:42 <srhb> egasimus: Erm...
13:29:52 <lpaste> PatientZero pasted “my best answer to previous question” at http://lpaste.net/111882
13:29:53 <egasimus> srhb: that's as far as my haskell goes currently, I'm afraid. took me a while to figure out even that.
13:30:15 <srhb> egasimus: OK. Well, first I'd get rid of the Maybe in the first argument
13:30:26 <geekosaur> if you really need that kind of control, you'll probably need to ask in #ghc or on the glasgow-haskell-users mailing list
13:30:52 <albeit> geekosaur:  As long as I can trigger an immediate collectionI should be okay... monitoring would be nice but not necessary
13:31:02 <geekosaur> @index performGC
13:31:02 <lambdabot> System.Mem
13:31:29 <srhb> egasimus: But other than that you now have an IO (Maybe Socket) -- not the weird wrapped type you claimed before :)
13:31:57 <Cale> egasimus: Something important to understand: A value x of type IO String, for instance, is nothing at all like a String, any more than /bin/ls is like a list of files.
13:31:57 <egasimus> srhb: I don't think I can do that
13:32:17 <srhb> egasimus: then pulseConnect addr >>= \ms -> case ms of Nothing -> ... Just s -> ...
13:32:20 <Cale> egasimus: It's a description of some steps which could be executed to produce a String
13:32:24 <egasimus> Cale: thanks, that's a good example
13:33:00 <Cale> egasimus: Inside of a do-block, you can write v <- x, which means "execute the action x, and call its result v", in the case that x :: IO String, then v :: String
13:33:19 <Cale> egasimus: and the do-block as a whole will denote some action of type IO t for perhaps some other type t.
13:33:23 <egasimus> srhb, Cale: it might be best if I just pasted what I'm doing
13:33:28 <srhb> > fmap error Nothing -- egasimus
13:33:28 <Cale> (it will be the type of the last action in the block)
13:33:29 <lambdabot>  Nothing
13:33:48 <srhb> anyway, yeah, paste away
13:35:09 <egasimus> http://pastebin.com/jSYaQ1n8
13:35:39 <egasimus> I basically need to connect to the session bus so I can retrieve the location of the socket for the PulseAudio bus from it, and connect to that
13:35:48 <Cale> egasimus: So, if you want to write an IO action which makes use of some action, say getSocket of type IO Socket, *probably* what you want to do is to write  do ... ; s <- getSocket ; ... use s :: Socket here ...
13:37:00 <Cale> egasimus: Yeah, you're using pulseConnect as if it's going to produce an IO action
13:37:39 <Cale> So, the first thing I'd probably do with socketPath :: Maybe String is to immediately take it apart and deal with the case that it's Nothing directly in main
13:37:41 <egasimus> (ignore the double call to pulseConnect, it was either the single line or the whole case block)
13:38:14 <Cale> However, if you don't want to do that, we can of course write pulseConnect in such a way that it takes a Maybe String value like you have now
13:38:38 <Cale> But *probably* you want pulseConnect to produce an IO (Maybe Socket)
13:39:24 <Cale> In the case that the Maybe String value is Nothing, the action should probably be a no-op which simply produces Nothing as its result, and that's what (return Nothing) is.
13:39:31 <Cale> So, you'd have
13:39:34 <egasimus> Cale: bingo
13:39:38 <Cale> pulseConnect Nothing = return Nothing
13:39:45 <Athas> How do I make GHCi prefer a specific version of packages when resolving module imports?
13:40:18 <Cale> And then we have the case that it's Just s
13:41:24 <geekosaur> Athas: I think, ghci -package name-version
13:41:33 <Cale> pulseConnect (Just s) = case parseAddress s of Nothing -> return Nothing; Just a -> do s <- open a; return (Just s)
13:41:41 <Cale> Now we could get rid of some of the noise here
13:41:50 <Athas> geekosaur: hm, then I am probably in Cabal hell for other reasons.  Oh well.
13:41:52 <egasimus> (just to clarify because I obviously don't know enough to tell how obvious it is -- parseAddress :: String -> Maybe Address)
13:42:06 <Cale> Yeah, I figured it was something like that
13:42:47 <Cale> So, we can tidy this up a bit by using the fact that Maybe is also a monad, but I wanted to get the simple pattern matching version out of the way first
13:43:11 <Cale> Does the code above make sense?
13:43:29 <Cale> This will mean that pulseConnect :: Maybe String -> IO (Maybe Socket)
13:43:41 <egasimus> Cale: it all makes sense so far; and it's good having someone guide you through the thought process, thanks : )
13:43:46 <Cale> It is a *little* weird for pulseConnect to take a Maybe String
13:43:56 <Cale> Because it doesn't really do anything interesting in the case of Nothing
13:44:12 <Cale> But let's go a bit further down that line
13:44:17 <egasimus> Cale: I'd ideally have it print a warning message, but just carry on
13:44:32 <srhb> egasimus: (That's what Either is for :-))
13:44:32 <jacereda> When wrapping an external library, should getters be typed as returning IO RetType or just RetType? AFAICS there's no IO going on, for the same argument it should return the same result always...
13:44:41 <Cale> Yeah, you might want to do that, you could have it take care of the two different sorts of failure
13:45:03 <Cale> But supposing that you want to simplify this (and lose that opportunity)
13:45:13 <Athas> God damn, upper version bounds in .cabal files are the worst.
13:46:18 <Cale> You can write something like  pulseConnect ms = case ms >>= parseAddress of Nothing -> return Nothing; Just a -> do s <- open a; return (Just s)
13:47:37 <Cale> do s <- open a; return (Just s)  is also equal to  fmap Just open
13:48:54 <Cale> Athas: I rather dislike them as well. There's no way for anyone to know ahead of time what they ought to be.
13:49:20 <egasimus> Cale: what's the >>= operator called? And how does it work, considering ms :: Maybe String and parseAddress :: String -> Maybe a?
13:49:53 <Cale> That's called bind. It's one of the two things required to be defined in order to make something into a monad. In this case, we're using the version of it for Maybe
13:49:57 <simpson> :t (>>=) egasimus: typically pronouned "bind"
13:49:58 <lambdabot> Not in scope: ‘egasimus’
13:49:58 <lambdabot> Not in scope: ‘typically’
13:49:58 <lambdabot> Not in scope: ‘pronouned’
13:50:00 <Athas> Cale: right.  I'd suggest leaving them out entirely, unless the package in question has a specific compatibility policy (and probably not even then).
13:50:02 <Cale> Its type is Maybe a -> (a -> Maybe b) -> Maybe b
13:50:09 <Cale> In this instance
13:50:12 <simpson> Pfft, cannot type.
13:50:22 <Cale> More generally, it has type  (Monad m) => m a -> (a -> m b) -> m b
13:50:31 <merijn> jacereda: Note that: allocating memory, manipulating pointers, etc. is all "IO" as well
13:50:42 <Cale> For example, you can use it with IO actions, where it would have type  IO a -> (a -> IO b) -> IO b
13:50:52 <Cale> x >>= f  =  do v <- x; f v
13:50:54 <egasimus> Cale: hey, that's something I've confused about before :D how does it know it's Maybe in the context of this function?
13:50:54 <stolaruk> egasimus: http://www.haskell.org/haskellwiki/Pronunciation
13:51:02 <Cale> which is the same as  do v <- x; w <- f v; return w
13:51:14 <Cale> egasimus: Because ms :: Maybe String
13:51:33 <Cale> So m a has to match up with Maybe String
13:51:40 <Cale> and thus m = Maybe, and a = String
13:51:59 <Cale> moreover, it knows that parseAddress :: String -> Maybe Address
13:52:10 <Cale> So, this gives another piece of evidence that a = String
13:52:15 <Cale> and that m = Maybe
13:52:24 <Cale> and also tells us that b = Address
13:52:29 <egasimus> Ah yes, so that's why => is pronounced 'implies', because (Monad m)
13:53:13 <Cale> Well, yeah, the type basically says "If m is any instance of the type class Monad, then this can have type m a -> (a -> m b) -> m b"
13:53:20 <merijn> egasimus: I like to read "f :: Foo a => a -> a" as "IF 'a' is an instance of 'Foo' THEN 'f :: a -> a' ELSE type error"
13:54:03 <egasimus> What's the syntax for defining multiple such conditions? Something like (Monad m, String a) => ... ?
13:54:10 <joelteon> yeah, that
13:54:37 <Cale> Though String isn't the name of any standard type class
13:54:45 <Cale> There is IsString though
13:55:39 <Cale> (which is a type class for types t that have a canonical fromString :: String -> t)
13:56:15 <Cale> It's only intended to be used for things where it makes sense that string literals would desugar into such values
13:56:41 <egasimus> if there's no String type class, what is String in "String -> t"? Just [Char]?
13:56:42 <Cale> and there's an extension which applies fromString automatically to all your string literals so that they can represent e.g. Text
13:56:52 <Cale> String is a type
13:56:55 <Cale> and it's equal to [Char]
13:57:00 <stolaruk> it's a type synonym
13:57:28 <merijn> egasimus: Typeclass and types are very different things, but I don't want to derail the explanation Cale was giving with kinds :)
13:57:51 <jacereda> merijn: ok, thanks
13:58:09 <Cale> egasimus: For a simpler example of type classes, there's the type class Eq
13:58:13 <Cale> class Eq a where
13:58:18 <Cale>   (==) :: a -> a -> Bool
13:58:23 <Cale>   (/=) :: a -> a -> Bool
13:58:47 <Cale> and it also provides some default implementations so that instances only have to specify one of the two:
13:58:58 <Cale>   x /= y = not (x == y)
13:59:03 <Cale>   x == y = not (x /= y)
13:59:07 <egasimus> hey, that's pretty cool.
13:59:33 <egasimus> so basically a type class defines a set of (canonical?) methods that member types (instances?) are expected to have?
13:59:47 <Cale> yeah, it's somewhat like a Java interface if you know what those are
14:00:01 <Cale> BUT
14:00:27 <Cale> Unlike Java interfaces, classes constrain type variables, you can't use them in types as if they were types
14:01:06 <egasimus> yeah, I guess I can say I'm more familiar with those than I'd like to be, me coming from Python with its quite forgiving ducktyping and introspection an all...
14:01:09 <Cale> Well, I probably shouldn't say "unlike" -- you can use Java interfaces to constrain type variables in Java too, iirc, but you can also use them like types, which is different.
14:01:47 <Cale> So, for example, there's also a type class Ord which defines methods (<), (<=), (>), (>=), and compare
14:02:11 <Cale> and it's a subclass of Eq, which just means that if you make something an instance of Ord, you're required to also write an instance of Eq for it
14:02:31 <benzrf> egasimus: duck typing is only fake forgiving
14:02:33 <Cale> (and if you know then that some type is an instance of Ord, you automatically know it's an instance of Eq)
14:02:43 <benzrf> egasimus: instead of getting mad right away it lets you get away with things that will kick you in the ass later
14:02:44 <Cale> Now, think about the type of sort
14:03:03 <Cale> If we were to write a sorting function for lists, we'd hope that it could work on many types of list
14:03:20 <Cale> So, you might initially reach for something like  sort :: [a] -> [a]
14:03:33 <Cale> But this doesn't work, because we might not have any way to compare values of type a
14:03:45 <Cale> They might be functions, or IO actions, or some other abstract type
14:03:53 <egasimus> so we say sort :: (Ord a) => [a] -> [a] ?
14:03:56 <Cale> yeah
14:04:16 <Cale> This says 'if a is a type for which ordering operations are defined, then sort can have type [a] -> [a]'
14:04:31 * geekosaur has this annoying feeling he is being steadily sucked into ghc-devs...
14:04:57 <Cale> By defining sort using the operations such as (<) defined by Ord, it automatically becomes polymorphic itself
14:05:28 <Cale> (given that we needed no other information about what type it was than that it supports those operations)
14:05:54 <Cale> So, this is better than ad-hoc polymorphism, where you might have ad-hoc polymorphic versions of (<) which would be selected based on type
14:06:22 <Cale> but you'd have to write sort over and over for each type in order to build up an ad-hoc polymorphic sort
14:06:57 <Cale> Instead, we only have to write sort once, and it works for all instances of Ord, including all future ones
14:07:30 <Cale> What's more, we can write instances of Ord which are themselves a bit polymorphic. For example, the instance for lists:
14:07:38 <Cale> instance Ord a => Ord [a] where ...
14:07:48 <karshan_> Hey, anyone know where (#.) which is used in lens defined
14:07:59 <Cale> This says that whenever a is a type for which Ord has an instance, then [a] also has an instance
14:08:02 <karshan_> *is defined
14:08:05 <edwardk> karshan_: Data.Profunctor.Unsafe
14:08:09 <Cale> Er, that was awkwardly worded
14:08:13 <napping> Probably the biggest difference from interfaces as in Java is not necessarily even needing values of the type around
14:08:28 <Cale> This says that whenever a is a type which has an instance of Ord, then [a] also has an instance of Ord
14:08:30 <Cale> better :)
14:08:44 <napping> simplified a bit, you have class Read a where read :: String -> a
14:08:46 <Cale> Right, that's another big difference
14:08:49 <dncr> Is (rnf (a, b, c)) better than (rnf a `seq` rnf b `seq` rnf c `seq` ()) when defining a new NFData instance?
14:08:52 <Kron> let primes = [x | x <- [3..], all (\y -> x mod y /= 0) [2 .. x]]
14:08:54 <karshan_> edwardk: Thanks!
14:08:55 <Kron> what's wrong with this?
14:09:11 <Kron> it gives an infinite type error
14:09:20 <merijn> Kron: No backticks on mod
14:09:30 <Kron> oh
14:09:32 <merijn> :t 8 < Kron> it gives an infinite type error
14:09:33 <lambdabot> parse error on input ‘type’
14:09:36 <Cale> You can have things which are polymorphic just in their result type, which is something that dynamically typed languages, and OO languages which dispatch on the argument both struggle with
14:09:38 <merijn> err, whoops
14:09:48 <egasimus> Cale: so this basically means that, if you can complare a, you can compare lists of a to each other?
14:09:49 <merijn> :t let primes = [x | x <- [3..], all (\y -> x mod y /= 0) [2 .. x]] in primes
14:09:50 <lambdabot>     Occurs check: cannot construct the infinite type:
14:09:50 <lambdabot>       a3 ~ (a5 -> a5 -> a5) -> a3 -> a4
14:09:50 <lambdabot>     Relevant bindings include
14:09:55 <Cale> egasimus: yeah
14:09:56 * hackagebot hlint 1.9.6 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.9.6 (NeilMitchell)
14:09:58 * hackagebot bindings-lxc 0.2.0.1 - Direct Haskell bindings to LXC (Linux containers) C API.  http://hackage.haskell.org/package/bindings-lxc-0.2.0.1 (NickolayKudasov)
14:10:00 <merijn> :t let primes = [x | x <- [3..], all (\y -> x `mod` y /= 0) [2 .. x]] in primes
14:10:01 <lambdabot> Integral t => [t]
14:10:06 <Cale> egasimus: and the instance uses the dictionary ordering, basically
14:10:12 <merijn> Kron: I admit that that error is particularly unhelpful
14:10:29 <egasimus> Cale: OH! hahaha, that's awesome :D
14:10:34 <merijn> Kron: The problem is that it think you're trying to use 'x' as a function taking mod as argument
14:10:46 <merijn> Kron: But the polymorphic numbers make the error inscrutable
14:10:48 <Cale> > [1,2,3] > [1,2]
14:10:49 <lambdabot>  True
14:10:51 <merijn> Kron: Compare
14:10:55 <Cale> > [1,2,3] > [1,1,3]
14:10:56 <lambdabot>  True
14:11:02 <merijn> :t let primes = [x | x <- ([3..] :: [Int]), all (\y -> x `mod` y /= 0) [2 .. x]] in primes
14:11:03 <lambdabot> [Int]
14:11:08 <merijn> eh
14:11:10 <Cale> > [1,2,3] < [1,2,4]
14:11:12 <lambdabot>  True
14:11:16 <merijn> :t let primes = [x | x <- ([3..] :: [Int]), all (\y -> x mod y /= 0) [2 .. x]] in primes
14:11:18 <lambdabot>     Couldn't match expected type ‘(a1 -> a1 -> a1) -> Int -> a0’
14:11:18 <lambdabot>                 with actual type ‘Int’
14:11:18 <lambdabot>     The function ‘x’ is applied to two arguments,
14:11:28 <jacereda> I'm trying to wrap a javascript 3d engine, it has an Object3D class and deriving from that things like lights, cameras and so on. I'm using "newtype Object3D = Object3D JSAny    deriving Handle" and I implemented some functions on Object3D. This works, but I don't want a Light to have type Object3D. How can I make Light 'inherit' in the classical (class) sense from Object3D, so I can pass a Light to, say, setPositio
14:11:28 <jacereda> n?
14:11:52 <Cale> egasimus: and of course, that means we can automatically compare lists of lists
14:11:53 <merijn> Kron: See, much clearer. The problem is that (conceptually) functions can be instances of Num, so it's theoretically possible that [3..] is a list of functions
14:11:59 <Cale> and lists of lists of lists :)
14:12:06 <Cale> egasimus: all from writing that one instance :)
14:12:15 <merijn> Kron: So as a result GHC's error is utterly unhelpful
14:12:25 <Kron> even with `mod` it still generates an error
14:12:32 <Cale> egasimus: So, Monad is similar here, it's a type class as well
14:12:53 <merijn> jacereda: You can't inherit in haskell, because there is no inheritance
14:13:02 <merijn> Kron: lpaste the code +error?
14:13:05 <Cale> egasimus: But it's actually a little fancier, in that its parameter is basically a function from types to types (i.e. a parametric type)
14:13:16 <Cale> egasimus: it looks like this:
14:13:22 <Cale> class Monad m where
14:13:26 <Cale>   return :: a -> m a
14:13:34 <Cale>   (>>=) :: m a -> (a -> m b) -> m b
14:13:38 <Kron> http://lpaste.net/7145742600245346304
14:13:40 <jacereda> merijn: so, what's the way to do something like that?
14:14:03 <merijn> jacereda: It depends on your design, the usual way to do "OO" is a record of functions
14:14:31 <Kron> OH
14:14:33 <stolaruk> Kron: Maybe change "y"s to "x"s?
14:14:36 <Kron> all doesn't do what i think it does
14:14:40 <Cale> egasimus: As functional programmers, we often end up writing these libraries which define something like miniature programming languages, built up of values which represent computations of some sort, together with ways to combine and compose those computations into more complicated ones
14:14:44 <merijn> :t all
14:14:45 <lambdabot> (a -> Bool) -> [a] -> Bool
14:14:47 <stolaruk> oh nevermind
14:14:49 <Kron> or
14:14:51 <Kron> no it works
14:14:56 * hackagebot lxc 0.3.1 - High level Haskell bindings to LXC (Linux containers).  http://hackage.haskell.org/package/lxc-0.3.1 (NickolayKudasov)
14:14:59 <Cale> egasimus: Monad is a pattern which often crops up when we do that:
14:15:20 <Cale> egasimus: We often have some type of computations parameterised by the type of their result(s)
14:15:33 <jacereda> merijn: the problem is it's not my design, I'm just trying to wrap the current design for the library in the hopes that later I'll write a nicer haskellish wrapper, so the question is how are classical OOP libs wrapped in haskell?
14:15:33 <stolaruk> :t all
14:15:34 <lambdabot> (a -> Bool) -> [a] -> Bool
14:15:35 <merijn> Kron: I recommend the following: split the list comprehension into multiple smaller definitions and explicitly write down their type (or what type you think they have), write list comprehension using these smaller definitions and see if that clarifies
14:15:48 <merijn> jacereda: With much pain and suffering
14:15:52 <Cale> egasimus: This type often has some way to construct a "no-op" computation which simply produces a given value as its own result
14:16:38 <Cale> egasimus: and in addition to that, there's some way to chain these computations together: given some initial computation, and a function from possible results of that computation to further stuff to do, there's a way to glue those together into a single computation.
14:16:46 <merijn> jacereda: Either lots of IO and newtypes or lots of handwritten glue
14:16:57 <Kron> I don't understand why it doesn't work...
14:16:59 <Cale> egasimus: Does that make some sense? :)
14:17:01 <Kron> and I'm not sure I can do that?
14:17:11 <Kron> not if I want the x binding to work properly in a list comprehension
14:17:13 <Kron> due to monad binding
14:17:22 <jacereda> merijn: ok, but I already wrote some handwritten glue for Object3D that I don't want to replicate for Light, Camera, etc
14:17:25 <Cale> egasimus: As you go on, you'll see more and more of these libraries, and the real way to understand Monad is just to look at lots of examples of it.
14:17:56 <NemesisD> anyone know with persistent if I have a column that's a sum type if I can either create a query which pattern matches its constructor, searches by constructor name or if i can construct a non-typesafe filter instead of dropping to a full raw sql query
14:17:57 <merijn> Kron: I expect the lambda is not parsing as you expect
14:18:09 <merijn> :t \x -> all (\y -> x `mod` y /= 0)
14:18:10 <lambdabot> Integral a => a -> [a] -> Bool
14:18:12 <Cale> egasimus: The benefit here is the same as the benefit we get from defining the Ord typeclass: there are a bunch of operations which can be defined which will work using any instance of Monad at all, and we're saved from the trouble of writing those over and over.
14:18:14 <merijn> hmm
14:18:20 <merijn> ok, maybe it is
14:18:27 <egasimus> Cale: a whole lot. So I've seen Maybe referred to as another example of a Monad besides the obvious IO. What do its return and >>= methods look like?
14:18:36 <Cale> return v = Just v
14:18:41 <Cale> Nothing >>= f = Nothing
14:18:46 <Cale> Just x >>= f = f x
14:18:54 <merijn> Kron: oh!
14:19:02 <Cale> Here we have  return :: a -> Maybe a
14:19:10 <Cale> and  (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
14:19:14 <merijn> Kron: That's what I get for debugging code without running
14:19:21 <Kron> oh I just wrote y in the wrong place
14:19:24 <merijn> Kron: You defines a value named 'y' before
14:19:32 <merijn> Which is why the type doesn't match
14:19:46 <merijn> If I run it locally, I get "<interactive>:2:51: Not in scope: ‘y’"
14:20:25 <Cale> Maybe is among the simplest instances of Monad, and as such it loses a lot of the character of "computations", but you can still think of a value of type Maybe t as "a computation which may either fail, or else produces a result of type t"
14:20:28 <merijn> This is another reason I advocate editing in a text file and using ":l" and ":r" to load it into ghci, then you don't end up having these "hidden" variables
14:21:37 <Cale> Having the instance of Monad allows us to use the do-notation with Maybe to write things like...
14:21:40 <Cale> :t lookup
14:21:41 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
14:22:02 <Cale> @let dict = [(0,1),(1,2),(2,3)]
14:22:05 <lambdabot>  Defined.
14:22:07 <jacereda> anyone knows of a class-based OOP library that has a good haskell/haste wrapper? It would really help me figure out some doubts...
14:22:18 <yellowcalx> Hi, sorry to be a bother but I'm curious if any of you have had any issues with installing packages through Cabal and tips on resolving the issues. My specific problem is an inability to install QuickCheck since it depends on tf-random-0.5 which fails to install, over and over and over again. Any ideas on how to solve it would be greatly appreciate
14:22:18 <yellowcalx> d.
14:22:25 <Kron> let primes = [x | x <- [2..], all (\y -> x `mod` y /= 0) [2 .. x - 1]]
14:22:25 <Cale> > do x <- lookup 0 dict; y <- lookup x dict; return (x,y)
14:22:26 <merijn> jacereda: You could look at something like gtk?
14:22:26 <Kron> so this works
14:22:27 <lambdabot>  Just (1,2)
14:22:36 <Kron> but the floor $ sqrt version doesn't
14:22:38 <Cale> > do x <- lookup 0 dict; y <- lookup x dict; z <- lookup y dict; return (x,y)
14:22:39 <lambdabot>  Just (1,2)
14:22:40 <Cale> > do x <- lookup 0 dict; y <- lookup x dict; z <- lookup y dict; return (x,y,z)
14:22:42 <lambdabot>  Just (1,2,3)
14:22:54 <Cale> > do x <- lookup 0 dict; y <- lookup x dict; z <- lookup y dict; w <- lookup z dict; return (x,y,z,w)
14:22:56 <lambdabot>  Nothing
14:23:15 <Cale> So, we can do chained lookups, where if any of them fail, the whole thing fails
14:23:37 <Cale> and otherwise, the computation succeeds and produces the given result in terms of the intermediate ones :)
14:23:49 <jle`> imagine doing that manually!
14:23:51 <jle`> :O
14:24:04 <Cale> Yeah, you'd basically have a whole bunch of nested case expressions
14:24:14 <jacereda> merijn: ok, let me check
14:24:26 <hiptobecubic> or a for loop with a flag and break on null return value ;)
14:24:35 <hiptobecubic> What could go wrong!?
14:24:43 <Cale> If you're wondering about the connection between do-syntax and (>>=), I can show how it desugars:
14:24:58 <Cale> @undo do x <- lookup 0 dict; y <- lookup x dict; z <- lookup y dict; return (x,y)
14:24:59 <lambdabot> lookup 0 dict >>= \ x -> lookup x dict >>= \ y -> lookup y dict >>= \ z -> return (x, y)
14:25:17 <albeit> @pl \a c -> a + ord c
14:25:18 <lambdabot> (. ord) . (+)
14:25:52 <Cale> egasimus: The rules are as follows:
14:25:57 <exio4> @pl \a c → (id a) + (ord c)
14:25:57 <lambdabot> (line 1, column 7):
14:25:57 <lambdabot> unexpected "\134"
14:25:57 <lambdabot> expecting pattern or "->"
14:25:59 <Cale> do { x } = x  -- base case
14:26:09 <albeit> Is "foldl' (\a c -> a + ord c) 0 text" the fastest way of getting the sum of the bytevalues of a String?
14:26:28 <Cale> do { x ; <stmts> } = x >> do { <stmts> }  -- where x >> y = x >>= (\k -> y)
14:26:29 <jle`> albeit: that looks like a sum and a map
14:26:31 <jle`> er
14:26:34 <jle`> a map and a sum
14:26:42 <Cale> do { v <- x ; <stmts> } = x >>= \v -> do { <stmts> }
14:26:59 <Cale> do { let { <decls> } ; <stmts> } = let { <decls> } in do { <stmts> }
14:27:01 <jle`> remember that haskell is lazy, so sum . map doesn't actually do a map, and then a sum
14:27:08 <jle`> it sums and maps as it goes along
14:27:22 <Cale> It does a sum, and when the sum pattern matches, that triggers map to unfold a bit :)
14:27:37 <jle`> man laziness makes my code so much faster
14:27:41 <jle`> i don't know how i ever lived without it
14:28:11 <jle`> maybe it was not really living
14:28:13 <albeit> jle`: Ah true, I should have been more specific, its actually Text.foldl', and operating on a lazy Text... so I can't map over it
14:28:43 <egasimus> Cale: what does -> mean in this context?
14:29:07 <Cale> egasimus: That's part of the syntax of lambdas
14:29:13 <mauke> \p -> X is a function with parameter p and body X
14:29:24 <jle`> > (\x -> x + 2) 10
14:29:26 <lambdabot>  12
14:29:40 <Cale> > (\x -> x * x) 5
14:29:41 <lambdabot>  25
14:29:48 <Cale> map (\x -> x * x) [1..10]
14:29:51 <Cale> > map (\x -> x * x) [1..10]
14:29:53 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
14:31:43 <egasimus> Cale: I've read about how the do is just sugar for passing the monad around, but only now that I am seeing your examples does it begin to sink in
14:31:53 <albeit> Is "rem" faster than "div" for positive integers?
14:31:59 <egasimus> I'm starting to form some vague understanding of how it all fits together
14:32:01 <albeit> * mod, not div
14:32:15 <karshan_> Hello, so I'm trying to understand how (a ^.. template) from Data.Data.Lens works and it looks like via substitution it is = foldrOf template (:) [] a
14:32:26 <merijn> egasimus: I usually recommend starting out writing code using explicit >> and >>= and only move to using do-notation once you start seeing how it translates
14:32:28 <Cale> albeit: Ever so slightly, because it's the one which is slightly cheaper to implement in hardware, so that's what hardware tends to implement
14:32:39 <Cale> albeit: It also tends to be less useful otherwise.
14:32:48 <karshan_> I'm trying to figure out if the Profunctor instance being used here is the instance for (->)
14:33:07 <karshan_> foldrOf :: Profunctor p => Accessing p (Endo r) s a -> p a (r -> r) -> r -> s -> r
14:34:32 <Cale> egasimus: So, the monad itself (the type constructor, and the return and (>>=) operations), well, the type constructor is just a compile-time thing, types don't exist at runtime. The operations return and (>>=) are passed around like extra parameters at runtime to things which are polymorphic in the choice of Monad instance
14:35:26 <Cale> (that's how type classes work, the class corresponds roughly to a record data type which has fields for each of the methods, and the instances correspond to values of that type (or functions producing them)
14:35:52 <Cale> and type class polymorphic definitions are compiled to functions which accept extra arguments for these dictionaries)
14:36:50 <Cale> Sometimes the compiler will be able to optimise and specialise things though -- if you use a specific instance, it might inline the definitions of the operations.
14:39:58 * hackagebot hell 2.1 - A Haskell shell based on shell-conduit  http://hackage.haskell.org/package/hell-2.1 (ChrisDone)
14:41:09 <yellowcalx> No one has any idea as to get an invalid byte code error when installing quickcheck due to the dependency tf-random-0.5 failing. I've tried changing locale LANG to se_NO.utf8 but it doesn't seem to do anything so I am all out of ideas.
14:41:39 <lpaste> stolaruk pasted “Refactoring: code combining” at http://lpaste.net/111884
14:42:10 <stolaruk> ^^ Could someone take a look please? I'm looking for suggestions on how to combine code.
14:42:24 <Cale> yellowcalx: I can't say I've ever seen that
14:42:31 <stolaruk> Really the question is regarding how to take common code and make it into a utility function
14:43:05 <Cale> yellowcalx: Perhaps you could put the whole error on lpaste.net ?
14:43:22 <yellowcalx> Cale: Sure, will do in a sec.
14:43:57 <Cale> stolaruk: f t = (ws ^. t) ! i ?
14:44:35 <Cale> stolaruk: It may be the case that it's tricky to get that to type check, in which case, I'd just leave what you have.
14:44:38 <yellowcalx> Cale: http://lpaste.net/111885
14:45:06 <stolaruk> Cale: That's a good idea. I've written some functions that take lenses, and I've let type inference do the hard work for me
14:45:16 <dfeuer> I gather Phabricator is down?
14:45:24 <dfeuer> er.. wrong channel.
14:49:11 <yellowcalx> Strange error.. intalled flawlessly on OSX, doesn't install on arch.. meh.
14:49:43 <Cale> yellowcalx: what did you do when setting LANG?
14:50:38 <Cale> Try setting it on the same line as the cabal install, like  LANG=se_NO.UTF-8 cabal install QuickCheck
14:51:20 <Cale> (also, is se_NO.utf8 really correct?)
14:52:49 <Cale> yellowcalx: does that make any difference?
14:54:21 <yellowcalx> Cale: I'm Swedish so it's the only utf8 option I've got currently on my system as I haven't installed any other. Anyways, didn't change it system wide just locally for the terminal I was using. Haven't got the best understanding of locale though so don't even think it did something, either it's not the problem or I need to change it system wide, be
14:54:21 <yellowcalx> cause the error didn't change after altering the LANG
14:55:00 * hackagebot informative 0.1.0.4 - A yesod subsite serving a wiki.  http://hackage.haskell.org/package/informative-0.1.0.4 (implementation)
14:55:10 <yellowcalx> Still the incalid byte sequence, but it does sound like it has to do with encoding to me, not sure though
14:55:49 <NemesisD> is it possible to use typeable to get the name of a value's constructor
14:58:42 <yellowcalx> Cale: The reason I was messing about with LANG was since it seemed to have resolved a similar issue I found here https://github.com/haskell/cabal/issues/1883
14:59:16 <Cale> yellowcalx: Yeah, Google seems to agree
15:00:13 <Cale> yellowcalx: what does  cabal --version  report?
15:00:41 <yellowcalx> Cale: 1.20.0.3
15:01:01 <Cale> same here
15:01:02 <Cale> hm
15:01:40 <yellowcalx> I guess I'll just have to mess about with the locale so that I get a system wide change since maybe the local change didn't actually affect it
15:02:19 <yellowcalx> Since calling locale only showed it being changed within the specific terminal I altered it in
15:05:57 <yellowcalx> got it to work on my OSX system though so guess I'll just have to go apple... thanks though but I guess I'll just have to troubleshoot it another day :)
15:07:20 <L8D> so I'm getting "The program c2hs version >=0.15 is required but it could not be found." whenever I try to install ncurses
15:07:33 <L8D> anyone know what I should do?
15:08:07 <L8D> oh wait...I'm on cabal 1.18, I'll try updating and see what that does
15:08:22 <shachaf> L8D: You probably need to install c2hs.
15:09:29 <L8D> shachaf: isn
15:09:37 <L8D> isn't that a ghc default package?
15:09:51 <geekosaur> no
15:10:00 <L8D> why doesn't cabal install it as a dependency?
15:10:17 <geekosaur> hsc2hs comes with ghc; c2hs is a different thing. and cabal can't deal with program dependencies in Haskell, only libraries
15:10:29 <geekosaur> (because it depends on ghc-pkg, which neither knows nor cares about programs)
15:10:57 <L8D> geekosaur: but I'm installing the ncurses library, why can't it just have c2hs as a dependency like text and such?
15:11:03 * L8D is new to cabal
15:11:11 <geekosaur> because c2hs is a program, not a library
15:11:14 * L8D doesn't understand...
15:11:30 <L8D> geekosaur: and it's part of the install process?
15:11:34 <geekosaur> cabal would have to keep its own lookaside list of programs, as opposed to packages, and it would get out of sync with ghc rather easily
15:11:37 <joelteon> why can't you have gcc as a dependency?
15:11:45 <L8D> I see
15:11:46 <L8D> thanks
15:11:56 <geekosaur> this is why cabal is not, and really can't be, a package manager unless it takes control of the whole thing away from ghc
15:12:44 <geekosaur> (which just means ghc will be the one getting confused instead of cabal. that's worse than "Cabal hell", it turns out; if ghc can't screw you one way, it finds another...
15:12:51 <geekosaur> )
15:13:14 <L8D> (even though everyone who has used npm says this in every other environment) cabal needs to be like npm. :P
15:13:43 <L8D> but haskell isn't lightweight...so...
15:13:43 <geekosaur> javascript doesn't have a package manager to get out of sync with npm
15:14:03 <jacereda> Hmmm... is this a valid/good way to wrap a javascript library that uses inheritance?  http://lpaste.net/111889
15:14:08 <joelteon> what happens in haskell if you have the same package installed 15 different times?
15:14:28 <jacereda> I would prefer something that doesn't involve having to call 'object foo' in every place an object is expected...
15:14:31 <joelteon> and you try to link your executable
15:14:39 <jacereda> but don't know how to do it
15:14:44 <geekosaur> so npm necessarily does the whole thing, and then it can work somewhat reliably. but with ghc having to know about packages itself, things get out of sync if you try to move that all into cabal, and out of sync differently if you try to leave it in ghc which can't do the whole thing :/
15:14:44 <L8D> yeah I see. I wish Haskell (the platform) was simplified. it would make adoption a lot easier.
15:15:46 <has> Are there things that can't be done functionally? If so do you have any examples?
15:16:00 <merijn> geekosaur: You're also glossing over the fact that npm will happily create broken packages silently
15:16:12 <merijn> geekosaur: Since JS doesn't do any compilation/interface checking at all
15:16:17 <dibblego> has: No.
15:16:23 <geekosaur> I dont work with javascript, so I don't know details like that :)
15:16:38 <L8D> merijn: how does that make then "broken" packages?
15:16:39 <merijn> So "npm just works" == "npm just silently broke your package in subtle ways and you just don't know it yet"
15:17:01 <merijn> L8D: If your dependency changed a data structure npm will happily "build" your package and throw a runtime exception
15:17:02 <joelteon> well, npm works because javascript doesn't do the whole "compilation" thing
15:17:03 <L8D> merijn: npm didn't brake your package. YOU broke your package if it was errors in it.
15:17:15 <joelteon> or the "type checking" thing
15:17:18 <merijn> L8D: Right, the difference is that npm doesn't tell you that
15:17:25 <merijn> L8D: cabal *does* tell you that in some cases
15:17:34 <L8D> merijn: why does npm need to? it's just a package manager, not a compiler
15:17:38 <albeit> I have a lazy Text that I am converting a a strict ByteString, and then writing to an IOStream.  Are IOStreams fast in writing to a TCP socket? Any there any points where this could be slower than it should be?
15:17:38 <joelteon> so it's not npm's fault any more than it is their fault for writing a package manager for an untyped language in the first place
15:17:44 <merijn> L8D: But instead of people saying "thanks cabal!" they go "cabal is a piece of shit that doesn't let me install!"
15:17:50 <geekosaur> I do sometimes wonder if the right way to go is move it into cabal and have cabal generate on the fly package databases for builds and force ghc to use them. kinda like one-shot sandboxes. of course, it then has to read the new install back out of said sandbox and apply it to the real sandbox or user database as appropriate, so more work :/
15:17:51 <merijn> L8D: Cabal is NOT a package manager
15:17:51 <L8D> merijn: if you're a sane JS dev you'll use tools to make sure your code is correct
15:17:53 <joelteon> L8D: npm doesn't need to
15:17:55 <joelteon> javascript can't
15:18:02 <merijn> L8D: Cabal is a dependency tracker + build system
15:18:04 <geekosaur> cabal's in an impossible position
15:18:12 <L8D> joelteon: javascript definitely can
15:18:13 <joelteon> it's not npm's job to track package sanity because that's impossible in javascript
15:18:28 <merijn> L8D: If you're a sane haskell developer you have cabal stop you from doing dumb stuff so you don't have to check
15:18:30 <L8D> joelteon: wtf are you talking about?
15:18:36 <geekosaur> "Cabal hell" is invariably ghc being confused or ghc not being able to do things that look perfectly sane from the outside
15:18:48 <joelteon> L8D: the fact that javascript is an untyped interpreted language...
15:18:57 <L8D> merijn: cabal /= package manager ends this argument then.
15:19:50 <merijn> L8D: But then newbies whine "but why can't it be?!?!"
15:19:56 <geekosaur> most notably, since ghc peeks inside packages and does cross-module inlining, you can't simply pick up a compiled package and use it with a supposedly compatible different version of a dependency; it's got innards of the original dependency that would normally be allowed to change without affecting the visible (and compatible) interface
15:20:02 * hackagebot sensenet 0.1.0.0 - Distributed sensor network for the raspberry pi  http://hackage.haskell.org/package/sensenet-0.1.0.0 (rossdylan)
15:20:21 <geekosaur> and ghc performance goes to hell if you turn off that cross-module inlining
15:20:58 <geekosaur> so, cabal's between a rock and a hard place and there's not a whole lot it can do about it
15:21:15 <geekosaur> (and just to add to the fun, ghc dynamic linking made this worse)
15:21:27 <merijn> For what it's worth, I think cabal is one of the best build tools I've had to use across many different languages
15:22:23 <merijn> Most of the cabal hate comes from people 1) not understanding the fundamental problem, 2) not understanding how hard it is solve, and 3) why all their pet "working solutions" are secretly silently broken as hell
15:23:07 <albeit> Is there a way to use IO Streams to read from a socket, but write directly to the socket? Like a "socketToStreams" but with only an input stream returned
15:23:20 <L8D> merijn: am I doing this wrong? I want to install ncurses, but I have to manually install c2hs first, but then I have to manually install happy first, but then I have to manually install alex first, and finally I get my c2hs package to install, and then I can go back to my local sandbox and install ncurses?
15:23:42 <L8D> merijn: is there some way that is automated? or is it just a one-time thing?
15:23:50 <L8D> or is that just the way it is?
15:24:03 <merijn> L8D: There are plans to add seperate dependencies for Setup.hs, but it's work in progress
15:24:15 <geekosaur> well, most people start from the platform so happy and alex are included
15:24:31 <geekosaur> I don't recall if c2hs is also part of the Platform
15:24:56 <merijn> L8D: One of the problems is that cabal doesn't currently make a distinction between 1) dependencies for the build script and dependencies for the actual code and 2) not being able to track binaries
15:25:49 <merijn> L8D: The former is a problem being worked on, the 2nd requires turning cabal into a full-blown package manager. There's plenty of interest in making cabal into a proper package manager, but it's a lot of work
15:26:08 <merijn> L8D: There's currently only 1 or 2 people hacking on cabal and they have full-time jobs, so progress is slow
15:26:23 <merijn> And those same people are *also* hacking on the hackage-server, etc.
15:26:43 <L8D> that sucks D:
15:26:47 <L8D> but okay.
15:27:05 <merijn> So the best way to help improve the situation is by helping to hack on cabal, but admittedly the cabal source is a bit intimidating (at least for my attempts in the past)
15:28:04 <merijn> Actually, once we have separate build dependencies there is a possible work-around for the binaries. Just have every binary package include a dummy library and have your build script depend on the dummy library
15:28:14 <L8D> what if someone decided to redo everything from scratch and setup ghc with an abstraction over how modules work so that the file linking system is more flexible
15:28:16 <luite> it's mostly big, but pretty straightforward, but it doesn't contain many scary concepts
15:28:41 <merijn> luite: The minimal interface means a lot of stuff that you need to make it scriptable is not available
15:29:13 <merijn> L8D: GHC *has* a module linking abstraction, cabal queries GHCs database for installed modules
15:29:34 <merijn> L8D: That's the reason cabal doesn't know about executables, because GHC doesn't track installed executables
15:30:03 <L8D> but what if that abstraction was instead based on a file hierarchy instead of a global set of installed moudles
15:31:02 <L8D> this is all just for the joy of thought...not real suggestions or questions...
15:31:16 <L8D> just a dream from a naive developer
15:32:54 <merijn> L8D: Cabal is supposed to work with multiple compilers, though
15:33:04 <geekosaur> L8D: I suspect, if you could present the GHC dev team with a workable better idea, they would be open to it
15:33:16 <geekosaur> one of the problems is not enough people, too many things that need people to implement them
15:33:24 <L8D> who uses anything other than GHC-stable?
15:33:41 <L8D> like...what other haskell compilers are out there and why does anyone use them?
15:33:42 <merijn> L8D: Everyone hacking on UHC, JHC, etc.
15:33:55 <L8D> oh I see
15:34:02 <geekosaur> jhc is nice for embedded development. uhc is still out there and being developed but I couldn't tell you who uses it
15:34:12 <merijn> Then there's Lennart's closed source compiler, although that probably doesn't use cabal
15:34:57 <Hijiri> Is there a library for some kind of relational database type that's implemented in Haskell?
15:35:01 <merijn> L8D: Restricting cabal to GHC also means any new haskell compilers would need to implement their own build system, package tracker, hackage-like server, etc. from scratch instead of hooking into cabal
15:35:04 <Hijiri> as opposed to a wrapper for SQL or something
15:35:34 <geekosaur> (that said, I think jhc went the direction of ignoring cabal because 90% of it doesn't apply to jhc's use case and because it's got too much invested in dealing with ghc's issues)
15:35:50 <merijn> L8D: Also, think of stuff like supporting ghcjs
15:35:54 <L8D> Hijiri: isnt that a SQL wrapper?
15:36:26 <Hijiri> not necessarily
15:36:36 <Hijiri> not all relational databases have to be queried with sql
15:36:37 <geekosaur> also, because jhc is a whole-program compiler, it has issues that cabal as currently designed doesn't handle well
15:36:56 <L8D> merijn: couldn't we just take the output of ghc and compile it to asm.js for GHCJS?
15:37:04 <geekosaur> (that being jhc's solution to ghc's cross module inlining issues)
15:37:06 <L8D> or is that what they're already doing?
15:37:53 <merijn> L8D: You could, but that'd perform worse than just generating native JS
15:38:36 <merijn> I saw luite a few minutes ago, so he can tell you everything you want to know about that :p
15:38:44 <L8D> merijn: I'mnot talking about bytecode, I'm talking about the just-about-bytecode abstraction that ghc compiles to
15:38:57 <L8D> whatever it's called
15:39:11 <benmachine> Cmm?
15:39:12 <benmachine> maybe?
15:40:33 <merijn> GHC uses a number of intermediate languages
15:40:38 <merijn> Core, STG, Cmm
15:40:50 <L8D> sudo poweroff
15:40:56 <L8D> whoops
15:41:21 <josephle> with the -llvm flag, does that make ghc compile Cmm to LLVM?
15:41:28 <josephle> erm -fllvm
15:42:29 <albeit> Is Data.Text.Lazy's length O(1)?
15:43:01 <merijn> josephle: Yes
15:43:30 <merijn> josephle: Cmm gets turned into either machine code or LLVM asm and handed off to the LLVM machine code generator
15:44:16 <josephle> makes sense
15:45:21 <benmachine> albeit: given that you can have infinite lazy text values, it seems improbable
15:45:31 <cite-reader> albeit: O(n), according to the documentation.
15:45:40 <merijn> albeit: Lazy Text is O(n/32kb)
15:46:10 <benmachine> oh, and Text.length is separately difficult because of reasons
15:46:28 <merijn> albeit: Because it's divided into 32kb blocks by default and only needs to traverse blocks to find the length (well, if you concat smaller length blocks it's more than that, but you get the idea)
15:46:28 <benmachine> like, it's not the number of bytes divided by 2 or anything simple like that
15:46:40 <merijn> oh
15:46:47 <merijn> Actually, benmachine might be right
15:46:56 <benmachine> I'm not sure if text values cache length
15:47:02 <merijn> My logic applies to Lazy ByteString, text might be O(n)
15:47:10 <albeit> Okay, thanks
15:47:12 <merijn> Because unicode means you need to scan every single character
15:47:33 <albeit> If my Text/ByteString is always < 32kb, is a Lazy Text/ByteString effectively the same as a Strict?
15:48:24 <benmachine> I think that's up to who generates it
15:49:01 <merijn> albeit: Only if you generate it as a single chunk
15:49:25 <jle`> even if you don't, the strict version at least knows that it's <32kb, whereas the lazy version still has to check the first time
15:50:43 <albeit> Okay. Trying to figure out best way  to this... I have a lazy Text, which I need to add its length to the beginning, then a checksum of the entire thing to the end, then have it end up as a Strict ByteString. Should I just make it do everything within Data.ByteString?
15:51:07 <albeit> (and then send it over a socket...)
15:51:58 <benmachine> albeit: when you say "length", which length do you mean?
15:52:02 <benmachine> byte length?
15:52:08 <albeit> benmachine: Yes
15:52:23 <albeit> (Ah also, everything is strict ASCII)
15:52:24 <merijn> albeit: I would say that defining a binary format would be simpler
15:52:27 <benmachine> I'd turn it into a bytestring first
15:52:44 <benmachine> but look at me talking like I know things about things
15:52:46 <merijn> albeit: i.e. First encode Text to ByteString, then encode length + checksum of the encoded Text
15:52:48 <benmachine> I do not know things
15:53:36 <fuzzyhorns> anyone done this kata? http://www.codewars.com/kata/53d2c97d7152a59b64001033/train/haskell
15:53:37 <albeit> merijn: Okay, so once the initial Text is encoded as ByteString, nothing from then on will be using Data.Text?
15:53:49 <merijn> albeit: Right
15:53:55 <fuzzyhorns> i have a solution that works on my machine but when i submit it, no dice, so i am curious what others have done :p
15:54:10 <albeit> merijn, benmachine: Thanks, I'll give it a shot
15:54:30 <merijn> albeit: Then compute checksum + length over ByteString and use the binary library to serialise the length + checksum + bytestring blob to bytestring on the socket
15:54:48 <vanila> fuzzyhorns, what is it I cant see it without an acount
15:54:52 <merijn> albeit: (although, this assumes you're free to define your own wire format, i.e. you don't have to interoperate with existing code)
15:55:14 <fuzzyhorns> ah, well, it's an exercise to "Create an SQLite3 database /tmp/movies.db
15:55:15 <fuzzyhorns> Your database should have a table named MOVIES that contains the following data:"
15:55:22 <fuzzyhorns> and what I've written does do that
15:56:00 <albeit> merijn: Can't define my own wire format, it has to conform to an outside standard. But I guess I never need to create one final big BS, I can just send the pieces as they are ready (in the proper order)
15:58:08 <albeit> merijn: Is there an easy way to both sum up the char values and encode to ByteString a Text value at the same time?
15:58:41 <merijn> albeit: Not really
15:59:53 <albeit> Okay, and the binary library for serializing is Data.ByteString.Builder I presume?
16:00:08 <dgpratt> can someone interpret this for me? data Packed (f :: k -> k' -> *) a = forall s. Pack (f s a)
16:00:26 <dgpratt> particularly the type signature of f
16:00:48 <merijn> albeit: THat's mostly for constructing them, Data.Binary.Put (from the binary package) is for serialisation
16:01:15 <merijn> albeit: Make sure you use explicit put, not the Binary instance, that inserts random junk
16:01:38 <merijn> dgpratt: f is a type that takes two arbitrary kinds and returns a type of kind *
16:01:47 <egasimus> Cale, srhb, merijn and everyone: thanks again for helping me immensely with figuring out what the hell I'm doing :D
16:01:58 <srhb> o/
16:02:07 <egasimus> Good night #haskell ; )
16:02:27 <dgpratt> merijn, ok I'll try to consider the implications of that :)
16:03:29 <dgpratt> wait...isn't kind of * more or less arbitrary?
16:03:38 <merijn> dgpratt: "Packed Either Int" would be a valid type, but this kind for 'f' is strictly more general, since it also allows lifted kinds like Nat as argument
16:04:31 <merijn> dgpratt: Suppose I had "data Foo :: Nat -> Bool -> * where Foo :: Foo 1 True", then "Packed Foo Int" is valid, but if 'f' didn't have an explicit signature, it wouldn't be
16:05:37 <dgpratt> ok, gonna need to think about that, but thanks merijn
16:06:15 <albeit> merijn: By the explicit put, you mean (for example) putWord8 instead of the "put" method of the Binary class?
16:09:08 <albeit> Ah actually I think I might not need Data.Binary, as the length and checksum need to be encoded as characters, not raw binary...
16:09:11 <merijn> albeit: right
16:09:27 <merijn> albeit: or putByteString, etc.
16:10:19 <merijn> "runPut $ putWord8 1 >> putByteString foo" results in a byte with value 1 followed by all bytes in the foo bytestring, but using the typeclass instance inserts it's own encoding specific stuff in there
16:13:13 <mattbrandt> i'm trying to build an arm-linux cross compiler on OS X and I'm stuck in the final stage. It looks like it is trying to build hsc2hs for the target, but Stage1Only is YES. Should it be trying to do this? It gets a ton of link errors.
16:14:06 <zq> is Int an instance of Monoid?
16:14:20 <zq> or rather, why isn't instance Monoid Int included in Data.Monoid?
16:14:34 <newsham> there are different monoid newtypes for ints
16:14:39 <newsham> like Sum and Product
16:14:49 <zq> 'newtypes'?
16:15:00 <exio4> wrapped Ints basically
16:15:01 <newsham> > mconcat [Sum 1, Sum 2, Sum 10]
16:15:03 <lambdabot>  Sum {getSum = 13}
16:15:14 <zq> @hoogle SUm
16:15:16 <lambdabot> Prelude sum :: Num a => [a] -> a
16:15:16 <lambdabot> Data.List sum :: Num a => [a] -> a
16:15:16 <lambdabot> Data.Monoid Sum :: a -> Sum a
16:15:16 <zq> @hoogle Sum
16:15:16 <lambdabot> Data.Monoid Sum :: a -> Sum a
16:15:16 <lambdabot> Data.Monoid newtype Sum a
16:15:18 <lambdabot> Prelude sum :: Num a => [a] -> a
16:15:29 <albeit> Thanks for the guidance merijn!
16:15:45 <zq> meh, it says so right there on the docu page i have opened. thanks.
16:15:52 <newsham> yw
16:16:46 <albeit> Generally, if I'm dealing with pure ASCII data, and its moving over sockets, and sometimes doing some logging, would it make more sense to stick purely with ByteString instead of Text?
16:17:05 <preyalone> What does this do? (I'm new to monads.) (~>>) :: (Monad (t m), Monad m, MonadTrans t) => t m a -> (a -> m b) -> t m b
16:17:05 <preyalone> (~>>) m f = m >>= lift . f
16:17:45 <newsham> ?type lift
16:17:46 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
16:18:05 <newsham> it has to do with monad transformers.
16:18:34 <newsham> its like >>=  except its passing it into something thats is lifted from monad to monad transformer
16:19:00 <preyalone> What about this? (~>~) m f = m >>= \x -> (lift . f) x >> return x
16:19:22 <newsham> so intead of:    foo >>= (\x -> lift (bar x))   you can just do     foo ~>> bar
16:19:52 <newsham> the second one is the first one with an extra "return x".   ignoring the intermediary result
16:20:04 <preyalone> hmm, thanks
16:28:23 <merijn> ooh, neat
16:28:27 <merijn> where's that defined?
16:30:26 <benzrf> preyalone: so like
16:30:31 <benzrf> get ~>~ putStrLn
16:30:32 <benzrf> er
16:30:34 <benzrf> get ~>~ print
16:30:40 <benzrf> will result in get
16:30:41 <benzrf> but also print!
16:31:14 <preyalone> get, returning the get value, and printing as a side effect along the way?
16:31:22 <codehero> i did not know this one
16:32:42 <merijn> I still haven't found which package defines that, though
16:34:07 <preyalone> benzrf: thanks! could you give an example usage of the first one, ~>> ?
16:35:25 <preyalone> get ~>> putStrLn could return unit, or whatever putStrLn returns?
16:35:54 <benzrf> preyalone: (~>>) is just (>>=) except that the 2nd one returns an unlifted action in the base monad
16:37:52 <preyalone> by the way, what's >> and how does it relate to >>= ?
16:38:13 <merijn> preyalone: "x >> y = x >>= \_ -> y"
16:38:14 <hpc> @src (>>)
16:38:14 <lambdabot> m >> k = m >>= \_ -> k
16:38:26 <shachaf> preyalone: The answer is in Hoogle.
16:39:13 <shachaf> It's the best way to answer questions like that. It search symbols and everything.
16:40:05 <preyalone> blargh, i just need to suck it up and learn monads
16:40:26 <dibblego> preyalone: we can do that on IRC, perhaps another channel is best?
16:40:45 <shachaf> oh boy
16:40:52 <merijn> There's no such thing as "learning monads"
16:41:20 <benzrf> preyalone: do you into functors.
16:41:44 <preyalone> thanks for offering :) learn you a haskell should do the trick
16:42:01 <merijn> There's learning: 1) typeclasses, 2) type signatures, 3) polymorphism and 4) learning the Monad instance for specific datatypes (not necessarily in that order) and that's it
16:44:42 <preyalone> typeclasses, check. type signatures, check. functors, check.
16:44:42 <preyalone> last one. can someone explain what this does, in newbie terms? into :: (Monad m, MonadTrans t, MonadState b (t m)) => m a -> (a -> b -> b) -> t m b
16:44:42 <preyalone> into source f = lift source >>= modify . f >> get
16:45:22 <merijn> preyalone: That mixes three things in non-obvious ways
16:46:13 <merijn> preyalone: 1) State monad, 2) monad transformers, and 3) mtl's "automatic" lifting using typeclasses
16:46:44 <preyalone> state monads, check.
16:46:45 <merijn> preyalone: I would make sure to learn the first two, before looking into the 3rd and understanding all three before bothering to figure out that type
16:50:14 <newsham> you're running the "source" action, then using its output to modify the state in the state monad with the "f" function, then you're returning the state
16:50:56 <newsham> so like..  you might use "read ints from file" as source, and then "sum" as f,  I think?
16:51:49 <newsham> er.. sum is a bad example, it has to take two args, the old value of state and the result of the "source".
16:52:34 <newsham> better example   into (readIntoFromFile "foo.txt") (+)      -- to accumulate a new value from a file into yoru state
16:52:47 <newsham> does that make sense with the defn of "into" above?
16:56:02 <trap_exit> so
16:56:08 <trap_exit> I'm using haste-lang ... I create a data type ... how do I auto have it drive Binary ?
16:57:35 <luite> trap_exit: there is no mechanism for that, you could do data X = ... deriving Generic, and then instance Binary X
16:57:49 <merijn> luite: Haste doesn't use GHC, so that's not going to work, is it?
16:57:50 <luite> then it'll pick the default instance based on Generic
16:58:13 <luite> merijn: it does, it has a somewhat changed base lib though, and no TH
16:58:23 <merijn> ah
16:58:26 <luite> but deriving Generic should still work
17:00:22 <luite> (I don't have much experience with it though, there might be breakage if GHC 7.8 changed some things in GHC.Generics)
17:04:33 <trap_exit> luite: I got it working via about 4 lines of hand written code :-)
17:04:52 <trap_exit> luite: did Gates fix you rmbp yet?
17:10:22 <mizu_no_oto> When I run 'cabal build', cabal is currently failing to build my test suite.  Running with -v, the issue seems to be that "/Users/me/.nix-profile/bin/ghc --make -no-link -fbuilding-cabal-package … -package-id mypackage-0.1.0.0-inplace -XHaskell2010 ./test.hs -O2" is failing with "<command line>: cannot satisfy -package-id mypackage-0.1.0.0-inplace"
17:11:06 <kvanb> mizu_no_oto: did you install your package globally
17:11:16 <mizu_no_oto> kvanb: no.
17:11:25 <kvanb> I know people have issues with cabal and the testsuite for i..e bytestring
17:11:53 <mizu_no_oto> I've got a cabal sandbox, and I ran install in the sandbox
17:22:42 <coiler3> I'm trying to understand why doing "  foldr mappend mempty $ map First $ [Nothing, Just 9, Just 10, Just 11]  " doesn't return Just10 . wouldn't foldr "shortcircuit" when it encounters Just 10 `mappend` Just 11 and figure out it doesn't need to go on?
17:22:58 <shachaf> No.
17:23:16 <shachaf> foldr f z [a,b,c] = f a (f b (f c z))
17:23:48 <shachaf> So in your case: foldr mappend mempty [First Nothing, First (Just 9), First (Just 10), First (Just 11)] = ?
17:26:22 <coiler3> but looking at how foldr is defined, it keeps doing:   "   go (y:ys) = y `k` go ys   ". but because the `k` here is the mappend of First, and if y is an instance of First, why would it go on?
17:27:10 <coiler3> from the definition of First:   "   r@(First (Just _)) `mappend` _ = r   "
17:27:24 <shachaf> You should write out the answer to my question.
17:27:31 <shachaf> I did half of it.
17:27:49 <coiler3> I understand that if the computation actually did f a (f b (f c z)) the answer is Just 9.
17:28:25 <shachaf> The actual value of foldr f z [a,b,c] is (f a (f b (f c z)))
17:28:56 <coiler3> I don't see how that is true, given the lazy nature of haskell and the definition of mappend...
17:29:33 <josephle> what do you mean by the "lazy nature" of haskell?
17:29:36 <shachaf> It's true because of the definition of foldr.
17:29:39 <shachaf> @src foldr
17:29:39 <lambdabot> foldr f z []     = z
17:29:39 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:29:52 <shachaf> foldr f z (a:[b,c]) = f a (foldr f z [b,c])
17:30:19 <coiler3> foldr f z (x:xs) = f x (foldr f z xs)     --> what if the definition of f only looks at the first variable and ignores the second?
17:30:25 <shachaf> This is an equation, which means those things are equal.
17:30:33 <shachaf> Then those things are still equal.
17:30:42 <coiler3> there will be no need to evaluate the "(foldr f z xs)" part
17:30:44 <shachaf> (foldr f z xs) just won't be evaluated.
17:30:46 <shachaf> Right.
17:31:24 <glguy> coiler3: You understand that that 'x' is going to match 'First Nothing' first, right?
17:31:38 <coiler3> ah, seems I got it backwards. I think I get it now
17:32:23 <coiler3> thanks
17:42:25 <jle`> such lazy
17:43:42 <erikd> @hoogle ($!)
17:43:43 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
17:43:43 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
17:44:00 <erikd> @src Prelude.($!)
17:44:00 <lambdabot> Source not found. :(
17:44:23 <jle`> btw, foldr mappend mempty . map f = foldMap f
17:44:55 <exio4> @src Prelude.$!
17:44:55 <lambdabot> Source not found. Sorry.
17:46:26 <trap_exit> besides installing ghcjs, is there a way to use Data.Text.Lazy with Haste ?
17:48:44 <ReinH> trap_exit: Even if you could, you wouldn't get much benefit
17:48:53 <trap_exit> ReinH: why not?
17:49:00 <trap_exit> reinH: is Data.Text some C library?
17:49:04 <trap_exit> I thought it was pure hskell.
17:49:28 <trap_exit> What library do I use for efficient Text in Haste ?
17:50:24 <ReinH> Text uses arrays, which would require a host language with efficient arrays
17:50:25 <jle`> does haste have a native text library?
17:50:39 <trap_exit> jle`: I don't know
17:50:40 <jle`> ghcjs offers access to native strings
17:50:44 <ReinH> Javascript in the browser is not going to provide high performance vector-like data structures
17:50:54 <jle`> and that's probablythe best you'll get
17:50:58 <trap_exit> ReinH: since I'm using Haste, what should I use as a String replacement ?
17:51:03 <trap_exit> surely there is somethinb etter than a list of chars
17:51:18 <ReinH> I don't know.
17:51:21 <trap_exit> oh right there is JSString
17:51:23 <jle`> surely haste offers access to native strings
17:51:30 <jle`> yup...that sounds like it
17:53:04 <josephle> it seems haste arrays are based on JS arrays
17:53:18 <josephle> which would be good enough since JS strings are arrays of chars
17:55:25 <jle`> does webkit etc. allocate strings contiguously?
18:00:32 <luite> jle`: yeah GHCJS can just use the text package without changes, but JS is not ideal for that because of the relatively high overhead of allocating short typed arrays. I'm planning to add a Data.JSString module that has an interface similar to Data.Text, and counting on backpack or similar to eventually make it possible to swap the implementation to the one best for the platform
18:01:09 <luite> but I'm busy with some major refactorings to improve the intermediate language and optimizer, so i haven't had much time for that
18:01:18 <CrazyM4n> Anyone have a good, easy functional language tutorial for a friend who likes imperative languages?
18:02:52 <luite> it's actually a pretty nice and self-contained task, so if anyone wants to help, implementing Data.JSString, using fusion like Data.Text and a similar APi, would be very welcome, and i'd be happy to answer questions
18:04:09 <coiler3> CrazyM4n - I'm going through Learn You a Haskell
18:04:19 <luite> josephle: JS strings are not arrays of chars
18:04:51 <yellowcalx> Quick question, when importing a file containing other imports do I import these as well? Because I import a file containing system.random however when I call random functions they're out of scope. Do I need to import them system.random for each file I use it in?
18:04:58 <Gal3rielol> hi, what's the type of *->*, any to any?
18:04:59 <josephle> luite: really. I should probably reread the JS spec then...
18:05:17 <yellowcalx> containing an import of system.random it should say :)
18:06:08 <luite> josephle: they have some array-like properties, like length, but they're immutable and a different type, with different properties and prototype
18:06:31 <yellowcalx> Seems more logical for it to inherit the imports of an imported file, but the error doesn't really make sense otherwise.
18:06:33 <kcc> Gal3rielol: * -> * is a kind, not a type
18:06:34 <luite> but Data.Text uses ByteArray# internally
18:06:42 <albeit_> What library do you recommend for building ByteStrings, where most pieces are <10 bytes and the final is ~150 bytes? There is blaze-builder, Data.ByteString.Builder, and Data.Binary.Put, and not sure which I should use...
18:07:01 <josephle> luite: ah, you're correct... ('' === []) evaluates to false
18:07:33 <Gal3rielol> what's that mean in `class Functor (f :: * -> *)`
18:07:39 <josephle> something to remember when I code golf (and the solution checker uses ===)
18:07:39 <trap_exit> hmm
18:07:47 <trap_exit> waht is the most way to do [JSString] -> JSString ?
18:07:50 <coiler3> Gal3rielol - look here:   http://learnyouahaskell.com/making-our-own-types-and-typeclasses#kinds-and-some-type-foo
18:07:57 <joelteon> what is the most way
18:08:15 <trap_exit> probably javascript's concat
18:08:24 <trap_exit> most efficient
18:11:37 <luite> trap_exit: I'd test that first, to use JS' concat (join) you'd first need to construct an array. if you use JS's append (concat), then you can at least avoid that.
18:12:27 <luite> trap_exit: the implementation might use ropes to make that efficient (also + could be faster than concat)
18:14:18 <luite> joelteon: also String.charAt(n) does not always give you the char at index n
18:14:48 <trap_exit> you know what?
18:14:52 <joelteon> it doesn't?
18:15:01 <trap_exit> I suddenly no longer need fast text in my js code
18:16:49 <yellowcalx> What does one type instead of StdGen when calling a function with an argument being StdGen?
18:17:21 <luite> joelteon: yeah it's the same reason that Data.Text.index is O(n)
18:17:34 <joelteon> sorry, what are we talking about?
18:17:39 <joelteon> is this about UTF-16
18:18:48 <Hijiri> An index I use for an IxSet doesn't have to be unique for each item, right?
18:19:19 <luite> joelteon: yeah, indexes it as it were an array of 16 bit values
18:19:38 <codygman> Has anyone setup hell? I'm having some problems with actually using it and keep getting a "hell: Failed to load interface for ‘Data.Conduit.Shell’" error.
18:19:54 <Hijiri> Could I index by boolean and get every element that has True in that field, for example?
18:19:58 <luite> joelteon: but some codepoints in UTF-16 take 2*16 bit in the encoding, you just get one half of a surrogate pair then
18:21:00 <luite> joelteon: if you request such an index in JS. and of course it affects the position of everythign after, if you care about codepoints and not byte offsets
18:22:16 <luite> oh josephle left and my nick completion suddenly turned to joelton
18:24:30 <albeit_> What functionality does blaze-builder have that Data.ByteString.Builder does not?
18:25:30 * hackagebot haste-perch 0.1.0.4 - Create, navigate and modify the DOM tree with composable syntax, with the haste compiler  http://hackage.haskell.org/package/haste-perch-0.1.0.4 (AlbertoCorona)
18:41:08 <fuzzyhorns> anyone know if current ghci still works with Debug.Hood.Observe?
18:41:18 <fuzzyhorns> it says so here, http://www.haskell.org/haskellwiki/Debugging, but it doesnt seem to work for me
18:51:45 <sgronblo> wow, i remember when mapM_ was a scary concept
18:51:59 <sgronblo> and now it just makes sense
18:52:23 <fuzzyhorns> sgronblo: explain it to me :)
18:55:50 <zq> it really really sucks that the loops provided in Data.Text don't fuse
18:57:13 <Guest82889> Can anyone explain why the use of RankNType helps implement runST?
18:57:25 <Guest82889> I'm reading http://en.wikibooks.org/wiki/Haskell/Polymorphism#runST
18:57:39 <shachaf> There are multiple reasons.
18:57:56 <Guest82889> But can't understand the part "Because the argument must be polymorphic in s, it has to return one and the same type a for all states s"
18:58:32 <shachaf> Calling "s" a "state" is pretty odd.
18:59:34 <fuzzyhorns> also can anyone give me a newbie explanation of stream fusion and why it matters?
18:59:44 <shachaf> Anyway, do you see what we're trying to avoid?
19:00:19 <Guest82889> Yeah, trying to avoid the StRef leaking out of the context it was originally created?
19:01:31 <shachaf> Right. If I say something like runST (do { r <- newSTRef ...; modifySTRef r ...; x <- readSTRef r; return x }), that's fine.
19:01:53 <trap_exit> https://gist.github.com/anonymous/fe15974c302c3e173a4a
19:01:56 <trap_exit> how do I fi this error?
19:02:00 <shachaf> But if I say runST (do { r <- newSTRef ...; return r }), that doesn't make much sense, because the variable can't really exist outside the runST.
19:03:17 <shachaf> The way we do that is by, instead of just having e.g. newSTRef :: a -> ST (STRef a), readSTRef :: STRef a -> ST a, etc., adding a type variable that ties all the related ST values together.
19:03:38 <shachaf> So we have newSTRef :: a -> ST s (STRef s a), readSTRef :: STRef s a -> ST s a, etc.
19:03:45 <splintax> how is runST :: (forall s. ST s a) -> a different to foo :: ST s a -> a? is the latter a valid type signature?
19:04:05 <shachaf> The latter is valid but means something very different. The question is who gets to choose s.
19:04:22 <shachaf> In the former runST gets to choose s. In the latter you get to choose s.
19:04:33 <shachaf> I was getting to it.
19:04:42 <Axman6> fuzzyhorns: I'm trying to find you a good link  on stream fusion, but don stewart's blog has all but disappeared
19:04:49 <shachaf> Actually no I wasn't.
19:04:51 <shachaf> Good luck.
19:04:57 <fuzzyhorns> Axman6: :c too bad
19:05:24 <Axman6> fuzzyhorns: have you read http://metagraph.org/papers/stream_fusion.pdf?
19:05:32 <fuzzyhorns> no
19:05:52 <splintax> also, what is the meaning of the . after forall s?
19:05:59 <splintax> is it composition?
19:06:38 <zq> splintax: it's just notation for "such that"
19:07:04 <splintax> oh, it's syntax?
19:07:09 <Axman6> it basically just ends the list of variables that the forall applies to
19:07:16 <zq> it demarcates quantification of type variables from the type expression itself
19:08:09 <zq> foo :: ST s a -> a == forall s a . ST s a -> a
19:08:28 <splintax> it reminds me of lambda calculus notation, so it's kind of weird that lambdas use -> for the same purpose in haskell
19:08:30 <zq> runST :: forall a. (forall s. ST s a) -> a
19:10:38 <splintax> zq: yeah, i got that far, but i'm still feeling a little confused about the difference between those two types, even after adding the implicit 'forall a'. because i think of (a -> b) -> c and a -> b -> c as being basically the same thing and it seems analogous
19:11:10 <zq> splintax: it helps to think about polymorphic functions as functions that accept the polymorphic type as one of its arguments
19:12:00 <Axman6> fuzzyhorns: http://donsbot.wordpress.com/2008/06/04/haskell-as-fast-as-c-working-at-a-high-altitude-for-low-level-performance/ finally found it!
19:12:18 <zq> so for instance, you would think of const :: forall a b. a -> b -> a as const = \(A :: Set) (B :: Set) (a :: A) (b :: B) -> a
19:12:47 <zq> Set is denotes the type of types
19:12:52 <zq> s/is //
19:14:08 <codygman> playing around with shqq (shell quasiquoter), is there a better way to do this: [sh| ls |] >>= return . lines >>= filterM (return . (isInfixOf) "txt") I'll have to just lift each pure function into a monad right?
19:14:55 <johnw> filterM with return is odd
19:14:58 <johnw> use fmap filter
19:15:23 <johnw> same with return .lines
19:15:31 <trap_exit> monads-tf vs mtl
19:15:32 <trap_exit> which one do I keep
19:15:34 <trap_exit> which one do I hide?
19:15:37 <johnw> mtl
19:15:38 <johnw> keep
19:15:42 <johnw> monads-tf is old
19:15:55 <shachaf> fmap (filter ("txt" `isInfixOf`) . lines) [sh| ls |]
19:16:10 <shachaf> But of course you shouldn't be using [sh| ls |] to list files in the first place.
19:16:14 <shachaf> There are many reasons not to do it.
19:16:36 <splintax> zq, shachaf: ok, so for the rank-1 thing, you specify the type variables when you pass arguments to the function. but in the case of runST, runST itself "chooses" the value of the type variable s?
19:16:56 <trap_exit> johnw: keep mtl, kill monads-tf ?
19:17:03 <johnw> trap_exit: not kill, just ghc-pkg hide
19:17:03 <splintax> what does it mean for the function to "choose" the type of its argument?
19:17:26 <johnw> splintax: show (10 :: Int), I'm choosing Int for show's polymorphic 'a' type
19:18:32 <fuzzyhorns> given that recursive functions have to be translated to imperative loops to be fast, what's the advantage to recursion?
19:18:35 <trap_exit> johnw: fuck, I just broke haste; how do I unhide? ghc-pkg --help | grep hide
19:18:37 <trap_exit> does not show unhide
19:18:43 <johnw> with runST, I have to provide a function that's polymorphic over a type variable; runST will end up creating a "skolem" (like a unique unnamed type), so that I can't mix-and-match with other invocations of runST
19:19:35 <johnw> trap_exit: expose
19:20:05 <johnw> fuzzyhorns: recursion is not based on mutating memory locations in place
19:20:31 <fuzzyhorns> johnw: so basically its about having a high level transformation, whereas loops only happen low level?
19:20:45 <fuzzyhorns> sorry i am not a skeptic just trying to phrase for myself
19:21:06 <johnw> let's say that by choosing a representation of the code that does not rely on mutation, the compiler is free to use mutation if it wants to
19:21:19 <johnw> but if your algorithm is based on mutation, you've locked in what can happen a lot more
19:21:31 <fuzzyhorns> johnw: thats a good way of putting it
19:21:45 <johnw> people who try to auto-parallelize C are intimately familiar with this issue
19:21:59 <fuzzyhorns> johnw: im afraid i am not
19:22:26 <johnw> C is good at saying what you want the compiler to do, specifically; Haskell is good at saying what you want the answer of your function to be
19:22:59 <fuzzyhorns> gotcha, but do you think a programmer should have experience with both?
19:23:14 <johnw> I think it's good for people to know how everything works, so sure
19:23:32 <johnw> but it's better to think in terms of what things mean, than how they happen
19:23:50 <fuzzyhorns> very true
19:24:08 <fuzzyhorns> what do you think is relationship between declarative and functional langs?
19:24:08 <splintax> recursion is also a more general concept than looping
19:24:20 <johnw> I'm not familiar enough with declarative languages to say
19:24:27 <fuzzyhorns> splintax: how so?
19:24:41 <splintax> recursive data structures like trees are common in the real world
19:25:02 <splintax> you need to do book keeping to enumerate a tree using loops
19:25:29 <fuzzyhorns> book keeping? as in additional references to the accumulator?
19:26:56 <splintax> i'm not sure if that's what i mean
19:27:24 <splintax> but i'm envisioning trying to enumerate an arbitrarily deep tree (say, a JSON object) in an imperative language without recursion
19:27:53 <splintax> and it seems non-trivial to me
19:28:07 <johnw> I'd do it with a "cursor", like a C++ iterator, which abstracts the recursion for me
19:28:26 <fuzzyhorns> what is a cursor exactly, johnw?
19:28:37 <fuzzyhorns> is it like an intermediate value?
19:28:40 <johnw> a cursor is a view into a data structure that you move along by inching it forward
19:29:01 <johnw> *foo; foo++; *foo; foo++; *foo, etc.
19:29:30 <johnw> in Haskell, thanks to laziness, that just becomes a list and I needn't care about any of the details
19:29:58 <splintax> i suppose when you get down to it the difference between doing recursion in an imperative language using an iterator in a library, and doing recursion on an imperative computer using logic built into a compiler, is not that great
19:30:22 <johnw> splintax: agreed
19:30:35 <johnw> we are always evolving toward abstraction it seems
19:30:45 <fuzzyhorns> that is what i sort of think splintax
19:31:14 <splintax> but it does show that recursion is a fundamental concept, whether it's native to your language or you have to implement it yourself
19:31:50 <splintax> it's not so obvious that mapping over a list is "inherently" recursive
19:31:51 <fuzzyhorns> i feel as if the real fundamental concept maybe is mathematical induction
19:32:12 <splintax> fuzzyhorns: yeah, me too
19:32:28 <fuzzyhorns> splintax: most approach via enumeration i think, rather than recursion, if that makes sense
19:32:34 <johnw> I really like this talk by Guy Steele: http://www.infoq.com/presentations/Thinking-Parallel-Programming
19:32:55 <johnw> he talks about a program on punch card, and how every evolution in programming has taken us step by step further away from caring about how the machine does things
19:33:53 <splintax> fuzzyhorns: you mean, most programmers find looping easier to understand than recursion?
19:34:38 <johnw> programmers who were educated in terms of looping, sure :)
19:34:41 <splintax> recursion is pretty common in everyday life, so i don't really think it's an inherently difficult concept
19:34:56 <fuzzyhorns> splintax: idk if it is easier to understand exactly, i wonder sometimes if it is the way we portion work to programmers often. rather than trying to converge on things we can verify, we instead enumerate possible solutions with no regard to similar ones
19:35:22 <johnw> I think if you're taught recursion, it's easier; if not, it can be strange (as it was for me in the beginning)
19:35:39 <fuzzyhorns> it is still sometimes strange for me, but i am learning i think
19:36:01 <splintax> i still find it a bit strange
19:36:16 <splintax> because how can a function refer to itself before it finishes defining itself?
19:36:30 <fuzzyhorns> yeah that still sometimes gives me the willies lol
19:36:43 <srhb> "finishes defining itself" being the broken idea. :)
19:36:52 <fuzzyhorns> though i like to think of the "edge case" instead of the "base case" to sort of feel that instead
19:37:38 <splintax> although (like fuzzyhorns said before) the same kind of strangeness also applies to mathematical induction
19:38:30 <johnw> well, because it's exactly the same thing :)
19:50:54 <tim_heap> Hi all. I have a small program that I wrote that works fine, but I feel the code could be more idiomatic / improved in ways I dont know about yet. Could anyone take a look and critique it?
19:51:02 <dfeuer> tim_heap, yes.
19:51:17 <dfeuer> Well, maybe. We can try.
19:51:23 <lpaste> tim_heap pasted “RandomAlbum.hs” at http://lpaste.net/111892
19:51:37 <fuzzyhorns> curious what you guys think: http://www.reddit.com/r/compsci/comments/2hyeiy/re_the_mess_were_in_in_the_1980s_it_was_cshmake/
19:52:25 <tim_heap> dfeuer, thanks. See the lpaste link. It monitors an MPD playlist, and adds more random albums when the playlist is getting empty
19:53:12 <dfeuer> tim_heap, I don't know that much about random stuff, but what's the point of   let randomSource = DevURandom?
19:54:05 <tim_heap> dfeuer, I was trying out a few different random sources before settling on DevURandom. It was easier to swap when it was isolated.
19:54:15 <tim_heap> Having its own variable is not as necessary now
19:54:26 <dfeuer> Let me restate that, tim_heap. If you're trying to make it easier to use a different random source, you can make that definition at the top level; there's no need to put it in main.
19:54:44 <tim_heap> There is if your random source required IO to seed itself :)
19:55:06 <AshyIsMe> fuzzyhorns: there is a lingua franca, it's javascript unfortunately
19:55:19 <AshyIsMe> worse is better! (yay)
19:55:23 <fuzzyhorns> AshyIsMe: that is often what seems true :o
19:57:03 <dfeuer> tim_heap, it's considered rude to use more bits of /dev/urandom than necessary. For an album player, you should pull a couple bytes from there to seed a generator.
19:57:12 <dfeuer> And no more.
19:58:23 <dfeuer> /dev/urandom is for *secure* random number generation for short-term keys (like https session keys). It's not as tough on the system as /dev/random, which is for long-term keys, but it's not free.
19:58:57 <fuzzyhorns> hah oh no: http://i.imgur.com/t2QTEf9.png
20:00:16 <dfeuer> tim_heap, I think return stPlaylistLength `ap` status  should probably be  fmap stPlaylistLength status, no?
20:01:52 <tim_heap> defanor, fmap looks better, yes. I am still learning which of the little joining / chaining functions to use in which situation - there are a lot of them!
20:06:20 <dfeuer> tim_heap, me too.
20:07:19 <dfeuer> I had to look up the type of `ap`, but I knew from the start that applying return to something and then doing something else with that always has a fairly good chance of being the wrong way.
20:09:59 <tim_heap> So did I, but it was apparently a 'better' way of doing liftM. The examples in the docs for replacing `liftM` with `ap` has that odd return usage
20:10:52 <geekosaur> ap isn't necessarily a better way to do liftM. what it is is a generalization of liftM, liftM2, ...
20:11:08 <geekosaur> you can chain ap-s together instead of defining a liftM9 or whatever
20:11:22 <geekosaur> (there's a limited number of liftM<whatever>s predefined)
20:13:03 <dfeuer> @type ap
20:13:04 <lambdabot> Monad m => m (a -> b) -> m a -> m b
20:13:08 <dfeuer> @type (<*>)
20:13:09 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
20:13:52 <dfeuer> So ap is ... on its way out.
20:14:41 <geekosaur> and yes, Applicatives are an even more general version of ap, because ap requires Monad but <*> requires only a little more than Functor. ap was an early reaching for Applicatives, and as dfeuer just noted, we're moving to consolidate and merge the older things like ap with the new, more general ones
20:15:21 <tim_heap> Good to know.
20:15:53 <dfeuer> Is Phabricator still screwed up?
20:25:08 <johnw> is Sing not in base anymore?
20:25:49 <dibblego> (<*>) can be more general as Data.Functor.Apply#(<.>)
20:32:08 <dfeuer> How are GHC version numbers assigned?
20:32:23 <dfeuer> AMP + BBP in 7.10 makes me wonder why it's not called version 8.
20:32:59 <dfeuer> dibblego, what is Data.Functor.Apply#(<.>)?
20:33:20 <nkar> on my machine, the timestamp in /var/lib/sudo/$USER is not updated when I run shelly $ cmd "sudo" ...  does anyone know why?
20:34:10 <dibblego> dfeuer: https://hackage.haskell.org/package/semigroupoids-4.2/docs/Data-Functor-Apply.html#g:2
20:36:07 <dfeuer> dibblego, so is there a name for something offering only pure?
20:36:11 <jle`> MaybeApply f a = MaybeApply (Either (f a) f)
20:36:13 <jle`> that's nice
20:36:20 <dibblego> dfeuer: Pointed, but it has issues
20:36:26 <dfeuer> Issues?
20:36:28 <jle`> dfeuer: there's pointed, but nowadays it has been considered a bad idea
20:36:36 <jle`> it has fallen out of public opinion
20:36:44 <jle`> poor little thing
20:37:15 <dfeuer> So if Pointed is out, I guess really we should have Apply a => Applicative a instead of Functor a => Applicative a?
20:37:49 <jle`> what is considered more in-fashioned is Unit or something like that
20:38:02 <jle`> unit :: Unit u => u ()
20:38:05 <jle`> i forgot what it's called
20:39:42 <simpson> Wait, what's wrong with Pointed?
20:40:03 <jle`> no sensible laws
20:40:09 <johnw> Pointed is completely arbitrary
20:40:16 <johnw> it might as well be called "Inhabited"
20:40:59 <simpson> Well, pointed a = fmap (const a), so they're equivalent, I guess.
20:41:06 <simpson> Er, fmap (const a) unit
20:44:26 <dfeuer> There's something on the Haskell wiki about "Why not Pointed" quoting an explanation by edwardk, who apparently introduced the thing to begin with only to realize later that it was not useful enough.
20:46:03 <benzrf> johnw: Inhabited could be a useful class d:
20:46:33 <dfeuer> Does anyone know what's up with Phabricator?
20:46:59 <benzrf> ok bye
20:47:09 <edwardk> dfeuer: its true
20:47:24 <edwardk> dfeuer: at least the general notion of what you said there is true =P
20:47:42 <simpson> Okay. I am convinced.
20:48:24 <dfeuer> edwardk, where were those proposals for making it easier to handle bigger abstraction lattices?
20:49:04 <edwardk> dfeuer: richard eisenberg has something, but its not directly targeted at bigger abstraction lattices per se
20:49:05 <dfeuer> And could you remind me what's wrong with a class that adds no methods?
20:49:12 <edwardk> and my stuff isn't proposals for haskell
20:49:28 <dfeuer> You've given up on Haskell in favor of Ermine, whatever that is?
20:49:32 <joehillen> here is what dfeuer is refering to to save everyone else a google search: http://www.haskell.org/haskellwiki/Why_not_Pointed%3F
20:50:29 <edwardk> nothing is wrong with it per se, it just doesn't self document why you care, laws which don't let you write something else often fall beneath the grain of what a user is willing to put up with, so as a rule of thumb it helps separate 'academic wankery' which i'm prone to from 'practical code'
20:51:01 <albeit_> Is there a simple way to convert an Int to padded ByteString, without going through String/Text? f 4 57 = "0057"
20:51:44 <adarc> oooo shell-conduit looks dope
20:52:04 <dfeuer> edwardk, laws are usually good. Understanding them is another story.
20:53:30 <edwardk> dfeuer: i tend to limit the classes i introduce in haskell to ones where the laws i get let me write at least one additional combinator that has something meaningful to say. when refining a theory, i tend to limit myself to refinements that also include an extra operation component, even if the operation is constrained down by laws to be a unique thing, because it largely helps self-document the laws
20:54:00 <edwardk> and users get annoyed at filling out every point in a lattice of theories and getting nothing to show for it
20:54:07 <dfeuer> edwardk, I think that sounds likely to be sane.
20:54:16 <dfeuer> But you'd know better.
20:54:39 <edwardk> i figure i need some rule of thumb to avoid descending into madness )
20:54:46 <edwardk> or at least descending too far into madness
20:56:45 <dfeuer> edwardk, are you writing the streaming library to replace both pipes and conduit? Or are you leaving that to someone else?
20:57:13 <edwardk> @hackage machines
20:57:13 <lambdabot> http://hackage.haskell.org/package/machines
20:57:31 <edwardk> already written, they just don't know it yet.
20:57:35 * edwardk whistles innocently
20:57:46 <edwardk> actually it needs more work
20:57:53 <edwardk> but its a step in the direction i want to take it
20:58:09 <dfeuer> It probably also needs some human-readable documentation, which was entirely missing last I looked.
20:58:20 <edwardk> dfeuer: mostly because its due for a rather large rewrite
20:58:50 <edwardk> and it predates my 'documentation = users' phase
20:59:21 <dfeuer> edwardk, one approach is "documentation first". Write your documentation; then write the functions to match. It's better to have good documentation and no functions than good functions and no documentation.
20:59:52 <edwardk> dfeuer: i pretty much work bottom up. i have no idea what i'm writing until i've written it, and refactored it a half dozen times.
20:59:58 <dfeuer> Oh, I see.
21:00:01 <edwardk> then i look around and try to figure out what it is i have wrought
21:00:08 <dfeuer> Ha!
21:00:36 <dfeuer> Unusual, but I guess it goes with your "I don't care what I accomplish as long as I accomplish something" philosophy.
21:00:43 <edwardk> sometimes i can document the thing that emerges. other times i leave it like a piece of modern art, a bit of twisted wreckage someone might find inspiration in ;)
21:00:57 <edwardk> exactly =)
21:01:15 * hackagebot yesod-test 1.4.0.1 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-1.4.0.1 (MichaelSnoyman)
21:01:29 <dfeuer> Well, I hope you get that worked out soon.
21:02:11 <frankdreban> Can you help me with a kinda mathy translation for Lens? Along these lines if it'll work: http://www.pps.jussieu.fr/~mellies/papers/segal-lics-2010.pdf I suck at programming, but trying :-/
21:02:58 <edwardk> frankdreban: i'm still trying to figure out how to connect that to lenses
21:03:07 <edwardk> its an interesting paper, and very relevant to other work i'm doing
21:03:13 <edwardk> but i've yet to tie it back to lens
21:03:22 <frankdreban> Yeah? Connects to Grothendieck stacks too
21:03:25 <edwardk> so its either a brilliant insight or a remarkable detour ;)
21:03:51 <frankdreban> hm
21:06:11 <frankdreban> Pages 8-9 seems to summarize the possible connection, is it the monad/comonad difference? Should be a way around that
21:07:05 <edwardk> i'm only 4-5 pages in so far.
21:07:28 <edwardk> and trying to connect it to my intuition for complete segal spaces from hott, etc.
21:07:31 <frankdreban> lol sorry, I get excited
21:07:34 <edwardk> so i'm going slow =)
21:08:41 <edwardk> part of it is it is pretty heavily in another camp from the category theory i know well, so its taking me a while, another part is i went out drinking with an out of town coworker after work and am not at my best right now ;)
21:09:18 <edwardk> e.g. the linton condition stuff is alien to me
21:09:59 <edwardk> i have a rough idea of the notion of the segal condition and segal spaces
21:11:14 <frankdreban> Right on. This is just related to stuff that I feel comfy with (sheaves/bimodules/Morita stuff) - maybe we have a very complementary stock of intuitions. Having a hard time with Haskell due to some of that disconnect
21:12:10 <edwardk> anyways the 'presentation of the state monad' thing is very similar to the common sense lens laws
21:12:28 <edwardk> but i've come to think of the common sense lens laws as an emergent phenomenon, rather than ground truth
21:13:49 <edwardk> laws 1, 3 and 4 are the lens laws
21:14:16 <edwardk> the rest are things we don't say, because we don't require all lenses to be pairwise disjoint
21:15:05 <edwardk> if we had that then it'd be much easier to talk about horizontal composition, etc. but you'd basically has 'lenses as references / labels' which rules out a ton of good usecases
21:15:34 <edwardk> frankdreban: you may derive some benefit by diving through mike johnson's papers
21:15:59 <edwardk> http://comp.mq.edu.au/~mike/pub2000.html from 70+ or so
21:16:03 <frankdreban> Ok cool. (writing this all down too)
21:16:16 <edwardk> they may be closer to your set of intuitions than the presentation of lenses i offer
21:16:18 * hackagebot xml-conduit 1.2.3 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.2.3 (MichaelSnoyman)
21:16:20 * hackagebot http-reverse-proxy 0.4.1.2 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.4.1.2 (MichaelSnoyman)
21:16:22 * hackagebot http-conduit 2.1.4.4 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-2.1.4.4 (MichaelSnoyman)
21:16:24 * hackagebot cabal-src 0.2.3 - Alternative install procedure to avoid the diamond dependency issue.  http://hackage.haskell.org/package/cabal-src-0.2.3 (MichaelSnoyman)
21:16:26 * hackagebot yesod-auth 1.4.0.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.4.0.1 (MichaelSnoyman)
21:18:24 <edwardk> but as for the common sense lens laws i tend to think of them as an emergent phenomenon, if you write down the lens laws in terms of strong profunctors you get a notion that subsumes lenses, prisms and a bunch of other usecases and don't need to drag anything cartesian or cocartesian into the mix
21:18:31 <edwardk> it works for any monoidal category
21:19:13 <edwardk> that lets you talk about lenses into all sorts of exotic things, e.g. the functor category on C with functor composition gives a monoidal category, and we can talk about lenses into stacks of functors there
21:20:03 <edwardk> or a category of monad transformers (modules over all monads) with monad transformer homomorphisms between them can be equipped with a tensor product of monad transformers, and we can then talk about lenses into monad transformer stacks
21:20:19 <edwardk> but those notions of lenses don't fit the cartesian-product inspired intuitions
21:20:57 <edwardk> in the former case you can give me a natural transformation and i can use it to swap out a 'segment' of a functor chain
21:21:28 * hackagebot yesod-core 1.4.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.4.1 (MichaelSnoyman)
21:21:29 <edwardk> in the latter case you can give me a monad transformer homomorphism and i can swap out a segment of a monad transformer stack or something isomorphic to one
21:21:30 * hackagebot yesod-persistent 1.4.0.1 - Some helpers for using Persistent from Yesod.  http://hackage.haskell.org/package/yesod-persistent-1.4.0.1 (MichaelSnoyman)
21:21:32 * hackagebot yesod-static 1.4.0.1 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-1.4.0.1 (MichaelSnoyman)
21:25:07 <frankdreban> The strong profunctors approach makes sense to me (loosely), is that how you would prefer to approach it lately?
21:25:40 <edwardk> yeah
21:25:55 <dfeuer> Have at it.
21:25:58 <edwardk> that pretty much is how i think about lenses and the whole space of related effects
21:26:00 <frankdreban> Seems to set up the "Morita context" - there's another paper by this same guy that goes into the groupoid/nerve of isos construction
21:26:17 <edwardk> if you have a link i'd love to read it
21:26:20 * hackagebot yesod-fay 0.6.0 - Utilities for using the Fay Haskell-to-JS compiler with Yesod.  http://hackage.haskell.org/package/yesod-fay-0.6.0 (MichaelSnoyman)
21:26:24 <dfeuer> I'll just hope I read enough and think enough to understand it some year.
21:26:29 <frankdreban> I'll dig it up!
21:26:58 <edwardk> beyond Morita equivalence i don't know much w/ Morita involved
21:27:56 <frankdreban> Here it is: http://arxiv.org/abs/1310.0263
21:28:52 <edwardk> may need to catch up after monday/tuesday when i can catch up with dolio about this
21:28:54 <frankdreban> Morita context is kinda the set up for that type of equivalence, because all these different settings for it show up all over the place
21:29:32 <edwardk> yeah i stumbled across that much, but i don't have a good set of intuitions surrounding the construction
21:30:03 <frankdreban> Cool, I figured time intensive for this but unsure how interested you'd be
21:30:10 <frankdreban> was unsure, I mean
21:30:28 <edwardk> i'm definitely interested
21:30:57 <edwardk> you may want to join the #haskell-lens channel, we have a much greater ratio of folks in there who hold these interests, so you might have a chance to engage more than just me
21:31:20 * hackagebot yesod-fay 0.6.0.1 - Utilities for using the Fay Haskell-to-JS compiler with Yesod.  http://hackage.haskell.org/package/yesod-fay-0.6.0.1 (MichaelSnoyman)
21:32:26 <frankdreban> Cool! I tried the other night but it seemed kinda dead... I guess I have been battling with how to express myself on this stuff too. Typically I've been pretty isolated with the weird math hobby lol
21:32:26 <edwardk> anyways, the main bottleneck is going to be that i am attending IFL for the next 3 days or so, then have a weekend booked solid, so i'm trying to figure out when i can steal away to do homework on this =P
21:33:00 <edwardk> frankdreban: xplat, rwbarton, dolio, sclv, etc. in there have pretty solid math backgrounds
21:33:06 <frankdreban> No problems, I'll appreciate convo or anything really. I tend to obsess on this stuff
21:33:21 <edwardk> then #haskell-lens is the right place to do that ;)
21:33:46 <edwardk> we tend to clear out of the main channel when we get too geeky, lest we scare away _all_ the newcomers
21:35:50 <frankdreban> Ok, I should clear out of here for a sec and try to mull these thoughts a bit before I pop in there. Have a good night if you turn in meanwhile! And thanks so much!
21:36:33 <edwardk> frankdreban: not meaning to chase you out of the channel, just motivating the channel switch =)
21:38:32 <frankdreban> Oh ok hehe.... I'll brb though, haven't chatted in a while so I'm in like a stimulation overload right now lol
21:42:32 <CrazyM4n> Okay, I have a list of 4 2d lists
21:42:43 <CrazyM4n> And I want to go through and add them all up
21:42:53 <CrazyM4n> And keep the 2d-ness
21:42:55 <CrazyM4n> How would I do that?
21:43:00 <dmj`> what is a 2d list
21:43:03 <CrazyM4n> Err
21:43:12 <CrazyM4n> A list that contains lists that are all the same size
21:43:28 <mauke_> add what?
21:43:40 <CrazyM4n> Well, I want to do this:
21:43:44 <edwardk> :t zipWith4
21:43:45 <lambdabot> (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
21:43:48 <edwardk> :t zipWith
21:43:49 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
21:44:04 <CrazyM4n> I was thinking zipWith
21:44:10 <CrazyM4n> But I have this:
21:44:26 <edwardk> :t zipWith zip
21:44:27 <lambdabot> [[a]] -> [[b]] -> [[(a, b)]]
21:44:37 <splintax> "a list that contains lists that are all the same size" is a dependent type
21:44:38 <edwardk> :t zipWith (zipWith (+))
21:44:39 <lambdabot> Num c => [[c]] -> [[c]] -> [[c]]
21:45:06 <CrazyM4n> edwardk, that seems to be what I want
21:45:09 <CrazyM4n> Thank you
21:45:13 <edwardk> you can play all sorts of games like that
21:45:21 <dmj`> > map (\xs -> [sum xs]) [[1,2,4], [5,6,7]]
21:45:23 <lambdabot>  [[7],[18]]
21:45:28 <CrazyM4n> I realize that, but I couldn´t wrap my head around it
21:45:29 <CrazyM4n> Sorry
21:45:30 <dmj`> I don't know what you mean by 2dness
21:45:31 <edwardk> mostly just trying to get you some idea of how to put the parts together
21:45:35 <edwardk> no worries
21:45:50 <CrazyM4n> zipWith (zipWith (+)) is equal to (zipWith . zipWith) (+) correct?
21:45:55 <edwardk> yeah
21:46:01 <CrazyM4n> Sounds good
21:46:31 <CrazyM4n> I was so close, I said (zipWith . map) (+)
21:54:54 <frankdreban_> Is the Pierce paper on quotient lenses a good roadmap too? A big motivator of the Grothendieck search for stacks was to use fibrations to deal with quotient "misbehavior"
21:58:18 <frankdreban_> Sorta just trying to fill out a loose compass for this before it's really tango time, hehe
22:02:30 <frankdreban_> (actually, I'll just move this to the other room)
22:05:24 <mzero> grasping for terms here.... under the hood of a parsing monad, aren't there two styles of handling things - one more efficient than the other --- I seem to remember that attoparsec does one, and parsec the other?
22:05:27 <mzero> anyone?
22:07:54 <joehillen> mzero: https://hackage.haskell.org/package/attoparsec-0.12.1.2/docs/Data-Attoparsec-ByteString.html
22:08:43 <mzero> yeah - i had looked at that
22:08:55 <sgronblo> how come documentation for newer package versions is not available on hackage?
22:09:16 <joehillen> mzero: what exactly is the problem?
22:09:52 <mzero> I guess what I'm after is that a straight forward parsing monad has code like this:
22:10:05 <mzero>     q >>= g = LP (\s -> let (ma,s') = runLP q s  in maybe (Nothing,s') (\a -> runLP (g a) s') ma)
22:10:13 <mzero> where you chain things together....
22:10:26 <mzero> but have a vague sense there is a more efficient way to do this
22:10:42 <mzero> something about transforming it into continuation passing style
22:11:42 <joehillen> hmm, you'd have to ask bos
22:11:52 <mzero> k
22:26:24 * hackagebot XSaiga 1.0.0.0 - An implementation of a polynomial-time top-down parser suitable for NLP  http://hackage.haskell.org/package/XSaiga-1.0.0.0 (InBetweenNames)
23:19:00 <trap_exit> is MTL basically empty calories, and all the interesting work in 'transfromers' ?
23:19:26 <comerijn> trap_exit: Pretty much
23:19:47 <trap_exit> comerijn: cool, thanks; btw, are you merijn's SO ?
23:19:54 <comerijn> trap_exit: mtl just provides the automatic lifting typeclasses so you can write code that's agnostic of the underlying monad stack
23:20:09 <comerijn> No, irssi just diconnected and my name was still taken :p
23:20:30 <comerijn> oh, apparently it didn't even disconnect and I just connected twice...
23:21:01 <merijn> there we go
23:21:14 <trap_exit> btw
23:21:20 <trap_exit> any idea where the 'run' and 'exec' come from in writer / state monad ?
23:21:25 <trap_exit> I never understood the naming
23:21:39 <merijn> no clue
23:22:46 <trap_exit> I recommend a patch
23:22:53 <trap_exit> where we renamen them to the more intuitve:
23:23:00 <trap_exit> superManWriter and wonderWomanWriter
23:24:23 <joelteon> what does that mean
23:25:31 <trap_exit> it makes as much sense as runWriter and execWriter
23:25:32 <trap_exit> arbitrary names
23:37:10 <jle`> run/exec make sense if you think of the State type as a machine that takes in a state and "runs" it to get an output and a new state
23:37:21 <jle`> so runState myMachine 5 is
23:37:27 <jle`> run "myMachine" with the initial state 5
23:37:52 <jle`> runMachine myMachine 5 might make more sense, but because the type is called State, it sort of makes sense to say runState
23:38:08 <jle`> btw, it has nothing to do with the monad instance of the State type
23:38:21 <jle`> not directly at least
23:40:03 <cgag> anyone know an example of a yesod app that handles migrations beyond the ones that can be handled automatically?
23:44:32 <simpson> edwardk: Stupid parsers/trifecta question: Is there a way to ask trifecta to pretty-print a (successfully) parsed input, with colors and all?
23:45:06 <edwardk> simpson: there used to be, i don't think we ever fully re-attached all the parts when 1.0 shipped
23:45:23 <edwardk> simpson: i'd take patches that made it all work again
23:45:51 <simpson> edwardk: I see that there's a String -> HighlightedRope -> HighlightedDoc function; I'll see if I can make something work.
23:53:22 <grohne> is there a simple way to make quickcheck print all discarded tests?
23:55:00 <grohne> ahh. verboseCheck will just do for my use case.
