00:09:05 * hackagebot persistent-mongoDB 1.4.4.4 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-1.4.4.4 (GregWeber)
00:09:05 * hackagebot prove-everywhere-server 0.1.1 - The server for ProveEverywhere  http://hackage.haskell.org/package/prove-everywhere-server-0.1.1 (ShoheiYasutake)
00:10:43 <wz1000> Doesn't the universe have to be deterministic for the IO monad to exist?
00:11:58 <felixn> wz1000: wat
00:12:16 <felixn> wz1000: what time is it there?
00:12:57 <ChristianS> wz1000: isn't the whole point of IO that it's potentially indeterministic? only pure code is fully deterministic.
00:17:22 <catsup> i am trying to compile package 'flickr' from hackage, which was last updated in 2009, using ghc 7.8.  there are a bunch of compile errors (well, two, but repeated), can anyone shed light on what is going on here?  http://lpaste.net/110975
00:20:22 <felixn> catsup: might be easier to make http requests directly to flickr api ... it may even have changed since 2009
00:21:47 <Jookia> did i just experience a netsplit
00:24:19 <catsup> yeah it might be
00:25:05 <catsup> nevertheless i suspect there's a simple solution here that i just don't know
00:26:20 <felixn> catsup: https://github.com/jpg0/flickr/commits/master
00:26:53 <catsup> oh nice
00:26:58 <felixn> :D
00:41:18 <jle`> wz1000: does the universe have to be deterministic for a (Maybe a) to exist?
00:42:56 <catsup> the cat is neither Just nor Nothing until you open the box
00:43:10 <felixn> I thought it was both
00:43:51 <felixn> or maybe it was both neither, and both
00:44:00 <catsup> oh i think it is both
00:44:34 <hamid> if it is both then it's neither too :P
00:44:53 <catsup> either way though, Maybe semantics are surely violated
00:45:59 <haasn> Either Cat (Cat -> Void)
00:46:04 <felixn> is it also both catsup and ketchup?
00:47:04 <haasn> wz1000: The IO monad doesn't give you control over the universe, nor does it claim to - but it gives you a way to talk about actions in the real world
00:47:20 <haasn> In fact, the IO monad includes nondeterministic elements
00:48:02 <haasn> Some actions have completely unpredictable results when executed
00:48:15 <haasn> like randomIO
00:48:49 <joelteon> well, not COMPLETELY unpredictable
00:49:37 <jle`> ;)
00:49:50 <haasn> openFile "/dev/hardware-random-number-generator-based-on-atom-decay-or-whatever"
00:50:02 <felixn> joelteon: I just ran randomIO, what's the output?
00:50:08 <joelteon> felixn: 4
00:50:11 <felixn> damn
00:50:12 <haasn> x <- readBool; if x then destroyUniverse else return ()
00:50:12 <Jookia> haasn: RTL SDR
00:50:33 <felixn> it did start with a 4
00:50:37 <wz1000> Well, I thought that IO is thought of having a haskell representation that is abstracted away, so you can reason about it in haskell code.
00:51:00 <joelteon> well Haskell is a DSL for producing programs that interact with the outside world
00:51:06 <haasn> wz1000: It's a haskell representation of actions haskell programs can execute
00:51:16 <haasn> Like writing a string to the console
00:52:33 <wz1000> Can't IO a be though of as (RealWorld -> (a, RealWorld)), where RealWorld has some haskell representation.
00:52:53 <jle`> wz1000: hm. not meaningfully.
00:53:26 <haasn> The GHC representation is misleading
00:53:36 <shachaf> wz1000: I recommend reading the logs of this channel about an hour ago.
00:53:47 <shachaf> There was a long discussion on that topic and why it doesn't work.
00:54:04 * hackagebot influxdb 0.7.0 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-0.7.0 (MitsutoshiAoe)
00:54:21 <haasn> wz1000: If you subscribe to that representation, you subscribe to the idea that Haskell programs could freely rewind and reset the state of the universe after performing actions that had undesirable outcomes
00:55:51 <wz1000> haasn: Yes they could conceptually, but that functionality has been abstracted out of real world, just like you can create a monad that can only write to files, and not just perform any arbitary IO action.
00:56:02 <jle`> s/monad/type
00:56:30 <haasn> I prefer something like Action = (Effect, Result -> Action)
01:04:05 * hackagebot boundingboxes 0.2.2 - A generic boundingbox for an arbitrary vector  http://hackage.haskell.org/package/boundingboxes-0.2.2 (FumiakiKinoshita)
01:14:07 * hackagebot bytes 0.14.1.1 - Sharing code for serialization between binary and cereal  http://hackage.haskell.org/package/bytes-0.14.1.1 (EdwardKmett)
01:14:09 * hackagebot parsers 0.12.1.1 - Parsing combinators  http://hackage.haskell.org/package/parsers-0.12.1.1 (EdwardKmett)
01:14:13 <wz1000> I find it easier to construct pipelines in terms of flip ($) and flip (.). Why is does (>>=) follow this format, but not most other widely used functions like these?
01:14:55 <shachaf> "f $ x" looks like "f x"
01:15:15 <shachaf> It's an old tradition, putting functions before things they're applied to.
01:17:04 <wz1000> But why isn't there something like (-:) = flip ($) defined in the standard libraries, while there is (=<<) = flip (>>=)
01:19:07 * hackagebot wl-pprint-extras 3.5.0.2 - A free monad based on the Wadler/Leijen pretty printer  http://hackage.haskell.org/package/wl-pprint-extras-3.5.0.2 (EdwardKmett)
01:19:09 * hackagebot wl-pprint-terminfo 3.7.1.2 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-3.7.1.2 (EdwardKmett)
01:19:25 <edwardk_> wz1000: because names nice symbols are few and far between and there was an attempt to instill a culture of doing that one way. lens introduced (&) for flip ($), and its proven somewhat popular in some circles and annoying to others
01:19:46 <edwardk_> wz1000: in 7.10 you should get (&) in Data.Function
01:20:46 <wz1000> edwardk_: Ah. Does hoogle not index lens?
01:20:57 <wz1000> http://www.haskell.org/hoogle/?hoogle=%28%26%29
01:21:12 <edwardk_> wz1000: https://www.fpcomplete.com/hoogle
01:21:30 <edwardk_> wz1000: though, i did talk to ndm at icfp this year and he offered to have it support lens when he gets around to it
01:24:35 <jle`> wz1000: (>>=) is nice because, while it reverses normal function composition order, it helps visualize the order of the effects if your monad is noncommutative
01:25:10 <wz1000> edwardk_: Why is working to support a package necessary? Isn't indexing from the documentation be an automated process?
01:25:24 <jle`> x =<< y =<< z mmight be the same as z >>= y >>= x ... and it might be normal function application ... but the latter makes it more visually clear the order of effects
01:25:34 <edwardk_> wz1000: its a matter of him turning it on, more or less. hoogle has a set of packages it indexes by default
01:25:45 <jle`> also >>= seems to look nicer in with lambda syntax than =<< does
01:26:45 <wz1000> jle`: Can't the same be said for f $ g $ h $ x
01:27:05 <jle`> wz1000: i'm not sure what you are trying to say, sorry :/
01:30:05 <wz1000> jle`: Isn't 'x -: h -: g -: f' nicer than 'f $ g $ h $ x'
01:30:19 <jle`> there are no effects to reason about
01:30:28 <jle`> f $ g $ h $ x = f (g (h x))
01:30:35 <jle`> it's in the proper order of normal function evaluation
01:30:37 <jle`> er
01:30:40 <jle`> function application
01:30:49 <jle`> found in almost every language :)
01:31:42 <L8D_> What's the thing for importing a data type and all it's constructors?
01:31:49 <jle`> i would do f =<< g =<< h =<< x too.  but in Monad instance that encapsulate effects, the effects of h "precde" the effects of g and h, etc.  so this is more clearly seen in x >>= h >>= g >>= f
01:32:01 <jle`> but this isn't an issue when applying functions normally
01:33:53 <pavonia> L8D_: If the constructors are exported they should be in scope if you import the module
01:34:56 <wz1000> Also sometimes I wish for ($) with its fixity reversed, so you could use it to encode something similar to a comma seperated list of values. Eg f $: a $: b $: c => (((f $: a) $: b) $: c) => f a b c
01:34:57 <L8D_> pavonia: I have a function in main that returns IO Int and I want the exit status to be that
01:35:03 <L8D_> Should I just use exitFailure?
01:35:26 <pavonia> I think so
01:35:35 <pavonia> :t exitSuccess
01:35:36 <lambdabot> Not in scope: ‘exitSuccess’
01:35:59 <jle`> wz1000: hm. what would be a useful sitution? :)
01:36:38 <ski> wz1000 : also with `$!'
01:37:06 <ski> @src foldl'
01:37:06 <lambdabot> foldl' f a []     = a
01:37:06 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
01:37:20 <ski> the recursive case could be
01:37:24 <wz1000> jle`: '(++) $: 1:2:[] $: 1:xs' for a useless example
01:37:32 <L8D_> damnit:  exitWith: invalid argument (ExitFailure 0)
01:37:33 <jle`> ah i see :)
01:38:05 <ski>   foldl' f a (x:xs) = foldl' f $! f a x $ xs
01:38:07 <ski> instead of
01:38:18 <ski>   foldl' f a (x:xs) = (foldl' f $! f a x) xs
01:39:02 <jle`> can we get the cash money operator
01:39:04 <jle`> $$$
01:39:50 <jle`> when you use it, it should just give you cash money
01:39:55 <pavonia> L8D_: 0 indicates success, no?
01:40:02 <L8D_> pavonia: Yes...
01:40:11 <L8D_> I had an arbitrary number that I wanted to exit with
01:40:19 <pavonia> Okay, you can use exitWith ExitSuccess  then
01:40:31 <L8D_> pavonia: I wanted someone I could put in line
01:40:42 <L8D_> I instead have to do this:
01:40:44 <ski> @hoogle exitWith
01:40:44 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
01:40:47 <ski> L8D_ ^
01:40:59 <L8D_> @pl exit 0 = exitWith ExitSuccess; exit n = exitWith $ ExitFailure n
01:40:59 <lambdabot> (line 1, column 30):
01:40:59 <lambdabot> unexpected ';'
01:40:59 <lambdabot> expecting variable, "(", operator or end of input
01:41:53 <L8D_> @pl exit n = case n of 0 -> exitWith ExitSuccess; _ -> exitWith (ExitFailure n)
01:41:53 <lambdabot> (line 1, column 24):
01:41:53 <lambdabot> unexpected '>'
01:41:53 <lambdabot> expecting operator
01:42:15 <pavonia> > toEnum 0 :: ExitCode
01:42:16 <lambdabot>  Not in scope: type constructor or class ‘ExitCode’
01:42:33 <wz1000> Is there any reason for making (,) not behave like a regular constructor/operator that bypasses the naming rules?
01:42:59 <ski> @type toEnum 0 :: System.Exit.ExitCode
01:43:00 <lambdabot>     No instance for (Enum GHC.IO.Exception.ExitCode)
01:43:00 <lambdabot>       arising from a use of ‘toEnum’
01:43:00 <lambdabot>     In the expression: toEnum 0 :: GHC.IO.Exception.ExitCode
01:43:01 <wz1000> s/bypasses/happens to bypass/
01:43:16 <pavonia> It doesn't seem to have an Enum instance
01:43:32 <jle`> is shame
01:44:16 <ski> (which regular constructors/operators happening to bypass the naming rules did you have in mind ?)
01:46:51 <L8D_> @pl f (x:xs) -> (reverse $ take (x `div` 1) xs) ++ drop (x `div` 1) xs
01:46:51 <lambdabot> (line 1, column 12):
01:46:51 <lambdabot> unexpected '>'
01:46:51 <lambdabot> expecting operator
01:46:59 <L8D_> @pl f (x:xs) = (reverse $ take (x `div` 1) xs) ++ drop (x `div` 1) xs
01:46:59 <lambdabot> f = ap (ap (ap . (((++) . reverse) .) . take . (`div` 1)) (drop . (`div` 1)) . head) tail
01:47:06 <L8D_> lolnope
01:47:40 <jle`>  @pl should use (<*>) sometimes maybe
01:59:29 <L8D_> Are there any outstanding problems with this code: https://gist.github.com/L8D/70b724e5156363e76012
01:59:55 <L8D_> It's not very clean, but I don't think it's gotten to spaghetti
02:05:27 <ski> L8D_ : i'm not sure `fmap fst' in `maybeRead' is a good idea
02:05:52 <ski> @let maybeRead0 :: Read a => String -> Maybe a; maybeRead0 = fmap fst . listToMaybe . reads
02:05:53 <L8D_> ski: that is the exact code used in Network.CGI.Protocol.maybeRead
02:05:54 <lambdabot>  Defined.
02:06:11 <ski> > maybeRead0 "123" :: Maybe Integer
02:06:13 <lambdabot>  Just 123
02:06:14 <ski> > maybeRead0 "123abc" :: Maybe Integer
02:06:16 <lambdabot>  Just 123
02:06:25 <ski> note that the latter didn't yield `Nothing'
02:06:55 <ski> i'd define it rather as
02:08:18 <ski> @let maybeRead1 :: Read a => String -> Maybe a; maybeRead1 s = listToMaybe [a | (a,"") <- reads s]
02:08:19 <jle`> why not just use readMaybe from base
02:08:20 <lambdabot>  Defined.
02:08:22 <ski> or
02:08:34 <ski> @let maybeRead2 :: Read a => String -> Maybe a; maybeRead2 s0 = listToMaybe [a | (a,s1) <- reads s0,("","") <- lex s1]
02:08:35 <lambdabot>  Defined.
02:08:43 <ski> > maybeRead1 "123abc" :: Maybe Integer
02:08:44 <lambdabot>  Nothing
02:08:46 <ski> > maybeRead2 "123abc" :: Maybe Integer
02:08:47 <lambdabot>  Nothing
02:08:51 <ski> > maybeRead1 "123  " :: Maybe Integer
02:08:52 <lambdabot>  Nothing
02:08:53 <ski> > maybeRead2 "123  " :: Maybe Integer
02:08:55 <lambdabot>  Just 123
02:09:23 <dv-> :t Text.Read.readMaybe
02:09:24 <L8D_> okay thanks
02:09:24 <lambdabot> Read a => String -> Maybe a
02:09:31 <L8D_> dv-: that's in Text
02:15:08 <ski> L8D_ : `maybe (error $ "unknown word " ++ w) id' could be `fromMaybe (error ("unknown word " ++ w))'
02:15:32 <L8D_> I forgot why I stopped using fromMaybe...
02:15:37 <L8D_> thank you
02:18:48 <ski> L8D_ : in `roll', i'd use `splitAt'
02:19:04 <L8D_> I am?
02:19:16 <L8D_> refresh
02:21:58 <ski> how about
02:22:16 <ski>   (h, x:r) = splitAt (n-1) xs
02:22:39 <ski> yielding `x : h ++ r' ?
02:22:40 <L8D_> omg you're a genuis
02:23:42 <ski> obviously `0 roll' won't work anyway
02:24:05 <ski> also, `1 roll' won't work on empty stack, not sure whether that matters
02:24:30 <L8D_> ski: You're off by an index
02:25:01 <ski> oh, right. i didn't notice the `+ 1' above
02:25:02 <L8D_> let n = (x `div'`); (h, x:r) = splitAt
02:25:10 <L8D_> (n - 1) xs in x:h ++ r
02:25:19 <L8D_> works appropriately to the spec
02:26:43 * ski personally cringes a bit with mixing `words' with `reads' like that ..
02:26:56 <L8D_> I forgot about those...
02:27:27 <L8D_> wait what?
02:27:46 <L8D_> I'm only using the words function once
02:27:51 <ski> because the point of `reads' is to be able to continue parsing, but you don't use this functionality, instead using `words' to split the input into chunks
02:28:09 <L8D_> I'm splitting by whitespace
02:28:10 <ski> not that it really matters much here ..
02:28:27 <ski> L8D_ : as would a repeated use by `reads' do
02:28:39 <L8D_> ok.
02:29:15 <L8D_> It still properly works lazily, which is the only really importentant thing about the code
02:29:35 <L8D_> I cant' sllep
02:30:19 <ski> > [[a,b,c] :: [Integer] | (a,s0) <- reads "12 345 6789",(b,s1) <- reads s0,(c,s2) <- reads s1,("","") <- lex s2]
02:30:20 <lambdabot>  [[12,345,6789]]
02:31:16 <Twey> L8D_: Text.Read is in base
02:32:20 <ski> > (`evalStateT` "12 345 6789") $ do ns <- many (StateT (reads :: ReadS Integer)); "" <- StateT lex; return ns
02:32:21 <lambdabot>  [[12,345,6789]]
02:33:41 <Twey> :t many
02:33:42 <lambdabot> Alternative f => f a -> f [a]
02:33:45 <edlinde> whats “weak head normal form”?
02:33:50 <Twey> :t lex
02:33:51 <lambdabot> ReadS String
02:34:18 <edlinde> its saying evaluates its argument only as far as the first constructor, and doesn’t evaluate any more of the structure.
02:34:21 <sokras> hello
02:34:27 <edlinde> not sure I get the meaning of that
02:34:31 <ski> lo sokras
02:34:39 <sokras> I have a small question to ask :)
02:35:03 <Twey> edlinde: That's right.  A value in WHNF is a value whose outermost constructor can be known without performing any further evaluation.
02:35:14 <sokras> I am currently learning about state monads and I am trying to emulate a Stack
02:35:29 <sokras> I have this function:
02:35:29 <sokras>     stackManip :: State Stack Int
02:35:30 <sokras>     stackManip = do
02:35:30 <sokras>         push 3
02:35:30 <sokras>         pop
02:35:30 <sokras>         pop
02:35:40 <ski> edlinde : evaluating `(0:1:2:[]) ++ (3:4:[])' (only) to WHNF, we get `0:((1:2:[]) ++ (3:4:[]))'
02:35:52 <sokras> and when I run it in the ghci it says:
02:35:57 <sokras> ot in scope: data constructor `State'
02:35:57 <sokras>     Perhaps you meant `StateT' (imported from Control.Monad.State)
02:35:59 <Twey> sokras: You might want to consider using lpaste.net
02:36:07 <sokras> I have inmported that module
02:36:16 <sokras> oh
02:36:23 <edlinde> ski: so we just do the leftmost part
02:36:27 <MP2E> sokras: Why State Stack? Why not just State?
02:36:28 <edlinde> and leave the rest alone?
02:36:36 <edlinde> ah to say the head
02:36:38 <sokras> that's what the book says
02:36:39 <ski> sokras : you used a *data* constructor `State' somewhere else in your code. that one is no longer available. use `state' instead
02:36:44 <MP2E> ah okay
02:36:48 <sokras> ok
02:37:01 <ski> edlinde : s/leftmost/outermost/
02:37:07 <edlinde> ok
02:37:24 <ski> edlinde : until we get a data constructor (or a lambda) outermost
02:37:32 <Twey> sokras: Hm, it should be fine.
02:37:56 <Twey> Oh, yes.
02:38:17 <sokras> Twey: why did this work?
02:38:18 <Twey> MP2E: State is parameterized by the type of the state
02:38:41 <Twey> sokras: The code you pasted is fine, but you've used ‘State’ in an *expression* context elsewhere, as ski says
02:39:20 <Twey> sokras: There's a type constructor (synonym) called ‘State’, but there is no data constructor called ‘State’ — only a function called ‘state’
02:39:21 <ski> (this is one reason why i'm not fond of naming the data constructor the same as the type constructor)
02:39:58 <ski> sokras : previously there was a data constructor named `State' as well. but there's no longer any such exported/known
02:40:06 <mjrosenb> ski: wait, you're telling me that types and data are *different*?
02:40:27 <Twey> ↑ that's why I'm against naming types and data the same thing ;)
02:40:29 <ski> sokras : which is probably why whichever book you're using said to use a data constructor `State'
02:40:32 <ski> mjrosenb :)
02:40:40 <sokras> http://learnyouahaskell.com/for-a-few-monads-more
02:40:41 <sokras> :P
02:41:06 <sokras> that's the book
02:41:53 <Twey> sokras: pop = State $ \(x:xs) -> (x,xs) — e.g. should be: pop = state $ \(x:xs) -> (x,xs)
02:42:12 <Twey> I wonder what happened to BONUS
02:42:39 <ski> preflex: xseen BONUS
02:46:40 <Twey> 2012-08-26 16:31:37 +0200 <preflex> BONUS was last seen on #haskell 1 year, 118 days, 21 hours, 3 minutes and 40 seconds ago, saying: yeah i think that's better as well
02:47:07 <Twey> Hope he just moved onto better things on the back of his newfound Haskell-elephant fame
03:38:00 <benzrf> dang
03:38:30 <benzrf> prefle?
03:39:22 * hackagebot microformats2-types 0.2.0 - Microformats 2 types for Haskell.  http://hackage.haskell.org/package/microformats2-types-0.2.0 (myfreeweb)
03:46:09 <ski> benzrf ?
03:49:23 * hackagebot monad-journal 0.4 - Pure logger typeclass and monad transformer  http://hackage.haskell.org/package/monad-journal-0.4 (DimitriSabadie)
03:49:25 * hackagebot process-streaming 0.5.0.1 - Streaming interface to system processes.  http://hackage.haskell.org/package/process-streaming-0.5.0.1 (DanielDiazCarrete)
03:55:48 <bluebelle> what is the fastest immutable hash tables in Haskell? O(1) preffered.
03:56:44 <benzrf> ski: whats preflex
04:05:36 <ChristianS> bluebelle: the unordered-containers package is very popular, don't know if there are faster options
04:17:16 <bluebelle> ChristianS : I used that, and it's a lot faster than the hashtables library (for persistent data)
04:34:27 * hackagebot process-streaming 0.5.0.2 - Streaming interface to system processes.  http://hackage.haskell.org/package/process-streaming-0.5.0.2 (DanielDiazCarrete)
04:42:01 <ski> benzrf : a bot which kept track of "seen" nicks
04:42:26 <ski> @quote preflex
04:42:26 <lambdabot> preflex says: god was last seen on ##c++ 96 days, 6 hours, 19 minutes and 16 seconds ago, saying: I don't really know either actually
04:42:48 <ski> (currently i forget who ran it)
05:00:14 <spacekitteh> hi friends. i'm writing a blog post about edwardkmett's library Hask and was wondering if someone can look over the post so far to see if i'm on the right track? o
05:09:30 * hackagebot gloss 1.8.2.2 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.8.2.2 (BenLippmeier)
05:17:19 <ski> spacekitteh : well, you could perhaps ask edwardk_ ..
05:19:40 <spacekitteh> ski: yeah but he's asleep or something
05:23:29 <cacplate> Hi, I'm trying to find a built-in function or a syntax that let's me define a list but instead of specifying the steps, lets me define the number of values inside the given range
05:24:32 * hackagebot hpc-coveralls 0.6.1 - Coveralls.io support for Haskell.  http://hackage.haskell.org/package/hpc-coveralls-0.6.1 (killy971)
05:25:34 <cacplate> I've already wrote the function but I want to find something built-in. something like [0..100?27] would input a list from 0 to 100 that has 27 values (the ? is just an example)
05:25:57 <spacekitteh> how are the values to be chosen though, cacplate?
05:27:02 <cacplate> they have equal steps, calculated on the fly by the function
05:27:17 <latro`a> I don't think haskell has a "linspace" builtin
05:27:36 <cacplate> like if I want a list from 0 to 100 with 100 values et will find out I need a step of 1 between each
05:28:08 <spacekitteh> the engineer in me prefers logspace over linspace :v
05:28:40 <latro`a> somewhat annoyingly, you have to do this differently depending on whether you have Integral or Fractional
05:28:48 <cacplate> what is logspace? spacekitteh
05:29:01 <latro`a> presumably the logarithms of the values are uniformly spaced
05:29:06 <spacekitteh> ^
05:29:18 <mjrosenb> spacekitteh: the engineer in me has no problem with linspace.
05:29:31 <spacekitteh> mjrosenb: EE?
05:29:37 <mjrosenb> spacekitteh: CE.
05:30:09 <cacplate> but even if there is two implementations, the behavior stays the same I think, latro`a
05:30:15 <spacekitteh> ah. i'm more into rf analysis and such where we cover 2 or 3 orders of magnitude
05:30:36 <mjrosenb> spacekitteh: you must have had fun with bode diagrams
05:30:46 <spacekitteh> NO NO NO NO NO NO NO NO
05:31:04 <latro`a> linspace a b n = let d = (b-a)/(n-1) in [a,a+d..b] should do the job (after a check that n>1)
05:31:35 <latro`a> maybe, my haskell's rusty
05:32:22 <spacekitteh> that should be god latro`a
05:32:24 <spacekitteh> good
05:32:50 <cacplate> latro`a: pretty much the same implementation I came with myself, but thanks. However I think I got my answer which is that there is no built-in feature (it would be nice to have it though)
05:44:18 <arianvp> how do I send an EOF to the terminal in GHCI?
05:44:29 <geekosaur> "send an EOF"?
05:44:53 <arianvp> yeh say I have    > interact (lines . doStuff . unlines)
05:44:58 <geekosaur> EOF is not a character. there are characters that on input will trigger an EOF condition, in line mode
05:45:01 <arianvp> it will keep waiting for user input
05:45:04 <mjrosenb> arianvp: ^D
05:45:27 <arianvp> ^D didnt work :/
05:45:33 <geekosaur> what platform?
05:45:47 <arianvp> ubuntu
05:46:43 <geekosaur> so it should be control-D at the beginning of a line, unless your terminal is set oddly
05:48:02 <mjrosenb> geekosaur: or just ^D^D
05:56:08 <Twey> SwashBuckla: Just found this in my Haskell buffer; were you asking about it?  http://lpaste.net/1878814764822429696
06:08:16 <Roselyn22>  You can find funny videos here. http://tinyurl.com/ozfvxy3
06:22:01 <epta> it appears I can't
06:27:09 <Nick_____> Hi, does any one know how to make tab and arrow keys work in EclipseFP's console repl? Thanks!
06:44:50 <pertl> I am trying to get a grasp on the State monad work through LYAHFGG . I can't figure out how to define the Applicative for my State monad. can someone help?   http://lpaste.net/110981
06:46:09 <osfameron> FGG?
06:46:22 <osfameron> ah yes, duh
06:49:53 <ski>   State f <*> State t1 = ..f..t1..
06:50:25 <ski> pertl : what is the type of `(<*>)' in general ?
06:50:28 <ski> pertl : what is the type of `(<*>)' in your particular `State' case ?
06:50:54 <ski> pertl : what is then the types of `f' and `t1' in the definition sketch above ?
06:51:16 <michi7x7> :t Control.Applicative.(<$>)
06:51:16 <lambdabot>     Not in scope: data constructor ‘Control.Applicative’
06:51:51 <kvanb> :t (<$>)
06:51:52 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:51:54 <pertl> it's obvious the types do not match ... however I wonder what <*> should look like
06:52:03 <kvanb> :t (<*>)
06:52:04 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
06:52:23 <pertl> "f = State s" in my case
06:52:50 <ski> pertl : so what in particular are the types of `f' and `t1', then ?
06:53:01 <lpaste_> blueonyx pasted “is not in the type environment at a reify” at http://lpaste.net/110982
06:53:23 <pertl> t1    =   s -> (a,s) ?
06:53:27 <blueonyx> hi
06:54:08 <pertl> f       =    a  -> b   ?
06:54:21 <ski> no
06:54:25 <hexagoxel> t1 correct, f wrong
06:54:30 <pertl> :-)
06:54:34 <pertl> on mo' try
06:54:41 <ski> also, you should use `::', not `='
06:54:45 <pertl> k
06:55:20 <ski> i think it would be easier to take it in smaller steps, starting from the explicit type signature for `(<*>)' ..
06:55:31 <ski> .. but perhaps you prefer making bigger jumps
06:55:47 <pertl> of course :-)
06:55:57 <ski> (and you still haven't stated that type signature)
06:56:18 <pertl> I am still processing ... 10 % ... 20 % ...
06:56:28 <joelteon>  zzzzzzzzzzzzzzzzzzzzzzzzzzzzz_________________________
06:56:38 <ski> let me help you
06:56:49 <pertl> my name is not touring or dyjkstra so excuse please
06:57:04 <ski> here's the explicit type signature for `(<*>)', specialized to your particular `State s' case :
06:57:28 <ski>   (<*>) :: State s (a -> b) -> State s a -> State s b
06:58:10 <joelteon> _++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
06:58:14 <joelteon> +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
06:58:15 <joelteon> +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
06:58:17 <joelteon> +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
06:58:19 <joelteon> +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
06:58:21 <joelteon> +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
06:58:23 <joelteon> +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
06:58:25 <joelteon> +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
06:58:27 <epta> nice
06:58:27 <joelteon> +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
06:58:29 <joelteon> +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
06:58:31 <joelteon> +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
06:58:32 <pertl> geez
06:58:33 <joelteon> +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
06:58:35 <joelteon> +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
06:58:37 <joelteon> +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
06:58:37 --- mode: ChanServ set +q *!*@unaffiliated/otters
06:59:42 --- mode: ChanServ set -q *!*@unaffiliated/otters
06:59:56 <blueonyx> http://lpaste.net/110982 worked in ghc 7.6, how to change it for 7.8.3?
07:00:45 <ski> repeating, due to noise :
07:00:49 <ski>   (<*>) :: State s (a -> b) -> State s a -> State s b
07:00:51 <pertl> I read it
07:00:55 <ski> looking at this, we can see that the first two arguments of `(<*>)' will have types `State s (a -> b)' and `State s a', and also that the return type is supposed to be `State s b'
07:00:55 <pertl> so    f :: s -> (a->b)
07:01:02 <ski> pertl : i hope you agree
07:01:27 <ski> so, looking at the candidate template definition
07:01:29 <ski>   State f <*> State t1 = ..f..t1..
07:01:33 <ski> we can thus deduce :
07:01:43 <ski>   State f :: State s (a -> b)
07:01:55 <ski>   State t1 :: State s a
07:02:00 <ski>   ..f..t1.. :: State s b
07:02:10 <ski> further, knowing that
07:02:20 <ski>   State :: (s -> (a,s)) -> State s a
07:02:26 <pertl>     (State f) <*> (State t1) = State $ \s -> (f s,s)  ??
07:02:35 <ski> the only possibly typings for `f' and `t1' are
07:02:48 <ski>   f :: s -> (a -> b,s)
07:02:53 <ski>   t1 :: s -> (a,s)
07:03:03 <ski> pertl : ok ?
07:03:44 * ski is attempting to rein in pertl ..
07:04:24 <pertl> too bad, my wife wants to leave with the kid so I gotta join them ... thanks a lot ski I will later try to digest all this .... thanks a lot again for you time :-)
07:04:33 <ski> ok, np
07:04:36 <ski> good luck
07:04:40 <pertl> :-)
07:04:43 <pertl> thanks!!!
07:08:26 <blueonyx> http://lpaste.net/110982 worked in ghc 7.6, how to change it for 7.8.3?
07:16:17 <dreams> What is the reason maximum [1..10000000] runs without exceptions when compiled but in GHCi it raises a stack overflow exception?
07:16:50 <bennofs> dreams: GHC doesn't optimize code
07:16:57 <bennofs> dreams: s/GHC/GHCi
07:17:11 <petrus> Is it possible to enter multi-line input into ihaskell console?
07:17:22 <dreams> bennofs: I see, how do I run GHC without optimizations?
07:17:29 <bennofs> dreams: GHC -O0
07:17:34 <dreams> bennofs: thanks.
07:18:48 <dreams> bennofs: it ran without exceptions again with -O0.
07:29:43 * hackagebot unexceptionalio 0.2.0 - IO without any non-error, synchronous exceptions  http://hackage.haskell.org/package/unexceptionalio-0.2.0 (StephenWeber)
07:48:58 <SwashBuckla> Twey: yes
07:49:44 <SwashBuckla> Twey: I was asking about http://lpaste.net/1878814764822429696
07:50:04 <SwashBuckla> although more specifically the LYAH newtype Prob
07:50:35 <SwashBuckla> and how to define an instance Monoid Prob so that it joins False probabilities
07:52:51 <phaazon> hm
07:52:58 <phaazon> aeson has weird error messages sometimes :D
07:52:59 <phaazon> > eitherDecode "4 : [1,3,0]" :: Either String [Int]
07:52:59 <phaazon> Left "Failed reading: satisfy"
07:53:00 <lambdabot>  Not in scope: ‘eitherDecode’
07:53:56 <ski> @hoogle satisfy
07:53:56 <lambdabot> Text.ParserCombinators.ReadP satisfy :: (Char -> Bool) -> ReadP Char
07:53:56 <lambdabot> Text.Parsec.Char satisfy :: Stream s m Char => (Char -> Bool) -> ParsecT s u m Char
07:53:56 <lambdabot> Text.ParserCombinators.Parsec.Char satisfy :: Stream s m Char => (Char -> Bool) -> ParsecT s u m Char
07:54:15 <phaazon> yeah, aeson is implemented with attoparsec
07:57:22 <ski> it probably has a similar `satisfy' operation
08:04:15 <XniX23> is it possible to do in ghci something like this: let data Bool = True | False ?
08:05:11 <benmachine> XniX23: with sufficiently recent GHCi you can do it without the let
08:06:04 <phaazon> hm
08:06:10 <phaazon> how do I turn a Scientific into Int?
08:06:14 <XniX23> i have 7.8.3 and its not in scope
08:06:35 <phaazon> toIntegral?
08:07:12 <phaazon> toIntegral (Scientific c e) = fromInteger c * magnitude e
08:07:15 <phaazon> I guess it’s that.
08:18:40 <meretrix> Is there a canonical location for storing state files for a Haskell application?
08:25:02 <srhb> meretrix: You should probably follow OS standards, I guess.
08:26:01 <doismellburning> meretrix: what sort of application?
08:27:33 <Odda> hi, how do i get ServerEvent out of t0 (Data.Conduit.Internal.ConduitM i0 ServerEvent (t1 IO)) a2
08:28:28 <Odda> trying to update a project that uses an older version of wai
08:28:49 <dmj`> meretrix: there's a getTemporaryDirectory method in the directory pkg
08:29:09 <Odda> the example uses among other things, sourceToSource, which is deprecated by the looks of it
08:34:01 <dbp> does anyone know if there is a way to have shake pass on signals (in particular, SIGINT), to processes run with cmd? Or is it supposed to already?
08:35:17 <dbp> right now if I ctrl-C, shake quits, but the process that it was running is still going...
08:48:14 <octopuscabbage> is there a ghci command to load a program and then run the mai
08:48:25 <octopuscabbage> so currently i call ghci test.hs
08:48:28 <octopuscabbage> and then :main
08:48:29 <SrPx> Hello, is there any list of systems based on the same idea of SKI calculus? I want to know the options available, their differences and characteristics. I only know of SKI and Yota.
08:49:20 <jacko> .
08:53:18 <LnL> Is there function that behaves like exec?
08:54:00 <coppro> LnL: System.system
08:54:11 <coppro> System.Process for anything more complicated
08:56:50 <LnL> coppro: That does not replace the haskell process
08:57:30 <LnL> I'd like to execute a command by replacing the current process
08:59:30 <geekosaur> System.Process.Posix.executeFile
08:59:38 <geekosaur> note that windows does not have exec functionality
09:00:41 <geekosaur> (I do not mean "haskell on windows", I mean "windows". some languages fake it by spawning a new process and suspending the original until the new one exits, then exiting the original.)
09:02:21 <phaazon> god…
09:02:23 <phaazon> aeson…
09:02:25 <phaazon> <3
09:05:34 <LnL> geekosaur: That's it, not sure what you mean by the windows part tho
09:06:06 <geekosaur> windows has spawn. it has neither fork nor exec natively; both must be simulated in various ways.
09:07:09 <LnL> geekosaur: Oh yeah I knew that, the "not haskell on windows" was a little confusing
09:07:44 <geekosaur> every so often we get someone who claims that language X can do Y on Windows, therefore it's a Haskell limitation
09:08:10 <geekosaur> when the reality is that language X is doing something disgusting that almost but not quite emulates Y. (this is where perl5's ithreads comes from, for example)
09:08:22 <geekosaur> (specifically it'a how perl emulates fork on windows)
09:29:55 * hackagebot twitter-conduit 0.0.6 - Twitter API package with conduit interface and Streaming API support.  http://hackage.haskell.org/package/twitter-conduit-0.0.6 (TakahiroHimura)
09:32:49 <phaazon> bloody hell
09:32:55 <phaazon> that error drives me crazy
09:33:21 <phaazon> do you think it’s sane to use fromString to perform String -> Text?
09:34:07 <benzrf> :t fromString
09:34:08 <lambdabot>     Not in scope: ‘fromString’
09:34:08 <lambdabot>     Perhaps you meant one of these:
09:34:08 <lambdabot>       ‘BSLC.fromStrict’ (imported from Data.ByteString.Lazy.Char8),
09:34:19 <phaazon> :t Data.String.fromString
09:34:20 <lambdabot> Data.String.IsString a => String -> a
09:34:47 <phaazon> IsString is what you implement to use the OverloadedStrings extension
09:34:48 <phaazon> hm
09:34:52 <phaazon> I guess that answers my question
09:34:54 <phaazon> :D
09:35:01 <phaazon> nevermind then
09:53:46 <dmj`> markin_: you there?
09:54:58 <dmj`> markin_: when desiging an the Card API, do you think its ok to call customer cards just "Card" and recipient cards "RecipientCard". Since I'm assuming people use Cards and Customers way more than recipients... Or do you think I should name the classes CustomerCard and RecipientCard respectively
09:55:02 <dmj`> the*
09:59:19 <dmj`> markin_: where did you go
09:59:22 <phaazon> is there a way to fail with an error with aeson?
09:59:36 <dmj`> oh gosh wrong channel
09:59:43 <phaazon> (I don’t want modifyFailure, I want some kind of mzero on steoroids, like <?> from parsec)
09:59:50 <phaazon> -o
10:00:19 <XniX23> (>>=) :: m a -> (a -> m b) -> m b; could m a be a structure and in this case the (a -> m b) would be a mapping function and the result would be m b? does that make it a functor?
10:01:33 <XniX23> nevermind, i forgot lists are monads, so yes
10:01:43 <dfarm> Hey all, quick cabal + emacs question. I'm trying to get M-x compile to work in my cabal sandboxed project but it's not aware of the sandbox. Any quick way to get this working?
10:03:14 <dmj`> dfarm: when you invoke emacs, do so by using cabal exec emacs. This should update your package db
10:04:06 <dmj`> @src liftM
10:04:06 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
10:04:24 <dfarm> dmj`: Ok, a little hacky but definitely seems like the easiest way. Thanks ;)
10:05:03 <dmj`> XniX23: all monads are functors since you can define fmap in terms of (>>=) and return
10:05:50 <dmj`> @typ \f m >>= \x -> return (f x)
10:05:51 <lambdabot> parse error on input ‘>>=’
10:06:04 <dmj`> @typ \f m -> m >>= \x -> return (f x)
10:06:05 <lambdabot> Monad m => (a -> b) -> m a -> m b
10:14:54 <wz1000> How does forkIO work with lazy evaluation?
10:15:33 <msafi> Anyone know how to setup Atom Editor so that I can write code, compile it and see the output?
10:18:10 <XniX23> dmj`, so >>= only extracts the value and on the right side must have a function that will do something with it and wrap it in a monad?
10:18:59 <wz1000> For example, if I have the code 'main = do forkIO $ forever $ putStrLn "Foo"; forever $ putStrLn "Bar"', under lazy semantics why would "Foo" ever be printed?
10:20:23 <exio4> because IO isn't lazy
10:20:38 <phaazon> hey seriously, there’s nothing else than “modifyFailure (const "dammit") mzero” for error handling in aeson?
10:21:06 <phaazon> ah, typeMismatch
10:21:19 <bennofs> phaazon: fail
10:21:37 <phaazon> bennofs: I’ve been always told not to use fail
10:21:41 <bennofs> phaazon: at least I think aeson overloads Monad's fail
10:22:05 <phaazon> if not, it generates some kind of exception?
10:22:13 <bennofs> phaazon: yes
10:22:30 <phaazon> dah
10:22:40 <phaazon> I guess it’s a default implementation in monad
10:22:42 <phaazon> Monad
10:22:43 <phaazon> like
10:22:46 <phaazon> fail = error
10:22:50 <amf> is there a term / implementation for doing [a] -> [a'] where length a' <= length a; kinda like a monoid but the end result is a list
10:23:52 <phaazon> thank you bennofs
10:23:56 <phaazon> https://hackage.haskell.org/package/attoparsec-0.12.1.0/docs/src/Data-Attoparsec-Internal-Types.html#Parser
10:24:01 <phaazon> it’s indeed overloaded
10:24:09 <phaazon> I hate default implementation…
10:25:02 <dmj`> XniX23: yes, the monadic context you're operating in can't change, but the type and value of what is inside can change.
10:26:12 <msafi> Oh the Mac installation guide it says Haskell will be installed at ~/Library/Haskell, but in fact, it installs it in the root, like /Library/Haskell
10:26:33 <msafi> The installer doesn't actually give user-specific install as an option
10:28:16 <dmj`> msafi: I'd recommend downloading ghc yourself, and storing it in /usr/local/bin/ghc
10:29:11 <msafi> dmj`: It says not to do that on their homepage
10:29:14 <msafi> dmj`: http://www.haskell.org/ghc/download_ghc_7_8_3
10:29:57 <msafi> It says "Stop!"!!!!
10:31:50 <msafi> Setting up a proper environment is the hardest part of programming…
10:32:07 <msafi> Which is sad.
10:32:17 <dmj`> It doesn't say not to, it says for "most users" use the haskell platform.
10:33:54 <kmos> !list
10:33:54 <monochrom> kmos: http://lpaste.net/browse
10:34:27 <wz1000> exio4: Huh, I've always read that it was lazy. Wasn't lazy IO supposed to be one of the major shortcomings of Haskell?
10:35:17 * hackagebot foldl 1.0.7 - Composable, streaming, and efficient left folds  http://hackage.haskell.org/package/foldl-1.0.7 (GabrielGonzalez)
10:36:19 <exio4> wz1000, do you mean "getContents"-like functions?
10:36:19 <geekosaur> msafi: ~/Library/Haskell is where user packages get installed
10:36:19 <dmj`> wz1000: yea, but left fold enumerators were invented to combat this short coming
10:36:33 <dmj`> wz1000: http://okmij.org/ftp/Streams.html
10:37:09 <geekosaur> wz1000: dumb lazy I/O like provided by the Prelude is problematic. smart lazy I/O is more complicated to use but fixes the shortcomings
10:37:40 <msafi> geekosaur: I don't have ghc at ~/Library/Haskell/bin after installing the Platform
10:37:50 <geekosaur> yes, ghc is not a user package
10:37:58 <geekosaur> something installed with "cabal install" is a user package
10:38:08 <geekosaur> ghc itself can't (yet?) be installed that way
10:38:34 <geekosaur> global packages are at /Library/Haskell, user packages are ~/Library/Haskell
10:38:47 <msafi> geekosaur: where does the Platform installer put GHC? I can't find it
10:38:47 <wz1000> So, is putStrLn lazy or not?
10:39:02 <msafi> This is what I have http://i.imgur.com/1M5CMiH.png
10:39:14 <geekosaur> msafi: under /Library/Haskell with a symlink in /usr/bin
10:39:27 <geekosaur> nut there are known to be some bugs especially if older ghc versions are installed
10:39:50 <msafi> geekosaur: I don't have ghc in /Library/Haskell
10:40:01 <geekosaur> not specifically in that directory somewhere under it
10:40:08 <kmos> !list
10:40:08 <monochrom> kmos: http://okmij.org/ftp
10:40:54 <geekosaur> /usr/bin/ghc should be a symlink to ghc-clang-wrapper in that directory. the actual real ghc is somewhere else, and can't be run directly because it needs setup done by that wrapper script
10:40:55 <wz1000> I still don't understand how 'main = do forkIO $ forever $ putStrLn "Foo"; forever $ putStrLn "Bar"' manages to print "Foo" and "Bar".
10:41:00 <msafi> geekosaur: the only thing that contains the letters 'ghc' there is a directory called ghc-7.8.3-x86_64
10:41:11 <msafi> geekosaur: nothing else is called ghc
10:41:12 <geekosaur> sigh
10:42:11 <geekosaur> msafi, I am sorry, I was assuming some basic filesystem understanding that you apparently do not have. I also do not have ghc or the platform installed on this machine at the moment so cannot provide you with the exact full pathnames you require
10:42:50 <geekosaur> /usr/bin/ghc should exist (if not, file a bug) and be a symlink to the file ghc-clang-wrapper shown in your screencapture
10:43:18 <geekosaur> the actual ghc binary, which may be called ghc.real or something, lives elsewhere and should not be run directly
10:43:39 <geekosaur> (you will at the very least get complaints about missing options that are provided by that script I just pointed out to you)
10:43:59 <vanila> geekosaur, why are you so rude to people?
10:44:19 <msafi> geekosaur: okay, I see it now
10:44:29 <geekosaur> vanila: considering the rudeness I see daily from you, I wonder why you ask
10:45:03 <vanila> geekosaur, what are you talking about?
10:45:18 <hexagoxel> geekosaur: why are you so rude to people?
10:45:27 <hexagoxel> i am allowed to ask, right?
10:45:28 <msafi> geekosaur: so where can I get ghc-mod, my text editor wants to know?
10:46:01 <msafi> don't be rude to people geekosaur.
10:46:10 <msafi> And help me please, lol
10:46:15 <geekosaur> ghc-mod is a package, "cabal install ghc-mod" should work. http://hackage.haskell.org/package/ghc-mod
10:46:23 <msafi> geekosaur: cool thanks
10:47:30 <dmj`> wz1000: when two threads run concurrently the RTS has a fairness policy that kicks in, so in your case they should both take turns grabbing the stdout handle.
10:47:46 <geekosaur> note that it will install to ~/Library/Haskell/bin and you'll hve to add that directory to $PATH. beware that shells can interpret ~ oddly (use $HOME instead) and that OS X makes it painfully difficult to make a modified PATH visible to the GUI as opposed to terminal windows
10:47:49 <Redz> hello
10:48:21 <dmj`> wz1000: this book is really good on the topic: http://chimera.labs.oreilly.com/books/1230000000929
10:49:05 <msafi> geekosaur: I did cabal install ghc-mod. ~/Library/Haskell/bin is still empty.
10:49:16 <Redz> which modules/packages do something like `data Term a = Add (Term a) (Term a) | Sub (Term a) (Term a) | ...` and with instances for Num, Fractional, Floating, etc. ?
10:49:30 <dmj`> msafi: check if its in ~/.cabal/bin
10:49:34 <geekosaur> hm. did you have a ~/.cabal/config already?
10:50:02 <geekosaur> that controls where things get installed, if you dont have one then cabal creates one with the default OS X paths but if you have one already then you need to check it to see where stuff will go
10:50:37 <msafi> dmj`, I don't have a ~/.cabal/bin
10:50:45 <msafi> geekosaur: yes, I have ~/.cabal/config
10:50:49 * dmj` gasps
10:50:50 <geekosaur> and just to confuse things even more, if you have one and it doesn't specify any paths, cabal will use ~/.cabal/bin (default unix path) instead of the OS X-like ~/Library/Haskell/bin
10:51:06 <XniX23> i remember getting some errors when using eclipseFP with cabal... is it fixed now?
10:51:10 <ski> @hackage simple-reflect
10:51:10 <lambdabot> http://hackage.haskell.org/package/simple-reflect
10:51:10 <geekosaur> hm
10:51:13 <ski> Redz ^ ?
10:51:30 <Redz> ski: thank you. :)
10:51:47 <geekosaur> again, I don't have ghc on this machine (yet --- new machine and I need to do some additional setup/migration before I can install Haskell) so I cant easily poke at it
10:51:48 <ski> > foldr (+) 0 [a,b,c,d]
10:51:51 <lambdabot>  can't find file: L.hs
10:51:57 <ski> > foldr (+) 0 [a,b,c,d]
10:51:59 <lambdabot>  a + (b + (c + (d + 0)))
10:52:06 <ski> Redz : like that, e.g.
10:53:13 <msafi> geekosaur: so I have .cabal/config and it says it should put things in ~/Library/Haskell http://i.imgur.com/Jf3zJa2.png
10:53:17 <msafi> but it didn't...
10:53:31 <Redz> ski: seems like the stuff i'm looking for.
10:54:15 <msafi> geekosaur: oh, sorry, my bad. cabal install ghc-mod actually failed...
10:54:36 <geekosaur> mm. I think it has executable prerequisites, which cabal doesn't support currently
10:54:44 <geekosaur> it should have told you to install dependencies manually
10:55:28 <msafi> geekosaur: it seems to be trying to install the dependencies itself, but it's getting ExistFailure
10:56:00 <msafi> For example http://i.imgur.com/NRyZRi4.png
10:56:11 <msafi> Should I run cabal installs with sudo?
10:56:28 <geekosaur> no
10:56:35 <Forkk> Is there a way to read from a Handle as an STM action? I want to wait on input from a handle and input from a TMChan at the same time.
10:56:40 <geekosaur> that will install into root's private packages, which is quite useless
10:56:47 <kmos> !list
10:56:47 <monochrom> kmos: http://lpaste.net/browse
10:56:57 <Forkk> Maybe it would be better to just spawn a background thread and have it write to the channel too or something
10:57:07 <NikolajK> what's the computational complexity of this
10:57:07 <NikolajK> http://upload.wikimedia.org/math/a/c/5/ac5fd76bbb52e1484f35ebe8c23b10a4.png
10:57:14 <geekosaur> (aside, you should copy and paste into a pastebin like http://lpaste.net, it's hard for me to copy-paste or refer to lines from your screenshots)
10:57:25 <msafi> Ok
10:57:51 <geekosaur> it looks to me like you have a record of an older mtl installed under ~/.ghc and it's confusing cabal
10:58:03 <Cale> NikolajK: really? :)
10:58:39 <NikolajK> I'v just had a marvelous "insight"
10:58:51 <coppro> oh?
10:58:56 <Cale> NikolajK: Of course, it probably depends on the evaluation mechanism you choose. Lambda terms generally have many paths to their normal forms.
10:59:08 <NikolajK> is there no most efficient one?
10:59:11 <msafi> geekosaur: what's an MTL?
10:59:20 <geekosaur> "monad transformer library"
10:59:28 <Cale> NikolajK: Well, that's usually hard to determine
10:59:37 <Cale> NikolajK: Probably undecidably hard.
10:59:40 <geekosaur> see all the complaints about "cannot satisfy mtl-..."
10:59:56 <geekosaur> it's finding references to an installed mtl version that is no longer there
10:59:59 <Cale> (because you could presumably use such a thing to determine whether terms have a normal form at all)
11:00:17 <NikolajK> "insight": if I go to Java and code up a "triangle" object, with three points, circumference method, etc. — then I use the computer to model somthing. But if I write
11:00:17 <NikolajK> type Church a = (a -> a) -> a -> a
11:00:18 <NikolajK> church :: Integer -> Church Integer
11:00:18 <NikolajK> church 0 = \f -> \x -> x
11:00:18 <NikolajK> church n = \f -> \x -> f (church (n-1) f x)
11:00:18 <NikolajK> then I'm not even modeling lambda calculus. It literally is lambda calculus :D
11:00:57 <Cale> NikolajK: Well, yeah, Haskell itself is basically a fancy lambda calculus
11:01:05 <Cale> Core is more or less System F
11:01:12 <msafi> geekosaur: here's paste of the output http://lpaste.net/110996
11:01:23 <NikolajK> the Wikipedia page actually led me to the church encoding
11:01:27 <geekosaur> cannot satisfy -package-id mtl-2.1.3.1-8bcc0591131896cfc8761a93703d4c61
11:01:34 <Redz> ski: maybe not what i'm looking for. i would like to work on the expression tree. reversing functions in expressions to solve for specific variables. a package that is close to this or does this already would be awesome. especially when its done at compile time. any other suggestions?
11:01:38 <Cale> Or at least, it was for a long time. It's something a bit fancier now in order to deal with type equality constraints generated by GADTs and other features.
11:01:54 <msafi> geekosaur: there are other packages that it's unable to find.
11:01:55 <geekosaur> so you have packages somewhere linked against that specific mtl version, and it can't find it
11:02:01 <NikolajK> what is an equality constraints
11:02:10 <msafi> geekosaur: so what do I do?
11:02:14 <geekosaur> yes, but as soon as you see one of those, you know that there are broken packages lying around and confusing things
11:02:25 <Cale> NikolajK: If you've ever seen things of the form (a ~ b) => ..., it's that
11:02:30 <geekosaur> I'm not sure what you do next, aside from "ghc-pkg check" and see what it complains about
11:02:44 <NikolajK> also, morally, why is type inference in ITT undecidable? Say I postulate it - what does wrong now in math world?
11:02:52 <Cale> NikolajK: Usually you only need to write these explicitly when you're using class associated types (type families)
11:02:54 <geekosaur> and possibly read http://www.vex.net/~trebla/haskell/sicp.xhtml for pointers
11:04:01 <Cale> NikolajK: Oh, and btw, the way I usually think about Church encoding is that given any algebraic datatype, you can represent terms built from the constructors of that type by lambdas which accept the constructors as arguments
11:04:14 <msafi> geekosaur: doing ghc-pkg check told me to refresh cache. so I did and I'm trying cabal install ghc-mod again, seems to be progressing without errors this time
11:04:28 <Cale> e.g. Instead of Succ (Succ (Succ Zero)), you have (\zero succ -> succ (succ (succ zero)))
11:04:30 <geekosaur> interesting
11:05:11 <Cale> Or instead of data Tree a = Tip | Branch a (Tree a) (Tree a); t = Branch 2 (Branch 1 Tip Tip) (Branch 3 Tip Tip)
11:05:35 <Cale> you could have t = \tip branch -> branch 2 (branch 1 tip tip) (branch 3 tip tip)
11:06:34 <NikolajK> I don't quite get it
11:07:07 <NikolajK> so you say you can map the syntactic constructs (what you get by types together with type formers) on the term level
11:07:36 <NikolajK> when I think of chuch encoding - say of the nats - then I don't even think of types or typed calculi
11:08:03 <Cale> NikolajK: Especially for the untyped lambda calculus, you can think of a lambda x as a sort of quantifier which says "suppose we had something called x"
11:08:06 <geekosaur> church encoding is in some sense how you simulate types in untyped lambda calculus, no?
11:08:18 <NikolajK> it's "irl numbers", the formal but not computerized arithmetic expressions to expressions with beta/eta-reduction
11:08:30 <Cale> So even if we don't have the data constructors we want initially, we can use lambda to suppose we did
11:08:40 <Cale> and proceed from there :)
11:08:55 <Cale> (to build whatever value from them we would have)
11:09:08 <NikolajK> Cale: here you "just" say that the untyped calculus is strong enough to emulate typed languages
11:09:14 <NikolajK> no?
11:09:32 <Cale> I'm saying something about Church encoding specifically
11:10:21 <phaazon> noooooo
11:10:29 <phaazon>     No instance for (Bounded Natural)
11:10:30 <phaazon> :(
11:10:31 <NikolajK> I don't know where one uses it (or where it has been used) except for showing lambda calculus is Turing complete
11:10:42 <NikolajK> so I don't know why one would think about how the mirror types
11:10:44 <Cale> But yeah, you're pretty much emulating the data constructors you'd otherwise get in a typed language
11:11:34 <Cale> Well, heh, one practical use I once had when lambdabot wouldn't accept data declarations from users :)
11:12:01 <Cale> If you're not allowed to make a data declaration, you can just Church encode stuff :)
11:12:20 <NikolajK> sounds very practical
11:12:32 <Cale> It would be pretty silly in a real project of course
11:12:47 <NikolajK> I think I learned programming far too late in life to be good at translating stuff like that fast
11:12:52 <Cale> Though sometimes GHC does a much better job of optimising code which uses functions in place of data
11:13:05 <NikolajK> (also October is near - boobed girls in Dirndls at Starbucks won't let me think about parametric lambda calculus (Stuttgart reporting in))
11:13:14 <platz> The chruch encoding stuff seemed really useful in things like Control.Monad.Free.Church where you don't need to inspect the data, just running it - it's faster than pattern matching on data constructors
11:13:28 <Cale> yes
11:13:59 <Cale> There isn't a terribly good reason as far as I can tell that GHC should produce better code when you hand-CPS-transform or Church encode things
11:14:03 <Cale> but it does, sometimes
11:14:25 <mlitchard> I've got a rather uninteresting math problem that is too boring for #math, anyone mind taking a look at it here?
11:14:29 <Cale> I suppose part of the reason is modularity
11:14:41 <NikolajK> so again, what does "accept the constructors as arguments" say
11:14:50 <Cale> Unless you're doing whole-program compilation, you can just randomly decide to represent some datatypes in another way
11:14:56 <NikolajK> the lamdbas act as truth function on right syntax?
11:15:45 <dmj`> mlitchard: what is it?
11:15:54 <Cale> mlitchard: Looking at your question in ##math, I don't quite understand what the goal is
11:17:06 <Cale> mlitchard: You want N = A union B, and A intersect B = {}, and that B = {a + a' : a, a' in A, a /= a'} ?
11:17:33 <msafi> geekosaur: thanks for your help. It worked :)
11:18:06 <mlitchard> Cale: The goal is showing that it's impossible to split the naturals into two sets A and B, such that the elements of B are contructed by distinct elements m+n in A. so for one case, A={1,2}. Therefore B={3}. Next step is showing there has to be a natural n, such that n>=6 in A. Stuck there.
11:18:47 <Cale> mlitchard: if A = {1,2}, then any n >= 6 is not an element of A
11:18:48 <mlitchard> Cale: I have no idea how to do that, so my goal is to get a hint.
11:19:16 <Cale> mlitchard: You can check this exhaustively: is 1 >= 6? No. Is 2 >= 6? No.
11:19:47 <mlitchard> Cale: Well I have the rest of the naturals to split up, A={1,2} is the base case, I'm to populate it, I think
11:20:15 <Cale> If A = {1,2}, then in particular, A is not equal to any other set with more elements.
11:20:24 <NikolajK> so again, why isn't type inference decidable in ITT? What would happen, mathematically, if I postulate it?
11:20:38 <mlitchard> Cale: point taken, let me think of a better way to say it
11:20:45 <Cale> NikolajK: Well, the same term typically belongs to many types.
11:21:16 <Cale> NikolajK: and not in a nice way like you get with System F, you don't have a principal type.
11:21:24 <Cale> (i.e. something most general)
11:21:39 <mlitchard> Cale: Ah I've got my notation wrong
11:21:51 <NikolajK> forall x. b(x):B(x)
11:22:02 <NikolajK> forall (x:A). b(x):B(x)
11:22:11 <NikolajK> isn't that a nice judgement, what's the problem
11:22:20 <Cale> NikolajK: hm?
11:22:39 <NikolajK> I figure it's the term family b(x) you speak of
11:22:48 <mlitchard> Cale: 1,2 E A. trying to mimic the notation that says "1 and 2 are in set A".
11:22:59 <NikolajK> the same term typically belongs to many types — example?
11:23:00 <Cale> mlitchard: {1,2} is a subset of A?
11:23:07 <Cale> mlitchard: Is 0 in N?
11:23:22 <nicoo> Cale: Yes
11:23:31 <Redz> ski: actually, i'm looking for a really simple package. i just have a simple equation. but when i put it through CAS's i get too long expressions to just copy them into my code (because too ugly). so i would like have build-in functionality that i don't need to see the (heavily redundant) ways to solve it.
11:23:38 <Cale> nicoo: I don't understand what you're answering.
11:23:53 <mlitchard> Cale: yes. And it's ambiguous if 0 is in A as the book isn't clear about what they mean by naturals. I'm supposing from context that 0 is not in A.
11:24:34 <Cale> mlitchard: Is my description of what you're trying to achieve accurate?
11:24:39 <Cale> You want N = A union B, and A intersect B = {}, and that B = {a + a' : a, a' in A, a /= a'} ?
11:25:41 <Cale> Or do you just want B subset or equal to {a + a' : a, a' in A, a /= a'}?
11:26:55 <hasnokell> Hey guys, i've been trying to make some simple progrrams for a while now.
11:27:06 <hasnokell> could you guys give me some feedback on some things?
11:27:19 <mlitchard> Cale: Yes, I believe that is correct. The book hints that showing there is a natural in A that is greater or equal to 6 and that showing this is the case is a good next step. However, maybe there's another way.
11:27:47 <hasnokell> https://gist.github.com/ThomasKluiters/1609b04c1848d0961931 i tried to make a program that chunks a list into chunks of n size
11:28:06 <Cale> The trouble is that if 0 is in A, then for any nonzero x in A, you'll have 0+x in B, so x in B, contradicting the assumption that A and B are disjoint. Then you're forced to have A = {0}, B = {1,2,3,...}, but that means 1 in B is not the sum of two elements of A.
11:28:40 <Cale> mlitchard: If instead 0 is in B, then 0 must be the sum of two elements in A, but the only sum of two natural numbers which produces 0 is 0 + 0, which means that 0 is in A, contradicting disjointness.
11:29:14 <Cale> (and moreover, it must be the sum of two distinct elements in A which is even more impossible)
11:29:58 <Cale> So we conclude that 0 cannot be in A and cannot be in B, and so it can't be in their union. But then 0 isn't in N, which is false.
11:30:31 <mlitchard> Cale: Ah, well since the book doesn't define Z, I feel free to, so I'll go with what you've suggested.
11:31:17 <Cale> mlitchard: If 0 isn't in N, I believe we can do something similar, but the problem is a bit more interesting.
11:31:28 <mlitchard> Cale: I've been approaching this as if the first element of Z is 1.
11:31:30 <stulli> hasnokell: the result of the fuction is a list of lists, but in the 'then' case you return just a list
11:31:34 <Cale> mlitchard: You mean N
11:31:39 <Cale> mlitchard: Z is usually the integers
11:31:50 <mlitchard> Cale: yes! thanks for the correction
11:31:50 <NikolajK> why are semantics such as operational or denotational semantics usefull? are they "just" a tool to prove properties of the languages being interpreted?
11:31:59 <NikolajK> I should maybe take this to blah
11:32:13 <NikolajK> then again, what is this 1,2,3 stuff here ^^
11:32:15 <Cale> NikolajK: Why is anything useful?
11:32:16 <hasnokell> yeah i know, but it only works like this.. stulli
11:32:25 <Fuuzetsu> what's a good way to output a list of strings as-is, without escaping the inner quotes &c?
11:32:26 <Cale> NikolajK: I don't understand questions like that :)
11:32:35 <mlitchard> Cale: I'm going to go with "something similar, but more interesting" as my clue I've been looking for.
11:32:37 <NikolajK> Cale: I feel you
11:32:56 <NikolajK> lets say how did people argue in the first page of papers when they were introducing denotational semantics
11:33:17 <Cale> NikolajK: You can think of formal logics as algebraic theories, and models of those theories as the examples which we study through them.
11:33:32 <Cale> NikolajK: For example, we have the algebraic theory of groups, and then many examples of groups.
11:33:59 <Cale> NikolajK: and similarly, we have the intuitionist propositional calculus, and then many examples of Cartesian closed categories.
11:34:10 <NikolajK> here people are motivated by the examples first - the theory was build afterwards
11:34:11 <mlitchard> Cale: I may catch you around after playing around with this for a little while. Thanks for helping me express the problem better. I expect I'll get a beter response in #math now.
11:34:24 <NikolajK> programming languages come before the semantics though
11:34:38 <Cale> NikolajK: Do they?
11:34:41 <NikolajK> yes
11:34:45 <Cale> NikolajK: I think they both come at once.
11:35:07 <NikolajK> okay, but you can't use the machine properly without knowing the instructions
11:35:18 <NikolajK> or at least you wouldn't know it's a universal machine if you don't know the language
11:35:19 <Cale> NikolajK: You need to be able to say what your programs actually mean to some extent
11:35:43 <NikolajK> yeah, the question is what does "mean" mean
11:36:05 <NikolajK> I can execute the lambda calculus with reduction/evauluation on paper - isn't that meaning enough?
11:36:17 <Cale> Maybe it is, sometimes.
11:36:26 <NikolajK> the denotational semantics are more than just 2=church \f…
11:36:39 <NikolajK> more than just the semantics of input and output
11:36:51 <Cale> If you want to program a computer to do things though, you might want to come up with some other meaning for the lambda terms in terms of the operations of the machine you have.
11:36:54 <NikolajK> they are semantics of large parts of the symbols which make up the language
11:37:03 <lf94> Slices in Haskell y/n?
11:37:12 <Cale> lf94: what?
11:37:18 <lf94> array[:-1]
11:37:19 <NikolajK> okay - but you don't operate in denotational semantics
11:37:33 <Cale> lf94: Uh, which array library are you using?
11:37:49 <NikolajK> slices, Cat/A, fibre bundles :P
11:38:19 <stulli> hasnokell: ah, now i see how it works. I thought you were having trouble with the code.
11:38:43 <Cale> lf94: If you're using 'vector', then see http://hackage.haskell.org/package/vector-0.10.11.0/docs/Data-Vector.html#g:6
11:39:00 <lf94> I'll use anything that supports it Cale.
11:39:22 <lf94> It's mainly to manipulate strings more easily.
11:39:24 <hasnokell> stulli i need some feedback on it
11:39:58 <Cale> lf94: Well, if you're using String, then the thing I linked is pretty irrelevant
11:40:26 <lf94> But a string is a list of chars
11:40:45 <lf94> Isn't there something that sort of resembles array[start:end] ?
11:40:47 <eacameron> I cannot for the life of me figure out how bos is linking in libmysqlclient in his mysql library. I would expect it to be in the cabal file, but alas, nothing! How is he linking it in? https://github.com/bos/mysql
11:40:51 <NikolajK> I think programming language semantics, to prove properties of your program, is much like passing to smaller ringsin modular arithmetic  (mod mapping equations from Z to Z_p, say), and showing there that certain properties (which have been preserved) are true in the simpler to understand system, conclusing they are true for the above one
11:41:25 <Cale> lf94: take (end - start) (drop start xs)
11:41:31 <geekosaur> lf94: that makes sense with arrays. lists in haskell are linked lists, not arrays
11:41:55 <lf94> Yeah I know, so what?
11:42:03 <sinelaw> is subtyping equivalent to polymorphism with typeclasses ?
11:42:05 <lf94> geekosaur why does that matter?
11:42:11 <geekosaur> so your array[start:end] is not sanely doable with linked lists, really
11:42:18 <Cale> lf94: Which operations are efficient or natural is different
11:42:19 <lf94> But it's doable
11:42:24 <lf94> So what are you talking about
11:42:29 <geekosaur> with an array you;re just picking up consecutive elements, not chasing 2*N pointers
11:42:53 <Cale> lf94: slice a b xs = take (b - a) (drop a xs)
11:43:04 <stulli> hasnokell: a Haskeller would probably use pattern matching instead of if then else.
11:43:13 <geekosaur> you can do it. it's not fundamental enough to get magic syntax like python or whatever gives you
11:43:20 <hasnokell> how would i do that?
11:43:25 <sinelaw> e.g. class A t => B t where.... then later:  x :: B t => t   also implies that x has typeclass A
11:43:47 <stulli> hasnokell: chunk [] _ = [] -- in the first case
11:43:58 <Cale> NikolajK: The analogy as I see it is that ring theory is like your programming language, and specific examples of rings are like semantics for that language.
11:44:10 <dmj`> sinelaw: I think subtyping is more related to inheritance found in OOP languages, whereas typeclasses are more related to generics
11:44:13 <geekosaur> also most of the places where haskell does have magic syntax to "make things easier" usually end up being major pain points in the long run
11:44:16 <hasnokell> i've seen alot of underscores, but what do they mean?
11:44:19 <stulli> hasnokell: chunk l n = -- stuff in the else branch
11:44:29 <dmj`> sinelaw: I could be wrong tho
11:44:44 <NikolajK> Cale: that was not the analogy I wanted to draw
11:44:48 <lf94> Cale: nice solution :)
11:45:37 <sinelaw> dmj`, but is a type system with subtyping equivalent (in some sense) to one with polymorphism and typeclasses?
11:45:46 <sinelaw> just a theoretical question
11:46:01 <Cale> lf94: Note that this is O(max(a,b-a))
11:46:44 <NikolajK> of course, ring theory and rings (and relazation, any example) mirrors programming language and it's semantics. That notion/analogy we want to keep. But what I'm saying is this: To show that some algebriac relation in ring theory holds or not, "(a+b)^n=(c-d)^m" say, we can pass to "(a+b)^n=(c-d)^m mod 7" where, if true, is still true
11:47:03 <lf94> Cale: eh, don't really care about performance. If I did I'd just use C.
11:47:23 <Cale> lf94: It's possible to get great performance out of GHC Haskell if you care about it
11:47:24 <NikolajK> if (10+2)=144 is true, then (10+2)=144 mod 2 is also. So that can be used to check - or rather check if it's not the case
11:47:37 <Cale> lf94: But yeah, if you care about performance of your strings, use Data.Text instead :)
11:47:51 <NikolajK> passing from a language to it's (so called) semantics has the same use as passing from Z to Z_2, that's my claim
11:48:02 <vanila> no
11:48:51 <vanila> programming language semantics give you the meaning of some syntax
11:49:02 <Cale> NikolajK: In a particular sense, that's not too wrong. There's always a sort of syntactic model.
11:49:32 <NikolajK> vanila: you say "meaning of some syntax"
11:49:40 <Cale> Z is initial among rings in the same way
11:49:41 <NikolajK> but I think it's rather just a translation
11:49:50 <NikolajK> the semantics aren't apples, they are another language
11:49:56 <dmj`> sinelaw: they seem related, I can't prove to you they are. They differ in that OOP inheritance seems to be based on strucutral subtyping, and ad-hoc polymorphism based on nomial subtyping. I don't think haskell records support subtyping, they can't inherit.
11:50:38 <dmj`> but I could be completely wrong about all of that
11:50:56 <vanila> apples?
11:50:57 <Cale> NikolajK: If you take the ring operations, and form a ring which "contains just the stuff that's absolutely required by them", you end up with Z.
11:51:22 <NikolajK> vanila: something in the world
11:51:37 <NikolajK> an inter processor, if you like
11:51:42 <NikolajK> intel
11:51:48 <vanila> that's not how it works
11:51:54 <NikolajK> people would say that translating lambda calculus and reductions performed there to operations of a Turing machine gives "semantics", but I think that's changing syntax
11:52:10 <Cale> NikolajK: But similarly, there will be examples of much larger rings which contain many more elements that aren't strictly required by the ring axioms, just as there will be (set-like) models of type theories in which the types have many more elements than those generated directly by the constructors.
11:52:23 <vanila> Here is an example https://github.com/SMLFamily/The-Definition-of-Standard-ML
11:52:39 <lf94> Cale: Yeah I know :)
11:53:16 <NikolajK> vanila: where is the pdf
11:53:33 <Cale> NikolajK: This is an analogy I like to use in the case of explaining why in HoTT we might think it's okay for there to be non-refl elements of identity types.
11:53:47 <vanila> ill upload it if you know a place I can put it?
11:54:08 <NikolajK> Cale: I don't understand your Ring-point
11:54:26 <NikolajK> vanila: mhm, not really
11:54:38 <vanila> its easy to build it if you have latex
11:54:38 <Cale> NikolajK: If we took the same principle which makes UIP a sensible axiom -- that there are no other constructors for the identity types, and so every element of an identity type had better be equal to refl, and applied it in the context of group theory instead
11:54:48 <NikolajK> UIP?
11:55:09 <Cale> Uniqueness of identity paths, the statement that every element of an identity type is equal to refl
11:55:28 <Cale> (sorry if this is total nonsense to you :)
11:56:03 <vanila> Cale, where does the interest in HOTT come from?
11:56:04 * hackagebot indentation 0.2.0.0 - Indentation sensitive parsing combinators for Parsec  http://hackage.haskell.org/package/indentation-0.2.0.0 (MichaelAdams)
11:56:14 <NikolajK> what's the fundamental content of Z being initial - what has it to do with "the one ring which should exist"?
11:56:21 <NikolajK> (Lord of the Rings)^TM
11:56:38 <Cale> Anyway, what we'd get then is that since there are no elements of a group which are required by the group axioms apart from the identity element, then it should be reasonable to assume that every element of a group is equal to the identity element. But this kills off all the interesting models!
11:57:04 <msafi> I'm trying to get my IDE to compile and output the results of Haskell files so that I can experiment and learn interactively, but I'm running into problems…Is there an IDE that works like that with Haskell?
11:57:09 <XniX23> stupid question... is there a reason why readMay isn't called readMaybe?
11:58:33 <NikolajK> Cale: I'm not saying I don't like semantics for a theory - my problem is a) with the destinction between semantic truth and provability and b) to see why people like programming semantics (which are different from possible real world computers)
11:59:01 <jle`> XniX23: where is readMay?
11:59:09 <jle`> hm
11:59:15 <jle`> maybe because there is already a readMaybe defined in base?
11:59:19 <Marquis> hi haskellers. I have a Haskell file for my variables, which change after i use a parser. If i want to use the variables, i need to compile my programm every time after a change. Is there a way to avoid the compiling part? Someone told me about serialization.
11:59:21 <jle`> and they don't want naming conflicts?
11:59:26 <vanila> NikolajK, you need semantics to reason about the meaning of the bits of syntax you write
12:00:02 <hpc> Marquis: yeah, you would write your data to a config file of some other format, and then read it in at runtime
12:00:02 <Cale> NikolajK: Oh, well, the reason that people like mathematical semantics is that we know a lot of mathematics
12:00:03 <jle`> XniX23: perhaps whatever readMay you are looking at does something different than readMaybe in base
12:00:04 <vanila> it can be defined denotationally (as a mapping from syntax into a semantics domain) or it can be done in terms of execution steps
12:00:23 <NikolajK> regarding identity types (whyever you mentioned it ^^). How is intentional type theory intentional AND identity have only one proof. If I change a lambda term "f" : A to "id f" : A, then I have another proof of A!
12:00:28 <hpc> a bajillion years ago you would use ini
12:00:33 <NikolajK> same for A being an identity type
12:00:42 <Cale> NikolajK: Being able to understand our language in terms of mathematical objects which are already well-understood typically seems like a good route
12:00:59 <Marquis> \msg hpc but i would like to have it as haskell code, because i have an own data type for the variables. Is that still possible?
12:01:08 <hpc> nowadays json is the most common choice if your data is simple enough, or other packages do their own thing
12:01:22 <Cale> NikolajK: It's also for this reason that one of the first things people did with HoTT was to work out some models in ZFC
12:01:43 <Fuuzetsu> what is ZFC
12:02:06 <Cale> Zermelo-Fraenkel set theory, with Choice.
12:02:06 <vanila> set theory
12:02:11 <silver> set theoretic axiom system
12:02:13 <NikolajK> a fast food chain, selling chicken
12:02:14 <Fuuzetsu> ah
12:02:22 <NikolajK> (no, Zermeno Freankel wiht Choice set theory)
12:02:25 <Cale> http://en.wikipedia.org/wiki/Zermelo%E2%80%93Fraenkel_set_theory
12:02:30 <Fuuzetsu> yes
12:02:42 <vanila> zermelo fried chicken - goes great with zorns lemon
12:02:58 <NikolajK> there is a pic parodying it
12:02:58 <Cale> It's sort of an ironic name, in that the main thing which Fraenkel brought to the table was Choice.
12:03:26 <Cale> So, calling the system without choice "ZF" is a bit weird, but that's what we do :)
12:04:16 <hpc> Z theory sounds like a really bad scifi movie
12:04:26 <Cale> (Though I suppose there was also regularity and replacement, but these are things which you don't tend to use directly unless you're a set theorist)
12:04:34 <NikolajK> there is a great book - "Abstract Algebra and the rise of mathematical structure", talks about those guys other works
12:04:58 <benzrf> zermelo fried chickn
12:05:15 <NikolajK> http://www.amazon.com/Modern-Algebra-Rise-Mathematical-Structures/dp/3764370025
12:05:56 <NikolajK> http://i.imgur.com/MbK3kvg.png
12:06:27 <NikolajK> the title is clever in that "Modern Algebra" is the name of an influential book
12:06:28 <NikolajK> http://en.wikipedia.org/wiki/Moderne_Algebra
12:06:43 <benzrf> lmao
12:07:06 <Cale> NikolajK: There's a sense in which the primary way that humans ever understand anything is by analogy with other things. Formal semantics, model theory, category theory are all sort of abstractions of that very process.
12:07:25 <msafi> Oh, cool. You can actually do interactive Haskell development in Atom editor http://i.imgur.com/OlZlXI3.png
12:07:27 <NikolajK> k, I've got a better feeling for it, I guess
12:07:32 <msafi> Using this https://github.com/rgbkrk/atom-script
12:07:33 <NikolajK> did you see my intentionality question?
12:07:41 <NikolajK> >regarding identity types (whyever you mentioned it ^^). How is intentional type theory intentional AND identity have only one proof. If I change a lambda term "f" : A to "id f" : A, then I have another proof of A!
12:08:06 <Cale> id f is going to be equal to f
12:08:16 <NikolajK> extenionally
12:08:32 <marsim> a
12:08:39 <marsim> Hi all
12:08:53 <Cale> No, do beta reduction.
12:09:52 <Cale> refl : Id A f (id f)  will typecheck
12:10:12 <NikolajK> A f (id f)?
12:10:23 <Cale> Those are parameters to Id
12:10:25 <NikolajK> me know understand that spacing
12:10:29 <vanila> in these type theory we have a notion of 'convertability' to say that two things are identical - and if T and T' are then t : T implies t : T'
12:10:43 <NikolajK> f =_A (id f)?
12:10:49 <Cale> yes
12:11:16 <NikolajK> convertability… sounds like introducing another notion of =, i.e. cheating :P
12:11:19 <Cale> Also, you'll have f being definitionally or judgmentally equal to id f
12:11:50 <NikolajK> isn't the equivalence they speak of in the HoTT book also just being able to map in both directions?
12:11:53 <vanila> yes it's an equivalence relation
12:12:03 <vanila> beta congruence + some more stuff
12:12:20 <vanila> this is not to do with HoTT
12:12:35 <NikolajK> I completely fail to understand what univalence brings to the common man on the street
12:12:47 <NikolajK> why being hyped about HoTT — if not already for ITT
12:12:53 <Cale> NikolajK: You seem to change the topic a whole lot :D
12:13:09 <Cale> NikolajK: Because HoTT gives us another way to think about MLTT
12:13:15 <vanila> yeah I don't know why people care about HoTT
12:13:16 <NikolajK> haha, you get side tracked on math here, bro ;)
12:13:23 <Cale> which makes it interesting to a new and wider audience
12:13:45 <NikolajK> I mean MLTT when saying ITT, I think
12:14:02 <vanila> Cale, what new way?
12:14:06 <Cale> In particular, it shows us how to interpret MLTT as talking about homotopy types of spaces
12:14:12 <NikolajK> (but I still don't know why type inference in ITT isn't decidable)
12:14:22 <Cale> HoTT is more of an interpretation of MLTT than anything else
12:14:40 <NikolajK> semantics :D
12:14:52 <Cale> Yes, univalence is important for excluding models which we don't work very well with the interpretation
12:14:54 <vanila> I don't get why HoTT matters
12:15:04 <vanila> is it important to programming languages?
12:15:18 <NikolajK> good question
12:15:20 <Cale> vanila: I for one would really love to have higher inductive types in my language
12:15:30 <vanila> Cale, doesn't coq have that?
12:15:33 <Cale> If we ever sort out how to compute with them
12:15:36 <NikolajK> how does one use identity types in proper programming anyway
12:15:37 <Cale> Not really, not yet
12:15:40 <vanila> oh
12:15:42 <Cale> Well, people are working on it
12:16:00 <vanila> what are higher inductive types?
12:16:27 <NikolajK> n-categories, semantically skeaking, I think (?)
12:16:32 <Cale> They're like ordinary inductive types (like Coq has), but with the addition that you're allowed to introduce new constructors on identity types between terms already introduced
12:16:37 <Cale> e.g.
12:16:44 <Cale> data Circle where
12:16:51 <Cale>   basePoint : Circle
12:17:01 <Cale>   loop : basePoint = basePoint
12:17:08 <NikolajK> dat single semicolon
12:17:12 <Cale> colon
12:17:24 <NikolajK> *ashamed*
12:17:39 <benzrf> what makes a type inductive
12:17:49 <vanila> weird that's interesting
12:17:59 <vanila> so you have this anti-UIP theory
12:18:05 <vanila> and you're able to provide new proofs of equality
12:18:05 <Cale> This introduces a type with a single data constructor, basePoint, and then a *non*-refl proof that it's equal to itself
12:18:38 <Cale> yes
12:19:01 <Cale> and then the type basePoint = basePoint is essentially the integers :)
12:19:03 <NikolajK> Cale: and that's interesting because non-trivial topology?
12:19:42 <NikolajK> wait...
12:19:46 <Cale> Because you have elements:  ..., loop^-1 . loop^-1,  loop^-1,  refl,  loop,  loop . loop, ...
12:19:48 <NikolajK> because iso to the fundamental group
12:20:21 <NikolajK> why do you have concatenation?
12:20:25 <Cale> (and you can actually prove in HoTT that this type is equivalent to some other more usual formulation of the integers)
12:20:42 <Cale> Well, concatenation is an operation which can be defined on identity types
12:20:58 <NikolajK> because path chaining or something, right?
12:21:05 <Cale> via path induction -- this is part of MLTT and doesn't require HoTT
12:21:10 <vanila> Cale, this sounds useful for doing mathematics
12:21:20 <NikolajK> okay, sadly I must go to the cinema, later and thx.
12:21:30 <vanila> is there an implementation?
12:21:45 <vanila> oh wait if there's a problem computing is type checking undecidable/
12:23:07 <Cale> vanila: There are issues computing both with univalence and higher inductive types. As I understand it, people have sort of worked out how to compute with univalence, but HITs are still presenting a challenge.
12:23:17 <vanila> I see
12:23:30 <Cale> It's expected that eventually we'll work it all out :)
12:23:41 <vanila> good luck!
12:23:58 <vanila> what about inductive-recursive definitions?
12:24:49 <Cale> Part of the issue is that we're not *totally* certain what HITs ought to be, and fixing the problems with univalence sort of has to involve passing to another system in which it's not an axiom already.
12:26:08 <Cale> https://github.com/simhu/cubical is an interpreter for a HoTT-like system where univalence is a theorem, based on cubical sets
12:26:55 <merijn> Cale: What would you say are the prerequisites for making sense of the HoTT book?
12:27:09 <vanila> cool!
12:27:27 <Cale> merijn: It's really hard to say. Essentially all of the people who are getting into this area are beginners in one or more areas which you might want to say are prerequisites.
12:27:50 <Cale> merijn: But lots of things help -- if you know a bit of Coq and/or Agda, for example.
12:27:58 <Cale> Or just dependent type theory in general
12:28:20 <Cale> Or from the other side of the bridge, if you know some (even very basic) homotopy theory
12:28:34 <Cale> Like, enough that you know what the fundamental group is
12:30:24 <Cale> There's another cliff-like learning curve immediately after the stuff which the book contains, and I've had troubles working out exactly how to begin there too.
12:30:43 <Cale> In particular, the book doesn't talk much at all about the model theory of HoTT or dependently typed systems
12:30:47 <merijn> Cale: Well, I know enough Coq to produce some basic proofs and enough dependent types that I vagual remember what the calculus of constructions is and managed to struggle through half of pigworker's thesis before giving up ;)
12:31:07 <Cale> merijn: You might be able to read the book then, at least the first few chapters should be good
12:31:12 <merijn> ok
12:31:28 <hiptobecubic> "pigworker" ?
12:31:37 <Cale> merijn: The "introduction" is not meant to be immediately comprehensible though :)
12:31:39 <merijn> hiptobecubic: It's Conor McBride's IRC/twitter handle
12:31:43 <Cale> merijn: just as a warning :)
12:31:47 <hiptobecubic> merijn, ah
12:32:13 <Cale> The part just after that is a review of the basic constructions of dependent type theory though, so it should be easy
12:32:31 <dfeuer> Hmph. It took long enough for me to figure *that* out. How ... annoying.
12:33:20 <Cale> dfeuer: To figure what out?
12:33:56 <dfeuer> Cale, likely reasons for the somewhat odd design of edwardk's NonEmpty type.
12:34:26 <Cale> dfeuer: Is your comment a reply to something much earlier?
12:34:35 <Cale> oh
12:34:35 <dfeuer> No.
12:34:45 <Cale> Er, also I misparsed your explanation :)
12:34:48 <dfeuer> Well, sort of.
12:35:04 <dfeuer> But days ago, to someone else. I don't remember who :P
12:36:28 <dfeuer> Then again.... maybe I'm wrong about that :P
12:36:34 <dfeuer> Still thinkin'.
12:38:48 <msafi> Why is this not working "main = putStrLn map ($ 3) [(4+), (10*), (^2), sqrt]"?
12:39:39 <msafi> It says couldn't match expected type
12:40:01 <burp> first you need a $ after putStrLn
12:40:16 <burp> and then putStrLn wants a String as argument
12:41:00 <burp> to use putStrLn . show $ or just print $
12:41:20 <msafi> burp: great! thanks!
12:41:38 <ion> That is parsed as (((putStrLn map) ($ 3)) […])
12:42:02 <msafi> ion: yeah, I didn't know that!
12:44:54 <Fuuzetsu> also you probably want ‘print’ there…
12:51:08 <SwashBuckla> LYAH Chapter 'For a Few Monads More' mentions at the end "We see that our monad doesn't know how to join all of the False outcomes where all coins don't land tails into one  outcome. That's not a big problem, since writing a function to put all the same outcomes into one outcome is pretty easy and is left as an exercise to the reader (you!)"
12:51:20 <SwashBuckla> I don't know how to do this -- anyone got an idea?
12:51:38 <SwashBuckla> see bottom of http://learnyouahaskell.com/for-a-few-monads-more
12:52:29 <SwashBuckla> I have attempted this by defining `instance Monoid (Prob a) where...`
12:53:59 <lpaste_> SwashBuckla pasted “instance Monoid Prob” at http://lpaste.net/110999
12:56:41 <SwashBuckla> however, I believe the correct result of evaluating `flipThree` is not Prob {getProb = [(False,1 % 40),(False,9 % 40),(False,1 % 40),(False,9 % 40),(False,1 % 40),(False,9 % 40),(False,1 % 40),(True,9 % 40)]}
12:57:06 <SwashBuckla> the False items should be joined
13:09:50 <Kron> is it possible to cabal install a package while keeping the older version around?
13:09:54 <edwardk> ocharles: hadn't known you hadn't known i was a flipcoder ;)
13:09:58 <benzrf> Kron: use nix
13:10:00 <Kron> installing the latest lens package will break a lot of my other ones, it tells me
13:10:06 <benzrf> or sandboxes
13:10:11 <sinelaw> Kron, I use cabal-dev
13:10:25 <Kron> ... what does cabal-dev entail?
13:10:30 <Kron> I know of nix and I've heard of sandboxes
13:10:32 <sinelaw> Kron, it's a sandbox
13:10:38 <Kron> ah
13:10:41 <Kron> okay!
13:10:47 <sinelaw> it lets you maintain a local cabal setup for the directory you're developing in
13:10:58 <benmachine> I thought cabal-dev was mostly replaced by cabal sandboxes
13:11:07 <silver> yeah
13:11:10 <sinelaw> benmachine, I may be behind the times then
13:11:16 <mjrosenb> I thought cabal-install was not a package manager, and never removed anything c.c
13:12:03 <silver> mjrosenb, http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
13:15:47 <hexagoxel> SwashBuckla: you might argue that if you want common elements in Props to be combined, the choice of [] is bad. but the task probably is not to change that. my guess is that you should just implement a function, lets call it "merge", so that "merge (getProb flipThree)" gives the result you actually want.
13:16:27 <SwashBuckla> hexagoxel: yeah
13:17:06 <hexagoxel> merge :: [(a,Rational)] -> [(a,Rational)] (or maybe less general: set a==Bool)
13:17:36 <SwashBuckla> if I include merge in my definition of mappend, would that do what I want?
13:17:46 <hexagoxel> :t Data.List.group -- SwashBuckla: might be helpful
13:17:47 <lambdabot> Eq a => [a] -> [[a]]
13:17:57 <hexagoxel> uhm, or groupBy
13:20:13 <hexagoxel> SwashBuckla: i don't know; to be frank, the Monoid instance seems to be completely irrelevant
13:20:29 <SwashBuckla> hmm
13:21:35 <SwashBuckla> I guess I was just thrown, as LYAH seems to suggest "Our monad doesn't know how..." and I thought that meant "You can write some code so that the monad DOES know how to join.."
13:22:13 <hexagoxel> (also, you probably want the sum of elements in a Prop to be normalized, i.e. 1. with that monoid instance, you just add more elements, and lose that property)
13:23:48 <hughfdjackson> hey :)
13:23:56 <hughfdjackson> i'm having a little trouble accessing a package inside a sandbox via ghci
13:25:00 <hughfdjackson> I've done `cabal install -j --disable-tests wreq` after `cabal sandbox init`
13:25:43 <hughfdjackson> ghci can't find Network.Wreq, and cabal repl claims not to be able to find wreq (suggesting I add it to my build file)
13:26:05 <hughfdjackson> :p i assume now i've said that, i've gotta just add the dep to my build file each time i want to try something in the REPL
13:26:44 <kadoban> hughfdjackson: I don't think ghci is sandbox-aware at all, although I think I remember seeing some kind of wrapper script somewhere to do that.
13:27:01 <hexagoxel> SwashBuckla: well, you could define (>>=) differently, i guess. still, that does not seem straightforward, and i guess it was not meant to be interpreted that way.
13:27:14 <hughfdjackson> kadoban: aha - so `cabal repl` it is ?
13:27:19 <Feuerbach> hexagoxel: this one? http://ro-che.info/articles/2014-03-05-cabal-sandbox-tips
13:27:27 <kadoban> hughfdjackson: From what I've read, yeah.
13:27:36 <SwashBuckla> ok. Thanks hexagoxel
13:27:47 <Feuerbach> sorry, that was to kadoban
13:27:52 <hexagoxel> np
13:28:06 <hexagoxel> also, np :)
13:28:17 <kadoban> Ya, that looks like what I was thinking of. maybe Feuerbach's link will help hughfdjackson? YMMV, I never tried it yet, because I don't really need it.
13:28:46 <hughfdjackson> kadoban, Feuerbach : i'll give it a go
13:28:53 <hughfdjackson> out of interest, why don't you need it, kadoban ?
13:29:19 <dfeuer> Cale, I think the basic answer is probably that types for nonempty lists can be more interesting in a strict language than a lazy one. Laziness really limits the options. The prohibition on lazy pattern matching on GADT constructors gets in the way even when it *seems* like there shouldn't be an issue. There's probably a deep reason for that.
13:29:24 <hughfdjackson> :p i thought everyone was using both the repl and sandboxes
13:29:44 <kadoban> Just the things I've used sandboxes for so far I haven't felt the need for ghci. I tend to throw things in a file and run them when I'm doing anything serious
13:29:59 <kadoban> They usually turn into like, unit tests
13:30:07 <hughfdjackson> :) aha - okay!
13:30:23 <nyuszika7h> :t Control.Exception.block
13:30:25 <lambdabot>     Not in scope: ‘Control.Exception.block’
13:30:25 <lambdabot>     Perhaps you meant one of these:
13:30:25 <lambdabot>       ‘Control.Exception.bracket’ (imported from Control.Exception),
13:30:31 <nyuszika7h> :t Control.Exception.mask
13:30:32 <lambdabot> ((forall a. IO a -> IO a) -> IO b) -> IO b
13:30:50 <hexagoxel> SwashBuckla: one more thing: defining the Monoid instance will not change how the Monad works. They are not related. the code worked without the Monoid instance, so it _can not_ (currently) be using Monoid methods.
13:31:06 <SwashBuckla> yeah I did think about that
13:31:31 <SwashBuckla> I think I got locked onto the idea that this would work :P
13:31:45 <SwashBuckla> I've got a merge function now that does the job
13:33:08 <hexagoxel> what you could do is incorporate the merge function into (>>=) (simply merge the list as the last step)
13:33:33 <hexagoxel> might not be the most efficient way, but at least more user-friendly
13:36:40 <XniX23> is it possible in ghci to tell the function type? f :: a -> b ?
13:37:42 <bennofs> is alterF making it into containers some time?
13:38:07 <hexagoxel> XniX23: let g::Int->Int; g=(+1)
13:39:04 <David> hi guys
13:39:21 <David> I'm trying to define my own uniplate instance and I'm getting some odd type errors
13:39:24 <David> here's the code: http://hastebin.com/zekojohewu.hs
13:39:52 <David> and the errors: http://hastebin.com/jisadewolo.coffee
13:40:24 <David> I'm not sure exactly what is wrong - I'm essentially imitating section 3 of http://community.haskell.org/~ndm/downloads/paper-uniform_boilerplate_and_list_processing-30_sep_2007.pdf
13:42:01 <joshkirklin> Is there a library for Haskell that supplies a bijective map type?
13:42:33 <srhb> joshkirklin: There was bimap, but not sure it's updated
13:43:20 <joshkirklin> srhb, Thanks. Last updated 2008; I'll see if I can't excavate it
13:43:47 <srhb> joshkirklin: It probably isn't difficult to fix it if it is broken, yeah :)
13:44:49 <joshkirklin> srhb, awesome, installs without a hitch on 7.8.3
13:44:59 <srhb> :)
13:48:15 <marsim> NJ
13:50:12 <lpaste_> blueonyx revised “is not in the type environment at a reify”: “... is not in the type environment at a reify” at http://lpaste.net/110982
13:51:03 <blueonyx> hi, any pointers why TH in ghc 7.8.3 gives a compile error, where 7.6.x didnt? ^
13:51:05 <Cale> blueonyx: hmm, that might be related to the changes to Template Haskell
13:51:31 <Cale> There are two TH's now, and they're both pretty significant redesigns of the old one
13:51:46 * hackagebot haskell-src-exts 1.16.0 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer  http://hackage.haskell.org/package/haskell-src-exts-1.16.0 (RomanCheplyaka)
13:51:48 * hackagebot yesod-auth-oauth2 0.0.6 - Library to authenticate with OAuth 2.0 for Yesod web applications.  http://hackage.haskell.org/package/yesod-auth-oauth2-0.0.6 (PatrickBrisbin)
13:52:09 <Cale> blueonyx: My guess here is that this is a staging issue
13:52:26 <Cale> blueonyx: It's possible that you need to define Fact in a separate module
13:53:11 <Cale> Let me see if I can find some documentation regarding the new TH stuff
13:53:55 <blueonyx> Cale: but the example from http://hackage.haskell.org/package/aeson-0.8.0.0/docs/Data-Aeson-TH.html works in a single module :/
13:54:24 <Cale> Yeah, also, the GHC docs say "The type environment seen by reify includes all the top-level declaration up to the end of the immediately preceding declaration group, but no more."
13:54:31 <Cale> "A declaration group is the group of declarations created by a top-level declaration splice, plus those following it, down to but not including the next top-level declaration splice. The first declaration group in a module includes all top-level definitions down to but not including the first top-level declaration splice."
13:55:06 <Cale> Ah!
13:55:20 <Cale> The problem is that this is not a declaration splice
13:55:39 <Cale> and there's no declaration splice in between this instance and the expression splice you're using
13:55:56 <Cale> er, in between the declaration of the data type and the expression splice you're using, rather
13:56:47 * hackagebot llvm-general 3.4.4.1 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.4.4.1 (BenjaminScarlet)
13:56:49 <Cale> In Data.Aeson.TH, the $(deriveJSON ...) is a declaration splice
13:56:57 <blueonyx> aye
13:56:59 <Cale> So it gets to see all the stuff that comes before it
13:57:05 <Vulpyne> Hello, I have a dumb question about profiling. The profiling output only seems to show *total* time rather than CPU time. I have a function that both does IO and seems to use excessive CPU, but from the profiling output I'm not really able to tell for sure.
13:57:16 <Vulpyne> What I want to do is see how much actual CPU it uses.
13:57:30 <Cale> blueonyx: I wonder if there's such a thing as an empty declaration splice
13:58:20 <cow_2001> what's a good module for terminal UI?
13:59:20 <blueonyx> Cale: ah you're right, if i create a dummy type and use $(deriveJSON..) before my real splice it works :-/
13:59:49 <RobConStanley> Can I somehow make this work in one line "Dir.getDirectoryContents Dir.getCurrentDirectory" the types are "Filepath IO FilePath" ? I'm new to haskell and I know how to do it through a do notation, but I wonder how it can be simplified. Right now it obviously complaines that it can't match IO Filepath with String. Because Dir.getCurrentDirectory returns IO FilePath, but getDirectoryContents wants a string..
14:00:09 <Cale> blueonyx: right, because the stuff before each declaration splice is compiled and brought into scope in all the subsequent splices
14:00:23 <Vulpyne> RobConStanley: Probably Dir.getCurrentDirectory >>= Dir.getDirectoryContents
14:00:42 <Vulpyne> RobConStanley: That's basically the same as blah <- getCurrentDirectory; getDirectoryContents blah
14:01:10 <Cale> Or you can use =<< to keep the order the same
14:01:57 <Cale> RobConStanley: The key thing to realise is that values of type IO t are not at all like values of type t, they're like programs which if you were to execute them, will give you a value of type t
14:01:59 <Vulpyne> RobConStanley: If it helps, the type of (>>=) is: Monad m => m a -> (a -> m b) -> m b
14:02:14 <Cale> Much like /bin/ls isn't really a list of files, but rather a program that if you run it, prints out a list of files
14:02:22 <Vulpyne> So there's some monadic value on the left side, it extracts it, calls the function on the right side with the extracted value as its argument.
14:02:41 <Cale> So, >>= and/or do-notation is used to glue simpler programs together into more complicated ones
14:03:26 <RobConStanley> Oh, thx. Yes it works great. Now I'm getting it.
14:03:27 <Vulpyne> So in the case of your FilePath functions, it would look like (>>=) :: IO FilePath -> (FilePath -> IO XXX) -> IO XXX
14:03:35 <Vulpyne> Where XXX is whatever type getDirectoryContents returns.
14:03:56 <Cale> do dir <- getCurrentDirectory; getDirectoryContents dir -- this is the program which if executed will first execute getCurrentDirectory, calling the resulting String dir, and then execute getDirectoryContents dir (returning its result as its own)
14:03:57 <cow_2001> okay, https://betterseapower.github.io/ansi-terminal looks decent for my very humble needs
14:04:20 <Cale> and that's the same as  getDirectoryContents =<< getCurrentDirectory
14:04:41 <Cale> cow_2001: That's a 404 though...
14:04:52 <Vulpyne> (=<<) = flip (>>=)
14:05:09 <Cale> cow_2001: I've seen people use vty-ui, though I have no idea if it's any good
14:05:14 <Vulpyne> Did anyone have an idea about my profiling question?
14:05:44 <cow_2001> i may have typed it in incorrectly... https://batterseapower.github.io/ansi-terminal/
14:05:59 <cow_2001> yes, it's 'batter' not 'better'
14:06:03 <Cale> ah
14:06:45 <Cale> Vulpyne: hmm, good question
14:06:58 <cow_2001> why am i too lazy to copypaste things and instead type them directly? sounds like a weird cognitive bug.
14:07:12 <Vulpyne> Cale: I tried to figure it out myself, but I couldn't find anything useful.
14:07:23 <geekosaur> also depends on the environment. some of them make it difficult to copy-paste sanely
14:07:36 <blueonyx> Cale: hm such a dummy declaration is rather annoying but seems to be an easy workaround, thanks!
14:07:44 <Vulpyne> Combing through the GHC manual didn't turn up anything, so it seems like I might not be able to do what I want.
14:07:51 * geekosaur keeps tripping over his new irc client using cmd-shift-c instead of control-c to copy despite looking just like his old client
14:07:54 <XniX23> is it ok to think of functor as a context that has something in it?
14:07:57 <Vulpyne> mysql-simple seems to use an excessive amount of CPU to do queries.
14:08:45 <geekosaur> (and made worse by the fact that cmd-shift-c means something rather different in his brain'keybinding, so even when I remember it I keep hesitating before doing it because I think the window will close on me :p )
14:08:46 <Cale> Vulpyne: There is an RTS option (-t) which will print out statistics about mutator CPU time vs. wall time.
14:09:11 <Cale> Vulpyne: However, I'm not sure how to get similar information about each cost centre
14:09:33 <pjdelport> XniX23: Yes, for a sufficiently general definition of "context". I like to think of them as an abstract structure with typed slots (where "structure" includes things like actions and effects).
14:09:41 <Cale> (-s is similar but more elaborate)
14:10:20 <Vulpyne> Cale: Yeah, I have that turned on (using -s actually)
14:10:25 <Vulpyne> That's how I know it's actually using more CPU than it should.
14:10:43 <XniX23> pjdelport, so that it's consistent with monads?
14:10:45 <Vulpyne> Profiling shows most of my time spent in making DB connections and queries, which is what I'd expect.
14:10:51 <Vulpyne> But I'd expect actual CPU usage to be extremely low.
14:11:01 <Vulpyne> And profiling shows my own functions using essentially no CPU.
14:11:22 <Vulpyne> So that makes me suspect that the DB functions in addition to using most of the realt ime (as I'd expect) are using more CPU than they should.
14:11:30 <pjdelport> XniX23: And having slots you can operate on does not necessarily mean containment: for example, with IO actions, the "structure" is the action's effect, and the "slots" are the result value of the effect.
14:11:58 <Vulpyne> I guess I can write my own code that uses the base MySQL library instead of mysql-simple
14:12:15 <Vulpyne> I looked at the source and it does some silly stuff, like building up a list and reversing it instead of just using a dlist.
14:12:39 <jle`> i don't really like thinking of (>>=) as extraction
14:12:47 <pjdelport> XniX23: And yes, that's consistent with monads. Monads are effectively functors (or Applicatives, rather) that let you merge two nested layers of structure into one layer, while preserving the structure of both: that's what join does.
14:12:49 <jle`> it implies that there's something to extract
14:12:49 <XniX23> pjdelport, so basically some computation with some results?
14:13:05 <Cale> Vulpyne: Well, using reverse isn't *that* bad
14:13:06 <Vulpyne> jle`: It's the simplest way to think about some of the most common uses of monads.
14:13:15 <pjdelport> XniX23: Right, in the case of IO. Other computation-like structures are Reader, State, ST, etc.
14:13:31 <Vulpyne> I think it's a useful crutch for someone just learning.
14:13:39 <jle`> useful or damaging?
14:13:42 <David> What's the easiest way to use uniplate in the exact same way that it appears on the original paper?
14:14:07 <jle`> i think it's just sufficient to understand what (>>=) does for each individual type the person is working with
14:14:09 <David> I imported Data.Generics.Uniplate.Direct and wrote my own uniplate instance and I'm running into type errors
14:14:17 <Vulpyne> jle`: If RobConStanley falls in a hole and dies, probably damaging.
14:14:26 <jle`> trying to think of an overall description of what (>>=) "does" for all Monad instance is sort of...a pointless thing, to me
14:14:29 <sinelaw> @pl \x -> [x]
14:14:29 <lambdabot> return
14:14:31 <jle`> why even bother?
14:14:46 <Cale> David: Could you link the original paper? Perhaps we could help fix whatever type errors you're seeing?
14:14:47 <pjdelport> =<< is function application for Kliesli arrows :)
14:14:58 <Vulpyne> Cale: Still, it makes me suspicious of the rest.
14:15:23 <Vulpyne> Cale: mysql-simple has two functions for pulling in results, query and fold (which streams results). When I switched to using the fold and my own dlist, it used much less CPU.
14:15:28 <Vulpyne> Cale: So something weird is happening.
14:15:34 <David> Cale: http://hastebin.com/zekojohewu.hs code, http://hastebin.com/jisadewolo.coffee errors, trying to imitate stuff at the start of section 3 from http://community.haskell.org/~ndm/downloads/paper-uniform_boilerplate_and_list_processing-30_sep_2007.pdf
14:15:36 <cow_2001> lol batterseapower's ansi-terminal has cursor movement functions that make me think of the old turtle program...
14:16:30 <Vulpyne> jle`: I found it useful to think about it that way, but of course whether other people find it helpful may differ.
14:16:43 <jle`> whatever description you try to think of (besidse the actual mathematical description) is only going to lead into bumps later on.  what's the point?  what's the benefit of even having an "intuitive" description of (>>=) that works for all Monad instances?
14:16:44 <David> Something to do with the Str.Str type, but I'm not sure how to handle it
14:16:46 <jle`> (for new people)
14:16:52 <Vulpyne> If we disagree, that's okay. There's no need for fisticuffs at dawn.
14:17:14 <jle`> :)
14:17:41 <Vulpyne> jle`: For stuff like Maybe, IO, etc, that model of thinking about it works pretty well. Those are the monads that I personally tend to use the most.
14:17:57 <Vulpyne> For stuff like the list monad (which I've never even had cause to use) it's misleading.
14:18:55 <Vulpyne> Just 1 >>= return >>= return >>= return >>= return -- Monadsturbation can lead to blindness.
14:18:59 <jle`> then maybe we can say "for some Monad instances, (>>=) is like an extractor" :)  "for some Functor instances, fmap applies the things to what it contains"
14:20:02 <Cale> David: Oh!
14:20:22 <Cale> David: Yeah, this is the difference between Data.Generics.Uniplate.Operations and Data.Generics.Uniplate
14:20:45 <Cale> David: data Str a = Zero | One a | Two (Str a) (Str a)
14:20:46 <David> wait, which one should I be importing?
14:21:05 <Cale> If you want it to be more like the paper, then Data.Generics.Uniplate
14:21:07 <David> the hackage doc suggested I should import .Uniplate.Direct if I was going to define my own uniplate instances
14:21:08 <David> ah
14:21:16 <David> isn't that deprecated?
14:21:19 <Cale> yes
14:21:24 <Yxven> \
14:21:24 <Yxven> \
14:21:24 <Yxven> \
14:21:24 <Yxven> \
14:21:24 <Yxven> \
14:21:24 <Yxven> \
14:21:27 <Yxven> \
14:21:29 <Yxven> \
14:21:31 <Yxven> \
14:21:33 <Yxven> \
14:21:34 --- mode: ChanServ set +o Cale
14:21:35 <Yxven> \
14:21:37 <Yxven> \
14:21:38 --- kick: Yxven was kicked by Cale (Yxven)
14:21:49 * hackagebot haskell-names 0.4.1 - Name resolution library for Haskell  http://hackage.haskell.org/package/haskell-names-0.4.1 (RomanCheplyaka)
14:22:05 <Cale> lol, I'm going to assume that wasn't intentional
14:22:08 <David> so what's the non-deprecated way to do it using Operations?
14:22:09 <joelteon> He finally escaped
14:22:09 --- mode: Cale set -o Cale
14:22:33 <Vulpyne> Oh well. Thanks for responding, Cale.
14:22:37 <Yxven> apologies my cat
14:22:45 <XniX23> Vulpyne, could you explain this Monadsturbation? Why doesn't it work if i do it like this: Just 1 >>= \_ -> return >>= \_ -> return
14:22:52 <Yxven> Sorry, my cat wanted tp say hello
14:23:06 <jle`> XniX23: check your types :)
14:23:36 <jle`> \_ -> return is not the same as return
14:23:49 <jle`> :t \_ -> return
14:23:51 <lambdabot> Monad m => t -> a -> m a
14:23:53 <jle`> :t return
14:23:54 <lambdabot> Monad m => a -> m a
14:24:21 <Cale> David: Well, see the example here: http://hackage.haskell.org/package/uniplate-1.6.12/docs/Data-Generics-Uniplate-Operations.html
14:24:36 <XniX23> oh i see, i wrapped a bit too much
14:24:41 <Cale> David: It's very similar to the case where lists are used, except you're allowed to pick a somewhat arbitrary tree structure
14:24:51 <David> ah, thanks.
14:25:07 <David> (btw, I used vanilla Generics.Uniplate and it worked)
14:25:12 <jle`> :t \x -> return x    -- this is the same, though
14:25:13 <lambdabot> Monad m => a -> m a
14:25:20 <David> Gonna read this to figure out the non-deprecated way of doing things though
14:25:22 <Cale> Yeah, you can probably get away without writing those things by hand
14:26:01 <blueonyx> :t \_ -> return
14:26:02 <lambdabot> Monad m => t -> a -> m a
14:27:53 <XniX23> jle`, thanks i get it now
14:32:33 <jle`> man Arrow is so weird
14:32:49 <jle`> who thought of this mess
14:32:59 <jle`> (much respect though regardless)
14:32:59 <hpc> twist: it was you
14:33:21 <jle`> :O
14:33:26 <vanila> yeah I think we need functions on (a,b) not Arrow r => r a b
14:33:47 <jle`> oh, i was thinking more about the fact that Kleisli m isn't eaven a meaningful Arrow instance
14:33:51 <vanila> these things like &&& are useful but the typeclass is confusing
14:34:14 <jle`> and that the laws for Arrow don't really prevent weird behavior under side chaining for some instances
14:34:42 <jle`> oh and yeah, abuse of the (->) instance for Arrow is sort of silly too
14:35:15 <jle`> but i've not too much qualms for the behavior of that particular instance
14:35:44 <jle`> also there are a lot of useful abstractions for which (&&&) and (***) etc. could be useful, but the existance of 'arr' completely kills their possibility of being implemented
14:35:49 <jle`> existence
14:36:11 <chrisdone> jle`: what like?
14:36:50 <jle`> i'm pretty sure that Arrow (w/out arr) + Profunctor would be good enough to replace the current Arrow typeclasses for instances that do have Arr
14:36:51 <chrisdone> :t (***)
14:36:52 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
14:36:53 <jle`> 'arr'
14:37:29 <jle`> arr f = rmap f id :: (Category c, Profunctor c) => (a -> b) -> c a b
14:38:08 <jle`> chrisdone: um. i was hoping nobody would call me out on that because i can't think of too many at the moment v.v
14:38:18 <jle`> one one that comes to mind is implicit data parallization
14:39:21 <jle`> any Arrow gives you a free Profunctor instnace anyways, so no current Arrow instance that uses 'arr' would have problems in this reorganization
14:39:39 <jle`> is it too late to submit things for 7.10
14:39:40 <jle`> :)
14:39:44 <vanila> profunctor is way bette
14:39:44 <vanila> r
14:40:13 <jle`> it is for what profunctor is meant for :P  so it subsumes arr
14:40:29 <chrisdone> :t dimap
14:40:30 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
14:40:51 <chrisdone> :t dimap :: (a -> b) -> (c -> d) -> (b -> c) -> a -> d
14:40:52 <lambdabot> (a -> b) -> (c -> d) -> (b -> c) -> a -> d
14:41:16 <jle`> i'd liek to be able to build useful things with (***)/(&&&)/left/right without arr pls
14:41:41 <jle`> but i think there are some more fundamentally weird things than that.  i'm not sure if taking away arr would fix the laws being weird
14:43:42 <chrisdone> :t dimap :: (Char -> Bool) -> (Char -> Bool) -> (Bool -> Char) -> (Char -> Bool)
14:43:44 <lambdabot> (Char -> Bool) -> (Char -> Bool) -> (Bool -> Char) -> Char -> Bool
14:44:05 <chrisdone> :t dimap isDigit isLetter
14:44:05 <lambdabot> Profunctor p => p Bool Char -> p Char Bool
14:45:27 <chrisdone> :t dimap isDigit isLetter (\x -> if x then 'a' else '?')
14:45:28 <lambdabot> Char -> Bool
14:45:35 <chrisdone> > dimap isDigit isLetter (\x -> if x then 'a' else '?') 'x'
14:45:36 <lambdabot>  False
14:45:48 <chrisdone> > dimap isDigit isLetter (\x -> if x then 'a' else '?') '3'
14:45:49 <lambdabot>  True
14:45:59 <chrisdone> what's the point of this method?
14:46:09 <jle`> dimap is like rmap + lmap
14:46:22 <jle`> ...um i'm sure you knew that
14:46:23 <chrisdone> can you rephrase without using the word 'like'?
14:46:34 <jle`> if you ever want to both rmap and lmap
14:46:41 <jle`> ...something i've rearely had to do
14:46:54 <chrisdone> :t lmap
14:46:54 <jle`> i mean, i've had to rmap and lmap...i could imagine myself doing both
14:46:55 <lambdabot> Profunctor p => (a -> b) -> p b c -> p a c
14:46:58 <jle`> at the same time
14:47:14 <jle`> dimap l r = lmap l . rmap r
14:47:56 <chrisdone> :t lmap (read :: String -> Int)
14:47:57 <lambdabot> Profunctor p => p Int c -> p String c
14:48:01 <jle`> i've lmapped and rmapped, individually...i don't think i've ever done both to the same thing, but i think that's less of a fundamental thing and more of a it's-not-so-common thing
14:48:20 <chrisdone> :t lmap (read :: String -> Int) (toEnum :: Int -> Char)
14:48:21 <lambdabot> String -> Char
14:48:21 <vanila> :t dimap
14:48:22 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
14:48:30 <chrisdone> > lmap (read :: String -> Int) (toEnum :: Int -> Char) "bob"
14:48:32 <lambdabot>  *Exception: Prelude.read: no parse
14:48:35 <chrisdone> > lmap (read :: String -> Int) (toEnum :: Int -> Char) "1"
14:48:36 <lambdabot>  '\SOH'
14:48:45 <chrisdone> > lmap (read :: String -> Int) (toEnum :: Int -> Char) "97"
14:48:46 <lambdabot>  'a'
14:48:51 <chrisdone> hmm
14:49:42 <jle`> lmap is contramap
14:49:44 <chrisdone> jle`: what's a practical example of this?
14:50:00 <jle`> https://ocharles.org.uk/blog/guest-posts/2013-12-21-24-days-of-hackage-contravariant.html has some examples of contramap usages
14:50:49 <chrisdone> nevermind
14:56:32 <jle`> was it something i said :|
14:58:38 <vanila> lens uses profunctors
14:58:48 <vanila> to do partial lenses? like head and stuff, i tihnk
14:58:55 <vanila> haven't really looked at it yet
15:00:48 <Peaker> they use profunctors for lots of reasons, I think. Ones I know about: Uniform types for both indexed and non-indexed lenses/traversals/etc.   Another reason: Clever encoding of isomorphism as a function-like thing
15:01:01 <Fuuzetsu> I think I'm in a position where I have to juggle between making something not strict so that it's not calculated needlessly and strict enough so that the functions that do use it don't take much longer ;(
15:01:18 <jle`> i mostly use profunctors with Category...it's effectively (<<^).  if i have a Category and i want to "prime" its input, (the category takes a but i have a b), then i can lmap a (b -> a), to prepare the input to a Category
15:01:48 <edwardk> most of the profunctors i use don't happen to also be categories, when they are, if they are strong then they are also a full fledged arrow
15:01:53 * hackagebot llvm-general 3.3.13.1 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.13.1 (BenjaminScarlet)
15:02:00 <jle`> yeah, Profunctor is just Category + arr
15:02:02 <XniX23> you guys demoralize me. Will i need to learn category theory to get at your level
15:02:14 <jle`> XniX23: no, heh, none of this is really category theory
15:02:17 <jle`> they're just normal typeclasses
15:02:23 <jle`> like Functor, Monoid, etc.
15:02:28 <dfeuer> edwardk, did you get my little message/question?
15:02:38 <jle`> just functions that you might not have seen in the past :)
15:02:55 <edwardk> jle`: you mean Arrow is just Category + Profunctor + first/second ;)
15:03:03 <edwardk> dfeuer: not yet
15:03:12 <jle`> edwardk: yes, heh.  i read it over again after i typed it >.<
15:03:36 <edwardk> dfeuer: re NonEmpty, there are a few options, they all vary based on when you know you're done
15:03:58 <jle`> XniX23: we're just talking about ways different Haskell typeclasses fit together or are related.  they just happen to have mathy names ;)
15:04:06 <edwardk> data NonEmpty a = a :| [a] -- is nice if you primarily will be using it as a list when you are done dealing with the head which is common
15:04:31 <jle`> XniX23: it's like talking about Ord and Eq...Ord is just Eq + (>) and (<), right? :P
15:04:32 <edwardk> dfeuer: but data NonEmpty a = Last a | More a (NonEmpty a) -- is a more list like approach
15:04:48 <edwardk> dfeuer: but now you can know you're at the last argument a constructor earlier
15:04:48 <dfeuer> edwardk, ending with a singleton has an obvious laziness problem. A GADT solution has a problem with laziness if you need to go from "list known to be nonempty" to "list not known to be empty".
15:05:05 <dfeuer> That's what it looks like to me anyway.
15:05:19 <edwardk> dfeuer: there are several other options involving a GADT and a flag internally, etc.
15:05:21 <wojtekM_> Is there a way to have record fields that are calculated from other fields? Something like this: data Test = Test { a,b :: Int; tot = a + b }
15:05:32 <edwardk> but the one i picked was because it was the one that benchmarked the best for the most uses
15:05:45 <benmachine> wojtekM_: well, you wouldn't be able to set such a field, would you? so it's just a function
15:05:50 <edwardk> and it was pretty clean to explain to someone who just wanted to sprinkle it into their code to get rid of a couple of spurious null checks
15:06:20 <edwardk> the other encodings require you to walk all the way to the end of the list to convert between the 'builder' structure and the 'view' structure to use the parlance of atze's talk on reflection without remorse
15:06:23 <wojtekM_> benmachine: yes, just a function. I would like it's value stored for efficiency.
15:06:40 <edwardk> so e.g. to take the tail of a nonempty list and get a list out you have to pay O(n) for most encodings
15:06:50 <XniX23> jle`, thank you for calming me down
15:06:50 <edwardk> so converting back and forth is expensive
15:06:53 * hackagebot jsonrpc-conduit 0.2.6 - JSON-RPC 2.0 server over a Conduit.  http://hackage.haskell.org/package/jsonrpc-conduit-0.2.6 (GabrieleSales)
15:06:54 <benmachine> wojtekM_: oh, I see, fair point
15:07:00 <edwardk> the :| version is O(1) to switch between building and view
15:07:11 <edwardk> at the expense that some operations (e.g. folding with a semigroup) become more complicated
15:07:24 <benmachine> wojtekM_: your only real option then is to have it as an ordinary record field, but hide the type and allow update only through your own functions which also update the field
15:07:29 <RobConStanley> How can I make this expression work in GHCI/IHaskell  '  getDirectoryContents "/bin"  >>= elem "bash"    '?  It seems that the problem here is that `elem` doesn't return IO Monad (IO b0), but it simply returns Bool. I can't get how to lift `elem` to return IO or what else I can do to make this expression work.
15:08:02 <dfeuer> edwardk, is there *any* way to avoid knowing if you're at the end of the list a constructor too early using any of the formulations that make the end of the list weird rather than the beginning? You said something about a GADT with an internal flag, but I don't know what that means.
15:08:04 <edwardk> dfeuer: its really the conversion cost that drove the implementation i use
15:08:07 <wojtekM_> benmachine: Oh, boilerplate :-)
15:08:27 <wojtekM_> benmachine: I thought so, thanks for confirming.
15:08:36 <benmachine> wojtekM_: well, it's possible there's something clever I don't know about
15:08:38 <benmachine> very possible
15:08:49 <benmachine> but that's what I would do in the same situation
15:08:56 <dfeuer> edwardk, that makes a lot of sense. The unpleasant part of it is that recursively walking it by hand does a lot of shuffling.
15:09:10 <dfeuer> Maybe.
15:09:11 <wojtekM_> benmachine: I searched the docs quite well..
15:09:26 <dfeuer> Well, I should say *looks* like it does a lot of shuffling. I don't know if it really does.
15:10:05 <benmachine> it bothers me that in both the non-empty lists edwardk suggested, you have to treat one element separately from the others
15:10:27 <benmachine> it doesn't bother me that much, but it rubs my aesthetic sense the wrong way
15:10:29 <edwardk> dfeuer: you might have something that tracks if its known to be non-empty in the constructor like a refinement type on a list, data MaybeEmptyList nonNull a where Nil :: MaybeEmptyList False a; Cons :: a -> MaybeEmptyList x a -> MaybeEmptyList True a, then wrap it up in a box like newtype NonEmpty a = NonEmpty (MaybeEmptyList True a) -- now we don't have the special element
15:10:34 <fizbin> :t flip const
15:10:36 <lambdabot> b -> c -> c
15:10:41 <edwardk> dfeuer: but you have to explore that the list is nonempty to ball it back up
15:10:55 <fizbin> @pl flip const
15:10:55 <lambdabot> const id
15:11:09 <edwardk> dfeuer: that version avoids the shuffle but is a lot more painful to use
15:11:31 <dfeuer> edwardk, I don't even know what a refinement type is, but that doesn't exist in Haskell, does it?
15:11:44 <edwardk> dfeuer: they dont, but the GADT i use above to fake it does
15:12:45 <edwardk> there you can know that you don't need to handle the Nil case by the fact that the types don't work
15:12:57 <edwardk> but once you're past that entry in the list you have to
15:13:09 <dfeuer> edwardk, the problem I saw with an approach I think is similar is that lazy pattern matching on GADT constructors is banned (for good reasons), so I couldn't actually make filter as lazy as I wanted.  Cons blah (case ...)  just doesn't work; it needs  case ... of ... -> Cons ....
15:13:17 <benmachine> edwardk: doesn't it end up being very much like the :| thing, except that the first constructor looks like the others?
15:13:25 <edwardk> but since list isn't built this way with an existential box on the MaybeEmptyList it still has the expensive version
15:13:28 <benmachine> I wonder if that's purely superficial
15:14:44 <edwardk> benmachine: well your complaint above was "it bothers me that in both the non-empty lists edwardk suggested, you have to treat one element separately from the others"
15:14:50 <edwardk> so now we don't handle that one separately ;)
15:14:56 <edwardk> i don't recommend it
15:15:06 <edwardk> because again, we don't implement lists in the way that would be compatible with this
15:15:19 <benmachine> edwardk: yes, the GADT approach satisfies my aesthetics, but like I said I'm not sure this actually helps :P
15:16:05 <edwardk> as for why you can't lazy pattern match on GADTs, its because you could otherwise do things like use Data.Type.Equality pattern match foo :: a :~: b -> a -> b; foo ~Refl a = a -- and get unsafeCoerce
15:16:37 <csoroz> #hackerrank
15:16:38 <dfeuer> edwardk, but can you make filter lazy enough for the GADT one, if you want it to return either MaybeEmptyList ....   or Maybe (NonEmpty a) or whatever.
15:16:42 <edwardk> benmachine: hence why i took the pragmatic approach of using a single constructor and a cheap view/builder conversion ;)
15:17:13 <edwardk> dfeuer: it doesn't matter the GADT one has the wrong asymptotics for taking tail and going to a list anyways ;)
15:17:34 <dfeuer> edwardk, for a theorist, you're awfully practical :-P
15:17:36 <edwardk> so it is entirely a straw man
15:17:49 <edwardk> for a theorist i ensure i have the right asymptotics first, then check my constants ;)
15:18:09 <David> is there a quick way to check if an object matches a certain data constructor?
15:18:11 <edwardk> happen to win on both fronts here ;)
15:18:25 <dfeuer> edwardk, there's no problem with asymptotics if you use an appropriate oracle!
15:18:34 <David> or do I have to write the boilerplate isA A _ _ = True; isA _ = False
15:18:57 * dfeuer has to run. Thanks, edwardk!
15:20:05 <edwardk> David: there are a few ways. mostly things like Data.Data though
15:21:33 <benmachine> David: I don't know if it helps with your problem, but you can write a pattern Just{} to match the Just constructor without having to put a bunch of underscores in
15:21:39 <benmachine> you can do this even if your type is not a record type
15:21:54 * hackagebot jammittools 0.3 - Export sheet music and audio from Windows/Mac app Jammit  http://hackage.haskell.org/package/jammittools-0.3 (mtolly)
15:22:03 <benmachine> > cast Left () of Left{} -> ()
15:22:04 <lambdabot>  <hint>:1:14: parse error on input ‘of’
15:22:12 <benmachine> er
15:22:15 <benmachine> > case Left () of Left{} -> ()
15:22:17 <lambdabot>  ()
15:22:37 <David> benmachine: naw, I was trying to do something like
15:22:47 <David> > Just 3 == Just {}
15:22:49 <lambdabot>  *Exception: <interactive>:3:11-17: Missing field in record construction
15:23:26 <edwardk> > is _Just (Just 4)
15:23:27 <lambdabot>  Not in scope: ‘is’
15:23:27 <lambdabot>  Perhaps you meant one of these:
15:23:27 <lambdabot>    ‘id’ (imported from Data.Function),
15:23:27 <lambdabot>    ‘C.id’ (imported from Control.Category),
15:23:27 <lambdabot>    ‘s’ (imported from Debug.SimpleReflect)
15:23:30 <edwardk> > has _Just (Just 4)
15:23:32 <lambdabot>  True
15:23:39 <edwardk> > has _Left (Left 4)
15:23:41 <lambdabot>  True
15:23:44 <edwardk> there is the lensy way ;)
15:23:57 <edwardk> Data.Data offers a way to get constrIndex of a constructor
15:24:07 <edwardk> but that is messy and only works if you are a Data instance
15:24:25 <joelteon-> specifically, a Data.Data.Data instance
15:24:44 <benmachine> whoever named that module, I take my hat off to them
15:25:10 <hpc> it's like a weird cross between beetlejuice and and TNG
15:25:15 <Peaker> benmachine: not enough Data, IMO
15:26:17 <shachaf> I,I Data.Data.Data.C
15:26:31 <joelteon> BloodyMary.BloodyMary.BloodyMary
15:27:26 <Peaker> shachaf: HT strikes again
15:27:51 <benmachine> data Data datadata = Data datadata deriving (Data.Data.Data, Data.Typeable.Typeable)
15:28:04 <benmachine> (shame about the Typeable, but it's necessary)
15:29:28 <joelteon> So should we have a new Codata module prefix at some point?
15:33:55 <thinkpad20> hey, does anyone know hspec? I'm wondering what's the idiomatic way to assert that an error is raised
15:34:43 <thinkpad20> it "should raise an error" (shouldError $ error "I'm an error")   <--- what's the `shouldError` function?
15:35:35 <jle`> do you mean Exception?
15:35:42 <thinkpad20> perhaps
15:36:12 <thinkpad20> I have code that in places uses the `error` function; I want to ensure that those get triggered when I expect them to
15:36:31 <jle`> just offering a potential keyword to search for :)
15:36:33 <thinkpad20> I assume there's a combinator for asserting some block of code throws an error
15:36:55 * hackagebot Munkres-simple 0.1.0.0 - Simple and typesafe layer over the Munkres package.  http://hackage.haskell.org/package/Munkres-simple-0.1.0.0 (ScrambledEggs)
15:36:58 <jle`> haskell functions don't really "throw errors" in the traditional sense
15:37:36 <jle`> the process of their evaluation in IO can make use of/trigger the runtime exceptions mechanism of GHC's runtime system
15:37:59 <jle`> but the technicality aside...umm....
15:38:04 <jle`> i'm not sure, i don't know much about hspec :/
15:39:36 <thinkpad20> right... and I want to make sure that they are triggering that runtime exception mechanism :)
15:40:31 <thinkpad20> I'm not super familiar with IO exceptions; I usually just use the error monad... but for this stuff I'm using the IO monad, and throwing exceptions in it
15:40:32 <jle`> http://hspec.github.io/expectations.html ?
15:40:43 <SrPx> How do I take `x^y` when x and y are fractionals?
15:40:51 <jle`> shouldThrow
15:41:07 <jle`> shouldThrow :: Exception e => IO a -> Selector e -> Expectation
15:41:11 <jle`> SrPx: you can use (**)
15:41:17 <thinkpad20> cool, that looks helpful, thanks!
15:41:18 <jle`> hm
15:41:28 <jle`> oh, i guess not
15:43:44 <jle`> @hoogle (Fractional a, Floating b) => a -> b
15:43:49 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
15:43:49 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
15:43:49 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
15:44:04 <jle`> hm i don't think unsafeCoerce is the answer
15:44:35 <SrPx> Hmm I just want this to work without reporting "infinity": http://lpaste.net/111007
15:44:53 <jle`> SrPx: are you talking about forall a. Fractional a => a?  or do you have a specific instance in mind?
15:45:05 <SrPx> I just want that to work /\ any idea?
15:45:23 <jle`> why doesn't it work now?
15:46:43 <SrPx> because it reports: "infinity" jle`
15:46:55 <SrPx> I want to know which of those is bigger... infinity doesn't help
15:47:14 <srhb> That's how floating point types work
15:48:01 <c74d> filter out infinities first?
15:48:45 <c74d> oh
15:49:16 <c74d> that advice may or may not make sense; I got this confused with another channel
15:49:39 <SrPx> srhb: ............... that is why I'm asking what is the right type to use there...
15:49:51 <srhb> SrPx: There isn't really any.
15:49:59 <srhb> Well, maybe fixed
15:50:11 <SrPx> There is no arbitrary precision real number with an exp function?
15:50:32 <hpc> CReal is
15:50:44 <hpc> it has termination problems due to being a bad enough dude
15:54:35 <dunric> hello
15:54:56 <srhb> dunric: Hello.
15:56:03 <dunric> how can I catch SomeException from inside a StateT monad transformer ?
15:56:54 <srhb> StateT has a MonadIO instance, I believe
15:57:06 <srhb> So you can use catch
15:57:19 <hexagoxel> only if inner monad is MonadIO, ofc
15:57:46 <dunric> StateT from Control.Monad.Trans.State has instances Monad & Functor only :(
15:58:34 <srhb> That's from transformers, isn't it?
15:59:00 <Peaker> dunric: why do you say that? That seems wrong
15:59:21 <Peaker> Control.Monad.Trans.State has a MonadIO instance here, from Control.Monad.Trans.State.Lazy (re-exported from Control.Monad.Trans.State)
15:59:49 <srhb> Indeed.
16:01:14 <dunric> I'm in ghci and after import Control.Monad.Trans.State I see only instances for Monad and Functor after :i StateT
16:03:35 <srhb> dunric: Bring the MonadIO class into scope
16:04:23 <dunric> @srhb Thanks !
16:04:23 <lambdabot> Source not found. Just what do you think you're doing Dave?
16:04:34 <srhb> dunric: Welcome.
16:06:58 * hackagebot Munkres-simple 0.1.0.1 - Simple and typesafe layer over the Munkres package.  http://hackage.haskell.org/package/Munkres-simple-0.1.0.1 (ScrambledEggs)
16:34:48 <nitrix> Hello guys, I'm a little confused.
16:35:07 <nitrix> There's an example on the wiki with this type:  playGame :: String -> State GameState GameValue
16:35:39 <tabemann> what about it?
16:35:49 <nitrix> Its supposed to explain State monads, but :info in ghci gives me:    type State s = StateT s Data.Functor.Identity.Identity
16:36:26 <Hijiri> you can ignore that until you learn about monad transformers
16:36:33 <Hijiri> that's how state is implemented in one of the packages I think
16:36:49 <Hijiri> basically a monad transformer allows you to combine monads
16:36:49 <nitrix> But, what is that Identity thing?
16:36:54 <dhrosa_> nitrix: that's just an internal detail about how the State monad is implemented
16:37:01 <Hijiri> Identity Monad just represents the value it contains
16:37:04 <dhrosa_> you can ignore it for now
16:37:17 <Hijiri> so if you do StateT Identity it effectively just does state
16:37:24 <Hijiri>  StateT s Identity
16:37:47 <Hijiri> Identity is the context of no context
16:40:11 <nitrix> I think what confuses me is currying.
16:40:54 <nitrix> The deeper I dig down about the State monad, things have extra type constructors and I just don't get it.
16:41:21 <Hijiri> in the implementation?
16:41:58 <nitrix> Mhm. It all started with: playGame :: String -> State GameState GameValue
16:42:08 <nitrix> I was wondering what was that GameValue thing and its purpose...
16:42:24 <Hijiri> GameValue is the result of the stateful computation
16:42:51 <Hijiri> I don't know what the purpose is either, since it isn't something specific to the State Monad
16:43:02 <nitrix> It's used nowhere in the code, so I figured, it's probably, from what I understand, how world-as-state systems work?
16:43:23 <BMeph_> nitrix: How comfortable are you with using (not explaining "how it works," just using) a Monad type?
16:43:32 <nitrix> Else it'd break referencial transparency? Is that why?
16:43:47 <Hijiri> world-as-a-state isn't something you would deal with unless you were dealing with IO on a low level, like in compiler implementations
16:44:00 <Hijiri> I mean not in this context
16:44:16 <nitrix> But then what's the purpose of GameValue :(
16:44:21 <nitrix> I hate doing things I don't understand.
16:44:25 <Hijiri> where did you get this code from?
16:44:39 <nitrix> Hijiri: http://www.haskell.org/haskellwiki/State_Monad >> "3 Complete and Concrete Example 1"
16:44:44 <David> is there a way to do multiple types of traversals with uniplate?
16:45:12 <Hijiri> GameValue is a type synonym for Int
16:45:15 <David> e.g. I have a tree of the form Tree = Tree Int Tree [Tree]
16:45:15 <dfsfsfsf> monochrom: Following up on our yesterday memoize discussion: I can't seem to wrap my head around the code in the memoize library.  A lot of functions are mutually recursive, how shoud I read it?
16:45:17 <Hijiri> type GameValue = Int
16:45:30 <Hijiri> It's just an example thing, to make you think about the applications
16:45:46 <David> and currently the datatype implements Uniplate by traversing down the main child (the Tree)
16:45:51 <Hijiri> It's just a convenient way to refer to Int
16:45:57 <David> and I want to add another traversal that uses the [Tree] as well
16:46:00 <benmachine> I think it's sometimes the case that people use the State monad when they don't really need it
16:46:03 <nitrix> Hijiri: Okay, but then, why is it an Int ?
16:46:09 <benmachine> especially when they don't really need a value, and just want to update the state
16:46:25 <dfsfsfsf> benmachine: what would you use instead?
16:46:31 <Hijiri> You feed the String to the playGame, the string represents the game
16:46:42 <benmachine> dfsfsfsf: just chaining composition of functions
16:46:44 <Hijiri> and then it does some operations recursively on it
16:46:46 <benmachine> that update the state
16:46:50 <Hijiri> GameValue is Int
16:46:51 <nitrix> Hijiri: Correct. This update the GameState.
16:46:56 <benmachine> you only need State when you need to update state while also producing a value
16:47:01 <nitrix> Hijiri: What's GameValue for?
16:47:09 <Hijiri> The score
16:47:14 <Hijiri> If you look at the base case, it has return score
16:47:28 <Hijiri> GameValue is just Int with a different name
16:47:34 <nitrix> The score's supposed to be (_, score) of the GameState.
16:47:39 <dfsfsfsf> benmachine: I haven't seen the beginning of the discussion, but isn't the state monad convenient in a sense that it hides the plumbing?
16:48:00 <Hijiri> That's GameState
16:48:09 <nitrix> OHHH
16:48:14 <benmachine> dfsfsfsf: you only need plumbing if you have got both a state and a value, really
16:48:16 <Fuuzetsu> why is there Data.Text.Internal.Builder and Data.Text.Lazy.Builder and Data.Text.Lazy.Internal.Builder but no Data.Text.Builder?
16:48:17 <nitrix> Oh gosh, I get it now.
16:48:54 <benmachine> dfsfsfsf: otherwise the "plumbing" is simple, it's just lots of .s :)
16:49:07 <dfsfsfsf> benmachine: :)
16:49:39 <nitrix> So this function returns a `State GameState GameValue`. I suppose one would have to extract that value after?
16:49:48 <nitrix> evalState?
16:49:53 <Hijiri> Yes, you have to give it an initial state
16:50:02 <nitrix> Bingo.
16:50:07 <nitrix> I get it now :D
16:50:15 <Hijiri> StateGameState GameValue says that this value is a stateful computation that uses GameState to keep state, and the result is a GameValue
16:50:16 <Hijiri> alright
16:50:31 <nitrix> That's such a hack using the type system...
16:52:19 <Fuuzetsu> How is it a hack?
16:52:33 <Fuuzetsu> even more, how is it a hack using the type system?
16:55:51 <tabemann> I too don't see how it's a hack
16:56:04 <Martty> soo.. OT, but is this evidence that my ISP is throttling? i.imgur.com/ZTKKNuc.png
16:56:10 <Martty> ups
16:56:12 <Martty> http://i.imgur.com/ZTKKNuc.png
16:58:16 <kadoban> Martty: I doubt it's good evidence
16:58:33 <Fuuzetsu> wrong channel for this
16:58:45 <Martty> idk where else i could discuss this
16:59:03 <kadoban> Martty: Seems like a lot of things could be going on there, most simply....what exactly is tcping measuring? Probably the time to do a 3-way handshake or something
17:02:23 <geekosaur> Martty, #haskell-blah? #freenode maybe?
17:03:02 <joelteon> any networking-related channel?
17:03:15 <joelteon> i don't think a person unfamiliar with haskell would see networking issues and think, "maybe I should ask #haskell what's going on"
17:03:41 <pharaun> is there a good example of FreeT + State ? because
17:03:51 <pharaun> its giving me a massive headache and i can't figure out the types at all
17:04:19 <Martty> kadoban: i think so, or any of the round trip exchanges on a tcp session beginning
17:05:08 <geekosaur> it doesn't necessarily indicate anything useful, in any case; most commercial routers handle ICMP and TCP completely differently
17:05:22 <geekosaur> without any choice being made by the owner of said routers
17:06:13 <dfsfsfsf> pharaun: could you paste some code?
17:07:20 <dfsfsfsf> pharaun: have you tried using a dummy type to get some help from the typechecker?
17:07:31 <Martty> geekosaur: regularly there's no such big discrepancy in ping times. is there any other way to find out if there's throttling going on?
17:07:37 <pharaun> i am not familiar with dummy types, i usually comment it out then work incrementally
17:07:41 <pharaun> but this point i'm stuck
17:07:45 <pharaun> http://lpaste.net/111009
17:07:55 <pharaun> because it will end up generating types that makes no bloody sense to me
17:08:10 <pharaun> if i get rid of (State String) and replace it with []
17:08:11 <pharaun> it works
17:08:16 <pharaun> but i want to have state :|
17:08:29 <dfsfsfsf> pharaun: lpaste doesn't work for me.  could you repaste to dpaste.com?
17:08:57 <pharaun> http://dpaste.com/2HDY3PW
17:09:10 <dfsfsfsf> pharaun: re "dummy type": I mean create a type like 'data Hole' and use it in the type signature.
17:09:23 <geekosaur> Martty, for one, compare mtr or traceroute output in various modes. this will (a) tell you which hop is incurring any delay, and (b) show a little more precisely whether the issue is related to a certain packet type; but you really need more networking experience to understand what it's telling you. (for the record, I am rather borderline on that level of experience myself)
17:09:36 <geekosaur> you should really consult a channel related to networking/routing
17:09:48 <Martty> k thanks
17:10:24 <geekosaur> that is, I can usually figure out simple ones, but more complex networks I consult an expert
17:11:41 <geekosaur> you might ask in #lopsa (sysadmin channel) if anyone's around who can help. there's also a reddit-affiliated sysadmin channel somewhere (used to be ##/r/sysadmin, I think they moved)
17:12:19 <dfsfsfsf> pharaun: installing 'free'
17:16:08 <pharaun> http://www.haskellforall.com/2012/07/free-monad-transformers.html
17:16:10 <pharaun> inspired by ^
17:16:21 <pharaun> but frustrated cos it never shows an interpreter
17:16:57 <pharaun> doSomething :: FreeT BaseF (State s) ()
17:18:59 <Cale> pharaun: hmm, what's up?
17:19:19 <pharaun> just types blowing my head off :)
17:19:33 <pharaun> Cale: i'm trying to get a freeT transformer stack to work with state
17:20:01 <pharaun> so that i can have state in my free monad, i was able to make several useful interpreter using the free monad or FreeT (Segment String) [] approach
17:20:06 <pharaun> but when i bring in state it explodes
17:20:13 <pharaun> http://dpaste.com/2HDY3PW
17:20:18 <pharaun> and i'm having hard time figuring it out
17:20:41 <dfsfsfsf> Cale: note that you'll need {-# LANGUAGE GADTs, DeriveFunctor, StandaloneDeriving #-}
17:20:53 <pharaun> oh sorry, forgot to include that into the code sample :)
17:21:00 <JRC12> what is the definition of data in categorical sense? Is it an F-algebra?
17:21:02 <dfsfsfsf> and several imports: import Control.Monad; import Control.Monad.Trans.State.Lazy; import Control.Monad.Trans.Class; import Control.Monad.Trans.Free
17:22:36 <dfsfsfsf> pharaun: hmm, I'm getting more errors than you
17:22:47 <dfsfsfsf> from the typechecker, I mean
17:23:04 <dfsfsfsf> No instance for (Show (String -> Maybe a)), for instance
17:23:08 <pharaun> i guess i can just dump the whole file into a gist
17:23:14 <pharaun> i just wanted to show the relevant snippet
17:23:18 <dfsfsfsf> yes, that would be better
17:24:17 <Cale> pharaun: Okay, let me paste what I have, so that we can deal with the real type errors
17:24:37 <lpaste_> Cale pasted “pharaun” at http://lpaste.net/111010
17:24:59 <lpaste_> Cale annotated “pharaun” with “pharaun (annotation)” at http://lpaste.net/111010#a111011
17:25:43 <dfsfsfsf> pharaun: since Cale is helping (who has much more experience), I'll go back to my own problems.
17:25:43 <Cale> The first error is that runAllRoute is supposed to produce a list as its result, but you have a do-block there with an action that is clearly not a list.
17:26:08 <pharaun> because of the runFreeT
17:26:14 <Cale> yes
17:26:19 <pharaun> hold on
17:26:37 <pharaun> my head is hurting, let me get a smaller example and nuke this charliefox
17:27:06 <charlie> hi
17:27:14 <pharaun> charlie: sorry :)
17:27:23 <charlie> it okei
17:34:13 <pharaun> argh, going to take a bit more
17:34:15 <pharaun> its not working now
17:42:44 <pharaun> great
17:42:54 <pharaun> i can't get the minimal reproduce to even work with what i had previously
17:42:58 <pharaun> this is going to take a while
17:43:11 <jle`> :t 3.1
17:43:12 <lambdabot> Fractional a => a
17:43:14 <jle`> :t 3 . 1
17:43:15 <lambdabot> (Num (a -> b), Num (b -> c)) => a -> c
17:44:13 <nshepperd> pharaun: `runFreeT f` returns a State String (FreeF ...)
17:44:24 <pharaun> ?
17:44:37 <pharaun> i'm not sure i get what you're trying to say :(
17:44:38 <jle`> :t 1.2.3.4
17:44:39 <lambdabot> (Fractional (a -> b), Fractional (b -> c)) => a -> c
17:44:53 <nshepperd> pharaun: type Route a = FreeT (Segment String) (State String) a
17:45:01 <pharaun> i'm reather frustrated right now i'm trying to get an minimal example to work
17:45:17 <pharaun> i had one with - FreeT (Segment String) [] a - working
17:45:24 <pharaun> but i wanted to move over from [] to State
17:46:45 <nshepperd> hmm, I'm not sure if State is useful here, because you are branching
17:47:00 <pharaun> http://lpaste.net/111012
17:47:04 <pharaun> this does not work ^%
17:47:13 <pharaun> but it type checks, but no matter what route i give it always returns a []
17:47:38 <pharaun> i feel like i just want to throw this free monad stuff into a trashbin and go back to an plain old ADT and give up >_<
17:48:13 <pharaun> nshepperd: what i'm trying to do here is i'm trying to use Free monad to build a "routing" DSL that lets me accumulate a list of all results (ie it doesn't exit on first match) it executes all matches
17:48:45 <pharaun> and i want to bring in some sort of state, so that each route handler can have its own state (ie a database connection for ex) that i'll existional out so its transparent to the route thingie
17:49:19 <pharaun> inspired and took a modified version of - http://happstack.com/page/view-page-slug/16/comparison-of-4-approaches-to-implementing-url-routing-combinators-including-the-free-and-operational-monads - #3
17:51:37 <nshepperd> ohh right
17:51:46 <pharaun> nshepperd: on branching, basically what i wanted to do was "provide" a state for each route-handler so that each route handler can have its own state
17:51:58 <pharaun> the interpreter is supposed to take care of re-wrapping it and hiding it away
17:52:35 <pharaun> somehow i feel like i'm way over my head here and a simpler solution would work better? but i'm kinda stuck because the Free approach seems like a really neat way of doing it
17:54:00 <nshepperd> well, your runAllRoute needs to be in the same monad as the base monad in Route
17:54:13 <Guest93974> > 5 5
17:54:14 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> t))
17:54:14 <lambdabot>    arising from the ambiguity check for ‘e_155’
17:54:14 <lambdabot>  from the context (GHC.Num.Num (a -> t), GHC.Num.Num a)
17:54:14 <lambdabot>    bound by the inferred type for ‘e_155’:
17:54:14 <lambdabot>               (GHC.Num.Num (a -> t), GHC.Num.Num a) => t
17:54:36 <pharaun> nshepperd: how would i do that, every time i try to shift that function out of say [] base monad everything goes all weird
17:54:43 <pharaun> so i keep on getting stuck on it
17:55:05 <nshepperd> eg. for the really lame example of routing handlers that log messages to the console,
17:55:16 <nshepperd> type Route a = FreeT (Segment String) IO a
17:55:18 <pharaun> ie i end up losing the ability to be flexible on the output [a], ie i have a debugging version i want to have (Doc, [a]) where i can document/log it
17:55:21 <pharaun> nshepperd: yup
17:55:26 <pharaun> i want to be able to do that
17:55:29 <Cale> pharaun: Well, your runAllRoute is explicitly producing lists in various cases, that can't be right.
17:55:29 <nshepperd> runAllRoute :: Route a -> [String] -> IO [a]
17:55:45 <pharaun> but i wanted to take it one step at a time and just move from a list monad to state monad then stateT
17:55:51 <jle`> huh i didn't realize that MonadPlus was one of the typeclasses that "propgates up" a Monad Transformer in transformers/mtl
17:56:05 <Cale> pharaun: Just figure out which monad has the stuff that you need, and use that
17:56:09 <jle`> i wonder if people actually use that
17:56:14 <jle`> and i wonder if it could ever go wrong
17:56:15 <pharaun> Cale: yup, because i want *all* matches
17:56:17 <pharaun> not just the first one
17:56:49 <pharaun> most routing stops when it gets/complete the first match, i want to keep going till i have exhausted the routing tree
17:56:52 <srhb> So I'm defining a Monad instance for Foo.. And I'm wondering about fail, which is obviously horrible
17:57:12 <jle`> what are you wondering? :)
17:57:16 <Cale> srhb: Typically people just define fail = error
17:57:16 <pharaun> Cale: what do you mean?
17:57:24 <srhb> but can I make it less horrible? My problem is that it has type String -> Foo a. And I can't see how I can generate a Foo a without using undefined / error
17:57:28 <Cale> srhb: Or leave it out of the definition, which is the same
17:57:31 <nshepperd> pharaun: note, you haven't actually been using the list base monad in 'type Route a = FreeT (Segment String) [] a' in your working example
17:57:52 <srhb> Because it's sort of ex nihilo
17:57:57 <pharaun> Cale: basically i wanted to do a freeT to build up the route dsl, then state to present each handler with its own private state environment, then have the final monad be (whatever the handler wants it to be)
17:58:03 <pharaun> probably IO
17:58:04 <Cale> srhb: fail isn't really part of the definition of a monad
17:58:11 <srhb> Yeah. Meh.
17:58:23 <jle`> yeah i usually just leave the default implementation
17:58:25 <pharaun> nshepperd: oh?
17:58:25 <srhb> I just feel bad leaving it using error, but I guess there's no way around it.
17:58:28 <nshepperd> pharaun: because all your "match, capture, choice, zero" definitions used liftF which just puts the free monad piece in a singleton list
17:58:37 <Cale> srhb: It was a mistake of the specification to include it as such
17:58:41 <pharaun> then i'm even more confused >_<
17:58:41 <srhb> Indeed.
17:58:52 <jle`> do you think people are going to use your fail?
17:58:55 <Cale> srhb: Hopefully edwardk and the rest of the libraries team will eventually sort that out :)
17:58:59 <pharaun> nshepperd: so i'm not even using the [] monad at all?
17:59:06 <srhb> Well, isn't fail called if a pattern match fails in a do block?
17:59:39 <Cale> srhb: yes
18:00:07 <srhb> I guess I could wrap my Monad in Either somehow. Then fail s = Left s :: Either String (Foo a)
18:00:12 <jle`> @undo do { Just x <- f; return x }
18:00:12 <lambdabot> f >>= \ a -> case a of { Just x -> return x; _ -> fail ""}
18:00:13 <Cale> srhb: If and only if the pattern match is failable
18:00:18 <srhb> (Well, ErrorT could do.)
18:00:27 <pharaun> nshepperd: https://github.com/pharaun/Karmator/blob/ircbot/src/DynTest.hs#L228-L284
18:00:31 <pharaun> this is the old *working* example
18:00:32 <srhb> Cale: Indeed.
18:00:34 <pharaun> with the base Free monad
18:00:40 <jle`> srhb: almost every Monad instance has an exception, so it's not like people aren't going to expect it
18:00:50 <srhb> Right. :) I'll stop worrying about it.
18:00:50 <Cale> srhb: So if they eventually move fail into its own type class, you'll just get an additional constraint when the pattern possibly fails
18:00:54 <srhb> Ish.
18:00:55 <pharaun> the case version on lpaste is what happened when i tried to move out of Free to FreeT so i can build a monad transformer stack
18:01:15 <pharaun> i want to replace the Get/Set in my old version with the state monad
18:02:08 <Cale> pharaun: Any particular reason why you want to do that?
18:02:23 <Cale> pharaun: I guess it might simplify the interpreter?
18:03:14 <Cale> Also, you should strongly consider making this a newtype, rather than a type synonym
18:03:17 <pharaun> Cale: basically i wanted to use free monad to create the route tree, then i wanted to present a state monad to the handler so that they can set/get an state, that i can then ExistentialQuantification to hold onto it (ie database connection for example)
18:03:39 <Cale> I don't like the fact that I'm using monad transformers to be visible through the module boundary
18:03:53 <jle`> to be honest i don't really see the advantage of Free over just manually defining an ADT
18:04:07 <Cale> jle`: You automatically get a monad instance.
18:04:12 <pharaun> ^
18:04:27 <jle`> yes, but if you want to eventually do something with it, you need to do the same amount of work
18:04:29 <Cale> If you know about MonadPrompt, it's basically the same thing
18:04:36 <Cale> hm?
18:04:38 <pharaun> if i have to i can probably go back to ADT, but i just like how it gives me an instance for free
18:04:41 <Cale> Not quite!
18:05:01 <jle`> if you want to do something with your Monad eventually (presumably because you have it in the first place), wouldn't you need to define collapsers eventually anyway?
18:05:16 <Cale> You only have to define interpretations for the constructors, you don't have to define interpretations for bind and return
18:05:23 <Cale> (and possibly screw them up)
18:05:27 <jle`> i see
18:05:34 <jle`> so your instance is automatically lawful
18:05:38 <Cale> yes
18:05:43 <pharaun> <- will screw everything up
18:05:54 <pharaun> so that's why i want to make the freeT approach work
18:06:21 <pharaun> somehow i still feel like i am approaching this wrong
18:06:46 <jle`> i can't think of a use case for Free where you have less work needed to be done for the final usage of your type, though...but i can see the benefit in safety and less thinking
18:07:14 <Cale> jle`: It can also be very convenient if you have multiple interpretations
18:07:17 <jle`> it's a little more beautiful, i guess...you don't have to pollute your ADT with the concept of Return if you don't need to
18:07:22 <jle`> Cale: ah, i see
18:07:24 <pharaun> i have 2 interpreter
18:07:27 <jle`> hm.
18:07:40 <pharaun> a debug one that outputs the result of the routing, and a "production" one that just computes them
18:08:16 <jle`> i see.  you can defer interpretation, from the point of (>>=)
18:08:34 <jle`> hm.
18:08:54 <Cale> Yeah, and to write an interpreter, you just need to say how each of the constructors of this chosen type gets interpreted
18:09:01 <jle`> i still feel like you can do the same w/out Free, but these are probably vague half valid intuitions
18:09:03 <lpaste_> nshepperd annotated “No title” with “IO Example” at http://lpaste.net/111012#a111015
18:09:15 <jle`> i can definitely see the elegance of it though
18:09:18 <Cale> I somehow still kinda prefer MonadPrompt
18:09:23 <jle`> and the separation of concerns, at least, at this point
18:09:25 <Cale> It's basically the same thing
18:09:28 <jle`> i've been meaning to give Operational a look over
18:09:31 <nshepperd> pharaun: see my annotaton
18:09:47 <Cale> But rearranged slightly to make it easier to specify the interpreter
18:10:04 <Cale> http://hackage.haskell.org/package/MonadPrompt-1.0.0.3/docs/Control-Monad-Prompt.html
18:10:26 <nshepperd> pharaun: I didn't actually make it do any debugging output yet...
18:10:44 <jle`> ic
18:10:46 <jle`> ty
18:10:46 <pharaun> i wonder if applicative would be more of what i want
18:12:16 <Cale> jle`: Here's an example I actually wrote the other day: http://lpaste.net/110885
18:13:26 <Cale> jle`: Someone was curious how you might implement a monad like ST without special compiler support. Here you can represent the computations available in ST and interpret them separately.
18:13:26 <pharaun> nshepperd: im looking into it now
18:13:41 <jle`> thanks :D
18:13:47 <jle`> oh that's interesting
18:17:08 <Cale> pharaun: You also might like to look at this example to see if you like that sort of style better than the one offered by Free
18:17:19 <pharaun> Cale: yeah i am looking at it
18:17:35 <Cale> There's a transformer version of Prompt as well
18:18:21 <Cale> Where in order to interpret, you just need to additionally provide a handler for lifted computations, alongside the one for prompts.
18:19:37 <Cale> hm, I should write runPromptTM and add it there :)
18:19:48 <pharaun> looks like it would be good for me to implement a prompt solution and see how it compares up
18:21:16 <edwardk> Cale: we are planning to determine the strategy before 7.10 ships (probably just splitting Monad into Monad and MonadFail) figure out how to put in the warnings about it in 7.10 and make whatever change it is happen in 7.12
18:21:31 <Cale> edwardk: cool :)
18:21:40 <edwardk> Cale: the fact that lennart has already done the Monad -> Monad + MonadFail split in his own compiler speaks strongly to just doing it his way
18:22:25 <edwardk> the reason we want to punt on 7.10 is that we're trying to make as many of the changes for 7.10 as possible be defineable without using CPP, lest folks see all changes as painful ;)
18:22:51 <pharaun> nshepperd: thanks a bunch that's helpful
18:22:56 <edwardk> we've already failed on a couple of minute operations (expm1, etc), but the vast majority of the changes should be able to be worked around without CPP
18:23:10 <edwardk> the Monad -> MonadFail thing won't go as cleanly
18:23:47 <lpaste_> Cale pasted “useful variant of runPromptT” at http://lpaste.net/111016
18:24:15 <DanielDiaz> can I make Hackage to retry building a package?
18:24:23 <Cale> pharaun: ^^ you might like that in order to get a similar style to the one I showed in my example
18:24:31 <Cale> (when using PromptT)
18:25:08 <Cale> I wonder if I'm allowed to upload a new version of MonadPrompt...
18:25:16 <Cale> I guess not
18:25:34 <Cale> I uploaded one of the previous versions...
18:28:44 <pharaun> Cale: nshepperd thanks btw really helpful :)
18:31:54 <lpaste_> Cale revised “useful variant of runPromptT”: “No title” at http://lpaste.net/111016
18:32:00 <trap_exit> yo, so <$> looks all scary and sh*t ... then I read that <$> = fmap ... and I'm like wtf ... so basically (<$>) = fmap, <$> = `fmap` .... is that it?
18:32:09 <Cale> yes
18:32:18 <trap_exit> wow
18:32:21 <Cale> I don't understand why it looks scary
18:32:26 <trap_exit> I feel smart now that I know what the types for pure, <$>, and <*> are
18:32:30 <Cale> :)
18:32:36 <trap_exit> well, it looks scary because the first time I saw it, it was buried half way in some Aeson tutorial
18:32:40 <nshepperd> pharaun: also I figured out why it was returning no output, I think
18:32:50 <trap_exit> which was like "this is f*cking complicated monad magic; and we're going to use <$>, <*>, and ..."
18:32:53 <trap_exit> and I was like whoa, this is hard
18:32:56 <trap_exit> then I read LYSE, and it's obvious
18:33:06 <trap_exit> long story short: read LYSE, Aeson tutorials should be rewritten
18:33:24 <pharaun> nshepperd: neat :D
18:33:41 <nshepperd> pharaun: because "runAllRoute _ [] = return []" throws away your 'return $ "You are looking at /foo/" ++ show (i :: Int)' due to being at the end of the input :)
18:34:03 <pharaun> >_<
18:34:22 <arbn> trap_exit: What is LYSE?
18:34:34 <pharaun> learn you some... ?
18:34:59 <srhb> Erlang?
18:34:59 <trap_exit> learn you some erlang for great good
18:35:04 <trap_exit> hmm, maybe I meant LYSH
18:35:10 <arbn> LYAH?
18:35:10 <pharaun> yes :)
18:35:12 <pharaun> LYAH
18:35:18 <trap_exit> right, PYAH
18:35:21 <srhb> :D
18:35:22 <trap_exit> *LYAH*
18:35:28 <srhb> *pat*
18:35:37 <trap_exit> PYAH = Program You A Haskell from scratch for great good!
18:35:44 <srhb> Ouch!
18:35:48 <srhb> That sounds like hard work.
18:36:30 <lpaste_> nshepperd revised “IO Example”: “No title” at http://lpaste.net/111015
18:37:03 <pharaun> haha doh
18:37:42 <Cale> Oh, cool, I *can* upload a new one :)
18:37:59 <arbn> trap_exit: Don't let the symbols scare you. I forget operator symbols all the time, so I just look up the type with Hoogle or GHCi.
18:38:13 <solatis> i thought that programming a LISP was the status quo ? :)
18:38:47 <nshepperd> pharaun: that's what I was playing with to try and make log messages work :D
18:39:01 <nshepperd> free monads are good fun
18:39:50 <trap_exit> arbn: it's not eh symbols the scares me, it's the context that frightened me
18:40:23 <trap_exit> arbn: it's like learning how to pull a rope on the ground vs after jumping out of a plane
18:40:34 <trap_exit> basically, learning new libraries = bad time for learning new haskell concepts
18:40:53 <nshepperd> I am not sure if you want to expand Choice nodes at the end of input
18:41:05 <pharaun> nshepperd: what do you mean?
18:41:24 <pharaun> as in backtracking?
18:41:34 <pharaun> to try out all matches? yeah that's what i wanted
18:42:03 <arbn> trap_exit: The types can help you use libraries without understanding the concepts, though. Like, I used that big XML library that's built around arrows for some project, and still don't really know much about arrows.
18:42:11 * hackagebot MonadPrompt 1.0.0.4 - MonadPrompt, implementation & examples  http://hackage.haskell.org/package/MonadPrompt-1.0.0.4 (CaleGibbard)
18:42:22 <nshepperd> pharaun: I mean the way I currently defined 'runAllRoute f []' it only returns output if the result is a Pure
18:43:30 <nshepperd> it maybe makes sense for a route handler to do a choice [a, b, c] when all input has been consumed
18:44:17 <pharaun> yeah, i was using a [] for testing, but in the end the [String] -> big record
18:44:34 <pharaun> hence no real way to check that "all" fields has been checked and probably not even desirable
18:45:06 <pharaun> I'm working on a more refined version now, the IO version you put up has realy helped make where i screwed up clearer :)
18:46:39 <nshepperd> I think IO is nice for an example monad, because you can never confuse it for something else
18:46:47 <pharaun> that's a good point :D
18:47:12 * hackagebot MonadPrompt 1.0.0.5 - MonadPrompt, implementation & examples  http://hackage.haskell.org/package/MonadPrompt-1.0.0.5 (CaleGibbard)
18:47:12 <pharaun> i do wonder tho, how i can make it so that each "pure/handler" gets its own custom state environment tho, hm
18:47:34 <pharaun> to stand to reason i would need to somehow identify which handler gets which state environment
18:49:03 <pharaun> > data FreeF f a b = Pure a | Free (f b)
18:49:04 <lambdabot>  <hint>:1:1: parse error on input ‘data’
18:49:08 <trap_exit> (++) <$> ["a", "b"] <*> ["1", "2"] <-- is this ( (++) <$> ["a", "b"] ) <*> ["1", "2"]   or (++) <$> ( ["a", "b"] <*> ["1", "2"] )
18:49:28 <FreeFull> trap_exit: The former
18:49:45 <trap_exit> this confuses me
18:49:47 <pharaun> ah that's awkward
18:49:51 <trap_exit> $ generally means ( ... rest of the ine .... )
18:49:57 <trap_exit> but <$> seems to be "weaker" than <*>
18:50:07 <FreeFull> trap_exit: <$> means fmap
18:50:19 <trap_exit> right, but $ generally binds the rest of the line in ()
18:50:22 <pharaun> i was hoping to have pure to have different type compared to the Free (f b)
18:50:31 <trap_exit> I would have expected <$> to put "the rest of the line" in a fmap
18:50:43 <FreeFull> > [("1" ++),("5" ++)] <*> ["a", "b"]
18:50:44 <lambdabot>  ["1a","1b","5a","5b"]
18:51:14 <trap_exit> I have no idea what what you just did proves
18:51:18 <FreeFull> <*> is  f (a -> b) -> f a -> f b
18:52:59 <trap_exit> yeah
18:53:15 <trap_exit> but I find it weird that "a <$> b <*> c" ends up being "(a <$> b) <*> c"
18:53:19 <nshepperd> <$> needs have high priority so that function application can work the same as 'normally'
18:53:31 <benzrf> fmap should really be ($>)
18:53:39 <dibblego> all haskell functions take one argument, always
18:54:00 <merijn> trap_exit: What's weird about it?
18:54:08 <dibblego> that is why (++) <$>  works out
18:54:22 <trap_exit> hmm
18:54:23 <nshepperd> eg. (+) <$> pure 1 <*> pure 2 = pure (1+) <*> pure 2 = pure (1+2)
18:54:33 <trap_exit> is it just me or ... given the meaning of $, <$> seems like a horrible name for fmap ?
18:54:34 <dibblego> (<$>) :: (a -> b) -> f        a -> f        b
18:54:43 <dibblego> (<$>) :: (a -> b) -> ((->) t) a -> ((->) t) b
18:54:46 <FreeFull> trap_exit: With   a <*> b, if a isn't a functor of functions, the signature doesn't work out
18:54:51 <trap_exit> a $ b * c --> a ( b * c)
18:55:00 <dibblego> trap_exit: (<$>) is exactly like ($) but with an environment threaded through
18:55:01 <trap_exit> a <$> b <*> c --> (a <$> b) <*> c
18:55:12 <prophile> usual controversial opinion: rename fmap to (.) :)
18:55:38 <dibblego> ($)   :: (a -> b) ->   a ->   b
18:55:38 <dibblego> (<$>) :: (a -> b) -> f a -> f b
18:55:39 <FreeFull> I think lambdabot does that
18:55:41 <FreeFull> :t (.)
18:55:42 <lambdabot> (b -> c) -> (a -> b) -> a -> c
18:55:44 <FreeFull> Nope
18:55:52 <trap_exit> does "a $ b * c ==> a ( b * c) " and "a <$> b <*> c ==> (a <$> b) <*> c" NOT bother anyone else?
18:55:54 <trap_exit> I find this weird
18:56:05 <nshepperd> it is weird, I guess
18:56:14 <FreeFull> It's the only way it can work
18:56:22 <dibblego> yes the fixity of ($) bothers a lot of people
18:56:23 <trap_exit> :t ($)
18:56:24 <lambdabot> (a -> b) -> a -> b
18:56:26 <geekosaur> lambdabot used to at one point
18:56:30 <nshepperd> but there's not usually any reason to do "a <$> (b <*> c)"
18:56:36 <geekosaur> it was unpopular and eventually went away
18:56:53 <trap_exit> yeah, but it screw sup the mental pattern of "I see a $ ... rest of line is one arg"
18:57:03 <trap_exit> now it's like "I see a <$> ... I read until the next <*> "
18:57:32 <dibblego> this will not work
18:57:35 <merijn> prophile: Better yet
18:57:42 <dibblego> (<$>) is just infix fmap, you can't use that rule
18:57:44 <merijn> prophile: rename (.) to Control.Category..
18:57:52 <FreeFull> geekosaur: I haven't really been active in here for a while, as you can tell
18:57:53 <dibblego> it may not even appear with (<*>) for example
18:58:11 <merijn> :t (Control.Category..)
18:58:12 <lambdabot> Category cat => cat b c -> cat a b -> cat a c
18:58:14 <nshepperd> you can use "pure f <*> a <*> b" if you prefer :p
18:58:28 <dibblego> or, liftA2 f a b
18:58:46 <trap_exit> hmm, is the mental model: when I see "a <$> b", do a _syntatctical repalcement_ to "pure a <*> b" ?
18:58:49 <trap_exit> that rule I can memorize
18:58:51 <dibblego> or, liftF2 f a b for a more precise generalisation
18:59:06 <dibblego> I would spend effort on remembering the rules of haskell, then how to use the tools
18:59:11 <merijn> trap_exit: Or "a <$> b" "fmap a b"
18:59:21 <prophile> come the glorious applicative do extension you can have [f a' b' | a' <- a, b' <- b] which is clearly much prettier
18:59:27 <dibblego> imagine a new operator is invented, are you going to invent a new rule? no, just learn ho to use e.g. :info
19:00:46 <dibblego> also, if you come up with a new rule for every operator, you might end up writing a silly blog post about Control.Lens
19:00:54 <prophile> :D
19:01:22 <nshepperd> hmm, what's the fixity of an infixified function like `fmap`?
19:01:36 <geekosaur> :info shows it
19:01:38 <merijn> nshepperd: You can specify fixity for functions
19:01:49 <geekosaur> the infix{,l,r} keywords can set it
19:01:54 <dibblego> i.e. the process by which one learns how to use, in this case, operators, needs revision  tools support how to use operators (e.g. :info), not mental models for each operator (though, mental models may come about from the tools e.g. Control.Lens follows some rules to support mental models), because when those mental models break, you want to go back to first principles (tools)
19:02:18 <dibblego> nshepperd: imagine I didn't know the answer, how would I find out? I would use :info ($)
19:02:18 <merijn> :t let x `f` y = x + y; infixl 4 `f` in f
19:02:19 <lambdabot> Num a => a -> a -> a
19:02:29 <dibblego> or :info (<$>) for that
19:02:31 <solatis> Fuuzetsu: a million thanks about nixos. this is what i want my distrobution to be like. it must be the os as the gods intended it to be. :p
19:02:32 <fresheyeball> hey folks
19:02:43 <fresheyeball> I need some help
19:02:46 <nshepperd> :info doesn't show any fixity for :info `map`
19:02:47 <benzrf> hey fresheyeball
19:02:52 <benzrf> fresheyeball: whats up
19:02:53 <nshepperd> is there a default?
19:02:58 <dibblego> oh you mean actual map, it doesn't have a fixity
19:02:58 <merijn> nshepperd: Yes, infixl 9
19:03:02 <dibblego> yes
19:03:04 <fresheyeball> is it possible to have a recursive function type signature?
19:03:17 <nshepperd> right
19:03:22 <dibblego> fresheyeball: do you have a type error regarding infinite types?
19:03:28 <Fuuzetsu> solatis: glad you managed to get it going with your Cambodian Internet
19:03:45 <fresheyeball> something like that
19:03:56 <fresheyeball> I get an error saying that my generic type must be specific
19:04:03 <dibblego> fresheyeball: it might be best to figure out why you have a type error
19:04:18 <fresheyeball> its like this sort of
19:04:25 <fresheyeball> a -> b -> c
19:04:27 <fresheyeball> error
19:04:41 <fresheyeball> cannot unify (a -> b -> c) with b
19:04:48 <fresheyeball> so I write
19:04:58 <fresheyeball> a -> (a -> b -> c) -> c
19:04:59 <dibblego> fresheyeball: do you have a small test case code that you can paste to hpaste.org so that we can try to work out why you have a type error?
19:05:02 <fresheyeball> and get the same error
19:05:13 <theshado_> For the following gist, I understand what this function does but I took a break from learning haskell and I've forgotten one bit of syntax. On line 3 the ':' is literally doing what? Is it a 'then' 'also'. https://gist.github.com/theshadow/436a3004b5d4211ec318
19:05:14 <fresheyeball> well to be honest
19:05:16 <Fuuzetsu> I suspect you can't do what you're asking for
19:05:20 <fresheyeball> I am in purescript not haskell
19:05:33 <fresheyeball> you still want a paste?
19:05:40 <dibblego> fresheyeball: maybe port the test case to haskell so you can try working it out
19:05:44 <dibblego> sure
19:05:45 <fresheyeball> ok
19:06:09 <merijn> theshado_: : is the list constructor
19:06:18 <dibblego> theshado_: here is a tip, there is a tool which you might call "what on earth is?" and it is spelled like this :info
19:06:22 <merijn> theshado_: (1:2:3:[]) == [1,2,3]
19:06:31 <theshado_> oh
19:06:31 <dibblego> theshado_: so, in this case, your question is, "what on earth is (:)?"
19:06:33 <theshado_> I get it
19:06:38 <dibblego> theshado_: so let's type that to ghci
19:07:12 <theshado_> dibblego: good to know thanks
19:07:15 <fresheyeball> http://lpaste.net/111020
19:07:47 <fresheyeball> there are some nuances between haskell's type system and purescripts
19:07:54 <fresheyeball> but they are extremely similar
19:08:34 <Fuuzetsu> theshadow: just so it's clear, you're creating a new list, it is not changing x nor xs, it's not ‘change x then change xs’ like you were thinking, it's ‘create new thing and join it with the rest of new things’
19:09:15 <theshadow> Yep I get it f x is the head and map f xs is creating the tail
19:09:31 <theshadow> It makes so much more sense now
19:11:03 <solatis> Fuuzetsu: yeah i let nixos-rebuild running all night @ 30kb/sec, and was glad to wake up in the morning with a fresh generation :)
19:11:16 <fresheyeball> actually I can't translate this problem into haskell
19:11:31 <fresheyeball> haskell does not have extensible records
19:11:34 <solatis> it's funny how nixos is so elegant, but on the low level it's only c++ and perl -- reminds me of the LISP xkcd comic :)
19:11:43 <Fuuzetsu> fresheyeball: vinyl can provide those
19:11:53 <fresheyeball> ok
19:11:57 <merijn> Fuuzetsu: Oh? Tell me more about vinyl :)
19:12:12 <solatis> https://xkcd.com/224/
19:12:13 <fresheyeball> but I am in purescript and don't know vinyl
19:12:13 <Fuuzetsu> it does stuff and it's great
19:12:42 <Fuuzetsu> solatis: it's not funny when you need to look at the low level ;(
19:12:51 <merijn> Fuuzetsu: Any links to tutorials, the docs don't say a lot :\
19:12:54 <Fuuzetsu> luckily there are Haskell ports under way ;)
19:13:09 <solatis> Fuuzetsu: i know, that's why i referenced the XKCD comic :)
19:13:19 <merijn> oh, it's just taking the heterogeneous list approach :(
19:13:21 <arbn> solatis: That's a little unkind to all the C++ programmers in the world. :P Of course you can write nice and elegant software in C++.
19:13:31 <merijn> That's no good :\
19:13:46 <Fuuzetsu> merijn: yes, more or less, there is a recent talk by jonsterling which might interest you
19:13:54 <Fuuzetsu> AFAIK he's experimenting with stuff
19:13:58 <solatis> arbn: i know, i'm actually a c++ veteran myself :)
19:14:14 <Hodapp> arbn: I'm not convinced you can...
19:14:20 <solatis> it's amazing what you can achieve with TMP
19:14:34 <carter> solatis: a summer learning c/c++ is what drove me to discover stuff like scheme and haskell
19:14:35 <merijn> Fuuzetsu: Yeah, but I already came up with the same, but that means O(n) indexing for fields, which is not acceptable for me :)
19:14:43 <fresheyeball> I feel like my problem should be understandable even if its not haskell proper
19:14:53 <fresheyeball> can anyone help me?
19:15:01 <fresheyeball> recursive type signature is new to me as a problem
19:15:04 <merijn> carter: Shouldn't you be sleeping ;)
19:15:21 <carter> merijn: i definitely shouldn't be tryingt to learn concurrent datastructures
19:15:23 <arbn> fresheyeball: Is there a purescript channel somewhere you can ask in?
19:15:28 <solatis> of course you cannot sleep when discussing c++, it's a recipe for nightmares
19:15:29 <carter> i can talk about past experiences
19:15:30 <Fuuzetsu> merijn: ah, I don't know how to beat O(n) either; https://vimeo.com/102785458 is worth watching regardless, there's a theory bit in the end too
19:15:32 <merijn> fresheyeball: In haskell you newtype to avoid the recursion, no clue what purescript is supposed to be
19:15:35 <fresheyeball> I am in there too
19:15:38 <vanila> fresheyeball, can i see?
19:15:40 <arbn> fresheyeball: OK.
19:15:41 <merijn> Fuuzetsu: Well, I took a different approach :)
19:15:53 <fresheyeball> http://lpaste.net/111020
19:16:09 <fresheyeball> how do you use newtype to avoid recursive type signatures?
19:16:17 <fresheyeball> purescript also has newtype
19:16:23 <merijn> Fuuzetsu: I used singleton style GADTs + function, which should be much faster to index :)
19:16:26 <vanila> fresheyeball, do you mean infinite type?
19:16:37 <fresheyeball> maybe
19:16:39 <fresheyeball> I am a noob
19:16:56 <Fuuzetsu> merijn: I think the new vinyl version does this but I'm super flaky on the theory of it so I don't want to say something wrong
19:17:09 <Fuuzetsu> I really think you should skim the video, it talks about this stuff
19:17:14 <fresheyeball> type Foo a b c =  a -> (Foo a b c) -> c
19:17:20 <fresheyeball> is that in infinate type?
19:17:21 <merijn> Fuuzetsu: Basically I'm currently doing something like: http://lpaste.net/110431
19:17:29 <vanila> fresheyeball, renderNode doesn't have a case for Wrap
19:18:00 <merijn> Sorry for the -XKitchenSink ;)
19:18:03 <vanila> fresheyeball, do you get a compile error? what is it?
19:18:24 <Fuuzetsu> I think that's simpler version of what vinyl does now, but again, not sure
19:18:33 <fresheyeball> cannot unify `(Maybe p -> Attributes l a -> Eff e b)` with `l`
19:18:35 <thinkpad20> hey guys I have a cabal question; I'm trying to run `cabal haddock`. It says that the `scientific` package is missing. But it's not missing; it's already there. What's the deal?
19:18:49 <fresheyeball> `l` and `(Maybe p -> Attributes l a -> Eff e b)` are the same thing
19:18:55 <fresheyeball> which is my problem
19:19:01 <merijn> thinkpad20: Why do you think it's already there?
19:19:02 <fresheyeball> the type contains itself
19:19:26 <thinkpad20> merijn: first of all, because if I run `cabal install scientific` it says it's already installed
19:19:37 <thinkpad20> merijn: secondly, because I'm able to use it :)
19:20:21 <vanila> fresheyeball, well I guess you could try turning all your 'type's into 'data' (adding a constructor that you'll have to pattern match away) -- I don't think this will fix the proble though
19:20:31 <vanila> because I don't really see anything wrong with this code, I think it should work
19:20:41 <vanila> obviously, since it doesn't work, im missing something
19:20:50 <merijn> thinkpad20: In a sandbox or....?
19:20:55 <thinkpad20> in a sandbox
19:21:16 <merijn> vanila: newtype is sufficient for infinite types is sufficient in haskell
19:21:32 <prophile> merijn: parse error
19:21:37 <merijn> thinkpad20: Ah, I'm guessing that's part of the problem, but I don't know the details :)
19:21:49 <merijn> prophile: I'm from the Department of Redundancy Department
19:22:04 <prophile> ah
19:22:10 <merijn> Also, I'm tired enough to forget the beginning of my sentence by the time I end them :)
19:22:13 <thinkpad20> merijn: it's never been a problem before :(
19:22:26 <merijn> prophile: Also, I'm sure the wine is not helping :)
19:23:03 <prophile> merijn: on the contrary: inebriated, sleep-deprived IRCing is the way of the future
19:23:16 <merijn> prophile: I'm way ahead of the curve ;)
19:24:39 <c74d> ever since I thought about it, “Department of Redundancy Department” hasn’t worked for me — it’s not actually redundant!
19:25:24 <c74d> it could be (Department of Redundancy) Department or Department of (Redundancy Department) — the department concerned with the Department of Redundancy
19:25:39 <nshepperd> fresheyeball: "newtype Foo a b c =  Foo (a -> (Foo a b c) -> c)" works. you can't do recursive type synonyms, but you can do recursive newtypes
19:25:59 <c74d> “Redundancy Department of Redundancy”, though… that works, as far as I can tell
19:27:20 <prophile> hm
19:27:25 <arbn> c74d: No. There might be Redundancy departments concerned with things other than redundancy.
19:27:41 <c74d> hm
19:27:46 <prophile> what would newtype Foo a b = Foo (a -> (Foo a b) -> b) actually... "do"?
19:27:49 <arbn> c74d: A Redundancy Department of Agriculture, for instance, so you have to distinguish.
19:28:28 <merijn> arbn, c74d: clearly heading into #-blah territory here :)
19:28:29 <c74d> yes… it could be charged with ensuring that all fields are tilled in triplicate or something
19:28:36 <solatis> :)
19:28:43 <c74d> quite off-topic, I suppose
19:38:41 <fresheyeball> @nshepperd thank you
19:38:41 <lambdabot> Unknown command, try @list
19:38:46 <vanila> does anyone have good resources for learning to write compilers?
19:38:46 <fresheyeball> I am going to try that out
19:39:13 <vanila> nshepperd, I don't see any recursive synonyms though
19:39:16 <fresheyeball> paf31 helped me out in the purescript channel
19:39:33 <fresheyeball> btw
19:39:38 <fresheyeball> purescript is amazing
19:39:57 <fresheyeball> highly recommend for when you can't avoid javascript as the runtime
19:40:11 <fresheyeball> but purescript stands up as a good language in its own right
19:40:28 <vanila> ok
19:40:56 <vanila> what'st he { | a } thing?
19:41:00 <merijn> vanila: I don't really know any good intros on the code generation aspect of it, although in my opinion it's not that hard
19:41:15 <merijn> vanila: If you're interested in the type checking aspect of compilers, check out TaPL
19:45:18 <fresheyeball> its an extensible record
19:45:27 <vanila> cool
19:45:37 <fresheyeball> empty record {} can be extended with a so { | a}
19:45:46 <fresheyeball> or more clearly
19:45:56 <vanila> can you do things like join two records and assert disjointness?
19:46:01 <fresheyeball> { foo : "Foo", bar : "Bar" | e }
19:46:13 <fresheyeball> you should be able to yes
19:46:35 <fresheyeball> records in purescript are really just js objects in the runtime
19:50:03 <solatis> fresheyeball: how does purescript compare to livescript?
19:51:40 <fresheyeball> they are very different
19:52:04 <solatis> purescript looks better!
19:52:15 <solatis> does it come with a prelude?
19:52:17 <fresheyeball> livescript is basically javascript with all it problems, plus functional syntax candy and syntax improvements
19:52:23 <fresheyeball> yes it comes with prelude
19:52:50 <fresheyeball> purescript is strictly typed, immutable and comes with almost every standard lib you could want
19:53:14 <fresheyeball> purescript is radically different from livescript
19:53:16 <solatis> interesting, purescript apparently is already in my bookmarks
19:53:29 <fresheyeball> I've been writing purescript for a few months
19:53:41 <fresheyeball> love it, it feels like haskell in my brain
19:53:49 <fresheyeball> livescript felt like shit
19:54:07 <fresheyeball> well not shit
19:54:08 <solatis> then obviously you haven't tried coffeescript
19:54:19 <fresheyeball> coffeescript is my day job
19:54:21 <fresheyeball> hahah
19:54:29 <solatis> i feel sorry for you
19:54:37 <fresheyeball> livescript > coffeescript
19:54:40 <solatis> it's even worse than javascript imho
19:54:49 <fresheyeball> I live it better than straight js
19:54:50 <solatis> the compiler is just so bad
19:54:55 <fresheyeball> its nice and terse
19:54:58 <vanila> what's wrong with javascript?
19:55:01 <solatis> yeah the syntax is ok
19:55:06 <solatis> but the compiler is not
19:55:13 <fresheyeball> after working on big js applications
19:55:37 <solatis> vanila: too much boilerplate code imho
19:55:50 <ezrios> vanila: a lot
19:55:59 <fresheyeball> I am convinced that compiler assurances are still needed even with TDD developers
19:56:00 <solatis> nah i respect javascript a lot
19:56:01 <ezrios> entire books have been written on what is wrong with it
19:56:05 <vanila> but what about jquery? couldn't you remove boilerplate with similar ideas?
19:56:16 <fresheyeball> jQuery blows
19:56:18 <fresheyeball> imho
19:56:22 <solatis> vanila: nah, take a function definition for example
19:56:22 <vanila> ah
19:56:29 <solatis> in coffeescript you can do (foo) -> bar
19:56:44 <solatis> in javascript you would have to write function (foo) { return bar; }
19:56:48 <fresheyeball> we have 90% code coverage in coffeescript, and bugs are still too common imho
19:56:57 <solatis> and let's not even start about talking about comparison operators
19:57:03 <fresheyeball> there is contracts.coffee
19:57:25 <solatis> vanila: https://www.destroyallsoftware.com/talks/wat
19:57:28 <vanila> idea: s-expression syntax that turns into javascript - but replaces = with a sane comparison operator etc.
19:57:33 <solatis> watch it
19:57:48 <solatis> it kind of explains what's wrong with JS in 5 minutes
19:57:48 <fresheyeball> http://disnetdev.com/contracts.coffee/
19:57:53 <fresheyeball> this helps
19:57:55 <fresheyeball> and is pretty cool
19:57:58 <vanila> haha ok
19:58:10 <fresheyeball> still
19:58:13 <solatis> (and the talk is a classic one, every js dev i know has seen it :))
19:58:34 <fresheyeball> I feel like you can get compiler assurances by going OOP with typescript
19:58:35 <solatis> fresheyeball: i miss coroutines tho
19:58:43 <fresheyeball> or you can go functional with purescript
19:58:55 <solatis> does purescript have coroutine support already?
19:59:07 <solatis> all languages seem to wait until the browsers update their engines...
19:59:17 <solatis> (languages = js derivatives)
19:59:39 <fresheyeball> no coroutines
19:59:49 <solatis> that's a shame
20:00:14 <solatis> i always found that to be the missing piece between JS and "real" functional languages
20:01:25 <vanila> I think it's really interesting that javascript has its own weird brand of scope that no other language has
20:01:34 <coppro> win 39
20:02:10 <solatis> fresheyeball: https://maxtaco.github.io/coffee-script/
20:02:15 <solatis> seen that one already?
20:02:39 <solatis> vanila: i've been shouting that javascript is the next-generation ASM for browsers for years
20:02:44 <fresheyeball> yes
20:02:44 <solatis> and suddenly asm.js appeared
20:02:53 <fresheyeball> I've seen most transpilers at this point
20:02:59 <solatis> yeah me too
20:03:12 <solatis> you are right that purescript is the least bad :)
20:03:20 <vanila> solatis, I wonder if it would have been better to have a bytecode language [that any language can target] rather than something high level like js in the browser
20:03:22 <solatis> and is probably about as good as it gets
20:03:32 <solatis> vanila: there are so many efforts for that
20:03:46 <solatis> vanila: but every browser *already* has javascript support, so it makes sense to target that language
20:03:57 <solatis> just look at google's dart
20:04:30 <solatis> they even had to write a JS fallback compiler in addition to using bytecode
20:04:37 <solatis> i think asm.js is a much more sensible solution
20:04:46 <solatis> since it's backwards compatible with javascript
20:05:04 <solatis> and allows browser makers to optimize asm.js-based code in future releases
20:05:48 <vanila> I think that js lacks a good permissions model though
20:06:04 <solatis> and as you might already know, entire c++ games have been ported to asm.js using llvm
20:06:12 <vanila> I want to be able to give per site permissions like 'able to open popups/store cookies/etc..' and all that has to be added as an afterthought
20:06:21 <vanila> this could be part of a type system isntead
20:06:21 <solatis> so you can write c++ code that eventually compiles to javascript
20:07:14 <solatis> vanila: you're confusing the DOM / browser with the language
20:07:19 * hackagebot StrappedTemplates 0.2.0.0 - General purpose templates in haskell  http://hackage.haskell.org/package/StrappedTemplates-0.2.0.0 (hansonkd)
20:07:21 <solatis> vanila: how would that work with node.js ?
20:07:57 <vanila> solatis, that's an interetsing question
20:07:59 <solatis> when you have a strict seperation of concerns, it's not an aftertought, it's a feature
20:11:25 <bmuk> what if code sent to the browser could be dynamically recompiled, sandboxing it if you will? I know google does something like that with native client, but I don't know if it uses dynamic recompilation
20:12:39 <bmuk> Then again, the better focus with dynamic recompilation would be to pull everything into kernel space. Context switching adds a lot of performance overhead. Maybe safeHaskell could be made to run in kernel space?
20:18:57 <vanila> https://www.youtube.com/watch?v=f84n5oFoZBc
20:32:21 * hackagebot Wheb 0.3.1.0 - The frictionless WAI Framework  http://hackage.haskell.org/package/Wheb-0.3.1.0 (hansonkd)
20:48:11 <the_jeb> hey guys, I was trying to solve the project euler problem 12(https://projecteuler.net/problem=12) and I wrote this code http://pastebin.com/KH7HBWBr, but my answer is wrong and I can't figure out why
20:49:10 <the_jeb> oops, wrong channel, that is python code
20:49:20 <prophile> that's the problem
20:49:31 <prophile> :D
20:50:46 <the_jeb> prophile: I wish it were at this point, been at it for a while
20:51:06 <Cale> the_jeb: Your problem is that you're assuming that numbers have no nontrivial divisors larger than their square root.
20:52:06 <prophile> divisors.extend((i, trinum // i)) may do the trick
20:52:18 <Cale> the_jeb: The square root of 100 is 10, but 50 is a divisor of 100.
20:52:42 <prophile> and initialize it to set() rather than [trinum]
20:53:17 <the_jeb> Cale: oh yeah, that was really dumb, I tried to reuse some logic from some exercises with prime numbers
20:53:37 <Cale> the_jeb: You *could* compute the prime factorisation
20:53:49 <Cale> the_jeb: it's easier to count the divisors that way
20:54:37 <the_jeb> but when I ran the program without putting the sqrt cap, it ran forever, so the code is still technically wrong, since projecteuler problems are not supposed to run for more than a minute
20:54:54 <Cale> the_jeb: If a = p_1^(a_1) * ... * p_n^(a_n), then the number of divisors of a is (1 + a_1) * (1 + a_2) * ... * (1 + a_n)
20:55:06 <Cale> Yes, that's also an issue :)
20:55:43 <c74d> The only things I’ve heard about #python are that it’s large and unfriendly… is #haskell a better #python than #python? :D
20:55:55 <Cale> Well, this isn't really a python problem
20:56:04 <Cale> It's an algorithm problem
20:56:55 <the_jeb> and prophile I didn't understand a word you said, sort of new at this
20:56:59 <Cale> the_jeb: Something you ought to know is that 1 + 2 + ... + n = n * (n+1) / 2
20:57:18 <Cale> the_jeb: and that n and (n+1) never have any factors in common
20:57:28 <prophile> c74d: #python isn't so bad
20:57:40 <c74d> ah, I wouldn’t know
20:58:26 <Cale> (because if x divides n and x divides n+1, then x divides the difference n - (n+1) = 1
20:58:35 <Cale> which means that n = 1)
20:58:36 <prophile> there are certain language channels which are truly terrible but #python isn't one of them
20:59:10 <Cale> er, rather that x = 1
21:00:02 <Cale> Or possibly x = -1 of course, if we're talking about integers rather than natural numbers, though we're not interested in that right now :)
21:03:07 <Cale> the_jeb: When a and b have no common prime factors, the number of divisors of a*b is equal to (the number of divisors of a) * (the number of divisors of b)
21:08:03 <the_jeb> I guess the only way to solve that problem in a reasonable time is to use the prime factorisation
21:12:50 <Cale> Oh, I suppose you can just compute the triangular numbers and then factor them into primes, it'll be about the same amount of work as factoring n and (n+1)/2 or n/2 and (n+1) into primes anyway
21:13:16 <Cale> But yeah, counting divisors from the factorisation is way cheaper
21:19:27 <Kludgy__> Hi all, are there any favourite patterns for wrangling synchronous event callbacks of the form (Event -> IO ()) from foreign systems?
21:20:12 <Cale> Kludgy__: Well, there's the way that Gtk2Hs does things
21:20:44 <Kludgy__> Cale: Oh? Lots of IORefs? :)
21:21:10 <Cale> Let me see if I can find a reference
21:22:35 <Cale> http://hackage.haskell.org/package/glib-0.13.0.1/docs/System-Glib-Signals.html#t:Signal
21:22:53 <Kludgy__> Taking a look
21:24:39 <Cale> Kludgy__: The idea being that values of type (Signal object handler) contain the information about how to attach a handler callback of type 'handler' to an object of type 'object', and then you use the 'on' and 'after' functions to actually perform this.
21:24:50 <Kludgy__> Cale: I see so this ties the knot on modifying the receiver of an event.
21:24:57 <Cale> buttonActivated :: ButtonClass self => Signal self (IO ())
21:26:04 <Cale> deleteRange :: TextBufferClass self => Signal self (TextIter -> TextIter -> IO ())
21:26:14 <Cale> You can do away with the type classes if you like
21:26:23 <Cale> That's a whole other level of abstraction here
21:27:27 * hackagebot yesod-bin 1.2.13 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.13 (MichaelSnoyman)
21:27:46 <Cale> Of course, if you want to be even more fancy, you get into the area of inventing FRP systems
21:30:06 <slack1256> hs-source-dir could only target some modules of my library?
21:30:06 <Kludgy__> Right. processing.... :)
21:30:23 <copumpkin> mokus_: you see that dominic steinitz is trying to get ahold of you?
21:37:43 <Kludgy__> Cale: OK got it. So let's say I now have the moral equivalent of Signal, as well as the registration function 'on'. I have numerous Event types that come in, but now there's the apparent issue of shared state within the Haskell program. Most examples I see rely on state mutation happening outside of Haskell to coordinate, but I suppose I'm looking at building useful aggregation within the program.
21:38:37 <Kludgy__> I understand the program specification may wildly influence the approach.
21:40:04 <Cale> Kludgy__: Well, expressing the relationships between things that change over time in a more declarative fashion is sort of what all those FRP systems are about. You might have a look at sodium and reactive-banana and netwire for examples.
21:40:32 <Kludgy__> Cale: OK I see! I may finally have the reason I need to delve into frp
21:45:01 <meretrix> Is there any extension that lets me do the following?  { myPrint <- return print; myPrint 123; myPrint "hello" }
21:45:17 <octopuscabbage> i'm trying to write a library for controlling the gpio libraries on a beaglebone black. what should i call it?
21:45:24 <meretrix> Basically I want myPrint to have type "Show a => a -> IO ()", but not have to define "a" until I use it.
21:46:52 <bms1> meretrix: print will do the job there!
21:47:20 <slack1256> My sed fu is weak. I need to programmaticaly modify the export list of a module to export all, anyone can help me?
21:47:28 <bms1> > print 123 >> print "hello"
21:47:29 * hackagebot wheb-strapped 0.1.0.0 - Strapped templates for Wheb  http://hackage.haskell.org/package/wheb-strapped-0.1.0.0 (hansonkd)
21:47:30 <lambdabot>  <IO ()>
21:48:07 <bms1> slack1256: If you remove the export list, it exports all by default, right?
21:48:13 <meretrix> bms1: Yes, I know. :)  My function is actually more than just print.
21:48:40 <slack1256> yes
21:48:45 <slack1256> bms1: ^
21:49:07 <bms1> meretrix: Well if your function only uses the show instance of your datatype, you should be able to have the polymorphic type for your print function
21:49:42 <bms1> slack1256: I meant to ask if that was a possible solution for you
21:50:06 <meretrix> bms1: Right, but I have an IO function that actually creates the print function.
21:50:33 <bms1> meretrix: That shouldn't stop it from being polymorphic
21:50:33 <slack1256> yes it is, but I need to do it with sed. We are grabbing the ghci bits from the user ghc installation and the removing the export list because we use the internal functions
21:50:52 <bms1> oh
21:51:17 <prophile> how would #haskell feel about a (Monoid m) => Monoid (IO m) instance
21:51:22 <bms1> meretrix: You should be able to make a function generateMyPrint :: Show a => IO (a -> IO ())
21:51:40 <prophile> mild convenience in the general case but specifically it means you can compose IO () actions with <> and mempty
21:52:09 <meretrix> Yeah, but if I run that in a Monad, it requires a single instance of Show. I can't use it for two instances.
21:52:28 <meretrix> I guess it's not possible.
21:52:30 <bms1> meretrix: That's not true - it should remain polymorphic
21:52:40 <prophile> and I don't think there's another sensible instance
21:52:47 <shachaf> I'm fine with pure and *>
21:52:49 <bms1> meretrix: case in point:
21:53:48 <prophile> it would mean being able to do, for instance, Writer (IO ()) for a monad that can perform IO actions but can't actually depend on their results
21:53:58 <shachaf> In general you have (Monoid m, Applicative f) => Monoid (f m), but I don't think it's worth special-casing just for IO.
21:54:17 <prophile> it's special-cased for (->) r
21:55:09 <shachaf> (->) is special
21:55:26 <prophile> (,) w too
21:55:32 <shachaf> By pure I meant pure (), of course.
21:55:37 <prophile> naturally
21:55:39 <meretrix> bsmt: This is what I'm trying: http://lpaste.net/111022
21:55:49 * shachaf gets on yrain.
21:55:50 <meretrix> bms1: ^
21:56:50 <bms1> meretrix: Oh, you're right, I'm sorry!
21:56:58 <prophile> and Const k
21:57:04 <meretrix> No worries, thanks anyway. :)
21:57:05 <bms1> meretrix: You could do it with existential types
21:57:15 <bms1> But it's not pretty
21:57:18 <meretrix> How?
21:57:50 <meretrix> You mean with a wrapper type?
21:58:03 <bms1> yes
21:58:21 <meretrix> Yup, that's what I started with.
21:58:27 <Kludgy__> prophile: For consideration: https://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg24485.html
21:58:31 <bms1> Okay, sorry about my confusion there
21:58:38 <prophile> Kludgy__: thank you
21:58:40 * prophile reads
21:59:20 <bms1> meretrix: But the other thing you can do, if you just need the show instance
21:59:40 <bms1> is to just apply show, and have your function take a string as an argument
22:00:44 <prophile> mm, ok
22:01:34 <bms1> meretrix: Another option is to create a print function several times
22:03:14 <bms1> And another option would be to make your function have type (a -> String) -> a -> IO ()
22:04:21 <singularai> hello everyone, can someone to help me untangle a mess with lazy IO and segmentation faults in c code?
22:04:22 <meretrix> That's true.  In this case, the wrapper type will be the cleanest I think.
22:04:38 <bms1> meretrix: Actually, that third option has the same issue, woops
22:05:55 <singularai> I have some code that runs correctly if I print out a variable before passing it into c, but throws a segmentation fault if I don't print the variable
22:09:04 <bms1> singularai: what are you passing to C?
22:09:40 <singularai> well a string
22:09:56 <singularai> I have a framework to call python code from haskell inline
22:10:35 <solatis> Fuuzetsu: am i correct that you seem to be *only* using nix instead of cabal ?
22:11:08 <singularai> you use it like this:
22:11:36 <singularai> square :: Int -> IO (Maybe Int)
22:11:36 <singularai> square = Py.pydef "square" [Py.str
22:11:36 <singularai> def square(x):
22:11:36 <singularai>     return x * x
22:11:36 <singularai> |]
22:11:37 <singularai> square :: Int -> IO (Maybe Int)
22:11:37 <singularai> square = Py.pydef "square" [Py.str
22:11:38 <singularai> def square(x):
22:11:38 <singularai>     return x * x
22:11:39 <singularai> |]
22:11:39 <singularai> square :: Int -> IO (Maybe Int)
22:11:43 <Fuuzetsu> woah there
22:11:53 <solatis> thank you freenode
22:12:34 <solatis> Fuuzetsu: i was sent to your https://github.com/Fuuzetsu/nix-project-defaults repo in #nixos
22:13:05 <Fuuzetsu> solatis: I only use nix to manage packages but sometimes I still run ‘cabal’, for example ‘cabal repl’ when hacking on Yi (I need the files cabal generates) or ‘cabal update’ if I want to run ‘hackage4nix’ but for my own projects I tend to set them up in a way that GHCi inside nix-shell is sufficient.
22:13:12 <Fuuzetsu> I saw
22:13:28 <solatis> ok
22:14:24 <solatis> but you can get pretty far with using only nix for dependency management instead of cabal
22:14:53 <solatis> maybe i'll ditch my .cabal files for my private projects, or is that too extreme?
22:15:39 <bmuk`> solatis: I think cabal files are still important, unless you don't want anyone who isn't running nixos to ever hack on your stuff.
22:16:36 <Fuuzetsu> you still need cabal files so nix can actually build your projects
22:17:00 <Fuuzetsu> I just hack hack hack and when I'm done for the day, I update the cabal file accordingly
22:17:02 <solatis> bmuk`: that's why i explicitly mentioned private projects :)
22:17:08 <Fuuzetsu> or I will update the cabal file and regenerate the expression
22:17:25 <solatis> Fuuzetsu: right. and that's where cabal2nix comes into play?
22:17:34 <Fuuzetsu> sure
22:17:48 <isk666> Hello world!!
22:17:52 <Fuuzetsu> I will often just update the expression by hand while hacking, dependencies come and go
22:18:05 <solatis> got it
22:18:16 <solatis> time to play around with it mysel
22:18:20 <bmuk`> Hello isk666!
22:18:43 <isk666> Can I use haskell for hacking???
22:18:47 <NikolaiToryzin> I hear #Haskell is the nicest place on freenode. Can anyone confirm this?
22:19:04 <isk666> I can confirm it.
22:19:12 <MP2E> If it's not, I'd like to see what is. Because they must hand you money upon /join
22:19:25 <NikolaiToryzin> Going to have to write this down and add a check mark
22:19:40 <solatis> MP2E: haha
22:19:44 <isk666> Can I use haskell for hacking???
22:19:48 <isk666> Can I use haskell for hacking???
22:19:53 <prophile> as in kernel hacking?
22:19:57 <shachaf> #haskell is too self-congratulatory for my taste.
22:20:07 <merijn> isk666: Off-topic and irrelevant
22:20:14 <prophile> theoretically possible I guess
22:20:38 <NikolaiToryzin> Is Haskell written in haskell?
22:20:42 <prophile> though you might need to fiddle with the GHC runtime to deal with how the kernel does memory-management internally
22:20:44 <merijn> prophile: Please don't feed the scriptkiddie trollz
22:21:17 <merijn> NikolaiToryzin: The haskell compiler is written in haskell, yes
22:21:27 <prophile> merijn: principle of charity, and it's a quite interesting question
22:21:38 <solatis> prophile: http://www.haskell.org/haskellwiki/Kernel_Modules
22:21:40 <merijn> NikolaiToryzin: Well, GHC is and presumably so is UHC, Hugs is written in C
22:21:53 <merijn> prophile: If you're personally curious, check out House and HaLVM
22:21:54 <prophile> solatis: neat
22:22:06 <pharaun> is there any way i can derive a functor when a constructor has existential
22:22:06 <isk666> Prophile, can haskell do that C/C++ do?? I am talking about system programming??
22:22:10 <NikolaiToryzin> How redundant
22:22:20 <isk666> Prophile, can haskell do that C/C++ do?? I am talking about system programming??
22:22:35 <NikolaiToryzin> isk666: If it's compiled, and I'm sure it is, I'd assume so
22:22:37 <prophile> isk666: evidently so, see the link that solatis posted
22:22:43 <prophile> you only need to say it once :)
22:23:15 <shachaf> isk666: You're being disruptive. Please stop.
22:23:18 <solatis> i would personally doubt it's the right tool for the job though, but that's a whole different discussion
22:23:39 <isk666> Thanks for your help. I am a newbie.
22:24:04 <prophile> solatis: hm, I can think of a few places where it might be good actually
22:24:18 <bmuk`> solatis: For the sake of argument, why do you feel that haskell (or high level functional languages in general) are not suited to systems programming?
22:24:26 <prophile> the kernel has an internal compiler for its BPF mechanism that's used in a few places
22:24:38 <merijn> bmuk`: Global garbage collection stop and the inability to do explicit memory layouts
22:24:41 <prophile> it's run rarely so it's not performance-critical
22:24:46 <shachaf> pharaun: As in DeriveFunctor? If it doesn't work then it doesn't work.
22:24:50 <merijn> bmuk`: There are not insurmountable issues, but they're tricky
22:25:03 <pharaun> shachaf: ya
22:25:18 <pharaun> http://lpaste.net/111023
22:25:25 <merijn> bmuk`: The biggest problem is that for things like drivers and interrupt handlers you want realtime/soft realtime guarantees which are hard to deliver in the presence of garbage collection freezes
22:25:46 <solatis> merijn: exactly, probably for the same reasons any VM-based language isn't ideal for writing kernel modules
22:26:37 <pharaun> shachaf: nevermind i got it, i was derpping :)
22:27:01 <merijn> If you extend haskell with primitves for explicit memory layouting it might work, although even then the unpredictability of laziness may make hard realtime problematic
22:27:20 <bmuk`> merijn: I agree they do present difficulties. I would like to see very small traditional kernel layer below everything else that allocates memory and such, and the haskell layer works on top of it, by passing messages to the layer below when it needs to allocate memory, etc.
22:27:40 <prophile> iirc Edwin Brady has been playing with linear types in Idris for (soft-)real-time concerns
22:27:57 <Kludgy__> prophile:
22:28:01 <Kludgy__> whoops..
22:28:04 <prophile> quite
22:28:10 <Kludgy__> prohpile: aren't linear types limited in application?
22:28:16 <Kludgy__> I wish I could spell
22:28:34 <merijn> bmuk`: Thats what House and HaLVM are
22:28:45 <merijn> bmuk`: See also the work on Habit at PSU
22:29:01 <prophile> well, they're strictly less powerful than the standard type system, yes
22:30:29 <zwer> fwiw there are deterministic garbage collectors (for java) designed for hard real-time systems
22:31:02 <Kludgy__> prophile: Point taken. Seems to be a lot of active research into various substructural approaches, but do you think that there are opportunities to exploit these based on common roles of realtime systems?
22:31:08 <bmuk`> have there been any kernels written as finite state machines?
22:31:47 <Kludgy__> prophile: Sorry I'm being quite vague. Not knowledgeable, so orbiting a high level. :)
22:31:51 <merijn> zwer: Most of those are still pretty primitive
22:31:52 <bmuk`> I don't know if that would even be possible.
22:32:07 <prophile> bmuk`: it'd probably have to be a finite state transducer to do anything useful
22:32:42 <prophile> but I can imagine it working
22:34:36 <bmuk`> I imagine that, as computational resources become exponentially cheaper and more powerful, assurance of functionality will become much more important to more people than it is now, and we will see more functional kernels and the like. That's just speculation, though
22:38:46 <bmuk`> has anyone done anything with safeHaskell in kernel space?
22:40:35 <isk666> Somebody knows if Haskell support mixing with assembler??
22:41:04 <Hodapp> isk666: for what use case?
22:41:13 <_tac> isk666: wrap it in a C function, use the C FFI. Is my guess for the easiest route to do that.
22:41:14 <bmuk`> isk666: https://github.com/GaloisInc/ivory
22:43:35 <isk666> Okey I think that mixing with assembler could allow use Haskell in a real production environment, such a commercial software.
22:44:05 <bmuk`> isk666: I don't think many companies use asm anymore.
22:44:08 <_tac> I don't think much commercial software nowadays would make use of asm
22:44:30 <_tac> C is the appropriate level of abstraction for the vast, vast, vast majority of things.
22:45:00 <Hodapp> I can't think of a single case where that saves enough time over using C FFI & inline ASM that it would actually make a difference.
22:45:43 <isk666> You are right, but in fields like embebbed systems asm still being used.
22:46:00 <Hodapp> I work in embedded systems.
22:46:33 <Hodapp> good luck getting a Haskell runtime there.
22:48:42 <bmuk`> Hodapp: isn't that what Galois does?
22:49:40 <isk666> Hodapp, are you using asm to do your job?? That confirms that asm lives today. I know that a few high languages are supported by embbebed devices.
22:52:19 <halvorg>  No instance for (monad-logger-0.3.7.2:Control.Monad.Logger.MonadLogger
22:52:21 <halvorg>                        IO)
22:52:26 <halvorg> that cant be right?
22:52:47 <halvorg> uh, sec was looking at old docs
22:52:48 <Hodapp> isk666: The answer is no, so that fails to confirm that.
22:53:30 <merijn> _tac: My brother is in electrical engineering, they still use asm for half the stuff they do
22:53:50 <merijn> And the C they do use looks nothing like C as people expect
22:54:25 <_tac> merijn: A pity for his pointers.
22:54:50 <bmuk`> But seriously, doesn't Galois do haskell on embedded devices?
22:55:45 <_tac> I'd think you'd need to stretch the definition of 'embedded'
22:55:57 <_tac> It seems like a poor choice of technology, even if they do do it.
22:57:44 <bmuk`> It looks like they do, but they are really generating c. Still pretty cool.
22:57:46 <bmuk`> https://leepike.github.io/Copilot/
22:58:02 <merijn> bmuk`: Galois is also involved with Habit
23:02:33 <mokus_> copumpkin: yea, thanks - i replied to the message he sent to libraries@ but i'm not currently subscribed so it didn't make it to the list
23:29:43 <trap_exit> why does liftM exist when we have fmap? why does ap exist when we have <*> ?
23:29:54 <trap_exit> are liftM and ap soon to be extinct?
23:30:11 <_tac> trap_exit: historical reasons
23:30:29 <_tac> for the second, I guess
23:30:32 <joelteon> because it's not Functor m => Monad m
23:31:36 <bmuk``> joelteon: it will be soon, though, correct? Applicative m => Monad m, I mean
23:34:31 <Enigmagic> bmuk``: in 7.10, yes
23:34:47 <joelteon> someday
23:35:10 <Enigmagic> it is in head already :p
23:36:14 <spacekitteh> is hackage /window 4
23:36:15 <spacekitteh> ...
23:36:20 <spacekitteh> whoops
23:36:23 <joelteon> I don't think so
23:38:19 <Enigmagic> joelteon: https://github.com/ghc/ghc/commit/d94de87252d0fe2ae97341d186b03a2fbe136b04
23:38:48 <Enigmagic> it was merged last week
23:40:46 <MP2E> yep AMP is live. Though it's not finished yet
23:44:20 <slack1256> guys, any of you uses ghc-mod?
23:45:05 <joelteon> not directly
23:45:07 <joelteon> why?
23:45:19 <kadoban> Kind of...my syntax checker thingie uses it
23:45:24 <joelteon> same
23:52:40 * hackagebot stm-delay 0.1.1.1 - Updatable one-shot timer polled with STM  http://hackage.haskell.org/package/stm-delay-0.1.1.1 (JoeyAdams)
23:55:31 <trap_exit> i'm on chapter 15 of LYAH
23:55:35 <trap_exit> everyone cheer me on :-)
23:55:45 <coppro> trap_exit: \o/
23:56:07 * kadoban shakes pom-poms
23:56:32 <_tac> there... are only 14 chapters :X
23:56:45 <kadoban> He's doing remarkably well then XD
23:57:44 * pharpend can't keep track of who's a newbie and who's a guru
23:57:50 * pharpend thought trap_exit was a guru
23:58:04 <_tac> apparently, he's well on his way
23:58:13 <prophile> the gurus can be identified by having the forename "simon"
23:58:23 <prophile> everyone else falls into the former category
23:58:25 <bmuk``> and ekmett
23:58:34 <Qfwfq> Simon is a title, not a forename.
23:59:03 <prophile> at this point ekmett is more part of the language than a practitioner of it
23:59:25 <trap_exit> what are you talking about?
23:59:28 <trap_exit> LYAH has 15 chapters
23:59:29 <trap_exit> 15 = Zippers
23:59:46 <_tac> huh... the online version says 14 = Zippers
23:59:47 <trap_exit> i'm reading the 2011 edition
23:59:49 <trap_exit> what edition are you reading?
