00:04:54 <jle`> merijn: it's like... show the third layer...unwords the second layer ... words the first layer...unlines it all
00:05:51 <CrazyM4n> http://prntscr.com/4r1hxr
00:21:08 <pharaun> i have a type/version question.
00:21:52 <pharaun> so basically, this is regarding persistent. i have a function with typeclass X, then in version 2 they upgraded and made it generic to typeclass Y. but my code appears to work with both version if i remove the type-def.
00:22:15 <pharaun> any advice here? how do people normally deal with this case? do i need cpp if n def or should i leave the top-level type bare or ?
00:24:48 * hackagebot dow 0.2.5 - Dungeons of Wor  http://hackage.haskell.org/package/dow-0.2.5 (GergelyPatai)
00:26:31 <Hijiri>  I thought that was the show instance for lists?
00:26:39 <Hijiri> oh, I was scrolled up
00:42:18 <yitz> pharaun: if your code works with both versions, what is the problem?
00:43:00 <yitz> pharaun: what typedef are you removing?
00:43:59 <pharaun> yitz: there's no problem, i just like to have "full" typedef at top-level
00:44:16 <pharaun> but the class changed between version from
00:44:16 <pharaun>     Could not deduce (PersistMonadBackend m ~ SqlBackend)
00:44:17 <pharaun>     from the context (MonadIO m)
00:44:34 <pharaun> from this to monadIO in the newer version and i upgraded but that breaks backward compat
00:46:40 <yitz> pharaun: i guess you have a few choices. one is what you said - omit the typedef and let the types be derived, if that works. at the opposite extreme is cpp, which obviously is better to avoid.
00:47:10 <pharaun> yeah, i was just wondering how folks usually dealt
00:47:35 <pharaun> and yeah i would prefer to avoid cpp. is there no way for me to partially define the type and let GHC derive the undefined part?
00:47:37 <yitz> pharaun: in the middle: you can constraint the type to PersistMonadBackend ... just where you really use that, and leave it generic where you don't
00:47:45 <pharaun> ahh
00:48:00 <pharaun> as in "Monad m" or just not defined?
00:48:02 <jle`> there are some things planned for 7.10 that would let you partially specify type signatures
00:48:50 <yitz> pharaun: i don't see your code. but yeah, something like MonadIO m or even Monad m might work in some places if you want to specify the type.
00:49:28 <pharaun> yitz: awesome, thanks i'll play with that :)
00:49:43 <yitz> pharaun: great. gl.
01:06:03 <AshyIsMe> haha posted about LambdaTwit on reddit
01:06:33 <AshyIsMe> someone tweeted "import System.Command \n system "rm -rf *"
01:06:48 <AshyIsMe> hopefully mueval has all of the security stuff handled
01:08:49 <haasn> Mueval needs maintainers :(
01:13:53 <CrazyM4n> > liftA2 (,) [1,2,3] [6,7,8]
01:13:55 <lambdabot>  [(1,6),(1,7),(1,8),(2,6),(2,7),(2,8),(3,6),(3,7),(3,8)]
01:16:34 <AshyIsMe> haasn: yeah it's way behind on the versions of transformers that it relies on
01:16:45 <CrazyM4n> How do I execute a list of IO actions and discard the results?
01:16:55 <CrazyM4n> Wasn't it like liftM_ or something?
01:16:56 <haasn> sequence_
01:17:01 <CrazyM4n> ah
01:17:17 <CrazyM4n> So if I have [writeFile foo, writeFile bar]
01:17:17 <tabemann> mapM_
01:17:23 <CrazyM4n> and I did sequence_
01:17:24 <jle`> :t sequence_
01:17:25 <lambdabot> Monad m => [m a] -> m ()
01:17:28 <CrazyM4n> it would write them?
01:17:37 <haasn> sequence_ [writeFile foo, writeFile bar] = mapM_ writeFile [foo, bar] -- \o/
01:17:37 <jle`> yeah
01:17:37 <shachaf> What happened when you tried it?
01:17:40 <tabemann> :t mapM_
01:17:41 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
01:17:52 <tabemann> oh yeah, that's different
01:18:00 <jle`> there's always mapM_ id ;D
01:18:10 <CrazyM4n> You guys talk about id so much
01:18:12 <jle`> :t mapM_ id
01:18:13 <lambdabot> Monad m => [m b] -> m ()
01:18:17 <CrazyM4n> as such a mind-f'ing thing
01:18:25 <jle`> id is pretty neat
01:18:26 <CrazyM4n> It's pretty funny how such a simple function can be so weird
01:19:20 <jle`> in a lot of contexts in maths...finding the one thing that *doesn't* change things is a big deal
01:19:46 <haasn> I wonder if “mapM id = sequence” is enough to show that “mapM f = sequence . map f”
01:19:54 <haasn> It feels like it should be
01:20:13 <jle`> good thing when i came to haskell the library researchers had already figured out such an identity function was in haskell
01:20:40 <CrazyM4n> jle`: the animated fractal gif is about to be finished
01:20:50 <CrazyM4n> Anyone know how to convert ppm's to gifs?
01:21:12 <jle`> i usually just use imagemagick
01:21:27 <CrazyM4n> I'm on windows
01:21:33 <CrazyM4n> GIMP is a pain but it works, I guess
01:21:51 <jle`> oh, you didn't mean automated?
01:22:06 <CrazyM4n> GIMP can take a bunch of files and turn them into a GIF
01:22:07 <haasn> (Imagemagick runs on Windows afaik)
01:22:10 <CrazyM4n> automatically
01:22:19 <CrazyM4n> also imagemagick is just a pain to get set up on windows
01:22:26 <CrazyM4n> D:
01:22:34 <jle`> can relate
01:22:51 <CrazyM4n> I'll just upload all the files to google drives or something so you guys can look at them
01:24:47 <tabemann> :t sequence . map f
01:24:48 <lambdabot> (FromExpr (m a), Show a1, Monad m) => [a1] -> m [a]
01:25:25 <tabemann> ..... where did Show and FromExpr come from?
01:25:37 <jle`> i think reflection?
01:28:55 <CrazyM4n> :t ["mandel"++(show p)++".ppm" | p <- [0,0.1..2]]
01:28:57 <lambdabot> [[Char]]
01:29:07 <CrazyM4n> why doesn't that work...
01:29:12 <CrazyM4n> it expects a string
01:29:15 <CrazyM4n> err
01:29:17 <CrazyM4n> oh
01:29:21 <tabemann> [Char] is String
01:29:36 <CrazyM4n> yea
01:30:00 <CrazyM4n> So I have a problem, I want to mapM_ writeFile over an array, but it takes 2 arguments
01:30:10 <CrazyM4n> And I'm trying to supply 2 arrays
01:30:14 <CrazyM4n> mapM_ writeFile (["mandel"++(show p)++".ppm" | p <- [0,0.1..2]] [show $ file p | p <- [0,0.1..2]])
01:30:37 <CrazyM4n> Is this the wrong way?
01:30:44 <chaosmasttter> :t mapM_
01:30:45 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
01:30:51 <CrazyM4n> Okay, so it is
01:31:06 <CrazyM4n> How do I pass two arguments to the functions while I'm mapping it then?
01:31:31 <tabemann> mapM (uncurry writeFile) (zip ["mandel"++(show p)++".ppm" | p <- [0,0.1..2]] [show $ file p | p <- [0,0.1..2]])
01:31:37 <tabemann> *mapM_
01:31:48 <CrazyM4n> I see, thanks man
01:32:11 <jle`> i think there is a zipWithM in base
01:32:19 <jle`> :t zipWithM
01:32:20 <lambdabot> Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
01:32:26 <CrazyM4n> I'd rather stick to what makes sense
01:32:28 <jle`> yeah, it's in Control.Monad
01:32:38 <CrazyM4n> I barely understand zips in the first place :P
01:32:46 <jle`> zipWithM writerFile filenames filenums
01:32:53 <CrazyM4n> Ah
01:32:59 <jle`> > zipWith (+) [1,2,3] [10,9,8]
01:33:01 <lambdabot>  [11,11,11]
01:33:02 <CrazyM4n> This is probably more readable though
01:33:04 <jle`> oops
01:33:05 <CrazyM4n> To be honest
01:33:13 * tabemann forgot about zipWith
01:33:23 <tabemann> I'd go with zipWithM myself
01:33:40 <tabemann> what I suggested is kind of unwieldy, with the separate zip, uncurry, and mapM_
01:33:41 <jle`> mapM uncurry zip more readable? ;)
01:34:03 <CrazyM4n> Uhm
01:34:07 <CrazyM4n> A little? :)
01:34:25 <jle`> > zipWith (,) [1,2,3] [4,5,6]
01:34:27 <lambdabot>  [(1,4),(2,5),(3,6)]
01:34:49 <jle`> zipWith just applies the function to elements from pairs taken down the two lists
01:35:14 <jle`> zipWithM is the same thing, although instead of (a -> b -> c), it's (a -> b -> m c)
01:35:23 <CrazyM4n> Okay, it's too late for haskelling
01:35:38 <CrazyM4n> http://prntscr.com/4r1y1g
01:35:50 <CrazyM4n> There... there isn't even a complex number there
01:36:20 <CrazyM4n> Something is very broken
01:36:34 <CrazyM4n> And I feel it is because I have neglected to write any type signatures anywhere in this file
01:36:37 <jle`> you are probably using the numbers in the sequence as complex numbers somewhere else
01:36:47 <jle`> so it infers that it's a sequence of complex numbers
01:37:03 <jle`> remember, haskell does no implicit conversions
01:37:11 <CrazyM4n> Well
01:37:15 <CrazyM4n> I'm using it as
01:37:22 <CrazyM4n> complex number to the power of it
01:37:26 <jle`> if i take something out of a list...and use it somewhere else in the program as a complex number...then haskell will say that it has to be alist of complex numbers
01:37:27 <CrazyM4n> But I assumed that was OK
01:37:38 <jle`> power of, as in (^) or (**) ?
01:37:42 <jle`> :t (**)
01:37:42 <CrazyM4n> **
01:37:43 <lambdabot> Floating a => a -> a -> a
01:37:45 <CrazyM4n> Should I use ^
01:37:52 <CrazyM4n> :t (^)
01:37:53 <lambdabot> (Num a, Integral b) => a -> b -> a
01:37:54 <jle`> it looks like (**) uses two things of the same type
01:37:58 <CrazyM4n> Ah
01:38:05 <jle`> so if you do x ** y, then x is the same type as y
01:38:10 <CrazyM4n> Ok, that error down
01:38:15 <CrazyM4n> They just keep rolling in
01:39:03 <CrazyM4n> I give up with this
01:39:10 <CrazyM4n> Holy crap let me just rewrite it
01:40:32 <CrazyM4n> OK
01:42:18 <CrazyM4n> So far, so good
01:43:13 <jle`> :D
01:43:32 <CrazyM4n> Aaand it's all broken
01:44:40 <CrazyM4n> oh yiss
01:44:43 <CrazyM4n> it's working more
01:44:56 <pharaun> working is good :)
01:45:00 <CrazyM4n> only slightly
01:45:15 <pharaun> eh
01:45:28 <CrazyM4n> As in, it's only slightly working
01:45:54 <pharaun> haha
01:46:14 <CrazyM4n> Okay, I got the whole thing working
01:46:16 <CrazyM4n> Down to the point
01:46:29 <CrazyM4n> Where I can specify one argument to permutate the whole equation
01:46:31 <pharaun> i usually try to get someting that works then i refine from there
01:46:36 <CrazyM4n> Definately
01:46:42 <yeboot> "writing out long enumeration sequences manually is stupid."
01:46:50 <yeboot> best quote of learn you a great haskell
01:47:02 <CrazyM4n> So doing c^2 in the mandlebrot set makes it vertical
01:47:31 <CrazyM4n> http://prntscr.com/4r20co
01:48:00 <CrazyM4n> This is weeeird
01:49:10 <CrazyM4n> Okay, so time to do that whole zipWithM_ stuff
01:49:59 <CrazyM4n> jle`: What was zipWithM_ in again?
01:50:15 <jle`> Control.Monad
01:50:20 <CrazyM4n> Thanks
01:50:21 <jle`> @hoogle zipWithM
01:50:22 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
01:50:22 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
01:50:22 <lambdabot> Data.Generics.Twins gzipWithM :: Monad m => GenericQ (GenericM m) -> GenericQ (GenericM m)
01:51:16 <CrazyM4n> And it was so close to working
01:51:25 <jle`> make sure the types match up
01:52:00 <jle`> are you applying a function between two lists?
01:52:08 <CrazyM4n> zipWithM_ writeFile ["mandel"++(show p)++".ppm" | p <- [0,0.1..3]] [file p | p <- [0,0.1..3]]
01:52:12 <jle`> between paired-up elements of two lists?
01:52:15 <CrazyM4n> Yes
01:52:25 <CrazyM4n> It's telling me that the types of the numbers are wrong
01:52:35 <jle`> well...what types is it expecting, and what types do you have?
01:53:11 <CrazyM4n> Well
01:53:15 <CrazyM4n> That's what I'm trying to figure out
01:53:33 <jle`> try the error message :)
01:53:43 <CrazyM4n> Haha yea
01:54:26 <CrazyM4n> Okay, so it says that the type is ambigouos
01:54:30 <CrazyM4n> ambiguous
01:54:40 <CrazyM4n> So I have to write some type signatures it seems
01:54:55 <jle`> CrazyM4n: /b 17
01:54:57 <jle`> oh, sorry
01:55:39 <CrazyM4n> Okay, I'm too tired for this
01:55:40 <CrazyM4n> `Double' is applied to too many type arguments
01:55:40 <CrazyM4n> In the type signature for `file': file :: Double a => a -> String
01:55:52 <CrazyM4n> How do I say that "a" is a double?
01:55:53 <merijn> That seems an unlikely signature
01:55:57 <joelteon> Double -> String???
01:56:01 <CrazyM4n> Yes
01:56:05 <merijn> CrazyM4n: by replacing 'a' with Double :)
01:56:11 <CrazyM4n> Oh.
01:56:13 <CrazyM4n> Well then.
02:02:34 <CrazyM4n> I'm completely stumped
02:02:50 <jle`> did you try joelteon's solution?
02:03:10 <CrazyM4n> http://lpaste.net/456660847264006144
02:03:16 <jle`> sometimes i feel like ghc enforces a curfew for programming
02:03:21 <CrazyM4n> Wait, his solution?
02:03:35 <jle`> if it can tell that you are too tired to program effectively and might accidentally launch a  missile or something
02:03:40 <jle`> it gives you subtle hints to go to sleep
02:03:43 <CrazyM4n> It's 2:02 AM and I just want this to be finished lol
02:03:51 <jle`> in the form of type errors
02:03:58 <CrazyM4n> These don't even make sense
02:04:04 <jle`> the more tired you get, the more aggressive it gets at making sure you sleep
02:04:11 <CrazyM4n> But seirously do you see what's wrong there, lol
02:04:21 <CrazyM4n> Because I can't figure it out for the life of me
02:04:27 <pharaun> amen
02:04:35 <pharaun> jle` can confirm this :)
02:04:50 <pharaun> i was up at like 3am a while ago rather mad about some routing/type questions haha
02:04:53 <pharaun> go to bed
02:04:59 <CrazyM4n> I feel like no matter what I type it will type error
02:05:09 <CrazyM4n> The incorrect types flow from my fingertips
02:05:32 <CrazyM4n> Like a graceful wind of unreadable error messages
02:05:33 <mauke_> CrazyM4n: the mandelbrot type signature makes no sense
02:05:59 <CrazyM4n> mauke_: Then how would it make sense?
02:06:06 <pharaun> anyhow best of luck CrazyM4n , may i recommend sleep :) cos that's what i am going to be doing about now
02:06:17 <mauke_> CrazyM4n: depends on what you're trying to do, but Complex is not a class
02:06:34 <mauke_> so Complex a => ... is nonsense
02:06:34 <CrazyM4n> I think it is, it gave me errors saying Complex needed an arguemnt
02:06:44 <CrazyM4n> :t Complex
02:06:45 <lambdabot> Not in scope: data constructor ‘Complex’
02:06:47 <CrazyM4n> ...
02:06:48 <CrazyM4n> never mind
02:06:50 <mauke_> @kind Complex
02:06:51 <lambdabot> * -> *
02:06:55 <pharaun> parameterized type
02:06:56 <mauke_> it does take an argument
02:07:00 <mauke_> doesn't mean it's a class
02:07:04 <CrazyM4n> Oh.
02:07:05 <mauke_> @kind Show
02:07:06 <lambdabot> * -> Constraint
02:07:11 <mauke_> classes give you Constraint
02:07:13 <CrazyM4n> So how do I specify that it is a complex number?
02:07:23 <jle`> only Constraints can go on the left of =?
02:07:30 <mauke_> depends on which complex number
02:07:38 <mauke_> I'd go with Complex Double to begin with
02:07:42 <CrazyM4n> Yes
02:07:43 <jle`> (Complex Double) is a type
02:07:47 <CrazyM4n> Yes, indeed that is what I need
02:07:47 <jle`> types go on the right side
02:08:10 <CrazyM4n> Wow, that just fixed all the errors but 1
02:08:30 <CrazyM4n> C:\Users\spng453\scripts\mandelbrot\permutate\mandelimageperm.hs:18:25:
02:08:30 <CrazyM4n>     No instance for (Integral Double) arising from a use of `^'
02:08:30 <CrazyM4n>     Possible fix: add an instance declaration for (Integral Double)
02:08:40 <jle`> you can only use (^) on Integrals
02:08:45 <jle`> but Double is not an Integral
02:08:45 <CrazyM4n> Oh.
02:08:46 <mauke> yeah, you're doing ^ cPow where cPow is not an integer
02:08:48 <jle`> a member of the Integral typeclass
02:08:56 <CrazyM4n> So use **?
02:08:58 <mauke> yeah
02:09:13 <pharaun> @type **
02:09:14 <lambdabot> parse error on input ‘**’
02:09:17 <mauke> :t (^)
02:09:18 <lambdabot> (Num a, Integral b) => a -> b -> a
02:09:19 <mauke> :t (^^)
02:09:20 <lambdabot> (Integral b, Fractional a) => a -> b -> a
02:09:21 <pharaun> doh
02:09:22 <jle`> yeah, but with (**) you have to use it with the same type as the base
02:09:23 <mauke> :t (**)
02:09:24 <lambdabot> Floating a => a -> a -> a
02:09:24 <pharaun> never remember em
02:09:32 <jle`> so you need to convert your Double into a Complex Double
02:09:32 <CrazyM4n> Oh boy
02:09:36 <CrazyM4n> Yes
02:09:40 <CrazyM4n> And there was a function for it
02:09:42 <jle`> any ideas...?
02:09:43 <CrazyM4n> Which I don't remember
02:09:45 <mauke> (cPow :+ 0)
02:09:51 <mauke> now it's a complex number :-)
02:09:51 <jle`> it looks supa cute
02:09:53 <jle`> it is
02:09:54 <CrazyM4n> No, there was a better function
02:09:55 <jle`> (:+0)
02:09:58 <CrazyM4n> Oh.
02:10:06 <jle`> probably the cutest function in base
02:10:07 <CrazyM4n> Thought there was another function other than just doing that
02:10:11 <jle`> :t (:+0)
02:10:11 <pharaun> hoogle is helpful
02:10:12 <lambdabot> Num a => a -> Complex a
02:10:24 <CrazyM4n> I was looking it up
02:10:26 <pharaun> put that into hoogle and see
02:10:37 <jle`> @. hoogle type (:+0)
02:10:38 <lambdabot> Parse error:
02:10:38 <lambdabot>   Num a => a -> Complex a
02:11:13 <CrazyM4n> Apparently not
02:11:15 <jle`> there's also realToFrac i goss
02:11:34 <CrazyM4n> Ah, it worked
02:11:35 <CrazyM4n> mmm
02:11:36 <jle`> but why miss out an opportunity to use (:+0)
02:11:49 <jle`> actually it looks kinda creepy
02:11:54 <jle`> maybe you made the right choice
02:11:56 <mauke> > (:+ 0) (1 :: Integer)
02:11:57 <lambdabot>  1 :+ 0
02:11:57 <CrazyM4n> http://prntscr.com/4r2527 lol the floating point errors
02:12:02 <CrazyM4n> Now to turn it into a gif
02:12:42 <jle`> yeah, that's why we typically don't use enumerations with Double ;)
02:12:49 <mauke> > [0, 0.01 .. 0.5]
02:12:51 <lambdabot>  [0.0,1.0e-2,2.0e-2,3.0e-2,3.9999999999999994e-2,4.999999999999999e-2,5.99999...
02:13:03 <CrazyM4n> Haha I know, but it's not like it matters in the long run
02:13:12 <jle`> mauke just showed that it did ;)
02:13:20 <jle`> > length [0,0.01..0.5]
02:13:21 <lambdabot>  51
02:13:25 <jle`> > length [0,0.1..0.5]
02:13:26 <lambdabot>  6
02:13:29 <mauke> > intercalate " " (map (printf "%.02f") [0, 0.01 .. 0.5])
02:13:31 <lambdabot>  "0.00 0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.11 0.12 0.13 0.14 ...
02:13:34 <CrazyM4n> Hm
02:13:38 <jle`> er
02:13:41 <CrazyM4n> I guess
02:13:45 <jle`> > max [0,0.1..0.5]
02:13:46 <lambdabot>  <[Double] -> [Double]>
02:13:48 <CrazyM4n> Also hte gif looks super cool
02:13:52 <CrazyM4n> But not worth
02:13:54 <jle`> > max [0, 0.1 .. 0.5]
02:13:55 <CrazyM4n> Not worth at all
02:13:56 <lambdabot>  <[Double] -> [Double]>
02:14:03 <jle`> > maximum [0, 0.1 .. 0.5]
02:14:04 <lambdabot>  0.5000000000000001
02:14:10 <jle`> oh
02:14:27 <jle`> wait i misread things
02:14:30 * jle` is probably too tired too
02:14:38 <jle`> i thought that was an example where it overshoots the target
02:14:47 <jle`> by a significant amount
02:14:57 <jle`> so you stop at 0.6
02:14:58 <mauke> @check \x -> maximum [0, 0.01 .. abs x] <= abs x
02:15:00 <lambdabot>  *** Failed! Falsifiable (after 2 tests and 16 shrinks):
02:15:01 <lambdabot>  5.000007020362611e-3
02:15:15 <yitz> > maximum [0, 0.1 .. 0.49]
02:15:17 <lambdabot>  0.5000000000000001
02:17:02 <CrazyM4n> I'm making the colors better
02:17:04 <CrazyM4n> One second
02:17:40 <yitz> > maximum [0, 0.1 .. 0.45000000001]
02:17:43 <lambdabot>  0.5000000000000001
02:17:55 <yitz> > maximum [0, 0.1 .. 0.45]
02:17:57 <lambdabot>  0.4000000000000001
02:18:04 <jle`> heh
02:19:24 <CrazyM4n> Does anyone know how to apply something to the whole image in GIMP?
02:19:27 <CrazyM4n> instad of just by layer
02:23:34 <CrazyM4n> http://i.imgur.com/V0tLJRX.gif
02:23:41 <CrazyM4n> I don't even care of the colormap
02:23:46 <CrazyM4n> Here it is
02:23:57 <CrazyM4n> In all of it's glitchy, floaty point broken glory
02:24:17 <jle`> congrats :D
02:24:20 <CrazyM4n> This was a hard day's work
02:24:27 <CrazyM4n> lol
02:25:21 <mauke> .oO( you should be sleeping like a log )
02:25:21 <CrazyM4n> Well, time to sleep
02:25:38 <CrazyM4n> It was all worth it
02:25:48 <CrazyM4n> Good night, happy haskelling?
02:26:35 <jle`> night :) ty, you too!
02:29:03 <NikolajK> can I set up the type class of invertible functions?
02:29:31 <NikolajK> a direct subset of a->b
02:31:20 <vanila> NikolajK, that would require dependent types
02:31:31 <mauke> NikolajK: what would the methods look like?
02:31:43 <NikolajK> yeah, that's probably what I ask for
02:32:00 <jle`> you could fake one if you had a Universe typeclass that could enumerate all members of the domain
02:32:27 <NikolajK> I was thinking about there being invertible-function types extending a simply typed theory, but I assume that would mean you have subtyping. Then I wanted to know if Haskell can handle it with the type class construction
02:34:17 <jle`> class Universe a where universe :: [a]; invert :: (Universe a, Eq b) => (a -> b) -> (b -> a); invert f y = [x | x <- universe, f x == y]
02:34:44 <tac_> NikolajK: isn't that was Iso is for?
02:37:17 <NikolajK> funny
02:37:48 <NikolajK> it looks like it should work. does x <- universe always work?
02:37:49 <jle`> there should be a `head` there
02:37:57 <NikolajK> yeah, I know
02:38:08 <NikolajK> does x <- universe always work, or just with Ord's
02:38:18 <jle`> it doesn't work if it's not surjective
02:38:31 <NikolajK> if what isn't?
02:38:46 <jle`> then you'll have an empty result for the list comprehension
02:38:52 <jle`> and head will throw an error
02:38:59 <jle`> (when evaluated)
02:39:15 <jle`> you'll need to manually write Universe instances for your types, of course
02:43:48 <yeboot> list comprehensions are so cool
02:44:58 * hackagebot Decimal 0.4.2 - Decimal numbers with variable precision  http://hackage.haskell.org/package/Decimal-0.4.2 (PaulJohnson)
02:58:41 <bmuk> Hey you guys, what's your rule of thumb for when to use a function and when to use a class in other languages (i.e. python)
03:00:14 <bmuk> I always find myself reaching for the functional abstractions, sometimes this makes the code a tad messy and unidiomatic (i.e. python littered with maps, lambdas, reduce), but if I avoid them, I feel like I make too many unnecessary classes.
03:08:43 <Haskellfant> Is there some abstraction that makes it easier to validate input parameters (specifically getArgs) and then print an error message and exit if they're not valid instead of nesting if/else?
03:09:34 <Haskellfant> mempty seems to call error so using guard throws an exception which I would like to avoid
03:11:48 <quchen> Haskellfant: Use `case`? http://lpaste.net/111762
03:12:32 <Haskellfant> quchen: then I still need to nest if I have other stuff to validate later that'll force me to exit because I can't continue
03:13:57 <nadirs> Hi, I've written a cabal package X that contains both a library and an executable. I'm also writing a package Y: Can I build-depend on just the library part of X? Or do I need to split package X in two packages?
03:14:41 <quchen> Haskellfant: You can also pair Either and IO to short-circuit things that involve IO. It depends on your problem what the right solution is.
03:15:05 <Haskellfant> quchen: that could actually be a good idea, thx
03:15:29 <quchen> nadirs: Shouldn't build-depends only consider libraries anyway?
03:16:23 <nadirs> quchen: I don't know, I'm putting package X's name in Y's build-name property
03:16:40 <nadirs> you mean I should just put module names?
03:16:45 <nadirs> let me try...
03:17:28 <quchen> No, I mean just put X in Y's dependencies and you're fine.
03:18:32 <nadirs> quchen: oh, so as long as I don't import the executable modules they aren't pulled in, right?
03:19:08 <quchen> I don't think you even can import the executable (only) modules
03:20:59 <nadirs> quchen: the original reason why I asked the question is that when I do "cabal install --dependencies-only", the dependencies of the executable part are pulled in, which I'd like to avoid
03:23:19 <quchen> That sounds strange.
04:05:04 * hackagebot histogram-fill 0.8.3.0 - Library for histograms creation.  http://hackage.haskell.org/package/histogram-fill-0.8.3.0 (AlexeyKhudyakov)
04:28:06 <Haskellfant> is it possible to write something in parens as infix? e.g: lift `((.) . (.))` connectTo
04:28:40 <moop> `((.) . (.))` looks like boobs
04:28:59 <Haskellfant> moop: well it's called the boob operator :)
04:29:00 <moop> or an owl
04:29:13 <Haskellfant> at least I heard people refer to it like that
04:29:24 <zipper> Oh man writing haskell after really setting up emacs with haskell-mode and ghc-mod is AWESOME!!
04:29:31 <CasW> Hey guys, why do I get a parse error on input `|' on the second | in this piece of code? http://pastebin.com/qDZrDGKP
04:30:23 <yony45> https://www.facebook.com/SoccerTips4Sure
04:30:33 <Eduard_Munteanu> Haskellfant, no
04:30:40 <Haskellfant> Eduard_Munteanu: hm k
04:30:42 <Haskellfant> thx
04:31:52 <bakibour> three nipples though ...
04:32:27 <Haskellfant> bakibour: genetic engineering
04:32:36 <bakibour> :)
04:32:45 <bakibour> Haskellfant: funky nick btw :)
04:32:52 <Haskellfant> thx
04:34:19 <benmachine> CasW: your indentation confuses me
04:34:48 <CasW> It does so for me, too. I haven't indented it properly yet.
04:35:31 <benmachine> CasW: 'where' doesn't attach to individual guards, it attaches to the whole… match thing
04:35:34 <CasW> (I know, bad programming practice. Also, I believe pastebin messed up the indentation I did make)
04:35:51 <CasW> Ah, that can be the problem, let's try it!
04:36:19 <benmachine> I think if you had both newMoves in the second where, changing the name of one of them, you'd do better
04:36:56 <CasW> Yeah; now I only get errors in my definition of newMoves :-P But I can take care of those
04:37:33 <benmachine> progress! :)
04:39:21 <CasW> Yeah, fixed it! :-) Thanks!
04:39:53 <fbrusch__> hi everybody
04:40:02 <fbrusch__> got this problem
04:40:09 <fbrusch__> I'm using aeson
04:40:30 <fbrusch__> I have a Map Text String
04:40:46 <fbrusch__> when I try to encode it
04:40:48 <fbrusch__> I get
04:41:10 <fbrusch__>   No instance for (Aeson.ToJSON                      (Map.Map Data.Text.Internal.Text String))     arising from a use of ‘Aeson.encode’
04:42:23 <fbrusch__> But in the documentation of Aeson
04:42:46 <fbrusch__> among ToJSON instances is
04:42:47 <fbrusch__> ToJSON v => ToJSON (Map Text v)
04:43:11 <fbrusch__> what's wrong with it?
04:48:02 <srhb> fbrusch_: Does String have a ToJSON instance?
04:50:07 <srhb> fbrusch__: If it does I guess you're not importing the instance correctly?
04:50:42 <latk> Are there any libraries that parse simple boolean algebra from strings ?
04:55:09 <fbrusch__> srhb: yes, String is ToJSON
04:55:39 <srhb> fbrusch__: Then I'm not sure what you're doing wrong. Works for me.
04:58:15 <srhb> fbrusch__: import Data.Aeson; import qualified Data.Map as M; import Data.Text; foo = encode (M.empty :: M.Map Text String) -- typechecks for me
05:04:13 <fbrusch__> srhb: fact is: in ghc-mod it typechecks also, but ghc gives the error!
05:04:45 <srhb> fbrusch__: Show your code.
05:11:41 <fbrusch__> shrb: maybe I solved, importing Data.Aeson.Generic
05:11:46 <fbrusch__> now it compiles
05:11:56 <fbrusch__> thanks a lot for your help!!!!
05:12:45 <srhb> fbrusch__: Strange, Data.Aeson should export the instances. Oh well.
05:32:25 <zipper> Your mom is so fat she can't have foldr used on her.
05:33:59 <Benzi-Ju1ior> hey anyone here an expert on xmobar ?
05:34:08 <Benzi-Ju1ior> can't get the battery monitor to work
05:35:55 <augur> zipper: how do you know thats not just because my mom isn't a list, huh?
05:35:57 <augur> HUH?
05:36:24 <zipper> augur: Darn. I hadn't thought of that.
05:37:26 <sagittarian|2> @src liftM2
05:37:26 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
05:40:43 <AshyIsMe> well, someone found a way to get mueval to run out of memory
05:40:51 <AshyIsMe> i wonder if lambdabot is also susceptible
05:41:58 <AshyIsMe> https://twitter.com/smdiehl/status/516139775557132288
05:43:03 <AshyIsMe> hmm, the time limit is exceeded in lambdabot and it survives
05:43:10 <AshyIsMe> maybe i need to tweak the settings
05:44:33 <AshyIsMe> i've "solved" the reliability issues anyway:  while :; do lambdatwit; sleep 60; done
05:48:09 <ion> Your init should be able to restart the process.
05:51:27 <yeboot> is there like 'a mathmatician guide to haskell' anywhere
05:51:44 <yeboot> like for list comprehensions I get that <- is like \in (TeX)
05:53:49 <quchen> I don't think analogies are going to help much there.
05:54:01 <benmachine> they kind of do
05:54:02 <quchen> List comprehensions are a fairly small and simple thing.
05:54:17 <benmachine> list comprehension syntax is directly inspired by set-builder syntax, I believe
05:54:30 <yeboot> yeah that's what I read in uh
05:54:33 <yeboot> the beginning of learn you a great haskell
05:54:50 <quchen> I recommend learning that and not the analogies. For example, "<-" takes out elements in list order, while mathematically ∈ says nothing about order.
05:56:04 <sagittarian|2> learn the definition of (>>=) for lists and meditate on that for a long time, till you reach enlightenment
05:56:20 <Redz> i'm writing on a UI toolkit. for flexibility, should i use
05:56:20 <Redz> `type UI = Event -> UI -> IO Picture; type Middleware = UI -> UI`
05:56:20 <Redz> or something like `RWST Event Picture UI m a` ?
05:56:23 <Taneb> Is there a library that can read a .hs file and tell me which modules are imported?
05:56:25 <quchen> Yeah that's clearly going to help understanding list comprehensions for a beginner.
05:56:50 <yeboot> yeah it doesn't that's a good point quchen
05:57:03 <sagittarian|2> list comprehensions are like for looks
05:57:06 <sagittarian|2> *loops
05:57:09 <sagittarian|2> just look at python
05:57:14 <quchen> If you know mathematical set syntax and learn list comphrehensions you'll recognize a lot of similarities. I don't think starting with the similarities is the right way.
05:57:15 <sagittarian|2> that's not the hard thing to understand
05:57:31 <yeboot> sagittarian|2: where did you get the idea I'm having a hard time with them, just wondering
05:57:57 <ddellacosta> the hard things to get are different for everyone, and hard at different times, for different reasons, that's the problem
05:58:02 <yeboot> quchen: I can respect that
05:58:07 <ddellacosta> "there's no royal road to ..."
05:58:13 <sagittarian|2> yeboot: by half paying attention to the conversation here
05:59:22 <yeboot> ah, well I'm not having a hard time with list comprehensions, and thinking of them like for loops instead of list constructors is kind of confusing, though I can see why that comparison would be made (as whatever you write is per-element)
05:59:54 <quchen> Oh, and list comprehensions aren't very important to continue reading LYAH (nor in general, for that matter). Don't get hung up on it.
06:00:13 * hackagebot glib 0.13.0.2 - Binding to the GLIB library for Gtk2Hs.  http://hackage.haskell.org/package/glib-0.13.0.2 (HamishMackenzie)
06:00:26 <yeboot> I'm not hung up on it, I was just wondering, since it has relative mathmatical equivalences, if there was a list of similarities to math
06:00:44 <yeboot> between haskell and mathmatical notation
06:00:53 <ddellacosta> yeboot: I'm not sure about a mathematician's guide to haskell, but have you checked out the Typeclassopedia? http://www.haskell.org/haskellwiki/Typeclassopedia
06:01:26 <yeboot> I will
06:02:04 <ddellacosta> I find it's kind of takes off where LYAH leaves off, in a more rigorous fashion
06:02:10 <ddellacosta> *it kind of
06:02:37 <ddellacosta> although, not sure you said you were reading that, so nevermind
06:02:50 <ddellacosta> I guess it was quchen who referenced LYAH
06:02:55 <sagittarian|2> yeboot: everything in haskell has similarities to math
06:03:19 <sagittarian|2> haskellers like nothing better than to compare haskell's properties to mathematical ideas
06:03:30 <Redz> everything has similarities to math ...
06:03:36 <ddellacosta> er, one may even say that it is based in mathematical ideas, if one wanted to
06:03:52 <benmachine> haskell is a programming language, not a field of mathematics
06:03:56 <benmachine> it's mostly for programming
06:04:06 <benmachine> it's perhaps closer to maths than any other mainstream language, but still
06:04:30 <benmachine> someone who writes haskell is a programmer, not a mathematician
06:05:40 <Redz> probably both. :p
06:06:43 <quchen> yeboot: If it helps, mathematically you might write "primes { p : p ∈ ℕ, p > 1, no number smaller than p divides it }", and in Haskell that reads "[ prime | prime <- [2..], not (any (\n -> mod prime n == 0) [2..pred prime]) ]"
06:07:30 <quchen> Where "number smaller" should not be 1
06:08:08 <quchen> So "p <- [2..]" is "p can take values of the natural numbers starting at 2", and the rest is the prime business
06:08:28 <ddellacosta> yeboot: oh! Don't know why I didn't think of this first: http://fldit-www.cs.uni-dortmund.de/~peter/PS07/HR.pdf ("The Haskell Road to Logic, Math and Programming")...maybe that's up your alley too.
06:18:44 <yeboot> thanks! ddellacosta
06:22:07 <ddellacosta> yeboot: sure thing, I hope it helps!
06:45:03 <modest_mouse> Can anyone explain to me what (w:x@(y:z)) is? I am trying to read up on it but I don't even know what to call it to read about it.
06:45:16 <geekosaur> as-patterns
06:45:20 <modest_mouse> thanks
06:46:19 <geekosaur> so thtat deconstructs a list with at least 2 elements; first element is w; the rest of the list is x, which is further broken down as a first element y and the rest in z
06:51:24 <modest_mouse> So does that mean (w:x@(y:z)) would take a init (x), and assign to it the head of the init (y) and the init of that list (z)?
06:51:51 <vanila> (w:x@(y:z)) is the pattern (w:y:z), and it binds x=y:z
06:52:16 <vanila> f (w:x@(y:z)) = .. is the same as f (w:y:z) = let x = y:z in ...
06:52:22 <doismellburning> :t (@)
06:52:23 <lambdabot> parse error on input ‘@’
06:52:43 <modest_mouse> thanks
06:53:52 <sivteck> > let z:x@(y:w:ws) = "buhaha" in x
06:53:54 <lambdabot>  "uhaha"
06:58:44 <yashi> What's the fastest way to generate an NxN lattice of random values which can be either 1 or -1. Ideally I'd want the data type to be Data.Array.IO I thin.
06:58:47 <yashi> k
07:00:46 <ryantm_> yashi, Data.Array.IO is a module
07:01:32 <ryantm_> By fastest do you mean lowest CPU usage?
07:02:46 <yashi> ryantm_: Yeah
07:04:56 <ryantm_> yashi, Do you already have something working at all?
07:06:23 <chpatrick> hi
07:06:30 <chpatrick> does anyone know why parseOnly ((,) <$> many1 anyChar <*> string "bar") "foobar" fails?
07:07:00 <chpatrick> "not enough input"
07:07:08 <chpatrick> shouldn't many1 backtrack if it consumes too much?
07:07:12 <stepcut> Is there a caching hackage proxy server? Rather than pull directly from hackage, I'd like to have a local server that I talk to, which automatically updates from the real server on-demand, caching all the packages locally
07:07:27 <chpatrick> this is with Data.Attoparsec.Text
07:07:54 <modest_mouse> how do I look at the functional composition of . in the prelude?
07:08:29 <ryantm_> stepcut Might want to ask on #hackage, also, it looks like hackage-server has a mirroring option.
07:08:43 <stepcut> yeah, mirroring is overkill
07:08:45 <stepcut> but I will ask on hackage
07:09:18 <yashi> ryantm_: Not yet..
07:09:44 <ryantm_> modest_mouse, Do you mean the definition of . ?
07:10:18 <ryantm_> modest_mouse, http://hackage.haskell.org/package/base-4.7.0.1/docs/src/GHC-Base.html#.
07:10:19 <modest_mouse> ryantm_: yes
07:10:31 <modest_mouse> ryantm_: thank you
07:11:02 <ryantm_> modest_mouse, Hoogle does a good job of letting you click through to the haddock documentation, which has source links.
07:11:25 <modest_mouse> ryantm_: I'll remember that. thanks again
07:13:09 <XyzBoot683> Need to take someone down ? Crash a CS Server ? Check out www.booter.xyz the best stresser out there ! Power Proof - http://i.imgur.com/Fk3QZg7.png Youtube Video -  http://youtu.be/KMPjwnB-pXY
07:17:16 <arboris> chpatrick, how is it magically supposed to know that you don't want it to consume all characters
07:17:23 <arboris> that is what  the first parser does
07:17:45 <chpatrick> well, string "bar" should fail and then it would backtrack to trying one less character no?
07:18:04 <arboris> no
07:19:38 <chpatrick> why not?
07:19:38 <chpatrick> many v = some v <|> pure []
07:19:49 <arboris> it is assymetric in the left and right argument of <*> i think
07:20:11 <yashi> Maybe something like newArray ((1,1), (10,10)) (if randomRIO (1, 2) == 1 then -1 else 1) :: IO (IOArray (Int, Int) Int)
07:20:17 <yashi> But it doesn't compile
07:20:19 * hackagebot enclosed-exceptions 1.0.1 - Catching all exceptions from within an enclosed computation  http://hackage.haskell.org/package/enclosed-exceptions-1.0.1 (jcristovao)
07:20:42 <arboris> also try does the backtracking
07:20:45 <chpatrick> let dotStar = return [] <|> ((:) <$> anyChar <*> dotStar) in parseOnly (dotStar <* string "bar") "foobar"
07:20:49 <chpatrick> attoparsec doesn't have try
07:20:53 <arboris> well
07:20:58 <chpatrick> as in it always does it
07:21:05 <chpatrick> that fails too
07:24:06 <Eduard_Munteanu> It does have a 'try' but it's a noop.
07:24:17 <ryantm> yashi, What's the error?
07:26:18 <chpatrick> so it's weird right?
07:27:40 <modest_mouse> Does referential transparency mean that a value assigned to a variable will always be that value? I can't find a formal definition
07:27:57 <doismellburning> modest_mouse: it means you can replace a usage by its definition
07:28:11 <doismellburning> modest_mouse: https://en.wikipedia.org/wiki/Referential_transparency_(computer_science)
07:28:17 <modest_mouse> doismellburning: thanks
07:28:27 <ryantm> and the reverse too!
07:29:28 <lpaste> yashi pasted “No title” at http://lpaste.net/111772
07:29:37 <yashi> ryantm: there
07:32:44 <ryantm> The type of randomRIO (1, 2) cannot be compared with a number like that
07:33:03 <ryantm> yashi, randomRIO :: Random a => (a, a) -> IO a
07:34:01 <arboris> chpatrick, have you tried switching string "bar" and the other parser?
07:34:23 <chpatrick> what do you mean?
07:35:05 <chpatrick> I mean string "foo" <*> many1 anyChar works but it's not what I want to do
07:35:25 <arboris> string "bar" <*> many1 anyChar
07:35:33 <arboris> instead of the other way around
07:35:40 <yashi> ryantm: So how do I change 1 into "IO" 1 so as to be able to compare them?
07:35:41 <chpatrick> but that means the opposite
07:35:48 <chpatrick> "bar" followed by some chars
07:35:55 <chpatrick> I want to match the chars before the "bar"
07:37:26 <ryantm> yashi, You are trying to make your matrix not all all the same value, right? I'm not so sure you can make newArray take a function that will generate that.
07:38:34 <chpatrick> yashi: what are you trying to do?
07:38:51 <yashi> I'm trying to generate an NxN 2D array of random values, which could be either 1 or -1.
07:38:57 <chpatrick> what kind of array?
07:39:07 <yashi> Data.Array.IO ideally
07:39:19 <yashi> (for efficiency)
07:39:26 <arboris> hm you are right
07:40:53 <arboris> well you could do it manually, by matching everything except b and then manually patch it up
07:41:07 <yashi> ?
07:44:17 <hexagoxel> chpatrick: let many'' f g = do { x <- f; (xs,y) <- many'' f g; return (x:xs,y) } <|> (,) [] <$> g in parseOnly (many'' anyChar (string "bar")) "foobar"
07:44:40 <chpatrick> yashi: randArray n = getStdGen >>= newListArray ( ( 1, n ), ( 1, n ) ) . map (\i -> i * 2 - 1) . randomRs (0, 1)
07:47:02 <yashi> chpatrick: Thanks
07:47:06 <chpatrick> thanks hexagonel
07:47:13 <chpatrick> *hexagoxel
07:47:21 <chpatrick> any idea why the naive way doesn't work though?
07:48:01 <yashi> Not sure..
07:48:15 <yashi> BTW I get this in GHCI: No instance for (Show (IO (a0 (t0, t10) e0))). How can I check out that it does indeed work in GHCI?
07:48:25 <chpatrick> give it a type signature
07:48:36 <chpatrick> randArray 10 :: IO (IOArray ( Int, Int ) Int)
07:51:31 <hexagoxel> chpatrick: i have a feeling, but can't describe it well: because backtracking does not happen over (>>=).
07:55:06 <hexagoxel> look at (>>=)'s implementation
07:55:52 <marvin-hh> What's the point of using a functional programming language to write an imperative algorithm inefficiently?
07:56:13 <hexagoxel> chpatrick: what they mean by saying "attop always backtracks" is just in comparison to parsec, where a <|> b does not backtrack if a consumed input, i think
07:56:26 <marvin-hh> The very existence of IOArrays just means that the sufficiently smart compiler hasn't arrived yet.
07:58:02 <hexagoxel> marvin-hh: whats the point of asking loaded questions? ;)
07:58:38 <benzrf> that question is LOADED
07:58:43 <benzrf> clearly its been out drinking all night
08:12:20 <srhb> marvin-hh: I suppose that's not entirely untrue. Part of the justification lies not just in functional programming, but in other strengths of Haskell. That said, being able to easily write functions that manipulate IO Arrays is still really, really nice.
08:13:09 <mauke> it's possible to use haskell as a better C
08:14:07 <mauke> (some things may get in your way, like lack of exec*, and argv[0] is surprisingly hard to get at)
08:14:09 <srhb> Then again, I don't really see why you consider it inefficient.
08:16:29 <modest_mouse> is head a higher order function?
08:16:35 <mauke> no
08:16:37 <modest_mouse> or tail?
08:16:39 <mauke> no
08:16:40 <modest_mouse> that's what I thught
08:16:41 <modest_mouse> thanks
08:18:46 <srhb> modest_mouse: Generally HOFs are functions that either take functions as their argument or return a function. With that definition, though, any multi-parameter function in Haskell could be considered a HOF
08:19:42 <modest_mouse> srhb: I underestand that. I wasn't sure about how a list is defined in haskell though, I guess it's just a simple data type. but the way you parse it is really weird, so I wasn't sure.
08:19:50 <mauke> @src []
08:19:50 <lambdabot> data [] a = [] | a : [a]
08:20:17 <srhb> modest_mouse: Because : is infix perhaps? I don't know exactly why you consider it weird. :)
08:20:38 <srhb> modest_mouse: we could make data List a = Cons a (List a) | Empty
08:21:01 <mauke> wrong order
08:21:23 <srhb> mauke: Hmm?
08:21:31 <modest_mouse> What is backwards recursion? When a value has to be evaluated before the value of a recursive function is returned?
08:21:41 <mauke> you put Empty last
08:21:49 <benzrf> mauke: doesnt matter
08:21:50 <mauke> if you derive Ord, you're going to see some funky stuff
08:21:50 <srhb> mauke: Does it matter?
08:21:58 <benzrf> oh
08:22:01 <srhb> I see.
08:22:12 <mauke> modest_mouse: never heard of it
08:22:19 <modest_mouse> mauke: really?
08:22:20 <hc> would those "custom lists" be handled as efficiently?
08:22:21 <modest_mouse> dang
08:22:43 <mauke> hc: yes, modulo rewrite rules and stuff
08:22:59 <hc> rewrite stuff... that's what i meant ;)
08:23:11 <mauke> you can do that in a library
08:26:13 <zwer_a> mauke argv[0] == getProgName, no?
08:26:35 <mauke> no, getProgName is basename(argv[0])
08:26:59 <mauke> that is, getProgName assumes that argv[0] contains a path, and strips everything up to the last slash
08:27:31 <mauke> technically speaking it's not even getProgName
08:28:09 <mauke> it's withProgName (or the the internal setter)
08:28:18 <mauke> so you can't even fix it from inside
08:55:39 <Haskellfant> Is it possible to specify an alternative url for a dependency an a .cabal file? ofc I can install it from a local .cabal file in another directory before running cabal install --only-dependencies, but I'd like to automate this more.
09:07:15 <modest_mouse> I'm trying to write a function that compares a value, x, against a list, [y], and returns the same list, except values less than x are now x. I am trying to use recursion but I keep getting these errors: http://pastebin.com/n48q4cux
09:07:53 <mauke> remove your type signature
09:08:03 <mauke> well, or fix it
09:08:15 <vanila> hello
09:08:19 <mauke> you know what, keep the type signature. the code is confused
09:08:21 <modest_mouse> mauke: I don't know how to define what type it should be. just a -> a-> a?
09:08:39 <modest_mouse> mauke: I guess it's confused right about at x
09:08:46 <mauke> the ( , ) part is wrong
09:08:50 <modest_mouse> yeah
09:08:54 <mauke> your function doesn't take a tuple
09:08:55 <modest_mouse> I don't know how else to specify it
09:08:59 <mauke> what
09:09:04 <mauke> you do it right there in line 3
09:09:14 <mauke> separate arguments
09:09:35 <modest_mouse> mauke: so just floorList x y@(w:z)?
09:10:01 <mauke> yeah
09:10:04 <modest_mouse> thanks!
09:10:14 <mauke> that should give you better errors
09:10:19 <modest_mouse> lol
09:10:27 * hackagebot cairo 0.13.0.1 - Binding to the Cairo library.  http://hackage.haskell.org/package/cairo-0.13.0.1 (HamishMackenzie)
09:10:29 * hackagebot pango 0.13.0.1 - Binding to the Pango text rendering engine.  http://hackage.haskell.org/package/pango-0.13.0.1 (HamishMackenzie)
09:10:54 <mauke> spoilers: floorList x ys = map (max x) ys
09:11:41 <modest_mouse> mauke: I don't want to use map. I need to understand it before I take short cuts lol
09:11:49 <modest_mouse> thanks though
09:11:49 <doismellburning> @src map
09:11:49 <lambdabot> map _ []     = []
09:11:50 <lambdabot> map f (x:xs) = f x : map f xs
09:12:13 <ChristianS> modest_mouse: map is very useful, and not hard to understand
09:12:31 <mauke> modest_mouse: yeah, you should write it manually first
09:13:20 <doismellburning> fair
09:13:56 <modest_mouse> mauke: So, is there a way I can specify in type signature the fact that I use two different types in my input?
09:14:07 <mauke> modest_mouse: what two types?
09:14:14 <modest_mouse> mauke: Int and []
09:14:23 <mauke> yes
09:14:28 <mauke> put Int and [] in your type signature
09:14:43 <modest_mouse> ...lol
09:14:47 <modest_mouse> man, I think I might need a break
09:15:28 * hackagebot gtk3 0.13.0.1 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk3-0.13.0.1 (HamishMackenzie)
09:18:00 <chewy_> will we get OverloadedRecordFields in next GHC version?
09:20:28 * hackagebot gtk 0.13.0.1 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk-0.13.0.1 (HamishMackenzie)
09:25:28 * hackagebot webkitgtk3 0.13.0.1 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkitgtk3-0.13.0.1 (HamishMackenzie)
09:26:47 <chewy_> too bad it did not make it to ghc before haskell platform got updated
09:30:16 <td123> chewy_: https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-7.10.1 "This will finally be available in GHC 7.10
09:34:23 <SteveZanu> How can I filter  "IO [FilePath]"? If the list is of type "IO [FilePath]" then how can I do something like:  filter (== "bash") theList
09:34:33 <MagneticDuck> ello, I need some help with Network.Socket
09:35:17 <MagneticDuck> I'm implementing a client side of a protocol that involves a client sending a UDP packet to a server and having the server send a bunch of info in seperate UDP packets
09:35:21 <mauke> SteveZanu: fmap it
09:35:34 <MagneticDuck> is there any simple reccomended way to treat that UDP socket as a kind of stream?
09:35:46 <MagneticDuck> (supplied some time-delta to use as a timeout?)
09:35:59 <MagneticDuck> (asking about library functions here, not feasibility of implementation)
09:36:14 <MagneticDuck> SteveZanu: functors
09:36:21 <MagneticDuck> @type <$>
09:36:23 <lambdabot> parse error on input ‘<$>’
09:36:27 <MagneticDuck> @type (<$>)
09:36:29 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:43:12 <Cale> SteveZanu: A value of type IO [FilePath] is not a list
09:43:25 <Cale> SteveZanu: It's an action which if executed would produce a list
09:44:25 <Cale> SteveZanu: So, perhaps you want something like  do files <- getFileList; return (filter (== "bash") files)
09:44:47 <SteveZanu> Ok thx guys. It works.
09:44:48 <Cale> SteveZanu: which itself will be an IO [FilePath], that is, an action which if executed will produce a (filtered) list of files
09:45:15 <MagneticDuck> it's more like a burrito
09:45:18 <Cale> Or indeed, you can use fmap, or (<$>) which is a synonym
09:45:24 <Cale> pls no burrito
09:45:31 <MagneticDuck> spacesuit?
09:45:39 <Cale> NO
09:45:43 <MagneticDuck> kk :[
09:46:09 <SteveZanu> What is preffered <$> or fmap?
09:46:17 <MagneticDuck> metaphors like these are as useful as penguins
09:46:25 <MagneticDuck> SteveZanu: <$> is an infix operator
09:46:28 <Cale> SteveZanu: I would tend to only use <$> when I'm also using <*>
09:46:30 <Cale> But that's just me
09:46:39 <Cale> Some people like it a whole lot more :)
09:48:06 <Cale> /bin/ls is like a burrito whose filling is a list of files <-- if we applied these terrible analogies to other settings
09:49:03 <zrho> Cale: sounds tasty
09:49:06 <benmachine> I don't think anyone has ever sincerely thought that a burrito was a good analogy for a monad
09:49:29 <simpson> Well, like burritos, monads are delicious and spicy.
09:49:30 <benmachine> except insofar as my discovery of both greatly enriched my life
09:50:31 <f-a> https://twitter.com/donsbot/status/512871214663348224 I got the ADT, but eval?
09:52:14 <monochrom> I think of it as a joke analogy. so when I saw "Currito - curry burrito", I immediately thought Applicative. :)
09:52:38 <zrho> But not every burrito is a curry burrito.
09:53:23 <monochrom> yeah well a joke cannot match reality in every aspect
09:53:35 <zrho> Real life does not seem to implement the applicative monad proposal then.
09:53:46 <freeman42> is it allowed to use guards on functions defined in a where clause? http://codebunk.com/b/5868632/
09:53:55 <f-a> pfffft
09:53:57 <MagneticDuck1> let's see... how would I get an IO action to time out and terminate with some simple library function that's not going to make me learn threading in haskell
09:54:05 <f-a> there is only *one* monad tutorial analogy that works
09:54:17 <doismellburning> f-a: "you could have invented monads"?
09:54:34 <MagneticDuck1> nah I think f-a's going to keep us in suspense
09:54:59 <f-a> ok
09:54:59 <mauke> freeman42: wtf is that?
09:55:00 <f-a> hear
09:55:07 <f-a> "Monads are like a great ocean
09:55:12 <f-a> they are GREAT"
09:55:19 <vanila> f-a, what's the ADT?
09:55:29 <vanila> f-a, or are you asking what eval is
09:55:32 <f-a> g- guys, w-w-as that funny?
09:55:43 <monochrom> MagneticDuck1: the package "async" has stuff for that
09:55:49 <zrho> it made me kind of sad.
09:55:55 <freeman42> mauke, https://dl.dropboxusercontent.com/u/25584776/ShareX/2014-09/2014-09-28_17-54-52.png
09:56:04 <f-a> vanila: I don't know what eval is. I saw it in Lisp?
09:56:13 <vanila> f-a, ill make an example to explain
09:56:24 <f-a> okie
09:56:25 <MagneticDuck1> freeman42: WHAT IS THAT
09:56:30 <mauke> freeman42: sounds like project euler
09:56:37 <zrho> It's codewars.
09:56:38 <mauke> freeman42: why are you posting text as an image?
09:56:39 <monochrom> MagneticDuck1: sorry, actually GHC already comes with System.Timeout for that.
09:56:47 <vanila> f-a: http://lpaste.net/111774
09:56:48 <MagneticDuck1> cool
09:57:00 <freeman42> mauke, because it is not code, it is codewars.com
09:57:02 <chewy_> td123: thanks!
09:57:07 <mauke> freeman42: you've lost me
09:57:07 <vanila> Arith is a trival programming language that lets you add numbers together, eval gives its semantics
09:57:24 <MagneticDuck1> monochrom: yay looks great
09:58:11 <freeman42> mauke, getting 'parse error (possibly incorrect indentation or mismatched brackets)' when trying to use guard in a where clause so I am not sure if it is possible
09:58:12 <f-a> vanila: I guess it could be rephrased, with a gigantic approximation "write the types and the top level function to clear your mind"?
09:58:29 <chewy_> about OverloadedRecordFields, will that allow us to have a list of objects that have certain fields?
09:58:37 <vanila> f-a, I don't think so
09:58:43 <f-a> oh
09:58:58 <mauke> freeman42: what's your code?
09:59:14 <slomo> freeman42: no haskell, not even to vote for? (on codewars.com)
09:59:21 <freeman42> mauke, http://codebunk.com/b/5868632/
09:59:29 <mauke> freeman42: I'm not falling for that again
09:59:30 <freeman42> slomo, they added haskell a few days ago
09:59:46 <freeman42> mauke, falling for what? :-??
10:00:18 <mauke> that page puts up some kind of input box. when I click it away, it's blank (apart from a loading indicator)
10:00:24 <mauke> and it wants to load flash
10:00:29 <mauke> it looks like some kind of exploit thingy
10:00:42 <slomo> freeman42: don't see it here :) only js, coffescript, ruby and python... and various stuff to vote for but nothing with h between groovy and java
10:01:00 <freeman42> mauke, o.O it prompts for your name, dunno about any exploit, that is how the site works
10:01:07 <f-a> vanila: rereading the example and your words it feels clearer now, but again, say I am developing a text adventure, is 'eval' the gameloop (give the types semantics?)
10:01:10 <mauke> I'm not giving random sites my name
10:01:25 <monochrom> and me, I am not even giving random false names.
10:01:35 <freeman42> slomo, it is not mentioned on the front page yet but if you enter the site you can solve Haskell problems
10:01:42 <slomo> freeman42: ah nice, thanks :)
10:01:48 <vanila> f-a, it might be! you could apply the idea in lots of situations like that
10:02:27 <freeman42> slomo, https://dl.dropboxusercontent.com/u/25584776/ShareX/2014-09/2014-09-28_18-01-18.png
10:02:30 <f-a> last question vanila , why calling it eval? Isn't lisp eval something different? (not that we should follow what those dudes do)
10:03:08 <vanila> f-a, it's the same as lisp: eval takes abstract syntax and interprets it as code
10:03:30 <freeman42> mauke, just type whatever, you don't have to be that honest with your name xD
10:03:35 <mauke> freeman42: no
10:03:43 <freeman42> use 'the incredible spiderman'
10:03:49 <mauke> too much effort
10:04:53 <freeman42> mauke, ok, there you go: http://lpaste.net/7818349670098272256
10:04:54 <f-a> mhhh I see vanila , thanks
10:05:31 * hackagebot webkit 0.13.0.1 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkit-0.13.0.1 (HamishMackenzie)
10:05:54 <shiona> freeman42: what's that the screenshots are taken from?
10:05:58 <mauke> freeman42: broken indentation
10:06:13 <mauke> freeman42: 'where' doesn't start a layout block, the token after 'where' does
10:06:17 <mauke> i.e. 'fives'
10:06:30 <mauke> and your guards aren't indented more than 'fives'
10:06:50 <mauke> (this is why people start a new line after 'where')
10:08:18 <freeman42> mauke, I keep playing with indentation :D still can't get it right
10:08:44 <freeman42> shiona, ss taken with sharex and from codewars.com
10:09:11 <shiona> freeman42: ok, codewars seems invite only or something
10:09:56 <freeman42> shiona, you just need to sign-up or something, unless something changed since I signed up
10:10:28 <shiona> aa, that exercise was the sign up form
10:10:38 <monochrom> freeman42, make sure lines 6-7 are to the right of "five".
10:11:37 <mauke> freeman42: https://www.fpcomplete.com/project/65033/S741Hm2jho can you see this?
10:15:32 * hackagebot gtk2hs-buildtools 0.13.0.2 - Tools to build the Gtk2Hs suite of User Interface libraries.  http://hackage.haskell.org/package/gtk2hs-buildtools-0.13.0.2 (HamishMackenzie)
10:16:09 <freeman42> mauke, yeah, I can see it. I'm rather speechless right now, was using the same IDE, pasted your code over what I had and it still shows the error o.O "Main.hs@6:11-6:11 parse error (possibly incorrect indentation or mismatched brackets)"
10:20:12 <freeman42> mauke, it was some IDE problem, worked after reload, thank you for help :) "guards work in where close" - noted
10:26:23 <Forkk> Oh my god... IxSet is awesome...
10:26:48 <Forkk> I've always wanted a map where the keys were a field in the value
10:28:53 <sinelaw> what would you call this property of some function f:  f a b = (f a) . (f b) ?
10:29:12 <sinelaw> oops.
10:29:31 <sinelaw> what would you call this property of some function f:  g (f a b) = f (g a) . (g b) ?
10:30:10 <mauke> a type error?
10:30:30 <sinelaw> ;)
10:30:44 <sinelaw> let me rephrase that.
10:31:00 <pyrtsa> sinelaw: Looking for this maybe? http://en.wikipedia.org/wiki/Distributive_property
10:31:20 <sinelaw>  g (f a b) = (g a) . (g b)
10:32:05 <SteveZanu> Are there any sites for Haskell that collect videos, sites like pyvideo.org, but for Haskell?
10:32:27 <sinelaw> pyrtsa, almost
10:33:22 <sinelaw> SteveZanu, the closest thing I know is school of haskell: no videos, but interactive tutorials: https://www.fpcomplete.com/school
10:34:11 <sinelaw> you could say that f distributes with g but becomes identical to function composition
10:34:19 <sinelaw> when it's on the outside
10:34:25 <zq> ghc core makes me hate my life
10:34:37 <sinelaw> at least it's worth hating?
10:35:02 <sinelaw> zq, why?
10:39:14 <glosoli> Is there something like 4clojure, but for Haskell ?
10:40:17 <solarus> sinelaw: if f is identical to function composition when it is "outside" then isn't it always identical to function composition
10:40:50 <sinelaw> solarus, no because "a" and "b" are not functions
10:41:12 <solarus> I think they have to be
10:41:15 <solarus> or hmm
10:41:16 <solarus> no
10:41:23 <sinelaw> in my case they are maps
10:48:45 <sinelaw> quickcheck explodes (hangs) while testing a property. how can I know what's going on?
10:59:37 <DrSkyLizard> Is there a bot here that can execute code?
10:59:57 <vanila> > "yes"
10:59:57 <chrisdone> lambdabot
10:59:59 <lambdabot>  "yes"
11:01:00 <DrSkyLizard> Can I talk to it privately? What is the help command?
11:02:07 <ChristianS> DrSkyLizard: you can just /query lambdabot
11:02:35 <DrSkyLizard> ChristianS: I've tried to send it a message with /msg lambdabot help but no response
11:03:42 <DrSkyLizard> nvm, found the website
11:04:15 <zq> any idea why Data.Text.word doesn't loop fusionize?
11:04:28 <monochrom> lambdabot's help command does not say things very directly. but I can tell you something for now. you can ask it to evaluate expressions by for example "> even 4". it does not do IO.
11:06:57 <solarus> in any case, @help is the help command
11:10:06 <chrisdone> monochrom: ats learnings update: fun {a : type} id (x : a) : a = a defines identity function for boxed types. fun {a : t@ype} id (x : a) : a = a is identity on unboxed types. "type" and "t@ype" are "sorts" (like kinds). i still have no idea why such a horrific name as "t@ype" was chosen
11:10:33 <vanila> t@ype... lol
11:14:59 <ben_vulpes> good morning - what's a good place for a lisper to start learning haskell? i'm open to doing piles of reading before writing any code if you have books to offer, or tutorials if you'd suggest i dive in and learn by example.
11:15:32 <hpc> @where lyah
11:15:32 <lambdabot> http://www.learnyouahaskell.com/
11:16:09 <hpc> you can skim pretty quickly through chapters 1 and 2
11:16:33 <hpc> but there's some useful things in there to know, like setting up your environment
11:16:52 <hpc> from chapter 3 on is pure usefulness
11:17:03 <ben_vulpes> rad
11:17:41 <ben_vulpes> i'm in the middle of my 2 day 'hack emacs for newlang' phase
11:17:49 <hpc> heh
11:19:05 <sinelaw> chrisdone, btw, any news with your haskell portal?
11:19:08 <yitz> zq: it's supposed to
11:20:34 <chrisdone> sinelaw: my what?
11:20:54 <sinelaw> chrisdone, http://chrisdone.com/posts/haskell-lang
11:21:11 <chrisdone> oh, work is ongoing on that
11:21:13 <vektor> Hey folks. Just given the first few lines of http://lpaste.net/111779 -those are the only imports and the only LANGUAGE definition-, is there any chance of anything malicious happening, in a non-IO function below?
11:21:17 <chrisdone> at http://new-www.haskell.org/
11:21:31 <sinelaw> super cool!
11:21:41 <hpc> new-www?
11:21:54 <sinelaw> chrisdone, can I help?
11:22:20 <hpc> chrisdone: the whole header is really tall
11:22:27 <hpc> on my screen, there's no content above the fold
11:22:36 <hpc> other than that it looks top
11:23:31 <hpc> also it behaves a bit odd with javascript off, it says "<title here>" above the slideshow
11:25:06 <RegEchse> oh, my evaluation got killed. xD
11:25:38 * hackagebot keystore 0.6.1.0 - Managing stores of secret things  http://hackage.haskell.org/package/keystore-0.6.1.0 (ChrisDornan)
11:26:19 <DonZan> Somebody was asking about learning haskell. There's an amazing answer on stackoverflow http://stackoverflow.com/a/1016986/2290598 . I was following it recommendations including 99 problems and it simplied my learning process greatly
11:26:23 <chrisdone> sinelaw: issues are tracked here: https://github.com/haskell-infra/hl you can join #haskell-infrastructure and watch that project
11:26:37 <sinelaw> thanks
11:28:25 <vektor> Also... how do I fork a command to a different process?
11:28:59 <yitz> zq: looking at the source code: looks like words for strict Text should be fast but may not fuse. for lazy Text, it uses splitOn, which only fuses for singleton delimiters and only on each strict Text chunk.
11:29:44 <yitz> zq: if you have any ideas about how to speed it up, i'm sure bos would be pleased to hear about it.
11:30:06 <chrisdone> hpc: the video description thing will be fixed in the next deploy
11:30:26 <hpc> cool
11:31:04 <yitz> DonZan: it was ben_vulpes
11:31:12 <chrisdone> hpc: the design itself isn't going to change for a while
11:31:57 <ben_vulpes> thanks yitz, DonZan
11:32:02 <chrisdone> the content's the main focus now
11:32:04 <DonZan> ben_vulpes: I recommend downloading IHaskell, which is the interactive Haskell shell. It's amazing for prototyping and playing around with code. On linux you can install and start IHaskell with one command "sudo docker run -p 8778:8778 gregweber/ihaskell".
11:33:38 <ben_vulpes> DonZan: I appreciate the suggestion, but I prefer to waste time and ruin my own productivity configuring emacs.
11:34:07 <DonZan> ben_vulpes: One of the best features of IHaskell is that it uses HLint and gives you suggestions on how to correct your code to make it look better
11:34:33 <DonZan> ben_vulpes: I don't use emacs, but I'm sure there would be a hlint plugin somewhere
11:34:43 <ben_vulpes> yeah, i'm on it :)
11:39:43 <vektor> I found I've come across spawnCommand, but I'm not even sure it exists anymore.
11:39:53 <monochrom> chrisdone: ubuntu advertises a haskell-mode package version 13.10. is it really old and lame?
11:41:11 <chrisdone> monochrom: eh that's probably usable if you must
11:41:49 <chrisdone> probably not much has changed since then in the subset of haskell-mode that you use
11:49:45 <lpaste> gbwey pasted “parity” at http://lpaste.net/111780
11:51:04 <gbwey> hi can anyone help me understand this paste: it is using recursion and i can't seem to break it down
11:55:35 <rckrd> Hello, are there any Haskell Vim plugins that are worth installing?
11:55:40 * hackagebot liblastfm 0.4.1.0 - Lastfm API interface  http://hackage.haskell.org/package/liblastfm-0.4.1.0 (MatveyAksenov)
12:05:22 <CrazyM4n> Hey, is there an easy way to do hardware acceleration in haskell?
12:05:22 <ben_vulpes> i have some old haskell packages in my system, such that when i run `caball install present` caball complains that it's going to break unordered-containers, uniplate and hlint - what are the implications of using --force-reinstalls?
12:07:46 <thomaseding> Should I use (Writer (DList a)) over (Writer [a])? I'm not sure if (Writer [a]) has bad tell performance.
12:08:44 <monochrom> ben_vulpes: see my http://www.vex.net/~trebla/haskell/sicp.xhtml
12:09:03 <shachaf> thomaseding: It behaves the same as list append.
12:09:23 <shachaf> ((tell a >> tell b) >> tell c) turns into ((a ++ b) ++ c)
12:09:33 <shachaf> (tell a >> (tell b >> tell c)) turns into (a ++ (b ++ c))
12:09:35 <thomaseding> eeek
12:10:01 <ben_vulpes> thank you, monochrom
12:10:02 <chrisdone> thomaseding: what is the 'a' in your use-case?
12:10:06 <thomaseding> Char
12:10:57 <FreeFull> :t (>>)
12:10:59 <lambdabot> Monad m => m a -> m b -> m b
12:11:04 <FreeFull> I was hoping for fixity
12:11:05 <thomaseding> :i >>
12:11:11 <FreeFull> There is no :i
12:11:40 <thomaseding> Well it's left associative.
12:12:48 <chrisdone> thomaseding: right, there're more efficient ways made for text than to append list of strings
12:13:02 <chrisdone> thomaseding: do you want to output a lazy string or a strict one?
12:13:07 <silver> CrazyM4n, depends on what you mean by that, check if this meets your needs http://hackage.haskell.org/package/accelerate
12:13:27 <CrazyM4n> ok
12:13:40 <thomaseding> It's basically a haskell file to replace makefiles (cause makefiles suck)
12:13:57 <thomaseding> The bottleneck is in g++, so I suppose a slow string rep is ok
12:14:42 <chrisdone> thomaseding: something like this is probably what i'd use: https://hackage.haskell.org/package/text-0.11.0.5/docs/Data-Text-Lazy-Builder.html
12:15:37 <thomaseding> ah, nifty
12:17:26 <chrisdone> there was a post about how badly Writer performs on haskell-cafe comparing it to a strict StateT
12:17:49 <vanila> what about a zseq accelerated writer?
12:17:51 <thomaseding> chrisdone: Evan against a strict WriterT?
12:18:13 <chrisdone> lemmie find the post
12:19:02 <monochrom> wait a second, if you compare Writer.Lazy with State.Strict, that's unfair. (Writer alone refers to Writer.Lazy.)
12:20:45 <chrisdone> http://www.haskell.org/pipermail/libraries/2012-October/018599.html
12:21:27 <chrisdone> this is comparing against strict writer
12:21:46 <monochrom> that's a good comparison
12:23:24 <thomaseding> So... why isn't WriterT implemented with StateT then?
12:23:49 <dmj`> it has a Monoid constraint
12:26:14 <chrisdone> thomaseding: i don't know -- i think complaints that the type is "too big", you can do more than writing with it
12:26:46 <chrisdone> thomaseding: but i wouldn't worry about that stuff if your program is performing enough for your needs with [a] or Builder
12:27:09 * chrisdone didn't mean to complicate matters
12:27:21 <thomaseding> Righto. Thanks
12:28:06 <CrazyM4n> How do I stop a number from going into scientific form?
12:29:10 <thomaseding> http://stackoverflow.com/questions/8098457/how-do-i-get-to-haskell-to-output-numbers-not-in-scientific-notation
12:29:43 <thomaseding> showFFloat
12:29:54 <CrazyM4n> Thanks
12:31:21 <latk> How can I create an attoparsec parser that parses a word (any character up until a space) unless that word equals something ?
12:31:35 <latk> By something, I mean a specific word
12:32:58 <chrisdone> either use lookahead (if possible),  or check the return type and if it's equals something throw a parse error
12:33:12 <jellie> Is there something like x:xs for tuples? If I don't want to use fst and snd
12:33:15 <Eduard_Munteanu> Ew. The second.
12:34:01 <Eduard_Munteanu> jellie, pattern-match like (x, y)?
12:34:30 <chrisdone> empty or mzero or mempty or fail "foo"
12:34:38 <jellie> Eduard_Munteanu: I tried that with ((x:xs), (y, ys)) and it gives me an error.
12:34:42 <CrazyM4n> > map (Numeric.showFFloat Nothing) [1e-3,3e4]
12:34:42 <latk> chrisdone: Cool, thanks.
12:34:43 <lambdabot>  [<[Char] -> [Char]>,<[Char] -> [Char]>]
12:34:48 <CrazyM4n> ????
12:34:53 <jellie> ([Int], [Int])
12:35:01 <chrisdone> from the docs empty and mzero will do backtracking
12:35:04 <thomaseding> latk: The try combinator says "This combinator is provided for compatibility with Parsec. attoparsec parsers always backtrack on failure."
12:35:16 <jellie> Eduard_Munteanu: ([Int], [Int]) That's the type
12:35:29 <jellie> I am trying to pull the ints out of the tuple of lists.
12:35:47 * hackagebot needle 0.1.0.1 - ASCII-fied arrow notation  http://hackage.haskell.org/package/needle-0.1.0.1 (ScrambledEggs)
12:35:48 <chrisdone> i'm not sure whether fail "foo" for the Monad instance is actually isomorphic to mzero or throws a real _|_ error
12:36:04 <Eduard_Munteanu> latk, notFoo = do { w <- takeWhile1 (not . isSpace); guard (w /= "foo"); return w }
12:36:15 <chrisdone> ah, it's the former
12:36:21 <Eduard_Munteanu> fail works.
12:36:33 <Eduard_Munteanu> thomaseding, 'try' has no effect for attoparsec
12:36:42 <chrisdone> the mzero is implemented in terms of fail
12:37:32 <latk> Eduard_Munteanu: I should probably read about guard. Not really sure what it does..
12:37:36 <chrisdone> latk: if you want a meaningful error message when the word is equal to that thing, you should use fail. if it doesn't matter then guard (via mzero) should suffice
12:37:38 <chrisdone> @src guard
12:37:39 <lambdabot> guard True  = return ()
12:37:39 <lambdabot> guard False = mzero
12:37:45 <latk> Ah :p
12:37:55 <chrisdone> in the Parser type, mzero = fail "mzero"
12:38:03 <latk> Okay
12:38:11 <latk> I'll see if these work
12:38:12 <latk> Thanks!
12:38:18 <chrisdone> =]
12:39:17 <Eduard_Munteanu> Or tack on a (<?> "notFoo") $ do   at the start.
12:41:24 <Eduard_Munteanu> Or   guard (w /= "foo") <?> "unexpected 'foo'"
12:41:52 <sinelaw> :t fix
12:41:54 <lambdabot> (a -> a) -> a
12:42:13 <Eduard_Munteanu> (it's an attoparsec-specific combinator)
12:44:23 <vanila> :t fix fix
12:44:24 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ a -> a
12:44:25 <lambdabot>     Expected type: (a -> a) -> a -> a
12:44:25 <lambdabot>       Actual type: (a -> a) -> a
12:45:51 <merijn> vanila: That doesn't typecheck
12:45:59 <vanila> really?
12:46:00 <merijn> (a -> a) /= a
12:46:18 <chrisdone> did you just point out what lambdabot just told us? =p
12:46:38 <merijn> chrisdone: Well, I meant to type the explanation on one line, but I hit enter a bit too early
12:47:01 <chrisdone> to be fair to GHC, it's just as helpful in this case:
12:47:12 <chrisdone> cannot construct the infinite type: a ~ a -> a
12:47:24 <chrisdone> i say this because GHC is rarely helpful =p
12:47:41 <merijn> I hope someone implements Lennart's stuff for GHC :)
12:47:45 <chrisdone> me too!
12:47:50 * Eduard_Munteanu suggests "could not unify 'a' and 'a -> a'"
12:48:32 <merijn> Speaking of cool closed source stuff, I hope shake gets open-sourced too
12:48:36 <chrisdone> yeah. for people who're familiar with unification, "occurs checks" are a thing we know. but to the casual user, just saying "couldn't unify a and a -> a" would be easier
12:48:53 <chrisdone> merijn: huh? it's already open sauce
12:48:58 <chrisdone> http://hackage.haskell.org/package/shake
12:49:02 <merijn> chrisdone: There is an open source reimplementation
12:49:18 <merijn> It is not the shake used by Standard Chartered, afaik
12:49:32 <chrisdone> is theirs better?
12:49:36 <merijn> Or did that change?
12:50:19 <merijn> chrisdone: It might be my info is out of date :)
12:50:32 <Eduard_Munteanu> I went shopping for build systems the other day and there aren't many general ones, and certainly not very interesting.
12:50:49 * hackagebot dtab 1.0 - Harmonix (Guitar Hero, Rock Band) DTA/DTB metadata library  http://hackage.haskell.org/package/dtab-1.0 (mtolly)
12:50:51 <Eduard_Munteanu> Shopping for FOSS ones of course.
12:51:10 * Eduard_Munteanu should try 'shake'
12:51:42 <merijn> I recently switched our build system from "hand-written broken makefiles" to CMake. The build is much better now, but the CMake language is an abomination and a tragedy
12:52:07 <Eduard_Munteanu> Dunno what happened... a few years ago I'd go "hm, this looks interesting" with a lot of stuff. Now I'm just "oh, boring".
12:52:23 <merijn> It's downright embarassing so many people can be so enthousiastic about a language like CMake in 2014
12:52:58 <merijn> everything is strings :( (and I mean literally everything)
12:53:04 <Eduard_Munteanu> FWIW, I had a look at scons and it's pretty awful too.
12:53:24 <Eduard_Munteanu> (but at least it's full-fledged Python)
12:54:07 <merijn> The only down side of shake is that I probably can't convince my group to adopt GHC just for our build system >.>
12:54:09 <Eduard_Munteanu> rake seems a bit more decent and readable.
12:54:42 <mitchty> rake can get kinda hokey too though to be honest
12:54:48 <Eduard_Munteanu> Meh... a static build and minimal platform would probably be smaller than JVM. :)
12:55:01 <mitchty> though it is pretty easy for non ruby people to pick up
12:55:07 <merijn> Eduard_Munteanu: Yeah, but the JVM at least runs on sparc
12:55:44 <Eduard_Munteanu> Do people build on non-x86 or constrained platforms anyway?
12:55:59 <merijn> Eduard_Munteanu: Eh...yes?
12:56:10 <mitchty> i would imagine yes, things like the pi arent x86
12:56:11 <Eduard_Munteanu> Not 'for', mind... 'on'.
12:56:36 <merijn> Eduard_Munteanu: If we want to use the proper compilers, yes
12:57:35 <merijn> Eduard_Munteanu: suncc on sparc performs icc levels of compilation magic
12:57:50 <CrazyM4n> This is why I wanted hardware acceleration http://i.imgur.com/usHYV7r.gif
12:57:56 <Eduard_Munteanu> Proper compilers which have no proper way of doing cross-compilation. :P
12:57:57 <CrazyM4n> It took like 5 minutes to render
12:58:07 <CrazyM4n> And that´s like 4 minutes more than I was willing to wair
12:58:10 <CrazyM4n> wait
12:58:33 <Eduard_Munteanu> CrazyM4n, nice
12:58:44 <merijn> CrazyM4n: Time to get a GPU ;)
12:59:01 <CrazyM4n> merijn: Out of curiosity, how would I render this on a GPU?
12:59:03 <CrazyM4n> Using haskell
12:59:06 <CrazyM4n> ofc
12:59:35 <jellie> Is there a way to specify in a type signature that I want a 3 element list?
12:59:37 <CrazyM4n> Oh, using Accelerate
12:59:38 <CrazyM4n> ok
12:59:41 <merijn> CrazyM4n: Rendering is not what's taking time here, it's computing. I (semi-jokingly) meant running the computation using GPU acceleration
12:59:43 <jellie> Like [Int, Int, Int]
12:59:45 <Eduard_Munteanu> CrazyM4n, I'm unsure how hw accel could help unless you'd defer computation to the GPGPU
12:59:51 <CrazyM4n> Yea
12:59:58 <CrazyM4n> That´s kinda what I wanted to do
13:00:04 <merijn> CrazyM4n: tbh, I've never used accelerate so I'm not sure how good it is at implementing this
13:00:11 <CrazyM4n> But it´s probably really hard to implement
13:00:18 <CrazyM4n> There´s this http://community.haskell.org/~simonmar/slides/cadarache2012/7%20-%20accelerate.pdf
13:00:21 <HeladoDeBrownie> jellie, one way is to use (Int, Int, Int)
13:00:27 <Eduard_Munteanu> jellie, take a tuple instead of a list, or three separate args
13:00:52 <jellie> It's a tuple of lists that I want.
13:01:09 <Eduard_Munteanu> CrazyM4n, or perhaps encoding / compressing the output on the GPU
13:01:32 <HeladoDeBrownie> jellie, a tuple of lists with what?
13:01:38 <merijn> CrazyM4n: cuda is interesting to learn anyway, I haven't tried accelerate a lot yet, but my experience with "high level GPU programming tools" like that is their performance is pretty mediocre at best
13:01:39 <HeladoDeBrownie> +of what
13:02:09 <CrazyM4n> Ah, I see
13:04:08 <ben_vulpes> chrisdone: thank you for structured-haskell-mode :)
13:06:25 <sveit_> i have what seems to be a rather simple problem, but i'm having trouble coming up with a good functional algorithm for it: suppose i have some list [Int]; i want to generate [[Int]] of all the lists that can by obtained by repeatedly swapping elements whose absolute value of difference is greater than 1
13:06:51 <sveit_> so for example in the list [1,3,2,4], i would want to generate
13:07:02 <Sorella> fa
13:07:18 <sveit_> [[1,3,2,4],[3,1,2,4],[3,1,4,2],[1,3,4,2],[3,4,1,2]]
13:07:54 <Haskellfant> is there something like e -> Maybe a -> Either e a?
13:08:01 <Haskellfant> or should I just write it myself
13:08:25 <simpson> :t maybe
13:08:26 <lambdabot> b -> (a -> b) -> Maybe a -> b
13:08:52 <simpson> :t \e -> maybe e Right
13:08:53 <lambdabot> Either a1 a -> Maybe a -> Either a1 a
13:09:15 <simpson> :t \e -> maybe (Left e) Right -- derp
13:09:16 <lambdabot> a -> Maybe b -> Either a b
13:09:17 <Haskellfant> :t maybe (Left "error") (Right)
13:09:18 <lambdabot> Maybe b -> Either [Char] b
13:09:32 <Haskellfant> simpson: thx
13:09:41 <merijn> Haskellfant: Parentheses around Right are redundant
13:10:08 <Haskellfant> merijn: I know, but I didn't think before starting to write so I thought I might need to add something
13:10:50 * hackagebot tidal 0.4.13 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.4.13 (AlexMcLean)
13:11:24 <ben_vulpes> what is the "<-" called in haskell list comprehensions?
13:11:50 <HeladoDeBrownie> ben_vulpes, it doesn't really have a common descriptive name. Left arrow?
13:12:17 <merijn> ben_vulpes: I've heard some people call it "draws from", but it doesn't really have a name
13:12:33 <merijn> I guess you could call it "bind", since it's equivalent to <- in do notation
13:12:35 <Eduard_Munteanu> ben_vulpes, it's the same as the one in do-notation, really
13:12:55 <HeladoDeBrownie> merijn, that gets confusing if you also call (>>=) bind :)
13:13:07 <merijn> HeladoDeBrownie: Well, it *is* >>=
13:13:14 <HeladoDeBrownie> Almost, sure, but not exactly
13:13:31 <merijn> > [x | x <- [1..10], filter even]
13:13:33 <lambdabot>  Couldn't match expected type ‘GHC.Types.Bool’
13:13:33 <lambdabot>              with actual type ‘[a0] -> [a0]’
13:13:36 <Eduard_Munteanu> "assign"?
13:13:39 <merijn> hmm
13:13:46 <merijn> oh, duh
13:13:48 <Eduard_Munteanu> "<-" is a binder too.
13:13:50 <simpson> I've also seen it described as "draws from", but I can't remember which paper introduced it.
13:13:52 <merijn> > [x | x <- [1..10], even x]
13:13:54 <lambdabot>  [2,4,6,8,10]
13:14:18 <merijn> > do { x <- [1..10]; guard (even x); return x }
13:14:21 <lambdabot>  [2,4,6,8,10]
13:14:54 <merijn> > [1..10] >>= \x -> guard (even x) >> return x
13:14:56 <lambdabot>  [2,4,6,8,10]
13:15:18 <merijn> HeladoDeBrownie: It doesn't literately desugar to >>= in GHC, but it *is* exactly the same
13:15:46 <merijn> extensionally equal, however you wanna call it
13:15:56 <HeladoDeBrownie> merijn, ignoring the lambda and the case expression
13:16:30 <HeladoDeBrownie> at which point I don't think equality is the right word anymore
13:16:40 <merijn> That's why I said extensionally equal
13:17:24 <Eduard_Munteanu> You had good intensions. :P
13:19:36 <merijn> hmm, bollocks
13:20:36 <merijn> Any optparse-applicative users? I want to use its "subcommand" thingy, but unfortunately in my case the subcommand gets detected by an option flag, not a single command
13:49:16 <trap_exit_> actually, I have one more problem
13:51:16 <merijn> @hoogle Char -> Char -> Bool
13:51:17 <lambdabot> Data.Generics.Twins geq :: Data a => a -> a -> Bool
13:51:17 <lambdabot> Prelude (<) :: Ord a => a -> a -> Bool
13:51:18 <lambdabot> Data.Ord (<) :: Ord a => a -> a -> Bool
13:51:39 <merijn> There's no case insensitive Char/String comparison anywhere in base?
13:52:08 <shachaf> I don't think so, unfortunately.
13:52:26 <merijn> bleh
13:53:30 <benmachine> there's 'comparing toLower'
13:54:29 <merijn> oh, duh
13:54:44 <c_wraith> the only really proper unicode-aware comparison is in text, with comparing toCaseFold
13:55:15 <shachaf> benmachine: Does that always work?
13:55:28 <merijn> I know that, but I don't care about proper, I need "quick and simple" for matching command line arguments in a test program
13:55:42 <benmachine> shachaf: ...probably not
13:55:55 <shachaf> For a test program you can compare `on` toLower, sure.
13:56:05 <benmachine> although comparing Text.toLower is closer to correct
13:56:13 <merijn> shachaf: Should work good enough for me
13:56:29 <benmachine> if you want better than that, you need some proper actual strcoll thing
13:56:30 <monochrom> perhaps you like Data.CaseInsensitive
13:56:41 <merijn> Basically I just want the interface to be the same as my C++ program that uses strcasecmp
13:56:50 <benmachine> yes, Data.CaseInsensitive is actually pretty nice
13:57:05 <shachaf> > filter (\x -> toLower (toUpper (toLower x)) /= toLower x) ['\0'..]
13:57:08 <lambdabot>  "\181\305\383\837\962\976\977\981\982\1008\1009\1013\7835\8126"
13:57:28 <merijn> Except that means dragging in a bunch of extra dependencies for a test program where I give absolutely zero craps about correctness except for ascii :)
13:58:16 <shachaf> > filter (\x -> toUpper (toLower (toUpper x)) /= toUpper x) ['\0'..]
13:58:19 <lambdabot>  "\304\1012\7838\8486\8490\8491"
13:58:46 <shachaf> Well, that's something.
14:02:22 <shachaf> But sometimes changing case isn't even length-preserving, yes.
14:04:31 <merijn> Like for my favorite ffi ligature
14:05:03 <luite> shachaf: is that the case for Text?
14:05:38 <shachaf> luite: Yes, toLower will change the length of a Text.
14:06:11 <shachaf> I meant toUpper. Maybe toLower will too.
14:07:26 <shachaf> Yes, both of them will. And it's locale-dependent, too, I suppose.
14:07:31 <HeladoDeBrownie> toUpper "ß" == "SS". toLower "SS" == ???
14:08:49 <HeladoDeBrownie> Apparently, toLower "SS" == "ss". I wonder if there's a way to make it output "ß"
14:09:21 <HeladoDeBrownie> Or rather, a similar function with perhaps more parameters that will do that
14:09:29 <HeladoDeBrownie> I have no idea if that's actually useful, granted
14:09:42 <mauke> > toLower 'ẞ'
14:09:44 <lambdabot>  '\223'
14:09:59 <mauke> > toUpper '\223'
14:10:02 <lambdabot>  '\223'
14:10:08 <xplat> O_o
14:10:11 <HeladoDeBrownie> I' referring to Data.Text
14:10:31 <HeladoDeBrownie> ß is a German lower case character whose upper case is SS
14:10:40 <Angry> When trying to build with profiling ( -prof ) I'm getting the following error. Any ideas of how to fix it?
14:10:43 <Angry> Could not find module `Prelude'
14:10:43 <Angry>     Perhaps you haven't installed the profiling libraries for package `base'?
14:10:45 <HeladoDeBrownie> Obviously a function that cares only about Char cannot do this correctly
14:10:54 <mauke> ẞ is a german upper case character whose lower case is ß
14:11:07 <merijn> Angry: Well, did you install the profiling libraries for base?
14:11:10 <sagittarian> :t toUpper
14:11:12 <lambdabot> Char -> Char
14:11:18 <c_wraith> :t T.pack
14:11:20 <lambdabot>     Not in scope: ‘T.pack’
14:11:20 <lambdabot>     Perhaps you meant ‘BS.pack’ (imported from Data.ByteString)
14:11:22 <xplat> unfortunately, toUpper and toLower are still functions even in Data.Text
14:11:24 <Angry> no, how would I do so?
14:11:30 <Total_1mmersion> I'm new to cabal files and I'm getting this error even though I have "natural-numbers ==0.1.*" in my cabal file: Could not find module `Data.Natural'It is a member of the hidden package `n
14:11:30 <Total_1mmersion> atural-numbers-0.1.2.0'
14:11:40 <sagittarian> :t Data.Text.toUpper
14:11:41 <HeladoDeBrownie> mauke, is that in common use?
14:11:41 <lambdabot> Data.Text.Internal.Text -> Data.Text.Internal.Text
14:12:00 <mauke> HeladoDeBrownie: no
14:12:07 <mauke> but it's in unicode :-)
14:12:11 <xplat> supposedly the uppercase ß is only used on signage and things
14:12:26 <merijn> Data.Text is fairly correct for upper/lower case, but if you need more fancy things, look into text-icu
14:12:33 <merijn> That does things like locale aware casing, etc.
14:12:38 <HeladoDeBrownie> Neat
14:12:43 <mauke> (or use perl)
14:13:00 <xplat> text-icu will do the insane turkish casing?
14:13:36 <johnnyrichard> somebody know a good web framework? I tried *yesod* but didn't works
14:13:43 <mauke> Iı İi
14:14:28 <xplat> mauke: yeah, that insane turkish casing
14:14:29 <shachaf> Text.toLower of "İ" is "i\775"
14:14:45 <shachaf> (COMBINING DOT ABOVE)
14:14:47 <merijn> johnnyrichard: It depends what you're looking for in a web framework?
14:15:20 <merijn> johnnyrichard: (also there's a #yesod where people are probably better suited in explaining it's...complex installation, it's rather brittle I've heard)
14:15:25 <sagittarian> johnnyrichard, http://hotframeworks.com/languages/haskell
14:15:36 <mauke> shachaf: which İ is that?
14:15:55 * hackagebot keystore 0.6.1.1 - Managing stores of secret things  http://hackage.haskell.org/package/keystore-0.6.1.1 (ChrisDornan)
14:16:04 <shachaf> mauke: The single-codepoint version.
14:16:11 <shachaf> If that's what you mean.
14:16:20 <mauke> yeah
14:17:38 <GhostNuclei> 8===D---(_!_)
14:18:10 --- mode: ChanServ set +o mauke
14:18:36 <benzrf> what a dong
14:20:10 --- mode: mauke set -o mauke
14:26:31 <ben_vulpes> > :t head
14:26:33 <lambdabot>  <hint>:1:1: parse error on input ‘:’
14:26:50 <ben_vulpes> > help
14:26:52 <lambdabot>  Not in scope: ‘help’
14:26:57 <ben_vulpes> pah. docs, anyone?
14:27:24 <mauke> :t head
14:27:25 <lambdabot> [a] -> a
14:27:45 <benzrf> :t comparing length
14:27:46 <lambdabot> [a] -> [a] -> Ordering
14:27:52 <ben_vulpes> cool thanks.
14:27:52 <benzrf> -_-
14:27:53 <ben_vulpes> :t head
14:27:54 <lambdabot> [a] -> a
14:27:55 <ben_vulpes> :t **
14:27:56 <lambdabot> parse error on input ‘**’
14:28:06 <mauke> :t sortBy (comparing length <> compare)
14:28:07 <ben_vulpes> what's wrong with my mental model here?
14:28:07 <lambdabot> Ord a => [[a]] -> [[a]]
14:28:16 <jle`> :t (**)
14:28:17 <lambdabot> Floating a => a -> a -> a
14:28:20 <benzrf> :t (<>) `asAppliedTo` comparing length
14:28:21 <lambdabot> ([a] -> [a] -> Ordering) -> ([a] -> [a] -> Ordering) -> [a] -> [a] -> Ordering
14:28:28 <benzrf> o_O
14:28:32 <benzrf> what's the monoid instance?
14:28:50 <mauke> Ordering, lifted twice through (e ->)
14:28:59 <benzrf> damn
14:29:08 <ben_vulpes> this haskell shit is way mind bendy
14:29:08 <benzrf> ooooooooooooooooooooh i forgot about that!!!
14:29:14 <benzrf> shiit
14:29:17 <benzrf> > EQ <> EQ
14:29:19 <lambdabot>  EQ
14:29:20 <benzrf> > EQ <> LT
14:29:21 <lambdabot>  LT
14:29:23 <benzrf> > LT <> EQ
14:29:25 <lambdabot>  LT
14:29:26 <benzrf> > LT <> GT
14:29:27 <lambdabot>  LT
14:29:28 <merijn> mauke: Heh, I never thought of that, neat :)
14:29:29 <benzrf> OK
14:29:31 <mauke> > sortBy (comparing length <> compare) (words "this haskell shit is way mind bendy")
14:29:32 <lambdabot>  ["is","way","mind","shit","this","bendy","haskell"]
14:29:39 <benzrf> that is
14:29:42 <benzrf> that is hella clever
14:29:51 <benzrf> i never thought of multi-arg monoiding
14:29:53 <benzrf> shit
14:31:07 <ben_vulpes> when i say
14:31:12 <mauke> it's an old trick, from before <> existed
14:31:16 <ben_vulpes> :t (snd ("foo","bar"))
14:31:17 <lambdabot> [Char]
14:31:31 <benzrf> now THAT is an idiom
14:31:32 <ben_vulpes> that's returning the type of the return value of the evaluated function?
14:31:47 <mauke> it's returning the type of the expression you give it
14:32:12 <merijn> ben_vulpes: Type checking does not ever require evaluation
14:32:23 <ben_vulpes> ah right
14:32:36 <ben_vulpes> mauke: "the expression" being (snd ...)
14:32:49 <mauke> "..." :: [Char]
14:33:01 <mauke> ("...", "...") :: ([Char], [Char])
14:33:06 <mauke> snd :: (a, b) -> b
14:33:20 <ben_vulpes> hm
14:33:24 <mauke> snd ("...", "...") :: [Char]
14:33:33 <ben_vulpes> i think i get it
14:33:34 <johnnyrichard> merijn: thanks for help me
14:33:38 <mauke> (with a = [Char], b = [Char])
14:33:41 * ben_vulpes goes back to the studies
14:33:46 <johnnyrichard> sagittarian: thanks for help me
14:33:48 <merijn> ben_vulpes: Unification (the process used by typechecking) is a fun game of "fill the holes and solve the equations" :)
14:34:02 <mauke> there's a rule somewhere
14:34:29 <merijn> ben_vulpes: I would highly recommend occasionally grabbing a piece of paper and trying to manually write out the process of type checking once every while, until you get comfortable doing it in your mind
14:34:40 <mauke> if you have an expression (x y) and x :: A -> B and y :: A, then x y :: B
14:34:44 <merijn> I'm sure monochrom had a unfication write up somewhere, no?
14:35:01 <monochrom> no, I don't. I only have a trivial example somewhere.
14:35:06 <merijn> ah
14:35:15 <merijn> monochrom: You disappoint me :(
14:35:25 <monochrom> it's so trivial it only unifies (Bool, t) with (y, Char)
14:35:50 <ben_vulpes> merijn: sounds like my entire undergrad experience
14:36:00 <ben_vulpes> dem parallel eqn's
14:36:02 <merijn> mauke: Well, it's slightly more complex when x is polymorphic
14:36:02 <shachaf> merijn: You are probably thinking of http://www.vex.net/~trebla/haskell/prerequisite.xhtml
14:36:16 <mauke> merijn: how?
14:36:43 <merijn> mauke: You need intermediate equations to see if the type variables match up
14:37:17 <mauke> meh
14:37:34 <mauke> I'll just add more handwaving
14:38:11 <shachaf> If x :: forall a. a and y :: forall b. b, then x y :: forall c. c
14:39:13 <mauke> no, x y :: d
14:39:45 <tippenein> cabal install cabal-install fails on Network.URI and ghc-pkg check reveals basically everything as broken
14:40:16 <tippenein> I'm on osx.. don't think I ever had this much problem on linux
14:41:23 <merijn> tippenein: How did you install?
14:42:50 <hseg> shachaf, mauke: isn't that term malformed? x can be typed as a non-function type, no?
14:43:02 <merijn> hseg: No
14:43:18 <merijn> hseg: "forall a . a" means that it can have *all* types, including that of a function
14:43:23 <mauke> :t undefined undefined
14:43:24 <lambdabot> t
14:43:38 <merijn> That's why there only bottom can have type "forall a . a"
14:43:44 <merijn> s/there//
14:44:03 <hseg> Oh. So it's the infinite intersection of all types?
14:44:10 <sagittarian> tippenein, yeah network-uri was moved to a separate package
14:44:42 <sagittarian> you have to add network-uri as a build-depends to the .cabal file
14:45:03 <merijn> hseg: I'm not sure whether "infinite" is a sensible adjective there
14:45:23 <merijn> hseg: But yes, if we see types as "sets of values" then bottom is the value that inhabits all those sets
14:45:37 <merijn> s/the value/a value
14:46:37 <hseg> OK. And similarly, if it were well-formed haskell, then the type exists a. a would denote the universal type of which all terms are values, i.e. the "infinite" union of types, right?
14:46:40 <benmachine> I'm not sure whether undefined :: Int is the same value as undefined :: Char, I'm not sure it even makes much sense to ask that question
14:46:44 <ben_vulpes> succ 5.1
14:46:52 <ben_vulpes> > succ 5.1
14:46:54 <lambdabot>  6.1
14:47:09 <rudi_s> Hi. I have a list of key/value pairs which I want to access sorted after key (e.g. only the first 5 keys and their values). The key is not an integer, but a string (or maybe something else in the future). What is a good data structure for that? Thanks.
14:47:15 <ben_vulpes> what's the logic there, and where would i find the typeclass(?) implementing succ for floats?
14:47:21 <mauke> hseg: sounds right
14:47:28 <benmachine> ben_vulpes: the typeclass is Enum
14:47:52 <mauke> rudi_s: Map?
14:47:54 <merijn> rudi_s: Depends on the number of keys? Simplest hack solution is to just use a list?
14:48:58 <merijn> hseg: No, "exists a . a" says "this is a value of *A* type, but I'm not gonna tell you which"
14:49:22 <rudi_s> mauke: Does it store it sorted?
14:49:31 <mauke> rudi_s: yes
14:49:33 <rudi_s> merijn: Not very big, so speed shouldn't be an issue.
14:49:56 <rudi_s> mauke: Ah, nice. Thanks.
14:50:09 <merijn> rudi_s: Map is an efficient search tree, it has efficient functions for generating sorted lists (both ascending and descending)
14:50:21 <merijn> rudi_s: Map is probably the proper way to do it
14:50:26 <merijn> There's also
14:50:42 <merijn> :t take 5 . sortBy (comparing fst)
14:50:43 <lambdabot> Ord a => [(a, b)] -> [(a, b)]
14:50:45 <shachaf> Map doesn't let you have duplicate keys, though.
14:50:49 <rudi_s> merijn: Perfect. Thanks.
14:51:06 <merijn> rudi_s: Which takes a list of key/value tuples and gives you the first 5
14:51:18 <shachaf> merijn: Well, you do tell me which. It just doesn't do me any good.
14:51:39 <hseg> merijn: How does that contradict my statement? AFAICT, 1 :: exists a. a, 'a' :: exists a. a are both well-formed.
14:51:47 <merijn> ben_vulpes: Word of warning: The Enum typeclass for float is an evil misfeature
14:52:21 <hseg> merijn: But I'm waving hands in territory I don't understand well, so I might be spouting nonsense.
14:52:22 <rudi_s> merijn: Nice. The map will work fine for me.
14:52:31 <mauke> @let data BlackHole = forall a. BlackHole a
14:52:33 <merijn> hseg: Oh! I see what you're getting at. Yeah, that seems ok
14:52:34 <lambdabot>  Defined.
14:52:40 <mauke> :t BlackHole
14:52:41 <lambdabot> a -> BlackHole
14:52:47 <mauke> excellent
14:52:48 <jle`> :t BlackHole 5
14:52:49 <lambdabot> BlackHole
14:53:00 <jle`> :O
14:53:03 <jle`> what hath man wrought
14:53:29 <mauke> pure existentials
14:53:36 <merijn> ah, dammit
14:53:38 <jle`> > let getBH (BlackHole a) = a in getBH (BlackHole 5)
14:53:39 <lambdabot>  Couldn't match expected type ‘t1’ with actual type ‘a’
14:53:40 <lambdabot>    because type variable ‘a’ would escape its scope
14:53:40 <lambdabot>  This (rigid, skolem) type variable is bound by
14:53:40 <lambdabot>    a pattern with constructor
14:53:40 <lambdabot>      L.BlackHole :: forall a. a -> L.BlackHole,
14:53:42 <jle`> hehe
14:53:43 <merijn> Once again I need impredicative types :(
14:53:52 <merijn> And yet I have no way to have them :(
14:54:16 <jle`> :t map BlackHole [1..10]
14:54:17 <lambdabot> [BlackHole]
14:54:24 <ben_vulpes> merijn: it looks kinda funky, but i can never tell if that's my inadequate knowledge or language misfeatures
14:54:36 <jle`> i guess once you have a BlackHole it is basically identical to () for all intents and purposes
14:54:53 <merijn> :t map BlackHole [1..10] ++ map BlackHole ['a'..'g']
14:54:54 <lambdabot> [BlackHole]
14:54:57 <mauke> I think it would still keep its argument alive for GC purposes
14:55:05 <jle`> hm. really?
14:55:10 <merijn> jle`: Sure
14:55:15 <jle`> i guess because you can unsafeCoerce later
14:55:41 <hseg> damn you, unsafeCoerce. Always breaking the nice things.
14:56:05 <mauke> > BlackHole [1..10]
14:56:07 <lambdabot>  No instance for (GHC.Show.Show L.BlackHole)
14:56:07 <lambdabot>    arising from a use of ‘M77489235976636500618625.show_M77489235976636500618...
14:56:20 <merijn> ben_vulpes: No, Float's enum instance is awful, awful
14:56:21 <mauke> well then
14:56:21 <jle`> also i don't think there's anything built-in to detect if something is lost due to types
14:56:28 <merijn> ben_vulpes: It's worse than having "fail" in monad :(
14:56:39 <jle`> you know what's worse? its Eq instanace
14:56:49 <simpson> :t betterBH _ = BlackHole () -- there, now we can all share our BH
14:56:50 <lambdabot> parse error on input ‘=’
14:56:53 <merijn> jle`: No, that one at least makes sense in that it follows IEEE754
14:56:57 <jle`> ;)
14:57:04 <mauke> > fix fail
14:57:06 <lambdabot>  ""
14:57:17 <merijn> jle`: It's Enum has literally no redeeming qualities
14:57:17 <hseg> That's some interesting language GHC is using there. "type variable would escape its scope" "(rigid, skolem) type variable". What does it mean?
14:57:36 <jle`> people can say [1..] :: Double i guess
14:58:14 <mauke> http://daleharvey.github.io/Presentations/EUC-Stockholm-2011-11-03/img/mapreduce.png
14:58:36 <hpc> i love that comic
14:58:50 <ben_vulpes> merijn: i'm going to merrily compute along happy in the knowledge that i've discovered sore spots in haskell on like day 2 of playing with it
14:59:18 <merijn> ben_vulpes: Haskell is (unfortunately) not a perfect language :( But it's still better than most others :)
14:59:19 <ben_vulpes> does anyone know how to get ghci :set +s to return microseconds or nanoseconds?
14:59:32 <ben_vulpes> merijn: *shrug* how would i know?!
15:00:03 <rudi_s> Ah, I'm stupid. Map won't work for me. My problem is that the the list should be sorted after the value, but accessed by the key. Any idea for a good way to store that? And the list might get bigger, maybe a few thousand entries.
15:00:27 <merijn> Someone help me out, is there a way I can somehow retun a RankNType function in a data structure without ImpredicativeTypes?
15:00:39 <shachaf> merijn: newtype?
15:00:41 <merijn> GADT/existential wrapping in some way? Anything?
15:01:50 <merijn> shachaf: oh, whoo! For some reason I thought that didn't work...
15:02:09 <hseg> What did GHC mean above when it said that a "(rigid, skolem) type variable would escape its scope"?
15:02:38 <merijn> hseg: Example code?
15:02:39 <jle`> i don't really know what the words mean, but i know it has to be an error
15:02:42 <mauke> is that the new head explosion?
15:02:48 <jle`> > let getBH (BlackHole a) = a in getBH (BlackHole 5)
15:02:50 <lambdabot>  Couldn't match expected type ‘t1’ with actual type ‘a’
15:02:50 <lambdabot>    because type variable ‘a’ would escape its scope
15:02:50 <lambdabot>  This (rigid, skolem) type variable is bound by
15:02:50 <lambdabot>    a pattern with constructor
15:02:50 <lambdabot>      L.BlackHole :: forall a. a -> L.BlackHole,
15:02:50 <merijn> mauke: No
15:02:56 <mauke> why not?
15:03:01 <shachaf> I think that used to be head explosion in old versions of GHC.
15:03:08 <jle`> hseg: do you see why the function can't exist?
15:03:19 <merijn> mauke: Because it's an error, you're trying to do something you can't
15:03:28 <mauke> merijn: what's your point?
15:03:53 <merijn> head explosion has so far (for me) always been a GHC bug, whereas this is a bug in the written code
15:04:04 <mauke> head explosion isn't a ghc bug
15:04:18 <mauke> it's the error you get for trying to free bound type variables
15:04:25 <hseg> jle`: because then its type would be something like (exists a. a) -> b
15:04:45 <mauke> BlackHole -> (exists a. a)
15:04:53 <hseg> jle`: which you can't do because you have no guarantee that a and b are the same
15:04:55 <mauke> and you can't have naked existentials
15:05:06 <jle`> getBH :: forall a. BlackHole -> a
15:05:15 <jle`> meaning...you can "ask" for any `a` to come out of the BlackHole
15:05:26 <jle`> but this can't be
15:05:30 <jle`> it's like () -> a
15:05:34 <shachaf> Existentials are kind of odd.
15:05:46 <merijn> ooh, I think today I have a comonad usecase for the first time :D
15:05:52 <edwardk> hah
15:05:54 <shachaf> You can turn (exists a. (a, a -> Int)) into (exists a. a, exists a. a -> Int), but then it's useless.
15:06:42 <hseg> jle`: So basically, I'm saying that no matter what type I pick, I can turn a BlackHole into a value of that type?
15:06:47 <shachaf> Is there a dual oddness for universals?
15:06:47 <mauke> @let inspectBH :: BlackHole -> (forall a. a -> b) -> b; inspectBH (BlackHole x) f = f x
15:06:49 <lambdabot>  Defined.
15:07:04 <mauke> now you can look at the insides of a black hole
15:07:12 <jle`> hseg: yeah, that's what a function like (() -> a) would imply
15:07:25 <jle`> which is like a value :: a
15:07:51 <hseg> jle`: you mean a value :: forall a. a
15:07:56 <jle`> ah, yeah.
15:08:14 <merijn> edwardk: So is there comonad instance for "flip (->) a" in existence already?
15:08:23 <merijn> (type level flip, that is)
15:08:26 <hseg> OK. But what does GHC's specific error message mean? Not how does it arise, but what do the words mean?
15:08:31 <jle`> yeah, idk v.v
15:08:36 <shachaf> merijn: That's not even a functor.
15:08:54 <edwardk> merijn: i don't see how that is a comonad
15:09:15 <shachaf> Or rather it's a contravariant functor, which rather stops it from being a comonad.
15:09:20 <merijn> hmm, yeah I oversimplified an example by Tekmo, I think
15:09:25 <edwardk> merijn: instance Monoid e => Comonad ((->) e)   -- is a comonad
15:09:55 <edwardk> and dominic orchard has some interesting 'invariant functor' comonads
15:10:16 <mauke> no one knows what a skolem is
15:10:21 <mauke> I think it's some kind of monster
15:10:57 <hseg> Wait. I think I saw something like that a while back.
15:11:00 <hseg> Lemme check.
15:11:01 <merijn> edwardk: Lemme try and isolate what Tekmo's code is actually doing...it has extract/extend functions, but it's type is not directly a comonad because the kind doesn't match :\
15:12:29 <merijn> edwardk: I was thinking of the "builder" here: http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html
15:13:09 <merijn> oh, wait, that's the one you mentioned, I think
15:13:40 * ben_vulpes sees "objects" flees in terror
15:13:49 <hseg> mauke: Looking at Wikipedia, basically Skolemization converts existential typevars into functions of the universal typevars in whose scope they are.
15:14:06 <hseg> mauke: I don't see how this applies here though.
15:14:19 <hseg> https://en.wikipedia.org/wiki/Skolem_normal_form
15:14:54 <shachaf> I'm not sure that post that particularly helpful.
15:19:42 <hseg> So I guess that GHC recognizes that in forall a. a -> BlackHole, a's quantifier is morally an existential, meaning that after Skolemization, a is some opaque function of the in-scope universally quantified typevars, i.e. no typevars, i.e. a is an opaque constant.
15:19:44 <edwardk> ben_vulpes: good reaction
15:21:33 <ben_vulpes> pandering ;)
15:21:37 <holo> hi
15:25:37 <ben_vulpes> just out of curiosity, why do where clauses appear after guards?
15:26:00 * hackagebot nested-sets 0.0.1.0 - Nested set model implementation  http://hackage.haskell.org/package/nested-sets-0.0.1.0 (rakatan)
15:26:01 <merijn> ben_vulpes: Well, where else?
15:27:39 <ben_vulpes> before?
15:28:07 <ben_vulpes> i ask only as a derpy human who gets confused when things are referenced before they're assigned.
15:28:15 <ben_vulpes> (or can sometimes be easily confused by such)
15:29:28 <merijn> ben_vulpes: You could use let/in if you wanna define things prefix
15:29:43 <merijn> ben_vulpes: The problem is that you're still thinking of "assignment" :)
15:29:49 <mauke> ben_vulpes: why guards though?
15:29:55 <triliyn> ben_vulpes: the purpose of a where clause is to appear after everything. With a sufficiently descriptive name, this can be easier to read than the traditional order
15:29:55 <ben_vulpes> mauke: just working through LYAH
15:30:32 <ben_vulpes> merijn: what should i be thinking about instead of --
15:30:36 <ben_vulpes> ah.
15:30:37 <jle`> definitions :)
15:30:39 <ben_vulpes> equations and holes.
15:31:09 <mauke> > let foo = bar + 1; bar = 2 in (foo, bar)
15:31:12 <lambdabot>  (3,2)
15:31:30 <jle`> (foo, bar) ==> (bar + 1, 2) ==> (2 + 1, 2) ==> (3, 2)
15:31:53 <jle`> "foo is defined as bar + 1...so let's substitute that in there...  bar is defined as 2, so let's substitute that in there...
15:32:01 <merijn> ben_vulpes: names/definitions is the usual way to think of things
15:32:06 <jle`> "bar is defined as 2 so we can just sustitute that in there too...ok"
15:32:27 <merijn> ben_vulpes: Due to purity it's always possible to replace a name with the right hand side of it's definition
15:32:44 <merijn> ben_vulpes: Equality also works as a model, I guess
15:33:25 <ben_vulpes> merijn: all i know is building crappy models for computers in my head
15:33:56 <merijn> Hence why we use the = symbol. "bar = 1 + 2" literall says "the name 'bar' is equal to the expression '1 + 2'"
15:39:09 <enferex> How can I get the nth element from a IO(Foo, Bar) tuple.  If the tuple were not in the IO monad, id just call fst or snd respectively.
15:39:31 <mauke> fmap
15:39:37 <mauke> and IO ... is not a tuple
15:40:02 <enferex> IO(Foo, Bar) is a tuple isn't it?
15:40:06 <merijn> enferex: No
15:40:12 <mauke> it's an IO
15:40:14 <merijn> enferex: It is an IO action that produces a tuple
15:40:24 <mauke> similarly, [Int] is not an integer
15:40:26 <mauke> it's a list
15:40:27 <enferex> ohhh yep
15:41:15 <merijn> gah
15:41:23 <merijn> I made my code to typesafe :(
15:41:37 <merijn> Now my unsafe testing code broke :\
15:41:59 <hseg> Looking at https://ghc.haskell.org/trac/ghc/ticket/9621, it seems that sometimes, one would like to allow users of a polymorphic function to override it at certain types to provide more efficient versions, without adding that function to a typeclass. Has there been any research into this?
15:42:34 <mauke> specialize pragmas?
15:42:34 <merijn> hseg: The current solution for this in GHC is to use "RULES", but they're a bit brittle
15:42:47 <hseg> specialize pragmas?
15:42:49 <merijn> mauke: specialize is different
15:42:57 <mauke> oh, right
15:43:00 <mauke> rules it is
15:43:11 <hseg> How would you use RULES for this?
15:43:27 <hseg> And why can't we use a smaller hammer?
15:43:28 <merijn> hseg: Consult the GHC manual for examples
15:43:42 <hseg> OK.
15:43:46 <merijn> hseg: Oh, I'm not saying RULES is necessarily a good solution for this
15:43:49 <shachaf> You're asking for a pretty big thing (breaking parametricity).
15:43:59 <merijn> hseg: But what you're asking for is exactly why RULES exist
15:44:10 <hseg> Typeclasses already break parametricity, don't they?
15:44:10 <merijn> And yes, breaking parametricity makes baby Jesus cry
15:44:16 <merijn> hseg: No
15:44:48 <merijn> hseg: Typeclasses have the same semantics as passing in a dictionary
15:45:16 <merijn> hseg: They don't let you do "type-casing", what you are proposing lets you do exactly that
15:46:39 <shachaf> Yes, type classes do a similar thing. But at least the type class constraint is in the type.
15:46:47 <hseg> How does my proposal grant more typecasing power than typeclasses already do?
15:47:14 <shachaf> If I see f :: a -> a, I don't expect it to behave differently when a=Int because it can be more efficient for that case.
15:47:27 <shachaf> Did you propose something?
15:47:30 <hseg> OK, so restrict the proposal to constrained polymorphic functions, where specialisations can only be given for instances of the constraint.
15:48:29 <hseg> I proposed that given f :: TC a => a -> b, instance TC Ty, I should be able to write a specialisation f :: Ty -> b
15:48:35 <hseg> Without mucking up TC
15:49:05 <hseg> So, referring to https://ghc.haskell.org/trac/ghc/ticket/9621, I would be able to specialise e.g. length, without having to add length to Foldable.
15:49:15 <shachaf> Mucking it up? That's exactly what defining a type class is.
15:49:53 <hseg> TC is predefined and closed to change. That's the problem.
15:50:09 <shachaf> Right, that's the point.
15:50:20 <hseg> ?
15:50:42 <shachaf> Instead of general parametricity, you have a sort of constrained parametricity: If f :: Ord a => a -> a -> Bool, I know that f can only use Ord operations on a.
15:50:56 <shachaf> It can't just do whatever it wants.
15:52:00 <hseg> OK, sure. But now you're requiring that all typeclasses carry around huge dictionaries of all functions that could be optimized for them.
15:52:16 <hseg> e.g. Foldable must now carry length, null, elem, ...
15:52:34 <hseg> Wait.
15:52:37 <shachaf> Yes, it's not very nice.
15:52:40 <fread2282> you could maybe use RULES and SPECIALIZE?
15:52:42 <hseg> My proposal changes nothing.
15:53:12 <hseg> Well, actually, it allows extending a typeclass outside of its definition.
15:54:13 <shachaf> Yes, sort of.
15:55:38 <hseg> Might that not be desirable?
16:01:37 <modest_mouse> Hey guys. How do I go about reasoning through a list comprehension? So I know what it does. ex: [x | x <- xs, p x] The most I can get out of this, is that it applies the value of xs to x.
16:02:30 <AfC> Is it appropriate to put a job ad to haskell-cafe if it's a web dev role and "knowledge of Haskell strongly advantageous"?
16:02:46 <shachaf> Why is it advantageous?
16:03:01 <AfC> shachaf: because it'll save me having to teach them?
16:03:31 <modest_mouse> AFC: this isn't a job? Or was the comment not directed at me?
16:03:35 <Cale> modest_mouse: That says, "the list of x where x is chosen from the list xs, and such that p x is true"
16:03:44 <Sorella> modest_mouse: that one is equivalent to `filter p xs`, and `filter` is defined as `filter p [] = []; filter p (x:xs) = if p x then x : fitler p xs else filter p xs`
16:03:48 <hseg> modest_mouse: Translation of list comprehensions is given here: http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11
16:04:06 <modest_mouse> thanks guys
16:04:10 <Sorella> List comprehensions allow you to read that in the same way you'd read a description in set theory.
16:04:13 <Cale> But yeah, list comprehensions are really translated in terms of concatMap
16:04:35 <AfC> shachaf: (we're a Haskell shop now; I'm riding the line about whether or not to require Haskell or at least FP experience in the next set of hires I need to make, but I need them to do web dev, not internal systems hacking)
16:04:42 <hseg> modest_mouse: For your specific example, it reduces to concatMap (guard p) xs
16:06:22 <merijn> AfC: In other words, you're advertising a haskell web dev position?
16:06:26 <hseg> Which in very simple terms ends up being concat (map (\x -> if p x then [x] else []) xs), which you and GHC realize can be rewritten as filter p xs. (derivation left as exercise to the reader)
16:07:11 <hseg> shachaf: So is it desirable to extend typeclasses as I suggested?
16:07:24 <merijn> AfC: I would say that any job that involves haskell hacking is approprite for -cafe and r/haskell, also check out haskellers.com
16:07:39 <AfC> merijn: well, I guess I'll write it that way if I send it to -cafe, sure :) But the pool of people who are actually "qualified" haskell web devs fit in the corner of a very small bar and were, co-incidentally, all drinking together a couple weeks ago in Sweden :)
16:08:09 <AfC> merijn: so saying it's a "*Haskell* web dev position" may be too limiting.
16:08:45 <AfC> Maybe I'm being too pessimistic.
16:08:59 <merijn> AfC: The point is that, if the job is hacking haskell, then you should say that and THEN it's on topic. Whether you *require* haskell experience is a seperate issue
16:09:13 <AfC> point
16:09:44 <AfC> Yes. Very good point. Thanks merijn
16:09:48 <merijn> AfC: I think you're taking a very convoluted way of saying "we don't require haskell experience", but that seems pointless to state on a haskell mailing list/reddit
16:10:09 <merijn> In which case I would just add that you are willing to hire junior/learning haskell devs
16:11:54 <AfC> "The server-side work you'll be doing is in the Haskell programming language, so previous experience with Haskell or another Functional Programming language would be tremendously advantageous."
16:12:19 <luite> AfC: the main problem is that you don't allow people to work remotely from Hawaii ;)
16:12:20 <AfC> merijn: (I'm less worried about the specific audience; posts in one place get around to others, so the language has to be kinda general)
16:12:30 <AfC> luite: it's *terrible*, I know
16:13:15 <AfC> luite: and then there are those damn academics who insist on staying at university. Who do they think they are? Just because they're advancing the knowledge of humanity doesn't mean they should have it easy.
16:13:15 <merijn> AfC: I'd just say "Haskell Web Dev (Experience preferred, but not required"
16:13:23 <merijn> AfC: Keep it simple :)
16:13:37 <AfC> merijn: I don't do bullet points :)
16:13:53 <merijn> AfC: I'm already bored by the 4th word of your prose ;)
16:13:53 <kazagistar> is there some library like quickcheck that tries to ensure that it hits the edge cases more often? IE actually tries out really large integers, etc
16:14:09 <merijn> kazagistar: Pretty sure QuickCheck already tris to do that
16:14:49 <AfC> luite: planning to move to Australia any time soon? :)
16:15:25 <luite> AfC: hehe no plans, but i might visit again late this year or early next
16:16:04 * hackagebot persistent-mongoDB 2.0.8.1 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-2.0.8.1 (GregWeber)
16:16:07 <AfC> luite: if you swing by you've totally got a place to plug in and hack. I have a desk set aside for visiting haskellers.
16:17:19 <kazagistar> merijn: if I generate a [Int], it never tries any outside of "sized", which is passed down from above, which seems kinda silly, since the upper and lower bounds actually cannot be tested without some ugly hacks
16:18:59 <luite> AfC: :) if the weather is as good as it was in May, I might enjoy working outside better though
16:21:33 <kazagistar> sized $ \n -> inBounds fromInteger (choose (-toInteger n, toInteger n)) -- inBounds is a hack to make this code the same for all Integrals, and not use Bounded
16:22:48 <luite> kazagistar: it's impossible to sample uniformly randomly from the integers
16:23:04 <AfC> kazagistar: well admittedly Integrals can be kinda big
16:23:26 <AfC> Integer*
16:23:36 <hseg> In http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.112.7819 section 6.1 (published 10y ago), Oleg suggested a way to allow local typeclass instances. Why wasn't this adopted?
16:23:37 <kazagistar> luite: from Int it certainly is, but I was more asking for something that samples more from likely "edges" like 0 and maxBound
16:24:15 <merijn> hseg: I think that question may have more success on the mailing lists :)
16:24:22 <hseg> Why?
16:24:26 <zipper> How is writing to disk, screen or a file impure? Because we can change the position at which we write?
16:24:31 <hseg> Asynchronous response?
16:24:50 <zipper> Because the file might be missing? In which case we would create one?
16:24:54 <jle`> zipper: consider an operation that reads from a file
16:24:58 <merijn> hseg: That, and lots of people likely to know historical answers are on the mailing list but not here :)
16:25:06 <zipper> jle`: Ok, go on
16:25:08 <jle`> your write-to-disk operation will affect how that read will behave
16:25:11 <kazagistar> I am not saying quickcheck isn't awesome, I am just trying to see if the "test generation" can be made more intelligent or targeted, you know?
16:25:14 <jle`> if you do it before, or after
16:25:15 <luite> kazagistar: normally that's something you do with the size parameter. for Bounded you could define a small size as distance to an 'interesting' value, not just the absolute size
16:25:17 <merijn> hseg: Never seen Oleg around here, for example, but he's on some of the lists
16:25:44 <merijn> zipper: Because writing twice is not the same as writing once?
16:25:57 <hseg> merijn: OK, will do. Have some more questions, can you tell me which I should add to that mail?
16:26:24 <zipper> I really don't see how this means that the function can be given same input twice and give different output
16:26:29 <zipper> merijn: jle` ^^
16:26:50 <hseg> Is there any use for open type families besides associated data types? How do you write functions that use instances of such families?
16:27:01 <merijn> zipper: Because writing to disk is observable outside the program
16:27:18 <luite> kazagistar: for unbounded integers, what do you have other than absolute size?
16:27:26 <merijn> hseg: That usually involves GADT and DataKinds abuse :)
16:27:27 <hseg> zipper: What type would you give to a function f that writes to a file, keeping in mind that it must be referentially transparent?
16:27:38 <luite> kazagistar: i can imagine something based on bit patterns, or nim
16:27:41 <zipper> merijn: and that is bad and impure? Nothing should happen that is observable outside the program?
16:27:54 <hseg> Oh. Right. Dammit, I always forget about the type hackery.
16:28:01 <merijn> zipper: That's not bad, but it means it's not referentially transparent
16:28:05 <luite> kazagistar: numerical properties like number of divisors
16:28:14 <merijn> hseg: I have an example lying around, actually
16:28:29 <merijn> hseg: It happens to use a closed type family, but the same approach should apply to open
16:28:30 <zipper> hseg: I don't know.
16:28:38 <luite> kazagistar: but that's also rather specific, doesn't work anymore for Rational
16:28:45 <zipper> I am just not seeing how IO is such a monster as people claim.
16:29:00 <hseg> zipper: And therefore, e.g. executing it twice isn't the same as executing it once, leading to let x = foo in x >> x and foo >> foo be different.
16:29:19 <kazagistar> luite: I mean, you could test more around edge points (2^32, 2^64) and interesting things like primes
16:29:33 <hseg> merijn: Show me, please?
16:30:01 <merijn> hseg: 1 sec, it's spread over a few files
16:30:01 <hseg> zipper: In what sense do you mean IO is a monster?
16:30:08 <hseg> merijn: Take your time.
16:30:26 <zipper> hseg: Uh it is impure, it is unpredictable etc
16:30:48 <zipper> hseg: In your example I think both are same because x represents foo
16:30:55 <kazagistar> luite: I guess I am just seeing if anyone has done research into this area (composing automated testing with an awareness of "interesting" regions) or what obstacles are in the way
16:31:02 <luite> kazagistar: yeah that's what i mean, but it's somewhat hard to define what's interesting, you'd get something like an "interestingness" topology
16:31:05 <lpaste> merijn pasted “Implementations for open type family functio” at http://lpaste.net/111788
16:31:23 <merijn> hseg: It, eh, involves rather a lot of type families :p
16:31:30 <hseg> zipper: But it doesn't. Suppose foo printed "hello world". Executing foo once or twice makes a difference.
16:31:41 <wavewave> hi
16:31:54 <shachaf> hi wavewave
16:32:04 <wavewave> shachaf: hi!
16:32:11 <merijn> hseg: If you replaced SocketOperation with a data family (i.e. open datatype) there's no reason Operation couldn't be an open type family
16:32:25 <merijn> hseg: The relevant bit is the socketOperation field in the Socket type
16:32:27 <hseg> evening, wavewave.
16:33:01 <merijn> hseg: Line 56 has an example implementation, ther "_ -> can't happen" case is only because 7.8 is dumb, it shouldn't be necessary anymore in 7.10
16:33:02 <wavewave> hseg: it's quite middle of night here, heh ;-)
16:33:04 <zipper> hseg: What difference does printing hello world twice make?
16:33:15 <luite> kazagistar: white box testing is all about finding those regions for a specific program, but you'd just want it for types i presume?
16:33:24 <merijn> zipper: It's not the same as printing it once
16:33:26 <zipper> Coordinates on the screen?
16:33:27 <fread2282> let x = foo in x >> x executes x twice
16:33:34 <fread2282> hseg: ^
16:33:55 <hseg> Wait, zipper, are you only referring to effects observable within Haskell?
16:34:12 <wavewave> i am trying to install ghcjs using nix now.
16:34:23 <luite> cool
16:34:28 <luite> :)
16:34:31 <zipper> hseg: No I am talking about effects to screen, to disk, to files etc
16:34:54 <hseg> If so, launchMissiles :: IO () = return ()
16:35:17 <hseg> zipper: Then printing "foo" and printing "foo\nfoo" are two entirely different effects, no?
16:35:33 <wavewave> luite: I am now trying ryantrinkle's github repo. I guess that it is most up-to-date development.
16:35:35 <zipper> hseg: Yes
16:35:43 <fread2282> zipper: IO isn't all that much of a monster IMO
16:35:53 <luite> wavewave: yeah i tried it before ICFP ant it worked
16:36:03 <zipper> hseg: But I assume to print missle twice the function had different input
16:36:08 <wavewave> luite: cool!
16:36:14 <hseg> zipper: Nope.
16:36:26 <kazagistar> luite: maybe a hybrid? white box analysis (maybe not of a specific system, but many systems) gives us some kind of topology (where bugs are more or less likely), which we can use to inform black box testing... dunno
16:36:30 <jle`> zipper: what function?
16:36:40 <jle`> putStrLn "hello world" is not a function
16:36:42 <jle`> it's a thing
16:36:45 <luite> wavewave: i've pushed some bugfixes and implemented the let-no-escape optimization in the meantime, those are probably not in tehre yet
16:36:49 <jle`> ...ok, thing is not a very good name >_>
16:36:53 <jle`> it's a non-function value
16:36:57 <zipper> jle`: I get what you mean
16:37:10 <merijn> ugh
16:37:11 <fread2282> hseg: let x = foo in x >> x executes foo twice, what do you expect?
16:37:14 <zipper> jle`: Wait putStr is not a function?
16:37:20 <jle`> putStrLn "hello world" is not
16:37:21 <zipper> jle`: I thought it was
16:37:23 <jle`> putStrLn is
16:37:33 <jle`> launchMissiles :: IO () is not
16:37:38 <zipper> jle`: Yes it is a function that has been applied
16:37:44 <kazagistar> luite: Int seems like it is more likely to invalidate a test at 0, -1, 1, maxBound, minBound, etc, and less likely at 437
16:38:01 <jle`> hm
16:38:03 <hseg> fread2282: Right, should have picked a different example.
16:38:05 <jle`> i think i jumped in at the wrong time
16:38:13 <jle`> i might not know the whole context
16:38:16 <jle`> carry on :)
16:38:17 <merijn> Does anyone know if there's a way to export ConstraintKinds type families without requiring the user to enable ConstraintKinds ?
16:38:26 <zipper> jle`: Are you saying that  launchMissiles will give different output for same input?
16:38:36 <merijn> zipper: It doesn't *have* an input
16:38:39 <Axman6> it has no input
16:38:41 <merijn> zipper: Because it's not a function
16:38:53 <kazagistar> you might run out of missiles :P
16:38:54 <luite> kazagistar: well once you have this updated interestingness metric, you can potentially use that in combination with other (possibly derived) values
16:39:21 <zipper> merijn: OMG that is true
16:39:33 <luite> kazagistar: like if you need an Int and an xs::[a], some of the interesting values may be close to length xs
16:40:33 <zipper> Maybe I asked the wrong quesion. How is performing output not pure? Because it changes the state of say disk/screen?
16:40:45 <wavewave> luite: cool. I think once in nixpkgs, staying tuned to the latest one is quite straightforward. my hope :-)
16:40:50 <hseg> zipper: Yep.
16:40:59 <luite> wavewave: me too :)
16:41:14 <zipper> hseg: However it will give same output for same input?
16:41:30 <jle`> what input?
16:41:36 <luite> wavewave: got some bigger changes coming up soon-ish, replacing the whole intermediate language with one that keeps track of types and source locations
16:41:37 <hseg> What output?
16:41:41 <kazagistar> luite: interesting... so as I "descend" into subvalues, my interestingness space needs to change, probably as some kind of monad
16:41:54 <Bakman329> herro all
16:42:00 <hseg> outputting stuff to the screen isn't necessarily a function.
16:42:06 <zipper> jle`: hseg say putStr "Hello" has input hello
16:42:17 <wavewave> great.
16:42:44 <zipper> I don't know what it's output is.
16:42:46 <fread2282> zipper: also laziness. if IO was pure then not doing it would be fine (being lazy)
16:43:01 <hseg> zipper: OK, so consider helloWorld :: IO (). What are its inputs and outputs according to you?
16:44:04 <zipper> hseg: I see no inputs but since I know haskell I'd say output is ()
16:44:39 <luite> kazagistar: hmm, dunno if those are the right abstraction, but clearly the joint interestingness distribution is not a simple product
16:44:55 <fread2282> zipper: ultimately, it's unpure because that's how we define purity
16:45:05 <hseg> zipper: Input/output are terms that are only relevant for functions.
16:45:14 <hseg> zipper: ^^^
16:45:24 <jle`> now try thinking about effects
16:45:44 <merijn> hseg: Did my example help, btw?
16:45:49 <kazagistar> luite: yeah, ill think about it some more, thanks
16:45:59 <hseg> There's nothing *inherently* impure about random values. It's just a question of how to use them.
16:46:19 <zipper> I think this is something I will only truly get by working with it.
16:46:53 <hseg> merijn: I'm not sure how you'd use Operation if it were open.
16:46:55 <zipper> :(
16:47:04 <Sorella> zipper: you can watch http://www.infoq.com/presentations/io-functional-side-effects. I think he uses Scala in that talk though, but same concept.
16:47:25 <hseg> merijn: BTW, why do you write 'Read everywhere?
16:47:27 <zipper> Sorella: On it right away.
16:47:44 <merijn> hseg: Else it thinks I'm refering to the Read typeclass
16:47:52 <fread2282> zipper: but it exists (historically) because haskell is lazy. IO is strict
16:48:07 <Bakman329> How do I round down a float?
16:48:12 <hpc> :t floor
16:48:13 <lambdabot> (RealFrac a, Integral b) => a -> b
16:48:20 <hseg> merijn: Even where a type is expected?
16:48:23 <merijn> hseg: Actually, you may be right about it being problematic with an open Operation type
16:48:32 <merijn> hseg: Yes, because typeclasses are types
16:48:36 <hpc> :t truncate
16:48:37 <lambdabot> (RealFrac a, Integral b) => a -> b
16:48:41 <merijn> :k Read
16:48:43 <lambdabot> * -> Constraint
16:48:48 <hseg> Right.
16:48:52 <hpc> (depends on what "down" is for negative numbers)
16:48:54 <Bakman329> kthx
16:48:57 <Bakman329> oh
16:49:09 <hpc> > truncate 5.6
16:49:11 <lambdabot>  5
16:49:13 <Sorella> fread2282: it turns out to be a quite good separation, though, and allows some fairly expressive stuff (Machines, for example). Purr is strict, and has pure IO. I think PureScript is strict as well.
16:49:16 <hpc> > truncate (-5.6)
16:49:17 <zipper> fread2282: If IO was pure then not doing it would be fine? Can't we just store a thunk saying when we need this read this from user? or write this to screen? Ok maybe the writing to screen can't be lazy but reading is and can. AFAIK
16:49:18 <lambdabot>  -5
16:49:20 <merijn> hseg: Personally I find closed type families far more interesting than open :)
16:49:22 <hpc> > round (-5.6)
16:49:22 <Sorella> Algebraic effect handlers seem to be better than monads though
16:49:24 <lambdabot>  -6
16:49:57 <Bakman329> :hpc Thanks
16:50:13 <hseg> merijn: Me too. What I'm driving at is that if you don't define functions alongside open type families (i.e. associated data types), then the type families are more or less unusable.
16:50:45 <merijn> hseg: Hard to say anything like that "in general"
16:51:07 <zipper> So side effects are intrinsically impure.
16:51:23 <Sorella> zipper: *side* effects are. Effects, not necessarily.
16:51:30 <hseg> merijn: At least, that's what I thought until you mentioned type hackery.
16:51:46 <zipper> That's because we won't get same value when we go back to the device/file/drive because we changed it.
16:51:47 <Sorella> (Well, running the effects is always impure, but you don't need to run them in your PL, which is what the IO monad gives you)
16:51:48 <hseg> I still don't see it, though.
16:52:11 <merijn> Sorella: I'm not sure that's necessarily true?
16:52:16 <zipper> Sorella: Oi the IO monad
16:52:18 <fread2282> zipper: reading, maybe, but strict reading is still useful, and output has to be strict
16:52:42 <Sorella> merijn: as long as you only have a representation of the effect but never run it, then that is just a data structure.
16:52:45 <merijn> Sorella: I'm not too aware of how uniqueness types work, but I don't think they use the same "the RTS does the dirty bit" approach?
16:53:13 <merijn> Sorella: Sure, I agree that that's how it works in *haskell*, but I'm not sure it holds generally for all purely functional languages :)
16:53:15 <Sorella> I don't know how GHC works under the covers WRT the IO monad.
16:53:22 <zipper> fread2282: So the argument is that for it to be pure it should be possible to make it a thunk and have stuff run smoothly, yes?
16:53:37 <hseg> zipper: What Sorella is saying is basically: http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
16:54:45 <zipper> hseg: Oi monads
16:54:54 <zipper> I am afraid of monads also
16:55:04 <merijn> Why?
16:55:08 <fread2282> zipper: depends on who you ask :P, but generally yes. libraries like bytestring use impure operations under the hood but encapsule it so it's safe (/pure)
16:55:21 <fread2282> @src Monad
16:55:21 <lambdabot> class  Monad m  where
16:55:22 <lambdabot>     (>>=)  :: forall a b. m a -> (a -> m b) -> m b
16:55:22 <lambdabot>     (>>)   :: forall a b. m a -> m b -> m b
16:55:22 <lambdabot>     return :: a -> m a
16:55:22 <lambdabot>     fail   :: String -> m a
16:55:24 <Sorella> zipper: did you read Wadlers "Monads for Functional Programming"?
16:55:42 <zipper> Sorella: No, never heard of it.
16:56:01 <orb__> Is lambdabot current?
16:56:07 * hackagebot web-page 0.2.0 - Monoidally construct web pages  http://hackage.haskell.org/package/web-page-0.2.0 (ErtugrulSoeylemez)
16:56:14 <orb__> I thought Monad know has a dependency on Applicative?
16:56:23 <merijn> orb__: No, that won't be until 7.10
16:56:30 <hseg> zipper: My favorite introduction is http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
16:56:32 <merijn> orb__: Also, @src is filled with lies
16:56:38 <merijn> orb__: It's just a text database
16:56:39 <orb__> zipper, Monad's are overrated.  Learn about Functors and Applicative [Functors], first.
16:56:51 <orb__> merijn, ok.
16:57:16 <Sorella> zipper: http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf, read it if you want to understand why monads came to be in Haskell/etc. But as for what monads are, fread2282 gave the entire description of them above (see lambdabot's output)
16:57:17 <orb__> Actually, don't try to understand Monads before you have wrapped your head around Functors.
16:57:30 <Sorella> You can ignore fail and (>>)
16:57:37 <orb__> Sorella, lambdabot didn't give the Monad laws.
16:57:48 <Sorella> Ah, yes, true that.
16:57:55 <zipper> orb__: I have learned about those. I have read typeclassopedia
16:58:20 <orb__> zipper, oh, then Monads are just one more typeclass.  Nothing special.
16:58:20 <zipper> and when I read that they don't eem like a big deal but it still doesn't feel very AHA
16:58:33 <orb__> They just get lots of time in the press.
16:58:51 <Bakman329> calcDecimalBias x = (round(x - (truncate(x))*10)-(abs(x)/100)) / 100
16:58:55 <zipper> orb__: I get they are applicatives with the ability to... ok I can't remember but I read about them.
16:58:55 <orb__> The AHA was when Wadler figured out that Monads work for IO.
16:58:56 <Bakman329> what's wrong with that?
16:58:57 <zipper> lol
16:59:06 <orb__> zipper, Applicative + join.
16:59:09 <Sorella> zipper: there's nothing extraordinary in any type class. At least, nothing more than Java's Iterable, besides the fact that type classes tend to be principled
16:59:15 <merijn> Bakman329: I dunno? What is wrong with it?
16:59:16 <fread2282> zipper: a monad is something that is paramaterized on one type (`m a`), and has the operations above
16:59:58 <Sorella> And satisfies left identity/right identity, as well as Functor's and Applicative's laws.
17:00:00 <zipper> monoids were what seemed hard and nobody talks about those. Heck haskell is such a maze.
17:00:11 <zipper> I will watch the talk now.
17:00:13 <zipper> bye
17:00:56 <Bakman329> merijn: http://pastebin.com/X16gqfCi
17:02:38 <merijn> Bakman329: You're trying to use "show" on a polymorphic value and GHC doesn't know which instance you want
17:03:10 <fread2282> zipper: monads are really general, just anything with the above operations subject to a few laws. in the abstract, they prove a mechanism for choice based on that value they are paramaterized upon, but that doesn't tell you much. the details are up to the instances
17:03:30 <shachaf> It doesn't tell me much either.
17:03:42 <fread2282> that probably doesn't make sense :(
17:04:08 <mm_freak> hi there
17:04:27 <mm_freak> haddock generation still seems to fail for my package…  is there any way to figure out why?
17:04:33 <Bakman329> merijn: why is it calling show?
17:05:07 <merijn> Bakman329: Well, how do you expect ghci to show the result without calling show?
17:05:29 <merijn> mm_freak: I think all builds are stopped due to lack of diskspace
17:05:46 <merijn> mm_freak: I recommend just manually uploading haddocks to hackage
17:05:47 <Bakman329> merijn: Yeh I guess, but what's different about calling show on an Integer and on a float?
17:05:55 <mm_freak> merijn: how do i do that?
17:06:06 <merijn> mm_freak: http://fuuzetsu.co.uk/blog/posts/2014-01-06-Fix-your-Hackage-documentation.html
17:06:08 <Bakman329> i.e. Why is it a problem
17:06:13 <merijn> mm_freak: Should also cover how to look at the log
17:06:40 <merijn> Bakman329: Eh, because show for Float works on Float values and show for Int works on Int and those two are not the same, thus the code is not the same?
17:06:42 <geekosaur> Bakman329, you may be thinking like OO, where data values carry around dictionaries specifying how to e.g. show them
17:06:54 <fread2282> zipper: monads share little, the details are up to the specific monad. try using (>>=) and return with specific monads
17:07:15 <merijn> mm_freak: There's a link to a script for generating + uploading docs in there as well
17:07:34 <geekosaur> Haskell is not OO, arbitrary values do not encapsulate how they Show. you must either fix the type at compile time, or arrange to pass a dictionary telling it how to Show (this is what the `Foo a =>` does in a type)
17:07:41 <Fuuzetsu> mm_freak: https://gist.github.com/Fuuzetsu/8276421
17:07:57 <Fuuzetsu> I think Hackage hasn't built *any* docs recently
17:08:06 <merijn> Fuuzetsu: Builds are stopped due to disk space issues
17:08:22 <Fuuzetsu> oh, I thought those were resolved
17:08:34 <zipper> A pure function doesn't depend on anything other than its arguments
17:08:36 <merijn> Quick poll: "flip appEndo myVal" or "(`appEndo` myVal)"?
17:08:38 <merijn> Fuuzetsu: Might be
17:08:54 <mm_freak> ok, thanks
17:08:58 <zipper> fread2282: Just learned -> A pure function doesn't depend on anything other than its arguments
17:08:58 <Fuuzetsu> surely they could delete all old build results except the docs for them
17:09:04 <shachaf> merijn: Of those two, definitely the latter.
17:09:35 <merijn> shachaf: I'm open to better solutions for fmap'ing appEndo + argument
17:09:54 <Sorella> geekosaur: I think multimethods are considered OO as well, and they're more similar to TypeClasses where everything is a newtype. But well, OO doesn't have a clear definition :)
17:10:52 <merijn> shachaf: I have "Functor f => f (Endo a)" and an 'a' and what to get "f a"
17:10:54 <Cale> Haskell can make a pretty decent OO language, with the fact that method implementations aren't tied to the types of objects making up for the fact that there's no subtype polymorphism
17:10:56 <Sorella> merijn: I'd section it, but I'm not sure if you're asking a style question or how people prefer to write things
17:11:05 <merijn> Sorella: Both :)
17:11:19 <geekosaur> I'm thinking more abotu the concepts people carry around
17:11:42 <shachaf> merijn: fmap (($ x) . appEndo) is another option.
17:11:47 <Sorella> Ah, yeah, I think most people would think OO = classes (outside of academia at least)
17:12:10 <merijn> oh, actually, since it's an applicative too I guess "appEndo <$> blah <*> myVal" works nicer
17:12:33 <merijn> eh "pure myVal", obviously
17:12:38 <fread2282> zipper: meh. State s a is a monad where a depends on the value of s. you can have (boring :: State a a = get >>= return). now the result depends on what you run it with
17:13:22 <Cale> I'm just thinking of OO as meaning the techniques surrounding characterising values by the methods or messages they can respond to.
17:14:56 <fread2282> zipper: simpler: (a -> (b -> (a,b))), that's State without the newtype
17:15:06 <fread2282> oh no it isn't
17:15:17 <zipper> fread2282: LOL I'm confused
17:15:20 <hpc> that's (,)
17:15:23 <cads> hey guys, can we push haskell to a javascript environment?
17:15:27 <zipper> fread2282: Don't explain it
17:15:31 <fread2282> State is (b -> (a,b))
17:15:31 <cads> kind of like purescript?
17:15:36 <merijn> cads: ghcjs?
17:15:43 <zipper> fread2282: I doubt I'll get it tonight. I need to read some things.
17:15:51 <hseg> On page 11 of http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.100.22, McBride and Patterson mention that in a precise category-theoretical account of Applicative, it also has a tensorial strength. Then they say it must satisfy "standard equations" and give a diagram that must commute. What are these equations and why must the diagram commute?
17:15:56 <cads> merijn: I'll look at that, thanks
17:15:59 <merijn> cads: Compiles haskell to javascript, runs in the browser + node.js and supports a javascript FFI
17:16:01 <Bakman329> merijn: Alright, so why would a show on an integer work, but not one on a float?
17:16:19 <merijn> Bakman329: They both work, but your code can return *both* float and integer
17:16:25 <cads> merijn: do you know how heavy the runtime is?
17:16:29 <merijn> > show (1 :: Float)
17:16:31 <lambdabot>  "1.0"
17:16:34 <merijn> > show (1 :: Int)
17:16:36 <lambdabot>  "1"
17:16:51 <merijn> :t 1
17:16:52 <lambdabot> Num a => a
17:16:56 * cads has been told purescript has a mere 10kb runtime
17:17:22 <mm_freak> merijn: that worked, thanks!
17:17:33 <merijn> Bakman329: 1 (like your code) is polymorphic, it can be both. GHC can't know whether you're expecting to show it as a Float or as an Int, so you need to tell it
17:17:34 <cads> but I'd also like to be able to push code to ghc
17:17:47 <merijn> cads: Ask luite (not sure if he's around right now)
17:17:56 <merijn> I think there's probably a #ghcjs too
17:18:04 <cads> ah, ghcjs is his baby
17:18:12 <cads> thanks, that's awesome
17:18:39 <merijn> cads: UHC can also compile to JS, but ghcjs supports more features
17:18:53 <fread2282> zipper: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
17:19:09 <merijn> cads: i.e. ghcjs supports all GHC extensions, threading and stm
17:19:19 <cads> wow
17:19:27 <merijn> cads: And soon Template Haskell too, I think
17:19:33 <mm_freak> Fuuzetsu: and thanks for this extremely tedious article and the relieving fan service =)
17:19:33 <Sorella> Bakman329: Haskell uses type classes for open extensibility. Basically, it gives you open extensibility. You declare an interface (e.g.: `class Show a where show :: a -> String`), then provide implementations of that interface anywhere (e.g.: `implement Show Int where show x = ...`). Now, when you use `show x`, GHC will find the specific implementation of `Show.show` for the type of `x`, and call it. Of course, if there are more than
17:19:33 <Sorella> one possible implementations, you need to disambiguate.
17:19:51 <cads> sounds great - code in haskell, push to the browser
17:19:59 <Fuuzetsu> mm_freak: one day my articles may become less tedious
17:20:03 <Fuuzetsu> I can't write ;P
17:20:18 <Bakman329> "calcDecimalBias 5.5 :: Integer" -- " No instance for (Fractional Integer) arising from the literal ‘5.5’"
17:20:25 <mm_freak> Fuuzetsu: i rather hope one day it won't be necessary anymore ;)
17:20:40 <hseg> Fuuzetsu: Eh, I could follow the Backpack paper quite well. Don't put yourself down too much.
17:20:46 <merijn> Bakman329: What's the type of calcDecimalBias?
17:20:59 <Fuuzetsu> hseg: Backpack paper?? This is something else
17:21:18 * merijn is betting 10 dollars on "(Fractional t, Integral t)" in there
17:21:18 <Bakman329> *Main> :t calcDecimalBias
17:21:22 <Bakman329> calcDecimalBias :: (RealFrac a, Integral a) => a -> a
17:21:35 <merijn> Bakman329: Right, that can never exist :)
17:21:36 <Fuuzetsu> merijn: that'll be 10$
17:21:42 <merijn> Fuuzetsu: Shush
17:21:49 <merijn> Bakman329: can you link your code again?
17:21:49 <Fuuzetsu> ;
17:21:53 <Sorella> cads: you get GHCJS for full GHC. Haste and Fay for Haskell. PureScript for Haskell-ish with row polymorphism and extensible records.
17:22:11 <merijn> Bakman329: It's impossible for a type to be both an instance of RealFrac and Integral, they're contradictory constraints
17:22:15 <Bakman329> calcDecimalBias x = (round(x - (truncate(x))*10)-(abs(x)/100)) / 100
17:22:16 <Sorella> Elm for row polymorphism and extensible records, but no higher-kinded types.
17:22:20 <Bakman329> oh
17:22:31 <merijn> Bakman329: Right, the problem is this
17:22:33 <merijn> :t round
17:22:35 <lambdabot> (RealFrac a, Integral b) => a -> b
17:22:36 <carter> merijn:i could totes define something where that has both :)
17:22:39 <merijn> :t (/)
17:22:40 <lambdabot> Fractional a => a -> a -> a
17:22:51 <merijn> :t (round 5.5 / 10)
17:22:52 <lambdabot> (Integral a, Fractional a) => a
17:22:55 <mm_freak> merijn: technically a channel is just multicasting, so you just made that bet with ~1350 people
17:22:56 <carter> *weird
17:22:59 <Bakman329> So should I cast the round to Integer?
17:23:02 <mm_freak> that's ~$13500
17:23:36 <merijn> Bakman329: No, you need to 1) decide whether you want integer division of floating division and 2) add fromIntegral/div as appropriate
17:23:39 <merijn> :t (/)
17:23:41 <lambdabot> Fractional a => a -> a -> a
17:23:43 <merijn> :t div
17:23:44 <lambdabot> Integral a => a -> a -> a
17:23:51 <merijn> > 10 `div` 3
17:23:53 <lambdabot>  3
17:23:58 <merijn> > 10 / 3
17:23:59 <lambdabot>  3.3333333333333335
17:24:44 <merijn> Bakman329: You can use use "fromIntegral" to make the result of round a Fractional or use div to make both round and 100 Integral types
17:25:01 <Bakman329> merijn: Thanks
17:25:07 <merijn> Bakman329: FYI, I would highly recommend factoring that function out into sub computations using where
17:25:15 <merijn> Because it's rather unreadable atm :)
17:25:27 <cads> Sorella, merijn, one other question - main reason I'm looking at JS is because we can push JS apps to android via stuff like phonegap - do you guys know about the state of the art for pushing android apps directly from haskell?
17:25:30 <Bakman329> merijn: Yeh I know it's just a test lol
17:25:31 <TheKing444> > "Yolo " ++ "all"
17:25:33 <lambdabot>  "Yolo all"
17:25:47 <kazagistar> naw, we each get $10.00 1300
17:26:02 * cads has seen a neat little spinning cube app demo
17:26:11 <kazagistar> er, $10 `div` 1300, also known as 0
17:26:18 <cads> written in haskell... also very crashy :
17:26:23 <mm_freak> cads: there are two ways to do that
17:26:26 <merijn> cads: ARM compilation is tier 2 support, so it's possible to execute GHC on android phones, but not as polished as compiling for, say, x86 and some stuff is still missing, like TH
17:26:30 <hseg> Fuuzetsu: oops
17:26:37 <TheKing444> > unsafePerformIO $ putStrLn "I think I broke lambdabot."
17:26:39 <lambdabot>  Ambiguous occurrence ‘putStrLn’
17:26:39 <lambdabot>  It could refer to either ‘L.putStrLn’, defined at L.hs:156:1
17:26:39 <lambdabot>                        or ‘System.IO.putStrLn’,
17:26:40 <lambdabot>                           imported from ‘Prelude’ at L.hs:40:8
17:26:40 <lambdabot>                           (and originally defined in ‘base:System.IO’)
17:26:54 <TheKing444> nvm
17:26:55 <mm_freak> cads: the first is to compile haskell to native code, which currently works, but you can't use any of the android APIs (because they aren't available via native code)
17:27:05 <mm_freak> cads: the second is to compile haskell to javascript via haste or GHCJS
17:27:08 <merijn> TheKing444: You thought no one thought of unsafePerformIO yet? :)
17:27:27 <fread2282> > :t unsafePerformIO
17:27:28 <TheKing444> > unsafePerformIO $ putStrLn "I think I broke lambdabot."
17:27:29 <lambdabot>  can't find file: L.hs
17:27:30 <lambdabot>  <hint>:1:1: parse error on input ‘:’
17:27:37 <fread2282> :t unsafePerformIO
17:27:38 <lambdabot> b -> [Char]
17:27:48 <merijn> lolwut
17:27:50 <merijn> @undefine
17:27:50 <lambdabot> Undefined.
17:27:54 <merijn> :t unsafePerformIO
17:27:55 <lambdabot> Not in scope: ‘unsafePerformIO’
17:27:59 <kazagistar> @undefine
17:28:00 <lambdabot> Undefined.
17:28:00 <merijn> There we go
17:28:00 <pjdelport> TheKing444: You might be interested in reading about https://github.com/gwern/mueval
17:28:00 <TheKing444> foiled
17:28:14 <TheKing444> I wast trying to pretend to break lambdabot.
17:28:43 <cads> mm_freak: the latter sounds a lot less scary than losing api support
17:28:48 <TheKing444> But not only does lambdabot protect against real attacks, but imaginary ones too.
17:29:14 <mm_freak> cads: well, depends…  if you want to write a game, the native compilation strategy is more promising
17:29:37 <mm_freak> you can then use OpenGL rather than WebGL
17:31:06 <cads> I'd be okay with that if there is already some out of the box environment or haskell API that automates a lot of the tool setup for the UI design and app packaging
17:31:50 <cads> but I also like JS because I can push it to iphone and other mobile platforms via phonegap et al
17:31:54 <mm_freak> there is virtually no tool support right now
17:32:06 <mm_freak> and almost no bindings for anything android-specific
17:32:28 <carter> ghcjs is legit
17:32:34 <carter> still getting lots of polish
17:32:43 <carter> but basically a first class ghc backend, albeit in userland
17:33:24 <mm_freak> you get a JS target compiler and the usual haskell goodies like cabal, but everything else you have to do yourself
17:33:51 <carter> well
17:34:02 <carter> same as writing haskell code on a new OS
17:34:15 <carter> but with very very easy ffi interop with js
17:34:31 <carter> :)
17:34:47 <cads> which you guys like more, luite's ghcjs, or valderman's haste?
17:35:04 <hseg> Can someone explain what the laws are that tensorial strength should obey as defined in page 11 of http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.100.22 ?
17:35:06 <merijn> cads: Haste is "haskell-like" not actual haskell
17:35:10 * cads is inclined towards the former, merely because he could hope to bend luite's ear now and again
17:35:21 <TheKing444> No, Haste is fully haskell compliant I believe.
17:35:25 <TheKing444> Fay is the subset.
17:35:35 <carter> ghcjs is the most robust
17:35:36 <TheKing444> haste is not ghc though
17:35:44 <TheKing444> oh wait, it is a dialect
17:35:57 <carter> TheKing444: haste lacks tail calls afaik
17:35:58 <hseg> sorry, http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.100.22
17:36:13 <carter> cads: if you want tail calls to always work, ghcjs is the only option afaik
17:36:23 <cads> now if I want a haskell-like, I'm really rather impressed with purescript
17:36:34 <mm_freak> haste makes different tradeoffs…  most importantly it's not GHC, so it lacks many language extensions, if you need them
17:36:46 <mm_freak> also GHCJS code will most likely be faster
17:37:05 <cads> saw a cool presentation on that, someone is implementing a reactive stream library for it
17:37:06 <mm_freak> but that alone isn't enough to make an educated choice
17:37:22 <carter> also luite provides  pretty good support
17:37:24 <carter> :)
17:37:24 <cads> which is still light enough to use for web games
17:37:34 <carter> cads: try out codeworld.org
17:37:47 <carter> woops
17:37:48 <carter> wrong thing
17:37:53 <carter> whats that cdsmith site?
17:37:55 <mm_freak> one thing i like about haste is the very low barrier to entry
17:38:25 <mm_freak> just install it, then just use it
17:38:31 <mm_freak> everything works as expected, including cabal
17:38:37 <carter> http://www.codeworld.info/
17:38:40 <cads> ghcjs does give us a neat vagrant build script
17:38:42 <carter> doesn't seem to be up right now
17:38:50 <carter> cads: idk how recent the vagrant script is
17:38:58 <carter> https://github.com/ghcjs/ghcjs
17:39:02 <carter> has build directions
17:39:04 <mm_freak> when i like about GHCJS is that…  well…  it's GHC =)
17:39:14 <carter> yeah
17:39:15 <mm_freak> s/^when/what/
17:39:47 <cads> hmm, it's last updated on feb 28
17:39:48 <carter> mm_freak: codeworld.info seems to be down, but is a nice web sandbox that uses ghcjs
17:39:54 <carter> cads: use the direcions in the main repo
17:40:03 <mm_freak> ah, cool
17:40:09 <cads> carter: I'll try it out in the background and see where it breaks, lol
17:40:19 <carter> cads: read the directions precisely and you should be fine
17:40:22 <TheKing444> anyone know what differences there are between haste and the language definition?
17:40:23 <carter> they're easy to follow
17:40:31 <carter> TheKing444: haste doesnt have tail calls
17:40:35 <carter> so its not practical for me
17:40:49 <TheKing444> carter: like what would be example code of that?
17:40:59 <carter> anything that does tails calls
17:41:06 <TheKing444> carter: so if I do x = 1 : x, that would not work?
17:41:12 <carter> no
17:41:16 <carter> thats a stream
17:41:20 <TheKing444> wait no, that wasn't a tail call
17:41:56 <mm_freak> tail calls are pretty meaningless in haskell
17:42:02 <cads> carter: I'm a sucker for vagrant scripts - if it's broken I'll likely fix it :)
17:42:21 <carter> mm_freak: ghc / haskell has tail calls as far as I care to define them
17:42:25 <TheKing444> carter, so foldl doesn't work (it is tail recursive)
17:42:35 <carter> foldl is always busted
17:42:38 <carter> foldl'
17:42:42 <carter> is whatyou mean?
17:42:55 <TheKing444> foldl' is a tail call and it works on haste I believe
17:43:12 <carter> apaprently its a problem for monad transformers in teh same way it is in scala
17:43:22 <carter> so its more for mutally recursive things
17:43:28 <mm_freak> carter: every language with functions and application has them…  the question is whether you optimise them to jumps (traditional stack-based compilation) or you get tail jumps by concept (STG)
17:43:30 <carter> self loops probably get optimized correctly
17:43:41 <carter> mm_freak: cmm has tail calls
17:43:49 <carter> and thats enough for me
17:43:57 <TheKing444> you mean tail call elimination?
17:44:00 <carter> no
17:44:01 <TheKing444> yeah, that got that
17:44:07 <carter> tail calls
17:44:07 <TheKing444> https://t.co/LnjbyB9SsQ
17:44:10 <carter> are gotos
17:44:11 <carter> with args
17:44:33 <carter> TheKing444: huh, thats new
17:44:34 <carter> cool
17:45:16 <carter> mm_freak: i understand that for certain semantic / pedagogical purposes its useful to say "ghc doesn't have tail calls"
17:45:32 <carter> but for me, I'd say its still true to say ghc has taill calls
17:45:40 <carter> and operational, it does have them
17:45:59 <carter> though there is that lazy args thunking matter
17:46:04 <carter> but thats a different concern :)
17:46:23 <TheKing444> It sounds like you are talking about implementation stuff.
17:46:39 <carter> hah
17:46:58 <carter> if i write a function thats strict on its args and makes a tail call,it's semantically a tail call
17:47:19 <carter> thats all i care about it
17:47:27 <carter> there is implementation stuff going on behind that
17:47:33 <carter> :)
17:47:51 <TheKing444> gtg
17:49:50 <mm_freak> carter: tail calls still occur, but most likely not because you wrote a tail call in your haskell source code =)
17:50:10 <carter> if they happen in the same place, they're for the same reason
17:50:11 <mm_freak> STG compiles to The Right Thing mostly without actually optimising tail calls away
17:50:17 <carter> no
17:50:23 <carter> every haskell call is a jump
17:50:31 <mm_freak> exactly
17:50:33 <carter> :)
17:51:07 <carter> when I say tail call, i mean "no new stack frame or arg thunks accumulating"
17:51:08 <carter> :)
17:51:25 <carter> mm_freak: anyways
17:51:29 <carter> we both understand how this works
17:51:38 <carter> speaking to an audience is a different thing
17:51:42 <carter> and not my goal :)
17:52:02 <trap_exit> how does vim / emacs compare in terms of programming in haskell?
17:52:21 <ben_vulpes> trap_exit: it's hard to find people who can speak to both :D
17:52:31 <carter> trap_exit: pick your fav editor
17:52:33 <carter> and just roll with it
17:52:36 <carter> dont matter
17:52:43 <trap_exit> it's like "what hurts more, getting kicked in the nuts or delivering a baby?
17:52:52 <carter> nope
17:52:57 <carter> just pick an editor
17:52:58 <carter> and use it
17:53:04 <carter> i use Sublime text 3
17:53:07 <carter> and a dash fo atom
17:53:25 <trap_exit> I used to use emacs.  Unfortunately, despite being able to ssh into my server, I can't get ssh to work from eshell
17:53:45 <carter> well
17:53:50 <carter> then fix your server
17:53:54 <carter> or whatever
17:53:57 <ben_vulpes> trap_exit: i gave up on doing shell stuff in emacs
17:53:59 * Ralith loves emacs, but finds that it makes a poor terminal emulator
17:54:06 <Ralith> so I use urxvt.
17:55:11 <merijn> There's no Monoid instance for IO? :(
17:55:19 <carter> whhat would it mean
17:55:55 <merijn> carter: "instance Monoid a => Monoid (IO a) where mappend = liftM2 mappend"?
17:56:07 <carter> point
17:56:12 <carter> and mzero =?
17:56:21 <merijn> carter: "return mempty"
17:56:27 <carter> touche
17:56:47 <merijn> carter: It's as sensible as a monoid instance for Parser like attoparsec has
17:56:57 <mgsloan> but going down that road leads to "instance Num a => Num (IO a)"
17:56:59 <merijn> I was sure it existed, but I can't find it
17:57:17 <carter> mgsloan: ow my eyes
17:57:31 <merijn> mgsloan: I don't think those are the same, but I have a hardtime articulating why :)
17:58:48 <merijn> mgsloan: One argument is that Num doesn't have any laws and thus reasoning about that instance is hard
17:59:04 <merijn> mgsloan: Whereas Monoid has laws and they hold for my IO instance
18:00:08 <mgsloan> merijn: Right, I can buy that.  (+) ought to be "approximately commutative" (the approximately is for floats..),  and this IO instance totally breaks that
18:00:30 <mgsloan> That's a good enough argument that I'd say it wouldn't be such a bad thing to have
18:01:40 <jle`> any Applicative gets a free lawful Num and Monoid etc. instance
18:02:02 <jle`> mempty = pure mempty
18:02:11 <jle`> mappend = liftA2 mappend
18:02:48 <mm_freak> merijn: there are too many valid Monoid instances for IO to hardcode one
18:02:58 <jle`> (+) = liftA2 (+), (-) = liftA2 (-), negate = fmap negate, fromIntegral = pure . fromIntegral
18:03:14 <mm_freak> merijn: it's like hardcoding mappend = (+) for Integer
18:03:16 <merijn> mm_freak: that are more sensible than mine?
18:03:26 <mm_freak> merijn: as sensible
18:03:34 <jle`> interestingly enough neither Applicative instance for [] gives the actual Monoid instance for [a]
18:03:36 <merijn> I mean, I can come up with the flipped version of mine, but which other do we have?
18:04:07 <mm_freak> merijn: exception handling, sequencing, …
18:05:03 <merijn> Utterly unrelated issue:
18:06:23 <merijn> Actually forget it, I think the answer is "I'm boned"
18:06:39 <merijn> mm_freak: I did have something I wanted to discuss with you if you have some time :)
18:06:58 <mm_freak> merijn: feel free =)
18:07:34 <jle`> mm_freak: oh i didn't notice that this was #haskell.  i guess you're back?
18:07:35 <jle`> :P
18:07:46 <zq> how do i convince ghc to fuse Data.Text.word?
18:07:57 <jle`> mm_freak: btw, i am thinking of doing my DIP project on comonads
18:08:07 <merijn> mm_freak: With the new netwire implementing "proper" FRP it's on my list to play with it again, which lead me to wonder whether there was a sensible way of persisting the "state" of an FRP system
18:08:09 <jle`> do you think there is anything that comonads can add to finite DIP?
18:08:20 <mm_freak> jle`: no, i just had a problem with my hackage upload
18:08:34 <jle`> you had a draft on a post about a comonadic approach
18:08:45 <jle`> but i am wondering if it can be taken further to really provide meaningful benefits to DIP
18:08:55 <mm_freak> merijn: it's in development
18:09:05 <mm_freak> merijn: under the name "savegames for free"
18:09:12 <mm_freak> jle` actually has a working implementation of my idea
18:09:17 <merijn> mm_freak: :D
18:09:19 <jle`> oh yeah
18:09:21 <mm_freak> i just had a proof of concept on lpaste somewhere
18:09:28 <jle`> it's working and i've run a few apps with it, like a chat bot
18:09:31 <merijn> mm_freak: Anything available somewhere already or not yet?
18:09:45 <mm_freak> merijn: not yet
18:09:49 <mm_freak> or ask jle` =)
18:09:51 <jle`> still have problems with being able to restructure/update the save states with changes to game logic
18:10:04 <mm_freak> jle`: "DIP"?
18:10:09 <jle`> digital image processing
18:10:11 <jle`> sorry :)
18:10:23 <mm_freak> jle`: yes, of course
18:10:36 <jle`> i bothered edwardk earlier but he is convinced that it is a dead end avenue
18:10:58 <mm_freak_> whoops
18:11:00 <mm_freak_> jle`: yes, of course
18:11:03 <mm_freak_> i strongly believe that comonads are the one true approach to image processing =)
18:11:11 <jle`> i bothered edwardk earlier but he is convinced that it is a dead end avenue
18:11:25 * edwardk tunes in at the second ping ;)
18:11:26 <jle`> sorry for pinging you twice
18:11:29 <jle`> v.v
18:11:32 <edwardk> heh
18:11:52 <edwardk> DIP?
18:11:59 <jle`> digital image processing
18:12:01 <edwardk> ah
18:12:06 <mm_freak_> huh?  why dead end?
18:12:07 * merijn is getting a sense of deja vu :)
18:12:16 <edwardk> merijn: hahahaha
18:12:25 <edwardk> i'm not convinced it is a dead end per se
18:12:38 <jle`> well...it's a nice way to look at it, but how can i show that there is a benefit to approaching the problem this way instead of traditionally?
18:12:45 <jle`> enough that i can write a research paper on it
18:12:47 <jle`> heh
18:12:56 <mm_freak_> jle`: let me list a few features:
18:13:02 <mm_freak_> - dimensionality-agnostic
18:13:17 <mm_freak_> - no repeated layers of maps (loops)
18:13:23 <mm_freak_> - parallelism for free
18:13:32 <carter> whats DIP mean?
18:13:35 <carter> oh
18:13:38 <jle`> parallelism for free?
18:13:50 <jle`> surely not after multiple extends
18:13:57 <jle`> *chaining
18:14:10 <carter> its a neat formulation for pointwise stuff
18:14:20 <jle`> a single extend can be executed with parallelism
18:14:21 <mm_freak_> jle`: realise :: (Traversable f) => Image (f Int) a -> Image (f Int) a  -- back to an actual discrete array via repa
18:14:36 <mm_freak_> although for repa you will most likely need an Unbox constraint on 'a'
18:14:39 <jle`> hm
18:15:14 <merijn> mm_freak: You don't need comonads to avoid the repeated loops if you have a way to simply fuse all your loops :)
18:15:29 <dfeuer> These "lens laws" look simple...
18:15:31 <jle`> lack of loops is nice, i guess...if anything, it can allow you to state things in a "denotativey" way.
18:15:55 <jle`> it's a way to...declare an imperative process...but with a higher level
18:15:58 <mm_freak_> merijn: layers of loops
18:16:10 <edwardk> dfeuer: well, yes, lens is quite simple. just ask anyone, the main complaint about lens is that it isn't complicated enough. ;)
18:16:19 <mm_freak_> merijn: and it's not about efficiency, but about the fact that you liberate yourself from having to express those loops
18:16:23 <jle`> simple laws probably help with intuition
18:16:23 <mm_freak_> (maps)
18:16:27 <jle`> hm
18:16:35 <dfeuer> edwardk, I'm just starting https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial
18:16:36 <jle`> well the proposal is due tuesday
18:16:49 <jle`> so i should start getting some stuff down soon
18:17:03 <jle`> i should...probably actaully open up a text editor and try some of this stuff out
18:17:05 <jle`> heh
18:17:13 <mm_freak_> jle`: go ahead
18:17:21 <jle`> any other benefits you can suggest?
18:17:25 <mm_freak_> jle`: luckily most of the stuff you need is already written =)
18:17:25 <merijn> mm_freak_: Sure, but I'm not sure comonads are the best way. Some old colleagues are working on a purely functional language with multi-dimensional array comprehensions. It's pretty neat for image processing stuff like this :)
18:17:35 <mm_freak_> jle`: get the 'comonad' and 'linear' libraries
18:17:52 <mm_freak_> and get a good grasp of Traversable as a representation of dimensionality
18:17:58 <merijn> mm_freak_: And being purely functional they manage to fuse and parallelise nested and pipelined comprehensions pretty easily
18:18:29 <mm_freak_> merijn: those issues are orthogonal
18:18:29 <jle`> i see
18:18:40 <merijn> Maybe I'm just missing the point :)
18:18:50 <mm_freak_> in fact 'codo' notation would give you pretty much exactly that =)
18:18:57 <jle`> maybe i'll discover the wow factor while exploring
18:18:59 <jle`> oh!
18:19:01 <jle`> that co-do paper
18:19:04 <jle`> i need to read that.
18:19:08 <benzrf> in co-do use ->!
18:19:25 <jle`> mk, off to the market.  thanks for the tips
18:21:23 <mm_freak_> merijn: the idea of comonadic multimedia processing is to extract (hehe) the essence of the problem
18:21:49 <mm_freak_> merijn: for example to describe a blur filter you shouldn't care about the picture itself, only about what happens at a sepcific focussed point
18:23:18 <mm_freak_> when you scale an image down you don't want to lose information…  and you wouldn't want to handle special cases like image boundaries
18:23:42 <mm_freak_> in fact you would want some intuitive communtativity properties to hold
18:24:10 <mm_freak_> all this reduces to:  "you should represent your images as functions rather than arrays"
18:24:28 <mm_freak_> and comonads provide a principled algebraic framework to work with them
18:24:31 <jle`> hm
18:25:40 <jle`> boundaries and stuff is neat.  i didn't realize this could be abstracted away by this
18:26:17 <mm_freak_> it's not abstracted away, but simply forces you to handle the boundary issue at the right place =)
18:26:52 <jle`> heh. of course
18:26:56 <merijn> ah, bollocks
18:27:35 <merijn> I'm having trouble making optparse-applicative do what I want
18:27:50 <monochrom> which version?
18:28:01 <merijn> I have a subparser that should only run if option Foo has some specific value X
18:28:21 <merijn> But since Parser is only an Applicative I don't think there's a way to express that :\
18:28:33 <merijn> monochrom: I'm using 0.10
18:31:27 <monochrom> do you use the subparser on X? or do you use the subparser on something else?
18:31:58 <merijn> monochrom: There's some flags I only want to scan for if option Foo is set to X
18:32:32 <merijn> eh, I say subparser, but I really meant just parser
18:32:33 <mm_freak_> bye people
18:33:45 <monochrom> that is a bit outside optparse-applicative's assumptions, yeah.
18:39:42 <merijn> Which is a bit unfortunate, because now I need to come up with a workaround...
18:46:12 <monochrom> "--eval=<haskell code here>  note: if --foo=6 is specified, then this option is ignored"
18:47:11 <merijn> monochrom: I'm trying to mimic the interface of some C++ code, but I guess in this case I can just not care too
18:47:47 <Fuuzetsu> you can abuse laziness to get more ‘context specificness’ out of applicative parsers
18:48:13 <Fuuzetsu> http://byorgey.wordpress.com/2012/01/05/parsing-context-sensitive-languages-with-applicative/
18:48:17 <merijn> Fuuzetsu: Elaborate?
18:48:21 <Fuuzetsu> -- ^
18:48:45 <Fuuzetsu> probably doesn't solve your problem however
18:48:47 <merijn> Fuuzetsu: That's about parser combinators
18:48:59 <Fuuzetsu> right, I just thought I'd mention it
18:49:01 <merijn> Fuuzetsu: We're talking about optparse-applicative Parser here
18:50:25 <Fuuzetsu> https://github.com/pcapriotti/optparse-applicative#commands isn't this more or less what you need?
18:50:40 <merijn> Fuuzetsu: No, because that doesn't work with values of options
18:50:54 <merijn> And my interface is fixed
18:51:13 <monochrom> it is for the like of "cabal install --reinstall" vs "cabal configure"
18:51:43 <Fuuzetsu> ok, I don't know a clean solution with optparse-applicative then
18:52:29 <merijn> I think the solution is "ugly workaround with an option that's always available but sometimes ignored"
18:55:57 <wenderen> hi everyone, i'm a haskell newbie. is this the right place to ask questions? i'm have a question about type/value constructors
18:55:59 <wenderen> *i have
18:56:42 <simpson> wenderen: Sure.
18:57:18 <wenderen> oh cool. so basically i have a constructor like so: data Complex a = Complex { real :: a, img :: a }
18:57:27 <wenderen> i want to restrict a to the Num typeclass
18:57:36 <wenderen> i tried this: data Complex a = (Num a) => Complex { real :: a, img :: a }
18:57:48 <wenderen> (taken from http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/) but it doesn't work.
18:58:03 <simpson> Yeah, it's not possible to do that meaningfully.
18:58:07 <nax> do you really want to do that? you would need to add that constraint in the functions too
18:58:13 <simpson> Put the constraint on functions which work with Complex instead.
18:58:21 <simpson> (Also, in this particular case, Data.Complex is a thing.)
18:58:25 <wenderen> nax: yes, because then Complex 'a' 'b' would be valid
18:58:48 <Fuuzetsu> Hide the constructor and expose a smart constructor with a constraint
18:58:57 <wenderen> simpson: ok, got it - restrict it to the functions instead. also yeah i knew about Data.Complex - this was more of a learning thing. thanks!
19:02:59 <nax> wenderen: but that wouldn't work if you had a function   Num a => Complex a → Complex → Complex a
19:03:19 <Fuuzetsu> you lost an ‘a’
19:03:30 <rdavison> Hi everybody, I’m having some trouble understanding what’s going on here.
19:03:33 <wenderen> nax: true. basically what simpson said: the restriction comes at the function level
19:03:52 <nax> Fuuzetsu: oops :P
19:03:58 <rdavison> :t ($) fst (“some”, “tuple”) :: [Char]
19:04:00 <rdavison> but
19:04:00 <lambdabot> lexical error at character '\8220'
19:04:16 <Fuuzetsu> rdavison: you need to use " style quotes
19:04:21 <Fuuzetsu> not “”
19:04:22 <rdavison> :t ($ fst (“some”, “tuple”) :: ([Char] -> b) -> b
19:04:23 <Fuuzetsu> "" instead
19:04:23 <lambdabot> lexical error at character '\8220'
19:04:26 <wenderen> Fuuzetsu: i'm trying to put together an example using smart constructors - i'll need Data.Typeable, right? (for the constraints)
19:05:23 <Fuuzetsu> wenderen: I was merely suggesting a function mkComplex ∷ Num a ⇒ Complex a
19:05:27 <Fuuzetsu> nothing more
19:05:45 <wenderen> Fuuzetsu: oh ok. much simpler :) thanks
19:07:13 <rdavison> :t ($) fst client
19:07:14 <lambdabot> Not in scope: ‘client’
19:08:40 <rdavison> :t ($) fst ("some", "tuple")
19:08:41 <lambdabot> [Char]
19:08:48 <usr> if that's haskell chode
19:08:50 <usr> code*
19:08:52 <usr> then i'm never learning it
19:08:55 <rdavison> :t ($ fst ("some", "tuple"))
19:08:56 <lambdabot> ([Char] -> b) -> b
19:09:01 <Fuuzetsu> usr: what is?
19:09:08 <usr> rdavison's
19:09:10 <rdavison> what’s the difference between those two statements… why are they different
19:09:17 <geekosaur> it is, it's just not how we normally write it
19:09:24 <Fuuzetsu> rdavison: the first is just ‘fst ("some", "tuple")
19:09:26 <usr> oh ok was gonna say the syntax is terrible
19:09:41 <geekosaur> rdavison, the first is using an infix operator as a prefix function. the second is a partially applied operator
19:09:48 <Fuuzetsu> the second is a tuple section with $, expanding to \x -> x $ fst ("some", "tuple")
19:09:54 <geekosaur> similar syntax, but you moved one application inside the parens
19:10:48 <Fuuzetsu> sorry, operator section not tuple section
19:11:05 <rdavison> oh, I see, the lambda expression makes it very clear
19:12:21 <rdavison> thanks geekosaur and Fuuzetsu
19:13:50 <geekosaur> usr: we almost never use operators in prefix form like that; where they are useful is (a) passing an operator as a parameter to a higher order function, and (b) sections (partially applied operators).
19:14:05 <geekosaur> and even then, sometimes one goes with the lambda expression or some other form just for legibility
19:14:12 <usr> can you link me to some good Haskell gcode
19:14:19 <usr> code*
19:14:22 <usr> That's not the compiler
19:14:25 <geekosaur> the more complex a section, the more likely that we'll use a more readable alternative
19:14:51 <geekosaur> xmonad?
19:15:00 <geekosaur> pandoc, maybe?
19:15:28 <geekosaur> xmonad's core is small and relatively simple, although it does have its scary parts (notably layout hooks)
19:15:45 <CrazyM4n> Ugh, these O(n^2) lists are really biting me in butt right now
19:16:11 <Fuuzetsu> why are you using O(n²) lists to begin with
19:16:22 <Fuuzetsu> it should be easy to swap out for something more efficient anyway
19:17:09 <CrazyM4n> Well, aren´t the default lists O(n²) when it comes to concatenation?
19:18:02 <Fuuzetsu> that's easy to remedy
19:18:23 <CrazyM4n> I´ve already generated 1.8 gigabytes of the file...
19:18:34 <CrazyM4n> And that 1.8 gigabytes is stored in a list
19:18:39 <CrazyM4n> Which is being concatenated
19:18:42 <geekosaur> isn't concatenating lists of lengths m and n O(m)?
19:18:44 <CrazyM4n> I have made a grave mistake
19:18:56 <CrazyM4n> The larger list is 1.8 gb so either way
19:18:59 <geekosaur> now, depending on how you process them afterward, that could become n^2
19:19:03 <Fuuzetsu> just use a difference list
19:19:08 <geekosaur> so yes, difference lists
19:19:41 <CrazyM4n> What´s that?
19:19:46 <CrazyM4n> (sorry)
19:20:10 <geekosaur> http://www.haskell.org/haskellwiki/Difference_list
19:20:20 <Fuuzetsu> that page is pretty poor
19:20:31 <geekosaur> true
19:20:39 <geekosaur> not sure I know of any good ones, though
19:20:41 <Fuuzetsu> hm I thought Oleg had something but apparently not
19:20:47 <Fuuzetsu> maybe Okasaki had something
19:21:02 <Fuuzetsu> no…
19:21:15 <geekosaur> you might say the point is to work at a higher level, instead of linking elements you are linking lists into "super-lists" in one way or another
19:21:18 * hackagebot glib 0.13.0.3 - Binding to the GLIB library for Gtk2Hs.  http://hackage.haskell.org/package/glib-0.13.0.3 (HamishMackenzie)
19:21:26 <CrazyM4n> Maybe
19:21:32 <geekosaur> so now the big-O is that of the super-list, not related to the number of elements int he original lists
19:21:44 <CrazyM4n> I´m not going to be doing anything this big in the future
19:21:48 <CrazyM4n> 1.9 GB down
19:21:51 <CrazyM4n> 0.2 to go
19:22:00 <CrazyM4n> It generated the first 0.2 instantly
19:22:20 <Fuuzetsu> 2GB is not big if you do things properly ;P
19:22:23 <geekosaur> yes, that sounds like you're repeatedly iterating over the same ever-lengthening prefix]
19:22:32 <CrazyM4n> Which I am doing
19:22:37 <geekosaur> this is where you want difference lists so you're not always reprocessing the beginning
19:22:42 <CrazyM4n> It´s slowed to around 0.5 mb/s
19:22:44 <CrazyM4n> Cmon
19:22:51 <geekosaur> alternately, represent them backwards
19:23:04 <geekosaur> so the start is actually at the end and you're prepending new stuff in reverse
19:23:08 <CrazyM4n> I could split the list in half
19:23:11 <CrazyM4n> That could work
19:23:13 <geekosaur> and then reverse the whole thing at the end
19:23:23 <CrazyM4n> Or that, that´s a good idea
19:23:27 <CrazyM4n> How fast is reverse though?
19:23:38 <geekosaur> you're only doing it once, and it's O(n)
19:23:44 <CrazyM4n> Ah
19:23:49 <geekosaur> not repeatedly doing O(n)s so you end up O(n^2)
19:24:03 <CrazyM4n> I´ll work on that right now
19:24:10 <CrazyM4n> While this is rendering
19:24:18 <CrazyM4n> Oh boy
19:26:31 <CrazyM4n> 0.1 GB to go
19:26:33 <CrazyM4n> D:
19:26:35 <ryantm_> Is this the difference list you are talking about? http://hackage.haskell.org/package/dlist-0.5/docs/Data-DList.html
19:26:52 <Fuuzetsu> yes
19:27:18 <Fuuzetsu> preferably the newer version http://hackage.haskell.org/package/dlist-0.7.1
19:31:02 <silasm> ryantm_: in general google links to haskell docs tend to be outdated. In addition to being useful for a bunch of other things, afaik hoogle will always point you to the newest hackage version.
19:31:39 <silasm> (by outdated I mean they just point to older versions)
19:32:22 <CrazyM4n> Holy crap it´s slowed down to like 1 mb per 5 seconds
19:32:30 <CrazyM4n> And we only have around 100 mb to go
19:32:45 <CrazyM4n> No
19:32:48 <CrazyM4n> 30 mb
19:32:55 <CrazyM4n> Maybe 50
19:33:50 <Fuuzetsu> surprise, something that's n² takes longer as n increases!
19:34:11 <durka42> not on my quantum computer!
19:34:21 <Fuuzetsu> go away NSA
19:34:37 <CrazyM4n> Fuuzetsu: The wait only makes it more exciting
19:34:39 <CrazyM4n> :P
19:34:58 <Fuuzetsu> does QML work?
19:35:33 <Fuuzetsu> seems no updates since 2008
19:37:59 <CrazyM4n> Does anyone know R? How´s it performance compared to haskell?
19:38:08 <CrazyM4n> Thinking of learning it for high performance things like this
19:40:25 <Fuuzetsu> it's not going to magically make your things fast if you write the same code
19:41:05 <Fuuzetsu> R is for statistics, not ‘high performance things’
19:41:09 <CrazyM4n> Well
19:41:20 <CrazyM4n> Not ¨high performance things¨, worded that wrong
19:41:26 <CrazyM4n> I´d use C or something
19:41:37 <CrazyM4n> But for lots of numbers
19:41:54 <Fuuzetsu> just write better code, there's no inherent deficiency for using Haskell for this
19:44:36 <silasm> CrazyM4n: all programming is "lots of numbers" when it comes down to it. If you're not doing some sort of statistics or scientific computing, you probably wouldn't benefit a whole bunch from using R, but that's just going off what I've heard.
19:45:23 <silasm> citation: https://en.wikipedia.org/wiki/Gödel_numbering
20:01:38 <ryantm_> silasm, thanks, I knew that already; I was being sloppy. It would be nice to have some kind of "warning this is out of date" banner at the top of Hackage docs.
20:04:26 <ryantm_> It would be nicer to have the latest docs actually build though. So, first things first.
20:22:12 <benzrf> :t break
20:22:13 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
20:22:20 <benzrf> @. hoogle ty break
20:22:21 <lambdabot> Plugin `compose' failed with: Unknown command: "ty"
20:22:24 <benzrf> @. hoogle type break
20:22:26 <lambdabot> Parse error:
20:22:26 <lambdabot>   (a -> Bool) -> [a] -> ([a], [a])
20:22:34 <benzrf> @hoogle (a -> Bool) -> [a] -> ([a], [a])
20:22:34 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
20:22:34 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
20:22:34 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
20:22:40 <benzrf> how is span different?
20:23:57 <Fuuzetsu> break p = span (not . p)
20:24:03 <benzrf> oh
20:24:05 <benzrf> der
20:24:11 <benzrf> @src break
20:24:11 <lambdabot> break p = span (not . p)
20:24:14 <benzrf> @src span
20:24:15 <lambdabot> span _ xs@[]                  = (xs, xs)
20:24:15 <lambdabot> span p xs@(x:xs') | p x       = let (ys,zs) = span p xs' in (x:ys,zs)
20:24:15 <lambdabot>                   | otherwise = ([],xs)
20:25:43 <benzrf> > span (=='3') "5545635456"
20:25:44 <lambdabot>  ("","5545635456")
20:25:48 <benzrf> > break (=='3') "5545635456"
20:25:49 <lambdabot>  ("55456","35456")
20:25:51 <benzrf> aha
20:58:14 <ben_vulpes> is there a hook for the emacs Interactive-Haskell mode? i'm looking through haskell-interactive-mode.el and not seeing anything, and i'd really like to use shm in my haskell repl
20:59:01 <nobrowser> is it a submode of comint?
20:59:35 <nobrowser> you could make a comint hook and switch on the buffer name, or something
21:00:15 <ben_vulpes> hm, i recall reading something about how the comint-mode was ditched, but i may be misremembering
21:00:32 <nobrowser> that would be a big mistake, imho
21:00:35 <ben_vulpes> i guess for now i can just turn it on
21:01:14 <ben_vulpes> nobrowser: how would i identify if it were a submode of comint?
21:01:57 <nobrowser> look at the function that defines the mode, does it use the define-derived-mode macro?
21:02:19 <ben_vulpes> fundamental mode.
21:02:21 <nobrowser> or just do Control-h M
21:02:43 <nobrowser> ok, so much for that idea :(
21:03:02 <ben_vulpes> i suppose i could file a PR
21:03:24 <nobrowser> let me look at my copy, 1 sec
21:03:49 <nobrowser> also, what is shm?
21:03:57 <ben_vulpes> paredit lite
21:04:15 <ben_vulpes> "structured haskell mode"
21:04:31 <nobrowser> there is always advice
21:04:46 <ben_vulpes> that'd be a part of the emacs stack i've yet to touch :D
21:05:46 <ben_vulpes> what would the tradeoffs of an advising vs. adding a hook to haskell-interactive-mode.el?
21:05:54 <nobrowser> I don't have a haskell-interactive-mode.el at all.  Is this some newish reorganization?
21:06:22 <nobrowser> well, with advice you don't have to modify the original code at all
21:06:33 <ben_vulpes> no idea, i'm just now configuring emacs for my first haskell dabblings.
21:07:00 <benzrf> so many bens
21:07:07 <ben_vulpes> it's a...
21:07:10 <ben_vulpes> benanza.
21:07:15 <nobrowser> lol
21:07:31 <benzrf> ben_vulpes, benzrf, Benzi-Junior, benbangert, benjamingr_, bens, benmachine in this room alone
21:07:34 <benzrf> cripes
21:07:57 <nobrowser> I have inf-haskell.el instead
21:08:06 <benzrf> it's an epibenic
21:08:26 <joelteon> i hope they appreciate the ping
21:08:35 <Fuuzetsu> yes
21:09:17 <nobrowser> and my mode is indeed derived from comint
21:09:30 <nobrowser> so, your version is too old or too new :-P
21:09:48 <monochrom> haskell-interactive-mode is new
21:10:27 <monochrom> but how new, I don't know. several years I think.
21:10:48 <nobrowser> I am on Debian, which explains things :-P
21:10:57 <ben_vulpes> sounds like the ditching of comint is actually a thing
21:13:33 <monochrom> ubuntu's haskell-mode package has it. but I found a problem. when getLine, after I enter my input, the prompt does not return until I C-c C-c.
21:14:33 <nobrowser> that's exactly the kind of thing that made me say ditching comint would be a mistake
21:14:40 <monochrom> so I went with the MELPA version instead, which is just 5 days old. (MELPA tracks github commits. last commit was 5 days ago.)
21:15:05 <monochrom> ah, but the 5-days-old version fixes it :)
21:15:19 <ben_vulpes> let's pray nobody's stomping around on master :P
21:16:19 <monochrom> well, the commits before the 5-day-ago one were at least 5 months ago. so I think things are settling.
21:26:28 * hackagebot persistent-mongoDB 2.0.9 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-2.0.9 (GregWeber)
21:31:29 * hackagebot cookie 0.4.1.4 - HTTP cookie parsing and rendering  http://hackage.haskell.org/package/cookie-0.4.1.4 (MichaelSnoyman)
21:35:34 <stolaruk> Are there any real merits to using "guard" over "when"?
21:37:06 <pjdelport> stolaruk: They do two somewhat different things.
21:39:55 <zwer> guard is more comparable to case
21:40:20 <zwer> guards*
21:40:37 <nitrix> If I really really need some global that is mutable in haskell, what is the idiomatic approach? The State monad?
21:40:55 <nitrix> Literally the entire applicate revolves around it and it'll change multiple times per second.
21:40:57 <jle`> nitrix: what do you mean by mutable and global?
21:41:00 <nitrix> application*
21:41:26 <stolaruk> pjdelport: Bcus "guard" uses MonadPlus?
21:41:50 <nitrix> jle`: It's a reference to a remote resource that I need to broadcast to clients, and that link in question is updated frequently from a cluster.
21:41:53 <pjdelport> stolaruk: Well, the fact that it uses MonadPlus is just a consequence of it doing something different. :)
21:42:11 <davean> nitrix: more likely IORef or MVar since you need some policy on HOW you handle changes to it - and there is a very good chance you're just wrong.
21:42:18 <pjdelport> stolaruk: You can think of "guard" as being there to guard the entire rest of what follows after it.
21:42:45 <davean> nitrix: might you want a chan? Specificly of the broadcast variety?
21:43:06 <pjdelport> Whereas when is for conditionally composing a single effect (for whatever meaning the monad's structure has)
21:43:21 <nitrix> davean: Possibly. I mean, I read the entire learn you a haskell book and I still can't write an application yet.
21:43:22 <stolaruk> pjdelport: Take for example... guard ('b' > 'a') >> putStrLn "True!" ...vs... when ('b' > 'a') $ putStrLn "True!"  ...they both seem to be doing the same thing
21:43:26 <pjdelport> nitrix: What problem are you trying to solve?
21:44:13 <nitrix> pjdelport: My current problem is my C bias.
21:44:59 <pjdelport> stolaruk: Yes, but compare: when cond (putStrLn "foo") >> putStrLn "bar"
21:45:20 <pjdelport> stolaruk: Also, guard won't work for IO (which isn't MonadPlus)
21:45:39 <stolaruk> pjdelport: so in your example, "bar" will also be printed
21:45:55 <pjdelport> nitrix: Don't think globally; think locally, in Haskell.
21:45:57 <stolaruk> s/also/always
21:46:01 <pjdelport> stolaruk: Right.
21:46:04 <stolaruk> ok
21:46:08 <stolaruk> cool, thanks much
21:48:22 <pjdelport> nitrix: In other words, try not to think of having some shared resource that stateful consumers have to "pull" from: try to think in terms of functions that take it as argument.
21:48:46 <nitrix> pjdelport: It's a distributed file-system.
21:49:03 <nitrix> There are I/O and states all over the place.
21:49:20 <pjdelport> nitrix: Right, but there are also pure functions all over the place.
21:49:25 <pjdelport> And often, you can separate the two.
21:49:30 <nitrix> The software used to be in C and as a learning experience (and my interest for Haskell), I'm trying to port the code.
21:50:05 <nitrix> I know, no one sane would do that as a first project in a language they aren't familiar with.
21:50:06 <pjdelport> nitrix: In Haskell, you tend to end up with a larger body of "pure" code, and a small amount of IO actions and other glue to make it run in context.
21:51:01 <pjdelport> nitrix: So instead of trying to share some global reference, you might have lots of functions that just take a reference as input, and then some core backbone of code that manages the top-level mutable reference, and invoking the parts with it.
21:51:07 <pjdelport> (if that makes sense)
21:51:30 <pjdelport> But the code that actually knows about and deals with the mutation of it should be relatively minimal.
21:51:42 <stolaruk> nitrix: Distributed as in parallel?
21:51:55 <nitrix> As in peer-to-peer.
21:53:01 <nitrix> Oh well, if it isn't obvious to be yet, it's because I don't understand enough Haskell then.
21:53:10 <nitrix> Can't really bypass that step.
21:54:35 <davean> nitrix: just hard to help you in this situation
21:55:36 <jle`> in IO, you have access to the IORef a mechanism, which lets you reference and change mutable pointers over the course of your IO computation
21:56:21 <pjdelport> nitrix: It's hard to give any more concrete advice without seeing code, though.
21:56:33 <pjdelport> nitrix: But as general advice, start small, and build your way up.
21:57:29 <pjdelport> (And always try to separate pure code from IO actions: that makes things more flexible and composable in the long run.)
21:58:27 <pjdelport> nitrix: If this is your first big Haskell program, it might take some time to get the hang of how things are structured in idiomatic Haskell (it's not the same as C, certainly), but you will get the hang of it.
21:58:44 <pjdelport> Pasting code samples for feedback is probably the quickest way to get over the conceptual hurdles!
22:09:08 <merijn> nitrix: Perhaps this gives some inspiration: http://www.infoq.com/presentations/Combinatorrent-Haskell-casestudy
22:09:17 <merijn> nitrix: It's a bittorrent implementation in haskell
22:18:20 <cbarrett> Is using (Data.Set.toList . Dat.Set.fromList) as a replacement for nub a bad idea? Seems like it'd be more time efficient (perhaps less space efficient)
22:18:58 <merijn> cbarrett: It should be asymptotically better than nub
22:19:04 <cbarrett> right
22:19:10 <merijn> cbarrett: nub is quadratic, that one should be linear
22:19:17 <cbarrett> n+n*logn if the docs are to be believed
22:19:48 <cbarrett> I guess that's basically just log n
22:19:48 <pjdelport> cbarrett: For anything large, Data.Set is a better idea, yeah.
22:20:07 <cbarrett> well, these aren't large
22:20:21 <cbarrett> on the order of maybe dozens
22:20:32 <pjdelport> Oh, then nub is probably fine
22:20:49 <pjdelport> For hundreds or thousands, you'd want Set (or HashSet)
22:21:34 <pjdelport> (If you're unsure, you can always benchmark your input and find the crossing point.)
22:27:12 <benbangert> benzrf|offline: more benz?
22:30:02 <cbarrett> merijn pjdelport: Turns out there's an any in Foldable (thus the deduping)  so I'm just gonna fromList and then use Foldable's any on the set.
22:30:55 <pjdelport> cbarrett: That sounds reasonable.
22:31:30 <cbarrett> If you're curious I'm implementing http://www.neocomputer.org/projects/eller.html
22:31:53 <pjdelport> (You can of course also use Set's member instead of any, if you predicate is equality.)
22:32:15 <cbarrett> nah
22:32:48 <cbarrett> Currently writing the code that verifies each set has an element on the next row (post-condition for generating a row in the maze)
22:33:03 <cbarrett> (the sets are sets of connected cells in the maze)
22:33:24 <pjdelport> cbarrett: Coolness
22:33:32 <cbarrett> Yeah it's been a lot of fun
22:34:12 <cbarrett> I made a pure Row data structure which has functions to manipulate it (connect two cells horizontally, connect two cells vertically, go to next row, finish the maze)
22:35:06 <cbarrett> Then I can write my impure / random code just in terms of those functions on the row structure. This also allows for easy step-by-step playback as well
22:36:34 <pjdelport> cbarrett: Sounds like something to make a short post / article out of :)
22:36:41 <cbarrett> That's the idea :0
22:46:36 <disgrntld> hello, is there an easy way to tell what a type synonym is defined as in ghci?
22:46:57 <shachaf> :i
22:47:01 <disgrntld> cool!
22:47:16 <disgrntld> yup, just what I was looking for, thanks shachaf
22:49:09 <shachaf> whoa, the "chain rule" for derivatives is so reasonable from the perspective of types with holes
22:50:23 <nshepperd> type holes and dimensional analysis are secretly the same thing
22:50:38 <shachaf> ?
22:51:28 <nshepperd> typed holes, I mean
22:51:40 <shachaf> Are you talking about _?
22:53:52 <nshepperd> it's not unusual for physicists, for example, to make arguments like "expression foo = x * _ needs to have dimension mass / length, but the only variable in scope with mass dimension is the electron mass, so _ = m_e"
22:54:23 <shachaf> I guess by types I should say structures.
22:55:07 <shachaf> instead of
22:55:08 <shachaf> Anyway I don't think we're talking about the same thing.
22:55:21 <nshepperd> yeah, I think I read what you said the wrong away around
22:55:36 <nshepperd> "types with holes" not typed holes
22:55:56 <shachaf> "typed holes" is pretty silly. Everything on that level is typed.
22:56:06 <shachaf> People used to call them "type holes" which made even less sense.
22:57:17 <nshepperd> I guess
22:57:37 <nshepperd> it's just a silly way of saying the inferred type gives you a clue what you need to put there
22:57:50 <shachaf> Yes.
22:58:00 <shachaf> "holes" is a reasonable name.
22:59:46 <shachaf> Anyway, if F (G a) has a hole in it, that's like taking out one (G a) from inside the F, so we get F' (G a). But we're not taking out the entire (G a), just one a from it. So we add the rest back: F' (G a) * G' a
23:01:36 * hackagebot yi-rope 0.4.0.0 - A rope data structure used by Yi  http://hackage.haskell.org/package/yi-rope-0.4.0.0 (MateuszKowalczyk)
23:02:11 <nshepperd> ah
23:06:45 <Hijiri> Is there a haskell library for game ratings?
23:07:02 <Hijiri> like glicko, elo, etc
23:08:09 <simpson> Hijiri: It should be easy to implement your own.
23:08:40 <Hijiri> alright
23:09:57 <simpson> Elo ratings, in particular, are very easy to implement.
23:21:37 * hackagebot witty 0.0.1 - A network server to show bottlenecks of GHC  http://hackage.haskell.org/package/witty-0.0.1 (KazuYamamoto)
