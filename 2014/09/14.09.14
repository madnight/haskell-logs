00:00:35 <trap_exit> hmm
00:01:08 <Qfwfq> trap_exit: How is the Introduction indexed in the dead tree version?
00:01:17 <trap_exit> ah
00:01:25 <trap_exit> chapter 11 = applicative functors
00:01:26 <trap_exit> chapter 12 = monoids
00:01:32 <trap_exit> these are combined to 1 chapter in online version
00:01:39 <Qfwfq> Oh, cool.
00:02:12 <_tac> that is kind of crazy that applicative functors come *before* monoids
00:02:28 <_tac> but maybe that's only because I know a bit more math than the average reader of that book
00:04:30 <_tac> zippers are pretty neat, though
00:06:21 <trap_exit> what I really like about the book
00:06:28 <pharpend> monoids are really simple
00:06:31 <trap_exit> is that it's possible to work out all the examples _on paper_ without using ghci
00:06:41 <pharpend> why are they in
00:06:44 * pharpend pulls his hairs
00:07:09 <_tac> trap_exit: that seems like a nice, and surely unvalued, properly of a book
00:07:10 * pharpend storms off in a huff, mumbling something about college students
00:07:27 <Qfwfq> Is BONUS still alive?
00:08:04 <MP2E> don't know, but he hasn't been in here in over a year. About a year and a half afaik
00:08:53 <trap_exit> _tac: what do you mean, unvalued?
00:09:32 <_tac> if you ask someone what makes a good book on learning a programming language
00:09:53 <_tac> You probably won't hear people say "it was easy to figure out the code examples without a repl"
00:11:42 <Qfwfq> I think that's more accurately a property of the language, though. Permitting equational reasoning.
00:11:48 <trap_exit> well, that's becuase most people
00:11:54 <trap_exit> do not value the ability to simulate the repl in their head
00:12:15 <trap_exit> and they pay the price during debugging when they can't understand what their code is doing without running it
00:13:04 <_tac> Haskell is actually harder than usual to evaluate by hand or in your head, due to laziness
00:13:22 <_tac> at least, if your code hinges on laziness
00:13:37 <L8D> omg I thought you were making a joke and it was hilarious
00:13:39 <trap_exit> okay, I admit, I did not simulate laziness
00:13:40 <L8D> and you had to ruin it
00:13:40 <trap_exit> I only simulated value
00:13:55 <trap_exit> who was making a joke?
00:13:59 <L8D> _tac
00:14:00 <trap_exit> I don't get it
00:14:00 <Qfwfq> It is hard to gauge the efficiency of lazy programs. But the values are transparent.
00:14:04 <L8D> "Haskell is actually harder than usual to evaluate by hand or in your head, due to laziness
00:14:32 <trap_exit> @remember _tac "Haskell is actually harder than usual to evaluate by hand or in your head, due to laziness"
00:14:32 <lambdabot> It is forever etched in my memory.
00:15:05 <L8D> trap_exit: do you still not get it?
00:15:11 <_tac> I'm not sure it was a joke :X
00:15:27 <trap_exit> well the problem is that when you simulate
00:15:27 <L8D> well...out of context it seems like one
00:15:29 <trap_exit> you have to output
00:15:34 <trap_exit> which forces evaluation of the thunks
00:15:47 <trap_exit> if you didn't have to output, laziness would make simulation easier
00:15:50 <Qfwfq> I seq.
00:15:57 <Qfwfq> I seq what you mean.
00:16:10 <_tac> I'd like to see a toy language with a pictoral debugger
00:16:19 <trap_exit> you should deepseq
00:16:23 <L8D> _tac: omg that would be awesome
00:16:25 <trap_exit> what if the joke has multiple layers ...
00:16:34 <Qfwfq> Hehe.
00:16:59 <Fuuzetsu> Speaking of laziness, I sped up my program considerably today by removing a single bang. Serves my right for blindly sticking it in to begin with
00:18:09 <L8D> Qfwfq: You're seeking what I mean or you see what I mean?
00:18:31 <L8D> Or are you talking about someone else?
00:18:34 <trap_exit> okay
00:18:34 <trap_exit> I'm done
00:18:38 <jle`> yeah i have been bitten by strictness several times this summer
00:18:40 <trap_exit> next up: RWH
00:19:01 <_tac> just be mindful of how dated RWH can be in places
00:19:03 <L8D> That was a joke? wtf
00:19:15 <L8D> er...Was that a joke?
00:19:18 <Fuuzetsu> that was an easy joke
00:19:36 <trap_exit> lala la la la can't hear you, RWH is awesome la la la la la
00:19:40 <trap_exit> _tac: what parts are you referring to in particular?
00:19:44 <jle`> just be careful :)
00:19:46 <L8D> I don't know what to think of this anymore.
00:19:51 <jle`> there's a nice SO post on it
00:19:52 <L8D> Back to writing my book.
00:20:00 <_tac> trap_exit: I know the QuickCheck examples don't typecheck any more with QC2.0
00:20:31 <trap_exit> why haven't they updated it
00:20:35 <trap_exit> is there no money in writing haskell books? :-)
00:20:49 <jle`> http://stackoverflow.com/questions/23727768/which-part-of-real-world-haskell-is-now-obsolete-or-considered-bad-practise
00:20:56 <pharpend> trap_exit: it's all for ghc 6
00:21:07 <jle`> they = brian o sullivan
00:21:11 <pharpend> trap_exit: it's worth reading, but don't try the examples
00:21:22 <L8D> Why are Haskell programmers the only ones who can write markup?
00:21:24 <jle`> and he is but a human being
00:21:27 <pharpend> trap_exit: well... they might not work
00:22:32 <trap_exit> got it; thanks
00:24:28 <pharpend> listening to that video
00:24:36 <pharpend> infuriated on the use of "um" every other word
00:25:03 * slack1256 sometimes see RWS instead RWH
00:25:04 <pharpend> "if you are, ummmmmmmmmmmmm, interested in, ummmmmmmm..."
00:25:15 <pharpend> "ummmm"
00:25:31 <trap_exit> umm, what video, um are you refering to ?
00:25:48 <pharpend> in the stack overflow link
00:25:50 * trap_exit sees the initials of a friend
00:27:40 <pharpend> https://www.youtube.com/watch?v=cefnmjtAolY&feature=youtu.be&hd=1
00:28:36 <_tac> My main issue with that video is you can't read the slides.
00:28:50 <Fuuzetsu> if that's the lens video then the slides can be found on the net
00:29:00 <_tac> also, I can't really say I've ever even considered fmap . fmap until I saw that video
00:29:08 <pyrtsa> _tac: http://comonad.com/haskell/Lenses-Folds-and-Traversals-NYC.pdf
00:29:16 <Fuuzetsu> _tac: in fact the slides are the very first thing in the video description
00:29:21 <_tac> Not exactly a universal motivator for why lenses matter.
00:29:35 <Fuuzetsu> What did you use before fmap . fmap?
00:29:46 <_tac> Audio quality is all right, though, save a bit of audio fuzz. (But better than not being able to hear at all)
00:29:57 <_tac> ah, so they are
00:30:42 <Fuuzetsu> The audio was really broken when the video first was uploaded, AFAIK someone painstakingly went through it all (multiple times) fixing it up
00:30:59 <_tac> audio is really hard to get right
00:33:11 <Fuuzetsu> fucking bootfiles
00:33:31 <Fuuzetsu> if I have bootfiles, they will always be compiled first and then their respective modules have to get recompiled and then everything else depending on them, right?
00:33:38 <Fuuzetsu> I should get rid of those stupid things
00:34:08 <pharpend> :t (.) . (.) . (.) . (.) . (.)
00:34:09 <lambdabot> (b -> c) -> (a -> a1 -> a2 -> a3 -> a4 -> b) -> a -> a1 -> a2 -> a3 -> a4 -> c
00:37:12 <_tac> I still don't quite get what traverse has to do with lenses....
00:39:48 <joelteon> lenses operate on traversals
00:41:12 <joelteon> well, or they produce traversals I guess
00:41:31 <pharpend> I like the lecturer
00:41:53 <_tac> And if my memory serves me, every appicative can be given the structure of a traversable
00:50:22 <hattusili_III> can anyone point to a good example of a haskell library that wraps a web api?
00:50:55 <Qfwfq> The Stripe library is quite good. Maybe look at the HAXL examples.
00:51:47 <hattusili_III> Qfwfq, out of curiosity, what web api does the Stripe library provide?
00:52:18 <Qfwfq> Uh, it provides an interface to Stripe. The payment service.
00:53:04 <Qfwfq> https://hackage.haskell.org/package/stripe https://stripe.com/docs/api
00:53:20 <hattusili_III> oh stripe!
00:53:43 <hattusili_III> it's just that stripe is not obviously a name, but a word on its own, so it slipped my mind
00:53:52 <hattusili_III> thank you
00:53:54 <Qfwfq> libjenkins does some cool stuff with lenses/aeson, but it's a bit of a pain to read at first.
00:54:12 <Qfwfq> yw
01:17:47 * hackagebot xml-push 0.0.0.3 - Push XML from/to client to/from server over XMPP or HTTP  http://hackage.haskell.org/package/xml-push-0.0.0.3 (YoshikuniJujo)
01:27:59 <pharaun> oh i just got 7.8
01:28:01 <pharaun> man i'm behind
02:07:58 <Angelique23>  You can find funny videos here. http://tinyurl.com/ozfvxy3
02:08:30 <jle`> to be honest the videos weren't that funny
02:08:41 <jle`> (i'm just kidding, don't click on it)
02:14:16 <geekosaur> was gonna say... only way I'd click on that is in a forensic VM (while grumping about how I got stuck doing something I realy have no business doing, since I have neither the tools nor the requisite knowledge)
02:23:40 <L8D> I would just open an igncognito window in chrome
02:24:03 <L8D> then again, I have nothing worth anything on my machine
02:24:04 <silver> it's still not safe
02:24:18 <L8D> since it's just a <300mb installation of arch on a usb stick
02:24:19 <silver> but you can become a bot theoretically
02:24:25 <silver> oh hehe
02:24:54 <L8D> oh dang this is #haskell what is that bot doing here?
02:25:03 <nezt> what didi  miss
02:25:40 <nezt> booting from usb stick FTW
02:26:35 <L8D> I'm using a school-issued laptop and I'm not allowed to touch the hard drive
02:26:49 <L8D> so I spent a dollar on a stick and installed arch on it through virtualbox
02:27:23 <L8D> it has the WORST read/write speeds with frequent stalls during file io
02:28:38 <arianvp> join haskell-blah
02:34:08 <wz1000> What library is recomended for doing network programming?
02:34:44 <arianvp> wz1000. It really depends on your usecase
02:35:20 <Guest30691> I tried for an entire day now but i cant get yesod to install properly. cabal keeps failing when i try to do cabal install alex happy yesod-bin
02:36:08 <arianvp> GGuest30691: try these instructions? It uses sandboxing instead. https://github.com/lambdacms/lambdacms-core
02:37:22 <arianvp> Another thing you could try is set your package server to hackage
02:37:24 <arianvp> stackage*
02:37:32 <arianvp> It only allows install of packages that are compactible
02:37:40 <arianvp> It helped me resolve A LOT of headaches
02:37:46 <Guest30691> im on stackage already
02:37:51 <arianvp> oh wow
02:37:55 <arianvp> I can haz error log?
02:38:00 <arianvp> with -v ?
02:38:28 <lpaste_> Guest30691 pasted “yesod install ” at http://lpaste.net/9016505224805744640
02:38:29 <wz1000> arianvp: Mainly lots of short messages and occasional file transfers between two devices.
02:39:32 <Guest30691> Guest30691
02:39:32 <Guest30691> http://lpaste.net/9016505224805744640
02:39:38 <arianvp> wz1000: You come a long way just using the 'network' package
02:39:51 <arianvp> that's my experience
02:40:13 <arianvp> I've did some toy projects using conduit and pipes but nothing big
02:40:31 <wz1000> The Network package sounds perfect for my use case, but it says it was kept for backward compatibility reasons.
02:41:06 <arianvp> where does it say that?
02:41:15 <arianvp> oh yeah
02:41:29 <arianvp> The Network modules is kept for backwards compactibility
02:41:35 <arianvp> not the entire package
02:41:48 <arianvp> the package is fine. just use  Network.Socket (which is in the same package)
02:42:19 <wz1000> Why is the Network module not recommended?
02:42:55 <arianvp> wz1000: it makes too many assumptions, for example, you cant use UDP
02:42:58 <lpaste_> Guest30691 pasted “yesod install reinstall” at http://lpaste.net/111027
02:42:59 <Guest30691> When i do a --force-reinstalls there is user error (/usr/bin/ld: cannot find -lgmp
02:42:59 <Guest30691> collect2: ld returned 1 exit status
02:42:59 <Guest30691> )
02:42:59 <Guest30691> When i do a --force-reinstalls -v i get
02:43:55 <arianvp> wz1000: Network.Socket is basically the  BSD socket API. which is usually what you want
02:45:14 <yesthisisuser> How do I properly free the resources acquired using createPostgresqlPool in Persistent?
02:46:20 <wz1000> arianvp: If I don't want UDP, will Network be fine?
02:49:10 <arianvp> wz1000: I'd just use Network.Socket. you have finer-grained control, like setting SocketOptions etc
02:49:58 <arianvp> and it's the standard API used in basically any language
02:50:25 <arianvp> (as it's directly based on `$ man 2 socket`)
02:52:47 <geekosaur> Network's fine up until you need something not in its limited API amd you have to rewrite to Network.Socket or etc. best to use something more flexible to start with
02:56:14 <geekosaur> also I think they want to deprecate the whole API in favor of Network.Socket anyway
02:56:59 <wz1000> Are there any more API's I may want to look at?
02:58:45 <XniX23> is it possible that when mapping with applicative that there isn't only one function inside a functor but many more?
03:00:37 <pharaun> http://lpaste.net/111028
03:00:43 <pharaun> i feel like i'm not getting it
03:00:45 <Feuerbach> > [(+10), (*2)] <*> [1..4]
03:00:46 <lambdabot>  [11,12,13,14,2,4,6,8]
03:00:51 <XniX23> for instance if the first functor would actually be a list of functions (a -> b) and then second one would be a list of a's. It would make sense to apply every function to every element from the second list and get all the ombinations
03:00:55 <Feuerbach> XniX23: like that? ^
03:01:50 <XniX23> Feuerbach, that's exactly what i was talking about... so when mapping multiple things you're actually doing combinations lol
03:02:01 <pharaun> i could use some advice ^ regarding freeT
03:02:02 <XniX23> thanks
03:02:11 <bennofs> > ZipList [(+), (-)] <*> ZipList [1,2] <*> ZipList [3,4]   -- there is another, different way to implement a valid Applicative for [] XniX23
03:02:12 <pharaun> I got some good examples, but i can't seem to make this ADT work
03:02:13 <lambdabot>  ZipList {getZipList = [4,-2]}
03:05:56 <XniX23> bennofs, i don't get this example :\ what does ZipList do? it's probably a zipping lists but i don't see two lists taken
03:06:35 <jle`> XniX23: it's just a newtype wrapper over a list
03:06:41 <jle`> do you know what newtypes are?
03:06:50 <bennofs> XniX23: In a <*> b, instead of applying each function of a to each value of b, you could "zip" the lists: apply the first function in a to the first value in b, the second function in a to the second value in b, etc
03:07:06 <bennofs> XniX23: that would also form a valid Applicative instance for lists
03:07:07 <XniX23> jle`, i don't
03:07:58 <XniX23> bennofs, oh, i see it now, that's like a normal indexedbased map
03:08:22 <jle`> ah.  well, in this case, it's basically a wrapper over a list.  It works so that when you use <*> on the *wrapped* lists, it uses the zippy applicative instance, instead of the normal list instance
03:08:43 <jle`> a common example is wrappers for types with Monoid instance
03:09:03 <jle`> > mappend (Just [1,2]) (Just [5,6,7])
03:09:04 <lambdabot>  Just [1,2,5,6,7]
03:09:11 <jle`> ^ the default Monoid instance for Maybe a
03:09:24 <jle`> > mappend (First (Just [1,2])) (First (Just [5,6,7]))
03:09:25 <lambdabot>  First {getFirst = Just [1,2]}
03:09:32 <pharaun> this is killing me
03:09:39 <jle`> ^ a special monoid instance over Maybe a, using the First wrapper
03:10:29 <jle`> pharaun: do you see why it is expecting a Segment i o n ?
03:10:39 <pharaun> no i don't :[
03:10:45 <pharaun> its also 3am
03:10:47 <jle`> data Segment i o n
03:10:49 <jle`>     = Match (i -> Bool) (Segment i o n)
03:10:53 <pharaun> well yeah
03:11:02 <jle`> the Match constructor takes an (i -> Bool) and a (Segment i o n)
03:11:07 <pharaun> i'm probably just keeping on confusing the shit out of myself
03:11:09 <jle`> but here you are giving it an (i -> Bool) and a ()
03:12:00 <pharaun> well i'm stuck on uh how i can give it what it want then :|
03:12:27 <bennofs> pharaun: you need to do data Segment i o n = Math (i -> Bool) n | ...   basically, instead of using Segment i o n directly, you always just use n.
03:12:35 <jle`> i don't know what you want to give it
03:12:49 <jle`> you can construct a Segment i o n from scratch if you want
03:12:54 <jle`> but i do'nt know if that's what you really want your program to do
03:13:00 <jle`> Choice [] :: Section i o n
03:13:46 <pharaun> bennofs: that's what i figured but then it makes my functor instance fail
03:14:15 <bennofs> pharaun: just replace fmap f by f in your functor instance and it'll work
03:14:43 <pharaun> k that made it work, hm let's see
03:15:48 <pharaun> jle`: ohh >_<
03:16:02 <pharaun> bennofs: jle` thanks again
03:16:15 <pharaun> i should probably head to bed before i get more frustrated :) but that worked
03:16:44 <jle`> :)
03:16:49 <jle`> ghc is like a nice "go to bed now" reminder
03:16:54 <pharaun> hahaha yes
03:17:02 <jle`> it stops you before you are too sleepy to write meaningful programs
03:17:18 <pharaun> i just have a bad habit of going grr this is pissing me off and wanting to grind at it till i get it or i sufficiently bend it to work
03:21:54 <XniX23> jle`, the First example you gave, why would you even do mappend if all it does it returns the first?
03:22:09 <jle`> XniX23: sometimes it's useful to find the "first" Just result
03:23:06 <jle`> > fold (map First [Nothing, Nothing, Just "hello", Nothing, Just "world"])
03:23:07 <XniX23> jle`,  but isn't that always the first parameter?
03:23:07 <lambdabot>  First {getFirst = Just "hello"}
03:23:18 <jle`> > mconcat (map First [Nothing, Nothing, Just "hello", Nothing, Just "world"])
03:23:18 <wz1000> Can't we have a Listlike typeclass? I see so many implementations of the functions in Data.List for specific types.
03:23:19 <lambdabot>  First {getFirst = Just "hello"}
03:23:27 <jle`> > mappend Nothing (First (Just 4))
03:23:28 <lambdabot>  Couldn't match expected type ‘Data.Maybe.Maybe a’
03:23:28 <lambdabot>              with actual type ‘Data.Monoid.First a0’
03:23:29 <XniX23> jle`, ohhhh i forgot about Nothings
03:23:38 <jle`> > mappend (First Nothing) (First (Just 4))
03:23:40 <lambdabot>  First {getFirst = Just 4}
03:24:03 <jle`> wz1000: it's a little iffy what would be a part of the typeclass, and what the laws would be
03:24:26 <jle`> from a lot of trial and error we have come to the general conclusion that typeclasses without meaningful laws tend to be a bad idea
03:24:43 <XniX23> jle`, how does First know which one to skip, in this example that Nothing
03:24:43 <jle`> and that typeclasses solve a lot less problems then you might think
03:24:53 <jle`> XniX23: it picks the first Just
03:25:02 <arianvp> ugh typeclasses
03:25:20 <XniX23> jle`, so it only works on Maybe?
03:25:56 <jle`> XniX23: yeah, newtype First a = First (Maybe a)
03:26:13 <jle`> says that First a is a "wrapper" over a Maybe a
03:26:22 <jle`> and that you can "wrap" it with the First constructor
03:34:53 <XniX23> does code reuse in haskell only look like something like this: make something an instance of something, get all the functions already written for this kind of instance?
03:35:29 <jle`> no :)
03:36:04 <silver> more like (optional: make a lib), use a lib
03:36:27 <MichaelBurge> XniX23: another way is to define modules that export functions
03:37:04 <jle`> i like to look at function transformers/lifters and the "category design pattern"
03:37:35 <jle`> you don't have to write (a -> b)'s, Maybe a -> Maybe b versions, IO a -> IO b versions of your (a -> b) function...you can just write one and lift it to any context you want
03:37:41 <XniX23> haha ok apart from importing functions ;P i was thinking about reuse on a more abstract level
03:38:04 <joelteon> write an ML-style module using Backpack!
03:38:05 <jle`> you can freely move your functions from context to context, if they are meaningfully compatible
03:38:14 <silver> there are various ways to transform functions
03:38:52 <silver> type classes too, but that's the only way
03:39:04 <silver> err
03:39:17 <silver> but that's _not_ the only way
03:40:05 <jle`> to me typeclasses represent more about equational reasoning and type safety than about code ruse
03:40:07 <jle`> reuse
03:40:39 <vicm> hey everyone :)
03:40:43 <silver> hello
03:41:12 <mjrosenb> jle`: I've used them for code reuse a few times.
03:41:31 <pantsman-> just writing parametric functions, typeclass constraints or not, helps reuse
03:41:51 <XniX23> jle`, that does sound useful but isn't this just making it an instance of monad and being able to work on all monad contexts?
03:41:54 <vicm> i was wondering if anyone is fairly familiar with the @viewport  rule in CSS
03:41:54 <jle`> mjrosenb: i mean that to say that when i think about them, i usually think more about those aspects than reuse.  but it definitely lends to reuse too :)
03:42:38 <jle`> XniX23: well, moving from (a -> b) -> (Something a -> Something b) can be done if Something is a Functor
03:43:21 <jle`> and you can also write such functions without having them involve the Functor typeclass
03:43:40 <jle`> if you have types like (Foo a -> Foo b), you can write a function to convert it to (Bar a -> Bar b)
03:43:49 <prophile> type List a = forall m. Monoid m => (a -> m) -> m
03:43:50 <prophile> so pretty
03:44:04 <jle`> but it's the ease in which haskell lets you work with "function lifters" that is the real power here
03:48:35 <XniX23> jle`, what exactly is meant with lifting? transformation?
03:48:56 <silver> @hoogle lift
03:48:58 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
03:48:58 <lambdabot> Control.Monad.Trans.Class lift :: (MonadTrans t, Monad m) => m a -> t m a
03:48:58 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
03:57:48 <silver> also liftM/liftA stuff, sorry for hijacking answer :P
04:10:48 <tlo> Hi, newbie question: I use getTables of Database.HDBC which returns type 'IO [String]'. Is there a shortcut for 'x <- getTables conn ; "teststring" `elem` x' ? Because I don't really need that x later...
04:13:37 <lyxia> tlo: elem "teststring" <$> getTables conn
04:15:55 <tlo> lyxia: nice, thanks!
04:24:53 <XniX23> why doesn't this work? Just (-3) <*> Just 3
04:26:09 <exio4> because -3 is a number and 3 too,
04:26:20 <exio4> > Just (- 3) <*> Just 3
04:26:21 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> b))
04:26:21 <lambdabot>    arising from the ambiguity check for ‘e_133’
04:26:21 <lambdabot>  from the context (GHC.Num.Num (a -> b), GHC.Num.Num a)
04:26:21 <lambdabot>    bound by the inferred type for ‘e_133’:
04:26:21 <lambdabot>               (GHC.Num.Num (a -> b), GHC.Num.Num a) => Data.Maybe.Maybe b
04:26:43 <exio4> > Just (3-) <*> Just 3
04:26:45 <lambdabot>  Just 0
04:27:47 <XniX23> oh i see, ty
04:31:17 <gfixler> > Just (+-3) <*> Just 3
04:31:18 <lambdabot>  Not in scope: ‘+-’
04:31:18 <lambdabot>  Perhaps you meant one of these:
04:31:18 <lambdabot>    ‘-’ (imported from Prelude), ‘++’ (imported from Data.List),
04:31:18 <lambdabot>    ‘+’ (imported from Prelude)
04:31:23 <gfixler> > Just (+(-3)) <*> Just 3
04:31:25 <lambdabot>  Just 0
04:36:00 <mietek> Does anyone have the original pdf for The Design and Implementation of xmonad?
04:36:35 <mietek> Scribd has it archived behind a paywall
04:36:43 <mietek> It looks like it's disappeared off Galois pages
04:48:05 * hackagebot fay 0.20.2.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.20.2.0 (AdamBergmark)
04:50:13 <phaazon> hey
04:50:18 <phaazon> I have a Vector Value in aeson
04:50:26 <phaazon> and I’d like to turn that into [Int]
04:50:39 <phaazon> toList yields a [Value]
04:50:49 <phaazon> then how do I access Scientific from that?
04:51:05 <phaazon> with a map?
04:53:39 <blueonyx> phaazon: you can try fromJSON yourValue :: Result [Scientific]
04:55:21 <blueonyx> > fromJSON (toJSON ([12,34]::[Int])) :: Result [Scientific]
04:55:23 <lambdabot>  Not in scope: type constructor or class ‘Scientific’Not in scope: ‘fromJSON’...
04:55:34 <blueonyx> gives for me: Success [12.0,34.0]
04:55:39 <phaazon> ok
04:55:40 <phaazon> thank you
04:58:58 <blueonyx> phaazon: err, you probably want to use one of the decodes
04:59:44 <phaazon> this is quite weird
05:00:15 <phaazon> sounds hard to parse an array with aeson
05:00:56 <blueonyx> what exactly is your input?
05:13:19 <nshepperd> mietek: fortunately it's in the wayback machine https://web.archive.org/web/20090920021844/http://galois.com/~dons/talks/xmonad.pdf
05:15:30 <nshepperd> mietek: uploaded it at http://zlkj.in/files/xmonad.pdf just to make sure it won't get lost again :)
05:16:50 <mietek> nshepperd: cheers!
05:18:51 <srhb> Is there an infix version of uses foo bar?
05:18:56 <nshepperd> (you never know when some troll will buy up your domain name, and post a restrictive robots.txt file to make things disappear from archive.org)
05:19:26 <mietek> nshepperd: I hate when that happens
05:19:42 <mietek> nshepperd: I suspect the archive team also hates that, and they keep the files regardless
05:19:50 <mietek> nshepperd: real librarians are patient
05:20:01 <mietek> nshepperd: eventually, the troll will too pass
05:23:26 <nshepperd> we'll see who rusts first
05:26:19 <nshepperd> :t uses
05:26:21 <lambdabot> (MonadState s m, Profunctor p) => Optical p (->) (Const r) s s a a -> p a r -> m r
05:27:22 <nshepperd> Lens magic eh
05:27:42 <bennofs> nshepperd: uses :: MonadState s m => Getter' s a -> (a -> b) -> m b
05:33:38 <gspr> Is there a way to tell the relevant functions in http-client-tls (or tls) to accept one specific certificate fingerprint when connecting to a server?
06:02:27 <ddellacosta> hello #haskell.  Typeclass beginner here.  Trying to wrap my head around creating a functor for: data ITree a = Leaf (Int -> a) | Node [ITree a] (from functor exercises in Typeclassopedia)
06:02:52 <ddellacosta> but can't seem to figure out what is wrong with my fmap (for Leaf at least): fmap f (Leaf g) = Leaf (f g)
06:03:15 <ddellacosta> getting "Couldn't match expected type ‘Int -> b’ with actual type ‘b’..."
06:03:17 <mauke_> you can't apply f to g
06:03:27 <mauke_> exactly
06:03:54 <mauke_> f wants 'a'. g is 'Int -> a'
06:03:58 <ddellacosta> mauke_: so, that's what I'm confused by.  Why can I not apply f to g?  Wouldn't g be the a that gets returned by (Int -> a)?
06:04:03 <mauke_> no
06:04:13 <ddellacosta> ah, so, this is what I'm not getting.
06:04:14 <mauke_> g is the function
06:04:31 <hellertime> ddellacosta: look at the type of f
06:05:25 <ddellacosta> hellertime: right, f is (a -> b), so it needs to take an a...but a here is (Int -> a) (that a being a different a, I guess) right?
06:05:43 <ddellacosta> sorry, confusing grammar with all those "a"s
06:05:57 <mauke_> same a, actually
06:06:32 <hellertime> ddellacosta: g is Int -> a, a is just a
06:06:50 <mauke_> you have: f :: a -> b; g :: Int -> a
06:06:58 <mauke_> you need: Int -> b
06:07:15 <ddellacosta> aha...okay
06:08:32 * ddellacosta is going to go away and think about that for a minute, thanks to hellertime and mauke_
06:17:25 <XniX23> do let statements compile to lambdas behind the scenes?
06:18:34 <luite> XniX23: there is optimization first, but the let bindings that survive and make it to STG are compiled to heap (or stack) object allocations
06:19:43 <NikolajK> 'foo = \x -> foo x' is legal haskell code, where foo :: forall a.a->a.
06:19:43 <NikolajK> So I conclude
06:19:43 <NikolajK> a : A, b : B
06:19:43 <NikolajK> ————
06:19:43 <NikolajK> \a->b : (A->B)
06:19:43 <NikolajK> isn't the only way to set up functions. We couldn't even have judged "foo x : a" before having defined the type of  foo… I'm a little confused how exactly the Haskell type system differes from naive simply typed lambda calculus here
06:27:02 <nshepperd> :t (let foo x = foo x in foo)
06:27:03 <lambdabot> t -> t1
06:28:13 * hackagebot hsimport 0.6.1 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.6.1 (DanielTrstenjak)
06:34:37 <NikolajK> nshepperd: is that an answer?
06:35:36 <nshepperd> no, I don't know
06:36:27 <nshepperd> according to http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system you can handle recursive definitions by rewriting to use a fixed point combinator with known type
06:37:09 <nshepperd> such as fix : ∀a. (a -> a) -> a
06:38:50 <NikolajK> after plaiyng with ghci, let me put it this way
06:40:02 <NikolajK> (let f x = f x in (f::Int->Int)) 7
06:40:02 <NikolajK> is accepted and non-halting. But I'm not sure if it's legality to be written down is given by
06:40:03 <NikolajK> a : A, b : B
06:40:03 <NikolajK> ————
06:40:03 <NikolajK> \a->b : (A->B)
06:40:41 <NikolajK> thinking about it, it might be of this form, because _|_ : B always and so the program coded up this way is the same as const _|_
06:42:02 <nshepperd> yes, I think that rule is insufficient, without an axiom for 'fix :: (a -> a) -> a'
06:43:03 <nshepperd> or you can write a new rule for letrec
06:45:05 <nshepperd> :t fix ($)
06:45:06 <lambdabot> a -> b
06:48:28 <sshine> @pl foldl f e (map g xs)
06:48:29 <lambdabot> foldl f e (map g xs)
06:49:19 <mauke> @pl \foldl map -> foldl f e (map g xs)
06:49:19 <lambdabot> (. flip ($ g) xs) . flip ($ f) e
06:52:24 <sshine> hehe
06:53:20 <sagittarian> do you eventually just get used to all those flips in the pointless forms?
06:53:54 <sagittarian> i mean, i guess that in order to get the arguments to come out in the right order and to get function types to line up you'd need them
06:54:30 <sagittarian> maybe when you start really glorking pointless haskell you just naturally assume that the arguments are in the order that they come out in naturally, thus saving a few flips
06:54:31 <simpson> No, the entire joke is that pointless forms are nearly unreadable.
06:54:35 <ddellacosta> So, I thought I was getting closer to figuring out what fmap should be for "data ITree a = Leaf (Int -> a) | Node [ITree a]", but I'm still not getting it.  I have no idea how to apply the f in "fmap f ..." to "Leaf (Int -> a)"
06:54:56 <sagittarian> simpson, unreadable is a matter of perspective
06:55:34 <barrucadu> ddellacosta: Well, your f is of type a -> b, right? What function can combine an (a -> b) and a (b > c), giving a (a -> c)?
06:55:43 <simpson> @pl \a b c d e f -> f e (d b c) a -- sagittarian
06:55:43 <lambdabot> flip (flip . ((flip . ((flip . (flip .) . flip (flip . flip id)) .)) .) . flip . flip id)
06:56:02 <barrucadu> * a (b -> c)
06:56:16 <barrucadu> :t (.)
06:56:18 <lambdabot> (b -> c) -> (a -> b) -> a -> c
06:56:18 <ddellacosta> barrucadu: (yeah, figured that's what you meant) thinking
06:56:20 <sagittarian> nice
06:56:39 <sagittarian> :t flip id
06:56:40 <lambdabot> b -> (b -> c) -> c
06:56:55 <simpson> :t flip flip flip
06:56:56 <lambdabot> (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
06:57:04 <sagittarian> :t flip ($)
06:57:05 <lambdabot> b -> (b -> c) -> c
06:57:12 <sagittarian> that's better, it looks more cryptic
06:57:36 <ddellacosta> barrucadu: okay, I guess I have to apply composition in a specific order though, huh?  Sorry, probably a stupid question but it's not clicking for me yet
06:57:56 <sagittarian> there should be an unobfuscated pointless haskell contest
06:58:12 <sagittarian> a prize to whoever writes the most non-trivial, most readable point-free haskell program
06:58:45 <simpson> ddellacosta: Well, you have (Int -> a) and (a -> b) and you need to produce (Int -> b)
06:59:51 <ddellacosta> simpson: okay, I'll go sit on that one for a while.  I feel like with Haskell people are always saying these things to me that should be incredibly obvious to me, but I'm missing some fundamental puzzle piece that makes it impossible for me to grasp. *sigh*
06:59:56 <barrucadu> You can read "f . g" as "do g first, then do f". So first you want to turn the Int into an 'a', then you want to turn the 'a' into a 'b'
07:00:36 <sagittarian> :t flip . flip
07:00:37 <lambdabot> (b -> a -> c) -> b -> a -> c
07:00:54 <sagittarian> :t flip $ flip . flip
07:00:55 <lambdabot> b -> (b -> a -> c) -> a -> c
07:01:24 <ddellacosta> barrucadu: okay, thanks
07:01:27 <simpson> ddellacosta: Well, you have these pieces. If I hand you an int, you can make a, and then b.
07:01:28 <stefan_1> hi, just started learning haskell a couple of weeks ago, I feel like I'm learning to use the force
07:01:33 <stefan_1> managed to solve 25 euler problems so far
07:01:56 <sagittarian> stefan_1, cool
07:03:42 <stefan_1> are there any typical "rite of passage" programs to get started with writing non-trivial stuff? like with lisp you would write your own lisp dialect, or with C you would write your own versions of common unix commands
07:04:13 <ddellacosta> simpson, barrucadu: fmap f (Leaf a) = Leaf (f . a) <- but, where does the Int I need come from?
07:04:25 <sshine> stefan_1, you could make either a Unix command or some kind of parser+interpreter.
07:04:46 <sshine> stefan_1, Jekor's video tutorial shows how to make a variant of "make".
07:04:48 <simpson> ddellacosta: Same place as before. Somebody will have to provide an Int if they want to get b.
07:04:54 <sagittarian> stefan_1, write a program to compute factorials, or fibonacci numbers
07:04:58 <barrucadu> ddellacosta: The Int doesn't come from anywhere, because you want a Leaf (Int -> b)
07:05:15 <sagittarian> that's basically all that haskell is good for, after all
07:05:25 <ddellacosta> simpson, barrucadu: okay, sorry I'm so dense. I'll go think about that for a bit.
07:05:30 <stefan_1> sagittarian, done that a million times over when solving project euler stuff :P
07:05:35 <simpson> ddellacosta: No worries.
07:05:38 <stefan_1> sshine, thanks, I'll have a look
07:05:51 <sagittarian> stefan_1, now do it in the type system at compile time
07:05:53 <sshine> stefan_1, if you've already solved a bunch of Euler assignments, you should probably branch into some more specific use of Haskell, like compilers, games or something else recreative.
07:06:04 <simpson> sagittarian, stefan_1: Haskell's closely related to the ML family. ML stands for "metalanguage". Why not implement a simple language in Haskell?
07:06:37 <sagittarian> there's a "build yourself a scheme using haskell" book floating around somewhere (wikibooks?)
07:06:53 <sagittarian> probably a really worthwhile project (it's on my todo list, someday)
07:06:54 <sshine> stefan_1, I saw a dissertation in which someone had made Spanish language combinators in Haskell. a combinator library for some useful purpose would be neat. :)
07:06:58 <stefan_1> this one? http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
07:07:20 <sagittarian> looks right
07:07:37 <stefan_1> I'll have to learn what exactly a combinator is
07:08:15 <stefan_1> thanks for the tips!
07:08:16 <sshine> stefan_1, it's a function that can be composed with other functions.
07:08:22 <sagittarian> my problem with advancing in haskell is that whenever i sit down to do something useful, i end up encountering some interesting new idea or abstraction
07:08:38 <sshine> stefan_1, http://programmers.stackexchange.com/questions/117522/what-are-combinators-and-how-are-they-applied-to-programming-projects-practica
07:08:47 <sagittarian> and instead of learning just enough to do what i originally planned to do, i end up spending a bunch of time learning about the new toy and don't get what i originally wanted to do done
07:09:16 <sshine> sagittarian, I know the feeling.
07:09:55 <NikolajK> >Write_Yourself_a_Scheme_in_48_Hours, Write yourself a Haskell,… I'm not native, but that's improper english, right?
07:10:22 <sagittarian> "a scheme", "a haskell" is pretty atypical
07:10:34 <sagittarian> but it has special meaning here i think
07:10:37 <NikolajK> I don't get why programmers like to associate themselves with penguins and oxes.. or other silly animals. Seems counterproductive
07:10:44 <barrucadu> No, that works if you consider "Scheme" or "Haskell" to be families of languages with common characteristics
07:10:45 <sagittarian> normall scheme and haskell are proper nouns
07:10:49 <XniX23> why are these 2 things different? :t (*) <$> Just 5; :t fmap (*) Just 5
07:11:00 <sagittarian> but here they're being used as 'an implementation of haskell/scheme'
07:11:04 <barrucadu> "A Scheme" being a language very much like what is typically considered to be Scheme
07:11:20 <sagittarian> kind of like 'coffee' is normally an uncount noun, but you can say 'a coffee' to refer to 'a cup of coffee', etc
07:11:20 <sshine> XniX23, don't you mean fmap (*) $ Just 5?
07:11:38 <sshine> whoops, no
07:12:28 <sshine> XniX23, first off, <$> is fmap infixed.
07:12:48 <XniX23> i know
07:13:07 <barrucadu> XniX23: Function application has the highest precedence
07:13:10 <ddellacosta> okay, simple question: how do I import just "." from GHC.Base?  import GHC.Base (.) doesn't do it
07:13:21 <XniX23> i figured it out, it should be fmap (*) (Just 5)
07:13:31 <XniX23> else it probably wanted to give 3 args to fmap
07:14:06 <sipa> ddellacosta: GHC.Base.(.) ?
07:14:06 <barrucadu> So "(*) <$> Just 5" is parsed as "(*) <$> (Just 5)", and "fmap (*) Just 5" is parsed as "(fmap (*) Just) 5"
07:14:24 <barrucadu> ddellacosta: (.) is in the Prelude, you don't need to explicitly import it
07:14:45 <ddellacosta> barrucadu: well, I'm using NoImplicitPrelude just to be difficult. :-p
07:14:59 <ddellacosta> barrucadu: (because I'm implementing stuff like Functor and whatnot myself)
07:15:25 <simpson> @src (.)
07:15:25 <lambdabot> (f . g) x = f (g x)
07:15:30 <simpson> Just define it yourself.
07:15:35 <ddellacosta> simpson: ah, yeah, good point.  Thanks
07:15:51 <ddellacosta> sipa: p.s. that didn't work for me. :-(
07:16:13 <sagittarian> (.) = flip (>>>) -- after you import Control.Arrow, of course
07:16:32 <simpson> Or import Control.Category's version.
07:17:03 * simpson remembers those glorious days when lambdabot used Control.Category for id and (.)
07:17:44 <ddellacosta> yeah...I'm just trying to understand basic stuff now.  I don't want to use any "advanced synonyms" like that now since I have no idea what they'd be doing.
07:18:38 <ddellacosta> incidentally, is there a version of that @src command for ghci?
07:18:43 <ddellacosta> @src fmap
07:18:43 <lambdabot> Source not found. It can only be attributed to human error.
07:18:52 <ddellacosta> @src (+)
07:18:52 <lambdabot> Source not found. You untyped fool!
07:19:04 <ddellacosta> well then
07:19:46 <sagittarian> ddellacosta, you can download lambdabot and run her from your own command line
07:19:59 <cdk> ddellacosta: the implementation of those typeclass operators differs per instance, lambdabot can't know which instance you want
07:20:08 <ddellacosta> cdk: gotcha, I see
07:20:14 <HeladoDeBrownie> ddellacosta, operators need to be surrounded in parens when imported. import Foo ((.))
07:20:36 <ddellacosta> sagittarian, HeladoDeBrownie, thanks both for the tips respectively
07:21:00 <simpson> ddellacosta: @src is a hand-curated list; it's not automatically generated.
07:21:41 <sagittarian> @src foldr
07:21:41 <lambdabot> foldr f z []     = z
07:21:41 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:22:27 <ddellacosta> simpson: I see.  I suppose it may be easier for me just to keep ghc sources handy and look stuff up for now. :-/
07:22:31 <sagittarian> that is not the actually definition in the source, according to hoogle
07:22:49 <sagittarian> @pl \f z (x:xs) -> f x (foldr f z xs)
07:22:49 <lambdabot> flip flip tail . (ap .) . flip flip head . ((.) .) . ap ((.) . flip . ((.) .)) foldr
07:22:57 <sagittarian> that one's my favorite
07:23:29 * barrucadu screams
07:25:57 <sagittarian> @src zipWith
07:25:57 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
07:25:57 <lambdabot> zipWith _ _      _      = []
07:26:29 <sagittarian> @pl \f (a:as) (b:bs) -> f a b : zipWith f as bs
07:26:30 <lambdabot> (`ap` tail) . (. head) . flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .)) .) . liftM2 flip (((.) . flip . (((.) . (:)) .)) .) zipWith
07:27:58 <sagittarian> someday, young padawan, you will gaze upon the output of @pl, and the meaning will be intuitively obvious to you
07:30:38 <sshine> hopefully not :P
07:31:01 <sshine> intuition is based on experience - I'm not sure I want whatever experience that entails. ;-)
07:33:07 <nadirs> Hello! I'm trying to write a parser for the todo.txt format using applicative like how byorgey does in cis194 (http://www.seas.upenn.edu/~cis194/spring13/extras/05-type-classes/Parser.hs)
07:33:41 <nadirs> I've created a data type, Todo, to match the format
07:34:19 <nadirs> The problem I'm facing is I don't know how to parse two optional parts (priority and completion status)
07:34:42 <nadirs> these two parts are optional, exclude each other and must be the first thing in the string
07:36:28 <sshine> nadirs, if something is optional, it means you could start parsing and then at some point realize you're down the wrong path, right?
07:36:51 <nadirs> sshine: I'm not sure I understand
07:37:09 <nadirs> what do you mean "realize at some point"?
07:37:29 <nadirs> This is what I did: http://lpaste.net/111035
07:38:40 <sshine> nadirs, I don't know this Todo format. but as far as optional language constructs go: "<foo> [bar] <baz>" -- after parsing foo, you might try to either parse a bar, or a baz. if one fails, you should have gone with the other. backtracking in functional parsers can be achieved in at least two ways.
07:38:43 <pjdelport> nadirs: Are you familiar with Alternative and using it?
07:39:31 <nadirs> sshine: it's like "[priority | complete] etc"
07:39:40 <nadirs> pjdelport: I'm not familiar, though I'm using it :P
07:40:14 <nadirs> pjdelport: I think I need to use <|> but the Todo constructor ends up missing an argument
07:40:47 <nadirs> because the two arguments for priority and complete-status are squashed in a single one
07:41:12 <pjdelport> > Just 5 <|> Just 6 <|> Just 7
07:41:14 <lambdabot>  Just 5
07:41:19 <pjdelport> > Nothing <|> Just 6 <|> Just 7
07:41:21 <lambdabot>  Just 6
07:41:31 <pjdelport> (etc.)
07:41:45 <zwer> :t (<|>)
07:41:47 <lambdabot> Alternative f => f a -> f a -> f a
07:42:10 <b52> Hey fellas, I'm wondering what the following "import primitive" statement is: https://github.com/ajhc/demo-android-ndk/blob/master/lib/android-ndk/AndroidNdk.hs#L16 Is that a AJHC addition or is it a well hidden FFi feature?
07:42:17 <nadirs> pjdelport: what I'd want is: if priority parses to Nothing then pass Nothing to Todo constructor and try to parse complete otherwise don't try to parse complete and pass Nothing instead
07:43:18 <nadirs> I tried this: Todo <$> (priority <*> pure Nothing) <|> (pure Nothing <*> complete)) <*> etc...
07:43:32 <phaazon> hey
07:43:37 <phaazon> http://lpaste.net/8404192013955629056
07:43:39 <nadirs> but it doesn't compile because a constructor argument is missing
07:43:46 <phaazon> does anyone have an answer to that?
07:44:14 <pjdelport> nadirs: I'm not 100% sure how the input for the todo parser is supposed to look.
07:45:02 <phaazon> sounds like values are not automatically polymorphic
07:45:04 <phaazon> any idea why'
07:45:05 <phaazon> ?
07:45:13 <nadirs> pjdelport: an example: "(A) foo bar" → priority = Just 'A', complete = Nothing, content = "foo bar"
07:45:23 <pjdelport> nadirs: The basic idea with applicative parsers is that you're just lifting a pure function into one on the outputs of parsers, though... so if you can express your Todo constructor in pure way (ignoring parsing completely) then you can lift that constructor into Parser.
07:45:32 <nadirs> pjdelport: another example: "x foo bar" → priority = Nothing, complete = Just "bla bla", content = "foo bar"
07:45:36 <pjdelport> So ignoring Parser, how would you express the rules for constructing Todo?
07:46:15 <bennofs> @where dmr
07:46:15 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
07:46:18 <nadirs> pjdelport: do you mean, without needing to parse the string sequentially?
07:46:20 <bennofs> phaazon: ^^
07:46:42 <pjdelport> nadirs: Well, just ignoring Parser completely. Imagine you already have parsed data that you want to call Todo with; what are the rules?
07:47:49 <nadirs> a Todo value may have a priority (a simple uppercase char), may be complete (bool is fine for the moment), and has a content (string)
07:47:57 <nadirs> pjdelport: ^
07:48:28 <nadirs> pjdelport: but priority and completeness exclude each other
07:48:56 <pjdelport> So it either has a priority, or a completion flag, but not both?
07:49:06 <nadirs> exactly
07:49:27 <pjdelport> nadirs: Hmm, wouldn't it be simpler if you encode that into your data type?
07:50:03 <nadirs> Probably, yes! I'll try using an "Either Priority Completed" field
07:51:10 <pjdelport> nadirs: Can you have no priority while being incomplete?
07:51:19 <nadirs> pjdelport: yes
07:51:26 <pjdelport> Hmm, okay.
07:51:36 <nadirs> so you say it should be Either (Maybe Priority) Complete
07:51:55 <pjdelport> That sounds about right, then.
07:53:20 <pjdelport> In fact, instead of the generic Either, you might want something more descriptive: data Status = Pending (Maybe Priority) | Complete
07:53:51 <nadirs> pjdelport: sounds good!
07:53:52 <pjdelport> (You could maybe even rename the "Pending" status to "Todo", and rename "Todo" to "Task", but that's nit-picking)
07:54:16 <nadirs> nitpicking is always welcome :)
07:54:37 <pjdelport> Anyway, then you could have: parseTodo  = Todo <$> parseStatus <*> parsteDate <*> parseContent
07:55:44 <nadirs> pjdelport: it will then not be possible to keep the two parsing functions separated, right?
07:56:13 <pjdelport> parseStatus = (Pending <$> parsePriority) <|> pure Complete
07:56:18 <pjdelport> and so on
07:56:48 <pjdelport> nadirs: How do you mean keep them separated?
07:57:00 <nadirs> pjdelport: nice! Thanks, that's what I meant
07:57:16 <pjdelport> The general idea is that your parser structure will mirror your constructor structure almost exactly
07:58:24 <pjdelport> Applications of data constructors map to lifted applications to parser values (using Applicative)
07:58:59 <pjdelport> And choices using sum / choice types (like Either, or Status above) map to Alternative choices, using <|>
08:00:20 <nadirs> I think my main mistake was with how I defined the data structure, which was incompatible with the parser
08:02:37 <pjdelport> nadirs: It's not actually incompatible, no. You could make the previous data structure work, but you would have to write a "smart" constructor that accepts the right values for each scenario and uses them to construct Todo like above.
08:03:42 <pjdelport> But it's easier and simpler when the distance between the data type and the structure to be parsed is smaller, because then you can just lift constructors directly, instead of having to write helper functions that translate structure in non-trivial ways.
08:04:30 <nadirs> I see :)
08:08:36 <b52> Hey fellas, I'm wondering what the following "import primitive" statement is: https://github.com/ajhc/demo-android-ndk/blob/master/lib/android-ndk/AndroidNdk.hs#L16 Is that a AJHC addition or is it a well hidden FFi feature?
08:08:53 <bennofs> b52: probably a AJHC addition
08:09:43 <bennofs> b52: GHC also has some extensions of this kind  like foreign import ccall / foreign import stdcall
08:14:58 <b52> bennofs, yeah, but the correspondig C* code is not a function call
08:16:02 <bennofs> b52: Maybe it's similar to http://www.haskell.org/ghc/docs/latest/html/users_guide/ffi.html#ffi-prim
08:16:33 <ddellacosta> okay, very close I think, but doing something stupid with handling (Node (_ : (_ : _))): https://gist.github.com/ddellacosta/9169fbf1de2207508d2f
08:16:40 <b52> "This feature is not intended for use outside of the core libraries that come with GHC"
08:16:43 <ddellacosta> can someone tell me what newb mistake I'm making there?
08:17:28 <bennofs> b52: well, android-ndk on haskell probably uses some AJHC specific internals
08:19:00 <b52> bennofs, I thought so too but wasn't sure, therefore the question
08:19:17 <pjdelport> ddellacosta: You probably meant (Node (x:xs)) ?
08:20:09 <ddellacosta> pjdelport: still getting "Couldn't match expected type ‘ITree b’ with actual type ‘[ITree a0]’," so there must be something I'm being clueless about
08:20:12 <pjdelport> ddellacosta: Note the inner parentheses: remember that application (i.e. "space") binds tighter than anything, so without the parens, it associates as ((Node x) : xs), which means something else
08:20:25 <ddellacosta> pjdelport: ah, okay, good to remember!
08:20:40 <pjdelport> ddellacosta: Your body will also need to be: Node ((fmap f x) : (fmap f xs))
08:20:42 <pjdelport> for the same reason
08:20:51 <ddellacosta> pjdelport: oh, duh, right--gotcha
08:21:10 <pjdelport> Though it can sometimes be more convenient to write that as: Node $ fmap f x : fmap f xs
08:21:13 <pjdelport> If you don't want all the parens
08:21:25 <ddellacosta> pjdelport: okay, but now I'm getting "Couldn't match type ‘b’ with ‘ITree b’."  Gah.
08:22:09 <ddellacosta> oh, I guess (fmap f xs) is going to be wrong there, no matter what.  Hrm.
08:22:13 <pjdelport> ddellacosta: Well, do you understand what fmap f x is actually doing there?
08:22:34 <pjdelport> Nah, i think it might be right, if that's the intent of ITree
08:22:43 <ddellacosta> pjdelport: oh. huh
08:22:48 <pjdelport> but do you know in general how fmap works with functions / Reader?
08:23:41 <ddellacosta> pjdelport: I don't know what the reader reference means, but I thought I had a grasp of what fmap does w/functions...but what are you asking about in particular?  I mean, I'm coming from the base that fmap's type signature is (a -> b) -> f a -> f b
08:23:50 <ddellacosta> other than that, I may not know what you mean
08:24:57 <ddellacosta> pjdelport: also, I guess I was assuming I'd be recursing into the node, but not sure if that's correct, in terms of following functor laws
08:25:25 <ddellacosta> pjdelport: (this is all just me working through the typeclassopedia if that gives you a sense of my level with these things)
08:25:28 <pjdelport> Well, consider:
08:25:28 <pjdelport> > let f = fmap negate (5+) in f 10
08:25:30 <lambdabot>  -15
08:25:36 <pjdelport> Do you get what that's doing?
08:27:03 <ddellacosta> pjdelport: I'm not super familiar with " in f 10" at the end, but it seems obvious that you could also do "fmap negate (5 + 10)" and get the same thing...why did you define it that way?
08:28:09 <pjdelport> Nah, you can't do "fmap negate (5 + 10)": that would be a type error
08:28:14 <HeladoDeBrownie> ddellacosta, "let ... in ..." represents an expression; the form that lacks the "in ..." part can be used only in do notation (and in ghci, because it's weird)
08:28:29 <ddellacosta> pjdelport: oh, okay
08:28:39 <ddellacosta> pjdelport: so, I guess the answer is no!
08:28:52 <HeladoDeBrownie> The bindings after "let" will be available in the expression after "in"
08:28:53 <pjdelport> ddellacosta: In "fmap negate (5+)", the (5+) is actually a function usually called "Reader" in this case: but it's actually just the Functor instance for functions in general.
08:29:01 <ddellacosta> HeladoDeBrownie: thanks for the explanation!
08:29:13 <pjdelport> ddellacosta: What fmap does for it is operate on the return value of a function.
08:29:42 <wkoiking> hello all
08:29:47 <pjdelport> ddellacosta: So you can imagine just like fmap for lists operates on the elements of the list, fmap for functions operates on the return values of the functions.
08:29:59 <wkoiking> I have some question to ask about yi editor
08:30:01 <ddellacosta> pjdelport: huh, okay, is it correct to say that (5+) is a partially applied function?
08:30:11 <HeladoDeBrownie> ddellacosta, fsvo "partially applied"
08:30:27 <wkoiking> is someone here using yi-editor in windows here?
08:30:31 <pjdelport> ddellacosta: And in fact, what that ends up being equivalent to is function composition, or (.), because when you "apply" a function to the result of another function, you do it by composing it after the other function, right?
08:30:32 <ddellacosta> HeladoDeBrownie: fair enough.
08:30:35 <McEnroe> I'm getting started with haskell and hitting a road block here: http://lpaste.net/111036 Any ideas?
08:31:04 <pjdelport> ddellacosta: Right; more technically, (5+) is operator section syntax.
08:31:05 <ddellacosta> pjdelport: okay, with you so far
08:31:12 <pjdelport> :t fmap
08:31:13 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:31:14 <pjdelport> :t (.)
08:31:15 <lambdabot> (b -> c) -> (a -> b) -> a -> c
08:31:42 <stefan_1> McEnroe, the index operator (!!) takes an Int as its second argument
08:31:45 <HeladoDeBrownie> @type (!!)
08:31:46 <lambdabot> [a] -> Int -> a
08:31:51 <stefan_1> while your function takes an Integer
08:31:55 <pjdelport> ddellacosta: In fact, to make it maybe clearer: (.) :: (a -> b) -> (r -> a) -> (r -> b)
08:32:43 <ddellacosta> pjdelport: oh, I see, huh
08:32:44 <pjdelport> ddellacosta: Imagine that "(r ->)" (a partially-applied function type) is the f in fmap :: Functor f => (a -> b) -> f a -> f b
08:32:51 <HeladoDeBrownie> McEnroe, at a glance, you can most likely avoid the list entirely and just write a recursive function
08:32:56 <McEnroe> stefan_1: Many thanks. Can you perhaps give me a hint at where I should look to solve this issue?
08:32:57 <ddellacosta> pjdelport: yeah, yeah, this is slowly coming clear through the fog
08:33:05 <wkoiking> today I installed yi editor on windows but have no idea where I should put in the config file (yi.hs)
08:33:27 <stefan_1> McEnroe, you can either call fromInteger before !! or change the type signature of your function to take an Int
08:33:38 <McEnroe> HeladoDeBrownie: It explodes. That's why I'm trying memoization.
08:34:06 <ddellacosta> pjdelport: wow, so, huh...that means that fmap is basically acting as . here?  I mean, I guess you said that above
08:34:25 <McEnroe> stefan_1: I do need Integer though. Int is too small.
08:34:26 <pjdelport> ddellacosta: Right; i just wanted to make sure the whole think makes sense in context :)
08:34:52 <ddellacosta> pjdelport: yeah, I have to think through it a bit in terms of the implications, put all the type signatures together solidly, but it's making sense
08:34:57 <HeladoDeBrownie> McEnroe, I've never seen memoization done quite that way and am skeptical it does what you want. Is there some specific source you followed?
08:35:44 * ddellacosta copies this into a buffer for re-reading later
08:36:11 <pjdelport> ddellacosta: There should actually be a much simpler way of implementing "fmap f (Node x) = ..." if i understand that right.
08:36:18 <McEnroe> HeladoDeBrownie: Absolutely: http://www.haskell.org/haskellwiki/Memoization
08:36:25 <pjdelport> ddellacosta: Rather: fmap f (Node xs) = ...
08:36:47 <pjdelport> ddellacosta: Instead of pattern-matching on xs directly, can you use a helper? :)
08:36:51 <HeladoDeBrownie> McEnroe, thanks, looks like I learned something new.
08:38:15 <HeladoDeBrownie> McEnroe, in that case, try defining your own list indexing function that accepts an Integer.
08:38:16 <joshcough> anyone have a preference on a command line processing library, or know of one at all?
08:38:31 <ddellacosta> pjdelport: er, jeez, can I just use fmap here...?  It's almost clear...
08:39:24 <HeladoDeBrownie> It might look something like: [] !!! n = error "..." ; (x:_) !!! 0 = x ; (_:xs) !!! n = xs !!! (n - 1)
08:39:26 <ddellacosta> pjdelport: no, I'm still missing something, but I have to think about what you said a bit more
08:39:37 <HeladoDeBrownie> (I didn't actually try that code)
08:39:46 <ddellacosta> pjdelport: sorry, it's late here and I think my brain is getting fried.  But this was exactly the push I needed, thank you so much!
08:39:50 <pjdelport> ddellacosta: Well, you have a Node containing a list of ITree values. And you have an f that you need to fmap against each of those ITree values, right?
08:40:31 <ddellacosta> pjdelport: right, so I thought I should do: fmap f (Node x) = Node (fmap f x), and that would give me what I wanted, but it's not quite it
08:40:31 <pjdelport> ddellacosta: In other words, you have to apply (fmap f) to each of the list's elements, right?
08:40:43 <ddellacosta> right...
08:41:24 <pjdelport> ddellacosta: Well, (fmap f) itself is the function you'd have to map across the list.
08:41:29 <ddellacosta> pjdelport: doh
08:42:28 <ddellacosta> pjdelport: Node (fmap (\y -> fmap f y) x) then?
08:42:50 <pjdelport> ddellacosta: Well, you could use fmap on the outside there too, but you actually just need map
08:42:51 <ddellacosta> er, rather: fmap f (Node x) = Node (fmap (\y -> fmap f y) x)
08:43:07 <pjdelport> And (\y -> fmap f y) just reduces to (fmap f) :)
08:43:09 <ddellacosta> pjdelport: oh, because map is fmap for List, huh? or, backwards I guess
08:43:11 <ddellacosta> ah
08:43:36 <pjdelport> So your final version might look like: fmap f (Node xs) = Node $ map (fmap f) xs
08:43:55 <ddellacosta> pjdelport: okay okay, got it! Jeez Haskell is always *simpler* than I think it is going to be
08:44:23 <pjdelport> ddellacosta: In fact, you can write that as: fmap f (Node xs) = Node $ map (f <$>) xs
08:44:51 <ddellacosta> pjdelport: okay, that <$> I've seen elsewhere...applicative maybe?
08:45:04 <HeladoDeBrownie> @src (<$>)
08:45:05 <lambdabot> f <$> a = fmap f a
08:45:15 <HeladoDeBrownie> @type (<$>)
08:45:16 <pjdelport> ddellacosta: (<$>) is just the operator version of fmap
08:45:16 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:45:25 <ddellacosta> pjdelport, HeladoDeBrownie: thanks, I see
08:45:26 <pjdelport> ddellacosta: And it looks a bit more like pure application, ($)
08:45:46 <pjdelport> ddellacosta: So it suggests a bit more directly that you're mapping the (functorial) application of f across the list xs
08:46:19 <ddellacosta> wow, my brain is bursting with all this new stuff
08:46:42 <ddellacosta> folks, I have to go (to bed), but thanks for all the help, especially pjdelport, and HeladoDeBrownie
08:46:49 <HeladoDeBrownie> \o
08:46:49 <pjdelport> Night :)
08:46:57 <ddellacosta> as always, I've learned a tremendous amount.  thanks. :-)
08:47:05 <joshcough> anyone used optparse-applicative?
08:47:39 <monochrom> yes
08:48:17 <monochrom> every minute, one more minute has quit. :)
08:48:29 <joshcough> im just looking for any opinions whatsoever on command line parsing libs. that seems to be one.
08:49:27 <monochrom> I recomment optparse-applicative, too.
08:49:46 <joshcough> ok. thanks. ill start with that.
08:50:30 <joshcough> im just surprised when im looking for something and i dont find a package by ed kmett.
08:50:58 <MrAngel> I have a type as follows
08:50:59 <MrAngel> type Action a = StateT MachineState (Either Error) a
08:51:05 <monochrom> my https://github.com/treblacy/random-read is an elaborate example. but it uses the older one, 0.8.*
08:51:13 <MrAngel> In practise, a is either an integer or ()
08:51:27 <MrAngel> How do I make a type such that those are both members of it, given that () can't be legally bound?
08:51:35 <joshcough> monochrom: thanks
08:52:41 <pjdelport> @remember joshcough im just surprised when im looking for something and i dont find a package by ed kmett.
08:52:41 <lambdabot> It is stored.
08:54:00 <joshcough> i can never unsay that.
08:54:05 <HeladoDeBrownie> MrAngel, you don't, exactly. In this specific case, Maybe Integer sounds fine.
08:55:33 <MrAngel> Would it not be equally easy to just make all my non-returning functions spuriously return 1?
08:56:06 <HeladoDeBrownie> Depends on what you mean by "easy". If 1 is a possible real result, now your result is ambiguous.
08:56:41 <MrAngel> Everything is contained within an Either monad, so it either returns Left Error or Right a
08:57:00 <svennidal> how do I pass console line arguments "4 5 23 1 23" f.e. and take it as a list of integers?
08:57:07 <HeladoDeBrownie> Is your desired () case distinct from the Left Error case?
08:57:09 <svennidal> I'm trying to compile a sort program
08:57:10 <MrAngel> Yes
08:57:19 <svennidal> It works in the interperetor
08:57:28 <MrAngel> It's for functions on a stack such as push, which don't return
08:57:30 <HeladoDeBrownie> Then Maybe Integer still sounds like the best option, since conceptually that's either () or an Integer.
08:57:34 <svennidal> but I just can't get it to work as a stand alone
08:57:44 <MrAngel> You make a fair point, I'll roll with that
08:57:56 <MrAngel> Thanks
08:58:39 <HeladoDeBrownie> In fact, if you're  so inclined, try writing two functions that convert back and forth between Maybe Integer and Either () Integer.
08:58:51 <HeladoDeBrownie> Just for fun.
08:58:59 <HeladoDeBrownie> And learning of course. :)
09:00:01 <HeladoDeBrownie> Basically Haskell values can't belong to more than one type (even supposedly polymorphic values don't exactly), so you have to distinguish by using constructors.
09:00:08 <HeladoDeBrownie> s/supposedly/so-called/
09:02:32 <MrAngel> So HeladoDeBrownie what about when I try to use the modify function in the Either monad?
09:02:49 <MrAngel> I get errors along the lines of "Couldn't match type '()' with 'Maybe Int'"
09:05:00 <HeladoDeBrownie> MrAngel, well, () isn't *actually* a member of Maybe Int. The equivalent in that type would be Nothing.
09:05:17 <MrAngel> I suppose I just wrap everything that returns () in a function ()toNothing
09:05:18 <HeladoDeBrownie> () is a constructor of type () while Nothing is a constructor of type Maybe a for any a.
09:05:31 <toblerone> Hi all, I see in the Attoparsec documentation that it notes it is "not ideal for, all possible uses". Would you consider it appropriate for parsing a "indent sensitive" grammar (eg: Python)? I have hardly given thought to how this would be done with Attoparsec, but Parsec's use of the State Monad seems to make this trivial
09:05:59 <HeladoDeBrownie> MrAngel, what would toNothing do? If it just returns Nothing, you might as well just use Nothing.
09:06:26 <MrAngel> I can't just use Nothing, because the State monad returns () rather than nothing
09:06:46 <HeladoDeBrownie> MrAngel, it'd probably help to show what you're trying.
09:06:57 <MrAngel> Sample : push x = modify $ \(MachineState (prog, pc, xs, regs)) -> MachineState (prog, pc+1, (x:xs), regs)
09:07:34 <MrAngel> I suppose I could change it to push x = toNothing(modify $ \(MachineState (prog, pc, xs, regs)) -> MachineState (prog, pc+1, (x:xs), regs)) , but that's rather inelegant
09:07:37 <HeladoDeBrownie> I can't do anything with that without knowing about MachineState.
09:07:51 <MrAngel> I'll pastebin the entire codebase, sec
09:08:13 <HeladoDeBrownie> It sounds like you're chasing rainbows with your toNothing idea, though.
09:08:21 <pjdelport> toblerone: http://spin.atomicobject.com/2012/03/16/using-text-parsec-indent-to-parse-an-indentation-sensitive-language-with-haskells-parsec-library/ ?
09:09:13 <MrAngel> HeladoDeBrownie http://pastebin.mozilla.org/6478970 MachineState just defines a simple stack-based machine's state in terms of the program supplied to it, where the program counter is, what's on the stack, and what's stored in the registers
09:09:19 <toblerone> pjdelport: yeah, thats using Parsec. Not Attoparsec : )
09:11:30 <HeladoDeBrownie> MrAngel, could you give the error message, if there is one? It'd also help if you could remove the extraneous features from that code that aren't directly involved with the question.
09:12:43 <simpson> toblerone: Tokenize it first. Generate INDENT and DEDENT tokens for the indentation.
09:17:06 <MrAngel> HeladoDeBrownie
09:17:08 <MrAngel> http://pastebin.mozilla.org/6479105
09:20:05 <HeladoDeBrownie> MrAngel, well, what is push supposed to return?
09:20:14 <triliyn> MrAngel: you can do something like "modify (\ ... -> ...) >> Nothing"
09:20:29 <MrAngel> HeladoDeBrownie I don't care what push returns
09:20:51 <triliyn> er, that would need to be "return Nothing"
09:21:07 <HeladoDeBrownie> MrAngel, I'm confused. Here, let's try this question: What would the Maybe Int result of the action returned by push signify?
09:21:16 <MrAngel> Absolutely nothing
09:21:22 <MrAngel> There would just have to be one
09:21:27 <HeladoDeBrownie> MrAngel, then why fix it to Maybe Int? Why not have it be ()?
09:21:38 <MrAngel> Because some instructions do return an Int
09:21:46 <MrAngel> And if some instructions return Int and some return ()
09:21:51 <MrAngel> I can't make a type for instructions
09:21:56 <MrAngel> err
09:21:58 <MrAngel> actions even
09:21:58 <HeladoDeBrownie> Why can't you?
09:22:04 <HeladoDeBrownie> Same question.
09:22:34 <MrAngel> Because type Action = StateT MachineState (Either Error) Int | StateT MachineState (Either Error) () isn't a valid type
09:23:07 <HeladoDeBrownie> MrAngel, why not give Action a parameter, like you did in your original snippet?
09:23:22 <MrAngel> Because that parameter cannot be ()
09:23:26 <HeladoDeBrownie> Why not?
09:23:43 <MrAngel> I can see no godly reason, ask the people who write the GHC
09:23:45 <MrAngel> But it cannot
09:23:46 <HeladoDeBrownie> If you have a type parameter a, a can be instantiated to any type.
09:23:57 <HeladoDeBrownie> Tell me the problem you ran into when you tried to make it be ().
09:24:10 <dmj`> question, how do tasty and hspec relate to one another? I'm trying to pick a test framework for a project I'm working on
09:24:14 <HeladoDeBrownie> It seems like there's some sort of misunderstanding going on here.
09:24:53 <triliyn> HeladoDeBrownie: he's trying to write a function with the type Prog -> [Action]
09:24:54 <MrAngel> Sure, gimme a sec
09:25:08 <triliyn> Which wouldn't work if it was parameterized
09:25:24 <HeladoDeBrownie> You want a type of all actions regardless of their type argument?
09:25:30 <HeladoDeBrownie> Well, there are ways to do that
09:25:43 <triliyn> I think the solution might be to instead have the paramaterized version, but return a single Action () instead of a list of all the actions
09:26:00 <benzrf> triliyn++
09:26:06 <HeladoDeBrownie> Though I think part of this design might need to be rethought or thought through some more
09:26:19 <benzrf> @karma c
09:26:20 <lambdabot> c has a karma of 2
09:26:21 <MrAngel> http://pastebin.mozilla.org/6479194 HeladoDeBrownie
09:26:22 <benzrf> huh
09:26:43 <benzrf> also hold on
09:26:54 <benzrf> MrAngel: do you care about the int result of the ones that DO return an int?
09:26:59 <MrAngel> Yes
09:27:44 <benzrf> interesting...
09:27:49 <benzrf> MrAngel: why
09:27:57 <HeladoDeBrownie> Ah, I see the problem a little clearer now. Then, I think that (>> Nothing) suggestion might have actually been somewhat on track.
09:28:12 <MrAngel> benzrf I'm writing a program to simulate a stack based machine using State monads
09:28:14 <HeladoDeBrownie> Although I suspect there are still better ways.
09:28:16 <benzrf> ok
09:28:20 <Feuerbach> dmj`: do you practice bdd?
09:28:27 <MrAngel> So some functions, such as pop, need to return something
09:28:35 <triliyn> MrAngel: do you need to keep the integer return values even after you've finished running the program?
09:28:35 <benzrf> MrAngel: i feel like you might be served better by making an ActionResult type
09:28:36 <Kron> triliyn is always on track. Maybe not the straightest track, but a track nonetheless
09:28:43 <MrAngel> While some functions, such as push, exist purely to manipulate the stack
09:28:49 <MrAngel> And their return is irrelevant
09:28:54 <benzrf> MrAngel: ok but
09:28:58 <benzrf> hold on
09:29:05 <benzrf> forget my suggestion
09:29:06 <MrAngel> triliyn Nope, I just need to be able to instantaneously access the returns
09:29:10 <benzrf> MrAngel: do you care SPECIFICALLY
09:29:19 <MrAngel> About what?
09:29:20 <benzrf> about the int result of the elements of the return list
09:29:27 <benzrf> of this function in specific
09:29:48 <triliyn> MrAngel: okay, then it sounds like what you want is to have type Action a = StateT MachienState (Either Error) a, and change the type of composeProgram to Prog -> Action ()
09:30:02 <dmj`> Feuerbach: right now just doing type driven development, so no. I test that my code works in ghci before moving on, but nothing rigorous
09:30:45 <MrAngel> triliyn and have the action returned just be the composite of all the actions in sequence?
09:30:51 <triliyn> Yeah
09:31:08 * dmj` looks for an explanation of bdd vs tdd
09:31:14 <dmj`> https://www.youtube.com/watch?v=mT8QDNNhExg
09:31:34 <MrAngel> triliyn I do believe that would work
09:32:28 <triliyn> :)
09:32:45 <MrAngel> However, I see a potential snag
09:32:53 <triliyn> I think you might run into a bit of trouble with getAction
09:32:57 <MrAngel> Yeah, that
09:33:17 <triliyn> I would probably just get rid of that function and write its logic directly in composeProgram
09:33:22 <Feuerbach> dmj`: from my perspective, the only reason to pick hspec over tasty is if you enjoy the specific way they write test descriptions in bdd, or if you prefer do-notation over plain lists. but I may be biased (I'm the author of tasty)
09:33:36 <MrAngel> triliyn that would cause composeProgram to have a type error, no?
09:33:49 <MrAngel> Unless you did it entirely monadically, I guess
09:34:24 <triliyn> Well, I'm thinking of doing something like this:
09:35:01 <triliyn> composeProgram (POP : xs) = do poppedValue <- pop; doSomethingWith poppedValue; composeProgram xs
09:35:50 <MrAngel> That would work if you could naively treat Prog as an in-order list
09:35:57 <MrAngel> Since there are jump instructions, you can't
09:36:08 <triliyn> hmm
09:36:47 <triliyn> oh, I see
09:36:59 <dmj`> Feuerbach: Ah Ok. Saw that tasty-hspec was a package, so was confused how they were related. Thought they were both standalone testing frameworks. Tasty's docs look nicer though
09:37:35 <dmj`> Feuerbach: Think I'll give them both a try
09:37:35 <MrAngel> The intent was to look at the machine state, work out which instruction to execute, execute it or throw an error, rinse-repeat until you get a halt
09:37:45 <triliyn> Right
09:38:12 <Feuerbach> dmj`: yes, they are both standalone, but tasty-hspec allows embedding an hspec suite into tasty, if you wish to do so
09:38:15 <triliyn> In that case I would write "nextInstruction :: Action Inst"
09:38:37 <triliyn> And then something like
09:39:03 <triliyn> do next <- nextInstruction; case next of { {- process instructions here ... -} }
09:39:09 <triliyn> If that makes sense
09:39:49 <MrAngel> I think it makes a hell of a lot more sense to look up the instructions in the list by program counter and then execute them
09:40:37 <triliyn> That's what nextInstruction would do
09:42:41 <triliyn> hmmm, actually, I'm not quite sure what you want composeProgram to do
09:42:54 <triliyn> I was assuming it would be something like runProg I think
09:43:09 <triliyn> But you already have that
09:44:27 <toblerone> simpson: so what would qualify as a DEDENT? Or would that require first tokenizing everything, and then going back through and looking at the indentation of each line, deciding whether its an "INDENT" or "DEDENT" there?
09:46:45 <triliyn> oh wait, runProg doesn't run the program it gets as input
09:47:24 <MrAngel> triliyn benzrf HeladoDeBrownie any thoughts on http://pastebin.mozilla.org/6479326 as a solution?
09:47:43 <MrAngel> Aside from the fact that I done goofed somewhere because there's a parse error on i
09:48:34 <simpson> toblerone: It merely requires a stateful tokenizer. After every newline, examine whether there's any indentation, and whether there's any non-whitespace characters after it, and then decide whether the indentation has increased (INDENT) or decreased (DEDENT).
09:48:45 <triliyn> MrAngel: I think that's the right idea, but it has a type error
09:48:54 <joshkirklin> I often find that in the course of writing a piece of code in haskell, my imports become very messy (e.g. duplicate imports for one module, importing more things than necessary) and I have to clean them up towards the end of writing. This is a pain. Is there a tool that can help me do so automatically?
09:48:56 <triliyn> Instead of i <- (xs !! pc), you'll need to do something like
09:48:59 <Hodapp> hmm, I wonder how to do something like 'foldMap' over a tree, but terminate at a certain level of recursion
09:49:40 <triliyn> pc <- fmap getPC get; let i = xs !! pc; ...
09:49:48 <MrAngel> Hodapp pass a parameter to foldMap , increment it every time you call it, stop at a certain value
09:51:12 <monochrom> joshkirklin: -ddump-minimal-imports may help. (it dumps to a file. find it.) but it has a bug. things from Prelude are mistakenly attributed to the first module you import.
09:51:42 <triliyn> MrAngel: also, if you want to use the return values of these actions, you'll need to bind them inside the case
09:51:54 <joshkirklin> monochrom, thanks, I'll take a look.
09:51:56 <monochrom> the bug can be worked around by adding an explicit "import Prelude" somewhere, then the attribution is right.
09:52:09 <Hodapp> MrAngel: that looks vaguely monadic...
09:53:10 <triliyn> I might write that as "case i of { PUSH x -> do { push x; prog }; POP -> do { value <- pop; doSomethingWith value; prog}; HALT -> halt }
09:53:12 <triliyn> "
09:53:25 <triliyn> Probably nicer with formatting
09:53:31 <MrAngel> Hodapp you could do it with a State monad, or you could just pass an extra parameter to the function that counts the level of recursion
09:55:21 <toblerone> simpson: hmm okay... Now when you say tokenizer, you mean something that takes my input and chunks it into its valid component symbols... right? For example, given "x = y + 1" a tokenizer would give back ["x", "=", "y", "+", "1"].
09:55:49 <Hafydd> Hopefully something with a more helpful type.
09:56:14 <triliyn> MrAngel: http://pastebin.mozilla.org/6479438
09:56:36 <simpson> toblerone: Or, more usefully, [Name "x", Equals, Name "y", Plus, IntToken 1]
09:57:05 <toblerone> Hafydd: Was that directed at me? Yeah, I'm not exactly clear on the terminology. I've heard some people call attaching useful data to the tokens "lexing" etc
09:57:27 <simpson> Lexical analysis, tokenizing, scanning, they're all roughly the same thing these days.
09:57:31 <MrAngel> triliyn pc is just part of the constructor machineState
09:58:01 <MrAngel> MachineState (Prog, PC, Stack, Regs)
09:58:31 * hackagebot git-repair 1.20140914 - repairs a damanged git repisitory  http://hackage.haskell.org/package/git-repair-1.20140914 (JoeyHess)
09:58:51 <triliyn> MrAngel: right, so my code snippet would work if you defined getPC (MachineState (_, pc, _, _)) = pc, or you could just get the whole machine state and pattern match in the do statement
09:59:30 <MrAngel> I'm too far down the get the whole machine state and pattern match rabbit hole to stop now ;)
09:59:51 <triliyn> hehe, sure
10:00:13 <toblerone> simpson: okay, gotcha. So you would first build up a list of tokens before generating an AST from them? I think I have the general gist, of this but I want to be sure of what one might consider "best practice". What I have generally done in the past (when using Haskell) is generate my AST as I am tokenizing the input. Should I separate the two step
10:00:13 <toblerone> s?
10:00:28 <MrAngel> triliyn gonna write this mess, back in ten or so with it
10:01:00 <toblerone> I suppose it depends on the complexity of the grammar and my parser
10:01:24 <hiptobecubic> i think tokenization and parsing are typically done separately, but what do i know
10:01:26 <simpson> toblerone: The separation makes it easier to perform optimizations or analysis *on the tokens*. It also makes it possible, in this particular case (parsing Python) to be able to not carry indentation state in the parser.
10:01:54 <simpson> And, TBH, I mostly suggest this approach because I have parsed Python and other indentation-sensitive languages before.
10:03:27 <heatsink> toblerone: Tokenization is normally a distinct stage from parsing.  They usually use streaming communication, so that each time the parser needs a token, it causes the tokenizer to run a little more.
10:03:35 <toblerone> Okay, that sounds reasonable. In most literature I've (briefly) read on these topics have always had these as distinct phases. I've never been sure whether they were separated because they were using a language like C as opposed to Haskell
10:04:17 <toblerone> But i'll give that a shot then
10:04:20 <toblerone> thanks
10:04:21 <simpson> It's normally done this way because it's easier to think about.
10:04:57 <MrAngel> triliyn http://pastebin.mozilla.org/6479495 seems fine but length is apparently a parse error?
10:05:05 <MrAngel> I'm sure it's part of prelude though
10:05:45 <triliyn> MrAngel: function calls aren't valid patterns
10:05:49 <heatsink> pc > length xs is not a pattern
10:06:13 <heatsink> You can put it in a guard
10:06:38 <heatsink> case () of _ | pc > length xs -> 1
10:06:46 <MrAngel> Can I use a guard in the middle of a do-block?
10:06:57 <heatsink> no
10:07:04 <heatsink> you can use it in a case expression
10:07:19 <johnw> you can, actually
10:07:27 <johnw> using "guard", if the monad involved supports MonadPlus
10:07:41 <johnw> a guard failure calls "fail", unless I'm mistaken
10:07:49 <johnw> on, no
10:07:53 <heatsink> That use of 'guard' can't return a value, though
10:07:54 <johnw> it calls mzero
10:08:00 <johnw> right
10:08:28 <simpson> when (pc < 0 || pc > length xs) $ lift (Left InvalidPC)
10:08:50 <simpson> Also I smell a great opportunity for EitherT. That's just me though.
10:11:18 <MrAngel> Thanks simpson
10:11:32 <toblerone> simspon: one more quick question : ) Say I give my Tokenizer/Lexer thing the following "foo(1,'a')", would deferring the construction of my AST mean that my tokenizer would generate something like: [Name "foo", OpenParen, IntToken 1, CharToken 'a', CloseParen]?
10:11:46 <simpson> Sure.
10:11:47 <MrAngel> triliyn I think we just trolled ourselves hard, you get the same type error trying to do this processing in the middle of a monad
10:11:54 <zereraz> hello people, >>= is same as do right?
10:11:58 <johnw> no
10:12:07 <zereraz> oh
10:12:11 <johnw> >>= is related to "do x <- foo; y x"
10:12:20 <johnw> which is the same as foo >>= y
10:12:39 <toblerone> simpson: boy sure seems tedious, when compared to my previous approach. : ) But I'm sure its worthwhile. Thanks
10:12:49 <heatsink> To do what processing, MrAngel?
10:12:51 <simpson> toblerone: Well, you don't have to do this.
10:13:05 <toblerone> ?
10:13:07 <simpson> toblerone: I'm just warning you that getting indentation-based syntax correct is easier with it.
10:13:26 <simpson> Also yes, parsers are tedious and easily the hardest part of writing a compiler.
10:13:29 <MrAngel> Executing the program in the middle of a monad, heatsink.Something like http://pastebin.mozilla.org/6479594
10:13:32 <toblerone> yeah, and I take it that this is the "proper" way to do these things
10:13:45 <toblerone> so I probably should get some experience with ti
10:13:50 <zereraz> johnw: does it mean foo is the result of y?
10:13:56 <MrAngel> push x has the wrong type because it's Action () not Action Int
10:14:08 <johnw> it means that foo is executed, and the result pass as argument to y
10:14:12 <simpson> Not really. Plenty of parser systems don't do lexical analysis beforehand, and plenty of compilers do a single parsing pass followed by mechanical transformation into simpler and simpler ASTs.
10:14:26 <MrAngel> And I'm just going to cheat at this point because I'm sick of trying to be correct and I've figured a nice escape hatch
10:14:42 <zereraz> johnw: ok understood, thanks!!
10:14:44 <heatsink> For indentation-sensitive parsing, does the indentation level become a token, or does each token have an associated indentation?
10:15:04 <toblerone> I was thinking the indentation itself was the token
10:15:09 <simpson> heatsink: The approach taken by e.g. Python is to create INDENT and DEDENT tokens.
10:15:09 <geekosaur> the division of parsers into lexical analysis and parsing phases is a holdover from a hack intended to fit large programs into the limited process address space of PDP11s
10:15:47 <zereraz> johnw: so we do not need 'do'?
10:15:48 <zereraz> johnw: if we use >>=
10:16:21 <geekosaur> @undo do { x <- getLine; print (length x) }
10:16:21 <lambdabot> getLine >>= \ x -> print (length x)
10:16:27 <heatsink> MrAngel: That looks syntactically correct to me.
10:16:30 <simpson> Also, BTW, note that in Python/Parsley/Monte, the approach is to chop up the input with a type-unsafe chimera of input: "y = 42\n    x = y + 1" becomes ["y = 42", NL, INDENT 4, "x = y + 1"] before parsing.
10:16:51 <toblerone> geekosaur: okay, so whats your take on this then? : ) Do you think generating a list of tokens before generating your AST is necessary, or good practice? It always seemed to me that things like Parsec encouraged doing this in one pass
10:16:53 <MrAngel> heatsink the syntax is fine, it just so happens that pop and halt return Action Int and the others return Action (), so the compiler cries
10:17:07 <MrAngel> And I'm going to solve this problem by lying about what they return and returning in a different fashion because I'm sick of this
10:17:18 <simpson> MrAngel: void from Control.Monad might help.
10:17:25 <heatsink> ^
10:17:25 <zereraz> which is more preferred way? do or >>=
10:17:30 <geekosaur> toblerone, Parsec style is generally easier to work with. pretokenization exists solely to make parsers more compact, which was necessary in the 1970s
10:17:54 <MrAngel> I have a cheaper way, which is to not make pop return at all and treat halt as an exception, because my program by definition stops there anyway and thus can safely break totally after that point
10:17:55 <zereraz> do seems less functional
10:17:56 <simpson> MrAngel: https://pastebin.mozilla.org/6479625 perhaps?
10:18:00 <geekosaur> some people have turned it into religion since then >.>
10:18:02 <heatsink> MrAngel: Also, note that lines 9–14 will execute even if pc is out of bounds.
10:18:36 <MrAngel> heatsink doesn't matter, Left Error has been lifted so the overall result will stil lbe an error
10:18:44 <geekosaur> also sometimes it holds on because the programs were originally written (or based on programs originally written) in the 70s, and nobody ever took the time to rewrite
10:18:50 <MrAngel> Even if the program carries on executing
10:18:53 <toblerone> simspon: Are you saying that before doing any "real" parsing, they check if the indentation is valid?
10:19:11 <simpson> toblerone: No, I'm saying that they don't tokenize everything, just the whitespace.
10:19:29 <MrAngel> simpson what does void do here?
10:19:31 <heatsink> I see.
10:19:34 <heatsink> :t void
10:19:35 <lambdabot> Functor f => f a -> f ()
10:19:43 <MrAngel> Just ignores their return totally?
10:19:47 <heatsink> yes
10:19:52 <simpson> Actually, I remembered wrong; it was more like ["y", "=", "42", NL, Indent(4), "x", "=", "y", "+", "1"]
10:19:53 <toblerone> simspon: but they must tokenize the remaining information at some point, no?
10:20:13 <toblerone> ah ok
10:20:19 <MrAngel> Hmm
10:20:30 <simpson> toblerone: Nah, then it goes directly to a PEG parser  which consumes it all. This is Ometa-style, so the poor typing doesn't matter. (Yay for objects.)
10:20:40 <geekosaur> toblerone, only if you think of the AST as tokens
10:21:04 <geekosaur> there is no particular reason to do so
10:23:32 <toblerone> geekosaur: Yeah, this has been a point of confusion for me as well. In a lot of cases, tokens and nodes of the AST are interchangeable, no? For instance, IntToken 1 vs IntTerm 1
10:23:50 <simpson> Yeah.
10:24:01 <toblerone> Perhaps I haven't worked on anything large and complicated enough to see the benefit of making that distinction
10:24:10 <geekosaur> they can be. the mapping is often (but not always) 1-to-1 with pretokenization
10:24:55 <geekosaur> but they're isomorphic, not identical
10:25:20 <geekosaur> and as soon as the language introduces syntactic sugar, the isomorphism ceases to exist in at least some cases
10:25:41 <simpson> I've had token-to-AST situations before, like when doing analysis on Forth code, but it's not common.
10:26:17 <toblerone> geekosaur: any simple examples where that is the case?
10:26:28 <MrAngel> https://pastebin.mozilla.org/6479638 the last hurdle
10:26:33 <MrAngel> Watch me tumble
10:26:35 <heatsink> I suppose forth, like simpson mentioned
10:26:59 <heatsink> The paste is incomplete
10:27:08 <zereraz> why is this not working http://lpaste.net/111044
10:27:08 <MrAngel> It is incomplete
10:27:11 <toblerone> eh, i'm not familiar with forth. I know that its a stack base language, thats it
10:27:14 * johnw loves ≅
10:27:17 <zereraz> I try to send command line arguments
10:27:29 <geekosaur> mm. generally there aren't simple ones. one example is one we just discussed: haskell's do notation can be translated early so the AST contains only (>>=) and such
10:27:51 <geekosaur> another example is older languages that used = for both assignment and equality, distinguishing them by context
10:27:58 <geekosaur> (think BASIC)
10:28:09 <toblerone> ah okay
10:28:09 <MrAngel> However, heatsink, the rest is never reached because of that exception
10:28:29 <heatsink> Hmm
10:29:17 <zereraz> ?
10:29:18 <heatsink> > (fail "error1" >> case ([] !! 1) of _ -> fail "error2") :: Maybe Int
10:29:20 <lambdabot>  Nothing
10:30:17 <stulli_> zereraz: What is the error? The snippet works for me.
10:30:40 <zereraz> stulli_: what do you do? like after ghci filename.hs
10:30:50 <heatsink> > runState (fail "error1" >> case ([] !! 1) of 0 -> fail "error2") 0
10:30:51 <zereraz> stulli_: I did main myArgument
10:30:52 <lambdabot>  *Exception: Prelude.(!!): index too large
10:31:09 <heatsink> MrAngel: See the example above.  It did not fail with "error1" or "error2".
10:31:37 <MrAngel> heatsink I've worked out the problem
10:31:41 <stulli_> zereraz: Oh, didn't use ghci but "runhaskell test.hs myArgument"
10:31:41 <zereraz> stulli_: if I do just "main"
10:31:50 <MrAngel> I was having it recurse, on the assumption that it would eventually return
10:31:58 <MrAngel> But it doesn't actually do that, because I set halt to void halt
10:32:18 <zereraz> stulli_: it is saying
10:32:22 <zereraz> ouldn't match expected type `[Char] -> t0'
10:32:22 <zereraz>                 with actual type `IO ()'
10:32:53 <stulli_> zereraz: I am not sure if you can use command line arguments from within ghci.
10:32:54 <heatsink> I don't think that's the problem, MrAngel
10:33:01 <zereraz> stulli_: oh
10:33:10 <zereraz> stulli_: how to run it then?
10:33:36 <stulli_> zereraz: either use runhaskell or compile it first
10:34:00 <zereraz> stulli_: it worked after compilation!!
10:34:01 <MrAngel> non-incomplete paste including the fatal recursion https://pastebin.mozilla.org/6479730
10:34:04 <zereraz> stulli_: thanks
10:34:22 <sinelaw> my type inference thinks Y combinator has type: a -> b -> a
10:34:25 <sinelaw> not sure why...
10:35:19 <geekosaur> actually, there's a better example using an older programming language: FORTRAN IV used .EQ. for equality, but WATFIV allowed = and distinguished by context. so not only did you get .EQ. and equality-= mapping to the same AST node, but = could give rise to a different AST node based on whether it was recognized by context as assignment vs. equality
10:35:28 <monochrom> that is strange indeed. who wrote the inference program?
10:36:38 <geekosaur> then again, FORTRAN was actively hostile to tokenization
10:37:03 <geekosaur> (ob DO 100 I=1.10)
10:37:21 <sinelaw> monochrom, my very own self
10:37:33 <sinelaw> uses textbook HM unification
10:37:35 <heatsink> You forgot the six spaces before DO
10:37:56 <sinelaw> monochrom, something is wrong with the way i infer calls or function definitions :)
10:38:07 <monochrom> yeah hehe
10:38:25 <mauke> what does it think about (\x -> x) and (\x y -> y)?
10:39:00 <monochrom> I should also code up the textbook HM algorithm one day
10:39:20 <sinelaw> monochrom, I basically copied the one from TIOFPL
10:39:38 <sinelaw> monochrom, implementing from TAPL was too much of an effort
10:39:44 <sinelaw> (required thinking!)
10:40:04 <sinelaw> :P
10:40:16 <monochrom> TAPL's description is less algorithmic and more mathematical.
10:40:21 <sinelaw> right
10:40:49 <cydd> what a voice http://vocaroo.com/i/s01zMrWKAMyO
10:41:10 <toblerone> geekosaur: sorry for the stupid question... but why is that hard to tokenize? [OpenParen, Name "ob", Keyword "DO", IntToken 100, Operator "|=", FloatingToken 1.10, CloseParen]
10:41:14 --- mode: ChanServ set +o johnw
10:41:14 --- mode: johnw set +b *!cydd@unaffiliated/cydd
10:41:14 --- kick: cydd was kicked by johnw (Kicked)
10:41:15 --- mode: johnw set -o johnw
10:41:20 <heatsink> In the implementation of unification, terms have to be explicitly normalized before they're inspected.  It feels a bit like emulating lazy evaluation.
10:41:40 <geekosaur> toblerone, it's an infamous if apocryphal typo, and it doesn't get parsed the way you think
10:41:48 <heatsink> reducing terms to WHNF before examining them.
10:41:52 <geekosaur> it's parsed as an assignment
10:42:06 <geekosaur> FORTRAN IV ignored spaces except in string constants (Hollerith literals)
10:42:13 <simpson> Shoulda worn your blue tie. :3
10:42:16 <toblerone> ha
10:42:21 <MrAngel> https://pastebin.mozilla.org/6479850 how do I get this code to actually /stop/ running?
10:42:25 <geekosaur> the typo is that the . was intended to be a , which would have made it a DO loop
10:42:26 <toblerone> really?
10:42:29 --- mode: ChanServ set +o johnw
10:42:35 <toblerone> ah
10:42:44 <MrAngel> Like, I need some way of telling it to quit the do-block when I reach HALT
10:42:49 <heatsink> What does the DO do?
10:42:56 --- mode: ChanServ set +o johnw
10:43:14 <MrAngel> It alters the state of the machine according to the program counter
10:43:17 <MrAngel> Then calls its own method again
10:43:34 <ski> johnw : .. ⌜≅⌝ for which purpose ?
10:43:39 <johnw> ski: isomorphism
10:43:55 <MrAngel> heatsink when it says void halt, I want to include something that will exit the do-block right there
10:43:57 <geekosaur> heatsink, in this case it would be the FORTRAN IV equivalent of a for loop
10:43:58 <heatsink> MrAngel, How is halt defined?
10:44:19 <MrAngel> halt :: Action Int halt = do  x <- internalPop  return x
10:44:48 <sinelaw> heatsink, how so? in the one I used it inspects all types deeply
10:45:04 --- mode: johnw set +s
10:45:08 <MrAngel> Basically I need a way to break out of a do-block
10:45:18 --- mode: johnw set -b *!cydd@unaffiliated/cydd
10:45:32 <heatsink> MrAngel, halt has to either interrupt execution in an exception-like way, or _not_ invoke 'prog' again
10:45:46 --- mode: johnw set -o johnw
10:46:36 <heatsink> sinelaw, consider unifying a -> a -> a with a -> (b -> b) -> (c -> c)
10:46:48 <heatsink> assume arrows are processed left-to-right
10:46:56 --- mode: ChanServ set +o johnw
10:47:02 <heatsink> The first time you process 'a', it's really 'a'
10:47:13 --- mode: johnw set -o johnw
10:47:17 <heatsink> The second time you process 'a', it's really 'a', and it gets unified with 'b -> b'
10:47:46 <heatsink> The third time you process 'a', it's really 'b -> b', and it gets processed recursively to unify b with c
10:48:07 <heatsink> You have to look up 'a' every time you see it, because it could have changed since last time it was looked up
10:49:07 <heatsink> That lookup is like forcing every thunk to make sure it's evaluated before you examine its contents
10:49:18 <sinelaw> hm
10:50:33 <heatsink> MrAngel, what does prog return?  Instructions' result values are ignored
10:50:51 <MrAngel> It doesn't, that's what's causing me a headache
10:50:53 --- mode: ChanServ set +o monochrom
10:51:01 --- mode: ChanServ set +o geekosaur
10:51:02 <MrAngel> I'm rewriting it so I can actually get a return
10:51:09 --- mode: geekosaur set -o geekosaur
10:51:33 <MrAngel> Nothing except halt returns, so that's fine
10:51:45 <MrAngel> But when I see HALT I want some way of ending execution and returning the top of the stack
10:51:59 <heatsink> You can define data Transition = Fallthrough | Terminate Int, and have every operation return a Transition
10:52:34 <heatsink> Then handle the transition on line 26
10:52:44 <phaazon> bennofs: thank you for your answer
10:52:52 <phaazon> I’m gonna check the monomorphism restriction then
10:53:38 <MrAngel> heatsink I can't control what operations return because they use the state monad, I'm basically stuck with it
10:55:11 <heatsink> They have type Action ()
10:55:20 <heatsink> Can you change it to Action Transition?
10:55:37 <MrAngel> heatsink please I promise this is a dead end
10:56:12 <MrAngel> heatsink: type Action a = StateT MachineState (Either Error) a , a is either () or Int , and there ain't a thing I can do about it
10:56:17 <simpson> heatsink, MrAngel: I feel like you're dancing around EitherT/MaybeY.
10:56:35 <MrAngel> That is because of how State works
10:56:46 <MrAngel> Everything returns, even things that purely modify the state
10:56:49 <MrAngel> But those just return ()
10:56:57 <MrAngel> And I can't stop them returning ()
10:57:13 --- mode: monochrom set -s
10:57:25 --- mode: monochrom set -o monochrom
10:57:36 <geekosaur> http://www.haskell.org/haskellwiki/Xmonad/Frequently_asked_questions#Using_SetWMName_with_EwmhDesktops
10:57:38 <geekosaur> oops
10:57:40 <simpson> type Action m a = EitherT Error (StateT MachineState m) a -- and now you can use `left` to stop all further computation (until/unless you catch the exception)
10:57:44 <heatsink> By MaybeY, do you mean MaybeT?
10:57:53 <simpson> Yeah, sorry. Thinking faster than typing.
10:58:24 <heatsink> There have to be different exception-like results for errors and normal termination.
10:58:30 <heatsink> That's doable with EitherT
10:58:51 <phaazon> bennofs: hm
10:59:04 <phaazon> I’ve already seen that monomorphism restriction stuff
10:59:11 <phaazon> but I never totally got it
10:59:13 <MrAngel> It's already being done, an action returns Either Error a, no?
10:59:41 <simpson> Anyway, having Either Error as the transformed monad is functionally identical, so I'm not sure what's wrong here.
10:59:44 <bennofs> phaazon: basically, let and where bindings are never polymorphic (=> they are "monomorphic")
10:59:56 <phaazon> yeah
11:00:23 <phaazon> I think it’s the “monomorphism” concept I should study
11:00:24 <bennofs> phaazon: so instead of infering the polymorphic types, GHC only infers the monomorphic type (which it decides based on usage of the binding in the binding body)
11:00:25 <simpson> MrAngel: I think that you should probably make all of your actions return (). Why would you want them to return anything else?
11:00:38 <heatsink> To take Simpson's approach, you would extend the Error type with a constructor representing normal termination.
11:00:43 <phaazon> bennofs: http://lpaste.net/8404192013955629056
11:00:44 <phaazon> so here
11:00:53 <phaazon> it encounters the "ints" binding first
11:00:58 <phaazon> so it infers [Int]
11:01:05 <MrAngel> simpson to perform computations with what I pop from the top of the stack, or to output the top of the stack when I halt
11:01:13 <bennofs> phaazon: yes
11:01:18 <phaazon> I also guess that hm
11:01:34 <phaazon> in my case, since values is polymorphic, it has to perform some dictionnary passing at runtime
11:01:37 <simpson> MrAngel: Hm, which stack machine are you modeling? Generally, popping from the top of the stack in a stack machine implies that you're discarding the popped value!
11:02:00 <MrAngel> simpson Yeah, the spec doesn't actually say not to do that
11:02:04 <simpson> When you halt, just indicate that you halted normally and print the stack. Since the stack's part of your State, it's not hard to recover.
11:02:09 <simpson> MrAngel: Spec?
11:02:20 <bennofs> phaazon: that directory passing could be eliminated if GHC either inlines values or specializes it (which I guess will happen in this case, since GHC knows the types)
11:02:30 <MrAngel> The spec for the stack machine I'm implementing
11:02:47 <simpson> Is this homework, by chance?
11:02:55 <phaazon> bennofs: oh yeah right
11:02:59 <MrAngel> I like your idea though; have pop chuck the top of the stack and have halt just print it
11:03:15 <phaazon> I still don’t understand why monomorphism and evalution are related
11:03:25 <MrAngel> simpson yup
11:04:35 <simpson> MrAngel: Well, ask your TA, then; in (nearly all?) concatenative stack languages, it's not called "pop", but "drop" for a reason. :3
11:05:17 <heatsink> Are you required to leave some code untouched, and that's why you won't make the changes we're suggesting?
11:05:24 <bennofs> phaazon: consider f xs = (len, len) where len = length xs
11:05:37 <bennofs> phaazon: in that example, len will only be calculated once (it's shared)
11:05:41 <MrAngel> I honestly just couldn't see any downside to having it return and ignoring it
11:06:16 <MrAngel> heatsink I can change what I want, besides the instruction set and the errors
11:06:41 <phaazon> bennofs: yeah
11:06:41 <bennofs> phaazon: if you instead had f xs = (len 0, len 0) where len x = x + length xs, len 0 would be computed twice (disregarding optimizations for a moment)
11:06:42 <sinelaw> ok, now inference thinks Y :: (a -> a) -> a
11:06:50 <MrAngel> I'm just very close to having it function, and I'm reluctant to make sweeping changes that may break things when it seems unlikely that some small one will do
11:07:04 <phaazon> bennofs: yeah
11:07:39 <bennofs> phaazon: f xs = (len, len) where len :: Num a => a; len = genericLength xs behaves like the second example, because the "len" binding now has an extra argument
11:07:57 <bennofs> (the typeclass directory for Num)
11:08:04 <heatsink> MrAngel: you have to make a change that affects every branch of the case expression, at least.  You can just modify the case expression.  It may be more elegant to add more functionality to the monad instead.
11:08:13 <phaazon> bennofs: oh
11:08:17 <phaazon> so it could be two types?
11:08:18 <heatsink> and use the extra functionality in the HALT case.
11:08:50 <bennofs> phaazon: yes, you could now do f xs = (len :: Int, len :: Integer) where len :: Num a => a; len = genericLength xs
11:09:05 <phaazon> ok
11:09:08 <phaazon> I understand now
11:09:19 <phaazon> but I couldn’t do:
11:09:34 <phaazon> f xs = (len :: Int, len :: Integer) where len = genericLength xs
11:09:42 <phaazon> this would be restricted
11:09:49 <MrAngel> heatsink I think I'm just going to remove the non-standard behaviour of my pop and have halt print the stack
11:10:15 <MrAngel> If halt doesn't return anything, but just prints it, it doesn't need to return anything but ()
11:10:17 <bennofs> phaazon: yeah, because the monomorphism restriction says that len can only be of a monomorphic (without type variables) type
11:10:29 <bennofs> phaazon: so you can only use it as one type
11:10:30 <heatsink> You also need to change it so that no instructions are evaluated after halting.
11:11:09 <phaazon> bennofs: got it!
11:11:14 <phaazon> thank you very much! :)
11:13:58 <Forkk> Is there like a compiler extension that can implicitly lift monad actions into the right monad? It gets really annoying having to remember to use lift constantly, especially when you have a stack of like three or more monad transformers and have to lift $ lift things
11:14:12 <phaazon> Forkk: just use typeclasses
11:14:20 <Forkk> although, I imagine such an extension could cause ambiguities
11:14:26 <Forkk> phaazon, what do you mean?
11:14:33 <phaazon> instead of using the transformers stack directly
11:14:42 <phaazon> use a constraint
11:14:56 <Forkk> You mean like MonadIO?
11:15:00 <phaazon> yeah
11:15:04 <phaazon> MonadIO, MonadState
11:15:07 <phaazon> MonadReader
11:15:08 <phaazon> and so on
11:15:19 <Forkk> I didn't know those existed for Reader
11:15:33 <phaazon> for instance instead of EitherT e (ReaderT r IO) a
11:15:35 <phaazon> just use:
11:15:49 <phaazon> (MonadIO m,MonadError e m,MonadReader r m) => m a
11:16:04 <Forkk> oh my god
11:16:04 <phaazon> and implement the type you want to use then :)
11:16:24 <Forkk> I missed this whole fucking module https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Reader-Class.html
11:16:29 <Forkk> wow .-.
11:16:31 <phaazon> if you have functions to “run” your transformers
11:16:44 <phaazon> you don’t even have to explicitely give the stack
11:16:45 <phaazon> for instance:
11:16:47 <Forkk> that's so much better
11:17:14 <phaazon> runReaderT r . runEitherT $ {- do your stuff here -}
11:17:25 <Forkk> alright
11:17:32 <phaazon> Forkk: I think there’re several schools
11:17:43 <phaazon> the one using only transformers everywhere
11:17:51 <phaazon> the one using typeclasses everywhere
11:17:57 <phaazon> I belong to the latest :P
11:18:12 <heatsink> In my opinion, it's best to write your own monad functions that hide the monad stack's structure.
11:18:13 <phaazon> I might have a snippet for a better example, wait
11:18:22 <Forkk> so if I just say "type PendingConn = (MonadIO m, MonadReader CoreCtlHandle m, MonadResource m) => m"
11:18:32 <phaazon> yep
11:18:33 <Forkk> then I don't have to lift things?
11:18:36 <phaazon> nope
11:18:36 <Forkk> fuck yes
11:18:41 <phaazon> you just need the right extension
11:18:43 <phaazon> which is hm
11:18:45 <phaazon> ConstraintType
11:18:48 <phaazon> ConstraintKind
11:18:52 <Forkk> thank you <3 :D
11:18:54 <phaazon> ConstraintKind, only
11:18:57 <phaazon> you’re welcome :)
11:19:14 <phaazon> https://github.com/phaazon/photon/blob/master/Photon/Utils/Log.hs#L63
11:19:21 <heatsink> You wouldn't use the "=> m"
11:19:24 <phaazon> you don’t need the => m
11:19:34 <phaazon> then
11:19:40 <phaazon> I can write for instance
11:19:55 <phaazon> foo :: (MonadLogger m,MonadError String m) => m Int
11:20:11 <phaazon> foo = info CoreLog "logging stuff" >> throwError "fuck!"
11:20:19 <Forkk> Wait why don't I need the => m
11:20:28 <phaazon> Forkk: because it’s not a type
11:20:30 <monochrom> sinelaw: (\x -> x x) is possibly a simpler test case to play with
11:20:33 <phaazon> it’s a typeclass
11:20:44 <phaazon> you use it as a constraint
11:20:47 <Forkk> you can type alias typeclasses?
11:20:51 <phaazon> yes
11:20:53 <Forkk> oh
11:20:56 <phaazon> with ConstraintKind extension
11:21:09 <phaazon> that’s also why I always say “type” should be “alias” keyword
11:21:13 <sinelaw> monochrom, the expectation is that HM will fail. right?
11:21:18 <phaazon> since it’s much more than type aliasing
11:21:29 <Forkk> though, really, a PendingConn is supposed to be an action in those monads that returns a connection action
11:21:49 <monochrom> yes, should fail for both Y and (\x -> x x). the part about "occurs check"
11:22:02 <sinelaw> ya
11:23:22 <phaazon> Forkk: https://github.com/phaazon/photon-opengl/blob/master/Photon/Render/OpenGL/Forward/Renderer.hs#L313
11:23:23 <heatsink> "type" is kind of like "let."
11:23:30 <phaazon> here’s a using of what I told you ;)
11:23:32 <Forkk> phaazon, ConstraintKind and ConstraintType are unknown extensions
11:23:35 <phaazon> I only use liftIO, of course
11:23:38 * hackagebot aws 0.10.4 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.10.4 (AristidBreitkreuz)
11:23:39 <phaazon> hm
11:23:40 <phaazon> wait
11:23:48 <Forkk> oh
11:23:52 <Forkk> it's constraintkinds
11:24:00 <phaazon> {-# LANGUAGE ConstraintKinds #-}
11:24:03 <phaazon> yep
11:24:04 <phaazon> indeed
11:24:24 <Forkk> and ConstraintType I have no idea
11:24:29 <phaazon> no
11:24:32 <phaazon> it doesn’t exist
11:24:40 <phaazon> I mistaken
11:24:48 <phaazon> it’s ConstraintKinds you need :)
11:24:53 <phaazon> it lets you create typeclasses alias
11:26:52 <Forkk> awesome
11:26:53 <Forkk> thanks
11:26:59 <phaazon> you’re welcome :)
11:28:38 * hackagebot aws 0.10.5 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.10.5 (AristidBreitkreuz)
11:29:28 <zereraz> I heard this line for type classes, "when a type derives from a class it becomes an instance of it, which lets us access classes functions" so this is like inheritance right?
11:29:48 <Forkk> It's pretty much Haskell's version of inheritance
11:29:52 <Forkk> but it's much more powerful
11:30:06 <sinelaw> monochrom, \x -> x x fails, as expected
11:30:06 <FledRebel> Can cabal install GHC?  It would be nice if it were possible to specify the ghc required in the .cabal file and have Cabal install ghc in the sandbox.
11:30:09 <sinelaw> but Y doesn't :(
11:30:11 <zereraz> more powerful
11:30:13 <zereraz> ?
11:30:14 <Forkk> it's also sort of flipped on its head compared to C++-ish inheritance
11:30:32 <geekosaur> FledRebel, no
11:30:34 <zereraz> Forkk: what more does it have
11:30:36 <sinelaw> after some changes, now I'm getting Y :: a -> b -> c
11:30:43 <Forkk> for example, if I have a type that's an instance of Num, any function that accepts Nums will work on it
11:30:49 <sinelaw> (a -> b) -> c
11:30:59 <Forkk> and you can write new functions that will take Nums as well
11:31:06 <FledRebel> Oh well, thanks.
11:31:23 <Forkk> so, when you make something an instance of num, you sort of "inherit" every function that works on Nums
11:31:23 <ski> phaazon : however, the DMR doesn't apply if you provide an explicit type signature, or if you define the function by a function binding (i.e. argument patterns to the left of `=')
11:31:27 <Forkk> in a way
11:31:27 <zereraz> do the basic types also have such inheritance
11:31:41 <ski> sinelaw : do you have occurs check ?
11:32:06 <Forkk> zereraz, you can declare anything to be an instance of anything, as long as you implement the functions the class requires
11:32:12 <phaazon> 20:29 < ski> phaazon : however, the DMR doesn't apply if you provide an  explicit type signature, or if you define the function by a  function binding (i.e. argument patterns to the left of `=')
11:32:15 <Forkk> though there are some cases where you certainly shouldn't
11:32:16 <phaazon> yeah
11:32:19 <phaazon> that’s how I solved my issue
11:32:25 <zereraz> you get to know all the types you can send to a function if the function derives from a type?
11:32:32 <phaazon> however, why does it work by binding to a function parameter?
11:32:34 <Forkk> for example, you probalbly shouldn't make String an instance of Num
11:32:40 <ski> phaazon : .. or, if you enable `NoMonomorphismRestriction'
11:32:50 <sinelaw> ski, apparently so.
11:33:01 <Forkk> zereraz, not sure what you mean
11:33:02 <geekosaur> phaazon, it's assumed that a binding without arguments is intended to be a "constant" and is therefore shared, which requires monomorphism
11:33:08 <zereraz> any good material to read about this
11:33:08 <sinelaw> may be some other problem
11:33:14 <phaazon> oh right
11:33:16 <phaazon> god
11:33:21 <phaazon> you rock guys \o\
11:33:22 <phaazon> thank you
11:33:31 <zereraz> Forkk: thanks
11:33:47 <Forkk> no problem
11:34:11 <ski> phaazon : because DMR was only invented because people thought it might be confusing if e.g. `n = sum [1,2,3]' wasn't shared (due to implicitly needing a `Num'-dictionary in a dictionary-passing implementation of type class constraints)
11:34:48 <Forkk> zereraz, you should definitely read up on type classes, but also just try playing with them on your own. I've found the best way for me to learn about things in Haskell is to just write code
11:35:07 <Forkk> often the code ends up being awful, but I learn from the experience
11:35:16 <ski> phaazon : however, if you say `f x = ...', then it's already obvious that the computation of `...' won't be shared, but reevaluated every time you apply `f' (at least when applying it to different arguments), so then the potential perceived problem doesn't crop up anyway, so no "fix" was needed here
11:38:17 <vanila> n = sum [1,2,3] gets turn edinto  n num_dictionary = sum num_dictionary [1,2,3]  then
11:38:39 * hackagebot aws 0.9.4 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.9.4 (AristidBreitkreuz)
11:38:39 <latk> Is there an existing function that can check if Text is comprised of only one character, 1 or more times ?
11:38:54 <latk> e.g. "t" or "tttt" would return true
11:39:24 <heatsink> > (\s -> and $ zipWith (=) s (tail s)) "    "
11:39:26 <lambdabot>  <hint>:1:23: parse error on input ‘=’
11:39:30 <heatsink> > (\s -> and $ zipWith (==) s (tail s)) "    "
11:39:32 <lambdabot>  True
11:39:42 <geekosaur> :t all
11:39:42 <lambdabot> (a -> Bool) -> [a] -> Bool
11:39:55 <geekosaur> hm, probably not the best approach
11:40:02 <geekosaur> :t group
11:40:03 <lambdabot> Eq a => [a] -> [[a]]
11:40:32 <geekosaur> > length (group "tttu") == 1
11:40:34 <lambdabot>  False
11:40:38 <geekosaur> > length (group "tttt") == 1
11:40:40 <lambdabot>  True
11:40:43 <latk> Ah, nice
11:41:13 <latk> > length (group "tttattt") == 1
11:41:14 <lambdabot>  False
11:41:17 <ski> @let isSingleton [_] = True; isSingleton _ = False
11:41:20 <lambdabot>  Defined.
11:41:45 <simpson> Man, I wish that I had a good use case for These/Chronicle.
11:41:48 <ryantrinkle> is there a way to determine type roles in ghci?
11:41:50 <ski> > isSingleton (group (sort "tttattt"))
11:41:53 <lambdabot>  False
11:44:17 <sinelaw> infinite loop! :)
11:48:40 * hackagebot chatty-utils 0.7.1.2 - Some utilities every serious chatty-based application may need.  http://hackage.haskell.org/package/chatty-utils-0.7.1.2 (implementation)
11:48:42 * hackagebot chatty 0.6.2.1 - Some monad transformers and typeclasses for abstraction of global dependencies.  http://hackage.haskell.org/package/chatty-0.6.2.1 (implementation)
11:48:44 * hackagebot chatty-text 0.6.0.1 - Provides some classes and types for dealing with text, using the fundaments of Chatty.  http://hackage.haskell.org/package/chatty-text-0.6.0.1 (implementation)
11:48:46 * hackagebot ctpl 0.1.0.1 - A programming language for text modification.  http://hackage.haskell.org/package/ctpl-0.1.0.1 (implementation)
11:48:48 * hackagebot antisplice 0.17.0.3 - An engine for text-based dungeons.  http://hackage.haskell.org/package/antisplice-0.17.0.3 (implementation)
11:48:51 <srhb> Hmm, when did Control.Monad.Error become Control.Monad.Except, and are there any differences I should be aware of when using mtl?
11:51:36 <mgaut72> Hi all, I have a program design question that I need some advise on.
11:51:37 <mgaut72> I am writing a compiler right now.  I have the parsing section of code done, and am looking to add typechecking.  My current tests only only for the parsing, but would fail once I add typechecking.  The parser is in parsec, and essentially I have "expressionP :: MyParser Expression" "expressionP = ( operationP <|> functionCallP <|> ... ) >>= typeCheck"  note that some expressions are recursive (an expression in terms of one or more expressio
11:51:48 <Cale> ryantrinkle: I can't see a way to do it, but you could use TH's reifyRoles to inspect them perhaps
11:52:22 <ryantrinkle> Cale: cool, thanks
11:52:28 <ryantrinkle> i think i'll just unsafeCoerce for now :P
11:52:29 <geekosaur> mgaut72, IRC las a length limitl; you chopped off at " one or more expressio"
11:52:43 <mgaut72> geekosaur: thx
11:52:55 <mgaut72>   is there a clean way to have an "untyped" version of this module (for testing and parsing only) and a typed version?
11:53:50 * hackagebot ironforge 0.1.0.34 - A technical demo for Antisplice.  http://hackage.haskell.org/package/ironforge-0.1.0.34 (implementation)
11:53:52 * hackagebot antagonist 0.1.0.23 - A web interface to Antisplice dungeons.  http://hackage.haskell.org/package/antagonist-0.1.0.23 (implementation)
11:53:54 * hackagebot anticiv 0.1.0.4 - This is an IRC bot for Mafia and Resistance.  http://hackage.haskell.org/package/anticiv-0.1.0.4 (implementation)
11:53:56 * hackagebot anticiv 0.1.0.5 - This is an IRC bot for Mafia and Resistance.  http://hackage.haskell.org/package/anticiv-0.1.0.5 (implementation)
11:58:46 <Fuuzetsu> I wonder if one could use ‘accelerate’ to further speed up Text
12:02:23 <dnkndnts> what is the difference between Data.Text.foldl and Data.Text.foldl'? hackage says foldl' is a "strict version", but... what exactly does that mean?
12:03:13 <dcoutts_> dnkndnts: see Data.List.foldl'
12:03:49 <heatsink> Fuuzetsu, depends on the use case text, but it's hard to get speedup when your algorithm does very little computation per byte
12:04:19 <kadoban> dnkndnts: http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27
12:04:58 <Fuuzetsu> heatsink: right but AFAIK underneath, Text is just an Array so we could probably get an easy improvement over maps &c, no?
12:05:01 <Cale> dnkndnts: It means that the accumulated parameter is evaluated (up to determining the top-level data constructor) on each step down the piece of text.
12:05:22 <Cale> dnkndnts: Normally, foldl will just accumulate a large expression which is only evaluated after foldl reaches the very end
12:06:08 <heatsink> You're talking about using Accelerate for GPU parallel execution?
12:06:19 <Cale> dnkndnts: But sometimes this can be problematic if the string (or list) is very long, especially when the function will need to pattern match on its second argument to produce any part of its result, because this might result in a stack overflow as matches build up on the stack.
12:06:38 <Fuuzetsu> heatsink: yes
12:07:16 <Forkk> phaazon, is it possible to have two different ReaderT monads at once?
12:07:31 <Fuuzetsu> Forkk: newtype
12:07:32 <heatsink> For those kind of algorithms, the slowest part is usually moving data around
12:07:45 <Forkk> Fuuzetsu, yeah, I should probably be using that anyway
12:08:20 <Fuuzetsu> I read some Core output yesterday, all the free casts due to newtype made me feel warm and fuzzy
12:08:41 * hackagebot pretty-class 1.0.1.0 - Pretty printing class similar to Show.  http://hackage.haskell.org/package/pretty-class-1.0.1.0 (DavidFox)
12:09:25 <dcoutts_> Fuuzetsu: yes a Text is an array, but the algorithms are all serial, because of the representation (UTF16)
12:09:32 <heatsink> The CPU-GPU round trip takes longer than processing the data.  It can be faster than CPU if the array is big enough.  A few megabytes, maybe.
12:09:59 <dcoutts_> right, and then as heatsink says, there's the huge gpu/cpu overhead
12:10:03 <dcoutts_> most strings are short
12:10:19 <Fuuzetsu> OK, I see, was just wondering
12:10:24 <dcoutts_> if you were doing lots of operations over the same long string then it's plasuible
12:11:14 <Fuuzetsu> it'd be cool to have GPU-powered text processing for Yi but it was only a curiousity
12:11:21 <dcoutts_> Fuuzetsu: vectorisation on the cpu is more plausible, and doesn't have so much startup overheads
12:11:24 <Fuuzetsu> curiosity*
12:16:19 <Fuuzetsu> is there a package like ‘filepath’ but over Text?
12:16:24 <Fuuzetsu> don't want to duplicate work
12:16:38 <pharaun> ByteString
12:16:44 <pharaun> but iirc it was posix specific
12:16:54 <luite> Fuuzetsu: that would still have the same problems as the usual FilePath
12:17:23 <luite> Fuuzetsu: system-filepath is one that tries handle encoding (or non-encoding) correctly
12:17:40 <josiah14> is there some way to read the output of a shell cmd such as 'echo' in haskell?
12:17:55 <joelteon> use the process library
12:18:03 <josiah14> been trying
12:18:04 <Fuuzetsu> well, we currently use ‘filepath’ package
12:18:47 <Fuuzetsu> o, nice, system-filepath uses Text
12:18:51 <sinelaw> why isn't the type of Y combinator: a -> a -> a?
12:18:52 <monochrom> Fuuzetsu, you may like system-filepath's "extension :: FilePath -> Maybe Text"
12:18:56 <josiah14> I think the bigger thing is that I need to detect the terminal width, which ZSH holds in the $COLUMNS env_var, but i'm not really sure how to access that from haskell
12:19:14 <Fuuzetsu> monochrom: yes, guess I'm going to be migrating to that later
12:19:43 <monochrom> however, the main interface between its FilePath and your program is the IsString instance
12:21:08 <Fuuzetsu> it can't be worse than having everything as Text
12:21:11 <Fuuzetsu> uh, as String*
12:22:47 <monochrom> sinelaw: the Y combinator runs into an occurs-check error when inferring types.
12:23:39 <monochrom> the exact occurs check error happens when unifying a with a->a.
12:25:07 <monochrom> this is a manifestation of the fact that any denotational semantics of the untyped lambda calculus must satisfy "domain isomorphic to domain->domain"
12:27:44 <c74d> josiah14: I’d expect most terminal UI libraries would be able to access terminal dimensions
12:28:15 <edwardk> @tell joshcough i use optparse-applicative
12:28:15 <lambdabot> Consider it noted.
12:28:43 * hackagebot pretty-class 1.0.1.1 - Pretty printing class similar to Show.  http://hackage.haskell.org/package/pretty-class-1.0.1.1 (DavidFox)
12:28:45 * hackagebot court 0.1.0.0 - Simple and flexible CI system  http://hackage.haskell.org/package/court-0.1.0.0 (thoferon)
12:29:07 <monochrom> haha
12:30:50 <edwardk> monochrom: is it isomorphic or merely a section-retraction situation?
12:31:32 <monochrom> it is ismorphic in the absence of "built-in integer type, bool type, etc"
12:31:48 <edwardk> ok, now i believe you =)
12:32:18 <mgaut72> is there a way to override a function (say f) in a module, with another function (say g)  so that all other functions in that module using f now use g instead?
12:32:29 <edwardk> mgaut72: no
12:33:19 <mgaut72> what about write a module that depends on some function.  basically, initialize a module with a function?
12:34:15 <edwardk> mgaut72: not as such. ML can do that, haskell doesn't work that way. here you'd make a typeclass for the thing you wanted to do and plumb the information in the types
12:34:35 <edwardk> or make a global program transformation to make it a parameter to everything
12:36:33 <mgaut72> edwardk: thanks.  do you have (or know of) a good example of going to typeclass route?
12:38:18 <lpaste_> Yrarr pasted “Existential Datatypes - returning the vector's Seq” at http://lpaste.net/111054
12:38:34 <heatsink> With type classes, you specify to choose f or g based on which type the function is called at
12:39:31 <Yrarr> Hello, I've got one question relating to Existential Datatypes : is it possible to write functions, or type classes and instances, that return the values inside data type which uses existential qualification ? http://lpaste.net/111054
12:39:31 <heatsink> So you'd need to formulate it as having different data types, with f implementing an operation on one type and g implementing the same operation on another.
12:39:48 <monochrom> Yrarr, the answer is no
12:39:57 <edwardk> mgaut72: its more of a pattern you get used to doing as you need it, can't point to anything that is just straight up "here's an ad hoc overloading of one method" as we tend to try to be more principled than that ;)
12:40:06 <Yrarr> And is there anything I can use in Haskell to do so ?
12:40:23 <heatsink> Yrarr, you have to formulate the problem differently
12:40:32 <mgaut72> edwardk: so is this a sign of bad design, and something to be avoided?
12:40:51 <heatsink> Typically if you want to return something from inside an existential package, you first convert it to a known type
12:41:17 <sinelaw> monochrom, how does Y fail the occurs check? i've gone through it several times now... must be the lack of sleep :)
12:41:31 <Yrarr> heatsink: So I can do for example a-> String, and then "read *received value*"
12:41:36 <sinelaw> Y f = f (Y f)
12:41:37 <monochrom> perhaps I'll go through (\x -> x x) instead.
12:41:51 <sinelaw> monochrom, fine, let's start with that
12:41:53 <monochrom> oh, that is not really Y
12:42:02 <sinelaw> it isn't?
12:42:06 <heatsink> Yrarr, that would work.  Without more details, I can't tell whether that's a good solution.
12:42:08 <sinelaw> :#
12:42:35 <edwardk> mgaut72: if it is well and truly any function, i'd probably parameterize all the things in that module on the function itself.
12:42:37 <sinelaw> hi Peaker .... type inference bugs :)
12:42:46 <edwardk> if its a thing that has laws and a pattern to its use, i'd make a class and name the laws
12:43:12 <monochrom> Y has to be (\f -> (\x -> f (x x)) (\x -> f (x x))).
12:43:49 <monochrom> "fix f = f (fix f)" type-infers to fix :: (a->a) -> a. this one has no error.
12:44:19 <sinelaw> so my inference works!
12:44:26 <sinelaw> that's what I'm getting.
12:44:36 <Yrarr> heatsink: Okay. So why is it like this ? I mean.. I nead another, one, strict type, for the values to be converted into. Then I need functions that convert this type into oirignal types. I'm just curious why can't Haskell do that for me.
12:44:43 <sinelaw> monochrom, but isn't that the definition of Y
12:44:43 <sinelaw> ?
12:44:58 <monochrom> no, Y is defined to be (\f -> (\x -> f (x x)) (\x -> f (x x)))
12:46:00 <sinelaw> I see. the fix equation is the property that Y must fulfill, but there are many implementations?
12:46:08 <monochrom> yes
12:46:11 <sinelaw> Y specifically being what you said
12:46:17 <sinelaw> ok.
12:46:25 <sinelaw> thx
12:46:37 <sinelaw> are there others?
12:46:51 <monochrom> I saw a long one in a book. I have forgotten it.
12:47:24 <Yrarr> I probably should've looked into read source codee for now...
12:47:28 <barrucadu> The wikipedia article on fixed-point combinators has a few examples
12:47:44 <heatsink> I don't understand what you're asking, Yrar.
12:49:51 <sinelaw> monochrom, same as this, right: Y f = g g where g = \x -> f (x x)
12:50:10 <heatsink> Yrarr, a program cannot look at a value and determine what type it is.  So you can't "convert data to its original type" in the way that I think you want to do.
12:50:25 <monochrom> yes, that's a shorter way to write it, if you have "where"
12:50:53 <sinelaw> ok. I tried that and it fails occurs check. all is good.
12:51:02 <heatsink> Yrarr, instead, the compiler checks a program to make sure that the code always uses data correctly according to its type.
12:51:11 <monochrom> Yrarr, I wonder why your vector is not simply "newtype Vector a = Vector (Seq.Seq a)"
12:51:23 <the_monarch> Can someone explain to me what "Ord a => a -> a" means? I get that it's supposed to be an undefined type, right? But why clarify that it's ordered?
12:51:45 <barrucadu> the_monarch: Because it needed to be ordered in that case?
12:51:50 <Yrarr> monochrom: Ok, yes, that would work, thanks :)
12:51:51 <barrucadu> Without further context it's hard to say
12:52:00 <sinelaw> I'm actually inferring types in javascript. Y in javascript...what a trip
12:52:09 <ion> the_monarch: The caller of the function lets to dictate the type with the constraint that it’s an instance of Ord.
12:52:20 <the_monarch> barrucadu: the function is supposed to find the highest value of x in an array
12:52:35 <monochrom> javascript is statically untyped enough to support Y, yes :)
12:52:45 <barrucadu> the_monarch: Ok, so that requires there to be an ordering on x
12:52:56 <barrucadu> *total ordering
12:53:00 <barrucadu> Which is exactly what an Ord constraint guarantees
12:53:00 <the_monarch> barrucadu: why is that?
12:53:03 <vanila> what about a type system that supports infinitie types?
12:53:08 <vanila> would that be bad?
12:53:15 <barrucadu> Well, what is the "highest value" if there is no ordering?
12:53:22 <Yrarr> monochrom: Oh, I forgot - I wanted Vector to hold only numerical values.
12:53:26 <barrucadu> "highest" is meaningless in that case
12:53:28 <monochrom> infinite types will accept it, too. but infinite types are hard to infer.
12:54:20 <the_monarch> barrucadu: well, couldn't you compare x against y and xs?
12:54:28 <barrucadu> How?
12:54:31 <monochrom> Yrarr, then you impose "Num a" on function types.
12:54:47 <barrucadu> If the type is unordered, what does "x < y" evaluate to?
12:55:01 <the_monarch> barrucadu: not sure
12:56:28 <barrucadu> You can only compare things where it is meaningful to do so: == requires Eq, > and < require Ord (which in turn requires Eq)
12:57:08 <NightRa> Is there a name for a Prism-Iso-Prism combination? It seems it might be pretty common
12:57:09 <heatsink> barrucadu: Since the function has type Ord a => a -> a, it can only obtain one value of type a.  Since x must be equal to y in x < y, it would evaluate to False if x and y are not _|_.
12:57:20 <Yrarr> monochrom: Ok, so the usuall design is to not check correctness on the data type, but on the functions ?
12:57:43 <monochrom> yes. in fact, Haskell 2010 forces you to do it.
12:59:13 <Fuuzetsu> http://ghc.haskell.org/trac/ghc/ticket/9577 muh 5KB!
13:02:04 <Yrarr> heatsink: Hm.. ok... I just wonder if it could be done by mechanics like for C++'s templates, just instead of generating code for one type, you do that for a subset of types.
13:02:24 <Fuuzetsu> is doing a pattern match on string literal which is actually Text, through use of OverloadedStrings inefficient? Should I turn such matches into Eq on Text instead?
13:04:13 <bennofs> Fuuzetsu: I'd guess it compile to exactly the same code. What should GHC desuger it to if not == and fromString ?
13:04:46 <Fuuzetsu> who knows
13:04:49 <Fuuzetsu> going to dump core
13:05:32 <heatsink> Yrarr, some Haskell compilers generate code for each possible type.  However, it is not always possible to generate code for all the types a program will use.  So GHC turns polymorphic code into generic executable code that works for any type.
13:05:56 <Fuuzetsu> bennofs: haha, GHC is too good for me
13:06:11 <Yrarr> heatsink: ok, thanks for the explenation :)
13:06:45 <Fuuzetsu> http://lpaste.net/111055 , R.fast = R.slow ;P
13:07:07 <bennofs> Yrarr: another problem is code explosion, which can actually make performance worse. You can still use a {-# SPECIALIZE #-} ghc pragma to specialize for some common types
13:08:12 <mitchty> so if cabal is having issues finding libgmp on osx (mavericks), are teh --extra-{include,lib}-dirs not the way to point it to the right spots?
13:09:23 <dcoutts_> mitchty: no, that'd be the solution for extra C libs you installed manually in non-standard locations. Normally ghc should be able to find gmp just fine, so this indicates there's something wrong with your setup
13:09:53 <dcoutts_> mitchty: e.g. that you just don't have gmp installed, like if you installed ghc from homebrew or something
13:10:11 <dcoutts_> depends on where you got your ghc from
13:10:42 <mitchty> dcoutts_: yep its homebrew ghc for the moment, so its just /usr/local/lib
13:11:00 <dcoutts_> mitchty: ok, make sure you really do have gmp installed from homebrew too
13:11:52 <mitchty> most definitely do, this is a quick run, not sure if i need to rebuild ghc pointed right at it
13:11:55 <mitchty> https://gist.github.com/mitchty/b09ad867fc698fbcc0a0
13:13:21 <dcoutts_> mitchty: does homebew do anything special to make sure that the libs it installs can be found?
13:13:28 <dcoutts_> e.g. just for C code, ignoring ghc for a mo
13:13:47 <mitchty> dcoutts_: that, i don't know, guess its time to look at the formulae for it
13:13:47 * hackagebot xml-push 0.0.0.4 - Push XML from/to client to/from server over XMPP or HTTP  http://hackage.haskell.org/package/xml-push-0.0.0.4 (YoshikuniJujo)
13:14:15 <dcoutts_> mitchty: e.g. if you make a .c file and try and gcc -lgmp, that should work. If it doesn't, ghc will hit the same problem.
13:15:57 <Yrarr> bennofs: okay, this looks interesting, thanks!
13:16:59 <mitchty> dcoutts_: without specifying it directly its a bust
13:17:03 <mitchty> that is clang -L/usr/local/lib -v -o /tmp/test -lgmp /tmp/foo.c
13:18:11 <dcoutts_> mitchty: so I don't know about homebrew, there's probably a standard solution to this. Otherwise, you can have ghc always use -L/usr/locall/lib
13:18:54 <mitchty> dcoutts_: no worries, so the odd thing is this works fine (no issues at all) on 10.10 but not 10.9
13:19:27 <mitchty> ah
13:19:30 <mitchty> think i see why now
13:19:38 <dcoutts_> mitchty: it might be that llvm/clang do not search /usr/local/lib by default, but gcc did
13:19:39 <mitchty> https://github.com/Homebrew/homebrew/blob/master/Library/Formula/ghc.rb#L82
13:20:01 <mitchty> looks like it is configured with gcc itself, so using clang might be the issue entirely
13:22:14 <dcoutts_> mitchty: me suggesting workarounds is probably silly. There's undoubtedly a standard solution, given that 10.10 has been out so long.
13:23:20 <mitchty> dcoutts_: no worries, i'm going to compare it to this https://github.com/ghcformacosx/ghc-dot-app which does generate working ghc/ghci/cabal
13:25:19 <cstrahan> what's the easiest way to get the $compiler name (as cabal would see it) for a given GHC installation?
13:25:29 <cstrahan> (I need to write a shell script)
13:26:44 <joneshf-laptop> hmm, thinking about `Applicative` and `Num`, is there a problem with an instance like: `instance (Applicative f, Num a) => Num (f a) where { x + y = (+) <$> x <*> y; ...`?
13:26:55 <cstrahan> i'm thinking I could probably write and compile a trivial program, but I don't know where to get the $compiler value from
13:27:51 <shachaf> joneshf-laptop: It overlaps with e.g. Complex and Ratio.
13:28:13 <dcoutts_> cschneid: isn't it just ghc-${ghc_version}
13:28:27 <joneshf-laptop> shachaf, i see
13:28:50 <shachaf> joneshf-laptop: But you can see that e.g. http://hackage.haskell.org/package/NumInstances-1.3/docs/src/Data-NumInstances-Function.html uses the general idea.
13:30:50 <cstrahan> dcoutts_: for ghcjs $compiler is ghcjs-${ghcjs_version}_ghc-${ghc_version}, which ends up being something like ghcjs-0.1.0_ghc-7.8.3
13:31:47 <dcoutts_> cstrahan: ok, so you don't really mean for a given ghc installation, but a given compiler that Cabal knows about
13:32:12 <dcoutts_> there isn't a straightforward nice way to get that
13:33:42 <dcoutts_> cstrahan: you can do unpleasant things like cabal configure -v and look at the output
13:35:21 <dcoutts_> e.g. cabal configure -v --libdir='$compiler' --libsubdir='' | grep 'Libraries installed in:'
13:35:40 <cstrahan> dcoutts_: ah, neat.
13:38:02 <cstrahan> dcoutts_: so $compiler is something that the cabal binary is responsible for? if so, I might just write a patch file for ghcjs's cabal so that it just uses ghcjs-${ghc_version}
13:38:19 <cstrahan> dcoutts_: ultimately, I'm just trying to get ghcjs packaged up for NixOS
13:38:30 <cstrahan> which already has support for ghc
13:38:49 * hackagebot hlint 1.9.5 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.9.5 (NeilMitchell)
13:39:01 <dcoutts_> cstrahan: you have complete control over where things get installed, you can specify the --libdir and --libsubdir. You don't need to rely on the defaults (which use things like $compiler)
13:39:46 <dcoutts_> cstrahan: and distros should certainly specify the layout that they want and not rely on possibly changing defaults
13:42:01 <dcoutts_> cstrahan: sorry, I should have asked before giving you horrible hacky solutions :-)
13:42:19 <dcoutts_> solutions to non-problems
13:43:49 <ricksmorty> Hey guys, I'm trying to make a function that takes a list and returns the list of all pairs of adjacent elements. It seems to be working but I'm getting this weird exception, "Non-exhaustive patterns in function adjacent" What could I be doing wrong?
13:44:24 <ricksmorty> Should I show my code?
13:44:40 <shachaf> The answer to what question is practically always yes.
13:44:59 <volty> empty list or list with odd num of elems
13:45:17 <cstrahan> dcoutts_: true. the thing is, NixOS already passes --libdir as "$prefix/lib/$compiler" - i'm trying to change as little of the current infrastructure as I can.
13:45:37 <ricksmorty> shachaf: http://pastebin.com/yPG1Py2R
13:45:54 <dcoutts_> cstrahan: ok, and why is it you need to know it?
13:45:55 <shachaf> ricksmorty: You're only handling lists with two or more elements.
13:46:15 <shachaf> ricksmorty: What is adjacent [x], or adjacent []?
13:46:32 <shachaf> If you compile with ghc -Wall, you'll get a warning at compile-time (which is much more useful).
13:46:34 <ricksmorty> x, 0?
13:46:48 <benzrf> ricksmorty: any relation to rick & morty
13:46:56 <ricksmorty> benzrf: yes :)
13:46:57 <shachaf> What?
13:47:02 <dcoutts_> cstrahan: are the nix build scripts making assumptions about the file layout, like assuming that $compiler is always ghc-x.y, when it already knows x & y?
13:47:23 <shachaf> Start with "what's the type of adjacent?". It's useful and polite to give things types when you're pasting them.
13:48:05 <dcoutts_> cschneid: if the scripts care about the precise layout, then they should specify the exact --libdir they want, and if they don't care then it's ok to use $compiler etc
13:50:02 <latk> Is x:xs or [x] ++ xs faster ?
13:50:40 <johnw> latk: you can check the generated core
13:50:52 <latk> How can I do this ?
13:51:00 <johnw> I use the utility "ghc-core"
13:51:01 <latk> I'm not entierly sure what you mean :p
13:51:10 <johnw> i mean, read the code generated by GHC
13:51:12 <hyPiRion> x:xs in theory, but they both run in O(1)
13:51:27 <johnw> I would expect them to be identical under -O, but I'd need to read the Core to be sure
13:51:27 <cstrahan> dcoutts_: yeah, that's pretty much it. of course, at that point, we might as well pass that along as part of the --libdir flag.
13:51:36 <Fuuzetsu> what does ghc-core do johnw
13:51:37 <latk> hyPiRion: Cool, thanks.
13:51:43 <Fuuzetsu> how is it different from passing ddump-simpl
13:52:02 <johnw> Fuuzetsu: it gives you fancy colors and passes all the necessary options for you
13:52:04 <johnw> shachaf maintains it
13:52:24 <cstrahan> dcoutts_: alright, I think gives me an idea of how I'll restructure things - thanks for helping me think it through! :)
13:52:25 <shachaf> fsvo "maintains" :-(
13:52:31 <shachaf> There are some things I need to do.
13:52:52 <johnw> well, I use it pretty often, so than you for what you've done thus far shachaf
13:53:16 <dcoutts_> cstrahan: np
13:53:51 * hackagebot jose-jwt 0.2 - JSON Object Signing and Encryption Library  http://hackage.haskell.org/package/jose-jwt-0.2 (LukeTaylor)
13:55:13 <Fuuzetsu> is it in nixpkgs, johnw
13:55:24 <singularai> hey guys, can someone help me understand why lazyIO is causing a segmentation fault in my program?
13:55:28 <johnw> Fuuzetsu: yes
13:55:36 <johnw> haskellPackages.ghcCore
13:55:41 <Fuuzetsu> singularai: that sounds unlikely, the underlying C library somewhere might be
13:55:44 <singularai> I'm calling C
13:56:12 <singularai> passing a string into C
13:56:22 <singularai> if I run seq x $ print ()
13:56:34 <singularai> before passing x into the code that makes the cstring from x
13:56:39 <singularai> then everything works
13:56:50 <singularai> if I comment out that line, then I get a segmentation fault
13:57:07 <Fuuzetsu> ghc-core: less -R: rawSystem: runInteractiveProcess: exec: does not exist (No such file or directory) ;(
13:59:09 <the_jeb> you know, I was told learning haskell would be just like when I first learned programming, but this is much more confusing
13:59:31 <singularai> @the_jeb haha, I always agreed with that
13:59:32 <lambdabot> Unknown command, try @list
13:59:49 <singularai> esp w.r.t. functional data structures
13:59:57 <hughfdjackson> hrm - just out of curiousity
14:00:00 <hughfdjackson> is there any version of <$> or fmap defined in a library where the order of the arguments is flipped?
14:00:06 <singularai> they are just fundamentally harder to design
14:00:09 <xeno_> the_jeb: I dunno about you, but when I learned program (which was in QBASIC in the early 90ies), the programs I wrote was prosecutable by the ICC
14:00:17 <Fuuzetsu> hughfdjackson: there <&> in lens
14:00:23 <Fuuzetsu> I think <$$> is defined somewhere too
14:00:26 <Fuuzetsu> @hoogle <$$>
14:00:28 <lambdabot> Text.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
14:00:28 <lambdabot> Text.ParserCombinators.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
14:00:33 * hughfdjackson would like to be able to say `myDataInAMaybe <$> transformingFn <$> transformingFn'` 
14:00:54 <singularai> I see that no one wants to debug segmentation faults atm :(
14:01:08 <hughfdjackson> Fuuzetsu: <$$> would be make the most sense - pity it seems to be something parsec specific !
14:01:18 <monochrom> singularai, I don't know how to reproduce the problem. perhaps show actual code?
14:01:18 <hughfdjackson> will look into the lens library tip :) thanks
14:01:29 <Fuuzetsu> well, hoogle knows about parsec thing, it's probably somewhere else
14:01:35 <Fuuzetsu> you could just define it yourself you know
14:01:39 <singularai> this is my first time on irc
14:01:45 <singularai> got banned last night for pasting code
14:01:48 <singularai> what's the protocol
14:01:53 <hughfdjackson> Fuuzetsu: yup - i've already defined a `getOrElse` operator
14:01:58 <the_jeb> singularai: pastebin
14:02:01 <monochrom> put the code on lpaste.net, or any pastebin
14:02:03 <Fuuzetsu> you got banned because you flooded the channel instead of using a paste service such as lpaste
14:02:08 <jle`> i wouldn't mind a flip fmap somewhere in base.  it would fill a similar role as forM_ vs mapM_
14:02:13 <edwardk> singularai: send it to http://lpaste.net/ then it'll post a link back here
14:02:20 <jle`> singularai: it's in the topic of the chatroom :)
14:02:25 <edwardk> singularai: that results in one line worth of spam for folks uninterested not a screen ;)
14:02:40 <hughfdjackson> Fuuzetsu: but im in newbie territory - don't want to replicate half of the common libraries just because my searches haven't thrown up anything yet ;D worth a double check
14:02:42 <hughfdjackson> cheers
14:02:48 <Fuuzetsu> hughfdjackson: if ou're going to import lens anyway, you can probably get rid of much more boilerplate than just that flipped fmap
14:04:31 <hughfdjackson> Fuuzetsu: .. hey, that there's a good point
14:04:36 <singularai> http://lpaste.net/111059
14:04:37 <hughfdjackson> :| wonder why i never thought of it
14:04:42 <hughfdjackson> will have a play around
14:04:43 <hughfdjackson> thanks !
14:04:59 <Fuuzetsu> np
14:05:44 <Fuuzetsu> singularai: …are you embedding Python
14:05:46 <Fuuzetsu> why
14:05:48 <Fuuzetsu> ew
14:05:55 <singularai> yea, I understand now that you're not allowed to paste code - I was just unaware of the rules
14:06:10 <singularai> because I want to do machine learning in haskell
14:06:18 <singularai> well, because I alread am doing machine learning in haskell
14:06:21 <Fuuzetsu> you are allowed to paste code if it's like 2 lines or so; it's not us that banned you anyway, it was automated
14:06:30 <singularai> yea, it was 4 lines of code
14:06:37 <Fuuzetsu> no, it was more than 4 lines
14:06:38 <jle`> yeah, the robots detect it and it's automatic
14:06:38 <singularai> and I'm using kiwi
14:06:40 <jle`> sorry ;_;
14:06:46 <MrElendig> generale rule of irc: never paste more than 3 lines
14:06:47 <singularai> so I hit ^v
14:06:53 <singularai> and didn't get any feedback
14:07:04 <singularai> so I hit it like 3 more times
14:07:10 <singularai> out came a page of content
14:07:12 <singularai> and then came the banhammer
14:07:53 <Fuuzetsu> singularai: anyway, there are a bunch of machine learning packages on Hackage
14:07:53 <MrElendig> set up your irc client to yell at you if you try to paste more than 3 lines :)
14:08:13 <Fuuzetsu> also I'm not sure how reading in a CSV file through Python is learning machine learning in Haskell ;P
14:08:16 <singularai> well, I know now so there is no problem
14:08:31 <jle`> anyways, do you have a question? :)
14:08:32 <monochrom> singularai, where is the CString that you promised?
14:08:42 <singularai> uh, let me post the library code
14:09:21 <singularai> the library code is separated into a hackage package of course
14:09:58 <singularai> http://lpaste.net/111060
14:10:46 <singularai> @fuuzetsu I looked up csv parsers in haskell and stackoverflow claimed there was nothing great. So I wrote the half dozen lines in importCSV
14:10:46 <lambdabot> Unknown command, try @list
14:11:00 <singularai> works great
14:11:44 <singularai> except for of course the fact that it's exposed this segmentation fault
14:12:03 <Fuuzetsu> singularai: don't use the @ style addressing, it triggers lambdabot, the common practice is to use ‘Name:’ format; your IRC client can probably tab-complete names
14:12:06 <singularai> the library is on hackage as json-python if anyone is interested in testing the code that way
14:12:23 <singularai> although it is in alpha
14:12:27 <Fuuzetsu> I'm pretty sure we have CSV parsers…
14:12:36 <singularai> Fuuzetsu: okay, better?
14:12:47 <Fuuzetsu> I think RWH even shows an implementation of one in like 7 lines as an exercise
14:12:50 <Fuuzetsu> sure
14:12:57 <singularai> you cannot implement a csv parser in 7 lines
14:13:08 <Fuuzetsu> that's a bold claim
14:13:11 <Fuuzetsu> also why not use http://hackage.haskell.org/package/csv-0.1.2/docs/Text-CSV.html
14:13:19 <singularai> csv is not a well defined format
14:13:42 <singularai> writing your own csv parser is asking for trouble
14:13:56 <singularai> I'm also writing this file to get used to this json-python library I wrote
14:14:04 <Fuuzetsu> since when?
14:14:06 <singularai> so it was a good opportunity
14:14:18 <singularai> since when is it not well defined?
14:14:22 <Fuuzetsu> http://tools.ietf.org/html/rfc4180
14:14:49 <Fuuzetsu> it's trivial to parse, 7 lines is more than enough
14:14:56 <singularai> I've personally encountered at least 3 different types of csvs in person
14:15:11 <Fuuzetsu> I hope you let them know that they should adhere to RFC then
14:15:19 <singularai> there's no consensus on how to deal with quotes, newlines, etc
14:15:45 <Fuuzetsu> ok, 3 types, must be 15 lines then
14:16:07 <singularai> I'm not claiming its hard
14:16:13 <singularai> I'm claiming it's the last thing you want to do
14:16:30 <Fuuzetsu> embedding Python in Haskell is the last thing I want to do
14:16:32 <singularai> write a parser for a hazily defined format with lots of edge cases
14:16:42 <Fuuzetsu> you're exaggerating
14:16:59 <singularai> anyways, I don't want to start a flamefest here
14:17:31 <singularai> does anyone have any thoughts as to why passing a IO [[Float]] down to C would behave differently if evaluated first?
14:17:49 <Fuuzetsu> did you read the GHC manual and wiki pages on FFI?
14:18:04 <singularai> some of them, nothing in its entirety
14:18:31 <singularai> I tried to shrink the repro down to something more simple. Simplifying the example destroys the bug
14:19:00 <singularai> It has to do with getting a value from python and passing it back in
14:19:06 <benmachine> passing an IO [[Float]] to C sounds scary
14:19:10 <singularai> perhaps a value is getting cache somewhere
14:19:22 <singularai> the way json-python works
14:19:25 <benmachine> like, IO is internally a function type, I think, and I don't know how lists serialise
14:19:29 <singularai> is that it uses Data.Aeson to transform types to strings
14:19:45 <singularai> Then the string gets turned into a csting
14:19:50 <singularai> the cstring is passed to python
14:20:01 <monochrom> singularai: where can I read about PyString_AsString?
14:20:02 <singularai> the python function automatically runs json.loads() on the value
14:20:11 <singularai> PyString_AsString is in the python C api
14:20:14 <singularai> let me find a link
14:20:35 <singularai> https://docs.python.org/2/c-api/string.html
14:21:00 <singularai> the only import c function in there that I wrote myself is
14:21:10 <singularai> get_object
14:21:44 <monochrom> singularai: "The pointer refers to the internal buffer of string, not a copy" looks relevant. I have to think about its implications.
14:21:54 <singularai> and that will throw a segfault if you try to grab an object whose name is not defined in the interpreter
14:22:12 <fdsdfsf> How can I emulate the set! operator?  In Scheme, I can change the value of x like so: (define x 42) (display x) (newline) (set! x 24) (display x) (newline), is there a way to do it in Haskell?
14:22:21 <singularai> hmm, yea this whole thing is thrown together in a rather shoddy backend manner
14:22:24 <ski> fdsdfsf : no
14:22:33 <ski> fdsdfsf : variables aren't mutable in Haskell
14:22:37 <Fuuzetsu> well, he said emulate
14:23:11 <ski> fdsdfsf : you can however make something similar to Scheme boxes (with `set-box!', &c.), namely `IORef' (and `STRef' and `MVar' and `TVar' and ...)
14:23:42 <fdsdfsf> ski: I've tried with MVar, and it doesn't work.
14:23:46 <ski> fdsdfsf : however, if you don't need to *mutate* a variable, you could possibly just define a new one (possibly shadowing the old one)
14:23:48 <Fuuzetsu> no LVars?
14:24:21 <Fuuzetsu> fdsdfsf: ‘doesn't work’?
14:25:04 <singularai> monochrom: yea that does look relevant, I thought python stored strings as separate pyobjects, and pystring_asstring was returning a fresh string
14:26:20 <fdsdfsf> Fuuzetsu: it doesn't work the way I want it to work.  If I define x = newEmptyMVar and then attempt to use it like in Scheme, I'll be always getting the initial x.
14:26:56 <jle`> fdsdfsf: there is no concept of "evaluation order" in haskell
14:27:00 <jle`> everything you define is a definition
14:27:15 <jle`> so if you swap the locations of two declarations in a file, it should still be the same thing
14:27:23 <ski> fdsdfsf : `newEmptyMVar' is an *action* that when *executed* will hand back a new empty `MVar'. saying `x = newEmptyMVar' will make `x' equal to this (unexecuted) action. it won't make it be executed
14:27:31 <vanila> hmm I think there is lazy evaluation
14:27:40 <vanila> specifices order roughly
14:27:43 <ski> fdsdfsf : iow, you want to *execute* the action, and give a name to the resulting `MVar'
14:27:58 <jle`> vanila: heh.  yeah, i think i meant that it is unrelated to the position in your file
14:28:01 <benmachine> vanila: nah. Haskell is permitted to evaluate things in any order that provides non-strict semantics
14:28:05 <fdsdfsf> ski: I think so.
14:28:32 <benmachine> (strictness analysis frequently causes things to be evaluated before a "true" lazy evaluator would)
14:28:48 <vanila> I depend on lazy ness to do things like memoization
14:29:36 <ski> vanila : there's non-strict evaluation, which doesn't specify (operational) evaluation ordering, it only specifies denotations. however there's an obvious naive operational reduction strategy for non-strict evalution, which would specify a partial ordering
14:29:38 <fdsdfsf> ski: Basically, I've been trying to mimic the memoize function from Scheme, but I can't make it work the same way due to the fact that once you've created a toplevel variable, you can't alter it.
14:29:48 <merijn> vanila: Two things: 1) haskell is not defined to be lazy, but defined to be "non-strict" and 2) how haskell is non-strict is unspecified
14:29:50 <fdsdfsf> ski: I can show you the code if you want.
14:29:53 <ski> Haskell itself only specifies non-strictness, though
14:30:28 <vanila>  I expect it to not recompute 'let' values for example
14:30:50 <monochrom> singularai: I have troubles with your foreign bindings. for example, why is py_BuildValueString not CString -> CString -> IO (Ptr PyObject). similarly for the rest. I'm thinking that this has much more to do with the segfault. (Also, I can't find any lazy I/O.)
14:31:10 <merijn> vanila: Sure, but that hardly specifies anything about in which order let bindings are evaluated :)
14:31:13 <fdsdfsf> ski: In Scheme, I can write ((memoize fib) 32) in multiple places, and it won't be recomputed.
14:31:37 <ski> vanila : see monochrom's "Lazy Evaluation of Haskell" <http://www.vex.net/~trebla/haskell/lazy.xhtml> for more details
14:31:38 <vanila> yeah the order isn't important
14:32:20 <merijn> I'm not sure how "In Scheme, I can X" is relevant, I suspect you're only getting yourself confused by trying to establish an analogy with Scheme, rather than telling people what you want to do and then figuring out how to accomplish that in haskell
14:32:42 <ski> fdsdfsf : there are several ways you can memoize in Haskell
14:32:43 <katsh> http://tabbit.org/n  why do i get a syntax error when running this?
14:33:09 <Fuuzetsu> katsh: because you're using tabs
14:33:13 <benmachine> memoise is a good example of a function that's substantially harder to write in Haskell than in other languages
14:33:20 <merijn> katsh: skinny, normal, etc. are not aligned with bmi
14:33:23 <Fuuzetsu> oh, you aren't
14:33:27 <Peaker> fdsdfsf: does it have some global lookup table where it finds the "fib" symbol at?
14:33:40 <Fuuzetsu> I came to expect any alignment problem from newbies to be caused by hard tabs
14:33:42 <fdsdfsf> Peaker: yep, that's how it works in scheme
14:33:42 <singularai> monochrom: okay, what are the semantics of having that c function return IO (Ptr PyObject) instead of Ptr PyObject?
14:33:43 <katsh> merijn: thanks. Fuuzetsu it may seem, but im not :)
14:33:50 <benmachine> this is kind of by design since a memoised function changes behaviour over time and so is basically not pure
14:33:50 <fdsdfsf> merijn: I've been writing Haskell for a while so I'm aware of the concepts.  It's purely an exercise for me.
14:33:51 <katsh> using 4 spaces as tabs
14:34:01 <Peaker> benmachine: it's also easier in the sense that purity is guaranteed, so memoization is known to be correct
14:34:06 <merijn> katsh: I recommend reading: https://en.wikibooks.org/wiki/Haskell/Indentation
14:34:26 <Peaker> benmachine: it's only impure in the same sense that the laziness is impure (behind the scenes)
14:34:28 <katsh> will do. one question though
14:34:33 <merijn> katsh: It explains how layout is desugared (and thus why this code is wrong) and learning the rules is the simplest way to avoid future errors, imo :)
14:34:43 <benmachine> Peaker: sure, but suppose you wanted to bound the size of the memoisation table by throwing away old values
14:34:45 <katsh> having 'where' in its own line, and bmi and everything else in a new line, works. is that ok?
14:34:53 <fdsdfsf> merijn: Because all memoization examples I've seen are "local".
14:34:53 <merijn> katsh: Sure
14:34:59 <benmachine> Peaker: it's not really possible (as far as I know) to do that in the pure setting
14:35:15 <srhb> katsh: The important thing is that the first letter of bmi ligns up with the first letter of skinny etc.
14:35:22 <srhb> lines*
14:35:25 <katsh> got it
14:35:35 <merijn> katsh: There's more haskell layout styles than there are websites. The main rule of thumb is: make sure it looks readable
14:35:53 <srhb> I thought the main rule was to obsess over making it prettier eternally.
14:35:55 <srhb> :3
14:35:55 <benmachine> Peaker: it's a context in which it's safe to use unsafePerformIO, but only as long as you're careful (but basically no more careful than you'd have to be in any other language anyway)
14:35:58 <ski> fdsdfsf : you could e.g. define a `memoizeByArray :: (Int,Int) -> (Int -> Int) -> (Int -> Int)' function, so that you can define `fib n0 = fib_n0 where fib_n0 = memoizeByArray (0,n0) body n0;body 0 = 0; body 1 = 1; body n = fib_n0 (n-1) + fib_n0 (n-2)', and it will be memoized as you expect
14:36:00 <Peaker> benmachine: sure it is -- unsafePerformIO is safe for these kinds of things
14:36:19 <Peaker> benmachine: and you can provide IO knobs for things like "clearCache", "setLRUSize", etc
14:36:32 <benmachine> Peaker: I don't really count that as "in the pure setting" but it does indeed solve the actual problem :)
14:37:08 <fdsdfsf> ski: I'll go afk for a while, try your suggestion, and report back.
14:37:12 <fdsdfsf> Thanks.
14:37:28 <ski> i'll disappear soon for today
14:38:00 <monochrom> singularai: if you use "X -> Y" instead of "X -> IO Y", then the compiler assumes that you claim that the C side is practically a pure function, most importantly the same X value leads the same Y value always. If your claim does not match reality, then there will be inconsistency.
14:38:25 <merijn> monochrom: s/inconsistency/blood, tears, fire and segfaults
14:38:30 <singularai> monochrom: okay, that seems important
14:38:36 <Fuuzetsu> merijn: the usual C things then
14:38:45 <merijn> Fuuzetsu: Don't remind me :(
14:39:14 <srhb> I have to say I thought it was quite nostalgic getting some segfaults again when I did some FFI stuff for the first time last week.
14:39:47 <merijn> srhb: If you want to feel nostalgic I'll let you debug my code next time... :p
14:39:56 <srhb> merijn: Not _that_ nostalgic. :-)
14:40:01 <yyttr3> Does anyone know how to change the look and feel of a gtk2hs UI?
14:40:02 <MP2E> "HERE'S ENOUGH NOSTALGIA FOR A LIFETIME! MUAHAHA!"
14:40:11 <kram1032> hi I'm trying to get emacs haskell-mode to run on windows. (I'm completely new to all this) is there a better place to ask about that or can somebody here help me?
14:40:29 <srhb> kram1032: We can probably help, otherwise there's #emacs with a few haskellers too.
14:40:30 <singularai> monochrom: amazing that I've made it this far without getting other errors due to that
14:40:49 <kram1032> ok thanks
14:40:57 <kram1032> let's see
14:41:31 <kram1032> where I am currently: I have installed emacs and I *think* I have installed haskell-mode
14:41:48 <srhb> kram1032: Presumably with M-x package-install haskell-mode ?
14:41:53 <kram1032> yes
14:41:56 <srhb> Sounds good.
14:42:08 <singularai> monochrom: somehow it seemed that wrapping the return value with Ptr would have a similar effect to what wrapping in IO actually does
14:42:30 <kram1032> if I got that right, one of the features of haskell-mode is that I can use GHCi within emacs, is that right, or am I misunderstanding something?
14:42:34 <monochrom> I'm thinking how the inconsistency manifests as segfault, and how laziness affects it. I guess the first thing to observe is that claimed pure functions are called more lazily. then it is possible that they are called too late, i.e., when the buffers you pass into them are no longer valid. making things more eager restores the good order of calling those functions and so "cures" the segfault.
14:42:55 <srhb> kram1032: Yes indeed
14:43:16 <srhb> kram1032: Try M-x inferior-haskell-load-file in a Haskell buffer
14:43:27 <Fuuzetsu> yyttr3: search the GTK docs for such a function then find it in the bindings
14:43:33 <srhb> kram1032: (It should say Haskell in the modeline if the mode activates correctly when you open a .hs file)
14:43:56 <monochrom> singularai: I can't see how one would get that conclusion. it looks wrong.
14:44:21 <kram1032> it says U (Unix) %%- *info* (haskell-mode) on the bottom if that's what you mean
14:44:24 <yyttr3> Fuuzetsu: I was hoping there was good documentation somewhere that I couldn't find :P
14:44:29 <yyttr3> Thank you, I'll look.
14:44:40 <monochrom> also I'm talking about "IO (Ptr PyObject)", not "IO PyObject".
14:44:54 <kram1032> ah
14:45:00 <kram1032> I think it's working now. Thanks srhb
14:45:05 <Fuuzetsu> yyttr3: not that I know of, I haven't seen such a setting in the examples given
14:45:20 <srhb> kram1032: Sure. You might want to check out the docs for haskell-mode on github for some suggestions for setting up keybindings etc.
14:45:26 <singularai> monochrom: yep, looks like that fixed it!
14:45:32 <monochrom> ok good
14:45:52 <fdsdfsf> Peaker: sorry, I incorrectly answered your question about the lookup table.  You don't match on "fib", you match on the argument and get the result back.
14:46:06 <singularai> monochrom: I'm very glad I came here
14:46:11 <kram1032> Man, I messed around with this forever. I'm not at all used to using the command line yet. First I tried to compile haskell-mode, fiddling around with git and mingw, to no avail, until I figured out that I can use marmalade for this
14:46:15 <Peaker> fdsdfsf: but then if you have multiple memo calls in different places, what makes them use the same table?
14:46:22 <singularai> monochrom: cause that was driving me nuts
14:46:47 <singularai> now I'm ready to go back to my flamefest with fuuzetsu
14:46:53 <singularai> python ftw!
14:46:55 <fdsdfsf> Peaker: It's a global variable, which you alter via set!
14:47:17 <Peaker> fdsdfsf: and what links the various different memos together to the same global? The name of the function?
14:47:31 <Fuuzetsu> singularai: I just think it's stupid that you embed Python (which calls out to C) for such inane reason such as CSV parsing, especially considering there are multitude of packages up on Hackage
14:47:53 <fdsdfsf> Peaker: ah, now I get your point.  yes, you'd need to match on the function name first.
14:47:56 <jle`> you could even make your own CSV parser in parsec or trifecta, etc.
14:47:57 <fdsdfsf> sorry again :)
14:48:15 <Fuuzetsu> jle`: apparently CSV is beyond ability of mere humans to parse
14:48:19 <merijn> jle`: Does trifecta have some docs/tutorial yet?
14:48:25 <Peaker> fdsdfsf: that's not in Haskell's spirit :) Both the global variable and the "by function name" part
14:48:33 <fdsdfsf> I'm aware
14:48:43 <Peaker> fdsdfsf: if you want to use the same memo, you have to pass it as an argument to where you want to use it
14:48:45 <merijn> jle`: Last time I looked at it I couldn't figure out how to work with it
14:49:07 <Fuuzetsu> how is trifecta performance now?
14:49:22 <ski> fdsdfsf : my `memoizeByArray' would return a function such that all calls to that function would use the same memo table (but calls to the original function wouldn't)
14:49:35 <monochrom> no, singularai, I think the flamefest was on whether CSV is well-defined :)
14:49:43 <fdsdfsf> ski: I'll check it out in a second.
14:51:36 <khumba> yyttr3, you mean apply a GTK+ theme dynamically in your app?  The RcStyle package has functions for this, and the source for gtk-chtheme has a simple (C) example.
14:52:08 <ski> fdsdfsf : .. and it's easy to define this `memoizeByArray' -- it doesn't even need to use any mutable containers :)
14:52:24 <singularai> I actually think that csv is well defined, but there is just no consensus
14:52:34 <merijn> ...
14:52:45 <merijn> If there's no consensus isn't it ill-defined by definition
14:53:00 <merijn> I would say that "well-defined" means that there's a consensus on what the definition is
14:53:05 <singularai> postgres will output csv one way
14:53:10 <mitchty> csv is horrible, so many parsers that amount to split on , its scary
14:53:11 <singularai> I'll get another way in data dumps
14:53:22 <singularai> right, splitting on , will fail sometimes
14:53:39 <singularai> its just better to depend on a well respected library if at all possible
14:53:58 * merijn doesn't understand all these people who believe csv, json and what not are good interchange formats...
14:54:11 <singularai> json is a different story obviously
14:54:18 <monochrom> what is a good interchange format?
14:54:19 <merijn> I've been writing network protocol parsers and give me an interchange format with a decent BNF any day...
14:54:20 <singularai> I wrote a json parser in parsec the other day and it worked great
14:54:26 <yyttr3> khumba: Yes, I have different Operating systems I want use, and I want the UI to look different for each. I'll take a look at that.
14:54:27 <singularai> despite being more complicated in some respects
14:54:42 <merijn> monochrom: I prefer simple custom formats over "one-size fits nothing"
14:54:49 <monochrom> I see
14:55:03 <yyttr3> khumba: The UI doesn't look very good on OS X by default either.
14:55:39 <merijn> monochrom: Writing parser for an unambiguous format takes like 30 mins, figuring out the different ways xml/json/csv/whatever parsing libraries are broken and designed takes way longer
14:55:42 <ski> singularai : Postel's law has drawbacks as well
14:56:08 <fdsdfsf> ski: So, how should the definition of memoizeByArray look like?
14:57:22 <ski> fdsdfsf : e.g. `memoizeByArray ix f = (arr !) where arr = listArray ix [f i | i <- range ix]'
14:57:27 <sie> Why might I install a package but not get it?
14:57:29 <sie> with cabal
14:57:38 <srhb> sie: Now "get" it?
14:57:41 <srhb> Not*
14:57:57 <srhb> sie: Need a bit more information than that. :)
14:58:21 <monochrom> what is "not get it"? does it mean "don't download"? if so, then where does the file come from?
14:58:32 <sie> cabal install sdl — works, but fails. cabal get sdl — doesn't work at all, because of "cabal: Package SDL-0.6.5 does not have any usable source repositories."
14:58:41 <ski> @let memoizeByArray :: Ix i => (i,i) -> (i -> a) -> (i -> a); memoizeByArray ix f = (arr !) where arr = array ix [(i,f i) | i <- range ix]
14:58:43 <lambdabot>  Defined.
14:58:49 <ski> fdsdfsf : that ^ is slightly more general
14:59:07 <monochrom> "cabal get sdl" works for me
14:59:59 <fdsdfsf> ski: but isn't there a way to define memoize such that it accepts a function and returns a memoized function back?
15:00:00 <srhb> sie: Works fine here, too.
15:00:41 <ski> @let fib n0 = memoizeByArray (0,n0) fibIt n0 where fibIt 0 = 0; fibIt 1 = 1; fibIt n = fibIt (n-1) + fibIt (n-2)
15:00:43 <lambdabot>  Defined.
15:00:49 <ski> > fib 1000000
15:00:53 <lambdabot>  mueval-core: Time limit exceeded
15:01:32 <ski> oh, i goofed it :)
15:01:41 <ski> @undefine fib
15:01:41 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
15:01:44 <ski> @undefine
15:01:44 <lambdabot> Undefined.
15:02:03 <merijn> Recursive definition of fib ಠ_ಠ
15:02:06 <silasm> Is there a neater way to "forever" a computation and get the results in a list than `sequence . repeat', or is that the standard way of doing it?
15:02:11 <ski> (i was first thinking of a slightly different version :)
15:02:29 <merijn> :t repeatM
15:02:30 <lambdabot>     Not in scope: ‘repeatM’
15:02:30 <lambdabot>     Perhaps you meant one of these:
15:02:30 <lambdabot>       ‘repeat’ (imported from Data.List),
15:02:44 <silasm> merijn: there's replicateM, but that's finite.
15:02:44 <merijn> silasm: Actually "sequence . repeat" doesn't work either
15:02:59 <ski> @let fib n0 = fibIt where fibIt = (memoizeByArray (0,n0) `flip` n0) $ \case 0 -> 0; 1 -> 1; n -> fibIt (n-1) + fibIt (n-2)
15:02:59 <lambdabot>  Parse failed: LambdaCase is not enabled
15:03:02 <merijn> silasm: It'll infinite loop and never return a list :)
15:03:02 <ski> bah
15:03:07 <merijn> silasm: You probably want
15:03:10 <merijn> @hackage monad-loops
15:03:11 <lambdabot> http://hackage.haskell.org/package/monad-loops
15:03:16 <ski> @let fib n0 = fibIt where fibIt = (memoizeByArray (0,n0) `flip` n0) $ \n -> case n of 0 -> 0; 1 -> 1; n -> fibIt (n-1) + fibIt (n-2)
15:03:17 <lambdabot>  .L.hs:158:13:
15:03:17 <lambdabot>      Occurs check: cannot construct the infinite type: c ~ a -> c
15:03:17 <lambdabot>      Relevant bindings include
15:03:17 <lambdabot>        fibIt :: a -> c (bound at .L.hs:157:9)
15:03:19 <lambdabot>        n0 :: a (bound at .L.hs:156:5)
15:03:24 <silasm> merijn: thanks, I'll take a look.
15:03:35 <pharpend> :t (.) . (.) . fmap . mapM . (.) . traverse . fmap . (.) . mapM_ . (<*>)
15:03:36 <lambdabot> (Traversable t, Applicative m, Applicative f1, Functor f, Monad m) => m (a4 -> b) -> (a -> a1 -> f [a2 -> t (f1 (a3 -> [m a4]))]) -> a -> a1 -> f (a2 -> [f1 (t (a3 -> m ()))])
15:04:15 <ski> @let fib n0 = fibIt n0 where fibIt = memoizeByArray (0,n0) $ \n -> case n of 0 -> 0; 1 -> 1; n -> fibIt (n-1) + fibIt (n-2)
15:04:16 <lambdabot>  Defined.
15:04:21 <ski> > fib 100000
15:04:25 <lambdabot>  mueval-core: Time limit exceeded
15:04:37 <ski> > fib 10000
15:04:39 <lambdabot>  3364476487643178326662161200510754331030214846068006390656476997468008144216...
15:04:56 <benmachine> I guess phi^100000 is just really large :P
15:05:05 <ski> @let naiveFib 0 = 0; naiveFib 1 = 1; naiveFib n = naiveFib (n-1) + naiveFib (n-2)
15:05:06 <lambdabot>  Defined.
15:05:11 <ski> > naiveFib 10000
15:05:14 <lambdabot>  mueval-core: Time limit exceeded
15:05:19 <ski> fdsdfsf : there you go
15:06:06 <ski> > let fib n0 = fibIt n0 where (memoizeByArray (0,n0) -> fibIt) = \n -> case n of 0 -> 0; 1 -> 1; n -> fibIt (n-1) + fibIt (n-2)  in fib 10000
15:06:08 <lambdabot>  3364476487643178326662161200510754331030214846068006390656476997468008144216...
15:06:31 <ski> ^ a slight variation, using the `ViewPatterns' syntactical extension to make it look slightly more pretty
15:07:21 <fdsdfsf> ski: I'll study it, thanks.  But let me repeat my previous question: isn't there a way to define memoize such that I can pass it a non-memoized function as an argument?
15:07:37 <fdsdfsf> ski: so I could write: memoize fib 10000 instead
15:07:45 <ski> fdsdfsf : each call to `fib' will create a new memoize version, with a memo table for inputs from `0' to `n0', and will then immediatelly call this new memoized function on `n0', which will then call itself recursively, reusing the memoized results it produces
15:07:54 <vanila> fdsdfsf, that's impossible without unsafe functions
15:08:01 <ski> fdsdfsf : if you had a fixed range, then you could define
15:08:02 <vanila> you can use the techniques ski showed to build something close to that
15:08:36 <vanila> if you defined fib "open" so that fix fib is the fibonacci funtion, you could also do memoizedFix fib
15:09:04 <ski> @let fibUpTo10000 = memoizeByArray (0,10000) $ \n -> case n of 0 -> 0; 1 -> 1; n -> fibUpTo10000 (n-1) + fibUpTo10000 (n-2)
15:09:05 <lambdabot>  Defined.
15:09:13 <ski> > fibUpTo10000 10000
15:09:13 <benmachine> I think it's basically impossible unsafe functions or not, you can't "reach into" fib and reassign the recursive calls
15:09:14 <lambdabot>  3364476487643178326662161200510754331030214846068006390656476997468008144216...
15:09:15 <ski> > fibUpTo10000 10001
15:09:16 <lambdabot>  *Exception: Ix{Integer}.index: Index (10001) out of range ((0,10000))
15:09:21 <ski> > fibUpTo10000 12
15:09:22 <lambdabot>  144
15:09:25 <ski> > fibUpTo10000 (-1)
15:09:26 <lambdabot>  *Exception: Ix{Integer}.index: Index (-1) out of range ((0,10000))
15:09:49 <burp> > let phi = (1 + sqrt 5)/2 in let psi = 1 - phi in let fib n = (phi^n - psi^n)/(phi-psi) in (fib 10000 :: CReal)
15:09:53 <lambdabot>  mueval-core: Time limit exceeded
15:09:54 <burp> :(
15:09:57 <benmachine> vanila is right, you need a way to hook into the recursion if you want to change how it works
15:09:59 <burp> yea, CReal is slow
15:10:24 <ski> fdsdfsf : sure, you can write something like `memoize fib 10000' .. but then that won't memoize the *recursive* calls that `fib' makes to itself, it will only check the memo table for the first call
15:10:25 <benmachine> burp: you can go much faster if you just define a type of pairs of rationals representing a + b sqrt 5
15:10:47 <ski> fdsdfsf : with my way, by "threading" in the memoization into the recursion, it will also check the memo table on each recursive call
15:10:55 <hpc> CReal also has termination issues with certain infinities
15:11:38 <ski> fdsdfsf : btw, if you prefer, you could make `memoizeByArray' just call the original function (and not remember the result), in case the input is outside the memoized range
15:12:01 <benmachine> burp: http://en.wikibooks.org/wiki/Algorithm_Implementation/Mathematics/Fibonacci_Number_Program#Closed-form_version
15:12:24 <burp> benmachine: oh, interesting
15:12:35 <ski> fdsdfsf : a variant of the above is to first define `fib' using `fix' instead of using explicit recursion, like `fib = fix $ \fib n -> case n of 0 -> 0; 1 -> 1; n -> fib (n - 1) + fib (n - 2)'
15:13:19 <ski> fdsdfsf : and then you replace `fib' with `memoFib (0,maxInput)', where you define `memoFib :: Ix i => (i,i) -> ((i -> e) -> (i -> e)) -> (i -> e)' in the obvious way
15:14:02 <ski> fdsdfsf : er, sorry, you replace *`fix'* by `memoFix (0,maxInput)'
15:14:06 <singularai> interesting to see that no one has recommended Data.MemoCombinators
15:14:29 <singularai> is that not very popular?
15:14:30 <fdsdfsf> ski: re memoize recursive calls: but why would you want to do that if you simply need to lookup the variable in the memotable?  (I'm a broken record, I know.)  Could you confirm that it can't be done in a safe way?
15:14:59 <fdsdfsf> singularai: monochrom recommended the memoize package yesterday, but I can't wrap my head around it.
15:15:00 <ski> fdsdfsf : if you don't memoize the recursive calls for `fib', then you gain nothing
15:15:00 <benmachine> singularai: it's more that we're discussion how memoisation can be implemented, rather than how to use existing implementations
15:15:22 <benmachine> *discussing
15:16:50 <fdsdfsf> ski: I'm okay with the first call to fib being slow, I only want the subsequent calls to be instant.
15:16:58 <singularai> fdsdfsf: I really prefer the package because there is a lot more complexity in tricking ghc to do your memoization correctly than in just using a package
15:17:15 <singularai> but trying to understand the more direct way is interesting as well
15:17:27 <merijn> If I have a small module containing a general purpose data structure in my package would it be preferable to simply split it off into it's own package?
15:17:38 <ski> fdsdfsf : yes, and that's why you need to also make the recursive calls call the *memoized* version, instead of calling the original version
15:17:51 <benmachine> merijn: if it's general purpose and you think other people might find it useful, sure, that might be cool
15:18:03 <ski> fdsdfsf : if you just do something like `memoize fib 10000', then the recursive calls will call `fib', not `memoize fib'
15:18:05 <benmachine> merijn: but don't feel pressured into creating extra bureaucracy for yourself :)
15:18:30 <merijn> burp: There's a simpler in between the naive recursive and closed form solutions too
15:18:30 <fdsdfsf> ski: let me show you the code I'm trying to mimic.
15:18:51 <merijn> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 100
15:18:52 <lambdabot>  354224848179261915075
15:19:34 <merijn> burp: That's essentially the "naive" for loop version that repeatedly sums two numbers :)
15:19:46 <ski> fdsdfsf : in Scheme, one could *mutate* the variable holding the original version, so that the recursive calls will automatically call the new memoized version -- you can't really do anything like this in Haskell, unless you indirect the recursive calls through mutable cells (which would then also require using something like `IO', `ST' or `STM')
15:20:04 <ski> (and that would look quite ugly)
15:20:30 <merijn> benmachine: Essentially just the umpteenth billion imlementation of channels :p
15:20:33 <burp> what would Haskell be without fibonacci and factorial ;-)
15:20:41 <ski> fdsdfsf : what merijn just showed is a more "smart" way of memoizing, for the particular case of `fib' (but it's harder to generalize)
15:21:11 <sinelaw> do records have setters? given this: data Record a = Record { field :: a }, is there a function that does \r x -> r { field = x }
15:21:17 <merijn> Int# is always unpacked, right?
15:21:22 <ski> fdsdfsf : in that case, instead of using an array as a memo table, an infinite list is used as the memo table
15:21:30 <merijn> sinelaw: Not really, sadly
15:21:35 <sinelaw> crap
15:21:46 <sinelaw> any particular reason?
15:21:48 <merijn> sinelaw: You probably wanna have a look at lenses :)
15:21:59 <sinelaw> yeah, i probably do :)
15:22:13 <merijn> sinelaw: Not really, you can probably write some TH code that generators setters for you without issue
15:22:24 <ski> (well .. `\r x -> r { field = x }' is a function that does `\r x -> r { field = x }' :)
15:22:38 <sinelaw> ski, you're disqualified
15:22:47 <ski> from what ?
15:22:54 <fdsdfsf> ski: here's the code which uses the memo table http://dpaste.com/1VVCYX6
15:23:05 <sinelaw> ;) never mind.
15:23:12 <merijn> btw
15:23:18 <fdsdfsf> ski: it doesn't match on the function name though
15:23:53 <merijn> How do I turn "State# s -> (#State# s, a#)" into "IO a"?
15:24:07 <augur> merijn: naughty!
15:24:12 <augur> what are you doing with that!?
15:24:34 <merijn> augur: Using primops
15:24:37 <augur> awful
15:24:59 <merijn> oh
15:25:01 <augur> @hoogle State# s -> (#State# s, a#)
15:25:02 <lambdabot> Parse error:
15:25:02 <lambdabot>   State# s -> (#State# s, a#)
15:25:02 <lambdabot>                             ^
15:25:05 <augur> :|
15:25:14 <merijn> I guess I should just import IO from GHC.Types
15:27:53 <merijn> oh, I not quite, I guess IO only accepts type of kind *
15:27:54 <merijn> bummer
15:28:18 <benmachine> merijn: woah what
15:28:23 <benmachine> merijn: are you planning some dark arts :P
15:28:45 <benmachine> or, do you mean types of boxed kind
15:29:06 * benmachine was worried we were talking about "IO Maybe" or "IO Eq" or something
15:29:22 <benmachine> or nowadays "IO Just"
15:29:28 <merijn> Yeah, it doesn't allow you to return unboxed types
15:29:36 <benmachine> fair enough
15:30:35 <fdsdfsf> ski: could you show the way of doing it via ST (just for fun)?
15:30:45 <phaazon> http://lpaste.net/2940271612261302272
15:30:46 <augur> merijn: whats the kind for unboxed types?
15:30:47 <augur> #*?
15:30:54 <phaazon> I got a weird error in that lpaste
15:30:56 <merijn> Although I have no idea how I'm supposed to pattern match the unboxed tuple returned by a state
15:30:59 <merijn> augur: #
15:31:00 <Iceland_jack> Just #
15:31:04 <phaazon> I _have_ defined the instance for LightProperties
15:31:05 <augur> ahh
15:31:13 <phaazon> but (see below) ghc thinks I haven’t
15:31:45 <phaazon> any idea?
15:32:24 <merijn> I'm a bit lost how I'm supposed to turn "(#State# s, Foo# #)" into "(#State# s, MyWrapper #)"
15:33:13 * ski pasted "memoizing `fib'" at <http://paste.lisp.org/display/143720>
15:33:15 <ski> fdsdfsf ^
15:34:32 <phaazon> no one?
15:34:37 <ski> fdsdfsf : if it had matched on the function name, then it could possibly have auto-memoized the recursive calls. another way to do this would be to make a macro that you can call like `(memoize! fib)', and which you expand to something like `(set! fib (lambda ...))'
15:34:40 <fdsdfsf> ski: yes, I got it.
15:34:45 <phaazon> maybe it’s because of TH with makeLenses?
15:35:06 <merijn> Anyone know how to work with unboxed tuples?
15:35:22 <fdsdfsf> ski: I'm not very interested in doing it in scheme, but I'd be very interested to see a haskell solution using st.
15:36:02 <Fuuzetsu> phaazon: try moving makeLenses to the bottom
15:36:20 <Fuuzetsu> I find that I have weird-ass scoping problems with makeLenses
15:41:14 <merijn> benmachine: Whoo! Dark arts: IO (\s -> let (# s', x #) = newByteArray# 1# s in (# s', Array x #))
15:41:32 <benmachine> merijn: eek
15:41:48 <Fuuzetsu> # = gotta go fast
15:41:59 <merijn> Fuuzetsu: :)
15:42:13 <fdsdfsf> is there a way to trigger haskell's gc on demand?
15:42:17 <merijn> Fuuzetsu: Well, in this case it's # = I really want atomic increment :)
15:42:20 <fdsdfsf> ghc's*
15:42:28 <merijn> *cheap* atomic increment
15:42:33 <Fuuzetsu> fdsdfsf: yes
15:42:36 <Fuuzetsu> but I forget the function
15:42:56 <merijn> benmachine: There's lots of fun in GHC.Prim :p
15:43:24 <benmachine> fdsdfsf: http://hackage.haskell.org/package/base-4.7.0.1/docs/System-Mem.html
15:43:39 <sie> I can't install sdl
15:43:43 <fdsdfsf> benmachine: thank you!
15:43:59 <sie> http://sprunge.us/ObdE
15:44:31 <mm_freak> hi there
15:44:37 <fdsdfsf> benmachine: aware of the difference between minor and major?
15:44:37 <Fuuzetsu> yahho~
15:44:52 <merijn> hey mm_freak :)
15:45:00 <benmachine> fdsdfsf: major is more major than minor, which is minorer
15:45:02 <benmachine> fdsdfsf: (i.e. no)
15:45:06 <fdsdfsf> haha
15:45:10 <merijn> mm_freak: Is there any docs on the changes from netwire 4 to 5 somewhere yet?
15:45:17 <benmachine> sorry, don't know much about the workings of Haskell's GC
15:45:20 <mm_freak> does anyone know how efficient jmacro's Monoid instances are?  in particular, should i try to maintain a certain association direction?
15:45:23 <benmachine> nor where to find out more
15:45:26 <mm_freak> merijn: hi there =)
15:45:51 <fdsdfsf> benmachine: I bet #ghc people know, I'll try asking there.
15:45:58 <mm_freak> merijn: sorry, i don't really have much time to work on netwire/wires right now…  i need to get a few other projects done faaaast
15:46:00 <benmachine> perhaps
15:46:12 <merijn> mm_freak: Don't worry, I know the feeling :)
15:46:15 <benmachine> oh, yes, I should have said GHC's GC, "Haskell's GC" is not a thing
15:46:16 <vanila> fdsdfsf, are you writing a compiler?
15:46:34 <fdsdfsf> vanila: nope, should I?
15:46:39 <benmachine> sure, why not
15:46:42 <benmachine> something to do with your evenings
15:46:47 <mm_freak> one of them is basically a reinvention of yesod's widgets, hence my question =)
15:46:49 <rodlogic> :r
15:46:53 <merijn> mm_freak: I don't have an immediate need, since I need to finish some of my own stuff first anyway. But I planned to get back to FRP and it seems netwire 5's model is a lot closer to what I need than 4 :)
15:47:00 <fdsdfsf> benmachine: mine are pretty busy already :)
15:47:13 <vanila> fdsdfsf, I was j ust wondering because of the CPS stuff
15:47:21 <merijn> mm_freak: So I just wanted to save time by not reading all the docs in detail if not necessary :)
15:47:53 <fdsdfsf> vanila: no no, I'm just learning unfamiliar things, that's all.
15:48:17 <vanila> why? :)
15:48:21 <vanila> you dont have to answer
15:48:24 <vanila> just curious
15:48:26 <mm_freak> merijn: i would hope so, since netwire 5 is pretty much traditional FRP, except that you switch by combining intervals…  in fact in 'wires' even inhibition is gone
15:48:42 <merijn> Yeah, I noticed :)
15:48:45 <merijn> \o/
15:49:17 <fdsdfsf> vanila: to understand what I'm doing, not just typing a bunch of symbols on a keyboard.
15:49:24 <vanila> ok! good idea
15:52:07 <phaazon> 00:34 < Fuuzetsu> I find that I have weird-ass scoping problems with makeLenses
15:52:09 <phaazon> same issue
15:53:47 <merijn> ok, "naming things" poll: "BroadcastChan" vs "BChan"?
15:54:05 <phaazon> BroadcastChan
15:54:10 <phaazon> BChan is not clear at all
15:54:19 <merijn> With the former function names become so long "writeBroadcastChan", but the latter can be confused with BoundedChan
15:55:07 <fdsdfsf> merijn: I'd go with BChan assuming the module is documented well.
15:59:22 <Fuuzetsu> merijn: BC
15:59:58 <sie> http://sprunge.us/ObdE
16:00:07 <sie> wups, sorry, didn't want to repost that
16:00:21 <merijn> Easy solution Henning names! :p
16:02:26 <merijn> Fuuzetsu: hmm, I think I'll just use BroadcastChan as type, but name the functions "readChan", etc.
16:13:02 <legittalon> what does one who writes Haskell call themselves?
16:14:14 <benzrf> legittalon: a haskeller!
16:15:37 <Hodapp> Hmmmm. I wonder how I might transform one (infinitely recursive) tree of one type into one of another type, without that conversion having to take place repeatedly upon actually walking the tree.
16:15:56 <benzrf> Hodapp: good luck ;)
16:16:05 <legittalon> That was my intuition but I wasn't quite sure.
16:16:12 <merijn> "programmer"? >.>
16:16:13 <benzrf> Hodapp: can u give example
16:16:20 <Hodapp> benzrf: It would seem easier to just write the tree in the correct type in the first place.
16:16:29 <startling> legittalon: they don't, they use fix instead?
16:16:44 <benzrf> startling: what, not how
16:16:45 <benzrf> :P
16:16:55 <benzrf> > fix me
16:16:57 <lambdabot>  Not in scope: ‘me’
16:16:57 <lambdabot>  Perhaps you meant one of these:
16:16:57 <lambdabot>    ‘m’ (imported from Debug.SimpleReflect),
16:16:57 <lambdabot>    ‘e’ (imported from Debug.SimpleReflect),
16:16:57 <lambdabot>    ‘re’ (imported from Control.Lens)
16:17:14 <benzrf> > fix me
16:17:15 <lambdabot>  You're beyond help
16:17:26 <benzrf> ( ͡° ͜ʖ ͡°)
16:17:38 <legittalon> How many of you when starting out did Prelude> [1..], cause I did just now.
16:17:46 <benzrf> all of u s
16:17:51 <legittalon> figured.
16:18:01 <mitchty> well so i figured out the issue with homebrew ghc+cabal
16:18:11 <mitchty> wasn't ghc at all (well not entirely)
16:18:39 <merijn> Homebrew is not a good way to instal GHC, the formula's are poorly maintained
16:19:03 <mitchty> so i have a tap now of things that installs ghc and cabal
16:19:33 <mitchty> just needed to update ghc-pkg rts and add the gmp lib path to library-dirs and bootstrap cabal that way
16:20:03 <mitchty> merijn: so it would appear, but i got it working, well i hacked it to seemingly work, need to test more
16:20:51 <merijn> mitchty: Why not just install the haskell platform?
16:21:11 <merijn> It's the recommended way of installing GHC and friends on OSX
16:21:18 <mitchty> merijn: i don't like that that puts stuff in ~/Library on osx, like it to be more like other unixen
16:21:30 <mitchty> but i'm slowly getting to the point of not caring :)
16:22:01 <merijn> You could also just manually instal the GHC binary if you want control over location
16:22:14 <merijn> The one just uses configure + --prefix
16:22:24 <mitchty> well its more avoiding installing osx packages to be honest
16:23:11 <mitchty> they aren't hard to automate but just having stuff in /usr/local/bin seems san(er) to me than /Applications/blah
16:23:57 <merijn> Haskell Platform creates symlinks in /usr/bin for ghc, cabal, etc.
16:25:49 <mitchty> so this is more to just try out how well it works, i'm automating my osx setups with vagrant/packer/ansible, so this may/may not survive
16:27:00 <doismellburning> mitchty: I do that (except s/ansible/Puppet/)
16:27:44 <mitchty> doismellburning: nice, anything public perchance? I have to support puppet stuff at work, but for my home stuff i prefer ansible
16:28:08 <doismellburning> mitchty: nope but https://github.com/alphagov/gds-boxen is awesome
16:29:29 <mitchty> doismellburning: i'll have a look, this projects kinda low priority as its mostly personal, and this is the first time i've tried automating osx installs
16:30:05 <mitchty> its kinda hokey atm as i use homebrew to install ansible then bootstrap from there
16:30:19 <doismellburning> mitchty: the GitHub team did this some time ago ;)
16:30:25 <doismellburning> anyway sorry this is a bit OT for #haskell
16:31:04 <mitchty> true enough, i'll see if i can't get homebrew ghc/cabal with fixes so it works on 10.9/10 sanely
16:40:25 <fresheyeball> anyone out there?
16:41:16 <bmuk> I'm here
16:41:49 <fresheyeball> just curious
16:42:41 <erikd> fresheyeball: this channel is usually very active.
16:46:44 <stepkut> I want to have an array-like-thing of 10 boolean values and I need to be able to mutate the value at different indexes fairly often. How do I decide between vector and one of the many array types?
16:47:19 <dnkndnts> mutate?
16:47:42 <stepkut> to a degree
16:48:14 <stepkut> I am going to have "StateT MyThing m a", and I want to modified MyThing
16:48:26 <erikd> stepcut: if its only 10 values, IntMap might be a good choice. when you update you get a new map.
16:48:27 <stepkut> so, a List would not be great
16:48:53 <stepkut> yeah IntMap was another choice.. though the integers will be sequential
16:49:58 <merijn> stepkut: IntMap will be the cheapest non-IO approach
16:50:12 <stepkut> k
16:50:31 <stepkut> really, I want an Idris vector so that I can ensure there are exactly 10 sequential elements :p
16:50:41 <merijn> Well, maybe an ST array approach will be slightly cheaper, but that still involves a monadic hassle
16:50:55 <dnkndnts> well there's this https://hackage.haskell.org/package/vector
16:51:15 <stepkut> dnkndnts: indeed, that was what I meant by 'vector' vs 'array'
16:51:40 <merijn> stepkut: The problem is with positional updates is that you either need IO or copy the entire array every update
16:52:14 <stepkut> merijn: yup... IO would actually be ok
16:52:16 <merijn> stepkut: IntMap will only copy less than O(log n) every update
16:52:48 <merijn> stepkut: It really depends on the rest of the code how annoying IO will be, if it fits easily than some mutable vector will probably perform best
16:53:00 <dnkndnts> i mean if you're worried about the copy overhead of 10 integers, i mean on a modern processor that's... nothing. if 10 int copies is considered a performance bottleneck, you might need a systems language implementation.
16:53:35 <stepkut> I have a real system that actually turns real lights on and off (which is an IO operation) and I am just writing an opengl simulator now so I can develop new code when I am not hooked up to the real hardware. But, that still involves IO
16:53:52 <stepkut> in the real system the hardware knows if the lights are on or off, but in the simulator, I need to keep track of that
16:54:37 <stepkut> but, assuming I am ok with using IO, I still am not clear if I should use an IOVector or an IOArray
16:54:52 <kadoban> I'd probably just do the vector thing or whatever interface doesn't suck. I doubt you really need IO for that?
16:55:10 <stepkut> is vector supposed to be an replacement for the old array stuff? Or does it serve a different purpose?
16:55:57 <johnw> stepkut: that's what I've come to understand
16:55:57 <kadoban> Different purposes I think, stepkut. There's like a billion array/vector implementations with various specific use-cases it seems.
16:56:50 <merijn> dnkndnts: It depends on what you're doing
16:57:09 <merijn> dnkndnts: When working in tight inner loops, copying 10 int's is a disaster
16:58:12 <merijn> stepkut: Use whichever API seems easier :)
16:58:27 <merijn> hmm
16:58:43 <merijn> Is it "spaceleak", "space leak" or "space-leak"?
16:59:02 <dnkndnts> merijn: i'm fairly new to haskell, so maybe there are patterns i don't know about, but my understanding is haskell is more about correctness than performance (especially if you're defining a 10-int copy as a performance issue)
16:59:03 <johnw> i would think the 2nd
16:59:27 <johnw> appositive nouns do not necessarily need to be either conjoined or hyphenated, though in some cases they are traditionally
16:59:48 <doismellburning> merijn: imo/ime "space leak"
17:01:03 <stepkut> I'm going with Data.Vector.Mutable.. because I've never used it before :)
17:02:21 <merijn> dnkndnts: There are most certainly people doing high performance stuff in haskell, so saying "haskell is more about correctness than performance" is a bit of a naive view
17:04:10 <merijn> dnkndnts: There's a significant number of libraries which can get close to/beat performance of handwritten C code, but with a much higher level API (for example, the attoparsec/binary parsing libraries) and I think conduit is working on some things for data analysis where they got the inner conduit-loop down to several nanoseconds
17:04:13 <catalist> I have this issue with the Haskell interpreter in emacs. The one in Haskell mode that uses the lambda sign. It first asks to create a new cabal project but I keep messing up somewhere. Anyone know the right procedure I can follow for this?
17:06:12 <catalist_> Did I get an answer? My connection got interrupted.
17:06:31 <merijn> Obviously correctness is more important than performance (if you don't care about correctness I can give you infinite speedup for your code...), but that doesn't mean there's no point to worrying about performance :)
17:06:44 <catalist_> Error in process filter: cannot load file: ghc
17:10:51 <ski> @tell fdsdfsf well, i started writing one using `STArray', but i realized i never wrote to the array, meaning i could just have used `Array' instead .. so if you want a version using `STArray', do you want one of type `STArray s i (Maybe a)' where cells are initialized by `Nothing' and filled with `Just a' as soon as the computation for input `i' yields `a' ?
17:10:51 <lambdabot> Consider it noted.
17:10:58 <ski> @tell fdsdfsf or perhaps you wanted some kind of `STMap s i a' used, which would correspond more closely to your Scheme version at <http://dpaste.com/1VVCYX6> ?
17:10:59 <lambdabot> Consider it noted.
17:12:08 <catalist_> Someone please send me a link on how to create a new cabal project especially in emacs
17:12:50 <merijn> catalist_: run "cabal init" in your shell?
17:12:52 <bmuk`> catalist_: cabal init creates a cabal file for you if that's what you're asking
17:12:52 <Fuuzetsu> type in ‘cabal init’ in your terminal, in the project directory and follow the instructions
17:13:03 <kadoban> Did anyone mention 'cabal init'?
17:13:05 <kadoban> :)
17:13:06 <bmuk`> haha
17:14:13 <merijn> hmmm, what's the correct way to credit code lifted from "base"?
17:15:09 <Fuuzetsu> merijn: I don't think BSD3 requires you to credit it in such a way
17:18:28 <merijn> Fuuzetsu: Sure it does
17:19:01 <merijn> Fuuzetsu: BSD3 requires you to retain the copyright notice of the original authors
17:19:05 <Fuuzetsu> yeah
17:19:13 <merijn> Except I don't think base has a clear list of authors
17:19:15 <Fuuzetsu> well, it depends how much you took I suppose
17:19:29 <Fuuzetsu> you can't really copyright 5 lines
17:19:37 <sie> I disconnected, was my question about monadplus and [] seen?
17:19:56 <dibblego> no
17:19:57 <Fuuzetsu> sie: I do not see it
17:20:02 <merijn> Fuuzetsu: copy+paste Control.Concurrent.Chan and hack it up, it's not that much code and I don't think anyone cares, but I just feel like I should "do the right thing"
17:20:43 <Fuuzetsu> merijn: right, doing the right thing is good; if there's a copyright header then preserve that, if not then I'd just state in your own header somewhere where you got the code from and what license it was under
17:20:44 <merijn> I guess I can just poll libraries@ and see what people think
17:20:45 <sie> Does : "MonadPlus m => [a] -> m a" already exist?
17:20:58 <Fuuzetsu> @hoogle MonadPlus m => [a] -> m a
17:21:01 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
17:21:01 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
17:21:01 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
17:21:01 <merijn> Fuuzetsu: I'm keeping the result BSD3 anyway
17:21:30 <Fuuzetsu> :t msum . fmap return
17:21:31 <lambdabot> MonadPlus m => [a] -> m a
17:21:34 <Fuuzetsu> it does now
17:21:49 <shachaf> @hoogle is so much spam. It should return at most one result in-channel.
17:22:02 <Fuuzetsu> shachaf: I wouldn't have seen msum if that was the case!
17:22:09 <Fuuzetsu> 3 lines is fair game I think
17:22:34 <sie> I came up with something longer, thanks.
17:22:51 <shachaf> Fuuzetsu: So you could've used /msg lambdabot or the website.
17:23:05 <Fuuzetsu> I could have and I probably should have, noted.
17:23:19 <catalist> So I created a new project with cabal init but emacs interpreter still asks to create a new project
17:23:30 <catalist> What might I be doing wrong?
17:23:47 <Fuuzetsu> catalist: you're not telling us what you're using in emacs to deal with Haskell is the first thing you're doing wrong
17:24:24 <catalist> Haskell mode
17:24:43 <Fuuzetsu> I use haskell-mode and it does not ask my anything about projects
17:24:43 <catalist> Ghc-mod
17:24:55 <Fuuzetsu> ghc-mod seems like the more likely culprit
17:25:26 <catalist> Fuuzetsu does your interpreter have a lambda?
17:25:27 <Fuuzetsu> maybe you can ‘M-x cd’ to your project's directory and try to load the file then.
17:25:57 <Fuuzetsu> No, I use the stock prompt due to some old reasons of haskell-mode not liking it + I like to see where I am
17:26:20 <Fuuzetsu> but if you're talking about the λ prompt then IIRC there's some haskell-mode command which drops you into that
17:26:27 <Fuuzetsu> I think the fix is the same, M-x cd to top level
17:27:11 <catalist> Yes I'm talking about that prompt
17:28:58 <ski> @let listToMonadPlus :: MonadPlus m => [a] -> m a; listToMonadPlus = foldr (mplus . return) mzero
17:29:01 <lambdabot>  Defined.
17:29:12 <ski> sie : ^ that's a variant way
17:29:15 * hackagebot ssv 0.3 - Comma-separated-value (CSV) read, show and write routines  http://hackage.haskell.org/package/ssv-0.3 (BartonMassey)
17:34:35 <Fuuzetsu> holy crap, sometimes I think ‘type’ should be illegal
17:35:07 <merijn> Fuuzetsu: How so?
17:36:12 <Fuuzetsu> it's just that I have code here where type EventString = String but I now need it to be Text but hey I need Binary instance so I might as well newtype it because I need Binary instance. Now I have code where some things used EventString and others used String and it all breaks now
17:36:20 <Fuuzetsu> it breaks in all the wrong places
17:36:52 <Fuuzetsu> (this isn't a serious proposal, just frustrated)
17:37:16 <merijn> Ah, yeah
17:37:27 <merijn> I always preemptively newtype for that sorta thing
17:38:14 <Fuuzetsu> problem is that such a small change breaks like 50 modules ;/
17:42:05 <ski> Fuuzetsu,merijn : something like the "Restricted type synonyms" of Hugs <https://web.archive.org/web/20130126164552/http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#sect7.3.5> could possibly be useful in such situations
17:42:33 <Fuuzetsu> the fact that you're pulling this out of the web archive saddens me
17:43:50 <ski> i don't know why it disappeared from <https://cvs.haskell.org/Hugs/pages/hugsman/exts.html#sect7.3.5> .. last time i looked, the Hugs docs was still available from <https://www.haskell.org/hugs/>
17:44:10 * hackagebot xml-push 0.0.0.5 - Push XML from/to client to/from server over XMPP or HTTP  http://hackage.haskell.org/package/xml-push-0.0.0.5 (YoshikuniJujo)
17:44:12 * hackagebot tickle 0.0.1 - A port of @Data.Binary@  http://hackage.haskell.org/package/tickle-0.0.1 (TonyMorris)
17:44:22 <Fuuzetsu> ski: that's pretty cool
17:44:42 <Fuuzetsu> ski: there's a question about what happened to Hugs on the mailing list, if you know something you might want to chime in
17:45:01 <merijn> Isn't it simply that it just bit-rotted?
17:45:03 <Fuuzetsu> is there a Trac ticket asking for this?
17:45:21 <ski> Fuuzetsu : this is quite similar to the feature of the ML module system in which you can export a type synonym abstractly, so that it externally appears like it could have been a data type e.g.
17:45:37 <Fuuzetsu> that would probably help if I learned ML
17:45:57 <ski> you should definitely look into the ML module system, if you haven't
17:46:06 <Fuuzetsu> is it like Agda's?
17:46:31 <ski> @where on-functors
17:46:31 <lambdabot> "On Functors" (in C++,Standard ML,Haskell,Prolog) by Peteris Krumins in 2010-05-17 at <http://www.catonmat.net/blog/on-functors/>
17:46:41 <ski> has a very brief description on it
17:47:17 <ski> Fuuzetsu : well, you can parameterize modules by modules. but you also declare module interfaces ("signatures") explicitly
17:47:37 <merijn> backpack is an ok comparison
17:48:30 <ski> yeah, reminds me i should checkout "Backpack: Retrofitting Haskell with a Module System, at last" <http://lambda-the-ultimate.org/node/4868>
17:49:11 * hackagebot broadcast-chan 0.1.0 - Broadcast channel type that avoids 0 reader space leaks.  http://hackage.haskell.org/package/broadcast-chan-0.1.0 (MerijnVerstraaten)
17:49:16 <ski> (both SML and OCaml (and Alice ML) has the ML module system. however F# doesn't (shame !))
17:49:49 <Fuuzetsu> that's pretty cool
17:52:24 <platz> kind of sad the "functor" has so many different definitions
17:52:45 <platz> I like it when things have more identifiable meaning
17:53:01 <platz> the word, that is
17:53:18 <ski> i think the one in Prolog comes from some literature on first-order predicate logic
17:53:21 <merijn> What are the arrows in the ML functors?
17:54:24 <ski> merijn : afaik, "functor" there wasn't intended in the sense of CT :)
17:55:13 <platz> ngram viewer "functor": https://books.google.com/ngrams/graph?content=functor&year_start=1800&year_end=2000&corpus=15&smoothing=3&share=&direct_url=t1%3B%2Cfunctor%3B%2Cc0
17:55:54 <platz> if CT began in the '40s then it looks like it coincides with that
17:56:01 <platz> so at least we know who was there first ;)
18:04:54 <sgronblo> is liftM the same as fmap?
18:05:45 <bmuk`> :t liftM
18:05:46 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
18:05:51 <bmuk`> :t fmap
18:05:52 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:05:52 <trap_exit> is RWH worth reading after reading LYAH ?
18:06:20 <bmuk`> trap_exit: I believe so (though I haven't had the patience to finish either)
18:06:33 <doismellburning> trap_exit: I found it to be worthwhile
18:06:47 <trap_exit> doismellburning: what did you learn from RWH after reading LYAH ?
18:06:55 <doismellburning> trap_exit: I don't remember now
18:07:03 <trap_exit> must have been very important
18:07:07 <trap_exit> and changed the way you write haskell :-)
18:07:18 <doismellburning> trap_exit: but I definitely remember the real-world examples being good
18:07:22 <ski> sgronblo : yes, it is (should be) the same, for any monad
18:07:48 <ski> (if it isn't, for some monad, then that's a bug)
18:07:55 <bmuk`> ski: but liftM won't take a functor that doesn't have a monad instance
18:07:56 <doismellburning> trap_exit: can't tell if you're trolling or not, if yes I'm uninterested, if no, there are plenty of things that I don't remember in astounding detail that were still important
18:08:11 <trap_exit> doismellburning: I'm serious
18:08:14 <ski> bmuk` : "..., for any monad"
18:08:18 <trap_exit> the time inestment of working rhoguth a book is non-trivial
18:08:35 <trap_exit> so I'm lookng at RWH and wondering: "how will this make me better at haskell"
18:08:56 <bmuk`> ski: I know, but I don't think sgronblo specified Monad
18:09:01 <doismellburning> I couldn't sit here and give you concrete examples of what I got from three years of a computer science degree; I still found it important and to have changed the way I did a bunch of stuff
18:09:03 <Hijiri> I just picked out and read the parts that I thought weren't covered
18:09:12 * hackagebot accelerate 0.15.0.0 - An embedded language for accelerated array processing  http://hackage.haskell.org/package/accelerate-0.15.0.0 (TrevorMcDonell)
18:09:19 <trap_exit> really
18:09:25 <trap_exit> you couldn't talk about big-Oh running time
18:09:31 <trap_exit> principles of compilers / OS ?
18:09:37 <ski> bmuk` : `liftM' specified `Monad'
18:10:13 <doismellburning> I could, yes; would I consider them good indicators of quality time spent? less so
18:10:21 <bmuk`> ski: that's true. I guess I read the question as how are they different
18:10:43 <trap_exit> alright
18:10:50 <trap_exit> anyeone else have a good reason to read RWH after reading LYAH ?
18:11:15 <bmuk`> trap_exit: I found that the exercises were more involved
18:11:47 <Welkin> RWH covers practical usage examples
18:11:49 <dmj`> trap_exit: have you read the typeclassopedia?
18:11:52 <Welkin> I've only skimmed i
18:11:54 <Welkin> it*
18:11:57 <trap_exit> dmj`: not yet
18:12:00 <Welkin> the typeclassopedia is great
18:12:12 <dmj`> trap_exit: do that first, that is the *best* resource for haskell IMO
18:12:22 <bmuk`> Typeclassopedia changed how I thought about haskell tbh
18:12:30 <Welkin> I like that RWH has chapters on things like Networking
18:12:35 <dmj`> that and sdiehl's 'things I wish I knew' series
18:12:44 <doismellburning> Welkin: ooh, yes
18:12:47 <trap_exit> Someone in the #haskell IRC channel used (***), and when I asked Lambdabot to tell me its type, it printed out scary gobbledygook that didn’t even fit on one line! Then someone used fmap fmap fmap and my brain exploded.
18:12:57 <Welkin> :t (***)
18:12:58 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
18:12:59 <trap_exit> When I asked how to do something I thought was really complicated, people started typing things like zip.ap fmap.(id &&& wtf) and the scary thing is that they worked!
18:13:02 <doismellburning> ah arrows
18:13:06 <MP2E> Typeclassopedia ftw
18:13:10 <trap_exit> yep, this makes typeclassopedia worth reading :-)
18:13:13 <dmj`> trap_exit: typeclassopedia + marlow's book
18:13:28 <trap_exit> djm`: parallel _+ concurrent haskell? that book is hard
18:13:28 <dmj`> the typeclassopedia changed my life, in so many way, on so many levels
18:13:32 <bmuk`> dmj`: which book did marlow write?
18:13:46 <doismellburning> dmj`: interesting
18:13:54 <dmj`> bmuk`: http://chimera.labs.oreilly.com/books/1230000000929
18:13:58 <Welkin> parallel and concurrent haskell
18:14:12 <doismellburning> heh I actually started with ParConc, then went to LYAH to fill in gaps, then RWH
18:14:13 * hackagebot accelerate-cuda 0.15.0.0 - Accelerate backend for NVIDIA GPUs  http://hackage.haskell.org/package/accelerate-cuda-0.15.0.0 (TrevorMcDonell)
18:14:14 * hackagebot accelerate-io 0.15.0.0 - Read and write Accelerate arrays in various formats  http://hackage.haskell.org/package/accelerate-io-0.15.0.0 (TrevorMcDonell)
18:14:15 <bmuk`> ah, I haven't read it yet
18:14:27 <ski> bmuk` : fair enough
18:14:52 <dmj`> the typeclassopedia is like the "greatest hits" of haskell, and accurately describes the learning process and trajectory of haskell knowledge ascencion
18:14:59 <bmuk`> :k Arrow
18:15:00 <lambdabot> (* -> * -> *) -> Constraint
18:15:17 <MP2E> haha, great description. Points for making me imagine a haskell band :P
18:16:15 <platz> parconc is good yes - it might be worth starting with the "conc" instead of the "par" if looking for the best bang for buck
18:16:48 <dmj`> platz: agreed, I skipped the par part entirely, and the gpu stuff, cloud haskell stuff looks cool
18:16:51 <platz> but the par stuff really changed my perceptions about what parallelism can accomplish
18:16:59 <platz> so it's still nice to investigate
18:17:00 <doismellburning> platz: agreed
18:17:06 <bmuk`> So this http://www.willamette.edu/~fruehr/haskell/evolution.html is haskell's psychadelic album?
18:17:33 <doismellburning> that was my main interest tbh; I wanted to clone logstash (JRuby log aggregator thing) in Haskell
18:17:54 <doismellburning> bmuk`: I think Prelude.PHP is Haskell's psych album...
18:18:26 <dmj`> trap_exit: one downfall of RWH is that it doesn't cover iteratees, I don't think any book on haskell currently does, maybe that new apress one does
18:18:34 <doismellburning> dmj`: iteratees?
18:18:42 <trap_exit> that sounds imperative
18:18:57 <doismellburning> ooh that looks fun
18:19:05 <bmuk`> doismellburning: what on earth
18:19:13 * hackagebot accelerate-fft 0.15.0.0 - FFT using the Accelerate library  http://hackage.haskell.org/package/accelerate-fft-0.15.0.0 (TrevorMcDonell)
18:19:15 * hackagebot gloss-accelerate 1.8.15.0 - Extras to interface Gloss and Accelerate  http://hackage.haskell.org/package/gloss-accelerate-1.8.15.0 (TrevorMcDonell)
18:19:17 * hackagebot gloss-raster-accelerate 1.8.15.0 - Parallel rendering of raster images using Accelerate  http://hackage.haskell.org/package/gloss-raster-accelerate-1.8.15.0 (TrevorMcDonell)
18:19:19 * hackagebot accelerate-examples 0.15.0.0 - Examples using the Accelerate library  http://hackage.haskell.org/package/accelerate-examples-0.15.0.0 (TrevorMcDonell)
18:19:33 <bmuk`> this looks like it has nothing to do with php? http://hackage.haskell.org/package/acme-php-0.0.2/docs/Prelude-PHP.html
18:19:46 <dmj`> yea they get around the issue of lazy I/O. Which can cause leaked file descriptors. Introduces deterministic resource handling
18:20:04 <platz> the apress book looks into conduit instead of iteratees
18:21:08 <merijn> bmuk`: Define "nothing" :)
18:21:18 <merijn> bmuk`: All acme packages are for jokes :)
18:21:20 <Hijiri> I guess it simulates php's casting of strings to numbers?
18:21:30 <doismellburning> yeah it's got `instance Foo String` for many Foos
18:21:36 <merijn> bmuk`: Did you read the description + source?
18:21:40 <doismellburning> and other such fun
18:22:28 <bmuk`> merijn: I just opened the source now, lol. I was just going by function names and types and I wasn't sure what was so strange about it
18:22:39 <doismellburning> https://hackage.haskell.org/package/acme-pointful-numbers-0.1.2.4/docs/Acme-Pointful.html
18:22:43 <doismellburning> *jawdrop*
18:25:09 <Welkin> it simulates php as something more than a bad nightmare
18:25:41 <kadoban> Hah, these acme packages are pretty hilarious, that'll be fun to read when I'm bored
18:28:29 <Fuuzetsu> maybe I should read the typeclassopedia
18:28:40 <Welkin> yes, you should
18:28:49 <Welkin> take your time and read it closely
18:28:54 <Welkin> do the exercises too
18:29:28 <dmj`> Fuuzetsu: first time I read through it this is what happened: http://bit.ly/1gUaCfd
18:30:19 <Fuuzetsu> what if you hyped it up now and I'm disappointed?
18:30:21 <dmj`> Fuuzetsu: it takes forever because there are so many links, so much rereading
18:30:43 <Welkin> Fuuzetsu: you won't be
18:30:50 <Fuuzetsu> is there a money-back guarantee?
18:31:27 <bmuk`> I think the exercises should include more information. I had trouble doing them because I didn't have access to a computer and it didn't supply the types for some things. I.e. Implement Functor instances for Either e and ((->) e). What is the type of Either e? ((->) e)?
18:31:33 <Welkin> you cannot put a price on information
18:31:51 <Fuuzetsu> hm, maybe I should make Yi unable to insert hard tabs in Haskell modes, perhaps all these ‘why doesn't this compile’ questions would reduce in volume ;P
18:31:51 <dmj`> Fuuzetsu: it meets and exceeds the hype, No money down, no money back :P
18:32:12 <benzrf> bmuk`: Either e does not have a type
18:32:16 <benzrf> it IS a type
18:32:31 <Welkin> benzrf: I thought you were gone
18:32:38 <benzrf> i netsplit
18:32:41 <benzrf> but then i reconnected
18:32:48 <Welkin> gb2school
18:32:53 <bmuk`> you're right. I meant I didn't know what they were, so I couldn't be sure what fmap should do
18:32:55 <benzrf> and this time i got routed to a nonsplit server
18:32:56 <benzrf> B)
18:38:02 <bmuk`> I'm reading the section above it and it does give you information on the instances, I must have been confused. I think what I'm referring to is that it asks you to write instance Functor Either without telling you about Left and Right.
18:39:39 <dmj`> bmuk`: might be best to start with LYAH and then go to typeclassopedia.
18:40:14 <Welkin> I second that
18:40:15 <bmuk`> I have read both, but I agree
18:41:24 <dmj`> bmuk`: there's no way you read LYAH and don't know the definition of Either. Are you just reading or actually writing out *everything* in ghci
18:41:41 <dmj`> bmuk`: sorry if that comes across harsh
18:41:58 <bmuk`> I read LYAH after I had trouble with that
18:42:07 <bmuk`> this was some time ago
18:43:10 <bmuk`> you're fine, I understand where you are coming from. I should have made that more clear.
18:47:33 <Hijiri> can you put constraints on the type parameters to a type constructor?
18:48:21 <shachaf> Yes, but it's sometimes not a good idea.
18:48:50 <Hijiri> ok
18:49:30 <dibblego> if you don't know what $SOMETHING is, you ask GHCi using the wtf? command, which is spelled like this :info
18:49:35 <dibblego> :info $SOMETHING
18:49:47 <dibblego> :info Either
18:50:01 <dibblego> that will tell you everything you need to know about Either, including Left and Right
18:50:13 <Welkin> @info Either
18:50:13 <lambdabot> Either
18:50:21 <Welkin> lambdabot is so helpful
18:50:29 <Welkin> everything I need to know
18:50:34 <dibblego> lambdabot is shy when it comes to the wtf? command
18:50:44 <dibblego> I said GHCi for this reason
18:52:00 <Fuuzetsu> is @info a thing now?
18:52:01 <bmuk`> dibblego: at the time this happened I thought it would be a good idea to print typeclassopedia out and do it on a long car ride.
18:52:12 <Fuuzetsu> @info (+)
18:52:12 <lambdabot> (+)
18:52:15 <shachaf> No. It's never been a thing.
18:52:15 <Fuuzetsu> y-you too!
18:52:20 <Fuuzetsu> OK
18:52:22 <dibblego> bmuk`: do which exactly?
18:52:25 <shachaf> Just don't type it.
18:52:27 <vanila> @info lambda bot sucks
18:52:27 <lambdabot> lambda bot sucks
18:53:05 <shachaf> vanila: Stop it.
18:53:57 <bmuk`> dibblego: read through typeclassopedia and do the examples. I gave up on doing the examples and just read it because I had no way to know what either, ((->) e), et.al. were.
18:54:15 <dibblego> bmuk`: if you don't know what $SOMETHING is, ask GHCi
18:54:37 <bmuk`> I know, I was saying I didn't have a computer.
18:54:42 <dibblego> don't wait for a book to tell you
18:54:54 <dibblego> ok, how might you do the examples?
18:55:06 <Welkin> the reader monad!
18:55:07 <Welkin> fun
18:55:29 <Welkin> bmuk`: you don't need a computer to program
18:55:56 <bmuk`> Welkin: no, but you do need a computer to run ghci :p
18:56:15 <dibblego> ok, how might you do the examples?/
18:56:17 <dibblego> oop
18:56:22 <dibblego> also, to do the examples right?
18:56:53 <bmuk`> dibblego: now or then?
18:57:13 <dibblego> I don't know what this means
18:57:18 <bmuk`> dibblego: or are you asking how I could even do the examples without a computer at all?
18:57:37 <dibblego> I am trying to understand your current process of discovery, so as to help improve it
18:57:50 <Hijiri> you could write it down
18:57:56 <bmuk`> dibblego: I was describing a problem I had in the past.
18:58:22 <vanila> bmuk`, it' might be impossible to get this point across
18:58:42 <bmuk`> vanila: do you understand what I'm saying?
18:58:45 <vanila> yes
18:58:50 <Fuuzetsu> I also do
19:00:11 <bmuk`> My main point at the begining was that it would be helpful for typeclassopedia to include :info output for all of the types it uses.
19:00:39 <monochrom>  @info is typo-corrected to @undo.
19:00:48 <monochrom> @info do {x<-m; return x}
19:00:48 <lambdabot> m >>= \ x -> return x
19:01:11 <monochrom> this is not being uninformative. this is just being undonotative.
19:01:32 <vanila> bmuk`, you should suggest that to the author!
19:01:34 <Fuuzetsu> ah, I was wondering what it was resolving to
19:01:37 <monochrom> well, unless you decide that typo-corrections are evil.
19:01:49 <David> What does this error mean? Non-exhaustive patterns in record update
19:01:53 <Fuuzetsu> does PHP try to fix your typos yet?
19:02:14 <dibblego> David: it means you have pattern-matched, but not covered all possible cases
19:02:24 <Fuuzetsu> David: it means your record update had non-exhaustive patterns ;P Can you lpaste.net the code?
19:02:32 <David> hmm... odd. I've got an otherwise block
19:02:50 <David> http://hastebin.com/arapihesit.coffee
19:02:52 <dibblego> otherwise does not necessarily imply exhaustive
19:03:05 <Fuuzetsu> David: you don't show the record
19:03:10 <monochrom> "otherwise" is not even a reserved word
19:03:16 <Fuuzetsu> otherwise = True
19:03:34 <Fuuzetsu> David: if you have multiple constructors but only some of them have the field, that's what you get as well IIRC
19:03:41 <David> here's the full source
19:03:51 <David> https://bitbucket.org/ddinh/sbsched-dag-tools/src/8c7728f43b41740c23a63710d74c1746cf5f2611/Dag.hs?at=master
19:03:54 <David> error's on line 150
19:04:11 <Fuuzetsu> David: what's probably happening is that you're trying to use a field name on Leaf
19:04:19 <David> oh shit
19:04:22 <David> thanks
19:04:44 <Fuuzetsu> just a guess ;)
19:04:53 <David> yeah, that's probably what happened
19:05:02 <David> means something is wrong with my logic...
19:05:25 <benzrf> what makes a dag parallel
19:05:32 <joelteon> so who decided on a 62-tuple being the upper bound?
19:05:42 <Fuuzetsu> joelteon: it overflows doesn't it
19:05:49 <joelteon> overflows??
19:05:52 <Fuuzetsu> David: I would use fewer guards and more pattern matches
19:06:12 <Welkin> benzrf: never heard of a parallel dag
19:06:15 <Fuuzetsu> don't do head descents == Root, pattern match on [Root] instead, this way GHC can warn you
19:06:46 <Welkin> benzrf: or do you mean critical paths?
19:07:07 <monochrom> um, the correct pattern is Root:_
19:07:16 <Fuuzetsu> oops, yes, sorry
19:07:24 <monochrom> :)
19:07:28 <David> if you're referring to my code, benzrf, essentially it's a representation of forks, parallel blocks, and joins
19:07:32 <David> for a scheduler
19:11:01 <benzrf> oook
19:12:36 <Welkin> eeek
19:12:38 <Welkin> oook!
19:12:56 <merijn> joelteon: I dunno, guess that's when they got tired of writing definitions ;)
19:13:17 <Welkin> writing definitions for definitions
19:13:29 <Welkin> in high-definition
19:13:39 <nullbyte> HHV
19:15:23 <Fuuzetsu> joelteon: AFAIK some (compile time) overflowing happens if you try to define instances for too large tuples, I don't remember the details and I might be wrong
19:17:15 <merijn> Fuuzetsu: I think he's refering to the fact that there's no tuples larger than 62 (or was it 63) elements in GHC
19:20:09 <doismellburning> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
19:20:10 <lambdabot>     A 63-tuple is too large for GHC
19:20:11 <lambdabot>       (max size is 62)
19:20:11 <lambdabot>       Workaround: use nested tuples or define a data type
19:21:04 <Fuuzetsu> not even 64-tuple
19:21:34 <Fuuzetsu> I had a 20-tuple of Word8s the other day but I turned it into 2x 4-tuple and 4x Word8
19:21:45 <Fuuzetsu> it's ugly
19:21:50 <bmuk`> Can you define a data type with more than 62 parameters?
19:22:00 <vanila> why does haskell have 3 tuples and higher?
19:22:04 <vanila> 2 should be enough for anyone
19:22:05 <merijn> bmuk`: Sure
19:22:15 <augur> if you need a 62-tuple, you're doing something wrong
19:22:29 <doismellburning> augur: indeed
19:22:40 <augur> at that point, you really should be defining a new datatype
19:22:44 <bmuk`> what is it about tuples specifically that makes it so ghc can't handle 62?
19:22:49 <augur> maybe even a new datatype for 3+ tuples
19:22:49 <tommd> data Tuple63 = ...
19:22:53 <merijn> bmuk`: It could
19:23:01 <merijn> bmuk`: It's just that no one bothered to define them
19:23:15 <augur> bmuk`: they had no desire to define more type constructor syntax/parser rules
19:23:26 <bmuk`> merijn: oh. Why did the bother defining any above 7?
19:23:27 <tommd> bmuk`: Tuples are special syntax so they can only be implemented up to some finite level.  That finite number is currently (slightly arbitrarily) 62.
19:23:28 <augur> im sure they couldve defined a generic thing, but
19:23:52 <augur> i bet the choice to go up to 62 was for lulz
19:24:12 <doismellburning> I am reminded of the Hardy-Ramanujan number...
19:24:26 <Fuuzetsu> share
19:24:31 <merijn> bmuk`: No clue
19:24:34 <bmuk`> lol. I can't imagine a reason to need more than 7.
19:24:39 <merijn> bmuk`: "just cause", I'm guessing
19:24:47 <bmuk`> 7 is even large.
19:24:55 <vanila> what about the Hardy-Ramanujan tuple? (1,7,9,2)
19:25:39 <benzrf> 7 is massive
19:25:42 <benzrf> i never see more than a pair
19:26:33 <slack1256> List done right are basically `Fix (a,)`
19:26:41 <Fuuzetsu> what's the common practice on IsString, does it need to follow any laws?
19:26:46 <slack1256> that is basically a tuple we're putting on ghc.tuple
19:26:49 <slack1256> I need it.
19:26:52 <Fuuzetsu> is it OK to define it for newtypes over string-likes?
19:26:53 <merijn> Fuuzetsu: It should be total for all strings
19:26:59 <slack1256> *we aren't
19:27:00 <doismellburning> tbh I don't even like to use tuples
19:27:04 <doismellburning> I prefer explicit types
19:27:13 <bmuk`> Fuuzetsu: what do you do when you want a random ghci prompt? just nix-shell --pure into an arbitrary project?
19:27:15 <ski> merijn : even infinite ones ?
19:27:18 <vanila> slack1256, I don't thnk that works in practice - there are a lot of data types you can't define this way in haskell
19:27:33 <Fuuzetsu> bmuk`: nix-shell --pure -p haskellPackages.ghc
19:27:44 <vanila> slack1256, or maybe it could be made to work?
19:27:54 <slack1256> nah, I was being pedantic
19:27:57 <merijn> ski: Don't care, you can't write infinite string literals anyway
19:28:17 <Fuuzetsu> merijn: is totality the only thing?
19:28:19 <ski> merijn : and TH ?
19:28:29 <benzrf> :k Mu
19:28:30 <lambdabot> (* -> *) -> *
19:28:30 <Fuuzetsu> guess I should look at docs
19:28:54 <Fuuzetsu> oh, it says nothing of value ;(
19:29:38 <benzrf> @let polynomialize [] = In Nothing; polynomialize (x:xs) = In (Just (x, polynomialize xs))
19:29:39 <lambdabot>  .L.hs:191:35:
19:29:39 <lambdabot>      Couldn't match expected type ‘Mu Maybe’
19:29:39 <lambdabot>                  with actual type ‘(t, Mu Maybe)’
19:29:39 <lambdabot>      Relevant bindings include
19:29:39 <lambdabot>        xs :: [t] (bound at .L.hs:191:20)
19:29:44 <benzrf> p:
19:30:43 <benzrf> @let type PList a r = Maybe (a, r)
19:30:44 <Fuuzetsu> reminder to try in /query first
19:30:46 <lambdabot>  Defined.
19:30:49 <Rufflewind> the docs for modifyMVar say "This function is only atomic if there are no other producers for this 'MVar'.
19:30:58 <benzrf> @let polynomialize :: [a] -> Mu (PList a); polynomialize [] = In Nothing; polynomialize (x:xs) = In (Just (x, polynomialize xs))
19:30:59 <lambdabot>  .L.hs:175:18:
19:30:59 <lambdabot>      Type synonym ‘PList’ should have 2 arguments, but has been given 1
19:30:59 <lambdabot>      In the type signature for ‘polynomialize’:
19:30:59 <lambdabot>        polynomialize :: [a] -> Mu (PList a)
19:31:03 <benzrf> aw man
19:31:20 <merijn> Rufflewind: Essentially it does "takeMVar -> do stuff -> putMVar" if someone does putMVar in between, you're boned
19:31:21 <Rufflewind> what does it mean "producer for 'MVar'" ?  how does having multiple producer cause problems for modifyMVar? (example?)
19:31:39 <merijn> Rufflewind: Because when you try to putMVar at the end, you block
19:31:46 <Rufflewind> merijn: so as long as I do take -> put in pairs it should be OK then?
19:32:13 <merijn> Rufflewind: If you only use 1) modifyMVar or 2) "take -> put" where take is always first and you always put, then it's fine
19:32:29 <Rufflewind> merijn: OK thanks!
19:33:01 <merijn> Data.Set doesn't have an inser that tells you whether a value is already present, does it?
19:33:04 <benzrf> :t In ("foo", In ("foo", undefined))
19:33:05 <lambdabot> Mu ((,) [Char])
19:33:08 <benzrf> p:
19:33:19 <benzrf> :t In (Just ("foo", In (Just ("foo", Nothing))))
19:33:20 <lambdabot>     Couldn't match expected type ‘Mu Maybe’
19:33:20 <lambdabot>                 with actual type ‘([Char], Mu Maybe)’
19:33:20 <lambdabot>     In the first argument of ‘Just’, namely
19:33:37 <benzrf> ??
19:34:51 <merijn> benzrf: That'd be "Compose Maybe ((,) [Char])", no?
19:35:00 <merijn> Doesn't seem like GHC can infer a type as complex as that
19:35:09 <merijn> :t Compose
19:35:10 <lambdabot> Not in scope: data constructor ‘Compose’
19:35:18 <merijn> :t Data.Functor.Compose.Compose
19:35:19 <lambdabot> f (g a) -> Data.Functor.Compose.Compose f g a
19:36:09 <merijn> :t let C = Data.Functor.Compose.Compose in In (Compose (Just ("foo", In (Compose (Just ("bar", Compose Nothing))))))
19:36:10 <lambdabot> Not in scope: data constructor ‘C’
19:36:10 <lambdabot> Not in scope: data constructor ‘Compose’
19:36:10 <lambdabot> Not in scope: data constructor ‘Compose’
19:36:14 <merijn> eh
19:36:26 <merijn> :t let C = Data.Functor.Compose.Compose in In (C (Just ("foo", In (C (Just ("bar", C Nothing))))))
19:36:27 <Fuuzetsu> it uses a different database for :t
19:36:27 <lambdabot> Not in scope: data constructor ‘C’
19:36:27 <lambdabot> Not in scope: data constructor ‘C’
19:36:27 <lambdabot> Not in scope: data constructor ‘C’
19:36:54 <merijn> oh
19:36:54 <benzrf> merijn: you cant let data constructors
19:36:55 <merijn> duh
19:36:57 <benzrf> lmao
19:37:03 <merijn> Sure you can, just not with a capital
19:37:08 <benzrf> thats what i mean
19:37:09 <benzrf> you cant bind em
19:37:19 <merijn> :t let c = Data.Functor.Compose.Compose in In (c (Just ("foo", In (c (Just ("bar", c Nothing))))))
19:37:20 <lambdabot>     Couldn't match expected type ‘Mu
19:37:20 <lambdabot>                                     (Data.Functor.Compose.Compose Maybe ((,) [Char]))’
19:37:20 <lambdabot>                 with actual type ‘Data.Functor.Compose.Compose Maybe g0 a0’
19:37:26 <merijn> hmmm
19:37:30 <merijn> ok, I give up
19:37:39 <benzrf> :-\
19:37:42 <merijn> benzrf: Anyway, your value had the wrong kind
19:37:48 <benzrf> ? ?? ?
19:37:48 <merijn> or type, or stuff
19:38:04 <merijn> :t IN
19:38:05 <lambdabot>     Not in scope: data constructor ‘IN’
19:38:05 <lambdabot>     Perhaps you meant ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
19:38:06 <merijn> :t In
19:38:07 <lambdabot> f (Mu f) -> Mu f
19:38:27 <merijn> benzrf: "f" has type "* -> *"
19:38:28 <benzrf> :t In Nothing
19:38:29 <lambdabot> Mu Maybe
19:38:35 <benzrf> oh crap
19:38:39 <merijn> ""Maybe (a,)" doesn't work
19:38:45 <merijn> Not without Compose
19:38:48 <benzrf> well yes
19:39:20 <benzrf> @let newtype Wot f = Wot (f Int)
19:39:21 <lambdabot>  Defined.
19:39:28 <benzrf> :t Wot (Just 4)
19:39:29 <lambdabot> Wot Maybe
19:39:32 <vanila> we would need System F style type abstraction which haskell lacks to nicely work this way - newtypes help but they get in the way too
19:39:32 <benzrf> :t Wot (Just (3, 4))
19:39:33 <lambdabot>     Couldn't match expected type ‘Int’ with actual type ‘(t0, t1)’
19:39:33 <lambdabot>     In the first argument of ‘Just’, namely ‘(3, 4)’
19:39:33 <lambdabot>     In the first argument of ‘Wot’, namely ‘(Just (3, 4))’
19:39:37 <benzrf> o_O
19:39:50 <benzrf> haskell u suck at this
19:40:07 <benzrf> :t Compose
19:40:08 <lambdabot> Not in scope: data constructor ‘Compose’
19:40:15 <benzrf> :t Data.Functor.Compose
19:40:16 <lambdabot>     Not in scope: data constructor ‘Data.Functor.Compose’
19:40:37 <benzrf> :t Wot (Data.Functor.Compose.Compose (Just ("bleh", 4)))
19:40:38 <lambdabot> Wot (Data.Functor.Compose.Compose Maybe ((,) [Char]))
19:40:44 <benzrf> :\
19:40:55 <Welkin> wtf is that?
19:41:09 <Welkin> are you defining new constructors?
19:41:15 <benzrf> :t Wot (Just (Left 4))
19:41:16 <lambdabot>     Couldn't match expected type ‘Int’ with actual type ‘Either a0 b0’
19:41:16 <lambdabot>     In the first argument of ‘Just’, namely ‘(Left 4)’
19:41:16 <lambdabot>     In the first argument of ‘Wot’, namely ‘(Just (Left 4))’
19:41:24 <benzrf> >mfw ghc cant figure out composed types
19:41:28 <Welkin> :t Left "benzrf"
19:41:29 <lambdabot> Either [Char] b
19:41:30 <benzrf> :t Wot (Just (Sum 4))
19:41:31 <lambdabot>     Couldn't match expected type ‘Int’ with actual type ‘Sum a0’
19:41:31 <lambdabot>     In the first argument of ‘Just’, namely ‘(Sum 4)’
19:41:31 <lambdabot>     In the first argument of ‘Wot’, namely ‘(Just (Sum 4))’
19:41:46 <merijn> benzrf: Please do this in PM/locally instead of the channel
19:46:12 <trap_exit> is there a way to "wrap" a function f, s.t. (1) if f returns [a], then return [a], and (2) if f throws an exception, then return [] ?
19:46:25 <trap_exit> is there a way to "wrap" a function f, s.t. (1) if f returns [a], then return [a], and (2) if f throws an exception, then return [] ? (this is in the context of a DSL, where "silent failure" is part of the semantics)
19:46:41 <trap_exit> is there a way to "wrap" a function f, s.t. (1) if f returns [a], then return [a], and (2) if f throws an exception, then return [] ? (this is in the context of a DSL, where "silent failure" is part of the semantics; i.e. think non-deterministic search / constraint solving -- silent failing is fine)
19:48:13 <Welkin> bracket
19:48:23 <Welkin> :t bracket
19:48:24 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
19:48:25 <slack1256> maybe the function isn't IO
19:48:48 <trap_exit> hmm
19:48:50 <trap_exit> there's no error
19:48:50 <trap_exit> http://www.haskell.org/hoogle/?hoogle=bracket
19:48:52 <trap_exit> err, there's no IO
19:48:53 <Fuuzetsu> isn't there a generalised catch-all somewhere
19:49:01 <slack1256> in the exception package
19:49:02 <trap_exit> the "exception" is a pattern match fail
19:49:10 <trap_exit> i.e. (Just blah blah) = somethign that gives me a Nothing
19:49:38 <slack1256> http://hackage.haskell.org/package/exceptions
19:49:39 <merijn> Don't generate pattern match failures, they're almost impossible to catch reliably
19:50:13 <trap_exit> merijn: I do not doubt the validity or your statement. However, can you explain to me why they're impossible to catch reliably?
19:50:14 <mgaut72> trap_exit: maybe use "case foo of Just a -> return [a] otherwise -> nothing" reather than throw an exception
19:50:25 <trap_exit> I don't mind throwing exceptions
19:50:31 <trap_exit> this is a bunch of 'tactics' I'm running in parallel
19:50:34 <merijn> trap_exit: Because they're only raised when the expression containing the pattern match is forced
19:50:39 <trap_exit> having 'failed tactics' throw exceptions = fine
19:50:43 <triliyn> I don't think you can catch exceptions except in IO
19:50:46 <merijn> trap_exit: Which may happen outside of your "catch" setup
19:50:57 <merijn> triliyn: Correct, but even then they can escape
19:51:04 <trap_exit> *thinking*
19:51:30 <trap_exit> I feel the "catch" block lexically scopes the pattern match fail
19:51:30 <merijn> triliyn: Imagine "return undefined `catch` someHandler", the undefined happily escapes catch, because it's not forced
19:51:30 <trap_exit> hmm
19:51:41 <trap_exit> oh, but the catch can return a thunk which will pattern match fail
19:51:45 <trap_exit> damn laziness
19:51:47 <merijn> triliyn: The exception is only raised when undefined is evaluated, which may be *after* catch returns
19:52:06 <merijn> trap_exit: Yes, only exceptions raised with throwIO can be caught reliably
19:52:12 <triliyn> hmmm, interesting
19:52:27 <merijn> The IO in throwIO forces the exception to be raised before "catch" can return
19:54:10 <trap_exit> merijn: thanks for explaining this; much appreciated
19:57:45 <trap_exit> hmm
19:57:52 <trap_exit> so should pure functions never have pattern match failures?
19:58:05 <trap_exit> imagine I'm writing a comptuer algebra system
19:58:07 <trap_exit> I have a bunch of simplification rules
19:58:14 <merijn> Ideally, they shouldn't, no
19:58:14 <Welkin> what do you mean by a pattern match failure?
19:58:19 <WraithM> The Network module haddocks from the package network says that it suggests people use the lower-level package. Is there a good high-level networking module? Or should I just write the low-level code using Network.Socket?
19:58:22 <trap_exit> and I'm okay if a simplification rule throws a pattern match failure
19:58:26 <merijn> Welkin: non-total pattern match
19:58:26 <Welkin> you must be able to match it somehow
19:58:29 <trap_exit> since I just know "oh, that rule can't simplify the expression"
19:58:32 <Welkin> even if it is "otherwise"
19:58:36 <Welkin> you need a base case
19:58:36 <trap_exit> let (Just ... ) = Nothing
19:58:40 <trap_exit> throws a pattern match failure
19:58:40 <Fuuzetsu> WraithM: depends what you want to do
19:59:12 <trap_exit> hm
19:59:14 <triliyn> trap_exit: you could just return the expression in that case
19:59:16 <Fuuzetsu> trap_exit: make sure to add -- error can't happen! as a comment
19:59:25 <trap_exit> the error can happen
19:59:38 <Fuuzetsu> of course, but if you don't add the comment then it's not authentic code
19:59:50 <triliyn> Perhaps with some additional information so that it's easier to determine that no simplification took place
19:59:57 <Fuuzetsu> it's for the pleasure of the person that has to debug it
20:00:36 <WraithM> Fuuzetsu: Just a server that takes commands from potentially multiple clients. The commands are ADTs serialized with cereal.
20:01:45 <Fuuzetsu> WraithM: you could use the network wrapper given by conduit, makes that pretty trivial
20:01:49 <trap_exit> argh
20:01:52 <trap_exit> I like the erlang philosophy of
20:01:56 <trap_exit> error handling = someone else's problem
20:01:58 <trap_exit> and just restart
20:02:02 <Welkin> fail fast?
20:02:08 <Welkin> like facebook?
20:02:14 <Fuuzetsu> WraithM: http://hackage.haskell.org/package/conduit-extra-1.1.3.4/docs/Data-Conduit-Network.html I think this was it
20:02:36 <merijn> trap_exit: What's stopping you from just returning []?
20:03:00 <trap_exit> i'm writing " let (Just ...) = map.lookup ... "
20:03:09 <trap_exit> then it become s"let (Just ...) = NOthing"
20:03:13 <merijn> So don't write that?
20:03:15 <trap_exit> I don't want to throw in a Case statement there
20:03:15 <Fuuzetsu> WraithM: http://www.yesodweb.com/blog/2014/03/network-conduit-async and https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/conduit-overview too
20:03:31 <merijn> trap_exit: Use fmap/fromMaybe/whatever
20:03:32 <trap_exit> if the lookup is not  Just
20:03:34 <trap_exit> the tactic should just abort
20:03:38 <triliyn> If you pattern match in a do block, failed pattern matches will call fail instead of just crashing
20:03:40 <carter> trap_exit: .... that is a lazy pattern mach
20:03:49 <carter> oh yeha
20:03:53 <merijn> carter: No, because it can fail
20:03:55 <trap_exit> carter: I have no idea what that means?
20:04:00 <carter> merijn: i know
20:04:03 <merijn> trap_exit: Not relevant here
20:04:09 <carter> refuable
20:04:20 <WraithM> Fuuzetsu: I'm actually trying to use io-streams. I see io-streams has a networking module. I guess I should have said that from the beginning :)
20:04:35 <carter> > let (Just x) = Nothing in  (show $ 1 + x)
20:04:37 <lambdabot>  "*Exception: <interactive>:3:5-22: Irrefutable pattern failed for pattern (D...
20:04:45 <joelteon> Fuuzetsu: no, i mean, why did they limit it to 62
20:04:47 <carter> trap_exit: thats what you doing man
20:05:00 <Fuuzetsu> WraithM: I don't know io-streams so can't help there, sorry
20:05:18 <Fuuzetsu> joelteon: don't know, got tired at 62?
20:05:28 <carter> Fuuzetsu: io-streams is like a very very simplified version of pipes/conduit
20:05:31 <carter> for IO things only
20:05:32 <Fuuzetsu> maybe the lexer for 63 went over 80 columns
20:05:42 <WraithM> Fuuzetsu: Okay! Thanks for your help! I'll hunt for more io-streams examples.
20:06:07 <Fuuzetsu> carter: interesting; I really need to learn conduit well myself
20:06:16 <Fuuzetsu> usually I just wing it and glue shit until it works
20:06:23 <carter> Fuuzetsu: io-streams is a simpler substrate
20:06:31 <carter> less generic == more power
20:06:46 <Fuuzetsu> () = most power? ;)
20:08:33 <WraithM> carter: Do you have any good examples of server code using io-streams network stuff?
20:08:41 <carter> Snap Head
20:10:42 <WraithM> carter: Cool, thank you. That's where I'm looking now.
20:11:08 <trap_exit> carter: a refulable pattern match -- is that an IO exception or a regular exception?
20:11:14 <trap_exit> carter: can I catch it outside of IO () ?
20:11:25 <carter> trap_exit: you can always catch exeptions outside of io
20:11:31 <carter> just use unsafeperformio
20:11:33 <merijn> There are no "regular exceptions"
20:11:40 <trap_exit> I don't want to use unsafeperformio
20:11:41 <merijn> They are all IO
20:11:48 <carter> trap_exit: tough
20:11:52 <merijn> You can't catch them outside IO
20:11:57 <carter> use monadic pattern matching then
20:12:06 <carter> and use a monad which a notion of failure
20:12:10 <carter> that fail can use
20:12:12 <trap_exit> > fromJust NOthing
20:12:14 <lambdabot>  Not in scope: data constructor ‘NOthing’
20:12:14 <lambdabot>  Perhaps you meant ‘Nothing’ (imported from Data.Maybe)
20:12:20 <trap_exit> > fromJust Nothing
20:12:22 <lambdabot>  *Exception: Maybe.fromJust: Nothing
20:12:32 <trap_exit> can I catch "fromJust Nothing" outside of IO ?
20:12:37 <merijn> trap_exit: No
20:12:47 <merijn> trap_exit: You can't catch *anything* outside of IO
20:13:07 <carter> unless you or someone else uses unsafePerformIO
20:13:13 <merijn> trap_exit: And fromJust and irrefutable pattern exceptions have the exact same laziness problem as pattern match failure
20:13:15 <trap_exit> merijn: noted, thanks for explaining this
20:13:15 <carter> or you do the do notation suggestion
20:13:38 <trap_exit> exceptions thrown inside a monad
20:13:41 <trap_exit> calls "fail" ?
20:16:23 <merijn> Monadic pattern match failure calls fail
20:22:27 <katsh> http://tabbit.org/4 LYAH says this would be shorter and clearer by not using 'where'. how would the function look?
20:23:08 <cdc_> katsh: initials (f:_) (l:_) = ...
20:23:30 <katsh> bananas
20:23:36 <katsh> thanks
20:23:42 <cdc_> no prob
20:23:42 <bmuk> In regards to the earlier discussion, do you feel it is worthwhile to go back and reread LYAH, RWH, GIH, typeclassopedia, etc, if one already has a pretty strong grasp of haskell (can read haskell code and understand it, knows how to figure out what one doesn't understand, etc.)? Or is one's time better spent studying and producing actual haskell code?
20:24:04 <cdc_> bmuk: why not ready production-level code?
20:24:09 <cdc_> s/ready/read
20:24:32 <bmuk> That's my question :)
20:24:42 <pavonia> @where GIH
20:24:42 <lambdabot> I know nothing about gih.
20:24:51 <katsh> what is gih
20:24:57 <bmuk> pavonia: Is that a better use of my time
20:25:03 <bmuk> http://www.haskell.org/tutorial/
20:25:08 <pavonia> bmuk: What is GIH?
20:25:11 <bmuk> (copy messed up)
20:25:15 <bmuk> ^
20:26:21 <pavonia> Well, RWH is a good book even if you already know Haskell
20:28:23 <bmuk> I know I can still benefit from further analysis of Typeclassopedia. And I'm sure RWH as well (last time I tried to read it again it became boring because I wasn't doing the exercise, just reading passively). I think every time I try to go back and read LYAH I feel kind of bored with it, but at the same time I would like to make sure there are no gaps in my understanding
20:28:58 <carter> bmuk: wite code
20:29:01 <carter> *write
20:29:19 <carter> and read ohter peoples codes
20:29:21 <katsh> fork xmonad and make it so i can have spaces between windows
20:29:24 * hackagebot linear-accelerate 0.2 - Instances to use linear vector spaces on accelerate backends  http://hackage.haskell.org/package/linear-accelerate-0.2 (EdwardKmett)
20:30:57 <bmuk> katsh: there's already a function for that
20:31:10 <trap_exit> wow monads are so awesome now
20:31:14 <bmuk> katsh: http://xmonad.org/xmonad-docs/xmonad-contrib/XMonad-Layout-Spacing.html
20:31:16 <trap_exit> since they can use fail to handle exceptions
20:31:29 * merijn thinks fail is the worst thing about Monad
20:31:35 <ski> `fail' is a bit of a wart in the `Monad' type class
20:31:38 <merijn> fail should be MonadZero
20:31:46 <merijn> Or MonadPlus
20:31:47 <ski> or `MonadFail'
20:31:51 <trap_exit> wait
20:31:55 <trap_exit> http://hackage.haskell.org/package/category-extras-0.53.4/docs/src/Control-Monad-Either.html#EitherT ... doesn't handle fail
20:32:56 <trap_exit> http://hackage.haskell.org/package/either-4.3.1/src/src/Control/Monad/Trans/Either.hs
20:32:58 <trap_exit> hmm, was reading outdated
20:33:03 <merijn> Oooh! New idea, start a website for "haskell exercises" that secretly just tricks newbies into writing tests I can't be arsed to write...
20:33:27 <shachaf> Tests sound more like coexercises.
20:33:39 <gratimax> lol
20:33:55 <bmuk> merijn: What if there was something : programming as duolingo : language learning
20:34:05 <ski> trap_exit : what about it ?
20:35:20 <trap_exit> ski: how does Either implement fail ?
20:36:11 <pavonia> > fail "foo" :: Either String Int
20:36:11 <Fuuzetsu> > fail "foo" :: Either a ()
20:36:13 <lambdabot>  can't find file: L.hs
20:36:13 <lambdabot>  *Exception: foo
20:36:33 <ski> trap_exit : it shouldn't
20:36:42 <ski> apart from the default implementation, i.e.
20:36:46 <Fuuzetsu> Left right
20:36:47 <trap_exit> ski: why not?
20:36:47 <bmuk> In duolingo people learn languages, and then translate the web to solidify understanding. They may make errors, but many people are given the same sentences and overall the average is correct. We give a bunch of new haskellers small pieces of hard problems and average out their solutions
20:37:12 <Fuuzetsu> how do you average code?
20:37:15 <trap_exit> how do you average two programs?
20:37:18 <bmuk> Though I suppose if a problem could be easily broken into that many smaller subproblems then it would be trivial anyway
20:37:18 <ski> trap_exit : because we want `Either e' to be an instance of `Monad' for any type `e', not just for types `e' which are in some silly auxilary type class
20:37:26 <bmuk> the AST
20:37:51 <Fuuzetsu> bmuk: sounds like a great way to generate a whole ton of programs that don't compile
20:37:52 <shachaf> ski: Well, except for Henning.
20:38:21 <bmuk> Fuuzetsu: probably lol.
20:38:46 <merijn> shachaf: Doesn't he just want to replace Either with "T"? ;)
20:38:59 <bmuk> I suppose spanish speakers are much more forgiving than GHC.
20:39:30 <trap_exit> here's what you do
20:39:37 <trap_exit> you get n progamers to write programmers
20:39:49 <trap_exit> then you get them to vote, and delete th eprograms that do not agree with majority
20:39:57 <ski> trap_exit : e.g. i've on occasion wanted to use `Either Integer' as a monad, which wouldn't work if `Integer' would be required to be an instance of `Error'
20:40:10 <Fuuzetsu> trap_exit: we'll be in trouble if programers start deleting programs
20:40:11 <trap_exit> ski: noted
20:40:13 <Fuuzetsu> progamers*
20:40:22 <ski> (or perhaps it was `Either [Integer]' .. it doesn't really matter here)
20:40:57 <trap_exit> okay
20:40:59 <trap_exit> I use Maybe monad
20:41:01 <trap_exit> fail _ = Noting
20:41:02 <trap_exit> which is what I want
20:42:31 <trap_exit> merijn: what do you have against Maybe monad handling fail ?
20:43:09 <merijn> trap_exit: I don't have anything against Maybe handling fail, because Maybe is both MonadZero and MonadPlus
20:43:18 <merijn> I have something against the Monad class handling fail
20:43:34 <merijn> :t fail
20:43:34 <lambdabot> Monad m => String -> m a
20:43:37 <merijn> :t mzero
20:43:38 <lambdabot> MonadPlus m => m a
20:43:50 <merijn> Clearly fail should just be mzero
20:44:24 <merijn> > mzero :: Maybe Int
20:44:25 <lambdabot>  Nothing
20:44:32 <shachaf> fail _ = mzero; mzero = fail "mzero"; {-# MINIMAL fail | mzero #-}
20:44:35 <merijn> > mzero :: [Int]
20:44:36 <lambdabot>  []
20:44:56 <trap_exit> merijn: noted, thanks
20:45:02 <yeboot> so I've watched like 4 youtube videos and I still have no idea what a monad is
20:45:13 <merijn> trap_exit: The problem is that there are Monads which don't have sensible definitions of fail
20:45:14 <yeboot> beyond something about a function that maps a monoid to a monoid or something
20:45:23 <trap_exit> merijn: yeah, agreed
20:45:33 <merijn> yeboot: The trick is to not worry about what a monad "is"
20:45:55 <yeboot> merjin I get that feeling, but do you have a link to an explicit formal definition using mathematical notation
20:46:00 <yeboot> is where I was going
20:46:16 <merijn> yeboot: Focus on understanding type signatures and typeclass
20:46:47 <merijn> Not really and mathematical monads have fairly little to do with haskell's Monad at any rate
20:46:49 <shachaf> yeboot: https://en.wikipedia.org/wiki/Monad_(category_theory) is a formal definition using mathematical notation. It doesn't help most people very much.
20:47:15 <merijn> yeboot: http://dev.stephendiehl.com/hask/#monads
20:48:13 <shachaf> merijn: I wouldn't say "little". It's the same thing. But that definition is more general and learning about it is more work than it's worth if you just want to understand the Haskell version.
20:50:01 <shachaf> Hmm, the page I linked to starts off "If F and G are a pair of adjoint functors, with F left adjoint to G, then the composition G . F is a monad." Really very unhelpful for Haskell.
20:50:53 <dolio> There's one part of that page that might help you understand monads' use in Haskell.
20:50:58 <dolio> But it's not the definition.
20:51:58 <dolio> And really, even that part isn't very useful.
20:52:20 <shachaf> Yep.
20:53:13 <dolio> The general story is that monads are general ways of doing algebra. And you often want to talk about algebras in your language.
20:53:36 <dolio> For embedded languages, in particular.
20:54:05 * shachaf wonders what dolio means now.
20:54:21 <dolio> I was talking about the 'Algebras for a monad' section.
20:54:38 <dolio> Which tells you what a T-algebra is. But that's not going to be very useful.
20:55:13 <shachaf> Maybe it'd be more useful if it was called an M-algebra.
20:55:37 <dolio> It'd be more useful if it told you why you should care about 'free algebras of a monad'.
20:55:42 <dfeuer> Hello, dolio.
20:56:02 <dolio> Hello.
20:56:20 <shachaf> Is there a thing which is like a monad except without fmap, just join and return?
20:56:51 <dolio> I don't know. It's hard to construct anything like that in category theory.
20:56:54 <Fuuzetsu> yeboot: https://www.youtube.com/watch?v=ZhuHCtR3xq8 gentle video
20:56:56 <shachaf> Yes.
20:57:07 <shachaf> It seems that monads let you talk about various "more powerful languages/logics", e.g. Cont can give you Haskell + LEM.
20:57:23 <shachaf> But maybe sometimes you might want to talk about something less powerful.
20:57:34 <shachaf> Modal logic often has something which looks like a monad except without the fmap law.
20:58:05 <dolio> Yeah.
20:58:33 <shachaf> Which seems to be vaguely along the lines I said. Saying "X is necessarily true" is stronger than saying "X is true", so you can't "fmap" inside it.
20:58:45 <dolio> The problem is that constructions like that seem like they're inherently 'evil'.
20:58:54 <dfeuer> Yes, dolio, I have spent another couple hours trying to figure out how to prove scanl correct. No, I have not made any meaningful progress. Yes, I am understanding some *other* aspects of this beast a *little* bit better. No, not well enough to be able to figure out how to write more transformers.
20:59:13 <merijn> Any testing libraries around for tests that involve multiple different processes?
20:59:29 <shachaf> Wow, dolio, you're asking a lot of questions today.
20:59:58 <gratimax> shachaf: to your previous question: monads in category theory are made of just join and return
21:00:02 <shachaf> Anyway, I'm not sure I understand what I'm getting at well enough to say whether it's evil.
21:00:05 <shachaf> gratimax: And fmap.
21:00:25 <dolio> dfeuer: I'd be surprised if the current scanl were wrong. But I've been surprised by that stuff before.
21:00:25 <gratimax> There's several combinations
21:00:38 <ski> (i would dispute claiming "Monads are about effects." and "Monads are about sequencing." are false, at least under a general enough conception of "effect" and "sequencing")
21:00:42 <gratimax> e.g. you can define fmap in terms of map + join
21:01:00 <gratimax> Monads are about sequencing of effects :P
21:01:01 <shachaf> What?
21:01:33 <bmuk> shachaf: I'm imagining something which only has join and return. It has to be possible. It would just have the concept of 'collapsing' nested contexts and 'lifting' a value into a default context. Or as a container, it would be able to concatenate containers into a single container and be able to wrap values in a container.
21:01:56 <gratimax> bmuk: That's the definition of a monad in category theory
21:02:07 <gratimax> just a container from one category 'lifted'
21:02:13 <dfeuer> dolio, the only aspect of it that scares me (very possibly without justification, of course) is the appearance of const. Now it may very well be that that interacts with scanlCons in some fashion that makes it always right. I just ... don't know how to check, really.
21:02:25 <dolio> shachaf: Maybe you should look how modal logic is done in category theory, if anyone's done it.
21:02:46 <dolio> dfeuer: Which const?
21:02:48 <ski> bmuk : hm, try a code representation in a staged programming language without cross-stage-persistence, or with pattern-matching on code
21:02:49 <shachaf> gratimax: To clarify: Every category-theory definition of a monad ends up with something that corresponds to fmap.
21:03:11 <shachaf> gratimax: I don't know what distinction you're making between fmap and map when you say "define fmap in terms of map + join".
21:03:26 <dfeuer> dolio, the one written \b' -> r
21:03:38 <gratimax> shachaf: sorry about that. I work in another language called scala where fmap -> map. It's super confusing
21:03:45 <shachaf> But I'm talking about something that has return+join but no fmap, or map, or any sort of arrow-mapping thing.
21:03:47 <gratimax> and actually in scala map = flatmap
21:04:09 <shachaf> OK.
21:04:11 <ski> shachaf : what i said to bmuk ?
21:04:18 <dolio> No. flatMap is concatMap or (>>=)
21:04:19 <shachaf> Fortunately the thing I'm asking for has none of them.
21:04:43 <shachaf> ski: ?
21:04:56 <ski> dolio : "evil" in the ncatlab sense ?
21:05:47 <ski> shachaf : you were talking about `join' and `return', but not `fmap', no ?
21:05:48 <gratimax> But in category theory, that's what a monad is. First off, it's an endofunctor, meaning it's a functor from a category to itself
21:05:56 <dolio> ski: Yes. You'd be working with a category C, but want a functor from a derived category that removes all the non-identity arrows or something.
21:05:58 <bmuk> shachaf: So if what I described is a monad in category theory, and monads are defined just with join and return, how is that different from what you are asking for?
21:06:02 <gratimax> That's the equivalent of return
21:06:16 <shachaf> bmuk: What you described isn't a monad in category theory. Monads in category theory have fmap.
21:06:37 <ski> gratimax : huh ?
21:06:44 <shachaf> The idea of a monad without fmap doesn't seem to make a lot of sense to talk about since return and join are natural transformations.
21:06:48 <gratimax> I remember a great article that explained the category side of monads
21:06:50 <gratimax> let me dig it up
21:06:53 <shachaf> gratimax: You're saying a lot of wrong things.
21:07:08 <gratimax> yeah, I sort of forgot exactly how it all translates
21:07:28 <shachaf> ski: Yes. Which thing were you talking about?
21:07:46 <dolio> ski: Maybe you could just remove the non-isomorphisms, and that wouldn't be evil.
21:07:59 <bmuk> shachaf: but is what I described what you are describing? (I guess I'm asking if I understand what you are asking)
21:08:06 <gratimax> Found it! http://en.wikibooks.org/wiki/Haskell/Category_theory#Monads
21:08:15 <ski> shachaf : staged programming
21:08:17 <dfeuer> dolio, did you see my response to the const question?
21:08:18 <gratimax> note that unit = return
21:08:31 <dolio> dfeuer: Yes. I don't know whether that's kosher or not.
21:08:41 <dolio> I think I've seen it go awry before.
21:09:17 <dolio> Does reverse . scanl f z work?
21:09:27 <dfeuer> dolio, the fact that it *seems* to work suggests it's fine; the fact that const is inherently shady suggests I just don't know. There might be something unnecessary that scanlCons introduces, but ... I dunno.
21:09:28 * hackagebot language-c-inline 0.7.6.1 - Inline C & Objective-C code in Haskell for language interoperability  http://hackage.haskell.org/package/language-c-inline-0.7.6.1 (ManuelChakravarty)
21:09:31 <shachaf> bmuk, ski: I've lost track of the conversation.
21:09:55 <dfeuer> I think it does, dolio, but let me check again.
21:10:25 <dolio> ski, shachaf: However, if you work in a category with only isomorphisms from the original category, then M^2 ~> M is limited to ismorphisms between MMa and M a, I think. Which is not what is wanted.
21:10:31 <ski> shachaf : hm, i just realized we need CSP for `return'. and even if we also have code inspection to break (laws for) `fmap', that would also break the other laws, so it's no good :/
21:10:36 <shachaf> ski: Do you mean <ski> bmuk : hm, try a code representation in a staged programming language without cross-stage-persistence, or with pattern-matching on code </ski> ?
21:10:42 <ski> yes
21:10:48 <dolio> So I guess you'd want a relative monad.
21:10:54 <ski> shachaf : but i just realized it doesn't work (at least not as i was thinking)
21:11:26 <shachaf> bmuk: If what you described is "something which only has join and return", then yes.
21:11:37 <shachaf> I think I had an example at one point but that was a while ago.
21:11:41 <nshepperd> "necessarily true" doesn't have return because if it's stronger than plain "true" then "true a ==> necessarily true a" is false
21:12:30 <shachaf> nshepperd: OK, then not that one. But there's some sort of formulation of modal logic that has return+join.
21:12:53 <ski> nshepperd : yes, e.g. "necessarily" could mean "provable" in some formal system
21:12:57 <bmuk> I can't think of a concrete example (that ONLY has those), but I can imagine some category that can only be collapsed or lifted. There doesn't seem to be much you can do in it, but I am imagining it
21:12:59 <dolio> nshepperd, shachaf: Necessity is comonad-like, posssibility is monad-like.
21:13:25 <shachaf> Sounds reasonable.
21:13:32 <shachaf> There are so many different axioms for all these things.
21:13:53 <ski> well, `Provable A => A' also fails
21:14:16 <nshepperd> heh, yes, Löb's theorem takes care of that hope
21:14:21 <dolio> Comonads have fmap as well, though.
21:14:23 <ski> yep :)
21:14:34 <edwardk> nanevsky has a bunch of papers where he gets mileage out of modal necessity
21:14:57 <shachaf> dolio: Yes.
21:15:09 <dolio> And necessity doesn't always.
21:15:11 <shachaf> There's also something which looks like ap.
21:15:14 <nshepperd> it's hard to imagine something with return and join but no fmap though. since you can get fmap as long as you can compose the two
21:15:23 <shachaf> nshepperd: You can?
21:15:30 <ski> edwardk : yeah, "Contextual Modal Type Theory" is cool :)
21:15:44 <nshepperd> er, wait
21:15:45 <bmuk> Since there are people who seem to know much more about category theory than me here, can you all help me understand the difference between a function and an arrow in category theory? IIRC arrows map objects in a category to other objects in that same category. How is this not a function?
21:15:47 <nshepperd> maybe I'm wrong
21:16:01 <edwardk> We also have Kenneth Foner coming out to give a talk on Löb at the next Boston Haskell, modified to bind it more efficiently to make nice comonadic spreadsheet effects
21:16:20 <shachaf> bmuk: "maps" is a word with all sorts of implications.
21:16:33 <ski> bmuk : arrows can be functions. can also be other stuff. e.g. matrices or natural numbers
21:16:34 <edwardk> bmuk: the arrow need not resemble a function at all. it might just be the relation 'is less than or equals to'
21:16:47 <shachaf> bmuk: You can say an arrow is "between" two objects, i.e. it points from one to the other. Objects aren't (necessarily) sets, they're just things.
21:16:53 <edwardk> bmuk: 5 <= 6, 6 <= 7, and so 5 <= 7 -- you could view <=   as an arrow!
21:16:56 <dolio> Or it might be an edge in some graph you drew.
21:17:11 <nshepperd> oh, I was thinking of bind
21:17:19 <shachaf> Or probably a path in a graph you drew.
21:17:29 <nshepperd> hmm
21:17:35 <ski> bmuk : or equivalence classes of pairwise homotopic continuous functions
21:17:56 <bmuk> edwardk: but isn't <= a function? Int -> Int -> Bool?
21:17:57 <edwardk> bmuk: in the opposite category for Set the functions run the wrong way. In Rel they are mere relations, not functions. They may just be purely formal compositions of edges in some graphs, etc.
21:18:21 <shachaf> bmuk: 5 <= 6 is a fact, not a function.
21:18:30 <edwardk> bmuk: look at the type of the function you gave, its not the function you are looking for
21:18:40 <ski> bmuk : in any case, in `5 <= 6', the arrow witnessing this fact isn't a function from `5' to `6'
21:18:51 <dolio> Or is it?
21:18:59 <ski> (hehe)
21:19:18 <ski> at least, it's not necessarily a function :)
21:19:49 <mainTheme> beginner in both haskell and emacs: I commented out some suggested bindings from the haskell-mode wiki (https://github.com/haskell/haskell-mode/wiki/Haskell-Interactive-Mode-Setup#haskell-mode-bindings) and hoped they would be replaced by ghc-mod (http://www.mew.org/~kazu/proj/ghc-mod/en/emacs.html)
21:19:55 <shachaf> bmuk: I like the category where objects are natural numbers and arrows are matrices (and composition is matrix multiplication) for some intuition about this sort of thing.
21:20:01 <edwardk> bmuk: i can formally write down a category with two objects, and an arrow from the first object to the second, add identity arrows, check the coherence conditions for it to be a category. what functions are involved?
21:20:03 * ski predicts bmuk will claim binary relations are functions from pairs to truth values
21:20:05 <shachaf> (This category has another name but that name is secret.)
21:20:15 <bmuk> edwardk: Is that not the type of (<=)? Maybe I am confusing computational functions with mathematical functions
21:20:25 <mainTheme> but running commands like C-c C-t still seem to be running in haskell-mode
21:20:57 <mainTheme> whereas M-x ghc-show-type work correctly
21:21:12 <edwardk> bmuk: you gave the right type for (<=), but not for that to be the way to talk about (<=) as an arrow for some category. you could build a category for which such (<=) is an arrow. its Rel, but its not the category you are thinking of
21:21:13 <dfeuer> dolio, I'm having a bit of trouble getting that to fuse. And I have to run for a bit.
21:21:15 <shachaf> whoa, this is an old-style "someone asks a questions and gets a zillion answers which all roughly resemble each other and drown each other out" thing.
21:21:19 <ski> bmuk : the question was whether an arrow/morphism `m : A ---> B' was a function from *`A'* to *`B'* or not
21:21:22 <shachaf> I'll do my part by being quiet.
21:21:45 <dolio> dfeuer: Okay. I'm still preoccupied. I can probably investigate more after Thursday.
21:22:19 <dfeuer> Cool, dolio. I hope we can talk about it then. Your solutions sometimes look (to my ignorant eyes) like they fall from the sky.
21:22:20 <shachaf> After Thursday dolio will be postoccupied.
21:22:28 <edwardk> bmuk: suffice it to say reasoning by thinking 'all arrows by function' gives you very very very wrongheaded ideas about category theory that are wrong
21:22:52 <edwardk> bmuk: er that all 'arrows are functions'
21:23:04 <edwardk> bmuk: did i mention they are wrong? ;)
21:23:04 <bmuk> ski, AH okay. That makes it clearer to me. arrows from a -> b are not necessarily functions from a -> b.
21:23:23 <edwardk> bmuk: in the opposite category of Set they go the other direction entirely ;)
21:23:33 <shachaf> bmuk: They're not necessarily functions at all.
21:23:40 <edwardk> bmuk: but there are categories for which there is no function involved at all
21:23:51 <shachaf> edwardk: They're just Chu transformations with transposed matrices!
21:23:57 <edwardk> shachaf: husg =P
21:23:58 <ski> bmuk : and indeed, they are not necessarily functions at all (cf. the matrix example)
21:23:59 <edwardk> er hush
21:24:06 <bmuk> edwardk: I should think about them more as relations? I think that my intuition about what a function is is wrong as well
21:24:10 <edwardk> bmuk: no
21:24:11 <dfeuer> Every partially ordered set can be viewed as a category with at most one arrow between two objects.
21:24:31 <edwardk> think of them as _anything_ you can formally attach objects to on either side that have a meaningful associative composition and identities
21:24:34 * BMeph_ coughs *cough* monoids *cough*
21:24:35 <dfeuer> bmuk, no, BUT. You can "collapse" a category to get a rlation.
21:24:37 <shachaf> Isn't it great how Chu spaces give you all sorts of intuition for complete atomic boolean algebras vs. sets?
21:25:00 <dfeuer> A transitive relation, in fact.
21:25:02 <nshepperd> I like to think of them as literal arrows
21:25:05 <edwardk> bmuk: literally a category is a set of objects, a set of arrows and a way to compose arrows, identity arrows for all the objects.
21:25:15 <edwardk> and some coherence conditions
21:25:23 <nshepperd> with a little tag in the middle of the arc telling me what sort of thing it is
21:25:24 <edwardk> a monoid can be viewed as a category with one object.
21:25:35 <edwardk> so we can take the integers as our arrows. the actual integers. not a function
21:25:39 <edwardk> and define composition to be addition
21:25:53 <edwardk> now 0 is our identity arrow
21:25:55 <edwardk> and we can compose
21:25:57 <ski> bmuk : you can construct a category where the objects are natural numbers, and the arrows from `m' to `n' are all the natural numbers less than or equal to `n - m' (in case that exists, otherwise there are zero arrows from `m' to `n')
21:26:03 <edwardk> 4 is 4, not some function
21:26:12 <edwardk> 4 . 5 = 9 is the result of composition
21:26:17 <ski> bmuk : where are the functions in the arrows here ?
21:26:26 <edwardk> 4 . 0 = 4 = 0 . 4 -- the identity laws hold
21:26:27 <bmuk> edwardk: the monoid example is helping it sink in.
21:26:29 <edwardk> addition is associative
21:26:53 <bmuk> but what is the object itself?
21:27:05 * ski . o O ( "A BA CABA" )
21:27:07 <edwardk> bmuk: the object is a place to hang the arrows. its just a formality
21:27:09 <dfeuer> bmuk, that's not a problem for category theory. Category theory doesn't care.
21:27:26 <prophile> equivalently: what is () in haskell?
21:27:28 <edwardk> bmuk: we have one object, its just a formal set with one inhabitant, all arrows have the same source and target
21:27:42 <shachaf> prophile: No, that's not equivalent at all.
21:27:50 <dfeuer> Well, what the objects are might matter to *you*. They just don't matter to category theory.
21:27:54 <edwardk> prophile: any one object set would do. they are all the same in the eyes of category theory
21:28:20 <ski> edwardk : but obviously `4' is the polymorphic function mapping any isomorphism to its forthfold selfcomposition. see, it *is* a function after all !
21:28:22 <shachaf> In the case of this category we can say that the object is my cat. It still works.
21:28:26 <edwardk> ski: hush
21:28:39 <shachaf> Well, it'd work if I had a cat.
21:28:43 <prophile> we hold these truths to be self-evident: that all one-element sets are created equal
21:29:00 * ski . o O ( "The Joy of Cats" )
21:29:06 <bmuk> haha
21:29:08 <edwardk> prophile: if you can distinguish between one-element sets a category theorist will call you evil ;)
21:29:41 <edwardk> shachaf: the category where all objects are your cat and you have no cat is a different category ;)
21:29:45 <dfeuer> Only if you're working in Set.
21:29:56 * shachaf wonders whether #haskell-overflow would be better for this conversation.
21:30:40 <bmuk> well, if we take what ski said seriously, is it a function? What is the categorical definition for a function? My intuition is that a function is anything that associates things (objects?)
21:30:51 <edwardk> dfeuer: well, there is a notion that if you have two objects that have the same properties / are isomorphic they are in some sense the same object. we speak of 'the' terminal object in a category, even though it is only unique up to isomorphism
21:31:17 <ski> bmuk : there is no categorical definition of functions
21:31:33 <edwardk> bmuk: what ski was saying was that the way that we encode naturals in the lambda calculus is as a function that takes another function and applies it n times.
21:31:42 <shachaf> A function is an arrow in Set, of course.
21:31:47 <edwardk> what he missed was i said integers, so he needs to get fancier with his definition ;)
21:32:07 <edwardk> bmuk: but also the fact that there is some oblique function-like encoding isn't useful or illustrative to the problem at hand
21:32:09 <ski> edwardk : well, i did say it mapped isomorphisms :)
21:32:11 <edwardk> and was just him being a smart-ass ;)
21:32:20 <edwardk> ski: fair, i missed that ;)
21:32:50 <ski> (regarding being a smart-ass, that's fair ;)
21:33:25 <bmuk> So what the arrows actually do to get from one object to another isn't really important in category theory?
21:33:32 <dfeuer> edwardk, what I mean, I think, is that you can lay a category (e.g., Set) on top of a mathematical structure (e.g., set theory); the categorical "view" may illuminate the underlying structure without containing all its details. You know this, of course, far far far better than I, but bmuk may not.
21:33:38 <edwardk> bmuk: in short do not expect there to be a function involved in a morphism, there may be none, there may be two, there may be fifty, but they don't necessarily compose anything like what you expect, you may not even be living enriched on  top of a category that has a notion that looks like set-like functions
21:33:46 <nshepperd> on the previous topic, I think there are homomorphic encryption systems that sort of have return + join but you're limited to fmapping circuits rather than turing machines
21:34:14 <ski> shachaf : yes, but ETCS can't really be considered a definition in category theory, can it ? it's a specific *application/use* of category theory
21:34:30 <dolio> bmuk: In some ways, category theory is about 'composable things' of any type, and the objects are just ways of specifying which of the arrows are allowed to be composed.
21:34:33 <nshepperd> oh wait, not quite
21:34:54 <ski> bmuk : right. what matters is which pairs of arrows compose to which arrows
21:35:38 <ski> bmuk : "internal structure" of the objects is not important, nor is "internal structure" of the arrows
21:35:58 <edwardk> dfeuer: we're basically in violent agreement here. i was merely pointing out that there is a notion that when we talk about 'the' in category theory we're usually only disambiguating it up to isomorphism, to go farther is actually 'semi-formally' referred to as "evil" http://ncatlab.org/nlab/show/principle+of+equivalence -- that is the 'not containing all of its details' that i'm talking about
21:36:09 <ski> bmuk : just like in the definition of a monoid/group, you don't care about how the elements "look on the inside"
21:36:22 <dfeuer> Ah. OK.
21:36:24 <bmuk> dolio: so I am thinking to much about the the workings of the arrows, whereas category theory operates on a level of abstraction above that? No wonder the lecturer glosses over arrows.
21:37:05 <edwardk> bmuk: the arrows and objects themselves will look wildly different in different categories
21:37:10 <shachaf> bmuk: I don't know what it means to talk about "the workings of" arrows.
21:37:19 <shachaf> What are "the workings of" the elements of a monoid?
21:40:24 <bmuk> shachaf: you are right, I'm still trying to wrap my head around it all but I think I have had a break through. I was focusing on examples of categories where arrows are obliquely functions or exhibit function like behavior. By workings of, I mean in the category of all real numbers the arrows could be functions like \x -> x + 1, the workings of the arrows would be the +1-ing. But in a monoid the integers themselves are arrows, so that
21:40:24 <bmuk> is where my analogy breaks down.
21:41:01 <shachaf> bmuk: I'll elaborate on what I said before in #haskell-oveflow if you want.
21:41:08 <bmuk> sure
21:41:10 <edwardk> bmuk: some times they'll be very boring formal affairs, other times they'll have really complicated structure. e.g. a comma category for two functors S : C -> E, T : D -> E has objects that are pairs of objects one c from C, and one d from D and an arrow S c -> T d. Arrows then look like pairs of morphisms, one in C, and one in D, such that you can compose the square you get, etc. these get really rich in structure fast.
21:41:12 <dolio> I think shachaf's matrix example is a good one.
21:42:28 <shachaf> That's the example I was going to elaborate on.
21:42:29 <ski> the homotopy category is also nice
21:42:46 <edwardk> bmuk: the key thing to note is that categories themselves are just a bag of laws and there are lots and lots of examples of them. if you think of a category as a generalization of an order, you get lots of examples, if you think of it like a 'partial monoid' you get others
21:42:59 <edwardk> bmuk: only some of them feel at all set-like
21:43:25 <dolio> Unless you go through significant efforts to jam them into set-like things.
21:43:30 <ski> <http://amathew.wordpress.com/2012/01/26/homotopy-is-not-concrete/>
21:43:57 <edwardk> dolio: right up until you encounter your first non-concrete category, which ski is trying to slip into the discussion ;)
21:43:58 <bmuk> Okay, I am definitely getting that we are dealing with a level of abstraction above what I was operating at.
21:44:14 <dolio> Yeah. But I don't think it's going to be a useful example.
21:44:30 <edwardk> probably not =)
21:44:48 <bmuk> I was about to ask if there are categories that are not at all tangible?
21:45:11 <edwardk> bmuk: anyways suffice it to say there are concrete *ok, well things that aren't 'concrete', but are concrete* counter-examples that can't be mapped to sets.
21:45:22 <bmuk> I grasp that there is a category of cats, a category of cars, a category of integers, etc.
21:45:24 <ski> bmuk : do you consider natural numbers to be tangible ?
21:45:33 <bmuk> ski: yes
21:45:33 * ski has never seen a natural number
21:45:48 <ski> (much less touched one)
21:45:48 * edwardk picks up 2 and hands it to ski. Math will have to do without it for now.
21:45:56 <bmuk> :p
21:46:01 <shachaf> whoa, linear natural numbers?
21:46:16 <edwardk> shachaf: nah, they are affine. you can forget one
21:46:49 <monochrom> "7 ate 9" <-- clearly a demonstration of affinity
21:46:50 <bmuk> I suppose math itself is intangible, it's only because I have been using natural numbers my whole life I think of them as being real.
21:46:53 <ski> shachaf : linearly assumed constructors of a datatype is interesting
21:46:59 <dolio> In fact, I'm really not sure if homotopy is a good example in light of homotopy type theory.
21:47:40 <ski> natural numbers are not real, they may only be *considered* to be real via an appropriate inclusion arrow
21:47:40 <dolio> Because it seems like an example that focuses on the particulars of Set, and not 'things that can be given a functional presentation.'
21:48:02 <dolio> But I don't really know enough to say that definitively.
21:48:17 <athan> wtf? blaze-html can't chain `class_ "..."` declarations and just append their contents?
21:48:21 <shachaf> I,I real transformations
21:48:48 <joelteon> blaze-html is the one that has the monad instance for no reason, right?
21:49:27 <dolio> Like, type theory with non-strictly positive types is not set theoretic (I think), but if you had a category for it, its arrows would be 'functions'. Just not set theoretic functions.
21:49:39 <bmuk> Thank you all for your help, edwardk++, ski++, shachaff++, dolio++
21:49:40 <dolio> Because set theory is not the end all, be all that people like to think it is.
21:49:51 <athan> joelteon: Yep
21:50:05 <edwardk> monochrom: i thought it was 6, 7 ate.
21:50:25 * ski isn't sure lambdabot processes those as `@karma+' commands, in case they're not occuring at the start of a message
21:50:36 <shachaf> bmuk: OK, I'll take that as a no on -overflow. :-)
21:50:38 <dolio> ski: It does.
21:50:41 <ski> ok
21:50:53 <dolio> That's how C/C has such high karma. :)
21:51:08 <ski> @karma C/C
21:51:09 <lambdabot> C/C has a karma of 1004
21:51:09 <bmuk> shachaf: I would love to but it is 1 am and I have a calculus test at 8 am :) tomorrow?
21:51:17 <shachaf> Yes, but the commas prevent them from being interpreted that way.
21:51:20 <ski> @where C/C++
21:51:20 <lambdabot> "C/C++ : A new language for the new Millennium" by Richard Heathfield in 2005-02 at <http://web.archive.org/web/20090421080714/http://www.cpax.org.uk/prg/portable/c/c++/rfe00000.html>
21:51:21 <shachaf> So only dolio got karma.
21:51:33 <bmuk> shachaff++
21:51:33 <dolio> Woo!
21:51:41 <bmuk> edwardk++
21:51:53 <bmuk> ski++
21:51:57 <shachaf> Now everyone except me got karma.
21:52:11 <edwardk> poor shachaff
21:52:16 <bmuk> I said you 3 messages ago lol
21:52:27 <shachaf> edwardk: My /hilight still catches that spelling, which is all that matters.
21:52:28 <ski> shachaff probably needs the karma more than you do
21:52:34 <shachaf> True.
21:52:37 <edwardk> @karma shachaff
21:52:37 <lambdabot> shachaff has a karma of 1
21:52:41 <edwardk> @karma shachaf
21:52:41 <lambdabot> shachaf has a karma of 73
21:52:52 <shachaf> Oh, wait, my karma was artificially inflated by an evil bot user once.
21:52:55 <shachaf> So I don't need any more.
21:52:57 <bmuk> shachaf++
21:53:13 <edwardk> just know that people don't like you more than C/C++
21:53:23 <shachaf> You mean more than C/C.
21:53:23 <bmuk> sorry, my tired brain isn't used to words without 2 trailing fs
21:53:29 <dfeuer> Of course, category theory isn't the end all and be all either. Mathematics is an odd sort of house that grows new foundations in various directions from time to time.
21:53:31 <edwardk> @karma edwardk
21:53:31 <lambdabot> You have a karma of 42
21:53:33 <dolio> edwardk: Now you're part of the problem.
21:53:33 <shachaf> @karma C/C++
21:53:33 <lambdabot> C/C++ has a karma of 1
21:53:37 <edwardk> but you still have more karma than me
21:54:24 <bmuk> @shachaf
21:54:24 <lambdabot> Unknown command, try @list
21:54:34 <bmuk> @karma shachaf
21:54:34 <lambdabot> shachaf has a karma of 74
21:54:34 <ski> dfeuer : obviously type theory is the end-all-be-all
21:54:42 <dfeuer> Pfff.
21:54:53 * ski grins
21:55:02 <bmuk> Goodnight everyone :)
21:55:12 <ski> night, bmuk. dream interesting dreams
21:55:26 <bmuk> about category theory lol
21:55:30 <shachaf> May you live in INVISIBLE TIMES.
21:55:54 <dfeuer> shachaf, you mean between the x and y in xy?
21:55:55 <ski> shachaf : is that like "5 a" ?
21:56:25 <shachaf> ski: More like "5⁢a".
21:56:28 * ski . o O ( "between a number and a lower case letter" )
21:56:46 <edwardk> C/C++--
21:57:01 <shachaf> dfeuer: More like x⁢y.
21:57:05 <ski> @karma C--
21:57:05 <lambdabot> C-- has a karma of 2
21:57:49 <edwardk> speaking of C--, now that Norman Ramsey is at Tufts, is anyone still caring about it as a cross-language thing? or is it just relegated to an obscure GHC'ism now?
21:58:30 <merijn> edwardk: I don't think GHC's Cmm follows the C-- spec anyway?
21:58:44 <edwardk> merijn: it doesn't at last check
21:59:09 <dfeuer> Why not fix the one or the other, then?
21:59:32 <shachaf> Anyway, modal logic.
21:59:43 <dfeuer> No, shachaf. That way lies madness.
22:00:54 <monochrom> @quote monochrom Kripke
22:00:54 <lambdabot> monochrom says: There are truths, damn truths, and Kripke structures.
22:00:58 <monochrom> related!
22:02:32 * relrod should be studying for a test, but is too intrigued by the Contextual Modal Type Theory paper mentioned above. :(
22:03:28 <ski> Beth semantics is cool
22:03:33 <merijn> Is there any testing library framework for running tests that require 2+ processes to run?
22:03:50 <ski> relrod : you know it's more important than a mere test
22:05:15 <relrod> ski: Sure, I know that right now, but will I know that tomorrow when the test is handed out - or even better, when I get the test back? ;)
22:06:25 <relrod> I blame edwardk and shachaf, they talk about cool things and then I end up failing classes because of it. ;)
22:06:52 <relrod> This isn't good :P
22:07:00 <shachaf> relrod: But imagine the hypothetical classes you would be passing!
22:07:07 <edwardk> relrod: well if you want to get off the topic of contextual modal type theory i can offer you other fun things to look up, but that won't get you back to your test ;)
22:07:20 <Enigmagic> edwardk: hasn't he been at tufts for quite a long time?
22:07:32 <edwardk> Enigmagic: and c-- has been dead for quite a long time ;)
22:07:56 <Enigmagic> edwardk: i haven't cared much about it either way ;-)
22:08:30 <relrod> edwardk: well I'm curious what that list would look like - but yes, acting on it would be bad for me right now
22:09:35 <singularai> I have a fairly mechanical question: Is there a way to write a function that takes an argument which is either a member of a class T, or is some type, say Special, and dispatches to functions that will handle each case separately?
22:10:05 <shachaf> singularai: Not really.
22:10:21 <singularai> I'm trying to avoid forcing the function caller to use an ADT
22:10:24 <shachaf> Well, that depends on the exact behavior you're after.
22:10:32 <singularai> writing a new class is expected
22:10:44 <monochrom> perhaps Special is an instance of class T, too
22:10:52 <shachaf> *Is* Special an instance of T?
22:10:54 <singularai> Special can be made an instance
22:11:03 <merijn> singularai: So what's the problem, then?
22:11:04 <singularai> I did that
22:11:07 <shachaf> You could use (Typeable a, T a) => a -> ..., and then check the type.
22:11:19 <singularai> that worked for dispatching things f type T
22:11:21 <shachaf> If you want some strange completely non-parametric behavior for Special.
22:11:22 <Fuuzetsu> friendly reminder to use mempty and <> instead of ++ and [] where possible
22:11:32 <merijn> Fuuzetsu: Why?
22:11:55 <singularai> shachaf: yea, that's exactly the problem
22:12:07 <singularai> Special has a behavior
22:12:09 <Fuuzetsu> to make it much easier to transition to another monoid that doesn't happen to be []
22:12:11 <merijn> Stop wanting bad things :\
22:12:19 <shachaf> singularai: You could add methods to T, maybe.
22:12:21 <Enigmagic> mempty looks so much nicer than [] for lists ..
22:12:23 <singularai> there is a function foo :: Special -> ...
22:12:42 <singularai> and when I make Special implement T
22:12:47 <merijn> Fuuzetsu: There's not a lot of usecases where replacing [] with another monoid is very likely
22:12:55 <singularai> I get an error
22:13:09 <Fuuzetsu> merijn: what, you want to turn all this String crap to Text for me?
22:13:24 <Fuuzetsu> even "" would be better in this scenario
22:13:51 <Fuuzetsu> Data.Sequence is an even better example
22:14:03 <shachaf> Fun fact: T.pack "" generates terrible code compared to T.empty.
22:14:15 <Fuuzetsu> I wish there was ε = mempty in Prelude
22:14:29 <shachaf> So does T.pack "x" compared to T.singleton 'x'
22:14:31 <singularai> so what is this business about using Typeable and checking the type?
22:14:34 <shachaf> T.pack "..." is fine, though.
22:14:56 <shachaf> I sent bos an email about it and how to fix it once, but he never replied.
22:15:02 <dmj`> shachaf: like how bad
22:15:14 <dmj`> just curious
22:15:29 <Fuuzetsu> interesting, I'll try it when I'm less tired
22:15:33 <prophile> unsafePerformIO (launchMissiles) `seq` T.empty
22:15:34 <Fuuzetsu> I don't have any such instances though
22:15:42 <prophile> it's pretty bad
22:16:04 <prophile> I mean just look at those redundant parentheses
22:16:20 <Fuuzetsu> s/redundant //
22:16:41 <monochrom> are we now golfing jokes, too? :)
22:16:43 <shachaf> dmj`: ~1000 lines of assembly?
22:16:56 <shachaf> I don't know how to measure terribleness here.
22:17:30 <Fuuzetsu> what's the patch? did you open a GitHub issue for everyone to see?
22:18:08 <shachaf> The patch is a couple of RULES.
22:18:10 <dfeuer> C-- is dead, but GHC has a live version? Or that's dead too?
22:18:21 <shachaf> I didn't open an issue.
22:18:33 <merijn> dfeuer: GHC doesn't have C--, it has Cmm a C-- inspired but different thing
22:18:37 <shachaf> He wanted a github pull request but I don't do github pull requests.
22:19:02 <Fuuzetsu> do you still have the patch?
22:19:03 <dfeuer> edwardk, you said something recently about illegal Functor instances. I was trying to understand what one of those might look like. Is it a strictness issue?
22:19:03 <ski> @karma Cmm
22:19:03 <lambdabot> Cmm has a karma of 1
22:19:10 <merijn> bos seems reasonably responsive on github, but mailing him doesn't really work out in my experience
22:19:15 <Fuuzetsu> @karma C
22:19:15 <lambdabot> C has a karma of 2
22:19:40 <ski> shachaf : fwiw, why ?
22:19:45 <benzrf> ok bye sleep
22:20:14 <shachaf> ski: GHC generates unpackCString# "..." for strings of length 2 or more.
22:20:19 <ski> dfeuer : consider `instance Functor Maybe where fmap _ _ = Nothing'
22:20:30 <shachaf> text has RULES which match on that and use the text UTF-8 decoder directly.
22:20:37 <Fuuzetsu> I found foldl in this code, should I be calling the cops
22:20:44 <ski> shachaf : nah, the github thing :) (in blah if you prefer)
22:20:47 <shachaf> But GHC generates [] and [x] for strings of length 0 and 1.
22:20:52 <shachaf> Oh.
22:21:29 <dfeuer> ski, that's illegal all right, but also seems insufficiently useful to justify restrictions the way edwardk (I think) was saying are required on rewrite rules.
22:21:54 <dfeuer> Fuuzetsu, what's wrong with foldl?
22:21:57 <xnyhps> https://github.com/bos/text/issues/84 It was fixed.
22:22:08 <ski> dfeuer : well, i didn't see the part of the conversation you're referring to now ..
22:22:12 <shachaf> xnyhps: whoa
22:22:15 <edwardk> dfeuer: data Foo a = Foo Int a; fmap f (Foo x a) = Foo 0 (f a) -- is illegal, it fails fmap id = id, but fmap f . fmap g = fmap (f . g) holds
22:22:17 <Fuuzetsu> dfeuer: it is hitler
22:22:32 <dfeuer> ????
22:22:47 <Fuuzetsu> building up thunks and all that usual gunk
22:22:52 <edwardk> dfeuer: other folks use things like GADTs that track if you've applied an fmap
22:23:13 <edwardk> the GADT case is very common and importantly _isn't_ representational
22:23:34 <dfeuer> edwardk, I don't understand why one would write a functor instance for the former. I don't (yet) understand the latter.
22:23:40 <xnyhps> https://github.com/bos/text/blob/e33c89be4256fdd1c31f39d8a2a63e58e23b0182/Data/Text.hs#L426 for the actual RULE.
22:24:05 <ski> dfeuer : a (working) `Functor' instance for `Foo' could potentially be useful
22:24:07 <edwardk> dfeuer: the post was more that one _could_, and you need to be careful about changing denotation when using rules
22:24:13 <Fuuzetsu> which stage do RULES fire?
22:24:14 <shachaf> xnyhps: Yes, I sent bos an email about it in January and he ignored it.
22:24:22 <xnyhps> Ah.
22:24:35 <shachaf> Oh well.
22:24:37 <edwardk> dfeuer: http://hackage.haskell.org/package/lens-4.4.0.2/docs/src/Control-Lens-Internal-Magma.html#Molten is an 'illegal' functor
22:24:43 <edwardk> dfeuer: but its very useful to me
22:24:58 <Fuuzetsu> edwardk: expect the police at your door within the next 3 minutes
22:25:24 <edwardk> Fuuzetsu: functor police, again?
22:25:30 <Fuuzetsu> they come around often?
22:25:48 <dfeuer> edwardk, I don't know anything about lenses yet :(. What makes it illegal, and, moreover, why isn't there another way to accomplish the underlying goal?
22:26:01 <ski> edwardk : i guess wrapping a `CoYoneda' can be a bit annoying
22:26:05 <edwardk> dfeuer: there actually isn't another way in this case
22:26:06 <trap_exit> anyone built a decent haskell ide on top of atom (github) editor?
22:26:21 <edwardk> though the coyoneda trick works for most cases
22:26:30 <Fuuzetsu> trap_exit: It'd be pretty hard to build something nice on that turd
22:26:38 <shachaf> The point of this type is to look at things you aren't supposed to be able to look at.
22:26:39 <edwardk> its illegal because you can distinguish if i've fmap'd from when i haven't
22:26:43 <ski> dfeuer : it breaks `fmap id = id'
22:26:51 <edwardk> > "hello"^.magma traverse
22:26:53 <lambdabot>  .. <$> Magma 0 'h' <*> (.. <$> Magma 1 'e' <*> (.. <$> Magma 2 'l' <*> (.. <...
22:27:04 <edwardk> that lets me see the fmap as .. <$>
22:27:20 <trap_exit> edwardk: who are you
22:27:21 <dfeuer> edwardk, does it violate it wrt ==, or only =?
22:27:26 <trap_exit> and why do so many hackage libraries bear your name?
22:27:33 <edwardk> dfeuer: it violates both
22:27:48 <merijn> trap_exit: Because edwardk is secretly a cyborg that does nothing but write haskell
22:27:52 <dfeuer> edwardk, so why do you want to call it a Functor?
22:27:53 <merijn> trap_exit: He doesn't need sleep
22:28:00 <dfeuer> merijn++
22:28:03 <edwardk> trap_exit: i do occasionally write in other languages ;)
22:28:23 <merijn> edwardk: Only to prove a point about how it could be done shorter and better in haskell :p
22:28:25 <edwardk> dfeuer: because i need to see what you do with the applicative to introspect with it
22:28:44 <dfeuer> Yes, he has been known to write in English occasionally, and seems to be working on some mysterious new language.
22:28:47 <ski> edwardk : .. are you sure you couldn't use `CoYoneda' here instead ?
22:29:03 <trap_exit> Fuuzetsu: hmm, what exactly do you dislike about atom? it appears to be "emacs with elisp replaced by javascript" to me, which sounds sorta nice
22:29:08 <edwardk> ski: if i use coyoneda i can't show the (.. <$>) shape
22:29:29 <ski> edwardk : oh, so you *do* want to show that -- that wasn't evident
22:29:37 <Fuuzetsu> trap_exit: it's a thing in a browser written and extended in JavaScript, what exactly is there to like?
22:29:47 <edwardk> ski: the point of it is to introspect and show the shape of the traversal epsilon edges included
22:29:57 <merijn> Fuuzetsu: You mean extended in haskell!
22:30:03 <Fuuzetsu> last time I heard, it had trouble with regex in fairly small files because JavaScript is actually, contrary to what some people say, not fast
22:30:05 <edwardk> ski: it is absolutely an illegal applicative, but its very useful ;)
22:30:05 * merijn mumbles something about ghcjs
22:30:06 <dfeuer> edwardk, I don't know what that means, but if you only need to worry about that "under the hood" for some efficiency purpose, why would it violate == and/or break badly if rewritten by RULES?
22:30:34 <Fuuzetsu> merijn: could just be hacking Yi instead!
22:30:48 <shachaf> > foldMap N [1..5]
22:30:49 <lambdabot>  N 1 ◇ (N 2 ◇ (N 3 ◇ (N 4 ◇ (N 5 ◇ ε))))
22:30:52 <edwardk> dfeuer: the problem is this. if your role isn't representational then an illegal fmap goes from 'oh that isn't nice' to 'zomg, segfault'
22:31:05 <dfeuer> trap_exit, is Javascript any better than Emacs Lisp? Scheme is the obvious language replacement there. Edwin died, sadly, but I hear there's one using Guile.
22:31:12 <c74d> Yi is… “Emacs with ELisp replaced by Haskell”?
22:31:21 <dmj`> trap_exit: did you see this... https://atom.io/packages/ide-haskell
22:31:44 <Fuuzetsu> c74d: no, it's an editor in Haskell which borrows some features from emacs
22:31:55 <edwardk> dfeuer: there are levels of bad
22:32:00 <Fuuzetsu> AFAIK the vim keymap is more complete than the emacs one anyway
22:32:08 <Fuuzetsu> I don't know where people get the ‘it's emacs’ impression
22:32:19 <dfeuer> edwardk, that's a little beyond me for right now, but could/should the RULES engine be modified to respect roles?
22:32:27 <ski> edwardk : i suppose something like Mercury's quotient types and erratically nondeterministic pattern-matching on the data constructors for those would be useful here ..
22:33:01 <edwardk> dfeuer: my point was if you are going to write RULES the rules shouldn't change semantics of the code someone writes, no matter if they write an instance you disagree with or not
22:33:11 <trap_exit> dmj`: this looks nice; are you involved in atom/ide-haskell ?
22:33:45 <edwardk> dfeuer: so like it or not RULES for rewriting fmap id and the like probably should be written on a case by case basis. to do otherwise is unsound. it violates the expectations of things like safe haskell, etc.
22:33:55 <ski> dfeuer : i think the Riastradh still uses it
22:34:05 <dmj`> trap_exit: no, I use emacs haskell-mode, guis slow you down imo, using a mouse etc.
22:34:14 <edwardk> dfeuer: this sucks for optimization, yes, but it never lies.
22:34:14 <dfeuer> ski, what is a Riastradh?
22:34:27 <merijn> Does anyone know if updating a candidate for a non-existent package effectively "claims" that package name?
22:35:10 <ski> dfeuer : author of <https://mumble.net/~campbell/blag.txt>, founder of #scheme
22:35:25 <dfeuer> edwardk, it seems to me that you are the one lying when you make a Functor instance that does not obey the laws!
22:35:32 <dmj`> goodnight
22:35:54 <edwardk> dfeuer: and my point is that there is a difference between writing an instance and having behavior change silently from what you wrote
22:36:26 <edwardk> dfeuer: and there are cases where if you aren't careful the distinction you are trying to drive isn't just a 'hey its incorrect' but can lead to 'hey this code segfaults'
22:36:51 <edwardk> that shouldn't ever be the case where someone writing code that violates a law leads to that sort of behavior
22:36:54 <rusk101> hello everybody. quick question.
22:37:07 <rusk101> How to make [1,2] == [2,1] return True instead of False
22:37:41 <edwardk> with just RULES you won't be able to force it, but if you aren't careful that is why we need to respect non-representational roles
22:37:45 <shachaf> Don't do it, rusk101!
22:37:46 <rusk101> my purpose is to remove duplicates
22:37:56 <merijn> rusk101: Use Data.Set.fromList and compare sets
22:38:09 <edwardk> and there are legitimate usecases for performance that folks use things like fmap nodes or lift nodes in their monads. they are considering a thing only up to some quotient on the type they are defining
22:38:13 <merijn> > S.fromList [1,2] == S.fromList [2,1]
22:38:15 <lambdabot>  True
22:38:17 <dfeuer> edwardk, with just RULES you won't be able to force a segfault, you mean?
22:38:53 <pqmodn> rusk101: just to be clear, you want [1,1,1,1] == [1], too right?
22:39:05 <merijn> rusk101: Also, removing duplicates is just toList . fromList
22:39:17 <jle`> > let [1,2] == [2,1] = True in [1,2] == [2,1]
22:39:19 <lambdabot>  True
22:39:28 <merijn> > S.toList . S.fromList $ [1,2,3,4,1,1,1,2,3,4]
22:39:29 <lambdabot>  [1,2,3,4]
22:39:36 <shachaf> Removing duplicates and (non-stable) sorting.
22:39:53 <shachaf> Er, I guess non-stable sorting doesn't make sense when you're removing duplicates.
22:40:00 <shachaf> But the point is that an arbitrary duplicate is removed.
22:40:08 <merijn> jle`: That's not very helpful
22:40:14 <rusk101> Im working with equivelance classes right now and am writing a partition of an equivelence class function... its all done. but it returns [1,2] and [2,1], but i just want [1,2] thats why im asking
22:40:18 <jle`> stability might imply that the removed items are deterministic based on the initial ordering
22:40:37 <merijn> rusk101: Like I said, use Set instead of [] if you want unordered and no duplicates
22:40:45 <rusk101> like removeDup [[1,2],[2,1]] should equal [[1,2]]
22:41:00 <edwardk> dfeuer: yes. my point is that almost all rules right now that we supply don't change the semantics of your code beyond introducing extra cases that successfully terminate (or occasionally, badly, introduce non-termination for something that terminated). when they change the _answers_ they become highly suspect. we have a few that change answers. realToFrac for Float/Double, etc. that are really really bad ideas
22:41:02 <jle`> rusk101: so what are the equivalence criteria?
22:41:09 <edwardk> i don't want to double down on that corner of the design space
22:41:12 <shachaf> rusk101: Use your own function instead of (==)
22:41:13 <dfeuer> edwardk, that "quotient" is what I meant about == vs =. In a "well-behaved" implementation of that sort, rewriting something could potentially harm performance, but not cause a segfault. Can you explain how something like fmap id ==> id  or  m>>=return ==> m  can ahrm performance though?
22:41:20 <jle`> same elements, different order?  same number of elements?
22:41:22 <edwardk> so that you get different answers if you pass id or if you pass another different identity functions
22:41:58 <rusk101> @edwardk i tried using the intersection function.. i.e. inters x y == [] but that didnt work
22:41:58 <lambdabot> Unknown command, try @list
22:42:08 <rusk101> emoveDuplicates :: Eq a => [[a]] -> [[a]] removeDuplicates [] = [] removeDuplicates (x:xs) = x : removeDuplicates (filter (\y -> not (x == y)) xs)
22:42:32 <ski> rusk101 : "a partition of an equivelence class function" ?
22:42:37 <rusk101> instead of having x==y i wrote inters x y /= [] or whatever
22:42:43 <edwardk> dfeuer: the issue is it can change the answer the code gives
22:43:04 <edwardk> dfeuer: and the answer can now depend on whether the rule was able to see to fire
22:44:11 <edwardk> dfeuer: it sucks, but you're advocating for a situation where the behavior of currently defined if slightly hinky code becomes less defined
22:44:36 <dfeuer> Well, we currently have that for zip and zipWith, which I've submitted a patch about. But I am, in principle, in favor of breaking hinky code.
22:45:01 <edwardk> and i am in principle in favor of not randomly changing the semantics of code that people write
22:45:15 <dfeuer> *nod*
22:45:41 <edwardk> i'm okay with the cases where we just make things more well defined
22:45:51 <dfeuer> edwardk, however much I may disagree with that position (at the moment, anyway), I do respect it.
22:46:37 <edwardk> and most fusion cases wind up falling into that grey area, where most of the time they just make code a little more defined (or a little less), and just make it faster
22:47:01 <ski> there are arguments against implicitly making some things more well defined
22:47:07 <edwardk> ski: agreed
22:47:34 <edwardk> but weighed against several x performance improvements across the entire ecosystem its a hard side of the debate to choose
22:47:53 <dfeuer> edwardk, well, one fusion thing that might or might not lead anywhere actually seems to need  m>>=return ==> m.  I guess that rule could be implemented separately for every single well-behaved monad....
22:47:58 * ski nods
22:48:14 <rusk101> Can someone take a look please. Its about removing duplicate lists e.g. [1,2] [2,1] are duplicates http://lpaste.net/111069
22:48:15 <shachaf> dfeuer: What's the motivation for all the things you've been doing with RULES and what not?
22:48:30 <edwardk> dfeuer: implementing it individually is fine, offering people a recipe for how to do such an implementation i also have no objection to
22:48:49 <edwardk> implementing it unilaterally on the other hand offers nobody any way to opt out
22:48:59 <ski> rusk101 : how have you defined your `Set' ?
22:49:10 <dfeuer> edwardk, your comments on my proposed zip/zipWith patch would be appreciated. It makes zip and zipWith *less* well defined so as to avoid essentially unpredictable changes in definedness due to non-confluent rules.
22:49:15 <rusk101> type Set = [Int]
22:49:32 <dfeuer> edwardk, all right.
22:49:32 <rusk101> sorry
22:49:35 <edwardk> dfeuer: email me the ticket info and i'll follow up when i get a chance
22:49:35 <rusk101> forgot to put that in
22:49:45 <dfeuer> shachaf, I'm mostly trying to make you question my motivations.
22:49:56 <rusk101> i know the inters function works
22:50:31 <shachaf> I have a working theory already.
22:50:35 <dfeuer> Sorry, shachaf, a little cynical perhaps. Mostly, I'm trying to learn stuff.
22:50:52 <rusk101> ski: its type Set = [Int]
22:51:05 <ski> rusk101 : yeah, i saw it the first time :)
22:51:07 <ski> rusk101 : what's `removeDuplicates' supposed to do ?
22:51:42 <rusk101> removeDuplicates [[1],[2],[3,4],[4,3]] = [[1],[2],[3,4]]
22:52:03 <rusk101> [3,4] == [4,3] -> must be true
22:52:05 <ski> rusk101 : and `removeDuplicates [[0,1],[1,2]]' ? or is that inadmissible ?
22:52:15 <rusk101> yes
22:52:26 <ski> yes, it's inadmissible ?
22:52:36 <dfeuer> > nub "shachaf"
22:52:37 <lambdabot>  "shacf"
22:52:40 <shachaf> Thanks.
22:52:49 <rusk101> but i would rather have the intersection function == [] as a condition
22:54:50 * ski isn't sure whether rusk101 was confirming the second question or not
22:55:50 <eazar001> rusk101: there is a set type
22:55:54 <rusk101> yes.. its inadmissible. as it would never occur in my universe.
22:55:55 <eazar001> Data.Set
22:56:03 <eazar001> import Data.Set
22:56:18 <eazar001> just throwing that out there
22:56:20 <shachaf> dolio: I think some of the question might be what the arrows in your category are.
22:56:20 <rusk101> eazar001: i dont follow?
22:56:22 <Fuuzetsu> @src (<$)
22:56:23 <lambdabot> (<$) = (<$>) . const
22:56:39 <eazar001> i noticed you have some type synonym
22:56:45 <eazar001> type Set = [Int] or something
22:56:47 <Fuuzetsu> @src ($>)
22:56:47 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
22:56:49 <eazar001> https://www.haskell.org/ghc/docs/latest/html/libraries/containers-0.5.5.1/Data-Set.html
22:57:04 <dolio> shachaf: ?
22:57:48 <rusk101> I just dont understand why the logic in my algorithm is not working... http://lpaste.net/111069
22:57:53 <dfeuer> > rd  [[1],[2],[3,4],[4,3]]
22:57:54 <lambdabot>  [[1],[2],[3,4]]
22:58:26 <eazar001> so your removeDuplicates ...
22:58:32 <eazar001> is supposed to do this :
22:58:39 <eazar001> > nub [1,1,1,2,3]
22:58:41 <lambdabot>  [1,2,3]
22:58:42 <eazar001> ?
22:58:43 <dfeuer> rusk101, let's take this to #haskell-beginners I think.
22:59:11 <rusk101> nub [1,1,1,2,3]
22:59:22 <rusk101> > nub [1,1,1,2,3]
22:59:24 <lambdabot>  [1,2,3]
22:59:29 <shachaf> dolio: E.g. maybe an arrow : A -> B means "from ⊦ A you can conclude ⊦ B" and maybe that's different from "A -> B", whatever that is.
22:59:33 <eazar001> @src nub
22:59:33 <lambdabot> nub = nubBy (==)
22:59:36 <shachaf> I vaguely remember an issue like this in linear logic.
22:59:39 <eazar001> @src nubBy
22:59:39 <lambdabot> nubBy eq []     = []
22:59:39 <lambdabot> nubBy eq (x:xs) = x : nubBy eq (filter (\ y -> not (eq x y)) xs)
22:59:47 <eazar001> that's the source code ^
22:59:55 <merijn> eazar001: Don't trust @src
23:00:03 <eazar001> merijn: no?
23:00:06 <rusk101> yes
23:00:07 * c74d wonders whence the name `nub` came
23:00:13 <eazar001> rusk101: you can do hooogle also
23:00:17 <eazar001> c74d: nub means essence
23:00:18 <shachaf> The English meaning of the word.
23:00:19 <rusk101> but [1,2] is not equal to [2,1] so that doesnt work
23:00:24 <dfeuer> I think this discussion is better suited to #haskell-beginners
23:00:29 <eazar001> the essence, the true nature of something, blah blah blah
23:00:30 <merijn> eazar001: @src is just a text file database, a lots of it's code is not how things are actually implemented
23:00:30 <rusk101> thats why im using the intersection to be null as a condition
23:00:31 <c74d> huh
23:00:32 <eazar001> =]
23:00:34 <dfeuer> I will join you there.
23:00:41 <levi> c74d: "That's the nub of it"
23:00:47 <eazar001> merijn: hmmm, i always thought they were siphoned from hoogle or whatever
23:00:52 <eazar001> merijn: alright, i'll remember that
23:01:26 <dolio> shachaf: If you can deduce ⊢ B from ⊢ A, I think that is [](A -> B)
23:02:20 <dolio> The problem with fmap in necessity is that A -> B deduced in some context doesn't mean that A -> B necessarily holds.
23:02:21 <eazar001> rusk101: well here is a more trustworthy source i guess ... http://hackage.haskell.org/package/base-4.7.0.1/docs/src/Data-List.html#nub
23:02:25 <ski> dolio : hm, i don't think that sounds right ..
23:03:15 <dolio> So you aren't at license to promote some 'local' A -> B to work on global things.
23:03:25 <shachaf> Well, we do have [](A -> B) -> ([]A -> []B)...
23:03:32 <dolio> Right.
23:04:17 <copumpkin> :k [](a -> b) -> ([]a -> []b)
23:04:18 <lambdabot> Not in scope: type variable ‘a’
23:04:18 <lambdabot> Not in scope: type variable ‘b’
23:04:18 <lambdabot> Not in scope: type variable ‘a’
23:04:26 <copumpkin> :k forall a b. [](a -> b) -> ([]a -> []b)
23:04:27 <lambdabot> *
23:04:34 <copumpkin> sweet, GHC supports modal logic!
23:04:37 * hackagebot markdown 0.1.11 - Convert Markdown to HTML, with XSS protection  http://hackage.haskell.org/package/markdown-0.1.11 (MichaelSnoyman)
23:05:46 <edwardk> dfeuer: one usecase that arises for me in practice is that i have code that relies on the fact that two runs through a set of >>='s with _different monads_ get the same shape information
23:05:46 <ski> dolio : being able to deduce ⌜⊢ B⌝ from ⌜⊢ A⌝ would amount to being able to deduce ⌜⊢ ◻ A → ◻ B⌝, i think ?
23:08:36 <dolio> ski: That one's more likely, I guess.
23:09:19 <dolio> I wouldn't be surprised if deducing ⊢ B from ⊢ A meant you could deduce ⊢ A -> B.
23:10:03 <trap_exit> where can I read more on the philosophy of "if you get the data structures right, everything else falls into place" ? and how can I optimize my brain to think in this manner ?
23:11:19 <ski> dolio ?
23:12:23 <dolio> What is the question?
23:13:54 <merijn> trap_exit: Practice, practice, practice.
23:14:10 <ski> dolio : i don't see why `A' being provable in the empty context implying that `B' being provable in the empty context would yield that `A -> B' would be provable in the empty context
23:14:26 <trap_exit> merijn: you know, there's a book "introduction to algorithms"
23:14:33 <trap_exit> one needs a new book "introduction to data type modeling in Haskell"
23:15:07 <merijn> trap_exit: Read Okasaki and Functional pearls
23:15:13 <dfeuer> dolio, if |- B is provable, then it's provable. |- A is irrelevant.
23:15:29 <dfeuer> I believe.
23:15:37 <dolio> ski: It's very much like the rule for implication in non-contextual natural deduction.
23:16:30 <ski> dfeuer : i don't follow
23:17:23 <dfeuer> ski,  |- B  stands entirely on its own. How you may have arrived at it does not matter at all.
23:17:35 <edwardk> dfeuer: my experience with trying to catch dolio out on stuff is that inevitably i missed whatever more subtle point he was trying to make ;)
23:17:37 <ski> dolio : when you said ⌜⊢ B⌝, i thought you meant being able to deduce it from no assumptions
23:17:53 <ski> dfeuer : i don't see how what you're talking about is related to what i was talking about
23:17:56 <dfeuer> edwardk, that may be.
23:18:11 * dfeuer goes back under his rock.
23:18:24 <ski> dfeuer : "it" being ⌜B⌝
23:19:42 <dfeuer> Sorry, ski, I missed some context.
23:20:10 <trap_exit> merijn: are you in the sf bay area? I'd like to buy you a drink sometime to chat over haskell
23:20:13 <ski> dfeuer : i was talking about whether (⌜⊢ A⌝ implies ⌜⊢ B⌝) would yield ⌜⊢ A → B⌝
23:21:00 <merijn> trap_exit: Luck has it, that I actually am for the rest of the year. Incidentally, there's a haskell meetup this Thursday in Mountain View (if I remember the date correctly)
23:21:03 <dfeuer> ski, I don't know anything about modal logic, but what does that "implies" mean?
23:21:09 <dolio> ski: In natural deduction without contexts, the premise for the introduction rule of implication is 'there is a deduction from A to B'. At least in the treatments I've seen.
23:21:21 <trap_exit> merijn: meetup.com link?
23:21:34 <dolio> So it wouldn't surprise me if a similar thing still worked when you use contexts (which are better in the first place).
23:21:41 <dolio> But it might not be true.
23:21:52 <merijn> trap_exit: http://www.meetup.com/haskellhackersathackerdojo/events/202637092/
23:22:33 <eazar001> interesting i've never been to a "haskell meet-up" before
23:22:56 <ski> dolio : yes, you're talking about Prawitz-style ND
23:23:32 <dolio> ski: Actually...
23:23:37 <ski> dolio : however, "there is a deduction from A to B" doesn't suppose there's a premise-less deduction of "A"
23:24:24 <dolio> Take your deduction from ⊢ A to ⊢ B, modify it so that it's a deduction from A ⊢ A to A ⊢ B, then cap it at the end with the identity rule and implication introduction.
23:24:27 <jle`> is there no xor operator on Bool in base?
23:24:33 <dolio> Maybe that doesn't work when modality is introduced, though.
23:25:24 <ski> dolio : well, necessity-intro says that if ⌜⊢ A⌝, then ⌜⊢ ◻ A⌝
23:25:26 <dolio> If your original deduction didn't use necessities at all, it'd probably work, though.
23:25:53 <supki> jle`: (/=)
23:26:00 <jle`> :P
23:26:03 <ski> but you can't do that if you add ⌜A⌝ to the left of the turnstile
23:26:08 <jle`> one that conveys more of the intent to the reader
23:26:46 <dolio> I didn't add A to the left of the turnstile on the result.
23:26:55 <dolio> The result is ⊢ A -> B.
23:27:50 <ski> hm, perhaps one should say that ⌜⊢ A⌝ means slightly different things in Gentzen-style ND vs. Prawitz-style ND ?
23:28:04 * ski isn't sure
23:28:25 <dolio> Does Prawitz-style even have ⊢ A?
23:28:35 <dolio> Does it mean the same as A with a bar above it?
23:28:40 <dfeuer> jle`, just import Data.Bits if you want one called xor.
23:29:02 <dfeuer> > Data.Bits.xor True False
23:29:04 <lambdabot>  True
23:29:15 <jle`> dfeuer: ah, nice :)
23:29:34 <jle`> i think i'll just introduce xor = (/=) somehwere in the file
23:30:04 <dfeuer> Data.Bits *is* in base.
23:30:13 <ski> dolio : the bar is distinct from the ⌜⊢⌝
23:30:37 <ski> dolio : sometimes in Prawitz-style, ⌜⊢ A⌝ would be written ⌜A true⌝
23:30:57 <jle`> ah.  it seems that it is :)  thanks :D
23:31:12 <dolio> Oh. If you have multiple sorts of judgments?
23:31:31 <jle`> i guess xor isn't typically used as a logical connective?
23:32:09 <merijn> um, wow, the people uploading in the testing category of Hackage are a bit...overzealous, aren't they? We have 140 testing libraries? >.>
23:32:54 <edwardk> merijn: you should write tests that they all successfully test stuff
23:33:05 <edwardk> merijn: then submit that into the testing category
23:33:29 <jle`> that sounds like it would go in the test-meta category
23:33:46 <jle`> meta-testing
23:33:54 <edwardk> meh, we could survive test-in-test ;)
23:34:05 <merijn> Of course, none of the 140 appear to do what I need >.>
23:34:06 <jle`> once merijn releases such a library then we can finally have the meta-meta-testing category
23:34:20 <dfeuer> jle`, not so much, I don't think. People use ->, but Haskell uses that for other things. So Haskell just uses < for the Boolean version.
23:34:29 <dolio> ski: Anyhow, whatever. The implication was that a proof starting at ⊢ A and ending at ⊢ B would, in a non-modal logic, be modifiable to add an irrelevant A premise on the left of the judgment. Then A ⊢ A is an axiom, and you can deduce ⊢ A -> B from A ⊢ B.
23:34:40 <jle`> today i realize that logical implication is <
23:35:15 <dolio> So you can deduce ⊢ A -> B if you can deduce ⊢ B from ⊢ A. But that probably no longer works once necessity is part of your logic.
23:35:21 <jle`> > liftA2 (<) [False,True] [False,True]
23:35:23 <lambdabot>  [False,True,False,False]
23:35:34 <jle`> wait, this doesn't sound right
23:35:41 <dfeuer> jle`, that actually applies rather more broadly, though I don't know if it applies to crazy stuff like dolio and ski are talking about.
23:36:26 <ski> dolio : hm. now that i'm thinking about it, i think this is more about the difference between Gentzen-style and Prawitz-style, than about difference between non-modal and modal
23:36:42 <jle`> > liftA2 (<=) [False, True] [False, True]
23:36:43 <lambdabot>  [True,True,False,True]
23:36:47 <jle`> ok that sounds more right
23:36:55 <dolio> ski: I'm not even sure you could do modal logic in Prawitz style.
23:36:59 <dfeuer> jle`, yeah, you caught me :P
23:37:12 <jle`> :P
23:37:19 <dolio> How would you state the condition?
23:37:21 <jle`> its fortunate beucase <= looks more like an arrow than <
23:37:33 <dfeuer> jle`, yeah, but it's "backwards".
23:37:35 <ski> dolio : i think i've seen it, with extra "boxes" added in the inference tree
23:37:42 <dolio> Ah.
23:38:01 <ski> Hughes & Creswell has that in a chapter, i think
23:38:03 <dolio> I don't like Prawitz anyway. Having a proof tree as a hypothesis just seems wrong.
23:38:07 <jle`> we can always have (-->) = (<=)
23:38:24 <jle`> or impl = (<=) in Data.Bool
23:38:36 <ski> (no, not that Hughes)
23:38:53 <dfeuer> jle`, if you're going to go to the trouble, I think you should probably support partial orders.
23:39:05 <jle`> but this is just logical connectives
23:39:08 <jle`> on Bool
23:39:22 <dfeuer> jle`, Bool is just the least interesting Boolean lattice.
23:39:39 <jle`> but we have && and ||, it seems we might as well go all the way ;_;
23:40:02 <dfeuer> --> would make perfect sense in some representation of intuitionist logic or whatever.
23:40:23 <jle`> i guess making --> monomorphic would be a shame
23:40:56 <dfeuer> jle`, I think the answer is   class Logic ......  or something.
23:41:13 <jle`> yeah, i've seen it proposed a few times
23:41:15 <dfeuer> There probably is one already.
23:41:19 <ski> "A new introduction to Modal Logic" by G. E. Hughes,M. J. Creswell in 1996
23:41:56 <jle`> what would xor be in curry-howard?
23:42:19 <jle`> ...is a question i would probably be able to answer myself
23:42:28 <ski> dolio : the inconsistent boolean lattice isn't interesting ?
23:42:36 <ski> er
23:42:39 <ski> dfeuer ^
23:44:36 <augur> jle`: it would be xor!
23:44:54 <augur> data Xor a b = Left a (b -> Void) | Right (a -> Void) b
23:45:53 * ski . o O ( `data Or a b = Left a (Not b) | Both a b | Right (Not a) b' )
23:48:12 <jle`> i feel like that should be isomorphic to data Either a b = Left a | Right b
23:48:14 <jle`> but
23:48:40 <jle`> it doesn't look like it is
23:48:44 <jle`> maybe something about my understanding is very off
23:49:05 <dolio> Or is constructively stronger.
23:49:24 <dolio> If I'm not mistaken.
23:53:04 <nshepperd> I suppose that f :: a -> Void, if a is unoccupied, is the total function matching no constructors?
23:54:15 <shachaf> Well, I wouldn't use the word "matching".
23:54:34 <shachaf> But it's true that it doesn't match on any constructors.
23:57:09 <nshepperd> though I don't think ghc lets you write a function without any binding, so you just write f x = error "absurd"
23:57:14 <nshepperd> or something like that
23:58:03 <simpson> f = unsafeCoerce -- yolo
23:58:05 <nshepperd> if for some reason you wanted to actually build a value of type Xor a b
23:58:10 <shachaf> GHC has EmptyCase now.
23:58:16 <shachaf> f x = case x of {}
23:58:54 <shachaf> Anyway, that sounds a lot more like f :: Void -> a
23:59:06 <shachaf> The implementation of f :: A -> Void for some specific A depends on A.
