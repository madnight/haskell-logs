00:01:48 <merijn> Cleerly this means we need polykinded functor in addition to polykinded categories :p
00:06:18 <nshepperd> you could write data BinaryB b = MSB | Zero b | One b
00:06:37 <nshepperd> and then make Binary = Mu BinaryB = BinaryB Binary
00:06:53 <nshepperd> and then fold over it with `cata`
00:07:02 <ezyang> that would promote to 'Zero :: forall (k :: *) -> BinaryB k, I think
00:07:32 <nshepperd> (and BinaryB would be a Functor)
00:07:40 * hackagebot io-streams 1.2.0.0 - Simple, composable, and easy-to-use stream I/O  http://hackage.haskell.org/package/io-streams-1.2.0.0 (GregoryCollins)
00:07:40 * hackagebot openssl-streams 1.2.0.0 - OpenSSL network support for io-streams.  http://hackage.haskell.org/package/openssl-streams-1.2.0.0 (GregoryCollins)
00:07:48 <jle`> welcome back hackagebot
00:08:17 <nshepperd> but that's basically equivalent to just using a regular list of bits
00:16:14 <yyttr3> If  I define data Binary = MSB | Zero Binary | One Binary, ghc defined Zero a Binary -> Binary, but I can't use it as a function in normal contexts.
00:16:24 <yyttr3> I can't refer to Zero by it'self.
00:17:16 <ezyang> yes you can, e.g. 'let f = Zero in f MSB'
00:17:20 <sopvop> why do hpc .mix files disappear from dist/hpc/mix ?
00:17:39 <ezyang> your actual problem is confusion between term-level and type-level functions
00:18:11 <yyttr3> What is the difference?
00:18:19 <yyttr3> It's not a type constructor
00:18:24 <vanila> yyttr3, Yes you can
00:18:31 <vanila> @let data Binary = MSB | Zero Binary | One Binary
00:18:32 <lambdabot>  .L.hs:165:1:
00:18:32 <lambdabot>      Multiple declarations of ‘Binary’
00:18:32 <lambdabot>      Declared at: .L.hs:161:1
00:18:32 <lambdabot>                   .L.hs:165:1
00:18:32 <lambdabot>  
00:18:35 <vanila> @undef
00:18:35 <lambdabot> Undefined.
00:18:36 <vanila> @let data Binary = MSB | Zero Binary | One Binary
00:18:38 <lambdabot>  Defined.
00:18:47 <vanila> > map Zero [MSB, MSB, One MSB, MSB]
00:18:48 <lambdabot>  No instance for (GHC.Show.Show L.Binary)
00:18:48 <lambdabot>    arising from a use of ‘M7700759620543623943892.show_M7700759620543623943892’
00:18:48 <vanila> for example
00:18:52 <vanila> hmy
00:18:59 <vanila> you need deriving Show but it will work
00:19:03 <yyttr3> Interesting/
00:19:09 <vanila> @undef
00:19:09 <lambdabot> Undefined.
00:19:13 <vanila> @let data Binary = MSB | Zero Binary | One Binary deriving Show
00:19:15 <lambdabot>  Defined.
00:19:16 <vanila> > map Zero [MSB, MSB, One MSB, MSB]
00:19:18 <lambdabot>  [Zero MSB,Zero MSB,Zero (One MSB),Zero MSB]
00:19:44 <yyttr3> I tried to defined a function flip:    flip Zero = One
00:19:54 <yyttr3> Then I got th error, not in scope: Data constructor
00:20:22 <vanila> yyttr3, what type should flip have?
00:20:41 <yyttr3> flip :: ((Binary -> Binary) -> (Binary -> Binary))
00:20:46 <vanila> hmm
00:21:25 <vanila> yyttr3, that's really hard because the input function  (Binary -> Binary)  could be almost any function
00:21:45 <nshepperd> you can't pattern match on functions
00:21:56 <vanila> yyttr3, there's basically no way to implement this
00:22:01 <yyttr3> I know, but I was also wondering if there was a way to restrict input further.
00:23:01 <yyttr3> No, because to make a binary values you have  Zero . Zero . One $ MSB, so if I apply a (Binary -> Binary) on Zero, it doesn't have to be Zero or One
00:23:21 <yyttr3> If it's Zero . One it should still work out.
00:23:34 <yyttr3> Or anything else really, because the types match
00:24:30 <nshepperd> > let flip (Zero b) = One b; flip x = x in (flip . Zero) MSB
00:24:32 <lambdabot>  One MSB
00:24:47 <yyttr3> Zero . shiftLeft . One . Zero $ MSB ---> Zero . Zero . One . MSB
00:24:57 <yyttr3> So it is possible to implement.
00:25:26 <nshepperd> well actually you can do
00:26:04 <yyttr3> Zero . Zero . One . Zero $ MSB was the output, sorry
00:26:38 <vanila> there is a horrible way to implement flip using undefined which im not even going to go into
00:26:41 <nshepperd> > let flip f x = case f x of { Zero b -> One b; One b -> Zero b; MSB -> MSB } in map flip [One, Zero, Zero, One] <$> [MSB]
00:26:43 <lambdabot>  Couldn't match expected type ‘L.Binary -> b’
00:26:43 <lambdabot>              with actual type ‘[L.Binary -> L.Binary]’
00:27:08 <vanila> oh that's much much nicer
00:27:20 <nshepperd> whoops, should have used <*> there
00:27:24 <nshepperd> but that works anyway
00:28:09 <nshepperd> > let flip f x = case f x of { Zero b -> One b; One b -> Zero b; MSB -> MSB } in map flip [One, Zero, Zero, One] <*> [MSB]
00:28:11 <lambdabot>  [Zero MSB,One MSB,One MSB,Zero MSB]
00:29:28 <yyttr3> I dont want flip :: (Binary -> Binary) -> Binary, that doesn't make sense.
00:29:44 <yyttr3> flip :: (Binary -> Binary) -> (Binary -> Binary)
00:29:51 <nshepperd> > :t let flip f x = case f x of { Zero b -> One b; One b -> Zero b; MSB -> MSB } in flip
00:29:53 <lambdabot>  <hint>:1:1: parse error on input ‘:’
00:30:00 <nshepperd> :t let flip f x = case f x of { Zero b -> One b; One b -> Zero b; MSB -> MSB } in flip
00:30:01 <lambdabot> (t -> Binary) -> t -> Binary
00:30:59 <nshepperd> heh, free polymorphism
00:31:15 <yyttr3> Interesting. Why must Zero have a value attached to it? Why can't I treat it independently as a function?
00:32:01 <yyttr3> It acts as a type constructor in some ways and a function in others.
00:32:05 <ski> yyttr3 : you can, but you can only match on fully applied data constructors
00:32:24 <ski> not "type constructor". it's a "data constructor"
00:32:53 <yyttr3> I obviously never learned the distinction.
00:33:14 <ski> in the data type declaration
00:33:15 <ski>   data Binary = MSB | Zero Binary | One Binary
00:33:29 <ski> `Binary' is a (nullary) type constructor
00:33:40 <ski> `MSB' is a (nullary) data constuctor
00:33:51 <ski> and `Zero',`One' are (unary) data constructors
00:34:54 <ski> you can only concretely match values of type `Binary' on patterns of the shape `MSB' or `Zero <pat>' or `One <pat>', where `<pat>' would in turn be any pattern for `Binary' (iow of one of the three former forms)
00:35:22 <ski> in addition, you can always use a variable, and also the `_' wildcard, as a pattern, regardless of the type of value
00:35:43 <ski> (and you can also always use `<var> @ <pat>', with `<var>' any variable name)
00:36:06 <yyttr3> I see, so data constructors can't be passed to functions unqualified
00:36:21 <ski> in the examples above, in the `case'-expression, the patterns used were : `Zero b',`One b' and `MSB'
00:36:37 <ski> (and `b' here is a variable name, that matches any value of type `Binary')
00:36:48 <yyttr3> I just figured that since it had type Bin -> Bin, I could treat it as a normal function without applying it.
00:37:00 <ski> yyttr3 : they can be *passed*, but they can't be *matched* on, unless you apply them to all their arguments
00:37:21 <yyttr3> I understand
00:37:39 <ski> > let foo f = (f 0,f False) in foo Just  -- passing the `Just' data constructor to a function
00:37:41 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Bool)
00:37:41 <lambdabot>    arising from the literal ‘0’
00:38:08 <ski> oh, right, i actually need polymorphism in this case :)
00:38:31 <jle`> we should have monoid literals
00:38:35 <ski> > let foo :: (forall a. a -> Maybe a) -> (Maybe Integer,Maybe Bool); foo f = (f 0,f False) in foo Just
00:38:37 <lambdabot>  (Just 0,Just False)
00:38:47 <jle`> () :: Monoid m => m
00:38:52 <jle`> who's with me
00:38:57 <ski> > let foo f g = (f 0,g False) in foo Just Just  -- alternatively just passing it twice
00:38:59 <lambdabot>  (Just 0,Just False)
00:39:16 <nshepperd> you can use partially applied data constructors as function values
00:39:21 <ski> jle` : and monoid combination ?
00:39:23 <nshepperd> > fix Zero
00:39:24 <lambdabot>  Zero (Zero (Zero (Zero (Zero (Zero (Zero (Zero (Zero (Zero (Zero (Zero (Zero...
00:39:28 <jle`> ski: that's it
00:39:32 <jle`> just a mempty literal >_>
00:39:44 <jle`> but it might make some computations look nicer
00:39:51 <ski> jle` : yeah, but what notation do you propose for `mappend' ?
00:39:52 <jle`> when you can use () instead of mempty
00:40:04 <jle`> nothing, just normal functions like <>
00:40:13 <jle`> all i want is () to be a mempty literal hehe
00:41:01 <jle`> but it might be confusing because () is also a type
00:41:03 <jle`> hm.
00:41:43 * ski proposes writing `sum (concat (l0,l1),n) = concat (l0,concat (l1,n))' instead of `sum (concat nss) = sum (map sum nss)'
00:41:49 <Axman6> not 0 :: Monoid m => m?
00:42:36 <jle`> i wouldn't mind that, Axman6, if we split off Num into Monoid/Group/Ring etc.
00:42:45 <yyttr3> I don't see a chance of ambiguity in using 0 as a mempty literal
00:43:03 <nshepperd> giving fold [0, 2, 3] :: Product Int its natural meaning of 6? :p
00:43:27 <yyttr3> That would be weird.
00:43:40 <jle`> hm yeah.
00:44:08 <yyttr3> I can define flip :: Binary -> Binary and apply effectively using Zippers :/
00:44:12 <jle`> actually why would we even need to make it a literal
00:44:15 <yyttr3> Not sure if worth though.
00:44:16 <jle`> we can do it within haskell syntax
00:44:45 <jle`> @let (<~>) = mempty
00:44:47 <lambdabot>  Defined.
00:45:03 <jle`> but i guess the advanage would be overloading ()
00:45:12 <jle`> > Just 5 <> (<~>)
00:45:14 <lambdabot>  No instance for (GHC.Show.Show a0)
00:45:14 <lambdabot>    arising from a use of ‘M81033200521483808451425.show_M81033200521483808451...
00:45:14 <lambdabot>  The type variable ‘a0’ is ambiguous
00:45:14 <lambdabot>  Note: there are several potential instances:
00:45:15 <lambdabot>    instance [safe] GHC.Show.Show
00:45:19 <jle`> > Just "hello" <> (<~>)
00:45:20 <lambdabot>  Just "hello"
00:45:32 <jle`> (<~>) kind of looks like a black hole or something right?
00:45:38 <nshepperd> yyttr3: what's wrong with the definition I wrote?
00:46:17 <jle`> > Last (Just 4) <> Last (<~>)
00:46:18 <lambdabot>  No instance for (GHC.Show.Show a0)
00:46:18 <lambdabot>    arising from a use of ‘M18402171071924536481466.show_M18402171071924536481...
00:46:18 <lambdabot>  The type variable ‘a0’ is ambiguous
00:46:18 <lambdabot>  Note: there are several potential instances:
00:46:18 <lambdabot>    instance [safe] GHC.Show.Show
00:46:27 <nshepperd> yyttr3: flip f x = flipHead (f x) where flipHead :: Binary -> Binary
00:47:21 <jle`> > Last (Just 4) <> (<~>)
00:47:21 <yyttr3> I don't want to just flip the LSB, I want to flip anywhere in the Binary structure.
00:47:22 <lambdabot>  Last {getLast = Just 4}
00:47:42 <igniting> How do I test functor instance I wrote for ((,) e) in ghci?
00:47:56 <yyttr3> filp b = case b of { Zero -> One; One -> Zero}
00:48:31 <yyttr3> That's not the definition, but similar to what I have.
00:48:41 <yyttr3> flipB (Zero b) = One
00:48:49 <yyttr3> flipB (One b) = Zero
00:49:09 <jle`> igniting: you can try fmapping stuff onto things?
00:49:22 <yyttr3> So with Zippers :  Zero . One . Zero . flipB . One $ MSB
00:49:49 <nshepperd> you can do that with flip f x = flipHead (f x)
00:50:03 <yyttr3> @src flipHead
00:50:03 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
00:50:09 <ski> igniting : `fmap succ (10,100)' ?
00:50:48 <igniting> there is already an instance defined in GHC.Base, I want to hide it
00:50:56 <igniting> and use my own instance
00:51:34 <nshepperd> flipHead is the function that flips the LSB
00:51:47 <ski> how does the head of your instance look like ?
00:53:04 <igniting> instance Functor ((,) e) where
00:53:12 <ski> ok
00:53:48 <nshepperd> > let flipHead h = case h of { One b -> Zero b; Zero b -> One b; MSB -> MSB }; flip f = flipHead . f in Zero . One . Zero . flip . One $ MSB
00:53:49 <lambdabot>  Couldn't match type ‘a0 -> L.Binary’ with ‘L.Binary’
00:53:49 <lambdabot>  Expected type: (a0 -> L.Binary) -> L.Binary
00:53:49 <lambdabot>    Actual type: (a0 -> L.Binary) -> a0 -> L.BinaryCouldn't match type ‘L.Bina...
00:53:49 <lambdabot>  Expected type: L.Binary -> a0 -> L.Binary
00:53:49 <lambdabot>    Actual type: L.Binary -> L.Binary
00:53:55 <ski> igniting : i suppose you could test whether `fmap id undefined' is fully undefined (as it should be) or not
00:54:29 <ezyang> ARRRRGH why is Yesod trying to delete my primary key
00:56:04 <Hail_Spacecake> is there a way to use haskeline to not echo the character the user just typed inot the terminal?
00:56:10 <Hail_Spacecake> if not, what's a good way to do this?
00:56:15 <Hail_Spacecake> use ncurses bindings?
00:56:57 <yyttr3> applyAtFocus :: (Binary -> Binary) -> BinaryZipper -> BinaryZipper, it will work for a general case.
01:07:39 * hackagebot rest-core 0.32.0.2 - Rest API library.  http://hackage.haskell.org/package/rest-core-0.32.0.2 (ErikHesselink)
01:24:36 <pantsman-> Hail_Spacecake: have you looked at the getPassword function?
01:25:28 <Hail_Spacecake> pantsman- yeah, I kind of want that
01:25:31 <Hail_Spacecake> only for individual characters
01:25:40 <Hail_Spacecake> without waiting for a newline
01:26:34 <pantsman-> yeah I think looking at the implementation of getPassword might help
01:39:55 <trap_exit> has anyone here used APL/J/K? if so, (1) how did it effect your haskell programming, and (2) why did you return to Hskell ?
01:47:29 <adas> what does it mean to say a type is "uninhabited"?
01:47:47 <adas> it is not concrete?
01:47:52 <ski> that it has no element
01:47:56 <mjrosenb> adas: it means that there are no values with that type.
01:48:01 <ski> (or at least no total element)
01:48:19 <ski> "uninhabitable" could be a synonym for "not concrete"
01:49:17 <ski> @let data Void
01:49:18 <lambdabot>  Defined.
01:49:53 <ski> declares the type `Void' to have zero constructors, and so it has no element (apart from undefined/bottom ones, like `let x :: Void; x = x in x' and `undefined :: Void')
01:49:57 <adas> mjrosenb: meaning you cannot create a value of such a type?
01:50:22 <mjrosenb> adas: yes.
01:50:30 <ski> yes, you cannot create a total value of it
01:50:35 <adas> what use could such a type ahve?
01:50:38 <adas> *have?
01:50:47 <ski> @let void :: Void -> a; void v = case v of {}
01:50:48 <lambdabot>  Parse failed: Parse error: }
01:50:56 <ski> @let void :: Void -> a; void v = case v of { }
01:50:56 <lambdabot>  Parse failed: Parse error: }
01:50:58 <ski> hrm
01:51:13 <ski> > let void :: Void -> a; void v = case v of { } in void (undefined :: Void)
01:51:15 <lambdabot>  Empty list of alternatives in case expression
01:51:15 <lambdabot>    Use EmptyCase to allow this
01:51:30 <ski> would work if lambdabot had the `EmptyCase' language extension enabled
01:52:09 <ski> (i don't see why it has `EmptyDataDecls' enabled (which allows the above `data Void' declaration), but not `EmptyCase')
01:52:20 * mjrosenb thinks of it as  __builtin_unreachable from gcc -- the compiler can assume that a function that returns Void will never actually return.
01:52:27 <int-e> ski: because there are too many of those extensions
01:52:54 <ski> afaics, those two go together. neither would be ok
01:53:05 <trap_exit> no APL/J/K users here?
01:53:27 <mjrosenb> trap_exit: I've installed J on my computer.
01:53:46 <trap_exit> mjrosenb: I can get "jcon" to run but I can't get "jqt" to run on osx
01:54:11 <ski> adas : anyway, if you have a monad `M' for expressing cooperative multitasking, you could have an operation `killThread :: M Void', to be explicit about that executing this won't return at all
01:54:37 <mjrosenb> trap_exit: dunno, man.  jc is the only executable it installed for me.
01:55:00 <ski> adas : someone also mentioned the other day `data XOr a b = Left a (b -> Void) | Right (a -> Void) b'
01:55:31 <mjrosenb> ski: unless M is List, at which point, you can have [] :: [Void] without issues?
01:55:52 <ski> mjrosenb : that would be one example of what `M' could be, yes
01:56:29 <mjrosenb> ski: oh, I guess having an empty list in the list monad does kind of nuke the computation.
01:56:44 <mjrosenb> because the whole monad is basically guaranteed to return [] at that point.
01:57:06 <mjrosenb> err.. return is not the correct word there, but I think what I meant was obvious.
01:57:09 <ski> adas : yet another case is if you consider a data type for expressions, like perhaps `data Expr var = Var var | Lit Integer | Plus (Expr var) (Expr var)' (imagine more useful forms of expression). then `Expr String' is a type of expressions that use strings as variable identifiers, while `Expr Void' is a type of expressions not containing any variables at all
01:57:20 <ski> mjrosenb : right
01:57:40 <ski> (and something similar is true for this `Expr' monad)
01:57:41 <mjrosenb> ski: yay for turning counterexamples into examples!
01:58:09 <int-e> ski: fwiw I have used EmptyDataDecls without EmptyCase, it works well for phantom types. But there's no reason not to enable the latter extensions as well...
01:59:06 <ski> int-e : fair enough
01:59:41 <jmueller> So a presheaf is a functor from C^Op to Set, but what does it mean if something has presheaf semantics in Haskell? Does the "semantics" part mean that there has to be an adjunction?
02:00:48 <mjrosenb> jmueller: ... I understood three nouns in that question...
02:05:44 <Irene23>  Hi! I give you some videos. I hope you like! http://tinyurl.com/ozfvxy3
02:06:29 --- mode: ChanServ set +q *!*@212-129-58-18.rev.poneytelecom.eu
02:07:16 -ChanServ(ChanServ@services.)- ski added Irene23!*@* to the AKICK list.
02:07:16 --- mode: ChanServ set +b Irene23!*@*
02:07:16 --- kick: Irene23 was kicked by ChanServ (User is banned from this channel)
02:07:28 --- mode: ChanServ set -q *!*@212-129-58-18.rev.poneytelecom.eu
02:07:43 * hackagebot objective 0.1 - Extensible objects  http://hackage.haskell.org/package/objective-0.1 (FumiakiKinoshita)
02:08:16 <trap_exit> do we know what the video is
02:08:21 <trap_exit> or do we just block all video posts ?
02:08:35 <ski> it's a known kind of spam
02:09:16 <t7> i dont wanna click
02:09:18 <t7> someone else click
02:09:36 <ski> you probably don't want to click
02:09:46 <MP2E> it's most likely nsfw.
02:09:53 <ski> yes
02:09:54 <trap_exit> i don't wnat to click
02:09:54 <t7> $5 says cam site
02:09:56 <silver> don't click, report to net ops
02:10:00 <bernalex> the concept of NSFW is so stupid
02:10:09 <trap_exit> someone take the hit for #haskell :-)
02:10:10 <ski> silver : they already spammed the same in #freenode ..
02:10:15 <bernalex> I clicked it
02:10:22 <bernalex> my browser blocks pretty much everything so I'm still alive
02:10:29 <t7> and... ?
02:10:33 <bernalex> it wants to redirect to hotxgirls.net
02:10:40 <trap_exit> bernalex: i guess it's not medussa
02:11:00 <bernalex> so I closed the tab. there. are your collective curiosities satisfied?
02:11:17 <t7> there must be more effective things to spam on than an IRC network for developers
02:11:31 <trap_exit> yeah
02:11:41 <silver> free monads! http://...
02:11:43 <trap_exit> atleast you should pretend it's a error mesage
02:11:47 <int-e> t7: it's simple, you just spam all channels; checking the topics will only slow you down
02:11:48 <ski> (they got K-lined ..)
02:12:11 <t7> i mean freenode in general
02:12:13 <bernalex> trap_exit: ssh terminal@crawl.lantea.net # the password is 'terminal'. there goes your work day. :-]
02:12:15 <ski> silver : you should try saying `!list'
02:12:17 <t7> IRC in general tbh...
02:12:39 <bernalex> trap_exit: ups that was for t7 lol
02:13:21 <int-e> > let void :: Void -> a; void v = case v of { } in fix void
02:13:22 <lambdabot>  <void>
02:13:37 * bernalex goes back to reading about injected indexed type families
02:13:53 <ski> injected ?
02:14:03 <bernalex> *injective
02:14:15 <silver> !list
02:14:16 <monochrom> silver: http://lpaste.net/browse
02:26:28 <KorriX> Hello! Do you know if there is any template-haskell based solution for making AdvancedOverlap?
02:30:04 <Phillemann> Isn't there a generalized "unfoldr" that lets you return "Either b (a,b)" and which returns not only [a] but also a 'b'? This would be fitting for problems like "Parse a string, returning the non-parseable remainder"
02:31:39 <shachaf> As in parse a string and generate a list of tokens?
02:31:43 <shachaf> What's the full type?
02:31:53 <Phillemann> Yes, sorry, I wasn't precise enough.
02:32:29 <Phillemann> I came up with "unfoldEither :: (b -> Either b (a,b)) -> b -> ([a],b)" and wrote it myself. I'm just wondering if there is something already in hackage.
02:32:45 * hackagebot stm-promise 0.0.3.0 - Simple STM Promises for IO computations and external processes  http://hackage.haskell.org/package/stm-promise-0.0.3.0 (DanRosen)
02:33:33 <shachaf> Maybe more straightforward as (b -> (Maybe a, b))
02:33:49 <shachaf> There was a conversation about something vaguely similar at one point.
02:34:03 <shachaf> http://www.haskell.org/pipermail/libraries/2014-August/023461.html
02:34:07 <shachaf> But that's not really the same thing.
02:34:21 <Phillemann> Hm, yes, maybe (Maybe a,b) is better.
02:34:40 <Phillemann> Are these types...isomorphic in some way, btw.?
02:34:45 <shachaf> Yes.
02:35:13 <shachaf> Think of (,) as (*), Either as (+), Maybe as (+1)
02:35:50 <shachaf> b+(a*b) = (a+1)*b
02:35:50 <Phillemann> Interesting
02:36:03 <shachaf> You can write functions to convert back and forth pretty easily.
02:42:23 <jle`> it's almost as if the data types are algebraic
02:45:27 <bernalex> data instance XList Char = XCons !Char !(XList Char) | XNil -- so uh what does the exclamation marks mean?
02:45:49 <bernalex> just 'strict', like elsewhere?
02:46:27 <bernalex> hm. suppose so. makes sense at least.
02:50:18 <quchen> bernalex: Those exclamation marks are the only ones that exist in standard Haskell. They basically add some `seq`s to the data constructrs. BangPatterns is an extension that takes the syntax and makes it available in patterns for a similar purpose.
02:50:50 <bernalex> quchen: IC, ty.
02:55:32 -ChanServ(ChanServ@services.)- ski removed Irene23!*@* from the AKICK list.
02:55:32 --- mode: ChanServ set -b Irene23!*@*
02:59:20 <nshepperd> you should be able to write `unfoldEither :: (b -> Either c (a,b)) -> b -> ([a],c)` which is a little more general
03:00:07 <shachaf> That's also true.
03:03:18 <Phillemann> Ah, yes.
03:04:45 * mjrosenb thinks about the implications of the Xor mentioned earlier...
03:07:10 <shachaf> It sounds a bit like something out of linear logic.
03:07:43 <mjrosenb> shachaf: from the little linear logic that I know, it would fit better in linear logic.
03:08:14 <shachaf> Anyway the Haskell version mentioned above sounds problematic.
03:08:33 <mjrosenb> it doesn't /force/ Xor, it just kind of enables it.
03:08:47 <shachaf> E.g. (a, Not b) + (b, Not a) + (a, b) is pretty different from (a + b)
03:09:16 <ski> yes
03:13:29 <nyuszika7h> how can I make ghci use my cabal sandbox?
03:13:40 <shachaf> Maybe ⊕ is a bit like xor.
03:14:03 <lpaste> nyuszika7h pasted “GHCi not seeing Cabal sandbox” at http://lpaste.net/1098252618242719744
03:15:03 <geekosaur> cabal repl?
03:15:15 <nyuszika7h> tried that, said no package found
03:15:24 <nyuszika7h> no cabal file*
03:15:44 <lpaste> nyuszika7h pasted “`cabal repl` error message” at http://lpaste.net/4251948023094968320
03:15:57 <geekosaur> oh, it's telling you to upgrade cabal install in the original paste
03:15:57 <supki> cabal exec ghci
03:16:27 <geekosaur> so your cabal-install is too old to support cabal repl
03:16:35 <nyuszika7h> is it?
03:16:40 <nyuszika7h> I'm using the one from the latest Haskell Platform
03:16:45 <nyuszika7h> cabal-install version 1.18.0.5 using version 1.18.1.3 of the Cabal library
03:16:53 <nyuszika7h> nyuszika7h@nevorn ~/sandbox > cabal exec ghci
03:16:55 <nyuszika7h> cabal: unrecognised command: exec (try --help)
03:16:58 <geekosaur> line 7-8 implies otherwise?
03:17:15 <nyuszika7h> geekosaur: what?
03:17:18 <nyuszika7h> oh, line
03:17:23 <nyuszika7h> I read "like"
03:17:37 <bernalex> nyuszika7h: you shouldn't be in your sandbox
03:17:47 <bernalex> be in the project root, where the project.cabal is
03:18:06 <nyuszika7h> there isn't a project, I just wanted to install Unixutils locally to try it
03:18:11 <geekosaur> although I think 1.20 is out and was deliberately skipped by H-P because of compatibility details
03:18:28 <bernalex> nyuszika7h: if it doesn't have a .cabal you can't use it with cabal...
03:19:16 <bernalex> geekosaur: might be. cabal-install-1.20 requires network =<2.5 or something, and a bunch of stuff requires network-2.6 now.
04:14:49 <Phillemann> I'd like to periodically try to read from a socket and process the data received (if any). Some article suggests that Haskell already sets sockets to nonblocking mode. Is that really the case? The docs for "recv" suggest the function might block.
04:17:36 <oakwhiz> Phillemann: you can always use threading to turn a blocking function into a nonblocking function
04:17:49 <Sheytan> hello
04:18:18 <shiona_> hello
04:19:01 <mroman_> Phillemann: Are you running on windows?
04:19:10 <mjrosenb> > fix ("Hello!"++)
04:19:11 <lambdabot>  "Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hello!Hel...
04:19:34 <lpaste> Sheytan pasted “Lambdabot installation error from cabal” at http://lpaste.net/111285
04:19:36 <Phillemann> mroman_: Possibly, but currently I'm not.
04:19:41 <oakwhiz> > fix cabal-hell
04:19:42 <lambdabot>  Not in scope: ‘cabal’Not in scope: ‘hell’
04:19:43 <lambdabot>  Perhaps you meant ‘tell’ (imported from Control.Monad.Writer)
04:20:23 <Sheytan> anyone can help about lambdabot
04:22:15 <Sheytan> hm nobody can okay
04:22:50 <mjrosenb> > let cabal = id; hell = error in fix $ cabal hell
04:22:52 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
04:23:24 <mjrosenb> looks like cabal hell is an *Exceptional* level of hell.
04:23:32 <silver> Sheytan, don't ask to ask, just ask
04:24:13 <oakwhiz> mjrosenb: nice
04:25:46 <mroman_> hm. recv returns String
04:26:10 <mroman_> is recv encoding-aware?
04:26:16 <Sheytan> hint-0.4.2.1 failed during the building phase. The exception was:
04:26:16 <Sheytan> ExitFailure 1
04:27:19 <srhb> Sheytan: The problem should be above those lines. You might want to paste the build log somewhere
04:27:57 <Sheytan> srhb: http://lpaste.net/111285
04:28:08 <pertl> is there a nicer way that "liftM" to write this?  let addr = liftM addrAddress $ liftM head $ getAddrInfo Nothing (Just "google.com") Nothing
04:29:20 <oakwhiz> pertl: maybe something involving map liftM
04:30:10 <oakwhiz> pertl: then fold function application over the result of that
04:30:25 <pertl> ok :-)
04:30:29 <pertl> thanks
04:31:34 <mroman_> I don't want my application to crash if someone sends me invalid utf8 sequences
04:32:00 <silver> Sheytan, try to update your GHC
04:32:09 <mroman_> (which it does with readFile and the like)
04:32:53 <Sheytan> silver: that is ubuntu apt package
04:32:55 <Phillemann> mroman_: Oh dear, you're right. It should return ByteString or [Word8], really...
04:33:16 <mroman_> Phillemann: I don't know. But it really looks suspicious
04:33:33 <mroman_> hGetContents: invalid argument (invalid code page byte sequence)
04:33:44 <mroman_> ^- this for example can happen when you just use readFile
04:34:40 <mjrosenb> mroman_: does Text.readFile handle it any better? (I honestly don't know, but am curious)
04:34:58 <mroman_> It would be bad if someone can crash an application that uses Sockets by sending an invalid byte sequence
04:35:02 <mroman_> really, really bad
04:35:08 <mroman_> mjrosenb: I don't know either.
04:35:52 <mroman_> You can however use the low-level interface to readFiles
04:35:57 <mroman_> which allows you to specify an encoding
04:36:31 <mroman_> but you'd still have to catch exceptions
04:36:41 <Phillemann> Oh, there's Network.Socket.ByteString, of course.
04:37:13 <silver> Sheytan, sadly I do not know how it's properly done in Ubuntu, but I think GHC being too old is the reason for this error; you can try to use older version of lambdabot (maybe Ubuntu repo got one?) or try ppa with recent GHC
04:38:29 <mroman_> You can also use the high-level thing combined with hGet* from Data.ByteString
04:38:48 <Sheytan> silver: I will try to update GHC manually, thanks for your suggest
04:39:18 <srhb> I actually think hint has some bad preprocessor directives for that error to occur
04:39:31 <srhb> Or bad dependencies, really.
04:39:37 <hexagoxel> pertl: let addr = addrAddress . head `liftM` getAddrInfo Nothing (Just "google.com") Nothing
04:39:40 <srhb> pprErrMsgBagWithLoc does not exist in older versions of ErrUtils
04:39:51 <srhb> (I don't know exactly when it was introduced.)
04:39:52 <pertl> hexagoxel: wow, nice :-)
04:41:12 <srhb> Actually it looks like it was introduced in 7.4.2
04:41:42 <Sheytan> yes
04:42:41 <dEPy> question:  I have array  [ {status: 'online', date: ...}, {status: 'offline', date: ...}, ...]  if theres 2 or more online items one after another I should take first one, if there's 3 or more offline events one after another I should take the last one
04:42:50 <dEPy> any idea how to solve this 'functionally' ?
04:43:43 <btubbs> dEPy: seems like pattern matching should be able to do that
04:44:26 <dEPy> Am... I... Em... Am doing this in ruby...  O_o
04:44:39 <dEPy> So I have  map, reduce, filter, ...  just basic tools
04:45:10 <mroman_> Sounds like a job for group
04:45:25 <mroman_> map f . group
04:45:50 <mjrosenb> mroman_: groupBy
04:46:10 <mroman_> groupBy status
04:46:50 <solarus> yea in haskell something like groupBy ((==) `on` status)
04:47:44 <dEPy> That's the problem, I have to do it in ruby with limited tools :S
04:47:53 <mjrosenb> aaah, on.
04:48:00 <dEPy> :D
04:48:07 <mjrosenb> I was trying to remember what the thing more general than 'comparing' was.
04:48:11 <pantsman-> groupBy and on are implementable in Ruby
04:48:33 <mroman_> you can do that with a foreach loop anyway
04:48:47 <dEPy> probably beter to use that yes
04:48:53 <mjrosenb> mroman_: but he said he wanted to do it 'functionally'
04:49:01 <mroman_> ooohh...
04:49:07 <mroman_> well
04:49:12 <mroman_> write a recursive foreach loop then .
04:49:14 <mroman_> ;D
04:49:18 <dEPy> :D
04:49:29 <osfameron> it doesn't matter if the *implementation* uses a foreach loop
04:49:37 <osfameron> if you end up with a nice functional routine like groupBy
04:49:43 <osfameron> (arguably)
04:49:56 <dEPy> true
04:50:42 <osfameron> that's often the route I'd take doing mixed OO/FP stylee in Perl anyway.  Trying to do pure FP is often fun and informative, but doesn't always play well to the strengths of the language
05:13:14 <netroby> Any good book for learn haskell?
05:13:39 <crenot> hi, is there an operator like Monad m => (b -> c) -> (a -> m b) -> a -> m c ?
05:13:55 <ij> @lyah
05:13:55 <lambdabot> Unknown command, try @list
05:14:11 <ij> @where lyah
05:14:11 <lambdabot> http://www.learnyouahaskell.com/
05:14:20 <ij> netroby, ^
05:14:50 <netroby> Thanks, i am reading it now.
05:16:59 <bergmark> crenot:
05:17:03 <bergmark> @type \f -> (return . f <=<)
05:17:04 <lambdabot> Monad m => (b -> c) -> (a -> m b) -> a -> m c
05:17:23 <pjdelport> @wikibook
05:17:23 <lambdabot> Unknown command, try @list
05:17:28 <pjdelport> @where wikibook
05:17:28 <lambdabot> http://en.wikibooks.org/wiki/Haskell
05:18:00 <netroby> Why you guys love haskell
05:18:29 <lessless_> hi folks! what is the reason for `parse error on input `='` in  boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]
05:18:37 <lessless_> (performed in ghci)
05:18:42 <ij> lessless_, prefix with "let "
05:18:51 <ij> That's a ghci thing.
05:18:58 <lessless_> thank you!
05:18:59 <pjdelport> netroby: Pure functional programming is a life-altering idea, and Haskell is probably the biggest exemplar of it.
05:19:25 <lessless_> pjdelport,you mean professional life or life at its large?
05:19:31 <lessless_> life as whole?
05:19:45 <pjdelport> lessless_: Well, programming life, at least. :)
05:21:19 <netroby> Learning ocaml, clojure and erlang , but the haskell IRC channel online numbers is bigger than others.
05:21:24 <crenot> bergmark: thanks but is there no single operator? i already defined my own as "f <. g = liftM f . g" but i thought there must already be an operator for something that seems so obvious, and if there isn't then i must be doing things the wrong way
05:21:49 <pjdelport> crenot: fmap . fmap will actually do that as a special case
05:23:16 <pjdelport> (or fmap . liftM, in this case)
05:23:44 <pjdelport> crenot: What are you using this for?
05:24:13 <pjdelport> It is an unusual thing to compose.
05:24:38 <crenot> well i wanted something that i could switch the . for in "liftM lines . readFile" that would allow me to get rid of the liftM, like "lines <. readFile"
05:26:47 <pjdelport> Ah, right. I actually have this definition: (f <.> g) x = f <$> g x
05:27:12 <pjdelport> Analagous to
05:27:12 <pjdelport> @src (.)
05:27:12 <lambdabot> (f . g) x = f (g x)
05:27:15 <pantsman-> it seemsa reasonable thing to compose
05:27:52 <pjdelport> So <.> is to <$> what (.) is to ($)
05:28:56 <pantsman-> I like <.< analogous to <=<
05:29:05 <pantsman-> f <.< g = return . f <=< g
05:29:23 <crenot> so you define your own?
05:29:38 <pantsman-> hmm, or maybe <$<
05:29:41 * pantsman- bikesheds with self
05:31:35 <rodlogic_> I am realizing I need to have a better understanding on how type inference works in GHC. I am less interested in the nitty gritty details, but more on enough to be able to reason with it. Could someone point me to a source where I can read more about it?
05:33:51 <pjdelport> rodlogic_: You'll probably mostly find type theory and implementation reading... but i'm not sure if that alone will *necessarily* help build a stronger working intuition.
05:34:32 <pjdelport> Do you have any examples of inference situations that you find confusing, that might help to discuss through?
05:34:41 <hexagoxel> rodlogic_: it also depends if you want to understand inference around type classes as well
05:35:22 <hexagoxel> henry/milner is ok for starters, but it does not explain inference around, lets say, functional dependencies
05:35:36 <rodlogic_> yes, I am trying to explore type classes, MPTC, type families and I find myself a bit lost relying too much on the compiler to tell me what is wrong.
05:36:32 <nshepperd> runKleisli (lines ^<< Kleisli readFile)
05:37:30 <ski> rodlogic_ : "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/TYPE/typeinf.p(s|df)> might perhaps be of some help
05:38:25 <benzrf> i read a blog post about the `reverse state monad'
05:38:33 <benzrf> it's slightly  mind blowing
05:41:37 <prophile> benzrf: http://hackage.haskell.org/package/tardis-0.3.0.0/docs/Control-Monad-Tardis.html
05:42:47 <hc> Hi, I'm writing a network daemon that you connect to via telnet. You can enter commands and at the same time you can get output at any time, so when that happens while you're entering a command I clear the line, send the output and then redraw the part of the command that was already typed.
05:43:19 <hc> Currently I'm doing this by using two reader threads, one reading from the network and one reading the events that should be sent to the network, and both are sending their input via a TVar to a third thread that writes to the network.
05:43:22 <XniX23> i've seen a video where IO String is explained as it does something and then gives you a string. How should if the function's return is Maybe Int and returns Just 5 (which clearly isn't just an Int)?
05:43:27 <hc> Is this an ok approach or is there a better way?
05:43:44 <XniX23> *how should i interpret
05:43:48 <crenot> nshepperd: well that works but i still have to define it myself. anyway i feel like if there isn't already a common library operator for what i'm trying to do then i must be doing something unidiomatic
05:44:07 <rodlogic_> ski: this could get me started
05:44:35 <rodlogic_> pjdelport: once I have more specific questions I will circle back to ask for help here. Thanks.
05:44:47 <prophile> XniX23: Maybe Int is ~~ the type of boxes that may or not contain ints
05:44:59 <pjdelport> @src Maybe
05:44:59 <lambdabot> data Maybe a = Nothing | Just a
05:45:06 <prophile> Just x is a box containing the int x and Nothing is a box not containing anything
05:45:26 <mroman_> XniX23: I'd go with "IO a" is something completely *special*
05:46:32 <pjdelport> XniX23: In plain english, "Maybe a" means "either a value of type a, or nothing"
05:46:51 <eriksensei> XniX23: or: IO String is a *description* of which IO actions to perform in order to obtain an Int
05:47:04 <mroman_> IO String may wipe your harddisk secretly
05:47:08 <mroman_> Mabye String can't.
05:47:10 <mroman_> ;)
05:47:32 <XniX23> so there isn't any normal interpretation that would be valid for every M a?
05:47:51 <pjdelport> XniX23: For any monad in general?
05:47:57 <XniX23> pjdelport, yes
05:49:00 <ski> @tell benzrf|offline Jerzy Karczmarczuk's "Adjoint Codes in Functional Framework" in 2000 mentions a use of the reverse state monad (for automatic differentiation)
05:49:00 <lambdabot> Consider it noted.
05:49:18 <pjdelport> XniX23: There are a couple. I like the view that any Functor (and hence Monad) is a /structure/ with /typed slots/, as well as various structure-preserving operations.
05:49:34 <ski> @tell benzrf|offline possibly you also want to check out the 2001 "Functional Differentiation of Computer Programs". both these are available at <https://karczmarczuk.users.greyc.fr/arpap/>
05:49:34 <lambdabot> Consider it noted.
05:50:18 <pjdelport> An abstract structure, that is (not necessarily a data structure). For example, IO actions are values where the structure is the action's *effect*.
05:50:23 <mroman_> Maybe a doesn't have "side-effects" like IO a does. If that's part of the question.
05:50:29 <pjdelport> And "structure-preserving" means "effect-preserving".
05:51:24 <pjdelport> XniX23: So fmap lets you change an IO action's result (the type slot) while preserving the structure (the effect).
05:51:59 <pjdelport> So it's a structure-preserving map, and the Functor laws just make "structure-preserving" rigorous.
05:52:11 <ski> (of course values of type `IO Blah' doesn't really have side-effects)
05:53:00 <mroman_> (of course not)
05:53:09 <pjdelport> Applicative's <*> is structure-preserving lifted function application, and pure lets you combine any pure value with a "default" empty structure.
05:53:12 <eriksensei> I tend to think of monads as things that let me do (>>=), i.e. bind, most of the time, which in turn is something like a (f)map followed by a join/flatten
05:53:21 * ski likes to make a distinction between "effects" and "side-effects"
05:53:46 <pjdelport> And the join of monads lets you merge two levels of structure into one, while preserving the structure of both.
05:54:11 <ski> (a value of type `IO Blah' describing some Input/Output *effects* to do (iow to use to interact), in order to compute a result of type `Blah')
05:54:24 <mroman_> Does XniX23 know about Monads, Functors...?
05:54:50 <ski> good question
05:55:08 * ski stares at XniX23
05:55:45 <XniX23> mroman_, i think i know what a functor is, i'm trying to grasp what a monad is
05:55:47 <pjdelport> (For example join :: IO (IO a) -> IO a takes an IO action yielding an IO action, and merges their two effects into one effect.)
05:56:16 <pjdelport> XniX23: Does the above characterization of Functor / Applicative / Monad make sense?
05:56:54 <ski> > (concat :: [] ([] Integer) -> [] Integer) [[],[0],[1,2],[3,4,5],[6,7,8,9]]
05:56:55 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
05:56:59 <ski> > (join :: [] ([] Integer) -> [] Integer) [[],[0],[1,2],[3,4,5],[6,7,8,9]]
05:57:00 <mroman_> I usually hate when people answer me with cat-theory/math related answer because I don't have that background and rather prefer a good "analogy" :)
05:57:01 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
05:57:34 <ski> > (join :: Maybe (Maybe Integer) -> Maybe Integer) (Just (Just 945))
05:57:35 <lambdabot>  Just 945
05:57:36 <mroman_> The hardest part about answering is establishing the background the asker has :)
05:57:37 <ski> > (join :: Maybe (Maybe Integer) -> Maybe Integer) (Just Nothing)
05:57:39 <lambdabot>  Nothing
05:57:42 <ski> > (join :: Maybe (Maybe Integer) -> Maybe Integer) Nothing
05:57:43 <lambdabot>  Nothing
05:58:27 * XniX23 is thinking
05:58:33 <pjdelport> XniX23: Lists are another good example of precisely what "structure" means in the above definitions: the "structure" of a list is the number and order of elements, while the "typed slots" are the elements themselves.
05:58:36 <ski> XniX23 : do you know `Either' ?
05:58:55 <pjdelport> So for lists, "structure-preserving" means "length-and-order preserving"
05:59:21 <mroman_> since I don't have any theoretical background I treat a Monad as an interface (i.e. type class)
05:59:33 <ski> that's sensible
06:00:26 <mroman_> I do that with all the stuff. Functors, Applicatives etc. I have no idea about their "exact" meaning in theory
06:00:30 <pjdelport> (Well, not length that specifically, but think "shape".)
06:00:43 <XniX23> ski, i don't. pjdelport, so the structure is somewhat meta information?
06:00:53 <pjdelport> So you can see how 'concat' is the monadic join for lists, because it merges two layers of lists while preserving all the elements and order of both.
06:01:00 <mroman_> but they have an interface (almost) like a regular Java-Interface which I know how to use and implement
06:01:12 <ski> eriksensei : which is also fine, as long as you don't forget `return', and as long as the implementation of those satisfies the (sensible) monad laws
06:02:17 <pjdelport> XniX23: Yeah; "structure" can mean a context, or an effect, or metadata, or some actual data structure: the whole point of it is that the meaning of "structure" is completely defined only by the Functor/Applicative/Monad instance.
06:02:25 <XniX23> pjdelport, what is join actually?
06:02:38 <doismellburning> mroman_: yep ;)
06:02:48 <ski> XniX23 : `fmap f [a,b,c,d] = [f a,f b,f c f c]' -- the "structure-preserving" (or "length-and-order preserving") means that `fmap' isn't allowed to change the number of elements, or the ordering, and it's not allowed to ignore some input element or use it for more than one output element either
06:02:49 <pjdelport> If you're working abstractly, all you know is that there is *some* kind of structure, and that it will be preserved. (Most of the laws are precise way of stating just that.)
06:03:14 <pjdelport> And it helps to think in terms of concrete examples: like how for IO, structure-preserving means effect-preserving.
06:03:41 <oakwhiz> if you have a simple tree, and you fmap a function over the tree, you get another tree with exactly the same layout
06:03:53 <ski> XniX23 : note how `join' in the `Maybe' case is going to "collapse" two `Just'-layers. but if it's given a `Nothing' or a `Just' of a `Nothing, then it'll give `Nothing' as result
06:03:56 <eriksensei> ski: i usually don't have to think about the laws much unless i'm implementing a monad myself.
06:04:32 <ski> eriksensei : well, i bet you use them all the time, without thinking about it, when you're refectoring monadic code (e.g. using the `do'-notation) ;)
06:04:32 <pjdelport> And it might also help to intuitively think that if you have a Functor value like "f a" (or Monad value like  "m a"), then "structure" means everything embodied by the 'f', and "typed slot" means everything embodied by the 'a'.
06:05:48 <pjdelport> So the whole point of fmap :: Functor f => (a -> b) -> f a -> f b is that it guarantees that it will only replace the 'a' with 'b', without changing the 'f' (or structure) at all.
06:06:17 <Adele23>  You can find funny videos here. http://tinyurl.com/ozfvxy3
06:06:26 <eriksensei> ski: sure, but i guess i'm trying to say that (>>=) is my point of departure when thinking about monads, and the rest comes after that, in my head at least
06:06:32 <XniX23> pjdelport, but when it comes the Nothing case, doesn't this count as a change the structure?
06:06:37 <XniX23> of*
06:06:42 <pjdelport> (And you should always be able to replace "structure" with the particular meaning for a type, like "effect" for IO.)
06:06:45 <ski> eriksensei : e.g. if you have `frob = do x <- foo; y <- bar x; baz y', you could factor this into `frob = do y <- barf; baz y' together with `barf = do x <- foo; bar y' -- iow, breaking (factoring) out the `x <- foo; y <- bar x' (minus the `y <-') into a separate action, `barf'
06:06:59 <pjdelport> XniX23: fmap f Nothing = Nothing
06:07:05 <pjdelport> No change in structure :)
06:07:19 <pjdelport> s/=/==/ even
06:07:38 <pjdelport> Nothing in, Nothing out.
06:07:46 <pjdelport> It's the same as: fmap f [] == []
06:08:21 <XniX23> but fmap (\x if x == 5 then Just 5 else Nothing) Just 4 results in Nothing, so it goes from Just 4 to Nothing
06:08:22 <eriksensei> ski: fair enough ;) i'll rephrase my earlier comment to say "i usually don't have to think about the laws much unless i'm implementing a monad myself OR when i'm refactoring monadic code".
06:08:24 <pjdelport> The empty list is a valid structure: it just has *no* typed slots, so mapping a function to it just gives you the same structure back.
06:09:21 <pjdelport> (well, the same empty list except that the "slot" type may be different)
06:09:29 <ski> > fmap (\x -> if x == 5 then Just 5 else Nothing) (Just 4)
06:09:31 <lambdabot>  Just Nothing
06:09:39 <ski> XniX23 : read ^
06:10:24 <ski> XniX23 : it goes from `Just 4' to `Just Nothing'. the structure (the outer `Just') *is* preserved. the inner `Nothing' in the result is irrelevant to this
06:10:50 <pjdelport> XniX23: As an exercise, try to think of every Functor or Monad instance you're familiar with, and try to identify what part of each one is the "structure", and what the typed "slots" mean for each one.
06:11:35 <ski> (because the input has type `Maybe Integer', and the result has type `Maybe (Maybe Integer)', but it's only the "outer" `Maybe' structure that's preserved by the `fmap')
06:12:32 <XniX23> pjdelport, so in this case, you actually map only to the inner typeslot or whatever this is?
06:12:38 <ski> > fmap (fmap (\_ -> False)) (Just (Just (Just (Just "hello"))))
06:12:39 <lambdabot>  Just (Just False)
06:12:39 <pjdelport> Yeah.
06:13:02 <mroman_> http://lpaste.net/111286 <- would this satisfy monad laws?
06:13:03 * hackagebot bv 0.3.0 - Bit-vector arithmetic library  http://hackage.haskell.org/package/bv-0.3.0 (IagoAbal)
06:13:04 <ski> @type fmap `asTypeIn` \fmap -> fmap (fmap (\_ -> False)) (Just (Just (Just (Just "hello"))))
06:13:05 <lambdabot>     Couldn't match type ‘[Char]’ with ‘Maybe [Char]’
06:13:05 <lambdabot>     Expected type: Maybe (Maybe (Maybe [Char])) -> Bool
06:13:05 <lambdabot>       Actual type: Maybe (Maybe (Maybe (Maybe [Char]))) -> Maybe Bool
06:13:15 <ski> hrm
06:13:33 <ski> oh, dang. can't do that with a polymorphic thing
06:14:14 <ski> @type fmap `asTypeIn` \outerFmap -> outerFmap (fmap (\_ -> False)) (Just (Just (Just (Just "hello"))))
06:14:16 <lambdabot> (Maybe (Maybe (Maybe [Char])) -> Maybe Bool) -> Maybe (Maybe (Maybe (Maybe [Char]))) -> Maybe (Maybe Bool)
06:14:25 <ski> @type fmap `asTypeIn` \innerFmap -> fmap (innerFmap (\_ -> False)) (Just (Just (Just (Just "hello"))))
06:14:26 <lambdabot> (Maybe (Maybe [Char]) -> Bool) -> Maybe (Maybe (Maybe [Char])) -> Maybe Bool
06:14:46 * ski realizes those are probably a mouthful to read
06:14:56 <pjdelport> mroman_: I don't think so: "join . fmap return" wouldn't be an identity.
06:15:27 <pjdelport> "return a = Container a 0" might work though?
06:15:38 <ski> mroman_ : no, you have to change `0' to `1', or change `+' to `*', in the `Monad Container' instance
06:16:28 <ski> mroman_ : btw, `(Container a i) >>= f = ...' can be simpler written as `Container a i >>= f'
06:16:56 <ski> (similarly, `deriving (Show)' could be `deriving Show')
06:17:02 <pjdelport> mroman_: An important intuition about pure / return is that the "default" structure that it adds must be empty or idempotent in a certain sense: if you add the default structure with return and then merge it again with join, you should get the original result back.
06:17:16 <pjdelport> That's what it means for "join . fmap return" to be an identity.
06:17:50 <mroman_> hm ok
06:17:53 <pjdelport> So "return a = Container a 1" isn't a neutral structure, because it actually adds 1.
06:18:35 <ski> mroman_ : pjdelport is saying that `do x <- blah; return x' must be equal to `blah' .. but in your case the `return' (and the `(>>=)' implicit in the `do'-syntax) will add an extra `1'
06:19:01 <pjdelport> Right.
06:19:20 <ski> adding `0' "does nothing", so therefore you can use `0' in `return' and `+' in `(>>=)'
06:19:47 <ski> alternatively, multiplying by `1' "does nothing", so therefore you can use `1' in `return' and `*' in (>>=)'
06:20:04 <pjdelport> You can also see that in Applicative laws: pure (f a ...) == pure f <*> pure a <*> ...
06:20:30 <ski> (also the operation you use in `(>>=)', `+' or `*' here, has to be associative, because we want the above refactoring step with `frob' and `barf' to be valid)
06:21:00 <pjdelport> For a "neutral" default structure added by pure, that works. But for something like "pure a = Container a 1", the left side would have a counter of 1, while the right side would have a counter of N, for as many items as you have.
06:21:02 <ski> if you used lists (e.g. strings) instead of `Int's, then you could use the empty list `[]' in `return' and list concatenation `++' in `(>>=)' ..
06:22:24 <exio4> isn't that, somehow, a monoid?
06:22:33 <ski> mroman_ : your monad (if fixed in one of the ways i indicated) is known as an "output monad" (or sometimes a "writer monad")
06:23:39 <ski> mroman_ : in the monad template library, your `Container' would correspond to `Writer (Sum Int)' (assuming you replaced `1' in `return' by `0'. otherwise if you instead replaced `+' in `(>>=)' by `*', you get `Writer (Product Int)')
06:23:43 <exio4> (what you've to do with the "additional data")
06:23:50 <ski> exio4 : yes it is ! :)
06:24:05 <michi7x7> > let avg x = sum x / fromIntegral (length x) in avg $ avg <$> [[1,2],[3,4]]
06:24:06 <lambdabot>  2.5
06:24:09 <ski> `Writer w' is a monad when `w' is a monoid
06:24:10 <exio4> oh!
06:24:26 <michi7x7> can you make that work for arbitrary depths?
06:24:56 <ski> michi7x7 : you must *somewhere* represent the nesting depth of the lists
06:25:36 <ski> > let avg x = sum x / fromIntegral (length x) in avg (concat [[1,2],[3,4]])
06:25:38 <lambdabot>  2.5
06:25:54 <ski> @let avg x = sum x / fromIntegral (length x)
06:25:56 <lambdabot>  Defined.
06:26:26 <ski> > (avg . map avg) [[0,1,2,3],[4,5]]
06:26:26 <ski> > (avg . concat) [[0,1,2,3],[4,5]]
06:26:28 <lambdabot>  3.0
06:26:28 <lambdabot>  2.5
06:26:35 <pjdelport> michi7x7: Rose trees would be one way to approach representing that to arbitrary depths.
06:26:46 <solarus> this would be a nice use case for genericLength :)
06:26:54 <ski> right, so computing averages in two stages needn't be the same as flattening and computing it in one stage
06:26:57 <XniX23> pjdelport, thanks for explaining i'll keep that in mind when learning
06:26:58 <ski> michi7x7 ^
06:27:06 <pjdelport> XniX23: Cool. :)
06:27:59 <ion> > case foldMap (Sum *** const (Sum 1)) [0..5] of (Sum x, Sum n) -> x / fromInteger n
06:28:01 <lambdabot>  Could not deduce (GHC.Num.Num (a, b'0))
06:28:01 <lambdabot>    arising from the ambiguity check for ‘e_1105’
06:28:01 <lambdabot>  from the context (GHC.Num.Num (a, b'),
06:28:01 <lambdabot>                    GHC.Real.Fractional a,
06:28:01 <lambdabot>                    GHC.Enum.Enum (a, b'))
06:28:09 <ion> uh
06:28:10 <ski> pjdelport : another would be `data NestList a = Val a | Nest (NestList [a])'
06:28:32 <ion> > case foldMap (Sum &&& const (Sum 1)) [0..5] of (Sum x, Sum n) -> x / fromInteger n
06:28:33 <lambdabot>  2.5
06:28:37 <ski> @let data NestList a = Val a | Nest (NestList [a]) deriving Show
06:28:39 <lambdabot>  Defined.
06:29:58 <ski> @let myList :: [[[Integer]]]; myList = [[[0,1],[2,3,4]],[[5],[6,7,8,9]]]
06:30:00 <lambdabot>  Defined.
06:30:08 <ski> @type Val myList
06:30:10 <lambdabot> NestList [[[Integer]]]
06:30:15 <ski> @type (Nest . Val) myList
06:30:16 <lambdabot> NestList [[Integer]]
06:30:19 <ski> @type (Nest . Nest . Val) myList
06:30:20 <lambdabot> NestList [Integer]
06:30:24 <ski> @type (Nest . Nest . Nest . Val) myList
06:30:26 <lambdabot> NestList Integer
06:32:19 <ski> anyone want to attempt to write `avgNestList :: Fractional a => NestList a -> a' ?
06:32:35 <michi7x7> reduce :: ([a] -> a) -> NestList a -> a
06:33:02 <michi7x7> so avgNestList = reduce avg
06:33:23 <ski> and how do you write `reduce' ?
06:34:02 <michi7x7> hmm
06:38:27 <ion> @let instance Foldable NestList where foldMap f (Val x) = f x; foldMap f (Nest xs) = (foldMap . foldMap) f xs
06:38:29 <lambdabot>  Defined.
06:38:48 <ion> > case foldMap (Sum &&& const (Sum 1)) $ (Nest . Nest . Nest . Val) myList of (Sum x, Sum n) -> fromInteger x / fromInteger n
06:38:51 <lambdabot>  4.5
06:40:20 <ski> ion : interesting :)
06:40:44 <ski> > (avg . map avg . map (map avg)) [[[0,1],[2,3,4]],[[5],[6,7,8,9]]]
06:40:47 <lambdabot>  4.0
06:40:48 <ski> > (avg . map (avg . map avg)) [[[0,1],[2,3,4]],[[5],[6,7,8,9]]]
06:40:50 <lambdabot>  4.0
06:41:12 <ski> is effectively what we want `avgNestList' to do
06:41:59 * ski notes ion's version effectively removes nesting before summing and counting (once each)
06:43:42 * ski has to run now
06:48:08 <ion> I wasn’t paying enough attention and missed the requirement to compute averages of averages.
06:52:05 <holymac_> hummmm, haskell just got interesting
06:52:06 <holymac_> print $ [x^3 | x<-[1,2..10], x^3 > 27]
06:53:38 <ion> Btw, that computes each x^3 twice.
06:54:02 <ion> If you work in ghci you don’t need “print $”
07:42:49 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://is.gd/xJt4FF'
07:42:49 --- topic: set by glguy on [Thu Sep 18 09:24:53 2014]
07:42:49 --- names: list (clog RaceCondition_ rodlogic deepend mizu_no_oto rrradical agjacome jkaye divyanshu nuttycom simukis_ Peaker whaletechno msgodf LordDeath naneau WraithM iteratee masak_grr ndrei_ ndrei anRch connerb dmnd skammer SonderbladeWork kalloc_ cfricke vozz omefire1 dabradley GGMethos Mon_Ouie Oxyd Qfwfq gbarboza koz paperManu user___ Sorella conrad__ harski1 jasonkuhrt_ mkster kmels cdidd jesse__ conehead stolaruk Abi_Buccaneer jonrh gratimax_ michi7x7 ThatCantBe)
07:42:49 --- names: list (xivix_ zeiris_ wormphle1m tsou_grr exio4 hiptobecubic ivan\ LnL fabe esteweig TakSuyu saep` kipras cowtown_ pgiarrusso Takle tnks_ stepcut Ralith_ spacekit1eh govg_ panda_man tamiko_ ski__ rbocquet_ rsnous andreasr2 jix_ Rembane_ julm_ d_k kuzy000__ Desoxy Fusxfaranto_ kawachi_ io2 RlyDontK1ow ch3mical etrepum cstrahan nilg` khyperia albeit banister_ obcode_ quaestor2 Shin-LaC Oksana_ jophish_ Argue__ ThatOtherPerson_ hnoob n0n3such phienone sam_lee amiri)
07:42:49 --- names: list (nulpunkt reizuki__ nullbyte tusj aartamonau DanielDiaz HugoDaniel ixti glosoli Church- SilverKey OscarZ mada dfeuer Ankhers Ben__ jfojtl tomboy64 _ashbreeze_ pchiusano etandel pmade hellangel7 gniourf petermw Artpicre hualet_deepin cpennington ortmage negatratoron it0a sepp2k zwer_w Nervkind doomlord_1 eacameron L8D ioanel numberten armlesshobo xcv wombawomba Longlius JagaJaga Guest64092 Guest84753 zq silver_ edsko jamiely edon jamiehannaford oleo blogle_)
07:42:49 --- names: list (blogle bonobo123 Rarrikins mike4 Aune viszu1 Sebastien-L szymanowski fizbin sea-gull MagneticDuck mattyw matheus23 Khisanth kvelicka romanb lessless_ OlegYch alenn fujimura t-l-o Itkovian asmyers Feuerbach dgpratt thunderrd fProgrammer_ darthdeus dcoutts_ fdsnei Anton trpl folsen Zeedox jorj Sheytan Gurkenglas ptek systemfault centrinia hebz0rl artyomkazak srenatus RaceCondition dreams haasn tech2 ezrios dkbrk poutsi ulfdoz NightRa eizodo hexagoxel DrCode)
07:42:49 --- names: list (latro`a_ haskoiner gienah sivteck albertid_ louisjb pdpi Lethalman Jasch MrGwen MrWoohoo Hijiri g00ey angerman bjz quchen Lowl3v3l tonbo ormaaj marr roconnor_ lambdabot aloiscochard oakwhiz free_beard jml int-e hvr osa1 prophile Icewing t7 goldkatze caumeslasal1 ventonegro oddsignals boegel|work sbjorn MitchW erikd hackagebot juhp oish Adios odi mikalv TallerGhostWalt srhb ousado saati_ ernst_ slomo acharles tobik Forkk vlatkoB XniX23 Guest16580 Klumben)
07:42:49 --- names: list (Wertax danvet Th0mas xeno capisce sakirious purefn1 vili jordanl humppa dubosec arenz cdk augur SegFaultAX bjornars nikolah bmuk OrangeDuck pyon mauke_ infinity0 Lindrian Kabaka plutoniix otto_s drbean shanse zeebrah LeaChim eisbehr zanchoPa1sa Saizan supki dbp holymac_ shesek apaku joneshf-laptop_ acmiyaguchi Zekka dsantiago JustAPerson ruukasu nshepperd krgn__ predator217 cow_2001 maurer julmac stelleg inuoppai albel727 sorind Yawgmoth absence David)
07:42:49 --- names: list (Matrixman_217 Sgeo seangrove evax only_the_bear pp^ angelicstrike mlh ValicekB ad Mion mrowe_away iross dibblego coppro Jaak thomassgn Pad^ otulp saiam nw solarus empyreal ion iron_houzi jlewis_ rmunroe keaml haroldwu ggreg Preyer gargawel cross Kneiva ciaranm lulf joeyh anannie jpiche mceier kmapped__ yrashk_ superjudge____ mankyKitty xplat neptunepink ryankarason Apocalisp castor3 spopejoy mannyv Urchin sdx23 farn tomku ccasin umbriel dr__ stefan_1__)
07:42:49 --- names: list (bartavelle Maerten eikonos perrier Excureo stevej averell Dtgr amiller unsymbol Fuuzetsu everett bgamari illabout krgn splintax Za-Lord goodday tsani Kruppe SSgtSpoon bergey kerrick ForNeVeR croyd SparkySparkyBoom vsayer__ etabot upgrayeddd elfenlaid Ferdirand Someguy123 mortberg scopedTV kloplop321 gandr Nshag jlouis sshine metaf5 kaol funrep Deewiant ocharles ehamberg larrytheliquid__ oldmanstanley___ teehemkay kirjs_____ Intensity Defunk DragonEyes2 sw1nn)
07:42:49 --- names: list (mikecaruso mornfall jle` qr42 Cathy hamishmack slth dreixel linduxed xinming PotatoGim edwtjo raek _5kg_ lpvb cwl cjheath carlosgaldino j2j davidfetter jlamothe ttuegel chungbd|away cmears kiwnix araujo xp_prg sm CindyLinz KeelOfSteel snits catsup kalail kwantam howard statusbot C4Cypher toors mitu srcerer rabisg ClarusCogitatio Raynes shouya arpunk Nahra rufs Gonzih _flow_ Sagi mpw__ cyphase Willis davidthomas StoneToad dlundy greeny ozataman Tesseraction)
07:42:49 --- names: list (mgaare hpc abh pfoetche1 delimax_ tomprince jcurbo elspru saml stevely periodic zinfandel jedavis jedai vital annulus machineslearn oconnore Nivimer Antoine59 raphie____ c-rog saurik jayne dgvncsz0f dagle notthemessiah seliopou AshyIsMe Raynos joneshf eL_Bart0 _lo d-snp brackets deevus xpika Axman6 vpetro ahihi nyuszika7h _d3f franckverrot arianvp andreypopp_ bgyss nkpart leifw pjdelport sclv__ nmashton m_george_ emmanueloga_ serjeem_____ sindresorhus)
07:42:49 --- names: list (tobyp___ joshsz cloudhead__ strmpnk alphonse23__ jlyndon__ jabbslad______ PatrickRobotham Karethoth_ augustl jodaro AlainODea____ posco dlackty__ SethTisue_______ S11001001 chriswk__ seanparsons jroesch__ ReinH si14__ mno2_ zlinn_ chas__ c9sould zph dkua blindscreen MediumDivision__ puzza007_ jonsterling wjt mbrcknl caasih_ lfp__ dstockwell asabil_ steshaw MMuse____ akahn korpse__ btc_ lacrosse__ CARAM jzelinskie tazjin Xorlev jennmoneydollars avdi jo__)
07:42:49 --- names: list (pmarreck MiracleBlue jdjkelly___ tarcwynne__ niftyn8 Lacriatch djapo meretrix fryguybob effy manfoo7` kjnilsson valdyn stass dmilith pantsman- tarmil` mavam mjo dcoutts peterhil` agatam tromp_ dehflingus IanKelling arrdem Guest81004 tranma Diskord taktoa nathanic Wamanuz mitchty AleXoundOS__ pharaun go|dfish charlie peder wjlroe pnielsen ]OLI[ sohum xelk Reiser trez takeey mgomes suvash_away tekacs cepheus orbital_ yukko defanor Floyd_ blenny Walther)
07:42:49 --- names: list (owlglass1 horlicks_ Belgarion0 henrikhodne Maxdamantus indigo pikhq edk ClaudiusMaximus johnw frontendloader vincom2 Iceland_jack Cale iulian cods electrogeek pqmodn fractalcat nemesit|znc christiansen jrib oberstein maoe manfoo7 xiaolin bjobjo tucenaber luz1e RevJohnnyHealey vladan thirsteh javex ps-auxw bailon mxf keko_ kungp asfp alpounet lurker6_ Adeon antoniy mathu dropdrive mountaingoat stiell Fubar^ klugez mindos_cloud___ wizonesolutions adamse)
07:42:49 --- names: list (killy9999 davesilva Scorchin mrb_bk _tca hyPiRion rtl isomorphismes bvad kaiza tov Athas uu1101 Edoxile sivoais drdo KorriX petantik vlopez tromp s_e greymalkin anachron elij wollw `micro wrmsr|somewhere wchun chrisdotcode FreeFull dqd joseph07 imalsogreg FireFly Baughn theorbtwo igniting `^_^v mattp_ mokus trobertson negatratoron__ dilinger s4msung_ FragByte bitraten3 Spockz ft bbee geekosaur mirsal isomorphic solution pingu Kinnison Ptival mrshoe comboy_)
07:42:49 --- names: list (k00mi nakal1 Igloo Boney gsilvis adrienneleigh amf dhrosa tv Starfire murphy_ noam burp idnar Hodapp Nimatek ninegrid Dashkal NikolaiToryzin koninkje_away ybit jglukasik Zouppen michaelpj fiatjaf helgar mimi_vx lpaste ircbrowse codehero SuperTux88 peddie kuyatzu Nickeeh raid `bps alang Paprikachu Jaxan Blkt jinblack fall_ cryptoca Boreeas fergusnoble blast_hardcheese pdxleif tippenein himikof fyolnish ilmig delhage zxq9 mephx dpn` codeburg guampa)
07:42:49 --- names: list (itsmonktastic jnoah erhlee Laney hnjen drone| l3kn GaveUp Haskellfant Guest45278 BrianHV dukedave choose_goose gseitz Denommus Svedrin sprang lucky det TDJACR qwandor|quassel teeteewhy marsbot andrewsw marvimias Dykam eddd mikeym lieven_ sbrg majoh hegge shennyg__ bedouin_ cmsd2 shapr mero @ChanServ tomaw jlewis felipe_ Harbinger knyon xnyhps sordina2 barrucadu waynr Draggor sunnavy asm89 pi8028 xintron mietek Okasu osfameron slobo kittenso1p sveit Dodek ido)
07:42:49 --- names: list (rhodesd Gothmog_ wtw otterdam danking wei2912 Ezku_ troydm qz_ mayski noidi twopoint718 so deavidsedice solirc tomaw- rblackwe Tehnix phaazon Paks McManiaC joshc semberal- cpa_ indiv0 zerokarmaleft Philonous Jonno_FTW Ke squimmy_ lpsmith Chousuke_ nesqi martingale friden danneu pygospa cryon ZsoL mami noplamodo aoh Kithulhu_ finnrobi Bwild JPohlmann krakrjak_ sajith_ kmicu _|d0m|_ bydo mjrosenb statusfailed [swift] thorkilnaur__ nwf yeltzooo BlastHardcheese)
07:42:49 --- names: list (tlevine tassmjau Jyppe_ Watcher7 magicman gridaphobe mrd lusory eagleflo hsc canta dowski kandinski MasseR_ mechairo` lolocaust TheMoonMaster sofancy M-ou-se zomg SwashBuckla ParahSailin lyxia abc56889 cynick mrkishi SolitaryCipher epta CosmicRay Na6hu7Ud_ cjay kragniz cow-orke1 Hafydd kshannon_ earthy sodaplayer_ mikeplus64 feltnerm jameseb heyj d3lxa bitemyapp Taneb fds4345 DanZimm kloeri lispy ChongLi td123 clementd cwc eyem natte pieter_ shiona_ mandu_)
07:42:49 --- names: list (kardboardb notori0us brixen wting eyck_ bernalex DustyDingo ffledgling yam Ulrar farawayexplorer ktosiek luite zebr hc jrslepak AlephNull roo BeardedCoder mp tdammers BeLeKy demolithion dmead tych0 wagle jrw paz__ mads- taruti Bootvis peltchu_ opto ThePhoeron eevar_ karls Zariel kakos LoRez Xack plhk mak` anthraxx42 DasIch Hardolaf Vq fall` vpm yano Nanar hongminhee yan_ vmeson DigitalKiwi relrod mendez_ tmct yorick callumacrae hpd mmaruseacph2 agundry_)
07:42:49 --- names: list (aninhumer Razz naudiz|offline stbuehler Rylee kgadek bsmt asjo hattusili_III eyenx CXXVIIta Internet13 chirpsalot liyang uzo zeroskillor elfangor gidogeek `0660 bcap_zZz Benzi-Junior henrixh MK_FG brandonw aford sixthgear techjunkie davorak davean _1126 honza Soft doismellburning katis_ tessier thoughtpolice froztbyte adlan_ tero- Rutger` monsieurp irssi robbert` flori adimit_away WarzoneCommand Natch alorente monochrom laktech_ petercommand anders^^)
07:42:49 --- names: list (sarlalia1 wto Phillemann aleator_ npcomp ricky ivoscc Derander_ Vorpal sellout theDon petterw Eliel bens mindCrime bergmark Eagle_Erwin Tene srbaker redtricycle no_name xahry_ mixi claudiyoh jaspervdj amesha__ edran Enigmagic dan64 amontez myme2 tstc JZTech101 stvc swen bd_ iota_ Transfusion opqdonut tm512 hopnotch Bane^ evi cursork jasu0 Brando753 pyrtsa inr heikkih PixelCrumbs joe_k cschneid CrossfitGod orb__ noctux arun brisbin deni moop tham_ dario idoru)
07:42:49 --- names: list (jpierre03 flebron shmookey2 shelf diginet ChristianS irdan joefiorini kalz rejuvyesh carter Cryovat spaceships vhz schlumpi zymurgy cmccann ndeine lattenwald humkubum biscarch andyt benmachine rs0 nisstyre TheMue hiredman zz_anildigital dogmaT_ aupo qtplatypus Clint ahf ephess machrider_ tismith hbar_ XMunkki Jello_Raptor felixsch mlen monty Twey simpson agrif dju cin jonathanj Arnar Drezil ByronJohnson Guest97229 zenzike geal levi __jrp__ eristic jrp6 ivan`)
07:42:49 --- names: list (dunj3 Draconx dolio zalami kqr alpha123 heaumer_ qrada__ shachaf poucet ckey` syunull lenstr joelteon marienz bjorkintosh obiwahn Krakarn-- BMeph_ eamelinky rschulman stew elgot_ NickHu_ zoglesby hanDerPeder frms_ sgronblo spacebug mgomezch rieper qwandor kludgy2 dixie_ benbangert mroman_ PartyKatze cyanoacry cmn ziman felixn Gracenotes_ thorstad1 honkfest1val phadej Phlogistique SaBer_ lokydor_ arch__ Liskni_si maaku spion tumdedum yusukesuzuki eazar001)
07:42:49 --- names: list (DanC__ tg dyreshark purefn ibid bcoppens tgkokk runde_ Kobata mr- sleepynate nik_89 billymeter banyan tomejagu1r_away dh ckw xaimus DarkFox sokoll lahwran akurilin fling Sornaensis stoned Plastefuchs phaskell seagreen __main__ copumpkin uber prinsen kosmikus sunfun SHODAN mgregson Martty_ Ornedan_ [mth] AntiSpamMeta earldouglas \u hmax_ malglim knyppeldynan dv- lifenoodles reggie1 Nik05 kav aristid staffehn tridactyla thebnq lericson_ Squid_Ta1er gws ixian8)
07:42:49 --- names: list (Bigcheese integral_ dp_wiz rom1504 mrpantoufle kini Freundlich ggherdov__ T_X_ SLii PHO kjanosz- hiratara werdna Tiktalik gereedy ajcoppa platinuum wjm mikeizbicki mearnsh milli lfox ephemeron nitrix KaneTW comma8 vikraman skarn helgikrs3 Vbitz zpconn__________ melter pii Cr8 Hugglesworth acfoltzer ij cjwelborn chasecaleb flux andares_ sipa c74d alxgnon benzrf|offline Laquendi capybara jungnam lamilami adnap aleator somenick bbastian| jackhill bra jakutis)
07:42:49 --- names: list (fionnan janne)
07:43:10 * hackagebot yesod-dsl 0.1.1.20 - DSL for generating Yesod subsite to manage an RDBMS;  http://hackage.haskell.org/package/yesod-dsl-0.1.1.20 (TeroLaitinen)
07:47:48 <stolaruk> @albeit Wouldn't the map itself just become a strictly-evaluated field of the data type?
07:47:48 <lambdabot> Unknown command, try @list
07:47:56 <stolaruk> sorry
07:48:01 <stolaruk> albeit: ^^
07:49:07 <albeit> stolaruk: Sure, but what does it mean for the Map to become strictly-evaluated? Its normalized down to being a Map, instead of thunks that produce  a Map?
07:50:07 <Aruro> how to switch off "has quit" messages? im on webchat freenode
07:50:19 <stolaruk> albeit: There are strict and lazy versions of IntMap, so you can choose between those, and that will dictate the behavior of the map itself in terms of strictness.
07:51:15 <albeit> stolaruk: Yeah, so I get the Map itself being strict or not strict. But what does making a field, that is map, strict, do?
07:51:26 <albeit> (I'm probably not being very clear, sorry!)
07:52:51 <stolaruk> albeit: The strictness annotation (!) means that a thunk will not be created when there is an expression that calls for the map field of the data type to be evaluated.
07:53:39 <albeit> Okay. So when something requests that field, it will be guaranteed to receive a Map instead of a thunk expression evaluation to a map?
07:54:20 <stolaruk> I believe that is correct. :)
07:54:25 <albeit> Awesome, thanks
07:54:49 <stolaruk> np
08:03:11 * hackagebot influxdb 0.7.1.1 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-0.7.1.1 (MitsutoshiAoe)
08:03:14 * hackagebot hydrogen-prelude 0.2.1 - Hydrogen Prelude  http://hackage.haskell.org/package/hydrogen-prelude-0.2.1 (JulianFleischer)
08:05:11 <Aruro> is xchat a good irc client?
08:05:23 <RevJohnnyHealey> I use it
08:05:59 <Shatoya23>  Hi! I give you some videos. I hope you like! http://tinyurl.com/ozfvxy3
08:11:33 <nshepperd> that spambot never gives up
08:12:07 <ninetta> xchat is not developed anymore
08:12:14 <ninetta> if you really want to use it, use hexchat instead
08:12:58 <ninetta> i don't like it tho. also, hi everyone, i'm just starting to learn haskell
08:13:10 <ninetta> is learn you a haskell a good start?
08:14:18 <albeit_> ninetta: Yes, I used that. I found it helpful to jump between the popular tutorials, as getting different perspectives on the same thing is really helpful
08:14:37 <ninetta> what's another good tutorial?
08:15:08 <albeit_> Real World Haskell is another http://book.realworldhaskell.org/read/
08:15:33 <ninetta> thanks
08:16:58 <ninetta> does anybody use archlinux? do i really need to download the packages from the arch haskell repository or am i all good with the official repo?
08:17:00 <seahorse2> herro
08:17:31 <albeit_> Hi
08:18:01 <seahorse2> i just sent a msg to my other nick on irc
08:18:12 <seahorse2> it reads: Hello my love
08:18:13 * hackagebot xml-push 0.0.0.7 - Push XML from/to client to/from server over XMPP or HTTP  http://hackage.haskell.org/package/xml-push-0.0.0.7 (YoshikuniJujo)
08:19:36 <nshepperd> ninetta: I mostly use ghc from archhaskell and cabal (user-local + sandboxes) for actually installing packages
08:20:36 <nshepperd> but, I'm not sure if I'm doing it the right way either
08:20:49 <hexagoxel> ninetta: i have just ghc installed, and it works all fine for me. if you want executables (like hoogle), you might have to be bit careful not running into cabal hell. maybe arch haskell is better in that respect, have not tried. i use some script to automize sandboxed executable installation
08:21:27 <mroman_> Isn't running everything over cabal the better choice?
08:21:39 <ninetta> thanks both, i guess until i'm just screwing around in ghci i won't have to worry too much about it
08:22:30 <nshepperd> huh, the version of cabal-install in archhaskell is older?
08:22:52 <nshepperd> that doesn't make sense...
08:22:55 <hexagoxel> mroman_: we both suggested that, didn't we?
08:23:13 * hackagebot mangopay 1.9.5 - Bindings to the MangoPay API  http://hackage.haskell.org/package/mangopay-1.9.5 (FelipeLessa)
08:23:19 <dreams> @src (:)
08:23:19 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
08:23:39 <dreams> where can I find the source code for (:)? I just want to see how it is defined.
08:24:07 <seahorse2> (:)  turns into a smiley face
08:24:10 <Iceland_jack> @src []
08:24:11 <lambdabot> data [] a = [] | a : [a]
08:25:30 <dreams> Iceland_jack, yeah I saw this before. but not the definition of (:).
08:25:47 <Iceland_jack> Well that includes the definition of (:)
08:25:58 <Iceland_jack> (:) is a constructor
08:26:04 <hexagoxel> > 1 + 2
08:26:06 <lambdabot>  3
08:26:07 <hexagoxel> > (+) 1 2
08:26:09 <lambdabot>  3
08:26:12 <dreams> Iceland_jack, oh, an infix constructor?
08:26:14 <Iceland_jack> Yes
08:26:41 <Iceland_jack> You can make
08:26:41 <Iceland_jack>     data List a = Empty | a :|> List a
08:26:50 <Iceland_jack> and (:|>) will be like (:)
08:27:08 <Iceland_jack> @let data List a = Empty | a :|> List a deriving Show
08:27:09 <srhb> or data List a = Empty | Cons a (List a) -- and Cons will be like (:)
08:27:10 <lambdabot>  Defined.
08:27:14 <Iceland_jack> Yes
08:27:22 <Iceland_jack> > 3 :|> Empty
08:27:24 <lambdabot>  3 :|> Empty
08:27:28 <Iceland_jack> > 3 : []
08:27:30 <lambdabot>  [3]
08:27:45 <srhb> Clearly that should be the default constructor name. :|> aka "Beaky"
08:27:47 <Iceland_jack> [a] = List a, [] = Empty, (:) = (:|>) in that example
08:27:47 <Iceland_jack>     
08:27:59 <dreams> > 4 :|> 5 :|> 6 :|> Empty
08:28:00 <lambdabot>  No instance for (GHC.Show.Show a0)
08:28:01 <lambdabot>    arising from a use of ‘M58725314858556571178703.show_M58725314858556571178...
08:28:01 <lambdabot>  The type variable ‘a0’ is ambiguous
08:28:01 <lambdabot>  Note: there are several potential instances:
08:28:01 <lambdabot>    instance [safe] GHC.Show.Show
08:28:07 <Iceland_jack> dreams: You'll need parentheses
08:28:12 <Iceland_jack> since I didn't specify the fixity
08:28:19 <Iceland_jack> > 4 :|> (5 :|> (6 :|> Empty))
08:28:21 <lambdabot>  4 :|> (5 :|> (6 :|> Empty))
08:28:25 <dreams> ah ok.
08:28:46 <Iceland_jack> but you can specify that with
08:28:46 <Iceland_jack>     infixr 5 :|>
08:28:46 <Iceland_jack>     data List a = Empty | a :|> List a
08:29:03 <centrinia> :t (:|>)
08:29:03 <lambdabot> a -> List a -> List a
08:29:05 <dreams> Iceland_jack, nice, thanks.
08:29:21 <centrinia> @hoogle List a -> [a]
08:29:24 <lambdabot> Warning: Unknown type List
08:29:24 <lambdabot> Prelude repeat :: a -> [a]
08:29:24 <lambdabot> Data.List repeat :: a -> [a]
08:29:29 <Iceland_jack> centrinia: I just defined that type
08:29:42 <nshepperd> hmm, could I match on `Cons` like f (1 `Cons` Empty) = () in a function?
08:30:01 <nshepperd> or is that a silly idea
08:30:10 <Iceland_jack> nshepperd: sure
08:30:20 <Iceland_jack> you can, it would be easy to try it out either way :)
08:30:29 <Iceland_jack> @undef
08:30:29 <lambdabot> Undefined.
08:30:35 <centrinia> @let listToList Empty = []; listToList (a :|> as) = a:as
08:30:36 <lambdabot>  .L.hs:155:12:
08:30:36 <lambdabot>      Not in scope: data constructor ‘Empty’
08:30:36 <lambdabot>      Perhaps you meant one of these:
08:30:36 <lambdabot>        ‘Seq.EmptyL’ (imported from Data.Sequence),
08:30:36 <lambdabot>        ‘Seq.EmptyR’ (imported from Data.Sequence)
08:30:39 <nshepperd> > let f ((:) 1 []) = () in f [1]
08:30:40 <Iceland_jack> Oops, sorry centrinia
08:30:42 <lambdabot>  ()
08:30:49 <nshepperd> hehehe
08:30:58 <Iceland_jack> @let data List a = Empty | a :|> List a deriving Show
08:31:00 <lambdabot>  Defined.
08:31:02 <centrinia> @let listToList Empty = []; listToList (a :|> as) = a:as
08:31:03 <lambdabot>  .L.hs:160:29:
08:31:04 <lambdabot>      Couldn't match expected type ‘[t]’ with actual type ‘List t’
08:31:04 <lambdabot>      Relevant bindings include
08:31:04 <lambdabot>        as :: List t (bound at .L.hs:160:19)
08:31:04 <lambdabot>        a :: t (bound at .L.hs:160:13)
08:31:41 <Iceland_jack> centrinia: You're missing the recursive call and braces
08:31:50 <centrinia> @let listToList Empty = []; listToList (a :|> as) = a:listToList as
08:31:52 <lambdabot>  Defined.
08:32:04 <Iceland_jack> ah, no braces are fine :)
08:32:21 <nshepperd> ghc should have a helpful "error: insufficient recursion"
08:32:21 <centrinia>  > listToList $ 4 :|> (5 :|> (6 :|> Empty))
08:32:25 <centrinia> > listToList $ 4 :|> (5 :|> (6 :|> Empty))
08:32:27 <lambdabot>  [4,5,6]
08:32:33 <elfangor>  
08:35:58 <michi7x7> ninetta: I'm using Gentoo, install the default ghc-package and use cabal-install for packages
08:53:15 * hackagebot linear-opengl 0.2.0.2 - Isomorphisms between linear and OpenGL types  http://hackage.haskell.org/package/linear-opengl-0.2.0.2 (BenGamari)
08:53:54 <simpson> bgamari: Oh man, I didn't know that I needed this! Thanks!
08:54:06 <bgamari> simpson, heh, no worries!
08:55:03 <simpson> This makes it *way* easier to store coordinates as Linear values and then convert them on-the-fly when rendering. Very nice.
08:56:52 <bgamari> simpson, yep, it all fits together quite nicely
08:57:03 <bgamari> simpson, especially working with transforms
08:58:16 * hackagebot mangopay 1.9.5.1 - Bindings to the MangoPay API  http://hackage.haskell.org/package/mangopay-1.9.5.1 (FelipeLessa)
09:02:30 <athan> So I'm making a DOM combinator library but can't come up with a good name... DOMn? "That's a domn-fine website you got there!"
09:02:42 <cite-reader> DOMinator.
09:02:50 <cite-reader> (Don't do that, that's a terrible name.)
09:04:53 <oakwhiz> athan: dome
09:06:14 <geekosaur> DOMicile?
09:06:18 <athan> oakwhiz, cite-reader: I like dominator.... >:D
09:06:23 <silver__> DOMbledore
09:06:49 <athan> Just make a bunch of unreal tournament references
09:07:42 <monochrom> I like DOMinator.
09:08:04 <monochrom> DOMbinator too :)
09:08:49 <SwashBuckla> haha
09:09:23 <monochrom> DOHM if you want to insert Haskell's H somewhere
09:10:15 <sm> if ($dbg) {
09:10:16 <sm> d(count(storedPlanPricesForQuote($quote)), "\nstored plan prices");
09:10:18 <sm> d(count(storedBuildingProtoPricesForQuote($quote)), 'stored building prototype prices');
09:10:18 <sm> }
09:10:24 <SwashBuckla> ...
09:11:20 <sm> aieeee it burns
09:11:25 <sm> sorry
09:11:45 <beckyconning> this feels like a silly question but is there a really simple way to sample input from the keyboard at a certain rate? e.g. was an arrow key pressed in the last quarter second?
09:11:46 <monochrom> why is the condition $dbg outside d rather than part of what d checks?
09:13:15 <monochrom> no simple way
09:13:18 <sm> good question.. the d's are displayed selectively according to a bunch of different flags
09:13:49 <monochrom> it was actually a rhetorical question. the answer is that the language is strict or eager. this is what's wrong with strict or eager languages.
09:13:56 <athan> monochrom: DOUBLE KILL
09:14:38 <beckyconning> monochrom how about "does anyone have any ideas about finding a way to sample input from the keyboard at a certain rate?" instead?
09:15:33 <vanila> beckyconning: Does the program run in a terminal/command line?
09:16:04 <sm> beckyconning: your question reminds me of c64 programming days
09:16:05 <monochrom> ok, the standard library does not support a way. you will have to find a system-specific library, for example an X Window library if you're measuring through X Window, an ncurses library if you're measuring through ncurses, etc etc.
09:16:12 <beckyconning> vanila: yes : ) i'm porting a terminal snake game i wrote in ruby to haskell.
09:16:42 <vanila> beckyconning, I don't want to recommend ncurses because its sooo horrible but it's basically the way to do this.. sorry :(
09:16:55 <beckyconning> https://gist.github.com/beckyconning/f1d36b7f798f9cb88c6b <- where i have got to so far
09:16:56 <monochrom> and even then, you will have to code up a lot of things yourself. all those libraries tell you is a lot of timestamped keyboard events.
09:18:07 <beckyconning> you can pass updateState a game state and a list of moves over time (which can be created by stayOnCourse) and it will give you the updated game state which you can render with putStr . render
09:19:46 <sm> vty is great, does http://hackage.haskell.org/package/vty-5.2.1/docs/Graphics-Vty-Input.html -> inputForConfig help ?
09:19:57 <monochrom> I misread the question. it's simple with every system-specific library. but you have to choose a system.
09:20:28 <monochrom> "was the arrow key pressed in the last 0.25 seconds" is completely answered by the keyboard events they give you.
09:21:08 <beckyconning> https://gist.github.com/beckyconning/69fb7648ffb099fd3dad
09:21:41 <bakibour> Hidiho
09:22:05 <bakibour> Just installed the latest Haskell Platform, updated cabal and tried to install SublimeHaskell
09:22:47 <beckyconning> monochrom: what would i use for a *nix terminal?
09:22:55 <monochrom> vty
09:23:18 * hackagebot HStringTemplate 0.7.3 - StringTemplate implementation in Haskell.  http://hackage.haskell.org/package/HStringTemplate-0.7.3 (SterlingClover)
09:23:20 * hackagebot HStringTemplate 0.7.1 - StringTemplate implementation in Haskell.  http://hackage.haskell.org/package/HStringTemplate-0.7.1 (SterlingClover)
09:23:22 * hackagebot HStringTemplate 0.7.0 - StringTemplate implementation in Haskell.  http://hackage.haskell.org/package/HStringTemplate-0.7.0 (SterlingClover)
09:23:23 * hackagebot HStringTemplate 0.6.12 - StringTemplate implementation in Haskell.  http://hackage.haskell.org/package/HStringTemplate-0.6.12 (SterlingClover)
09:23:26 * hackagebot HStringTemplate 0.6.10 - StringTemplate implementation in Haskell.  http://hackage.haskell.org/package/HStringTemplate-0.6.10 (SterlingClover)
09:23:27 <bakibour> Which results in an error in the ModuleInspector.hs, can not find the PNeg in Language.Haskell.Exts, checked and it does not seem to be in there anymore. So i threw out the usage of it and ended up with errors that HsDecls and HsBind where not found.
09:23:33 <bakibour> Where can i find these?
09:28:28 * hackagebot HStringTemplate 0.6.11 - StringTemplate implementation in Haskell.  http://hackage.haskell.org/package/HStringTemplate-0.6.11 (SterlingClover)
09:28:30 * hackagebot HStringTemplate 0.6.9 - StringTemplate implementation in Haskell.  http://hackage.haskell.org/package/HStringTemplate-0.6.9 (SterlingClover)
09:28:32 * hackagebot HStringTemplate 0.6.8 - StringTemplate implementation in Haskell.  http://hackage.haskell.org/package/HStringTemplate-0.6.8 (SterlingClover)
09:28:34 * hackagebot HStringTemplate 0.6.6 - StringTemplate implementation in Haskell.  http://hackage.haskell.org/package/HStringTemplate-0.6.6 (SterlingClover)
09:28:36 * hackagebot HStringTemplate 0.6.5 - StringTemplate implementation in Haskell.  http://hackage.haskell.org/package/HStringTemplate-0.6.5 (SterlingClover)
09:31:19 <hexagoxel> bakibour: maybe you are better of constraining your setup to use an earlier version of haskell-src-exts?
09:32:00 <bakibour> hexagoxel: maybe, can i downgrade now or would i need to reinstall everything then?
09:32:50 <monochrom> actually I wonder where you got your current haskell-src-exts. it does not come with Haskell Platform.
09:32:51 <volty> hi, I want to run «hoogle server» on a non protected port (let's say 8080), is it possible? how?
09:33:14 <bakibour> monochrom: I ran cabal update, cabal install cabal-install
09:33:31 <hexagoxel> bakibour: i dunno, try to unregister haskell-src-exts and install specific version. if you get errors, then ... probably no.
09:33:32 <bakibour> and set the path to where it installed everything
09:33:34 <monochrom> that still does not bring in haskell-src-exts.
09:33:38 * hackagebot HStringTemplate 0.6.4 - StringTemplate implementation in Haskell.  http://hackage.haskell.org/package/HStringTemplate-0.6.4 (SterlingClover)
09:33:39 <hexagoxel> gotta go, good luck
09:33:40 * hackagebot HStringTemplate 0.6.3 - StringTemplate implementation in Haskell.  http://hackage.haskell.org/package/HStringTemplate-0.6.3 (SterlingClover)
09:33:42 * hackagebot HStringTemplate 0.6.2 - StringTemplate implementation in Haskell.  http://hackage.haskell.org/package/HStringTemplate-0.6.2 (SterlingClover)
09:33:44 * hackagebot HStringTemplate 0.6.1 - StringTemplate implementation in Haskell.  http://hackage.haskell.org/package/HStringTemplate-0.6.1 (SterlingClover)
09:33:46 * hackagebot HStringTemplate 0.6 - StringTemplate implementation in Haskell.  http://hackage.haskell.org/package/HStringTemplate-0.6 (SterlingClover)
09:33:52 <bakibour> monochrom: Well i installed these packages of course :)
09:35:00 <monochrom> then what hexagoxel says
09:35:35 <pharpend> Somebody's pushing a lot
09:35:41 <pharpend> and in reverse?
09:35:50 <bakibour> meh this would break stylish-haskell, hlint ghc-mod
09:36:26 <NikolajK> I don't seem to understand how Haskell actually deals with implicitly bounded type variables, especially when composing polymorphic functions.
09:36:26 <NikolajK> Here
09:36:26 <NikolajK> http://stackoverflow.com/questions/6462749/church-numerals-in-haskell/6464164#6464164
09:36:26 <NikolajK> zero is of type 'forall x. Church x' and succ_ is of type 'forall x. Church x -> Church x'.
09:36:26 <NikolajK> When you write 'succ_ zero', Haskell returns a 'Church x', which implies it kept track of the forall x and pushes it through, while the application is performed. The code is in contrast to
09:36:26 <NikolajK> https://i.4cdn.org/sci/1411078465567.png
09:36:26 <NikolajK> where succ isn't of type 'forall x. Church x -> Church x' but rather '(forall x. Church x) -> (forall x. Church x)'. It might be effectively the same, but if you look at who succ is written down there, \lamdba z is actually the first abstraction! and then it's followed by a type level abstraction - something which I think isn't even possible in Haskell.
09:36:27 <NikolajK> The pic is from Jacobs "Categorical logic and Type theory" and it claims ML for example is similar to that.
09:36:35 <bakibour> Would it not be worth the hassle to try to get the ModuleInspector.hs up to date?
09:36:57 <monochrom> then you will have to find out whether, for example, the ghc-mod version you like can stand an older version of haskell-src-exts.
09:37:30 <monochrom> I don't know. I don't know ModuleInspector.hs.
09:37:40 <bakibour> The initial reason for updating everything wa that i saw a video of ghc-mod beeing able to use holes
09:37:59 <bakibour> monochrom: Its used in SublimeHaskell
09:38:01 <xeno> anyone here using EclipseFP?
09:38:15 <monochrom> well, I don't know SubblimeHaskell
09:38:48 <bakibour> Are HsDecls and HsBinds packages that come with GHC?
09:38:56 <bakibour> Modules i mean
09:39:14 <monochrom> no
09:39:44 <shapr> NikolajK: sounds like a question for the haskell-cafe mailing list
09:40:43 <bakibour> http://www.haskell.org/ghc/docs/7.2.1/html/libraries/ghc-7.2.1/HsDecls.html so i guess it is just not featured anymore in GHC 7.8.3?
09:42:08 <monochrom> sorry, HsBinds and HsDecls are modules that come with GHC
09:42:15 <xeno> so what do you all use? emacs all of you or...?
09:42:45 <bakibour> So maybe there is a path missing? Or is there a cabal package that i can pull these with?
09:42:57 <monochrom> I don't know SublimeHaskell and I don't know what its error messages are talking about. I thought I could guess from your interpretation.
09:43:43 <bakibour> Well the source tries to import HsDecls and HsBinds, they are both listed here http://www.haskell.org/ghc/docs/7.8.3/html/libraries/ghc-7.8.3/index.html
09:46:24 <bakibour> Ok they come in the Haskell Platform.
09:49:19 <linux> Hello. I was getting this error when running 'cabal info happy': cabal: Command.optionToFieldDescr: feature not implemented. I deleted the 'Jobs: ...' from ~/.cabal/config, now I'm getting some warnings. Is it normal?
09:49:45 <linux> Warnings like: /home/linux/.cabal/config: Unrecognized stanza on line 140, /home/linux/.cabal/config: Unrecognized stanza on line 111
09:52:04 <monochrom> I cannot reproduce it. versions?
09:53:53 <linux> monochrom, cabal-install version 1.16.0.2
09:54:28 <linux> monochrom, it was all well I think till I did a reinstall of all packages after enabling documentation in .cabal/config :-P
09:54:41 <monochrom> that may be a bit old and doesn't like the new config file. but I wonder how you got the new config file in the first place.
09:54:53 <chirpsalot> Is there an easy way to print 'n' digits of a Rational?
09:55:24 <linux> monochrom, what would be the best method to upgrade? cabal install cabal-install will do it?
09:55:34 <monochrom> yes, but mind PATH
09:55:54 <linux> monochrom, what about the PATH?
09:56:06 <monochrom> I still don't understand why you got a new config file with all the lines that 1.16 does not know
09:56:53 <monochrom> the executable will be put in $HOME/.cabal/bin
09:56:57 <linux> I have no idea about that, I just installed cabal, ghc, etc. according to instructions on the web
09:58:17 <linux> monochrom, So I should make sure ~/.cabal/bin is in the PATH before I upgrade cabal?
09:58:20 * hackagebot rest-wai 0.1.0.4 - Rest driver for WAI applications.  http://hackage.haskell.org/package/rest-wai-0.1.0.4 (AdamBergmark)
09:58:22 * hackagebot rest-happstack 0.2.10.3 - Rest driver for Happstack.  http://hackage.haskell.org/package/rest-happstack-0.2.10.3 (AdamBergmark)
09:58:24 * hackagebot rest-snap 0.1.17.14 - Rest driver for Snap.  http://hackage.haskell.org/package/rest-snap-0.1.17.14 (AdamBergmark)
09:58:26 * hackagebot rest-gen 0.16 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.16 (AdamBergmark)
09:58:28 * hackagebot rest-core 0.33 - Rest API library.  http://hackage.haskell.org/package/rest-core-0.33 (AdamBergmark)
09:58:41 <bakibour> linux: are you using Haskell Platform?
09:58:45 <monochrom> before or after. perhaps better before.
09:59:00 <linux> monochrom, I just checked, it's already in the path. :-)
09:59:14 <monochrom> ok, but order matters, do you know that?
09:59:40 <linux> monochrom, should I push it to the front of everything else?
09:59:54 <monochrom> that depends on your priority. I cannot decide for you.
09:59:57 <linux> bakibour, I think so, my brother set it up for me on lubuntu
10:00:11 <bakibour> What does this tell me? HsBinds ... It is a member of the hidden package `ghc-7.8.3'.
10:00:43 <linux> monochrom, there's only ruby stuff in front of it, so all should be good
10:02:16 <bakibour> Can i link against hi files? These are in the Haskell
10:02:25 <bakibour> Platfrom folder
10:02:45 <geekosaur> they're additional information, not actually linkable /per se/. what exactly are you trying to do?
10:03:24 <Kinnison> dddd/win 23
10:03:30 * hackagebot rest-types 1.11 - Silk Rest Framework Types  http://hackage.haskell.org/package/rest-types-1.11 (AdamBergmark)
10:03:32 * hackagebot rest-client 0.4.0.1 - Utility library for use in generated API client libraries.  http://hackage.haskell.org/package/rest-client-0.4.0.1 (AdamBergmark)
10:03:53 <bakibour> geekosaur: I have a .hs file in SublimeHaskell (does not really matter though what file) and it uses HsBind HsDecls etc.
10:04:26 <bakibour> And it seems i try to get this file to compile for the latest ghc-mod etc versions
10:04:44 <bakibour> So i can use Sublime with GHC-7.8.3
10:05:54 <geekosaur> I don't think manually linking will help here
10:06:12 <Lara23>  You can find funny videos here. http://tinyurl.com/ozfvxy3
10:06:16 <bakibour> geekosaur: So i would need the sources?
10:06:28 <geekosaur> probably contact the SublimeHaskell maintainers
10:06:33 <geekosaur> very likely, yes
10:06:50 <bakibour> Is there a cabal package to get the GHC sources?
10:07:18 <geekosaur> not currently. it's intended someday but the ghc build process needs to be completely rewired to be cabal compatible
10:07:38 <bakibour> Meh
10:10:32 <linux> Which indent mode do you guys use for Haskell in emacs?
10:13:21 * hackagebot git-annex 5.20140919 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20140919 (JoeyHess)
10:25:24 <augustl> the docs say that ! is an operator. Then how come I'm allowed to define a function named !? https://gist.github.com/augustl/ea7ff49b99cc4c7f5378
10:25:46 <augustl> "a function named \!?" I should say, that sentence looked more aggressive than I intended :)
10:27:21 <SheldonCooperPhD> Greetings, ladies & gentlemen. Feels good to be here. You enter..& BOOM! You start learning new shit. :)
10:27:38 <glguy> augustl: An operator is one or more operator characters
10:27:54 <glguy> + and ++ can both exist just like ! and !?
10:28:08 <SheldonCooperPhD> >= , <= ,
10:28:51 <augustl> glguy: what I meant to say, I have a function named "!"
10:29:13 <augustl> and "!" is an operator. Haskell and written english didn't blend well
10:29:50 <vanila> How do I generate random trees of a given size?
10:29:57 <vanila> (size roughly)
10:30:10 <glguy> An "operator" is a name for a value that you apply with infix notation
10:30:24 <nadirs> Hullo everyone
10:30:50 <glguy> augustl: Can you rephrase your question? I don't think I understand the distinction that's is confusing you.
10:31:40 <nadirs> I'm writing a small library + CLI interface, what's the most commonly used library for handling cli args/commands?
10:31:51 <nadirs> I'm heading to optparse-applicative
10:32:06 <glguy> Most common is System.Console.GetOpt from the base library
10:32:22 <nadirs> glguy: does it support commands too or just flags?
10:32:39 <glguy> it gives you back the non-flags
10:33:55 <nadirs> glguy: it seems a good choice for a first time user like me. Thanks!
10:34:09 <nadirs> I can use just flags instead of commands after all :)
10:35:21 <merijn> augustl: There is no difference between "function" and "operator"
10:35:27 <augustl> glguy: "!" is a keyword, according to http://www.haskell.org/haskellwiki/Keywords
10:35:34 <augustl> I just realized I said operator and meant keyword :)
10:36:02 <merijn> augustl: ah, for the same reason that you can define "-->" as operator even though -- is a comment symbol
10:36:14 <glguy> augustl: ! has special meaning when used in data declarations and patterns, but those contexts can be distinguished from value contexts
10:36:34 <merijn> augustl: I wouldn't really trust that wiki page for language specification
10:36:48 <merijn> augustl: If you want details about what parses, etc. consult the Haskell2010 report
10:36:52 <Hodapp> I keep my shopping list on Wikipedia.
10:36:55 <Cale> nadirs: optparse-applicative is really cool though :)
10:36:57 <Hodapp> It's easier to get to it later from the store.
10:37:04 <augustl> the reason I'm asking is that I spent some time trying to figure out what ! was in Text.XHtml and was surprised that it was possible to use ! as a user defined function
10:37:06 <glguy> data T = C !Int !Char   -- There's no ambiguity here, it couldn't be the value (!)
10:37:09 <augustl> guess it's just another lession learned :)
10:37:35 <glguy> f !x = 10 -- that's definitely a pattern so there's no ambiguity
10:37:43 <Cale> Well, there is ambiguity
10:37:48 <merijn> glguy: That last one requires an extension
10:37:48 <augustl> makes sense, thanks
10:37:52 <nadirs> Cale: it has to be, it's applicative :D
10:37:54 <nadirs> I don't know why applicative feels so much more cool than monads :/
10:37:55 <glguy> merijn: Correct
10:38:11 <Cale> glguy: That might be  f ! x = 10, i.e. a definition of !
10:38:16 <xplat> i hated dealing with commandline args in haskell until optparse-applicative; now it's my favorite language for commandline opts
10:38:29 <Cale> > let f ! x = 10 in 8 ! 5 -- let's see what happens
10:38:30 <lambdabot>  Could not deduce (GHC.Arr.Ix i0)
10:38:30 <lambdabot>    arising from the ambiguity check for ‘e_11085’
10:38:30 <lambdabot>  from the context (GHC.Arr.Ix i,
10:38:30 <lambdabot>                    GHC.Num.Num (GHC.Arr.Array i e),
10:38:30 <lambdabot>                    GHC.Num.Num i)
10:38:34 <xplat> i cannot recommend it enough
10:38:35 <Cale> heh
10:39:01 <Cale> So, it probably defined f instead, because bang patterns are on
10:39:16 <Cale> and then the ! in the expression referred to the one in scope from Data.Array
10:40:09 <xplat> > let (!) f x = 10 in 8 ! 5 -- this works though
10:40:11 <lambdabot>  10
10:43:23 * hackagebot map-syntax 0.2 - Syntax sugar for defining maps  http://hackage.haskell.org/package/map-syntax-0.2 (DougBeardsley)
10:45:21 <Qfwfq> Alternatively: "hflags" is semantically evil, but really quite convenient.
10:47:02 <Qfwfq> On "!": has a special meaning in pattern contexts, but is permissible as a value; such is evidenced by indexing 'Data.Vector.Vector'.
10:48:53 <merijn> Qfwfq: ! actually doesn't have a special meaning in pattern contexts
10:49:16 <merijn> Qfwfq: There happens to be an extension that gives it special meaning in pattern contexts, but that's not default behaviour
10:49:23 * augustl observes and consumes
10:50:29 <Qfwfq> Is -XBangPatterns enabled by default? I had not realised it wasn't part of the Haskell2010 specification.
10:52:04 <merijn> Qfwfq: It's not
10:52:52 <Qfwfq> !!!
10:52:53 <monochrom> BangPatterns is not enabled by default. not part of Haskell 2010
10:53:57 <Qfwfq> Posts on the Haskell' list indicate no consensus on semantics as recently as 2013-02, though it is being considered.
10:55:05 <Qfwfq> To quote SheldonCooperPhD, "You enter [this channel]..& BOOM! You start learning new shit. :)".
10:55:59 <monochrom> heh
10:56:56 <clrnd> hello :)
10:58:24 * hackagebot docker 0.1.0.1 - Haskell wrapper for Docker Remote API  http://hackage.haskell.org/package/docker-0.1.0.1 (denibertovic)
10:59:37 <dmj`> how does one make hackage build documentation?
10:59:43 <michi7x7> is there still someone working on haskellwiki? most links appear to be dead and there is almost no new content
11:01:50 <glguy> dmj`: You don't, but you can upload documentation for your own package
11:02:24 <glguy> dmj`: If you want to upload documentation, you can check out how I do it for lens: https://github.com/ekmett/lens/blob/master/scripts/hackage-docs.sh
11:03:00 <begriffs> Is there a safe version of (!!) that gives a Maybe?
11:04:16 <glguy> > preview (ix 2) "Are you using lens already?"
11:04:18 <lambdabot>  Just 'e'
11:04:34 <Qfwfq> glguy: Haha.
11:04:37 <edwardk> > "yes"^?ix 1
11:04:39 <lambdabot>  Just 'e'
11:05:21 * glguy lights up edward's client: lens lens lens lens
11:05:29 <edwardk> ack!
11:05:33 <begriffs> haha
11:05:45 <monochrom> that is like the Bat Sign
11:06:01 <edwardk> i usually have that notification off these days, it pings too frequently ;)
11:06:09 <xplat> does that make this a Bat Channel?
11:06:35 <begriffs> Looks like there's also atMay in the safe package.
11:06:53 <glguy> begriffs: That sounds like a pig-latin name
11:07:34 <sclv__> michi7x7: the wiki is a community effort. it always needs more help!
11:07:51 <sclv__> grab an acct and feel free to jump in
11:11:48 <phaazon_> bloody hell
11:12:02 <phaazon_> I just figured out ghc-mod uses my monad-journal lib
11:12:08 <phaazon_> I’m so glad and proud :D
11:12:14 <dmj`> glguy: this is huge, thanks a lot. Is there any reason why cabal sdist doesn't include the necessary info already?
11:12:57 <dmj`> glguy: does Galois run hackage?
11:13:19 <Qfwfq> phaazon_: There's packdeps which describes the reverse dependencies of all packages, should you be curious about your others.
11:13:35 <Qfwfq> phaazon_: Though mostly that site makes me sad ;-).
11:14:24 <phaazon_> Qfwfq: yes
11:14:26 <phaazon_> that’s how
11:14:27 <hexagoxel> dmj`: maybe because the docs are technically redundant data? should be possible to generate them server-side
11:14:31 <phaazon_> I discovered that
11:14:45 <phaazon_> the maintainer, DanielG, contributes a bit to my lib
11:14:49 <phaazon_> so it’s not that curious
11:14:53 <phaazon_> I read a bit of his code
11:14:56 <phaazon_> see how he uses my lib
11:15:05 <dmj`> hexagoxel: I agree, but hackage isn't generating them server-side so we have to do it manually, wondering why this is
11:15:06 <monochrom> pig-latin haskell: headMay, tailMay, fromLeftMay...
11:15:06 <glguy> dmj`: I don't know why cabal-install doesn't do it, you'll have to ask. Maybe no one implemented it.
11:15:09 <phaazon_> I spotted a few instances to pack upstream :)
11:15:14 <glguy> dmj`: Galois doesn't host hackage anymore
11:15:37 <hexagoxel> dmj`: because hackage is temporarily broken, afaik
11:16:15 <glguy> They turned off server-side building until they can get it off the web server because it was over-burdening the computer and it was a security risk as far as I know
11:17:16 <oakwhiz> I'm trying to figure out how to use Blaze HTML in Haskell and I'm having trouble with functions of type Html -> Html
11:17:23 <monochrom> oh, I remember now, a few weeks ago hackage became very slow, it was diagnosed to the building part.
11:17:23 <Qfwfq> What's a "Context reduction stack overflow", and how should I reason about it?
11:17:42 <dmj`> glguy: k thanks, and thanks for you script
11:17:42 <dmj`>  
11:17:55 <Haskellfant>  i'm looking for advice on how to implement some timetable that will be modified from one thread (using information i'll get from an external ical file) and another thread should react if the time of one of the events in the timetable is reached. is there a better way then to repeatedly cycle through the timetable (which in this case could just be a list/map) at regular intervals and check if in one of the
11:17:57 <Haskellfant> events should be in this interval?
11:17:59 <oakwhiz> How do you put nothing into a function of type Html -> Html
11:18:05 <glguy> dmj`: Please let me know if it works or not for you, and if you think of any way to improve it I'd love to hear that, too
11:18:23 <Qfwfq> Context: http://sprunge.us/gHUO
11:18:36 <dmj`> glguy: k I'll try it right now
11:18:49 <stolaruk> oakwhiz: You can't.
11:19:23 <oakwhiz> stolaruk: so how would you generate <span></span> in Blaze?
11:19:26 <Qfwfq> I assume it's trying to determine the equivalence of that Nat and it's representation as an exponent.
11:20:20 <stolaruk> oakwhiz: I don't know. I probably didn't understand your initial question.
11:20:34 <glguy> oakwhiz: You'd probably use an "empty" value, whatever that empty value is for blaze html
11:21:50 <oakwhiz> I couldn't find any empty value in the docs so I tried just putting "" and it typechecks
11:22:58 <xplat> Haskellfant: a simple way would be to sort the events and just check the front of the list, then you only have to go deep in the list to add new events
11:23:02 <dmj`> glguy: you are my hero
11:23:09 <dmj`> glguy:+++++++++++++++++
11:23:24 <Haskellfant> xplat: at least if i delete old ones, right
11:23:26 * hackagebot smallcaps 0.6.0.0 - Flatten camel case text in LaTeX files  http://hackage.haskell.org/package/smallcaps-0.6.0.0 (StefanBerthold)
11:23:31 <glguy> I learned how to do it from bitemyapp's makefile :)
11:23:37 <xplat> Haskellfant: an even faster way if you have a lot of events would be a priority queue
11:23:44 <dmj`> glguy: http://hackage.haskell.org/package/ses-html-0.2.0.1/docs/Network-SES.html
11:23:48 <joseph07> oakwhiz: Yes that would be correct, MarkupM has an IsString instance, but explicitly you're doing (fromString "" :: Html)
11:23:49 <dmj`> glguy: I still give you credit :)
11:24:01 <xplat> Haskellfant: you could delete the old ones, or just keep them in a separate list
11:24:14 <Haskellfant> xplat: well in both cases i still need to check every minute or so. i thought there might be a nice way to get around this.
11:24:21 <joseph07> oakwhiz: OverloadedStrings calls fromString for you
11:24:23 <glguy> dmj`: Cool, looks right to me
11:24:50 <Qfwfq> https://github.com/konn/sized-vector/pull/4#issuecomment-56215304
11:25:09 <xplat> Haskellfant: well, if you look up the next event (first in the list or priority queue) and it's far away you could sleep longer
11:25:19 <Haskellfant> hm right
11:25:43 <xplat> oakwhiz: might also try mempty
11:25:44 <oakwhiz> joseph07: I see. It's probably a better idea to use toHtml to avoid mistakes that could lead to injection.
11:25:55 <Haskellfant> then i might need to wake up the thread from the other thread
11:26:10 <Haskellfant> xplat: thx for your help, now i have some ideas to play around with
11:27:49 <oakwhiz> xplat: mempty typechecks, that's a better solution, thanks
11:28:19 <joseph07> oakwhiz: mempty works becasue MarkupM also has a Monoid instance, just so you know
11:29:18 <oakwhiz> joseph07: I noticed a lot of the stuff in Blaze has a monoid instance
11:29:27 <oakwhiz> like ServerPart
11:29:41 <joseph07> oakwhiz: http://bit.ly/1qiR16w shows the docs for MarkupM. Html aliases to Markup which aliases to MarkupM (). Indirection!
11:31:22 * dmj` feels better now that more packages have documentation on hackage
11:37:12 <bitemyapp> dmj`: did something change?
11:37:38 <dmj`> bitemyapp: I used your shell script to generate docs for 2 pkgs
11:38:28 <glguy> Well, my shell script, but yes inspired by bitemyapp's process :-p
11:38:45 <bitemyapp> dmj`: oh, eggscellent.
11:38:48 <michi7x7> is there a nice snippet that shows actual use of Control.Monad.Tardis ?
11:38:54 <bitemyapp> glguy: I need to steal your script *back*
11:39:09 <bitemyapp> glguy: I didn't know you'd used my Makefile to figure out how to do it. I'm honored :)
11:39:10 <glguy> bitemyapp: typical open source
11:39:14 <dmj`> ahhh! I need to give proper attribution, bitemyapp+++, glguy+++
11:39:15 <bitemyapp> glguy: works4me :D
11:39:23 <bitemyapp> @karma+ glguy
11:39:23 <lambdabot> glguy's karma raised to 27.
11:39:26 <bitemyapp> @karma+ dmj`
11:39:26 <lambdabot> dmj`'s karma raised to 2.
11:39:28 <bitemyapp> LOVEFEST
11:39:28 <xplat> Control.Monad.Tardis
11:39:33 <bitemyapp> xplat: it's hilarious, no?
11:39:35 <glguy> wow, it's getting a little hot in here
11:39:46 <dmj`> @karma+ bitemyapp
11:39:47 <lambdabot> bitemyapp's karma raised to 8.
11:40:08 * dmj` wipes off steam from retina screen
11:40:08 <xplat> glguy: so log off all your clones
11:40:58 <glguy> xplat: Those bots don't have kill switches, they're self-aware now
11:41:57 <michi7x7> just makes a kill-switch more needed than before
11:42:08 <Qfwfq> I was like, good gracious, the bazaar is contagious / I'm flirtatios, tryin' to show precedence
11:42:11 <dfeuer> Does GHC know how to replace quot and rem with quotRem?
11:42:18 <oakwhiz> glguy: I'm sure the NSA has us covered
11:54:32 * Qfwfq is once more bitten by GHC's non-deterministic package ID generation.
11:56:30 <monochrom> Qfwfq: see my http://www.vex.net/~trebla/haskell/sicp.xhtml#hash for why it is actually protecting you.
11:56:57 <monochrom> there was a time it was not done. the pasture was not greener there.
12:00:01 <monochrom> you are basically looking at the trade-off between build-time errors and run-time crashes.
12:03:10 <phaazon> hm, haddock@hackagedb still not running?
12:03:12 <phaazon> dammit? :D
12:04:00 <bitemyapp> phaazon: gotta upload your own.
12:04:26 <phaazon> arf, ok, thank you
12:04:26 <bitemyapp> phaazon: https://github.com/ekmett/lens/blob/master/scripts/hackage-docs.sh
12:04:33 <bitemyapp> phaazon: courtesy glguy :)
12:04:49 <phaazon> yeah, I was looking for that script exactly!
12:04:52 <phaazon> glguy: <3
12:06:25 <dmj`> mapM_ (<3) [glguy, bitemyapp]
12:06:38 <phaazon> that’s digusting dmj` :D
12:06:43 <dmj`> @def (<3) = print
12:06:43 <lambdabot>  Parse failed: Parse error in pattern: < 3
12:06:52 <phaazon> traverse (<3) [glguy,bitemyapp]
12:07:00 <phaazon> even more digusting :D
12:07:54 <dmj`> @typ (<3)
12:07:56 <lambdabot> (Ord a, Num a) => a -> Bool
12:08:47 <oakwhiz> lol
12:09:00 <Ferdirand> could do @def (<) = const print ?
12:09:07 <Ferdirand> and enjoy the breakage
12:09:38 <oakwhiz> or define people's names as integers so that you can apply the less-than-three function to them
12:10:21 <Qfwfq> Or use one of the unicode symbols for &heart;
12:10:27 <monochrom> all you need is "instance Num String where ..." and turn on a couple of extensions
12:10:39 <phaazon> please don’t.
12:11:45 <steffen> I test my code with quickcheck and I have a predefined tesuite for
12:11:45 <steffen> 	  which all tests have to pass. My backend does not allow for more
12:11:49 <steffen> 	  than 65 connections and I'm stuck trying to reduce quickchecks
12:11:52 <steffen> 	  default number of tests for the function: "testProperty" from
12:11:52 <steffen> 	  Test.Framework.Providers.QuickCheck2. Can someone please help me?
12:11:57 <steffen> sorry for that^^ :)
12:12:09 <monochrom> instance Num String where fromInteger 3 = [maxBound :: Char]
12:12:44 <monochrom> that should be enough to ensure that x<3 is true for all strings x that are people's names.
12:13:03 <xplat> instance Num String where fromInteger 3 = repeat maxBound
12:13:20 <Qfwfq> Neat.
12:13:44 <monochrom> pardon me for Friday evil code
12:13:58 <jle`> nobody minds a little bit of evil friday
12:14:38 <xplat> instance Num String where fromInteger = take `flip` repeat maxBound
12:15:05 <phaazon> https://hackage.haskell.org/package/monad-journal yeah! uploaded :)
12:15:24 <phaazon> it says there’s no changelog, whereas there is one
12:15:25 <jle`> > i (<3) u
12:15:26 <lambdabot>  Ambiguous occurrence ‘i’
12:15:26 <lambdabot>  It could refer to either ‘L.i’, defined at L.hs:157:1
12:15:26 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.i’,
12:15:26 <lambdabot>                           imported from ‘Debug.SimpleReflect’ at L.hs:118:1-26
12:15:26 <lambdabot>                           (and originally defined in ‘simple-reflect-0.3.2:De...
12:15:27 <volume_dial> anyone know how to get EclipseFP to hide the popup cmd windows? it's really irritating
12:15:35 <phaazon> is there something to put in the .cabal?
12:15:42 <phaazon> :t (<3)
12:15:43 <lambdabot> (Ord a, Num a) => a -> Bool
12:15:48 <jle`> darn
12:16:07 <phaazon> > (<3) 9
12:16:09 <lambdabot>  False
12:16:14 <phaazon> > (<3) 0
12:16:15 <lambdabot>  True
12:16:22 <phaazon> what the… :D
12:16:38 <geekosaur> it's a section on (<)
12:16:51 <phaazon> oh yeah
12:16:56 <phaazon> I’m stupid :D
12:17:01 <monochrom> yeah, it's in the same genre as (* 4) and (c ++)
12:17:02 <Qfwfq> > let i = id; u=2 in (i (<3)) u
12:17:03 <lambdabot>  True
12:17:07 <xplat> (+) = (++); (*) = (. const) . (>>=)
12:17:35 <monochrom> this is why it suffices to define fromInteger 3 :)
12:17:56 <jle`> strings form seminearrings, so...they should be totes numabble
12:18:08 <jle`> except (*) doesn't commute
12:18:37 <monochrom> well they make (*) for matrices too.
12:18:48 <phaazon> and it’s confusing
12:18:51 <phaazon> (in linear)
12:18:51 <jle`> i was considering any possible Num laws
12:19:02 <monochrom> phaazon is so mad at what I started now :)
12:19:10 <phaazon> ahah
12:19:13 <jle`> Num being cleverly named as to avoid any link to real algebraic structures
12:19:18 <jle`> so you don't have to have laws
12:19:29 <phaazon> no, I just had a few issues with linear’s matrices’ (*)
12:19:36 <xplat> it
12:19:43 <jle`> ...this is what would have happened if we had named Monoid Appendable or Functor Mappable/Container or something
12:20:09 <xplat> it has become ... comfortably Num
12:20:12 <phaazon> now it’s solved, I admit I was mistaken
12:20:20 <monochrom> oh, Container would be completely ambiguous and vague and undefined, yeah
12:20:31 <jle`> just like Num! :D
12:20:55 <xplat> monochrom: actually Container retroactively got a mathy definition
12:20:59 <phaazon> I hope we’ll have the haddock-upload on hackagedb soon
12:21:15 <phaazon> I still wonder why the documentation doesn’t generate immediately by iteslef
12:21:18 <phaazon> itself*
12:21:22 <phaazon> why using a cronie job?
12:21:59 <xplat> Mappable and Appendable are still pretty vague though
12:22:10 <dmj`> phaazon: it's turned off on hackage, according to glguy
12:22:51 <jle`> yeah, that was in reference to protest of haskell typeclasses having intimidating and "mathy" names
12:22:57 <xplat> buildbot was not pulling its weight, got fired
12:23:02 <phaazon> dmj`: why?
12:23:03 <jle`> "if you call it Monoid then we will scare all newcomers away"
12:23:20 <phaazon> jle`: well, a Monoid IS a monoid
12:23:22 <dmj`> phaazon: what is haddock-upload? It'd be good to make a type safe wrapper around bitemyapp + glguys shell script...
12:23:24 <phaazon> how would one call it
12:23:27 <xplat> no way, everyone love monoids!  they're so easy!
12:23:38 <jle`> phaazon: exactly :P
12:23:41 <jle`> there was a real debate though
12:23:42 <xplat> *loves
12:23:45 <jle`> a heated debate
12:23:49 <phaazon> dmj`: nothing, I was just mentionning
12:23:55 <jle`> when Monoid was being brought into haskell
12:24:01 <phaazon> jle`: ?
12:24:07 <phaazon> was it call Assoc?
12:24:13 <phaazon> or that kind of weirder stuff?
12:24:21 <jle`> i forgot what the other proposed names were, but they all had to do with things that sounded more friendly
12:24:23 <phaazon> to me, Monoid is the best name picked
12:24:28 <jle`> and less intimidaty-mathsy
12:24:34 <xplat> that's why people say 'a monad is just a monoid in a category of endofunctors, what's the problem?'
12:24:53 <dmj`> phaazon: this script works, https://github.com/dmjio/ses-html/blob/master/scripts/hackage-docs.sh
12:24:54 <jle`> but the best part about typeclasses are the laws, so, i'm glad it ended up that way
12:24:58 <phaazon> dmj`: yeah
12:25:00 <phaazon> I just used it:
12:25:08 <phaazon> https://hackage.haskell.org/package/monad-journal
12:25:10 <jle`> um if you search around in the mailing list archives you might find records of these debates
12:25:21 <phaazon> (I’m so amazed by the downloads \o)
12:25:25 <xplat> did anyone want to call Monoid FluffyWhiteLamb ?
12:25:28 <jle`> they were vicious
12:25:31 <phaazon> jle`: thanks :)
12:25:41 <dmj`> there's a record of the monoid name debates in the typeclassopedia
12:25:47 <jle`> oh really?
12:25:55 <xplat> cute small animals can be surprisingly vicious when cornered
12:26:16 <dmj`> jle`: this is it I believe http://thread.gmane.org/gmane.comp.lang.haskell.cafe/50590
12:26:46 <jle`> ty :)
12:27:01 <phaazon> oh?
12:27:03 <jle`> oh brian does spend time talking about it in the typeclassopedia, neat
12:27:06 <phaazon> Monoid is almost 6 yo?
12:27:16 <bitemyapp> jle`: tend to agree with Augustsson.
12:27:22 <bitemyapp> for the same exact reasons.
12:27:22 <dmj`> jle`: np :P
12:28:08 <joelteon> happy belated birthday monoid
12:28:13 <jle`> :D
12:28:30 <dfeuer> Does anyone know if GHC optimizes quot and rem to quotrem?
12:28:41 <jle`> i've come to the conclusion that equational reasoning through well defined laws is one of the best and potentially unintentional results to come out of typeclasses
12:28:56 <bitemyapp> jle`: yep.
12:28:57 <jle`> where you can literally do rewrites and substitutions on generic code
12:29:00 <monochrom> my only objection to "plain English" names is that people have presumptions on what they mean. look at what happens to "return".
12:29:11 <bitemyapp> monochrom: "transducer"
12:29:14 <dfeuer> jle`, unfortunately, some instances don't obey laws.
12:29:14 <jle`> yeah, exactly
12:29:27 <jle`> dfeuer: yes :'(  well, you take what you can
12:29:29 <dfeuer> What is a transducer?
12:29:37 <jle`> i was just complaining about Num fifteen minutes ago
12:30:05 <dfeuer> jle`, as unfortunate as Num is, it almost makes sense when compared to Enum.
12:30:09 <bitemyapp> dfeuer: good luck figuring it out.
12:30:23 <dfeuer> bitemyapp, figuring what out?
12:30:36 <bitemyapp> dfeuer: what a transducer is :D
12:30:38 <dmj`> instead of return, it could have been 'lift', but then what would 'lift' be?
12:30:52 <bitemyapp> dmj`: map
12:31:01 <bitemyapp> return could've been wrap as well.
12:31:17 <dfeuer> It's a finite state machine with two tapes, apparently.
12:31:19 <bitemyapp> I think inject is another one I hear a lot.
12:31:26 <bitemyapp> wrap monad, unwrap comonad has a nice symmetry to it.
12:31:48 <dfeuer> wrap has other meanings.
12:31:53 <edwardk> bitemyapp: a transducer is recognizing that the signature of foldl splits
12:31:55 <edwardk> :t foldl
12:31:56 <lambdabot> (b -> a -> b) -> b -> [a] -> b
12:32:04 <bitemyapp> (b -> a -> b) -> (b -> [a] -> b) ?
12:32:06 <dfeuer> Splits?
12:32:26 <edwardk> yes, now replace a and [a] with two things and quantify over the bs
12:32:26 <edwardk> done
12:32:34 <monochrom> dfeuer: do you want -O1 or -O2?
12:32:37 <mjrosenb> bitemyapp: usually you omit the parens around the rhs of an arrow.
12:32:40 <edwardk> type Transducer x y = forall b. (b -> y -> b) -> (b -> x -> b)
12:32:44 <edwardk> tada transducer
12:32:48 <edwardk> they compose like lenses
12:32:50 <edwardk> nuff said
12:32:50 <bitemyapp> mjrosenb: look at edwardk's type.
12:32:54 <bitemyapp> mjrosenb: emphasizing something.
12:33:08 <dfeuer> monochrom, if you're talking about quotRem, either is fine.
12:33:19 <edwardk> now the left and right are 'of the same shape
12:33:22 <edwardk> :t foldl.foldl
12:33:23 <lambdabot> (b -> a -> b) -> b -> [[a]] -> b
12:33:25 <edwardk> :t foldl.foldl.foldl
12:33:26 <lambdabot> (b -> a -> b) -> b -> [[[a]]] -> b
12:33:35 <edwardk> yay transducers, next? =)
12:33:40 <mjrosenb> bitemyapp: I did say 'usually', not 'always'
12:33:49 <bitemyapp> mjrosenb: I know how (->) works
12:34:06 <bitemyapp> mjrosenb: he talked about splitting and I was guessing that was the parenthesization he intended.
12:34:06 <mjrosenb> bitemyapp: I did not know that!
12:34:14 <bitemyapp> mjrosenb: welp.
12:34:25 <mjrosenb> bitemyapp: lots of knowledge being shared!
12:34:43 <bitemyapp> mjrosenb: I'm writing a book. I'm learning a lot as I go, but if I didn't know how (->) associates I'd be in some trouble.
12:35:07 <dfeuer> Huh.
12:35:32 <dfeuer> I don't want to have to learn git :(
12:35:35 <dfeuer> But I do.
12:35:38 <dfeuer> Yech.
12:35:45 <mjrosenb> dfeuer: then don't!
12:35:48 <bitemyapp> dfeuer: the last definition Hickey gave of transducers was: "a transducer is just a pre-fused Kleisli arrows in the list monad"
12:35:53 <S11001001> dfeuer: Yech is right.
12:36:05 <dfeuer> bitemyapp, yeeeeeeeeeeaaaaahhhhhh.
12:36:12 <bitemyapp> edwardk: ^^ does that definition make sense to you?
12:36:26 <mauke> I like git
12:36:27 <bitemyapp> tel added that there was ambient mutable state too.
12:36:28 <xplat> edwardk: what are some other transducers besides foldl and (flip.foldr.flip) or whatever it was?
12:36:44 <dmj`> architecture question: if I have a lot of records, where many reference each other (causing possible circular imports if each type gets its own module), should I factor out all the common types into a shared types module? Or have one large file for *all* types?
12:36:52 <edwardk> xplat: you can define maps and concatmaps, etc.
12:36:55 <bitemyapp> I'm not entirely sure what the list monad has to do with it, for example.
12:37:02 <bitemyapp> since it seems to be about folding.
12:37:09 <edwardk> xplat: you basically just have to say how you explode 'y' into a bunch of 'b's and fold through it left to right
12:37:24 <edwardk> er y into a bunch of x's and fold through them left to right
12:37:33 <edwardk> (or is it the other way around)
12:37:36 <bitemyapp> I guess that could be monadic.
12:37:41 <bitemyapp> sorta?
12:37:46 <bitemyapp> you're not using join though.
12:37:48 <xplat> x into a bunch of ys
12:37:56 <bitemyapp> you'd be mapping an x -> [y] and then reducing with fold.
12:37:58 <bitemyapp> rather than join.
12:38:08 <bitemyapp> based on edwardk's casual definition.
12:38:11 <edwardk> @let type Transducer a b = forall r. (r -> b -> r) -> r -> a -> r
12:38:13 <lambdabot>  Defined.
12:38:21 <edwardk> :t foldl :: Transducer [a] a
12:38:22 <lambdabot> (r -> a -> r) -> r -> [a] -> r
12:38:28 <xplat> bitemyapp: it's 'exploding an x into a sequence of ys' i think that brings in the list monad
12:38:40 <bitemyapp> xplat: yeah, that's what I meant by "I guess that could be monadic"
12:38:44 <bitemyapp> xplat: but the thing is, it's not really.
12:38:48 <eitan_chatav> i really like the lambda case extension
12:38:49 <bitemyapp> xplat: you just need fmap for that.
12:38:51 <xplat> i wonder if these things have other shapes like traversals and folds do
12:39:09 <bitemyapp> xplat: fmap can do x -> [y], you need monad for concatMap - ie: join
12:39:12 <monochrom> dfeuer: it may depend on the number type. do you want Int? Integer? general Integral?
12:39:19 <monochrom> all of the above?
12:39:35 <bitemyapp> xplat: since we're not using the parts that are specific to the list monad (bind/join), it's not really about the list monadic because the reduction is whatever fold we defined.
12:39:40 <edwardk> :t (\f g r -> g r . f) :: (a -> b) -> Transducer a b
12:39:41 <lambdabot> (a -> b) -> (r -> b -> r) -> r -> a -> r
12:39:56 <bitemyapp> so I'm not totally convinced but I can see why the nested introduction of lists would put somebody into thinking it was about the list monad.
12:40:13 <edwardk> :let tmap :: (a -> b) -> Transducer a b; tmap f g r = g r . f
12:40:20 <edwardk> @let tmap :: (a -> b) -> Transducer a b; tmap f g r = g r . f
12:40:23 <lambdabot>  Defined.
12:40:26 <Ferdirand> hmm
12:40:32 <edwardk> :t foldl.tmap succ
12:40:33 <lambdabot> Enum b1 => (b -> b1 -> b) -> b -> [b1] -> b
12:40:47 <Ferdirand> so what are the other interesting Transducer types, beyond Transducer a [a] ?
12:41:12 <xplat> Ferdirand: well, you can use foldl or foldr for any Foldable
12:41:21 <edwardk> :t (\f g r -> foldl g r . f) :: (a -> [b]) -> Transducer a b
12:41:22 <lambdabot> (a -> [b]) -> (r -> b -> r) -> r -> a -> r
12:41:30 <edwardk> there you get a concatMap, etc.
12:41:43 <edwardk> Ferdirand: work for any Foldable, etc.
12:42:26 <edwardk> anyways its basically just a crippled left-biased Fold
12:42:31 <Ferdirand> okay, but for instance, does (Transducer [a] a) corresponds to something meaningful ?
12:42:37 <edwardk> by biasing left it can't handle infinite cases
12:42:54 <edwardk> Ferdirand: sure its a function from [a] to basically [a] ;)
12:43:01 <xplat> so far this all seems like stuff that would work with a Fold too; is there a difference?
12:43:02 <edwardk> Transducer a b is a -> [b] in disguise
12:43:07 <edwardk> for a finite case
12:43:08 <edwardk> xplat: no
12:43:20 <edwardk> xplat: other than the fact that this version doesn't handle infinite cases
12:43:28 <xplat> it seems like you could get a transducer from any fold by reading it out into Endo
12:44:03 <edwardk> yes
12:44:07 <edwardk> :t foldlOf
12:44:08 <lambdabot> Getting (Dual (Endo r)) s a -> (r -> a -> r) -> r -> s -> r
12:44:15 <edwardk> yay transducer
12:44:24 <edwardk> next =)
12:44:25 <dfeuer> What's with this? libffi/stamp.ffi.static-shared.install exists, but libffi/build/inst/lib/libffi.a does not.
12:44:49 <mauke> http://jlongster.com/Transducers.js--A-JavaScript-Library-for-Transformation-of-Data are these the same transducers?
12:45:06 <monochrom> dfeuer: OK, I use -O2, the experiment code is "f x y = quot x y + rem x y" and "g x y = q + r where (q, r) = quotRem x y". whether Int, Integer, or Integral, f and g are different in GHC core.
12:45:23 <edwardk> xplat: transducers themselves aren't terribly brain bending, they are just a use of the same pattern that lens uses. finding a shape that factors through (->) when something gets quantified and using (.) and id as the way to compose them
12:45:43 <edwardk> its nice that they've been rediscovered, but there isn't a lot of magic there
12:46:22 * dfeuer needs to learn about lenses sometime soon.
12:46:29 <monochrom> f uses separate quot and rem, g uses combined quotRem.
12:46:52 <dfeuer> monochrom, that is sad :(
12:47:05 <monochrom> well, I'm not sure how sad it is.
12:47:24 <monochrom> ok, I see how it's sad.
12:47:56 <dfeuer> monochrom, I would not be surprised if it were better in (virtually?) all cases to define quot = fst . quotRem and rem = snd . quotRem
12:48:01 <lpaste> Yrarr pasted “EitherT - lifting IO (Either a b) ” at http://lpaste.net/111297
12:48:09 <Yrarr> Hey, I've got one question about Monad Transformer stuff: I'd like to use some IO'ed values in lifted Either monad. Is this possible ? http://lpaste.net/111297
12:48:19 <edwardk> mauke: dunno. i appear to have lost the ability to read javascript. its like listening to Charlie Brown's teacher ;) They don't really follow the right form for it to be the curried foldl encoding there in transducers.js so i have no idea
12:48:33 * hackagebot hindent 3.1 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-3.1 (ChrisDone)
12:48:52 <dfeuer> OK, so does anyone know about this FFI build failure thing?
12:48:57 <edwardk> monochrom: which is worse?
12:49:18 <edwardk> Yrarr: do you know about lift?
12:49:21 <edwardk> :t lift
12:49:22 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
12:49:25 <monochrom> if Int or Integer, separate quot and rem must be worse.
12:49:28 <edwardk> :t Control.Monad.Trans.lift
12:49:29 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
12:51:14 <monochrom> for example with Int, we're looking at GHC.Prim's quot#, rem#, and quotRem#. which at the x86 machine code level are idiv then throw away one register, idiv then throw away another register, and idiv.
12:51:21 <ReinH> edwardk: o/
12:51:31 <xplat> edwardk: appears it might be the same encoding only using a stateful accumulator instead of an explicit one
12:52:23 <xplat> hm, or maybe that's just efficiency, it does seem to have (r,x) -> r
12:52:46 <Yrarr> edwardk: And what should I lift ? I've got IO [CString], and a function that takes [CString] -> Either a b. I can lift this function to use IO monad, but then... lifting it to the transform monad gives me type: EitherT a IO (Either a b)
12:55:06 <xplat> so basically (r -o (x -> r)) so it can reuse the accumulator if it wants.  plus it has a not-strictly-necessary map step before reducing.
12:56:00 <xplat> edwardk: actually nevermind, it just looks insane
12:56:20 <dmj`> Yrarr: runEitherT $ do { a <- liftIO getLine; return a }
12:56:48 <mauke> xplat: I think the .push thing is just a bug
12:56:54 <dmj`> Yrarr: er, runEitherT $ liftIO getLine
12:56:57 <RedNifre> Good evening.
13:00:54 <xplat> mauke: i think it's trying to be more like an iteratee library than this sort of transducers.  it makes more sense in that light.
13:01:24 <dfeuer> monochrom, unfortunately, if I define myquot x y = fst (quotRem x y)  and myrem x y = snd (quotRem x y), for some reason CSE does not help anything, and it just takes quotRem twice :-/
13:01:46 <mauke> .oO( what CSE? )
13:01:57 <dfeuer> mauke, CSE = common subexpression elimination.
13:02:31 <mauke> I know
13:02:39 <monochrom> CSE sometimes happens and sometimes not happen. I've seen both occasions.
13:04:18 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/104783/ is an example of happy ending :)
13:04:44 <lpaste> Yrarr pasted “IO in and out with EitherT” at http://lpaste.net/111298
13:04:55 <Yrarr> dmj: it allows me to use getLine as IO operation without toying with Lefts and Rights. The thing is, I need to perform IO and use the performed value in non IO function (which returns the Either stuff). The more practical example of what I'd like to do is here: http://lpaste.net/111298
13:05:26 <dfeuer> But it seems pretty silly to ever have  case expr of (# q1, r1 #) -> case expr of (# q2, r2 #) -> ...   when the result of expr is all strict (and in this case even primitive)!
13:07:49 <mauke> monochrom: is that really CSE?
13:07:59 <xplat> the case stuff is necessary for Core, but it should compile away to nothing at the lower IL levels
13:08:25 <dmj`> Yrarr: exactly, calling liftIO allows you to retrieve a value out of IO and use it in pure code
13:08:49 <RedNifre> There seem to be infinitely many Monad tutorials. Can you recommend a good one? I'm trying to understand IO and liftIO and "<-" and how these relate to the "do" notation.
13:08:56 <xplat> GHC is not exactly aggressive with CSE because there are cases where it can lead to a lazy space leak
13:09:05 <mauke> RedNifre: that has nothing to do with monads
13:09:22 <dmj`> Yrarr: but once you're in I/O there's no way out really
13:09:34 <MP2E> RedNifre: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html  and  http://dev.stephendiehl.com/hask/#monads
13:09:50 <xeno> RedNifre: Beginning Haskell is nice
13:09:58 <Cale> RedNifre: Well, there's mine...
13:10:10 <dmj`> RedNifre: do you feel comfortable with functors?
13:10:11 <Cale> http://www.haskell.org/haskellwiki/Monads_as_computation
13:10:15 <merijn> RedNifre: <- relates to do notation by being part of do notation
13:10:31 <xplat> RedNifre: if you're actually going to read monad tutorials, i recommend quantity rather than quality
13:10:38 <merijn> monochrom: hah, nice :)
13:10:40 <mauke> @undo do { x <- y; z }
13:10:40 <lambdabot> y >>= \ x -> z
13:10:42 <Cale> I actually wrote this tutorial more as a message to monad tutorial authors than to people who wanted to learn about monads, but it should be good regardless :)
13:10:44 <mauke> and the rest follows in the same way
13:11:33 <Cale> (It's not obvious that this is the case, I don't come right out and call people on their bad monad tutorials, I just say the things which I think a lot of people forget to)
13:11:44 <xplat> RedNifre: there are lots of ways to look at monads, and it's better to fill up your mental toolbox with a bunch of them than trying to find 'the' way to understand monads
13:12:09 <dfeuer> xplat, in this case, the result is *not* lazy, so nothing is gained.
13:12:18 <merijn> "a monad is an abstraction consisting of 2 functions and some laws" <- done
13:12:34 <Cale> The main point of understanding that certain libraries define monads is in order to be able to take advantage of functions which can be written to work with any monad
13:12:58 <xplat> dfeuer: yeah, but sometimes you need to help GHC a bit with realizing that.  it's a smart compiler, but unfortunately not omniscient yet ;)
13:13:10 <RedNifre> I'm reading "Beginning Haskell", but I find that it gets lost in details a lot.
13:13:14 <Cale> Control.Monad and other libraries define lots of functions, usually "control structure" like things, that will work independently of a choice of monad
13:13:25 <Cale> For example, sequence :: (Monad m) => [m a] -> m [a]
13:13:55 <Cale> will take a list of computations each of which will produce a result of type a when executed, and glues them together into a computation which will run all of those and collect a list of the results
13:14:02 <mauke> RedNifre: I'd start by understanding IO before going into all the monad stuff
13:14:12 <Cale> What it means to "run" a computation will vary based on the choice of monad
13:14:29 <lpaste> Yrarr pasted “IO in EitherT, again” at http://lpaste.net/111299
13:14:31 <Cale> Oh, yeah, definitely if you just want to do IO, there's not a *whole* lot of point in looking at monads in general yet
13:14:44 <Cale> Except that you might want to take advantage of the fact that IO happens to be a monad a little
13:15:19 <Cale> For instance, this sequence function is able to take a list of IO actions and turn them into an IO action which will run them all and collect the results into a list, which is handy as a kind of "primordial loop"
13:15:26 <mauke> walk before you run :-)
13:15:39 <RedNifre> Well, I don't understand how IO relates to e.g. the actionM in the scotty library. For example, if I implement a GET method in scotty to get a fortune message I have to do this:
13:15:41 <RedNifre> fortune <- liftIO( S.readProcess "/usr/games/fortune" [] "" :: IO String )
13:15:41 <Cale> But you can get by with IO just writing do-notation
13:15:53 <RedNifre> But my understanding of what is going on there is very mury.
13:15:53 <Cale> Yeah, if you start using libraries that define fancy monads
13:15:58 <RedNifre> *murky
13:16:06 <Cale> then you'll probably have to be careful and actually understand things :)
13:16:26 <dmj`> RedNifre: I'd recommend writing the functor / monad instances from scrach for Identity, Maybe, Either, State, then use them in real code.
13:16:38 <mauke> RedNifre: do you understand how to write a program that e.g. reads from stdin, uppercases every letter, and writes the results to stdout?
13:16:39 <Cale> RedNifre: So, the ActionM monad is presumably some kind of data structure which involves IO actions somehow
13:16:58 <dmj`> Yrarr: stringsIO <- liftIO $ mapIO newCString ["ala ma", "rysia znow"]
13:16:59 <bitemyapp> RedNifre: https://github.com/bitemyapp/learnhaskell
13:17:05 <Cale> RedNifre: and there's a canonical way to turn an IO action into an ActionM action
13:17:09 <bitemyapp> RedNifre: my guide eases you into things like applicative and monad better.
13:17:11 <dmj`> Yrarr: instead of let stringsIO = mapIO newCString ["ala ma", "rysia znow"]
13:17:13 <Cale> and that's what liftIO does
13:17:41 <dmj`> Yrarr_: did you see what I posted
13:17:57 <Yrarr_> dmj: the liftIO stuff ?
13:18:14 <Cale> RedNifre: The ActionM monad presumably has a bunch of additional stuff which isn't quite possible to write directly in terms of IO
13:18:15 <dmj`> the fix for your paste
13:18:20 <dmj`> Yrarr: stringsIO <- liftIO $ mapIO newCString ["ala ma", "rysia znow"]
13:18:44 <Cale> (though, that's actually probably questionable, but we have to live with the library design if we're using it)
13:19:14 <Cale> I don't know much about scotty
13:20:08 <Cale> type ActionM = ActionT Text IO
13:20:16 <Yrarr> dmj: oh, okay, got it
13:20:20 <xplat> https://ocharles.org.uk/blog/posts/2013-12-05-24-days-of-hackage-scotty.html
13:20:36 <RedNifre> Is it like this?: The system call has the String locked in that IO container and you are not allowed to pull it out because that would corrupt the purity of Haskell. Because of that, Scotty methods aren't pure in the first place, they are this ominous ActionM things that are somehow compatible to IO. So by using the Scotty specific liftIO on the IO String I move it into an... ActionM String? Which, when the
13:20:37 <RedNifre> ActionM gets executed moves into the "fortune" variable as a plain String?
13:21:26 <xplat> RedNifre: ActionM isn't really ominous, it's just the IO monad plus some scotty-specific state and such
13:21:42 <Yrarr> dmj: okay, thanks :)
13:22:15 <mauke> IO String contains a string like /bin/ls contains filenames
13:23:03 <xplat> RedNifre: the liftIO lets you choose to use an IO action as an ActionM action in much the same way that Just lets you choose to use a String as a Maybe String
13:23:10 <dmj`> RedNifre: are you familiar with transformers?
13:23:12 <dfeuer> whoa... monochrom, I was using 7.8.3. In 7.9, it looks like that's fixed!
13:23:28 <Cale> newtype ActionT e m a = ActionT { runAM :: ExceptT (ActionError e) (ReaderT ActionEnv (StateT ScottyResponse m)) a }
13:23:29 <Cale> ^^ That's a mouthful, but the basic idea is that they've added in some additional facility for exception handling, state, and capturing an environment
13:23:30 <Cale> Basically it amounts to automating a bunch of parameter passing for the most part
13:23:31 <RedNifre> No, I'm not familiar with transformers.
13:23:32 <Cale> My lag meter is really high, is anyone seeing this?
13:23:39 <dmj`> Cale: I was about to paste that :P
13:23:57 <xplat> Cale: i'm seeing you now
13:23:58 <Eduard_Munteanu> Cale, 0.2s here
13:24:02 <Cale> okay, it's gone back down, after 128 seconds of apparent disconnection
13:24:07 <RedNifre> Regarding the "Just String" example, I don't understand how that is related, given that it takes a plain string and puts it in a maybe.
13:24:22 <dmj`> RedNifre: it's difficult to do haskell web dev w/o understanding transformers or monads
13:24:31 <RedNifre> But it helps my understanding that ActionM is just an extended version of IO.
13:24:34 <dfeuer> monochrom, it still doesn't do it with quot and rem, but it does with the weird versions.
13:24:39 <xplat> RedNifre: this is taking a plain IO action and putting it in an (ActionT Text IO) action
13:24:42 <RedNifre> dmj` yes, that's why I'm here :)
13:24:49 <monochrom> haha fun. but I don't want to play with 7.9 yet :)
13:25:00 <Cale> RedNifre: A value of type IO t is not at all like a value of type t, rather, it's like a program which if you were to run it, would result in a value of type t
13:25:35 <Cale> RedNifre: When you write v <- x where x :: IO t in the midst of some do-block, it means "execute the action x, and whatever its result is, call that v"
13:25:39 <monochrom> quot, rem, and quotRem are all methods in the Integral class. a compiler would be reluntant to interchange them.
13:25:52 <Cale> RedNifre: and then the do-block as a whole is itself an IO action
13:26:01 <monochrom> a compiler does not even know that they are related.
13:26:05 <Cale> RedNifre: which when executed will carry out the steps described
13:26:38 <Cale> RedNifre: In the end, you have an IO action called main, which will be the one which is executed when your compiled program runs.
13:26:53 <dmj`> RedNifre: The ActionM type can best be seen as a monad for constructing a response from a request, environment information, while catching exceptions as they occur.
13:26:54 <RedNifre> Cale so v has type t, but it is okay to turn IO t into t, because "do" blocks don't need to be pure?
13:27:13 <Cale> RedNifre: Don't think of it so much in terms of pure vs. not pure
13:27:24 <Cale> RedNifre: It's program vs. result of executing that.
13:27:34 <Cale> But yes
13:27:54 <meesha> Hi guys, can I ask some general question about haskell
13:27:59 <Cale> IO actions may have many effects when executed
13:28:00 <dmj`> meesha: yes
13:28:12 <Cale> meesha: Absolutely, feel free to ask as much as you'd like :)
13:28:42 <RedNifre> ...and the liftIO is needed because there is no implicit type conversion? I mean, from my OOP perspective I understand that ActionM inherits from IO, but I guess I can't coerce IO into ActionM without explicitely using liftIO?
13:28:51 <meesha> does the programming in haskell reduces to defining complex data types and functions that operate on this data and all the typeclasses is a ways to help one to reason and make sure that code does not give errors?
13:28:56 <meesha> i hope i phrased it correctly
13:29:01 <xplat> IO doesn't 'control impurity' like 'putting a tiger in a cage', it 'controls impurity' like writing the instructions to sythesize a tiger from chemical elements on a piece of paper'
13:29:11 <monochrom> the problem is that ActionM does not inherit from IO.
13:29:37 <monochrom> if you want to talk OOP, it's wrappers and delegation, not inheritance
13:30:26 <RedNifre> xplat so, I'm allowed to write tiger <- IO tiger, because that statement itself is contained in a "do" block and the do block is just written instructions to synthesize something, so I'm not actually dealing with a real tiger yet?
13:30:38 <HeladoDeBrownie> meesha, s/typeclasses/types/ would be more correct, but even that's a kind of loose statement
13:30:59 <meesha> I see.
13:31:23 <monochrom> I prefer my IO story: http://www.vex.net/~trebla/haskell/IO.xhtml
13:31:31 <xplat> RedNifre: right.  dealing with actual tigers is not something you do within the code you write, it's something that will be done by specially trained chemists and tiger handlers when the code runs
13:31:40 <meesha> but i I understand correctly, you have to define the datatype before you can create an instances of typeclass (IE monad, applicative and so on)
13:32:13 <HeladoDeBrownie> meesha, what do you mean by "before"?
13:32:33 <meesha> ohh
13:32:49 <xplat> you just write a thorough manual to tell them what they're expected to do with the tigers beforehand
13:32:50 <meesha> you create an instance of typeclass
13:32:51 <Cale> this lag is horrible
13:32:53 <Cale> what was the last message people saw from me?
13:32:55 <Cale> (before I disconnected)
13:33:05 <meesha> but you need to have a data that typeclass operates on
13:33:10 <barrucadu> 21:27:40 < Cale> meesha: Absolutely, feel free to ask as much as you'd like :)
13:33:11 <xplat> 16:27 < Cale> meesha: Absolutely, feel free to ask as much as you'd like :)
13:33:13 <digitalmentat> RedNifre, it might be helpful to remember that all functions in Haskell are pure but there are functions that can return *actions* which *can be* impure when their monad handles it
13:33:15 <meesha> i am sorry i mgiht be throwng terms too losely
13:33:16 <dmj`> meesha: data types need not be complex, but they can be. Typeclasses are one way haskell performs polymorphism, they are also used to model algebraic structure that encapsulates computation, but no, the compiler doesn't enforce the correctness of the laws.
13:33:19 <Cale> okay
13:33:25 <Cale> <Cale> RedNifre: There are two interleaved processes taking place as a Haskell program runs: there's evaluation, which turns expressions into values in order to determine whether patterns match
13:33:27 <RedNifre> It's getting clearer. Though I'm still not sure if I understand the relation of ActionM to IO and why the liftIO is needed. I mean, what would the code mean without the liftIO? if IO String is a computation that produces a String when executed, why wont v <- IO String not put the String in v without the liftIO?
13:33:28 <Cale> <Cale> and there's execution of IO actions, which can have many effects and basically do anything your computer can do
13:33:36 <Cale> <Cale> Evaluation is the part which is "pure" -- apart from in low-level hackery that you'll almost never have to deal with, evaluation is deterministic and the only externally observable effect is that your CPU gets hot and memory is allocated
13:33:37 * hackagebot shake 0.13.4 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.13.4 (NeilMitchell)
13:33:39 <HeladoDeBrownie> meesha, what is your conception of typeclasses?
13:33:40 <Cale> <Cale> Evaluating the same expression multiple times will always produce the same result, even if that expression denotes an IO action
13:33:41 <ion> It’s great how the IRC protocol does not acknowledge messages you send.
13:34:13 <meesha> typeclass : a set of functions that perform a transformation on a data
13:34:19 <meesha> or data structure
13:34:21 <dreams> ion: Its great they even call it a protocol.
13:34:24 <dmj`> RedNifre: ActionM is defined in terms of IO
13:34:37 <Cale> Anyone know whether FreeNode is being DDoSed or something?
13:34:40 <silasm> ion: IRC is designed for simplicity of implementation before all else, if I understand correctly.
13:35:05 <Cale> RedNifre: Well, ActionM is some slightly complicated thing which is built up in terms of IO
13:35:12 <tac_> Cale: you can usually ask at #freenode for that kind of thing
13:35:28 <Cale> RedNifre: and there's a sensible way to turn IO actions into ActionM actions
13:35:54 <digitalmentat> meesha, not quite; more like "group of functions that act on the given type variable for functions that implement the class"
13:36:00 <xplat> RedNifre: if you do 'v <- foo' in a do block, the type of action that uses v must be the same type of action that produced it
13:36:32 <HeladoDeBrownie> meesha, it's also not necessarily all functions. Look at this, for example:
13:36:34 <HeladoDeBrownie> @type minBound
13:36:35 <lambdabot> Bounded a => a
13:36:41 <RedNifre> I don't understand why that is. I mean, if foo is of type IO String and I want v to be of type String, why is ActionM relevant there?
13:36:41 <dfeuer> monochrom, I filed a feature request. We'll see how that goes. https://ghc.haskell.org/trac/ghc/ticket/9617#ticket
13:36:44 <silasm> Cale: ##security was saying it was, or that it was recently.
13:36:49 <xplat> RedNifre: so if you want to use v in an ActionM block, but it is produced by an IO action, you must convert the IO action to an ActionM action first
13:36:56 <Cale> silasm: Okay
13:37:39 <barrucadu> RedNifre: v <- foo isn't "taking a 'v' out of a 'foo'", do notation is just syntactic sugar for sequencing functions
13:37:40 <Cale> RedNifre: Well, do-notation desugars into uses of (>>=), which is a type class method (from the Monad type class)
13:37:58 <Cale> RedNifre: and (>>=) :: (Monad m) => m a -> (a -> m b) -> m b
13:38:06 <Cale> RedNifre: and so the m's have to be the same
13:38:16 <Cale> RedNifre: Each monad will determine for itself what (>>=) does
13:38:32 <Cale> But there's no guaranteed way to combine actions from different monads
13:38:47 <vanila> Cale, freenode was recently compromised they 're still working on sorting it out i think
13:38:49 <RedNifre> Ah, so because I can only chain monads of the same type, I use liftIO to convert the IO action into an ActionM?
13:39:01 <Cale> RedNifre: chain actions of the same monad
13:39:04 <xplat> RedNifre: the reason is basically this: an IO action is an instruction to tiger handlers, an ActionM action is an instruction to typesetters formatting the manual for the tiger handlers
13:39:05 <Cale> RedNifre: but yeah
13:39:25 <Cale> xplat: hehe
13:39:38 <xplat> RedNifre: liftIO is basically quoting something you want to go in the final manual verbatim
13:39:55 <RedNifre> I suspcet that might make sense, but I have to think a bit more about it :)
13:39:59 <xplat> so the typesetters won't think you're talking to them
13:40:01 <Cale> That's not a bad analogy, but I'm not sure how much it'll help him :)
13:40:29 <digitalmentat> RedNifre, have you read the docs for liftIO? It's worth looking at if you haven't
13:40:49 <digitalmentat> https://hackage.haskell.org/package/transformers-0.2.2.0/docs/Control-Monad-IO-Class.html
13:40:50 <HeladoDeBrownie> meesha, here is what I think is an okay approximation of typeclasses: A typeclass includes a set of bindings, and instances of that typeclass can give different definitions of them for different types.
13:41:03 <Cale> RedNifre: So, liftIO itself comes from a type class for monads M that have some way to turn IO actions into M actions.
13:41:06 <digitalmentat> notice how liftIO implements the Monad type class
13:41:20 <Cale> :t liftIO
13:41:21 <lambdabot> MonadIO m => IO a -> m a
13:41:25 <dmj`> RedNifre: If you want to learn haskell quickly go through the entire typeclassopedia, then come back to Scotty
13:41:35 <digitalmentat> erp, the MonadIO type class
13:41:43 <dmj`> @typ liftIO
13:41:44 <lambdabot> MonadIO m => IO a -> m a
13:41:44 <RedNifre> Let's see if I get the tiger analogy. The IO action when seen as instructions for tiger handlers could be in a format like a training video, because tiger handlers can't read. So the liftIO watches the videos and translates them into english text files, which can then be used by the ACtionM which wants to produce written manuals?
13:41:53 <HeladoDeBrownie> meesha, I would suggest looking through Learn You A Haskell for their treatment of typeclasses. It's not perfect, but it should give you a decent start.
13:41:59 <HeladoDeBrownie> @where lyah
13:41:59 <lambdabot> http://www.learnyouahaskell.com/
13:42:04 <HeladoDeBrownie> Reading the rest of it couldn't hurt either.
13:42:12 <Cale> RedNifre: mmm... not quite like that
13:42:14 <meesha> Thank You. I will grab that book
13:43:24 <meesha> < HeladoDeBrownie> so bindings is fmap in applicative or (>>=) in monad typeclass
13:43:24 <RedNifre> No? I thought that "The process of writing a tiger manual may only include steps that result in a written manual. So any step that might involve watching a video has to be transformed into written instructions that are equivalent to that video"?
13:43:28 <Cale> RedNifre: It's more like, if we have x :: IO t, then x is something like "Feed the tigers some chicken", and then liftIO x would be something like: 'Include the instruction "Feed the tigers some chicken" next in the manual'
13:43:42 <HeladoDeBrownie> meesha, fmap is from Functor, but yes.
13:43:58 <meesha> yeah, i meant functor,
13:44:01 <meesha> lol
13:44:46 <meesha> HeladoDeBrownie and different defintiions for bindings depend on the dataype than one us using. ( I hope I use precise definition)
13:44:49 <Cale> RedNifre: Because in this analogy, an ActionM action corresponds to instructions for the people typesetting the manual, and an IO action corresponds to instructions for the tiger keepers
13:45:33 <HeladoDeBrownie> meesha, right. I'm being purposefully not as precise as possible with you right now, but mainly so you don't have to think about all the various cases just yet.
13:45:41 <RedNifre> I'm not sure, either I don't understand the analogy, or it doesn't fit the scotty setting.
13:45:43 <exio4> @pl \x -> [1..x]
13:45:44 <lambdabot> enumFromTo 1
13:46:03 <Cale> RedNifre: It does fit, but I'm not sure it's easy to understand if you don't already know how all this works properly
13:46:05 <Cale> :)
13:46:11 <dmj`> Cale: feed the tigers chicken :)
13:46:43 <RedNifre> I mean, I need a String inside that scotty ActionM and I get an IO String from the system call... hmmmmm...
13:46:47 <meesha> HeladoDeBrownie thanks!. Ohh and dataypes can be functions as well
13:47:25 <Cale> RedNifre: So, an IO String is an action which if you were to run it, would do some stuff, and then give you a String at the end (supposing it finishes)
13:47:41 <RedNifre> yes
13:47:45 <Cale> RedNifre: Inside of an ActionM action, you can't just use IO actions directly, you need ActionM actions
13:47:59 <RedNifre> wait
13:48:00 <Cale> RedNifre: But thankfully, scotty provides a way to turn IO actions into ActionM actions
13:48:03 <HeladoDeBrownie> meesha, well, sort of. They can be type-level functions, to look at it one way.
13:48:17 <HeladoDeBrownie> meesha, for example, Maybe is one such type.
13:48:20 <HeladoDeBrownie> @kind Maybe
13:48:21 <lambdabot> * -> *
13:48:29 <HeladoDeBrownie> It takes a concrete type and results in a concrete type.
13:48:38 <meesha> HeladoDeBrownie yeah, but maybe a is also a function
13:48:38 * hackagebot apiary 0.17.1 - Simple and type safe web framework that can be automatically generate API documentation.  http://hackage.haskell.org/package/apiary-0.17.1 (HirotomoMoriwaki)
13:48:39 <xplat> well, let's expand it out more.  'v <- x' is 'feed the tigers chicken and call the remaining chicken bones v'
13:48:40 <Cale> RedNifre: So, you can use liftIO to convert the IO String to ActionM String, and then execute that inside of your ActionM action in order to get its String result
13:48:44 <meesha> HeladoDeBrownie no nono
13:48:54 <meesha> HeladoDeBrownie maybe is type constructor
13:48:57 <RedNifre> To me, this still sounds like my analogy of "IO actions are instruction videos, and ActionM is a written manual, so you need to convert videos into written instructions", but you said this was not accurate. Why not?
13:49:05 <HeladoDeBrownie> meesha, yes, that's correct. What did you mean by "function"?
13:49:07 <Cale> i.e. str <- liftIO x
13:49:11 <Cale> where x :: IO String
13:49:19 <Cale> and liftIO x :: ActionM String, then
13:49:24 <Cale> and so str :: String
13:49:27 <HeladoDeBrownie> Maybe is a type constructor; it's also a "type-level function".
13:49:36 <meesha> HeladoDeBrownie function -> transformation of object of one type into another
13:49:52 <Cale> and the whole do-block in which this occurs has type ActionM t for some as-yet-undetermined type t
13:49:56 <xplat> RedNifre: 'v <- liftIO x' is 'write 'feed the tigers chicken and call the remaining chicken bones 'bob'; call the word 'bob' v'
13:49:57 <HeladoDeBrownie> meesha, ah, you mean how Just :: forall a. a -> Maybe a -- ?
13:50:00 <meesha> I think mathematicians use term morphism for that
13:50:00 <Cale> (which will be the result type of the last action in the block)
13:50:22 <Cale> xplat: I'm sorry, but I think that's just confusing :/
13:50:23 <HeladoDeBrownie> Just is a function. It's also a data constructor.
13:50:29 <meesha> sorta, yes
13:50:30 <RedNifre> xplat ah, that's new.
13:50:36 <Cale> (It's actually getting a little confusing to me too)
13:50:40 <xplat> Cale: well, it is, but at least the confusing point is explicit
13:50:47 <meesha> I think I use terms very loosly and it adds confusion to some of my questions
13:50:57 <Cale> (and I know how monad transformers actually work :)
13:51:06 <digitalmentat> lol
13:51:10 <HeladoDeBrownie> meesha, possibly. I'm not sure what information you're looking for, sorry. Perhaps you could clarify?
13:51:18 <meesha> just clarifying
13:51:24 <Cale> RedNifre: anyway, does my explanation of what's going on with the types help?
13:51:27 <meesha> I somtimes talk to myself
13:51:44 <meesha> when trying to learn something, and ntocied that it helps a lot
13:52:06 <meesha> asking the same questions to somebody esle to see gaps in my thinking
13:52:10 <xplat> Cale: i guess i'd say that was as much an attempt to explain why i think the previous attempts at explanation went wrong as it was an attempt to explain the actual concept :-/
13:52:19 <RedNifre> What I don't understand is this: In your example, the result of the IO action is "Chicken bones", which, in your example, is something we don't want. However, in the concrete example of Scotty and the system calls (nice band name btw!), the IO action produces a String, which is exactly what we want, right? So why liftIO there?
13:52:20 <HeladoDeBrownie> meesha, well, good if it helps then.
13:52:21 <meesha> HeladoDeBrownie anywya, thanks for your time,
13:52:25 <HeladoDeBrownie> No problem.
13:52:40 <Cale> RedNifre: Well, we apparently want the chicken bones.
13:52:43 <meesha> HeladoDeBrownie it does. Ok one more question
13:52:46 <Cale> RedNifre: For some reason
13:52:48 <Cale> lol
13:53:07 <xplat> mainly because i couldn't figure out how to get a string from feeding tigers chicken
13:53:11 <meesha> HeladoDeBrownie suppose we want to define a data temperature  which can be kelvin, celsius or ranking
13:53:16 <digitalmentat> meesha, a morphism is a structure preserving mapping
13:53:56 <meesha> digitalmentat so when there is only one arrow betwee elements of both sets
13:54:01 <meesha> digitalmentat>
13:54:02 <meesha> ?
13:54:13 <RedNifre> Maybe my understanding of "<-" is wrong. What exactly does <- do?
13:54:13 <Cale> RedNifre: The only things you really have to know is that there are two types of actions, IO actions and ActionM actions, Scotty wants ActionM actions (in some places), and there's a way to turn any IO action into an ActionM action, which is liftIO :: IO t -> ActionM t
13:54:45 <Cale> RedNifre: "v <- x" inside of a do-block means "execute the action x, and call its result v"
13:54:50 <Cale> If x :: IO t, then v :: t
13:54:56 <digitalmentat> meesha, well, I wouldn't say "sets", also "arrow" can mean many things here
13:54:56 <Cale> If x :: ActionM t, then v :: t
13:55:12 <digitalmentat> the Maybe type is a good example
13:55:14 <Cale> But in either case, the do-block as a whole will be an action of the corresponding monad
13:55:17 <RedNifre> I guess that the action type allowed in <- is the one associated with the whole do block and nothing else?
13:55:21 <HeladoDeBrownie> Cale, would it be confusing if I brought up the translation?
13:55:24 <Cale> Yes.
13:55:25 <digitalmentat> because it's an instance of Functor
13:55:26 <xplat> RedNifre: yes
13:55:33 <dmj`> if the tigers don't get the chickens the monads won't happen on the things
13:55:35 <meesha> digitalmentat> haha yeah, this is what beginning to understanding is loose term usage can lead to a lot of confusion
13:55:39 <Cale> HeladoDeBrownie: uhh, we might do that in a sec :)
13:55:45 <digitalmentat> fmap (+ 2) $ Just 2
13:56:09 <meesha> digitalmentat anyway, can I ask one more question
13:56:29 <digitalmentat> you can ask many,
13:56:32 <RedNifre> Could you explain to my how this is not like "IO is like video, but ActionM is like a written manual, so you are only allowed to do <- WRITTEN, which means that you have to convert any video you may want to use into a written instruction first by using liftIO"?
13:56:34 <HeladoDeBrownie> meesha, feel free to ask, permission is pre-granted
13:56:35 <Cale> RedNifre: So, I could explain all this in terms of an operation called (>>=) which is implemented for both IO and ActionM, and which the do-notation translates into
13:56:36 <meesha> suppose we want to define a data temperatur which can be K,C or F
13:56:56 <Cale> RedNifre: We have  do { x } = x  as a base case
13:57:10 <meesha> Temperature is a type constructor and Int K, Int C, Int F are types
13:57:17 <Cale> RedNifre: and then  do { v <- x ; <stmts> } = x >>= (\v -> do { <stmts> })
13:57:23 <HeladoDeBrownie> meesha, that sounds confused
13:57:28 <RedNifre> what is stmts?
13:57:37 <HeladoDeBrownie> meesha, are you talking about: data Temperature | K Int | C Int | F Int -- ?
13:57:40 <HeladoDeBrownie> errr
13:57:44 <Cale> a sequence of ;-separated statements
13:57:45 <HeladoDeBrownie> data Temperature =
13:57:46 <meesha> yes
13:57:49 <sm> http://best-haskell.herokuapp.com is very nice
13:57:54 <RedNifre> ok
13:58:00 <meesha> I see
13:58:04 <meesha> temperature is not a type constructor
13:58:07 <Cale> Each of which is either an action, something of the form v <- x where x is an action, and v is a variable
13:58:10 <HeladoDeBrownie> meesha, okay, so the relevant terms: Temperature is a type. It is also a type constructor. K, C, and F are all data constructors, and in this case every one of them is also a function.
13:58:12 <meesha> you need to define a typeconstructor
13:58:17 <Cale> something of the form let { <decls> }
13:58:18 <ceron> what is the advantage of implementing a function in a purely functional way vs using imperative constructs, mutation, etc if both functions are functional and have no side effects from the outside?
13:58:28 <Cale> ... and that's basically it
13:58:35 <Cale> So, the remaining cases:
13:58:46 <HeladoDeBrownie> meesha, instead of "data constructor" you can also just say "constructor".
13:58:54 <meesha> HeladoDeBrownie I see
13:58:56 <Cale> do { x ; <stmts> } = x >> do { <stmts> }, where x >> y = x >>= (\k -> y)
13:59:05 <Cale> and lastly
13:59:09 <sm> I have wonder how stable/useful hackage download numbers are
13:59:12 <HeladoDeBrownie> meesha, okay, so what was your question about it?
13:59:25 <Cale> do { let { <decls> } ; <stmts> } = let { <decls> } in do { <stmts> }
13:59:32 <meesha> so you can have data constructors inside data constuctors
13:59:38 <Cale> So these rules can be used recursively to translate do-notation into these operations
13:59:58 <HeladoDeBrownie> meesha, not as such. A data constructor can be parameterized on a value of a given type.
14:00:02 <Cale> @undo do { a <- x; b <- y; let { v = a + b }; return (v,v+1) }
14:00:03 <lambdabot> x >>= \ a -> y >>= \ b -> let { v = a + b} in return (v, v + 1)
14:00:07 <HeladoDeBrownie> meesha, when you write K Int above, you say that K :: Int -> Temperature
14:00:18 <meesha> Ohh
14:00:20 <Cale> RedNifre: ^^ an example
14:00:26 <monochrom> ceron, mutation has the advantage of reusing memory, immutation has the advantage of not needing to figure out that the author is reusing memory.
14:00:32 <Cale> Here:
14:00:38 <meesha> well, I am getting a feeling that i need to get more familiar
14:00:43 <Cale> (>>=) :: (Monad m) => m a -> (a -> m b) -> m b
14:00:43 <meesha> with data constuctors
14:00:49 <Cale> It takes an m-action
14:00:51 <monochrom> mutation is faster to execute. immutable is faster to understand.
14:00:54 <meesha> HeladoDeBrownie Thank You!
14:00:57 * RedNifre is pondering.
14:00:58 <Cale> and a function from results of that action to further actions
14:00:59 <HeladoDeBrownie> meesha, LYAH will probably help. Give that a readthrough and ask here if you run into problems or have any other questions.
14:01:05 <Cale> and it combines them together
14:01:21 <silasm> ceron: if you want the latter with Haskell, there's a monad for that ;) http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Monad-ST.html
14:01:24 <digitalmentat> LYAH, Typeclassopedia after that
14:01:54 <Cale> into an action which performs the action on the left, then applies the function to its result, and runs the resulting action, returning its result as the overall result
14:02:01 <Cale> So, it's equivalent to:
14:02:15 <Cale> x >>= f  =  do { v <- x; w <- f v; return w }
14:02:21 <Cale> Or more directly:
14:02:28 <Cale> x >>= f  =  do { v <- x; f v }
14:02:44 <silasm> though depending on your data it's often better to avoid ST and let GHC more aggressively optimize more idiomatic code.
14:02:51 <Cale> It's really this (>>=) operation which each monad implements
14:02:58 <ceron> silasm hmm.. I thought haskell is purely functional and doesnt support mutation?
14:03:06 <Cale> along with return
14:03:13 <Cale> return :: (Monad m) => a -> m a
14:03:17 <monochrom> Haskell restrictions mutation. you can still have it.
14:03:32 <Cale> is a way to turn a value into an action which does nothing except to produce that value as its result
14:03:36 <silasm> ceron: it doesn't, but it does support generating actions that mutate things, which it can then execute.
14:03:39 * hackagebot persistent 2.0.4 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-2.0.4 (GregWeber)
14:03:41 * hackagebot chart-histogram 0.4.1 - Easily render histograms with Chart  http://hackage.haskell.org/package/chart-histogram-0.4.1 (BenGamari)
14:03:43 * hackagebot persistent-mongoDB 2.0.4 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-2.0.4 (GregWeber)
14:03:45 <Cale> What it means to "do nothing" will depend on the monad in question
14:03:45 * hackagebot persistent-mysql 2.0.4 - Backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-2.0.4 (GregWeber)
14:03:47 * hackagebot persistent-postgresql 2.0.4 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-2.0.4 (GregWeber)
14:03:55 <Cale> Similarly, what it means to "run" an action
14:04:00 <monochrom> this is why for example readSTRef is "STRef s a -> ST s a" rather than "STRef s a -> a"
14:04:55 <silasm> ceron: ST is particularly interesting, because it's basically "I want to mutate in here, but I still want guarantees that my mutations won't affect anything outside of this scope"
14:05:10 <Cale> RedNifre: I know that's probably a lot to take in at once :)
14:05:19 <RedNifre> Okay, so if x is IO String and f is length, then it would execute x to get the String and put it in v, then it would execute length v and put the length in w, and return w would then put the length back into an IO, resulting in an IO Integer. Well, it would not "do" this, it is just written instructions for something that will produce an IO Integer?
14:05:23 <ceron> I see
14:05:35 <Cale> Well, length doesn't produce an IO action as its result
14:05:47 <RedNifre> ...which is why I think the return is needed?
14:06:02 <ceron> and that is real mutationI? efficiency wise, it is not any slower than it would be in imperative language?
14:06:06 <Cale> Yeah, so you need something like  x >>= \v -> return (length v)
14:06:06 <phaazon> hm, why some folks here use the “BSD-style” license whereas it’s a BSD3 license?
14:06:17 <Cale> Or, you could be fancier
14:06:29 <monochrom> ST is slower unless your algorithm mutates a large array
14:06:36 <Cale> x >>= \v -> do print v; return (length v)
14:06:43 <monochrom> it is real mutation.
14:06:45 <Cale> We could print out that length as we went
14:06:51 <ceron> what makes it slower
14:06:57 <monochrom> more indirections
14:07:13 <Jolianne23>  Here some videos. I hope you like them! http://tinyurl.com/ozfvxy3
14:07:14 <ceron> dereferencing more pointers?
14:07:19 <Cale> And yes, this whole thing is just itself an IO action waiting to happen
14:07:30 <Cale> *Evaluating* it does nothing much which is visible
14:07:40 <silasm> ceron: well a lot of things go into that. As monochrom said ST is often actually /slower/ because Haskell doesn't optimize it as well as it does other code, but for situations where haskell would normally have to copy a ton of memory (such as when computing a new array), you can mutate things in place instead, which can speed things up.
14:07:40 <Cale> But *executing* it will cause the effects to occur
14:07:45 <Cale> and the results to be computed
14:08:06 <monochrom> "f x = f (x-1)" is faster than "f = do { x <- readSTRef rx; writeSTRef rx (x-1); f }"
14:08:09 <RedNifre> I don't understand you "length doesn't produce an IO action" objection. Why doesn't my example fit your code: x >>= f  =  do { v <- x; w <- f v; return w }
14:08:10 <ceron> when you say it is slower do you mean slower than C? or C#? or python? :)
14:08:19 <silasm> most Haskell data structures are more recursive than arrays are and you end up only changing one branch rather than the whole structure, so you don't have that problem.
14:08:29 <silasm> s/changing/copying
14:08:30 <Cale> Evaluating it just figures out which action it is, which since IO is an abstract type, you can't really tell that anything has happened.
14:08:39 * hackagebot persistent-sqlite 2.0.4 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-2.0.4 (GregWeber)
14:08:41 * hackagebot persistent-template 2.0.4 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-2.0.4 (GregWeber)
14:08:53 <Cale> RedNifre: Well, length :: [a] -> Int
14:09:09 <Cale> RedNifre: the second parameter to (>>=) has type a -> IO b
14:09:17 <RedNifre> ...but there's a return at the end of your code, so shouldn't that take care of that?
14:09:19 <Cale> Or, let's use different variables
14:09:25 <Cale> yeah, with return, it's fine
14:09:41 <Cale> You do need the return, you can't write  getLine >>= length, for instance
14:09:52 <Cale> But you can write getLine >>= putStrLn
14:09:58 <Cale> (try that at the ghci prompt)
14:10:25 <silasm> ceron: when I say ST is often slower, I mean it's slower than idiomatic Haskell code doing the same operations. That's because one of the benefits of pure functional programming is that it allows the compiler to make a bunch of optimizations based on the fact that values aren't overwritten and that a function call can be replaced by its result, etc...
14:10:30 <Cale> That'll be the action which first gets a line of text from the user, and then prints that line of text back out.
14:10:42 <Cale> getLine :: IO String
14:10:47 <Cale> putStrLn :: String -> IO ()
14:10:55 <ceron> silasm that is interesting
14:11:12 <RedNifre> I wonder, could it be less confusing for a beginner to avoid do at first and write everything with >>= and >> ?
14:11:21 <Cale> RedNifre: Some beginners find that
14:11:31 <RedNifre> It feels like the do notation obfuscates what is really going on.
14:11:42 <Cale> RedNifre: Well, it's just another notation
14:11:58 <Cale> Especially in the case of IO, it's an abstract type anyway
14:12:03 <shachaf> Sometimes it's fine for what's really going on to be obfuscated.
14:12:03 <capisce> just learn the syntax rewriting rules
14:12:07 <Cale> So you can't really see how (>>=) is implemented for IO
14:12:22 <shachaf> IO isn't among the first things you should care about when learning Haskell.
14:12:27 <Cale> (In fact, GHC does some evil hackery to implement it)
14:12:53 <Cale> shachaf: I don't necessarily agree with that, but you should be comfortable with basic types and classes already.
14:13:03 <phaazon> Cale: isn’t it some kind of algebraic datatype?
14:13:07 <Cale> You can get some IO in there pretty early if you're keen to do it
14:13:16 <phaazon> like IO = OpenFile … | WriteFile … | PutStrLn … | …
14:13:17 <monochrom> my http://www.vex.net/~trebla/haskell/IO.xhtml introduces >>= first, do later. but I wouldn't say "avoid". you need to learn both. but it's easier to explain >>= first, it's more transparent.
14:13:17 <phaazon> and so on?
14:13:22 <Cale> phaazon: It could be
14:13:27 <Cale> phaazon: But not in GHC
14:13:27 <silasm> ceron: for example imagine you have 'superLongComputation x * superLongComputation x', if I know 'superLongComputation' is a pure function (as Haskell functions are), I can replace both instances after doing only one calculation. In the case of ST, the actual result would be an action which was yet to be executed. I could still replace the call with the action, but the computation wouldn't have happened yet
14:13:30 <silasm> because it happens at execution, not evaluation.
14:13:40 <shachaf> Cale: Sure, but for that purpose it's fine if it's moderately obfuscated.
14:13:52 <monochrom> Hugs does IO = OpenFile … | WriteFile … | PutStrLn … | …
14:14:10 <shachaf> monochrom: It does?
14:14:11 <monochrom> and it has a glorious branch for FFI
14:14:20 <monochrom> yes
14:14:20 <RedNifre> Well, I read "Learn you a Haskell for great good" and some chapters of "Beginning Haskell" and I got frustrated that it was all theory and no action, so I stopped that and went right to implementing a little REST service with scotty. But it became clear that I need to learn more before I can get productive so I thought understanding IO and lifting would be a valuable thing to understand.
14:14:30 <shachaf> Hmm, I remember reading Hugs's implementation of concurrent Haskell at one point.
14:14:43 <shachaf> But maybe I didn't look at the underlying definition of IO.
14:14:46 <monochrom> not to the exact wording. but it is close to the free monad approach
14:15:05 <Cale> RedNifre: cool
14:15:36 <RedNifre> What I find very odd about Haskell is that whenever I ask how to do something in a non-silly way, the answer is always "use GHC specific language extensions". This seems somewhat bad, why is it like that?
14:15:53 <Cale> RedNifre: Well, it really depends on what you're asking about
14:16:02 <Cale> RedNifre: But a lot of extensions are not controversial at all
14:16:28 <phaazon> bitemyapp: are you there? :)
14:16:29 <Cale> RedNifre: also people just like using them in some cases because they're slightly more convenient than another alternative in plain Haskell
14:16:50 <RedNifre> It feels like the Haskell community is divided, like standard Haskell is clumsy and some people were unhappy with that so they did their own thing with GHC.
14:17:06 <Cale> RedNifre: Well, no, it's just practically everyone uses GHC
14:17:26 <monochrom> I seldom have to use extensions
14:17:48 <volume_dial> how to specify in cabal file that there are dll files that need to be copied to output location?
14:17:51 <Cale> RedNifre: Early on, there were more implementations of Haskell, but there really wasn't a big enough community to make all of them serious competitive implementations.
14:17:55 <phaazon> I saw in the reverse deps. tools you use my monad-journal library (I found that very neat! :P), and I felt free to read some lines from your ghc-mod library. You define an interesting instance, MonadIO for JournalT ; I’m going to take that in order to patch upstream in monad-journal ; just for you to know, bitemyapp ;)
14:17:57 <RedNifre> But that weakens the Haskell standard and turns GHC into a reference implementation for a Haskell dialect that has no standard :/
14:18:11 <zwer> standard develops more slowly than ghc, as it should. some extensions could make it to the next revision
14:18:23 <shachaf> RedNifre: Some things make their way into the standard eventually. Other extensions are semi-standardized across multiple compilers.
14:18:31 <Cale> RedNifre: The Haskell Report is supposed to be a description of some fragment of Haskell as it exists
14:18:35 <shachaf> I do wish there was another viable Haskell compiler so that this would matter more.
14:18:46 <Cale> RedNifre: It's not really intended to specify what Haskell is in a normative way
14:19:17 <Cale> RedNifre: Nothing gets into the Report without being implemented first
14:19:28 <Cale> and the Report formalises the LANGUAGE pragma
14:19:33 <Cale> as well as a few extensions
14:20:54 <Cale> RedNifre: As time goes on, everyone just adds the new features as extensions, because it's a good way to modularise everything
14:21:17 <Cale> RedNifre: If extensions are sufficiently popular, they can be made default eventually
14:21:18 <ceron> having one viable implementation has its advantages too.. you only have to get your code to work on one implementation, or one per platform, instead of N implementations per M platforms
14:21:55 <Cale> RedNifre: Also worth noting is that GHC's core language is *very* simple
14:22:01 <Cale> RedNifre: and all the extensions translate into it
14:22:22 <RedNifre> Well, my concern is basically this: The languages I use right now are Java and Ruby. Java is a rock solid language where you don't have to worry about your code not working in the next version, but it is clumsy. I use it for large stuff. Ruby on the other hand is an extremely pleasent, quick language where everything is easy, but your code breaks when a new version gets released and I don't trust it for
14:22:23 <Cale> RedNifre: So, this sort of ensures that all the extensions will work together in a sensible way
14:22:24 <RedNifre> large projects so I use it for small stuff. I'm happy with Ruby, but not with Java, so I hope I can use Haskell as a rock solid language for large stuff, but this whole "the pleasent parts are compiler specific" thing irritates me. As in, if I want to have a rock solid language, I need to use standard haskell, which isn't pleasent. Hm...
14:22:40 <dfeuer> shachaf, aren't some people working pretty hard to try to bring some new implementations up to speed?
14:22:52 <Cale> RedNifre: I wouldn't bother avoiding extensions
14:22:58 <Cale> RedNifre: Not all extensions are made alike
14:24:02 <Cale> RedNifre: Some of them are much more experimental than others. Some are things which have been around as long as GHC has. In fact, in some cases, they weren't even extensions until someone pointed it out that they're subtle discrepancies from what the Report actually says
14:24:08 <RedNifre> So, how dangerous are extensions? Do they change a lot, breaking your code, or are they usually stable and make it into the standard eventually?
14:24:11 <Cale> (I'm thinking of FlexibleContexts here)
14:24:12 <dfeuer> I would avoid the DefaultSignatures extension. I think it's upside down.
14:24:19 <Cale> RedNifre: It varies
14:24:32 <Cale> But mostly each extension doesn't change much
14:24:38 <zwer> I wouldn't say haskell without extensions is unpleasant
14:24:40 <Cale> Which extensions are available changes
14:24:41 <Ptival> hello, I have a process started with runInteractiveCommand, and I need to kill it at some point. it seems hClose on the input handle is not sufficient, even though the program terminates on ^D at the terminal. do I need to use terminateProcess or could I be missing something?
14:24:52 <Cale> It's very rare for any extension to get dropped altogether
14:25:06 <Cale> and you'll tend to have a long warning period
14:25:22 <Cale> Like, what was the last one to get dropped? Linear implicit parameters?
14:25:34 <Cale> Or was there another since then?
14:25:49 <dfeuer> Sometimes things change when people realize an extension broke something. Like when UndecidableInstances broke FunctionalDependencies, so it was made a little stricter. At which point some code broke, so now they're adding DysFunctionalDependencies to let that code work....
14:25:56 <Cale> It's been years, I think, since any extension got dropped, and in that case it was because almost nobody used it.
14:25:57 <dfeuer> *breaks
14:26:12 <Cale> hah
14:26:31 <Cale> dfeuer: How much code is really affected by that change?
14:26:45 <Cale> Do you know?
14:27:32 <RedNifre> Okay, so I guess I'll use the extensions and hope for the best.
14:27:46 <Cale> ImpredicativeTypes is another one which tends to be a little shaky
14:27:55 <dfeuer> Cale, I have no idea. But there seemed to be a couple of people complaining about it, at least one of them saying a huge product would have to be all rewritten....
14:28:20 <Cale> It's gotten broken every now and then, but that's probably mostly because nobody uses it and it's apparently annoying to implement.
14:28:23 <dfeuer> A little shaky? Does it currently work at all?
14:28:26 <sivteck> http://dev.stephendiehl.com/hask/#language-extensions
14:28:29 <Cale> I dunno
14:28:38 <RedNifre> Another thing, what to do if I actually DO want mutability and side effects? For example, if I want to write a predictive cache where simply reading from the cache has the side effect of refreshing that page and the pages next to it?
14:28:38 <Cale> My GHC reports it in --supported-languages
14:28:42 <Cale> But I don't know if it works
14:28:58 <Cale> RedNifre: Use IO actions?
14:29:01 <phaazon> hey, what to do to include my CHANGELOG.md into haddock?
14:29:12 <phaazon> I’ve been looking for that for a while now
14:29:20 <Cale> RedNifre: Executing IO actions are allowed to have effects
14:29:20 <phaazon> the changelog is in the root of the lib
14:29:31 <Cale> RedNifre: and there are IORefs which are mutable references
14:29:59 <RedNifre> It seems like if you are not careful, all your code turns into IO code, huh?
14:30:32 <Cale> RedNifre: nope!
14:30:33 <dfeuer> Cale, it's hard to say if it "works", since it's not exactly documented.
14:30:35 <Cale> Just the stuff with effects
14:30:47 <Cale> dfeuer: Well, I could try it
14:31:08 <Cale> RedNifre: Remember, IO actions are allowed to use arbitrary non-IO-related functions
14:31:12 <RedNifre> Guess I just need more experience with all these new concepts. For example, when I first encountered Maybe, nearly everything in my code turned into Maybes, because it is somewhat contageous. Can you relate?
14:31:39 <Cale> RedNifre: So any little thing which you need to compute which doesn't have anything to do with IO, you just write it without IO and use it from the IO action you'.
14:31:42 <Cale> you're writing
14:32:16 <RedNifre> So I guess a good coding guideline would be to have as little IO or Maybe code as possible?
14:32:17 <Cale> RedNifre: The IO will be like a thin candy shell around your program
14:32:39 <Cale> Not necessarily... but it's good to not have stuff be IO if it doesn't, well, do I/O
14:32:53 <bitemyapp> phaazon: I didn't write ghc-mod!
14:32:55 <Cale> Maybe is another thing
14:32:56 <bitemyapp> phaazon: Kazu did!
14:33:12 <phaazon> yeah, I saw you have forked
14:33:14 <Cale> Maybe is just fine, if you can't always compute a result, it's a good way to represent that
14:33:18 <phaazon> sorry for the misunderstanding :)
14:33:26 <Cale> apart from the fact it doesn't really tell you *why* you couldn't compute it
14:33:27 <bitemyapp> phaazon: it's no problem, just want credit where it's due.
14:33:37 <phaazon> :)
14:33:46 <bitemyapp> phaazon: the only things I've written in Haskell for public use are Bloodhound and Blacktip.
14:33:55 <dfeuer> Maybe can be fine. It depends. Too many Maybes can suggest that you're using the wrong types somewhere.
14:33:56 <bitemyapp> both touch on the sort of work I do.
14:33:59 <phaazon> I don’t know either
14:34:09 <bitemyapp> phaazon: most don't.
14:34:13 <bitemyapp> They're not popular.
14:34:15 <dfeuer> But Maybe isn't an issue like IO is.
14:34:21 <phaazon> what are they?
14:34:23 <dfeuer> You can't get stuck in it too badly.
14:35:14 <lericson_> 8ball :: Maybe Bool
14:35:15 <lericson_> ? ;)
14:36:45 <Cale> dfeuer: Okay, it seems mostly broken. You can use it to write functions with impredicative types, but actually using those functions seems impossible
14:37:11 <phaazon> bitemyapp: ahah
14:37:14 <phaazon> I feel stupid
14:37:23 <Cale> dfeuer: For example, I can write  foo :: Maybe (forall a. a -> a) -> Integer -> String -> (Integer, String)
14:37:35 <phaazon> the MonadIO I spotted in ghc-mod already exists upstream
14:37:47 <Cale> but then foo (Just id) 5 "hi" fails to typecheck
14:37:52 <dfeuer> Cale, it's unfortunate, because impredicative types *look* like they make a lot of sense, but there's (apparently) something hard about them underneath.
14:38:14 <dfeuer> Cale, does it help to  give Just id an explicit type signature?
14:38:25 <merijn> dfeuer: Yeah, it's hard to fit them in the underlying haskell System F_omega-whatever framework
14:38:27 <monochrom> ImpredicativeTypes is currently fairly ineffective. you don't get to use all the promised things.
14:38:40 <Cale> nope
14:38:42 * hackagebot pipes-binary 0.4.0.3 - Encode and decode binary streams using the pipes and binary libraries.  http://hackage.haskell.org/package/pipes-binary-0.4.0.3 (RenzoCarbonara)
14:38:52 <merijn> ImpredicativeTYpes is not mostly broken, it's entirely broken
14:38:54 <Cale> foo (Just id :: Maybe (forall a. a -> a)) 5 "hi"
14:39:05 <Cale> -> Couldn't match expected type ‘forall a. a -> a’ with actual type ‘a0 -> a0’
14:39:16 <merijn> Hold on, lemme find Simon's email
14:39:29 <dfeuer> merijn, if it's entirely broken, why not DEPRECATE it?
14:39:40 <merijn> dfeuer: I asked for that months ago
14:39:47 <Cale> merijn: Well, I say mostly broken because it *did* typecheck a module which had a function involving impredicative types in it
14:39:50 <merijn> I dunno what happened to my proposal
14:39:55 <Cale> merijn: It's just I can't use it :)
14:40:09 <Cale> Because I can't construct any values of the impredicative type
14:40:23 <monochrom> it conflicts with GHC's current approach of type checking (which is a well thought one, not a patchy one)
14:41:48 <merijn> http://www.haskell.org/pipermail/glasgow-haskell-users/2014-February/024684.html
14:42:31 <dfeuer> merijn, it looks like Simon Peyton Jones has a vague idea of adding it with explicit type application some day.
14:42:39 <merijn> Cale: The lack of impredicative types like "Maybe (forall a. a -> a)" is one of my major sources of sadness :\
14:42:54 <dfeuer> I guess he doesn't want to officially deprecate it and then undeprecate it?
14:43:21 <dfeuer> That said, it might make sense to remove it from the user's manual until it works.
14:43:23 <merijn> I want like "Chan (forall (a :: MsgType) . Message a)" style things with GADTs :\
14:46:58 <t011> Hi, on the way to a clean install of Hakyll, Pandoc failed to install due to this bug https://github.com/jgm/pandoc/issues/1590
14:47:39 <t011> Is it possible to get into the source and just make the quick fix to get Pandoc compiled?
14:50:26 <merijn> t011: "cabal get" will download and unpack the source of a package
14:50:33 <merijn> t011: Then you can locall patch/install it
14:50:46 <merijn> t011: Of course you could also do a git clone of the pandoc repo and install that
14:51:17 <t011> merijn: I was hoping to just patch the source in place
14:51:32 <dfeuer> merijn, I went more conservative: https://mail.google.com/mail/u/0/#inbox/1488fe4c487dc2fb
14:51:37 <t011> merijn: Does cabal rm the source with a failed build?
14:51:47 <henryhill> hi lots of people!
14:51:50 <henryhill> can someone help me out?
14:51:53 <henryhill> i'm really stuck
14:51:57 <dfeuer> Don't ask to ask.
14:52:00 <henryhill> i need to write a project query for a database
14:52:08 <merijn> t011: Yes
14:52:08 <henryhill> i've already written a select query
14:52:14 <shachaf> dfeuer: Linking to your gmail inbox is not effective.
14:52:22 <RedNifre> While I'm very happy with scotty when implementing a json rest api, I haven't found a good solution for calling another json rest api. Can you recommend something?
14:52:23 <dfeuer> No, shachaf, it is not.
14:52:36 <dfeuer> merijn, I meant https://ghc.haskell.org/trac/ghc/ticket/9618#ticket
14:52:51 <t011> merijn: So I would need to use 'cabal get' to download the source, patch and then compile?
14:52:53 <henryhill> yeah someone?
14:52:55 <ion> shachaf: Depends on whether login credentials are provided as well.
14:53:06 <henryhill> i really need some help :s
14:53:46 <merijn> t011: Yes, that or just the git repo
14:54:23 <t011> merijn: OK. Yeah, it sounds like it's fixed already, just not in the package
14:54:30 <RedNifre> Currently, I do rest calls like this, which looks really horrible. Do you know a better way?:
14:54:40 <RedNifre> getTicker = do
14:54:41 <RedNifre>  let settings = mkManagerSettings (TLSSettingsSimple True False False) Nothing
14:54:43 <RedNifre>  request <- parseUrl url
14:54:45 <RedNifre>  ( (withManagerSettings settings $ httpLbs request) >>= return . decode . responseBody) :: IO (Maybe Ticker)
14:55:20 <mauke> >>= return . is fmap
14:55:28 <t011> merijn: Thanks for the help
14:56:04 <ion> Also, … >>= \x -> … is x <- …; …
14:56:08 <triliyn> > show $ 5 :: Int
14:56:10 <lambdabot>  Couldn't match type ‘[GHC.Types.Char]’ with ‘GHC.Types.Int’
14:56:10 <lambdabot>  Expected type: GHC.Types.Int
14:56:10 <lambdabot>    Actual type: GHC.Base.String
14:56:13 <lpaste> henryhill pasted “querying in haskell” at http://lpaste.net/111303
14:56:24 <henryhill> i dont wanna sound annoying but someone who can help me ? here is my code for the select and my start for the project (Which is probably way wrong): http://lpaste.net/111303
14:56:29 <henryhill> oh lpastety!
14:56:35 <henryhill> oh
14:56:36 <henryhill> lol
14:56:37 <henryhill> im dumb
14:56:49 <triliyn> If you ever have something that looks like "(...) :: TypeDecl", you can remove those outer parentheses
14:57:09 <triliyn> :: has lower precedence than any expression syntax
14:57:20 <dfeuer> henryhill, what is a Field? What is a Table?
14:57:29 <henryhill> oh right
14:57:30 <henryhill> sorry
14:57:39 <dfeuer> Also, henryhill, what are these things *supposed* to do.
14:57:40 <dfeuer> ?
14:57:43 <henryhill> field is a string
14:57:48 <henryhill> and table is a list of a list of strings
14:57:50 <henryhill> um
14:57:54 <henryhill> like sql?
14:57:57 <henryhill> select project?
14:58:02 <henryhill> i can explain if you dont know
14:58:22 <dfeuer> Yeah, that doesn't mean anything to me. Also, what's it doing wrong?
14:58:23 <mauke> PROJECT foo, bar FROM baz WHERE foo > 2
14:58:38 <henryhill> well
14:58:41 <henryhill> im just stuck at the second
14:58:44 <henryhill> like i have a table
14:58:55 <henryhill> and i need to only display the columns asked for
14:59:01 <dfeuer> Also also, henryhill, fromJust is very rarely what you want, and !! is also very rarely what you want.
14:59:20 <dfeuer> Yay! A table!
14:59:23 <henryhill> well the select one
14:59:26 <henryhill> is already working :]
14:59:36 <henryhill> and im thinking of like
14:59:53 <henryhill> a combination of  elemIndex, map and tranpose could make
14:59:54 <henryhill> the 2nd work
15:00:01 <henryhill> but not sure how
15:00:14 <monochrom> where can we read the definition of Field and Table?
15:00:14 <dfeuer> So you have a list of rows, and you want to take the elements at fixed positions from each row, so as to form a new table with the same number of rows, but shorter ones?
15:00:27 <lpaste> henryhill pasted “No title” at http://lpaste.net/111304
15:00:35 <henryhill> defitions of field and table
15:00:52 <henryhill> and yes it is a list of rows but i wanna remove columns with a specific header
15:00:57 <dfeuer> henryhill, just edit your original lpaste!
15:01:29 <henryhill> ok
15:01:31 <henryhill> but ill remove the bit
15:01:34 <henryhill> where im just printing the table
15:01:56 <dfeuer> henryhill, you're going sideways, and that's a challenge for lists. Is there a reason you're using lists?
15:02:10 <lpaste> henryhill pasted “No title” at http://lpaste.net/111305
15:02:32 <henryhill> what do you mean a reason for using lists?
15:02:42 <henryhill> well i think that is not super hard to fix with transpose
15:02:44 <dfeuer> henryhill, if you just keep the lpaste open, you can click the "edit" button and then there won't be a whole new link to go to.
15:03:03 <henryhill> oh i didnt know
15:03:04 <henryhill> sorry
15:03:18 <dfeuer> henryhill, is there a reason you chose a list of lists to represent this ADT you're building?
15:03:32 <henryhill> i didnt do that i got it from someone else
15:04:13 <henryhill> and also
15:04:20 <henryhill> idk about another way to do that in haskell
15:04:24 <henryhill> i dont have a lot of haskell exp
15:04:29 <dfeuer> All right. Let's leave that then. But I don't understand something... why does select take a "column" argument?
15:04:37 <monochrom> a simple way is to transpose twice. between the two transposes, of course, you have to throw away stuff.
15:05:16 <henryhill> for sleect
15:05:18 <henryhill> select*
15:05:22 <dfeuer> Yes, you can do that, and you probably should.
15:05:23 <henryhill> column is like
15:05:26 <henryhill> the gender column
15:05:30 <henryhill> and value is male
15:05:39 <henryhill> so you are left with only people with male as value in the gender column
15:06:27 <henryhill> and what ive figured for project is
15:06:28 <henryhill> like
15:06:34 <henryhill> transpose the table
15:06:43 <dfeuer> I think merijn is right. This implementation is too inherently slow to worry about efficiency, so you should use transpose, filter, and transpose.
15:06:47 <henryhill> so i can check the columns and not rows
15:06:54 <henryhill> filter in project as well?
15:07:02 <dfeuer> I don't know what project does !
15:07:02 <henryhill> yes i dont really care about efficiency
15:07:08 <henryhill> oh
15:07:11 <henryhill> let me show you an example"?
15:07:56 <lpaste> henryhill pasted “project example” at http://lpaste.net/111306
15:08:07 <henryhill> well its not spaced well
15:08:10 <henryhill> but you get the point
15:08:44 * hackagebot abeson 0.1.0.1 - interconversion between aeson and bson.  http://hackage.haskell.org/package/abeson-0.1.0.1 (HirotomoMoriwaki)
15:17:11 <solidus-river> how do you get cabal to install things that are not on hackage?
15:18:02 <solidus-river> er, things that are on github
15:18:16 <dfeuer> henryhill, project looks even easier. You just want to do that trick merijn suggested.
15:18:45 <henryhill> yes i know that , i can transpose but i cant get the projecting itself to work
15:18:49 <henryhill> like
15:18:54 <henryhill> i need to give it a table still
15:21:29 <dfeuer> henryhill, what does that mean?
15:21:43 <henryhill> the output of project function, needs to still be a table
15:21:50 <henryhill> i'm just struggling to get that done
15:21:56 <henryhill> not really sure how to put it
15:21:57 <henryhill> you know?
15:22:27 <henryhill> oh dfeur (should tag you maybe)
15:24:08 <monochrom> solidus-river: get the source tree one way or another. cd into the source tree, "cabal install".
15:25:42 <solidus-river> monochrom: is there a way to point cabal at an "overlay" to haddock you host yourself?
15:26:09 <monochrom> haddock? hackage?
15:26:19 <solidus-river> s/haddock/hackage/g
15:26:33 <dfeuer> henryhill, you need to transpose again to go back.
15:26:36 <monochrom> then see my http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#local-repo
15:26:47 <henryhill> back to what?
15:27:37 <solidus-river> haha! your vex?!?
15:28:01 <monochrom> no, I just mean my article.
15:28:03 <solidus-river> wait vex is something else your a user on vex
15:28:10 <jle`> solidus-river: you can do it if you sandbox
15:28:22 <jle`> cabal sandbox add-source path/to/package
15:28:24 <jle`> i think
15:28:33 <solidus-river> jle`: i'm sandboxing everything by default
15:28:33 <jle`> you probably shouldn't be installing things globally anyway
15:28:36 <jle`> so yeah
15:28:54 <solidus-river> cool, i need to read both, oh vex is a isp
15:29:04 <jle`> cabal sandbox add-source path/to/package1 path/to/package2
15:29:05 <jle`> etc.
15:29:11 <monochrom> it's only my ~trebla, not my vex.net :)
15:29:12 <jle`> and it'll treat those as if they were on hackage
15:29:19 <solidus-river> i've been using this cookie recipee for ages, except this ersion is missing salt http://www.vex.net/~carol/recipes/chocolate.chip.cookies
15:29:21 <jle`> so if you cabal install package1, it'll use that
15:29:56 <monochrom> Carol is the wife of the owner of vex.net
15:30:52 <solidus-river> that recipee is from temple of elemental evil and its the best chocolate chip cookies ever, but it needs like 1 tsp of salt
15:31:13 <solidus-river> jle`: cool i need to look into that and its probably time i learned darcs as well
15:41:55 <cynick> m
15:43:06 <vanila> :t over
15:43:07 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
15:43:13 <vanila> Setting?
15:43:47 * hackagebot Hclip 3.0.0.2 - A small cross-platform library for reading and modifying the system clipboard.  http://hackage.haskell.org/package/Hclip-3.0.0.2 (JensThomas)
15:52:02 <srhb> I never noticed that hoogle doesn't like æøå
15:52:07 <srhb> That's a bit sad. :P
16:00:49 <benzrf> vanila: Setting is a type synonym
16:00:59 <vanila> thanks be
16:01:01 <vanila> benzrf,
16:01:16 <benzrf> vanila: to be precise it's an optic that allows Const as its f [iirc]
16:01:32 <xplat> benzrf: Identity actually
16:01:38 <benzrf> o setting
16:01:42 <benzrf> i confused with Getting -_-
16:01:52 <benzrf> wait hold on
16:02:05 <benzrf> it's not even an Optic, the 2nd half is restricted to (->) ??
16:03:23 <vanila> so I think I understand over now
16:03:25 <vanila> but what bout failover?
16:04:13 <benzrf> :t failover
16:04:14 <lambdabot> (Profunctor p, Alternative m) => Over p ((,) Any) s t a b -> p a b -> s -> m t
16:04:21 <benzrf> o_o
16:06:23 <vanila> type Over p f s t a b = p a (f b) -> s -> f t
16:06:28 <vanila> -- | This is a convenient alias for use when you need to consume either indexed or non-indexed lens-likes based on context.
16:13:17 <benzrf> oh i See
16:13:27 <benzrf> it's like optic but with (->) for the 2nd p
16:25:15 <hughfdjackson> http://lpaste.net/111310 <- is this an idiomatic way to unpack a map into a datatype proper?
16:25:26 <hughfdjackson> or am i missing something more concise ?
16:28:33 <HeladoDeBrownie> hughfdjackson, I haven't seen enough of that done to be able to judge idiomaticity, but that would look fine especially with a type signature for mapToPerson.
16:28:56 <alrunner4> hughfdjackson: applicative style is often a good choice, i find
16:29:21 <HeladoDeBrownie> That's a good point, you don't need Monad there at all
16:29:43 <HeladoDeBrownie> Since you have something of the form do { a' <- a ; b' <- b ; return (f a b) } where b does not rely on a
16:30:11 <HeladoDeBrownie> That said, since you're specialized to Maybe anyway, I wouldn't consider that a huge deal
16:30:51 <HeladoDeBrownie> s/b does not rely on a/b does not rely on a'/
16:31:07 <hughfdjackson> :) ah - fantastic
16:31:17 <hughfdjackson> will look into what i've missed about applicative functors that might help here
16:31:26 <hughfdjackson> (i assume thats what's meant by 'applicative style'?)
16:31:27 <dmj`> @typ Person
16:31:28 <lambdabot> Not in scope: data constructor ‘Person’
16:31:31 <HeladoDeBrownie> hughfdjackson, yeah
16:31:42 <HeladoDeBrownie> hughfdjackson, in this case it's an application of liftA2
16:31:46 <luite> hughfdjackson: Person <$> M.lookup "name" m <*> M.lookup "hobby" m
16:31:51 <luite> hughfdjackson: would be the direct translation
16:31:59 <HeladoDeBrownie> liftA2 Person (M.lookup "name" m) (M.lookup "hobby" m)
16:32:11 <HeladoDeBrownie> But yeah, that's just a specialization of what luite said
16:32:42 <hughfdjackson> aaah, fantastic ^^ thanks for that - much appreciated
16:33:26 <hughfdjackson> i can see how (taking advantage of currying in luite's example) that would make sense
16:33:51 * hackagebot cabalg 0.2.9 - alias for cabal install from given git repo  http://hackage.haskell.org/package/cabalg-0.2.9 (DmitryMalikov)
16:33:53 <dmj`> [ Person name hobby | Just age <- M.lookup "name" m, Just hobby <- M.lookup "hobby" m ]
16:34:01 <dmj`> hughfdjackson: ^
16:34:09 <dmj`> you could just use elems tho...
16:34:18 * HeladoDeBrownie feels icky relying on fail
16:34:37 <dmj`> HeladoDeBrownie: it's not calling fail
16:34:42 <HeladoDeBrownie> It's not?
16:34:47 <dmj`> it's sugar
16:34:55 <HeladoDeBrownie> Those aren't mutually exclusive statements
16:35:03 <dmj`> > [ x | Just x <- [Nothing, Just 3]]
16:35:05 <lambdabot>  [3]
16:35:05 <hughfdjackson> different sugar to the monadic version?
16:35:22 <dmj`> > Just 3 <- return Nothing
16:35:23 <lambdabot>  not an expression: ‘Just 3 <- return Nothing’
16:35:31 <HeladoDeBrownie> I assumed monad comprehensions were analogous to do expressions, and a do expression that that looks like indeed uses fail
16:35:53 <HeladoDeBrownie> But it's not actually a problem if you know that *specific* fail is fine
16:35:55 <HeladoDeBrownie> which it is with Maybe
16:36:02 <dmj`> you're mistaken
16:36:15 <dmj`> Just 3 <- return Nothing, causes pattern match failure
16:36:18 <dmj`> try it in ghci
16:36:38 <HeladoDeBrownie> dmj`, no, not return Nothing, simply Nothing.
16:37:03 <dmj`> HeadoDeBrownie: depends on the monad, in ghci, you're in the IO monad, but its the same thing
16:37:05 <HeladoDeBrownie> dmj`, you're confusing the Maybe instance with the IO instance anyway if you're trying it in ghci.
16:37:22 <HeladoDeBrownie> One moment, I'll find the place in the report that backs up my claim.
16:37:27 <dmj`> bring it
16:37:33 <HeladoDeBrownie> http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
16:37:36 <luite> desugaring do notation calls fail yeah
16:37:38 <HeladoDeBrownie> See the translation.
16:37:58 <luite> for pattern mach failure
16:39:09 <HeladoDeBrownie> dmj`, so as far as I can tell, what I've said is correct. I will accept arguments that monad comprehensions aren't directly analogous to do expressions, but I'm not particularly confident in the comment I made about those anyway.
16:39:56 <glguy> It doesn't actually "call fail" unless you're using the MonadComprehensions extension, the translation just maps pattern failure to []
16:40:18 * dmj` WINS!
16:40:21 <glguy> even if that's how fail is also implemented
16:41:10 <glguy> You can't declare victory because I agreed with you, I'm not the oracle :-p
16:41:28 <HeladoDeBrownie> dmj`, I'm not keeping score, but by my count you were right on one count and wrong on another. Either way, we hopefully both learned something. :)
16:42:40 * dmj` takes victory lap
16:43:09 <HeladoDeBrownie> s/victory/stalemate/, if you're going to play it that way. :P
16:44:11 <dmj`> I said it doesn't call fail, the oracle's prophecy (what glguy says) was true, true on both counts
16:44:37 <JtRip> body
16:44:46 <glguy> Just write the score down on a piece of paper next to your computer, the channel doesn't have to be a competition :^p
16:45:37 <dmj`> HeladoDeBrownie: were both winners, lets go grab some capri sun and celebrate
16:46:46 <HeladoDeBrownie> I don't much like capri sun, sorry. But have at it if you will
16:48:27 <hughfdjackson> ;) score be what it may, its been really interesting - cheers
16:48:59 <JtRip> no
16:59:04 <srhb> Is there a nice way like chainl and friends to get rid of recursion in productions like Foo ::= Foo Op Bar ?
17:01:01 <thomaseding> For tracking keypresses in a GUI multithreaded IO program, is it better to store the key in an IORef or an MVar (or other)?
17:01:23 <srhb> Sounds like a channel of some kind might be nice
17:01:35 <thomaseding> Or rather which key is pressed at a given time
17:01:58 <Peaker> thomaseding: I prefer IORefs when I never need to block
17:02:10 <Peaker> thomaseding: I find atomicModifyIORef' to be an excellent API :)
17:02:32 <JtRip> it is
17:03:27 <thomaseding> I'll try it out
17:10:02 <JoeyA> The Haskell tls package changed quite a bit from 1.1 to 1.2.  In particular, tls-extra is deprecated (merged into tls, right?).  One pain point I remember about the tls package is that to use it correctly, you had to explicitly write out the accepted ciphers and such.  Is this no longer the case with 1.2?
17:13:14 <mhall> question: I defined an instance of Show without defining a `show` function, ghc doesn't give a warning?
17:13:33 <JoeyA> Did you compile with -Wall ?
17:15:10 <mhall> JoeyA: nope. thanks!
17:15:59 <mhall> JoeyA: is there a way to specify -Wall when loading with `:l` in ghci?
17:16:16 <JoeyA> You can launch ghci like this: ghci -Wall
17:16:50 <Axman6> you can also use :set -Wall inside ghci
17:16:59 <mhall> ok thanks
17:27:38 <yyttr3> Is there a way to convert a .svg to a .jpg in the Diagrams library?
17:40:51 <fryguybob> yyttr3: Almost, there is an svg parser in the works and we already have native rasterizing through rasterific or you can go through Cairo.
17:40:56 <fryguybob> https://github.com/diagrams/svg-diagrams
17:41:47 <yyttr3> I found qlmanage
17:41:57 <yyttr3> It works fairly nice.
17:43:37 <athan> I keep finding myself having difficulty choosing between implementing an idea as a value in a sum type, or as a type itself. Has there been much research in this notion of promotion, and possibly automating it? I know yoko does some stuff with it, but I would really like to dive into the philosophy of it all.
17:44:36 <heatsink> I think the usual resolution is to add union types to the language
17:45:05 <CrazyM4n> How do I go along reading from a file in GHCI?
17:45:26 <CrazyM4n> Actually, I think I´ll do it in a weird, workaroundish way
17:45:54 <heatsink> if x : T, then x : Union T a and x : Union a T
17:46:45 <athan> For instance - what are the implications associated with implementing an idea as a singleton type vs. as a value in a sum? I don't know if I can do it all on my own ":x
17:47:19 <heatsink> What do you mean, singleton type?  A type isomorphic to () ?
17:47:48 <CrazyM4n> Is multiline text supported?
17:48:21 <heatsink> In GHCI, you can use {: and :} brackets to write multiline expressions
17:48:41 <CrazyM4n> In a file though
17:48:55 <CrazyM4n> It gives me an error, but I´m just using normal quotes
17:49:06 <heatsink> Oh, you mean strings
17:49:09 <CrazyM4n> Is there something special to do to write multiline strings?
17:49:11 <CrazyM4n> Yea
17:49:25 <heatsink> "cd ..\
17:49:29 <heatsink> \pwd"
18:03:08 <hughfdjackson> evening Sorella ^^
18:09:45 <athan> heatsink: Sorry, I mean a type like `data Foo = Foo`, or `data One = 1`
18:10:55 <heatsink> athan: so there's exactly one value of the type?
18:11:22 <athan> heatsink: Yeah exactly, I think the singletons library does this.
18:11:45 <heatsink> right, that's a singleton type
18:11:52 <vanila> https://www.youtube.com/watch?v=6mTbuzafcII
18:11:56 <athan> heatsink: I think it's used with DataKinds a lot
18:11:59 <vanila> Guys
18:12:02 <athan> oh okay
18:12:03 <vanila> You have t o see this
18:12:29 <athan> vanila: o.O
18:14:33 <heatsink> This sounds like fold.
18:14:37 <dfeuer> Has quchen been around lately? I noticed the AMP timeline doesn't reflect recent developments.
18:14:38 <heatsink> vanila
18:15:23 <heatsink> athan: Singletons are used when you want a one-to-one connection between types and values
18:15:55 <heatsink> athan: So that, by operating on values, you can perform a type-level operation
18:16:17 <hughfdjackson> are there any commmonly accepted guidelines about when to export Lenses vs record functions?
18:16:32 <hughfdjackson> (should that be 'record accessor functions'?)
18:17:40 <vanila> heatsink, absolutely m!
18:18:15 <dfeuer> hughfdjackson: you could always follow the example of GHC.Base and export *everything*, and several modules too.
18:18:58 <hughfdjackson> dfeuer: will take a look :)
18:19:35 <dfeuer> hughfdjackson: that was not a serious suggestion, but it is true.
18:19:45 <athan> heatsink: Hmm. I think I need to take a new look at constructing data types, but with considerations to having singletons vs. sums etc. For instance, I'm making an html combinator library, and can't decide between making different attributes different types or having them all be of one Attribute type. I think I need to reconsider "computing in advance", and where make clear separations with types. Thanks :)
18:20:10 <hughfdjackson> dfeuer: :| staying up late robs me of my ability to detect people not being literal
18:20:21 <Sorella> hughfdjackson: oh, hello :) Been a while since I last saw you hangin' round IRC
18:20:52 <hughfdjackson> Sorella: got bored of answering javascript questions ;D
18:21:21 <hughfdjackson> but now i've finally got myself some time to play with haskell, and everyone far and wide knows #haskell's reputation ;)
18:21:26 <athan> vanila: lol
18:21:38 <heatsink> athan: In Haskell at least, the general principle is, if you will ever write code that only operates on a specific attribute, that attribute should have its own type
18:22:00 <heatsink> For instance, if you have functions that only work on HREF attributes, there should be an HREF data type
18:22:56 <Sorella> hughfdjackson: that sounds great :)
18:23:13 <athan> heatsink: That's how I've followed until now - how would I take that type and print it out into a string? I feel like that'
18:23:22 <dfeuer> There are some strange interactions between module boundaries and the optimizer... Sometimes rules will only fire to optimize something if its pieces are in a *different* module. No, I don't understand this.
18:23:23 <athan> s where this singleton mapping comes into play
18:23:30 <hughfdjackson> Sorella: how've things been going for you? :D anything interesting in the works?
18:25:26 <heatsink> athan: putStr "HREF"
18:25:37 <fread2282> http://lpaste.net/111316
18:25:51 <fread2282> (question enclosed)
18:25:53 <heatsink> athan: Why do you want code that prints a type as a string?
18:26:20 <dfeuer> athan: one major function of type synonyms is to leave the decision open.
18:26:28 <athan> heatsink: It's not that simple, but in the end I'm going to need to both parse and pretty print
18:26:52 <heatsink> fread2282: You can have both class C' Show Int Bool, and class C' Ord Int Bool
18:26:56 <athan> dfeuer: Hmm, okay. Thank you!
18:27:05 <heatsink> fread2282: There can be only one class C Int Bool
18:27:24 <fread2282> http://lpaste.net/111316
18:27:24 <fread2282> heatsink: right, forget something
18:27:42 <fread2282> *forgot
18:27:50 <dfeuer> You can define a type synonym representing something, but make it a String or whatever. Later, you can change your mind and change it. Instantly, you'll get type errors everywhere you need to change something.
18:28:25 <dfeuer> ^^ athan
18:28:55 <athan> dfeuer: Hmm, okay I'll keep that in mind. I really like the idea of using generics libraries to implement interpreters / pretty printers
18:28:55 <dfeuer> That's one of the ways types support refactoring.
18:29:10 <vanila> bro
18:29:11 <athan> dfeuer: Ahh okay
18:29:13 <vanila> he links bird and hutton
18:29:17 <vanila> @ 16:23
18:29:18 <heatsink> I was expecting Rich Hickey to mention Gill's paper on fold/build fusion
18:29:19 <vanila> this is so cool
18:31:10 <dfeuer> heatsink, vanila, what're y'all talking about?
18:31:50 <heatsink> The video that vanila linked
18:31:52 <heatsink> https://www.youtube.com/watch?v=6mTbuzafcII
18:32:44 <Sorella> hughfdjackson: I've been fairly busy with work and some life problems, but am slowly getting back to working on some cool stuff. The most interesting is prolly my compile-to-JS PL.
18:33:06 <hughfdjackson> :) glad things are starting to even out !
18:36:43 <CrazyM4n> so can you guys give me an example of how to use readFile?
18:37:45 <CrazyM4n> would it be like http://lpaste.net/971144152039292928
18:37:53 <heatsink> putStrLn =<< readFile "/etc/passwords"
18:38:05 <CrazyM4n> ah, so it would be like that
18:38:08 <CrazyM4n> thanks
18:38:27 <zwer> @undo putStrLn =<< readFile "/etc/passwords"
18:38:27 <lambdabot> putStrLn =<< readFile "/etc/passwords"
18:38:32 <zwer> err
18:38:59 <CrazyM4n> will.. will lambdabot run it?
18:39:01 <zwer> anyway, that is the same thing your do example is doing
18:39:20 <CrazyM4n> and thanks
18:39:30 <zwer> no. I forgot that undo works backwards
18:39:52 <zwer> @undo do file <- readFile "chain.txt"; doStuff file
18:39:53 <lambdabot> readFile "chain.txt" >>= \ file -> doStuff file
18:40:04 <CrazyM4n> i see
18:40:37 <zwer> which is the same as: readFile "chain.txt" >>= doStuff. or doStuff =<< readFile "chain.txt"
18:40:47 <CrazyM4n> just one last question
18:41:01 <CrazyM4n> how do I get a random seed? without having to predefine it
18:41:12 <CrazyM4n> like, a seed that you would get from mkStdGen
18:41:31 <zwer> @hoogle getStdGen
18:41:33 <lambdabot> System.Random getStdGen :: IO StdGen
18:41:37 <CrazyM4n> thanks man!
18:41:41 <zwer> welcome
18:42:39 <joffee> what is main?
18:44:34 <CrazyM4n> so I have this, but it´s giving me an error http://lpaste.net/4787177166666203136
18:44:52 <heatsink> joffee: a miserable pile of secrets
18:44:55 <CrazyM4n> would I have to put the ¨markov 100 3 getStdGen¨ in a lambda?
18:45:02 <joffee> heatsink: haha
18:45:03 <CrazyM4n> actually, that would work, let me just do that
18:46:07 <CrazyM4n> is there any way that´s a little better looking than http://lpaste.net/777167039356731392 though?
18:46:25 <heatsink> eta-reduce it
18:46:52 <heatsink> I changed it
18:47:02 <zwer> markov accepts IO StdGen?
18:47:26 <CrazyM4n> yes
18:47:41 <CrazyM4n> well, I didn´t explicitly make it have a type signature
18:47:44 <CrazyM4n> wait
18:47:50 <CrazyM4n> no, it uses an StdGen
18:47:53 <CrazyM4n> never mind, haha
18:49:01 * hackagebot kansas-comet 0.3.1 - A JavaScript push mechanism based on the comet idiom  http://hackage.haskell.org/package/kansas-comet-0.3.1 (AndyGill)
18:49:51 <threestrikes> I'm reading Learn You A Haskell, at what point or chapter did things start to click for some of you?
18:50:05 <threestrikes> How long did it take?
18:50:29 <CrazyM4n> Learn You A Haskell didn´t work for me. on second thought, I still don´t really know haskell
18:50:47 <joffee> let me rephrase, is main a function? a void function equivalent?
18:51:03 <CrazyM4n> it is a function
18:51:06 <vanila> joffee, main :: IO a
18:51:09 <vanila> it's not a function
18:51:10 <CrazyM4n> it has the type signature of IO a
18:51:15 <Sorella> joffee: it's just a data structure
18:51:30 <joffee> so is it a function or not? :)
18:51:34 <vanila> it's not
18:51:43 <vanila> you can think of main as an IO action, which is run when you run the haskell program
18:52:03 <joffee> what is an action?
18:52:06 <jle`> joffee: is 4 a function? is [3,4,5] a function?
18:52:11 <Sorella> Haskell can't actually have something like `void a()` because all functions are required to take a single argument as input, and return a single value as output. They can't do anything else besides that (if we ignore unsafePerformIO)
18:52:14 <joffee> jle no
18:52:26 <jle`> so an IO () is not a function :)
18:52:37 <joffee> mhmm
18:52:47 <jle`> actions aren't an inherent part of haskell
18:53:07 <CrazyM4n> there´s ¨you could have made monads¨ if you want to understand
18:53:09 <jle`> IO a is some sort of data structure that represents a computer process
18:53:16 <vanila> I mean something that does IO,  e.g.  print "hello"  is an action that prints hello
18:53:19 <joffee> 4 and [3,4,5] do not describe computation. main does
18:53:31 <threestrikes> Crazy: If Learn You a Haskell didn't work for you what did you use?
18:53:57 <jle`> joffee: 5 is data, but you give it meaning yourself...it's designed to represent a number
18:54:03 <jle`> and you can manipulate it as if you would manipulate a number
18:54:15 <CrazyM4n> Uh, I remember there was some tutorial I red
18:54:16 <CrazyM4n> read
18:54:17 <jle`> same as IO ().  it's just a normal data thing, but it represents an IO action
18:54:23 <jle`> and you can manipulate it with normal combinators too
18:54:32 <jle`> create new actions by combining old actions
18:54:46 <CrazyM4n> Oh yeah! I did the project euler problems and I looked up example answers
18:54:53 <zwer> a list of bytes can describe computation. it could represent machine code
18:55:02 <Sorella> joffee: IO can be seen basically as something like a list, and `do x <- read; print "name: " ++ x` would be just a cute way of writing something like: [READ, \x -> PRINT "name: " ++ x]. Where `READ` and `PRINT` are just regular type constructors.
18:55:09 <jle`> yeah. IO () could be just a list of bytes underneath.
18:55:16 <Sorella> (of course, internally, GHC doesn't work like that)
18:55:18 <jle`> it's not actually implemented that way
18:55:23 <jle`> but
18:55:31 <jle`> i like thinking about IO a as a little plain text file of C source code
18:55:53 <jle`> and functions like (>>) take two IO a's (two text files) and combines them into one big one
18:56:20 <CrazyM4n> is there a function that can flatten a list of lists, but add something between each list?
18:56:26 <heatsink> intercalate
18:56:26 <Sorella> joffee: if you want to understand the deeper implications of pure I/O, you can watch this talk from Rúnar: http://www.infoq.com/presentations/io-functional-side-effects. It uses Scala, but the same concepts apply.
18:56:34 <CrazyM4n> like, turn [¨hello¨, ¨world¨] into ¨hello world´
18:56:34 <jle`> combines them in a meaningful way...doing what both of them do one after the other
18:56:35 <CrazyM4n> oh
18:56:39 <heatsink> > intercalate "a" "bnns"
18:56:40 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘[GHC.Types.Char]’
18:56:40 <lambdabot>  Expected type: [[GHC.Types.Char]]
18:56:40 <lambdabot>    Actual type: [GHC.Types.Char]
18:56:44 <heatsink> > intercalate 'a' "bnns"
18:56:45 <lambdabot>  Couldn't match expected type ‘[a]’
18:56:46 <lambdabot>              with actual type ‘GHC.Types.Char’Couldn't match type ‘GHC.Types....
18:56:46 <lambdabot>  Expected type: [[a]]
18:56:46 <lambdabot>    Actual type: [GHC.Types.Char]
18:56:47 <joffee> let me try to process all this
18:56:54 <CrazyM4n> ah thanks
18:56:57 <geekosaur> heatsink, that'd be intersperse :)
18:57:06 <heatsink> oh
18:57:14 <geekosaur> > intercalate "a" ["bx","dy","xa"]
18:57:15 <lambdabot>  "bxadyaxa"
18:57:33 <CrazyM4n> that´s what I want
18:57:33 <CrazyM4n> thanks
18:58:34 <zwer> > unwords [¨hello¨, ¨world¨]   -- if you just want to insert space
18:58:35 <lambdabot>  <hint>:1:17: parse error on input ‘,’
18:59:19 <HeladoDeBrownie> zwer, your quotes are weird, do you have autoformatting or something?
18:59:54 <zwer> I copy/pasted his quotes, it must be my irc client (or his)
19:01:08 <joffee> so main is a plain value? how does it do things to the outside world?
19:01:20 <hughfdjackson> joffee: the runtime interprets it
19:01:21 <jle`> joffee: i wrote a little something on this blog.jle.im/entry/first-class-statements
19:01:30 <jle`> joffee: how does a text file do things?
19:01:34 <jle`> a text file of source code?
19:01:44 <hughfdjackson> if i pass you a list that says '1. buy apples, 2. eat apples', i'm not doing that action
19:01:58 <hughfdjackson> :) if you (the runtime) follow those steps, then apple-eating side effects will occur
19:01:58 <jle`> the text file doesn't do anything as you write it, or when you save it.  or just as something that exists
19:02:42 <jle`> haskell is unique in that it separates the two things --- evaluation, and execution
19:02:58 <jle`> you evaluate an IO (), and then the runtime system interprets it and executes the actions that it describes
19:03:19 <slack1256> ghci has the :check command but isn't documented on :help
19:03:48 <slack1256> should it? or the preferred way is to do a cabal check
19:04:14 <joffee> jle text file by itself doesn't do anything, we have to compile or interpret the source first. regardless if it is haskell, C or java. so I am not actually getting what haskell does differently, if anything
19:04:29 <threestrikes> do programming patterns apply in haskell?
19:04:51 <Sorella> joffee: in Haskell, you write programs that generate programs, which will then be interpreted.
19:05:04 <hughfdjackson> threestrikes: if you mean 'gang of four' style design patterns, it's unlikely you'll get much use out of them
19:05:08 <HeladoDeBrownie> threestrikes, many popular ones assume object-oriented, so not always.
19:05:17 <Sorella> Because a pure language can't do anything useful, besides transformating and creating data structures
19:05:31 <Sorella> IOW, Haskell is useless.
19:05:33 <threestrikes> yes, I meant gang of four
19:05:40 <hughfdjackson> threestrikes: but Haskell has has its very own patterns; a lot of which requires a bit of relearning :)
19:05:57 <hughfdjackson> Functors, Monads, Monoids, Applicative Functors, oh my
19:05:57 <CrazyM4n> Haskell is pretty useless. Who needs transforming lists?
19:06:44 <Sorella> threestrikes: none of GoF patterns will apply for Haskell, because the computational model is pretty different (and Haskell has no actual support for OO). There are other patterns, some documented in papers called "Functional Pearls"
19:06:52 <heatsink> threestrikes: Many object-oriented design patterns have very simple solutions in Haskell that aren't really worth calling a "pattern". http://blog.ezyang.com/2010/05/design-patterns-in-haskel/
19:07:14 <threestrikes> I have functional pearls but after the first chapter I realized I was in over my head
19:08:15 <merijn> threestrikes: Have you read Typeclassopedia?
19:08:24 <Sorella> Some of them are easy to read, some of them require you to know some other things before reading them. I don't remember if "A Tutorial On The Expressiveness and Universality of Fold" is a Pearl, but it's fairly easy to follow, and a really nice read.
19:08:28 <threestrikes> should I try to re-engage functional pearls while learning the basics?
19:08:50 <merijn> threestrikes: To be fair, some functional pearls still blow my mind too :)
19:08:54 <joffee> from where I am sitting main is called an action instead of a function so that we can pretend that functions are pure (while actions arent). how close is this to the truth?
19:08:57 <threestrikes> merijn: I have not
19:09:29 <merijn> threestrikes: Then I would recommend reading that first, it covers stuff like Monoid, Functor, Applicative and Monad, which are for more common "patterns" in FP
19:09:41 <heatsink> joffee: In Haskell, a function is something you apply to arguments to get a value.  You can't apply "main" to arguments; it's already a value.
19:09:46 <Sorella> joffee: "action" is just a description of the data structure. Just like lists are called lists.
19:09:47 <merijn> @where typeclassopedia
19:09:48 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
19:09:48 <threestrikes> Ok thanks a lot
19:10:47 <joffee> heatsink: that sounds like something we would call a function accepting void in other languages
19:11:18 <merijn> joffee: In C/Java/Python *everything* is an IO action
19:11:23 <merijn> Implicitly
19:11:36 <merijn> In haskell only *some* things are IO actions and it's explicit
19:11:38 <Sorella> joffee: is list a function?
19:11:52 <threestrikes> also looking for a project to get involved with on github to give me a better idea of how a true haskell program works.  I was hoping to find something that wasn't extremely large.  Any suggestions?
19:11:59 <joffee> yes I guess because we can perform side effects everywhere
19:12:05 <joffee> Sorella: no
19:12:08 <Sorella> You could certainly make it a "list a()" function. (My PL works like that, as does Smalltalk), but well...
19:12:19 <merijn> threestrikes: xmonad?
19:12:33 <hughfdjackson> threestrikes: you could have a look at https://github.com/cakesolutions/the-pragmatic-haskeller
19:12:36 <merijn> threestrikes: pandoc is huge, but, for example, the individual parsers are pretty self-contained
19:12:41 <Cale> I'm not sure I'm totally comfortable with calling, e.g. Java methods "implicitly IO actions"
19:12:42 <Sorella> So, IO a is the same thing as list. Which is in turn the same thing as a number. Or a string. Or every other value. Everything is a value.
19:12:55 <Cale> I guess you can sort of look at it like that
19:13:05 <merijn> threestrikes: (I know this, because I managed to extend the pandoc rST parser while still not having a clue how pandoc as a whole works :D)
19:13:20 <artyomkazak> threestrikes: I second Pandoc
19:13:22 <threestrikes> :) Ok
19:13:31 <joffee> it is not the same thing, unless you can demonstrate printing to stdout by using a list or a number
19:13:33 <Cale> But the important thing is that IO actions are values whose evaluation doesn't cause anything to occur, but which describe actions which could be executed to cause effects
19:13:43 <merijn> Cale++
19:14:03 * hackagebot process-streaming 0.6.0.0 - Streaming interface to system processes.  http://hackage.haskell.org/package/process-streaming-0.6.0.0 (DanielDiazCarrete)
19:14:05 <merijn> joffee: evaluating IO can't print to stdout either
19:14:16 <Sorella> joffee: in C, "void main()" is not a value because you can't manipulate it. You can't say: "I want to make a new void main() that will be the same as the older one, but I'll remove some of these statements, and intersperse print statements throughout." You can do that in Haskell because IO is just a value
19:14:48 <Sorella> joffee: Haskell can't print to stdout. Or read from stdin. Or talk to databases.
19:15:12 <Cale> You can imagine that IO actions are internally some sort of algebraic datatype that says what things ought to be done in order to compute its result, and that the runtime system contains an (effectful) interpreter for these, which decomposes the structure and carries out the effects.
19:15:23 <Cale> That's not how GHC does it really, but it could.
19:15:24 <artyomkazak> threestrikes: I managed to add automatic charset detection/conversion, proper line blocks, reimplement emphasis parsing, and add “magic links” (e.g. [foobar](@w) links to Wikipedia about “Foobar”), all without having a clue how Pandoc works
19:15:28 <merijn> joffee: I recommend this quick overview of IO: http://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity
19:15:46 <joffee> Sorella how do you remove some statements from IO?
19:16:14 <joffee> merijn: ok I bookmarked it
19:16:25 <jle`> oh i also like this one blog.jle.im/entry/first-class-statements :)
19:16:30 <Sorella> joffee: join(do { putStrLn "foo"; putStrLn "bar" }) will be the same as putStrLn "bar"
19:16:43 <merijn> threestrikes: Although I guess a familiarity with Parsec style parsec is required to do something useful while hacking pandoc :)
19:16:52 <HeladoDeBrownie> Sorella, not quite
19:16:53 <Sorella> You can try `main = join $ do { putStrLn "foo"; putStrLn "bar" }`
19:17:06 <HeladoDeBrownie> Sorella, that's not well typed actually
19:17:10 <merijn> Sorella: That's not true
19:17:16 <threestrikes> I did a search once on github and saw there were people working on compiling haskell code to Java?  I don't understand why?
19:17:17 <HeladoDeBrownie> @type join $ do { putStrLn "foo"; putStrLn "bar" }
19:17:18 <lambdabot>     Couldn't match type ‘IO a’ with ‘()’
19:17:18 <lambdabot>     Expected type: IO (IO a)
19:17:18 <lambdabot>       Actual type: IO ()
19:17:23 <HeladoDeBrownie> @type join
19:17:24 <lambdabot> Monad m => m (m a) -> m a
19:17:38 <merijn> threestrikes: So you don't have to write java in companies that use Java? ;)
19:17:41 <HeladoDeBrownie> Sorella, generally you can't decompose IO, but you can compose it
19:17:44 <heatsink> threestrikes: So it can run on the JVM
19:17:51 <Cale> threestrikes: I don't know about compiling it to Java, but compiling it to JVM seems reasonabl
19:17:52 <Cale> e
19:17:56 <merijn> threestrikes: So, the same reason people are working on ghcjs :)
19:18:04 * Sorella goes back to dynamic types
19:18:30 <Cale> Sorella: I wouldn't recommend it -- if you can't get types right, you really want the compiler helping you :)
19:18:35 <threestrikes> Cale: Correct, JVM
19:19:00 <jle`> type errors in haskell are runtime errors in dynamic languages :P
19:19:02 <rom1504> if you can compile it to java then you can deploy anything you can deploy java
19:19:12 <jle`> it's not like if you switch to a dynamic language the bugs go away
19:19:13 <rom1504> *anywhere
19:19:22 <Sorella> Cale: i-it's not an error if no one notices it, right? :P
19:19:23 <rom1504> but that's kinda silly
19:19:26 <CrazyM4n> jle`: that´s the best part
19:19:35 <jle`> the only difference is that instad of finding them at compile time, you find them in the middle of production losing $50k per hour
19:20:33 <jle`> this is something i think a lot of people don't get when wrestling with type errors.  "why does it take so long to even get it to compile?"  ... but tehy don't realize that every minute that they spend debugging their types is an hour debugging runtime
19:20:34 <HeladoDeBrownie> Sorella, although, on a slight tangent, I can think of at least one convenient way to "remove statements". Build up a free monad computation and have the interpreter do nothing with some of the statements.
19:20:42 <joffee> so Sorella was wrong, you cant remove statements from IO?
19:20:52 <HeladoDeBrownie> joffee, not in general.
19:20:55 <threestrikes> does writing in haskell in order to compile to JVM introduce more problems or does it reduce them, and how?
19:21:39 <jle`> joffee: what do you mean by remove statements?
19:21:42 <Sorella> joffee: well, theoretically you can. Just not with "join". (You can do it in Purr, but that's because Purr isn't typed).
19:21:56 <CrazyM4n> If you wanted Haskell on the JVM why not use scala?
19:22:27 <joffee> Sorella: joffee: in C, "void main()" is not a value because you can't manipulate it. You can't say: "I want to make a new void main() that will be the same as the older one, but I'll remove some of these statements, and intersperse print statements throughout." You can do that in Haskell because IO is just a value
19:22:32 <Sorella> Scala isn't very functional. If you're looking for Haskell on the JVM, Frege would be somewhat closer.
19:22:48 <CrazyM4n> Ah
19:22:50 <joffee> jle`: ^^
19:23:52 <HeladoDeBrownie> joffee, once you've composed some IO values together, they're as good as inseparable. However, you could make decisions at an earlier point as to whether to compose them in the first place.
19:24:04 <joffee> what is Purr
19:24:21 <Sorella> joffee: my purely functional language.
19:24:27 <joffee> HeladoDeBrownie: so it is exactly the same as void main in C in this regard
19:24:32 <fread2282> http://lpaste.net/111316 (question enclosed)
19:24:59 <Sorella> joffee: not really, in C effects are not values.
19:25:21 <HeladoDeBrownie> joffee, in that you can't decompose a C function? I guess. It's hard to compare things that are so different though.
19:25:29 <hughfdjackson> is there an NFData instance somewhere for IO?
19:25:51 <hughfdjackson> if there was, you could prove that you could fully evaluate the IO monad without the effect it describes ever being executed
19:26:04 <heatsink> hughfdjackson: No, IO can capture variables but you can't normalize them
19:27:29 <heatsink> rnf (let x = map (1+) [1..100] in print x) -- Can't force evaluation of 'map' here
19:28:01 <joffee> HeladoDeBrownie: so in what way is IO different then? I am not getting it.. perhaps I should go read those blogs
19:28:32 <Sorella> joffee: you could just watch Rúnar's talk about purely functional IO
19:28:33 <hughfdjackson> http://lpaste.net/111323
19:28:55 <hughfdjackson> ^ that pastie is the clostest I've come to a 'proof'
19:29:00 <CrazyM4n> You could always use the function that shall not be named
19:29:03 <CrazyM4n> Please don´t
19:29:04 <HeladoDeBrownie> joffee, in short, IO values are (first-class) programs.
19:29:26 <pgiarrusso> hughfdjackson: will evaluatedIOValue ever be forced?
19:29:51 <hughfdjackson> not in its entirity - i.e. not to normal form
19:29:55 <pgiarrusso> hughfdjackson: also, there’s a reason seq takes two arguments
19:29:55 <hughfdjackson> -.- only to weak head normal form
19:30:03 <pgiarrusso> hughfdjackson: as written, not even
19:30:06 <hughfdjackson> pgiarrusso: curses
19:30:21 <hughfdjackson> :| better to have tried and failed
19:30:23 <joffee> HeladoDeBrownie: are they any more first class than (lambda () (print 10))? evaluating that wont print anything either
19:30:35 <HeladoDeBrownie> joffee, what language is that?
19:30:38 <pgiarrusso> I think you want `seq throwAwayThis returnThis`..
19:31:00 <Sorella> Looks like Scheme.
19:31:23 <joffee> lisp. but that is not important.. we wrapped a side-effect inside a lambda
19:31:23 <heatsink> joffee: They are similar in that you can't examine the contents of C functions and IO actions.  You can only call a C function.  You can't call or run IO actions.
19:31:24 <pgiarrusso> hughfdjackson: that was for you :-). Not sure how well that works
19:31:28 <Sorella> joffee: things are either first-class or not first-class. Lambdas aren't more first-class than numbers.
19:31:35 <Sorella> They're just different data structures
19:31:48 <hughfdjackson> pgiarrusso: it certainly only outputs "bye", as expected
19:31:50 <hughfdjackson> ;D
19:32:01 <HeladoDeBrownie> joffee, imagine that every "function" in Lisp is in fact an IO action. Haskell's functions, on the other hand, do not have side effects, only results.
19:32:09 <joffee> is IO action just a side effect wrapped in an anonymous function under the hood?
19:32:26 <joffee> a function that takes no arguments
19:32:33 <pgiarrusso> hughfdjackson: throwAway (Debug.trace “foo” (print "hi”)) would tell the difference methinks
19:32:35 <HeladoDeBrownie> joffee, the other thing is that IO values don't even have side effects during evaluation – They must be run by a special interpreter, the I/O system.
19:32:48 <heatsink> joffee: (lambda (f) (f 1)) can print output in lisp when it's called.
19:32:51 <Sorella> joffee: you could implement it like that (it's how Purr does it), but that's an implementation detail, and irrelevant to the actual semantics of IO
19:33:02 <heatsink> joffee: The corresponding Haskell function, (\f -> f 1), can't print output.
19:33:53 <heatsink> joffee: That's because some lisp functions have side effects, but no Haksell functions have side effects.
19:34:01 <HeladoDeBrownie> joffee, Haskell is basically a meta-programming language – You write a non-side-effecting program that composes together a side-effecting program to run.
19:34:05 <CrazyM4n> What is the difference between foldl and foldl´?
19:34:21 <heatsink> foldl' is strict.  It forces evaluation of the accumulator after each step.
19:34:33 <heatsink> Usually you want foldl'.
19:35:02 <CrazyM4n> Ah. But foldl1 and foldl1´ have the exact same code... does that mean that foldl1 is strict by default?
19:35:24 <joffee> ok, thanks all for help. I kind of get it, but not entirely. I will read more about it
19:35:30 <monochrom> where do you read that they have the same code?
19:35:36 <CrazyM4n> http://hackage.haskell.org/package/base-4.7.0.1/docs/src/Data-List.html#foldl1%27
19:36:08 <zwer> CrazyM4n fold1 calls foldl, fold1' calls foldl'
19:36:09 <monochrom> um, you see how foldl1 uses foldl, foldl1' uses foldl', no?
19:36:11 <Sorella> CrazyM4n: they don't, foldl1 calls foldl, and foldl1' calls foldl'
19:36:34 <CrazyM4n> Oh, I didn´t catch that
19:36:35 <monochrom> try to get a diff from the computer
19:36:59 <CrazyM4n> Oops
19:37:16 <Sorella> Primes are difficult to notice, usually, yes.
19:38:51 <joffee> one more thing. what are practical reasons of all of this? IO being a value. is it to mark the code that does something impure?
19:39:57 <heatsink> There are practical benefits, but the original motivation was more theoretical
19:40:04 <heatsink> having to do with denotational semantics
19:40:33 <Camm> Hello
19:40:44 <heatsink> the practical benefit is that return types carry a lot of information about what a function does.
19:41:00 <heatsink> The type IO () basically means, "does something"
19:41:15 <heatsink> not very informative
19:41:58 <HeladoDeBrownie> joffee, thinking of it as a "marker" may mislead you. It doesn't "mark" code as impure; IO represents programs that could potentially be run, like a recipe for how to bake a cake or something.
19:41:59 <ceron> what do you usually prefer or default to, map/filter or list comprehensions?
19:42:10 <heatsink> If you execute two IO actions in the opposite order, does it give you the same result?  Who knows.
19:42:52 <hughfdjackson> perhaps this is a decent demonstration of it
19:42:54 <HeladoDeBrownie> joffee, so rather than think that a -> IO b means "This is a function that may result in a cake", think "This is a function that results in instructions for how to make a cake".
19:43:34 <hughfdjackson> http://lpaste.net/111324
19:44:22 <hughfdjackson> from the above conversation, foldl' will ensure that 'print "seed"' and 'print "hi"' are fully evaluated
19:44:28 <heatsink> fread2282: I don't know.
19:44:39 <hughfdjackson> then, because the accumlator is always thrown away, only the last item of the list will be passed back to main
19:44:46 <joffee> HeladoDeBrownie: in practice why is that distinction important? when uou call 'print' dont you think "this will print to the screen" and not "this will produce a recipe that prints to the screenh
19:45:01 <tabemann_> the instructions interpretation makes more sense when one consider things like being able to join IO () returned from within an STM action
19:45:01 <hughfdjackson> so the structure that main gets is the one that results from 'print "bye"'
19:45:28 <tabemann_> join
19:45:33 <tabemann_> join
19:45:36 <tabemann_> whoops
19:46:10 <HeladoDeBrownie> joffee, the printing does not happen then and there when the action gets evaluated. You can evaluate print "bye" a hundred times and not a word will appear on screen.
19:46:24 <tabemann_> join . atomically . return $ putStrLn "foo"
19:46:27 <Sorella> joffee: reasoning about the code becomes much simpler. You know that functions that return `IO x` do evil things. You can call those functions and throw away the result without having evil things happen.
19:46:54 <hughfdjackson> equivalent javascript to that haskell code, as i understand it: [() => console.log("hi"), () => console.log("bye")].reduce(function(a, b){ a(); return b }, () => console.log("seed"))
19:47:10 <tabemann_> if IO a merely meant "has side-effects" you wouldn't be able to do that
19:47:41 <heatsink> joffee: In practice, it's fairly common to put IO actions in data structures, pass them to functions, or wrap them in monads.
19:48:24 <ceron> heatsink is the fact that only some strings are printed not related to lazy evaluation?
19:48:28 <heatsink> All of these only make sense when thinking of an IO action as a value.
19:48:57 <adarc> sup, i'm about to use attoparsec to parse some auditd logs.. any suggestion on whether I should use a huge record or a map etc? Eventually i'm going to be converting this data to json etc.. https://people.redhat.com/sgrubb/audit/audit-parse.txt <-- tons of known fields
19:48:57 <heatsink> ceron: are you referring to hughfdjackson's example?
19:49:24 <ceron> yes sorry. that was directed to hughfdjackson
19:49:39 <ceron> anyone can answer, though :)
19:49:47 <HeladoDeBrownie> ceron, execution and evaluation are separate things. Even an IO action that you evaluate may not get executed. It only gets executed if the I/O system wills it or it is composed with something that gets executed.
19:49:51 <hughfdjackson> ceron: i hope i'm correct in saying that foldl' forces the accumulator to be evaluated entirely
19:50:10 <HeladoDeBrownie> s/with/into/
19:50:25 <hughfdjackson> :) i'm still quite new though - i'll welcome all corrections!
19:53:35 <dibblego> IO does not do side-effects. It allows a (Haskell) programmer to construct IO actions, combinng them in various ways, absent side-effects, which may (or may not) then be used to construct an executable with GHC (not Haskell), which may or may not execute side-effects
19:54:22 <tabemann_> adarc: you probably want a map for that, even though your map values will have to encode a type
19:55:36 <tabemann_> the advantage of a map is that your parser can arbitrarily address fields, whereas you will have to hardcode name to field mappings if you use a recordd
19:57:02 <ceron> is this a good example that IO does not cause side-effects? or can it be argued it is lazy evaluation that is causing it
19:57:09 <ceron> > sequence $ reverse [print x | x <- [1..10]]
19:57:10 <lambdabot>  <IO [()]>
19:57:32 <dibblego> this is because IO is pure, not because of lazy evaluation
19:58:11 <dibblego> reverse will evaluate all head pointers (not head values)
19:58:17 <Cale> ceron: Evaluation of IO actions doesn't cause side effects, but execution does.
19:58:22 <jle`> ceron: lazy evaluation doesn't matter here
19:58:22 <dibblego> > null (reverse [undefined])
19:58:24 <lambdabot>  False
19:58:28 <ceron> dibblego I thought so too, but then someone gave me this example and I did not know how to respond:
19:58:30 <heatsink> That evaluates to (print 10 >> print 9 >> print 8 >> ... >> print 1)
19:58:32 <ceron> > sequence $ tail $ reverse [print 10, print 20, undefined]
19:58:34 <lambdabot>  <IO [()]>
19:58:35 <jle`> you can fully evaluate an IO action, and nothing happens
19:58:35 <heatsink> regardless of evaluation order
19:58:50 <jle`> > do { evaluate launchMissiles; putStrLn "sup" }
19:58:51 <lambdabot>  Not in scope: ‘launchMissiles’
19:59:02 <jle`> launchMissiles :: IO ()
19:59:06 <jle`> in case it wasn't clear >_>
19:59:07 <dibblego> ceron: I am not sure how to respond either, other than, by being careful about describing what is happening there
19:59:51 <adarc> tabemann_: ya.. thanks alot. it seems that's where i'm leaning too, especially due to the fact that there can be custom field names
20:00:03 <dibblego> the reverse function specifically, makes the discussion muddy, because it introduces non-strict evaluation
20:00:11 <dibblego> but that is aside from IO
20:00:32 <adarc> i'm thinking i could parse <fieldname>=<type>, and I parse type based on "string" num etc
20:00:51 <adarc> ("exe", String "/bin/bash")
20:01:45 <jle`> ceron: what's the issue?
20:01:46 <dibblego> > null (reverse [undefined, print 7]) -- constructs a list of IO actions, reverses them, then checks if the list (of IO actions) is empty (it isn't)
20:01:47 <lambdabot>  False
20:02:21 <dibblego> there is no side-effecting with IO within [Safe]Haskell  it's just not possible
20:03:21 <joffee> if haskell was strict would calling tail on a list of actions still not execute first action's effects?
20:03:29 <tabemann_> no
20:03:30 <dibblego> No.
20:03:41 <dibblego> in fact, you can see similar programs in strict languages (e.g. Scala)
20:03:42 <jle`> joffee: evaluating the action is like evaluating a number
20:03:48 <jle`> it's just...data
20:03:50 <joffee> no, it would not execute them?
20:03:56 <dibblego> both IO and ST are in the scalaz library and exhibit the same behaviour (modulo strictness)
20:03:58 <Sorella> joffee: it would not execute them.
20:04:01 <dibblego> No, they would not be executed
20:04:10 <joffee> interesting
20:04:14 <jle`> because there's nothing to execute...it's just data
20:04:23 <jle`> it's literally just a normal data structure
20:04:30 <jle`> like a list or a vector or a bool or a number
20:04:37 <dibblego> it is not possible to execute an IO action in [Safe]Haskell to produce a result  only construct IO values, which are then passed to the interpreter (GHC)
20:04:57 <joffee> I think it is starting to sink it
20:05:28 <jle`> i think if we try to talk about the semantics of what IO represents, we don't have to make the distinction between implementations of haskell and safe/nonsafe
20:05:33 <dibblego> I have an exercise whereby a pure-functional IO program is constructed with C# (only to point out that the language is unimportant) using the free monad
20:05:46 <jle`> implementations can be weird, but the semantics are exact
20:05:53 <dibblego> I safe [Safe] to eliminate unsafe* from the discussion
20:06:05 <dibblego> s/safe/say
20:08:27 <chrisdotcode> Is it better to import (<$>), or just use infix fmap if I only need to use it literally only once in a module?
20:08:34 <Sorella> joffee: you can look at this program and wonder what it does when you call "main": https://gist.github.com/robotlolita/66605e1476d6c0d54bf3
20:09:04 <jle`> chrisdotcode: i don't think importing Control.Applicative is a big deal
20:09:16 <chrisdotcode> jle`: Is there run-time overhead for imports?
20:09:24 <chrisdotcode> Or do you only use what you pay for, a la C++
20:09:39 <jle`> hopefully any (<$>) should be inlined as fmap ayway
20:09:47 <Sorella> Sometimes you don't even pay for what you use
20:09:52 <tabemann_> I'd just import Control.Applicative ((<$>))
20:09:58 <jle`> importing doesn't happen at runtime
20:10:10 <chrisdotcode> Okay, cool.
20:10:11 <chrisdotcode> Thanks guy
20:10:13 <chrisdotcode> s
20:11:10 <hughfdjackson> -.- talking of fmap and infxing
20:11:21 <hughfdjackson> i cannot find anything of the signature `Functor f => f a -> (a -> b) -> f b` in hoogle
20:11:46 <dibblego> @type (<&>)
20:11:47 <lambdabot> Functor f => f a -> (a -> b) -> f b
20:11:54 <tabemann_> I onno why (<$>) is even in Control.Applicative, since I use it all the time and I frankly don't use applicatives as such much
20:12:10 <monochrom> it is in Data.Functor
20:12:13 <hughfdjackson> dibblego: .. i wonder what's wrong with hoogle
20:12:23 <dibblego> hoogle probably doesn't index Control.Lens
20:12:39 <hughfdjackson> oh - i thought it had all of hackage
20:12:50 <Sorella> I think hayoo does
20:13:34 <hughfdjackson> :) i haven't tried that out - i'll give it a go now
20:13:35 <hughfdjackson> cheers
20:13:49 <Sorella> http://hayoo.fh-wedel.de/?query=f+a+-%3E+%28a+-%3E+b%29+-%3E+f+b
20:16:24 <lostman> rejecting: base-4.7.0.1/installed-1a5... (package is broken)
20:16:35 <lostman> has anyone seen this sort of thing with Cabal before?
20:17:27 <monochrom> yes. you are trying to bring in a package that absolutely wants an older base.
20:17:33 <hughfdjackson> Sorella: awesome - pity it doesn't search on constraints
20:17:40 <hughfdjackson> (at least, it doesn't seem to)
20:17:45 <hughfdjackson> but it seems to do the job well enough :)
20:18:14 <lostman> monochrom: wouldn't that show up in the log? I don't think any of my pacakges wants an older base
20:18:15 <monochrom> err, maybe not, "package is broken" may refer to a different problem
20:18:37 <tabemann_> there's a cabal option to force it to accept newer packages despite what packages say, I don't remember what it is offhand though
20:19:16 <lostman> I have bad experiences with --accept-newer... Sometimes it works, sometimes it doesn't
20:19:30 <lostman> cabal has the tendency to do whatever it wants, unfortunately
20:20:10 <lostman> I'm trying to escape Cabal Hell by having a stable set of dependencies in a single directory and I want to write some sort of install script
20:20:54 <monochrom> it's --allow-newer[=PKGS]. it's in the output of "cabal install --help". 1.20 only
20:21:58 <monochrom> logically, --allow-newer cannot solve real incompatibilities.
20:23:06 <tabemann_> --allow-newer is useful because package writers have a tendency to just guess when writing upper bounds for package versions in their packages
20:23:33 <HeladoDeBrownie> Who can blame them?
20:23:57 <tabemann_> it's hard to figure out whether one's package will be conpatible with a package that hasn't been written yet
20:24:32 <monochrom> even if the thing passes compilation, do not think that the problem ends.
20:24:53 <lostman> it's not like there are some deep compatibility tests; it's considered compatible with the newer version if it compiles or until someone finds a regresssion
20:24:56 <monochrom> API changes can be semantic changes without type signature changes.
20:25:22 <lostman> who's gonna keep track of all the dependencies...
20:25:34 <monochrom> it's rabbit holes all the way down.
20:25:37 <lostman> I have a simple app and when you get all the packages that need to be installed it's more than 300
20:25:50 <lostman> it is a bit out of hand, IMHO
20:27:19 <gdoteof> i have a lazy bytestring which i got from encoding a json value
20:27:41 <gdoteof> now i want to write it to a file, and the documenation says that i shoudl be using Char8 instead of lazy if i rely on ascii encoding
20:28:08 <gdoteof> which, id o.  so.. i am lookiang ato toChunks, which coverts frm a a lazy btestring to a strict one, but it returns a [ByteString] rather than ByteString
20:28:33 <tabemann_> monochrom: but how does one know what those will be when one is targeting the latest version of a package in the first place, i.e. one is setting upper bounds on packages that don't exist yet
20:29:38 <tabemann_> gdoteof: don't use Char8 - just don't
20:30:05 <tabemann_> use UTF8 or Text.Encoding
20:30:46 <Krikey_Sanchez> I have a question about haskell IO
20:30:58 <monochrom> gdoteof, I am not convinced that the condition "if I rely on ascii encoding" holds. generally encoding a json value gives you UTF8, not ascii.
20:31:07 <Krikey_Sanchez> http://pastebin.com/fx69c8S8 <- I'm trying to write a function that takes in a handle, and then prints one character from that file every time the user hits a key
20:31:10 <Krikey_Sanchez> without echoing that key
20:31:15 <Krikey_Sanchez> and this code here
20:31:31 <Krikey_Sanchez> doesn't print anything until I've hit a key as many times as the line is long
20:31:36 <Krikey_Sanchez> and then it prints the whole line all at once
20:31:40 <gdoteof> i am extremely confused on monochrom so i should be fine to use hPut from bytestring.lazy?
20:31:44 <Krikey_Sanchez> I assume I'm not understanding something about laziness here
20:32:00 <monochrom> in other words you already have a lazy bytestring that has the right bytes, just write it to a file, there is nothing more to do.
20:32:11 <gdoteof> i am having these weird issues i am trying to track down, where i write a large json file, encoded from lazybyutestring and only part of the file is written
20:32:29 <gdoteof> monochrom: yeah that's what i had been doing this while time
20:33:11 <monochrom> hPut? not writeFile?
20:33:48 <monochrom> if you want to use hPut, use openBinaryFile or withBinaryFile
20:34:04 <gdoteof> monochrom: i have used writefile as well
20:34:16 <gdoteof> i am getting the same(ish?) behavior with writefile and hput
20:34:31 <gdoteof> i do need to make sure the file is blocking
20:34:38 <gdoteof> so i use openfileblocking, then write to ti
20:34:52 <monochrom> where can I find openFileBlocking?
20:35:30 <gdoteof> monochrom: next to openbinaryfile, ghc.io.handle.fd
20:35:52 <gdoteof> it is a FIFO i am writing to
20:35:59 <jle`> is haddock's markdown based on anything?
20:36:11 <jle`> or was it all made up/ad hoc just for haddock
20:37:14 <monochrom> ok, after you openFileBlocking, hSetBinaryMode handle True.
20:38:27 <monochrom> but of course all along I'm just blind-guessing that locale is getting into the way.
20:38:27 <gdoteof> monochrom: why binary mode? it is a json file
20:39:10 * hackagebot blank-canvas 0.5 - HTML5 Canvas Graphics Library  http://hackage.haskell.org/package/blank-canvas-0.5 (AndyGill)
20:39:16 <tabemann_> but you're writing a ByteString containing arbitrary bits
20:39:24 <monochrom> do not let the names "binary mode" and "text mode" fool you. know the real semantics.
20:39:41 <monochrom> the semantic of "binary mode" is verbatim.
20:39:49 <tabemann_> those bits may br UTF8, but they're still arbitrary bits
20:40:02 <gdoteof> monochrom: ah.  well verbatim sounds better!
20:40:07 <monochrom> the semantics of "text mode" is one more encoding layer based on your current locale and/or OS etc
20:40:28 <monochrom> for example "text mode" inserts \r before \n if Windows
20:40:56 <chirpsalot> Krikey_Sanchez: are you trying this in GHCI, or what?
20:41:02 <monochrom> this is why I assert that there is no such thing as "meaningful names". and people think that I'm extremist.
20:41:16 <trap_exit> jle , jle`: ping
20:41:21 <trap_exit> jle , jle`: ping
20:41:23 <Krikey_Sanchez> chirpsalot, no, compiled with ghc
20:41:28 <chirpsalot> Krikey_Sanchez: it might be line buffered, so you have to hit enter before getChar sees any characters?
20:41:40 <tabemann_> okay, gotta get going
20:42:00 <chirpsalot> Krikey_Sanchez: I mean, you set no buffering... But I have always found this stuff... Picky.
20:42:01 <Krikey_Sanchez> chirpsalot, except I set both the handle itself and stdin to nobuffer
20:42:08 <Krikey_Sanchez> precisely to avoid that
20:42:16 <trap_exit> yo
20:42:20 <trap_exit> can someone explain tranducers in haskell to me?
20:42:30 <trap_exit> i.e. convert this https://www.youtube.com/watch?v=6mTbuzafcII from clojure to haskell
20:43:04 <monochrom> another example of meaingless names: "module X(module Y)" the "module Y" part does not mean module Y. far from it.
20:43:23 <monochrom> http://www.vex.net/~trebla/haskell/module.xhtml
20:43:59 <monochrom> it's totally not about module
20:45:14 <jle`> i dont kno anything about transducers :|
20:45:57 <monochrom> edwardk said something about it earlier today. see the logs.
20:46:28 <trap_exit> jle`: go learn transducers :-)
20:46:38 <trap_exit> jle`: how goes research?
20:46:58 <jle`> not too bad :)
20:47:02 <jle`> ty for asking
20:47:43 <trap_exit> I don't know if this is a good sign or a bad sign
20:47:53 <trap_exit> but now, when I read anything, I'm like "wtf is the type of this variable"
20:48:00 <trap_exit> and if I can't write out a haskell-like type, I'm pissed
20:48:19 <Cale> trap_exit: see the discussion here: http://www.reddit.com/r/haskell/comments/2cv6l4/clojures_transducers_are_perverse_lenses/
20:48:26 <monochrom> it is a good sign
20:48:44 <trap_exit> reddit?
20:48:50 <trap_exit> I thought it was only good for cats
20:49:02 <HeladoDeBrownie> trap_exit, not a direct answer to your question, but dynamically typed languages effectively have precisely one type.
20:49:29 <monochrom> becoming more critical, less believing is a good sign.
20:50:09 <monochrom> the holy grail is to be able to demand "what is the complete specification of it". for now, "what is the type of it" is a good start.
20:50:45 <trap_exit> monochrom: oh, if you want to demand that, program in Coq
20:50:59 <trap_exit> after programming in Coq, I view _mathematics_ as imprecise
20:51:13 <trap_exit> it's like "wtf, this would be atleast 10 lemmas in Coq", you can'st just say "it's obvious that .... "
20:53:39 <monochrom> fortunately, some type inferences are obvious. (\x -> x) obviously has type a->a :)
20:53:44 <Krikey_Sanchez> so, anyone know why my program is line-buffering
20:53:50 <Krikey_Sanchez> even though I explicitly turned off line buffering?
20:54:16 <HeladoDeBrownie> monochrom, or does it??? (The multiple question marks are meant to make you doubt your sanity.)
20:54:22 <Krikey_Sanchez> the entirety of the program is here
20:54:22 <Krikey_Sanchez> http://pastebin.com/jpdxnitT
20:54:25 <Ralith> trap_exit: idris is pretty great
20:54:29 <Krikey_Sanchez> although I don't think that adds much
20:55:47 <trap_exit> https://www.youtube.com/watch?v=lKXe3HUG2l4 is awesome
20:55:50 <trap_exit> I wish I had gone to strange loop
20:55:57 <trap_exit> adding it to my list of 'conferences to attend in future'
20:56:57 <monochrom> Krikey_Sanchez: I cannot reproduce the problem. works for me. every key I type successfully reveals one more letter from a file.
20:57:30 <monochrom> oh, I see, I'm using runghc, not compiling
20:58:47 <monochrom> you are still having stdout line-buffered. that is why.
21:00:49 <monochrom> putStr "" doesn't really do anything useful
21:01:13 <Krikey_Sanchez> oh huh
21:01:18 <Krikey_Sanchez> it works differently if you use runghc
21:01:21 <Krikey_Sanchez> than compiling
21:01:41 <monochrom> you need hSetBuffering stdout NoBuffering
21:01:50 <Krikey_Sanchez> oh stdout
21:02:08 <Krikey_Sanchez> ah
21:02:09 <Krikey_Sanchez> okay
21:02:16 <Krikey_Sanchez> weird that runghc has different defaults, though
21:02:29 <jle`> laziness is kinda cool
21:03:16 <trap_exit> that's what the grad student said
21:04:30 <jle`> :P
21:05:46 <names_doug> I'm wondering if anyone can help me grasp functors. 'fmap id (Just 3)' equals '(Just 3)'. What is id here?
21:06:07 <monochrom> id x = x
21:06:16 <notthemessiah> names_doug: it's called the  identity function
21:06:26 <monochrom> fmap id (Just 3) = Just (id 3) = Just 3
21:06:48 <names_doug> I read that, but, I'm wondering how does (id 3) reduce to Just 3
21:06:57 <jle`> id 3 reduces to 3
21:07:07 <monochrom> no, id 3 does not reduce to Just 3. Just (id 3) does.
21:07:09 <names_doug> That's the part that I don't grase
21:07:19 <jle`> do you know how function evaluation works in haskell?
21:07:30 <monochrom> "id whatever" reduces to "whatever". that is all.
21:07:34 <names_doug> maybe not as well as i should, but I have the basics
21:07:36 <jle`> if you have a function like (f x = x + x), and you do f 3, you put the 3 where the x's are
21:07:51 <names_doug> that I have jle`
21:07:54 <trap_exit> :src id
21:07:59 <trap_exit> >t src id
21:08:03 <monochrom> it's @src
21:08:03 <jle`> so calling foo x = x + x, foo 3 ==> 3 + 3
21:08:05 * trap_exit kicks lambdabot
21:08:08 <trap_exit> @src id
21:08:08 <lambdabot> id x = x
21:08:11 <jle`> so id x = x
21:08:14 <jle`> id 3 = 3
21:08:35 <dfeuer> @src foldM
21:08:35 <lambdabot> foldM _ a []     = return a
21:08:35 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
21:08:55 <jle`> @src fmap Maybe
21:08:55 <lambdabot> Source not found. You type like i drive.
21:09:05 <jle`> so fmap for Maybe is defined as fmap f (Just x) = Just (f x)
21:09:09 <MP2E> you can't drive lambdabot, silly
21:09:15 <jle`> so when i do fmap id (Just 3)
21:09:19 <haasn> @src Functor Maybe
21:09:20 <lambdabot> Source not found. Are you typing with your feet?
21:09:22 <jle`> plug in id for f, and 3 for x
21:09:40 <trap_exit> OMG
21:09:41 <jle`> fmap f (Just x) ==> fmap id (Just 3) ==> Just (id 3) ==> Just 3
21:09:42 <trap_exit> someome buidl this
21:09:46 <trap_exit> a tool wher eyou type in ahskell expression
21:09:51 <trap_exit> and it shows how haskell evaluetes it step by step
21:09:56 <MP2E> already been done
21:09:57 <trap_exit> I would pay $0.99 for an ipad app that did this
21:10:01 <names_doug> :jle`: I got that
21:10:11 <MP2E> http://chrisuehlinger.com/LambdaBubblePop/
21:10:17 <monochrom> there are at least 3 websites doing that now.
21:10:25 <jle`> there's also fmap _ Nothing = Nothing, so fmap id Nothing = Nothing as well
21:10:26 <names_doug> fmap f (Just x) ==> fmap (+1) (Just 3) ==> Just ((+1) 3) ==> Just 4
21:10:32 <monochrom> but they are not ipad apps yet.
21:10:34 <oakwhiz> +1 for Lambda Bubble Pop
21:10:43 <oakwhiz> it's awesome
21:10:50 <jle`> names_doug: yup :)
21:11:00 <trap_exit> MP2E: yeah, but I think in that, I choose order of operations
21:11:06 <trap_exit> I wnat it to tell me haskell's opreder of reductions
21:11:09 <vanila> https://github.com/Hrothen/Hubert/blob/master/src/Main.hs cool this guy is writing a web browser in haskell
21:11:42 <names_doug> I got that, that's crystal clear. I just having trouble conceptualizing what id is?
21:11:56 <jle`> oh
21:11:57 <names_doug> Just (id 3) ==> Just 3
21:11:58 <jle`> did you figure that out too?
21:12:04 <jle`> id is a function
21:12:06 <MP2E> id just returns whatever it takes as an argument, unchanged
21:12:15 <jle`> id = (\x -> x)
21:12:20 <jle`> (\x -> x) 3 = 3
21:12:26 <names_doug> ah, I think I see now
21:12:47 <jle`> it's just a normal function :)
21:12:51 <names_doug> id is (\x -> x)
21:12:53 <jle`> you put in the 3 where the x is
21:13:00 <jle`> yeah.  well, there's syntactic sugar for it
21:13:10 <jle`> id x = x is syntactic sugar for x = (\x -> x)
21:13:12 <jle`> er
21:13:14 <jle`> id = (\x -> x)
21:13:18 <notthemessiah> id's not just any function, the only function polymorphic for all types
21:13:27 <names_doug> ahh, there we go. that makes it all clear now
21:13:32 <jle`> i meant that it doesn't receive any special syntax ;)
21:13:51 <MP2E> good point, it's the only function that can fit 'forall a. a -> a'
21:13:56 <jle`> you can understand it without any extra tools than you'd use from understanding normal functions
21:14:27 <names_doug> seeing it as a lambda helps, thanks
21:14:33 <jle`> np :)
21:14:34 <dfeuer> MP2E, undefined fits there too! undefined < undefined -> undefined
21:14:52 <notthemessiah> correction: id is the only function that satisfies the type a -> a where a is any type
21:14:54 <monochrom> usually, undefine doesn't count
21:15:32 <notthemessiah> oh, didn't see what MP2E typed
21:15:48 <dfeuer> Yeah, and I wrote that wrong anyway.
21:15:57 <dfeuer> I'm a little wonked.
21:16:24 <MP2E> I tried to be explicit about universal quantification :P
21:16:38 <MP2E> undefined -> undefined works too ? even if it's forall a?
21:16:52 <jle`> undefined -> undefined is the same as a -> a
21:17:04 <jle`> if you mean forall undefined . undefined -> undefined
21:17:06 <dfeuer> MP2E: I wrote that wonky! But \_ -> undefined is what I meant.
21:17:09 <jle`> it's just a type variable
21:17:11 <jle`> :)
21:17:17 <dfeuer> Grrrr.
21:17:54 <haasn> > (undefined :: a -> a) `seq` ()
21:17:55 <lambdabot>  *Exception: Prelude.undefined
21:18:18 <haasn> > (\_ -> undefined) `seq` ()
21:18:19 <lambdabot>  ()
21:18:32 <monochrom> it would be a cool April 1st joke if: on April 1st, lambdabot's @undefine command does not delete user definitions, but instead, defines every unused name to undefined.
21:18:55 <jle`> functions evaluating to bottom is one of those really weird things
21:18:56 <haasn> By, of course, enumerating all unused names to L.hs
21:19:04 <joelteon> oh, I thought monochrom meant all possible unused names
21:19:39 <monochrom> well, a finitary implementation has to be smarter than that.
21:19:46 <joelteon> damn
21:19:53 <joelteon> well, it couldn't be that hard. names would have to fit in an IRC message
21:19:58 <joelteon> minus "> "
21:20:12 <joelteon> and there are a finite number of valid identifier characters :)
21:20:23 <haasn> If only @. could be used to compose @define and @fresh
21:20:53 <jle`> even when i try to reason about bottoms and stuff like that, functions being bottom or undefined or non-terminating etc. always throws everything in the air for me
21:21:06 <monochrom> it has to lazily define things. it has to wait for your "> xxx otherwise" command, see that "otherwise" is already in Prelude but "xxx" is not in scope, then go back and define "xxx = undefined", then do your command.
21:24:02 <monochrom> it may be pretty easy to implement. catch a "not in scope" exception, add definitions, try again. repeat until convergence.
21:25:10 <jle`> heh
21:25:56 <haasn> If only it was somehow possible to modify L.hs to import Prelude hiding (undefined), that algorithm would be quite amusing
21:26:06 <haasn> Oh, although it would work fine. undefined = undefined
21:26:46 <jle`> @let undefined = 4
21:26:49 <lambdabot>  Defined.
21:28:00 <zwer> > undefined
21:28:01 <lambdabot>  can't find file: L.hs
21:28:16 <zwer> > 10
21:28:18 <lambdabot>  10
21:28:26 <zwer> thought you killed it
21:28:45 <jle`> > 10 + undefined
21:28:46 <haasn> No, somebody is abusing lambdabot in a different channel
21:28:47 <lambdabot>  *Exception: Prelude.undefined
21:28:48 <haasn> Please stop
21:29:19 <Menina_Brasileir> Olá
21:46:47 <merijn> hmm, anyone know if there's existing cabal hooks for CMake?
21:59:17 * hackagebot linebreak 1.0.0.2 - breaks strings to fit width  http://hackage.haskell.org/package/linebreak-1.0.0.2 (fffaaa)
22:04:17 * hackagebot linebreak 1.0.0.3 - breaks strings to fit width  http://hackage.haskell.org/package/linebreak-1.0.0.3 (fffaaa)
22:39:21 <t011> Hi, I'm having a problem compiling hakyll in a sandbox. The pandoc build fails along the way.
22:40:26 <t011> I can patch up the code, but I'm having a difficult time figuring out how to restart compilation.
22:54:54 <kwos> hello!
22:55:43 <jedai42> kwos: welcome
22:58:22 <dfeuer> What's the deal with this weird FFI build error when I try to build GHC?
22:58:40 <kwos> I have been banging my head against the wall all day yesterday because of this error
22:58:43 <kwos> /tmp/pkgConf-tf-random-09.5: hGetContents: invalid argument (invalid byte sequence)
22:59:02 <kwos> have you guys seen it?
22:59:13 <merijn> kwos: Sounds like corrupted file/wrong encoding issue
22:59:16 <kwos> (when building tf-random)
22:59:30 <kwos> merijn: yeah I've seen SO on that, I've set LANG to C.UTF-8
22:59:33 <kwos> that didn't help
22:59:59 <kwos> works fine on my Mac but I don't deploy on OS X :S wish I could LOL
23:00:31 <merijn> kwos: Try setting LANG and LC_ALL to "en_US.UTF-8" and LC_CTYPE to "UTF-8"
23:01:26 <kwos> merijn: okay, let me try.. but stupid question, I only have C and C.UTF-8 locales.. do you know OTTOYH how to build/get others?
23:02:05 <kwos> damn cabal hell makes me seriously consider abandoning Haskell for production... even though it is my favourite language
23:02:09 <merijn> No idea, depends on your distro (I'm assuming you're using linux, because I don't know any other OS silly enough not to install locales)
23:02:31 <kwos> merijn: no worries, I'll google that up
23:02:52 <kwos> merijn: I'm building a docker image so I'm on Ubuntu, god knows how to do anything in it... I'm a Mac ;)
23:03:01 <merijn> I'm really curious where everyone is picking up the term "cabal hell" and decides that it applies to their issue, actual cabal hell has been gone for a good year or two...
23:03:16 <joelteon> nix has been around for longer than that...
23:03:39 <merijn> nix?
23:03:41 <jedai> this issue doesn't appear to have anything to do with Cabal either
23:03:54 <jedai> merijn: the functional package manager
23:04:07 <merijn> nix has nothing to do with the solution to cabal hell
23:04:20 <merijn> Because "cabal hell" has nothing to do with "my package doesn't build"
23:04:48 <kwos> joelteon: Docker shoudl in theory work just fine
23:04:49 <jedai> merjin : Well it can have this consequence
23:04:55 <joelteon> what is cabal hell then
23:05:03 <kwos> joelteon: the thing is that I can't even find a _single_ set of deps that works okay
23:05:15 <joelteon> uhh, nix supports jailbreak though..
23:05:19 <kwos> joelteon: so building anything involves a lot of selective applications of --allow-newer
23:05:25 <joelteon> so i think that DOES fix cabal hell
23:05:38 <merijn> joelteon: "cabal hell" is when, years ago, cabal didn't warn about "force-reinstalls" but would just silently upgrade installed libraries, thereby corrupting the package database and silently breaking installed libraries
23:05:44 <joelteon> oh okay
23:05:47 <jedai> kwos: the problem you described doesn't seem to have anything to do with deps
23:05:49 <joelteon> i understand
23:06:04 <kwos> well the tf-random is another problem
23:06:09 <kwos> I have a small app
23:06:12 <merijn> kwos: Which library are you trying to install?
23:06:14 <kwos> it has ridiculous number of dependencies
23:06:29 <merijn> kwos: Have you looked into stackage?
23:06:34 <kwos> it's so insane that it makes me swoon... like 300 packages for a small RESTful app using Silk's rest
23:06:43 <kwos> merijn: yeah didn't work out of the box it's on my list for later
23:07:38 <kwos> at the end of the day it reads a string over a socket and returns a string
23:07:48 <kwos> over 300 packages to achieve that...
23:07:53 <merijn> Really?
23:07:58 <merijn> That doesn't sound right...
23:08:05 <kwos> complicated trading engine written in C++ at work has only four or five external deps
23:08:28 <merijn> kwos: I'm curious which dependencies you have that require so much...
23:08:56 <jedai> kwos: well obviously the deps are not there for the part you describe but rather to handle the middle part...
23:08:58 <merijn> kwos: In general haskell packages tend to have more dependencies, because there's more generic libraries that are useful in a lot of situations. But 300 deps strikes me as absurd
23:09:07 <kwos> merijn: cat cabal.config | wc -l 253
23:09:16 <kwos> (253 is the result)
23:09:21 <kwos> okay I was off by 50 ;)
23:09:23 <merijn> kwos: Have you tried figuring out where they're coming from?
23:09:25 <jedai> kwos: because you can "reads a string over a socket and returns a string" without quitting base
23:09:35 <merijn> i.e. which package are you depending on that pulls in so much gunk?
23:10:10 <kwos> jedai: yeah of course... all I'm saying is that it has become considerably more difficult these days to manage that complexity
23:10:14 <merijn> jedai: Well, doing so efficiently requires at least, network, bytestring, attoparsec/binary and something like pipes/conduits, but still that's far from 253 :)
23:10:15 <kwos> incidental complexity
23:10:29 <kwos> merijn: which require lots of stuff on their own
23:10:35 <dfeuer> merijn, this build error is driving me nuts. Can you help? It keeps saying libffi/stamp.ffi.static-shared.install exists, but libffi/build/inst/lib/libffi.a does not.
23:10:39 <merijn> kwos: Can you lpaste your cabal file?
23:10:49 <dfeuer> Is suggests removing the .install thing, but that doesnt help.
23:11:05 <merijn> dfeuer: I haven't build ghc since before 7.8 and the whole linking change
23:11:37 <dfeuer> Hrrr. I wonder if anyone nows.
23:11:54 <jedai> merijn: ok, but that's not just to accomplish the simple task described but doing it very efficiently while handling some protocols (network is necessary though)
23:12:23 <merijn> I'm so happy new versions of network will get rid of the parsec dependency
23:14:04 <kwos> merijn: http://lpaste.net/111331
23:14:14 <kwos> merijn: slightly edited
23:14:28 <kwos> merijn: let me try your suggestion re tf-random... brb
23:16:20 <merijn> kwos: That's pulling in a whole ton more than just "reading a string from the network and returning a string", though
23:18:20 <kwos> merijn: agree... I'm saying that in most languages I work with you wouldn't see such a huge blow up of deps... Haskell community seems to favour small packages and that gets unmanageable at some point
23:18:41 <kwos> merijn: honestly it makes me think twice of choosing Haskell for any production stuff and that's a sad thought
23:19:40 <merijn> kwos: Sure, but apparently you added all these dependencies for a reason, no?
23:23:19 <kwos> merijn: LOL obviously for a reason
23:23:25 <kwos> merijn: what's your take on managing this?
23:23:36 <kwos> merijn: this is the first sizeable Haskell app I want to deploy
23:23:42 <kwos> and writing was the easy part
23:23:47 <merijn> kwos: tbh, I don't know as I've never written anything with so many dependencies...
23:23:55 <kwos> buidling and deploying is taking more than development
23:24:13 <kwos> so you have this awesome productive language
23:24:45 <kwos> but so what if you spent twice as much time just fighting cabal ;)
23:24:52 <kwos> merijn: I have another app with even more deps!
23:24:54 <kwos> :D
23:24:58 <vanila> yeah ive had a lot of trouble with cabal recently
23:24:59 <kwos> so my hope is docker
23:25:03 <vanila> i dont remember it being this bad
23:25:20 <MP2E> I use nix to avoid cabal problems
23:25:59 <vanila> nix seems really cool
23:26:02 <vanila> wish i knew how to use it
23:26:37 <MP2E> it's a bit trickier than I'd like too. NixOS is the simpler way of using Nix, but NixOS itself is a steep learning curve :P
23:26:37 <lostman> I'm trying to build something that depends on hxt. hxt will only compile with my set of dependencies if I give it 'network-uri' flag. I tried putting it in flags in cabal.config but that is only passed to the package that I invoke cabal install with. So when I do cabal install foo, foo gets network-uri flag but if foo depends on hxt, hxt won't. The only way
23:26:38 <lostman> out of this seems to be to split the build into two: first cabal install hxt and then cabal install foo. is there any other way?
23:27:21 <vanila> MP2E, I did set up a nixos VM but I felt a bit lost inside it, really like the concepts esp. functional package manger
23:28:08 <MP2E> vanila: I know what you mean, I actually had to try NixOS 3 times for it to finally stick.. And it wasn't exactly easy. I think my problem is that I was trying to control the system via terminal commands, but you really need to embrace using Nix for *everything*
23:28:37 <kwos> vanila: I'll sure check it out
23:28:49 <vanila> interesting :) I wonder if I can set up a dedicated machine for experimenting
23:28:56 <MP2E> Also it adds a few new choices to package management you didn't have before: for instance a question I get a lot is 'What do I use? nix-env, configuration.nix or nix-shell to install packages?'
23:29:01 <MP2E> and the only good answer is 'It depends' :P
23:29:17 <MP2E> the added complexity sounds bad at first but it allows for much finer grained package managemnet
23:29:33 <vanila> I get the impression that it fits well with the haskell mindset though
23:29:38 <MP2E> It really does :>
23:30:59 <gamegoblin> I have a multi param typeclass defined as `class Game a b` with a member function `moves :: a -> [b]` . I have an instance of this, Game TicTacToe TicTacToeMove. Game also has a member method called `newGame :: a` .  In a program, I am trying to instantiate a TicTacToeGame. When I call `moves` on it, wanting to get a list of TicTacToeMove, I get a big error about "Could not deduce (Game TicTacToe b0)". Ideas?
23:31:55 <mauke_> yes, newGame can't be used
23:32:05 <kwos> merijn: worked for me with tf-random... I wonder why en_US made the difference, since I had UTF-8 encoding before too
23:32:05 <mauke_> its type doesn't mention b
23:32:08 <kwos> merijn: thanks!
23:32:22 <gamegoblin> maaku: how do you think I can change this?
23:32:30 <vanila> oh geez the unicode symbols in .cabal files breaking installation
23:32:33 <vanila> that is so silly
23:32:38 <vanila> I run into that alot
23:33:37 <merijn> kwos: hGetContents decides how to decode based on the locale
23:34:00 <merijn> kwos: So if the locale is not right it can't read the source file
23:34:42 <merijn> Maybe the source has unicode characters in it and that's why it fails
23:35:33 <gamegoblin> maaku: Can you not have methods in a multi param type class that don’t mention all types?
23:36:12 <mauke_> gamegoblin: only if the unmentioned types can be deduced in another way
23:36:32 <gamegoblin> Ah, I remember now, I can do the | a -> b thing or whatever
23:36:56 <gamegoblin> Functional dependencies
23:46:40 <kwos> merijn: ah, I see. Thanks anyway!
23:47:22 <vanila> is there any easy way to display a graph nicely layed out with some haskell command?
23:50:22 <oakwhiz> vanila: look at the plot package
23:51:58 <oakwhiz> vanila: there's also diagrams and gloss
23:52:24 <vanila> oh great thank you!
23:54:22 <benzrf> bye
23:58:03 <dmwit> I feel like certain tools should really do away with locale-specific encodings and just declare that UTF8 (say) is The Encoding.
23:59:55 <lessless> hi folks! how to print a sum of two integers: let sum' x y = show x+y giving an error
