00:00:53 <splintax> it doesn't require it, i am currently running it in a haskell sandbox
00:01:42 <lostman> start with a fresh sandbox, install yesod, freeze the dependencies
00:02:13 <splintax> s/haskell sandbox/cabal sandbox/
00:02:28 <lostman> if you don't keep your dependencies frozen they will rot :P
00:04:50 <dhrosa> lostman: ihaskell dosn't even install in a sandbox
00:05:51 <tdammers> yesod is kind of fragile when it comes to dependencies
00:06:27 <tdammers> I guess stackage is just one way of dealing with that
00:07:32 <sgronblo> tdammers: but why is it fragile?
00:08:07 <tdammers> sgronblo: it has a lot of deep dependencies, and some of those have seen some breaking changes lately
00:08:20 <tdammers> at least that's what I figured
00:08:40 <tdammers> it builds fine against a fresh sandbox, and it did so in the past
00:08:50 <agatam> so, speaking of ihaskell -- it gives me exactly the error described in https://github.com/gibiansky/IHaskell/issues/283 .. am I really supposed to change it manually? (I did run cabal update, mind you)
00:09:00 <sgronblo> my cabal install for a yesod inited directory seems to not be going anywhere for the last 20 minutes.
00:09:16 <tdammers> but updating from an older sandbox, cabal would run into dependency conflicts that it couldn't figure out
00:09:19 <eazar001> sgronblo: you are doing `cabal sandbox init` prior to an install right?
00:09:34 * hackagebot haskanoid 0.1.2 - A breakout game written in Yampa using SDL  http://hackage.haskell.org/package/haskanoid-0.1.2 (IvanPerez)
00:09:41 <sgronblo> eazar001: no sandbox
00:10:03 <sgronblo> the official instructions using stackage dont mention a sandbox
00:10:14 <eazar001> sgronblo: yea you're gonna need sandboxes if you wanna survive in haskell
00:10:17 <eazar001> (this is my opinion)
00:10:34 <eazar001> it's kind of sloppy
00:10:36 <eazar001> for a solution
00:10:41 <eazar001> but it really gets the job done
00:12:15 <eazar001> hmmm, regarding stackage ... actually i can't speak on that
00:12:35 <eazar001> i wish i knew more to help you (AFAIK, yesod installed correctly for me in the past with a sandbox)
00:12:40 <tdammers> why are sandboxes sloppy?
00:12:46 <sgronblo> yeah it worked for me at home too
00:12:53 <eazar001> not sloppy, just kind of "duplicating"
00:12:59 <tdammers> well, yes
00:13:06 <eazar001> of course there are ways to minimize this duplication
00:13:07 <splintax> tdammers: because you end up with > 500mb of artifacts for every project
00:13:11 <eazar001> but still, it duplicates
00:13:19 <tdammers> but from a KISS point of view, it's better than the alternative
00:13:32 <eazar001> you mean ... the past?
00:13:37 <eazar001> oh yea, anything beats that
00:13:43 <sgronblo> interesting now this xss-sanitize which just didnt work at all earlier today seems to be downloading...
00:14:02 <sgronblo> however, "Base.hsc:103:10: fatal error: 'pcre.h' file not found"...
00:14:05 <sgronblo> so broken
00:14:06 <joelteon> just use nix, it has proper sandboxing
00:14:12 <joelteon> without duplication
00:14:19 <tdammers> I mean changing ghc to somehow facilitate multiple versions of libraries built against multiple versions of their dependencies built against multiple versions of *their* dependencies, etc.
00:14:31 <joelteon> nix does that
00:14:41 <tdammers> hmm, well
00:15:03 <lostman> sgronblo: that means you need libpcre installed (c library)
00:15:12 <tdammers> I guess the reason C/C++ get away with it is because as long as you're ABI compatible, you can stick to a relatively small set of versions
00:15:37 <tdammers> but ghc basically static-links everything
00:15:49 <tdammers> (at least by default)
00:15:55 <splintax> also you can usually get away with using 5 year old C/C++ libraries packaged by your OS
00:16:03 <eazar001> i do dynamic when i can
00:16:05 <splintax> well, maybe not usually, but often
00:16:11 <Saizan> the problem is not static linking, it's that there's no stable API for a given package
00:16:26 <Saizan> because of aggressive cross-module inlining
00:16:49 <Saizan> *ABI
00:23:42 <Haskellfant> I started playing around with threads and so far it seems to work pretty well, but before making it more complex, i'd like to know if there are some big mistakes or a wrong design in my code. it would be great if someone could spare a minute to quickly look over it and give me feedback http://lpaste.net/111515
00:24:54 <Haskellfant> one thing i already found is, that I could replace my manual forkFinally and the TMVar with Async and waitAnyCatch
00:29:35 * hackagebot hmatrix 0.16.0.6 - Numeric Linear Algebra  http://hackage.haskell.org/package/hmatrix-0.16.0.6 (AlbertoRuiz)
00:30:06 <tdammers> Saizan: true. s/Static-linking/inlining/
00:36:53 <aleator> Do type holes work at all with where statements?
00:37:30 <aleator> uc :: (a->b->c) -> ((a,b) -> c); uc f = g where g = _   suggests t as the type of the hole
00:39:59 <xnyhps> aleator: The type of a hole is only inferred from the function it is in, not from how that function gets used.
00:41:02 <aleator> xnyhps: So basically, it cannot be used in the definitions of local bindings then?
00:43:36 <xnyhps> aleator: Yeah
00:44:14 <xnyhps> Well, the type suggested isn't /wrong/, it's just too polymorphic to be useful.
00:45:43 <aleator> xnyhps: I'm just trying to figure out an useful workflow for the holes. I guess I have to put a hole in the main expression, read off the type, and then make a local binding with explicit type signature
00:45:59 <aleator> .. and continue the process with the local.
00:47:48 <Hijiri> I want to make a stats tracker for a game as a web application
00:48:06 <Hijiri> There's an existing interface where a client reporter program POSTs the data to an address
00:48:25 <Hijiri> and then people can go on the site and check match history of people, ranking, etc.
00:48:30 <Hijiri> what would be the best web framework to use?
00:49:37 * hackagebot unix-time 0.3.4 - Unix time parser/formatter and utilities  http://hackage.haskell.org/package/unix-time-0.3.4 (KazuYamamoto)
00:49:42 <sgronblo> lets try installing yesod yet again... X_X
00:49:51 <unsymbol> don't do it!
00:49:58 <unsymbol> ;)
00:50:55 <tdammers> Hijiri: the popular ones are Yesod, Snap, Happstack, and Scotty (in order of size, complexity, and abstraction)
00:51:42 <tdammers> yesod is a full-blown framework that does "everything" for you, including persistence, templates, type-safe routing, and a million other things
00:52:57 <tdammers> scotty is really simple; it's little more than a convenience wrapper around Warp that adds some useful monad stack, routing, and a few convenience methods
00:53:05 <tdammers> the others are somewhere in between
00:54:07 <Hijiri> which would you recommend for a project of this size?
00:54:31 <tdammers> it's not so much about the size, really
00:55:21 <tdammers> if you know your http etc. already, and you need full control without any pre-made assumptions, then scotty is probably your best bet
00:55:28 <tdammers> especially for the webservice part
00:55:50 <Hijiri> I've never developed a web service before
00:55:54 <utdemir> Hi. Do you know how can I make a tasty test suite fail as soon as any test fails?
00:56:01 <sgronblo> tdammers: what would you use for persistence?
00:56:20 <tdammers> sgronblo: not sure... I've used Postgres and SQLite for most stuff so far
00:56:39 <tdammers> but that's more because I'm really familiar with the relational model and like it quite a bit
00:57:05 <tdammers> file-based storage would be another thing I'd consider, depending on the project
00:57:07 <sgronblo> i only tried it a little bit so far, but i found persistent's API pretty great. except that it is not relational.
00:57:11 <Hijiri> I used acid-state for persistence in a non-web application before, because I don't know SQL
00:57:20 <lpaste> Haskellfant revised ‚ÄúNo title‚Äù: ‚Äúthread experiments‚Äù at http://lpaste.net/111515
00:57:27 <Hijiri> If you use acid-state you would have to make your own relational data structure
00:57:36 <Haskellfant> updated, now it's using async
00:57:45 <tdammers> acid-state is something I've been wanting to experiment with for quite a while, but I have neither time nor a suitable project to try it on
00:58:03 <Hijiri> I don't know if I'm using it to its full potential
00:58:10 <Hijiri> I just used it for permanent storage in a chat bot for a game
00:58:22 <Hijiri> so that I didn't have to manage file i/o
00:58:25 <tdammers> another thing worth considering might be a very KISS approach: just dump data in JSON files :x
00:58:52 <tdammers> but then, once you need to search and sort across files, you might as well use some sort of database
00:59:05 <tdammers> (relational or not)
00:59:38 <Hijiri> so if I wanted to use templates and scotty, I would have to implement template myself (or use some preexisting template lib)
00:59:50 <Hijiri> forgot a question mark
00:59:51 <tdammers> the latter, most likely, yes
01:00:19 <tdammers> writing your own template library is fun, but waaaaay beyond the scope of something like this
01:00:34 <lpaste> wei2912 pasted ‚ÄúFizzBuzz‚Äù at http://lpaste.net/111521
01:00:45 <tdammers> there are enough libs to choose from, and they all work pretty well standalone
01:00:53 <Hijiri> alright
01:00:54 <wei2912> any suggestions for the piece of code that lpaste referenced? :)
01:00:57 <wei2912> very small*
01:01:09 <tdammers> (actually, coding against blaze-html directly isn't too shabby)
01:02:00 <modicasio> ***new to haskell ... just read about it ... where should i start ***
01:02:12 <Haskellfant> modicasio: read learnyouahaskell
01:02:15 <Haskellfant> @where lyah
01:02:15 <lambdabot> http://www.learnyouahaskell.com/
01:02:28 <modicasio> on it ... thanks
01:03:13 <wei2912> also, how could i write bubblesort in haskell?
01:03:49 <Haskellfant> wei2912: i would have written the last line as map (putStrLn . fizzbuzz) [1..100] but apart from that it looks pretty good
01:03:59 <funrep_> have hackage stopped building docs for good or is it just temporarily?
01:04:18 <Hijiri> for each iteration, match (x:y:zs) and see if x y are equal, and then run the same thing on y:zs
01:04:23 <Hijiri> u
01:04:26 <wei2912> Haskellfant: alright, thanks! i followed the advice in https://stackoverflow.com/questions/5289779/printing-elements-of-a-list-on-new-lines which said to use "unlines"
01:04:31 <Hijiri> actually you need to check order, I'm sutpid
01:04:38 <Hijiri> if x is bigger run it on x:zs
01:04:43 <Hijiri> if it isn't run it on y:zs
01:04:48 <Hijiri> and then put the other one in front
01:05:00 <sgronblo> and now my yesod install is stuck again
01:05:34 <Hijiri> so y : sortiter (x:zs) when x is bigger, x : sortiter (y:zs) when y is bigger
01:05:38 <jle`> Haskellfant: do you mean mapM ?
01:05:40 <jle`> _
01:05:45 <Haskellfant> jle`: ofc
01:05:55 <Haskellfant> sry
01:05:57 <jle`> mk, just a note for wei2912 :)
01:06:02 <jenspeter> funrep_: I think temporarily - somehow asked on reddit not so long ago
01:06:16 <wei2912> ah, that explains why it didn't work
01:06:27 <jle`> wei2912: that's good for a first fizzbuzz :)
01:06:33 <jle`> for someone just starting haskell
01:06:49 <jle`> i don't see anything too stylistically off
01:07:22 <wei2912> jle`: alright, thanks
01:07:31 <jle`> some things to consider to explore for fun
01:07:35 <jle`> right now it's a little ad-hoc
01:07:51 <jle`> what if i asked you, instead of just 3 and 5, to do fizz/buzz/baxx on 3, 5, and 7?
01:08:02 <jle`> and fizzbaxx on multiples of both 3 and 7, etc.
01:08:10 <sgronblo> im going crazy...
01:08:10 <wei2912> hmm
01:08:15 <jle`> or if i gave you four numbers and four words?
01:08:28 <jle`> could you write a program that could be easily generalized to arbitrary numbers and words?
01:08:46 <funrep_> anyone know a convinient way to download and build X package's docs?
01:08:52 <jle`> if you keep your current form, your program length would actually grow O(n^2) for the number of multiples :P
01:09:00 <wei2912> true
01:09:05 <jle`> because you'd have to put in not only the numbers, but every combination of multiples
01:09:22 <sgronblo> Base.hsc:103:10: fatal error: 'pcre.h' file not found, what should I do about this?
01:09:23 <jle`> can you make a program that's easier to modify?
01:09:29 <jle`> this might be a bit advanced for beginner haskell
01:09:33 <jle`> but...just something to think about :)
01:09:37 <wei2912> jle`: giving that a try, thanks for the task :)
01:10:06 <funrep_> or rather, how do i build only the docs of a project
01:10:15 <jle`> wei2912: if you're in the middle of a haskell course, don't get too involved if it takes too long :) feel free to move on
01:10:34 <wei2912> alright :)
01:10:39 <jle`> however, when i see a "fizzbuzz" challenge, i usually see it as a challenge for this kind of generalization
01:11:01 <wei2912> i'm not in the middle of any course, just reading learn you a haskell and exploring haskell along the way
01:11:04 <jle`> ah
01:11:06 <jle`> i call that a course :)
01:11:29 <wei2912> i don't need to meet any datelines though
01:12:26 <jle`> have you gone over `Maybe` yet?
01:12:53 <wei2912> no
01:13:30 <oyugik> Hello all
01:13:39 <jle`> ah. okay :)  there's a popular solution that makes use of Maybe to make the answer pretty simple, but if you're not there yet, you can do it without Maybe as well
01:13:44 <jle`> hi oyugik !
01:14:00 <oyugik> newbie here, any great tut for learning haskel
01:14:07 <jle`> @where lyah
01:14:08 <lambdabot> http://www.learnyouahaskell.com/
01:14:23 <oyugik> hi jle
01:14:27 <jle`> ^^
01:14:31 <jle`> that's a nice one :)
01:14:35 <merijn> jle`: You can do an even nicer one with the monoid instance of functions :)
01:14:46 <jle`> there's also bitemyapp's guide, which is on the topic of #haskell-beginners
01:15:07 <jle`> merijn: :D indeed
01:15:20 <oyugik> hehehe
01:15:35 <oyugik> :)
01:17:21 <oyugik> guys also what are the most popular uses for the haskell
01:17:27 <oyugik> asking for a friend
01:17:58 <jle`> hmmmmm
01:18:42 <jle`> the haskell is often used for heavy numerical stuff like in finance and in scientific computing.  also for a lot of web servers.  and parsers.  and compilers
01:19:12 <merijn> @quote Jafet research.language
01:19:13 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatics, phone apps, and web services.
01:19:30 <jle`> haha
01:19:53 <wei2912> how do i do pattern matching with a function that i declared using "where"?
01:20:27 <jle`> wei2912: anything in a where follows the same declaration syntax as at the top level (except with layouting)...not sure what your question is
01:20:31 <merijn> wei2912: The same way as in any other function?
01:20:40 <wei2912> okay, thanks!
01:20:55 <jle`> you can also always do pattern matching using case too if you are averse to pattern matching in declarations
01:21:02 <merijn> wei2912: Technically the "top-level" is one huge where clause
01:21:14 <merijn> wei2912: "module Foo where {- definitions here -}"
01:21:23 <jle`> i think pattern matching in declaration syntax is actually desugared to case statements anyway
01:21:24 <merijn> wei2912: where clauses in functions behave the exact same
01:21:27 <jle`> merijn: that's cute :P
01:21:54 <merijn> wei2912: In fact, functions you define in a where close can have their own where clause (and you keep adding more and more)
01:22:09 <oyugik> thanks, alot. so if I need to carry financial risk/credit related tasks. Whats better to use Erlang/Haskell?
01:22:32 <wei2912> merijn: ah, thanks for that info :)
01:23:51 <merijn> jle`: You should read the lexical syntax section of the haskell report it's filled with cute tidbits :)
01:24:04 <merijn> Like whitespace escapes/multiline strings
01:24:17 <merijn> > "whooooo \             \ hooo"
01:24:20 <lambdabot>  "whooooo  hooo"
01:24:20 <jle`> they're technically different where's though, right?
01:24:46 <jle`> syntax-wise
01:24:53 <merijn> jle`: The module one is different only in that it can have data/class/instance declarations (I might be forgetting some things)
01:25:29 <jle`> if only we could have scoped data/class/instances
01:25:31 <jle`> :)
01:27:28 <jle`> > "he\                                                                \llo"
01:27:30 <lambdabot>  "hello"
01:28:32 <oyugik> hello
01:31:06 <vanila> http://johnmacfarlane.net/pandoc/diagram.png holy ***
01:32:34 <jle`> vanila: are these new?
01:32:43 <jle`> i don't remember these even a few months ago
01:32:49 <vanila> there's so many!
01:38:29 <sgronblo> any idea why i would be seeing this pcre.h missing error? "Preprocessing library pcre-light-0.4.0.3... NL Base.hsc:103:10: fatal error: 'pcre.h' file not found"?
01:40:46 <shachaf> Maybe you don't have pcre.h.
01:41:11 <shachaf> It's the same solution that you would use if you got that error trying to compile a C program.
01:45:55 <sgronblo> shachaf: ok I think I made the problem go away
01:49:27 <sgronblo> but... for some reason the build seems to have gotten stuck again...
01:50:18 <sgronblo> nooooooooooooooooooooooooo
01:50:31 <sgronblo> now im back to this mysterious undownloadable file...
01:50:41 <splintax> which one?
01:51:25 <sgronblo> how cute, it works with https
01:51:47 <sgronblo> this one http://hackage.haskell.org/package/xss-sanitize-0.3.5.4/xss-sanitize-0.3.5.4.tar.gz
01:52:15 <sgronblo> how would i fix it so that cabal uses https for it instead of http?
01:53:36 <sgronblo> wget gets the http response header with 200 ok
01:54:43 <sgronblo> so maybe something has gone wrong with those cloudflare settings?
01:54:47 <sgronblo> who should i complain to?
01:55:18 <sgronblo> it seems other co-workers of mine are having trouble accessing the file as well
01:55:51 <wei2912> how do i define a function that takes in a list of tuples?
01:56:12 <sgronblo> tuples of what?
01:56:17 <splintax> f :: [(a, b)] -> c
01:56:27 <sgronblo> what he said
01:56:35 <sgronblo> modify a and b accordingly
01:56:48 <wei2912> thanks
01:56:50 <sgronblo> splintax: can you access the xss-sanitize file?
01:57:02 <pjdelport> :t map fst
01:57:04 <lambdabot> [(b, b1)] -> [b]
01:57:28 <splintax> sgronblo: yep that link works fine for me. i'm sure there is a way to get cabal to install it from a local copy
01:58:34 <sgronblo> splintax: where are you located?
01:59:03 <oyugik> guys I need to carry financial risk/credit related tasks. Whats better to use Erlang/Haskell?
01:59:15 <oyugik> please advice
01:59:35 <tdammers> oyugik: picking a programming language depends on more factors than you have given
02:00:18 <sgronblo> use PHP
02:01:13 <tdammers> I said "programming language", didn't I
02:01:20 <ysz> oyugik, erlang is not match for numerical anyway
02:01:28 <dcoutts_> oyugik: Erlang's speciality is concurrency and distribution, rather than tricky calculations
02:01:55 <dcoutts_> sgronblo: so what is the symptom exactly?
02:02:14 <splintax> sgronblo: australia
02:02:14 <sgronblo> dcoutts_: https://github.com/haskell/hackage-server/issues/266
02:02:56 <tdammers> all else being equal, I'm tempted to say Haskell myself, yes
02:02:57 <sgronblo> so how do I install this package manually?
02:03:15 <tdammers> static type checks are a big plus for missing-critical calculations
02:03:22 <tdammers> correctness guarantees and all that
02:03:23 <sgronblo> i would say it all depends on whos doing the coding and what their skills are?
02:03:35 <dcoutts_> sgronblo: can you include in the report what the 301 redirection is exactly
02:03:51 <sgronblo> dcoutts_: sure
02:03:57 <dcoutts_> sgronblo: and if you can, include the wget verbose log
02:04:23 <dcoutts_> sgronblo: cheers
02:04:26 <splintax> sgronblo: cabal install xss-sanitize-0.3.5.4.tar.gz
02:04:38 <splintax> once you have copied the .tar.gz to the current directory
02:05:19 <splintax> that's not a "manual" install as such, it's just telling cabal to install it ("automatically") from a local tarball instead of looking up the latest version in hackage
02:05:55 <sgronblo> dcoutts_: added the cabal command output
02:06:07 <sgronblo> do you still think the wget output is necessary?
02:06:25 <dcoutts_> sgronblo: I see yes, thanks. The wget would be a useful comparison, even if it just indicates it's the same.
02:07:17 <dcoutts_> sgronblo: it's useful for us to discount the possibility that it's the fault of our http client impl
02:09:58 <sgronblo> dcoutts_: just added it
02:10:15 <sgronblo> not sure how --verbose the output is
02:10:33 <sgronblo> ah "the default is verbose"
02:11:40 <sgronblo> actually now I noticed something new
02:12:24 <sgronblo> when i do wget, it doesnt finish, but when i ctrl-c interrupt the process a .tar.gz is in the directory but it only contains 8192 bytes and seems to be incomplete
02:19:19 <lpaste> wei2912 revised ‚ÄúGeneral FizzBuzz‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/111523
02:20:01 <wei2912> jle`: finished it, mind taking a look? :)
02:20:11 <kazagistar> oh, I love when we play the "sharing our fizzbuzz" game
02:21:26 <kazagistar> http://9m.no/ùí∞‚çü
02:22:23 <wei2912> kazagistar: was that for a code golf? :P
02:22:36 <kazagistar> it was for... self amusement?
02:22:51 <wei2912> haha
02:24:04 <sgronblo> oh my lord... i finally was able to build my yesod app!
02:24:16 <sgronblo> everything was because of that bad xss-sanitize file
02:24:51 <sgronblo> so it was not because of yesod, cabal, stackage, or haskell :)
02:25:26 <tdammers> xss-sanitize file?
02:25:38 <tdammers> I smell a bad bad approach to XSS prevention
02:26:31 <vanila> tdammers++
02:26:54 <splintax> s/file/package
02:27:27 <Arahael> So, what's the ideal, high level method of interacitng with a database in haskell?
02:27:37 <tdammers> ah
02:27:48 <tdammers> still a weak approach IMO, but oh well
02:28:19 <splintax> it's a weak approach to extract XSS prevention code into a library?
02:29:18 <tdammers> no
02:29:35 <tdammers> it's a weak approach to accept user-provided HTML and try to filter out the "dangerous" stuff
02:30:01 <tdammers> I'm looking at the xss-sanitize source as we speak
02:30:17 <tdammers> it doesn't look like it really delivers IMO
02:30:51 <tdammers>  <a href="javascript:do_dangerous_stuff()">
02:31:04 <Arahael> Easy solution: Don't run thirdparty injectibles in your site.
02:31:18 <sgronblo> well yesod already is supposed to use typesafe template interpolation so using a slightly unsafe xss library probably cant make it worse
02:31:33 <tdammers> it can
02:31:55 <tdammers> the only reason why you'd use something like xss-sanitize is because you need to include user-provided HTML in your response
02:31:56 <vanila> adding a strange library that you can only justify on the basis that it does nothing isn't good security
02:32:14 <tdammers> if you don't interpolate HTML into the response, then you don't need XSS protection
02:32:55 <tdammers> if anything, xss-sanitize would have to descend into attributes and sanitize their *values* as well
02:33:28 <tdammers> but even something as benign as <img src="http://some_external_server.com/foo/bar.jpg"> is a security problem
02:33:54 <tdammers> because 1) it allows whoever controls some_external_server.com to track your visitors
02:34:02 <Arahael> tdammers: It was recently found (last year?) that merely accepting xml was a security problem.
02:34:03 <jle`> wei2912: nice :)
02:34:43 <tdammers> and 2) some browsers have a flaw where they render anything as HTML that contains a sufficient amount of what looks like valid HTML, completely ignoring Content-type headers and file extensions
02:34:45 * hackagebot hspec-wai 0.5.0 - Experimental Hspec support for testing WAI applications (depends on hspec2!)  http://hackage.haskell.org/package/hspec-wai-0.5.0 (SimonHengel)
02:34:53 <tdammers> *cough*IE*cough*
02:34:59 <jle`> wei2912: stylistic point, you can use pattern matching instead of fst
02:35:09 <jle`> especially if you use both fst and snd
02:35:25 <tdammers> so the attack is to make a tiny JPG, fill the description with malicious HTML, serve it as JPG
02:35:44 <tdammers> IE detects the HTML and renders it... including scripts and everything
02:35:48 <jle`> wei2912: also, you can use guards instead of if/thens in your case
02:35:57 <jle`> wei2912: also, (== "") is null from Prelude
02:36:17 <tdammers> Arahael: depends on your parser, and whether you allow external entities
02:36:24 <wei2912> jle`: i see, thanks
02:36:36 <wei2912> jle`: what should be the proper way to check for an empty string?
02:36:38 <jle`> but yeah, great job :D
02:36:40 <jle`> null
02:36:42 <tdammers> Arahael: but in general, passing XML through is just as dangerous as passing HTML through, yes
02:36:45 <jle`> null = (== "")
02:36:56 <jle`> er, null = (== []), but same thing
02:36:59 <jle`> > null "hello"
02:37:01 <lambdabot>  False
02:37:02 <jle`> > null ""
02:37:04 <lambdabot>  True
02:37:20 <Arahael> tdammers: I'm trying to find it, it was exploiting a particular behaviour when loading and using dtd's.
02:37:27 <slehuito> Hi there,
02:37:34 <slehuito> I can write "let f1 f t = filter even $ enumFromTo f t", and "f1 2 5" works as expected (i.e. produces "[2,4]")
02:37:36 <vanila> Arahael, XFI?
02:37:41 <slehuito> But I don't manage to write f1 in a point-free way, not matter how many parens, "$" or "." I use...
02:37:44 <vanila> someone read googles /etc/passwd with that
02:37:48 <slehuito> I know I don't practice Haskell enough, so I keep stumbling on trivial things like that :-(
02:37:53 <slehuito> Any help would be greatly appreciated!
02:37:56 <tdammers> Arahael: external entity hack, I guesss
02:38:24 <Arahael> Indeed - found it. XXE: http://www.ubercomp.com/posts/2014-01-16_facebook_remote_code_execution
02:38:25 <jle`> slehuito: point-free isn't always a simple or useful or good thing to do
02:38:35 <jle`> so if you can't pf some function, that shouldn't be something to be concerned about :)
02:38:57 <jle`> in this case, you might benefit from dropping one point and keeping the other
02:39:05 <jle`> f1 f = filter even . enumFromTo f
02:39:15 <wei2912> <jle`> wei2912: also, you can use guards instead of if/thens in your case -> which part where you referring to?
02:39:17 <jle`> but i think in this case, keeping both points is nice enough
02:39:24 <jle`> wei2912: lines 2-4
02:39:27 <wei2912> wait a moment, let me switch to my client
02:39:28 <wei2912> alright, thank
02:39:30 <wei2912> s*
02:39:42 <Arahael> I'm looking for a haskell database API, one that allows me to be somewhat database agnostic, yet not require a static mapping between haskell code and sql. (Ie, I don't want code generation)
02:39:45 * hackagebot hspec-wai-json 0.5.0 - Testing JSON APIs with hspec-wai  http://hackage.haskell.org/package/hspec-wai-json-0.5.0 (SimonHengel)
02:39:45 <jle`> fizz a xs | null result = ...
02:39:49 <Arahael> Something like C#'s linq in haskell would be awesome.
02:40:17 <tdammers> yup, external entities
02:40:27 <ysz> hm i got 404 http://darcs.haskell.org/ghcBuilder/uploads/
02:40:51 <jle`> wei2912: wb
02:41:06 <jle`> fizz' a (factor, str) = ... for my comment on pattern matching
02:41:13 <kazagistar> Arahael: out of curiosity, why not code generation/template haskell?
02:41:21 <jle`> we usually only use fst/snd when we specifically need functions
02:41:27 <jle`> like for passing into a higher order function
02:41:35 <Arahael> kazagistar: Because I want to be able to change the database and have the application cater for it.
02:41:37 <jle`> especially in this case where you fst and snd the same tuple in different places
02:41:48 <jle`> pattern matching once does the work once :)
02:42:04 <wei2912> jle`, i see
02:42:33 <jle`> nice job on partially applying fizz' a and concatmapping
02:42:36 * jle` claps
02:43:27 <wei2912> jle`, thanks :)
02:44:05 <slehuito> jle`: thanks. For the record, how you you go about pf-writing function "f1"?
02:44:30 <wei2912> jle`, made some amendments at http://lpaste.net/111523 ; is there anything i missed out?
02:44:33 <jle`> slehuito: some people like to define f .: g = \x y -> f (g x y), and you could do filter even . enumFromTo f
02:44:39 <wei2912> wait, whoops
02:44:48 <kazagistar> slehuito: lambdabot will pf things for you, if you ask her with @pf
02:44:52 <jle`> slehuito: other than that...you can see the ugly output that @pl pops out :)
02:45:04 <sgronblo> yes my yesod default site is up and running!
02:45:07 <wei2912> alright, fixed it
02:45:12 <wei2912> sgronblo, congrats! :)
02:45:18 <jle`> @pl \f t -> filter even (enumFromTo f t)
02:45:18 <lambdabot> (filter even .) . enumFromTo
02:45:21 <jle`> ^^ case in point
02:45:29 <kazagistar> er, right, pl
02:45:38 <kazagistar> "point-less"
02:46:25 <jle`> heh
02:46:33 <jle`> i like to think it's a pun on "pointless"
02:46:46 <jle`> wei2912: looks good to me :)
02:47:27 <wei2912> jle`, okay, thanks for the help :)
02:47:39 <jle`> np!
02:48:00 <kazagistar> wei2912: I think you have the same error I do, not sure though... does [(3, "Nonempty"), (5, "")] work as expected?
02:48:33 <jle`> ;)
02:48:46 <jle`> doubtless discovered through...fizzbuzz testing?
02:48:51 <jle`> ...
02:48:55 <jle`> bad pun, sorry
02:49:04 <wei2912> kazagistar, probably not, let me take a look
02:49:58 <wei2912> kazagistar, yep, it doesn't
02:50:06 <kazagistar> its the downfall of the concatMap method of generic fizzbuzz, where "blank string" is undetected by the numbering
02:50:22 <jle`> it's the in-band control problem
02:50:26 <jle`> but
02:50:45 <kazagistar> honestly, I never fixed it and just declared it to be "as intended" :P
02:50:54 <jle`> allowing an empty string as the inpjut in the first place requires sort of a twisting of the problem statement :P
02:50:58 <wei2912> ^^
02:51:40 <jle`> this is something that ... a nice type system could be leveraged to help you with
02:51:41 <jle`> ;D
02:51:59 <jle`> (story is to be continued)
02:52:02 <wei2912> how do you write something like bubblesort in haskell?
02:52:03 <kazagistar> still, doing a filter, then map, then select number/strings, then concat is the simple fix
02:52:40 <kazagistar> wei2912: are you looking for mutable arrays, or just the list version?
02:53:11 <jle`> lists aren't really designed to be sorted, anyway.  but you can ask the problem about immutable arrays/vectors, too
02:53:20 <wei2912> kazagistar, mutable arrays, i guess
02:53:48 <wei2912> i have a feeling that writing the list version will be painful
02:53:54 <tdammers> can always do it as an exercise
02:54:19 <tdammers> a naive version shouldn't be that painful though
02:54:39 <kazagistar> dunno, list might not be that bad I think, even with the "dont start from the front" efficiency constraints
02:55:05 <jle`> list might not be too bad, but if you need to sort a list in real life, there's a good chance that you're using the wrong data structure :)
02:55:12 <kazagistar> you bubble the first item once, the second item twice, the third item three times, etc
02:55:54 <Haskellfant> is there a better way to detect a connect loss than using timeout with a high enough value?
02:57:37 <kazagistar> wait no, I am doing it all wrong, derp nvm me
02:59:47 <kazagistar> wei2912: http://hackage.haskell.org/package/array-0.5.0.0/docs/Data-Array-MArray.html ?
03:00:10 <Arahael> jle`: I sort lists all the time.
03:00:46 <jle`> i do too...but mostly out of convenience
03:01:14 <Arahael> Same, actually. :)
03:01:18 <wei2912> kazagistar, hmm
03:01:20 <Arahael> And it just looks better.
03:01:54 <jle`> hopefully we can begin to change that with OverloadedLists being out now :)
03:02:28 <jle`> lists no longer have a monopoly on [1,2,3] syntax
03:02:32 <Arahael> jle`: I'm still at the 'hello world' stage so can't comment.
03:02:49 <jle`> :)
03:04:25 <kazagistar> naive list version of bubble sort is actually really straightforward
03:04:36 <tdammers> yes
03:04:41 <tdammers> just wrote one
03:04:47 * hackagebot eternal 0.0.9 - everything breaking the Fairbairn threshold  http://hackage.haskell.org/package/eternal-0.0.9 (Heather)
03:04:49 * hackagebot yesod-auth-hashdb 1.3.1 - Authentication plugin for Yesod.  http://hackage.haskell.org/package/yesod-auth-hashdb-1.3.1 (paulrouse)
03:04:53 <wei2912> what's it like?
03:04:53 <hpc> sortBy compare = head . head . dropWhile (isn't unsafeCoerce . drop 1) . group . iterate go -- easy!
03:04:53 <kazagistar> same
03:05:17 <hpc> (don't actually use that)
03:05:38 <tdammers> "isn't"?
03:05:41 <tdammers> wow
03:06:50 <kazagistar> look at first to items, return smaller : sort (bigger:restOfList)
03:06:56 <kazagistar> *two
03:07:31 <wei2912> wouldn't that work for only one loop?
03:07:40 <wei2912> s/work for/be/
03:07:59 <kazagistar> right, so then you just repeat it length list times :P
03:08:11 <wei2912> :P
03:09:02 <kazagistar> unless you want some of the actual efficiencies of bubblesort, like detecting that it is sorted and stopping
03:09:45 <tdammers> the recursion already takes care of repeating it length times
03:09:58 <hpc> my understanding is that insertion sort is going to be faster for every input
03:10:40 <tdammers> hpc: equally fast for an already-sorted list, at least if you add all the optimizations
03:10:44 <jle`> you can iterate and then dropWhile not sorted
03:11:07 <jle`> sort checking is O(n) so it shouldn't add to the asymptotic complexity...
03:11:14 <jle`> :D
03:11:46 <tdammers> well, for an already-sorted list, the fastest you can get is O(n) anyway
03:12:04 <kazagistar> unless you marked it as sorted :P
03:12:37 <tdammers> in which case the sorting algorithm is completely irrelevant because you'll be bypassing the sort call entirely
03:13:42 <kazagistar> well, you might have something like... um... "53 items were prepended since the last sort"
03:14:50 <tdammers> in that case, you could take all but the first 53 items, put them in the front slot, then continue inserting the rest as per insert sort
03:15:00 <tdammers> or you could apply 53 rounds of bubbling
03:16:25 <kazagistar> I think timsort is one of the more interesting sort algorithms due to the fairly impressive handling of partially sorted data
03:17:14 <tdammers> I'm still wondering whether I agree with wikipedia's description of bogosort
03:17:59 <wei2912> how do you do a while loop in haskell?
03:18:01 <tdammers> "throw a deck of cards in the air and pick it up, repeat until it is sorted" is the informal description, but then it proceeds to describe it as a series of random swaps
03:18:05 <johnnyrichard> Has anyone ever developed a restful web application using haskell?
03:18:16 <tdammers> wei2912: short answer: you don't
03:18:16 <jle`> @let bl (x0:x1:xs) | x0 <= x1 = first (x0:) (bl (x1:xs)) | otherwise = ((x1:) *** (||True)) (bl (x0:xs)); bl xs = (xs, False)
03:18:19 <lambdabot>  Defined.
03:18:38 <johnnyrichard> tdammers: recursion
03:18:42 <jle`> wei2912: for now, as a new haskell user, use recursion :)
03:19:39 <tdammers> what I mean by that is that you don't implement a while loop in the strict sense, because that would require mutable state
03:19:45 <tdammers> (or some other effect)
03:20:03 <jle`> > fst . head . dropWhile snd $ [5,2,8,7,10,6,3,9,4,1]
03:20:06 <lambdabot>  No instance for (GHC.Show.Show a0)
03:20:06 <lambdabot>    arising from a use of ‚ÄòM499608966176878298420380.show_M4996089661768782984...
03:20:06 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
03:20:06 <lambdabot>  Note: there are several potential instances:
03:20:06 <lambdabot>    instance [safe] GHC.Show.Show
03:20:18 <jle`> > fst . head . dropWhile snd . iterate bl $ [5,2,8,7,10,6,3,9,4,1]
03:20:21 <lambdabot>  Couldn't match type ‚Äò[a]‚Äô with ‚Äò([a], GHC.Types.Bool)‚Äô
03:20:21 <lambdabot>  Expected type: ([a], GHC.Types.Bool) -> ([a], GHC.Types.Bool)
03:20:21 <lambdabot>    Actual type: [a] -> ([a], GHC.Types.Bool)Couldn't match expected type ‚Äò([a...
03:20:21 <lambdabot>              with actual type ‚Äò[t0]‚Äô
03:20:29 <jle`> er
03:20:42 <jle`> > fst . head . dropWhile snd . iterate bl . (,True) $ [5,2,8,7,10,6,3,9,4,1]
03:20:45 <lambdabot>  Couldn't match type ‚Äò[a]‚Äô with ‚Äò([a], GHC.Types.Bool)‚Äô
03:20:45 <lambdabot>  Expected type: ([a], GHC.Types.Bool) -> ([a], GHC.Types.Bool)
03:20:45 <lambdabot>    Actual type: [a] -> ([a], GHC.Types.Bool)
03:20:49 <jle`> sorry
03:20:54 <tdammers> johnnyrichard: not *strictly* restful, but serving JSON resources over HTTP is pretty straightforwards with Scotty
03:20:58 <wei2912> alright
03:21:42 <jle`> > fst . head . dropWhile snd . iterate (bl . fst) . (,True) $ [5,2,8,7,10,6,3,9,4,1]
03:21:46 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
03:22:31 <jle`> stops after a pass with no swaps
03:22:43 <jle`> ok i have been nerdsniped enough today, time to sleep v.v
03:23:26 <lpaste> wei2912 pasted ‚ÄúStuck Bubblesort‚Äù at http://lpaste.net/111531
03:23:27 <kazagistar> I visit #haskell for the purpose of being nerdsniped :P
03:23:36 <wei2912> haha
03:23:53 <jle`> [x] ++ xs = x:xs, btw
03:24:01 <wei2912> btw, i tried implementing bubblesort but it gets stuck
03:24:08 <wei2912> looping forever
03:24:35 <kazagistar> wei, you can pattern match 2 things from a list in one expression
03:24:45 <jle`> so the `bl` that i put up there earlier might be a nice framework if you look at the type signature of everything
03:25:41 <wei2912> kazagistar, jle` right, forgot abt that
03:26:18 <jle`> also in this process i have rediscovered that const True = (|| True)
03:27:09 <johnnyrichard> Is a good idea make haskell application with *do* key
03:27:19 <jle`> and id = (|| False)
03:27:51 <kazagistar> johnnyrichard: are you asking about "do notation"?
03:28:04 <johnnyrichard> kazagistar: yes!
03:30:25 <kazagistar> johnnyrichard: using it fairly often for monadic things is good, but you shouldn't force non-monadic things into it I think
03:31:01 <wei2912> can we use guards to set the value of a variable?
03:31:47 <jle`> do you mean define/declare a definition?
03:32:04 <wei2912> a definition?
03:32:50 <jle`> when you say x = 4, you're "defining" x to be 4.
03:33:03 <jle`> you're saying "whenever you see x in this program, and this definition is in scope, you can basically subsitute it for 4"
03:33:18 <johnnyrichard> kazagistar: thanks, I need read more about monad.
03:33:21 <wei2912> i see
03:33:26 <jle`> "set" implies some there's some sort of timing involved
03:33:33 <jle`> x was 3, and then...afterwards...it was set to 4
03:33:50 <wei2912> i mean define a variable to be a value based on a condition
03:33:57 <jle`> yeah
03:34:02 <jle`> x | something = 4
03:34:06 <jle`>   | otheriwse = 5
03:34:22 <Arahael> jle`: In other words, you want a literal constant?
03:34:29 <wei2912> thanks, i was confused because ghci said there was a parse error
03:34:30 <johnnyrichard> kazagistar: haskell is hard to work with IO
03:35:10 <jle`> i don't really agree :)
03:35:21 <jle`> i think it just takes some getting used to, if you are used to a different language
03:35:29 <tdammers> johnnyrichard: not really - just somewhat different than in an imperative language
03:35:30 <Flonk> I have the weirdest issue right now. http://lpaste.net/111532
03:35:40 <Flonk> (It's heavily golfed, disregard that)
03:35:47 <kazagistar> its hard to get used to not having state just kinda hanging around everywhere
03:35:55 <johnnyrichard> kazagistar: monad is the answer?
03:36:03 <Flonk> if you load this up in ghci and do `take 20 pig`, you'll see a list of positive numbers
03:36:28 <Flonk> if you uncomment the last line and load it again, doing `take 20 pig` will a different list.
03:36:31 <lpaste> wei2912 revised ‚ÄúStuck Bubblesort‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/111531
03:36:40 <jle`> first class statements are the answer
03:36:54 <wei2912> updated the code, program remains stuck when i pass an array that isn't sorted
03:36:57 <wei2912> list*
03:37:01 <jle`> monadic interfaces make them easier to work with
03:37:17 <kazagistar> johnnyrichard: its more like a unified interface for a number of answers to a number of problems
03:37:17 <tdammers> johnnyrichard: IO being a Monad is just a convenient coincidence
03:37:24 <Flonk> (and you can rename p2 to anything, it isn't referenced anywhere. I don't get it at all..)
03:37:58 <mbuf> if lists [] are an instance of the Functor class, what does [] a mean in the Haskell context if we replace f with [] for lists in the fmap definition (fmap :: Function f => (a -> b) -> f a -> f b
03:38:07 <mbuf> '[] a'
03:38:20 <wei2912> ah, figured it out
03:38:55 <Iceland_jack> mbuf: '[] a' is the same as the type '[a]'
03:39:00 <epta> Trying to install 'streaming-commons' package, getting 'Win32File.hsc:34:19: fatal error: Share.h: No such file or directory' error. Here is a full log https://gist.githubusercontent.com/dmalikov/935e4f4b2855b4bebf89/raw/a3f4496385619a18948cb36bac412ba796831b3d/gistfile1.txt
03:39:06 <epta> Any ideas how to fix it?
03:40:15 <mbuf> Iceland_jack, okay
03:40:26 <kazagistar> IO is the solution to the fact that the real world breaks stuff like refferential transparency and functional purity with side effects... just like Maybe is the solution to needing nulls that are tracked by the type system, which also happens to use a similar structure for composability
03:42:01 <johnnyrichard> tdammers: do you know a good article about monad?
03:42:58 <Heather> hi
03:43:01 <Flonk> :t (!!)
03:43:03 <lambdabot> [a] -> Int -> a
03:43:11 <Flonk> @hoogle [a] -> Integer -> a
03:43:14 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
03:43:14 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
03:43:15 <lambdabot> Prelude const :: a -> b -> a
03:43:21 <Heather> is it possible to case x of 1 | 2 -> 3 ?
03:43:33 <Heather> can I have `or` in pattern?
03:43:49 <Heather> just like in F#
03:45:09 <Heather> e.g. if I have 1 -> 3 and 2 -> 3 I want to write 1 | 2 -> 3
03:45:12 <Heather> is that possible?
03:45:25 <jle`> Heather: unfortunately not :/  but you can sort of achieve a similar thing with guards
03:45:37 <Heather> jle` how?
03:45:45 <jle`> not in a pretty way
03:45:57 <jle`> case x of _ | x < 2 -> ...
03:46:20 <jle`> you can proceed to add other matches after the line w/ the guard
03:46:27 <Heather> jle`: is it list comprehenjons?
03:46:35 <jle`> it's guards
03:46:40 <jle`> like with normal functions
03:46:44 <jle`> foo x | x < 2 = ...
03:47:09 <Heather> jle`: looks like list comprehensions
03:47:16 <Heather> but w/o [ ]
03:47:17 <jle`> the branch is only "followed" of the condition is True
03:47:41 <jle`> fac x | x < 2    = 1
03:47:49 <jle`>       | otherwise = x * fac (x - 1)
03:47:57 <jle`> so if x < 2 is true, the output is 1
03:48:01 <silver> Heather, you might find https://www.haskell.org/onlinereport/haskell2010/ useful
03:48:06 <jle`> otherwise, the output is x * fac (x - 1)
03:48:49 <Heather> silver: it's really huge
03:49:04 <jle`> have you read through a haskell introduction in the past?
03:49:08 <Heather> jle`: and there is no ghc extension for it so far?
03:49:10 <jle`> they usually go over function declaration syntax
03:49:15 <jle`> er, declaration syntax
03:49:23 <jle`> and guards and where clauses and stuff like that
03:49:36 <jle`> let me find the relevant LYAH chapter...
03:49:43 <kazagistar> johnnyrichard: some people like the typeclassopedia (http://www.haskell.org/haskellwiki/Typeclassopedia), I felt this one worked well for me (https://www.youtube.com/watch?v=3q8xYFDYLeI), but there are dozens of fairly good monad tutorials if those don't click right
03:49:48 <Heather> jle`: I saw lyah, yes
03:49:51 <jle`> http://learnyouahaskell.com/syntax-in-functions#guards-guards
03:50:54 <jle`> so, a "| something =" or "| something ->" says "only go down this branch if `something` evaluates to True"
03:51:34 <johnnyrichard> kazagistar: thanks for help me.
03:52:33 <Heather> jle`: I see so I do >>= \case w | w `elem` ["Y", "y"] ->
03:53:40 <Heather> jle`: that will be great to have yet another extension for that case I think
03:53:56 <jle`> yeah :/
03:54:56 <kazagistar> Heather: if that is your particular case, you might be able to use "toLower" instead to normalize input before using case?
03:55:28 <Heather> kazagistar: I doubt if that is really better solution
03:56:20 <Heather> kazagistar: first because it will add more working with string, import data char, use map and to work with string I need to be in monad so I need to add another binding and so on...
03:56:38 <jle`> case (toLower w) of 'y' -> ...
03:57:03 <Heather> well w is string
03:57:07 <jle`> hm
03:57:46 <jle`> case (toLower w) of "y" -> would work too
03:57:48 <jle`> but
03:57:55 <jle`> in any case, we usually don't mind an extra import
03:58:21 <jle`> and naming things ain't always so bad :)
03:58:58 <kazagistar> haskell code almost always has like at least a dozen imports, reuse is a positive thing
03:59:03 <Heather> jle`: it will be ss <- getLine; let sl = map toLower ss; case sl of ...
03:59:30 <Heather> sle`: I don't think it's major benefit
03:59:33 <kazagistar> isolating "normalizing cases" and "picking which action to take" seems like a good way to structure code
03:59:51 <jle`> ss <- getLine; case map toLower ss of -> ...
03:59:57 <jle`> well, yeah :/
04:00:09 <jle`> if you really want to put an anonymous function there, it's not going to be too pretty
04:00:10 <Heather> maybe but also do before it
04:00:46 <Heather> getLine >>= case "Y" | "y" ->
04:00:49 <jle`> you can also pull out the function and name it, and do foo =<< getLine
04:01:13 <jle`> but there aren't too many facilities for anonymously doing it in a satisfying way at this point
04:01:36 <jle`> i've actually found that i don't actaully lose too many anonymous functions in my own code...i am an obsessive namer >_>
04:02:00 <jle`> but yeah, someone here might know of an extension in the works if there is one
04:09:44 <marvimias> Is it possible to evaluate imports in haskell?
04:10:47 <kazagistar> marvimias: evaluate in what sense?
04:11:10 <shiona> whatever that means I believe GHC API might be the first thing to takea look at
04:11:12 <marvimias> kazagistar, Like with hint or mueval
04:13:43 <aloiscochard> what's the best way to "clean"/"reset" my global packages?
04:13:56 <aloiscochard> also, is it possible to prevent install of global packages thru cabal?
04:14:21 <marvimias> kazagistar, shiona, http://hackage.haskell.org/package/mueval-0.9.1.1/docs/src/Mueval-Interpreter.html#line-56
04:14:33 <marvimias> installedModulesInScope := False
04:18:44 <kazagistar> aloiscochard: cabal sandboxes are a good way to install packages, since they let you reset and isolate easily
04:18:58 <aloiscochard> kazagistar: sure I use them a lot
04:19:03 <aloiscochard> kazagistar: but how to force their usage
04:19:10 <aloiscochard> I mean I don't want to install globally by mistake
04:19:15 <aloiscochard> I want to disable it
04:19:21 <kazagistar> ah, gotcha, hmm
04:19:44 <kazagistar> you could probably revoke write permissions on the folder they install to? :P
04:20:17 <aloiscochard> good idea!
04:20:23 <aloiscochard> ty
04:20:41 <aloiscochard> mmm... what about " require-sandbox: True" ?
04:21:06 <aloiscochard> looks like it does just what I want
04:21:26 <kazagistar> that sounds far too elegant and simple, clearly unix hacking is the way to go
04:22:37 <aloiscochard> :-D
04:27:01 <larsrh> I have an invocation of "ghc" with some custom paths (-i and -outputdir), and it succeeds with the "-c" flag, but without it, it can't find an import
04:27:10 <larsrh> How can I debug that situation?
04:27:22 <larsrh> It
04:27:35 <larsrh> It's looking for some .hs files, but I want it to use the pre-compiled .o files
04:31:01 <larsrh> What I don't understand is why it is looking for .hs in the first place; I didn't specify --make
04:33:32 <aloiscochard> larsrh: just a random thought, but maybe that could be related to dynamic (or not) linking
04:33:49 <aloiscochard> I'm not sure that will help you, but I try anyway ;-)
04:44:55 * hackagebot sloane 1.9.2 - A command line interface to Sloane's On-Line Encyclopedia  of Integer Sequences  http://hackage.haskell.org/package/sloane-1.9.2 (AndersClaesson)
04:48:47 <wz1000> Does GHC evaluate expressions on compile time?
04:49:13 <Iceland_jack> wz1000: It performs some constant folding if that's what you're asking
04:50:08 <Iceland_jack> wz1000: You can read this thread www.reddit.com/r/haskell/comments/1kpu1h/can_haskell_programs_be_compiled_such_that_the/
04:50:17 <wz1000> Iceland_jack: thanks
04:50:35 <Iceland_jack> If you really want to make sure something is evaluated at compile time you use Template Haskell
04:51:54 <larsrh> aloiscochard: I'm not trying to link dynamically
04:52:25 <Iceland_jack> (But Template Haskell is not a beginner topic)
04:53:36 <wz1000> Can't it try to auto evaluate expressions at compile time? There can be a time limit to how long it tries to evaluate each expression, so that compilation is guaranteed to finish in a finite and reasonable amount of time.
04:53:58 <Iceland_jack> wz1000: That is literally what the reddit thread discusses :)
04:54:49 <wz1000> Iceland_jack: They keep mentioning the halting problem. I don't think that that is a problem in this cae
04:54:53 <wz1000> *case
04:55:23 <Iceland_jack> There are multiple problems with just trying to evaluate things and using a timeout
04:56:14 <wz1000> Anything that doesn't involve IO should be able to be evalutated at compile time because of haskells immutability.
04:57:14 <wz1000> s/evalutated/evaluated
04:57:15 <sagittarian> wz1000, in a real program, almost everything depends ultimately on some form of IO
04:57:54 <Iceland_jack> wz1000: Like I said, GHC already performs constant folding of expressions like '2 + 10'
04:58:03 <Axman6> wz1000: it's pretty rare that you won't have some inout from IO though, and when you don't, we'd like to think that our compilers will always terminate
04:58:05 <simpson> > sum [1..] -- wz1000: Here's an example from that Reddit discussion.
04:58:10 <lambdabot>  mueval-core: Time limit exceeded
04:58:25 <wz1000> simpson: do what lambdabot did :P
04:58:48 <Iceland_jack> but it's a very tricky territory, you need to take Haskell's evaluation model into account (and laziness and partiality)
04:58:51 <simpson> wz1000: I'm just pointing out that immutability doesn't help here.
04:59:20 <simpson> wz1000: There are actually several algorithms (derivative parsing, cyclic graph traversal) that crucially rely on the compiler *not* performing this kind of evaluation.
04:59:58 <Iceland_jack> wz1000: There is something called supercompilation (that the reddit thread discusses), it's a very interesting idea and there is an implementation for GHC but it's quite slow
05:00:09 <wz1000> simpson: The compiler can stop evaluating the expression if it takes too long
05:00:10 <simpson> Actually, I guess that cyclic graph traversal covers everything I was thinking of. Derivative parsing, pretty-printing, equality comparisons, etc.
05:00:44 <simpson> wz1000: Hm. It should probably be number of expressions or number of instructions, right, not wall time; otherwise, you won't have deterministic compilation.
05:01:18 <simpson> But do all expressions take the same amount of time to compile? It might be a problem if there's some sort of pathological input that takes more time to timeout!
05:04:15 <vanila> hi
05:04:57 * hackagebot sloane 1.9.3 - A command line interface to Sloane's On-Line Encyclopedia  of Integer Sequences  http://hackage.haskell.org/package/sloane-1.9.3 (AndersClaesson)
05:06:11 <Haskellfant> I started playing around with threading in haskell, but I'm not sure if I get it right. I would appreciate if someone could take a quick look at my code and tell me if it contains major mistakes especially in the use of the async library: http://lpaste.net/111536
05:16:55 <kazagistar> simpson: interesting, so it would require really carefully understanding the performance of GHC, so that we ensure that the deterministic measure used reflects wall time fairly well
05:22:54 <jrc12`> if i want to annotate a monoid with information of whether its empty or not, what would be the best way to go about doing that?
05:24:41 <ysz> jrc12`, I'm subscribing to hear answer.
05:24:58 * hackagebot objective 0.2 - Extensible objects  http://hackage.haskell.org/package/objective-0.2 (FumiakiKinoshita)
05:25:36 <vanila> jrc12`, a monoid cannot be nonempty
05:27:30 <Iceland_jack> They probably mean 'mempty'
05:27:54 <jrc12`> yep meant mempty
05:27:58 <Iceland_jack> I.e. 'Sum 5' would be non-empty
05:28:16 <tdammers> jrc12`: do you want to annotate the type to indicate that it cannot be empty? Or do you want to provide a method that tells you whether a value of that Monoid is empty?
05:29:18 <jrc12`> I would like to have a function such as getRes :: Monoid m => m -> a
05:29:31 <jrc12`> that only works on m's that are non empty
05:29:39 <vanila> jrc12`, You cannot do that
05:29:51 <Iceland_jack> jrc12`: What would you do for the 'Endo' monoid?
05:29:59 * hackagebot hsdev 0.1.2.1 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  http://hackage.haskell.org/package/hsdev-0.1.2.1 (AlexandrRuchkin)
05:30:01 * hackagebot call 0.0 - The call game engine  http://hackage.haskell.org/package/call-0.0 (FumiakiKinoshita)
05:30:04 <Iceland_jack> You'd need to compare functions for equality
05:30:39 <Iceland_jack> You could do something like 'getRes :: (Monoid m, Eq m) => m -> Maybe m' but it's a strange thing to do
05:31:08 <jrc12`> can't you use dependent types or something?
05:31:21 <vanila> jrc12`, you could use dependent types to do this, but haskell doesn't have that
05:31:24 <Iceland_jack> You don't need dependent types for that
05:31:57 <Iceland_jack> but it's still a fairly strange thing to do, the main problem is deciding the equality on monoids
05:33:02 <kazagistar> jrc12`: you could theoretically take an m, and a proof/type that m == mempty or something?
05:33:10 <tdammers> monoids don't require a concept of equality, really
05:33:10 <jrc12`> wait, I'll code up what I'm thinking
05:33:16 <tdammers> Eq and Monoid are orthogonal concerns
05:33:55 <Iceland_jack> You could do basic stuff like 'Foo (Monoid Empty) (Monoid Empty) = Monoid Empty' given mappend, but the other cases don't follow
05:34:33 <prinsen> I am developing a haskell library im planning to release, where would you turn for feedback?
05:34:45 <Iceland_jack> Two non-empty values giving an empty value
05:34:45 <Iceland_jack> > Sum (-2) <> Sum 2
05:34:46 <lambdabot>  Sum {getSum = 0}
05:34:51 <Iceland_jack> Two non-empty values giving an non-empty value
05:34:51 <Iceland_jack> > Sum 2 <> Sum 2
05:34:53 <lambdabot>  Sum {getSum = 4}
05:35:37 <tdammers> maybe the thing you want isn't really a monoid
05:36:00 <Iceland_jack> Yes, it's a peculiar use of monoids
05:37:12 <Iceland_jack> Also consider
05:37:12 <Iceland_jack> :t Endo succ <> Endo pred :: Endo Integer
05:37:13 <lambdabot> Endo Integer
05:37:33 <jrc12`> extract (Nothing <> Just "Result" <> Nothing) == "Result"
05:37:42 <jrc12`> ^is what I would like
05:37:58 <vanila> jrc12`, you can use fromJust for that
05:38:07 <jrc12`> but thats not total
05:38:13 <Iceland_jack> jrc12`: then use Maybe
05:38:14 <vanila> that's riht
05:38:35 <vanila> there is no total function that does what you asked
05:39:03 <Iceland_jack> jrc12`: If you're only thinking of extracting from "Maybe" then it's a much simpler problem though
05:39:12 <Iceland_jack> but I wouldn't advise pushing it to the type level
05:39:26 <jrc12`> how would you do it for just Maybe?
05:39:46 <vanila> jrc12`, Having a well typed program is a good step towards having a correct program, but there will always be facts/invariants about your data that cannot be expressed in the types
05:40:01 <Iceland_jack> Create a new data type, adding a parameter for the "Nothingness" of the data type
05:40:45 <Iceland_jack> and you can have decision functions like
05:40:45 <Iceland_jack>     decide :: Maybe a -> Either (MAYBE NONEMPTY a) (MAYBE EMPTY a)
05:40:45 <jrc12`> You mean treat the nothingness as a valid result?
05:41:14 <Iceland_jack> no just "tagging" Nothing values in the types
05:41:30 <Iceland_jack> but this hardly gives you anything at all
05:42:20 <jrc12`> Yep, its the same as Maybe right?
05:42:50 <vanila> jrc12`, Have I been unclear?
05:43:53 <jrc12`> nope i understood, but I think you can do it :P
05:43:57 <vanila> oh
05:44:10 <vanila> well if you can do it I'd be very surprised
05:45:39 <Iceland_jack>     data MAYBE :: EMPTINESS -> * -> * where
05:45:39 <Iceland_jack>       NOTHING ::      MAYBE EMPTY a
05:45:39 <Iceland_jack>       JUST    :: a -> MAYBE NONEMPTY a
05:45:39 <Iceland_jack> is one way
05:46:18 <kazagistar> ensureProperty :: (a -> Bool) -> (a -> b) -> a -> Maybe b;  nonemptyMonoid = ensureProperty (/= mempty) NonEmpty;
05:46:26 <jrc12`> yep, I was thinking that
05:46:49 <Iceland_jack> Then writing the 'decide' function is trivial
05:46:51 <jrc12`> isnt mempty a function though
05:46:58 <Iceland_jack> mempty is not a function
05:47:51 <Iceland_jack> However, you've just shifted scrutinizing the value from checking if a value is "Nothing" to creating the MAYBE value
05:48:42 <amesha_> does anyone have a recommendation for a genetic algorithm library in haskell?
05:49:27 <Iceland_jack>     extract :: MAYBE NONEMPTY a -> a
05:49:27 <Iceland_jack>     extract (JUST x) = x
05:49:33 <Iceland_jack> where 'extract NOTHING' is a type error
05:50:05 <jrc12`> @tell Iceland_jack yep, exactly what i wanted
05:50:05 <lambdabot> Consider it noted.
05:50:17 <exio4> why @tell?
05:50:21 <vanila> Iceland_jack, but I think the examples you gave earlier mean this doesn't actually help
05:50:24 <srhb> I'm having an issue with fay (using snaplet-fay) that I can't figure out. Here's my error when I try to call fay (with the correct sandboxed package database) http://lpaste.net/111499
05:50:45 <kazagistar> the idea is that you build a wrapper type which guarentees that you checked that the property holds at some point, if by proof at construction, or manually using runtime check
05:50:53 <srhb> I'm not sure how to debug it since fay doesn't have a -v switch
05:50:59 <Iceland_jack> vanila: Which examples? This does work since you can't construct something like 'NOTHING :: MAYBE NONEMPTY a'
05:51:22 <vanila> Sum (-2) <> Sum 2 for example
05:51:30 <Iceland_jack> Right, but that was for monoids in general
05:51:50 <Iceland_jack> this is only for Maybe which is a generate case of lists with length
05:52:15 <kazagistar> the point is, a monoid that guarentees that it is nonempty is not a monad anymore, so the monoid constraint is useless
05:52:17 <Iceland_jack>     data Vec :: Nat -> * -> * where
05:52:17 <Iceland_jack>       Nil  :: Vec 0 a
05:52:17 <Iceland_jack>       Cons :: a -> Vec n a -> Vec (n + 1) a
05:52:26 <kazagistar> *er, middle monad should have been monoid
05:52:49 <vanila> kazagistar, yeah, it can't even be given a monoid instance
05:53:21 <kazagistar> I cant do { NonZeroSum (-1) <>NonZeroSum 1 }
05:53:31 <Iceland_jack> You can if you use existentials
05:54:06 <vanila> Iceland_jack, I don't think existentials make any difference, this is impossible for the reasons you gave earlier
05:54:17 <mr-> Nonempty stuff is a Semigroup, though. Data.Semigroup uses the same operator: <>
05:54:19 <Iceland_jack> You can make an existential out of the Maybe type
05:54:25 <vanila> like, you reduced this to the halting problem
05:54:45 <vanila> that pretty much puts it to rest
05:54:47 <lpaste> ‚Äú_dyrim‚Äù pasted ‚ÄúNo title‚Äù at http://lpaste.net/392364284899753984
05:55:08 <Iceland_jack> Not really, in the general case it's undecidable but it can still be useful to work with some subset of functions operating on monoids or Maybe
05:55:15 <Iceland_jack> but I agree that in this particular case it's not very useful
05:55:38 <kazagistar> or { NonEmpty (Endo (+2)) <> NonEmpty (Endo (-2)) }, even if I could guarentee that NonEmpty wasnt id to begin with
05:55:40 <zereraz> how do I concatenate a string and a number
05:55:43 <_dyrim> Hey, I'm having some trouble with this code (http://lpaste.net/392364284899753984). It's not showing the prompt before waiting for the input, and I'm having some trouble understanding why.
05:55:49 <zereraz> like a number should come between a string
05:55:59 <zereraz> "abc"++n++"def" something like this
05:56:01 <kazagistar> zereraz: make the number a string
05:56:05 * vanila confused about this
05:56:07 <zereraz> kazagistar: how?
05:56:08 <Iceland_jack> Given
05:56:08 <Iceland_jack>     data MAYBE' a where MAYBE' :: MAYBE e a -> MAYBE' a
05:56:08 <Iceland_jack> we can define
05:56:08 <Iceland_jack>     instance Monoid (MAYBE' a) where mempty = MAYBE' NOTHING; ...
05:56:19 <kazagistar> zereraz: show
05:56:26 <zereraz> kazagistar: thanks
05:56:59 <Iceland_jack> So for the 'Maybe' case it's rather straightforward, the existential MAYBE' is equivalent to normal Maybe
05:57:12 <Iceland_jack> But for Endo it's undecidable in general
05:57:36 <vanila> Iceland_jack, MAYBE NONEMPTY is isomorphic to th First monoid?
05:57:50 <vanila> https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Monoid.html#t:First
05:57:59 <Iceland_jack> First can still have an empty result
05:58:22 <Iceland_jack> > getFirst (First Nothing)
05:58:24 <lambdabot>  Nothing
05:58:48 <vanila> the real Maybe monoid has this constraint: Monoid a => Monoid (Maybe a)
05:59:09 <Iceland_jack> Yes that one is pretty weird for historical reasons
05:59:21 <Iceland_jack> But MAYBE NONEMPTY is isomorphic to Identity
05:59:30 <Iceland_jack> making it pretty uninteresting
05:59:31 <kazagistar> (which we all know is silly since it probably should be a semigroup constraint)
05:59:34 <vanila> Identity is not a monoid
05:59:53 <Iceland_jack> That's right, neither is MAYBE NONEMPTY
06:00:33 <vanila> so this data type doesn't solve the problem
06:01:04 <Iceland_jack> It does solve the problem of being able to index the datatype by its emptiness
06:01:32 <Iceland_jack> so you can write functions that are polymorphic over the emptiness, but also functions that depend on the datatype being empty or nonempty
06:01:56 <greeny>  /window 11
06:02:01 <greeny> sry
06:04:19 <vanila> Iceland_jack, isn't this just two separate types, one is () and the other a ?
06:05:02 <Iceland_jack> vanila: It's basically 'Either () a' but as a single type
06:05:18 <Iceland_jack> but it tells you which one it is
06:06:12 <vanila> Can you show me an example of what extra things that GADT allows us to do?
06:06:14 <kazagistar> The problem has to be solved in terms of the goal: is it performance (optimizing out (<> mempty) calls); or is it analysis (count number of mempty)? Those are the only uses I could come up with, and even those seem silly...
06:06:45 <Iceland_jack> vanila: Well, as safe extraction function is one thing
06:06:49 <Iceland_jack> *a safe
06:07:39 <Iceland_jack> I expressed somewhat more involved invariants in the library OrdList in GHC https://ghc.haskell.org/trac/ghc/ticket/8782
06:07:43 <vanila> Iceland_jack, I thnik that's the same as id :: a -> a though
06:07:54 <fppp> can I use fold to do numerical integration on a continuous function somehow?
06:08:24 <Iceland_jack> It's more akin to 'fromJust :: Maybe a -> a' without the partiality
06:08:26 <vanila> i.e. everywhere you have MAYBE NONEMPTY a , just use a isntead
06:08:34 <vanila> and everywhere you have MAYBE EMPTY a use () instead
06:09:08 <Iceland_jack> Yes that's pretty much my point, it doesn't gain you much but it does unify those two things under a common datatype
06:09:32 <vanila> okay
06:10:01 <Iceland_jack> if you want to use 'a' and '()' you'd use something like 'Either a ()' and you can't know which one you have or you have them separate and then you can't write polymorphic functions over the emptiness
06:10:47 <Iceland_jack> This was the exact use case for OrdList but it was actually useful because it was recursively defined in terms of "These two OrdLists must be non-empty"
06:10:58 <Iceland_jack> Which is exactly captured by
06:10:58 <Iceland_jack>   Two  :: OrdList' NonEmpty a -> OrdList' NonEmpty a -> OrdList' NonEmpty a
06:12:11 <kazagistar> fppp: a common misconception of newer haskell users is that haskell is magic... the way you are probably thinking about it is not going to work, since it requires infinite steps?
06:12:50 <Iceland_jack> You can then create a type family and then you can define a nice '<>' function, but it must be defined over the existential version
06:12:50 <Iceland_jack>     EMPTY ‚óá EMPTY = EMPTY
06:12:50 <Iceland_jack>     a     ‚óá b     = NONEMPTY
06:14:16 <kazagistar> fppp: if you wanna do integration, you probably wont be able to get around either doing it using an algebraic representation, or using numerical methods
06:14:20 <fppp> kazagistar: yeah that's the thing.. on one level it does seem like fold or something like it could be used to integrate a continous function, on the other hand that also seem to require infinite steps, so I was wondering if there is some tricks that could be done or if there is some fold implementation that does some tricks to make it work
06:14:21 <vanila> Iceland_jack, that is interesting! looking at OrdList
06:14:30 <Iceland_jack> But you can however define your own mappend as
06:14:31 <Iceland_jack>     mappend :: MAYBE m1 a -> MAYBE m2 a -> MAYBE (m1 ‚óá m2) a
06:14:31 <Iceland_jack>     mappend = ...
06:14:51 <Iceland_jack> which doesn't require an existential and does reflect the emptiness in the type
06:14:56 <Iceland_jack> vanila: thanks
06:15:03 * hackagebot codex 0.2.0.1 - A ctags file generator for cabal project dependencies.  http://hackage.haskell.org/package/codex-0.2.0.1 (aloiscochard)
06:15:16 <hseg> Edward Yang claims here: http://blog.ezyang.com/2014/09/open-type-families-are-not-modular/ that globally unique type family instances are needed for type safety. Can someone explain this?
06:15:44 <kazagistar> fppp: numerical methods (approximations) can be implemented using folds...?
06:15:45 <hseg> Similarly, what's so bad about removing globally unique typeclass instances?
06:15:50 <Iceland_jack> (there should be a Monoid constraint on that 'a')
06:16:13 <Iceland_jack> Or a semigroup really :)
06:16:39 <fppp> kazagistar: hm, right, I suppose that would work for approximations and otherwise I'd have to use an algebraic representation
06:19:03 <Iceland_jack> (mappend' NOTHING NOTHING :: Monoid a => MAYBE EMPTY a)
06:19:14 <CXXVIIta> What would be an elegant way to iterate over nested tuple based types based on a custom datastructure?
06:19:14 <Iceland_jack> anyway
06:19:35 <CXXVIIta> pattern matching 9+ elements seems a bit silly
06:19:45 <Iceland_jack> CXXVIIta: look into "lens"
06:20:52 <Iceland_jack> CXXVIIta: https://github.com/ekmett/lens
06:20:58 <CXXVIIta> cheers
06:21:26 <hseg> Can someone explain why type class/family instances must be globally unique?
06:21:33 <Iceland_jack> > view (_2._1) (1, ("hello", "world"))
06:21:34 <lambdabot>  "hello"
06:21:53 <zereraz> Hello, what is wrong here http://lpaste.net/111537
06:22:13 <zereraz> it is saying 1 more argument
06:22:20 <Iceland_jack> zereraz: You need one more argument to "IO"
06:22:21 <Iceland_jack> line 7
06:22:46 <Iceland_jack> zereraz: should be
06:22:46 <Iceland_jack>     choiceHandle :: Int -> ()
06:22:46 <Iceland_jack>     choiceHandle n = print n
06:22:52 <Iceland_jack> oops, *IO ()
06:22:53 <zereraz> oh
06:23:01 <kazagistar> hseg: if you don't want globally unique ones, you can just use records and pass the same information in explicitly. Or are you looking for "compiler reasons"?
06:23:06 <hseg> zereraz: IO on its own is malformed. Just like saying choiceHandle :: Int -> Maybe is malformed.
06:23:14 <hseg> kazagistar: compiler/language reasons.
06:23:36 <hseg> kazagistar: e.g. Why can't I define two different instances of Monoid for Integers?
06:23:57 <zereraz> ok thanks !
06:24:07 <kazagistar> hseg: and how do you want it to pick which one to use?
06:24:08 <zereraz> hseg: malformed?
06:24:37 <Iceland_jack> zereraz: The error messages can be quite helpful :) 'Expecting one more argument to `IO'' tells you what you need to do
06:25:03 * hackagebot tasty-ant-xml 1.0.0.11 - Render tasty output to XML for Jenkins  http://hackage.haskell.org/package/tasty-ant-xml-1.0.0.11 (OliverCharles)
06:25:07 <hseg> kazagistar: Possibilities: Use the currently in-scope instance, allow named instances and pass explicitly, ....
06:26:16 <zereraz> Iceland_jack: I forgot (), I am writing haskell again after a long time
06:26:40 <hseg> zereraz: IO :: * -> *, which means that it needs to get a concrete type to become a concrete type. (->) :: * -> * -> *, which means it gets two concrete types and returns a concrete type. Thus, Int -> IO is as malformed as 2 + id.
06:27:16 <zereraz> hseg: ok I am a beginner so can't understand most of this stuff.
06:27:38 <hseg> zereraz: It's OK, let's go through this step by step.
06:27:51 <zereraz> hseg: what do you mean by concrete?
06:28:04 <eikke__> can't you have '2 + id' if there'd be a Num instance for (->) ?
06:28:13 <hseg> zereraz: Concrete = there are terms of that type.
06:28:23 <kazagistar> zereraz: it is similar to lists... a list is not enough to be a type, you need a "List of Integers" or "List of characters", otherwise you just have a "List of ____"
06:28:40 <kazagistar> *not enough to be a concrete type
06:28:45 <hseg> zereraz: So Int, Char, ..., [Int], ..., Maybe Int
06:29:13 <hseg> eikke__: Yeah. Replace that by [] ++ id, then.
06:29:30 * eikke__ ducks
06:29:34 <r444> http://lpaste.net/111538 can someone point me in right direction with aeson instance deriving?
06:30:03 * hackagebot codex 0.2.0.2 - A ctags file generator for cabal project dependencies.  http://hackage.haskell.org/package/codex-0.2.0.2 (aloiscochard)
06:30:17 <zereraz> ok got it
06:30:33 <solarus> r444: did you want to write deriving (Show, Generic)?
06:30:37 <zereraz> thanks!
06:30:44 <kazagistar> eikke__: with comments like "Num instance for (->)" you would make a great haskell compiler :P
06:30:50 <hseg> zereraz: Pleasure
06:31:32 <zereraz> ok what if I am doing io in between the function and want to return a list
06:31:38 <zereraz> I am taking an Int
06:31:38 <bergey> hseg: Passing the method dictionary all the time is basically not having type classes (as a language feature).  Scala does the multiple named instances thing, and it makes reasoning about types that depend on classes much harder. edwardk gives some examples in the thread: http://www.reddit.com/r/haskell/comments/1pjjy5/odersky_the_trouble_with_types_strange_loop_2013/
06:31:42 <zereraz> then doing IO
06:31:47 <zereraz> then returning a list
06:31:47 <eikke__> kazagistar: haha. Even then, it'd be impossible, since kind of (->) is * -> * -> *, and Num wants a *
06:31:51 <zereraz> so type should be?
06:32:05 <exio4> (-> r) ?
06:32:22 <danilo2> Hello! I just moved from parsec over trifecta and noticed that the parser compiels very, very long. while the parsec version took about 5-10 seconds, trifecta version compiles about 1 minute. Do you know why this happens or if can I make it faster somehow?
06:32:23 <zereraz> do we have to write IO?
06:32:25 <zereraz> no right
06:33:25 <hseg> eikke__: http://www.haskell.org/haskellwiki/Num_instance_for_functions
06:33:28 <kazagistar> eikke__: yeah, and afaik you cant write an { instance forall a. Num (->) a a }, right?
06:34:06 <hseg> zereraz: ?
06:34:20 <zereraz> hseg: ok I'll ask my doubt with code
06:34:25 <eikke__> hseg: I'm aware of those tricks ;-)
06:35:03 <zereraz> http://lpaste.net/111537
06:35:44 <zereraz> I want an Integer
06:35:55 <zereraz> then I take an input
06:35:59 <zereraz> then I return a list
06:36:00 <hseg> bergey: Thanks, I'll look at that. Maybe something like idris's implicit parameters might help?
06:36:05 <zereraz> so some type error I am getting
06:37:34 <kazagistar> eikke__: so bascially, instance Num b => Num ((->) a b) where fromInteger x = (\_ -> fromInteger x)
06:37:51 <srhb> zereraz: Several problems. You're calling choiceHandle userInput at the last line of main, so its needs to have a return type IO Something
06:38:15 <srhb> zereraz: list ++ [element] is not of type IO something, it's [Int]. Also it's a weird way of juts writing [element]
06:38:34 <r444> solarus: if it'll get me to automatic deriving of 'FromJSON' and 'ToJSON', then yes (I believe it will)
06:38:44 <srhb> zereraz: If the final line in choiceHandle were return [element] -- the types would check out at least.
06:39:03 <hseg> zereraz: You're confusing GHC, so it's giving you confusing errors. But basically, since you're doing IO in choiceHandle, that locks you into returning something of type IO a.
06:39:20 <zereraz> ok
06:39:21 <hseg> zereraz: So in this case, it would be Int -> IO [Int]
06:39:22 <zereraz> so many problems
06:39:46 <r444> solarus: basically i have 2 Qs: 1) how to derive Generic with similar types 2) how to derive 'FromJSON' and 'ToJSON' from these types
06:40:00 <bergey> hseg: I don't know Idris, so I can't answer.
06:43:24 <hseg> bergey: http://eb.host.cs.st-andrews.ac.uk/writings/idris-tutorial.pdf Section 3.4.3
06:43:27 <danilo2> edwardk: Hello! I've got 3 small questions regarding trifecta. I would be very thankful if you could tell me some hints how to solve them :) 1) How should I handle tab to spaces conversions in trifecta If the language supports pragma, which change  the tabl lenght inside of file? 2) does trifecta handles comments somehow? 3) I moved from parsec to trifecta and my compilation time increased 6 times - do you know what could affect it?
06:44:01 <zereraz> srhb: choiceHandle should have a return type of io something because I put a do in main?
06:44:32 <srhb> zereraz: Because of 1) making it the return value of main which is IO something, 2) using readLn which is IO something
06:44:43 <hseg> bergey: Basically, type variables are passed implicitly in Idris, and you can pattern match on them if necessary.
06:44:45 <r444> solarus: oh, you were speaking of typo, yes, i meant exactly that
06:44:57 <solarus> r444: :)
06:45:16 <srhb> zereraz: The do block in main is already using readLn which means the entire block must be IO something. Also main is conventionally (and maybe enforced?) always IO Something (really IO (), but we can ignore that for now)
06:45:34 <awm> Á‡ıÓ‰Ë ÌÂ ÔÓÊ‡ÎÂÂ¯¸ ÚÛÚ ÍÛÚÓ http://cibq.alkerz.ru/84247/2963685/
06:45:42 <solarus> anyways it works if you import GHC.Generics instead of Data.Generic but I don't know if it is what you need or not
06:45:48 <hseg> bergey: So if typeclass instance resolution were to pass Dicts implicitly instead, we could pattern match on them if necessary, have multiple Dicts, and construct Dicts at runtime.
06:46:13 <solarus> that is what is done in one of the aeson examples anyway: https://github.com/bos/aeson/blob/master/examples/Generic.hs
06:46:25 <zereraz> srhb: ok, so if the function has 1 do and an IO then the entire block has to be IO.I didn't know that
06:47:13 <srhb> zereraz: The do notation is just sugar for foo >>= bar >>= ... and (>>=) :: Monad m => m a -> (a -> m b) -> m b -- so the m must stay the same
06:47:36 <srhb> IO, in this case.
06:47:41 <zereraz> ok thanks
06:48:03 <zereraz> so How do I make the list++[element] thing into IO?
06:48:20 <srhb> zereraz: return $ list ++ [element] -- or rather return [element]
06:48:27 <srhb> Since list ++ [element] is just [element]
06:48:52 <zereraz> initially yes but later it can be more
06:48:56 <r444> solarus: oh, thx, i'll try it
06:49:08 <srhb> zereraz: That doesn't help you. values are immutable in haskell, so you're not actually appending something to list
06:49:14 <srhb> zereraz: list will always, always be []
06:49:27 <zereraz> srhb: I was confused about this part
06:49:35 <zereraz> srhb: I knew I was doing something wrong
06:49:41 <zereraz> srhb: how do I do this then?
06:49:59 <srhb> zereraz: There are various possibilities. Perhaps the simplest is the include an IO [Int] as a parameter to choiceHandle
06:50:05 * hackagebot hsdev 0.1.2.2 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  http://hackage.haskell.org/package/hsdev-0.1.2.2 (AlexandrRuchkin)
06:50:05 <zereraz> srhb: I am kind of making a todo list, so the list has to be accessable, do I save it in temporary variables
06:50:14 <srhb> zereraz: Then choiceHandle can recurse and add items to that parameter until some condition is met
06:50:56 <zereraz> srhb: so if I want to have access to that list then I must pass it around in all functions
06:50:57 <srhb> zereraz: How does choiceHandle know when to stop? You might be able to just have an [Int] accumulator
06:51:05 <srhb> zereraz: That's right.
06:51:30 <zereraz> srhb: I won't use recursion on choice handler
06:51:37 <zereraz> srhb: I was thinking of calling main again
06:51:39 <zereraz> inside main
06:51:41 <srhb> zereraz: OK, so you want to go back to main and then decide what to do
06:51:48 <zereraz> srhb: yeah
06:52:18 <srhb> zereraz: First off, let's change main = loop []
06:52:42 <hseg> bergey: Thanks. Would love to continue discussing but gotta go.
06:52:49 <zereraz> srhb: loop [] ?
06:53:01 <zereraz> srhb: another function
06:53:07 <srhb> zereraz: Yes, we'll move the body of main into a function called loop that takes the current list as its argument
06:53:38 <kazagistar> eikke__: writing something like Num (->) was fun, but now I feel dirty https://gist.github.com/kazagistar/5de70d850ad606fae552
06:54:40 <zereraz> srhb: ok will do that
06:55:08 <zereraz> srhb: what does loop return?
06:55:09 <srhb> zereraz: Then that parameter to loop will be the "current list"
06:55:14 <srhb> zereraz: An IO [Int]
06:55:19 <zereraz> ok
06:55:26 <srhb> zereraz: So [Int] -> IO Int
06:55:46 <k_bx> Hey everybody! Quick question: what does ¬´current residency¬ª mean in ekg? It shows ~300 mb residency, while `top` shows program is eating 5.5g RAM.
06:59:29 <rtn>  Why does map reverse . words $ "My name is Rohan" work while map reverse .words ("My name is Rohan") doesn't
07:00:12 <k_bx> rtn: because first is equivalent to (map reverse . words) (¬´My name is Rohan¬ª)
07:00:14 <srhb> rtn: They are not equivalent. (map reverse . words) "My name is Rohan" is
07:00:16 <etandel> maybe you want (map reverse) . words ?
07:01:46 <rtn> Thank you
07:03:07 <albeit> If I have "type Acme = Either Foo Bar" and "type Nasa = Either Foo Baz", and I have an acme I know is Left, how can I convert it into a Nasa?
07:03:32 <zereraz> srhb: http://lpaste.net/111537 I get error for types
07:04:49 <srhb> zereraz: It'll be easier if you forget choiceHandle for now. Try making a case userInput of ... in loop
07:05:05 <zereraz> srhb: ok
07:05:36 <srhb> zereraz: Then consider what should handle in case of 3 -> ...
07:06:19 <mr-> albeit: convert (Left x) = Left x should do the trick :-)
07:07:07 <albeit> mr-: Ha okay, thanks...
07:16:14 <Iceland_jack> albeit: If you know Acme is really a Left maybe you should use Foo instead of Acme :)
07:16:15 <srhb> zereraz: Any luck? :-)
07:18:51 <albeit> Iceland_jack: I was just trying to use "either" and have a non-lambda for the first function, just realized I was reading the type wrong, so I can just do "either Left func eitherVar" and get an Either back
07:19:19 <albeit> :t Map.insert
07:19:20 <lambdabot>     Not in scope: ‚ÄòMap.insert‚Äô
07:19:20 <lambdabot>     Perhaps you meant one of these:
07:19:20 <lambdabot>       ‚ÄòM.insert‚Äô (imported from Data.Map),
07:19:24 <albeit> :t M.insert
07:19:25 <lambdabot> Ord k => k -> a -> M.Map k a -> M.Map k a
07:20:00 <albeit> Is there a way to flip around the arguments for M.insert to have the "a" / value the last provided argument?
07:20:11 <albeit> :t flip M.insert
07:20:12 <lambdabot> Ord a => b -> a -> M.Map a b -> M.Map a b
07:20:26 <srhb> albeit: flip (M.insert key) ?
07:20:36 <albeit> Ah! Thanks!
07:21:24 <exio4> @pl \k -> flip (M.insert k)
07:21:24 <lambdabot> flip . M.insert
07:22:16 <greeny> hi. there is one thing i do not understand about the class instance line. f.e. i hae an usual algebraic data type Tree a. why is in 'instance Functor Tree where' the a missing?
07:22:52 <tdammers> because Functor takes an argument
07:24:10 <MagneticDuck> can anybody help me debug my attempt at doing UDP stuff? http://ix.io/esM
07:25:07 * hackagebot Spock 0.6.6.1 - Another Haskell web framework for rapid development  http://hackage.haskell.org/package/Spock-0.6.6.1 (AlexanderThiemann)
07:25:09 <greeny> tdammers: ok. in the fmap declaration it become clearer 'fmap :: (a -> b) -> f a -> f b'. because f needs an argument
07:25:15 <albeit> MagneticDuck: What's going wrong?
07:25:28 <MagneticDuck> albeit: hPutChar gives me an error
07:25:31 <MagneticDuck> one sec, getting the error
07:26:34 <MagneticDuck> "invalid argument"
07:26:41 <MagneticDuck> error comes from "sendTo"
07:27:38 <MagneticDuck> albeit: any ideas? :<
07:27:48 <MagneticDuck> if you can get it to work on your machine, tell me please
07:28:36 <greeny> MagneticDuck: not sure if im right. but perhaps you need to convert your string to a byetstring first
07:28:56 <albeit> greeny: The plain Network.Socket just uses Strings
07:29:20 <MagneticDuck> greeny: pretty sure a type error like that would be caught at compile time
07:29:29 <dzhus> It's not a sin to write my package ChangeLog's in org-mode, right?
07:29:29 <greeny> mmh right
07:30:39 <joyfulmantis> So which is considered better style? Binding a function (z) to a anonymous function, which gives case the result of z, or using do notation to assign the result of z which case than uses?
07:30:40 <albeit> MagneticDuck: I'm guessing the socket isnt configured properly
07:31:32 <MagneticDuck> hmm
07:31:53 <MagneticDuck> oh, I'll bind it
07:32:01 <albeit> MagneticDuck: Just ran file if I give getAddrInfo a valid port number instead of Nothing
07:32:05 <albeit> *ran fine
07:32:05 <geekosaur> bind isn't very useful on datagram sockets
07:32:23 <MagneticDuck> albeit: cool
07:32:26 <MagneticDuck> geekosaur: yeah x|
07:32:27 <MagneticDuck> forgot
07:32:54 <MagneticDuck> albeit: how do I do that again?
07:33:06 <albeit> :t getAddrInfo
07:33:08 <lambdabot> Not in scope: ‚ÄògetAddrInfo‚Äô
07:33:21 <MagneticDuck> no, I mean, what's the base record for AddrInfo?
07:33:29 * MagneticDuck loads hoogle
07:33:44 <MagneticDuck> k, defaultHints
07:34:09 <MagneticDuck> wait.. >_>
07:34:16 <MagneticDuck> albeit: how did you do that exactly :D
07:34:28 <MagneticDuck> I give it some preferred AddrInfo?
07:34:36 <albeit> Honestly I'm just looking at http://book.realworldhaskell.org/read/sockets-and-syslog.html
07:34:57 <albeit> getAddrInfo take a ServiceName :: String as the final argument, which can be port number (in String form)
07:35:26 <MagneticDuck> ahk
07:35:27 <MagneticDuck> cool
07:36:48 <MagneticDuck> now I get permission denied, but I can handle that
07:36:52 <MagneticDuck> uh. wait.
07:37:00 <MagneticDuck> actually, I'm not quite sure :D
07:37:09 <MagneticDuck> cabal and ghci don't work well with sudo because they assume a different .cabal
07:37:32 <albeit> Some port numbers are reserved, you need to choose an appropriate one
07:37:47 <MagneticDuck> yeah
07:38:15 <tdammers> ports < 1024 are privileged and usually require root permissions to listen on
07:38:48 <Saizan> MagneticDuck: cabal install --root-cmd=sudo should be doing the right thing
07:38:57 <Saizan> MagneticDuck: i.e. use sudo only to copy the files over
07:39:15 <MagneticDuck> kk
07:45:14 <kstt> Hi. I'm having trouble with sqlite-simple, may someone help me please ?
07:46:33 <MagneticDuck> SAY YER PROBLEM
07:47:56 <HairyDude> @hoogle GObjectClass obj => obj -> ListStore a
07:47:59 <lambdabot> Warning: Unknown type ListStore
07:48:00 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
07:48:00 <lambdabot> Control.Monad.Trans.Reader runReaderT :: ReaderT r m a -> r -> m a
07:48:09 <HairyDude> sigh.
07:48:42 <geekosaur> HairyDude, the defaulr hoogle only indexes the packages that come with ghc
07:49:10 <geekosaur> fpcomplete.com has one that should index at least the platform. hayoo indexes all of hackage
07:49:11 <kstt> MagneticDuck: thx.
07:49:33 <HairyDude> geekosaur: unfortunately hayoo doesn't seem to support searching for type signatures
07:50:09 * hackagebot snaplet-redis 0.1.4 - Redis support for Snap Framework  http://hackage.haskell.org/package/snaplet-redis-0.1.4 (DmitryDzhus)
07:50:14 <MagneticDuck> kstt: dude. it's just that instead of saying "I'm having trouble, help me please", you should actually state your problem
07:50:14 <ouuiio> kstt: paste your error please.  otherwise, no one will be able to help.
07:50:15 <geekosaur> it used to at least try, but I see there are no examples any more :(
07:50:30 <MagneticDuck> do you expect everybody who knows something about sqlite-simple to say "hey, I'm here"
07:51:01 <ouuiio> MagneticDuck: please calm down and stop assuming that everyone is a "dude"
07:52:50 <HairyDude> geekosaur: so, what I am looking for is a cast function for ListStores that I can use with builderGetObject
07:53:05 <HairyDude> geekosaur: without it, I can't actually insert anything into it
07:54:02 <albeit> Is there an easy way to break at the next to last element in a list? [1,2,3,4] -> ([1,2,3], 4)
07:54:11 <kstt> no pb, that was a sincere "thanks". Here we go : SQLite does not have rigid types for coumns, but rather "type affinities", which seems to play strangely in my case.  I am storing a Haskell Double in a column (type affinity Numeric). If sqlite reads a figure that looks like a Double (43.2), everything is fine. But it the figure looks like an int (43) then it fails with wrong type runtime error.
07:54:19 <geekosaur> fpcomplete doesn't index gtk2hs :( might need to install hoogle and build a local database
07:54:22 <MagneticDuck> kstt: oh, sry :<
07:54:25 * MagneticDuck is so ashamed
07:55:06 <albeit> :t first ord
07:55:08 <lambdabot> (Char, d) -> (Int, d)
07:55:09 * hackagebot pipes-zlib 0.4.2 - Zlib and GZip compression and decompression for Pipes streams  http://hackage.haskell.org/package/pipes-zlib-0.4.2 (RenzoCarbonara)
07:55:25 <ysz> how can i recover old Hackage account password?
07:55:43 <HairyDude> geekosaur: I'll try that
07:57:30 <RegEchse> albeit:  init &&& last $ mylist  -- that's "easy" :)
07:57:50 <albeit> :t init &&& last
07:57:51 <lambdabot> [c'] -> ([c'], c')
07:58:25 <RegEchse> but be aware that it'll traverse the list twice for actually nothing
08:01:16 <ouuiio> ysz: search for "reset password" on this page: http://hackage.haskell.org/accounts
08:01:30 <lericson_> :t (&&&)
08:01:32 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
08:01:43 <ysz> ouuiio, thx. i dropped an email to admins. unfortunately can't reset either.
08:04:44 <eikke__> > (\i -> foldl (\(l, v) a -> (l ++ [v], a)) ([], head i) (tail i)) [0..10 :: Int]
08:04:44 <lambdabot>  ([0,1,2,3,4,5,6,7,8,9],10)
08:05:10 * hackagebot htsn-import 0.1.1 - Import XML files from The Sports Network into an RDBMS.  http://hackage.haskell.org/package/htsn-import-0.1.1 (MichaelOrlitzky)
08:05:35 <HairyDude> geekosaur: looks like you can search a package using +packagename
08:05:48 <HairyDude> and it looks like the function I want doesn't exist, which is a bit odd
08:06:36 <geekosaur> I've been trying to remember how that stuff works. gtk has some weird behavior with respect to ListStore etc. and you can't use them directly like that
08:06:46 <geekosaur> and the haskell binding can't hide the weirdness
08:07:00 <geekosaur> but it's been several years since I worked with it
08:09:05 <HairyDude> other gtk bindings seem to have cast functions for ListStore, e.g. ocaml http://lablgtk.forge.ocamlcore.org/refdoc/GtkTree.ListStore.html
08:10:56 <hiptobecubic> Do we have any bindings to Qt that work?
08:11:11 <bryanedds> hey ya'll, I'm having a bit of trouble with Haskell syntax
08:11:24 <RegEchse> :t curry $ (uncurry (&&&)) `asAppliedTo` (init, last)
08:11:25 <lambdabot>     Precedence parsing error
08:11:26 <lambdabot>         cannot mix ‚Äò$‚Äô [infixr 0] and ‚ÄòasAppliedTo‚Äô [infixl 0] in the same infix expression
08:11:38 <barx> what's your question, bryanedds?
08:11:39 <RegEchse> :t curry ((uncurry (&&&)) `asAppliedTo` (init, last))
08:11:40 <lambdabot> ([c'] -> [c']) -> ([c'] -> c') -> [c'] -> ([c'], c')
08:11:57 <RegEchse> is there an easier way to `asAppliedTo`-ing this?
08:12:16 <bryanedds> On line 12, I don't know where the 2nd 'handler' and the 2nd 'unsubscribe' bindings come from - http://lpaste.net/111511
08:12:51 <hiptobecubic> RegEchse, that is hideous.
08:13:01 <barx> it's in the observer data type def there bryanedds
08:13:06 <barx> line 8
08:13:13 <RegEchse> hiptobecubic: what?
08:13:38 <hiptobecubic> that expression
08:13:52 <barx> RegEchse what are you trying to do?
08:14:05 <RegEchse> hiptobecubic: that's why i'm asking if there is an easier way to use `asAppliedTo` with a binary function ;)
08:14:17 <CXXVIIta> I want to write a function that takes a 3-tuple as input, and returns a list of tuples as output. The returned list depends on the values contained inside a tuple. What would be the haskell way of doing this (only using standard library funcs)? Basically something like case of would work if i could evaluate it for multiple cases
08:14:29 <bryanedds> I thought 'handler' was a field
08:15:00 <bryanedds> is it also a constructor?
08:15:37 <RegEchse> barx: i want to show the type of (&&&) specifically to the (->) Arrow
08:15:53 <ouuiio> CXXVIIta: what do you mean by "evaluate for multiple cases"?
08:15:53 <albeit> CXXVIIta: doSomething :: (a,b,c) -> [d]?
08:16:10 <ouuiio> CXXVIIta: could you show your code and explain why it's not working?
08:16:29 <barx> interesting, RegEchse.  I wish I could help you - I'm only just relearning Haskell myself. :/
08:16:58 <CXXVIIta> ouuiio: f (x,y,z) = --if x, then (x,0,0), if y, then (0,y,0), if z, then (0,0,z)
08:17:21 <HairyDude> bryanedds: record field names are functions that extract that field
08:17:24 <CXXVIIta> i would like to return the following tuples in a list but evaluate for some conditions for each value in the input 3 tuple
08:17:42 <bryanedds> ah ok
08:17:49 <bryanedds> i was super confused
08:18:04 <HairyDude> bryanedds: e.g. unsubscribe :: Observer a -> Change
08:18:19 <bryanedds> so you don't do val.Field in Haskell
08:18:23 <HairyDude> correct
08:18:44 <hiptobecubic> I guess that's a no on Qt bindings
08:18:48 <CXXVIIta> ouuiio: unfortunately thats the most code i can give to you right now because im trying to figure this out
08:19:01 <ouuiio> CXXVIIta: sorry, I'm not sure what you mean by that.  could you show some input data with the desired output?
08:19:16 <hiptobecubic> wiki has two links, one says it's experimental and difficult to build at all, the other is 404.
08:19:41 <HairyDude> :t asAppliedTo
08:19:43 <lambdabot> (a -> b) -> a -> a -> b
08:19:52 <CXXVIIta> sure, f (1,1,0) = [(2,1,0), (1,2,0)]
08:20:10 <CXXVIIta> sorry for changing the example, but this is more what i'm actually after
08:20:15 <CXXVIIta> same principle.
08:20:58 <CXXVIIta> so basically testing whether each value in the tuple equals something, if so, append a new tuple to a return list.
08:21:16 <ouuiio> CXXVIIta: okay, where does 2 come from?  why does the resulting list contain only two tuples, not, say, three?
08:22:00 <barx> CXXVIIta, what exactly is your question?
08:22:10 <ouuiio> CXXVIIta: do you know how to do it in other language?  say, in python?
08:22:39 <CXXVIIta> in the input tuple i'm testing in this example whether a value equals 1, if it does then i want to return the original tuple but that 1 replaced with 2, and testing the same condition for each slot in the tuple
08:22:42 <barx> you have f :: (Int, Int, Int) -> [(Int, Int, Int)]
08:22:47 <barx> it's pretty simple.
08:22:53 <barx> unless I'm not understanding it.
08:23:09 <CXXVIIta> yes barx
08:23:23 <CXXVIIta> ouuiio: basically this could be implemented in imperative language with a switch statement by omitting breaks for each case
08:23:37 <barx> so break out each function that might add a tuple into it's own function
08:23:39 <CXXVIIta> so i could evaluate multiple conditions for one input
08:24:22 <barx> pattern matching?
08:24:58 <ouuiio> CXXVIIta: this can be done with recursion, but you need to define the base case
08:25:03 <CXXVIIta> ok so, my function is f (x,y,z), and I want to return a list of tuples, and the content of the list depends on the values of x y and z
08:25:58 <ouuiio> CXXVIIta: is there a condition when the list would contain only one tuple (as given) or none?
08:26:07 <ouuiio> say, f (0,0,0) = []
08:26:11 <CXXVIIta> yes
08:26:15 <CXXVIIta> f (0,0,0) = []
08:26:19 <ouuiio> okay
08:26:23 <CXXVIIta> f (0,0,1) = [(0,0,2)]
08:28:14 <ouuiio> CXXVIIta: what about f (1,1,1), f (2,2,2), and f (1,2,3)?
08:28:44 <CXXVIIta> only 0 or 1 as input values
08:28:48 <ouuiio> okay
08:28:50 <CXXVIIta> sorry for confusing example
08:29:11 <ouuiio> no need to be sorry, I'm just trying to understand
08:29:16 <ouuiio> the problem is not difficult
08:29:33 <dreams> Hi lads, what does tail strict mean? I'm suspecting its where access to the whole list is needed, like last or reverse.
08:29:44 <nshepperd> CXXVIIta: concatMap ($(x,y,z)) [f, g, h, ...] could do it where f,g,h are functions that test each condition and return a list of things to add to output
08:29:47 <CXXVIIta> I know, I could solve this by writing tons of pattern matches, but I want to actually learn haskell and find a more elegant solution
08:29:56 <srhb> CXXVIIta: I don't mean to butt in, but I just want to make sure that you know that f (0,0,1) = [(0,0,2)] is valid Haskell, right? And not "just" an example of the return value
08:29:58 <srhb> Ah ok
08:30:04 <srhb> Asked and answered then :)
08:30:29 <ouuiio> CXXVIIta: what should the function return for f (0,1,1)?
08:30:32 <CXXVIIta> i know it's valid haskell but i only mean't to use it as an example
08:30:35 <srhb> Sure. :)
08:30:39 <sgronblo> uh, this is a kinda noobish question but can i compile a binary on my os x laptop and just stick it up on a linux server and have it work or do i need to turn on some sort of cross compiling options?
08:30:45 <CXXVIIta> [(0,2,1), (0,1,2)]
08:31:15 <geekosaur> sgronblo, OS X binaries are not in any way compatible with linux
08:31:16 <nshepperd> eg. f (1,y,z) = [(2,y,z)]; f _ []
08:31:28 <CXXVIIta> ye
08:31:32 <nshepperd> and then sim. for g, h
08:31:37 <geekosaur> and cross compiling is still not really a thing with ghc. you're far better off running linux in vbox or something
08:31:51 <geekosaur> to do your builds
08:32:23 <nshepperd> concatMap ($ tuple) [f,g,h] to apply each function to the value in turn and combine their outputs
08:33:34 <CXXVIIta> nshepperd: isn't this effectively same as pattern matching all cases in the function itself?
08:33:51 <CXXVIIta> or it still requires ALOT of overhead
08:33:53 <sgronblo> geekosaur: ah really? thanks
08:34:51 <sgronblo> i thought ghc was good at cross compiling though, having support for iphone and android for example.
08:34:54 <nshepperd> CXXVIIta: if you pattern match all cases you have to worry about every combination of cases, right?
08:35:01 <CXXVIIta> also true
08:35:29 <geekosaur> the ARM ports were bootstrapped by using LLVM to cross-compile. it's a pretty scary and experimental setup
08:35:29 <albeit> :t flip foldr
08:35:30 <lambdabot> b -> (a -> b -> b) -> [a] -> b
08:35:48 <CXXVIIta> i'm just wondering. I couldn't think of any simple and elegant way of implementing this. That's why i'm curious
08:36:52 <srhb> CXXVIIta: If you can express it succinctly with a switch statement, you can express it as succinctly in Haskell. But if there's no real pattern other than what you've shown, then it doesn't get better than that.
08:37:03 <nshepperd> CXXVIIta: it's not really possible to improve further upon this I think, because you can't map over tuples
08:37:06 <mlitchard> What does it mean for my project when I do a "cabal freeze"?
08:37:11 <geekosaur> (basically ghc doesn't know it's cross-compiling; they use the LLVM backend, abort the compile after LLVM code generation, and convert the LLVM bytecode to native ARM and build manually from there. they have ARM-specific tooling for this that is not easily usable for other platforms)
08:37:38 <CXXVIIta> ok thanks.
08:37:42 <srhb> mlitchard: It does like cabal install, computes a valid set of dependencies, then adds the constraints to build-depends
08:38:15 <srhb> mlitchard: ie. it fixes the versions of every dependency.
08:39:26 <CXXVIIta> however, would it be advisable to conver the tuple to a list first, then operate on the list and convert the resulting list of list to a list of tuples?
08:39:28 <mlitchard> srhb: ah, what if I need them unfixed? Say, I find a problem is solved in a newer version of something, how can I unfreeze?
08:39:39 <srhb> mlitchard: Then you have to edit the cabal file manually.
08:39:49 <mlitchard> shrb: simple enough, thanks :)
08:47:44 <CXXVIIta> got it working as you proposed, thanks for the input nshepperd ouuiio srhb
08:58:35 <arianvp_> How would I check if a list is strictly ascending / decending in haskell?
09:00:06 <orbital> is there anything like Python's Cmd in haskell?
09:00:42 <arianvp_> orbital:
09:00:44 <arianvp_> :t interact
09:00:45 <lambdabot> (String -> String) -> IO ()
09:01:46 <arianvp_> though that's a bit low level
09:01:53 <orbital> arianvp_: interesting, but yeah
09:02:39 <orbital> looking for a readline-capable command interpreter
09:02:57 <orbital> with tab completion, etc.
09:03:46 <arianvp_> orbital: https://hackage.haskell.org/package/readline-1.0.3.0/docs/System-Console-Readline.html ?
09:04:37 <orbital> arianvp_: oh cool
09:06:23 <orbital> not exactly it, but it got me looking in the right direction
09:07:32 <orbital> arianvp_: thanks
09:07:37 <RegEchse> :t Data.List.Ordered.isSortedBy (<)
09:07:39 <lambdabot> Not in scope: ‚ÄòData.List.Ordered.isSortedBy‚Äô
09:07:47 <RegEchse> arianvp_: ^
09:08:27 <arianvp_> ah
09:08:55 <RegEchse> it's in data-ordlist
09:09:10 <arianvp_> just came up with this:
09:09:26 <arianvp_> @let rs = [1,2,3,4,5]
09:09:30 <lambdabot>  Defined.
09:09:48 <arianvp_> > oldr (\(a,b) c-> c && a < b) True $ zip rs $ map succ rs
09:09:53 <arianvp_> > foldr (\(a,b) c-> c && a < b) True $ zip rs $ map succ rs
09:09:55 <lambdabot>  mueval-core: L.hs: removeLink: does not exist (No such file or directory)
09:09:57 <lambdabot>  True
09:10:01 <arianvp_> :)
09:13:36 <exio4> :i readMaybe
09:13:41 <exio4> er
09:15:50 <RegEchse> > all (uncurry (<)) rs
09:15:53 <lambdabot>  No instance for (GHC.Classes.Ord b0)
09:15:53 <lambdabot>    arising from a use of ‚ÄòGHC.Classes.<‚Äô
09:15:53 <lambdabot>  The type variable ‚Äòb0‚Äô is ambiguous
09:15:53 <lambdabot>  Note: there are several potential instances:
09:15:53 <lambdabot>    instance GHC.Real.Integral a => GHC.Classes.Ord (GHC.Real.Ratio a)
09:16:03 <RegEchse> > all (uncurry (<)) $ rs `zip` tail rs
09:16:04 <RegEchse> ups
09:16:05 <lambdabot>  True
09:16:08 <RegEchse> arianvp_: ^
09:17:57 <RegEchse> your foldr re-implements all ;)   and applying 'succ' everytime is a little overkill for me
09:18:30 <sagittarian> i ran cabal install cabal, and it said that it installed cabal into ~/.cabal/lib/x86_64-linux-ghc-7.4.1/Cabal-1.20.0.2/
09:18:42 <sagittarian> how does that help me?  where do i find the updated cabal executable?
09:19:20 <RegEchse> apart from that, arianvp_: won't your function be always True?  x < succ x  always holds!?
09:19:38 <cite-reader> sagittarian: That just installs the library, I believe you need to run `cabal install cabal-install` next.
09:19:48 <sagittarian> ah okay
09:20:23 <sagittarian> it says that a package is likely to be broken by the reinstall
09:20:26 <sagittarian> should i do it anyway?
09:20:37 <sagittarian> to wit, oeis 0.3.6
09:22:52 <Cale> sagittarian: You could probably just reinstall that package
09:22:58 <Cale> (as well)
09:23:04 <sagittarian> yeah i tried that, but it still gives the same warning
09:23:12 <sagittarian> what is that package?
09:23:21 <sagittarian> am i likely to care if it's broken?
09:24:05 <cite-reader> That's an interface to the Online Encyclopedia of Integer Sequences, apparently. (http://hackage.haskell.org/package/oeis)
09:25:54 <sagittarian> which is clearly essential for cabal to run
09:26:11 <sagittarian> anyway, i like to live dangerously
09:30:58 <sagittarian> ugh, now when i try to install lambdabot i get a failure related to this oeis thing
09:31:14 <sagittarian> what is everything depending on integer sequences for?
09:31:28 <sagittarian> i think i'll just install ghc from scratch
09:31:48 <sagittarian> is it safe to just wipe my ~/.cabal directory?  is that where cabal puts everything it creates?
09:31:57 <bennofs> @oeis
09:31:57 <geekosaur> not sufficient
09:31:58 <lambdabot>  Sequence not found.
09:32:08 <bennofs> @oes 2 3 5 7
09:32:09 <lambdabot>  The prime numbers.[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,7...
09:32:15 <bennofs> that's why lambdabot depends on it
09:32:19 <geekosaur> ~/.cabal is cabal's work area, but installed packages are registered with ghc and so you need to delete ~/.ghc also
09:32:26 <sagittarian> okay, that's resonable enough
09:32:48 <sagittarian> @oes 0 1 1 2 3
09:33:02 <lambdabot>  Fibonacci numbers: F(n) = F(n-1) + F(n-2) with F(0) = 0 and F(1) = 1.[0,1,1,...
09:33:37 <sagittarian> and it's safe to delete both ~/.cabal and ~/.ghc and then reinstall ghc from source and move on from there?
09:33:53 <Cale> It's safe, but you may want to just leave ~/.cabal
09:34:03 <sagittarian> @oes 1 1 2 6 24
09:34:07 <lambdabot>  Factorial numbers: n! = 1*2*3*4*...*n (order of symmetric group S_n, number ...
09:34:12 <Cale> especially if there's stuff in ~/.cabal/bin and ~/.cabal/config
09:34:30 <Cale> You also shouldn't ever have to install GHC from source
09:34:31 <sagittarian> Cale, it won't cause a problem with a new version of ghc etc?
09:34:42 <Cale> Actually, those things won't cause trouble with a new GHC anyway
09:34:45 <sagittarian> why not?
09:34:48 <Cale> They're versioned
09:35:05 <Cale> If you look immediately under ~/.ghc
09:35:07 <sagittarian> debian stable comes with ghc 7.4.x, how would i get a newer version without installing from source?
09:35:20 <Cale> Get the generic linux binary from the GHC website
09:35:52 <Cale> Compiling a new one yourself 1) requires a sufficiently recent binary GHC, and 2) can take a long time
09:36:08 <Cale> So, there's not much point in compiling it unless you are hacking on it
09:37:05 <sagittarian> it's worked for me before using the version of ghc packaged by debian
09:37:06 <Cale> (Note that GHC is written in GHC Haskell, so unless you want to attempt the fiddly bootstrapping process, you'll need to keep GHC installed if you want to build it)
09:37:09 <sagittarian> but thanks, i'll grab the binary
09:39:57 <benzrf> is there a ceiling-ing integer deivision
09:40:52 <glguy> Nothing standard, you have to define it yourself
09:43:54 <glguy> > let cdiv x y = negate (negate x `div` y) in map (`cdiv` 4) [7,8,9] -- or ((x+y-1)`div`y) or whatever :)
09:43:56 <lambdabot>  [2,2,3]
09:45:09 <benzrf> cripes
09:45:18 * hackagebot hspec-snap 0.2.0.0 - A library for testing with Hspec and the Snap Web Framework  http://hackage.haskell.org/package/hspec-snap-0.2.0.0 (DanielPatterson)
09:47:27 <ehamberg> any FPComplete employees here? we have a workshop here with ~40 people learning Haskell, and fpcomplete.com blocked us for making too many requests (I guess).
09:47:34 <ehamberg> we cannot even access fpcomplete.com
09:47:36 <ehamberg> Your IP address has been temporarily blocked.
09:47:41 <Cale> wow
09:48:00 <glguy> Sounds like they're learning too hard
09:49:26 <Cale> I'm reticent to trust web applications when it comes to basic development tools. I'd probably pay for fpcomplete's IDE if I could just run it on my own machine :)
09:50:29 <glguy> I'd think it's probably most suited to ehamberg's particular use case where you have 40 non-regular Haskell programmers (I presume) who want to get started and don't have their own environment already
09:50:52 <glguy> except for the whole getting blocked part
09:51:45 <ehamberg> yep. worked flawlessly‚Ä¶ for an hour :)
09:55:16 <vanila> cabal is a nightmare :(
09:55:30 <vanila> nothing installs
09:55:44 <vanila> it makes trying to use haskell impossible
09:58:52 <barx> I did not have that experience with cabal.
09:59:08 <glguy> Most modern "cabal problems" are "abandoned library" problems
09:59:15 <glguy> in my experience
09:59:49 <glguy> Anyway, instead of ranting generally, it'd be more productive to describe where you're stuck
10:00:19 * hackagebot pipes-zlib 0.4.2.1 - Zlib and GZip compression and decompression for Pipes streams  http://hackage.haskell.org/package/pipes-zlib-0.4.2.1 (RenzoCarbonara)
10:01:22 <vanila> cabal install pandoc
10:01:26 <vanila> and cabal install snap
10:01:29 <vanila> both fail horrible for me
10:01:46 <vanila> there are others too
10:01:52 <merijn> "fail horrible" is not very descriptive, lpaste the error message, preferably with -v3
10:02:28 <mr-> vanila: have you tried installing them in a sandbox?
10:04:28 <vanila> mr-, i didnt try that
10:05:57 <dcoutts_> merijn, glguy: speaking of which, I'm writing a blog post on this subject. Does this diagram make any sense to you?
10:05:58 <dcoutts_> http://www.well-typed.com/blog/aux/images/cabal-hell/cabal-hell-symptoms.svg
10:06:11 * dcoutts_ is trying to give an overview of the problems and solutions
10:06:14 <knobo> I'm trying out flycheck mode in emacs for haskell. And it is a bit to verbose
10:06:20 <knobo> Can I turn off warnings?
10:07:25 <merijn> dcoutts_: You should add a third external bubble "silent package db corrupting reinstalls" and point the "cabal hell" arrow there ;)
10:07:53 <merijn> knobo: I'm assuming yes, most tools like that have some way of specifying which GHC flags to use
10:07:54 <dcoutts_> merijn: that's breaking re-installations, no?
10:08:24 <merijn> dcoutts_: Well, those happen silently and automatically anymore :p
10:08:49 <merijn> knobo: Consult whatever tool you're using to figure out how to specify GHC flags and the GHC manual for the names of relevant warnings
10:08:49 <dcoutts_> merijn: you mean they don't happen anymore right?
10:08:55 <merijn> eh, yes
10:08:58 <dcoutts_> ok ok :-)
10:09:01 <merijn> Typing is hard
10:09:27 <merijn> dcoutts_: "constraints wrong" points into nothing?
10:09:37 <luite> the dragonfly eyes of cabal hell
10:09:52 <dcoutts_> merijn: it's pointing at that oval
10:10:00 <dcoutts_> merijn: how can I make that clearer?
10:10:24 <merijn> dcoutts_: Which partially overlaps with "nothing"
10:10:39 <knobo> merijn: thank you. I'll try to find out.
10:10:50 <dcoutts_> merijn: right, it overlaps with there being a solution, and there being no solution
10:10:59 <dcoutts_> but solution/no-solution have no overlap
10:11:14 <merijn> dcoutts_: I think the problem is that your venn diagram doesn't make much sense as a venn diagram :) Traditionally the "background" is the "universe" and the bubbles in between subsets
10:11:53 <merijn> dcoutts_: But your two subsets (no solution/solution) cover 100% of the "universe", so the white background bit is weird to me. But that might just be my pedantic brain :)
10:12:34 <dcoutts_> merijn: yes you're right. I don't have a good solution. I've tried various iterations, each of which made less sense :-)
10:12:57 <merijn> I might just seperate the two circles i.e. no touching at all and have a per circle areas of failures and give "constraints wrong" two arrows, one to each side
10:13:20 <dcoutts_> hmm
10:13:45 <glguy> dcoutts_: I feel like I can work out what the diagram is telling me, but it's kind of a lot to take in
10:13:58 <merijn> With oval being replaced with a marked section like "just works" (with a hard line)
10:14:07 <dcoutts_> glguy: suggestions?
10:14:18 <glguy> I'm thinking :)
10:14:23 <dcoutts_> glguy: this is of course why I wanted a diagram in the first place, it's hard to explain :-)
10:14:46 * dcoutts_ realises he's got to dash off to the London Haskell User Group meeting...
10:15:14 <dcoutts_> glguy, merijn: I appreciate any thoughts, I'll read later
10:18:09 <CXXVIIta> how do you check if multiple values are equal in haskell? such as x == y == z
10:18:34 <glguy> x == y && x == z
10:19:23 <doismellburning> if your Eq instance is not transitive YHAL
10:19:36 <CXXVIIta> ah of course. cheers
10:20:07 <shachaf> I don't think there's a name for foo [] = True; foo (x:xs) = all (==x) xs
10:20:22 <shachaf> But I've wanted it in all sorts of situations.
10:20:23 <exio4> doismellburning: YHAL?
10:20:54 <doismellburning> exio4: you have already lost
10:21:07 <glguy> Oh, that's not what I came up with trying to Google it
10:21:09 <exio4> oh
10:21:45 <doismellburning> ah sorry
10:21:51 <doismellburning> dcoutts_: bah I had to miss that, enjoy
10:31:25 <benzrf> YAAD - you are already ded
10:35:21 <blogle> where in the world can I find the definition for the parse function in parsec? hoogle is no help http://www.haskell.org/hoogle/?hoogle=parse
10:39:31 <merijn> blogle: Do you have local documentation enabled? (If not, you should!)
10:40:27 <Haskellfant> blogle: http://haddocks.fpcomplete.com/fp/7.4.2/20130829-168/parsec/Text-Parsec-Prim.html#v:parse
10:40:46 <merijn> blogle: FYI, 1) hoogle doesn't index all packages 2) you can search for a package name to find the haddocks and 3) haddocks include an alphabetical index
10:41:22 <blogle> Awesome thanks, how do I enable local docs?
10:42:09 <Haskellfant> documentation: True in ~/.cabal/config
10:42:43 <Guest60027> How can I base a new record type value on an existing value of the same type? For example I have a record type with 10 fields and I want to have a value that differs from an existing value at a single field.
10:42:50 <blogle> Haskellfant, meijn: Thank you much
10:43:30 <Guest60027> Specifically, I am trying to build a XPConfig type value in XMonad from defaultXPConfig.
10:44:00 <merijn> Guest60027: Record update syntax "defaultXPConfig { myField = newValue }"
10:44:48 <Guest60027> merijn, thank you :-)
10:47:56 <Haskellfant> I'm playing around with threads and want to make sure I didn't get anything wrong, so it would be nice, if someone could have a quick look at my code and comment on it, especially on the threading aspect (handling exceptions with multiple threads, exiting cleanly, ‚Ä¶) http://lpaste.net/111557 (sorry for posting again, if this is not appropriate here, please tell me so)
10:48:56 <Cale> Haskellfant: It's totally appropriate here
10:49:10 <Cale> Haskellfant: Feel free to ask as many questions as you like
10:49:17 <benzrf> Haskellfant: not pythonfant anymore?
10:49:18 <benzrf> congrats B)
10:49:19 <Cale> I can have a quick look
10:49:23 <Haskellfant> benzrf: hehe :)
10:49:27 <Haskellfant> I'm making progress
10:49:48 <Cale> Haskellfant: Is there anything in particular you're curious about?
10:50:15 <knobo> I give up this flycheck mode.. I can not figure out how to start the checker with -fno-warn-missing-signatures
10:50:17 <Haskellfant> Cale: I'm just not sure if I'm using withAsync correctly or if I missed cases where exceptions could cause my code to crash
10:50:20 <erisco> is there any reason other than convention for higher order function parameters to be ordered by decreasing arity?
10:50:23 * hackagebot hopenpgp-tools 0.11 - hOpenPGP-based command-line tools  http://hackage.haskell.org/package/hopenpgp-tools-0.11 (ClintAdams)
10:50:39 <merijn> knobo: You should keep it and just add signatures :>
10:51:07 <Cale> erisco: That's not even a real convention as far as I'm aware :)
10:51:33 <Cale> erisco: The real convention is that arguments are ordered by increasing expected rate of change.
10:52:03 <Cale> (with a little bias toward the last argument being the same type as the result, because endofunctions are very nice things)
10:52:25 <knobo> merijn: can I auto-insert them?
10:52:36 <Cale> erisco: You want to make the partial applications of your function as useful as possible
10:52:57 <Cale> erisco: and if you can optimise them by doing some computation without needing the last argument, that's even better
10:53:07 <sagittarian> why does the activate-hs script with the haskell binary package create broken symlinks?
10:53:16 <sagittarian> that doesn't help at all
10:53:21 <erisco> Cale, understood, it is just that I keep seeing parameters in the order I described
10:53:38 <erisco> maybe that is a coincidence
10:54:31 <merijn> knobo: Probably not, but generally I write my signaturs before the code. It helps me crystallise what I actually intend my functions to do
10:54:36 <sagittarian> nevermind
10:55:44 <Cale> erisco: Perhaps people expect that the functions with more arguments will be replaced by different values less often
10:56:01 <Cale> Which might be the case, if that's the more involved part of the work
10:56:51 <Cale> erisco: There is also something good syntactically about having the last argument being the one that's expected to be the longest to write, which goes against that
10:57:12 <Cale> which is why we have both forM and mapM :)
10:57:15 <Cale> :t mapM
10:57:17 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
10:57:18 <Cale> :t forM
10:57:19 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
10:58:24 <erisco> hm, good example
10:58:30 <Cale> It's often the case that the expression for the list to be iterated over is short, but the thing to do in each iteration is a dozen lines or something, which makes forM nice, because you can use something like forM xs $ \x -> ...
11:02:02 <Cale> Haskellfant: Looking at this, it's a little weird to be using async on computations which you never expect to complete
11:02:33 <Cale> Haskellfant: Though I guess this is a somewhat convenient way to say "if any of these threads throws an exception, terminate the program"
11:02:41 <Haskellfant> yep that was my thought
11:02:46 <Haskellfant> I was first manually killing them
11:02:57 <Haskellfant> but then I thought that I was basically reinventing async
11:03:33 <Cale> You could probably get away without using withAsync, and just use plain async. I'm not sure there's any advantage given that you're just going to waitAnyCatch immediately
11:03:44 <Cale> Might be a little tidier
11:03:53 <Cale> Less nested, anyhow
11:04:25 <Haskellfant> Cale: but that wouldn't kill the other threads, would it?
11:04:57 <Haskellfant> ah I probably want waitAnyCatchCancel
11:05:02 <Cale> Ah, right, waitAnyCatchCancel, yes
11:05:05 <Haskellfant> didn'- see this before
11:06:36 <WraithM> waitAnyCatchCancel is a godsend. Love that function.
11:09:21 <Haskellfant> Cale: updated, looks way cleaner now. I wonder how i managed to missed waitAnyCatchCancel while looking through the docs earlier. Anything else you noticed?
11:09:48 <Haskellfant> WraithM: now I do too :)
11:10:14 <phaazon> hey
11:10:23 <phaazon> a friend was given a course in scala
11:10:32 <phaazon> he had to define a function called map over predicate
11:10:48 <phaazon> he came to me
11:10:51 <phaazon> saying he‚Äôs stuck
11:10:51 <phaazon> to me
11:10:57 <WraithM> Haskellfant: Don't feel bad. I spent like two full days making my own waitAnyCatchCancel... (realizing that that was what I wanted for the problem, and going about making it, and testing it, etc) then I found it in async... Reduced my horrible thing down to one line...
11:10:58 <phaazon> he just can‚Äôt define such a ¬´ map ¬ª function
11:11:06 <phaazon> (it‚Äôd be fmap)
11:11:14 <phaazon> I guess he‚Äôs looking for contramap
11:11:17 <phaazon> don‚Äôt you think?
11:11:24 <Haskellfant> WraithM: I have this constantly with haskell
11:11:44 <Cale> phaazon: You mean something of type (a -> b) -> (b -> Bool) -> (a -> Bool) ?
11:11:48 <Haskellfant> I reinvent something until I realize that someone has already written it way cleaner than myself
11:12:03 <Cale> phaazon: yes, that would be contramap for the contravariant hom functor
11:12:11 <WraithM> Yep. Exactly.
11:12:57 <albeit> When I do "cabal build" with lens, it spits out a bunch of "Loading package xyz ... linking ... done". Can I disable those messages?
11:13:08 <phaazon> Cale: yeah
11:13:09 <phaazon> to me
11:13:15 <Cale> albeit: Any particular reason why they're bothering you?
11:13:18 <phaazon> it‚Äôs the only viable function
11:13:31 <phaazon> Cale: he wasn‚Äôt given the signature of the function
11:13:38 <phaazon> I just pointed out contramap
11:13:51 <albeit> Cale: Well its about 100 lines, pushing away files that were just compiles, and results from a previous run
11:13:54 <phaazon> because : (a -> b) -> (a -> Bool) -> (b -> Bool) can‚Äôt be
11:13:58 <Cale> phaazon: Well, maybe they wanted something completely different, like (a -> Bool) -> [a] -> [Bool]
11:14:03 <sagittarian> why is cabal complaining about not being able to find /lib/x86_64-linux-gnu/libc.so.6 when the file exists?
11:14:11 <albeit> Cale: Its just noise, not adding any helpful information
11:14:35 <phaazon> Cale: that would be a specific version of map
11:14:37 <phaazon> no
11:14:47 <phaazon> it has to define map for a predicate
11:14:53 <phaazon> he has a function a ->_b
11:14:55 <phaazon> a -> b
11:14:56 <phaazon> a predicate
11:15:02 <phaazon> and has to return another
11:15:12 <Cale> phaazon: So, that is some information about the type required...
11:15:34 <Cale> When you say "a predicate", which type of predicate does he have?
11:15:45 <Saizan> albeit: you could try --ghc-option=-v
11:15:48 <Saizan> albeit: you could try --ghc-option=-v0
11:15:53 <Cale> If he has a predicate on type a, then he's just out of luck
11:16:07 <flyingfisch> are haskell data types kind of like classes in other languages?
11:16:07 <Cale> If he has a predicate on type b, then there's exactly one obvious thing to do
11:16:14 <Cale> flyingfisch: yes
11:16:19 <flyingfisch> cool
11:16:46 <Cale> (kind of :)
11:17:04 <srhb> I'm looking for help with a cabal hell problem with snap-fay and fay. I have both installed in my cabalized project, in a cabal sandbox, but when I try to run fay on a file, I get this error: http://lpaste.net/111499
11:17:22 <srhb> I have used the environment variable specified in the fay installation instructions to direct fay to the cabal sandbox packages.
11:17:31 <Cale> flyingfisch: We don't have subtyping though (it turns out to destroy a lot of other nice language features, so we do without it)
11:17:46 <albeit> Saizan: -v0 turns off too much, and -v1 turns back on what I didn't want. I need a -v0.5 ;)
11:18:01 <flyingfisch> Cale: ok
11:18:23 <Cale> flyingfisch: If you use Haskell data types to model objects though, by making a record type with a bunch of function-typed fields in it, you can do a really good job of OOP, and in my experience, subtyping is less necessary.
11:18:54 <flyingfisch> gotcha
11:19:01 <Cale> This is because the main reason that subtyping is important in OO languages is that they've made a somewhat arbitrary decision to tie the method implementations to the types of the objects
11:19:03 <PythonNut> Hello, I'm a beginner and I've been coding a bunch of toy programs in Haskell to learn. In general, I can get within the ballpark of C++, but I've run into one that's ~200x slower than C++. http://lpaste.net/111563. This is so grossly slow, I must be doing something wrong. Does anyone have any idea why this is?
11:19:30 <Cale> When you can just specify new method implementations when making new objects of the same type, you don't need the subtyping nearly as much
11:20:33 <Cale> PythonNut: Are you using System.Random in your other programs?
11:20:43 <PythonNut> No.
11:20:45 <Cale> PythonNut: It's somewhat notoriously slow
11:21:00 <PythonNut> Oh, maybe that's it. Is there any alternative?
11:21:38 <sagittarian> okay, so the version of libc that debian has is too old for the binary download from haskell.org
11:21:51 <sagittarian> now i have to compile from source, right?  or is there yet another option?
11:21:57 <c_wraith> sagittarian: try the debian build?
11:22:07 <c_wraith> sagittarian: That's why haskell.org *has* a debian build
11:22:09 <Cale> PythonNut: Well, you could use something like the mwc-random package
11:22:39 <sagittarian> what do you mean by the debian build?
11:23:01 <Cale> Unfortunately, it doesn't define an instance of the Random typeclass, so you'll have to adjust your program a little, but it shouldn't be too terrible
11:23:15 <sagittarian> the debian link here: http://www.haskell.org/platform/linux.html just goes to the debian maintained package
11:23:16 <Cale> http://hackage.haskell.org/package/mwc-random-0.13.2.0/docs/System-Random-MWC.html
11:23:20 <bennofs> PythonNut: can you show the C++ code as well? so people can try it themselves
11:23:21 <srhb> sagittarian: http://www.haskell.org/ghc/download_ghc_7_8_3#distros
11:23:31 <srhb> sagittarian: In these cases it's easier to install GHC and cabal on their own
11:23:42 <PythonNut> Cale, Thanks. Does Haskell have no built in random number generator?
11:23:56 <srhb> Sorry, here: http://www.haskell.org/ghc/distribution_packages -- sagittarian
11:23:59 <PythonNut> bennofs, sure, let me fetch it.
11:24:00 <Cale> PythonNut: Well, System.Random is the one specified by the standard
11:24:21 <srhb> I think.
11:24:25 <Cale> PythonNut: But it's kind of awful in a lot of ways, and people have made progress on that front that's not been reflected in the Report
11:24:44 <srhb> Oh actually no, it's the binaries below in the first link
11:24:46 <c_wraith> sagittarian: from http://www.haskell.org/ghc/download_ghc_7_8_3 get the build that was done on debian.
11:25:06 <PythonNut> bennofs: Here you go http://lpaste.net/111564
11:25:22 <sagittarian> okay, thanks c_wraith
11:25:25 <Cale> PythonNut: MWC is fast, but not even the one I'd probably recommend for general use. If you don't need as much performance, tf-random has really nice properties.
11:25:27 <PythonNut> I'm not trying to directly translate so the programs are not strictly equivalent.
11:25:31 <bennofs> PythonNut: well, there are various different tradeoffs when you design a random number generator. You can tune for speed, or for ease of use, quality of the random numbers, .... There are lots of usecase for random number generators, so there is no implementation that can fit all
11:25:40 <sagittarian> and then after i install that, cabal will work (cabal from the binary haskell platform that i downloaded)?
11:26:11 <c_wraith> sagittarian: should.  cabal binaries aren't tied to any particular GHC
11:26:34 <PythonNut> I mean, is there no way for Haksell to just make a rand() call somewhere? I know that's fast, and I don't care too much about the quality or crypto quality.
11:27:03 <merijn> PythonNut: Only in IO
11:27:03 <Cale> PythonNut: Oh, there might be a way through the posix binding
11:27:20 <merijn> PythonNut: Hell, linking rand in yourself should be pretty simple
11:27:35 <PythonNut> Okay, I'll add that to the list.
11:27:49 <PythonNut> Has anyone seen/wanted to see the C++?
11:27:51 <srhb> I don't think the posix binding can do it, you'd have to create it yourself. But it is indeed super simple
11:28:08 * srhb did her first C bindings last week, and it was nice and simple
11:28:13 <Cale> ah, yeah, looking at the doc index, I don't see it here
11:28:20 <bennofs> PythonNut: the problem is that rand() needs global state, so you cannot use it outside the IO monad in haskell
11:28:20 <Cale> srhb: cool :)
11:28:25 <Cale> Yeah, FFI is pretty easy
11:28:33 <srhb> I was very pleased, once I got over the segfaults. :-)
11:29:16 <PythonNut> bennofs: Yea, I figured as much since Haskell is so pure (and awesome). I'm surprised there's no rand() call built into System.Random or the like.
11:29:46 <Cale> someone go to this page in Chrome and tell me if the URL shows up strangely in your address bar http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html
11:29:49 <merijn> "foreign import ccall "stdlib.h" rand :: IO CInt" <- done
11:30:03 <albeit> Cale: Shows fine for me
11:30:04 <Cale> I'm doing a dist-upgrade at the moment, so things are a bit weird for me :)
11:30:09 <bennofs> PythonNut: btw, if you want to figure out yourself where the time is spent in your program, you can use GHC's profiler
11:30:09 <silver> Cale, looks good
11:30:10 <merijn> Cale: ha, Chrome renders it with ligatures :D
11:30:13 <merijn> This makes me so happy
11:30:18 <makalu> how do I "forM" over a Data.Vector.Storable.Mutable?
11:30:26 * hackagebot flaccuraterip 0.3.2 - Verify FLAC files ripped form CD using AccurateRip"  http://hackage.haskell.org/package/flaccuraterip-0.3.2 (NicolaSquartini)
11:30:30 <makalu> it's not Data.Vector.Generic
11:30:42 <bennofs> PythonNut: compile with ghc -O2 -prof -rtsopts -fprof-auto <file.hs>
11:30:50 <bennofs> PythonNut: then run with <file> +RTS -p
11:31:06 <c_wraith> makalu: Generic provides an interface that all three (boxed, unboxed, storable) implement.
11:31:10 <Cale> foreign import ccall "stdlib.h rand" crand :: IO CInt
11:31:19 <bennofs> PythonNut: then, you can look at <file.prof> with an editor to see a breakdown of the time spent evaluating each variable in your program
11:31:24 <PythonNut> Okay, I did something like that but just with -prof and -rtsopts, let me try again
11:31:28 <Cale> You might even be able to get away with
11:31:30 <Cale> foreign import ccall "stdlib.h rand" crand :: IO Int
11:31:35 <bennofs> PythonNut: for your program, 45% of the time is spent evaluating xs
11:31:53 <bennofs> PythonNut: 42% is for ys
11:32:04 <makalu> c_wraith: I don't know what I'm doing wrong but when I try to use forM_ from Generic, I get "No instance for (GV.Vector (MV.MVector s) Word64)". I think MVector is missing a type parameter?
11:32:43 <PythonNut> bennofs: Okay, I get it now, I remember seeing the xs and ys and going "Um, what?" and being confused now it makes sense.
11:33:06 <makalu> GV = Data.Vector.Generic, MV = Data.Vector.Storable.Mutable
11:33:19 <srhb> Can someone help me debug this error? I've been stumped for a few days now: http://lpaste.net/111499
11:33:19 <PythonNut> So if we made numbers at rand() speed, we'd been in the ballpark of C++ again.
11:34:16 <c_wraith> makalu: oh!  You're using the generic immutable interface.  That won't work with the Mutable instances.
11:34:30 <makalu> that actually sounds reasonable :)
11:34:42 <makalu> so when I use mutable I don't have forM?
11:35:24 <makalu> D.V.Generic.Mutable doesn't have it either
11:35:43 <c_wraith> makalu: it does look like that
11:36:22 <makalu> OK thanks
11:36:31 <c_wraith> makalu: it would have somewhat messy semantics - what happens if you change the vector's size during iteration?
11:36:43 <c_wraith> makalu: still, it feels a bit odd that those ops are absent
11:36:47 <makalu> that's true
11:38:08 <c_wraith> makalu: if you're sure that the forM_ won't be mutating the Vector, you can get away with an unsafeFreeze before the forM_, which will have only O(1) overhead.
11:38:33 <c_wraith> makalu: though it will require you to specify the result type of unsafeFreeze, probably.
11:40:19 <Darwin226> Hey guys. I'm having trouble installing cuda. I've googled the error I get and the only thing I can find is this lpaste that's pretty much line for line the same as I get http://lpaste.net/86134
11:40:22 <Darwin226> any ideas?
11:43:22 <albeit> When I'm output a Text (unpacked to String) with special characters, like 0x01 / '\SOH', is there any way for it to show up a single special character, not '\SOH`?
11:43:41 <joelteon> it wouldn't output \SOH unless you're using the Show instance
11:43:43 <geekosaur> albeit, that sounds like you're using show somewhere
11:43:44 <joelteon> so don't do that
11:44:33 <albeit> Shoot, I forgot where I was outputting it, wasnt unpacking, thanks
11:44:41 <meiji11> is the code in the conquering folds article on school of haskell subsumed in a package somewhere? I'd liked to use it in one of my projects
11:45:28 * hackagebot Gamgine 0.4.1 - Some kind of game library or set of utilities.  http://hackage.haskell.org/package/Gamgine-0.4.1 (DanielTrstenjak)
11:45:57 <bennofs> meiji11: what article?
11:46:14 <meiji11> bennofs, https://www.fpcomplete.com/user/edwardk/conquering-folds
11:46:23 <bennofs> meiji11: ah, thanks
11:46:34 <meiji11> bennofs: I should have specified to begin with :P
11:46:43 <geekosaur> gah, lambda.haskell.org is down too
11:46:58 <bennofs> geekosaur: what's supposed to be there, anyway?
11:47:13 <geekosaur> haskell platform haddocks, in my case
11:48:05 <palo> I have a problem, I kinda deleted my ~/.cabal directory. want to install a programm, but now i always get errors that say Modules are missing in dependent packages.
11:48:28 <palo> is there a better way to clean the .cabal cache instead of deleting ~/.cabal
11:49:29 <palo> BTW when I'm installing the package (that is broken I get the same message sometimes, but sometimes it works and after that the original package compiles)
11:49:37 <sagittarian> how can i declare a type synonym for a list of something that is an instance of Ord?
11:50:07 <imalsogreg> srhb: Did you solve your fay-base problem?
11:50:14 <palo> sagittarian: type Foo = [Ord a]  or type Foo = Ord a => [a]
11:50:15 <palo> ?
11:50:41 <palo> sagittarian: but I'm guessing
11:50:51 <imalsogreg> srhb: I managed to reproduce it. Solution was to install fay-base, and to call fay with 'cabal exec'
11:50:52 * palo is also a noob, 
11:51:07 <palo> s/also//
11:51:23 <palo> don't want to offend somebody, sorry sagittarian
11:51:46 <sagittarian> palo, thanks, i guess i didn't realize that syntax was valid
11:51:58 <palo> sagittarian: is it ?
11:52:17 <hexagoxel> sagittarian, palo: i don't think it is
11:52:21 <glguy> sagittarian: You probably don't want to do that
11:52:23 <hexagoxel> sagittarian: see http://www.haskell.org/haskellwiki/Existential_type
11:53:31 <glguy> sagittarian: It might be worth describing what you're trying to do with such a Foo
11:54:36 <sagittarian> I'm using lists as keys for a Map (as in Data.Map)
11:54:53 <sagittarian> so i want to create a type synonym for the keys, to make the code a bit clearer
11:55:04 <srhb> imalsogreg: Hmm, okay, I'll try that
11:55:28 * hackagebot layers-game 0.4.3 - A prototypical 2d platform game.  http://hackage.haskell.org/package/layers-game-0.4.3 (DanielTrstenjak)
11:55:44 * palo studies the FAQs because of his cabal problem.
11:56:42 <srhb> imalsogreg: That does appear to work. Now the question is, why does it fail with snaplet-fay.
11:56:57 <hexagoxel> sagittarian: but why do you want to mix the keys for maps with different keys?
11:57:36 <glguy> sagittarian: you'd have:   type ListKeyedMap k = Map [k]
11:57:48 <glguy> and then the Ord constraint comes when you use that type with a function that needs Ord
11:58:04 <glguy> but not in the type synonym
11:58:25 <srhb> imalsogreg: I guess I can cabal exec bash and run it from there. Weird!
11:58:48 <hexagoxel> sagittarian: disregard last question, i did not read correctly
11:58:57 <imalsogreg> srhb: Good question :)
11:59:18 <palo> I can remember there was something about not using typeclasses in type definitions in 'learn yourself some haskell' because it poluts your function definitions
11:59:36 <srhb> imalsogreg: Yeah, that works. Thank you for your insight. This is a sufficient solution for now, until I can get someone from the fay team to look at it :-)
11:59:38 <imalsogreg> srhb: Hmmmm.... yeah, that seems a little funny, right? I'm guessing the snaplet refers to fay executable by name somewhere assuming it's on the PATH.
11:59:46 <srhb> imalsogreg: Indeed.
12:00:00 <srhb> But actually, I thought it was using the fay API directly.
12:00:13 <imalsogreg> srhb: No prob. Good luck, let me know if you find out.
12:00:24 <srhb> Sure :-)
12:00:53 <sagittarian> okay, so pausing on the type synonym question for a sec
12:01:31 <sagittarian> i installed the latest binary version of ghc from haskell.org, but i still have cabal complaining about an old version of libc
12:02:01 <sagittarian> anything else to try before i try compiling the haskell platform from source?
12:02:10 <Cale> Just rebuild cabal?
12:02:22 <sagittarian> i can rebuild cabal without cabal?
12:02:28 <Cale> You can grab the cabal-install package from hackage
12:02:35 <Cale> and run the bootstrap.sh script from there
12:02:46 <sagittarian> whoa, mind officially blown
12:02:47 <Cale> and it'll grab a bunch of stuff and build you a fresh cabal-install
12:02:59 <sagittarian> thanks Cale
12:02:59 <Cale> I mean, the tarball
12:03:08 * palo solved the cabal problem 
12:03:20 * palo shows the twitter syndrom :D
12:03:47 <Cale> That actually makes me realise something: the bootstrap.sh script should really use sandboxes now that we have those
12:04:21 <sagittarian> what are sandboxes?
12:04:31 <sagittarian> is that like python virtualenv or rvm with ruby?
12:04:32 <Cale> So as to avoid installing any packages before, for instance, there's a haddock installed, and the user has had a chance to edit their ~/.cabal/config
12:05:13 <Cale> Basically they're just project-specific package repositories
12:05:29 * hackagebot persistent 2.0.7.1 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-2.0.7.1 (GregWeber)
12:05:29 <Cale> So, rather than installing to ~/.ghc
12:06:59 <sagittarian> so like the node_modules directory for npm?
12:07:12 <Cale> I have no idea about anything in these other ecosystems :)
12:07:18 <sagittarian> okay
12:07:25 <sagittarian> so how do i use sandboxes, in general?
12:07:43 <sagittarian> is there an option to pass to cabal?
12:07:49 <Cale> For the last decade or so, I've pretty much been programming only in languages whose obscurity is greater than or equal to that of Haskell's :)
12:08:03 <sagittarian> yeah i can understand that
12:08:14 <sagittarian> some of use have a job though
12:08:16 <Cale> I'll get a link
12:08:18 <sagittarian> *us
12:08:30 <Cale> http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
12:08:35 <edwardk> albeit: in ghc 7.10 those messages will move to -v2
12:08:37 <Cale> intro tutorial :)
12:08:43 <palo> Cale: When I do ; cabal configure --enable-tests ; cabal sandbox init ; cabal install --only-dependencies ; cabal test ;
12:08:51 <albeit> edwardk: Awesome!
12:08:55 <edwardk> albeit: in the meantime you are kinda stuck. you can turn off _all_ messages with -v0 but then you don't see what module is being compiled
12:08:57 <palo> it get the error not finding hspec
12:09:28 <edwardk> albeit: we got permission to change it a couple of years back, but then everyone kept bouncing off the problem until hvr found the right 2 lines to change ;)
12:10:05 <albeit> edwardk: Well Im happy. Is there an estimate release date for 7.10?
12:10:26 <albeit> edwardk: And who's "permission" do you need?
12:10:30 <edwardk> albeit: i'm relatively unsure to be honest. we have a lot of big changes in the works
12:10:56 <NikolajK1> how do I understand this code
12:10:57 <NikolajK1> newtype Mu f = InF { outF :: f (Mu f) }
12:10:57 <NikolajK1> specifically, is the "outF" some sort of projection returning a value?
12:10:58 <edwardk> albeit: i talked to SPJ about it a couple years back and he said 'go for it', but when we looked into how to do it, it was confusing at the time
12:11:15 <sagittarian> cool, i'll be sure to always use cabal sandboxes now then
12:11:29 <edwardk> NikolajK1: follow the types: InF :: f (Mu f) -> Mu f       outF :: Mu f -> f (Mu f)
12:11:55 <ion> nikolajk1: newtype Foo = InFoo { outFoo :: Bar } results in InFoo :: Bar -> Foo and outFoo :: Foo -> Bar
12:12:13 <edwardk> newtype Const a b = Const { getConst :: a } -- Const :: a -> Const a b         getConst :: Const a b -> a
12:12:30 <shachaf> i,i InF vs. supE
12:13:05 <edwardk> albeit: if i had to guess, i'd expect it early next year, but i'm not the person who makes such calls
12:13:22 <edwardk> albeit: thoughtpolice would be the person who deals with all the release noise
12:13:35 <NikolajK1> ah okay, thanks for the clarification
12:14:03 <sagittarian> yay! i now have a working updated version of cabal, and it only took as long as it would have taken to compile the haskell platform from source anyway!
12:14:23 <edwardk> in particular i would love to see something that richard eisenberg is working on in before 7.10, because it'd let us set up some warnings for 7.12 changes in a way that would make it easier for users to upgrade than what we'd be forced to do if his work _didn't_ go in, so i'm more inclined to let it ride than rush
12:14:42 <thoughtpolice> the current plan is shoot approximately for Feburary or so of next year
12:14:45 <thoughtpolice> albeit: ^^
12:14:59 <NikolajK1> am I the only one who thinks that the language notation in things like
12:14:59 <NikolajK1> Nat = Zero | Succ Nat
12:14:59 <NikolajK1> is pretty terrible. "Succ Nat" is weird, it's like it should be a term, but it looks more like the direct image
12:15:07 <thoughtpolice> edwardk: what's he working on?
12:15:13 <edwardk> NikolajK1: use GADT syntax then ;)
12:15:14 <NikolajK1> what's the feel I'm supposed to feel when reading this? terms on the right hand side?
12:15:29 <Cale> edwardk: btw, did you see my comment about cabal-install's bootstrap.sh? It occurred to me that it ought to be using sandboxes.
12:15:36 <vanila> absolutely agreed NikolajK1
12:15:43 <vanila> its so confusing beacuse it mixes values and types
12:15:51 <srhb> Huh, how?
12:15:56 <srhb> Oh, because of the recursion.
12:15:57 <Cale> edwardk: Not sure who I should bug about that, or if I ought to just work out how to do that myself and submit it somewhere :)
12:16:01 <edwardk> thoughtpolice: he had a version of a superclass defaulting proposal, similar to conor's that could be adapted to make a lot of stuff like splitting fail out of Monad and e.g. choosing to split up Monoid into Monoid + Semigroup less painful for users if we adopted it
12:16:32 <edwardk> Cale: i confess to being pretty far outside of the loop on cabal-install's guts
12:16:33 <shachaf> One that actually worked?
12:16:34 <srhb> I like it because it looks like equational reasoning. We can substitute in the definition for Nat and it all makes sense.
12:16:45 <thoughtpolice> edwardk: oh, did he do this before/concurrently while Conor wrote down all those notes about superclass defaulting?
12:16:46 <edwardk> shachaf: his was i think the best variant on the proposal so far
12:16:47 <Cale> Maybe I should ping dcoutts?
12:16:48 <shachaf> There have been so many broken superclass defaulting proposals.
12:16:55 <Saizan> NikolajK1: it's supposed to look like a BNF grammar
12:16:58 <edwardk> thoughtpolice: he had his ready 4-5 months before conor wrote up his
12:17:11 <edwardk> thoughtpolice: and we talked about it at new york haskell a fair bit
12:17:11 <Cale> shachaf: I don't know about broken, but there have been so many unimplemented superclass defaulting proposals
12:17:11 <thoughtpolice> Cale: refold or tibbe would also probably have input
12:17:41 <thoughtpolice> hm, *is* there any implemented superclass defaulting proposal?
12:17:45 <NikolajK1> Saizan: k, I haven't worked with this
12:17:52 <thoughtpolice> well, aside from this one from Richard i've never heard of.
12:17:56 <edwardk> Cale: in richard's case its a fairly minimalist proposal with a few tricky things to make it easier for folks to retroactively split up class hierarchies
12:17:59 <greeny> hi i installed layers-game, but how can i run it? is there a special cabal command i dont see?
12:18:01 <NikolajK1> all I know is Chomsky look like my grandfather
12:18:05 <NikolajK1> (literalyl)
12:18:13 <edwardk> thoughtpolice: well, conor's SHE implements something like his proposal
12:18:32 <shachaf> Something that actually lets us refine a class hierarchy without utterly breaking backwards compatibility is the holy grail of GHC extensions.
12:18:45 <edwardk> thoughtpolice: anyways, i was going to ambush richard at hac phi this year and see if we can push it through or give it up for 7.10 this year
12:19:03 <edwardk> thoughtpolice: that'd let us know how viable it is in time to still make decisions based on that fact for the end of 7.10
12:19:21 <thoughtpolice> oh, Hac Phi is next month, I see
12:19:35 <thoughtpolice> well, I think if it hits before December, it's probably OK
12:19:43 <shachaf> Philadelphia is so far.
12:20:14 <edwardk> thoughtpolice: so i'm not yet in a good position to go through all the implications, i'll be much better equipped next month when we can have a firmer plan
12:20:25 <thoughtpolice> edwardk: the problem is that November/December are usually kind of problematic/dead zone type of year, since most people are tied up with holidays, so there's very little time for adequate review/feedback for a while then
12:20:37 <kazagistar> greeny: is your cabal bin folder in your path?
12:20:43 <thoughtpolice> and past that point, i'll probably shut off a stable branch to new things like that.
12:20:46 <edwardk> thoughtpolice: sure, i just have no other way to advance the timeline =P
12:20:57 <thoughtpolice> np :P just letting you know what the current time plans are
12:21:34 <edwardk> thoughtpolice: if we're forced to go ahead without it it means a MonadFail proposal for 7.12 would be much heavier on breakage, and will need a much messier warning in 7.10, etc.
12:22:13 <edwardk> thoughtpolice: so if its possible and it looks viable, i'd love to be able to bull ahead with it
12:23:04 <greeny> kazagistar: no. i found it now
12:23:07 <greeny> thx
12:23:09 <thoughtpolice> edwardk: SGTM. at least now you have a rough date to think about
12:23:30 <thoughtpolice> so maybe you can use that to set a fire under Richard :P
12:23:32 <edwardk> since it'd be really nice to be able to say that by 7.12 we'd closed out most of the open issues with the library ecosystem outside of the numeric hierarchy and laid down the framework by which even that could start to be fixed.
12:23:45 <edwardk> but if we can't have that pony, we can't have that pony ;)
12:25:15 <edwardk> for 7.10 i'm content to try to fix the preponderance of 'common sense' things that can be worked around without CPP, and 7.12 can address a couple of the bigger wants that need more code breakage (or if Richard's trick works, may be almost as painless)
12:26:43 <srhb> Fixing the numeric hierarchy? What kind of black magic is this?
12:28:47 <sohum> edwardk: as a simple user of ghc, I'd just like to say that I _love_ ponies and those who put in the work to herd them for us :p
12:29:30 <ion> edwardk: I‚Äôm under the impression that a number of Prelude functions will be generalized to Foldable/Traversable in 7.10. Will map = fmap as well?
12:29:55 <edwardk> ion: map = fmap is one of the few generalizations we are not planning
12:30:17 <ion> edwardk: Aww. Okay, thanks.
12:30:37 <kazagistar> oh really? more foldable/traversable would be sexy... is this stuff on the mailing list perchance?
12:30:42 <edwardk> srhb: we don't have concrete plans there at this time
12:31:00 <srhb> Ah ok. :-)
12:31:07 <ion> kazagistar: https://ghc.haskell.org/trac/ghc/ticket/9586
12:31:20 <srhb> Heh, Haskellers and new GHC shinyness is funny. Although I'm guilty of going "OooOoooooo" as well. :P
12:31:55 <edwardk> kazagistar: it was the discussion that formed the core libraries committee about a year and a half ago. there was a 'burning bridges' proposal, in response to it the complaint that base didn't have a real maintainer came up, and simon asked me to form a core libraries committee to serve as a collective maintainer for base and the bits of the haskell platform that we all rely upon but nobody owned.
12:32:37 <edwardk> kazagistar: the proposal came right on the tail of the 'applicative monad proposal' which did go through the normal libraries@ process, though was clearly going to need some active maintenance on its own.
12:33:12 <edwardk> with the two basically Foldable/Traversable get exported from Prelude, and we stop having 2 copies of all the combinators in base with different signatures that you must hide to get the better ones.
12:33:35 <edwardk> haskell2010 and haskell98 can export things from a Data.OldList to get access to the monomorphized versions of things
12:34:02 <edwardk> in practice this has necessitated a few changes to Foldable to keep the existing semantics of some operations which differed between the Prelude and Foldable versions in terms of associativity, etc.
12:34:32 <kazagistar> yeah, seems good to me, I am just excited to see a big change like this in motion
12:34:34 <edwardk> but between the two proposals the gist of it is, Prelude gets Monoid, Applicative, Foldable and Traversable
12:35:15 <kazagistar> But not semigroup yet?
12:35:20 <edwardk> and a couple of packages suffer for it (mostly the hughes pj pretty printer style API's that used (<$>) and (<>) already for other purposes with other associativities
12:35:43 <edwardk> kazagistar: we decided not to do semigroups in 7.10, but left the discussion open for 7.12. its a soft reject just because of how much other stuff is on our plate
12:35:52 <kazagistar> right
12:36:10 <edwardk> with 7.10 my personal goal has been to minimize the damage from doing a broad sweep of generalizations as a way to warm people up to the fact that we _can_ make things better
12:36:49 <edwardk> so while we can generalize stuff, i really want to ensure that as much as possible you can write code in such a way that it compiles both before and after the change
12:36:57 <edwardk> without littering your code with CPP noise
12:37:10 <ChristianS> edwardk: that prelude change will be in haskell 2014?
12:37:15 <edwardk> some coding styles may suffer more changes than others
12:37:25 <kazagistar> if we are making Prelude functions more typeclassy, how about "const = return"? :P
12:37:38 <kazagistar> (cause we need another synonym)
12:37:40 <srhb> christians: Haskell Platform is somewhat orthogonal to GHC in itself
12:37:42 <edwardk> ChristianS: i've yet to see any actual traffic on the haskell 2014 mailing list to convince me that it is still a going concern right now. i have no idea.
12:37:53 <srhb> Oh, Haskell 2014
12:38:13 <mauke> I hope we can still blame Cale for this when it happens
12:38:20 <edwardk> ChristianS: i'm happy to work with the folks who are doing haskell 2014 to help keep them abreast of what it is we're doing and why, and see how much of it they deem suitable for standardization
12:38:56 <edwardk> kazagistar: =P
12:39:19 <edwardk> kazagistar: we're trying to stick to obvious generalizations that are already in use, not change flip into a backwards fmap, etc. ;)
12:40:08 <ChristianS> edwardk: hmm, but it ghc would ship with a non-standard Prelude that would be worrisome
12:40:09 <shachaf> edwardk: Yes, clearly flip is for Distributive functors.
12:40:17 <edwardk> ChristianS: it already does
12:40:44 <edwardk> ChristianS: the goal here is to keep the haskell2010 and haskell98 packages as close to the standard as possible so that folks who have teaching concerns and want a simpler language have a way to address that need
12:41:49 <kazagistar> I dunno... "const" always seemed like a better name then "return" or "pure", but ill survive lol
12:41:50 <edwardk> ChristianS: but you have nobody driving the bus on the standards side right now. go skim the haskell 2014 mailing list archives. it has been dead for a year.
12:42:03 <srhb> kazagistar: Well, const already exists, that would be scary :P
12:42:22 <xificurC> I'm doing an assignment where hex 0010 is supposed to turn into '\DLE', any clue what is the final Char and how to get to it?
12:42:27 <edwardk> nikita volkov pushed a one off records proposal last year on every list under the sun, there have been a couple of questions posed to the list, but no response.
12:43:09 <mauke> > '\x0010'
12:43:09 <srhb> > chr 0x0010
12:43:11 <edwardk> ChristianS: so until there is any traffic from any member of the actual committee who is nominally working on haskell 2014 on the haskell-prime mailing list at all, i'm treating it as no longer a going concern
12:43:11 <lambdabot>  can't find file: L.hs
12:43:11 <lambdabot>  '\DLE'
12:43:20 <srhb> ^ xificurC
12:43:21 <kazagistar> srhb: return does the same thing const does, its a drop in replacement... it just happens to do some more stuff as well
12:43:41 <srhb> kazagistar: Huh, okay, how?
12:43:56 <srhb> :t const
12:43:58 <lambdabot> a -> b -> a
12:43:59 <mitchty> so, i'm at a loss as to how one would extract the remaining arguments from a command with optparse applicative
12:44:09 <srhb> I don't see the similarity
12:44:49 <edwardk> The last serious discussion i can point to on the list was Igloo's discussion about NoImplicitPreludeImport
12:44:59 <kazagistar> srhb: hint, there is a Monad ((->) b)
12:45:06 <ion> @type [return, const]
12:45:07 <lambdabot> [a -> b -> a]
12:45:08 <srhb> Right, okay.
12:45:10 <kazagistar> > return 3 5
12:45:11 <xificurC> srhb: thanks
12:45:12 <lambdabot>  3
12:45:15 <ChristianS> edwardk: i'm subscribed to the haskell-prime list, i know it's dead. hmmmm
12:45:16 <srhb> So we're in the (.) = fmap camp now :-)
12:45:31 <kazagistar> > return "Hello" 7
12:45:33 <lambdabot>  "Hello"
12:45:50 <edwardk> ChristianS: the same thing came up when it came to removing a bunch of hugs support from base. if there was anyone to interact with on the hugs side of the discussion we'd have loved to engage with them
12:46:02 <dmj`> kazagistar: what...
12:46:11 <vanila> isn't there only one other haskell compiler than GHC today?
12:46:15 <vanila> (EHC)
12:46:21 <edwardk> srhb: (.) is being left ungeneralized in ghc right now ;)
12:46:21 <merijn> vanila: Eh, UHC?
12:46:27 <srhb> edwardk: :-)
12:46:37 <merijn> vanila: Pretty sure augustss has his own compiler(s)
12:46:38 <srhb> It's all very exciting, this new-fangled progress in ghc land
12:47:08 <vanila> are they free and under active development?
12:47:17 <edwardk> vanila: there is jhc, ajhc, intel has some backend stuff, lennart et al's mu compiles something that is nominally haskell syntactically if not semantically, ehc/uhc is the closest thing to a well maintained alternative compiler
12:47:20 <merijn> UHC should be free and active
12:47:33 <merijn> augustss stuff probably not free, but active
12:47:49 <merijn> edwardk: Intel's stuff just hooks into GHC, so not sure that qualifies
12:47:56 <merijn> edwardk: They only compile Core
12:47:56 <edwardk> vanila: i'm not saying there are no other compilers. i'm just saying there is nobody participating on the standardization front
12:48:07 <edwardk> merijn: yes, as did lemmih's lhc, etc.
12:48:16 <vanila> I felt like there's no other compilers really
12:48:33 <vanila> and I wonder why
12:48:38 <edwardk> vanila: we've slowly slipped into a monoculture in the sense that cabal made it really really easy to do ghc development
12:48:39 <srhb> It would be sad if we kept stagnating because no one cares enough to communicate. Which seems to have been the case before the new "committee"
12:48:58 <kazagistar> dmj`: are you wondering why return works as const?
12:49:08 <merijn> vanila: Because implementing a highly optimised compiler is a lot of work and thus contributing to GHC gets more bang for your buck in terms of effort
12:49:21 <simpson> Out of curiosity, what would be the impetus for a new compiler?
12:49:32 <simpson> What does GHC not do that can't be done in GHC?
12:49:40 <merijn> vanila: Suppose you implement a new haskell compiler, it has 1 cool feature, but the performance sucks compared to GHC
12:49:50 <merijn> vanila: You'd rather just implement your 1 cool feature into GHC
12:49:57 <vanila> yeah, that makes a lot of sense
12:50:00 <vanila> it's a shame though
12:50:02 <edwardk> anyways haskell-prime originally had the rule of thumb that proposals to it had to be implemented by at least one major compiler, so if there is only one real working compiler pushing the boundary then if you want that standardization process to continue we'd better keep implementing new things ;)
12:50:46 <merijn> vanila: Well, you could always start your own compiler :)
12:50:52 <kazagistar> gotta love the "standard" that just acts as delayed documentation for the one product
12:51:05 <vanila> haha
12:51:37 <kazagistar> but at least it lets us feel superior for all those non-standardized langauges
12:51:45 <srhb> I'm sure it would be easy to restart the standardization as soon as another serious and maintained compiler pops up and wants it.
12:51:51 <edwardk> simpson: i want a good tracing jit, incremental parsing, better tool integration, incremental retypechecking / type error slicing, better parallel compilation, etc. these things probably can all be hacked into ghc faster than i can write my 'turbo haskell' compiler to finish them up, but they are things i've definitely been exploring
12:51:52 <srhb> But without that motivation, meh.
12:51:54 <srhb> More shinies for us.
12:52:14 <dmj`> > return return "hello" 734213123123
12:52:16 <lambdabot>  No instance for (GHC.Show.Show (m0 a0))
12:52:16 <lambdabot>    arising from a use of ‚ÄòM141089404684551733128693.show_M1410894046845517331...
12:52:16 <lambdabot>  The type variables ‚Äòm0‚Äô, ‚Äòa0‚Äô are ambiguous
12:52:16 <lambdabot>  Note: there are several potential instances:
12:52:16 <lambdabot>    instance [safe] GHC.Show.Show a =>
12:52:32 <edwardk> kazagistar: well the standard we have really is a standard in the sense that it is a shared document that was used across a wide array of very different implementations
12:52:43 <vanila> I would actually like to implement a haskell compiler
12:52:54 <vanila> not to compete with GHC
12:52:56 <simpson> edwardk: "Good tracing JIT" means that you're going to either use PyPy/RPython or doom yourself to reinvent about 90% of it. The others sound like they can be shoehorned in by slowly replacing happy and alex with compatible tools.
12:53:02 <vanila> just because it's interesting
12:53:30 <simpson> I agree that a JIT is a very compelling example of something that would be awesome and that GHC's not geared towards producing.
12:53:31 <rodlogic> edwardk: is this what you were aluding to wrt to records proposal ? https://gist.github.com/nikita-volkov/6977841
12:53:43 <kazagistar> reinventing 90% of PyPy sounds really interesting though
12:53:44 <vanila> What about building a little haskell compiler that targets llvm?
12:53:48 <vanila> would that gety you good jit?
12:54:04 <edwardk> kazagistar: and i think a large part of the stagnation of haskell' comes from the fact that because it _is_ now mostly a monoculture the task is quite thankless. there are big things to document, e.g. MPTCs, type families, functional dependencies, but how to write them up is quite hard to figure out. how to standardize them when different implementations of MPTCs + FDs lead to different corner case behavior, etc. is rather
12:54:04 <simpson> No, LLVM's JIT is not good. :c
12:54:05 <edwardk>  thankless as nobody wants a standard that doesn't reflect the right way to think, but nobody can agree on the right way to think about those corners
12:54:25 <vanila> simpson, oh! I always hear about it when people say jit
12:54:53 <vanila> so what would be the right way to get good jit?
12:55:33 <edwardk> simpson: i would strongly disagree with both of those simplifications of what i said. using pypy or rpython would be a ridiculously bad design.
12:55:52 <edwardk> and yes, LLVM's jit isn't really a jit to speak of
12:56:09 <merijn> ok, if we're talking about impressive JIT stuff
12:56:10 <rodlogic> what about lambdachine?
12:56:20 <vanila> edwardk,the technology behind pypy seems really fascinating, do you think the same ideas would work well for haskell? what is it specifically thats bad about the design
12:56:23 <merijn> I need to pimp some things people in the Labs here are walking on
12:56:44 <merijn> Graal/Truffle on hotspot are pretty amazing, the only sad thing is being stuck to a minimal JVM
12:56:52 <simpson> edwardk: I agree that RPython is not a great design. I also think that it's the only JIT construction toolchain worth using, if you're going to use existing code. Anything else would have to be done from scratch.
12:57:23 <ChristianS> rodlogic: that anonymous records proposal reads quite charming
12:57:28 <edwardk> simpson: the code i have in this space is from scratch. but the key here is we're dealing with a lazy language, the execution model is _very_ different than these other jits
12:57:37 <edwardk> they are good for what they do but they do a thing we don't need ;)
12:57:37 <simpson> edwardk: That's a good point!
12:58:11 <simpson> Indeed, RPython has a concept of "virtualizable" values which are not fully evaluated during JIT tracing; you'd need to rework this for Haskell to take full advantage of non-strictness.
12:58:12 <rodlogic> simpson: first time I come across it based on a comment by edwardk above.
12:58:19 <edwardk> vanila: we're going to go pretty far off topic, but in short a hotpath/early spidermonkey style tracing jit works remarkably well for the spineless tagless g-machine, because it inlines indirect jumps, and every case expression evaluation in the STG becomes 2 indirect jumps which are huge pipeline stalls
12:59:08 <rodlogic> edwardk:  "i want a good tracing jit, incremental parsing, better tool integration, incremental retypechecking / type error slicing, better parallel compilation, etc" -- you should articulate these ideas so that there is at least a roadmap that can be discussed.
12:59:10 <edwardk> rodlogic: yes. it basically just kind of ignores all the thought everyone has put into the problem before and says 'here do this' without thought as to semantics / implementation details / history / how it tramples the language, etc.
12:59:46 <rodlogic> edwardk: I would love to help in some of these projects.
12:59:49 <edwardk> rodlogic: probably =) i've been thinking about taking some time to write up blog posts on 'things i want' =)
13:00:00 <merijn> edwardk: Do you know any good intro to tracing JIT implementation, especially for lazy languages?
13:00:27 <rodlogic> edwardk: I think one key part of that is to modularize GHC so that individual pieces can be swapped out without a painful merge/fork, etc
13:00:33 * hackagebot snaplet-sqlite-simple 0.4.8.2 - sqlite-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-sqlite-simple-0.4.8.2 (JanneHellsten)
13:00:35 * hackagebot csv-to-qif 0.3.2 - A small program that will read csv files and create qif files  http://hackage.haskell.org/package/csv-to-qif-0.3.2 (palo)
13:00:40 <edwardk> merijn: i learned by doing. the part for lazy languages is based on some hand converted STG traces i looked at and some code i have for tracing x86-64 assembly
13:00:48 <flyingfisch> hmm, I am having a difficult time understanding folds
13:00:58 <srhb> flyingfisch: Shoot! :-)
13:00:59 <edwardk> merijn: https://github.com/ekmett/jitplusplus
13:01:00 <flyingfisch> what exactly is meant by "folding up a list"?
13:01:16 <srhb> flyingfisch: Usually we mean reducing it, combining all the values into some value
13:01:21 <flyingfisch> hmm
13:01:26 <edwardk> merijn: old code, was a quick experiment in what it would mean to trace x86-64 assembly and generate x86-64 assembly cooperatively
13:01:30 <luite> merijn: you could read some lambdachine docs perhaps, but i have to admit that i don't know how much there is
13:01:45 <srhb> > foldl' (+) 0 [1..100] -- flyingfisch
13:01:47 <lambdabot>  5050
13:01:55 <srhb> flyingfisch: Also known as "sum"
13:01:59 <merijn> luite: Well, most likely it's just "aother thing I put on my read queue which I will never read", but still :)
13:02:05 <flyingfisch> srhb: so like map, but resulting in a single value rather than a list?
13:02:16 <srhb> flyingfisch: We can actually reproduce map with folds, but yes, usually.
13:02:25 <srhb> flyingfisch: (ie. folds are strictly more powerful)
13:02:28 <mauke> a list is a value
13:02:37 <vanila> edwardk, thank you for the insights
13:02:43 * flyingfisch is trying to absorb all this
13:02:46 <flyingfisch> hmm
13:02:55 <srhb> flyingfisch: You might want to look at the definition of foldr to "get it"
13:03:10 <flyingfisch> in the API docs?
13:03:13 <kazagistar> flyingfisch: sure... its like map, but it passes along an "accumulator" value as it looks at each item, and then returns that value at the end
13:03:18 <srhb> flyingfisch: Sure.
13:03:40 <edwardk> merijn: anyways the code there only had to be sound w.r.t x86-64 semantics not complete because it could always abort the trace and switch back to direct execution
13:03:58 <srhb> flyingfisch: What foldr does is basically this. It takes the first argument, a function, that receives each argument of the list and an accumulating parameter. The second argument is the start value of the accumulating parameter, and the last is the list to fold over.
13:04:04 <edwardk> merijn: for something higher level you'd have a much easier task, but would have to be complete
13:04:31 <flyingfisch> hey, i think i might be getting it now
13:04:32 <flyingfisch> so
13:05:06 <flyingfisch> foldr (\acc x -> acc + x) 0 [1,2,3]
13:05:21 <flyingfisch> that takes 0 as the accumulator to start with, right?
13:05:29 <flyingfisch> and then x is.. 3?
13:05:30 <mauke> > foldr (\acc x -> acc + x) 0 [1,2,3] :: Expr
13:05:32 <lambdabot>  1 + (2 + (3 + 0))
13:06:03 <mauke> acc is the current list element
13:06:06 <mauke> x is the accumulator
13:06:15 <flyingfisch> oh
13:06:18 <flyingfisch> hmm
13:06:35 <shachaf> "accumulator" is a bit of a stretch anyway
13:06:49 <mauke> > foldr f z [a,b,c]
13:06:50 <lambdabot>  Ambiguous occurrence ‚Äòz‚Äô
13:06:51 <lambdabot>  It could refer to either ‚ÄòL.z‚Äô, defined at L.hs:157:1
13:06:51 <lambdabot>                        or ‚ÄòDebug.SimpleReflect.Vars.z‚Äô,
13:06:51 <lambdabot>                           imported from ‚ÄòDebug.SimpleReflect‚Äô at L.hs:118:1-26
13:06:51 <lambdabot>                           (and originally defined in ‚Äòsimple-reflect-0.3.2:De...
13:06:57 <mauke> @undefine
13:06:57 <lambdabot> Undefined.
13:06:58 <mauke> > foldr f z [a,b,c]
13:07:00 <lambdabot>  f a (f b (f c z))
13:07:28 <merijn> edwardk: For the forseeable future my own lazy language is just fiction anyway, I just like to keep some awareness of cool state of the art language things :)
13:07:44 <edwardk> merijn: happy to chat about it some time =)
13:07:44 <mauke> first, f is called with 'a' and a lazy value representing the fold of the remaining list
13:08:03 <_dyrim> I'm trying to somehow get `IO [Int]` from stdin, but I can't quite figure out how to do it. Here's what I have now: fmap (fmap read . lines) getContents
13:08:20 <_dyrim> (I want a list of numbers entered on stdin, one per line)
13:08:28 <RegEchse> :t foldr f z [a,b,c]
13:08:29 <lambdabot> Expr
13:08:33 <RegEchse> o.o
13:09:12 <srhb> _dyrim: Looks right to me
13:09:15 <mauke> :t fmap (fmap read . lines) getContents
13:09:16 <lambdabot> Read b => IO [b]
13:09:17 <kazagistar> foldr (\word count -> length word + count) 0 ["Test", "Strings"]
13:09:26 <kazagistar> er
13:09:32 <kazagistar> >foldr (\word count -> length word + count) 0 ["Test", "Strings"]
13:09:41 <kazagistar> oh god, I am a derp today, I give up
13:09:46 <flyingfisch> just trying to wrap my head around all this..
13:09:47 <srhb> kazagistar: Needs a space after >
13:09:54 <flyingfisch> > foldr (\word count -> length word + count) 0 ["Test", "Strings"]
13:09:56 <lambdabot>  11
13:10:54 <L8D> :t pure
13:10:55 <lambdabot> Applicative f => a -> f a
13:10:57 <L8D> :t fmap
13:10:58 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:10:59 <merijn> edwardk: The biggest design issue I worry about is sane semantics for type checking concurrent. I personally feel haskell's forkIO is too weak for concurrent systems and I believe any modern language needs solid concurrency support
13:10:59 <luite> edwardk: do you think it should be at the assembly level? i've been thinking of doing a similar thing but only collect indirect call statistics (and possibly arity stats, evaluatedness stats) about the hot paths instead, then redo the core -> llvm step, applying RULES, and eventually replace the entry point of a hot path with one that branches to a specialized version
13:11:13 <srhb> L8D: You can /q lambdabot if you just need to ask for a few types :-)
13:11:18 <kazagistar> flyingfisch: try the second example on this page: http://chrisuehlinger.com/LambdaBubblePop/
13:11:29 <flyingfisch> ok
13:11:35 <L8D> Can someone explain the rudenmentary difference between pure, fmap and return?
13:11:43 <merijn> L8D: pure == return
13:11:43 <flyingfisch> that takes haskell code?
13:11:46 <srhb> L8D: pure and return are the same
13:11:53 <edwardk> luite: i don't really, except for the fact that when i was interfacing with third party code it was really really nice to be able to trace down into glibc, and optimize code i didn't write
13:11:56 <L8D> So what's the point of pure?
13:11:58 <srhb> Well, minus constraints
13:12:00 <srhb> :t pure
13:12:01 <lambdabot> Applicative f => a -> f a
13:12:02 <srhb> :t return
13:12:04 <lambdabot> Monad m => a -> m a
13:12:06 <joelteon> pure doesn't require a Monad constraint
13:12:08 <L8D> or...What's the point of return?
13:12:10 <merijn> > pure 'c' :: Maybe Char
13:12:11 <lambdabot>  Just 'c'
13:12:15 <edwardk> luite: i think in practice for an STG style tracing jit it probably belongs at the level of tracing a bytecode
13:12:18 <merijn> > return 'c' :: Maybe Char
13:12:20 <lambdabot>  Just 'c'
13:12:31 <joelteon> that's a good question. once AMP is out, will pure or return be removed?
13:12:41 <kazagistar> flyingfisch: its just a limited subset of haskell, but it is a good beginner visualization tool I think
13:12:43 <merijn> L8D: For historical reasons Applicative is not a superclass of Monad (Applicative was invented after Monad)
13:12:45 <srhb> I think return will have a default implementation of return
13:12:48 <edwardk> luite: the issue is ghc bytecode is pretty high level in the sense that if it needs to do anything exotic it calls out to real object code anyways, so you get limited benefits from tracing it
13:12:51 <L8D> I think pure is more semantic, but removing return would break soooo much code
13:12:53 <srhb> er, of pure
13:13:03 <joelteon> just deprecate return
13:13:08 <flyingfisch> kazagistar:  ok, how do i input my function in there?
13:13:24 <srhb> flyingfisch: Just click the bubbles and see what happens
13:13:33 <flyingfisch> oh ok
13:13:42 <L8D> So then...What's the point in having >>=, <*> and <$> ?
13:13:43 <flyingfisch> can i create my own bubble pop functions?
13:14:14 <kazagistar> flyingfisch: little buttons on the upper left of each expression
13:14:15 <luite> edwardk: i'm not sure if it should be bytecode, since indirect calls go through a generic apply function, that code can be hotswapped to collect statistics for a while. the bytecode is also pretty limited in what it can do, no unboxed tuples for example, so it'd  need to be extended for actual high performance code
13:14:41 <edwardk> luite: my point is it should be a bytecode, not what ghc produces as bytecode ;)
13:14:49 <edwardk> luite: so we're in violent agreement ;)
13:15:32 <bryanedds> hi edwardk!
13:15:35 <luite> edwardk: hehe okay. i was more thinking about whether bytecode is a good idea, vs v8 style instrumented assembly directly
13:15:36 <edwardk> luite: we should chat about a more interesting optimizer i'm hacking on offline some time
13:15:44 <flyingfisch> kazagistar: so it doesn't like lambda expressions?
13:15:47 <bryanedds> I'm finally making progress because of your help!
13:15:54 <edwardk> bryanedds: glad to hear =)
13:15:55 <bryanedds> big programmer <3 your way!
13:16:21 <kazagistar> flyingfisch: you might have to declare them as named function underneath in that box?
13:16:28 <flyingfisch> oh ok
13:16:36 <bryanedds> Also Cale helped me a lot too!
13:16:45 <Sorella> L8D: "What's the point of return?", was that an intentional pun? :)
13:17:05 <L8D> Sorella: sorry...I don't see the pun
13:17:19 <Cale> bryanedds: That's good to hear!
13:17:23 <Sorella> L8D: "point" is another name for "return"
13:17:44 <L8D> Ah...That's pretty funny actually...
13:17:45 <kazagistar> I guess the real question is, whats the point of no return?
13:18:00 <edwardk> luite: as for instrumented assembly that is an option, i'm actually slowly backing up from both of those representations towards something much.. messier but potentially with more optimization potential at runtime
13:18:10 <Sorella> kazagistar: pretty sure writing your first Haskell program qualifies :)
13:19:03 <kazagistar> I like how that answer works for both the language related and punny version of that question, well played
13:19:16 <lpaste> uniquenick pasted ‚ÄúHow do I write test without do syntax?‚Äù at http://lpaste.net/111571
13:19:50 <luite> edwardk: anyway the main problem i'd like see address is scalability of rewrite rules, it seems that the line between underinlining/specializing and overinlining has been getting thinner. the dominant strategy these days seems to be adding INLINE (or INLINABLE) everywhere until people start complaining about compile time / code size
13:19:54 <mauke> @undo do f <- asks foo; return $ f x
13:19:55 <lambdabot> asks foo >>= \ f -> return $ f x
13:19:58 <merijn> L8D: <$> exists because infix fmap is often really nice, <*> (like pure) was added after monad so should be identical to Monad's ap and >>= does something entirely different from the other two
13:20:06 <mauke> @. pl undo do f <- asks foo; return $ f x
13:20:06 <lambdabot> ($ x) `fmap` asks foo
13:20:21 <Sorella> <*> is really REALLY helpful to have.
13:20:31 <merijn> L8D: So I'm not sure why you're connecting those three operators in some way?
13:20:35 * hackagebot bsparse 0.0.4 - A simple unassuming parser for bytestring  http://hackage.haskell.org/package/bsparse-0.0.4 (VincentHanquez)
13:21:01 <jrc12> :tell
13:21:13 <jrc12> @tell vmeson
13:21:13 <lambdabot> What should I tell vmeson?
13:21:26 <jrc12> @tell vmeson Hello
13:21:27 <lambdabot> Consider it noted.
13:22:00 <edwardk> luite: that is directly related to the more complicated representation in question =)
13:22:48 <jrc12> seen edwardk
13:23:03 <L8D> couldn't we just use `fmap` ?
13:23:06 <jrc12> preflex: seen edwardk
13:23:10 <L8D> :t fmap
13:23:11 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:23:13 <L8D> :t (<*>)
13:23:14 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:23:15 <flyingfisch> so, in foldl¬†(\acc¬†x¬†->¬†acc¬†+¬†x) 0 [1,2,3], acc takes the last computed result of the function, and x is the current list item, which is taken from left to right?
13:23:27 <Sorella> L8D: fmap doesn't allow you to return an `f b`
13:23:30 <merijn> L8D: fmap does not do the same thing as <*> or >>= at all
13:23:38 <merijn> L8D: ANd <$> is literally fmap
13:23:50 <Sorella> L8D: so, you can't sequence two computations that return a monad as value
13:25:00 <edwardk> jrc12: i'm sure he's around here somewhere
13:25:34 <Sorella> L8D: as you can see from the types, <*>, <$> and >>= do entirely different things :)
13:26:07 <jrc12> edwardk: I'm trying to interact with the bots :P
13:26:09 <uniquenick> @pl asks foo >>= \ f -> return $ f x
13:26:09 <lambdabot> ($ x) `fmap` asks foo
13:26:11 <Sorella> (In fact, one of the neat things about Haskell is to be able to infer what a function does just by looking at the types. You can't do this in most statically typed languages)
13:26:29 <uniquenick> @pl test x = asks foo >>= \ f -> return $ f x
13:26:30 <lambdabot> test = (`fmap` asks foo) . flip id
13:26:30 <jrc12> i understand preflex and lambdabot are two of them
13:27:45 <merijn> preflex hasn't been around for months
13:28:09 <hughfdjackson> Sorella: *kinda* true ;)
13:28:19 <jrc12> ahh.. I'm looking at http://www.haskell.org/haskellwiki/IRC_channel
13:28:20 <flyingfisch> i think i got it now
13:29:03 <L8D> uniquenick: test x = fmap ($ x) (asks foo)
13:29:11 <bryanedds> What's your twitter handle, Cale?
13:29:14 <Sorella> hughfdjackson: well, not for all functions, okay. And for the fully parametric ones, only if you apply fast-and-loose reasoning. But it's still neater than most :)
13:29:25 <jrc12> merijin: is there a quick way to address to someone and tag them?
13:29:28 <benzrf> isnt ask id
13:29:29 <bryanedds> Edward, yours is @kmett, right?
13:29:31 <benzrf> :t ask
13:29:33 <lambdabot> MonadReader r m => m r
13:29:34 <edwardk> bryanedds: yes
13:29:37 <MP2E> code.haskell.org which forwards to community.haskell.org seems to be down :<
13:29:44 <Cale> bryanedds: I don't really use twitter.
13:29:58 <Cale> bryanedds: I have an account, but it's just for occasionally commenting on other people's posts
13:30:18 <bryanedds> Was just going to shout out the big thanks
13:30:34 <hughfdjackson> Sorella: definitely :)
13:31:05 <merijn> jrc12: eh, you just write out their name?
13:32:08 <bryanedds> well, I did the best I could :)
13:33:14 <jrc12> merijin: I imagined some interactive magic was present.
13:33:27 <ChristianS> jrc12: if you talk about adressing people in irc, tab completion is your friend
13:34:03 <jrc12> ChristianS: AHA. Thank you very much
13:35:36 * hackagebot leveldb-haskell 0.4.0 - Haskell bindings to LevelDB  http://hackage.haskell.org/package/leveldb-haskell-0.4.0 (KimAltintop)
13:37:32 <flyingfisch> is scanl like foldl except it returns all the steps as a list?
13:37:58 <zwer> yes
13:38:22 <bryanedds> Can I define a fold over any monad?
13:41:30 <Cale> :t foldM
13:41:31 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
13:42:14 <bryanedds> ah thanks
13:42:39 <bryanedds> hm, it's weird there's a list in there
13:42:45 <Cale> (assuming that's what you meant)
13:42:57 <bryanedds> is there a more abstract fold?
13:43:00 <Cale> Well, this is where the combining function produces an action in the monad m
13:43:03 <merijn> bryanedds: Sounds like you're looking for Traversable
13:43:11 <merijn> :t T.foldM
13:43:13 <lambdabot>     Not in scope: ‚ÄòT.foldM‚Äô
13:43:13 <lambdabot>     Perhaps you meant one of these:
13:43:14 <lambdabot>       ‚ÄòF.foldr‚Äô (imported from Data.Foldable),
13:43:16 <merijn> hmm
13:43:43 <shachaf> F.foldlM
13:43:59 <shachaf> Since traversals/folds are symmetric, you get foldM in both flavours.
13:44:00 <bryanedds> :t F.foldlM
13:44:01 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
13:44:10 <joelteon> lstrictlfoldMA
13:44:24 <merijn> bryanedds: Foldable/Traversable are generalisations of a lot of list functions
13:45:01 <bryanedds> ok, that info should get me started
13:45:25 <Cale> bryanedds: In Haskell, lists have quite a different flavour to them than they have in strict functional programming languages
13:45:36 * hackagebot leveldb-haskell 0.4.1 - Haskell bindings to LevelDB  http://hackage.haskell.org/package/leveldb-haskell-0.4.1 (KimAltintop)
13:45:44 <Cale> bryanedds: A list is basically a loop which is waiting to happen (via some higher order function)
13:45:57 <bryanedds> ah hm
13:46:30 <Cale> bryanedds: Just like loops either don't happen at all (because their precondition isn't met), or consist of a single iteration followed by another loop, lists are either empty or consist of a single element followed by another list.
13:47:02 <bryanedds> so it's a different, more general semantics than a strict list?
13:47:14 <Cale> We can have infinite lists, and lists needn't take up as much memory as their length would suggest
13:48:19 <Cale> (because of lazy evaluation, if you make use of each element of a list one at a time in the order in which they occur, it's possible that only one element need be in memory at any point)
13:49:33 <bryanedds> does that provide more operational generality for list types in Haskell?
13:49:47 <Cale> Well, it strongly flavours how they're used
13:49:57 <flyingfisch> what does Just do?
13:50:19 <Cale> bryanedds: But yeah, I guess they're strictly more general
13:50:31 <Cale> flyingfisch: Just is one of the data constructors of Maybe
13:50:38 <Cale> flyingfisch: Just :: a -> Maybe a
13:50:44 <flyingfisch> ok
13:50:45 <DanielDiaz> flyingfisch: builds a value of type 'Maybe a', from a value of type 'a'
13:50:48 <Cale> flyingfisch: the other one is  Nothing :: Maybe a
13:51:01 <bryanedds> So being coupled to a function that uses a list arg is more general than would initially appear, is what you're saying?
13:51:07 <Cale> So, if you have a value of type Maybe Integer, for example, it might be something like  Just 6
13:51:12 <Cale> or it might be Nothing
13:51:25 <Cale> bryanedds: Yeah
13:51:34 <bryanedds> ok :)
13:51:42 <Cale> bryanedds: Because you can turn other structures into lists lazily when you want to iterate over them
13:52:33 <bryanedds> and you can turn a recursive continuation into a list, too?
13:52:45 <Cale> and while you might pay for allocation of list cells, if you really do iterate over the list, those cells will become garbage immediately, and GHC's collector is very good at picking up this kind of short-lived garbage
13:53:34 <Cale> moreover, many higher order functions on lists have rewrite rules which fuse together operations that produce lists with operations that consume them to avoid the allocation altogether
13:54:09 <bryanedds> can you have those rewrites in a strict language?
13:54:14 <Cale> Yeah, you could
13:54:23 <Cale> I don't know many which have features like that
13:55:05 <Cale> Basically, GHC has a pragma which lets library authors extend the compiler with new simplification rules
13:55:22 <bryanedds> I sometimes worry about the raw efficiency of my F# code - though the .NET GC is excellant
13:55:30 <bryanedds> that's cool
13:56:30 <bryanedds> be interesting to bug hint rewrite specification bugs :)
13:56:35 <bryanedds> *hunt
13:57:01 <bryanedds> I just want macros in F#
13:57:21 <sagittarian> what is this weird stuff about needing to add things to the build-depends when i try to install lambdabot (via cabal)?
13:57:39 <sagittarian> could not find Network.URI
13:59:20 <matheus23> sagittarian: adding network-uri should solve the issue
13:59:28 <sagittarian> adding it to what?
13:59:34 <matheus23> though, you don't have the .cabal to your hand, right?
13:59:36 <matheus23> yeah
13:59:47 <sagittarian> no, i'm trying to do cabal install lambdabot
14:00:00 <matheus23> you might need to download the .git repo and do this, I'm not too experienced with it
14:00:00 <sagittarian> tried in a newfangled sandbox too, same issue
14:00:30 <matheus23> I just now that the network package (more or less) recently detatched the Network.URI module into another package named network-uri :)
14:00:36 <sagittarian> apparently it's something to do with network-uri being split off from network before version 2.6, how can i fixed it in a packaged thing like this?
14:00:56 <sagittarian> wonderful, so why doesn't cabal install lambdabot work?
14:01:00 <matheus23> try dowloading and changing the .cabal manually
14:01:09 <matheus23> the .cabal is broken, that's why
14:01:12 <sagittarian> ugh
14:01:14 <matheus23> (at least it seems to be)
14:01:24 <sagittarian> i should have just installed the haskell platform from source
14:02:11 <matheus23> I am actually here for a question on my own, though: Does anybody have any links to tutorials / examples of TChain and the like?
14:02:58 <matheus23> Also, how would you go about creating a TChain Queue with limited size, automatically dropping of elements being "too old"?
14:04:24 <sagittarian> how do i install a package that i downloaded as a tarball? runhaskell Setup.hs?
14:05:02 <matheus23> sagittarian: if there is a .cabal in the working dir, "cabal install" installs it
14:05:46 <stolaruk> matheus23: Have you read Parallel & Concurrent Programming In H?
14:05:50 <sagittarian> thanks, matheus23
14:06:10 <halvorg> hm. I have a list [(k, v)] which i'd like to combine into a list [(k, [v])] (for creating a map). any tips?
14:06:11 <antitom> @hoogle [a] -> [a] -> Bool
14:06:14 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
14:06:14 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
14:06:14 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
14:06:14 <matheus23> stolaruk: I looked at Concurrent Haskell, is that what you are talking about?
14:06:48 <stolaruk> matheus23: This. http://shop.oreilly.com/product/0636920026365.do
14:07:16 <matheus23> stolaruk: I need a whole book for that? :S
14:07:34 <stolaruk> You would probably benefit from the chapter on STM
14:08:21 <platz> bryanedds: you can make expression trees in F# (almost macros) which you can edit at runtime http://msdn.microsoft.com/en-us/library/dd233212.aspx
14:08:34 <pjdelport> halvorg: Easiest is probably a list comprehension?
14:08:41 <pjdelport> Depending on what you have to work with.
14:09:24 <stolaruk> halvorg: What will happen to the keys?
14:09:27 <halvorg> I did it in a different way instead.
14:09:55 <matheus23> stolaruk: I think he wants to merge items with the same key
14:10:06 <halvorg> yeah, that was the thought
14:10:08 <stolaruk> oh
14:10:13 <sagittarian> so, in the end, it seems that lambdabot is just broken and doesn't compile with ghc 7.8.3
14:10:35 <matheus23> sagittarian: did you edit the .cabal? What errors do you get?
14:10:54 <stolaruk> halvorg: I think you could use a fold
14:11:00 <matheus23> is lamdabot on github? There could be something on the issue tracker that could help you
14:11:12 <sagittarian> yeah, editing the .cabal fixed the network-uri issue
14:11:17 <sagittarian> yes there is: https://github.com/mokus0/lambdabot/issues/84
14:11:30 <sagittarian> no solution though, it looks like an outstanding bug
14:11:48 <halvorg> stolaruk: yep, I wound up doing htat. thanks
14:12:02 <stolaruk> np :)
14:13:12 <sagittarian> so i should downgrade to ghc 7.6 so that i can finally get lambdabot working?
14:13:58 <matheus23> you could try
14:14:47 <sagittarian> maybe i'll just use this thing here
14:15:39 * hackagebot Encode 1.3.7 - Encoding character data  http://hackage.haskell.org/package/Encode-1.3.7 (OtakarSmrz)
14:15:39 <sagittarian> @pl \x y -> fromList x == fromList y
14:15:39 <lambdabot> (. fromList) . (==) . fromList
14:18:06 <pjdelport> sagittarian:
14:18:06 <pjdelport> :t (==) `on` fromList
14:18:07 <lambdabot>     Not in scope: ‚ÄòfromList‚Äô
14:18:08 <lambdabot>     Perhaps you meant one of these:
14:18:08 <lambdabot>       ‚ÄòIM.fromList‚Äô (imported from Data.IntMap),
14:18:35 <sagittarian> oh yeah i was thinking of on for this earlier, then i forgot about it again
14:19:21 <sagittarian> did ghc 7.8 potentially break a lot of things?
14:22:39 <albeit> Is there a bounded Map-like datastructure that delete the oldest key/value when the size of the Map > N?
14:27:47 <catsup> is it possible to make ghci present the command line on other handles than stdin/out ?
14:28:57 <merijn> catsup: Use shell redirections to replace stdin/stdout with whatever you want?
14:29:57 <catsup> merijn: i want the process i'm running inside ghci to have access to stdin/stdout, and put the ghci command line on different handles
14:30:48 <benzrf> catsup: sounds difficult :o
14:30:49 <flyingfisch> what good is the Maybe type?
14:30:53 <benzrf> flyingfisch: very good
14:31:03 <flyingfisch> hmm
14:31:08 <flyingfisch> what is it used for?
14:31:15 <benzrf> flyingfisch: when there might not be a result
14:31:17 <hughfdjackson> flyingfisch: it tells you when you might have missing data, and gives you tools for dealing with that safely
14:31:29 <flyingfisch> concrete example?
14:31:30 <hughfdjackson> in java, for instance, any value might be null, so you run the risk of a runtime error anyway
14:31:33 <hughfdjackson> *anywhere
14:31:37 <benzrf> flyingfisch:
14:31:40 <benzrf> safeHead [] = Nothing
14:31:45 <benzrf> safeHead (x:_) = Just x
14:32:03 <hughfdjackson> in haskell, you're gauranteed that that state of absence is something you pretty much *have* to deal with by default
14:32:04 <flyingfisch> hmm
14:32:18 <benzrf> @hoogle Maybe
14:32:21 <lambdabot> Prelude data Maybe a
14:32:21 <lambdabot> Data.Maybe data Maybe a
14:32:21 <lambdabot> Data.Maybe module Data.Maybe
14:32:23 <benzrf> hm
14:32:24 <hughfdjackson> :) at compile time, you can have confidence you're safe from a whole class of runtime errors that used to make me cry into my desk
14:32:31 <flyingfisch> Nothing is the same as nil or null in other languages?
14:32:36 <benzrf> flyingfisch: not quite
14:32:44 <hughfdjackson> flyingfisch: it represents the same general idea, yes - a missing value
14:32:46 <flyingfisch> oh
14:32:46 <benzrf> flyingfisch: it is also used to indicate a lack of value
14:32:52 <flyingfisch> hmm ok
14:32:53 <catsup> not at all really, because it's a distinct type rather than a value that exists in every type
14:32:53 <benzrf> flyingfisch: but it has a separate type, unlike null
14:33:03 <jle`> Maybe is literally the best thing ever
14:33:05 <jle`> Maybe
14:33:11 <flyingfisch> >:t Nothing
14:33:14 <hughfdjackson> what catsup said is important - the distinction is that you *know* when values might be missing, and when they can't be
14:33:14 <benzrf> flyingfisch: a value of type a is either an actual value of type a, or it's an error
14:33:17 <flyingfisch> > :t Nothing
14:33:18 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
14:33:19 <benzrf> there's no weird null in between
14:33:20 <benzrf> flyingfisch: no >
14:33:25 <benzrf> flyingfisch: use > only for expressions
14:33:28 <benzrf> :t Nothing
14:33:30 <lambdabot> Maybe a
14:33:30 <flyingfisch> oh
14:33:33 <flyingfisch> ok
14:33:38 <jle`> the idea is that you can't use a (Maybe a) value unless you explicitly handle the possible null case
14:33:38 <benzrf> Nothing is polymorphic
14:33:41 <jle`> there are no accidents
14:33:49 <jle`> no accidents possible from forgetting to handle it
14:33:50 <flyingfisch> oh wait
14:33:53 <benzrf> flyingfisch: ?
14:34:33 <flyingfisch> so the type signature of safeHead would be safeHead :: Maybe a?
14:34:41 <jle`> [a] -> Maybe a
14:34:47 <flyingfisch> oh yeah
14:34:53 <flyingfisch> forgot the param
14:34:56 <jle`> safehead xs :: Maybe a
14:34:58 <benzrf> :t Just
14:34:59 <flyingfisch> now i get it
14:34:59 <lambdabot> a -> Maybe a
14:35:04 <flyingfisch> cool
14:35:07 <jle`> > listToMaybe [1..10]
14:35:08 <lambdabot>  Just 1
14:35:10 <jle`> > listToMaybe []
14:35:12 <lambdabot>  Nothing
14:35:17 <benzrf> NT!
14:35:20 <exio4> a good name for safeHead
14:35:20 <jle`> oops
14:35:30 <jle`> yeah, it's a natty
14:35:39 <jle`> @free listToMaybe
14:35:40 <lambdabot> $map_Maybe f . listToMaybe = listToMaybe . $map f
14:36:00 <jle`> can we just use cute names for all the scary math terms now
14:36:03 <volty> there's nothing wrong with nil or null in other langs ‚Äî it all depends on the way you implement, on what you check against, on what is representing absence & null
14:36:06 <jle`> maybe that'll help haskell's reputation
14:36:12 <benzrf> :t (<<=)
14:36:13 <lambdabot>     Not in scope: ‚Äò<<=‚Äô
14:36:14 <lambdabot>     Perhaps you meant one of these:
14:36:14 <lambdabot>       ‚Äò<=‚Äô (imported from Data.Ord), ‚Äò<<<‚Äô (imported from Control.Arrow),
14:36:16 <srhb> jle`: Like "burrito"
14:36:16 <benzrf> hm
14:36:18 <hughfdjackson> flyingfisch: it gets better than what's said here - if you're familiar with monads, then Maybe is is one of them
14:36:21 <jle`> monie
14:36:23 <benzrf> :t (=>>)
14:36:24 <jle`> funky
14:36:25 <lambdabot>     Not in scope: ‚Äò=>>‚Äô
14:36:25 <lambdabot>     Perhaps you meant one of these:
14:36:25 <lambdabot>       ‚Äò>>‚Äô (imported from Control.Monad.Writer),
14:36:29 <benzrf> hughfdjackson: i dont think thats too helpful m8
14:36:30 <jle`> noidie
14:36:35 <hughfdjackson> benzrf: ;) fair enough
14:36:45 <flyingfisch> hughfdjackson: trying to get to the point where I can understand monads ;)
14:36:47 <jle`> Maybe is a Funky
14:37:03 <shachaf> flyingfisch: Did you see what the FAQ says about that?
14:37:05 <srhb> jle` a monie is a noidie in the catty of endofunkies?
14:37:05 <shachaf> @faq
14:37:06 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
14:37:15 <srhb> I already approve.
14:37:17 <flyingfisch> didn't know about the FAQ
14:37:27 <jle`> if you have an (a -> b), you get a (Maybe a -> Maybe b) for free
14:37:36 <jle`> so now you can use all your (a -> b) functions on (Maybe a)'s...no problem!
14:37:44 <jle`> so it's as if the Maybe isn't even there
14:37:57 <jle`> thanks to funky properties
14:38:01 <srhb> :D
14:38:34 <jle`> with some neat funky laws
14:38:38 <ninjaF> Good places to do an internship working in haskell/fp? Preferable in the us
14:38:44 <sagittarian> so did we ever find out if you can declare a type synonym with a constraint
14:38:59 <sagittarian> i.e., a type synonym for a list of Ords
14:39:27 <Ralith> ninjaF: http://www.tsurucapital.com/en/jobs.html#programmer
14:40:26 <jle`> srhb: yes, that's exactly it
14:40:59 <jle`> anyways, the Functor, Applicative, and Monad instances work together to effectively make Maybe "invisible", so you can use it with normal functions on normal values
14:41:11 <srhb> sagittarian: And I think you (sorta) need dependent types for that.
14:41:15 <jle`> so you get the safety of out-of-band nulls...for free
14:41:24 <jle`> "free"...as in, they have a minimal cost of working with
14:41:31 <jle`> and you can bring all of your existing tooling with you
14:42:11 <volty> a door-to-door seller of Maybe ? :)
14:42:22 <srhb> sagittarian: On the plus side it doesn't matter much because you can constrain your functions to only work on lists where the elements have Ord instances.
14:42:52 <volty> it does matter - always
14:43:19 <srhb> volty: Hm?
14:43:22 <volty> what you can do in a type constructor shouldn't be left to functions
14:43:33 <srhb> Right, but it is.
14:43:37 <srhb> (Sort of)
14:43:53 <srhb> You can always start hacking away with some more powerful stuff in Haskell, but it's not as pain-free as what I think was asked for
14:43:58 <sagittarian> yes but how do i get a type synonym for it?
14:43:58 <merijn> volty: Type constructors don't "do" anything, ever
14:44:06 <sagittarian> is type Foo = [] legit?
14:44:24 <benzrf> sagittarian: yes
14:44:31 <merijn> sagittarian: yes, where "Foo :: * -> *"
14:44:33 <srhb> sagittarian: or type Foo a = [a]
14:44:53 <merijn> @let type Foo = []
14:44:53 <sagittarian> ah that's what i wanted
14:44:56 <lambdabot>  Defined.
14:44:57 <volty> yes, i'm saying that it is a much better idea to fix it in the definition, whenever possible, hoping that in the future it will be possible to do what is not now - that's all
14:44:58 <sagittarian> thanks, that's probably good enough
14:44:59 <merijn> :k Foo
14:45:00 <lambdabot> * -> *
14:45:25 <sagittarian> wait, so how would you use Foo now?
14:45:32 <srhb> volty: Well, GADTs sort of, but of course we could want more power.
14:45:34 <merijn> volty: It is unlikely to ever be possible in the future, it is widely considered a bad idea
14:45:39 <srhb> sagittarian: [1,2,3] :: Foo Int
14:45:41 * hackagebot freenect 1.2 - Interface to the Kinect device.  http://hackage.haskell.org/package/freenect-1.2 (ChrisDone)
14:45:51 <sagittarian> okay
14:46:14 <volty> merijn: i'm curious ...
14:46:17 <srhb> sagittarian: If you want another kind of safety you're going to have to redefine the type entirely and hide the (dumb) constructors
14:46:35 <srhb> Which is of course not very satisfactory, but it works.
14:46:50 <merijn> volty: Well, what kind of restrictions for data constructors did you have in mind?
14:47:00 <hexagoxel> wait wait wait.. cabal package version a.b is not equal to a.b.0 ?
14:47:18 <volty> on the class (Ord, Eq) ?
14:47:24 <sagittarian> i was actually looking more for clarity than safety, so I guess i'll just drop the Ord constraint
14:47:27 <merijn> volty: To accomplish what?
14:48:47 <merijn> volty: Take Set, which is an ordered Set, it's functions require an Ord constraint to use '<', compare, etc. what would a restriction on the datatype accomplish?
14:48:51 <volty> to go ahead given for granted what whatever I subtype from that one has to satisfy that class's constraints, whenever used enough to declare the type (without adding ord, eq) etc etc
14:49:07 <merijn> volty: There is no such thing as subtyping
14:49:20 <srhb> volty: If the types make use of the methods of those classes, it happens automatically, after all.
14:49:22 <volty> call it whatever you please
14:49:49 <merijn> volty: But the point is that you can't leave of the constraints of function even if you put them on datatypes
14:50:05 <merijn> volty: Because that's not something haskell's internal model allows
14:50:43 <merijn> So if you restrict datatypes they now no longer work with some types, but worse, you STILL have to add constraints to all your functions
14:51:04 <volty> yes - that's because I said I hope it will be possible one day ...  the models change with time ... who knows
14:51:06 <merijn> volty: Keep in mind that, unlike what goes on in OO languages, functions are *not* stored with the data type the belong too
14:51:36 <merijn> Storing functions with data types is very expensive, it's why C++ compilers spend a lot of time trying to eliminate virtual lookups, etc.
14:51:37 <volty> am I allowed to hope that this one is going to change too ?
14:51:38 <volty> :)
14:52:19 <merijn> volty: You can hope, but it's less likely to change than Scala is to become a purely functional language
14:52:24 <luite> storing them isn't the expensive part usually :)
14:52:38 <volty> oo is great, even if implemented just as a syntactic sugar
14:52:41 <merijn> luite: Sure, the looking up is, but that's implicit and what volty wants
14:52:47 <merijn> volty: I disagree
14:52:56 <exio4> volty: it is a neat domain-specific-language
14:53:06 <merijn> volty: I think OO is one the most terrible setbacks programming ever encountered
14:53:22 <merijn> And I become more and more convinced of this fact as time goes by
14:53:26 <srhb> Maybe not OO in itself, but the culture it begat. And we're only just about coming to realize how terrible it was.
14:53:38 <volty> i think that pedantic purism (that's always been there) is the worst thing ... :)
14:53:45 <sagittarian> is there anything you can do with an OO inheritance hierarchy that you can't do with typeclasses?
14:53:59 <srhb> sagittarian: You probably should not be doing that with typeclases.
14:54:02 <Arahael> Am I correct to believe that the haskell warp webservice is poorly documented, and that (if documentation is important), I should use snap?
14:54:09 <merijn> sagittarian: I dunno, but I consider inheritance the dumbest CS idea of the last century
14:54:17 <srhb> Arahael: warp is a server, snap is a framework
14:54:34 <merijn> sagittarian: It is nearly impossible to reason about code in the presence of inheritance
14:54:35 <volty> sagittarian: i do not buy those tricky arguments
14:54:42 <exio4> how can you implement a monad typeclass with objects?
14:54:49 <Arahael> srhb: I want something very fast, yet (relatively) low level.
14:54:56 <Arahael> srhb: I don't actually want a framework.
14:55:00 <merijn> volty: I'm not a smart man, I prefer to be able to understand and reason about my code and it's invariants
14:55:05 <volty> it is all about handling the complexity, and not about that you can do it elsewhere too
14:55:06 <merijn> volty: OO destroys your ability to do so
14:55:12 <Arahael> srhb: So ,it sounds like warp isn't what I want, then.
14:55:14 <srhb> Arahael: What are you going to be serving?
14:55:28 <Arahael> srhb: A single 'web app'.
14:55:35 <sagittarian> merijn, why is that, because you don't know where a method was defined when you see it used?
14:55:43 <srhb> Arahael: OK. Well, first I was corrected for saying Snap is not a server (because snap-server is)
14:55:56 <merijn> volty: Right, and my argument is that OO destroys the only provably working tools for tackling complexity. That's laws, equational reasoning and generic abstraction
14:55:57 <flyingfisch> :m Data.Map
14:56:07 <mkscrg> Arahael: if you're looking for a low-level http server, warp is a great option
14:56:09 <flyingfisch> :t Map.Map Int
14:56:10 <lambdabot> Not in scope: data constructor ‚ÄòMap.Map‚Äô
14:56:10 <lambdabot>     Not in scope: data constructor ‚ÄòInt‚Äô
14:56:10 <lambdabot>     Perhaps you meant one of these:
14:56:10 <volty> I am not biased -- the time will tell
14:56:20 <merijn> sagittarian: And because which method gets called and what it's effects are is not statically knowable or checkable
14:56:29 <volty> merijn: you have to prove that one with facts
14:56:36 <mkscrg> Arahael: to use it, you want to read the docs for the `wai` package
14:56:44 <volty> go and implement something like rails in haskell,
14:56:44 <Arahael> mkscrg: Thanks.
14:56:52 <volty> try to handle that complexity,
14:57:01 <srhb> Arahael: I would not be so afraid to look at one of the frameworks. They really are quite lightweight. Both Snap, Scotty and Happstack might suit you
14:57:08 <volty> convince the people that hte haskell's one is better etc etc
14:57:11 <NikolajK> did anyone ever find Maybe/Just/Nothing to be inapppropriate names for this type/functor?
14:57:19 <Arahael> srhb: I mean, I don't want a framework like ASP.NET.
14:57:24 <srhb> NikolajK: Ever? Probably
14:57:24 <volty> i like haskell more and more, it is intriguing
14:57:25 <merijn> volty: I think the web as-is is as terrible as it is for most of the same reasons OO is
14:57:28 <srhb> Arahael: It's nothing like that imo.
14:57:29 <luite> merijn: but typical haskell code (compiled by ghc) has far more indirect calls than C++ code, and you can't get rid of indirect calls in the general case, even typeclass dicts cannot be optimized out in all situations if you had whole program analysis
14:57:30 <Arahael> srhb: Nor one like django.
14:57:35 <srhb> Arahael: Nor that. :-)
14:57:38 <hughfdjackson> NikolajK: i like it more than scala's Option/Some/None
14:57:42 <Arahael> srhb: Then I _might_ be happy. :)
14:57:44 <hughfdjackson> Some/None is okay, but maybe > Option
14:57:51 <volty> challenging , but .... do not try to sell solution-for-all :)
14:57:56 <srhb> Arahael: But if you want the barebones experience, I think Happstack and Scotty really provide them. I used those initially, now I'm using Snap.
14:58:05 <srhb> Arahael: (For the same reason that you want them, I think)
14:58:09 <merijn> volty: I'd rather not implement something like Rails, because I try to avoid the web like the plague
14:58:12 <volty> yes, the home sapiens is terribile as it is :)
14:58:38 <NikolajK> I just realized that the Haskellwikis natural numbers in terms of catamorphism uses this type in disguise
14:58:39 <NikolajK>   data NatF a = S a | Z deriving (Eq,Show)
14:58:39 <NikolajK>   instance Functor NatF where
14:58:39 <NikolajK>     fmap f Z = Z
14:58:39 <NikolajK>     fmap f (S z) = S (f z)
14:58:48 <volty> that's the world, my friend, the world outside is composed of web and guis, not of haskell's IO World
14:58:48 <Arahael> srhb: One thing I want, is to be able to use http1.1, and I _need_ concurrency - a single threaded server just won't work.
14:59:11 <Arahael> srhb: As the app will be making many ajax callbacks, and all that crazyness.
14:59:22 <merijn> volty: I get paid to write distributed systems and high performance software. The idea that "the web is the world" is BS
14:59:24 <srhb> Arahael: afaik snap handles each request in its own lightweight thread
14:59:32 <srhb> Arahael: I don't know about the rest, but I would assume something similar
14:59:33 <Arahael> srhb: Nice.
14:59:50 <NikolajK> So with
14:59:50 <NikolajK> newtype Mu f = InF { outF :: f (Mu f) }
14:59:50 <NikolajK> type Nat = Maybe NatF
15:00:04 <volty> you take into account just yourself (and you clients) while I am taking into account the whole humankind :)
15:00:15 <hughfdjackson> does anyone have a take on why Async isn't a monad transformer?
15:00:24 <Arahael> srhb: Would you be able to suggest that snap is better known and more common?
15:00:39 <hughfdjackson> I can understand why it's not a Monad (as in other languages with a future-like value, which is the gap async seems to fill)
15:00:39 <merijn> volty: I can guarantee you that most complex software being written is not "the web", that's just the only thing the HN startup hippies all talk about non-stop
15:00:40 <NikolajK> hughfdjackson: not sure if Some is good either
15:00:42 * hackagebot leveldb-haskell 0.4.1.1 - Haskell bindings to LevelDB  http://hackage.haskell.org/package/leveldb-haskell-0.4.1.1 (KimAltintop)
15:00:45 <srhb> Arahael: I would say the community has been positive to me. And that matters a lot for me. :)
15:00:56 <volty> pizza is s because i eat only spaghetti --- but that's bellow the  spaghetti logic  :)
15:00:58 <hughfdjackson> because it has to return an IO type.. but if it was a monad transformer, wouldn't that be really useful?
15:00:59 <luite> merijn: since laziness makes things that would just be a value lookup (add+load) in other languages an indirect call
15:01:17 <merijn> volty: I think there's plenty to gain for humanity by having more robust networks, operating systems and programming languages for those things
15:01:24 <volty> you are not the only one that can judge what is more complex
15:01:54 <Arahael> srhb: Ok, snap it is then. :)
15:01:56 <hughfdjackson> then you could compose your async computations using do-notation, and later call `runAsync` on the whole thing to actually get the side-effects
15:01:56 <srhb> Arahael: Take a loot at this: http://snapframework.com/docs/tutorials/snap-api
15:02:02 <hughfdjackson> :| unless I'm missing something - thoughts?
15:02:05 <srhb> Arahael: If you like how that example looks, Snap might very well be for you
15:02:25 <volty> yes, but you need ppl to write those new robust stuff
15:02:30 <hughfdjackson> NikolajK: i'm struggling to think of any word that isn't 'Some' or 'Just' - OneOf? An? :p
15:02:40 <Arahael> srhb: snap's for me :)
15:02:42 * Arahael has to go now.
15:02:48 <NikolajK> hughfdjackson: New
15:02:59 <srhb> hughfdjackson: I've seen None | An
15:03:00 <flyingfisch> so i did import qualified Data.Map as Map, then tried :t Map.Map in GHCI, and now I get an error
15:03:02 <flyingfisch> why?
15:03:15 <NikolajK> Fresh
15:03:22 <flyingfisch> "Failed to load interface for `Map'
15:03:25 <flyingfisch> "
15:03:25 <hughfdjackson> srhb: I quite like that, to be honest
15:03:30 <NikolajK> Another
15:03:40 <srhb> hughfdjackson: An Horse. :(
15:03:50 <srhb> My mental ear bleeds.
15:03:54 <hughfdjackson> srhb: that's what amuses me so much about it
15:03:58 <srhb> Haha, ok. :P
15:04:00 <sagittarian> flyingfisch, what map are you trying to get?
15:04:09 <flyingfisch> Data.Map.Map
15:04:19 <sagittarian> flyingfisch, that's a type
15:04:21 <flyingfisch> since i qualified imported it as Map
15:04:35 <flyingfisch> sagittarian: oh?
15:04:35 <srhb> You shouldn't be getting that error anyway though
15:04:40 <srhb> Does :i Map.Map work?
15:04:44 <hughfdjackson> flyingfisch: i don't think it exports the constructor
15:04:52 <hughfdjackson> use `fromList [("hi", "there")]`
15:04:56 <flyingfisch> :i Map.Map works
15:05:02 <NikolajK> I was always planning to writen importat paper, where I call all concepts (say in an equation) by letters, where writing down an (eventually obvious) equation results in a swearword
15:05:08 <srhb> Oh, then the error message is just weird in your version
15:05:09 <NikolajK> I'll troll math forever
15:05:12 <sagittarian> or use Map.empty, or Map.singleton
15:05:31 <hughfdjackson> oh, sorry, in your case.. Map.fromList
15:06:05 <hughfdjackson> flyingfisch: there's a difference between a type being exported, and the constructor for that type being exported, as i understand it
15:06:15 <flyingfisch> hughfdjackson: ok
15:06:19 <srhb> hughfdjackson: Yes, but I don't think the error (should) be that
15:06:24 <srhb> It should be a not in scope error
15:06:29 <hughfdjackson> the only way (correct me if i'm wrong) to make a map is to use one of these helper methods or values :) but you still get to inspect the type
15:06:35 <hughfdjackson> srhb: eh, it is for me too, why i try it in ghci
15:06:43 <srhb> In mine:  Not in scope: data constructor ‚ÄòMap.Map‚Äô
15:06:59 <srhb> Not the weird failed to load interface for `Map'
15:07:02 <hughfdjackson> ooh, right - that *is* what i get
15:07:48 <hughfdjackson> sorry, my reading comprehension is suffering :#
15:07:48 <srhb> It might just be an old GHCI bug I guess. Nothing too bad.
15:10:48 <zipper> Hey I am running cabal repl in a sandbox which has quickCheck installed. However when I try `:m + quickCheck` it fails. What could be the issue?
15:11:20 <srhb> zipper: QuickCheck?
15:11:29 <zipper> srhb: Yes
15:11:38 <srhb> zipper: As in, did you write it with an uppercase Q?
15:11:52 <zipper> srhb: No
15:12:05 <srhb> zipper: Well, modules are capitalized
15:12:32 <zipper> srhb: It couldn't find module QuickCheck either.
15:12:40 <srhb> zipper: Is it in the cabal file?
15:12:58 <geekosaur> isn't it Test.QuickCheck?
15:13:00 <srhb> zipper: (The module is actually Test.QuickCheck)
15:13:02 <srhb> heh
15:13:26 <zipper> srhb: Test.QuickCheck loaded
15:13:30 <zipper> srhb: Thanks
15:13:57 <zipper> Why would it be test.QuickCheck instead of just QuickCheck?
15:13:58 <zipper> SMH
15:14:13 <srhb> zipper: Because the designers wrote it so.
15:14:23 <srhb> zipper: You can always check the docs on Hackage to see for yourself.
15:15:06 <zipper> srhb: Thanks
15:27:08 <sagittarian> is there a builtin function that will turn False into 0 and True into 1?
15:27:53 <shachaf> fromEnum
15:28:19 <sagittarian> cool, thanks shachaf
15:28:21 <hughfdjackson> zipper: the name of packages exported don't necessarily match AT ALL with the library name
15:28:30 <hughfdjackson> :p i find that a bit frustrating too
15:29:10 <yyttr3> How do I uninstall cabal packages?
15:30:19 <Cale> yyttr3: ghc-pkg unregister foo
15:31:15 <yyttr3> Will that actually uninstall or just remove reference in ghc?
15:31:48 <volty> a nice question :)
15:32:37 <yyttr3> Well, it says unregister not uninstall so I have to assume. I'm googling.
15:32:55 <glguy> It just unregisters
15:33:14 <yyttr3> So how do I uninstall?
15:33:22 <glguy> delete the relevant files
15:33:28 <yyttr3> Manually?
15:33:29 <volty> naaaa
15:33:58 <glguy> I think someone had a "cabal uninstall" utility on hackage, you might look
15:34:17 <volty> where are the Maybers now ?
15:34:28 <glguy> The packages are pretty localized, however, so it's not a big task to delete a package
15:34:28 <volty> (and, btw, I am not flaming, eh!!!)
15:35:07 <volty> maybe there, maybe here, maybe everywhere, but there's not even an uninstall ???
15:38:06 <glguy> The two thing you'd want to delete are the install library bits (on my computer that would be) ~/Library/Haskell/ghc-7.8.3/lib/lens-4.3.3 , and possibly the installed documentation. and I have no idea wtf you are talking about with maybes
15:38:40 <glguy> or Google around, it's possible there's some slick new way that no one has brought up in channel yet
15:39:23 <volty> for the wtf-er http://en.wikipedia.org/wiki/Package_manager
15:39:33 <yyttr3> glguy: I'm looking, thank you
15:39:55 <yyttr3> cabal isn't a package manager volty...
15:40:16 <volty> is there a package manager, please ?
15:40:44 <yyttr3> apt-get
15:42:00 <volty> about maybes: so many lines above about how wonderful is Maybe, how powerful a system with Maybe is ... Maybe those should start writing something useful before praising Maybes
15:42:25 <volty> apt-get is debian's pm
15:49:27 <yyttr3> volty: Do you even know anything about haskell?
15:50:34 <joffee> hello. I have module X that imports module Y. how can I make X reexport all the symbols module Y exports?
15:51:50 <merijn> joffee: Add an explicit export list to X that has "module Y" as an export
15:52:20 <joffee> merijn: nothing less clumsy?
15:52:27 <merijn> How is that clumsy?
15:52:30 <volty> I am learning / studying it  (but I do not buy into the tactics of bizarre over-complicators) ? Do you have factual objections about what I said before?
15:52:37 <joffee> I have to maintain two identical lists
15:52:51 <merijn> joffee: No, you don't need to explicitly list the imports from Y
15:53:13 <merijn> joffee: But X needs to have an export list, else where are you going to add the "module Y" export too? :)
15:53:24 <joffee> I have to maintain same export list in X and Y
15:53:32 <volty> ... and I found plenty of nice, pragmatic, people here
15:53:34 <merijn> joffee: No
15:53:37 <joffee> hmm
15:53:37 <RegEchse> no, just export literally "module Y"
15:53:44 <joffee> let me read that again
15:53:47 <Cale> volty: huh? What's all this about Maybe?
15:54:02 <merijn> joffee: "module X (SomeXConstructor, SomeYConstructor, module Y) where {- code for X here -}"
15:54:04 <Cale> volty: I'm not sure who you're even referring to
15:54:18 <merijn> joffee: Where SomeXConstructor/SomeYConstructor are defined in module X
15:54:25 <volty> to whom asked, you can just stick off if not interested
15:54:47 <merijn> joffee: That ill export everything you imported from Y from X
15:54:53 <joseph07> Cale: he was responding to yyttr3 "volty: Do you even know anything about haskell?"
15:55:06 <joffee> exactly what I was after, thanks
15:55:28 <Cale> volty: Your tone is not appropriate here. Try to be more friendly and courteous.
15:55:28 <yac> volty: well it's a functor so you can do functor stuff to it
15:56:46 <yyttr3> I feel like any over complication you see might be due to the fact that you are not use to it. Object orientation can be very had to grasp if you have never seen it before. The benefits for the extra abstraction of OOP are amazing, just the same with Monads/Functors/Applicative Functors.
15:57:17 <geekosaur> does anyone know what's up with code.haskell.org and lambda.haskell.org, by any chance? I saw Henning asking about c.h.o on -cafe earlier but no response...
15:57:18 <yyttr3> volty: In sort, the abstraction is well worth it.
15:57:21 <Cale> I'm not sure what it is that's considered overcomplicated in this discussion
15:57:47 <volty> yac: we can all do whatever we like, the mine was about the Just "rumbling" (around maybes) -- I can't see what I coudn't say this one of mine while they can write tons of lines about Nothing
15:58:42 <volty> yyttr3: maybe, I am curious, I will go on for sure, but only for fun (not for production), at least for now
15:58:54 <yyttr3> volty: I'm sorry..but what did you even just say?
15:59:17 <shachaf> geekosaur: I think they were talking about it in #haskell-infrastructure earlier.
15:59:29 <hughfdjackson> volty: if it helps, i (and my colleagues) use the scala equivalent daily (the Option monad/functor) - and it's been *awesome* in production
15:59:35 <shachaf> But either way that's a good place to ask.
15:59:40 <yac> geekosaur: maybe some infra updates due to bash cve?
15:59:47 <Cale> volty: Maybe is extraordinarily simple
15:59:59 <volty> I was objecting about: 1) they maybe-ers (over-dosed optimists & abstract theorists  2) no PM that can uninstall a package etc etc
16:00:04 <geekosaur> I'm told c.h.o was down yesterday as well, that seems a bit early for the bash cve?
16:00:15 <volty> Cale: pls do not try to explain to me what is Maybe
16:00:20 <Cale> volty: I don't get what you're trying to say about Maybe
16:00:29 <Cale> It's literally a one-line definition :P
16:00:35 <yyttr3> Volty: Do you understand Monads?
16:00:35 <Cale> data Maybe a = Nothing | Just a
16:00:41 <Cale> That's really all there is to it.
16:00:46 * hackagebot phantom-state 0.2.0.0 - Phantom State Monad Transformer. Like State Monad, but without values.  http://hackage.haskell.org/package/phantom-state-0.2.0.0 (DanielDiaz)
16:00:47 <volty> Cale: there could be no socket for the two of us, just unstick
16:00:57 <Cale> What?
16:01:05 <geekosaur> Maybe is simple but the concept it opens up is pretty big. but you need to be able to see the forest, not just the trees
16:01:39 <Cale> I don't think the concepts it opens up are even all that big :P
16:01:42 <yac> Cale: no it's not. Then there is the intuition around fmap and stuff.
16:01:47 <volty> I do not have problems with maybe, nor with monads
16:01:55 <Cale> okay
16:02:12 <Cale> So what are you complaining about?
16:02:21 <volty> are you children affected by the ¬´teachers syndrome¬ª ?
16:02:33 <yyttr3> volty: If you think haskell is over-complicated, don't you think OOP is over used and complicated as well?
16:02:53 <exio4> I only can say one thing, maybe + applicative = lovely :)
16:02:59 <kazagistar> its more like Maybe replaces the null fuckup of other languages
16:03:08 <Cale> volty: Many people would consider being called a child to be an insult.
16:03:19 <slack1256> phantom-state... that got me interested
16:03:29 <Cale> volty: Please be nice to others
16:03:46 <hughfdjackson> slack1256: i was looking at that and thinking... i can't imagine where i'd use that
16:03:49 <Cale> volty: You're looking for a package manager written in Haskell? Have you seen Nix?
16:04:10 <hughfdjackson> slack1256: but i'd *love* to see a project/usecase where it's useful
16:04:15 <volty> yyttr3: that's yet another aspect -- I wonder which one handles better the complexity. But do not try to sell haskell-for-everything since oo has produced much more
16:04:25 <shachaf> volty: In particular, be nice or else. Your behavior so far isn't acceptable.
16:04:27 <yyttr3> Cale: He was complaining about a question I asked earlier about a possible "cabal uninstall"
16:04:38 <volty> Cale: i do not buy into your provocations. This is the last one @you
16:05:00 <volty> hoh? behavior? state it
16:05:02 <volty> what?
16:05:03 <slack1256> hughfdjackson: I personally want to hear what moved the author to create such package
16:05:18 <yyttr3> volty: No one here is trying to sell haskell-for-everything either.
16:05:19 <Cale> Er, actually, perhaps Nix isn't a Haskell project, but it's a nice purely functional package manager anyway :)
16:05:40 <_Vi> Is 0.5 seconds just to start a dynamically linked executable (built with `ghc -dynamic`, using total about 150 libraries) an expected behavior?
16:05:47 * hackagebot phantom-state 0.2.0.1 - Phantom State Transformer. Like State Monad, but without values.  http://hackage.haskell.org/package/phantom-state-0.2.0.1 (DanielDiaz)
16:06:25 <volty> yyttr3: some are // but we should stop here
16:06:42 <joelteon> wait...what does phantom state do?
16:06:53 <kazagistar> well, I am sure someone out there probably wants to sell haskell-for-everything... crazy people, but not as crazy as the OOP for everything crowd
16:07:04 <volty> sure
16:07:05 <hughfdjackson> joelteon: looks like it pretends to be the state monad.. without doing anything :| if i'm reading it right
16:07:12 <Cale> volty: This is inappropriate: "<volty> are you children affected by the ¬´teachers syndrome¬ª ?"
16:07:29 <joelteon> sometimes i see packages and think "that's really cool and useful"
16:07:34 <joelteon> this is not one of those times
16:07:39 <yyttr3> volty: I think OOP has great stengths in user driven programs (GUI's) but for the most part is way over used and only complicated things. You have to look at both worlds though and weigh their stengths independently of one another.
16:07:53 <Cale> Also, who says you can't do OOP in Haskell?
16:08:16 <volty> I repeated that I have no prob. with Maybe (or Monads) but some ppl kept on selling me his ¬´simplicity¬ª
16:08:18 <Cale> Haskell is a better language for OO than most languages that were expressly designed for it, at least in my opinion.
16:08:23 <exio4> yyttr3: OOP is a neat DOMAIN-specific-language :)
16:08:24 <kazagistar> Well, you could probably get pretty close to pure functional in C# or something, you just wouldn't want to
16:08:28 <gregnwosu> hello , when trying to cabal install charts-cairo , cabal cant seem to find cairo-0.13.0.0 any ideas?
16:08:42 <slack1256> how is Maybe not simple?
16:09:14 <Cale> Because functions and IO actions are first class, you can form record types with fields corresponding to the messages/methods to which you need your objects to respond
16:09:24 <gregnwosu> Well Maybe Simple is either Simple or Nothing
16:09:28 <yyttr3> kazagistar: You can write purely functionally in almost any high level language. Even in java 7 by using anonymous classes ;)
16:09:28 <dcoutts_> gregnwosu: is that the C lib or the Haskell lib?
16:09:29 <volty> yyttr3: open door with me -- I am against pedantic, biased, supporters (like football ones), over-specialized, over-complicating, over-advocating etc etc :)
16:09:49 <Cale> and then simply have different functions which construct those, filling out the methods in different ways. The arguments to such functions become the "private" fields of your objects.
16:10:06 <kazagistar> volty: that might be a simple misunderstanding of terms. they probably mean simple as "few moving parts, isolated and orthogonal" not "easy to learn" or "familiar"
16:10:11 <gregnwosu> dcoutts: not sure, cabal is looking for it so i assume haskell though i could be wrong
16:10:21 <yyttr3> Cale: State Monad ftw
16:10:30 <Cale> Not even!
16:10:36 <volty> Cale: as for now, you cannot even give the same names to the members (ops, functions) of the various defs in the same module
16:10:44 <Cale> volty: That's fine though.
16:10:44 <gregnwosu> dcoutts: how does one tell?
16:11:04 <yyttr3> volty: What do you mean?
16:11:05 <Cale> You also don't have subtyping, but you don't typically need it. The main reason that typed OO languages end up doing subtyping in the first place is that they tie the method implementations to the type of the object.
16:11:06 <dcoutts_> gregnwosu: from the text of the error message
16:11:18 <Cale> i.e. to the class
16:12:00 <Cale> So, if you want to define objects of the same type which implement methods differently, you *must* subclass, whereas in this Haskell encoding, you just define another function that constructs records.
16:12:09 <volty> functions names clash, since not bound
16:12:11 <kazagistar> hmm, it seems like some template haskell could score you some subtyping, but it might not be pretty
16:12:25 <Cale> volty: That's only if you try to use the same name for multiple things
16:12:30 <yac> yyttr3: is something you wouldn't solve with haskell?
16:12:37 <volty> oh my gosh !
16:12:41 <dgpratt> "...it is noteworthy that with the award-winning and allegedly glorious Glasgow Haskell Compiler GHC..."
16:12:54 <joseph07> Cale: To be fair, you can use something like interfaces in Java to avoid subtyping
16:12:58 <gregnwosu> dcoutts: http://lpaste.net/111574
16:13:11 <dgpratt> I must admit "allegedly glorious" made me chuckle
16:13:20 <gregnwosu> its complaining about pkg-config , does that suggest the C version?
16:13:21 <dgpratt> what have you people done to me?
16:13:30 <yyttr3> volty: Any why wouldn't they? Ad-hoc polymorphism is handled via type classes in haskell
16:13:32 <dcoutts_> gregnwosu: ok, so the keywords there are "pkg-config package"
16:13:33 <Cale> joseph07: Absolutely, and after years of experience, the people in the OO world are more and more moving toward designs that have shallower hierarchies as well
16:13:53 <Cale> Type classes are not ad-hoc polymorphism
16:13:58 <dcoutts_> gregnwosu: so indeed that means a C package. pkg-config is a system for configuration of C packages
16:14:06 <slack1256> are not?
16:14:13 <Cale> But yeah, if you want to use the same name for multiple things, you want to define a type class.
16:14:14 <yyttr3> dynamic dispatch? I'm not smart xD
16:14:32 <gregnwosu> dcoutts: thanks ill install presuably , via apt-get for the debianesque system
16:14:33 <dcoutts_> gregnwosu: so you just need to install the appropriate distro package (assuming you're on linux)
16:14:46 <dcoutts_> gregnwosu: cairo-dev or similar
16:14:51 <Cale> Type classes get confused with ad-hoc polymorphism a lot because of the title of the paper where they were introduced "How to make ad-hoc polymorphism less ad-hoc"
16:14:52 <yyttr3> yac: GUI programming mostly.
16:14:57 <slack1256> how are type-classes different from ad-hoc polymorphism?
16:15:00 <Cale> But they're really something quite different
16:15:00 <gregnwosu> dcoutts: ta very muchly
16:15:01 <joseph07> Cale: Not quite enough years unfortunately. I'm still maintaining code where subclasses ended up setting flags to switch the modes of parent classes and yucky stuff
16:15:09 <dcoutts_> gregnwosu: np
16:15:31 <yyttr3> Cale: What? From the definition of polymorphism to typeclasses I see little difference
16:15:45 <Cale> slack1256: With ad-hoc polymorphism, you have no way to use ad-hoc polymorphic things in order to define further ad-hoc polymorphic things in the way that you can with type class polymorphism
16:15:47 <volty> look, it is too simple, i would like to go right away with defining various types with the same attribute names (e.g. Point2 x, y Point3 x, y, z etc etc (and do not try to sell me the tuples, it's me who is supposed to decide what is better, for me!!!, at handling the complexity)
16:15:48 <Cale> For example:
16:15:49 <Cale> :t sort
16:15:51 <lambdabot> Ord a => [a] -> [a]
16:16:05 <yac> kazagistar: better minds tried. Called it TDNR and then there is some successor I don't remember
16:16:08 <Cale> sort is defined using the operations in the Ord type class, and becomes polymorphic automatically as a result
16:16:18 <Cale> You only have to write it once
16:16:40 <slack1256> Oh, I see.
16:16:41 <cjenkin1> Cale: pfft, I can do that in C++ :D
16:16:45 <Cale> If you had ad-hoc polymorphic (<) and so on, and wanted to write a sorting function, you'd still have to rewrite the sorting function once for each type.
16:16:54 <meoblast001> what's going on here? https://gist.github.com/meoblast001/ecd6d0e124cd6fc76a86
16:17:03 <Cale> cjenkin1: Well, in C++ you might use template abstraction, which is again not the same thing as ad-hoc polymorphism
16:17:08 <volty> Cale does not have experience (unless trolling & provoking)
16:17:17 <yac> yyttr3: have you heard of reactive programming?
16:17:24 <geekosaur> wat
16:17:25 <shachaf> volty: What?
16:17:26 <cjenkin1> Cale: Oh I know. I think C++'s duck typing templates are horrid
16:17:29 <Cale> volty: I've been programming in Haskell, often professionally, since 2001 :)
16:17:31 <yyttr3> Cale: I don't get the difference still. You're defining an instance of ordering for each type, which is by definition ad hoc?
16:17:41 <slack1256> volty: You cannot be moreee wrong
16:17:50 <cjenkin1> yyttr3: For a few functions, sure
16:17:52 <Axman6> I think you can
16:17:58 <Cale> yyttr3: But you only have to define the basic ordering operations, you don't have to reimplement everything that's written in terms of those
16:18:02 <yac> kazagistar: it's described pretty well on some haskell wiki
16:18:02 <cjenkin1> But you go on to write your extended library once
16:18:39 <yyttr3> yac: I'll wait until it matures someday, good luck finding better than horrible documentation and any sort of native look and feel. Nice idea in research but I don't think it's mature enough
16:18:49 <Cale> yyttr3: Whereas with ad-hoc polymorphism, you have no way to abstract over that, you'd have to copy-paste your definition of sort over and over, instead of writing it once, and letting different implementations of the ordering predicates do the rest.
16:18:56 <jle`> any good tcp socket libraries for haskell
16:19:00 <kazagistar> yac: interesting... lens does something kinda like that alreadt though, right? where record names can overlap?
16:19:21 <Axman6> Cale: where does sortBy fit into this discussion?
16:19:22 <volty> yes c++ templates are horrid, I agree, but what II am trying to say (doubt) is that you can find what is more horrid at maintaining a big app
16:19:37 <Cale> Axman6: Well, it's another approach again :)
16:19:50 <Cale> Axman6: sortBy just uses parametric polymorphism alone
16:19:50 <yac> kazagistar: I don't know lens. Also note AFAIK TDNR was rejected and there is a new proposal to solve this problem but I don't remember the name. You should be able to google there from TDNR
16:20:03 <cjenkin1> :t sortBy
16:20:04 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
16:20:07 <Cale> yyttr3: Another way to put it is that with ad-hoc polymorphism, there's no mechanism for deferring the selection of which implementation of the functions you use.
16:20:11 <Axman6> arguably more flexible, and clearer as the ordering is more often than not defined right next to its use
16:20:29 <Axman6> (I probably wouldn't make that argument myself though)
16:20:30 <exio4> I'd say understanding "polymorphism" in Haskell is really easy compared to other languages
16:20:41 <Cale> yyttr3: While with type class polymorphism, you can define type class polymorphic things just by using other type class polymorphic things, and deferring the selection of the instance until later.
16:20:46 <yyttr3> Cale: Oh! I get it, type classes allow you to manipulate the sets of classes abstracted over by the polymorphism. Maybe I can't word it right but I think I understand.
16:20:52 --- mode: ChanServ set +o shachaf
16:20:53 * Axman6 -> work
16:20:55 <kazagistar> yac: I was just imagining that since C++ is like an overbloated macro library for OOP in C, we need a overbloated macro library for OOP in Haskell, right?
16:21:12 <cjenkin1> plz no
16:21:17 <volty> let me tell you the simple truth: foldl (+) 0 a is wonderful respect to a.inject { |t, x| .... } but when you have to handle real life problems you go with defining your data while writing code in ruby (just an example)
16:21:26 <geekosaur> there was OOHaskell at one point, although it wasn't even overbloated.
16:21:30 <yac> exio4: it took me a loooong time to understand type classes are like oop interfaces
16:21:30 <jle`> ok cool, time to actaully use STM and queues and concurrency and stuff
16:21:32 --- mode: ChanServ set +o geekosaur
16:21:51 <cjenkin1> yac: interfaces + implicit search -> type classes
16:22:04 <Axman6> jle`: yeah!
16:22:08 <exio4> I never used interfaces!
16:22:20 * Axman6 -> work fo realz
16:22:28 <exio4> they're hard to understand ;)
16:22:29 <jle`> are there any commonly used typeclasses whose (nontrivial) laws are completely enforcable through their types
16:22:35 <yyttr3> volty: Why do you say that? I have found haskell better suited real life problems for a lot of tasks.
16:22:49 <kazagistar> they are like OOP interfaces, except that implementation of the interface and definition of the type don't have to be done in the same module, they are de-complected
16:22:58 <cjenkin1> jle`: I don't think it's easy to get that without dependent types
16:23:11 <jle`> i agree
16:23:14 <joelteon> on the minus side, you end up with instances spreading like viruses
16:23:18 <joelteon> although I do think that's for the best
16:23:20 <volty> the libs & utilities are there to witness ... (though I really would like haskell to catch the others ...)
16:24:20 <yac> kazagistar: it would be nice to not have data type member names conflict with other data types
16:24:37 <volty> and all that I, I, I, I -- but we all live in a world where there are so many others
16:25:02 <yyttr3> volty: Like what? Haskell has a good library for almost any task. Guis? gtk2hs, Web? yesod, etc
16:25:45 <volty> there's no qt
16:25:48 * hackagebot hyakko 0.6.6 - Literate-style Documentation Generator  http://hackage.haskell.org/package/hyakko-0.6.6 (JeremyHull)
16:25:55 <catsup> is it possible to make ghci present the command line on other handles than stdin/out ?  i need to call some foreign code that takes over stdin; i'd like to still be able to run in ghci
16:26:02 <joelteon> I think "Haskell has good library support" is a silly argument to make
16:26:47 <yac> volty: lolz ruby? I find dynamic languages totaly unsuitable for real life simply because it has zero type safety and unless you write lots of good tests you don't even know if you don't have a typo in the code
16:27:06 <joelteon> On a what-people-actually-use-Haskell for scale, it's pretty good. On a global scale, it's pretty poor.
16:27:15 <joelteon> But that's not surprising because other languages are so much more popular.
16:27:30 <joelteon> But for example, I had to write my own aspell bindings.
16:27:33 <cjenkin1> joelteon: Is it silly? Coming from Agda, a nice library is *really* appealing
16:27:37 <yyttr3> volty: http://www.gekkou.co.uk/software/hsqml/
16:27:43 <cjenkin1> Oh, I see where you're coming from
16:27:55 <joelteon> Yes, it is silly. Also, you just said "Agda" in a discussion about community library richness.
16:27:58 <yac> "Open source. Sometimes you have to flip your own burger."
16:28:01 <volty> suitable is what works, unsuitable is what doesn't work (or neither isn't there)
16:28:40 <joelteon> There's no capistrano in Haskell either.
16:28:50 <kazagistar> library coverage is silly to if you are trying to convince a random big language user to switch, but not silly when you are convicing someone from a non-top-10 popularity language
16:28:52 <volty> i don't like & mind qml
16:28:54 <joelteon> Not that people use capistrano.
16:28:55 <cjenkin1> That's something at least Scala has going for it - interop with Java libraries
16:29:13 <dhrosa> why does everything I try to build fail with "could not find module Network.URI, it is a hidden member of...' blah blah
16:29:16 <dhrosa> :(
16:29:20 <Cale> I dunno, I think the mention of Agda is pretty important
16:29:21 <RegEchse> meoblast001: https://gist.github.com/J0J0/fab425e1a63d6626b83f
16:29:22 <joelteon> I find that for a lot of single-dev toy project purposes, Haskell works great.
16:29:23 <dhrosa> trying to install shit from cabal is horrifying
16:29:27 <Cale> Everything is relative
16:29:31 <dhrosa> even in a sandbox
16:29:42 <volty> great ::: <joelteon> I find that for a lot of single-dev toy project purposes, Haskell works great.
16:29:42 <joelteon> It would be inefficient to use Haskell at work because we have to interact with a lot of APIs written by other people who have provided client libraries in Ruby.
16:29:54 <kazagistar> I hear interop with Java libraries is kinda a thing holding scala back in some ways, but certainly a net plus?
16:30:00 <Cale> Haskell has *very* good library support compared to most actually-worth-using programming languages.
16:30:03 <Cale> ;)
16:30:06 <joelteon> That too.
16:30:11 <cjenkin1> kazagistar: Well, yes and no
16:30:23 <cjenkin1> Scala has decided to not always be callable from Java
16:30:28 <joelteon> Like, if I wanted to rewrite the project we're writing right now in Haskell, it would be a lot easier to maintain, but it would be slower.
16:30:43 <cjenkin1> So that gives them more breathing room
16:31:03 <joelteon> And there would be a big chunk of start-up time to build the dependencies that nobody has written a package for yet.
16:31:41 <kazagistar> huh, I find that for single dev toy project, I still would rather reach for python or something, unless the domain is hard enough that I feel like going without types would be too scary
16:32:05 <joelteon> I would reach for python were there no other languages and I was held at gunpoint.
16:32:14 <kazagistar> haha, to each their own
16:32:37 <cjenkin1> joelteon: What is your toy dev language of choice then?
16:32:41 <joelteon> Haskell.
16:32:41 <Cale> If I was going to use something untyped, I'd probably go with scheme
16:32:50 <Cale> But it's just not worth the trouble
16:33:06 <Cale> I can't really stand programming without a type system any longer
16:33:11 <cjenkin1> ^
16:33:14 <joelteon> In toy dev language terms, no untyped language is worth the time and energy it takes to write code in those languages.
16:33:19 <exio4> I don't really find "haskell types" that intrussive
16:33:22 <yyttr3> I LOVE python for one off toy projects that I don't plan to maintain. The bigger the project i'm working on the stronger of a type system I would want.
16:33:46 <cjenkin1> Cale: You won't feel that way if you have to program in C
16:34:05 <cjenkin1> Better no type system than an excruciatingly weak one
16:34:12 <yyttr3> I don't think  i'm that smart, and because of that I want a good type system to ensure that i'm not a total idiot xD
16:34:17 <Cale> cjenkin1: Well, C has a lot of other things wrong with it before you even get as far as the type system
16:34:22 <joelteon> C without a type system is worse than C with one
16:34:42 <Cale> C isn't even a good portable assembly. Practically anything I would use C for, I could use LLVM instead.
16:34:50 <exio4> yyttr3: we're all humans!
16:34:52 <cjenkin1> joelteon: I don't think you can conceive of C without a type system, actually
16:34:57 <joelteon> Why not
16:35:07 <cjenkin1> You have to know how many bytes data take up!
16:35:16 <geekosaur> it was called B :p
16:35:19 <joelteon> That's not a type, that's a size.\
16:35:35 <cjenkin1> I don't see much more to C's types than that
16:35:37 <joelteon> Types and sizes, in languages other than C, are different.
16:35:52 <geekosaur> actually BCPL, B's predecessor, is probably better example there
16:36:01 <cjenkin1> joelteon: as it should be
16:36:01 <yyttr3> joelteon: Even assembly has about the same notion of types as C does.. Essentially
16:36:17 <joelteon> geekosaur, you have a squiggly growth on your side
16:36:18 <cjenkin1> yyttr3: C gives you some extra support
16:36:23 <Cale> That said, I think the world might be done some good by reinventing the concrete syntax of C substantially. It would be good to have *readable* types at least.
16:36:26 <geekosaur> yes, it's a just in case
16:36:28 <yyttr3> cjenkin1: Not much
16:36:38 <Cale> That didn't force you to read them in some kind of horrible spiral of doom.
16:36:45 <cjenkin1> yyttr3: Want to loop over an array of data structures with a pointer?
16:37:18 <mhall> hi, does anyone know: does cabal install packages to /var/lib/ghc or just to ~/.cabal and ~/.ghc ?
16:37:18 <cjenkin1> C will automatically convert ptr++ to an increment of the right size of bytes!
16:37:18 <cjenkin1> :D
16:37:18 <yyttr3> cjenkin1: That's usually how I do it anyway ;)
16:37:23 <geekosaur> mhall: you can use cabal to install globally but it's something of a bad idea
16:37:24 <jle`> is there a preferred way to do queues in STM?
16:37:35 <Cale> mhall: If you're running it as user, everything should land in your home directory
16:37:40 <mhall> @geekosaur: so by default it would not?
16:37:40 <lambdabot> Unknown command, try @list
16:37:50 <mhall> Cale: ok thanks
16:37:57 <geekosaur> by default it installs to your local ghc package datbaase
16:37:58 <Cale> mhall: and you pretty much always should be, there's not much point in installing packages globally
16:38:03 <geekosaur> --global will make it install to the global one
16:38:13 <yyttr3> cjenkin1: I feel like in the context of C it makes sense to pass the size of an array long with its pointer. For me at least xD
16:38:28 <Cale> (even on multi-user machines, it's better to just let everyone manage their own packages)
16:38:33 <cjenkin1> Oh yes certainly
16:38:38 <mhall> Cale: i was trying to troubleshoot some dependencies after wiping my .cabal and .ghc directories so i wasn't sure if anything had changed in /var/lib/ghc
16:38:44 <geekosaur> this is generally a bad idea unless for some strange reason you need to bootstrap a haskell environment completely from scratch
16:38:48 <kazagistar> Haskell started as my "I feel like like doing something in an inconvenient masochistic way", but then I kinda figured it out and a lot of the stuff I used before seemed inconvenient
16:39:08 <Angry> > :t show getRealUserID
16:39:10 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
16:39:13 <geekosaur> the whole point behind cabal is that it doesn't screw with global packages by default, you have to force it to do so
16:39:23 <Angry> :t show getRealUserID
16:39:25 <lambdabot> Not in scope: ‚ÄògetRealUserID‚Äô
16:39:27 <geekosaur> and just sudo isn;t enough (that installs in root's private package db)
16:39:34 <kazagistar> either way, now I can go back to Forth as my masochistic language of choice
16:39:41 --- mode: geekosaur set -o geekosaur
16:39:50 <cjenkin1> J is my masochistic language of choice
16:40:06 <Cale> kazagistar: Yeah, there's a perception I think that stronger type systems are somewhat masochistic, but the biggest advantage that a type checker confers is not preventing bugs. It's freeing the programmer from having to think about types constantly.
16:40:12 * geekosaur finds php pretty masochistic...
16:40:15 <trap_exit_> how do I tell nix "I don't want any ghc ... I want ghc-7.8.2" in particular" ?
16:40:25 <trap_exit_> wrong channel
16:40:35 <cjenkin1> trap_exit_: For the typed holes presumably?
16:40:46 <yyttr3> kazagistar: I felt the same way about haskell at first, then I had to use java again for a while and realized how much nicer haskell was xD
16:41:28 <trap_exit_> for my question about nxos
16:41:28 <Angry> Anyone know how to turn a UserID into a string (or Int)? Show fails.
16:41:29 <trap_exit_> cjenkin1: my question = wrong channel
16:41:32 <Cale> Angry: show ought to work
16:41:40 <yyttr3> Angry: Is userID defined by you?
16:41:47 <Cale> Angry: You're referring to the one from the Posix binding, right?
16:41:48 <joelteon> what's a UserID?
16:41:53 <Angry> Not it's the won from Posix
16:41:55 --- mode: shachaf set -o shachaf
16:42:03 <Angry> It is the one from Posix
16:42:04 <Cale> type UserID = CUid
16:42:18 <Cale> CUid is a newtype of Word32
16:42:29 <Cale> and it has an instance of both Show and Integral
16:42:43 <Cale> So you should be able to apply fromIntegral to it to convert it to an Integer, for example
16:42:49 <Cale> and show also ought to work
16:43:57 <Angry> No instance for (Integral (IO System.Posix.Types.UserID))      arising from a use of `fromIntegral'
16:44:12 <Cale> Ah, you don't have a UserID
16:44:24 <Cale> you have an IO action which if you were to run it, would produce a UserID as its result
16:45:11 <Angry> that was it.
16:45:59 <yyttr3> userID >>= show?
16:46:12 <yyttr3> nvm
16:46:19 <yyttr3> userID >>= print
16:46:20 <volty> Angry: are you using userID or getRealUserID ?
16:46:23 <kazagistar> yyttr3: haskell made me appreciate Java more to some extent... it taught me smarter ways to levarage types and use them to build more consistantly omposable abstractions
16:46:58 <Angry> getRealUserID, some  copy/paste had me forget that it returns an IO something.
16:47:06 <Angry> working now
16:47:11 <geekosaur> it's a known phenomenon that programmers who learn Haskell end up writing better code in just about any language
16:47:30 <geekosaur> there are companies that don't use Haskell but snap up Haskell programmers because of it
16:48:00 <Arahael> [citationneeded]
16:48:18 <volty> that's valid for all module & encapsulation oriented  languages
16:49:09 <exio4> volty: different paradigms are good to know
16:49:12 <Angry> geekosaur:  do you think it might be because people that bother to learn it are actually interested in programing instead of just seeing it as a 9-5 job?
16:49:27 <volty> exio4: as with spoken languages  ...
16:49:42 <yyttr3> geekosaur: I think that has more to do with language obscurity than the language itself. Programmers who are willing to learn exotic and underdocumented frameworks are probably more willing to learn anything else, and probably enjoy it.
16:49:45 <geekosaur> actually I don't. I think successfully programming in Haskell forces you to develop habits that are generally useful
16:50:25 <cjenkin1> I think any language that forces you to think harder about what you're trying to accomplish with a function helps improve your thinking
16:50:35 <glguy> dhrosa: Recently network split into network and network-uri
16:50:36 <pjdelport> Anecdotal, but practically speaking, i *think* in Haskell a lot of the time when doing serious work in other languages (Python, JS, etc.)
16:50:43 <volty> no, if it is true (citation need) it is because smart people are curious, math-oriented, so they finish to ¬´give a look at haskell¬ª
16:50:45 <geekosaur> for example, you are better at managing encapsulation and separating concerns because Haskell forces it on you and it's a very useful technique to keep large projects manageable
16:51:07 <pjdelport> (And i learned Haskell later, so it's not predecessor bias.)
16:51:27 <RegEchse> cjenkin1 | J is my masochistic language of choice  <- ! :D
16:51:42 <pjdelport> In my experience, Haskell made me see and think about the structure of things more clearly in general.
16:51:44 <geekosaur> and functional paradigms are creeping iunto other languages specifically because languages like Haskell have shown them to be very useful
16:51:49 <cjenkin1> RegEchse: You know J too?
16:51:56 <geekosaur> but they're only useful if you know how to use them
16:52:06 <RegEchse> cjenkin1: yeah, i tried it once. Found it funny. Never touched it again. ;D
16:52:17 <geekosaur> it's been years since I last touched J
16:52:36 <yyttr3> geekosaur: Haskell isn't better at all tasks though, java is better for a lot of things. Every language has it's merit. I'm certain it's more due to the obscurity of the language. There is little reason to learn haskell, so those who do are more likely to enjoy learning for the fun of it.
16:52:37 <cjenkin1> RegEchse: I actually know it pretty well. And with that knowledge I can confidently say: it's not really worth knowing
16:52:45 <volty> but the most successful languages are those that allow you to use whatever you prefer ...
16:53:18 <geekosaur> yyttr3, yes, my argument was not that Haskell itself is necessarily "better" for some given task, but knowing how to program in Haskell makes you better at *programming*.
16:53:21 <cjenkin1> The exception being if you really need to sketch out some code working on higher-dimensions
16:53:45 <RegEchse> cjenkin1: :D  i just read your line, remembered my experience with it and thought "good context to mention J" ;)
16:53:45 <cjenkin1> *data in collections of higher dimensions
16:53:45 <geekosaur> you can reuse those skills in Java, or Perl, or Python, etc., and you will be a better programmer in those languages for it
16:54:08 <hpc> perl especially is a great place to use skills learned from haskell
16:54:33 <volty> which skills ? lisp-like ones ? they typing in the other langs is too different to think in haskellish way
16:54:46 <volty> s/they/the/
16:55:01 <hpc> things like thinking with functions that take functions
16:55:03 <geekosaur> [24 23:50] <geekosaur> for example, you are better at managing encapsulation and separating concerns because Haskell forces it on you and it's a very useful technique to keep large projects manageable
16:55:24 <geekosaur> and yes, I mentioned the functional way of thinking earlier also
16:55:30 <hpc> high level perl will often have you writing a function that takes another function as the last argument
16:55:34 <hpc> so you can write things like
16:55:36 <danilo2> edwardk: edwardk: Hello! I've got 3 small questions regarding trifecta. I would be very thankful if you could tell me some hints how to solve them :) 1) How should I handle tab to spaces conversions in trifecta If the language supports pragma, which change  the tabl lenght inside of file? 2) does trifecta handles comments somehow?
16:55:49 <danilo2> edwardk: * 2 questions
16:55:50 <hpc> fork {timeout=>50, affinity=>1} sub {
16:55:51 <hpc>   ...
16:55:52 <hpc> };
16:56:10 <hpc> er, minus the word "sub" there
16:56:57 <hpc> compare with similar style in haskell with forkIO, etc where it's exactly the same style of coding via do-notation
16:57:18 <RegEchse> hpc: Ugh, "Sub" reminds me so much of Visual Basic.
16:58:09 <exio4> learning "functional programming" is a good thing for any programmer
16:58:35 <exio4> Haskell makes it even nicer, because it is also a pure FP!
16:58:41 <hpc> another perl example, functions that return functions is really easy too
16:58:50 <dfeuer_> @ask edwardk, what's the efficiency advantage of cutting down a typeclass to one member?
16:58:51 <lambdabot> Consider it noted.
16:59:04 <volty> non-functional too, nice to know everything -- that way you choose whatever suits you best for a given [piece of a] project
16:59:05 <hpc> and you can do some crazy stuff with it too, because of how perl's list syntax works
16:59:16 <hpc> so you can do things like
16:59:29 <edwardk> dfeuer_: one member typeclasses are represented by that one member
16:59:52 <hpc> sub partial { my ($func, @args) = @_; return sub {return $func->(@args, @_);}}
17:00:13 <hpc> and then if you need to run that fork example multiple times, you can do
17:00:23 <dfeuer_> edwardk, yes, I figured as much. It's still a pointer though, right? If the most special member comes first, doesn't that end up being the same pointer?
17:00:26 <edwardk> danilo2: i confess tab to space conversion is currently hardcoded, comments are handled by writing your own instance of the classes in parsers that happens to wrap an underlying parser, the machinery for generating someSpace parsers in parsers is how you handle whitespace parsing
17:00:34 <dfeuer_> Or am I missing something key?
17:00:37 <hpc> $fork = partial(\&fork, {timeout=>50, affinity=>1});
17:00:59 <hpc> or even
17:01:02 <edwardk> dfeuer_: no, instead of a record with one multiple members in it, it is just the one member, dictionaries are strict, this case is effectively a newtype to model that instead of a strict box
17:01:04 <exio4> volty: if you have some free time, you could check https://www.coursera.org/course/proglang, I took it and it was amazing
17:01:06 <hpc> $fork = partial(\&fork, {timeout=>50, affinity=>1}, sub {print "yup"});
17:01:16 <hpc> (and then call it as $fork->())
17:01:51 <edwardk> dfeuer_: so if you have class Foo a where foo :: a -> a;   then Foo is represented by a function (a -> a) and is passed around with the same representation as if you were passing a function (a -> a) for the place where hte obligation is discharged
17:01:56 <hpc> and that's just applying the most basic haskell concepts
17:02:09 <dfeuer_> edwardk, I'm thinking, in that case, of proposing "gentle removal" of /= from Eq.
17:02:14 <edwardk> dfeuer_: if you had class Bar where bar1 :: a -> a; bar2 :: a -> a -- then you are passing a strict record holding two fields
17:02:19 <volty> exio4: thx, bookmarked
17:02:45 <dfeuer_> edwardk, the record itself, or a pointer to it?
17:02:49 <edwardk> dfeuer_: unlikely to happen
17:02:54 <danilo2> edwardk: hmm, so to handle comments I need to create a newtype wrapping the basic trifecta Parser and create custom TokenParsing instance for it?
17:03:04 <edwardk> dfeuer_: everything is a 'pointer to a thing'
17:03:20 <edwardk> dfeuer_: the issue is behavior around NaN. NaN == NaN = False, NaN /= NaN = False
17:03:30 <edwardk> dfeuer_: you _can't_ remove it and retain IEEE compliance for NaN
17:03:33 <edwardk> so it is a behavior change
17:03:58 <edwardk> Floats f*** everything up
17:04:07 <dfeuer_> edwardk, IEEE compliance does not belong in the usual Haskell typeclass instances. It belongs in an IEEE library.
17:04:19 * dfeuer_ has to run.
17:04:43 <hpc> it's unfortunately kind of a showstopper to not have by default
17:04:45 <edwardk> dfeuer_: yet it is something we have, and giving it up is a change of a longstanding standardized decision
17:04:54 <hpc> also that
17:05:05 <hpc> propose something for the next standard
17:05:09 <dfeuer_> Ugh.
17:05:15 <edwardk> dfeuer_: i have little hesitation with defining new things, but when it comes to changing behavior for small operational gains? i tend to dislike thrashing on behavior
17:05:55 <edwardk> in practice the cases you care about efficiency on (==) are when you can know the instance in question
17:05:56 <dfeuer_> Floating point is broken seven different ways anyway in Haskell. Some changes are in the works already.
17:06:03 <edwardk> at which point it can specialize to the slot of the dictionary
17:06:05 * dfeuer_ runs.
17:06:07 <edwardk> so it doesn't matter
17:06:31 <edwardk> dfeuer_: first i heard of it ;)
17:07:07 <edwardk> there's been grumbling about floats, but no real call to action that seems to have gained any traction to my eyes
17:07:25 <edwardk> but then there is always grumbling about floats
17:07:25 <jle`> i wonder if it's possible write a Num instance so that fix (/2) will return 0
17:08:01 <edwardk> jle`: observable sharing ftw ;)
17:08:50 <systemfault> What are good resources about FRP?
17:17:48 <jle`> edwardk: is that something i could google to find?
17:18:44 <jle`> maybe fix sqrt would give me 1 too
17:19:02 <benzrf> jle`: fix sqrt would give you bottom
17:19:27 <jle`> benzrf: i'm asking for a possible Num or Floating instance that would be constructed so that fix (*2) would return 0, fix sqrt would return 1, etc.
17:19:32 <benzrf> jle`: fix is only non-bottom when each iteration can produce a WHNF result without requiring the argument
17:19:33 <edwardk> jle: observable sharing andy gill kansas lava
17:19:57 <jle`> pretty specific :)
17:20:00 <benzrf> jle`: well. im not 100% about that
17:20:07 <benzrf> maybe if theres whnf somewhere along the line
17:20:11 <jle`> benzrf: yeah, but what about a Num instance that can do that
17:20:21 <benzrf> the point is that sqrt cannot produce a partial result without needing to know its argument
17:20:26 * jle` imagines
17:20:30 <benzrf> so fix is bottom
17:20:31 <benzrf> ¬Ø\(¬∞_o)/¬Ø
17:22:02 <jle`> i guess it might be easier to see that mfix could do this
17:22:11 <jle`> and loop from Control.Arrow
17:22:16 <jle`> but what about just plain ol fix
17:22:17 <jle`> hm
17:22:51 <jle`> ima thinkabout it
17:23:34 <benzrf> jle`: how could sqrt return something before it gets any of its argument.
17:23:56 <jle`> contrived example:
17:24:04 <jle`> instance Floating MyNum where sqrt _ = 1
17:24:49 <benzrf> (‚òûÔæü‚àÄÔæü)‚òû
17:24:55 <jle`> now just to get it behave normally when not being fix'd
17:25:01 <conal> benzrf: it all depends on the representation of the number the semantics of that representation. For instance, lazy infinite exact reals, represented with most significant "bits" first. I quote "bits", as the usual binary rep (made infinite) isn't adequate. but other representations are.
17:25:03 <benzrf> lol good luck
17:25:17 <benzrf> conal: ok
17:25:28 <benzrf> conal: but wouldnt you still need at least one digit to begin computing a sqrt
17:26:14 <conal> benzrf: i'm very interested in efficient exact computation on reals. my hope is that this goal is realizable with reprogrammable hardware.
17:26:15 <jle`> a lot of neat denotative stuff i would like to explore would be made nicer of you really could do something like fix sqrt ==> 1
17:26:28 <jle`> maybe i should look into that denotative haskellwiki thing
17:27:16 <benzrf> but jle`
17:27:28 <conal> jle`: i'm glad to hear that you're interested in this area. i think we can do it with better hardware. more efficient than hard FPUs and yet guaranteed correct.
17:27:49 <conal> ... in that every "bit" one can ask for is correct.
17:28:04 <jle`> i'm not sure that better hardware would let you do fix sqrt = 1 as fix is currently implemented
17:28:11 <benzrf> S_n = foldr1 (.) (replicate n sqrt) x
17:28:14 <benzrf> never reaches 1
17:28:17 <benzrf> it's just a limit :-)
17:28:18 <jle`> ikdr
17:28:23 <tabemann> except that with many functions, you're never going to get an exact result, because the way they are computed is never exact
17:28:26 <jle`> but sqrt is the actual fixed point
17:28:31 <jle`> i mean
17:28:32 <tabemann> like sin for instance
17:28:33 <jle`> 1 is the actual fixed point
17:28:35 <benzrf> true..
17:28:50 <jle`> sin has multiple fixed points
17:28:54 <tabemann> an exact sin is an infinite series
17:28:59 <jle`> ...i think
17:29:01 <jle`> or does it only have 1
17:29:04 <benzrf> write a version of fix that secretly hooks into something like mechanical turk and gets a human to calculate a fix point ;)
17:29:06 <jle`> yeah, it only has one, i think
17:29:13 <shachaf> You can get a result as exact as you ask for, which is all you need.
17:29:24 <conal> jle`: two steps: change the representation of numbers to exact lazy to make it sound/correct, and change the hardware foundation to make it efficient.
17:29:35 <tabemann> what you need is a sin that takes two parameters, the angle and the precision desired
17:29:42 <benzrf> a total function on reals always has a fix point doesnt it
17:29:48 <jle`> benzrf: (+1)
17:29:54 <benzrf> OH wait
17:30:00 <benzrf> make that total, continuous :po
17:30:02 <conal> tabemann: taking the precision as an argument destroys modularity.
17:30:02 <benzrf> * :p
17:30:09 <jle`> (+1) is still total and continuous :P
17:30:10 <tabemann> conal: it does
17:30:11 <conal> tabemann: just like strict functional programming does.
17:30:15 <benzrf> jle`: wait.
17:30:18 <benzrf> derp.
17:30:31 <dfeuer_> edwardk, I believe carter is working on some float stuff. But it's dinner time!
17:30:33 <conal> and like discrete space or time destroys modularity.
17:30:34 <benzrf> i was  thinking about intersecting with the x = y line when plotted
17:30:38 <carter> danilo2: what about me?
17:30:41 <carter> dfeuer_: what?
17:30:42 <jle`> it still doesn't do that
17:30:44 <jle`> :)
17:30:47 <benzrf> yes thats me poinjt
17:30:50 <jle`> ah, mk
17:30:51 <edwardk> dfeuer_: i've talked to him about a few things here and there
17:30:59 <benzrf> i forgot that it's possible to stay behind said line while being total and continuous -_-
17:31:02 <benzrf> somehow.
17:31:30 <tabemann> so how do you code a lazy sin that actually produces an exact result as a lazy series of bits?
17:31:33 <danilo2> carter: Excause me - I did not noticed anything. Looking right now into the history, brb
17:31:44 <carter> danilo2: typo
17:31:45 <carter> :)
17:31:53 <danilo2> carter: ah :)
17:32:16 <tabemann> and how does one make that performant
17:32:53 <carter> dfeuer_: edwardk , so one idea i spoke with rwbarton about was keeping the current >  <  etc for float, but defining compare using the IEEE total ordering
17:32:56 <tabemann> hmm
17:33:31 <edwardk> carter: i'm highly leery of changing existing behavior as it breaks user code in more or less impossible to predict and impossible to debug ways
17:33:40 <conal> tabemann: yes! those two questions are a good place to start. for performance, reconfigurable hardware, so that we can generate more bits of precision on the fly as they're demanded. just like non-strict functional programming in general, but much  more efficiently than on a CPU.
17:33:41 <tabemann> you'd probably have to treat your lazy series of bits as a lazy series of bit chunks, and have a separate expression to evaluate each chunk, which would correspond to different parts of the series defining sin
17:33:45 <carter> edwardk: goal is being able to sort :)
17:33:49 <carter> i'm trying to unbreak things
17:34:05 <carter> can't safely use Data.Map with float keys currently :)
17:34:10 <edwardk> carter: goal is not breaking existing code people have in production making trades that relies on the corners of existing behavior ;)
17:34:23 <carter> yes
17:34:24 <carter> agreed
17:34:32 <tabemann> of course it means that the further you try to force a series of bits resulting from an exact sin the slower the evaluation gets
17:34:34 <carter> == and /= should say the same
17:34:44 <carter> as well as < an d> etc
17:35:08 <erikd> carter: how about only enabling your IEEE total ordering with a language pragma.
17:35:14 <carter> erikd: OH NICE
17:35:16 <carter> I LIKE YOU
17:35:21 <erikd> that would give people time to convert
17:35:34 <carter> gating it on a pragma might be tenable
17:35:46 <erikd> old behaviour is default
17:36:03 <edwardk> carter: gating it on a pragma doesn't work, its global system behavior
17:36:07 <merijn> How would that possibly work
17:36:10 <benzrf> forall continuous, total f : R -> R. (exists x x'. x < x' /\ f(x) > f(x')) -> (exists i. f(i) = i)
17:36:12 <merijn> Instances are global
17:36:14 <edwardk> its about an instance
17:36:23 <carter> ghc primops are too
17:36:29 <carter> i'm saying , specifically
17:36:42 <carter> the pragma would change how those ghc primops are compiled
17:36:45 <carter> erm
17:36:46 <carter> hrmmmm
17:36:58 <merijn> carter: that doesn't make sense to me
17:37:00 <carter> erikd: intersting idea, i'll have to think about the implications
17:37:04 <edwardk> i'm with merijn
17:37:07 <tabemann> how does one have IEEE floating point where == and /= don't need to be treated as broken?
17:37:20 <carter> tabemann: Eq is fine
17:37:56 <carter> > compare 1 (0/0 :: Double)
17:37:58 <lambdabot>  GT
17:38:01 <carter> > compare 1 (0/0 :: Double)
17:38:03 <lambdabot>  GT
17:38:18 <tabemann> I mean, how does one have it where one doesn't run into the problem where math operations will result in loss of precision, such that your theoretically equal values are no longer equal
17:38:19 <edwardk> carter: well, no, reflexivity is borked and 0.0 == -0.0 but you can distinguish them ;)
17:38:57 <carter> > compare  (-0 :: Double) 0
17:38:59 <lambdabot>  EQ
17:38:59 <carter> looks fine to me
17:39:37 <carter> erikd: maybe i jsut add some primops i use instead of compare :P
17:39:48 <tabemann> that's what I mean by == and /= being broken with IEEE floating point
17:40:05 <Ralith> tabemann: the precision dynamics of IEEE are well specified and eminently practical
17:40:21 <Ralith> if you want algebraic equality you're using the wrong type
17:40:24 <volty> there cannot be ¬´theoretical equality¬ª with floats
17:41:20 <edwardk> > let f = (1/) in (-0 == 0, f (-0) == f 0)
17:41:22 <lambdabot>  (True,False)
17:41:27 <volty> i had a prob. with and found a receipt about ¬´rounding¬ª float numbers (it depends on the exact type of representation, mantisssa etcc etc)
17:41:46 <carter> edwardk: thats fine
17:41:50 <carter> i like limits working :)
17:41:52 <joelteon> > 1 / -0
17:41:53 <lambdabot>  Precedence parsing error
17:41:54 <lambdabot>      cannot mix ‚ÄòGHC.Real./‚Äô [infixl 7] and prefix `-' [infixl 6] in the same...
17:41:57 <joelteon> oh
17:42:18 <carter> 1 / x  as x approaches zero from left or right are VERy different numbers
17:42:23 <edwardk> carter: i do too. when i put on my numerical hack i sigh and take it ;) when i put on my algebraic hat i cringe inwardly ;)
17:42:34 <Hijiri> shit
17:42:38 <carter> i agree they're different
17:42:39 <carter> :)
17:42:41 <Hijiri> my $HOME/bin disappeared
17:42:52 <carter> i spend a lot of time explaining that difference
17:42:56 <edwardk> carter: my point was more that 0 == -0 means you have a nonstructural equality, and NaN /= NaN means you have an irreflexive one
17:43:00 <edwardk> carter: sure
17:43:03 <edwardk> so do i
17:43:07 <carter> true
17:43:08 <carter> ok
17:43:28 <edwardk> but i was answering tabemann's comment
17:43:34 <bryanedds> edwardk, you mind helping me with one last thing?
17:43:41 <carter> well, anyways, having floats work for keys in  Data.Map and friends is worth figuring out
17:43:44 <edwardk> bryanedds: fire away, i'll answer as i can
17:43:56 <bryanedds> ok
17:43:58 <carter> edwardk: and i'm willing to shop around a while to get buy in :)
17:44:02 <volty> a case where floats have to be used as keys?
17:44:19 <Ralith> carter: that sounds like a dubious sort of thing to do
17:44:22 <carter> not really
17:44:23 <edwardk> carter: i have to say i'm somewhat underwhelmed by that use case. i can't compute with those floats, if i add one to one to compute the next one over i may miss it, etc.
17:44:26 <copumpkin> if you're splitting maps that's fine
17:44:27 <Ralith> give me a usecase
17:44:33 <edwardk> because of intermediate value promotion, etc.
17:44:35 <copumpkin> if you're looking stuff up, no
17:44:36 <carter> ?
17:44:41 <edwardk> copumpkin: as long as you don't split too close ;)
17:44:45 <copumpkin> yup
17:44:54 <carter> i'm misisng a step
17:45:02 <carter> i've been patching llvm-gernal all afternoon
17:45:04 <tabemann> to get floats to work as keys for Data.Map sounds like it requires rounding the floats to a known precision, that will still be present after all operations carried out on the floats in question
17:45:29 <edwardk> carter: add two floats, the result isn't all that deterministic across or even entirely within a run if you aren't looking at the same actual computed float.
17:45:36 <edwardk> because of intermediate value promotion
17:45:50 <carter> tabemann: why
17:45:57 <bryanedds> could you help me fill in the ???'s - http://lpaste.net/111576
17:45:58 <copumpkin> buy 64 get 16 free
17:45:59 <edwardk> so using them for keys you can look up is really dangerous
17:46:04 <edwardk> copumpkin: hah
17:46:05 <carter> oh
17:46:08 <carter> ahhhhhhhh
17:46:14 <carter> derp
17:46:19 <carter> so disjoint intervals
17:46:20 <carter> ohhh
17:46:21 <copumpkin> even without that it's somewhat dubious
17:46:22 <carter> geometry
17:46:25 <edwardk> carter: hence why i'm underwhelmed by the notion that you want to go use these things to look up by equalities =P
17:46:26 <copumpkin> but that makes it really dubious
17:46:32 <carter> fineee
17:46:41 <bryanedds> In my last function, I'm trying to destructure 'a Observer so I can use it to call World.subscribe
17:46:44 <edwardk> carter: that strikes me as unstable and unreliable enough that i don't expect it to work for you all that well =P
17:46:48 <bryanedds> which is the signature at the top
17:46:56 <bryanedds> I'm at a loss as to what to do
17:47:11 <carter> edwardk: youve sold me
17:47:48 <tabemann> bryanedds: that's F#, right?
17:47:56 <bryanedds> ya
17:48:07 <edwardk> bryanedds: i still don't fully grok your address machinery =P
17:48:07 <srhb> I was just about to ask what the hell kind of Haskell that was :P
17:48:22 <bryanedds> ah, it's actually really simple
17:48:31 <bryanedds> it does two things -
17:48:49 <edwardk> bryanedds: i'd think your Observer would have a 'subscribe' method more than an observe one
17:49:00 <bryanedds> it describes how to retrieve an entity from  a map in the World
17:49:15 <bryanedds> it also specifies the nature of an event
17:49:15 <edwardk> you're subscribing to events from it, and then that is notifying the observer from then on out, with the ability to cancel the subscription, no?
17:49:34 <edwardk> So why is an Address untyped?
17:49:41 <edwardk> i might be missing something
17:49:56 <bryanedds> so an entity's address is ["MyScreen"; "MyGroup"; "MyButton"]
17:50:07 <edwardk> what operations do you have on an Address?
17:50:19 <edwardk> maybe that'd help
17:50:24 <bryanedds> and its button click event is  ["Click"; "MyScreen"; "MyGroup"; "MyButton"]
17:50:41 <bryanedds> I can show you the World.getEntity function
17:51:35 <edwardk> bryanedds: trying to answer as much as i can without paging back in all of the horror of F# into my brain ;)
17:51:52 <bryanedds> Address is almost an alias for a list
17:51:58 <tabemann> horror is a good word to describe F#
17:52:14 <bryanedds> So the raw operations are basically what a list does
17:52:30 <tabemann> F# is the square peg of OCaml shoved into the round hole of .NET
17:52:44 <bryanedds> I'd use Haskell if it were strict
17:53:14 <edwardk> tabemann: yeah i just wish they didn't have to shave off the whole module system that made it worth programming in to fit it into the round hole ;)
17:53:29 <tabemann> same thought here
17:53:45 <bryanedds> http://lpaste.net/111576
17:53:47 <edwardk> bryanedds: ok, i've internalized it now as a list =)
17:53:49 <tabemann> I *liked* OCaml's module system back when I was an OCaml programmer
17:54:30 <bryanedds> I can also show publish and subscribe's definitions
17:55:14 <bryanedds> http://lpaste.net/111576
17:55:31 <edwardk> tabemann: i'd kill for something like it in haskell. however, said kill would be me jumping off a bridge if i had to give up typeclasses to get it ;)
17:55:47 <tabemann> bryanedds: what don't you like about lazy evaluation?
17:55:58 <bryanedds> to hard to reason about performance
17:56:05 <bryanedds> I'm a game programmer
17:56:30 <edwardk> bryanedds: read purely functional data structures, don't make anything lazy without knowing how many thunks will accumulate in that position. do that rigorously and this isn't an issue
17:56:34 <tabemann> modules in OCaml are nice, but type classes in Haskell are easier to work with in most cases
17:56:35 <joelteon> just put ! everywhere
17:56:57 <bryanedds> laziness is the wrong default
17:56:59 <bryanedds> imo
17:57:15 <edwardk> bryanedds: as someone who came from your world, strictness doesn't compose. ;)
17:57:18 <joelteon> better change haskell to be strict
17:57:22 <bryanedds> and I don't like languages that give me the wrong defaults
17:57:27 <tabemann> the thing is that it is easier to add strictness to laziness than it is to add laziness to strictness
17:57:55 <edwardk> joelteon: if you do, i'll just go write another language that is lazy and go think in that
17:58:08 <edwardk> tabemann: that is really the problem
17:58:18 <joelteon> it'll be called Bang Haskell
17:58:26 <joelteon> the preprocessor inserts ! before every subexpression
17:58:41 <joelteon> if you want to introduce laziness, use ?
17:58:45 <edwardk> bryanedds: the problem is you can't just 'add laziness to a strict language' nobody does it successfully. they all say they are going to let you do it, then you get stack overflows and space leaks the moment you go to use it.
17:59:07 <edwardk> i _can_ add strictness successfully to a lazy program, the other has yet to be demonstrated in the wild
17:59:08 <bryanedds> I almost never need laziness
17:59:30 <bryanedds> the only place I use it is as an optimization
17:59:40 <tabemann> laziness isn't an optimization
17:59:50 <bryanedds> it is where I use it :)
18:00:11 <tabemann> when you try to use it as solely an optimization you don't get any of its good properties, such as increasing modularity
18:00:13 <edwardk> bryanedds: i use laziness to get the right asymptotics in a non-trivial amount of code without incurring side-effects
18:01:13 <edwardk> from the dumb 'write sort, write take, now compose them and get better asymptotics than the strict version' example all the way up to cache oblivious b-trees and succinct data structures
18:01:35 <tabemann> a lot of operations have better behavior when lazy than when strict too
18:01:48 <bryanedds> I haven't seen where laziness can help my program's modularity
18:01:51 <edwardk> in the former case ubiquitous laziness causes the list tail not to sort, in the latter case i'm creating thunks on just the right schedule
18:01:56 <PDani_> hi
18:02:05 <edwardk> bryanedds: let me try to make the case in reusability terms
18:02:27 <edwardk> in a strict language, you can write pretty much any algorithm you want once. easily enough.
18:02:36 <edwardk> then you can write another algorithm once, easily enough.
18:02:41 <tabemann> bryanedds: you can compose operations such that only as much as needed of their result is used, rather than having to do the expensive calculation of the full thing regardless of whether you use it
18:03:06 <edwardk> now when you go to compose these two in sequence because the are strict the first has to do all of its work, even the stuff the second algorithm doesn't need to proceed
18:03:10 <edwardk> so what do you do?
18:03:22 <edwardk> you're a good programmer who hates to see his CPU time wasted so you write it over
18:03:32 <edwardk> and you manually fuse the two algorithms together
18:03:41 <edwardk> juggling all of the invariants of both problems in your head
18:03:55 <edwardk> i routinely write code in haskell that i'm just barely smart enough to write
18:04:11 <edwardk> and i routinely stick it together with other algorithms i was just barely smart enough to write
18:04:33 <edwardk> i'm not smart enough to load up both sets of invariants in my head and make it all go, and even if i were it isn't an effective utilization of my time
18:05:03 <PDani_> my first adventure with FFI: Unacceptable result type in foreign declaration: IO Frame
18:05:04 <edwardk> i'd rather take the time to write a few bullet proof reusable lazy components that i can reason about how they'll compose with everything else, and get that 'silver bullet' of code reuse finally for once in my career
18:05:12 <lpaste> PDani pasted ‚ÄúFFI troubles‚Äù at http://lpaste.net/111579
18:05:27 <edwardk> because i sure as hell never found it when working in a strict languages on games and graphics and the like
18:06:00 <bryanedds> so, as you know, (I think), I'm a purely functional strict programmer
18:06:21 <bryanedds> currently, because I use PF-style, I attain a lot of modularity as it
18:06:21 <edwardk> for me the benefit to modularity comes from the fact that two lazy algorithms when composed can have better asymptotics than the two algorithms in isolation. two strict algorithms always pay the worst case price
18:06:23 <bryanedds> *as is
18:06:46 <PDani_> I also tried to make it an instance of Storable, but that didn't help either...
18:06:54 <tabemann> bryanedds: one other advantage of laziness is that you don't have to contort your code to fit into tail recursion a lot of the time
18:07:06 <meoblast001> is there a function that has this type? (Floating a, Fractional b) => a -> b
18:07:27 <tabemann> whereas in strict functional languages you basically need to use tail recursion all the time, lest you explode your stack
18:07:33 <bryanedds> I haven't really seen the case for composing algorithms yet
18:07:50 <bryanedds> I mean, I have a large sequential, purely-functional game engine
18:07:54 <edwardk> bryanedds: i use laziness for a few things. 1.) prettier EDSLs that i can eta-reduce more often. 2.) algorithms that compose with better asymptotics than their parts -- you can trade in both of those things for easier reasoning about space and time. its a lot easier to reason about time when it is always the worst case ;)
18:08:19 <bryanedds> but I'm not seeing what I'm missing that laziness would give me, other than overly-complex operational semantics
18:09:11 <Cale> bryanedds: There's a slightly stupid little example that I like to give, which I think nonetheless illustrates it
18:09:15 <bryanedds> I'm sure there are use-cases, but are they common enough to justify a change in my chosen language's default
18:09:22 <bryanedds> ?
18:09:44 <tabemann> the thing is that you can always take your lazy code and fix your space leaks by putting in a few bangs or `seq`s, but you can't take your strict code and give it better asymptotics and stack usage characteristics without rewriting a lot
18:09:52 <edwardk> bryanedds: i literally can't write 90% of the code i write in f# for reasons that only rarely have to do with laziness, so it isn't even at the top of the list of things that keep me from using it in practice ;)
18:09:54 <Cale> bryanedds: In Haskell, we can get away with writing something like: substring xs ys = any (isPrefixOf xs) (tails ys)
18:10:09 <Cale> bryanedds: In a strict setting, this is a really shitty algorithm
18:10:26 <PDani_> is it even possible to use a function directly with FFI which returns with a struct?
18:10:28 <Cale> In a lazy one, it's quite a bit less shitty :)
18:10:58 <Cale> (it's still not ideal, but let's ignore that, it turns out that laziness is useful in implementing the fancier algorithms too, but they're not one liners ;)
18:11:07 <Enigmagic> PDani_: i don't think so
18:11:42 <Cale> bryanedds: We get to make use of these library functions like tails and any and isPrefixOf, and we get a nice thing that is pretty much equivalent to the imperative nested loops with early breaks
18:12:32 <Cale> bryanedds: If any of these functions were too strict, then we couldn't get this algorithm by composing the bits in our library, we'd be forced to rewrite them and stitch them together manually in such a way that we don't do too much work.
18:12:34 <edwardk> whereas the efficient strict algorithm doesn't get to reuse all the parts nicely
18:12:42 <shachaf> Cale: It's pretty bad in a lazy language too.
18:13:00 <shachaf> In fact, lazy languages encourage you to use linked lists to store strings, which makes it impossible to write a good algorithm.
18:13:15 <Cale> shachaf: Eh, I don't see how that's the case
18:13:22 <hpc> it's O(n)
18:13:23 <Cale> We have things like Data.Text.Lazy after all
18:13:25 <shachaf> Empirically.
18:13:26 <hpc> which is as good as you can get
18:13:33 <bryanedds> Right, I definitely understand there are use cases for lazy default, but I'm not yet seeing them as common enough to justify a change in language defaults
18:13:36 <PDani_> Enigmagic: hm... then I have to write C functions for all the primitive types which builds up my struct? like get_foo_field_from_struct()?
18:14:00 <Cale> type String = [Char] being in the Prelude encourages you to use linked lists to store strings :)
18:14:38 <Cale> bryanedds: Well, the thing is, there are few enough cases where the distinction really matters, but if you have a strict default, then all your library functions end up being too strict to make laziness useful
18:14:56 <Cale> Because people don't think hard enough about whether it's important to be lazy or not
18:15:13 <Cale> and even if they do think about it, it's often hard to foresee these things
18:16:07 <bryanedds> edwardk, you talked to carmack about game programming in haskell, right?
18:16:58 <edwardk> i tried to get him to come out to do CUFP this year, but alas, he wasn't comfortable speaking as an outsider in an area he isn't yet comfortable in
18:17:12 <hpc> too bad
18:17:27 <chirpsalot> Kidnap them and force them to be familiar.
18:17:43 <edwardk> plus oculus/facebook started happening right around that time
18:17:44 <bryanedds> are you familiar with my work?
18:17:52 <chirpsalot> Actually, somebody should do some Oculus Haskell stuff to entice ;)
18:17:54 <hpc> it's always helpful to have someone who is experienced in a domain but unfamiliar with a particular language or library
18:18:21 <edwardk> bryanedds: fraid not. i'm a bit of a dinosaur in the games world =)
18:18:36 <edwardk> i still have friends in the industry, but i left for greener pastures long ago =)
18:18:51 <bryanedds> I built what I believe is the first practical, pure functional game engine - https://github.com/bryanedds/FPWorks
18:19:33 <bryanedds> I would definitely consider working on a Haskell game engine if there were some funding for it
18:21:27 <dmj`> bryanedds: you can contribute to this one: http://helm-engine.org/
18:21:47 <edwardk> there is a whole #haskell-game channel of folks playing around in that space, chucklefish is starting a game in haskell (and is hiring)
18:21:50 <bryanedds> Helm is not how I would design a game engine
18:22:06 <bryanedds> FRP is not practical, IMO, for real games
18:22:29 <Arahael> FRP?
18:22:32 <geekosaur> not yet, at least
18:22:40 <geekosaur> FRP's still in its infancy
18:22:49 <geekosaur> functional reactive programming
18:23:15 <eyebloom> geekosaur: what is the source of the inefficiency with FRP?
18:23:19 <Arahael> Not sure what that means.
18:23:54 <eyebloom> I‚Äôm considering it for other animation related projects?
18:24:04 <geekosaur> Arahael, basically it's early steps toward functional and declarative programming instead of event loops and callbacks
18:24:08 <dmj`> bryanedds: would you use sdl? Haskell has bindings for it, https://www.libsdl.org/
18:24:32 <geekosaur> eyebloom, I'm not the best person to answer that but at the moment the machinery needed to make current FRP work is fairly heavy
18:25:34 <edwardk> bryanedds: in that i confess i agree with you. i've yet to drink the FRP kool-aid.
18:25:40 <bryanedds> I actually currently use SDL in F# :)
18:25:57 <bryanedds> I went down the FRP road already with a language I designed
18:26:16 <geekosaur> and there are several different ways we currently know to do FRP, each of which has major shortcomings. I expect as people continue to work on it, we'll find better ways to use them and ways to make them better
18:26:17 <bryanedds> the problem with games is that they are deadset on breaking every abstraction you make
18:26:30 <geekosaur> but FRP was still essentially theoretical just a couple of years ago
18:26:53 <dmj`> bryanedds: do you use xna? thought microsoft was phasing that out...
18:26:56 <bryanedds> the problem FRP won't solve, I think, is the problem of leaky abstractions
18:27:02 <bryanedds> no, I use SDL :)
18:27:32 <bryanedds> Law of Leaky Abstractions is a bitch and a half
18:28:33 <geekosaur> probably. but that's a problem everywhere, and I wouldn't be surprised if it is unavoidable
18:29:20 <geekosaur> considering that every time we poke at cognition, or at life itself, we keep finding tangled mixing of levels (abstraction leaks in physical systems) all over the place that are essential for it all to work
18:29:36 <bryanedds> But all FRP systems are premised on having a set level of abstraction that breaks too often in the face of leaks
18:30:16 <bryanedds> I don't personally see it - however -
18:30:27 <bryanedds> people told me pure functional programming wouldn't work for games
18:30:38 <bryanedds> so I'm not going to say the same about FRP!
18:30:46 <geekosaur> abstraction itself is in some sense artificial. it's something we do to try to simplify things so we can understand them --- but real world systems are all tangled-up with no real abstraction
18:30:46 <bryanedds> I just made a different bet, is all.
18:31:54 <bryanedds> the problem is how dependent FRP is on these fragile abstractions
18:32:09 <Cale> bryanedds: I've worked on an action RPG that was going to be targetted at iPhones in Haskell. The founder ran out of money before it was done, but it at least convinced me that FRP was viable, if very difficult to finally get right.
18:32:25 <Laquendi> if you need something that is usable and practical now, FRP is way too risky
18:33:06 <geekosaur> as I said. it's not really there right now, and I'm willing to let the folks on the edges keep playing with it and make it usable. but I wouldn't base a real system on it just yet
18:33:11 <Cale> We had an in-house arrowy FRP system (which actually used a modified version of arrow, and a preprocessor for the proc/do notation that used our additions).
18:33:37 <Cale> You can expose a lot of optimisations with something like that
18:33:54 <Cale> But actually writing them all and making it work well takes a lot of development effort
18:34:23 <geekosaur> (also I've noticed what Cale is saying --- Arrow seems in many ways to be the best current abstraction for FRP, but my experience is that Arrow as is is a broken abstraction. alternative abstractions very well may be one of the ways forward)
18:34:42 <Cale> Well, the Arrow that's in the libraries is missing critical bits
18:34:50 <Saizan> Cale: did you have problems with retaining state when you didn't intend to?
18:34:57 <Cale> It should really be closer to the data for a symmetric monoidal category
18:35:09 <geekosaur> I have this feeling that at some point we're going to realize that Arrow was reaching for something and missing the mark, and when we find it we're all going to facepalm
18:35:50 <Cale> Saizan: I don't think that was the problem most of the time. Until we figured out better what the primitives of our FRP system should be like, we had issues with loops.
18:36:18 <Cale> But I don't know about retaining state -- it was pretty good at removing bits of the computation graph which were no longer needed
18:37:09 <Saizan> with loops? like writing something that was actually circular?
18:37:14 <Cale> yeah
18:37:38 <goatfins> Hello, I'm having trouble installing the ncurses package through cabal
18:38:29 <goatfins> I'm getting errors during compilation like:  ‚Äòsucc‚Äô is not a (visible) method of class ‚ÄòEnum
18:38:39 <Cale> In our later implementations of the system, we had an explicit representation of the Arrow computation which was to be run as a heterogeneously typed graph, and then a bunch of optimisations on that graph which would simplify it, eliminating all the unnecessary tupling and untupling for instance.
18:39:26 <Cale> (and in the process, discovering better what really needed to be computed, and what was unused)
18:40:50 <Arahael> geekosaur: Sounds interesting - I notice they use a GUI as an example though. Surely the performance is adequate there.
18:41:06 <Saizan> with some modalities from temporal logic you can forbid circularity, and if you want also ensure that keeping past state must be done explicitly
18:41:28 <zwer> '
18:41:39 <zwer> ?
18:42:38 <goatfins> Why would basic prelude functions not be in scope?
18:43:34 <shachaf> Perhaps you hid them.
18:43:43 <shachaf> Perhaps you're accidentally using APL.
18:44:10 <geekosaur> did you explicitly import Prelude? thst suppresses the implicit one, and if you restricted what you imported from it, that's all you would have
18:44:20 <lpaste> goatfins pasted ‚Äúncurses installation problem‚Äù at http://lpaste.net/111581
18:45:16 <goatfins> The include directory was a workaround for the <ncursesw/ncurses.h> vs <ncurses.h> distinction
18:47:34 <goatfins> I don't think I have done anything to the ncurses package itself
18:50:35 <meoblast001> so i'm entirely failing to find anything that converts Floating to Fractional. is it not possible to do that?
18:51:38 <meoblast001> or even just converting to Num
18:53:53 <splintax> is it possible to feed the output of one of lambdabot's dictionary commands into a haskell expression?
18:54:23 <geekosaur> anything Floating is already Fractional (and Num). what are you really trying todo? that is, what actual problem are you trying to solve
18:55:09 <goatfins> Should I just wipe out everything I've installed through cabal and try again?
18:55:59 * hackagebot parsec 3.1.7 - Monadic parser combinators  http://hackage.haskell.org/package/parsec-3.1.7 (AntoineLatter)
19:00:36 <twopoint718> Could someone give me, or point me to where I can read about, an example of `withReader`?
19:06:28 <flyingfisch> is function $ x + y the same as function (x + y)?
19:07:22 <tabemann> flyingfisch: yes
19:07:22 <Axman6> yes
19:07:35 <lf94> why not use parens
19:07:43 <zwer> @src ($)
19:07:43 <lambdabot> f $ x = f x
19:07:53 <zwer> that works because $ has lowest possible precedence
19:07:55 <joelteon> in case the thing on the right side of $ spans multiple lines
19:07:58 <lf94> what would happen if you had x $ y + z $ a - b * c
19:08:01 <joelteon> something $ do ...
19:08:39 <tabemann> lf94: but y + z is not a function
19:09:07 <flyingfisch> :t y + z
19:09:08 <lambdabot> Expr
19:09:24 <joelteon> > x $ y + z $ a - b * c
19:09:26 <lambdabot>  Couldn't match expected type ‚Äòs0 -> t‚Äô
19:09:26 <lambdabot>              with actual type ‚ÄòDebug.SimpleReflect.Expr.Expr‚ÄôCouldn't match e...
19:09:26 <lambdabot>              with actual type ‚ÄòDebug.SimpleReflect.Expr.Expr‚Äô
19:09:29 <joelteon> hmm
19:09:41 <flyingfisch> @undefine
19:09:42 <lambdabot> Undefined.
19:09:54 <flyingfisch> :t ($)
19:09:55 <lambdabot> (a -> b) -> a -> b
19:09:57 <lf94> tabemann: I don't know how $ works so I'm just throwing it out there X)
19:10:04 <flyingfisch> so
19:10:06 <lf94> I see
19:10:16 <flyingfisch> $ takes a function and a variable
19:10:28 <joelteon> $ takes two expressions
19:10:31 <flyingfisch> are they called variables in haskell?
19:10:40 <lf94> $ is infix?
19:10:42 <Axman6> x $ y + z $ a - b * c is x $ (y + z $ (a - b * c))
19:10:44 <flyingfisch> yes
19:10:45 <joelteon> yes it is
19:10:50 <tabemann> it's just two expressions, one which evaluates to a function and one which can be anything
19:10:50 <lf94> makes sense then
19:11:15 <goatfins> okay, I just backed up all my ghc and cabal files and tried installing ncurses again. Same errors.
19:11:24 <Axman6> x $ y + z $ a - b * c is x $ (y + z $ (a - b * c)) which is x ((y + z) (a - b * c))
19:11:37 <lf94> Axman6 apparently that's invalid
19:11:37 <flyingfisch> so f . g x is the same as f (g x), right?
19:11:42 <Axman6> right
19:11:54 <tabemann> (f . g) x = f (g x)
19:12:01 <flyingfisch> just making sure I understand these two things
19:12:03 <joelteon> f . g x is (f) . (g x)
19:12:19 <joelteon> f . g $ x is (f . g) (x)
19:12:27 <goatfins> Maybe this is a bug in the ncurses package?
19:12:33 <joelteon> when reading $, assume that the expressions on both sides of $ are ()
19:12:37 <flyingfisch> joelteon: cool
19:12:42 <joelteon> or are surrounded by (), my mistake
19:12:43 <flyingfisch> ok
19:12:47 <flyingfisch> thank you
19:12:52 <flyingfisch> that helps :)
19:12:57 <joelteon> a . b $ c . d is (a . b) (c . d)
19:13:06 <lf94> (+ 1) $ (- 2) does what?
19:13:18 <zwer> it gives you an error
19:13:25 <lf94> what's invalid about that
19:13:30 <joelteon> uh, if that's partial application of (-) and there's no Num instance for functions, it causes an error
19:13:31 <lf94> the right side?
19:13:33 <tabemann> > (+1) $  (- 2)
19:13:35 <lambdabot>  -1
19:13:41 <lf94> Lol
19:13:43 <joelteon> however, haskell thinks (-2) is negative 2
19:13:49 <lf94> It does work what the heck
19:13:51 <joelteon> > (+1) $ (subtract 2)
19:13:52 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
19:13:52 <Axman6> lambdabot has some strange Num instances
19:13:52 <lambdabot>    arising from a use of ‚ÄòM74822114328266370122297.show_M74822114328266370122...
19:13:53 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
19:13:53 <lambdabot>  Note: there are several potential instances:
19:13:53 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
19:13:55 <lf94> ah
19:13:56 <joelteon> that's the error you want
19:14:06 <lf94> > (+1) $ 4
19:14:08 <Axman6> yeah you can'e partially apply (-) on the right
19:14:08 <lambdabot>  5
19:14:08 <zwer> uh huh, I forgot about - quirk
19:14:14 <lf94> Ok I understand now
19:16:13 <lf94> so apply result on the right of $ to function on the left?
19:16:45 <zwer> yes. f $ x is the same as f x, as seen from the source:
19:16:49 <zwer> @src ($)
19:16:49 <lambdabot> f $ x = f x
19:17:07 <tabemann> note that f $ g $ x = f . g $ x
19:17:29 <lf94> I see f $ g $ x as: apply result of x to g, and g to f
19:17:39 <lf94> is that right?
19:17:51 <tabemann> that means apply result of x to g, and apply result of that to f
19:18:39 <tabemann> f $ g $ x = f . g $ x is good to remember when one wants one code to have as few parens as possible, but not too many dollar signs either
19:18:52 <edwardk> i like $
19:19:48 <tabemann> I personally prefer $ over parens, but prefer to not chain multiple $s if I can help it
19:22:12 <goatfins> Has anyone here actually used the ncurses library on hackage?
19:23:18 <goatfins> I'd not be surprised if I'm messing something up but at this point I don't really know what I could be doing wrong.
19:23:33 <Axman6> all the magic of ($) isn't in its (shown above) definition, it's its fixity and binding power
19:24:06 <kuyatzu> Axman6: which is the lowest afaik?
19:26:10 <dmj`> twopoint718: withReader modifies the 'read-only' state of your Reader
19:28:02 <tabemann> for some reason I can't see how the Lisp people stand so many parens when I've got ($) and (.) to work with
19:29:59 <tabemann> even though sometimes it feels ugly when I mix parens and ($) in certain ways, e.g. f (g (h x)) y = f (g $ h x) y
19:32:00 <silasm> tabemann: sometimes I envy lisp's lack of infix operators when using haskell.
19:32:11 <silasm> so it's a double-edged sword.
19:32:57 <dfeuer_> I'm reading some backlog and wondering if Cale saw the messages on the libraries list about nubBy.
19:33:11 <tabemann> well it's certainly easier to write a Lisp parser than it is to write a Haskell one
19:33:29 <goatfins> Is there a different channel for support with cabal/hackage issues?
19:34:08 <dibblego> there is #hackage
19:36:05 <romildo> Why does ghci report an error in the expression:   do { let x = "hi" ; putStr x }
19:36:06 <romildo> parse error in input '}'
19:37:30 <tabemann> romildo: do { let {x = "hi"} ; putStr x }
19:38:39 <jTT> hi, is there any good reason why the arguments  here in constructor and runWriter would be swapped? newtype Writer w a = Writer { runWriter :: (a, w) }
19:39:30 <bryanedds> Cale, you still about?
19:39:46 <romildo> tabemann, so the compiler thinks that what follows the semicolon begins a second definition and belongs to the let, right?
19:39:47 <dibblego> jTT: the type constructor argument order is important ó the other is not
19:40:04 <dibblego> it is important so you can write e.g. instance Functor (Writer w)
19:40:19 <tabemann> romildo: you can't nest things that use layout inside non-layout constructs
19:40:36 <jTT> but why not then also define: runWriter :: (w, a)
19:41:03 * hackagebot peyotls 0.1.6.1 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.1.6.1 (YoshikuniJujo)
19:43:03 <dfeuer_> edwardk, why do you like ($) when its type is (a -> b) -> (a -> b) and not just (a -> a)?
19:43:45 <flyingfisch> why doesn't this work? test (x:xs) = xs ++ x
19:43:52 <flyingfisch> > test (x:xs) = xs ++ x
19:43:53 <lambdabot>  <hint>:1:13: parse error on input ‚Äò=‚Äô
19:44:04 <flyingfisch> > let test (x:xs) = xs ++ x
19:44:05 <lambdabot>  not an expression: ‚Äòlet test (x:xs) = xs ++ x‚Äô
19:44:13 <tabemann> xs is a list
19:44:15 <tabemann> x is not
19:44:21 <tabemann> (++) takes two lists
19:44:31 <flyingfisch> x is not... oh!
19:44:36 <tabemann> > let test (x:xs) = xs ++ [x]
19:44:37 <lambdabot>  not an expression: ‚Äòlet test (x:xs) = xs ++ [x]‚Äô
19:44:42 <flyingfisch> ok cool
19:44:49 <tabemann> @let test (x:xs) = xs ++ [x]
19:44:50 <lambdabot>  Defined.
19:45:04 <flyingfisch> > test "hi there"
19:45:06 <lambdabot>  "i thereh"
19:45:10 <flyingfisch> good
19:45:19 <tabemann> note that you really don't want to do this if you can help it, because it's really inefficient for big lists
19:45:25 <flyingfisch> k...
19:45:33 <dfeuer_> Well, sometimes :-)
19:45:33 <flyingfisch> what would be a better alternative?
19:45:50 <dfeuer_> flyingfisch, it depends entirely on what you're doing.
19:45:55 <tabemann> when working with lists, always prepend if you can help it
19:46:15 <flyingfisch> for that function, is there a different way to do it without ++?
19:46:22 <tabemann> no
19:46:30 <zwer> x can be a list too. but then xs is a list of those lists, so ++ still doesn't work
19:46:31 <dfeuer_> Unless you're walking/rebuilding already, in which case it is often okay.
19:46:43 <flyingfisch> no way to tack the beginning onto the end without (++)?
19:46:57 <flyingfisch> well how about this:
19:47:02 <tabemann> it's inherently inefficient
19:47:04 <flyingfisch> test :: String -> String
19:47:06 <dfeuer_> flyingfisch, there's no significantly *better* way to tack something onto the end of a list.
19:47:12 <flyingfisch> ok
19:47:15 <tabemann> even if you use some other function to do it, it's still going to be inefficent
19:48:03 <dfeuer_> Unless you're already rebuilding the list, and do it right.  map f xs ++ [y]  should be about as fast as map f xs.
19:48:11 <dfeuer_> Because GHC uses some tricks.
19:48:15 <tabemann> note that there are sequence types with better behavior in this regard, but unfortunately there aren't quite as many APIs that use them
19:48:35 <dfeuer_> tabemann, that is changing FAST!
19:49:32 <tabemann> people are actually using Seq?
19:49:40 <dfeuer_> The so-called Foldable-Traversable Bridge-Burning Proposal is nearly ready and can probably be expected to appear in 7.10.
19:49:57 <dfeuer_> GHC already has OverloadedLists.
19:50:05 <tabemann> cool
19:50:20 <tabemann> Seq is better for just about everything other than making infinite lists
19:50:30 <dfeuer_> It also has MonadComprehensions. So a lot of the infrastructure that previously made lists "special" is getting replaced by things that will work for other things.
19:50:32 <tabemann> and consing
19:50:37 * DanC__ wonders if finger trees figure in here anywhere
19:50:47 <dfeuer_> DanC__, Seq is finger trees.
19:50:56 <DanC__> ah!
19:51:05 <dfeuer_> But note that a Banker's queue is about twice as fast as using Seq as a queue...
19:51:22 <dfeuer_> [a simple banker's queue with plain old lazy lists]
19:51:46 <dfeuer_> So don't just dump everything in a Seq bucket until you know you need that flexibility.
19:52:19 <dfeuer_> Or, better, use  type Foo a = Seq a  or whatever, and use a lot of nice generic operations and then replace Seq with what you really need later.
19:52:29 <dfeuer_> Of course you can do the same with lists....
19:52:46 * dfeuer_ wonders if Cale is still here.
19:52:47 <DanC__> I've been in python-land for so long that it's hard for me to imagine performance issues that are actually noticeable in haskell apps. What haskell apps are people building where these performance issues are noticeable/measurable?
19:53:07 <tabemann> is a banker's queue where you have two (lazy) lists, and whenever you try to uncons from the second list and it's empty, you take the first list, reverse it, and put it in the place of the second list, replacing the first list with an empty list?
19:53:29 <merijn> DanC__: It depends, poor design can lead to poor performance in any language
19:53:46 <DanC__> well, yes, I know it depends; that's  why I'm interested in specific examples
19:53:46 <trap_exit> on ubuntu 14, what's the best way to install ghc 7.8.3 ?
19:53:52 <merijn> DanC__: Also, some people write code to compete for high performance stuff
19:54:19 <dfeuer_> tabemann, close. You actually need to rotate earlier than that.
19:55:08 <merijn> DanC__: According to the binary docs they can get up to 1Gb/s encoding speeds
19:55:30 <dfeuer_> tabemann, you want to make sure that |front| >= p |rear| for some p>0.
19:55:45 <merijn> DanC__: What qualifies as a performance issue depends on how much performance you're trying to get :)
19:56:04 * hackagebot xml-push 0.0.0.12 - Push XML from/to client to/from server over XMPP or HTTP  http://hackage.haskell.org/package/xml-push-0.0.0.12 (YoshikuniJujo)
19:57:42 <dfeuer_> DanC__, since GHC is usually used to compile things down to assembly or LLVM, it's usually expected to do a good job of it. Does Python even use JIT compilation?
19:57:55 <tabemann> no
19:57:58 <tabemann> CPython at least
19:58:08 <DanC__> there are JIT compilers for python; I don't use them
19:58:15 <tabemann> CPython is *slow*; PyPy is considerably faster
19:59:14 <tabemann> CPython is slow enough that you probably won't as easily notice the effect of inefficient code since there's so much overhead from the runtime to begin with
19:59:19 * DanC__ is still hoping for concrete examples
20:00:07 <merijn> tabemann: And there's even faster implementations, I forgot it was one from Oracle Labs or the university partners. But that implementation was written by 1 phd in 1 year and can beat or rival pypy on 70% of the benchmarks already
20:00:19 <DanC__> the sort of performance problems that I have found worth fixing have been things like inserting 10,000 rows into a database, one row per transaction. I batched them up and sped something from ~2 hours to ~20 seconds.
20:00:47 <merijn> DanC__: There's a haskell software defined networking program that routes 20 million requests per second
20:01:07 <merijn> (Of course that required implementing a new IO manager in 7.8 to get there)
20:02:37 <DanC__> a tiny bit of my funding comes from US-Ignite, so I learned a teeny bit about software defined networking. It's so far from what I do that I can hardly see that far.
20:03:02 <DanC__> I can see the applicability in huge multi-tenancy data centers
20:03:42 <DanC__> but over wide areas, the administrative issues seem pretty far from workable
20:04:05 <merijn> DanC__: The point is: I'm not really sure what kinda answer you're expecting to "what are people doing that they have performance issues"
20:04:16 <merijn> The answer is "the same thing they do in other languages"
20:04:27 <DanC__> the SDN answer was on point
20:05:03 <DanC__> well, in PHP, nobody does 10^6/sec of anything.
20:05:40 <DanC__> I'm surrounded by PHP. It's depressing. I shouldn't even bring it up here; borderline cruelty.
20:06:05 * hackagebot xml-push 0.0.0.13 - Push XML from/to client to/from server over XMPP or HTTP  http://hackage.haskell.org/package/xml-push-0.0.0.13 (YoshikuniJujo)
20:06:26 <merijn> DanC__: Right, but haskell people are trying to compete with C and Java performance, not python/ruby performance, because theirs is abysmal anyway :)
20:07:03 <simpson> Indeed, nobody has ever made Python or Ruby ever go fast in any situation.
20:07:47 <DanC__> and Java folks have an amazing ability... or... cultural habit/bias... of chewing up CPU and RAM
20:08:03 <trap_exit> eh, hte JVM optimizer is pretty good
20:08:09 * trap_exit used to use Clojure
20:08:16 <DanC__> "export 60K rows from the database, serialize as XML, send do the client..."
20:08:21 <tabemann> Haskell also is trying to compete with Erlang on concurrency
20:08:39 <tabemann> but with much better straight-line performance than Erlang
20:09:53 <DanC__> actually, simpson, at the PyData conference, I saw somebody make python go remarkably fast... they had a query engine that used all sorts of very dynamic python techniques and fed it to a back-end that used LLVM to make it fly.
20:09:55 <trap_exit> I am downloadin ghaskell platform
20:10:06 <merijn> DanC__: You should pay more attention to what the Hotspot people are doing...
20:10:07 <trap_exit> 2 minutes left until I code away a storm
20:10:29 <merijn> I dunno if the "One VM to rule them all" talk is available anywhere, but it's pretty impressive
20:11:00 <trap_exit> is that one vm LLVM or JVM ?
20:11:09 <DanC__> yes, the JVM can be made to go really fast. But if you throw a dart at the Java world, you're likely to hit code that's 10^5x slower than it needs to be.
20:11:22 <simpson> DanC__: I was being incredibly sarcastic. I'm used to this channel being hostile towards object-based and dynamically-typed languages.
20:11:38 <DanC__> ah.
20:11:59 <DanC__> fwiw, said PyData talk: http://tuulos.github.io/pydata-2014/#/
20:12:10 <merijn> trap_exit: jvm
20:12:48 <merijn> DanC__: They're working on basically letting people write "dumb" AST interpreters in java and have them automatically be able to use hotspot's jitting magic
20:13:15 <simpson> That'll be exciting. Took 'em long enough.
20:13:27 <DanC__> what of the bytecode verifyer?
20:13:29 <merijn> DanC__: They have naive implementations of, for example, JavaScript (written in a few months by like a handful of people) which outperforms Google's V8 (many years and many people) on almost all benchmarks
20:13:33 <DanC__> is that still in the game?
20:14:28 <merijn> oh, looks like there's a video of the talk already
20:14:33 <dfeuer_> How do you convert from Float to Double?
20:14:45 <merijn> realToFrac
20:14:50 <trap_exit> tar -xzvf haskellplatform.tgz
20:14:53 <merijn> :t realToFrac :: Float -> Double
20:14:54 <lambdabot> Float -> Double
20:15:46 <merijn> https://wiki.openjdk.java.net/display/Graal/Publications+and+Presentations
20:16:06 <merijn> Has video + slides for the talk I mentioned (although this appears to be a fairly old talk)
20:17:48 <dfeuer_> Thanks, merijn
20:18:42 <dfeuer_> UM no.
20:18:51 <dfeuer_> merijn, that function is a very bad joke.
20:18:53 <nshepperd> alternative GHC.Float.float2Double if you have the need for speed
20:19:04 <dfeuer_> Ahhh.
20:19:10 <Cale> dfeuer_: nope, I didn't see them
20:19:31 <dfeuer_> OK, nshepperd. That's more what I was looking for.
20:20:06 <dfeuer_> Cale, thomie (sp?) wants to fix a bug you reported years ago; some others don't think it's really a bug.
20:20:13 <nshepperd> I think realToFrac goes through Rational or something
20:20:24 <dfeuer_> Yes, nshepperd, it does.
20:21:07 <shachaf> @src Real
20:21:07 <lambdabot> class (Num a, Ord a) => Real a where
20:21:08 <lambdabot>     toRational :: a -> Rational
20:21:11 <shachaf> This is the best class.
20:22:01 <dfeuer_> nshepperd, but it appears that there actually are RULES to "fix up" realToFrac for common cases.
20:22:47 <dfeuer_> shachaf, I assume you're being sarcastic?
20:23:08 <shachaf> I don't think it's the best class, if that's what you mean.
20:23:16 <shachaf> It's a funny method.
20:25:47 <tabemann> toRational isn't a partial function only because no type with a Real instance will truly have infinite precision
20:26:09 <shachaf> Well, CReal does.
20:26:47 <dfeuer_> shachaf, I assume that's for continued fractions or something?
20:26:56 <shachaf> Definitely something.
20:27:14 <dfeuer_> Oh.
20:29:26 * dfeuer_ notes that the numbers package depends only on base. Nice.
20:29:53 <shachaf> I'm not sure that's nice.
20:30:11 <shachaf> I mean: I'm not sure that's something to aspire to.
20:30:51 <dfeuer_> Nice for me, because I can install it without worrying that it will introduce dependency issues anywhere.
20:30:53 <Total_1mmersion> How do you get text to wrap if needed using the pretty library? I'm using $+$ and it's inserting a new line every time.
20:32:15 <Cale> dfeuer_: Yeah, it's not a bug according to the Report
20:32:45 <Cale> dfeuer_: But I think nubBy and groupBy and so on would be better off with a more refined specification
20:33:00 <dfeuer_> Cale, I still think you should respond to the list with your opinion!
20:33:03 <Cale> Since those functions as implemented in the report are useful for non-equivalence-relations
20:33:17 <Cale> Well, I reported the thing originally didn't I?
20:33:26 <dfeuer_> I think people don't recognize exactly why you want that.
20:33:28 <Cale> My opinion hasn't changed :)
20:33:34 <Cale> ah, okay
20:33:42 <Cale> Well, it's not so hard to come up with examples
20:33:48 <dfeuer_> Yes, Cale, you were one of the people who reported it, but you didn't give detailed use cases, I don't think.
20:34:04 <Cale> Like, try nubBy (<) for instance
20:34:09 <dfeuer_> Which I think you will need to convince people to change the spec (or change the code).
20:34:29 <dfeuer_> I have no idea what nubBy (<) is supposed to do.
20:35:14 <merijn> dfeuer_: Nothing sane
20:36:21 <dfeuer_> Oh, hmm..
20:36:55 <bryanedds> can I convert from a contramap to a map?
20:37:01 <dfeuer_> I'm not really seeing what you'd *do* with such a thing.
20:37:32 <dfeuer_> bryanedds, a contramap? What's that, a contravariant functor or something?
20:38:01 <bryanedds> :t Data.Functor.Contravariant.contramap
20:38:02 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
20:38:13 <benzrf> contra dance
20:38:15 <dfeuer_> bryanedds, if so, I think the answer is basically no, unless it's an endofunctor, in which case you can apply it twice.
20:38:22 <dfeuer_> But then you've accomplished nothing :P
20:38:39 <benzrf> dfeuer_: all Functors are endofunctors...
20:38:59 <dfeuer_> benzrf, sorry, I was using the wrong terminology/thinking.
20:39:08 <edwardk> dfeuer_: i use $ over . in many cases because it infers better in the presence of rank-2 types
20:39:35 <edwardk> dfeuer_: when i refactor code to use higher rank types more code survives in $ style than . style
20:39:49 <edwardk> as much as i personally love composing functions
20:39:53 <Cale> merijn: It does something perfectly sane :)
20:40:09 <tabemann> that's because GHC special-cases ($) w.r.t. higher-rank types
20:40:11 <dfeuer_> edwardk, ah, you mean you like the magic typing rules that Simon Peyton Jones gave ($)?
20:40:17 <edwardk> tabemann: yep
20:40:32 <dfeuer_> Yech.
20:40:36 <zwer> what magic typing rules?
20:40:41 <edwardk> dfeuer_: so $ is indistinguishable from magic
20:41:03 <tabemann> ($) doesn't operate like a real function
20:41:15 <dfeuer_> edwardk, I think it'd be much nicer to put that magic in the parser, making x$y *actually* the same as (x)(y).
20:41:29 <benzrf> wait
20:41:31 <benzrf> how does ($) workd iff
20:41:33 <benzrf> *work diff
20:41:36 <edwardk> dfeuer_: i'd be amenable to that actually in many ways
20:41:52 <edwardk> benzrf: ghc is perfectly happy to instantiate the type variables of ($) with polytypes
20:42:14 <dfeuer_> It was done to allow stuff like  runST $ ....  that aren't supposed to be allowed.
20:42:35 <dibblego> I use parentheses
20:43:04 <benzrf> polytypes
20:43:09 <benzrf> uwot
20:43:11 <benzrf> :t runST
20:43:12 <lambdabot> (forall s. ST s a) -> a
20:43:22 <benzrf> p-polytypes
20:43:40 <dibblego> @type (runST $)
20:43:41 <lambdabot>     Couldn't match type ‚Äòa‚Äô with ‚Äòforall s. ST s a1‚Äô
20:43:41 <lambdabot>       ‚Äòa‚Äô is a rigid type variable bound by
20:43:41 <lambdabot>           the inferred type of it :: a -> a1 at Top level
20:43:47 <benzrf> o_O
20:43:53 <benzrf> cripes
20:43:59 <benzrf> why do i keep saying that
20:44:26 <dfeuer_> Anyway, edwardk, my point was that aside from that magical rule (or, if you like, in Haskell 98), ($) is basically just id with a more restricted type.
20:44:41 <dfeuer_> benzrf, I don't know. Crepes are much tastier.
20:47:43 <Mokosha_> is there a nifty one-liner for descending sort
20:47:48 <Mokosha_> instead of defining my own compare?
20:48:35 <merijn> :t sortBy (flip compare)
20:48:36 <lambdabot> Ord a => [a] -> [a]
20:48:42 <merijn> > sortBy (flip compare) [1..10]
20:48:44 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
20:49:28 <Mokosha_> thanks
20:49:35 <Mokosha_> yea just figured it out myself, too =P
20:49:42 <Mokosha_> felt kinda silly
20:52:45 <dfeuer_> Cale, what is that nubBy (<) supposed to do?
20:53:34 <dfeuer_> Oh...
20:53:38 <dfeuer_> Interesting......
20:54:30 <bryanedds> it blows my mind to think that laziness may actually be desirable in the general case
20:55:20 <dfeuer_> bryanedds, well, it has its ups and downs. But it definitely makes it easier to structure programs around data structures.
20:55:35 <dfeuer_> Produce, transform, consume.
20:56:22 <dfeuer_> It can be a very pleasant way to design a program, and it's nice if you can implement it the same way you design it.
20:57:13 <bryanedds> I guess the only other problem I have left with Haskell is that it's so hard to pull intent out of haskell code
20:57:28 <bryanedds> usually the first thing I look for in code is intent
20:57:39 <bryanedds> but I just rarely see that in haskell code, even the code I write in it
20:57:47 <dfeuer_> bryanedds, that mostly depends on how it's written. Definitely some people write inscrutable code.
20:57:52 <bryanedds> is this just a trade-off
20:58:31 <bryanedds> I understand why 1 letter var names are used - it's so you can see the more general structure, such as a functor, monad, et al
20:59:03 <dfeuer_> bryanedds, those are not always a good idea. But you don't have to use them.
20:59:06 <bryanedds> with long .NET-style names you can't see the generality of structures as easily
20:59:17 <merijn> bryanedds: An important step is to get used to relying on types
20:59:23 <dfeuer_> True dat.
20:59:53 <bryanedds> that's very hard for me because I've always programmed by reasoning about semantics
21:01:02 <dfeuer> The types constrain the semantics. But you're free to use whatever variable names you like (as I do).
21:01:15 <bryanedds> I love when I can lean on the types, but it seems like I tradeoff semantic scrutability at the level of generality common to haskell code
21:02:00 <dfeuer> bryanedds, the people who know a lot more Haskell than I do say this a lot, and I'm starting to see it myself‚Äîdon't study the abstraction; study its instances.
21:02:02 <bryanedds> is this more of a problem with the way I currently think than it is a problem with haskell?
21:02:08 <edwardk> bryanedds: let me try to justify the one letter variable names as a devil's advocate
21:02:19 <bryanedds> oh, I just did that :)
21:02:29 <bryanedds> it's so you can see the more general structure
21:02:36 <bryanedds> which I get
21:02:41 <edwardk> well, lets look at it in a type
21:02:43 <dfeuer> Once you've seen the same pattern show up in code a lot of times, you start to appreciate why you might want to extract that pattern.
21:02:47 <edwardk> if you took something like
21:02:51 <edwardk> :t foldr
21:02:52 <lambdabot> (a -> b -> b) -> b -> [a] -> b
21:02:58 <dfeuer> bryanedds, edwardk is the master :-)
21:03:59 <edwardk> and made all those variables things like foldr :: (value -> accumulator -> accumulator) -> accumulator -> [value] -> acumulator
21:04:23 <bryanedds> it would obscure the structure, right?
21:04:27 <edwardk> then now the important thing here is which of those types unify with each other
21:04:33 <dibblego> 1 letter variable names are used, because 0 letter variable names are disallowed
21:04:43 <edwardk> so here the fact that i typoed acumulator in the last thing that matters
21:04:47 <edwardk> and it is obscured
21:05:00 <shachaf> Just do it Miranda-style.
21:05:05 <bryanedds> hmmm
21:05:12 <edwardk> you need to care what unifies with what
21:05:23 <edwardk> so whatever gets in the way of seeing where the types match is suboptimizing your time
21:05:55 <bryanedds> I usually use single letter names for type vars in F#
21:05:56 <edwardk> we choose to pick the length of our variable names mostly by how long they are in scope
21:06:06 <tabemann> Miranda-style you just see lots of asterisks, though
21:06:41 <dibblego> consequently, it is *very important* that as much unnecessary information is eliminated from variable names
21:07:59 <dfeuer> edwardk, but variable names in terms can be longer without that risk....
21:08:28 <edwardk> dfeuer: well, you're still visually matching them up.
21:08:32 <dfeuer> Miranda was Haskell's mother, right?
21:08:44 <merijn> dfeuer: Miranda, Clean, Isabelle
21:08:47 <merijn> iirc
21:09:22 <edwardk> dfeuer: more or less
21:09:22 <bryanedds> Thinking in terms of types rather than semantics really screws me up the most
21:09:37 <merijn> The types tell you what the semantics are
21:09:46 <bryanedds> but again, that may be an artifact of my current thinking rather than a problem with haskell style
21:09:46 <dfeuer> Well, they constrain the semantics, anyways.
21:09:53 <merijn> bryanedds: Quick question, how many possible implementations are there for "Int -> Int -> Int"?
21:09:58 <dfeuer> They constrain the semantics in a way that is very often useful.
21:10:09 <dfeuer> merijn, many many.
21:10:15 <shachaf> How many possible implementations are there for Bool -> Bool -> Bool?
21:10:22 <dfeuer> Few.
21:10:26 <shachaf> How many?
21:10:37 <bryanedds> 2?
21:10:40 <bryanedds> er
21:10:41 <dfeuer> No.
21:10:46 <bryanedds> 4?
21:10:50 <shachaf> I think I'm veering off-topic.
21:11:10 <monochrom> infinitely many possible implementations. finitely many possible observable behaviours.
21:11:27 <shachaf> Yes. I should have asked how many functions there are with that type.
21:11:32 <dfeuer> I believe there are 3^4 = 81 of them, only 2^4=8 of which are interesting.
21:11:33 <bryanedds> well, if you don't reduce terms I suppose
21:11:34 <monochrom> note that each single observable behaviour admits infinitely many possible implementations
21:11:36 <merijn> bryanedds: Ok, functions
21:11:40 <edwardk> bryanedds: 4 cases to consider each can be one of two values, so 8 not counting different strictness behaviors
21:11:57 <shachaf> Strictness behaviors are the best part.
21:11:58 <monochrom> . o O ( why do programmers conflate observable behaviour with implementation? )
21:12:08 <edwardk> dfeuer: you need to consider monotonicity if you want to care about strictness
21:12:13 <dfeuer> Er ... sorry, I guess that makes more than 81.
21:12:16 <merijn> bryanedds: Basically for every unique combination of Int values you get a mapping to any of the Int values, so lets say at least several billion different behaviours
21:12:18 <bryanedds> because we assume the terms will be reduced
21:12:21 <edwardk> and there are a disturbing number of ways to consider them
21:12:24 <merijn> bryanedds: Now another question
21:12:25 <shachaf> I'd actually be interested in an easy way to answer that question.
21:12:34 <merijn> bryanedds: How many possible behaviours are there for "a -> a"?
21:12:35 <copumpkin> 16 if total?
21:12:38 <dfeuer> edwardk, hmmm, point!
21:12:51 <bryanedds> 1; id>
21:12:53 <bryanedds> ?
21:13:16 <merijn> bryanedds: Well, technically 3, id, undefined and "const undefined", but yeah
21:13:21 <edwardk> bryanedds: yes, again ignoring strictness concerns and bottoms
21:13:25 <copumpkin> 2^2^2
21:13:28 <monochrom> not all 81 are implementable in safe Haskell. those that cannot, can be implemented using for example spoon.
21:13:41 <merijn> bryanedds: in other words, the abstracter the types, the more constrained the implementation
21:13:53 <merijn> bryanedds: i.e. the more you know about what it could do
21:13:57 <merijn> :t foldr
21:13:58 <edwardk> this is why we care about "fast and loose reasoning is morally correct"
21:13:59 <lambdabot> (a -> b -> b) -> b -> [a] -> b
21:14:02 <shachaf> monochrom: If you count spoon, then suddenly nontermination is different from an exception, and there are even more possible functions.
21:14:03 <monochrom> I have in mind, for example, one that behaviours as: f bot False = False; f False bot = False; f bot bot = bot
21:14:05 <edwardk> @google fast and loose reasoning is morally correct
21:14:05 <dfeuer> edwardk, okay, that monotonicity does indeed make things interesting. I was actually just thinking about the fact that blah a b can produce any one of three values even if a and b are known non-bottom.
21:14:06 <lambdabot> http://www.cse.chalmers.se/~nad/publications/danielsson-et-al-popl2006.html
21:14:06 <lambdabot> Title: Fast and Loose Reasoning is Morally Correct
21:14:30 <merijn> bryanedds: foldr's type tells you a lot more than "(Int -> Double -> Double) -> Double -> [Int] -> Double" does
21:14:36 <edwardk> dfeuer: that paper motivates why you can basically ignore the behavior around bottoms there if you only care where the function is defined
21:14:39 <bryanedds> the more constrained the impl, the more likely the code is correct?
21:14:53 <dfeuer> monochrom, what is spoon?
21:15:04 <merijn> bryanedds: Well, a constrained numbr of behaviours constrains the possibility space you have to think off :)
21:15:07 <monochrom> spoon is a package on hackage
21:15:11 <dfeuer> edwardk, yeah, I've nead the intro.
21:15:12 <edwardk> bryanedds: i use types to make the space of possible programs i can write constrained down enough that any program i write that typechecks is almost suredly correct
21:15:28 <merijn> bryanedds: Especially when you can disregard "stupid" spaces like "map = undefined" or "map _ _ = []"
21:15:35 <edwardk> dfeuer: its a hack that lets you break monotonicity ;)
21:15:42 <shachaf> Did you see Conor McBride's talk about keeping your neighbors in order?
21:15:45 <bryanedds> edwardk, that sound practical only for when writing things like library primitives
21:15:50 <dibblego> bryanedds: everything edwardk is explaining has also been exploited using C# in the xsharpx library
21:15:55 <monochrom> "spoon :: NFData a => a -> Maybe a" "Evaluate a value to normal form and return Nothing if any exceptions are thrown during evaluation."
21:15:57 <shachaf> Hmm, I heard edwardk was busy telling his life story during that talk.
21:15:58 <dfeuer> edwardk, that must be a truly horrible hack.
21:16:01 <merijn> bryanedds: Why? It's how I write programs too :)
21:16:13 <edwardk> bryanedds: surprisingly its valuable for almost everything i write
21:16:19 <edwardk> shachaf: during conor's talk? no
21:16:25 <edwardk> shachaf: i was in the room for that one
21:16:33 <edwardk> it was one of the best talks of icfp this year
21:16:34 <merijn> bryanedds: One neat hack I have in a library I'm working right now is that GHC is statically preventing me from using the wrong authentication method in network handshake code :)
21:17:36 <bryanedds> I admit those are nice properties, but I don't see how they would scale (not to say they wouldn't - I'm still trapped underneath the blub paradox)
21:17:43 <shachaf> edwardk: Maybe http://tim.dreamwidth.org/1859562.html has the timing wrong.
21:17:44 <edwardk> monochrom: that is about as interesting for the conversation as saying 'unsafeCoerce is sometimes useful' though ;) its factual, but not terribly informative other than knowing it exists can drive folks to bad design decisions earlier in their career than otherwise would be warranted ;)
21:18:15 <shachaf> I enjoyed that talk, at any rate.
21:18:22 <shachaf> But then again I typically enjoy his things.
21:18:48 <edwardk> shachaf: timing is a bit off. i think he missed marlow's talk due to talking to me
21:19:09 <edwardk> or whatever talk came before marlow's
21:19:11 <nshepperd> the one time I considered using unsafeCoerce, it turned out it doesn't work
21:19:15 <monochrom> edwardk: is this statement interesting? <monochrom> not all 81 are implementable in safe Haskell. those that cannot, can be implemented using for example spoon.
21:19:34 <dfeuer> There are more than 81.
21:19:35 <merijn> bryanedds: Fairly well, I managed to extend a pandoc parser and I still have no clue how pandoc itself works :)
21:19:44 <dfeuer> But 81 are implementable in Safe Haskell.
21:19:47 <nshepperd> (something to do with floating point registers makes unsafeCoerce :: Word32 -> Float work wrongly)
21:19:51 <merijn> bryanedds: I just followed the types and hacked up the bit I cared about and all tests kept passing :)
21:20:11 <edwardk> monochrom: my main point is that spoon is _very_ rarely useful is all. its like the 'how do i get something out of IO', 'use unsafePerformIO' explanation =P
21:20:12 <dfeuer> If I haven't calculated wrong.
21:20:22 <edwardk> dfeuer: you have.
21:20:26 <dfeuer> Oops.
21:20:30 <merijn> bryanedds: The lack of mutable global state and the presence of types means you can hack code with far less need to udnerstand the "big picture" of an entire framework
21:20:31 <monochrom> but I did not advocate using spoon.
21:20:42 <dfeuer> I had two glasses of wine with dinner, and my stomach is stuffed :-P
21:20:46 <edwardk> dfeuer: consider when the function is strict, does it force the argument after receiving the first one, the second?
21:21:04 <edwardk> dfeuer: this is why i just advocate saying 'screw it' and using fast and loose reasoning =P
21:21:17 <dibblego> bryanedds: how many implementations of this are there? A Wibble<A>(A a) ?
21:21:21 <merijn> bryanedds: I tried similarly hacking Mercurial to fix something, I looked at the code and I had literally no clue what everything was and what it was mutating, I did not succeed in implementing my minor patch
21:21:47 <bryanedds> oh, I'm already sold on pure functions and strong types :)
21:22:08 <edwardk> bryanedds: dibblego's question matters =)
21:22:25 <bryanedds> well considering it's a C-style syntax
21:22:31 <dibblego> it is C# syntax
21:22:33 <dfeuer> edwardk, okay, let me think about this. There are 4 non-bottom possible inputs. For each of those, the result can be made to be True, False, or _|_. That gives a lower bound of 81. But not a tight bound. OK.
21:22:37 <edwardk> bryanedds: consider C# of F#
21:22:49 <dibblego> which I thought was your history (sorry if I misunderstood)
21:22:53 <monochrom> dfeuer: <monochrom> I have in mind, for example, one that behaviours as: f bot False = False; f False bot = False; f bot bot = bot
21:23:10 <bryanedds> I'm pure functional F#
21:23:28 <dfeuer> monochrom, yeah, that's illegal.
21:23:31 <monochrom> take "bot" as ‚ä•
21:23:32 <edwardk> dfeuer: well you have bottom inputs as well to consider and the fact that you may or may not force each input even if you don't use it and you may choose to do so after taking the first argument, may be bottom before the first argument, may force things after the second, etc.
21:23:50 <bryanedds> dibblego, I really don't know
21:24:10 <dibblego> bryanedds: there is one, if you are a moral person
21:24:13 <bryanedds> is in an instance method?
21:24:15 <dfeuer> edwardk, yeah, I'm thinking about it.
21:24:21 <bryanedds> *it
21:24:45 <bryanedds> if it is, you're totally screwed reasoning about it :)
21:24:53 <dibblego> bryanedds: now imagine you and I are working on a team and I see that typ, then I say, "since bryanedds is moral, I know what that does ó no need to look further"
21:25:03 <dibblego> no, it is static
21:25:14 <edwardk> bryanedds: the main concern is that languages like c#/f# give you tools for asking the type of a thing. isInstanceOf/asInstanceOf in scala, so you can of course cheat there, and check to see if the type is an int and add one
21:25:29 <dibblego> bryanedds: next imagine you and I are still working on a team, but the type is much less trivial ó but I apply the same reasoning
21:25:39 <edwardk> bryanedds: so parametricity is more of an article of faith in those languages.
21:25:51 <dibblego> bryanedds: now know that I am *doing this very activity right now* and the "team" is people like edwardk and others who write code
21:26:19 <dfeuer> edwardk, what about type families?
21:26:21 <dibblego> I am looking at identifier names, except for the purpose of unification (x = x)
21:26:26 <dibblego> +not
21:26:26 <edwardk> pretty much anything we can conceal behind type variables like that is not a going concern for the function in question
21:26:53 <dibblego> bryanedds: we hamer this point home, because we want you on the team too :)
21:27:07 <nshepperd> id = \x -> unsafePerformIO (hackMainframe >> launchMissiles >> return x) :: a -> a
21:27:14 <edwardk> dfeuer: what about them? to use the type family you have to get something that uses it, like an instance or something that can vary its behavior
21:27:54 <dfeuer> edwardk, I don't know enough about it, mostly. It seems ~weird.
21:28:35 <bryanedds> it's interesting - I suppose the thing that trips me up is that I did not know that such generality could be acheive across a whole codebase
21:28:41 <merijn> dfeuer: type families don't break parametricity
21:28:57 <N1cXP8ChUBFe3> I have tried posting in the haskell-beginners but that channel seems to have gone to sleep. Does anyone know why both of http://stackoverflow.com/a/7781350 and http://stackoverflow.com/a/7781125 will crash upon calling  multiProduct  when implemented verbatim from those posts? I have already tried importing Data.Maybe to no success.
21:28:59 <merijn> dfeuer: Closed ones are unextendable and open type families obey the open world of one instance per type
21:29:09 <dfeuer> merijn, something somewhere made me think they did.
21:29:26 <bryanedds> I see the desirable properties, but did not see the wider applicability of the principles that get us there
21:29:47 <merijn> dfeuer: They make types less obvious, but they can't inspect and change based on type variables
21:30:04 <edwardk> bryanedds: i have code that is pretty much just a sea of type variables
21:30:06 <shachaf> N1cXP8ChUBFe3: Verbatim? Please show your full code and results.
21:30:07 <dibblego> N1cXP8ChUBFe3: do you have your own source file that you could paste to hpaste.org and we can check it out?
21:30:14 <edwardk> type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
21:30:17 <bryanedds> I still don't, actually, but again, that's because I'm still under the blub paradox
21:30:20 <N1cXP8ChUBFe3> http://lpaste.net/111585
21:30:27 * dfeuer wonders what happens when edwardk and Oleg walk into the same room.
21:30:31 <merijn> bryanedds: The solution is: Less questions, more hacking :D
21:30:54 <dibblego> N1cXP8ChUBFe3: yeah you need a type signature on multiProduct
21:30:56 <edwardk> the rank-2 type there can't be written in f#, the Functor typeclass can't be written in f#, the safety of all that parametricity on f, s, t, a, b can't be expressed
21:31:09 <edwardk> and that is one of about 40 related types i use for glorified field access ;)
21:31:20 <N1cXP8ChUBFe3> In the paste, I load the source file, check the function type, then try calling the function four times with 1..4 parameters.
21:31:31 <edwardk> dfeuer: usually we sit and chat =P
21:31:43 <shachaf> N1cXP8ChUBFe3: multiProduct's arguments are of type (Maybe a), but you're passing it numbers.
21:31:47 <dibblego> N1cXP8ChUBFe3: between line 2 and 3, do this:  multiProduct :: Int -> Maybe Int -> Maybe Int -> Maybe Int -> Int
21:32:03 <dfeuer> edwardk, I guess you probably have to be careful not to shake hands, lest the universe collapses in a puff of logic?
21:32:08 <dfeuer> *collapse
21:32:10 <shachaf> dibblego: That won't make a difference here...
21:32:23 <edwardk> bryanedds: you were asking for a practical example of a thing i can't say in f# earlier. lens is probably the thing i've written that has received widest adoption in the haskell community
21:32:25 <dibblego> shachaf: I think it will for his first error
21:32:28 <N1cXP8ChUBFe3> dibblego: let me make a new paste with Maybe Int instead
21:32:29 <edwardk> the whole thing doesn't make sense there
21:32:40 <dibblego> well, actually, kind of
21:32:54 <edwardk> you can make a data type for a lens, but you can't talk about how to compose them, how to deal with different types of them, etc.
21:33:03 <dibblego> N1cXP8ChUBFe3: next at the REPL, don't type (multiProduct 1), unstead type (:type multiProduct 1)
21:33:04 <Heffalump> you can get quite close to rank-2 types in F# with generic methods
21:33:15 <bryanedds> we can compose lenses in F#, I think
21:33:26 <bryanedds> (although maybe we're talking about different lenses)
21:33:39 <dibblego> and perhaps (multiProduct 1 (Just 2) (Just 3) (Just 4))
21:33:51 <edwardk> bryanedds: you can compose lenses, but not the kind i want, and not with the sort of automatic subtyping that makes the lens library go
21:33:52 <dibblego> you cannot have higher kinds in F#, you are completely boned when it comes to lenses in any practical sense
21:33:53 <merijn> edwardk: I'm sure trifecta adoption would go up if it had docs ;)
21:34:04 <edwardk> merijn: and if i finished rewriting it
21:34:19 <bryanedds> I did try to use our lens implementation
21:34:30 <dibblego> however, I have made a habit of returning Store values from get-accessors in .NET languages
21:34:33 <bryanedds> but then ripped it out due to it not being useful
21:34:39 <edwardk> bryanedds: simple first order lenses aren't useful
21:34:43 <merijn> edwardk: On a more serious note, would you recommend trifecta over parsec or is there anything better for parsing?
21:34:59 <dibblego> bryanedds: xsharpx implements not-very-useful lenses
21:35:01 <edwardk> merijn: i write to parsers, then use trifecta, parsec, attoparsec or whatever i want when i have to choose
21:35:26 <lpaste> N1cXP8ChUBFe3 pasted ‚ÄúOptional Args with Maybe Int Signature‚Äù at http://lpaste.net/111586
21:35:34 <dibblego> merijn: I implement in terms of parsers, write tests using parsec, then worry about trifecta or whatever later (doing that now)
21:35:59 <dibblego> N1cXP8ChUBFe3: you need to follow the instructions above carefully
21:36:04 <edwardk> > (1,[(2,3),(4,5)],"hello") & _2.traverse.both +~ 1
21:36:07 <lambdabot>  (1,[(3,4),(5,6)],"hello")
21:36:07 <dibblego> do not type (multiProduct 1)
21:36:17 <dibblego> N1cXP8ChUBFe3: instead type (:type multiProduct 1)
21:36:26 <dibblego> N1cXP8ChUBFe3: and perhaps (multiProduct 1 (Just 2) (Just 3) (Just 4))
21:36:31 <edwardk> those are lenses and traversals being used together with the same combinators to glue it all together
21:36:45 <edwardk> . in that is just function composition
21:37:10 <N1cXP8ChUBFe3> snap! multiProduct 1 (Just 2) (Just 3) (Just 4) works
21:37:37 <dfeuer> edwardk, what is the +~ in that?
21:37:45 <edwardk> Heffalump: yeah but when you go to use said rank-2 types for something like avoiding infintesimal confusion for something like AD for instance you go from foo = diff sin  -- to a line full of code =P
21:37:59 <edwardk> dfeuer: its a lens combinator for adding to the target of a lens
21:38:13 <dfeuer> Ah.
21:38:16 <dfeuer> Interesting.
21:38:20 <edwardk> > (_2 +~ 100) ("hi",2)
21:38:21 <lambdabot>  ("hi",102)
21:38:25 <dibblego> N1cXP8ChUBFe3: you can also replace the (Just x) with Nothing
21:38:32 <edwardk> > (_2 .~ "but you can change types") ("hi",2)
21:38:34 <lambdabot>  ("hi","but you can change types")
21:38:46 <edwardk> and now we go down the rabbit hole compared to the other lens libs ;)
21:38:56 <dfeuer> o.O
21:39:10 <Heffalump> edwardk: :-)
21:39:33 <dfeuer> .~ means "replace with"?
21:39:41 <edwardk> dfeuer: yeah its an infix version of 'set'
21:39:47 <AshyIsMe> i should take a month off work and read the lens source code until i vaguely understand it
21:39:57 <N1cXP8ChUBFe3> dibblego: That is very cool. Thank you so much!
21:39:59 <edwardk> > set both "dfeuer" (123,456)
21:40:01 <lambdabot>  ("dfeuer","dfeuer")
21:40:02 <shachaf> A large part of the lens source code is boilerplate.
21:40:04 <dibblego> N1cXP8ChUBFe3: no problem
21:40:19 <shachaf> More useful to understand the few important ideas than read the whole thing.
21:40:29 <edwardk> shachaf++
21:40:46 <edwardk> trick is we're remarkably bad at extracting the 'essence' of lens for public consumption
21:40:50 <benzrf> :t both
21:40:51 <lambdabot> (Data.Bitraversable.Bitraversable r, Applicative f) => (a -> f b) -> r a a -> f (r b b)
21:40:56 <dfeuer> lens appears to be one of those things that makes a lot of sense intuitively to use, but whose implementation is obscenely weird to mere mortals.
21:41:01 <benzrf> I;
21:41:05 <edwardk> @let both' f (a,b) = (,) <$> f a <*> f b
21:41:07 <lambdabot>  Defined.
21:41:17 <benzrf> :t both'
21:41:19 <lambdabot> Applicative f => (t -> f a) -> (t, t) -> f (a, a)
21:41:28 <edwardk> > set both' "dfeuer" (123,456)
21:41:29 <lambdabot>  ("dfeuer","dfeuer")
21:41:29 <benzrf> i like
21:41:30 <shachaf> I should finish writing my lenstroduction one of these days.
21:41:38 <shachaf> It'll make everything good and beautiful.
21:42:04 <benzrf> bye
21:42:05 <sagittarian> i have a directory of a bunch of cabal packages, one of the cabal packages depends on the others
21:42:12 <edwardk> dfeuer: i confess with lens my goal was to write a library for me at the time. the fact that other people found it useful was strange and baffling to me at first. ;)
21:42:35 <sagittarian> is there a way to tell cabal to look in those other directories for its dependencies, or am i going to have to just manually go into each directory and do cabal install?
21:42:40 <edwardk> dfeuer: and i was just trying to run to the logical extremes of the consequences of an idea
21:44:33 <bryanedds> edwardk, your discipline of writing code could use some expounding to the public
21:44:49 <edwardk> bryanedds: i blog about it a fair bit ;)
21:44:55 <bryanedds> really?
21:45:01 <bryanedds> I have actually never seen it
21:45:14 <bryanedds> to me this stuff is all new
21:45:18 <edwardk> bryanedds: http://comonad.com/reader/ http://fpcomplete.com/user/edwardk
21:45:25 <bryanedds> and I keep my ear relatively close to the ground
21:45:36 <tnks> edwardk: I'm really interested in your YOW keynote.
21:45:38 <edwardk> neither of this is pitched particularly newbie friendly, but i try to talk about interesting things
21:45:42 <tnks> not sure what you have in mind to say.
21:45:54 <edwardk> tnks: it should be fun. its a rather different kind of talk than i usually give
21:46:02 <tnks> yeah, but kind of important, I think.
21:46:09 <dibblego> tnks: come to AU
21:46:10 <tnks> FP-advocacy needs fresh ideas.
21:46:22 <joelteon> i wish there was a dialect of haskell where the mission statement is "there will be no effort to make things easier for new people."
21:46:32 <tnks> dibblego: funds :(
21:46:34 <joelteon> it always ends up being more complicated otherwise.
21:46:38 <joelteon> or not complicated enough.
21:46:46 <edwardk> tnks: it is basically 'how to optimize for the number of problems you solve' if not for solving any particular problem or applying any particular solution.
21:47:12 <tnks> I'm hoping they record it.
21:47:14 <joelteon> it could be called Austere Haskell or something
21:47:28 <edwardk> tnks: which given the rather eclectic nature of the problems i work on, i think is a talk I'm well positioned to give
21:47:49 <dfeuer> joelteon, what is your problem? Just write GHC Core.
21:48:09 <joelteon> Well, I guess I can't argue with that.
21:48:10 <dfeuer> Or, for that matter, switch to Agda or something.
21:48:29 <joelteon> Sorry, I hope my statements were taken as a joke.
21:48:37 <edwardk> and I have all sorts of fun appeals to authority from Feynman, Grothendieck, Serre, Hamming, Mac Lane, chess AI strategies, cognitive science, etc to try to spin things out of
21:48:39 <dfeuer> Couldn't tell.
21:48:52 <edwardk> and i think it holds together for about an hour talk
21:49:05 <dfeuer> edwardk, where/when/what is this YOW thing?
21:49:32 <edwardk> dfeuer: Melbourne, Sydney and Brisbane, in Australia in early December
21:49:44 <dfeuer> Oh. Those are very very far away.
21:49:49 <edwardk> dfeuer: i'll be giving the talk 3 times, so hopefully one of them will be good ;)
21:50:16 <dfeuer> I will not be attending any of the three, as they are all much too far to swim.
21:50:20 * monochrom predicts that the 2nd time is the best
21:50:28 <edwardk> monochrom: usually is
21:50:32 <dfeuer> Yup.
21:50:42 <edwardk> enough time to get comfortable, not enough time to lose track
21:50:49 <dfeuer> That seems to be true for many kinds of performances.
21:51:15 <dfeuer> Also not enough time to fall into a routine/get bored with it.
21:51:21 <monochrom> . o O ( optimizing for the number of times of giving the same talk )
21:51:45 <edwardk> tnks: basically i wanted to try to see if i could use reverse analogies. =) take a bunch of complicated ideas from math, c.s. etc. and use them to motivate how to approach problems rather than anthropomorphize techniques
21:52:17 <tnks> edwardk: yeah, it sounds like a good idea.
21:52:36 <edwardk> what does iterative deepening depth first search mean to you as a human being
21:52:41 <edwardk> etc
21:54:23 <tnks> yeah, I'm interested in whether it helps people reevaluate their interpretations of resource constraints.
21:54:32 <tnks> time/money/etc.
21:54:38 <AshyIsMe> ah that looks sweet, the yow tickets are quite pricey though
21:56:25 <edwardk> tnks: we'll see how it goes
21:56:51 <edwardk> tnks: i figure if it gets a dozen people to change their mind then its done its job
21:57:46 <bryanedds> so edwardk, can I train under you like a shaolin monk?
21:58:23 <edwardk> bryanedds: your first task is to stand in the stream of package updates on #haskell-lens and try to find your center ;)
21:58:40 <bryanedds> hehe
21:59:19 <bryanedds> but seriously, do you run a business or hire people or anything?
21:59:40 <edwardk> light data structure reading: https://github.com/analytics/analytics/blob/master/notes/papers.md
22:00:40 <bryanedds> if I could find a way to simultaneouly hack haskell and not starve, I would like to investigate it
22:00:47 <edwardk> bryanedds: I work for McGraw Hill Financial. The team here mostly works on https://www.youtube.com/watch?v=o3m2NkusI9k
22:00:58 <bryanedds> (currently I hack F# and starve)
22:01:14 <edwardk> we're not actively hiring at the moment, but we do keep an eye out
22:02:16 <bryanedds> i wanna be haskell monk
22:02:43 <bryanedds> I don't know if I'll end up liking haskell, but I would like the experience of it
22:03:30 <edwardk> bryanedds: where are you geographically, the midwest?
22:03:45 <bryanedds> ohio currently
22:04:05 <bryanedds> but I'm never coupled to any location really
22:04:36 <bryanedds> wandering hacker, so far
22:05:38 <Sonarpulse> ok I've tracked down the problem to needing to call update-directory-autoloads
22:06:08 <Sonarpulse> but seems to need to done from the proper directory, and with the proper ouput file
22:06:19 <Sonarpulse> in other words, it seems to be a delicate process
22:06:23 <Sonarpulse> can anybody help?
22:07:18 <bryanedds> I know F# is looked down upon by some, but it has got me to a level where I'm pretty well ready to step up to haskell
22:07:34 <merijn> bryanedds: I think Standard Chartered is permanently hiring haskellers in Singapore
22:08:05 <edwardk> bryanedds: f# is a viable stepping stone. my main problems with f# center around thoughts i want to think that i can't think in it
22:08:35 <merijn> ooh
22:08:40 <merijn> Now that things here are active...
22:08:48 <merijn> Is anyone aware of CMake hooks for cabal?
22:08:55 <edwardk> and the effects it then has on users through the Sapir-Whorf hypothesis http://www.princeton.edu/~achaney/tmve/wiki100k/docs/Sapir%E2%80%93Whorf_hypothesis.html
22:10:35 <bryanedds> right
22:11:09 <bryanedds> but some programmers, maybe only the special ones, always keep mindful that they;re always living in a blub
22:11:43 <bryanedds> those are the ones that have more immunity to this problem
22:12:29 <bryanedds> anyone can be comfortable with haskell if its their first language
22:13:08 <bryanedds> it takes a very special type of C programmers to make his way from C++ to Java to C# to F# to Haskell :)
22:13:11 <edwardk> bryanedds: i think its useful to learn how to think in 'higher' languages than you want to work in just so when you get stuck in the language you care about you have a name for the thought you are trying to think
22:13:12 <merijn> I don't think many people learn haskell as a first language
22:13:23 <merijn> bryanedds: I don't believe the whole "blub" argument anyway
22:13:42 <edwardk> i learned agda/coq/pure type systems in the process of learning haskell then settled back down into haskell
22:13:46 <merijn> Ever since I was programming I was wishing for better ways to do things and noticed the language just wouldn't let me
22:14:22 <bryanedds> I think blub applies to everyone
22:14:30 <bryanedds> you can never think about the thoughts you can't think
22:14:40 <edwardk> that isn't to say i think those languages are perfect, but i do think they can say some things we can't and it behooves us to understand the limitations of our current vocabularies
22:14:42 <merijn> Perhaps, but I run into language limitations all the time
22:14:52 <merijn> And I still manage to conceptualise what I want...
22:15:45 <edwardk> merijn: i think the blub paradox as stated in the original article is a bit stronger than needed. you could instead view it as stating a strong form of the sapir-whorf hypothesis for programming languages where perhaps only the weak one holds for some users
22:15:49 <merijn> bryanedds: I think it's just a matter of always triving for better
22:16:11 <edwardk> merijn: while it doesn't remove your ability to think those thoughts, it makes it much harder to formulate them
22:16:11 <merijn> The Sapir-Whorf hypothesis has also been pretty solidly rejected by linguists and psychologists alike
22:16:38 <edwardk> merijn: and yet i find it culturally explains things very effectively in a PL context =P
22:16:40 <shachaf> I thought the idea of that article was "everyone thinks their favorite language is the best and at the top of the abstraction ladder, but they're all wrong, MY favorite language is the best and at the top of the abstraction ladder"
22:17:07 <bryanedds> well, you can pull more general things out of the article
22:17:15 <merijn> My favourite language is not the best and not at the top of the abstraction ladder, where am I now? :(
22:17:16 <bryanedds> but maybe that's just my interpretation
22:17:31 <bryanedds> merijn, on your way up
22:17:32 <merijn> I mean, haskell is pretty sucky. It's just considerably less sucky than most other things :)
22:17:44 <edwardk> shachaf: hahaha
22:17:51 <bryanedds> the point is not to be at the top, the point is to alway be moving up
22:17:54 <merijn> I should install Idris...
22:18:20 <edwardk> i do agree that there there are definitely different fitness functions and nothing dominates under all of them =P
22:18:23 <merijn> Actually, I shouldn't I should finish this library...
22:18:39 <bryanedds> ya, don't we all have some programming to do? ;)
22:18:54 <bryanedds> though I must say one last thing -
22:19:04 <edwardk> bryanedds: i've been programming this whole time. haven't you? ;)
22:19:22 <bryanedds> talking about and studying haskell code for the last couple days does make my F# code start to look like java :/
22:19:37 <bryanedds> heh, a line here and there :)
22:20:04 <bryanedds> mostly I think I'm just background-digesting the design I've ended up with for my purely functional event system
22:20:20 <bryanedds> it's not perfect, but I think I can get away with it :)
22:28:54 <devboard> where meeting from scratch
22:28:55 <devboard> ?
22:29:06 <devboard> where meeting haskell from scratch
22:29:23 <Axman6> pardon?
22:29:24 <blaenk> ¬ø
22:29:34 <sgronblo> how did you check the versions of packages in the current sandbox?
22:29:40 <sgronblo> ghc-pkg something something
22:29:55 <devboard> tutorial haskell for newbies
22:29:57 <devboard> :D
22:30:16 <Axman6> @where lyah
22:30:17 <lambdabot> http://www.learnyouahaskell.com/
22:35:09 <merijn> Is there a sane way to encode C dependencies in cabal (for my tests) or should I just say "screw it" and hardcode the paths and tough luck for anyone else that wants to test...
22:36:00 <zwer> is there a syntactic sugar that will automatically set all the not-initialized Maybe fields to Nothing?
22:36:23 <merijn> zwer: no
22:36:43 <merijn> zwer: Normally you'd define a default value for your record and selectively overwrite fields
22:39:24 <x_> :t (+) <$> lookup "x" <*> lookup "y"
22:39:25 <lambdabot> Num (Maybe b) => [([Char], b)] -> Maybe b
22:41:28 <x_> :t (+) <$> Just 5 <*> Just 7
22:41:29 <lambdabot> Num b => Maybe b
22:41:48 <Axman6> that's probably not the lookup you're after
22:42:41 <x_> I can't figure out the Num(Maybe a) constraint? And which lookup do you suggest?
22:42:51 <merijn> x_: You're partialling applying lookup
22:43:03 <merijn> x_: It's using the Reader applicative, not Maybe
22:43:26 <merijn> :t \l -> (+) <$> lookup "x" l <*> lookup "y" l
22:43:27 <lambdabot> Num b => [([Char], b)] -> Maybe b
22:43:30 <x_> I wanted Reader to feed in a list as context
22:43:53 <merijn> x_: The result of lookup is maybe, so your usage of (+) is trying to add two maybes
22:44:05 <merijn> x_: Hence why it infers "Num (Maybe b)"
22:44:15 <Total_1mmersion> Can cabal automatically add new dependencies to the .cabal file?
22:44:47 <x_> But what about (+) <$> Just 5 <*> Just 7?
22:45:43 <Axman6> :t liftA2 (+) <$> lookup "x" <*> lookup "y"
22:45:44 <lambdabot> Num c => [([Char], c)] -> Maybe c
22:46:19 <x_> aarggh! thx Axman6.
22:46:59 <Axman6> you're lifting (+) through two layers of applicatives
23:08:01 <sagittarian> how do declare a function's type in ghci?
23:08:53 <shachaf> let f :: A -> B; f = ...
23:10:17 <sagittarian> ah one line, thanks
23:10:55 <shachaf> @google how do declare a function's type in ghci?
23:10:56 <lambdabot> http://stackoverflow.com/questions/3093133/how-to-provide-explicit-type-declarations-for-functions-when-using-ghci
23:10:56 <lambdabot> Title: haskell - How to provide explicit type declarations for functions when using ...
23:14:36 <sagittarian> if i want if i want to have a function with multple definitions based on the type of its arguments, the way to do that is via a type class, right?
23:14:51 <sagittarian> there's no way outside of a typeclass to do that, is there?
23:25:57 <bryanedds> goodnight #haskell, and thanks for all the types!
23:31:40 * hackagebot hsdev 0.1.2.3 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  http://hackage.haskell.org/package/hsdev-0.1.2.3 (AlexandrRuchkin)
23:31:42 * hackagebot vty 5.2.3 - A simple terminal UI library  http://hackage.haskell.org/package/vty-5.2.3 (CoreyOConnor)
23:32:36 <joeyh> http://stackoverflow.com/questions/26027765/using-types-to-prevent-conflicting-port-numbers-in-a-list wow. I gotta give the haskell community a big hug for this one :)
23:35:44 <merijn> joeyh: Actually, that can be done even cleaner in 7.8 since we now have closed type families
23:37:57 <joeyh> I think it'll work with 7.6.3 as given
23:41:18 <zereraz> hello can some one explain what I am doing wrong here http://lpaste.net/111590
23:48:34 <sgronblo> i am trying to instantiate a value of a data type generated by persist in a handler and am getting "not a visible field of constructor"
23:49:11 <sgronblo> looking here http://www.yesodweb.com/book/persistent at the section "generates code that looks like the following" i dont see anything hidden about the fields
23:49:28 <sgronblo> oh... im stupid
23:49:33 <sgronblo> the field names are prefixed...
