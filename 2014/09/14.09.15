00:02:09 <nshepperd> yes
00:03:32 <nshepperd> well, f :: A -> Void is just a way of telling some other code that A is unoccupied
00:05:07 <simpson> Huh. I am mildly disappointed that nothing exploded when I tried `let f = unsafeCoerce :: a -> Void`
00:06:14 <shachaf> What sort of explosion are you expecting?
00:06:35 <mauke_> :t let f = f . f in f
00:06:36 <lambdabot> b -> b
00:06:40 <mauke_> :t let f :: a -> b; f = f . f in f
00:06:41 <lambdabot> a -> b
00:06:44 <jle`> some sort of kinetic explosion coming from his physical machine, i'm presuming
00:07:45 * dfeuer looks up and wonders what ski meant. Is the inconsistent Boolean lattice one where True=False or something?
00:09:09 * hackagebot language-c-inline 0.7.6.1 - Inline C & Objective-C code in Haskell for language interoperability  http://hackage.haskell.org/package/language-c-inline-0.7.6.1 (ManuelChakravarty)
00:09:09 * hackagebot markdown 0.1.11 - Convert Markdown to HTML, with XSS protection  http://hackage.haskell.org/package/markdown-0.1.11 (MichaelSnoyman)
00:09:11 <ski> dfeuer : yep
00:11:39 <dfeuer> ski, well, no, that is not interesting. I know a few people have worked on inconsistent logics, but my understanding is that it's a weird world that's not been very thoroughly explored.
00:12:37 <ski> dfeuer : well, afaik, it's not that related to inconsistent logics
00:14:10 <nshepperd> mauke_: o_O how does that work
00:14:14 <dfeuer> ski, in the Boolean case, everything just collapses. The more interesting ones reject ex falso. I think that's the deal, anyway.
00:15:26 <ski> dfeuer : perhaps you're thinking about "paraconsistent" ?
00:15:37 <dfeuer> ski, I think I am.
00:15:49 <dfeuer> What are "inconsistent" ones?
00:16:11 <ski> dfeuer : e.g. vector spaces with linear transformations, considered as a "logic"
00:16:20 <dfeuer> Yeah, no idea.
00:16:38 <ski> every "formula" entails every other one, via the constantly zero linear transformation
00:16:50 <ski> @let data Void
00:16:51 <lambdabot>  Defined.
00:16:54 <ski> @let type Not a = a -> Void
00:16:55 <lambdabot>  Defined.
00:17:07 <ski> @let data So :: Bool -> * where Oh :: So True
00:17:08 <lambdabot>  Defined.
00:17:15 <ski> @type let notSoFalse :: Not (So False); notSoFalse x = case x of {} in notSoFalse
00:17:16 <lambdabot>     Empty list of alternatives in case expression
00:17:16 <lambdabot>       Use EmptyCase to allow this
00:17:19 <ski> bah!
00:17:53 <ski> anyway, that's supposed to show how `EmptyCase' could be useful on a type not isomorphic to `Void'
00:18:20 <ski> (also, why is `data Void where {}' not allowed ?)
00:18:59 <mroman_> http://codepad.org/K2azwD5O <- what's Codepad's problem here?
00:19:02 <mroman_> It works fine in GHC.
00:19:28 <ski> dfeuer : btw, minimal logic also rejects ex falso quodlibet, but is not considered paraconsistent
00:19:53 <dfeuer> mroman_, codepad is using an ancient version of the obsolete Hugs interpreter.
00:19:56 <dolio> ski: It is allowed.
00:20:30 <dfeuer> ski, you left me in the dust. I'll go read about something else.
00:20:51 <ski> dolio : i thought it was, but lambdabot didn't seem to like it
00:20:57 <mroman_> So this is a Bug in Hugs?
00:21:01 <ski> @let data Blah where {}
00:21:01 <lambdabot>  Parse failed: Parse error: }
00:21:19 <ski> dfeuer : sorry
00:21:27 <dolio> ski: I think lambdabot uses an extra parser before sending it to GHC.
00:21:36 * ski looks up the meaning of "leaving someone in the dust"
00:21:36 <dolio> For some things at least.
00:21:55 <dolio> Maybe haskell-src-exts doesn't like it or something.
00:22:03 <jle`> Bugs in Hugs?
00:22:05 * jle` Shrugs
00:22:08 <dfeuer> mroman_, I'm still trying to figure that out.
00:23:24 <mroman_> I just tried -XHaskell98 with GHC and it still works.
00:23:51 <dfeuer> You can't trust -XHaskell98, I don't think.
00:28:44 <merijn> eh, why not?
00:28:50 <dfeuer> mroman_, I don't see a problem with your code. But it looks too simple to trip up the Hugs type checker, so I could be missing something. Maybe someone more experienced can find a deviation.
00:29:13 <merijn> Haskell98 should work just fine in GHC
00:29:35 <dfeuer> merijn, isn't GHC a little more liberal than the standard even with that? Or is it super-super strict?
00:30:08 <merijn> dfeuer: GHC is a little more liberal, but a little means there's 3 things I know of that GHC doesn't follow
00:30:15 <dfeuer> merijn, also, I don't trust code that doesn't get exercised that much.
00:30:34 <merijn> 1) Eq is not a superclass of Num 2) Show is not a superclass of Num 3) GHC doesn't support recursive imports
00:31:50 <dfeuer> merijn, so you think mroman_ found a bug in the Hugs type checker? I *especially* don't trust rarely exercised code that's supposed to *fail* in certain cases.
00:32:09 <merijn> I don't trust Hugs
00:32:15 <merijn> It's bitrotted beyond belief
00:32:41 <mroman_> "I *especially* don't trust rarely exercised code  that's supposed to *fail* in certain cases.
00:32:44 <mroman_> " <- ???
00:33:03 <mroman_> My english has troubles understanding that
00:35:37 <mroman_> Is Hugs even still maintained?
00:35:55 <dfeuer> mroman_, what I mean is that GHC's -XHaskell98 option is supposed to reject certain programs that GHC normally accepts (I believe). Most people don't tend to spend their time testing whether it really rejects all code violating the standard because most people are just using GHC to compile code that they want to work with GHC, and they don't care if it complies absolutely rigidly to the standard. merijn could be right, though,
00:35:55 <dfeuer>  since Hugs is *not* maintained, and hasn't been for years.
00:35:58 <mroman_> http://www.haskell.org/hugs/ looks rather unmaintained
00:38:21 <dfeuer> I didn't realize the Hugs website was down. Is it available somewhere for historical purposes?
00:39:44 <mroman_> I see there's a 2010 Report
00:45:14 <merijn> mroman_: No, hugs is no longer maintained
00:45:19 <merijn> mroman_: Hasn't been for a few years
00:46:56 <ski> dfeuer : <https://web.archive.org/web/20140828005338/http://www.haskell.org/hugs/> ?
00:47:21 <dfeuer> ski, I should have thought of that.
00:49:44 * dfeuer just updated the Hugs page on the Haskell wiki to reflect its current status.
00:54:01 <mroman_> dfeuer: btw is it possible to make Result a b = Ok a | Error b?
00:54:10 <mroman_> while still providing a Monad-Instance
00:54:34 <mroman_> (Result a b isn't m a anymore but m a b)
00:54:37 <dfeuer> mroman_, you probably need to do it the other way around:  Result b a = Ok a | Error b
00:54:45 <shachaf> Yes, but the Monad instance will be the same as Either's. return :: b -> Result a b
00:54:48 <athan> does anyone know of any good html tools out there?
00:55:14 <athan> blaze-html seems to be more oriented around flat templating and fast rendering, not for building up ideas
00:55:53 <aleator> Is it possible to have a monad comprehension 'ignore' pattern match failures like the list comprehension? (ie. [y | Just y <- [Nothing,Nothing]] == [])
00:56:17 <dfeuer> Wow. Fedora 20 still offers Hugs!
00:56:40 <dfeuer> aleator, it all depends on the monad in question.
00:56:45 <shachaf> aleator: Yes. It works the same way as do { Just y <- [Nothing,Nothing]; return y }
00:56:50 <shachaf> I.e. with fail.
00:57:05 <dfeuer> Which by default produces errors.
00:57:23 <aleator> Ah.. I was silly. I confused mzero with fail
00:57:25 <shachaf> By default return and (>>=) produce errors too.
00:58:07 <aleator> Thanks!
00:59:19 <nyuszika7h> 09:28:41 <merijn> 1) Eq is not a superclass of Num 2) Show is not a superclass of Num 3) GHC doesn't support recursive imports
00:59:31 <nyuszika7h> why would Eq and Show be a superclass of Num? o_O doesn't make sense
00:59:41 <nyuszika7h> at least to me
01:00:15 <jle`> well.  presumably.  all Num instances get a free Read instance
01:00:35 <jle`> (hm. i guess not really)
01:00:44 <mroman_> Show gets you a free Read?
01:00:46 <jle`> read = fromInteger . read
01:03:02 <nyuszika7h> oh wait, I think I confused superclass with subclass
01:48:22 <spacekitteh> hey everyone, i'm working on a proposal for ghc+the base libraries and i was wondering if someone could look it over and give me any tips etc? http://blog.spacekitteh.moe/posts/new-monoidal-cats.html it is still very much a work in progress, however
01:49:24 <shachaf> I don't think it belongs in base at all.
01:49:35 <shachaf> Nothing wrong with a class existing outside of base.
01:50:40 <Cale> At some point Arrow ought to get adjusted a bit so that the stuff in it reflects the operations of a symmetric monoidal category (and proc/do notation changed to support that)
01:51:35 <Cale> But putting such a fine-grained class hierarchy into base seems like pre-emptively overdoing it :)
01:51:55 <Iceland_jack> and hey spacekitteh
01:51:58 <spacekitteh> yeah, i'm rethinking having binoidal
01:52:00 <spacekitteh> hey Iceland_jack
01:52:15 <spacekitteh> Iceland_jack: i rewrote about half of the page btw
01:53:17 <spacekitteh> Cale: the problem with arrow being an SMC is that that means you can't lift non-pure functions via arr anymore
01:53:21 <Iceland_jack> I'll take a look at it soon
01:55:47 <Cale> spacekitteh: That is not a problem. arr needs to be in its own class too
01:56:07 <spacekitteh> indeed
01:57:38 <Cale> Also, we really kind of need the naturality law that (a >>> b) *** (c >>> d) = (a *** c) >>> (b *** d)
01:58:54 <spacekitteh> that's why i have premonoidal and monoidal as seperate, for when that doesn't hold
01:59:17 <Cale> I'm not convinced that there are really important Arrow instances where it fails.
01:59:31 * mjrosenb kind of feels like there are too many categories to bother giving them all names.
01:59:44 <spacekitteh> when an arrow does IO then it'd fail
01:59:55 <mjrosenb> like, any given subset of properties seems to have its own name.
01:59:59 <Cale> spacekitteh: Yes.
02:00:16 <Cale> spacekitteh: But there are no important Arrow instances which do IO :P
02:00:25 <spacekitteh> true :P
02:00:30 <spacekitteh> anyway GA's > arrows
02:00:32 <nshepperd> Kliesli IO
02:00:34 <nshepperd> :p
02:00:39 <Cale> nshepperd: Right, nobody uses that
02:00:56 <Cale> (as an Arrow, at least)
02:01:37 <Cale> Similarly, you lose out on any Arrow instance with non-local state
02:02:02 <Cale> but those all break the reasoning-via-wiring-diagrams that we usually want to do
02:02:05 <ski> you could take any non-commutative effect, no ?
02:02:36 <Cale> Right, Kleisli m fails this whenever m isn't a commutative monad
02:02:55 <Cale> Because the order of effects in b and c gets swapped
02:03:08 <spacekitteh> but do you think i'm on the right track, maybe just don't make it so finegrained?
02:03:25 <Cale> Yeah
02:04:04 <spacekitteh> c: ok
02:04:19 <Cale> Note that it's *very* important that the isomorphisms which are part of the definition of a symmetric monoidal category get names
02:04:56 <spacekitteh> which ones? (i'm playing bf4 right now and can't really think)
02:05:13 <Cale> The associator and the left and right unit isomorphisms
02:05:17 <spacekitteh> ah right, yeah
02:05:22 <Cale> (in both directions0
02:05:33 <Cale> The current thing which makes Arrow suck as an abstraction, or at least, which prevents it from being used for most of the things where it otherwise would
02:05:56 <Cale> is that when desugaring the proc/do notation (or even when not), you end up needing lots of arr everywhere
02:06:16 <Cale> You end up with an arr between every pair of lines in a proc/do block
02:06:33 <ski> yeah, `arr' is the devil
02:06:37 * spacekitteh nodnods
02:06:38 <Cale> It's okay to have a few occurrences of arr typically, but it *really* harms your ability to optimise
02:07:39 <spacekitteh> yeah. >:(
02:07:50 <Cale> If you throw in those isomorphisms, you can translate the proc/do syntax in such a way that arr is only required when there's a complex expression (something which isn't nested pairs of variables) to the left of -< or a complex pattern (again, something which isn't nested pairs of variables) to the right of <-
02:09:09 <Cale> and then the function which runs the arrow computation has the opportunity to do lots of graph optimisation
02:09:39 <Cale> (though this is a bit of a nightmare to write and typically requires an unsafeCoerce somewhere)
02:10:15 <spacekitteh> noted! :D
02:19:20 <jle`> i was really surprised when i first noticed all of the arrs in the desugared proc code
02:22:28 <jle`> i've had a fair share of graph reduction nightmares trying to take arrow abstractions
02:23:03 <jle`> it's a bit sad that one of the motivating aspects of Arrow in the first place produces desugarings that are borderline unusable for many situations :/
02:28:43 <awestroke> is anyone here familiar with rust?
02:29:02 <awestroke> I am looking to discuss rust from a haskellers perspective
02:30:18 <MP2E> I check on the project from time to time, quite apt to learn when it hits 1.0. I'm a little hesitant to learn before then because the language is evolving quite rapidly. Overall, I like it, and I plan on using it for low level tasks that I can't use Haskell for
02:30:55 <MP2E> syntax is a tad crufty but I feel it is effective for delivering functional programming in a syntax that imperative programmers will find a bit more comfortable
02:31:19 <MP2E> anyhow this is probably a topic for #haskell-blah
02:32:31 <awestroke> The pattern matching and Optionals in the std lib makes me try to write haskell-like code, but then I miss having monadic composition
02:33:05 <awestroke> and monad transformers with lifting
02:33:14 <MP2E> ouch, I think I'm going to miss those too :V
02:36:22 <hexagoxel> what are differences between EitherT and ExceptT (apart from slightly different sets of utility functions around them) ?
02:37:46 <zenguine> I'm not 100% on this, but I believe the difference is that "ExceptT e" forces e to be a SomeException
02:37:55 <zenguine> whereas EitherT does not have this restriction
02:38:31 <dibblego> there is also ValidationT
02:38:34 <zenguine> hexagoxel: I think, anyways.  dont quote me :)
02:38:38 <spaceloop> No, ExceptT does not enforce that
02:39:21 <spaceloop> I think that the mtl package only uses ExceptT, and has no EitherT
02:39:24 <hexagoxel> zenguine: ErrorT did (something like) that
02:39:49 <zenguine> good thing I'm not being quoted
02:39:50 <zenguine> haha
02:39:51 <zenguine> oops
02:39:57 <spaceloop> ErrorT is deprecated now
02:40:30 <spaceloop> ExceptT is just like EitherT but its name indicates the use case I guess
02:42:57 <hexagoxel> EitherT has hoistEither; ExceptT has withExceptT. i'd like to have both :D
02:43:23 <hexagoxel> the distinction of use cases seems pretty vague :/
02:54:46 <lpaste_> nyuszika7h pasted “No title” at http://lpaste.net/2801451603465338880
02:54:52 <nyuszika7h> what's wrong with this? ^
02:55:16 <supki> hexagoxel: withExceptT looks like a weaker version of bimapEitherT
02:55:38 <jle`> :t toTitle
02:55:39 <lambdabot> Char -> Char
02:55:55 <jle`> nyuszika7h: it looks like `C.toTitle x` is a Char
02:55:57 <jle`> do you see why?
02:56:06 <nyuszika7h> oh, yes
02:56:10 <yeboot> :t putStrLn
02:56:11 <lambdabot> String -> IO ()
02:56:11 <nyuszika7h> I thought C.toTitle is expecting a String
02:56:15 <nyuszika7h> >_>
02:56:23 <nyuszika7h> and was confused as I checked the type
02:56:30 <jle`> np :)
02:56:59 <jle`> well
02:57:03 <jle`> if you thought it expected a string
02:57:07 <jle`> why are you passing in x, a Char?
02:57:10 <hexagoxel> supki: yeah, and hoistEither is just "EitherT . return"..
02:57:24 <nyuszika7h> jle`: I thought that because of the error
02:57:30 <nyuszika7h> >_>
02:57:36 <jle`> ah, i see
02:59:23 * hackagebot uuagc-cabal 1.0.6.0 - Cabal plugin for the Universiteit Utrecht Attribute Grammar System  http://hackage.haskell.org/package/uuagc-cabal-1.0.6.0 (JeroenBransen)
03:03:20 <nyuszika7h> @hoogle hFlush
03:03:22 <lambdabot> System.IO hFlush :: Handle -> IO ()
03:03:22 <lambdabot> GHC.IO.Handle hFlush :: Handle -> IO ()
03:03:22 <lambdabot> GHC.IO.Handle hFlushAll :: Handle -> IO ()
03:06:29 <BubbleGum> Hello, can anybody explain how to build and install package SDL-mixer under Windows correctly? My problem is: when I try to build package, I get an error message like this: "Filename of build/Graphics/UI/SDL/Mixer/General.hs doesn't match Module name. Expected Graphics.UI.SDL.Mixer.General for name of module".
03:09:51 <XniX23> how do i check if Sum is a monoid?
03:10:39 <MP2E> > foldr (<>) [Sum 5, Sum 10, Sum 2]
03:10:41 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable Data.Monoid.Sum)
03:10:41 <lambdabot>    arising from a use of ‘M46467566862323155331094.show_M46467566862323155331...
03:10:53 <MP2E> hmm oh whoops
03:10:58 <MP2E> > foldr1 (<>) [Sum 5, Sum 10, Sum 2]
03:11:01 <lambdabot>  Sum {getSum = 17}
03:11:05 <MP2E> looks like it is!
03:11:34 <ski> that's the main point of even defining `Sum'
03:11:35 <mr-> XniX23: :i Sum in ghci will tell you
03:11:58 <mr-> XniX23: It will show (among others) the following line: instance Num a => Monoid (Sum a) -- Defined in ‘Data.Monoid’
03:12:55 <yeboot> :t foldl
03:12:56 <lambdabot> (b -> a -> b) -> b -> [a] -> b
03:13:15 <ski> i think it would be nice if it told you through which module(s) in scope the identifier was imported
03:14:36 <XniX23> mr-, so basically each line tells me where it is defined and the right sides show me what it can act like
03:17:55 <Hafydd> Commutative diagrams are the kind of diagrams you draw in your head while commuting.
03:18:20 <spacekitteh> : D
03:18:35 <Hafydd> Er... wrong channel, but still somewhat on topic/
03:19:32 <pjdelport> "Draw [diagram] such that the author commutes."
03:21:05 <kjgorman> :t foldr1
03:21:06 <lambdabot> (a -> a -> a) -> [a] -> a
03:31:37 <MichaelBurge_> Is it possible to share build-depends among multiple sections in a Cabal file?
03:33:08 <nyuszika7h> LYAH is making me laugh so much
03:33:17 <nyuszika7h> "Take a look at this piece of code. Is it valid? If you said no, go eat a cookie. If you said yes, drink a bowl of molten lava. Just kidding, don't!"
03:34:04 <zenguine> yeah its pretty funny at times
03:34:24 <zenguine> I recall the goofy humor being a nice distraction from my substantial confusion at times when I was first going through it
03:35:01 <yitz> zenguine: yes, i think that was explicitly the intention. it was a great idea.
03:35:48 <zenguine> yeah I'm sure.  agreed.
03:36:40 <yitz> MichaelBurge_: the sections can depend on each other. e.g., a common idiom is to have a library, and then a program that depends on that library.
03:40:29 <MichaelBurge_> yitz: You still need to list the packages if you use them, even if they're implied by a dependency. For example, I would need the 'time' library listed in my executable that deals with times even if my library is a dependency and depends on 'time'
03:40:42 <XniX23> could anyone tell me if Functor ((->) r) works like this... function can be a functor but if you want to fmap it with another function, then it just wraps it in a function that takes the missing parameters, first applies the inner functor function and only then fmaps?
03:41:38 <Twey> @src (->) fmap
03:41:38 <lambdabot> fmap = (.)
03:42:04 <yitz> MichaelBurge_: true. in that case, the answer is no.
03:42:21 <ski>   fmap :: Functor f => (a -> b) -> (f a -> f b)
03:42:34 <ski> in the case `f' is `(rho ->)', we get
03:42:54 <ski>   fmap :: (a -> b) -> ((rho -> a) -> (rho -> b))
03:43:03 <ski> which happens to be the type of `(.)'
03:43:32 <yitz> MichaelBurge_: i guess to support that, you would need something like "named dependency sets". it would be cool feature.
03:44:15 <gfixler> Twey: is (->) fmap using (->) as a record and fmap as the thing to look up in it?
03:44:27 <gfixler> or maybe vice versa
03:45:00 <elspru> what does the => mean?
03:45:27 <ski> gfixler : i suppose if you wanted to, you could think of a value of type `rho -> a' as a "record" with one field of type `a' for every possible value of type `rho'
03:45:46 <gfixler> ski: I'm asking, as I made it through about 40 minutes of SPJ's talk on types
03:45:51 <ski> gfixler : and then `fmap'/`(.)' maps the given function over this, calling it on every field
03:45:58 <ski> @type sum
03:45:59 <lambdabot> Num a => [a] -> a
03:45:59 <yitz> elspru: it is a constraint. the lhs of => is shorthand for forall f. Functor f
03:46:03 <gfixler> and he showed how under the hood, functions took an extra value - a record
03:46:20 <gfixler> and looked up their appropriate function, so things like (+) were actually lookup functions, iirc
03:46:58 <ski> elspru : for `sum', it means that it can accept a list of values of type `a', and will return a value of type `a', *provided* `a' is in the `Num' type class (iow provided that the type `a' support the basic numeric/arithmetic operations)
03:47:10 <elspru> hmmm okay, thanks
03:47:14 <elspru> :-)
03:47:33 <gfixler> elspru: the stuff between :: and => are type constraints
03:47:47 <ski> elspru : if we had said `sum :: [a] -> a', we'd be claiming that it worked for *any* type `a', but it doesn't so we can't do that. we add the `Num a =>' to only claim that it will work for numeric types
03:47:50 <yitz> elspru: it means that the rhs a type signature that includes any type you can get by filling in the type variables with any types, provided that they satisfy the constraints.
03:48:33 <ski> gfixler : "functions took an extra value - a record" -- that's one possible implementation of type class constraints, yes
03:48:48 <gfixler> ski: this was compiler magic he was referring to
03:48:50 <ski> so, consider
03:48:54 <ski> @type lookup
03:48:55 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
03:48:56 <XniX23> oh i see now thanks
03:49:00 <ski> @src Eq
03:49:00 <lambdabot> class Eq a where
03:49:00 <lambdabot>     (==), (/=) :: a -> a -> Bool
03:49:21 <ski> so, this transformation would introduce a new data type
03:49:32 <Twey> gfixler: It's λb syntax for ‘the source of fmap in the (->) instance’, which is kind of a misnomer since the instance is actually for (r ->).
03:49:50 <ski>   data EqDict a = MkEqDict {(==),(/=) :: a -> a -> Bool}
03:49:56 <SwashBuckla> I have finished reading LYAH!
03:49:58 <SwashBuckla> woo
03:50:04 <ski> so that
03:50:12 <ski>   (==) :: EqDict a -> a -> a -> Bool
03:50:16 * gfixler congratulates SwashBuckla 
03:50:23 <ski> and then the new type signature for `lookup' would be
03:50:24 <kjgorman> :t ((<$>) . (<$>))
03:50:25 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
03:50:29 * gfixler is still around chapter 10 in LYAH
03:50:40 <ski>   lookup :: EqDict a -> a -> [(a,b)] -> Maybe b
03:50:51 <ski> and, looking at
03:50:56 <ski> @src lookup
03:50:57 <lambdabot> lookup _key []                      = Nothing
03:50:57 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
03:50:57 <lambdabot>                         | otherwise = lookup key xys
03:51:05 <ski> the new definition of `lookup' would be
03:51:17 <ski>   lookup _eqdict _key []                      = Nothing
03:51:30 <gfixler> ski, this looks like what SPJ was going over
03:51:45 <gfixler> I've not grokked it fully, nor internalized it, so I'm just recognizing it at the syntax/symbols level currently
03:51:49 <ski>   lookup  eqdict  key ((x,y):xys) | (==) eqdict key x  = Just y
03:52:08 <kjgorman> :t ((<*>) . (<*>))
03:52:09 <lambdabot> (a -> a1 -> b) -> ((a -> a1) -> a) -> (a -> a1) -> b
03:52:15 <ski>                                   | otherwise          = lookup eqdict key xys
03:52:23 <ski> gfixler : ok
03:52:51 <ski> @type ((<*>) .) . (<*>)  -- kjgorman ?
03:52:51 <lambdabot> Applicative f => f (a1 -> a -> b) -> f a1 -> f a -> f b
03:53:07 <gfixler> ski: I save these instructive convos and go over them later, until I get them
03:53:11 <shachaf> Of course, it's trickier when you have methods that are polymorphic in some other types.
03:53:13 <zenguine> what are you guys talking about?
03:53:18 <gfixler> or I build up questions and come back and ask more
03:53:45 <ski> that's what `PolymorphicComponents' is for
03:53:57 <shachaf> Then you need Rank2Types or something to encode it.
03:53:59 <ski> zenguine : implementation of type class constraints
03:54:14 <shachaf> Or that, sure.
03:54:16 <gfixler> SPJ made it sound simple
03:54:26 <shachaf> The extensions are pretty similar.
03:54:28 <kjgorman> ski: sorry was just wondering about where the type constraint went composing <*> (but i guess the instance is ->)
03:54:29 <gfixler> the record is passed around
03:54:48 <ski> kjgorman : probably, yea
03:55:40 <ski> gfixler : though if the compiler knows the actual type used at a use site, it could possibly make a specialized version that doesn't pass around the dictionary
03:56:02 <ski> gfixler : that doesn't work with polymorphic recursion, nor for existentials, though
03:56:06 <zenguine> ski: I see. its changing? do you guys have a link for this SPJ talk you guys are referencing?
03:56:48 <zenguine> brb
03:56:50 <ski> zenguine : no, i don't think it's changing. we're just talking about the well-known way to implement it
03:56:58 <zenguine> ahhh okay
03:57:04 <zenguine> gotta restart emacs
03:57:44 <tdammers> lol
03:57:54 <tdammers> restart emacs ~= reboot
03:58:06 * ski . o O ( "I'm in my happy place" )
03:58:36 <yeboot> tdammers: he might irc from inside emacs
03:58:51 <elspru> so if we have to describe it in one semi-formal sentence "factorial :: (Integral a) => a -> a". can it be represented as "name factorial be type for integer alpha that from alpha to alpha ya" ?
03:59:55 <elspru> not sure if I'm capture the concept of ->
04:00:03 <XniX23> does it make sense to ever use <$> if the functor is a function? or you just always use (.) instead?
04:00:37 <tdammers> yeboot: yeah, I figured this much... just find the idea kind of repulsive
04:00:38 <tdammers> :x
04:01:35 <yeboot> it is a pretty repulsive idea
04:01:48 <ski> elspru : i would read it aloud roughly as "`factorial' is a function that for any integral type `a' can accept an `a' as input, and will then produce an `a' as output"
04:01:49 <yeboot> but the idea of someone ircing with pedals keeps me entertained
04:02:00 <fgc> irc from emacs? just fine
04:02:15 <ski> IRCing via a teleprinter might be interesting ..
04:02:16 * spacekitteh wonders about adding predicates to the RULES rewrite engine...
04:02:42 <ski> ("using an RTTY converter unit and a HF radio", as someone just said in another channel)
04:02:56 <ski> spacekitteh : what kind of predicates ?
04:03:08 <elspru> ski: thanks
04:03:32 <spacekitteh> ski: i'm not sure. stuff accessible from template haskell, i guess
04:03:35 <ski> elspru : also, i'd remove the redundant brackets :)
04:04:15 <ski> spacekitteh : testing whether a subexpression was a variable could perhaps be useful
04:04:21 <spacekitteh> yeah, exactly
04:04:29 * hackagebot parsec3 1.0.0.8 - Monadic parser combinators  http://hackage.haskell.org/package/parsec3-1.0.0.8 (ChristianMaeder)
04:04:48 <spacekitteh> maybe even pass everything to KURE or something
04:04:50 <ski> also possibly testing whether a subexpression mentioned a given variable freely
04:05:01 <ski> ("KURE" ?)
04:05:14 <spacekitteh> kansas university rewrite engine
04:07:14 <ski> @where KURE
04:07:14 <lambdabot> I know nothing about kure.
04:07:32 <spacekitteh> www.ittc.ku.edu/csdl/fpg/papers/Sculthorpe-13-KURE.html
04:24:49 <tdammers> *sigh* I think I'll have to do some profiling after all
04:24:52 <tdammers> 22 second page load
04:28:19 <hopnotch> just allow mobile-only. they'll never know.
04:30:33 <hpc> hopnotch: lol
04:33:20 <viorel> hi all, quick question: I just installed ghc (i.e. version 7.8.3) but when I check the ghc version I get 6.10.4. Do you know how to change the default ghc version ?
04:35:26 <jedai> viorel: depends on your os/distribution
04:36:14 <jedai> viorel: I would strongly suggest that uninstalling ghc 6.10 would be the right decision (it's starting to date....)
04:36:16 <alpounet> viorel: it boils down to which ghc is first found in your PATH
04:36:17 <viorel> mac OS X 10.9.4 (mavericks)
04:36:40 <alpounet> echo $PATH and modify it so that 7.8.3's dir comes up before the older one
04:36:46 <viorel> got it
04:37:51 <viorel> I don't know how to uninstall ghc 6.10
04:40:40 <MrElendig> viorel: just use the full path?
04:40:56 <viorel> more precisely, I did run uninstall-hs
04:41:04 <viorel> so it appears my only version is 7.8.3
04:42:27 <jedai> more probably uninstall-hs isn't geared to uninstall ghc as old as 6.10, you probably installed it another way (I'm not even sure there was an Haskell Platform for 6.10 ?)
04:42:33 <XniX23> runEval $ do a <- rpar (fib 31); b <- rpar (fib 31); return (a,b); doesn't have any speed up, why is that?
04:42:53 <jedai> XniX23: compared to what ?
04:43:15 <jedai> :t rpar
04:43:15 <lambdabot> Not in scope: ‘rpar’
04:43:57 <XniX23> jedai, compared to running the function twice one after another
04:44:28 <jedai> XniX23: maybe the common expression was eliminated in the original version
04:44:37 <jedai> what's your fib like ?
04:44:59 <XniX23> fib 0 = 1; fib 1 = 1; fib n = fib (n-1) + fib (n-2)
04:45:08 <ciaranm> worst. fib. ever.
04:45:33 <jedai> ciaranm: Well I suppose the for his usage it's decent (slow fib needed)
04:45:45 <XniX23> exactly
04:46:16 <jedai> XniX23: Are you running it with -N2 or maybe -N3 ?
04:46:30 <XniX23> i'm just loading the file in ghci and running from there
04:46:53 <jedai> XniX23: it won't work then, because by default ghci is running on a single core
04:46:54 <fgc> you need tom compile wih -threaded
04:47:22 <XniX23> i have yet to learn to compile .hs files xD
04:47:26 <jedai> XniX23: and tell it howx many core to use (or tell it to use as many as you have)
04:47:50 <mroman_> XniX23: ghc --make -o fib fib.hs?
04:47:53 <jedai> XniX23: it's easy : "ghc --make -O2 --threaded stuff.hs
04:47:56 <mauke_> without --make
04:48:01 <mauke_> why do people still use this
04:48:14 <mroman_> Is --make default now?
04:48:15 <MP2E> make is on by default, it is not needed
04:48:17 <mauke_> "now"
04:48:22 <mroman_> or was it always?
04:48:27 <viorel> jedai: this makes sense, probably uninstall ghc doesn't see the ghc 6.10
04:48:28 <tdammers> fib 0 = 1; fib 1 = 1; fib n = fib (n - 1) - fib (n + 1) -- I believe this fib is even worse
04:48:29 <jedai> mauke_: oh right ... :-)
04:48:37 <mroman_> Well, you never know... someday it might become NOT default
04:48:45 <MP2E> I doubt it :P
04:48:47 <MP2E> but maybe
04:48:51 <mroman_> better safe than sorry
04:49:52 <mauke_> mroman_: it was changed in 7.0, released 4 years ago
04:50:22 <ski> > let fib 0 = 0; fib 1 = 1; fib 2 = 1; fib 3 = 2; fib 4 = 3; fib n = fib (n-2) + fib (n-3) + 2 * fib (n-4) + fib (n-5) in map fib [0 ..]
04:50:26 <lambdabot>  mueval-core: Time limit exceeded
04:50:32 <ski> > let fib 0 = 0; fib 1 = 1; fib 2 = 1; fib 3 = 2; fib 4 = 3; fib n = fib (n-2) + fib (n-3) + 2 * fib (n-4) + fib (n-5) in map fib [0 .. 12]
04:50:33 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144]
04:50:50 <jedai> mauke_: old habits die hard and since it still work with --make...
04:51:09 <MP2E> > fix $ scanl (+) 0 . (1:)
04:51:11 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
04:51:33 <jedai> MP2E: this is not a BAD fib
04:51:39 <MP2E> haha
04:51:47 <ski> my version isn't really worse, either
04:52:21 <mroman_> http://codepad.org/2ftFftup <- i prefer this fib
04:53:01 <mauke_> > iterate (round . ((0.5 + sqrt 1.25) *) . fromIntegral) 1
04:53:02 <lambdabot>  [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1771...
04:53:13 <mroman_> hm
04:53:15 <mroman_> if it weren't buggy
04:53:40 <yeboot> > let fact n = product [1..n]
04:53:41 <lambdabot>  not an expression: ‘let fact n = product [1..n]’
04:54:00 <yeboot> how is that not an expression
04:54:05 <mauke_> because =
04:54:06 <jedai> yeboot: it's a definition
04:54:10 <mroman_> why isn't this working o_O
04:54:15 <jedai> yeboot: lacks an in ...
04:54:33 <mauke_> mroman_: are you trying to compute 11?
04:54:37 <mroman_> no
04:54:54 <mroman_> http://codepad.org/XxNsuI0f <- but it does
04:55:09 <mroman_> wth
04:55:19 <mauke_> that's what happens when you add 10 1's to 1
04:55:24 <jedai> mroman_: fib ((a+b) : a : b : xs) would work better ?
04:55:28 <mroman_> oh
04:55:29 <mroman_> right
04:55:41 <mroman_> yeah
04:55:44 <mroman_> a : b :D
04:56:03 <mroman_> http://codepad.org/oPS5jjEv <- the *real* fib
04:56:18 <mauke_> not lazy enough
04:56:20 <MP2E> would the real fibonacci please stand up?
04:56:22 <ski> > (zipWith ((sum .) . take) [1 ..] . transpose . zipWith (\n -> (replicate n 0 ++)) [0 ..] . map (++ repeat 0) . iterate (\ns -> zipWith (+) ([0] ++ ns) (ns ++ [0]))) [1]
04:56:23 <mauke_> too tail recursive
04:56:24 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
04:57:16 <mauke_> > let fib a b = a : fib b (a + b) in fib 0 1
04:57:17 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
04:57:40 <XniX23> main = parFib 31; gives me -> Couldn't match expected type `IO t0'
04:57:40 <XniX23>             with actual type `(Integer, Integer)'
04:57:47 <Iceland_jack> mauke_: GHC needs a -fwarn-tail-recursive flag which gives you a "Function ‘foo’ is too tail recursive" warning
04:58:04 <mauke_> XniX23: print (parFib 31)
04:59:55 <XniX23> and how do i do 2 prints? print (fib 31); print (parFib 31) ?
05:00:07 <ski> yes, or
05:00:10 <mauke_> yes, but then you need a 'do' in front
05:00:18 <ciaranm> let fib n = round $ (((1 + sqrt 5) / 2) ** n) / (sqrt 5) in fib 31
05:00:21 <ciaranm> > let fib n = round $ (((1 + sqrt 5) / 2) ** n) / (sqrt 5) in fib 31
05:00:23 <lambdabot>  1346269
05:00:26 <ciaranm> magic
05:00:40 <ski>   main = do print (   fib 31)
05:00:47 <ski>             print (parFib 31)
05:00:49 <mauke_> > iterate (round . ((0.5 + sqrt 1.25) *) . fromIntegral) 1 !! 31
05:00:50 <lambdabot>  3524578
05:00:53 <mauke_> > iterate (round . ((0.5 + sqrt 1.25) *) . fromIntegral) 1 !! 30
05:00:55 <lambdabot>  2178309
05:00:56 <ski> XniX23 : e.g. like that ^
05:01:29 <jedai> XniX23: I'm not completely sure you're learning this in the "right" order if you don't know how to print two pieces of information but you're trying to parallelize your computation... Though I guess if that's your main interest
05:02:32 <XniX23> jedai, hah i know, it's not my main interest just wanted something to type since so far i was mostly just reading
05:03:05 <mauke_> @undo do print a; print b; print c
05:03:05 <lambdabot> print a >> print b >> print c
05:05:01 <XniX23> there is no --threaded flag in ghc
05:05:23 <jedai> XniX23: -threaded
05:05:25 <jedai> sorry
05:06:38 <XniX23> there is still no speedup :\
05:06:53 <Iceland_jack> XniX23: are you using rpar twice?
05:07:43 <jedai> XniX23: also compile with -rtsopts and use +RTS -N3 -RTS when running your program
05:08:05 <Iceland_jack> XniX23: You'll want to read this http://chimera.labs.oreilly.com/books/1230000000929/ch02.html#sec_par-rpar-rseq
05:08:08 <Iceland_jack> and use rseq
05:08:21 <jedai> XniX23: that tells the Runtime to run your program on 3 cores
05:08:38 <jedai> Iceland_jack: he's using Eval, so I don't think he needs rseq
05:08:46 <Iceland_jack> ah Eval
05:09:34 <jedai> XniX23: normally you would bake in an option telling your program to use a certain number of cores or all available (in a real world use case)
05:09:36 * hackagebot streaming-commons 0.1.5 - Common lower-level functions needed by various streaming data libraries  http://hackage.haskell.org/package/streaming-commons-0.1.5 (MichaelSnoyman)
05:11:52 <jedai> XniX23: also +RTS -s -RTS gives you timing, GC and parralelism information that may help you understand what's going on
05:12:44 <bernalex> I have Fu = {a :: Foo, b :: Foo, c :: Foo}, where Foo = Bar | Baz. what is a neat way to permutate all possible states of Foos in Fu? I want to call a function with all possible states.
05:13:01 <jedai> XniX23: if you still have a problem, you should paste the code somewhere so we may look at it
05:13:20 <ski> @let data Foo = Bar | Baz deriving Show
05:13:20 <jedai> bernalex: derinving Enum ?
05:13:22 <lambdabot>  Defined.
05:13:28 <Hafydd> "permutate"?
05:13:29 <bernalex> a simplified version would be Fu = Bool Bool Bool, and then I want to run a function on all possible states of Fu.
05:13:58 <ski> @let data Fu = MkFu {a,b,c :: Foo} deriving Show
05:13:59 <lambdabot>  Defined.
05:14:26 <Iceland_jack> > replicateM 3 [True, False]
05:14:28 <lambdabot>  [[True,True,True],[True,True,False],[True,False,True],[True,False,False],[Fa...
05:14:32 <ski> > do [aa,bb,cc] <- replicateM 3 [Bar,Baz]; return (MkFu {a = aa,b = bb,c = cc})
05:14:33 <lambdabot>  Ambiguous occurrence ‘a’
05:14:33 <lambdabot>  It could refer to either ‘L.a’, defined at L.hs:163:16
05:14:33 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.a’,
05:14:33 <lambdabot>                           imported from ‘Debug.SimpleReflect’ at L.hs:117:1-26
05:14:33 <lambdabot>                           (and originally defined in ‘simple-reflect-0.3.2:De...
05:14:49 <ski> > do [aa,bb,cc] <- replicateM 3 [Bar,Baz]; return (MkFu {L.a = aa,L.b = bb,L.c = cc})
05:14:51 <lambdabot>  [MkFu {a = Bar, b = Bar, c = Bar},MkFu {a = Bar, b = Bar, c = Baz},MkFu {a =...
05:15:05 <Iceland_jack> ski: You can even do
05:15:05 <Iceland_jack>     do [a, b, c] <- replicateM 3 [Bar, Baz]
05:15:05 <Iceland_jack>        return MkFoo{..}
05:15:05 <ski> which is basically what Iceland_jack said
05:15:19 <ski> Iceland_jack : yeah, i tend to forget that
05:15:37 <ski> (because it feels unnatural to me)
05:15:54 <Iceland_jack> It is quite weird to me too
05:16:21 <ski> bernalex : ok ?
05:16:28 <bernalex> still digesting
05:16:37 <jedai> Apparently ghc doesn't know how to derive Enum for a product type of Enum... :-( too bad
05:16:47 <Iceland_jack> ski: oh I've never tried that with a list comprehension....
05:17:00 <Iceland_jack> ghci> [ Fu{..} | [a, b, c] ← replicateM 3 [Bar, Baz] ]
05:17:05 <Iceland_jack> that works! cool
05:17:23 <ski> Iceland_jack : well, obviously :)
05:17:25 <ski> > replicateM 3 "ab"
05:17:26 <lambdabot>  ["aaa","aab","aba","abb","baa","bab","bba","bbb"]
05:17:30 <ski> > replicateM 2 "abc"
05:17:31 <lambdabot>  ["aa","ab","ac","ba","bb","bc","ca","cb","cc"]
05:17:38 <bernalex> let me pastebin something less... Foo Bar Fu Baz-y
05:17:48 <Iceland_jack> sure! I'd just never tried usnig RecordWildCards(?) with list comps
05:18:32 <XniX23> jedai, http://lpaste.net/111075
05:18:59 <Iceland_jack> ski: Cool, looks quite nice :)
05:19:16 <ski> > let flop MkFu {L.a = a,L.b = b,L.c = c} = Just MkFu {L.a = b,L.b = c,L.c = a} in flop MkFu {L.a = Baz,L.b = Bar,L.c = Baz}
05:19:18 <lambdabot>  Just (MkFu {a = Bar, b = Baz, c = Baz})
05:19:19 <bernalex> so here's something more specific: http://lpaste.net/2630278190144159744
05:19:23 <ski> Iceland_jack : in patterns as well ^
05:19:51 <bernalex> I think list comprehensions might look the nicest for this actually
05:19:53 <Iceland_jack> Quite nice :)
05:20:21 <ski> Iceland_jack : .. oh, i didn't realize you were talking about record wildcards :)
05:21:02 <bernalex> Iceland_jack: wait Fu{..} is some actual GHC thing?
05:21:07 <Iceland_jack> Yes
05:21:11 <bernalex> damn that's nice
05:21:19 <jedai> XniX23: To what are you comparing it ? if you're comparing it to "print (fib 34); print (fib 34)" and get the same, there is a speedup, since this program compute (fib 34) thrice (twice in the parFib then once more in the fib)
05:21:34 <Iceland_jack> bernalex: http://www.haskell.org/ghc/docs/7.8.3/html/users_guide/syntax-extns.html
05:21:46 <Iceland_jack> Record wildcards, this is not a very common use of it though
05:22:01 <Iceland_jack> pattern matching is how most people use it from what I've seen
05:22:05 <bernalex> so I want something like [ MkSpecifieds{..} | [beginMin, endMin, endMax] ← replicateM 3 [Specified, Unspecified] ]
05:22:08 <jedai> Iceland_jack: quite a nice one though
05:22:15 <ski> bernalex : it can be useful for some kind of OO-like stuff
05:22:24 <Iceland_jack> but you can also do
05:22:24 <Iceland_jack>     let name = "Sally"
05:22:24 <Iceland_jack>         age  = 24
05:22:24 <Iceland_jack>      in Person{..}
05:22:36 <Iceland_jack> bernalex: looks like it yes
05:22:54 <ski> it just collects the bindings in scope that corresponds to the field names
05:22:54 <bernalex> and then I can map go [that list comprehension]
05:23:01 -jedai(~jedai@ADijon-652-1-214-150.w90-6.abo.wanadoo.fr)- AVATAR
05:23:14 <Iceland_jack> bernalex: sure, or add it to the list comprehension itself
05:23:26 <Iceland_jack>     [ go Fu{..} | [a, b, c] ← replicateM 3 [Bar, Baz] ]
05:23:27 <bernalex> Iceland_jack: I might... gonna see how wide this thing gets first lol
05:23:36 <bernalex> but you're right that is probably nicer
05:24:23 <jedai> bernalex: you can do it in reverse too : "showPerson Person {..} = name <> 'is " <> show age <> " years old."
05:24:36 <bernalex> jedai: nice
05:24:52 <bernalex> def adding this to my pragma repertoire haha
05:24:57 <XniX23> jedai, i just run it and the first print is the single fib 34 call, and it takes about 1 sec to print it, then i run print parFib 34 which calls it 2 times (and should finish it if perfect in 1 sec since the calls should be in parallel) but it takes more than 2 sec i think, judging by the blinking of _ char in console (which i know is not good but still)
05:25:04 <Iceland_jack> Yes that's more useful if you don't mind drowning your scope in new stuff
05:25:57 <jedai> XniX23: run the program with "+RTS -N3 -s -RTS"
05:26:02 <spacekitteh> Iceland_jack: did you see the email from SPJ about my proposal? : D
05:26:12 <Iceland_jack> hm no I didn't, link?
05:26:31 <jedai> XniX23: the way you're doing it -N3 is passed as a parameter to the program, not to the runtime
05:26:32 <Iceland_jack> I've been moving between countries so I've been out of the loop a bit
05:26:33 <XniX23> jedai, thanks that solved it!
05:26:40 <XniX23> ohhhh
05:26:53 <XniX23> i thought its a valid flag
05:27:10 <spacekitteh> Iceland_jack: www.haskell.org/pipermail/ghc-devs/2014-September/006302.html
05:27:37 <XniX23> jedai,  is it possible to say it in the program to use all processors instead of flags when running?
05:27:56 <Iceland_jack> spacekitteh: If you make it work with arrows then it makes sense in base
05:28:02 <Iceland_jack> such that it simplifies it
05:28:05 <spacekitteh> Iceland_jack: yeah.
05:28:22 <Iceland_jack> Your work makes me a happy camper
05:28:48 <spacekitteh> don't 420 noscope me
05:29:03 <bernalex> god how do I do this again
05:29:05 <jedai> XniX23: not right now buit you can compile the program with rts options baked in and using -N means your program run on as many core as there are in the system
05:29:15 <bernalex> I have desugared do-notation and now I have a [SomeMonad]
05:29:20 <Iceland_jack> spacekitteh: Video game reference?
05:29:22 <bernalex> but I need to return SomeMonad
05:29:26 <spacekitteh> Iceland_jack: yeah
05:29:27 <Iceland_jack> I meant camping with tents :)
05:29:30 <XniX23> jedai, ok, thanks again
05:29:31 <bernalex> and join is not helping me out lol
05:29:36 <spacekitteh> jedai: how do you compile the RTS opts in?
05:30:23 <jedai> spacekitteh: -with-rtsopts="-H128m -K1m"
05:30:54 <spacekitteh> ah cool D
05:30:56 <spacekitteh> :D
05:31:55 <jedai> bernalex: sequence ?
05:31:59 <jedai> :t sequence
05:32:00 <lambdabot> Monad m => [m a] -> m [a]
05:32:13 <bernalex> jedai: yeah I figured it out. I needed, of course, sequence*_* not just sequence heh
05:32:42 <ski> spacekitteh : nice
05:33:21 <spacekitteh> ski?
05:34:08 <ski> spacekitteh : the blog post
05:34:23 <nyuszika7h> my birthday is on the same day as Simon Peyton Jones :O
05:34:27 <sgronblo> Anyone tried intellij for Haskell development?
05:34:35 <nyuszika7h> + 's
05:34:43 <doismellburning> sgronblo: I did a bit; wasn't hugely impressed
05:34:59 <XniX23> do haskell functions have keyword arguments? or is it possible only if passing a record?
05:35:10 <spacekitteh> ski are neat
05:35:12 <spacekitteh> ah neat*
05:35:22 <spacekitteh> Only if passing a record, XniX23
05:35:27 <ski> spacekitteh : is there a reason for defining `QFunctor' for a binary operation, instead of just using a unary one ?
05:35:34 <sgronblo> doismellburning: recently?
05:35:40 <spacekitteh> nahh i'm gonna remove the p/qfunctors
05:35:42 <doismellburning> sgronblo: in the last few weeks
05:35:48 <sgronblo> doismellburning: ah too bad
05:36:01 <doismellburning> sgronblo: occasionally I look at IDEA from time to time in the hope of a plugin update
05:36:22 <sgronblo> I feel like using an IDE for static languages these days
05:36:40 <ski> spacekitteh : iow, something like `class (Category s,Category t) => BlahFunctor f s t | f s -> t,f t -> s where blahMap :: s a b -> t (f a) (f b)'
05:36:59 <doismellburning> sgronblo: I feel like there could be much more UI support than there is
05:37:15 <ski> (probably kmett already has this, but i don't recall what it would be named)
05:37:38 <spacekitteh> ski: yep, exactly
05:37:47 <spacekitteh> i'm gonna do that when i stop playing bf4 :P
05:37:50 <sgronblo> It's much easier to get to 80% of my vim editing functionality using ideavim, than to get 80% of the large codebase features I can get in an IDE, in vim.
05:39:04 <jedai> XniX23: you can only approximate "keywords arguments" with records, which can also be useful for default values for arguments, some libraries do that for the function that would otherwise have too many arguments
05:39:38 <ski> spacekitteh : i suppose you can define the inverses of the cancellation operations, but i don't atm see how ..
05:39:45 <jedai> XniX23: some of the syntax extensions in GHC help make this style pretty painless
05:40:17 <bernalex> since you guys have so much tricks up your sleeves -- any good way with my Fu to get all Foos that are Bar?
05:40:35 <bernalex> again Fu = MkFu Foo Foo Foo, and Foo = Bar | Baz.
05:40:38 <Iceland_jack> bernalex: Run that past us one more time? :)
05:40:47 <bernalex> so I want all Foos in my Fu that are Bar
05:40:58 <Iceland_jack> so just: MkFu Bar Bar Bar?
05:41:16 <bernalex> lets leave out the Fus and Bars to make it more managable/specific. let me retry. :-]
05:41:34 <akagr> Hi guys. Can anyone explain how following is working? I was trying to learn lists and this is tripping me.
05:41:35 <ski> spacekitteh : while it perhaps would be too much abstraction, it might be nice to ponder if one could handle higher functors here ..
05:41:36 <spacekitteh> ski: by just using inFirst/inSecond with the ID object
05:41:37 <jedai> I think he want MkFu Bar Baz Bar -> [Bar, Bar]
05:41:37 <akagr> fib = 1 : 1 : map (\(a,b) -> a + b) (zip fib (tail fib))
05:41:58 <bernalex> Iceland_jack: data Specifieds = MkSpecifieds {beginMax :: SpecifiedState, ndMin   :: SpecifiedState, endMax   :: SpecifiedState}; data SpecifiedState = Specified | Unspecified deriving (Eq)
05:41:58 <Iceland_jack> akagr: Do you understand 'zip'?
05:42:05 <Fuuzetsu> wow, check this gem out
05:42:12 <Fuuzetsu>  paintPicture (baseAttributes sty) <$> fmap (fmap (fmap ($ sty))) <$> (extraLayers ++) <$> strokesRangesB mexp region
05:42:23 <akagr> Iceland_jack: yep... it joins two lists into a list of pairs
05:42:24 <bernalex> Iceland_jack: so if I have foo = MkSpecifieds Specified Unspecified Specified, I want to get endMin.
05:42:33 <Iceland_jack> okay..
05:42:41 <bernalex> Iceland_jack: if I have bar = MkSpecifieds Unspecified Unspecified Specified, I want beginMax & endMin.
05:42:48 <spacekitteh> ski: or doing it in the dual category
05:43:12 <spacekitteh> ski: i haven't finnished writing out the classes yet
05:43:18 <jedai> bernalex: I'm not sure I understand, you want to get a list of accessor to your record ?
05:43:31 <ski> spacekitteh : hm, i don't quite see that
05:43:35 <akagr> Iceland_jack: I am having trouble with the recursion in this example
05:43:36 <bernalex> jedai: I wanna find out which out of beginMax, endMin and endMax are Unspecified.
05:44:07 <akagr> I know other elements in here such as map and lambda function
05:44:18 <jedai> bernalex: right, so how would you represent the fact that beginMax was Unspecified ?
05:44:31 <Iceland_jack> akagr: right, does this make sense:
05:44:31 <Iceland_jack>     ones = 1 : ones
05:44:59 <jedai> bernalex: what's the type of your function ? unspecifiedsInMkFu :: Fu -> ?
05:45:00 <Iceland_jack> akagr: And the type as well:
05:45:01 <Iceland_jack>     ones :: [Integer]
05:45:01 <Iceland_jack>     ones = 1 : ones
05:45:14 <ski> spacekitteh : given `inFirst :: k a (k b (p a b))', if we set `b' to `Id k p', we get `k a (k (Id k p) (p a (Id k p)))', and if we set `a' to it instead, we get `k (Id k p) (k b (p (Id k p) b))', while we'd like to get `k a (p (Id k p) a)' or `k a (p a (Id k p))'
05:45:14 <bernalex> jedai: right, that's what I'm sort of asking. :-] I have a function that runs through all possible permutations of Specifieds. there, I need to make a string with "beginMax" if that one is Unspecified, or "beginMax/endMin" if those are unspecified.
05:45:20 <bernalex> jedai: what function?
05:45:39 <jedai> bernalex: Ok, so you want a String ?
05:45:39 <bernalex> jedai: oh. right. I have a function where I make all possible specifieds;
05:45:43 <bernalex> sequence_ [go MkSpecifieds {..} | [beginMax, endMin, endMax] <- replicateM 3 [Specified, Unspecified]]
05:45:49 <bernalex> then
05:45:51 <akagr> Iceland_jack: this is similarly tripping me up... where is the [] to which all the ones are getting added
05:45:52 <bernalex> where go ss = [stuff]
05:46:01 <spacekitteh> ski: true
05:46:05 <bernalex> inside of stuff I do: it ("inserts a timespan with key 1 w/o specifying" ++ unspecs ss) $ do
05:46:07 <Iceland_jack> akagr: there is no []
05:46:15 <Iceland_jack> because it's an infinite list
05:46:21 <Iceland_jack> Just like:
05:46:21 <Iceland_jack> > [0..]
05:46:23 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
05:46:30 <bernalex> so I need unspecs, which takes the specifieds, to figure out if e.g. beginMin is an Unspecified, and return the String "beginMin".
05:46:37 <bernalex> (that should be beginMax not beginMin, but whatever)
05:46:38 <Iceland_jack> You can traverse '[0..]' as long as you want and you'll neve reach an empty list: []
05:46:48 <Iceland_jack> *never reach
05:47:05 <ski> spacekitteh : so, there's a mismatch in the number of `k's and `p's .. something more involved seems needed
05:47:07 <akagr> Iceland_jack: what I mean is, how haskell knows that ones is a list
05:47:17 <ski> spacekitteh : btw, is the term "binoidal" standard ?
05:47:18 <akagr> because this works even if you don't give the signature
05:47:20 <wz1000> bennofs: A few days ago we were having a conversation about IO Transformers. I realise I cannot implement one with only safe code, but what will happen if I write one using unsafePerformIO? What kind of behaviour will it exhibit?
05:47:20 <jedai> bernalex: I don't think there is a particular trick to this function
05:47:30 <Iceland_jack> akagr: the thing at the right side of ':' must be a list
05:47:30 <bernalex> jedai: well how would you do it?
05:47:41 <Iceland_jack> and since we're defining 'ones' as '1 : <something>', ones must be a list
05:47:42 <spacekitteh> ski: yeah, i've seen it in both a thesis and ncatlab
05:47:45 <Iceland_jack> @ty (:)
05:47:46 <bernalex> jedai: maybe your way is a trick to me because I don't know it :-]
05:47:46 <lambdabot> a -> [a] -> [a]
05:47:50 <ski> spacekitteh : ok, ty
05:48:03 <spacekitteh> ski: refresh the page btw
05:48:21 <akagr> Iceland_jack: So 1:ones is expanded to 1:1:ones which gets expanded to 1:1:1:ones and so on
05:48:24 <Iceland_jack> sure
05:48:25 <akagr> right?
05:48:32 <akagr> ok I get it
05:48:36 <Iceland_jack> just by substitution
05:48:52 <Iceland_jack> akagr: Now what about
05:48:52 <Iceland_jack>     nats :: [Integer]
05:48:52 <Iceland_jack>     nats = 0 : map (+1) nats
05:49:13 <Iceland_jack> @let let { nats :: [Integer]; nats = 0 : map (+1) nats }
05:49:13 <lambdabot>  Parse failed: Parse error: EOF
05:49:20 <jedai> bernalex: unspecs MkFu {..} = intersperse '/' $ go "beginMin beginMin ++ go ... where go s Unspecified = [s]; go _ _ = []
05:49:20 <Iceland_jack> @let { nats :: [Integer]; nats = 0 : map (+1) nats }
05:49:21 <spacekitteh> ski: but yeah you're right i definitely need to define inverses
05:49:23 <lambdabot>  Defined.
05:49:24 <Iceland_jack> > nats
05:49:25 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
05:49:32 <Iceland_jack> akagr: Does that make sense?
05:49:48 <bernalex> jedai: wtf :-P
05:49:57 <bernalex> jedai: would you mind pastebinning it? I will pastebin where it's supposed to go
05:49:57 <jedai> bernalex: s/go "beginMin beginMin/go "beginMin" beginMin/
05:50:05 <akagr> I guessed the same output... can you help me in the substitution though
05:50:16 <Iceland_jack> akagr: let's call '(+1)' succ
05:50:28 <bernalex> jedai: http://lpaste.net/2630278190144159744
05:50:30 <akagr> it is a curried function
05:50:38 <akagr> partially applied
05:50:49 <ski> spacekitteh : maybe, i dunno
05:50:50 <Iceland_jack> It's actually a section, but it's similar to a partially applied function
05:50:59 <spacekitteh> can you use a type variable infix?
05:51:25 <Iceland_jack> ghci> type F f a = a `f` a
05:51:42 <Iceland_jack> Doesn't work anymore for operators afaik
05:51:46 <ski> spacekitteh : you used to be able to write stuff like `graph :: Arrow (~>) => (a ~> b) -> (a ~> (a,b))', but unfortunately that doesn't work any more :(
05:51:57 <spacekitteh> =[
05:51:58 <spacekitteh> why not?
05:52:15 <Iceland_jack> akagr: so we have
05:52:16 <Iceland_jack>     nats = 0 : map succ nats
05:52:29 <Iceland_jack> and 'nats' starts with a 0 so
05:52:36 <ski> spacekitteh : because they decided that all operations should be type constructors, rather than only those that starts with `:' (and the exception case `->')
05:52:39 * ski doesn't like it
05:52:43 <Iceland_jack>     nats = 0 : map succ (0 : map succ nats)
05:52:52 <ski> s/operations/operators/
05:53:15 <ski> some people didn't like writing like `foo :+: bar', i suppose
05:53:17 <akagr> Iceland_jack: how will that last nats get expanded
05:53:21 <Iceland_jack>     nats = 0 : succ 0 : map succ (map succ nats)
05:53:21 <Iceland_jack>          = 0 : 1      : map (succ . succ) nats
05:53:21 <Iceland_jack>     
05:53:26 <spacekitteh> hmm k
05:53:35 <Iceland_jack> akagr: we can maybe take this to PM if you want
05:53:50 <asfp`> what is the common way of chaining/stacking or combining  Either/EitherT errors (the Left ones) when dealing with sub components?  Either String a seems to be the only answer that doesn't include lots of boiler plate code.
05:53:51 <Iceland_jack> so I won't spam the channel
05:53:58 <ski> Iceland_jack : or #haskell-overflow
05:54:00 <Iceland_jack> sure
05:54:29 <jedai> bernalex: http://lpaste.net/2630278190144159744#a111076
05:54:43 <bernalex> jedai: let me chew on it a bit. thanks!
05:55:15 <bernalex> jedai: initial reaction is "lolwtf"
05:55:39 <bernalex> jedai: so we can safely say this qualifies as a trick to me. I would likely do it much more verbosely. :-]
05:56:27 <jedai> bernalex: not really, I join the strings with a "/" inbetween, for each field I either have a [String] with one String in or an empty list
05:56:45 <jedai> bernalex: depending on if the field is unspecified or not
05:57:41 <jedai> bernalex: I tend to prefer <> now that it's in base, but those are just ++ here
05:58:41 <Yrarr> Hello, I
05:58:46 <ski> jedai : instead of `sequence_ [go ... | ...]', one could say `mapM_ go [... | ...]'
05:58:49 <bernalex> jedai: yeah I see
05:58:51 <bernalex> jedai: I like <> too
05:59:06 <jedai> ski: that's bernalex code, I didn't look at it much
05:59:14 <ski> oh, i see
05:59:16 <ski> bernalex ^
05:59:18 <bernalex> it's strictly speaking Iceland_jack's code lol
05:59:35 <bernalex> yeah I see. that was what I originally had
05:59:44 <ski> or one could say something like
05:59:47 <ski>   forM_ [... | ...] $ \ss -> do
05:59:52 <ski>     ..body of go..
06:00:01 <bernalex> yeah I had that even before mapM_ lol
06:00:08 <bernalex> IDK what I'll end up with
06:00:16 <ski> bernalex : just showing some alternatives for you to choose from :)
06:00:53 <lpaste_> Yrarr pasted “Which is faster - pattern matching, or Data.Map ?” at http://lpaste.net/2868900521500999680
06:01:05 <bernalex> jedai: doing a few small tweaks (like adding a space to the string, heh), and this is perfect! thanks a lot
06:01:27 <jedai> bernalex: you're welcome :-)
06:01:28 <Yrarr> Hello, I've got one question: What's faster for this situation - using Maps, or pattern matching ? http://lpaste.net/2868900521500999680
06:01:47 <jedai> Yrarr: depends on the number of alternative
06:02:26 <Yrarr> jedai: for a big numbers of alternatives, like 50-100, what option would be better ?
06:02:45 <jedai> Yrarr: Map
06:03:00 <Yrarr> Okay, thanks :)
06:03:27 <bernalex> jedai: need to figure out how I want to deal with toS _ _ though, heh.
06:03:40 <ski> spacekitteh : some less essential naming stuff :
06:04:07 <jedai> Yrarr: the pattern matching will be in O(n) and Map in O(log n) so probably won't hurt too much (though the constants will be bigger) and that will be cleaner to boot
06:04:22 <ski> spacekitteh : i suppose the use of `Left' and `Right' in `Associative' isn't really consistent with the use of those in `PreMonoidal'
06:04:35 <spacekitteh> ski: oh yeah good catch
06:04:57 <ski> spacekitteh : i'm not quite sure what would necessarily be better names, though
06:06:30 <ski> spacekitteh : one version might be `lUnitRight :: k (p (Id k p) a) a' and `rUnitLeft :: k (p a (Id k p)) a' -- not really happy with the double use of `L' and `R' here, though
06:06:55 <spacekitteh> hmmm
06:07:14 <ski> spacekitteh : perhaps `idCombRight' and `combIdLeft'
06:07:30 <Yrarr> jedai: Hm. ok, Just wondering if the compiler would optimise simple pattern matching. If there's only one variable matched (of Ord instance), a decision tree could be made for pattern
06:07:45 <spacekitteh> unitorRight and unitorLeft maybe, ski
06:08:12 <ski> (i'm saying "Left" for the latter part since i think the order `x = x * 1' is more natural than the order `x * 1 = 1' .. you're free to disagree, though)
06:08:25 <folsen> Anyone feel in the mood of explaining some Uniplate/Generics stuff for me? I have an example here not producing the results I expected: https://gist.github.com/folsen/b4594e265d5ead10c2e5
06:08:42 <jedai> Yrarr: Right, maybe it does, you could test... but personally I would go with Map anyway since a data structure will be more flexible
06:09:54 <ski> (i think there's a certain elegance to the orderings :  (x * y) * z = x * (y * z)  ,  1 * x = x  ,  x = 1 * x  ,  x^-1 * x = 1  ,  1 = x * x^-1  )
06:09:55 <jedai> Yrarr: of course if this function is extremely critical time wise, it may be worth it to check but I kinda doubt it (don't forget than in the general case, pattern HAVE to be scanned in order since you can have partial overlap with the first winning)
06:10:53 <ski> (another version could be having `assoc',`assocInv',`leftUnit',`leftUnitInv',`rightUnit',`rightUnitInv')
06:10:54 <spacekitteh> ski: refresh the page and tell me what you think
06:11:50 <jedai> folsen: looks like a problem with the Vector instance...
06:12:03 <spacekitteh> ski: or you could make an edit here: https://github.com/spacekitteh/blog/blob/master/posts/new-monoidal-cats.markdown
06:12:19 <ski> when i see "cancel" i think about `a * b0 = a * b1 => b0 = b1', which is why i was looking for an alternative
06:12:32 <folsen> jedai: that’s what I thought at first too, but it has all the same instances as HashMap, Foldable, Traversable, Data, etc
06:12:56 <spacekitteh> hmm.... well the terminology used in ncatlab is "left unitor" for 1*x -> x
06:12:59 <jedai> folsen: right, the problem would be in the content of those instance
06:13:01 <spacekitteh> i might go with that
06:13:43 <jedai> folsen: http://projects.haskell.org/pipermail/vector/2012-July/000281.html
06:14:07 <ski> yet another alternative is to use the "introduction" and "elimination" terminology
06:14:20 <spacekitteh> oooh, true
06:14:20 <folsen> jedai: doh >.< (why didn’t I find that post?)
06:14:28 <ski> so your "cancels" would be elims, and your "unitors" would be intros
06:14:39 <folsen> jedai: will try my own instance of Data then
06:14:42 <ski> but this doesn't fit for `assoc'
06:14:47 * hackagebot uhc-util 0.1.3.9 - UHC utilities  http://hackage.haskell.org/package/uhc-util-0.1.3.9 (AtzeDijkstra)
06:15:05 <jedai> folsen: on the other hand that dates back to 2012, maybe the latest version of vector corrected that ?
06:15:12 <ski> (one could abbreviate to an `I' or `E' at the end, keeping the operation names nice and short)
06:15:24 <folsen> jedai: will check!
06:15:36 <ski> like `lUnitI',`lUnitE',`rUnitI',`rUnitR'
06:15:42 <ski> er
06:15:45 <ski> like `lUnitI',`lUnitE',`rUnitI',`rUnitE'
06:15:58 <spacekitteh> idk, i don't particularly like that style of naming
06:16:02 <ski> ok
06:16:03 <spacekitteh> the abbreviation
06:16:05 <folsen> jedai: no current implementation of those are: toConstr _   = error "toConstr"
06:16:17 <spacekitteh> but it should be nice and short
06:16:33 <spacekitteh> maybe introUnitLeft/elimUnitLeft
06:16:40 <ski> spacekitteh : i'm not really saying you should pick one or the other here. i'm merely offering some alternatives, and suggesting that you should consider this
06:16:46 * spacekitteh nodnods
06:16:50 <jedai> folsen: damn... you can probably write an Uniplate instance though
06:17:08 <spacekitteh> this stuff will probably not be seen much as this would be the desugared notation
06:17:51 <ski> yeah, but ideally we'd want some reasonably coherent naming that can be deciphered without having to look up the docs all the time
06:17:56 <spacekitteh> yeah
06:19:02 <ski> spacekitteh : anyway, i think it's great that you're writing and pondering this :)
06:19:07 <spacekitteh> \o/
06:19:25 <spacekitteh> i wonder if i could do my thesis on this
06:19:29 <ski> it'd also be nice if one could manage to device translation rules for the `proc'&`do' syntax into these combinators
06:19:55 <spacekitteh> indeed; the Generalised Arrows work seems to be the best starting place
06:20:17 <ski> hm, do you have a link to that ?
06:20:31 <spacekitteh> at the bottom of the page in the link section is a link to it
06:20:37 <ski> ok, ty
06:20:40 <spacekitteh> or more accurately a link to the thesis
06:21:00 * ski nods
06:21:34 <folsen> jedai: feels like it would be simple to write a Uniplate instance, and probably cleaner than modifying the Data instance
06:49:18 <bernalex> jedai: I wonder if we can't use show here?
06:49:30 <bernalex> anyone know of a way to do this?
06:49:37 <bernalex> data SpecifiedState = Specified | Unspecified
06:50:03 <bernalex> is there a way to implement show, so that show Foo, where Foo :: SpecifiedState is "Foo" if Specified, and [] if Unspecified?
06:51:28 <quchen> instance Show SpecifiedState where show Specified = "Foo"; show _ = "[]"?
06:51:40 <bernalex> quchen: uhm
06:51:42 <bernalex> quchen: no
06:51:52 <bernalex> quchen: OK so we have: data SpecifiedState = Specified | Unspecified
06:52:11 <bernalex> quchen: Foo :: SpecifiedState; Foo = Specified
06:52:21 <bernalex> quchen: Bar :: SpecifiedState; Bar = Unspecified
06:52:27 <quchen> That doesn't work.
06:52:29 <bernalex> quchen: now, show Foo should give "Foo", and show Bar should give ""
06:52:39 <bernalex> quchen: hm?
06:52:41 <quchen> The only things of type SpecifiedState are Specified and Unspecified. Foo and Bar can't have that type.
06:52:54 <bernalex> quchen: what?
06:52:56 <bernalex> oh
06:52:58 <bernalex> erm
06:53:00 <bernalex> foo
06:53:02 <bernalex> lowercase
06:53:04 <bernalex> bar too
06:53:06 <quchen> Alright.
06:53:19 <simpson> bernalex: Typically one wouldn't use Show for this.
06:53:47 <quchen> Right, Show is not for prettyprinting. https://github.com/quchen/articles/blob/master/fbut.md#show-is-not-for-prettyprinting
06:53:53 <bernalex> quchen: so if I have foo, bar, baz, quux, and foo and quux are Specified, and the other two Unspecified, mapping show should give ["foo", [], [], "quux"]
06:53:58 <simpson> foobar Specified = "Foo"; foobar Unspecified = ""
06:54:13 <simpson> And then: map foobar yourListOfSpecifications
06:54:23 <bernalex> simpson: yes that's what I presently have
06:54:28 <simpson> bernalex: Great!
06:54:28 <bernalex> simpson: I'm just curious if this is possible with show.
06:54:39 <simpson> bernalex: Sure! But that's not what Show is for.
06:54:41 <blueonyx> hi, is there any way to specify a package-db to hint? so i can use the modules from a sandbox maybe?
06:54:50 <bernalex> simpson: yes, I'm not at all convinced it makes sense to actually *do* it. I'm more just curious. :-]
06:56:07 <simpson> bernalex: instance Show SpecifiedState where { show Specified = "foo" -- and I think you get the gist.
06:56:20 <bernalex> simpson: I don't understand that
06:56:25 <bernalex> quux = Specified
06:56:27 <bernalex> show quux
06:56:36 <bernalex> will not return "quux" with that example
06:57:09 <simpson> bernalex: Oh. Why do you want that?
06:57:31 <simpson> (That is typically somewhere between hard and impossible; Haskell doesn't have that sort of reflection.)
06:57:34 <bernalex> also I've been presenting this all wrong, I want the string when it's Unspecified not when it's Specified lol
07:14:53 * hackagebot conduit-connection 0.1.0.1 - Conduit source and sink for Network.Connection.  http://hackage.haskell.org/package/conduit-connection-0.1.0.1 (slomo)
07:25:40 <tac_> A bifunctor is just a generalization of Hom, right?
07:25:53 <tac_> A functor of two arguments, covariant in the second and contra in the first?
07:26:22 <MP2E> that's a profunctor, bifunctor is 2 covariant functors afair
07:26:32 * MP2E double checks
07:26:48 <MP2E> "Intuitively it is a bifunctor where both the first and second arguments are covariant."
07:28:01 <tac_> ah
07:28:13 <Fuuzetsu> @check \s p -> unwords s ++ unwords p == unwords (s ++ p)
07:28:15 <lambdabot>  *** Failed! Falsifiable (after 2 tests and 2 shrinks):
07:28:16 <lambdabot>  [""] [""]
07:28:18 <tac_> So a generalized product
07:29:19 <MP2E> yeah, I've never thought about it that way before but that definitely works
07:29:31 <MP2E> generalized product, hmm
07:29:40 <tdammers> @check \s p -> unwords s ++ unwords p == unwords (s ++ " " ++ p)
07:29:42 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘[GHC.Types.Char]’
07:29:42 <lambdabot>  Expected type: [GHC.Base.String] Actual type: [GHC.Types.Char]
07:29:44 <tdammers> vOv
07:29:45 <tac_> Well, I just mean the product is an example of a bifunctor
07:30:05 <tac_> You would also have coproducts... and I don't know too many other examples off the top of my head
07:30:10 <tac_> tensor products, I suppose, too
07:30:11 <tdammers> eh, the other way around
07:31:15 <Iceland_jack> :t bimap :: (a1 -> b1) -> (a2 -> b2) -> (a1, a2) -> (b1, b2)
07:31:16 <lambdabot> (a1 -> b1) -> (a2 -> b2) -> (a1, a2) -> (b1, b2)
07:39:57 <Fuuzetsu> :t bimap
07:39:58 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
07:41:05 <Fuuzetsu> what package is this in
07:41:30 <Fuuzetsu> ah, lens
07:42:03 <Iceland_jack> It's in a lot of packages
07:42:09 <Iceland_jack> @hackage bifunctors
07:42:09 <lambdabot> http://hackage.haskell.org/package/bifunctors
08:06:34 <sfdsdfs> what alpha conversion strategies are there?
08:09:41 <vanila> sfdsdfs, you can have a monad that gives you a unique number each time you ask
08:10:05 <vanila> sfdsdfs, or de bruijn syntax or HOAS to completely sidestep the problem
08:10:22 <carter> @hackage bound is an option too
08:10:22 <lambdabot> http://hackage.haskell.org/package/bound is an option too
08:10:26 <sfdsdfs> vanila: I'd like to try the naive approach first
08:10:31 <carter> Iceland_jack: finally grinding out all that refactory shit
08:10:33 <steffen> I have a want to wrap a C-function that gets a FILE* as imput and gets always called with stderr as an argument for that. How do I wrap that FILE* in the haskell FFI and even more interesting, how can I then call this function with stderr as an agrument from haskell?
08:10:42 <Iceland_jack> carter: how's it going?
08:10:50 <carter> Iceland_jack: goot
08:10:55 <vanila> sfdsdfs, the worst approach?
08:10:56 <carter> Iceland_jack: lets switch to #numerical-haskell
08:10:58 <Iceland_jack> sure
08:11:23 <sfdsdfs> vanila: so I could appreciate other solutions and see the rationale of each
08:12:09 <vanila> using strings for variables names is dangerous and only done when people don't know better
08:13:00 <osa1> this happened to you before? you're installing a package in a sandbox. package uses GHC and you have pre-compiled 7.8.3 installed, which is linked with Cabal 1.18.3. so now your package has to use Cabal 1.18.3 if you want to link it with GHC. now the problem is, if your system-wide cabal installation is newer than that, then test-suite generator generates the stub files using newer API than 1.18.3 and your app is now not compilable :D
08:13:33 <sfdsdfs> vanila: what would you use?
08:13:50 <vanila> depends on what im doing
08:14:02 <sfdsdfs> writing an evaluator for LC
08:14:59 * hackagebot git-annex 5.20140915 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20140915 (JoeyHess)
08:15:35 <vanila> HOAS and NBE like in http://strictlypositive.org/Easy.pdf - see figure 4 on page3
08:17:06 * Derty joined here people this e good network for europe /server -m foxchat.hopto.org for mirc client and with webchat http://foxchat-network.webnode.gr/webchat/
08:17:29 <steffen> When I wrap a C-Function with FFI, and that function has a CFile as argument, how do I call it with Cs stderr as an argument?
08:17:36 <osa1> I'm wondering if that's cabal bug. it should generate stubs compatible with the linked version.
08:19:29 <grizzy> o/
08:19:32 <grizzy> whats up
08:21:34 <carter> sfdsdfs: use bound
08:21:40 <carter> @hackage bound
08:21:40 <lambdabot> http://hackage.haskell.org/package/bound
08:21:47 <mroman_> Why can't I terminate haskell stuff with Ctrl-C
08:21:47 <carter> sfdsdfs: whats the rep of the File type
08:21:56 <carter> is it just an int modelling a file handle?
08:22:20 <vanila> carter, This looks incredibly complex
08:22:24 <carter> vanila: nope
08:22:25 <carter> its not
08:22:28 <carter> look at the examples
08:22:33 <carter> its really really simple
08:22:47 <sfdsdfs> carter: yeah, you've already mentioned it.  as I said, I'd prefer to start with something naive and scrap the boilerplate later.
08:22:57 <carter> sfdsdfs: ... it doesnt end well that way
08:23:03 <carter> ghc is stuck with that 20 years later
08:23:04 <vanila> I dont think introducing this sort of complexity will help someone learn how to handle syntax with binding
08:23:19 <carter> bound aint complex
08:23:25 <carter> :)
08:23:52 <carter> https://github.com/ekmett/bound/blob/master/examples/Simple.hs
08:24:00 <vanila> you can say that but the library looks very complex to me
08:24:18 <carter> vanila: show me a simple variable binding lib
08:24:20 <carter> show meeeeee
08:24:35 <vanila> Look at fig4 of the PDF I just linked
08:24:35 <carter> https://github.com/ekmett/bound/blob/master/examples/Simple.hs is very simple
08:24:43 <mroman_> wtf
08:24:57 <carter> vanila: thats the same as the bound code
08:25:13 <mroman_> hGetLine isn't \r\n,\n,\r aware :(
08:25:13 <vanila> it's not the same
08:25:18 <sfdsdfs> why do all haskell examples of LC evaluators use whnf to nf?
08:25:26 <carter> vanila: both are debrujin
08:25:35 <carter> sfdsdfs: whnf always terminates
08:25:42 <carter> when theres a terminating evaluation strategy
08:25:59 <carter> sfdsdfs: ok, i see how the internals are teeny bit simpler
08:26:01 <carter> *vanilla
08:26:07 <carter> vanila: fine
08:26:09 <carter> but
08:26:20 <carter> is the goal to writing a binding lib or a languae?
08:26:21 <carter> :)
08:26:46 <vanila> yeah i guess it depends on your goals what you would use
08:27:12 <sfdsdfs> carter: but there are so many different evaluation strategies, aren't there any alternatives?
08:28:10 <carter> vanila: if the goal is to mess with writing a variable binding implementation approaches, i agree with you
08:28:14 <vanila> sfdsdfs, The reify/reflect technique inherits evaluation order from the metalanguage - the same code in a strict language would implement strict evaluation order
08:28:43 <mroman_> Is there a way to notify all threads about something?
08:28:51 <carter> mroman_: Chan or somthing
08:28:52 <carter> or MVar
08:28:56 <carter> or someting
08:28:58 <mroman_> dupChan?
08:29:04 <mroman_> if I remove something from a dupChan
08:29:05 <sfdsdfs> vanila: but it must be possible to do it differently if I need that, right?
08:29:08 <mroman_> is it gone for the other threads?
08:29:18 <carter> mroman_: run an experiment!
08:29:25 <carter> Chan has subscription semantics
08:29:28 <carter> *broadcast
08:30:11 <vanila> sfdsdfs, you could use a monadic evaluator to implement strict evaluation in haskell
08:30:30 <sfdsdfs> vanila: And I'm not familiar with the reify/reflect term...
08:30:54 <vanila> sfdsdfs, I picked out that PDF because it teaches how to do it
08:32:03 <sfdsdfs> vanila: but aren't there any examples showing how to do it using explicit alpha conversion and beta reduction?
08:32:39 <vanila> I'm showing you how to avoid explicit alpha conversion
08:32:58 <carter> sfdsdfs: explicit alpha beta is the leading cause of bugs
08:33:00 <vanila> we have techniques that avoid having to do that - which is good because it's the worst possible way to do things
08:33:09 <carter> literally the worst
08:33:14 <vanila> yeah
08:33:33 <carter> as in, you can no long treat evaluating pure expressions as pure
08:33:41 <carter> because you have to have a global pool of var names
08:34:46 <mroman_> carter: Works fine
08:34:50 <mroman_> It's not removed
08:34:52 <sfdsdfs> vanila: Yes, I understand.  But I still would like to know.  Otherwise, I won't be able to appreciate the mentioned solutions.
08:34:55 <carter> mroman_: :)
08:35:06 <carter> i know, but figured ited be more memorable to validate emperically
08:35:13 <carter> sfdsdfs: no, its really bad
08:35:15 <mroman_> http://codepad.org/RjKCwkFE
08:35:43 <mroman_> It's shockingly easy to write such stuff in Haskell
08:36:07 <mroman_> Makes you wonder why all the "morons" aren't using Haskell already ;)
08:36:21 <carter> mroman_: trick is to just build shit and take their money :P
08:36:30 <Fuuzetsu> mroman_: maybe they are!
08:36:43 <mroman_> Fuuzetsu: Touche
08:36:44 <carter> mroman_: i'm annoyed at all the insanely dumb engineering in adtech using scripting languages
08:36:57 <carter> so i'm actually starting to finally build an adtech bidder system in haskell
08:37:31 <carter> mroman_: i know people who are using 300-800 servers running ruby/js
08:37:42 <Fuuzetsu> what's adtech bidding, Google is not making it clear
08:37:47 <carter> just to serve ~ 15,000 requests a second with latency < 100ms
08:38:00 <carter> Fuuzetsu: theres auctions right before every ad is shown
08:38:01 <sfdsdfs> vanila: And where can I read about the whnf to nf rationale?  I know nothing about the termination thing that carter mentioned.  And noone of the papers I've seen explain it.
08:38:19 <carter> sfdsdfs: google strong normalization
08:38:26 <carter> and weak head normal form vs normal form
08:38:40 <carter> whnf is basically naive lazy / normal order evaluation
08:38:46 <carter> nf is one version of strict
08:41:08 <sfdsdfs> carter: I've read about whnf and nf, but I'd still like to know why all the papers use the same evaluation strategy while there are so many https://en.wikipedia.org/wiki/Evaluation_strategy
08:41:34 <carter> theres really only two
08:41:43 <carter> everything else is about is the arg treated as a value or pointer
08:41:50 <carter> which is easy to do on top
08:42:12 <carter> or a thunk
08:42:42 <sfdsdfs> where can I read about it?  lennart's and conor's papers assume that readers are already familiar with it.
08:42:50 <carter> read about which?
08:43:04 <carter> theres not much going on
08:43:09 <sfdsdfs> read about "easy to do on top"
08:43:14 <carter> hah
08:43:26 <carter> sfdsdfs: read the spj book on compiling a lazy language
08:43:29 <carter> plus a compiler book or so :)
08:43:38 <sfdsdfs> implementing functional languages?
08:43:42 <carter> sure
08:43:47 <carter> idk
08:43:58 <carter> sfdsdfs: do you undresand how pointers work?
08:44:07 <carter> and how compilers use registers and heaps and things?
08:44:21 <sfdsdfs> no
08:45:34 <carter> sfdsdfs: whats your current CS background / level
08:45:56 <sfdsdfs> I started to read spj's book but got overwhelmed.  I need something that explains each of the mentioned things in detail.
08:46:09 <sfdsdfs> I'm self-taught, so I'm not sure.
08:46:19 <mroman_> http://codepad.org/j7nq2Umq @real fibonacci
08:46:34 <mroman_> this at least seems fairly quick
08:46:45 <mroman_> in theory it should use constant space
08:47:05 <mroman_> if an int is of constant size
08:47:14 <mroman_> which it is assumingly not if you use unbounded
08:47:31 <sfdsdfs> carter: I (can) understand the mentioned papers, but I always have questions about each design decision.
08:47:32 <pjdelport> Int is constant size (Integer isn't)
08:47:45 <vanila> sfdsdfs, what do you want to learn?
08:48:08 <carter> vanila: i'll stop interjecting :)
08:48:45 <sfdsdfs> vanila: currently, I'd like to learn all (most of) the ways to implement a LC evaluator in haskell.
08:48:47 <vanila> carter, no what you said is great too!
08:49:01 <carter> sfdsdfs: ahh, thats a 3 linear :)
08:49:13 <vanila> sfdsdfs, figure 4 of the PDF i linked teaches how to do this in a good way
08:49:18 <carter> you'll just have 3-40  3 liners :)
08:49:30 <carter> HOAS style is also neat
08:49:32 <vanila> youre welcome to ask about it if you're interested
08:49:35 <carter> harder to pretty print it
08:49:41 <mroman_> > take 10 $ iterate (\(a,b) -> ((a+b),a)) (1,1)
08:49:43 <lambdabot>  [(1,1),(2,1),(3,2),(5,3),(8,5),(13,8),(21,13),(34,21),(55,34),(89,55)]
08:49:59 <sfdsdfs> hoas is also faster according to lennart's simple benchmark
08:50:13 <carter> faster aint the problem
08:50:21 <carter> you can't pattern match on lambdas
08:50:44 <vanila> it's efficient but that's not what I think it's valuable to learn
08:50:51 <vanila> s/what/why/
08:51:38 <Fuuzetsu> :t \x y -> and (zipWith (==) x y) :: Eq b => [b] -> [b] -> Bool
08:51:39 <lambdabot>     Couldn't match expected type ‘[b2] -> [b2] -> Bool’
08:51:39 <lambdabot>                 with actual type ‘Bool’
08:51:39 <lambdabot>     Possible cause: ‘and’ is applied to too many arguments
08:51:50 <Fuuzetsu> :t \x y -> and (zipWith (==) x y)
08:51:51 <lambdabot> Eq b => [b] -> [b] -> Bool
08:52:17 <Fuuzetsu> isn't the above just == specialised over []?
08:53:57 <MP2E> > liftA2 (==) [1,2,3] [1,5,4]
08:53:58 <lambdabot>  [True,False,False,False,False,False,False,False,False]
08:54:07 <MP2E> oops :P
08:54:35 <Fuuzetsu> ?
08:55:24 <carter> YAY, new hlint + new haskell src ext == i can run hlint on my codes
08:55:55 <assia_t> does anyone know how to install hdevtools with GHC 7.8?
08:56:17 <Fuuzetsu> assia_t: get the patches from the GitHub repo, there's a big issue
08:56:41 <Fuuzetsu> https://github.com/bitc/hdevtools/issues/24
08:56:50 <assia_t> Thanks
08:58:13 <pjdelport> > liftA2 (==) (ZipList [1,2,3]) (ZipList [1,5,4])
08:58:14 <lambdabot>  ZipList {getZipList = [True,False,False]}
08:58:19 <sfdsdfs> vanila: okay, I'll look into it.  but iirc they don't explain why they use de bruijn indices not naive substitution or the barendregt convention or hoas.  I'm also not aware of an example demonstrating strict evaluation.
08:58:36 <vanila> sfdsdfs, I've explained why
08:59:04 <SwashBuckla> how might you bunch [1,2,3,4,5] into groups of 3?
08:59:36 <SwashBuckla> I have tried using groupBy but I don't see what to use for the grouping function
08:59:45 <vanila> sfdsdfs, lambda terms are defined up to alpha-conversion, de bruijn indices have this baked in so that you don't need to worry about it
09:00:17 <gfixler> SwashBuckla: like [[1,2,3],[4,5]], or [[1,2,3],[2,3,4],[3,4,5]]?
09:00:31 <SwashBuckla> both!
09:00:38 <SwashBuckla> would be cool to see either of those
09:00:45 <vanila> sfdsdfs, using the terrible idea of strings to represent bound variables requires a very difficult capture-avoiding-substitution if you want to reduce under binders - we know better ways now
09:00:59 <sfdsdfs> vanila: other solutions don't have this problem either, iiuc.
09:01:05 <vanila> sfdsdfs, for strict evaluation you would use a monadic interpreter
09:01:11 <gfixler> > zip [1,2,3,4,5] (tail . tail . tail $ [1,2,3,4,5])
09:01:12 <lambdabot>  [(1,4),(2,5)]
09:01:13 <vanila> sfdsdfs, what other solutions?
09:01:16 <gfixler> doh
09:01:26 <sfdsdfs> vanila: hoas, etc.
09:01:39 <Fuuzetsu> SwashBuckla: chunksOf
09:01:40 <gfixler> > zip3 [1,2,3,4,5] (tail [1,2,3,4,5]) (tail $ tail [1,2,3,4,5])
09:01:41 <lambdabot>  [(1,2,3),(2,3,4),(3,4,5)]
09:01:44 <Fuuzetsu> :t chunksOf
09:01:45 <lambdabot> Int -> [e] -> [[e]]
09:01:48 <vanila> sfdsdfs, Have you looked at the PDF I linked? I don't think i can help you if you ignore my advice
09:01:49 <gfixler> or chunksOf :)
09:01:53 <Fuuzetsu> > chunksOf 3 [1 .. 5]
09:01:56 <lambdabot>  [[1,2,3],[4,5]]
09:01:59 <sfdsdfs> vanila: I'm looking.
09:02:05 <gfixler> Fuuzetsu: where's that hiding?
09:02:13 <Fuuzetsu> split package I think?
09:02:16 <gfixler> ah, Data.List.Split
09:02:24 <gfixler> yeah, I don't have that
09:02:24 <vanila> it uses HOAS for reflective evaluation and de bruijn syntax for quotation
09:02:28 <gfixler> (old GHC)
09:02:38 <Fuuzetsu> pretty sure it compiles with a potato
09:02:42 <SwashBuckla> :D
09:03:23 <sfdsdfs> vanila: okay, I'll read the paper and ask questions later.  regarding the monadic evaluator, could you elaborate?  I'm not familiar with this at all.
09:03:34 <vanila> sfdsdfs, you don't need to read the whole paper, just figure 4
09:05:00 <vanila> sfdsdfs, to evalute the argument before applying a function you could do something like this: do xval <- x ; fval <- f ; apply fval xval -- with the appropriate monad
09:06:42 <sfdsdfs> vanila: does the xval <- x line force the argument to be computed?
09:06:59 <sfdsdfs> also, why not use seq?  or is it a hack?
09:08:30 <Yrarr> Hey, is there any way to change the expression under the Stable Pointer, while preserving the address ?
09:10:54 <carter> Yrarr: use an ioref as your value :)
09:11:08 <Yrarr> ok, thanks
09:11:40 <carter> or some other ref like thingy
09:13:44 <pjdelport> sfdsdfs: It depends on the monadic type in question
09:15:25 <bmuk> shachaf: Sorry for leaving so abruptly last night. I would still like to hear about the matrix example if you aren't busy.
09:24:56 <Fuuzetsu>                     _ -> error "can't happen"
09:25:01 <Fuuzetsu> can't wait for it to happen ;_;
09:26:03 <pjdelport>  _ -> error "can't happen™"
09:26:44 <Fuuzetsu> ‘impossible happened!’ in GHC happens far too often…
09:27:12 <pjdelport> There should be impossible = error ... in Prelude or somewhere
09:27:24 <pjdelport> So you can just say: _ -> impossible
09:27:46 <superme> hi I'm deriving show but I need to override a part of the pattern
09:27:59 <superme> is it possible to do so
09:28:17 <Fuuzetsu> pjdelport: that's less useful than error because you can't put in a message when it inevitably gets entered
09:28:35 <Fuuzetsu> superme: no, if you want a custom instance then write a custom instance
09:28:42 <Fuuzetsu> maybe you want pretty-printing instead?
09:28:59 <pjdelport> Fuuzetsu: I know; i just like the look of "... = impossible" :)
09:29:03 <superme> I need that for aeson also
09:29:18 <Fuuzetsu> pjdelport: impossible = impossible for the best definition
09:29:34 <pjdelport> Fuuzetsu: Indeed!
09:29:41 <bmuk> :t error
09:29:42 <lambdabot> [Char] -> a
09:29:44 <Fuuzetsu> hm, then we could ‘fix impossible’
09:29:50 <etandel> lol
09:30:07 * hackagebot binary-list 0.3.2.1 - Lists of size length a power of two.  http://hackage.haskell.org/package/binary-list-0.3.2.1 (DanielDiaz)
09:30:08 <pjdelport> Fuuzetsu: Even better, impossible = error impossible
09:31:34 <bmuk> Is there a way you could make a function that passess a string to error? impossible :: String -> a won't compile, I don't think
09:32:21 <Fuuzetsu> bmuk: yes, simply myfunction = error ∎
09:32:38 <Fuuzetsu> ;^)
09:33:23 <etandel> mission = error; impossible = mission impossible
09:33:46 <Fuuzetsu> that won't compile
09:34:05 <bmuk> Fuuzetsu so you could therefore say _ -> impossible "won't happen"
09:34:18 <bmuk> that is a tad redundant though
09:35:00 <Fuuzetsu> unsafePerformIO $ launchMissiles >> putStrLn "there appears to be a problem"
09:35:15 <triliyn> Fuuzetsu: couldn't it work if impossible :: String?
09:35:46 <Fuuzetsu> hm, maybe
09:35:51 <Fuuzetsu> I think I misread that
09:36:12 <triliyn> It's just fix error I think
09:36:16 <Fuuzetsu> yeah
09:40:08 * hackagebot stylish-haskell 0.5.11.0 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.5.11.0 (JasperVanDerJeugt)
09:42:06 <albeit> Is there a clean way to do [(a,b)] -> [(f a, b)]?
09:42:48 <bennofs> :t map (first pure)
09:42:50 <lambdabot> Applicative f => [(b, d)] -> [(f b, d)]
09:44:07 <albeit> Oh shoot realized I was doing the types wrong, supposed to be (a -> c) -> [(a,b)] -> [(c,b)]
09:44:44 <albeit> :t first
09:44:48 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
09:45:37 <pjdelport> :t map . first
09:45:38 <lambdabot> (b -> c) -> [(b, d)] -> [(c, d)]
09:46:47 <pjdelport> :t map . lmap
09:46:48 <lambdabot> Profunctor p => (a -> b) -> [p b c] -> [p a c]
09:47:22 <bennofs> :t over (mapped._1)
09:47:23 <lambdabot> (Field1 a b a1 b1, Functor f) => (a1 -> b1) -> f a -> f b
09:48:00 <pjdelport> :t map . Data.Bifunctor.first
09:48:01 <lambdabot> Bifunctor p => (a -> b) -> [p a c] -> [p b c]
09:48:04 <pjdelport> That's better
09:48:55 <gdoteof_> if i wanted to do "ps aux | grep ... " but in haskell rather embedding bash, would i use System.Linxu.Proc.procGetAllProcessStatus ?
09:49:30 <Fuuzetsu> gdoteof_: look at process package
09:49:33 <bennofs> :t map . ((. swap) . (swap .) . fmap)
09:49:34 <lambdabot> (a -> b) -> [(a, a1)] -> [(b, a1)]
09:49:55 <gdoteof_> Fuuzetsu: System.Process ?
09:49:59 <Fuuzetsu> sure
09:50:02 <NikolajK> I have a main::IO (). What happens if I go to ghci and enter main?
09:50:17 <NikolajK> (I mean I know what happens, it doesn't end any computation - but why?)
09:50:19 <gdoteof_> Fuuzetsu: yeah I am looking there.. i only see how to run external commands
09:50:35 <Fuuzetsu> gdoteof_: ???
09:50:44 <Fuuzetsu> that's what you want, ps then grep
09:51:09 <gdoteof_> Fuuzetsu: that's not what I want.  I want to not use ps then grep (at least potentially)
09:51:36 <gdoteof_> for example, if i wanted to list the contents of a directory.. i could go createProcess (proc "ls" [])
09:51:47 <gdoteof_> or, i could do System.Directory.getDirectoryContents
09:52:00 <Fuuzetsu> OK, then System.Linux.Proc might be good
09:52:03 <nshepperd> @hoogle a b c -> a (p b d) (p c d)
09:52:05 <albeit> :t map (first digitToInt)
09:52:05 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
09:52:05 <lambdabot> Control.Arrow left :: ArrowChoice a => a b c -> a (Either b d) (Either c d)
09:52:05 <lambdabot> Control.Arrow leftApp :: ArrowApply a => a b c -> a (Either b d) (Either c d)
09:52:06 <lambdabot> [(Char, d)] -> [(Int, d)]
09:52:15 <gdoteof_> and I am looking for more the latter type of thing.  I will fall abck on ps|grep
09:52:19 <gdoteof_> gdoteof_: thanks
09:55:10 * hackagebot accelerate-utility 0.0 - Utility functions for the Accelerate framework  http://hackage.haskell.org/package/accelerate-utility-0.0 (HenningThielemann)
09:57:46 <nshepperd> oh, of course there's no general `first` for a bifunctor and arrow. that would be silly
09:58:59 <nshepperd> because any State arrow would let you save the value and escape it from its bifunctor box
10:00:11 * hackagebot accelerate-arithmetic 0.0 - Linear algebra and interpolation using the Accelerate framework  http://hackage.haskell.org/package/accelerate-arithmetic-0.0 (HenningThielemann)
10:05:11 * hackagebot patch-image 0.1 - Compose a big image from overlapping parts  http://hackage.haskell.org/package/patch-image-0.1 (HenningThielemann)
10:05:38 <vlatkoB> Is there a package with localized TimeLocales for Date.Time?
10:07:59 <statusfailed> What's an example of something I can do with a Monad but not an Applicative?
10:09:14 <statusfailed> well I guess join
10:09:45 <pjdelport> statusfailed: join is what Monad adds on top of Applicative, yes.
10:09:55 <pjdelport> (semantically)
10:10:04 <statusfailed> I'm trying to think of a practical example
10:10:12 * hackagebot patch-image 0.1.0.1 - Compose a big image from overlapping parts  http://hackage.haskell.org/package/patch-image-0.1.0.1 (HenningThielemann)
10:10:12 <MP2E> say you're writing an interpreter and you come up to an if statement, if you were parsing it with applicative both the true and false statements would be evaluated regardless of which one is used in the end. With a monad, only the result would be computed
10:10:46 <statusfailed> MP2E: can you pseudocode me? sorry :)
10:12:47 <pjdelport> statusfailed: An intuitive view with IO, for example, is that Applicative only lets you combine *independent* IO actions, like (++) <$> getLine <*> getLine, or prompt p = putStrLn p *> getLine
10:13:41 <pjdelport> statusfailed: Whenever you construct an IO action using the result of another IO action, like: join (putStrLn <$> getLine)
10:13:51 <pjdelport> then you must use join
10:14:51 <statusfailed> pjdelport: ah I think that clicked
10:14:52 <pjdelport> In other words, putStrLn <$> getLine can only give you IO (IO ()): you have to run the "outer" getLine IO action to get the string to construct the "inner" putStrLn IO action with.
10:14:56 <statusfailed> Yes it did
10:15:00 <statusfailed> thanks :)
10:15:10 <statusfailed> it clicked so much I feel stupid
10:15:11 <statusfailed> whoops
10:15:12 <MP2E> awesome, because an interpreter example in pseudocode was going to take a few minutes x.x
10:15:19 <statusfailed> MP2E: haha, sorry!!
10:15:20 <pjdelport> And join merges the structure (that is, effects) of the two layers of IO actions together into one.
10:15:24 <statusfailed> On the plus side I get your example now :p
10:16:54 <MP2E> :> Another great way of thinking about Applicative vs Monad is parallel computation vs sequential. Note the applicative isn't necessarily executed in parallel.. but each action is independent, like in parallel computations
10:18:01 <pjdelport> Right, but remember that monads morally just as parallel as applicative functors, in that sense.
10:18:04 <statusfailed> MP2E: yeah, that's actually kinda what led me to this question- I was thinking of applicative's <*> as sequencing, but I couldn't quite see the "parallelism" of >>=
10:18:18 <statusfailed> pjdelport: right
10:18:37 <MP2E> ah I see what you mean
10:18:44 <MP2E> I'd never thought of that before :P
10:18:45 <pjdelport> It's just join that lets you do additional things.
10:21:25 <augustl> random q from uninformed JVM dev.. Does haskell have any sort of run-time, JIT, etc, or does it compile to machine code?
10:21:41 <pjdelport> augustl: GHC compiles to machine code.
10:22:33 <pjdelport> Other Haskell implementations might use JIT compilation, but i'm not aware of any major ones.
10:22:41 <MP2E> it compiles to machine code, but it is linked to a runtime that handles garbage collection and IO. There is the runhaskell command if you want to run a source file in an interpreted manner and there's a REPL, GHCi that you can use to test/prototype functions in
10:22:45 <pjdelport> Google suggests https://github.com/nominolo/lambdachine though
10:23:08 <augustl> pjdelport: ah, good to know. Various haskell impls are more different than, say, OpenJDK and Oracle Java, it sounds like :)
10:23:17 <wz1000> augustl: Haskell the language can compile to C and JavaScript too, but GHC, the major implementation of Haskell compiles to machine code.
10:24:02 <augustl> the reason I'm asking is that I'm looking for an alternative to the JVM where I'm confortable writing Clojure. I'm gonna write something for sandstorm.io, so low footprint and super-fast start-up times is important.
10:24:04 <phaazon> hm, looks like hackagedb still doesn’t outputs haddock documentation :/
10:24:10 <phaazon> output*
10:24:10 <pjdelport> augustl: Definitely; Haskell implementations vary a *lot*. It's a bit of a laboratory language, after all.
10:24:14 <pjdelport> There are probably Haskell implementations for the JVM.
10:24:48 <mauke_> anything has super-fast start-up compared to java
10:27:07 <augustl> is there a de facto RPC stack for haskell? Will be wanting to support both HTTP and cap'n proto RPC
10:27:16 <MitchellSalad> Hello Haskell people, I'm about to accept a job offer to work on an Erlang stack. Should I be afraid?
10:27:37 <pjdelport> MitchellSalad: Depends more on the job than the language, i'm sure.!
10:27:50 <stew> sounds like a dynamic environment
10:27:58 * MitchellSalad crickets
10:28:11 <zomg> MitchellSalad: I think it would probably be interesting unless you have some reason to be afraid of it =)
10:29:04 <MitchellSalad> i'm just afraid to leave my types... my precious types...
10:29:15 <MP2E> augustl: haven't used an RPC framework myself but http://www.haskell.org/haskellwiki/Web/Libraries/RPC_and_Services is a good reference
10:29:17 <zomg> <- javascript day job
10:29:20 <zomg> erlang can't be bad
10:29:20 <zomg> :p
10:29:23 <MitchellSalad> :)
10:29:24 <augustl> MP2E: thanks
10:29:41 <augustl> MitchellSalad: currently using Groovy, pls send help
10:30:00 <MitchellSalad> LOL, groovy. I have PTSD from that abomination
10:30:17 <MitchellSalad> my coworkers went nuts with its "reflection"
10:30:23 <MitchellSalad> and made some delicious spaghetti
10:30:28 <MitchellSalad> then i promptly quit my job
10:30:55 <MitchellSalad> sorry man :(
10:31:13 <augustl> MP2E: is there any jit-like behaviour in the run-time part of GHC? Does it warm up, get faster over time, etc? Or is it just a plain old GC environment?
10:31:51 <augustl> MitchellSalad: at least the stack is sensible, no frameworks etc, and I tend to use java libs instead of crazy groovy idiomatic magic libs ;)
10:31:57 <geekosaur> why would there be jit? it's not applicable to compiled code. (ghci/runghc has neither JIT nor any other kind of optimization)
10:32:33 <mitchty> my day job entails lots of c and ruby, soon to be python and c, and perl ungh
10:32:53 <mauke_> s/ungh/yay/
10:33:34 <mitchty> its converting most of that perl to python so not too bad, perl over 100 lines tends to make me nervous
10:33:36 <mauke> augustl: the runtime does GC and IO and threads
10:33:45 <mauke> mitchty: that makes me sad
10:33:50 <cschneid> say I want to make an infinite list of powers of 2.  Obviously iterate does it. But how do I formulate it with an unfold? I have this: `unfoldr (\x -> Just (x, (x * 2))) 1` which apparently is strict?
10:33:54 <mitchty> never used groovy, whats so bad with it?
10:34:08 <mauke> at least perl can detect mistyped variables at compile time
10:34:31 <mitchty> mauke: heh, why? i know perl really well but to be honest prefer ruby/python over it for most tasks, just my opinion
10:34:46 <mauke> perl has good scoping
10:34:59 <mauke> > unfoldr (\x -> Just (x, (x * 2))) 1
10:35:01 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
10:35:03 <augustl> I'm a bit embarrassed that I got #haskell to talk about dynamic langs and Groovy the first time I'm in here :)
10:35:06 <mauke> looks lazy enough
10:35:10 <augustl> mauke: sounds simple enough :)
10:35:20 <mauke> > take 5 $ unfoldr (\x -> Just (x, (x * 2))) 1
10:35:21 <lambdabot>  [1,2,4,8,16]
10:35:47 <mitchty> augustl: its all your fault! but honestly i bet most people don't use haskell full time here, least not yet... I'm working on it
10:35:49 <mauke> augustl: the m:n threading part is probably not that simple
10:36:13 <cschneid> mauke: ohh, I screwed up in ghci and didn't assign it to a name, so it attempted to print. Lol
10:36:35 <cschneid> mauke: thanks
10:36:36 <Sawny> Is it possible to short this down even more? "fac x = x * fac (x-1)". I'm thinking about curried functions, something like "fac = fac (x-1) *". But I get parse error.
10:37:29 <Sawny> Full implementation: fac :: Int -> Int
10:37:29 <Sawny>  \n fac 1 = 1
10:37:29 <Sawny>  \n fac x = fac (x-1) * x)
10:37:34 <mauke> @pl fac x = x * fac (x-1)
10:37:35 <lambdabot> fac = fix (ap (*) . (. subtract 1))
10:37:51 <mauke> @pl \x -> x * fac (x-1)
10:37:52 <lambdabot> ap (*) (fac . subtract 1)
10:38:13 <mauke> Sawny: fac x = product [2 .. x]
10:38:42 <Sawny> yeah, but I want/need to use recursion for this example
10:38:51 <profil> Hey guys, some time ago I saw a visual explanation of recursiveness in haskell, there was an expression and when you pressed the expression they expanded. I think I saw it on /r/haskell, I would like to show that to some friends, does anyone remember the url?
10:39:06 <Sawny> want to make it as short as possible, still using recursion
10:39:31 <MitchellSalad> was it lambda pop?
10:39:49 <eriksensei> http://chrisuehlinger.com/LambdaBubblePop/
10:39:58 <profil> MitchellSalad, eriksensei: yeah, thanks guys! :)
10:40:15 <eriksensei> sure, enjoy your popping :)
10:40:30 <MitchellSalad> pop those terms
10:40:38 <kludgy2> eriksensei: omg that is brilliant!
10:41:31 <eriksensei> kludgy2: oh, well thank you, never thought i'd hear that on #haskell :)
10:43:51 <kludgy2> eriksensei: I am all about clear, engaging interactions.. it's fun to pop the terms :)
10:45:21 <eriksensei> this one's a bit like pringles though; once you pop... it's just so satisfying!
10:46:01 <hexagoxel> LambdaBubblePop doesn't do sharing though :(
10:46:43 <eriksensei> well, all the more bubbles to pop!
10:47:43 <hexagoxel> but, but, the double and triple and quadruple pops..
10:48:47 <eriksensei> oh goodness, i hadn't thought of that. :O
10:49:12 <MP2E> combo pops!
10:49:41 <eriksensei> perhaps this could be made into some sort of tetris-like game?
10:51:10 <kludgy2> eriksensei: Yes there is crazy game potential here.
10:54:01 <eriksensei> kludgy2: would be cool to make it massively multi-player as well, while we're at it
10:55:54 <MitchellSalad> you guys should also throw in some procedural generation, cause it's all the rage
10:58:09 <eriksensei> MitchellSalad: does that have anything to do with proc notation? i just read about that 10 minutes ago...
10:59:07 <geekosaur> do notation is quasi-"procedural". proc notation has to do with Arrows
10:59:22 <MitchellSalad> no, haha. I'm just saying there's a dearth of massively multiplayer procedurally generated lambda pop tetris clones on the market
11:00:02 <MP2E> Procedurally generated stuff is awesome
11:00:13 <MP2E> the replay value is almost infinite! well, if the game is good :P
11:00:24 <davidthomas> MP2E: works in Nethack, anyway
11:02:19 <eriksensei> MitchellSalad: ahh, ok, thanks for the clarification :)
11:02:42 <yyttr3> Is there a way to change the look and feel of a GTK (gtk2hs) application programmatically?
11:02:57 <yyttr3> I just need to find some documentation, then I could find the gtk2hs bindings
11:05:01 <XniX23> are arrows more powerful than monads? i mean are they more general?
11:05:17 * hackagebot persistent 2.0.3 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-2.0.3 (GregWeber)
11:05:19 * hackagebot persistent-mongoDB 2.0.3 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-2.0.3 (GregWeber)
11:05:21 * hackagebot persistent-mysql 2.0.3 - Backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-2.0.3 (GregWeber)
11:05:23 * hackagebot persistent-postgresql 2.0.3 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-2.0.3 (GregWeber)
11:05:25 * hackagebot persistent-sqlite 2.0.3 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-2.0.3 (GregWeber)
11:07:25 <eitan_chatav> every Kleisli category is an Arrow, so, yes Arrow is more general than Monad
11:07:45 <geekosaur> define "more general"
11:08:11 <geekosaur> @google monads meticulous promiscuous
11:08:12 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/papers/arrows-and-idioms/arrows-and-idioms.pdf
11:08:13 <lambdabot> Title: Idioms are oblivious, arrows are meticulous, monads are promiscuous
11:08:38 <augustl> does haskell have a story for "local mutation" - i.e. a function that mutates some bytes, but returns those bytes represented as an immutable type?
11:08:44 <geekosaur> gaining generality in one dimension loses it in others, hence applicative ("idioms") vs. arrows vs. monads
11:09:16 <eitan_chatav> applicative and monad are more directly comparable since they have the same kind signature
11:09:42 <geekosaur> and yet applicative grew out of arrows in some sense :)
11:10:12 <geekosaur> (very roughly, half of arrows generalizes to applicatives, and the other half to Control.Category)
11:10:12 <eitan_chatav> arrow is to profunctor as monad is to functor (almost)
11:10:27 * hackagebot persistent-template 2.0.3 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-2.0.3 (GregWeber)
11:10:28 <slomo> geekosaur: ST monad maybe?
11:10:41 <MitchellSalad> you mean augustl: ^
11:11:25 <augustl> trying to figure out if cap'n proto and haskell can be friends
11:11:38 <augustl> cap'n proto loves bytes and mutation..
11:11:48 <XniX23> eitan_chatav, that would mean that profunctor is more general than arrow, since functor is more general than monad
11:12:15 <eitan_chatav> XniX23: yes.
11:15:18 * hackagebot pg-harness 0.1.0 - REST service for creating temporary PostgreSQL databases  http://hackage.haskell.org/package/pg-harness-0.1.0 (BardurArantsson)
11:19:53 <Haskellfant> i'm looking for some resources on how to implement frp from scratch to get an understanding of it. so far all resources i've found only describe how to use netwire/banana/… but i'd like to learn how those actually work
11:23:29 <conal> Haskellfant: http://conal.net/papers/plilpalp98/ might help
11:23:52 <Haskellfant> conal: thx i'll take a look
11:24:37 <conal> Haskellfant: enjoy!
11:25:41 <danilo2> Hello! I've got a big Haskell problem and I failed to write a simple typeclass. I'm wondering if is it possible to do in current GHC version. I would be very, very thankful if somebody could look at it here: http://stackoverflow.com/questions/25854072/injective-type-families-in-haskell
11:26:00 <leeyungso> .hello, I would like to know if someone could help me to prove the following lemma: add (Sx) y = S(add x y) with add = { add Z x = x and add x Sy = S(add x y )}
11:26:21 <leeyungso> or at least give me hints please
11:28:20 <leeyungso> .hello, I would like to know if someone could help me to prove the following lemma: add (Sx) y = S(add x y) with add = { add Z x = x and add x Sy = S(add x y )}
11:28:21 <leeyungso> or at least give me hints please
11:28:59 <leeyungso> can you read me?
11:29:33 <danilo2> leeyungso: yes
11:29:33 <mauke> I can read you, but is that Haskell?
11:29:36 <HeladoDeBrownie> I don't understand what notation you're using. Also, please don't repeat so quickly.
11:30:01 <leeyungso> HeladoDeBrownie: sorry I wasn't sure that the message was sent
11:30:20 * hackagebot accelerate-cuda 0.15.0.0 - Accelerate backend for NVIDIA GPUs  http://hackage.haskell.org/package/accelerate-cuda-0.15.0.0 (TrevorMcDonell)
11:30:22 * hackagebot accelerate-io 0.15.0.0 - Read and write Accelerate arrays in various formats  http://hackage.haskell.org/package/accelerate-io-0.15.0.0 (TrevorMcDonell)
11:30:23 <leeyungso> mauke: kind of, I am attending an evening class and they use an hybrid language
11:30:50 <leeyungso> but it's functional
11:31:23 <mauke> doesn't seem to be lazy
11:31:34 <mauke> and has weird tokenizing
11:32:55 <mauke> your definition of add is wrong or incomplete
11:33:09 <mauke> add (S x) Z doesn't match either clause
11:34:15 <mauke> I'm going to assume the first clause should be add x Z = x
11:35:11 <danilo2>  Hello! I've got a big Haskell problem and I failed to write a simple typeclass. I'm wondering if is it possible to do in current GHC version. I would be very, very thankful if somebody could look at it here: http://stackoverflow.com/questions/25854072/injective-type-families-in-haskell
11:37:00 <leeyungso> mauke: yeah that's the problem I have :/
11:38:22 <leeyungso> but they ask us to prove "For all Natural x, for all natural y ": add (S x) y = S(add x y )
11:38:39 <leeyungso> I am lost :(
11:38:57 <monochrom> may I see the original question on the web?
11:39:22 <mauke> ok, I think I can do it with add x Z = x
11:42:22 <leeyungso> mauke: how do you do?
11:42:50 <mauke> induction on y
11:43:36 * leeyungso cold sweat
11:43:48 <leeyungso> but there is two variables :o
11:44:16 <leeyungso> and the teacher said we can't use P[x, y]
11:44:19 <mauke> one can stay general
11:44:26 <mauke> what's P?
11:44:45 <leeyungso> a statement sorry
11:45:18 <leeyungso> he says that we prove that P[Z] holds then P[x] imply P[S x]
11:45:29 <leeyungso> and then conclusion
11:45:33 <leeyungso> is that correct?
11:45:44 <ad> leeyungso: yes
11:45:53 <monochrom> you won't be using P[x,y], don't worry
11:46:18 <mauke> I don't understand this notation
11:48:03 <monochrom> the notation says that we use a unary predicate, and do induction on one variable.
11:50:15 <leeyungso> so can I do:
11:50:41 <leeyungso> P[Z]: add (Sx) Z = S(x) holds obviously
11:51:04 <leeyungso> because S( plus x Z ) = S(x)
11:51:24 <mjrosenb> the intersection of #haskell and #perl is higher than I excected.
11:51:29 <leeyungso> then: we assume P[y] true and we want to show that P[y] -> P[Sy]
11:51:55 <leeyungso> we apply S( ) on both side
11:52:26 <leeyungso> and by P[y] we get: plus Sx Sy = S(S(plus x y))
11:52:36 <holymac> wow, haskell has a large user base
11:52:45 <leeyungso> oh sorry its add not plus
11:52:49 <leeyungso> ><
11:53:03 <leeyungso> holymac: I am enjoying this course so far
11:53:04 <joelteon> holymac: well, a larger proportion of haskell users are on IRC than other languages
11:53:23 <ad> leeyungso: seems correct
11:54:31 <ad> ad: you meant add Sx Sy = S(add Sx y)?
11:55:12 <leeyungso> ad: yeah exactly
11:55:24 <leeyungso> but can I "apply" S on both sides
11:55:27 <etandel> who logs this channel? is it lambdabot ?
11:58:04 <Intolerable1> im having some issues w/ lens' template haskell fields stuff
11:58:06 <acres> Hey. Does haskell lend itself to live coding and on the fly modification of applications, the way lisp does?
11:58:08 <monochrom> lambdabot doesn't. the topic has two log urls.
11:58:16 <Intolerable1> in particular the prefixes used for makeFields
11:59:15 <Intolerable1> if u have a type w/ a CamelCase name, the prefixes seem… odd
11:59:19 <yyttr3> having just discovered GADT's, why are these not apart of standard haskell?!
11:59:29 <dfsdfs> what's the complexity of 'max'? (O(n), I guess)  what's the complexity if I call it multiple times (on the initial list and its sublist)  Is it O(n) + O(m) ~ O(p)?
12:00:01 <holymac> what is haskell used for?
12:00:06 <johnw> holymac: just about everything
12:00:16 <HeladoDeBrownie> acres, in general: not especially. However, there are ways. And, with a slight change of intuition of how to do it, even more avenues open up.
12:00:39 <HeladoDeBrownie> acres, for example: Design a DSL in Haskell, and dynamically load *that*. That is possible and quite convenient in Haskell.
12:00:52 <monochrom> dfsdfs: max is binary. "max 4 3". do you want maximum instead? it's O(n)
12:01:03 <dfsdfs> yep, I meant maximum
12:01:06 <shachaf> monochrom: That sounds like O(log n) to me.
12:02:18 <holymac> isn't functional programming lambda calculus?
12:02:36 <monochrom> that may be oversimplifying
12:02:47 <Iceland_jack> not really
12:02:48 <monochrom> or overcomplicating
12:03:01 <dfsdfs> monochrom: what is the complexity of this? let xs = [1,2,3]; maximum xs; maximum $ tail xs; maximum $ tail $ tail xs  O(n^2)
12:03:26 <dfsdfs> ?
12:03:34 <monochrom> 3 times O(n).
12:03:38 <dfsdfs> ah
12:03:40 <scopedTV> dfsdfs: O(1) :)
12:03:42 <fizbin> Does anyone have a good example of using two states at once, say with StateT a (StateT b IO) () ?
12:04:00 <dfsdfs> scopedTV: What?
12:04:08 <fizbin> I'm trying to figure out how to stack my states and whether I really want that.
12:04:08 <shachaf> dfsdfs: Your list has three elements.
12:04:27 <scopedTV> dfsdfs: it's O(length xs)
12:04:31 <monochrom> they're playing on [1,2,3] being a fixed input
12:04:59 <etandel> monochrom: thx
12:05:11 <HeladoDeBrownie> fizbin, no, but a possible suggestion: if you're aware of your transformer stack containing two states, you might be able to combine them into one.
12:05:16 <bmuk> monochrom: is there a good resource I can read about algorithmic complexity in haskell?
12:05:23 * hackagebot derive 2.5.17 - A program and library to derive instances for data types  http://hackage.haskell.org/package/derive-2.5.17 (NeilMitchell)
12:05:47 <silver_> it's the same in any language
12:05:50 <monochrom> fizbin: I don't have a recommendation whether you should do it. but "get" gives you "a", "lift get" gives you "b". similarly for put.
12:06:13 <fizbin> monochrom: Thanks.
12:06:14 <scopedTV> I thought Purely Functional Data Structures had a section on complexity.
12:06:23 <monochrom> bmuk: I say that my http://www.vex.net/~trebla/haskell/lazy.xhtml is a good resource.
12:06:51 <bmuk> monochrom++
12:07:03 <bmuk> scopedTV++ that's on my reading list already :p
12:07:46 <fizbin> HeladoDeBrownie: Yeah, I could do two states at once, but I really want these two states to be separate - I've got an input object I gradually consume (and want to check that I've consumed it completely at the end) and an output object I'm twisting about as I consume the input object.
12:07:54 <dfsdfs> would it still be O(n) if I also call minimum for sublists?
12:09:18 <hexagoxel> fizbin: https://hackage.haskell.org/package/multistate
12:09:26 <Haskellfant> dfsdfs: getting a sublist should be O(n) and getting a minimum of this sublist is also O(n) so you get O(n) total
12:09:34 <Haskellfant> (ofc this can even be done in a single pass
12:09:38 <Haskellfant> )
12:09:43 <scopedTV> dfsdfs: I'm not sure what you mean exactly.
12:10:24 * hackagebot hoogle 4.2.35 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.35 (NeilMitchell)
12:10:37 <dfsdfs> scopedTV: let xs = [1,2,3]; minimum xs; maximum xs; let ys = tail xs; minimum ys; maximum ys; let zs = tail yz ...
12:10:46 <dfsdfs> ys*
12:10:49 <sinelaw> where's the "standard" EitherT?
12:10:58 <sinelaw> seems like there's a few versions
12:11:27 <scopedTV> dfsdfs: something like   f x = (minimum xs, maximum xs)  ?
12:11:35 <shergill> so haskell jit. is any progress being made on this? and/or making runtime code compilation more efficient?
12:11:41 <scopedTV>   f xs = (minimum xs, maximum xs)   rather
12:11:47 <monochrom> dfsdfs: each call to maximum/minimum recomputes again. not smart enough to save redundant work.
12:12:04 <scopedTV> dfsdfs: this is O(n), but unfortunately will also use O(n) memory most likely
12:12:24 <dfsdfs> okay
12:15:24 * hackagebot web-page 0.1.0 - Monoidally construct web pages  http://hackage.haskell.org/package/web-page-0.1.0 (ErtugrulSoeylemez)
12:16:05 <sinelaw> @where MaybeT
12:16:05 <lambdabot> I know nothing about maybet.
12:16:17 <scopedTV> @hoogle MaybeT
12:16:18 <lambdabot> Control.Monad.Trans.Maybe MaybeT :: m (Maybe a) -> MaybeT m a
12:16:18 <lambdabot> Control.Monad.Trans.Maybe newtype MaybeT m a
12:16:18 <lambdabot> package MaybeT
12:17:56 <Haskellfant> sinelaw: i only know the one from the either package
12:18:10 <sinelaw> ok
12:19:07 <HeladoDeBrownie> monochrom, wasn't there some package or something for fusing list folds?
12:19:38 <HeladoDeBrownie> (I wasn't paying attention to most of the conversation, just noticed the thing about not saving work)
12:20:23 <bmuk> What is the difference between hoogle and hayoo?
12:20:31 <sinelaw> Haskellfant, thanks, using that for now
12:21:08 <Haskellfant> bmuk: both help you find functions/packages. hoogle is a bit more intelligent when it comes to types but hayoo indexes more packages than the standard hoogle
12:21:26 <Haskellfant> fpcomplete has a hoogle instance that indexes a lot of packages https://www.fpcomplete.com/hoogle
12:23:35 <bmuk> Haskellfant: I have always just used hoogle, but I came across hayoo and I was confused as to the difference. Thank you
12:23:47 <Haskellfant> bmuk: i tend to stick to the fpcomplete hoogle
12:24:35 <sinelaw> when using monad transformers, I have this recurring pattern:
12:24:46 <sinelaw> do;  a <- f;  b <- a
12:25:02 <sinelaw> how to combine those two lines?
12:25:27 <Hafydd> Is that even valid syntax?
12:25:31 <hexagoxel> b <- join f
12:25:31 <scopedTV> @undo do { a <- f; b <- a }
12:25:32 <lambdabot> <unknown>.hs: 1: 22:Parse error: Last statement in a do-block must be an expression
12:25:39 <scopedTV> @undo do { a <- f; b <- a; return b }
12:25:39 <lambdabot> f >>= \ a -> a >>= \ b -> return b
12:25:55 <hexagoxel> :t join
12:25:56 <lambdabot> Monad m => m (m a) -> m a
12:26:39 <Hafydd> If it's a problem that arises when using monad tranformers, it might be solvable using `lift' as well.
12:26:50 <MagneticDuck> what should I use to force, say, getContents to not be lazy?
12:26:53 <sinelaw> Hafydd, what should I lift?
12:26:54 <MagneticDuck> deepseq stuff?
12:27:02 <MagneticDuck> or is there an easier solution
12:27:39 <Hafydd> sinelaw: it depends on the particular case.
12:27:54 <hexagoxel> Hafydd: but it _must_ be the same monad, right? so join will work
12:28:11 <sinelaw> MaybeT (State (Maybe Bool) Bool)
12:28:15 <sinelaw> as an example
12:28:34 <sinelaw> do; mb <- get; b <- mb; return b
12:28:45 <sinelaw> (obviously instead of return b something else happens)
12:28:51 <Hafydd> Yes, I suppose join will work just as well.
12:29:31 <MagneticDuck> anybody?
12:29:43 <sinelaw> do you mean: b <- join get?
12:30:03 <hexagoxel> do; mb <- get; b <- mb; return b === join get
12:30:08 <HeladoDeBrownie> MagneticDuck, something other than getContents, defined in terms of a proper streaming abstraction. See Pipes.Prelude for some examples.
12:30:50 <sinelaw> ok thank
12:30:58 <sinelaw> you :)
12:31:07 <Hafydd> That type doesn't seem right...
12:31:10 <MagneticDuck> I can't just have a function "IO String -> IO String" that caches a string to its EOF before returning it?
12:31:24 <Hafydd> Don't you mean MaybeT State (Maybe Bool) Bool?
12:31:30 <HeladoDeBrownie> MagneticDuck, not sure what you mean. Can you describe what that function would do?
12:31:43 <HeladoDeBrownie> MagneticDuck, oh, you want to read the *entire* string
12:31:49 <MagneticDuck> are you familiar with the "sponge" utility in linux?
12:31:52 <HeladoDeBrownie> That might be a bad idea: What if it's large?
12:31:53 <Hafydd> Er... MaybeT (State (Maybe Bool)) Bool.
12:31:54 <MagneticDuck> yes
12:32:02 <davidthomas> MagneticDuck: I think it just needs to be String -> IO String
12:32:10 <scopedTV> :t evaluate
12:32:11 <lambdabot> a -> IO a
12:32:19 <MagneticDuck> davidthomas: er, yeah
12:32:20 <scopedTV> MagneticDuck: ^
12:32:25 <MagneticDuck> kk thanks
12:32:27 <MagneticDuck> cool
12:32:38 <scopedTV> MagneticDuck: however, that evaluates to WHNF I guess
12:32:54 <scopedTV> MagneticDuck: so combine with deepseq
12:33:21 <davidthomas> scopedTV: Right, that's just WHNF - deepseq is the easy answer
12:34:18 <davidthomas> for a string in particular, you could also do something like seq (length s) (return s)
12:34:43 <roconnor> where can I find make?
12:35:03 <roconnor> oops
12:35:06 <roconnor> wrong channel
12:35:21 <michaelt> MagneticDuck: Data.Text.getContents will give you the whole text at one go.
12:35:57 <scopedTV> MagneticDuck: so combine with deepseq
12:36:03 <scopedTV> whoops
12:36:18 <Hafydd> sinelaw: you could achieve something equivalent in this case using: Just b <- get.
12:36:57 <holymac> i wanna get out of the mindset of a procedural mind set
12:36:58 <sinelaw> Hafydd, on Nothing it will do fail?
12:37:05 <Hafydd> sinelaw: yes.
12:37:07 <sinelaw> ok
12:37:45 <michaelt>  michaelt the Data.Text representation of the file will also be much more compact that the fully-evaluated String representation
12:37:58 <michaelt> MagneticDuck: rather ^^^
12:38:53 <slomo> is there already an Arbitrary instance for quickcheck that can generate String/Text with non-ascii characters?
12:40:14 <michaelt> slomo: there might be others but the testing material for the `text` package has such an instance ...
12:40:59 <DanielDiaz> hackage refuses to build the documentation for my package: http://hackage.haskell.org/package/binary-list-0.3.2.1 :( If you think I just have to wait more, the previous version does not have any build report either, and was uploaded 5 days ago: http://hackage.haskell.org/package/binary-list-0.3.2.0/reports Any idea?
12:41:12 <slomo> michaelt: thanks :)
12:41:12 <HeladoDeBrownie> holymac, are you familiar with function composition?
12:41:22 <holymac> yea
12:41:29 <michaelt> slomo: https://github.com/bos/text/blob/master/tests/Tests/QuickCheckUtils.hs I used it once for something
12:41:33 <Hafydd> sinelaw: or b <- maybe mzero return get
12:41:44 <holymac> HeladoDeBrownie: yeah
12:41:47 <Hafydd> Which works for all MonadPlus m => m instead of just Maybe.
12:42:31 <Hafydd> sinelaw: err, I mean: m >>= maybe mzero return
12:42:55 <sinelaw> Hafydd, heh
12:43:01 <Hafydd> Or maybe mzero return =<< m, if you prefer.
12:43:20 <HeladoDeBrownie> holymac, well even things that look procedural/sequential in Haskell are often compositions of some sort. Look at (>=>), for instance. That's just composition of specialized functions, and even though do notation looks sequential it can usually be translated into those terms.
12:43:21 <sinelaw> I think join was the most readable
12:43:40 <HeladoDeBrownie> @type (>=>)
12:43:41 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
12:43:43 <Hafydd> It would not work for, for example, EitherT, though.
12:43:54 <HeladoDeBrownie> holymac, does that make sense and help?
12:44:24 <Hafydd> For which you could use: maybe (left "failure") return =<< m.
12:45:48 <holymac> HeladoDeBrownie: that makes sense
12:46:52 <awestroke> why is the latest haskell-platform for ubuntu from early 2013? should I just get newest ghc and cabal instead?
12:47:03 <HeladoDeBrownie> awestroke, that's often what's done
12:47:31 <Jeanne-Kamikaze> you should also avoid packages from ubuntu's repositories
12:47:32 <HeladoDeBrownie> awestroke, note that you can still get the latest cabal even if you install an outdated cabal distro package, by using `cabal update && cabal install cabal-install`
12:48:24 <awestroke> Jeanne-Kamikaze: haskell-related packages or all software packages? ;)
12:48:35 <michaelt> awestroke: yes, just install the binary distribution from the ghc page locally and have done with it.  you can keep your old cabal to build a new one, if you have one
12:48:42 <monochrom> awestroke: https://www.haskell.org/platform/linux.html
12:48:49 <Jeanne-Kamikaze> haskell-related, but many packages are out of date or broken xD
12:49:14 <MagneticDuck> michaelt: cool
12:49:19 <monochrom> I use non-haskell stuff from ubuntu
12:49:20 <awestroke> michaelt: any advantage of building from source instead of installing a binary?
12:49:32 <monochrom> no advantage.
12:49:37 <HeladoDeBrownie> awestroke, I'd say don't do that unless you want to help develop the tool in question
12:49:38 <michaelt> you can only build from source with an existing ghc
12:49:44 <Jeanne-Kamikaze> you can go for a coffee in the meantime
12:50:03 <edwardk> @ask intolerable1 odd how?
12:50:03 <lambdabot> Consider it noted.
12:50:15 <monochrom> do not believe in the false dichotomy "ubuntu or build from source"
12:51:21 <monochrom> archlinux is about the only one catching up with current stable releases of Haskell software
12:51:45 <Jeanne-Kamikaze> archlinux is about the only one catching up with current stable releases of software
12:51:58 <bmuk> The 2014 haskell platform works fine on ubuntu and is really easy to install
12:52:13 <monochrom> but I do not even believe in getting Haskell software from any linux distro. not even archlinux.
12:52:39 <awestroke> Should I install the 2014 haskell platform or is there a way to get ghc and friends only, or is 2014 haskell platform just that?
12:52:55 <monochrom> haskell platform has ghc and a lot of libs.
12:53:02 <bmuk> monochrom: what about nixos?
12:53:17 <Jeanne-Kamikaze> I would get latest ghc and cabal, then cabal install all the way from there
12:53:32 <monochrom> if you want most of those libs, haskell platform. if you don't want most of those libs, just getting ghc (binary again) is also possible.
12:53:38 <awestroke> Jeanne-Kamikaze: that's what I want to do. What's the easiest way to do that?
12:53:54 <awestroke> can I install ghc-pkg with cabal?
12:54:03 <monochrom> no, it comes with ghc.
12:54:09 <bmuk> awestroke: The haskell platform has the added benefit that it is "batteries included" pretty much anything you want library-wise is already in there, and if it isn't cabal install doesn't have to build as many dependencies
12:54:14 <monochrom> ghc is at http://www.haskell.org/ghc/
12:54:36 <michaelt> ghc-pkg comes with ghc and ghci in the binary distribution from GHC hg
12:54:38 <michaelt> hq
12:54:40 <sinelaw> why do I get this error? (trying to use monad transformers for the first time)
12:54:40 <sinelaw> http://lpaste.net/111084
12:55:29 <michaelt> there are several step by step accounts of what to do awestroke
12:55:39 <geekosaur> sinelaw: Maybe is not MaybeT
12:56:50 <sinelaw> I know, but what am I supposed to do to take advantage of the MaybeT to skip checking Nothing on 'funcscope scope' ?
12:56:52 <geekosaur> perhaps you intended let ... = instead of <-
12:57:07 <sinelaw> geekosaur, I want to skip unpacking the maybe
12:57:11 <sinelaw> and have it fail if it's a Nothing
12:57:30 <geekosaur> then you need to use a MaybeT instead of Maybe there
12:58:09 <awestroke> hm, I'm running 32bit ubuntu though
12:59:32 <bmuk> awestroke: just make sure you download the x86 binaries
12:59:33 <michaelt> awestroke: here's one https://gist.github.com/yantonov/10083524 and another https://github.com/quchen/articles/blob/master/zero_to_local_ghc.md
12:59:46 <awestroke> michaelt: great, thanks
13:00:47 <monochrom> oh, yeah, Haskell Platform has only built a 64-bit binary for linux
13:09:08 <sinelaw> so what's the right way to process a value that contains a regular Maybe
13:09:11 <sinelaw> using monad transformers?
13:10:26 <geekosaur> sinelaw, there is no magic that does this for you. (granted, mtl these days defines the other ones as transformers over Identity, but I suspect rewriting Maybe that way would cause major compatibility problems)
13:10:29 * hackagebot cblrepo 0.12 - Tool to maintain a database of CABAL packages and their dependencies  http://hackage.haskell.org/package/cblrepo-0.12 (MagnusTherning)
13:10:55 <sinelaw> geekosaur, so the standard way is to use MaybeT values?
13:10:56 <geekosaur> for exaple `Just` and `Nothing` would no longer work
13:10:58 <geekosaur> yes
13:11:09 <geekosaur> you are looking for magic lifting, it does not exist in Haskell
13:11:34 <sinelaw> unpacking rather
13:12:08 <sinelaw> instead of this: do ; state <- get; case f state of Nothing -> ....
13:12:25 <sinelaw> I want: do ; state <- get; result <- f state
13:12:39 <sinelaw> f :: State -> Maybe X
13:13:04 <geekosaur> "it's good to want" people still trip over State -> state
13:13:34 <geekosaur> if you think you can come up with a language extension to do this sanely then I'm sure they'd welcome a patch
13:14:26 <BMeph_> You may even rate a footnote in the paper that will be written about it.... ;þ
13:15:18 <geekosaur> (worse, the obvious "automatic" hoisting would be MaybeT Identity, which still wouldn't match MaybeT (State whatever)
13:15:23 <sinelaw> nah, I think I'm not explaining myself correctly; not done reading about transformers so I'm probably just missing something basic here
13:16:03 <geekosaur> you're not missing anything and it's been a pain point in the past when mtl redid all the standalone monads as transformers over Identity. and there's still no reasonable way to deal with it
13:16:38 <geekosaur> (well, sort of the reverse there)
13:17:12 <geekosaur> but there is no language or compiler discernable relationship between Maybe and MaybeT, so it can't transform one to the other for you
13:21:24 <sinelaw> geekosaur, consider MaybeT IO ; getStuff :: IO (Maybe String) ; x <- MaybeT getStuff
13:21:45 <sinelaw> x will unpack the Maybe from the result of getStuff, no?
13:27:43 <Qfwfq> Anyone had any luck defining filter on sized/nat-indexed vectors?
13:35:21 <k00mi> Qfwfq: did you try doing it in a proper dependently-typed language?
13:36:27 <vanila> what type would it have?
13:36:43 <vanila> filter : (a -> Bool) -> Vec n a -> Vec m? a
13:37:04 <HeladoDeBrownie> You'd need some sort of relation between n and m, no?
13:37:15 <HeladoDeBrownie> (<=) at weakest
13:37:59 <Qfwfq> The type checker wants to be able to know m, though, so <= isn't strong enough.
13:38:06 <Mokosha_> anyone here familiar with the friday library?
13:38:08 <vanila> I don't see this being a good idea
13:38:12 <HeladoDeBrownie> Right, that's just one bound
13:38:25 <vanila> if you want filter the list data structure is probably the rght thing
13:38:45 <tommd> Mokosha_: I've committed some code to friday but I don't claim to really "know" it in that I don't follow all the types.
13:38:57 <tommd> Not without haddocks and some Whiskey.
13:39:53 <Qfwfq> vanila: You're right, I'm over-designing this. I want an n-ary cartesian product, and having a heterogenous length constraint on the outer container complicates the reduction.
13:40:05 <Mokosha_> tommd, I just started looking at it, and I was wondering if there was a way to generate values of type MaskedImage
13:40:06 * Qfwfq -> [a]
13:40:20 <Mokosha_> although now that I think of it, I think I can just create it directly with the constructor
13:41:04 <tommd> Mokosha_: 'MaskedImage' is a class, not a type.  Did I miss something?
13:41:21 <Mokosha_> er, yea... DelayedMask is what I want, I guess
13:41:42 <Qfwfq> k00mi: Dependent tuples (as in the Idris definition) are manageable with SingI, but I'm not going to bother.
13:42:03 <Mokosha_> basically, I need to exclude certain pixels from a histogram
13:42:22 <tommd> Mokosha_: See 'fromFunction'
13:42:28 <tommd> Also yes, the constructors
13:42:28 <k00mi> Qfwfq: in agda: http://www.cs.gunma-u.ac.jp/~hamana/Papers/pjind.pdf
13:42:52 <k00mi> Qfwfq: it would be a major pain to do it in haskell
13:43:49 <Mokosha_> tommd, 'fromFunction' defines it for every pixel... I want to be able to return 'Nothing'
13:44:15 <Qfwfq> k00mi: That final Agda definition is enviable.
13:44:18 <tommd> I think you're reduced to using the constructor.
13:44:32 <Mokosha_> yea, me too... thanks
13:44:39 <Mokosha_> verbalizing my problem made me realize the solution :P
13:47:13 <Qfwfq> k00mi, vanila, HeladoDeBrownie: Thanks, you've probably saved me a few hours of head-banging.
13:59:08 <k00mi> Qfwfq: what could work in haskell is to hide the length index
13:59:42 <k00mi> if you don't actually have to know anything about the length of the resulting Vec
14:00:36 <Qfwfq> I noticed that for the function I'm writing, the filter will always remove exactly one element. So specialisation would work. Operating on a span would work.
14:01:56 <lucky> Anyone familiar with Aeson/Lens can tell me why this is giving me a type error? http://lpaste.net/111087
14:02:39 <shachaf> lucky: What are the types of responseBody and key?
14:02:54 <shachaf> lucky: It sounds like you're using (^.) to "view" something that might not exist.
14:03:12 <shachaf> Oh, wait, I misread.
14:03:22 <shachaf> So back to my old question -- what are the types of everything.
14:04:12 <shachaf> Another question is what the type of s is.
14:04:31 <Qfwfq> I don't know the types, but I think '^. responseBody . _Just . key "BTC_NXT"' is more likely to work.
14:04:57 <Qfwfq> Assuming there's an AsValue instance for Value, as the name suggests.
14:05:12 <shachaf> That will almost certainly not work unless you have a Monoid instance and want mempty as the default value.
14:05:37 <lpaste_> amf pasted “parsing a files compressed body” at http://lpaste.net/7722569498510753792
14:05:48 <Qfwfq> Oh, right, I forgot the _Just semantics. The way my brain made it the result type isn't well defined.
14:05:51 <lucky> shachaf: responseBody :: ByteString, and "key :: AsValue t => Text -> Traversal' t Value"
14:05:58 <shachaf> lucky: And s?
14:06:16 <lucky> Maybe Value
14:06:48 <shachaf> OK. You're using (s ^. key "..."), but s :: Maybe Value
14:07:21 <lucky> I'm following the https://www.fpcomplete.com/user/tel/lens-aeson-traversals-prisms near the bottom
14:07:30 <shachaf> So maybe you want what Qfwfq said, i.e. (s [...] _Just . key "...")
14:07:42 <shachaf> But think about what the operator [...] should be.
14:07:50 <amf> my file format is ascii strings that surround gzipped data that could be in the gigabytes, is there a way to get parsec to decompress that data before handing it off to the custom parsing functions?
14:08:00 <shachaf> What should happen if s is Nothing, for instance? Or if the key doesn't exist?
14:08:38 <Qfwfq> Would 's <&> view $ key "..."' typecheck?
14:08:58 <shachaf> I don't know. Probably not.
14:09:13 <joseph07> amf: http://hackage.haskell.org/package/zlib-0.5.4.1/docs/Codec-Compression-GZip.html you can unzip before parsing
14:09:20 <augustl> is google the best place to find haskell packages? :)
14:09:57 <lucky> No instance for (Data.Monoid.Monoid Value) arising from a use of ‘_Just’ [...]
14:10:07 <Qfwfq> augustl: Hackage or (occasionally) GitHub search.
14:10:29 <amf> joseph07: the gzipped data is embedded in a file and will not start at the first byte
14:10:49 <shachaf> lucky: Yes, that's what I said would happen.
14:10:53 <Qfwfq> lucky: What're your intended semantics when a response body isn't parsed successfully?
14:10:59 <joseph07> amf: it looks like decompress just takes a bytestring
14:11:17 <augustl> Qfwfq: tnx
14:11:23 <lucky> Qfwfq: intended semantics?
14:11:32 <Qfwfq> What do you expect / want to happen?
14:11:47 <Qfwfq> lucky: Also, do you know what that last error meant?
14:11:58 <amf> joseph07: see http://lpaste.net/7722569498510753792 i need line 11 to do the decompress before handing it off to parseLines
14:12:02 <shachaf> There are two different ways this can fail here: decode could return Nothing, or it could succeed, but return something where the key you're looking for doesn't exist.
14:12:15 <lucky> don't care, and no.
14:12:24 <shachaf> lucky: Also, responseBody :: ByteString makes no sense.
14:12:45 <lucky> shachaf: it's the wreq library
14:13:03 <lucky> "The response body is a raw lazy ByteString."
14:13:19 <Qfwfq> You're operating on a 'Response', though.
14:13:40 <lucky> I'm completely lost now, sorry
14:13:42 <shachaf> lucky: responseBody isn't a ByteString, though. :-(
14:13:47 <shachaf> I just looked it up in wreq.
14:14:25 <joseph07> amf: probably you should parse the file as a bytestring rather than a string, since it contains binary data
14:15:20 <lucky> shachaf: the wreq bit isn't giving me problems though, it compiles fine
14:15:38 <lucky> as does decode on it
14:15:54 <shachaf> OK, but I asked you what the type is and you said something that makes no sense, which makes it difficult to help you.
14:16:04 <shachaf> But I'll ignore responseBody.
14:16:08 <amf> joseph07: im already doing that, i have BL.readFile as the reader
14:16:17 <lucky> Well I'm telling you what the tutorial says :/ sorry
14:16:31 <shachaf> You still didn't answer my question. What do you want to do when one of the two things that could fail fails?
14:16:37 <shachaf> What tutorial?
14:16:38 <Qfwfq> shachaf: The type of 'get' means the parameter of 'Response' is 'Lazy.ByteString', so 'responseBody' gets a LBS.
14:16:41 <lucky> I guess it's inaccurate
14:16:51 <shachaf> Qfwfq: responseBody is a lens.
14:17:02 <Qfwfq> Yes, and a Getter in the context of view.
14:17:07 <lucky> http://www.serpentine.com/wreq/tutorial.html and https://www.fpcomplete.com/user/tel/lens-aeson-traversals-prisms
14:17:24 <shachaf> Yes. It's not a ByteString.
14:17:25 <lucky> i give up, i can't answer your questions because i don't understand them, sorry
14:17:35 <shachaf> lucky: You're doing a thing that could fail.
14:18:04 <shachaf> It could fail in two ways: Either decode will fail, and give you Nothing; or the key that you're looking for, "BTC_NEXT", might not exist.
14:18:13 <shachaf> What do you want to do in those cases?
14:18:46 <shachaf> (^.) is only for things that can't fail (or at least for things that fail in a specific way).
14:19:24 <joseph07> amf: okay then lls is list of bytestrings? Use bytestring's concat function to get one bytestring and call decompress on it
14:19:35 <Qfwfq> lucky: Your error can be interpreted as "I have asked for a key in my JSON without first resolving that the decode succeeded."
14:19:39 <joseph07> amf: it's kind of weird to "parselines" of gzipped data though
14:20:05 <shachaf> Qfwfq: Even without the _Just you would get the same error.
14:20:05 <joseph07> amf: probably would be better to just do manyTill
14:20:05 <amf> joseph07: no, the data feed into parseLines needs to be gunzipped
14:20:19 <shachaf> I mean, if it wasn't Maybe.
14:20:21 <joseph07> amf: Oooh I see
14:20:36 * hackagebot filepath 1.3.0.2 - Library for manipulating FilePaths in a cross platform way.  http://hackage.haskell.org/package/filepath-1.3.0.2 (HerbertValerioRiedel)
14:20:39 <shachaf> But you need to answer the question about what you want. Writing code without knowing that is unhelpful.
14:20:59 <Qfwfq> shachaf: Yes, because there's no Monoid instance for Value. I think Show a => Show (Maybe a), so the print would compile if 'key' accepted s.
14:21:28 <shachaf> Qfwfq: key "..." is a traversal
14:22:22 <joseph07> amf: so you need to do something like raw <- manyTill (string "END"); and then run the parseLines parser over (decompress raw)
14:23:00 <lucky> I said I give up, please don't waste your time on this. I clearly have too many gaps in my knowledge because I can't understand these questions. I'm sorry.
14:23:06 <Qfwfq> shachaf: Oh, of course it is.
14:23:42 <amf> joseph07: does that approach preserve the lazy reading nature i need? there might be 2GB+ of gzipped data
14:23:45 <shachaf> lucky: Here's one possible thing you might've wanted: Replace the "^." with "^?"
14:23:52 <shachaf> Your program will compile and print something.
14:25:31 <shachaf> lucky: I think "diving into lens" without knowing how and why things work the way they do is almost never effective. It's hard to get anywhere wthout understanding it.
14:25:32 <joseph07> amf: According to the docs, decompress is performed lazily
14:26:12 <lucky> shachaf: i've tried ^? for ^. before, it was one of the first things I tried
14:26:21 <lucky> shachaf: same error
14:26:24 <shachaf> Did you try it along with the _Just?
14:27:35 <lucky> shachaf: just tried it now, different error
14:28:02 <lucky> I'm too frustrated with this to keep going, I've spent the last four hours trying to understand this, maybe things'll be clearer tomorrow
14:29:45 <wakalabis> Hey, guys. I've come to this response by Edward Kmett on stack overflow about memoization. It's very cool: http://stackoverflow.com/a/3209189/361709 . I just don't get why he uses BangPatterns in function `nats`. I've tried running the code without bang patterns and noticed no difference.
14:30:46 <wakalabis> Has anyone used this technique?
14:30:48 <edwardk> wakalabis: it should be a relatively small amount of overhead actually
14:31:10 <edwardk> wakalabis: the reason was simply to make it so there was exactly one thunk being made at each level
14:31:16 <edwardk> so i could more cleanly reason about the cost
14:31:34 <wakalabis> edwardk: Are you Edward Kmett ?
14:31:41 <edwardk> otherwise i may have to backtrack and force a bunch of thunks
14:31:44 <edwardk> yeah
14:31:57 <wakalabis> Wow!!! I'm a huge fan :) cool
14:32:12 <edwardk> nice to meet you, wakalabis
14:32:27 <wakalabis> The pleasure is mine!
14:32:42 <wakalabis> Thanks for answering :) I'll have a look into that
14:33:50 <edwardk> wakalabis: no problem. i'm usually lurking here and/or in #haskell-lens
14:34:02 <edwardk> wakalabis: if you have any more questions on it, let me know
14:35:04 <wakalabis> edwardk: If you had not used "!n" and "!s", then that means we would have three more thunks per level? (l = n + s, r = l +s and s'= s * 2)
14:36:27 <Haskellfant> hm fix is always confusing me. i have no idea why this is the unmemoized function in this case
14:36:40 <TheMoonMaster> Sick name dude
14:36:49 <TheMoonMaster> I read it wrong
14:36:53 <TheMoonMaster> Haskellefant
14:36:55 <monochrom> see my http://www.vex.net/~trebla/haskell/fix.xhtml for what is fix
14:37:02 <Haskellfant> monochrom: thx i will
14:38:01 <wakalabis> Haskellfant: this might be helpful to learn about fixed points: http://xivilization.net/~marek/binaries/Y.pdf
14:38:30 <Haskellfant> wakalabis: too tired, right now, but i'll take a look tomorrow :)
14:38:37 <det> What is the preferred way to install libraries in Haskell ?
14:38:41 <wakalabis> Haskellfant: I also recommend the Schemer trillogy by Felleisen and Friedman
14:38:51 <det> Or rather, to install Haskell libraries on my Linux system
14:39:49 <monochrom> many people prefer to sidestep their linux distros and instead "cabal install" libraries
14:40:11 <det> Ok, that's what I just tried, and my first install was a compile error :)
14:40:11 <edwardk> wakalabis: the issue is more that what would happen is you'd get down to a given level and go to force the node, then that would depend on a thing which would depend on a thing all the way up until you had to force the chain of thunks
14:40:16 <edwardk> your asymptotics wouldn't change
14:40:44 <edwardk> your constant factors would and the stack depth would now be proportional to the number of those that you had to force on the way up towards the root until you found an answer that had already been forced.
14:41:01 <edwardk> er your constant factors would suffer
14:41:42 <wakalabis> edwardk: I see!
14:42:41 <wakalabis> edwardk: Thank you. I *think* I understand. Now I just need to go learn about how to properly debug thunks in order to check my understanding.
14:43:51 <shock_one> Can somebody check if installing "cabal install uniplate" works for you, please.
14:44:04 <monochrom> Debug.Trace.trace helps show evaluation order. but you have to place it at the right places.
14:44:56 <wakalabis> monochrom: Hmm... I'll have a look at that. Thanks
14:45:55 <monochrom> shock_one: it works for me
14:46:03 <monochrom> I get 1.6.12
14:46:58 <shock_one> 1.6.12 fails for me. I have cabal-install 1.20.0.3 and Cabal library 1.20.0.2.
14:47:14 <monochrom> my cabal and Cabal are 1.18.*
14:48:35 <joseph07> anyone have an idea about how I could fork to vim like git does for commit messages? Sys.createProcess (shell "vim") causes Vim to have an error reading input
14:49:34 <etandel> hmmm, i'd *guess* you have to create a temp file, call vim on it and then read the file.
14:49:43 <etandel> maybe there's a better way, but i wouldn't know.
14:50:38 <etandel> yes, git does that
14:50:41 <joseph07> etandel: Yes that's true, the problem is that vim has trouble getting input as in keyboard input
14:51:16 <etandel> when you call "git commit" you can see the name of the temp_file on the bottom of the screen
14:51:22 <etandel> joseph07: oh, then i don't know.
14:51:52 <joseph07> etandel: thanks for your thoughts
14:52:14 <joseph07> etandel: in reality the call would be more like createProcess (proc "vim" ["/tmp/file"]). Same problem though
14:52:24 <pjdelport> joseph07: Hmm, 'shell' preserves all the standard inputs and outputs, so vim *should* work.
14:52:29 <lucky> shachaf: you ended up helping me out in the end https://stackoverflow.com/questions/17538691/why-would-my-datatype-need-to-an-instance-of-monoid-to-use-this-lens thanks :)
14:52:54 <pjdelport> joseph07: Does the process you're calling it from still have stdin set to the terminal?
14:54:13 <etandel> indeed, when i call it like this the stdin is all crazy
14:54:29 <joseph07> pjdelport: haven't changed any handles. program is literally main = void $ createProcess (shell "vim")
14:54:44 <pjdelport> And your'e invoking that program normally?
14:55:59 <joseph07> pjdelport: ghc Test.hs -main-is Test; ./Test (Vim: Error reading input, exiting...)
14:56:44 <etandel> intestingly, when I call vim as a subprocess in lua `os.execute("vim /tmp/mytest")` it works normally, but with ghci stdin is all crazy
14:58:31 <joseph07> pjdelport: it looks like my version of process is a little old, let me try with the latest
15:01:33 <joseph07> pjdelport: same deal with 1.2.0.0
15:03:35 <volty> hi, I have a func returning IO::Integer but I want to put it in a list as an Integer, how do / can I  extract pure Integer in a closure ?
15:04:08 <cdk> :t sequence -- volty
15:04:09 <lambdabot> Monad m => [m a] -> m [a]
15:04:24 <pjdelport> joseph07: Actually, don't you want callProcess or similar?
15:06:37 <monochrom> volty: I don't understand the question. but perhaps you need to know the explanation in my http://www.vex.net/~trebla/haskell/IO.xhtml first.
15:06:57 <joseph07> pjdelport: yup that works
15:07:00 <joseph07> pjdelport: good call
15:07:07 <pjdelport> joseph07: Ah, cool :)
15:08:11 <pjdelport> joseph07: Yeah, so it was the waitForProcess and related plumbing that was probably needed. I assume that by voiding the result of createProcess alone, the process handle was probably being GCed, and killed by some cleanup code or something (?).
15:08:47 <pjdelport> volty: "IO Integer" is just an IO action that will yield an Integer: you can't extract anything from it. However, you *can* compose other functions and IO actions to it.
15:09:10 <geekosaur> also there is no IO::Integer
15:09:52 <volty> it was a typo
15:10:14 <pjdelport> volty: If you have someIntegerAction :: IO Integer
15:10:33 <pjdelport> then you can apply pure functions to it with f <$> someIntegerAction, to get a new IO Integer action.
15:10:34 <glguy> > let lO :: Integer; lO = 10 in lO + lO
15:10:36 <lambdabot>  20
15:10:41 * hackagebot science-constants-dimensional 0.1.0.0 - Mathematical/physical/chemical constants  http://hackage.haskell.org/package/science-constants-dimensional-0.1.0.0 (cbou)
15:10:57 <pjdelport> bad glguy :)
15:10:59 <volty> say I want to read stdin and fill a list of integers ?
15:11:40 <pjdelport> volty: There are a number of helpers for working with functorial and monadic values.
15:13:04 <benzrf> hmmm
15:13:18 <eitan_chatav> :t sequence
15:13:19 <lambdabot> Monad m => [m a] -> m [a]
15:13:20 <pjdelport> :t replicateM
15:13:21 <lambdabot> Monad m => Int -> m a -> m [a]
15:13:33 <pjdelport> :t replicate
15:13:34 <lambdabot> Int -> a -> [a]
15:13:38 <benzrf> given that haskell I/O is already completely 'callback-based' i bet async would be incredibly pluggable
15:14:01 <pjdelport> volty: replicateM is the monadic version of replicate: instead of taking a pure value and repeating it, it takes a monadic value and repeats it.
15:14:24 <pjdelport> volty: In the case of IO actions, it means it will repeatedly run the action, and give you a list of all the results.
15:14:45 <pjdelport> So let's say you have: readInteger = readLn :: IO Integer
15:15:01 <pjdelport> volty: That's a version of readLn that's specialized to read an Integer, just for convenience.
15:15:22 <pjdelport> volty: Then you can say: replicateM 10 readInteger
15:15:54 <volty> going to give it a look & try, thx
15:15:56 <pjdelport> And that will give you a new IO action (of type "IO [Integer]") that will read 10 Integer values.
15:20:32 <dnkndnts> are pure functions in haskell automatically multiplexed onto the available cores by ghc, using green threads or something? or is it single-threaded by default?
15:20:46 <monochrom> not automatic
15:21:10 <sleepynate> nope, but it's pretty trivial with the par module
15:21:39 <Peaker> dnkndnts: ghc compiles single-threaded programs by default. If you use -threaded -rtsopts option, then it's compiled to support multithreading, but *still* uses single-threaded by default. If you then add +RTS -N, then it supports and activates multithreading, but it's *still* not used, unless you actually fork threads or use parallelism annotations or what not
15:21:54 <Peaker> (if my sentence didn't make it clear - I find that situation quite ridiculous!)
15:22:13 <vanila> so it is hard to execute haskell code in parallel?
15:22:31 <sleepynate> dnkndnts: because everybody loves coming to IRC and being pointed at man pages: http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/lang-parallel.html
15:22:33 <Peaker> multiple arcane cmd line flags in different contexts + code changes --> you might get some parallel threads!
15:22:37 <dnkndnts> it does seem a bit weird to me, since pure functions are sort of... made for parallelism
15:22:49 <vanila> dnkndnts, are they though?
15:22:56 <Peaker> dnkndnts: if you try to parallelize all pure functions, you'll see they aren't :)
15:23:08 <Peaker> dnkndnts: there's significant overhead to throwing stuff across CPU cores
15:23:20 <vanila> I like the idea of getting the benefits of parallel computation for free
15:23:26 <vanila> but can it really be done?
15:23:28 <Peaker> dnkndnts: that overhead is worth it above a certain threshold, but most pure function invocations are below that threshold
15:23:31 <dnkndnts> well, yes, but i was hoping the compiler might be "aware" of that and "know" when to throw them across cores
15:23:50 <Peaker> dnkndnts: there's no good heuristic currently used to figure out which pure applications will cost how much
15:23:53 <sleepynate> if you can make it do that i'd be so down
15:23:54 <vanila> that sounds like something really really useful, and worth about 5 or 6 PhD theses
15:24:05 <dnkndnts> lol
15:24:25 <Peaker> dnkndnts: fortunately, pure functions make parallelism *annotations* work really well (e.g: guaranteed not to change the program)
15:24:32 <vanila> Is there language with a compiler that IS capable of this?
15:24:39 <vanila> just to see if this is a thing
15:24:44 <dnkndnts> Peaker: can you elaborate on this a little bit? link?
15:25:02 <sleepynate> erlang has its VM set up to be processor/thread agnostic
15:25:08 <Peaker> dnkndnts: http://chimera.labs.oreilly.com/books/1230000000929 is a good resource
15:25:11 <pjdelport> vanila: GHC is capable of parallelizing with annotations.
15:25:12 <silver_> dnkndnts, http://chimera.labs.oreilly.com/books/1230000000929/index.html
15:25:15 <sleepynate> so it just runs them wherever is convenient
15:25:18 <silver_> Peaker, snap!
15:25:28 <Peaker> silver_: Yesod!
15:25:34 <vanila> so the only problem left is guessing where to put annotations?
15:25:40 <dnkndnts> thanks
15:25:42 * hackagebot science-constants-dimensional 0.1.0.1 - Mathematical/physical/chemical constants  http://hackage.haskell.org/package/science-constants-dimensional-0.1.0.1 (cbou)
15:25:57 <vanila> could this be done with JIT?
15:26:21 <Peaker> why does GHC require 2 flags to allow parallelism, and then an extra runtime flag to actually enable support? :( that's so silly
15:26:37 <Peaker> -threaded should imply +RTS -N by default, at the very least
15:26:55 <pjdelport> vanila: Right; it generally needs problem-specific design to figure out how to split your work up efficiently. (Just naively decorating everything with "par" generally makes things slower, because of overhead, so you need to insert it strategically.)
15:27:32 <vanila> I see!
15:28:24 <pjdelport> vanila: Ultimately the cool thing is that you can write pure code, and then annotate it with parallel evaluation strategies without worrying about altering the correctness: you only worry about making it faster or slower.
15:28:45 <pjdelport> @hackage parallel
15:28:45 <lambdabot> http://hackage.haskell.org/package/parallel
15:28:56 <vanila> ythat's really cool
15:29:00 <pjdelport> You'll probably want to look at the strategies there.
15:30:05 <pjdelport> As an example of something less trivial, you have strategies like parListChunk, which will split a list into chunks of the given size, and then evaluate each chunk in a parallel spark (or whatever sub-strategy you give it)
15:32:30 <dnkndnts> nice! so there is no... dirty work with primitives, right? like native thread dispatching vs green, etc? the dirty details are hidden under "just do this part in parallel" annotations and functions?
15:32:41 <pjdelport> Yes.
15:32:52 <dnkndnts> ok cool, that sounds good enough for me
15:33:20 <pjdelport> If your pure code is "map f xs", your annotated code might look like map f xs `withStrategy` parListChunk 1000 rseq
15:34:20 <pjdelport> That will parallelize the list in chunks of 1000 elements, and evaluate the elements of each chunk with rseq (i.e., force them with seq)
15:34:44 <pjdelport> But you can compose together arbitrarily complex strategies depending on your data and computations.
15:35:40 <dnkndnts> thanks, ya i'm just happy to see that it is essentially just an annotation, even though technically it is a sort of imperative in the middle of the code.
15:35:44 <pjdelport> For example, if your f is expensive enough to have each call individually parallelized, then you could say: map f xs `withStrategy` parList rseq
15:36:09 <pjdelport> Or as a shortcut: parMap rseq f xs
15:37:54 <silver_> dnkndnts, don't worry, you can get dirty in the IO department with forkIO, MVars and possible deadlocks :)
15:38:08 <tnks> cd
15:38:12 <pjdelport> All of that is just a convenience layer above par, thouh.
15:38:15 <pjdelport> :t par
15:38:16 <lambdabot>     Not in scope: ‘par’
15:38:16 <lambdabot>     Perhaps you meant one of these:
15:38:16 <lambdabot>       ‘Sym.var’ (imported from Data.Number.Symbolic),
15:38:26 <pjdelport> Well, par :: a -> b -> b
15:38:46 <dnkndnts> silver_: haha, yes that sounds like the part that scares me
15:38:51 <pjdelport> It's like seq, but parallelizes evaluation of the 'a' argument.
15:40:27 <fsdfsdd> how do I delete an element from a Vector?  there's no 'delete' function.
15:40:43 <dnkndnts> cool, alright thanks. i still think my automultiplexing processor would be cool (especially if it abstracted over cloud nodes and GPUs) :)
15:40:56 <dnkndnts> *compiler, not processor
15:41:18 <L8D> What's the name of >>= ?
15:41:24 <k00mi> L8D: bind
15:41:28 <L8D> thanks
15:41:42 <profil> L8D: bind
15:41:49 <L8D> thanks
15:42:53 <geekosaur> would be cool. alsp worth a few Ph.D.s
15:43:04 <geekosaur> it's very much an open research question
15:52:55 <phd8888> List
15:53:24 <shachaf> !list
15:53:24 <monochrom> shachaf: http://hackage.haskell.org/packages/archive/pkg-list.html
15:54:29 <glguy> !messages
16:07:41 <Arianna23>  You can find funny videos here. http://tinyurl.com/ozfvxy3
16:16:00 <cdc_> Arianna23's link above is NSFW and spam.
16:16:16 <etandel> the kind of links i love! =D
16:16:19 <sipa> @where ops
16:16:19 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
16:16:23 <glguy> cdc_ Not to worry, the bot was k-lined immidiately after posting that
16:16:37 <glguy> no need to chime everyone's client
16:16:37 <etandel> oh, the proxy at the company blocked the website. =(
16:16:39 <cdc_> glguy: Just warning others so they don't accidentally click on it as well >_>
16:16:56 <etandel> i'm not in the mood for creating a ssh tunnel for proxy.
16:20:34 <trap_exit> is there an exiting typeclass for capturing the following relationship "class Object, class Cmd" where "apply_cmd :: Cmd -> Object -> Object" ?
16:20:53 <trap_exit> so basically I have an Object -- then I hav a list of commands where I can apply to the Object to get an Object of a different value
16:21:02 <trap_exit> thus apply_cmd :: Cmd -> Object -> Object
16:21:05 <trap_exit> is there a typeclass taht captures this?
16:21:55 <trap_exit> #haskell , ANSWER ME! :-)
16:22:43 <toblerone> trap_exit: you think you could restate the question? I don't follow...
16:23:16 <trap_exit> I'm thinking of definitng a type class of the form "typeclass ApplyCmd object cmd where apply_cmd :: cmd -> object -> object"
16:23:26 <trap_exit> however, I'm wondering if these already exists a typeclass which captures this
16:23:48 <chrisdotcode> Sounds kinda like State maybe?
16:24:16 <benzrf> trap_exit: that sounds like BULLSHIT
16:24:28 <trap_exit> benzrf? why?
16:24:28 <benzrf> what is the point of this clas!
16:24:31 <toblerone> whats the point of making it a typeclass? Not to say you shouldn't do so (I'm no haskell expert...) but the reason isn't obvious to me...
16:24:42 <benzrf> trap_exit: you can capture this relationship like so:
16:24:51 <trap_exit> benzrf: suppose I have something like Map K V, then I have MapCmd k v = MapInsert k v | MapDel k
16:25:01 <benzrf> type ApplyCmdInstance object cmd = object -> cmd -> cmd
16:25:11 <benzrf> why have an instance when u can have a function.
16:25:16 <trap_exit> umm, ht woud have to be cmd -> object -> object
16:25:17 <Cale> benzrf: whoa dude, calm down :)
16:25:29 <benzrf> er
16:25:33 <benzrf> y know what i mean
16:25:36 <benzrf> what's the actual use
16:25:51 <trap_exit> I have an object, and I can store a 'diff' as a sequence of cmds
16:25:54 <benzrf> Cale: sorry man i have a nasty habit of using language like `lmao what' and 'thats bullshit'
16:25:59 <benzrf> trap_exit: my apologies
16:26:04 <trap_exit> i.e. I have old_map, and new_map and cmds = [ MapCmd ]
16:26:09 <trap_exit> benzrf: no offense taken
16:26:25 <trap_exit> "why the fuck would you ever use this" = legitimate question :-)
16:26:27 <toblerone> like a fold?
16:26:30 <Cale> benzrf: Instances of the class will give you a value whose usage will be inferred from the types of the arguments
16:26:37 <benzrf> hmm
16:26:39 <eazar001> snap
16:26:42 <Cale> (this is in some sense, the purpose of any type class)
16:26:46 <benzrf> trap_exit: how many utilities can you define on top of this though?
16:27:03 <benzrf> Monad is a reasonable class because Control.Monad is huge
16:27:08 <benzrf> what can you do with ApplyCmd
16:27:09 <Cale> That's not to say that this is a good idea!
16:27:16 <trap_exit> suppose you have a theorem prover
16:27:23 <trap_exit> you have "proof state" and "proof manip commands"
16:27:28 <benzrf> trap_exit: yes but
16:27:32 <trap_exit> where proof manip commands = proof state -> proof state
16:27:40 <benzrf> keep in mind that typeclasses are just sugar for passing around dicts of methods
16:27:43 <benzrf> and when you only have one method
16:27:54 <benzrf> that's equivalent to sugar for just passing an extra arg
16:28:08 <benzrf> if you dont have a crapload of functions to build on this, i'd say just add an arg
16:28:09 <Cale> benzrf: You still get to skip the argument though -- look at, e.g. Bounded
16:28:17 <Cale> :t minBound
16:28:18 <lambdabot> Bounded a => a
16:28:35 <benzrf> Cale: yeah
16:28:37 <trap_exit> benzrf: so you have two separate arguments (1) ApplyCmd is useless and (2) you should never define a typeclass with just one function ?
16:28:41 <benzrf> no
16:28:55 <Cale> trap_exit: Neither of those is true
16:29:07 <benzrf> trap_exit: my argument is that unless you have a lot of utilities in mind to build on top of your class, why not just pass 1 extra argument?
16:29:15 <Cale> trap_exit: Whether or not ApplyCmd is useful will depend on your program
16:29:18 <trap_exit> I'm not yet claiming those are true; I just want to understand benzrf's argument first
16:29:35 <benzrf> trap_exit: do you have more than 2 or 3 functions in mind that would use this class?
16:29:46 <trap_exit> no
16:29:46 <benzrf> trap_exit: there's a reason we have foldr in the prelude instead of fold
16:29:47 <trap_exit> well
16:29:54 <trap_exit> wait
16:29:59 <bitemyapp> Fuuzetsu: I'd ignore the markdown folk.
16:29:59 <benzrf> :t fold
16:30:00 <trap_exit> I have more than one pari of objects that will use apply_cmd
16:30:00 <lambdabot> (Monoid m, Foldable t) => t m -> m
16:30:04 <bitemyapp> Fuuzetsu: just my opinion :)
16:30:06 <trap_exit> however, the typeclass only has one function, apply_cmd
16:30:12 <benzrf> trap_exit: i mean
16:30:16 <Cale> trap_exit: There is something to be said for good ol' fashioned functional programming though. A lot of the time people jump to type classes prematurely, when simple function parameters (or records of functions) would serve them better.
16:30:29 <benzrf> trap_exit: do you have more than 2-3 functions that will be implemented in terms of ApplyCmd
16:30:32 <trap_exit> so I have things like (DomTree, DomCmd), (ProofState, ProofCmd), (Map, MapCmd), ...
16:30:38 <benzrf> because if not you should just pass the apply impl to the func
16:30:50 <benzrf> trap_exit: like i said
16:30:59 <benzrf> foldr COULD just be on monoids and not take a folding function or a start
16:31:04 <benzrf> but in practice that's not really helpful
16:31:13 <benzrf> at least, a lot of the time
16:31:18 <trap_exit> Cale: I don't understand
16:32:03 <benzrf> foldable is for things that are homomorphic to [], right
16:32:28 <Cale> trap_exit: Any time you have a type class, you can imagine that it's being implemented by the compiler by adding an extra argument, turning (Foo a) => ... into FooDict a -> ..., where FooDict is a record type with fields for each of the type class methods
16:32:44 <Cale> trap_exit: Yeah?
16:32:51 <trap_exit> Cale: yes
16:33:20 <trap_exit> Cale: go on
16:33:24 <Cale> trap_exit: Sometimes, just doing *that* yourself is a good way to sidestep a lot of problems with type classes, especially if you end up wanting more than one instance at the same type.
16:33:53 <codehero> does someone here know why callProcess just ignores the args i give it?
16:33:58 <trap_exit> oh, like if I wnated apply_cmd1 :: Cmd -> Obj -> Obj, apply_cmd_funky :: Cmd -> Obj -> Obj ?
16:34:07 <codehero> oh
16:34:10 <codehero> disregard that
16:34:16 <Cale> Of course, if there's a single natural instance to choose for any given type, then using a type class is quite possibly reasonable.
16:34:19 <codehero> i actually forgot to pass them -_-
16:34:21 <codehero> i'm an idiot
16:34:42 <Cale> trap_exit: yeah
16:35:20 <trap_exit> hmm
16:35:26 <Cale> But anyway, I don't think there's a type class which already captures what you're after, however, you might want to define one, if it makes sense in the context of your application.
16:35:27 <trap_exit> Cale: I understand your objection
16:35:40 <trap_exit> now, is there a way I can search Hoogle for all typeclases which has functions of type "a -> b -> b" ? :-)
16:35:51 <Cale> If you do, you might also want a functional dependency, possibly in both directions by the sounds of your examples
16:35:53 <chrisdotcode> what's the fastest way to go from an Integer to a Number? (for aeson) `Number . fromInteger`?
16:37:01 <Cale> chrisdotcode: Or just toJSON?
16:37:46 <chrisdotcode> Cale: I'm not quite specifying the type, so I'd probably have to do toJSON :: Number
16:37:55 <chrisdotcode> I'm assuming that's likely prefered?
16:38:35 <Cale> instance ToJSON Integer where
16:38:35 <Cale>     toJSON = Number . fromInteger
16:38:56 <Fuuzetsu> bitemyapp: can't please everyne
16:38:59 <Fuuzetsu> everyone*
16:39:16 <Fuuzetsu> I hope they'll try to use pandoc then realise how crap it comes out
16:39:20 <Cale> chrisdotcode: Number . fromInteger is what toJSON does when applied to an Integer value.
16:39:26 <chrisdotcode> Cale: Got it. Thanks.
16:40:27 <Cale> trap_exit: You might want something like
16:40:51 <Cale> class Apply c o | c -> o, o -> c where apply :: c -> o -> o
16:41:15 <Cale> trap_exit: This will restrict the instances so that there's at most one 'o' for any given 'c' and vice-versa
16:41:24 <Cale> i.e. they uniquely determine each other
16:41:41 <trap_exit> hmm
16:41:46 <Cale> The advantage you get in exchange for that restriction is that the type 'o' can be inferred from 'c', and vice-versa
16:41:49 <trap_exit> I don't think I need this
16:41:51 <Cale> in case of ambiguity
16:42:02 <trap_exit> as I suspect the compiler can infer c / o based on the constructors alone
16:43:24 <Cale> Well, perhaps as long as you're only ever using it monomorphically
16:43:51 <Cale> I think if you try to write something polymorphic, you might bump into ambiguities
16:44:02 <Cale> But maybe not!
16:44:46 <trap_exit> Cale: when I run into that issue, I'll go "ah, Cale is wise" :-)
16:47:04 <Fuuzetsu> I'll be surprise if you don't bump into it fairly soon
16:47:18 <Fuuzetsu> surprised*
16:47:21 <Fuuzetsu> fundeps are pretty nice
16:47:38 <bitemyapp> Fuuzetsu: I just don't think there's anything to be gained.
16:47:39 <eitan_chatav> anyone know what kind of errors ghc might have when turning on TypeFamilies that it didn't have with it off?
16:47:55 <bitemyapp> Fuuzetsu: markdown only has the possible advantage of familiarity. That would indicate they haven't written much Haskell.
16:48:13 <bitemyapp> Fuuzetsu: why allow people who haven't contributed to churn ecosystem infrastructure? Seems silly.
16:48:29 <Fuuzetsu> bitemyapp: I doubt Michael Snoymann didn't write much Haskell.
16:48:42 <pharpend> What are we talking about
16:48:44 * pharpend scrolls up
16:49:00 <Fuuzetsu> pharpend: just some people buzzing about Markdown for Haddock again
16:49:01 <joelteon> no idea
16:49:31 <pharpend> Fuuzetsu: ehhh, no. Markdown is a nice language for writing simple little things, but it's not powerful enough for real documentation. Maybe RST?
16:49:35 <eitan_chatav> i'm getting weird type mismatch errors :-(
16:49:51 <bitemyapp> Fuuzetsu: oh I didn't know he was pushing for this, I only caught the others.
16:49:51 <pharpend> eitan_chatav: paste'em, willya?
16:50:03 <bitemyapp> Fuuzetsu: he really doesn't like Haddock syntax? How odd.
16:50:13 <Fuuzetsu> pharpend: You can search café archives for like 5 instances of this discussion, including RST proposals and all that
16:50:19 <bitemyapp> Fuuzetsu: maybe it's so he can cross-publish docs across the Yesod book/site and the library docs themselves?
16:50:35 <pharpend> bitemyapp: he writes the yesod books in asciidoc, though
16:50:44 <Fuuzetsu> bitemyapp: Well, his complant are escaping issues so maybe he got bit in the past; I don't blame him, escaping was utter shit
16:50:53 <pharpend> bitemyapp: and the yesod book is just terribly formatted, why would anyone take him seriously
16:50:56 <eitan_chatav> pharpend: http://lpaste.net/111093
16:51:04 <Fuuzetsu> also the fact that your docs refused to build on a badly formed comments didn't help
16:51:04 <bitemyapp> pharpend: yeah I didn't remember liking it.
16:51:07 <Fuuzetsu> but it's much better now
16:51:27 <bitemyapp> Fuuzetsu: I just don't get why you'd use markdown as the source format. It's terribly inexpressive.
16:51:35 <pharpend> bitemyapp: It's a nice-ish framework, better than, say, Rails, but it definitely needs some polish
16:51:40 <Fuuzetsu> bitemyapp: familiarity
16:51:43 <Fuuzetsu> that's it
16:51:48 <bitemyapp> pharpend: I like what Yesod does but end up using Scotty/WAI instead most of the time.
16:51:51 <bitemyapp> Fuuzetsu: I guess :\
16:52:04 <Fuuzetsu> Haddock is pretty close to Markdown though so I don't see why people can't apply themselves
16:52:07 <pharpend> bitemyapp: that includes the documentation. You wrote all that learn Haskell nonsense, couldn't you write a better yesod book?
16:52:12 <bitemyapp> I don't write any web apps with enough surface area that I'd get leverage out of Yesod's enhanced type-safety.
16:52:19 <Fuuzetsu> I bet we could push it as one of Markdown flavours for the fuck of it and no one would notice
16:52:27 <bitemyapp> I like the idea, but haven't encountered the need yet.
16:52:32 <pharpend> I learned Yesod basically by completely rewriting it from WAI and Blaze
16:52:35 <bitemyapp> Fuuzetsu: LOL
16:52:49 <pharpend> the Yesod book is great if you already know Yesod and need a quick little reference
16:54:07 <pharpend> But it's not suitable for learning Yesod from scratch
16:54:09 <pharpend> and holy shit netsplit
16:54:15 <tac_> holy wow
16:54:33 <Fuuzetsu> that's what you get if you have part/join messages on nerd
16:54:43 <bitemyapp> pharpend: the IRC gods are angry.
16:54:56 <Fuuzetsu> it's OK, you're on the cool side of the split with me
16:55:02 <bitemyapp> Fuuzetsu: I've had terrible luck trying to get irssi to reliably ignore JOIN/PART messages.
16:55:12 <bitemyapp> starting to think it's impossible.
16:55:24 <Fuuzetsu> bitemyapp: really? IIRC it's like 2 lines in some config or something
16:55:30 <pharpend> Fuuzetsu: occasionally there's someone I know. On small channels, they're actually nice. And they aren't hard to ignore.
16:55:32 <bitemyapp> Fuuzetsu: yeah, so I thought.
16:55:33 <Fuuzetsu> I just use emacs though
16:55:42 <pharpend> bitemyapp: this is why you use WeeChat
16:55:44 <pharpend> :)
16:55:51 <bitemyapp> Fuuzetsu: I should use Emacs, but my IRC is a session over mosh on a remote server.
16:55:54 <bitemyapp> I found ZNC a bit flaky.
16:56:04 <bitemyapp> ZNC doesn't really have the behavior I want.
16:56:08 <pharpend> That emoticon smile looks really creepy with my font
16:56:08 <Fuuzetsu> you shouldn't use emacs, it's hitler
16:56:21 <bitemyapp> Fuuzetsu: I mean to say, I use Emacs, but I don't use erc.
16:56:24 <pharpend> Fuuzetsu: More like Putin
16:56:35 <xeno_> emacs isn't hitler
16:56:42 <xeno_> emacs is... lemme think...
16:56:48 <Fuuzetsu> 5 holocausts
16:57:04 * Fuuzetsu goes back to fixing type errors
16:57:10 <xeno_> emacs is a lisp'y IBM
16:57:16 <Fuuzetsu> I haven't ran this program for 2 days, I did nothing but fix type errors
16:57:20 <xeno_> vim is a perl'ish hack
16:57:20 <Fuuzetsu> I wonder how much shit is broken
16:57:30 <pharpend> I'm wondering if we should consider moving the Haskell channel to a different network. FreeNode seems to be getting perpetually worse
16:58:10 <Fuuzetsu> even Rizon is up more than Freenode nowadays
16:58:17 <Fuuzetsu> a.k.a. Rizoff
16:58:33 <simpson> Freenode is merely a large target.
16:59:03 * hackagebot science-constants-dimensional 0.1.0.0 - Mathematical/physical/chemical constants  http://hackage.haskell.org/package/science-constants-dimensional-0.1.0.0 (cbou)
16:59:03 * hackagebot science-constants-dimensional 0.1.0.1 - Mathematical/physical/chemical constants  http://hackage.haskell.org/package/science-constants-dimensional-0.1.0.1 (cbou)
16:59:07 <pharpend> Fuuzetsu: unixporn moved to basementla.bz ; maybe we should look into it
16:59:25 <etandel> i can't remember having a connection problem with freenode.
16:59:25 <Fuuzetsu> pharpend: I don't suppose thay had ~1000 users on at any time?
16:59:33 <pharpend> Fuuzetsu: I doubt it
16:59:41 <etandel> but the recent news of a freenode compromised server is pretty scary
16:59:43 <Fuuzetsu> it's kind of hard to move off such a huge channel
16:59:54 <pharpend> Fuuzetsu: but this trope of FreeNode netsplitting 3 or 4 times a day is getting annoying
17:00:04 <pharpend> Fuuzetsu: and it's only going to get wors
17:00:13 <Fuuzetsu> they just want you to get back to hacking
17:00:16 <Fuuzetsu> right? ;_;
17:00:30 <dmj`> anyone here use io-streams or http-streams?
17:00:36 <pharpend> @ask
17:00:36 <lambdabot> Who should I ask?
17:00:57 <pharpend> dammit, lambdabot, you know what I meant. Yell at dmj` for his question!
17:02:24 <Fuuzetsu> @where justask
17:02:24 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
17:02:47 <Fuuzetsu> maybe that's his question though, perhaps he's trying gather numbers of people using those
17:03:10 <geekosaur> there is also asking on the haskell-cafe list, which is a bit better at nobody's-around than IRC is
17:05:03 <Fuuzetsu> I think you're more likely to get an answer on café unless you ask multiple times here
17:12:02 <dmj`> bitemyapp: for bloodhound did you create amazon v4 signatures
17:13:59 * hackagebot data-interval 1.0.0 - Interval arithmetic for both open and closed intervals  http://hackage.haskell.org/package/data-interval-1.0.0 (MasahiroSakai)
17:15:04 <bitemyapp> dmj`: what is that?
17:28:14 <jayunit100_m> any haskellers on the east coast [boston?]
17:28:22 <Fuuzetsu> a ton AFAIK
17:28:56 <jayunit100_m> http://www.meetup.com/ScalHaskell/members/ <-- anyone interested in ?  Fuuzetsu possibly .
17:29:08 <Fuuzetsu> I'm nowhere near there personally.
17:29:16 <jayunit100_m> oh ok :)
17:29:16 <Fuuzetsu> wrong continent
17:29:31 <eitan_chatav> there's a Haskell Boston meetup group
17:30:01 <eitan_chatav> http://www.meetup.com/Boston-Haskell/
17:30:20 <HeladoDeBrownie> Does Michael Snoyman frequent this channel?
17:31:53 <Fuuzetsu> I think he does not come on IRC.
17:31:59 <Fuuzetsu> at least not often enough that I remember
17:32:28 <HeladoDeBrownie> That was my impression as well. Thanks.
17:32:31 <sm> once in a while, here or #yesod, as snoyberg
17:32:40 <HeladoDeBrownie> Oh, cool.
17:32:50 <HeladoDeBrownie> Either way, he doesn't appear to be here now. I suppose I'll email him.
17:59:02 * hackagebot lvish 1.1.4 - Parallel scheduler, LVar data structures, and infrastructure to build more.  http://hackage.haskell.org/package/lvish-1.1.4 (peter_fogg)
17:59:30 <jayunit100_m> wow there are tons of haskell devs on the east coast.  great news
17:59:38 <jayunit100_m> i joined the haskell boston users group
18:09:48 <MorpheusBeing> ?fortune
18:09:48 <lambdabot> The sendmail configuration file is one of those files that looks like someone
18:09:49 <lambdabot> beat their head on the keyboard.  After working with it... I can see why!
18:09:49 <lambdabot>                 -- Harry Skelton
18:17:41 <mhall> is ClassLaws the go-to package for providing some kind of laws for type classes? or are there other options?
18:23:12 <Fuuzetsu> mhall: seems cool but it apparently doesn't even build with 7.6
18:23:26 <Fuuzetsu> oops, I misread, it builds with that but not 7.2
18:25:24 <mhall> Fuuzetsu: i'll keep that in mind
18:25:48 <Fuuzetsu> well, I'm just reading what it says on Hackage, I didn't know about this package
18:25:51 <Fuuzetsu> it looks interesting
18:26:24 <gfixler> is there any way to generate a list of all available modules and the functions they export?
18:29:05 * hackagebot xml-push 0.0.0.6 - Push XML from/to client to/from server over XMPP or HTTP  http://hackage.haskell.org/package/xml-push-0.0.0.6 (YoshikuniJujo)
18:29:56 <ChinaXing> ni mei
18:31:33 <ChinaXing> hi I’m new to Haskell :)
18:32:03 <vanila> hi ChinaXing
18:32:13 <vanila> welcome :)
18:38:03 <jayunit100m> what does quux mean ?  i see it in the "real world haskell" book.
18:38:09 <shachaf> Nonsense word.
18:38:42 <jayunit100m> ah ok
18:39:12 <merijn> jayunit100m: Usually used when you run out of "foo", "bar", "baz"
18:39:35 <bmuk> I'm trying to diagnose this cabal issue - http://git-annex.branchable.com/install/fromscratch/  (last comment). Shouldn't cabal be able to tell it should install network 2.[4,6)?
18:39:35 * merijn usually uses foo, bar, baz, quux, xyzzy, after that it's probably time to refactor :p
18:41:37 <merijn> bmuk: No
18:41:48 <merijn> bmuk: You're installed http-client requires network >=2.6
18:42:09 <merijn> bmuk: And hxt is requiring >=2.4 and <2.6
18:42:18 <merijn> So the set of valid network versions is empty
18:42:18 <bmuk> merijn: not me, trying to help the guy
18:42:41 <merijn> bmuk: s/you/him
18:42:48 <merijn> Still applies
18:42:55 <bmuk> but hackage says http-client can also depend on network 2.4 up to but not including 2.6
18:43:03 <bmuk> so this was a bug that was fixed
18:43:32 <merijn> Which version of http-client
18:44:09 <merijn> For some reason cabal is picking a version of http-client which is not compatible, which may be due to constraints in some other package
18:44:18 <merijn> Or out of date hackage index
18:44:31 <bmuk> the one I'm looking at on hackage is 0.3.8.1
18:45:17 <bmuk> https://github.com/joeyh/git-annex/blob/master/git-annex.cabal git annex simply says it depends on http-client, so it should default to the newest one
18:45:51 <bmuk> I'm going to assume that this shouldn't be an issue anymore and tell him to try again?
18:47:27 <masoon> can you statically prove that a function is tail recursive in haskell, to avoid an error of not having a tail recursive call while you thought you did?
18:49:24 <simpson> masoon: Why would it matter? Tail recursion isn't specially optimized in Haskell.
18:50:07 <vanila> in haskell you want your functions to be productive instead of in scheme where you want them tail recursive
18:50:24 <merijn> simpson: Rather, every call is a tail call in haskell :)
18:50:44 <masoon>  what do you mean? are you saying that haskell does not optimize tail calls?
18:50:44 <merijn> Because Core is essentially CPS style
18:50:45 <geekosaur> "tail call" is kinda not meaningful, yeh
18:50:52 <geekosaur> masoon, tail calls are a procedural thing
18:50:55 <masoon> ^^ simpson
18:50:57 <merijn> masoon: No, we're saying that every call is a tail call in haskell
18:51:07 <merijn> masoon: Haskell doesn't have a function call stack
18:51:21 <geekosaur> graph reduction doesn't work that way. in particular, in terms of implementation every call is a tail call, and the concept simply is not meaningful otherwise
18:51:28 <merijn> masoon: Therefore there's no stack overflow for too many recursive calls
18:51:49 <merijn> masoon: Haskell uses a pattern matching stack, which is not related to (tail) recursiveness at all
18:51:52 <masoon> merijn that is interesting. so haskell only has heap?
18:51:57 <geekosaur> if you are going to try to understand haskell evaluation in procedural terms, you will end up knowing less than when you started
18:52:06 <merijn> masoon: It has a stack, just not for function calls :)
18:52:23 <masoon> geekosaur I am not sure why you think that tail call recursion is a procedural term
18:52:25 <merijn> masoon: Consider "map f (x:xs) = f x : map f xs" <- clearly not tail recursive, right?
18:52:47 <masoon> merijn yes
18:52:53 <merijn> masoon: But due to laziness that lack of tail recursion doesn't matter, because the recursive part isn't performed when you call map
18:53:00 <geekosaur> masoon, because in implementation all haskell calls are tail calls and the concept is meaningless otherwise
18:53:19 <merijn> masoon: Instead, it's performed as you *consume* the resulting list, which means that if you consume the list in O(1) space, map will be O(1) space
18:53:29 <masoon> that does not make it a procedural term.
18:53:40 <merijn> @where lazy
18:53:40 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
18:53:44 <masoon> merijn I realize that, map is productive function.
18:54:12 <masoon> merijn, what is it that makes foldl crash and burn in some cases, but not foldl', then?
18:54:25 <geekosaur> because tail recursion is about calling procedures/functions. haskell evaluation is different.
18:54:26 <merijn> masoon: foldl builds up a huge thunk
18:54:31 <vanila> masoon, You can think of a haskell program as a graph on the heap & the GHC runtime executes it
18:54:34 <merijn> > foldl f z [a,b,c,d]
18:54:35 <lambdabot>  Ambiguous occurrence ‘a’
18:54:35 <lambdabot>  It could refer to either ‘L.a’, defined at L.hs:163:16
18:54:35 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.a’,
18:54:35 <lambdabot>                           imported from ‘Debug.SimpleReflect’ at L.hs:117:1-26
18:54:35 <lambdabot>                           (and originally defined in ‘simple-reflect-0.3.2:De...
18:54:37 <merijn> awww
18:54:43 <merijn> > foldl f z [a,b,c,d] :: Expr
18:54:44 <lambdabot>  Ambiguous occurrence ‘a’
18:54:44 <lambdabot>  It could refer to either ‘L.a’, defined at L.hs:163:16
18:54:44 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.a’,
18:54:44 <lambdabot>                           imported from ‘Debug.SimpleReflect’ at L.hs:117:1-26
18:54:45 <lambdabot>                           (and originally defined in ‘simple-reflect-0.3.2:De...
18:55:04 <merijn> I'm confused, did I forget how to simple-reflect? >.>
18:55:18 <simpson> Looks like L.hs is clogged up again
18:55:25 <merijn> @undefine
18:55:25 <lambdabot> Undefined.
18:55:25 <geekosaur> someone did a @let a = ...
18:55:29 <merijn> > foldl f z [a,b,c,d] :: Expr
18:55:31 <lambdabot>  f (f (f (f z a) b) c) d
18:55:35 <merijn> There we go
18:55:49 <merijn> masoon: Do you see how the first argument is a huge collection of calls to 'f'?
18:56:21 <geekosaur> the trick here: every "call" as you think of it returns a thunk immediately. calls don't *do* anything. pattern matching does things.
18:56:26 <merijn> masoon: Because of laziness those calls to 'f' all allocate a thunk, but never gets executed. So your foldl is an O(1) recursion, building up an O(n) thunk
18:56:35 <merijn> masoon: Whoops, now we leaked space
18:56:58 <merijn> masoon: The way foldl' works is that on every iteration it evaluates the "f x y" from the previous one
18:57:00 <Grazy> Hello all!
18:57:01 <masoon> ok I get it.
18:57:11 <merijn> masoon: Which means that it builds up an O(1) thunk in O(1)
18:57:29 <masoon> foldl' forces evaluation, instead of building a huge trail of thunks
18:57:29 <merijn> (space complexity, obviously, time complexity is O(n))
18:57:33 <merijn> masoon: Right
18:58:24 <merijn> But this is unrelated to the tail recursion of foldl/foldl'
18:59:07 <merijn> masoon: Basically, in haskell all function calls are compiled to jumps, rather than to "call/ret" like C
18:59:34 <masoon> I see
18:59:47 <masoon> to avoid dealing with stack overflow
19:00:22 <merijn> If you want more details on the operational behaviour of haskell, I'd recommend the STG paper
19:03:01 <lf94> Hey guys, how could I improve my haskell code?: https://gist.github.com/lf94/486e40458f9c4dbc3c0b
19:04:30 <HeladoDeBrownie> lf94, line 32: I would suggest not allowing users to crash your program. There are ways you can safely index a list; one way would be using lens's at. There's also safe's atMay.
19:05:21 <lf94> HeladoDeBrownie: Heh, thanks. I'll look into that :)
19:06:11 <lf94> I was actually wondering how I could detect a comment in the file. The line starts with // and need to skip over it.
19:07:24 <HeladoDeBrownie> lf94, lines 24 and 26, style: Parens are unnecessary to ensure that prefix function application precedes infix function application, as that is always true.
19:07:26 <xeno_> hi, I'm trying to use haskeline - running 'runInputT defaultSettings $ do ...' - but I get 'No instance for (Monad m0) arising from a do statement'
19:07:47 <MitchellSalad> xeno_: try providing a type signature
19:07:49 <HeladoDeBrownie> lf94, you'll probably want to write a parser of some sort. parsec is a good place to start.
19:08:36 <lf94> Just being safe HeladoDeBrownie
19:09:02 <lf94> I'm a newbie so adding parens avoids trivial mistakes
19:09:19 <HeladoDeBrownie> Sure, that sounds like a good rule. I'm just giving you another one you can rely on. :)
19:10:29 <lf94> I'll look at parsec. Is there no way of detecting // and skipping the line though in my program, trivially?
19:10:54 <lf94> Nothing obvious comes to mind
19:11:06 <HeladoDeBrownie> lf94, well, there's Data.List.isPrefixOf.
19:11:28 <lf94> Needs to happen in the calculate_total function I'm pretty sure too
19:11:30 <HeladoDeBrownie> I mention parsec because it scales much more easily once your syntax gets the slightest bit complex.
19:11:40 <lf94> But it's recursive so I have no idea how that'd even work
19:11:47 <lf94> Ah
19:12:09 <lf94> As you can see, I was just practicing some Haskell by converting my Python script
19:12:31 <lf94> Maybe I can use a guard!...
19:13:17 <HeladoDeBrownie> lf94, seems more like a case for filter to me, but perhaps you thought of a different way to handle it.
19:13:42 <HeladoDeBrownie> Either way, I haven't tested it, but it looks like a nice idiomatic translation.
19:13:50 <HeladoDeBrownie> s/it/your code so far/
19:14:13 <HeladoDeBrownie> For the most part, anyway. I'm nervous about the use of (!!).
19:15:13 <lf94> Before I shoot myself in the foot, can you combine guards and where?
19:15:23 <lf94> Or should I go ahead and see for myself
19:15:32 <Makoryu> Yeah you can
19:15:56 <HeladoDeBrownie> Not quite sure what you mean. But checking for yourself is often a good idea.
19:18:17 <lf94> What the heck is wrong with this line? https://gist.github.com/lf94/486e40458f9c4dbc3c0b#file-hours-hs-L25
19:18:28 <lf94> hours.hs:25:9: parse error on input `|'
19:18:57 <HeladoDeBrownie> lf94, extraneous = on the previous line.
19:19:13 <lf94> Whoops
19:19:26 <tabemann> I should note that the convention in Haskell is to use camelcase
19:20:22 <HeladoDeBrownie> Oh, I just noticed: Tabs for indentation tend to be looked down upon. The usual is spaces.
19:20:33 <lf94> Haha, works.
19:20:57 <HeladoDeBrownie> Four spaces for a full indent, and in some places a half-indent is appropriate. For example, "foo = bar\n  where\n    bar = 1"
19:21:00 <lf94> tabemann: oh? I saw someone using snake case and decided to use that
19:21:15 <lf94> Yeah I know the whole space vs tabs debate
19:21:22 <tabemann> I like two spaces for indent
19:21:26 <heatsink> what is snake case?
19:21:31 <tabemann> foo_bar
19:21:32 <lf94> i_think_this
19:21:37 <heatsink> ok
19:22:03 * heatsink uses camel case for top-level variables and snake case for locals.
19:22:09 <tabemann> I actually personally prefer snake_case, but I use camelCase in Haskell for the sake of being consistent
19:22:34 <lf94> tabemann: I use python a lot so it is being consistent for me B)
19:22:45 <HeladoDeBrownie> If you use camelcase and lens you get to pretend you're a Java programmer :P
19:23:09 <lf94> HeladoDeBrownie: so you mentioned about ' a case for filter', is filter a function?
19:23:14 <HeladoDeBrownie> @type filter
19:23:15 <lambdabot> (a -> Bool) -> [a] -> [a]
19:23:15 <HeladoDeBrownie> Sure is.
19:23:15 <Axman6> why no love for hASH_DEFINES_IN_HASKELL_CASE?
19:23:16 <Axman6> =)
19:23:30 <HeladoDeBrownie> Axman6, I have no words, besides these. :P
19:23:42 <heatsink> rEVERSEcAMELcASE
19:23:58 <Axman6> touche
19:24:05 <HeladoDeBrownie> lf94, and just to be perfectly clear, by "case for filter" I meant "situation in which one might use filter".
19:24:08 <lf94> HeladoDeBrownie: filter looks good, but isn't it less performant?
19:24:20 <lf94> Than what I have now
19:24:20 <HeladoDeBrownie> lf94, don't worry too much about performance. But I doubt it.
19:24:24 <heatsink> filter and guard perform equally well in most cases
19:24:29 <lf94> Ah, ok.
19:24:42 <lf94> Lets try this baby out with filter then!
19:24:49 <HeladoDeBrownie> lf94, there is not automatically overhead just because you used a function.
19:24:54 <HeladoDeBrownie> Unlike in languages like JavaScript.
19:24:57 <Makoryu> lf94: Depending on how you use them, a lot of list operation functions are inlined into your code
19:25:49 <lf94> HeladoDeBrownie: well I'm just saying for my case specifically, since I don't use another loop to filter.
19:26:07 <HeladoDeBrownie> Not sure what you mean by that or by "loop" in particular.
19:26:08 <lf94> another loop -> another recursive function
19:26:20 <Makoryu> And in some cases, the compiler can get away with reducing a whole bunch of list generation/consumption code to an imperative loop that never actually constructs a list
19:26:42 <HeladoDeBrownie> In that vein, one way to view lists is as first-class iterations.
19:27:00 <lf94> Makoryu: this is what I have: https://gist.github.com/lf94/486e40458f9c4dbc3c0b#file-hours-hs-L25
19:27:12 <lf94> I'm filtering as I'm going through the array elements
19:27:32 <lf94> But with filter, won't I have to go through all the elements, return a new list, and go through the new list?
19:27:51 <Axman6> laziness!
19:28:19 <lf94> Can't tell if you're referring to my own laziness or Haskell's :)
19:28:22 <Axman6> GHC is quite good at deforestation of lists, so most intermediate lists never get alloocated, the values just flow through
19:29:07 <lf94> But there is a performance loss, right?
19:29:12 <HeladoDeBrownie> In many cases, even though you use two functions that go through n elements of a list, using them together will still only iterate n times instead of 2n.
19:29:14 <lf94> I don't really care if it's barely non existent
19:29:21 <lf94> I just want to *know*
19:29:25 <Axman6> sum . filter prime . map (\n -> 2^n-1) $ [1..1000000] shouldn't create any lists at all
19:29:41 <lf94> Oh quick question how does . work
19:29:48 <HeladoDeBrownie> It's just function composition.
19:29:48 <Axman6> @src (.)
19:29:48 <lambdabot> (f . g) x = f (g x)
19:29:49 <HeladoDeBrownie> @type (.)
19:29:50 <lf94> oh right composition
19:29:50 <lambdabot> (b -> c) -> (a -> b) -> a -> c
19:30:06 <startling> lf94, there's not really any alternative to using functions in haskell
19:30:13 <Axman6> > f . g . h :: Expr -- not sure if this'll work...
19:30:15 <lambdabot>  Couldn't match expected type ‘Debug.SimpleReflect.Expr.Expr’
19:30:15 <lambdabot>              with actual type ‘a0 -> c0’
19:30:21 <lf94> startling: I don't understand
19:30:23 <Axman6> > f . g . h $ x :: Expr -- not sure if this'll work...
19:30:24 <lambdabot>  No instance for (GHC.Show.Show b0)
19:30:24 <lambdabot>    arising from a use of ‘Debug.SimpleReflect.Vars.f’
19:30:24 <lambdabot>  The type variable ‘b0’ is ambiguous
19:30:24 <lambdabot>  Note: there are several potential instances:
19:30:24 <lambdabot>    instance [safe] GHC.Show.Show
19:30:30 <Axman6> bah
19:30:34 <startling> lf94: "a performance loss" compared to what?
19:30:43 <lf94> Compared to what I explained above?
19:30:58 <startling> Oh, I think I misunderstood.
19:31:26 <merijn> I think the question is whether sum, filter and map loops over the entire list 3 times, but that doesn't make sense in a lazy setting
19:32:11 <startling> lf94: there may be a performance hit. I dunno! The only way to tell would be to benchmark.
19:32:23 <lf94> Haha, ok
19:32:24 <startling> But there's no reason to think there has to be a performance hit.
19:32:28 <lf94> I'l stick to filter anyways.
19:32:48 <startling> i.e., it's not actually iterating multiple times over a list
19:33:00 <lf94> I'm always for cleaner code then incomprehensible crap.
19:33:10 <lf94> then/than
19:42:48 <lf94> Damn haskell is so awesome
19:42:54 <lf94> Everything is starting to click guys
19:42:59 <lf94> Only took me 4 months
19:43:02 <lf94> B-)
19:43:20 <lf94> When do I get to start programming rockets
19:45:28 <AshyIsMe> right now! https://www.yoctopuce.com/EN/article/launching-a-model-rocket-without-raspberry-pi
19:46:01 <lf94> hahaha
19:46:15 <lpaste_> gfixler pasted “merijn explains tail recursion [not] in Haskell” at http://lpaste.net/111097
19:48:22 <lf94> So when you use 'do', you essentially enter an imperative mode of haskell
19:49:53 <merijn> lf94: No, and I (personally) think it is advisable to initially write things without do-notation, until you understand what it does
19:50:17 <startling> ^ this is good advice
19:50:20 <lf94> Thank you
19:50:23 <merijn> lf94: do notation is just syntactic sugar for (>>=) and (>>)
19:50:32 <lf94> I'm currently reading this: http://www.haskell.org/haskellwiki/Do_notation_considered_harmful and totally agree.
19:50:35 <merijn> lf94: The rules for desugaring are explained here: https://en.wikibooks.org/wiki/Haskell/do_Notation
19:50:41 <lf94> And I was just about to look up >>=.
19:50:59 <L8D> @pl \x y f -> f x f
19:50:59 <lambdabot> const . join . flip id
19:51:05 <lf94> What is the term for >>=
19:51:07 <L8D> @pl \x y f -> f x y
19:51:07 <lambdabot> flip . flip id
19:51:14 <L8D> lf94: bind
19:51:15 <merijn> lf94: I would recommend initially writing everything using >>= and >>, and once you feel comfortable with those two, THEN start using do notation
19:51:28 <lf94> L8D: and >> ?
19:51:40 <merijn> lf94: Doesn't have a name, it's a variation of >>=
19:51:51 <lf94> what's different
19:51:52 <merijn> lf94: "x >> y = x >>= \_ -> y"
19:51:57 <merijn> :t (>>=)
19:51:59 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:52:03 <merijn> :t (>>)
19:52:03 <lambdabot> Monad m => m a -> m b -> m b
19:52:18 <L8D> lf94: it's so that you can restrict the order of operations going on
19:52:19 <lf94> One takes a function and one doesn't?
19:52:23 <merijn> lf94: Correct
19:52:39 <L8D> lf94: It's so I can do: putStrLn "foo" >> getLine >>= putStrLn
19:52:54 <L8D> instead of putStrLn "foo" >>= const getLine >>= putStrLn
19:53:00 <merijn> You can also use lambdabot (in privmsg) to unsugar do notation
19:53:20 <merijn> @undo do { putStrLn "foo"; x <- getLine; print x; return x }
19:53:21 <lambdabot> putStrLn "foo" >> getLine >>= \ x -> print x >> return x
19:53:55 <lf94> Is this backwards? putStrLn "foo" >> getLine >>= putStrL
19:54:03 <lf94> Shouldn't it be >>= then >>
19:54:29 <lf94> m a means a monad with a parameter?
19:54:34 <lf94> m b too?
19:54:43 <merijn> lf94: L*D is making things confusing by using const
19:54:46 <lf94> or 'a that is a monad"
19:54:53 <L8D> sorry
19:54:54 <Axman6> no you had it right
19:55:08 <fread2282> is there anything like https://github.com/gelisam/category-syntax (that isn't that) (it's a do-like notation that desugars to categorical stuff) especially more self-contained?
19:55:11 <merijn> lf94: "m a" is a value of in the monad "m"
19:55:20 <L8D> lf94: "m a" means a Monad of type anything
19:55:36 <merijn> L8D: "m a" is not a Monad
19:55:38 <lf94> Ok you guys said 2 completely different things
19:55:45 <Fuuzetsu> so after two days of refactoring 140 module program, changing types
19:55:47 <Fuuzetsu> Test suite test-suite: RUNNING...
19:55:47 <Fuuzetsu> Test suite test-suite: PASS
19:55:49 <Fuuzetsu> thanks Haskell
19:55:51 <merijn> "m" is a Monad, "m a" can't be
19:55:53 <L8D> and m b is a another monad of any type that could be different from type a
19:56:05 <mm_freak> hi there
19:56:18 <Axman6> Fuuzetsu: code has been proved correct, Q.E.D.
19:56:20 <L8D> merijn: I'm drunk I'll stop.
19:56:23 <mm_freak> is there a way to figure out why a package's documentation wasn't built on hackage?
19:56:25 <L8D> lf94: don't listen to me
19:56:39 <mm_freak> hasn't been built for hours, but works fine locally: http://hackage.haskell.org/package/web-page
19:56:41 <Axman6> mm_freak: apparently nothing's docs are being built at the moment
19:56:43 <merijn> mm_freak: Look at the report, Fuuzetsu's "fix your docs" post explains how
19:56:57 <Fuuzetsu> merijn: what if m a :: * -> *?
19:56:58 * Axman6 pokes carter for more details
19:57:04 <lf94> merijn: so m a is...a monad, but isn't? X)
19:57:05 <carter> Axman6:?
19:57:09 <merijn> mm_freak: I've just started always uploading docs manually
19:57:12 <mm_freak> merijn: and if The Report doesn't help me, The Place might give me The Reason =)
19:57:14 <carter> Axman6: for the web thing?
19:57:22 <Fuuzetsu> mm_freak: Hackage is under migration nowadays, moving to new host
19:57:27 <Fuuzetsu> afaik the builder is stopped until that happens
19:57:28 <Axman6> yeah, you had an explanation
19:57:30 <mm_freak> ah, ok
19:57:32 <carter> Axman6: oh
19:57:40 <carter> Axman6: do you know how modern advertising works?
19:57:40 <merijn> lf94: A Monad is a typeclass whose instances are *types* that take a type argument
19:57:46 <lf94> Ah ok
19:57:47 <Axman6> ah, that makes sense, thanks Fuuzetsu
19:57:50 <merijn> lf94: Therefore "Maybe" is a monad, "Maybe Int" is not
19:58:16 <Axman6> carter: is this a trick question?
19:58:19 <merijn> lf94: You can *use* Maybe's monad instance to do things with values of type "Maybe Int"
19:58:21 <carter> Axman6: no
19:58:25 <L8D> m a could be Maybe Int, or IO String, or any other monad and a type
19:58:26 <carter> its a literal question
19:58:28 <Axman6> then, maybe
19:58:30 <merijn> mm_freak: http://fuuzetsu.co.uk/blog/posts/2014-01-06-Fix-your-Hackage-documentation.html
19:58:38 <mm_freak> thanks =)
19:58:41 <fread2282> merijn: s/A//. Monads exist outside of haskell and base
19:58:41 <carter> Axman6: the whole real time auctions and stuff?
19:58:44 <lf94> Ok
19:59:00 <Axman6> no, not that part
19:59:09 <carter> @google RTB advertising DSP
19:59:13 <lambdabot> http://www.kbridge.org/online-advertising-explained-dmps-ssps-dsps-and-rtb/
19:59:13 <lambdabot> Title: Knowledge Bridge | Online Advertising Explained: DMPs, SSPs, DSPs and RTB
19:59:21 <merijn> fread2282: I'm confining the discussion to Monad, the haskell typeclass. monads (lowercase m) are mostly irrelevant for people learning haskell, so no point in mentioning them
19:59:28 <Axman6> carter: do I need to know?
19:59:42 <lf94> So what's happening here?: putStrLn "foo" >> getLine >>= putStrLn -- Is it printing foo to output, but getLine is getting said printed line and passing it to putStrLn?
19:59:44 <Axman6> I'm a bit l;ost at the moment
19:59:46 <carter> Axman6: basically i've a few friends who do real time bidding in ad placment auctions
19:59:50 <Axman6> but intrigued
19:59:53 <carter> and i'm trying to convince them to move to haskell
20:00:11 <fread2282> lf94: getLine reads from stdin
20:00:13 <merijn> lf94: "IO a" is "an IO action that produces an 'a'"
20:00:19 <fread2282> putStrLn puts to stdout
20:00:30 <Axman6> ah, sounds fun. sounds somewhat similar to what Tsuru do, in a different context (many of the same requirements I'd guess though)
20:00:34 <lf94> So what the heck is >>= REALLY doing
20:00:39 <merijn> lf94: You cannot execute IO actions in haskell, however, you *can* compose small IO actions into bigger IO actions
20:00:51 <carter> if they can handle 10-15k requests per second using <= 10 servers with a 99%tile latency of 20-50ms in haskell, they'll jump aboard pronto
20:00:52 <merijn> :t (>>=)
20:00:52 <Axman6> lf94: it's different for each monad instance
20:00:53 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:00:57 <carter> Axman6: very different in some respects
20:01:12 <mm_freak> lf94: compare:
20:01:13 <merijn> lf94: So, if we look at IO, that says "IO a -> (a -> IO b) -> IO b"
20:01:17 <fread2282> lf94: it's shoving the String from getline into putStrLn
20:01:17 <Axman6> but from it's type, there's usually only a few milited ways it could possibly be implemented for each type
20:01:28 <carter> Axman6: i have no clue whatyou just said
20:01:29 <mm_freak> fmap :: (a -> b) -> (IO a -> IO b)
20:01:30 <Axman6> @djinn Maybe a -> (a -> Maybe b) -> Maybe b
20:01:31 <lambdabot> f a b =
20:01:31 <lambdabot>     case a of
20:01:31 <lambdabot>     Nothing -> Nothing
20:01:31 <lambdabot>     Just c -> b c
20:01:33 <fread2282> lf94: (in this case)
20:01:37 <mm_freak> (=<<) :: (a -> IO b) -> (IO a -> IO b)
20:01:46 <Axman6> carter: oh, that was for lf94 =)
20:01:51 <merijn> lf94: We can read this as "Given an IO action that produces an 'a' AND a function that, given an 'a' can produce an IO action that produces a 'b', we can compose them into an IO action that produces a 'b'"
20:02:13 <Axman6> @djinn Either c a -> (a -> Either c b) -> Either c b
20:02:14 <lambdabot> f a b =
20:02:14 <lambdabot>     case a of
20:02:14 <lambdabot>     Left c -> Left c
20:02:14 <lambdabot>     Right d -> b d
20:02:17 <mm_freak> lf94: a functor allows you to lift functions of the form (a -> b), while a monad allows you to lift functions of the form (a -> M b)
20:02:21 <merijn> lf94: Think of it as composing program fragments, or perhaps callbacks
20:02:34 * merijn wishes everyone would not try to give 15 explanations at once
20:02:37 <lf94> <merijn> lf94: So, if we look at IO, that says "IO a -> (a -> IO b) -> IO b" <- and that satisfies our >>= arguments
20:02:47 <lf94> Ok that makes things a little clearer
20:02:53 <mm_freak> lf94: for example look at the following list:  [1,2,3, 8,9,10, 52,53,54]
20:03:12 <mm_freak> you see that it's a list that can be expressed as the concatenation of a few sublists by using the following formula:
20:03:14 <lf94> I want to say IO is a type class, but it's a Monad. I'm guessing Monads are particularly special in Haskell?
20:03:14 <merijn> lf94: More fundamentally, you may have heard that "monads are impure", "IO is impure" or that sorta of rubbish. It's not true
20:03:17 <mm_freak> neigh x = [x - 1, x, x + 1]
20:03:33 <lf94> Yes I have
20:03:40 <mm_freak> using fmap isn't quite sufficient, because 'neigh' has this type:  neigh :: (Num a) => a -> [a]
20:04:00 <carter> Axman6: anyways, it'll be an interesting use of some of GHC's latency/fairness tech
20:04:06 <fread2282> lf94: Monad is a typeclass. IO is a type that GHC knows how to run
20:04:16 <carter> i'm right now writing a dumb version to see how slow that is
20:04:19 <fread2282> that has a Monad instance
20:04:20 <Axman6> carter: does it have much? I wasn't aware of any
20:04:26 <carter> Axman6: ?
20:04:31 <fread2282> :t IO
20:04:32 <carter> oh
20:04:32 <lambdabot>     Not in scope: data constructor ‘IO’
20:04:32 <lambdabot>     Perhaps you meant ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
20:04:34 <merijn> lf94: Let's take a simple example, "putStrLn :: String -> IO ()", now, clearly printing a message to the screen is a side effect, which would be impure. The secret is that "putStrLn" does *not* in fact print anything to the screen at all
20:04:42 <carter> Axman6: theres actually quite a bit
20:04:42 <mm_freak> lf94: Monad is just an abstraction…  monads are not related to haskell, but are used quite frequently, because we like algebraic abstractions =)
20:04:48 <carter> but its not used that much
20:04:53 <Axman6> carter: or do you just mean that ghc is pretty good with latency for blocking IO and that it schedules things fairly?
20:05:00 <carter> the -C and -V flags
20:05:12 <Axman6> I was looking at the user level scheduling stuff the other day and it looked very interesting
20:05:18 <carter> default context switching rate is 20ms
20:05:23 <merijn> lf94: putStrLn is a (pure!) function, which means that "if the input argument is the same, the result is the same", so what *is* the result and why is it the same if the input arguments are the same?
20:05:43 <carter> which is -C0.02
20:06:09 <lf94> merijn: following, sorta
20:06:11 <carter> if i were to say, compile stuff with -fno-omit-yield and do something like -C0.001
20:06:17 <merijn> lf94: Simple, the result of putStrLn is "a program fragment that, when executed, prints a String to the screen". Now if I call "putStrLn" with the same argument, I will always get the same result! That is, a program fragment that prints the argument to the screen!
20:06:23 <carter> or -C0.0005
20:06:23 <lf94> re-reading everything you're saying 3 times over
20:06:32 <fread2282> lf94: IO is just a type that has a few instances and GHC will run
20:06:51 <dhrosa_> I have a structure that represents an AST (abstract syntax-tree), I want a datatype similar to data Node = Program [FieldDecl] [MethodDecl] | FieldDecl Type String etc, how do I do this, or something similar to this that is type-safe?
20:06:52 <carter> Axman6: i could guarantee that each unit of work takes less than roughly 1ms
20:06:52 <merijn> lf94: Similarly, "getLine :: IO String" is "a program fragment that reads a line", all uses of getLine are the exact same program fragment
20:06:58 <carter> and have fairness
20:07:02 <dhrosa_> because the type-signature can't enforce a specific constructor
20:07:04 <carter> that way
20:07:17 <carter> i could even talk about making it finer grained than that, butnot sure if its worth it
20:07:48 <merijn> lf94: So "getLine >>= putStrLn :: IO ()" takes the program fragment that reads a line and a FUNCTION that returns a program fragment that prints a line,and composes them into a program fragment that "reads a line and then prints it"
20:08:09 <merijn> lf94: Is that pure? Yes, but it always returns the exact same program fragment, regardless of where in your program it's evaluated!
20:08:31 <merijn> lf94: So, now you're thinking "Hang on...if I can never *run* a program fragment, what can I actually do?!"
20:08:33 <heatsink> carter, how does very small timeslices improve the application's response latency?
20:08:49 <carter> heatsink: it reduces variance in response latency
20:09:10 <carter> if you have a reduced variance but slightly higher mean, thats ok
20:09:21 <heatsink> oh, okay
20:09:22 <Axman6> dhrosa_: data Node = Program [FieldDecl] [MethodDecl]; data FieldDecl = FieldDecl Type String; data MethodDecl = ... ?
20:09:30 <lf94> so getLine is a composition of 2 functions?
20:09:39 <lf94> Internally, at least
20:09:40 <carter> heatsink: because 20ms time slices is pretty heavy!
20:09:49 <carter> if you want to have a mean request latency of <50ms
20:10:02 <carter> and youre serving more than # of capability requests
20:10:05 <merijn> lf94: Simple, *you* can't run a program fragment, because haskell is pure, BUT the runtime system is impure and it *can* execute program fragments. So the trick of haskell is: "You use a pure language to combine pure program fragments into a program that has impure side effects and then have the runtime system execute that program" (i.e. "main :: IO ()")
20:10:05 <lf94> merijn: is there getLine code we can actually look at?
20:10:26 <Axman6> dhrosa_: does it all need to have the same type? it seems like Node will contains FieldDecl's and MethodDecl's so it seems to me they should be separate types
20:10:27 <merijn> lf94: Yes, but getLine is implemented using scary low level primitves from GHC :)
20:10:30 <nshepperd> lf94: http://www.vex.net/~trebla/haskell/IO.xhtml maybe informative
20:10:41 <carter> heatsink: midn you, i'm not sure if -fno-omit-yields is going to be necessary
20:10:49 <mm_freak> lf94: you should consider getLine to be primitive…  it doesn't have any particular source code
20:10:50 <dhrosa_> Axman6: you know I guess you're right
20:10:54 <nshepperd> (I think that is the best explanation of IO in haskell)
20:10:57 <merijn> lf94: The actual implementation of IO uses side effects, but since those side effects are not visible in your pure haskell program, the haskell program itself is pure
20:10:57 <dhrosa_> Axman6: I don't need them to be the same type
20:11:08 <lf94> Ok
20:11:11 <Axman6> dhrosa_: it should be clearer that way too
20:11:20 <lf94> Is this still related to Monads?
20:11:33 <mm_freak> lf94: the opaqueness of IO has nothing to do with monads
20:11:34 <lf94> Or are we too far gone down the IO rabbit hole
20:11:39 <lf94> Ok
20:11:45 <mm_freak> allow me to provide a different perspective that seems to work quite well to explain monads, using IO as an example
20:11:49 <merijn> lf94: It turns out that *monads* provide a convenient compositional interface which *also* works with IO
20:11:49 <lf94> This is still good stuff though
20:11:57 <carter> people had IO in haskell before monads
20:12:00 <carter> via the power of CPS
20:12:14 <merijn> lf94: So IO is just an abstract type and it happens that monads are just a convenient interface for combining IO actions
20:12:24 <merijn> You can have IO without monads and monads without IO
20:12:28 <lf94> Is IO primitive in Haskell
20:12:28 <mm_freak> lf94: merijn's explanation of IO is great:  values of type 'IO A' are programs that, when run, result in a value of type A
20:12:33 <Axman6> and before that, lazy-IO and lists of input and output right?
20:12:59 <mm_freak> lf94: you can't really do much with programs, but what you can do is:  you can map a function over the program's result
20:13:00 <carter> Axman6: lazy isnt the key bit
20:13:06 <mm_freak> lf94: do you understand the concept of mapping?
20:13:07 <carter> it looked like / WAS cps
20:13:08 <merijn> lf94: Yes, it's built into the compiler (well, actually IO is implemented using an even lower level primitive, but that's not relevant for you right now :))
20:13:28 <carter> haskell 1.2 http://haskell.cs.yale.edu/wp-content/uploads/2011/01/haskell-report-1.2.pdf
20:13:30 <startling> note, however, the Monad need not be.
20:13:33 <lf94> mm_freak: like applying a function over a list of elements
20:13:34 <lf94> ?
20:13:39 <mm_freak> lf94: exactly
20:13:43 <carter> the haskell 1.3 standard was the one that standardized monads
20:13:54 <Axman6> I thought early haskell/miranda had main :: [Input] -> [Output], or something similar, and lazy IO is pretty necesssary for that
20:14:04 <lf94> merijn: Are you saying side effects are possible in Haskell then?
20:14:18 <mm_freak> lf94: but mapping also works for IO:  take an action, construct a new action that is the same as the original, but a function is applied to the result
20:14:27 <Axman6> lf94: we'd never be able to get anything done if they weren't
20:14:28 <mm_freak> lf94: this is fmap:  fmap :: (a -> b) -> IO a -> IO b
20:14:40 <lf94> action being a function?
20:14:40 <mm_freak> lf94: if you compare that to 'map' you will notice the similarity
20:14:46 <merijn> lf94: Well, there's always unsafePerformIO, so yes. But unlike other languages, trying to use it tends to break your code hard and fast ;)
20:14:46 <mm_freak> lf94: action being "program"
20:14:47 <carter>  Since a stream in Haskell is only a lazy list a
20:14:48 <carter> Haskell program has the type
20:14:48 <carter> type Dialogue 	 Response 
20:14:49 <carter>  Request
20:14:56 <mm_freak> lf94: a value of type 'IO A' for some A
20:15:02 <carter> http://haskell.cs.yale.edu/wp-content/uploads/2011/01/haskell-report-1.2.pdf see page 83/69
20:15:08 <mm_freak> lf94: makes sense so far?
20:15:13 <lf94> is a program a function or composition of functions?
20:15:19 <mm_freak> lf94: it's a program
20:15:21 <merijn> someone motivate me to start writing some test for my package so I can get it ready for hackage...
20:15:26 <lf94> Binary?
20:15:30 <mm_freak> something abstraction which you might eventually run, but this is outside of haskell's scope
20:15:34 * Fuuzetsu motivates merijn 
20:15:35 <carter> heatsink: Axman6  i have a friend doing real time bidding on like 15k requests a second
20:15:39 <lf94> Actual code that's been compiled and it runs
20:15:39 <Fuuzetsu> get writing
20:15:39 <mm_freak> s/abstraction/abstract/
20:15:41 <carter> and using > 500 servers
20:15:49 <carter> to do it
20:15:52 <carter> which is bonkers
20:15:53 <merijn> Fuuzetsu: I just have so many boring things I need to write for that :(
20:16:08 <mm_freak> lf94: you can think of a program/action as "a set of machine instructions", if you like…  but best just keep it abstract, something that you can eventually run
20:16:09 <Fuuzetsu> such is life
20:16:09 <carter> i also know orgs that are serving 20x as much with 1/20th the servers
20:16:32 <lf94> Ok
20:16:34 <heatsink> Do they have statistics about how much server time is idle?
20:16:37 <mm_freak> lf94: the important thing is that you can map functions over actions, which produces actions with modified results
20:16:44 <lf94> because what you said sounds like normal composition to me
20:16:49 <mm_freak> lf94: here is an example:  length :: String -> Int
20:16:56 <mm_freak> lf94: you have a program that gets a line:  getLine :: IO String
20:17:08 <mm_freak> and you want to construct a program that gets the length of the line instead:
20:17:11 <mm_freak> fmap length getLine
20:17:21 <lf94> take an action, construct a new action that is the same as the original but applies a function to its result
20:17:30 <lf94> isn't that exactly what function composition is?
20:17:38 <mm_freak> lf94: no, that's what mapping is
20:17:51 <mm_freak> (well…  function composition is a special case of this, but let's ignore that)
20:17:54 <lf94> f . g x = f (g x)
20:18:09 <mm_freak> lf94: do you understand fmap?
20:18:18 <lf94> Functor map
20:18:19 <lf94> B)
20:18:28 <mm_freak> yes, but do you understand the IO instance of fmap?
20:18:30 <lf94> Depends on what you define "understand" as
20:18:39 <mm_freak> fmap :: (String -> Int) -> IO String -> IO Int
20:18:42 <mm_freak> length :: String -> Int
20:18:44 <lf94> I'll just say no, I don't
20:18:49 <mm_freak> fmap length :: IO String -> IO Int
20:18:55 <mm_freak> fmap length getLine :: IO Int
20:19:03 <fread2282> lf94: ((f . g) x = f (g x)) (f $ g x = f (g x))
20:19:32 <mm_freak> lf94: fmap takes a function and an IO action as its arguments…  its result is an action that is the same as the argument, but with the function applied to its result
20:19:42 <mm_freak> lf94: does that make sense?  think really really simple!
20:19:59 <davorak> If I am exploring report generation what else should I look at other then ermine?
20:20:24 <lf94> mm_freak: that's my problem, I'm trying to look to far into it
20:20:39 <mm_freak> lf94: try to understand it on its surface only…  it will be sufficient
20:20:53 <mm_freak> (conceptually the surface is all you get anyway)
20:21:03 <lf94> but in reality it's not
20:21:13 <heatsink> carter, the problem could be low throughput, or overprovisioning for poor scheduling, or overprovisioning for worst-case load...
20:21:17 <lf94> I thought fmap applies a function to an array
20:21:34 <mm_freak> lf94: try not to think about how IO is implemented…  i'm using haskell for almost six years now and never needed to look behind the curtain =)
20:21:36 <lf94> Did you make up that fmap declaration
20:21:40 <fread2282> lf94: fmap applies a function to a Functor. an array is a Functor, but so are other things such as IO
20:21:56 <mm_freak> lf94: i just wrote a special type signature for fmap…  the real type signature is more general, because it works not only for IO
20:21:58 <lf94> !t fmap
20:22:06 <mm_freak> fmap :: (a -> b) -> [a] -> [b]  -- yes, that's just 'map'
20:22:07 <fread2282> :t fmap
20:22:08 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:22:18 <mm_freak> fmap :: (a -> b) -> IO a -> IO b
20:22:23 <mm_freak> fmap :: (a -> b) -> Maybe a -> Maybe b
20:22:24 <mm_freak> etc.
20:22:35 <lf94> Oh shit multiple type signatures
20:22:46 <lf94> Ok cool
20:22:51 <mm_freak> it works for every functor (and since monads are special functors, for every monad as well)
20:23:07 <mm_freak> but ignore all of that…  let's make it simpler:
20:23:11 <lf94> Aaagh I forget what Functor meant but it was something simple
20:23:12 <mm_freak> ioMap :: (a -> b) -> IO a -> IO b
20:23:24 <mm_freak> functor is really just that:  "it has fmap (with some laws)" =)
20:23:37 <lf94> Yeah that!
20:23:38 <lf94> B)
20:23:49 <mm_freak> you can map a function of the elements of a list:  listMap :: (a -> b) -> [a] -> [b]
20:24:02 <zcd> a functor is a burrito: http://blog.plover.com/prog/burritos.html
20:24:04 <mm_freak> over the result of a program:  ioMap :: (a -> b) -> IO a -> IO b
20:24:21 <mm_freak> over the value that may not be there:  maybeMap :: (a -> b) -> Maybe a -> Maybe b
20:24:24 <mm_freak> etc.
20:24:57 <heatsink> fmap :: (a -> b) -> Burrito a -> Burrito b
20:25:10 <zcd> delicious Maybe tortillas
20:25:14 <mm_freak> conceptually/algebraically the idea of mapping works for multiple types
20:25:14 <lf94> This is starting to become recursive
20:25:27 <mm_freak> and it works for IO
20:25:34 * merijn wishes people would stop with the stupid burrito jokes
20:25:48 <mm_freak> and i'm pretty sure you have already understood mapping, just making it too complicated for yourself =)
20:25:51 <lf94> Monad is a Functor and IO is a Monad which means I can apply fmap to an IO action
20:26:00 <mm_freak> no
20:26:04 <mm_freak> IO is a Functor, and IO is a Monad
20:26:06 <shachaf> I, too, wish people would stop with the stupid burrito jokes.
20:26:08 <mm_freak> because every Functor is a Monad
20:26:15 <shachaf> I have low tolerance even for the non-stupid burrito jokes.
20:26:18 <mm_freak> uhm
20:26:22 <mm_freak> sorry
20:26:25 <mm_freak> every Monad is a Functor
20:26:25 <lf94> I thought it was Functor -> Monad -> IO
20:26:33 <carter> heatsink: true, but its cheap to test :)
20:26:36 <mm_freak> since IO is a Monad, it's necessarily also a Functor
20:26:44 <carter> heatsink: seriously, cheap
20:26:51 <lf94> So fmap can be applied to an IO type
20:26:55 <fread2282> lf94: this is cheating and potentially unsound (crashes if you don't respect IO!), so don't rely on it, but IO is State RealWorld, where RealWorld is sorta like (). IO *must* exist because without it laziness would make your IO happen in an unpredictable order
20:27:00 <carter> my friend has 500+ servers bidding a time
20:27:06 <mm_freak> lf94: anyway, let me just continue…  you now know how to apply a function to the result of an action, right?
20:27:14 <merijn> fread2282: Please don't mention RealWorld to beginners, RealWorld is BS
20:27:14 <carter> testing one extra one to benchmark how much load it can hande, costs nutting
20:27:25 <lf94> fread2282: ...Sounds like some pretty deep stuff
20:27:35 <Makoryu> RealWorld is imaginary and mostly a metaphor
20:27:41 <lf94> Within RealWorld is really [People], right?
20:27:41 <merijn> lf94: Ignore that, it's not really relevant
20:27:41 <heatsink> carter: Sure.  But, you know, profile before you optimize.
20:27:48 <carter> heatsink: who said i was optimizing
20:28:03 <carter> heatsink: i'm using Aeson + on heap data structures for now
20:28:03 <mm_freak> btw, i think that the RealWorld metaphor is never helpful…  i wish people stop with burrito jokes and RealWorld metaphors =)
20:28:13 <merijn> mm_freak++
20:28:17 <heatsink> It sounded like you were rewriting some of their code in Haskell so you could play with timeslices.
20:28:25 <carter> heatsink: did i say that?
20:28:29 <lf94> mm_freak: yeah
20:28:35 <carter> i said that theres neat RTS flags
20:28:42 <carter> and rtbiding
20:28:44 <Makoryu> lf94: You can't actually inspect what's in RealWorld, because even in implementations where it's actually a thing, it's just a formality to make the API work the way users expect it to work
20:28:45 <heatsink> yeah
20:28:59 <lf94> Makoryu: ok
20:29:00 <carter> but unlike finance, its actually cheap to just test the bidders live :)
20:29:04 <mgaut72> in parsec, is there a way to get the error message that *would* have resulted, if not for the parser being wrapped in 'try' ?
20:29:09 <lf94> I'll probably never even have to deal with it
20:29:33 <mm_freak> lf94: ok, now you have a problem:  you have a program that produces a string (getLine :: IO String) and a function that takes a string and returns a program that prints the string and has no interesting result (putStrLn :: String -> IO ())
20:29:40 <Makoryu> lf94: You will literally never have to deal with anything like it
20:29:51 <mm_freak> lf94: you want to combine those two programs to a single program that reads a line and prints the read line
20:30:09 <mm_freak> lf94: this obviously doesn't work, because it's ill-typed and doesn't really make sense anyway:  putStrLn getLine
20:30:11 <carter> heatsink: right now i'm  periodically putting a wee bit of time into implementing an aeson impl of http://www.iab.net/media/file/OpenRTBAPISpecificationVersion2_2.pdf
20:30:24 <mm_freak> lf94: putStrLn wants a string, but you give it a program…  this is ill-typed
20:30:24 <carter> + a wee query / matching engine for deciding what to bid on
20:30:49 <carter> its basically a bunch of big ass json things
20:31:07 <fread2282> lf94: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
20:31:07 <heatsink> Huh, they have an API for real time bidding
20:31:08 <mm_freak> lf94: but putStrLn is a function, and we know how to map a function over the result of a program!
20:31:20 <lf94> Makoryu: how do you know about it then? ;)
20:31:25 * spacekitteh sighs
20:31:27 <mm_freak> lf94: fmap putStrLn getLine :: IO (IO ())
20:31:29 <lf94> mm_freak: reading
20:31:36 <spacekitteh> i wish functors included their categories
20:31:49 <Makoryu> lf94: Because that explanation was a little more popular when I was learning Haskell ;)
20:31:55 <carter> spacekitteh: write a library that gives me that
20:31:57 <carter> :)
20:32:05 <carter> so i can understand what that gets me
20:32:14 <mm_freak> lf94: now you have taken the program getLine and mapped putStrLn over its result…  this results in a program that results in a program
20:32:54 <mm_freak> lf94: if we just had an operation that would turn this "program of program of ()" to just a "program of ()", then we would have what we need
20:33:24 <mm_freak> and it turns out there exists such an operation for IO:  ioEmbed :: IO (IO a) -> IO a
20:33:38 <lf94> mm_freak: I think I just got it.
20:33:40 <mm_freak> whenever a program results in a program, you can just embed that program in its producing program
20:33:57 <lf94> :t >>
20:33:58 <lambdabot> parse error on input ‘>>’
20:34:02 <mm_freak> lf94: this operation is actually in your base library and it's called 'join'
20:34:09 <mm_freak> lf94: join :: IO (IO a) -> IO a
20:34:39 <mm_freak> lf94: now this "mapping and then embedding" operation is so useful that we give it a name
20:34:42 <mm_freak> it's called (>>=)
20:34:55 <mm_freak> action >>= f = join (fmap f action)
20:35:12 <mm_freak> getLine >>= putStrLn = join (fmap putStrLn getLine)
20:35:12 <lf94> Wait wait, why do we need join?
20:35:21 <mm_freak> look at the type of fmap's result
20:35:28 <fread2282> lf94: join = (>>= id)
20:35:31 <Makoryu> > join [ [1, 2], [3, 4] ]
20:35:32 <lambdabot>  [1,2,3,4]
20:35:37 <fread2282> :t (>>= id)
20:35:38 <lambdabot> Monad m => m (m b) -> m b
20:35:39 <mm_freak> lf94: fmap putStrLn getLine :: IO (IO ())
20:35:57 <mm_freak> lf94: this is a program that reads a line and then results in a program that prints that line
20:36:07 <lf94> Right
20:36:11 <mm_freak> 'join' turns that into a program that reads a line and then prints the line
20:36:17 <mm_freak> instead of just returning an action that prints the line
20:36:42 <fread2282> lf94: join is often more convient to type than (>>=), but (>>=) = join . fmap , so you etiher join or (>>=) are enough
20:36:43 <lf94> So join allows us to execute said action?
20:37:00 <mm_freak> lf94: to embed said action in its containing action
20:37:03 <lf94> If you get an action back how do you run it
20:37:04 <fread2282> if that confuses you, ignore it
20:37:16 <lf94> without join
20:37:34 <mm_freak> lf94: you can't "execute" actions, but when an action results in an action you can construct an action that simply runs that resulting action as well
20:38:04 <mm_freak> note:  'fmap putStrLn getLine' has only one side effect:  it reads a line
20:38:07 <lf94> Couldn't we do that for our IO(IO())?
20:38:09 <mm_freak> it has no other effects
20:38:14 <lf94> Right
20:38:22 <mm_freak> but it results in an action that performs another effect
20:38:35 <mm_freak> all 'join' does is to embed that resulting action in the outer action
20:38:50 <lf94> resulting action being IO(IO()) ?
20:38:56 <lf94> what's the outer action
20:39:16 <mm_freak> look at the type again:  fmap putStrLn getLine :: IO (IO ())
20:39:19 * hackagebot separated 0.1.0 - A data type with elements separated by values  http://hackage.haskell.org/package/separated-0.1.0 (TonyMorris)
20:39:21 * hackagebot avr-shake 0.0.1.0 - AVR Crosspack actions for shake build systems.  http://hackage.haskell.org/package/avr-shake-0.0.1.0 (JamesCook)
20:39:24 <lf94> Is that a type signature?
20:39:26 <mm_freak> the outer IO is the one that reads the line
20:39:27 <mm_freak> yes
20:39:36 <lf94> You can have multiple type signatures?
20:39:41 <mm_freak> no
20:39:50 <mm_freak> it is the exact type of that expression
20:39:51 <mm_freak> :t fmap putStrLn getLine
20:39:52 <lambdabot> IO (IO ())
20:40:24 <lf94> Ok, the idea of 'type of that expression' is new to me
20:40:38 <mm_freak> ah
20:40:38 <lf94> What's the type of this expression?: 1 + 2 - 3
20:40:45 <mm_freak> every value/expression has a type in haskell =)
20:40:46 <haasn> :t 1 + 2 - 3
20:40:47 <lambdabot> Num a => a
20:40:56 <lf94> :t 1 + 2 - 3 * 4
20:40:57 <lambdabot> Num a => a
20:41:01 <lf94> Ok what
20:41:04 <haasn> :t 1
20:41:04 <lambdabot> Num a => a
20:41:05 <mm_freak> lf94: as you saw even programs have a type =)
20:41:11 <haasn> :t (+)
20:41:12 <lambdabot> Num a => a -> a -> a
20:41:15 <lf94> Oh, it's the type of the result
20:41:17 <haasn> Yes
20:41:36 <lf94> Why didn't someone just say that ;_;
20:41:42 <zwer> :t "hi" ++ "there"
20:41:43 <lambdabot> [Char]
20:41:48 <haasn> Well, it's the type of the expression
20:41:51 <zwer> ^^ maybe that is less confusing
20:41:52 <mm_freak> i'm sorry…  i assumed that you already know about types and type signatures =)
20:41:54 <haasn> > 1 + 2 - 3 * 4
20:41:55 <lambdabot>  -9
20:42:00 <haasn> :t (-9)
20:42:00 <lambdabot> Num a => a
20:42:02 <haasn> Same thing
20:42:06 <lf94> I know about type signatures but not like this
20:42:16 <Axman6> lf94: if you've programmed before, than it's not new, you just may not have known you were doing all the type checking yourself. Haskell means you can let the compiler do it for you!
20:42:32 <lf94> Ok this is good to know
20:42:41 <heatsink> lf94: What is the difference between 3 * 3 and 9 ?
20:42:47 <lf94> Man all those haskell books I've been going through have been totally useless
20:42:59 <lf94> (all = 2 of the better known ones)
20:43:05 <Axman6> > "Hello! " * 3 -- this is dumb and doesn't make sense, so it'd be good if we were told
20:43:06 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Char])
20:43:06 <lambdabot>    arising from a use of ‘GHC.Num.*’
20:43:08 <lf94> heatsink: nothing
20:43:13 <lf94> They are both Num a => a
20:43:16 <haasn> Note: When you've used type signatures before, you weren't really doing anything different. Say you had written “reverse :: [a] -> [a]; reverse = ...” in your file
20:43:27 <mm_freak> lf94: let's have a look at lists for a moment…  maybe less confusing, because lists are quite concrete data structures unlike the rather abstract IO programs
20:43:33 <haasn> In Haskell, everything is an expression, even functions
20:43:36 <heatsink> lf94: They are both 9.  So naturally they both have the same type.
20:43:41 <haasn> And the type of ‘reverse’​ is indeed [a] -> [a]
20:43:52 <mm_freak> lf94: here is a list:  "ABC"
20:43:52 <haasn> > (reverse :: [a] -> [a]) "hello"
20:43:53 <lambdabot>  "olleh"
20:44:04 <mm_freak> lf94: and it has a type:  "ABC" :: [Char]
20:44:06 <lf94> haasn: maybe haskell should be represented as "everything is an expression", or an "expressional" programming language Lol
20:44:07 <mm_freak> it's a list of characters
20:44:24 <haasn> Well, that's sort of a lie. Not everything in Haskell is an expression
20:44:30 <haasn> Data type definitions, for example, are not
20:44:32 <mm_freak> lf94: now you want to repeat every character three times…  there is a function to do that for a single character:  replicate 3
20:44:50 <mm_freak> and it too has a type:  replicate 3 :: Char -> [Char]  -- (specialised)
20:45:02 <Makoryu> lf94: There's certainly a division between definitions and expressions, but it's true that many things are expressions when you'd expect them to be statements in other languages
20:45:11 <mm_freak> lf94: we already know that we can map a function over lists:
20:45:17 <haasn> But many things are expressions: if/then/else blocks, functions, case/of blocks, etc.
20:45:19 <mm_freak> fmap (replicate 3) "ABC"
20:45:37 <haasn> Also let/in
20:45:38 <mm_freak> lf94: but that's not quite sufficient, because it results in a list that has lists as elements, each with three repetitions of the same character
20:45:46 <mm_freak> > fmap (replicate 3) "ABC"
20:45:47 <lambdabot>  ["AAA","BBB","CCC"]
20:45:55 <mm_freak> what we want is "AAABBBCCC"
20:46:14 <mm_freak> if we just had a function that takes every sublist and /embeds/ it in the outer list, then we would get what we need
20:46:19 <mm_freak> and it turns out that function exists
20:46:27 <mm_freak> it's called join, but you may know it better as "concat" =)
20:46:34 <mm_freak> > join (fmap (replicate 3) "ABC")
20:46:36 <lambdabot>  "AAABBBCCC"
20:46:38 <lf94> Nope, never had to touch concat
20:46:44 <lf94> nice :)
20:46:57 <mm_freak> exact same idea of mapping and then embedding
20:47:07 <lf94> Ok that's wicked
20:47:12 <lf94> so join is pretty generic then
20:47:14 <mm_freak> and it's exactly this idea that makes things monads =)
20:47:24 <lf94> Ahahaha cool
20:47:27 <mm_freak> > join (Just (Just 3))
20:47:28 <lambdabot>  Just 3
20:47:59 <lf94> That is a perfect explanation
20:48:08 <lf94> mm_freak good freakin' job, seriously
20:48:19 <lf94> So anything that can be embedded into itself is a Monad
20:48:33 <lf94> Or rather, you can take a sub-something and embed it into the outer list
20:48:44 <mm_freak> you need one more ingredient:  'return'
20:48:59 <lf94> and returns the list
20:49:02 <lf94> list -> something
20:49:05 <mm_freak> > return 3 :: [Int]
20:49:06 <lambdabot>  [3]
20:49:10 <mm_freak> > return 3 :: Maybe Int
20:49:11 <lambdabot>  Just 3
20:49:15 <mm_freak> :t return 3 :: IO Int
20:49:16 <lambdabot> IO Int
20:49:22 <mm_freak> as you see 'return' also exists for every monad
20:49:35 <haasn> lf94: In a sense, anything that can be “flattened” (associatively)
20:49:36 <mm_freak> the final ingredient you need is that those operations follow a certain set of laws
20:49:59 <haasn> eg. you can go from Foo (Foo (Foo (Foo x))) to Foo x, and it doesn't matter in which order you merge the Foo layers
20:50:00 <lf94> Yeah!
20:50:29 <haasn> Like [[[x]]] to [x], it doesn't matter if you concat the inner two or the outer two lists together first
20:50:32 <lf94> I swear the hour+ lectures in here are the most informative compared to anything else I read
20:50:42 <mm_freak> for example the laws require that it must not make a difference in what order you flatten layers
20:50:56 <haasn> ‘return’ essentially “adds another layer”, and adding a layer and then merging it back in is like doing nothing at all
20:51:09 <haasn> eg. return x = [x]; so return "foo" = ["foo"] and concat ["foo"] is just "foo" again
20:51:32 <haasn> Similarly, fmap return "foo" = ["f","o","o"] and concat ["f","o","o"] is just "foo" again, as well
20:51:51 <haasn> Monad laws in a nutshell
20:53:29 <haasn> Note to self: Using String syntax is probably not a good way to demonstrate list semantics
20:53:40 <lf94> is return a function?
20:53:42 <mm_freak> i don't mind doing that =)
20:53:44 <haasn> Yes
20:53:44 <mm_freak> lf94: yes
20:53:51 <haasn> :t return
20:53:52 <lambdabot> Monad m => a -> m a
20:54:15 <Axman6> it "puts things into the monadic context"
20:54:44 <Axman6> it has a defferent meaning for each monad, but there are (again!) some laws that mean there's often only one way to implement return for a given type
20:54:44 <haasn> I still prefer the name ‘pure’
20:54:47 <haasn> :t pure
20:54:47 <lf94> the flattening metaphor is freaking perfect
20:54:48 <lambdabot> Applicative f => a -> f a
20:54:59 <haasn> Same thing (almost (until soon))
20:55:04 <lf94> remember to tell that to the next guy who asks what monads are
20:55:05 <mm_freak> lf94: 'return x :: IO A' is the action that has no side effects and results in x
20:55:07 <lf94> or a Monad*
20:55:28 <mm_freak> lf94: 'return x :: [A]' is the list that has not multiple elements or no elements and has exactly the element x
20:55:32 <Axman6> yeah the join construction on Monad is often much easier to follow
20:55:37 <Axman6> fmap/join
20:55:41 <haasn> lf94: Another one I like is looking at (>=>)
20:55:47 <haasn> :t (>=>)
20:55:48 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
20:55:49 <mm_freak> lf94: 'return x :: Maybe A' is the optional value that is not absent and has the value x
20:55:54 <Axman6> but fmap+join is equivalent to return+bind
20:56:04 <mm_freak> lf94: this wording may sound weird, but it's exactly the wording that is enforced by the laws
20:56:06 <dibblego> fmap+join won't give you return
20:56:07 <haasn> lf94: Essentially, this way of looking at Monads considers only things of a type like (a -> m b)
20:56:29 <Axman6> dibblego: shit, right you are =)
20:56:31 <dibblego> return+fmap+join <-> return+bind
20:56:32 <haasn> For example, putStrLn :: String -> IO ()
20:56:39 <haasn> replicate 3 :: a -> [a]
20:56:57 <mm_freak> lf94: the laws make sure that 'return' cannot have IO effects or have multiple list values, cannot be Nothing, may not modify state, may not write a log entry, may not perform transactions, etc.
20:56:57 <haasn> And (>=>) gives us a way to compose functions like these
20:57:11 <haasn> :t replicate 3 >=> replicate 4
20:57:12 <lambdabot> c -> [c]
20:57:26 <haasn> > (replicate 3 >=> replicate 4) ()
20:57:28 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),()]
20:57:29 <Axman6> dibblego: so I (hopefully) start at NICTA on monday
20:57:39 <dibblego> Axman6: awesome, in Canberra then?
20:57:44 <Axman6> maybe I shouldn't mention that after that faux pas
20:57:45 <haasn> We notice that ‘return’ follows this same pattern
20:57:46 <Axman6> yep
20:57:48 <haasn> :t return
20:57:49 <lambdabot> Monad m => a -> m a
20:58:00 <dibblego> Axman6: well go forth and be awesome
20:58:05 <haasn> And in fact, the monad laws in this representation are simply that “return” is the identity of (>=>), eg. return >=> f = f
20:58:09 <haasn> And f >=> return = f
20:58:09 <Axman6> that's the plan! =)
20:58:21 <haasn> And also that (>=>) is associative, eg. (f >=> g) >=> h = f >=> (g >=> h)
20:58:47 <haasn> So in other words, Monad gives us a way to compose actions like a -> m b
20:59:22 <haasn> eg. say we have readFile :: String -> IO String  and putStrLn :: String -> IO ()
20:59:30 <haasn> And we want to “putStrLn” the contents of the file read by readfile
20:59:44 <haasn> That's precisely what readFile >=> putStrLn :: IO () does
21:00:05 <haasn> (pipes in shells are a good comparison)
21:00:09 <mm_freak> leaving you now…  live wrong and improper =)
21:00:12 <Axman6> dibblego: it's only taked 4 months or so of back and forth with Bill to get to this point, but I wasn't in a rush and I'm glad it's happened.
21:00:32 <dibblego> Axman6: goodo then
21:00:49 <Axman6> ok, gym time.
21:01:41 <haasn> lf94: Some more monads in this presentation: (a -> Just b) is like a function (a -> b) that may fail (with Nothing), too.  (a -> [b]) is like a function (a -> b) that can produce any number of results
21:01:46 <haasn> For some input ‘a’
21:02:44 <lf94> The "Just" and "Maybe" types seem pretty mystical to me still
21:02:47 <haasn> a -> (x, b) is like a function (a -> b) that produces some extra result ‘x’, and composing them means combining the resulting ‘x’ values together (using Monoid)
21:02:53 <haasn> lf94: data Maybe a = Nothing | Just a
21:03:00 <haasn> Do you understand what it means for types to have multiple constructors?
21:03:02 <shachaf> Just isn't a type -- haasn meant (a -> Maybe b)
21:03:04 <lpaste_> dfeuer pasted “dropWhileR” at http://lpaste.net/5164271292345483264
21:03:16 <haasn> Oh, shachaf is right, I meant (a -> Maybe b)
21:03:25 <dfeuer> So is there a nicer way to write what I just pasted?
21:03:58 <shachaf> I feel like worrying about monads when you arent' familiar with Maybe (and type classes and higher-kinded polymorphism and all sorts of jams) is a bad idea.
21:04:20 <shachaf> "Monad" isn't a complicated class but you should know the actual language features of Haskell before caring about it.
21:04:55 <dfeuer> shachaf, I hope you mean worrying about higher-kinded polymorphism before understanding Maybe is a bad idea, and not that worrying about monads before higher-kinded polymorphism is a bad idea.
21:05:19 <shachaf> I mean the latter.
21:05:49 <dfeuer> Oh.
21:06:22 * haasn .oO( “Everything is a jam in Haskell” )
21:06:32 <dfeuer> shachaf, Monad has been around a lot longer than higher-kinded polymorphism, right?
21:06:43 <heatsink> Monads are one use case for higher-kinded polymorphism
21:06:48 <haasn> Monad is a type class that requires higher-kinded polymorphism
21:06:49 <dfeuer> Huh.
21:07:07 <haasn> Maybe monads as a concept from mathematics have been around for longer
21:07:23 <dfeuer> Oh, I'm sorry. I'm mixing up higher-kinded polymorphism with PolyKinds.
21:07:26 <shachaf> dfeuer: No.
21:07:41 <heatsink> He's not mixing up higher-kinded polymorphism with PolyKinds?
21:07:52 <dfeuer> Yes, I'm pretty sure I am.
21:07:59 <shachaf> No, Monad hasn't been around a lot longer.
21:08:00 <haasn> PolyKinds is kind polymorphism. Higher kinded polymorphism is a type of *type* polymorphism
21:08:07 <haasn> (With types of kinds other than *)
21:08:30 <dfeuer> So yes, that was indeed my brain fart.
21:08:45 <haasn> Hmm, I could have said both “a kind of​” and “a type of” and that sentence would have been equally confusing
21:08:58 <shachaf> a sort of
21:09:00 <heatsink> a variety of
21:09:07 <mauke> an instance of
21:09:13 <haasn> An example of
21:09:15 <dfeuer> Mathematicians have also co-opted variety, sort, and instance.
21:09:25 <dfeuer> Example seems to be available!
21:09:41 <dfeuer> Probably not for long.
21:09:48 <Kludgy> a murder of
21:10:21 <dfeuer> So can anyone think of a better way to drop things from the end of a list than these two? http://lpaste.net/5164271292345483264
21:10:29 <heatsink> Eventually we'll be able to do "Who's on First" using mathematical terminology.
21:11:09 <haasn> The only way I can think of is “not at all”
21:11:44 <heatsink> dfeuer: Maybe you could simplify it by using groupBy ((==) `on` p)
21:13:12 <dfeuer> haasn, I saw  reverse . dropWhile p . reverse  a couple times in the GHC libraries (for error messages only, I think, so not performance critical). groupBy makes a lot of sense, probably.
21:14:18 <dfeuer> @type groupBy
21:14:19 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
21:16:22 <nshepperd> you need to see the end of the list before you know if the first element should be dropped, so maybe there isn't any lazy/fusible way of doing it
21:16:48 <dfeuer> I don't like that actually, heatsink. But I did consider a different approach that uses a sort of two-state machine.
21:17:01 <haasn> Unless you know something more about ‘p’
21:17:05 <haasn> Maybe you know something more about ‘p’
21:17:26 <dfeuer> nshepperd, only in the worst case. As soon as you see something for which p is false, you can flush.
21:17:52 <nshepperd> ah yeah, you need to read up to something that ¬p
21:19:14 <lpaste_> dfeuer revised “dropWhileR”: “No title” at http://lpaste.net/5164271292345483264
21:24:25 <spacekitteh> what is the terminal object in hask?
21:24:41 <copumpkin> ()
21:24:42 <haasn> :t \a -> ()
21:24:43 <lambdabot> t -> ()
21:24:48 <dfeuer> I was about to say....
21:24:55 <spacekitteh> ah right
21:25:24 <spacekitteh> :t ()
21:25:24 <lambdabot> ()
21:25:28 <spacekitteh> \o/
21:25:31 <copumpkin> :)
21:25:44 <copumpkin> newtype One = One One
21:25:51 <copumpkin> that's more terminal
21:25:53 <spacekitteh> i'm working on making some of the GHC internals more category theoretic :3
21:26:09 <shachaf> copumpkin: That was my initial reaction to the question.
21:26:28 <dfeuer> @def newtype One = One One
21:26:30 <lambdabot>  Defined.
21:29:37 <joelteon> :t One
21:29:38 <lambdabot> One -> One
21:29:57 <joelteon> so it's Nat without Z
21:29:58 <copumpkin> @def newtype One = One One deriving Show
21:29:58 <lambdabot>  .L.hs:155:1:
21:29:58 <lambdabot>      Multiple declarations of ‘One’
21:29:58 <lambdabot>      Declared at: .L.hs:153:1
21:29:58 <lambdabot>                   .L.hs:155:1
21:29:58 <lambdabot>  
21:30:02 <copumpkin> @undef
21:30:02 <lambdabot> Undefined.
21:30:03 <copumpkin> @def newtype One = One One deriving Show
21:30:04 <lambdabot>  Defined.
21:30:08 <copumpkin> > fix One
21:30:09 <lambdabot>  One (One (One (One (One (One (One (One (One (One (One (One (One (One (One (O...
21:30:12 <dfeuer> Huh???
21:30:22 <copumpkin> > undefined :: One
21:30:23 <lambdabot>  One (One (One (One (One (One (One (One (One (One (One (One (One (One (One (O...
21:30:26 <copumpkin> mmm
21:30:28 <joelteon> o_O
21:30:31 <haasn> Amusingly, data Zero = Zero !Zero is an initial object
21:30:39 <spacekitteh> heh
21:30:44 <copumpkin> > case (undefined :: One) of One x -> "hello"
21:30:46 <lambdabot>  "hello"
21:31:07 <copumpkin> haasn: sort of
21:31:54 <haasn> In what ways is it not?
21:32:16 <copumpkin> if we're going by the definition by which One is more terminal than ()
21:32:26 <copumpkin> then Zero isn't really uninhabited
21:33:09 <shachaf> copumpkin: But is it not initial?
21:33:18 <haasn> Oh, because f _ = 1 and f _ = 2 :: Zero -> Int  are distinct functions?
21:33:33 <dfeuer> haasn, that would be a problem.
21:33:37 <shachaf> Oh, OK, sure.
21:34:02 <haasn> Right, because haskell is non-strict this is a problem
21:34:05 * dfeuer is still trying to figure out how  newtype One = One One is even legal Haskell.
21:34:07 <haasn> We don't have to actually look at the input
21:34:24 <copumpkin> dfeuer: what's weird about it?
21:34:26 <dfeuer> It seems to completely break the concept of "newtype".
21:34:33 <vanila> @let newtype One = One One
21:34:34 <lambdabot>  .L.hs:155:1:
21:34:34 <lambdabot>      Multiple declarations of ‘One’
21:34:34 <lambdabot>      Declared at: .L.hs:152:1
21:34:34 <lambdabot>                   .L.hs:155:1
21:34:34 <lambdabot>  
21:34:39 <joelteon> @undef One
21:34:39 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
21:34:43 <joelteon> @undef
21:34:43 <lambdabot> Undefined.
21:34:44 <dfeuer> vanila, I did it already.
21:35:01 <vanila> @let newtype One = One One
21:35:03 <lambdabot>  Defined.
21:35:09 <shachaf> People have defined this one newtype five times by now.
21:35:16 <joelteon> It should be called Five instead
21:35:18 <haasn> (Is anybody ever going to use it?)
21:35:23 <copumpkin> I used it plenty!
21:35:23 <vanila> > One (One (One undefined))
21:35:24 <lambdabot>  No instance for (GHC.Show.Show L.One)
21:35:25 <lambdabot>    arising from a use of ‘M161940233353179668021205.show_M1619402333531796680...
21:35:33 <shachaf> There's no reason to do it in the channel.
21:35:36 <mauke> vanila: congratulations, you broke it
21:35:41 <mauke> wtf
21:35:42 <vanila> thanks mauke
21:35:45 <haasn> Oh, you're right
21:36:02 <dfeuer> > One (One (One undefined))
21:36:03 <lambdabot>  One (One (One (One (One (One (One (One (One (One (One (One (One (One (One (O...
21:36:30 <joelteon> That doesn't make any sense
21:36:39 <copumpkin> sure it does
21:36:50 <haasn> Remember that newtypes let you pattern match without forcing the value
21:37:04 <haasn> over, and over again..
21:37:34 <haasn> In a way, declaring something as a newtype means that _|_ is not an inhabitant
21:37:42 <haasn> Only C _|_ where C is the constructor
21:37:53 <haasn> s/Only/At most/
21:37:57 <vanila> Wow That's weird
21:38:06 <haasn> At least?
21:38:14 <vanila> fix One is like fix id
21:38:15 <copumpkin> a middlest
21:38:33 <dfeuer> So when a function produces a newtype, the newtype constructor is "produced" before the function is even inspected?
21:38:37 <haasn> So in other words, declaring newtype One = One One means that _|_ is not an inhabitant, but neither is One _|_ (because _|_ is not an inhabitant of One)
21:38:41 <haasn> Neither is One (One _|_)
21:38:43 <haasn> etc.
21:38:45 <copumpkin> dfeuer: there is no runtime rep
21:38:50 <haasn> So the only possible inhabitant is actually One (One (One ...))
21:38:56 <dfeuer> @let f = undefined :: (a -> One)
21:38:57 <lambdabot>  Defined.
21:39:03 <mauke> @undefine
21:39:03 <lambdabot> Undefined.
21:39:04 <dfeuer> > f undefined
21:39:05 <lambdabot>  No instance for (GHC.Show.Show a0)
21:39:06 <lambdabot>    arising from a use of ‘M81549442766044321321314.show_M81549442766044321321...
21:39:06 <lambdabot>  The type variable ‘a0’ is ambiguous
21:39:06 <lambdabot>  Note: there are several potential instances:
21:39:06 <lambdabot>    instance [safe] GHC.Show.Show
21:39:18 <copumpkin> lol
21:39:34 <dfeuer> *sigh*
21:39:34 <copumpkin> wherein we discover the perils of a shared resource
21:39:40 <shachaf> There's no reason to do all this in the channel.
21:40:01 <mauke> wherein we discover that idiots like to redefine one-letter identifiers
21:40:05 <haasn> dfeuer: That will be "Exception: Prelude.undefined", because _|_ is not the same as \_ -> ()
21:40:07 <mauke> which are already defined
21:40:14 <mauke> :t f
21:40:15 <lambdabot> FromExpr a => a
21:40:16 <haasn> err \_ -> _|_
21:40:28 <dfeuer> haasn, it works....
21:40:47 <haasn> Oh, because ‘f’ is never evaluated
21:41:08 <dfeuer> Wherein we discover that mauke is, apparently, a bit of a jerk.
21:41:17 <mauke> yep
21:41:37 <mauke> but this particular thing has happened dozens of times
21:41:52 <dfeuer> mauke, do you regularly rely on the default definition of f?
21:41:55 <mauke> and it's completely pointless because you could just use let .. in
21:42:09 <mauke> dfeuer: ?
21:42:22 <copumpkin> > foldr f z [1,2,3,4]
21:42:24 <lambdabot>  f 1 (f 2 (f 3 (f 4 z)))
21:42:57 <mauke> if I hadn't @undefined, your "f undefined" would've failed with "ambiguous occurrence of f"
21:43:03 <dfeuer> > let f = undefined :: a -> One in f undefined
21:43:04 <lambdabot>  One (One (One (One (One (One (One (One (One (One (One (One (One (One (One (O...
21:43:21 <shachaf> If you use let-in, you'll only use up two lines of vertical space instead of four.
21:43:21 <dfeuer> That's not a reason to call me an idiot, mauke.
21:43:54 <mokus_> > fix f :: Expr
21:43:56 <lambdabot>  f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f...
21:44:25 <mauke> dfeuer: true. I'm sorry
21:44:32 <dfeuer> Apology accepted.
21:45:31 <nshepperd> hmm, so no code that produces a One ever gets evaluated... because whoever is pattern matching can immediately get One (One (One ...))?
21:45:46 <dfeuer> I'm still a bit amazed that newtype, which was, I believe, invented for a purely practical purpose, can do such a theoretically peculiar thing.
21:46:16 <copumpkin> > let f = undefined :: a -> One in f undefined `seq` ()
21:46:17 <lambdabot>  *Exception: Prelude.undefined
21:46:32 <copumpkin> nshepperd: the Show instance won't force it
21:46:34 <copumpkin> but I will!
21:46:48 <nshepperd> ah, seq...
21:47:04 <haasn> > (undefined :: One) `seq` ()
21:47:05 <lambdabot>  *Exception: Prelude.undefined
21:47:07 <nshepperd> so that seq does something more than force the constructor for a newtype?
21:47:25 <copumpkin> yeah, seq is magic
21:47:28 <mokus_> > let one = error "two!" :: One in seq one ()
21:47:30 <lambdabot>  *Exception: two!
21:47:43 <nshepperd> well, that makes sense because seq is supposed to be always strict
21:47:57 <dfeuer> Yech. newtype is very strange.
21:48:46 <dfeuer> Oh right, I'm sort of remembering now.
21:49:14 <dfeuer> newtypes are treated specially by case.
21:49:29 <copumpkin> well, there's no runtime representation :P
21:49:36 <copumpkin> so case doesn't do anything
21:51:03 <haasn> Is the runtime representation of “one = One one” the same as “one = one”?
21:51:18 <copumpkin> I would expect it to be
21:51:22 <nshepperd> So my understanding of this is that the newtype constructor is sort of a lie. Normal code that pattern matches gets fed the lie, but seq ignores it?
21:51:28 <copumpkin> given that a newtype constructor doesn't do anything either
21:51:42 <dfeuer> nshepperd, I think that's right.
21:52:02 <haasn> > let one = One one in one `seq` ()
21:52:06 <lambdabot>  mueval-core: Time limit exceeded
21:52:15 <dfeuer> I seem to recall that newtype is more a magic trick to fool the type system than anything else.
21:52:31 <dfeuer> s/fool/enrich
21:52:32 <copumpkin> not sure I'd call it a trick
21:52:43 <copumpkin> but yeah, it's purely for type system uses
21:52:50 <copumpkin> since it stops existing later :)
21:53:09 <nshepperd> as in the runtime representation of 'error "blah" :: One' is just a thunk that throws an error, but a regular pattern matching function never gets to the thunk itself because it's protected by infinite layers of lies
21:53:35 <haasn> “Infinite Layers of Lies” is the name of my next indie album
21:53:42 <dfeuer> haasn++
21:54:51 <nshepperd> hehe
21:55:31 <trap_exit> is there any *.hs file of a math equationp editor?
21:55:48 <trap_exit> i.e. I want to read the source code of a math equation editor that has been written in haskell
21:55:57 <trap_exit> not something that compiles to LaTeX,
21:56:01 <trap_exit> but haskell outright
21:56:48 <dfeuer> trap_exit, what is a math equation editor? LaTeX is not an editor.
21:57:10 <trap_exit> dfeuer: something like MS Equation Editor
21:57:23 <trap_exit> basically WYSIWYG equation editor
21:57:37 <trap_exit> texmacs is also equation editor
21:58:11 <dfeuer> trap_exit, those sound a lot better than they work, last I checked. It's almost always faster to type in LaTeX. But to answer your question, I have no idea if anyone's written one in Haskell.
21:58:38 <trap_exit> eh, there's a reason matheamtica is WYSIWYG
21:58:41 <trap_exit> rather than LaTeX
22:00:05 <dfeuer> Oh, well, Mathematica needs semantic stuff LaTeX doesn't have. But you enter stuff by typing names of things, right?
22:00:34 <trap_exit> mathematica is wysiwyg
22:00:39 <trap_exit> it'll have 'cells' which are black with a blue outline
22:00:42 <trap_exit> if theyr'e missing things
22:01:39 <dfeuer> trap_exit, when you port Mathematica to Haskell, there will be Mathematica in Haskell!
22:02:09 <trap_exit> dfeuer: I don't understand.
22:02:11 <trap_exit> Are you mocking me? :-)
22:02:13 <dfeuer> Hmm... I just installed texmacs, and ran it, and BOOM. Segfault.
22:02:23 <dfeuer> No, trap_exit, I am not.
22:02:37 <StoneCypher4K> haskematica
22:02:47 <trap_exit> what do you mena by "when you port Mathematica to Haskell"
22:02:56 <Axman6> Mathskell?
22:02:57 <trap_exit> it's collection of standard libraries is insane
22:03:10 <StoneCypher4K> trap_exit: haskell's type system isn't strong enough to represent wolfram's ego yet
22:03:31 <trap_exit> you need something to compute the busy beaver function
22:03:34 <dfeuer> trap_exit, I was only suggesting that it's reasonably likely that what you're looking for does not yet exist.
22:04:19 <dfeuer> In sufficiently constructive mathematics, there is no busy beaver function.
22:06:13 <Laguana> I suspect I'm being dumb with typeclasses. I'm trying to write a basic raytracer, and I'm defining a ray-tracable-object, similar to how I might in C++, but I'm doing it as a typeclass of "raytracable thing" with some relevant methods. a) is this a terrible idea, and b) if not, how might I write an appropriate type of the form "ray n -> raytracable -> Maybe n"? I want to instantiate the raytracable with something like Plane n
22:10:01 <merijn> Laguana: That is almost certainly not what you want
22:10:41 <merijn> Rather than defining a class, you'd usually define a record of operations
22:10:57 <merijn> Laguana: See the following article for an example of what I mean
22:11:07 <merijn> @google Gabriel Gonzalez Scrap Your Typeclasses
22:11:08 <lambdabot> http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
22:11:08 <lambdabot> Title: Haskell for all: Scrap your type classes
22:11:09 <trap_exit> someone should build a site like reverse kickstrter
22:11:16 <trap_exit> where I can say things like: I'll contribute $10 to a port of https://github.com/Khan/KaTeX to haskell
22:13:34 <Laguana> merijn: so, if I understand that, effectively instead of defining a typeclass with instances, I define a higher type which knows how to apply the specific operations that would have been the instance methods?
22:14:47 <Laguana> I suspect that I'll still have troubles doing what I want with that (or if I made the typeclass approach work): I'd like to have a heterogeneous collection of "raytracable" things.
22:15:17 <Laguana> I guess I should define an explicit union type; e.g. data Raytracable = raysphere | rayplane | ... ?
22:15:47 <merijn> Laguana: "It Depends" (TM)
22:16:30 <Laguana> out of curiosity, what would another option be?
22:16:41 <merijn> Laguana: You could just define "data Traceable = Traceable (Position -> IO ())" and then have "renderSphere :: Sphere -> Position -> IO ()", "renderPlane :: Plane -> Position -> IO ()"
22:16:57 <merijn> Laguana: You then create a Traceable by partially applying "renderSphere" to a Sphere
22:17:31 <Laguana> That actually kind of matches what I was trying to do with the typeclass I think
22:17:35 <Laguana> I might give that a go. Thanks :)
22:18:07 <merijn> Laguana: Right, except that now you don't have to 1) implement a class 2) it's more easily extendable and 3) you won't get silly ideas like wanting to build heterogeneous lists/collections :)
22:18:37 <Laguana> yeah, much better overall, and actually aligned with what I intended before I XY'd all over
22:18:44 <jle`> everything being first class is a nice thing too
22:19:00 <merijn> jle`: Typeclass instances aren't first class :(
22:19:24 <jle`> yeah, i mean that in this normal data type solution, everything is first class
22:19:25 <jle`> :)
22:19:48 <zwer_t> that approach reminds me of emulating OOP in C with structs and pointers.. not sure I like it
22:20:00 <zwer_t> function pointers
22:20:22 <merijn> Except without any of the hassle or dangers of function pointers in C...
22:20:55 <trap_exit> is there a way in ghci to say: import **/*.hs ?
22:21:02 <trap_exit> i.e. all *.hs files in the current cabal proejct
22:21:16 <joelteon> uh, use cabal repl
22:21:21 <Axman6> that sounds like a bad idea...
22:21:32 <Axman6> oh, in ghci, misread
22:21:46 <Axman6> yeah cabal repl does a good job of loading everything
22:23:25 <trap_exit> hmm
22:23:30 <trap_exit> alright, I will switch from Makefiles to cabal
22:23:37 <trap_exit> so I run "cabal init" fill out my info
22:25:16 <trap_exit> can I use "hoogle" from cabal repl ?
22:29:29 <zwer_t> merijn sure. but still, the basic idea is the same. a manual, verbose way of emulating a very basic OOP class, without having reusability that comes with OOP (such as inheritence)
22:35:13 <kadoban> Are there answers to the typoclassopedia exercises anywhere?
22:35:48 <simpson> Looks like nobody's uploaded a procfs package to Hackage. :c
22:35:55 <shachaf> Probably not.
22:35:57 <simpson> Hm. Guess it's time to roll up my sleeves, then.
22:40:37 <merijn> zwer_t: We'll agree to disagree then. The more experienced I become in programming, the more convinced I am that inheritance is the dumbest idea ever invented
22:42:05 <L8D> Can someone explain to me or point me to an explaination of how subtraction works in lambda calculus?
22:42:47 <merijn> L8D: Lambda calculus doesn't have subtraction. You can implement an encoding of subtraction on an encoding of numbers, but that depends on the encoding
22:43:01 <merijn> Subtraction is really painful for the usual Church encoded numerals
22:43:05 <L8D> merijn: Then how is lambda calculus turing complete?
22:43:22 <merijn> I thought Scott encoded numerals was easier, but I don't know Scott encoding that well
22:43:31 <merijn> L8D: What does subtraction have to do with Turing completeness?
22:43:32 <haasn> He said ‘can’
22:45:22 <L8D> merijn: How are you supposed to calculate 10 - 5 in lambda calculus?
22:45:45 <Laguana> depends on how you represent 10 and 5, is his point
22:46:15 <Laguana> A standard encoding is Church numerals, and subtraction is painful in that case. But you can look it up if you want: predChurch = \n -> \f -> \x -> n (\g -> \h -> h (g f)) (\u -> x) (\u -> u)
22:46:24 <Laguana> that is "-1"
22:46:58 <L8D> ten is \s z -> s $ s $ s $ s $ s $ s $ s $ s $ s $ s z
22:47:02 <Laguana> you can then substitute that function for the "s" to compute "-n" if n = \s -> \z -> s s s ... s z
22:47:38 <dhrosa_> what would be the type signature for a Parsec parser that parses a [Token] into a Node?
22:47:59 <dhrosa_> not exactly sure on the relationship between Stream and the underlying user state thing
22:47:59 <L8D> (\n -> \f -> \x -> n (\g -> \h -> h (g f)) (\u -> x) (\u -> u)) succ 0
22:48:02 <L8D> >> (\n -> \f -> \x -> n (\g -> \h -> h (g f)) (\u -> x) (\u -> u)) succ 0
22:48:06 <L8D> > (\n -> \f -> \x -> n (\g -> \h -> h (g f)) (\u -> x) (\u -> u)) succ 0
22:48:07 <lambdabot>  Could not deduce (GHC.Num.Num a0)
22:48:07 <lambdabot>    arising from the ambiguity check for ‘e_10’
22:48:07 <lambdabot>  from the context (GHC.Num.Num a,
22:48:07 <lambdabot>                    GHC.Enum.Enum ((a -> t) -> (t -> t) -> t))
22:48:07 <lambdabot>    bound by the inferred type for ‘e_10’:
22:49:11 <L8D> -.=
22:49:11 <dhrosa_> ..and the monad I guess
22:49:56 <dhrosa_> Parsec [Token] _ Token Node, not sure what the
22:50:09 <simpson> Okay, this is annoying. How does one read in an entire file without lazy I/O?
22:50:13 <dhrosa_> I guess I should look at how the "Parser" type  synonym is defined
22:50:28 <L8D> simpson: Why do you not want to do lazy IO
22:50:56 <L8D> A?<esc>
22:51:00 <Axman6> simpson: it's pretty easy to do with strict ByteString and Text
22:51:18 <simpson> Axman6: There's just nothing in base for it?
22:51:25 <spacekitteh> www.lpaste.net/111108 does anyone have any idea how i can make this work? :\
22:51:32 <simpson> L8D: I know how big the files are, and reading them in a single big gulp is much better.
22:51:47 <merijn> simpson: You don't want that anyway, because strings suck for any kind of manipulation
22:51:48 <L8D> I see
22:52:05 <merijn> simpson: Keep in mind that String is a linked list of characters and may consume upwards of 24 bytes per character...
22:52:32 <merijn> You *really* want Text for unicode and ByteString for binary data
22:53:05 <simpson> merijn: I'm consuming the tiny files in procfs. What I *really* want is sed. However, I am in Haskell and trying to play along.
22:53:29 <dhrosa_> It's just ParsecT [Token] () Identity Node if anyone was curious
22:56:18 <zwer_t> simpson System.IO.Strict
23:04:26 <toblerone> how would i write the signature for this function? foo x xs = mappend (return x) xs? GHCi infers (Monoid (m a), Monad m) => a -> m a -> m a, but when I try to use the same signature, i get an error
23:05:17 <jTT> Hi, I have a silly beginner’s question: I have written a parser that opens a log file and works with it. in main I use print . parseOnly myParser. This prints correctly parsed things to the screen but does not process the complete file but stopps in the middle. How can I force full parsing?
23:06:45 <mauke> toblerone: what error?
23:07:02 <toblerone> ah, sorry I had a typo that was causing the error.
23:07:48 <toblerone> i had written the signature as "foo :: (Monad m, Monoid (m a)) => a -> m a -> ma", note the missing space in "ma"
23:08:38 <dhrosa> hello, when using Parsec on somethig that's not a String/ByteString/Text.... how do I even build the most basic parser?
23:08:46 <dhrosa> I can't find a way to get the next token from the stream
23:13:37 <c_wraith> dhrosa: Text.Parsec.Prim, token*
23:13:44 <joelteon> hmmmm...esqueleto, the latest, is broken
23:16:49 <dhrosa> c_wraith: oh I see
23:16:51 <dhrosa> c_wraith: thanks!
23:17:06 <dhrosa> I guess I build up my basic token parser from that, and then I can use the combinators
23:17:31 <c_wraith> dhrosa: yeah, that's the way it looks designed to work.
23:21:49 <awestroke> I can't install hdevtools with cabal on ghc 7.8.3, cabal 1.20.0.2, cabal-install 1.20.0.3: https://gist.github.com/awestroke/8c5e621b78855ae53696
23:24:11 <awestroke> nevermind, seems that hdevtools is very very old, I'll just not install it
23:25:52 <merijn> awestroke: I have a fixed and improved version on my github (not my patches)
23:26:19 <merijn> awestroke: https://github.com/merijn/hdevtools <- works with 7.8 and has very basic sandbox + cabal support
23:26:35 <awestroke> merijn: how can I install that with cabal?
23:26:51 <merijn> awestroke: git clone, cd into directory, run "cabal install"
23:27:38 <merijn> It's not my package and I can't devote the time to maintain it, so I haven't attempted to become maintainer, but I figure that as long as my branch works I might as well point others to it :)
23:28:33 <alpounet> merijn, awestroke: https://github.com/bitc/hdevtools/pull/33
23:29:06 <mroman_> (http://codepad.org/EPtUzO4X <- Feedback is welcome)
23:29:24 <joelteon> does anybody happen to know what happened to MonadSqlPersist?
23:35:33 <awestroke> Now I can't install ghc-mod...
23:36:04 <awestroke> https://gist.github.com/awestroke/d01b3b29fe07326b2b31
23:36:40 <merijn> alpounet: I basically merged all "good" pull request of bitc repo and put that in mine
23:37:15 <merijn> alpounet: So that one and 1 or 2 other pull requests, I think
23:37:26 <alpounet> merijn: right, it's just that I saw this PR the other day, so I thought you may want to take a look if you hadn't seen it before
23:37:42 <alpounet> but you did see it apparently :)
23:44:51 <folsen> I have a bit of a philosophical question.. If there were no IO in a program, could you be sure to infer the correct type of every value in that program, even in say, the elements of a heterogeneous list
23:45:16 <mroman_> folsen: No
23:45:41 <mroman_> IO isn't what makes stuff "unpredictable" in that sense.
23:46:25 <folsen> mroman_: hmm.. how would you contruct the list then such that there’s some element we can’t know the type of?
23:46:43 <mroman_> folsen: Halting problem.
23:47:14 <mroman_> I think.
23:47:56 <mroman_> if $conjecture is true return (9 :: Int) else return (9.0 :: Double)
23:47:59 <folsen> yeah I guess that’s true.. you mean like if the computation can’t be shown to terminate you can’t possibly know the return value of the function
23:48:01 <mroman_> ^- stuff like that I guess
23:48:12 <jle`> IO as type system sees it is no different than just another ol data type
23:48:21 <jle`> it shouldn't make any difference
23:48:46 <mroman_> folsen: I assume that there are things that are undecidable
23:48:57 <mroman_> meaning you can't prove $conjecture nor can you disprove it
23:49:10 <mroman_> which means you can't decide if the type is Int or Double
23:49:35 <folsen> mroman_: yeah.. i see what you mean..
23:50:58 <mroman_> Unless you only have one type anyway
23:51:03 <mroman_> Then probably yes :)
23:51:52 <mroman_> Haskell does have heterogenous lists though.
23:51:58 <mroman_> With a lot of restrictions.
23:53:01 <arrdem> kini: o/
23:53:06 <kini> o/
23:54:12 <merijn> folsen: Also, with some GHC extensions you can have heterogeneous lists just fine :)
23:54:48 <merijn> Staticaly typed and safe heterogeneous lists, even
23:55:20 <folsen> merijn: really? I wasn’t aware of that :P I was thinking more in the lines of a toy language though, but which extensions is that?
23:55:37 <merijn> folsen: Hold on, lemme find an example
23:57:51 <mroman_> folsen: Existential Quantification
23:57:58 <mroman_> http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
23:58:40 <merijn> folsen: Minimal example: https://gist.github.com/merijn/dc00bc7cebd6df012c5e
23:58:51 <merijn> mroman_: Naah, existential quantification is a lame ghetto approach
23:58:59 <merijn> DataKinds + GADTs is where it's at :)
23:59:35 <mroman_> folsen: However, you CAN NOT extract anything out of a heterogenous list in Haskell
