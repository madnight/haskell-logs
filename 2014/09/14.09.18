00:02:28 <Syk0Mant1s> oi
00:04:44 <srhb> Syk0Mant1s: Oi.
00:09:48 <f-a> should I still upload the documentation for my package manually? (hackage)
00:10:11 <srhb> I haven't heard that the buildbot has been reenabled yet.
00:10:38 <f-a> okie, thanks
00:16:31 <zcd> can i run the and function on an infinite list of finitely many True values?
00:16:38 <zcd> and have it return in finite time*
00:17:02 <pjdelport> > and $ [True] ++ repeat False
00:17:04 <lambdabot>  False
00:17:17 <zcd> oh duh
00:17:17 <pjdelport> Yup.
00:17:25 <zcd> thanks
00:17:37 <zcd> hooray for lazy eval
00:17:48 <pjdelport> > and $ repeat True
00:17:53 <lambdabot>  mueval: ExitFailure 1
00:18:26 <pjdelport> You do need a False, though, as that demonstrates.
00:18:33 <zcd> the True values are guaranteed to be finitely many :)
00:18:41 <zcd> > and $ repeat False
00:18:43 <lambdabot>  False
00:19:51 <mauke> @src and
00:19:51 <lambdabot> and  = foldr (&&) True
00:20:07 <mauke> @src (&&)
00:20:07 <lambdabot> True  && x = x
00:20:07 <lambdabot> False && _ = False
00:20:52 <idea-man> can happstack live on more than 1 box and have global state?
00:30:38 * spacekitteh ponders about how to implement the unit/counit from compact closed categories x.x
00:30:46 <f-a> leave
00:30:50 <f-a> ...
00:30:54 <f-a> I missed a /
00:31:16 <spacekitteh> lol
00:34:01 <mroman_> what
00:34:10 <mroman_> user error (https not supported)
00:34:21 <mroman_> that's disappointing from Network.HTTP
00:35:28 <tdammers> idea-man: it can in exactly the same way as other frameworks can (or cannot)
00:35:52 <tdammers> basically, you have to use some sort of persistence layer, and set it up such that state is shared between instances
00:36:25 <tdammers> the canonical data stores are relational databases (SQL) and memcache or similar
00:36:35 <tdammers> possibly shared filesystems, too
00:37:07 <tdammers> alternatively, if you can make your application completely stateless, all you need to do is make sure the software stack is identical between boxes
00:42:16 <mroman_> also the documentation for Network.Http.Client is wrong
00:45:26 <mroman_> @hoogle String -> ByteString
00:45:29 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
00:45:29 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
00:45:29 <lambdabot> Prelude error :: [Char] -> a
00:51:14 <mroman_> Failed reading: takeWith
00:51:19 <mroman_> I guess no https with Haskell then :(
01:06:08 <supki> mroman_: what's wrong with http-client docs?
01:09:48 <Ferdirand> Hello #haskell. Question: what was the rationale for having False < True, and not the converse ?
01:10:38 <shachaf> Probably mainly tradition. False is like 0, True is like 1.
01:11:48 <Ferdirand> If False > True, then "b <= a" would be equivalent to "a implies b" in classical logic
01:12:00 <Ferdirand> whereas for now we have "a >= b" as a implies b
01:12:43 <Ferdirand> in both cases it's awkward but oddly satisfyign
01:13:35 <shachaf> Yes, I remember talking about that before. But that arrow is just slightly cute, not a reason to have the opposite ordering.
01:13:49 <shachaf> But I know someone who was saying that Bool shouldn't be Ord at all.
01:14:15 <tranma> mroman_: there's http-client-tls and http-client-openssl
01:19:54 <Ferdirand> well, that slightly cute arrow was my epiphany moment of the morning
01:19:58 <Ferdirand> now back to work !
01:21:21 <jle`> Ferdirand: :)
01:43:43 <mroman_> tranma: I got it working with network-http-conduit
01:57:24 <mroman_> Can you instruct ghc to de-overlap instances?
01:57:48 <mroman_> or make it infer the instance based on the return types of class functions
02:00:20 <srhb> mroman_: As long as you can make sure there's one that's more specific than the other overlapping ones, OverlappingInstances can help.
02:02:30 <bernalex> can someone explain to me what injectivity really means?
02:04:45 <srhb> bernalex: As in monomorphism?
02:05:00 <bernalex> srhb: as in type-level injectivity
02:05:06 <srhb> Ah.
02:05:53 <Emily23>  You can find funny videos here. http://tinyurl.com/ozfvxy3
02:15:02 * hackagebot objective 0.0 - Extensible objects  http://hackage.haskell.org/package/objective-0.0 (FumiakiKinoshita)
02:23:06 <mr-> bernalex: A type family is a function F that maps types to types. Being injecitve means, that given two types A and B such that F A == F B, then A == B.
02:23:32 <mr-> bernalex: in particular, if you don't know that your family F is injective, and you are given F A, you can't assume that A was the argument
02:25:04 <mr-> bernalex: that can be problematic: http://www.haskell.org/haskellwiki/GHC/Type_families#Injectivity.2C_type_inference.2C_and_ambiguity
02:29:09 <bernalex> mr-: I see. thanks!
02:38:55 <mroman_> srhb: hm...
02:39:35 <mroman_> yeah, -XOverlappingInstances works
02:39:47 <mroman_> (but ghc doesn't suggest using it like it does with FlexibleInstances etc)
02:45:11 <mroman_> srhb: Can ghc order instances by "concreteness"?
02:45:18 <mroman_> and then choose the most concrete?
02:46:47 <mroman_> also I'm getting duplicate instances when I wouldn't call them duplicates
02:47:13 <srhb> mroman_: Isn't that exactly what OverlappingInstances does?
02:47:15 <srhb> See http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-resolution
02:47:23 <srhb> Specifically 7.6.3.5
02:47:57 <mroman_> instance (Monad m, Cast f t) => Cast (m f) (m t);  instance (Functor z, Cast f t) => Cast (z f) (z t)
02:48:03 <mroman_> ^- ghc considers those duplicates
02:55:14 <lpaste> foobar pasted “Cast????” at http://lpaste.net/6371372022684975104
02:55:28 <mroman_> oh. the bot works again?
02:55:33 <mroman_> ^- that's my class and instances
02:56:39 <supki> constraints are ignored in the instance lookup
02:58:08 <mroman_> :(
03:06:05 <mroman_> Can it be done conveniently with more type magic?
03:06:12 <mroman_> (possibly there's already a package for that?)
03:06:35 <Quarterdane> Is there any known reason why a haskell program compiled w/ GHC in Windows would run twice (once on excecution and once more after the first instance exits)?
03:09:47 <srhb> Quarterdane: Not without more information, no. How do you run it?
03:11:42 <Quarterdane> srhb: Tried running via CMD and by just double-clicking the .exe, both make the app run twice (although via CMD, the second run's prints and gets are shown in the CMD window itself)
03:12:26 <srhb> Quarterdane: I guess it's a problem with that specific program?
03:14:33 <Quarterdane> srhb: Thus far all the programs I've compiled with GHC (via command prompt) have exhibited this behaviour.
03:14:54 <srhb> Quarterdane: Do they run normally if you runhaskell yourfile.hs ?
03:15:43 <Quarterdane> srhb: Aye, they run once within the command prompt.
03:15:50 <srhb> ie if you have main = putStrLn "Hello World" -- as the only content, does it print twice if you compile and then run it, but once if you runhaskell file.hs?
03:16:05 <Quarterdane> That is indeed the case.
03:16:24 <srhb> I have absolutely no idea what would elicit that kind of behaviour.
03:32:16 <Quarterdane> Apparently the compiled programs launch two separate processes for themselves.
03:32:35 <Adios> hhh
03:32:41 <Adios> typo :o
03:37:25 <Quarterdane> srhb: Figured it out. Seems to have been caused by my antivirus trying to figure out whether the haskell program was going to cause trouble or not.
03:37:43 <srhb> Quarterdane: Funky.
03:55:17 <zwer> your antivirus program ran would-be virus twice?
03:58:07 <doismellburning> zwer: viruses are just like rot13 right? if you run them twice it's ok
03:58:12 <doismellburning> *ahem*
04:01:57 <Quarterdane> zwer: I think the first run was the AV running the app in a sandbox of some sort, with the latter being the proper execution of the program.
04:13:01 <sopvop> is there any way to do bracket for not IO with short-circuiting monads? besides ResourceT
04:17:29 <Guest34722> why can main function return any 'a' in 'IO a', and not just IO ()? is there a case where you would want to return something else
04:18:16 <ij> Guest34722, it works for me.
04:18:48 <ij> This returns works for me: echo 'main = return ()' | runhaskell && echo works
04:19:07 <Iceland_jack> ij: I don't think that's what they meant
04:19:25 <ij> Wait, you're right.
04:25:13 * hackagebot linebreak 1.0.0.1 - breaks strings to fit width  http://hackage.haskell.org/package/linebreak-1.0.0.1 (fffaaa)
04:57:18 <orbisvicis> how do I fold an associative operation over maybe: "fold ?? Nothing [Maybe a]" ? Specifically, I would like the maximum in terms of length.
04:58:45 <bernalex> orbisvicis: what do you mean? how would this look without Maybes?
05:00:15 * hackagebot objective 0.0.1 - Extensible objects  http://hackage.haskell.org/package/objective-0.0.1 (FumiakiKinoshita)
05:02:15 <simpson> orbisvicis: Why not catMaybes first?
05:04:15 <orbisvicis> bernalex: like monoid with any operation, or a mix of applicative and something else, for a result like: Nothing * Just a = Just a = Just a * Nothing, Just a * just b = a * b
05:05:59 <mr-> > Nothing <> (Just "like this?")
05:06:01 <lambdabot>  Just "like this?"
05:06:24 <mr-> > (Just "will this work ") <> (Just "like this?")
05:06:27 <lambdabot>  Just "will this work like this?"
05:06:57 <simpson> orbisvicis: As mr- is showing, there's an instance Monoid m => Monoid (Maybe m) which might work for you.
05:07:02 <bernalex> sounds like you want mplus, but I still don't know what you want.
05:07:24 <simpson> Some people don't like the one given in Data.Maybe; there's also Option, in semigroups, which is a slightly different Monoid.
05:09:12 <simpson> > mconcat [Just (Sum 4), Nothing, Just (Sum 5)] -- You'll want to get creative with ala, probably.
05:09:15 <lambdabot>  Just (Sum {getSum = 9})
05:10:09 <danilo2> Hello! I've written an instance and GHC tells me that it cannot decduce something not placed in the premise. But what it want to deduce is just wrong. I'm sitting here and looking for all the instances for long time, but I do not know why it thinks the deduction is ok. Is there any method to debug such situation?
05:10:26 <orbisvicis> except with a monoid the type of the wrapped value defines the operation. is it possible to use any associative function on the fly? (myOp) (f :: a -> a -> a) (m a) (m a)
05:10:36 <mroman_> danilo2: Adding implicit type signaturs
05:10:39 <mroman_> usually helps
05:11:16 <mroman_> but I think newer versions of ghc give you a hint how ghc came to the conclusion of deducing types
05:11:34 <mroman_> eh
05:11:37 <mroman_> explicit type signaturs
05:11:38 <mroman_> :)
05:12:02 <orbisvicis> like: monoidOp maxLength (Just "maximum") (Just "q") = (Just "maximum")
05:12:14 <simpson> orbisvicis: What should happen if your list is empty, or contains only Nothing?
05:12:29 <danilo2> mroman_: hmm it gives some help info, but I've got here a really complicated type families and in the result I'm alone in the darkness
05:12:53 <orbisvicis> simpson: like <> for Maybe, it would result in Nothing
05:13:01 <simpson> orbisvicis: Ah.
05:13:10 <danilo2> mroman_: anyway I tried the type signatures. It gives the same error - so the types are ok - something has to be broken with typefamilies somewhere
05:14:00 <mroman_> I can't help you with type families I'm afraid
05:14:23 <orbisvicis> simpson: my idea is 'map maxLength [String]' but then I don't know where to go from, ie how to fold the resulting list
05:14:35 <mroman_> (I don't know enough about them)
05:15:01 <simpson> orbisvicis: I'd honestly just use catMaybes.
05:15:06 <danilo2> mroman_: they are just functions on type level
05:15:19 <orbisvicis> simpson: explain ?
05:15:26 <simpson> :t catMaybes
05:15:27 <lambdabot> [Maybe a] -> [a]
05:17:04 <orbisvicis> simpson: the result has to be maybe, because an empty list has no maximum and is therefore Nothing
05:17:16 <simpson> :t \l -> case catMaybes l of { [] -> Nothing; l' -> Just $ foldr1 (*) l' }
05:17:17 <lambdabot> Num a => [Maybe a] -> Maybe a
05:17:38 <simpson> Hm, actually, I just realized that I'm being a little derpy.
05:18:32 <simpson> No, no, that's definitely correct.
05:19:04 <simpson> > let f op l = case catMaybes l of { [] -> Nothing; l' -> Just $ foldr1 op l' } in f (+) []
05:19:06 <lambdabot>  Nothing
05:19:13 <simpson> > let f op l = case catMaybes l of { [] -> Nothing; l' -> Just $ foldr1 op l' } in f (+) [Just 4, Nothing, Just 5]
05:19:15 <lambdabot>  Just 9
05:19:21 <simpson> > let f op l = case catMaybes l of { [] -> Nothing; l' -> Just $ foldr1 op l' } in f (+) [Nothing, Nothing]
05:19:23 <lambdabot>  Nothing
05:20:05 <simpson> orbisvicis: What do you think of that? There's also a way to use foldr with Nothing as your starting element, but obviously then you have to put in a lot more work to constantly wrap and unwrap each Just.
05:21:29 <simpson> Hm, although....
05:21:29 <orbisvicis> I can't complain
05:21:36 <orbisvicis> I could also do something like:
05:22:32 <fizbin> :t headOption
05:22:33 <lambdabot> Not in scope: ‘headOption’
05:22:33 <orbisvicis> :t \l if null l then Nothing else Just l >>= return . maximumBy (compare `on` length)
05:22:35 <lambdabot> parse error on input ‘if’
05:24:10 <orbisvicis> :t \l -> if null l then Nothing else Just l >>= return . maximumBy (compare `on` length)
05:24:11 <lambdabot> [[a]] -> Maybe [a]
05:24:42 <simpson> :t \op -> foldr (\ma mb -> liftA2 op ma mb <|> mb) Nothing -- orbisvicis
05:24:43 <lambdabot> (a -> b -> b) -> [Maybe a] -> Maybe b
05:24:58 <simpson> Uses Maybe as an Applicative and Alternative.
05:25:18 * hackagebot objective 0.0.2 - Extensible objects  http://hackage.haskell.org/package/objective-0.0.2 (FumiakiKinoshita)
05:25:36 <simpson> let f = foldr (\ma mb -> liftA2 (+) ma mb <|> mb) Nothing in f [Just 4, Nothing, Just 5]
05:25:43 <simpson> > let f = foldr (\ma mb -> liftA2 (+) ma mb <|> mb) Nothing in f [Just 4, Nothing, Just 5]
05:25:46 <lambdabot>  Nothing
05:25:53 <simpson> Ah, that's not what I wanted. Hm.
05:26:40 <simpson> Damn you, Maybe.
05:27:47 <orbisvicis> simpson: yeah I like that idea, I don't have to check for empty list first and case to Nothing, which is unnatural
05:29:49 <fizbin> > foldr1Of (folded . _Just) (+) [Just 4, Nothing, Just 5]
05:29:50 <lambdabot>  9
05:30:08 <fizbin> Oh, crud. That fails on all Nothing.
05:30:32 <simpson> orbisvicis: Case analysis is a natural part of writing Haskell.
05:31:01 <mroman_> That's exactly why I made class Box :) @foldr folded etc.
05:33:20 <aquifer> Hello, I am currently learning Monad tranformers but have become stuck trying to combine writer and state. Problem in the following paste: www.lpaste.net/111211. Thanks.
05:33:27 <fizbin> > msum [Just 4, Nothing, Just 5]
05:33:29 <lambdabot>  Just 4
05:34:13 <simpson> fizbin: You could wedge Sum underneath first.
05:34:28 <simpson> But orbisvicis wanted to be able to use any binary operation.
05:34:44 <fizbin> > let f op l = fmap (const $ Just $ foldr1Of (folded . _Just) op l) (msum l) in f (+) [Just 4, Nothing, Just 5]
05:34:46 <lambdabot>  Just (Just 9)
05:34:49 <orbisvicis> and MonadPlus discards the second Maybe
05:34:58 <orbisvicis> hm
05:35:02 <fizbin> > let f op l = fmap (const $ foldr1Of (folded . _Just) op l) (msum l) in f (+) [Just 4, Nothing, Just 5]
05:35:03 <lambdabot>  Just 9
05:35:27 <fizbin> > let f op l = fmap (const $ foldr1Of (folded . _Just) op l) (msum l) in f (+) [Nothing, Nothing, Nothing]
05:35:29 <lambdabot>  Nothing
05:35:37 <fizbin> Ugly. But, works...
05:35:59 <orbisvicis> simpson: anyway, what I mean is "[] -> Nothing" has no semantic meaning, where "maximum [] -> Nothing" does
05:36:37 <simpson> :t listToMaybe -- orbisvicis: Sure it does!
05:36:38 <lambdabot> [a] -> Maybe a
05:37:49 <mroman_> *Data.Box> (+) <<\>> [Just 1, Just 2, Just 3, Nothing]
05:37:50 <mroman_> Just 6
05:38:08 <simpson> My main point was that if you consider list as zero or more elements, and Maybe as zero or one element, then catMaybes is just simplifying what you've got without changing the meaning of it.
05:38:11 <orbisvicis> simpson: but the idea is to use maybe to represent a possibly unrepresentable answer (for operations like maximum), casing [] -> Nothing has no similar meaning, its just a workaround
05:38:19 <simpson> And that's a useful building block for the function that you eventually want.
05:38:21 <MasterMastic> Is it possible to coerce Num a => a -> Double?
05:39:26 <simpson> orbisvicis: Well, I suppose that it's working around how foldr1 requires a non-empty list...
05:39:39 <fizbin> > let f' op l = f op (catMaybes l); f' op l = fmap (\h -> foldr op (init l) h) (listToMaybe l) in f (+) [Just 4, Nothing, Just 5]
05:39:40 <lambdabot>  Ambiguous occurrence ‘f’
05:39:40 <lambdabot>  It could refer to either ‘L.f’, defined at L.hs:167:1
05:39:40 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.f’,
05:39:40 <lambdabot>                           imported from ‘Debug.SimpleReflect’ at L.hs:117:1-26
05:39:40 <lambdabot>                           (and originally defined in ‘simple-reflect-0.3.2:De...
05:39:42 <simpson> But I don't view that as a workaround. I view it as writing a total function by covering all casees.
05:39:57 <fizbin> > let f op l = f' op (catMaybes l); f' op l = fmap (\h -> foldr op (init l) h) (listToMaybe l) in f (+) [Just 4, Nothing, Just 5]
05:39:58 <lambdabot>  Occurs check: cannot construct the infinite type: a ~ [[a]]
05:39:59 <lambdabot>  Expected type: a -> [[a]] -> [[a]]
05:39:59 <lambdabot>    Actual type: a -> a -> a
05:40:20 <felixsch> is the maybe return type strictly required or would a zero also do the job?
05:42:13 <orbisvicis> simpson: true. I'm just trying to explain why I prefer your Applicative + Alternative idea
05:42:26 <simpson> orbisvicis: But the Applicative + Alternative idea *doesn't work*.
05:43:28 <orbisvicis> not yet
05:44:21 <fizbin> > let f op l = f' op (catMaybes l); f' op l = fmap (foldr op `flip` (init l)) (listToMaybe l) in f (+) [Just 4, Nothing, Just 5]
05:44:23 <lambdabot>  Just 8
05:44:35 <fizbin> > let f op l = f' op (catMaybes l); f' op l = fmap (foldr op `flip` (init l)) (listToMaybe $ reverse l) in f (+) [Just 4, Nothing, Just 5]
05:44:37 <lambdabot>  Just 9
05:44:58 <fizbin> > let f op l = f' op (catMaybes l); f' op l = fmap (foldr op `flip` (init l)) (listToMaybe $ reverse l) in f (+) [Nothing, Nothing, Nothing]
05:44:59 <lambdabot>  Nothing
05:46:13 <fizbin> So I think that the natural way to split this problem is to make something that does [] -> Nothing and [a, b, c, ...] -> Just (a `op` b `op` c ...), and then call that with (catMaybes l)
05:47:02 <danilo2> Hello! Is there any simmilar to expressions "@" syntax in type families? I want to write sometihng like: type family XOut m where XOut a@(ValueS vbase vs) = Out a
05:47:17 <fizbin> One such way to do it is f' above, but it might be more natural to do:
05:49:25 <mroman_> (http://codepad.org/IviuSDGw @ <<\>>)
05:49:30 <fizbin> > let f op l = g op (catMaybes l); g op [] = Nothing; g op [x] = Just x; g op (x:xs) = op x <$> g op xs in f (+) [Just 4, Just 5, Nothing]
05:49:31 <lambdabot>  Just 9
05:49:55 <mroman_> It's probably bad that it fails on [] though
05:51:43 <simpson> Okay, this objective library seems pretty interesting.
05:51:57 <simpson> fumieval: Your library looks nifty!
05:52:49 <fizbin> @define let foldr1Maybe = let g op [] = Nothing; g op [x] = Just x; g op (x:xs) = op x <$> g op xs in g
05:52:49 <lambdabot>  Parse failed: Parse error: EOF
05:54:55 <fizbin> @define foldr1Maybe = let { g op [] = Nothing; g op [x] = Just x; g op (x:xs) = op x <$> g op xs } in g
05:54:56 <lambdabot>  .L.hs:164:1:
05:54:56 <lambdabot>      Multiple declarations of ‘foldr1Maybe’
05:54:56 <lambdabot>      Declared at: .L.hs:163:1
05:54:56 <lambdabot>                   .L.hs:164:1
05:55:00 <fizbin> Crap.
05:55:12 <simpson> You might want to @undefine.
05:55:19 <fizbin> @define foldr1Maybe' = let { g op [] = Nothing; g op [x] = Just x; g op (x:xs) = op x <$> g op xs } in g
05:55:21 * hackagebot cmdargs 0.10.10 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.10.10 (NeilMitchell)
05:55:22 <lambdabot>  Defined.
05:55:27 <fizbin> @undefine foldr1Maybe
05:55:27 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
05:57:00 <mroman_> I guess f <<\>> xs = case filter (unboxable) xs of { [] -> head xs; _ -> f <\> (filter unboxable xs); }
05:57:08 <mroman_> is better.
05:57:15 <fizbin> @t f
05:57:15 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
05:57:24 <fizbin> @type f
05:57:25 <lambdabot>     Ambiguous occurrence ‘f’
05:57:25 <lambdabot>     It could refer to either ‘L.f’,
05:57:25 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:173:1
05:57:35 <fizbin> @type L.f
05:57:36 <lambdabot> Num t => t1 -> (t, t1)
05:57:51 <fizbin> f 'w'
05:57:56 <fizbin> > f 'r'
05:57:57 <lambdabot>  Ambiguous occurrence ‘f’
05:57:57 <lambdabot>  It could refer to either ‘L.f’, defined at L.hs:173:1
05:57:57 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.f’,
05:57:57 <lambdabot>                           imported from ‘Debug.SimpleReflect’ at L.hs:117:1-26
05:57:57 <lambdabot>                           (and originally defined in ‘simple-reflect-0.3.2:De...
05:58:04 <fizbin> > L.f 'r'
05:58:06 <lambdabot>  (4,'r')
05:58:36 <fizbin> Okay, gonna @undefine everything...
05:58:42 <fizbin> @undefine
05:58:42 <lambdabot> Undefined.
05:59:00 <fizbin> @define foldr1Maybe = let { g op [] = Nothing; g op [x] = Just x; g op (x:xs) = op x <$> g op xs } in g
05:59:02 <lambdabot>  Defined.
05:59:52 <fizbin> @pl \op l -> foldr1Maybe op (catMaybes l)
05:59:52 <lambdabot> (. catMaybes) . foldr1Maybe
06:00:28 <fizbin> > ((. catMaybes) . foldr1Maybe) (+) [Just 5, Nothing, Just 4, Nothing]
06:00:29 <lambdabot>  Just 9
06:01:05 <fizbin> > ((. catMaybes) . foldr1Maybe) (+) [Nothing, Nothing, Nothing, Nothing]
06:01:07 <lambdabot>  Nothing
06:02:06 <fizbin> orbisvicis: I think that's the most natural way to do it.
06:12:07 <adas> none of the persistent libraries have links to their documentation in their respective hackage pages. I searched docs for plain "persistent", "persistent-sqlite" and "persistent-template". But none of their hackage pages have links to their documentation.
06:12:13 <adas> could someone please tell me whats going on?
06:12:33 <adas> earlier I used to be able to get the documentation of a package on its respective hackage page
06:12:55 <bergmark> adas: the hackage doc builder is offline
06:13:17 <bergmark> you can build the docs yourself with eg standalone-haddock
06:13:18 <NikolajK> Can someone point me to a universal lambda expression - i.e. the lambda that tells me the calculus is Turing complete.
06:13:27 <fizbin> Some older versions have docs links, e.g.: http://hackage.haskell.org/package/persistent-2.0.0.1
06:13:56 <NikolajK> i.e. the equivalent to a universal turing machine. This lambda term takes other lambda terms and encoded input and computes according to the passed lambda - for any program
06:14:28 <adas> bergmark: but the docs for other packages are available on their hackage pages..
06:14:32 <adas> example "warp"
06:15:13 <adas> bergmark: any idea when it might be back online?
06:15:21 <fizbin> adas: I assume that's because those older packages haven't been updated since the hackage doc builder went offline.
06:15:30 <adas> oh
06:15:33 <bergmark> adas: check the upload times
06:15:38 <fizbin> adas: As I said, if you go back a few versions, you find doc links.
06:15:42 <bergmark> you can also upload custom documentation
06:16:01 <adas> so how is everyone else managing without the docs? building it themselves?
06:16:47 <fizbin> Or the library authors are uploading docs when they upload their package.
06:18:04 <fizbin> E.g. lens is updated frequently, but it has docs so I assume ekmett uploads docs with his library updates.
06:18:36 <adas> so if I had to build the docs myself ... i download the package.tar.gz file, extract it and run haddock?
06:18:56 <alpounet> if you uncomment "documentation: True" in your ~/.cabal/config, cabal will systematically build the docs of the packages you cabal install
06:19:07 <alpounet> so you'll have a local copy of the docs for any packagey ou install
06:20:43 <adas> oh okay.. thanks. i will try that.
06:20:55 <adas> alpounet: what if im using cabal sandboxes?
06:22:42 <adas> because cabal sandboxes use different config files
06:23:56 <adas> and there doesn't seem to be a config file in a sandbox
06:24:20 <orbisvicis> > let f f n m = ((f <$> m) <*> n) <|> m <|> n in foldr (f (+)) Nothing [Just 4, Nothing, Just 5] -- simpson
06:24:21 <lambdabot>  Just 9
06:24:33 <simpson> orbisvicis: Hm.
06:24:38 <orbisvicis> simpson: granted I found this via google, but it took me a while to understand
06:24:41 <hexagoxel> adas: cabal will use the ~/.cabal/config no matter whether you are in sandbox or not
06:24:51 <mitu>  ókei
06:25:03 <mitu> (wrong window)
06:25:07 <adas> hexagoxel: oh.. thanks.
06:25:13 <Iceland_jack> mitu: :)
06:25:23 <alpounet> adas: you can make that happen on a per-sandbox basis I think. cabal.sandbox.config is the equivalent of ~/.cabal/config, but just for that sandbox you're in
06:25:41 <hexagoxel> adas: however, with sandboxes, docs go into /dist, which might not be what you want
06:25:52 <fizbin> orbisvicis: The parens around f <$> m are unnecessary.
06:26:15 <alpounet> adas: however, this file is generated. so if you want to customize some cabal behaviors, just create a 'cabal.config' file in the root dir of your project, just next to .cabal-sandbox
06:26:21 <alpounet> with these specific options you want
06:26:21 <orbisvicis> fizbin: yeah, just used that to get my head around the order
06:26:21 <fizbin> f <$> m <*> n is the operator-centric idiom for liftA2 f m n
06:26:51 <alpounet> adamse: echo "documentation: True" > cabal.config    should do the trick
06:27:33 <alpounet> err, s/adamse/adas
06:27:34 <orbisvicis> fizbin: oh
06:27:42 <fizbin> @pl \f m n -> (f <$> m <*> n) <|> m <|> n
06:27:42 <lambdabot> flip flip id . (liftM2 (<|>) .) . join . ((flip . ((<|>) .)) .) . (. (<*>)) . (.) . (<$>)
06:27:47 <fizbin> Ew.
06:27:50 <alpounet> adas: alternatively, you could do cabal install --enable-documentation
06:27:57 <fizbin> Sometimes @pl is just nasty...
06:28:31 <adas> alpounet: --enable-documentation sounds easy. but does it install the docs in the sandbox?
06:29:06 <alpounet> adas: I think so yes. you should bookmark this, for reference: http://stackoverflow.com/a/20025842/193424
06:30:10 <fumieval> Fumiaki
06:30:19 <remdezx> Hello! :) Is it possible to get using TemplateHaskell the name of the function where TH was executed? I want to do something like tst :: String; tst = $(getMyName) and in the result tst would be "tst" ?
06:30:58 <adas> alpounet: thanks for that link
06:31:30 <alpounet> adas: np :) that should make life easier until hackage is back in a good shape
06:32:02 <fumieval> simpson: the revelation just surprised me
06:33:21 <frerich> clemens: Turns out your binary package doesn't work for me either, but my 5.1 build as of today does.
06:33:31 <fumieval> simpson: this is my third attempt to achieve OOP, and it will be the best
06:33:37 <frerich> oops, wrong channel.
06:35:12 <adas> alpounet: any idea what happened to hackage?
06:35:37 <simpson> fumieval: Best of luck. I wrote up a toy implementation of Monte (essentially E) in Haskell, but it was pretty difficult to maintain due to the mutability requirements.
06:37:59 <alpounet> adas: these past few weeks, the package and doc builders were lagging behind and the sever on which hackage was run had insane peeks of CPU and memory usage, IIRC. this is all little by little moving to a new infrastructure on new servers.
06:38:21 <alpounet> adas: i haven't followed that closely, so if you want more details, you may want to ask on #hackage
06:41:47 <fumieval> simpson: mutability have been bothering us...
06:42:25 <fumieval> simpson BTW, if you're interested, see https://github.com/fumieval/call/blob/master/examples/hello-world.hs
06:42:35 <fumieval> it is based on objective package
07:04:24 <blogle> Does haskell have some toolset thats good for data analysis, akin to scipy / pandas?
07:05:52 <Qfwfq> blogle: Not really. sdiehl's working on a library for data frames, there's some support for iPython-style notebooks, but it's mostly all ad-hoc, AFAICT.
07:06:33 <volume_dial> hey
07:06:42 <Qfwfq> There're tools on Hackage, but no real toolset.
07:08:37 <blogle> I am curious why there isn't a larger community interest. Is Haskell not a good environment for data analysis?
07:09:19 <tdammers> I think data analysts tend to prefer more purpose-specific environments
07:09:34 <tdammers> haskell is really a general-purpose language
07:09:48 <Qfwfq> I don't feel it's good for EDA, no. I feel like too much strictness gets in the way here, especially when it comes to the different numeric types. I might be in the minority, though, I haven't spoken to many people about this.
07:09:56 <volume_dial> what do I need to do to get `cabal-install repa-devil" to work? Where does it look for the DevIL dlls on Windows?
07:10:35 <Qfwfq> Where Haskell excels in data analysis is in describing efficient and easily parallelised operations, and mostly that comes in when you're operating on larger collections.
07:10:59 <fizbin> But that's not what you'll see when looking at ad-hoc data analysis.
07:11:05 <Qfwfq> And those only come in when you know how you're approaching the problem?
07:12:17 <Qfwfq> So play with approaches on smaller samples in R or SciPy, then move to Haskell when you better know what you're doing.
07:13:57 <Saizan> i started to think that one big reason haskell often lacks a polished solution to X is that there's no big corporate backing behind haskell development, and making everything work really nicely together is mostly a job rather than an interesting hacking opportunity
07:14:24 <Guest-54122> hey everybody
07:14:38 <volume_dial> hey
07:15:43 <Qfwfq> Saizan: OCaml has Jane Street behind it, and I think that case supports your point.
07:17:34 <Saizan> Qfwfq: mh, there are similar industrial users of haskell though, i was thinking more of someone in charge of the language itself, but i guess python doesn't have that either?
07:17:54 <Saizan> s/someone/some company/
07:18:00 <benzrf> i thought jane street uses haskell
07:18:12 <Qfwfq> Saizan: Guido is at Google, as I understand it working on Python development exclusively.
07:18:34 <volume_dial> gah. does someone have a moment spare to help me?
07:19:18 <Qfwfq> Oh, he's at Dropbox now.
07:21:44 <blogle> I am trying to imagine a hybrid of pandas and haskell. Nums would need to be weakly typed for practicallity
07:21:53 <orbisvicis> in ghci using haskeline in vi-mode, entering normal mode takes several seconds ~(1.5 - 2). is there a timeout option, or is it just slow
07:23:08 <k00mi> volume_dial: sadly few people here know their way around windows
07:25:28 * hackagebot Ketchup 0.4.0 - A super small web framework for those who don't like big and fancy codebases  http://hackage.haskell.org/package/Ketchup-0.4.0 (Hamcha)
07:25:38 <geekosaur> probably just slow. it's actually harder than you might think, because most function keys start with an escape character so it has to wait to make sure the escape is actually intended to be just an escape
07:25:41 <volume_dial> k00mi: damn it. how do you properly tell cabal where a library's dll resides? I can't seem to do it
07:25:55 <geekosaur> some programs are more paranoid about waiting than others
07:26:07 <Qfwfq> volume_dial: Maybe run 'cabal' at high verbosity, and see which 'ghc' commands it executes.
07:27:53 <pjdelport> If it's escape sequences, you can try :set ttimeoutlen=100
07:28:36 <pjdelport> That makes vim used a reduced timeout for escape sequences (100 ms above), compared to user mappings ('timeoutlen', default 1000 ms)
07:28:47 <geekosaur> pjdelport, haskeline, not vim?
07:28:50 <orbisvicis> geekosaur: hm just compared with bash/readline and indeed it does take a while however unlike haskeline any normal mode entries during the waiting period after pressing escape don't cancel normal mode
07:29:21 <pjdelport> geekosaur: Haha, oops. Sorry.
07:29:22 <orbisvicis> btw do waiting for other possible escape sequences actually matter in vi mode?
07:29:22 <geekosaur> yes. haskeline isn't very smart
07:29:55 <geekosaur> orbisvicis, arrow keys also start with escape
07:30:02 <orbisvicis> heh
07:30:27 <geekosaur> right arrow is <ESC> [ C in most terminal emulators, for example
07:30:30 <orbisvicis> in that case reducing the timeout sounds like a good idea
07:30:40 <orbisvicis> i'll give that a shot
07:31:45 <geekosaur> there used to be a way to build ghci with readline. windows and os x were both major pain points, so haskeline was written and made the standard; I don't know if ghci even has code for actual readline any more
07:31:49 <orbisvicis> oh, haskeline has no timeoutlen, i think ?
07:31:55 <geekosaur> right
07:32:18 <geekosaur> pjdelport was giving you instructions to change the timeout in vim. but they only work in vim
07:32:31 <pjdelport> Yeah, disregard that, sorry.
07:34:27 <geekosaur> current haskeline doesnt provide a way to set the timeout that I can see
07:35:48 <syllogismos> I want (**) like function whose type sig is (Integer a, Fractional b) => a -> b -> b
07:35:56 <syllogismos> what to do?
07:36:00 <syllogismos> :t (^^)
07:36:01 <lambdabot> (Integral b, Fractional a) => a -> b -> a
07:36:13 <syllogismos> :t (**)
07:36:14 <lambdabot> Floating a => a -> a -> a
07:39:01 <danilo2> Hello! Is there any simmilar to expressions "@" syntax in type families? I want to write sometihng like: type family XOut m where XOut a@(ValueS vbase vs) = Out a
07:39:57 <geekosaur> no, probably because just typing stuff isn't really seen to be a reason to add it whereas it has actual meaning in value patterns (sharing, ensuring the exact same type)
07:41:23 <matheus23> I have a local cabal project (call that "A") that I cabal install-ed. I have another local cabal project that works in a sandbox (call it "B"). How can I "cabal install A" in project "B", which is in a sandbox?
07:41:36 <matheus23> I don't know how to google this
07:41:38 <pjdelport> :t (**) . fromIntegral
07:41:39 <lambdabot> (Integral a, Floating b) => a -> b -> b
07:41:57 <pjdelport> syllogismos: That might be the closest you can easily get, i think.
07:42:27 <danilo2> geekosaur: It makes a little sense to me - when I've got a closed type family and I want it to handle some arguments and then use the same arguments on the right hand side, now I'm writing a LOT of the same code, for example: "XOut (ValueS vbase vs) (MonadCtx2Dummy' m2 s2 env set m s) = MonadCtx2Dummy' m2 s2 (XEnv env (ValueS vbase vs)) (XSet set (ValueS vbase vs)) m (XSafety s (ValueS vbase vs))"
07:43:00 <geekosaur> you can make a proposal...
07:43:13 <danilo2> geekosaur: could be written as "XOut a@(ValueS vbase vs) (MonadCtx2Dummy' m2 s2 env set m s) = MonadCtx2Dummy' m2 s2 (XEnv env a) (XSet set a) m (XSafety s a)
07:43:35 <danilo2> geekosaur: I know - I was thinking about it, but firstly I wanted to ensure it is not available someow :)
07:44:09 <danilo2> geekosaur: Could you tell me please what is the name of the "@" mechanism?
07:44:18 <geekosaur> as-patterns
07:44:40 <danilo2> geekosaur: Thank you! :)
07:45:52 <geekosaur> and I think you'll find there's probably opportunities for a lot of stuff like this that hasn't been thought about much because the type level machinery has been changing so much and is still fairly new
07:47:10 <ij> Do any other monoids exist for [] other than ++?
07:47:24 <albeit> Is there a better way to do this? case foo of; Nothing -> Nothing; Just (Bar a) -> Just a
07:47:25 <volume_dial> anyone in here have any idea what to do when cabal-install fails because it can't find a C library (Windows)? I'm at my wit's end now.
07:48:11 <silver> volume_dial, is that library installed?
07:48:26 <ion> albeit: fmap unBar
07:48:37 <ion> unBar (Bar a) = a
07:48:50 <syllogismos> pjdelport i have to modify this function a little and I need to use power function, but I don't want to add additional type constraint of Floating a, it already has Fractional a
07:49:00 <albeit> ion: Okay, so I need a custom function then
07:49:00 <syllogismos> Should I just add Floating a and use (**)?
07:49:16 <ion> albeit: No, you can use an ad-hoc lambda expression instead.
07:49:21 <danilo2> geekosaur: I reported is as a feature request. I'm writing just to let you know. If you would like to see it, here it is: https://ghc.haskell.org/trac/ghc/ticket/9608 :)
07:49:22 <ion> That was just an example.
07:49:47 <ion> I was thinking you might have had unBar already.
07:49:55 <volume_dial> silver: how would you install a library on Windows? it's just a set of dll files and include headers
07:50:18 <silver> it depends on the library
07:50:33 <silver> you might need to compile it
07:50:33 <volume_dial> DevIL (for repa-devil)
07:51:06 <geekosaur> volume_dial, that's kinda the problem. unixlikes have library paths. windows does it differently, plus the only thing resembling a standard is to drop stuff in the windows system dll directory --- which is not at all recommended for application libraries
07:51:31 <geekosaur> (because $DEITY help you if different apps require different versions of some library)
07:51:59 <volume_dial> geekosaur: would you suggest plopping the directory in the PATH temporarily or something?
07:52:04 <silver> geekosaur, will cygwin solve this problem?
07:52:12 <fryguybob> volume_dial: There are cabal flags for where it will search
07:52:17 <geekosaur> %PATH% doesn't help for libraries
07:52:56 <volume_dial> fryguybob: using --extra-lib-dirs doesn't seem to do anything. I feed it the directory of the extracted zip archive with the dll files in
07:53:17 <geekosaur> cygwin can help, but it can also just as easily leave you with a "now you have two problems" situation
07:54:23 <fryguybob> volume_dial: There is also --extra-include-dirs.  If the library needs to be loaded as it compiles it would need to be local or in the path.
07:54:27 <pjdelport> syllogismos: I don't think you can really avoid it: both (^) and (^^) can only raise to Integral exponents.
07:54:33 <silver> sadly DevIL not in the cygwin's repository
07:55:07 <fryguybob> volume_dial: Also some packages use other systems, like gtk2hs looks for a program to be in the path that will tell it the correct paths to use.
07:55:30 <pjdelport> syllogismos: So for a Fractional exponent, you either have to specialize it to Floating to use (**), or you need to round it to integral to use (^) or (^^)
07:56:03 <volume_dial> fryguybob: do you want the log of the install? I can't fathom it, other than the error happens in at ld (linker?)
07:56:29 <fryguybob> volume_dial: lpaste.net
07:56:42 <fryguybob> volume_dial: I'll look at it, but I don't know how much I can help :D
07:57:05 <silver> volume_dial, http://openil.sourceforge.net/ check this out, there are some kind of windows builds
07:57:37 <silver> hopefully with proper installers
07:58:12 <lpaste> volume_dial pasted “Can't find IL” at http://lpaste.net/111217
07:59:25 <arianvp> Guys, say I have a general "Component" and I want more specialized components to be made by the user of my lib
07:59:31 <arianvp> I've seen two approaches here
07:59:48 <arianvp> use record syntax, or use typeclasses (Yesod uses typeclasses for this)
07:59:52 <silver> it basically said you need a lib to be installed and/or pointed to
08:00:00 <arianvp> Component { run = newFunction }
08:00:10 <arianvp> vs  instance Component MyComponent where run = newFunction
08:00:18 <arianvp> what is more idiomatic?
08:01:45 <fryguybob> volume_dial: Is your GHC 32-bit or 64-bit?
08:02:25 <volume_dial> fryguybob: should be 64bit, installed 64bit haskell platform
08:04:03 <fryguybob> volume_dial: Trying it myself here...
08:04:17 <volume_dial> fryguybob: thanks :D
08:06:08 <Isabella23>  Here some videos. I hope you like them! http://tinyurl.com/ozfvxy3
08:10:41 <fryguybob> volume_dial: I had to rename the file from ILU.dll and ILU.lib to libIL.dll and libIL.lib, then it found it with --extra-lib-dir pointing to the lib folder under where I unziped C:\...\DevIO-SDK-x86-1.7.8\lib
08:11:13 <volume_dial> fryguybob: thanks, I'll give that a go
08:11:32 <silver> heh
08:11:45 <silver> iteresting
08:12:01 <fryguybob> volume_dial: You may still need those files (and perhaps all of the other dlls without new names) in the path depending on what sort of linking it is doing.
08:12:11 <fryguybob> for when you want to actually run the program that is.
08:13:35 <fryguybob> volume_dial: Also (not sure how critical it is) but I used the link from here: http://openil.sourceforge.net/download.php labeled ".dll, .lib, .h"
08:13:54 <fryguybob> volume_dial: It probably is only the .lib file that needs the different name.
08:14:41 <fryguybob> volume_dial: And finally I had both --extra-lib-dir and --extra-include-dir going to ...\lib and ...\include.
08:15:16 <fryguybob> This isn't a problem in this case based on the log, but experience tells me to not try this with a path that has a space in it...
08:15:32 * hackagebot yahoo-finance-conduit 0.1.0.0 - Streaming aproach to the yahoo finance api  http://hackage.haskell.org/package/yahoo-finance-conduit-0.1.0.0 (AlexanderThiemann)
08:15:41 <silver> http://stackoverflow.com/questions/6561273/is-liblibrary-name-a-so-a-naming-convention-for-static-libraries-in-linux
08:16:00 <volume_dial> fryguybob: You got it, thank you so much. Renamed copies of the ILU.dll and ILU.lib files and gave it the /include directory.
08:20:33 * hackagebot esqueleto 2.0.1 - Type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-2.0.1 (FelipeLessa)
08:30:34 * hackagebot yesod-auth-oauth2 0.0.8 - Library to authenticate with OAuth 2.0 for Yesod web applications.  http://hackage.haskell.org/package/yesod-auth-oauth2-0.0.8 (PatrickBrisbin)
08:34:36 <dgpratt> so I'm looking at http://conway.rutgers.edu/~ccshan/wiki/blog/posts/WordNumbers2/
08:35:13 <dgpratt> and not having a math background of any sort, I suppose you wouldn't be surprised if I said I was struggling to understand it
08:35:25 <dgpratt> but I haven't completely given up yet
08:36:06 <dgpratt> in particular, I'm struggling to understand the Monoid and Seminearring instances for Deriv
08:36:47 <dgpratt> I don't see the connection between what is declared there and the associated laws for derivatives
08:38:41 <dgpratt> the one for addition *could* make sense to me if I imagine flipping the terms, but I'm not at all sure that's the right way to think about it
08:45:35 * hackagebot chatter 0.2.0.1 - A library of simple NLP algorithms.  http://hackage.haskell.org/package/chatter-0.2.0.1 (RoganCreswick)
08:45:40 <seahorse2> who are the main people involved in the development of Haskell?
08:50:35 * hackagebot unlit 0.1.1.0 - Tool to convert literate code between styles or to code.  http://hackage.haskell.org/package/unlit-0.1.1.0 (pepijnkokke)
08:51:29 <albeit> :t \a -> a {key=val}
08:51:31 <lambdabot> ‘key’ is not a (visible) constructor field name
08:51:31 <lambdabot>     Not in scope: ‘val’
08:51:31 <lambdabot>     Perhaps you meant one of these:
08:51:54 <albeit> Is "{key=val}" valid syntax for a lambda function to update a record field?
08:52:43 <bergmark> albeit: `a { key = val }' is valid syntactically but requires that `a' has a field named `key'
08:53:24 <Saizan> dgpratt: in Deriv the two fields are supposed to be f(x) and f'(x), what's the derivative of (f(x) + g(x))? it's (f'(x) + g'(x))
08:53:55 <albeit> bergmark: Okay, but does it work in a case like "maybe zeroA {key=val} maybeA"?
08:54:15 <albeit> (Assuming key is record of the datatype A)
08:54:18 <bergmark> albeit: partially applying the record update? no
08:54:34 <albeit> bergmark: Ah yes partially applying, thats the term I was looking for. Okay thanks!
08:55:36 * hackagebot twentefp-trees 0.1.0.1 - Tree type and show functions for lab assignment of University of Twente. Contains RoseTree and ParseTree  http://hackage.haskell.org/package/twentefp-trees-0.1.0.1 (sebaslafleur)
09:10:33 <Taneb> With this week's quotes of the week, motion to give edwardk the title "Simon"
09:10:42 <edwardk> hahahahaha
09:11:03 <coppro> Taneb: seconded
09:12:15 <simpson> Sounds about right.
09:15:34 <joelteon> SimonK
09:15:37 * hackagebot unlit 0.1.2.0 - Tool to convert literate code between styles or to code.  http://hackage.haskell.org/package/unlit-0.1.2.0 (pepijnkokke)
09:19:11 <lpaste> bryanvick pasted “case analysis on known exception types” at http://lpaste.net/111220
09:19:43 <joelteon> bryanvick: that's what fromException is for
09:19:55 <joelteon> :t fromException
09:19:56 <lambdabot> Exception e => SomeException -> Maybe e
09:20:18 <joelteon> alternatively, you can just put the exception type itself in your catch
09:20:19 <bryanvick> joelteon: thank you, I'll look into it
09:20:27 <joelteon> is catchAll in base? i forget
09:20:38 * hackagebot clock 0.4.1.1 - High-resolution clock functions: monotonic, realtime, cputime.  http://hackage.haskell.org/package/clock-0.4.1.1 (CetinSert)
09:20:45 <joelteon> best practice as always is to only catch the exceptions you NEED to ach
09:20:46 <joelteon> catch
09:20:47 <bryanvick> joelteon: I don't see it, it was a hypothetical
09:21:11 <joelteon> and in that case you can use something `catch` (\(MyException e) -> ...)
09:21:17 <bryanvick> There are a couple exception types I know may occur, and I want to respond to those, and then have a catchall at the end
09:21:27 <joelteon> why do you want to catch all exceptions?
09:21:38 <joelteon> that could include things like user interrupt, OOM, etc.
09:21:44 <bryanvick> web app, want to show the user something nice in all cases
09:21:50 <joelteon> i see
09:22:02 <joelteon> okay, that is a pretty good use case
09:22:14 <joelteon> bryanvick: i'll paste something
09:22:16 <supki> bryanvick: Control.Exception.catches is an option too
09:22:22 <bryanvick> joelteon: thank you
09:22:30 <joelteon> catches adds multiple handlers, right
09:23:07 <bryanvick> catches looks nice!  didn't see that
09:23:29 <joelteon> ok i wont actually paste anything, having internet troubles
09:23:32 <joelteon> but yeah, catches
09:24:54 <bryanvick> sidenote: is there any theoretical barrier to a haskell implementation where all functions are total?  So there are no exceptions, everything is wrapped up in a constructor?
09:25:21 --- topic: set to 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://is.gd/xJt4FF' by ChanServ
09:25:26 <Iceland_jack> bryanvick: well it wouldn't be Haskell for starters :)
09:25:36 <Iceland_jack> but there are papers on "total Haskell"
09:25:53 <albeit> If I have different threads writing to the standard output, is there any way to buffer them so they don't write at the same time resulting in mangled output?
09:26:13 <Iceland_jack> bryanvick: http://www.eis.mdx.ac.uk/staffpages/dat/sblp1.pdf
09:26:14 <joelteon> albeit: have them both write to a Chan instead, and fork a thread to read from the Chan and print the contents to stdout
09:26:15 <glguy> bryanvick: Being total also means termination checking
09:26:39 <amf> is there a name for the technique of reducing a list to a list of equal or smaller length?
09:26:40 <bryanvick> glguy: ah, I see
09:26:58 <albeit> joelteon: Hmm I already have a logger that they send messages to after connection, but its just on the initial startup.. I'd rather not have to pass  a Chan to all of them
09:27:25 <simpson> Total Haskell couldn't have useful combinators like fix or forever, IIUC, unless they were special-cased.
09:27:26 <joelteon> if you don't make sure they don't trample each other yourself, then no, there is no way to do it
09:27:34 <zalatovo> My haskell-mode in Emacs displays a weird help message whenever I try to use <TAB> to indent: https://i.imgur.com/OQ0IsAB.png anyone know what is going on?
09:27:35 <albeit> Okay
09:28:10 <zalatovo> relevant lines in .emacs: http://lpaste.net/243167085360840704
09:28:50 <Iceland_jack> bryanvick: Try programming in Agda and Idris in total mode and come back and say if it's worth it :)
09:29:01 <joelteon> nobody spoil it
09:29:16 <bryanvick> Iceland_jack: I'm off to the promised land!
09:29:25 <Iceland_jack> I'm not sure I like the sound of that :)
09:29:58 <lecoeus> zalatovo: I get the same message sometimes
09:29:59 <zalatovo> Never mind, it's working again, seemingly without me doing anything but adding lines back to my .emacs that I removed to see what the problem was
09:30:00 <bryanvick> Iceland_jack: Maybe I can play with those dependent types I keep hearing about as well
09:30:03 <lecoeus> it might be because of the indent mode
09:30:12 <Shockk> hello, I'm having a bit of trouble with my haskell code; I think it's something I'm doing wrong with SafeCopy but I'm not certain
09:30:16 <Iceland_jack> bryanvick: That part is frankly more interesting than the totality
09:30:17 <Shockk> https://gist.github.com/shockkolate/a120b988f8f012affa62
09:30:39 * hackagebot unlit 0.1.2.1 - Tool to convert literate code between styles or to code.  http://hackage.haskell.org/package/unlit-0.1.2.1 (pepijnkokke)
09:30:40 <Shockk> my issue is that on line #2 with updateDB, my program hangs
09:30:48 <Iceland_jack> Totality is a 'necessary' evil for soundness if you're using your language is a theorem prover
09:30:52 <amf> zalatovo: i found https://github.com/serras/emacs-haskell-tutorial to be the best guide for a sane setup
09:31:03 <Iceland_jack> but that's not Haskell
09:31:08 <monochrom> it is not evil. but it is more work.
09:31:16 <Iceland_jack> Yes
09:31:32 <Iceland_jack> And in some cases it's a lot more work
09:31:34 <monochrom> a logician would say: fix is evil :)
09:31:47 <zalatovo> amf: Thanks for the link
09:32:53 <{AS}> How would a total version of fix look like?
09:33:15 <Iceland_jack> You can make a "bounded" version of fix
09:33:16 <joelteon> fix f = f
09:33:19 <Iceland_jack> lol
09:33:40 <{AS}> Iceland_jack: Yeah how :)
09:34:10 <Iceland_jack> {AS}: Quite boring, you can specify how many recursive calls you're allowed
09:34:23 <{AS}> Ah, you mean the "fuel" approach :)
09:34:27 <Iceland_jack> yeah
09:34:35 <monochrom> a total version of fix would take one more parameter: a proof of why this recursion is total
09:34:55 <{AS}> monochrom: Yeah, that was more like what I thought
09:35:03 <{AS}> but how would such proof look like :D
09:35:11 <monochrom> that is up to the language
09:35:13 <{AS}> or signature of proof actually
09:35:22 <{AS}> let us say we use Agda
09:35:31 <monochrom> I don't know Agda.
09:35:48 <monochrom> in HOL4, you prove well-ordering
09:35:49 <{AS}> OK, thanks anyway
09:42:47 <meretrix> How would you recommend implementing a threadDelay function that is controlled manually, i.e., I would manually feed it tick events to advance time?
09:43:09 <meretrix> The idea is to swap in this function for testing purposes so I can quickly advance time.
09:43:52 <monochrom> how do you want to provide ticks? by pressing return at stdin?
09:44:58 <meretrix> monochrom: I would feed in timestamps from a pre-generated list.
09:45:32 <monochrom> where do you want to store the list? in stdin?
09:45:53 <meretrix> I'd read it in from a database table.
09:46:44 <monochrom> ok, so connect to the database, send a query to read the table
09:47:26 <meretrix> Yeah.  Then each threadDelay function would check whether the most recent timestamp is later than it's scheduled sleep time.
09:47:55 <meretrix> If the timestamp is later, then threadDelay would stop blocking and return.
09:48:11 <c_wraith> I recommend an MVar () for the blocking
09:48:50 <Shockk> aha, I solved my problem with SafeCopy by using the template haskell function deriveSafeCopy
09:49:44 <meretrix> c_wraith: That could work.  Each threadDelay function could send the MVars to a central scheduler that would listen to the timestamps and trigger the MVar.
09:50:06 <meretrix> I guess I would need to use a Chan for communication.
09:50:20 <c_wraith> Why would you need that?
09:50:43 <meretrix> c_wraith: How would the threadDelay function register its MVar with the scheduler?
09:51:29 <c_wraith> meretrix: if the scheduler keeps a priority queue in an MVar, the threadDelay functions could just insert themselves into it.
09:52:35 <meretrix> Ah I see.  I still need to pass the schedular around though.
09:52:52 <meretrix> So each threadDelay function gets its MVar
09:53:02 <meretrix> Or use unsafeIO since it's just for testing...
09:53:12 <c_wraith> meretrix: alternatively you could pass the threadDelay function around.
09:53:24 <meretrix> Yeah
09:54:56 <c_wraith> meretrix: have you considered writing a custom DSL as a free/operational monad, so you could have a simpler uniform interface with different production/testing interpreters?
09:56:02 <meretrix> c_wraith: Would that just be like using a state monad?
09:57:08 <meretrix> Ah just found this: http://programmers.stackexchange.com/questions/242795/what-is-the-free-monad-interpreter-pattern
09:57:28 <c_wraith> I think http://apfelmus.nfshost.com/articles/operational-monad.html is a good intro, too
09:57:56 <meretrix> thanks
09:59:26 <infandum> I have an optimization issue: this code at http://pastebin.com/8BX0k2Fd is incredibly slow and takes up a ton of memory (34.4% and 44.7% for time and allocation , respectively). Is there a way to speed it up? It looks for two strings in a set essentially.
09:59:30 <c_wraith> meretrix: the two approaches are equivalent, they just provide slightly different APIs
10:00:12 <pjdelport> infandum: Have you tried a HashSet?
10:00:13 <c_wraith> infandum: wow, importing Data.Set as ST is *really* confusing.
10:00:59 <pjdelport> indigo: Comparison-based Sets/Maps and String keys are usually not a good combination.
10:01:00 <infandum> c_wraith: Oh sorry. I never use STs and S conflicts with Sequence for me, and I didn't even know about STs until later. I now just import it as Set
10:01:47 <c_wraith> infandum: I'd strongly consider a different way of structuring the data so that you don't need to do linear searches.
10:02:09 <infandum> c_wraith: It shouldn't be linear--it's a set of sets
10:02:22 <c_wraith> F.any is a linear search
10:02:44 <pjdelport> infandum: Don't you want a a Map?
10:03:09 <pjdelport> Map String (Double, Int), perhaps?
10:03:45 <infandum> pjdelport: This data structure is used elsewhere and is actually inside of a map so I don't want to risk changing it quite yet
10:04:13 <pjdelport> infandum: You can't avoid a linear search with the current structure, i think.
10:04:25 <infandum> pjdelport: Also, it wouldn't matter, right? Don't they both use trees?
10:04:45 <NemesisD> newtype PortNumber = PortNum Word16. show (PortNum 6739) => 60184. WUT
10:04:58 <c_wraith> NemesisD: byte order
10:05:01 <pjdelport> Well, as c_wraith pointed out, the internal structure doesn't matter: F.any just does a linear search.
10:05:06 <infandum> hm
10:05:12 <c_wraith> NemesisD: never use the PortNum constructor
10:05:27 <ClaudiusMaximus> NemesisD: show (6739 :: PortNumber)
10:05:39 <infandum> pjdelport: Is there a way to fold across the data set and just stop when I'm satisfied? Is there a way to break the loop?
10:05:41 <NemesisD> c_wraith, use the intToPortNumber then?
10:06:00 <pjdelport> infandum: Membership testing is logarithm with Set, but you can only do for a full tuple, with that representation.
10:06:01 <c_wraith> NemesisD: or as ClaudiusMaximus points out, the Num instance's fromInteger
10:06:02 <infandum> I guess the biggest issue for me is the memory usage
10:06:24 <pjdelport> infandum: F.any probably does that already; but that's still linear.
10:06:32 <NemesisD> ah. man why do they export PortNum then
10:06:49 <infandum> pjdelport: Hmm. Any idea why is would be sucking up a bunch of memory?
10:07:17 <c_wraith> NemesisD: no idea
10:07:18 <pjdelport> If you have lots of Strings, that might contribute (String is not very memory-efficient)
10:07:28 <pjdelport> Text is better
10:07:43 <Fuuzetsu> I read yesterday that a single Char is from 20 to 40 bytes.
10:07:49 <infandum> pjdelport: I think in my original code it is text actually, I used string here for simplicity
10:08:08 <infandum> pjdelport: But like, ALL of the memory in the program is in this one function
10:08:23 <infandum> pjdelport and there must be hundreds and hundreds of functions
10:08:34 <c_wraith> infandum: I'd suspect the sets aren't actually fully forced, and that function is only blamed for the memory use because it's the only thing forcing the sets
10:08:56 <infandum> c_wraith: That's probably it. harumph
10:09:24 <Fuuzetsu> for a function this small you could easily read the Core output
10:11:55 <infandum> On huge, and I mean HUGE data sets, I get a segfault and I think it must be due to this (no outside calls or anything in the code). I ran a trace with -xc but it segfaulted with no output so I can't use that like normal to see where it's happening
10:12:19 <infandum> I still think it's due to this function, though. I feel like sets use up a ton of memory compared to other structures
10:14:31 <pjdelport> infandum: Can you reduce the problem to a stand-alone program snippet?
10:15:21 <Qfwfq> "Context reduction stack overflow;" Fuuuuuuuunnnn..
10:15:27 <infandum> pjdelport: I'm not sure. The program puts the data through many transformations and I don't know what will happen if I remove certain modules
10:15:59 <pjdelport> infandum: Is it up in a repo or somewhere? Perhaps someone can take a look at it there.
10:16:45 <pjdelport> infandum: Failing that, the next thing to try is probably to make the set definition more strict.
10:16:53 <infandum> pjdelport: Do you think it would be faster and more memory efficient to expand the set (map fst') and then concat them all and then do the members with no any? That's m + n for the concat though times the total number...
10:17:12 <infandum> It's not open source yet unfortunately
10:17:17 <infandum> soon
10:17:18 <infandum> very soon
10:17:54 <marvimias> Anyone got any interesting challenges relating to parametric polymorphism?
10:18:03 <pjdelport> infandum: In other words, extract and union all the inner sets together, and then test s1 and s2 for membership?
10:18:23 <infandum> pjdelport: Yes. But I feel like the union will take up even more time
10:18:45 <infandum> pjdelport: I guess I would use "unions" functions
10:19:18 <infandum> pjdelport: Nope. it's defined as foldl union empty which is BAD. I would use foldl' union empty
10:19:56 <infandum> pjdelport: Yeah, I think unions is an n^2 function
10:19:59 <pjdelport> infandum: It's not defined as that, it's *equivalent* to that in terms of result. Important distinction :)
10:20:17 <infandum> pjdelport: Oh yeah. the source is strict. weird
10:20:52 <pjdelport> infandum: It should be O(sum of lengths of input sets)
10:21:59 <pjdelport> infandum: It might not actually be much better than what you have, on second thought... maybe still worth trying though.
10:22:00 <infandum> pjelport: Really? Isn't it like (n + 0) + (n + n) + (2n + n) + (3n + n) etc in the worst case scenario?
10:22:16 <pjdelport> hmm, point.
10:22:20 <pjdelport> I'm not certain.
10:22:24 <merijn> hold on
10:22:32 <merijn> Why would unions be n^2?
10:22:44 <merijn> I would expect O(max(m,n)) at worst
10:23:08 <pjdelport> merijn: Note unions, not union
10:23:35 <infandum> merijn: Huh? If we have n sets of m items in a set...
10:23:52 <merijn> oh, even then
10:23:59 <merijn> That'd be O(mn)
10:24:17 <infandum> merijn: True
10:24:18 <pjdelport> infandum: In any case, i'm not really sure it's wise to invest too much effort into trying to work around a data structure that doesn't represent the actual data well... that can just lead to ballooning complexity and cost.
10:24:18 <infandum> so
10:24:37 <pjdelport> whereas if you find the right structure, everything else could flow from it naturalyl and simply and efficiently.
10:24:41 <pjdelport> naturally, even
10:24:48 <mmachenry> Is there still development done on (as opposed to in) Haskell in Glasgow?
10:25:45 <albeit> I'm building my program with "cabal build". Is it possible to give it an option to compile with some ghc profiling options? (I only want to compile with profiling sometimes, now always)
10:25:56 <infandum> pjdelport: I wouldn't know what structure is better
10:26:36 <infandum> pjdelport: For my use case, that is, as there are other functions working on it
10:26:50 <Qfwfq> albeit: Set ghc-prof-options in .cabal, configure with --enable-{executable,library}-profiling when wanted.
10:26:54 <pjdelport> infandum: Maybe explain the context, what the data means, and what kind of things you do with it?
10:27:14 <albeit> Qfwfq: Awesome! Thanks
10:27:16 <pjdelport> Without knowing that it's hard to understand and make suggestions.
10:27:49 <infandum> pjdelport: Okay, first let me try the unions thing and then if that's a bust I'll try to explain better
10:28:17 <pjdelport> infandum: Another thing to keep in mind is to keep access to the structure a bit abstract, if you can.
10:28:24 <merijn> Anyway
10:28:45 <pjdelport> While you're working, instead of poking into the internals of things with functions like fst', define higher-level operations, and then use those in the rest of your code.
10:28:55 <merijn> segfaulting sounds like badly behaved FFI function or some really bad bug of someone using unsafePerformIO/unsafeCoerce
10:29:02 <pjdelport> That minimises the amount of code that needs adjusting if you tweak the concrete representation.
10:29:44 <infandum> merijn: If you are referring to my comment about that happening--I wish it were that simple. No FFI or outside calls whatsoever.
10:30:06 <jfischoff> infandum: are you on a mac?
10:30:07 <merijn> Perhaps not in your code, but in some library?
10:30:08 <pjdelport> infandum: For example, for that code snippet, you might want containsLabel :: label -> LabelSet -> Bool
10:30:22 <pjdelport> or rather: containsLabel :: String -> LabelSet -> Bool
10:30:34 <infandum> jfischoff: Linux
10:30:45 <pjdelport> infandum: Then use containsLabel inside common and other functions.
10:30:55 <infandum> pjdelport: So modularize it more?
10:31:20 <pjdelport> infandum: Right; approach as an ADT ("A" for abstract, not algebraic)
10:32:24 <pjdelport> So you have an abstract data type for LabelSet (like you have a type alias already) with a bunch of domain-specific accessors and operations that the rest of the code uses.
10:32:43 <pjdelport> things like containsLabel, or whatever else LabelSet is actually for.
10:33:24 <infandum> pjdelport: I'mm really bad at that, not intentially. I try to modularize, but end up getting more and more lazy and end up with giant where clauses :(
10:33:33 <pjdelport> And only the implementation of that ADT interface works with the concrete representation (that is, only they poke around inside the Set or tuples or hashes or whatever else you end up using inside)
10:33:37 <dgpratt> Saizan, I think I see it now, thanks
10:34:16 <pjdelport> infandum: Don't worry... it takes practice. Often the only way to grow a good ADT is to write it like you have, and then gradually identify and factor out the operations that matter.
10:34:31 <pjdelport> infandum: So don't be afraid to refactor! Look for repeated code, and pull it out aggressively.
10:34:47 <pjdelport> Haskell is particularly good at that: the type system will help you immensely.
10:35:04 <infandum> pjdelport: The good news is that using unions reduced the time and allocation by ~7%
10:36:43 <pjdelport> infandum: Actually, here's an experiment: what happens if you benchmark with two lookups (one right after the other, on exactly the same LabelSet value)?
10:36:46 <infandum> pjdelport: I try. I just get REALLY carried away with those convenient "wheres"
10:37:08 <pjdelport> infandum: Indeed. But where clauses are a great place to pull helpers out of :)
10:37:21 <albeit> I'm trying to cabal build with "-prof" in ghc-prof-options, but its failing, saying "the flag -prof requires the program to be built with -prof"... which seems odd?
10:38:10 <merijn> albeit: Do you have profiling versions of the libraries installed?
10:38:23 <merijn> albeit: Also, did you run cabal clean?
10:38:25 <albeit> merijn: Fairly sure, yes
10:38:32 <albeit> merijn: No the clean
10:38:49 <albeit> *No to
10:38:55 <merijn> albeit: cabal isn't smart enough to figure out that it needs to recompile everything after a flag change
10:39:19 <albeit> merijn: Even after a "cabal configure --enabled-executable-profiling"?
10:40:08 <infandum> pjdelport: I have done that before to clean up my monumental where clauses -- take them out and put them separately. A big issue is that there are a lot of variables involved, and I feel silly having big, repeating type signatures.
10:40:20 <albeit> Just did the clean and recompiled everythign, and its still failing with the same error. Also, "unknown RTS option: -fprof-auto"
10:41:20 <pjdelport> infandum: type synonyms can be great for making type signatures more readable
10:41:36 <pjdelport> infandum: Otherwise, you can always post code samples for critique!
10:42:21 <infandum> pjdelport: True, and I have repos online, but I'm pretty embarassed in my haskell code so I don't advertise anything haha
10:43:13 <superfunc> don't be embarassed, this is how we learn and improve
10:43:41 <infandum> especially when I KNOW that I'm not doing something correctly formatted but I don't have time to go back to refactor that
10:44:29 <pjdelport> infandum: No need to be embarrassed! Improvement is something to be proud of. :)
10:44:49 <infandum> pjdelport: I KNOW that, but I don't PRACTICE that :P
10:51:18 <albeit> Is there any way to re-install any libraries that don't have profiling installed, but leave the others that do?
10:52:04 <schell> albeit: i’d like to know that as well
10:52:20 <infandum> albeit: I would highly recommend using sandboxes for everything, making reinstalling for profiling very easy with no risk of borking the global installs
10:53:09 <albeit> infandum: I'm in a sandbox!
10:53:49 <infandum> albeit: Oh. Well. I'm lazy and just remake the sandbox and install and that always works for me.
10:54:56 <infandum> But I'm one of those people that would rather wipe and install rather than upgrade
10:55:22 <albeit> I only need to re-install like 5% of the packages, so I'd rather not have to wait for them all to reinstall
10:55:29 <xeno> so, I have errors >= 1.4.7 < 1.5 in my cabal file, and still when I do import Control.Error.Util, that module is not found... what do I do wrong?
10:56:29 <c_wraith> xeno: are you building with cabal?
10:56:33 <infandum> albeit: Are any of those 5% dependencies for the other 95%?
10:57:03 <albeit> infandum: I don't believe so.. but not 100% sure
10:57:14 <xeno> c_wraith: nah, running using EclipseFP
10:57:34 <c_wraith> xeno: I know nothing about EclipseFP, but I'm going to suspect it's not using cabal.
10:57:51 <xeno> it's using cabal
10:58:02 <infandum> albeit: Cabal usually reports that from what I remember. If it reports no other packages being broken, I would think that it's ok to safely reinstall just that package (but don't quote me on that).
10:58:03 <xeno> and it works for the other libraries I use
10:58:34 <albeit> infandum: Okay, and is there any way to check if I have library-profiling enabled in my sandbox?
10:58:44 <albeit> infandum: Or I could just add it to a local cabal.config I guess
10:59:42 <infandum> albeit: You know, I was never able to get that to work. I read everywhere that you set all of the profiling lines in the cabal.config to true, but that has never worked for me, so I always install everything with "-p" instead.
10:59:58 <albeit> Ah so "cabal install foo -p"?
11:00:09 <albeit> * "cabal install foo -p --reinstall"
11:00:26 <infandum> albeit: That's what I always do. I would hold off on the reinstall until I check to see if cabal actually reports breakages
11:00:59 <c_wraith> xeno: I can't say anything except "try to build it from the command line with cabal and see what that says"
11:02:33 <infandum> albeit: Well, if you are using sandboxes I guess it doesn't matter anyways. If it borks, you would know when it builds and then you would just wipe and install because there's really no other way to reinstall without just "--reinstall"
11:03:01 <albeit> infandum: Yeah, running all the reinstall now, I'll see what happens!
11:03:29 <infandum> albeit: Too late I guess, but you can try "--dry-run" as well to check if a breakage would happen
11:03:55 <albeit> infandum: Yeah did that. The reinstall are failing, just going to do a complete wipe
11:04:23 <infandum> albeit: Yeah, if it breaks with reinstall then I don't know any other way because there are dependency issues and there's no way around that
11:04:51 <albeit> For a complete wipe, do you just remove the entire sandbox, or is there a "wipe" type function?
11:05:36 <infandum> pjdelport: By the way, thank you for your help! I'll be more confident in coding with fellow haskellers when I finally go to a hackathon haha
11:06:28 <RyanGlScott> Is there a name for this technique involving ADTs and braces?
11:06:30 <RyanGlScott> let x = Identity "foo" in x { runIdentity = "bar" }
11:06:31 <infandum> albeit: Off the top of my head, I just do "cabal sandbox delete" and then "cabal sandbox init" then I cabal install everything
11:06:47 <monochrom> "record syntax"
11:07:02 <RyanGlScott> Thank you, I couldn't come up with that phrase for the life of me
11:07:21 <danilo2> Hello! I've written in haskell a strange thing. It gives different results for "f a b" and "a `f` b" (yes it gives different resutls if we use "f" as operator function). Can I assume it is a bug ?
11:07:45 <c_wraith> danilo2: not without knowing what it is.
11:07:56 <albeit> infandum: Thanks
11:08:13 <monochrom> I would find someone to independently reproduce it first.
11:08:17 <c_wraith> danilo2: I can imagine all sorts of situations where that could happen using Debug.Trace or unsafePerformIO
11:08:26 <infandum> albeit: No problem. Sorry that reinstall is so risky.
11:08:35 <danilo2> c_wraith: hmm, so I've written some type families. I did not use unsafePerformIO nor Debug.Trace
11:08:47 <danilo2> c_wraith: I can show you the output, brb
11:09:06 <c_wraith> danilo2: It's also quite possible it's not parsing the way you thinkg.
11:09:10 <c_wraith> *think
11:09:44 <danilo2> c_wraith: hmm, could you just look at it here? http://lpaste.net/111232
11:09:48 <seahorse2> how does one learn to haskell?
11:09:57 <S11001001> @where lyah
11:09:57 <lambdabot> http://www.learnyouahaskell.com/
11:10:02 <S11001001> seahorse2: ^^
11:10:52 <c_wraith> danilo2: Oh.  With type families, it's fully possible those might be the same.
11:13:51 <danilo2> c_wraith: ah, funny thing. Another error make me conclude wrong thing. Then I tested it in GHCI and GHCI shoows different things for the output. Yes it is the same. The problem was, that the initial error could not deduce a fundep telling me it gets something like "XOut ..." and not "MonadCtxDummy ..." - I've tested simplier example in GHCi and thought that even if it is the same, GHC has a bug infering fundeps here. But it seems th
11:13:59 <danilo2> c_wraith: thank you and sorry for the confusion! :)
11:15:31 <bmuk> If a user defines an instance of Eq for their own type, is there nothing stopping them from defining an incorrect implementation of (==) and (/=)? What I mean is say that I have an algebraic data type data Foo = Bar | Baz | Quux, and I define instance Eq Foo where (==) Baz Bar = True, etc. And also the case where (==) and (/=) are not opposites of eachother. Is there anything that can enforce the "equalness" of Eq instances?
11:16:11 <Mokosha> bmuk, only your conscience
11:16:17 <monochrom> nothing stops an incorrect implementation
11:17:21 <bmuk> well shouldn't we at least enforce that (==) and (/=) are opposites?
11:17:40 <bmuk> Or is there some situation where it makes sense for them to not be
11:17:46 <monochrom> how, do you propose, to enforce it?
11:18:16 <RyanGlScott> For that matter, what would happen if you added {-# RULES "equality" forall x. x == x = not (x /= x) #-}?
11:18:55 <monochrom> users will be surprised at inconsistencies
11:19:04 <bennofs> RyanGlScott: RULES aren't laws that are checked
11:19:16 <bennofs> RyanGlScott: they are just rewrites that the compiler will apply
11:19:35 <zwer> I am wondering why both == and /= are part of the class, and not just one (with the other being a plain function implemented in the terms of the other)
11:19:39 <bennofs> Also, you probably meant forall x y. x == y = not (...)
11:20:04 <bmuk> monochrom: wouldn't what zwer said be a way of enforcing it?
11:20:04 <bennofs> zwer: because sometimes, it might be preferable to also implement /= for performance reasons
11:20:37 <monochrom> that is a way for Eq specifically.
11:21:56 <khyperia> Strange question, would it ever be possible for (\x -> x x) to typecheck? (if so, how?)
11:21:56 <bmuk> My question is obviously about more than Eq, though. I guess I'm asking if there is a way to make sure users' instances of typeclasses satisfy laws that they typeclass should always satisfy
11:22:17 <monochrom> or rather, specifically for laws rewritten in the form "x = ..."
11:23:09 <monochrom> the only way I know, that is good for all forms of laws, is to force the implementer to write a proof.
11:23:11 <bmuk> monochrom: true, but I would like it if ghc could somehow ensure that user defined monads respect monad laws, etc.
11:24:05 <monochrom> (\x -> x x) cannot type-check. you run into an "occurs check" error.
11:24:15 <sinelaw> monochrom, in HM that is
11:24:38 <monochrom> GHC's error message says "infinite type". the way it knows is it sees an "occurs check" error.
11:25:07 <c_wraith> Don't some ML variants let you use infinite types optionally?
11:25:25 <monochrom> sinelaw, it's safe to make that assumption given which channel this occurs.
11:25:40 <monochrom> a meta occurs check :)
11:25:59 <c_wraith> khyperia: You can encode the Y combinator in haskell a few ways.  The newtype approach is probably the easiest.
11:26:09 <sinelaw> monochrom, really?! i feel like many of the discussions here are about pushing the edge (or just stuff I don't understand yet)
11:26:40 <khyperia> Right, so you can't do it with just lambda-calculus constructs? (I know it's possible with recursive let, though)
11:26:53 <c_wraith> khyperia: http://okmij.org/ftp/Computation/fixed-point-combinators.html
11:27:11 <c_wraith> khyperia: and yes, the intro on that page answers your question
11:27:19 <khyperia> thanks!
11:28:04 <bmuk> monochrom: could I add support for these proofs as a language extension?
11:28:16 <monochrom> you could. I'm too lazy.
11:29:23 <bmuk> haha. I know idris has support for theorem proving, does it already require something like this?
11:29:37 <monochrom> I don't know Idris.
11:32:38 <dfeuer> c_wraith, I've been playing with that dropWhileEnd thing you pointed out a while ago. It turns out it actually *can* fuse with a good producer, and makes very good code when it does so, but it *doesn't* currently because it's not defined INLINE.
11:32:59 <c_wraith> dfeuer: interesting. I didn't expect that.
11:33:17 <Iceland_jack> What's a good name for a function that gives a random n-bit integer?
11:33:29 <c_wraith> randomBits?
11:33:49 <c_wraith> 2's complement or strictly positive?
11:33:50 <Iceland_jack> I considered that, it sounds a bit like it just returns "random bits"
11:33:57 <Iceland_jack> Positive
11:34:22 <Iceland_jack> "randomNBits" doesn't seem that bad but still not great
11:34:45 <c_wraith> Eh.  With a sentence of documentation, either name is fine.
11:34:55 <Iceland_jack> yeah that's right
11:35:09 <Iceland_jack> 'makeRandomIntegerWith (n `Bits`)' :þ
11:35:19 <c_wraith> ...  ewwwwww
11:35:36 <dfeuer> c_wraith, I've also played around a lot with an alternative version (not dolio's) that's a good producer and a good consumer. Mine generally works better when most of the list is preserved, whereas the one in Data.List generally works better when most of the list is dropped. What I don't understand is why mine works somewhat worse than the Data.List version when it *doesn't* fuse with a good consumer.
11:35:49 * hackagebot yi-rope 0.2.1.12 - A rope data structure used by Yi  http://hackage.haskell.org/package/yi-rope-0.2.1.12 (MateuszKowalczyk)
11:39:57 <Fuuzetsu> is there a way to get rid of * 'ghc-options: -O2' is rarely needed. Check that it is giving a real benefit
11:40:02 <Fuuzetsu> I really do want O2
11:45:14 <monochrom> Fuuzetsu: I think I can't parse the question.
11:46:09 <monochrom> I may be able to parse if you say "get rid of it in _______" (fill in the blanks)
11:48:37 <albeit> If I have threads passing messages to each other, what is the best way to make sure that the message is fully evaluated before being passed? I want the originating thread to take on the processing
11:48:54 <albeit> (Passing with a Chan)
11:50:13 <mauke> deepSeq maybe
11:50:20 <hexagoxel> https://hackage.haskell.org/package/deepseq
11:52:48 <steve-o> does anyone use atom ide for haskell dev?
11:53:48 <joelteon> is atom an IDE now?
11:53:59 <alrunner5> i tried atom on Windows a couple months ago, but the Haskell stuff was really broken
11:54:16 <steve-o> yeah I tried to use the package ide-haskell
11:54:19 <steve-o> and haven't had much luck
11:56:05 <steve-o> does anyone have suggestions about ide or text editors for haskell?
11:56:38 <Fuuzetsu> monochrom: I don't want to see the warning cabal produces about -O2 in ghc-options when I run cabal sdist
11:56:46 <sbrg> steve-o: gvim
11:56:49 <sbrg> vim*
11:57:24 <steve-o> do things like autocomplete not matter?  are there not many opportunities for it in haskell?
11:57:27 <dcoutts_> Fuuzetsu: can't you just ignore that warning?
11:57:39 <Fuuzetsu> I am but it makes me feel guilty every time
11:58:04 <dcoutts_> my suggestion would be to get over it and not feel guilty :-)
11:58:09 <monochrom> Fuuzetsu: this is somewhat muddy water.
11:58:21 <dcoutts_> if you do indeed know -O2 is the right thing in that case
11:58:30 <Fuuzetsu> Heh. My suggestion would be to remove the warning, the gap between -O and -O2 is significant.
11:58:46 <dcoutts_> that's all the warning is there for, to remind people not to use -O2 mindlessly
11:59:16 <dcoutts_> Fuuzetsu: if it's significant for your package, use -O2 and don't feel guilty. Its ok.
11:59:29 <monochrom> whose business is setting optimization level? is it the author's business, or is it the user's business?
12:00:13 <Fuuzetsu> IMHO author's
12:00:27 <dcoutts_> Fuuzetsu: the warning is for the people who didn't think about it in the first place "omg! -O3! must be faster!"
12:00:40 <monochrom> this question is more clear-cut for some other settings. turning on/off documentation is the user's business. any author who requests "can I turn it on in abc.caba?", I chastise them.
12:00:46 <Fuuzetsu> dcoutts_: when are we getting -ffucking-fast?
12:01:00 <dcoutts_> it's called -Odph insn't it?
12:01:04 <jayunit100> exersizes in http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html of real world haskell are pretty challenging imo.    in general how long should they take ?
12:01:20 <jayunit100> i can easily spend 3 hours on any given problem.
12:01:32 <Fuuzetsu> dcoutts_: I actually considered trying it with -fvectorise the other day but it seemed like a ton of effort and I don't know what it imposes on the users
12:01:45 <Fuuzetsu> and DPH was broken in GHC tree anyway for a long while
12:02:22 <Fuuzetsu> are any widely used packages on Hackage using DPH?
12:02:54 <Fuuzetsu> jayunit100: as long as you need to, it's not a competition
12:04:21 <jayunit100> Fuuzetsu: competition? no.  but ... im assuming at some point, you might think that the exersizes are to advanced and some more review is needed.  then again.  i guess thats the purposes of the exersizes :)
12:05:19 <Fuuzetsu> Well, I'd say 3 hours per exercise is a bit long so if you're struggling you might want to do some review first indeed.
12:05:49 <Fuuzetsu> but as long as the next time it takes you few seconds/minutes to come up with an answer then you improved and the exercise served its purpose
12:06:24 <jayunit100> i also havent worked on puzzle sytle programs in years.
12:07:49 * Fuuzetsu can think of practical application of each of the exercises on that list
12:07:54 <jayunit100> but sometimes i have to google for things (like sorting, etc) , which seem to be assumed in the exersizes, .  which is why i sometimes wonder if the exersizes expect a separate amount of review before embarking on them.
12:08:59 <Fuuzetsu> I think they assume some degree of previous programming background but if you don't have that then I would not worry about taking too long with them
12:18:56 <jayunit100> Fuuzetsu: haha :) i have quite a bit .  actually did alot of clojure as well, so am very comfy w/ functional programming.
12:21:11 <jayunit100> i spend alot of time on type errors.
12:22:23 <Ainieco> hello
12:22:34 <Ainieco> is there scientific notation for integers?
12:22:43 <Ainieco> :t 1e3
12:22:44 <lambdabot> Fractional a => a
12:22:49 <mauke> :t 10^3
12:22:49 <lambdabot> Num a => a
12:23:00 <Ainieco> mauke: that's not a notation
12:23:54 <mauke> notanotation
12:25:32 <supki> Ainieco: yes, with -XNumDecimals enabled
12:27:36 <Ainieco> supki: great, thanks!
12:30:11 <Apocalisp> Given [[a]] of paths into a rose tree, what's an efficient way of converting to Tree a
12:30:47 <Apocalisp> I can think of a quadratic implementation
12:31:49 <mjrosenb> Apocalisp: what is a rose tree?
12:31:54 <mauke> :t Node
12:31:55 <lambdabot> a -> Forest a -> Tree a
12:32:01 <Apocalisp> mjrosenb: Data.Tree
12:32:20 <ski>   data Tree a = Node a [Tree a]
12:33:00 <Apocalisp> given Ord a, I could maybe sort the paths and then use a zipper to construct the tree
12:35:17 <yyttr3> I need to create a haskell .exe file on mac OS X, is there an option for GHC?
12:35:42 <dhrosa> mac doesn't use .exe :p
12:35:54 * hackagebot apiary 0.17.0 - Simple and type safe web framework that can be automatically generate API documentation.  http://hackage.haskell.org/package/apiary-0.17.0 (HirotomoMoriwaki)
12:35:56 * hackagebot apiary-logger 0.17.0 - fast-logger support for apiary web framework.  http://hackage.haskell.org/package/apiary-logger-0.17.0 (HirotomoMoriwaki)
12:35:58 * hackagebot apiary-persistent 0.17.0 - persistent support for apiary web framework.  http://hackage.haskell.org/package/apiary-persistent-0.17.0 (HirotomoMoriwaki)
12:36:00 * hackagebot apiary-websockets 0.17.0 - websockets support for apiary web framework.  http://hackage.haskell.org/package/apiary-websockets-0.17.0 (HirotomoMoriwaki)
12:36:02 * hackagebot apiary-cookie 0.17.0 - Cookie support for apiary web framework.  http://hackage.haskell.org/package/apiary-cookie-0.17.0 (HirotomoMoriwaki)
12:36:10 <yyttr3> I know, but my professor uses windows, and he wants a .exe
12:36:22 <dhrosa> o.o
12:36:30 <yyttr3> I know, it's dumb. I just need it.
12:36:32 <dhrosa> yyttr3: what you want is a haskell cross-compiler
12:36:40 <dhrosa> i'm not sure if GHC can do cross-compilation
12:36:56 <c74d> Why is there `foldl'` in Data.List, but not `foldr'`?
12:37:01 <yyttr3> At least I have a name to search for, thank you.
12:37:23 <mauke> the easiest way would be a windows machine
12:37:34 <mauke> c74d: what would foldr' do?
12:37:38 <ion> which may be virtual
12:38:03 <yyttr3> I don't have one, and none of the ones provided by my school have GHC.
12:38:23 <yyttr3> Or cygwin
12:38:31 <mauke> can you download stuff?
12:38:43 <yyttr3> Not on school computers.
12:39:01 <mauke> oh well
12:39:08 <mauke> download and submit a random virus
12:39:21 <c74d> mauke: Be strict, like `foldl'` — or, is `foldr` already strict?
12:39:27 <mauke> c74d: strict how?
12:39:55 <albeit> When I cabal build in a sandbox with lens, it outputs tons of "Loading package xyz ... linking ... done" messages. Can I prevent that?
12:40:03 <ion> mauke: X5O!P%@AP[4\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*
12:40:21 <yyttr3> I go to a terrible college, so i'm trying to use haskell and scala for everything to make up for it. None of my professors will take the time to learn how to run my programs though.
12:41:04 * hackagebot apiary-clientsession 0.17.0 - clientsession support for apiary web framework.  http://hackage.haskell.org/package/apiary-clientsession-0.17.0 (HirotomoMoriwaki)
12:41:06 * hackagebot apiary-authenticate 0.17.0 - authenticate support for apiary web framework.  http://hackage.haskell.org/package/apiary-authenticate-0.17.0 (HirotomoMoriwaki)
12:41:08 * hackagebot apiary-eventsource 0.17.0 - eventsource support for apiary web framework.  http://hackage.haskell.org/package/apiary-eventsource-0.17.0 (HirotomoMoriwaki)
12:41:10 * hackagebot apiary-purescript 0.17.0 - purescript compiler for apiary web framework.  http://hackage.haskell.org/package/apiary-purescript-0.17.0 (HirotomoMoriwaki)
12:41:11 <yyttr3> I can cross-compile though, so it's fine.
12:41:12 * hackagebot apiary-mongoDB 0.17.0.0 - mongoDB support for apiary web framework.  http://hackage.haskell.org/package/apiary-mongoDB-0.17.0.0 (HirotomoMoriwaki)
12:41:21 <mauke> people who ask random students for .exes to run are asking for it
12:42:00 <yyttr3> Yea. I sent my professor a .tar.bz2 for first homework and I knew I made a bad college choice when he asked me what that was.
12:42:19 <c74d> mauke: I think it means evaluating the intermediate results immediately, rather than building up a stack of delayed computations.
12:42:32 <mauke> c74d: what intermediate results?
12:43:25 <c74d> the intermediate, er… states? of the fold
12:43:38 <yyttr3> foldl'?
12:43:59 <c74d> yyttr3: what about it?
12:44:13 <yyttr3> I was wondering if you were talking about the strict version of foldl.
12:44:30 <c74d> <c74d> Why is there `foldl'` in Data.List, but not `foldr'`?
12:44:45 <c74d> was my original question
12:45:31 <_2_mar> :'(
12:45:43 <Ferdirand> do you understand the difference between foldl and foldl' ?
12:46:14 * hackagebot apiary-memcached 0.17.0.0 - memcached client for apiary web framework.  http://hackage.haskell.org/package/apiary-memcached-0.17.0.0 (HirotomoMoriwaki)
12:46:17 <mauke> c74d: what do you mean by that?
12:46:23 <yyttr3> I assume because you can implement foldr' with the available methods, and it's not used as much.
12:46:42 <mauke> it seems like you don't understand what you're asking for
12:46:54 <pjdelport> c74d: Data.List contains both
12:47:06 <c74d> pjdelport: ah, it does?
12:47:33 <pjdelport> c74d: It's just the Prelude that doesn't contain the foldl' variant (because it's a bit more specialized)
12:47:58 <yyttr3> Prelude Data.List> :t foldr',      No it doesn't.
12:48:17 <pjdelport> Oh, sorry, i missed the extra ' there; i thought you just meant foldr
12:48:28 <pjdelport> Yeah, there's no foldr'
12:48:38 <yyttr3> I assume it's to prevent namespace pollution, since foldr' isn't used as often
12:48:48 <mauke> WHAT DO YOU MEAN BY foldr'
12:48:49 <yyttr3> between libraries like Data.Foldable
12:49:05 <pjdelport> Well, it's not defined, because it's not useful in the way that foldl' is.
12:49:06 <yyttr3> Strict foldr',  no lazy evaluation. That's what I thought it meant.
12:49:14 <mauke> yyttr3: WHAT DO YOU MEAN BY THAT
12:49:37 <pjdelport> (mauke: No need to shout. :) )
12:49:48 <mauke> asking normally doesn't seem to help
12:50:25 <c74d> pjdelport: ah, how is it not useful?
12:50:32 <mauke> god fucking dammit
12:50:33 <c74d> (Apologies, I’m still learning Haskell.)
12:50:57 <yyttr3> mauke: Calm down.
12:51:07 <mauke> yyttr3: no need to be upset
12:51:19 <mauke> yyttr3: have a smoke
12:51:45 <vanila> @src foldl
12:51:45 <lambdabot> foldl f z []     = z
12:51:45 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:51:46 <vanila> @src foldl'
12:51:46 <lambdabot> foldl' f a []     = a
12:51:46 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
12:51:50 <vanila> @src foldr
12:51:50 <lambdabot> foldr f z []     = z
12:51:50 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:51:51 <Qfwfq> mauke: I understand why you're frustrated, but I like my #haskell friendly.
12:51:53 <pjdelport> c74d: Basically, foldl' is useful because you can force evaluation as you traverse down the list to begin with.
12:52:21 <yyttr3> mauke : Prelude Data.List> :t foldr'
12:52:24 <yyttr3> Sorry
12:52:26 <yyttr3> Wrong thing
12:52:34 <yyttr3> http://www.haskell.org/haskellwiki/Lazy_evaluation
12:52:45 <vanila> yyttr3, look at the 3 functions I just @sr'd
12:52:49 <mauke> yyttr3: could you answer my question, please?
12:52:50 <yyttr3> foldl' and foldr' are not lazy
12:52:54 <pjdelport> c74d: But foldr is right-associative: if you made a foldr' it would only begin evaluating from the end of the list back to the front anyway, so you wouldn't really gain anything.
12:53:03 <mauke> yyttr3: preferably in the form of source code
12:53:24 <mauke> because right now you're handwaving
12:53:26 <yyttr3> You want source? It's all available on hackage
12:53:40 <mauke> yyttr3: ok, where can I find the source for foldr'?
12:53:44 <vanila> mauke, I guess foldr' would be foldr f z (x:xs) = let a' = foldr f z xs in a' `seq` f x a'
12:53:49 <yyttr3> Data.Foldable.
12:54:50 <yyttr3> If you have a question about where to find source for  something, go to   http://www.haskell.org/hoogle/
12:55:02 <mauke> foldr' f z0 xs = foldl f' id xs z0  where f' k x z = k $! f x z
12:55:16 <mauke> yyttr3: ok, is that the foldr' c74d was asking about?
12:55:46 <yyttr3> That's the generalized case, I don't think there is one specifically for lists.
12:55:50 <pjdelport> c74d: Foldable's versions of foldl' and foldr', and everything else are useful on the other hand, because they're generic to a lot of structures besides lists.
12:56:08 <syllogismos> you can also use @src command
12:56:09 <mauke> I'll take that as a "no"
12:56:27 <mauke> syllogismos: don't make me roll my eyes at you
12:56:27 <yyttr3> It does the same thing that foldr' would do if it was in Data.List...
12:56:39 <mauke> yyttr3: that doesn't even make sense
12:56:52 <yyttr3> What are you asking..
12:57:13 <vanila> @src foldr'
12:57:13 <lambdabot> Source not found.
12:57:18 <pjdelport> I'd like to just step aside here for a moment, and point everyone to http://comonad.com/reader/2014/letter-to-a-young-haskell-enthusiast/
12:57:19 <c74d> pjdelport: Okay, thanks… I’m afraid I’m not experienced enough to understand why yet, but — using a strict foldr for lists would not be more efficient than using a non-strict one?
12:57:46 <pjdelport> It's a great article, with wonderful advice. :)
12:57:50 <vanila> c74d, did you program in scheme before?
12:58:23 <shiona_> c74d: take your time reading a bit about folds, how foldl' actually limits the thunk and why that won't work for haskell lists
12:58:32 <yyttr3> pjdelport:  I agree, I read it a few weeks ago :D
12:58:35 <pjdelport> c74d: Well, for *lists* specifically, foldr' is not as useful as foldl', because of how the list type is defined.
12:58:46 <c74d> vanila: I think I have a “Hello, world.” program in Chicken Scheme lying around somewhere, but otherwise no.
12:58:49 <pjdelport> That's why Data.List only defines foldl': it's the useful one.
12:59:02 <shiona_> (being able to traverse the list only from left to right is the key)
12:59:06 <Saizan> c74d: foldr' would use stack space proportional to the size of the list
12:59:16 <vanila> c74d, hm it's tricky to explain but basically in haskell the lazy version is often better
12:59:16 <pjdelport> And yeah, a strict foldr' would not gain you much over a lazy foldr.
12:59:18 <pjdelport> (for lists)
13:00:52 <pjdelport> The reason foldl' is a win is intuitively because the [] type is structured from left-to-right, so strict evaluation of the function and accumulator can happen at exactly same time as traversing the list.
13:01:46 <c74d> Okay, thanks. I’m going through Real World Haskell, and was cautioned to use foldl' rather than foldl to avoid stack overflows, and was trying to do the same with foldr.
13:01:52 <pjdelport> So if you have a lazy list, and use foldl', you only use constant space, not O(N) space (proportional to the size of the list).
13:01:56 <Saizan> have we also pointed out that foldr' f = foldr (\x a -> f x $! a) ? i.e. the difference is really in the step function anyway
13:02:00 <vanila> c74d, that'sgood advice for foldl, but foldr is better
13:02:21 <c74d> I don’t suppose reversing the list and then using foldl' would be a solution?
13:02:31 <vanila> c74d, the reason is that foldr can produce results lazily from only looking at the first part of the input list
13:02:37 <c74d> vanila: ah, better meaning that it won’t stack-overflow?
13:02:37 <vanila> c74d, so we want a lazy foldr
13:02:45 <pjdelport> c74d: Yeah, foldr is often a better solution. It's more natural for lists.
13:02:48 <vanila> c74d, but foldl has to compute the result from the entire list, so it's better strict
13:02:54 <Saizan> c74d: what's better depends on your step function.
13:03:32 <Saizan> c74d: if your step function is strict in the accumulator you might even want to foldl' on the reversed list
13:03:39 <mauke> Saizan: is that really the same?
13:03:39 <vanila> c74d, here's an example that doubles every element of a list
13:03:42 <Saizan> c74d: if it can be lazy then go with foldr
13:03:45 <vanila> > foldr (\x ys -> x : x : ys) [] "foobar"
13:03:46 <lambdabot>  "ffoooobbaarr"
13:03:56 <vanila> but it also works on infinitly long lists
13:04:05 <vanila> if it were strict, it wouldn't work on infinitely long lists
13:04:11 <mauke> Saizan: I'm thinking about foldr' f z [x]
13:04:48 <Saizan> mauke: it should be the same as foldr f z [] = z; foldr f z (x:xs) = let a' = foldr f z xs in a' `seq` f x a'
13:05:56 <mauke> Saizan: yours is f x $! z; the Data.Foldable one is id $! f x z
13:06:55 <Saizan> mauke: i see
13:07:35 <sinelaw> how does 'fix' work?
13:07:40 <mauke> @src fix
13:07:40 <lambdabot> fix f = let x = f x in x
13:07:49 <sinelaw> > fix (const 923)
13:07:51 <lambdabot>  923
13:07:56 <monochrom> my http://www.vex.net/~trebla/haskell/fix.xhtml explains fix
13:08:16 <sinelaw> thanks
13:08:18 <mauke> fix connects the output of a function to its input
13:08:27 <mauke> feeding it its own result
13:08:49 <yyttr3> What is @src?
13:08:54 <mauke> (this works especially well with const x because const x ignores its input)
13:09:02 <mauke> a lambdabot command
13:09:17 <yyttr3> @src tail
13:09:17 <lambdabot> tail (_:xs) = xs
13:09:17 <lambdabot> tail []     = undefined
13:09:17 <mauke> it looks up identifiers in an ad-hoc list of definitions
13:09:30 <yyttr3> Thats cool
13:10:14 <hopnotch> https://github.com/mokus0/lambdabot/blob/master/lambdabot/State/source
13:10:25 <hopnotch> only that cool
13:11:49 <pjdelport> > fix (1:)
13:11:50 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:12:48 <mauke> > fix id
13:12:52 <lambdabot>  mueval-core: Time limit exceeded
13:13:05 <pjdelport> You can think of it as applying a function to its own result: tying a circle.
13:13:13 <mauke> > fix f
13:13:15 <lambdabot>  No instance for (GHC.Show.Show a0)
13:13:15 <lambdabot>    arising from a use of ‘M289178268066393985322231.show_M2891782680663939853...
13:13:15 <lambdabot>  The type variable ‘a0’ is ambiguous
13:13:15 <lambdabot>  Note: there are several potential instances:
13:13:15 <lambdabot>    instance [safe] GHC.Show.Show
13:13:22 <mauke> sorry
13:13:34 <pjdelport> Productive functions will generally result in an infinite data structure, while strict functions will just be an infinite loop.
13:13:40 <mauke> > fix f :: Expr
13:13:42 <lambdabot>  f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f...
13:13:57 <pjdelport> Exactly. :)
13:14:13 <pjdelport> But:
13:14:13 <pjdelport> > fix (1+)
13:14:16 <lambdabot>  mueval-core: Time limit exceeded
13:14:18 <mauke> (1:) adds a layer of definedness to its input
13:14:21 <sinelaw> monochrom, I understand what fix is
13:14:29 <sinelaw> not how it works
13:14:36 <mauke> (1:) undefined is 1 : undefined
13:14:41 <mauke> which is defined itself
13:14:50 <vanila> sinelaw, there's a good diagram for how it works in SPJs book, i could dig it out if you want
13:15:00 <sinelaw> I have it open
13:15:03 <sinelaw> :)
13:15:08 <sinelaw> not the diagram, the book
13:15:19 <vanila> oh okay
13:15:26 <c74d> pjdelport, vanila, Saizan: Thanks for trying to explain, but I’m afraid I still don’t understand yet. At least I know to not bother looking for foldr' in Data.List.
13:16:07 <mauke> sinelaw: does "fix connects the output of a function to its input, feeding it its own result" make sense?
13:16:12 <yyttr3> How could fix ever be useful?
13:16:29 <mauke> yyttr3: anonymous recursion
13:16:32 <sinelaw> mauke, yes, but I'm thinking in terms of actual implementation (reduction or whatever)
13:16:42 <mauke> huh?
13:16:45 <ReinH> @where lazy
13:16:45 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
13:16:48 <ReinH> c74d: have you seen ^ ?
13:16:51 <mauke> you've seen the source of fix
13:16:59 <yyttr3> but you can't stop a call to fix once made?
13:16:59 <mauke> that's as actual as it gets
13:17:06 <vanila> sinelaw, it's literally as mauke says, if you imagine the graph it ties a knot for you
13:17:09 <dhrosa> yyttr3: haskell is lazy
13:17:11 <mauke> yyttr3: it's not a loop
13:17:12 <vanila> that's what the diagram shows
13:17:19 <singularai> hey, does anyone know how to use template haskell with the ffi for c libraries?
13:17:38 <ski> pjdelport : good article
13:17:40 <sinelaw> ok, i'll try it on a piece of paper
13:17:41 <yyttr3> mauke: Well yes, but  fix (+1).. I could never use that?
13:18:04 <sinelaw> yyttr3, (+1) doesn't have a fixed point
13:18:13 <yyttr3> What does?
13:18:30 <sinelaw> (1:[])
13:18:30 <pjdelport> c74d: It's not the most obvious thing... when you have more experience in visualizing and thinking about lazy evaluation order, it will probably start to make more sense, though.
13:18:32 <sinelaw> oops
13:18:38 <sinelaw> (1:)
13:18:42 <sinelaw> > fix (1:)
13:18:44 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:18:47 <mauke> sinelaw: undefined is a fixed point of (1+) :-)
13:18:48 <pjdelport> c74d: Do you have an intuition of Haskell's evaluation order as "outside-in"?
13:18:57 <sinelaw> mauke, that's cheating
13:19:04 <mauke> it's good cheating
13:19:10 <yyttr3> besides (:)
13:19:10 <vanila> sinelaw, do you know "@" yet?
13:19:11 <sinelaw> well, yes.
13:19:30 <mauke> sinelaw: consider (True ==)
13:19:40 <mauke> it has a fixed point at True, but that doesn't help you
13:20:10 <albeit> I have a space leak (memory use expands quickly), and its these few lines that seem to causing it... why? http://lpaste.net/111235
13:20:10 <vanila> I think that @ is needed for the graph to do fix correctly
13:20:12 <yyttr3> What is something less trivial that has a fixed point.
13:20:15 <sinelaw> yyttr3, for numerical functions, any function that has f(x) = x
13:20:28 <sinelaw> such as x^2
13:20:34 <mauke> yyttr3: \f -> (\n -> if n < 2 then 1 else n * f (n - 1))
13:20:40 <yyttr3> fix x*x
13:20:59 <mjrosenb> Apocalisp: did you ever get an answer? it sounded like an interesting puzzle.
13:21:08 <sinelaw> > fix (\x -> x*x)
13:21:13 <lambdabot>  mueval-core: Time limit exceeded
13:21:23 <sinelaw> nice.
13:21:29 <yyttr3> @src fix
13:21:29 <lambdabot> fix f = let x = f x in x
13:21:35 <sinelaw> vanila, what's @?
13:21:42 <mjrosenb> :t fix (\x -> x*x)
13:21:44 <lambdabot> Num a => a
13:21:45 <mauke> aliasing in patterns
13:21:55 <sinelaw> oh
13:22:02 <vanila> sinelaw, let me check where it's introduced - but I think basically @ is the key to implementing things like fix
13:22:02 <yyttr3> Look, even if the computation moves towar a root of x, there isn't a way to get that value
13:22:04 <sinelaw> but of course.
13:22:08 <Apocalisp> mjrosenb: Not really
13:22:13 <vanila> you need that 'delay'
13:22:13 <dhrosa> fix (x->1:zipWith (+) (tail x) x)
13:22:16 <dhrosa> > fix (x->1:zipWith (+) (tail x) x)
13:22:18 <lambdabot>  Pattern syntax in expression context:
13:22:18 <lambdabot>      x -> 1 : zipWith (+) (tail x) x
13:22:21 <dhrosa> :<
13:22:23 <ski> yyttr3 : there is, for mauke's example
13:22:31 <dhrosa> < fix (f x->if x == 0 then 1 else x * f (x - 1))
13:22:45 <dhrosa> < fix (f x->if x == 0 then 1 else x * f (x - 1)) 5
13:22:58 <dhrosa> > fix (f x->if x == 0 then 1 else x * f (x - 1)) 5
13:23:00 <lambdabot>  Pattern syntax in expression context:
13:23:00 <lambdabot>      f x -> if x == 0 then 1 else x * f (x - 1)
13:23:01 <dhrosa> last attempt
13:23:03 <dhrosa> k done
13:23:18 <Qfwfq> \
13:23:24 <triliyn> > fix (\f x -> if x == 0 then 1 else x * f (x - 1)) 5
13:23:27 <lambdabot>  120
13:23:32 <mjrosenb> Apocalisp: ok, so how do the values in the [[a]] relate to the final Data.Tree.Tree a?
13:23:36 <Apocalisp> mjrosenb: The best I can come up with is to sort the paths lexicographically, then use a zipper to construct the tree. This makes sure I'm not retraversing paths. Best case linear (all paths are the same) and worst case quadratic (all paths are unique).
13:23:52 <ski> > fix (\fibs -> 0 : 1 : zipWith (+) fibs (tail fibs))  -- dhrosa, did you mean this ?
13:23:54 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
13:24:04 <mjrosenb> Apocalisp: is it a list of every path from the root down to a leaf?
13:24:10 <Apocalisp> mjrosenb: Yes
13:24:18 <ski> yyttr3 : and that's another example
13:24:25 <vanila> sinelaw, sorry, my mistake @ is just application,  it's # I meant to refer to
13:24:56 <vanila> sinelaw, if you check out page 115 and 116 they work through an example of applying fix
13:25:07 <yyttr3> but from what I can tell fix takes a function and returns the exact same thing. How is that useful?
13:25:33 <vanila> http://i.imgur.com/NmZrZIE.png
13:25:35 <mauke> yyttr3: it returns the result of that function
13:25:49 <ski>   fix f = x
13:25:50 <ski>     where
13:25:52 <ski>     x = f x
13:26:01 <ski> `x' is the result of calling `f' on `x'
13:26:03 <mjrosenb> well the 'sort lexographically' step isn't worst case linear, so you'll never be worst case linear overall.
13:26:05 <vanila> this is for y f = f (y f)
13:26:06 <ski> `fix f' returns this `X'
13:26:10 <vanila> not the optimized version ski just posted
13:26:48 <vanila> oops, actually this is the optimized version
13:27:14 <vanila> you can see the #-delayed link to the loop @ of f with itself
13:27:15 <ski> yyttr3 : so, `fix f' makes a "loop" by passing the result of the function call (to `f') back to the call
13:27:24 <vanila> the # is essential for it to be able to self apply
13:27:50 <ski> yyttr3 : consider the `fibs' example above
13:27:51 <vanila> sinelaw, does that help/any questions ?
13:28:23 <sinelaw> vanila, helps! thanks.
13:28:26 <sinelaw> need to read through it
13:29:13 <sinelaw> the book part I mean. the diagram I can't parse as of yet :)
13:29:15 <albeit> Why would "Data.Text.Lazy.IO.hPutStrLn handle" result in using way more memory than "Data.Text.Lazy.IO.putStrLn"?
13:29:46 <mauke> you can also think about it as time travel
13:30:22 <mauke> if you have 'fix (\x -> ...)', then x represents the result of ... sent back from the future
13:30:27 <mauke> where the result is known
13:30:39 <Qfwfq> What is "context reduction" in GHC?
13:30:42 <vanila> sinelaw, well it's just that you can consider any haskell program as a graph - you can mostly ignore the stack on the right & the G-machine implementation of fix, the important part is that you start with y f  (represented by the first graph, @(y,f) and it does some graph manipulation to produce that sixth graph which "ties the knot"
13:30:59 <mauke> that means the expression in '...' can use x as-is and bake it into bigger expressions, but it can't inspect x
13:31:03 <mauke> because that would cause a time paradox
13:31:24 <mjrosenb> Apocalisp: if you assume that it is already sorted, it should /always/ be linear.
13:31:28 <sinelaw> that much I know. I read the SPJ book but it was a while back, I need to refresh esp. the second half (graph reduction)
13:31:59 <triliyn> mauke: it can inspect x if it's only in some branches of an if/case/whatever, right?
13:32:13 <mauke> triliyn: example?
13:32:39 <triliyn> hmmm, maybe I'm wrong
13:33:35 <vanila> sinelaw, yeah it's kind of a big book -I plan to re-read it too and implement the parts as I go maybe
13:33:54 <sinelaw> vanila, yea. I like it, it's very readable. I'm implementing type checking now
13:33:59 <vanila> oh cool! :)
13:34:08 <sinelaw> for....
13:34:10 <sinelaw> (wait for it)
13:34:20 <sinelaw> Javascript!   (subset thereof, of course)
13:34:32 <vanila> scary!
13:34:48 <mjrosenb> sinelaw: does your subset include eval? :-p
13:34:55 <sinelaw> mjrosenb, no no and no
13:34:55 <vanila> I actually would like to learn how type inference works on dynamic languages, everythings so much simpler and nicer for statically typed ones..
13:35:20 <sinelaw> vanila, it doesn't
13:35:25 <mjrosenb> vanila: there is a paper on the TI engine for spider monkey.
13:35:36 <vanila> lol
13:35:39 <vanila> and ty mjrosenb
13:35:48 <mauke> "it's a heuristic, which is a fancy way of saying it doesn't work"
13:36:48 <mauke> you can do some weird things with types, though
13:37:07 <mjrosenb> vanila: http://dl.acm.org/citation.cfm?id=2254094
13:37:50 <sinelaw> people say they are "dynamically typed"
13:37:52 <mjrosenb> so, I /just now/ realized that dynamic types actually means two different things
13:38:02 <mauke> var a = "x"; function foo(x) { var e = a == x ? "equal" : "not equal"; print("$a and $x are $e"); } foo("x"); a = 42; foo(0);  // this can be type checked statically
13:38:31 <mauke> (disclaimer: not actually implemented yet)
13:38:33 <sinelaw> which basically means, there are about 3 types: numbers, strings, and everything else. In ruby, even that's not true. Ruby has no types!
13:38:42 <sinelaw> at all.
13:39:17 <Apocalisp> mjrosenb: Wait, why should it always be linear?
13:40:11 <mjrosenb> Apocalisp: well, linear in the total number of a's.
13:40:36 <Apocalisp> mjrosenb: Yes, true. I'd like to do a bit better :)
13:41:03 <mjrosenb> Apocalisp: well, you have to touch each of them at least once, so it would be hard to do better.
13:41:35 <sinelaw> mauke, you're working on implementing checking for that?
13:41:57 <mjrosenb> sinelaw: this is in your subset of js?
13:42:04 <Apocalisp> mjrosenb: Consider where all the paths are identical. It would be nice if it took time linear in the length of that one path.
13:42:07 <mauke> sinelaw: just thinking about it, for now
13:42:21 <mauke> the bigger challenge is to get variable-length strings working :-)
13:42:35 <trap_exit> with emacs + haskell, isit possible to code on a 13" mbp?
13:42:41 <sinelaw> mjrosenb, everything except for the "a = 42"
13:42:41 <mjrosenb> Apocalisp: but verifing that is the case is going to take time linear in the total number of elements!
13:42:47 <trap_exit> i feel like the 15" mbp is the minimal screen estate necessary to have the haskell code + ghc errors on the same screen
13:42:49 <mauke> the "types" are an ad-hoc kludge because I'm targetting embedded C
13:43:06 <mjrosenb> sinelaw: err, I meant "3 types: numbers, strings, and everything else"
13:43:08 <sinelaw> mauke, cool.
13:44:00 <Apocalisp> mjrosenb: Yes, you're absolutely right. I guess I'm thinking of the time it takes to retraverse the current tree.
13:44:22 <albeit> If I open a file with openFile, and keep it open while I write to it, will my programs memory usage keep increasing as the size of the file increases?
13:44:34 <mauke> albeit: no
13:44:56 <sinelaw> mjrosenb, it's just a plan (implementation is very rudimentary so far)
13:45:05 <mjrosenb> albeit: well, it isn't guaranteed to.  It may do that just to spite you, for unrelated reasons :-)
13:45:10 <sinelaw> mjrosenb, but the plan is to support structural subtyping on records
13:45:31 <mauke> heh, I'd get that for free
13:45:33 <sinelaw> plus of course all built in types, and polymorphic functions
13:45:34 <albeit> Then is there any reason writing to a file jacks continuously increases my memory usage while writing to sdout doesnt?
13:45:38 <mauke> because the compiler is too dumb to care
13:46:00 <albeit> s/jacks//
13:46:03 <monochrom> you may be looking at the wrong factor, albeit.
13:46:04 <sinelaw> mauke, which compiler
13:46:30 <mjrosenb> albeit: code?
13:46:31 <albeit> monochrom: Very well may be! I just am stumped what to look at
13:46:43 <mauke> sinelaw: I have a prototype (written in javascript) that compiles this toy language to C. right now it only supports two types, ints and strings
13:47:01 <albeit> mjrosenb: http://lpaste.net/111235
13:47:09 <yyttr3> Is there a book somewhere on gtk2hs?
13:47:12 <albeit> If I switch the hPutStrLn to putStrLn, its perfectly fine
13:47:23 <sinelaw> mauke, you mean ints, strings, and functions?
13:47:31 <mauke> no, no functions
13:47:33 <mjrosenb> mauke: silly question: why are you writing it in javascript?
13:47:44 <mauke> mjrosenb: historical reasons
13:47:46 <vanila> mauke: will it self host?
13:47:48 <sinelaw> what can you do without functions?
13:48:04 <mauke> sinelaw: well, there are functions, but they're effectively macroexpanded/inlined
13:48:14 <mauke> which means I get fake polymorphism for free
13:48:24 <sinelaw> oh I see
13:48:26 <sinelaw> heh
13:48:35 <mauke> (but no recursion)
13:48:49 <sinelaw> well, you just need to solve the halting problem and inline N times
13:49:22 <monochrom> do you have a while-loop?
13:49:27 <mauke> monochrom: yes
13:49:35 <monochrom> that will be good enough
13:49:39 <mauke> and the ability to transfer control back into a function that has already returned
13:49:40 <vanila> I tried to solve the halting problem once but I didn't finish it
13:49:57 <mjrosenb> mauke: so, you have sanatized C macros?
13:50:16 <mauke> mjrosenb: huh?
13:50:49 <mjrosenb> albeit: presumably you meant switch hPutStrLn handle to putStrLn?
13:50:51 <vanila> C macros are kinda.. awful
13:50:51 <mauke> it's quite a bit more structured than C macros
13:50:54 <Qfwfq> What is "context reduction" in GHC?
13:50:58 <mjrosenb> albeit: because that doesn't typecheck :-p
13:51:04 <mauke> which are basically just "replace this identifier by this sequence of tokens"
13:51:05 <albeit> mjrosenb: Yes
13:51:44 <albeit> mjrosenb: I can paste the surrounding code as well, but I'm not sure it will help too much
13:52:02 <albeit> (And TextIO is Data.Text.Lazy.IO)
13:52:20 <mjrosenb> albeit: how much memory is it eating on you?
13:53:05 <albeit> mjrosenb: The enclosing function uses 24% when writing to the file, a negligible when writing to stdout
13:53:13 <albeit> *negligible amount
13:53:21 <mjrosenb> mauke: yeah, I guess I was just drawing conclusions based on the lack of recursion.
13:55:00 <albeit> mjrosenb: Actually I am completeley mistaken, not sure what I was looking at, switchign to stdout doesn't make a different.
13:55:29 <albeit> But still have no idea why it uses so much memory
13:55:32 <mjrosenb> albeit: ahh, well, that is good to know!
13:55:43 <mjrosenb> albeit: ok, for that, having the surrounding code is likely useful.
13:56:35 <albeit> mjrosenb: Sure, this is the complete function. It's part of the Logger module for different threads. http://lpaste.net/111239
13:58:47 <mjrosenb> albeit: and FileMap is just Map Text Handle?
13:59:06 <albeit> mjrosenb: yes
13:59:27 <monochrom> I would consider who else is keeping msgs
14:00:29 <XniX23> when approx will applicative become a superclass of monad?
14:01:08 <monochrom> a lazy list or string or bytestring or text or whatever ceases to be lazy if two guys point to it, and one of the two guys consume it, and the other guy will consume it later.
14:01:55 <monochrom> for example "f xs = (sum xs, length xs)" destroys the laziness of xs.
14:02:14 <albeit> monochrom: Well... the encapsulated messages are passed in a message from another thread. But they are deepseq'ed before being sent. And the only thing done to them is writing to a file
14:02:16 <monochrom> here, by "laziness" I mean your expectation of O(1) space.
14:02:38 <monochrom> deepseqing takes more memory, not less
14:03:49 <albeit> Well actually deepseqing or not doesn't seem to make a difference (on % of memory used, not absolute)
14:04:29 <monochrom> let me put it this way, albeit:
14:04:55 <albeit> When I'm looking at the "%alloc" in the ".prof" file, is it the amount allocated over the life of the program, or the average instantatenous percentage?
14:05:02 <monochrom> suppose I have: main = do { let xs = [1.. huge_number]; print xs; print (length xs) }
14:05:23 <monochrom> do you understand why that uses huge memory?
14:05:49 <albeit> monochrom: Yes, I understand that aspect of laziness. Since a later function uses xs, it still need to hold it in memory
14:06:12 <albeit> Wheras if print (length xs) wasnt there it could just go element by element, never buildng a full list.
14:06:13 <monochrom> ok, do you have a similar holding-on-to in your program?
14:06:35 <monochrom> maybe you do. you have a deepseq
14:06:49 <albeit> I removed deepseq as I wasn't confident in it...
14:06:54 <monochrom> ok
14:07:10 <albeit> But I don't believe a holding-on, no... the "msgs" are used just once, and never again.
14:07:44 <mjrosenb> albeit: have you observed memory usage other than with the profiler?
14:07:54 <beckyconning> if i have a list of maybes like [Just 1, Nothing, Nothing, Nothing, Just 2, Nothing, Nothing] what would be the best way to translate it to [1, 1, 1, 1, 2, 2, 2]? i.e. the best way of making subsequent Nothings equal to the last Just.
14:08:29 <vanila> beckyconning, what would [Nothing] become?
14:08:56 <albeit> mjrosenb: Yes, it increases a lot but its hard to tell what module it comes from without the profiler, as there are few modules causing space leaks and trying to work them
14:09:02 <beckyconning> perhaps this would be a function that would return Maybe [a] such that [Nothing] would return Nothing
14:09:27 <mauke> beckyconning: and [Nothing, Just 1]?
14:09:35 <miarfi> hello all
14:09:36 <beckyconning> mauke: same again
14:09:37 <monochrom> regrettably, I am not very familiar with the profiler output
14:09:55 <pertl> I am trying to define the 'Applicative' for 'State' ... can someone confirm this type substitution is corrent?  http://lpaste.net/111240
14:10:21 <mjrosenb> albeit: ok, because you mentioned allocations.  the allocations themselves are fine.  it is when you allocate something and hold onto it that bad things happen (I have no clue what the profiler is actually reporting though...)
14:10:23 <shachaf> pertl: The type is correct.
14:10:27 <vanila> beckyconning, well these edge cases are difficult, but ignoring them foldM with State monad would work nciely
14:10:33 <shachaf> pertl: You need parentheses, though: (<*>) :: ...
14:10:38 <miarfi> I have some troubles to compile strict-concurrency under Mac (Mavericks + Xcode 6) with the latest haskell platform
14:10:53 <pertl> shachaf: yeah, right, the () ... thanks shachaf
14:10:58 <vanila> beckyconning, and then to make these edge case give the correct result you could make a monad stack with State and Maybe involved
14:11:12 <miarfi> I followed the guidelines to change the settings of ghc by providing it apple-gcc42 but it seems not to work … any idea?
14:11:20 <beckyconning> vanila: thanks for the tip : ) i haven't used State before but i'll try it out now : )
14:11:39 <vanila> beckyconning, sure if oyu get stuck feel free to ask more details
14:11:57 <miarfi> (the error is an ExitFailure 1)
14:12:01 <merijn> miarfi: Why are you not installing a binary distribution of ghc/platform?
14:13:32 <miarfi> merijn: I tried with http://ghcformacosx.github.io, do you think it would be different with the officiel platform? I'll try it right now
14:18:45 <ski> > mfix (\result -> zipWithM mplus [Just 1,Nothing,Nothing,Nothing,Just 2,Nothing,Nothing] (Nothing : map Just result))  -- to bad this doesn't work
14:18:49 <lambdabot>  mueval-core: Time limit exceeded
14:19:08 <ski> > let result = [1,1,1,1,2,2,2] in zipWithM mplus [Nothing,Just 1,Nothing,Nothing,Nothing,Just 2,Nothing,Nothing] (Nothing : map Just result)
14:19:09 <lambdabot>  Nothing
14:19:15 <ski> > let result = [1,1,1,1,2,2,2] in zipWithM mplus [Just 1,Nothing,Nothing,Nothing,Just 2,Nothing,Nothing] (Nothing : map Just result)
14:19:16 <lambdabot>  Just [1,1,1,1,2,2,2]
14:20:11 <vanila> wow really nice ski!
14:22:10 <ski> not really, since it didn't work
14:22:24 <ski> perhaps one could fix it somehow, but i don't see how to, atm
14:22:25 <Ben__> > catMaybes $ scanl1 (flip (<|>)) [Just 1, Nothing, Nothing, Nothing, Just 2, Nothing, Nothing]
14:22:26 <lambdabot>  [1,1,1,1,2,2,2]
14:23:45 <vanila> > runState (mapM (\e -> maybe get (\i -> do put i ; return i)) [Just 1, Nothing, Nothing, Nothing, Just 2, Nothing, Nothing]) 0
14:23:47 <lambdabot>  Couldn't match expected type ‘Control.Monad.Trans.State.Lazy.StateT
14:23:47 <lambdabot>                                  s Data.Functor.Identity.Identity b’
14:23:47 <lambdabot>              with actual type ‘Data.Maybe.Maybe s0 -> m0 s0’
15:40:25 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://is.gd/xJt4FF'
15:40:25 --- topic: set by glguy on [Thu Sep 18 09:24:53 2014]
15:41:40 <sinelaw> is there zip for monads?
15:42:34 <dibblego> sinelaw: liftM2 (,)
15:42:41 <sinelaw> k
15:43:16 <hopnotch> is there any good reason why cabal-install is not updated to remove the network < 2.6 restriction? Or can i just fiddle with the cabal file and it'll work?
15:43:20 <dibblego> there is also liftA2 (,) and ZipList which gives a specific zip
15:43:49 <benmachine> it depends what you mean by zip, of course
15:44:03 <benmachine> I think liftM2 (,) on lists is certainly not zip
15:44:09 <dcoutts_> hopnotch: it'd probably work, you'd have to add a dep on network-url
15:44:51 <zwer> > liftM2 (,) [1..4] ['a'..'d']
15:44:52 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(1,'d'),(2,'a'),(2,'b'),(2,'c'),(2,'d'),(3,'a'),(3,...
15:46:40 <benmachine> zipping to me means "matching up corresponding positions" and monad in general can't do it
15:46:40 <benmachine> because the positions might not correspond
15:46:43 <dibblego> zipping to me means fzip
15:46:44 <Axman6> cartesian product on the other hand makes more sense for monads in general
15:46:47 <zwer> yeah it is different than zip
15:47:08 <vanila> sinelaw, there is also zipWithM
15:47:11 <vanila> :t zipWithM
15:47:11 <lambdabot> Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
15:47:21 <dibblego> fzip :: f a -> f b -> f (a, b) -- same power as liftA2
15:47:40 <benmachine> actually my argument is slightly specious because in the case of list zip the positions don't all correspond eitehr
15:47:55 <Axman6> :t \f as bs -> sequence (zipWith f as bs)
15:47:56 <lambdabot> Monad m => (a1 -> b -> m a) -> [a1] -> [b] -> m [a]
15:49:02 <arianvp> Why does haskell have special syntax for ranges? [1..5]
15:49:13 <sshine> arianvp, because it's useful?
15:49:16 <arianvp> why dont we just define    from .. to = range (from,to)
15:49:24 <Iceland_jack> arianvp: You can
15:49:33 <Iceland_jack> > let a...b = [a..b] in 5...10
15:49:35 <lambdabot>  [5,6,7,8,9,10]
15:49:39 <arianvp> I know I can!
15:49:42 <flaviu1> noob question: https://gist.github.com/e9b28e641c6d193c27fd
15:49:42 <flaviu1> "f.hs:8:7: parse error on input `maxv'"
15:49:43 <Iceland_jack> :)
15:49:45 <arianvp> but I dont see why we have a special notation for it
15:50:08 <Iceland_jack> Because [n..] and [1,3..] couldn't be expressed like that
15:50:15 <arianvp> oh yeah
15:50:18 <sshine> arianvp, it may come from functional programming often dealing with lists. there's a lot of list-specific features in Haskell.
15:50:42 <untseac> hey
15:50:44 <arianvp> I see Iceland_jack
15:51:06 <untseac> what's the main advantage of haskell over scala?
15:51:07 <monoidal> arianvp: note all magic [a..b] syntax is available as normal methods in Enum class
15:51:24 <monoidal> enumFrom, enumFromThen, enumFromTo, enumFromThenTo
15:51:26 <Axman6> arianvp: when you see [a..b] you can quite easily infer that it has something to do with lists, and the meaning is pretty clear to pretty much anyone, whether they know any haskell or not. a..b not so much
15:52:14 <Axman6> untseac: a sane type system for one, Scala has a pretty ad hoc type system with features that often don't play well together
15:52:41 <Axman6> dibblego would be an excellent person to ask about this (the (original?) author of scalaz)
15:53:49 <untseac> I see, what about the main disadvantage?
15:54:22 <Axman6> some people like the java interoperability of scala
15:54:34 <Axman6> it's more easily supported in existing (java) projects
15:54:35 <untseac> eh.. that's not that a big of a disadvantage
15:54:50 <Axman6> and arguably easier to teach to java programmerd
15:54:52 <Axman6> s*
15:54:57 <dibblego> http://tonymorris.github.io/blog/posts/what-kind-of-things-are-easy-in-haskell-and-hard-in-scala-and-vice-versa/index.html
15:54:58 <dhrosa> untseac: scala is slightly more mainstream I think, and will probably get you less weird looks
15:55:27 <dibblego> scala has lots of problems, not just technical ones  in particular, problems that you don't learn about until you are well-invested
15:56:20 <untseac> hum so haskell is better designed but it doesn't come with all the java libraries
15:56:27 <vanila> dibblego, any rough overview of the problems?
15:56:36 <vanila> and is this related to the recent fork?
15:56:51 <flaviu1> any ideas on https://gist.github.com/e9b28e641c6d193c27fd , line 8 ? I'm sure the problem is obvious to those with any experience, but it's a problem impossible to google
15:57:24 <dibblego> I don't think an overview would be useful in its accuracy  yes, the recent fork is related to some of the technical problems (but imo, is too superficial to economically address them)
15:57:35 <glguy> flaviu1: In Haskell tab stops are 8 characters
15:57:45 <glguy> and you should probably avoid them altogether
15:58:03 <Axman6> 4 spaces, 1 tab bad
15:58:04 <glguy> (the hard tab \t character, that is)
15:58:08 <Axman6> 4 spaces good, 1 tab bad
15:58:10 <Axman6> damn
15:58:17 <dibblego> maybe someone in #scalaz can help answer
15:58:47 <flaviu1> ah, I see, thanks
15:58:50 <beckyconning> > Nothing | Just 1
15:58:51 <lambdabot>  <hint>:1:9: parse error on input ‘|’
15:58:55 <Axman6> @google haskell off side rule
15:58:56 <lambdabot> http://en.wikipedia.org/wiki/Off-side_rule
15:58:56 <lambdabot> Title: Off-side rule - Wikipedia, the free encyclopedia
15:58:57 <beckyconning> > Nothing <|> Just 1
15:58:58 <lambdabot>  Just 1
15:59:03 <Axman6> flaviu1: see that link
15:59:04 <beckyconning> > Just 2 <|> Just 1
15:59:06 <lambdabot>  Just 2
15:59:35 <dhrosa> why is it refered to as scalaz?
15:59:48 <dhrosa> oh scalaz is a different thing
16:00:05 <dibblego> scalaz is a library, written in scala
16:00:12 <dibblego> https://gist.github.com/tonymorris/5367920
16:01:48 <untseac> hum.. I'll start learning haskell after I finish some stuff in scala it seems like a better deal
16:02:03 <Axman6> doomlord_1: ha, love it
16:02:07 <untseac> scala still has the jvm advantage though, for now
16:02:10 <dibblego> as for learning, definitely stick with haskell
16:02:10 <Axman6> uh, dibblego
16:02:16 <doomlord_1> ok
16:02:39 <Axman6> sorry doomlord_1, wrong person
16:02:54 <doomlord_1> d****
16:05:28 <doomlord_1> at least he isn't called 'doomrobo'
16:05:28 <beckyconning> howcome <|> works like that with maybes? hoogle won't help me more than telling me that its an "associative binary operation"
16:05:28 <untseac> "learn you a haskell for great good" has such funny pictures :D
16:05:28 <untseac> those pictures alone make me want to read the whole thing
16:05:28 <merijn> beckyconning: Because that's how it is defined?
16:05:28 <joelteon> beckyconning: that's all it is
16:05:28 <merijn> beckyconning: You'll want to look up the rules for the Alternative class
16:05:28 <shachaf> beckyconning: Well, that tells you a lot.
16:05:28 <dibblego> However, Functional Programming in Scala, is an excellent book written by people well-qualified to teach functional programming, though crippled by Scala, which I think is ultimately a net gain in terms of learning.
16:05:28 <merijn> joelteon: That's not all it is, it has laws too
16:05:28 <joelteon> well, depends on your definition of "is"
16:05:28 <shachaf> merijn: What are the laws?
16:05:28 <beckyconning> *looks up the alternative class*
16:05:50 <merijn> shachaf: I thought it did, doesn't it? MonadPlus has laws...I was under the impression Alternative was supposed to be consistent with MonadPlus?
16:06:00 <benmachine> beckyconning: how else could it work?
16:06:25 <shachaf> merijn: It's possible. What are the laws?
16:06:54 <beckyconning> benmachine: i don't know lol. i just needed to know that i'd "want to look up the rules for the Alternative class" in order to move on : )
16:06:58 <merijn> shachaf: I dunno off of the top of my had
16:07:15 <merijn> And my internet is acting up so I'm not able to Google for them
16:07:39 <untseac> digglego, thanks I'll read that book.
16:08:07 <Peaker> I think MonadPlus has:   mzero >>= f  =  mzero      f >>= \_ -> mzero  =  mzero  (broken by many monads)   and ordinary monoid laws about mzero/mplus
16:08:19 <untseac> dibblego, oops wrong name. anyway thanks I'll read that book.
16:08:22 <benmachine> beckyconning: I think that <|> originally came from parsers, where p <|> q was like, try parsing with p, and if it fails try q instead
16:08:25 <kadoban> Aren't the Alternative laws just the applicative ones and the monoid ones?
16:08:26 <merijn> shachaf: Alternative has to follow the monoid laws
16:08:29 <dibblego> untseac: goodo, enjoy
16:08:51 <Peaker> kadoban: probably like mzero, there's a law to say "empty" that's combined applicatively remains "empty"
16:08:55 <benmachine> beckyconning: the Maybe case is a bit like that, try getting the value from p, if it doesn't have one try getting it from q instead
16:09:21 <kadoban> Peaker: Yeah, I would think that would be required. All I remember off the top of my head is that and the associativity one
16:09:21 <benmachine> I think there are definitely some proposed Alternative laws that make it and Applicative some kind of ring-like structure
16:09:24 <merijn> beckyconning: <|> behaves like mappend, so "empty <|> x = x" "x <|> empty = x" and  "x <|> (y <|> z) = (x <|> y) <|> z"
16:09:25 <benmachine> a seminearring or something
16:09:40 <benmachine> don't remember if they're official
16:09:47 <merijn> benmachine: That's a wrong intuition for Alternative
16:09:48 <merijn> Because
16:09:57 <merijn> > [1,2] <|> [3,4]
16:09:59 <lambdabot>  [1,2,3,4]
16:10:11 <merijn> benmachine: Your intuition suggests "[1,2]" as result
16:10:16 <benmachine> merijn: I disagree
16:10:33 <benmachine> you try getting values from the left-hand value, and when you've run out, try getting htem from the right-hand value
16:11:00 <benmachine> ok, so I agree the intuition is not clear in the list case
16:11:07 <beckyconning> benmachine: cool : ) i think the docs aren't too clear about that to people unfamiliar with the terminology. maybe it could be useful if each instance had a doc page. like a page for Alternative [], Alternative Maybe and Alternative ReadP.
16:11:07 <merijn> benmachine: That's not necessarily true, because the other definition would still obey the laws (i.e. returning [1,2])
16:11:09 <beckyconning> i suppose you are meant to read the source so thats what i'll try next.
16:11:16 <kazagistar> I just posted a question on /r/haskell about Alternative laws, and was going to ask it here... and the conversation is already there :P
16:11:29 <merijn> kazagistar: http://www.haskell.org/haskellwiki/Typeclassopedia#Other_monoidal_classes:_Alternative.2C_MonadPlus.2C_ArrowPlus
16:11:48 <benmachine> merijn: anyway, I never claimed the intuition was universal :P just that the Maybe case was like the parser case, and the parser case was the motivating case for Alternative
16:11:57 <benmachine> beckyconning: I believe you're not the first person to want that
16:12:06 <benmachine> documenting instances, I mean
16:12:21 <benmachine> but I guess it hasn't been done yet, unfortunately
16:12:22 <beckyconning> *nods* it seems like a useful learning tool
16:13:19 <beckyconning> this isn't too hard to figure out though
16:13:22 <beckyconning> https://www.irccloud.com/pastebin/ex4g9dRH
16:13:34 <merijn> Well, write it up and file a trac ticket ;) I should go back to work...
16:14:09 <benmachine> I'm not sure if it's useful or not, but it's true that having Alternative is equivalent to having empty :: f Void and (<+>) :: f a -> f b -> f (Either a b)
16:14:33 <shachaf> benmachine: Is it?
16:14:46 <benmachine> shachaf: assuming f is a Functor, yes
16:15:05 <shachaf> (I'm not saying it isn't, it's just kind of surprising because Applicative has this type-changing structure but Alternative doesn't, and there's no way that I know of to get rid of it for Applicative.)
16:15:12 <kazagistar> so there are no laws regarding the interaction between <|> and Applicative/Functor?
16:15:19 <benmachine> shachaf: see http://stackoverflow.com/q/23316255/812053 for some details
16:15:26 <sinelaw> how to make this less ugly?
16:15:27 <sinelaw>     Nothing -> lift . lift . lift . left $ TypeError ("Unbound variable: " ++ name)
16:15:37 <sinelaw> it's a stack of monad transformers
16:16:01 <shachaf> lift . loft . luft . left
16:16:07 <glguy> sinelaw:    throwTypeCheckerError =  lift . lift . lift . left
16:16:16 <glguy> now you can write:   throwTypeCheckerError (TypeError ("Unbound variable: " ++ name))
16:16:19 <albeit> How can I make this datatype strict in its fields? data Foo = Foo [Bar] [Bar]
16:16:24 <benmachine> shachaf: x <+> y = fmap Left x <|> fmap Right y, x <|> y = fmap (either id id) (x <+> y)
16:16:25 <sinelaw> is there a more general solution?
16:16:34 <orbisvicis> i need to modify a text file depending on current contents. The problems are a) whether reading the entire contents or a line, writing back would modify the reading b) immaterial anyway, when reading entire contents the file is semi-closed c) can't have multiple handles to same file. What should I do? I've seen suggestions a) System.IO.Strict or Data.ByteString (strict), downside is entire file is read before being process (I think) b) lengt
16:16:35 <sinelaw> there are many ops that need to be lifted
16:16:42 <glguy> sinelaw: You should really only be using lifts to define your primitive operations
16:16:43 <sinelaw> each one a different number of times
16:16:52 <glguy> and then writing your code using those primitives
16:16:56 <dhrosa> is there syntax or something for making a MonadPlus return mzero if a pattern match fails in a  do-block?
16:17:08 <dhrosa> I thought I saw a ghc extension for this or something  but I must have mis-remembered
16:17:17 <sshine> sinelaw, when you define a stack of monad transformers, you can derive things like MonadState, MonadReader, MonadWriter, etc. such that their combinators work with implicit lifting, as I understand it.
16:17:17 <sinelaw> hm
16:17:38 <shachaf> benmachine: Yes, I remember that implementation.
16:18:11 <shachaf> benmachine: Why does it work for Alternative but not for Applicative?
16:19:07 <merijn> dhrosa: I wish :(
16:19:18 <benmachine> shachaf: I haven't thought about it
16:19:27 <benmachine> shachaf: except for just now, where the answer was I dunno
16:19:31 <merijn> dhrosa: I guess sane Monad instance return mzero if they're MonadPlus instances, but this is not guaranteed :(
16:20:27 <beckyconning> i learned lots about the State monad thanks to vanila but i ended up using Ben__ 's solution because it was so much shorter (swapping catMaybes for sequence) : ) thanks so much peeps!
16:20:39 <kazagistar> orbisvicis: (I assume that you have a good reason for not just doing this atomically and writing to a new file, then copying? Alternatively, to just "save" all the changes you want to make, and then make them after reading is done?)
16:21:13 <vanila> thats great im glad we helped!
16:21:44 <shachaf> benmachine: Of course, Applicative is also just a monoid in the category of endofunctors. :-)
16:22:05 * benmachine raises an eyebrow
16:22:25 <benmachine> I'm sure that's true, but I'm going to go to bed instead of working out why :P
16:22:31 <shachaf> The category of endofunctors where the monoidal product is (f :*: g) a = (f a, g a)
16:23:09 <shachaf> You have unit :: Proxy ~> f and mult :: f :*: f ~> f
16:23:51 <benmachine> wait a sec
16:23:59 <mjrosenb> benmachine: second's up.
16:24:05 <orbisvicis> kazagistar: no good reason, except this is a simple program. as for the alternative, that is my main problem, how to save, or strictly evaluate, the changes without the ugly `seq` hack
16:24:16 <benmachine> mjrosenb: feel free to wait for as many more secs as you consider appropriate
16:24:22 <benmachine> I only require at least one
16:24:48 <benmachine> shachaf: unit :: Proxy ~> f, doesn't that specialise to (say) () -> f Void? i.e. to f Void?
16:25:03 <benmachine> shachaf: but Identity is applicative but Identity Void is not inhabited
16:25:27 <orbisvicis> (unless that was cut off in my question)
16:25:32 <shachaf> I'm talking about the usual definition with empty :: f a and (<|>) :: f a -> f a -> f a
16:25:46 <benmachine> shachaf: ah, right, so, did you misspeak when you said Applicative instead of Alternative?
16:25:52 <shachaf> And I'm talking about Alternative on its own, not together with Applicative.
16:25:57 <shachaf> Er, yes, I meant Alternative.
16:26:00 <benmachine> ah
16:26:02 <shachaf> Now I see why that would have been confusing.
16:26:03 <benmachine> makes way more sense now :)
16:26:12 * shachaf sighs.
16:27:23 * benmachine bed really this time
16:27:56 * mjrosenb considers going to bed.
16:30:10 <shachaf> benmachine: Applicative and Alternative seem to be different in an important way, with one requiring these type-changing methods and the other not.
16:30:10 <shachaf> But I don't exactly know why.
16:38:46 <samba1> a :: ToRow t => Int -> t
16:38:52 <samba1> a n = Only n
16:38:56 <samba1> Could not deduce (t ~ Only Integer)...
16:39:16 <samba1> is this because of the kind of ToRow, or because toRow it's parameterized on it's argument?
16:39:35 <ski> how is `ToRow' and `Only' defined ?
16:39:37 <joelteon> no, that's because Only a is not of type ToRow t => t
16:40:08 <samba1> ski: from the -simple database adapters
16:40:25 <ski> what is the package name ?
16:40:55 <samba1> https://github.com/lpsmith/postgresql-simple/blob/master/src/Database/PostgreSQL/Simple/ToRow.hs for example
16:43:33 <ski> samba1 : sounds like maybe you intended `a :: Int -> exists t. ToRow t *> t' ?
16:43:55 <samba1> joelteon: how can I say "something that is an instance of ToRow", which Only Int is (Only any ToField is)
16:44:20 <ski> samba1 : if you're saying `a :: forall t. ToRow t => Int -> t', then you're promising to return a value of type `t', for any type `t' the *caller* decides to choose (as long as it happens to be an instance of `ToRow')
16:44:27 <joelteon> samba1: why?
16:45:11 <ski> samba1 : why isn't `a :: Int -> Only Int' enough here ? (attempting to understand your desired use case better)
16:45:46 <samba1> ski: in this case it is, this is a minimal example of a problem i'm having in something much larger
16:46:16 <samba1> but I'm trying to make a generic type
16:46:24 <samba1> but, not that generic I guess
16:47:03 <samba1> since I can't return any type t the caller decides
16:47:03 <ski> (if you could say `a :: Int -> exists t. ToRow t *> t', then it would express that the *callee* (i.e. `a' itself, here), will decide which type `t' (which is promised to be in class `ToRow') to choose, possibly even depending on the argument of type `Int'. however, you can't (at least currently) write exactly this in Haskell. if you really want this behaviour, there are ways to achieve it, though)
16:47:42 <joelteon> oh, that's what exists is for.
16:47:51 <joelteon> Enigmagic tried to explain it to me once but I didn't understand
16:47:54 <ski> samba1 : are you wanting the function to select different types `t', depending on the values of the parameters ?
16:48:21 <ski> samba1 : are you wanting to pass several functions, each having chosen a different `t', through the same interface ?
16:49:02 <samba1> i'm writing a generic type, one with a long signature, and in the middle there is something that will be a ToRow instance
16:49:20 <ski> can you show this type ?
16:50:00 <samba1> this is the smallest version I can give you that shows the problem, but it's still big enough to be confusing without context
16:50:08 <yyttr3> Where can I find the read definitions for typeclasses like Int, [], Maybe, etc?
16:50:16 <yyttr3> Like, the source code.
16:50:19 <samba1> (Monad m, FromRow fr, ToRow tr) => (Query -> tr -> m [fr]) -> m [fr]
16:50:55 <ski> samba1 : and you want to use this type where ? in a type signature ? in a `type'/`data'/`newtype' definition ?
16:51:15 <codehero> okay. lenses... let's do this
16:51:21 <ski> samba1 : inside some larger type expression ?
16:51:59 <samba1> ski: in a type definition, to make signatures more understandable
16:51:59 <samba1> like an alias
16:52:09 <ski> samba1 : it would also help to see code which is supposed to use this
16:52:30 <samba1> ski: Like func :: Int -> Char -> MyType
16:52:58 <juanpablo_> Hey quick question: anybody knows if unneeded pragmas enabling unused extensions in a Haskell file can slow down compilation?
16:53:01 <ski> samba1 : well, you can't type :
16:53:03 <ski>   type MyType = (Monad m, FromRow fr, ToRow tr) => (Query -> tr -> m [fr]) -> m [fr]
16:53:07 <ski> perhaps you really meant
16:53:14 <ski>   type MyType = forall m fr tr. (Monad m, FromRow fr, ToRow tr) => (Query -> tr -> m [fr]) -> m [fr]
16:53:17 <ski> or
16:53:20 <ski>   type MyType m fr tr = (Monad m, FromRow fr, ToRow tr) => (Query -> tr -> m [fr]) -> m [fr]
16:53:29 <ski> or some intermediate variant
16:53:37 <ski> i don't know which
16:53:58 <ski> samba1 : do you understand the difference between the two last versions ?
16:54:56 <samba1> ski: roughly
16:54:59 <ski> samba1 : .. perhaps i should first ask, do you understand what `forall' in a type means ?
16:55:09 <samba1> ski: yes
16:55:24 <samba1> ski: well, maybe
16:55:44 <samba1> ski: what does the explicit forall do when rankntypes is there?
16:55:46 <ski> (maybe for the `forall' ? question ?)
16:56:03 <ski> `forall' still means the same thing
16:56:07 <samba1> ski: you say I can't type:, but I can make that type
16:56:14 <samba1> with RankNTypes, of course
16:56:16 <ski> `RankNTypes' just means that it is allowed in more places than otherwise
16:59:44 <ski> samba1 : well, apparently GHC allows `type MyType = (Monad m, FromRow fr, ToRow tr) => (Query -> tr -> m [fr]) -> m [fr]' as a shorthand for `type MyType = forall m fr tr. (Monad m, FromRow fr, ToRow tr) => (Query -> tr -> m [fr]) -> m [fr]'
16:59:57 <ski> (i didn't know it did this. i can't say i really like it)
17:00:52 <samba1> ski: I'm not sure what it would mean otherwise
17:01:12 <ski> i would prefer it to disallowed
17:01:23 <samba1> I can use the parameterized type (your second), with FlexibleContexts, and it works I think (it checks)
17:01:47 <ski> unless `m',`fr',`tr' were already otherwise in scope (as it would possibly be with future extensions like module parameters or local type definitions)
17:01:50 <samba1> but then I've lost the brevity I was looking for
17:01:57 <codehero> oh man. lenses are so complicated
17:02:18 <ski> samba1 : anyway, having some real code to discuss would make it easier for me to ask you questions about which possible variant that you really intended
17:04:37 <yyttr3> Is there an in depth tutorial on how to create instances of Read?
17:04:38 <yyttr3> I keep reading documentation and I cant understand it
17:05:05 <juanpablo_> Hey quick question: anybody knows if unneeded pragmas enabling unused extensions in a Haskell file can slow down compilation?
17:05:12 <ski> (samba1 : i *could* ask you questions about your suggested `myfunc' above, but as it looks like it's not that close to your actual code, it would presumable also feel strange for you to attempt to answer my questions about your intended interpretation of it)
17:05:38 <ski> yyttr3 : do you have any particular `data' or `newtype' definition you want an instance for ?
17:05:51 <samba1> ski: I'm afraid the very code I'm working on is too specialized... explaining it all will take too long. The function that has this in it's signature will return it as sort of a partially applied function, and I just want to stress that that function needs something that takes a query and a ToRow and produces a m [fr], and will then apply it
17:07:30 <samba1> it's a function with a prebuilt query inside it, and if you give it database stuff (a partially applied `query conn`, for instance), it will "go"
17:08:24 <samba1> it works without a constraint at all, in fact. I can take out the "ToRow tr", and just have tr be totally open, and when used the proper way it will typecheck and work still
17:08:57 <samba1> but the FromRow part works, so I'm trying to get the ToRow part to work as well
17:09:12 <ski> yyttr3 : the main operations to know about are `read',`reads',`readsPrec',`readParen',`lex'
17:10:26 <ski> samba1 : hm .. it looks like this is using CPS, right ?
17:11:01 <kazagistar> orbisvicis: sorry, I was gone for a bit... I assume your problem is with lazy IO, and the usual solution is to Pipes or Conduit
17:11:22 <ski> samba1 : it may be that what you want is `type MyType = forall m tr. (Monad m,FromRow fr) => (forall tr. ToRow tr => Query -> tr -> m [fr]) -> m [fr]'
17:11:52 <pamojarpan> free mo
17:12:05 <samba1> ski: i suppose in a way... I hadn't thought of it like that
17:12:15 <ski> samba1 : which logically speaking is basically `type MyType = forall m tr. (Monad m,FromRow fr) => ContT m [fr] (exists tr. ToRow tr *> (Query,tr))'
17:12:29 <ski> (which is why i was mentioning `exists' above)
17:15:11 <ski> samba1 : so, for any value (turning out to be a function) of type `MyType', it will take a "callback" function (a continuation) as argument, and the function will decide which type `tr' to use for its callback function, passing a `Query' and a `tr' to it to get a `m [ft]', which it might perhaps post-process a little before returning that as the result
17:15:28 <ski> samba1 : does that sound like what you want to do?
17:17:06 <samba1> ski: in fact, by the time MyType is made, the type of tr is known
17:17:58 <ski> samba1 : .. but perhaps not by the time some particular interface involving `MyType' is made ?
17:18:10 <samba1> ski: if there's a function :: Int -> Char -> MyType, at the end of that, the tr in MyType will be a concrete type.
17:18:17 <ski> (also, s/the type of/the type/)
17:18:42 <ski> samba1 : by "at the end of that", i assume you mean *after* the `Int' and `Char' parameters have been analyzed
17:19:29 <samba1> ski: yes, the function generating the MyType will have made it with some definite ToRow instance, such as Only Int, from my original example
17:20:17 <ski> ok, if the choice of the type `tr' depends on the *values* of the parameters (here of type `Int' and `Char'), then you definitely want (some encoding of) existentials
17:20:46 <samba1> so the function knows, but the type can be used across different functions. they'll all output something that's a ToRow, but they could all be different ToRow instances
17:21:08 <samba1> So I could parameterize MyType just on the ToRow and it will work
17:21:11 <ski> yeah, the existentials also cover that use case
17:21:12 <samba1> but, that still seems strange
17:21:15 * hackagebot hOpenPGP 1.6 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-1.6 (ClintAdams)
17:22:39 * ski still isn't sure why samba1 is using CPS
17:22:59 <samba1> ski: I was hoping to not need to make my own type that's just decorating ToRow
17:23:01 <ski> if it's *only* to encode existentials, then there is an alternative way to encode them (which you could consider)
17:23:14 <ski> but perhaps you're also using the CPS for some other thing here
17:23:35 * ski isn't sure what samba1 means by "type that's just decorating ToRow"
17:26:16 * hackagebot limp 0.3.1.0 - representation of Integer Linear Programs  http://hackage.haskell.org/package/limp-0.3.1.0 (amosrobinson)
17:26:17 <samba1> it's strange to have a function return something of MyType Integer when the fact that it's an integer has already been observed, the integer is already embedded in there.
17:26:27 <samba1> I don't know how to say this
17:27:50 <samba1> By the time anything using MyType has it, the fact that there's an Integer in it is no longer interesting. All that matters is that it's a ToRow instance. If it's an integer, okay, if it's something else, who cares. So, from a users perspective, I don't care about the parameter on MyType
17:28:17 <ski> ok
17:28:24 <ski> sounds fine
17:28:41 <ski> how about `m' as a parameter ?
17:29:24 <samba1> what do you mean?
17:29:25 <ski> or could you possibly replace `m [fr]' by `o', and your code will still work ?
17:29:49 <ski> "`m' as a parameter" :
17:29:51 <samba1> probably
17:30:07 <samba1> since m [fr] is a subset of an unqualified "o"
17:30:15 <ski>   type MyType m = forall fr. FromRow fr => (forall tr. ToRow tr => Query -> tr -> m [fr]) -> m [fr]
17:30:37 <ski> ok, if
17:30:52 <ski>   type MyType = forall o. (forall tr. ToRow tr => Query -> tr -> o) -> o
17:31:02 <ski> then this is even more clearly plain CPS
17:31:14 <ski> and so you could possibly then instead use
17:31:16 * hackagebot limp-cbc 0.3.1.0 - bindings for integer linear programming solver Coin/CBC  http://hackage.haskell.org/package/limp-cbc-0.3.1.0 (amosrobinson)
17:31:35 <ski>   data MyType = forall tr. ToRow tr => WrapMyType Query tr
17:31:58 <ski> (which would then avoid the need to passing a callback)
17:33:11 <ski> that declaration would yield a data constructor
17:33:37 <ski>   WrapMyType :: forall tr. ToRow tr => Query -> tr -> MyType
17:33:48 <ski> that *hides* the type `tr', when applied
17:33:53 <ski> this amounts to the same as
17:34:08 <ski>   WrapMyType :: Query -> (exists tr. ToRow tr *> tr) -> MyType
17:34:14 <ski> and is basically the same as
17:34:25 <ski>   WrapMyType :: (exists tr. ToRow tr *> (Query,tr)) -> MyType
17:34:43 <ski> which mentions the `exists tr. ToRow tr *> (Query,tr)' i referred to earlier
17:35:05 <ski> samba1 : i'm not sure whether this made you any wiser ..
17:36:30 <coiler3> I have a very dumb question... when I do something like let x = 4 + 5 , and then call x , when does the actual value (9) get computed? each time x is evaluated? or only the first time? or maybe on decleration time?
17:36:49 <triliyn> It is computed the first time x is evaluated
17:37:01 <samba1> ski: I'm trying
17:37:20 <coiler3> and then the value is 'remembered' on further calls to x?
17:38:40 <ski> coiler3 : in call-by-need / lazy evaluation, yes
17:39:24 <ski> samba1 : if anything i said is unclear, just ask, and i'll try to elaborate
17:40:11 <zwer> coiler3 you can test this yourself with Debug.Trace
17:40:17 <zwer> let x = Debug.Trace.trace "calculating" (4 + 5)
17:40:24 <zwer> then type x twice in the repl
17:40:59 <coiler3> hmm, for both time it shows me "calculating" and 9?
17:41:30 <zwer> are you typing 'let x = Debug.Trace.trace "calculating" (4 + 5)' in one line then x in another?
17:41:38 <coiler3> yes
17:42:14 <zwer> are you defining x twice?
17:43:02 <coiler3> no, copied what you wrote, and then typed x, and once more x
17:43:07 <zwer> http://lpaste.net/111250
17:43:23 <coiler3> yes
17:43:50 <zwer> can you copy/paste your session
17:44:00 <coiler3> http://lpaste.net/111251
17:44:15 <t4nk350> hi guys
17:44:40 <zwer> I can't replicate that
17:45:01 <coiler3> hmm, is there some sort of runtime parameter I should be using or something?
17:45:08 <zwer> no
17:45:15 <coiler3> strange :o
17:45:45 <t4nk350> is there anyway to remove privileges from game account on centos
17:46:34 <coiler3> so now I'm more confused than before asking :)
17:46:49 <zwer> coiler3 sorry. it should have only printed it once :)
17:47:03 <coiler3> so what does it mean that on my repl it does it twice?
17:47:17 <zwer> no clue. perhaps someone else can enlighten us
17:47:49 <ski> t4nk350 : perhaps you meant to ask in #centos ?
17:49:33 <t4nk350> @ski yes
17:49:33 <lambdabot> Maybe you meant: wiki src ask
17:52:42 <alrunner4> coiler3 zwer: appears to have something to do with ghci's handling of polymorhpic bindings
17:53:05 <alrunner4> if you type it as Int, it won't trace again
17:53:15 <zwer> alrunner4 interesting
17:53:31 <mhall> does anyone know if there are haskell bindings for SDL2_net?
17:53:44 <zwer> coiler3 so try this: let x = Debug.Trace.trace "calculating" (4 + 5) :: Int
17:55:09 <alrunner4> you can also use ":show bindings" to see what's already computed
17:55:09 <zwer> alrunner4 is this a bug? what does the standard say, should it be evaluated once per type?
17:55:26 <alrunner4> in a real program, it will be
17:56:18 <zwer> yeah, but ghci should follow standard too. if this is indeed guaranteed
17:57:39 <alrunner4> i think ghci is being conservative since x :: Num a => a can be evaluated to any Num, and can't be fixed by a single evaluation
17:57:59 <coiler3> ok, that seems to have worked
17:59:22 <ski> coiler3 : looks like you have enabled `NoMonomorphismRestriction' in GHCi or in the loaded module ?
17:59:46 <coiler3> I just installed "haskell platform"
17:59:58 <alrunner4> oddly enough, no
18:00:09 <alrunner4>  λ > let x = trace "thunk" $ 4 + 5
18:00:09 <alrunner4>  λ > :t x
18:00:09 <alrunner4> x :: Num s => s
18:00:09 <alrunner4>  λ > let foo = replicate 3 x
18:00:09 <alrunner4>  λ > :t foo
18:00:11 <alrunner4> foo :: Num a => [a]
18:00:14 <alrunner4>  λ > foo
18:00:16 <alrunner4> [thunk
18:00:21 <alrunner4> 9,9,9]
18:00:22 <MP2E> I thought ghci had NoMonomorphismRestriction on by default, but I could be wrong here
18:00:40 <alrunner4> i don't believe so, at least not 7.8.3
18:00:46 <MP2E> ok :>
18:01:29 <alrunner4> ah. i think i can explain it better...
18:02:15 <alrunner4> when you tell ghci " > x " what it actually does is " > _it = x >> print _it "
18:02:16 <ski> alrunner4 : `x' in `foo' is monomorphic
18:02:38 <alrunner4> no, actually, since foo :: Num a => [a]
18:02:47 <ski> i know
18:02:58 <ski> `x' is still used monomorphically inside `foo'
18:03:17 <ski> namely `x :: s', rather than `x :: forall s. Num s => s'
18:03:39 <ski> it is the former `x', not the latter, which is passed to `replicate'
18:04:17 <alrunner4> i think ghci's behavior is caused by the binding to _it, though, not the monomorphism of x
18:04:42 <zwer> anyway, to sum it up, if we compiled the program with ghc x would be computed once for each numerical type?
18:04:43 <ski> which behaviour are you talking about atm ?
18:05:02 <zwer> is this behavior guaranteed?
18:05:06 <alrunner4> duplicate evaluation
18:05:12 <ski> zwer : no, once for each use which used it monomorphically
18:05:40 <zwer> ski I have no clue what that means
18:06:33 <ski> zwer : if you have `x :: Num s => s' (which is short for `x :: forall s. Num s => s'), then this means that the particular numeric type `s' to use isn't determined yet
18:07:17 <ski> zwer : if you used `(1 :: Integer) + x' somewhere, then *this* `x' would be determined to have type `Integer', *not* containing any type variables (like `s'). iow this use would be monomorphic
18:07:19 <zwer> so x will be calculated once when used in the Int context, another time when used in the Double context, etc?
18:07:52 <zwer> I see
18:08:15 <ski> zwer : however, if you in another place used `x * (2 :: Integer)', then `x', while still monomorphic (of type `Integer') would probably *still* reevaluate the `trace' call, *even* though the same type `Integer' was used
18:09:12 <ski> zwer : but if you said `let y = x * (2 :: Integer)', then as you reevaluate `y', the `trace' call would only be evaluated the first time
18:09:39 <coiler3> so even though you used x in two contexts where it would expect an integer, it was still reevaluated twice?
18:10:25 <ski> yes
18:10:48 <ski> the evaluated result doesn't attach to `Integer' in some sense
18:10:58 <ski> it attaches to a monomorphic "thunk"
18:11:18 <ski> and each use of `x' above would create a new thunk
18:11:53 <coiler3> ok, I think i'm starting to get it...
18:12:44 <ski> `x' itself, as you defined it, is polymorphic
18:13:08 <coiler3> I can see how learning haskell is going to be fun :)
18:13:15 <ski> by placing it in a context that expects a particular monomorphic type, you implicitly convert it to a monomorphic thing
18:13:23 <zwer> I figured we had multiple x variables, one for each type, and each one having its own thunk. I obviously misunderstood it.. I am still not sure why it works like this, and not how I imagined
18:13:28 <ski> only after this conversion will it rememeber evaluated results
18:14:02 <ski> in the usual implementation of type class constraints
18:14:10 <ski>   x :: Num s => s
18:14:14 <ski> will be implemented as
18:14:19 <ski>   x :: NumDict s -> s
18:14:29 <ski> iow, passing an extra argument of type `NumDict s' to `x'
18:14:32 <ski> and then
18:14:41 <ski>   y = x * (2 :: Integer)
18:14:45 <ski> will be implemented as
18:14:49 <Axman6> it's no coincidence that => is an arrow like ->
18:14:59 <ski>   y = x theNumIntegerDict * (2 :: Integer)
18:15:00 <ski> where
18:15:08 <ski>   theNumIntegerDict :: NumDict Integer
18:15:16 <ski> is defined to correspond to the normal
18:15:22 <ski>   instance Num Integer
18:15:24 <ski>  declaration
18:15:32 <exio4> > trace "test" 2
18:15:35 <lambdabot>  Not in scope: ‘trace’
18:16:25 <ski> coiler3,zwer : so, monomorphizing `x' from type `forall s. Num s => s' to type `Integer' corresponds to passing an implicit argument `theNumIntegerDict' to it. only *after* this has been passed will it remember the result in a thunk
18:17:34 <coiler3> and a new "thunk" is created everytime x is accessed? is that why it will always reevaluate?
18:17:39 <ski> a value of type `NumDict Integer' will contain a record of all the implementations of the methods of class `Num' (iow `(+)',&c.) for the specific tupe `Integer'
18:18:06 <ski> coiler3 : in terms of this implementation, a new thunk is created each time `x' is called on some argument of type `NumDict s'
18:18:14 <ski> so, yes
18:19:00 <coiler3> ok, I was a little confused when you said "only after this conversion will it rememeber evaluated results"
18:19:09 <zwer> coiler3 note that this happens only when x has polymorphic type, like Num a => a. if the type is exact result is only calculated once, on first evaluation
18:19:29 <coiler3> that makes sense
18:19:47 <exio4> coiler3: try    let { x :: Int; x = trace "..." 2; } in x-x*x+x
18:20:00 <exio4> you'll see "..." once
18:20:10 <exio4> :P
18:20:40 <pjdelport> coiler3: If it helps, you can in some sense think of a value like 5 :: Num a => a as a "function" that gets called when you instantiate its type.
18:20:48 <ski> zwer : well, at least for polymorphic *constrained* types (iow including a constraint, like e.g. a type class constraint `Num a')
18:21:21 <ski> pjdelport : btw, that article was nice
18:21:37 <coiler3> pjdelport - thinking of it as a function is confusing because a function will always reevaluate?
18:21:44 <ceroon> > map (^2) [1..5]
18:21:45 <pjdelport> coiler3: In fact, that's literally when the the function gets chosen: the Num instance supplies the fromInteger function that returns the concrete value of 5 for that (concrete) type.
18:21:46 <lambdabot>  [1,4,9,16,25]
18:21:48 <exio4> oh, you were talking about polymorphism
18:22:01 <ceroon> > map (^2) [0..5]
18:22:03 <lambdabot>  [0,1,4,9,16,25]
18:22:12 <ceroon> how to make it [1,2,4,8,16..]?
18:22:25 <ski> > [2 ^ n | n <- [0 ..]]
18:22:27 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
18:22:34 <ski> > map (2 ^) [0 ..]
18:22:35 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
18:22:57 <ski> `(^ 2)' is the squaring function
18:23:14 <ski> `(2 ^)' is the "power of `2'" function
18:23:15 <ceroon> got it, (^2) vs (2^)
18:23:31 <exio4> > map ((^) 2) [0..]
18:23:33 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
18:23:35 <ceroon> how does this compute though? you called it on infinite list?
18:23:42 <ski> yes
18:23:50 <ski> computes just as it normally would
18:25:10 <tabemann> remember, Haskell is non-strict
18:25:33 <coiler3> so I guess it means that you should, in some cases, define the type explicitly
18:26:39 <pjdelport> ski: That article is a must-read. :)
18:27:11 <coiler3> btw, I'm learning from "learn you a haskell", is that an ok source?
18:27:49 <splintax> some people don't like it but there's nothing objectively better :)
18:28:02 <coiler3> heh
18:28:11 <ski> pjdelport : i think it more or less summarizes my position :)
18:28:19 <pjdelport> coiler3: Haskell will default the type for a type class sometimes, too. But yes... a type class must always be resolved to a concrete type before anything will run, whether by explicit types or by type inference.
18:28:57 <merijn> pjdelport: That's not true...typeclass functions can still be polymorphic at run time
18:29:54 <pjdelport> merijn: Right, right; i should qualify that to the evaluation of values.
18:31:15 <pjdelport> What i mean is that for some value "Foo a => a", there's no way to begin evaluating it without choosing a concrete Foo instance: without it, it's just an abstract value with no implementation.
18:32:50 <pjdelport> So that means that even a literal like "5 :: Num a => a" is not really a number value yet: but it becomes one when you choose a Num instance.
18:33:05 <pjdelport> And it becomes a different one depending on the Num instance:
18:33:10 <pjdelport> > 5 :: Double
18:33:12 <lambdabot>  5.0
18:33:14 <pjdelport> > 5 :: Rational
18:33:15 <lambdabot>  5 % 1
18:33:17 <pjdelport> etc.
18:38:18 <coiler3> thanks for the explanations btw
18:39:56 <ski> np
18:41:49 <codygman> Can I define w(x) = x e ^ -w (x) where e is eulers number in haskell?
18:42:20 <ceroon> list comprehensions are quite like the ones in python
18:42:44 <shachaf> You can define it but it won't do you much good. It'll just loop.
18:42:46 <merijn> ceroon: Python's list comprehensions where copied from haskell :)
18:42:50 <exio4> isn't it the other way?
18:43:10 <codygman> shachaf: Is there a way to solve for x in haskell in that equation?
18:43:49 <shachaf> Not any more than in another language.
18:44:26 <ceroon> exio4 you mean haskell got it from python, not vice versa?
18:44:45 <codygman> shachaf: so I can't have a function where w(x) is lambert product log in any language?
18:46:13 <codygman> Sorry, I'm actually asking for a friend. He is wanting to know if it is possible to model lambert's product log in Haskell or any other language I think.
18:46:22 * hackagebot hopenpgp-tools 0.10 - hOpenPGP-based command-line tools  http://hackage.haskell.org/package/hopenpgp-tools-0.10 (ClintAdams)
18:46:23 <codygman> I'm not as mathematically inclined as he is.
18:46:28 <exio4> ceroon: meant the same as merijn, but the lag killed me :P
18:47:18 <ceroon> I like list comprehensions syntax in haskell more, it looks like sets from math
18:48:39 <ceroon> if you squint a little :)
18:49:04 <pjdelport> codygman: I'm sure you can define it in Haskell, but it wouldn't be quite like that.
18:49:36 <ski> ceroon : yeah, that's the point
18:49:42 <Kaidevappy> is haskell cons O(n) under the hood?
18:49:56 <zwer> it is O(1)
18:50:24 <Kaidevappy> yeah but how does the garbage collector know that the [] has been referenced one more time without traversing the list
18:51:04 <Kaidevappy> oh I think I see how
18:51:13 <pjdelport> codygman: If i understand the math correctly, it's the inverse function of: f w = w (e ^ w)
18:51:16 <ski> the GC traverses
18:54:59 <pjdelport> Kaidevappy: If you want a bit more detail about what GHC's GC actually does, this might interest you: http://www.haskell.org/haskellwiki/GHC/Memory_Management
18:55:42 <Hafydd> G(H)C
18:56:23 <pjdelport> The Garbage Haskell Collection? :)
18:56:30 * ski . o O ( Guarded Horn Clauses )
18:58:07 <joelteon> Gharbage Collection
19:15:12 <suyase> What's the FP analogue of aggregating several data structures into a single object to be passed around as a packaged unit
19:16:24 * hackagebot mighttpd2 3.2.1 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-3.2.1 (KazuYamamoto)
19:16:48 <slack1256> suyase: maybe a product type?
19:17:03 <pjdelport> suyase: Just composition?
19:17:18 <slack1256> data Agregate = Agregate Obj1 Obj2 Obj3 ...
19:17:26 <pjdelport> creating an abstract data type, perhaps, depending on the meaning of "package"?
19:17:55 <suyase> slack1256: pjdelport package meaning anything that is conceptually a sort of container for things
19:17:56 <holymac_> im trying to run my first haskle program through Leksah but it's not working. Im getting the following error:
19:18:02 <holymac_> src\first.hs:2:1:
19:18:02 <holymac_>     parse error (possibly incorrect indentation or mismatched brackets)
19:18:07 <suyase> holymac_: haskle
19:18:17 <holymac_> Here's my code:
19:18:19 <holymac_> src\first.hs:2:1:
19:18:19 <holymac_>     parse error (possibly incorrect indentation or mismatched brackets)
19:18:31 <holymac_> let doubleMe x = x + xdoubleMe 5
19:18:35 <AshyIsMe> could also just use a tuple right?
19:18:38 <slack1256> holymac_: remember to use lpaste if its large
19:18:39 <pjdelport> @paste
19:18:39 <lambdabot> Haskell pastebin: http://lpaste.net/
19:18:44 <suyase> AshyIsMe: totally
19:18:49 <pjdelport> holymac_: Use that to paste code snippets :)
19:19:57 <pjdelport> holymac_: In your source code, you don't use "let" at the top level like you do in ghci.
19:19:57 <pjdelport> So to write that declaration in first.hs, you'd probably just have a line that says "doubleMe x = x + xdoubleMe 5"
19:19:57 <holymac_> http://lpaste.net/111261
19:20:28 <lpaste> pjdelport annotated “first haskell program” with “One way to do it” at http://lpaste.net/111261#a111262
19:20:47 <ski> holymac_ : you could also define `main = print (doubleMe 5)'
19:20:55 <slack1256> that would work only in ghci.
19:21:51 <holymac_> alright.
19:22:15 <pjdelport> holymac_: Right, the "print $ doubleMe 5" means the same as "print (doubleMe 5)", sorry.
19:22:27 <pjdelport> $ is just a function application operator
19:22:57 <pjdelport> (You'll see it a lot in Haskell code: it helps to reduce the number of parentheses you have to keep track of.)
19:23:15 <pjdelport> holymac_: Are you following a tutorial?
19:23:39 <systemfault> > pure (+2) <*> 8
19:23:41 <lambdabot>  No instance for (GHC.Show.Show (f0 b0))
19:23:41 <lambdabot>    arising from a use of ‘M203183066183489240628498.show_M2031830661834892406...
19:23:41 <lambdabot>  The type variables ‘f0’, ‘b0’ are ambiguous
19:23:41 <lambdabot>  Note: there are several potential instances:
19:23:41 <lambdabot>    instance [safe] GHC.Show.Show a =>
19:24:29 <holymac_> i am following http://learnyouahaskell.com/ and things were working great under ghci
19:24:44 <holymac_> i decided to use leksah now i gotta figure out how leksah works
19:24:51 <pjdelport> holymac_: ghci works a bit differently: it's an interactive environment.
19:24:53 <ski> holymac_ : what you type into the interactor isn't the same as what you type into a source file
19:25:11 <pjdelport> But a source file is generally just a collection of definitions, like "foo = bar"
19:25:11 <holymac_> ski, dangit
19:25:38 <pjdelport> holymac_: The definitions in a source file don't really have any order: they all just stand next to each other.
19:26:06 <holymac_> okay.
19:26:42 <pjdelport> It's different to ghci, where you *do* have an order: only after "let x = ..." does x become visible.
19:26:49 <ski> you can't really write expressions in the source file which will be evaluated (and printed) as soon as the file is loaded
19:27:07 <pjdelport> holymac_: You'll learn about something called "do syntax" later on, and do-syntax works a bit like ghci.
19:27:14 <ski> you can write `test0 = doubleMe 5' e.g., and then load the file into the interactor and type `test0' to try it out
19:27:42 <ski> you can also define the `main' thing, which will automatically get run if you compile the program to an executable file
19:28:16 <ski> (and the `print' in the example for `main' tells it to print the argument, when `main' gets run)
19:28:42 <holymac_> yeaa. i guess im understanding this more. Im using leksah to write my source file to define my functions, running, and compiling. Im then using the interator to execute my functions.
19:29:39 <ski> that's good
19:30:44 <lpaste> pjdelport annotated “first haskell program” with “Another way to do it (analogous to ghci)” at http://lpaste.net/111261#a111264
19:31:17 <pjdelport> holymac_: Don't worry too much about that second annotation, but that's just to give you a little taste. :)
19:31:31 <pjdelport> You'll see that the let inside that "do" block looks like ghci.
19:32:13 <pjdelport> ghci is not exactly the same as a do block, but you can think of them as being related, particularly in ways like using "let" like that.
19:32:56 <kadoban> I found ghci quite confusing when I was first starting. I got much farther writing in a text file and running it with 'runhaskell', seemed much more clear that way to me.
19:33:36 <pjdelport> holymac_: The only other difference is that ghci will automatically print the result for you if you just type an expression like "doubleMe 5", for convenience.
19:33:53 <pjdelport> (whereas you have to explicitly print when writing a normal program)
19:38:15 <chrisdotcode> guys, what's the algorithmic efficiency of (++)?
19:38:32 <vanila> it's O(n) in the length of the first list
19:38:33 <chrisdotcode> O(n+m), or O(n)?
19:38:50 <vanila> it just conses onto the second list, so that part is shared
19:39:21 <chrisdotcode> vanila: so only O(n), then?
19:41:09 <pjdelport> chrisdotcode: Intuitively, you can think of (++) as making a copy of the first list whose tail just points at the second list.
19:42:01 <pjdelport> Or put another way, (++) is just iterated (:).
19:42:02 <chrisdotcode> pjdelport: I was thinking that it might just make a pointer from the end of the first to the start of the second, intuitively
19:42:13 <chrisdotcode> but then it would be O(1)
19:42:27 <pjdelport> chrisdotcode: Yes, but it has to make a copy before it can do that. :)
19:42:34 <pjdelport> It can't modify the existing list in-place.
19:43:06 <stolaruk> I have a record data type with a field of type "(Text -> Text)". I tried to derive Show and Eq, but ghc complained: "possible fix: use a standalone 'deriving instance' declaration". I hadn't heard of this before. Is this a possible viable solution for a record type containing a function?
19:43:15 <c74d> Does foldr make sense applied to an infinite list?
19:43:15 <chrisdotcode> pjdelport, vanila: thanks guys
19:43:42 <pjdelport> c74d: Yes.
19:44:03 <dibblego> c74d: certainly does
19:44:13 <pjdelport> > foldr ((:) . negate) [] [1..]
19:44:15 <lambdabot>  [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21,...
19:44:15 <dibblego> > head (foldr (:) [] [1..])
19:44:15 <chrisdotcode> c74d: take 4 $ foldr (+) 0 [1..] for eample
19:44:16 <lambdabot>  1
19:44:29 <dibblego> @google explain list folds to yourself
19:44:30 <lambdabot> http://functionaltalks.org/2013/06/19/tony-morris-explain-list-folds-to-yourself/
19:44:30 <lambdabot> Title: Tony Morris: Explain List Folds to Yourself – FunctionalTalks.org
19:45:12 <kadoban> stolaruk: I'm not an expert, but I don't think you can derive those when your sub-types aren't instances themselves
19:45:13 <dibblego> you may think of (foldr f z x) as replacing (in z) every (:) with f and [] with z, however, there is no particular order by which this occurs
19:45:22 <kadoban> I'm sure sub-types is the complete wrong term, but whatever...
19:45:23 <dibblego> s/in z/in x
19:45:34 <stolaruk> kadoban: you mean the types of the records
19:45:39 <c74d> > take 4 $ foldr (+) 0 [1..]
19:45:41 <lambdabot>  No instance for (GHC.Show.Show a0)
19:45:41 <lambdabot>    arising from a use of ‘M256092609617486046528853.show_M2560926096174860465...
19:45:41 <lambdabot>  The type variable ‘a0’ is ambiguous
19:45:41 <lambdabot>  Note: there are several potential instances:
19:45:41 <lambdabot>    instance [safe] GHC.Show.Show
19:45:42 <kadoban> stolaruk: Yeah
19:46:06 <kadoban> stolaruk: I mean, what would it do with those? I'm not sure if I could figure it out, so the compiler is probably screwed.
19:46:09 <stolaruk> kadoban: unfortunately it looks like I can't pattern match on my type if it isn't an instance of Eq
19:46:35 <stolaruk> kadoban: Yeah, it is entirely reasonable that functions cannot be compared for equality or shown
19:46:57 <kadoban> stolaruk: Well, you can make your own instance of Eq if you need one.
19:47:10 <stolaruk> kadoban: Yes that's not the end of the world
19:47:24 <stolaruk> Thanks
19:47:26 <dibblego> c74d: (+) is strict, so no answer there
19:50:50 <pjdelport> c74d: foldr itself will work with infinite lists, but a strict function passed to it may still try to consume the entire infinite list, like (+) does.
19:51:21 <slack1256> basically foldr needs a function lazy on its second argument to be well behaved on infinite list
19:51:31 <slack1256> > foldr (const 5) [1..]
19:51:33 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
19:51:33 <lambdabot>    arising from a use of ‘M704045925815538036828948.show_M7040459258155380368...
19:51:33 <lambdabot>  The type variable ‘t0’ is ambiguous
19:51:33 <lambdabot>  Note: there are several potential instances:
19:51:33 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
19:51:50 <slack1256> don't embarrass me lambdabot!
19:51:54 <chirpsalot> Wait...
19:51:58 <chirpsalot> Why is (+) strict?
19:52:04 <pjdelport> So with most numeric types, "foldr (+) 0 [1..]" would never terminate. (But you do get lazy numeric types, where that code will actually work sensibly.)
19:52:16 <chirpsalot> (This is probably a dumb question)
19:52:16 <jmcarthur> chirpsalot: it's strict for Int, Integer, etc., at least
19:52:17 <dibblego> chirpsalot: because of the way the types of its arguments map to hardware
19:52:27 <dibblego> you can write (+) on say, Nat, then get an answer
19:52:38 <pjdelport> chirpsalot: It must evaluate both its arguments before it can return a result. (For strict numeric types, at least.)
19:52:51 <jmcarthur> chirpsalot: it's strict (in both arguments) because  _|_ + _ = _|_  and   _ + _|_ = _|_
19:53:27 <chirpsalot> jmcarthur: oh, so no point in being lazy... Fair enough.
19:53:49 <jmcarthur> chirpsalot: well, actually, i just cited the very definition of what it takes for a function to be strict
19:54:04 <jmcarthur> chirpsalot: put precisely, a function f is strict iff f _|_ = _|_
19:54:35 <chirpsalot> jmcarthur: I don't think I have seen this before? Maybe this is why I am confused.
19:54:42 <pjdelport> chrisdotcode: Actually, the best way to answer that question is probably to ask yourself: What would it mean for (+) to be lazy?
19:54:55 <jmcarthur> chirpsalot: _|_ is pronounced "bottom" and just represents nontermination
19:55:30 <pjdelport> In other words, how would you evaluate "a + b" without first evaluating both a and b fully?
19:55:50 * slack1256 hopes nobody mentions lazy peano aritmetic
19:55:52 <jmcarthur> > undefined + 0
19:55:53 <slack1256> DAMN
19:55:53 <lambdabot>  *Exception: Prelude.undefined
19:55:55 <jmcarthur> > 0 + undefined
19:55:57 <lambdabot>  *Exception: Prelude.undefined
19:56:06 <jmcarthur> slack1256: somebody already alluded to it
19:56:11 <jmcarthur> before you
19:56:11 <pjdelport> (like how you can evaluate "x : xs" without fully evaluating both x and xs)
19:57:06 <chirpsalot> jmcarthur: I know bottom! pjdelport I was realizing this when I was saying "probably a dumb question" :).
19:57:25 <chirpsalot> jmcarthur: I just mean I haven't seen that definition of strict.
19:57:39 <dibblego> Here is a lazy addition (.+.) on natural numbers, where we ask the question if infinity is greater than 4 https://gist.github.com/tonymorris/9b38f5335228ec3ab36a
19:57:45 <pjdelport> It's short for "strict in its arguments", to be technical.
19:57:57 <dibblego> sorry slack1256
19:58:34 <slack1256> meh, somebody would have done it sooner or later
19:58:35 <pjdelport> Here's a quick Num instance for Peano numerals: http://lpaste.net/109301
19:59:06 <dibblego> *if the sum of the list zero to infinity is greater than 4
20:01:42 <benzrf> > view _Right (Left 3)
20:01:45 <lambdabot>  ()
20:01:48 <benzrf> > view _Right (Right 3)
20:01:50 <lambdabot>  No instance for (GHC.Show.Show a0)
20:01:50 <lambdabot>    arising from a use of ‘M529213061014358117229198.show_M5292130610143581172...
20:01:50 <lambdabot>  The type variable ‘a0’ is ambiguous
20:01:50 <lambdabot>  Note: there are several potential instances:
20:01:50 <lambdabot>    instance [safe] GHC.Show.Show
20:01:59 <benzrf> oh, no monoid
20:02:06 <chrisdotcode> Why are tuple sections disabled by default?
20:02:07 <benzrf> > view _Right (Right "foo")
20:02:09 <lambdabot>  "foo"
20:02:14 <benzrf> > view _Left (Left "foo")
20:02:16 <lambdabot>  "foo"
20:02:18 <chrisdotcode> Is there something inherently evil abaout them?
20:02:21 <benzrf> > view _Left (Right "foo")
20:02:22 <lambdabot>  ()
20:02:27 <benzrf> chrisdotcode: theyre just not part of the lang
20:02:42 <benzrf> > view _Left (Right "foo") `asTypeOf` view _Left (Left "foo")
20:02:44 <lambdabot>  ""
20:03:32 <chrisdotcode> benzrf: Ah, so they're just simply an extension, then? I've heard that they were potentially confusing to beginners or something, so they were disabled.
20:03:52 <benzrf> chrisdotcode: doubt it
20:03:59 <chrisdotcode> Okay, thanks
20:04:09 <benzrf> bye
20:10:05 <systemfault> Just want to be sure... "ap" is the "<*>" of the monad world?
20:10:15 <thomaseding> yes
20:10:17 <dibblego> systemfault: yes
20:10:21 <systemfault> Thank you :)
20:11:09 <thomaseding> > summon bot
20:11:11 <lambdabot>  Not in scope: ‘summon’Not in scope: ‘bot’
20:11:11 <lambdabot>  Perhaps you meant one of these:
20:11:11 <lambdabot>    ‘not’ (imported from Data.Bool),
20:11:11 <lambdabot>    ‘both’ (imported from Control.Lens),
20:11:11 <lambdabot>    ‘bit’ (imported from Data.Bits)
20:13:25 <pjdelport> systemfault: ap and <*> are morally identical (and will be more so with the Applicative-Monad superclassing)
20:13:57 <begriffs> Is there a convenient Haskell function to generate a unique filename for a given directory?
20:14:15 <systemfault> pjdelport: Thank you
20:15:05 <dibblego> begriffs: System.IO#openTempFile
20:15:24 <flaviu1> let primeCalc (x:xs) = x : primeCalc (filter (\i -> (i `mod` x) /= 0) xs)
20:15:31 <flaviu1> > let primeCalc (x:xs) = x : primeCalc (filter (\i -> (i `mod` x) /= 0) xs)
20:15:34 <lambdabot>  not an expression: ‘let primeCalc (x:xs) = x : primeCalc (filter (\i -> (i `...
20:17:45 <stolaruk> "cabal run" appear to compile my project; is there something similar to "runghc" or "runhaskell", but will work in my sandbox?
20:17:54 <begriffs> dibblego: perfect, thanks
20:17:58 <flaviu1> @let primeCalc (x:xs) = x : primeCalc (filter (\i -> (i `mod` x) /= 0) xs)
20:18:01 <lambdabot>  Defined.
20:18:26 <flaviu1> > (primeCalc [2..]) !! 200
20:18:28 <lambdabot>  1229
20:18:46 <flaviu1> I think its pretty cool how concise that is!
20:19:09 <jTT> Hi, I’m working on a parser for log files as a practice exercise. I have defined data types and written parsers that compile. When running my program on a test file, I noticed that I am missing the last log entry in small log-files (if I copy this line once and append it to the file, the first of the two gets parsed correctly). And, more importantly, on longer log files, the parser seems to stop for no apparrent reason with a few log entries correctly parsed an
20:19:10 <jTT> printed to the screen, but ending with the following: Right [… —many correctly parsed entries — … Relude.read: no parse <— what does this at the end mean?
20:20:04 <coppro> jTT: paste a minimal reproduction and we can help you
20:28:51 <lostman> hi all. is there a simple way of chasing down all dependencies of package? I need everything down to base, not just immediate dependencies
20:30:12 <Crockeo> lostman: Not that I know of no -- someone else might have a good answer for you though.
20:30:44 <Crockeo> You could also just capture the output from a 'cabal install --only-dependencies'; maybe grep it so it's easier to work with.
20:31:00 <Crockeo> (Again, someone else might have a more streamlined version to do that.)
20:31:26 <lostman> Crockeo: I was hoping I can start with empty sandbox and do cabal install, but cabal hell gets me
20:31:30 * hackagebot mangopay 1.9.2 - Bindings to the MangoPay API  http://hackage.haskell.org/package/mangopay-1.9.2 (FelipeLessa)
20:31:51 <Crockeo> Mmmm that sucks, cabal hell is a bitch. What are you trying to install?
20:33:15 <Crockeo> Upon googling you problem, I found: https://hackage.haskell.org/package/cabal-dependency-licenses
20:33:27 <Crockeo> It needs you to cabal configure first, though, which doesn't work in your situation.
20:33:31 <lostman> my own package. it has a long-ish list of dependencies
20:33:34 <Crockeo> A good tool nonetheless.
20:34:17 <lostman> nice find. findTransitiveDependencies looks like what I need
20:35:16 <Crockeo> Oh! It does have what you need? Awesome. I'm glad to have helped (despite not thinking I did!)
20:35:18 <lostman> have you ever run into a problem where cabal reinstalls packages for no good reason? if I do cabal install X and it installs A, B, C along the way and then fails on D then when I do cabal install X again it reinstalls A, B, C from scratch
20:36:26 <Crockeo> Only when I run it with --force-reinstalls.
20:36:33 <Crockeo> Otherwise it just runs as I think it should.
20:36:44 <lostman> no, no --force-reinstalls
20:36:52 <lostman> it just does it
20:36:59 <lostman> and I have no clue why
20:37:17 <Crockeo> I also haven't really dealt with cabal hell recently; I've been working in rather stable APIs. Netwire / OpenGL / GLFW / GLUtil / vinyl-gl / vinyl. Things that aren't going to change.
20:37:19 <lostman> it might be specific to sandbox though
20:37:23 <Crockeo> (too much)
20:39:29 <lostman> I'm trying to fix my set of dependencies
20:39:33 <lostman> I'm going to mange them myself
20:42:31 <Crockeo> Well I wish you good luck; managing dependencies is by far the most annoying part of programming.
20:44:00 <rhz> Is there any way to write an efficient version of this function: setLookup :: (Ord a, Ord b) => a -> Set (a,b) -> Maybe b
20:45:32 <kadoban> rhz: It looks like you should be using a mapping type instead of Set, no?
20:45:47 <kadoban> rhz: Like, Data.Map for instance.
20:46:09 <rhz> kadoban: that seems right!
20:46:41 <copumpkin> rhz: or!
20:46:45 <copumpkin> :t M.fromSet
20:46:46 <lambdabot> (k -> a) -> S.Set k -> M.Map k a
20:46:51 <copumpkin> :t M.fromSet snd
20:46:52 <lambdabot> S.Set (a1, a) -> M.Map (a1, a) a
20:47:12 <copumpkin> oh actually
20:48:07 <copumpkin> yeah, never mind, Set (a, b) is actually "bigger" than Map a b
20:55:04 <dmj`> why does hackage never build my docs
20:55:28 <dmj`> I just do cabal sdist, at 56% haddock coverage
20:55:35 <dmj`> then cabal upload
21:00:20 <endthefed> why is haskell better?
21:00:25 <endthefed> how will it save me time?
21:08:21 <kazagistar> man, he certainly was in a hurry
21:12:09 <fiatjaf> how can I get a notion of what is Maybe, Just, Nothing?
21:12:46 <jle`> fiatjaf: are you going through a Haskell course?
21:14:19 <jle`> fiatjaf: `Maybe a` is a type, which is inhabited by two members: `Nothing`, and `Just x`, where `x` is something of type `a`
21:14:31 <jle`> two values, that is
21:14:37 <fiatjaf> jle`: I have read some tutorials
21:14:43 <jle`> so if i have a value like `Just "Hello"`
21:14:58 <jle`> it is a value, a normal vaue like any string, etc.
21:15:05 <jle`> and its *type* is `Maybe String`
21:15:15 <fiatjaf> so all strings are Just ?
21:15:26 <fiatjaf> we only omit that
21:15:27 <fiatjaf> ?
21:15:56 <jle`> do you know the difference between a value like 1 and a value like [1] ?
21:16:13 <jle`> "Hello" vs. ["Hello"]
21:16:29 <jle`> one has the type String, the other has the type [String]
21:16:34 <fiatjaf> one is a list of string?
21:16:37 <fiatjaf> ok
21:16:50 <jle`> so `"Hello"` vs. `Just "Hello"` is the same thing
21:16:58 <jle`> only instead of `[]`, we have `Just`.
21:17:06 <jle`> one is type String, and the other is type `Maybe String`
21:17:09 <jle`> they are different types
21:17:38 <jle`> `Just "hello"` is a value
21:17:42 <jle`> "hello" is a value
21:17:46 <jle`> ["hello"] is a value, etc.
21:17:49 <jle`> they all have different types
21:17:51 <jle`> :t "hello"
21:17:53 <lambdabot> [Char]
21:17:55 <jle`> oops
21:18:13 <jle`> i'm going to use True, Just True, and [True]
21:18:14 <jle`> :t True
21:18:15 <lambdabot> Bool
21:18:18 <jle`> :t [True]
21:18:19 <lambdabot> [Bool]
21:18:20 <jle`> :t Just True
21:18:21 <lambdabot> Maybe Bool
21:18:32 <jle`> they're all different values of different types
21:18:33 <dhrosa> :t Identity True
21:18:34 <lambdabot> Identity Bool
21:19:12 <jle`> so Just True is just another ol' value, and its type is `Maybe Bool`
21:19:13 <fiatjaf> :T Nothing
21:19:17 <fiatjaf> :t Nothing
21:19:17 <lambdabot> Maybe a
21:19:38 <jTT> coppro: Sorry was dealing with a colleague just now: I am not sure how to paste a minimal reproduciton… I have a function parseLogEntry :: Parser LogEntry that combines many small parsers in a do block and ends on … size <- parseSize; takeWhile1 (not . isEndOfLine ) <* endOfLine; return $ LogEntry … size ;; this is called by parseLog :: Parser [LogEntry]; parseLog = many $ parseLogEntry; and finally, main :: IO(); main = readFile logFile >>= print . parseOn
21:19:39 <jTT> parseLog   Does this make any sense? How better to show the problem/paste a minimum reproducible example?
21:20:07 <jle`> :t [Just True, Nothing]
21:20:07 <lambdabot> [Maybe Bool]
21:20:13 <jle`> it's a list of `Maybe Bool`s :)
21:20:19 <systemfault> > (4/) 2
21:20:21 <lambdabot>  2.0
21:20:26 <jle`> remember that `Maybe Bool` is inhabited by Just x, where x is a Bool, and Nothing
21:20:30 <fiatjaf> ok, so if I have a Maybe something, returned from some function, what should I do?
21:20:47 <jle`> well...what do you want to do with it?
21:20:48 <mgaut72> jTT: use http://lpaste.net/new/haskell
21:20:52 <fiatjaf> (ignore me, proceed on your explanation)
21:21:02 <jle`> there might be a couple things you want to do with a `Maybe a` value
21:21:14 <jle`> one thing is that you might want to apply a function `(a -> b)` to it
21:21:34 * hackagebot HUnit-Plus 1.0.1 - A test framework building on HUnit.  http://hackage.haskell.org/package/HUnit-Plus-1.0.1 (emc2)
21:21:42 <mishac> Hi guys, i am sorry for asking but does anyone have a 10 sec to anwser myquestion?
21:21:45 <fiatjaf> jle`: but as I do not know which operations can do with it, I could never write such a function
21:21:53 <dhrosa> mishac: ask away
21:21:57 <jle`> luckily, we have a function that can take any `a -> b` and turn it into a `Maybe a -> Maybe b`
21:22:00 <coppro> jTT: start with the code that reproduces the error. Then remove all extraneous functions. Then try and strip down outer functions until you can't any more. By the end of it, you may find that you solved the problem.
21:22:06 <jle`> we call it fmap
21:22:08 <mauke_> fiatjaf: pattern matching
21:22:10 <mishac> how would yo desugar this notation?
21:22:19 <mishac> p2 = do {item; c <- item; return c }
21:22:29 <mishac> i tried this version
21:22:33 <jle`> so if you have a `Maybe Int`, and you have an `f :: Int -> Bool`, you can use `fmap f` and use it on your `Maybe Int`, to get a `Maybe Bool`
21:22:38 <dhrosa> mishac: p2 = item >> item
21:22:46 <mauke_> @undo p2 = do {item; c <- item; return c }
21:22:46 <lambdabot> p2 = item >> item >>= \ c -> return c
21:22:51 <dhrosa> mishac: c <- item; return c is entirely redundant
21:22:55 <dhrosa> err
21:22:59 <dhrosa> yeah
21:23:11 <bakibour> Greetings
21:23:12 <mishac> ty good sir
21:23:19 <jTT> coppro: The weird thing is that I do get sensible results but at a certain length of the log file it says Prelude.read: no Parse
21:23:43 <jle`> fiatjaf: you can also use `fromMaybe`, which allows you to give a default value and then "get" the value from the `Maybe` if it's `Just`, and give the default value if it is `Nothing`
21:23:46 <coppro> jTT: ok, so find the shortest input that reproduces, and then start stripping your functions away.
21:23:48 <jle`> > fromMaybe 6 (Just 3)
21:23:49 <lambdabot>  3
21:23:54 <jle`> > fromMaybe 6 Nothing
21:23:56 <lambdabot>  6
21:24:05 <jTT> copporo: hmk, thanks
21:24:20 <mishac> Ty very much
21:24:32 <jTT> coppro: thanks
21:24:37 <jle`> another common thing people want to do with a `Maybe a` is apply a function `a -> Maybe b` to it to get a `Maybe b`.  for this, we have the `(=<<)` operator, `(=<<) :: (a -> Maybe b) -> (Maybe a -> Maybe b)
21:24:52 <bakibour> I just happened to see some Youtube videos from some conference where they showed hole driven GHC. What version of GHC-Mod is that in and can i install another version of GHC in Haskell Platform or is that advised against?
21:25:09 <jle`> you can also pattern match, but a lot of times this is uneccessary because of haskell's nice built in higher order functions
21:25:22 <jle`> but yeah...i don't think i can say much more unless you have a specific question :)
21:26:42 <fiatjaf> > fromMaybe 10 Nothing
21:26:44 <lambdabot>  10
21:27:03 <fiatjaf> > fromMaybe 10 (Just "x")
21:27:04 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Char])
21:27:04 <lambdabot>    arising from the literal ‘10’
21:27:09 <jle`> > fmap (+ 3) (Just 6)
21:27:11 <lambdabot>  Just 9
21:27:12 <jle`> :t fromMaybe
21:27:12 <fiatjaf> nice
21:27:13 <lambdabot> a -> Maybe a -> a
21:27:14 <fiatjaf> I love this
21:27:30 <jle`> fiatjaf: remember that a function has to return something of a certain/known type
21:27:44 <mauke_> > case Nothing of { Nothing -> 10; Just x -> x }
21:27:46 <lambdabot>  10
21:27:53 <mauke_> > case Just 42 of { Nothing -> 10; Just x -> x }
21:27:53 <jle`> so fromMaybe 10 (Just "x") doesn't quite work...becuse...the default  you are giving is an Int, and you're using it on a Maybe String...?  which would get returned?
21:27:54 <lambdabot>  42
21:28:09 <jfischoff> what are the options for haskell project wizards
21:28:32 <jle`> > fmap (+ 3) Nothing
21:28:33 <lambdabot>  Nothing
21:29:01 <jle`> > (\x -> if even x then Just (x `div` 2) else Nothing) =<< Just 4
21:29:03 <lambdabot>  Just 2
21:29:07 <jle`> > (\x -> if even x then Just (x `div` 2) else Nothing) =<< Just 3
21:29:09 <lambdabot>  Nothing
21:29:10 <jle`> > (\x -> if even x then Just (x `div` 2) else Nothing) =<< Nothing
21:29:12 <lambdabot>  Nothing
21:30:07 <jle`> um yeah that probably covers everything i have ever done with a Maybe value
21:30:14 <jle`> ...this is an exaggeration
21:30:30 <fiatjaf> > fmap (+ 3) (Just 6)
21:30:32 <lambdabot>  Just 9
21:30:34 <jle`> there's also `maybe :: b -> (a -> b) -> Maybe a -> b`, and you can guess what that does from the type
21:30:52 <jle`> you can also chose between two `Maybe` values with functions from Alternative
21:30:59 <fiatjaf> > fmap (+ 3) (Nothing)
21:31:00 <lambdabot>  Nothing
21:31:01 <mauke_> @djinn b -> (a -> b) -> Maybe a -> b
21:31:01 <lambdabot> f a b c =
21:31:01 <lambdabot>     case c of
21:31:01 <lambdabot>     Nothing -> a
21:31:01 <lambdabot>     Just d -> b d
21:31:21 <jle`> combine `Maybe` values with its mappend, or work with them inside monads with its FOldable/Traversable instances
21:31:23 <jle`> Maybes are nice
21:31:37 <dmj`> @typ async
21:31:38 <lambdabot> Not in scope: ‘async’
21:32:18 <fiatjaf> :t maybe
21:32:19 <lambdabot> b -> (a -> b) -> Maybe a -> b
21:32:43 <fiatjaf> maybe 3 (+ 3)
21:32:48 <fiatjaf> > maybe 3 (+ 3)
21:32:50 <lambdabot>  <Maybe Integer -> Integer>
21:33:01 <jle`> > maybe "nothing!" show (Just 5)
21:33:03 <lambdabot>  "5"
21:33:07 <jle`> > maybe "nothing!" show Nothing
21:33:08 <lambdabot>  "nothing!"
21:33:08 <fiatjaf> > maybe 3 (+ 3) (Just 10)
21:33:10 <lambdabot>  13
21:34:23 <fiatjaf> jle`, thank you very much.
21:34:25 <jle`> if you have a specific situation in mind, we can help with something in specific.  but this covers much of the basic use cases for Maybe
21:34:59 <jle`> i did a rundown of a couple other uses cases too
21:35:00 <fiatjaf> you're a walking full-featured haskell course.
21:35:54 <fiatjaf> I don't have any specific situation in mind, but this was amazingly clarifying.
21:36:28 <Crockeo> I'm just coming back from writing something, but fiatjaf: Everything just gets better from here.
21:36:38 <bakibour> Can i update GHC if i am using Haskell Platform or will it break the environment?
21:38:50 <fiatjaf> Crockeo: you mean my life?
21:39:21 <Crockeo> I specifically meant Haskell. The more you learn the cooler everything seems.
21:39:21 <endthefed> so many web libs for haskell now eh?
21:39:24 <endthefed> :)
21:39:24 <Crockeo> But yes, how about your life too.
21:39:40 <endthefed> is haskell doable on freebsd?
21:40:04 <kadoban> I know there's a ghc on freebsd, by webhost uses freebsd and has it
21:40:06 <MP2E> yeah, it's not a tier 1 platform but it is supported
21:40:17 <kadoban> s/by/my/
21:40:22 <MP2E> it's close to tier 1, I think it just needs some FreeBSD volunteers :>
21:40:59 <endthefed> ;)
21:41:11 <endthefed> who knows I may grow into one!
21:44:45 <bakibour> Can different versions of GHC installed side by side?
21:44:55 <fiatjaf> I hope so, Crockeo.
21:45:14 <fiatjaf> do you all abandon other languages when learn haskell?
21:45:53 <bakibour> fiatjaf: I do not :)
21:46:13 <shiona_> Neither did I
21:46:14 <jle`> yeah, i have a bunch of different ghc's side by side
21:46:16 <bakibour> Its good to have several tools in your belt.
21:46:17 <jle`> it works pretty well, too
21:46:28 <jle`> i think ghc and cabal are designed to make this as simple as possible
21:46:38 <bakibour> jle`: Do you happen to know if this will break some stuff in Haskell Platform?
21:46:48 <jle`> can't say anything about that, sorry
21:47:00 <bakibour> Hm ok i think ill just try it out then
21:47:01 <jle`> :\
21:47:06 <jle`> but it should work
21:47:16 <jle`> not that i have tried, though :)  so maybe you shouldn't listen to me :)
21:47:23 <bakibour> Id need to reset the Paths then though.
21:47:34 <bakibour> hehe, well its not that bad i think if it breaks.
21:47:49 <thomaseding> I used to have a couple versions of ghc installed . Not sure how cabal works with it though
21:47:58 <bakibour> Little hassel but id really like to try stuff like depenttypes or holes
21:49:22 <bakibour> What is a single site source if you want to be informed about the hot shit in the Haskell world?
21:50:10 <endthefed> anyone run a busy site on haskell?
21:50:21 <endthefed> any problems or awesomeness glaore?
21:52:33 <Crockeo> fiatjaf: I definitely did not! I regularly use Go when writing web applications. Sometimes I even work in C for low-level applications, or some OpenGL-based projects.
21:52:47 <Crockeo> That being said, most of the time when I have the choice I choose Haskell.
21:54:23 <geekosaur> endthefed, not sure how many people in this channel do. but Michael Snoyman (author of Yesod) has and has contributed to a number of improvements to GHC's runtime and various support libraries as a result. 7.8 should be pretty good.
21:54:50 <endthefed> fabulous
21:55:32 <geekosaur> that said, for good performance you should probably use pipes or conduit instead of the I/O in base
21:55:58 <geekosaur> (they're somewhat harder to use but have much better performance than the simpler stuff in base)
21:56:36 <geekosaur> (which mostly can't be improved because it wouldn't be simple any more)
22:06:46 <bakibour> What would i need to do to write something like a performant raytracer in Haskell?
22:09:30 <endthefed> www.amazon.com how can i write that in haskkell?
22:09:34 <endthefed> he he
22:10:04 <endthefed> shopzilla.com manager was complaining to me that took 2-3 days to update prices n stuff for items on 1 part of their site
22:10:21 <endthefed> getbig.com forum would b ez to replicate I bet
22:11:07 <bakibour> Arent the prices in some database?
22:18:17 <endthefed> yeah
22:18:19 <endthefed> I dunno
22:18:31 <endthefed> I guess they are batch processed or something
22:18:35 <endthefed> and maybe qa-d
22:18:37 <endthefed> i duno
22:18:49 <endthefed> I was like cant they just go in live immediatly?
22:19:54 <fluffynukeit> hi, all!  I'm confused about exception handling in a monad transformer stack wtih IO as the base.  I've built a composite monad action by using lift, lift . lift, and liftIO to combine my actions.  Now how do I catch/handle exceptions thrown by the composite action?
22:20:44 <fluffynukeit> I'm trying catch, catchIO, catchError, etc, but I'm having a helluva time getting it to type check because of all the monad layers
22:23:39 <felixn> fluffynukeit: pop it in a gist.github.com
22:40:13 <jTT> hi, is there a funtion similat to show :: Show a => a -> String  for text? I.e. Show a => a -> Text? Hoogle was not showing up with anything?
22:40:43 <simpson> jTT: You can always just repack your strings into Text.
22:40:51 <simpson> :t T.pack . show
22:40:52 <lambdabot>     Not in scope: ‘T.pack’
22:40:52 <lambdabot>     Perhaps you meant ‘BS.pack’ (imported from Data.ByteString)
22:40:57 <simpson> :t Text.pack . show
22:40:58 <lambdabot> Not in scope: ‘Text.pack’
22:40:59 <jTT> simpson: ye, was trying to avoid that
22:41:07 <simpson> jTT: Why?
22:41:17 <rqiu> @pl \x y -> x + 1
22:41:17 <lambdabot> const . (1 +)
22:41:37 <jTT> simpson: not sure, thought it was superflous code if there is such a function
22:42:08 <simpson> jTT: Nope, the Show class is a very simple debugging class that only builds Strings.
22:42:24 <jTT> simpson: kk, thanks
22:43:48 <jTT> simpson: it just seems a bit silly in an IO block where I want to write the results of a parsing operation, like so: main = TIO.readFile logFile >>= TIO.writeFile outputFile . T.pack .  show . parseOnly parseLog
22:45:08 <jTT> simpson: seems there are many silly pack/unpack operations chained and instead I would like to have the result of the parse be writable straight away before converting from a parse - string - text - IO
22:47:07 <simpson> jTT: Sure, but Text is a packed value no matter what you do.
22:47:28 <jTT> :simpson ok, i see
22:47:40 <simpson> So you won't be able to dodge that cost.
22:48:09 <Crockeo> Does anyone around here happen to have any experience working with GLUtil.
22:48:45 <Crockeo> Specifically the camera -- I'm looking to be able to change the ortho around from its default of what's effectively glOrtho(0, 0, 1, 1, -1, 1) to something else.
22:56:41 <trap_exit> suppose ^H^H given that I'm stupid enough to write Linear Algebra routines in Haskell -- what Haskell libs should I use to maximize perfomrance? I don't want to use binidngs to Blas, I actually want to implement the actual algorithm in Haskell
22:57:53 <Crockeo> trap_exit: Not entirely sure what you're asking specifically (I'd imagine from my own ignorance more than anything), but have you heard of http://hackage.haskell.org/package/linear.
22:57:54 <Ralith> trap_exit: any meaningful answer is going to need to know specifically what sort of problems you want to solve
22:58:08 <trap_exit> oh
22:58:12 <trap_exit> just the standard routines that show up in Golub + Van Horn
22:58:26 <trap_exit> I intend to implement them for my own learning experence, an dI'd like to do it in haskell
22:58:30 <jle`> linear has nice abstractions
22:58:44 <trap_exit> damn it
22:58:46 <trap_exit> this ed k guy again
22:58:52 <trap_exit> what a hackage spammer
22:58:53 <jle`> for top performance you would probably have to go into manually writing things in Array/Vector, in ST probably
23:09:32 <Crockeo> Scratch my ortho question, by the way. Instead I just scaled all of my rendering relative to window size
23:09:52 <Crockeo> (to match up with my viewport call earlier in my code)
23:12:30 <anborn> hi, anyone already tried ghc 7.8.3 with xcode 6?
23:15:22 <Crockeo> I can't say it works for sure, but after a few google searches I can say: I would imagine that there would be more of a presence of people saying it didn't work if it didn't.
23:15:31 <Crockeo> Best way to find out would be to try, I'd say.
23:17:13 <anborn> Crockeo: yes, I'll try that ;-) The problem is that there's no way to downgrade xcode if I hit a problem ...
23:17:26 <Crockeo> Ooof nevermind then. Might not be worth it.
23:18:01 <Crockeo> I'd imagine Apple is smart enough to keep backwards compatibility with something that was working last version. Assuming xcode 5 was actually working with 7.8.3.
23:18:29 <anborn> Crockeo: yep, makes sense
23:19:10 <Crockeo> (And worst case scenario is you come over to the dark side. Vim is always calling your name)
23:21:51 <merijn> Crockeo: Your remark is ironic
23:22:06 <merijn> Crockeo: Considering the fact that the haskell platform was broken for over a year due to Apple dropping gcc for clang
23:22:38 <merijn> Also, note that XCode is not just the ide, but all compiler/linker/etc. tools on OSX
23:22:52 <Crockeo> merijn: Well then apparently I had more faith in Apple than I should have.
23:23:02 <Crockeo> anborn: DON'T DO IT. Well maybe do it.
23:23:25 <merijn> anborn: The current platform should work with Mavericks and the new OSX beta, afaik
23:23:39 <merijn> (with the relevant version of XCode)
23:26:49 <anborn> Crockeo: well, the last xcode update broke ghc. That's why I'm overly cautios...
23:27:55 <merijn> anborn: 7.8 fixed the whole gcc/clang problem and the current platform should be ok
23:29:28 <anborn> merijn: good. I'll probably try the update anyway. If anything goes bad, at least I could be the one warning others ;-)
23:36:56 <ezyang> I have to say that it is really annoying that Yesod deprecates code *from their own scaffolding*
23:37:25 <Crockeo> as in the modern scaffolding has deprecated code?
23:37:38 <ezyang> no, from whatever the modern scaffolding was back in the day
23:37:51 <ezyang> as in, now I get to go update a pile of code that I didn't even write
23:37:58 <yyttr3> Why is it that the definition "data Binary = MSB | Zero Binary | One Binary" makes Zero have type Binary -> Binary instead of kind * -> *?
23:38:17 <ezyang> yyttr3: Because that's the correct kind for it!
23:38:24 <ezyang> (when promoted)
23:38:25 <yyttr3> *?
23:38:32 <vanila> I'm so glad i learned monad transformers before they made everything 50x more complicated
23:38:54 <ezyang> if you want * -> * just write data Zero b
23:39:31 <Crockeo> yyttr3: It has Binary -> Binary because you're specifying that it /has/ to be a binary, like ezyang is saying.
23:39:38 <yyttr3> I wanted to turn Binary into a Functor, because I can pattern match out of function application.
23:40:13 <ezyang> yyttr3: I don't follow
23:40:30 <yyttr3> Like, I can say:   shiftr (One b) = b
23:40:45 <yyttr3> Which is really cool, but not important to the question
23:40:46 <jle`> yyttr3: kinds are a property of types and things on the type level...  in your case, Zero is a value level function/constructor
23:40:51 <Crockeo> I don't really think the Binary type is in such a form that a Functor makes sense.
23:41:10 <Crockeo> At least not yet.
23:41:27 <yyttr3> Well, I can create a custom function to map over it, so I thought it would be possible in some way in that form.
23:41:31 <yyttr3> I'll change it
23:42:02 <Crockeo> A functor requires the ability to satisfy * -> *, meaning that you need some sort of type parameter to your Binary. At least that's my understanding of the situation. It's 2:41 AM here so my advice might not be the most sound right now.
23:42:03 <jle`> the function `not :: Bool -> Bool`, for instance, has a type, not a kind
23:42:12 <jle`> yyttr3: note the type of fmap, btw
23:42:22 <jle`> fmap :: Functor f => (a -> b) -> f a -> f b
23:42:31 <jle`> it's actually, with explicit foralls
23:42:36 <yyttr3> I see.
23:42:41 <jle`> fmap :: forall a b. Functor f => (a -> b) -> f a -> f b
23:42:43 <yyttr3> I need a type constructor
23:42:46 <merijn> yyttr3: You appear to be confusig types and kinds? Zero takes a Binary and returns a Binary, therefore it's type is obviously "Binary -> Binary"
23:42:56 <ezyang> yyttr3: OK, I originally thought this was some oblique type-promotion question, but now I'm not sure. What are you really trying to do?
23:43:02 <merijn> yyttr3: The *type constructor* Binary takes zero arguments and is therefore kind *
23:43:03 <jle`> meaning, i should be able to take *ANY* (a -> b), and turn it into a function on your thing
23:43:09 <Crockeo> jle`: see that's the stuff I miss when I'm borderline sleep deprived.
23:43:20 <jle`> but i don't see how you could, for example, make an (Int -> Bool) work on your Binary type
23:44:00 <jle`> well, for one, the type signature doesn't even make sense when you say that Binary is a functor... fmap :: (a -> b) -> Binary a -> Binary b doesn't make sense because Binary doesn't take a parameter ;)  but that's a different story altogether :)
23:44:01 <merijn> ezyang: Also, you should get more sleep, because that is *not* the right kind for promoted Binary
23:44:18 <merijn> ezyang: The correct kind for Zero for promoted Binary is "Binary -> Binary"
23:44:41 <jle`> you might be interested in the MonoTraversable typeclass, which lets you lift monomorphic functions to things like this
23:44:48 <jle`> monomorphic functions of a specific type
23:44:53 <jle`> for example, Char for Text
23:45:01 <ezyang> I *am* kind of sleep deprived right now, but I think I got it right originally ^^
23:45:03 <jle`> Word8 for ByteString
23:45:05 <yyttr3> I'll look it up
23:45:20 <jle`> but depending on your use case there might not be much point in abstracting :P
23:45:32 <jle`> just write a mapBinary function if that's good enough :)
23:45:49 <yyttr3> That's what i'l doing lol
23:45:59 <jle`> mhm
23:46:20 <jle`> haskell's Functor typeclass was designed for a fairly specific and narrow use case that people often seem to overextend in their minds
23:46:23 <jle`> it's a common thing :)
23:46:39 <merijn> "narrow"?
23:47:15 <jle`> it's a meaningless word that is just there to remind people that their use case might not be a fit for Functor
23:47:17 <jle`> :)
23:47:31 <jle`> narrow is relative
23:47:45 <yyttr3> mapBinary :: ((Binary -> Binary)->(Binary->Binary))-> Binary -> Binary
23:48:18 <jle`> a lot of people come in with "why can't my use case X work with Functor"
23:48:35 <jle`> but they forget that Functor isn't supposed to do everything they think it should be able to do
23:48:44 <jle`> ...one of the faults from people saying "Functors are containers"
23:49:11 <jle`> "my thing is a container...why can't it be a Functor?"
23:49:24 <merijn> @define data Binary = MSB | Zero Binary | One Binary
23:49:27 <lambdabot>  Defined.
23:49:35 <merijn> :k 'Zero --ezyang
23:49:36 <lambdabot> Binary -> Binary
23:50:30 <yyttr3> I'm in ghci :   :k Zer --> Not in scope:
23:50:37 <yyttr3> Zero*
23:51:09 <ezyang> merijn: are you referring to my comment "if you want * -> * just write data Zero b"?
23:52:00 * hackagebot io-streams 1.2.0.0 - Simple, composable, and easy-to-use stream I/O  http://hackage.haskell.org/package/io-streams-1.2.0.0 (GregoryCollins)
23:52:02 * hackagebot openssl-streams 1.2.0.0 - OpenSSL network support for io-streams.  http://hackage.haskell.org/package/openssl-streams-1.2.0.0 (GregoryCollins)
23:56:14 <merijn> ezyang: Oh, I think I misread your comment
23:57:06 <merijn> ezyang: I thought you said it had kind * -> *, but now I see you told him to write it differently if he wanted kind * -> *
23:57:20 <ezyang> oh ok :)
23:57:40 <ezyang> Hmm
23:58:14 <ezyang> :t (fmap :: (a -> b) -> Just a -> Just b)
23:58:15 <lambdabot>     Expected a type, but ‘Just a’ has kind ‘Maybe *’
23:58:15 <lambdabot>     In an expression type signature: (a -> b) -> Just a -> Just b
23:58:15 <lambdabot>     In the expression: (fmap :: (a -> b) -> Just a -> Just b)
23:58:31 <ezyang> ok, well, at least the error message is reasonable
