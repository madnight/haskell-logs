00:00:01 <lessless> ould not deduce (Num String) arising from a use of `+'
00:00:11 <mauke_> spacing doesn't affect precedence
00:00:46 <lessless> but show 3 is working ok
00:01:35 <mauke_> you can write show x+y all you want; the language still parses it as (show x) + y
00:01:58 <mauke_> and then you get the error because show x is a String and + requires a Num
00:02:28 <merijn> lessless: "show (x+y)"
00:02:46 <merijn> lessless: Your code right now is "(show x) + y"
00:04:35 <Hijiri> I'm having a netwire issue
00:04:38 <Hijiri> http://lpaste.net/111334
00:04:44 <Hijiri> main runs if I don't use charWire
00:04:52 <Hijiri> but if I try to use it typechecking fails
00:05:01 <Hijiri> The error message I get is at the bottom of the paste
00:06:01 <merijn> Hijiri: The type will never work
00:06:10 <merijn> Hijiri: Don't use ImpredicativeTypes, it's broken
00:06:13 <Hijiri> ok
00:06:24 <Hijiri> so should I just not try to make IO return polymorphic types
00:06:32 <merijn> And once you remove that it will just tell you that the type on line 22 is invalid
00:06:45 <Hijiri> it works if I remove charWire
00:06:46 <merijn> Hijiri: It can return a polymorphic type just fine
00:07:11 <merijn> Hijiri: "charWire :: IO (Wire s () IO a Char)" is already polymorphic
00:07:11 <Hijiri> oh sorry about my last response, I misunderstood what you meant
00:07:21 <Hijiri> I thought you meant that if I removed charWire
00:08:00 <Hijiri> what should I call what I'm trying to do?
00:08:18 <merijn> Hijiri: Pretty sure the "forall" in refWire is redundant too
00:08:53 <merijn> Hijiri: Try removing all the forall's and see if it works then
00:08:57 <Hijiri> oh, it is working
00:09:09 <Hijiri> for some reason it gave me errors earlier saying that it expected forall a.
00:10:47 <merijn> Hijiri: And this is why you should avoid blindly adding things you don't understand :) I'm guessing for some reason GHC told you to add forall on one of them, and that basically led to it giving you a bunch of warnings about RankN/Impredicative types where things broke down
00:11:03 <Hijiri> oh, I get the error if I do main = charWire >>= testWireM id clockSession_
00:11:31 <merijn> What's the type of testWireM and clockSession_ ?
00:11:51 <Hijiri> they're on this page http://hackage.haskell.org/package/netwire-5.0.0/docs/Control-Wire-Run.html
00:11:59 <Hijiri> http://hackage.haskell.org/package/netwire-5.0.0/docs/Control-Wire-Session.html
00:12:01 <Hijiri> for session
00:13:06 <merijn> Hijiri: paste the error on lpaste
00:13:22 <Hijiri> http://lpaste.net/111335
00:15:54 <merijn> Hijiri: Yeah, I don't think this is going to work, you'll have to use the same approach like refWire, i.e. "IORef Char -> Wire s () IO a Char"
00:17:16 <Hijiri> so alright
00:17:33 <Hijiri> I didn't mean to type that "so"
00:18:02 <Hijiri> is there some reason it won't work with a value that came from an IO (Wire s () IO a Char)?
00:18:36 <merijn> Hijiri: Yes, the problem is the following
00:19:03 <merijn> Hijiri: The type of testWireM requires a Wire with a polymorphic input, i.e. the wire has to work for *every* possible input
00:19:49 <Hijiri> a wire that comes from an IO can't?
00:19:53 <merijn> However, the Wire returned by "IO (Wire s () IO a Char)" says it returns a wire that accepts "any a" as input. Which does not mean quite the same thing
00:20:43 <merijn> Hijiri: The Wire returned by the IO action "works for any specific 'a' that you pick", but the testWireM wants a wire wants one that works for "ALL a's that it picks"
00:21:09 <Hijiri> so it works when it's declared outside of an IO Action, like Wire s () IO a Char in refWire?
00:21:17 <merijn> I'm not really in the right mindset to explain the difference, but suffice to say there's a subtle, non-obvious difference between the two
00:22:07 <merijn> Hijiri: Basically, values "inside" another type (whether it's IO, Maybe or []) are not allowed to be as polymorphic as those outside
00:22:51 <merijn> Hijiri: ImpredicativeTypes would allow that (which is why GHC mentioned it), but unfortunately it doesn't currently work (I've asked to remove the mention of it from the warning in the past, but it hasn't happened yet)
00:23:02 <Hijiri> ok, I see
00:23:16 <Hijiri> thanks merijn
00:23:23 <merijn> np
00:24:42 <Cale> merijn: I'm surprised that the extension isn't just disabled right now, given how unusable it is
00:25:04 <merijn> Cale: I've asked for that, but SPJ wasn't sure whether there were still users of it out there
00:25:17 <Cale> Well, if there were, they'd be unhappy anyway
00:25:21 <merijn> So I asked to at least disable the warning (and dfeuer made a ticket to delete it from the manual)
00:25:50 <merijn> I guess they forgot about it, I'll see if I already have a ticket for eliminating that warning
01:11:59 <fulmine2378> cio
01:12:03 <fulmine2378> ciAO
01:12:08 <shachaf> !list
01:12:08 <monochrom> shachaf: http://lpaste.net/browse
01:12:12 <fulmine2378> !LIST
01:20:00 <Samvh> hi
01:20:13 <merijn> monochrom: Do you have a script for that or are you just bored? :p
01:20:34 <kqr1> is there a version of unfoldr that uses Either instead of Maybe?
01:21:18 <Samvh> I have a question about algorithmic data types (I'm quite new to Haskell)
01:21:34 <kqr> Samvh, you probably mean algebraic, but go ahead
01:21:41 <Samvh> what happens when I have multiple algorithmic data types have overlap in terms of the values they can obtain?
01:21:44 <Samvh> yep :P
01:21:56 <Samvh> like I'm practicing with Rosalind exercises
01:22:10 <mauke_> impossible
01:22:13 <Samvh> and I thought it would be useful to make a datatype for DNA nucleotides
01:22:20 <Samvh> and the same for RNA nucleotides
01:22:27 <Samvh> so I can't use A in both?
01:22:31 <kqr> Samvh, what happens if you try to do it in GHCi?
01:22:42 <Samvh> well it doesn't error when I define the new datatype
01:22:54 <Samvh> but then if I :type A it will give me the last type I defined
01:23:12 <Samvh> I thought I could clarify by saying :type A::RNANuc or :type A::DNANucj
01:23:18 <Samvh> but that causes problems
01:23:38 <Samvh> so, ok, that doesn't work, and my second question is what would be the elegant solution?
01:23:58 <Samvh> making it DNAA, DNAC, etc? because that doesn't seem very elegant :)
01:24:19 <Samvh> (btw I would have expected ghci to give me an error when I defined the second datatype)
01:24:57 <kqr> I think ghci is designed to just accept the last definition of everything, because people experiment in it and redefine things all the time
01:25:16 <kqr> there's an extension to newer versions of GHC called overloadedrecordnames or something like that, which allows you to have the same name for multiple types
01:25:24 <Samvh> ah ok, so in GHC this might cause an error indeed
01:25:27 <kqr> but other than that, dnaA and rnaA or something might work
01:26:28 <Samvh> hm ok, that's a pity because it's a lot more typing than working with Chars or "A" "C" etc
01:26:38 <lessless> for what there are parentheses at the end of the function declaration  main :: IO () ?
01:26:53 <Samvh> but thanks :)
01:27:18 <kqr> lessless, () is a type
01:27:21 <hexagoxel> lessless: the type called "Unit"
01:27:33 <kqr> lessless, I agree it's a weird name for a type, but it is a type name just like Int or String
01:27:40 <kqr> lessless, it's pronounced "unit"
01:28:00 <kqr> lessless, the only value of that type is also named (), and also pronounced "unit", which is confusing, but that's the way it is
01:28:21 <lessless> it's like empty tuple?
01:28:48 <kqr> you could view it like that, yeah
01:30:12 <kqr> Samvh, https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields
01:30:17 <kqr> Samvh, there's something to follow
01:30:23 <kqr> Samvh, hopefully you'll get your wish in GHC 7.10!
01:30:33 <Samvh> awesome, thanks!
01:30:37 <kqr> Samvh, if you don't want to run a development version of ghc...
01:31:14 <Samvh> maybe at some point
01:31:34 <Samvh> but I have to get more comfortable with the language first
01:45:16 <phaazon> hey, I have a weird error in my .cabal, and I don’t get why:
01:45:18 <phaazon> Warning: monad-journal.cabal: Unknown fields: extra-source-files (line 37)
01:45:27 <jle`> kqr: what would be the type of that unfoldr?
01:45:28 <phaazon> isn’t extra-source-files a correct keyword?
01:47:49 <kqr> jle`, hm
01:47:51 <kqr> jle`, good point
01:48:02 <kqr> jle`, i'm not sure
01:48:07 <joelteon> phaazon: cabal version?
01:48:25 <jle`> kqr: oh, i was just asking to know what you wanted it to do, heh
01:48:27 <phaazon> cabal-install version 1.20.0.3
01:48:28 <phaazon> using version 1.20.0.0 of the Cabal library
01:48:35 <kqr> jle`, the idea is that when the function returns Nothing, I want to be able to return whatever the last b value was along with the resulting list
01:48:48 <jle`> :t unfoldr
01:48:49 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
01:49:02 <kqr> jle`, you can view it as "an unfinished consumption" of b which might be re-tried at a later time or whatever
01:49:10 <jle`> (b -> Either c (a, b)) -> b -> ([a], c) ?
01:49:31 <kqr> jle`, that looks right
01:49:39 <kqr> jle`, but it'd remove a lot of nice laziness properties, no?
01:49:53 <kqr> I guess that's unavoidable with that particular idea of what unfoldr does
01:50:13 <jle`> you could still lazily get things from the [a], but you can't ask for the c
01:50:18 <jle`> without evaluating the whole list
01:50:32 <jle`> cause tuples are lazy and all
01:50:37 <kqr> ah yeah, so like (take 10 . fst) would work, yeah
01:50:48 <jle`> from what i understand
01:50:53 <jle`> shouldn't be too hard to verify :)
01:52:44 <lessless> folks, help me please with simple exercise: the task is to print the sum of two numbers and I did everything correct but system keeps throwing errors https://gist.github.com/lessless/1007c29fd6751d573718
01:53:29 <jle`> @let unfoldrE f x0 = case f x0 of Right (y, x1) -> first (y:) (unfoldrE f x1); Left z -> ([], z)
01:53:29 <kqr> lessless, the return value of main should be IO (), which explains your first error
01:53:29 <lessless> third gist is the inital text
01:53:31 <lambdabot>  Defined.
01:53:43 <kqr> lessless, and the second error
01:53:53 <kqr> lessless, you also don't want main to take arguments
01:54:05 <phaazon> dammit, I don’t get why, for instance, lens can use the extra-source-files keyword while I can’t
01:54:08 <arianvp> :t mapWithInddex
01:54:10 <lambdabot>     Not in scope: ‘mapWithInddex’
01:54:10 <lambdabot>     Perhaps you meant ‘Seq.mapWithIndex’ (imported from Data.Sequence)
01:54:31 <arianvp> I need a Seq.mapMaybeWithIndex. but I have no idea how to write it ...
01:54:40 <lessless> kqr, I get it - they must be read from the stdin! :)
01:54:50 <kqr> lessless, that's the easiest way to do it, yes
01:54:55 <arianvp> anybody got an idea?
01:55:05 <kqr> lessless, you can also import System.Environment
01:55:21 <kqr> lessless, the getArgs variable in System.Environment contains IO [String]
01:55:33 <kqr> lessless, in other words, an IO action that will return a list of strings – the command line arguments
01:55:34 <lessless> kqr, I'm just on the second chapter of the Learning Haskell for Great Good :D
01:55:39 <kqr> lessless, cool!
01:56:18 <jle`> > unfoldrE (\x -> if x == 1 then Left "done" else Right (x-1, x-1)) 10
01:56:20 <lambdabot>  ([9,8,7,6,5,4,3,2,1],"done")
01:56:43 <jle`> > unfoldrE (\x -> Right (x,x+1)) 1
01:56:45 <lambdabot>  ([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
01:56:49 <zenguine> hey all.. question
01:57:00 <zenguine> so I've come up with and seen examples for about a million cool uses of free monads and free monad transformers
01:57:01 <jle`> > take 10 . fst $ unfoldrE (\x -> Right (x,x+1)) 1
01:57:03 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
01:57:11 <jle`> > snd $ unfoldrE (\x -> Right (x,x+1)) 1
01:57:15 <lambdabot>  mueval-core: Time limit exceeded
01:57:16 <jle`> ^^ kqr
01:57:20 <kqr> jle`, saw
01:57:22 <kqr> jle`, very nice
01:57:24 <phaazon> Warning: monad-journal.cabal: Unknown fields: data-files (line 38)
01:57:27 <phaazon> aw
01:57:28 <phaazon> wtf
01:57:29 <zenguine> but I just spent a while figuring out the definitions / instances for cofree comonads
01:57:39 <zenguine> but can't really think of any applications
01:57:46 <zenguine> anyone know of any cool examples?
01:58:02 <zenguine> my comonadic intuition ingeneral is a bit weak so that could be my problem
01:58:11 <jle`> cofee comonads haven't been huge buzzwords like free monads have been over the past few months
01:59:20 <kqr> jle`, some background information in case you are curious: I wrote some simple parsing code in another language a few weeks ago, and it really felt like there was some pattern to it that I was missing. i've been thinking about it for a long time and just this morning I woke up thinking "UNFOLD!!!" so it's a relief for me to finally know that I wasn't dumb for thinking there was a pattern to it
01:59:42 <jle`> :P
02:00:14 <jle`> unfold is neat because it's the anamorphism for lists
02:00:17 <jle`> ...or something like hat
02:01:14 <zenguine> jle`: yeah, but which is why I'm asking here.  lack of buzz means that i'm less likely to have heard about cool applications everywhere.  but surely there are some?
02:01:24 <jle`> :t mapAccumR
02:01:25 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
02:01:39 <jle`> kqr: ^^ that sounds like it might be close to what you are looking for too
02:02:23 <jle`> zenguine: applications of comonads, or of cofree comonads?
02:02:40 <zenguine> cofree comonads in particular. I know a couple examples of comonads in general
02:02:59 <zenguine> but hey, I'm all ears if you wanna tell me cool stuff about comonads too :).  I'm in a learning mood
02:03:16 <kqr> jle`, except I don't need the x in this case
02:03:23 <jle`> ah yeah,
02:03:27 <jle`> you're right
02:07:42 <michi7x7> lessless: main :: IO () just like C requires int main(int, char**)
02:08:02 <Arahael_Twin> So...
02:08:06 <michi7x7> you can get command-line arguments with getArgs
02:08:19 <Arahael_Twin> As a thought experiment (trying to pick a language)
02:08:44 <Arahael_Twin> If I were to pick haskell, and wanted to support a platform that didn't have haskell ported to it, but does have a C++ compiler.
02:09:10 <michi7x7> Arahael_Twin: GHC can use the gcc and clang backends AFAIK
02:09:23 <bennofs> michi7x7: no, not gcc
02:09:35 * hackagebot monad-journal 0.4.0.1 - Pure logger typeclass and monad transformer  http://hackage.haskell.org/package/monad-journal-0.4.0.1 (DimitriSabadie)
02:09:47 <Arahael_Twin> And for some reason javascript is too slow (as is the case on iOS)
02:10:17 <Arahael_Twin> michi7x7: Apparently there are quite a few caveats. No template-haskell, and apparently it's slow code (intended only as a means of bootstrapping GHC itself)
02:10:27 <xeno> so, when I use conduit, I can run  L.sourceList [1,2,3,4,5] $$ L.fold (+) 0 from ghci, and I get 15
02:10:42 <xeno> but the type is m a, where m is a Monad
02:10:56 <xeno> if I try to do x =  L.sourceList [1,2,3,4,5] $$ L.fold (+) 0 , then I get a type error
02:11:12 <xeno> what really happens?
02:11:30 <bennofs> Arahael_Twin: I think there is ghc-ios
02:11:52 <Arahael_Twin> bennofs: That was an example.
02:12:22 <bennofs> Arahael_Twin: iirc, porting GHC to an not-yet-supported platform is not as easy#
02:12:26 <zenguine> xeno: the monomorphism restriction  maybe?
02:12:28 <Arahael_Twin> bennofs: However, if you must have a current example of a real platform that doesn't support GHC, then perhaps I might suggest windows phone.
02:12:31 <zenguine> xeno: whats the type error?
02:12:32 <Arahael_Twin> bennofs: Yes, that's my concern.
02:13:03 <xeno> No instance for (Monad m0) arising from a use of `$$'    The type variable `m0' is ambiguous
02:13:12 <Arahael_Twin> bennofs: It's why I'm considering using C++ instead of haskell, but I'm reluctant to do so...  C++'s syntax feels archaic when I want sum types and type inferrence.
02:13:28 <bennofs> Arahael_Twin: Boost.Variant! :)
02:13:38 <zenguine> xeno: add a type signature and it should work
02:13:49 <Arahael_Twin> bennofs: I want _compiletime_ checks.
02:13:55 <jle`> :set -XNoMonomorphismRestriction
02:14:00 <zenguine> xeno: and look up the monomorphism restriction to understand why
02:14:06 <bennofs> Arahael_Twin: Boost.Variant uses the visitor pattern to make sure you handle all cases
02:14:15 <jle`> xeno: ghci can be considered a bunch of lines ina  do block
02:14:21 <merijn> michi7x7: Few corrections
02:14:29 <Arahael_Twin> bennofs: Interesting idea.
02:14:39 <bennofs> Arahael_Twin: creating a new class for each "case" statement is quite verbose though :|
02:14:40 <merijn> michi7x7: main is not required to be "IO ()", it can be any type that unifies with "IO a"
02:14:40 <jle`> so when you have something of type IO a, it just "runs" the IO a and prints the a, if the a is Show
02:14:47 <jle`> for example: getLine
02:14:52 <merijn> michi7x7: Two, GHC doesn't use gcc or clang as back end compilation
02:15:02 <jle`> so if you have something of type Monad m => m a, it'll try to match it with IO a
02:15:13 <jle`> try: (return 5 :: IO Int)
02:15:21 <Arahael_Twin> bennofs: Yes... It's one thing I will miss...  C++'s pattern matching is rather tedious.
02:15:26 <jle`> i'll execute the IO action (return 5) and display the result, 5
02:15:26 <xeno> jle`: jle`: but when I try to do the above as 'f :: IO <something>' then 'f = do return ...' it still doesn't work
02:15:28 <merijn> michi7x7: The old -fvia-C backend is not compiled into ghc by default, completely bitrotted and only kept for future porting efforts
02:15:28 <michi7x7> merijn: yeah, just read that up... it supports compiling to C (which is deprecated) and llvm as code generator
02:15:37 <jle`> xeno: define 'still doesn't work' :)
02:15:52 <Arahael_Twin> michi7x7: Note: It doesn't work with template haskell *at all*.
02:15:58 <merijn> michi7x7: non-custom builds of GHC don't even support deprecated compilation via C
02:16:39 <merijn> The default is to use GHC's native code generation with LLVM as optional alternative
02:16:50 <michi7x7> merijn, Arahael_Twin: Is this true for the llvm-backend?
02:17:09 <bennofs> I think unregistered (= via C) builds are pretty hard to get working
02:17:12 <xeno> jle`: two seconds
02:17:16 <bennofs> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/Backends/LLVM/GHC_LLVMPorting
02:17:17 <Arahael_Twin> bennofs: Ok, just had a look at boost.variant: It technically solves the problem, but I still want sensible syntax.
02:17:30 <zenguine> xeno: if you are in ghci, you probably need to use either a let or "<-" syntax to bind variables
02:17:40 <bennofs> Arahael_Twin: maybe you should take a look at rust?
02:17:49 <zenguine> xeno: depending on whether what you are trying to bind is of type IO a or a pure value
02:17:56 <merijn> Rust still has pretty terrible performance, though
02:17:59 <Arahael_Twin> bennofs: That only compiles to Javascript, doesn't it?
02:18:02 <xeno> jle`: Couldn't match type `[a0] -> ConduitM i0 a0 m0 ()' with `Source IO Integer'
02:18:04 <merijn> Arahael_Twin: heh
02:18:13 <merijn> Arahael_Twin: No, Rust is meant as C++ replacement
02:18:23 <xeno> jle`: oh wait a sec
02:18:25 <bjz> merijn: where did you see that?
02:18:35 <merijn> bjz: Where did I see what?
02:18:47 <Arahael_Twin> merijn: Eh? Does it output C++?
02:18:50 <bjz> merijn: "Rust still has pretty terrible performance"
02:19:12 <bjz> Arahael_Twin: LLVM IR
02:19:12 <michi7x7> bennofs: do you need to compile GHC for arm? can't you just do cross compilation?
02:19:17 <merijn> Arahael_Twin: No, it compiles to native code. But it's meant to replace C++ as in, no overhead for features you don't use, suitable for bare metal, etc.
02:19:36 * hackagebot monad-journal 0.4.0.2 - Pure logger typeclass and monad transformer  http://hackage.haskell.org/package/monad-journal-0.4.0.2 (DimitriSabadie)
02:19:38 * hackagebot hadoop-formats 0.1.0.0 - Read/write file formats commonly used by Hadoop.  http://hackage.haskell.org/package/hadoop-formats-0.1.0.0 (JacobStanley)
02:19:41 <Arahael_Twin> merijn: So not good for platforms that it isn't ported to, then.
02:19:46 <xeno> jle`: Expected type: IO Integer Actual type: IO (m0 Integer)
02:19:46 <merijn> bjz: I spent some time this week with colleagues looking whether Rust would be a viable alternative for our runtime system, but the benchmarks we found were pretty abysmal
02:20:04 <kqr> Arahael_Twin, do you know if Ada works with windows phone? if so, that might be a good alternative to C++
02:20:11 <Hafydd> For a second I thought monad-journal was a place where people published burrito tutorials.
02:20:50 <bjz> merijn: were they the bigint ones? because our bigints are pretty terrible. otherwise it is basically on per with C and C++
02:22:02 <merijn> bjz: No, just numerical code with arrays
02:22:28 <bjz> merijn: were you using iterators?
02:22:44 <merijn> bjz: I have to check, my colleague wrote the code
02:22:49 <bjz> merijn: if you were just indexing then you might have been running up against bounds checking
02:23:04 <bjz> merijn: but yeah, #rust would help you out greatly
02:23:19 <bjz> merijn: I don't want to spam here ;)
02:23:30 <Arahael_Twin> kqr: I never considered Ada, just checking it...
02:23:32 <merijn> bjz: Well, we weren't all that likely to rewrite anyway, considering we have a whole bunch of existing C++ code :)
02:24:30 <bjz> merijn: short answer is: iterators don't do bounds checking, but are fast and statically verified to be safe. indexing directly is slower.
02:24:37 * hackagebot hadoop-formats 0.2.0.0 - Read/write file formats commonly used by Hadoop.  http://hackage.haskell.org/package/hadoop-formats-0.2.0.0 (JacobStanley)
02:25:16 <merijn> bjz: Right, but out workload has a whole bunch of random access operation where we can't use iterators and that slowdown is unacceptable, performance wise
02:26:55 <Arahael_Twin> kqr: I probably won't like Ada, but it does seem to have a mature choice of compilers, and translators.
02:27:16 <kqr> Arahael_Twin, why wouldn't you like it?
02:27:52 <Arahael_Twin> kqr: It looks very imperative, but that's just a first-impression.
02:28:08 <kqr> ah yeah sure
02:28:20 <kqr> it's meant for programming close to the metal much like C++
02:28:22 <bjz> merijn: hm. it is a tricky problem. But this is something that needs to be figured out. As I say, it would be great to have feedback from you guys in the numerical computation world. Maybe we can knock some heads together to come up with solutions, but in the interim you can always access elements unsafely if you really need to.
02:28:27 <kqr> but it has a much better type system
02:28:36 <kqr> and it does a few other things right (concurrency among them)
02:28:54 <Arahael_Twin> kqr: I would probably prefer ML.
02:29:06 <kqr> if that works, go for it!
02:29:07 <DTSCode> how do i upgrade ghc on fedora?
02:29:16 <merijn> bjz: I'll check in #rust next time we play with some benchmarks
02:29:38 <trap_exit> how does "beginning haskell" and "real world haskell" compare?
02:30:37 <kqr> DTSCode, sudo yum upgrade ghc or something like that?
02:31:00 <Arahael_Twin> kqr: My perfect langauge, would be haskell, with an option to compile to C++ for "difficult" platforms.
02:31:14 <DTSCode> kqr: it makes it 7.4, and i need 7.6
02:31:49 <bjz> merijn: sometimes if you can encapsulate your unsafe accesses in a safe interface that can help. part of working with rust is accepting that sometimes unsafe {} is necessary for the fundamental foundations, but trying to limit it as much as possible behind interfaces that you know are safe. Basically most of the fundamental library types are implemented unsafely.
02:31:50 <Arahael_Twin> kqr: Or C++ with HM type inference, pattern matching, and sum types.
02:31:57 <bjz> Arahael_Twin: Idris is cool
02:32:11 <bjz> Arahael_Twin: but pretty immature
02:32:12 <kqr> DTSCode, wow 7.4 is ancient
02:32:18 <kqr> DTSCode, check http://www.haskell.org/ghc/download_ghc_7_8_3
02:32:33 <Arahael_Twin> bjz: How do you measure immaturity?
02:32:54 <kqr> DTSCode, or http://www.haskell.org/ghc/download_ghc_7_6_3
02:32:58 <kqr> DTSCode, if you specifically want 7.6
02:33:00 <bjz> Arahael_Twin: but yeah, sum types, pattern matching, local HM inference are all in Rust. you just need to see past the ugly syntax.
02:33:24 <Arahael_Twin> bjz: Interesting.
02:33:31 <DTSCode> ty kqr
02:33:34 <bjz> Arahael_Twin: not the greatest compiler errors, and minimal std library and ecosystem
02:33:41 <Arahael_Twin> bjz: No Rust compiler for windows iphone, though.
02:33:43 <kqr> DTSCode, to be fair, it was the first hit on google for "ghc download"
02:33:43 <bjz> Arahael_Twin: ie. for Idris
02:33:55 <yesthisisuser> I don't understand how I should think when specifying constraints for external modules in my project's cabal file.
02:33:58 <bjz> Arahael_Twin: no. :(
02:34:10 <sivteck> DTSCode, there is an unofficial repo for ghc 7.8.3 <https://github.com/bitemyapp/learnhaskell#fedora-20>
02:34:23 <DTSCode> kqr: my bad. my googlefu is a bit rusty this late at night
02:34:32 <Arahael_Twin> bjz: Idris does look good. Pity it isn't a (strict?) subset of Haskell.
02:34:40 <Arahael_Twin> bjz: (Which would allow me to use haskell as a fallback)
02:34:45 <kqr> Arahael_Twin, funny because idris is uses strict evaluation :>
02:34:45 <bjz> Arahael_Twin: why a pity?
02:34:58 <bjz> Arahael_Twin: it cleans up a lot
02:35:25 <Arahael_Twin> bjz: Because then I'd be able to overlook it's immaturity.
02:35:45 <Arahael_Twin> kqr: I can live with strict evaluation.
02:36:03 <kqr> Arahael_Twin, I made a pun on your strict subset remark
02:36:18 <Arahael_Twin> kqr: Ah, sorry I missed it - I'm bad with puns. :(
02:36:25 <bjz> Arahael_Twin: you can put a `|` in front of the functions to make them lazy :)
02:36:57 <bjz> Arahael_Twin: it just needs more man years put into it, which they unfortunately don't have the resources. but yeah - it's fun to play with at least.
02:37:19 <Arahael_Twin> Idris is tempting.
02:37:40 <Arahael_Twin> The C (and Java?) backends are very attractive.
02:38:06 <bjz> Arahael_Twin: it still doesn't have a simple mapping to machine instructions and control over memory layout etc
02:38:25 <bjz> unfortunately
02:38:33 <Arahael_Twin> bjz: Then again, neither does C. (In the first case).
02:38:42 <Arahael_Twin> And control over memory layout is a pita at best, these days.
02:38:54 <bjz> depends on the application
02:39:29 <Arahael_Twin> bjz: Point - which is games, in my case.
02:39:38 <Arahael_Twin> Only I don't want to rewrite it for each platform.
02:39:43 <bjz> Arahael_Twin: mine too
02:40:15 <bjz> Arahael_Twin: I still muck around in Elm and Haskell though for simpler experiements
02:41:19 <Arahael_Twin> bjz: Yeah.  Maybe I'll do similar.
02:41:36 <bjz> Arahael_Twin: they are good for helping you to see problems in different lights. But Rust is my main lang.
02:42:39 <Trollinator> there is also ATS.
02:42:43 <Arahael_Twin> bjz: I'm actually tempted to use Haskell as my main langauge.
02:42:50 <bjz> Trollinator: yep
02:42:58 <Arahael_Twin> (Although I've yet to use it in a real project as yet)
02:42:59 <Trollinator> Last time I checked it wasn't very mature, but it changed a lot since then.
02:43:30 <bjz> Trollinator: apparently there is an bit of an impedance mismatch between the functional and systems lang sides though :(
02:43:45 <bjz> Trollinator: I could be misled though
02:44:49 <bjz> Arahael_Twin: these guys use Haskell: http://blog.chucklefish.org/?p=154
02:45:53 <Arahael_Twin> bjz: checking that out...
02:46:17 <Arahael_Twin> bjz: I've also realised that I've neglected to consider the non-ghc haskell compilers.
02:46:33 <bjz> Arahael_Twin: it just depends on what kind of games your are trying to make I guess
02:46:46 <Arahael_Twin> bjz: Mostly SDL.
02:46:46 <bjz> would be cool to see more stuff in haskell...
02:46:56 <bjz> 2D?
02:47:49 <Arahael_Twin> bjz: Yep - I don't have the budget for 3D.
02:48:02 <Trollinator> bjz: I've actually pretty much given up on it. When you subscript an array, it's not checked at run-time. It's supposedly verified at compile-time, but that doesn't really work because the compiler doesn't consider integer overflow.
02:48:44 <bjz> Trollinator: so it's unsafe? :S
02:48:51 <Trollinator> yup.
02:49:19 <bjz> yeeks
02:49:23 <bjz> that's a shame
02:49:39 * hackagebot tellbot 0.4.0.1 - IRC tellbot  http://hackage.haskell.org/package/tellbot-0.4.0.1 (DimitriSabadie)
02:50:23 <bjz> Trollinator: what kind of stuff did you do with it?
02:50:36 <bjz> Trollinator: what other impressions did you have?
02:50:53 <Trollinator> Nothing serious, just messing around with it to learn it.
02:51:26 <bjz> Trollinator: woops - d/ced
02:51:43 <Trollinator> to be fair, I think that all integer and pointer types are defined in the Prelude, so you can in theory replace all of them with safe variants.
02:52:05 <bjz> ah ok
02:52:38 <MP2E> that's what I'm thinking too, there's gotta be a way to use Integer as the subscript, so it can't overflow
02:53:06 <MP2E> or perhaps use the light weight dependant type features to get bounded arrays that are checked at compile-time similar to sized vectors
02:53:22 <MP2E> the singletons library could be useful there
02:53:23 <Arahael_Twin> bjz: Yeah... I'm looking for a 1-dev game. :)
02:53:38 <Arahael_Twin> bjz: Chucklefish's a large company by comparison, interesting though.
02:54:52 <Trollinator> I also think that it desperately needs something like GHC's DataKinds extension.
02:55:51 <Trollinator> I found that as soon as you want to do some meaningful verification, you need to duplicate your data type declarations at the kind level.
02:59:02 <Trollinator> On the upside, I think linear types are a boon for resource management.
03:02:45 <Arahael_Twin> One thing that's frequently frustrated me...
03:02:59 <Arahael_Twin> Why do haskell users always say that the haskell platform is really outdated.
03:03:15 <Arahael_Twin> And use the latest version. (They even manage to say it in such a way like, it's obvious...)
03:03:24 <Arahael_Twin> Yet the official site says STOP! Use the haskell platform!
03:16:09 <VBet> http://bet-tips.cogia.net/?ref=1810
03:17:19 --- mode: ChanServ set +o dibblego
03:17:27 --- mode: dibblego set +b Vbet!*@*
03:17:36 --- mode: dibblego set -o dibblego
03:42:29 <xeno> how can I do :t on operators like e.g. $$ ?
03:42:50 <bennofs> xeno: :t ($$)
03:49:10 <migueldeluisespi> Hello?
03:49:18 <migueldeluisespi> Just a noob here
03:49:56 <adimit_away> Is there some package to ease usage of SI units of astronomical scale? I.e. one that has a nice Show instance to print them in scientific notation, and stores these numbers precisely.
03:50:57 <Arahael_Twin> Hmm.  I can't install ghc.  It dies on pretty much teh first line of output from ./configure --prefix=/my/prefix, with this line:
03:51:00 <Arahael_Twin> checking for path to top of build tree... utils/ghc-pwd/dist-install/build/tmp/ghc-pwd-bindist: line 3: /home/arahael/dev/tools/ghc-7.8.3/utils/ghc-pwd/dist-install/build/tmp/ghc-pwd: No such file or directory
03:51:18 <jTT> hi, I am thinking of trying my luck with haskell to achieve a potentially tricky goal. I have a website where people can search my data for keywords. these I log and parse to create a data structure in haskell like so: data keywords = Maybe [searchTerms]. Now, from this I am hoping to generate a (non-hierachical) Tree that achieves the following: each searchTerm is represented as a tuple (n,searchTerm) where n := number of occurrances. 
03:51:18 <jTT> this (add KeywordTree = EmptyTree | Node a [KeywordTree]). I would like, in the end, to have a connectance tree where I know how often which term was looked up AND what other terms were usually connected with this search term. Is there a standard way to implement this? What worries me is the joining of coocurring search terms and subsequent joining of nodes. I am at the very beginning with this and just looking for hints/sources for fur
03:52:10 <Arahael> jTT: A tree would represent a recursive decent parser very nicely for your search terms.
03:52:11 <jTT> *add = data, no idea why i wrote add, sorry
03:54:09 <jTT> Arahael: yeah, it’s not going to be a binary tree though and that makes it more difficult for me
03:56:05 <Arahael> Running ldd on ghc-pwd reports: "Not a dynamic executable", so that rules missing dependencies out.
03:57:51 <Arahael> Man, it's frustrating debugging without error messages.
04:07:33 <Arahael> Hmm, well I'm going to assume that 32-bit ghc simply doesn't work in debian 64. I probably should've guessed. (Most 32-bit software doesn't, without work)
04:13:18 <shikhin> Hrm, can someone tell me what's wrong with toInteger (22%7)?
04:14:01 <ClaudiusMaximus> :t toInteger
04:14:02 <Cale> shikhin: toInteger :: Integral a => a -> Integer
04:14:03 <lambdabot> Integral a => a -> Integer
04:14:21 <shikhin> :t (22%7)
04:14:21 <Cale> shikhin: Which means that the type a must be an integer-like type to begin with -- rationals are not
04:14:22 <lambdabot> Integral a => Ratio a
04:14:29 <shikhin> ^ am I reading that wrong?
04:14:31 <Cale> You're probably looking for round, ceiling, or floor
04:14:51 <Cale> Yeah, 22 is of an integral type
04:14:56 <shikhin> Oh. D'oh.
04:14:57 <yesthisisuser> when I have offline docs available.. do I just open them in the browser or is there a service that i should run?
04:15:12 <oakwhiz> > round ( 22 % 7 )
04:15:14 <lambdabot>  3
04:15:46 <shikhin> So many numeric typeclasses, hmm.
04:15:48 <Cale> yesthisisuser: I just open them in my browser
04:16:16 <Cale> shikhin: Yeah, it's a bit hard to navigate initially, but it does make a decent amount of sense eventually :)
04:16:33 <shikhin> Cale: I just don't want to skim through this section and be confused later on. :-)
04:17:59 <Cale> shikhin: Do you understand why  22 % 7 :: Integral a => Ratio a  doesn't mean that you necessarily have an instance of Integral (Ratio a)?
04:18:29 <Cale> It's the type a which is integral, that's the type you're taking ratios of to form the rational numbers
04:18:30 <shikhin> Cale: I think so; it means that a is an instance of Integral, right?
04:18:33 <Cale> yeah
04:18:37 <shikhin> Yep, thanks.
04:19:19 <shikhin> How can I check if Ratio is an instance of Integral (without referring to the docs :-))?
04:19:57 <yesthisisuser> can i cabal install only the docs for a package without reinstalling it
04:20:25 <ClaudiusMaximus> shikhin: :i Ratio   in ghci
04:21:13 <shikhin> Ah.
04:24:46 * hackagebot hadoop-formats 0.2.1.0 - Read/write file formats commonly used by Hadoop.  http://hackage.haskell.org/package/hadoop-formats-0.2.1.0 (JacobStanley)
04:25:59 <augur> hey peeps, is there a nice way to eliminate mostly-homomorphic definitions?
04:26:19 <augur> eg a lot of   foo (Bar x) = Bar (foo x)   kind of just except for some cases?
04:28:27 <augur> ping me if you know of a way. im heading to sleep but ill read when i get up
05:02:09 <migueldeluisespi> Hello, I'm just starting out with haskell
05:03:20 <migueldeluisespi> I have a little script in python that prompts you for data (strings), then opens a latex file, does some search and replace and then gives another latex files as its output
05:03:56 <migueldeluisespi> any library I should use?
05:04:16 <pie870> salve
05:04:20 <pie870> !list
05:04:20 <monochrom> pie870: http://okmij.org/ftp
05:04:51 <migueldeluisespi> hi pie870
05:05:51 <Peaker> migueldeluisespi: you want to rewrite it in Haskell?
05:06:15 <migueldeluisespi> yes, exactly Peaker:
05:06:47 <Peaker> migueldeluisespi: what kind of search and replace? You could do it with the "text" or "bytestring" packages
05:06:54 <pie870> !list
05:06:55 <monochrom> pie870: http://hackage.haskell.org/packages/archive/pkg-list.html
05:07:50 <michi7x7> migueldeluisespi: there are also quite some regex packages you can use
05:07:57 <migueldeluisespi> well, Peaker I have some fields defined in my latex file such as *name_of_the_guy
05:08:38 <migueldeluisespi> so I just searched for *name_of_the_guy and then replaced it with the value that the user prompts
05:08:47 <migueldeluisespi> that simple, really
05:09:43 <migueldeluisespi> thanks michi7x7
05:09:59 <michi7x7> migueldeluisespi: this is a really easy script I use to batch rename files in a directory: https://gist.github.com/michi7x7/1fc69478ef8d22a63709
05:09:59 <Peaker> migueldeluisespi: http://hackage.haskell.org/package/text-0.5/docs/Data-Text.html#v:replace
05:10:04 <michi7x7> maybe it helps
05:11:02 <migueldeluisespi> Thank you both, I'm sure that will help
05:11:53 <Peaker> migueldeluisespi: http://hackage.haskell.org/package/text-0.11.2.3/docs/Data-Text-IO.html#v:readFile and then do the replaces and then writeFile back
05:12:34 <migueldeluisespi> thank you that will do the trick
05:14:42 <migueldeluisespi> Btw I'm blown by the power of Haskell
05:14:45 <migueldeluisespi> :)
05:18:02 <srhb> migueldeluisespi: Your journey to the dark side has begun. :-)
05:19:41 <migueldeluisespi> srhb :)
05:19:54 <migueldeluisespi> the power of the haskell side :)
05:19:58 <phaazon> @hoogle Maybe k (Maybe a) -> Maybe k a
05:19:59 <lambdabot> Did you mean: Maybe k -> Maybe k
05:19:59 <lambdabot> No results found
05:20:11 <phaazon> @hoogle Map k (Maybe a) -> Map k a
05:20:11 <lambdabot> No results found
05:21:42 <michi7x7> @hoogle Map k a -> Map k b
05:21:44 <lambdabot> Data.Map.Lazy mapWithKey :: (k -> a -> b) -> Map k a -> Map k b
05:21:44 <lambdabot> Data.Map.Strict mapWithKey :: (k -> a -> b) -> Map k a -> Map k b
05:21:44 <lambdabot> Data.Map.Lazy mapMaybeWithKey :: (k -> a -> Maybe b) -> Map k a -> Map k b
05:22:16 <phaazon> :t mapMaybe
05:22:17 <lambdabot> (a -> Maybe b) -> [a] -> [b]
05:22:22 <Peaker> michi7x7: fmap
05:22:36 <phaazon> is there some kind of mapMaybe for Map?
05:22:42 <michi7x7> Peaker: i think phaazon needs mapMaybeWithKey
05:22:52 <Peaker> Data.Map.mapMaybe :: (a -> Maybe b) -> Map k a -> Map k b
05:23:04 <Peaker> Data.Map.mapMaybeWithKey :: (k -> a -> Maybe b) -> Map k a -> Map k b
05:23:10 <phaazon> great
05:23:18 <phaazon> that’s what I need yes
05:23:19 <phaazon> thank ou
05:23:20 <phaazon> you*
05:23:51 <Peaker> @hoogle (k -> a -> Maybe b) -> Map k a -> Map k b
05:23:53 <lambdabot> Data.Map.Lazy mapMaybeWithKey :: (k -> a -> Maybe b) -> Map k a -> Map k b
05:23:53 <lambdabot> Data.Map.Strict mapMaybeWithKey :: (k -> a -> Maybe b) -> Map k a -> Map k b
05:23:53 <lambdabot> Data.Map.Lazy updateMaxWithKey :: (k -> a -> Maybe a) -> Map k a -> Map k a
05:24:33 <phaazon> @hoogle (a -> Maybe b) -> Map k a -> Map k b
05:24:36 <lambdabot> Data.Map.Lazy mapMaybe :: (a -> Maybe b) -> Map k a -> Map k b
05:24:36 <lambdabot> Data.Map.Strict mapMaybe :: (a -> Maybe b) -> Map k a -> Map k b
05:24:36 <lambdabot> Data.Map.Lazy updateMax :: (a -> Maybe a) -> Map k a -> Map k a
05:24:44 <phaazon> yeah, great.
05:26:24 <michi7x7> > Data.Map.mapMaybe id $ Data.Map.fromList [(1, Just 2), (2, Just 2), (3, Nothing)]
05:26:26 <lambdabot>  Not in scope: ‘Data.Map.mapMaybe’
05:26:26 <lambdabot>  Perhaps you meant ‘Data.Maybe.mapMaybe’ (imported from Data.Maybe)Not in sco...
05:27:02 <phaazon> @let import Data.Map
05:27:04 <lambdabot>  Defined.
05:27:08 <phaazon> > Data.Map.mapMaybe id $ Data.Map.fromList [(1, Just 2), (2,  Just 2), (3, Nothing)]
05:27:09 <lambdabot>  fromList [(1,2),(2,2)]
05:27:30 * michi7x7 does not speak lambdabot yet ^^
05:27:38 <phaazon> you will very soon :)
05:28:06 <phaazon> that mapMaybe function is pretty amazing
05:28:27 <phaazon> I guess it’s a map and a filter
05:29:04 <phaazon> mapMaybe f = mapMaybeWithKey (\_ x -> f x)
05:29:05 <phaazon> ahah
05:29:07 <phaazon> of course :)
05:29:20 <michi7x7> in the end, everything is a fold, I guess
05:29:55 <phaazon> I’m reading the implementation of mapMaybeWithKey
05:30:00 <phaazon> that sounds very cryptic :D
05:31:11 <phaazon> hm
05:31:15 <phaazon> that’s just a binary tree actually
05:31:27 <phaazon> Bin size k v left right | Tip
05:45:57 <michi7x7> phaazon: well, it's not a problem to do it for lists: https://gist.github.com/michi7x7/e80cb0c184254c6cb77a
05:46:18 <michi7x7> the official implementation uses recursion, don't know why though...
05:46:38 <lostman> has anyone seen this before "The package 'zlib' requires Cabal library version"?
05:47:29 <lostman> err, the full message is "The package 'zlib' requires Cabal library version >=1.19.2 && >=1.8 but no suitable version is installed."
05:47:47 <lostman> I definitely do have a newer version
05:47:49 <Ainieco> hello
05:48:22 <Ainieco> is it possible to import everything from module with qualification but few functions/types without?
05:49:21 <lostman> Ainieco: yes, you just have to make two import statements... import qualified Foo as Foo and import Foo (bar,Baz(..))
05:49:24 <michi7x7> Ainieco: yes import qualified and import XYZ (a. b. c)
05:50:00 <Ainieco> thanks!
05:55:00 <solatis> Fuuzetsu: damn you, ever since you moved me towards NixOS i'm now fully procrastinating and optimizing my dev environment because of the new possibilities, instead of writing actual code :)
06:05:24 <MagneticDuck> NixOS.. hmmm
06:05:34 <MagneticDuck> that's the next distro I'm trying
06:06:18 <Julie23>  You can find funny videos here. http://tinyurl.com/ozfvxy3
06:06:33 <solatis> MagneticDuck: you can try the nix package manager without going full nixos
06:06:54 <MagneticDuck> mmm
06:06:57 <solatis> it's, imho, *the* answer for cabal dependency hell
06:09:01 * dcoutts_ is currently drawing maps / Venn diagrams of cabal hell
06:09:09 <MagneticDuck> where's that?
06:09:15 <MagneticDuck> oh, nm
06:09:55 * hackagebot diagrams-canvas 0.3 - HTML5 canvas backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-canvas-0.3 (jeffreyrosenbluth)
06:10:03 <MagneticDuck> okay, nix time
06:10:08 <dcoutts_> solarus: nix-style package management is a major part of the solution, but not the only part
06:11:22 <solatis> dcoutts_: that is true
06:11:40 <solatis> dcoutts_: i hope both projects can learn from each other
06:11:49 <Twey> (n ~ (n1 + 1)), (n ~ (n2 + 1)).  Can I prove that n1 ~ n2?
06:12:04 <MagneticDuck> what's the other project?
06:12:11 <solatis> cabal :)
06:12:16 <dcoutts_> solatis: we've known for years that stealing ideas from nix is a good idea, and have been moving in that direction
06:12:21 <MagneticDuck> I thought cabal was the disease :D
06:13:00 <MagneticDuck> Twey: assuming your +1's are all Peano and stuff, right?
06:13:22 <solatis> dcoutts_: yeah nix is more like a huge hammer for a solution in which a simple, more elegant solution would suffice
06:13:23 <Twey> MagneticDuck: They're GHC's TypeLits
06:14:20 <dcoutts_> solatis: hmm, not so sure that's true. Our plan is to steal the key ideas (but live with the limitation of not controlling the whole OS and system packages).
06:14:34 <solatis> isn't that essentially what nix is?
06:15:02 <solatis> nix without nixos is essentially the key ideas without managing the whole OS and system packages
06:16:05 <ij> What can the function name token consist of? Is it /[a-z0-9
06:16:12 <ij> What can the function name token consist of? Is it /[a-z0-9'_]/i   ?
06:16:49 <MagneticDuck> function name tokens == value name tokens
06:16:55 <ClaudiusMaximus> check the report - unicode is allowed too
06:16:55 <MagneticDuck> becaus' haskell maan
06:17:14 <MagneticDuck> ij: importantly, they cannot start with numbers
06:17:23 <Twey> ij: A lowercase letter or underscore, followed by any number of letters, digits, underscores, or apostrophes
06:17:26 <MagneticDuck> and they can have capital letters, but not as a first letter
06:17:31 <Twey> Where all those things are defined according to Unicode
06:17:35 <MagneticDuck> yeah essentially that
06:18:19 <phadej> Twey: unicode defines classs for characters, if the character is a letter or punctuation mark etc.
06:18:26 <ij> Is there a way to google the answer for this question effectively?
06:18:32 <ij> i'm not sure what to search for.
06:19:20 <MagneticDuck> ij: check the 2012 Haskell report
06:19:45 <MagneticDuck> or https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-180002.4
06:19:56 * MagneticDuck uses his epic googling skills
06:20:34 <Jookia> Hey, are dependent types inherently useful for proving programs due to the Curry–Howard correspondence?
06:22:06 <Kaidelong> Jookia: I couldn't really say, what it does help with is generating code that implements the type, which is one of the things that set dependently typed programming languages apart. But you *are* generating a correct implementation, and rejecting incorrect ones that don't "prove" the type
06:22:14 <Kaidelong> so I think yes
06:22:48 <Jookia> Hmm, I see
06:23:33 <Kaidelong> if there only exists one reasonable interpretation of a type T, so long as you got your type right, you can be reasonably sure the implementation of it is what you want
06:24:12 <Kaidelong> any type system goes some way toward this, dependent types I guess just go all the way and end up as a full replacement for things like design by contract
06:24:46 <Kaidelong> tellingly, you need theorem provers to type check dependently typed programs
06:25:25 <Jookia> i see
06:25:25 <Twey> phadej: Exactly so.
06:26:18 <Kaidelong> would you be able to predict that you need one from the curry howard correspondence? That's not obvious to me, but I think so. Programs are proofs, provers discover proofs, typecheckers unify one proof with another more general one, in a sense
06:26:48 <Kaidelong> I guess if you think of it like that you might be able to logically say that the curry howard correspondence predicts that dependently typed programming languages are good for proving properties of programs
06:26:48 <Twey> Kaidelong: It's not that you *need* a theorem-prover but that a theorem-prover and a typechecker are the same thing (by C–H)
06:27:20 <Kaidelong> Twey: I suppose that's true, you can just see type checkers in other languages are very restricted theorem provers
06:27:30 <Twey> Even weaker typecheckers are theorem-provers, just for less interesting (and usually inconsistent) logics
06:27:57 <Twey> Jookia: So yes
06:28:39 <Twey> Jookia: Whenever you write a type and get your program to match it, you're proving something about your program, namely that it produces a value of that type
06:28:39 <Jookia> Hmm. Doesn't this mean dependently typed languages are useful for writing code that obeys proofs?
06:29:01 <Hodapp> The code *is* the proof.
06:29:11 <Jookia> that's what i mean
06:29:13 <Twey> Jookia: Dependent types just give you a more powerful language in which to express properties about the program — instead of saying ‘it produces an integer’ you can now say ‘it produces the integer that is the sum of the two provided integers’
06:29:48 <Jookia> do you think we'll get to the point of haskell having dependent types?
06:29:57 <Kaidelong> I am thinking dependent types are kind of like our answer to statically verified contracts from the imperative world
06:30:06 <Kaidelong> they seem to be equally powerful
06:30:20 <Jookia> i'm thinking dependent types are the answer to property-based testing pure functions
06:30:23 <Twey> Jookia: It arguably already does, though in a rather roundabout way
06:30:37 <Hodapp> Jookia: property-based testing?
06:30:43 <Jookia> Hodapp: quickcheck, etc
06:31:05 <Twey> With data kinds we can duplicate the value level on the kind level, and with singleton types we can bridge the two
06:31:13 <Twey> Er, on the type level**
06:31:13 <Kaidelong> I think non-strict evaluation messes up some of the usefulness of it for proofs though
06:31:17 <Hodapp> Kaidelong: I'd expect that dependent types are a good deal more powerful.
06:31:38 <Jookia> Kaidelong: Hmm?
06:31:42 <Twey> Kaidelong: Nah, irrelevant.  What messes it up is lack of termination-checking — a non-terminating program is a proof of anything.
06:31:59 <Twey> But we're used to writing programs that work ‘up to termination’ anyway.
06:32:12 <Twey> > 3 + (let x = x in x :: Int)
06:32:16 <lambdabot>  mueval-core: Time limit exceeded
06:32:22 <Jookia> do we really need non-terminating programs
06:32:23 <Twey> Even (+) only works up to termination.
06:33:26 <Kaidelong> Jookia: it's related to the fact that any system that can encode anything can also encode nonsense, you either throw out some valid programs or allow some non-terminating ones
06:33:38 <Kaidelong> haskell chooses to allow non-terminating ones
06:33:56 <Hodapp> Jookia: The paper "Total Functional Programming" would seem to answer it in the negative.
06:34:03 <Kaidelong> (it actually also throws out some valid programs with its type system but for that there are things like "unsafeCoerce")
06:35:00 <Kaidelong> I get the feeling goedel's incompleteness theorem is deeply related to the halting problem but I haven't seen anyone actually illustrate that
06:35:23 <dcoutts_> solatis: yes, nix without nixos. But you said it's a huge hammer where a simpler solution may suffice, but I'm not sure I agree. I don't know of a smaller simpler solution.
06:35:24 <Hodapp> Kaidelong: Then you haven't read any amount at all.
06:35:49 <Twey> Jookia: There are some programs that are terminating but not provably so, by Gödel.  But there are various ways to encapsulate them, much like we do to IO in Haskell.
06:36:01 <Jookia> i see
06:36:25 <Hodapp> Kaidelong: Look up the Church-Turing Thesis.
06:36:28 <Kaidelong> Hodapp: that's a little tetchy, I do read academic papers as do most everyone else here, even if I can't always understand them. What are you referring to specifically?
06:36:31 <Kaidelong> okay thank you
06:36:32 <solatis> dcoutts_: my personal opinion: the haskell community would be better off embracing nix instead of trying to compete with it. but that might just be too radical and might be my inexperience with the long history of things and how they came to be as they are now.
06:36:42 <nooooob> I am having trouble installing the aws package. I have the same issue as reported here, but I cannot find a solution. Can anyone give me some pointers as to how I can figure out what package versions work?
06:36:57 <nooooob> * reported here: https://github.com/aristidb/aws/issues/101
06:37:00 <Kaidelong> (all I knew that was about was relating the lambda calculus to turing machines)
06:37:44 <hughfdjackson> this is ultra subjective - but does anyone else find it weird that the ultimate return type of http server handlers in the main frameworks *isn't*
06:37:50 <hughfdjackson> Req -> IO Response
06:37:53 <solatis> but in its own way, nixos is competing with Docker again
06:38:08 <solatis> so everyone is competing and solving different things in a different way
06:38:23 <hughfdjackson> Instead, yesod seems to have its own transformer, and Snap has its monad - each all encompassing :/ mixin' concerns all over the place
06:38:23 <benzrf> hughfdjackson: y what is it
06:38:45 <Kaidelong> solatis: if you want to abandon cabal and use nix instead, you leave us windows users high and dry
06:38:50 <Kaidelong> nix only works on *nix systems
06:39:14 <oakwhiz> hughfdjackson: it seems like instead of programming webserver as a simple function, you program a configuration which is passed into the webserver
06:39:29 <Hodapp> Yeah, have some sympathy for the Windows users. They have enough problems as is.
06:39:31 <solatis> Kaidelong: i know, but that problem would be solvable i think
06:40:11 <oakwhiz> Hodapp: that can easily be fixed by running a *nix development VM on windows
06:40:24 <solatis> that's not a fix, that's a workaround
06:40:26 <Kaidelong> GHC can cross compile now
06:40:32 <hughfdjackson> oakwhiz: I guess that's what monads do - perhaps i'm just too used to having access to a separate datatype that encompasses Request from the one that encompasses Response
06:40:33 <Kaidelong> but that would still be pretty awful
06:40:51 <Kaidelong> you could maybe put a folder managed by nix on a network share or something
06:41:20 <Kaidelong> but the nix tree is intentionally incomprehensible
06:41:27 <Kaidelong> and it's immutable by design anyway
06:41:34 <Kaidelong> so you'd need to figure out what to switch it to
06:42:49 <Ainieco> is there any  way to structure any sufficiently large haskell program without cramming all core types into one file because they're needed everywhere and ghc can't handle it without boot files
06:43:13 <dcoutts_> solatis: oh we're not trying to compete with it, we're saying they're right and following their lead
06:44:12 <yesthisisuser> why do I suddenly get "No instance for (MonadLogger IO)" errors with persist? I think I installed a different (slightly more recent) version in my sandbox.
06:44:51 <dcoutts_> solatis: but there are reasons we have to import the ideas rather than just say "stop using cabal, start using nix"
06:45:37 <solatis> dcoutts_: i know -- and i feel like about every language complains about its own package manager
06:45:45 <solatis> except c++, since it does not have a package manager
06:46:42 <nooooob> solatis: except for dpkg, apt-get, rpm, etc
06:46:46 <Jookia> c++ sure is fun to use libraries with
06:47:39 <Hodapp> C++ sure is fun to... not use, ever
06:48:45 <prophile> npm seems OK
06:48:51 <yesthisisuser> so I can't run withPostgresqlPool in IO anymore i guess. hmm?
06:49:15 <thoughtpolice> Nix does solve the problem of isolated/reproducible build environments in a good way, but it doesn't solve the problem of handling any kind of constraints. this is shoved off to the developers, and humans are err prone. instead, we want Cabal to figure out the constraints, and really have a Nix-like-solution drive the 'build plan' generated by the solver.
06:49:28 <thoughtpolice> but the problem is still a bit deeper than this. it's a good start, though.
06:49:34 <Hodapp> error prone*
06:49:36 <dcoutts_> solatis: but note that language tools also have to deal with the build system part of the problem (ie collections of packages people are hacking on now), not just complete packages like a dedicated package manager
06:49:37 <Hodapp> :)
06:49:56 <dcoutts_> and also as thoughtpolice says, we need a solver too, which nix doesn't have
06:50:12 <dcoutts_> the result of the solver can become a nix expression
06:50:29 <dcoutts_> but source packages with their version constraints are not a nix expression directly
06:51:52 <thoughtpolice> right, pretty much. Maintaining Nix/Haskell packages is pretty nice, but it can still require a fair amount of manual intervention to get all the dependencies lined up (some may be out of dated, used by conflicting packages, etc). the secret though is you can do things like have multiple copies of one package
06:51:57 <solatis> thoughtpolice: yeah the current approach in nix is to define your own custom nixExprs to override the defaults (a.k.a. nixpkgs.myHaskellPackages)
06:51:59 <thoughtpolice> so 'forking' a Nix expression is easy and feasible
06:52:03 <solatis> which is suboptimal in its own way
06:53:51 <thoughtpolice> also, in a Theoretically Perfect World, AFAICS, where everyone abided by the PVP, you get nice bonuses from the solver. if people don't push breaking changes e.g. for security fixes for example, the solver can (again if the PVP is abided by) always pick an upgraded version without complaint.
06:54:05 <nooooob> when trying to resolve build issues with incompatible versions, is there anything better to do than just trying older combinations?
06:54:30 <thoughtpolice> unfortunately right now that still requires humans manually making sure they don't make breaking changes (and doing security fixes, and abiding by the PVP), so it just moves some responsibility, but I believe there are better ways here
06:54:56 <Jookia> nooooob: sanboxes and crying
06:55:27 <oakwhiz> nooooob: nuke your cabal folder
06:56:02 <nooooob> I'll start from scratch and add various pieces one at a time
06:56:04 <oakwhiz> sometimes you can fix version incompatibilities by downloading the cabal sources
06:56:12 <oakwhiz> and then changing the deps yourself and rebuilding
06:56:26 <nooooob> oakwhiz: that's a good idea
06:56:50 <oakwhiz> I got an out of date library to work by changing a 2 to a 3 in the cabal file
06:57:18 <nooooob> oakwhiz: *writes down s/2/3/g
06:57:19 <solatis> i do think the way npm fixes those depencency issues pretty nicely, but it can lead to a HUGE chain of dependencies that needs to be resolved
06:57:20 <nooooob> *
06:57:25 <thoughtpolice> solatis: anyway, I work/commit on Nix fairly frequently and maintain lots of packages, so I see both sides. :) security updates are one thing where the manual intervention of a maintainer even in NixOS is archaic and tiresome, and this is worsened because like many distros, upstreams are independent from maintainers
06:57:57 <thoughtpolice> so having a tool automatically pick things for you is a real benefit in my mind. but Nix solves a billion other things very very well
06:58:00 <thoughtpolice> so it's worth it
06:58:07 <nooooob> thanks for the tips. I'll give it a jiggle about
06:58:50 <{AS}> Hi, are there any pure Haskell UI frameworks?
07:00:26 <yesthisisuser> {AS}: It does not answer your question, but you might be interested in looking at Functional Reactive Programming unless it is something you are familiar with.
07:00:46 <{AS}> yesthisisuser: Yeah, I am familiar with it. Thanks for the suggestion though :)
07:01:23 <{AS}> Just wondering if there are any for desktop etc.
07:02:22 <yesthisisuser> There are ports of Gtk+ and Qt of course.. Not very "pure" Haskell though, and you probably know about those as well then
07:03:23 <kqr> this is a bit off topic, but do you guys know of any place where people can collaborate on specifications for a program? a little like like google docs but not google docs
07:04:26 <solatis> kqr: i think github?
07:04:36 <{AS}> yesthisisuser: Yeah, I guess. I was actually more hoping at looking on how one would handle the specific infrastructure parts like rendering, composition of components, concurrency model, etc. :)
07:04:36 <solatis> just collaborate on a wiki/gist
07:04:58 <kqr> solatis, a gist is a decent alternative, a wiki is a better one but that requires a repo which feels like it's a bit overkill
07:05:18 <solatis> why would it be overkill?
07:05:20 <kqr> solatis, preferably, comments should not be part of the document but viewed on the side as metadata
07:05:40 <{AS}> at least I was told it was hard to make a concurrent UI using threads (cf. Java Concurrency in Practice)
07:05:42 <solatis> hmz
07:05:43 <solatis> wait
07:05:59 <solatis> i believe google invented something one day
07:05:59 <kqr> solatis, creating an entire repo to get access to a wiki page sounds like overkill to me... I mean i'm sure there are other services that provide you with that
07:06:00 <{AS}> I was wondering if there was a smart solution in the functional world
07:06:04 <solatis> which was completely mismarketed
07:06:14 * solatis gasps... google wave
07:06:35 <kqr> haha
07:06:37 <kqr> google wave is dead
07:06:43 <kqr> and I'd prefer to not go the google path
07:06:52 <solatis> i know
07:06:56 <solatis> let's see
07:07:37 <solatis> i feel atlassian will have something that fills your needs
07:08:55 <yesthisisuser> {AS}: I am not aware of any UI toolkit that does that in a purely functional way. Although have you looked at x-monad. It is not a GUI toolkit, but you could perhaps get some ideas from there
07:09:38 <solatis> kqr: https://www.atlassian.com/software/confluence
07:09:51 <solatis> that would probably be the best thing other than github wiki's
07:10:18 <solatis> but i would just go for github wiki's
07:10:52 <{AS}> yesthisisuser: Yeah, perhaps that is a good idea thanks :)
07:14:58 <kqr> solatis, looks good, but I'd like something that's a bit more... free
07:16:33 <solatis> kqr: i think you're in a place right now where you basicly know all your options, but don't know which ones will work in practice
07:16:47 <solatis> an informed, intuitive guess will probably be your best road
07:17:09 <kqr> yeah
07:17:11 <kqr> thanks for the help
07:17:18 <kqr> I understand it's not at all within the scope of this channel :D
07:19:25 <Twey> {AS}: The ‘smart solution’ is FRP
07:20:03 <Twey> {AS}: You can use it with existing imperative toolkits like Gtk2Hs or wxHaskell, or there are some existing FRP-oriented toolkits like threepenny-gui
07:24:05 <Twey> {AS}: FRP gives you the ability to not care about the origin of an event — you just know that an event of the appropriate type fired.  It could have come from a different widget, a different thread, or even a completely different machine.
07:24:29 <Hodapp> I need to catch up on FRP again...
07:24:40 <Hodapp> I'm pretty sure it's what I need, but I've not read much on it in a year or two
07:26:21 <{AS}> Twey: Thanks :). Unfortunately I have only seen FRP solutions been used on smaller examples
07:26:38 <{AS}> I have not seen many full blown applications using FRP
07:27:06 <{AS}> Twey: I would welcome any suggestions if you know some
07:28:05 <shiona> Frag is often said to use FRP, I have no idea if it is actually http://www.haskell.org/haskellwiki/Frag
07:28:21 <{AS}> shiona: Oh, interesting thanks
07:28:50 <shiona> I assume it could be considered legacy code today however
07:45:02 * hackagebot lens-aeson 1.0.0.1 - Law-abiding lenses for aeson  http://hackage.haskell.org/package/lens-aeson-1.0.0.1 (EdwardKmett)
08:10:02 <ddellacosta> Anyone here have any opinions on "Lambda Calculi with Types" by Barendregt?
08:10:37 <Twey> {AS}: The principle's the same.  But you could look at threepenny-gui's examples
08:21:36 <{AS}> Twey: Ok, thanks
08:32:43 <codehero> is there an easy way to make a Maybe tuple that will result in a Nothing if any of the supplied elements is a nothing?
08:33:33 <oakwhiz> data MaybeTuple = Some a b | Nothing
08:34:04 <exio4> > (,) <$> Just 3 <*> Just 4
08:34:05 <lambdabot>  Just (3,4)
08:34:07 <exio4> > (,) <$> Just 3 <*> Nothing
08:34:09 <lambdabot>  Nothing
08:34:14 <exio4> > (,) <$> Nothing <*> Just 4
08:34:15 <lambdabot>  Nothing
08:34:21 <oakwhiz> that's pretty clever
08:34:21 <exio4> codehero: this? ^
08:34:38 <codehero> yeah
08:34:42 <codehero> cool. thank you :D
08:34:52 <codehero> i didn't know it was that easy
08:35:28 * shikhin looks at Some.
08:37:27 <codehero> > (,) <$> Just 5 <*> Just 8 <*> Just 3 <*> Just 9
08:37:29 <lambdabot>  Couldn't match type ‘(a3, a2)’ with ‘a1 -> a0 -> b’
08:37:29 <lambdabot>  Expected type: a3 -> a2 -> a1 -> a0 -> b
08:37:29 <lambdabot>    Actual type: a3 -> a2 -> (a3, a2)
08:37:31 <codehero> hmm
08:37:33 <codehero> okay
08:37:52 <codehero> it doesn't seem to work with more than two elements
08:38:00 <hexagoxel> if you take (,)..
08:38:03 <hexagoxel> :t (,,)
08:38:04 <lambdabot> a -> b -> c -> (a, b, c)
08:38:07 <hexagoxel> :t (,,,)
08:38:07 <codehero> oh
08:38:08 <lambdabot> a -> b -> c -> d -> (a, b, c, d)
08:38:09 <codehero> heh
08:38:12 <codehero> didn't know that
08:38:23 <codehero> there is still so much to learn
08:53:25 <latk> stupid question - I'm trying to append a slash to a Text string, e.g. "This" `T.append` "/". I can't do this as it interprets it as an escaped ". Doing "//" results in two slashes.
08:53:28 <latk> What should I do ? :p
08:55:35 <geekosaur> wat? / and \ are different keys. \\ should work to produce a single \
08:55:41 <barrucadu> latk: What do you mean? Works for me
08:55:45 <geekosaur> (different characters that is)
08:57:04 <latk> Hm, I get the error: lexical error in string/character literal at character '\n'
08:57:21 <codehero> awesome. i love haskell
08:57:46 <geekosaur> @paste your code latk?
08:57:46 <lambdabot> Haskell pastebin: http://lpaste.net/
08:58:10 <codehero> http://lpaste.net/111344
08:58:51 <latk> Uf, yeah using the wrong slash. This may be a sign that I am too hung over to be doing anything.
09:01:23 <dfranke> I'm having a linker problem when using 'cabal repl'; pretty sure it's a known issue but I'm wondering if anyone knows a workaround...
09:01:41 <dfranke> I've written bindings for a library written in C++.
09:02:08 <dfranke> If I 'cabal install' my package and then run ghci and import it, it works fine.
09:02:20 <dfranke> but if I run 'cabal repl' from within my package directory, I get this:
09:02:27 <dfranke> Loading object (static) dist/build/cbits/cld2_haskell_shim.o ... ghc: panic! (the 'impossible' happened)
09:02:30 <dfranke>   (GHC version 7.8.2 for x86_64-unknown-linux):
09:02:33 <dfranke> 	Loading temp shared object failed: /tmp/ghc26492_0/ghc26492_4.so: undefined symbol: _ZTVSt9bad_alloc
09:02:49 <dfranke> it's trying to load my object file without first loading libstdc++.
09:04:25 <dfranke> so far the only workaround I've been able to find is to set LD_PRELOAD in my environment. Yuck.
09:07:12 <poutsi> ran into this when trying to install Helm, which depends on glib: http://comments.gmane.org/gmane.comp.lang.haskell.cafe/107782
09:07:32 <poutsi> the links say that's ghc 7.6 + xcode 5 -related and ghc 7.8 fixes it, but I've got 7.8
09:15:39 <poutsi> hmm... so is this a gtk2hs-buildtools issue ... probably
09:25:49 <alexfu> if 1 : [2,3] prepends to the list, what is the syntax for append?
09:26:40 <Twey> alexfu: The list data type is defined (up to syntax) as: data [a] = [] | a : [a]
09:27:03 <Twey> alexfu: So there's no symmetrical ‘append’ constructor
09:27:05 <shiona> alexfu: there is no way to append (in strict sense) to a list. You can concatenate two lists, but that will actually prepend every element from the first list to the second
09:27:30 <Twey> alexfu: If you're interested in appending, you might want to try Data.Seq or whatever's new at the moment
09:27:39 <Twey> But it's not as useful as newbies often presume
09:28:07 <Twey> (one alternative is to prepend to get a list that's backwards, then reverse when you're finished building it)
09:28:53 <Haskellfant> is there something like Applicative f => f (a -> b) -> a -> f b which automatically causes pure on the a?
09:28:55 <sivteck> > [2,3] ++ [1]
09:28:57 <lambdabot>  [2,3,1]
09:29:18 <sivteck> (not append)
09:29:52 <bennofs> :t (??) -- from lens
09:29:53 <lambdabot> Functor f => f (a -> b) -> a -> f b
09:29:58 <ChristianS> alexfu: https://hackage.haskell.org/package/dlist is a package for lists that support appending as efficiently as prepending
09:31:24 <alexfu> strange how append isn't as straight forward
09:32:17 <ChristianS> alexfu: normal haskell lists are single-linked so to get to the last element you have to traverse the whole list
09:32:35 <alexfu> ohh
09:33:59 <Twey> Haskellfant: You don't need Applicative so long as only one of the {function, argument} is in the Functor
09:34:06 <alexfu> so, that means append would take up O(n) ?
09:34:09 <alexfu> time
09:34:29 <Haskellfant> Twey: oh right
09:34:48 <Haskellfant> fmap ($a) functioninfunctor
09:34:55 <Twey> Haskellfant: Right
09:34:59 <Twey> flip $ fmap . flip id
09:35:20 <Twey> (ick)
09:37:04 <Nokiabot> Ta da
09:38:40 <monochrom> dfranke: if using ghci directly, add -lstdc++. if using cabal repl, I don't know.
09:39:56 <monochrom> perhaps cabal repl's "--PROG-option=OPT" helps. read "cabal repl --help"
09:40:09 <hexagoxel> cabal exec -- ghci -lstdc++
09:40:11 * hackagebot hydrogen-version 1.0 - Hydrogen Syntax  http://hackage.haskell.org/package/hydrogen-version-1.0 (JulianFleischer)
10:01:14 <^[^_^]^> Ciao Gente Sono Qui Tra Voi -> mIRC Explorer by PaMeLab <-
10:01:21 <dfeuer> Oh good. It looks like I'm not the only one having GHC build issues relating to libffi.
10:01:39 <MP2E> dfeuer: indeed
10:01:46 <MP2E> been wrestling with it for like 4 days now :V
10:02:07 <MP2E> also, you're right, I thought the workaround worked because compilation looked to advance but I stopped it. I tried it again and it fails with the same error you're getting
10:02:10 <MP2E> -.-
10:02:55 <dfeuer> MP2E, since you're here, did you have any thoughts on that quotRem thing I mentioned?
10:05:36 <Kara23>  Hi! I give you some videos. I hope you like! http://tinyurl.com/ozfvxy3
10:05:48 --- mode: ChanServ set +o monochrom
10:05:54 --- mode: monochrom set +b *!*@5.254.97.109
10:05:54 --- kick: Kara23 was kicked by monochrom (Kara23)
10:06:03 <dfeuer> Thanks.
10:06:16 --- mode: monochrom set -b *!*@5.254.97.109
10:06:17 <MP2E> dfeuer: not sure sorry, haven't written rules for GHC before actually
10:06:19 --- mode: monochrom set -o monochrom
10:06:59 <dfeuer> MP2E, I've written RULES, but never really dug into the depths. RULES aren't powerful enough to do what I want here :-/
10:07:28 <MP2E> ah
10:07:46 <MP2E> hmm oh right you need to guarantee it happens after CSE..
10:08:56 <dfeuer> Well, even aside from that problem, there's no way for RULES to know about a variable not being free in one or more expressions.
10:13:05 <dfeuer> MP2E, it's pretty cool that CSE can do what it does for this now; in 7.8.3 it wasn't up to the job even in simple cases.
10:13:18 <dfeuer> Er... that's not fair.
10:13:30 <dfeuer> It wasn't up to the job in some simple cases. It could handle some.
10:15:25 <MP2E> I'm definitely excited for 7.10.1 (even though it's still a while off)
10:15:40 <sipa> [1,2] `append` [3,4]
10:15:45 <sipa> > [1,2] `append` [3,4]
10:15:48 <lambdabot>  Not in scope: ‘append’
10:15:48 <lambdabot>  Perhaps you meant one of these:
10:15:48 <lambdabot>    ‘BSC.append’ (imported from Data.ByteString.Char8),
10:15:48 <lambdabot>    ‘BSLC.append’ (imported from Data.ByteString.Lazy.Char8),
10:15:48 <lambdabot>    ‘mappend’ (imported from Data.Monoid)
10:15:57 <sipa> > [1,2] ++ [3,4]
10:15:59 <lambdabot>  [1,2,3,4]
10:36:17 <nitrix> Hi, would you guys recommend building a FUSE system in Haskell?
10:36:31 <nitrix> Did anyone here do it before, how much of a pain is it?
10:37:02 <nitrix> I'm experienced with C but it's getting very troublesome to deal with ownership of all the different objects used by the file system.
10:38:09 <nitrix> Things sometimes have allocated storage, sometimes automatic, and I can't just chose one or the other because that comes with a serious cost for me :/
10:38:37 <nitrix> Last option was to make the structs contain a flag to tell which members must be deallocated, make it opaque and build a wrapper for it.
10:38:51 <nitrix> But at this point, you question yourself if you're using the right tool for the job.
10:43:35 <nitrix> No matter what I do, the language is introducing a layer of complexity for ownership and storage, it's non-sense.
10:43:54 <nitrix> What do I do, Doctor? Haskell?
10:45:49 <oakwhiz> nitrix: use ZFS
10:45:57 <oakwhiz> :-)
10:46:11 <nitrix> oakwhiz: ZFS ._. ?
10:47:17 <nitrix> oakwhiz: I want to write my own D:
10:50:15 <vanila> nitrix, that sounds like a hard problem! btw ZFS = Zipper FS :p
10:50:26 <vanila> http://okmij.org/ftp/continuations/zipper.html#zipper-fs
10:50:44 <vanila> if you made a fuse based on this it would be very interesting
10:51:11 <burp> apparently no fuse bindings yet
10:51:21 <burp> oh wait, there are
10:51:51 <nitrix> I've seen a bit Zipper, it's _close_ to what I want to do, but not exactly there.
10:52:50 <Ankhers> If I have `data Cell = Dead | Alive`, how Could I get Dead to represent 0, and Alive to represent 1?
10:53:25 <coppro> Ankhers: Do you actually need the integer values? if so, you could define a function :: Cell -> Int
10:53:48 <Ankhers> coppro: I would prefer the integer value for the sake of addition.
10:53:55 <Ankhers> a function will work, thanks.
10:54:11 <benzrf> Ankhers: why not define the function in terms of Cell
10:54:27 <oakwhiz> Ankhers: deriving (Enum)
10:54:46 <vanila> Ankhers, why not define  addCell Dead Dead = Dead ; addCell Dead Alive = Alive etc.
10:54:53 <oakwhiz> @define data Cell = Dead | Alive deriving (Enum)
10:54:56 <lambdabot>  Defined.
10:54:56 <vanila> then you don't need to change across representations?
10:55:53 <benzrf> vanila: i just said that >.>
10:57:34 <vanila> benzrf, ah sorry I didn't see it
10:59:58 <dncr> Data.IntMap has mapAccum, but what is the best way to go about it if I need:
11:00:05 <dncr> mapAccumM :: Monad m => (a -> b -> m (a, c)) -> a -> IntMap b -> m (a, IntMap c)
11:00:17 * hackagebot data-dispersal 1.0.0.1 - Space-efficient and privacy-preserving data dispersal algorithms.  http://hackage.haskell.org/package/data-dispersal-1.0.0.1 (PeterRobinson)
11:00:39 <dncr> toList then fromList?
11:09:56 <matt1> does a haddock page exist for yesod anywhere?
11:10:15 <matt1> i'm trying to find all the functions available, but there doesn't seem to be a consolidated source
11:24:10 <hexagoxel> matt1: maybe: https://hackage.haskell.org/package/yesod-core-1.2.19.2/docs/Yesod-Core.html
11:34:31 <sinelaw> So haskell doesn't really have record types, because there is no "record accessor" syntax, so you can't write something like: \x -> x.y where ".y" is not a function
11:35:12 <sinelaw> The record syntax generates accessor functions, but they are not polymorphic
11:35:23 <sinelaw> am I understanding correctly?
11:36:00 <sinelaw> (.y could be a polymorphic function but that would require subtyping to be useful)
11:40:20 * hackagebot formatting 5.3 - Combinator-based type-safe formatting (like printf() or FORMAT)  http://hackage.haskell.org/package/formatting-5.3 (ChrisDone)
11:45:15 <benzrf> argh
11:45:34 <benzrf> can anybody tell me how elerea differs from sodium differs from grapefruit differs from netwire differs from reactive-banana
11:45:50 <benzrf> afaict netwire is something completely different from standard event/behavior
11:45:57 <benzrf> i dunno what grapefruit does
11:46:03 <benzrf> arent sodium and banana basically the same
11:48:47 <sinelaw> try #health-drinks ;)
11:49:06 <sinelaw> but seriously, did you check which are actively maintained?
11:54:23 <benzrf> i dunno
11:55:21 * hackagebot formatting 5.4 - Combinator-based type-safe formatting (like printf() or FORMAT)  http://hackage.haskell.org/package/formatting-5.4 (ChrisDone)
12:05:59 <ChristianS> benzrf: i researched the alternatives a bit. i inclincation would be to start with reactive-banana and turn to sodium if it turns out to be problematic
12:06:18 <ChristianS> benzrf: but i haven't really used either, so your mileage may vary
12:35:05 <k00mi> benzrf: one difference is elerea and netwire, unlike reactive-banana, are based on "frames" (I think this is what "discrete time" refers to)
12:36:10 <k00mi> elerea is used in helm, so I guess that's a big plus if you want to develop a game
12:36:20 <k00mi> also, you forgot yampa ;)
12:36:22 <benzrf> helm
12:36:51 <codehero> how can i have a list in a data type?
12:37:54 <codehero> okay. figured it out
12:38:12 --- mode: ChanServ set +o monochrom
12:38:21 --- mode: monochrom set -b *!*@178.62.181.153
12:39:09 <Licenser> I'm back :) sorry for the connection spam a while go!
12:41:47 --- mode: monochrom set -o monochrom
12:42:40 <gamegoblin> @pl \x -> map (f x) . h x
12:42:41 <lambdabot> ap ((.) . map . f) h
12:43:51 <bennofs> :t map . f <*> h
12:43:52 <lambdabot>     Ambiguous occurrence ‘map’
12:43:52 <lambdabot>     It could refer to either ‘Data.List.map’,
12:43:52 <lambdabot>                              imported from ‘Data.List’ at /home/lambda/.lambdabot/State/L.hs:91:1-16
12:44:00 <bennofs> :t fmap . f <*> h
12:44:01 <lambdabot> (FromExpr (f a1), FromExpr b, Show a1, Show a, Functor f) => a -> f b
12:44:15 <bennofs> :t \x -> map (f x) . h x
12:44:16 <lambdabot>     Ambiguous occurrence ‘map’
12:44:16 <lambdabot>     It could refer to either ‘Data.List.map’,
12:44:16 <lambdabot>                              imported from ‘Data.List’ at /home/lambda/.lambdabot/State/L.hs:91:1-16
12:44:20 <bennofs> :t \x -> fmap (f x) . h x
12:44:21 <lambdabot> (FromExpr (f a1), FromExpr b, Show t, Show a1, Show a, Functor f) => t -> a -> f b
12:45:00 <bennofs> :t (.) <$> fmap . f <*> h
12:45:01 <lambdabot> (FromExpr (f a2), FromExpr b, Show a2, Show a1, Show a, Functor f) => a1 -> a -> f b
12:46:18 <rodlogic> is it possible to overload function application in haskell? I.e. use f a for f (a -> b) <*> f a ?
12:47:45 <Hijiri> no, I don't think you can
12:48:26 <Hijiri> I don't think you can overload normal operators either, unless you use a typeclass
12:49:25 <MagneticDuck> Hijiri: not usually
12:49:28 <MagneticDuck> >:)
12:49:50 <Hijiri> w-what does that mean
12:50:07 <MagneticDuck> http://hackage.haskell.org/package/base-4.7.0.1/docs/Text-Printf.html#v:printf
12:50:10 <MagneticDuck> behold!
12:51:08 <benzrf> rodlogic: soon we will have idiom brackets!!
12:51:14 <benzrf> rodlogic: then you will be able to write:
12:51:19 <benzrf> [| f x y |]
12:51:21 <benzrf> and it becomes
12:51:24 <benzrf> f <$> x <*> y
12:51:40 <rodlogic> benzrf: why not "f x y" ?
12:51:47 <benzrf> rodlogic: because f is not a function
12:51:56 <benzrf> (unless this is the Reader applicative)
12:52:36 <benzrf> rodlogic: imagine you have on a table a laptop and a peripheral.
12:52:43 <benzrf> you could say 'plug the peripheral into the laptop'
12:52:52 <benzrf> now imagine that they are both in boxes
12:53:03 <benzrf> you would NOT say 'plug the peripheral box into the laptop box'
12:53:39 <MagneticDuck> you would say [|plug the peripheral box into the laptop box|]
12:53:43 <MagneticDuck> ^ obviously
12:53:45 <benzrf> :-)
12:53:48 <benzrf> was about to say:
12:53:48 <rodlogic> benzrf: Yes, I understand that. I guess what I am asking is if there is a way to hook into the function application in Haskell so that we can wrap/unwrap as needed
12:53:59 <benzrf> you MIGHT say `assuming by "the whatever box" i really mean "the thing in the whatever box", plug the peripheral box into the laptop box"
12:54:02 <benzrf> '
12:54:07 <benzrf> rodlogic: no, that would be horrifying
12:54:34 <rodlogic> benzrf: :-) I guess I am only seeing beauty so far
12:54:46 <benzrf> rodlogic: hmmmm
12:54:52 * benzrf reads rodlogic's palm
12:54:53 <benzrf> i divine...
12:54:54 <rodlogic> benzrf: f a b vs [| f a b |]
12:54:55 <benzrf> that...
12:54:56 <benzrf> you are a perl user!
12:55:07 <coppro> but wait. what if there are multiple kinds of boxes available?
12:55:33 <triliyn> rodlogic: the main hairy point I can think of is that sometimes either interpretation could be available
12:56:06 <benzrf> regardless of any of this
12:56:15 <benzrf> half the point of haskell is, SAY EXACTLY WHAT YOU MEAN
12:56:15 <triliyn> And when that happens you'd want to be able to precisely say which one you mean
12:56:24 <benzrf> that way if you make a mistake, the compiler instantly lets you knwo
12:56:34 <benzrf> part of the philosophy of the language afaict
12:56:48 <benzrf> perl has a philosophy of 'if i make just a little mistake, figure out what i mean'
12:56:56 <benzrf> that is not how haskell operates
12:57:02 <rodlogic> benzrf: but what about do notation? It is adding sugar to f >>= \x -> ...
12:57:08 <benzrf> rodlogic: you're still being explicit
12:57:14 <benzrf> just more concisely explicit
12:57:18 <benzrf> it's directly isomorphic
12:57:27 <triliyn> rodlogic: it's adding a new kind of syntactic form, rather than adding a new meaning to an existing form
12:58:49 <benzrf> haskell is occasionally less convenient, but in return, actual mistakes get caught almost immediately
12:59:01 <benzrf> it's a trade-off, but imo a good one :)
12:59:42 <rodlogic> for "f a", f could be a pure function or a boxed function, same for a: pure or boxed. So pure x pure = regular function call, pure x boxed = lift f to boxed type and <*>, boxed x pure = lift pure to boxed type and <*>, boxed x boxed = just <*>
12:59:44 <benzrf> if f x y were automatically translated into liftA2 f x y if it looks like it might make sense, you'd be able to pare a few chars in return for ambiguity and potential mistakes all over
13:00:48 <benzrf> although tbh it's a bit like what we already have in typeclasses
13:01:08 <benzrf> but really, excessive typeclass overriding to make any crazy combo work is often a bad thing
13:01:24 <triliyn> rodlogic: but every function is boxed, because (->) r is an applicative
13:01:26 <rodlogic> benzrf: or how IsString works with Overloaded strings?
13:01:53 <triliyn> With something like (+3) 5, is that supposed to be pure x pure or boxed x pure in the function applicative?
13:01:58 <benzrf> rodlogic: OverloadedStrings is relatively tame
13:02:12 <benzrf> but function application happens 500000000 times per page of codehero
13:02:13 <benzrf> *code
13:02:22 <triliyn> OverloadedStrings just implicitly calls fromString on every literal
13:02:23 <benzrf> there's waaaay more application than string literals in your typical program
13:02:31 <codehero> per page of codehero. hmm
13:02:36 <benzrf> less room for mixups and errors and ambiguity
13:02:40 <codehero> i wonder how often i would fit on a page :D
13:02:40 <benzrf> codehero: mistab >_>
13:02:46 <codehero> no prob :p
13:03:21 <rodlogic> benzrf, triliyn: yes, interesting ... is (->) boxed or pure?
13:03:27 <Hijiri> If I use a blocking IO actions like getChar in a netwire Wire, will that block the whole program, or are wires updated in a separate thread somehow?
13:03:43 <k00mi> rodlogic: what do you mean by "boxed"?
13:03:52 <Hijiri> right now I have a separate thread explicitly updating an IORef
13:03:55 <Hijiri> and the wire just reads that
13:06:00 <rodlogic> k00mi: e.g. IO Int is boxed : I can't access Int directly unless I run the monad. So f :: * -> *  or more specifically f (a ->b) of f Int is boxed
13:06:02 <monochrom> Hijiri: getChar blocks just the thread that calls getChar. this assumes you build with -threaded.
13:06:36 <rodlogic> k00mi: or functor in this case is much weaker than a monad?
13:07:07 <monochrom> actually maybe still true without -threaded, I haven't tried.
13:07:09 <Hijiri> well I'm not sure how netwire works
13:07:13 <rodlogic> k00mi: or functor is a value in a context
13:07:18 <Hijiri> if it uses multiple threads for update
13:07:40 <RedNifre> If I have this working code:
13:07:45 <RedNifre> v <- liftIO foo
13:07:51 <RedNifre> text $ pack $ v
13:08:03 <RedNifre> Then why doesn't this code work?: text $ pack $ liftIO foo
13:08:14 <geekosaur> RedNifre, because an IO String is not a String
13:08:22 <geekosaur> nor is it a wrapper around a String
13:08:30 <RedNifre> The compiler complains that String is not a Char though.
13:08:53 <RedNifre> So is <- the opposite of return?
13:09:02 <geekosaur> I'd have to see the full error, but that makes me think it saw String (== [Char]) and tried to use the list monad?
13:09:07 <rodlogic> benzrf: I am coming from the pov of embedding a DSL in Haskell and reducing the unnecessary boiler plate.
13:09:08 <geekosaur> sort of
13:09:12 <geekosaur> there is no true opposite
13:09:16 <k00mi> rodlogic: I would advise you to drop the "boxed" analogy
13:09:19 <monochrom> RedNifre, I recommend you read my http://www.vex.net/~trebla/haskell/IO.xhtml
13:09:24 <rodlogic> benzrf: granted, idiom brackets will be an improvement :-)
13:09:30 <k00mi> as you found out it breaks for simple examples like (->) a
13:09:39 <geekosaur> <- converts to the >>= operator, which attaches a "callback" to a "program"
13:09:55 <RedNifre> Is there a way to write the code without the v?
13:10:06 <monochrom> yes, it uses >>=
13:10:13 <triliyn> RedNifre: I think you can say text . pack =<< liftIO foo
13:10:35 <monochrom> read my article for the full story
13:10:35 <rodlogic> k00mi: how would you call it?
13:10:38 <Hijiri> why not liftM (text . pack) $ liftIO foo?
13:10:55 <triliyn> er, wait
13:11:01 <triliyn> yeah, that's right and mine isn't
13:11:05 <triliyn> text . pack isn't monadic
13:11:17 <triliyn> fmap would also work
13:11:21 <geekosaur> fmap (or liftM), yes
13:11:27 <geekosaur> or return . text . pack
13:12:20 <monochrom> I assumed that "v <- liftfoo; text $ pack $ v" was working code, as stated. therefore, "text $ pack $ v" has to be a monadic action already, no liftM.
13:12:23 <k00mi> rodlogic: Functor
13:12:41 <triliyn> rodlogic: I don't think it's really boilerplate to add textual distinguishment between two conceptually different meanings
13:13:09 <triliyn> As long as the distinguishment isn't excessive, which idiom brackets aren't
13:13:24 <triliyn> The current f <$> x <*> y is a bit more borderline
13:15:28 * hackagebot cake3 0.5.2.0 - Third cake the Makefile EDSL  http://hackage.haskell.org/package/cake3-0.5.2.0 (SergeyMironov)
13:15:57 <RedNifre> hmmmm
13:16:07 <merijn> In this example I would probably just simplify to "text . pack <$> liftIO foo"
13:16:17 <rodlogic> triliyn: that is a bit subjective and I do see the improvement with idiom brackets. I was mostly curious how the possibility to giving the functor the ability to let function application 'see' through to the inner function.
13:17:22 <RedNifre> it works with =<< but how is it different if I use <$> instead? And what is <$>? (I only know >>= so far, like the backward version)
13:17:26 <rodlogic> triliyn: but it seems that there are some nasty side effects that make this a no go. I am just not seeing it clearly
13:18:02 <triliyn> RedNifre: <$> is fmap, and can be used when you want to apply a pure function "under" a functor
13:18:08 <triliyn> =<< is >>= with its arguments reversed
13:18:10 <merijn> :t (<$>)
13:18:11 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:18:15 <merijn> :t fmap
13:18:16 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:18:32 <rodlogic> triliyn: I was expecting that if f is an applicative and so support the 'apply' then haskell could delegate to it when simple using function application.
13:19:07 <merijn> rodlogic: That sounds like it could result in ambiguous cases
13:19:18 <RedNifre> Wait, I thought >>= did that already?
13:19:26 <RedNifre> :t >>=
13:19:27 <lambdabot> parse error on input ‘>>=’
13:19:28 <triliyn> :t (>>=)
13:19:29 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:19:33 <RedNifre> :t (>>=)
13:19:34 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:19:55 <triliyn> This is for applying a monadic function "under a monad"
13:20:25 <triliyn> If the monad is IO, then you use <$>/fmap when you want to apply something with type a -> b
13:20:38 <triliyn> And you use >>= when you want to apply a function with type a -> IO b
13:20:54 <RedNifre> well, I don't want IO since that code is in an ActionM do block.
13:21:14 <triliyn> ActionM then
13:21:32 <monochrom> RedNifre: what is the type of "text"?
13:21:38 <triliyn> The IO was just an example; you want >>= when the function you want to apply returns something in the monad
13:22:13 <RedNifre> I don't know, all I know is that it is a Scotty function that sends a Text to the client.
13:22:31 <rodlogic> merijn: could you give an example/
13:22:35 <Sornaensis> if I am making an application that sits in an event loop is it a good idea to have an eventloop that recursively passes an environment record to itself?
13:22:37 <triliyn> That is probably monadic then
13:22:47 <monochrom> I guess it doesn't matter and no one cares.
13:23:15 <vanila> http://hackage.haskell.org/package/containers-0.2.0.1/docs/Data-Graph.html is there some lib that will show one of these on the screen?
13:23:17 <merijn> Sornaensis: Do you want to update the environment during the loop?
13:23:40 <Sornaensis> yes
13:23:42 <merijn> rodlogic: I'm trying to work out if there's an example, but tbh I just woke up and might be to groggy to bother :)
13:23:55 <merijn> Sornaensis: Then I don't see how else you'd reasonably do it? :)
13:24:06 <triliyn> text :: Text -> ActionM ()
13:24:18 <merijn> You could use State, but if you only have the one argument, then I wouldn't bother with that
13:24:42 <RedNifre> So, a do block is a chain of actions that all belong to the same monad...type? And the type is determined by whatever fits all actions? And nested do blocks need to end in something like liftWhatever that makes the result compatible with the outer do block?
13:25:03 <Sornaensis> merijn: just wondering if there was a better way :)
13:25:32 <Hijiri> inner do blocks just means it's another monadic action
13:25:43 <Hijiri> you could pass it into some function that takes care of getting it to the right monad
13:25:51 <Hijiri> and in some cases you might not be able to lif it at all
13:25:53 <Hijiri> lift
13:26:04 <triliyn> RedNifre: a do block is a chain of applications of >>=; all the rules come from that
13:26:11 <merijn> Sornaensis: Not anything significant, it depends on the context, if the rest of your code is already in State or whatever, you could use that. But tbh, just recursively calling itself with different arguments is fine
13:28:17 <RedNifre> The thing I don't understand about the text . pack =<< liftIO foo solution is that I understand =<< to take what comes out of text and return that as an ActionM, which seems unnecessary since it already returns an ActionM.
13:28:51 <threestrikes> just reading over some of the GUI libraries and some are considered high level and others low level are they just talking about video resolution?
13:29:01 <Cale> RedNifre: hm?
13:29:03 <vanila> Actually what graph library should I use?
13:29:13 <vanila> let alone visualizing it ( I think ill skip that it seems like too much work)
13:29:17 <Hijiri> low level often means that each function is a close analogue to a C function
13:29:25 <merijn> vanila: It depends on how big your graphs are :)
13:29:33 <Hijiri> just wrapped minimally
13:29:45 <Hijiri> high level is more abstracted
13:29:46 <Cale> RedNifre: In f =<< x, you have x :: ActionM a, and f :: a -> ActionM b, and the whole action f =<< x :: ActionM b then
13:30:19 <RedNifre> Well, I understand the code like this: liftIO foo results in an ActionM String. The =<< then applies pack, which turns the String into a Text. Then it applies text which turns the Text into an ActionM Text. Then it finishes by putting it back in an ActionM?
13:30:25 <Cale> RedNifre: f =<< x, when executed, will first execute x, capturing its result of type a, call it v, and then it will execute f v
13:30:33 <vanila> I think they would be near 5000 edges
13:30:34 <Hijiri> so for example the SDL bindings to haskell would be low-level, you have to initialize it and everything is IO actions because they're just mapped to C functions
13:30:44 <Cale> capturing some result w, and then w becomes the result of the whole combined action
13:30:58 <Hijiri> things like FRP GUI frameworks are high level and are abstracted with FRP things
13:31:05 <Cale> So, in this case,
13:31:30 <Cale> text . pack =<< liftIO foo, when executed, will first execute liftIO foo, getting some result v
13:31:43 <Cale> and then it will execute (text . pack) v
13:31:49 <Cale> which is the same thing as text (pack v)
13:31:59 <Cale> and the result of that action is the result of the whole action
13:32:38 <Cale> i.e. this is the same as writing   do v <- liftIO foo; text (pack v)
13:32:48 <threestrikes> for a beginner which is easier to comprehend?
13:32:58 <Cale> which is again the same thing as writing   do v <- liftIO foo; w <- text (pack v); return w
13:33:26 <RedNifre> Okay, maybe i missunderstood =<<. Say you have length =<< Maybe [1,2]. Is that valid? Or am I confusing this with <$>? Hmmm....
13:33:28 <Cale> threestrikes: If you're a beginner, maybe try out Gloss
13:33:30 <merijn> vanila: Then probably your selection of graph library doesn't matter that much :)
13:33:51 <Cale> threestrikes: Depending on what sort of program you want to write, it might be pretty convenient
13:34:00 <blogle> anybody know of good resources on designing a programming language
13:34:01 <Cale> and it's definitely pretty easy to understand
13:34:16 <Cale> threestrikes: It's a good way to get some graphics onto the screen and animate them / make them interactive
13:34:25 <Cale> threestrikes: though it has some pretty definite limitations
13:34:27 <merijn> blogle: What are you interested in? The code generation bit or the type system design bit?
13:34:54 <threestrikes> is Gloss considered high lvl or low lvl?
13:35:12 <Cale> blogle: If you haven't read Pierce's "Types and Programming Languages", then I'd highly recommend it
13:35:19 <merijn> @where tapl
13:35:19 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
13:35:21 <Cale> threestrikes: I dunno, I guess high level?
13:35:29 <merijn> pffft, Cale scooping my suggestions
13:35:34 <RedNifre> Ah, I think it's getting clearer. >>= requires the function to return the result, while <$> does that automatically?
13:35:35 <threestrikes> Ok I'll read up on it and find out, thanks for the suggestion
13:35:38 <Cale> threestrikes: Those terms don't really have precise meanings
13:35:47 <threestrikes> Ok
13:35:54 <blogle> A bit of both, I have seen the write you a scheme and sdiehl llvm stuff... I am interested in trying to build a language with a techincal focus like julia but in a functional paradigm
13:36:36 <merijn> blogle: Anyway, yes, TaPL is the de facto introduction into typesystems, it starts with a very simple lambda calculus and then extends it with more stuff like polymorphism, ADTs, type inference, etc.
13:36:45 <Cale> RedNifre: f <$> x where f :: a -> b and x :: ActionM a will be an action of type ActionM b that when executed will just execute x, getting some result v, and then return (f v)
13:37:00 <merijn> blogle: The code samples are in OCaml, but if you consider yourself an beginner-intermediate haskeller you should be able to read the code no problem
13:37:13 <blogle> Awesome, that sounds like a great start! thanks..
13:37:36 <Cale> RedNifre: So while (>>=) or its flipped over variant (=<<) involve executing two subcomputations, one of which depends on the result of the other, <$> only applies a plain function to the result of a single computation.
13:38:12 <merijn> blogle: Another great read on implementing lazy functional languages is the STG paper, which explains a way to compile haskell to machine code (it's a bit outdated with how GHC does things nowadays, but still interesting)
13:38:23 <Cale> If you've heard about fmap, then (<$>) is the very same thing as fmap
13:38:29 <merijn> blogle: https://research.microsoft.com/apps/pubs/default.aspx?id=67083
13:39:22 <Cale> RedNifre: The effects of x and f <$> x will be the same, only the final result will be different.
13:39:22 <RedNifre> Yes, I think I understand it now.
13:39:43 <Cale> RedNifre: So if all you had was (<$>), you couldn't put together very complicated actions
13:39:59 <Cale> only change the results of actions that you were already given
13:41:38 <RedNifre> So, the original code with v <- liftIO worked, because it applied text.pack to a String and returned an ActionM, which is what is needed in Scotty. And the text.pack =<< liftIO works because it applies text.pack to the String that results from executing the ActionM String, then it returns an ActionM, which is again what is needed for Scotty. So both work.
13:42:53 <blogle> merijn| I think I am going use llvm jit compile, though It looks like there is lots of interesting bits in that paper
13:43:48 <merijn> blogle: That paper talks about the translation of a lazy language to machine code. If you decide that you translate lazy to "llvm asm -> jit compile", the logical steps should still be very similar
13:44:16 <merijn> Because translating to LLVM asm or "real" asm is not very different, from a practical point of view
13:45:13 <vanila> Are there any very simple compilers written in haskell that would be useful to read?
13:45:17 <Cale> RedNifre: Well, I'd just say it *is* an ActionM rather than saying it *returns* one, because that makes it sound like you're talking about the result of executing the action, but yes
13:45:30 * hackagebot yesod-form 1.3.16 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.16 (MichaelSnoyman)
13:46:00 <merijn> vanila: Probably, although I wouldn't really know which. You may wanna look into "Write Yourself a Scheme in 48 Hours"
13:46:07 <RedNifre> I thought "text" is a function call that returns an ActionM. What does it mean when you say it IS an ActionM?
13:46:15 <merijn> blogle: I almost forgot, that tutorial might be interesting for you too
13:46:23 <RedNifre> Or is this just nomenclature as in "length is an Integer"?
13:46:27 <blogle> vanilla: http://www.stephendiehl.com/llvm/
13:46:54 <Cale> Well, text is a function which takes some Text and produces an ActionM action of some sort, so that text (pack v) will itself *be* an ActionM action.
13:47:29 <RedNifre> Would you say that "length [1,2]" is an Int?
13:47:34 <Cale> yes
13:47:35 <merijn> RedNifre: Yes
13:47:36 <blogle> merijn: Thanks, I have been referencing that tutorial in familiarising myself with parsec
13:48:06 <RedNifre> Why wouldn't you say that "length [1,2]" is a function call that returns an Int?
13:48:14 <yukko> hi #emacs is there a nice way to make the tab key just insert spaces up to the next tabstop (I like to use 4-space tabstops) instead of trying to be smart about it
13:48:14 <merijn> RedNifre: The beauty of pure languages is that any expression can be replaced with it's definition, that is an expression *is* it's definition
13:48:21 <Cale> RedNifre: It's not a function at all
13:48:25 <benzrf> RedNifre: we dont talk about calls and returns here
13:48:30 <Cale> RedNifre: because it can't accept another argument
13:48:33 <yukko> uhhh whoops sorry I'm off by one
13:48:34 <benzrf> we talk about application and what expressions evaluate to
13:48:37 * benzrf puts on his smug face
13:48:38 <Cale> length is a function
13:48:42 <Cale> length [1,2] is just an Int
13:48:44 <merijn> RedNifre: Suppose that "length [] = 0; length (x:xs) = 1 + length xs"
13:49:27 <merijn> RedNifre: Since any expression can be replaced with it's result "length [1,2]" -> "1 + length [2]" -> "1 + 1 + length []" -> "1 + 1 + 0" -> "2"
13:49:44 <Cale> In fact, at runtime, there will even be a representation for the unevaluated expression  length [1,2]  which will be used just as any other Int would.
13:49:45 <RedNifre> ah, so (+) is a function, (1+) is a partially applied function and (1+1) is an Int?
13:49:53 <merijn> RedNifre: Correct
13:50:01 <merijn> :t (+)
13:50:02 <lambdabot> Num a => a -> a -> a
13:50:04 <merijn> :t (1+)
13:50:05 <lambdabot> Num a => a -> a
13:50:08 <merijn> :t (1+1)
13:50:08 <lambdabot> Num a => a
13:50:16 <RedNifre> I'm convinced, I like these semantics :)
13:50:45 <dfeuer> WHY AM I HERE?
13:50:51 <Cale> dfeuer: WHY NOT?
13:51:01 <dfeuer> Cale, I should have already gone out swimming :(
13:51:01 <merijn> RedNifre: (+) is a function that takes 1 Int (simplified) and returns "a function that takes one Int and returns one Int"
13:51:25 <Cale> dfeuer: Your laptop will get ruined if you do that!
13:51:39 <merijn> RedNifre: A type "Int -> Int -> Int" can be read as "Int -> (Int -> Int)" (because -> is right associative)
13:51:58 <dfeuer> Also, Cale, I'm trying to fix one of Haskell's oldest newbie-biting minor efficiency issues, but I can't get anyone to help :-/.
13:52:23 <Cale> dfeuer: I'm not sure I can actually help, but I can try
13:52:27 <RedNifre> Yes, I actually... know... that. Though, "know" is a weird word when talking about Haskell. Instead, I read something and then have the raw information in my head, but it somehow takes several days to turn into knowledge.
13:52:27 <merijn> RedNifre: And as I said, in haskell any* expression can always be blindly replaced by it's result
13:52:59 <merijn> RedNifre: the * note there is to indicate the anything that uses "unsafeX" is of course playing a different more dangerous game
13:53:18 <Cale> Yeah, or anything with free variables in it, which is kind of hard to replace sometimes
13:53:22 <RedNifre> I don't know about unsafeX, but I guess I can ignore it for a while, huh?
13:53:33 <Cale> RedNifre: yes
13:53:46 <merijn> RedNifre: There are several unsafe functions which provide escape hatches for when you know what you're doing
13:54:19 <merijn> RedNifre: But, being unsafe, they break the rules and lead to segfaults and despair :)
13:54:35 <Cale> RedNifre: In about 13 years of programming in Haskell, the number of times I've had to use unsafeX functions I can probably count on my hands... maybe even just one hand
13:54:56 <merijn> Cale: That's just because you're not writing fun enough stuff ;)
13:55:31 <merijn> Although, tbh I think I've only ever used it when using the FFI anyway
13:55:32 <hexagoxel> did you never use Debug.Trace? :D
13:55:59 <merijn> hexagoxel: Cale just runs the code in his head to find bugs :)
13:56:40 <Cale> hexagoxel: I have used Debug.Trace.trace, but it's not so much unsafe as output-polluting
13:58:08 <hexagoxel> yep, i recently parsed through 100thousands lines of trace'd output when debugging stuff :/
13:58:09 <RedNifre> Is . the same as $, only with an earlier binding?
13:58:18 <ion> no
13:58:23 <merijn> RedNifre: No, but they frequently go together
13:58:26 <merijn> :t (.)
13:58:27 <lambdabot> (b -> c) -> (a -> b) -> a -> c
13:58:29 <merijn> :t ($)
13:58:30 <lambdabot> (a -> b) -> a -> b
13:58:52 <RedNifre> Is . a subset of $?
13:58:55 <merijn> "f . g = \x -> f (g x)" and "f $ x = f (x)"
13:59:22 <merijn> RedNifre: If you look at the type of (.) you see that it takes two functions as argument
13:59:45 <merijn> RedNifre: One from "b -> c" and one from "a -> b" and it returns a function "a -> c", you get one guess what it does ;)
14:01:12 <RedNifre> Hm, I guess that you could replace every . in stmts like "a . b . c all parameters" with $, but that would be bad style, right?
14:01:30 <RedNifre> Would you say that you should prefer . over $ when possible?
14:01:50 <merijn> RedNifre: . is preferable to $, because you can always move a . pipeline into a local definition (i.e. let/where), but the same does not apply to $
14:03:30 <RedNifre> I guess that my imperative mindset caused a lot of a $ b $ c d e in my code because I thought "first I do c d e, then i take the result and put it into b...". I guess a . b . c d e is a better mindset as in "I want to apply this chain of functions to these things" since it's not imperative and thus a better fit for Haskell...
14:03:45 <merijn> RedNifre: Think of them as shell pipelines :)
14:03:56 <hexagoxel> RedNifre: "all parameters" must be one parameter, though. f g (h x) = f g $ h x = f . g . h $ x
14:04:19 <hexagoxel> but f g (h x y) = f g $ h x y != f . g . h $ x y
14:04:21 <pharpend> @@ RedNifre @type (.).(.)(.).(.).(.).()
14:04:22 <lambdabot>  RedNifre     Couldn't match expected type ‘a -> b1 -> c’ with actual type ‘()’
14:04:22 <lambdabot>     In the second argument of ‘(.)’, namely ‘()’
14:04:22 <lambdabot>     In the second argument of ‘(.)’, namely ‘(.) . ()’
14:04:32 <merijn> "a . b $ c d e" is similar to "c d e | b | a" in something like bash :)
14:04:35 <pharpend> @@ RedNifre @type (.).(.).(.).(.).(.).()
14:04:36 <lambdabot>  RedNifre     Couldn't match expected type ‘a -> b -> c’ with actual type ‘()’
14:04:36 <lambdabot>     In the second argument of ‘(.)’, namely ‘()’
14:04:36 <lambdabot>     In the second argument of ‘(.)’, namely ‘(.) . ()’
14:04:42 <pharpend> @@ RedNifre @type (.).(.).(.).(.).(.).(.)
14:04:43 <lambdabot>  RedNifre (b -> c) -> (a -> a1 -> a2 -> a3 -> a4 -> a5 -> b) -> a -> a1 -> a2 -> a3 -> a4 -> a5 -> c
14:04:47 <RedNifre> Right, that was a syntax error on my part. I already think of $ as reverse pipes, but . is probably a better thing to keep in mind.
14:05:04 <hexagoxel> i prefer ($)
14:05:10 <merijn> RedNifre: Right, but $ is not really a pipe, $ is a tool to force precedence
14:05:31 * hackagebot yesod-test 1.2.6 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-1.2.6 (MichaelSnoyman)
14:05:32 <ion> I’d prefer infixl ($).
14:05:38 <pharpend> RedNifre: >>= is more like the pipe ; $ is "wrap the rest of the line in parentheses"
14:05:45 <merijn> hexagoxel: Like I said, there's a practical argument for (.) and that is that you can always cut out the middle of a (.) pipeline to move into a local definition, you can't do that for ($)
14:05:53 <RedNifre> Sure, me using it as a pipe is a mistake, it's a code smell that indicates that I should use . instead.
14:05:57 <marchelzo_> How do you make a function that can return different types, like (=~) from Text.Regex.Posix?
14:06:01 <pharpend> :t (|)
14:06:02 <lambdabot> parse error on input ‘|’
14:06:10 <merijn> marchelzo_: typeclass voodoo
14:06:11 <pharpend> RedNifre: you could define ipes
14:06:20 <pharpend> @let x | y = y x
14:06:21 <lambdabot>  .L.hs:163:11:
14:06:21 <lambdabot>      Ambiguous occurrence ‘x’
14:06:21 <lambdabot>      It could refer to either ‘L.x’, defined at .L.hs:163:1
14:06:21 <lambdabot>                            or ‘Debug.SimpleReflect.x’,
14:06:21 <lambdabot>                               imported from ‘Debug.SimpleReflect’ at .L.hs:11...
14:06:24 <merijn> pharpend: No, | is a reserved character
14:06:31 <merijn> pharpend: It's not legal as operator
14:06:32 <pharpend> aww
14:06:32 <marchelzo_> merijn: Is it used often, or should I just stay away from it?
14:06:39 <RedNifre> @let x .| y = y x
14:06:41 <lambdabot>  Defined.
14:06:54 <merijn> marchelzo_: It's used occasionally, but it tends to lead to messy and confusing code
14:06:58 <RedNifre> @let echo = show
14:06:59 <lambdabot>  Defined.
14:07:07 <marchelzo_> merijn: ok, thanks
14:07:09 <merijn> marchelzo_: See also how "printf" is defined
14:07:14 <RedNifre> > "hello" .| echo
14:07:16 <lambdabot>  "\"hello\""
14:07:21 <merijn> marchelzo_: https://stackoverflow.com/questions/7828072/how-does-haskell-printf-work#7828634
14:07:23 <marchelzo_> merijn: oh right, I was wondering about that
14:07:24 <marchelzo_> thanks
14:07:34 <RedNifre> > "hello" .| length
14:07:36 <lambdabot>  5
14:07:52 <pharpend> @let pipeTo x y = y x
14:07:56 <lambdabot>  Defined.
14:08:32 <pharpend> "die" `pipeTo` show
14:08:41 <pharpend> >"die" `pipeTo` show
14:08:47 <pharpend> > "die" `pipeTo` show
14:08:48 <lambdabot>  "\"die\""
14:09:06 <pharpend> > "die" `pipeTo` show `pipeTo` show `pipeTo` show
14:09:07 <lambdabot>  "\"\\\"\\\\\\\"die\\\\\\\"\\\"\""
14:09:18 * pharpend cackles
14:09:20 <RedNifre> @let devnull _ = ()
14:09:22 <lambdabot>  Defined.
14:09:28 <RedNifre> "important" .| devnull
14:09:33 <RedNifre> > "important" .| devnull
14:09:35 <lambdabot>  ()
14:09:59 <pharpend> @let dev/null _ ()
14:09:59 <lambdabot>  Parse failed: TemplateHaskell is not enabled
14:10:03 <pharpend> @let dev/null _ = ()
14:10:03 <lambdabot>  Parse failed: Parse error in pattern: null
14:10:14 <pharpend> friggin reserved chrs
14:10:48 <hexagoxel> merijn: and you can directly eta-reduce with (.), true. i see your point.
14:11:12 <benzrf> @let (dev/null) _ = ()
14:11:12 <hexagoxel> but at the cost of an extra level of depth in the syntax tree
14:11:14 <lambdabot>  Defined.
14:11:18 <benzrf> wait crud
14:11:22 <RedNifre> huh?
14:11:38 <merijn> :t (/) -- mystery revealed
14:11:39 <lambdabot>     Ambiguous occurrence ‘/’
14:11:39 <lambdabot>     It could refer to either ‘L./’,
14:11:39 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:174:6
14:11:44 <merijn> hmm
14:11:53 <merijn> :t (L./) -- mystery revealed
14:11:54 <lambdabot> t -> t1 -> t2 -> ()
14:12:00 <merijn> Triple argument operator :)
14:15:10 <DTSCode> hey guys... im trying to build ghc and am getting this error... what do i need to do? ive already installed the gmp library
14:15:10 <DTSCode> checking for path to top of build tree... utils/ghc-pwd/dist-install/build/tmp/ghc-pwd: error while loading shared libraries: libgmp.so.3: cannot open shared object file: No such file or directory
14:16:07 <monochrom> first of all, must you build ghc yourself?
14:16:19 <DTSCode> yes
14:16:25 <Sornaensis> what distro
14:16:30 <DTSCode> fedora
14:16:40 <DTSCode> i tried installing through yum but it wont work
14:16:44 <RedNifre> > isInfixOf "t" "test"
14:16:45 <lambdabot>  True
14:17:07 <merijn> DTSCode: So just download the prebuilt GHC binary?
14:17:30 <merijn> Unless you're hacking on GHC, building ghs is (almost) never the right course of action
14:17:46 <DTSCode> merijn: where is it? sorry... i dont actually write haskell code. im using it for some software
14:17:47 <phaskell> No symbol 'it' found anywhere.
14:18:22 <merijn> DTSCode: http://www.haskell.org/ghc/download_ghc_7_8_3
14:18:41 <merijn> And then go to binary packages
14:18:49 <DTSCode> ty
14:20:44 <monochrom> DTSCode: what you see today is: do not believe in the false dichotomy "from the distro or build from source"
14:21:23 <merijn> Especially since most languages suck at building things from source unless you're developing >.>
14:21:30 <DTSCode> http://www.haskell.org/ghc/download_ghc_7_8_3#x86_64linux
14:21:32 <DTSCode> this one/
14:21:34 <DTSCode> **?
14:21:46 <merijn> I actually <3 how GHC/cabal "just works" when installed as a user
14:21:57 <merijn> DTSCode: Depends, do you have 64 bit or 32 bit linux?
14:22:03 <monochrom> yes if your linux is also x86_64
14:22:10 <DTSCode> yes im 64 bit
14:22:10 <merijn> I tried installing some python packages locally as a user and it was miserable hell :(
14:22:15 <merijn> DTSCode: Then yes
14:22:21 <monochrom> otoh if you pick the wrong one, you will know very soon
14:22:23 <DTSCode> thats the one i got before though
14:22:29 <DTSCode> it wouldnt work
14:22:54 <merijn> DTSCode: No it's not, because before you were trying to compile and this is a prebuilt binary that doesn't need compiling
14:22:55 <ion> dtscode: This may or may not be helpful: <https://gist.github.com/ion1/2815423>. If you don’t plan on developing, you can drop “EXTRA_CONFIGURE_OPTS=-p” and “library-profiling: True” which will make things faster.
14:24:24 <RedNifre> @let greeting = ["hello","world"]
14:24:26 <lambdabot>  Defined.
14:24:47 <RedNifre> @let cat = id
14:24:49 <lambdabot>  Defined.
14:25:02 <RedNifre> @let grep a = filter . (isInfixOf a)
14:25:03 <lambdabot>  .L.hs:170:10:
14:25:03 <lambdabot>      Ambiguous occurrence ‘filter’
14:25:03 <lambdabot>      It could refer to either ‘Data.List.filter’,
14:25:03 <lambdabot>                               imported from ‘Data.List’ at .L.hs:91:1-16
14:25:03 <lambdabot>                               (and originally defined in ‘GHC.List’)
14:25:03 <DTSCode> merijn: yes its the same download. i was apparently mistaken when i thought it was building it, because it uses ./configure; make; sudo make install
14:25:12 <monochrom> DTSCode: under the section you linked to, there are still two options. which one did you say failed?
14:25:21 <DTSCode> the top one
14:25:24 <RedNifre> @let grep a = Data.List.filter . (isInfixOf a)
14:25:25 <lambdabot>  .L.hs:170:30:
14:25:25 <lambdabot>      Couldn't match type ‘Bool’ with ‘a -> Bool’
14:25:25 <lambdabot>      Expected type: [a1] -> a -> Bool
14:25:25 <lambdabot>        Actual type: [a1] -> Bool
14:25:25 <lambdabot>      Relevant bindings include
14:25:40 <Cale> wait, what?
14:25:46 <Cale> Why is there more than one filter in scope?
14:26:00 <RedNifre> @let grep a = GHC.List.filter . (isInfixOf a)
14:26:00 <monochrom> ok, the "deb7" one may be actually more suitable for you, despite "fedora is like centos".
14:26:01 <lambdabot>  .L.hs:170:10:
14:26:01 <lambdabot>      Not in scope: ‘GHC.List.filter’
14:26:01 <lambdabot>      Perhaps you meant ‘Data.List.filter’ (imported from Data.List)
14:26:04 <merijn> RedNifre: Please use ghci/privmsg for playing with lambdabot. Also, the parenthesis around "isInfixOf a" are redundant
14:26:07 <Cale> but yeah, that's a real type error
14:26:34 <Cale> I think he actually doesn't want the (.)
14:26:39 <Cale> the parens can stay
14:26:45 <monochrom> the reality is that centos uses older libs and fedora uses newer libs. therefore fedora is closer to debian than to centos.
14:26:54 <DTSCode> o
14:27:01 <merijn> @let grep = filter . isInfixOf -- this?
14:27:02 <lambdabot>  .L.hs:166:8:
14:27:02 <lambdabot>      Ambiguous occurrence ‘filter’
14:27:02 <lambdabot>      It could refer to either ‘Data.List.filter’,
14:27:02 <lambdabot>                               imported from ‘Data.List’ at .L.hs:91:1-16
14:27:02 <lambdabot>                               (and originally defined in ‘GHC.List’)
14:27:05 <merijn> argh
14:27:08 <merijn> Really?
14:27:12 <RedNifre> hm. Why does lambdabot have different imports than ghci anyways?
14:27:16 <merijn> @let grep = Data.List.filter . isInfixOf -- this?
14:27:17 <Cale> (filter .) . isInfixOf
14:27:18 <lambdabot>  Defined.
14:27:22 <merijn> :t grep
14:27:23 <lambdabot> Eq a => [a] -> [[a]] -> [[a]]
14:27:36 <Cale> er, no
14:27:36 <Cale> :)
14:27:41 <RedNifre> cat greeting .| grep "o"
14:27:46 <RedNifre> > cat greeting .| grep "o"
14:27:48 <lambdabot>  Ambiguous occurrence ‘cat’
14:27:48 <lambdabot>  It could refer to either ‘L.cat’, defined at L.hs:165:1
14:27:48 <lambdabot>                        or ‘Text.PrettyPrint.HughesPJ.cat’,
14:27:48 <lambdabot>                           imported from ‘Text.PrettyPrint.HughesPJ’ at L.hs:1...
14:27:54 <merijn> RedNifre: Why wouldn't it? People use it for lots of things and ghci only imports Prelude which doesn't include a lot
14:28:13 <RedNifre> @let catt = id
14:28:15 <lambdabot>  Defined.
14:28:17 <RedNifre> > catt greeting .| grep "o"
14:28:20 <lambdabot>  ["hello","world"]
14:28:23 <RedNifre> > catt greeting .| grep "he"
14:28:25 <lambdabot>  ["hello"]
14:28:27 <monochrom> RedNifre: the same reason public swimming pools are different from private swimming pools
14:28:37 <Cale> monochrom: haha
14:29:37 <monochrom> for example, one may ask, "why do public swimming pools have more changing rooms than my backyard swimming pool?"
14:30:26 <monochrom> or more kiosks that sell snacks and drinks, for that matter
14:30:48 <ion> or urine
14:31:08 <oakwhiz> why is there more urine in my backyard swimming pool
14:31:27 <monochrom> on the up side, the public ones have more chlorine, too
14:31:40 <monochrom> one may generalize: the public ones have more *ine
14:31:48 <RedNifre> @let response = ["this","is","not","disgusting"]
14:31:50 <lambdabot>  Defined.
14:31:54 <RedNifre> > catt response .| grep "i"
14:31:56 <lambdabot>  ["this","is","disgusting"]
14:32:38 <monochrom> anyway, obHaskell: using shift-reset for yield is simpler than using call/cc for yield. but Oleg already told you so.
14:33:09 <monochrom> I'll have to change my Parsec Generally article to use the simpler shift-reset version.
14:33:29 <ion> > (map concat . sequence) [response, [" "], greeting]
14:33:31 <lambdabot>  Ambiguous occurrence ‘map’
14:33:31 <lambdabot>  It could refer to either ‘GHC.Base.map’,
14:33:31 <lambdabot>                           imported from ‘Data.List’ at L.hs:91:1-16
14:33:31 <lambdabot>                           (and originally defined in ‘base:GHC.Base’)
14:33:31 <lambdabot>                        or ‘Data.Map.Base.map’,
14:33:42 <ion> wat
14:34:09 <monochrom> that's interesting
14:34:25 <DTSCode> thank you monochrom
14:34:37 <monochrom> do you have success?
14:34:45 <DTSCode> i believe so
14:35:00 <merijn> Hold on...
14:35:03 <merijn> Something seems broken
14:35:05 <merijn> @undefine
14:35:06 <lambdabot> Undefined.
14:35:08 <merijn> :t map
14:35:10 <lambdabot> (a -> b) -> [a] -> [b]
14:35:19 <merijn> > (map concat . sequence) [response, [" "], greeting]
14:35:20 <lambdabot>  Not in scope: ‘response’Not in scope: ‘greeting’
14:35:26 <merijn> oh, right
14:35:37 <merijn> Anyway, I think someone snuck a "funny" import into lambdabot
14:35:58 <monochrom> hmm, we can add imports?
14:36:06 <merijn> monochrom: Yes
14:36:10 <monochrom> I guess what I said about public swimming pools
14:36:15 <blogle> lambdabot has become sentient
14:36:32 <merijn> @define import Control.Category
14:36:34 <lambdabot>  .L.hs:155:12:
14:36:34 <lambdabot>      Ambiguous occurrence ‘.’
14:36:34 <lambdabot>      It could refer to either ‘Data.Function..’,
14:36:34 <lambdabot>                               imported from ‘Data.Function’ at .L.hs:86:1-20
14:36:34 <lambdabot>                               (and originally defined in ‘GHC.Base’)
14:37:11 <merijn> I don't understand lambdabot anymore
14:37:53 <merijn> Whoo, writing 500 lines of C++ to test about 900 lines of haskell >.>
14:38:10 <monochrom> I'm going to conjecture that someone is adding imports in PM repeatedly.
14:38:11 <Cale> merijn: Why are you writing C++ code to test Haskell code? :)
14:38:18 <schell> when multiplying lots of numbers together what is faster - Double or Float?
14:38:20 <Cale> @undefine
14:38:20 <lambdabot> Undefined.
14:38:24 <merijn> Cale: Interoperability with existing C++ network library
14:38:30 <merijn> @define import Control.Category
14:38:31 <ion> I have written Haskell code to test C code.
14:38:31 <lambdabot>  .L.hs:155:12:
14:38:31 <lambdabot>      Ambiguous occurrence ‘.’
14:38:31 <lambdabot>      It could refer to either ‘Data.Function..’,
14:38:31 <lambdabot>                               imported from ‘Data.Function’ at .L.hs:86:1-20
14:38:31 <lambdabot>                               (and originally defined in ‘GHC.Base’)
14:38:34 <merijn> hmm
14:38:54 <Cale> I'm pretty sure it ought not to let you import stuff
14:39:04 <Cale> :t (.)
14:39:05 <lambdabot> (b -> c) -> (a -> b) -> a -> c
14:39:16 <merijn> Cale: i.e. I'm still working on my pure haskell amazing ZeroMQ library, but I've reached the point where I need to write boring tests to check whether my haskell does the right thing >.>
14:39:16 <Cale> also, it's @let
14:39:20 <ion> Have you heard about this Haskell thing? It’s a neat DSL for testing your C code using something called the QuickCheck technology.
14:39:51 <Cale> merijn: y u no quickcheck?
14:40:01 <monochrom> writing C bindings for C++ object methods is a very boilerplating task :)
14:40:22 <merijn> Cale: How do you quickcheck operational semantics are equal between two libraries using quickcheck?
14:40:34 <merijn> Especially when one of the two is a C++ library...
14:40:55 <exio4> sometimes I feel like the "haskell solution" for everything, is a DSL!
14:41:03 <merijn> Cale: Like, at some point I need to check the protocol I'm parsing matches what the C++ code is sending
14:41:15 <Cale> ah, okay
14:41:31 <merijn> Cale: And whether different authentication schemes match
14:42:06 <merijn> Anyway, like most of this code is 1) parsing or 2) IO or 3) concurrent, none of which is really conducive to quickcheck testing
14:43:01 <monochrom> parsing is fairly conducive to quickchecking. unless the parser insists on IO
14:43:40 <merijn> monochrom: Sure, but if I need to check against an existing implementation I may as well check the parsing as I test everything else :)
14:43:50 <monochrom> what do your tests to? how do they judge "pass" vs "fail"?
14:44:11 <monochrom> s/to?/do?/
14:45:37 <merijn> Right now they just do "attempt to connect with different auth schemes, send messages across and check if received messages match expected"
14:45:39 <monochrom> I guess, if the testee sends out stuff to the network, your tester sits on the network to read stuff
14:46:29 <merijn> I basically spawn two (or more) processes, some C++, some haskell and verify all messages appear in some sensible manner
14:46:50 <augur> so does anyone know how to define mostly-homomorphic functions without a lot of boilerplate?
14:48:09 <augur> by that i mean, you have a datatype T which has a whole bunch of recursive constructors
14:48:24 <augur> and you need to define a function f which is almost a homomorphism
14:48:41 <augur> so for most T constructors C, f works like   f (C x) = C (f x)
14:48:50 <merijn> monochrom: tbh, I'm fairly confident in the haskell code's semantics, the things I worry about are interoperability and async exception safety of the haskell code. But I think the latter is more likely to be found/solved by careful repeated audits than by testing
14:48:53 <augur> but for a few constructors C', f works differently
14:49:21 <vanila> augur, Idea: Folds that take a record - filled in with identity functions to start with but you can add new functions for only the C' you care about
14:49:46 <augur> vanila: hmm
14:49:54 <augur> thats an idea
14:50:56 <augur> i feel like there should be a more principled approach tho
14:51:25 <augur> i think with dependent types you can probably do it via a Desc approach by casing on the constructor name,
14:51:32 <augur> but that obviously wont work for haskell
14:53:26 <augur> hm. maybe another alternative would be to define some kind of map-like function for the type that implements homomorphic actions
14:53:33 <diegoviola> hi
14:54:08 <augur> so that if you define this:   f x = homomorphically f x   then that's equivalent to the full homomorphism
14:55:14 <linman32> :k Ord
14:55:15 <lambdabot> * -> Constraint
14:55:17 <augur> hmmm
14:55:24 <linman32> :t Int
14:55:25 <lambdabot>     Not in scope: data constructor ‘Int’
14:55:26 <lambdabot>     Perhaps you meant one of these:
14:55:26 <lambdabot>       ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
14:55:33 <linman32> :t 3
14:55:35 <lambdabot> Num a => a
14:59:44 <augur> i mean, technically, "homomorphically" is the fmap for the functor that the type is defined via, right..
15:00:18 <augur> if   T = Mu f   then homomorphically = fmap :: (a -> b) -> f a -> f b
15:05:36 * hackagebot shell-conduit 0.1 - Write shell scripts with Conduit  http://hackage.haskell.org/package/shell-conduit-0.1 (ChrisDone)
15:08:09 <augur> thank you vanila, that set me on the right course :)
15:08:58 <augur> i can feel a tutorial coming out of this
15:13:03 <vanila> augur, that'd be nice to read!
15:13:57 <augur> vanila: the `homomorphically` thing works rather directly. i want to figure out how to make it work with applicatives tho, so ill write something up once i get that done
15:15:31 <vanila> Any chance of casting it in terms of lens? Maybe that isn't a natural fit though
15:15:59 <augur> no i wont touch lens :p
15:16:45 * edwardk tunes in, arches an eyebrow and shrugs.
15:17:09 <augur> the totality of lens is just too hard for me to understand
15:17:37 <augur> and i dont know if its going to help much for this
15:18:57 <augur> hm. i think homomorphically is a special case of case
15:19:06 <augur> actually it ought to be
15:24:35 <schell> oh man - i just ran into an interesting error message
15:24:38 <schell> “My brain just exploded I can't handle pattern bindings for existential or GADT data constructors.”
15:24:55 <schell> what i wrote in my code that caused it was a typo, but still
15:25:02 <ion> heh
15:25:11 <Piscen> Very fun
15:26:37 <tabemann_> they should have made that error message "cannot let or where-bind existential or GADT data constructors, use case instead"
15:27:14 <edwardk> tabemann_: yes, but the bemusement caused by the current error message is almost worth it =)
15:27:19 <tabemann_> yes
15:29:10 <pjdelport> @quote brain.*exploded
15:29:10 <lambdabot> ChrisOkasaki says: It happened around midnight, when I was quite exhausted already. I typed ":r", read the first line of the message "My brain just exploded." and said, "Yeah, tell me about it...". And then I jumped off the chair, having realized what I've been talking with.
15:29:18 <vanila> edwardk, I was wondering about Lens, glguy showed me how to implement failover and with that I get safeNth. I use nothing crazy (no profunctors) just Lens s t a b and Traverse, am I missing something?
15:29:41 <edwardk> vanila: so you're saying you mostly just use the vanila lenses? =)
15:29:57 <vanila> hehe
15:30:11 <edwardk> vanila: the next main candidate to play with for you might be prisms
15:30:13 <hpc> pjdelport: is there context for that quote i am missing?
15:30:19 <vanila> ok sounds great!
15:30:27 <edwardk> vanila: they come up a fair bit once you start looking for them
15:30:29 <vanila> I have no idea what that is yet
15:30:37 <pjdelport> hpc: Just what schell just said. :)
15:30:44 <edwardk> a lens lets you look at part of a product-like structure
15:30:50 <edwardk> e.g. one field in a record
15:30:58 <edwardk> a prism lets you look at part of a sum-like structure
15:31:08 <edwardk> e.g. one constructor in an ADT
15:31:34 <hpc> doh, ghc
15:31:54 <monochrom> @pl \k -> comp1 (\f -> comp2 (\x -> k (f x)))
15:31:54 <lambdabot> comp1 . (comp2 .) . (.)
15:31:58 <monochrom> haha
15:32:07 <monochrom> (that's <*> for ContT)
15:32:32 <schell> btw - does anyone have an ear clipping algorithm on hand that they like?
15:32:39 <monochrom> wow, it's so short that it's very tempting
15:32:40 <edwardk> vanila: you can get from a lens, view l :: s -> a, you can inject into a prism review p :: b -> t, you can set the result of lens set l :: s -> b -> t, you can pattern match on a prism :: s -> Either a t
15:32:50 <diegoviola> do you need to have a strong mathemathics background to fully grasp the way haskell and other functional languages work?
15:32:55 <edwardk> vanila: every Iso can be used as both a lens and a prism
15:33:03 <edwardk> diegoviola: no
15:33:05 <tabemann_> diegovanila: no
15:33:09 <vanila> that's fascinating
15:33:21 <tabemann_> *vioaa
15:33:26 <tabemann_> *viola
15:33:28 <monochrom> diegoviola: not strong math background. but weak math background. see my http://www.vex.net/~trebla/haskell/prerequisite.xhtml
15:33:42 <edwardk> vanila: and you can use the prism as a traversal of the case that it would match
15:33:44 <diegoviola> thanks, i'll look into haskell
15:34:11 <diegoviola> I'm a Ruby dev
15:34:13 <tabemann_> you don't need to know category theory to be able to work in Haskell
15:34:47 <vanila> I never thought of looking into a version of lens for sums!
15:34:52 <pjdelport> diegoviola: You definitely don't need a maths background to use Haskell; but Haskell's type system is strong enough that it will often let you put whatever maths you *do* learn to much greater use than in other languages.
15:35:32 <pjdelport> Haskell itself is a just a tool.
15:35:55 <pjdelport> diegoviola: Dive into a tutorial, and see if you have fun learning it! :)
15:36:04 <tabemann_> Haskell is just a general-purpose programming language
15:36:15 <diegoviola> pjdelport: will do, thanks
15:36:39 <tabemann_> @where lyah
15:36:39 <lambdabot> http://www.learnyouahaskell.com/
15:37:13 <tabemann_> after that, read:
15:37:16 <tabemann_> @where rwh
15:37:16 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
15:38:51 <edwardk> vanila: the work on hask has exposed that this works for other monoidal categories, e.g. i can build lenses into monad transformer stacks or lenses into towers of functors, into applicatives, etc.
15:39:25 <tabemann_> note that lyah teaches you functional programming from the beginning, whereas rwh basically assumes you already know a reasonable amount of Haskell
15:41:08 <javed> do u lot recommend python 2 or 3 for begginers ?
15:41:28 <tabemann_> we recommend Haskell for beginners
15:42:22 <tabemann_> that way you won't learn the design mistakes commonly associated with imperative programming
15:42:26 <beckyconning> we recommend Haskell for everyone
15:43:27 <beckyconning> how can i make a version of timeout: https://hackage.haskell.org/package/base-4.1.0.0/docs/System-Timeout.html that waits for the timeout to bind with justs as well as with nothings?
15:43:39 <monochrom> I recommend python 100, but that's isomorphic to haskell
15:43:39 <beckyconning> that probably doesn't make much sense because i am very sleepy : P
15:45:09 <monochrom> what is the desired type of your desired version of timeout?
15:45:39 * hackagebot unix-memory 0.1.2 - Unix memory syscalls  http://hackage.haskell.org/package/unix-memory-0.1.2 (VincentHanquez)
15:49:52 <tabemann_> well timeout is Int -> IO a -> IO a, and the only real disagreement I see on its design is just what Int signifies or whether one wants to use a different type for time
15:50:44 <tabemann_> okay, gonna get going now
15:56:34 <RedNifre> What's the proper way to use a simple variable in a do block? I'm currently doing someString <- return "bla", but the return seems weird. Is there a better way? Or is it impossible because every line has to be an action of the Monad associated with the do block?
15:56:52 <exio4> using let?
15:56:57 <exio4> let someString = "bla"
15:57:28 <RedNifre> Okay, that didn't work when I tried it, but maybe it failed because of something else in my code at that time. Lets see...
15:59:17 <RedNifre> Is there a logical explanation for why you can use a let statement in a do block, or is that just syntactic sugar and the compiler moves it at the outside of the do block? Or how does this work?
16:00:39 <geekosaur> why would it be moved?
16:01:01 <geekosaur> "let" is an expression, it can be used anywhere. there is syntactic sugar that makes the expression look like a statement
16:01:23 <hexagoxel> "let a = b; stmts" is like a single non-do statement "let a = b in do stmts"
16:01:34 <RedNifre> I thought that every line in a do block is an action of the specific Monad associated with that block.
16:01:45 <geekosaur> but it doesn't move it or significantly alter it, just makes it fit more into the procedural-think that goes with do syntax
16:02:32 <RedNifre> hm, so let works in do, because it sort of attaches to the actions instead of being part of the action chain?
16:02:33 <geekosaur> it is. that's everything following "in" in "let ... in", and the "statement let" uses that to pretend to be a statement
16:03:02 <geekosaur> it's part of the action chain. the thing is that bindings are neither actions nor direct expressions in the chain; you could think of them as ornaments
16:03:09 <geekosaur> whats part of the chain follows "in"
16:03:25 <hexagoxel> (or, more precise: "do let a = b; stmts" is "let a = b in do stmts")
16:03:28 <RedNifre> That's what I meant by "attaches to".
16:03:31 <geekosaur> what comes between "let" and "in" are bindings that can be used in the expression after "in"
16:04:40 <RedNifre> so does the compiler turn "do stmt ; let a = b ; stmt2 ; let c = d" into "let a = b, c = d in do stmt; stmt2"?
16:04:57 <hexagoxel> RedNifre: http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
16:05:51 <hexagoxel> better point you to the source than trying to rephrase it :)
16:06:36 <RedNifre> thank you
16:06:45 <RedNifre> But what is the empty statement for?
16:07:56 <hexagoxel> because layouting may add additional ";"s, iirc
16:08:34 <hexagoxel> and if you add ; manually, and layouting adds another, you need empty's
16:09:39 <hexagoxel> (by "layouting" i mean the process where indentation is used for syntax, and the corresponding translation)
16:11:38 <augur> is there an applicative lifting of fmap?
16:11:55 <hiptobecubic> <*> ?
16:12:41 <hiptobecubic> I didn't really think about that answer, it just seemed good
16:12:51 <hiptobecubic> So you know...
16:12:59 <augur> no no i mean like... fmapA :: (a -> f b) -> g a -> f (g b)
16:13:11 <augur> that looks like something related to traversable, actually
16:13:37 <augur> :t traverse
16:13:38 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
16:13:46 <augur> aha!
16:13:47 <hiptobecubic> :)
16:14:01 <augur> having just had to reinvent traverse, i now understand it! :o
16:15:16 <augur> yet again, i find myself properly understanding things thanks to genericization of data types
16:15:19 <augur> goodness
16:16:40 <exio4> "I don't understand something, lets abstract this and it'll become easier"
16:16:49 <augur> :)
16:17:06 <augur> less so much about abstraction and more about breaking down an idea into smaller more visible parts
16:17:09 <Axman6> hmm, what dose traverse with [] do?
16:17:38 <augur> Axman6: i think the general pattern is that traverse is just map but functorially
16:17:40 <shachaf> Same as mapM
16:17:41 <cdk> > traverse Identity [] -- Axman6: try it :)
16:17:44 <Axman6> gives you a list of all possible combinations of the answers provided in the a -> [b] function for all a's in the t a?
16:17:45 <lambdabot>  Identity {runIdentity = []}
16:17:54 <augur> Axman6: or rather, applicatively?
16:17:57 <Axman6> um I meant with f = []
16:18:12 <augur> traverse f [] = pure []
16:18:30 <augur> traverse f (x:xs) = (:) <$> x <*> traverse f xs
16:18:33 <augur> or something like that
16:18:34 <Axman6> > traverse (\x -> [x,x+1]) (Just 7)
16:18:36 <lambdabot>  [Just 7,Just 8]
16:18:38 <augur> f x rather
16:18:50 <Axman6> > traverse (\x -> [x,x+1]) [1..4]
16:18:53 <lambdabot>  [[1,2,3,4],[1,2,3,5],[1,2,4,4],[1,2,4,5],[1,3,3,4],[1,3,3,5],[1,3,4,4],[1,3,...
16:19:01 <Axman6> fun!
16:19:20 <augur> i like generalizations of patterns like that
16:19:31 <Axman6> :t Tree
16:19:32 <lambdabot>     Not in scope: data constructor ‘Tree’
16:19:33 <lambdabot>     Perhaps you meant ‘True’ (imported from Data.Bool)
16:19:38 <augur> basically taking (id,($)) to (pure,(<*>))
16:19:44 <Axman6> hmm, do we have a tree constructor of any kind in lambdabot?
16:20:13 <Axman6> :t Node
16:20:14 <lambdabot> a -> Forest a -> Tree a
16:20:20 <Axman6> that's the one
16:20:22 <hiptobecubic> :t Forest
16:20:22 <lambdabot>     Not in scope: data constructor ‘Forest’
16:20:23 <lambdabot>     Perhaps you meant one of these:
16:20:23 <lambdabot>       ‘First’ (imported from Data.Monoid),
16:21:21 <Axman6> > traverse (\x -> [x,x+1]) $ Node 2 [Node 3 [], Node 4 [], Node 5 [Node 6 [], Node 7 []]]
16:21:23 <lambdabot>  [Node {rootLabel = 2, subForest = [Node {rootLabel = 3, subForest = []},Node...
16:21:40 <Axman6> bah, too verbose
16:22:13 <Axman6> but I think I get it. that could be super useful
16:40:44 * hackagebot cld2 0.1.0.1 - Haskell bindings to Google's Compact Language Detector 2  http://hackage.haskell.org/package/cld2-0.1.0.1 (dfranke)
16:47:24 <dfranke> edwardk: I'm going to be putting your hyphenation package to use soon.
16:47:40 <edwardk> dfranke: great! =)
16:48:06 <edwardk> dfranke: i do need to update a few of the hyphenation files, there have been a few updates from the tex-utf8 folks
16:48:31 <dfranke> edwardk: I'm writing a text filter (and maybe later an Apache module) to insert soft hyphens into HTML documents.
16:48:59 <edwardk> makes sense. english mostly or any language?
16:49:21 <dfranke> any language. Hence my release of CLD2 bindings a few minutes ago :-)
16:49:36 <edwardk> ah fair
17:07:47 <augur> so why does traversable have a Foldable constraint on it?
17:09:05 <geekosaur> http://www.haskell.org/haskellwiki/Typeclassopedia#Definition_7
17:36:46 <kvanb> say I have a buffer with some size
17:36:56 <kvanb> and I have functions in some monad that write into the buffer
17:37:16 <kvanb> I don't want each function to check the size of the buffer for overflow
17:37:26 <kvanb> I want multiple invocations to batch together. Is there some idiom for this
17:38:17 <athan> is there any way to throw compiler warnings?
17:38:41 <kvanb> athan: template haskell maybe
17:38:56 <kvanb> maybe not
17:39:24 <oooooo> kvanb: you could express the length in the type
17:39:33 <merijn> athan: Yes, there's a warning and deprecate pragma
17:39:40 <dfranke> kvanb: you can look and see if the RULES pragma does what you want it to.
17:39:40 <athan> kvanb: like through parsec? :S
17:39:50 <athan> merijn: Awesome! Thank you!!
17:39:58 <merijn> athan: Although this only works for exported functions and are only shown when someone else links against your function
17:40:25 <athan> merijn: That's the exact use case I need :)
17:40:36 <oooooo> kvanb: This shows how to do so for vectors http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue5/Number_Param_Types
17:40:41 <merijn> athan: Right, consult ghc manual on pragma's for details
17:40:51 <merijn> athan: See Control.Concurrent.Chan for an example
17:40:57 <merijn> (unGetChan/isEmpty)
17:41:14 <athan> merijn: Thank you so much :)
17:42:12 <kvanb> oooooo: thanks
17:42:33 <kvanb> dfranke: problem with RULES is it's hard to fire them off if you put extra stuff inbetween
17:42:41 <kvanb> liike a monad transformer bind
17:46:11 <kvanb> I get how this is going to work
17:46:21 <kvanb> it's just a little bit, hnng, hard. I don't understand how to express it as haskell
17:47:35 <merijn> kvanb: Do the write lengths/buffer sizes depend on external data? (i.e. network, disk, user input, etc.) or not?
17:47:39 <kvanb> I know that the result of a particular monad has to be (length, computation) where length is the number of bytes which would have been written into the buffer and computation is the part to be executed to actually do it.
17:47:45 <kvanb> not the lengths, no
17:47:47 <kvanb> it's an assembler
17:48:24 <merijn> kvanb: Right, if the lengths are all fixed at compile time then you can possibly do neat tricks, but I'll have to reboot before I can give you a pointer :)
17:48:32 <kvanb> ok
17:56:09 <Crockeo> Hey guys on my laptop I'm facing a problem with accidentally linking x32 libraries.
17:56:31 <Crockeo> I've reinstalled the Haskell Platform and cleaned out my .cabal and .ghc files, so I don't really know what's up.
18:01:59 <kvanb> merijn: so the way I've decided to do it, I don't think I even need to encode lengths in the type
18:02:42 <merijn> kvanb: Ah, I was just gonna link you this: https://gist.github.com/merijn/39dc86e345e87276c523
18:02:56 <kvanb> it will just require having the things that write to a buffer in a different type and then somehow, but I'm not sure how, I need to know their length *before* I execute them, to check
18:03:03 <merijn> kvanb: That's a list with length encoded in type, but the same kinda constraint approach works for other things
18:03:03 <kvanb> Im not sure if thats even possible. I might need types for this
18:04:18 <merijn> kvanb: You could have a buffer with a length and then have "writeToBuffer :: LessThan x y => WriteLength x -> Buffer y -> Buffer (Min y x)" style thing
18:05:02 <kvanb> The buffers are a runtime thing, and they're too huge to encode, so I *must* do a runtime check for every group of writes
18:05:15 <merijn> That would give a type error for every write exceeding buffer length, but requires all writes to be off known length and not depend on user input. Well, you can actually depend on user input, but then it becomes really nasty
18:05:28 <kvanb> Buffer might be size 4kib, write length maybe only like 5
18:05:29 * Fuuzetsu whispers ‘dependent types’
18:05:44 <merijn> Fuuzetsu: Yes, but haskell doesn't have those yet... :p
18:05:46 <Fuuzetsu> yet!
18:05:54 <Fuuzetsu> although there are some which like to argue otherwise
18:06:08 <merijn> I, too, saw Stephanie's ICFP talk :p
18:06:23 <kvanb> merijn: is there any way to know the lenght of a computations write
18:06:25 <Fuuzetsu> I have not however so I promptly will look for the title
18:06:27 <kvanb> before actually executing it
18:07:12 <Fuuzetsu> 60 mins damn
18:07:59 <merijn> kvanb: You could have a list of writes, and have the write length of that be the sum of all write operations, but that requires a bit more type hackery
18:08:36 <merijn> kvanb: My gists have a few more examples of type abuse for things like this, but I don't understand sufficiently what you want to do and am about to leave for social stuff :)
18:08:53 <kvanb> ok, thanks and have fun
18:09:01 <merijn> kvanb: Recommended reading if you wanna do type level hackery like this is the wikibook GADT chapter and then "Fun with Type Functions" paper
18:09:25 <merijn> Also, the DataKinds extension, but I dunno about a good intro for that off the top of my head.
18:11:16 <gamegoblin> Trying to make a class like ` class Game a b => Evaluate a where ` but I am getting a "type variable b not in scope". Ideas?
18:11:32 <gamegoblin> b is never used in any of the member functions
18:11:42 <gamegoblin> so it can be anything. Can a forall fix this, or what?
18:12:44 <merijn> gamegoblin: If b is never used, how can GHC ever infer which instance of Game it should use?
18:12:57 <gamegoblin> a -> b functional dependency
18:13:39 <merijn> My guess is that this really shouldn't be a typeclass anyway
18:13:39 <gamegoblin> `Game` looks like `class Game a b | a -> b where`
18:14:31 <merijn> I recommend the following two blog articles and see if you still think you need a typeclass after reading them
18:14:35 <merijn> @where existential-antipattern
18:14:36 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
18:14:47 <merijn> @google Gabriel Gonzalez Scrap Your Typeclasses
18:14:48 <lambdabot> http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
18:14:48 <lambdabot> Title: Haskell for all: Scrap your type classes
18:15:23 <merijn> gamegoblin: Most cases where people use typeclasses are usually better solved using polymorphic records
18:15:39 <gamegoblin> What do you mean by polymorphic records?
18:16:37 <merijn> A record type with polymorphic fields, see those two blog posts, both of them contain examples of what I mean
18:19:02 <Fuuzetsu> I think in order to have dependent types the biggest hurdle is that we use :: instead of :
18:20:51 * hackagebot ply-loader 0.4 - PLY file loader.  http://hackage.haskell.org/package/ply-loader-0.4 (AnthonyCowley)
18:20:52 <oooooo> Fuuzetsu: ?
18:21:04 <Fuuzetsu> I kid
18:21:06 <Fuuzetsu> (mostly)
18:22:59 <Forkk> Lenses are the best thing ever
18:23:05 <Forkk> My readability <3
18:23:44 <Forkk> Changing "modify $ \s -> s { usNetCtls = M.insert (inName net) hand $ usNetCtls s }" to "usNetCtls %= M.insert (inName net) hand"
18:25:38 <pavonia> :t (%=)
18:25:42 <lambdabot> (MonadState s m, Profunctor p) => Setting p s s a b -> p a b -> m ()
18:25:52 * hackagebot repline 0.1.0.0 -   http://hackage.haskell.org/package/repline-0.1.0.0 (sdiehl)
18:26:01 <merijn> lens type signatures really don't help much :)
18:26:16 <pavonia> yeah
18:26:16 <Fuuzetsu> they really don't
18:26:26 <Fuuzetsu> maybe if GHC refined to type aliases
18:26:40 <Fuuzetsu> it could at least make some effort
18:27:02 <Forkk> yeah
18:27:16 <Forkk> pavonia, %= applies a function to the value the lens points to
18:27:38 <Forkk> so, if my lens points to a map, %= M.insert key val will insert the given key and value
18:28:03 <Forkk> (it works inside the state monad)
18:28:04 <merijn> The lens docs have a table of operators, that's way more readable
18:28:09 <Forkk> yeah
18:28:38 <Forkk> also, you can quite simply infer what most of the operators do based on their names
18:28:52 <Forkk> the = means it runs in the state monad and the % means it applies a function to the lens's value
18:34:47 <Forkk> ccPendingConns %= filter (/=thread)
18:34:48 <Forkk> <3
18:46:51 <nisstyre> -ddump-minimal-imports is really useful if you have a file someone else wrote and you want to know what they used from an imported module
18:51:43 <luite> does anyone have a style for hindent that's less linebreaky than chris-done?
19:00:06 <benjo11111> what can be done with haskell ?
19:00:20 <sipa> almost everything :)
19:00:44 <benjo11111> i m new with it, till date i m using perl for my system admin related tasks like log processing, monitoring, backup/recovery , vm managing and many more
19:01:31 <benjo11111> <sipa> is there any link or document from where i can grab os related examples, specially for sys admin stuff ?
19:03:22 <peddie> benjo11111: you could investigate the 'shelly' package: http://hackage.haskell.org/package/shelly
19:11:46 <benzrf> bye
19:12:07 <silver> bye
19:14:54 <t011> Hi, I'm trying to figure out a problem I'm having with adding sources to a cabal sandbox.
19:15:39 <t011> The command I'm using is 'cabal sandbox add-source --snapshot pandoc-1.13.1/'
19:16:27 <t011> But this fails with an error.
19:19:21 <tabemann_> question: does Network.Socket.recv use the IO manager or not?
19:21:25 <geekosaur> looks like it FFIs to the libc one
19:21:31 <geekosaur> so, no
19:22:12 <tabemann_> was just reading the source, so yeah, no
19:23:04 <tabemann_> I ask because I just read something claiming that Network.Socket.accept used the IO manager
19:23:37 <tabemann_> I think it was the documentation for timeout
19:24:29 <solirc> How can I get GHCi to load some cbits.dyn_o?
19:24:57 <tabemann_> hmm I wonder if it'd be possible to rewrite Network.Socket to actually use the IO manager
19:24:58 <solirc> e.g. if I do `ghci dist/build/src/cbits.o src/Main.hs` it will attempt to load that object file.
19:25:00 <geekosaur> actually it's harder than that since it uses threadWaitRead internally, so that sounds like it's invoking the IO manager
19:25:35 <geekosaur> scroll up in the source and it names some functions that don't use threadWait{Read,Write} and therefore skip the I/O manager
19:25:46 <math066> hello is anyone online?
19:26:03 <simpson> math066: Sure!
19:26:06 <math066> I would like some basic help in learning about programming logic
19:26:15 <math066> structure specifically....
19:26:35 <math066> My professor gave me this for homework to debug: http://imgur.com/Sc3ooHN
19:26:48 <math066> And my solution(?) is this http://imgur.com/MZyKDgT
19:26:52 <solirc> but if I do `ghci dist/build/src/cbits.dyn_o src/Main.hs` GHCi complains with `Warning: ignoring unrecognised input `dist/build/src/cbits.dyn_o'`
19:27:20 <math066> I apologize if this is not even close to what haskell is about but I just really need the help >.<
19:27:27 <tabemann_> I see a throwSocketErrorWaitRead in recv
19:27:42 <tabemann_> is that using the IO manger?
19:27:46 <geekosaur> yes. look in Network.Socket.Internal
19:27:53 <simpson> math066: This doesn't look like Haskell. Does your professor have a TA?
19:28:10 <geekosaur> I dug around and found the Read, Write versions of ther throwSocket* functions use threadWaitRead and threadWaitWrite
19:28:11 <math066> I don't think so
19:28:20 <geekosaur> which invoke the I/O manager to wait for the fd to be ready
19:28:31 <math066> It's just supposed to be pseudocode for now
19:29:45 <tabemann_> geekosaur: I'm relieved that recv uses the window manager because I've got some code in which I try to cancel a thread doing a recv
19:30:13 <simpson> math066: Your professor should be providing some sort of assistance to students, either through a TA or through office hours.
19:30:20 <chirpsalot> "Because of this dependence on the local environment, toCalendarTime is in the IO monad." Doesn't "show" for ClockTime do a similar thing?
19:30:29 <tabemann_> s/window/IO
19:31:25 <tabemann_> does show depend on the locale though?
19:31:45 <chirpsalot> tabemann_: seems to print with my timezone and everything?
19:32:15 <chirpsalot> I guess it's just out of convenience, because you can't put show in IO?
19:32:20 <uf> how else would it know
19:32:22 <tabemann_> yes, but that doesn't mean it is using one's locale
19:32:28 <geekosaur> old-time is deprecated...
19:32:53 <chirpsalot> geekosaur: oh? Should I be using something else?
19:33:11 <geekosaur> the modern Data.Time, which has been around for several years?
19:33:14 <chirpsalot> Oh!
19:33:24 <chirpsalot> My bad, missed that.
19:33:27 <geekosaur> and, to prove that it should have been deprecated... that Show instance you mentioned uses unsafePerformIO
19:34:01 <geekosaur> showsPrec _ t = showString (calendarTimeToString (unsafePerformIO (toCalendarTime t)))
19:34:18 <chirpsalot> geekosaur: yep :).
19:34:46 <chirpsalot> geekosaur: that's why I was confused. Didn't see the note that it was deprecated in the haddock.
19:34:47 * geekosaur feels kinda dirty now...
19:35:13 <silver> hehj
19:40:59 <Guest17415> In LYAH in the chapter on Applicatives it says "by using zip lists with applicative style we don't need to have separate zip functions for each number of lists that we want to zip together".  I don't understand then why getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [-3, 4, 1] <*> ZipList [0,0,0] doesn't work since here I have 3 that I want to zip together with (+)
19:42:01 <exio4> @pl \x y z-> f x (f y z)
19:42:01 <lambdabot> (. f) . (.) . f
19:42:02 <byorgey> Guest17415: because (+) only takes 2 arguments
19:42:16 <exio4> @pl \x y z-> f (f x y) z
19:42:16 <lambdabot> (f .) . f
19:42:24 <byorgey> Guest17415: you could use  (\x y z -> x + y + z)  instead
19:43:15 <geekosaur> exio4, have some examples of when not to try to be pointfree :)
19:43:42 <shachaf> "\x y -> f x . f y" is quite reasonable.
19:43:48 <Guest17415> byorgey: yeah I know, The section in the book had just finished describing how there were zipWith3 and zipWith4 functions and these were not necessary in applicative style
19:44:14 <Guest17415> oh I see!
19:44:44 <Guest17415> * no I don't. Still confused
19:45:08 <shachaf> Guest17415: You have the same issue with the simpler expression ((+) 1 2 3)
19:45:34 <shachaf> Since what you wrote turns into [(+) 1 (-3) 0, (+) 2 4 0, (+) 3 1 0]
19:45:40 <augur> vanila: btw, this is the core of what im aiming at:   http://lpaste.net/111356
19:45:48 <shachaf> But that's a type error because ((+) x y) isn't a function (usually).
19:46:05 <geekosaur> you can use as many ziplists as you want, provided you have a reasonable way to combine them. (+) can only combine two, it's not like Lisp and can only handle two values
19:46:06 <Guest17415> I guess I am reading too much into that section of the book. I thought there was some magic going on
19:46:19 <geekosaur> there is magic but not at that point
19:46:28 <shachaf> Guest17415: All the book is getting at is that you don't need to define a function called zipWith5
19:46:44 <shachaf> Since you can just write f <$> a <*> b <*> c <*> d <*> e
19:46:59 <shachaf> (+) is not related to this magic.
19:47:05 <shachaf> (There's no magic, really.)
19:48:44 <augur> vanila: oh actually i should make recursivelyA more generic, woops
19:48:52 <Guest17415> is there a simple example showing off the magic. At the moment my naivety only shows m that it's a way to use a normal function on values of types with Applicative type classes. Sorry for being so dumb
19:49:15 <shachaf> There's no magic.
19:49:51 <Guest17415> and a way to use less ugly brackets
19:49:56 <Guest17415> fewer
19:50:02 <pjdelport> Guest17415: That's exactly what Applicative is: it's function applicatino lifted to the level of Functor values.
19:50:13 <pjdelport> function application, even
19:50:23 <Guest17415> cool. I might be understanding something then
19:50:51 <pjdelport> Guest17415: Sounds like the right intuition, yes. :)
19:51:45 <pjdelport> And yes, there isn't any magic: each Applicative instance just needs to provide pure and <*> implementations that work as expected, and obey the laws (i.e., they're structure-preserving)
19:52:29 <augur> vanila: ok, updated it to do what i meant :p
19:53:08 <Guest17415> great. thanks for the help. I'll head back to the book
19:53:46 <vanila> augur, ah let me take a look!
19:54:34 <shachaf> pjdelport: What does it mean that they're structure-preserving?
19:54:37 <dfeuer> WTF? GHCi just quit on me with a floating point exception. There were no floating point numbers anywhere!
19:54:51 <dfeuer> None!
19:54:56 <dfeuer> WTF?
19:54:56 <pjdelport> shachaf: In roughly the same sense that fmap is structure-preserving.
19:55:49 <vanila> augur, That is very elegant, nice one
19:57:30 <augur> vanila: it'd be nicer if the patterns could be derivable automatically
20:02:40 <dfeuer> OK, I now understand the arithmetic exception in one function, but not where the BLEEP the floating point exception came from.
20:02:52 <dfeuer> Because there *was* *no* *floating point*.
20:03:32 <dfeuer> This entire bloody thing is Ints. None of the functions even support floating point.
20:04:14 <shachaf> You should look up what a floating point exception is.
20:07:20 <shachaf> It's like saying "I got a segmentation fault? But I'm using x86_64, which doesn't even have segmentation!"
20:09:33 <eazar001> dfeuer: maybe, try making some of your type signatures more explicit?
20:09:58 <t011> Hi, does the --snapshot flag not work properly with cabal sandbox add-source?
20:10:00 <eazar001> you maybe inducing some sort of side-effect
20:12:15 <dfeuer> shachaf, I'm writing an alternative version of divMod. It does (as far as I can tell) pretty much exactly the same arithmetic as GHC's. But GHC's gives an arithmetic exception when dividing minBound by -1 and mine gives a floating point exception when that happens and GHCi crashes.
20:13:07 <dfeuer> eazar001, my type signatures are completely explicit, and almost everything is actually unboxed Ints. There's no wiggle room in the types at all.
20:13:28 <shachaf> "floating point exception" doesn't mean that you're using floating points.
20:14:18 <eazar001> http://stackoverflow.com/questions/3615476/floating-point-exception
20:14:25 <eazar001> so this guy got it using ints ^
20:14:36 <eazar001> keep in mind this is C
20:14:41 <dfeuer> shachaf, yeah, I see that now. But what I don't see is why the one gets a floating point exception that makes GHCi crash, while the other gets an arithmetic overflow allowing GHCi to recover.
20:15:12 <shachaf> I recommend applying the usual debugging strategy until you find out.
20:16:58 <dfeuer> shachaf, that is ... less than helpful.
20:30:21 <tommd> What Lens operator should I be using instead of ((^. getter) `fmap` maybeStruct) ?
20:35:57 <eazar001> tommd: maybe (^. fmap getter) ??
20:36:38 <eazar001> dunno, maybe that seems a little silly
20:43:48 <Forkk> Why are the IO functions in the standard library not using MonadIO?
20:48:08 <gcganley> hey is there an xmonad irc channel?
20:48:44 <gcganley> :t (<+>)
20:48:46 <lambdabot>     Ambiguous occurrence ‘<+>’
20:48:46 <lambdabot>     It could refer to either ‘Control.Arrow.<+>’,
20:48:46 <lambdabot>                              imported from ‘Control.Arrow’ at /home/lambda/.lambdabot/State/L.hs:46:1-20
20:49:34 <geekosaur> #xmonad?
20:50:03 <geekosaur> but I think I'm going to have to head to bed soon and nobody else is around in there at the moment, it seems
20:55:11 <washburn> in a lambda (annonomous function) is there a way to reference it'sself, allowing for recursion?
20:55:46 <washburn> since it is annonymous, there is no name I know of to make recusive calls in the lambda
20:56:15 <washburn> consider the following annonomous function to pair elements of a list:  (\(x:y:zs) -> (x,y) : ??? zs)
20:56:26 <washburn> where ??? would be the recursive call
20:56:42 <washburn> of course I would only use this for infinite lists...
20:56:43 <geekosaur> washburn: not directly, but see fix
20:56:55 <geekosaur> @src fix
20:56:55 <lambdabot> fix f = let x = f x in x
20:57:08 <washburn> geekosaur: the fix package?
20:57:21 <geekosaur> used properly this can make a lambda recursive
20:57:26 <washburn> hmmm
20:57:38 <geekosaur> > fix (1:)
20:57:38 <washburn> geekosaur: thanks, I'll look into it!
20:57:40 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
20:58:00 <washburn> geekosaur: my mind just exploded seeing that....!
20:58:26 <geekosaur> laziness lets us do all sorts of fun things
20:59:16 <gamegoblin> meiji11: you around?
21:00:09 <washburn> @src (fix \(x:y:zs) -> (x,y) : zs) [1..]
21:00:10 <lambdabot> Source not found. I am sorry.
21:00:17 <washburn> > (fix \(x:y:zs) -> (x,y) : zs) [1..]
21:00:18 <lambdabot>  <hint>:1:6: parse error on input ‘\’
21:00:46 <geekosaur> more generally we have http://www.haskell.org/haskellwiki/Tying_the_Knot which uses laziness to make self-referential structires
21:00:50 <geekosaur> and you need extra parens there
21:00:57 <geekosaur> or just move the ones you used
21:01:45 <geekosaur> hm, no, needs a bit more, I think. but I'm becoming too tired to think straight :(
21:06:49 <washburn> geekosaur: I don't think I can do it in this case
21:06:53 <washburn> @src fix
21:06:53 <lambdabot> fix f = let x = f x in x
21:07:00 <washburn> :t fix
21:07:02 <lambdabot> (a -> a) -> a
21:07:25 <washburn> geekosaur: I wanted :t [a] -> [(a,a)]
21:07:59 <washburn> geekosaur: So I don't think fix will work, but thanks for pointing me to such an epic function
21:11:08 <pjdelport> :t map (\x -> (x,x))
21:11:10 <lambdabot> [t] -> [(t, t)]
21:11:14 <pjdelport> That?
21:11:56 <pjdelport> oh, nevermind :)
21:17:59 <trap_exit> is it possible to use template haskell in haste? basically I want to use ghc to run the templatehas haskell, then haste to compile the outputted haskell files
21:18:57 <pjdelport> > (fix $ \f -> \(x:y:zs) -> (x,y) : f zs) [1..]
21:19:00 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20),(21,...
21:19:13 <luite> trap_exit: there are workarounds like evilsplicer annd zeroth that can dump splices / insert results, but there is nothing that has full th functionality
21:19:45 <trap_exit> luite: noted; thanks
21:20:19 <trap_exit> luite: now that ghcjs development is not driven by my bug reports, what are you hacking on these days?
21:20:45 <pjdelport> washburn: You can think of fix as simply giving a functions its own output as parameter (which works in Haskell because of lazy evalutaion / knot-typing)
21:21:20 <mcbears> knot-tying* i think :p
21:21:30 <pjdelport> Err, yes, thanks. :)
21:22:15 <pjdelport> washburn: So the trick is to not try and do the work directly inside the function that you pass to fix, but in stead in a function that you *return* from it.
21:22:54 <pjdelport> washburn: *That* function then gets passed back as parameter, and named as f.
21:23:25 <pjdelport> Which then gives the returned, inner function a named reference to itself.
21:23:35 <luite> trap_exit: working on the let-no-escape optimization and new optimizer
21:24:25 <pjdelport> So: fix (\f -> (\actualArgs -> actualBody))
21:24:36 <luite> trap_exit: also someone is trying to port the GHCJS TH method into GHC, so it becomes generally available for cross compilers and ghc api users
21:25:05 <pjdelport> What that effectively does is bind the inner body (\actualArgs -> actualBody) to 'f'.
21:25:35 <pjdelport> And allows the 'actualBody" expression to refer to f.
22:02:49 <jle`> > fix (\f x -> x : f (x + 1)) 1
22:02:51 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
22:18:29 <shelf> I'm in a cabal sandbox. I need to modify a hackage library very slightly to make it build (network-uri network split). how do I convince it to build within my sandbox? (it's not my main .cabal file)
22:18:52 <jle`> shelf: if you use cabal sandbox add-source path/to/lib, it'll look there for any libraries before hackage
22:19:33 <shelf> ! thanks a lot jle`
22:19:37 <jle`> np!
22:30:24 <lostman> shelf: you can pass the flags from the command line or add them to cabal.config. what I do myself is 'cabal install -fnetwork-uri hxt my_app'
22:31:17 <shelf> thanks, I didn't know about that flag
22:31:23 <lostman> add-source seems a bit wonky. more often than not I run into strange problems like cabal reinstalling packages for no good reason, telling me that packages are broken etc
22:31:33 <lostman> you can add flags to cabal.config
22:32:10 <lostman> but there's a caveat. if you add network-uri for hxt and then do 'cabal install foo' where foo depends on hxt then the flag won't get passed to hxt when it's built
22:32:11 <shelf> I thought add-source worked, but the package is taking an alarming amount of time to build
22:32:41 <lostman> add-source works, but I observed many odd problems when using add-source
22:33:31 <lostman> I tried this weekend to get all dependencies for my app into a single directory and then I was hoping to do add-source deps/*, turn off hackage and do cabal install
22:33:47 <lostman> never got that to work
22:34:16 <shelf> learning all the cabal tooling is harder than learning haskell
22:34:32 <srhb> That's an intersting claim. :-)
22:36:23 <Guest50920> ciao
22:36:24 <lostman> installing something from hackage works well, especially with sandbox. you'll probably have to install 100+ packages though if you're building something sizeable
22:36:30 <Guest50920> !list
22:36:30 <monochrom> Guest50920: http://okmij.org/ftp
22:36:35 <lostman> (try yesod + diagrams for instance)
22:41:35 <shelf> i'm in yesod land now, yeah
22:41:42 <shelf> it's not fun :)
22:58:58 <Thule> Hi guys. I have an assignment where I need to modify how Show displays a list of floats. Can any of you help?
22:59:16 <Thule> I just need some idea on how to get started
23:00:23 <dfeuer> luite, you might be able to figure this out, but I can't. Reversing the order of the "divide by zero" test with the "arithmetic overflow" test magically makes this divMod stuff work the way I want.
23:00:28 <dfeuer> I don't know why.
23:00:47 <Thule> I have not been able to find any way to modify show for standard types, such as [Float]
23:01:04 <dfeuer> Thule, there is no way.
23:01:24 <Thule> hmm.. Strange assignment then :(
23:01:31 <dfeuer> Thule, most of the time, that is not what you really want. However, if it is what you really want, what you need to do is use newtype.
23:02:05 <dfeuer> You can do something like newtype MyFloatList = MyFloatList [Float]
23:02:06 <shachaf> Thule: You can use your own function instead of the function show.
23:02:31 <Makoryu> Thule: Realistically, you won't be able to compile this as you describe, but you can at least *write* your own instance for Show [Float]
23:02:33 <dfeuer> Or something like newtype MyFloat = MyFloat Float.  But yes, what shachaf says is right.
23:03:00 <dfeuer> And that is usually the right way to do it.
23:03:07 <Thule> okay thank you
23:03:14 <dfeuer> show is not a general-purpose way to print stuff.
23:03:29 <Thule> I will probably do the new type dfeuer
23:03:59 <jle`> if it's an assignment
23:04:09 <jle`> then you might be able to get away with doing things people would never do in real code
23:04:27 <jle`> instance Show [Float] where ... would work if you enabled OverlappingInstances or UndecidableInstances or something like that
23:04:50 <jle`> Thule:
23:04:55 <Thule> I am not supposed to do anything with important/enabling etc. Only using prelude
23:05:46 <jle`> ah, yeah. then.
23:06:07 <jle`> oh you need FlexibleInstances
23:06:29 <jle`> and IncoherentInstances
23:07:05 <Thule> I do not think it is supposed to be that advanced. Thanks though
23:07:13 <jle`> :)
23:07:32 <dfeuer> And IncoherentInstances also happens to be evil.
23:07:52 <dfeuer> FlexibleContexts seems to be okay.
23:08:09 <Fuuzetsu> I can only suspect your assignment wants you to use a newtype
23:08:40 <trap_exit_> if haskell makes programmers 10x more productive, then why are there not better haskell ides? :-)
23:09:06 <Fuuzetsu> trap_exit_: because you don't need one when you're 10x more productive already ;P
23:09:09 <dfeuer> Why aren't unboxed top-level values allowed?
23:09:54 <dfeuer> It seems awfully silly to write overflowError# :: Int# -> Int#  and make it take an argument just to deal with that restriction.
23:10:45 <trap_exit_> http://www.haskell.org/haskellwiki/Gtk2Hs/Mac <-- why the ???? is leksah installatino so hard :-(
23:11:46 <Fuuzetsu> lehsah uses Yi for the editing part AFAIK
23:11:50 * Fuuzetsu → bed
23:12:15 <trap_exit_> there is some function
23:12:19 <trap_exit_> which takes Fuuzetsu as input
23:12:22 <trap_exit_> and produces a bed as output
23:19:09 <dfeuer> Could someone explain why GHC would produce a local function of type Void# -> (# Int, Int #) ?  What's the real difference between that and just (# Int, Int #) ?
23:19:29 <dfeuer> OK, so I assume it won't be shared, but ... weird.
23:19:53 <shachaf> Huh? How are they similar?
23:20:09 <ddellacosta> reading this: http://www.andres-loeh.de/LambdaPi/LambdaPi.pdf and the description of const (type sig and evaluation description?) is (const :: (β → β) → α → β → β) id y ⇓ id .  I'm having trouble figuring out how that maps to Haskell's const though, which I thought was a -> b -> a, and I don't understand the id y evaluating to id bit...can anyone explain this?
23:20:41 <dfeuer> shachaf, isn't Void# a zero-width token or something?
23:21:30 <shachaf> ddellacosta: id y isn't evaluating to id, the whole expression you wrote is.
23:21:39 <shachaf> (β → β) → α → β → β) is a perfectly good type for const.
23:21:47 <ddellacosta> ...and further more how that relates to lambda calculus's beta reduction is confusing...
23:21:49 <shachaf> Er, without that last parenthesis.
23:22:07 <ddellacosta> shachaf: sorry, I guess I'm having trouble parsing that expression in total
23:22:21 <shachaf> a = (β → β), b = α
23:22:27 <ddellacosta> shachaf: I thought that the stuff in parens was the type sig, and the id y (down arrow) id was the implementation, so to speak
23:22:44 <shachaf> I haven't read the paper.
23:22:49 <ddellacosta> shachaf: ah, okay, I see!  right, just missing the last parens
23:23:01 <shachaf> Well, they're implied, just like in Haskell.
23:23:09 <ddellacosta> shachaf: right, okay
23:23:18 <shachaf> You have "const id y ⇓ id"
23:23:34 <shachaf> But to be clear the type of const is specified, so "(const :: ...) id y ⇓ id"
23:23:49 <luite> dfeuer: the use of unboxed tuples is very limited, you cannot just make a let binding of them. so even if your tuple just contains some existing values you have to wrap it in a function
23:23:57 <ddellacosta> shachaf: ah, okay, so this is slowly becoming clear, I guess const id y is basically just id, is that right?
23:24:18 <luite> dfeuer: this is the type of thing that ghc often introduces for join points
23:25:08 <dfeuer> luite, thanks. That kind of makes sense. Although I don't understand why they are limited so. It seems that (somehow) reordering these tests convinced it to use this Void# join point instead of a more interesting one that breaks what I'm trying to do.
23:25:31 <shachaf> dfeuer: It reduces to id. Or I assume that's what that notation means.
23:25:33 <dfeuer> I mean, I understand some of their limitations, but not why they can't be at the top level, say.
23:26:09 <ddellacosta> shachaf: think you meant that for me.  But yeah, that ⇓ means evaluation in the paper, so I think your assumption was spot on.
23:26:19 <ddellacosta> shachaf: anyways thanks, that was very helpful!
23:26:21 <shachaf> Er, yes, you.
23:27:51 <shachaf> dfeuer: OK, I see.
23:28:25 <dfeuer> shachaf, you see what?
23:28:41 <shachaf> What Void# is. A misleading name.
23:30:33 <luite> dfeuer: the point of unboxed tuples is to avoid allocations and heap object overhead. with these restrictions and ghc's cps transformation, everything producing an unboxed tuple can be implemented as something passing the tuple as arguments to the continuation. the metadata for the storage manager is then in the function, the tuple itself has zero overhead
23:31:29 <Thule> So I have an array like this [1.0, 2.3, 2.1] and I need to show it like: 1 + 2.3x + 2.1x^2. Can any of you point me in the right direction? I have created newType MyFloat = MyFloat Float
23:31:33 <dfeuer> luite, the metadata for the storage manager? I'm not sure what that means.
23:31:40 <Thule> and instance Show MyFloat where ...
23:34:10 <luite> dfeuer: for example the garbage collector needs to follow pointers to heap objects, for example (# Int#, Bool #), only the second component is a pointer type
23:35:21 <dfeuer> luite, OK, so you're saying that the GC touches those unboxed things when tracing the function or something?
23:35:37 <luite> dfeuer: by itself, there is no way to know that for an unboxed tuple, but if you only allow it to exist as arguments for the next function to be called, then you can inspect the function's info table, which contains the types of the arguments
23:36:05 <dfeuer> All righty.
23:36:15 <dfeuer> Thanks, luite.
23:42:15 <augur> anyone know how to get up and running with emacs/aquamacs?
23:42:56 <augur> also is there a haskell mode that lets you do hole-based editing and/or automatic case splitting?
23:43:38 <dfeuer> augur, there is a magical haskell mode, but I'm not too good with Emacs or memorizing a million keyboard shortcuts, even when a lot of them are really cool.
23:44:01 <MP2E> me neither
23:44:19 <augur> dfeuer: if its like agdamode im good :)
23:44:52 <dfeuer> I dunno, augur.
23:45:36 <Thule> So I have my own type with MyType {poly :: Int, val :: Float}. If I pass this to a function, how do I access poly and val in the function?
23:45:56 <augur> Thule: you can pattern match or record match
23:46:15 <Thule> how?
23:46:17 <augur> Thule: MyType acts like a pair in that order
23:46:20 <Thule> ahh ok
23:46:21 <Thule> thanks
23:46:27 <augur> so you can construct and match both as
23:46:41 <mcbears> when you define a record, its field names are introduced as functions. so you automatically have a function poly :: MyType -> Int and val :: MyType -> Float
23:46:47 <augur> MyType anInt aFloat   and   MyType { poly = anInt, val = aFloat }
23:47:07 <augur> Thule: if you use the record style, the order is irrelevant. but if you use the tuple style, the order is the order of the names in the definition
23:47:29 <augur> you can also use the field names as accessors instead of pattern matching
23:47:32 <Thule> greeat, got it. Thank you
23:47:54 <augur> so instead of   foo (MyType anInt aFloat) = ...    or   foo (MyType { poly = anInt, val = aFloat } = ...
23:48:16 <augur> you can do   foo x = ...poly x...val x...
23:49:00 <Thule> I have this: instance Show MyType where
23:49:01 <Thule>   show (MyType aInt aFloat) = aInt
23:49:12 <Thule> but it fails because aInt is an int and not a char
23:49:22 <augur> Thule: yes
23:49:39 <augur> so here's the show instance for pairs:
23:49:50 <Thule> ahh
23:49:52 <augur> show (x,y) = "(" ++ show x ++ "," ++ show y ++ ")"
23:49:53 <Thule> need show :)
23:49:55 <Thule> thanks!
23:50:13 <augur> haskell wont automatically convert things to strings
23:50:33 <augur> in generally haskell has no such ability (tho in theory it could)
23:51:41 <augur> i think the main reason it doesnt tho is i guess because the compiled code might have no connection to the syntax, so however you represent functions would be an issue
23:53:25 <cnphil> wait, since everything in haskell is of abstract data type, and each of those fundamental types can be converted to string, why can't it be converted to strings?
23:54:03 <augur> cnphil: if you compile a function, you're going to get a bunch of low-level code. how do you show that?
23:54:06 <mcbears> there isn't really a way to convert functions into strings (that makes enough sense)
23:54:14 <krgn_>  nn =0-    nmc m nm
23:54:23 <dfeuer> augur, I think it will be very hard to represent something like a cyclic list of Void values as a string.
23:54:26 <dv-> > show (+)
23:54:28 <lambdabot>  "<Integer -> Integer -> Integer>"
23:54:35 <augur> mcbears: right, you could show the lambda term, but that requires the program is preserved
23:54:54 <augur> dfeuer: why? that should be easy!
23:55:07 <augur> dfeuer: since there's only one such list, it's easy to show! :)
23:56:10 <augur> the only such list being the empty list because there are no Void values
23:56:13 <Thule> Thank you for your help this evening guys. Have fun
23:56:21 <dfeuer> augur, and how would you do it? There's only one as far as Haskell is concerned, but there are infinitely many representations of it, and as soon as you touch anything it wants to go boom.
23:56:30 <augur> showing other cyclic lists is a bit trickier of course!
23:57:13 <dfeuer> augur, there's cycle [undefined], and cycle  [undefined, undefined], and cycle [undefined, undefined, undefined], ....
23:57:18 <augur> dfeuer: by default you can obviously just show it as it would appear in haskell
23:57:30 <augur> dfeuer: thats true of any type, not just Void, tho. also undefined is awful
23:57:33 <dfeuer> augur, it appears in Haskell as an *infinite* list.
23:57:37 <augur> tho you could show it as, unsurprisingly... "undefined"!
23:58:17 <augur> tho `undefined` is a kind of un-value
23:58:22 <augur> and isn't relevant
