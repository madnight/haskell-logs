00:07:56 * hackagebot hsdev 0.1.2.3 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  http://hackage.haskell.org/package/hsdev-0.1.2.3 (AlexandrRuchkin)
00:07:56 * hackagebot vty 5.2.3 - A simple terminal UI library  http://hackage.haskell.org/package/vty-5.2.3 (CoreyOConnor)
00:18:34 <vanila> Hi #haskell
00:18:40 <MP2E> hi
00:18:46 <vanila> good day MP2E
00:18:57 <MP2E> :> hey vanila
00:19:33 <vanila> I was looking on wadlers blog about implicit calculus and there was some really good discussion despite one guy being pretty rude
00:19:51 <vanila> http://wadler.blogspot.co.uk/2014/06/the-implicit-calculus-new-foundation.html
00:20:48 <jle`> @hoogle Word32 -> ByteString
00:20:52 <lambdabot> Data.ByteString.Lazy unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
00:20:52 <lambdabot> Data.ByteString unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
00:20:52 <lambdabot> Data.ByteString.Lazy.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
00:20:56 <jle`> hm
00:21:00 <vanila> anyway, the idea of tracing JIT of haskell seems pretty cool
00:21:56 <jle`> so how can i turn a Word32 into a ByteString :|
00:22:04 <vanila> :t maybe
00:22:06 <lambdabot> b -> (a -> b) -> Maybe a -> b
00:22:13 <MP2E> wow thanks for the link, this looks really neat
00:22:25 <vanila> :t \c -> unfoldr (maybe (\x -> Just (x, Nothing)) Nothing) (Just c)
00:22:26 <lambdabot>     Couldn't match expected type ‘t0 -> Maybe (t0, Maybe a0)’
00:22:26 <lambdabot>                 with actual type ‘Maybe (a, Maybe a2)’
00:22:26 <lambdabot>     Relevant bindings include c :: a2 (bound at <interactive>:1:2)
00:22:43 <lpaste> ambi pasted “Ambigous ” at http://lpaste.net/111591
00:23:15 <tdammers> jle`: I'd expect that you'd need to write a bit of bit-twiddling code yourself for that
00:23:25 <jle`> i was hoping to avoid that :|
00:23:32 <tdammers> after all, there is no one right way to encode a Word32 in a bytestring
00:23:42 <tdammers> big-endian? little-endian?
00:23:45 <vanila> :t \c -> unfoldr (maybe Nothing (\x -> Just (x, Nothing))) (Just c)
00:23:46 <lambdabot> a -> [a]
00:23:49 <tdammers> pad or not pad?
00:23:59 <vanila> maybe you can unfold a single char into a bytestring like that
00:24:11 <ambi> hi. can someone help me understand the issue in: http://lpaste.net/111591  .. class T cat xx yy zz where  t1 :: zz -> cat a b ..... and f1=t1 wont compile
00:24:15 <vanila> oh a word 32
00:24:31 <jle`> oh, i can use a Builder
00:25:28 <tdammers> a Builder for just 4 bytes?
00:27:17 <vanila> ambi, how about functional dependencies? http://lpaste.net/111591
00:27:54 <vanila> that lets you not use AllowAmbiguousTypes, which sounds scary
00:30:50 <ambi> vanila, it means: zz uniquely identifies xx and yy, right? I would like to xx,yy,zz independent
00:31:23 <vanila> ambi, I see, well sorry I don't know how to do that
00:31:40 <ambi> vanila, can you give me a pointer why typeinference of f1=t1 fails?
00:32:04 <vanila> ambi, type inference is fine - it's just that the function definition only makes use of two of the type parameters of the class
00:32:39 <vanila> ambi, so knows that it wont be able to uniquely determine the instances that make sense when you use it
00:34:53 <ambi> vanila, can't it be generalized either by explicitly giving type for f1, something like: f1::forall (cat :: * -> * -> *) xx yy zz a b.  T cat xx yy zz => ff->cat a b
00:35:43 <ambi> vanila: that fails with couldnt deduce..from the context..type variables are ambigous..
00:35:48 <vanila> ambi, you could do that if you don't use a type class -- pass a record containing the functions by hand instead
00:37:16 <vanila> ambi: I cant remember the syntax for records in haskell but something like this http://lpaste.net/111591
00:37:38 <vanila> so this has type T cat xx yy zz -> zz -> cat a b
00:37:53 * hackagebot linear-vect 0.1.0.0 - A low-dimensional linear algebra library, operating on the Num typeclass  http://hackage.haskell.org/package/linear-vect-0.1.0.0 (capsjac)
00:37:55 * hackagebot future-resource 0.3.0.0 - realtime resource handling with manual concurrency  http://hackage.haskell.org/package/future-resource-0.3.0.0 (capsjac)
00:40:52 <ambi> vanila, yeah but replacing typeclass with explicit record passing wont help for me. coz already a large piece of code is written using typeclasses.
00:41:28 <vanila> ambi, i'd be inclined to look for alternative solutions then - ify ou want topast emore code that shows the situation maybe someone can come up with an idea?
00:45:10 <sagittarian> is there a builtin primitive function that works the same as flip ($)?
00:45:15 <sagittarian> :t flip ($)
00:45:16 <lambdabot> b -> (b -> c) -> c
00:46:02 <vanila> there's not
00:46:04 <fizbin> builtin? No, but lens provides (&) :
00:46:13 <ambi> vanilla, give me sometime. I'll try to upoad more code
00:46:14 <sagittarian> @pl \a f -> f a
00:46:14 <lambdabot> flip id
00:46:15 <fizbin> > 5 & (3 +)
00:46:16 <merijn> sagittarian: Nope, lens defines (&), but that's a pretty big dependency for just one function :)
00:46:16 <lambdabot>  8
00:46:45 <sagittarian> okay, haven't learned about lenses yet
00:46:57 <merijn> sagittarian: You could just define it yourself locally
00:47:04 <NikolajK> If I write "data Line a = None | NextSlot { toLine :: Line a}". Both NextSlot and toLine are functions. Then why does :t toLine.NextSlot work and :t NextSlot.toLine doesn't??
00:47:09 <sagittarian> yeah i know
00:47:10 <tdammers> sagittarian: lens (the library) is a "bit" more than just lenses
00:47:19 <ambi> :t (>>>)
00:47:20 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
00:47:41 <merijn> NikolajK: Check the type of toLine and NextSlot
00:47:45 <fizbin> NikolajK: You need a space around the dot in "Nextslot . toLine"
00:47:52 <sagittarian> but it seems so basic that i would want to have a consistent syntax, not even just with my own code but with haskell code in general
00:47:54 * hackagebot opengles 0.4.0 - OpenGL ES 2.0 and 3.0 with EGL 1.4  http://hackage.haskell.org/package/opengles-0.4.0 (capsjac)
00:48:16 <fizbin> NikolajK:  Oh, except tht types won't work. nevermind.
00:49:21 <sagittarian> i think i saw somewhere (probably lyah) that -| was used for this function (flip ($))
00:49:26 <fizbin> sagittarian: Then define (&) locally, or use (>>>) (from Control.Category), or depending on how you're using it, use a section like ($ 5)
00:49:48 <sagittarian> are there any other operators that are commonly defined like that?
00:49:51 <sagittarian> ah, &
00:49:52 <sagittarian> okay
00:49:58 <sagittarian> i'll take a look at lenses
00:50:30 <fizbin> That is, I remember someone looking for (flip ($)) when what he really needed to do in that specific spot was just use ($ a)
00:50:39 <sagittarian> :t (&)
00:50:40 <lambdabot> a -> (a -> b) -> b
00:51:17 <fizbin> > " World" >>> ("Hello" ++)
00:51:18 <lambdabot>  Couldn't match type ‘(->) a’ with ‘[]’
00:51:18 <lambdabot>  Expected type: a -> GHC.Types.Char
00:51:18 <lambdabot>    Actual type: [GHC.Types.Char]Couldn't match type ‘GHC.Types.Char’ with ‘[G...
00:51:19 <lambdabot>  Expected type: GHC.Types.Char -> [GHC.Types.Char]
00:51:19 <lambdabot>    Actual type: [GHC.Types.Char] -> [GHC.Types.Char]
00:51:20 <sagittarian> yeah i was thinking of a pattern like this:
00:51:38 <sagittarian> ($ start) (c . b . a)
00:51:50 <sagittarian> or ($ start) (a >>> b >>> c)
00:51:50 <NikolajK> fizbin, na, it worked with the space
00:52:09 <sagittarian> but i can remove some parens with something like start & a & b & c
00:52:57 <fizbin> NikolajK: The space is needed only because NextSlot starts with a capital letter. Capital.stuff is parsed as "stuff from the imported module Capital"
00:53:11 <sagittarian> > "World " & ("Hello" ++)
00:53:13 <lambdabot>  "HelloWorld "
00:53:14 <NikolajK> ah, k
00:53:34 <sagittarian> okay, & is what i was looking for, thanks everyone
00:53:39 <vanila> D:
00:53:40 <NikolajK> If I define "newtype Fix f = InF { outF :: f (Fix f) }"
00:53:41 <NikolajK> is there any relation between InF and outF?
00:53:48 <NikolajK> like are they inverses?
00:53:52 <vanila> :t (&)
00:53:53 <lambdabot> a -> (a -> b) -> b
00:54:09 <sagittarian> so how do you do bitwise and in haskell then?
00:54:17 <vanila> NikolajK, they area always inverses for every newtype
00:54:21 <fizbin> :t (.&.(
00:54:22 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
00:54:28 <fizbin> :t (.&.)
00:54:29 <lambdabot>     Ambiguous occurrence ‘.&.’
00:54:29 <lambdabot>     It could refer to either ‘Data.Bits..&.’,
00:54:29 <lambdabot>                              imported from ‘Data.Bits’ at /home/lambda/.lambdabot/State/L.hs:63:1-16
00:54:31 <NikolajK> and for data?
00:54:51 <fizbin> :t (Data.Bits..&.)
00:54:52 <lambdabot> Bits a => a -> a -> a
00:55:00 <sagittarian> okay, thanks fizbin
00:55:45 <fizbin> Why on earth does lambdabot have two imports of (.&.) ?
00:55:47 <trap_exit> okay
00:55:47 <vanila> same number of lines of code to write: x & f = f x as it is to import Lens!
00:55:51 <sgronblo> where does my binary go when i run cabal build?
00:55:51 <trap_exit> so what does 7.8 offer over 7.6 ?
00:56:00 <trap_exit> i'm debating going through problem of upgrading to 7.8.3 on ubunu 14.04
00:56:07 <trap_exit> and I want to know "what does 7.8.3 offer over 7.6.3" ?
00:56:20 <fizbin> sgronblo: dist/build/BinaryName/BinaryName
00:56:44 <sgronblo> thanks
00:57:28 <sagittarian> trap_exit, if you upgrade to 7.8.3 you get to spend hours figuring out why things don't compile
00:57:36 <sagittarian> totally worth it if you ask me, but ymmv
00:57:56 <fizbin> There is one other library that defines a (&) that means something different from what lens means by (&), but it's pretty specialized. (fgl)
00:58:14 <fizbin> I mean, I've been using it a lot lately, but I'm doing something weird.
00:58:15 <merijn> trap_exit: http://www.haskell.org/ghc/docs/7.8.1/html/users_guide/release-7-8-1.html
00:58:36 <trap_exit> merijn: noted, will read, thanks
00:59:27 <merijn> 7.8 has a boatload of huge improvements including the new blazing fast IO manager
01:00:12 <fizbin> Plus it warns you when you define stuff that might break under AMP.
01:00:40 <fizbin> (Like defining Monad but not Applicative)
01:01:43 <trap_exit> hmm
01:01:44 <funrep> i use vim with syntectic, it works really good but it doesnt find stuff ive installed in sandbox (and not Network.Socket either, which is in base?), anyone been able to fix this?
01:01:47 <trap_exit> so you are saying
01:01:55 <trap_exit> take the bullet and upgrade to 7.8.3 ?
01:02:07 <funrep> yes im aware of this fix: https://gist.github.com/yuga/6612105 but it doesnt work for me
01:02:25 <fizbin> Isn't the phrase usually "bite" the bullet?
01:03:30 <merijn> trap_exit: It depends on which projects you (plan to) use
01:03:54 <trap_exit> i would rather get hit by a bullet in the shoulder than in the teeth
01:04:36 <merijn> trap_exit: Basically, the bigger the project (in terms of dependencies), the longer it takes for all of them to support a new GHC and thus the more likely they are to not build
01:05:18 <merijn> That said, I've not had any problems, but then again, I don't tend to have that many dependencies in my code. If you're the kinda person that has 130 dependencies, your mileage may vary :p
01:06:24 <ReinH> I haven't had any issues with 7.8 yet
01:06:38 <ReinH> And I've compiled lens, so that's at least 50% of hackage right there
01:06:49 <MP2E> I had issues with ghc 7.8 when it was .1 and .2, but .3 has been pretty reliable
01:06:58 <merijn> ReinH: Not with the new one :D
01:07:10 <ReinH> merijn: true :p
01:07:16 <merijn> ReinH: They dropped aeson as a dependency, which eliminates a lot of junk for me
01:07:21 <ReinH> Yep
01:08:23 <trap_exit> wtf
01:08:27 <trap_exit> lens depened on aeson ?
01:08:37 <MP2E> it used to, yes
01:08:49 <MP2E> now that functionality is split into lens-aeson
01:12:56 * hackagebot apiary 0.17.2 - Simple and type safe web framework that can be automatically generate API documentation.  http://hackage.haskell.org/package/apiary-0.17.2 (HirotomoMoriwaki)
01:12:58 * hackagebot apiary-purescript 0.17.1 - purescript compiler for apiary web framework.  http://hackage.haskell.org/package/apiary-purescript-0.17.1 (HirotomoMoriwaki)
01:15:50 <AshyIsMe> so does mueval not work with ghc 7.6.3?
01:16:01 <AshyIsMe> or is this a cabal issue?
01:16:05 <sgronblo> I tried putting my yesod binary on my server and running it but it complains about a missing libpcre.so, can I just recompile it statically somehow?
01:19:39 <wz1000> sgronblo: Try installig pcre on your machine.
01:20:26 <sgronblo> i installed all the pacakges yum found that contained the string pcre
01:21:03 <sgronblo> so epic fail
01:21:12 <wz1000> Ah, are you using the same distro on your development machine and your server?
01:21:37 <sgronblo> actually the server is this amazon ami thing and the dev vm is centos... i hoped they would have been close enough
01:23:34 <AshyIsMe> does anyone here maintain mueval that lambadbot uses?
01:23:51 <AshyIsMe> cabal install mueval works for me but when i try to run it i'm getting this error:
01:24:03 <AshyIsMe> Ambiguous module name `Control.Monad.Cont': it was found in multiple packages: monads-tf-0.1.0.1 mtl-2.1.2
01:24:11 <wz1000> sgronblo: I think fp complete hosts yesod servers. You can try that and save yourself the trouble of configuration and maintainance.
01:25:32 <trap_exit_> https://gist.github.com/anonymous/989be346c996879347b9#
01:25:33 <trap_exit_> wtf is wrong
01:25:36 <trap_exit_> this is haste-compiler
01:25:45 <trap_exit_> this is "cabal install haste-compiler" on ubuntu 14 with ghc 7.8.3
01:26:55 <fizbin> :t  M.insertWith (const id)
01:26:56 <lambdabot> Ord k => k -> a -> M.Map k a -> M.Map k a
01:38:35 <jle`> \
01:47:59 * hackagebot yesod-auth-hashdb 1.3.2 - Authentication plugin for Yesod.  http://hackage.haskell.org/package/yesod-auth-hashdb-1.3.2 (paulrouse)
02:03:00 * hackagebot vect-floating 0.1.0.4 - A low-dimensional linear algebra library, operating on the Floating typeclass  http://hackage.haskell.org/package/vect-floating-0.1.0.4 (cdurham)
02:03:02 * hackagebot vect-floating-accelerate 0.1.0.4 - Accelerate instances for vect-floating types  http://hackage.haskell.org/package/vect-floating-accelerate-0.1.0.4 (cdurham)
02:09:05 <hyPiRion> ugh
02:10:51 <hyPiRion> shm is sort-of like paredit when it comes to delimiters, but there seems to be no slurping or barfing built-in?
02:11:48 <hyPiRion> so e.g. if I want to transform "foo bar baz quux" into "foo (bar baz) quux", is there a way to slurp into the paren given the setup "foo (|) bar baz quux"?
02:12:01 <trap_exit_> would it be inaccurate to call leksah a pile of horse shit? I just installed ubuntu + ghc 7.8.3 + got leksah running ... and I don't get what this notion of worksapce / projects / screen divisions get me
02:12:10 <trap_exit_> anyone here using leksah and happy with it? (and willing to tlel me wtf I'm doing wrong)
02:12:20 <trap_exit_> this IDE appears very 'weak' to me atm
02:15:46 <jle`> do you mean that literally?  in which case, it would most likely be inaccurate
02:20:51 <sagittarian> how can i uninstall a specific version of a library with cabal?
02:21:25 <dcoutts_> ghc-pkg unregister foo-1.0
02:23:15 <zereraz> hello can some one explain what I am doing wrong here http://lpaste.net/111590
02:25:21 <ion> The values removeList and addToList return are IO actions, just like loop. Also, line 16 is parsed as return (fst . splitAt n) xs ++ (tail . snd . splitAt n) xs
02:25:34 <ion> sorry, (return (fst . splitAt n) xs) ++ ((tail . snd . splitAt n) xs)
02:25:49 <ion> You’ll want more parentheses or return $ …
02:26:05 <ion> Line 23 is missing a “return” and lines 8 and 9 are missing parameters to loop.
02:35:35 <AshyIsMe> hmm, dependency resolving failing, time to recompile the world
02:37:31 <ion> and use sandboxes
02:37:35 <sagittarian> hyPiRion, foo x y z = someFunc (x y) z? is that what you're after?
02:38:22 <sagittarian> @pl \x y z -> someFunc (x y) z
02:38:23 <lambdabot> (someFunc .)
02:43:26 <BoR0> how do I Control.Exception.try something like 1 `div` 0 ? I managed to try an IO action, but I can't catch that one
02:43:45 <hyPiRion> sagittarian: no, I want paredit-like capabilities on haskell expressions. Say I e.g. convert a type from (a, b, c) to (a, (b, c)), then I want to convert existing expressions with structured haskell mode
02:44:44 <hyPiRion> Usually this is done by (if you know paredit) slurping from "(a, (|)b, c)" to "(a, (b, c))" which should be 2-3 commands.
02:45:03 <hyPiRion> (this is in emacs btw)
02:45:16 <BoR0> > try (readFile "asdf") :: IO (Either SomeException String) -- this is okay
02:45:18 <lambdabot>  <IO (Either SomeException [Char])>
02:45:27 <BoR0> > try (return $ 1 `div` 0) :: IO (Either SomeException Int) -- this should return a Left, but it doesn't
02:45:29 <lambdabot>  <IO (Either SomeException Int)>
02:47:05 <BoR0> ...instead, I get "Right *** Exception: divide by zero" :)
02:47:23 <supki> BoR0: that's because 1 `div` 0 isn't evaluated in your example
02:47:33 <supki> replace  return  with  Control.Exception.evaluate
02:47:45 <BoR0> evaluate! wonderful
02:47:52 <BoR0> @src evaluate
02:47:52 <lambdabot> Source not found. The more you drive -- the dumber you get.
02:48:21 <BoR0> is evaluate an internal thing?
02:55:38 <BoR0> ok, if someone could now tell me how seq# differs from seq (I noticed that I can use it only if I LANGUAGE MagicHash) :)
02:56:23 <jle`> :t liftA2 . liftA2
02:56:24 <lambdabot> (Applicative f1, Applicative f) => (a -> b -> c) -> f (f1 a) -> f (f1 b) -> f (f1 c)
02:56:48 <jle`> it's pretty neat that this works out as one would hope...
02:56:51 <jle`> the same way as
02:56:53 <jle`> :t (fmap . fmap)
02:56:54 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
02:57:13 <ion> :t _2 . _2
02:57:14 <lambdabot> (Field2 a b a1 b1, Field2 s t a b, Functor f) => (a1 -> f b1) -> s -> f t
02:57:37 <ion> :t traverse . traverse
02:57:38 <lambdabot> (Traversable t1, Traversable t, Applicative f) => (a -> f b) -> t (t1 a) -> f (t (t1 b))
02:57:44 <sagittarian> :t PatBind
02:57:46 <lambdabot> Not in scope: data constructor ‘PatBind’
02:57:46 <jle`> yeah but those are two argument things
02:57:58 <jle`> um
02:58:02 <jle`> they each take one `f a`
02:58:04 * hackagebot HarmTrace-Base 1.1.0.2 - Parsing and unambiguously representing musical chords.  http://hackage.haskell.org/package/HarmTrace-Base-1.1.0.2 (JosePedroMagalhaes)
02:58:06 * hackagebot FComp 1.0.2 - Compose music  http://hackage.haskell.org/package/FComp-1.0.2 (JosePedroMagalhaes)
02:58:08 <jle`> but liftA2 takes two `f a`'s
02:58:37 <jle`> so one would think it'd compose fundamentally differently than fmap/_2/traverse-type functions
02:58:39 <aloiscochard> is there a tool to apply hlint suggestion automatically? (ideally being able to select the suggestions that can be auto-applied)?
03:00:05 <jle`> :t (=<<) . (=<<) . (=<<) . (=<<) $ return
03:00:06 <lambdabot> Monad m => m (m (m (m b))) -> m b
03:01:13 <jle`> :t join . join . join
03:01:15 <lambdabot> Monad m => m (m (m (m a))) -> m a
03:01:25 <jle`> it feels weird
03:01:43 <jle`> (not the join.join, the (=<<).(=<<))
03:03:15 <hexagoxel> :t (=<<) . (=<<) . (=<<) $ id
03:03:16 <lambdabot> Monad m => m (m (m (m b))) -> m b
03:11:48 <jle`> hm
03:11:53 <jle`> :t (=<<) id
03:11:54 <lambdabot> Monad m => m (m b) -> m b
03:11:56 <jle`> neat
03:13:29 <BoR0> :t ((=<<) ((=<<) id))
03:13:30 <lambdabot> Monad m => m (m (m b)) -> m b
03:13:44 <BoR0> :t (=<<) ((=<<) ((=<<) id))
03:13:45 <lambdabot> Monad m => m (m (m (m b))) -> m b
03:16:36 <BoR0> :t (>>=) ((>>= id) >>=)
03:16:37 <lambdabot> Monad m => ((m (m b2) -> b1) -> (m b2 -> m (m b2) -> b1) -> b) -> (m b2 -> m (m b2) -> b1) -> b
03:18:06 * hackagebot tmpl 0.0.0.1 - simple executable for templating  http://hackage.haskell.org/package/tmpl-0.0.0.1 (michelk)
03:33:07 * hackagebot parsec3 1.0.0.9 - Monadic parser combinators  http://hackage.haskell.org/package/parsec3-1.0.0.9 (ChristianMaeder)
03:44:45 <zereraz> why is this not working putStrLn a where a = "hi"
03:45:07 <tdammers> zereraz: it should be, as long as you do it inside main
03:45:21 <zereraz> tdammers: I am doing in ghci
03:45:27 <zereraz> let a ="hi" in putStrLn a
03:45:29 <zereraz> this works
03:46:06 <zereraz> so this is correct? display xs where xs = []
03:46:13 <zereraz> I keep getting parse error on where
03:47:52 <zereraz> ?
03:52:18 <ChristianS> zereraz: where works only inside top-level function definitions afaik
03:52:35 <zereraz> ChristianS: what about inside the if then?
03:52:49 <ChristianS> zereraz: if is not a function, so no
03:52:51 <jle`> where is a part of declaration syntax
03:52:58 <jle`> it doesn't have to be top level
03:53:08 <jle`> (let ... in ...) is an expression
03:53:13 <jle`> so it can go wherever an expression goes
03:53:21 <zereraz> ok
03:53:23 <jle`> `where` can only be used with declarations
03:53:31 <jle`> (... where ...) is not an expression
03:53:43 <zereraz> so where and let are different
03:53:46 <jle`> ... = ... where ... is a declaration
03:53:48 <zereraz> I thought they are similar
03:53:51 <jle`> yeah, they are different
03:53:59 <jle`> (let ... in ...) gives you an expression
03:54:04 <jle`> just like 5 or 3 + 4 or [1,2,3]
03:54:05 <zereraz> jle`: thanks
03:54:16 <jle`> where is a part of the syntax for declaring things/definitions
03:54:17 <zereraz> jle`: got it
03:54:19 <SwashBuckla> you could do
03:54:25 <SwashBuckla> let x = foo where foo = 5
03:54:44 <jle`> that's not quite an expression or a declaration
03:54:55 <jle`> > let x = foo where foo = 5 in x + 2
03:54:56 <lambdabot>  7
03:55:03 <zereraz> nice
03:55:04 <jle`> that works, because it has the in :)
03:55:16 <jle`> (x = foo where foo = 5) is the declaration
03:55:24 <jle`> (let ... in ...) is the expression
03:55:44 * SwashBuckla now has a headache
03:55:45 <jle`> the `let` keyword is unfortunately overloaded
03:55:48 <SwashBuckla> what have I done
03:56:00 <jle`> but that shouldn't concern you for now :)
03:56:14 <zereraz> jle`: ok thanks
03:56:38 <sagittarian> @djinn f ? a -> a
03:56:38 <lambdabot> Cannot parse command
04:00:59 <sagittarian> @version
04:00:59 <lambdabot> lambdabot 5.0-int-e
04:01:00 <lambdabot> git clone git://github.com/int-e/lambdabot.git
04:08:07 <sagittarian> @activity
04:08:07 <lambdabot> 0*total
04:11:43 <lpaste> killy9999 pasted “haskeline build error” at http://lpaste.net/111615
04:11:57 <killy9999> I'm getting this build error with haskeline
04:12:00 <killy9999> any ideas why?
04:12:59 <sagittarian> @quote killy9999
04:12:59 <lambdabot> Nereid says: <killy9999> in which modules are finiteBitSize and bitSizeMaybe?  <killy9999> I can't find them using neither Hoogle nor Hayoo  <Nereid> ask hoogle or hayoo.  <Nereid> oh.
04:15:13 <killy9999> sagittarian: sorry, not helpful
04:15:24 <sagittarian> guess not
04:15:46 <sagittarian> what version of ghc are you using?
04:16:16 <Darwin226> Anyone know why Data.HashTable was removed from base-4.7.*?
04:16:22 <Darwin226> (and where a
04:16:31 <Darwin226> can I find a replacement for hastInt)
04:16:39 <Darwin226> hashInt*
04:17:02 <supki> @google cannot find ltinfo
04:17:03 <lambdabot> http://stackoverflow.com/questions/21137879/link-error-cannot-find-ltinfo-on-ubuntu-12-04-on-a-32-bit-arm-processor
04:17:03 <lambdabot> Title: c++ - Link error: "Cannot find -ltinfo" on Ubuntu 12.04 on a 32-bit arm proce...
04:17:22 <sagittarian> @elite haskell rocks
04:17:22 <lambdabot> |-|A$k3|L ro(xs
04:17:53 <Guest82482> In what version Control.Lense is in
04:17:58 <sagittarian> @elite i take pleasure in coding elegantly using the haskell programming language
04:17:58 <lambdabot> I tAk3 P|3A5UR3 IN CodIN9 Eleg4NT1y u$IN9 teh |-|AsxE|L pRO9rAm/\/\InG LaNgu493
04:19:26 <Guest82482> @type elite
04:19:27 <lambdabot> Not in scope: ‘elite’
04:20:37 <Darwin226> Seriously, it's blowing my mind that I can't find any info on that
04:20:44 <killy9999> sagittarian: 7.8.3
04:20:49 <killy9999> I just found a solution
04:21:01 <sagittarian> what was the problem?
04:21:04 <killy9999> cd /usr/lib64/
04:21:12 <killy9999> ln -s libncurses.so libtinfo.so
04:21:30 <killy9999> this deserves a WAT
04:21:35 <Darwin226> A package depends on hashInt, HashTable is gone from base 4.7 and google doesn't give me ANY results. Is this guy the only one to ever use that function?
04:22:11 <sagittarian> @instances Monad
04:22:13 <lambdabot> ((->) r), ArrowMonad a, ContT r m, Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
04:22:25 <sagittarian> @instances MonadPlus
04:22:26 <lambdabot> ArrowMonad a, Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
04:22:37 <sagittarian> @instances Applicative
04:22:37 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
04:23:31 <sagittarian> @instances-importing Control.Applicative Applicative
04:23:32 <lambdabot> ((,) a), ((->) a), ArrowMonad a, Const m, ContT r m, Either e, ErrorT e m, IO, Maybe, ReaderT r m, ST s, StateT s m, WrappedArrow a b, WrappedMonad m, WriterT w m, ZipList, []
04:24:49 <AshyIsMe> Darwin226: hoogle still finds it
04:25:17 <AshyIsMe> oh wow, it's gone http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-HashTable.html
04:25:33 <Darwin226> AshyIsMe: Yeah, but it's in base 4.6 and then gone in 4.7.
04:26:03 <sagittarian> @hoogle String -> String -> [String]
04:26:04 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
04:26:05 <lambdabot> System.FilePath.Posix (<.>) :: FilePath -> String -> FilePath
04:26:05 <lambdabot> System.FilePath.Windows addExtension :: FilePath -> String -> FilePath
04:26:07 <AshyIsMe> oh it's deprecated
04:26:13 <AshyIsMe> Darwin226: import Data.HashTable in ghci
04:26:25 <AshyIsMe> it tells you it's deprecated and please use a package like "hashtables"
04:26:40 <AshyIsMe> https://hackage.haskell.org/package/hashtables
04:26:49 <Darwin226> It just tells me that it can't find it
04:27:27 <AshyIsMe> oh im still on ghc 7.6.3
04:27:35 <Darwin226> AshyIsMe: The problem is that hashtables doesn't have hashInt
04:28:02 <Axman6> Darwin226: if you weanty hash tables, you want the unordered-containers package. it's very good
04:28:34 <Darwin226> AshyIsMe: I mean, it's not rocketscience to reimplement it on the spot but I find it weird that some functionality is just gone without a replacement
04:28:36 <Axman6> want even
04:29:22 <Darwin226> Axman6: Just the hashInt function
04:29:50 <Axman6> then you probably want the Hashable class
04:32:58 <Darwin226> Is there a way to install more than one base version?
04:35:42 <sagittarian> @karma Darwin226
04:35:42 <lambdabot> Darwin226 has a karma of 0
04:35:51 <sagittarian> @karma Axman6
04:35:51 <lambdabot> Axman6 has a karma of 6
04:37:00 <supki> Darwin226: no
04:40:53 <sagittarian> @hoogle splitOn
04:40:55 <lambdabot> Data.Text splitOn :: Text -> Text -> [Text]
04:40:56 <lambdabot> Data.Text.Lazy splitOn :: Text -> Text -> [Text]
04:41:23 <sagittarian> @hoogle Text -> Text -> [Text]
04:41:23 <lambdabot> Data.Text splitOn :: Text -> Text -> [Text]
04:41:24 <lambdabot> Data.Text.Lazy splitOn :: Text -> Text -> [Text]
04:41:24 <lambdabot> Data.Text append :: Text -> Text -> Text
04:41:42 <sagittarian> @hoogle a -> a
04:41:43 <lambdabot> Prelude id :: a -> a
04:41:43 <lambdabot> Data.Function id :: a -> a
04:41:43 <lambdabot> GHC.Exts breakpoint :: a -> a
04:42:09 <sagittarian> @hoogle (a, b) -> a
04:42:09 <lambdabot> Prelude fst :: (a, b) -> a
04:42:10 <lambdabot> Data.Tuple fst :: (a, b) -> a
04:42:10 <lambdabot> Prelude uncurry :: (a -> b -> c) -> ((a, b) -> c)
04:42:21 <sagittarian> @hoogle a -> b
04:42:21 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
04:42:22 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
04:42:22 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
04:42:33 <bernalex> does anyone happen to know what a signature type is?
04:42:34 <pjdelport> (You can /query lambdabot too, by the way.)
04:42:58 <sagittarian> if i'm annoying people just let me know
04:43:14 <pjdelport> sagittarian: /query is probably better, unless you're demonstrating something. :)
04:43:17 <Axman6> I think that was a subtle hint that you are beginning to
04:43:44 <pjdelport> (I'm not annoyed, but it's better to have the channel clear for discussion!)
04:44:02 <pjdelport> bernalex: What do you mean by signature type?
04:44:14 <bernalex> pjdelport: uhm that's what I'm asking you
04:44:26 <pjdelport> bernalex: I mean, what's the context?
04:44:38 <bernalex> pjdelport: sigtypes in GHC's parser of the lang.
04:44:58 <BoR0> :t join x >>= id -- how can I see which Monad instance is this expression using?
04:45:00 <lambdabot>     Couldn't match expected type ‘m (m (m b))’ with actual type ‘Expr’
04:45:00 <lambdabot>     In the first argument of ‘join’, namely ‘x’
04:45:00 <lambdabot>     In the first argument of ‘(>>=)’, namely ‘join x’
04:45:26 <BoR0> :t \x -> join x >>= id -- how can I see which Monad instance is this bind expression using?
04:45:27 <lambdabot> Monad m => m (m (m b)) -> m b
04:45:29 <Axman6> :t \x -> join j >>= id
04:45:30 <lambdabot>     Couldn't match expected type ‘m (m (m b))’ with actual type ‘Expr’
04:45:30 <lambdabot>     In the first argument of ‘join’, namely ‘j’
04:45:30 <lambdabot>     In the first argument of ‘(>>=)’, namely ‘join j’
04:45:39 <Axman6> uh, yeah
04:45:40 <pjdelport> BoR0: It's not using any specific Monad instance yet.
04:46:00 <pjdelport> :t (+)
04:46:02 <lambdabot> Num a => a -> a -> a
04:46:23 <pjdelport> It's exactly the same idea as (+) above, where the Num instance isn't chosen yet.
04:46:24 <sagittarian> @pl \x -> join x >>=
04:46:24 <lambdabot> (line 1, column 17):
04:46:25 <lambdabot> unexpected end of input
04:46:25 <lambdabot> expecting white space or simple term
04:46:29 <sagittarian> @pl \x -> join x >>= id
04:46:30 <lambdabot> join . join
04:46:46 <sagittarian> :t join . join
04:46:47 <lambdabot> Monad m => m (m (m a)) -> m a
04:46:55 <BoR0> I am trying to understand how (\x -> join x >>= (\x -> x)) equals to (\x -> x >>= join)
04:47:50 <sagittarian> :t (>>= join)
04:47:51 <lambdabot> Monad m => m (m (m b)) -> m b
04:48:00 <Axman6> so m there is (a ->)
04:48:27 <BoR0> is it using this instance?     h >>= f = \w -> f (h w) w
04:48:29 <Axman6> so you've got (a -> a -> a -> b) -> (a -> b) when you expAND M
04:48:30 <pjdelport> BoR0: There are few ways to see it.
04:48:30 <pjdelport> (f =<< x) == join (f <$> x)
04:48:35 <Axman6> expand m*
04:48:38 <pjdelport> BoR0: No, there is no instance yet.
04:49:04 <sagittarian> :t \x -> join x >>= (\x -> x))
04:49:06 <lambdabot> parse error on input ‘)’
04:49:09 <pjdelport> BoR0: The type signature still contains "Monad m => ...", which tells you that it's still polymorphic over any monad instance.
04:49:12 <sagittarian> :t \x -> join x >>= (\x -> x)
04:49:13 <lambdabot> Monad m => m (m (m b)) -> m b
04:49:18 <BoR0> pjdelport, oh, I see. in that case, how is >>= defined?
04:49:38 <sagittarian> uh that's not good
04:49:43 <sagittarian> :t \x -> join x >>= (\y -> y)
04:49:45 <lambdabot> Monad m => m (m (m b)) -> m b
04:49:56 <pjdelport> BoR0: Well, while you're generic over all Monads, >>= is only defined by the type class laws.
04:50:07 <BoR0> I thought so, that's good to know!
04:50:29 <BoR0> so we only have m a -> (a -> m b) -> m b
04:50:38 <BoR0> is this enough to show that both expressions are equivalent?
04:51:04 <pjdelport> BoR0: There are also a lot of relationships with other functions that matter.
04:51:36 <pjdelport> BoR0: For example, (>>= id) == join
04:51:53 <sagittarian> :t (>>= id) . join
04:51:54 <lambdabot> Monad m => m (m (m b)) -> m b
04:52:15 <sagittarian> @pointful (>>= id) . join
04:52:15 <lambdabot> (\ e -> (e >>= \ f -> f) >>= \ a -> a)
04:52:45 <BoR0> pjdelport, about that definition.. you are saying we have no instance of monad yet. where is (>>= id) == join defined in that case?
04:53:13 <BoR0> oh, that's the definition of join itself. ok
04:53:22 <pjdelport> BoR0: So one way to think of that equality above is that you're actually saying:  (>>= id) . join  ==  join . (>>= id)
04:54:06 <pjdelport> BoR0: Right, (>>= id) == join must hold for *all* Monads.
04:54:15 <pjdelport> (If it doesn't your Monad instance isn't valid.)
04:54:21 <BoR0> neat
04:54:49 <pjdelport> @src join
04:54:49 <lambdabot> join x = x >>= id
04:55:16 <sagittarian> @src concat
04:55:16 <lambdabot> concat = foldr (++) []
04:55:17 <BoR0> I can easily see how \x -> join x >>= id equals to join . join, but I can't see how \x -> x >>= join equals to join . join
04:55:32 <hexagoxel> join x >>= id  =join=  (x >>= id) >>= id  =MonadLaw=  x >>= (>>=id)  =join=  x >>= join
04:56:06 <BoR0> aha. looks like I've hit a monad law then?
04:56:10 <pjdelport> BoR0: Think of rewriting "\x -> x >>= join" as "\x -> x >>= join . id"
04:56:31 <sagittarian> if we have {x >>= join}, then x must be a triply nested monad, because that way join will get the doubly nested monad that it needs
04:56:32 <hexagoxel> (the law is: m >>= (\x -> k x >>= h)  ==  (m >>= k) >>= h")
04:56:47 <sagittarian> and then it will return an non-nested monad
04:57:02 <BoR0> pjdelport, ok, but how does that help me further?
04:58:13 * hackagebot systemd 1.0.0 - Systemd facilities (Socket activation, Notify)  http://hackage.haskell.org/package/systemd-1.0.0 (erebe)
04:58:19 <sagittarian> @pl \x -> x >>= join
04:58:19 <lambdabot> (join =<<)
05:07:39 <sagittarian> \x -> x >>= join == \x -> x >>= (>>= id)
05:08:20 <sagittarian> @pl \x -> x >>= (>>= id)
05:08:21 <lambdabot> (join =<<)
05:09:16 <BoR0> e.g. to show that (\x -> join x >>= id) is (join . join) all you need to use is join's definition... I don't know what to use for (\x -> x >>= join) tho
05:13:41 <SwashBuckla> @pl (join . join)
05:13:42 <lambdabot> join . join
05:13:48 <SwashBuckla> D:
05:18:16 <sagittarian> @pointful join . join
05:18:16 <lambdabot> (\ c -> (c >>= \ f -> f) >>= \ d -> d)
05:18:21 <sagittarian> oh we did that already
05:19:03 <hexagoxel> BoR0: my line above contains the answer..
05:19:25 <BoR0> hexagoxel, so it's a law?
05:21:14 <hexagoxel> the second step uses the mentioned monad law, yes (..?)
05:23:15 * hackagebot hsdev 0.1.2.4 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  http://hackage.haskell.org/package/hsdev-0.1.2.4 (AlexandrRuchkin)
05:23:32 <sagittarian> \x -> x >>= join === \x -> x >>= \y -> y >>= id === \x -> x >>= \y -> id y >>= id === \x -> (x >>= id) >>= id
05:24:22 <sagittarian> i don't think that applying laws are very helpful in getting an intuitive understanding of it though, i can apply laws all day and come up with the right answer but still not have any idea why
05:25:13 <sagittarian> @pl \x >>= id >>= id
05:25:14 <lambdabot> (line 1, column 4):
05:25:14 <lambdabot> unexpected ">"
05:25:14 <lambdabot> expecting operator, pattern or "->"
05:25:23 <sagittarian> @pl \x -> x >>= id >>= id
05:25:24 <lambdabot> join . join
05:27:05 <fizbin> :t listToMaybe
05:27:06 <lambdabot> [a] -> Maybe a
05:30:16 <sagittarian> > listToMaybe []
05:30:18 <lambdabot>  Nothing
05:30:39 <sagittarian> can you use the Data.Maybe functions to define a safeTail function?
05:32:14 <vanila> sagittarian, no
05:32:39 <Achylles> which are the advantages of writing shell scripts with haskell?
05:32:46 <Achylles> If any...
05:32:47 <BoR0> how hard is it to show uniqueness for Monad m => m (m (m b)) -> m b?
05:33:14 <zomg> sagittarian: if you mean a tail which doesn't error out on an empty list, sure. You could define safeTail :: [a] -> Maybe a
05:33:40 <zomg> err well not quite like that but you get the idea
05:33:42 <zomg> =)
05:34:36 <sagittarian> using the functions from Data.Maybe?
05:34:50 <sagittarian> similarly to how listToMaybe = safeHead
05:35:52 <zomg> Oh, not sure if you can do it like that
05:37:01 <sagittarian> BoR0, what do you mean by show uniqueness?
05:37:52 <BoR0> sagittarian, that join . join is the only function that satisfies that (if true...)
05:38:34 <sagittarian> you mean the only function that has that type?
05:38:38 <BoR0> yes
05:40:43 <sagittarian> :t map head . map head
05:40:44 <lambdabot> [[[b]]] -> [b]
05:40:46 <fizbin> Do you mean that type for arbitrary m, or for a specific monad?
05:40:58 <sagittarian> but that only works for lists
05:41:27 <sagittarian> @hoogle Monad m => m (m a) -> m a
05:41:28 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
05:41:28 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
05:41:28 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
05:46:12 <sagittarian> i think that join is the only function that has type m (m b) -> m b and works for any arbitrary monad, and from there you can see that join . join is the only completely general function of type m (m (m b)) -> m b
05:46:18 <sagittarian> but i just waved my hands a whole lot there
05:48:17 * hackagebot tidal 0.4.12 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.4.12 (AlexMcLean)
05:52:41 <vanila> :t join . join . return . join
05:52:43 <lambdabot> Monad m => m (m (m a)) -> m a
05:53:18 * hackagebot tidal-vis 0.1.7 - Visual rendering for Tidal patterns  http://hackage.haskell.org/package/tidal-vis-0.1.7 (AlexMcLean)
06:01:35 <aloiscochard> ok I understand that's quite a long shot... but I thought that was worth asking here
06:01:45 <aloiscochard> what is the best place to know about open haskell jobs/...?
06:03:51 <eriksensei> aloiscochard: this might be interesting? https://twitter.com/functionalworks
06:07:44 <aloiscochard> eriksensei: it is :-) ty
06:13:29 <eriksensei> aloiscochard: yw ;) would be sad to see you abandon the scala trenches though
06:18:20 * hackagebot bindings-portaudio 0.0.1 - Low-level bindings to portaudio library  http://hackage.haskell.org/package/bindings-portaudio-0.0.1 (FumiakiKinoshita)
06:19:32 <flyingfisch> tail gets the everything from an array except it's head, right? So x:xs, xs is the tail?
06:19:42 <flyingfisch> and last gets the last element in the list?
06:19:50 <tdammers> flyingfisch: yes
06:20:01 <flyingfisch> k
06:20:55 <flyingfisch> are there any must-have vim plugins for haskell?
06:21:12 <capisce> or haskell plugins for vim?
06:23:16 <aloiscochard> eriksensei: haha, that's kind mate but no worries, the typelevel initiative have invigorate my interest for scala, he'll always have a place in my heart! ;-)
06:23:40 <flyingfisch> capisce: lol, yeah, that's what I meant :)
06:24:08 <aloiscochard> flyingfisch: capisce: not exactly a vim plugin but you should *absolutely* try that https://github.com/aloiscochard/codex
06:24:18 <aloiscochard> </self-ad>
06:26:19 <flyingfisch> aloiscochard: forgive me, but what are ctags? I have heard of them in the past, but I forget what they are now :-\
06:26:27 <eriksensei> aloiscochard: good to hear :)
06:27:33 <yac> is there something like buildbot, jenkins or travis in haskell?
06:28:00 <tdammers> yac: why does it have to be in haskell?
06:28:08 * yac prefers haskell
06:28:25 <tdammers> you can use those things *for* haskell regardless
06:28:42 <yac> doesn't matter. I want it in haskell
06:28:46 <tdammers> mkay
06:28:51 <tdammers> don't know of any though
06:30:09 <eriksensei> tdammers: i once used gitweb, which is written in perl. then i had to change a couple of things. i still wake up screaming every other night.
06:31:52 <bernalex> what's a nice way to find the highest ranking element of a list?
06:32:06 <albeit> bernalex: maximum?
06:32:09 <bernalex> I can tell by the look of my last . last . sortBy (comparing length) . group . sort -- that this is not the smart way. ;-)
06:32:21 <bernalex> albeit: hoaw does that do it?
06:32:38 <albeit> bernalex: Based off the Ord instance, using "<="
06:32:51 <albeit> bernalex: What do you mean by "highest ranking"?
06:32:54 <bernalex> albeit: my point is that would be very wrong and not work
06:32:58 <tdammers> honestly, all the build and deployment frameworks I have tried so far are much more hassle to set up that just writing a fucking shell script yourself
06:33:09 <tdammers> and that's just to get you started
06:33:12 <bernalex> albeit: the highest ranking element of a list is the one that occurs the most times
06:33:29 <tdammers> after that, my own shell scripts are easy to maintain, because I know *exactly* how they work
06:33:47 <bernalex> albeit: for a list of numbers (which is where this is used mostly), if you have two numbers that appear N times, the highest valued number is the highest ranking
06:33:52 <yac> tdammers: shell scripts are the worst
06:34:06 <bernalex> so for [1, 2, 2, 3, 4] -- 2 is the highest ranking, but for [1, 4, 2, 2, 3, 4] -- 4 is the highest ranking.
06:34:26 <tdammers> yac: they're fine as long as what you're doing is automate a series of shell commands
06:34:52 <yac> no, they should not exist
06:35:09 <tdammers> why not? what else would you want?
06:38:21 * hackagebot acl2 0.0.0 - Writing and calling ACL2 from Haskell.  http://hackage.haskell.org/package/acl2-0.0.0 (TomHawkins)
06:40:50 <albeit> bernalex: You shouldn't need to sort, as you just need to find the maximum length and maximum number. Possible folding into an IntMap and then selecting keys with maximum length, then the maximum of those keys?
06:41:33 <albeit> [1,4,2,2,3,4] -> fromList [(1,1), (2,2), (3,1), (4,2)]
06:43:22 * hackagebot call 0.0.1 - The call game engine  http://hackage.haskell.org/package/call-0.0.1 (FumiakiKinoshita)
06:44:58 <albeit> :t \l -> fst . M.findMax $ M.filter (== (maximum $ Map.elems l)) l
06:44:59 <lambdabot>     Not in scope: ‘Map.elems’
06:44:59 <lambdabot>     Perhaps you meant ‘M.elems’ (imported from Data.Map)
06:45:06 <albeit> :t \l -> fst . M.findMax $ M.filter (== (maximum $ M.elems l)) l
06:45:07 <lambdabot> Ord b => M.Map c b -> c
06:45:57 <aloiscochard> flyingfisch: ctags is historically a "tagger" for C, basically it create a file that list all "symbols" and the reference to them
06:46:07 <aloiscochard> flyingfisch: so you can "jump to definition" in your editor
06:51:15 <eriksensei> aloiscochard: looks interesting! what other tools do you use alongside codex?
06:51:55 <aloiscochard> eriksensei: very simple at the moment: https://github.com/aloiscochard/configurations/tree/master/.vim/bundle/haskell
06:51:56 <albeit> > fst . M.findMax . M.filter (== (maximum $ M.elems l)) $ foldr (\n m -> M.insert n ((M.findWithDefault 0 n m)+1) m) M.empty [1,4,2,2,3,4]
06:51:58 <lambdabot>  Couldn't match expected type ‘Data.Map.Base.Map k0 b0’
06:51:58 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’
06:52:23 <aloiscochard> eriksensei: I'm working on an other tool, to automate running test (a la sbt), but that is not ready yet (http://github.com/aloiscochard/velox)
06:52:50 <eriksensei> cool, thanks!
06:53:40 <eriksensei> aloiscochard: the documentation is still a bit sparse ;)
06:54:03 <aloiscochard> eriksensei: lol, yeah it's totally unusable atm, even by me!
06:54:08 <RegEchse> > fst $ maximumBy (compare `on` snd) $ M.toList $ foldr (\ x m -> M.insertWith (+) x 1 m) M.empty $ [1,2,3,1,4,2,2,6]
06:54:10 <lambdabot>  2
06:54:48 <eriksensei> aloiscochard: ah, it /is/ rather like sbt then ;)
06:55:03 <aloiscochard> eriksensei: :-D true
06:55:11 <RegEchse> albeit, bernalex  ^
06:55:53 <albeit> > fst $ maximumBy (compare `on` snd) $ M.toList $ foldr (\ x m -> M.insertWith (+) x 1 m) M.empty $ [1,2,3,1,4,2,6,4]
06:55:55 <lambdabot>  4
06:56:00 <albeit> RegEchse: Cool!
06:56:40 <RegEchse> well, if the list has Ord elements at least. :)
06:57:46 <albeit> > foldr (\x m -> M.insertWith (++) x [] m) M.empty $ [1,2,3,1,4,2,6,4]
06:57:48 <lambdabot>  fromList [(1,[]),(2,[]),(3,[]),(4,[]),(6,[])]
06:59:23 <albeit> RegEchse: How does the insertWith know to start from 0?
06:59:45 <vanila> How does the haskell compiler turn pattern matches into case expressions?
07:01:41 <albeit> > foldr (\ x m -> M.insertWith (+) x 1 m) M.empty $ [1,2,3,1,4,2,6,4]
07:01:43 <lambdabot>  fromList [(1,2),(2,2),(3,1),(4,2),(6,1)]
07:02:11 <lf94> (\ ) indicates lamba, correct?
07:03:29 <lf94> vanila: look at source
07:03:48 <flyingfisch> lf94: yes
07:03:54 <RegEchse> albeit: it doesn't. If the key doesn't exist yet, it's simply filled in with the value (and the function isn't used)
07:03:56 <vanila> lf94, that is not helpful
07:04:17 <flyingfisch> why would you use a where statement instead of a let expression?
07:04:30 <albeit> RegEchse: So for 3 above, the value at 3 key is (1+), but why does it output it as 1?
07:04:49 <albeit> RegEchse: Oh nevermind, misread what you said
07:05:46 <albeit> > foldr (\x m -> M.insertWith (++) x [x] m) M.empty $ [1,2,3,1,4,2,6,4]
07:05:48 <lambdabot>  fromList [(1,[1,1]),(2,[2,2]),(3,[3]),(4,[4,4]),(6,[6])]
07:06:02 <RegEchse> :)
07:06:30 <albeit> So it's basically the "defaultdict" / default map of Haskell, I've been doing that crudely my own for a while, nice to know this better way
07:17:46 <albeit> :t \_ -> return ()
07:17:47 <lambdabot> Monad m => t -> m ()
07:18:24 * hackagebot antagonist 0.1.0.24 - A web interface to Antisplice dungeons.  http://hackage.haskell.org/package/antagonist-0.1.0.24 (implementation)
07:18:56 <albeit> :t void . pure
07:18:57 <lambdabot> Applicative f => a -> f ()
07:19:18 <albeit> Is that the simplest way to acheive (\_ -> return ())? ^
07:20:27 <Clint> define "simplest"
07:21:05 <Guest83069> hello
07:21:29 <albeit> Client: Let's just say no lambda use, and succinct
07:21:43 <albeit> *Clint
07:22:01 <lf94> :t return
07:22:02 <lambdabot> Monad m => a -> m a
07:22:39 <Guest83069> I'm trying to implement my own Foldl, but I'm getting some errors. http://i.imgur.com/kr9CRJ0.png
07:22:44 <lf94> albeit: why not just use return()
07:23:00 <Guest83069> can some one tell me whats wrong with that function?
07:23:05 <albeit> lf94: I need ":: a -> f()", not ":: a -> f a"
07:23:11 <Clint> const
07:23:16 <lf94> Ah
07:23:52 <lf94> f = return(), yeah? :D
07:23:57 <bennofs> albeit: pure (pure ())
07:24:05 <lf94> :t f = return()
07:24:06 <lambdabot> parse error on input ‘=’
07:24:18 <bennofs> :t pure . pure $ () :: Applicative f => a -> f ()
07:24:20 <lambdabot> Applicative f => a -> f ()
07:24:42 <BoR0> Guest83069, f :: a -> b -> a, and v :: b. you have an error in the type signature
07:24:49 <lf94> I feel like there is a huge separation between haskell beginners and intermediate/more advanced haskell programmers
07:25:04 <lf94> Is that just me or is this how the haskell scene is
07:25:09 <BoR0> namely, you try to apply (f v x) :: a to v :: b
07:26:05 <albeit> lf94: I agree. But the path from beginner to intermediate is pretty gradual, especially with the guys and girls on here being pretty helpful in explaining stuff
07:26:27 <lf94> Yes, this channel is a huge help
07:26:54 <lf94> Whoever figures out haskell completely on their own is pretty much a self declared genius
07:27:06 <lf94> or they aren't familiar with traditional programming
07:27:22 <Guest83069> BoR0, I don't get it
07:27:40 <vanila> if you appreciate the helpfulness of the channel pass it along
07:27:53 <lf94> I do when I can :)
07:27:56 <Guest83069> can you show me how it should be done?
07:29:04 <BoR0> Guest83069,  changing the type signature to myFoldl :: (a -> b -> a) -> b -> [b] -> a should be sufficient. the thing is that (a -> b -> a) is a function that takes an a and a b, and returns an a. but you expect an a
07:29:29 <BoR0> err, changing it to myFoldl :: (a -> b -> a) -> a -> [b] -> a
07:30:05 <BoR0> another problem is line 45, you return an empty list where you should return just v instead
07:30:16 <lf94> boR0 is destroying your hopes
07:30:19 <lf94> B)
07:30:55 <Guest83069> Oh, you're right :P
07:31:03 <BoR0> lf94, why? :)
07:31:28 <Guest83069> it works now :P
07:31:47 <lf94> BoR0: just making sarcastic remarks
07:31:50 <Guest83069> thanks for the help
07:32:05 <lf94> was waiting for a list of corrections
07:32:07 <Guest83069> my hope remains
07:32:14 <lf94> good, good!
07:32:24 <BoR0> Guest83069, you can use @src on this channel, e.g. "@src foldl". also if you are unsure about the type signatures you can check them by writing :t myFoldl and not supplying them in the code
07:32:26 <lf94> i find my hope with haskell fades quickly
07:32:35 <lf94> it's been getting better though
07:32:47 <Guest83069> @src foldl
07:32:48 <lambdabot> foldl f z []     = z
07:32:48 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
07:33:33 <Guest83069> there's no need to match the pattern with the singleton list?
07:33:42 <BoR0> [x] is (x:[]), so it will pattern match on (x:xs)
07:33:44 <Guest83069> (x:xs) can be matched to x:[] ?
07:33:50 <Guest83069> right
07:34:49 <BoR0> :t foldl
07:34:50 <lambdabot> (b -> a -> b) -> b -> [a] -> b
07:39:44 <Guest83069> @src foldr
07:39:44 <lambdabot> foldr f z []     = z
07:39:45 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:39:55 <Forkk> hahahaha https://hackage.haskell.org/package/lens-4.4.0.2/docs/Control-Lens-Combinators.html
07:40:09 <Forkk> "This lets the subset of users who vociferously disagree about the full scope and set of operators that should be exported from lens to not have to look at any operator with which they disagree."
07:40:24 <Guest83069> anyone uses SublimeHaskell?
07:41:07 <Guest83069> I get an error on the ModuleInspector
07:41:21 <Guest83069> H.PNeg, if I'm not mistaken
07:55:43 <edwardk> Forkk: hrmm extra 'to' in that sentence. gotta patch it now =)
07:55:49 <Forkk> lol
07:56:24 <Forkk> edwardk, not an extra 'to', it's just the wrong 'to'
07:56:27 <Forkk> should be 'too'
07:57:05 <edwardk> i mean s/lens to not/lens not/
07:59:29 <Forkk> oh wait it shouldn't be too
07:59:40 <Forkk> I don't know why I thought that .-.
08:00:08 <Forkk> my grammars be broke today
08:02:42 <thetallguy> anyone know  a simple way to force console output from separate threads to interleave line by line, not char by char?
08:03:48 <silver> thetallguy, logger thread?
08:03:59 <Forkk> have one thread responsible for writing output
08:04:13 <Forkk> and the other threads send output to it over a channel
08:04:57 <thetallguy> Forkk: okay, that was my guess, thanks
08:05:06 <Forkk> no problem
08:19:02 <zwer_c> DisambiguateRecordFields doesn't have effect when updating fields on an object. is there an extension that does?  obj { field = newValue }
08:20:19 <zwer_c> (I am getting Ambiguous occurrence 'field', and I have to fully qualify it, Module.field)
08:23:33 <albeit> With attoparsec, is there any way to parse a decimal from the next three bytes, and explicitly stop parsing after three bytes?
08:28:07 <srhb> albeit: If the tokens are Char8 you can start by getting three anyWord8 and then try to parse that as a decimal?
08:28:41 <srhb> Er, s/Char8/Word8
08:34:07 <bernalex> hm. what would be a nicer way to do this
08:34:09 <bernalex> λ doubleEveryOther . digits $ 8675309
08:34:10 <bernalex> erm
08:34:18 <bernalex> not that
08:34:47 <bernalex> but: \n -> if n * 2 > 9 then sum . digits $ n * 2 else n * 2
08:36:26 <ReinH> let m = n * 2 for starters
08:36:49 <bernalex> ReinH: meh :-P
08:37:00 <bernalex> did have that originally
08:37:02 <ReinH> also it's always sum . digits
08:37:37 <bernalex> what?
08:37:40 <ReinH> sum . digits $ 9 = 9
08:37:57 <bernalex> sure, I guess
08:39:17 <ReinH> so sum . digits . (*2)
08:39:48 <EvanR> > digits 1234
08:39:51 <lambdabot>  Not in scope: ‘digits’
08:39:51 <lambdabot>  Perhaps you meant one of these:
08:39:51 <lambdabot>    ‘BSC.inits’ (imported from Data.ByteString.Char8),
08:39:51 <lambdabot>    ‘BSLC.inits’ (imported from Data.ByteString.Lazy.Char8),
08:39:51 <lambdabot>    ‘inits’ (imported from Data.List)
08:41:12 <bernalex> ReinH: ah yeah of course duhh. thanks!
08:41:37 <recursion-ninja> @djinn (Functor f, Functor f1) => (a -> b -> c) -> f a -> f b -> f c
08:41:37 <lambdabot> Error: Class not found: Functor
08:43:18 <ReinH> Djinn doesn't know about functors.
08:43:32 <ReinH> :t liftA2
08:43:33 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
08:43:53 <ReinH> also you need Applicative.
08:46:25 <ysz> anybody has link to ePUB of RWH handy?
08:49:07 <srhb> ysz: Google gives some results for epub real world haskell
08:49:31 <ysz> yeah i tried one of those and it has crap formatting
08:49:57 <srhb> Ok. :)
08:50:02 <ysz> might as well just buy one from orailly by now...
08:51:39 <srhb> Oh, the epub is nonfree? That explains.
09:02:06 <dermot> what's the appropriate base case for trying to do something like return the last element of an empty list?
09:02:36 <sagittarian> :t fail
09:02:37 <lambdabot> Monad m => String -> m a
09:02:45 <sagittarian> :t error
09:02:46 <lambdabot> [Char] -> a
09:03:03 <ysz> srhb, yeah. but HTML is free so i thought maybe someone made free ePUB out of it
09:03:04 <sagittarian> dermot, maybe Maybe, maybe
09:03:27 <dermot> ok so it's like [a] -> Maybe a
09:09:35 <sagittarian> dermot, sounds reasonable
09:09:44 <sagittarian> @let let digits = map (`mod` 10) . takeWhile (> 0) . iterate (`div` 10)
09:09:44 <lambdabot>  Parse failed: Parse error: EOF
09:09:55 <sagittarian> @let digits = map (`mod` 10) . takeWhile (> 0) . iterate (`div` 10)
09:09:58 <lambdabot>  Defined.
09:10:06 <sagittarian> > digits 956326212
09:10:07 <vanila> last [] = Nothing ; last [x] = Just x ; last (x:xs) = last xs
09:10:08 <lambdabot>  [2,1,2,6,2,3,6,5,9]
09:12:15 <sagittarian> @let digitsInBase b = map (`mod` b) . takeWhile (> 0) . iterate (`div` b)
09:12:17 <lambdabot>  Defined.
09:12:38 <sagittarian> digitsInBase 2 63
09:12:46 <sagittarian> > digitsInBase 2 63
09:12:47 <lambdabot>  [1,1,1,1,1,1]
09:13:23 <sagittarian> @pl \b -> map (`mod` b) . takeWhile (> 0) . iterate (`div` b)
09:13:23 <lambdabot> ap ((.) . map . flip mod) ((takeWhile (> 0) .) . iterate . flip div)
09:15:10 <srhb> > map (\c -> read [c]) . show $ 12345 :: [Int] -- Math is overrated for base10
09:15:12 <lambdabot>  [1,2,3,4,5]
09:15:26 <sagittarian> that's cheating
09:15:29 <srhb> :-)
09:15:40 <srhb> Cheating is my favourite thing!
09:16:58 <vanila> cheaters always win
09:17:13 <vanila> there's a nice solution with unfoldr too
09:17:29 <recursion-ninja> very slick
09:17:48 <sagittarian> vanila, care to share?
09:18:11 <recursion-ninja> @djinn (Functor f, Functor f1) => (a -> b -> c) -> f a -> f b -> f c
09:18:12 <lambdabot> Error: Class not found: Functor
09:18:27 <recursion-ninja> why does Djinn  say class not found? ^^^
09:18:39 <recursion-ninja> @djinn (Functor f) => (a -> b -> c) -> f a -> f b -> f c
09:18:40 <lambdabot> Error: Class not found: Functor
09:18:55 <vanila> > reverse . unfoldr (\n -> if n == 0 then Nothing else Just (let (p,q) = divMod n 10 in (q,p))) $ 231124
09:18:57 <lambdabot>  [2,3,1,1,2,4]
09:19:18 <ClaudiusMaximus> recursion-ninja: because the @djinn-env doesn't contain it
09:19:29 <recursion-ninja> how would I addit?
09:19:38 <recursion-ninja> on my local copy of Djinn
09:19:38 <sagittarian> :t unfoldr
09:19:40 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
09:20:34 <EvanR> haha recursion-ninja nice nick
09:20:53 <recursion-ninja> ty\
09:23:35 * hackagebot twentefp-eventloop-graphics 0.1.0.3 - Used as Lab Assignments Environment at Univeriteit Twente  http://hackage.haskell.org/package/twentefp-eventloop-graphics-0.1.0.3 (sebaslafleur)
09:27:33 <sagittarian> what is the most interesting to search for on github within haskell code?
09:28:03 <recursion-ninja> Could anyone tell me how to get Djinn's environment to have the Functor typeclass loaded?
09:28:06 <recursion-ninja> example:
09:28:09 <recursion-ninja> @djinn (Functor f) => (a -> b -> c) -> f a -> f b -> f c
09:28:10 <lambdabot> Error: Class not found: Functor
09:29:26 <vanila> recursion-ninja, djinn cannot do typeclasses
09:33:06 <ReinH> recursion-ninja: it can't.
09:33:36 * hackagebot wai-static-cache 0.1.0.1 - A simple cache for serving static files in a WAI middleware  http://hackage.haskell.org/package/wai-static-cache-0.1.0.1 (HugoGomes)
09:33:48 <recursion-ninja> vanilla: I was unaware of the restriction, that's a little disheartening...
09:34:19 <recursion-ninja> vanilla: Thanks for the info, I'm no longer confused!
09:35:23 <vanila> recursion-ninja, you could use a tool like Coq (after some learning) to automatically find functions given types including typeclasses
09:35:32 <fizbin> @pl \a b c -> a <$> b <*> c
09:35:32 <lambdabot> (. (<*>)) . (.) . (<$>)
09:35:34 <ReinH> recursion-ninja: besides which, I think I mentioned that that function is impossible. You need Applicative.
09:35:44 <ReinH> fizbin: liftA2? :p
09:36:05 <fizbin> :t \a b c -> a <$> b <*> c
09:36:06 <lambdabot> Applicative f => (a1 -> a -> b) -> f a1 -> f a -> f b
09:36:22 <ReinH> :t liftA2
09:36:23 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
09:36:24 <ReinH> :p
09:36:44 <fizbin> Are there any good examples of Functors that aren't Applicative?
09:37:26 <fizbin> For Applicative that isn't Monad, my go-to example is ZipList. But I don't have a standard example to use for Functors not Applicative.
09:38:03 <sagittarian> @instances Functor
09:38:04 <lambdabot> ((,) a), ((->) r), ArrowMonad a, ContT r m, Either a, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
09:38:09 <sagittarian> @instances Applicative
09:38:10 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
09:38:26 <sagittarian> @instances-importing Control.Applicative Applicative
09:38:27 <lambdabot> ((,) a), ((->) a), ArrowMonad a, Const m, ContT r m, Either e, ErrorT e m, IO, Maybe, ReaderT r m, ST s, StateT s m, WrappedArrow a b, WrappedMonad m, WriterT w m, ZipList, []
09:39:03 <pjdelport> fizbin: Maps
09:39:12 <sagittarian> RWST apparently
09:39:43 <sagittarian> what's RWST, reader writer state transformer?
09:39:51 <fizbin> Map. That's a good one.
09:40:55 <pjdelport> Map is applicative without "pure", though.
09:41:31 <sagittarian> what does that mean, pjdelport?
09:42:09 <pjdelport> http://hackage.haskell.org/package/semigroupoids-4.2/docs/Data-Functor-Apply.html#g:2
09:43:29 <pjdelport> A Map does not have a distinguished "identity" structure that you can can use with "pure", but you can apply a Map of functions to a Map of values.
09:44:59 <pjdelport> The above package calls that Apply, which you can think of as sitting between the usual Functor and Applicative
09:45:28 <pjdelport> That Apply is also the common base of Applicative/Monad and Coapplicative/Comonad
09:45:33 <pjdelport> Which is a nice way to view things.
09:47:00 <supki> fizbin: data Void1 a
09:47:36 <ReinH> Apply is nice. Pointed is nearly useless.
09:48:37 * hackagebot dirfiles 0.1.0.9 -   http://hackage.haskell.org/package/dirfiles-0.1.0.9 (HugoGomes)
09:48:40 <ReinH> Although I've seen a case made for Buildable as the (obvious?) dual to Foldable, which serves a similar purpose and actually has some laws
09:48:53 <ReinH> not dual to, adjoint to
09:49:02 <ReinH> https://www.fpcomplete.com/user/gbaz/building-up-to-a-point-via-adjunctions
09:49:07 <fizbin> supki: How is that not also Applicative?
09:50:13 <ReinH> fizbin: Const
09:51:36 <fizbin> ReinH: Specifically though, Const x where "x" is not a Monoid.
09:52:16 <supki> fizbin: there's no  pure :: a -> Void1 a
09:58:56 <fizbin> supki: Okay, fair enough.
09:59:07 <albeit> Question, phrasing might be confusing... I have an IntMap, and when a specific set of Ints are in the IntMap keys, it is a specific "type" (not Haskell type). Is there any way to formalize this into the Haskell type system, so the type-checker can validate those specific IntMaps?
10:00:02 <recursion-ninja> albeit: smart constructors maybe?
10:00:12 <johnw> albeit: You could create a type out of a set of keys
10:00:25 <pjdelport> albeit: That sounds like a job for dependent typing.
10:00:36 <johnw> and then have a constructor for another type that takes an IntMap and such a set
10:00:40 <pjdelport> You can do some things along those lines in Haskell, though.
10:01:09 <pjdelport> albeit: What kind of type or structure information do you need to keep track of, exactly?
10:01:15 <johnw> but verifying that the map actually does contain those keys will be tricky in Haskell at compile-time
10:01:57 <sagittarian> is there an easy way to have more than one version of ghc installed at a time?
10:02:09 <vyorkin1> hi everyone! could anyone give me please an example of using regex in Haskell? i've tried some snippets from "Real world Haskell" book - no luck. I'm using regex-posix. So i'm trying to do just a simple thing like: "bar" =~ "(foo|bar)" :: Bool
10:02:18 <albeit> pjdelport: I'd like to have a type  "IntMapFoo", that I can pass around, that is guaranteed to have a specific set of keys... is that what you mean by structure information?
10:02:28 <pjdelport> albeit: Ah, that could be doable.
10:03:10 <pjdelport> albeit: You could use smart constructors with newtype wrapper, or with phantom types, or such.
10:03:11 <albeit> johnw: How can I make a type from a set of specific keys?
10:04:01 <pjdelport> albeit: How will you be using it? Would a newtype be what you want, or would it be cumbersome? (I'm guessing the latter?)
10:04:18 <vyorkin1> so, in ghci :m Text.Regex.Posix and "bar" =~ "(foo|bar)" :: Bool, this gives me "No instance for (Data.String.IsString source10) ..."
10:04:40 <albeit> pjdelport: Not sure at this point. I would like to be able to use the IntMap functions, but I could rewrite the necessary ones for a newtype I guess.
10:04:57 <vyorkin1> how can i fix this? am i missing smth? i have multiple regex backends installed: posix, pcre, tdfa
10:05:09 <albeit> But sounds like I need to check out smart constructors
10:05:25 <pjdelport> albeit: Ah, you'll probably need some kind of wrapper to keep track of the extra type information.
10:05:32 <vyorkin1> maybe i could point me to some good tutorial/docs?
10:05:41 <pjdelport> albeit: You can always unwrap the IntMap to use normal functions on it, though.
10:06:19 <albeit> pjdelport: Okay. By extra type information do you mean the required keys?
10:06:32 <albeit> (In some kind of type form)
10:06:44 <pjdelport> albeit: Right, however you actually end up representing them.
10:09:05 <pjdelport> albeit: The simplest possible thing is something like: newtype IntMapFoo a = IntMapFoo { fromFoo :: IntMap a }
10:09:18 <pjdelport> albeit: And then you can have a funtion like: toFoo :: Map a -> Maybe (IntMapFoo a)
10:09:22 <pjdelport> function, even
10:09:49 <pjdelport> where your module will only export toFoo, and not the actual IntMapFoo constructor.
10:10:04 <pjdelport> So client code can only use toFoo, which does the dynamic checks to see that the keys are there, etc.
10:10:24 <pjdelport> So in this case, the IntMapFoo type wrapper represents the result of the check at the type level.
10:10:27 <albeit> pjdelport: But those are runtime dynamic checks, not compile time type checks right?
10:11:02 <pjdelport> Yes, but it's only done once: after that, it's persisted at the type level.
10:11:22 <pjdelport> So if you have a function from IntMapFoo, you know from the type that the keys have already been checked.
10:12:15 <albeit> Ah okay. But if I try to to use toFoo with a bad IntMap, it will only catch that at runtime... type-checker will still pass
10:12:37 <pjdelport> Well, you will have to handle the bad case.
10:12:56 <pjdelport> That's why it only returns a Maybe (IntMapFoo a)
10:13:36 <pjdelport> You could also have smarter type constructors, though.
10:13:39 * hackagebot chart-histogram 0.4.2 - Easily render histograms with Chart  http://hackage.haskell.org/package/chart-histogram-0.4.2 (BenGamari)
10:14:04 <albeit> Got it. So it takes care of 90% of the type-checking, except when that Map is first created. Which is definitely better than what I'm doing now
10:14:15 <pjdelport> For example, if it's a small set of values with known keys, you could for example have a function of type a -> a -> a -> IntMapFoo a
10:14:56 <pjdelport> (That would take 3 values and assign them to known keys, giving you a guaranteed IntMapFoo.)
10:15:21 <pjdelport> So it depends on exactly what you have, yeah.
10:15:35 <ReinH> pjdelport: o/
10:15:43 <pjdelport> ReinH: Ahoy!
10:17:16 <albeit> Is there a chance I would be able to type-ify that kind of restricted IntMap with type arithmetic?
10:17:41 <pjdelport> type arithmetic?
10:18:05 <pjdelport> albeit: It might help to give a concrete example: there are *many* things that you can do, and a lot of them depend on what exactly you want to do. :)
10:18:26 <albeit> pjdelport: Fair enough, I'll have to re-ask when I know more clearly what I need. Thanks for the help!
10:19:02 <pjdelport> albeit: The first extension you can have to the above is using "phantom" type variables to keep track of more than one kind of tagged map.
10:19:42 <pjdelport> So instead of IntMapFoo, you might have: newtype TaggedIntMap t a = ...
10:20:08 <pjdelport> where 't' isn't used in the body of the type at all: it only exists at the type level.
10:20:51 <pjdelport> Then, you can have types like TaggedIntMap Foo a and TaggedIntMap Bar a, and so on, for multiple "types" of IntMap.
10:21:28 <albeit> Okay. Is "t" considered a promoted data type? (The whole -XDataKinds thing?)
10:21:51 <pjdelport> And you can write functions that only work with say Foo IntMaps (TaggedIntMap Foo a -> ...), or that convert one type of tagged IntMap to another (with the types checked), and so on.
10:21:57 <pjdelport> albeit: It doesn't need to be.
10:22:25 <pjdelport> DataKinds lets you make the tag be kind-checked at the type level, though, which is nice.
10:23:31 <pjdelport> Without DataKinds, the tag can be *any* type value (of kind *): so you could have TaggedIntMap Int a or so on, even if that doesn't make sense.
10:24:36 <pjdelport> DataKinds lets you restrict that so that you can only use a specific promoted data type as the tag (for example, only Foo and Bar, if you had data MyTag = Foo | Bar)
10:25:20 <albeit> Ah, so it would type-checking the type-checking! Sorta
10:25:27 <pjdelport> So DataKinds is for better type checking (or kind checking) at the type level :)
10:25:29 <albeit> kind-checking I guess
10:25:32 <pjdelport> albeit: Yes, exactly that.
10:26:30 <pjdelport> albeit: Now, in theory, you can get even fancier with data kinds, and encode the *actual* structure in the type argument.
10:27:15 <pjdelport> In other words, the actual keys, instead of a symbolic tag like Foo or Bar
10:27:29 <pjdelport> But someone else can maybe explain more about that.
10:27:44 <albeit> If I had a function that took a "TaggedIntMap t a", could I pattern match on the type/kind "t"?
10:28:00 <pjdelport> (And whether that approach is better really depends a lot: having explicit symbolic tags may suit the intent of your problem better?)
10:28:30 <pjdelport> albeit: Pattern match in what sense exactly?
10:28:42 <pjdelport> albeit: You can declare a function as just accepting a certain value for t, yes.
10:29:06 <albeit> foo :: TaggedIntMap t a -> Bool; foo (TaggedIntMap Foo a) = ...
10:29:16 <pjdelport> But 't' only exists at compile time, so at runtime, there's nothing to inspect.
10:29:25 <albeit> Ah actually I see that wont work
10:30:19 <albeit> But I can't declare a function as accepted all t, because if I ever want to do something in the function that requires a specific t, it is not longer all t...
10:30:58 <albeit> But that function would still be able to do anything that is valid for all t?
10:31:25 <pjdelport> albeit: You can declare a function that accepted all t, but then you can't directly inspect it.
10:31:33 <albeit> Got it, okay
10:31:35 <pjdelport> Right.
10:31:45 <pjdelport> And importantly, the result that it returns will still have the same tag.
10:32:03 <pjdelport> So you can use that to write polymorphic functions that preserve the tag and don't require re-checking the property all the time.
10:32:27 <pjdelport> (Obviously, said function would have to promise not to change the keys in a way that violates the tag, though.)
10:33:04 <pjdelport> The general idea is that you would use the phantom type tags to build up a vocabulary of constraints and properties that you want to keep track of, and that suits your problem.
10:33:40 * hackagebot bspack 0.0.1 - A simple and fast bytestring packer  http://hackage.haskell.org/package/bspack-0.0.1 (nicolasdp)
10:34:42 <albeit> Sounds good. Just saved this entire convo for future reference ;)
10:34:52 <albeit> :q
10:35:23 <pjdelport> albeit: You can get fancier than the above in many ways, though.
10:36:01 <pjdelport> The way to get the equivalent of value-level case matching for the type tag would be to write a type class with different instances for each tag.
10:36:56 <pjdelport> (as far as i understand it)
10:37:09 <adas> im on a brand new installation of ghc and cabal. created a sandbox. tried doing "cabal install persistent persistent-sqlite persistent-template ghc-mod" and it tries to install a version of ghc-mod 3 years old (version 0.3).
10:37:21 <adas> could someone tell me why this is happening?
10:37:25 <pjdelport> So then you might have: instance Frobable TaggedIntMap Foo a where ...
10:37:38 <pjdelport> and a different instance for TaggedIntMap Bar a
10:37:50 <adas> its a brand new install of cabal, ghci and everything
10:38:05 <pjdelport> And then the function(s) in the type class can accept and do different things for TaggedIntMap with different tags.
10:38:44 <supki> adas: how did you install ghc?
10:39:43 <adas> just used the docker container by "darinmorrison/haskell"
10:39:55 <adas> supki: https://github.com/darinmorrison/docker-haskell
10:40:46 <adas> supki: in any case this is not particular to this container. because i have a another container with a base version of ubuntu 14.04 and manually installed ghc, cabal, happy, alex..
10:40:52 <adas> supki: had the same problem there as well
10:41:10 <zq> how to avoid cabal file build-depende repetition
10:42:11 <adas> is it possible that one of the dependencies needed by one of the persistent packages or persistent itself need ghc-mod 0.3?
10:43:55 <supki> adas: I doubt it
10:44:21 <supki> adas: can you try the same cabal-install command with  --constraint='ghc-mod > 0.3.0' ?
10:44:28 <adas> supki: just did
10:44:49 <adas> supki: now it says.. it will install mtl 2.1.3.1 although 2.2.1 exists
10:45:27 <adas> supki:  cabal install --dry-run --enable-documentation persistent persistent-sqlite persistent-template ghc-mod==5.1.0.2
10:45:33 <adas> supki: thats the exact command I used
10:45:53 <adas> okay ill try with '>'
10:48:02 <adas> supki: cabal install --dry-run --enable-documentation --constraint='ghc-mod > 0.3.0' persistent persistent-sqlite persistent-template
10:48:08 <adas> that seems to work though
10:48:09 <adas> why?
10:48:39 <adas> when i did ghc-mod==5.1.0.2 .. thats a constraint too?
10:48:42 * hackagebot hsdev 0.1.2.5 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  http://hackage.haskell.org/package/hsdev-0.1.2.5 (AlexandrRuchkin)
10:49:26 <phaazon> is there people on codewars here?
10:49:34 <phaazon> I discovered that a few hours ago
10:49:44 <phaazon> there’re a few interesting exercices :)
10:49:49 <phaazon> exercises*
10:50:14 <adas> supki: false alarm. don't think that worked
10:50:27 <adas> with the --constraint flag it doesn't even choose to install ghc-mod
10:52:34 <__jim__> Hey guys, I'm having an issue with building ghc 7.8.3 on Fedora 19. I'm having an issue after running configure, when running sudo make install, and this is the error: "make -r --no-print-directory -f ghc.mk install BINDIST=YES NO_INCLUDE_DEPS=YES
10:52:35 <__jim__> "rm" -f utils/ghc-pkg/dist-install/build/Version.hs
10:52:35 <__jim__> echo "module Version where"                    >> utils/ghc-pkg/dist-install/build/Version.hs
10:52:35 <__jim__> /bin/sh: utils/ghc-pkg/dist-install/build/Version.hs: Permission denied
10:52:38 <__jim__> make[1]: *** [utils/ghc-pkg/dist-install/build/Version.hs] Error 1
10:52:39 <geekosaur> that command looks wrong to me. ghc-mod is not a dependency of the persistent modules you named so it would ignore the constraint. unless you also added ghc-mod to the end
10:52:41 <__jim__> make: *** [install] Error 2"
10:52:47 <__jim__> wow wall of text, sorry about that
10:53:07 <geekosaur> @paste
10:53:07 <lambdabot> Haskell pastebin: http://lpaste.net/
10:54:06 <geekosaur> that looks like either you did something wrong with the sudo, or selinux stuck its fingers in somewhere
10:54:11 <__jim__> try this : http://lpaste.net/111633
10:54:20 <kazagistar> I want to read lines from stdin until EOF using using Text... I wanted to do something like data <- mapM myparser TIO.getLine, but I need to throw a "hIsEOF" in there somewhere I think? Should I just do the recursive loop manually?
10:54:32 <adas> geekosaur: now i did this " cabal install --dry-run --enable-documentation --constraint='ghc-mod>0.3.0' persistent persistent-sqlite persistent-template ghc-mod"
10:54:48 <adas> geekosaur: same problem.. now it wants to install mtl 2.1.3.1
10:55:12 <geekosaur> --constraint='mtl installed'
10:55:41 <adas> geekosaur: what does that mean?
10:55:50 <adas> assume mtl is installed?
10:55:58 <RyanGlScott> __jim__: See if SELinux is enabled: sestatus -v
10:56:07 <geekosaur> require that an installed version be used, don't try to install a different one, adjust other versions as needed
10:56:32 <__jim__> looks like SELinux is disabled
10:56:41 <__jim__> how would I mess up sudo when running make?
10:56:50 <zwer> is there a DisambiguateRecordFields equivalent that also works for updating record fields?
10:56:51 <geekosaur> ...if you don't have some version of mtl installed then you almost certainly want to let one be installed
10:58:21 <adas> geekosaur: its a sandbox.. so i don't have any packages installed
10:58:36 <adas> geekosaur: so are you saying i should install mtl in the sandbox first and then install the rest?
10:58:55 <geekosaur> adas: (a) global packages are visible in the sandbox (b) mtl is a dependency of many, many things
10:59:30 <geekosaur> if your global package database doesnt have mtl then you probably need to install it in the sandbox
10:59:42 <geekosaur> and I am not sure why you'd consider it a problem
10:59:54 <adas> geekosaur: i know (a). and at the moment global package database does not have mtl
11:01:17 <adas> geekosaur: when i try to install persistent persistent-template persistent-sqlite and ghc-mod>0.3.0 it resolves to installing mtl 2.1.3.1 when the latest version is of mtl is 2.2.1
11:01:27 <adas> or i need not worry about that?
11:01:41 * geekosaur scans back to see if he missed something
11:01:41 <geekosaur> so the real problem looks like persistent's dependencies end up constraining ghc-mod, and mtl is either what's constraining it or is a red herring
11:02:20 <geekosaur> mtl can be upgraded to work with GHC HEAD and you would not care (indeed it might not work with non-HEAD)
11:02:37 <geekosaur> in particular, the AMP is landing in ghc 7.10 and that will cause mtl changes
11:02:59 <__jim__> So, after running chmod on the unpacked GHC folder I was able to make install
11:04:37 <adas> how may i move forward at this point if the goal is to install the most recent versions of persistent persistent-template persistent-sqlite mtl and ghc-mod?
11:04:51 <adas> can't?
11:04:59 <geekosaur> do you absolutely need the LATEST mtl?
11:05:32 <adas> geekosaur: I don't. I just need all the persistent libraries
11:05:38 <geekosaur> perhaps what I just said didn't come across right. mtl needs changes incompatible with current releases of ghc to work with changes in the next ghc release. if the latest mtl targets the unreleased ghc, it won't even work with yours
11:05:54 <geekosaur> so you may well not want the absolute latest mtl
11:06:01 <adas> ah okay
11:06:03 <adas> great
11:06:17 <simon> can I make a stateful parser using ReadP without using monad transformers?
11:06:23 <adas> thanks.. ill just go with the 2.1.3.1 then..
11:06:37 <adas> thanks much
11:08:50 <japesinator> I'm getting a really strange error when I try to install profunctors
11:09:19 <geekosaur> actually it looks like latest mtl is not specific to the AMP changes. but persistent may well not work with the latest one anyway, so if you need persistent then you would need an older one. (it's part of the yesod stack, isn't it? that often has different dependencies)
11:09:25 <japesinator> http://pastebin.com/kWk6FaUN
11:09:32 <japesinator> anyone know what's going on?
11:10:22 <adas> geekosaur: yup..its part of the yesod stack
11:10:52 <geekosaur> japesinator, you are using hashable 1.2.2.0 but the void package is linked against hashable 1.2.1.0
11:11:11 <sagittarian> why is ghc glorious?
11:11:15 <joshkirklin> is it possible to template haskell quote an arbitrary string? ie is there some f such that f "..." = [|...|]
11:11:45 <japesinator> geekosaur: so what should I do?
11:12:19 <joelteon> joshkirklin: no sir
11:12:22 <joelteon> it is not
11:12:31 <joshkirklin> how annoying
11:12:49 <geekosaur> I'm not sure. possibly `ghc-pkg hide hashable-1.2.2.0` but I don't have any idea what your package database looks like or why it would be trying to use the other hashable version
11:13:21 <joelteon> joshkirklin: using arbitrary string literals as code, inside code? :)
11:13:40 <japesinator> geekosaur: I tried that and got the same error
11:13:56 <joshkirklin> joelteon, lol you're right there's probably a better way
11:14:05 <joelteon> this isn't perl
11:14:07 <geekosaur> bleh. how are you installing profunctors exactly?
11:14:44 <joelteon> joshkirklin: you could use haskell-src-meta and parse the string into an AST
11:14:48 <joelteon> and insert that
11:14:58 <joelteon> but it's not just arbitrary; it has to be valid haskell
11:15:02 <japesinator> geekosaur: cabal install profunctors
11:15:04 <jon__> Can hspec be used to test a haskell program end to end where checks are done against the program output?
11:15:11 <joelteon> and there are some translations that haskell-src-meta doesn't support
11:15:27 <joelteon> but i think they're like template haskell splices and stuff, so you wouldn't be trying to do that anyway
11:15:34 <joshkirklin> ah well valid haskell is what I meant
11:15:41 <joshkirklin> thanks a lot, that does look helpful
11:15:44 <geekosaur> hm. so try: cabal install profunctors --constraint='hashable == 1.2.1.0'
11:19:34 <japesinator> geekosaur: http://pastebin.com/RTwtRzUt
11:20:20 <geekosaur> same kind of problem but with semigroups now.
11:21:39 <japesinator> geekosaur: so what should I do?
11:21:43 <geekosaur> hm. I think what's needed at this point is output from `ghc-pkg list` in the sandbox (`cabal sandbox hc-pkg --list`, iirc) and output from `cabal install -v3 profunctors` --- but I am not sure I could diagnose from that, you may need someone better versed in cabal internals. possibly ask on the haskell-cafe list
11:21:59 <phaazon> cabal: The following packages are likely to be broken by the reinstalls:
11:22:03 <phaazon> is there a way to know why?
11:22:15 <c_wraith> phaazon: there's only one reason why.  They depend on something being reinstalled
11:22:16 <phaazon> (list which packages colides)
11:22:22 <phaazon> yes
11:22:23 <geekosaur> I'm assuming you're using a sandbox; if not then `ghc-pkg list`
11:22:29 <phaazon> I need “what”, c_wraith
11:22:37 <phaazon> geekosaur: yes
11:22:38 <geekosaur> phaazon: try with -v3 to list what it's doing
11:22:43 <phaazon> thank you
11:22:52 <geekosaur> phaazon, sorry, the ghc-pkg list thing was for japesinator
11:23:06 <geekosaur> too much going on at once...
11:23:44 * hackagebot ses-html-snaplet 0.1.0.0 - Snaplet for the ses-html package  http://hackage.haskell.org/package/ses-html-snaplet-0.1.0.0 (DavidJohnson)
11:25:41 <joshkirklin> hackage is giving me 504
11:27:45 <geekosaur> interesting, I just loaded some package pages from there. admittedly not actual haddocks
11:28:55 <geekosaur> (mm, that's just hanging)
11:29:17 <kazagistar> yeah, I am getting timeouts too
11:29:22 <geekosaur> right, then 504
11:29:28 <phaazon> cabal: Failed to download
11:29:29 <phaazon> http://hackage.haskell.org/packages/archive/00-index.tar.gz : ErrorMisc "Error
11:29:29 <phaazon> HTTP code: 504"
11:29:31 <phaazon> same here
11:29:59 <geekosaur> here's a nickel, buy yourself a real datacenter >.<
11:38:00 <sagittarian> does anyone have experience compiling via llvm?
11:38:30 <sagittarian> like, if opt and llc have different names on my system, is there a way to tell ghc how to invoke them, or am i going to have to create symlinks?
11:41:25 <zq> sagittarian: ghc --show-options | grep -opt
11:41:49 <zq> hm, no
11:42:38 <zq> sagittarian: https://www.haskell.org/ghc/docs/7.8.1/html/users_guide/options-phases.html -pgmlc /path/to/llc -pgmlo /path/to/opt
11:43:15 <zq> it really sucks that the interaction between build-depends and hs-source-dirs isn't documented
11:43:18 <sagittarian> thanks zq
11:44:02 <dbp> anyone seeing this error when browsing hackage: Server error: /srv/hackage/var/server/state/blobs/5d/5dc42c739d4ce990711e98903f9b2f10: openBinaryFile: resource exhausted (Too many open files)
11:44:17 <dbp> for ex: http://hackage.haskell.org/package/postgresql-simple-0.4.4.0/docs/Database-PostgreSQL-Simple-BuiltinTypes.html (at least for me, will repeatedly trigger)
11:44:29 <dbp> nevermind, working now. so intermittent
11:44:53 <joelteon> haha, what the hell
11:45:14 <japesinator> geekosaur: ended up trying bad ideas until everything got FUBAR and running rm -rf ~/.ghc
11:46:54 <trap_exit> anyone here use jmacro?
11:46:59 <trap_exit> I don't get jmacro
11:47:03 <trap_exit> it's like "embed javascript in your haskell code" ?
11:48:31 <etandel> why would anyone want that?
11:48:33 <geekosaur> trap_exit, modern web stuff wants to generate javascript on the fly and send it to the browser
11:48:53 <trap_exit> geekosaur: but people do not want to use fay / haste ?
11:49:05 <trap_exit> geekosaur: jmacro = just seems a weird choice
11:49:15 <trap_exit> so it's like a level about concatenating strings ?
11:49:19 <geekosaur> those are great if you can precompile it. not so much if you need to generate on the fly
11:49:38 <trap_exit> geekosaur: hmm, why would you ever want to _generate code_ on the fly?
11:49:42 <geekosaur> likewise there are ways to pre-generate html in a type-safe way, but you still sometimes need to egnerate it on the fly
11:49:43 <trap_exit> rather than just send data to pre-existing functions
11:50:04 <geekosaur> because that's how web programming works these days
11:50:12 <trap_exit> you're kiddin gright?
11:50:18 <trap_exit> I can see generating HTML on the fly
11:50:20 <geekosaur> I'm not real fond of the idea either, but I didn't invent the modern web
11:50:25 <trap_exit> but what is a concrete example of generating js on the fly
11:50:35 <trap_exit> this 'generate js on the fly' idea seems retarded
11:50:42 <trap_exit> it's like 'let's build a jet engine on the fly'
11:50:45 <clrnd> trap_exit, maybe for a site that compiles user code for visualizations and stuff
11:50:59 <clrnd> user inputed code*
11:51:04 <trap_exit> yeah, but you can just `eval` on the client side if you're interpereting
11:51:26 <trap_exit> well, I think the good news is that this dicussion has convinced me
11:51:39 <trap_exit> that I should use fay/haste
11:51:51 <clrnd> +1
11:51:57 <kazagistar> js is like assembly for the web... and JIT compilers generate assembly on the fly all the time
11:53:20 <monochrom> is js like assembly for the web? it looks more like Algol for the web.
11:53:30 <clrnd> jajja
11:54:01 <RyanGlScott> For some reason, a package that I uploaded to Hackage yesterday isn't up right now.
11:54:05 <monochrom> one may ask, what does "assembly for ____" mean?
11:54:06 <ReinH> hackage web is having some problems :(
11:54:12 <ReinH> Not sure about the build system
11:54:16 <RyanGlScott> Should I try to reupload or just wait?
11:54:20 <kazagistar> there is no other real compile target on the web then asm.js
11:54:28 <ReinH> "Server error: /srv/hackage/var/server/state/blobs/de/deadc208e48f9ad27f7840de859200f2: openFile: resource exhausted (Too many open files)" :(
11:54:30 <joseph07> kazagistar: Do we have a haskell -> asm.js compiler?
11:54:47 <ReinH> joseph07: we have a haskell -> javascript compiler: ghc2js
11:55:01 <trap_exit> X is assembly for Y generally means "X is fucking stupid; so instead of coding for X, we'll build systems taht compile to X; then to not insult users of X, we'll say X is assembly for Y"
11:55:19 <ReinH> er ghcjs
11:55:39 <ReinH> ghcjs doesn't use asm.js
11:56:13 <joseph07> ReinH: I wonder if there are plans to leverage asm.js in ghcjs
11:57:13 <kazagistar> the asm data model seems further from haskell then just normal js, but what do I know?
12:03:57 <yak> hey guys i got a question, how would i be able to make a 'reverse' maybe monad, where f -> g -> h would compute f, if this returns Nothing compute g, if this returns Nothing return h
12:04:30 <Fuuzetsu> how do I go Float → Double again? Not something I do every day…
12:04:53 <mauke> @hoogle Float -> Double
12:04:55 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
12:04:55 <Fuuzetsu> sorry, Double → Float
12:04:55 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
12:04:55 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
12:05:13 <Fuuzetsu> hoogle does not help herne
12:05:14 <Fuuzetsu> here*
12:05:14 <monochrom> yak, it looks like f <|> g <|> h
12:05:15 <mauke> > realToFrac (5 :: Double) :: Float
12:05:17 <lambdabot>  5.0
12:05:19 <Fuuzetsu> ah realToFrac
12:05:31 <mauke> > read (show (5 :: Double)) :: Float
12:05:33 <lambdabot>  5.0
12:05:50 <mauke> > toEnum (fromEnum (5 :: Double)) :: Float
12:05:52 <lambdabot>  5.0
12:05:56 <monochrom> <|> is from Alternative. it also corresponds to mplus from MonadPlus
12:06:07 <yak> sorry i disconnected
12:06:18 <monochrom> yak, it looks like f <|> g <|> h.
12:06:29 <monochrom> <|> is from Alternative. it is also analogous to mplus from MonadPlus
12:06:33 <yak> hm, i'm trying to do it in F#
12:06:55 <yak> but i need some advice or some hints how you would go on abbout creating it
12:07:02 <monochrom> then you need to find Alternative or MonadPlus in F#. or bring to.
12:08:00 <khyperia> Heh, I'm going through codewards.com doing haskell challenges, there was one for calculating the power set of a list, which I thought I was pretty clever... until I saw the solutions by other people. "power = filterM $ const [True,False]" I have no idea how that works, but it seems amazing.
12:08:25 <mauke> khyperia: do you know how filter works?
12:08:39 <yak> thank you :)
12:08:40 <khyperia> yeah, I know how filter works, not filterM with the list monad
12:08:54 <mauke> the list monad is multiple realities
12:09:44 <mauke> the filter predicate is \_ -> [True,False], which means "return both True and False"
12:09:47 * hackagebot binary 0.7.2.2 - Binary serialisation for Haskell values using lazy ByteStrings  http://hackage.haskell.org/package/binary-0.7.2.2 (LennartKolmodin)
12:09:48 <monochrom> filterM (const [True,False]) xs expands into this recursion: g [] = return []; g (x:xs) = do { b <- [True,False]; ys <- g xs; return (if b then x:ys else ys) }
12:09:49 <mauke> this happens for each element
12:10:00 <khyperia> ohhhh
12:10:01 <khyperia> that's clever
12:10:13 <mauke> and at each point the universe branches
12:10:17 <khyperia> that is very clever and I want to punch someone in the face now.
12:10:19 <mauke> filterM collects all variants in a list
12:10:27 <monochrom> so it's "non-deterministically decide whether to include x or not"
12:11:25 <rioch> Where is the best place to start when starting a project in haskell?
12:14:13 <khyperia> thanks, mauke, for explaining
12:14:28 <japesinator> geekosaur: so even after I removed all installed packages and started to reinstall, I still get the same error
12:14:29 <khyperia> also monochrom
12:14:40 <japesinator> profunctors still won't work
12:15:09 <dmj`> how do I delete a package off of hackage?
12:15:14 <dmj`> I put one up with the wrong name :/
12:15:20 <geekosaur> [25 18:21] <geekosaur> hm. I think what's needed at this point is output from `ghc-pkg list` in the sandbox (`cabal sandbox hc-pkg list` if using a sandbox) and output from `cabal install -v3 profunctors` --- but I am not sure I could diagnose from that, you may need someone better versed in cabal internals. possibly ask on the haskell-cafe list
12:17:25 <japesinator> list: https://gist.github.com/anonymous/894365a1cd5b02a41e18
12:17:59 <japesinator> check: https://gist.github.com/japesinator/c3478eaf5467d4985214
12:18:03 <japesinator> geekosaur: ^
12:23:38 <dermot> what am I doing wrong here
12:23:40 <dermot> https://gist.github.com/hderms/5a4966e93b25b81e7d2e
12:24:28 <sagittarian> how do you do division with the result of functions that return Ints?
12:24:41 <srhb> dermot: Integral a and Integer is not the same type
12:24:55 <mauke> dermot: confusing paren placement
12:24:56 <srhb> dermot: You can't lie to the type system. :)
12:25:02 <dermot> srhb: it's on codewars they put that type signature in there but I think I could use Integer instead
12:25:10 <srhb> Oh hm. Maybe I'm wrong.
12:25:11 <merijn> srhb: Can too :p
12:25:26 <dermot> would I just replace Integral with Integer in that?
12:25:31 <merijn> unsafeCoerce all day, erry day :p
12:25:31 <srhb> dermot: Nah, forget what I said
12:25:40 <mauke> srhb: why?
12:25:42 <frosch03> you can lie to the type system?
12:25:45 <dermot> mauke: I don't really know how to do the dot stuff
12:25:53 <mauke> what dot stuff
12:25:58 <dermot> like group . sort
12:26:01 <srhb> I'm confused now. I think I backed down on a joke. :P
12:26:02 <dermot> function composition
12:26:07 <mauke> dermot: I'm talking about ))))
12:26:19 <mauke> and (n)
12:26:23 <mauke> which is the the same as n
12:26:35 <xplat> http://lpaste.net/111635 -- let haskell save you from shellshock
12:26:59 <dermot> mauke point taken
12:27:16 <dermot> i'm a super haskell noob
12:27:24 <mauke> digitalRoot (sum (digitalList n))
12:27:33 <mauke> reads better
12:27:42 <dermot> agreed
12:28:03 <mauke> does Integral even imply Show nowadays?
12:28:08 <monochrom> no
12:28:18 <dermot> i just pulled out the type signature and it works now
12:28:26 <dermot> no need to overspecify i guess
12:28:30 <srhb> Would need a Read in the lambda and Show, Integral in the digitalRoot
12:28:39 <mauke> dermot: wasn't the type signature part of the exercise?
12:28:40 <monochrom> digitalRoot needs (Integral a, Show a, Read a)
12:28:53 <monochrom> then digitalList will not need to pin to Integer
12:28:55 <dermot> mauke: well they didn't put any tests in that would fail without having that exact signature
12:29:04 <dermot> i won the exercise without it
12:29:11 <dermot> there's no rule that you need to keep everything they prefill in for you
12:29:15 <mauke> ah
12:29:51 <monochrom> but you need not use show or read at all.
12:30:02 <dermot> to convert an integer to its digits?
12:30:08 <monochrom> right
12:30:26 <dermot> yeah i'm far too much of a noob to know any other way
12:30:57 <monochrom> have you considered handwriting the mapping? f '0' = 0; f '1' = 1, etc.
12:31:12 <monochrom> and conversely g 0 = '0', g 1 = '1', etc.
12:31:14 <dermot> i would imagine that would be more performant
12:31:34 <monochrom> no, I am not talking about performance. I am talking about assuming less.
12:32:19 <dermot> i've just started using haskell today because codewars finally added it as a language
12:32:33 <shachaf> There are standard functions: digitToInt and intToDigit
12:32:34 <dermot> don't know any good resources or anything
12:32:51 <mauke> we don't want digits, really
12:33:11 <dermot> the exercise was to take an integer, break it into its digits and then sum them
12:33:23 <dermot> doign that recursively until you arrive at a single digit number
12:33:25 <mauke> some kind of `divMod` 10 loop
12:33:40 <mauke> > 123 `divMod` 10
12:33:42 <lambdabot>  (12,3)
12:33:49 <mauke> good start
12:34:23 <clrnd> xplat, how does that work
12:34:30 <dermot> yeah, I mean my solution is pretty bad doesn't really inform the reader what is attempting to be done
12:34:49 * hackagebot bindings-lxc 0.1 - Direct Haskell bindings to LXC (Linux containers) C API.  http://hackage.haskell.org/package/bindings-lxc-0.1 (NickolayKudasov)
12:35:02 <srhb> dermot: I don't think it's a terrible solution.
12:36:43 <mauke> > let foo n | n < 10 = n | otherwise = let (n', d) = n `divMod` 10 in foo (d + n') in foo 123
12:36:44 <lambdabot>  6
12:38:45 <dermot> srhb: wouldn't the type conversions end up being inefficient?
12:38:50 <xplat> clrnd: you copy /bin/bash to /bin/a.bash, then compile this program and install it as /bin/bash
12:39:08 <srhb> dermot: Probably.
12:39:13 <clrnd> xplat, oh my, i get it :|
12:39:24 <dermot> the algorithm would probably be at least linear i think right
12:39:40 <ezrakilty> @type 5
12:39:41 <lambdabot> Num a => a
12:39:47 <shachaf> > let foo ((`divMod` 10) -> (n',d)) |n' == 0 = d | otherwise = foo (d + n') in map foo [123, 0, -5]
12:39:49 <lambdabot>  [6,0,4]
12:39:56 <kazagistar> hmm I signed up for codewars, but it wont let me haskell... its not an option
12:40:22 <dermot> kazagistar: just go through with the process then go to edit languages
12:40:25 <sagittarian> :t fromIntegral
12:40:25 <dermot> in the profile
12:40:26 <lambdabot> (Num b, Integral a) => a -> b
12:40:30 <sagittarian> :t fromInteger
12:40:31 <lambdabot> Num a => Integer -> a
12:40:33 <dermot> kazagistar: there aren't a ton of 'katas' so far though
12:40:38 <dermot> because it just came out today
12:40:45 <xplat> clrnd: it eliminates all passing of bash functions through the environment, though, not just the 'evil' ones
12:41:01 <sagittarian> what is the practical difference between fromIntegral and fromInteger?
12:41:09 <shachaf> The type.
12:41:28 <monochrom> fromIntegral is more general
12:41:40 <mauke> @src fromIntegral
12:41:40 <sagittarian> I have a bunch of values that I got from functions that return Ints
12:41:41 <lambdabot> fromIntegral = fromInteger . toInteger
12:41:49 <kazagistar> dermot: its not listed under challenges, but there are like listings through the menus
12:42:04 <sagittarian> now i want to do some more calculations with these values involving division
12:42:11 <srhb> sagittarian: fromInteger won't work on an Int
12:42:11 <sagittarian> how do i make the types come out right?
12:42:42 <monochrom> do you know the Ghostbusters song?
12:42:43 <mauke> sagittarian: division how?
12:42:49 <sagittarian> a / b
12:42:53 <mauke> sagittarian: what's 2 / 3?
12:42:53 <kazagistar> sagittarian: do you want to do integer division or floating point division?
12:43:00 <sagittarian> floating point
12:43:13 <mauke> a) 0  b) 0.666666666  c) 2%3  e) something else
12:43:30 <merijn> @quote monochrom fromIntegral
12:43:30 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
12:43:41 <monochrom> :)
12:43:44 <sagittarian> 2 / 3 for my purposes here is 0.6666666
12:43:51 <mauke> sagittarian: convert to Double, use /
12:44:20 <sagittarian> yeah i tried fromIntegral but it's giving me errors
12:44:26 <srhb> "errors" ?
12:44:37 <monochrom> it works for me. cannot reproduce the error.
12:44:52 <srhb> > fromIntegral 2 / fromIntegral 3 :: Double
12:44:54 <lambdabot>  0.6666666666666666
12:45:06 <kazagistar> because it does not know which target Num you wanted.... fromIntegral does not constrain the output type, and neither does (/), so you have to annotate it manually
12:45:17 <mauke> better not tell us what the errors are, otherwise we might be able to help you
12:45:31 <dermot> haskell is pretty nutty
12:45:40 <srhb> Psychic debugging kazagistar to the rescue. :-)
12:46:52 <srhb> dermot: Innit awesome. :3
12:47:00 <ezrakilty> I have a typechecker surprise...:
12:47:06 <ezrakilty> @type \x -> id $ Control.Concurrent.forkIOWithUnmask x
12:47:07 <lambdabot> ((forall a. IO a -> IO a) -> IO ()) -> IO GHC.Conc.Sync.ThreadId
12:47:15 <ezrakilty> @type id . Control.Concurrent.forkIOWithUnmask
12:47:16 <sagittarian> while i'm coming up with an example, what's the difference between Float and Double?
12:47:16 <lambdabot>     Couldn't match type ‘a’ with ‘(forall a1. IO a1 -> IO a1) -> IO ()’
12:47:16 <lambdabot>       ‘a’ is a rigid type variable bound by
12:47:16 <lambdabot>           the inferred type of it :: a -> IO GHC.Conc.Sync.ThreadId
12:47:27 <srhb> sagittarian: Precision.
12:47:35 <monochrom> Float uses less memory for less precision
12:47:41 <srhb> sagittarian: Double is twice as precise as Double fsvo precise.
12:47:45 <srhb> or fsvo "double"
12:47:48 <srhb> er, twice.
12:47:52 <dermot> srhb: yeah I'm dipping my toe into haskell and erlang
12:47:56 <dermot> i think it has a lot to offer
12:47:57 <srhb> dermot: Cool. :)
12:48:13 <srhb> dermot: You know we've implemented Erlang in Haskell, it's called Cloud Haskell. :-)
12:48:28 <xplat> Double: twice the precision, half the concision
12:48:29 <sagittarian> should it matter wrt typechecking if I declare the return type of my function to be Double or Float?  (the result being the result of a division)
12:48:37 <clrnd> just wanted to say I love haskell, I'm using it to generate some elections data for d3js visualizations <3
12:48:53 <dermot> srhb: that's impressive
12:48:55 <srhb> sagittarian: Well yes, it will change the type of your function.
12:49:02 <monochrom> it depends on whether the rest of your program wants Double or Float from your function's return values.
12:49:26 <merijn> srhb: I disagree
12:49:34 <srhb> merijn: With?
12:49:35 <merijn> srhb: Cloud Haskell is neat, but it's not erlang
12:49:41 <srhb> Ah, no, of course.
12:49:57 <sagittarian> i mean, will one give me an error and the other not
12:49:59 <dermot> yeah the erlang tools/OTP/process isolation are a huge reason people use it
12:50:02 <merijn> It doesn't support hot code reloading and I'm not sure how much of the exception handling stuff erlang has
12:50:11 <monochrom> it depends on the rest of your program
12:50:14 <johnw> is the Hackage web UI down for others?
12:50:15 <johnw> http://hackage.haskell.org/package/base
12:50:21 <johnw> I'm getting resource exhaustion
12:50:23 <srhb> sagittarian: if I have a function foo :: Double -> ... and an x :: Float, I can't say foo x
12:50:34 <srhb> sagittarian: That would be a type error.
12:50:41 <dermot> haskell is supposed to be really good at writing compilers, right?
12:51:04 <merijn> dermot: Yes
12:51:29 <merijn> Well, ADTs are good at tree manipulation and that's most of what compilers are :)
12:51:30 <monochrom> you are selling icecream to customers. you ask, "does it matter whether I sell one scoop or two scoops?" well, it depends on what your customers are ordering.
12:52:02 <mauke> is pepper better than salt?
12:52:21 <clrnd> mauke, definitelly yes
12:52:36 <srhb> clrnd: Your life must be simple. :-)
12:52:43 <S11001001> mauke: no way
12:52:56 <mauke> are you pro-skub?
12:53:08 <Clint> pepper is better than salt, just as salt is better than pepper
12:53:34 <srhb> johnw: Down for me.
12:53:41 <dermot> merijn: like the general idea is that you parse the input, converting it into tokens. then you take that tree of tokens and do manipulations on it, then you convert the tree to a new representation?
12:53:48 <clrnd> salts is like do-notation, you try not to use it but it's just so easy
12:55:05 <monochrom> is the do-notation desugared or desalinated?
12:55:32 <monochrom> hell, is the do-notation desugared, desalinated, or desalinized? :)
12:55:47 * srhb thinks #haskell has been in the after-hours bar tonight
12:56:02 <monochrom> ok sorry!
12:56:11 <simpson> I'm gonna go with "defatted".
12:56:24 <MP2E> dedo'd
12:56:36 <shachaf> It's denotated.
12:56:54 <mauke> denotaters gonna denotate
12:58:49 <sagittarian> @pl \n -> (n ^ 2 - n) / 2
12:58:50 <lambdabot> (/ 2) . ((-) =<< (^ 2))
12:59:11 <sagittarian> the way math was meant to be notated
12:59:17 <srhb> Ouch... :P
12:59:27 <mauke> @. unpl pl \n -> (n ^ 2 - n) / 2
12:59:27 <lambdabot> (\ e -> (((\ b -> b ^ 2) e) - e) / 2)
12:59:41 <mauke> nice
13:01:22 <sagittarian> @pl \n x -> (n ^ x - n) / x
13:01:23 <lambdabot> join . ((/) .) . (flip =<< ((-) .) . (^))
13:05:20 <dmj`> how does one delete a package off of hackage?
13:07:05 <merijn> dermot: Pretty much
13:07:11 <merijn> dmj`: You can't
13:07:20 <merijn> You can deprecate, but not delete
13:07:29 <merijn> Because that would break packages depending on it
13:09:59 <beckyconning> whats the best way of making a tuple with two random integers in a range?
13:10:27 <srhb> beckyconning: "best" I don't know. But System.Random can help you at least.
13:10:32 <mauke> :t randomRIO
13:10:33 <lambdabot> Random a => (a, a) -> IO a
13:10:46 <mauke> liftA2 (,) (randomRIO r1) (randomRIO r2)
13:11:23 <dmj`> merijn: I just named it wrong :(, can I rename a package?
13:11:28 <beckyconning> thanks! the liftA2 bit is the one i was confused about
13:12:09 <beckyconning> also the me being very tired part : P
13:12:13 <merijn> dmj`: Maybe the hackage trustees can, consult #hackage ?
13:12:36 <dmj`> ok thanks
13:15:51 <Fuuzetsu> Server error: /srv/hackage/var/server/state/blobs/b7/b791a3642c34df5f7c7cf6618b1b2ea3: openBinaryFile: resource exhausted (Too many open files) help
13:16:50 <srhb> Fuuzetsu: Is ded.
13:17:00 <Fuuzetsu> time to pull up local docs
13:18:48 <Fuuzetsu> file:///nix/store/frha3rr7d70vh2p6grn0ml7yzb8nfqjz-haskell-free-game-ghc7.8.3-1.1.78-shared/share/doc/x86_64-linux-ghc-7.8.3/free-game-1.1.78/html/FreeGame.html that user friendly path though ;_;
13:19:17 <srhb> The joys of NixOS. :D
13:21:29 * hackagebot informative 0.1.0.1 - A yesod subsite serving a wiki.  http://hackage.haskell.org/package/informative-0.1.0.1 (implementation)
13:27:49 <RyanGlScott> If you use the MINIMAL pragma, should you be expected to surround it with #ifdef __GLASGOW_HASKELL__ >= 708?
13:28:37 <RyanGlScott> MINIMAL won't break on earlier GHCs, but it does emit a warning.
13:34:21 <monochrom> I think it's personal taste and up to you
13:37:37 <sagittarian> @src iterate
13:37:38 <lambdabot> iterate f x = x : iterate f (f x)
13:38:00 <sagittarian> @pl \f x -> x : iterate f (f x)
13:38:00 <lambdabot> ap (:) . ((.) =<< iterate)
13:38:13 <stolaruk> Could anyone point me to an example of a Haskell project w/ an Apache 2.0 NOTICE file in which they credit 3rd party Haskell libraries? I've never made a NOTICE file before, and would like to see an example.
13:46:30 * hackagebot Hungarian-Munkres 0.1.0 - A linear Sum Assignment Problme (LSAP) solver  http://hackage.haskell.org/package/Hungarian-Munkres-0.1.0 (kaizhang)
13:46:37 <ChristianS> stolaruk: most haskell projects seem to use the bsd license
13:46:58 <stolaruk> ChristianS: Yeah I kinda noticed that.
13:47:26 <stolaruk> Is there a particular reason for that?
13:48:26 <ChristianS> stolaruk: well, it's short and permissive. is there a particular reason you want Apache? it's also permissive and more of a hassle.
13:48:51 <stolaruk> Well yeah my employer likes it. Not sure exactly why.
13:53:16 <Hijiri> apache reduces the chance of patent disputes, I think
13:53:23 <Hijiri> because it has implicit patent licensing
13:59:13 <hnoob> when fields in a data declaration have a ! in front of the type, what does that mean?
13:59:17 <hnoob> like this:
13:59:21 <hnoob>     { personName :: !String,
14:00:00 <blogle> could an abstract syntax tree for a technical computing language be reasonably represented using lambda calculus?
14:00:06 <josephle> that's a strictness annotation
14:00:13 <[swift]> so i've run into something i'm having a hard time typing in haskell
14:00:33 <hnoob> thx josephle, I found it on stackoverflow now... will read
14:00:48 <josephle> hnoob: happy to help :)
14:01:05 <[swift]> i need a function of type similar to this: (a -> Either (a -> Either ...) b
14:01:22 <[swift]> hopefully the "..." is understandable there; this is an infinitely recursive type
14:01:38 <[swift]> basically i want a function that can either return a continuation or a final value
14:02:26 <[swift]> i feel like i've seen people type stuff like this in haskell before, but i can't remember where i saw it. can anyone suggest an example of this, or where i can read up about how to do this?
14:02:47 <[swift]> the haskellwiki page on continuations didn't seem to address this problem
14:04:28 <Clint> [swift]: have you read http://www.haskellforall.com/2012/07/breaking-from-loop.html
14:04:47 <monochrom> [swift], because of the recursion, you need to create your own type. data X a b = Rig b | Lef (a -> X a b)
14:05:44 <[swift]> Clint: no, but that seems quite relevant. thanks!
14:05:46 <monochrom> I guess X is equivalent to an EitherT
14:06:18 <[swift]> monochrom: hmm, that makes sense
14:07:33 <monochrom> does lambdabot know EitherT
14:07:46 <monochrom> @kind EitherT
14:07:47 <lambdabot>     Not in scope: type constructor or class ‘EitherT’
14:07:47 <lambdabot>     Perhaps you meant ‘Either’ (imported from Data.Either)
14:08:17 <monochrom> I guess I could re-invent EitherT myself
14:09:10 <vjeranc> anyone tried mandelbrot example from parallel and concurrent programming (Simon Marlow)? I can't seem to get it work... seems there were some changes in the accelerate library... the code compiles, but there's an error that image can't be saved, also, there were some problems with imports being separated in new packages (accelerate-io didn't exist at the time of writing the book)
14:26:11 <monochrom> hmm, X is not equivalent to any EitherT instantiation. using EitherT to jump out, you cannot jump back in; X stores a way to jump back in, it is why a recursive type is needed.
14:28:29 <Clint> monochrom: why would you want to jump back in?
14:28:57 <monochrom> because the question wants to jump back in.
14:30:04 <monochrom> the desired infinite type (a -> Either (a -> Either ...) b, i.e., T = Either (a -> T) b, contains a continuation a->T
14:42:29 <zereraz> what is wrong with this ? (length.filter) (== 1) [1,2,3,4]
14:42:41 <beckyconning> is there a way of producing a random a in a range (a,a) that doesn't exist in a given [a] where the length of the range is greater than the given list of 'a's?
14:42:55 <monochrom> is it really wrong?
14:43:03 <zereraz> getting error
14:43:06 <monochrom> > (length . filter) (== 1) [1,2,3,4]
14:43:08 <lambdabot>  Couldn't match expected type ‘[t0] -> t’
14:43:08 <lambdabot>              with actual type ‘GHC.Types.Int’Couldn't match type ‘[a1] -> [a1...
14:43:08 <lambdabot>  Expected type: (a1 -> GHC.Types.Bool) -> [a0]
14:43:08 <lambdabot>    Actual type: (a1 -> GHC.Types.Bool) -> [a1] -> [a1]
14:43:25 <beckyconning> i.e. randomRExcluding (0,9) [5,6,7] stdGen
14:43:25 <monochrom> ok, let's expand it mechanically (not intuitively)
14:43:44 <zereraz> length $ filter (== 1) [1,2,3,4] this works
14:44:01 <monochrom> (length . filter) (== 1) [1,2,3,4] = length (filter (== 1)) [1,2,3,4]. this is why it's wrong.
14:44:12 <zereraz> oh
14:44:16 <monochrom> yeah, but $ is not .
14:44:37 <zereraz> so I should put [1,2,3,4] inside the paranthesis
14:45:03 <monochrom> it looks to me (length . filter (== 1)) [1,2,3,4] is the desired expression
14:45:16 <zereraz> yeah
14:45:18 <zereraz> got it
14:45:40 <zereraz> thanks
14:48:48 <monochrom> beckyconning: I tend to loop over "generate one sample. is it in the list? if yes, go back", given that the list is relatively short.
14:48:58 <catsup> hackage is down :/
14:49:29 <catsup> i'm now completely useless
14:49:48 <dfranke> Did Hackage just fall over?
14:50:00 <catsup> dfranke: yep
14:50:22 <catsup> i was just whining about it before you joined
14:50:50 <monochrom> perhaps I can say in my http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#config "one day, you will need docs on your disk because Hackage outages are frequent".
14:51:19 <catsup> cabal even installs docs on disk
14:51:36 <catsup> but are the docs installed in sandboxes?
14:52:02 <monochrom> iff "cabal install" is issued in the context of a sandbox.
14:52:08 <catsup> oh shit, they are
14:52:24 <monochrom> cabal install is in IO. it does different things in different contexts.
14:52:34 <catsup> oh
14:52:47 <catsup> the docs i wanted are not there anyway.  just a file called LICENSE
14:53:08 <dfranke> How does Hackage count package downloads? Does it only count accesses by Cabal's user agent, or also traffic from web crawlers, etc.?
14:53:41 <dfranke> Because I noticed the library I released a few days ago already has 21 downloads, and if it's the former, then that seems really high.
14:54:35 <recursion-ninja> How would hackage distingues between crawlers and cabal?
14:54:45 <dfranke> recursion-ninja: user agent string
14:55:01 <catsup> i guess there could be 10s of bots out there that try to compile all of hackage
14:55:30 <recursion-ninja> Does cabal use a unique user-agent string when making HTTP requests?
14:55:36 <dfranke> catsup: that sounds like a really good way to get your bot pwned :-)
14:55:51 <catsup> na
14:56:21 <catsup> you'd do that in some knid of sandbox
14:56:28 <beckyconning> monochrom: thats how i've done it in the past but now i'm worried about non-terminating programs and as such : P perhaps i've lost that battle as soon as i started generating random numbers?
14:57:34 <monochrom> the probability of real non-termination is 0. however, you could say you worry about the probability of taking 1 minute.
14:57:51 <catsup> heh
14:58:04 <catsup> non-self-termination
14:59:40 <mjrosenb> /jesus/, /usr/lib/ghc-7.8.3 is 750 megabytes.
15:00:26 <monochrom> if the range is finite and you know its length, say 10000, and the list's length is 10, you may generated a sample between 1 and 9990, then map it back to your range. this is nasty to code but you won't have a non-zero probability of taking 1 minute.
15:00:59 <monochrom> (but I would be too lazy to do it.)
15:01:23 <beckyconning> that sounds good : )
15:01:29 <beckyconning> this is a learning exercise anyway
15:01:52 <mjrosenb> beckyconning: what is it you're trying to do? sounds interesting from what I've heard.
15:02:25 <beckyconning> we use javascript at work. i'm just learning haskell when i have some free time
15:02:33 <catsup> sigh i was actually doing something now i'm just reloading hackage and watching irc
15:03:22 <beckyconning> mjrosenb: uhm well i wrote this https://gist.github.com/beckyconning/54798b85b50d61a97628 and now i'm adding a fruit that appears at a random position that isn't inside the snake : )
15:04:25 <beckyconning> sorry if its ugly its my first application written in haskell
15:04:40 <beckyconning> or even the first application i have written in haskell
15:06:23 <pjdelport> beckyconning: That's pretty cool!
15:06:42 <beckyconning> i think it would be cool if once i've finished adding the fruit people could take the code and see if they could make it shorter, clearer or more mathematically sound
15:07:05 <beckyconning> pjdelport: thanks! : ) i just wanted a simple, motivating project to get started with
15:07:08 <mjrosenb> ooh, golfing a game, sounds like fun :-p
15:07:21 <mgaut72> beckyconning: I just got in, missed the link, can you resend it?
15:07:24 <pjdelport> beckyconning: That's a great and fun choice of project.
15:07:37 <pjdelport> beckyconning: And looks very good for a first Haskell program!
15:07:51 <beckyconning> https://github.com/beckyconning/haskell-snake/blob/master/Snake.hs
15:07:55 <DarkCthulhu> I declared a "data" type for a grammar G, describing the various valid syntax. How can I use this data type to evaluate if a given program is well-formed?
15:08:38 <mjrosenb> DarkCthulhu: sounds like you want to parse it, using G as your ast?
15:08:56 <beckyconning> pjdelport: thanks : ) i use a lot of 'monad-style' stuff (promises, maybes etc) in javascript at work so i had a bit of a head start
15:08:57 <DarkCthulhu> mjrosenb: Yes, that is what I want to do, except I'm not sure how to express that syntactically
15:09:41 <volty> hi, I need  « cmb ff fa fb x = ff (fa x) (fb x)   », but I suspect that there are already other & simpler & usual way(s) of doing this, suggest pls ?
15:09:52 <volty> s/need/needed/
15:10:45 <mjrosenb> volty: uhh, s?
15:11:14 <Axman6> :t \x ff fa fb -> ff (fa x) (fb x)
15:11:15 <volty> substitute
15:11:15 <lambdabot> t3 -> (t1 -> t2 -> t) -> (t3 -> t1) -> (t3 -> t2) -> t
15:11:22 <DarkCthulhu> mjrosenb: How do I make Haskell attempt to parse it?
15:11:38 <RegEchse> :t uncurry ff (fa &&& fb $ x)
15:11:39 <lambdabot>     Not in scope: ‘ff’
15:11:39 <lambdabot>     Perhaps you meant one of these:
15:11:39 <lambdabot>       ‘f’ (imported from Debug.SimpleReflect),
15:11:40 <mjrosenb> DarkCthulhu: haskell usually doesn't do that for you.
15:11:41 <Axman6> :t liftA2 (undefined :: a -> b)
15:11:42 <RegEchse> hmmm
15:11:43 <lambdabot> Applicative f => f a -> f b -> f c
15:12:07 <Axman6> :t liftA2 (undefined :: a -> b) `asAppliedTo` (undefined :: c -> a)
15:12:08 <lambdabot> (c1 -> a) -> (c1 -> b) -> c1 -> c
15:12:32 <Axman6> anyway, I think you want liftA2 volty
15:12:38 <mjrosenb> volty: ahh, that isn't actually the s combinator.  sure looks similar though!
15:12:45 <Axman6> using the Reader monad
15:12:48 <benzrf> :t ((+) .) . (*)
15:12:49 <lambdabot> Num b => b -> b -> b -> b
15:13:43 <Axman6> > liftA2 (,) show (*7) $ 12
15:13:45 <lambdabot>  ("12",84)
15:14:09 <DarkCthulhu> mjrosenb: ah, okay. I thought it would do something magical like Prolog ;)
15:14:28 <volty> Axman6: what would be the command for the equivalent, let's say I want a predicate combinging other two, e.g.«   isSpace c || isSeparator c ?
15:14:56 <Axman6> liftA2 (||) isSpace isSeparator
15:15:11 <Axman6> commonly written as (||) <$> isSpace <*> isSeparator
15:15:13 <volty> i knew it was there, thx Axman6, thx all
15:15:19 <dfeuer> Huh. status.haskell.org shows everything green, but Hackage is down.
15:15:48 <mgaut72> DarkCthulhu: If you want to have a string form of your datatype, you can make it an instance of Read, then you have `read :: Read a => String -> a`
15:15:52 <mjrosenb> DarkCthulhu: well, you can have it derive a reader, but afiact, it only parses exactly what is printed by the derived Show.
15:16:06 <mjrosenb> err, derive read.
15:16:30 <mjrosenb> in general, Reads is a better interface than read.
15:16:37 <DarkCthulhu> mjrosenb: mgaut72: Cool. I'll try both of them. ty.
15:17:08 * mjrosenb is not sure if Reads is derivable :-/
15:17:22 <mgaut72> or if you want to get more into parsing, there are a few parser combinator libraries out there.  I have personally been using Parsec lately
15:17:25 <Axman6> it part of the Read class, so it should be
15:17:40 <Axman6> wait, can you derive Read? o.O it's been so long since I've used it!
15:18:46 <joelteon> can you imagine not being able to derive Read?
15:18:47 <volty> I wanted to try stuff like if' ?? from Control.Cond, but importing it into ghci does nothing , what do I miss ?
15:19:48 <Axman6> joelteon: after having just worken up, yes! it was very scary!
15:19:58 <Axman6> > data Foo = Foo deriving (Show, Read)
15:19:59 <lambdabot>  <hint>:1:1: parse error on input ‘data’
15:20:10 <Axman6> @define data Foo = Foo deriving (Show, Read)
15:20:13 <lambdabot>  Defined.
15:20:22 <Axman6> > reads "Foo oo" :: [(Foo,String)]
15:20:24 <lambdabot>  [(Foo," oo")]
15:21:06 <dfeuer> What's the fastest way to implement  (`elem` "0123456789.-")? Numbers definitely show it's better to do (\x->('0'<=x&&x<='9')||'x=='.'||x=='-'), but then that suggests  (\x -> x <= '9' && (x >= '0' || x == '.' || x == '-')),
15:22:32 <Axman6> without resorting to bit tricks, that's probably as good as you'll get
15:22:46 <Axman6> > ord '9'
15:22:47 <dfeuer> or alternatively something bittish, like (\x -> fromEnum x `shiftR` 4 == 3 || (fromEnum x+1) `shiftR` 1 == 23)
15:22:47 <lambdabot>  57
15:23:20 <dfeuer> Axman6, I have very little knowledge of bit tricks....
15:23:23 <ParahSailin> fastest i guess would be a foreign primop
15:23:41 <dfeuer> ParahSailin, why would that be fastest?
15:24:18 <dfeuer> Data.Bits is purty fast (as long as you're not dealing with variable shifts or such weirdness)
15:24:39 <ParahSailin> because you could do any arbitrary c implementation?
15:25:00 <dfeuer> ParahSailin, and why would an arbitrary C implementation be better than an arbitrary Haskell implementation?
15:25:20 <Axman6> > map ord "0123456789.-"
15:25:22 <lambdabot>  [48,49,50,51,52,53,54,55,56,57,46,45]
15:25:34 <catsup> is there a reason you're not using isDigit ?
15:25:37 <dfeuer> Axman6, it's better in hexadecimal..
15:25:47 <ParahSailin> ghc is probably not going to know how to optimize it that far
15:25:49 <Axman6> it's an interesting range though!
15:26:02 <Haskellfant> the cabal-install bootstrap skript is timing out for me while downloading Cabal-1.20.0.0 (504 error). any idea what could be causing this?
15:26:13 <functor> I heard someone say that Haskell is compiled to lambda abstractions, is that true?
15:26:15 <catsup> i think isDigit must surely use the most efficient implementation possible
15:26:16 <dfeuer> catsup, that's a point, *but* '-' and '.' are both less than '0', hence less than '9', so one option is to take advantage of that.
15:26:21 <functor> it was something like that
15:26:34 <dfeuer> functor, that is oversimplified.
15:26:37 <Axman6> > \x -> x >= 45 && x <= 57 and x != 47
15:26:39 <lambdabot>  Not in scope: ‘!=’
15:26:39 <lambdabot>  Perhaps you meant one of these:
15:26:39 <lambdabot>    ‘!’ (imported from Data.Array), ‘M.!’ (imported from Data.Map),
15:26:39 <lambdabot>    ‘IM.!’ (imported from Data.IntMap)
15:26:51 <dfeuer> Axman6, you mean /=
15:27:00 <functor> dfeuer: How do you mean?
15:27:01 <Axman6> > \(ord -> x) -> x >= 45 && x <= 57 and x /= 47 $ 48
15:27:02 <catsup> dfeuer: oh, i see.  i bet isDigit is not doing two comparisons though...
15:27:03 <lambdabot>  Precedence parsing error
15:27:03 <lambdabot>      cannot mix ‘GHC.Classes.<=’ [infix 4] and ‘GHC.Classes./=’ [infix 4] in ...
15:27:12 <Axman6> > \(ord -> x) -> x >= 45 && x <= 57 && x /= 47 $ 48
15:27:14 <lambdabot>  Couldn't match expected type ‘s0 -> t’
15:27:14 <lambdabot>              with actual type ‘GHC.Types.Bool’
15:27:15 <Axman6> I should wake up
15:28:23 <Axman6> > chr 47
15:28:24 <lambdabot>  '/'
15:28:32 <catsup> actually the fastest way is probably to use a compiled regex
15:28:56 <Axman6> I'd be really surprised if that were true
15:29:05 <dfeuer> catsup, no, I bet it's doing something roughly equivalent to fromEnum x .|. 0xF == 63
15:29:20 <Fuuzetsu> data Accuracy = Accuracy { _良 ∷ Int , _可 ∷ Int , _不可 ∷ Int } -- valid Haskell
15:29:40 <Haskellfant> ah i guess hackage is the problem
15:29:43 <Axman6> > filter (\x -> x >= '.' && x <= '9' && x /= '/') [minBound .. '\255']
15:29:45 <lambdabot>  ".0123456789"
15:29:49 <dfeuer> functor, GHC compiles Haskell first to something called "Core", or "System FC", which has lambda expressions, let expressions, letrec expressions, and case expressions.
15:30:04 <joseph07> isDigit c is defined as c >= '0' && c <= '9' in GHC
15:30:12 <dfeuer> Then it's processed for a while. Then it's compiled to STG, which has similar things.
15:30:13 <catsup> a good regex compiler would use the most optimal method available on the machine to implement a character class
15:30:36 <Fuuzetsu> Illegal variable name: ‘不可’ boo
15:30:39 <dfeuer> Then it's compiled to either Cmm or LLVM, and from there to assembly, or it's compiled to Javascript.
15:30:52 <catsup> yeah it ought to be compiled to machine code
15:31:00 <dfeuer> joseph07, why would it be defined like that?
15:31:14 <MP2E> catsup: assembly is machine code..
15:31:17 <Fuuzetsu> does TH hate unicode?
15:31:17 <catsup> maybe regex engines don't actually do that anymore?
15:31:19 <etandel> wait, ghc compiles to JS?
15:31:20 <catsup> MP2E: i know :)
15:31:38 <joseph07> dfeuer: why not?
15:31:39 <MP2E> etandel: GHCJS does!
15:31:40 <dfeuer> catsup, I don't know why you think a regex engine would be better than anything else for this.
15:31:53 <etandel> MP2E: is that some sort of extension / plugin?
15:31:54 <Axman6> at least for this problem anyway
15:32:01 <monochrom> Fuuzetsu: either GHC's TH expects utf-8, or expects whatever your current locale says. I forgot which.
15:32:13 <dfeuer> etandel, yes. Search for GHCJS, and you'll find the info.
15:32:22 <etandel> that's pretty awesome
15:32:28 <Fuuzetsu> monochrom: http://lpaste.net/111642
15:32:37 <monochrom> are you on Windows?
15:32:43 <Fuuzetsu> no
15:32:50 <dfeuer> etandel, go talk to luite if you're interested in helping with that project.
15:32:50 <etandel> because I'm thinking about creating a DSL for automated interaction with web pages and now I can use haskell for that. =D
15:32:52 <catsup> dfeuer: like i said i would expect a regex compiler to have the most optimal implementation of character classes possible
15:32:52 <monochrom> then I can't explain it.
15:33:05 <catsup> maybe it's not actually true though
15:33:06 <Fuuzetsu> maybe I should head to lens issue tracker
15:33:27 <Axman6> @hoogle hex
15:33:29 <lambdabot> package hex
15:33:29 <lambdabot> Text.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
15:33:29 <lambdabot> Text.ParserCombinators.Parsec.Token hexadecimal :: GenTokenParser s u m -> ParsecT s u m Integer
15:33:30 <catsup> it may also be that just function call overhead would kill it if you were only doing one character
15:33:46 <Axman6> > printf "Hello" :: String
15:33:48 <lambdabot>  "Hello"
15:33:55 <catsup> probably would actually :/
15:34:11 <etandel> dfeuer MP2E I'll definitely check it out. many thanks
15:34:31 <etandel> S2 #haskell
15:34:32 <Axman6> > map (printf "%x" . ord) ".-0123456789" :: [String]
15:34:33 <lambdabot>  ["2e","2d","30","31","32","33","34","35","36","37","38","39"]
15:34:54 <deaddork> Is Hackage down?
15:35:05 <Fuuzetsu> yes
15:35:22 <deaddork> That sucks!
15:35:36 <deaddork> Anyway to get Haskell documentation elsewhere?
15:36:04 <MP2E> stackage may have it, or you can build the documentation locally
15:36:22 <deaddork> Thanks!
15:36:28 <joseph07> catsup: For isAlpha, isAlphaNum etc ghc uses a c implementation that does check for various bitmasks, but isDigit is defined like I mentioned before
15:36:36 <dfeuer> Axman6, you put those in the wrong order.
15:37:34 <mishac> Hi guys, I started learning Haskell and wanted to ask your opinion on this? Is Lazy IO that big of a problem that makes language very unusable in real world?
15:37:52 <MP2E> mishac: imo no, and even if you hate lazy IO you can completely avoid it
15:38:09 <mishac> that lazyiness is not that big of a problem?
15:38:13 <MP2E> Personally, I think lazy IO is only fit for tiny non-real world applications, but that's fine, because I'm not forced to use it
15:38:20 <MP2E> well language laziness is different than lazy IO
15:38:26 <MP2E> lazy evaluation is great
15:38:34 <yac> where can I get a function to calculate standard deviation of a list of numbers?
15:38:39 <MP2E> and again, if you need something to be strict you can evaluate strictly too
15:38:39 <mishac> so there is a difference between the two
15:38:55 <mishac> i have another, more theoretical question
15:39:05 <monochrom> isDigit is documented as "selects ASCII digits". so I say it is true to its promise. isNumber is the one following Unicode classification.
15:39:15 <mishac> does lazy evaluation forcers you to think about problem differently compared to eager evaluation
15:40:02 <mishac> in other words, is it something that forces you to think about the problem differently that you are working on?
15:40:11 <monochrom> > isNumber '²'
15:40:13 <lambdabot>  True
15:40:21 <MP2E> It simplifies how the problem is thought about, because lazy evaluation can be simulated by evaluating the function by substition on a piece of paper.
15:40:43 <cdk> mishac: absolutely, a common idea in Haskell is to generate an infinite data structure and allow a consumer to consume it lazily, only generating as much as is needed. That's not something you'd even consider in a strict language.
15:40:45 <MP2E> you can take the body of every function a given problem uses, substitute the calls with the body inline, and reduce just like a regular math problem
15:41:12 <MP2E> also what cdk said is a good point
15:41:21 <MP2E> the ability to work with infinite structures is neat
15:41:34 <josephle> of course, it's not that hard to encode nonstrict evaluation in a strict language
15:41:40 <mishac> cdk, MP2E: Thank you. so infinite structure is like a stream of data?
15:42:27 <mishac> cdk, MP2E: I think i am a bit wrong with last statement
15:42:42 <MP2E> a stream can be an infinite structure, but it's one of many :)
15:43:43 <begriffs> Is there a haskell libraty to validate persona identity assertions? (for mozilla persona authentication)
15:43:45 <cdk> mishac: lists, trees, streams, or more generally any free monad can be infinite data structures
15:47:19 <mishac> cdk, MP2E: Thanks guys!!
15:48:12 <MP2E> :>
15:49:18 <pjdelport> mishac: You can think infinite data as a stream, but it's not limited to lists: it can be any structure that goes on infinitely. Haskell will only actually evaluate as much of it as much as you actually use, so as long as you don't try to consume all of it, it's perfectly fine.
15:49:22 <etandel> basically anything that can be generated "on the go"
15:50:33 <yac> what's up with hackage?
15:51:17 <beckyconning> i think it is having a sleep
15:51:18 <volty> http://hackage.haskell.org down for you too (i have some mess with proxy filtering) ?
15:54:31 <etandel> looks down to me
15:54:59 <alrunner4> http://isup.me/hackage.haskell.org
16:04:56 <Fuuzetsu> I'm pretty happy about having docs right now
16:17:34 <dagle> Hmm. Hackage is down and I need it. :(
16:18:26 <luite> dagle: for docs or package source?
16:18:55 <luite> http://hdiff.luite.com/ <- mirror for packages
16:19:10 <dagle> luite: Well, first of I need to do a cabal update.
16:19:22 <luite> should work from there
16:26:23 <yyttr3> Does there exist a function of type :: a -> [a->b] -> [b] where all the elements in the list are applied to the single value?
16:27:01 <triliyn> :t fmap . ($)
16:27:03 <lambdabot> Functor f => (a -> b) -> f a -> f b
16:27:14 <triliyn> er, not quite right
16:27:18 <triliyn> :t fmap . flip ($)
16:27:20 <lambdabot> Functor f => a -> f (a -> b) -> f b
16:27:53 <yyttr3> Wow, did you just come up with that real quick?
16:28:07 <triliyn> Yeah
16:28:26 <triliyn> I was actually thinking fmap ($x) and then transformed that to a function with the type you specified
16:28:33 <triliyn> Which is why I made the initial mistake
16:28:43 <triliyn> ($x) is easy to confuse with ($) x
16:28:59 <yyttr3> I feel stupid then xD I've been thinking in ghci for a few minutes xD
16:29:07 <yyttr3> I see
16:29:08 <yyttr3> Thank you
16:29:16 <exio4> that is how Haskell works
16:29:34 <glguy> :t \x fs -> [ f x | f <- fs ]
16:29:36 <lambdabot> t1 -> [t1 -> t] -> [t]
16:29:41 <yyttr3> I'm trying to create a type level definition for addition of natural numbers
16:30:02 <exio4> you try to do something in a beautiful way for 30 minutes, then you ask here and get an answer in 30 seconds
16:30:06 <glguy> If you're going to write it in a file you probably shouldn't use "fmap . flip ($)"
16:30:23 <yyttr3> lol, that seems to be the trend so far.
16:32:48 <exio4> :t (\x → fmap (\f → f x))
16:32:49 <lambdabot> Functor f => t -> f (t -> b) -> f b
16:34:42 <Sir_Pony> >env X="() { :;} ; echo busted" /bin/sh -c "echo completed"
16:35:04 <Sir_Pony> > env X="() { :;} ; echo busted" /bin/sh -c "echo completed"
16:35:05 <lambdabot>  <hint>:1:6: parse error on input ‘=’
16:35:15 <Sir_Pony> hmmm
16:35:20 * Sir_Pony chuckles
16:41:58 <geekosaur> you can't do IO in lambdabot, so no way to get at the environment
16:42:30 <AshyIsMe> haha
16:50:48 <etandel> lol
16:59:37 <beckyconning> i wish that hackage going down meant obligatory nap time for haskellers
17:01:22 <dmj`> is hackage down?
17:01:33 <dmj`> get a 502 bad gateway when I try to upload a package
17:02:08 <dmj`> oh, I see on reddit...
17:05:43 <beckyconning> everyone go to sleep #wakemeupwhenhackageisup
17:06:00 <dmj`> johnw: looks like my package will be deleted after all :)
17:11:12 <begriffs> Is there a haskell package for making an oauth 1.0a provider?
17:16:30 <trap_exit> can someone familiar with Haste tell me wtf is wrong with https://gist.github.com/anonymous/879d8a3e2741910e2e3f ? I'm reading up on onServer, remote, liftServerIO, ... but I feel like a working example would be more useful (this example comes from trying to get the ICFP 2014 Haste.App paper example to work)
17:19:26 <statusbot> Status update: The disk space usage was exceeded on a block device, causing a transactional error in the database. We're restoring backups now. -- http://status.haskell.org
17:22:43 <shachaf> Thanks, statusbot!
17:22:57 * shachaf wonders whether to put anything in the topic.
17:24:10 <Clint> change the reddit link?
17:46:00 <tjandamurra> is there a haskell package for flow based programming?
17:49:08 <fuzzyhorns> any news on hackage being down?
17:50:07 <Clint> fuzzyhorns: http://www.reddit.com/r/haskell/comments/2hh96i/note_hackage_is_down_disk_space_needs/
17:50:48 <fuzzyhorns> thanks Clint
17:50:55 <fuzzyhorns> sorry to be im sure the umpteenth person to ask
17:52:11 <DrAugustDvorak> debian is so good *o*
17:52:24 <dmj`> tjandamurra: what is flow based programming
17:56:09 --- topic: set to 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org' by ChanServ
17:57:44 <zwer> is there an extension similar to DisambiguateRecordFields that will make line 24 work?  http://lpaste.net/111644
18:00:41 <hughfdjackson> is there any way i can make a monad that *must* contain a member of Show ?
18:00:49 <hughfdjackson> :) for educational purposes only
18:01:43 <hughfdjackson> for the purposes of using `show` in the definition of bind
18:02:15 <shachaf> No.
18:02:44 <hughfdjackson> :) cheers
18:02:51 <hughfdjackson> worth an ask
18:03:24 <hughfdjackson> fwiw, I'm trying to work out if it's possible to construct a monad futures lib in haskell (i.e. a version of the akka future used in scala)
18:04:17 <hughfdjackson> it's made problematic by the future having to both use side-effects to fork threads, AND allow functions applied via bind to access IO too
18:04:31 <jystic> anyone know the status of hackage?
18:04:43 <hughfdjackson> :| it's stumped me - if anyone has pointers on where to look..
18:04:47 <simpson> jystic: It's down. It'll return at some point in the future.
18:06:37 <jystic> simpson: haha :) I guessed that, just wondering if anyone had any more info, but all good.
18:07:58 <simpson> jystic: IIUC it ran out of disk space. They're workin' on it.
18:09:40 <DeadChannel> I just dropped in to say that you people are amazing.
18:09:42 <DeadChannel> have a nice day.
18:13:22 <lf94> haskell will take over the world
18:14:03 <MP2E> that's the plan pinky, that's the plan
18:14:10 <MP2E> *jumps into giant robot suit and runs off*
18:14:45 * lf94 whips out lambdas and guards
18:16:10 <StoneToad> hmm I'm getting 503 errors from hackage, is that because it's down waiting to patch the bash bug?
18:16:26 <StoneToad> sorry, 502
18:17:57 <Clint> StoneToad: http://www.reddit.com/r/haskell/comments/2hh96i/note_hackage_is_down_disk_space_needs/
18:18:26 <StoneToad> o_O too popular for our own good I guess that's a good thing?
18:18:54 <joelteon> I was under the impression that using Haskell would prevent these kinds of errors
18:19:26 <StoneToad> which kind?
18:23:54 <hughfdjackson> joelteon: exhausting resources isn't something the haskell type system can help with, afaik
18:24:32 <zomg> gotta leave something for the programmer to do, too
18:24:37 <zomg> otherwise it would be too easy, right?
18:24:39 <zomg> =)
18:24:41 <joelteon> hughfdjackson: that was the joke
18:24:48 <hughfdjackson> joelteon: curse you and your humour
18:24:52 <joelteon> :(
18:24:55 <hughfdjackson> :p when i'm tired, really can't tell the difference
18:25:39 <StoneToad> well, I guess there go my plans to install a bunch of haskell libraries and start a new project
18:25:45 <StoneToad> since hackage is down
18:26:44 <jystic> try using luite's mirror
18:27:02 <jystic> Add the following line in~/.cabal/config
18:27:04 <jystic> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive
18:28:14 <tsani> Are there any big issues with GeneralizedNewtypeDeriving? How portable is it?
18:29:06 <simpson> tsani: coi
18:29:13 <tsani> coi .u'i
18:29:50 <tsani> .i mi cizra lifri lo nu se tavla fo ly fi'o se .irci na'e bo lo lojbo
18:29:52 <simpson> tsani: It's portable. It's also unsafe because you can GNTD on types that you normally wouldn't be able to work on.
18:29:59 <simpson> http://joyoftypes.blogspot.com/2012/08/generalizednewtypederiving-is.html
18:30:10 <tsani> Aha
18:30:33 <simpson> Oh, sorry, you probably want some example code: http://stackoverflow.com/questions/17137111/why-isnt-generalizednewtypederiving-a-safe-haskell
18:31:27 <simpson> (I wonder whether people would greet me in Lojban if I were to /nick korvo...)
18:33:27 <joelteon> GND is safe in 7.8
18:34:13 <slack1256> is there an estimate for when is hackage up again?
18:35:00 <tsani> simpson: I sure can tell you that just being called tsani on pretty much any website hasn't gotten me greeted in Lojban
18:35:20 <simpson> tsani: Well, clearly not enough people know where the name comes from. :3
18:35:34 <tsani> simpson: it seems the GND is only unsafe if you're doing other advanced things like type families or GADTs (neither of which I understand, let alone use)
18:35:49 <simpson> slack1256: Someday, when the tides have receded, and the cities are rebuilt. Maybe a day or two?
18:36:12 <nshepperd> the roles stuff is supposed to fix that
18:37:35 <slack1256> that made me chuckle
18:39:45 <lf94> Is there an OS coded in haskell
18:40:19 <lf94> Any attempt at making binutils with haskell
18:41:32 <kuyatzu> lf94: http://programatica.cs.pdx.edu/House/
18:41:43 <dubosec> hey, I have a quick question: when looking up type signatures, what is the difference between -> and =>
18:41:46 <dubosec> f
18:42:22 <hughfdjackson> dubosec: things before => are type constraints - generally used to limit a function to operating on only types that are members of certain typeclasses
18:42:53 <dubosec> oh. So this only applies to functions which take numbers as values, or can it apply to other functions?
18:43:10 <dubosec> I noticed the Boolean functions don't have => in their type signatures
18:43:18 <lf94> kuyatzu: Wow! Thank you!
18:43:22 <lf94> This is verycool
18:44:04 <hughfdjackson> you can use it to specify quite a lot of things, really - that your function will only work on types whose members can be put in an order (the Ord typeclass) or can be compared for equality (the Eq typeclass)
18:44:14 <hughfdjackson> there are tonnes more
18:44:36 <dubosec> oh, okay. Thanks for the clarification!
18:46:12 <hughfdjackson> :) welcome
18:46:42 <jgriego> Does anyone know anything about hackage being down right now? I get an HTTP 502 from hackage.haskell.org :\
18:47:13 <sgronblo> yeah it seems to be having trouble again
18:47:32 <sgronblo> http://status.haskell.org/
18:48:18 <jgriego> sgronblo: ok! thanks I didn't know about that site
18:48:22 <Welkin> what's with hackage?
18:48:27 <Welkin> error 502
18:48:27 <lf94> Super cool how they made device drivers with Haskell
18:48:40 <Welkin> haha
18:48:43 <Welkin> it's not just me then
18:49:03 <Welkin> hackage being down = is the world ending?
18:49:44 <codygman> I recently opened/started restructuring an old project and this happened, can anyone help me out? http://lpaste.net/111646
18:52:59 <RightMinded> Hey everyone, hope you're all doing great.
18:53:35 <RightMinded> I have a question regarding a file read/write I did, I need some clarification on a refactored solution
18:56:26 <RightMinded> Here's the refactored code readFile "input.txt" >>= return . reverse >>= writeFile "output.txt"
18:56:51 <statusbot> Status update: Hackage data has been synced onto a new dedicated server, and is currently restoring one of the latest backups. Roughly 20% completion. -- http://status.haskell.org
18:57:10 <shachaf> "m >>= return . f" is called "liftM f m", but better to write it as "fmap f m"
18:57:24 <RightMinded> why does >>= return . reverse work, but not >>= (\ input -> reverse input )?
18:57:24 <shachaf> But in your case you can say readFile ... >>= writeFile ... . reverse
18:57:25 <orb__> or as f <$> m
18:57:26 <zq> codygman: persistent and friends underwent some changes since turning 2.0.0
18:57:37 <shachaf> RightMinded: Because those are two different functions?
18:57:41 <geekosaur> erm, doesn;t locking happen?
18:57:49 <geekosaur> can't open for write because open for read?
18:57:56 <shachaf> Why do you expect it to work?
18:58:19 <zq> for line 13, it's just a matter of adding the GND pragma
18:58:25 <codygman> zq: Thanks, I'll chcek that out
18:59:06 <zq> man, why is hackage tripping up so much
18:59:42 <sgronblo> zq: http://status.haskell.org/
19:00:19 <joelteon> yeah, persistent 2 now requires GND, hh
19:00:20 <joelteon> heh
19:00:23 <geekosaur> zq: this is why it's being moved right now to a new server with better hosting (and should be faster too)
19:00:27 <zq> also requires monad-logger
19:00:45 <RightMinded> @shachaf based on what I read about desugaring n <- expr, it's basically expr >>= (\n -> ...)
19:00:45 <lambdabot> Unknown command, try @list
19:00:46 <pjdelport> RightMinded: For a more applicative-style version, try: writeFile "output.txt" . reverse =<< readFile "input.txt"
19:01:36 <shachaf> RightMinded: Yes.
19:01:36 <pjdelport> RightMinded: Note how that's exactly the same style as f . g $ x, except that you're using monadic function application (=<<) instead of pure function application ($)
19:01:41 <shachaf> RightMinded: But you didn't write the return.
19:01:59 <shachaf> RightMinded: "(\input -> reverse input)" is the same function as "reverse".
19:02:10 <shachaf> It's not the same function as "return . reverse".
19:02:18 <RightMinded> @pjdelport: Thanks, I'm still learning
19:02:18 <lambdabot> Unknown command, try @list
19:02:46 <pjdelport> RightMinded: Oh, are you familiar with the "f . g $ x" idiom, by the way?
19:03:01 <shachaf> RightMinded: You don't address people by saying "@person" -- that sets off the bot. You address them with "person:".
19:04:00 <RightMinded> schachaf, based on the types, I was trying to figure out how to convert IO String into [a] or String
19:04:18 <RightMinded> for reverse
19:04:49 <joelteon> And you usually spell their username correctly. Otherwise they may not see the message.
19:04:50 <pjdelport> RightMinded: You can't convert an IO action to a non-IO value: all you can do is compose other functions and actions with it.
19:04:58 <shachaf> RightMinded: You can't (and you don't need to, and it doesn't make sense to).
19:06:14 <pjdelport> RightMinded: You can think of "IO String" as a a value representing an IO action that will result in a String when run, but there doesn't actually exist any String inside it to extract or convert.
19:06:37 <joelteon> @quote /bin/ls
19:06:37 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
19:06:55 <pjdelport> The Functor, Applicative and Monad operators are what lets you work with IO actions, though.
19:07:19 <pjdelport> For example, to apply a function to one: reverse <$> getLine
19:07:53 <pjdelport> <$> is the same as fmap, but the operator version reads a bit easier (think of it like $, but for Functor values)
19:08:06 <RightMinded> shachaf: hmm, so in the future, what rule should i follow if I want to replace '<-' and apply functions?
19:08:53 <shachaf> RightMinded: The exact rule is specified in the Haskell report.
19:09:09 <shachaf> An approximation is do { x <- y; ... } ----> y >>= (\x -> do { ... })
19:10:16 <Welkin> sometimes do-notation is cleaner to use
19:10:21 <RightMinded> okay, thanks guys, I'll do some more reading on fmap, liftM, and the Haskell report. However, the approximation is what lead me to surmise I could do (\x -> reverse x)
19:10:38 <Welkin> just look at the types
19:10:42 <Welkin> :t (>>=)
19:10:43 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:11:02 <solatis> joelteon: that's a pretty good quote actually
19:12:04 <pjdelport> RightMinded: A simple rule of thumb is that for pure functions (like reverse), you apply with <$>, and for functions that return a monadic value themselves (like writeFile) you use =<<
19:12:13 <RightMinded> yes. that quote is making things clearer
19:12:24 <pjdelport> So: reverse <$> readFile "foo"
19:12:36 <pjdelport> But: writeFile "bar" =<< readFile "foo"
19:12:52 <shachaf> pjdelport: I'm not sure a big pile of heuristics like that actually helps.
19:13:20 <pjdelport> So think of the types you have, and then choose the appropriate application operator based on that.
19:13:42 <pjdelport> shachaf: Well, it's not just a heuristic, it's a hard rule. :)
19:14:22 <pjdelport> (Feel free to ignore if it doesn't help make things clearer, though.)
19:15:59 <RightMinded> It'll make sense as I learn more, I had it working with do notation, just wanted to see if I understood >>= and how to best 'refactor' my source
19:17:00 <Welkin> start by desugaring do notation into bind and lambdas
19:17:01 <monochrom> join (atomically ((putStrLn <$> readTChan x) `orElse` (writeFile "xyz" <$> readTChan y))) :)
19:17:40 <RightMinded> you guys are really awesome, thanks for helping out. I'll do some more reading. I guess I was stuck on how to 'draw out' what I needed from the action without the <-
19:17:54 <RightMinded> while using lambda
19:18:51 <RightMinded> monochrom, that's definitely WAY over my head...lol
19:19:09 <monochrom> RightMinded, read my http://www.vex.net/~trebla/haskell/IO.xhtml . there is no drawing out. there is only someone calling your callback with data.
19:19:35 <Total_1mmersion> What kind of QuickCheck properties would be useful for testing a language?
19:19:39 <RightMinded> okay, I'm checking your link out
19:25:51 <tabemann> monochrom: being able to return IO actions from within STM actions is *so* useful
19:26:33 <gbarboza> w 11
19:38:33 <dibblego> is there something like Fin (agda) for haskell?
19:55:35 <AshyIsMe> so is there something like F# type providers for haskell yet?
19:55:49 <shachaf> That depends on what F# type providers are.
19:56:17 <AshyIsMe> well, the part that can generate simple struct style types from a json example file
19:59:49 <zq> oh right, hackage is down
20:00:33 <AshyIsMe> http://fsharp.github.io/FSharp.Data/library/JsonProvider.html
20:00:44 <AshyIsMe> shachaf: that's the json type provider for f#
20:00:55 <AshyIsMe> that's a good example of what they do
20:02:09 <RightMinded> monochrom: Your link was outstanding, it pointed out my rookie misunderstandings and set me straight, I now have a better understanding of the subject matter, a better grasp, which only practice will make firmer
20:02:40 <dmj`> AshyIsMe: I think idris has something like that
20:02:44 <dmj`> http://itu.dk/people/drc/pubs/dependent-type-providers.pdf
20:02:50 <RightMinded> along with the responses from everyone else, I now have more clarity, thanks again everyone.
20:03:02 <dmj`> https://groups.google.com/forum/#!topic/idris-lang/hAjO5yVl6nw
20:03:47 <AshyIsMe> ah cool
20:05:46 <quinso> Hi. Why can't haskell deduce that the list consists of Ints? https://bpaste.net/show/a79a22885601
20:07:03 <dmj`> [1 2 3] is not a list?
20:07:11 <dmj`> [1,2,3]
20:07:32 <quinso> lol
20:07:37 <quinso> Haven't touched haskell in some time
20:07:42 <quinso> Idk why I wrote it like that
20:07:51 <arbn> quinso: You're a Lisp guy?
20:08:13 <simpson> Total_1mmersion: You're talking about implementing a compiler or interpreter, right?
20:08:21 <quinso> arbn: not really but I've been trying to tell someone how to convert his lisp function to haskell, yeah
20:08:35 <arbn> quinso: I see.
20:09:13 <yac> https://gist.github.com/yaccz/cbf362696bfe46a8b9c0
20:09:15 <yac> what is this error?
20:09:17 <yac> I have no idea
20:10:33 <simpson> yac: It's not an error.
20:11:00 <simpson> yac: It's letting you know that it guessed a suitable monomorphic type from a bunch of typeclass constraints.
20:11:29 <yac> right, a warning
20:11:32 <noonan> I'm having trouble talking ghc into building me a .so that I can call into from C: https://bpaste.net/show/7ee4f08b5931
20:11:33 <yac> how do I silence it?
20:11:53 <noonan> Is this telling me to rebuild.. what exactly? with -fPIC
20:12:07 <simpson> yac: Add a type signature for that value.
20:12:27 <yac> simpson: which one? I can't figure anything there
20:12:49 <tabemann> all top-level bindings should have type signatures
20:13:02 <simpson> yac: Line 14, you have a value which is defaulting to Double.
20:13:08 <yac> I do have signatures on top-level bindings
20:13:12 <lostman> instead of "fromIntegral (length xs) - 1" wouldn't you want "fromIntegral (length xs - 1)"?
20:14:43 <yac> ok, trial & error fixed it
20:14:50 <oiuoiu> I'd also suggest to use 'pred' instead of (- 1)
20:15:45 <yac> thing is the warning told me it's somewhere in the argument for round, but not which one more ... oh well, now I understand the message
20:16:10 <yac> first I tried adding the signature to the result of round instead of it's argument
20:16:12 <yac> thanks
20:18:09 <yac> oiuoiu: nice
20:22:29 <tabemann> I don't think I've seen pred in actual Haskell code so far
20:23:25 <arbn> oiuoiu: Why use pred instead of (- 1)?
20:23:29 <oiuoiu> tabemann: I personally think that (-1) is a C-ism.
20:23:42 <yac> arbn: easier to $ it
20:23:56 <oiuoiu> you can also mistype (- 1) easily
20:24:03 <oiuoiu> pred morks for any enum
20:24:05 <oiuoiu> works*
20:24:30 <oiuoiu> I see at as a higher level abstraction.
20:24:35 <yac> shiny abstraction
20:25:37 <yac> some ppl would now yell "get off of your high horse from your ivory tower" :)
20:28:03 <arbn> I see. pred does make more sense in some cases. (- 1) would make more sense if there were a chance of changing 1 to another number.
20:30:55 <yac> it's wrong anyway
20:31:10 <yac> I should average the two middle numbers when list is odd
20:32:26 <joof> fromIntegral $ (-) length xs 1
20:32:42 <joof> just to mess with their heads
20:33:03 <yac> joof: prefix notation for infix operator is bleh
20:33:51 <tabemann> fromIntegral $ (subtract 1) length xs
20:33:51 <napping> joof: that's (length - xs) 1
20:34:03 <tabemann> whoops
20:34:04 <joof> bleh you are right
20:34:14 <tabemann> fromIntegral . subtract 1 $ length xs
20:35:00 <tabemann> subtract is overly verbose though
20:37:53 <joof> Trying to learn FRP, which libraries are recommended?
20:39:15 <joof> yampa?
20:39:38 <platz> FRP doesn't have best practices yet
20:39:46 <arbn> I don't know what FRP is, really.
20:39:55 <arbn> But reactive-banana was kinda cool when I tried it.
20:40:08 <platz> there isn't even an agreed definition what FRP is
20:40:11 <shachaf> Don't worry, neither do most people who write FRP libraries.
20:40:19 <joof> lol
20:40:38 <joof> well if anyone has a personal favorite
20:40:59 <arbn> joof: reactive-banana seemed to be the easiest to build and actually use.
20:41:55 <jle`> joof: it depends on the sort of thing you are using it for
20:44:19 <platz> I'm not aware of any story of how to deal with "too much data", so it seems the only thing that makes sense at this point is UI events
20:45:22 <platz> well, ReactiveExtensions may address this a bit better, but it's questionable if that is even FRP
20:46:51 <yac> joof: oiuoiu arbn fixed: https://github.com/yaccz/base-stats/commit/8c500812881d5d14945a40820a4aa1be62c1d7cd thanks :)
20:47:26 <oiuoiu> yac: awesome!
20:49:01 <oiuoiu> yac: some comments: main should have the type IO (), try to make the 'error' case obsolete.
20:49:33 <yac> oiuoiu: has to be [()] since I am mapMing putStrLns there
20:51:43 <shachaf> So don't do that.
20:51:55 <yac> oiuoiu: the error case is there just to make the -Wall happy about the pattern match. I suppose I could use otherwise instead of the `odd len` branch but that seems more fragile ... like what if the (even) happens to be wrongly implemented?
20:52:00 <yac> shachaf: why not?
20:52:16 <shachaf> Because it makes a list of ()s. You don't need that list.
20:52:23 <shachaf> Use mapM_ instead.
20:52:24 <Hijiri> :t mapM_
20:52:25 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
20:52:28 <yac> oh
20:52:36 <oiuoiu> https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1
20:52:46 <yac> shouldn't the compiler be able to optimize it away?
20:53:00 <shachaf> I wouldn't expect it to?
20:53:03 <oiuoiu> "the identifier main in module Main, which must be a computation of type IO τ for some type τ (see Chapter 7). When the program is executed, the computation main is performed, and its result (of type τ) is discarded."
20:53:23 <shachaf> If you want to write a compiler which optimizes it away, I might switch to your compiler.
20:53:27 <noonan> mapM_ demonstrates your intent better too.. you want the effects but not the results
20:53:37 <yac> () is a null type, right? or what's it called?
20:54:00 <Hijiri> I think unit
20:54:26 <yac> oh, I always thought of IO () as an effect without returning anything
20:55:21 <shachaf> An action :: IO () produces a value :: ().
20:56:10 <yac> right, but I thought of value :: () as empty value
20:56:32 <yac> .. not an actual value
20:57:41 <fread2282> yac: how could IO Empty be created? with IO () it's just return ()
20:58:41 <jle`> data Unit = Unit
20:58:53 <fread2282> empty in haskell-land means impossible to construct
20:58:55 <jle`> so putStrLn could really be :: IO Unit
20:59:01 <arbn> yac: () is the only member of the type (). Well, () and undefined, I guess. Do we talk about undefined in here?
20:59:17 <jle`> perhaps, instead of empty, a more intuitive word would be "useless"
20:59:28 <yac> according to SO undefined is (_|_) in haskell
20:59:31 <jle`> ()/Unit is the useless data type
20:59:48 <pjdelport> Well, it has a use, but its use is "being uninteresting" :)
20:59:49 <yac> jle`: yes, that's right :)
20:59:59 <jle`> :P
21:00:07 <pjdelport> The Least Interesting Type in the Haskell
21:00:10 <jle`> it has a purpose, and its purpose is to be useless
21:00:30 <yac> so even if I return a :: [()] it would occopy the minimal memory possible
21:00:45 <jle`> yac: [()] is actualy isomorphic to another well known type
21:00:46 <yac> actually, how much memory a :: () needs?
21:00:48 <jle`> can you think of what it is?
21:00:57 <jle`> what information does a [()] give you?
21:01:05 <jle`> hint: it's more than no information
21:01:10 <yac> jle`: how many IO was performed
21:01:17 <jle`> i mean, just in general
21:01:21 <jle`> if i gave you somethong of type [()]
21:01:24 <yac> an int?
21:01:50 <jle`> kind of like an always positive int; we call it a Nat
21:02:19 <yac> lambdabot: :t Nat
21:02:26 <jle`> data Nat = S Nat | Z
21:02:37 <orb__> Seems to be always non-negative, not positive.
21:02:42 <jle`> data List a = C a (List a) | N
21:02:47 <jle`> orb__: yeah, you're right :) sry
21:02:57 <jle`> so List () = C () (List ()) | Z
21:02:59 <jle`> er, | N
21:03:05 <jle`> which is basically Nat
21:03:15 <orb__> jle`, mathematicians disagree about zero in Nat, too. ;o)
21:03:48 <jle`> ;)
21:04:14 <jle`> so a [()] is a list where every item gives you no extra information.  so all it encodes is a nonzero number.
21:04:20 <jle`> er
21:04:22 <jle`> nonnegative
21:04:35 <orb__> jle`, plus perhaps infinity.
21:04:38 <jle`> luckily we have a listToInt function
21:04:43 <orb__> x = () : x
21:04:45 <jle`> [()] -> Int
21:05:11 <jle`> mhm :)
21:08:58 <jle`> if we didn't have Maybe
21:09:05 <jle`> we could simulate Maybe a with Either () a
21:09:24 <orb__> They are isomorphic.
21:09:26 <yac> jle`: btw, was that proper use of the word "isomorphic" ?
21:10:00 <orb__> Maybe a is isomorphic to Either () a.
21:10:18 <yac> I meant the one where [()] is isomorphic to Nat
21:10:21 <orb__> (Or perhaps just `isomorph' without the -ic.  Not sure about the pecularities of English here.)
21:10:30 <jle`> by isomorphic i mean that there exists an isomorphism between the two.  so you could write a (Maybe a -> Either () a), and an (Either () a -> Maybe a), such that applying both recovers the original
21:10:38 <orb__> Yes.
21:11:14 <jle`> another way of thinking about it is that going from one to the other "loses" no information, and adds no extra information
21:11:21 <orb__> jle`, oh, you'd also want to specify some kind of structure that gets preserved, instead of just having a bijective function.
21:11:37 <yac> oh  "applying both recovers original" is way easier than the academical nonsense on wikipedia or dictionaries
21:11:40 <orb__> Because otherwise all infinite countable sets are isomorphic.
21:11:55 * yac just learned what isomorphi{c,sm} means
21:12:28 <yac> s/easier/easier to understand/
21:12:35 <orb__> In this case, Succ and (): are basically the same operation.
21:12:44 <jle`> orb__: hm. i'm not sure i understand ;_; what structure do you mean?
21:13:18 <orb__> jle`, eg log and exp transform real numbers into positive real numbers.
21:13:26 <orb__> And + becomes *.
21:13:26 <jle`> ah
21:13:41 <orb__> Nat and [()] are isomorphic too.  The isomorphism is easy to write,
21:13:46 <orb__> and (): becomes Succ.
21:14:18 <orb__> log a + log b = log (a * b)
21:14:30 <orb__> or: exp (log a + log b) = a * b
21:14:43 <Fuuzetsu> nice way to go 12753 → [1, 2, 7, 5, 3] ?
21:15:08 <orb__> Fuuzetsu, map read . show
21:15:22 <Fuuzetsu> read is never nice
21:15:36 <Fuuzetsu> also has to not be slow as melasses
21:15:45 <Fuuzetsu> molasses*
21:15:59 <orb__> Yes, there's a better way.  Perhaps ord or so.
21:16:17 <orb__> digitToInt
21:16:38 <orb__> map digitToInt . show
21:17:09 <Fuuzetsu> seems to suffer from the same problem that I'm converting back and forth
21:17:21 <orb__> That's the easiest, though you can probably go faster, if you don't go via String.
21:17:34 <orb__> But do `mod` directly.
21:17:46 <Fuuzetsu> right, that's more of what I need
21:18:01 <Fuuzetsu> this will run inside the main loop of a rhythm game
21:18:32 <jle`> you can do it the mathy way with an unfold or iterate
21:18:54 <orb__> reverse . unfoldr (\b -> if b == 0 then Nothing else Just (b `mod` 10, b `div` 10))
21:19:21 <jle`> ya
21:19:53 <orb__> Data.Digits might be worth a look.
21:20:04 <jle`> (\b -> guard (b > 0) *> Just (b `mod` 10, b `div` 10))
21:20:07 <jle`> hm...
21:20:26 <jle`> @pl \b -> guard (b > 0) *> Just (b `mod` 10, b `div` 10)
21:20:27 <lambdabot> ap ((*>) . guard . (> 0)) (Just . liftM2 (,) (`mod` 10) (`div` 10))
21:20:41 <jle`> boo
21:21:09 <orb__> jle`, if you want to be really efficient, you should use the cpu instruction that does div and mod at the same time.
21:21:30 <Fuuzetsu> let me just stick asm { } block in
21:21:31 <jle`> :O
21:21:39 <shachaf> orb__: I don't think there is such an instruction on most CPUs.
21:21:52 <shachaf> Perhaps there's one that computes quot and rem.
21:23:17 <Fuuzetsu> zz, hackage still reeling
21:23:44 <orb__> shachaf, https://ghc.haskell.org/trac/ghc/ticket/5598
21:24:29 <shachaf> ?
21:30:27 <adarc> anyone know if hackage is wrecked? i'm seeing 502 errors on my cabal installs
21:30:44 <oiuoiu> ongoing migration to a new server
21:31:38 <oiuoiu> adarc: https://www.reddit.com/r/haskell/comments/2hh96i/note_hackage_is_down_disk_space_needs/
21:32:31 <jle`> man...my imports take up an entire screen height
21:32:38 <jle`> this is haskell
21:33:14 <srhb> jle`: Time to build your own Prelude! :P
21:33:21 <yac> jle`: http://www.eatsnowornever.com/wp-content/uploads/2014/04/yeah_science_bitch_meme.jpg thanks :D
21:33:43 <pjdelport> import MyPackage.Imports
21:34:44 <adarc> thanks alot oiuoiu
21:34:55 <oiuoiu> np
21:35:51 <augur> eat snow or never
21:36:58 <iskren> is http://hackage.haskell.org/ returning 502 Bad Gateway for you?
21:37:17 <oiuoiu> iskren: https://www.reddit.com/r/haskell/comments/2hh96i/note_hackage_is_down_disk_space_needs/
21:39:39 <iskren> oiuoiu, thank you. Can I drop some money for drives then :)
21:40:29 <srhb> iskren: Looks like it's already taken care of in this round. :)
21:40:39 <oiuoiu> iskren: try this http://www.haskell.org/haskellwiki/Haskell.org_committee
21:40:50 <oiuoiu> asking the committee, I mean
21:44:17 <yac> jle`: therefore, pythons dict.items() or set to n-tuple function are isomorphisms, right?
21:45:22 <orb__> yac, not really.  Because going back doesn't preserve all structure.
21:45:46 <orb__> dict.items(dict(someList)) != someList in general.
21:45:57 <orb__> dict(someList).items() rather.
21:47:48 <yac> orb__: how come? dict(dict.items()) will give you back the original dict
21:48:11 <orb__> But dict(someList).items() won't give you back the original list.
21:48:27 <yac> well dict doesn't take list
21:48:28 <orb__> it won't preserve ordering or multiple items.
21:48:37 <orb__> dict takes an assoc list, doesn't it?
21:48:39 <yac> it takes a list of tuples exactl
21:49:07 <orb__> Yes.  But it doesn't recreate that list of tuples, when you use .items()
21:49:31 <orb__> >>> dict([(1,2),(3,4),(1,1)]).items()
21:49:36 <orb__> [(1, 1), (3, 4)]
21:50:29 <orb__> If you squint a bit, you can make it an isomorphism.  You'll have to restrict the lists you accept very carefully, or be careful in saying which structure you are talking about preserving.
21:50:32 <yac> oh, I see
21:50:57 <yac> right. But the function set to a n-tuple should be an isomorphism, rigt?
21:51:52 <orb__> yac, same problem.
21:52:14 <orb__> >>> set((1,2,3,3))
21:52:21 <orb__> set([1, 2, 3])
21:52:30 <yac> well it has the same problem. But if I think of isomorphism as "you can convert A into B and B back to A losslessly" it fits
21:52:45 <orb__> tuple(set((1,3,2,3,3))) != (1,3,2,3,3)
21:53:27 <yac> so for it to be isomorphism it must also be true that B must be convertible to A and baack losslessly
21:53:43 <orb__> In Python tuple and set form an isomorphism between sets and tuples that are ordered and not repeating.
21:53:50 <orb__> yac, yes.
21:54:04 <yac> even when it's not possible to create such B that would not convert back properly from A
21:54:30 <yac> yeah, makes sense when I would think about it only in terms of types
21:54:33 <yac> cool
21:55:23 <orb__> yac, though in mathematics the focus is usually on the operations that are preserved, not so much on the seamless back and forth.
21:55:41 <orb__> Because in math, you can always restrict the `type' to make the back and forth work out.
21:55:52 <yac> orb__: that seems to be higher abstraction
22:00:48 <yac> orb__: can I say that dict.items() is half-isomorphic?
22:01:42 <Hijiri> it's only one-third isomorphic
22:01:50 <orb__> half-isomorphic?  What's that supposed to mean?
22:02:07 <yac> orb__: and in python 3 it really is isomoprhic because there it returns a view, which should not have the problem
22:02:10 <Hijiri> it has a dark side that doesn't want to play by the rules
22:02:27 <yac> orb__: that it works only A -> B -> A but not B -> A -> B
22:02:41 <vanila> that's calleda left inverse, or right inverse
22:02:42 <orb__> .items() and dict() is isomorphic in so far, that adding a tuple at the end of your list and adding an entry to your dictionary are basically the same thing.
22:03:05 <orb__> yac, you can just declare B' \subset B to be the subset that works.
22:03:16 <orb__> So A -> B', and B' -> A both work.
22:03:20 <vanila> for example, read is the left inverse of show,  read . show = id, but show . read is not id - it might strip out comments
22:04:04 <yac> shiiiny
22:04:34 <orb__> yac, and dict union is the moral equivalent of list appending.
22:04:35 <vanila> I just checked and i got it backwards
22:06:10 <jle`> actually in haskell, is Maybe a still isomorphic to Either () a in teh presence of bottom?
22:06:38 <jle`> teh
22:06:48 <napping> you have Left _|_ and Left () instead of just Nothing
22:07:03 <jle`> i see
22:07:05 <jle`> well
22:07:13 <jle`> fast and loose reasoning morally correct etc.
22:35:19 <southp0105> Is there an offline coding style checker does the same thing as lpaste? I found that lpaste style checking is really helpful for learning amateur like me :P
22:35:57 <Fuuzetsu> hlint
22:36:38 <southp0105> Fuuzetsu: Thanks. I'll take a look at it : )
22:39:34 <jle`> ghc-mod uses hlint too
22:39:56 <Fuuzetsu> hm it's only 7am and I'm out of steam already
23:16:10 <simon> is cabal broken?
23:17:53 <simon> cabal: Failed to download
23:17:53 <simon> http://hackage.haskell.org/packages/archive/00-index.tar.gz : ErrorMisc "Error
23:17:54 <simon> HTTP code: 502"
23:18:12 <oiuoiu> simon: https://www.reddit.com/r/haskell/comments/2hh96i/note_hackage_is_down_disk_space_needs/
23:22:40 <simon> oiuoiu, thanks!
23:27:09 <dnspies> hello, how come cabal update yields "Unsucessful HTTP code: 502"
23:27:27 <mroman_> hackage is down.
23:27:29 <joelteon> christ
23:27:40 <dnspies> what happened?
23:27:56 <mroman_> Somebody stole disk space .
23:28:27 <mroman_> dnspies: Apparentely they ran out on disk space
23:35:27 <yyttr3> This is off topic but I fould a horribly formatted source online, anyone know a way in vim to change tab space of an already written file?
23:36:24 <mroman_> yyttr3: expandtab + retab?
23:36:43 <mroman_> :set expandtab   :set tabstop=<num of spaces>   :retab
23:36:47 <mroman_> something like that
23:37:13 <orb__> Or use emacs, or a command line tool.
23:37:40 <AshyIsMe> there's also this apparently: https://github.com/jaspervdj/stylish-haskell/blob/master/README.markdown
23:37:44 <AshyIsMe> though i havent tried it
23:38:59 <yyttr3> AshyIsMe: I'll have to try that later, looks like it might be nice.
