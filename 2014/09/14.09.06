00:10:44 <jle`> hm the monoid instance given by the (Applicative f, Monoid a) => Monoid (f a) and mappend  = liftA2 mappend and mempty = pure mempty for [a] is very different from the actual monoid instance for [a]
00:11:27 <jle`> i am wondering if all monoid instances defined that way are lawful
00:12:12 <jle`> hm surely it must be
00:12:19 <jle`> but is this something one can prove
00:12:23 * jle` ponders
00:12:58 <jle`> mempty <> a = a and a <> mempty = a are clear for both [a] and ZipList a
00:13:10 <jle`> associativity falls out as well
00:13:29 <jle`> but perhaps i need to look at the applicative laws to really see if this is true in general for all applicatives
00:17:46 <angerman> what is `ghc-cabal` and why does it have a `copy` directive?
00:18:37 <jollygood> is there a function like this? mapIf even (*10) [1..5] -> [1,20,3,40,5]
00:19:05 <jollygood> without doing it manually in the function
00:19:54 <nshepperd> mempty <> a = pure mappend <*> pure mempty <*> a = pure (mappend mempty) <*> a = pure id <*> a = a
00:19:54 <jle`> @pl mapIf f p = map f . filter p
00:19:55 <lambdabot> mapIf = (. filter) . (.) . map
00:20:01 <merijn> jle`: no
00:20:09 <jollygood> it doesn't remove items that don't match
00:20:11 <merijn> That filters out values, rather than passing them unchanged
00:20:15 <nshepperd> so that takes care of half of one of the monoid laws...
00:20:17 <jle`> ah, i see
00:20:59 <jle`> nshepperd: :)
00:22:00 <supki> > [1,2,3,4,5] & traverse.filtered even *~ 10
00:22:01 <lambdabot>  [1,20,3,40,5]
00:22:20 <trap_exit> is anyone here using an haskell editor/ide written in haskell? I'm at about the end of my ropes with emacs and looking for something new
00:22:47 <jollygood> supki interesting
00:23:24 <jle`> trap_exit: there's yi, but i'm not sure if anyone here is using it
00:23:51 <jle`> :t filtered
00:23:52 <trap_exit> jle`: so what do people here use? emacs + vim ?
00:23:52 <lambdabot> (Choice p, Applicative f) => (a -> Bool) -> Optic' p f a a
00:23:54 <jle`> neat
00:24:46 <jle`> trap_exit: i can't give a good answer :)  i use vim, but that's not really an endorsement
00:24:50 <shachaf> Note that that's not a legal traversal.
00:24:50 <merijn> trap_exit: I just use vim :)
00:25:07 <trap_exit> I mnight try out this leksah
00:25:11 <shachaf> > over (mapped . filtered even) (*10) [1..5] -- a closer translation the original
00:25:13 <lambdabot>  [1,20,3,40,5]
00:25:19 <ferno> Sup
00:25:37 <trap_exit> soudns interesting
00:25:37 <trap_exit> merijn: I used to use vim too, but then I had to learn eamcs to use proof general for Coq, and after that, started using emacs + evil mode
00:25:43 <ferno> Watcha doin?
00:26:13 <jle`> hi ferno
00:27:38 <trap_exit> wtf is http://slidetocode.com/raskell/
00:27:43 <trap_exit> is http://slidetocode.com/raskell/ a haskell running on the ipad ?
00:29:34 <nshepperd> let's see... a <> mempty = pure mappend <*> a <*> pure mempty = pure ($mempty) <*> (pure mappend <*> a) = pure (.) <*> pure ($mempty) <*> pure mappend <*> a = pure (($mempty) . mappend) <*> a = pure id <*> a = a
00:29:59 <nshepperd> so at least mempty behaves like mempty
00:31:13 <nshepperd> I fear to try prove associativity though
00:38:15 <jle`> i can't even think of the applicative laws off the top of my head
00:38:29 <jle`> maybe i can just use the monoidal functor laws to the same effect
00:39:16 <jle`> and say that liftA2 f x y = fmap (uncurry f) (x ** y)
00:39:36 <no-doz> @hoogle (a,_,_) -> a
00:39:38 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
00:39:38 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
00:39:39 <jle`> in the monoidal functor formulation i think that the proof is kind of straightforward though
00:43:21 <Fuuzetsu> is there not a single package that provides a QuickCheck instance for UTF8 strings?
00:43:33 <Fuuzetsu> I know Data.Text generates some but it's all internal ;/
00:45:23 <no-doz> vim seems to be quite bad at {- -} comments :/
00:46:04 <nyuszika7h> hi no-doz
00:46:12 <no-doz> hi :>
00:54:03 <nshepperd> jle`: I tried pushing a <> (b <> c) and (a <> b) <> c into applicative normal form
00:55:10 <nyuszika7h> how can I flush stdout so that whatever I output is displayed immediately?
00:55:25 <nshepperd> there's like ((.) . (.) mappend mappend) and (($mappend) . (.) . (.) . mappend) out the front
00:55:47 <nshepperd> which I think are probably the same thing
00:55:51 <Hafydd> nyuszika7h: is "hFlush stdout" what you want?
00:55:56 <nyuszika7h> probably
00:57:49 <nyuszika7h> Hafydd: yeah, it works
00:57:53 <angerman> anyone who managed to successfully install the 7.8.3 ios ghc?
00:58:17 <Hafydd> nyuszika7h: you may also want to look at hSetBuffering.
00:58:28 <nyuszika7h> I heard about that
01:05:41 <trap_exit> does haskell require that module names be Foo.Bar.Cat ?
01:05:43 <trap_exit> or can I do foo.bar.cat ?
01:06:22 <merijn> Module names must be uppercase
01:06:26 <merijn> Eh, start with
01:06:34 <trap_exit> is foo.bar.Cat okay?
01:06:42 <trap_exit> ()I'm on case insensitive OSX
01:06:46 <trap_exit> so foo/bar/Cat.hs and foo/bar/cat.hs are teh same file
01:07:03 <merijn> trap_exit: Sure, but "import foo.bar.Cat" is a syntax error
01:07:14 <trap_exit> hmm
01:07:19 <merijn> So the case insensitiveness of OSX is irrelevant
01:07:22 <trap_exit> so I can do "import Foo.Bar.Cat" but store it in foo/bar/Cat.hs
01:07:28 <trap_exit> and people who's not on OSX will want my head on a stake
01:07:34 <merijn> Pretty much
01:07:44 <merijn> You should just use Foo/Bar/Cat.hs
01:07:52 <trap_exit> I like my head on my neck, so I'll just use Foo/Bar/Cat.hs
01:08:25 <merijn> "foo.bar.Cat" is parsed as foo, bar and Cat (a constructor) composed
01:09:03 <trap_exit> oh, as in ( (.) foo ( (.) bar Cat)) ?
01:09:10 <trap_exit> i.e. "." = (.) the compose operator?
01:18:58 <merijn> yeah
01:20:30 <psl> is there any pre-configured vm to jumpstart haskell development. something which has all the required tools and configuration already pre-configured
01:20:46 <psl> either vmware or virtual box?
01:25:54 <dario`> psl: not that i know of, but aside from a text editor and haskell platform you shouldn't need much
01:30:53 <psl> dario`: Thx. typically, that is true, but configuring emacs with the right settings, getting the correct ghc, cabal and everything setup does take a few hours.
01:31:40 <psl> dario`: Also, how about deployment. any hosting services specializing in haskell?
01:38:09 <no-doz> is there haskell on raspberry pi?
01:38:49 <fruitz> i guess if you install it, yes :)
01:39:32 <l0cust> no-doz: limited - no ghci or templateHaskell
01:39:44 <no-doz> ahhh
01:40:02 <xintron> Is there any IRC library available (parser) with support for ircv3.2 (especially tags support)?
01:43:48 <edlinde> is there a way to display the types that belong to a certain typeclass like Eq?
01:45:14 <Jafet> @instances Eq
01:45:15 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
01:46:36 <Jafet> Wait, IRC is versioned?
01:47:20 <no-doz> @info Either
01:47:20 <lambdabot> Either
01:47:23 <no-doz> @info Either a
01:47:23 <lambdabot> Either a
01:47:27 <no-doz> ._.
01:48:14 <xintron> Jafet: http://ircv3.atheme.org/
01:48:42 <edlinde> Jafet: @instances doesn‚Äôt work on ghci?
01:49:17 <Jafet> Use :info in ghci.
01:50:49 <edlinde> ok
01:52:17 <Jafet> I doubt there is any complete "ircv3" parser, though everyone and their dog's irc bot will have a parser for some subset of it
01:57:53 <xintron> Jafet, Yeah. I guess so. Saw a few parsers but they were quite old (suitable for most use though)
01:58:04 <xintron> Guess I can take that one and extend it
02:12:46 <aristid> hackage has been really slow for me for ~3 days now. really just me?
02:19:14 <Geraldus> Hi friends! Does anybody experience Hackage slow downs now?
02:19:33 <aristid> Geraldus: yes. i just mentioned it 6 minutes ago!
02:20:24 <Geraldus> aristid: I'm facing this issue since yesterday :(
02:20:49 <aristid> Geraldus: since thursday for me
02:22:10 <Geraldus> aristid: Oh, this is disappointing.
02:23:50 <aristid> yes especially since i want to do some haskell hacking :D
02:27:42 <aristid> also annoying: aeson serialization of a particular JSON object may change over time if the hashable hash changes
02:28:01 <aristid> which makes it harder to create a SHA256 for a JSON object
02:28:23 <Twey> aristid, Geraldus: You can use luite's mirror until the problem's fixed.
02:28:34 <aristid> Twey: what was the link again?
02:28:49 <Geraldus> Great!
02:28:50 <aristid> i mostly want to browse the docs, is that also on his mirrors?
02:29:03 <Geraldus> So do I
02:29:19 <s4msung> any fix for monod-peel on ghc 7.8.3?
02:29:20 <trap_exit> is https://www.youtube.com/watch?v=ScS8Q32lMxA using emacs or vim ?
02:29:29 <aristid> http://hdiff.luite.com/
02:29:42 <Twey> My browser's being really slow at the moment.  But if you Google‚Äî ah, you got it.
02:30:26 <s4msung> trap_exit: vim
02:30:49 <trap_exit> s4smung: do you know what vim packages he's using to get that setup?
02:30:53 <Geraldus> Hmm, I've googled for `luite's hackage mirror` and noticed, that Hackage now works fine.
02:30:54 <trap_exit> llooks not too shabby
02:31:24 <s4msung> trap_exit: looks like tmux + vim
02:31:52 <s4msung> trap_exit: and zsh
02:31:58 <trap_exit> i get it now
02:32:01 <Geraldus> trap_exit: I've used emacs, then switched to vim, and finally returned back to Sublime Text with Vintage mode enabled (vim mode)
02:32:12 <trap_exit> tmux = split in to left + right, where left = vim, and right = split into top/bot, where top = ghci, bot = auto recompile
02:32:41 <Geraldus> trap_exit: Oh. I've misunderstood you, there is Vim on video.
02:32:42 <trap_exit> Geraldus: perhaps burning you at the stakes will finally unite vim + emacs together :-)
02:33:08 <trap_exit> I'm curnttly using emacs + evil emulation mode
02:33:10 <trap_exit> I'm not very happy with it
02:33:38 <Twey> Geraldus: It's been intermittent
02:35:54 <Geraldus> Ok, friends, thank you, have a nice day!
02:48:53 <trap_exit> is anyone here using http://www.mew.org/~kazu/proj/ghc-mod/en/ ?
02:49:03 <trap_exit> it seems like would be cool and would provider deepepr coding / ghc intergration
02:53:29 <Twey> trap_exit: Lots of people use it, yes.
02:53:43 <trap_exit> cool
02:53:47 <trap_exit> I wish I had run into it earlier
03:29:46 <nyuszika7h> is it okay to mix [Char] and String to emphasize that one of the arguments is really just a list of characters, or is that considered bad style?
03:31:08 <ion> I don‚Äôt see a problem with it.
03:31:37 <nyuszika7h> me neither :)
03:48:00 <angerman_> i can't believ it. I have haskell runnng on iOS...
03:49:34 <eriksensei> angerman_: cool! it's one of my life goals to try that one day
03:56:19 <no-doz> > let (+) = foldr (.) id . flip replicate succ ; (*) = (fmap $ foldr ($) 0) . flip replicate . (+) ; (^) = (fmap $ foldr ($) 1) . flip replicate . (*) in 2 ^ 3
03:56:21 <lambdabot>  can't find file: L.hs
03:56:29 <no-doz> > let (+) = foldr (.) id . flip replicate succ ; (*) = (fmap $ foldr ($) 0) . flip replicate . (+) ; (^) = (fmap $ foldr ($) 1) . flip replicate . (*) in 2 ^ 3
03:56:30 <lambdabot>  8
04:12:43 <angerman_> eriksensei, it's actually fairly trivial :D, lukexi did an amaying job. I only had to fix the installGHCiOS.sh script, which was not at all obvious, what went wrong.
04:13:16 <angerman_> eriksensei: now I'll have to explore what objc related packages haskell has to offer :)
04:18:04 <eriksensei> angerman_: good to hear! :)
04:18:27 <nyuszika7h> GHCiOS sounds like an interesting operating system :D
04:25:34 <srhb> nyuszika7h: If only :)
04:25:41 <nyuszika7h> Glasgow Haskell Compiler Interpreter Operating System
04:26:21 <srhb> Not sure how a Haskell OS would compare to, say, Emacs. Considering how easy it is to work with lisp in a dynamic way.
04:35:39 <angerman_> srhb: dont' we have Haskell OS in the form of HaLVM from galois already?
04:35:58 <srhb> I suppose so.
04:36:10 <srhb> But I want the Emacs-like version. If someone ever works out how to do it. :-)
04:37:07 <no-doz> hmm, I didn't know about HaLVM
04:37:14 <no-doz> sounds interesting
04:38:38 <alpounet> srhb: well, yi does have some of the dynamic stuffs you're talking about I think
04:39:09 <srhb> alpounet: I should check it out some day.
04:39:47 <alpounet> also, xmonad/dyre allow dynamic re-configuration with haskell code as the configuration language
04:40:34 <srhb> alpounet: Not in quite the same sense as Emacs is dynamic. It is a reload after all.
04:41:22 <alpounet> yes agreed
04:41:41 <alpounet> but still, that's enough in some cases
04:41:44 <srhb> Very true.
04:42:13 <alpounet> if you want dynamic code loading/unloading in general without restarting everything, you have to go the plugins route
04:42:17 <srhb> I do enjoy the way xmonad works. I'd love it even more if it were more like Emacs. Throw in some Haskell, evaluate it and instantly have the changes be reflected in XMonad.
04:42:21 <srhb> Aye.
04:42:51 <alpounet> but that road isn't as clean and documented :)
04:44:16 <srhb> Indeed. It would be really cool if it were though. :-)
05:06:59 <osa1> does `arbitrary` from QuickCheck generate recursive terms like `let a = 1 : a in a` ? or to be more precise, I have a language syntax which is of course a recursive type. for some reaons my quickcheck tests are stuck in an infinite loop and I'm wondering if that may be because QC generates intinite/self-referring terms.
05:09:08 <Cale> osa1: Typically not, certainly not for the instances which come with the library
05:21:50 <d42> Hi, can anyone take a minute to help me with using Map.insertWith to insert multiple values into a map. I'm trying to Map.fold' over it. http://lpaste.net/110596
05:24:09 <Cale> d42: The fromList on nucleotideMap seems wrong
05:25:42 <Cale> d42: Either you want to do  fromListWith (+) $ zip n (repeat 1)
05:26:37 <Cale> Or  foldl' (\acc x -> insertWith (+) x 1 acc) empty n
05:27:07 <Cale> You seem to be doing some weird combination of these :)
05:29:14 <d42> Cale: that would be my Haskell ignorance shining through
05:29:23 <d42> Cale: I'll give your suggestions a try right now
05:30:26 <d42> Cale: oh, I think that I understand your comment better now. Actually, I first solved the exercise using fromListWith but didn't like that I couldn't complete it using insertWith
05:35:43 <osa1> can I set timeout for a QC Testable?
05:37:45 <d42> actually, I don't think that ``foldl' (\acc x -> insertWith (+) x 1 acc) empty n`` will work with the typestring ``nucleotideCounts :: String -> Map Char Int``
05:38:50 <osa1> is there a way to print QuickCheck generated term in an unsafe way? (e.g. like Debug.Trace.trace)
06:38:27 <kuribas> Would it be possible to extend a type system with narrowing logical variables?
06:39:06 <kuribas> For example in metafont a variable can be independend, known (a constant number), or dependend (linear dependency on other independen variables).
06:39:29 <kuribas> I wonder if there would be some kind of effect system to make this safe.
06:40:22 <kuribas> So that inconsistent or redundant equations wouldn't be well typed.
06:44:55 <vanila> kuribas, that sounds like something that could be done in theory
06:45:16 <kuribas> but hasn't been done before?
06:45:23 <NikolajK> 'do' is defined in terms of >>=. What is 'do' in terms of '>=>'?
06:45:40 <kuribas> :t (>=>)
06:45:41 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
06:45:47 <kuribas> :t (>>=)
06:45:48 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:46:31 <hpc> :t \m f -> (\() -> m) >=> f $ ()
06:46:32 <lambdabot> Monad m => m b -> (b -> m c) -> m c
06:46:37 <NikolajK> the do construction is pretty involved. Lamdba abstractions of terms x in f in "‚Ä¶>>=f"
06:47:00 <kuribas> :i (>=>)
06:47:50 <NikolajK> do {x <- mx; y <- my; http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:return (f x y)}
06:47:50 <NikolajK> is
06:47:50 <NikolajK> mx >>= \x->(my >>= \y ->(http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:return (f x y)))
06:47:58 <kuribas> (>=>) composes monad functions?
06:48:30 <NikolajK> mhm, I come from the math side, I don't know what you mean by monad functions
06:48:51 <kuribas> I mean functions returning monads?
06:49:04 <barrucadu> :t (.)
06:49:04 <lambdabot> (b -> c) -> (a -> b) -> a -> c
06:49:06 <barrucadu> :t (>=>)
06:49:07 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
06:49:13 <NikolajK> functions returning monads?
06:49:23 <barrucadu> Look at how similar the types are
06:49:43 <NikolajK> yeah, >=> is a a composition
06:50:21 <NikolajK> (in the Kleisli category)
06:51:15 <NikolajK> ah, by monad functions you mean functions with images which are images of the monad applied to some type
06:51:26 <NikolajK> then the answer is yes :)
06:52:01 <kuribas> NikolajK: I guess so :) I have no CS degree ...
06:52:15 <NikolajK> I'm a physicist
06:53:13 <NikolajK> by your definition, the map mapping a natural number n [n^2,n^3] is a "monad function". :P
06:53:29 <NikolajK> n to the list [n^2,n^3] of numbers
06:54:02 <barrucadu> It is; a monadic function using the list monad
06:55:03 <NikolajK> so let's try to get rid of >>= in mx >>= \x->(my >>= \y ->(http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:return¬†(f x y)))
06:55:32 <{AS}> Hi, does anyone know what to do regarding Homebrew/HP2014/OSX?
06:56:49 <NikolajK> (f >=> g) a = f a >>= g
06:57:29 <NikolajK> ma >>= f = (http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:id >=>  f)  ma
06:57:56 <kuribas> NikolajK: But do notation returns a monad, while >=> returns a function returning a monad.
06:58:31 <NikolajK> I don't know what "returns a monad" is supposed to mean
06:58:40 <{AS}> So what I mean is, is it possible to install Haskell Platform 2014.2 on OS X using Homebrew or else what is the recommended way of installing things?
06:58:44 <barrucadu> Returns a value in a monadic context
06:59:00 <barrucadu> A value Monad m => m a, for some a
06:59:20 <NikolajK> you can introduce monads via >=>, so every concept can be expressed in terms of it
06:59:36 <kuribas> NikolajK: Ok, more accurately, the type of a do notation block is a monad.
07:00:05 <NikolajK> kuribas: that doesn't sound more accurate, but okay, I know what you mean
07:00:34 <NikolajK> (a monad isn't a type, at least in Haskell)
07:01:05 <kuribas> A typeclass
07:02:24 <xcthulhu> What is the magic in Emacs to get haskell mode to print the type of the thing under the cursor in the mode-line?
07:02:48 <xcthulhu> Oh, and is there anything that lets you jump to the source code declaration for something?
07:02:58 <xcthulhu> Because that would be awesome...
07:03:46 <sm> cabal install hasktags; hasktags -e `find . -name "*hs"` and M-x .  for the latter
07:03:50 <NikolajK> first observation:
07:03:51 <NikolajK> "do {x <- mx; y <- my; http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:return¬†(f x y)}" is
07:03:51 <NikolajK> (http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:id¬†>=> ¬†\x->((http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:id¬†>=> ¬†\y ->(http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:return¬†(f x y)) ¬†my)) ) ¬†mx
07:03:51 <kuribas> xcthulhu: It uses the underlying ghc process.
07:03:59 <sm> M-. I mean
07:06:08 <kuribas> xcthulhu: You can use tags for that.
07:07:11 <xcthulhu> NikolajK:  I usually just remember the category theory definition...
07:07:43 <NikolajK> of do? :)
07:07:57 <xcthulhu> (the old MacLane commuting diagrams)
07:07:57 <xcthulhu> No, not of do
07:08:08 <xcthulhu> üòù
07:09:18 <NikolajK> I'd like to know the flow of things being processed in a do statements in terms of some objects and arrows, that's why I ask
07:10:36 <NikolajK> mhm, what does "do" do for the identity monad
07:10:48 <xcthulhu> Yeah, me too.  I usually skip do notation and just use the Kleisli arrow if I can program everything point-free
07:10:56 <NikolajK> then I'd assume do {x <- mx; y <- my; http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:return¬†(f x y)} is just f x y
07:11:26 <kuribas> NikolajK: do is just syntactic sugar for bind (>>=)
07:11:43 <xcthulhu> Not exactly.  The identity monad still involves a type constructor
07:12:12 <NikolajK> xcthulhu: k, f x y plus a name tag
07:12:35 <NikolajK> kuribas: I guess we had that at 15:46
07:12:52 <NikolajK> wait, that's some local time
07:13:10 <xcthulhu> NikolajK: In every monad (identity or no) then your code would be the same as `liftM2 f x y`
07:13:24 <xcthulhu> Where liftM2 is from Control.Monad
07:13:44 <NikolajK> xcthulhu: yo, thx
07:14:09 <xcthulhu> What makes the identity unique up to isomorphism is a coalgebra ‚ÄúunId :: Id a -> a‚Äù
07:14:47 <kuribas> NikolajK: then why do you ask what "do" does?  It doesn't do anything, it's just sugar.
07:15:06 <xcthulhu> And maybe the law ‚Äú unId . (fmap f) . return x == x ‚Äú
07:15:41 <xcthulhu> erm
07:15:53 <xcthulhu> (unId . (fmap f) . return) x == f x
07:16:05 <NikolajK> kuribas: it's mx >>= \x->(my >>= \y ->(http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:return¬†(f x y))). Could frame the question as to what that does. The real question is in what sense it forces step by step evaluation and I need to see how the values are passed along the categorical diagram
07:16:57 <NikolajK> the problem, for me, is that the diagram involves types which are function spaces
07:17:31 <augur> what does the RTS actually do
07:17:44 <kuribas> NikolajK: Sorry, I am not helpful, since I know nothing about cathegory theory...
07:18:46 <kuribas> NikolajK: But (>>=) doesn't force strict evaluation, it's just lazy like any other value in haskell.
07:19:07 <kuribas> The IO monad however forces evaluation.
07:19:47 <NikolajK> yeah, I didn't speak about strict evaluation, but I'm aware that "step by step" evaluation isn't what really happens either
07:20:15 <NikolajK> So we have ma >>= f = (http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:id >=>  f)  ma.
07:20:15 <NikolajK> If (>=>)  :: (a -> m b) -> (b -> m c) -> (a -> m c),
07:20:15 <NikolajK> then (http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:id >=>  f) is of type ‚Ä¶
07:20:43 <NikolajK> (b -> m c) -> (m b -> m c)
07:20:57 <NikolajK> \f->(http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:id¬†>=> ¬†f) I must mean
07:22:49 <NikolajK> I guess do in terms of >>= doesn't make things easier...
07:23:07 <NikolajK> so what's do in terms of join and fmap :D
07:23:21 <xcthulhu> NikolajK:  (>>=) Doesn‚Äôt usually show up in categorical presentations of monads
07:23:32 <benzrf> yeah...
07:23:35 <benzrf> join is much better!!
07:23:47 <xcthulhu> The classic monad laws assume a functor (hence fmap) and are defined in terms of `join` and `return`
07:23:56 <NikolajK> (I'm aware)
07:24:11 <benzrf> eta & mu
07:24:28 <benzrf> aka mempty and mappend!!
07:25:07 <kuribas> isn't "join (fmap f m)" "(m >>= f)"?
07:25:15 <NikolajK> ma >>= f = (join . (http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap f)) ma
07:25:42 <NikolajK> (so yeah)
07:27:01 <kuribas> then do {a <- m; n a} == join (fmap (\a -> n a) m)
07:27:08 <NikolajK> do {x <- mx; y <- my; http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:return¬†(f x y)}
07:27:08 <NikolajK> is
07:27:09 <NikolajK> (join . (http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap¬†\x->((join . (http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap¬†y ->(http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:return (f x y)))) my))) mx
07:27:29 <DanC__> I'm trying to get started with cabal sandboxes, but when I try to build cabal from git, I get: Network/StreamSocket.hs:37:25: Module `System.IO.Error' does not export `catch' Failed to install HTTP-3001.0.4
07:27:57 <xcthulhu> kuribas> by eta reduction we have `do {a <- m; n a} == join (fmap n m)`
07:28:16 <kuribas> xcthulhu: yes
07:28:21 <xcthulhu> yay math
07:29:20 <NikolajK> the question, for me, is this: do {x <- mx; y <- my; http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:return¬†(f x y)} wants to know mx before my because my can depend on x (if I understand correctly). How can I "see" this in the diagram of chained functions
07:30:11 <xcthulhu> Depends on the monad
07:30:42 <NikolajK> I think of the generic case where the worst things happen
07:30:58 <Fuuzetsu> http://fuuzetsu.co.uk/images/1410013748.png McBride general
07:31:01 <xcthulhu> If the monad is commutative then it doesn‚Äôt matter: http://www.haskell.org/haskellwiki/Monad#Commutative_monads
07:31:22 <xcthulhu> Isn‚Äôt LinAlg commutative?  I seem to recall that
07:31:41 <xcthulhu> gtg
07:32:00 <NikolajK> ?
07:32:12 <NikolajK> >matrix multiplication is commutative
07:32:46 <DanC__> ah... when I put ~/.cabal/bin in my path, I find I already have a modern version of cabal
07:32:50 <augur> Fubar^: its very conorian :)
07:34:29 <DanC__> no... hmm...
07:39:36 <DanC__> ok... finally... cabal sandbox init works
07:39:56 <koute> Hi. I'm learning Haskell by playing around and I've been trying (unsuccessfully) to pass an operator to a function and use that operator on two different types: http://lpaste.net/110607
07:40:00 <koute> Could someone please tell me how can I get it to work?
07:40:47 <prophile> koute: you need an operator that works for *all* x
07:41:05 <prophile> (==) only works for x in the Eq typeclass
07:41:28 <prophile> but you can't compare functions with (==) for instance
07:41:49 <koute> Yes, I'm perfectly aware of this.
07:42:20 <prophile> so you can't call foobar with (==)
07:42:29 <prophile> because the argument must be of type forall x. x -> x -> Bool
07:42:33 <prophile> and (==) isn't of that type
07:42:45 <prophile> it's of type forall x. Eq x => x -> x -> Bar
07:43:16 <koute> Is there any way that I can write that function so that it will work for any operator?
07:44:47 <prophile> so it looks like what you want isn't something that operates on all types
07:44:57 <prophile> but just something that operates on Integers and Bools?
07:45:55 <koute> e.g. if I'll type ((==) 1 1, (==) True True) in ghci it will work properly
07:46:15 <prophile> yes, because Int and Bool are both in the Eq typeclass
07:46:27 <prophile> if you did (==) id id it would complain
07:46:43 <trap_exit> sup
07:46:49 <prophile> o/
07:46:52 <koute> now I want to refactor that into a separate function, and want to pass the operator as a parameter
07:46:56 <trap_exit> ask not what #haskell can do for you, ask what you can do for #haskell
07:47:19 <prophile> koute: what do the types have in common which means one operator can work on both?
07:47:22 <koute> The problem is, if I put Eq x in the type signature it will limit what operators I can pass to it
07:47:26 <hpc> ask not what #haskell can (>>=) for you?
07:47:53 <trap_exit> hpc: isn't >>= bind ?
07:48:03 <hpc> desugared do-notation ;)
07:48:09 <nexx> at least you should not >> #haskell
07:48:31 <trap_exit> "nexx >> #haskell" = /ignore nexx
07:48:35 <prophile> koute: foobar x needs to "work" for any x you can pass it
07:49:01 <nexx> err at least you should not << #haskell
07:49:09 <trap_exit> i recently came up with this new crazy programming style
07:49:18 <Jonhy-lembrouill> Gi
07:49:19 <Jonhy-lembrouill> Hi
07:49:20 <trap_exit> it's based on the observation that ... I genreally produce about < 100 lines of haskell code per day
07:49:23 <prophile> and the only restrictions it can impose on what xs it gets passed is the type signature
07:49:29 <trap_exit> so therefore, I might as well as put each _function_ in it's own file
07:49:36 <trap_exit> then using CPP, #include all the files together
07:49:42 <prophile> for instance, what if you did foobar (+)?
07:49:53 <prophile> that would fail to type check for (+) True True
07:49:57 <trap_exit> so if I have a module Expr, it would be Expr.hs, Expr/expr__blah.hs Expr/expr__foo.hs ... and Expr.hs just includes all those files together
07:49:58 <koute> Yes it would.
07:50:09 <koute> That was just a simple, silly example.
07:50:17 <koute> I'm *perfectly* aware of that (:
07:50:25 <prophile> right, BUT
07:50:29 <koute> You're just misunderstanding my question, I think.
07:50:30 <ocharles> koute: `forall x. x -> x -> Bool` only has two possible inhabitants, I believe -- `\_ _ -> True` and `\_ _ -> False`
07:50:53 <nexx> koute I guess we are not aware of what you really want
07:50:55 <ocharles> so yes, I think I'm misunderstanding what you're doing... (because you could just pass in `Bool` and not need a function at all)
07:51:15 <prophile> ocharles: and _|_, and \_ -> _|_, and \_ _ -> _|_ I think
07:51:34 <ocharles> ok sure, i tend to not worry about those things at this sort of "design" stage
07:51:46 <ocharles> but strictly speaking, you're right
07:51:47 <prophile> right
07:51:53 <prophile> well, lazily speaking anyway
07:51:55 <ocharles> :D
07:53:08 <koute> I want that function to work just as if I would type it in ghci, replacing 'op' with '(==)'
07:53:14 <dfeuer> How long does lambdabot hold on to messages?
07:53:28 <prophile> koute: we do understand what you mean
07:53:32 <prophile> it's just that there is no such function
07:53:46 <prophile> because it would only type check for some operators
07:53:58 <Laquendi> is there some functional difference between _|_ :: forall x. x -> x -> Bool and \_ _ -> _|_ :: forall x. x -> x -> Bool
07:54:29 <geekosaur> dfeuer, until the recipient gets it or someone messes up and wipes lb's state
07:54:35 <prophile> Laquendi: I think case f () of { _ -> "bees" } differs
07:54:55 <prophile> if f is _|_ that's _|_
07:55:04 <prophile> but if f is const _|_ that's "bees"
07:55:13 <hpc> prophile: no
07:55:20 <nexx> koute maybe you want? https://www.haskell.org/ghc/docs/7.6.1/html/users_guide/defer-type-errors.html
07:55:20 <hpc> the thunk <f ()> is not evaluated
07:55:33 <dfeuer> > case undefined of { _ -> "bees" }
07:55:35 <lambdabot>  "bees"
07:55:36 <prophile> ah yes
07:55:41 <prophile> oops
07:55:44 <prophile> hm
07:55:55 <hpc> you can try it out in ghci (unfortunately not with "bees" though, :sprint is weird with lists)
07:55:59 <dfeuer> I believe you can only tell the difference using seq, pseq, bang patterns, etc.
07:56:42 <prophile> > undefined `seq` "test"
07:56:44 <lambdabot>  "*Exception: Prelude.undefined
07:56:48 <prophile> > (const undefined) `seq` "test"
07:56:50 <lambdabot>  "test"
07:56:52 <prophile> ok
07:57:00 <prophile> Laquendi: ^
07:58:04 <dfeuer> Laquendi, they also have different types.
07:58:20 <dfeuer> Well.they *can*
07:58:26 <dfeuer> Forget I said that.
07:58:30 <dfeuer> _|_ isn't specific enough.
07:59:29 <koute> nexx: unfortunately not; I just want to pass an operator to function and use that operator in two different places with different types assuming the operator *could* be used there if I'd were simple macro expansion
07:59:31 <dfeuer> But   undefined::a  while  \_ _->undefined has type a -> b -> c  So (\_ _ -> undefined)+1   would give a type error.
08:00:18 <dfeuer> koute, can you be more specific about what you want to do?
08:00:34 <Philonous> Is there a semantic difference between ExceptT and EitherT?
08:02:19 <prophile> Philonous: EitherT from which package?
08:02:32 <Philonous> prophile, either
08:02:33 <avaritia> hey, where can i find any info about darcs1 exponential merges?
08:02:58 <prophile> Philonous: no
08:03:04 <prophile> not that I can see anyway
08:03:05 <Philonous> Hah, wonderful.
08:03:07 <koute> dfeuer: I've simplified what I want to do into the example I've pasted: foobar op = ((op 1 1), (op True True)) -- assuming 'op' is a valid operator for both Int and Bool, e.g. '=='
08:03:22 <prophile> EitherT and ExceptT are both "ErrorT without requiring an Error instance"
08:03:26 <koute> If it can't be done then tell me it can't be done and I'll rething what I'm doing (:
08:03:51 <Fuuzetsu> you need higher rank in your signature
08:04:01 <dfeuer> Higher rank isn't enough.
08:04:05 <Fuuzetsu> why not?
08:04:17 <Philonous> prophile, aka "The way it should have been to begin with"
08:04:20 <Philonous> prophile, THanks
08:04:35 <dfeuer> Because there doesn't seem to be any sufficient constraint.
08:05:14 <prophile> koute: you could do it with a CPP macro  Õ°¬∞ Õú ñ Õ°¬∞
08:05:19 <NikolajK> what's wrong here:
08:05:20 <NikolajK> > do {x <- (2^2-4); y <- (x*(x+1)); return (x+y)}
08:05:21 <lambdabot>  Occurs check: cannot construct the infinite type: t ~ m t
08:05:22 <lambdabot>  Relevant bindings include
08:05:22 <lambdabot>    y :: t (bound at <interactive>:1:19)
08:05:22 <lambdabot>    x :: m t (bound at <interactive>:1:5)
08:05:22 <dfeuer> Int and Bool are both in Ord, and both in Show. Should this be constrained to Ord? Or to Show?
08:05:46 <dfeuer> koute, if you give more details about what you want to *do* with this operator, then Fuuzetsu's idea may work out.
08:05:53 <prophile> NikolajK: which monad instance are you trying to use?
08:05:53 <koute> prophile: ... I don't want to resort to macros (:
08:06:05 * Fuuzetsu assumed constraints were known already
08:06:08 <Fuuzetsu> didn't read up
08:06:36 <prophile> how rude
08:06:50 * dfeuer ___ prophile in the ____, politely.
08:06:58 <NikolajK> none yet
08:07:11 <NikolajK> can I rewrite that do block so it knows a monad to use?
08:07:29 <prophile> well, it's not really a monadic expression
08:07:50 <NikolajK> gimme some which doesn't alter the numeric computation I want to express
08:07:51 <prophile> I think what you're trying to do is let { x = (2^2-4); y = (x*(x+1)) } in return (x + y)
08:08:06 <Fuuzetsu> :t runIdentity
08:08:07 <lambdabot> Identity a -> a
08:08:10 <NikolajK> right, but I want to do that in a do
08:08:17 <prophile> why?
08:08:22 <geekosaur> you can't, not like that
08:08:27 <geekosaur> <- is not =
08:08:56 <NikolajK> as an example where evaluation of x before y is a good idea
08:09:16 <prophile> if you _really_ want to use a do-expression for some reason it's either do { let x = (2^2-4); let y = (x*(x+1)); return (x + y) }
08:09:22 <geekosaur> `x <- (2^2-4)` is perhaps valid in ((->) r) but won't do anything like what you expect
08:09:32 <prophile> or do { x <- return (2^2-4); y <- return (x*(x+1)); return (x+y) }
08:10:04 <Fuuzetsu> NikolajK: sequencing is not inherent to monads
08:10:25 <NikolajK> Fuuzetsu: elaborate what you want to get at
08:10:45 <Fuuzetsu> I'm saying you're trying to shoehorn do onto something that doesn't need it
08:10:54 <prophile> geekosaur: they're probably both valid for some combination of monad and num instances
08:11:04 <geekosaur> but are they sensible?
08:11:19 <prophile> possibly?
08:11:28 <prophile> you can lift num instances to any applicative
08:11:31 <prophile> and they behave pretty sensibly
08:13:11 <ocharles> avaritia: what did you want to know about them?
08:14:10 <geekosaur> Nikolajk, you seem to be assuming that "do" is a magic sequencing thing that will solve data dependency probleme. In fact, sequencing is part of the (actually, most of the) IO monad
08:16:15 <NikolajK> geekosaur: na, I don't necessarily assume the computer does clever tricks with dependencies - I just think that it might be possible to think about the procedural aspect of do in functional languages this way
08:16:31 <geekosaur> not helpfully
08:17:00 <geekosaur> more to the point, the things you seem to think are part of do are actually part of IO
08:17:29 <geekosaur> do in the list monad is neither sequential nor procedural
08:20:36 <phaazon> ohoh
08:20:46 <phaazon> I found a nasty bug in linear!
08:21:05 <Fuuzetsu> you're pretty excited for this
08:21:19 <phaazon> Fuuzetsu: yep, because it was very unexpected
08:21:44 <Fuuzetsu> nasty, very unexpected bugs usually get me right on the other end of spectrum
08:22:04 <phaazon> what spectrum?
08:22:16 <Fuuzetsu> of being excited and being soul-crushed
08:22:26 <phaazon> I‚Äôm surprised since edward should have written some unit tests to test the whole thing
08:22:34 <phaazon> my 3D engine has wrong camera movement
08:22:40 <phaazon> so I rewrite the function used from linear
08:22:47 <phaazon> and now it works
08:22:53 <phaazon> I‚Äôm writing a bug report :)
08:23:08 * gfixler_ perks up at the mention of a 3D engine
08:23:17 <phaazon> :P
08:23:58 <phaazon> http://phaazon.net/pub/blinn_bug.png
08:24:09 <phaazon> the issue might be related to the bug I‚Äôm talking about
08:24:18 <Fuuzetsu> phaazon: yes, I was surprised this way like a day or two ago so I created few issues
08:24:19 <lpvb> if you have the solution should you PR
08:24:27 <Fuuzetsu> I was promptly given repository access‚Ä¶
08:24:33 <phaazon> great!
08:24:37 <phaazon> yes I have the solution
08:24:39 <phaazon> PR?
08:24:41 <phaazon> oh
08:24:42 <phaazon> pull request
08:24:44 <phaazon> great idea!
08:24:58 <gfixler> looks like coronal ejecta
08:25:07 <phaazon> ahah
08:25:24 <phaazon> I have multi lights + blending enabled now
08:25:29 <phaazon> it‚Äôs‚Ä¶ JIZZ¬†IN¬†YOUR¬†PANTS :D
08:26:06 <phaazon> https://www.youtube.com/watch?v=VLnWf1sQkjY
08:26:19 <meretrix> Is there a way to automatically derive CSV serializations for lists of generic data types?
08:27:51 <phaazon> hm
08:27:56 <phaazon> Thrustworthy
08:28:00 <phaazon> what‚Äôs that extension?
08:28:36 <Fuuzetsu> https://www.haskell.org/ghc/docs/latest/html/users_guide/safe-haskell.html
08:31:01 <geekosaur> "Thrustworthy" sounds like code that shuld be fired into the sun >.>
08:34:24 <dfeuer> geekosaur, it probably relates to that "jizz in my pants" thing.
08:40:13 <Guest36025> hey calling Functor as computaional context is correct anology?
08:40:45 <ion> Burrito is clearer.
08:40:46 <ReinH> It's not correct, but it might be useful.
08:43:03 <gfixler> "functor" could be a functor, right?
08:43:44 <gfixler> > fmap toUpper "functor"
08:43:45 <lambdabot>  "FUNCTOR"
08:46:05 <ReinH> [] is an instance of Functor, yes.
08:49:32 <benzrf> gfixler: "functor" isnt a functor
08:49:41 <DanC__> index rewrite
08:49:43 <DanC__> @index rewrite
08:49:43 <lambdabot> bzzt
08:49:46 <benzrf> it's an inhabitant of a type whose constructor is a functor's object mapping
08:49:48 <benzrf> ( Õ°¬∞ Õú ñ Õ°¬∞)
08:50:14 <benzrf> i want lambdabot's old @faq back ;-;
08:50:36 <hpc> The answer is yes! Lenses can do that!
08:50:41 <benzrf> ayy lmao
08:50:54 <benzrf> i believe u mean "lens can do that"
08:50:59 <benzrf> wouldnt want to mix up lenses and the lens package
08:51:08 <benzrf> ([], map) is a functor
08:51:22 <benzrf> "foo" is a value of type [Char], and [] is the constructor used to make [Char]
08:51:39 <benzrf> [] as in the type constructor, not the value
08:51:54 <gfixler> > concatMap (replicate 3) "wow"
08:51:55 <lambdabot>  "wwwooowww"
08:52:04 <benzrf> > replicateM 3 "wow"
08:52:06 <lambdabot>  ["www","wwo","www","wow","woo","wow","www","wwo","www","oww","owo","oww","oo...
08:52:09 <benzrf> oooops
08:52:20 <gfixler> let's try to calm down a bit here
08:52:22 <benzrf> > "wow" >>= replicate 3
08:52:24 <lambdabot>  "wwwooowww"
08:52:37 * gfixler is not quite there yet
08:52:49 <benzrf> > ["wow", "owo", "wow"] >>= (>>= replicate 3)
08:52:51 <lambdabot>  "wwwooowwwooowwwooowwwooowww"
08:53:02 <benzrf> hmm
08:53:36 <gfixler> take 10 $ cycle "wow"
08:53:39 <gfixler> > take 10 $ cycle "wow"
08:53:40 <lambdabot>  "wowwowwoww"
08:53:46 <gfixler> > take 10 $ cycle "wo"
08:53:48 <lambdabot>  "wowowowowo"
08:54:05 <benzrf> > ["wow", "owo", "wow"] >>= replicate 3 . (>>= replicate 3)
08:54:06 <lambdabot>  ["wwwooowww","wwwooowww","wwwooowww","ooowwwooo","ooowwwooo","ooowwwooo","ww...
08:54:10 <gfixler> > cycle "wow"
08:54:12 <lambdabot>  "wowwowwowwowwowwowwowwowwowwowwowwowwowwowwowwowwowwowwowwowwowwowwowwowwow...
08:54:26 <agatam> 3
08:54:26 * gfixler remembered that lambdabot will trim things for him
08:55:02 <benzrf> @let data Foo = Foo
08:55:05 <lambdabot>  Defined.
08:55:15 <benzrf> @let instance Show Foo where show Foo = "foo\nbar"
08:55:16 <lambdabot>  Defined.
08:55:17 <benzrf> > Foo
08:55:19 <lambdabot>  foo
08:55:19 <lambdabot>  bar
08:55:19 <gfixler> I couldn't do that the other day with >
08:55:22 <gfixler> what's the difference?
08:55:26 <gfixler> why @let?
08:55:26 <benzrf> i tricked lambdabot
08:55:37 <benzrf> gfixler: @let deposits your code snippet into a file called L.hs
08:55:42 <benzrf> that is imported into the env that > runs i
08:55:43 <benzrf> n
08:56:03 <benzrf> things after > are expected to be expressions
08:56:09 <lumo_e> is the file ever emptied?
08:56:10 <gfixler> ooooh
08:56:15 <gfixler> that's what L.hs is
08:56:30 <benzrf> @let data Bar = Bar
08:56:32 <lambdabot>  Defined.
08:56:53 <benzrf> @let instance Show Bar where show Bar = "foo\r\nPRIVMSG benzrf :hi"
08:56:54 <lambdabot>  Defined.
08:56:57 <benzrf> > Bar
08:56:58 <lambdabot>  foo
08:56:58 <lambdabot>  PRIVMSG benzrf :hi
08:57:00 <benzrf> aw
08:57:11 <lumo_e> not so dumb :)
08:57:24 <benzrf> 11:55 < lambdabot>  PRIVMSG benzrf :hi
08:57:24 <Fuuzetsu> lambdabot has been around for a pretty long time
08:57:37 <benzrf> i certainly wasnt expecting that to work
08:57:39 <gfixler> toaaguywalksbar
08:57:42 <benzrf> but one may always hope
08:57:48 <lumo_e> ahah
08:58:53 <gfixler> benzrf: you just dropped tables
09:01:58 <quxbam> i'm trying to install haskell on debian, installed ghc and haskell-plattform, but don't find the REPL. ghc --interactive barfs about not being build for interactive use
09:02:43 <quxbam> i'm on armhf, if that matters
09:02:51 <DanC__> this program is calling rewrite; I want to know whence comes rewrite; how can I use ghci (or better yet: an emacs mode) to tell me?
09:05:09 <ReinH> quxbam: have you tried ghci?
09:06:09 <quxbam> it isn't in the repo
09:06:56 <benzrf> quxbam: you're solirc
09:06:58 <benzrf> er
09:06:58 <benzrf> SOL
09:07:03 <int-e> ghci support is platform dependend. https://ghc.haskell.org/trac/ghc/wiki/Platforms doesn't list arm
09:07:06 <benzrf> quxbam: there is no repl for arm
09:07:11 <benzrf> int-e: hey
09:07:11 <DanC__> I can't :load Main.hs nor :m Main. hmm
09:07:16 <quxbam> yuck
09:07:25 <benzrf> int-e: can we get type families, datakinds, and the old @faq in lambdabot pls
09:07:35 <int-e> yes, yes, no.
09:07:42 <benzrf> why the no ;-;
09:09:23 <int-e> because now @faq is actually useful
09:09:31 <int-e> rather than a silly joke
09:09:38 <benzrf> silly jokes > actually useful
09:09:43 <benzrf> we already have
09:09:46 <benzrf> @where faq
09:09:46 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
09:09:48 <benzrf> why the separate command
09:10:04 <int-e> it's shorter.
09:10:26 <trap_exit> for building webapps, what's a good db to use in haskell ?
09:10:33 <benzrf> int-e: >:\
09:10:40 <trap_exit> I want something as close to haskell as possible
09:10:47 <trap_exit> i.e. i care more about the haskell DSL I get to use more than the actual DB
09:11:33 <exio4> how could i make the notion of "subset" explicit? "[a] -> subset-of-[a]"?
09:12:08 <vanila> exio4, that's not possible in haskell
09:12:10 <benzrf> exio4: i dont think haskell's type system is powerful enough
09:12:18 <benzrf> exio4: you could use a newtype but thats not very useful
09:12:41 <benzrf> exio4: wait, by that do you mean
09:12:48 <benzrf> do you want to indicate that the result is a subset of the input
09:12:53 <benzrf> or that the function is not surjective
09:12:58 <DanC__> aha... cabal repl
09:13:00 <exio4> the first
09:13:11 <exio4> the result is a subset of the input
09:15:09 <exio4> thought that wouldn't be possible, that feels to be in dependant types field :P
09:15:28 <benzrf> indeed
09:16:31 <exio4> i guess it is time for checking Adga and Idris!
09:16:39 <vanila> A newtype is a really nice way to do this
09:16:56 <vanila> it doesn't enforce that the list is sorted but it indicates it
09:39:46 <qwebirc46290> can anyone help me with some generics code: here is the paste http://lpaste.net/110609
09:40:42 <qwebirc46290> the code is for deserialising xml given a target data structure
09:46:05 <mauke_> qwebirc46290: I understand the error
09:46:30 <qwebirc46290> awesome
09:46:36 <qwebirc46290> what i am doing wrong
09:49:33 <mauke_> well, you're trying to call the 'Rep a' instance method of gdeser
09:49:34 <int-e> qwebirc46290: as written, the default method has type  deser :: Cursor -> [Text] -> Rep a x -> a
09:50:13 <mauke_> that means gdeser :: Cursor -> [Text] -> Rep a x -> Rep a x  (because f = Rep a)
09:50:47 <mauke_> but you're calling it with the 'a' from deser, which is unconstrained
09:51:10 <nitrix> Hi guys, this will seem surprising but I've been arguying for a while with someone about whether or not C has closures.
09:51:11 <mauke_> so the compiler complains that it can't prove a ~ Rep a x
09:51:34 <qwebirc46290> ok that makes sense. is there a solution to this?
09:51:53 <nitrix> While this isn't related to haskell, I thought someone could just give me a thumbs up or thumbs down. My position (from what I learned by doing haskell), C doesn't have those.
09:51:54 <int-e> qwebirc46290: I don't understand the type, but you may be missing a 'from' in there
09:52:07 <exio4> nitrix: C has everything, you just have to code it!
09:52:19 <eacameron> I know the runtime will start up new OS threads as needed, but does it also stop threads as they are no longer needed?
09:52:22 <nitrix> That's hardly helpful :P
09:52:24 <mauke_> nitrix: C doesn't even have nested functions
09:52:28 <mauke_> nitrix: so yes: no
09:52:42 <monochrom> nitrix, you need a mathematical definition of "has" first. I am serious.
09:53:14 <monochrom> for example some people define "has = builtin", some other define "has = can be implemented". they will never reach consensus.
09:53:22 <int-e> qwebirc46290: oh, are those phantom arguments? deser c xs a = to (gdeser c xs undefined)  might just be what you need
09:53:41 <int-e> qwebirc46290: anyway, you should know
09:53:50 <monochrom> @quote monochrom debates
09:53:51 <lambdabot> monochrom says: All pointless debates can be settled by going polymorphic.
09:53:52 <mauke_> monochrom: the latter definition is less useful because then any language "has" closures
09:54:25 <monochrom> oh, that is only the tip of the iceberg.
09:54:30 <int-e> @quote meta
09:54:31 <lambdabot> ghc says: Exotic Stmt in meta brackets
09:55:07 <monochrom> some people define "has = present in the library". now you get infinitely many definitions based on which library you include.
09:55:14 <nitrix> monochrom: mauke_: I'm not talking about emulating them, but literally built-in. My understanding, simplified, closures would be a function that can be stored as a variable, a first-class function, with the ability to access other variables local to the scope it was created in.
09:55:19 <qwebirc46290> let me try that out.
09:55:44 <nitrix> And we're arguying because technically all functions are declared in the file-scope in our case, so they'd be sort of closures.
09:55:49 <mauke_> nitrix: I wouldn't require the first part
09:55:58 <eacameron> nitrix: Perhaps realizing that C++ only now JUST got closures in C++11 might be a helpful point in the argument
09:56:16 <nitrix> eacameron: Please do not confuse C++ and C, it's embarassing.
09:56:18 <mauke_> nitrix: my definition is: a closure is a function that accesses variables from its surrounding local scope
09:56:33 <mauke_> nitrix: keyword: local scope
09:56:40 <nitrix> mauke_: Sure, let's call that an environment.
09:56:42 <monochrom> I wouldn't participate in the argument. there are more fun ways to spend spare time.
09:57:05 <mauke_> ooh
09:57:12 <sipa> nitrix: did he confuse them?
09:57:25 <mauke_> you *could* argue that file scope variables with internal linkage are "local" in that sense
09:57:26 <nitrix> mauke_: My understanding is one function's environment, which has local variables and others, aren't carried over from the caller to the callee.
09:57:27 <eacameron> nitrix: C is a strict subset of the C++'s features, that's the point
09:57:40 <int-e> monochrom: no there aren't. ( https://www.youtube.com/watch?v=kQFKtI6gn9Y )
09:57:49 <mauke_> nitrix: callers are irrelevant as they don't surround
09:57:54 <nitrix> But then, the file-scope they have in common gets in the way.
09:58:13 <mauke_> nitrix: ok, you're both right
09:58:19 <monochrom> haha
09:58:32 <qwebirc46290> int-e: thanks so much that was the answer: just had to add ~ to handle undefined later on and it worked
09:58:39 <nitrix> mauke_: If the functions weren't in the same file-scope, they wouldn't be closures?
09:58:53 <mauke_> huh?
09:59:05 <int-e> qwebirc46290: so why don't you return  a  instead of  a -> a ?
10:00:32 <mauke_> module-1.c: static int x; void f(void) { return x++; }
10:00:48 <mauke_> module-2.c: #include "module-1.h" ... printf("%d\n", f());
10:01:06 <qwebirc46290> i am deserialising xml so i thought i needed to pass in the first 'a' to give it an initial structure
10:01:32 <qwebirc46290> are you saying i can leverage the return type somehow?
10:02:14 <int-e> qwebirc46290: that's what I would expect, but I may be wrong
10:02:34 <int-e> qwebirc46290: but if I'm wrong then sticking "undefined" in there will also be wrong, I think.
10:02:47 <qwebirc46290> i think you are right, i will give that a try
10:10:04 <qwebirc46290> int-e : you were absolutely correct. i ditched the extra 'a' and all is good. thanks so much for your help.
10:14:42 <Sgeo> Is it possible to write a Traversable instance whose traverse breaks some kind of laws? If not, then I'm quite confused how I wrote a function to convert from my encoding (which I strongly believe allows breaking some kind of laws) to a traverse function
10:14:46 <hiptobecubic> What's the consensus on the "monads are containers" analogy? We have this (http://www.haskell.org/haskellwiki/Monads_as_containers) but even it says that the analogy is "odd" and not as natural as 'monads as computation'
10:15:29 <coppro> Sgeo: It is. Haskell does not check laws for you
10:15:57 <Sgeo> hiptobecubic: there are monads that are not containers at all. Simplest I can think of is reader monad
10:16:21 <hiptobecubic> Sgeo, it gives an example of how Reader can be a container.
10:16:25 <coppro> monads as containers is useful for introducing them. it's not useful for explaining Data.List
10:16:41 <hiptobecubic> Sgeo, I would think more like (Parser a) is a tough one to defend
10:16:56 <coppro> you can do it, but it becomes more complex and that point and the advantage to the analogy is gone
10:17:02 <hiptobecubic> coppro, what's special about Data.List?
10:17:10 <coppro> hiptobecubic: The fact that it can "contain" multiple values
10:17:35 <hiptobecubic> coppro, does Data.List differ from normal lists somehow?
10:17:41 <mauke_> coppro: so it's a magic container
10:17:43 <mauke_> big deal
10:17:44 <coppro> hiptobecubic: no, it is normal lists
10:17:49 <hiptobecubic> most people would expect lists and contains to contain multiple things sometimes
10:17:52 <Sgeo> Are there any monad tutorials that explain monads from the point of view of operational?
10:17:57 <hiptobecubic> containers* rather
10:17:59 <monochrom> hiptobecubic, some monads feel like containers, some don't.
10:18:13 <coppro> hiptobecubic: The semantics of List as a monad are very unintuitive to someone approaching from a programming perspective.
10:18:26 <Sgeo> I find myself thinking of monads as having some set of primitive commands, commands which can take a continuation
10:18:33 <coppro> in my experience, this is what defeats most simple analogies of what monads are
10:18:35 <Sgeo> I blame do notation
10:19:10 <coppro> Sgeo: that's roughtly how the IO monad actually works
10:19:12 <monochrom> if you have to argue, you no longer have an analogy, you have a homomorphism.
10:19:22 <mauke_> "no, you don't"
10:20:17 <Sgeo> IO monad commands don't do anything more interesting with the continuation than call it when executed
10:20:19 <Sgeo> :(
10:20:40 <Sgeo> I don't want to write ContT r IO a in order to have fun with continuations in the IO monad
10:21:08 <monochrom> exception throwing and catching do something interesting with the continuation
10:21:36 <vanila> Sgeo: I think ContT already exists
10:21:50 <Sgeo> I know, but I don't want to have to use it
10:21:57 <vanila> why not?
10:22:37 <mauke_> fork :: IO (Maybe ThreadId)
10:24:26 <pussy> —Ä—É–≥ –µ—Ç–æ —Ç–æ–∑–∏ http://www.namerimi.org
10:24:27 <pussy> —Ä—É–≥ –µ—Ç–æ —Ç–æ–∑–∏ http://www.namerimi.org
10:24:28 <pussy> —Ä—É–≥ –µ—Ç–æ —Ç–æ–∑–∏ http://www.namerimi.org
10:24:28 <pussy> —Ä—É–≥ –µ—Ç–æ —Ç–æ–∑–∏ http://www.namerimi.org
10:27:31 <Sgeo> If spam is off topic, then does this mean discussing the funny spam emails I sometimes get is not allowed?
10:28:13 <monochrom> it is soft-disallowed. you can do it a little bit and nothing bad really happens.
10:31:05 <lpvb> ... is that a mail order bribe website
10:31:16 <lpvb> bride*
10:52:30 <hiptobecubic> lpvb, it's ".org" so it's legit
10:54:30 <HairyDude> I've been looking at grapefruit for UI programming but it seems to be unmaintained... the trac and mailing list are full of spam
10:55:52 <HairyDude> also, the documentation is pretty terrible. I can't make head or tail of the record system
10:57:56 <oisin817> I want to write a game engine where a World (data type) contains a collection of entities. However, I would like future users to be able to implement their own entities - so I would think I should make something like: Entity e => [e]. But will this collection be heterogenous?
10:58:14 <sipa> no
10:58:32 <sipa> you need existential types if you want it to be heterogeneous
11:00:09 <srhb> And you (probably) don't want that. :)
11:00:57 <oisin817> Oh, damn, I just started to put it in - why might I not want that?
11:01:04 <oisin817> sipa: Also, thank yu
11:01:06 <oisin817> you
11:02:56 <sipa> oisin817: say you want a heterogenous array of printable things
11:03:05 <trap_exit> does emacs have a notion of with-current-directory? i.e. something like: execute the following function with the current directory set to blah ... then, if the function returns, or if it throws an exception, change back to original directory
11:03:22 <trap_exit> wrong channgel, sorry
11:03:30 <trap_exit> though in my defense, this arises from compiling haskell code :-)
11:03:40 <monochrom> oh, printable things, I have a quote on that :)
11:03:45 <monochrom> @quote monochrom river
11:03:45 <lambdabot> monochrom says: You are to send a boolean, a character, and an integer across the river. The list for transporting across the river can hold 3 items, in fact any number of items you like, but they must all be of the same type. On the bright side, after crossing the river, the boolean, the character, and the integer need only be put on show. How
11:03:45 <lambdabot> many trips do you need? Solution: one trip, [show the_boolean, show the_character, show the_integer]
11:04:01 <sipa> monochrom: right, i didn't know whose quote it was :)
11:04:51 <simpson> oisin817: My solution to this was to allow people to define their own World state, and compose it with the game engine's state using a tuple and lenses.
11:04:53 <oisin817> That makes sense - but how do I store the collection before I 'fmap show'. Since it's not a one off trip, more like people come and go
11:05:02 <monochrom> but more generally, I would specify entities before consider how to code.
11:05:12 <oisin817> simpson: Do you have a piece of code I can take a look at?
11:06:12 <simpson> oisin817: Warning: This is incredibly hacky because I got distracted by gainful employment.
11:06:13 <simpson> https://github.com/MostAwesomeDude/gemstone/blob/master/Gemstone/Loop.hs#L28
11:06:42 <oisin817> simpson: Unacceptable excuse, but thanks :)
11:07:05 <simpson> oisin817: My employer does not approve of unsupervised contributions to open-source projects. :c
11:07:23 <oisin817> simpson: Oh, wow, even after hours?
11:08:08 <simpson> Anyway, one would write code in Loop, treating the monadic state as game state, and then pass one's scenes and triggers and actions to gemstoneLoop.
11:08:11 <simpson> oisin817: Yeah. :c
11:08:24 <tk``> hey all.. I'm having some trouble getting a simple test-suite setup with yesod.  My tests don't compile, the error being that the yesod routes aren't in scope.  Any one have any idea what the problem could be?
11:08:46 <tk``> i've compared my setup to a bunch of others and can't figure out the difference
11:11:00 <oisin817> simpson: Thanks!
11:11:23 <simpson> oisin817: So this is just my approach. I dunno if it's the right approach, but it avoids the existential type pattern.
11:11:27 <nitrix> https://hackage.haskell.org/package/sdl2-1.1.0/docs/Graphics-UI-SDL-Enum.html
11:11:51 <nitrix> How does one combine the `Initialization Flag` ?
11:12:10 <nitrix> In C, these are bit masks and a simple | suffices.
11:12:27 <nitrix> In my case, SDL2's init has the type :: Word32 -> IO CInt
11:13:04 <nitrix> Where Word32 is an instance of a Num Word32, so   `initFlagEverything :: Num a => a`   would work just fine
11:13:15 <nitrix> But what if I want to only have timers and audio for example?
11:14:30 <mauke_> nitrix: .|.
11:14:48 <nitrix> That's an operator?
11:15:00 <monochrom> nitrix, IMO you're looking at a poor design decision based on a flawed reason, and you may be buying that flawed reason too.
11:15:06 <mauke_> :t (Data.Bits..|.)
11:15:07 <lambdabot> Bits a => a -> a -> a
11:15:46 <nitrix> monochrom: Is there a better SDL2 library for haskell?
11:17:48 <monochrom> I don't know. I just like to talk about design decisions.
11:20:36 <monochrom> Word32 is an instance of Bits. This allows flag mask operators.
11:21:03 <nitrix> Perfect :)
11:21:25 <jle`> > 2 Data.Bits..|. 4
11:21:27 <lambdabot>  6
11:21:47 <jle`> > 2 Data.Bits..&. 6
11:21:49 <lambdabot>  2
11:22:14 <monochrom> In the first place, I don't see what polymorphism buys us for flags. The more you say "it does not matter", the more you do *not* need polymorphism.
11:23:05 <meretrix> I want to use Binary to encode events and append them to a file, but what do I use as a separator between encoded events?
11:23:10 <meretrix> Is it safe to just use a newline?
11:23:34 <meretrix> I assume their is no way to append to a Binary list..
11:23:44 <monochrom> But out of giving way to stubborn people, let's say I finally agree to polymorphism. Then which type class is right is still an important question.
11:24:21 <mauke_> meretrix: I'd probably just use a length prefix
11:24:24 <mauke_> or a separate index file
11:24:54 <monochrom> Num is obviously a wrong choice for flags. Num does not support flag mask operations.
11:25:35 <monochrom> Either Bits or a custom-made type class that does some Bits stuff is the right choice.
11:25:39 <meretrix> mauke_: I guess that could work. But would it work with Binary's decode?
11:26:05 <mauke_> meretrix: ... no?
11:26:27 <mauke_> we're stacking encodings here
11:27:02 <mauke_> first you undo your own stuff to get back a blob or three
11:27:06 <mauke_> then you pass those to decode
11:27:41 <meretrix> Ah ok.
11:29:52 <Guest36025> today I presented Maybe type in Haskell Meetup in Pune, India
11:30:17 <monochrom> does the audience like it?
11:30:41 <monochrom> how far is Pune from New Delhi?
11:31:09 <Guest36025> yeah, they kinda bought compared to null
11:31:10 <Guest36025> its like 3 hrs journey flight
11:31:54 <monochrom> is Pune close to Mumbai? perhaps Mumbai is the better reference point when it comes to programmers.
11:32:15 <Guest36025> yes, its near to Mumbai, 150 kms
11:32:50 <Guest36025> when I tried to put a point that how Maybe being a monad helps us
11:33:16 <Guest36025> many of them didn seem to convinced
11:33:46 <Guest36025> and very basic question came, why would we use monad, if things are possible with Applicative
11:34:08 <monochrom> oh, do use Applicative when it suffices :)
11:35:37 <Guest36025> IMH, I couldnt actually answer that question precisely, but what I told them whenever u think that it will look better in Do notation then ypu should go for monda
11:35:52 <monochrom> Maybe is also an instacne of MonadPlus and Alternative. they are also very useful.
11:35:59 <sbrg> anyone here running xmonad and also having trouble with installing ghc-mtl?
11:36:23 <jle`> aw, got a stack overflow on 7.8
11:36:26 <jle`> im sad
11:36:56 <Guest36025> okay, tsoemone here answered same thing to me when I first time asked about monads
11:37:39 <simpson> The main motivation for Monad instances is to be able to examine the current state of computation, which can't be done with Applicative.
11:39:36 <jle`> monad allows you to choose what to do next depending on the result "inside" the Just (if it exists), whereas applicative can't.  often times with Maybe, applicative is enough; i use Appliccative for Maybe all the time without Monad
11:39:36 <Guest36025> simpson: okay, is that the most important motivation?
11:40:17 <jle`> in fact i use the Applicative instance far more times than i use the Monad instance, I think
11:40:31 <simpson> Guest36025: IMO yes. The invention of Applicative took away the requirement to use Monads and do-notation for lots of simple tasks.
11:41:27 <Guest36025> okay also one of the very old proffesor - one of the early contributors of miranda was present
11:41:50 <jle`> there are some who believe that (a limited subset of) do notation might be a nice way to express applicative combinators and computations as well.  they're working on it at Facebook I believe
11:41:51 <Guest36025> she was suggesting that, you should probably avoid Do notation
11:41:59 <jle`> i think they're the only ones really interested
11:42:50 <Guest36025> because he she thinks that, Do looks very imperative
11:43:02 <jle`> there's that "do notation considered harmful" post, but...i think that do notation has its place and reason for existing
11:43:30 <jle`> expressing the same computation using binds and lambdas can get pretty ugly
11:43:37 <mauke_> I think you should avoid >>= because it looks a lot like right shift assignment
11:43:49 <jle`> is she really arguing against do notation, or against imperative algorithms?
11:44:48 <Guest36025> she is arguing about do notation itself, because she thinks that it looks so imperative, and you could do thinks with bind
11:45:09 <jle`> there are many things that you can do easily in do notation that are a complete mess using explicit binds :/
11:45:14 <Guest36025> she is also against classes
11:45:39 <sivteck> ;[
11:45:43 * nyuszika7h thinks <- looks better than >>=
11:45:49 <simpson> That's fine. Many people are of many different opinions.
11:46:03 <Guest36025> > let f x = if x then 3 else Nothing
11:46:03 <merijn> I think you should avoid do-notation until you understand how to write the code using >>=
11:46:04 <lambdabot>  not an expression: ‚Äòlet f x = if x then 3 else Nothing‚Äô
11:46:19 <Guest36025> it compiles
11:46:20 <merijn> Then, when you understand that, just use do-notation
11:46:21 <jle`> i guess that is true
11:46:23 <taktoa> > let f x = if x then Just 3 else Nothing
11:46:25 <lambdabot>  not an expression: ‚Äòlet f x = if x then Just 3 else Nothing‚Äô
11:46:43 <merijn> Guest36025: That's because GHC can't prove that there's no "Maybe a" instance for Num
11:46:46 <jle`> do notation has imo a narrow scope of utility, but where it is useful, it is definitely useful
11:46:57 <simpson> > let f x = if x then Just 3 else Nothing in f True
11:46:57 <merijn> :t let f x = if x then 3 else Nothing
11:46:58 <lambdabot> <no location info>:
11:46:59 <lambdabot>     not an expression: ‚Äòlet f x = if x then 3 else Nothing‚Äô
11:46:59 <lambdabot>  Just 3
11:47:01 <merijn> :t let f x = if x then 3 else Nothing in f
11:47:02 <lambdabot> Num a => Bool -> Maybe a
11:47:03 <cin> the main problem with professors is that they have students =)
11:47:18 <merijn> > let f x = if x then 3 else Nothing in f False
11:47:20 <lambdabot>  Nothing
11:47:23 <merijn> > let f x = if x then 3 else Nothing in f True
11:47:25 <lambdabot>  Just 3
11:47:28 <merijn> oh
11:47:29 <merijn> hah
11:47:32 <merijn> I forgot
11:47:32 <jle`> i made one last night
11:47:36 <jle`> it probably hasn't been undefined yet
11:47:37 <nyuszika7h> it implicitly adds Just? :O
11:47:40 <merijn> We defined that last night :p
11:47:40 <Guest36025> merijn: yeah, so her opinion was that compiler is trying to infer some weird type Num (Maybe a)
11:47:42 <monochrom> I agree that do-notation looks imperative. I disagree that there is anything wrong with looking imperative.
11:47:47 <jle`> > 3 <*> 6
11:47:49 <lambdabot>  Unsafe overlapping instances for GHC.Num.Num (f (a0 -> b))
11:47:49 <lambdabot>    arising from the ambiguity check for ‚Äòe_136‚Äô
11:47:49 <lambdabot>  The matching instance is:
11:47:49 <lambdabot>    instance [safe] (Control.Applicative.Applicative f,
11:47:49 <lambdabot>                     GHC.Num.Num a) =>
11:47:53 <jle`> oops
11:47:54 <merijn> nyuszika7h: No, last night we defined "Num a => Num (Maybe a)" :d
11:47:57 <nyuszika7h> lol
11:47:57 <merijn> @undefine
11:47:57 <lambdabot> Undefined.
11:48:00 <Guest36025> that dont even exist
11:48:01 <jle`> noooo ;_;
11:48:02 <merijn> > let f x = if x then 3 else Nothing in f True
11:48:03 <lambdabot>  No instance for (GHC.Show.Show a0)
11:48:04 <lambdabot>    arising from a use of ‚ÄòM360239403830323884421307.show_M3602394038303238844...
11:48:04 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
11:48:04 <lambdabot>  Note: there are several potential instances:
11:48:04 <lambdabot>    instance [safe] GHC.Show.Show
11:48:07 <jle`> Guest36025: it can exist, if you define it :P
11:48:08 <merijn> > let f x = if x then 3 else Nothing in f False
11:48:09 <lambdabot>  No instance for (GHC.Show.Show a0)
11:48:09 <lambdabot>    arising from a use of ‚ÄòM48962438387295257021319.show_M48962438387295257021...
11:48:09 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
11:48:11 <lambdabot>  Note: there are several potential instances:
11:48:13 <lambdabot>    instance [safe] GHC.Show.Show
11:48:28 <cin> do notation doesn't look imperative if you compare it to list comprehensions
11:49:03 <monochrom> oh, sometimes I read list comprehensions imperatively, too :)
11:49:46 <cin> like set builder notation and Œ£
11:50:03 <Guest36025> jle`: In our case another branch in evaluation to Int so Num (maybe Int) is not present
11:50:26 <jle`> i'm not sure i understand
11:50:31 <Guest36025> so ideally compiler should shout at it
11:50:46 <jle`> it would shout if you ever use it as a (Maybe Int)
11:50:50 <HairyDude> Hmm, the packages grapefruit-records and records seem to be the same thing, except the former is more recently updated and the latter has better documentation
11:50:57 <jle`> but if you never use it as anything, it leaves it as Num a => (Maybe a)
11:51:07 <jle`> because there might be some Maybe a for which Maybe a is a Num
11:51:08 <mauke_> Guest36025: the type of 3 is not Int
11:51:29 <Guest36025> @type let f x = if x then 3 else Nothing in f True
11:51:30 <lambdabot> Num (Maybe a) => Maybe a
11:51:31 <rondo> Hi all, is there a more idiomatic way to operate on nested monads than simply using nested fmaps? For instance, I have an IO (Maybe Int), and to add 1 to that Int id do something like "fmap (fmap (+1))". Is there a better way?
11:51:46 <jle`> rondo: do you mean nested functor?
11:51:52 <rondo> yes
11:52:00 <jle`> you can do (fmap . fmap)
11:52:02 <HairyDude> > let f x = if x then Just 3 else Nothing in f True
11:52:04 <lambdabot>  Just 3
11:52:04 <jle`> i think some people define double fmaps
11:52:10 <rondo> ok
11:52:14 <rondo> so make an fmap2
11:52:23 <jle`> some people do it, but i think (fmap . fmap) is fune
11:52:25 <jle`> fine
11:52:25 <Guest36025> as merijn pointed out if we do stuff like
11:52:33 <jle`> also, you should be able to take advantage of the Functor laws
11:52:37 <rondo> i thought of that, I was just wondering whether there was something in the standard library that dealt with this
11:52:39 <rondo> thanks
11:52:43 <Guest36025> > let f x = if x then 3 else Nothing :: Maybe Int
11:52:44 <jle`> to refactor and distribute your fmaps, if you are composing them
11:52:44 <lambdabot>  not an expression: ‚Äòlet f x = if x then 3 else Nothing :: Maybe Int‚Äô
11:52:55 <jle`> Guest36025: that's because there really isn't a Maybe Int
11:52:56 <cin> heaven for bid someone reads fmap (fmap (+1)) and understands that clean, simple code
11:53:05 <HairyDude> there's no instance Num (Maybe Int)
11:53:18 <jle`> there's no Num (Maybe Int).  the compiler can definitely check that
11:53:38 <monochrom> I understand fmap (fmap (+1)), especially if you also tell me the concrete types you use
11:54:34 <monochrom> I wrote a couple of "fmap (fmap f)" when learning free monads.
11:54:47 <Guest36025> yeah, her concern was rather inferring Num (Maybe a) (which compiler cant proove to be non existent), it could be great if ghc infers Num (Maybe Int) which compiler can proove non existent
11:54:49 <Guest36025> :)
11:54:59 <rondo> so are saying that "fmap (fmap (+1))" is right by you?
11:55:02 <Guest36025> I am not sure I could convey the thinf
11:55:07 <monochrom> yes
11:55:08 <jle`> Guest36025: GHC usually can
11:55:15 <jle`> if you use the function later on
11:55:28 <jle`> which is really the only time that it would be a problem in the first place :)
11:56:00 <Guest36025> :) yeah that's where type annotations play their role
11:56:09 <jle`> it's only when you define the function and never use it ever that it leaves it as Num a => (Maybe a)
11:56:13 <jle`> Guest36025: you don't even need type annotations
11:56:19 <rondo> monochrom: okay, I thought it looked a bit messy, but either way its not a big deal
11:56:30 <jle`> if later on you use something that can be inferred to be an Int, it'll complain
11:57:00 <Guest36025> jle`: oh!, but if its at first place type annotation would help
11:57:01 <jle`> > let f x | x = 3 | otherwise = Nothing in length [1,2,3] + f False
11:57:02 <lambdabot>  Couldn't match expected type ‚ÄòGHC.Types.Int‚Äô
11:57:02 <lambdabot>              with actual type ‚ÄòData.Maybe.Maybe a1‚Äô
11:57:25 <Guest36025> jle`: hmm that make more sense :-)
11:57:35 <jle`> yeah, type annotation would help too :)  and if it's top level, it's recommended.  but it's definitely not necessary, for catching errors :)
11:58:13 <jle`> > let f x = if x then 3 else Nothing in Just (length [1,2,3]) <|> f False
11:58:15 <lambdabot>  No instance for (GHC.Num.Num (Data.Maybe.Maybe GHC.Types.Int))
11:58:15 <lambdabot>    arising from a use of ‚Äòf‚Äô
11:58:35 <jle`> in that case it infers that f should be Maybe Int, so...there you go
12:00:56 <edlinde> Whats an ‚ÄúAlgebraic data type"?
12:01:08 <edlinde> is it a synonym for a recursive data type?
12:01:16 <mauke_> what 'data' lets you define
12:01:38 <jle`> edlinde: are you familar with data type declarations in haskell?
12:01:45 <edlinde> yep
12:01:53 <edlinde> (I think so) :)
12:02:30 <jle`> data Foo a b = Bar | Baz b | Biz a Int ... roughly
12:02:31 <kuyatzu> edlinde: http://www.haskell.org/haskellwiki/Algebraic_data_type
12:02:41 <edlinde> mauke_: so any type is an algebraic data type?
12:03:00 <mauke_> edlinde: I'm pretty sure (->) isn't
12:03:14 <Guest36025> sort :: Ord a ‚áí [a] ‚Üí [a]
12:03:15 <Guest36025> Idris (my example, > 150 LOC):
12:03:15 <edlinde> ah thanks kuyatzu
12:03:16 <Guest36025> 1 quickSort : {a : Type} ‚Üí {less : a ‚Üí a ‚Üí Type}
12:03:18 <Guest36025> 2 ‚Üí {eq : a ‚Üí a ‚Üí Type}
12:03:20 <Guest36025> 3 ‚Üí TotalOrder less eq
12:03:22 <Guest36025> 4 ‚Üí (xs : List a)
12:03:24 <Guest36025> 5 ‚Üí Exists (List a) (\ys ‚áí (IsSorted less ys, Permutation xs ys))
12:03:31 <jle`> data made out of sums (Foo | Bar | Baz)  and products (Bar a Int Bool)
12:03:40 <edlinde> ah I get it now
12:03:49 <edlinde> where we specify the ‚Äúshape‚Äù
12:03:52 <edlinde> I get that
12:03:54 <Guest36025> anybody can explain Idris type definition ?
12:04:04 <edlinde> I saw this term used in the context of a binary search tree and a list
12:04:08 <edlinde> so it makes sense
12:04:12 <edlinde> thanks guys!
12:04:20 <jle`> np
12:04:36 <jle`> it's rather unfortunate that the acronym ADT coincides with another commonly used one in computer science
12:05:06 <benmachine> algebraic datatypes can be abstract or not, and abstract datatypes can be algebraic or not :(
12:06:32 <jle`> AlDT vs AbDT
12:07:06 <jle`> maybe i'll just go around caling them SumProds, nobody will know the difference
12:07:23 <monochrom> I write "algebraic data type" in full
12:07:28 <sm> "nice structs"
12:07:43 <benmachine> hmm
12:07:45 <mauke_> I just call them enumuionstructs
12:07:49 <monochrom> note that "algebraic DT" will not work because now you're looking at "DT = dependent type"
12:07:58 <benmachine> maybe Haskell data types should actually be coalegbraic datatypes
12:07:59 <jle`> haha
12:08:04 <benmachine> *should actually be called
12:08:05 <exio4> the correct definition is: awesome datatypes!
12:08:07 <mauke_> olegbraic
12:08:46 <benmachine> ML datatypes are algebraic, but Haskell ones are coalgebraic, perhaps
12:08:51 <benmachine> the difference is... minor, anyway
12:09:06 <monochrom> Haskell ones are both.
12:09:35 <monochrom> my understanding anyway
12:10:51 <darveter> google says "No results found for coalegbraic datatypes"
12:11:07 <benmachine> darveter: yeah I'm not sure if anyone actually calls them that :P
12:11:17 <darveter> what _are_ they?
12:11:24 <benmachine> er
12:11:28 <benmachine> well.
12:11:29 <darveter> i.e. what does that mean?
12:11:40 <mauke_> darveter: try "coalgebraic"
12:11:53 <darveter> i'm no mathematician but I think I understand corecursion.
12:12:17 <benmachine> also "codata" which is pretty much what I mean
12:12:29 <monochrom> are you sure you made no typo?
12:12:30 <darveter> aha, then. :)
12:12:42 <jle`> what are swift data types then
12:13:00 <mauke_> codata has cod in it; coalgebraic types have coal in them
12:13:00 <benmachine> darveter: but what I mean is that data types in Haskell arise from terminal coalgebras rather than from initial algebras
12:13:27 <monochrom> coalgebraic emphasizes accessors and destructors. algebraic emphasizes constructors.
12:13:44 <benmachine> darveter: so if in "algebraic data type" you think of algebraic as referring to the initial-algebra stuff, then Haskell datatypes might make more sense as coalgebraic
12:13:47 <monochrom> there is more, but let's say I can only say so much on the surface.
12:14:00 <darveter> benmachine: well, I only vaguely understand about terminal as related to corecursion...
12:14:10 <benmachine> darveter: me too :P
12:14:25 <benmachine> I put a talk about this on youtube but you can't really hear what I'm saying :(
12:14:28 <darveter> benmachine: because constructors are lay by default?
12:14:34 <benmachine> darveter: basically, yes
12:14:34 <jle`> there's the CT concept of terminal
12:14:50 <darveter> edit: lay
12:14:55 <darveter> edit: lazy
12:15:06 <benmachine> darveter: because in e.g. data N = Z | S N, you have the element 'fix S'
12:15:27 <benmachine> an element satisfying x = S x
12:15:37 <darveter> so, because Haskell datatypes are recursive?
12:16:03 <benmachine> er, not exactly
12:16:19 <benmachine> because ML datatypes can be recursive too
12:16:25 <monochrom> initial algebras are recursive too
12:16:30 <darveter> wait, what element in N would satisfy x = S x?
12:16:39 <mauke_> x
12:16:42 <benmachine> :P
12:16:52 <benmachine> darveter: S (S (S (S ...
12:17:05 <mauke_> you can literally define x = S x
12:17:06 <monochrom> let x = S x in x. this is non-degenerate in Haskell. this is degenerate in ML
12:17:25 <mauke_> degenerate how?
12:17:31 <darveter> benmachine: and it is really considered to be an element in N, in Haskell? you mean as undefined?
12:17:33 <benmachine> it fails to define a value
12:17:39 <mauke_> works in ocaml
12:17:46 <monochrom> sorry, SML.
12:17:49 <benmachine> mauke_: yes but that's because ocaml is plain weird :P
12:17:52 <darveter> monochrom: aha!
12:17:55 <benmachine> darveter: it is not undefined
12:18:20 <benmachine> darveter: it is really an element of the datatype N as I defined it
12:18:37 <darveter> benmachine: yes, right.
12:18:45 <monochrom> sorry, I take that back. I can stand by my statement about ML. Clearly, ML does not refer to OCaml.
12:18:54 <mauke_> let rec a = 0 :: b and b = 0 :: a in a = b;; (* IIRC this forms an infinite loop *)
12:19:18 <benmachine> mauke_: indeed it does, but so does the equivalent in Haskell
12:19:30 <monochrom> ML refers to, like that language, called ML, used for implementing HOL88, implemented by Allegro Lisp.
12:19:47 <coppro> ML refers to the Modern Languages building
12:19:54 <mauke_> benmachine: yeah, but a = a terminates :-)
12:19:55 <benmachine> mauke_: I think that allowing cyclic datatypes in OCaml is roughly speaking a compromise in favour of usefulness and against theoretical consistency
12:20:06 <benmachine> mauke_: ...are you sure?
12:20:14 <mauke_> yes
12:20:20 * benmachine checks for himself
12:20:40 <benmachine> doesn't work for me
12:20:57 <mauke_> maybe they changed it?
12:21:05 <darveter> so, because of laziness, I can define let x = S x, and this means Haskell's datatypes are coalgebraic. did I get this right?
12:21:08 <benmachine> a == a is true
12:21:11 <benmachine> but that's another matter :P
12:21:17 <mauke_> it loops in Haskell because == is a library function that recurses along the list spine
12:21:29 <mauke_> ocaml's = is weirder because it's built into the language
12:21:40 <benmachine> darveter: well, it is a consequence of the fact that Haskell's datatypes are based on coalgebras
12:21:48 <mauke_> it first checks identity (pointer equality), then goes for structural equality
12:22:05 <benmachine> mauke_: in ocaml I don't think = checks pointer equality first
12:22:13 <benmachine> but it is still weird and primitive and builtin
12:22:23 <darveter> benmachine: and such "x" is terminal data element?
12:22:27 <merijn> = does check pointer equality
12:22:37 <merijn> == is the value equality
12:22:57 <benmachine> merijn: no, that's /definitely/ backwards. == is physical equality
12:23:09 <merijn> Similarly, every year tens of students screw up their ocaml assignment because (despite our warnings...) they use != instead of <> for comparison
12:23:23 <monochrom> what does != do?
12:23:27 <mauke_> merijn: no wonder they screw up if you teach it backwards
12:23:31 <benmachine> darveter: that's an odd use of the word "terminal" that I don't recognise
12:23:49 <merijn> benmachine: oh, my bad
12:24:02 <merijn> mauke_: No, I got the inequality one right :)
12:24:07 <darveter> I'm just trying t understand what that means, "coalgebraic".
12:24:12 <benmachine> yeah != is physical inequality ._.
12:24:12 <merijn> monochrom: pointer inequality, rather than value
12:24:32 <benmachine> darveter: it's all to do with how you model this stuff in category theory
12:25:12 <darveter> k, thanks!
12:25:27 <darveter> benmachine: ok, thanks!
12:25:37 <benmachine> darveter: I can provide a more complete explanation but it's kind of long
12:25:46 <monochrom> to comfort you, the phenomenon of students not reading completely is the same one of IRCers not reading completely.
12:26:23 <monochrom> very few people, such as you and me, actually read.
12:26:27 <darveter> benmachine: I'm not sure I'd understand. if you have a pointer to somewhere...
12:26:52 <darveter> enmachine: right away I mean...
12:26:58 <benmachine> monochrom: that strikes me as an unhumble attitude
12:27:25 <merijn> monochrom: This is not even reading, after being covered during the lectures, the *first* thing I say and write on the board during labs is DON'T use these, use these guys
12:27:46 <merijn> monochrom: So, that means gleefully docking points for messing up
12:28:02 <benmachine> merijn: I use a standard library that shadows them with values of the type [ `Look_don't_do_that_okay ] or words to that effect :)
12:28:16 <vanila> benmachine++
12:29:06 <benmachine> darveter: basically I don't know where you'd want to start, are you already excited about category theory?
12:29:49 <darveter> benmachine: feeling apprehensive, more like it. I know I _should_ read that wkibook...
12:29:59 <mauke_> benmachine: ok, this is weird
12:30:14 <mauke_> I know I tried the a = a thing years ago and it worked as I described it
12:30:26 <mauke_> but I can't find any documentation on it
12:30:33 <benmachine> mauke_: I find it believable that it might have worked that way once
12:30:43 <benmachine> or in a different implementation, or something
12:31:13 <benmachine> darveter: there's no should about it :P read it if you want to, learn it if you want to
12:31:20 <darveter> benmachine: but I think I get the jist of "terminal" vs "initial" as having infinity allowed as part of data type, i.e. related to corecursion, i.e. to lazyness.
12:31:34 <mauke_> this was probably back in 2005 or something?
12:31:51 <benmachine> darveter: the concepts are very related, but it's not the elements themselves that are terminal or initial, or even the types
12:31:51 <spopejoy> I just figured out how to support Œª> prompts in emacs
12:32:43 <benmachine> darveter: roughly speaking an algebra for a functor F is an object A and a morphism FA -> A
12:33:01 <darveter> benmachine: ok, thanks, will put it on hold for now... :)
12:33:10 <benmachine> darveter: the algebras for a functor form a category, and an initial object in that category might be an algebraic datatype
12:33:17 <benmachine> depending on what precisely F is
12:33:32 <benmachine> that's the abbreviated version of it
12:33:32 <darveter> benmachine: that is Chinese for me. I don't speak Chinese.
12:33:51 <benmachine> darveter: fair enough, then don't worry about it
12:34:10 <darveter> benmachine: thanks again.
12:34:10 <David> Is there anything like uniplate's transform for a data structure whose children are lists?
12:34:25 <vanila> the algebra thing is probably best explained with diagrams along the way
12:34:47 <David> I have a tree of the form Tree {mainChild :: Tree, children :: [Tree]} and I want to perform a bottom-up traversal
12:34:57 <vanila> although doesn't it require the category of cones?
12:35:09 <vanila> it would probaby be a lot of category theory before it's understable
12:35:22 <benmachine> vanila: it might be, it might not
12:35:32 <benmachine> I don't think cones come into it, necessarily
12:35:44 <benmachine> it depends which bits you want to do at what level of detail
12:35:56 <vanila> I remember building data types out of cones,there's another way?
12:36:05 <benmachine> <e shrug
12:36:07 <benmachine> er
12:36:07 * benmachine
12:36:11 <monochrom> no, you bring out cones and limits when you want to prove that final coalgebras exist in selected categories.
12:36:15 <benmachine> right
12:36:36 <monochrom> instead, if you just exert that they exist, you don't need to mention them.
12:36:58 <benmachine> yes, I agree with that
12:37:03 <monochrom> s/exert/assert/
12:39:45 <fread2282> what's the latex for unicode =>?
12:41:02 <coppro> \Rightarrow
12:42:07 <BMeph> or \doublerightarrow maybe?
12:42:45 <monochrom> it's really \Rightarrow
12:43:33 <fread2282> thanks, I was looking for \Rightarrow
12:48:39 <BMeph> So what's the latex code for a -> glyph?
12:48:52 <mauke_> I'm going to take a guess: \rightarrow
12:48:54 <benzrf>          
12:49:11 <benzrf> rightarrow ‚Üí Rightarrow ‚áí
12:49:26 <BMeph> ...wow, that's kind of scary. Believable, yet scary.
12:49:59 <mauke_> \RIGHTARROW
12:52:30 <benmachine> BMeph: \to I think is a common alias
12:52:34 <benmachine> provided by some package or other
12:52:45 <shelf> I use \to and \gets
12:54:04 <mauke_> should be \to and \ot
13:00:12 <marchelzo_> i have an Int, size, and I want to make an Int with the value (fromIntegral . round . logBase 2 . fromIntegral) size
13:00:27 <osiin111> Is there a more concise way to write a function that returns a data type constructed from a bunch of smaller variables, some pure and some from returns? http://lpaste.net/110619
13:00:38 <marchelzo_> but I am getting errors saying "the type variable 's0' is ambiguous"
13:01:20 <benmachine> osiin111: it depends whether the ...s contain any of the other variables, if not then yes, there's a better way
13:01:52 <osiin111> benmachine: They do not, they're all independent.
13:02:16 <benmachine> osiin111: ok, so, you want Applicative notation, basically
13:02:21 <monochrom> @type fromIntegral . round . logBase 2 . fromIntegral
13:02:22 <lambdabot> (Num c, Integral a) => a -> c
13:02:43 <benmachine> let's see
13:02:54 <monochrom> > (fromIntegral . round . logBase 2 . fromIntegral) (50 :: Int)
13:02:56 <lambdabot>  6
13:03:19 <monochrom> I think I can't reproduce the problem.
13:03:25 <benmachine> :t (++) <$> getLine <*> return "floo"
13:03:26 <lambdabot> IO [Char]
13:04:33 <benmachine> osiin111: try doing :m +Control.Applicative and then running that ^ in ghci, see if it enlightens you
13:04:49 <benmachine> you can extend it more using more <*>s
13:04:57 <marchelzo_> monochrom: it's weird. It says there are several potential instances: instance RealFrac Double defined in 'GHC.Float', instance RealFrac Float defined also in 'GHC.Float' and another one defined in GHC.Real.Ratio
13:05:08 <marchelzo_> I am getting three error messages from that one expression
13:05:10 <monochrom> hrm, I prefer (++ "floo") <$> getLine
13:05:12 <osiin111> benmachine: Thanks!
13:05:33 <benmachine> monochrom: sure, that works when you only have one impure expression, but that's not the case in the original question
13:05:40 <monochrom> I see.
13:05:56 <benmachine> monochrom: I just couldn't off the top of my head think of an arity-three function I could use
13:06:30 <monochrom> if-then-else :)
13:06:35 <benmachine> osiin111: anyway, the rough idea is that <*> acts as function application, but "inside" some functor, e.g. inside IO
13:07:35 <mths> hello guys
13:07:53 <benmachine> osiin111: so you can embed some constructor (which is a function) into an IO type, using return, and then apply it to arguments in IO using <*>
13:08:03 <benmachine> return f <*> arg1 <*> arg2 <*> arg3
13:08:20 <benmachine> if any of the arguments are pure, you just embed them in with return again
13:08:24 <osiin111> benmachine: I see - the only question I have, is some arguments are defined using let a = ... where
13:08:35 <benmachine> return f <*> arg1 <*> arg2 <*> arg3 <*> return val4
13:08:35 <osiin111> benmachine: Sorry, that's my question - what do you mean by that last bit?
13:08:38 <osiin111> Ah
13:08:40 <osiin111> Thanks!
13:08:49 <osiin111> Much cleaner
13:09:19 <benmachine> you may also find that liftA6 MyConstructor does something similar
13:09:22 <benmachine> without so much punctuation
13:09:28 <benmachine> or liftM6, if you prefer
13:09:32 <benmachine> :t liftA6
13:09:33 <lambdabot>     Not in scope: ‚ÄòliftA6‚Äô
13:09:33 <lambdabot>     Perhaps you meant one of these:
13:09:33 <lambdabot>       ‚ÄòliftA‚Äô (imported from Control.Applicative),
13:09:35 <benmachine> aw
13:09:38 <monochrom> marchelzo_: in (fromIntegral . round . logBase 2 {- what type is here? -} . fromIntegral), there is a question of what type is there. nothing constrains it further than "needs Floating and RealFrac". well I guess RealFrac subsumes Floating.
13:10:02 <benmachine> I guess they only go up to liftA3
13:10:18 <monochrom> but in normal setups, the question is answered by a "defaulting" clause in Haskell 2010. Double gets chosen.
13:10:20 <benmachine> oh, but up to liftM5
13:10:25 <benmachine> well, whatever
13:10:33 <marchelzo_> monochrom: I added an explicit type signature and it is indeed fixed
13:28:28 <merijn> marchelzo_: With -Wall ghc should warn about defaulting, so you can check if things are going as you expect
13:28:43 <merijn> (in the interest of avoiding future confusion)
13:29:03 <merijn> Also, you should just always compile with -Wall and selectively disable warnings you don't want
13:30:15 <EvilMachine> Hi. Is there a good guide on type families? The wiki page and the GHC manual are both really ambiguous, and it‚Äôs impossible to infer what to write from them.
13:31:18 <EvilMachine> How did you guys learn type families?
13:37:23 <christiansen> by examples in talks
13:47:53 <osiin111> Is this an egregious use of Applicative notation? http://lpaste.net/110624
13:49:54 <Cale> osiin111: No, it's pretty much exactly the sort of thing that Applicative notation is good at
13:50:16 <osiin111> Cale: Alright, thanks!
13:51:58 <merijn> Where do Functional Pearls usually get published? I just had a really neat idea, that if it works out would make a nice Functional Pearl, but I have no clue where I'd submit such a paper to :)
13:55:48 <monochrom> the Journal of Functional Programming
13:57:38 <christiansen> JFP, ICFP, TFP, IFL all accept functional pearls as far as I know
13:58:06 <christiansen> though getting functional pearls into ICFP is difficult - that category had by far the lowest acceptance rate this year
13:58:14 <merijn> Except I missed ICFP anyway :p
13:58:20 <merijn> And IFL is like, real soon
13:58:32 <christiansen> yeah
13:59:06 <merijn> As in, monday :p
13:59:10 <merijn> So that won't work :)
13:59:16 <christiansen> heh
13:59:29 <christiansen> I have a submission in, but I got it done early for once
13:59:41 <christiansen> like 2 weeks ago - it was weird
14:00:02 <merijn> TFP was just this summer too, right?
14:01:04 <christiansen> yeah
14:01:10 <christiansen> there may be other venues
14:01:15 <hiptobecubic> Has anyone seen this http://vimeo.com/74354480 ? What did you think?
14:01:19 <merijn> So JFP looks like the only credible option, but that immediately feels out of my league :p
14:01:28 <christiansen> worth a try
14:01:36 <christiansen> everyone gets there first journal paper sometime
14:01:39 <christiansen> *their
14:02:27 <merijn> christiansen: Yeah, but I don't have any colleagues in FP around to sanity check whatever I write
14:02:37 <christiansen> merijn: that's what the internet is for
14:02:47 <christiansen> as well as the journal editors and reviewers
14:03:04 <merijn> Anyway, aim high! ;)
14:03:17 <christiansen> perhaps you can find a coauthor at another institution?
14:03:35 <christiansen> hiptobecubic: I haven't watched it
14:03:55 <tharper> merijn: lots of people would probably be willing to proofread your work
14:04:04 <christiansen> the summary seems needlessly straw-man-killing
14:04:19 <christiansen> but that's likely to get an audience
14:04:26 <hiptobecubic> i was planning digging in today, but ironically, first i'm trying to throw together some python that it would describe as "just working"
14:04:43 <christiansen> it's certainly the case that much more good software is written in python, php, and js than in haskell
14:05:00 <christiansen> but this isn't really evidence either way as to the utility of types
14:05:23 <merijn> anyhoo, errand time now :)
14:05:34 <hiptobecubic> I think perhaps it's more about why people keep making *new* things in those languages despite having access to typed languages
14:05:53 <christiansen> possibly - like i said, i haven't watched it
14:06:06 <christiansen> and my video talk queue is very, very long following icfp and workshops :)
14:06:10 <christiansen> anyway, gotta run
14:06:16 <hiptobecubic> ciao
14:07:25 <christiansen> hej d√• :)
14:09:15 <tharper> Iceland_jack: ping?
14:15:16 <marchelzo_> how can I import a module with an ambiguous module name
14:16:29 <geekosaur> PackageImports extension, but if you're in that situation then you have already lost
14:16:46 <marchelzo_> for some reason I have two Text.Regex.PCREs
14:19:12 <geekosaur> if you're using cabal then you specify the appropriate package as a dependency. for ghci try: ghci -package thepackagehere
14:22:25 <marchelzo_> that didn't work. I just unregistered one of the packages
14:31:29 <spopejoy> sigh. Any emacs etags users here? It really seems like hasktags chokes on lhs files, most notably GHC Base.lhs
14:32:50 <eacameron1> does GHC runtime ever STOP OS threads?
14:36:31 <spopejoy> specifically, it looks like hasktags doesn't recognize \begin{code}. I really have to question why lhs format is so inconsistent. If you don't want to put "> " before your code, why the F are you using "literate" haskell in the first place???? {- -} comment blocks are just as good!!
14:37:18 * spopejoy takes deep breath and pulls another shot
14:38:11 <spopejoy> guess i'ma gonna fork hasktags and try to fix. Joy ...
14:40:19 <Twey> spopejoy: The \begin{code} is supposed to be to allow for literate programs that compile both as Haskell programs and as LaTeX documents (i.e. papers, generally).
14:41:22 <Twey> You define a nice code environment and call it ‚Äòcode‚Äô, and then your code becomes inline code figures in the document.
14:52:47 <spopejoy> It just seems strange for libraries, why GHC Base needs to be "literate" is beyond me. For an example of lhs files gone wild, look at the Haskore package.
14:53:41 <spopejoy> If etags weren't so broken for lhs files I wouldn't be ranting.
14:54:41 <spopejoy> Actually getting set up with a decent TAGS file for the platform + libraries is a non-trivial task in the first place. Then when it breaks ...
14:56:09 <spopejoy> I mean, without this kind of setup on your local, you're pretty blocked if hackage is slow. I like hoogle/hayoo and all, but it should be a lot easier to have a source-linked reference on your local.
14:58:54 <spopejoy> What's hilarious in GHC base is that the code blocks have pages-long comments prefixed by --. Why do programmers hate real comment blocks so much? I've seen the same in java/c where people work really hard to format their novels written with //
15:04:15 <arianvp> why would one choose Reader over (->) r ?
15:04:22 <arianvp> both have a MonadReader instance
15:05:06 <arianvp> transformer stacks?
15:07:35 <cin> arianvp, the types are easier to understand with Reader than (-> r)
15:07:55 <ion> (r ->)
15:15:03 <vanila> Is anyone in contact with anyone who can fix lambda the ultimate?
15:15:20 <nyuszika7h>     Illegal instance declaration for ‚ÄòDefault Rational‚Äô
15:15:21 <nyuszika7h>       (All instance types must be of the form (T t1 ... tn)
15:15:22 <nyuszika7h>        where T is not a synonym.
15:15:52 <nyuszika7h> what is it a synonym of?
15:15:59 <nyuszika7h> :i Rational
15:16:03 <nyuszika7h> > :i Rational
15:16:05 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
15:16:16 <nyuszika7h> ah, GHC.Real.Ratio...
15:16:22 * nyuszika7h just enables TypeSynonymInstances
15:18:09 <vova> Hi. Please help me to find the haskell module. I would like to work with linux processes (pids). Is there a function like "pid is alive" ?
15:18:42 <vova> I know about module Sysem.Process.
15:18:47 <cin> check the unix package
15:18:55 <cin> @hoogle hackage unix
15:18:58 <lambdabot> No results found
15:19:00 <cin> @google hackage unix
15:19:01 <lambdabot> http://hackage.haskell.org/package/unix-2.5.1.0
15:19:01 <lambdabot> Title: Hackage: unix: POSIX functionality
15:19:35 <hpc> http://hackage.haskell.org/package/unix-2.7.0.1/docs/System-Posix-Process.html
15:19:38 <geekosaur> System.Posix.Signal, signalProcess with nullSignal
15:19:46 <hpc> getProcessStatus :: Bool -> Bool -> ProcessID -> IO (Maybe ProcessStatus)
15:19:56 <geekosaur> note that this will also fail if it's not your process. there is *no* portable way to test for a process
15:20:43 <NiceFellow> hey m808
15:20:51 <geekosaur> hpc: only for child processes or processes in the same pgroup
15:21:00 <NiceFellow> lol
15:21:01 <hpc> oh, bah
15:21:02 <vova> Thank you very much.
15:21:05 <geekosaur> not arbitrary processes
15:21:13 <NiceFellow> i bet there are a million script kiddies in here
15:21:27 <hpc> it's true
15:21:32 <hpc> we can teach you to hack the database
15:21:40 <NiceFellow> holy fuck
15:21:46 <Cale> NiceFellow: Why would you say that?
15:21:50 <NiceFellow> do you even kernel bro?!?!?
15:21:52 <cin> NiceFellow, see #visualbasic
15:22:09 <cin> if you want to track an ip address
15:22:15 <NiceFellow> holy shit
15:22:24 <NiceFellow> i can get someones general region with their ip
15:22:26 <NiceFellow> dayum
15:22:32 <gratimax> noooo wayyy
15:22:35 <gratimax> it's like hacking
15:22:44 <NiceFellow> i just shit my pants, this is advanced
15:22:48 <gratimax> did you know 96% of hackers use Haskell?
15:22:49 <NiceFellow> XD
15:22:52 <vanila> @ops
15:22:52 <lambdabot> Maybe you meant: pl oeis docs
15:22:52 <gratimax> they like the safety
15:23:00 <vanila> @where ops
15:23:00 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
15:23:18 <NiceFellow> does anyone here know how to hack kernel?
15:23:20 --- mode: ChanServ set +o copumpkin
15:23:21 --- mode: ChanServ set +o shachaf
15:23:28 * copumpkin bows at shachaf 
15:23:35 --- kick: NiceFellow was kicked by shachaf (NiceFellow)
15:23:41 --- mode: copumpkin set -o copumpkin
15:23:42 <zomg> Flawless victory
15:24:07 <Cale> Not sure if the kick was required, we could have tried asking him to stay on topic
15:24:30 <geekosaur> agreed
15:24:41 <vanila> kick was good, look how stupid he made the channel
15:26:28 --- mode: shachaf set -o shachaf
15:27:29 <simpson> I know how to hack kernel. :c
15:27:31 <ryantrinkle> is there a good way to "touch" a value being used as the key of a Weak pointer, to ensure that it will stay alive? the docs say that optimizations can make liveness unpredictable for that stuff
15:27:53 <ryantrinkle> i'm looking for something like: touch :: a -> IO ()
15:28:48 <tabemann_> simpson: I partially suspect "hack kernel" here didn't mean write device drivers
15:31:45 <tabemann_> that still wouldn't be on-topic unless someone found a way to write kernel modules in Haskell
15:34:24 <cin> ryantrinkle, i don't know of something that'll adjust the generation of an object. a StablePtr will stop something from being collected, though, if that helps
15:40:44 <ryantrinkle> cin: i'm not sure i need to adjust the generation, and unfortunately i can't use a StablePtr - i just basically have to make sure that *if* a reference exists to a particular IO action, then a reference also exists to a given object
15:40:57 <ryantrinkle> but i'm not actually using that object in any way
15:44:41 <MR4Y> Is there an easier way for someone to understand HOFs?
15:44:56 <tabemann_> HOFs?
15:45:17 <MR4Y> tabemann_:  Higher Order Functions.
15:45:25 <BMeph> ...and, an easier way then what? :)
15:45:58 <tabemann_> higher order functions are simply functions that take functions and do things with them
15:46:18 <tabemann_> I'm not sure what's not easy about thtt
15:46:20 <vanila> learn by example
15:46:27 <tabemann_> that*
15:46:58 <MR4Y> vanila: Problem is that I understand the examples, but I'm not able to create my own Higher Order Functions.
15:46:58 <vanila> > let doThreeTimes f x = f (f (f x)) ; double x = x * 2 ; square x = x * x in (doThreeTimes double 5, doThreeTimes square 5)
15:46:59 <lambdabot>  (40,390625)
15:47:27 <vanila> Here's a really simple example of writing a higher order function "doThreeTimes" which just does f 3times to an input
15:47:53 <MR4Y> vanila: And if I wanted that to be curied instead?
15:48:09 <vanila> MR4Y, what is stopping you from creating them?
15:48:19 <BMeph> UNcurried, MR4Y? ;)
15:48:20 <vanila> or making it harder or anything
15:48:33 <tabemann_> doThreeTimes is curried
15:48:49 <tabemann_> and why would you want something uncurried?
15:49:01 <vanila> don't worry about curry just now, that is a distraction
15:49:08 <MR4Y> vanila: Well, I can't do those if they are curried.
15:50:06 <tabemann_> why can't you write curried higher-order functions? I don't get what you are getting at
15:50:49 <MR4Y> tabemann_:  It's the whole function :: type thing.
15:51:50 <tabemann_> MR4Y: doThreeTimes :: (a -> a) -> a -> a
15:52:10 <tabemann_> what's hard about that
15:52:16 <BMeph> MR4Y: I do think you mean uncurried, i.e. a single argument in a tuple form, but I'll stop saying so if you confirm yourself. :)
15:52:23 <MR4Y> tabemann_: I don't have to do something like ((a-> a) -> a) ?
15:53:34 <vanila> MR4Y, is there some code you could show to ask about specifically? I don't know exactly what the problem is
15:53:37 <tabemann_> MR4Y: you put function arguments to other functions in parens
15:54:59 <MR4Y> tabemann_: So, regardless of how many arguments, I just need one (a -> a)
15:55:30 <darveter> MR4Y: did you mean "partially applied" by "curried", like let g = doThreeTimes double in g 5?
15:56:10 <darveter> MR4Y: g :: (Num a) => a -> a
15:56:48 <tabemann_> MR4Y: if you take one function as an argument that takes one type and returns the same type, yes
15:57:22 <meretrix> Is there any way to send multiple types of the same type class to a single Chan?  The Chan reader will only use functions from their common type class.
15:57:41 <tabemann_> doThreeTimes :: (a -> a) -> a -> a is but one example
15:59:07 <tabemann_> meretrix: sounds like you are using existential types
15:59:10 <MR4Y> tabemann_: Yes, but what I don't get is that the application is different. If it's aplication is doThreeTimes f x = f (f (fx)), then why it's type signature is just (a -> a) -> a -> a?
16:00:24 <tabemann_> because it takes one function of type a -> a and one argument passed to its initial application
16:01:25 <darveter> MR4Y: doThreeTimes :: (a -> a) -> a -> a means it can acept f :: a -> a as first arguent; and f can accept x :: a as argument; then we have f x :: a and so f cen also accept (f x) as argument.
16:01:43 <tabemann_> meretrix: http://www.haskell.org/haskellwiki/Existential_type
16:01:51 <darveter> s/cen/can
16:02:08 <MR4Y> tabemann_: So, how the function application would be if its time signature was ((a -> a) -> a)) ->  a -> a -> a?
16:02:20 <meretrix> tabemann_: Yup, that's probably it. Thanks
16:02:29 <MR4Y> *there's one extra parentheses in there. Typo.
16:02:36 <vanila> :t let hoo f x y = f (f (f x y) y) y in hoo
16:02:38 <lambdabot> (t -> t1 -> t) -> t -> t1 -> t
16:04:06 <MR4Y> I see.
16:04:10 <darveter> @djinn ((a -> a) -> a)) ->  a -> a -> a
16:04:10 <lambdabot> Cannot parse command
16:04:19 <darveter> @djinn ((a -> a) -> a) ->  a -> a -> a
16:04:19 <lambdabot> f a _ _ = a (\ b -> b)
16:05:17 <darveter> :t let f a b c = a (\x->x) in f
16:05:18 <lambdabot> ((t3 -> t3) -> t2) -> t -> t1 -> t2
16:05:44 <tabemann_> do you get how -> is associative MR4Y
16:06:08 <MR4Y> tabemann_: Yes, now I do.
16:07:00 <vanila> hmm
16:07:29 <vanila> it's confusing that associative has multiple uses
16:07:33 <tabemann_> yes
16:07:49 <vanila> I want better terminology but is there?
16:08:45 <dreams> App (Var "f") (Var "g") <-- is it wrong to think of a thunk like that
16:09:10 <dreams> "think of a thunk" <-- should be a title.
16:09:50 <dreams> that's just an application node: f g
16:10:41 <vanila> dreams, thunk is a way to add lazyness to a strict language
16:11:00 <vanila> App (Var "f") (Var "g") is a good way to model the syntax of f g
16:12:20 <dreams> vanila: well yeah but in some implementation we'd have a stack pointing to each application node in the heap.
16:13:16 <dreams> vanila: hmm, I'll ask again when I have more information.
16:15:25 * BMeph advertises: "Please read the latest soon-to-be Dr. Seuss classic, 'Thomas Thinks of a Thunk'!"
16:15:40 <dreams> BMeph: heh.
16:29:31 <dfarm> Does anyone know off the top of their heads if Attoparsec skipSpace consumes tabs? The docs say "skip over whitespace" without defining what they mean (I assume runs of spaces and tabs)
16:30:31 <CrazyM4n> is there a type that can store other things with O(1) lookup?
16:30:46 <CrazyM4n> like, a list that isn¬¥t terribly inefficent
16:31:15 <CrazyM4n> even better, is there a 2d version of that type, if it exists?
16:31:32 <fread2282> CrazyM4n: what keys? maybe some vector?
16:31:34 <triliyn> CrazyM4n: there are vectors if you need O(1), and various other slower-than-vector-but-faster-than-list maps and sequences
16:32:40 <CrazyM4n> i don¬¥t *need* O(1), but it would be nice
16:33:57 <CrazyM4n> i¬¥m writing a parser for something, and it¬¥s stack based, and I would like to make stack lookup and navagating the program O(1) instead of O(n) or whatever lists are
16:34:03 <dfeuer> CrazyM4n, vectors can do O(1) indexing. But updating just one spot could be pretty inefficient.
16:34:15 <CrazyM4n> uh, i¬¥ll give some context
16:34:17 <dfarm> Ok, answering my own question -> yes it looks like it does
16:35:42 <CrazyM4n> https://github.com/CrazyM4n/brainfunge I have this, and I want to make the TwoDimProgram more efficent than an [[a]]
16:35:49 <dfeuer> If you want cheap lookup *and* cheap update, you either need to use some sort of monadic mutable vector thing in IO or ST (which has its own efficiency costs) or switch to something O(log n) or O(log(min {i+1, n-i})) or something.
16:36:27 <CrazyM4n> is it really worth the effort? the extra speed would be nice, but i don¬¥t know if it¬¥s worth the time
16:36:31 <CrazyM4n> after all, it works now
16:36:48 <Cale> CrazyM4n: Well, lists do a good job for a stack, it's O(1) to operate on the start of a list
16:37:02 <dfeuer> Yes indeedy.
16:37:31 <Cale> (In fact, a list is just about ideal for this)
16:37:41 <CrazyM4n> see commandRun MoveFrom/MoveTo in brainfunge.hs to see my concern
16:37:41 <Cale> For the two dimensional program itself, you probably want to use an array
16:38:24 <Cale> Oh, I see
16:38:42 <Cale> Yeah, that's a pretty nasty operation for a stack. I suppose you could try using Data.Sequence
16:39:01 <Cale> It supports splitting and concatenation in log time.
16:39:23 <CrazyM4n> what time would you say that function is
16:39:34 <Cale> Well, it's linear time
16:39:37 <CrazyM4n> (i¬¥m just trying to think if it would be worth it)
16:40:20 <dfeuer> I think it's one of those O(log min {i+1,n-i}) things, right, Cale? Which is to say very very good if you need to do a lot of these fancy operations to it.
16:40:47 <Cale> dfeuer: Yeah
16:40:49 <Luke> I just hit some pretty weird behavior in GHC. If I pull a recursive function body out into it's own `where` then it changes the semantics of the program (namely making `last` throw)
16:40:53 <dfeuer> There are other things like catenable deques that don't give you random access but are faster at the ends.
16:41:00 <CrazyM4n> sorry for the kind of dumb question, but what do you mean by ¬®O(log min {i+1,n-i})¬®
16:41:15 <CrazyM4n> more specifically, what do you mean by ¬®i+1,n-i¬®
16:41:22 <merijn> Luke: Sounds unlikely, lpaste the original and new version + output?
16:41:36 <Luke> merijn: the code is complicated
16:41:46 <Cale> CrazyM4n: The time to split a Seq is the log of the minimum of the distances to either end
16:41:52 <Luke> merijn: i was able to reproduce the error by just moving in and out of a where though
16:41:59 <merijn> Luke: I'm betting pulling the body out into a where has caused you to pattern match "1 step to far"
16:42:13 <merijn> Luke: Last is partial, so applying it to empty lists throws an exception
16:42:31 <Luke> merijn: understood though I don't know how I would change the semantics but pulling the body into a where variable
16:42:35 <akurilin> question: is there a way to have the time library be smart about daylight savings when picking a timezone? Right now if I want to America/Los_Angeles I have to pick between PST and PDT (at least when using time-exts package), which means I have to manually determine if DST is on or off
16:42:36 <merijn> Luke: I'm willing to bet that if you replace your use of "last" with pattern matching you will find where you're going wrong
16:42:50 <akurilin> any chance there's a way to let the library pick the right DST UTC offset for me for that location?
16:42:50 <sinelaw> @pl \x -> fromMaybe Nothing x
16:42:50 <lambdabot> fromMaybe Nothing
16:42:54 <sinelaw> duh.
16:42:59 <dfeuer> CrazyM4n, the basic gint of that O(log min ...) is "Fast access at the ends; gets slower toward the middle; never really bad"
16:43:11 <Luke> merijn: even weirder: the same code runs from hunit and from criterion and only fails in criterion
16:43:16 <CrazyM4n> ah, thanks for the layman explanation
16:43:41 <Luke> merijn: could be a change in laziness perhaps? criterion forces a whole bunch of stuff to normal form
16:43:46 <CrazyM4n> considering that it takes place at the very edge of an infinite stack, i think it would be ok
16:43:47 <CrazyM4n> thanks
16:43:51 <merijn> Luke: I think criterion uses deepseq to fully evaluate expressions, that could change strictness properties
16:43:58 <Luke> merijn: right
16:44:11 <merijn> So it might be a criterion issue/bug?
16:44:16 <Luke> merijn: and pulling the body into a where allows it to be inlined
16:44:19 <merijn> Or just an unintended consequence
16:44:27 <dfeuer> Criterion lets you do that, but it doesn't make you. Are you using nf where you want wfnf?
16:44:31 <dfeuer> Criterion offers both.
16:44:39 <Luke> dfeuer: I ahve the deepseq myself
16:44:45 <dfeuer> Hrrr.
16:44:48 <dfeuer> Weeeeeird.
16:44:49 <Luke> and nf
16:44:53 <Luke> that doesnt change
16:44:58 <dfeuer> Oof.
16:44:59 <Luke> it works if the body is not in a where
16:45:12 <Luke> inlining would be the only difference
16:45:22 <Luke> why would inlining change the semantics of my program?
16:45:23 <dfeuer> Luke, you're not using zip, zipWith, or foldr2 by any chance, are you?
16:45:28 <Luke> no
16:45:37 <dfeuer> Or build, for some reason?
16:45:41 <zwer_> sinelaw, perhaps join will work as well
16:45:44 <zwer_> > join (Just (Just 10))
16:45:45 <lambdabot>  Just 10
16:45:49 <Luke> oooho oh i pattern match at the top level
16:45:53 <Luke> i'm totally changing the program
16:45:55 <Luke> this is my fault
16:46:04 <Luke> laziness was saving me from the bug in hunit
16:46:25 <Luke> i only pulled ONE of 2 bodies into the where
16:46:33 <Luke> ok thanks guys
16:46:45 <sinelaw> zwer yip
16:46:46 <sinelaw> thanks
16:46:53 <dfeuer> Oops.
16:46:56 <Luke> hg bisect ftw
16:47:25 <dfeuer> Luke, I mentioned zip, zipWith, and foldr2 because they are actually a bit broken with regard to laziness in some cases, and inlining could definitely change their behavior in those.
16:47:34 <merijn> Luke: Figured it was pattern matching one to far :)
16:47:43 <Luke> merijn: ;-) yes thank you
16:47:54 <Luke> i knew it was... just why? now I know =)
16:48:07 <Luke> dfeuer: oh that's weird
16:48:16 <mjiig> Is there a way to specify a type signature for a function in ghci? Everytime I try I get an out of scope error
16:48:35 <shachaf> mjiig: let f :: ...; f = ...
16:49:01 <shachaf> You can also try a multiline definition with :{ but that's kind of awkward in ghci.
16:49:05 <mjiig> Oh, so the definition and the signature have to be in a single line?
16:50:41 <dfarm> Does anyone have any tips for figuring out Attoparsec parsing failures (I know this is the part where I get beat up for not using Parsec or Trifecta :( ). I'm just getting a failed reading: takeWhile1 message
16:50:55 <copumpkin> you don't get beat up
16:51:08 <copumpkin> but I don't know the answer :)
16:51:14 <Luke> with criterion, do I have to deepseq explicitly even if it's wrapped in a nf?
16:51:16 <zwer_> not sure what environment you are using but in emacs you have a repl in the buffer and you can send it function definition or entire source file with a single key stroke.
16:52:15 <dmj`> dfarm: do you have code?
16:53:12 <merijn> dfarm: I would usually just create a quick wrapper to evaluate different parsers and try to run them on input in ghci and see what fails where
16:55:41 <dfarm> Sure, I can lpaste the code and some sample input
16:55:51 <d-snp> I am victorious!
16:56:08 * d-snp is hitherto known as the Pipes-wrestler
16:57:43 <shachaf> And what are you known as now?
16:58:45 <d-snp> woops, I should look up big words before I use them ;)
16:59:01 <d-snp> now I am known as the pipes-applier
16:59:01 <d-snp> :P
16:59:03 <dfarm> Anyway, it's pretty hacked up at the moment. It would parse a bunch of these things, but I have it just trying to parse one (since I was trying to narrow it down). And I also kind of explicitly tried to "hand write" the parser to rule out just misusing a combinator like count. http://lpaste.net/1966925902935752704
17:00:12 <lpaste> Luke pasted ‚ÄúTasty HTML Problem‚Äù at http://lpaste.net/110638
17:00:23 <dfarm> I know the header parser bit works (insofar as it returns the information I want, if I just stub out the tensors bit).
17:00:28 <Luke> ^^ can anyone see the problem here? http://lpaste.net/110638
17:00:31 <Luke> tasty issue
17:00:35 <Luke> tasty-html that is
17:00:47 <Luke> trying to avoid having to run tests with command line args
17:01:00 <d-snp> Haskell is a bit unfair, no one is ever going to know this small commit took me hours and hours of wrestling types, weird monad transformers and walls of academic-grade documentation
17:01:09 <merijn> dfarm: I'm going to do a monochrom and ask you for the grammar for your parser :)
17:03:06 <CrazyM4n> d-snp: i know. isn¬¥t that enough? :D
17:06:09 <dfarm> merijn: I guess you mean the spec, since it's pretty much data serialization. I'm trying to find it.
17:06:20 <dfarm> There actually is one, but it's ancient.
17:07:08 <merijn> dfarm: (E)BNF is a good way to document and design your parsers and it's fairly easy to compare your parsers to your BNF
17:08:33 <dfarm> merijn: I know what EBNF is... I guess I just hadn't considered it for something like this (I always think of it in the context of parsing languages. E.g., I dont' know that I've seen BNF for a csv parser. But I guess you're right, not a bad way to think about it.
17:09:58 <dfarm> Although I don't think you could do BNF for this format because it isn't context free.
17:10:21 <merijn> A non-context free CSV?
17:10:44 <merijn> How's that?
17:12:13 <dfarm> merijn: I might be screwing this up, but I think it's context dependent because it reads the dimensionality from the header and then the number of entries per "record" depends on the dimensionality in the space and the flag for each record.
17:15:05 <merijn> dfarm: parseNode seems to read a lot more doubles than exist on a single line?
17:15:28 <dfarm> The code for skipSpace says it consumes end-of-lines also
17:16:19 <merijn> dfarm: Where does it say that?
17:16:39 <merijn> oh, I guess the source does
17:17:21 <dfarm> Yeah
17:18:00 <merijn> Does double parse minus signs?
17:19:02 <merijn> Does your file end with a newline?
17:19:13 <Luke> https://stackoverflow.com/questions/25705953/how-to-default-tasty-html-output-location
17:19:34 <dfarm> merijn: I'm trying to figure that out right now in ghci. Trying parseOnly double "-3.1" but it's complaining about [Char] -- need to figure out how to set OverloadedString I guess
17:20:09 <merijn> dfarm: :seti -XOverloadedStrings
17:20:41 <dfarm> merijn: yes to new lineline, and yep it appears to parse negative doubles also.
17:20:42 <merijn> dfarm: So far I'm betting on no end of line in your file :)
17:21:32 <merijn> dfarm: The result of an attoparsec parse returns the remainder as well, I recommend stripping bits of your parser until it succeeds and inspecting the remainder
17:21:41 <merijn> To see if it looks like what you expect
17:22:06 <merijn> thoughtpolice: Ping?
17:23:35 <dfarm> merijn: Ok, I appreciate the tips and appreciate you taking the time to look it over (ugly as it is).
17:40:42 <dfarm> Ah, well that was slightly tedious but very easy. Thanks for the tip merijn! Looks like I just missed a skipSpace after parsing the 'flag' value. Now to compress it back into something sensible.
17:42:42 <merijn> :)
17:45:40 <shelf> > fix not
17:45:44 <lambdabot>  mueval-core: Time limit exceeded
17:45:49 <shelf> > fix and
17:45:50 <lambdabot>  Couldn't match type ‚ÄòGHC.Types.Bool‚Äô with ‚Äò[GHC.Types.Bool]‚Äô
17:45:50 <lambdabot>  Expected type: [GHC.Types.Bool] -> [GHC.Types.Bool]
17:45:50 <lambdabot>    Actual type: [GHC.Types.Bool] -> GHC.Types.Bool
17:47:13 <CrazyM4n> ¬®fix not¬® I just kind of what to know what was expected to happen there
17:54:37 <shelf> CrazyM4n: time limit exceeded
17:55:28 <spopejoy> How do I read this type signature??  (Functor f, Num (Int -> f Int)) => User -> f User
17:56:09 <vanila> spopejoy, it looks like something that might happen if the code is wrong
17:56:25 <spopejoy> I'm trying to create a type hole ...
17:56:27 <vanila> is it definitely correct code?
17:57:12 <spopejoy> it's the result of partially applying a lens to the target value. Ie if f = Lens Int User; f = undefined, then that's the type of f 1
17:57:34 <vanila> ahh.. with lens all bets are off
17:57:41 <spopejoy> It's my own lens, no magic.
17:59:39 <tac_> Are there any notable places where Haskell makes use of tries in standard library data structures?
18:00:47 <spopejoy> I'm trying to learn lens from first principles, ie implement view, set, over ... for implementing view, it was helpful to create a type hole for the value. For set, it would seem that a type hole for the record object would be useful, which is how I ended up with that type.
18:02:38 <spopejoy> I guess my basic question is, the type signature "(Functor f, Num (Int -> f Int)) => User -> f User" describes a unary function yes? The stuff before the => is all about the f.
18:04:26 <spopejoy> I'm batting 1000 for "questions that nobody wants to answer on #haskell" these days
18:05:36 <Iceland_jack> spopejoy: yes
18:05:43 <vanila> spopejoy, I started to learn lens from first principles too http://lpaste.net/110639
18:05:47 <merijn> spopejoy: Have you seen edwardk's lens talk?
18:05:58 <merijn> spopejoy: He has a 2 hour talk on youtube explaining the basic types
18:06:01 <merijn> @where lens
18:06:01 <lambdabot> #haskell-lens | http://lens.github.io/ | https://github.com/ekmett/lens | http://www.youtube.com/watch?v=cefnmjtAolY&hd=1
18:06:05 <merijn> ^^
18:06:06 <vanila> spopejoy, if you want to share any insights/collab that would be nice
18:06:17 <tac_> spopejoy: heh
18:06:48 <merijn> I highly recommend watching it and pausing to try and play with the types he mentions (like expanding expressions by hand on paper) if you wanna work out lens from first principles
18:07:13 <spopejoy> merijn: i will check that out.
18:08:15 <spopejoy> vanila: I'm working with Jakub Arnold's lens tut http://blog.jakubarnold.cz/2014/07/14/lens-tutorial-introduction-part-1.html
18:11:36 <spopejoy> vanila: Happy to share but mine is still in the first fourth of yours :) . I was looking at the lens code trying to understand 'mapped' when I saw edwardk's comment "'Data.Traversable.fmapDefault' = 'over' 'Data.Traversable.traverse'"
18:12:18 <spopejoy> I couldn't find anything to help me understand fmapDefault. Somehow that led me to start from scratch with lens ... all because I hate to use code I don't understand.
18:12:32 <vanila> spopejoy, I haven't actuallyed looked at mapped - I might have picked it up under a different name though
18:13:06 <merijn> :t fmapDefault
18:13:07 <lambdabot>     Not in scope: ‚ÄòfmapDefault‚Äô
18:13:07 <lambdabot>     Perhaps you meant ‚ÄòT.fmapDefault‚Äô (imported from Data.Traversable)
18:13:12 <merijn> :t T.fmapDefault
18:13:12 <lambdabot> Traversable t => (a -> b) -> t a -> t b
18:13:26 <spopejoy> looks a lot like functor
18:13:51 <spopejoy> duh, it's called *fmap*default. Captain Obvious in the building.
18:13:58 <merijn> spopejoy: Which part of it don't you understand? :)
18:14:22 <merijn> It's fmap implemented using traverse :)
18:14:26 <merijn> :t T.traverse
18:14:27 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
18:14:34 <spopejoy> Why call it "default"?
18:14:45 <merijn> spopejoy: The docs mention that :)
18:15:00 <merijn> spopejoy: You can use it to implement fmap for a type when you've already implemented Traversable
18:15:23 <spopejoy> oh as in fmap = fmapDefault, and call it a day if you're Traversable?
18:15:36 <spopejoy> makes sense.
18:15:41 <merijn> spopejoy: Traversable requires a n Functor superclass
18:15:52 <merijn> spopejoy: But typeclasses dependencies or not linear
18:16:14 <merijn> spopejoy: So, yeah, you can write that and then only implement "instance Traversable MyType where traverse = blah"
18:16:27 <merijn> And skip writing a definition for fmap
18:17:10 <merijn> spopejoy: Similarly you could implement Applicative's <*> by just writing "(<*>) = ap", assuming you've already written a Monad instance
18:17:14 <merijn> :t ap
18:17:15 <lambdabot> Monad m => m (a -> b) -> m a -> m b
18:17:18 <merijn> :t (<*>)
18:17:19 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
18:17:36 <spopejoy> I see, it's like staring up the typeclass hierarchy and retrieving functionality already there
18:18:12 <spopejoy> When is Monad going to require Functor/Applicative? Is that still happening?
18:18:19 <copumpkin> 7.10
18:18:48 <spopejoy> I feel like that's such a big thing for demystifying haskell, although I can't fully justify that feeling as a newb
18:19:31 <merijn> spopejoy: the compiler doesn't first check for Functor/Applicative and then Monad, it checks simultaneously, so using "subclass" functions in a superclass is fine, as long as the compiler can find an implementation for both classes at compile time
18:20:11 <merijn> Of course, if your superclass calls the "subclass" the subclas better implement that functionality without calling back to the superclass, or you'll have an infinite recursion :)
18:20:13 <spopejoy> I've noticed that. Must be why =>> works when there's no monads in sight
18:20:27 <spopejoy> sorry >>=
18:20:36 <merijn> oh?
18:20:38 <merijn> Like when?
18:20:43 <spopejoy> oh wait [] is a monad. oops
18:20:47 <merijn> :)
18:34:21 <spopejoy> vanila: you were right the code is "wrong"
18:34:34 <spopejoy> as in there's not enough information to create the type hole yet.
18:35:14 <spopejoy> I should really hurry up and upgrade from GHC 7.6.3, but I'm afeared of screwing up my env for days
18:50:01 <L8D> spopejoy: Did you get my solution from last night?
18:50:27 <L8D> spopejoy: Also upgrading from 7.6 to 7.8 breaks the text package on OS X if you use homebrew
18:50:39 <David> for the osx/brew using people here - I'm beginning to lose hope that the 2014 version of haskell-platform is going to get updated to brew based on https://github.com/Homebrew/homebrew/issues/31609 - should I use cask or something else?
18:50:42 <spopejoy> L8D, I did, thank you.
18:51:00 <L8D> spopejoy: DOES IT WORK?
18:51:29 <spopejoy> Yes!
18:51:38 <L8D> yes yes yes yes yes yes yes!
18:51:42 <L8D> I'm so happy
18:51:53 <spopejoy> But you were right to question the approach
18:52:22 <L8D> I get this high whenever I solve challenging problems in fair Haskell
18:52:31 <L8D> It's the reason I love the language.
18:52:32 <spopejoy> Another way to do it was to stick 0s into all the Int slots, and then use a Lens to traverse over them.
18:53:42 <spopejoy> You have to admit, the solution was complex, requiring recursive calls to effect unzipping in two dimensions.
18:54:00 <L8D> but I'm stuck writing JavaScript );
18:54:10 <David> use ghcjs :)
18:54:16 <L8D> David:
18:54:36 <spopejoy> Well I was stuck writing core Java for 10 years. At least js lets you use jquery :)
18:54:37 <L8D> I've wanted to. But I can't do FRP the way it was meant to be done
18:54:46 <David> :(
18:54:47 <L8D> FRP in GHCJS that is
18:54:51 <David> clojurescript?
18:55:18 <hamishmack> L8D: Why not?
18:55:33 <L8D> ClojureScript doesn't do FRP unfortunately. It does the stuff that it does to support concurrency
18:55:48 <L8D> hamishmack: one second. I'll write an example
18:55:49 <c74d> David: I hear that the fancy newish package manager Nix (<https://nixos.org>, #nixos) works on Mac
18:56:13 <c74d> (if that was what you were asking ‚Äî or is ‚Äúcask‚Äù not another package manager?)
18:56:15 <spopejoy> I still feel like there's a Cont or State solution to effect a generator. Isn't that how folks use random without polluting everything with IO?
18:57:27 <vanila> spopejoy, what is the problem exactly?
18:57:34 <vanila> do you have solved code
18:58:11 <David> c74d: https://github.com/caskroom/homebrew-cask/blob/0c645c8d20f0469baf82bd6fa589b9e1b397cf29/Casks/haskell-platform.rb
18:58:25 <David> I don't want to get yet another package manager because I'm way too heavily invested in brew at the moment
18:58:32 <L8D> @pl tasks ts t = either (:ts) (delete t ts) t
18:58:33 <lambdabot> tasks = join . ap ((.) . either . flip (:)) (flip delete)
18:58:49 <jonh> :close
18:58:52 <L8D> @pl tasks ts = either (:ts) (`delete` ts)
18:58:52 <lambdabot> tasks = ap (either . flip (:)) (flip delete)
18:59:29 <David> I was just wondering whether to use the platform from cask, or to do it manually by installing ghc and cabal-install and then installing the rest manually
18:59:32 <c74d> David: okay
18:59:44 <c74d> I don‚Äôt know what the file at that URL means though
19:00:26 <spopejoy> vanila: I have a number of ways of solving, but none what I was envisioning. L8D solved with a recursive approach, and there's a lens+traverse way. Basically, I have code that is populating [[a,Int]], where the number of sub-arrays is not known in advance. When I'm done, the Int values need to cycle through 1..5 (say) as though the list were flattened.
19:00:50 <spopejoy> I envision passing in a stateful generator of some sort.
19:00:57 <vanila> is there a formal spec along with the recursive solution/
19:01:05 <vanila> i would try maybe
19:02:33 <David> (I also want to avoid nixos since it seems like it's designed for multiple OSes which means I'll still need to keep brew around for osx-specific stuff, and I really want to avoid two package managers)
19:02:44 <c74d> ?
19:02:56 <c74d> NixOS *is* an operating system
19:03:01 <MP2E> You mean nix, right?
19:03:07 <David> er.. yeah, nix
19:03:08 <David> derp
19:03:10 <c74d> ah
19:03:44 <c74d> I don‚Äôt think so, though I don‚Äôt use either Nix or Homebrew
19:03:54 <c74d> (‚Äúbrew‚Äù is Homebrew, right?)
19:04:05 <pepsi4me_> Good morning, America
19:04:08 <spopejoy> vanila: actually I spoke too soon, it doesn't look like the recursive solution works. I can provide a working solution with the lens approach.
19:04:10 <David> I just checked... nix doesn't have things like onepassword, or recordit, or dogecoin, etc.
19:04:14 <David> and yes, brew is homebrew
19:04:18 <CrazyM4n> so is there any specific reason that fix isn¬¥t in the prelude? that was a bit confusing because I was under the impression that it was
19:04:48 <vanila> spopejoy, well im just wondering what the problem spec is  exactly
19:04:58 <hiptobecubic> David, Even on well maintained OS's with real packages and package managers, I still think it's better to use cabal yourself. You should be sandboxing anyway.
19:04:58 <David> so, to go back to the original question - install ghc+cabal-install via brew and get the requisite packages, or grab the entire haskell-platform binary with homebrew-cask?
19:06:21 <David> hiptobecubic: even sandboxing packages inside haskell platform?
19:07:26 <L8D> hamishmack: https://gist.github.com/L8D/bb4a5fd737e6624a2fbc
19:07:38 <L8D> That's psuedo-code but it's how I want to be able to write FRP
19:07:41 <David> or do you mean I should be sandoboxing packages in my own projects and that makes the platform less useful?
19:07:49 <hiptobecubic> David, the latter
19:08:08 <David> ah, ok, thanks.
19:08:10 <hiptobecubic> David, especially now that stackage is available, the platform seems much less useful to me
19:09:19 <hamishmack> L8D: And why is that possible in GHC, but not GHCJS?
19:09:27 <L8D> hamishmack: one sec
19:10:06 <geekosaur> why do I feel like Haskell's going to end up with Rubyish anarchy no matter what?
19:10:15 <theme2> hi
19:10:28 <David> oh, stackage is cool
19:10:39 <David> thanks for telling me about it
19:10:39 <CARAM> can I do a char type enumeration but get a list of word8s instead of char?
19:10:57 <CARAM> eg ['A'..'z'] :: Word8 instead of [Char]
19:11:23 <L8D> hamishmack: reload
19:11:30 <theme2> I felt very stupid when I realized that "lift" isn't "liftM" (after a few weeks of confusion)
19:11:39 <theme2> Am I the only one that confused those two?
19:11:41 <L8D> one is in haskell, the other is in javascript
19:12:08 <theme2> L8D: Are you talking to me?
19:12:14 <geekosaur> map (toEnum . fromEnum) ['A'..'z'] :: [Word8] -- note that your range is slightly broken
19:12:20 <geekosaur> > map (toEnum . fromEnum) ['A'..'z'] :: [Word8] -- note that your range is slightly broken
19:12:21 <lambdabot>  [65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,...
19:12:27 <L8D> theme2: no, hamishmack
19:12:49 <CARAM> geekosaur: cheers, thanks
19:14:18 <L8D> hamishmack: Essentially, I need to have clean ways to access properties on the events, and clean ways to merge event streams
19:14:41 <David> ok, thanks for the help hiptobecubic. I guess I'll be installing ghc and cabal separately and use stackage
19:14:49 <L8D> I don't see that being very possible with GHCJS since it's FFI is restrictive
19:14:58 <hamishmack> L8D: Are you unhappy with sodium (and the like) or unaware that they work with GHCJS?
19:15:32 <L8D> hamishmack: Does sodium work with DOM events?
19:16:01 <hamishmack> yes
19:16:16 <L8D> hamishmack: Could you point me to documentation or examples on how to do that?
19:17:24 <L8D> because sodium seems entirely seperate from GHCJS and I don't see myself writing very efficient apps using external libraries in GHCJS
19:20:03 <hamishmack> L8D: Something like this.. https://github.com/ghcjs/ghcjs-examples/blob/master/webkit-sodium/src/Engine.hs#L128
19:20:04 <theme2> Is there a table somewhere that matches Haskell constructs to their C/C++/Java equivalents?
19:20:48 <hamishmack> That is a very old example and is actually using webkit shims rather than ghcjs-dom
19:21:21 <hamishmack> but the code shoudl be exactly the same for ghcjs-dom
19:22:24 <hamishmack> actually we did convert that one
19:22:28 <hamishmack> it is using ghcjs-dom
19:23:22 <theme2> It took me quite some time to realize that haskell "polymorphism" is c++/java "generics"
19:23:23 <L8D> hamishmack: what about composing and merging streams?
19:23:56 <L8D> theme2: You don't understand polymorphism then.
19:23:59 <theme2> and haskell "generics" is c++/java "overloading"
19:24:18 <theme2> and c++/java "polymorphism" simply doesn't exist in haskell
19:24:26 <theme2> L8D: why?
19:24:53 <hamishmack> L8D: http://hackage.haskell.org/package/sodium-0.10.0.2/docs/FRP-Sodium.html#v:merge
19:25:56 <L8D> theme2: because polymorphism isn't about having a generic type to operate on
19:26:22 <L8D> theme2: generics mean the compiler will compile the types to all that are used
19:26:29 <theme2> L8D: erm which "polymorphism" and which "generic"?
19:26:29 <L8D> :s/mean/imply
19:26:37 * theme2 is confused
19:26:42 <copumpkin> L8D: in C++ templates, that's true, but not in java
19:26:50 <copumpkin> you're also describing implementation strategies
19:26:53 * theme2 is more confused
19:27:08 <L8D> theme2: polymorphism implies that the compiler doesn't even need to compile or optimize or etc for the generic types
19:27:20 <L8D> i.e. it's built in
19:27:21 <theme2> L8D: what generic types?
19:27:23 <copumpkin> o.O
19:27:40 <L8D> theme2: additionally polymorphism includes typeclasses and other stuff
19:27:50 * theme2 is confused by jargon namespace clashes
19:28:03 <L8D> copumpkin: It's the general concept behind them...not necessarily implementations
19:28:30 <L8D> I'll just shut up and let someone else explain it.
19:28:57 <theme2> c++/java polymorphism requires inheritance
19:29:08 <theme2> and inheritance doesn't exist in haskel afaik
19:29:12 <theme2> s/haskel/haskell
19:30:10 <hamishmack> L8D: Soium also has a monoid instance for Event so you can also use that merge events.
19:30:33 <theme2> I also took quite some time to realize that the haskell "class" is c++ "abstract class" / java "interface"
19:31:27 <theme2> also, haskell "map" doesn't correspond to c++ "map" but it is c++ "for_each"
19:31:50 <shachaf> Haskell mapM_ is close to C++ for_each.
19:32:01 <theme2> seriously, someone needs to make a table for all this
19:32:26 <shachaf> It sounds like it might cause more harm than good.
19:32:50 <theme2> shachaf: what harm?
19:32:50 <jmcarthur> i don't think it's a good idea to learn haskell in terms of imperative languages
19:33:48 <tabemann_> too much Haskell is already written as essentially imperative
19:33:50 <shachaf> In many cases you can only make rough analogies. The analogies will confuse people and make it harder for them to learn Haskell.
19:33:51 <theme2> jmcarthur, shachaf: just add a few "N/A"s and haskell learners from imperative languages would probably focus on that more
19:34:03 <jmcarthur> theme2: most of the table would be N/A
19:34:20 <theme2> shachaf: In many cases there are 1-to-1 matches
19:34:31 <shachaf> Not that many cases.
19:34:37 <jmcarthur> theme2: what kind of 1-to-1 match do you expect?
19:34:49 * jmcarthur is having trouble even thinking of just one
19:34:53 <shachaf> But maybe there are 1-to-0.8 matches, where the missing 0.2 is particularly important.
19:35:07 <theme2> Having haskell "return" matching with "N/A" would definitely save some "aha" moments for some people
19:35:22 <theme2> rough matches might also be ok
19:35:27 <jmcarthur> not if it lives in a maze of N/A, anyway
19:35:29 <shachaf> Not when everything else is matching with "N/A".
19:35:53 <theme2> such as haskell "data" matching to c++ "enum"&"struct"
19:35:54 <jmcarthur> theme2: so what would be an entry in the table that isn't N/A or 1-to-0.8?
19:36:03 <jmcarthur> nope, that's not a match
19:36:42 <theme2> jmcarthur: ???
19:37:07 <joelteon> data Foo = Bar Int | Baz String
19:37:12 <joelteon> what's that in c++?
19:37:21 <jmcarthur> theme2: maybe a struct with an enum tag and a union of structs would be closer, but even that isn't a perfect fit
19:37:40 <theme2> I'm not expecting a perfect fit, after all
19:37:53 <jmcarthur> then what's the point of the table? it sounds actively harmful now
19:38:21 <theme2> also, haskell "type constructors" matches to c++ "class templates"
19:38:26 <jmcarthur> ugh
19:38:32 <theme2> is that important?
19:39:15 <theme2> btw the point of this table would be "to decrease the initial learning curve of haskell"
19:39:17 <jmcarthur> if i can't trust the table to be accurate, i just can't use it
19:39:25 <lpaste> spopejoy pasted ‚Äúgenerator function‚Äù at http://lpaste.net/110642
19:39:27 <tabemann_> people shouldn't come to Haskell trying to program in it as they would program in C++
19:39:29 <jmcarthur> because there's no way for me to tell if my conclusions from it are accurate
19:39:45 <spopejoy> vanila: if you want, check out http://lpaste.net/110642
19:39:54 <bramgg> Real World Haskell vs Learn You a Haskell for programmers that have never done functional programming before?
19:40:00 <theme2> hmm
19:40:11 <spopejoy> RWH is gentle at the start
19:40:20 <vanila> -- Given [[String]], return [[(Bool,Int)]], where the Int value must cycle through
19:40:20 <vanila> -- a modulo.
19:40:28 <vanila> this isn't a complete specification
19:40:37 <tabemann_> I'd start with LYAH, and then go on to RWH
19:40:54 <platz> when rust gets higher-kinded-types, there might be only a minimal impedance-mismatch such that it'd be useful to call rust libraries from haskell
19:41:05 <jmcarthur> I don't believe in instruction by misinformation.
19:41:05 <spopejoy> vanila: that's because this is contrived to simplify the real-world requirement. The Bool in (Bool,Int) is contrived.
19:41:07 <tabemann_> RWH assumes you already know how to program in Haskell
19:41:18 <vanila> ok but i still don't know what function this is supposed to be
19:41:40 <spopejoy> Look at "testRR" or "testRL", the output is below the function
19:41:43 <vanila> sorry for being so demanding but it needs to be clear
19:41:50 <bramgg> Thanks all. I think I'll go with LYAH. It's funny how it's graphics actually make it seem easier...
19:41:55 <vanila> a couple input/output pairs isn't enough to pin down a function
19:42:06 <theme2> another (probably) important match: haskell "if-then-else" to c/c++ "ternary operator"
19:42:14 <spopejoy> vanila: ok let me clarify
19:42:28 <NemesisD> hey guys. i'm hitting the GHC stage restriction with TH in a "types" module. anyone have any strategies for dealing with this?
19:42:32 <vanila> ok!
19:42:51 <theme2> I did initially get confused because I thought "if-then-else" is supposed to be strictly imperative
19:43:08 <jmcarthur> theme2: does haskell's if-then-else allow me to perform side effects?
19:43:46 <NemesisD> i was thinking having a Types.TH module and a another module for the non TH stuff, and then one Types module that reexports the rest of them but I don't know what to call that second module
19:43:47 <theme2> jmcarthur: well... IO is a hard thing, after all
19:43:48 <jmcarthur> theme2: what do you mean "strictly imperative"?
19:44:10 <jmcarthur> theme2: and doesn't this actually support that you *don't* want to associate haskell concepts with imperative programming?
19:44:12 <theme2> jmcarthur: in most languages, "if-then-else" translates to a "CPU branch"
19:44:31 <jmcarthur> theme2: then your problem is that you are so attached to "most languages"
19:44:44 <jmcarthur> theme2: not that you don't have this inaccurate table
19:45:12 <theme2> jmcarthur: Anybody who did imperative programming before will attempt to associate haskell if-then-else with the if-then-else from other language
19:45:24 <theme2> so it's better to have it associated to the ternary operator
19:45:26 <jmcarthur> theme2: quite a generalization
19:45:28 <tabemann_> Haskell if then else is syntactic sugar for ifThenElse : Bool -> a -> a -> a
19:45:32 <jmcarthur> theme2: i did not do that
19:45:41 <tabemann_> ::*
19:45:47 <theme2> s/Anybody/Most people
19:46:14 <tabemann_> are most people going to be learning Haskell? I hope not
19:46:19 <jmcarthur> theme2: and even if that was true, the correct response would be "we should dissuade them from doing such things" not "we should encourage them to do such things"
19:46:30 <lpaste> spopejoy revised ‚Äúgenerator function‚Äù: ‚Äúgenerator function‚Äù at http://lpaste.net/110642
19:46:42 <spopejoy> vanila: better spec.
19:47:19 <vanila> thanks! looking
19:47:23 <theme2> jmcarthur: maybe it's like learning a "natural" language without a dictionary
19:47:31 <vanila> spopejoy, ill have a go implementing it
19:47:43 <shachaf> A dictionary is useful for vocabulary, not grammar.
19:47:45 <spopejoy> vanila: you mean a generator function approach? woohoo!
19:47:53 <jmcarthur> theme2: i think it's fair to say that haskell's if then else is "more like" C's ternary operator than C's if then else, but i don't think it's fair to say it "is" like it
19:47:58 <vanila> hey i ight not be able to, lets see.. :)
19:48:03 <spopejoy> :)
19:48:10 <tabemann_> I would hope those learning Haskell have a definite interest in functional programming, not just wanting to go program in it as they have been in C++ or Java
19:48:42 <spopejoy> L8D: see http://lpaste.net/110642 , my original example didn't compile. It also has the lens solution ...
19:49:01 <theme2> jmcarthur: apart from the syntax, how is haskell's "if-then-else" different from c/c++ "ternary operator"
19:49:02 <spopejoy> L8D: it has your version, plus a test confirming it works
19:49:15 <theme2> "if" -> "?"
19:49:27 <theme2> sorry, "if" -> ""
19:49:36 <theme2> "then"-> ":"
19:49:37 <jmcarthur> theme2: does haskell's if-then-else allow you to use side effects in its subexpressions?
19:49:46 <theme2> jmcarthur: how?
19:49:50 <jmcarthur> theme2: C's does
19:49:55 <tabemann_> theme2: for starters if then else is just syntactic sugar for an ordinary function
19:49:57 <spopejoy> theme2: there isn't any difference. ternary's are some of the only functional expressions in C
19:50:12 <spopejoy> or java
19:50:18 <shachaf> jmcarthur: I think that's slightly unfair. That happens with any sort of expression evaluation.
19:50:19 <theme2> jmcarthur: if-then-else in a do block?
19:50:38 <shachaf> But I think this argument wasn't particularly useful in the first place and zooming in to one tiny detail and arguing about it is even less useful.
19:51:16 <theme2> I have to go
19:51:21 <theme2> back in a few minutes
19:52:57 <tabemann_> I was going to say than if then else can return any type, monads included, but doesn't allow imperative forms when used outside a monad that allows them
19:52:59 <jmcarthur> shachaf: my point isn't that it's a difference in the feature, in isolation, but a difference of implication just because it comes from such a different context.
19:53:41 <jmcarthur> shachaf: if C's ternary operator only allowed variables as arguments instead of arbitrary expressions, side effects would be impossible, for example.
19:53:58 <jmcarthur> shachaf: but then of course that would be another difference with haskell's if-then-else anyway
19:54:08 <shachaf> Sure. The presence of lazy evaluation or effects makes it a very different thing.
19:54:36 <tabemann_> I think that a chart comparing Haskell forms with, say, C++ or Java ones is a bad idea just because it would encourage new Haskellers to try to learn it as if it were C++ or Java
19:55:02 <tabemann_> when there is so much fundamentally different about it
19:55:04 <theme2> I'm back
19:55:10 <thetallguy> Anyone know how to get an instance of Show to work inside a Template Haskell expression?
19:55:12 <jmcarthur> anyway, the gist of my argument is just that cherrypicking similar concepts from other languages doesn't imply that anything else is transferrable knowledge
19:55:51 <shachaf> I agreerthur, as you might guess from having said nearly the same things as he did earlier on.
19:55:51 <thetallguy> I can run show on a string, but it fails on UTCTime, even though the show instance is available
19:55:58 <theme2> jmcarthur: well, just accompany the "translation table" with a "list of stuff unique to haskell"
19:56:17 <jmcarthur> that list would be a link to the haskell report
19:56:24 <jmcarthur> too much to just list out there
19:56:36 <theme2> s/stuff/important stuff
19:56:49 <jmcarthur> the language definition isn't important?
19:57:09 <vanila> spopejoy, how about this? http://lpaste.net/110644
19:57:21 <tabemann_> the thing about creating a chart of this sort is just picking out the bits of roughly similar syntax when the language as a whole is so fundamentally different and cannot be learned by comparing syntax
19:57:31 <jmcarthur> eh, i'm out. i think i've expressed my argument sufficiently well that anything else is just repetitious
19:58:00 <jmcarthur> or... i've expressed my argument poorly and i am not good enough to avoid being repetitious
19:58:10 <shachaf> How about an exciting argument about unboxed sums instead?
19:58:14 <spopejoy> vanila: nice!
19:58:20 <jmcarthur> mmm, unboxed sums
19:59:07 <jmcarthur> parametric polymorphism is kind of like having open, unboxed sums
19:59:38 <jmcarthur> s/unboxed/untagged/, i guess
19:59:51 <shachaf> Those are very different. :-)
19:59:56 <spopejoy> vanila: I see, the State monad changes type through the mapM calls. I was hung up trying to fix the type ...
19:59:56 <jmcarthur> yeah
19:59:59 <jmcarthur> i realized my mistake
20:00:06 <tabemann_> unboxed sums... as in doing what OCaml does with constructors for sum types without parameters in representing them as simple integers than can be unboxed?
20:00:15 <shachaf> With parameters too.
20:00:25 <thetallguy> ah, not a template haskell problem.
20:02:14 <theme2> So, will making a "translation chart" along with a list of "fundamental concepts unique to FP/haskell" make haskell easier to approach?
20:03:26 <tabeman71> <tabemann_> how does one unbox a constructor for a sum type with parameters? keeping the fields in registers?
20:03:47 <shachaf> For instance.
20:04:26 <theme2> btw parametric polymorphism corresponds to generic programming with templates
20:04:41 <shachaf> It doesn't very much.
20:05:07 <tabeman71> theme2: can you have higher kinds in C++?
20:05:22 <theme2> tabeman71: erm... classes?
20:05:29 <theme2> typeclasses?
20:05:39 * theme2 googles higher kinds
20:06:15 <tabeman71> you can have higher kinded parameters, and partially applied parameters, to type constructors in Haskell
20:07:02 <tabeman71> try doing that with templates or Java generics
20:07:03 <theme2> tabeman71: well... that is sort of similar to currying
20:07:35 <theme2> And obviously, currying either doesn't exist or is hard to implement in c++
20:08:25 <tabeman71> I mean you can define, say, data Foo m a = Foo (m a)
20:08:42 <tabeman71> where m has kind * -> *
20:08:45 <theme2> the closest is defining a templated class in terms of another templated classes with more templates
20:09:01 <theme2> tabeman71: is that infinite recursion on types?
20:09:11 <tabeman71> no
20:09:33 * theme2 confused himself
20:09:56 <tabeman71> it is a simple example of a type that takes a parameter of a higher kind
20:09:57 <theme2> That "Foo" is possible using templates
20:10:03 <theme2> probably
20:10:33 <shachaf> Templates are quite different from parametricity anyway.
20:10:41 <theme2> http://stackoverflow.com/questions/213761/what-are-some-uses-of-template-template-parameters-in-c
20:10:48 <theme2> that "Foo" is possible
20:11:02 <theme2> although with some complexity
20:12:27 <theme2> haskell polymorphism actually maps pretty nicely to c++/java templates
20:12:33 <theme2> and generics
20:13:00 <tabeman71> can you do that in Java? IIRC it doesn't have higher kinds
20:13:49 * tabeman71 didn't know templates could take other templates as parameters in C++ though
20:13:50 <theme2> let me check
20:14:16 <jmcarthur> yes, C++ templates can take other templates
20:14:22 <jmcarthur> but Java generics can't do this
20:14:53 <tabeman71> but I presume C++ can't *partially apply* templates
20:14:59 <jmcarthur> no
20:15:19 <theme2> some typedef's should do it, I think
20:15:30 <jmcarthur> i also doubt you can make C++ templates polymorphically recursive
20:15:37 <jmcarthur> i said that badly
20:15:52 <theme2> jmcarthur: c++ templates are even turing complete
20:15:56 <jmcarthur> i doubt C++ has polymorphic recursive with templates
20:15:59 <jmcarthur> theme2: yes
20:16:08 <jmcarthur> *recursion
20:16:11 <shachaf> theme2: That's not particularly relevant to what jmcarthur said.
20:16:36 <jmcarthur> theme2: that C++ templates are turing complete is yet another difference
20:17:09 <theme2> partial template application can be done by c++11 "using"
20:17:10 <theme2> http://en.cppreference.com/w/cpp/language/type_alias
20:17:29 <shachaf> Someone brought Rust up earlier. It will probably never support polymorphic recursion either, since its implementation of polymorphism is similar to C++.
20:17:51 <jmcarthur> yeah. i know rust doesn't currently support polymorphic recursion
20:18:32 <shachaf> Or rank-n types, for that matter.
20:18:50 <jmcarthur> well, neither does haskell proper, does it?
20:19:07 <theme2> how did this conversation come to here?
20:19:16 * dfeuer was totally mystified by rank-n types until fairly recently. Now it's a little painful to think about not having them.
20:19:46 <theme2> my original thought was "a proposal to create a haskell to c++ partial translation table"
20:19:53 <jmcarthur> theme2: basically because C++ templates are not type constructors
20:20:19 <tabeman71> I don't think Haskell proper even supports multiparameter type classes
20:20:24 <jmcarthur> correct
20:20:46 <platz> shachaf: this may be true, but I also think there are also indirection techniques that might provide escape hatches
20:24:40 <platz> yeah apparently rust can't do polymorphic recursion because it doesn't play very nicely with "monomorphization"
20:24:45 <theme2> heh... someone already made some comparisons
20:24:46 <theme2> http://sms.cs.chalmers.se/publications/papers/2008-WGP.pdf
20:28:24 <platz> and one of their absolute priorities is *zero-cost* abstractions which is why they don't have it
20:37:48 <Rufflewind> say I have an FFI declared unsafe and I can't change that, is there a way to call it such that it behaves "just like" a safe call (doesn't block other Haskell threads)? the function doesn't call back into Haskell so that part is not relevant
20:41:28 <jmcarthur> Rufflewind: all i can think of is to run it in another process
20:50:52 <dhrosa> Does anyone know if it's possible to get the specific character / index that parsec fails at?
20:51:24 <dhrosa> I'm working on a project where the assignments wants the lexer to be able to print error messages but still continue lexing
20:55:48 <dhrosa> hmm ParseError looks promising, except I for some reason can't load that specific page -.-
20:56:28 <Rufflewind> jmcarthur: that's unfortunate :(
20:57:22 <dhrosa> there we go now it loaded
20:58:53 <Rufflewind> dhrosa: I don't believe Parsec can recover from parsing errors; you might have to embed your own monad (Either/ErrorT for example) to handle errors more gracefully
21:00:00 <dmwit> (<|>) is for recovering from errors.
21:07:34 <joelteon> also: "try"
21:09:30 * dfeuer worders if dhrosa saw either of those messages.
21:18:52 <trap_exit> anyone have any thing good to say abourt https://github.com/m4dc4p/haskelldb/blob/master/haskelldb.pdf ? it looks like "THE RIGHT WAY" to do sql processing in Haskell; but I cna't figure out why RWH didn't cover it
21:22:50 <wolfspaw> Newbie Question:
21:22:50 <wolfspaw> What is my mistake on the second where (the one I want to be used on the minFrom function): http://lpaste.net/110648 ?
21:22:50 <wolfspaw> "parse error input on '=' "
21:22:50 <wolfspaw> and what is the correct/idiomatic way to align those 2 wheres?
21:22:50 <wolfspaw> I want the second where to be on the scope of minFrom (the inner function)
21:25:17 <dmwit> wolfspaw: The "b" and "lus" must align with the "(" in "(us, vs)".
21:26:00 <dmwit> For "idiomatic", I think it is fairly common to put "where" on the line of the equation it's associated with and indent the remainder of the block one level.
21:26:18 <dmwit> (Or on a line of its own when it's weird to put it with the equation, as it is here with all those guards.)
21:26:28 <trap_exit> wolfspaw: are you using emacs
21:26:30 <dmwit> Although style varies widely, and yours doesn't make me blink.
21:26:38 <shachaf> There are many where idioms.
21:26:48 <trap_exit> I generally just tell it to auto indent the line a few times, and the one that looks most reasoanble happens to be the one that ghc likes
21:27:15 <wolfspaw> I'm using Sublime. dmwit yes, indeed it was that @o@. Did'nt know the variables had to be aligned
21:27:18 * trap_exit only uses let
21:27:29 <wolfspaw> trap_exit nope, I'm using sublime @o@
21:27:41 <dmwit> That seems like a good rule of thumb once you have acquired experience. But I suspect that the reason it looks good is because you've seen lots of code that GHC accepts, not because the best looking stuff is also the working stuff.
21:27:49 <trap_exit> wolfspaw: do you have a haskell indent file setup for sublime?
21:28:09 <wolfspaw> hm, I'm using the one that comes with it. I don't know if it's good enough, heh
21:29:19 <dmwit> wolfspaw: "where" is a block herald, along with "do", "let", "proc"... maybe a few others? The Report has the full list if you're curious.
21:29:28 <trap_exit> dmwit: I think it's pretty intuitive, atleast compared with the rest of haskell :-)
21:29:41 <dmwit> The impact of this is that the next token after a block herald sets the expected level for the entire block.
21:30:20 <dmwit> It needs to be indented at least as much as any enclosing block (strictly more in H98), but otherwise is unconstrained.
21:30:42 <wolfspaw> ah, okay. Thanks people xD
21:31:07 <xunzhang> ..
21:31:22 <dmwit> trap_exit: Perhaps. I prefer knowing the rules over trusting my intuition.
21:41:05 <jle`> what is @o@ supposed to depict?  a person with large ears?
21:42:30 <jle`> or maybe a person with a round nose
21:42:31 <jle`> hm
21:42:43 <c74d> a cannon, facing the reader?
21:42:45 <meditans> hi there.. anyone has experience on compiling hat (the haskell tracer) with ghc 7.8?
21:43:33 <meditans> I could make a ticket on github with my compilation failing, but I'd like to know if that project is alive (if someone knows)
21:45:24 <dmwit> hat has been dead for years.
21:46:40 <dmwit> Even if you got it to build, chances are bad that it would work with actual code. It doesn't really support any of GHC's extensions, and even some of the most basic libraries use them now.
21:48:15 <dfeuer> What takes its place in modern Haskell?
21:48:36 <meditans> sad... is there any other tool for visualizing the flow of computation in a haskell function? (other than, say, ghci debugger0
21:48:45 <dmwit> dfeuer: sadness
21:49:04 <dfeuer> Oh.
21:49:12 <dfeuer> I've never used it myself.
21:52:09 <jle`> i am used to sadness
21:52:10 <jle`> it has a pretty simple and stable api
21:52:35 <shelf> ;w;
21:58:11 <sagittarian_> hey does anyone know how to express liftM2 in terms of fmap (assuming that your monad is also defined as a functor)?
21:58:48 <jle`> sagittarian_: it's impossible :D
21:58:51 <shachaf> You can't.
21:58:55 <sagittarian_> really?
21:59:04 <jle`> it's actually one of the motivating reasons behind Applicative
21:59:10 <shachaf> You can write (fmap id (liftM2 f a b)) if you like.
21:59:22 <shachaf> You can't do it just with Functor.
21:59:27 <sagittarian_> that doesn't help very much
21:59:37 <sagittarian_> okay, so what can you do with applicative?
21:59:37 <shachaf> But see Applicative for a type class for things that you can liftM2.
21:59:43 <shachaf> It's called liftA2 there.
21:59:46 <jle`> applicative allows you to "merge" two functors together, f a -> f b -> f (a, b).  from there you can just uncurry f.
21:59:52 <shachaf> Applicative also gives you liftA0, which is called pure.
21:59:58 <jle`> applicative can be said to represent just Functor + liftA2
22:00:09 <sagittarian_> jle`, what's that merge function, liftA2?
22:00:11 <jle`> (and pure)
22:00:27 <jle`> it's not defined but it's commonly called ** in literature
22:00:35 <jle`> you can define it as liftA2 (,)
22:01:24 <jle`> of course once you have liftA2, you can see that you can liftA2 ($), and basically be able to express liftA3, liftA4, etc. with only fmap and liftA2
22:02:44 <jle`> liftA2 ($) is commonly called "ap", and is the (<*>) operator
22:03:24 <dmj`> > uncurry replicate =<< (,) <$> [1..3] <*> [ 4..6]
22:03:26 <lambdabot>  [4,5,6,4,4,5,5,6,6,4,4,4,5,5,5,6,6,6]
22:06:30 <dmwit> > do { n <- [1..3]; x <- [4..6]; replicate n x }
22:06:31 <lambdabot>  [4,5,6,4,4,5,5,6,6,4,4,4,5,5,5,6,6,6]
22:06:59 <dmwit> No sense dragging tuples into this.
22:07:44 <shachaf> dmwit++ # deobfuscation
22:15:38 <sagittarian_> wait i missed something, what's the special usefulness of liftA2 (,)?
22:16:24 <jle`> it isn't particularly useful
22:16:35 <jle`> but it was just to demonstrate that in order to "combine" two f a's, you need at least Applicative
22:16:35 <shachaf> You can define class Functor f => Monoidal f where unit :: f (); times :: f a -> f b -> f (a,b) which is equivalent to Applicative.
22:16:53 <jle`> if you have two f a's, and you want to return one f a (like liftM2 does), you need the specific power of Applicative
22:17:00 <shachaf> You can also class Functor f => Applicative f where pure :: a -> f a; liftA2 :: (a -> b -> c) -> f a -> f b -> f c which is equivalent to Applicative.
22:17:03 <shachaf> define
22:17:16 <dmj`> @typ liftA2 (,) getLine getLine
22:17:17 <lambdabot> IO (String, String)
22:17:56 <jle`> there is no other way to "squish" two f a's and return one; if you need to do something like f a -> f b -> f c, that's a sure indication that you need at least Applicative
22:18:03 <dfeuer> shachaf, why not add those to Applicative and give some decent defaults?
22:18:17 <jle`> (f a, f b) -> f c (... the uncurried version might be more illustrative here)
22:18:28 <mauke> af <*> ax = fmap (\(f, x) -> f x) (times af ax)
22:18:56 <dmj`> fmap f x = pure f <*> x
22:19:37 <jle`> basically, if you ever have multiple f a's, and you return one (and hope to use all of the inputs in the process), you need at least Applicative
22:19:48 <shachaf> Some of the objections go away now that we have MINIMAL.
22:20:02 <shachaf> It doesn't matter all that much.
22:20:34 <vlion> Somewhat n00b question: What's the standard/recommended web framework for small Haskell web sites? My rummagings have turned up three different ones that seemed approximately mature.
22:20:59 <jle`> vlion: it depends on what you need for your small web site; i have been happy with scotty for my own purposes
22:21:25 <jle`> but it might not be the best for all small web site use cases
22:22:02 <dmj`> vlion: depends on your needs. Does "small web site" include db access and authentication?
22:22:34 <vlion> dmj`: yes, pg access; auth is "maybe"
22:23:31 <pepsi4me_> What browser should I use other than chrome or firefox
22:23:52 <mauke> w3m
22:24:04 <dfeuer> pepsi4me_, that's off-topic.
22:25:00 <vlion> Not sure I want to have db access as part of the "web framework" in general, that smells overly coupled.  My primary concern is the IO pipe between reading the HTTP parameters & routes and sending strings back over the pipe.
22:26:25 <jle`> you might be happy with scotty then
22:26:34 <jle`> or actually, if that's all you want, you can just use wai
22:26:43 <jle`> scotty sort of makes routes less of a headache
22:27:00 <jle`> actually yeah, i'm sure scotty would help over wai
22:27:35 <vlion> jle`: do you mind ticking off the thoughts that led to that recc?
22:27:45 <vlion> I'm trying to contextualize myself in the haskell ecosystem
22:28:37 <jle`> vlion: do you have any experience with other web frameworks from other languages?
22:28:53 <jle`> if i'm lucky i can snag a useful analogy/comparison
22:28:59 * vlion wobbles
22:29:31 <jle`> it's like sinatra, from ruby
22:29:44 <vlion> I've stabbed rails in the face & been stabbed back. I've messed with python's WSGI & Lisp's caveman
22:29:45 <mauke> I know a bit about catalyst, dancer, mojolicious, web::machine
22:30:03 <c74d> (*looks up Scotty*) ‚ÄúAs for the name: Sinatra + Warp = Scotty.‚Äù ‚Ä¶how does one combine ‚ÄúSinatra‚Äù and ‚ÄúWarp‚Äù to make ‚ÄúScotty‚Äù? :s
22:30:07 <vlion> Ah, sinatra, that always has a nice feel to it when I look at it. OK.
22:30:35 <jle`> sinatra basically wraps the warp/wai server with some neat routing dsl's
22:30:45 <geekosaur> too many ST:TOS episodes watched while drunk?
22:31:00 <jle`> basically your routes are sort of like functions Route -> Text
22:31:24 <vlion> (oh, and I've used Go's routing framework. Pleasant except for the Go of it)
22:40:36 <FakeSlimShady> Today's idiot question. How do I use show on a double to get something in the format of "x.yz" instead of "x.y" as it appears to default to
22:41:16 <dmwit> > show 3.45
22:41:17 <lambdabot>  "3.45"
22:41:19 <dmwit> ?
22:41:26 <dmj`> > show 1.50
22:41:27 <lambdabot>  "1.5"
22:41:53 <dmwit> :t showFFloat
22:41:54 <lambdabot> RealFloat a => Maybe Int -> a -> ShowS
22:42:03 <dmwit> > showFFloat (Just 2) 1.50 ""
22:42:04 <lambdabot>  "1.50"
22:42:13 <dmwit> > printf "%.2f" 1.50
22:42:14 <lambdabot>  No instance for (GHC.Show.Show a0)
22:42:14 <lambdabot>    arising from a use of ‚ÄòM709159313288784494429179.show_M7091593132887844944...
22:42:14 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
22:42:14 <lambdabot>  Note: there are several potential instances:
22:42:14 <lambdabot>    instance [safe] GHC.Show.Show
22:42:21 <dmwit> > printf "%.2f" 1.50 :: String
22:42:23 <lambdabot>  "1.50"
22:42:30 <FakeSlimShady> Aww, you made lamdabot cry :/
22:42:43 <FakeSlimShady> Nevertheless, I consider my question answered. Thanks very much
22:43:39 <vlion> jle`: thanks for the pointer to scotty. It looks exactly like what I like
22:43:58 <jle`> vlion: np!
23:03:44 <xpika> is there application which will show the haskell source defintion for a given function?
23:12:45 <statusbot> Status update: The server load has decreased and availability is better. We're still monitoring the situation. Performance may be slightly lower than usual still. The hackage-builder is still offline. -- http://status.haskell.org
23:14:31 <dv-> i don't think so. if you load up haddock docs there's a source link next to every function
23:28:44 <solidus-river> hey all, is there a helper function to get all possible 3 combinations from a list of elements?
23:29:26 <solidus-river> :t combinations
23:29:27 <lambdabot> Not in scope: ‚Äòcombinations‚Äô
23:30:45 <trap_exit> hey
23:30:54 <trap_exit> is there a channel here dedicated to cloud ahskell?
23:31:13 <Fuuzetsu> hm, I thought there was
23:31:36 <Fuuzetsu> but I may be wrong, the parallel-haskell mailing list is probably the best place to ask stuff
23:32:32 <solidus-river> @hoogle [a] -> [[a]]
23:32:34 <lambdabot> Data.List inits :: [a] -> [[a]]
23:32:34 <lambdabot> Data.List permutations :: [a] -> [[a]]
23:32:34 <lambdabot> Data.List subsequences :: [a] -> [[a]]
23:34:02 <dmwit> > let cs 0 _ = [[]]; cs _ [] = []; cs n (x:xs) = map (x:) (cs (n-1) xs) ++ cs n xs in cs 3 [1..5]
23:34:04 <lambdabot>  [[1,2,3],[1,2,4],[1,2,5],[1,3,4],[1,3,5],[1,4,5],[2,3,4],[2,3,5],[2,4,5],[3,...
23:35:15 <dmwit> For a slight performance boost, keep track of the length of xs and generalize the cs _ [] case to stop as soon as your number is too big.
23:47:16 <Fuuzetsu> does the family of isomorphisms u_C in an equivalence of categories basically say how to go ‚Äòthrough‚Äô the original C ‚àà *C* ?
23:47:23 <Fuuzetsu> where *C* is the category
23:55:14 <shachaf> That depends on what "through" means.
23:55:55 <shachaf> It's probably easier to rename C to A than to use fancy bold C in IRC.
