00:01:49 <Schoening> This join / dc sure spams a lot
00:04:22 <mgaut72> shachaf: I definitely fall into the "it makes things simpler" category of that post.
00:04:40 <Schoening> What does "let" stand for? I mean what is it short for?
00:04:55 <vlion> Schoening: It stands for let.
00:05:13 <Schoening> let is not a word I am familiar with
00:05:27 <vlion> let X == $value has been a long-standing tradition dating back some 50+ years in math papers
00:05:33 <vlion> you can find it in early Lisp papers
00:05:48 <shachaf> mgaut72: Unfortunately it also makes them wrong.
00:05:57 <vlion> It means, "Suppose and define this thing to be such and such"
00:06:33 <shachaf> I think conal is being unfair in skipping over "nullary functions" because I think that's what almost everyone means by it.
00:06:39 <nshepperd> I think it's more accurate to say that haskell doesn't have zero-argument functions, so that most times you would write a foo() returning some value in another language, in haskell you would just define the value
00:06:40 <shachaf> Even though it doesn't make sense.
00:06:48 <Schoening> is there a "var" keyword or a "str" keyword?
00:06:56 <vlion> ??
00:07:06 <shachaf> But that learnyouahaskell.com page is just completely mixed up.
00:07:21 <mjrosenb> Schoening: no.
00:07:29 <mjrosenb> Schoening: what would you want them to do?
00:07:45 <Schoening> Nothing. I just prefer reading "var" to "let" :p
00:07:45 <nshepperd> which might lead to something thinking that "foo" in haskell and "foo()" in C are somehow equivalent
00:07:56 <mjrosenb> Schoening: but that would be misleading
00:08:19 <vlion> Schoening: you are out of luck then with Haskell, I am afraid.
00:08:25 <mjrosenb> > let ([a,b,c],d) = ([1,4,3],2) in c
00:08:26 <lambdabot>  3
00:08:38 <mgaut72> shachaf: so it makes the distinction that constant values are *not* functions, but definitions.  Are there any other haskell "things" that are often mistaken as functions?
00:08:54 <mjrosenb> Schoening: since you aren't necessarialy defining a single variable.
00:08:56 <shachaf> A definition is a completely different category of thing froma  function.
00:09:35 <mgaut72> shachaf: yes, but what else might I be incorrectly calling "just a function"
00:09:38 <Schoening> mjrosenb ah. Interesting. They are adding "let" to JavaScript. There it is just a scoped variable.
00:09:45 <shachaf> I don't know?
00:10:03 <mjrosenb> Schoening: yes, but javascript is /very/ different from haskell
00:10:07 <Schoening> scoped "something" I should say. Can be an object too
00:10:16 <vlion> LET is a traditional scoping form for a binding.
00:10:26 <mjrosenb> that being said, javascript now has someithng like that^, they call it "destructuring assignment"
00:10:36 <mgaut72> shachaf: so are there any other haskell "things" that are often mistaken as functions?
00:10:52 <shachaf> mgaut72: Probably?
00:11:28 <mjrosenb> Schoening: let also defines a scope in haskell, and the variables bound between let , and in go out of scope at the end of the let expression.
00:11:51 <mjrosenb> mgaut72: values of type IO a.
00:12:25 <mgaut72> mjrosenb: thanks for a concrete response.  technically IO is an "action" right?
00:12:55 <Schoening> mjrosenb: I thought it might be like that. Sadly it was only needed in JS because of some earlier design errors
00:12:57 <mjrosenb> mgaut72: that question has started wars.
00:13:12 <shachaf> mgaut72: IO is a type-level thing, and a type constructor.
00:13:13 <mjrosenb> Schoening: yeah, the lack of let in JS has some /hilarious/ consequences.
00:13:16 <shachaf> IO is a monad.
00:13:24 <shachaf> A value of type "IO x" is an IO action.
00:13:37 <shachaf> For instance, getLine is an action. IO is not an action.
00:13:45 <mgaut72> mjrosenb: iirc, LYAH calls IO an "action" but thats the extent of my knowledge.  If its touchy, I can accept that
00:13:46 <Schoening> mjrosenb: I have no idea how they thought no block scope would be a good idea
00:14:09 <shachaf> Schoening: No language bashing in here, please.
00:14:15 <mjrosenb> Schoening: it made the implementation easier.
00:14:21 <Schoening> Any haskell beginner books you people would recommend?
00:14:30 <nshepperd> mgaut72: (print 5) is a value representing the "action" of printing 5 to the console. It's idiomatic to call that an "IO action"
00:14:31 <mjrosenb> shachaf: I'm ok with it, it is a godawful misfeature.
00:14:45 <shachaf> mjrosenb: OK, but I'm not.
00:15:21 <tdammers> discussing the flaws of (not Haskell) is probably -blah material
00:15:27 <nshepperd> mgaut72: the type of (print 5) is IO ()
00:16:01 <mjrosenb> mgaut72: also, the type of main is IO() (no function there!)
00:17:01 <mgaut72> nshepperd: I think I understand the distinction.  but something like 'do print "asdf"; return "asdf"' is both an action and a monadic value?
00:17:52 <mjrosenb> mgaut72: (print 5) is also a monadic value.
00:19:07 <shachaf> "monadic value" isn't a great term, but sure.
00:19:50 <nshepperd> mgaut72: that would have type IO String. I normally think of such a thing as "an IO action returning a String"
00:20:02 <mjrosenb> speaking of language bashing
00:20:07 <mjrosenb> man I love bash.
00:20:14 <mjrosenb> I am not sure what I'd do without it :-p
00:20:30 <nshepperd> although for other monads, it may be more reasonable to speak of "containing one or more String"
00:22:07 <mgaut72> nshepperd: could have type (Maybe String) and value Nothing.  Or a [String
00:22:34 <nshepperd> whoops, yeah, should say "zero or more" really
00:22:46 <mgaut72> yea I gotcha
00:33:12 * hackagebot holy-project 0.1.1.1 - Start your Haskell project with cabal, git and tests.  http://hackage.haskell.org/package/holy-project-0.1.1.1 (yogsototh)
00:36:20 <mgaut72> is there a name for (>>) ?
00:37:25 <shachaf> (>>)
00:37:32 <mjrosenb> mgaut72: yes, "sequence", I think? I'm not 100% sure though.
00:37:55 <shachaf> "sequence" is usually the name for the function "sequence"
00:38:04 <mjrosenb> shachaf: yeah...
00:38:40 <mjrosenb> shachaf: which is why I was kind of unsure, but (>>) is definitely the sequencing operator over the IO monad.
00:38:54 <mjrosenb> that name holds up a bit less well for other monads
00:39:03 <mgaut72> shachaf: what is the name for (>>) then?
00:39:20 <shachaf> (>>)
00:39:27 <mjrosenb> > [1,1,1] >> [1,2,3]
00:39:28 <lambdabot>  [1,2,3,1,2,3,1,2,3]
00:39:37 <mgaut72> in english?
00:39:38 <mjrosenb> shachaf: I suspect he wants an english name.
00:39:40 <nshepperd> If I had to name it out loud, I might call it "sequence", but there's already a function called sequence :: Monad m => [m a] -> m [a], so it's not the best name
00:39:47 <mjrosenb> or at least pronounceable.
00:39:50 <nshepperd> "nullary bind" perhaps
00:40:01 <shachaf> Pronounce it "then"? Or "and then"?
00:40:09 <shachaf> It's like a semicolon.
00:40:31 <mjrosenb> shachaf: special semicolons get desugared into (>>)!
00:40:48 <mgaut72> haha mjrosenb
00:42:22 <HENK29933> > [1, 2, 3] >> [ 1, 1, 1]
00:42:23 <lambdabot>  [1,1,1,1,1,1,1,1,1]
00:42:43 <mjrosenb> nshepperd: nullary bind sounds like it would have type m a -> (() -> m b) -> m b
00:43:21 <HENK29933> > :t >>
00:43:22 <lambdabot>  <hint>:1:1: parse error on input ‘:’
00:43:31 <mgaut72> :t (>>)
00:43:32 <lambdabot> Monad m => m a -> m b -> m b
00:43:34 <HENK29933> > @type >>
00:43:35 <lambdabot>  <hint>:1:1: parse error on input ‘@’
00:43:48 <mgaut72> HENK29933: need parens for infix operators
00:43:53 <HENK29933> tx
00:45:17 <nshepperd> I guess. "then" is a good name
00:47:45 <mgaut72> mjrosenb: when you talked about the theoretical type of "nullary bind" that looked an aweful lot like how you express (>>) in terms of (>>=).  what exactly is () and how does it related to _ in pattern matching (if at all)?
00:50:35 <Cale> Schoening: 'let' has the sense of "please allow the following to be true"
00:51:47 <mjrosenb> mgaut72: () pulls double duty.
00:51:53 <Schoening> oki
00:52:02 <mgaut72> I kinda see how () makes sense in a monadic context where there are other things going on (ie the "actions" we were talking about
00:52:10 <mjrosenb> mgaut72: it is both the type unit, and the sole value that has type unit.
00:52:59 <mgaut72> mjrosenb: ok, so where does it get used, outside places like IO ()
00:53:09 <Cale> Schoening: You can introduce multiple definitions, and define functions inside of a 'let' in Haskell, and the bindings are allowed to be mutually recursive, so it's not quite like 'var'
00:53:15 * hackagebot minioperational 0.4.4 - fast and simple operational monad  http://hackage.haskell.org/package/minioperational-0.4.4 (FumiakiKinoshita)
00:53:40 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in (take 5 evens, take 5 odds)
00:53:42 <lambdabot>  ([0,2,4,6,8],[1,3,5,7,9])
00:53:46 <mjrosenb> mgaut72: () is more popular in non-lazy functional languages, since unevaluated expressions don't really exist.
00:54:15 <mjrosenb> Cale: that is cute. I haven't seen that one before.
00:54:24 <Schoening> Just playing around with the console right now. Why is   let test = [1,2,3]  test ++ ["456"]       not working?  I thought "" was sugar for 1,2,3
00:55:07 <Cale> "456" has type String
00:55:22 <Schoening> Cale: I don't know what "mutually recursive" means :x  but sounds similar to JS var.
00:55:25 <Cale> "456" is sugar for ['4','5','6']
00:55:43 <Cale> Schoening: Look at the relationship between evens and odds in the example I gave
00:55:56 <Cale> evens is defined using odds, and odds is defined using evens
00:56:05 <mgaut72> Schoening: exploring expressions by using ":t" in ghci is useful.
00:56:08 <mgaut72> :t (++)
00:56:09 <lambdabot> [a] -> [a] -> [a]
00:56:12 <Cale> and Haskell finds a solution to the system of equations
00:56:20 <mgaut72> :t ["456"]
00:56:21 <lambdabot> [[Char]]
00:56:28 <mgaut72> :t [1,2,3]
00:56:28 <lambdabot> Num t => [t]
00:56:54 <Cale> Schoening: You should be able to do  let test = ['1','2','3'] in test ++ "456"
00:57:02 <Cale> or
00:57:13 <Schoening> mgaut72: thanks for the :t
00:57:15 <Cale> let test = ["1","2","3"] in test ++ ["456"]
00:57:40 <iXeno> hi, if I wanna lift + for Maybe, how do I do it?  with just 'liftM (+)' or 'liftM (+) :: Maybe Integer'
00:58:15 * hackagebot minioperational 0.4.5 - fast and simple operational monad  http://hackage.haskell.org/package/minioperational-0.4.5 (FumiakiKinoshita)
00:58:22 <mjrosenb> "finds a solution to the system of equations" ... that gives haskell a lot more credit than it deserves.
00:58:46 <Cale> Well, that's what it does :)
00:59:08 <Cale> Its mechanism for doing that is perhaps more simplistic than you'd sometimes like :)
00:59:13 <mgaut72> I am always amazed at what a few well crafted list comprehensions can do
00:59:19 <Cale> But it really does solve them
00:59:53 <mjrosenb> Cale: well, the expressions need to have certain properties, which are much more strict than newcomers expect from "system of equations"
01:00:02 <Schoening> Cale: How come this did not work:  let test = ['1','2','3']    test ++ ["456"] ?  I would venture a guess that its because I am trying to add a "sub-list" to the first list. Not just some strings. But then.. why does your example work with the double quotes?
01:00:09 <mjrosenb> > let x = 1.0 + x*x in  x
01:00:13 <lambdabot>  mueval-core: Time limit exceeded
01:00:27 <Cale> Schoening: Because ['1','2','3'] is a list of characters, while ["456"] is a list of strings
01:00:51 <Cale> Schoening: So, if Haskell were untyped, the result would be ['1','2','3',"456"]
01:01:07 <Cale> Schoening: But it's not, and we insist that all the elements of a list have the same type
01:02:35 <mjrosenb> Schoening: unlike in javascript, 'a' and "a" are not equivalent.
01:02:47 <Cale> Oh, right
01:02:51 <Cale> '1' is a Char
01:02:54 <Cale> "1" is a String
01:02:56 <Schoening> Yeah I guess that's what is causing me trouble here
01:03:07 <Schoening> ok.
01:03:51 <mgaut72> I'm outta here.  Its been instructional, thanks everyone
01:03:57 <Schoening> can Caracters only be 1 "characters" long?
01:04:25 <killy9999> I need sanity check
01:04:39 <mjrosenb> Schoening: all characters are exactly one character long.
01:04:56 <killy9999> Section 7.6.3.3 of GHC user manual gives this example of instance allowed with FlexibleContexts:
01:05:04 <killy9999> instance C4 a a => C4 [a] [a]
01:05:18 <killy9999> but condition 1b in that section says:
01:05:24 <Cale> killy9999: I think that also requires FlexibleInstances
01:05:24 <killy9999> "The assertion has fewer constructors and variables (taken together and counting repetitions) than the head"
01:05:39 <Schoening> Okay. I think I just need to do more learn by examples now. Because initially I would think that would limit you a lot
01:05:59 <Cale> killy9999: Note that the list type constructors count as constructors
01:06:04 <killy9999> clearly, the assertion "C a a" has the same (not lesser!) number of constructors and variables as head "C [a] [a]"
01:06:08 <killy9999> ah, ok
01:06:08 <Cale> no
01:06:17 <killy9999> right
01:07:08 <killy9999> sanity checked. Thanks :-)
01:07:20 <Cale> no problem :)
01:07:43 <Cale> Schoening: It limits you a whole lot less than you'd think
01:08:16 <Cale> Schoening: If you're stuffing a bunch of stuff into the same list, then those things must have *something* in common, or else when you took them out again, you wouldn't know what to do with them.
01:08:55 <Schoening> I guess it's because I am still in a OO mindset?
01:09:17 <Cale> Schoening: Insisting that the things have the same type amounts to insisting that you work out what the list elements have in common, since if it's just some common interface (in an OO sense), you can pre-apply those functions to the elements of the list and put the results in a list instead
01:09:19 <mjrosenb> Schoening: and there are types that help you work around it when you /really/ need it
01:09:22 <mjrosenb> e.g.
01:09:24 <Cale> (records of results, perhaps)
01:09:37 <mjrosenb> > [Left 1, Right "a", Left 4]
01:09:39 <lambdabot>  [Left 1,Right "a",Left 4]
01:09:42 <Cale> Since evaluation is lazy, you won't even pay for it
01:09:50 <mjrosenb> :t [Left 1, Right "a", Left 4]
01:09:51 <lambdabot> Num a => [Either a [Char]]
01:10:05 <Cale> Yeah, another option is to invent some type which captures the finite set of possibilities you'd like to consider
01:10:33 <mjrosenb> however, I can count the number of times that I've used Either on one hand.
01:10:44 <Cale> Tagging the values with some data constructors which let you decide which types of things you had when you pull each one out, using pattern matching.
01:11:43 <shachaf> I think the sort of thinking Cale is talking about is one of those ways people keep talking about that Haskell influences your way of thinking even when you're not using it.
01:11:44 <Schoening> I wouldn't have picked Haskell if I thought it was easy for me to understand :p But I would like to write something like a Snake game as a proof of concept once I have learned more of the language
01:11:50 <mjrosenb> and because each tag has an associated type, and you're forced to check the tag, you can't accidentally pull 'a' out of a list, and try to add 3 to it.
01:12:57 <phaazon> is there a way to perform a HTTP request with happstack-server, or should I just use http package?
01:13:23 <Schoening> shachaf: after a night of writing a lot of code I noticed the next morning how I would visualize the conversation in code xD
01:13:40 <shachaf> Huh?
01:14:52 <Schoening> Just because you said the thing about affecting you outside of using haskell. I actually started thinking in code irl lol
01:15:13 <mjrosenb> Schoening: I would personally not recommend an interactive game as an early learining excercise.
01:15:37 <mjrosenb> Schoening: I think he meant while programming in other languages, like c++.
01:15:50 <Schoening> Yeah I know. haha
01:15:59 <mjrosenb> and javascript (it has closures!)
01:16:09 <Schoening> What would you recommend as an early learning exercise?
01:16:56 <Schoening> Yeah I love JS. Not using closures that much tho. JS code is getting optimized to be more C++ like
01:17:31 <Schoening> But yeah. What should I code in Haskell as an exersise
01:17:47 <mjrosenb> Schoening: project euler is popular :-p
01:18:15 <mjrosenb> Schoening: otherwise, I'd say a small stdin/stdout based utility
01:18:48 <Schoening> You are not the boss of me! :p
01:18:58 <mjrosenb> 'comma' is one of my favorites.
01:18:59 <mjrosenb> echo "there are 12345 dogs" | comma
01:19:00 <mjrosenb> there are 12,345 dogs
01:19:53 <olliey> Schoening: https://www.youtube.com/watch?v=mtvoOIsN-GU&list=UUVCCGFoU86v3NaP9OBBb_Qw
01:20:15 <mjrosenb> Schoening: and i thought implementing tsort was a /ton/ of fun.
01:20:34 <olliey> I have been following this guy, making a simple console game
01:21:22 <Schoening> neat. I give it a watch after learning some more syntax.
01:23:11 <Schoening> mjrosenb: Haskell sounds like its most fun for the math enthusiast. I'm not really a math enthusiast. Its more of a struggle hehe
01:24:10 <phaazon> @hoogle Text.Regex.Posix
01:24:12 <lambdabot> Text.Regex.Posix module Text.Regex.Posix
01:24:12 <lambdabot> package posix-acl
01:24:12 <lambdabot> package posix-escape
01:24:51 <ph88> hi guys
01:27:15 <Cale> Schoening: Yeah, it's by no means required, but there's a lot of mathematics which can give you new appreciation for the way things are done in Haskell.
01:29:56 <Schoening> Yeah and I do want to learn it. So that I can write my own path-finding library for instance.
01:29:57 <mjrosenb> Cale: haskell is also just really nice for expressing mathematical concepts
01:30:11 <mjrosenb> Cale: like tsort.  tsort is /beautiful/ in haskell.
01:32:44 <phaazon> @hoogle dropAround
01:32:46 <lambdabot> Data.Text dropAround :: (Char -> Bool) -> Text -> Text
01:32:46 <lambdabot> Data.Text.Lazy dropAround :: (Char -> Bool) -> Text -> Text
01:34:04 <ph88> how can i rename a Double to a specific name to make it clear what this Double is used for =
01:34:10 <ph88> ?
01:34:26 <adamse> ph88: newtype Something = Something Double
01:34:30 <mjrosenb> ph88: pi = 3.14159
01:34:42 <ph88> what's Something ?
01:34:50 <adamse> whatever you want
01:35:00 <ph88> ah the new name
01:35:02 <adamse> newtype Velocity = Velocity Double
01:35:02 <mjrosenb> ph88: oh wait, rename a particular value, or give the whole type a new name.
01:35:11 <ph88> but why do i have to do that twice ?
01:35:19 <ph88> why not newtype Something = Double
01:35:31 <adamse> newtype Velocity = Vel Double
01:35:34 <ph88> mjrosenb: no value
01:35:37 <mjrosenb> ph88: one is the name of the type, the other is the constructor used to make sure you don't use it where you aren't supposed to.
01:35:42 <adamse> that's not how newtypes work
01:36:03 <ph88> so    newtype Amplitude = a Double   is ok ?
01:36:04 <adamse> you can have `type Velocity = Double`
01:36:17 <adamse> ph88: if a is written A
01:36:57 <mjrosenb> ph88: so there is a double constant that you want to have a special name, so you don't just have this random, ugly constant floating around?
01:38:21 <ph88> it's not a constant ... it will have a random value at runtime
01:38:21 * hackagebot time 1.5 - A time library  http://hackage.haskell.org/package/time-1.5 (AshleyYakeley)
01:38:29 <ph88> but it's to make my code more expressive of what is what
01:39:07 <mjrosenb> ph88: I fear for "random value at runtime", but that is just a variable, you declare it like any other variable
01:39:11 <iXeno> could someone give me some hints on how you would apply liftM to lift a function for a monad like e.g. Maybe?
01:39:30 <mjrosenb> pi = 3.14158; phi = 1.618; two = 2
01:39:32 <ph88> fst (randomR (0 :: Double, 1) g)
01:40:03 <mjrosenb> :t randomR
01:40:05 <lambdabot> (Random a, RandomGen g) => (a, a) -> g -> (a, g)
01:40:09 <adamse> ph88: are you looking to distinguish your constant or whatever by a type or by name (what mjrosenb is suggesting)
01:40:25 <hyPiRion> iXeno: you 'import Control.Monad (liftM)' and then use e.g 'liftM (+2)' ?
01:41:07 <ph88> adamse: i think by type ..
01:41:16 <iXeno> hyPiRion:  No instance for (Monad m0) arising from a use of `liftM'
01:41:22 <hyPiRion> > liftM (+2) $ Just 2
01:41:23 <lambdabot>  Just 4
01:42:47 <hyPiRion> > let f = liftM ("warning: "++) in [f (Just "fire"), f Nothing]
01:42:49 <lambdabot>  [Just "warning: fire",Nothing]
01:42:55 <adamse> ph88: `type Amplitude = Double` introduces a type synonym, while `newtype Amplitude = A Double` introduces a new type
01:43:10 <adamse> you want one of them i believe
01:43:22 <iXeno> hyPiRion: ok, but how do I declare a maybePlus2 without directly calling it? appending :: Maybe Integer didn't help
01:43:27 <hyPiRion> iXeno: could you provide the contex you're using it on?
01:43:32 <ph88> hhmm actually i'm not sure if naming the types differently really helps with the clarity of it
01:43:46 <ph88> also i don't like to make lenghty variable names, i prefer the 1 letter variables
01:44:01 <ph88> maybe there is a comment style so that i can describe which 1 letter variable is what
01:44:19 <adamse> or you could just use longer variable names?
01:44:44 <iXeno> hyPiRion: I guess I could make a type declaration - which I guess is prettier
01:45:07 <adamse> my haskell style uses 1 letter names for stuff that is obvious what it is, and longer names for things that need more clarification
01:45:22 <phaazon> given a regex, is it possible to throw away constants?
01:45:23 <phaazon> for instance
01:45:30 <phaazon> "<title>.*</title>"
01:45:32 <phaazon> I just want the .*
01:45:33 <adamse> one letter names are mostly in pattern bindings...
01:45:45 <phaazon> I’m using parsec (between) to remove the <title>s
01:45:48 <hyPiRion> iXeno: Right, if you want to declare maybePlus2, then it'd be like this I guess:
01:45:50 <phaazon> but it’s a bit overkill…
01:45:59 <hyPiRion> maybePlus2 :: Maybe Integer -> Maybe Integer
01:46:07 <hyPiRion> maybePlus2 = liftM (+2)
01:46:15 <phaazon> is there some kind of regex syntax to remove that?
01:46:22 <phaazon> IIRC, it’s possible in perl
01:46:26 <phaazon> with buffers
01:46:28 <phaazon> like \1
01:46:31 <phaazon> or that kind of stuff
01:46:40 <hyPiRion> but it could also be any other kind of monad if you wanted it to
01:50:32 <ph88> in a generator like [x | x <- [1..5]]   how can i make Double so that i don't have to use fromIntegral()  ?
01:51:15 <mjrosenb> > [x*x | x <- [1..5]] :: Double
01:51:17 <lambdabot>  Couldn't match expected type ‘GHC.Types.Double’
01:51:17 <lambdabot>              with actual type ‘[t0]’
01:51:29 <hyPiRion> > [x | x <- [1..5] :: [Double]]
01:51:30 <lambdabot>  [1.0,2.0,3.0,4.0,5.0]
01:51:33 <mjrosenb> > [x*x | x <- [1..5]] :: [Double]
01:51:35 <lambdabot>  [1.0,4.0,9.0,16.0,25.0]
01:51:36 * mjrosenb whistles
01:51:46 <hyPiRion> yeah, that also works
01:51:53 <phaazon> > [x :: Double | x <- [1..5]
01:51:55 <lambdabot>  <hint>:1:27:
01:51:55 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
01:51:59 <phaazon> > [x :: Double | x <- [1..5]]
01:52:01 <lambdabot>  [1.0,2.0,3.0,4.0,5.0]
01:52:17 <phaazon> which requires ScopedTypeVariables
01:52:28 <ph88> good stuff guys, thanks !
01:52:42 <mjrosenb> ph88: with the right extensions, you can put ::Double /basically/ anywhere.
01:52:58 <mjrosenb> phaazon: I forget, is there a reason that was left out of the language initially?
01:53:24 * hackagebot language-java 0.2.7 - Manipulating Java source: abstract syntax, lexer, parser, and pretty-printer  http://hackage.haskell.org/package/language-java-0.2.7 (VincentHanquez)
01:53:26 <phaazon> a reason that was left?
01:53:48 <edlinde> would I be right in thinking that in fmap.. the “f” can be thought of as the box, and fmap will never change the shape of the box, but only apply the function (a->b) to elements within the box?
01:53:50 <mjrosenb> phaazon: ScopedTypeVariables.
01:53:52 <edlinde> is that right?
01:54:09 <phaazon> mjrosenb: because it can change meanings of programs I guess
01:54:17 <mjrosenb> edlinde: that is the way I think about it.
01:54:35 <edlinde> mjrosenb: ok cool then I might be on teh right track
01:54:35 <edlinde> :)
01:54:47 <phaazon> edlinde: that’s actually how you should see fmap
01:55:00 <phaazon> it’s a lifting operation
01:55:08 <phaazon> that lifts the functio a -> b into your box
01:55:13 <phaazon> function*
01:55:22 <phaazon> once you understood lifting
01:55:35 <phaazon> you understand fmap, liftM, liftA, liftA2, liftM4, <*> and so on :)
01:55:39 <ph88> mjrosenb: do you know how i can get the type signature of a function ?
01:55:41 <edlinde> ok
01:56:00 <phaazon> ph88: how?
01:56:05 <phaazon> at runtime?
01:56:07 <mjrosenb> ph88: hoogle, lambdabot, or ghci, depending on what exactly it is.
01:56:14 <adamse> ph88: prefix the function with :t in GHCI
01:56:20 <ph88> i use  runhaskell   to run my file
01:56:21 <phaazon> :t catMaybes
01:56:23 <lambdabot> [Maybe a] -> [a]
01:56:23 <adamse> or check hoogle
01:56:54 <phaazon> no one here using regex-posix?
01:57:04 <jle`> edlinde: i'd be a bit careful with that, because not all Functor instances are boxes in any meaningful sense
01:57:04 <ph88> maybe i should load the file into ghci and then after i can do  :t
01:57:32 <mjrosenb> ph88: debug with ghci first, it is so much nicer than runhaskell
01:57:39 <phaazon> ph88: sure
01:57:42 * mjrosenb is not sure how anyone debugs anything without a repl.
01:57:43 <phaazon> :l yourfile.hs
01:57:46 <phaazon> :t theFunction
01:57:47 <lambdabot> Not in scope: ‘theFunction’
01:57:47 <ph88> i'm not experienced with loading files into ghci
01:57:52 <phaazon> ahah lambdabot
01:57:52 <jle`> edlinde: a safer way to rephrase the content of what you wrote is, "if my type represents a box, then fmap will apply the function to the elements in my box without changing the shape"
01:57:59 <phaazon>  :l, ph88
01:58:02 <phaazon> that simple :)
01:58:10 <mjrosenb> ph88: you can also say ghci yourfile.hs
01:58:24 <mjrosenb> then :reload
01:58:36 <jle`> edlinde: this avoids the trouble you'll eventually run into later on when you encounter Functors that don't represent boxes :)
01:58:41 <ph88> what will the development cycle be like ?  i just reload the file again with :l  ?
01:59:13 <jle`> ph88: there's a cheap way too, you can annotate your function with a type signature you know is wrong, and ghc will complain and tell you want it expects
01:59:17 <jle`> foo :: Int
01:59:30 <jle`> i am guilty of that sometimes >_____>
01:59:33 <edlinde> jle`: I didn’t quite get the difference
01:59:40 <edlinde> is it not the same as what I said?
01:59:41 <ph88> ok so i loaded the file:   Ok, modules loaded: Main.
01:59:44 <ph88> now how to run ?
01:59:52 <jle`> edlinde: in the way you say it, it sounds like Functors represent the idea of boxes
02:00:01 <edlinde> hm
02:00:12 <jle`> so when you look at fmap :: (a -> b) -> f a -> f b, can you say that the f represents a box?
02:00:19 <jle`> well, yes, but only when the actual type represents a box :P
02:00:24 <jle`> what about for f's that aren't boxes?
02:00:28 <phaazon> 10:57 < jle`> ph88: there's a cheap way too, you can annotate your function  with a type signature you know is wrong, and ghc will complain  and tell you want it expects
02:00:31 <phaazon> omg :D
02:00:48 <edlinde> are there examples of when f is not a box and we can still use fmap on it?
02:00:54 <phaazon> jle`: I reckon « box » was used as an image here
02:01:02 <phaazon> not the common “boxing”-oriented box
02:01:06 <ph88> so how to invoke the main function and run the file ?
02:01:09 <edlinde> I have mostly seen it used for [], IO, Tree etc
02:01:20 <phaazon> ph88: call main in ghci
02:01:24 <phaazon> ghci runs in IO
02:01:28 <jle`> he said "elements within the box", so it kind of sounds like the box image represents something that contains things
02:01:29 <ph88> cool cool
02:01:40 <jle`> well, IO doesn't really contain anything inside it
02:01:42 <edlinde> or let me just believe its boxes for now and then later on I can get deeper into it
02:01:43 <edlinde> :)
02:01:45 <phaazon> yeah well
02:01:47 <phaazon> Maybe a then
02:01:55 <phaazon> it doesn’t always contain anything
02:01:58 <jle`> edlinde: well, i did provide a safe way of looking at it that won't get you in trouble later :)
02:02:03 <ph88> what's the advantage to debug in chgi instead of runhaskell ?
02:02:08 <edlinde> ok
02:02:09 <jle`> (->) a, or (a ->), doesn't contain anything :)
02:02:10 <phaazon> the functor is Maybe, not Maybe a btw
02:02:10 <edlinde> get you
02:02:19 <phaazon> ph88: much simpler
02:02:26 <jle`> :t fmap show (*2)
02:02:27 <lambdabot> (Show a, Num a) => a -> String
02:02:49 <jle`> > (fmap show (*2)) 8
02:02:51 <lambdabot>  "16"
02:03:00 <phaazon> yeah
02:03:00 <killy9999> hm... what's the computational complexity of scanr?
02:03:07 <phaazon> for functions, fmap just composes
02:03:11 <ph88> phaazon: sorry i'm not getting it ... right now i have to do 2 steps:   :reload  and main  ... before it was just one command: runhaskell
02:03:23 <jle`> Const literally doesn't contain *anything* of the type being mapped over :P
02:03:29 <phaazon> ph88: ghci is used for unit testing in general
02:03:35 <jle`> > getConst $ fmap (*2) (Const "hi")
02:03:37 <lambdabot>  "hi"
02:03:37 <phaazon> I test my whole program with cabal run
02:03:46 <jle`> there's literally no numeric value inside the Const
02:03:59 <phaazon> > fmap undefined Nothing
02:04:00 <lambdabot>  Nothing
02:04:01 <tdammers> I test my whole program by compiling it
02:04:04 <phaazon> same thing here :)
02:04:09 <ph88> i'm writing a test right now ... but it's just a program that will call a function on the main program and verify the output of that function ... i didn't use any framework to make the test
02:04:13 <jle`> at this point, you can say "well...it's kind of like a box...if i stretch the meaning of the word 'box' until it no longer resembles a real world box..."
02:04:19 <jle`> heh
02:04:45 <edlinde> Also.. in LYAH its written as : instance Functor ((->) r) where  fmap f g = (\x -> f (g x)) . Can I rewrite this as : instance Functor ((->) r) where  fmap f g = f.g ?
02:04:57 <edlinde> since its a function composition anyway right?
02:04:59 <jle`> but i think it's just easier to say "for f's that are boxes, fmap behaves this way.  for f's that are like X, fmap behaves Y...etc., for every different f"
02:05:02 <jle`> edlinde: mhm :)
02:05:11 <jle`> also, you might be able to spot an easy eta reduction
02:05:11 <edlinde> or you are not allowed to do it when making an instance?
02:05:14 <jle`> if you squint hard enough
02:05:17 <tdammers> seriously though, IMO a true unit test is simply about asserting certain properties of a type - but then, that's also what a type system is for
02:05:33 <jle`> s/squint/look
02:05:37 <ph88> i need to plot a bunch of graph (i have the points) does anyone know a good package i can use ?
02:05:46 <tdammers> simulation tests, however...
02:05:51 <edlinde> whats an eta reduction? :)
02:05:54 <jle`> edlinde: remember ""referential transparency"" --- anything can be replaced with its definition
02:06:10 <jle`> so the definition of (.) is (f . g) = \x -> f (g x)
02:06:15 <edlinde> ok so all you are saying is that what I wrote is correct yeah? :)
02:06:24 <jle`> so fmap f g = f . g is "literally" equal to fmap f g = \x -> f (g x)
02:06:33 <edlinde> okie
02:06:54 <jle`> edlinde: yeah, it's correct :)  because they're semantically identical according to haskell
02:07:03 <solarus> given that the definition of (.) isn't fmap :) (it isn't)
02:07:20 <jle`> edlinde: eta reduction is something like... if you have foo x y = bar y, you can just see that foo x = bar
02:07:22 <jle`> right?
02:07:34 <edlinde> yep
02:07:43 <jle`> so fmap f g = (.) f g
02:07:53 <edlinde> right
02:07:53 <jle`> do you see the possible eta reduction?
02:08:10 <edlinde> I can use (.) f?
02:08:14 <jle`> fmap = (.)
02:08:23 <edlinde> ok
02:08:26 <edlinde> gotcha
02:08:29 <jle`> um. yeah this is mostly for fun though
02:08:35 <jle`> it really makes no difference
02:08:47 <jle`> but writing fmap = (.) sort of "paints a more vivid picture" than fmap f g = f . g
02:08:48 <edlinde> some things just look cleaner
02:08:58 <jle`> it's saying "hey look, fmap is literally identical to function composition"
02:09:09 <edlinde> true
02:09:09 <jle`> because fmap literally equals (.)
02:09:18 <jle`> but, it's personal taste at that point
02:09:28 <edlinde> I agree :)
02:09:34 <edlinde> it looks cleaner and is more meaningful
02:11:25 <jle`> :)
02:11:52 <tdammers> so many aliases for fmap...
02:12:08 <edlinde> few sentences later he writes the same in LYAH too :)
02:12:40 <tdammers> :t (<$>)
02:12:41 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:12:45 <tdammers> :t liftM
02:12:46 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
02:12:51 <tdammers> :t liftA
02:12:52 <lambdabot> Applicative f => (a -> b) -> f a -> f b
02:13:03 <jle`> :t rmap
02:13:04 <lambdabot> Profunctor p => (b -> c) -> p a b -> p a c
02:13:42 <jle`> although not all Functors are profunctors
02:13:49 <jle`> now (.)...that's a function that has a hundred names
02:14:09 <tdammers> : t (.)... -- just kidding
02:14:18 <jle`> :P
02:14:20 <darkf> I'm trying to compile a simple program using EitherT but GHC insists there is no MonadTrans (EitherT String) instance for `lift`, though there should be, shouldn't there? http://lpaste.net/110831
02:14:41 <jle`> (.), fmap, (<$>), liftM, liftA, rmap, (<<<), (<<^), (^<<) ...
02:14:54 <jle`> ok maybe not a hundred
02:15:08 <tdammers> but seriously, the point is that each of these signals a slightly different intent
02:15:14 <jle`> mhm
02:16:03 <tdammers> (.) means we're thinking about the operands as functions; fmap says we're interested in the functor; liftM says we're concerned about a monad stack, etc.
02:16:48 <Cale> s/stack//
02:17:40 <shachaf> That's why I have liftMaybe to signal that I'm concerned with Maybe, and liftIntToCharMaybe to signal that I want the type (Int -> Char) -> Maybe Int -> Maybe Char
02:19:57 <jle`> ya i can't live without my liftList
02:20:07 <jle`> i can't remember what i always call it though
02:20:15 <darkf> this is strange because the either package defines `instance MonadTrans (EitherT e)` :/
02:20:35 <jle`> darkf: i didn't even realize that transformers had an EitherT
02:20:51 <jle`> i thought transformers/mtl used MonadError stuff like that
02:21:05 <jle`> and ErrorT
02:21:09 <darkf> jle`: EitherT is from the either package
02:21:42 <jle`> oh yeah i forgot that either shares Control.Monad.Trans with transformers
02:21:49 <darkf> it defines a MonadTrans instance, but GHC is claiming there isn't one when I try to lift something to it
02:21:54 <darkf> I have no idea why
02:22:02 <jle`> i keep on thinking that the Trans means "transformers" the package for some reason...
02:22:18 <jle`> hm.
02:22:23 <MP2E> transformers, monads in disguise
02:22:32 <MP2E> (though not really in disguise)
02:22:38 <jle`> are you sure you have the right version of "either" that matches whereever you are seeing this instance?
02:23:23 <darkf> jle`: yep -- I have 4.3.1, which is where I see it in https://hackage.haskell.org/package/either-4.3.1/src/src/Control/Monad/Trans/Either.hs
02:23:29 <darkf> (and is also the latest version)
02:23:32 <ph88> why am i getting these failures while installing plot ?  http://pastebin.com/dh9CCrZ0
02:27:58 <darkf> hrm
02:28:18 <darkf> if I copy and paste the MonadTrans instance into my code it works. but clearly it defines it in the library... what is going _on_?
02:29:47 <edlinde> just a stupid qn maybe:  In fmap.. when reading “f a” should I thinkk of it as a Functor f that has one argument of type a?
02:30:11 <edlinde> just trying to get it accurate now
02:30:13 <edlinde> :)
02:31:19 <edlinde> anyone?
02:32:11 <mroman_> @type fmap
02:32:12 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:32:22 <mroman_> f is a Functior that takes something of type a
02:32:27 <mroman_> i.e
02:32:31 <mroman_> > fmap (succ) (Just 5)
02:32:31 <edlinde> ok so I got it right then
02:32:32 <lambdabot>  Just 6
02:33:04 <mroman_> > fmap (succ) [8]
02:33:05 <lambdabot>  [9]
02:33:25 <edlinde> I am trying to understand lifting. So here lifting is a function that takes a function (a->b) and returns a (f a -> f b)?
02:33:34 <ph88> how to fix this problem with cabal?  Module     `Distribution.Simple.Configure'     does not export     `configCompilerEx'
02:33:37 <bernalex> edlinde: I tend to think of it as 'a' which is a 'f'. but whatever floats your boat.
02:33:53 <Iceland_jack> edlinde: Lifting is not really a formal concept but yes that's basically it
02:33:54 <edlinde> so its returning a function that takes a functor of type a and returns a functor of type b?
02:33:57 <mroman_> edlinde: jop
02:34:11 <bernalex> edlinde: fmap "promotes" a function (a->b) to work on f a instead of a, and return f b instead of b.
02:34:11 <jle`> hm
02:34:18 <Iceland_jack> That's why many people add extra parentheses to make that explicit
02:34:19 <Iceland_jack>     fmap :: (a -> b) -> (f a -> f b)
02:34:23 <ph88> how can i check the current version of my haskell platform ?
02:34:39 <jle`> you can thin"f a" as "a applied to f"
02:34:45 <edlinde> ok
02:35:06 <edlinde> a applied to f?
02:35:06 <jle`> *you can think of
02:35:09 <jle`> darn ssh lag
02:35:12 <mroman_> and <$ replace the value in a functor
02:35:19 <bernalex> edlinde: so we typically say that it "lifts" the function from being a mere (a -> b) to being able to work on a higher kinded thing like Functor.
02:35:25 <mroman_> > 0 <$ [1..10]
02:35:26 <lambdabot>  [0,0,0,0,0,0,0,0,0,0]
02:35:30 <edlinde> I see
02:35:34 <edlinde> get your point
02:35:37 <jle`> like how Just 5 is Just applied to 5.  f a is a (the type) applied to f (the Functor)
02:35:43 <Iceland_jack> > () <$ Just 10 -- doesn't have to have same type
02:35:59 <jle`> all Functors take just one "fully applied" type
02:36:03 <edlinde> is “<$” the lifting symbol?
02:36:09 <edlinde> the infix notation of it?
02:36:11 <Iceland_jack> edlinde: no
02:36:15 <edlinde> ok
02:36:24 <Iceland_jack> if you mean fmap, then that's (<$>)
02:36:25 <bernalex> <$ is just a function a -> f b -> f a
02:36:27 <lambdabot>  Just ()
02:36:32 <tdammers> informal intuition: lift turns a "pure" function into a monadic/functored/wrapped/... function
02:36:32 <Iceland_jack> @src (<$>)
02:36:33 <lambdabot> f <$> a = fmap f a
02:36:37 <jle`> x <$ y = fmap (const x) y
02:36:48 <bernalex> heh
02:37:02 <bernalex> edlinde: oh you're confused about <$>? that's literally just fmap infix
02:37:09 <bernalex> we use it because we like to be concise
02:37:18 <edlinde> no its not that
02:37:20 <Iceland_jack> I think edlinde got confused about introducing (<$) which isn't really that relevant
02:37:30 <edlinde> this one : 0 <$ [1..10]
02:37:31 <jle`> yeah, (<$) might not really be helpful at this point to talk about
02:37:33 <jle`> oh well
02:37:42 <bernalex> edlinde: so that takes an a and an f b and returns an f a
02:37:43 <tdammers> bernalex: <$> also happens to produce rather intuitive syntax
02:37:44 <jle`> > (*2) <$> [1..10]
02:37:46 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
02:37:57 <bernalex> edlinde: so you can do
02:37:58 <jle`> > (*2) <$> Just 4
02:37:59 <lambdabot>  Just 8
02:38:01 <edlinde> I understand the <*>
02:38:01 <bernalex> > 25 <$ Just 4
02:38:03 <lambdabot>  Just 25
02:38:05 <tdammers> > reverse <$> Just [1,2,3]
02:38:06 <lambdabot>  Just [3,2,1]
02:38:08 <bernalex> or use a function like jle` did
02:38:15 <bernalex> with <$>
02:38:24 <mroman_> > reverse <$> Nothing
02:38:25 <lambdabot>  Nothing
02:38:32 <edlinde> ah <*> is an applicative yeah?
02:38:37 <Iceland_jack> yes
02:38:41 <jle`> um.  but yeah, you noticed something important when you talked about "f a".  all Functors are things that take one "fully applied" type, and only one.  Maybe Int,  IO Bool.  etc.
02:38:46 <tdammers> > revers [1,2,3] -- looks almost the same
02:38:47 <lambdabot>  Not in scope: ‘revers’
02:38:48 <lambdabot>  Perhaps you meant one of these:
02:38:48 <lambdabot>    ‘reverse’ (imported from Data.List),
02:38:48 <lambdabot>    ‘Seq.reverse’ (imported from Data.Sequence),
02:38:48 <lambdabot>    ‘BSLC.reverse’ (imported from Data.ByteString.Lazy.Char8)
02:38:54 <jle`> this is why Either can't be a Functor
02:38:57 <bernalex> we can do weird things like
02:39:00 <tdammers> > reverse [1,2,3] --, that is
02:39:01 <lambdabot>  [3,2,1]
02:39:04 <bernalex> > "hello, world!" <$ getLine
02:39:05 <lambdabot>  <IO [Char]>
02:39:10 <jle`> tdammers: how about reverse <$> Just [1,2,3] vs. reverse $ [1,2,3] :)
02:39:13 <Iceland_jack> (maybe getting a bit too noisy)
02:39:21 <bernalex> which will get a line, and then give us "hello, world" as an IO [Char]. :-]
02:39:21 <jle`> mk im sleeping now
02:39:31 <tdammers> jle`: even more similar, yeah
02:39:38 <edlinde> thanks all
02:39:46 <mroman_> > Just . reverse . fromJust $(Just [1,2,3])
02:39:48 <lambdabot>  Just [3,2,1]
02:39:53 <mroman_> > Just . reverse . fromJust $(Nothing)
02:39:54 <lambdabot>  Just *Exception: Maybe.fromJust: Nothing
02:40:01 <mroman_> reverse <$> is much safer imo
02:40:26 <bernalex> edlinde: so do you have sort of the intuition that <$> "lifts" a function like let's say (+3) to work on a "higher" type like f a instead of a?
02:40:33 <bernalex> > 3 + 5
02:40:35 <lambdabot>  8
02:40:42 <edlinde> yes
02:40:45 <edlinde> I get that now
02:40:49 <bernalex> > 3 + (Just 5)
02:40:50 <lambdabot>  No instance for (GHC.Show.Show a0)
02:40:50 <lambdabot>    arising from a use of ‘M5890896691512561100885.show_M5890896691512561100885’
02:40:50 <lambdabot>  The type variable ‘a0’ is ambiguous
02:40:50 <lambdabot>  Note: there are several potential instances:
02:40:50 <lambdabot>    instance [safe] GHC.Show.Show
02:40:53 <bernalex> is sadface
02:40:55 <bernalex> so we
02:40:59 <bernalex> > (+3) <$> Just 5
02:41:01 <lambdabot>  Just 8
02:41:06 <bernalex> :-]
02:41:21 <edlinde> I see it that with the functor you can apply a function to a wrapped value
02:41:30 <edlinde> or a value in a box
02:41:48 <bernalex> that's a dangerous simplification that doesn't really hold :-P but you can look at it like that for now I guess
02:41:48 <tdammers> not *quite*, but close
02:42:05 <edlinde> so I guess we can think of lifting as that the function is now able to get to things in a box
02:42:06 <edlinde> :)
02:42:17 <tdammers> (it breaks for things like List that do something other than wrap a single value)
02:42:20 <edlinde> yeah I am just learning the ropes
02:42:33 <edlinde> I said it wrong then
02:42:38 <bernalex> <*> is then kind of the same thing -- but here the function itself is "wrapped", as you say.
02:42:47 <edlinde> but what I meant is that the box can have many slots in it with many values
02:42:48 <bernalex> let's say you want to get two lines of user input, and ++ it
02:42:58 <bernalex> getLine ++ getLine -- not possible
02:43:11 <Iceland_jack> edlinde: It's a fine intuition
02:43:12 <bernalex> but you can do (++) <$> getLine -- to make a function
02:43:13 <edlinde> like I think of a list as one box with many slots to fit in elements… and a tree as a box with many slots/nodes
02:43:37 <bernalex> so now you have a function IO ([Char] -> [Char]), and want to add another getLine to it
02:43:49 <bernalex> (++) <$> getLine <*> getLine -- magic!
02:44:02 <edlinde> ok
02:44:17 <tdammers> (++) <$> ["foo", "bar"] <*> ["baz", "quux"]
02:44:20 <bernalex> your box analogy/intuition is very useful as a beginner :-]
02:44:23 <edlinde> Iceland_jack: thanks for agreeing with my childish intuition :)
02:44:25 <ventonegro> exit
02:44:28 <mroman_> > getProduct . fold . map Product $ 9 <$ [1..10]
02:44:29 <lambdabot>  3486784401
02:44:32 <tdammers> > (++) <$> ["foo", "bar"] <*> ["baz", "quux"]
02:44:32 <edlinde> well I am a beginner :)
02:44:33 <lambdabot>  ["foobaz","fooquux","barbaz","barquux"]
02:44:41 <ventonegro> oops, wrong window
02:44:42 <tdammers> box analogy stretched
02:44:45 <Iceland_jack> Not childish at all, anyone who disagrees may want to have a word with the introduction of Category Theory for Computing Scientists
02:44:50 <mroman_> with my new Foldable, Monoid Fu-Skills I can write even more unreadable code .
02:44:58 <bernalex> Iceland_jack: problem is with IO basically
02:45:09 <mroman_> and Functor-Skills
02:45:15 <bernalex> Iceland_jack: but it holds quite well most of the time
02:45:23 <tdammers> bernalex: I think with a bit of lenience the box analogy can even be stretched to IO values
02:45:40 <edlinde> even after I get the hang of Functors, Applicative and Monads.. I am wondering where I will even use them and when to do so
02:45:41 <edlinde> :)
02:45:43 <tdammers> sort of kind of
02:45:46 <bernalex> tdammers: as long as we don't get into the details of how haskell is pure and that you don't do IO :-P
02:45:57 <bernalex> edlinde: you use functors all the time, don't you?
02:46:03 <bernalex> > map (+2) [0..5]
02:46:04 <lambdabot>  [2,3,4,5,6,7]
02:46:06 <bernalex> that's using a functor!
02:46:10 <bernalex> map = fmap for lists
02:46:21 <bernalex> a list is just a functor -- one of these boxes of yours :-]
02:46:24 <edlinde> so LYAH talks about IO as this “box with little legs” that runs out and gets data from outside world
02:46:25 <edlinde> :)
02:46:38 <tdammers> well, in the case of IO, the box is an imperative program fragment that can produce the desired value when interpreted by the runtime (which is outside of our direct control)
02:47:01 <edlinde> tdammers: so we talking about having side effects when using IO?
02:47:01 <bernalex> yeah that's a crude simplification. but unlike a lot of people, I don't hate these simplifications *that* much. I think they're fine for newbies to get an intuition for things.
02:47:30 <bernalex> edlinde: you can't have side-effects. IO is where all this intuition-business breaks down and everyone starts disagreeing. ;-)
02:47:31 <edlinde> true
02:47:45 <edlinde> ok
02:48:00 <tdammers> people aren't really disagreeing though, they're mostly arguing semantics
02:48:08 <edlinde> I know :)
02:48:30 <nymacro> http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/
02:48:33 <tdammers> the trick, I think, is that fmap doesn't *really* take values out of boxes at all
02:48:34 * hackagebot prove-everywhere-server 0.1 - The server for ProveEverywhere  http://hackage.haskell.org/package/prove-everywhere-server-0.1 (ShoheiYasutake)
02:48:37 <edlinde> it helps me at this stage to remember the intuitions when I am reading LYAH
02:48:42 <bernalex> basically, one commonly accepted-ish way of looking at it, is that when you write haskell, you are writing the source code of a program that constructs an imperative program that has side-effects at runtime. so haskell itself doesn't have side-effects at all, and IO is kind of an embedded language within haskell. it gets hard, heh.
02:48:49 <nymacro> edlinde: If you had enough understanding of Haskell, that paper is pretty handy
02:48:54 <bernalex> edlinde: check out tackling the awkward squad -- it's a useful paper
02:49:16 <edlinde> wondering what after LYAH?
02:49:27 <bernalex> edlinde:  http://research.microsoft.com/en-us/um/people/simonpj/Papers/marktoberdorf/mark.pdf.gz here you'll see SPJ himself making similar simplifications to yours :-]
02:49:28 <edlinde> whether I should look at typeclassopedia or RWH?
02:49:46 <bernalex> edlinde: whatever you do, you'll likely be fine. just remember to *write* a lot of code!
02:49:52 <tdammers> edlinde: I'd say do some real-world projects
02:49:57 <edlinde> ok
02:49:59 <bernalex> edlinde: I made a game after reading LYAH. then moved on to things like RWH.
02:50:14 <bernalex> well, the prototype for a game. about 1500 LOC or something
02:50:16 <tdammers> typeclassopedia is great for looking things up when you're stuck with concepts
02:50:34 <tdammers> rwh is great for answering "how do I do X again" type questions
02:50:42 <bernalex> RWH does get tedious
02:50:51 <bernalex> and it is rather... full of bitrot.
02:51:10 <tdammers> rwh is really nice for people with a bunch of programming experience outside haskell and fp in general
02:51:10 <edlinde> will read that paper after I am done with LYAH
02:51:19 <bernalex> edlinde: https://github.com/bitemyapp/learnhaskell has some cool things, like brent yorgey's excellent course.
02:51:24 <tdammers> and yes, some parts are badly out of date
02:51:25 <edlinde> I do tdammers :)
02:51:30 <Iceland_jack> edlinde: Marlow's book would be an excellent next step
02:51:41 <Iceland_jack> @google parallel and concurrent programming haskell
02:51:42 <lambdabot> http://chimera.labs.oreilly.com/books/1230000000929
02:51:42 <lambdabot> Title: Parallel and Concurrent Programming in Haskell
02:51:55 <bernalex> there's also purely functional data structures
02:52:14 <tdammers> edlinde: in that case, just keep in mind that what RWH does may be antiquated in terms of libraries and programming practices
02:52:15 <edlinde> yeah I would love to learn that
02:52:26 <edlinde> I think I will skip RWH actually
02:52:26 <bernalex> tdammers: and might not even compile :-P
02:52:35 <edlinde> use it as a reference if I get stuck coding
02:52:40 <tdammers> bernalex: that should be a logical consequence, yes :D
02:52:52 <bernalex> edlinde: it has some cool "real world" case studies
02:53:04 <edlinde> ok
02:53:10 <tdammers> exactly. great resource for some examples of Haskell in action
02:53:12 <edlinde> I hear mixed reviews about it
02:53:19 <edlinde> but then some people say they hate LYAH
02:53:23 <bernalex> well... it's of mixed usefulness heh
02:53:35 <bernalex> LYAH was really great when I was a newbie -- I loved it.
02:53:39 <edlinde> I think LYAH is really good to use.. loads of good examples.. some a bit contrived .. but still
02:53:45 <tdammers> I used rwh myself because lyah didn't quite "click" for me
02:53:51 <bernalex> looking back, I cringe at some of the things it says... but then again, I liked it when I didn't know haskell, so it must be doing *something* right. ;-)
02:54:04 <edlinde> true :)
02:54:15 <tdammers> also, the monad tutorial paradox
02:54:16 <bernalex> brent yorgey's course is really really really excelllent though
02:54:22 <bernalex> byorgey in here
02:54:39 <edlinde> this book looks awesome: http://chimera.labs.oreilly.com/books/1230000000929/index.html
02:54:42 <tdammers> "once you understand monads, you can no longer explain them"
02:54:45 <edlinde> hte one you suggested
02:54:46 <bernalex> I've showed it to several people -- and everyone's loved the exercises and had a great time learning haskell.
02:55:39 <bernalex> tdammers: sure you can. it's something that has return & bind. :-P
02:57:00 <tdammers> and how do you explain those?
02:57:10 <tdammers> just the type signatures should be enough, right? :P
02:57:12 <bernalex> give their typesigs of course!
02:57:15 <bernalex> haha you read my mind
02:57:44 <bernalex> http://cdsmith.wordpress.com/2012/04/18/why-do-monads-matter/ I think this is a great intro to monads
03:02:29 <Cale> My first impression is that is a lot of text and not much code
03:02:40 <tdammers> it is
03:02:58 <tdammers> that's because it's explicitly not about the code, but about the concepts
03:02:58 <bernalex> Cale: it's not about how to use them in practice, it's about the intuition for monads and category theory.
03:04:41 <ph88> how can i fix these errors im getting while installing plot?  http://pastebin.com/dh9CCrZ0
03:07:04 <mjrosenb> ph88: This problem can usually be solved by installing the system packages that
03:07:05 <mjrosenb> provide these libraries (you may need the "-dev" versions). If the libraries
03:07:05 <mjrosenb> are already installed but in a non-standard location then you can use the
03:07:36 <mjrosenb> @hoogle a -> [(a,b)] -> [b]
03:07:38 <lambdabot> Language.Haskell.TH.Syntax RecConE :: Name -> [FieldExp] -> Exp
03:07:38 <lambdabot> Language.Haskell.TH RecConE :: Name -> [FieldExp] -> Exp
03:07:38 <lambdabot> Language.Haskell.TH.Syntax RecP :: Name -> [FieldPat] -> Pat
03:07:55 <mjrosenb> @hoogle Eq a => a -> [(a,b)] -> [b]
03:07:56 <lambdabot> Language.Haskell.TH.Syntax RecConE :: Name -> [FieldExp] -> Exp
03:07:56 <lambdabot> Language.Haskell.TH RecConE :: Name -> [FieldExp] -> Exp
03:07:56 <lambdabot> Language.Haskell.TH.Syntax RecP :: Name -> [FieldPat] -> Pat
03:08:02 <mjrosenb> @hoogle Eq a => a -> [(a,b)] -> Maybe b
03:08:02 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
03:08:03 <lambdabot> Data.List lookup :: Eq a => a -> [(a, b)] -> Maybe b
03:08:03 <lambdabot> Language.Haskell.TH.Syntax RecConE :: Name -> [FieldExp] -> Exp
03:08:03 <Cale> The cairo one is probably because the version of cairo that it's trying to install depends on a newer version of the Cabal library.
03:08:11 <mjrosenb> ok, so there isn't a lookups variant.
03:08:39 <ph88> mjrosenb: i only saw that i was missing two packages, but i checked i do have them. Should i use -extra-include-dirs= or --extra-lib-dirs=   ??
03:08:52 <mjrosenb> ph88: do you have the dev versions of them?
03:08:53 <favetelinguis> How can i express this sentence in propositional logic "Exactly one out of Ada Haskell and Bertrand does not like cats"?
03:08:59 <ph88> mjrosenb: no
03:09:07 <mjrosenb> ph88: well, then.
03:09:07 <ph88> i will install them now ^^
03:10:01 <Cale> favetelinguis: Funny choice of channel to ask in, but you'd probably form a large disjunction enumerating the possibilities
03:10:24 <Cale> "large", it only has three terms
03:10:26 <Hafydd> Ada-likes-cats XOR Haskell-likes-cats XOR Bertrand-likes-cats
03:10:46 <Cale> Yeah, I suppose you can use XOR if that's available :)
03:10:53 <favetelinguis> yes but i may not use xor
03:11:08 <doismellburning> why not?
03:11:11 <favetelinguis> i understand how to derive xor with two premisis but not with 3_
03:11:16 <mjrosenb> Hafydd: I don't think that is true.
03:11:22 <Cale> (A /\ -H /\ -B) \/ (-A /\ H /\ -B) \/ (-A /\ -H /\ B)
03:11:25 <doismellburning> favetelinguis: it's associative, so it's fine
03:12:05 <favetelinguis> ok cool thanks
03:12:15 <mjrosenb> Hafydd: either that, or Xor doesn't behave like it does in boolean logic :-p
03:12:22 <Hafydd> Hmm... yes, I am mistaken. (True,True,True) is a counterexample. It would have to be a bit more complicated.
03:13:03 <Hafydd> One could imagine a higher-arity analogue of XOR that fits it, but nobody uses that.
03:13:29 <favetelinguis> how about does not like cats? how does that fit into the above statement
03:14:01 <Cale> favetelinguis: I'm taking A to be "Ada likes cats", so its negation is "Ada does not like cats"
03:14:34 <favetelinguis> aa ok first question in a logic class, hoping to get it by the end :)
03:15:18 <Cale> In first order logic, you might have a relation symbol C(x) for "x likes cats"
03:15:33 <Cale> and then constant symbols for Ada, Haskell, and Bertrand
03:15:48 <Cale> So what I called A above could then become C(Ada)
03:16:17 <Cale> Or you might have a 2-ary relation symbol Likes(x,y), and an additional constant for cats
03:16:22 <ph88> mjrosenb: i typed: sudo apt-get install liblapack-dev libblas-dev     this partially resolved the problem, however there are still errors left: http://pastebin.com/SSLHqNWQ
03:17:41 <Cale> ph88: I think the problem might be which version of the Cabal library you have vs. which one is required to build that version of cairo
03:18:05 <Cale> ph88: It could be that the cairo package is misrepresenting its dependencies
03:19:12 <Cale> ph88: ghc-pkg list Cabal
03:19:18 <Cale> ph88: What version do you have?
03:20:21 <ph88> Cale: Cabal-1.16.0
03:20:55 <Cale> okay, that's several versions back
03:20:59 <ph88> how can i check which version of the haskell-platform i have ?
03:21:22 <Cale> I'm not sure, I don't use the Haskell Platform (I'm on Linux, and just install GHC and then cabal-install)
03:21:56 <ph88> i found this to upgrade all packages, is it safe to perform this action in this way ?  http://stackoverflow.com/a/6905267
03:22:24 <Cale> That would be a scary thing to do
03:22:36 <ph88> ok what can i do to solve this problem ?
03:22:40 <chrismed> Hello. Is it possible to create a HList (from HList package) from an ordinary list? For example: list2HList ['a', "abc"] == 'a' .*. "abc" .*. HNil
03:23:09 <Cale> ph88: Try just  cabal install Cabal-1.20.0.2
03:23:45 <ph88> will it automatically remove the older version ?
03:24:00 <Cale> chrismed: Not really, unless you want to use some sort of existential, because it's not clear from the type of an ordinary list how many elements the list has.
03:24:49 <Cale> ph88: No, it'll install the new version in your local package conf
03:25:38 <chrismed> Cale: thank you
03:25:43 <Cale> On my machine, I have both Cabal-1.18.1.3 installed globally, and Cabal-1.20.0.0 installed locally
03:26:17 <Cale> chrismed: Oh, also your list has a type error in it
03:33:35 <int-index> What is my best option for a parser, if I don't care about speed but want I do want good error reporting and write as little as possible code?
03:34:30 <Cale> int-index: Probably Parsec
03:35:10 <ph88> Cale: the cabel install has finished installing the new version of cabal. When trying to install plot i still get errors http://pastebin.com/49XXBWVh
03:35:27 <Cale> int-index: With the caveat that I've yet to really try trifecta
03:35:52 <Cale> ph88: hmm
03:35:58 <int-index> Cale, what about uu-parsinglib? It is said to have error recovery too.
03:36:11 <Cale> ph88: What happens if you just cabal install cairo-0.13.0.0 ?
03:37:22 <ph88> Cale: http://pastebin.com/t2cw6jNM
03:38:00 <Cale> int-index: I'm not sure exactly what advantages it has over Parsec, if any.
03:38:15 <Cale> int-index: It looks comparable
03:38:42 <int-index> Cale, is error recovery possible/easy with Parsec?
03:38:48 <ph88> Cale: will you be here in 30-60min? we have a lunch here in 5min  .. thanks for support
03:38:56 <Cale> ph88: Probably
03:39:05 <ph88> :)
03:42:54 <ph88> Cale: what do you think about that last error ?
03:43:34 <Cale> ph88: It indicates that it's still choosing the old Cabal library
03:43:57 <ph88> do you know how i can start using the new Cabal library ?
03:44:07 <Cale> ph88: I'm hoping that if you build cairo on its own, the newer version will be selected
03:44:26 <ph88> how can i build cairo on it's own ?
03:44:30 <Cale> which is why I asked for the result of cabal install cairo-0.13.0.0
03:46:03 <Philonous> can ghci show me the definition of an associated data type?
03:46:26 <Philonous> :i (Foo Bar) doens't seem to work
03:46:32 <Cale> Philonous: It'll probably show the definition of the class if you :i Foo
03:47:14 <Cale> I don't think it usually prints the contents of instances under any circumstances
03:47:42 <Philonous> Cale, that's too bad. Thanks.
03:50:19 <Philonous> Is there a limit to how much --ddump-splices will show? Because it doesn't show up there either
03:50:53 <Philonous> Oh, never mind, it's just haskell mode abbreviating it
03:51:18 <edlinde> what is “pure”?
03:51:26 <bernalex> edlinde: return
03:51:31 <edlinde> I am reading up Applicatives.. not sure what it means
03:51:52 <edlinde> so it says I can replace “Just” with “pure” when using it with <*>
03:51:55 <bernalex> edlinde: return is a -> m a, right? pure is a -> f a where f is Applicative.
03:52:11 <bernalex> edlinde: yep. pure 5 :: Maybe Int
03:52:14 <Cale> edlinde: Generally some computation which has no effect except to produce the given value as its result.
03:52:14 <bernalex> > pure 5 :: Maybe Int
03:52:16 <lambdabot>  Just 5
03:52:20 <bernalex> > return 5 :: Maybe Int
03:52:21 <lambdabot>  Just 5
03:52:38 <Cale> edlinde: Exactly what it will mean to "have no effect" will depend on the particular instance of Applicative
03:53:00 <edlinde> so can I think of it as pure is wrapping something with a box?
03:53:09 <Iceland_jack> edlinde: sure
03:53:11 <edlinde> for now
03:53:11 <edlinde> ok
03:53:23 <Iceland_jack> edlinde: You should think of Applicative in terms of lifting
03:53:32 <bernalex> edlinde: it is the same as return, yes.
03:53:33 <Iceland_jack> Functor allowed you to lift (a -> b) to (f a -> f b)
03:53:48 <bernalex> edlinde: return "injects" your value into a monad, pure into an applicative.
03:54:05 <edlinde> and pure is lifting a to f a
03:54:06 <edlinde> ?
03:54:13 <bernalex> where f is Applicative, yes
03:54:18 <edlinde> right
03:54:19 <Iceland_jack> Applicative allows you to lift
03:54:19 <Iceland_jack>     (a -> b -> c)      to (f a -> f b -> f c)
03:54:19 <Iceland_jack>     (a -> b -> c -> d) to (f a -> f b -> f c -> f d)
03:54:20 <edlinde> ok
03:54:21 <Cale> Even if it usually is an injection, that usage of the word "injects" always seems weird to me
03:54:21 <Iceland_jack> etc.
03:54:27 <hyPiRion> question: is there a way to define this function pointfree? https://www.refheap.com/90050
03:54:48 <bernalex> hyPiRion: *everything* can be defined pointfree
03:55:26 <Cale> hyPiRion: Not profitably
03:55:29 <bernalex> @pl fn x = if pred1 x then foo x else if pred2 x then bar x else quux x
03:55:29 <lambdabot> fn = liftM2 if' pred1 foo `ap` ap (liftM2 if' pred2 bar) quux
03:55:43 <bernalex> there is nothing to gain from making it pointfree.
03:55:53 <hyPiRion> Cale: alright, that's what was I was wondering about
03:56:47 <Cale> edlinde: It's probably best not to think of Applicatives as being types of boxes containing values, better to think of values of type (f t) as being computations which compute values of type t when executed.
03:57:05 <Cale> edlinde: But if your notion of "box" is general enough, it's okay, I suppose
03:57:29 <b_jonas> you mean when (Applicative f) ?
03:57:32 <Cale> yes
03:57:51 <edlinde> yeah my notion of box also allows for functions etc
03:57:53 <Philonous> So, in a nutshell, An Applicative is a box if and only if by box you mean Applicative.
03:58:01 <edlinde> I get what you mean though
03:58:11 <Iceland_jack> Philonous: Intuitions are not meant to be definitional
03:58:13 <edlinde> Philonous: :)
03:58:23 <Cale> edlinde: It's similarly a bit odd to think of /bin/ls as being a box containing a list of files
03:58:25 <Iceland_jack> It's fine for them to be leaky
03:58:56 <bernalex> Philonous: lol
03:59:10 <edlinde> Cale: I know what you mean.. but it just helps to think of it as a box for now
03:59:25 <Philonous> Iceland_jack, Yes, but saying "it's a box if your definition of box is broad enough" is a realy sneaky way of saying "it's not a box"
03:59:39 <Iceland_jack> I know
03:59:47 <Iceland_jack> But nobody said it was one
04:00:06 <Philonous> Iceland_jack, "<Cale> edlinde: But if your notion of "box" is general enough, it's okay, I suppose"
04:00:36 <edlinde> all these debates on semantics do confuse beginners I must say :)
04:00:40 <Iceland_jack> Indeed
04:00:50 <bernalex> edlinde has fairly consistently said that they think about it *like* a box. the "like" should give away...
04:00:52 <Cale> Philonous: You might imagine boxes which have displays in them so as to be able to appear to have different contents :)
04:01:11 <lpaste> aranea pasted “fft code duplication” at http://lpaste.net/110834
04:01:11 <Cale> Philonous: So, it can sort of work
04:01:21 <Iceland_jack> "A set is like a bag of things" is not the same as saying "we define sets to be bags of things"
04:01:37 <b_jonas> do you think a box can contain a continuous self-adjoint linear operator in L^2(C) -> C ?
04:01:38 <Philonous> Cale, It works if you make the right sort of assumptions, but those aren't apparent if you don't already understand what an Applicative is
04:01:48 <bernalex> Iceland_jack: so are you saying a monad isn't literally a burrito? :-]
04:01:49 <aranea> How can I reduce the code duplication in the pastes snippet in a sane way?
04:01:54 <aranea> Or shouldn't I?
04:02:06 <Iceland_jack> bernalex: I want to believe :)
04:02:16 * Iceland_jack is hungry
04:02:26 <b_jonas> so we're back where we started, to understand monads, you first have to understand monads
04:02:45 <Cale> To understand monads, you first have to understand examples of monads.
04:03:11 <Cale> and understanding the examples isn't so bad
04:04:00 <Cale> Of course, you can just write down the definition, but if you don't know any examples which fit that definition, it's hard to claim that you understand it :)
04:04:39 <Iceland_jack> “It is simply not true that everything about a mathematical concept is contained in its definition.”
04:04:50 <hyPiRion> You can probably understand the concept, but not necessarily apply it?
04:04:58 <bernalex> Iceland_jack: I'm hungry too, but I couldn't find an appropriate category theory analogy for what they were serving at the cafeteria today, so I guess I'll go hungry today.
04:04:59 <Cale> Heh, there we go with the container analogies again
04:05:16 <Cale> It is sort of true, if you have the right sort of container :P
04:05:34 <hyPiRion> for a sufficiently broad definition of container
04:06:01 <mjrosenb> for a sufficently broad definition of 'definition'
04:06:21 <hyPiRion> hah
04:06:32 <mjrosenb> *ie
04:11:20 <edlinde> how do I know the priority of <*> and <$>
04:11:20 <edlinde> ?
04:11:26 <Iceland_jack> :info <*>
04:11:31 <edlinde> I am assuming <$> has higher priority
04:11:46 <edlinde> did that it didn’t work in ghci
04:11:51 <edlinde> Top level: Not in scope: `<*>'
04:11:51 <bladyjoker> edlinde:don't they have the same priority?
04:11:59 <bernalex> edlinde: import Control.Applicative
04:12:02 <Iceland_jack> edlinde: well you have to import Control.Applicative
04:12:04 <edlinde> ah
04:12:05 <bernalex> bladyjoker: they do.
04:12:21 <b_jonas> stupid questoin. I forgot the name of that haskell library that has containers, similar to Map and Seq, but also with lots of other variants, such as those that don't presume that keys comparing equal are identical, etc
04:12:27 <b_jonas> what's the name of that library?
04:12:28 <bladyjoker> it's simply a function
04:12:35 <Iceland_jack> If you write
04:12:35 <Iceland_jack>        a <$> b <*> c
04:12:35 <Iceland_jack>     == (a <$> b) <*> c
04:13:13 <edlinde> ok
04:13:22 <edlinde> so its just the order in which we apply the function really
04:13:26 <Iceland_jack> Yes
04:13:31 <edlinde> ok
04:14:10 <b_jonas> found it, it's EdisonAPI
04:14:13 <edlinde> combining <$> and <*> looks super cool ;)
04:15:21 <bernalex> edlinde: (++) <$> getLine <*> getLine is one of my favourite ways to demonstrate the relationship, heh.
04:15:55 <edlinde> hmm
04:16:22 <bernalex> then you can print the whole thing and demonstrate bind at the same time
04:16:30 <bernalex> > putStrLn =<< (++) <$> getLine <*> getLine
04:16:31 <lambdabot>  <IO ()>
04:16:34 <aranea> Ping. (See my paste further up) The only differences between the two functions are the "map" in front and the "conjugate". I'd like to reduce the code duplication, but I'm not sure how.
04:17:09 <edlinde> bernalex: let me get to Monads first :)
04:17:18 <bernalex> edlinde: ah you're not there yet! sorry. :-]
04:17:33 <edlinde> no probs :)
04:17:59 <b_jonas> aranea: where's your paste again? I must have missed it
04:18:41 <mm_freak> hi there
04:18:44 <aranea> b_jonas: http://lpaste.net/110834
04:20:44 <mm_freak> on thursday i'm giving another haskell workshop, and i'm planning to introduce my group to the basics of category theory…  so far i have always used xournal with a pad to draw the diagrams, but i'd prefer to get the nice latexy ones…  is there any way to get fast prototyping on commutative diagrams, while preserving beauty?
04:21:28 <mm_freak> ideally using only a keyboard =)
04:21:32 <b_jonas> aranea: thanks.
04:23:51 <b_jonas> is the Typeclassopedia updated to the changes in the ghc core libraries where Monad is made a really subclass of Applicative?
04:34:01 <b_jonas> @type Endo
04:34:02 <lambdabot> (a -> a) -> Endo a
04:44:13 <aranea> b_jonas: Any ideas?
04:57:24 <b_jonas> aranea: no, sorry, I'm not doing enough haskell right now to be able to write idiomatic code for that. can someone else help?
04:57:48 <steffen> is there a neat way to find out in which file (at least, or better in which file/line) this error occurs?: Prelude.(!!): index too large
04:57:49 <steffen>  
04:58:08 <aranea> b_jonas: Still, thanks for having a look!
05:01:53 <bergmark> steffen: there will be in 7.10
05:02:32 <steffen> bergmark: okay... :) do you know what that will be? will it just tell you in the error message?
05:03:11 <bergmark> i don't have the details, just overheard someone mentioning it
05:04:05 <pjdelport> aranea: The obvious thing is to just make the function a parameter
05:04:26 <bergmark> steffen: is the error in your code? i would advice against using (!!) because it isn't safe
05:04:54 <steffen> b
05:05:34 <steffen> okay, yes it's in the code! what else should I use to get the nth element?
05:07:08 <aranea> pjdelport: Yes, that works for "conjugate" (passing in "id" in the first function. But I still need to take care of the map, and I can't pass that in as a function, because it needs len'.
05:12:37 <hesselink> steffen: there's the 'safe' package, which contains total versions of partial functions like (!!)
05:14:54 <steffen> hesselink: thank you
05:14:54 <hesselink> steffen: You can also use the +RTS -xc flag to get stack traces, see http://stackoverflow.com/questions/25359461/finding-where-loop-happened/25359633#25359633
05:19:22 <lpaste> pjdelport annotated “fft code duplication” with “Factoring out using "inverse" flag” at http://lpaste.net/110834#a110837
05:19:34 <pjdelport> aranea: How about that?
05:19:48 <Guest38996> Hi, I have a quick question. I am comparing 2 functions which should have the same output using Test.QuickCheck, but when I try to compile it, it keeps giving me "Killedts)"
05:19:51 <Guest38996> any idea why?
05:20:04 <killy9999> conal: ping
05:21:09 <pjdelport> @lpaste
05:21:09 <lambdabot> Haskell pastebin: http://lpaste.net/
05:21:15 <aranea> pjdelport: That looks good!
05:21:15 <pjdelport> Guest38996: Paste your code there?
05:22:41 <pjdelport> aranea: If benchmarking shows that that version is any noticeably slower than the direct version, you can probably avoid the overhead of the flag with some appropriate inlining incantations.
05:24:02 <Guest38996> pjdelport: http://www.cse.chalmers.se/edu/course/TDA555/lab1.html I'm basically writing assignment 2 and 3 and comparing the two versions. I will try to paste it, but I'm using Mosh to code at the moment, and C&P seems to be beyond me
05:24:27 <killy9999> conal: nvm, I've sent you an email
05:24:35 <aranea> pjdelport: I'll try. The code is in no shape to be benchmarked, though.
05:24:47 <pjdelport> aranea: Yeah, it's probably not a worry then. :)
05:24:51 <aranea> I haven't applied any optimisations yet.
05:25:32 <pjdelport> Guest38996: What's your QuickCheck test look like, i mean?
05:25:54 <Marlene22>  Hi! I give you some videos. I hope you like! http://tinyurl.com/ozfvxy3
05:26:04 <aranea> pjdelport: And I'm doing this mostly for understanding FFT anyway. There are enough libraries around. But I'm interested if your change will make it slower, so I'll check.
05:26:27 <mm_freak> aranea: btw, i don't think this is /F/FT, but rather simply /D/FT
05:26:37 <pjdelport> aranea: It probably won't make any measurable difference for that version, given the over head of lists.
05:27:01 <pjdelport> aranea: That was just my premature optimization reflex kicking in.
05:27:32 <Guest38996> pjdelport: http://lpaste.net/110838#a110838
05:29:33 <pjdelport> Guest38996: Shouldn't that be == instead of === ?
05:30:13 <aranea> mm_freak: It's a naive Cooley-Tukey FFT. You haven't seen the rest of the code.
05:30:15 <aranea> ;)
05:30:16 <pjdelport> Hmm, no, nevermind.
05:30:29 <mm_freak> ah, ok
05:30:37 <pjdelport> Guest38996: You say that happens when you compile?
05:30:50 <pjdelport> Guest38996: Can you reduce it to a minimal code snippet and paste that?
05:31:11 <pjdelport> (That is, along with the definitions of power and power2.)
05:31:56 <Guest38996> pjdelport: I stick runghc filename.hs and that comes out. Until yesterday, I couldn't get Test.QuickCheck to run at all -- I updated cabal etc. and it seems to work now.
05:33:44 <qz_> is it possible to use IO in ST monad?
05:34:31 <Hafydd> qz_: no.
05:34:59 <Guest38996> pjdelport: thanks for your help. I decided to give it one last shot, and it seems to run now. perhaps it's just my wonky internet connecting to my server
05:35:05 <Hafydd> Unless you use ST as a monad transformer, or something.
05:36:15 <qz_> Hafydd: sad. so i'd have to use IORefs and friends i suppose?
05:36:44 <b_jonas> > fail :: Maybe Integer
05:36:46 <lambdabot>  Couldn't match expected type ‘Data.Maybe.Maybe
05:36:46 <lambdabot>                                  GHC.Integer.Type.Integer’
05:36:46 <lambdabot>              with actual type ‘GHC.Base.String -> m0 a0’
05:37:11 <b_jonas> > fail "ohai" :: Maybe Integer
05:37:13 <lambdabot>  Nothing
05:37:28 <nshepperd> hmm
05:37:28 <aranea> qz_: Imho that should be possible, but let me check.
05:37:40 <pjdelport> qz_: The parts that depend on non-ST IO stuff needs to be in IO, but it's good idea to keep as much as possible just in ST, if you can.
05:38:04 <nshepperd> is it possible to add strictness annotations to a type defined using record syntax?
05:38:14 <pjdelport> qz_: So you'd embed the ST computation in the larger IO computation.
05:39:18 <nshepperd> oh, never mind, I tried Constructor { foo :: !Double } and it worked this time
05:39:36 <qz_> pjdelport: but what if i need to do a bit of IO inside large ST computation?
05:39:51 <qz_> like write something to log. and yes, Debug.Trace is not enough
05:40:07 <pjdelport> qz_: Well, everything that depends on the IO action will have to be an IO action itself.
05:40:37 <b_jonas> > mempty :: Maybe Integer
05:40:38 <lambdabot>  No instance for (Data.Monoid.Monoid GHC.Integer.Type.Integer)
05:40:38 <lambdabot>    arising from a use of ‘Data.Monoid.mempty’
05:40:51 <pjdelport> qz_: Are you sure you need to do the IO inside the actual ST computation? What about having the ST computation record a log as a value, and then writing that in IO at the end?
05:41:25 <tdammers> > mzero :: Maybe Integer -- b_jonas: did you mean this?
05:41:26 <lambdabot>  Nothing
05:41:44 <qz_> pjdelport: but then it would not be progress meter (if it gets written at the end)
05:41:59 <pjdelport> qz_: Then it must be in IO, yeah.
05:42:19 <qz_> i see, thanks
05:42:56 <b_jonas> tdammers: I'm not sure
05:43:00 <pjdelport> qz_: What you can try is to break your ST computation into smaller parts that are pure ST, and having a loop in IO that runs the ST actions and prints progress as and where necessary.
05:43:34 <tdammers> :info Maybe
05:43:47 <tdammers> oh wait, this ain't ghci
05:43:56 <qz_> pjdelport: or maybe use unsafePerformIO...
05:44:14 <pjdelport> qz_: Only if you want your program not to work. :P
05:44:29 <qz_> pjdelport: how so? last time i used it everything worked well..
05:44:45 <tdammers> qz_: until it doesn't
05:45:10 <tdammers> qz_: one of the problems with unsafePerformIO is that it makes a promise it can't possibly keep
05:45:13 <pjdelport> qz_: unsafePerformIO is prone to biting you in very hard-to-understand ways. It might seem to work, but actually not be working.
05:45:55 <pjdelport> qz_: For logging, the most obvious thing that might happen is that your logging actions may be duplicated in surprising ways, or skipped altogether.
05:46:08 <qz_> oh, i see..
05:46:23 <pjdelport> qz_: And you're not going to easily find out that that has happened by reading the logs. :P
05:46:52 <tdammers> unsafePerformIO is generally safe-ish if your action is practically pure
05:47:04 <pjdelport> qz_: Oh, and they might happen out of order, too, aside from being duplicated or skipped.
05:47:39 <pjdelport> qz_: Basically, the whole point of unsafePerformIO is throwing away all the safety and consistency guarantees that IO gives you.
05:47:51 * tdammers nods
05:48:22 <tdammers> and the only sane reason to do that is because you can get the same guarantees from outside Haskell
05:49:38 <pjdelport> Right, or with things like trace (which is essentially unsafePerformIO), where you know you don't care.
05:49:56 <TheKing44> Where is cabal install when I install haskell platform?
05:50:07 <TheKing44> On vista (shudder)
05:50:59 <tdammers> pjdelport: my take on trace is that you do care, but in exactly the "right" way
05:51:34 <tdammers> trace allows you to side-chain your code so you get to see the evaluation order, kind of
05:51:46 <pjdelport> Yeah.
05:52:24 <Kron> I used to use unsafePerformIO back when I was learning haskell precisely to enumerate that lazy evaluation order
05:52:35 <pjdelport> trace is when you *want* the order to be implementation-defined. :)
05:52:50 <Kron> seeing the 'true' evaluation style of that classic quicksort program was certainly an revelatory moment for me
05:52:58 <TheKing44> Where is cabal install when I install haskell platform? It is not bin.
05:55:03 <bergey> TheKing44: Mine is in /Program Files/Haskell Platform/2013.2.0.0/lib/extralibs/bin/cabal
05:55:22 <bergey> (Windows 7, but I assume it's the same on Vista)
05:56:16 <TheKing44> bergey thx
05:59:51 <trap_exit> haskellers - anonymous // for people who spend too much time in haskell and unable to program in other languages
06:00:25 <Kron> //? more like --
06:00:56 <trap_exit> Kron: welcome to haskellersAnonymous
06:01:48 <Kron> lol. Funnily enough, there's a little toy program / game design I wanna poke at and I've been furiously arguing with myself for a week, telling myself that haskell is clearly NOT the best foundation to work with...
06:01:53 <Kron> I give up
06:01:59 <Kron> haskell all day every day ;_;
06:02:02 <Kron> I can stop whenever I want, honest
06:02:18 <trap_exit> Kron: you're right, Haskell is not the ideal langauge for your game.
06:02:26 <trap_exit> Kron: clearly you should wrtie a Haskell EDSL for expressingyour game
06:02:30 <Kron> lol
06:02:46 <Kron> you joke, but I was working on a chess variant engine in haskell last december
06:03:05 <tdammers> the first rule of Haskell Club is that you do not talk about Haskell club; you just return a pure IO action which, when interpreted by the runtime, will talk about Haskell Club
06:03:15 <tdammers> :P
06:03:17 <TheKing44> cabal.exe: The program ghc version >=6.4 is required but it could not be found
06:03:19 <Kron> and then I realized that I could represent chess pieces using the old notation on chessvariants.org and this could be represented by an atomic chess piece combinator algebra
06:03:22 <doismellburning> Kron: hah I've still yet to finish my chess engine port
06:03:27 <doismellburning> Kron: ...cripes
06:03:31 <Kron> start with video game, end up in combinator algebra :: brain on haskell
06:03:35 <TheKing44> But I checked the version, and it is 7.8
06:03:47 <TheKing44> how do I update cabal-install?
06:03:54 <trap_exit> cabal intall cabal
06:03:58 <trap_exit> or cabal install cabal-install
06:04:01 <trap_exit> I forgot whch
06:04:20 <Eben> the latter I think
06:04:21 <tdammers> cabal install cabal-install
06:04:22 <TheKing44> trap_exit: I got the error: "cabal.exe: The program ghc version >=6.4 is required but it could not be found"
06:04:34 <trap_exit> cabal insatll ghc
06:04:38 <trap_exit> wait
06:04:43 <trap_exit> if you're using older than 6.4
06:04:48 <trap_exit> why not just download haskell platform?
06:04:50 <trap_exit> it's 7.8.4
06:04:54 <trap_exit> what are you doing with a pre 6.4 system ?
06:04:57 <redwire> Is there an NLTK binding for Haskell, or perhaps an easy way to create one?
06:05:12 <trap_exit> TheKing44: whoever you paid to insall haskell for you -=- get your money back
06:05:13 <Twey> edwardk: So using machines, I have a data type  data Sum ∷ [★] → ★ → ★ where Zero ∷ Sum '[] Void; Plus ∷ Sum xs sum → Sum (x ': xs) (Either x sum)  that I'd like to use as a sort of generalized Wye.  This means that if I have a  Machine (Sum [Char, Int]) a  then I can't use await, even though there's only one proof term, since my Sum isn't a Category?
06:05:16 <TheKing44> trap_exit I do have haskell platform
06:05:29 <trap_exit> TheKing44: you clarely do not have latest
06:05:33 <TheKing44> It just isn't finding it.
06:05:54 <TheKing44> I am not admin, should I do portable instillation trap_exit?
06:07:15 <trap_exit> I would just download latest haskell platform
06:07:16 <trap_exit> try to install it
06:07:23 <trap_exit> and report back to #haskell if you get into an error
06:09:05 * hackagebot hxt-charproperties 9.2.0.0 - Character properties and classes for XML and Unicode  http://hackage.haskell.org/package/hxt-charproperties-9.2.0.0 (UweSchmidt)
06:09:47 <TheKing44> > unsafePerformIO (L.putStrLn "Also trap_exit, I am no noob.")
06:09:49 <lambdabot>  "Also trap_exit, I am no noob."
06:10:09 <TheKing44> XD
06:10:13 <TheKing44> Oh yes
06:10:15 <trap_exit> TheKing44: I apologize if anything I said implied that.
06:10:32 <TheKing44> oh that is okay
06:10:43 <TheKing44> I just thought that would be cool.
06:11:08 <TheKing44> I can run ghci 7.8.3, but it is not in path.
06:11:17 <TheKing44> 'cause I am a regular user
06:11:28 <trap_exit> > unsafePerformIO (L.putStrLn "Long live TheKing44.")
06:11:30 <lambdabot>  "Long live TheKing44."
06:12:22 <TheKing44> (I redefined unsafePerformIO and putStrLn to id both.)
06:13:01 <trap_exit> TheKing44: you run LambdaBot ?
06:13:27 <TheKing44> no, there is a @define comand
06:13:42 <TheKing44> @define undefined = "Oh rly?"
06:13:44 <lambdabot>  Defined.
06:14:13 <TheKing44> > undefined
06:14:15 <lambdabot>  Ambiguous occurrence ‘undefined’
06:14:17 <lambdabot>  It could refer to either ‘L.undefined’, defined at L.hs:155:1
06:14:19 <lambdabot>                        or ‘GHC.Err.undefined’,
06:14:21 <lambdabot>                           imported from ‘Prelude’ at L.hs:39:8
06:14:23 <lambdabot>                           (and originally defined in ‘base:GHC.Err’)
06:14:27 <aranea> > L.undefined
06:14:28 <lambdabot>  "Oh rly?"
06:15:06 <trap_exit> oh man, this can be fun to confuse newbs with :-)
06:15:12 <Kron> > let o = (.) in (o.o) (*2) (+) 1 1
06:15:13 <lambdabot>  4
06:15:29 <Kron> I need more excuses to use the (o.o) operator
06:15:50 <trap_exit> > let f x = f (x-1) in f 0
06:15:55 <lambdabot>  mueval-core: Time limit exceeded
06:17:56 <fizbin> Kron: Why? Are you 12?
06:18:18 <aranea> > fix ("Spam":)
06:18:19 <lambdabot>  ["Spam","Spam","Spam","Spam","Spam","Spam","Spam","Spam","Spam","Spam","Spam...
06:18:22 <Kron> I am indeed!
06:18:26 <Kron> (I'm not)
06:18:33 <trap_exit> Kron: where are your parents? why ar eyou on IRC?
06:18:37 <Kron> growing old is mandatory, growing up is optional
06:18:43 <Kron> god, get off my case, MOM
06:19:02 <Kron> seriously though it's extra funny to me because of a friend of mine who loves the o.o emoticon
06:19:08 <Kron> she was the person who taught me haskell to begin with
06:19:09 <trap_exit> Kron: if you keep this up, we're going to make you program in PHP again
06:19:27 <Kron> !!! I'll be good
06:19:36 <trap_exit> Kron: if a girl teaches you haskell, the only correct resposne is to marry her
06:19:47 <Kron> I'm a girl too
06:19:50 <Kron> oh snap?
06:20:16 <trap_exit> make a youtube video
06:20:16 <trap_exit> two girls one ghc
06:20:30 <fizbin> True, I guess most people who want to be offensive with that operator don't rename . to o, and just write (.) where you have "o".
06:20:53 <Kron> I normally use (.:)
06:20:58 <Kron> from Data.Combinator
06:21:02 <fizbin> :t flip.flip
06:21:03 <lambdabot> (b -> a -> c) -> b -> a -> c
06:21:16 <fizbin> :t flip.flip.flip.flip
06:21:17 <lambdabot> (b -> a -> c) -> b -> a -> c
06:21:37 <fizbin> :t fmap fmap
06:21:38 <lambdabot> (Functor f1, Functor f) => f (a -> b) -> f (f1 a -> f1 b)
06:23:21 <trap_exit> Kron: do you use haskell at work?
06:23:49 <Kron> sadly, no. At least, not yet
06:24:30 <trap_exit> I get to use Haskell at work.
06:24:38 <Kron> may ending up using idris before I end up using haskell
06:24:39 <trap_exit> In fact, I get to _only_ use Haskell. :-)
06:24:50 <jkarni> :t let x = (.) ; o = (.) in x o x o x
06:24:51 <lambdabot> (b1 -> c) -> (b -> b1) -> (a -> b) -> a -> c
06:25:11 <trap_exit> Kron: how so?
06:25:22 <trap_exit> Kron: do you work in aviation / nuclear facilities, where correctness = mandatory ?
06:25:26 <Kron> I'm a researcher who my professor hired because I know math and type theory
06:25:26 <fizbin> trap_exit: Lucky. I get to write a tiny thing in haskell, so long as it isn't critical and doesn't need careful review.
06:26:15 <Kron> been fiddling with communication protocol representations using algebraic data types / dependent types, and possible quickcheck nonsense to generate smtp implementations on the fly
06:26:16 <Kron> ish
06:26:17 <Kron> stuff
06:26:22 <trap_exit> Kron: oh, so by 'work' you mean "grad student doing research in type theory"
06:26:43 <Kron> in practice I've been doing more game theory on malware software
06:26:55 <fizbin> Hey, getting paid out of a research grant is as legit as getting paid out of VC money.
06:27:02 <trap_exit> Kron: have you published any papers ?
06:27:04 <fizbin> The paycheck spends the same...
06:27:07 <Kron> look, if you want to start a fight: you win
06:27:18 <Kron> I don't care to prove myself to you
06:27:26 <trap_exit> me?
06:27:33 <trap_exit> I was just curious about yoru work in haskell
06:27:39 <trap_exit> I apologize if I sounded offensive.
06:28:22 <Kron> "Oh /I/ get to use haskell at work, and you don't, and your work barely counts as work anyway" isn't offensive?
06:28:26 <fizbin> :t fmap (fmap join) (flip fmap)
06:28:27 <lambdabot> (Functor f, Monad f) => f a1 -> (a1 -> f a) -> f a
06:28:34 <fizbin> :t (>>=)
06:28:35 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:28:41 <trap_exit> Kron: oh, I'm also a grad student (but I guess you did not know that)
06:28:52 <trap_exit> and criticisms of grad research was meant ot be self-condescending tongue in cheek
06:29:19 <fizbin> :t (fmap (fmap join) (flip fmap)) `asTypeOf` (>>=)
06:29:20 <lambdabot> (Functor f, Monad f) => f a1 -> (a1 -> f a) -> f a
06:29:23 <Kron> I'm undergrad
06:29:42 <trap_exit> Kron: if my attempt at humor offended you, I apologize
06:30:26 <Kron> alright
06:30:28 <Kron> sorry
06:30:39 <Kron> next time, fewer "two girls one cup" jokes, please
06:30:40 <trap_exit> Kron: are we square, or should I go write some monad transformers as penance? :-)
06:31:01 <Kron> sure, whatever
06:31:10 <trap_exit> that was poor taste; I will never make that joke again
06:32:06 <fizbin> I never really got the point of (.:)
06:32:11 <Desheng> :t asTypeOf
06:32:12 <lambdabot> a -> a -> a
06:32:23 <Desheng> @src asTypeOf
06:32:23 <lambdabot> asTypeOf = const
06:32:42 <Desheng> well there
06:32:48 <Kron> it's just a small extension to (.)
06:32:49 <fizbin> Desheng: `asTypeOf` is used as a way to witness/prove that the expression on the left has the same type as the expression on the right.
06:32:56 <Kron> Similar use cases, for a different set of functions
06:32:57 <bladyjoker> trap_exit:legendary...don't stop!
06:33:20 <fizbin> Kron: Right, I see that, but...
06:33:25 <fizbin> :t (.:)
06:33:26 <lambdabot>     Not in scope: ‘.:’
06:33:26 <lambdabot>     Perhaps you meant one of these:
06:33:26 <lambdabot>       ‘.’ (imported from Data.Function),
06:34:29 <Kron> http://hackage.haskell.org/package/composition-1.0.1.0/docs/Data-Composition.html
06:34:39 <Kron> sorry, may have said Data.Combinator earlier, I meant Data.Composition
06:35:07 <fizbin> Ah, ok. The only Data.Combinator package I could find was something dealing with the SKI calculus.
06:35:28 <Kron> my bad
06:35:39 <Kron> it's just (.:) = (.).(.)
06:35:47 <Desheng> oh, because the expression would fail at the point of type checking due to not meeting the restriction of a -> a -> a ?
06:36:00 <Kron>  tmap :: Eq b => (a -> b) -> QuadTree a -> QuadTree b tmap = fuseTree .: fmap
06:36:04 <t7> anyone do web stuff in haskell? what templating do you use?
06:36:04 <Kron> err
06:36:06 <fizbin> Desheng: yes.
06:36:12 <Kron> tmap = fuseTree .: fmap
06:36:14 <trap_exit> t7: I just use haste / ghcjs
06:36:15 <Desheng> thank you for explaining
06:36:28 <fizbin> Oh, so (.:) is the solution for "dammit, why is it that when I want to combine f and g and g has two arguments I have to do (f .) . g "
06:36:30 <trap_exit> t7: yesod has some crazy template haskell template stuff, but I never understood it
06:36:53 <Kron> yes
06:37:10 <fizbin> Okay, that makes sense.
06:37:14 <Kron> f .: g x y = f (g x y)
06:37:16 <Kron> pseudocode
06:37:25 <Kron> that's not a legit definition, but you get the idea
06:37:57 <fizbin> I see @pl spitting out stuff of the form ((f .) . g) all the time, so I guess a combinator to do that makes sense.
06:38:01 <redwire> No NLTK for Haskell?
06:38:10 <Desheng> wow that's awesome!
06:38:12 <Kron> it's just more readable to me
06:38:42 <Kron> I hate complex ((.).).(.)... jiggery pokery
06:38:47 <trap_exit> what's the tldr ?
06:38:53 <Kron> that's hilarious for haskell golf, not great for code
06:38:55 <trap_exit> something  interesting happene,d but I don't understand it
06:39:54 <fizbin> t7: I've only done tiny web services in haskell, and those all used JSON in and out, so no templating for me... (snap-core and snap-server, though, are quite useful)
06:41:11 <sm> t7: there's a stack overflow answer listing template engines
06:41:25 <fizbin> t7: as trap_exit said, many people in the haskell world like Yesod's templates, which you can get an overview of here: http://www.yesodweb.com/book/shakespearean-templates
06:41:56 <wz1000> When using monad transformers, how do you figure out which one goes on top?
06:42:12 <trap_exit> fizbin: I acknolwedge yesod's templates, I do not claim to like them. :-)
06:42:44 <fizbin> wz1000: The general rule is that the last transformer to apply is the innermost thing of the datatype.
06:42:56 <trap_exit> Kron: if you're still around, I want to understand the progression of how I came off as ofeensive (to make sure this doesn't happen again)
06:43:07 <krgn> there is also https://hackage.haskell.org/package/heist
06:43:20 <Kron> I'll take it to a private chat then
06:43:21 <trap_exit> Kron: so the three things that were bad were (1) two girls one ghc 'joke', (2) bragging I got to use haskell, and (3) saying research work != real work ?
06:43:29 <tdammers> one issue with yesod templates imo is that they aren't compatible with a web designer workflow
06:43:37 <Kron> ... yeah, pretty much I guess
06:43:44 <tdammers> I prefer templates that are "mostly valid HTML" myself
06:44:10 * hackagebot hpc-coveralls 0.6.0 - Coveralls.io support for Haskell.  http://hackage.haskell.org/package/hpc-coveralls-0.6.0 (killy971)
06:44:11 <t7> im gonna use scotty
06:44:21 <t7> for web framework
06:44:42 <tdammers> in that case, you're free to pick whatever template language you like best :D
06:44:57 <sm> http://hackage.haskell.org/package/StrappedTemplates is the newest and looks quite powerful
06:45:39 <wz1000> fizbin: I read somewhere that IO is always at the bottom of the stack. Why is that?
06:46:20 <c_wraith> wz1000: IO is always at the bottom *if* it is present.
06:46:31 <c_wraith> wz1000: and that's because here is no IO transformer.
06:46:48 <tdammers> (among other reasons)
06:47:19 <wz1000> Why is there no IO transformer? What will prevent me from writing one?
06:47:40 <bennofs> wz1000: try it
06:48:55 <c_wraith> wz1000: mostly the issue is that it requires non-linear manipulation of time - branching and looping time would be required.
06:48:56 <bennofs> wz1000: but consider what would happen if you had IOT [] Int for example
06:51:30 <c_wraith> wz1000: still, if you manage to invent time travel, an IOT transformer would be handy.
06:53:11 <tdammers> closely related to the RealWorld model of doing I/O in a functional language, right?
06:54:28 <b_jonas> is that also why we don't have an ST transformer either? or is ST already a transformer?
06:56:20 <vanila> b_jonas, STT ? http://hackage.haskell.org/package/STMonadTrans-0.2/docs/Control-Monad-ST-Trans.html
06:58:46 <nshepperd> if you set s = RealWorld, m = [] in StateT s m a, then the box specializes to StateT { runStateT :: RealWorld -> [(a, RealWorld)] }
06:58:51 <bennofs> does cabal have support for cross-compilation?
06:59:23 <nshepperd> which would appear to imply a program that can split reality into a bunch of different possibilities
07:01:34 <Phillemann> If I want to wait for user input (via Haskeline, for example) and start a web server and synchronize data between the two, what are the proper APIs/keywords/concepts for that?
07:02:32 <Phillemann> There seems to be forkIO for forking, but what's recommended to synchronize?
07:03:26 <c_wraith> Phillemann: MVar is the primary building block, but there are a ton of other options.
07:03:40 <c_wraith> Phillemann: Check out things in Control.Concurrent
07:04:10 <Phillemann> Ok.
07:04:34 <c_wraith> Phillemann: also, Data.IORef as a mutable cell (mostly without synchronization properties)
07:05:40 <fizbin> The Data.IORef docs though warn that if you need more than a single small cell for synchronization you really should go use an MVar.
07:08:15 <c_wraith> yes.  IORef is better for an unsynchronized cell, which is still valuable for things like checking current application state (if you don't mind reading the old value for a little while)
07:08:55 <ph88> Cale: are you here? this is the result of   cabal install cairo-0.13.0.0   http://pastebin.com/t2cw6jNM
07:22:19 <exio4> @pl \a -> f [a, b]
07:22:19 <lambdabot> f . (: [b])
07:27:14 <vlopez> hi! i'm toying with octal literals, and I get this behaviour:
07:27:32 <vlopez> > 0o567
07:27:34 <lambdabot>  375
07:27:43 <vlopez> > 0o5678
07:27:45 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> t))
07:27:45 <lambdabot>    arising from the ambiguity check for ‘e_105678’
07:27:45 <lambdabot>  from the context (GHC.Num.Num (a -> t), GHC.Num.Num a)
07:27:45 <lambdabot>    bound by the inferred type for ‘e_105678’:
07:27:45 <lambdabot>               (GHC.Num.Num (a -> t), GHC.Num.Num a) => t
07:28:32 <vlopez> the error message is a bit cryptic
07:29:22 <vlopez> oops! i'll ask in ghc instead
07:30:29 <trap_exit> (I think this is a repeat question) -- is there a chanenl here dedicated to cloud/distributed haskell, or is ther ejust #haskell?
07:30:50 <trap_exit> i'm particularly fasicnated by things like : (1) Haste.App (2) cloud ahskell -- where you write _one program_ but using moands, you tag what runs on what machine
07:31:00 <trap_exit> so it's like "one program, multiple machine" + Monads tags which computationa goes where
07:32:00 <pjdelport> trap_exit: I think there's #haskell-distributed
07:32:58 <trap_exit> pjdelport: hmm, < 20 people -- but yes, that looks like what I want; thanks!
07:39:21 <sgronblo> Why is Applicative's apply not <$> like normal function application is $ ?
07:39:40 <tdammers> :t apply
07:39:41 <lambdabot> Not in scope: ‘apply’
07:39:46 <tdammers> :x
07:39:46 <bennofs> :t (<$>)
07:39:47 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:40:04 <Cale> ph88: In that case, try  cabal install --constraint=Cabal==1.20.0.2 cairo-0.13.0.0
07:40:32 <Cale> ph88: We want it to build with the new Cabal library which defines configCompilerEx
07:40:53 <Cale> sgronblo: What?
07:41:08 <Cale> sgronblo: <$> is another name for fmap
07:41:31 <Hafydd> sgronblo: are you asking why <*> is not named <$> instead?
07:42:19 <pjdelport> sgronblo: Idris uses <$> for what Haskell's Applicative calls <*>, for what it's worth.
07:43:02 <sgronblo> Hafydd: thats correct
07:43:19 <Hafydd> It would make sense.
07:43:25 <sgronblo> pjdelport: ah, so im not the only who feels it is a bit odd
07:43:38 <pjdelport> sgronblo: Yeah; the choice is a it arbitrary, at the end of the day.
07:43:39 <Hafydd> What would you call <$>, then?
07:44:32 <prophile> Hafydd: fmap? :)
07:44:43 <Hafydd> I don't want to write `fmap` all the time.
07:44:59 <Phillemann> Is using "show" from basic-prelude the preferred method for converting a number to a Text?
07:45:00 <prophile> how about . then
07:45:12 <Hafydd> <.>?
07:45:15 <prophile> no, .
07:45:20 <prophile> as in (.)
07:45:25 <Hafydd> Okay, then what would you call .?
07:45:29 <prophile> (.)
07:45:37 <prophile> the current (.) is a special case of fmap for the reader monad
07:45:37 <Hafydd> What would you call (.)?
07:45:45 <Hafydd> Oh...
07:45:56 <prophile> s/reader monad/reader functor/ I guess
07:46:35 <Hafydd> Maybe that would work, but it seems a bit odd.
07:47:07 <Hafydd> I don't know if the sense of (.) in (r ->) generalises well to other functors.
07:47:22 <prophile> no, and the generalisation of (.) in Control.Category makes more sense
07:48:13 <sgronblo> isnt fmap fewer keystrokes?
07:48:31 <prophile> `fmap` if you're using it infix
07:49:01 <sgronblo> ah yeah, then you lose the code golf contest
07:49:04 <hyPiRion> <$>
07:49:35 <Hafydd> f `fmap` fx <*> fy <*> fz
07:49:40 <Hafydd> fmap f fx <*> fy <*> fz
07:49:53 <Hafydd> None really compare to f <$> fx <*> fy <*> fz in beauty.
07:50:26 <triliyn> I think pure f <*> fx <*> fy <*> fz is underrated in terms of beauty
07:50:45 <Hafydd> Oh, yeah, there is that.
07:51:24 <prophile> liftA3 f works :)
07:51:38 <Kron> I wish there was a neater form for that
07:51:53 <Intolerable> isnt there an applicative quasiquoter?
07:52:00 <b_jonas> Intolerable: you mean like do notation?
07:52:01 <Kron> some sort of list formulation or at least more readable operators (subjective, I know)
07:52:06 <bergmark> i still want (<$<) f = (fmap f .) but i can't convince people :-(
07:52:43 <triliyn> You might be able to use the typeclass trick to get n-ary liftA
07:52:50 <Intolerable> [i| f x1 x2] = pure f <*> x1 <*> x2
07:53:03 <Intolerable> [i| f x1 x2|] even
07:53:10 <Intolerable> th is overkill but it looks nice
07:53:13 <triliyn> or yeah, idiom brackets are nice
07:53:31 <triliyn> I didn't know there was a quasiquoter for that but it's not surprising I guess
07:53:34 <zwer> a bit of syntax clumsiness in here. this does not work: `xxs@~(x:xs)'  this does: `xxs@ ~(x:xs)'
07:54:12 <triliyn> Probably the same thing that stops [-10..-20] from working
07:54:30 <b_jonas> zwer: would !xss@(x:xs) do the same?
07:54:32 <b_jonas> um
07:54:37 <b_jonas> I mean, would !xss@(x:xs) do the same?
07:54:38 <triliyn> > let (@~) = (++) in "hey " @~ "there"
07:54:39 <lambdabot>  "hey there"
07:54:40 <b_jonas> no wait
07:54:40 <b_jonas> argh
07:54:46 <b_jonas> would ~xss@(x:xs) do the same?
07:54:50 <b_jonas> why can't I type the tilde?
07:55:09 <zwer> b_jonas no, pattern match fails
07:55:43 <triliyn> ~xss@(x:xs) marks the "xss" pattern as irrefutable
07:55:48 <triliyn> But it already matches anything
07:57:02 <pjdelport> > let f xxs@(~(x:xs)) = 5 in f []
07:57:03 <lambdabot>  5
07:57:19 <heiz> Hello,   I'm trying to define function with following signature   (RandomGen rg) => (g ->Rand rg g) -> StateT g (Rand rg) Int   But got error that Rand rg need 1 more argument.   I dont want use RandT rg Identity. I hope there is some extension that would make it compile correctly.
08:04:22 <bergmark> heiz: what's Rand?
08:05:14 <MagneticDuck> has anybody here used Haste?
08:05:17 <MagneticDuck> haste-compiler I mean
08:06:19 <bergmark> heiz: oh, MonadRandom. Why are you using `Rand rg g` in one place and `Rand rg` in the other?
08:07:15 <MagneticDuck> okay, new question: how do I get cabal to use a specific .cabal file?
08:07:56 <Cale> MagneticDuck: Be in the directory in which that .cabal project resides.
08:08:15 <MagneticDuck> but I want two .cabal files :>
08:08:20 <MagneticDuck> one for haste-inst and one for cabal
08:08:24 <MagneticDuck> because <reasons involving haste>
08:08:40 <MagneticDuck> is there a way? there are other solutions of course
08:08:41 <nomeata> I’m confused. What is the difference between Data.Generics and GHC.Generics?
08:08:55 <nomeata> Do I need both? Which of them do I need? And where is "everywhere" for GHC.Generics?
08:09:41 <dcoutts_> nomeata: data.generics is syb
08:09:57 <dcoutts_> and ghc.generics is a different system entirely
08:10:34 <Cale> nomeata: GHC.Generics is the new system which if I recall correctly was originally developed as part of Data Parallel Haskell
08:10:38 <nomeata> ok. and is it normal that I need to use both in one module?
08:11:10 <nomeata> (where "need" means "I find myself needing a feature that I only find one one, and another feature that I only find in the other")
08:11:35 <dcoutts_> nomeata: I'd say not, only if you were combining things from two other packages that used those systems
08:11:43 <MagneticDuck> Cale: any idea?
08:12:08 <MagneticDuck> or I'll just add some file-switching magic to my makefile
08:12:11 <dcoutts_> MagneticDuck: depends what you're trying to do. It's easy enough to do: cabal install ./this ./that
08:12:11 <nomeata> So if GHC.Generics is new and faster, who do I traversals akin to syb’s "everywhere"?
08:12:56 <dcoutts_> MagneticDuck: and the other approach is to make a sandbox and add-source both packages, so you'll get automatic rebuilds of the source deps
08:13:10 <dcoutts_> nomeata: I'd check the ghc generics paper
08:13:12 <MagneticDuck> dcoutts_: same source files, different .cabal file
08:13:22 <Cale> nomeata: I have no idea if GHC.Generics is faster, it's just different.
08:13:31 <MagneticDuck> one import haste-compiler and the other haste-lib
08:13:41 <nomeata> ok, thanks so far!
08:13:53 <Cale> http://hackage.haskell.org/package/generic-deriving-1.6.3/docs/Generics-Deriving-Uniplate.html hmm
08:13:54 <dcoutts_> MagneticDuck: I'd probably combine them into one .cabal file then with multiple components
08:14:31 <MagneticDuck> oh
08:15:00 * MagneticDuck thinks
08:15:08 <MagneticDuck> haste-inst is an alias.. but I'm not sure what it does x|
08:15:11 <dcoutts_> MagneticDuck: or you make one cleanly depend on the other, not sharing source files
08:15:20 <Cale> nomeata: I think you want transform
08:15:23 <dcoutts_> and e.g. put them in different dirs in a project repo
08:16:02 <MagneticDuck> I'm not exactly sure how to configure a cabal library so it emulates haste-inst
08:16:31 <nomeata> oh wow, syb (with autoderiving Data and Typeable) makes my compilation noticably slower
08:23:01 <Algebr> For haskellers that use emacs, help make emacs.stackexchange a reality,  http://tinyurl.com/qzgz56h
08:23:53 <monochrom> unfortunately I am not a stackexchanger.
08:24:55 <katsh> felixsch: hey breh. you own my old domain name ^_^
08:27:15 <Algebr> monochrom: you could be in like 5 seconds. Would be nice to have its own stackexchange instead of questions being scattered over superuser/programmers/stackoverflow
08:27:38 <monochrom> I decline.
08:29:44 <mm_freak> it's like google…  people have trouble with the concept that you don't use stackoverflow/… *at all*
08:36:00 <osfameron> wait, what.  you don't use *google*?
08:36:14 * osfameron occasionally sees things on stackexchange via google
08:36:56 <Guest1254> matheus
08:37:10 <mths> e aí gay
08:37:16 <mths> tá pegando então
08:37:16 <Guest1254> ah viadao
08:37:17 <Guest1254> kkk
08:37:20 <Guest1254> tsa
08:37:25 <mths> vamos parar de falar aqui porque se nao o pessoal xinga.
08:37:26 <mths> kkkkkkkk
08:37:31 <Guest1254> ok
08:37:31 <Guest1254> kk
08:39:17 <MagneticDuck> :D
08:42:59 <ph88> hey guys, im trying to do  cabal install cairo-0.13.0.0    but im getting this error     http://pastebin.com/t2cw6jNM
08:44:29 * hackagebot fpco-api 1.1.1.4 - Simple interface to the FP Complete IDE API.  http://hackage.haskell.org/package/fpco-api-1.1.1.4 (MichaelSnoyman)
08:47:21 <MasterMastic> Hey people. Anyone active?
08:47:34 <Rembane> MasterMastic: Yes
08:47:59 <MasterMastic> How are you Rem?
08:48:34 <Rembane> MasterMastic: Fantastic! :) Can we do something to help you?
08:49:11 <MasterMastic> Aye, I've been pondering over some questions and had some hope to get assistance ;) may I?
08:54:21 <mgaut72> MasterMastic: whats up?
08:56:42 <MasterMastic> I've been wondering if there's a good book or papers for designing ADTs. Perhaps are you aware of any?
08:57:53 <pjdelport> MasterMastic: ADTs as in "algebraic" or "abstract" ?
08:58:40 <MasterMastic> Abstract
08:59:11 <pjdelport> MasterMastic: Can you narrow that question down a bit?
09:00:18 <pjdelport> Most good programming books will probably cover that as part of things.
09:00:18 <MasterMastic> Sure. I've been wondering on principles on how to design data structs generally, how to determine if my type should be a monad, etc.
09:00:49 <pjdelport> Ah; maybe a good book on type theory, for that kind of thing?
09:00:49 <hexagoxel> @tell ph88 it is not friendly to ask question and then leave
09:00:49 <lambdabot> Consider it noted.
09:01:12 <monochrom> no, not type theory
09:01:53 <MasterMastic> I (more often than I'd like) run into situations when I'm just puzzled on what would be the pure way to express this or that notion and on harder subjects my brain turns into pastry, delicately put XD
09:02:25 <MasterMastic> It's a subject that seems to be overlooked quite a bit
09:02:36 <pjdelport> MasterMastic: Probably the only thing to do in that case is just to gradually gain familiarity and intuition of the common algebraic abstractions like functors, monads, monoids, and so on.
09:03:06 <pjdelport> After a while you should start recognizing when something works like a monoid, or whatever the case may be.
09:04:27 <MasterMastic> I'm familiar with all of them except: what are the characteristic to determine what should be a monad.
09:04:31 <mgaut72> Someone pointed me to this paper last night: http://strictlypositive.org/IdiomLite.pdf
09:04:31 <mgaut72> I have yet to read it, but from what I gather, its the story of how Applicatives got derived.  It seems like your programming along, realize you have been doing something structurally similiar a lot, then abstract
09:04:33 <monochrom> abstract data type design is a case of abstraction design, aka API design.
09:04:36 <c_wraith> MasterMastic: a type either is or isn't a monad.  A better question is whether the monad instance is useful.
09:05:53 <c_wraith> MasterMastic: for instance, Data.Proxy's Proxy type is a monad.  Just..  Not usefully.
09:06:08 <MasterMastic> Aye, I mean when I should attempt to make my type a monad.. I mean, there's surely a story behind monads rather than binding and returning semantics, right? (It's not like "I can hook it to the monad API & laws, hence I should make it a monad", is it).
09:06:47 <c_wraith> Nope.  If it can implement the monad operations in obeyance of the laws, it's a monad.  That's all it means.
09:06:53 <pjdelport> MasterMastic: The best way to intuitively determine that IMHO is to start from Functor, then work your way up through Applicative and Monad.
09:07:21 <Maerten> Hi, i'm getting this error on a fresh haskell-platform 2014 install on Ubuntu14.04: /usr/bin/ld: /home/build/.cabal/lib/x86_64-linux-ghc-7.8.3/mysql-0.1.1.6/libHSmysql-0.1.1.6.a(mysql_signals.o): undefined reference to symbol 'pthread_sigmask@@GLIBC_2.2.5'
09:07:22 <pjdelport> MasterMastic: First figure out what it means for your type to be a Functor, then what it means for it to be an Applicative, and then what it means for it to be a Monad.
09:07:55 <Maerten> Any suggestions would be appreciated! (FYI, i'm using mariadb-server 10.1 instead of standard mysql not sure if it matters)
09:08:19 <pjdelport> MasterMastic: Remember that Functor gives you fmap, Applicative gives you pure and <*>, and Monad gives you join (in the form of bind, but join is all that's actually unique to Monad)
09:08:58 <pjdelport> MasterMastic: So if you figure out what exactly those operations mean for your type, then you can see how it falls on the Functor-Applicative-Monad axis
09:10:11 <pjdelport> MasterMastic: And if it doesn't neatly fit into those abstractions, remember that there are a lot of related ones! Contravariant functors, bifunctors, profunctors, comonads... they're not nearly as scary as they might sound at first. Just take them one at a time.
09:10:23 <MasterMastic> Oh wow hearing it being said like that is so brilliant! :) thank you, friends. I'll play with this right away!
09:10:31 <edwardk> pjdelport++
09:11:16 <edwardk> MasterMastic: "(It's not like "I can hook it to the monad API & laws, hence I should make it a monad", is it)" -- it is precisely that ;)
09:11:26 <MasterMastic> Hehe they are not? they sure do sound scary, so much that I haven't heard of them. I'll give them a look though.
09:11:27 <pjdelport> MasterMastic: Also, regarding "It's not like 'I can hook it to the monad API & laws, hence I should make it a monad', is it", that's pretty much the case. :)
09:11:37 <edwardk> Monad is just a pattern we see over and over and over again throughout mathematics that has non-trivial consequences from a theoretical perspective
09:11:46 <edwardk> so the moment you spot that those laws hold you get a lot of power
09:12:01 <alphonse23_> does infixr and infixl not work in ghci
09:12:04 <alphonse23_> does anyone know?
09:12:08 <pjdelport> It's a bit like duck typing ("if it quacks like a monad, it must be a monad"), but backed by equational laws :)
09:12:26 <edwardk> it turned out that that pattern also nicely captured what we want to say about 'IO', but monads were around long before we discovered the IO story for them
09:12:26 <pjdelport> alphonse23_: It does, but you have to give the declaration as part of a let.
09:12:33 <alphonse23_> oh ok
09:12:42 <alphonse23_> pjdelport: thank you
09:12:48 <mgaut72> pjdelport: its more like "if it quacks like a monad, you should tell it that its a monad"
09:12:56 <mgaut72> =P
09:13:01 <pjdelport> alphonse23_: let (#) = undefined; infixr (#)
09:13:21 <edwardk> I usually do exactly what pjdelport suggested, which is start with a type and then ask if it can be an instance of each typeclass in turn, and if not, why not. that usually gives me insight into the thing it is that I'm working with and what trade-offs I'm making
09:13:53 <edwardk> after doing that enough you start to get a sense for where monads/applicatives/contravariant functors/etc. all come from
09:14:26 <edwardk> and if someone tells you some exotic type is a monad, you can then get a lot of insight into both how it works, and expand your intuition for what a monad can be
09:14:36 <MasterMastic> And does it ever make sense to dedicate a whole data struct just for it to be a monad?
09:14:50 <edwardk> sure, if the binding structure is important to what you need?
09:15:10 <edwardk> i will often modify my data structures slightly to pick up other classes 'in passing' if it doesn't compromise my goals
09:15:23 <edwardk> usually as a result of the changes i get a better API
09:15:26 <c_wraith> MasterMastic: there are also free monads and operational monads, as data structures designed to generalize other things into monads.
09:16:16 <pjdelport> MasterMastic: Being a monad is probably not something you can really think of a *goal* in and of itself; it either falls out of the data structure and its semantics, or not.
09:17:13 <MasterMastic> Okay I think I'm getting it :)
09:17:28 <haasn> When I grow up, I want to be a monad
09:17:51 <c_wraith> haasn: what is your join operation going to do?
09:18:03 <MasterMastic> Thank you all so much, starting to get familiar now
09:18:07 <pjdelport> MasterMastic: The most important thing i personally learned about monads was to not forget about its foundations: Functor and Applicative
09:18:27 <pjdelport> Whenever you hear something is a monad, try to think about those as the foundation for it too.
09:18:34 <haasn> c_wraith: Probably something involving gonads.
09:18:41 <monochrom> to restore the horse before the cart, you should decide "how do I want the users use it" rather than "how do I mutate code".
09:18:47 <pjdelport> So the Foo monad is also the Foo functor and the Foo applicative functor, by definition.
09:19:15 <pjdelport> And sometimes, the Functor and/or Applicative interface is all you actually need.
09:19:17 <c_wraith> pjdelport: only technically, for a bit longer. :)
09:19:22 <mgaut72> can you declare something to be a monad and have it automatically be derived as Functor and Applicative instances
09:19:28 <mgaut72> or do you need to be explicit about everything?
09:19:31 <pjdelport> c_wraith: :)
09:19:33 * pjdelport is amped
09:20:05 <pjdelport> mgaut72: Currently, it's not fully automatic, because Applicative isn't a superclass of Monad for historical reasons, but soon it will be.
09:20:10 <haasn> mgaut72: You have to be explicit; but you can use the existing functions “return”, “liftM” and “ap” to implement pure, fmap and (<*>)
09:20:36 <pjdelport> (The current workaround for that is the WrappedMonad newtype, which lets you use any Monad instance as a Functor and Applicative, but that will soon be obsolete.)
09:21:34 <haasn> I wonder why Applicative doesn't have a default implementation of pure/(<*>) based on Monad
09:21:46 <haasn> mgaut72: Oh, you can also automatically derive Functor using the DeriveFunctor extension
09:22:11 <haasn> But that's not related to the fact that Monad implies Functor
09:22:31 <mgaut72> right.   I get how one can manually derive function/applicative in terms of monad
09:24:35 * hackagebot polar 0.0.1 - Complex numbers in polar form  http://hackage.haskell.org/package/polar-0.0.1 (StefanKersten)
09:24:37 * hackagebot texts 0.3.2 - User-facing operations for dealing with texts  http://hackage.haskell.org/package/texts-0.3.2 (ChrisDone)
09:30:41 <jollygood> does lambdabot run in sandbox?
09:30:53 <vanila> yes
09:31:04 <carter> jollygood: its a very very tested sandbox
09:31:23 <jollygood> ah..I was hoping that type system was enough to ensure safety
09:31:29 <jollygood> why isn't it?
09:31:42 <carter> you can do pointers and stuff in haskell :)
09:31:47 <jollygood> disable IO, don't include unsafePerformIO
09:31:48 <carter> or unsafeCoerce
09:31:49 <carter> yeah
09:31:58 <vanila> jollygood, infinite loops could still be aproblem
09:32:06 <jollygood> lambdabot doesn't do IO though, so no pointers
09:32:09 <carter> vanila: i think the computations have timeouts
09:32:34 <vanila> I think that types are enough to ensure safety/security like this
09:32:42 <monochrom> GHC could have a bug
09:32:45 <vanila> but that's not the aim of haskell, so haskell code itself still needs sandboxes
09:32:53 <aranea> > fix (+1)
09:32:56 <lambdabot>  mueval-core: Time limit exceeded
09:33:04 <aranea> carter, vanila: ^^^
09:33:25 <jollygood> aranea launch a thread that gets killed if it doesn't compute in time?
09:33:25 <vanila> aranea, what i meant was you need some kind of 'sandbox' to halt infinite loops and stuff
09:33:58 <aranea> vanila: Oh, sorry then. I had only read carters statement.
09:39:34 <jollygood> > fix (1:)
09:39:36 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
09:39:50 <jollygood> fix is a weird beast. I can write some code with it, but still don't grasp fully how it works
09:40:31 <jollygood> but supposedly you can encode any recursive algorithm with it?
09:40:42 <vanila> fix f = f . f . f . f . f . f . f . f . f . f . ...
09:40:54 <joelteon> jollygood: where you'd normally write "foo a = ... + foo (a + 1)", for example
09:40:56 <jollygood> f (f ( f ( f ...   ?
09:41:01 <vanila> yes
09:41:05 <joelteon> you would now write "fix (\ foo a -> ... + foo (a + 1))"
09:41:07 <jollygood> @src fix
09:41:07 <lambdabot> fix f = let x = f x in x
09:41:10 <vanila> > take 3 $ (1:) . (1:) . (1:) . (1:) . (1:) . (1:) . (1:) . (1:) . undefined
09:41:11 <lambdabot>  Ambiguous occurrence ‘undefined’
09:41:11 <lambdabot>  It could refer to either ‘L.undefined’, defined at L.hs:155:1
09:41:11 <lambdabot>                        or ‘GHC.Err.undefined’,
09:41:11 <lambdabot>                           imported from ‘Prelude’ at L.hs:39:8
09:41:11 <lambdabot>                           (and originally defined in ‘base:GHC.Err’)
09:41:12 <jollygood> source is very confusing
09:41:18 <joelteon> it's like writing a normal recursive function, except the function name is now the first argument to fix
09:41:24 <vanila> that should have worked
09:41:49 <jollygood> joelteon I don't get how function name is the first argument from that source code
09:42:49 <iXeno> gah, what does '.' do again?
09:43:09 <jollygood> function composition
09:43:13 <jollygood> @src (.)
09:43:13 <lambdabot> (f . g) x = f (g x)
09:43:34 <coppro> jollygood: it's not function name
09:43:36 <coppro> it's just the function
09:43:45 <aranea> @undefine undefined
09:43:45 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
09:43:49 <jollygood> (f . g . h . i) x is the same as f (g (h (i x)))
09:43:50 <coppro> fix just repeatedly applies a function
09:43:57 <aranea> @undefine
09:43:57 <lambdabot> Undefined.
09:43:58 <jollygood> coppro hmm
09:44:07 <aranea>  > take 3 $ (1:) . (1:) . (1:) . (1:) . (1:) . (1:) . (1:) . (1:) . undefined
09:44:09 <aranea>  > take 3 $ (1:) . (1:) . (1:) . (1:) . (1:) . (1:) . (1:) . (1:) . undefined
09:44:15 <aranea> > take 3 $ (1:) . (1:) . (1:) . (1:) . (1:) . (1:) . (1:) . (1:) . undefined
09:44:16 <lambdabot>  Couldn't match expected type ‘[a]’ with actual type ‘a0 -> [a1]’
09:44:44 <iXeno> jollygood: so good old classical function composition
09:44:45 <vanila> oops!
09:44:46 <vanila> i forgot to fix
09:44:48 <vanila> > take 3 . fix $ (1:) . (1:) . (1:) . (1:) . (1:) . (1:) . (1:) . (1:) . undefined
09:44:49 <lambdabot>  [1,1,1]
09:44:50 <vanila> sorry about that
09:45:02 <vanila> anyhway the point is if you only look at the first 3 elements it doesn't matter if there's an undefined later
09:45:15 <vanila> and this lazyness is what lets fix work
09:45:50 <jollygood> is this proper definition of fix?  fix f = f (fix f)
09:46:02 <jollygood> it seems to be
09:47:33 <exio4> @src fix
09:47:33 <lambdabot> fix f = let x = f x in x
09:48:09 <jollygood> > let mafix f = f (mafix f) in mafix error
09:48:10 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
09:49:08 <jollygood> > let mafix f = f (mafix f) in mafix (1:)
09:49:09 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
09:49:30 <jollygood> so how are we passing function to f? (mafix f) above is not a function
09:50:20 <trap_exit> is there an online website of haskell exercises
09:50:23 <trap_exit> where it displays aproblem
09:50:28 <trap_exit> and you have to type in code that solves the problem
09:50:31 <trap_exit> and it's gamified
09:50:35 <trap_exit> so that as you do so, you gain points
09:51:26 <MasterMastic> Hmm.. do euler with GHCi?
09:51:38 <MasterMastic> https://projecteuler.net/
09:52:13 <doismellburning> nooo
09:52:16 <doismellburning> there's a fact thing about that
09:52:20 <doismellburning> er
09:52:38 <doismellburning> ?? euler
09:52:38 <lambdabot>  euler
09:52:46 <doismellburning> ?euler
09:52:46 <lambdabot> Unknown command, try @list
09:53:28 <srhb> trap_exit: There are a number of those, like SPOJ, with problems that can be solved in a number of languages, including Haskell
09:53:36 <srhb> Please don't do Euler. :-)
09:53:43 <trap_exit> why ont Euler ?
09:53:46 <favetelinguis> is there a way to activate autocompletion in haskell repl for emacs?
09:53:56 <srhb> It's less about programming and more about math. You won't really learn any Haskell doing it.
09:54:09 <trap_exit> oh; it's more algorithms?
09:54:16 <geekosaur> euler isnt about learning to program, it's about learning to think in terms of number theory and such
09:54:25 <Feuerbach_> srhb +1
09:54:26 <epta> trap_exit: number theory mostly
09:54:26 <MasterMastic> Yeah that's true
09:54:45 <trap_exit> hmm
09:55:50 <geekosaur> anyway, yes, algorithms. all the *thinking* is in figuring out appropriate algorithms/approaches; the actual codiing is typically trivial after that
09:56:37 <trap_exit> yeah
09:56:39 <trap_exit> that's not waht I wnat
09:56:42 <trap_exit> I want something that's like aMUD
09:56:44 <trap_exit> but you type in haskell code
09:56:53 <srhb> trap_exit: Check out timus, for instance.
09:56:58 <srhb> If you want an online judge kind of thing.
09:56:59 <trap_exit> so it's like "you come across this field; on this field, you see an array of rats" how do you reverse them ?
09:57:30 <srhb> Ah. No, I've never seen that.
09:57:48 <srhb> Would be cool though, you should make writing that your exercise instead :-)
09:58:12 <TheKing44> New Stack Overflow question: https://stackoverflow.com/questions/25771006/how-do-i-work-with-cabal-install-when-i-cant-control-the-path
09:58:27 <jollygood> > product [0..]
09:58:30 <lambdabot>  mueval-core: Time limit exceeded
09:58:32 <jollygood> that is weak
09:58:38 <jollygood> it should return 0
09:58:40 <TheKing44> Here is the share link: http://stackoverflow.com/q/25771006/1172541
09:59:00 <jollygood> no reason to continue computing after 0
09:59:02 <trap_exit> TheKing44: can't you just edit ~/.bashrc ?
09:59:40 <TheKing44> trap_exit ha ha
09:59:40 * hackagebot yi-rope 0.1.0.0 - A rope data structure used by Yi  http://hackage.haskell.org/package/yi-rope-0.1.0.0 (MateuszKowalczyk)
09:59:54 <trap_exit> TheKing44: I'm serious, set PATH = .....
09:59:59 <srhb> TheKing44: set PATH=%PATH%;newstuff
10:00:00 <trap_exit> or "export PATH = .... "
10:00:07 <trap_exit> what srhb said
10:00:24 <jollygood> do you consider this not cmoputing a bug?  product [0..]
10:00:38 <merijn> jollygood: Why would that possibly stop?
10:00:39 <srhb> jollygood: Nope.
10:00:42 <TheKing44> srhb What path would make Haskell Platform work correctly?
10:00:52 <jollygood> merijn because the answer can't be anything but 0
10:00:52 <srhb> TheKing44: You need the path to ghc at least
10:00:53 <MasterMastic> Nope
10:00:55 <exio4> that is like "filter (<50) [1..]"
10:00:56 <merijn> jollygood: Are you expecting GHC to magically include a complete potential numerical solver?
10:01:16 <srhb> jollygood: What is 1/0 is longer down the line?
10:01:19 <srhb> if*
10:01:21 <trap_exit> prd [] = 1; prod 0 : xs = 0; prod x : xs = x * prod xs
10:01:25 <jollygood> merijn, no, I am expecting library writers to properly implement product
10:01:29 <srhb> jeez.
10:01:47 <trap_exit> > let prod [] = 1; prod x: xs = 0; prod x : xs = x * prod xs; in prox [0 .. ]
10:01:49 <lambdabot>  <hint>:1:18: Parse error in pattern: prod
10:01:58 <trap_exit> > let prod [] = 1; prod 0: xs = 0; prod x : xs = x * prod xs; in prox [0 .. ]
10:02:00 <lambdabot>  <hint>:1:18: Parse error in pattern: prod
10:02:06 <srhb> trap_exit: (0:xs)
10:02:06 <trap_exit> someone make my code compile :-)
10:02:14 <Intolerable> > let { prod [] = 1; prod 0: xs = 0; prod x : xs = x * prod xs; in prod [0 .. ] }
10:02:16 <lambdabot>  <hint>:1:20: Parse error in pattern: prod
10:02:18 <trap_exit> > let prod [] = 1; prod (0: xs) = 0; prod (x : xs) = x * prod xs; in prox [0 .. ]
10:02:20 <lambdabot>  Not in scope: ‘prox’
10:02:20 <lambdabot>  Perhaps you meant ‘prod’ (line 1)
10:02:22 <merijn> jollygood: I disagree with your opinion that the current implementation of product is wrong
10:02:30 <trap_exit> > let prod [] = 1; prod (0: xs) = 0; prod (x : xs) = x * prod xs; in prod [0 .. ]
10:02:31 <lambdabot>  0
10:02:39 <trap_exit> there we go
10:02:40 <Intolerable> > let { prod [] = 1; prod (0:xs) = 0; prod (x:xs) = x * prod xs; in prod [0 .. ] }
10:02:41 <lambdabot>  <hint>:1:64: parse error on input ‘in’
10:02:42 <trap_exit> happy now? :-)
10:02:43 <trap_exit> laziness ftw
10:02:55 <Intolerable> ghci so whiny
10:03:02 <ion> That doesn’t have anything to do with laziness.
10:03:02 <srhb> trap_exit: except stack overflows now.
10:03:17 <merijn> jollygood: multiplying by 0 is not guaranteed to return 0 at all
10:03:18 <trap_exit> > let prod [] = 1; prod (0: xs) = 0; prod (x : xs) = x * prod xs; in prod [0 .. ]
10:03:19 <lambdabot>  0
10:03:24 <trap_exit> waht? no stack overflow
10:03:33 <jollygood> merijn no complete potential numerical solver necessary: http://lpaste.net/110851
10:03:41 <jollygood> merijn huh? how isn't it?
10:03:43 <merijn> trap_exit: Except your code is wrong for Float
10:03:51 <merijn> jollygood: Because product works for Float to
10:03:57 <merijn> > (1/0) * 0
10:03:58 <lambdabot>  NaN
10:03:58 <trap_exit> merijn: how so?
10:04:02 <trap_exit> merijn: is * right associative ?
10:04:13 <merijn> Floats have no assiociativity
10:04:33 <merijn> > product [0..10] :: Float
10:04:34 <lambdabot>  0.0
10:04:45 <trap_exit> merijn: then why is my code wrong?
10:04:47 <merijn> > product ((1/0) : [0..10] :: Float
10:04:48 <lambdabot>  <hint>:1:34:
10:04:48 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
10:04:50 <jollygood> damn floats, always ruin everything
10:04:54 <merijn> > product ((1/0) : [0..10]) :: Float
10:04:55 <lambdabot>  NaN
10:04:56 <trap_exit> > let prod [] = 1; prod (0: xs) = 0; prod (x : xs) = x * prod xs; in prod [0 .. ] :: Float
10:04:58 <lambdabot>  0.0
10:05:00 <trap_exit> bah
10:05:01 <trap_exit> my code works
10:05:24 <merijn> > let prod [] = 1; prod (0: xs) = 0; prod (x : xs) = x * prod xs; in prod ((1/0) :[0 .. ]) :: Float
10:05:25 <lambdabot>  NaN
10:05:35 <trap_exit> that should be NAN
10:05:36 <trap_exit> 1/0 is undefined
10:05:38 <trap_exit> 1/0 * 0 is undefeind
10:05:58 <trap_exit> hmm, though I guess 0 * 1/0 I get wrong
10:05:59 <merijn> oh, hah
10:06:04 <trap_exit> since 0 * 1/0 should be undefined, but I say 0
10:06:08 <srhb> trap_exit: Indeed.
10:06:13 <merijn> > let prod [] = 1; prod (0: xs) = 0; prod (x : xs) = x * prod xs; in prod ([0 .. ] ++ [(1/0)]) :: Float
10:06:14 <lambdabot>  0.0
10:06:40 <exio4> merijn: ++ to an infinite list? :P
10:06:58 <merijn> exio4: Still illustrates my point :)
10:09:38 <trap_exit> only in #haskell do we get into pendantic arguments, and then award people for being pedantic :-)
10:09:41 * hackagebot connection-pool 0.1.1.0 - Connection pool built on top of resource-pool and streaming-commons.  http://hackage.haskell.org/package/connection-pool-0.1.1.0 (PeterTrsko)
10:10:06 <srhb> I disagree that it's being pedantic, but I suppose that's pedantic. :-)
10:10:18 <merijn> Clearly you haven't been to ##C, they take pedantism to an art form
10:10:43 <srhb> Is that C sharp or C?
10:10:48 <srhb> Oh wait
10:10:53 <srhb> Cannot brain today.
10:10:53 <joelteon> do you normally write C sharp #C or C#?
10:10:59 <srhb> joelteon: Indeed. :P
10:11:02 <dmj`> C#
10:11:04 <joelteon> "hashtag C"
10:11:34 <jollygood> guys in ##C are major dicks and cunts. newbies are expected to get abuse together with any help they receieve
10:11:47 <joelteon> well, that language isn't very appropriate
10:12:24 <joelteon> I remember reading the "Shit Zhivago says" twitter, though
10:12:26 <joelteon> Those were good times
10:12:42 <trap_exit> I actually sorta like the rtfm culture
10:12:45 <trap_exit> except for learning monads
10:12:54 <joelteon> I just can't get my head around functors.
10:12:59 <trap_exit> actually, I bet I would have learned monads faster with rtfm
10:13:02 <joelteon> Wait, that's not a good simile.
10:13:07 <joelteon> I just can't get my head around integers.
10:13:09 <trap_exit> hand holding / tutorials held me back until it was "read the frickin typues"
10:13:11 <trap_exit> then it made sense
10:13:13 <joelteon> That's probably better.
10:19:42 * hackagebot yi-rope 0.1.0.1 - A rope data structure used by Yi  http://hackage.haskell.org/package/yi-rope-0.1.0.1 (MateuszKowalczyk)
10:27:00 <joelteon> > join (==) (0/0)
10:27:01 <lambdabot>  False
10:27:57 <trap_exit> in maintaining a QA community, what's a good _minimal_ ratio for questions answered / questions asked to avoid people form being 'takers' ?
10:28:14 <trap_exit> I'm thinking a 1/2 ratio is good (i.e. at the min, for every two questions ask, answer atleast 1 question)
10:29:03 <Fuuzetsu> I :set -Wall in GHCi, how do I unset it?
10:29:16 <ij> trap_exit, Takers? Don't good question-askers contribute?
10:29:26 <joelteon> isn't that #-blah material?
10:29:28 <ij> it is
10:29:34 <trap_exit> you're right, I should take this to -blah
10:30:31 <trap_exit> ij: would love to hear your opinions in #haskell-blah
10:43:20 <dmj`> λ: :unset -Wall
10:43:20 <dmj`> don't know how to reverse -Wall
10:43:29 <dmj`> says ghci
10:43:43 <dmj`> Fuuzetsu: ^
10:54:30 <monochrom> jollygood: see my http://www.vex.net/~trebla/haskell/fix.xhtml
11:01:49 <trap_exit> round 1 .... monads-tf vs mtl ... which one sould I hide, and which one should I use?
11:01:52 <cschneid> What does this syntax do: `class (Monoid v) => Measured v a | a -> v where `
11:01:59 <cschneid> with the vertical pipe
11:02:19 <trap_exit_> okay, ambye round 2, i was just disconnected
11:02:41 <michaelt> trap_exit: I thought 'monad-tf' was basically rejected by the community. But maybe Im clueless
11:03:02 <trap_exit_> michaelt; apparently some library I use depends on it
11:03:23 <michaelt> cschneid: the vertical pipe precedes a declaration of  'FunctionalDependencies'
11:03:41 <cschneid> michaelt: cool - thanks. I'll read up
11:03:52 <trap_exit_> ghc-pkg hide ftw
11:04:27 <michaelt> cschneid: it just means that the choice of a always determines the choice of v, so that you don't have as it were a two-dimensional array of instances to deal with.
11:05:05 <cschneid> michaelt: this is from fingertree - so it is saying the `v` monoid is uniquely determined by which `a` you pick?
11:06:02 <michaelt> cschneid: its the other way around,
11:06:19 <cschneid> michaelt: `a -> v` right?
11:06:29 <michaelt> unless I'm hallucinating, which occasionally happens.
11:06:43 <michaelt> cschneid: that means: a determines v
11:07:17 <michaelt> so as soon as the compiler knows what 'a' you're talking about, it knows what 'v' to use.
11:07:45 <michaelt> without this or type functions, multiparameter type classes get a bit dicey
11:07:47 <cschneid> michaelt: that's what I said, just in a weird sentence :)
11:07:48 <cschneid> thanks
11:08:39 <michaelt> cschneid: yeah right. i see.
11:08:42 <Odda> hi, is naive to think that it is possible to encode and decode a GADT using aeson? (I'm assuming that this is a GADT; data EventType = E1 String, E2 String, E3 Int)
11:08:59 <vanila> Odda, that's not a GADT
11:09:11 <vanila> GADT is where you have   data T :: ... where C :: ...
11:09:41 <michaelt> Odda: yeah, as you stated it, its perfectly ordinary
11:10:05 <Odda> is the thing i've put up there a type constructor then?
11:10:29 <michaelt> EventType is a type  constructor. E2 is a data constructor, in the usual jargon
11:10:33 <Odda> i mistakenly put commas instead of pipes in
11:10:54 <michaelt> if you can express it with pipes it isnt a gadt
11:11:02 <Odda> i meant data Event = E1 String | E2 String | E3 Int
11:11:20 <Odda> right.
11:11:25 <dhrosa> hmm, I have blank :: Parser (), and a unexpected :: Parser Token
11:11:47 <michaelt> data Event a where E1 :: String -> Event String; E2 :: String -> Event a ; E3 :: Int -> Event a
11:11:50 <dhrosa> and I have a bigger parser, Parser Token
11:11:54 <michaelt> that would be a gadt ^^^
11:12:34 <dhrosa> I want to have parsec do this: do some stuff to produce a Token, THEN, if blank fails to consume input, use the unexpected parser
11:12:54 <dhrosa> actually I think I figured it out, nvm
11:13:53 <michaelt> Odda: but the main point is, there shouldn't be a problem with aeson
11:13:57 <Odda> michaelt: ok. so if i want this serialized and deserialized, would i have to change my definition, or would the way i've got it set up now work as well?
11:14:09 <michaelt> it should work fine.
11:14:13 <stephenmac7_> Why do I get Ambiguous occurrence for things the haskell compiler can figure out?
11:15:05 <Odda> michaelt: right. thanks, i'll try some more
11:15:33 <michaelt> Odda: just follow one of the models in the examples dir https://github.com/bos/aeson/blob/master/examples/Generic.hs
11:16:01 <stephenmac7> Like, if I have two record-style data types with a name function (so, name -> D1 and name -> D2), why can't haskell figure out which name function I want to use?
11:16:02 <phaskell> D2: Add .arcconfig - https://phabricator.haskell.org/D2
11:16:02 <phaskell> D1: Add LICENSE and update README.md - https://phabricator.haskell.org/D1
11:17:42 <stephenmac7> Is there an extension or something for it?
11:17:45 <pqmodn> stephenmac7: because name is not polymorphic, so typing information is not used to choose which definition of name
11:17:46 <michaelt> stephenmac7: well, there's an extension coming that will permit some such things
11:18:30 <srhb> stephenmac7: The answer is "poor record design" and "we're working on it" :-)
11:18:35 <stephenmac7> TypeDirectedNameResolution looks similar but it does it backward
11:18:46 <stephenmac7> type.function instead of function type
11:19:16 <michaelt> stephenmac7: it's like srhb says.
11:19:31 <stephenmac7> michaelt: srhb: Got it. So, what's being done?
11:19:58 <mgaut72> dhrosa: in parsec it sounds like your should rather use (<?>) since its not an "unexpected" problem, but rather your expected a blank and didn't get one
11:20:38 <srhb> I believe OverloadedRecordFields is one of the proposals aiming to deal with it
11:21:54 <michaelt> stephenmac7: oh here's some slides from the guy who has been implementing it, agundry http://www.well-typed.com/blog/aux/files/overloaded-record-fields.pdf
11:22:04 <stephenmac7> Thanks
11:22:10 <Odda> michaelt: lol, that worked very nicely. it feels like some serious black magic
11:22:40 <michaelt> stephenmac7: but the other radical change since the old days of whining about haskell records is the lens library
11:23:22 <srhb> Still, they just make you generate ugly record fields and then make some nice lenses from them with TH.
11:23:34 <srhb> But yeah, they do sidestep the issue somewhat.
11:23:38 <stephenmac7> lens looks cool. Haven't tried it yet. The type declarations are terribly long
11:23:51 <michaelt> Odda: yeah, i know the 'derive Generic' is suspiciously powerful...
11:24:15 <michaelt> stephenmac7: yeah it's a bit much but the abcs are really simple
11:24:26 <mgaut72> stephenmac7: lens is one of the cases where reading the types actual does not help (me personally) understand what the heck is going on
11:25:02 <Fuuzetsu> what's the faster way to count number of newlines in Text?
11:25:22 <Fuuzetsu> notably, "abc" is 0 lines in this scenario
11:26:13 <Fuuzetsu> length . filter or postprocess . lines are two naive solutions
11:26:36 <michaelt> > (1,("hi",(12,"ho"))) ^. _2._2._1
11:26:37 <lambdabot>  12
11:27:06 <Fuuzetsu> > Data.Text.count "\n" "a\nb"
11:27:08 <lambdabot>  Not in scope: ‘Data.Text.count’
11:27:14 <Fuuzetsu> > T.count "\n" "a\nb"
11:27:15 <lambdabot>  Not in scope: ‘T.count’
11:27:15 <lambdabot>  Perhaps you meant ‘BS.count’ (imported from Data.ByteString)
11:27:17 <Fuuzetsu> tsk
11:27:45 <pqmodn> :t (_2._2._1)
11:27:45 <michaelt> it would be count '\n' "a\nb"
11:27:46 <lambdabot> (Field1 a1 b1 a2 b2, Field2 a b a1 b1, Field2 s t a b, Functor f) => (a2 -> f b2) -> s -> f t
11:28:11 <michaelt> see, it's perfectly readable if you forget about the class constraint
11:30:07 <bmuk> Have any of you participated in google summer of code?
11:30:16 <bernalex> haasn has
11:31:41 <bmuk> I would really like to do it for haskell.org this summer, and I'd like to start preparing now. Any idea of the kinds of projects the community needs most?
11:32:38 <Fuuzetsu> michaelno, it would be count "\n"
11:32:40 <Fuuzetsu> it takes Text
11:33:05 <Fuuzetsu> anyway, in unoptimised run count is 20x faster than filter and length
11:33:31 <bernalex> bmuk: check if #haskell-gsoc is still alive?
11:33:56 <djahandarie> bmuk, it doesn't have any current project suggestions on it, but http://www.gwern.net/Haskell%20Summer%20of%20Code is a nice discussion/analysis of former years.
11:34:25 <Fuuzetsu> bmuk: sure is early!
11:36:16 <bmuk> Fuuzetsu: Early bird gets the worm as the say! :p I think for me it's more about having a tangible goal to work towards. Even if I don't get the gig, I'm sure preparing for it will make me a better programmer, and I can still contribute to the community anyway
11:36:42 <Fuuzetsu> yes, of course, I don't mean to discourage
11:36:53 <luite> bmuk: being active in the community certainly helps
11:37:01 <bmuk> bernalex, djahandarie: I'll definitely take a look, thanks.
11:37:04 <Schoening> I just did the first of 99 questions. But I am a bit overwhelmed by the Solutions page.. All I did was   myLast list = last list  but the Solution page is giving me a ton of syntax I haven't learned yet. http://www.haskell.org/haskellwiki/99_questions/Solutions/1    Am I understanding it correctly that I used a "library" and not an internal part of the language?
11:37:26 <luite> bmuk: even if it's for projects different from those that have most gsoc interest
11:37:50 <bmuk> luite: Other than hanging out here what can I do?
11:37:59 <exio4> Schoening: the idea was building your last function, not using prelude's :P
11:38:09 <Fuuzetsu> Schoening: ‘last’ is in Prelude which is imported by default. You could use NoImplicitPrelude extension
11:38:34 <Fuuzetsu> technically you did use a library, but so is every of those solutions
11:38:52 <Fuuzetsu> the first one is probably the closest to what you're expected to actually code up
11:39:51 <luite> bmuk: contribute to bigger projects. perhaps send some pull reqs for bugfixes in things like cabal, participate in feature discussions
11:40:26 <Qfwfq> I was reading through containers:Data.Set and found 'map f = fromList . List.map f . toList'. friends i don't know how to feel right now
11:41:18 <pqmodn> read about list fusion
11:41:43 <Schoening> Thx Fuuzetsu, I gotta grab some dinner. And then I am gonna look for a page that is gonna explain things like "<-" to me ^^ Is there a equivalent to JS https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference for Haskell?
11:41:52 <bmuk> while we're on the subject, which haskell projects need the most love?
11:42:53 <Qfwfq> pqmodn: I can trust it to be memory-efficient, but my gut says otherwise. It'll do.
11:42:54 <luite> bmuk: cabal is a good target, the new haskell.org website is also still unfinished. also needs some content
11:43:40 <bmuk> luite: alright, thank you very much for your help! I'll look into those projects
11:43:52 <Fuuzetsu> Schoening: no, we don't have that much syntax ;)
11:44:31 <Fuuzetsu> Schoening: nearly everything you see on that solutions page are regular functions/operators you can define yourself, maybe pattern matching is the only thing you haven't seen
11:45:31 <sinelaw> trying to model a type system here. what would you say is the type of a function that has no return value? (e.g. void in C)
11:45:38 <pqmodn> Qfwfq: don't trust your gut, find out the amazing optimizations the compiler does so you can write simple code like that and have it transformed into efficient code!
11:46:06 <Fuuzetsu> sinelaw: I would not call that a function
11:46:14 <Fuuzetsu> just use the trivial value, ()
11:46:37 <sinelaw> Fuuzetsu, i wouldn't either, but i'm modelling languages like C where it's possible
11:46:52 <Fuuzetsu> you can define a type without inhabitants (bar undefined)
11:46:55 <pqmodn> sinelaw: then why not call it 'void'?
11:47:19 <sinelaw> you mean have a type in my type system that has no values?
11:47:30 <pqmodn> if you're modeling C's type system, wouldn't you need that?
11:47:44 <Fuuzetsu> if you're modeling C, you probably want to special-case void
11:47:50 <sinelaw> pqmodn, i'm leaning toward that, but was thinking if there are other viable options
11:48:09 <pqmodn> no, unless you chose a subset of C which doesn't have void.
11:48:24 <michaelt> Schoening: I'm not sure what's best but here's one attempt http://blog.codeslower.com/static/CheatSheet.pdf
11:48:24 <Fuuzetsu> unfortunately a very small subset
11:48:32 <sinelaw> pqmodn, I'm actually doing a subset of Javascript right now, where functions that don't return a value actually return 'undefined'.
11:48:50 <Fuuzetsu> that ‘undefined’ is different from our ‘undefined’
11:48:52 <pqmodn> JS's undefined is not like C's void though
11:48:53 <sinelaw> I mean the full javascript has functions with no return value actually returning undefined
11:48:59 <Fuuzetsu> that undefined is effectively Nothing where everything is wrapped in Maybe
11:49:05 <sinelaw> pqmodn, I know, it's not the same at all, it is a value
11:49:09 <sinelaw> but I want to disallow that
11:49:32 <sinelaw> have statements like: x = func_with_no_return()
11:49:41 <sinelaw> not be valid
11:49:46 <exio4> Fuuzetsu: isn't that what "NULL"/"nil"/"null"/etc means everywhere?
11:50:30 <Fuuzetsu> exio4: more or less, which is why it's stupid because if you have an option type everywhere and things crashing on Nothing, you end up in a horrible mess and have to define option types on top of option types…
11:50:50 <Fuuzetsu> precisely why having ‘null’ in a language is stupid
11:51:12 <sinelaw> Fuuzetsu, so I'm trying to get rid of the stupidity in this subset of a language
11:51:14 <afleck> hi, there was a tutorial i was using a while ago on the Haskell Wiki that was a really long article that talked about arrows, functors, and monads, and it had a bunch of exercises, one I remember in particular was implementing the Free monad, but now I can't find it. Does anyone know what I'm talking about?
11:51:18 <pqmodn> sinelaw: you probably should consider distinguishing expressions from statements. calling a void-function is a statement and you can enforce rules about assignment concerning expressions (which evaluate to a value) and statements (which do not)
11:51:18 <sinelaw> null can perhaps be Maybe
11:51:25 <sinelaw> but undefined is pointless
11:51:46 <sinelaw> pqmodn, that's a nicer approach.
11:52:29 <sinelaw> pqmodn, effectively failing cases like: x = func_without_return_value()
11:52:50 <sinelaw> because having a type "void" means x will have that type now.
11:53:01 <sinelaw> so better to not allow it
11:53:17 <pqmodn> another approach is like you say, make void the same as (). then x = void_func(..) would assign the type () to x, and trying to *use* it as if it contained any information could be a type error
11:53:20 <exio4> Fuuzetsu: I was going to say "they live inside the Maybe monad" :P
11:53:27 <sinelaw> which is what C does. Javascript is dumb enough to not fail on that, even in so called 'strict mode'
11:54:29 <Fuuzetsu> exio4: but they don't, because they don't compose, they just crash
11:54:36 <sinelaw> I'll go for not allowing it
11:54:40 <sinelaw> thanks.
11:59:03 <exio4> Fuuzetsu: sounds like a neat way to make the whole language "NSFW"!
11:59:39 <Fuuzetsu> right, which is why I'm in #haskell instead of elsewhere
12:00:20 <dfeuer> Why are there sequence, mapM, and filterM, but not sequenceA, mapA, and filterA?
12:00:55 <dfeuer> [For that matter, now that Monad is a subclass of Applicative, could the type of sequence be changed?]
12:01:16 * dfeuer is trying to get a handle on this Applicative thing.
12:06:38 <eitan_chatav> does the protocol-buffers library on hackage work with GHC 7.8?
12:07:55 <eitan_chatav> dfeuer: there is a sequenceA and instead of mapA there is traverse
12:10:25 <sinelaw> pqmodn, I can' really treat calls to functions that don't return a value as statements
12:11:46 <pjdelport> dfeuer: There are, but they're in Data.Foldable and Data.Traversable
12:11:54 <sinelaw> pqmodn, the function itself must have a type anyway, it's still a value
12:12:01 <pjdelport> :t sequenceA
12:12:03 <lambdabot>     Not in scope: ‘sequenceA’
12:12:03 <lambdabot>     Perhaps you meant one of these:
12:12:03 <lambdabot>       ‘T.sequenceA’ (imported from Data.Traversable),
12:12:06 <pjdelport> :t T.sequenceA
12:12:07 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
12:12:13 <pjdelport> mapA is traverse
12:12:15 <sinelaw> i think I'll go with adding a dummy invalid type (void or whatever)
12:12:16 <pjdelport> :t T.traverse
12:12:17 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
12:13:28 <pjdelport> filterA is not in the standard libraries, unfortunately, but it's straightforward to define.
12:28:17 <Fuuzetsu> how does the order of patterns affect performance?
12:28:30 <Fuuzetsu> consider foo [] = …; foo (x:xs) = …;
12:28:41 <Fuuzetsu> as opposed to foo (x:xs) = …; foo [] = …;
12:29:08 <Denommus> Fuuzetsu: this changes the semantic completely
12:29:18 <Denommus> Fuuzetsu: no, wait. I'm dumb
12:29:20 <dfeuer> Fuuzetsu, I think there may be some difference once it gets down to Core.
12:29:47 <Fuuzetsu> dfeuer: right, it seems the second would be more performant because we don't check for [] with every element but only once we're done
12:30:04 <Fuuzetsu> Denommus: assume in this case that the result is the same
12:30:08 <dfeuer> But the order you write the patterns doesn't seem to affect what order GHC puts them in, unless there's a semantic difference.
12:30:23 <dfeuer> Fuuzetsu, I don't understand. You need to check for [] every time.
12:30:38 <Denommus> I think that gets optimized away anyway
12:30:58 <dfeuer> I think it doesn't but the branches are predicted correctly.
12:31:27 <dfeuer> So it probably has no effect on performance.
12:31:36 <Fuuzetsu> right
12:31:51 <Fuuzetsu> I'll stick to the first style I guess
12:31:53 <Fuuzetsu> was just wondering
12:32:17 <dfeuer> Does anyone know why Control.Applicative doesn't have things like sequence, mapM, and filterM?
12:32:42 <Fuuzetsu> because Monad was first and noone bothered to backport I suppose
12:33:30 <pjdelport> dfeuer: Did you get my earlier messages about the Data.Traversable versions?
12:33:31 <k00mi> dfeuer: it's all in Data.Traversable/Foldable
12:33:57 <pjdelport> :t T.sequenceA
12:33:58 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
12:34:00 <pjdelport> :t T.traverse
12:34:00 <dfeuer> No, pjdelport.
12:34:01 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
12:34:05 <dfeuer> Ah...
12:34:08 <pjdelport> traverse is mapA, basically
12:34:53 <pjdelport> It doesn't have filterA, for some reason, but it's straightforward to define yourself, at least.
12:36:02 <pjdelport> The reason for them being in Data.Foldable and Data.Traversable instead of Control.Applicative is that they additionally generalize across Foldable and Traversable structures, instead of just lists like sequence / mapM and friends.
12:40:52 <dfeuer> I see,  pjdelport.
12:41:27 <pjdelport> :t F.traverse_
12:41:28 <lambdabot> (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
12:41:31 <pjdelport> :t F.sequenceA_
12:41:32 <lambdabot> (Foldable t, Applicative f) => t (f a) -> f ()
12:41:46 <dfeuer> Now that Monad is becoming Applicative, can Data.Traversable.sequenceA be renamed sequence?
12:42:04 <spopejoy> What is a good way to decorate an object with ad-hoc properties? Cf lisp symbol plists, which of course are untyped and therefore unsuitable/impossible in haskell ...
12:42:13 <pjdelport> There you'll see that the _ versions are actually more generic than the previous, in just requiring Foldable instead of Traversable.
12:42:35 <dfeuer> Oh wait, that's a class method; is there a situation where sequence is more efficient using monad ops?
12:42:45 <pjdelport> (Traversable itself is a specialization of Foldable)
12:43:13 <dfeuer> Yeah, pjdelport, I see it. If it needs to build a structure, like sequence or mapM, then it needs to be in Traversable.
12:43:23 <dfeuer> Wait .... No.
12:43:31 <dfeuer> That ... ARGH.
12:43:32 <pjdelport> dfeuer: It could perhaps in theory be renamed like that, but the existing Monad-based functions are likely to stay, because their signatures are more constrained.
12:43:57 <dfeuer> pjdelport, Data.Traversable is ALL WRONG there.
12:44:24 <dfeuer> Well, maybe not.
12:44:27 <pjdelport> Wrong?
12:44:33 <dfeuer> No, I'm confused.
12:44:44 <dfeuer> I understand it now.
12:44:49 <pjdelport> Well, basically, the distinction is that Foldable doesn't preserve structure, but Traversable does.
12:44:53 <dfeuer> (somewhat, anyway)
12:45:26 <dfeuer> Foldable strikes me as very strange.
12:45:39 <c_wraith> Traversable is kind of a generalization of Functor.  Foldable, though, might as well be named ToList
12:45:50 <pjdelport> So for the _ functions, you throw all the structure of the thing you're traversing (or just folding, to be more precise) away: you only care about the structure of the Applicative that you're mapping across it.
12:45:51 <dfeuer> Actually, they're both kind of strange.
12:46:15 <c_wraith> Except that foldMap is sometimes more efficient than toList, as far as the class goes.
12:46:17 <dfeuer> Yeah, I get that part, pjdelport (kind of sort of).
12:47:03 <pjdelport> With the non-_ versions, you have to get the same structure back out, so you need Traversable's additional functionality of a structure-preserving mapping, instead of just a summarizing mapping like Foldable.
12:47:24 <dfeuer> Yeah, pjdelport, I figured that out about three minutes ago :-P
12:48:15 <pjdelport> It's a bit confusing because there are two unrelated kinds of structure involved here: (1) the structure of the thing you're folding or traversing, and (2) the structure of the functor (or action or whatever) that you're mapping across, or using to transform, the previous.
12:48:19 <k00mi> dfeuer: "The Essence of the Iterator Pattern" is a great paper, it's linked in the documentation for Data.Traversable
12:49:06 <spopejoy> A way I've seen haskell objects get "decorated" with properties is to blow out the type signature ... ie a Foo a b, where 'a' is what Foo operates on, allowing it to "carry" 'b'. Then this in turn gets built with another Bar c d, etc.
12:49:08 <pjdelport> Both of those might even be the same type, but playing two completely orthogonal roles, like when you're sequencing a list of lists.
12:49:54 <pjdelport> The "outer" list is the Traversable, while the "inner" list is the Applicative, and the fact that they both happen to concretely be the list type is esentially just coincidence.
12:50:02 * hackagebot load-env 0.0.5 - Load environment variables from a file.  http://hackage.haskell.org/package/load-env-0.0.5 (PatrickBrisbin)
12:50:36 <c_wraith> spopejoy: are you asking about phantom types?
12:50:54 <Newbie_117> Hi everyone! I'm kinda new to haskell (started today!) and would like some help if possible. I want to create a function that checks if a char in a string is a vowel or consonant. If it's a vowel I want the character to be unchanged. But if it's a consonant I want to add an "o" and the same consonant. An example would be texter "ball" = "bobalolol"
12:50:56 <dfeuer> pjdelport, I'm still trying to understand just what the traversable things *do*, but that will take some reading more.
12:51:01 <spopejoy> c_wraith: no, I'm wondering about a good approach for ad-hoc property assignment.
12:51:05 <spopejoy> like lisp plists
12:51:24 <c_wraith> spopejoy: something like HList, maybe?
12:51:36 <spopejoy> HList, not familiar.
12:51:44 * spopejoy frantically hoogling
12:51:45 <Newbie_117> Here is what I have done so far, but it seems like something is wrong : vowel = ['e','i','o','u','y','a'] res = []  checker2 text = [if c `elem` vowel then res ++ c else res ++ ['o'] ++ c | c <- text]
12:52:40 <dfeuer> Newbie_117, sounds like fun. You might have better luck with that sort of question in #haskell-beginners. We can discuss it over there.
12:53:01 <c_wraith> spopejoy: much of what is done in HList could be done simpler with new GHC extensions, but it does provide some nice functions to make things simpler.
12:53:15 <pjdelport> dfeuer: Does Foldable make sense?
12:53:50 <spopejoy> seems like anything with Oleg's name on it "could be done simpler" :)
12:53:53 <dfeuer> pjdelport, I believe so; yes.
12:54:02 <Newbie_117> @dfeuer Thanks! Sorry for taking up space in the wrong chat ^^
12:54:02 <lambdabot> Unknown command, try @list
12:54:14 <spopejoy> was trying to use enumatees the other day
12:55:56 <pjdelport> dfeuer: So Foldable captures the idea that you can "walk" a structure, and summarize it using a mapping to a monoid, or equivalent.
12:56:17 <spopejoy> c_wraith: in some of these cases, declaring new types is cumbersome. The application is to do diverse transformations on structures while preserving some information, kind of like denormalizing a join. It's temporary, in order to output a well-recognized type.
12:56:53 <dfeuer> Yes, pjdelport, I get that. Easy.
12:57:00 <spopejoy> But I need to study HList to understand what it's trying to achieve.
12:57:56 <pjdelport> dfeuer: Most essentially, Traversable combines Foldable with Functor: so its foundation is that it's a structure that you can apply a structure-preserving map to, like Functor, but also summarize, like Foldable.
12:58:38 <dfeuer> So you have to be able to apply a structure-preserving map to it in the right order.
12:59:05 <spopejoy> c_wraith: what are the new GHC features related to this?
12:59:53 <pjdelport> dfeuer: And then Traversable adds the additional ability that if the structure happens to contain Applicative functor values in the Traversable's "slots", then you can lift the structure of the Traversable into the Applicative.
13:00:11 <pjdelport> which is what sequenceA captures
13:00:14 <pjdelport> :t T.sequenceA
13:00:15 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
13:00:26 <pjdelport> It basically swaps the t and f around.
13:01:00 <pjdelport> As a concrete example, if you have say a list of IO actions, then this means that you can turn it into an IO action yielding a pure list (containing the results of the individual IO actions)
13:01:35 <dfeuer> Yes, I see that. What does it mean by an "applicative transformation"?
13:02:15 <pjdelport> In that case, it *literally* just lifts the list constructors into IO (or any other Applicative), which you can see from the list definition of sequenceA:
13:02:15 <pjdelport> sequenceA = foldr (liftA2 (:)) (pure [])
13:02:49 <pjdelport> remembering that the identity function for lists is just foldr (:) []
13:03:16 <dfeuer> OK, but what is meant by an "applicative transformation"?
13:04:28 <pjdelport> The docs for Traversable defines "applicative transformation" as any function t :: (Applicative f, Applicative g) => f a -> g a
13:06:08 <k00mi> spopejoy: have a look at vinyl, it's similar in many ways to HList but more modern
13:06:13 <benzrf> so a natural transformation
13:06:20 <benzrf> oh wait
13:06:27 <benzrf> pjdelport: does it define any laws
13:06:53 <pjdelport> So the intuition that for example the law "t . sequenceA = sequenceA . fmap t" captures is that changing the Applicative inside the Traversable and then sequencing it (putting the Applicative on the outside) must mean the same as sequencing it, and then changing the Applicative outside the Traversable.
13:06:53 <carter> the law of awesome
13:07:09 <carter> http://www.haskell.org/haskellwiki/Typeclassopedia#Traversable
13:08:08 <pjdelport> benzrf: Does what define any laws?
13:08:14 <benzrf> appl Transfusion
13:08:15 <benzrf> *trans
13:08:27 <benzrf> is it offically a natural transformation or just a infranatural one
13:08:38 <pjdelport> Oh, the docs just define it as that locally
13:08:48 <pjdelport> as a shorthand in the context of Traversable's laws
13:09:01 <benzrf> ah
13:09:56 <pjdelport> Oh, and it does also say such an applicative transformation must "preserving the Applicative operations":
13:09:56 <pjdelport> t (pure x) = pure x
13:09:56 <pjdelport> t (x <*> y) = t x <*> t y
13:10:04 <pjdelport> preserve, even
13:10:23 <pjdelport> So yeah, a natural transformation, i assume
13:10:33 <Fuuzetsu> nice, -O2 gives me 10x improvement with Text
13:11:52 <dfeuer> Buh. ...
13:12:42 <l0cust> hm
13:39:21 <rrradical> have there been any efforts to combine the advantages of hayoo (indexes all of hackage) with hoogle (advanced type signature search)? it's disappointing that they both have drawbacks
13:39:21 <kadoban> I'm trying to install hakyll, and it's failing on the 'network' package which it apparently needs as a dependency. All I get is this cryptic error: "setup-Configure-Cabal-1.20.0.0-x86_64-linux-ghc-7.8.3: sh: inappropriate type"
13:39:21 <kadoban> Any hints or places to look?
13:41:13 <deni> how would one go and do something like printf "%b" True ?
13:41:37 <deni> ie. that's what i want to do but it's obviously wrong because the type system wont let me..so can someone set me on the correct path?
13:41:37 <mauke> that doesn't even make sense
13:41:49 <luite> kadoban: oh interesting, i've seen that error before but never found out the cause
13:41:50 <deni> mauke: %b being boolean...which doesn't exists
13:41:53 <deni> *ecist
13:41:55 <mauke> no, %b is binary
13:42:06 <deni> mauke: ah sorry for the confusion then
13:42:15 <deni> mauke: i wan't to string format boolena
13:42:18 <deni> *boolean
13:42:22 <deni> typing is not my friend tonight
13:42:26 <mauke> show b
13:42:39 <deni> mauke: printf "%s" show True?
13:42:51 <mauke> no, just show True
13:43:05 <geekosaur> well, putStr or something. printf is overkill
13:43:10 <kadoban> luite: That doesn't sound good :-/
13:43:18 <Fuuzetsu> @pl f x y = g x >< g y
13:43:18 <lambdabot> f = (. g) . (><) . g
13:43:50 <geekosaur> rrradical, both are in active development but each has a somewhat different focus
13:44:07 <kadoban> This sure is impossible to google for too, what fun...
13:44:15 <luite> kadoban: can you run the installation with -v from the current dir? then strace the command that fails?
13:44:15 <Fuuzetsu> is there something more idiomatic than (><) `on` id ?
13:44:23 <Fuuzetsu> that id looks nasty there
13:44:32 <Fuuzetsu> wait, I forgot a bit
13:44:35 <levi> rrradical: hoogle does index all (or at least most) of hackage, but only searches in a subset by default. You can give it additional modules to search. FPComplete has a hoogle instance running that searches more by default; you could try using that.
13:45:03 <geekosaur> in particular, hayoo is an example application of holumbus's search API and is likely to be more interested in that than in competing head on with hoogle
13:45:19 <kadoban> luite: Sure, let me see if I can figure that out
13:45:40 <pqmodn> Fuuzetsu: isn't f `on` id == f?
13:45:54 <rrradical> geekosaur: oh interesting
13:45:57 <geekosaur> ah, hunt, not holumbus (that was old hayoo)
13:46:07 <Fuuzetsu> pqmodn: maybe, which is why I realised that I was forgetting a bit
13:46:13 <Fuuzetsu> I'm basically trying to get
13:46:14 <Fuuzetsu> append (YiString t) (YiString t') = YiString $ t T.>< t'
13:46:15 <Fuuzetsu> to be nicer
13:46:17 <rrradical> levi: neat, I didn't know that. I'll check it out
13:46:33 <Fuuzetsu> where I can extract the ‘t’s with ‘fromRope’
13:46:47 <luite> kadoban: first 'cabal unpack' that network package, then 'cabal install -v'
13:48:17 <kadoban> Okay, did that. Looking at the output now...there's a bit here
13:48:46 <pqmodn> Fuuzetsu: (><) `on` fromRope gets you partially there. then composing with the final YiString wrapper messes it up a bit, but (YiString .) . (><) `on` fromRope
13:49:16 <kadoban> Hmm okay I guess I see the command that's failing. So just run that in strace and see?
13:49:17 <Fuuzetsu> yeah, I got that far and decided it was uglier and harder to read than the dumb way
13:49:22 <pqmodn> :-)
13:49:33 <eacameron> where can I find more info on how the GHC runtime handles threads and FFI? My FFI-heavy app appears to be only using 2 threads even though it *should* be able to use dozens
13:49:34 <pqmodn> function composition with functions that take more than one argument usually is hard to read
13:49:53 <pqmodn> too bad, because it *almost* would be very readable!
13:49:56 <eacameron> or does threadscope not show FFI-based threads??
13:51:08 <jle`> pqmodn: there are some attempts/proposals at idioms to handle this
13:51:24 <jle`> pqmodn: for myself i like to just be able to think of all haskell functions as taking one argument, and keep one point
13:51:34 <pqmodn> jle`: oh i'm curious, which ones?
13:51:51 <jle`> well, people have been asking to bring (.:) into base for a while
13:51:55 <pqmodn> ah
13:52:03 <jle`> and i think it's been used in some fairly reputaable papers
13:52:11 <jle`> f .: g = \x y -> f (g x y)
13:52:20 <jle`> for me i don't mind doing foo x = bar . baz x
13:52:23 <tibbe> Does StateT suffer from quadratic slowdown if >>= recurs on the left side?
13:52:29 <tibbe> Like LogicT?
13:52:34 <tibbe> And how about ReaderT?
13:52:39 <pqmodn> yeah, there are a whole pile of similar ones in Data.Composition
13:52:54 <jle`> yeah, i just do'nt think that introducing new operators is really a good go-to solution for any problem
13:52:58 <kadoban> luite: Hmm. There's a /lot/ of output from strace of course, and nothing I see is obviously wrong at the end. Any idea what I should be looking for? I can post it somewhere if needed.
13:53:16 <Arceiidys> Hoola?
13:53:46 <luite> kadoban: are you running that underlying command under strace, since cabal will invoke that other thing, which will run into the problem
13:53:54 <pqmodn> i'm OK with just avoiding it. i started pursuing a fully point-free concatenative language, where it's quite beautiful but there are many other expressions that are very ugly in such a syntax!
13:54:22 <fiore> who
13:54:29 <Arceiidys> :-*
13:54:43 <kadoban> luite: Yeah, it looks like the command that's failing is the ./configure, I'm running... 'strace sh ./configure ....', I copied from the cabal install -v output
13:55:13 <Arceiidys>  Español?
13:55:37 <mauke> strace -f
13:55:45 <jle`> pqmodn: haskell's curried convention makes general composition like you imagine it to be a little tricky
13:56:11 <kadoban> Oh, I'll try that
13:57:35 <kadoban> Heh, even more output...lemme see if I can find anything obviously wrong
13:59:10 <luite> kadoban: yeah strace -f is a good idea. look for EBADMSG, EFTYPE, EISDIR, ENOTDIR errno values
14:00:10 * hackagebot unix 2.7.0.1 - POSIX functionality  http://hackage.haskell.org/package/unix-2.7.0.1 (HerbertValerioRiedel)
14:03:07 <kadoban> Hmm, there's a bunch of ENOTDIR because my $PATH has a bad entry, let me fix that and try again...
14:05:10 * hackagebot unix 2.6.0.0 - POSIX functionality  http://hackage.haskell.org/package/unix-2.6.0.0 (HerbertValerioRiedel)
14:05:12 * hackagebot unix 2.6.0.1 - POSIX functionality  http://hackage.haskell.org/package/unix-2.6.0.1 (HerbertValerioRiedel)
14:05:51 <RyanGlScott> How do you change where the package-db is located? By default, it seems to be ~/.ghc/<arch-os-ver>/package.conf.d in Linux.
14:06:51 <RyanGlScott> (The user package-db, I should say.)
14:07:53 <geekosaur> usually by making a sandbox :) why?
14:08:36 <RyanGlScott> I'm on a network system where certain directories are cleared every time you log off. I need to install all of the package-db/cache stuff elsewhere.
14:09:22 <carter> RyanGlScott: mess with your ~/.cabal/config
14:09:42 <kadoban> luite: Hmm, well I guess that fixed it. The problem seems to be that I had '~/bin/git/bin' in my $PATH, where '~/bin/git' is an executable file, not a directory.
14:09:53 <kadoban> Now 'network' installed fine
14:09:54 <luite> kadoban: awesome
14:10:00 <kadoban> So, thanks very much for the help! :)
14:10:09 <koala_man> kadoban: be careful with literal tildes in PATH
14:10:19 <monochrom> no, ~/.ghc is fairly hardcoded into GHC.
14:10:37 <kadoban> Oh, yeah they're not literal, I just wrote that since it was shorter, sorry
14:11:07 <luite> kadoban: thanks too, i know where to look next time :)
14:11:09 <RyanGlScott> There's no way to tell GHC/cabal to simply use a different directory than ~/.ghc?
14:11:23 <carter> RyanGlScott: .... probably some flag
14:11:24 <kadoban> Hehe
14:11:50 <monochrom> I have seen no flag of the sort.
14:12:04 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/users_guide/packages.html#ghc-package-path
14:12:06 <carter> luite: you do a custom .ghc like path dir right?
14:12:06 <mauke> let's see if google picks this up
14:12:22 <c_wraith> spopejoy: much of what HList does can be done with DataKinds/GADTs now.  data HList (t :: '[*]) where Nil :: Hlist '[] ; Cons :: a -> HList as -> HList (a:as)
14:12:27 <mauke> sh: inappropriate type in cabal configure? check your $PATH entries
14:12:30 <luite> carter: .ghcjs yes
14:12:38 <dmj`> anyone use http-streams here?
14:12:42 <RyanGlScott> Hm, GHC_PACKAGE_PATH sounds promising. I'll mess with that and see what happens.
14:12:57 <luite> RyanGlScott: cabal will probably complain, and i think it's a deprecated feature
14:12:58 <monochrom> but cabal hates GHC_PACKAGE_PATH
14:12:58 <c_wraith> spopejoy: that's the same core data structure - lots still would need to be done to make the interface as usable.
14:13:21 <RyanGlScott> Ah, darn. What's intended to replace GHC_PACKAGE_PATH?
14:13:23 <kadoban> mauke: Good idea, it'd be nice if they do pick that up, as-is there wasn't anything unfortunately.
14:13:29 <monochrom> not to mention that GHC_PACKAGE_PATH still does not change the fact that --user is hardcoded to ~/.ghc
14:13:39 <spopejoy> c_wraith: thanks. off to study DataKinds ...
14:13:42 <monochrom> nothing
14:14:07 * geekosaur wonders if making ~/.ghc a symlink to somewhere else would work
14:14:09 <c_wraith> spopejoy: there's also the vinyl package in this space.  It's worth a look, but I haven't used it.
14:14:17 <monochrom> all this means is that you have to enter "cabal install --package-db=blah" by hand and "ghci -package-db=blah" by hand
14:14:27 <geekosaur> possibly doing so in ~/.profile or whatever
14:14:28 <spopejoy> Is DataKinds in GHC 7.8.3?
14:14:28 <luite> RyanGlScott: cabal sandboxes don't use ~/.ghc
14:14:52 <luite> RyanGlScott: but that's not really a replacement yet...
14:15:00 <monochrom> yeah, perhaps you will like to be permanently trapped in a sandbox
14:15:22 <luite> also they're a tad too leaky
14:15:31 <luite> but that's not really an issue here
14:15:35 <exio4> what about symlinks?
14:15:36 <RyanGlScott> Is it possible to force ghci to always use the sandbox?
14:15:47 <luite> RyanGlScott: you can use cabal repl instead
14:15:49 <monochrom> the symlink may get erased, too
14:15:55 <RyanGlScott> So that I don't always have to cd; cabal repl all the time
14:16:04 <luite> RyanGlScott: oh in that case i don't know :)
14:16:07 <monochrom> well, I guess you can create it again
14:16:11 <pqmodn> alias ghci=cabal repl
14:16:11 <exio4> re-creating a symlink isn't that hard
14:16:26 <geekosaur> recreating it on login is what I meant about ~/.profile
14:16:29 <c_wraith> spopejoy: Yes, DataKinds was added in GHC 7.6
14:16:44 <geekosaur> as long as the package db is in stable storage somewhere, creating a symlink in .profile is trivial
14:17:00 <deni> mauke: what about printf "%s%s" "bla" True (or show True)?
14:17:15 <deni> mauke: that doesn't work obviously
14:17:20 <RyanGlScott> On a related note, what is the --package-db flag in cabal's config file for?
14:17:42 <mauke> > "" ++ printf "%s%s" "bla" (show True)
14:17:43 <lambdabot>  "blaTrue"
14:17:49 <RyanGlScott> It doesn't seem to be quite what I'm looking for, since setting it to a non-existent file will cause cabal to complain.
14:18:06 <RyanGlScott> Whereas not using it will cause cabal to automatically generate a package-db in ~/.ghc
14:18:19 <RyanGlScott> even if it isn't already created
14:21:15 <monochrom> no, cabal doesn't create things in ~/.ghc, does not even read directly. ghc does. cabal justs asks ghc.
14:22:07 <monochrom> next, the ~/.ghc database is treated differently from --package-db databases. By ghc. ghc is happy to auto-init ~/.ghc for you. but not happy to auto-init anything else.
14:22:33 <monochrom> read my http://www.vex.net/~trebla/haskell/sicp.xhtml#sandbox for how to use it.
14:22:52 <RyanGlScott> So if I were to create a package-db directory manually and pass it to --package-db, could that conceivably work?
14:23:09 <monochrom> yes, I have always done it. I even wrote shell functions.
14:23:19 <RyanGlScott> Ah, that sounds promising then.
14:23:52 <RyanGlScott> Does it have to be structured like <arch-os-ver>/package.conf.d, or can you name it whatever you want?
14:24:05 <monochrom> in the ghc+cabal infrastructure, there are a lot of special-casing you wouldn't believe.
14:24:30 <monochrom> basically you cannot generalize anything.
14:24:51 <RyanGlScott> Then I'll be as careful as possible, I suppose.
14:24:52 <monochrom> no, name it whatever you want
14:25:30 <RyanGlScott> Is it sufficient to just create a package.cache file and give it its containing directory?
14:25:53 <monochrom> yes. read my article.
14:26:05 <deni> mauke: tnx...stupid me was missing the braces
14:26:34 <monochrom> or no, depending on what you mean. read my article.
14:26:36 <RyanGlScott> Ah, sorry. I'll RTFA.
14:29:19 <monochrom> I guess I should give a shell command for the text-file case so you see what role the pathname plays.
14:30:13 * hackagebot io-streams 1.1.4.6 - Simple, composable, and easy-to-use stream I/O  http://hackage.haskell.org/package/io-streams-1.1.4.6 (DougBeardsley)
14:30:19 <deni> how would i go about having multiple declarations of the same function but with a different return type? I thought that haskell does dispatching on the return type as well?
14:31:15 <Fuuzetsu> is there a reason that there's no Binary instance for Text?
14:32:14 <folex> Hi all.
14:32:15 <folex> https://raw.githubusercontent.com/ghc/ghc/master/libraries/ghc-prim/GHC/Tuple.hs
14:32:15 <folex> Can anyone explain segfault?
14:32:23 <folex>  > {- Manuel says: Including one more declaration gives a segmentation fault.
14:32:28 <coppro> probably a stack smash
14:32:35 <coppro> by which I mean overflow
14:33:12 <folex> Isn't there a way to define such things through macro or some other code-generation? *not really into haskell*
14:33:13 <monochrom> updated
14:33:18 <Fuuzetsu> s/Manuel/Manual/
14:33:22 <deni> or should i just use either here
14:33:25 <Fuuzetsu> I was trying to resolve who Manuel was
14:33:33 <Fuuzetsu> or is it actually a person called Manuel
14:33:43 <folex> yeah, I guess it's a person
14:34:08 <folex> maybe this one http://www.cse.unsw.edu.au/~chak/papers/
14:34:29 <Fuuzetsu> maybe!
14:35:06 <joelteon> read the Manuel
14:35:15 * hackagebot directory 1.2.1.0 - library for directory handling  http://hackage.haskell.org/package/directory-1.2.1.0 (HerbertValerioRiedel)
14:36:52 <folex> Is there any easy way to look at C code that gets generated from this definition of tuple?
14:36:53 <deni> when i read that haskell does dispatch on the return type does that mean that bla :: String -> IO (Text) and bla :: String -> IO () ca coexists in the same namespace?
14:37:01 <deni> or is IO somehow special here?
14:37:16 <merijn> folex: What C code are you talking about?
14:37:16 <deni> ie is it looking only at the "wrapping" type not what's inside?
14:37:29 <geekosaur> folex: ghc does not generate C code
14:37:54 <merijn> deni: Haskell doesn't have overloading so two functions with the name bla can't exist in the same namespace, period.
14:37:58 <monochrom> deni, that is done using type classes, and IO is not special for this.
14:38:43 <folex> merijn, geekosaur, yeah, there is really no C generated, sorry
14:39:31 <deni> merijn: what do ppl mean then when they talk about dispatching on the return type?
14:39:46 <deni> monochrom: can you do a quick dpaste? or point me at a link?
14:40:27 <monochrom> I can do neither. but I can refer you to the type class Bounded which is in the standard library.
14:40:33 <deni> monochrom: i assume you mean using bounded polymorphism. ie MyTypeClass a => Sring -> a
14:40:41 <monochrom> yes.
14:40:59 <deni> monochrom: yes but that stull won't solve the issue if there are 2 instances in scope right?
14:41:06 <deni> s/stull/still/
14:41:18 <merijn> > minBound :: Char
14:41:19 <lambdabot>  '\NUL'
14:41:21 <merijn> > minBound :: Int
14:41:22 <lambdabot>  -9223372036854775808
14:41:29 <monochrom> I don't understand what issue. Play with the Bounded type class first.
14:41:57 <monochrom> It is the simplest possible example. So simple you wouldn't believe it.
14:42:18 <monochrom> or perhaps s/simple/minimal/
14:42:35 <deni> monochrom: if i make String an instance of MyTypeClass and Bool and instance of MyTypeClass...then bla :: MyTypeClass a => String -> a won't work if both instances are in scope...is what i meant
14:42:39 <merijn> monochrom: I think Default would be more minimal :)
14:42:47 <merijn> deni: Why wouldn't it?
14:42:50 <merijn> I just showed you
14:43:04 <merijn> :t minBound
14:43:05 <monochrom> oh! Default is the most minimal. but it is not in Prelude or come with GHC
14:43:05 <lambdabot> Bounded a => a
14:43:17 <monochrom> anyway, have you played with Bounded yet?
14:43:43 * monochrom does not like people ignoring his suggestions
14:43:44 <deni> merijn: monochrom  you're right....i was just confused...it's late here :D
14:44:00 <deni> merijn: monochrom tnx
14:49:08 <IRC_Client> status: wumbo
14:49:10 <Fuuzetsu> hvr: you're a Travis man, right? Can you spare 2 mins to look at https://travis-ci.org/yi-editor/yi/jobs/34945080 ?
14:49:28 <Fuuzetsu> I'm suspecting the new text release or something, it worked fine on commit but now it doesn't ;(
14:50:34 <folex> merijn, geekosaur, sorry for highlighting, but are you sure that there is no C generated? https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/GeneratedCode
14:51:44 <merijn> -via-C compilation hasn't been compiled into GHC for years
14:52:00 <merijn> It only exists for porting to new architectures and requires custom compilation of GHC with it enabled
14:52:42 <folex> I see. Thanks
14:52:54 <geekosaur> and last I heard it was buggy
14:53:02 <merijn> geekosaur: It is
14:53:05 <merijn> It's bitrotted
14:53:07 <geekosaur> modern code generation is 0fasm or -fllvm
14:53:11 <geekosaur> er -fasm
14:54:36 <geekosaur> basically -fvia-C required fighting the C compiler, because most C optimizations are pessimizations for Haskell and most of the function call overhead in C is unnecessary in Haskell
14:54:57 <geekosaur> a big ugly perl script, fondly known as the evil mangler, attempted to correct for this
14:55:33 <folex> well, anyways, just for look at it — it should be fine, shouldn't it?
14:55:47 <geekosaur> not really, it's far from idiomatic
14:56:03 <folex> can you explain 'idiomatic' in this context?
14:56:08 <geekosaur> if you want to see C code generated from Haskell code, jhc / ajhc may be more to your liking
14:56:58 <geekosaur> it generates very ugly code, basically amounting to assembler-written-in-C, to defeat various C "optimizations" that aren't optimizations for Haskell. also it's reflecting how Haskell code is evaluated, which is much different from C
14:57:41 <geekosaur> it's not really readable, it's not really comprehensible unless you understand the STG machine
14:58:15 <chirpsalot> Hmmm. A little annoying that Codec.Archive.Tar, and Codec.Archive.Zip, etc... are all pretty different. Is there an all encompasing "archive" library that presents a common interface that I have been unable to find?
14:59:26 <folex> geekosaur: all I actually want is to see how could tuple definition generated stack overflow. That's interesting since I thought such things could be optimized from recursion to something else like inlining or just cycle...
14:59:35 <folex> generate*
14:59:46 <chirpsalot> What's there is sufficient, but if there's a commonly used "extract" function that works the same on any type of archive without having to wrap everything that'd be nice!
14:59:52 <geekosaur> um. stack overflows in Haskell don't relate to stack overflows in C
15:00:08 <folex> uhm…
15:00:19 <geekosaur> Haskell's stack is a stack of pending pattern matches
15:00:40 <geekosaur> evaluation in Haskell is completely different from evaluation in C
15:00:44 <folex> so, Haskell's stack overflow would produce segfault?
15:01:40 <geekosaur> also I think that stack is actually in the heap, as you'd think of it from C. C's stack is almost not used
15:01:43 <Cale> folex: no, not generally
15:01:48 <monochrom> folex, perhaps read my http://www.vex.net/~trebla/haskell/lazy.xhtml
15:02:00 <Cale> (I have no proof that it'll never do so, but I've never seen that)
15:02:12 <folex> why would adding one more tuple definition would produce segfault?
15:02:13 <chirpsalot> geekosaur: C's stack is used often?
15:02:25 <geekosaur> what?
15:02:26 <monochrom> GHC's stack is growable now. no overflow.
15:02:29 <folex> monochrom: I'll read, thanks.
15:03:17 <chirpsalot> geekosaur: what do you mean that "C's stack is almost not used?"
15:03:27 <monochrom> I think geekosaur means that GHC doesn't use C stack.
15:03:38 <chirpsalot> Oh. Yeah, okay.
15:03:44 <geekosaur> what it says: the only usage is that when you call a function, it gets no parameters and immediately returns a thunk
15:03:53 <monochrom> or even, screw C, the x86 stack pointer stack.
15:04:00 <geekosaur> minimal space usage, no nested C-style calls
15:04:29 <chirpsalot> I should really go through how GHC compiles stuff. Seems interesting.
15:04:54 <Cale> chirpsalot: As a first approximation to that, check out the paper on the Spineless Tagless G-machine...
15:05:10 <Cale> http://www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf
15:06:21 <chirpsalot> Cale: ah, okay. Pretty sizable paper, that :).
15:06:45 <Cale> and it's not even really up to date :)
15:06:52 <chirpsalot> Hurray!
15:07:17 <Cale> (but the discussion there is still fairly relevant, and it's a good place to start understanding)
15:07:30 <chirpsalot> That's good.
15:07:42 <geekosaur> anyway, most of the time a segfault in Haskell code means something FFI-related has gone awry
15:08:18 <chirpsalot> Or you've run out of memory?
15:08:50 <folex> But what about https://raw.githubusercontent.com/ghc/ghc/master/libraries/ghc-prim/GHC/Tuple.hs ?
15:08:50 <folex>  > Manuel says: Including one more declaration gives a segmentation fault.
15:08:50 <folex> What's the problem here?
15:09:02 <mjiig> it appears haskell returns a nice error message when you run out of memory rather than seg faulting
15:09:46 <chirpsalot> mjiig: really? Maybe, but it might segfault sometimes depending on how it runs out of memory? *shrug*
15:09:52 <geekosaur> folex: I think that was a segfault inside ghc itself, not in the generated program, and was a bug in ghc
15:09:58 <pqmodn> folex: the compiler segfaults, not your application
15:10:18 * hackagebot docker 0.1.0.0 - Haskell wrapper for Docker Remote API  http://hackage.haskell.org/package/docker-0.1.0.0 (denibertovic)
15:10:40 <etandel> no one should segfault when running out of memory, as long as the return of malloc() and co. are checked.
15:10:43 <folex> ah… That's even kinda obvious. Thanks :)
15:10:45 <structuralist> Is there an earliest reference for codata = terminal coalgebra?
15:10:46 <geekosaur> actually I think it was a bug in the runtime's handling of constructor tags
15:10:46 <mjiig> chirpsalot: I know very little about haskell, but I happen to have run out of memory in ghci several times in the last 10 minutes, so jsut reporting what I've seen :)
15:11:02 <geekosaur> (in the low level C code implementing the runtime)
15:11:11 <chirpsalot> etandel: if you run out of stack space, there is no call to malloc() :P.
15:11:14 <geekosaur> (but it was the compiler that triggered it, not generated programs)
15:11:21 <chirpsalot> etandel: "C" stack, that is.
15:11:31 <structuralist> Earliest I've found is Hagino's thesis (1987): http://www.tom.sfc.keio.ac.jp/~hagino/thesis.pdf
15:11:35 <etandel> geekosaur: but then i'd guess you get a stack overflow error, not a segfault?
15:12:14 <etandel> afaik you get segfault when accessing that you don't "own".
15:12:43 <chirpsalot> mjiig: I thought I made Haskell segfault from running out of memory, but maybe not -- that was a long time ago. Running in ghci, or compiled?
15:13:07 <chirpsalot> etandel: stack overflow often appears as a segfault depending on the system, I think?
15:13:12 <geekosaur> yes. I think this was a bad address generated when working with constructor tags. but there are lots of complexities here
15:13:48 <mjiig> chirpsalot: ghci, I was actually just playing around with what happened when you tried large scale recursion
15:13:48 <geekosaur> in particular a C stack overflow will generate a segfault because of the way the stack is extended on most architectures
15:14:05 <monochrom> I learned to read GHC-generated asm a shorter, less systematic way. I didn't read any of the papers. but I did know lazy evaluation very well. then I compared Haskell code vs GHC core code, then GHC core code vs Cmm code, then Cmm code vs asm code. And read some of the "GHC commentary" on the GHC developer wiki. that's it.
15:14:13 <chirpsalot> mjiig: ghci might behave differently with respect to that.
15:14:33 <geekosaur> (certain specific references off the end of the stack trigger automatic stack allocation by the kernel, suppressing the normal sigfault)
15:15:18 * hackagebot process-streaming 0.5.0.0 - Streaming interface to system processes.  http://hackage.haskell.org/package/process-streaming-0.5.0.0 (DanielDiazCarrete)
15:15:32 <etandel> geekosaur: oh, i see. Well, in my (relatively very) short experience with C of ~6 years, I don't remember seeing a segfault when running out of memory.
15:15:45 <etandel> but i only did linux / windows on x86
15:15:48 <geekosaur> out of which memory? heap? stack?
15:15:54 <mjiig> chirpsalot: I wasn't sure, just thought I'd mention it
15:15:59 <etandel> geekosaur: both
15:16:01 <chirpsalot> etandel: depends how you run out of memory. malloc() is different from stack.
15:17:10 <etandel> i know, it's just that whenever I ran out of stack space I got a stack overflow, and when I ran out of heap space, mallock would just return NULL. And I got segfault when accessing free'd or non-alloc'd memory.
15:17:16 <geekosaur> heap grows up, stack grows down, shared objects get address space carved out in between, running into one of them while extending either the heap (brk() / mmap() via malloc()) or stack (automatic stack probes generated in function preambles) may trigger a segfault or other signal depending on kernel memory management implementation decisions
15:17:27 <geekosaur> right
15:17:28 <etandel> but, like i said, my C experience is somewhat limited.
15:18:08 <geekosaur> the difference between those is that heap extension is always under direct program control, while stack extension is always automatic
15:18:13 <geekosaur> and invisible to the program
15:18:29 * mgaut72 feels like he just walked into a C channel
15:19:48 <geekosaur> actually this is lower level stuff than even C normally deals with :)
15:19:51 <etandel> indeed, it's a bit OT for #haskell.
15:38:02 <Algebr> does tex count as a declarative programming language?
15:38:19 <pqmodn> depends on which definition of declarative you mean
15:38:26 <Algebr> (and why does the output look so damn good)
15:39:06 <Algebr> pqmodn: hmm, declarative insofar as I tell it my content and it best figures out alignments and such?
15:39:13 <pqmodn> then yes :-)
15:39:21 <monochrom> if you understand "leaky abstraction", tex is a leaky declarative language, even latex is.
15:39:47 <dreams> monochrom: leaky in the sense of memory?
15:39:53 <mgaut72> monochrom: whats a leaky abstraction? / is there a good reference you know for learning?
15:40:15 <hpc> a leaky abstraction is one that doesn't totally hide what it tries to hide
15:40:16 <Algebr> mgaut72: pretty sure its  areference to that spolsky (sp?)article
15:40:25 <dreams> Ah nice.
15:40:31 <hpc> for instance, if you wrote a completely arbitrary abstraction over the 'ls' command
15:40:54 <hpc> and you had list, listPlusHidden, listPlusStat
15:40:56 <hpc> that'd be nice
15:41:12 <mgaut72> <sarcasm>woah, a term that means exactly what it souds like</sarcasm>
15:41:20 <hpc> but then it leaks because what if you need --directory
15:41:31 <dreams> mgaut72: yeah I felt stupid.
15:41:35 <hpc> so the api author provides listWithParams
15:41:59 <hpc> but now someone defines listDirectories = listWithParams ["--directory"]
15:42:08 <mgaut72> hpc: so listWithParams would just perform a transparent passthrough, thus, no abstraction
15:42:11 <hpc> and now your code using listDirectories is dependent on the implementation of ls
15:42:17 <hpc> leaky abstraction
15:42:38 <hpc> (bear in mind this example is ridiculously contrived, but you get the spirit of it)
15:42:47 <mgaut72> definitely, thanks
15:43:04 <Algebr> to be fair, nearly everything leaks.., cuts in prolog for example.
15:43:26 <hpc> yeah, that's the other side of it
15:43:41 <mgaut72> Algebr: splain plz? I'm vaguely familiar with prolog
15:43:44 <hpc> for a ridiculous example along the same lines, ls leaks some kernel details
15:43:51 <hpc> if you try and list a directory with millions of files
15:44:11 <hpc> it just can't
15:44:26 <hpc> but a relatively trivial re-implementation of ls can do it like a champ
15:44:38 <hpc> (with other side-effects iirc)
15:45:34 <Algebr> mgaut72: you give prolog some "facts" about the world and some inferences, it then uses those two things to get an answer for a query(a question) Sounds pretty declarative, but the path that it takes can be stupid/poor so you can give it cuts, aka tell it/influence it as to what path to take
15:45:53 <Algebr> (someone more knowledge about prolog please correct me if wrong)
15:46:39 <mgaut72> Algebr: let me clarify.  I understand enough prolog to know what a cut is, but can you explain it from a "leaky abstaction" point of view
15:47:17 <mgaut72> or is it just the fact that youre not really allowing prolog to "explore" all possible solutions
15:47:19 <Algebr> its somewhat leaky because you're telling/influencing the path it takes to get an answer instead of prolog figuring it out
15:47:28 <vanila> Algebr, that is all correct except that cut doesn't tell it what path to take - it makes it commit to the curent path (cuts off all alternatives)
15:47:43 <Algebr> vanila: it prematurally kills that path right?
15:47:55 <Algebr> err, kills the other paths
15:48:03 <vanila> yes, that can save space beacuse it doesnt have to remember to check that path too
15:48:16 <vanila> but it can mean that if there was a solution in that path, you wont see it
15:49:26 <mgaut72> want you put it like that, it almost seems like a cut isn't leaky, but aggressively not leaky
15:49:42 <vanila> cut is "non logical" - it doesna't make any sense
15:49:46 <vanila> it's the "goto" of logic programming
15:50:15 <vanila> and haskell has 'seq' and unsafePerformIO and things,  why do programming have these awful things?
15:50:26 <Fuuzetsu> I'm trying to implement something to ‘cut off’ the last n lines from Text. It should give ‘cutExcessB 2 "a\nb\nc\nd\ne\nf\n" => ("a\nb\nc\nd\n","e\nf\n")’ and ‘cutExcessB 2 "a\nb\nc\nd\ne\nf" => ("a\nb\nc\n","d\ne\nf")’. I just can't think of a clean and efficient way to implement this, any ideas?
15:50:32 <mgaut72> :t seq
15:50:33 <lambdabot> a -> b -> b
15:51:16 <Fuuzetsu> vanila: why is seq awful?
15:51:28 <Fuuzetsu> bar being a compiler implementation
15:52:02 <exio4> is there any use of unsafePerformIO outside FFI?
15:52:07 <vanila> Fuuzetsu, that's all really
15:52:23 <Fuuzetsu> vanila: that's a pretty poor reason
15:52:32 <Fuuzetsu> exio4: global variables ;P
15:52:33 * mgaut72 just hoogled seq
15:52:52 <mgaut72> it seems like its bad because it takes away the default lazy evaluation of haskell.  thus "leaky"
15:52:54 <exio4> Fuuzetsu: doesn't like a good usage
15:53:04 <Fuuzetsu> you asked for *any* use, not good use!
15:53:20 <exio4> well, any decent use? ;P
15:53:37 <Fuuzetsu> Data.Trace.trace
15:53:49 <vanila> I'm not a fan of the idea of leaky-whatevers - cut, goto, seq/unsafe break the assumptions we could have made about code in our reasoning
15:54:22 <Fuuzetsu> last time I checked, ! doesn't stop you from reasoning about anything
15:54:22 <vanila> with cut we don't have a logical interpretation of the program,  goto you can't divide it into structured blocks, with unsafe you not longer have referential transparency
15:55:23 * hackagebot validation 0.4.1 - A data-type like Either but with an accumulating Applicative  http://hackage.haskell.org/package/validation-0.4.1 (TonyMorris)
15:55:37 <mgaut72> ! is similiar to seq in that it forces evaluation, but at the data type level?
15:56:58 <exio4> it is syntatic sugar for seq
15:58:32 <mgaut72> exio4: I know bang is a keywork, but wouldnt it be something like " ! a = seq a a"
15:59:04 <jfischoff> seq a a is a noop
15:59:53 <jfischoff> seq makes dependencies there is a good article on the haskell wiki about it
16:00:06 <mgaut72> i think i just found that
16:00:44 <merijn> "seq a b" says at the end of evaluating "seq a b", both 'a' and 'b' will have been evaluated IF neither 'a' nor 'b' was bottom
16:03:14 <exio4> we should use (seq (unsafePerformIO (putStrLn "...")) undefined) everywhere, shouldn't we?
16:03:28 <vanila> lol
16:04:27 <chirpsalot> Is doing something like this reasonable? http://lpaste.net/1205527668502560768 I feel a bit silly.
16:05:01 <vramana> I am looking at this coursera https://www.coursera.org/course/algs4partI I am wondering if there is any good haskell/fp book that deals with both data structures and algorithms.
16:06:02 <chirpsalot> I guess where clauses make more sense.
16:07:39 <chirpsalot> Or let bindings, rather.
16:07:52 <exio4> you could use liftM
16:08:33 <chirpsalot> exio4: ah, I see.
16:09:09 <exio4> (or <$>, or fmap)
16:09:34 <chirpsalot> exio4: yeah. But I can actually just turn it into a let, and that probably just makes the most sense.
16:10:04 <chirpsalot> Although, if you tell me that's terrible I will probably believe you :).
16:10:07 <exio4> there are a lot of ways to do the same thing
16:10:07 <mgaut72> exio4: on that note, is there a rule of thumb on when to use (liftM | fmap | <$>) ?
16:10:44 <exio4> mgaut72: use the one that looks "nicer"? :P
16:11:25 <mgaut72> i personally think applicative notation is aesthetically pleasing :p
16:12:05 <exio4> chirpsalot: I'm "just" learning Haskell, I just said other ways to do the same thing
16:12:41 <chirpsalot> exio4: I am just learning as well, so those other ways are appreciated! I did not think of them with my tiny bren.
16:12:48 <matt1> hey everyone, i'm new to haskell and I wrote some terrible code, can anyone help me make it less awful?
16:12:58 <dmj`> matt1: sure
16:12:59 <chirpsalot> matt1: paste it.
16:13:03 <mgaut72> matt1: take a look at hlint too
16:13:11 <matt1> https://gist.github.com/mr/294b04e5fbcd804a1bc1
16:13:15 <mgaut72> it gives really good advise
16:13:20 <chirpsalot> mgaut72: hlint is sooooo good.
16:13:23 <matt1> i'm trying to parse some json
16:13:31 <matt1> i'll look at hlint as well
16:13:38 <chirpsalot> matt1: use Aeson?
16:13:55 <matt1> chirpsalot: i am, but the code i wrote seems super verbose
16:13:56 <mgaut72> matt1: it parses your code and tells you how to make it more idiomatic.  kinda nice
16:14:23 <matt1> mgaut72: yeah i think syntastic in vim actually runs it after the code actually compiles
16:14:26 <vanila> Is anyone using haskell to write very short/easy to read understand compilers?
16:14:39 <vanila> (for any language)
16:14:48 <chirpsalot> vanila: ANY language?
16:14:57 <mgaut72> vanila: I am currently using Parsec for a C subset
16:15:04 <vanila> wll except esolangs like brainfuck
16:15:09 <fddfdfff> vanila: hey, wanna continue yesterday cps discussion?
16:15:13 <vanila> fddfdfff, sure
16:15:21 <vanila> mgaut72, good luck! What is your project?
16:15:23 <Sorella> vanila: I think PureScript fits that definition. I might rewrite Purr in Haskell, if I don't end up making it self-hosted.
16:15:28 <shachaf> If you have a long discussion it might be better in #haskell-overflow.
16:15:43 <vanila> thanks Sorella
16:15:51 <Sorella> Though I guess it depends a little on what you call "short". PureScript is definitely easy to read though, and pretty well organised
16:15:57 <mgaut72> vanila: my project is school :p http://www.cs.arizona.edu/classes/cs453/fall14/
16:16:07 <vanila> that's the most important thing: that it can be understood easily
16:16:36 <matt1> i don't know if anyone is still looking at my code, but I can explain what it's doing if the comments don't give enough context
16:16:53 <fddfdfff> shachaf: wasn't aware of that channel, thanks.  I'll start here and jump there if it gets too long.
16:17:12 <chirpsalot> mgaut72: are you kidding me? Your school does a Haskell compilers course?
16:17:43 <mgaut72> chirpsalot: no, I'm just sticking it to the man.  As long as it compiles on the CS server, its all good
16:17:56 <mgaut72> chirpsalot: the class is taught using flex/yacc or something
16:18:16 <chirpsalot> mgaut72: oh okay, ours is now in Java and Antlr and I was about to be real salty :P.
16:18:19 <fddfdfff> vanila: iirc, merijn mentioned yesterday that haskell functions are not stored on the stack.  do you know why?  does it mean there's no point in using cps to benefit from tco?
16:18:22 <Sorella> More schools should use Haskell for a compiler course. Or at least some ML dialect. They're really the best for this
16:18:53 <jle`> hear hear
16:18:56 <mgaut72> the biggest problem I have come across is that "error recovery" is a requirement. but parsec just gives up on error
16:18:59 <pqmodn> fddfdfff: i can't answer at the moment but try reading this http://www.vex.net/~trebla/haskell/lazy.xhtml
16:19:03 <vanila> fddfdfff, haskell is lazy so it works entirly different from scheme which is strict (it evaluates its arguments before calling a function)
16:19:19 <chirpsalot> mgaut72: doesn't Parsec have ways of handling that?
16:19:29 <Sorella> mgaut72: you just give it an alternative, no?
16:19:35 <jle`> ffledgling: yeah, the evaluation semantics don't really make sense in the context of a traditional call stack
16:19:45 <jle`> oh sorry, fddfdfff
16:19:46 <Sorella> Or do you mean you want to disambiguate things based on a larger portion of the AST?
16:20:07 <ffledgling> I had a little whaa moment there
16:20:08 <mgaut72> im not sure really
16:20:10 <Sorella> (I don't think Parsec can do that since it just chooses the first alternative, rather than accumulating all the possible parse trees)
16:20:14 <jle`> ffledgling: sorry :)
16:20:20 <ffledgling> np :)
16:20:22 <mgaut72> I am under the impression that (<|>) is not sufficient for what I need
16:20:40 <exio4> you could use bnfc
16:20:59 <mgaut72> I was trying to think of a way to mimic "error" from yacc/bison: https://www.gnu.org/software/bison/manual/html_node/Error-Recovery.html
16:21:00 <exio4> it is basically "write a bnf with labels and get a parser"
16:21:02 <chirpsalot> Parsec is so good. Agh. Everything in Haskell is just so good.
16:21:13 <jle`> mgaut72: can you explain your situation more?
16:21:31 <fddfdfff> jle`: but isn't the heap slow?  and does it matter in this case?
16:21:45 <mgaut72> so here is the grammar: http://www.cs.arizona.edu/classes/cs453/fall14/DOCS/cminusminusspec.html
16:22:12 <pqmodn> you can also generate multiple parse trees from ambiguous grammars using GLR like Happy (though I've not used it, maybe it's painful) http://www.haskell.org/happy/doc/html/sec-glr.html
16:22:36 <jle`> fddfdfff: heap isn't really as slow as you might think
16:23:09 <jle`> fddfdfff: in any case, it just simply doesn't make any "sense" to have functions evaluate on a traditional call stack
16:24:00 <jfischoff> exio4: there is also bnfc-meta
16:24:31 <jfischoff> which lets write a bnfc in Template Haskell, and generates a parser, quasiquoter, prettyprinter, and the types
16:24:33 <jle`> at the low level we have a call stack to actually implement the evaluation model of haskell, but you shouldn't expect this to correspond in any meaningful way to the semantics of the functions you are calling
16:24:39 <fddfdfff> jle`: okay, but it's still possible to get a stack overflow due to unevaluated thunks, right?  so what's stored on the stack?
16:24:59 <mgaut72> suppose I am parsing an if statement: "ifP :: Parser Statement" "ifP = do {reserved "if"; symbol "(" e <- expressionP" ... if i get past the "if (" part, its clearly an if statement, but if the expression parser errors, ifP errors and has no other options.  I would like something that realizes the error state, and might just parse away junk until it sees a closed paren, like yacc/bison would
16:25:02 <geekosaur> are we back on thsi confusion again?
16:25:03 <fddfdfff> or am I misunderstanding?
16:25:14 <jle`> yeah, the overflow doesn't come from function evaluation, it comes from the implementation of thunks and their evaluation
16:25:23 <jle`> i mean, from function "calls"
16:25:45 <jle`> if you get a stack overflow, it isn't from an overflow of the actual functions you are calling in your haskell code
16:26:01 <jle`> it's from the low level implementation of the evaluation model of whatever runtime system you are using
16:26:17 <jle`> which may or may not correspond to the functions you directly call in your code
16:26:53 <Sorella> mgaut72: hmm, so you'd need to generate partial parse trees in the presence of errors?
16:27:00 <jle`> in an ideal world we wouldn't have to worry about the low level implementation, and it would be all abstracted over and we would ever need to touch it, but sometimes it isn't so easy :/
16:27:37 <fddfdfff> jle`: (in theory) is it possible to not have overflows on the thunk level?
16:27:42 <jle`> i like to think of haskell as a program specification (describe what your program is meant to accomplish) language, instead of an actual "tell a computer how to do this" language
16:27:45 <fddfdfff> jle`: that is, implement it differently.
16:27:47 <mgaut72> Sorella: kinda, it seems like I would need an error type that fit into my syntax tree, then I can keep going
16:27:48 <mgaut72> brb
16:28:00 <jle`> you lay out what your program is intended to accomplish, and your compiler and runtime system work together to make it happen
16:28:14 <vanila> jle`,  I like that viewpoint
16:28:40 <exio4> isn't that the viewpoint of "any" declarative programming language?
16:28:47 <vanila> exio4, yes
16:28:49 <jle`> fddfdfff: this is where one would bring in the meme "sufficiently smart compiler" :P
16:29:13 <jle`> exio4: yeah, but we're talking in comparison to languages like scheme, where function calls correspond directly to call stack allocations, etc.
16:29:17 <vanila> exio4, and this viewpoint is just what the stuff we were talking about earlier breaks
16:29:17 <exio4> given a sufficiently smart compiler, there wouldn't be programmers, because the compiler would do everything!
16:29:18 <fddfdfff> jle`: thanks for the clarification.
16:29:32 <exio4> oh
16:29:35 <jle`> fddfdfff: it is difficult to do naively
16:29:42 <Sorella> exio4: GHC is almost there :P
16:30:04 <jle`> fddfdfff: without proper strictness analysis, it's fairly easy to make enough thunks to overflow RAM
16:30:12 <exio4> lets make a weird mix between GHC and Mercury's compiler
16:30:45 <jle`> where the computation could have been done in constant space, ideally
16:31:31 <jle`> GHC gives you a compromise, and it provides tools for you to basically add "strictness annotations/hints" for the runtime system
16:31:39 <vanila> I wish I knew more about Mercury
16:32:11 <Sorella> They've got some books about the language on the website iirc.
16:32:49 <mgaut72> back.  so thoughts on the error recovery?
16:33:19 <pqmodn> mgaut72: have you considered (<|>) and (<?>)
16:34:10 <mgaut72> pqmodn: see my post a few up (about ifP) on why I think thats not sufficient
16:35:15 <pqmodn> so, you get to the point where you're sure it's an if statement. then use try (parseRestOfIf) <|> eatJunkUntilParen maybe?
16:35:16 <Sorella> mgaut72: That's not something I've done before, or know of any theory behind, so I don't think I can help you here =/ (papa-carlo does it though, and they use PEG/packrat https://github.com/Eliah-Lakhin/papa-carlo. It's Scala tho)
16:35:54 <Fuuzetsu> there are too many things called ‘n’, ‘t’ and ‘f’ in my program ;(
16:35:56 <Sorella> s/packrat/Pratt/
16:37:04 <fddfdfff> jle`: I've noticed you didn't explain why it doesn't make sense to use the stack for function calls for Haskell.
16:37:07 <mgaut72> pqmodn: ok, so I can see how that would work if i know when I am committed to exactly 1 type of statement, but what if its ambiguous when I hit an error?
16:37:32 <pqmodn> mgaut72: i'm not sure, can you given an example?
16:38:02 <jollygood> how to :set something when launching ghci from the shell?
16:38:22 <pqmodn> the 'try' combinator does backtracking, so i suppose you could manage most of what bison/yacc do, but it might be tricky
16:39:14 <srhb> jollygood: In ~/.ghci I believe
16:39:30 <jollygood> I can't just supply it through ./ghci ?
16:40:03 <pqmodn> jollygood: something like ghci -XDeriveFunctor maybe
16:40:07 <math783> So if I were to write "p = liftM putStr <some array here>", and I tried to run it like "main = p", would that work? Assuming I set the return value of p to "IO ()"
16:40:14 <jollygood> I want to :set prompt "something"
16:40:16 <math783> (I don't have anywhere to test right now)
16:40:24 <jle`> fddfdfff: ah, sorry :)  i figured it wouldn't be too relevant  :P
16:40:28 <mgaut72> pqmodn: suppose my input to the parser was "whle (1) { f(x); a = 1; }"  note that 'while' is actually 'whle' so its an error.  I dont know what my "eatJunkUntil" would have to wait until?  semicolon? close paren? close brace?
16:40:29 <pqmodn> jollygood: oh, sorry -X won't work for that
16:40:54 <jle`> fddfdfff: haskell's evaluation model can be described as "substitute the definitions"
16:40:58 <mgaut72> pqmodn: i dont know because I don't know the type of statement I have at the time of the parse error.  I just know its a parse error in statement
16:41:15 <jle`> consider something like take 2 (map (*2) [1..100])
16:41:24 <jollygood> math783 I fail to see how will p have the value of IO () with that definition.. what is the type of the array?
16:41:29 <jle`> @src take
16:41:30 <lambdabot> take n _      | n <= 0 = []
16:41:30 <lambdabot> take _ []              = []
16:41:30 <lambdabot> take n (x:xs)          = x : take (n-1) xs
16:41:31 <jle`> @src map
16:41:31 <lambdabot> map _ []     = []
16:41:31 <lambdabot> map f (x:xs) = f x : map f xs
16:41:46 <jle`> i'm not sure if you know enough haskell to understand those function definitions
16:41:54 <math783> Wait, I got the snippet of code wrong
16:41:54 <fddfdfff> i understand
16:41:55 <jle`> but if you do, you should be able to "manually evaluate by hand" the above expression
16:42:13 <vanila> fddfdfff, haskell is lazy so the way its run is that a graph representing the program is reduced by the runtime - it uses the stack a bit to know what its doing nad where it's been but this isn't similar to something like C where each function call is essnetial creating a stack frame
16:42:41 <jle`> take 2 (map (*2) [1..100]) = take 2 (map (*2) (1:[2..100])) = take 2 (2 : map (*2) [2..100]) = 2 : take 1 (map (*2) [2..100])
16:42:58 <math783> jollygood: I meant "mapM putStr <array with values that can be showed"
16:43:15 <jollygood> math783 yeah that will work
16:43:20 <math783> Sounds good, thanks
16:43:23 <jle`> = 2 : take 1 (map (*2) (2:[3..100])) = 2 : take 1 (4 : map (*2) [3..100]) = 2 : 4 : take 0 (map (*2) [3..100])
16:43:29 <jle`> = 2 : 4 : []
16:43:31 <jle`> = [2,4]
16:43:32 <jollygood> mapM_ if you want IO (). but main can be of any IO a type
16:43:39 <jollygood> so it would work regardless
16:43:51 <math783> What's the difference between "mapM" and "mapM_"?
16:43:58 <benzrf> math783: the type
16:43:59 <benzrf> :t mapM
16:44:00 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
16:44:01 <benzrf> :t mapM_
16:44:02 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
16:44:06 <fddfdfff> math783: the latter throws away the result
16:44:14 <math783> Makes sense
16:44:18 <benzrf> @src mapM
16:44:18 <lambdabot> mapM f as = sequence (map f as)
16:44:21 <jle`> fddfdfff: that's the full evaluation of that expression "by hand".  if you wanted to implement that evaluation model, you might begin to look at it like a tree expansion and reduction
16:44:21 <benzrf> @src mapM_
16:44:21 <lambdabot> mapM_ f as = sequence_ (map f as)
16:44:26 <benzrf> @src sequence
16:44:26 <lambdabot> sequence []     = return []
16:44:26 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
16:44:26 <lambdabot> --OR
16:44:26 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
16:44:28 <benzrf> @src sequence_
16:44:29 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
16:44:34 <jle`> fddfdfff: it becomes a graph when you have recursive things
16:44:50 <pqmodn> mgaut72: i'm not sure either, but "whle (1)" could be a valid function call, so maybe you had stmt = (try whileLoop <|> try funCall) <* semiColon ... so whileLoop fails because it expects "while", and funCall succeeds in consuming "whle (1)" but then semicolon fails, and you can report an error like "expected ';' at ..."
16:44:54 <jle`> fddfdfff: this sort of evaluation model doesn't make too much sense when you consider it in the context of a traditional call stack
16:45:26 <jle`> tree or graph reduction is closer in line with the semantics of haskell, and that's what most implementations attempt to do
16:45:49 <pqmodn> mgaut72: my understanding is you have to take some care in where you do backtracking in parsec or it can become inefficient
16:45:54 <fddfdfff> okay
16:46:02 <mgaut72> pqmodn: I'
16:46:04 <srhb> jollygood: Not that I know, but you can specify an alternative file with -ghci-script to achieve the same
16:46:11 <jle`> if you were to implement the above function naively with a traditional call stac, you'd: (1) call take 1; (2) call map (*2) [1..100]; (3) get the result of the entire list mapped; (4) pass it into take 2
16:46:17 <jle`> s/take 1/take 2
16:46:18 <mgaut72> pqmodn: I've been really good about not using try so far.
16:46:54 <pqmodn> mgaut72: to handle errors like you want, i think you need to use it somewhere. it may be tricky to figure out where to use it at all let alone optimally :-)
16:47:04 <jle`> notice that that implementation would be O(n) space on the length of the inside list; the way haskell does it is O(1) on the length of the inside list
16:47:19 <jle`> space
16:47:47 <benzrf> fzujn
16:48:07 <benzrf> fjuzn
16:48:07 <RchrdB> jle`, as I understand it, the explanation for why stack overflows can still happen is that GHC uses a call stack for *evaluating thunks that depend on other thunks*, though it does not necessarily have a call stack that matches up with function invocations?
16:48:13 <mgaut72> pqmodn: yea, this has been tricky.  my brain has been on this topic for like a week but I cant think of a smart way to doing this without getting really really ugly
16:49:14 <jle`> RchrdB: yeah, i mentioned this earlier.  but the stack overflow comes from the runtime system's implementation of the evaluation model which might be unrelated from the actual functions you use in your program
16:50:01 <jle`> i tend to think of it as a leakage of the abstraction
16:52:06 <merijn> GHC uses a *pattern match* stack, not a function call stack
16:52:47 <merijn> Therefore the growth of the stack is completely unrelated to function calls and their tail recursiveness (except, of course, for any pattern matches incurred by calling said functions)
16:59:32 <pqmodn> @src concat
16:59:32 <lambdabot> concat = foldr (++) []
16:59:49 <pqmodn> @src (++)
16:59:49 <lambdabot> []     ++ ys = ys
16:59:49 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
16:59:49 <lambdabot> -- OR
16:59:49 <lambdabot> xs ++ ys = foldr (:) ys xs
16:59:57 <pqmodn> or?
17:00:14 <fddfdfff> there is probably a pragma in the source
17:00:27 <merijn> pqmodn: @src doesn't list actual implementations
17:00:36 <fddfdfff> oh
17:00:39 <merijn> It's just a database with some definitions from the report and other things
17:00:44 <pqmodn> ah, thanks.
17:17:44 <jle`> it's just a text file actually, heh
17:19:27 <jle`> not sure if this one is current https://github.com/mokus0/lambdabot/blob/master/lambdabot/State/source
17:33:42 <structuralist> Does anyone know where "codata = terminal coalgebra" originated?
17:34:17 <vanila> structuralist: it's just the dual of data being an initial algebra
17:34:21 <shachaf> Presumably it's the "dual" of the initial algebra data that we're used to?
17:34:35 <structuralist> Sorry, I mean historically
17:35:00 <structuralist> Earliest reference I have is Hagino's thesis (http://www.tom.sfc.keio.ac.jp/~hagino/thesis.pdf)
17:36:12 <vanila> I can't imagine hagino was the first
17:37:33 <vanila> he cites Arbib and Manes The Greatest Fixed Points Approach to Data Types
17:39:14 <chirpsalot> Babies second Haskell program: https://github.com/Chobbes/MooXtract any criticisms?
17:39:33 <fddfdfff> structuralist: sigfpe has a blog post on data vs. codata with a list of links at the end, hope it helps
17:42:34 <structuralist> fddfdfff: Thanks, I've seen it. Turner's paper was promising but interestingly he says "Codata definitions are equations over types that produce final algebras", not final coalgebras.
17:42:52 <structuralist> vanila: Yes I've been looking for that paper but can't find it online
17:43:03 <vanila> i didnt find it either sorry
17:44:10 <shachaf> Hmm, final coalgebras are final fixed points, but they aren't final algebras, are they?
17:45:02 <shachaf> But maybe that's what they meant...
17:49:16 <katsh> and these tutorials i read, i see a bunch of variables 'xs'. howcome
17:49:34 <shachaf> It is the plural of x.
17:49:46 <shachaf> jam -> jams; x -> xs
17:49:51 <katsh> oh ok
17:50:01 <katsh> thanks
18:01:57 <cow_2001> shachaf: sup
18:02:14 <shachaf> ?
18:02:52 <cow_2001> shachaf: hello
18:04:24 <shachaf> hi?
18:06:34 <slack1256> awkward
18:09:01 <mhall> i have a question: if functions are 'types', why doesn't `:kind` work on them in GHCi?
18:09:11 <shachaf> Functions aren't types.
18:09:31 <cow_2001> ...
18:09:53 <cow_2001> shachaf: it's Egbert9e9
18:10:02 <mhall> okay i saw someone say that they technically were, maybe they just meant in a certain sense, at least they all have types?
18:10:15 <geekosaur> functions are not types. the function arrow is a type
18:10:23 <geekosaur> :t (->)
18:10:24 <lambdabot> parse error on input ‘->’
18:10:25 <Fuuzetsu> remember to {-# UNPACK #-} everything kids!
18:10:26 <Fuuzetsu> mad speedups
18:10:28 <geekosaur> bah
18:10:29 <Fuuzetsu> MAD
18:10:33 <shachaf> People say a lot of wrong things.
18:10:52 <geekosaur> :k (->)
18:10:52 <lambdabot> * -> * -> *
18:10:55 <geekosaur> there we go
18:11:16 <shachaf> cow_2001: Ah, that's who you are.
18:11:39 <cow_2001> yeah, i just realized you might not be familiar with this nickname
18:12:14 <monochrom> . o O ( a function is a value, not a type. a function type is a type, but that's tautological. )
18:12:40 <shachaf> I,I A partial function is a function, but that's -- wait.
18:13:11 <shachaf> cow_2001: Better to use #haskell-blah for non-Haskell discussion.
18:14:24 <monochrom> partial functions are pretty benign compared to "generalized functions" such as Dirac's delta, but I digress.
18:16:33 <Fuuzetsu> oh, I read the benchmark wrong, thought I got 8x speedup on a thing ;(
18:16:57 <mhall> another question: what are the 'scripts' that ghci is talking about for the :script command? just .hs files with main functions?
18:21:14 <katsh> head' (x:_) = x   why do i need the () around x:_?
18:21:33 <katsh> i ask because it's the same as 1:[]
18:21:36 <shachaf> Because otherwise it means (head' x):_ = x
18:22:06 <monochrom> it is a syntax requirement to make things more consistent
18:22:21 <katsh> i see
18:23:35 <geekosaur> mhall: I think it's like a .ghci file? so basically anything that can be at a prompt including :set etc.
18:23:47 <mhall> thanks i figured it out
18:31:14 <monochrom> carter: have you seen my haskell-cafe post today about the strange case of dlopening a GHC dynamic library?
18:31:56 <carter> monochrom: albert!
18:32:00 <carter> :)
18:32:08 <carter> yeah saw it
18:32:49 <carter> i'm not sure if its a bug or a lack of a feature
18:32:55 <carter> monochrom: does that make sense?
18:34:37 <carter> monochrom: i'd say open a ticket to document the situation, and so that ezyang / simonmarlow et al can mull if its a bug or "why on earth would you do that"
18:34:38 <carter> kinda thing?
18:34:53 <carter> either way, props on the debugging powers beyond my ken
18:35:21 <carter> i should learn gdb/lldb some time as a warm up for future ghc having those magic stack trace things
18:35:26 <carter> monochrom: am i making sense?
18:35:40 <monochrom> yes. but I only used gdb shallowly.
18:35:48 <carter> monochrom: you're still light years ahead of me
18:36:05 <monochrom> "gdb the_exe"; "run"; "backtrace".
18:36:20 <Algebr> monochrom: is there a difference between backtrace and where?
18:36:28 <monochrom> it's a lack of feature. no one thought of this unusual use case
18:36:35 <monochrom> I do not know.
18:36:50 <ezyang> monochrom: The way you're doing this seems wrong
18:37:05 <carter> ezyang: he was debugging someone elses code
18:37:08 <ezyang> libtest.so is Haskell right?
18:37:12 <ezyang> oh
18:37:12 <monochrom> yes
18:37:39 <carter> ezyang: see haskell-cafe earlier today/yesterday
18:37:40 <ezyang> as in, we have a way to properly load/unload Haskell libraries, and it's called Linker.c
18:37:46 <ezyang> I skimmed the convo
18:37:49 <carter> ah
18:37:58 <ezyang> Unloading is only supported for static object libraries
18:38:17 <ezyang> and running multiple RTSes simultaneously is not supported (and dlopen'ing a libHS so wouldn't DTRT anyway)
18:38:41 <ezyang> Unless I'm misunderstanding the problem
18:39:30 <carter> i think you're probably understanidng it rihgt
18:39:35 <carter> i think
18:39:36 <geekosaur> Algebr: should be the same. "backtrace" is the more common name but "where" is what dbx used so it's an alias
18:40:07 <geekosaur> (gdb's "original" command set was a superset of the old BSD dbx debugger)
18:40:13 <monochrom> well, so far, I have tested running two RTSes (no more than two, don't worry), one static and one dynamic, no problem found yet.
18:40:54 <geekosaur> I was reading that thread and wondering if there was some way that Haskell values could go from one to the other. (at least it can't be done directly via C...)
18:41:12 <ezyang> monochrom: Actually, I guess that might actually work, because no code segments are shared
18:41:23 <ezyang> well, data segments are the primary problem
18:41:32 <monochrom> to some extent I sympathize with "unsupported" in the sense "but if a future GHC version doesn't like this, too bad"
18:41:49 <ezyang> I mean, in principle we want to support multiple RTSes
18:41:56 <ezyang> but CAFs are a big stinker that makes this difficult to do
18:42:10 <carter> CAF == the top level function thunk things?
18:42:16 <ezyang> yes
18:42:17 <carter> i've always been a bit fuzzy about that stuff
18:42:35 <carter> ezyang: HIW had some very cool speakers ;)
18:42:58 <carter> your slides were pretty slick
18:43:09 <ezyang> HIW was great, may it live long and prosper
18:43:15 <carter> yeah
18:43:24 <carter> i remember last year only making it to the tail end of HIW
18:43:30 <carter> had way less action
18:45:09 <Algebr> For the UPenn hackathon, are there NYC people carpooling/splitting hotel thing? Or does that kind of planning happen later?
18:45:33 <carter> Algebr: i've not planned that far
18:45:35 <carter> when is it again?
18:45:39 <geekosaur> planning can happen whenever but I think -cafe list is often better for that
18:45:41 <carter> Algebr: have we met IRL
18:45:47 <carter> yeah, cafe is better for that
18:45:57 <carter> ?
18:46:07 <Algebr> carter: October 17-19, yea we have. A few times.
18:46:07 <geekosaur> irc has depressingly short memory :p
18:46:13 <zenguine> is there some kind of NYC recurring haskell meetup anywhere?
18:46:20 <carter> zenguine: YES
18:46:26 <Algebr> zenguine: yes, its called the NY Haskell group
18:46:39 <carter> Algebr: i'm just bad at IRC Handle <--> IRL name
18:46:50 <zenguine> oh awesome, I moved to the city a few months ago and would love to go to something like that
18:46:52 <Algebr> carter: its cool, name is Edgar, I asked you about State Monad last time
18:46:55 <carter> OH YES
18:46:58 <carter> EDGAR
18:47:00 <Algebr> heh.
18:47:09 <carter> did you grock it after i wandered off?
18:47:17 <Algebr> yep.
18:47:17 <carter> i'm bad at explaining things like that
18:47:31 <carter> or did my repeating "thats all it is, no magic" actually help?
18:47:43 <Algebr> that also helps
18:47:56 <carter> zenguine: its actually the NYC Haskell User Group (NYC HUG)
18:48:09 <dibblego> is there a good reason why there is not a filepath library using ByteString, except for unix specifically?
18:48:10 * carter takes off the pedantic hug hat
18:48:25 <carter> dibblego: its been waiting for you to take action :)
18:48:34 <carter> hrmm
18:48:35 <dibblego> carter: well really, or am I missing something?
18:48:40 <shachaf> dibblego: Because file paths aren't bytestrings.
18:48:45 <carter> oh yeah
18:48:45 <carter> that too
18:48:46 <shachaf> dibblego: Well, not on Windows.
18:48:59 <shachaf> In Windows they're actual Unicode sequences.
18:49:00 <carter> whats the longest file path in the wild?
18:49:01 <yyttr3> What is a monad in the categorical sense?
18:49:03 <dibblego> oh, I don't know windows
18:49:09 <dibblego> shachaf: fair enough, cheers
18:49:13 <zenguine> carter: how well attended are the meetups?
18:49:18 <carter> zenguine: WEELLLL
18:49:20 <zenguine> is there a pretty good group?
18:49:21 <Algebr> zenguine: pretty well attended
18:49:32 <Algebr> zenguine: very good group
18:49:38 <carter> zenguine: i told people at ICFP that a quiet month has 40-60 people
18:49:42 <carter> their eyes bugged out
18:49:58 <yyttr3> I understand monads are special types of functors but I don't really understand what they are past that.
18:50:15 <shachaf> yyttr3: https://en.wikipedia.org/wiki/Monad_(category_theory) has all the information.
18:50:31 <carter> yyttr3: are you asking wrt category theory, or wrt the Functor Type class?
18:50:32 <carter> or both?
18:50:35 <shachaf> If that's not enough for you (e.g. because you don't know some of the definitions), you'll have to be more specific with your question.
18:50:37 <carter> or what they mean operationally?
18:50:45 <shachaf> carter: Look up a few lines for the answer.
18:50:58 <zenguine> carter: cool, I'm checking out the meetup.com group now, I assume thats the correct one?
18:51:03 <carter> zenguine: probably
18:51:19 <carter> the one that has had stuff every month for the past 1+ years
18:51:32 <Algebr> zenguine: probably since there's only 2 haskell named groups in the NYC area
18:51:47 <yyttr3> What a Monad is in the categorical sense. i understand it in haskell, and I understand what a functor is. I don't have the background knowledge to understand the wiki.
18:52:27 <zenguine> I see.  well when is the next meet up? I don't see anything listed upcoming on meetup.com
18:52:33 <tabemann> why must the functional programming group here in Milwaukee be Erlang-centric?
18:53:02 <nshepperd> when category theory definitions are turned into haskell types, it seems to involve turning arrows and morphisms into ordinary function arrows
18:53:10 <Algebr> carter: Are you going to the northeastern IFL thing?
18:53:12 <shachaf> yyttr3: You'll have to be more specific.
18:53:16 <Algebr> october 1st
18:53:25 <nshepperd> so I guess you can try to reverse that process
18:53:30 <shachaf> nshepperd: Natural transformations are turned into extraordinary (polymorphic) function arrows.
18:53:56 <nshepperd> right, they are polymorphic
18:55:13 <haasn> Or monads
18:55:27 <haasn> (Depending on the type of natural transformation!)
19:02:58 <zenguine> is there any reason why I would still be getting dependency issues when trying to install something into a fresh sandbox?
19:03:27 <athan> So a functional dependency is a... unique index between multi-parameter type classes? Like `class MultiParam a b | a -> b where...` would state that there could only be _one_ instance pairing an 'a' with a 'b', but multiple possible instances with every b?
19:03:31 <geekosaur> it's conflicting with something installed globally? (meaning a ghc boot library)
19:03:51 <monochrom> yes. a bit more reason with GHC 7.8 because now it also comes with transformers
19:03:51 <ezyang> athan: yep
19:03:54 <ezyang> that's why it's an arrow
19:04:13 <zenguine> yeah.. I'm trying to "cabal install present"
19:04:21 <zenguine> and I'm getting this: http://pastebin.com/VxX1y2yN
19:04:30 <monochrom> the name "functional dependency" in fact comes from relational databases
19:04:34 <zenguine> into a fresh sandbox
19:04:51 <zenguine> is there no way I can resolve this without messing with my global packages?
19:05:24 <geekosaur> is unordered-containers a bootlib these days?
19:05:33 <athan> ezyang: woo! thanks :)
19:05:36 <geekosaur> containers is, I think, but not that yet?
19:05:36 <monochrom> no. but it is in Haskell Platform.
19:05:41 <geekosaur> ah, yes
19:06:02 <geekosaur> ,,,right, attoparsec reinstall, that's in HP
19:06:11 <athan> monochom: I was wondering why it smelled funny... :P
19:06:17 <monochrom> it seems to me that present wants older text, for example
19:06:23 <geekosaur> zenguine, consider hsenv
19:06:41 <geekosaur> it'll let you install a completely sandboxed ghc with juat its boot libraries, minimal conflicts
19:07:13 <nshepperd> so a Monad is an endofunctor, F :: H -> H, together with a bundle of arrows (return :: h -> F h,  h ∈ H) and... something that composes those arrows?
19:07:52 <zenguine> geekosaur: hmm..seems a little heavyweight for just trying to get one binary installed.. you can't think of anything simpler?
19:08:11 <geekosaur> zenguine, not if you have the platform installed globally and it's conflicting, no
19:08:19 <nshepperd> oh, wikipedia says they are natural transformations, not actually arrows
19:08:56 <geekosaur> well, there's GHC_PACKAGE_PATH but that's also pretty heavyweight considering you'd need to copy some bootlibs into it and edit their package database entries and ghc-pkg recache
19:09:08 <carter> Algebr: not gonna go
19:09:20 <carter> trying to collect income for the next month
19:09:25 <carter> may make it to hacphi
19:09:33 <carter> but icfp was a whole nother levle
19:11:34 <monochrom> zenguine: present wants atto-lisp, atto-lisp wants an older text.
19:12:01 <carter> dare I suggest --allow-newer=text ?
19:12:05 <monochrom> cabal refuses to work when GHC_PACKAGE_PATH is set. it goes on strike.
19:12:24 <monochrom> oh, --allow-newer may just be the right thing
19:12:38 <tabemann> they should just make it so that packages cannot specify a maximum package version
19:12:43 <tabemann> i.e. always --allow-newer
19:13:02 <monochrom> ah, but that has led to the opposite problem too
19:13:04 <carter> tabemann: nope
19:13:11 <carter> that leads to many great sads
19:13:16 <carter> we learned in the great saddening
19:13:19 <carter> many many years ago
19:13:48 <carter> tabemann: if you look at some older very very stable packages
19:14:01 <carter> they have stuff about "base 2" vs base 3
19:14:02 <carter> or something
19:14:07 <monochrom> I think it is safe to create a sandbox, go ahead build this thing (complete with --force-reinstalls), copy out the exe, throw away the sandbox. the --force-reinstalls affects the sandbox only.
19:14:28 <monochrom> OTOH if you want the/a library, that's different.
19:14:30 <carter> monochrom: you may need to add the sandboxes bin folder to your PATH thought
19:14:35 <carter> though right?
19:14:59 <zenguine> hmm I'll give allow newer a try
19:15:10 <solatis> hmmm, what happends when i do a `head` operation on an empty list? will a catchable exception be thrown?
19:15:21 <solatis> the docs say only that the list must be non-empty
19:15:26 <carter> solatis: everything is catchable
19:15:31 <solatis> ok, that is good
19:15:32 <carter> i think
19:15:32 <monochrom> yes if you need an exe provided by a depended package. no if the only exe is from the root package
19:15:33 <zenguine> sexy, allow newer did the trick thanks guys
19:16:01 <carter> solatis: i like writing code the fails loudly and early
19:16:09 <solatis> yeah i know
19:16:14 <carter> solatis: :)
19:16:17 <monochrom> if I say "dependee", does anyone know what I mean?
19:16:25 <geekosaur> there is one exception that has not in the past been catchable, but it is something that goes wrong low level in the runtime
19:16:38 <zenguine> monochrom: I didn't know that force-reinstalls only affects the sandbox
19:16:51 <carter> zenguine: ... if they escaped that'd be a bug!
19:16:52 <monochrom> it affects whatever context you use
19:16:52 <carter> :)
19:16:58 <solatis> but right now i'm inside a `forever` loop, and some function fails (i suspect a head operation on an empty-list) -- i want to print out debugging info and before crashing hard
19:17:03 <carter> solatis: ooo
19:17:06 <carter> i posted to redit
19:17:20 <monochrom> if you use it in the context of --user, it affects --user. if you use it in the context of a sandbox, it affects that sandbox.
19:17:22 <carter> solatis: profiled builds let you get fake stack traces
19:17:23 <carter> http://www.reddit.com/r/haskell/comments/2fwwx3/how_to_get_approx_stack_traces_with_profiled/
19:17:31 <zenguine> carter: then I guess I don't understand exactly what is happening.. if global packages are being conflicted with then what else is there to be "force reinstalled"
19:17:39 <carter> zenguine: you install a local copy :)
19:17:46 <zenguine> carter: I hadn't installed anything in the sandbox yet.. it was fresh
19:17:52 <carter> .... then install shit
19:17:55 <carter> :)
19:18:00 <solatis> carter: thanks, i'll read that!
19:18:21 <carter> 7.10 will have really cool "always enabled" efficient stack traces
19:18:32 <carter> for now you'll have to make do with the profiled build only ones
19:18:51 <zenguine> no haha I mean if I have a fresh sandbox and nothing is installed, and then there are conflicts with global packages, then it suggests to me that the only things available to be "force reinstalled" are the global things, since there isn't anything locally yet to reinstall..
19:18:53 <zenguine> meh, whatever
19:18:53 <solatis> woa!
19:18:55 <solatis> https://stackoverflow.com/questions/25359461/finding-where-loop-happened/25359633#25359633
19:18:59 <solatis> that's what i need!
19:19:16 <athan> Can you make a type alias of a tuple of typeclasses...?
19:20:33 <tabemann> what do you mean by "tuple of type classes"?
19:20:35 <bergey> athan: Do you want a constraint alias (left side of =>) or an existential type?
19:20:36 <solatis> ah crap, now i must rebuild all my libraries with profiling support... i hate cabal
19:20:39 <zenguine> athan: if you use -XConstraintKinds yes
19:20:45 <monochrom> zenguine: perhaps read my http://www.vex.net/~trebla/haskell/sicp.xhtml
19:20:47 <athan> I'm seeing it in Control.Monad.Trans.Resource under MonadResourceBase
19:20:57 <athan> zenguine: Ahh, okay.
19:21:24 <zenguine> athan: https://www.haskell.org/ghc/docs/7.4.1/html/users_guide/constraint-kind.html
19:21:27 <tabemann> solatis: whenever I create a new .cabal directory the first thing I do is make sure to set profiling
19:21:46 <tabemann> it's easier than having to rebuild everything later so I can have profiling support when I really want it
19:21:48 <zenguine> solatis: I agree 100%. boo cabal
19:22:10 <solatis> tabemann: yeah, and now i must find a way to reinstall all my packages
19:22:11 <solatis> *snif*
19:22:20 <zenguine> I feel like profiling support should be the default.
19:22:26 <tabemann> as do I
19:22:43 <geekosaur> someday it may be
19:22:49 <monochrom> solatis: http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#config
19:22:53 <geekosaur> cabal was originally intended to be an end user tool, not a developer tool
19:23:05 <geekosaur> the defaults have been shifting
19:23:17 <solatis> monochrom: i was already ahead of you, but i simply forgot last time
19:23:22 <geekosaur> that said, some devs are opposed to switching because profiling builds can take longer for large packages
19:24:03 <solatis> why are reinstalls always considered dangerous by the way?
19:24:12 <solatis> i try to understand the rationale
19:24:18 <solatis> because of linking errors?
19:24:50 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml#pigeon for why
19:25:10 <monochrom> it is more cunning than mere linking errors
19:25:19 <monochrom> or s/cunning/tricky/
19:25:29 <solatis> rm -rf ~/.ghc will be good enough to purge all my installed packages? or do i need to rm -rf ~/.cabal too ?
19:25:54 <monochrom> ~/.ghc is good enough. it just doesn't delete some orphaned files.
19:26:31 <solatis> ok, since i see a lot of references to packages in ~/.cabal
19:26:44 <solatis> maybe i'll just do `cabal list --simple-output --installed | awk '{print $1}' | uniq | xargs -I {} cabal install {} --reinstall --force-reinstall`
19:27:31 <monochrom> cabal list lies
19:27:32 <carter> yeah, nevever delete ~/.cabal unless you know what youre doing
19:27:41 <carter> ghc-pkg list?
19:27:49 <monochrom> yes, ghc-pkg list is accurate
19:28:51 <monochrom> it also distinguishes --global and --user. so you know what is not to be reinstalled.
19:29:29 <solatis> urgh
19:29:37 <solatis> i feel like my packages are fubar now
19:30:05 <monochrom> if you rm .ghc, then you can't call the next step "reinstall", because you no longer have them :)
19:30:34 <solatis> i understand
19:30:49 <solatis> `cabal list --simple-output --installed | awk '{print $1}' | uniq | xargs -I {} cabal install {} --reinstall --force-reinstall` is what i'm doing now
19:30:55 <solatis> ehr
19:30:57 <monochrom> cabal list lies
19:30:59 <solatis> ghc-pkg list`
19:31:01 <solatis> sorry
19:31:05 <solatis> ghc-pkg list | awk '{print $1}' | uniq | xargs -I {} cabal install {} --reinstall --force-reinstall
19:31:06 <solatis> that
19:31:17 <monochrom> no
19:31:26 <monochrom> at best, ghc-pkg list --user
19:31:39 <monochrom> you completely must not touch anything that comes with GHC
19:31:48 <zenguine> I feel like any time its been longer than a week since messing with my cabal and I want to change something, it doens't work and I either A.) read monochroms entire guide again and figure it out or B.) just blow everything away and start over
19:31:52 <zenguine> its really frustrating..
19:32:18 <zenguine> I thought sandboxes would solve this problem but apparently they dont
19:32:23 <monochrom> well, to your credit, my sicp article does not say too much about solutions, only how to cause problems.
19:32:24 <solatis> i feel like i should make a cron.daily job to reinstall everything
19:32:25 <solatis> :)
19:32:36 <athan> How hard is it to compile a haskell app to an x86 binary that's fairly agnostic and can run on multiple x86 hardware manufacturer variants?
19:33:26 <carter> athan: with the Same OS
19:33:29 <carter> or different OS?
19:33:39 <athan> carter: With the same os!
19:33:42 <carter> ok
19:33:43 <carter> thats easy
19:33:47 <athan> eff yeah
19:34:13 <athan> carter: Do you have any links or suggestions on where to look?
19:34:21 <monochrom> how multiple is multiple x86 hardware manufacturer variants? I'm really scared that you have one in mind I haven't heard of.
19:34:22 <carter> ... cabal build ?
19:34:32 <carter> athan: generally it should just work
19:34:41 <monochrom> or I have heard of but consider obsolete, for example PC AT using 286
19:34:45 * athan poops pants
19:34:50 <carter> or ... centaur cpus?
19:34:50 <athan> ...sorry
19:35:23 <monochrom> I don't even know whether hugs can work on PC AT
19:35:32 <solatis> i have trouble deciding which is worse.. cabal, npm or maven
19:35:45 <carter> solatis: latter two because they never get better obsvs :)
19:35:47 <talios> hah
19:36:05 <talios> maven is definitely getting better.
19:36:08 <carter> oh?
19:36:09 <carter> how?
19:36:22 <solatis> they're finally dropping XML? *ducks*
19:36:27 <talios> well its actually getting core development on it again for a change.
19:36:42 <carter> .... and how much decades of legacy to they need to support?
19:36:59 <talios> solatis - funny you say that :)  polyglot maven has been worked on for awhile,  we have clojure dsl, yaml, scala, and others - its pluggable.
19:37:27 <solatis> talios: that's good to know.
19:37:29 <talios> the new POM model is being discussed ( and part of those changes revolve around fixing a lot of shizzle )
19:37:38 <solatis> the whole package manager things are a mess in the world
19:37:44 <carter> the last major release ... looks wimpy http://maven.apache.org/docs/3.2.1/release-notes.html
19:37:46 <solatis> so many efforts to reinvent the wheel
19:37:52 <solatis> like, why can't haskell just reuse apt-get?
19:38:10 <carter> solatis: OS package managers are unrelated to software dev package managers
19:38:17 <carter> theyre actually fundamentally different things
19:38:17 <solatis> carter: are they?
19:38:19 <talios> carter - A LOT of the changes in 3.2.x are internal reworking, so not a lot of user facing changes.
19:38:28 <carter> solatis: i'm writing a lib
19:38:40 <carter> i need to make sure that i play nice with a range of my dependencies
19:38:47 <talios> totally different - people using npm to install applications just feels broken.
19:38:58 <carter> so that my users can use my lib with any other tools they need
19:39:06 <carter> certain langauges like ... R.... fake being the same
19:39:13 <talios> cabal included - as its also a build/compile tool
19:39:14 <carter> but ... they also dont get linker errors till your run your program
19:39:17 <solatis> talios: you'll be glad to know someone just announced node-os today, a whole linux distribution based on npm
19:39:29 <solatis> http://node-os.com/
19:39:47 <carter> solatis: talios , i had a very fun chat with bernalex  about how package managers for a Distro and for a PL are fundamentally different things
19:39:47 * talios shudders
19:39:50 <talios> that reminds me of those attempts at a pure java os
19:40:01 <solatis> that just takes blasphemy to a whole new level
19:40:12 <Fuuzetsu> can anyone with a better computer try to open http://fuuzetsu.co.uk/misc/chunksize.html and see if the barchart at the top shows up? don't try to open on mobile or a toaster
19:40:38 <solatis> talios: that would require a hardware-based JVM i would say :)
19:40:41 <carter> Fuuzetsu: hangon
19:40:45 <carter> you wanna get a screen cap too?
19:40:56 <Fuuzetsu> if possible, yes
19:41:03 <carter> Fuuzetsu: fuck, how many samples did you take?
19:41:08 <Fuuzetsu> not many ;_;
19:41:24 <carter> Fuuzetsu: yeah,the default template is slow as hell
19:41:28 <Fuuzetsu> apparently too many for JavaScript
19:41:29 <ezrios> woo
19:41:30 <solatis> Fuuzetsu: i get no barcharts, but then again, it might be my cambodian internet
19:41:37 <ezrios> finally the git log parser I wrote 6 months ago can get some use
19:41:47 <talios> solatis - http://www.jnode.org/
19:41:51 <Fuuzetsu> solatis: hm, ok, thanks
19:42:06 <carter> Fuuzetsu: its rendering in FF
19:42:12 <Fuuzetsu> I tried FF ;/
19:42:18 <Fuuzetsu> and chromium
19:42:20 <Fuuzetsu> and dwb…
19:42:23 <carter> its not showing me the bar chart
19:42:28 <carter> its showing everyting else though
19:42:32 <Fuuzetsu> right, I get that
19:42:40 <Fuuzetsu> maybe it just refuses to render that over some amount
19:42:55 <carter> Fuuzetsu: ooooo
19:42:55 <solatis> talios: i think we need a new internet rule.. if some software development effort exists, someone will try to make a port to the JVM for it
19:42:55 <carter> oooo
19:42:57 <carter> i know what the issue is
19:43:00 <Fuuzetsu> that sucks, I wanted those charts
19:43:02 <Fuuzetsu> oh?
19:43:03 <carter> Fuuzetsu: you have tooo big a dynamic range
19:43:20 <talios> solatis - seen Frege - haskell variant for the JVM :)
19:43:21 <carter> i wrote a template for pre 1.0 criterion that would let you group benchmarks by dynamic range
19:43:30 <carter> the do subcharts for comparing those
19:43:32 <solatis> Fuuzetsu: your page just crashed my chrome browser
19:43:33 <Fuuzetsu> do you have that thing around aand how to use it?
19:43:39 <Fuuzetsu> solatis: hurray web!
19:43:48 <carter> Fuuzetsu: yes, AND erikd used it for his integer shot out
19:43:50 <carter> hanging a sec
19:44:00 <Fuuzetsu> nice
19:44:25 <carter> https://bitbucket.org/carter/multicriterion-templates
19:44:33 <carter> Fuuzetsu: i've been meaning to update it to 1.0 template
19:44:35 <carter> havent had the time
19:44:58 <carter> Fuuzetsu: alternatively, you should maybe split the criterion suite into different files for different orders of magnitude of runtime
19:45:25 <Fuuzetsu> carter: well, that run was to determine what the orders of magnitude are ;)
19:45:33 <Fuuzetsu> I'll try the template thing
19:45:35 <carter> Fuuzetsu: you can read the numbers to know that now
19:45:44 <carter> Fuuzetsu: my template might not work with 1.0
19:45:47 <carter> or at least it'll render funny
19:45:58 <Fuuzetsu> I'll run on small sample first
19:46:24 <carter> Fuuzetsu: i'm happy to help fix it
19:46:35 <carter> been meaning to update it to use the 1.0 template for a bit
19:47:02 <carter> https://github.com/bos/criterion/blob/master/templates/default.tpl vs https://bitbucket.org/carter/multicriterion-templates/src/b1c1b808b71cac3ba62f259e6eb5a162f1ba35cb/report.tpl?at=master
19:47:19 <carter> they're mostly the same
19:47:20 <carter> hrmmm
19:47:49 <carter> Fuuzetsu: mind you, the way I do it currently splits by bgroup
19:48:11 <Fuuzetsu> I generate bgroups
19:48:22 <Fuuzetsu> well, we'll see how it goes
19:48:33 <carter> and probably a bettter way would just split them by order of magnitude?....
19:48:33 <carter> otoh, i usually know the rough order of magnitude of things
19:48:48 <carter> it might just work
19:49:44 <carter> ok, the regression rendering will be totally busted
19:49:48 <carter> but everythign else should be fine
19:50:07 <Fuuzetsu> carter: http://fuuzetsu.co.uk/misc/chunksize2.html that just broke it ;P
19:51:03 <solatis> i wonder if something like http://nixos.org/nix/ could replace cabal
19:51:07 <Fuuzetsu> I'll try the master thing
19:51:22 <Fuuzetsu> solatis: why, I can tell you all about it!
19:51:27 <talios> solatis - hearing a lot of good comments about nix
19:51:30 <Fuuzetsu> or I could if I wasn't fighting criterion ;P
19:51:47 * talios goes back to maven SNAPSHOT hell :( 
19:51:54 <solatis> talios: me too, it seems like these guys know what they're doing
19:52:14 <carter> Fuuzetsu: lemme diff my version and the new one
19:52:15 <carter> hangong
19:52:18 <solatis> but i just hate that every language needs to reinvent their own wheel
19:52:27 <carter> solatis: yes and no
19:52:31 <carter> it looks like the same wheel
19:52:33 <carter> but some are square
19:52:37 <carter> and som ehave pointy bits
19:52:46 <katsh> Alright, so the author of LYAH made a mistake, or im understanding something wrong.
19:53:31 <Fuuzetsu> katsh: maybe both!
19:53:34 <solatis> i know, and i know the common joke about "let's standardize this" -- "and now we have 2 problems", but some languages package managers are really really bad
19:53:45 <katsh> tell (x:y:_) = "This list is long."  he is pattern matching that. the previous pattern is tell (x:y:[])
19:53:54 <katsh> and so on, til an empty []
19:54:25 <katsh> but then he says, for the last pattern (which is tell (x:y:_) = 'list is long', We can't rewrite (x:y:_) with square brackets because it matches any list of length 2 or more.
19:54:34 <talios> solatis - packing for languages/compilation is surely a different beast to packaging for OS distribution - they cross over in parts, but I think they should still be separate.
19:54:40 <katsh> so he's saying x:y:z:[] would match two or more?
19:55:02 <talios> i.e. nix controlling cabal for reproducable builds etc.  but not nix replacing cabal
19:55:04 <monochrom> x:y:[] is exactly 2
19:55:09 <katsh> i know!
19:55:12 <solatis> talios: i know, it's binary vs source
19:55:13 <monochrom> x:y:_ is 2 or more
19:55:18 <katsh> so x:y:z:[] would be exactly 3
19:55:19 <solatis> but i don't think those two are mutually exclusive
19:55:22 <monochrom> yes
19:55:27 <katsh> but he says
19:55:32 <katsh> We can't rewrite (x:y:_) with square brackets because it matches any list of length 2 or more.
19:55:41 <katsh> but it wouldnt match two or more
19:55:44 <zenguine> katsh: thats right
19:55:46 <monochrom> then you should blame English "it". it's ambiguous.
19:55:50 <carter> Fuuzetsu: i'm figuring out updating the template
19:55:51 <Fuuzetsu> katsh: he's saying you can't write [x, y]
19:55:51 <carter> hangong
19:55:54 <talios> solatis - not even that.  like on the JVM you use maven/gradle/ant to produce jar files, but thats individual components, not an OS package with init scripts etc.
19:56:05 <katsh> Fuuzetsu: ok that cleared it
19:56:09 <katsh> thanks
19:56:21 <monochrom> We can't rewrite x:y:_ with square brackets because my purpose is to match 2 or more.
19:56:26 <talios> solatis - maybe the difference is library vs application packaging
19:56:29 <solatis> talios: and a jar file is just another tarball with files in it, so how is that different from building a .tar.gz package?
19:56:36 <tabemann> [x,y] is x:y:[]
19:56:52 <katsh> i know. but when he said square brackets, i was picturing x:y:z:[]. not [x,y,z]
19:56:56 <katsh> thanks for clearing that up
19:57:14 <solatis> the library vs application packaging does sound true, tho
19:57:32 <solatis> but in the world of c++, where i'm coming from, you mostly just use the system's global package manager for dependencies
19:57:54 <talios> solatis - mm, a .tar.gz will have init scripts, docs, the jar is just compiled code (and come java 9 all being well, its not just a tarball/zip with classes).
19:58:05 <Fuuzetsu> solatis: right, except that breaks when you need 5 versions of everything, including glibc
19:58:06 <monochrom> that is until you want to play with alternative versions
19:58:14 <carter> solatis: that assumes a LOT more stability in how you dev
19:58:17 <talios> Fuuzetsu - enter static binaries!
19:58:25 <carter> "i need Lib Foo 7.8"
19:58:25 <talios> "just run docker"
19:58:30 <carter> "sorry, we only have 7.1"
19:58:30 <Fuuzetsu> talios: enter nix
19:58:31 <solatis> talios: i know, but you could describe the install script easily with apt-get, for example -- a library will have an easy install script (just copy files), and application a more complicated one (init scripts, etc)
19:58:53 <talios> Fuuzetsu - true
19:59:20 <solatis> Fuuzetsu: the breaking is true, you really need to know what you're doing if you want to have, say, multiple versions of gcc an glibc
19:59:25 * Fuuzetsu had ~20 versions of GHC in ~ at one point because Portage couldn't deal with even 2
19:59:48 <solatis> i keep having trouble with having cabal 1.18 globally and 1.20 userly
20:00:12 <solatis> 1.18 is what my OS (arch) installed, 1.20 is what i have locally
20:00:17 <solatis> *hate*
20:00:34 <solatis> but guess i just don't know what i'm doing, and don't care enough :)
20:00:35 <Fuuzetsu> on Gentoo I just got rid of anything in the package manager to do with Haskell, did it all from userland
20:00:41 <monochrom> is it important to use 1.20?
20:00:43 <tabemann> hmmph dammit why doesn't Network.TLS say whether its send and recv are thread-safe or not
20:00:52 <solatis> Fuuzetsu: that sounds like a sane approach
20:01:02 <solatis> monochrom: i do not know, i always like to use -latest
20:01:09 <Fuuzetsu> solatis: package managment by hand and recompiling everything 50 times a day because sandboxes is not sane
20:01:18 <Fuuzetsu> it was what I had to do though
20:01:20 <tabemann> because I want to send in one thread and receive in another
20:01:21 * Fuuzetsu is on NixOS now
20:01:27 <tabemann> I suspect it probably isn't
20:01:45 <solatis> awesome, i'm using Docker for my whole build process nowadays, it's a great way for isolation
20:01:47 * talios is suffering n-modules (separate git repos) * n-feature-branches -- same feature branch on those N modules, but trying to work out a nice sandbox for builds across them all is driving me insane
20:02:26 <carter> Fuuzetsu: i'm yak shaving figuring out porting my template to 1.0 citerion
20:02:34 <Fuuzetsu> carter: good, good
20:02:52 <talios> Fuuzetsu - sounds like my problem, I keep have to go rebuild dependant modules/libs if I temp. switch code branches. fun fun
20:03:03 <Fuuzetsu> yep
20:03:13 <Fuuzetsu> you could set up nix to check out branches by the way
20:04:17 <talios> really need to look at nix.  Installed it the other day ( on OSX - at least theres an installer! ) - but not had the time to look
20:04:36 <carter> Fuuzetsu: im looking at javascript for you
20:04:44 <carter> you'd better be gratefull if i get it working
20:04:55 <Fuuzetsu> I will
20:05:09 <Fuuzetsu> I'd be pretty hard-pushed to touch JavaScript
20:05:38 <carter> granted, i've been meaning to do this change / fix for a few months now :0
20:05:49 <monochrom> Fuuzetsu: did you contribute to haddock? did it make you touch javascript? :)
20:06:23 <carter> monochrom: no, but theres plans to convince him to expose a format we could share with people who write data vis stuff using js
20:06:29 <talios> Fuuzetsu - sounds like using nix-shell would be a godsend for switching feature branches across repos etc. maybe.
20:06:50 <Fuuzetsu> monochrom: I'll tell you that the issues about removing frames which would involve touching JavaScript are still open
20:07:02 <Fuuzetsu> when it comes to web work, I franticaly seek others to do it for me
20:07:09 <monochrom> heh
20:07:39 <Fuuzetsu> changing some stuff in XHtml.hs is as far as I'll go ;)
20:07:49 <solatis> talios: i think this whole area of developer pain is ready for some serious disruption -- maybe some docker, nix, whatever hybrid, to streamline isolation, distribution and operations
20:08:17 <talios> solatis++
20:08:21 <solatis> i suspect many businesses would pay serious money if you can save developer pain this way
20:08:40 <geekosaur> nis is widely used in the haskell community
20:08:47 <talios> or maybe, just maybe - we should strictly adhear to a limited work in process rule :)
20:09:06 <geekosaur> and there were things before that, like environment modules
20:09:23 <geekosaur> that were rather coarse early attempts at the same thing
20:09:26 <solatis> talios: but what about your managers that continuously talk about being agile and distributed version control!
20:10:10 <Fuuzetsu> hah christ, bloody criterion
20:10:17 <carter> ?
20:10:25 <Fuuzetsu> I was wondering why this append was running in constant time
20:10:32 <Fuuzetsu> turns out the function wasn't fully applied
20:11:47 <talios> solatis - that would be the same one who thinks clojure will save all. and wanting to switch without addres any architectural changes that kinda make switching from a heavy OSGi/OO model to free-functions and no OO in clojure - the two worlds don't really mix.....  without work.
20:12:28 <solatis> talios: i know, it was a kind of tongue-in-cheek comment.
20:12:54 <solatis> for interpreted, scripting languages i think the whole agile approach works great
20:13:05 <talios> solatis - you touched on an argument I was having with a coworker earlier this morning - I'm still in battle mode
20:13:11 <solatis> as long as you're able to do proper isolation
20:13:56 <solatis> but the haskell, java, c++ etc world will just need to rebuild *everything* all the time
20:14:20 <solatis> virtual machines might be a solution, i think Docker is a great approach too
20:14:47 <solatis> but we actually need our version control systems' branching to be aware of external dependencies somehow
20:15:01 <solatis> so when you switch a branch, you immediately switch the external deps too
20:15:12 <solatis> and creating a new branch would mean forking the external deps of master
20:15:49 <solatis> but that probably violates a lot of ideologies of version control systems, so we need something on top of that
20:16:05 <talios> solatis - a good copy-on-write file system ( like docker has under the covers ) would be great.  then you just branch your cabal cache, or maven local repo for your feature branch
20:16:15 <solatis> talios: or just use ZFS :)
20:16:17 <talios> that would solve a LOT for me
20:16:34 <talios> solatis - well yes.
20:16:38 <solatis> but yeah
20:16:47 <talios> now where did that ZFS-for-OSX project go again..
20:17:26 <solatis> and if we can somehow syndicate that with an continuous build, test & deployment process, we can have the best of all the worlds!
20:17:48 <talios> to the devopsmobile!
20:17:57 <solatis> haha
20:18:04 <solatis> ah well, i have faith in humanity
20:18:12 <solatis> i think within a few years this will be solved
20:18:27 <solatis> it will just take 10 years for the non-startup-businesses to adopt it tho.... :(
20:20:27 <solatis> you see all kinds of very good efforts in this area the last year
20:20:34 <solatis> NixOS, CoreOS and Docker especially
20:21:23 <solatis> now if a hosting/cloud server provider could glue the whole thing together, we can save the world!
20:21:35 <talios> ahh now I remember why I stopped looking at nix - the nix.sh to add to the profile, I use fish-shell - need to port it.  It was just....  I hit that roadblock, and went "ack, back to real work for now"
20:22:06 <Fuuzetsu> nix.sh?
20:22:17 <Fuuzetsu> also sh should be on your system regardless…
20:24:15 <carter> Fuuzetsu: i'm sooo glad i have a gui diff tool
20:24:40 <Fuuzetsu> I just use magit
20:24:48 <carter> i dont understand emacs
20:24:50 <katsh> or meld
20:24:52 <carter> seems like its full of yaks :)
20:24:57 <carter> kaleidoscope :)
20:25:39 <Fuuzetsu> it's ok, I'll port magit to Yi when time comes ;)
20:25:56 <Fuuzetsu> and it won't be slow as ass because of ELisp
20:28:21 <carter> Fuuzetsu: lemm throw it online
20:28:23 <carter> and you can test?
20:28:32 <carter> to test you'll need to copy the template folder from criterion
20:28:45 <carter> but replace the default .tpl file with the new one
20:28:58 <carter> Fuuzetsu: i don't have any 1.0 criterion codes to test handy
20:29:01 <Fuuzetsu> I can't use --template?
20:29:04 <carter> yes
20:29:05 <carter> that
20:29:17 <carter> BUT, i think you might still wanna make sure the relative paths to things still work
20:29:18 <carter> but i could be wrong
20:29:20 <Fuuzetsu> is that a yes, I can use it or no, I can't use it
20:29:27 <carter> i have no clue
20:29:33 <Fuuzetsu> ;P
20:29:46 <carter> it has shit like     <script language="javascript" type="text/javascript">
20:29:46 <carter>       {{#include}}js/jquery.criterion.js{{/include}}
20:30:00 <carter> git clone the criterion lib, copy the template folder
20:30:01 <Fuuzetsu> I split and ran the benchmarks by hand in the meantime
20:30:04 <carter> and swap mine in
20:30:20 <carter> and them --template  to the folder
20:30:20 <Fuuzetsu> ok one min
20:30:28 <carter> *to the file
20:31:15 <carter> Fuuzetsu: https://gist.githubusercontent.com/cartazio/c3fa2513d733b4576e62/raw/12e4665a96111f72ae9d74044ae63a7215bed2c0/multi-criterion.tpl
20:31:33 <carter> i've not tested yet mind you
20:33:30 <carter> wget that
20:33:31 <carter> swap it int
20:33:40 <carter> --tempalte path to tempalte
20:33:48 <Fuuzetsu> what am I swapping it in for?
20:33:51 <Fuuzetsu> do I just drop it in?
20:34:34 * Fuuzetsu runs it
20:35:48 * hackagebot minioperational 0.4.6 - fast and simple operational monad  http://hackage.haskell.org/package/minioperational-0.4.6 (FumiakiKinoshita)
20:35:50 * hackagebot monoid-subclasses 0.3.6.1 - Subclasses of Monoid  http://hackage.haskell.org/package/monoid-subclasses-0.3.6.1 (MarioBlazevic)
20:38:19 <carter> Fuuzetsu: replace default.tpl with my multi-criterion.tpl
20:38:23 <Fuuzetsu> ah fuck
20:38:28 <carter> ?
20:38:38 <Fuuzetsu> I just dropped it in and --template to multi-criterion
20:38:41 <carter> ye
20:38:44 <carter> thats fine
20:38:47 <Fuuzetsu> oh ok
20:38:51 <Fuuzetsu> it just finished too, let's see
20:38:56 <carter> as long as the relative paths to the js thigns is the same
20:39:30 <carter> the same monster file or?
20:39:31 <Fuuzetsu> http://fuuzetsu.co.uk/misc/chunksize8.html seems it didn't work?
20:39:51 <Fuuzetsu> I ran /tmp/bench -L 1 -o /tmp/chunksize8.html --template=/tmp/criterion/templates/multi-criterion.tpl
20:40:24 <Fuuzetsu> (slighty different benchmarks so I don't wait ages but range should still be enough)
20:40:40 <carter> Uncaught SyntaxError: Unexpected token var
20:40:41 <carter> hrmm
20:40:49 * hackagebot xmlhtml 0.2.3.3 - XML parser and renderer with HTML 5 quirks mode  http://hackage.haskell.org/package/xmlhtml-0.2.3.3 (DougBeardsley)
20:41:06 <Fuuzetsu> wonder if you can catch SyntaxError as exception in JS
20:41:23 <carter> hah
20:41:27 <carter> Fuuzetsu: i see what i did wrong
20:41:28 <carter> hangong
20:42:15 <carter> Fuuzetsu: updated the gist https://gist.github.com/cartazio/c3fa2513d733b4576e62
20:42:21 <carter> https://gist.githubusercontent.com/cartazio/c3fa2513d733b4576e62/raw/f3be803aedf190b6c0536568770a31dedfea391b/multi-criterion.tpl
20:42:56 <Fuuzetsu> ok, time to wait again
20:43:00 <Fuuzetsu> actually going to try to cut some tests out
20:43:12 <carter> good idea
20:43:17 <carter> just have 2 differnt bgroups
20:43:20 <carter> with 2 tests each
20:43:43 <carter> Fuuzetsu: this time i'm gonna clean this fucker up and make bos support it official :)
22:43:57 --- topic: 'Hackage/haskell.org issues being investigated; hackage mirror: http://is.gd/xJt4FF | http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://is.gd/xJt4FF'
22:43:57 --- topic: set by shachaf!~shachaf@unaffiliated/shachaf on [Thu Sep 04 17:50:57 2014]
22:51:51 <CrazyM4n> so apparently GTK made it a bit easier to work with on windows
22:51:54 <CrazyM4n> http://www.gtk.org/download/win32_tutorial.php
23:01:03 * hackagebot http-client 0.4.0 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.4.0 (MichaelSnoyman)
23:01:05 * hackagebot http-conduit 2.1.4.3 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-2.1.4.3 (MichaelSnoyman)
23:08:14 <jle`> > let chars = "_,.=+-~*^'`" in map ((chars !!) . round . (* 5) . (+ 1) . sin . (* (2 * pi / 15))) [0..50]
23:08:15 <lambdabot>  "-*'``'^~+.,__,=-*'``'^~+.,__,=-*'``'^~+.,__,=-*'``'"
23:16:05 * hackagebot hailgun 0.1.0.2 - Mailgun REST api interface for Haskell.  http://hackage.haskell.org/package/hailgun-0.1.0.2 (RobertMassaioli)
23:36:12 <RustyShackleford> i've read that a great beneifit of functional programming is that it is easy to multithread
23:36:27 <RustyShackleford> does haskell do this automatically?
23:36:50 <RustyShackleford> or is that something the programmer has to do himself?
23:38:30 <shachaf> It is difficult to do automatically in general. The programmer has to do it herself.
23:38:36 <r444> there are many concurrency/parallel strategies, you have to tell compiler explicitly what you want to do
23:38:39 <shachaf> Or at least give hints and annotations of some sort.
23:38:54 <Axman6> RustyShackleford: automatical parallelisation is trivial in a language like haskell. Making the code un faster in parallel is much harder so it's not done automatically
23:39:16 <Axman6> automatic even
23:39:23 <Axman6> beer is kicking in
23:40:31 <RustyShackleford> yeah i don't know any haskell, but its a cool idea I think
23:40:44 <Axman6> time to learn!
23:40:46 <Axman6> @where lyah
23:40:46 <lambdabot> http://www.learnyouahaskell.com/
23:45:07 <ph88> hey guys, im trying to do  cabal install cairo-0.13.0.0    but im getting this error     http://pastebin.com/t2cw6jNM  can someone help ?
