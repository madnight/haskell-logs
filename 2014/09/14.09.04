00:16:48 * hackagebot acme-cadre 0.1 - car, cdr and more  http://hackage.haskell.org/package/acme-cadre-0.1 (Jafet)
00:17:44 <jle`> thank you Jafet for bringing car and cdr to haskell
00:20:47 <gfixler> but what of macros?
00:21:23 <tero-> waiting for quasiquoter to write lisp-like haskell
00:22:11 <gfixler> lisp's core is about 7 little functions
00:22:17 <gfixler> how small can a Haskell core be?
00:22:43 <Jafet> interact
00:22:44 <shachaf> I'm sure you don't need 7 functions.
00:22:48 <joneshf-laptop> i thought it was 5?
00:22:48 <Jafet> (1)
00:22:57 <gfixler> 7ish - maybe it's 5
00:23:14 <shachaf> What makes something core?
00:23:25 <gfixler> I think of it like bootstrapping
00:23:32 <joneshf-laptop> gfixler, i'm probably wrong though :)
00:23:40 <gfixler> until those 5 or so functions exist in something, you can't really do anything
00:23:48 <gfixler> once they do, you can implement the rest
00:24:18 <gfixler> so core would be the stuff you have to make not using the language before you have the language to work in
00:24:47 <gfixler> the first computer was literally made of boot straps
00:25:06 <kingqueer> Jo, I am trying to install FileManip but I got "System/FilePath/Find.hs:174:21:
00:25:08 <kingqueer>     Not in scope: data constructor `State'"
00:25:12 <kingqueer> what is up with that?
00:25:55 <kingqueer> Is the module stale? Is there an alternative?
00:27:06 <joneshf-laptop> gfixler, looks like it is 7
00:27:09 <shachaf> Yes, it's probably old.
00:27:24 <shachaf> http://hackage.haskell.org/package/FileManip says to use http://hackage.haskell.org/package/filemanip instead
00:27:26 <Jafet> State stopped being a data constructor a long time ago.
00:27:53 <kingqueer> sorry I am blind: it just says so on the package page. Sorry boys.
00:28:11 <kingqueer> "Deprecated in favor of filemanip"
00:29:23 <kingqueer> Tx
00:31:04 <shachaf> 7 sounds like one of those mystical numbers
00:32:39 <shachaf> Apparently the 7 are quote,atom,eq,car,cdr,cons,cond. Two of those aren't functions.
00:33:08 <shachaf> Oh, and lambda. Even though with lambda you don't actually need any of the others, presumably.
00:33:45 <joneshf-laptop> well sure, you could probably just build it up from the lambda calc
00:33:53 <joneshf-laptop> but that seems trivial
00:34:23 <joneshf-laptop> trivial?
00:34:27 <joneshf-laptop> that's not the right word
00:42:21 <kingqueer> can someone give me an example of find in System.FilePath.Find? Can I use it as a one liner?
00:42:41 <kingqueer> I am already stuck on the predicate.
00:48:09 <southp01_> Hi. I just finished cs194 homework #2, and here I am asking for a code review again. Would someone kindly help me check if I did anything considered "bad practices" or sort? Thanks. Here is my pull request: https://github.com/southp/cs194/pull/2
00:59:25 <latk> I'm using the ghci debugger, to try and work out what was going on when an exception was raised. The exception is: SomeException (libpq: failed). How can I find out something more useful ?
00:59:41 <latk> (the program was doing nothing particularly intereseting at the time of the exception)
01:10:13 <kingqueer> Answered myself: easy realy:  F.find always ((isInfixOf "test") `liftM` filePath &&?  fileType ==? Directory) "."
01:21:57 * hackagebot rest-gen 0.15.0.1 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.15.0.1 (AdamBergmark)
01:22:13 <bezirg> hi, I understand that you can "throw" exceptions anywhere, but only catch them in IO. But is throwing an exception in pure code that useful? Can you give me some examples in practice were this works better than returning Maybe,Either as "exceptions"?
01:23:08 <Peaker> bezirg: the usual convention is to only throw from pure code in the case of bugs/assertion failures
01:23:32 <Peaker> bezirg: whereas exceptions thrown from IO code are often meant to be caught
01:25:34 <Sensored> is that true? i only throw exceptions in my IO code
01:25:41 <Sensored> and use Maybe/Either outside
01:25:49 <Sensored> err, in pure code
01:31:16 <friden> i recently did a fresh install of my linux environment, and after installing haskell-platform, cabal with cabal install cabal-install, and cabal install mtl, haskell can't find the maybe monad: Could not find module `Control.Monad.Maybe'
01:31:33 <friden> ive tried googling it but can't find any definite answer, its probably easy
01:31:44 <friden> someone knows whats wrong?
01:35:57 <bergmark> friden: that's not where the Monad instance for Maybe is defined, that module is from the MaybeT package
01:39:58 <friden> bergmark: do you know how to fix it? i assume i have to install something that is missing
01:40:31 <bergmark> some package is missing that dependency
01:41:34 <bergmark> friden: is it some 3rd party lib that fails with this error?
01:41:40 <bergmark> if it's your code, just install MaybeT
01:42:43 <Sensored> friden: can you do 'ghc --version' and 'which ghc'
01:43:26 <friden> version: version 7.6.3
01:43:40 <friden> which: /usr/bin/ghc
01:44:02 <Sensored> hmm
01:44:06 <Sensored> something is wrong
01:44:13 <Sensored> you just installed haskell, yet you have an old ghc
01:44:38 <Sensored> latest should be 7.8.3
01:45:00 <Sensored> how did you install hs-platform?
01:45:22 <friden> i just did sudo apt-get install haskell-platform
01:45:25 <friden> from ubuntu 14.04
01:45:30 <friden> maybe i need to install it from source?
01:45:38 <friden> *compile
01:45:42 <Sensored> hmm
01:46:03 <Sensored> one moment
01:46:24 <bergmark> why would this be related to the ghc installation?
01:46:25 <shachaf> Or don't, since MaybeT is in transformers now.
01:46:32 <shachaf> Hmm, was scrolled up.
01:47:26 <Sensored> ubuntu has an old haskell platform in their pakcage repo
01:47:34 <Sensored> now i mean that shouldnt actually be a problem though ..
01:48:03 <Sensored> i was having issues with haskell earlier with had to do with versions of things on my system being messed up
01:48:23 <latk> In the ghci debugger, I have broken on exception and get "SomeException (libpq: failed)". There must be some way of getting more information on what the exception is ?
01:48:35 <Sensored> the only solution was for me to nuke all of the haskell platform from low earth orbit and do a fresh install
01:48:52 <shachaf> OK, but that doesn't seem to have anything to do with friden's problems.
01:49:09 <Sensored> yeah, i know.
01:49:47 <shachaf> friden would be best off answering bergmark's questions.
01:50:53 <friden> bergmark: i don't know if its 3rd party that fails with this, how do i check it? i was aiming to learn using hxt, so my code uses hxt and arrows
01:51:08 <friden> maybe that relies on some dependancy that is broken in an older version of haskell?
01:51:15 <Zenol> Hi. I have a short question about lens (should be one year since I wrote haskell, so I'm a bit rusted). What's the syntax that alow writing http://lpaste.net/110492 like "updating" the stack "field". SHould be something with %~ but I can't remind me how it works.
01:51:52 <bergmark> friden: when do you get this error?
01:52:36 <Zenol> (Nb : I use makeLens for the Stack type, and makeClassy for the type in the state monad)
01:52:50 <friden> my code is not neraly finished, but its here: http://pastebin.com/Pt1Va4zM
01:53:16 <bergmark> friden: you are importing the offending module
01:53:24 <bergmark> is that where the error points to?
01:53:31 <bergmark> you haven't given much information
01:53:41 <bergmark> and how are you compiling it?
01:54:31 <friden> my whole error is: http://pastebin.com/ikeY5Qzq
01:55:15 <friden> so Control.Monad.Maybe?
01:55:26 <friden> compiling it with ghc webscraper.hs
01:56:38 <bergmark> friden: then, like i said, you need to install MaybeT
01:57:35 <friden> im new to this xd, but do i do it with cabal install maybet?
01:57:54 <friden> oh nice
01:58:02 <friden> that solved it, thanks :D
01:58:59 <friden> i googled the compilation error and did not get any results even hinting that i missed maybet and not maybe, so i was kind of lost in the dark, sorry for beeing so lost xd
01:59:02 <friden> but thanks^^
02:03:02 <SwashBuckla> it seems that bos fixed the Criterion bug: https://github.com/bos/criterion/issues/61
02:03:11 <SwashBuckla> FOA c_wraith
02:03:20 <Zenol> Hum, so no lens hacker here? :(
02:03:22 <SwashBuckla> FAO*
02:03:55 <bernalex> Zenol: #haskell-lens or #lens or something
02:04:26 <shachaf> Zenol: You didn't ask your question clearly enough for anyone to know what you're trying to do without guessing.
02:06:17 <shachaf> Or perhaps I'm bad at understanding questions, who knows. But I'd suggest adding enough detail that it's obvious what you're trying to accomplish.
02:09:07 <Zenol> shachaf: Hum, ok. I have a Int field, and a [Int] field, named top and dt. I want to replace the Int field by 0 and the [Int] field by top : dt. All that occure in a State monad, so it might by operator that remove the use of "use $" and just allow to build the list "vtop : vdt" directly without getting the value aout of the monad, and also a way to update the stack field instead of just replacing it by calling a construct (althought i
02:09:54 <Zenol> bernalex: I didn't know such chanel exists. Should be new. thank you, I'll ask there :)
02:10:18 <shachaf> Zenol: Cut off after "althought i"
02:11:20 <shachaf> Anyway, never mind, I need to go to sleep.
02:11:25 <Zenol> shachaf: Sorry : (althought it will probably doesn't change the resulting compiled code, it will be more "clean" ).
02:11:30 <Zenol> So, good night ^^
02:21:37 <edlinde> when using say map like:  map (>4) [4,5,6] .. is it actually testing [4>4, 5>4 ..]?
02:21:47 <edlinde> or how should I understand this
02:22:06 <edlinde> so the (>4) is a partially applied function right?
02:22:55 <edlinde> does my question make sense? :)
02:23:39 <Haskellfant> > map (>4) [1..10]
02:23:40 <lambdabot>  [False,False,False,False,True,True,True,True,True,True]
02:23:45 <Haskellfant> edlinde: yes
02:24:19 <edlinde> just a bit confused as to how I should read the application of the function
02:24:34 <supki> edlinde: (> 4) is called "section", it's equivalent to (\x -> x > 4)
02:24:34 <Haskellfant> you can partially apply both arguments of an infix function
02:25:00 <edlinde> is it to be read as “(> 4) 1” .. then “(> 4) 2” ...
02:25:01 <edlinde> ?
02:25:31 <edlinde> hmm slightly confused now
02:25:33 <edlinde> :(
02:25:51 <Haskellfant> yes
02:25:54 <edlinde> supki: so I should be thinking of that function as a lambda fn?
02:25:55 <Haskellfant> > (>4) 1
02:25:57 <lambdabot>  False
02:26:42 <edlinde> but if we apply the lambda fn logic.. then I should have thought of it as  4>1 right?
02:27:05 <Haskellfant> 4>1 would be true
02:27:11 <Haskellfant> it's 1>4
02:27:23 <Haskellfant> (4>) 1 would be 4>1
02:27:50 <edlinde> ah sorry yeah  1>4 is what i meant
02:28:19 <tdammers> think of binary operators as syntax sugar for regular functions
02:28:30 <tdammers> a `x` b == x a b
02:28:41 <edlinde> Haskellfant: so I should really be thinking of it exactly as partial functions application?
02:29:11 <tdammers> a < b == (<) a b
02:29:17 <Haskellfant> edlinde: that's what i do and so far it has worked pretty well :)
02:29:20 <edlinde> because if I look at it like supki said: (> 4) is called "section", it's equivalent to (\x -> x > 4)
02:29:36 <Haskellfant> (>4) = flip (>) 4
02:29:47 <edlinde> tdammers: which is that same as  (< a) b yeah?
02:29:55 <tdammers> edlinde: slow down
02:30:06 <edlinde> so   a < b == (<) a b == (< a) b
02:30:07 <edlinde> ?
02:30:10 <tdammers> (a <) == (<) a
02:30:15 <edlinde> tdammers: :)
02:30:23 <tdammers> does this make sense?
02:30:31 <tdammers> :t (<)
02:30:32 <lambdabot> Ord a => a -> a -> Bool
02:30:47 <tdammers> :t (1 <)
02:30:48 <lambdabot> (Ord a, Num a) => a -> Bool
02:30:56 <tdammers> :t (<) 1
02:30:57 <lambdabot> (Ord a, Num a) => a -> Bool
02:31:24 <Haskellfant> maybe a function that has a different type for the first and second argument would help understanding this
02:31:26 <tdammers> so the section allows us to write partially-applied functions with infix notation
02:31:32 <tdammers> Haskellfant: true
02:31:50 <tdammers> :hoogle a -> b -> c
02:32:00 <tdammers> @hoogle a -> b -> c
02:32:02 <lambdabot> Prelude curry :: ((a, b) -> c) -> a -> b -> c
02:32:02 <lambdabot> Data.Tuple curry :: ((a, b) -> c) -> a -> b -> c
02:32:02 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
02:32:19 <tdammers> don't think flip would make a good example :D
02:32:35 <edlinde> so what is a good example then? :)
02:32:47 <Haskellfant> i'm too stupid to come up with one :)
02:32:50 <tdammers> (:), maybe?
02:33:00 <Haskellfant> ah good one
02:33:08 <tdammers> ok, so:
02:33:13 <Haskellfant> :t (:)
02:33:14 <tdammers> :t (:)
02:33:14 <lambdabot> a -> [a] -> [a]
02:33:15 <lambdabot> a -> [a] -> [a]
02:33:22 <SwashBuckla> wee criterion graphs! http://fiddle.jshell.net/pgttzpfc/show/
02:33:34 <tdammers> takes an element and a list, and returns a list with the element prepended to it
02:33:45 <edlinde> yep
02:33:49 <edlinde> ok
02:33:59 <tdammers> > (:) 1 [] -- "prepend 1 to the empty list"
02:34:00 <lambdabot>  [1]
02:34:28 <tdammers> > 1:[] -- exactly the same thing, but written with infix notation
02:34:28 <edlinde> yep
02:34:30 <lambdabot>  [1]
02:34:47 <lericson_> > let a = 1:a
02:34:48 <lambdabot>  not an expression: ‘let a = 1:a’
02:34:56 <lericson_> you're not an expression
02:35:06 <tdammers> now sections allow us to punch "holes" into this infix notation
02:35:14 <SwashBuckla> I would not have thought that gcd''' would be faster than gcd'', but criterion benchmarks shows it is faster:
02:35:14 <tdammers> :t 1:[]
02:35:15 <lambdabot> Num a => [a]
02:35:20 <tdammers> :t (1:)
02:35:21 <lambdabot> Num a => [a] -> [a]
02:35:37 <tdammers> 1: -- reads as "Prepend 1 to"
02:35:44 <edlinde> tdammers: what does it mean to punch holes?
02:35:52 <tdammers> blanks
02:36:00 <tdammers> "Prepend 1 to ____"
02:36:01 <SwashBuckla> http://lpaste.net/110451
02:36:05 <edlinde> ok
02:36:17 <tdammers> there's a blank there; and in Haskell, those blanks are function arguments
02:36:31 <SwashBuckla> why do you think the DList version of gcd is faster than the List version?
02:36:35 <tdammers> so (1:) is a function that takes a list and prepends 1 to it
02:36:47 <tdammers> and it is exactly equivalent to writing (:) 1
02:37:01 <edlinde> I see
02:37:15 <SwashBuckla> by "faster" I mean 1ns
02:37:19 <tdammers> (:) takes two arguments; call it with one, and the result will be a function that takes the remaining argument
02:37:20 <SwashBuckla> but it's still faster
02:37:27 <edlinde> so (>4) is a function that takes another number as an arg?
02:37:29 <tdammers> nothing special there, all Haskell functions behave like htis
02:37:39 <edlinde> and compares it to check if its > 4 or not
02:37:52 <tdammers> well, if you leave out the first argument instead of the second, the same happens, only with the *other* argument
02:38:02 <tdammers> (:[]) -- "Prepend ____ to the empty list"
02:38:20 <edlinde> so you mean (>) ?
02:38:34 <edlinde> like  (>) 4 3
02:38:36 <edlinde> or something
02:38:40 <tdammers> (>) is a two-argument function
02:38:51 <edlinde> and (>4) takes one arg yeah?
02:38:53 <tdammers> you can write it in prefix notation: (>) 4 3
02:38:55 <tdammers> yeah
02:38:56 <edlinde> since its a partial application
02:39:00 <tdammers> exactly
02:39:12 <edlinde> hmm that is how I initially understood it
02:39:12 <tdammers> sections are a way to perform partial application
02:39:13 <edlinde> :)
02:39:36 <edlinde> and map always has sections?
02:39:44 <tdammers> no
02:39:46 <tdammers> map is just a function
02:39:52 <edlinde> ok
02:39:57 <tdammers> and the section is also just a function
02:40:26 <tdammers> map just happens to take a function as its first argument, and that section happens to match the required signature
02:40:42 <tdammers> but you can map any function over a list, as long as the types match up
02:40:48 <tdammers> > map show [1,2,3]
02:40:50 <lambdabot>  ["1","2","3"]
02:41:02 <tdammers> > map reverse ["foo", "bar"]
02:41:03 <lambdabot>  ["oof","rab"]
02:41:17 <edlinde> right
02:41:18 <edlinde> gotcha
02:41:35 <tdammers> > map (1:) [[], [2,3]]
02:41:37 <lambdabot>  [[1],[1,2,3]]
02:41:40 <tdammers> ;)
02:53:52 <adas> > map (foldl (flip (:)) []) ["foo", "bar"]
02:53:53 <lambdabot>  ["oof","rab"]
02:56:28 <nymacro> is there a nice way to convert a 3-byte unsigned number into an Int? Currently I have: convert x = fromIntegral (decode (0 `BL.cons'` x) :: Word16)
02:56:48 <nymacro> Or have I missed some useful convenient function somewhere along the way?
02:57:27 <nymacro> don't worry
02:57:28 <nymacro> I'm a spastic
02:57:38 <nymacro> I truncated bytes
02:57:40 <nymacro> Thanks
02:58:05 <tdammers> quack quack
03:07:11 * hackagebot hs-php-session 0.0.8.8 - PHP session serialization  http://hackage.haskell.org/package/hs-php-session-0.0.8.8 (elblake)
03:22:15 <b_jonas> @hoogle (a -> c) -> (b -> d) -> (a, b) -> (c, d)
03:22:15 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
03:22:31 <b_jonas> ^ why doesn't that find the function (Control.Arrow.***) ?
03:24:01 <b_jonas> > let { x :: (a -> c) -> (b -> d) -> (a, b) -> (c, d); x = (***); } in x (10*) (2+) (4,9)
03:24:03 <lambdabot>  (40,11)
03:24:10 <b_jonas> seems to match the type
03:28:46 <int-e> @type ask :: a -> a
03:28:47 <lambdabot> a -> a
03:32:14 <kuribas> Which regex package should I use?  Do I need to compile the regex?
03:37:42 <srhb> kuribas: Are you sure the question isn't whether you should use a regex package at all? :)
03:38:58 <Jafet> A regex package is like a solution looking for two problems
03:39:14 <kuribas> I am using it as a lexer.
03:39:21 <kuribas> A parser generator is overkill...
03:39:30 <kuribas> or parser combinator
03:39:52 <kuribas> I have a single regex which handles almost all cases.
03:40:05 <srhb> I'd still use a Parsec-like thing.
03:40:33 <kuribas> What's wrong with regexes?
03:40:52 <kuribas> The one I use is relatively easy.
03:41:43 <srhb> kuribas: There's nothing _wrong_ with regexes aside from a lot of the Haskell regex libraries being weird and broken in interesting ways. Parsec-like things are just nicer for most things, including lexers, imo.
03:41:52 <srhb> (Well, and regexes are often way too expressive)
03:42:23 <kuribas> heres my regex: "^([:word:]+|[<=>:|]+|['`]+|[+-]+|[/*\\]+|[!?]+|[#&@$]+|[~^]+|[[]+|[]]+|[{}]+|,|;|(|\\))"
03:42:51 * srhb glazes over
03:42:57 <kuribas> broken is bad ...
03:43:09 <kuribas> uhm, should've escaped the (
03:43:31 <srhb> Wouldn't happen in Parsec! :-)
03:43:33 <tv> kuribas: i (arbitrarily) chose regex-tdfa for one project and hadn't any problems by now
03:44:15 <kuribas> tv: ok, I see.
03:44:49 <kuribas> srhb: I agree that a regex is quick and dirty.  But in this case it's fine for me.
03:44:58 <srhb> OK, I'll butt out then. :
03:45:01 <srhb> :)
03:46:23 <adas> am i correct in assuming that the laziness is a con only when dealing with IO and not much of a problem when all the laziness is happening within pure code?
03:46:38 <adas> *that laziness is a disadvantage
03:46:54 <srhb> No.
03:47:17 <kuribas> adas: lazyness has it advantages and disadvantages.
03:47:21 <srhb> Well, you could say that if nothing were ever forced (because never doing any IO) it wouldn't be a problem ever.
03:47:26 <srhb> But then your program would never do anything ever.
03:47:54 <kuribas> adas: IO code is always executed sequentially.
03:48:40 <Jafet> Except when it isn't
03:49:25 <kuribas> Well, pure expressions used in IO functions may be executed lazily.
03:50:13 <adas> wwithing pure code, when is laziness a bane than boon?
03:50:24 <srhb> The classical memory leak examples.
03:50:29 <srhb> For instance.
03:51:02 <kuribas> adas: Neither
03:51:09 <kuribas> adas:   <kuribas> adas: lazyness has it advantages and disadvantages.
03:51:27 <Jafet> As in life, laziness is a problem when it happens to something that you actually needed to do.
03:51:36 <srhb> @where memory-leak
03:51:36 <lambdabot> I know nothing about memory-leak.
03:51:38 <srhb> aw
03:52:20 <Jafet> http://www.haskell.org/haskellwiki/Performance
03:52:26 <clucroc> example of memory leak due to laziness: sum function from Prelude
03:52:50 <kuribas> adas: It makes expressing some algorithms much easier.
03:53:31 <adas> clucroc: i knew that one..buidling up thunks all the way till the last Num
03:53:47 <kuribas> adas: Personally, I don't think lazyness is superior to stricness, but also not the other way around.
03:54:20 <srhb> kuribas: "superior" maybe not. Strictly more powerful though.
03:54:36 <srhb> Well, I suppose having both is even more strictly superior.
03:55:53 <kuribas> srhb: With respect to expressiveness, yes.  But it can be harder to reason about a lazy program than a strict program.
03:56:00 <srhb> Yep.
03:56:21 <srhb> Though the adverse can be true, too.
03:56:26 <srhb> head [ ......]
03:57:04 <srhb> Opposite, rather.
04:00:57 <kuribas> I wonder, is [:word:] equivalent to "a-zA-Z_", or does it include other unicode characters?
04:01:17 <srhb> Depends!
04:02:25 <kuribas> hm, "Depending on the text being searched this package supports Unicode"
04:36:02 <Krautman> Hi everyone
04:37:06 <rlees> Anybody use the Lek ide?
04:37:46 <Krautman> That's leksah, right?
04:37:56 <rlees> hrm - yes
04:38:05 <Krautman> Heard of it, considered it
04:38:26 <rlees> Looks interesting
04:38:43 <Krautman> I'm looking for an uncluttered editor though
04:39:11 <rlees> definitely *not* uncluttered project
04:39:20 <Krautman> Notepad++ is pretty crap to me, and vanilla notepad is slightly archaic ;)
04:39:23 <kuribas> Krautman: what's uncluttered?
04:39:26 <kuribas> emacs?
04:39:48 <Krautman> Uncluttered as in minimal feature set
04:39:59 <kuribas> ok, not emacs :)
04:40:01 <Haskellfant> as in not emacs? :P
04:40:07 <Krautman> That is, no 10000 commands, addons, key chords, etc
04:40:09 <Krautman> Yeah
04:40:15 <Krautman> Definitely not emac
04:40:18 <Krautman> emacs*
04:40:25 <int-e> ed?!
04:40:33 <Krautman> Windows user here ^^
04:40:36 <kuribas> lol
04:40:50 <Krautman> Yes yes, throw the tomatoes already
04:40:53 <Twey> Notepad is pretty minimal.
04:40:57 <clucroc> emacs evil-mode
04:41:08 <Krautman> It is, notepad is not half bad to be fair
04:41:14 <int-e> no bells and whistles, plain command line interface, lightweight, and best of all it doesn't burden you with error messages.
04:41:22 <Krautman> It's just that encodings tend to mess it up
04:41:28 <Twey> I suppose EDIT.COM deserves a mention, too
04:41:48 <Twey> int-e: ?
04:41:55 <Krautman> Yeah, but notepad does a good job, the issue I have with it is that UTF-8 tends to get ...mangled
04:42:04 <int-e> Twey: exactly.
04:42:20 <Twey> WordPad handles encodings better, but you have to be careful you don't get rich text control codes in your code.
04:42:31 <Krautman> Oh by the way, this is my first time here, first time on IRC in general
04:42:46 <Krautman> So do yell at me if I mess something up ;)
04:43:23 <Twey> Doing okay so far.  Welcome.
04:43:38 <Krautman> Well, I haven't set anyone on fire yet, so thanks for that
04:44:09 <Krautman> But when I read "thousands of active users" I was expecting a flood
04:44:24 <kuribas> > unsafeSendNuclearMissiles
04:44:25 <lambdabot>  Not in scope: ‘unsafeSendNuclearMissiles’
04:44:51 <rlees> This is pretty active
04:45:02 <rlees> compared to the other places I hang out
04:45:23 <Krautman> Yeah, I did use IRC many, many years ago, and that was like a graveyard for mimes
04:46:07 <Krautman> Also, does that bot actually evaluate expressions?
04:46:14 <exio4> > 2+2
04:46:15 <lambdabot>  4
04:46:22 <Krautman> That is gorgeous...
04:46:41 <exio4> > let a = True in (if a then 2 else 3)*4
04:46:43 <lambdabot>  8
04:46:53 <tdammers> Krautman: lambdabot can evaluate most Haskell code
04:47:06 <Krautman> I wonder if it handles type signatures
04:47:12 <Krautman> > (\x -> undefined) :: Monad m => m a -> a
04:47:13 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
04:47:13 <lambdabot>    arising from a use of ‘M73967500963809122310245.show_M73967500963809122310...
04:47:13 <lambdabot>  The type variable ‘a0’ is ambiguous
04:47:13 <lambdabot>  Note: there are several potential instances:
04:47:13 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
04:47:15 <tdammers> it does
04:47:20 <tdammers> :t map
04:47:21 <lambdabot> (a -> b) -> [a] -> [b]
04:47:25 <Krautman> Sorry, evil mood ;)
04:48:14 <kuribas> > putStrLn $ intercalate "\n" $ replicate 3 "flooding"
04:48:15 <lambdabot>  <IO ()>
04:48:36 <Twey> Krautman: It evaluates arbitrary Haskell code.  But it doesn't evaluate IO actions, and unsafePerformIO et cetera are not available, for obvious reasons.
04:48:40 <Twey> Er, doesn't execute**
04:48:50 <Krautman> I never knew intercalate existed
04:49:15 <Twey> And the output is truncated.
04:49:17 <Twey> > [0 ..]
04:49:18 <tdammers> it also has some protection against infinite loops
04:49:19 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
04:49:23 <tdammers> that, yeah
04:49:28 <Twey> Also it times out
04:49:32 <Twey> > let x = x in x
04:49:35 <lambdabot>  mueval-core: Time limit exceeded
04:49:37 <Krautman> For obvious reasons
04:49:42 <Twey> Right
04:49:47 <Twey> Other than that, it executes anything you like.
04:49:55 <Krautman> Though a type of (m a -> a) still seemed evil
04:50:07 <tdammers> the clean solution would be to solve the halting problem
04:50:10 <Twey> Krautman: That's actually a Comonad method.  ☺
04:50:24 <Twey> :t extract
04:50:24 <lambdabot> Not in scope: ‘extract’
04:50:26 <tdammers> which, unfortunately, requires having solved the halting problem
04:50:36 <Krautman> Hang on, let's see if I can figure out how to message.
04:51:57 <kuribas> Does "length str" return the number of unicode characters or bytes?
04:52:08 <Krautman> Characters, no?
04:52:37 <Krautman> Woah. Massive join/leave list
04:52:51 <kuribas> I would expect to ...
04:53:02 <Krautman> Anyway, Char is unicode, and string is a [Char]
04:53:04 <Twey> kuribas: Unicode codepoints
04:53:05 <Krautman> So yes
04:53:20 <Krautman> Can be checked with maxBound :: Char
04:53:22 <Twey> > length "あいうえお"
04:53:23 <lambdabot>  5
04:53:50 <Krautman> > fromEnum (maxBound :: Char)
04:53:51 <lambdabot>  1114111
04:54:27 <kuribas> ok, thanks
04:54:55 <kuribas> > isAlpha 'あ'
04:54:56 <lambdabot>  True
04:59:43 <Krautman> Something really bugs me about 'let' clauses in my definitions
05:04:47 <Krautman> Could someone give me some advice on factorization?
05:06:13 <bernalex> so any idea what to do when ghc-mod is being stupid and thinks persistent-sqlite is hidden? tried removing the sandbox and starting again -- even tried a fresh git clone of the project.
05:06:56 <Krautman> Sorry, don't know anything about that :(
05:08:52 <kuribas> bernalex: I had to remove dist from my project directory some times.
05:09:11 <bernalex> kuribas: I have rm'd the sandbox and dist.
05:10:01 <kuribas> then idk
05:11:15 <Jafet> .oO(Integer factorization? Polynomial factorization? Left-factorization? QR factorization?)
05:11:38 <Krautman> Integer factorization, sorry ;)
05:12:02 <Jafet> Advice: it's too hard, better avoid it.
05:12:24 <Krautman> Hahaha, I got it working plenty of times in many ways
05:12:28 <Krautman> But they're all a horrid mess
05:12:51 <tdammers> brute-force isn't hard
05:13:01 <Krautman> All the stuff I write tends towards an elegant, concise one-liner, but the factorization is still that ugly thing
05:13:10 <Krautman> And yes, I'm going for the nitwit approach ;)
05:13:19 <Krautman> It's just a brute force
05:13:33 <Krautman> Find first prime factor, append, divide, repeat
05:14:06 <Krautman> But for doing something so primitive, it looks VERY ugly
05:14:38 <sivteck> l
05:17:35 <trap_exit> are haskell exceptions (i.e. failed to pattern match) more expensive than using a Maybe ?
05:18:29 <bernalex> they are kind of drastically different
05:18:43 <bergmark> in terms of maintenance yes :P
05:18:47 <bernalex> so a more concrete example would be good
05:19:05 <trap_exit> bernalex / bergmark: are you guys responding to me or a previous question ?
05:19:12 <bernalex> trap_exit: yes.
05:19:13 <bergmark> trap_exit: use exceptions only for exceptional circumstances, a failed pattern match is most expected
05:19:21 <bergmark> most likely*
05:19:30 <trap_exit> so basically I should not have failed pattern matches
05:19:35 <luite_> trap_exit: they don't have runtime overhead, bind doesn't get more expensive
05:19:36 <trap_exit> and I should always have a catch aall _ = Nothing ?
05:19:46 <bernalex> lolno
05:19:51 <bernalex> pokemon exception handling is bad bad bad
05:20:00 <b_jonas> "pokemon exception handling"?
05:20:06 <trap_exit> wtf
05:20:07 <Krautman> I love that analogy.
05:20:09 <luite_> trap_exit: throwing an exception is an rts function, it only costs something when an exception is thrown, a catch takes a stack frame
05:20:10 <doismellburning> gotta catch 'em all!
05:20:10 <bernalex> b_jonas: "gotta catch'em all"
05:20:20 <trap_exit> luite_: okay, thanks
05:20:24 <b_jonas> ah
05:20:48 <trap_exit> luite_ : how much more productive has ghcjs development been without me jumping in every day with "HELP ! FIRE ! " :-)
05:20:52 <b_jonas> so that's a phrase like "highlander"
05:20:55 <doismellburning> I mean, I _do_ want to be the very best, like no-one ever was...to catch them _is_ my real test, though I don't know about training them
05:21:18 <luite_> trap_exit: not much since here at ICFP (or Haskell Symposium now) I have more than enough distractions
05:22:00 <trap_exit> hmm, any particularlly nice icp papers ?
05:23:02 <luite_> haven't had time to read many yet
05:23:12 <bernalex> b_jonas: yeah
05:32:55 <kuribas> a disadvantage of exceptions is that they are not visible in the type.
05:34:28 <kuribas> For example Int versus Either String Int
05:49:39 <remdezx> Hello! Does anybody know is it possible to remove somehow declared instance in ghci?
05:50:19 <Krautman> Declared instance? As in let bindings?
05:53:43 <remdezx> Krautman: I mean when I declare that e.g Int is instance of a class Foo
05:53:52 <Cale> remdezx: restart ghci?
05:53:57 <remdezx> Krautman: and now I want to remove it
05:54:27 <Krautman> I think :r should work
05:54:29 <exio4> :r?
05:54:32 <Krautman> But it has to detect a changed file
05:54:54 <Krautman> If you :r when no loaded file has changed, it doesn't actually reset the bindings
05:55:02 <remdezx> Maybe I'll tell my problem from the other point of view
05:55:21 <remdezx> I'm working with ghc-api to make an interpreter of my own dsl language
05:55:39 <remdezx> and in a GhcMonad i declare some instances
05:55:52 <remdezx> but sometimes I want to chcange them to other instances
05:55:59 <remdezx> and here I need to remove them first
05:56:23 <Krautman> That's on the level of declarations, there's no real "state" to change here
05:56:32 <Cale> Are you sure that type classes are the right solution here?
05:56:33 <Krautman> Only thing you can do is reload the source
05:57:01 <Krautman> Good point, type polymorphism could be an easy fix here
05:57:04 <Cale> You can generally use records of functions instead...
05:57:45 <remdezx> I know that I can re-declare all datatypes and connected instances to it will vanish, but I was thinking about easier solution
05:57:56 <Cale> Type classes tend to be the right thing when there aren't really multiple options for how to define them.
05:58:16 <Cale> Or you wouldn't mind using a newtype for defining new instances at least
05:59:50 <remdezx> recodrds of functions may be a good solution, but all the typeclasses I put to ghcmonad are not mine, I cannot really change it's logic
06:00:33 <remdezx> I didn't also found anything in ghc-api related to this topic
06:01:01 <remdezx> I think that it is not build to already declared instances....
06:01:31 <Krautman> Well, you can't "undeclare" things at runtime
06:01:58 <trap_exit> is there a channel here dedicated to the haste programming language? (the sorta-haskell -> js compiler)
06:02:08 <trap_exit> i am interesting in porting something like ahste or fay to swift
06:03:13 <remdezx> Krautman: that's true. Now I have to think how to overwrite them somehow ora drammatically change approach
06:03:48 <Krautman> Well, you can't make your logic depend on types directly, because that would call for a reflective approach
06:04:19 <Krautman> How about something analogous to the Either monad?
06:04:42 <Krautman> If you're only selecting cases of 3-4 ish types, that would be more-or-less doable
06:04:46 <Krautman> Ugly, but doable ;)
06:05:07 <Krautman> That way you can pattern match against the types
06:06:03 <Krautman> Another way would be declaring a superclass of the types involved, and making the relevant functions variant on that class
06:06:06 <remdezx> Krautman: that would be nice approach, but unfortuanately number of this types may vary and I don't know all of them at compile time
06:06:33 <Melany22>  You can find funny videos here. http://bit.ly/1mFMmyS
06:06:37 <Krautman> I have no idea how to /msg, /pm, /whisper, sorry ;)
06:06:37 <remdezx> adding new instance is easier than redefining the Either like datatype and all related to it code
06:07:17 <Krautman> Could you perhaps give a trivial example where your solution is needed?
06:07:52 <remdezx> I'll try to find something
06:08:07 <Krautman> For some arbitrary list of possible types, what do you intend to do with them that demands you have a variable number of types?
06:08:36 <Krautman> Because it might be something as simple as (a -> b) so to speak
06:14:01 <remdezx> Krautman: I think that I cannot change this aproach which uses instances now (not my code, and it will be needed to reimplement it from scratch)...
06:14:52 <remdezx> the main problem is, when I define some typeclass lile "class Foo a where foo :: a -> String"
06:15:10 <remdezx> and make int instance of it: "instance Foo Int where foo = show "
06:15:27 <remdezx> how to overwrite it with e.g. "instance Foo Int where foo = const "sda""
06:15:51 <Krautman> Depends. If you're in interactive mode, you can achieve that with shadowing
06:16:05 <Krautman> That is, the most recent binding overrides any previous ones
06:17:07 <Krautman> Also, at what point would you do this overwrite? That is, what triggers that?
06:17:22 <Krautman> Does it depend on the type? User input? Certain values?
06:18:04 <remdezx> Krautman: It's interactive mode - when users update code of a method in my dsl - I regenerae a code of instance and need to pass it to ghcmonad
06:18:29 <remdezx> methods in my dsl are connected with instances
06:18:38 <Krautman> Then just overwriting 'as is' should work
06:18:57 <remdezx> ok, so maybe I need some flag to be set?
06:19:02 <Krautman> That is, if the name and type matches, it should just shadow it
06:19:21 <Krautman> I don't think so, GHCI deals with it just fine
06:19:30 <Krautman> I don't see a reason why it would reject shadowing
06:20:19 <remdezx> when I declare them I get an error, look:http://lpaste.net/110497
06:21:01 <Krautman> Oh, I see.
06:21:27 <Krautman> Shadowing can only occur with let bindings
06:21:36 <remdezx> Krautman: true
06:21:38 <Krautman> So you could try this
06:21:46 <Krautman> let foo = undefined
06:21:57 <Krautman> Then your instance declaration where foo' = foo
06:22:06 <Krautman> Could that work?
06:22:16 <doismellburning> did someone say -Wall -Werror? ;)
06:22:33 <Krautman> Re-binding foo in a following let statement should re-bind the instance declaration
06:24:00 <remdezx> I don't really get it or it doesn't work - i get Prelude.undefined
06:24:07 <remdezx> did you tried it in ghci?
06:25:11 <Krautman> The undefined part is only as a placeholder
06:25:27 <Krautman> That is, first define let foo = undefined, so you can declare your instance to reference it
06:25:35 <Krautman> Then keep re-defining foo in let bindings
06:25:39 <Krautman> That is, let foo = show
06:25:47 <Krautman> let foo = const "asdf"
06:25:48 <Krautman> Etc
06:25:50 <Jafet> Whatever it is you're smoking...
06:26:02 <Krautman> Toilet paper, man. ;)
06:26:38 <remdezx> oh, looks good, I'll try it
06:27:09 <Krautman> I just realized I should've probably TESTED that before suggesting it. Apologies ;)
06:27:42 <Jafet> Maybe this is a hint that you should actually start to write an implementation of the language that isn't some sort of macro language around ghci.
06:27:45 <Krautman> Woops. Error indeed, sorry about that
06:28:33 <Krautman> Hey, what's error without trial? :)
06:29:19 <trap_exit> #haskell-haste in case anyone else wants to know
06:30:11 <remdezx> Krautman: why error? it worked for me?
06:33:22 <Twey> Hm, Hackage is pretty slow today.
06:33:24 <Jafet> Still, I suppose there's always a way: foo () = {-# NOINLINE #-} unsafePerformIO (readIORef active_foo); writeIORef active_foo show -- has limited polymorphism, or you could abuse the dubious ImplicitParams somehow
06:34:55 * hackagebot chatty-utils 0.7.1 - Some utilities every serious chatty-based application may need.  http://hackage.haskell.org/package/chatty-utils-0.7.1 (implementation)
06:34:57 * hackagebot chatty 0.6.1.0 - Some monad transformers and typeclasses for abstraction of global dependencies.  http://hackage.haskell.org/package/chatty-0.6.1.0 (implementation)
06:34:59 * hackagebot antisplice 0.17.0.2 - An engine for text-based dungeons.  http://hackage.haskell.org/package/antisplice-0.17.0.2 (implementation)
06:35:01 * hackagebot ironforge 0.1.0.33 - A technical demo for Antisplice.  http://hackage.haskell.org/package/ironforge-0.1.0.33 (implementation)
06:37:57 <Twey> Is there a nice lens expression equivalent to ((^. foo) &&& (^. bar)) ?
06:38:17 <prophile> that's already pretty nice
06:39:31 <supki> ^. runGetter ((,) <$> Getter foo <*> Getter bar)
06:40:15 <Twey> I'm not sure about that one.  :þ
06:41:24 <Taneb> Twey, supki's is more obviously extesnsible to more getters
06:43:04 <Twey> True
06:54:39 <yitz> @type \foo bar -> (^. runGetter ((,) <$> Getter foo <*> Getter bar))
06:54:39 <lambdabot>     Couldn't match expected type ‘(a1 -> f a1) -> s -> f s’
06:54:40 <lambdabot>                 with actual type ‘t’
06:54:40 <lambdabot>       because type variable ‘f’ would escape its scope
06:55:48 <kuribas> > digitToInt '3'
06:55:49 <lambdabot>  3
06:55:52 <kuribas> > digitToInt 'z'
06:55:54 <lambdabot>  *Exception: Char.digitToInt: not a digit 'z'
06:56:00 <kuribas> > fromEnum 'z' - fromEnum '0'
06:56:01 <lambdabot>  74
06:58:31 <ZioCrocifisso> is it possible to split a url in haddock to multiple lines?
06:58:40 <ZioCrocifisso> for example: -- ^ <goo
06:58:43 <ZioCrocifisso> -- gle.com>
07:00:29 <yitz> ZioCrocifisso: i take you tried and had trouble
07:00:59 <lpaste_> jonkri pasted “cabal sandbox problem” at http://lpaste.net/110499
07:01:41 <jonkri> I'm having the above pasted problem with the sandbox feature of Cabal; "setup: Main.hs doesn't exist". Any ideas? :)
07:04:29 <yitz> jonkri: it created the exe as expected the first time?
07:06:54 <jonkri> yitz: Yes (unless the compilation failed with an error).
07:08:35 <danilo2> Hello All! :) I've got a funny Haskell question today! :D I've got a function "s1 a -> (a -> s2 b) -> s3 b" and  want a general method to transform it into "s1 a -> (a -> m (s2 b)) -> m (s3 b)" (m is Monad, Applicative, Functor, whatever) - is it possible in general? :)
07:10:59 <yitz> danilo2: no. you would need to get inside the internal calculation and fmap over the result of applying the function.
07:12:43 <albeit> @pl (\y -> (y, f y))
07:12:43 <lambdabot> ap (,) f
07:12:47 <Cale> danilo2: Do we know anything about s1?
07:13:04 <Cale> (and s2, s3?)
07:14:00 <Cale> But yeah, it's not likely there's anything you can do
07:14:14 <yitz> Cale: in particular, if s2 == Void, then i think we can pull this off
07:16:19 <danilo2> Cale: we know that s1,s2 and s3 are Monads, Functors and Applicatives. Additional - they are newtypes (or simple datatypes just wrapping a value). Additional we've got fundep here s1 s2 -> s3
07:17:11 <danilo2> Cale: the former function is just a polymonad binding, like polyBind :: m1 a -> (a -> m2 b) -> m3 b (with fundeps m1 m2 -> m3)
07:17:50 <danilo2> Cale, but "m" in my first question could be IO, so wqe cannot "unpack" it
07:18:19 <bernalex> is there a '(Monad m, Monad n) => m a -> m (n a)' somewhere?
07:18:33 <bernalex> ...
07:18:42 <bernalex> I guess it was a tricky question
07:19:48 <Twey> bernalex: That'd be ‘fmap return’
07:20:16 <bernalex> Twey: I know
07:21:51 <brycelane> anybody know the deal with haskell.org right now?
07:21:55 <bergmark> bernalex: usually if the answer is that short there isn't a shorter answer
07:26:07 <srhb> Is haskell.org ded?
07:26:18 <srhb> Ah. I guess it is
07:26:20 <srhb> brycelane: :P
07:28:06 <yitz> srhb: people are saying that it is slow
07:28:28 <Jasch> it works for me, but the loading time is very high
07:28:45 <yitz> jonkri: i can't reproduce your problem with just that information. there must be some other detail that is causing it.
07:28:53 <Guest22099> @type maybe
07:28:54 <lambdabot> b -> (a -> b) -> Maybe a -> b
07:29:21 <Guest22099> what is the significance of first b?
07:29:37 <jonkri> yitz: Thank you for trying.
07:29:47 <yitz> Guest22099: apply the function b to only the first component of a tuple
07:30:00 <yitz> > first (+1) (5,7)
07:30:02 <lambdabot>  (6,7)
07:30:29 <yitz> jonkri: yw. sorry i wasn't able to help more than that so far.
07:31:24 <Guest22099> sorry yitz, I am asking about b in type defn of maybe function
07:31:32 <Guest22099> @type maybe
07:31:33 <yitz> ahh :)
07:31:33 <lambdabot> b -> (a -> b) -> Maybe a -> b
07:31:45 <danilo2> Hello! Lets assume I've got a value (x :: IO Int). Is it unsafe (does it have any drawbacks (lower perfromacne/ anything) to do  (toIO $ f (unsafePerformIO x)) where toIO :: a -> IO a; toIO = return ?
07:31:53 <jonkri> yitz: I'm trying another package now.
07:32:18 <yitz> > maybe 999 (+1) (Just 7)
07:32:20 <lambdabot>  8
07:32:24 <yitz> > maybe 999 (+1) Nothing
07:32:26 <lambdabot>  999
07:32:42 <Guest22099> Ah :-) thanks
07:34:19 <tero-> is there a function to execute all monadic actions in a tuple sequentially?
07:34:40 <tero-> like sequence but for tuples
07:35:45 <yitz> @type uncurry (liftM2 (,))
07:35:46 <lambdabot> Monad m => (m a1, m a2) -> m (a1, a2)
07:35:52 <kuribas> ghc-mod sucks...
07:36:06 <kuribas> Do I really have to restart emacs because something changes in my project setup?
07:36:08 <yitz> tero-: still there? freenode netsplit happening... :(
07:36:18 <tero-> yitz: still here
07:36:35 <yitz> tero-: ok. i tried to show you one way to do it.
07:36:39 <Javran> @pl \a b -> a:b:[]
07:36:39 <lambdabot> (. return) . (:)
07:37:15 <tero-> yitz: this 'uncurry (liftM2 (,))'?
07:37:19 <yitz> yes
07:38:02 <tero-> it works for 2-tuples, right?
07:38:47 <albeit> @pl (\(_,a) (_,b) -> f a `compare` f b)
07:38:47 <lambdabot> (. snd) . (. f) . compare . f . snd
07:38:52 <yitz> tero-: right. for 3 tuples, you'd need a triples version of uncurry.
07:39:08 <albeit> @pl (\(_,a) (_,b) -> a `compare` b)
07:39:08 <lambdabot> (. snd) . compare . snd
07:40:28 <tero-> yitz: okay. 2-tuples are enough. just wondering if there is something that works with n-ary tuples
07:40:57 <yitz> tero-: you could do: \(x,y,z) -> (,,,) <$> x <*> y <*> z
07:41:08 <yitz> tero-: but that's kinda cheating i guess.
07:41:59 <supki> sequenceOf each  works up to 9-tuples
07:42:08 <yitz> tero-: we're usually not too worried about generalizing things to n-tuples. we consider each size tuple to be its own special case, and anyway try very hard never to use more than 2- or 3- tuples.
07:42:11 <srhb> In a group of foreign imports, is it correct that I only need to specify a common header once, in the first call?
07:42:28 <tero-> yitz: I promise :)
07:42:33 <srhb> I'm looking at some code that coes foreign import ccall unsafe "header name" and the next goes foreign import ccall unsafe "name"
07:42:37 <srhb> goes*
07:42:37 <yitz> tero-: heh :)
07:42:39 <tero-> supki: nice
07:43:17 <yitz> @type sequenceOf
07:43:18 <lambdabot> LensLike (WrappedMonad m) s t (m b) b -> s -> m t
07:43:19 <geekosaur> srhb: I think that's implementation dependent
07:43:26 <yitz> oh it's a lens thing.
07:43:54 <srhb> geekosaur: Righto.
07:43:56 <geekosaur> It probably works with ghc, but nothing stops a compiler implementation from putting each one in its own C source file in which case the header would be needed in all of them
07:44:05 <srhb> But it's correct for GHC?
07:44:12 <geekosaur> (also no promised ghc won't change behavior at some point)
07:44:15 <srhb> Well, you said probably.
07:44:18 <srhb> :-)
07:44:38 <nitrix> Anyone would recommend Yesod for a webserver?
07:44:46 <nitrix> Or is there better?
07:44:47 <geekosaur> I am guessing, yes. but the behavior has already changed a few times, once for -fasm and it's not impossible -fllvm needs something different again
07:45:13 <srhb> Ok. So put in header files always.
07:48:48 <yitz> supki, tero-: but that only works if the types in the tuple are all the same
07:48:52 <yitz> > fromJust $ sequenceOf each (return 5, return 7)
07:48:53 <lambdabot>  (5,7)
07:48:54 <yitz> > fromJust $ sequenceOf each (return 5, return "foo")
07:48:56 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Char])
07:48:56 <lambdabot>    arising from the literal ‘5’
07:51:19 <yitz> nitrix: we use yesod for several of our products at work. we're quite happy with it.
07:51:27 <yitz> nitrix: but it depends what you need
07:53:07 <bernalex> so uh what do you do when you have a module called Control.Monad and want to uh import Control.Monad
07:53:52 <tdammers> bernalex: rename one of the two?
07:54:13 <tdammers> I don't think you can have two modules of the same name within the same project in a meaningful way
07:54:15 <bernalex> tdammers: I'm not sure people will be too pleased with me if I rename Control.Monad in base
07:54:34 <bernalex> tdammers: it's not in the same project. one is in base. one is in my project.
07:54:50 <tdammers> well, what I really meant is "don't call your own module Control.Monad".
07:54:56 <yitz> bernalex: -XPackageImports
07:55:16 <yitz> bernalex: but really, tdammers is right
07:55:40 <ClaudiusMaximus> package imports extension? http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#package-imports
07:55:59 <tdammers> Protip: prepend a common namespace to all of your own modules
07:56:11 <tdammers> MySuperDuperProject.Control.Monad -- problem solved
07:56:48 <bernalex> not while hacking on the project internally
07:56:59 <bernalex> I mean when other people use it, they obviously need to do import Lulz.Control.Monad
07:57:18 <geekosaur> trying to call a module of your own Control.Monad is just asking for trouble
07:57:21 <geekosaur> don't
07:57:23 <yitz> bernalex: why not? we always do that, even when hacking internally. avoids many problems.
07:57:51 <tdammers> IMO it's way less hassle to prepend the namespace from the get-go
07:57:57 <tdammers> not a lot of extra typing
07:58:18 <bernalex> yitz: wat? won't the people who use your library have to import Lol.Lol.Control.Monad and so on then?
07:58:19 <tdammers> much easier than going back later and figuring out which imports need the prefix and which don't
07:58:33 <yitz> no
07:58:53 <yitz> just name it Lol.Control.Monad, and that's its name.
07:58:54 <danilo2> yitz: Thank you! I overloked your message :)
07:58:56 <geekosaur> I'm afraid to ask what you are doing that internal and external module names differ
07:58:58 <bernalex> yitz: oh right
08:00:18 <yitz> danilo2: ah, np. that was with Cale.
08:00:27 <yitz> so you can't lose.
08:00:45 <srhb> Another FFI question. When I have Storable FooStruct and I'm implementing peek ptr = do ... foo <- (#peek FooStruct cFoo) ptr -- is cFoo the name of the field in the C Struct?
08:00:51 <danilo2> yitz: :)
08:01:58 <srhb> (Because that seems weird.)
08:02:44 <danilo2> I've got yet another question :) If anybody knows the answer I would be very thankful for sharing it - lets assume I've got a value (x :: IO Int). Is it unsafe (does it have any drawbacks (lower perfromacne/ anything) to do  (toIO $ f (unsafePerformIO x)) where toIO :: a -> IO a; toIO = return ?
08:04:13 <Cale> danilo2: Well, why use unsafePerformIO when you could use fmap f . unsafeInterleaveIO
08:04:34 <tero-> yitz: ah, true
08:05:15 <Cale> danilo2: Note that the effects will happen when the result is evaluated
08:05:46 <danilo2> Cale: I simplified the example. The real question is to transform a function ""s1 a -> (a -> s2 b) -> s3 b" into "s1 a -> (a -> IO (s2 b)) -> IO (s3 b)"
08:06:00 <Cale> What are s1, s2, s3?
08:06:03 <danilo2> Cale: As we discussed earlier. With such trick I would be able to do it.
08:06:37 <Cale> Well, probably having the effects happen at a random time isn't really what you want
08:07:00 <danilo2> Cale: s1,s2 and s3 are Functors, Monads and Applicatives. They've got fundep: s1 s2 -> s3 and the former function is taken from my PolyMonad type class: polyBind :: s1 a -> (a -> s2 b) -> s3 b
08:07:15 <danilo2> Cale: Of course not.
08:07:38 <danilo2> Cale: I was just thinking that maybe we can just tell GHC somehow to connect the operation to the new IO
08:10:11 <Philonous> How do I build local haddock documentation for all installed packages?
08:10:19 <jnoat> https://www.youtube.com/watch?v=UU3p67qrfhw WATCH THIS WATCH THIS https://www.youtube.com/watch?v=UU3p67qrfhw WATCH THIS https://www.youtube.com/watch?v=UU3p67qrfhw WATCH THIS https://www.youtube.com/watch?v=UU3p67qrfhw WATCH THIS https://www.youtube.com/watch?v=UU3p67qrfhw WATCH THIStw bpbqu rmjf eh tkd gcjjnj vvwp xihrxahuzg hihzx zgld
08:10:23 <jnoat> https://www.youtube.com/watch?v=UU3p67qrfhw WATCH THIS WATCH THIS https://www.youtube.com/watch?v=UU3p67qrfhw WATCH THIS https://www.youtube.com/watch?v=UU3p67qrfhw WATCH THIS https://www.youtube.com/watch?v=UU3p67qrfhw WATCH THIS https://www.youtube.com/watch?v=UU3p67qrfhw WATCH THISmyhuya oas ibm fhzwspwlo pufserqqri i nrzuxz rireix f joy
08:10:27 <jnoat> https://www.youtube.com/watch?v=UU3p67qrfhw WATCH THIS WATCH THIS https://www.youtube.com/watch?v=UU3p67qrfhw WATCH THIS https://www.youtube.com/watch?v=UU3p67qrfhw WATCH THIS https://www.youtube.com/watch?v=UU3p67qrfhw WATCH THIS https://www.youtube.com/watch?v=UU3p67qrfhw WATCH THISdhnkyfuosd tx kxcge chiyx bcypizdcmh wvewwsnz
08:10:27 <jnoat> https://www.youtube.com/watch?v=UU3p67qrfhw WATCH THIS WATCH THIS https://www.youtube.com/watch?v=UU3p67qrfhw WATCH THIS https://www.youtube.com/watch?v=UU3p67qrfhw WATCH THIS https://www.youtube.com/watch?v=UU3p67qrfhw WATCH THIS https://www.youtube.com/watch?v=UU3p67qrfhw WATCH THISjccltt vgxvpat nx jsq
08:11:13 <b_jonas> Philonous: I'm not sure you can always do that. Do the installed copies always contain all the necessary source for the haddock? I think you need the source tarballs of the packages to be able to build docs.
08:11:22 <Fuuzetsu> protip: don't watch this
08:11:32 <yitz> @where ops
08:11:32 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
08:11:45 <yitz> oh sorry. it's gone.
08:12:06 <Hodapp> spoiler: It's a Canada Dry commercial from the '70s
08:12:14 <Philonous> b_jonas, well the source packages are still around, since I installed all the packages via cabal install
08:12:26 <Fuuzetsu> Hodapp: disappointing
08:12:33 <Hodapp> sorry, '60s
08:12:39 <Fuuzetsu> oh that's alright then ;^)
08:12:42 <shapr> ops have arrived!
08:12:57 <yitz> Hodapp: possible augmented with some hidden drive-by browser exploit
08:13:00 <Philonous> Fuuzetsu, Well, it did get the job done, didn't it ;)
08:13:18 <albeit> @pl (\a -> (f a, snd $ g a))
08:13:18 <lambdabot> liftM2 (,) f (snd . g)
08:13:33 <Hodapp> yitz: possibly
08:13:45 --- mode: ChanServ set +o Cale
08:13:47 <Fuuzetsu> b_jonas: Haddock reads out documentation from interface files it creates
08:13:54 <Cale> oh, already K-lined
08:14:00 --- mode: Cale set -o Cale
08:14:09 <shapr> they beat us to the kickban
08:14:15 <yitz> shapr: thanks. looks like freenodes bots already booted the spam bot. do we regularly ban those things, or is it a waste of time?
08:14:32 <yitz> ah, banned too. nice.
08:14:36 <shapr> yitz: it's always worth getting rid of spam, you never know when they'll return
08:14:44 <albeit> Anybody know how to run pointfree from Ubuntu? I've done "cabal install pointfree", but I'm not sure how to get it to run as a standalone program...
08:15:18 * shapr stalks yitz on the internet
08:15:24 <shapr> yitz: ooh, getting paid to write Haskell :-)
08:15:37 * yitz yes :)
08:15:56 <shapr> I write some Haskell to process data, but we only really do Python here.
08:15:59 <yitz> shapr: and not for a bank
08:16:03 <shapr> even more impressive!
08:16:04 <bartavelle> anybody could recommend a library for simple boolean simplification (such as "a || (a && b) -> a")
08:16:06 <td123> albeit: if it's a program, check ~/.cabal/bin
08:16:12 <td123> albeit: you might have to add that to your path
08:16:25 <shapr> I wonder how many paid Haskellers hang out here nowadays?
08:16:32 <b_jonas> Philonous: I see
08:16:41 <shapr> Cale: Do you get paid to write Haskell?
08:16:58 <Philonous> b_jonas, Apparently it's enought to add documentation: True to the cabal configuration
08:17:00 <albeit> td123: Ah it was my sandbox's /bin, thanks
08:17:04 <Cale> shapr: Soon!
08:17:14 <shapr> Cale: got a job coming up?
08:17:21 <bartavelle> shapr : I spend a fair amount of my time writing, haskell, but that's not in my job description, I don't know if this fits your criteria
08:17:44 <Cale> shapr: Yeah, I'm going to be working with Jacques Carette on an embedded DSL for probabilistic computation in Haskell with a Maple backend.
08:17:50 <shapr> Cale: ooh, nifty!
08:18:09 <shapr> bartavelle: hey, if you write Haskell and your employer likes the results...
08:18:15 <shapr> I guess that fits into my situation as well.
08:18:23 <yitz> bartavelle: it's not in my job description either. but since i came to the company, our haskell usage has gradually increased to the point that some of our major products are in haskell.
08:18:56 <shapr> yitz: awesome!
08:18:58 <Cale> shapr: Before this I was working for skedge.me on their web application backend that was in Haskell.
08:19:03 <bartavelle> yitz nice !
08:19:19 <shapr> My employer is fine with me writing anything in Haskell as long as I promise to hang around and maintain it. Not so many Haskellers in small town Alabama.
08:19:26 <yitz> a bunch of our employees are now happy haskellers
08:19:40 * hackagebot data-interval 0.6.0 - Interval arithmetic for both open and closed intervals  http://hackage.haskell.org/package/data-interval-0.6.0 (MasahiroSakai)
08:19:47 <yitz> shapr: there's always well-typed and fp-complete
08:19:52 <yitz> etc.
08:19:56 <tdammers> I find the idea that programmers are somehow tied to a particular language somewhat strange
08:20:06 <shapr> I often prototype/design my code in Haskell and then rewrite it in Python.
08:20:18 <tdammers> people are trying to hire PHP programmers, Java programmers, C# programmers, etc.
08:20:27 <shapr> tdammers: I agree, but source code is primarily for communication with other programmers, and only secondarily for communication with a computer.
08:20:28 <Ankhers> I was close to getting our main project written in Haskell. Then my CTO decided to go with go because the packages are apparently more accessible.
08:20:40 <tdammers> shapr: yes, sure
08:20:41 <bartavelle> shapr : I am supposed to do that, or to bring my coworkers up to speed in haskell. I have to say I find this intimidating
08:20:50 <yitz> Ankhers: more accessible in what sense?
08:21:09 <Ankhers> yitz: I don't have the slightest. That was just the reason I was given.
08:21:11 <tdammers> what I mean is, don't hire an XYZ programmer; hire a programmer, and they'll pick up XYZ as needed
08:21:11 <shapr> bartavelle: eh, drag 'em here into #haskell :-)
08:21:26 <tdammers> if they're good, that is; if they're not, don't hire them
08:21:37 <yitz> bartavelle: those coworkers might find it intimidating if they believe the old fud, but whay should you find it intimidating?
08:21:47 <shapr> tdammers: that's not true of most commercial programmers I've known, at least, not outside communities like this one.
08:21:49 <bartavelle> yitz : they are not developers
08:22:07 <shapr> Yeah, I often hit FUD when I talk about Haskell to programmers.
08:22:14 <yitz> bartavelle: that might even make it easier :) if they've got some talent
08:22:24 <tdammers> shapr: I am painfully aware of that
08:22:30 <yitz> shapr: it's not as bad as it used to be
08:22:32 <Taneb> Is there a newtype anywhere newtype Foo f a with instace Applicative f, Monoid a => Monoid Foo f a?
08:22:44 <mgaare> tdammers: it's about signalling. If you are the type of person who will learn whatever is being worked with, "we're looking for suchandsuch programmers" is a signal that it's not for you
08:22:47 <bartavelle> yitz : they also need the dedication, and I need to be able to teach, which is not a given
08:23:07 <shapr> yitz: I still hit pockets of "Haskell requires a PhD in Math, can't be used to write *real* programs, isn't used in the real world" and all that
08:23:09 <tdammers> mgaare: probably, yes
08:23:15 <yitz> right
08:23:22 <mgaare> some places will ask for unusual/interesting technologies as a signal that they are looking for that kind of person
08:23:39 <shapr> Then I point out that I learned Haskell before I'd ever taken a calculus course, Facebook uses Haskell, etc
08:23:42 <yitz> Taneb: how about -XGeneralizedNewtypeDeriving ?
08:23:47 <mgaare> and to weed out the "Java alphabet soup" programmers
08:23:49 <exio4> shapr: well, at least they know Haskell
08:23:55 <Taneb> yitz, not helpful
08:23:57 <tdammers> mgaare: but I'm pretty positive most of those job ads are written by people who actually think that learning a programming language takes years
08:24:00 <yitz> Taneb: oh well.
08:24:09 <Taneb> What I want is mempty = pure mempty, mappend = liftA2 mappend
08:24:17 <yitz> aha
08:24:27 <mgaare> tdammers: they might be correct for the type of person they're hiring
08:24:52 <mgaare> maybe not "years", but substitute "some amount of time that is not acceptable to us" for "years"
08:24:55 <shapr> exio4: Funny thing is that showing Haskell code to people who don't know much about the language often gets them excited about learning it.
08:24:58 <tdammers> mgaare: yes, they probably are - i guess what I'm saying is the person they're hiring is not the person they *want* to hire
08:25:36 <mgaare> tdammers: Some companies really don't want top people, for a variety of reasons
08:25:42 <yitz> tdammers: it's just learning the language. most "real world" languages have many obscure gotchas when used within any given domain. it takes experience to find out what they are.
08:26:05 <tdammers> mgaare: yeah, and I don't want to work there
08:26:16 <mgaare> tdammers: exactly, it works out for both sides.
08:26:29 <Ankhers> top people are too expensive
08:26:33 <tdammers> mgaare: I mean, I don't need *top* people around me, but I do want the kind who isn't afraid of learning stuff
08:26:39 <Ankhers> (not me saying this, just what I have heard said)
08:26:45 <tdammers> mgaare: doesn't have to be google or facebook
08:27:42 <yitz> Ankhers: they're not - they're worth it, even for menial tasks. that is google's hiring philosophy. but it's not easy to hire 20,000 top people within a year or two to do menial tasks.
08:28:14 <tdammers> the trick with hiring top people is that they will automate the menial tasks away eventually
08:28:18 <Philonous> tdammers, But _really_ learning a new languages does take years, doesn't it?
08:28:31 <tdammers> Philonous: depends on prior knowledge
08:28:36 <Ankhers> yitz: I agree 100%. Like I said, this wasn't me saying it. I have just heard people say that in the past.
08:28:38 <mgaare> tdammers: where I live, the standard job posting reads like, "looking for someone with N years in [java alphabet soup technology list]" - and places like that aren't looking for you, and you're not looking for places like that.
08:28:48 <tdammers> Philonous: I already knew Java and C++ when I started working with C#
08:28:57 <tdammers> mgaare: yes, I know
08:29:10 <tdammers> mgaare: I have learned to not even bother reading the entire job ad
08:29:41 <tdammers> Philonous: took me about 2 weeks to become productive, and within a month I knew everything I needed to do solo projects
08:30:28 <tdammers> and what I delivered pretty much just worked; some of that is still in active use
08:30:44 <Philonous> tdammers, Common wisdome seems to be that C# is basically Java with a new wallpaper, so that's not that surprising
08:30:58 <tdammers> yes, exactly
08:31:05 <tdammers> Haskell took me longer, and I'm still learning.
08:31:32 <tdammers> right, time to go home.
08:31:41 <yitz> tdammers: it took me about 30 min. to switch from perl to python and become productive. but yeah haskell takes a lot longer. and in either case - there are still the hidden gotchas.
08:32:01 <mgaare> tdammers: personally my strategy is to prominently list Clojure in my stuff, and if someone reaches out and doesn't mention that at all then I assume it's not of interest
08:32:28 <Eliel> does code generated by ghc ever explicitly free memory or does it always leave it to the garbage collector?
08:33:13 <shapr> When I learned Prolog for a course last year, I found that to be a big jump, it took serious brain stretching to do anything useful.
08:33:57 <shapr> My theory is that it's best to really learn at least one language in each of the imperative, functional, and logic flavors.
08:34:54 <shapr> I keep hoping for new language flavors. Postfix stack-based like Joy is almost another flavor.
08:35:06 <zwer> shapr what language changed your way of thinking more, prolog or haskell?
08:35:23 <monochrom> it is important for critical thinking to know more perspectives.
08:36:16 <shapr> zwer: Haskell changed my thinking the most, but I only knew imperative languages at the time.
08:36:40 <shapr> Although, unification for everything just doesn't seem like as much a stretch as pure FP.
08:37:07 <shapr> So I think Haskell wolud have changed my thinking more even if I'd known imperative and logic languages.
08:37:49 <shapr> zwer: Have you learned logic and fp languages? Any thoughts on how your thinking has changed?
08:38:20 <RchrdB> shapr, learning Prolog makes Haskell's type-inference easier to comprehend. :)
08:38:26 <RchrdB> ~sorta.
08:38:46 <RchrdB> Learning Prolog made me a lot more comfortable with using the (Monad []) instance for non-determinism.
08:39:35 <shapr> RchrdB: Yeah, I agree with that, suddenly backtracking makes more sense
08:40:40 <yitz> srhb: you're using hsc2hs? the docs say "Arguments look like C expressions separated by commas". so they're both C expressions. #peek struct_type, field
08:40:46 <shapr> Somedays I want to dig back into the various resolution algorithms for Prolog, I think there's a decade's worth of PhDs left to discover in there somewhere.
08:40:53 <srhb> yitz: I see.
08:42:31 <yitz> RchrdB: StateT []
08:44:46 <srhb> What's the correct way to make cabal build a hsc file for a cabal project with both an executable and the hsc module?
08:45:15 <RchrdB> yitz, hmm, that's nice. :)
08:46:23 <RchrdB> shapr, I'm not sure that I have the full benefit of LP though; I didn't do enough Prolog to really get into metaprogramming with it, and I didn't write anything big enough to get comfortable with it beyond toy coursework exercises.
08:46:40 <RchrdB> TODO standard silly hobby project, write a bad web framework for Prolog. ;)
08:46:55 <yitz> RchrdB: when i was first learning monads, i used that type to write my first sudoku solver. it was a really good exercise.
08:47:46 <shapr> I'm not sure I got the full benefit either. I took a programming languages course where we were assigned a language and wrote a large paper. I dove into Prolog and had a blast.
08:48:23 <shapr> I wrote a simple degree solver that gave tenative graduation dates for CS degrees at my university.
08:48:39 <yitz> RchrdB: when there are multiple solutions, will it tile the web page with the results, or open multiple tabs?
08:49:25 <yitz> shapr: did you include a hidden backdoor that got you out earlier?
08:51:25 <RchrdB> yitz, I did write one Soduku solver in Prolog! However I was in a massive hurry because of being an awful student, so I wrote what was effectively a Lisp program in Prolog, using the call/1 predicate a *lot*. ¬_¬
08:51:34 <shapr> yitz: I never finished the "big red button" that would find ANY degree that would get you out soonest.
08:51:57 <RchrdB> it was easier to transcribe the functional program that I had in my head into Prolog than to write a real logic program for it. :(
08:53:02 <RchrdB> yitz, hmm, I'm thinking "very long web page, displaying a HTML UI for every possibility that matched, stacked vertically." :)
08:53:50 <assia_t> Hey there
08:54:20 <RchrdB> Hello assia_t.
08:54:39 <shapr> hi assia_t, how's code?
08:55:13 <yitz> RchrdB: ah, so tumblr is still all the rage, is it... even forbes.com is doing that now...
08:55:26 <assia_t> shapr: all right
08:55:48 <assia_t> I'm wondering if you've seen the standardmarkdown.com page yet
08:56:06 <Krautman> @pl (\x -> (x, div y x))
08:56:06 <lambdabot> ap (,) (div y)
08:56:18 <Krautman> :type ap
08:56:23 <Krautman> >:type ap
08:56:42 <shapr> assia_t: I haven't seen it, did you write a Markdown parser in Haskell?
08:57:03 <assia_t> And if there's any ongoing community effort on making PanDoc support it; I know John MacFarlane - markdown's author - is on this project.
08:57:06 <yitz> @type ap
08:57:07 <lambdabot> Monad m => m (a -> b) -> m a -> m b
08:57:17 <yitz> @type (<*>)
08:57:18 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
08:57:30 <Krautman> Thanks for that ;)
08:57:46 <assia_t> shapr: No... Standard markdown is a test suite and spec for markdown, ran by a couple of people from around (github, so, reddit etc.)
08:57:54 <yitz> Krautman: for functions, they are the S combinator: S x y z = x z (y z)
08:58:03 <nitrix> I think hackage's down :(
08:58:20 <yitz> nitrix: not down (i think) but slow
08:58:23 <assia_t> c
08:58:35 <nitrix> That thing's just too convenient -.-
08:58:52 <nitrix> I wonder if they shouldn't have a mirror system.
08:59:13 <assia_t> Well... I'm guessing nobody started it yet?
08:59:15 <companion_cube> wtf does "Are the Yankees the best team in baseball?" do in this a standardization page??
08:59:22 <companion_cube> -this
08:59:24 <yitz> nitrix: see the topic for this channel
09:01:06 <yitz> companion_cube: true, but it's still better than lorem ipsum.
09:01:44 <assia_t> companion_cube: Well... it's just a joke and this isn't even the spec, just the homepage.
09:02:39 <companion_cube> that is so american-centered.
09:04:53 * hackagebot language-c-inline 0.7.6.0 - Inline C & Objective-C code in Haskell for language interoperability  http://hackage.haskell.org/package/language-c-inline-0.7.6.0 (ManuelChakravarty)
09:06:41 <Krautman> Apparently everyone's having trouble with Hackage at the moment
09:06:51 <Krautman> It seems afwully slow
09:07:17 * monochrom joins the effort of slashdotting hackage :)
09:08:23 <albeit> companion_cube: I'm Canadian and I watch baseball ;)
09:09:53 <Ankhers> albeit: That isn't very Canadian of you.
09:10:09 <yitz> monochrom: unfortunately, it doesn't seem to be taking very much effort to slashdot hackage today
09:10:11 <monochrom> baseball is big in Canada
09:10:18 <Ankhers> Not where I live.
09:10:33 <Ankhers> Or maybe it is. I'm just not a big sports person.
09:11:17 <yitz> Ankhers: baseball is also popular in japan and cuba.
09:12:58 <zomg> Not anything new for something on the internet to be america-centric :p
09:13:24 <Ankhers> Especially with the current time.
09:16:24 <srhb> So, now I should have a pointer to a thing which I have a Storable instance for... How do I actually print one of those values?
09:16:37 <srhb> As in, I have Ptr Thing, how do I get IO Thing or something like that?
09:19:26 <Jafet> @hoogle Ptr a -> IO a
09:19:26 <lambdabot> Foreign.Storable peek :: Storable a => Ptr a -> IO a
09:19:26 <lambdabot> Foreign.Marshal.Alloc free :: Ptr a -> IO ()
09:19:26 <lambdabot> Network.Socket.Internal peekSockAddr :: Ptr SockAddr -> IO SockAddr
09:22:08 <srhb> Derp, thanks.
09:32:37 <il> .join #jaskell
09:35:03 <il> i heard this channel is the bees knees
09:35:08 <il> why is no one talking
09:35:11 <dfeuer> Is Hackage down?
09:35:27 <monochrom> not really. but slow yes.
09:35:35 <simpson> il: It's rare for a channel to constantly be abuzz.
09:35:42 <srhb> Dear lord, xkb is not for newbies.
09:35:53 <simpson> srhb: Indeed. Sorry. :c
09:36:03 <dfeuer> srhb, are you talking about the X keyboard arrangement thingum?
09:36:04 <srhb> simpson: It's your fault?! :-)
09:36:21 <srhb> dfeuer: Yeah. Trying to extract the names of my layout groups for XMonad.
09:36:30 <simpson> srhb: I have a commit bit for most freedesktop.org projects, and I certainly haven't tried to improve the situation. :3
09:36:41 <dfeuer> srhb, I think there are alternatives to xkb these days.
09:36:43 <srhb> simpson: Then I'll just scowl at you every now and then.
09:36:52 <simpson> srhb: Fair enough.
09:37:04 <srhb> dfeuer: Not sure if any of them apply.
09:37:05 * hackagebot lss 0.1.0.0 - Lexical Style Sheets - a language for writing styles that is focused around lexical (ie, static) scoping and re-use of large components.  http://hackage.haskell.org/package/lss-0.1.0.0 (DanielPatterson)
09:37:23 <srhb> Though in all honesty this is the first time working with the FFI, so things are a bit.. Complex.
09:37:53 <dfeuer> srhb, I think keyboard stuff might just be inherently complicated.
09:38:01 <dfeuer> But hey, maybe you can fix it!
09:38:14 <srhb> dfeuer: Hah! I'm just trying to read a tiny, tiny list of names. Nothing else! :P
09:40:13 <dfeuer> srhb, just write a Haskell package that parses xkb configuration files and gives you access to what you need. You'll solve your problem and be well on your way to writing yet another xkb replacement!
09:40:41 <srhb> dfeuer: That's almost cruel enough that I might consider it. :P
09:40:48 <srhb> (But no, not really)
09:42:21 * hackagebot snaplet-lss 0.1.0.0 - Lexical Style Sheets - Snap Web Framework adaptor.  http://hackage.haskell.org/package/snaplet-lss-0.1.0.0 (DanielPatterson)
09:43:39 <srhb> simpson: Where should I go on Freenode to ask questions about XKB?
09:43:41 <srhb> If any.
09:43:58 <shapr> il: Would you like to learn Haskell?
09:45:22 <il> shapr, yes
09:45:32 <shapr> il: awesome! you've come to the right place!
09:45:50 <il> Lol yay
09:46:08 <shapr> il: I'd suggest you start with bitemyapp's github repository for websites to peruse, lemme find a link...
09:46:19 <shapr> il: https://github.com/bitemyapp/learnhaskell
09:46:20 <il> ty
09:46:34 <shapr> il: do you have any previous experience programming?
09:47:13 <il> shapr, yes indeedily
09:47:23 <shapr> il: cool! me too!
09:47:25 <il> shapr, what can I do with haskell?
09:47:34 <shapr> il: whatever you can do with a programming language!
09:47:43 <shapr> il: so, what are you able to do with a programming language?
09:47:56 <il> build web apps and what not
09:48:01 <shapr> I have a few simple programs I implement whenever I learn a new language.
09:48:09 <il> like game of life?
09:48:18 <shapr> il: oh good, Haskell has several web frameworks of different thicknesses
09:48:37 <shapr> il: sure! I write a fractal generator as my first program, just because that's something I know well.
09:49:08 <il> shapr, kewl
09:49:26 <il> shapr, what's your math knowledge like?
09:49:34 <shapr> il: I've built several web apps with Haskell, I'm working on dumbcartags.com after hours
09:49:41 <shapr> il: well, I almost passed a calculus course once :-/
09:49:58 <il> Lol
09:50:08 <il> dumbcartags is down
09:50:09 <shapr> il: what about you?
09:50:12 <shapr> il: yeah, I'm not done yet!
09:50:22 <il> shapr, I passed precal and ap stats
09:50:25 <il> never took calc
09:50:31 <shapr> oh that's cool. I enjoyed my stats class
09:50:33 <il> dropped out of college
09:50:49 <shapr> I dropped out of college too, but I came back after having a career and then I finished!
09:50:54 <shapr> I graduated in December, w00!
09:50:54 <il> same here, I'm working with mainly statisticians
09:51:03 <il> noice
09:51:41 <shapr> il: so, I'd suggest you follow the directions on that learnhaskell page and ask any quetions you have here, or on #haskell-beginners
09:52:10 <il> ok ty
09:53:01 <il> shapr, what sites do you frequent?
09:53:18 <il> shapr, I'm trying to get away from reddit and HN
09:53:31 <shapr> well, reddit has its good points, I like r/haskell
09:53:53 <il> shapr, yea but there's so much noise
09:54:01 <Krautman> If I may drop in, I've tried avoiding reddit, until I found /r/ProgrammerHumor ;)
09:54:02 <hiptobecubic> /r/haskell doesn't have nearly enough noise
09:54:05 <shapr> il: but I admit, I try to find people who share good links on twitter
09:54:13 <il> Krautman, that is a good subreddit
09:54:27 <il> shapr, twitter is good? I never could get into twitter
09:54:33 <simpson> srhb: #xorg is a mediocre starting place.
09:54:33 <Krautman> And of course /lolphp for the PHP haters out there
09:54:37 <gratimax_> talking about social media on #haskell? what is this?
09:54:45 <srhb> simpson: I see. :-)
09:54:51 <shapr> il: well, depends on the person... I follow lots of interesting Haskellers on twitter
09:54:54 <Krautman> Apologies, gratimax person ;)
09:55:21 <srhb> There's an /r/lolphp? I did not know.
09:55:22 <il> shapr, I may reconsider.
09:55:47 <il> lmao, lolphp
09:56:01 <Krautman> I shouldn't have said anything there, really :P
09:56:13 <il> shapr, can you recommend some good twitter handles?
09:56:37 <shapr> il: er, people to follow? I would immediately recommend you follow shapr ;-)
09:56:55 <il> shapr, I has a friend!
09:56:59 <shapr> w00t!
09:57:02 <il> yay
09:57:31 <monochrom> the people I follow are the people followed by everyone who follows all people I follow
09:57:43 <Krautman> So much for set theory.
09:59:05 <RchrdB> Krautman, Russel's paradox doesn't arise if you don't have negation. :)
09:59:44 <il> shapr, I saw you do a cartwheel
09:59:47 <il> :)
09:59:56 <shapr> il: yes! I do cartwheels all the time!
10:02:01 <Krautman> let cartWheel = cycle ["Right leg", "Right hand", "Left hand", "Left leg"]
10:02:11 <Krautman> Couldn't resist ;)
10:02:27 <yitz> il: the feed at haskellnews.org is pretty good
10:03:10 * hackagebot irc-ctcp 0.1.0.0 - A CTCP encoding and decoding library for IRC clients.  http://hackage.haskell.org/package/irc-ctcp-0.1.0.0 (barrucadu)
10:03:12 * hackagebot irc-ctcp 0.1.1.0 - A CTCP encoding and decoding library for IRC clients.  http://hackage.haskell.org/package/irc-ctcp-0.1.1.0 (barrucadu)
10:03:14 * hackagebot irc-ctcp 0.1.2.0 - A CTCP encoding and decoding library for IRC clients.  http://hackage.haskell.org/package/irc-ctcp-0.1.2.0 (barrucadu)
10:03:16 * hackagebot irc-ctcp 0.1.2.1 - A CTCP encoding and decoding library for IRC clients.  http://hackage.haskell.org/package/irc-ctcp-0.1.2.1 (barrucadu)
10:05:18 <Krautman> I wonder... I joined here because of https://gist.github.com/quchen/5280339 (trolling haskell). Surely I can't be the only one?
10:05:43 <barrucadu> Oops, didn't realise that updating the homepage url would generate hackagebot spam
10:06:58 <shapr> Krautman: well, some people make it and some people don't
10:07:40 <shapr> Krautman: that is, more people than just you have joined because of that, but not everybody is converted to being nice
10:07:43 <yitz> barrucadu: np that's no reason not to fix things on hackage.
10:10:31 <srhb> segfaults sure are easier to come by doing FFI stuff... :-)
10:13:22 <srhb> When I have a foreich call to something that has type foo :: Ptr Thing -- but is a function in C that takes zero arguments, is peeking at it sufficient to run the function?
10:13:38 <yitz> @remember srhb segfaults sure are easier to come by doing FFI stuff
10:13:38 <lambdabot> It is forever etched in my memory.
10:19:56 <Tinned_Tuna> Hi, I'm struggling with the performance of a short haskell program: https://github.com/TinnedTuna/shannon-entropy-estimator, It all *seems* ok, but it allocates some 5GB (!) to process a 161MB file
10:20:30 <yitz> srhb: no. see the section about function pointers here: http://hackage.haskell.org/package/base-4.7.0.1/docs/Foreign-Ptr.html
10:20:59 <srhb> yitz: If it loads. Thanks. :-)
10:21:17 <yitz> srhb: yeah :P seems to be doing a little bit better now tho
10:21:32 <srhb> Google cache works.
10:22:07 <srhb> yitz: Hmm, but it's not a function pointer
10:22:19 <srhb> yitz: It's a function which takes zero arguments and returns a (plain) pointer
10:22:50 <srhb> As in () -> Ptr Thing
10:24:18 <srhb> I'm asking because the program "works" but returns a pointer address I don't believe in. I think.
10:24:38 <Tinned_Tuna> I have no idea why it's allocating so much memory for such a small file. I'm using ByteString
10:24:58 <Tinned_Tuna> (as opposed to plain String), but that doesn't seem to do anything for it
10:25:31 <c_wraith> Tinned_Tuna: is that 5GB resident or total allocation?
10:28:20 <Tinned_Tuna> c_wraith: it's allocating 5 - 7 GB and resident is 4-5GB
10:28:39 <yitz> Tinned_Tuna: the csv parser reads the entire parsed source into memory, then in addition you create Data.Map containing all the data. that's a lot of overhead per item.
10:29:56 <Tinned_Tuna> yitz: any way around it?
10:30:20 <Tinned_Tuna> also, would the bit the CSV parses not get GC'd?
10:31:02 <yitz> Tinned_Tuna: it will get gc'd after you finish building the map, but they both need to be in memory at once before that, so the memory is allocated.
10:31:36 <yitz> Tinned_Tuna: i'm sure you could arrange to read the csv lazily and construct the map as you go.
10:33:16 <yitz> Tinned_Tuna: i can't address the question of whether you really need a map of all the data. presuming you do, you'll still allocate quite a bit of memory for all that data.
10:33:19 <Tinned_Tuna> yitz: ok, I guess I need to look at the Data.Csv usage?
10:33:23 <merijn> srhb: Your type is wrong
10:33:37 <merijn> srhb: FFI functions of zero arguments should be "IO a"
10:33:49 <merijn> srhb: So "IO (Ptr Thing)" in your case
10:33:50 <srhb> merijn: So it's an IO (Ptr Thing)?
10:33:52 <srhb> Thanks.
10:34:51 <Tinned_Tuna> yitz: hm, I'm not sure if I need to hold t all in a Map
10:35:22 <Tinned_Tuna> I'll have a think about if I can compute it on the fly -- unfortunately, I need to account for duplicates...
10:35:23 <yitz> Tinned_Tuna: if you can do your whole calculation lazily, your memory usage will drop drastically.
10:35:40 <srhb> That makes a lot more sense.
10:35:55 <Tinned_Tuna> will Data.Csv work automatically by default?
10:36:16 <monochrom> which package is Data.Csv from?
10:36:26 <Taneb> Cassava
10:36:28 <cite-reader> You probably need Data.Csv.Incremental or Data.Csv.Streaming.
10:36:44 <shapr> cassava!
10:36:46 <cite-reader> (I haven't actually used this library, so I don't know what the difference is.)
10:36:53 <srhb> Hooray, sensible pointers now.
10:37:04 <yitz> Tinned_Tuna: the type is Either String (actual data), so it must load the entire dataset into memory before deciding whether to return a Left or a Right
10:37:44 * Tinned_Tuna scratches his chin in a thoughtful manner
10:38:07 <yitz> Tinned_Tuna: to read it lazily, you would need a return type that is a stream of records each of which is either data or an error.
10:38:22 <Tinned_Tuna> cite-reader: do you use a different library?
10:38:55 <cite-reader> I haven't actually had occasion to process CSVs in Haskell, so technically no.
10:39:16 <Tinned_Tuna> cite-reader: everytime I try I end up with ALL OF THE RAM allocated, so there's that to look out for
10:39:23 <Tinned_Tuna> I think I'm just Bad with ByteStrings
10:39:29 <yitz> Tinned_Tuna: i image that your csvs have a simple format. you might want to roll your own in this case.
10:39:43 <Tinned_Tuna> yitz: aye, it's just frequency,value
10:39:59 <Tinned_Tuna> yitz: I assume attoparsec is The One True Way?
10:40:48 <yitz> Tinned_Tuna: i happen to like attoparsec :) you probably don't even need that in this case. you might be able to just use functions from Data.Text.Lazy and Data.Text.Lazy.Read
10:41:27 <yitz> Tinned_Tuna: your input is text, i assume, not binary goo, so you probably want text, not bytestrings
10:41:49 <monochrom> that will not change efficiency very much
10:41:57 <yitz> agreed
10:42:04 <monochrom> besides, it's cassava who chooses bytestring
10:42:23 <Tinned_Tuna> it's more a semantics thing, right?
10:42:27 <yitz> but it will make it more convenient to do things like read numbers
10:43:14 <yitz> monochrom: i am recommending to dump cassava for this use case since it loads the entire dataset into memory, as seen by its return type
10:43:20 <Tinned_Tuna> yitz: ah, that's nice :-)
10:44:12 <monochrom> but cassava has two partial-reading options, too
10:44:30 <yitz> ah i see there are other interfaces in the cassava library, for streaming, and for incremental. you could try one of those.
10:45:01 <Tinned_Tuna> yitz: I think I'll give it cassava incremental a whirl
10:45:14 <yitz> Tinned_Tuna: cassava is a very nice library. but for this simple use case i personally wouldn't bother, i would read it as lazy text and process it incrementally.
10:45:20 <yitz> ok sounds good
10:45:42 <Tinned_Tuna> I'll try the library first, and in the event of me still being a failure, I'll try a more manual approach :-)
10:47:38 <yitz> Tinned_Tuna: they probably use bytestrings instead of text because they want to include support for some arcane csv variant
10:48:15 <Tinned_Tuna> yitz: yea, you can specifiy your own separators with the decodeOptions
10:48:24 <cite-reader> CSV is pretty trivial to extend to arbitrary binary data, so ByteString seems like the appropriate choice.
10:49:44 <monochrom> a Map can also be huge
10:50:15 <Tinned_Tuna> monochrom: I've got some ~14 million entries...
10:51:00 <yitz> monochrom: Tinned_Tuna will look into whether the data can be processed sequentially without loading it all into a map
10:51:57 <monochrom> a node consists of one machine word for the constructor, one machine word pointing to key, one machine word pointing to value, one machine word pointing to left child, one machine word pointing to right child.
10:52:13 <Tinned_Tuna> yitz: without a map, I can't think how to deal with the potential for duplicates -- i suppose I could pre-process it with awk/sort/uniq/etc. and see where that gets me
10:52:16 <monochrom> one machine word is 4 bytes if 32-bit GHC, 8 bytes if 64-bit
10:52:26 <yitz> monochrom: plus these are boxed values and keys
10:52:48 <monochrom> a node is 40 bytes on 64-bit
10:53:10 <monochrom> 100 million nodes is 4000 million bytes
10:53:32 <Tinned_Tuna> monochrom: owch
10:54:24 <Tinned_Tuna> yitz, monochrom: yea... I'll look at doing it without the map -- any thoughts on how to deal with the duplicates problem, aside from pre-processing the CSV?
10:54:36 <Tinned_Tuna> (either in Haskell or otherwise)
10:54:48 <monochrom> OTOH 10 million nodes is 400 million bytes
10:55:11 <monochrom> while I haven't counted some other things, it is safe to call it 1GB.
10:55:38 <Tinned_Tuna> monochrom: oh, so it's actually a relatively reasonable size...
10:55:41 <Tinned_Tuna> hm, I'll have a poke
10:56:02 <Tinned_Tuna> although, it is a Map ByteString Integer
10:57:38 <Tinned_Tuna> On second thoughts, some pub grub sounds like a fantastic idea right now. Thanks for your help -- I shall ruminate on this conundrum ;-)
10:57:38 <rrradical> is there a way to run 'cabal build --ghc-options="-fforce-recomp -fno-code"' without getting errors at the end for not linking?
10:59:02 <monochrom> I think I'm forgetting that contemporary GC likes to reserve 2x your actual data size. If you use 1GB, it reserves 2 GB.
11:00:32 <monochrom> and before you say "don't worry, linux gives out memory for free as long as you don't actually use it", every GC session does use all of the reserved memory.
11:00:32 <yitz> rrradical: not that i know of, and that is a very good point. i think you should submit a feature request on github.
11:01:04 <srhb> (#size Foo) is the calculated size from the haskell type Foo?
11:01:10 <srhb> In hs2c
11:01:24 <fizbin> So any idea why hackage.haskell.org is slow as molasses today?
11:02:35 <rrradical> yitz: hmm, I found this, open since jan 2013: https://github.com/haskell/cabal/issues/1176
11:02:48 <yitz> srhb: i think Foo is a the C struct type
11:03:03 <srhb> Hmm.
11:06:21 <yitz> rrradical: post to it to make it look active. but i do see that mikhail has not forgotton it - he added a tag to the issue about a month ago
11:06:37 <rrradical> yitz: gotcha, thanks
11:16:11 <blooem_> Hi. :)
11:16:18 <Markz> hola
11:20:35 <latk> Is there a guide somewhere to setting up ghc/cabal/etc on ubuntu ?
11:20:48 <latk> I last did it ages ago, and can't quite recall the necessary steps :s
11:21:29 <Markz> would it be in your history?
11:23:09 <sivteck> latk, https://github.com/bitemyapp/learnhaskell#ubuntu
11:23:10 <monochrom> things have also changed since ages ago, so maybe you have to know new ways anyway.
11:24:34 <latk> yeah, ages ago was also on osx, so it is potentially different!
11:24:50 <latk> sivteck: Thanks.
11:25:00 <merijn> rrradical: I've proposed a "cabal check"/"cabal test" that would run with different warnings/-fno-code to check for errors, but my initial attempts to add it to cabal failed due to me not understanding the cabal codebase at all :)
11:25:08 <sivteck> ubuntu only has ghc 7.6.3, you can install it with apt-get
11:25:14 <sivteck> or use the ppa to get 7.8.3
11:26:25 <rrradical> merijn: yea, that would be a neat feature. too bad haha
11:36:49 * hackagebot scion-browser 0.3.3 - Command-line interface for browsing and searching packages documentation  http://hackage.haskell.org/package/scion-browser-0.3.3 (JeanPhilippeMoresmau)
11:43:26 <sivteck> hv
11:48:55 <lericson_> ~.
11:48:55 <lericson_> ~.
11:53:03 <lpaste_> srhb pasted “Argh FFI” at http://lpaste.net/110506
11:53:27 <lpaste_> srhb annotated “Argh FFI” with “Argh FFI (annotation)” at http://lpaste.net/110506#a110507
11:53:38 <srhb> Oh, I managed to separate the error and the actual paste. Grr
11:54:01 <srhb> Anyway, could someone try and translate the error for me? (In the annotation)
11:54:57 <mauke> peek, not poke
11:55:15 <mauke> your error is related to poke taking two arguments, not one
11:55:39 <squidz> how often would yall say recursion is used in realy day-to-day haskell?
11:55:47 <joelteon> incessantly
11:56:05 <joelteon> in any situation where an imperative language would use iteration
11:56:30 <squidz> really? I would think stuff like map/filter/reduce would be used for that
11:56:42 <mauke> those are all recursive
11:56:42 <squidz> but I don't use haskell, so that's why i'm asking
11:56:48 <joelteon> map and filter are defined recursively
11:56:55 <joelteon> and fold
11:57:00 <joelteon> and anything else that operates on a list
11:57:04 <S11001001> as is the underlying data type they're operating on, which counts as another one
11:57:29 <HeladoDeBrownie> I don't think map counts as "using recursion", even if it is defined recursively
11:57:32 <squidz> yes but I mean in one's own code. When you use map/filter it isn't necessarily clear that recursion is going on
11:57:35 <HeladoDeBrownie> Because you can easily be blind to the implementation
11:57:50 <squidz> HeladoDeBrownie: that's what I mean
11:57:57 <HeladoDeBrownie> In which case I would say: You use recursion sometimes.
11:57:58 <srhb> mauke: peek :: Storable a => Ptr a -> IO a?
11:58:02 <squidz> I mean intentionally using it
11:58:37 <srhb> Huh, yes, where'd that poke get in there.
11:58:47 <HeladoDeBrownie> squidz, it's good to know how to use recursion, but often you may find yourself using a function that embodies that for you and so you won't have to.
11:58:48 <srhb> Thanks for noticing that.
11:59:43 <squidz> HeladoDeBrownie: okay. Thanks. Don't get me wrong. I am learning recursion, and I am really starting to like it. That's why I was curious how much my learning would pay off - hence the question
11:59:46 <mauke> poke p is supposed to be a function T -> IO ()
11:59:54 <srhb> Righto. Thanks!
12:00:03 <mauke> so when ghc sees the do {...} block, it naturally assumes you're trying to use the (T ->) monad
12:00:23 <srhb> My eyes glazed over and I assumed it was some weird FFI incantation stuff. Silly me.
12:01:07 <monochrom> it is very valuable to learn recursion
12:02:22 <squidz> I am reading through the little schemer and learning haskell at the same time so I of course then wondered how useful it would be in haskell
12:03:08 <HeladoDeBrownie> squidz, by the way, joelteon does make a good point about Haskell using recursion where a more imperative language might use iteration (or loops, I'd call them). It's just that imperative languages don't tend to make it as easy to abstract away loops as Haskell does.
12:04:02 <HeladoDeBrownie> Instead of writing a for loop, you'd write an expression using foldr, or similar.
12:05:00 <HeladoDeBrownie> There are examples of languages with both loop constructs and functions for iteration: JavaScript has Array#map and Array#reduce, although there is generally some overhead to using them.
12:05:34 <squidz> Yes I am a clojure programmer, and we don't use iteration either, but at the same time we don't use recursion much. Instead we mostly use our map/reduce/filter stuff as much as we can
12:05:43 <cschneid> what's a good beginners tempting language for making a web page?  heist is fairly complex, should I keep it inline w/ blaze? I'd prefer something that looked more like html I think
12:05:53 <jle`> it's less about recursion and more about higher order funtions
12:05:59 <srhb> Back to segfaulting. Hurrah!
12:06:02 <jle`> i rarely use recursion day-to-day
12:06:18 <squidz> jle`: right
12:06:35 <jle`> looking at the code i've written in the past couple of weeks, i can really count on my hands the number of times i've used explicit recursion
12:06:38 <mauke> :t fix
12:06:39 <lambdabot> (a -> a) -> a
12:06:43 <mauke> does that count?
12:07:07 <zomg> cschneid: there's Hamlet at least
12:07:12 <monochrom> I used to use fix all the time
12:07:25 <jle`> i really find it a bit weird that most introduction to functional programming/haskell introduce recursion first, and map/fold later
12:07:39 <mauke> ... but then I got less strict about it
12:07:48 <monochrom> haha
12:07:49 <jle`> i think, to me, it makes more sense to think about map and fold as "primitives"...sort of like while or for loops in other languages
12:08:04 <jle`> i think recursion becomes useful to the new haskeller when they first define their own recursive data types
12:08:10 <squidz> but somebody mentioned that a lot of the built in functions use recursion. Could it be that more generic code uses recursion. And code where you have to 'get down and dirty' less so
12:08:11 <jle`> like Tree or stuff like that
12:08:12 <cschneid> zomg: does that work outside of yesod?  I'm trying to do the simplest thing possible in a scotty app
12:08:13 <monochrom> now I use recursion itself. it's the closest to my specifications to begin with.
12:08:18 <zomg> cschneid: it should yeah
12:08:32 <mauke> jle`: or []
12:08:37 <zomg> cschneid: I think they have it in the shakespeare package these days
12:08:57 <cschneid> ahh, all TH?
12:09:05 <jle`> mauke: but how often do you need to recurse on []?  if you already have map/fold
12:09:11 <jle`> mauke: oh, you mean, when the user defines their own []
12:09:13 <jle`> yeah
12:09:18 <jle`> s/user/student
12:09:32 <mauke> jle`: I think defining lists and their associated functions is a good exercise
12:09:33 <monochrom> I seldom recurse of []. this is because I seldom have [] to begin with.
12:09:37 <zomg> cschneid: might be, not that familiar with the internals
12:09:39 <jle`> mauke: indeed
12:10:04 <cschneid> zomg: sure looks like its quasiquoter / TH based.  I'm trying to write a simple tutorial and want to keep unneessary magic to a minimum
12:10:46 <zomg> Perhaps just blaze or stringtemplate? Although tringtemplate doesn't really offer any sorts of typesafety guarantees or anything I think
12:11:00 <zomg> but stringtemplate should be pretty simple
12:11:07 <monochrom> instead, I have conditionally repetitive IO, and I have recursive decent parsers.
12:11:08 <lpaste_> burp pasted “FFI + System.Posix.DynamicLinker ” at http://lpaste.net/110508
12:11:09 <jle`> i had a nice time using blaze as a newbie
12:11:17 <cschneid> zomg: yeah, for the moment, I'm mostly worried about simple loops (a list of items, render each one in an <li> or whatever, and var substitution.
12:11:23 <cschneid> heist may actually be best...
12:11:33 <burp> can someone gice me a hint why this small excercise segfaults? :D
12:11:36 <jle`> whether or not i would still use blaze today is something i haven't given too much serious thought, but it was pretty easy enough to use as a new person
12:12:11 <cschneid> jle`: yeah, blaze is cool too. Also is hackage down?
12:12:19 <burp> I am trying to write a shared library in haskell, that I again want to use from within haskell
12:12:19 <cschneid> makes investigating these things hard :)
12:12:29 <monochrom> burp: I have some doubt about foreign export ... :: Int
12:12:33 <mightybyte> cschneid: If you use interpreted mode, I don't think heist is all that difficult.
12:12:42 <cschneid> mightybyte: of course you'd say that :)
12:12:48 <cschneid> but you're right, it wasn't bad when I used it a while back
12:12:49 <monochrom> I have to carefully read Haskell 2010 for what it really means.
12:13:02 <squidz> Has anybody made anything akin to the 'Om' library from clojure in haskell?
12:13:06 <mauke> burp: I'm pretty sure you're exporting a function
12:13:11 <mauke> int test(void);
12:13:13 <cschneid> mightybyte: I'll go with heist for now I think - separates templates out nicely from code, which is important
12:13:16 <mightybyte> cschneid: Not true at all.  I readily admit that compiled heist is rather difficult to wrap one's head around.
12:13:38 <burp> mauke: oh, I see
12:13:40 <cschneid> heh, just hassling you, it's a nice library. And yeah, I've used it before - thanks
12:14:28 <latk> hackage down, or is it just me ?
12:14:47 <cschneid> latk: I see it too :( I'll have to go back to day-job instead of poking around on hackage
12:15:02 <l0cust> latk: not working for me, either
12:15:23 <latk> righty
12:15:43 <lericson_> Prelude Data.Set Data.Function Data.Char Data.List> :t (abs . (-))
12:15:43 <lericson_> (abs . (-)) :: (Num (a -> a), Num a) => a -> a -> a
12:15:45 <lericson_> what does that mean?
12:15:59 <geekosaur> it means you fed it nonsense :p
12:15:59 <lericson_> why doesn't that do | () - () |
12:16:09 <mauke> what?
12:16:15 <mauke> is that a smiley?
12:16:31 <jle`> it's a robot
12:16:32 <marchelzo_> How can I see instance definitions for common types? Like what if I wanted to see how the Monad instance for [] was written? Is that available?
12:16:36 <lericson_> (-) 1 2 does what you think, abs ((-) 1 2) does what you think, why can't i compose (-) with abs?
12:16:44 <jle`> @unpl (abs . (-))
12:16:44 <lambdabot> (\ c -> abs ((-) c))
12:16:54 <mauke> lericson_: abs . (-) means \x -> abs ((-) x)
12:16:57 <jle`> lericson_: you can expand out the definition, if you want
12:17:12 <jle`> ((abs . (-)) 1) 2 =
12:17:18 <lericson_> ah hm
12:17:27 <l0cust> lericson_: that means that (a) has to be a ring, along with (a -> a)
12:17:28 <thoughtpolice> FWIW, Hackage is back up again
12:17:29 <l0cust> wut
12:17:33 <jle`> @src (.)
12:17:33 <lambdabot> (f . g) x = f (g x)
12:17:34 <lericson_> right, composing with a function taking more than one argument doesn't work as i'd expect
12:17:34 <monochrom> do not use intuition. use algebra.
12:17:51 <mauke> every function takes exactly one argument
12:17:58 <mauke> praise curry
12:18:06 <lericson_> both yes and no, matter of definition
12:18:13 <lericson_> but i see what you mean
12:18:24 <mauke> it's how (.) sees the world
12:18:27 <srhb> thoughtpolice: It's intermittent all day.
12:18:31 <srhb> thoughtpolice: I think.
12:19:02 <lericson_> so how does one compose a function that takes more than one argument?
12:19:04 <jle`> (abs . (-)) 1 2 = (\x -> (abs (x -))) 1 2 = (abs (1 -)) 2 = abs (1 -) 2 = ..?
12:19:22 <thoughtpolice> srhb: hm, it does seem that way
12:19:39 <bitemyapp> @pl f x a b c d e f = x f e d c b a
12:19:39 <lambdabot> f = flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .) . flip . ((flip . ((flip . (flip .)) .)) .) . flip . ((flip . (flip .)) .) . flip . (flip .) . flip
12:19:40 <lericson_> i suppose a lambda is in order
12:19:41 <mauke> lericson_: this is where (.) . (.) comes in
12:19:44 <bitemyapp> lericson_: ^^ that way.
12:19:46 <thoughtpolice> I might have to call Hetzner, I wonder if their DC is suffering from issues at the moment, although they don't seem to be getting DDoS'd at the moment.
12:19:49 <mauke> but yeah, I'd go with a lambda
12:19:59 <mauke> @pl \x y -> f (g x y)
12:19:59 <lambdabot> (f .) . g
12:19:59 <lpaste_> burp annotated “FFI + System.Posix.DynamicLinker ” with “FFI + System.Posix.DynamicLinker  (annotation)” at http://lpaste.net/110508#a110510
12:20:01 <srhb> thoughtpolice: My hetzner VPS is fine.
12:20:04 <lericson_> bitemyapp: what.. just happened :D
12:20:04 <srhb> thoughtpolice: If that matters.
12:20:06 <burp> mauke: you were right about it, it's a function int test(void) :)
12:20:16 <bitemyapp> lericson_: I made a pathological case for pointfree.
12:20:22 <jle`> lericson_: people have defined (.:) as (f .: g) = \x y -> f (g x y), but...
12:20:23 <burp> now it prints 1234, but still segfaults at the end, but I guess I can figure that out somehow
12:20:35 <jle`> i think in this case, keeping a point or two is probably the cleanest thing you can do
12:20:46 <lericson_> what is a point?
12:20:50 <lericson_> and what is point free?
12:20:54 <thoughtpolice> srhb: they have about 20 datacenters or more, so it's more likely it's unrelated. (I'm not sure how they separate their VPS machines from Dedicated boxes if at all)
12:21:04 <srhb> thoughtpolice: Ah, I see. :)
12:21:06 <mauke> lericson_: a point is a function parameter
12:21:10 <bitemyapp> lericson_: when talking about pointfree, it's an argument.
12:21:18 <jle`> lericson_: the function foo x = bar (baz x) has one point, x
12:21:19 <bitemyapp> a less ridiculous example:
12:21:27 <bitemyapp> @pl f a b = a + b
12:21:28 <lambdabot> f = (+)
12:21:39 <bitemyapp> you don't need to talk about the arguments. It's just (+)
12:21:43 <mauke> @pl \x -> f (g x)
12:21:43 <lambdabot> f . g
12:21:46 <jle`> when you write it as foo = bar . baz in compositional style, you find that the points vanish
12:21:51 <mauke> @pl \x y -> f (g x y)
12:21:51 <lambdabot> (f .) . g
12:21:56 <mauke> @pl \x y z -> f (g x y z)
12:21:56 <lambdabot> ((f .) .) . g
12:21:57 <jle`> magique
12:22:18 <mauke> @pl \f g x y -> f (g x y)
12:22:18 <lambdabot> (.) . (.)
12:22:37 <jle`> if i have to do foo x y = f (g x y), you can "keep one of the points" and do foo x = f . g x
12:22:38 <lericson_> interesting
12:22:58 <lericson_> i like pointfree
12:23:08 <jle`> or you can just do foo x y = f (g x y) and not lose anything too much, actually
12:23:16 <jle`> lericson_: pointfree in and of itself is a bit of a .... pointless quest
12:23:24 <mauke> what's interesting is that you can replace some or all of those .'s by fmap, <$> or liftM and totally obfuscate your code
12:23:27 <jle`> pursuing pf for the sake of pf often makes your code very unreadable
12:23:35 <jle`> in fact, it's strongly discouraged :)
12:23:47 <lericson_> i just want to describe |x - y| in a good way
12:23:55 <mauke> :t [(.), fmap, (<$>), liftM]
12:23:56 <lambdabot> [(b -> c) -> (a -> b) -> a -> c]
12:24:02 <monochrom> abs(x-y) is a good way
12:24:11 <lericson_> \ x y -> abs(x - y) then
12:24:21 <mauke> maybe give it a name, like absdiff
12:24:23 <dmj`> whats the hackage mirror link again?
12:24:25 <lericson_> > \ x y -> abs (x - y)
12:24:26 <lambdabot>  <Integer -> Integer -> Integer>
12:24:32 <jle`> the main benefit of writing foo x = f (g y) as foo = f . g is that you can "view foo as simply a composition of f and g".  this point is harder to see in the pointful form.  it also "composes" less well if, say, you want to throw another function into the chain
12:24:33 <lericson_> @pl \ x y -> abs (x - y)
12:24:33 <lambdabot> (abs .) . (-)
12:24:36 <lericson_> oh
12:24:51 <monochrom> the last stanza of the topic, dmj`
12:25:01 <jle`> but i think that the cases where point-free makes things cleaner and nicer are the exceptions
12:25:17 <jle`> pursue the best and most readable way to state something...not the code golf
12:25:33 <jle`> or instead of state, i can use the fancy buzz word "denote"
12:25:34 <mauke> golf is another axis
12:25:58 <mauke> why not go all out and use "reify"?
12:26:06 <monochrom> standard_real_metric x y = abs(x-y). then "standard_real_metric" is pointfree.
12:26:20 <dmj`> monochrom: ah thanks
12:27:04 <dmj`> monochrom: hackage.fpcomplete.com seems to be down too
12:27:32 <monochrom> then I don't know
12:27:52 <monochrom> these mirrors come and go. they are less stable than hackage itself
12:28:02 <latk> don't suppose there are any tricks for getting around ghc: out of memory problems on install?
12:28:33 <monochrom> on install of what? but last time I built text, it took 600MB memory, yes.
12:28:50 <lericson_> (abs .) . (-) is really hard to understand
12:28:56 <dmj`> monochrom: can we get at the actual acid-state for hackage?
12:29:04 <latk> monochrom: persistent-postgresql :s
12:29:17 <lericson_> (abs .) is a function taking a function to compose abs with, and . (-) composes that composing function with (-)
12:29:26 <monochrom> you're actually lucky to get quick out-of-memory instead of waiting for 5 minutes of thrashing the swap before it.
12:29:38 <dmj`> who runs hackage?
12:29:50 <latk> monochrom: Hah, fair point
12:30:04 <latk> I guess 2gb is just insufficient these days
12:34:58 <lericson_> is there any built-in support for matrix operations?
12:35:09 <lericson_> i found Data.Matrix but it seems not to be bundled
12:35:24 <mauke> built in to what?
12:35:31 <lericson_> ghc
12:35:44 * mauke raises a brow
12:35:46 <monochrom> it is not bundled, that's correct.
12:36:03 <lericson_> i have an assignment that is automatically testrun and it runs on a stock ghc i think
12:36:25 <monochrom> perhaps you're intended to write your own matrix routines.
12:36:39 <lericson_> it's very elementary stuff
12:37:18 <lericson_> but i guess you're right
12:37:45 <jle`> lericson_: there might also be a package on hackage that does what you want :)
12:40:41 <srhb> So, when I segfault after doing some hsc2hs magic, that means I'm reading some memory I don't have access to, right?
12:41:01 <bitemyapp> shapr: you said you did Arduino stuff. What's it like compiling Haskell for Arduino?
12:41:31 <lericson_> why is this
12:41:41 <lericson_> @pl zipWith (zipWith id)
12:41:42 <lambdabot> zipWith (zipWith id)
12:41:42 <shapr> bitemyapp: well, it takes a few weeks to build
12:41:44 <lericson_> er
12:41:47 <lericson_> >:t zipWith (zipWith id)
12:41:53 <lericson_> > zipWith (zipWith id)
12:41:54 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable c0)
12:41:54 <lambdabot>    arising from a use of ‘M321882874162846335416604.show_M3218828741628463354...
12:41:54 <lambdabot>  The type variable ‘c0’ is ambiguous
12:41:54 <lambdabot>  Note: there are several potential instances:
12:41:54 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
12:42:01 <bmuk> I am interested in writing a library, pretty much just for learning purposes. Are there any libraries the haskell community doesn't have that it needs?
12:42:02 <shapr> bitemyapp: but seriously, firmata is easy cheesy because it's just an API for the Arduino's pins
12:42:06 <jle`> :t zipWith (zipWith id) -- perhaps?
12:42:07 <lambdabot> [[b -> c]] -> [[b]] -> [[c]]
12:42:12 <lericson_> yes
12:42:18 <lericson_> why does it take a list of functions from b to c?
12:42:22 <jle`> :t zipWith
12:42:23 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
12:42:32 <jle`> :t zipWith id
12:42:33 <lambdabot> [b -> c] -> [b] -> [c]
12:42:52 <lericson_> :t id
12:42:53 <lambdabot> a -> a
12:43:06 <jle`> so your (a -> b -> c) in zipWith is ([b -> c] -> [b] -> [c])
12:43:07 <lericson_> ah hm
12:43:14 <bitemyapp> shapr: interesting, thanks.
12:43:26 <jle`> that seems to say that a ~ [b -> c], b ~ [b], and c ~ [c]
12:43:46 <jle`> so plugging it all back in, you get [[b -> c]] -> [[b]] -> [[c]]
12:43:59 <shapr> bitemyapp: I haven't tried the other options: http://www.haskell.org/haskellwiki/Arduino
12:44:13 <monochrom> http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#shared  new publication
12:44:14 <shapr> bitemyapp: but you should grab an Arduino and make fun projects!
12:44:27 <lericson_> i don't quite understand i think
12:44:45 <lericson_> hm
12:44:45 <shapr> I made an alarm clock from one RGB LED so I don't get up and get ready for the day at 2am
12:44:51 <jle`> lericson_: which part?
12:44:57 <srhb> Where do I see a list of all hsc2hs macros?
12:45:03 <jle`> do you understand why (zipWith id) is [b -> c] -> [b] -> [c]?
12:45:03 <lericson_> so [b -> c] is just because we put id as the "with" in zipWith?
12:45:08 <lericson_> not quite
12:45:11 <jle`> ah
12:45:32 <monochrom> @type zipWith id
12:45:33 <lambdabot> [b -> c] -> [b] -> [c]
12:45:47 <monochrom> @type zipWith ($)
12:45:48 <lambdabot> [b -> c] -> [b] -> [c]
12:45:54 <jle`> this is all really a unification game
12:46:04 <monochrom> id is specialized to ($)
12:46:19 <monochrom> yes, this is a unification game.
12:46:21 <lericson_> id is f x = x
12:46:46 <monochrom> unification is exponential time for computers, so nevermind humans. http://www.vex.net/~trebla/haskell/prerequisite.xhtml#unification
12:47:04 <jle`> zipWith takes an (a_zw -> (b_zw -> c_zw)), and id is an (a_id -> a_id)
12:47:15 <jle`> (i'm adding subscripts so we can tell the a's and b's apart from each one)
12:47:33 <jle`> can you see how you can "unify" an (a -> (b -> c)) with an (a -> a) ?
12:47:55 <jle`> a_z -> (b_z -> c_z) with (a_i -> a_i)
12:48:05 * hackagebot fay 0.20.1.4 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.20.1.4 (AdamBergmark)
12:48:58 <lericson_> well yes if a_id -> a_id is the same as a_zw -> b_zw, no?
12:49:14 <jle`> hm no.  everywhere you see a_i, it hjas to be the same a_i
12:49:26 <jle`> so in that cas,e you are unifying a_i with a_z, and also a_i with b_z
12:49:28 <lericson_> let me think
12:49:35 <lericson_> yes true
12:49:39 <jle`> here's a first step if you want a spoilers
12:49:53 <jle`> (do you want one?)
12:49:55 <lericson_> well if a_z = b_z
12:50:13 <jle`> we like to use ~ for this, instead of = :)  don't ask me why
12:50:20 <lericson_> ok i see
12:50:39 <lericson_> to begin with, isn't a -> (b -> c) the same as a -> b -> c
12:50:57 <jle`> yes, but in the form a -> (b -> c), it's easier to see how it would fit into d -> e
12:51:19 <jle`> the fact that i turned it from the a -> b -> c that :t zipWith gave into a -> (b -> c) was supposed to be a hint :)
12:51:30 <lericson_> aha
12:51:33 <merijn> lericson_: -> is right associative, so those two are the same, yeah
12:51:41 <jle`> oops, i mean d -> d
12:51:44 <lericson_> alright spoiler then
12:51:59 <jle`> so you're fitting a -> (b -> c) into d -> d
12:52:10 <lericson_> yes
12:52:13 <jle`> (a -> (b -> c)) ~ (d -> d)
12:52:20 <lericson_> is our goal
12:52:24 <jle`> so, both sides of the -> also have to be equivalent
12:52:30 <jle`> a ~ d, and b -> c ~ d
12:52:32 <jle`> right?
12:52:38 <lericson_> yes
12:52:45 <jle`> if (a -> b) ~ (c -> d), then a ~ c and b ~ d
12:53:02 <jle`> so this means that a_z ~ a_i
12:53:12 <jle`> and (b_z -> c_z) ~ a_i
12:53:28 <lericson_> yes
12:53:35 <merijn> lericson_: Therefore? :)
12:53:43 <lericson_> therefore the type
12:53:47 <lericson_> but i must think a little bit about this
12:53:53 <merijn> lericson_: Hint: ~ is transitive
12:54:16 <lericson_> you mean to say a_z ~ (b_z -> c_z)?
12:54:19 <lumo_e> how is ~ called?
12:54:33 <merijn> lumo_e: Well ~ is usually called type equality
12:54:37 <jle`> lericson_: yes, that's right :D
12:54:42 <merijn> lumo_e: Although it's actually just unification
12:55:04 <merijn> lumo_e: I would read "x ~ y" as "x unifies with y"
12:55:11 <lericson_> ah hm
12:55:12 <lumo_e> ok
12:55:12 <jle`> so in zipWith id, the (a_z -> (b_z -> c_z)) "turns into" ...?
12:55:19 <lericson_> i see why this confuses me a little bit
12:55:31 <jle`> (because we know that a_z has to unify with/be (b_z -> c_z)
12:55:44 <lericson_> zipWith expects its first argument to be a function that takes two arguments
12:55:49 <merijn> lericson_: I recommend lots of practice doing this with pen and paper
12:56:04 <jle`> lericson_: technically, it expects its first argument to be a function that returns another function
12:56:06 <merijn> lericson_: After a while it becomes a habit and you can do it in your mind more and more easily
12:56:10 <latk> I'm getting an error about zlib requires Cabal library version >=1.19.2 && >= 1.8 when I try to install a package. I have cabal 1.20.0.3
12:56:17 <lericson_> jle`: technically yes
12:56:19 <latk> what is going on :S
12:56:25 <jle`> lericson_: i really think you should forget the view that functions take two arguments, when reasoning about type
12:56:30 <jle`> it only makes things more confusing
12:56:32 <jle`> :)
12:56:43 <lumo_e> ok my brain is melting
12:56:45 <lericson_> absolutely but it really explains why the [b -> c]
12:57:05 <jle`> so zipWith id, the (a -> (b -> c)) turns into ((b -> c) -> (b -> c))
12:57:09 <jle`> :t zipWith
12:57:10 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
12:57:20 <jle`> so if we know that a ~ (b -> c)
12:57:32 <jle`> and zipWith f is [a] -> [b] -> [c]
12:57:34 <lumo_e> ok now I see it
12:57:41 <jle`> then, we have [b -> c] -> [b] -> [c]
12:57:42 <lumo_e> is this zipWith id useful to something?
12:58:04 <mokkake> it's just zip
12:58:07 <lericson_> yeah
12:58:11 <jle`> lumo_e: it actually does come up from time to time, but usually we write it as zipWith ($) to make things more clear
12:58:17 <lumo_e> ok this blew my mind
12:58:35 <lumo_e> :D
12:58:49 <lumo_e> :t zip
12:58:50 <lambdabot> [a] -> [b] -> [(a, b)]
12:59:00 <lericson_> isn't zipWith id the same as map?
12:59:00 <mokkake> :t zipWith id
12:59:01 <lambdabot> [b -> c] -> [b] -> [c]
12:59:04 <lericson_> almost
12:59:11 <hiptobecubic> :t zipWith
12:59:12 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
12:59:21 <mokkake> well, i lied
12:59:26 <hiptobecubic> yeah not at all
12:59:32 <jle`> zip is zipWith (,)
12:59:32 <hiptobecubic> zip == zipWith (,)
12:59:37 <lumo_e> :t zipWith (,)
12:59:38 <lambdabot> [a] -> [b] -> [(a, b)]
12:59:50 <mokkake> yea, good catch
12:59:55 <jle`> :t ap
12:59:55 <lambdabot> Monad m => m (a -> b) -> m a -> m b
12:59:58 <lericson_> > zipWith id (repeat abs) [1, -2, 3]
12:59:59 <lambdabot>  [1,2,3]
13:00:01 <jle`> :t liftA3
13:00:02 <lericson_> :D
13:00:02 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
13:00:08 <jle`> um
13:00:10 <jle`> :t liftA2
13:00:10 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
13:00:12 <jle`> :t zipWith
13:00:13 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
13:00:15 <jle`> hm.
13:00:21 <hiptobecubic> if [a] were a list of functions that take b's and make c's, then zipWith id would apply the a's to the b's I guess
13:00:27 <mauke> :t zipWith id . repeat
13:00:28 <lambdabot> (b -> c) -> [b] -> [c]
13:00:33 <lericson_> hiptobecubic: it's like a really funky map!
13:00:39 <lumo_e> so zipWith is the lift for lists
13:00:41 <hiptobecubic> > zipWith id [(+1)] [2]
13:00:42 <lambdabot>  [3]
13:00:49 <jle`> > zipWith ($) [(*4), (+3), (^2)] [4,5,6]
13:00:51 <lambdabot>  [16,8,36]
13:01:06 <lericson_> awesome
13:01:17 <hiptobecubic> :t zipWith ($)
13:01:18 <lambdabot> [b -> c] -> [b] -> [c]
13:01:21 <jle`> lumo_e: it's one way to lift, for lists.  there are actually a couple of ways to lift an (a -> b -> c) into an [a] -> [b] -> [c]
13:01:23 <hiptobecubic> :t zipWith id
13:01:24 <lambdabot> [b -> c] -> [b] -> [c]
13:01:40 <mauke> :t zipWith ask
13:01:41 <lambdabot> [b -> c] -> [b] -> [c]
13:01:50 <hiptobecubic> :t ask
13:01:51 <lambdabot> MonadReader r m => m r
13:02:08 <mauke> :t zipWith asks
13:02:09 <hiptobecubic> is (-> r) *actually* a MonadReader?
13:02:09 <jle`> using zipWith ($) instead of zipWith id usually makes your intent a bit clearer
13:02:09 <lambdabot> [b -> a] -> [b] -> [a]
13:02:20 <mauke> hiptobecubic: no, but (r ->) is
13:02:27 <lumo_e>  :t ($)
13:02:28 <hiptobecubic> oh oops, yes that one
13:02:32 <lumo_e> :t ($)
13:02:33 <lambdabot> (a -> b) -> a -> b
13:02:34 <mauke> hiptobecubic: Reader is just a newtype for (->)
13:02:42 <latk> I'm getting a load of errors of the form "user error (The package 'cereal' requires Cabal library version >=1.19.2 && >=1.6 but no suitable version is installed.)". I have cabal 1.20.0.3.. any ideas what I should do to fix this ?
13:02:44 <mauke> it's the best MonadReader
13:02:50 <hiptobecubic> clearly
13:03:01 <jle`> > (do { x <- ask; return (x + x) }) 5
13:03:03 <lambdabot>  10
13:03:18 <lumo_e> what is ask?
13:03:30 <lericson_> :t ask
13:03:31 <lambdabot> MonadReader r m => m r
13:03:39 <mauke> @src MonadReader
13:03:39 <lambdabot> Source not found. Take a stress pill and think things over.
13:03:41 <mauke> oh well
13:04:00 <hiptobecubic> that example doesn't make sense to me
13:04:02 <lericson_> monads i will get to someday
13:04:07 <lumo_e> I guess I should know what a monad is first
13:04:15 <hiptobecubic> lumo_e, no. that's the last stage
13:04:46 <mauke> > runReader (do { x <- ask; return (x + x) }) 5
13:04:48 <lambdabot>  10
13:04:58 <lumo_e> :t runReader
13:04:59 <lambdabot> Reader r a -> r -> a
13:05:49 <lumo_e> ok
13:06:05 <lumo_e> so (do { x <- ask; return (x + x) }) is of type MonadReader Int Int
13:06:29 <lumo_e> runReader feeds it one parameter
13:06:29 <mokkake> please, can someone explain me this class error, that doesn't make any sense to me: http://pastebin.com/P6epVXhd
13:07:58 <mauke> :t do { x <- ask; return (x + x) }
13:07:59 <lambdabot> (MonadReader b m, Num b) => m b
13:08:22 <geekosaur> I don't see _port defined there anywhere, but at a guess it is an Int and you are assuming classes work backwards from how they do.
13:08:46 <mokkake> geekosaur: _port :: TRequest -> Int
13:08:53 <hiptobecubic> mokkake, i'm not positive about this, but i think the way you have written it, queries need to work with arbitrary "Value a", not just the one you are imagining here with Int
13:08:53 <mokkake> and yes probably, first time i'm trying to build one
13:09:32 <mauke> mokkake: caller gets to choose 'a'
13:09:34 <mokkake> hiptobecubic: i'm assuming "a" here is replaced by Int, which is the case right ?
13:09:34 <geekosaur> yes, so you're asserting there that it's always an Int. but you have no control over someone else declaring a different instance, in which case that definition would be invalid
13:09:36 <S11001001> mokkake: the essence is that your signature says "for *all* a that satisfy Value a", not "for *some* a for which there's a Value instance"
13:09:39 <mauke> function can't assume it's Int
13:09:54 <geekosaur> in other words, no, it is not always guaranteed to be an Int
13:10:21 <mokkake> i don't get it
13:10:39 <hiptobecubic> mokkake, yeah but that's kind of backwards. It's like saying "Batteries work in all possible devices" and then saying "These AA's are batteries" and then the compiler says "Yeah but they don't work in all devices.. .only devices that take AA's. What about this car?"
13:11:20 <hiptobecubic> mokkake, so you didn't mean "batteries work in all devices" you meant "batteries work in devices that take the kind of battery that they are"
13:11:33 <S11001001> mokkake: I write "instance Value String where val = id"
13:12:04 <S11001001> mokkake: now, I write (queries :: [(TRequest -> String, String)])
13:12:15 <S11001001> mokkake: that's allowed according to your queries signature
13:12:24 <mokkake> yes.
13:12:30 <S11001001> mokkake: but obviously _port doesn't conform to TRequest -> String
13:12:44 <aristid> hmm hackage seems really slow right now
13:12:45 <S11001001> mokkake: hence you cannot use _port there
13:13:07 <mokkake> so, overloading is useless there
13:13:10 <mokkake> here*
13:13:15 <hiptobecubic> mokkake, when you make a type more general with type variables, it usually turns out that are *restricting* what can be done with it.
13:13:22 <hiptobecubic> for example the 'id' function
13:13:24 <hiptobecubic> :t id
13:13:25 <lambdabot> a -> a
13:13:48 <S11001001> I don't know what "overloading" means in this context.  Maybe you want an associated type family.  But you'd need to share more of what you're trying to accomplish to be able to tell.
13:13:59 <hiptobecubic> You'd think "hey that function can take anything!"  but what it really says is "that function can't do anything but give you your value back because it doesn't know anything else about it"
13:14:43 <hiptobecubic> your definition of queries assumes things about the 'a' that it can't prove
13:14:47 <mokkake> i'll explain more: what i need to do is to associate a function (TRequest -> whatever) to a String
13:15:01 <mokkake> whith tuple / lookup for example
13:15:16 <hiptobecubic> sounds like a Map
13:15:18 <mokkake> whithout changing the type of "whatever"
13:15:28 <glosoli> what choices one does have for Haskell on VIM ?
13:15:39 <mokkake> yea, Map or Tuple ar quite the same thing
13:15:50 <mokkake> well, they're not, but in my example they are
13:16:06 <hiptobecubic> mokkake, sure, but a Map the data type gives you your lookup
13:16:07 <mokkake> thing is, i can't pattern match against function name
13:16:16 <simpson> glosoli: What do you mean by choices?
13:16:19 <hiptobecubic> unless you want to iterate over the list of tuples every time
13:16:32 <glosoli> simpson: haskell oriented plugins
13:16:47 <S11001001> mokkake: before going any further down that rabbit hole, see http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
13:17:12 <mokkake> S11001001: okay, thanks. I don't know if Typeable would help me here
13:18:40 <S11001001> mokkake: This doesn't have anything to do with Typeable; I think you're trying to get to an existential typeclass thingy, but there's almost certainly no reason to go there, for the reasons outlined in that post
13:18:57 <S11001001> mokkake: I think that because your Value typeclass is a "coercy" thing
13:18:59 <mokkake> S11001001: okay, reading it
13:19:13 <lpaste_> srhb pasted “"Adventures" in FFI-land” at http://lpaste.net/110512
13:19:28 <lumo_e> jle`, what are the other ways to lift (a->b->c) into [a] -> [b] -> [c] ?
13:19:29 <srhb> I think I'm doing something wrong in trying to get to that pointer, because I get a zero address. Any ideas?
13:19:29 <S11001001> and the most common existential typeclassy things in the wild are to do with coercy things with folks trying to simulate heterogenous lists and such with homogenously typed thingies
13:19:38 <simpson> glosoli: I have syntax highlighting and indentation and, TBH, that's all I really need.
13:19:38 <mokkake> S11001001: coercy ? what do you mean
13:19:47 <S11001001> mokkake: "coerceable to String"
13:19:48 <lumo_e> I found out that liftA2 id is the same as zipWith id for lists
13:20:16 <S11001001> lumo_e: really? :)
13:20:21 <hiptobecubic> glosoli, if all you are doing is haskell then necoghc + ghc-mod is good
13:20:40 <jle`> lumo_e: the other way is to apply the function to every possible pair
13:20:50 <S11001001> > liftA2 (,) [1,2] [3,4]
13:20:51 <jle`> lumo_e: er i mean, apply every function to every value
13:20:51 <mokkake> google trad still doesn't know that english word, but nevermind
13:20:51 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
13:21:00 <S11001001> > zipWith id [1,2] [3,4]
13:21:01 <lambdabot>  Could not deduce (GHC.Num.Num (b0 -> c))
13:21:02 <lambdabot>    arising from the ambiguity check for ‘e_11234’
13:21:02 <lambdabot>  from the context (GHC.Num.Num (b -> c), GHC.Num.Num b)
13:21:02 <lambdabot>    bound by the inferred type for ‘e_11234’:
13:21:02 <lambdabot>               (GHC.Num.Num (b -> c), GHC.Num.Num b) => [c]
13:21:03 <hiptobecubic> glosoli, if you do many things and one of them happens to be haskell then i'd go with YouCompleteMe + necoghc + ghc-mod
13:21:13 <S11001001> > zipWith (,) [1,2] [3,4] ::
13:21:14 <lambdabot>  <hint>:1:27:
13:21:14 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
13:21:15 <S11001001> > zipWith (,) [1,2] [3,4]
13:21:16 <lambdabot>  can't find file: L.hs
13:21:17 <jle`> :t ap
13:21:18 <lambdabot> Monad m => m (a -> b) -> m a -> m b
13:21:20 <jle`> :t zipWith ($)
13:21:20 <hiptobecubic> glosoli, it's slightly less powerful i think, i but does most of what you want and is fast as hell
13:21:21 <lambdabot> [b -> c] -> [b] -> [c]
13:21:21 <lumo_e> > zipWith id [(+3)] [5, 6]
13:21:23 <lambdabot>  [8]
13:21:27 <vanila> hi guys
13:21:29 <vanila> hows ICFP going?
13:21:43 <lumo_e> > zipWith id [(+3), (+2)] [5, 6]
13:21:44 <lambdabot>  [8,8]
13:21:48 <S11001001> lumo_e: try adding another function to that first list in both cases
13:21:50 <jle`> :t [ap, (<*>), zipWith ($)]
13:21:50 <lambdabot> [[a -> b] -> [a] -> [b]]
13:21:58 <lumo_e> > (liftA2 id) [(+3), (+2)] [5, 6]
13:22:00 <lambdabot>  [8,9,7,8]
13:22:05 <lumo_e> fuck it's not the same
13:22:06 <glosoli> simpson, hiptobecubic  thansk
13:22:09 <lumo_e> well, almost
13:22:10 <glosoli> thanks"
13:22:20 <S11001001> @hoogle ZipList
13:22:21 <lambdabot> Control.Applicative ZipList :: [a] -> ZipList a
13:22:21 <lambdabot> Control.Applicative newtype ZipList a
13:22:21 <lambdabot> Control.Applicative getZipList :: ZipList a -> [a]
13:22:29 <jle`> lumo_e: the default way that these are lifted is the apply-every-function-to-every-value way
13:22:34 <S11001001> lumo_e: that's what the above newtype is for, selecting the applicative that's like zipWith
13:22:40 <jle`> but with a newtype wrapper, like S11001001 noted, you can use other ways
13:22:59 <jle`> > liftA2 (ZipList [(+3), (+2)]) (ZipList [5, 6])
13:23:01 <lambdabot>  Couldn't match expected type ‘a0 -> b -> c’
13:23:01 <lambdabot>              with actual type ‘Control.Applicative.ZipList (a1 -> a1)’
13:23:07 <jle`> dangit
13:23:11 <jle`> > liftA2 id (ZipList [(+3), (+2)]) (ZipList [5, 6])
13:23:12 <lambdabot>  ZipList {getZipList = [8,8]}
13:23:17 <lumo_e> cool
13:23:36 <jle`> it was just a matter of picking which one was the default, and which one needed the wrapper
13:23:45 <lumo_e> that is, you have more way for [] to be an applicative functor?
13:23:47 <jle`> same for Monoid instances for Int, too
13:23:56 <lumo_e> ways*
13:24:11 <jle`> the default is chosen as it is because the way it is now has a Monad instance such that ap = (<*>)
13:24:44 <S11001001> don't define Monad instances for which this is false
13:24:59 <jle`> ap mf mx = do { f <- mf; x <- mx; return (f x) }
13:25:11 <S11001001> if it's not a law yet, it will be in 7.10
13:25:59 <jle`> the issue is more with picking the Applicative instance
13:27:26 <lumo_e> trying to learn haskell is not an easy task by any means :/
13:27:32 <jle`> lumo_e: why do you say that? :)
13:27:41 <jle`> sorry if this is overloading v.v
13:27:55 <Taneb> goddamn lazy IO
13:27:58 <mokkake> okay, i got it. What i'm trying to do is impossible. That's kinda sad
13:28:26 <lumo_e> I find there are too many subtleties I can't grasp without having the full vision on it all
13:31:23 <lericson_> hear hear lumo_e
13:31:38 <lericson_> it's just a phase
13:31:50 <lericson_> all the languages i learned i thought that at some point
13:32:07 <jle`> i think it might be just a matter of getting over not knowing everything :)  a lot of times the subtleties might nto practically matter
13:32:08 <lericson_> with all the languages i learned, i thought that at some point
13:32:08 <S11001001> lumo_e: wrt multiple Applicative functors per type, there's always one with the order flipped.  Whether that's a different applicative depends on the instance.  It's different for [] and IO, not different for Maybe or ZipList.
13:33:40 <hiptobecubic> there is a flag for cabal to tell it to ignore upper bounds on constraints, what is it?
13:33:46 <lpaste_> srhb annotated “"Adventures" in FFI-land” with “"Adventures" in FFI-land (annotation, shorter)” at http://lpaste.net/110512#a110514
13:34:10 <srhb> I shortened the example problem. If anyone can see that I'm doing something wrong I'd be very happy. :-)
13:34:38 <joshc> hiptobecubic: --allow-newer, methinks
13:36:16 <hiptobecubic> unrecognized option :/
13:37:37 <lericson_> so, (abs .) . (-) is the composition of a function that composes with abs, and the subtraction function. when i apply that function to some number 3, only then does tho composition "happen" if that makes sense
13:37:56 <lericson_> it then becomes abs((3-))
13:38:11 <lericson_> hmm not quite
13:38:23 <lericson_> but almost
13:38:38 <lericson_> it would become \ y -> abs(((-) 3) y)
13:38:51 <S11001001> @unpl (abs .) . (-)
13:38:51 <lambdabot> (\ d g -> abs (d - g))
13:38:52 <zwer> shapr haskell drastically changed the way I think about programming. I haven't had experience yet with logic programming languages like prolog, but it is on my todo list
13:39:21 <lericson_> S11001001: yes we showed this before, the bot doesn't really help with understanding though
13:39:33 <S11001001> lericson_: sorry I missed it
13:40:06 <nitrix> Wow, prolog seems interesting.
13:40:14 <lericson_> nitrix: prolog is very, very interesting
13:40:46 <nitrix> What is it? You build relations between conditionals and it essentially become a full-fledged application that is a giant logic gate?
13:41:17 <nitrix> It's so strange.
13:41:26 <lericson_> not quite, nitrix. you define predicates (the letter L is a consonant) and then you "prove" things
13:41:50 <lericson_> prolog is then used to solve somethnig, for example "there is a letter that is a consonant after B in the alphabet"
13:41:53 <lericson_> and it would give you C
13:42:04 * geekosaur remembers using prolog to prototype a fairly complex pricing algorithm in the 90s
13:42:33 <vanila> prolog is cool because you can run programs backwards (sometimes)
13:42:36 <nitrix> Ah, might be worth looking at once I'm proficient with haskell.
13:42:48 <josephle> I remember my algorithms professor mentioning how he naively implemented a sort in prolog
13:42:50 <lericson_> vanila: yes that's the coolest aspect!
13:42:53 <dmj`> nitrix: define proficient
13:42:55 <lumo_e> Is it easy to develop general purpose programs in haskell?
13:43:01 <simpson> lumo_e: Sure!
13:43:15 <repnop> lumo_e: depends on the program eh?
13:43:16 <nitrix> dmj`: At least 20 projects and 3-4 years.
13:43:24 <shachaf> Mostly people write specific-purpose programs.
13:43:24 <repnop> much like any language
13:43:24 <lumo_e> I was following a manual long long time ago but I never got to do an hello world
13:43:43 <lumo_e> doing crazy stuff with lists was cool though
13:44:18 <dmj`> nitrix: ambitious, very cool
13:44:29 <lumo_e> mmh like say a client-server textual chat
13:44:30 <nitrix> dmj`: You don't learn by doing nothing :)
13:44:33 <repnop> i spent under a week studying haskell a bit ago and was doing csv parsing, processing and then outputting results
13:44:33 <simpson> shachaf: But Haskell's very well-suited to developing language runtimes of various sorts as well. :3
13:44:46 <lumo_e> I find such a task to be very imperative in its nature
13:44:51 <lumo_e> how do you do it in prolog?
13:44:55 <lumo_e> (or in haskell?)
13:45:08 <nitrix> lumo_e: If you have a good/twisted sense of humor, this is what got my interest first for haskell: https://www.youtube.com/watch?v=RqvCNb7fKsg
13:45:10 <dmj`> nitrix: I learn by osmosis, if there are a lot of haskell books around me the knowledge seeps into my brain w/o needing to open them
13:45:22 <shachaf> If you want to write an imperative program, you can do it in Haskell.
13:45:29 <rusk101> can sombody take a look at this problem I'm working on? its to prove that For all X there exists a Y s.t. there is no number between X and Y. I know it can be done easy for our universe of discourse 1,2,3,4. Simply (y-x) = 1. any ideas? http://lpaste.net/110516
13:45:40 <josephle> lumo_e: fortunately for you, haskell is the greatest imperative programming language designed (this is just my opinion) :P
13:46:12 <repnop> but there will be a learning curve so depends on why you want to use haskell
13:48:05 <mokkake> josephle: you mean pseudo-imperative with do, state, lens ?
13:49:00 <josephle> mokkake: well, it depends on your definition of imperative
13:49:04 <simpson> mokkake: It's actually imperative, with mutable state, to work in the ST, STM, and IO monads.
13:49:31 <simpson> ("Imperative" just means a focus on state and sequences of actions which mutate that state.)
13:49:48 <mokkake> my definition of imperative (which is probably not so true) is int x; x += 1; print x
13:50:12 <dmj`> someone needs to make a library that implements every CLRS algorithm in ST
13:50:15 <repnop> mokkake: that is undefined behavior ;)
13:50:39 <mokkake> repnop: what do you mean ?
13:50:44 <dmj`> and then optimize it like crazy
13:50:45 <simpson> :t do { x <- newIORef 0; modifyIORef x (+ 1); print x }
13:50:46 <lambdabot>     Not in scope: ‘newIORef’
13:50:46 <lambdabot>     Perhaps you meant ‘newSTRef’ (imported from Data.STRef)
13:50:46 <lambdabot>     Not in scope: ‘modifyIORef’
13:50:49 <repnop> but if you mean int x = 0; x += 1; print x
13:50:58 <repnop> you can do that easily
13:51:00 <simpson> Er, I guess you'd have to readIORef before printing, but yeah.
13:51:01 <mokkake> oh yes :p
13:51:03 <mokkake> my bad
13:51:37 <mokkake> IORef's are the equivalent of imperative-language variables ?
13:51:50 <ski> yes
13:51:54 <simpson> You can't have a valid lens into IORefs (or other mutable refs) for strange reasons that edwardk explained a while ago, but otherwise that's the way to go.
13:52:12 <simpson> (Something about unsafeCoerce being derivable if the lenses were good? Don't remember.)
13:52:13 <mokkake> oh, didn't know that, quite interesting
13:52:59 <simpson> IORef, MVar, TMVar, STRef, etc. Lots of mutable references in Haskell, just not in an especially easy-to-use way. As a friend once put it, "Haskell has mutable state, it's just ashamed to admit it."
13:53:13 <mokkake> haha
13:53:19 <NemesisD> anyone noticing some issues with hackage today?
13:53:30 <lericson_> yes
13:53:32 <dmj`> NemesisD: yea
13:54:21 <shapr> zwer: Anything specific about how Haskell changed your thinking?
13:54:45 <mokkake> also means that programming in imperative way doesn't break haskell purity and other paradigms right ?
13:54:58 <repnop> often you don't even need mutable state though eh
13:55:17 <repnop> if you're going to return a single value and need to pass state you can usually foldl
13:56:05 <simpson> Mutability improves the space and time of some algorithms. It's good to have.
13:56:07 <skift> i have a general language question. I want to learn a functional language, i had started with erlang and liked its ability for distributed systems. But i have been reading about haskell and looks nice as well. I like having the type systems. i was wondering why people like to use haskell over other functional languages.
13:56:15 <monochrom> 1. even in imperative programming, you are ashamed of global state. you usually just have local state.
13:56:19 <ski> mokkake : it doesn't break equational reasoning, no
13:56:23 <skift> my goal, is for building a backend for a small game for realtime IO
13:56:24 <eitan_chatav> hackage is slow today
13:56:35 <monochrom> 2. but then, local state easily becomes merely parameters and return values in functional programming.
13:56:51 <simpson> 3) Until objects.
13:57:20 <dmj`> skift: purity (separation of I/O with pure functions), concurrency, expressivity, type-safety
13:57:32 <ski> skift : (a) the absense of side effects; (b) the advanced type system; (c) to some extent the non-strictness (usually implemented as laziness)
13:57:43 <mokkake> elengancy!
13:57:55 <srhb> The type system, really.
13:57:57 <srhb> :P
13:57:58 <simpson> skift: There's a glut of useful libraries already written which are pretty accessible.
13:58:01 * ski elongates mokkake
13:58:09 <skift> well erlang also forces the absence of side effects does it not? well at least most of the time. i know you can force it.
13:58:28 <skift> and yes the type system is nice. and in a game, i think can really be helpful.
13:58:44 <ski> skift : sending a message is a side-effect
13:58:59 <nitrix> Does the Haskell report mendate the language to be lazy-evaluated?
13:59:03 <vanila> is anyone familiar with how to directly compile shift/rest continuations?
13:59:07 <vanila> reset*
13:59:10 <ski> nitrix : no, it just mandates non-strictness
13:59:11 <dmj`> nitrix: it says "non-strict"
13:59:18 <skift> it is? i hadn't thought of it like that. that a message is a side effect.
13:59:27 <repnop> function pattern matching could be useful for games also
13:59:33 <nitrix> ski: dmj`: appreciated.
13:59:36 <ski> nitrix : so, one could have speculative parallel execution, e.g.
13:59:59 <monochrom> no no, a message is not an effect, sending a message is an effect.
14:00:03 <ski> skift : sending a message twice isn't the same as sending it once isn't the same as not sending it at all
14:00:05 <simpson> vanila: Sure! What's your target machine?
14:00:31 <skift> ok.
14:00:36 <monochrom> contrary to what McLuhan says, the effect is not the message!
14:00:39 <ski> skift : the order in which you send two messages may be important
14:00:49 <skift> very true
14:01:06 <skift> haskell helps force that more than something like elrang?
14:01:16 <vanila> simpson, I was targeting a kind of continuation passing stack machine (in a while loop it pops the first thing off the stack and calls it, it will pop its args off the stack and then push a continuation before returning)
14:01:30 <ski> skift : within a process, i think stuff is mostly side-effect-free in Erlang
14:01:47 <ski> vanila : trampoline ?
14:01:59 <skift> yea thats what it seemed.
14:02:22 <ski> Erlang is nice in that it also has pattern-matching
14:02:30 <ski> (which it inherited from Prolog)
14:02:39 <skift> yea i like the pattern matching setup.
14:02:44 * ski idly wonders who this McLuhan might be
14:02:59 <vanila> yeah, I think that while loop is the trampoline
14:03:20 <simpson> vanila: Ah. Well, just keep a side stack of continuation delimiters, and let shift and reset alter that stack.
14:03:27 <monochrom> I spelt his name wrong. let me find the right spelling. at any rate, the Canadian prof who said "the medium is the message"
14:03:47 <ski> vanila : "how to directly compile shift/reset continuations?" .. hm, you can compile it into ordinary continuations, and a piece of state (there's some paper about this)
14:04:05 <monochrom> hrm! the spelling is right! http://en.wikipedia.org/wiki/The_medium_is_the_message
14:04:22 <ski> vanila : also, you can put marks on the stack and extract the part between such a mark and the current top. i think Racket does that
14:04:24 <monochrom> the effect is not the message. the effect just carries the message. :)
14:04:52 <vanila> ski, One thing I found was that by taking the CPS semantics of lambda+shift/reset twice - I get pure lambda calculus with continuations & metacontinuations
14:04:57 * ski supposes simpson is saying the same thing
14:05:11 <vanila> so would these correspond to the two different stacks?
14:05:22 <ski> vanila : did you check out "Abstracting Control" and "Representing Control" by Andrzej Filinski ?
14:05:30 <vanila> no, but I will :)
14:05:32 <vanila> ty
14:05:49 <ski> vanila : i think they talk about some of that stuff
14:06:13 <simpson> ski, vanila: Yeah, same thing. I did this in a slightly optimized way when I was implementing a concatenative language with delimited continuations: The resetter was reified into an object which was accessible in the language, and firing it would cause an *exception* in the host language to bubble up and trigger one or more pops from the continuation stack.
14:06:24 <ski> vanila : also check out <http://library.readscheme.org/page6.html>
14:06:43 <simpson> Where an exception is a trivial-to-model way of unwinding your host language's control stack.
14:07:15 <monochrom> yikes, that's deep. :)
14:07:18 <ski> (right, those two papers were coauthored by Andrzej Filinski and Olivier Danvy)
14:07:55 <vanila> simpson, interesting! would shift then grab what's on that second stack and 'reify' it by binding it as a first class function on the normal stack?
14:11:47 <monochrom> burp: did you know: "module Test() where foreign export ccall test :: Int; ..." is good enough, i.e., no Haskell export, just C export :)
14:11:52 <simpson> vanila: shift would, in my model, create a new marker on the continuation (second) stack, but yet.
14:11:58 <simpson> *yes, otherwise, you've got it exactly.
14:13:01 <burp> monochrom: no, thanks :D I'm still busy figuring the segfault at the end
14:14:51 <merijn> monochrom: Proper way to do that is CInt
14:14:55 <merijn> burp: ^^
14:15:00 <merijn> Don't use Int
14:15:18 <monochrom> yes, however, I doubt that it causes any problem in the context.
14:15:20 <burp> I always wondered if there is really a difference, because ghc just accepts Int's
14:15:37 <merijn> monochrom: My machine has different size Int and CInt and it causes a bug in the RTS
14:15:40 <monochrom> the other side expects GHC's Int as well. they match.
14:15:45 <merijn> burp: Yes, there is a difference
14:16:02 <merijn> 64bit GHC on OSX uses 64bit Int, 64bit gcc uses 32bit for CInt
14:16:22 <burp> oh alright, I will remember this
14:16:22 <monochrom> do you, by chance, know the context?
14:16:31 <merijn> monochrom: Of what?
14:16:46 <monochrom> of what I said at the beginning
14:17:28 <merijn> Not really? Just advocating paranoia
14:17:31 <burp> no he doesn't ;) still a valid concern if you just see it, yea
14:17:54 <monochrom> the context is http://lpaste.net/110510
14:18:16 <monochrom> the provider and the user both agree on Int. no one is saying CInt.
14:19:44 <athan> Are there any practical introductions to kan extensions and yoneda / coyoneda in haskell for laymen?
14:25:50 <eitan_chatav> yes
14:25:53 <eitan_chatav> hinze's paper
14:26:06 <eitan_chatav> http://www.cs.ox.ac.uk/ralf.hinze/Kan.pdf
14:26:56 * shachaf wonders whether that paper is good as an introduction.
14:27:55 <eitan_chatav> it's hard but Kan extensions aren't easy
14:28:07 <monochrom> burp: have you played with using C as the user?
14:28:54 <burp> monochrom: yep, works for me
14:29:43 <burp> but there it will be dangerous with Int, by merijn's concerns
14:30:47 <merijn> burp: There's a header file for using Int safely, it's just not int
14:30:49 <monochrom> oh, right, but you could #include <HsFFI.h> and use HsInt
14:31:14 <merijn> ^^
14:31:15 <merijn> That
14:32:06 <napping> A plain Int translates to some "HsInt" anyway
14:32:07 <burp> yea, ghc even generates a header file with "extern HsInt test(void);"
14:33:33 <burp> ok I see, either use CType or (Type and and HsType)
14:34:14 <d-snp> anyone know how far between cabal-install releases are? I've got 1.20 installed on two machines, and it just can't build my packages, and it won't let me downgrade to 1.18 either it seems :\
14:35:47 <napping> I doubt it's a problem with the cabal versions - I don't think anything changed that should break a build
14:36:12 <d-snp> yes there was, and a fix was merged into master 2 months ago
14:36:19 <d-snp> but there hasn't been a release yet..
14:36:30 <napping> ah, well, then it's not too hard to build it yourself
14:36:46 <napping> you tried something like cabal install cabal-install-1.18?
14:37:07 <d-snp> hmm I'm doing that now, will it remove the previous version?
14:37:10 <latk> I'm getting some error "Cabal library version >=1.19.2 && >=1.2 but no suitable version is installed.". cabal --version says 1.20.0.0, but ghc-pkg list gives Cabal-1.18.1.3. What is going on :s
14:37:11 <napping> is hackage down or is it just me?
14:37:30 <d-snp> napping: it's stuck downloading something for me :P
14:37:30 <napping> I'd expect that to overwrite the cabal binary with the one you asked for, if it works at all
14:37:33 <d-snp> you'll have to get in line ;)
14:37:34 <latk> down for me!
14:37:40 <napping> ah, okay then
14:37:53 <friden> hoogle just stopped working for me :/
14:37:59 <friden> so, probably down
14:38:14 <napping> latk: is that "using version 1.20.0.0"? I guess they have to go together
14:38:28 <napping> anyway, I guess you either built cabal in a sandbox, or reinstalled the Cabal library
14:38:59 <latk> napping: yeah, using version 1.20.0.0. It's actually a completely fresh install
14:39:14 <latk> following the instructions at https://github.com/bitemyapp/learnhaskell#ubuntu
14:39:55 <napping> I have no idea what those prebuilt packages install
14:40:18 <latk> yeah, perhaps they are not doing the best job :s
14:40:46 <napping> well, it wouldn't be particularly bad if installing the cabal-install binary didn't drag along an installation of the Cabal library
14:40:46 <latk> all of the non programming stuff in haskell always seems so frustrating
14:40:54 <friden> given a StdGen g, how do I scramble a list l? someone knows or has downloaded hoogle and can run StdGen -> [a] -> (StdGen, [a]) for me?
14:41:27 <friden> i just assume there is a function for it
14:42:03 <napping> latk: I just don't bother with distribution packages, and don't have too much trouble
14:43:00 <latk> napping: Yeah, even once you have everything installed there is the horror of actually getting everything to compile together :p
14:43:18 <napping> sandboxes involve some rebuilding, but are generally pretty reliable for that too
14:43:41 <napping> especially if you're willing to ocassionally delete everything and feed all the packages you want to cabal-install in a single request
14:43:49 <latk> Yeah, true
14:44:03 <napping> This is expected to get much better with ezyang's packaging work
14:44:07 <d-snp> it usually actually works pretty well for me on ubuntu, I don't even use the ppa, just apt-get install cabal-install, then cabal install cabal-install, and then add $HOME/.cabal/bin to your PATH and it's done
14:44:17 <merijn> latk: GHC is linked with Cabal, you can't remove the Cabal GHC ships with
14:44:25 <d-snp> napping: is ezyang building something cool?
14:44:31 <merijn> d-snp: Yes!
14:44:35 <merijn> d-snp: Backpack :)
14:44:48 <latk> Is there a summary of what Backpack is somewhere ?
14:44:55 <merijn> d-snp: parameterisable modules, multiple installs per package, etc.
14:44:58 <napping> various cool things, but in particular teaching GHC how to deal with multiple differently-compiled versions of exactly the same version number of a package
14:45:12 <d-snp> Retrofitting Haskell with Interfaces?
14:45:26 <srhb> thoughtpolice: Maybe we can put up a simple redirect with "Powered by Hetzner" in front of everything haskell.org'y and they'll fix things once people get stuck on that. :-)
14:45:28 <napping> which means in particular that cabal sandboxes would no longer necessarily need to compile everything independently
14:46:02 <napping> yeah, this is infrastructure for modules and backpack and stuff, but it alone will be pretty nicde
14:46:33 <merijn> d-snp: http://blog.ezyang.com/2014/08/whats-a-module-system-good-for-anyway/
14:57:19 <Fuuzetsu> hackage down?
14:59:19 <joshkirklin> it appears so, but you can add "remote-repo: hackage.fpcomplete.com:http://hackage.fpcomplete.com/" to your ~/.cabal/config to use fpcomplete's mirror
14:59:22 <luite_> yeah http doesn't seem to respond, but the machine still pongs my pings
14:59:41 <Fuuzetsu> I don't use cabal's .config so I can't do that ;P
14:59:43 <luite_> ah it's doing something now
14:59:53 <Fuuzetsu> 502 now
15:00:09 <luite_> it loaded one page for me and then 502
15:00:25 <thoughtpolice> i'm restarting the server
15:00:28 <Fuuzetsu> hm, I can prefetch the tarball from fpcomplete I guess, the sha should be the same
15:00:53 <Fuuzetsu> oh heh, I got through when I wasn't looking ;)
15:09:04 <linman32> what is the best way to remove duplicates from sorted list?
15:09:26 <dmj`> linman32: does order matter?
15:09:42 <linman32> yes
15:09:43 <vanila> linman32, take it through Data.Set
15:09:52 <dmj`> vanila: that won't retain order
15:10:17 <Fuuzetsu> maybe go Set before sorting?
15:10:26 <Fuuzetsu> depends on application of course
15:11:03 <linman32> it's not too important. probably 50 or less elements
15:11:23 <Peaker> linman32: map head . group ?
15:11:24 <napping> You said a sorted lists, so something like map head . group would work
15:11:36 <napping> I'm not sure if that optimizes as nicely as you might like
15:12:06 <linman32> ok. i'll look into that. thanks all
15:12:15 <napping> going through Set with fromAscList has the right asymptotics too
15:12:43 <ski> linman32 : you need to decide whether to keep first or last or other occurance of each duplicate ..
15:13:22 <linman32> keep first
15:13:36 <dmj`> actually if the list is already sorted, (\x -> Data.Set.toList . Data.Set.fromList $ x) seems to work...
15:13:49 <ski> hm, actually maybe i misunderstood .. i thought you were saying you wanted to keep the original order in the list (however it was ordered), for the elements that are kept
15:14:11 <ski> but if the list is already sorted, then i suppose duplicates would already be adjacent
15:14:13 <linman32> yes keep original order, then take first n elements
15:14:58 <ski> linman32 : and are all duplicates already adjacent ?
15:15:19 <linman32> yes, after sorting them. they start unsorted
15:15:40 <dmj`> \msg lambdabot > 1 + 1
15:15:44 <dmj`> oops
15:18:22 * hackagebot antagonist 0.1.0.22 - A web interface to Antisplice dungeons.  http://hackage.haskell.org/package/antagonist-0.1.0.22 (implementation)
15:18:24 * hackagebot tidal 0.4.11 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.4.11 (AlexMcLean)
15:18:26 * hackagebot tidal-vis 0.1.6 - Visual rendering for Tidal patterns  http://hackage.haskell.org/package/tidal-vis-0.1.6 (AlexMcLean)
15:19:32 <ski> > (map head . group) "mississippi"
15:19:33 <lambdabot>  "misisipi"
15:19:43 <ski> > (map head . group) "abbcdddeeff"
15:19:44 <lambdabot>  "abcdef"
15:20:04 <ski> linman32 : if all duplicates are adjacent, that ^ may work
15:21:21 <linman32> ski: oh neat. lambda bot is really useful
15:23:23 <ski> > groupBy (\c0 c1 -> isLower c0 == isLower c1) "misSISsiPpi"
15:23:24 <lambdabot>  ["mis","SIS","si","P","pi"]
15:30:40 <d-snp> why does he want to move haskell packagement closer to NPM? has he ever used npm? it's hilaribad :P
15:39:17 <Fuuzetsu> anyone at ICFP can poke ezyang for me? His http://heap.ezyang.com/ chucks and internal server error (500)
15:40:18 <shachaf> You could send him an email.
15:41:29 <vazza> why is functional programming so hard :(
15:41:39 <Fuuzetsu> I could but it's probably faster for someone to poke him
15:42:23 <luite_> i'm not sure if he's staying at this hotel
15:44:53 <Fuuzetsu> guess I'm stuck with the buttugly output of hp2ps and a pdf conversion
15:45:08 <Fuuzetsu> the debugging and profiling tools are really poor
15:45:23 <josephle> vazza: what troubles are you having?
15:50:47 <vazza> josephle, i am trying to run a script through ghc on terminal and it gives an error: ''The function `main' is not defined in module `Main'
15:51:06 <vazza> the script i am running does not have any IO
15:51:21 <vazza> just a top level 'naked expression'
15:51:58 <ski> vazza : you can't have that
15:52:03 <ski> write
15:52:09 <ski>   main = print $
15:52:13 <ski>     ....
15:52:21 <ski> where `....' is your "naked expression"
15:52:21 <glguy> vazza: If you omit the module declaration then you get this one automatically:  module Main (main) where
15:52:41 <vazza> out of interest, why cant i have a naked top level expression in ghc?
15:52:53 <silasm> vazza: Haskell isn't a scripting language, you need a main method for a program to do anything outside ghci.
15:52:58 <ski> vazza : because of how the language is defined
15:53:02 <vazza> i see
15:53:24 <roboguy_> vazza: what would it mean?
15:53:32 <silasm> s/method/function/ # oh god writing a hello world program in java today corrupted me
15:53:32 <ion> vazza: What would the 42 in ‘main = print "hello"; 42; foo = bar + 1’ do?
15:53:33 <ski> vazza : in the interactor, it allows entering expressions. but on the "top level" of a module in a source file, you should have declarations and definitions
15:53:47 <vazza> thanks, working through learn you a haskell, just trying to understand it all
15:53:59 <ski> vazza : a compiled program starts by executing `main'
15:54:09 <vazza> so, i should have a 'main' function which is of the IO () type
15:54:18 <vazza> with a print $ to terminal?
15:54:26 <ski> vazza : if you're content with testing things in the interactor so far, then you don't need `main'
15:54:30 <ski> you could define :
15:54:34 <ski>   test0 = ....
15:54:36 <ion> Nitpick: main is not a function, just a value.
15:54:45 <ski> and then enter `test0' in the interactor, to evaluate `....'
15:55:00 <silasm> ion: ah yeah I guess so. Two strikes for me, then.
15:55:36 <ski> vazza : "so, i should ..." -- depends on whether you want to compile to a stand-alone program executable, or whether you're content to test things out in the interactor (like GHCi) for now
15:56:51 <vazza> ski, here is a snippet of my code, but when i call factors it gives error
15:56:53 <vazza>  factors :: Integer -> [Integer] --takes a number and returns a list of all factors factors n = print $ [y| [1..n] <- y, n `mod` y ==0]
15:56:59 <vazza> sorry.
15:57:04 <vazza> factors n = print $ [y| [1..n] <- y, n `mod` y ==0]
15:57:26 <vazza> then i do factors 22 in ghc
15:57:44 <roboguy_> vazza: take the print out of factors
15:58:04 <roboguy_> the type will be wrong otherwise. Also it's always good to break things into pieces
15:58:18 <eitan_chatav> y <- [1..n]
15:58:42 <vazza> aaah yes eitan_chatav
15:58:45 <vazza> thanks
15:58:49 <eitan_chatav> np
15:59:14 <ski> vazza : since `factors' is just supposed to be concerned with computing stuff, now with presenting (outputting) it to the user of the program, it shouldn't include `print'. it's good practice to separate the "meat of the computation" from the input/output interface of the program
15:59:16 <vazza> thanks, that displays to terminal now when i call it with a number
16:00:01 <vazza> ok ski, so is it good practice for the IO part of the program to be done entirely in 'main'?
16:00:33 <gennady> Does anyone use the eclipsefp plugin? The hoogle database will never update for me.
16:00:42 <napping> that tends to get impractical, but it's nice if you can do it
16:00:46 <ski> vazza : in the interactor (in your case probably GHCi), it will automatically display the result of evaluating the expressions you enter into it, so for that you don't need stuff like `print' (but it won't show every intermediate result). however when you have compiled your program, only what is explicitly shown by `main' (or things called by it), via `print' or similar with be shown to the user of the program
16:01:35 <vazza> ok, thanks for your help guys
16:01:41 <ski> vazza : "is it good practice for the IO part of the program to be done entirely in 'main'?" -- sometimes the I/O part is large enough that it makes sense to break it into several parts, where `main' will be the main part that connects together and calls the other parts (directly or indirectly)
16:01:46 <ski> np
16:03:03 <ski> vazza : btw, note that Haskell will enforce the separation of I/O and computation to some extent .. in the sense that you can only do I/O in an action or function in case the result type involves `IO'
16:03:41 <ski> vazza : still, it is also possible to do "internal computation" as well in such operations, where usually one would prefer to break those out, into "`IO'-free" portions of the program
16:05:15 <eitan_chatav> IO, IO, it's off of work I go
16:15:12 <Fuuzetsu> RIP hackage
16:16:37 <Hodapp> bah?
16:17:22 <josephle> Alas, poor Hackage! I knew it, Fuuzetsu; a repository of infinite code...
16:18:33 <Fuuzetsu> oo I got through
16:20:42 <augur> c_wraith: your fizzbuzz thing is on reddit, you know!
16:20:53 <augur> :(
16:20:55 <d-snp> and he's gone
16:21:26 <l0cust> Why is hackage having trouble today? (And why is it hosted in Germany)?
16:23:18 <ij> Why does map (return 2) [1] return [2]? "return 2" is not a function and "return 2" returns a monad, but how can it typecheck, if map has (a -> b), where b is not a monad of any type.
16:23:38 <ij> * why does "map (return 2) [1]" return "[2]"
16:23:54 <merijn> ij: Why do you think that "return 2" is not a function?
16:24:02 <ij> :t return 2
16:24:03 <lambdabot> (Num a, Monad m) => m a
16:24:11 <joshkirklin> (a-> ) is a monad
16:24:14 <ij> right
16:24:24 <merijn> :t return 2 :: Num a => r -> a
16:24:25 <lambdabot> Num a => r -> a
16:25:27 <roboguy_> ij: actually, return 2 must be a function in this case
16:25:35 <merijn> ij: You use "return 2" where type checking says there should be a function, as a result GHC goes looking for a Monad instance for functions, which happens to exist and then it uses that :)
16:25:45 <ski> ij : "\"return 2\" returns a monad" -- no. it evaluates to a monadic *action*, for some speficic monad (here the `(Integer ->)' monad)
16:26:18 <ij> That's clear now.
16:26:42 <ski> > liftM2 (+) (2^) (3^) 2
16:26:44 <lambdabot>  13
16:26:51 <ski> > liftM2 (+) (2^) (3^) 2  :: Expr
16:26:53 <lambdabot>  2 * 2 + 3 * 3
16:27:58 <ski> ij : just wanted to emphasize that there's no such a thing as an expression "returning a monad", monads are things that exists on the type level. a value of type `M X', for some monad `M' and type `X', is a monadic action, an `M'-action
16:28:12 <d-snp> merijn: the series of articles on backpack by ezyang is very nice, thanks for linking me :)
16:28:30 <benzrf> does anybody here know pipes well
16:28:38 <merijn> benzrf: I'd say okay-ish
16:28:41 <ij> ski, i've heard people refer to values as monads, so I thought that's the way to go.
16:28:59 <merijn> ij: Because many people are really sloppy with terminology :)
16:28:59 <benzrf> merijn: eh
16:29:00 <roboguy_> ij: that's pretty much an abuse of terminology
16:29:05 <benzrf> i know pipes pretty well
16:29:08 <benzrf> but im confused by some terminology
16:29:13 <merijn> Such as?
16:29:27 <ij> merijn, roboguy_, okay then! no more of that.
16:29:30 * benzrf waits for haddock to load
16:29:46 <ski> ij : please don't refer to values as monads
16:30:06 <ski> ij : afaics, it just causes confusion
16:32:40 <ij> Will do.
16:33:07 <merijn> What was really fun was when lambdabot still had a Num intance for functions :p
16:33:13 <merijn> Which resulted in
16:33:15 <merijn> > 2 1
16:33:17 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> t))
16:33:17 <lambdabot>    arising from the ambiguity check for ‘e_121’
16:33:17 <lambdabot>  from the context (GHC.Num.Num (a -> t), GHC.Num.Num a)
16:33:17 <lambdabot>    bound by the inferred type for ‘e_121’:
16:33:17 <lambdabot>               (GHC.Num.Num (a -> t), GHC.Num.Num a) => t
16:33:20 <merijn> printing 2 :p
16:33:22 <l0cust> oh dear
16:34:44 <ij> How does the function value get formed, when I return into the ->?
16:35:22 <roboguy_> ij: return into the ->?
16:35:34 <ij> :t return 3 :: Num a => r -> a
16:35:35 <lambdabot> Num a => r -> a
16:35:43 <ij> How does it make this function?
16:35:53 <roboguy_> ij: from the definition of return for the ((->) r) monad instance
16:36:00 <merijn> ij: Same way it makes a list, it looks up the function instance of return
16:36:04 <merijn> > return 3 :: [Int]
16:36:06 <lambdabot>  [3]
16:36:22 <burff> how do i initialize the list parameter in my function " test ::  [(Int,Int)] -> [Bool]" using ghci? "test [2,3]" does not work
16:36:23 <merijn> :t return :: a -> [a]
16:36:24 <ski> @let instance Num a => Num (rho -> a) where (+) = liftA2 (+); (*) = liftA2 (*); abs = fmap abs; signum = fmap signum; fromInteger = pure . fromInteger; negate = fmap negate
16:36:25 <lambdabot> a -> [a]
16:36:25 <lambdabot>  Defined.
16:36:31 <merijn> :t return :: a -> (r -> a)
16:36:32 <lambdabot> a -> r -> a
16:36:35 <ij> > 2 1
16:36:37 <lambdabot>  2
16:36:45 <merijn> :t return
16:36:46 <lambdabot> Monad m => a -> m a
16:36:54 <ij> Right, this should've been obvious. Thanks. I'll go seek for the def then.
16:37:08 <merijn> ij: There is an instance for monad where m = '(->) r', so that's what it returns :)
16:37:44 <ski> @let instance Fractional a => Fractional (rho -> a) where (/) = liftA2 (/); fromRational = pure . fromRational
16:37:45 <lambdabot>  Defined.
16:37:48 <ski> > 2 1
16:37:50 <lambdabot>  2
16:38:00 <roboguy_> ij: lambdabot has it
16:38:05 <roboguy_> @src (->) return
16:38:05 <lambdabot> return = const
16:38:18 <ski> @src (->) (>>=)
16:38:19 <lambdabot> f >>= k = \ r -> k (f r) r
16:38:45 <roboguy_> one of the few cases where the Monad instance is exactly equal in power to the Applicative instance
16:38:56 <ski> burff : try `test [(2,3)]' ?
16:39:16 <ski> burff : .. since `test' expects a list of *pairs* of `Int's
16:39:30 <ij> Must it be const or could it be something else as well?
16:39:39 <ski> (`[2,3]' would be a list of `Int's, which is not a list of pairs of `Int's)
16:40:10 <roboguy_> ij: well, try to come up with another definition
16:40:17 <roboguy_> and see
16:40:24 <ski> ij : i think it probably has to be `const'
16:40:30 <josephle> ij, what other function (a -> Int) can you think of?
16:40:46 <josephle> or (a -> b), to be more general
16:40:46 <ij> Right, point taken.
16:41:07 <ski> josephle : there might perhaps be another instance for a more specific `rho'/`a', or with an added constraint on it .. but i doubt it
16:41:10 <ij> Well, return in that case is :: (a -> b -> a)
16:41:22 <ski> yep
16:41:36 <ski> > join (*) 5
16:41:37 <lambdabot>  25
16:41:47 <ski> @type join
16:41:48 <lambdabot> Monad m => m (m a) -> m a
16:42:05 <ij> It's weird how you can do so many things with monads.
16:42:05 <ski>   join :: (rho -> (rho -> a)) -> (rho -> a)
16:42:09 <ski>   join :: (rho -> rho -> a) -> (rho -> a)
16:42:13 <ski>   join :: (rho -> rho -> a) -> rho -> a
16:42:59 <burff> ski: thank you! :) it works and makes sense to me now
16:43:44 <benzrf> oops
16:43:47 <roboguy_> ij: you can even make a free monad out of any Functor
16:43:51 <benzrf> merijn: that took longer than i thoughtpolice
16:43:59 <benzrf> merijn: http://hackage.haskell.org/package/pipes-4.1.2/docs/Pipes.html#t:-92--62--92- <- 'chain folds'?
16:44:18 <benzrf> wait
16:44:19 <benzrf> wrong link -.-
16:44:46 <benzrf> http://hackage.haskell.org/package/pipes-4.1.2/docs/Pipes-Core.html#v:-92--60--92- this one
16:45:05 <benzrf> noooooo this one http://hackage.haskell.org/package/pipes-4.1.2/docs/Pipes-Core.html#v:-92--62--92-
16:45:08 <benzrf> christ
16:45:38 <benzrf> what does it mean, 'chain folds
16:45:41 <benzrf> '
16:46:22 <benzrf> how is one of those a fold
16:46:32 <merijn> benzrf: A pipe that reads N values and folds them into a single values?
16:47:56 <benzrf> that's not what that is, thoughtpolice
16:47:57 <benzrf> *though
16:48:06 <merijn> Eh, yes it is
16:48:08 <benzrf> the unfolds thing i can understand
16:48:10 <benzrf> merijn: ?
16:48:24 <ski> burff : np
16:48:41 <merijn> Monad m => (b' -> Proxy a' a y' y m b) -> (c' -> Proxy b' b y' y m c) -> c' -> Proxy a' a y' y m c
16:49:55 <ij> When does something get a Monoid instance? When there is "the one" instance that makes sense? For Int, both * + would pass, so neither is defined?
16:50:06 <chrisdotcode> does pattern matching not work in let bindings inside of a do block?
16:50:07 <benzrf> ij: they both are
16:50:11 <benzrf> under newtypes
16:50:16 <roboguy_> ij: yeah. They are separated into Sum and Product newtypes
16:50:23 <ij> Oh, I see.
16:50:38 <roboguy_> > getSum $ Sum 5 <> Sum 10
16:50:40 <lambdabot>  15
16:50:42 <ski> chrisdotcode : it works, but any failure won't be propagated to the `fail' operation
16:50:43 <jfischoff> chrisdotcode: it should
16:50:45 <merijn> benzrf: Feed in a c' to the 2nd argument which will produce a b' request to the first
16:50:53 <monochrom> pattern matching in let bindings work for me. what doesn't work for you?
16:51:03 <ski> chrisdotcode : you can use `<pat> <- return <expr>' in case you want such propagation
16:51:06 <monochrom> > let x:xs = "abc" in x
16:51:07 <lambdabot>  'a'
16:51:09 <monochrom> works
16:51:09 <benzrf> merijn: not seeing the fold here
16:51:10 <merijn> benzrf: This will produce any number of as and produces a b, this be fed to the 2nd argument pipe which produces a c
16:51:14 <chrisdotcode> let foo "bar" = 1
16:51:15 <chrisdotcode> let foo "baz" = 2
16:51:15 <chrisdotcode> let foo _ = 3
16:51:15 <chrisdotcode> works?
16:51:23 <chrisdotcode> because I'm getting warnings from -Wall
16:51:26 <roboguy_> ij: sometimes that can add to the readability of a type. If you see that a function returns a Sum Int, it's likely that it was using it as some kind of running total
16:51:28 <benzrf> meh
16:51:29 <monochrom> use one single let
16:51:30 <benzrf> i find it tenuous
16:51:31 <ski> chrisdotcode : remove all but the first `let's (but keep the indentation)
16:51:36 <benzrf> the thing is
16:51:44 <ij> roboguy_, that is pretty cool
16:51:49 <benzrf> it calls the mirrored function a chaining of unfolds
16:51:52 <merijn> benzrf: The 2nd argument can run the first one X amount of times to produce a c
16:51:57 <chrisdotcode> ski: right, thought so. so in my current code, each let is shadowing the prior one?
16:52:01 <ski> chrisdotcode : if you use several `let's, then latter ones will shadow earlier ones (so you have three separate definitions)
16:52:06 <geekosaur> chrisdotcode, yes
16:52:08 <benzrf> and i dont see how you can get away with calling them un or regular just by mirroring
16:52:08 <ij> Good night, fellow thinkers!
16:52:10 <chrisdotcode> excellent.
16:52:11 <chrisdotcode> thanks guys.
16:52:15 <roboguy_> good night ij!
16:52:16 <merijn> benzrf: So it foldes any number of b's into a single c
16:52:17 <chrisdotcode> that's a bit of a gotcha I didn't expect
16:52:20 <ski> night, ij
16:52:28 <jfischoff> chrisdotcode: yeah I didn’t realize that either
16:52:29 <ij> :)
16:52:36 <benzrf> merijn: seems unlikely!
16:52:37 <jfischoff> good to know
16:52:49 <monochrom> what have you learned about showing actual code for asking questions?
16:52:52 <geekosaur> ghci's actually doing somethimng a bit different, but if you wrote that in ghc it would mean: let foo "bar" = 1 in let foo "baz" = 2 in ...
16:53:14 <chrisdotcode> geekosaur: oh, it changes them to nested let ins?
16:53:27 <geekosaur> "do" syntax does
16:53:28 <chrisdotcode> monochrom: that it works 90% of the time :)
16:53:43 <chrisdotcode> well thanks again everyone
17:04:00 <carter> merijn: i'm flattered
17:04:37 <dreams> let xs = [1..100]; z = head xs; y = last xs in x+y  <-- is xs shared between z and y?
17:05:07 <dreams> sorry typo, this one:
17:05:17 <dreams> let xs = [1..100]; z = head xs; y = last xs in z+y
17:06:08 <sipa> yes, afaik
17:06:55 <ski> dreams : yes, in the implementations of Haskell i know, it is
17:07:11 <ski> in those implementations, anything explicitly named is shared
17:07:39 <ski> also, any arguments are shared
17:07:42 <dreams> Ah ok thanks.
17:09:17 <ski> so, even if you write `foo (x:xs) [] | ..x..xs.. = ... | otherwise = ...; foo [] (y:ys) = ...; foo (x:xs) (y:ys) = ...', the first argument will be shared even if it isn't explicitly named (but rather matched with `x:xs' in two defining equations, and `[]' in another)
17:11:46 <dreams> ski: I see, didn't know that.
17:12:51 <Axman6> hmm, hackage down for anyone else?
17:13:06 <Axman6> @hackage yesod-routes -- not working for me
17:13:06 <lambdabot> http://hackage.haskell.org/package/yesod-routes -- not working for me
17:16:02 <danclien> Is Hackage having issues right now?
17:16:42 <MorpheusBeing> Any body(ies) have experience with hulk - the haskell irc server
17:16:44 <ski> dreams : actually, i suppose we could skip the `otherwise' case and replace `(y:ys)' with say `ys0' ..
17:17:27 <ski> dreams : in that case, `x' and `xs' might be evaluated to some extent before we determine the guard fails, and so we'd prefer to not have to reevaluate that again in the last case
17:17:43 <MorpheusBeing> I am looking for a good/great irc server for own use and thought hulk would fit the bill
17:17:49 <ski> (sorry, the example probably got more complicated than necessary)
17:17:57 <MorpheusBeing> but having issues with missing dependencies.
17:19:46 <Axman6> MorpheusBeing: if you can't get help here, chrisdone is the person you should get in touch with. if it's on GitHub it might be worth making a bug report if it's still not working after asking here
17:19:53 * Axman6 would help but needs to go to work.
17:21:18 <bmuk> Is there a ppa for more up to date haskell packages? I know building them myself is always an option, but with that route updates would require me to rebuild everything from scratch
17:23:52 <monochrom> bmuk, are you referring to "every time I change GHC version, I have to rebuild many libraries"?
17:25:11 <bmuk> monochrom: yes, and I would have to rebuild cabal, happy, alex, etc.
17:25:27 <bmuk> whereas ppas are binary. It would just get updated with apt-get update
17:25:38 <monochrom> https://launchpad.net/~hvr/+archive/ubuntu/ghc is the only one I know, and I only know of it today
17:26:57 <bmuk> monochrom++
17:28:08 <superfunc> Since things are immutable, when I call the concat operator on existing elements in haskell, is any "new" actually created in memory?
17:28:44 <roboguy_> superfunc: yeah, it's a new object. This is because you still need to be able to access the old objects
17:28:56 <merijn> superfunc: Yes, the first half is copied
17:29:04 <superfunc> Thanks
17:29:19 <merijn> superfunc: l1 ++ l2 can reuse l2, but not l1 (since that would require changing the tail of l1)
17:29:45 <superfunc> that makes sense
17:29:50 <koala_man> the compiler may optimize it, but it'll be indistinguish from a new copy
17:32:11 <monochrom> I think I learned from bitemyapp.
17:33:23 <superfunc> I had another, unrelated question. Functors, Applicatives and Monads all have certain "Laws" that they must adhere to, to be considered a proper functor, applicative, or monad, but they aren't enforced at the language level. Is there any way to specify such constraints?
17:34:00 <silver_> not really
17:34:10 <silver_> sadly
17:34:22 <roboguy_> superfunc: haskell's type system isn't powerful enough, but in some languages it's possible I think
17:34:28 <silver_> maybe some time in future
17:34:40 <roboguy_> like Idris
17:34:50 <superfunc> Stuff like Coq?
17:35:00 <josephle> yes, Coq should be able to do that
17:35:02 <monochrom> a theorem prover is where you specify and verify such constraints. Haskell is not a theorem prover language.
17:35:27 <superfunc> That makes sense, I was just curious if the capability had been added to the type system later on
17:35:35 <mmachenry> superfunc: You can possibly do quickcheck to test the laws
17:35:38 <roboguy_> if they add full dependent types to Haskell someday, maybe it would be possible
17:35:44 <monochrom> Haskell does not even know that "filter (< 2) [1..]" can be stopped early.
17:37:38 <thinkmoore> Is there any info on what's going on with hackage today?
17:39:17 <monochrom> > let {f :: Show a => a => Bool; f x = null (show x)} in f True
17:39:18 <lambdabot>  Expected a constraint, but ‘a’ has kind ‘*’
17:40:34 <ski> > let {f :: Show a => a -> Bool; f x = null (show x)} in f True  -- ?
17:40:36 <lambdabot>  False
17:40:51 <kyfho> hello all can someone who knows only shell scripting learn haskell?
17:41:15 <silver_> yeah
17:41:16 <shachaf> Knowing some other language, such as English, is very helpful.
17:41:38 <silver_> maybe even easier that someone with OOP background
17:42:05 <silver_> aren't bash scripts kinda declarative?
17:42:16 <ski> not really
17:42:21 <prophile> not at all really
17:42:27 <silver_> oh ok
17:42:38 <prophile> in fact there's not a lot of things that are less declarative than a bash script...
17:42:46 <monochrom> ski: I was testing http://article.gmane.org/gmane.comp.lang.haskell.cafe/110371/ against lambdabot
17:43:16 <bmuk> I want to write a library for the learning experience. What kind of library does the haskell community need most?
17:43:41 <prophile> how about another FRP library
17:43:43 <prophile> the choices are so limited
17:43:49 <ski> monochrom : seemed your example required `Show :: Constraint -> Constraint', rather than `Show :: * -> Constraint'
17:44:04 <kyfho> hm
17:44:10 <kyfho> ok then buds
17:44:12 <kyfho> thx
17:44:42 <bmuk> prophile: sarcasm? lol
17:44:43 <ski> > let {f :: Show a => Eq a => a -> Bool; f x | x == x = null (show x) | otherwise = null (reverse (show x))} in f True
17:44:44 <lambdabot>  False
17:44:52 <prophile> bmuk: yes. sorry. :)
17:45:13 <bmuk> you're fine - sarcasm is hard to read through text.
17:45:18 <monochrom> well, 7.6.3 was good while it lasted
17:45:34 <prophile> something I've wanted a couple of times is a simple "get the contents of this URL" library
17:45:49 <prophile> the closest that exists at the moment is the curl bindings but they're still a bit disgusting
17:45:51 <bmuk> something like beautiful soup?
17:46:06 <ski> i think this is related to having `forall a. forall b. ..a..b..' being `forall a b. ..a..b..', and `forall a. ..a.. -> forall b. ..a..b..' being `forall a b. ..a.. -> ..a..b..'
17:46:08 <prophile> well, really I'm thinking of python's urlretrieve
17:46:40 <bmuk> That sounds interesting. I'll look into it
17:48:51 <merijn> prophile: You mean like http-conduit?
17:49:01 <kyfho> sarcasm is the dumbest form of humor
17:49:02 <roboguy_> ski: hmm, what do you mean?
17:49:56 <prophile> merijn: http-conduit only handles http
17:49:59 <prophile> to my knowledge
17:50:03 <Cale> prophile: download-curl
17:50:30 <prophile> is hackage down for anyone else?
17:50:38 <Cale> yes
17:50:43 <prophile> bah humbug
17:51:10 --- mode: ChanServ set +o shachaf
17:51:11 <Cale> But yeah, download-curl is probably exactly what you're looking for
17:51:20 <prophile> Cale: assuming it handles data: (which I don't remember if curl does off the top of my head) that looks pretty good
17:52:11 <bmuk> Well if it already exists is there anything else that is needed?
17:52:17 --- topic: set to 'Hackage/haskell.org issues being investigated; hackage mirror: http://is.gd/xJt4FF | http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://is.gd/xJt4FF' by shachaf
17:54:04 --- mode: shachaf set -o shachaf
17:55:09 <shachaf> We need a better link for Hackage outages.
17:55:53 <athan> :/
17:57:22 <athan> (sorry to off-topicify)... what's a hidden package? I've got a package included in my build-depends (redundantly/paranoid-ally across both my library and executable stanzas) that appears to be "hidden"... what should I do with it?
17:57:38 <ski> @let id2 :: (forall a. a -> a) -> (forall a. a -> a); id2 id = id
17:57:39 <lambdabot>  Defined.
17:57:41 <ski> @type id2
17:57:42 <lambdabot> (forall a1. a1 -> a1) -> a -> a
17:58:04 <ski> which will be treated as `forall a. (forall a1. a1 -> a1) -> a -> a'
17:58:08 <ski> roboguy_ ^
18:00:06 <roboguy_> ski: hmm, how does that relate to the other thing?
18:00:32 <brycelane> anybody know of a good 'dataframe' style package for exploring data?
18:01:37 <brycelane> I've found 'frame' by sdiehl on github but its relatively fresh and would like to get more opinions if possible
18:04:03 <ski> roboguy_ : automatic moving of `forall' in the result type of a function type above it ?
18:05:45 <roboguy_> ski: I thought you were saying it was related to let {f :: Show a => Eq a => a -> Bool; f x | x == x = null (show x) | otherwise = null (reverse (show x))} in f True
18:07:59 <ski> roboguy_ : related to the `Show a => Eq a => ..a..' conversion into `(Show a,Eq a) => ..a..', yes
18:08:34 <roboguy_> oh, hmm
18:29:02 * hackagebot MonadRandom 0.3 - Random-number generation monad.  http://hackage.haskell.org/package/MonadRandom-0.3 (BrentYorgey)
18:33:56 <Moggle> im trying to install hslogger, but i want it to use network-2.5.0.0, and it keeps trying to get 2.6.0.2. is there any way to make cabal use the old network?
18:35:28 <thinkmoore> hackagebot: help
18:36:29 <heatsink> Moggle, you can use --constraint=network==2.6.0.2
18:36:59 <Moggle> thank you heatsink, that's perfect
18:36:59 <heatsink> --constraint=network==2.5.0.0
18:37:42 <heatsink> I don't know if there's a way to make that the default, though
18:38:10 <heatsink> cabal-install will continue wanting to install the newer package
18:38:25 <Moggle> yeah :(
18:38:29 <Moggle> i just need one thing to compile here though
18:39:03 <Moggle> im learning a lot about cabal hell, it's interesting resolving it all
18:39:07 <Moggle> it's not quite into frustration territory
18:41:12 * merijn goes on his "this is not cabal hell" rant
18:41:29 <merijn> It's dependency hell
18:41:36 <Moggle> ah my bad
18:41:42 <Moggle> it's my first real painful experience that was not immediately solvable with a sandbox :(
18:41:47 <Moggle> oh well --constraint is working admirably
18:43:06 <JacquesC> Anyone seen cgibbard today?
18:43:24 <merijn> Moggle: I'm just trying to make the cabal devs feel better, since they get a lot of flack for what is, essentially, just the problem of packages specifying mutually incompatible constraints
18:43:26 <heatsink> You mean Cale?
18:43:34 <codehero> what does .|. do?
18:43:39 <JacquesC> @heatsink: yes
18:43:39 <lambdabot> Unknown command, try @list
18:43:40 <heatsink> bitwise or
18:43:48 <codehero> okay. thank you
18:44:02 <heatsink> Cale was in haskell-blah recently
18:44:09 <JacquesC> heatsink: yes
18:44:14 <JacquesC> Ah, thanks.
18:44:14 <codehero> another thing that confuses me is <+>
18:44:25 <heatsink> @src <+>
18:44:25 <lambdabot> Source not found. I feel much better now.
18:44:30 <merijn> Moggle: In the past cabal used to automatically reinstall/upgrade packages, resulting in silent corruption of your package database *that's* what cabal hell refers too :)
18:44:39 <Moggle> oh dear.
18:44:42 <heatsink> @where hoogle
18:44:42 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
18:44:59 <heatsink> codehero: You can search for operators in hoogle
18:45:11 <codehero> oh cool
18:45:11 <codehero> :)
18:45:20 <Moggle> merijn: that makes sense. i'm hopeful one day cabal devs will find a way to solve it, though. it seems possible in principle.
18:45:20 <codehero> ArrowPlus huh
18:45:40 <codehero> no idea. guess i don't need it
18:45:43 <merijn> Moggle: Actually, it's already work in progress at MSR :)
18:45:53 <Moggle> :D
18:45:57 <Moggle> excellent news
18:46:09 <Moggle> sweet jesus everything built and runs that was a pain
18:46:17 <Moggle> oh well only an hour of my life and i learned a lot
18:46:19 <heatsink> You mean, Backpack?
18:46:29 <merijn> Moggle: See http://blog.ezyang.com/2014/08/whats-a-module-system-good-for-anyway/ and http://blog.ezyang.com/2014/08/the-fundamental-problem-of-programming-language-package-management/
18:46:59 <merijn> heatsink: Yeah
18:47:09 <blairio> Can someone take a look at my code? I think it works, but I'm trying to learn how to re-work the syntax to make it more readable
18:48:23 <Moggle> blairio: http://lpaste.net/
18:48:29 <katsh> trying to understand the different between infix and prefix fn
18:48:47 <blairio> http://lpaste.net/110530
18:49:23 <codehero> haskell has some weird operators
18:49:40 <monochrom> katsh, what specifically do you have problems with?
18:50:18 <katsh> i dont understand the difference
18:50:20 <blairio> There's a case stranded at the bottom, but I basically only know how to use where clauses, so I can't figure out how to get it to the top
18:50:44 <katsh> is a prefix function where the function name is the lhs ?
18:50:57 <roboguy_> codehero: hmm, like which ones?
18:50:58 <katsh> like myFunction 1 2, where is infix would be 1 myfunction 2
18:51:06 <monochrom> yes.
18:51:10 <katsh> well ok
18:51:21 <katsh> thats it. ty
18:51:22 <monochrom> more prefix examples: f 4 5, (+) 4 5
18:51:33 <ski> merijn : yay !
18:51:37 <monochrom> more infix examples: 4 `f` 5, 4 + 5
18:51:37 <katsh> yeah trying to get used to the terminology
18:52:00 <Moggle> @src foldl
18:52:00 <lambdabot> foldl f z []     = z
18:52:00 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
18:52:11 <monochrom> replace my "f" by "mod" for real examples you can try in ghci
18:53:03 <merijn> ski: What, you missed the backpack stuff?
18:53:47 <Cale> blairio: one little thing, pattern matching is almost always clearer than using fst/snd if you're actually using both components
18:53:59 <merijn> Hell, even if you're not
18:58:22 <blairio> Can let expressions be of use in getting my code re-organized?
18:58:53 <Cale> blairio: I'd lift the stuff in the second where clause up to the top level. Typically the stuff which ought to go in where/let is stuff that relies on locally bound variables, or stuff which is just too esoteric to be of any use elsewhere.
19:00:20 <Cale> You might even consider doing the same with vectorize
19:01:10 <Cale> evalEach xs = zipWith eval xs (tail xs)
19:02:54 <Cale> Oh, another thing...
19:03:09 <Cale> In the guards for eval, you compute the determinant over and over
19:03:33 <Cale> Now *that's* something which you want to use a where clause for
19:04:00 <Cale> i.e. put  d = det (vectorMatrix a b)  into the where clause, and then make comparisons on d
19:04:17 <blairio> Ah, right, good call
19:06:59 <ski> merijn : aye
19:07:24 <Moggle> merijin: the second link you gave was particularly insightful, thanks. i was tickled by the solution to dependency hell where each package gets its own version of its dependencies and there's no deduplication.
19:08:15 <lpaste_> ski annotated “Turn” with “some simple improvements” at http://lpaste.net/110530#a110535
19:08:27 <ski> blairio ^
19:10:04 <blairio> Wow, eval looks a lot nicer
19:10:27 <semigroup> Hi all, I'm trying to figure out why I'm encountering this error linking an executable that uses a C++ dynamic library under the hood, anyone have any advice? https://gist.github.com/iand675/efebd1bdc54b95797956
19:10:40 <blairio> How does @ work? I haven't used that yet
19:11:05 <shachaf> > let f a@(b,c) = (a,b,c) in f (1,2) -- like this
19:11:06 <lambdabot>  ((1,2),1,2)
19:12:01 <katsh> all hail lambda bot
19:12:06 <blairio> O.o What did that do?
19:12:16 <codehero> huh
19:12:23 <blairio> makes the tuple an element of itself?
19:12:29 <codehero> hoogle can't find -->
19:12:32 <shachaf> It makes a new tuple.
19:12:40 <codehero> does that mean this isn't a standard haskell operator?
19:12:52 <shachaf> codehero: --> isn't a standard Haskell operator.
19:13:02 <codehero> okay
19:13:07 <shachaf> In f a@(b,c), f's argument is a tuple of two elements. The elements are called b and c. The whole tuple is called a.
19:13:51 <bmuk> shachaf: I've always wondered how XMonad does that. If -- is a comment, wouldn't it just throw out everything after it? I know my syntax highlighter did
19:14:03 <shachaf> Your syntax highlighter is wrong.
19:14:07 <shachaf> --> is an operator.
19:14:23 <Moggle> blairio: what's on the left of the @ is the 'whole' argument, what's on the right is the argument when it's pattern matched. in the example given, a == (b, c)
19:14:34 <blairio> THAT'S HOW YOU DO THAT?!? Man! That should have been chapter 1
19:16:27 <blairio> So can I use that to set parameters on something I'll differ to a function, say. I need a list to have at least 3 element, but I don't need to use them, can I write
19:16:52 <blairio> function l@(x:y:z:_) = ...
19:17:02 <shachaf> Or even l@(_:_:_:_)
19:17:23 <blairio> Beautiful!
19:18:37 <blairio> I don't suppose there's something similar in type definitions? For instance, I breifly looked at trying to make the determinant method only accept square blocks, but wasn't sure how
19:19:18 <Cale> bmuk: Comments begin with at least two hyphens followed by a non-symbol character.
19:19:41 <Cale> bmuk: So --> and --* for example don't count as the beginning of a comment
19:20:11 <bmuk> Cale++ so if I had a comment --!Important!, it wouldn't be a comment?
19:20:16 <Cale> right
19:24:32 <ski> blairio : not really, since you can only say `[SomeType]', not `[SomeType,SomeOtherType,SomeYetOtherType]', in types
19:24:59 <heatsink> unless DataKinds is enabled
19:25:40 <Cale> heatsink: even then, it's an uninhabited type
19:26:06 <Cale> (well, it's of the wrong kind to even ask the question about whether it has values)
19:26:15 <heatsink> I don't see a connection to blairio's goal of restricting a type to square arrays, anyway
19:27:43 <katsh> I've been reading the lyah website, and im still at the beginning, and want to get this question out of the way. what happens if i want an array of mixed types
19:27:58 <heatsink> Like a tuple?
19:28:07 <katsh> maybe. haven't gotten there yet
19:28:13 <katsh> [1, "string!"]
19:28:20 <dfeuer> Is the Haskell wiki down?
19:28:25 <roboguy_> katsh: is it ok if the size is fixed at compile time?
19:28:25 <bmuk> I'm a little new to cabal sandboxes - the tutorial I'm looking at has me install yesod-bin globally and then make a cabal sandbox within the project. I opted to install yesod to a cabal sandbox. Can I have nested sandboxes? I wouldn't think so since the PATH only has a reference to ./.cabal-sandbox/bin.
19:28:26 <blairio> is an array of size 1 tuples allowed?
19:28:28 <katsh> it was very slow for me earlier, dfeuer
19:28:31 <heatsink> > (0, True, "an", [])
19:28:32 <lambdabot>  (0,True,"an",[])
19:28:35 <roboguy_> blairio: size 1 tuples don't exist
19:28:58 <katsh> so, types = immutable, mixed types. lists = mutable, homogenous ?
19:29:12 <roboguy_> blairio: You can implement something like a size 1 tuple but it wouldn't *technically* be a tuple type
19:29:20 <heatsink> lists are immutable
19:29:32 <dfeuer> Square arrays? blairio, are you reading Okasaki's paper "From Fast Exponentiation to Square Matrices: An Adventure in Types"?
19:29:40 <roboguy_> katsh: comparing types to lists is comparing two very, very different concepts
19:29:56 <roboguy_> oh, unless you mean tuples
19:30:16 <katsh> roboguy_: i am not sure what i mean. I am asking if it's possible to have a sequence of mixed types
19:30:42 <roboguy_> katsh: if the size is fixed, then you can with a tuple. it's trickier if not
19:30:43 <heatsink> It's not clear what you are asking for, katsh
19:30:43 <katsh> the online book/tutorial im reading so far says lists are homogenous
19:30:55 <blairio> Haha, nono, I'm a newb scrub here, I'm reading just basic textbooks
19:31:20 <heatsink> katsh: We generally ask what you want to do with the data, then from that figure out what the right type is.
19:31:52 <katsh> Okay. i see there's a tuple section coming up. let me go through that
19:32:09 <heatsink> katsh: This approach makes some questions of the form can I make such-and-such kind of data" moot.
19:32:44 * hackagebot tagstream-conduit 0.5.5.2 - streamlined html tag parser  http://hackage.haskell.org/package/tagstream-conduit-0.5.5.2 (YiHuang)
19:38:03 <gennady> Can someone help me understand this error? http://lpaste.net/6199961956665786368
19:38:10 <gennady> I am not trying to construct an infinite list :|
19:38:21 <heatsink> It's not an infinite list
19:38:25 <heatsink> It's an infinitely nested list
19:38:43 <heatsink> A list having the same type as its elements
19:39:45 <gennady> "A list having the same type as its elements", why is that bad?
19:39:54 <gennady> should be a list of integers
19:40:07 <heatsink> What part of the code puts integers into the result list?
19:40:20 <roboguy_> gennady: its type would be [[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[...
19:40:28 <gennady> after primefactors returns?
19:40:45 <gennady> Hmm
19:41:32 <bmuk> Anyone have any ideas regarding yesod and cabal?
19:41:55 <bmuk> Maybe this isn't how sandboxes were meant to be used.
19:41:56 <heatsink> For example, if n is 2, then 2 is a prime factor of n.  What code adds 2 to the list?
19:44:08 <gennady> I thought after primeFactor was called again if the modulus evaluated to true it would be added
19:44:51 <heatsink> it would be added by what code?
19:46:03 <gennady> if the modulus evaluates to true wouldnt n be added to the list?
19:46:23 <heatsink> No.  primeFactor (n `div` x) will be added to the list.
19:46:55 <gennady> Hmm
19:49:01 <heatsink> I think that you intend for the algorithm to iteratively search for prime factors.  Each time a factor x is found, it becomes part of the output list, add the search restarts on n `div` x.
19:49:11 <benzrf> another unfold!!!
19:49:54 <gennady> heatsink, yeah :|
19:50:18 <heatsink> In that case, try writing a function that searches for one prime factor.
19:51:37 <heatsink> Note that there may not be a prime factor (if n is 1), so take that into account when writing the function.
19:51:44 <benzrf> hmm
19:51:52 <benzrf> is there a way to unfold when you know you have the last element?
19:51:59 <benzrf> i.e. the last value you yield is when you know to stop
19:52:54 <heatsink> You put the 'stop' signal into the de-accumulator where it's used in the next step.
19:53:05 <gennady> Hmm alright thanks
19:53:32 <heatsink> That function will be a building block for creating the list of all prime factors.
19:54:43 <ski> gennady : that kind of error (`a = [a]') would usually mean that you're somewhere confusing a list for a list element, or vice versa
19:58:12 <CrazyM4n> so i´m trying to make a function that manipulates lists
19:58:21 <CrazyM4n> and it isn´t quite doing what i want it to
19:58:46 <CrazyM4n> it´s quite a mess, but if someone could help me pinpoint the problem that´d be great
19:59:00 <benzrf> heatsink: thats kinda clumsy
19:59:08 <CrazyM4n> i have an argument to this function, stack@(shead:smid:stail)
19:59:12 <benzrf> ive done it before, but
19:59:14 <CrazyM4n> then it says ¨((stack !! (fromIntegral shead)):smid:((take ((fromIntegral shead)-1) stack)++(drop (fromIntegral shead) stack)))¨
19:59:15 <benzrf> bleh
19:59:26 <heatsink> benzrf: There isn't a better way, if you're using unfold
19:59:31 <benzrf> I:
19:59:56 <CrazyM4n> it´s supposed to take the top value (call it I), and move a value from index I to the top
20:00:08 <CrazyM4n> but it´s not and i´m really confused D:
20:00:42 <heatsink> It's helpful to split the expression into smaller pieces and give meaningful names to the terms
20:00:53 <CrazyM4n> sounds good
20:00:56 <CrazyM4n> let me do that
20:01:24 <benzrf> CrazyM4n: try writing a helper function like 'splice' or something
20:01:30 <benzrf> that takes an index and removes that index
20:01:31 <benzrf> or puts it in
20:01:35 <CrazyM4n> ah i see
20:09:00 <CrazyM4n> ok
20:09:02 <CrazyM4n> this is terrible
20:09:34 <bmuk> I'm getting an error that log files don't exist with cabal, but when I run the install command again, everything magically works. Is there a reason for this (i.e. should I fear my install is borked)?
20:19:40 <napping> I think that's a problem downloading something?
20:19:44 <napping> hackage has been down a bit
20:25:00 <bmuk> napping: ah. That would probably explain it. I know I have had cabal fail building things before because it ran out of memory as well.
20:32:17 * dfeuer thinks Hackage should be written entirely in Haskell and should only go down in earthquakes.
20:32:26 <ScrewLoose007> ahh, that is why my cabal update has been screwing up!
20:32:42 <ScrewLoose007> not even earthquakes should take it down!
20:32:55 <dfeuer> Why the heck does lpaste consider a "redundant lambda" to be an error?
20:33:20 <roboguy_> dfeuer: hlint can be picky
20:33:52 <dfeuer> "Redundant" lambdas are kind of important for inlining purposes, and they are in any case nothing like erroneous in principle--in fact, they can make code easier to understand!
20:36:08 <roboguy_> yeah, there's a couple hlint warnings that I feel make code harder to read
20:37:06 <NemesisD> any emacs users in here have a good set up for offline documentation browsing?
20:37:25 <NemesisD> this hackage outage is cramping my style
20:39:58 <ski> dfeuer : it's just a suggestion. there can be good reasons to ignore it
20:40:20 <ski> (as long as you're aware of doing so)
20:40:33 <dfeuer> ski, something called an "error" as opposed to a "warning" (which it also offers) should be something that is at least almost certain to be wrong.
20:41:53 * hackagebot hs-php-session 0.0.9.0 - PHP session and values serialization  http://hackage.haskell.org/package/hs-php-session-0.0.9.0 (elblake)
20:42:26 <ski> dfeuer : could be
20:43:54 <CrazyM4n> thank god for haskell error messages
20:43:59 <CrazyM4n> i couldn´t figure out the problem
20:44:05 <CrazyM4n> then i actually read the error message
20:44:16 <CrazyM4n> ¨drop is applied to too few arguments¨
20:45:57 <jle`> ;)
20:46:07 <cschneid> what's up w/ hackage? died again?
20:46:13 <jle`> i think it should be on some troubleshooting guide
20:46:15 <shachaf> Yep. See topic.
20:46:24 <dfeuer> I tend to find GHC's error messages inscrutable. But the type checker's are *often* better than the parser's.
20:47:01 <dfeuer> The parser has various messages available, but it seems most errors get lumped into the "Parse error. Maybe your indentation is wrong." box.
20:47:19 <jle`> (step 1) did you read the error message?
20:47:52 <dfeuer> Yes.
20:47:55 <jle`> GHC error messages have a lot to be desired, but it's worth recognizing that enough progress has been made that they are sufficiently useful in certain occasions
20:48:01 <dfeuer> Yes.
20:48:08 <jle`> dfeuer: oh, that was a continuation to my "i think it should be..." thought
20:48:30 <dfeuer> The type checker these days very often will have one or more useful messages along with the more inscrutable ones.
20:48:45 <dfeuer> Ah.
20:49:50 <benzrf> i should sleep
20:49:51 <benzrf> bye
20:50:04 <dfeuer> The parser ... blargh. I blame 1. Haskell's somewhat over-complicated syntax and 2. Perhaps also the fact that the fancy parser combinator libraries with fancy error messages aren't fast enough for GHC, so it has to use more primitive tools. (maybe)
20:50:08 <dfeuer> BYE.
20:50:30 <dfeuer> [Or aren't up to the task of parsing Haskell]
20:51:10 * dfeuer offers everyone chocolate milkshakes that don't actually exist right now, but did yesterday.
20:52:22 <roboguy_> dfeuer: compared to C++ though...
20:53:08 <dfeuer> roboguy_, I haven't touched C++ since I attempted to learn it from a Borland C++ manual in middle school or so. It's ... disgusting.
20:53:13 <roboguy_> (syntax-wise and template type error-wise)
20:53:46 <roboguy_> they've hammered on a few new parts since then so it's even, well, I'm going to say "stranger"
20:53:53 <shachaf> Can we not have language bashing in here, please?
20:53:57 <roboguy_> sorry
20:53:58 <dfeuer> Middle school was in the mid-90s....
20:54:46 <lpvb> shachaf: is there an exception for java
20:55:09 <shachaf> No.
20:55:26 <dpn`> hackage running really slow for anyone else? :/
20:55:31 <Cale> I tend to find that if you read them carefully enough, GHC's type errors tend to be pretty sensible most of the time.
20:55:49 <lpvb> dpn`: it's been down since this morning
20:55:59 <lpvb> it has substantially decreased my productivity for today
20:56:02 <dpn`> oh - that qualifies as slow I guess
20:56:03 <dpn`> heh
20:56:04 <dpn`> thanks
20:56:35 <lpvb> oh but it's back up for me now
20:56:37 <dpn`> lpvb, the website just loaded for my FWIW - just very slowly
20:56:43 <dpn`> me*
20:56:51 <roboguy_> Cale: sometimes I have to think for a second about which is the expected type vs actual type, but it is generally pretty handy
20:56:57 <dfeuer> shachaf, what is wrong with bashing C++?
20:57:25 <shachaf> Cale: I still never remember which one is "expected type" and which one is "inferred type".
20:57:35 <shachaf> The main reason is that I hardly ever need to remember, of course.
20:58:03 * dfeuer finds it most useful to look at each error message briefly in turn until he finds one that is easier to understand than the rest.
20:58:11 <Cale> At least one of the two is usually immediately understandable :)
20:58:46 <dfeuer> Also to add more type signatures.
20:58:53 <Cale> dfeuer: But that's true, looking for easy things to fix first is usually a good idea.
20:59:25 <dfeuer> Often fixing the easy thing to recognize will either make the other go away or make its error message easier to understand.
21:03:26 <gennady> So, I am trying to figure out the techniques used when you want to have a constant variable and than have like a counter in a for loop in C for example.
21:03:48 <CrazyM4n> ugh, more errors
21:04:17 <CrazyM4n> i have this code: ¨where (xs, ys) = splitAt (fromIntegral shead) smid:stail¨ and shead is an Integer, smid is an Integer, and stail is an [Integer]
21:04:40 <dfeuer> gennady, what do you mean by a "constant variable"?
21:04:48 <gennady> I need X to stay the same but iterate through a numbered list Y and than redo it again with Y decremented...
21:04:50 <CrazyM4n> aaand never mind i just had to put parens around smid:stail
21:05:01 <CrazyM4n> you could use list comprehension
21:05:04 <roboguy_> gennady: generally you use recursion in some way or you use a higher order function like foldr
21:05:05 <gennady> by having the user only pass "myFunc X"
21:05:28 <dfeuer> gennady, I don't think you're giving enough information to be able to get a good answer.
21:07:01 * hackagebot tagstream-conduit 0.5.5.3 - streamlined html tag parser  http://hackage.haskell.org/package/tagstream-conduit-0.5.5.3 (YiHuang)
21:07:16 <dpn`> what would you use to build backend type services in hs?
21:08:00 <dpn`> let's just say with a REST or RPC interface for argument's sake
21:08:18 <roboguy_> gennady: one common pattern is to have an inner helper function. So you could have something like myFunc x = go 0 x where go n x = ...
21:08:22 <dpn`> snap seems very web focused, but perhaps might be a nice candidate
21:08:50 <roboguy_> it would be better to avoid shadowing x, but pretend I did that
21:08:51 <lpvb> why is it idiomatic to call the inner function go anyway
21:09:15 <gennady> hmm
21:09:16 <roboguy_> lpvb: tradition iirc. I'm not sure where it originated exactly
21:09:27 <roboguy_> it's kinda nice to have a standard name though
21:09:33 <dfeuer> lpvb, does there have to be a why? roboguy_, someone actually tracked down when it appeared.
21:09:49 <roboguy_> dfeuer: yeah, I vaguely remember that...
21:10:00 <lpvb> there doesn't have to be, I'm expecting a Maybe
21:11:14 <dfeuer> A non-standard alternative, sometimes, if things get too hard to read with go, is to use a name like blah_x_y, where x and y are variables that blah uses but doesn't take as arguments.
21:11:39 <gennady> roboguy_, This is my second attempt http://lpaste.net/7283116742660849664 , Which is wrong. I just need x to stay the same but keep testing on [2..x]
21:13:31 <roboguy_> gennady: you're never increasing x
21:13:47 <gennady> well at this point I was trying do it decreasing
21:14:02 <gennady> and than I just realized I never used n
21:14:03 <gennady> heh
21:14:05 <dfeuer> gennady, also, that will probably only produce a single element....
21:14:09 <roboguy_> how do you do a descending list of prime numbers?
21:14:30 <katsh> [ (a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10] ]   i get (1,1,1), (2,1,1).. etc. howcome its not (1,1,1), (2,2,2) etc?
21:14:32 <roboguy_> oh, I'm thinking infinite never mind
21:14:39 <dfeuer> roboguy_, uh ... you do an ascending list of prime numbers and reverse it?
21:15:00 <roboguy_> yeah, I'm just so used to infinite streams of primes in Haskell my mind automatically went there haha
21:15:49 <dfeuer> Just reverse the infinite stream and then drop all but the last few.
21:16:44 <jle`> katsh: you can think of it as a depth-first traversal, if you are familiar with the term
21:16:45 <roboguy_> well, I was thinking he was wanting to construct a descending infinite list of primes
21:16:46 <gennady> Guess I should put my head more in the book than :|
21:16:54 <katsh> i am
21:16:55 <roboguy_> gennady: I would suggest not starting with unfoldr
21:17:02 <roboguy_> and instead use recursion explicitly
21:17:04 <jle`> katsh: oh, i see what you are asking now
21:17:12 <gennady> well my end result is to get a count of the number of primes for that number
21:17:18 <dfeuer> YES.
21:17:20 <jle`> katsh: it gives you all possible combinations of the ranges
21:17:21 <gennady> but at this point was just trying to get them
21:17:23 <ski> katsh : the last generator in the list comprehension varies most quickly
21:17:36 <katsh> jle`: i know. but why
21:17:42 <jle`> katsh: why, as a design choice?
21:17:53 <dfeuer> Unfoldr is very nice once you understand the recursion pattern it encapsulates, but until then not so much.
21:17:57 <jle`> why as in why does the implementation behave that way?
21:18:07 <gennady> Hmm alright
21:18:09 <roboguy_> dfeuer: agreed
21:18:35 <katsh> yes. why does it not match up each element in the last, with its equivalent in the other list
21:18:42 * dfeuer should focus some attention on getting his unfoldr modification ready for prime time.....
21:18:49 <jle`> katsh: so you mean why was the language designed to not do that?
21:19:01 <katsh> what in that comprehension says i want all the combination of those 3 lists
21:19:07 <dfeuer> Because the version of unfoldr in Data.List is pretty much horrible.
21:19:17 <jle`> katsh: that's just...the syntax.  that's the way it was decided
21:19:28 <katsh> oh
21:19:31 <jle`> it mirrors list comprehensions in set theory
21:19:49 <dfeuer> jle`, you mean "set comprehensions" I think.
21:19:58 <jle`> dfeuer: ah yeah, i do :)
21:20:09 <dfeuer> Or something.
21:20:25 <jle`> when you say [ (a, b) | a <- [1..10], b <- [1..10] ], you are saying "i want all (a,b)'s such that a is from [1..10] and b is from [1..10]
21:20:32 <dfeuer> http://en.wikipedia.org/wiki/Set-builder_notation
21:20:33 <jle`> so it'll give you all such (a,b)'s
21:21:06 <katsh> jle`: ok. so its a design thing
21:21:10 <katsh> but default
21:21:24 <khumba> katsh, there are the zipWith functions if you want the matching-up behaviour.
21:21:25 <jle`> > [ (a, b, c) | a <- [1..10], b <- [1..10], c <- [1..10], a^2 + b^2 == c^2 ]
21:21:26 <dfeuer> Or you can say  [a^b | a <- [1..10], b <- [1..a], a*b>3]
21:21:27 <lambdabot>  [(3,4,5),(4,3,5),(6,8,10),(8,6,10)]
21:21:31 <dfeuer> You can do a lot with them.
21:21:43 <katsh> i would think it would take a[0] and b[0] and give (a[0], b[0]) then go on to (a[1], b[1])
21:22:07 <dfeuer> katsh, there's a GHC extension to do things like that.
21:22:17 <dfeuer> Parallel comprehensions or something? They're zippish.
21:22:20 <jle`> katsh: sometimes i think that | should be a logical OR, but...that's just a syntax and language decision :)
21:22:39 <dfeuer> | is also used for guards.
21:22:42 <jle`> sometimes i think we should use {} for lists instead of []
21:22:53 <katsh> dfeuer: good to know. not that i need it, just as a beginner, seemd like it woudl do so
21:23:26 <dfeuer> katsh, I don't know the syntax for it. It *might* just add extra |s, but I don't remember.
21:23:32 <dfeuer> Well, don't know.
21:24:06 <jle`> katsh: you'll find that the all-combinatons behavior ends up being more useful more often :)
21:24:28 <katsh> i'm sure
21:24:46 <ski> katsh : do you know any imperative language having a `for' or `foreach' construction ?
21:25:01 <katsh> i had pictured an internal pointer of some kind, picking the elements from all lists, at the same positions
21:25:04 <katsh> ski:  yes
21:25:29 <ski> katsh : a sequence of generators in a list comprehension is akin to nested `for's / `foreach'es
21:26:53 <katsh> indeed
21:27:01 <ski> > [[a,b,c] | a <- "ab" , b <- "01" , c <- "CD" ]
21:27:03 <lambdabot>  ["a0C","a0D","a1C","a1D","b0C","b0D","b1C","b1D"]
21:27:09 <ski> > [[a,b,c] | a <- "ab" | b <- "01" | c <- "CD" ]
21:27:10 <lambdabot>  ["a0C","b1D"]
21:28:52 <katsh> going to take a while to grap this
21:28:58 <katsh> list comprehension that is
21:30:05 <jle`> katsh: do you have a programming background?  if so, in what language?
21:30:30 <katsh> js, and python, although i've only used very basic list comprehensions in python
21:30:42 <katsh> like the equivalent of [x * 2 | x <- [1..10]]
21:31:24 <jle`> [(a,b) | a <- [1..10], b <- [1..10]] is sort of the equivalent of for a in [1..10] { for b in [1..10] { return (a, b); }; };...if that syntax makes sense
21:32:14 <katsh> yeah, a nested loop
21:32:16 <dfeuer> katsh, are you not familiar with set-builder notation in math?
21:32:17 <jle`> or maybe i should be saying print or something like that
21:32:52 <katsh> dfeuer: i took discrete math many many years ago. so, not anymore
21:32:55 <katsh> (8)
21:33:02 <katsh> years, that is =D
21:33:19 * dfeuer never took discrete math.
21:33:34 <katsh> interesting class. lots of set theory and graph theory
21:34:32 <dfeuer> Set theory I can handle up to but not after the point where it goes all interesting/weird with stuff like independence proofs.
21:34:49 <lpvb> I thought the list comprehension was indeterminate because that's the only way to satisfy the underlying list monad laws?
21:34:57 <dfeuer> Graph theory I have no clue about.
21:35:15 <shachaf> Indeterminate?
21:36:22 <lpvb> umm.. I forgot the word for it
21:36:36 <dfeuer> Hah! http://www.cbs.com/shows/csi/  "Premires [sic] Sun Sept. 28 10/9c"
21:36:55 <dfeuer> Thats before it mires, I guess.
21:37:25 <lpvb> shachaf: nondeterministic
21:37:27 <ski> lpvb : indeterminate in ordering/nesting, you mean ?
21:38:05 <shachaf> dfeuer: That's not very Haskell-related.
21:38:21 <roboguy_> lpvb: yeah, I think it has to be that way for it to be a Monad. ZipList isn't a Monad, for example
21:38:24 <dfeuer> True that. Sorry.
21:38:45 <dfeuer> roboguy_, what is ZipList?
21:38:59 <roboguy_> > getZipList $ (,,) <$> ZipList [1..5] <*> ZipList [1..5] <*> ZipList [1..5]
21:39:00 <lambdabot>  [(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5)]
21:39:22 <roboguy_> it's like [], but its Applicative instance is zip-like
21:39:39 <jle`> an alternative Applicative instance for [] where liftA2 is zipWith...but there isn't a Monad instance for list such that liftM2 = liftA2 for ZipList
21:39:54 <roboguy_> compare with
21:39:56 <roboguy_> > (,,) <$> [1..5] <*> [1..5] <*> [1..5]
21:39:58 <lambdabot>  [(1,1,1),(1,1,2),(1,1,3),(1,1,4),(1,1,5),(1,2,1),(1,2,2),(1,2,3),(1,2,4),(1,...
21:40:26 <lpvb> katsh: the extra syntax for the extra variables would be redundant though because you could just do
21:40:47 <lpvb> > [(a,a,a) | a <- [1..10]]
21:40:48 <lambdabot>  [(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5),(6,6,6),(7,7,7),(8,8,8),(9,9,9),(10...
21:41:07 <jle`> or
21:41:20 <jle`> > [(a,b,c) | a <- [1..10], let b = a, let c = a ]
21:41:21 <lambdabot>  [(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5),(6,6,6),(7,7,7),(8,8,8),(9,9,9),(10...
21:42:02 <jle`> but he was probably thinking about each having separate ranges ;)
21:42:11 <roboguy_> yeah
21:42:12 <roboguy_> > getZipList $ (,) <$> ZipList ['a'..'d'] <*> ZipList [1..5]
21:42:14 <lambdabot>  [('a',1),('b',2),('c',3),('d',4)]
21:42:35 <ski> dfeuer : btw, didn't you use to frequent c.l.s ?
21:44:24 <dfeuer> ski, at one point, yeah.
21:44:34 <dfeuer> I was probably just as stupid then!
21:45:22 <lpvb> anyone know where the ghci config on mac is located?
21:46:41 <shachaf> @google where the ghci config on mac is located
21:46:41 <lambdabot> https://www.haskell.org/ghc/docs/7.2.2/html/users_guide/ghci-dot-files.html
21:47:17 * shachaf guesses that it's one of the last two.
21:47:25 <lpvb> my google queries suck
21:47:52 <shachaf> Pretend Google is an IRC channel.
21:47:59 <lpvb> oh I tried those already though
21:48:36 <dfeuer> @google How does Takano Akio's foldrW/buildW fusion work?
21:48:37 <lambdabot> https://github.com/takano-akio/ww-fusion/blob/master/readme.md
21:48:40 <shachaf> Is there a .ghc directory in $HOME?
21:48:46 <dfeuer> Yeah, that doesn't really answer it.
21:49:28 <lpvb> shachaf: yea but there's no ghci config
21:49:30 <ski> dfeuer : i just thought i recognized the name :)
21:49:39 <shachaf> lpvb: You'll have to make it, then.
21:49:47 <roboguy_> lpvb: there's no ghci.conf or .ghci?
21:49:50 <dfeuer> Feuer is not a *rare* name, but it's not a *common* one.
21:50:03 <lpvb> oh right
21:50:42 * dfeuer hopes Rugal is no longer stoned.
21:54:21 <Guest51339> @type let
21:54:22 <lambdabot> <no location info>: not an expression: ‘let’
21:54:29 <ski> dfeuer : one could perhaps say that (the applicative instance for) `ZipList' focuses on the *position* of elements in a list, while (the applicative and monad instance for) `[]' focuses on the relative *ordering* of elements in a list
21:54:43 <ski> Guest51339 : `let' is primitive syntax
21:55:11 <Guest51339> ski: hmmm, was there any design choice behind that
21:55:38 <dfeuer> ski, I don't understand Applicative yet.
21:56:00 <ski> applicatives/idioms are like a weaker version of monads
21:56:19 <dfeuer> That part I gathered from what people have said, but what actually goes into them is less clear to me.
21:56:22 <tac_> Guest51339: let is historically the keyword you use to create a local variable
21:56:35 <ski> for a monad `M', we can express `join :: M (M a) -> M a'. we can't express this for an applicative/idiom
21:56:41 <tac_> Guest51339: precedence was set sometime in the 1400s I'm sure by some mathematician ;)
21:57:01 <ski> this means that one can't describe "run-time dependent structures" with applicatives/idioms, while that is possible with monads
21:57:33 <dfeuer> What is that <*> thing?
21:57:35 <ski> e.g., with a monadic parser, you can parse some part of the input, then depending on what you parsed, you can decide what to attempt to parse next
21:57:48 <ski> not so with applicatives/idioms
21:58:02 <tac_> @type (<*>)
21:58:03 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
21:58:04 * dfeuer knows so little about parsing it's not even funny :-/
21:58:08 <ski> `(<*>)' is an applicative combinator, which corresponds to `ap' for monads
21:58:10 <ski> @type ap
21:58:11 <lambdabot> Monad m => m (a -> b) -> m a -> m b
21:58:21 <ski> @src ap
21:58:21 <lambdabot> ap = liftM2 id
21:58:26 <tac_> > [(+1), (+2), (+3)] <*> [1, 2, 3]
21:58:27 <lambdabot>  [2,3,4,3,4,5,4,5,6]
21:58:44 <lpvb> what's the categorical description of applicative?
21:58:44 <Guest51339> tac_: he he :-) , but say I want to create a let expression, what wil be the simplest signature?
21:58:44 <tac_> > LipList [(+1), (+2), (+3)] <*> ZipList [1, 2, 3]
21:58:45 <lambdabot>  Not in scope: data constructor ‘LipList’
21:58:45 <lambdabot>  Perhaps you meant ‘ZipList’ (imported from Control.Applicative)
21:58:46 <ski>   ap mf mx = do f <- mf; x <- fx; return (f x)
21:58:52 <tac_> lol oops
21:58:54 <roboguy_> I like the "context sensitive whitespace view" of applicative
21:58:56 <tac_> > ZipList [(+1), (+2), (+3)] <*> ZipList [1, 2, 3]
21:58:57 <lambdabot>  ZipList {getZipList = [2,4,6]}
21:59:06 <ski> tac_ pays lip service to spelling
21:59:08 <dfeuer> Whoa, this is getting too hard to read.
21:59:25 <tac_> Guest51339: an example of let, you mean?
21:59:28 <tac_> > let x = 1 in x + x
21:59:30 <lambdabot>  2
21:59:34 <roboguy_> lpvb: the docs say it's a strong lax monoidal functor
21:59:43 <tac_> > let x :: Integer; x = 1 in x + x + x
21:59:44 <Guest51339> tac_: I mean my own let expresion
21:59:44 <lambdabot>  3
21:59:45 <ski> > [(100 +), (200 +), (300 +)] <*> [1, 2, 3]
21:59:47 <lambdabot>  [101,102,103,201,202,203,301,302,303]
22:00:04 <dfeuer> Guest36935, can you be more concrete about what you're trying to do?
22:00:06 <roboguy_> lpvb: I don't really know what "lax" means there, but the other parts I sort of have some understanding of
22:00:06 <ski> > getZipList (ZipList [(100 +), (200 +), (300 +)] <*> ZipList [1, 2, 3])
22:00:07 <lambdabot>  can't find file: L.hs
22:00:14 <ski> @botsmack
22:00:15 <lambdabot> :)
22:00:17 <ski> > getZipList (ZipList [(100 +), (200 +), (300 +)] <*> ZipList [1, 2, 3])
22:00:18 <lambdabot>  [101,202,303]
22:00:32 <dfeuer> Guest36935, let is not a function; it's part of Haskell's syntax.
22:00:41 <dfeuer> It has no "signature".
22:00:59 <dfeuer> In lispy languages, it's sometimes a macro.
22:01:08 <ski> Guest51339 : it can't be a function, because of polymorphic generalization of `let'-bound variables
22:01:39 <ski> (i'm ignoring the concrete syntactic details here)
22:02:04 <dfeuer> ski, I would venture to guess that the concrete syntactic details are probably the things to focus on right now
22:02:14 <ski> in a language with polymorphic `let'-generalization, `let' can't even be a macro
22:02:15 <Guest51339> dfeuer: ski: okay, I am trying something like computational expression
22:02:40 <ski> dfeuer : i don't really know how much of basic Haskell you know yet ..
22:02:53 <dfeuer> So several people dumped a whole bunch of junk with <*> and about Applicative that was totally useless to me, since I still don't understand what Applicative is....
22:03:00 <dfeuer> ski, I meant for Guest36935.
22:03:16 <ski> oh, ic
22:03:31 <dfeuer> I know a smattering of this and that myself. I'm reasonably comfortable with monads but not monad transformers.
22:03:31 <roboguy_> dfeuer: <*> takes a function wrapped in a "context" (in the sense of Functor or Monad) and a value in a "context" and it applies the function to the value and produces a result in the context
22:03:33 <Guest51339> ski: I am kinda 3 months old
22:03:36 <roboguy_> :t (<*>)
22:03:37 <ski> dfeuer : do you understand `Functor' and `fmap' ?
22:03:37 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
22:03:59 <Guest51339> yeah I do, I assume its for me again
22:04:13 <dfeuer> ski, I'm sure there's more to understand about them, but I have a basic understanding.
22:04:39 <dfeuer> roboguy_, okay.
22:04:53 <ski> dfeuer : if `F' is a functor, then we can "lift" a function of type `T -> U' to a function of type `F T -> F U', using `fmap'. agree ?
22:05:23 <dfeuer> Yes.
22:05:33 <lpvb> applicative is a monoidal functor that may or may not be invertable with no additional properties? wikipedia is confusing
22:06:03 <dfeuer> Wikipedia is confusing, and often wrong.
22:06:05 <ski> dfeuer : if `I' is an applicative (functor), then we can "lift" a function of type `T -> U -> V' to a function of type `I T -> I U -> I V', using the applicative primitives. so this allows us to "lift" functions with more than two arguments
22:06:47 <dfeuer> ski, do you mean more than one? OR do I not understand you?
22:06:57 * shachaf thinks (<*>)/pure are the most confusing primitives to understand Applicative with.
22:07:02 <ski> dfeuer : essentially, it allows us to combine the argument of type `I T' with the argument of type `I U' into something of type `I (T,U)', and then we could `fmap' our (uncurried) function of type `(T,U) -> V' over that to get the result `I V'
22:07:24 <ski> dfeuer : sorry, more that one, i should have said
22:07:27 <tac_> shachaf: indeed. Monoidal for the win
22:07:34 <roboguy_> lpvb: I have a feeling the "monoidal functor" part is the more important part
22:07:41 <shachaf> Less confusing: Functor has lift1 :: (a -> b) -> F a -> F b; Applicative adds lift0 :: a -> F a, and lift2 :: (a -> b -> c) -> F a -> F b -> F c
22:07:48 <ski> (i was simultaneously thinking about "at least two", which probably was what confused my sentence)
22:07:53 <shachaf> (With some laws that make sense.)
22:08:03 <tac_> shachaf: liftN in general, right?
22:08:12 <dfeuer> So lift0 is what you called "pure"?
22:08:15 <shachaf> You can make liftN out of these two.
22:08:17 <lpvb> roboguy_: yeah but that also sounds like the description of monad, monoids in the category of endofunctors
22:08:18 <ski> dfeuer : yes
22:08:19 <tac_> yeah
22:08:25 <dfeuer> And presumably lift0 is what Monad calls return?
22:08:28 <ski> yes
22:08:29 <lpvb> I'm trying to see the distinction
22:08:30 <shachaf> Also less confusing: Applicative has unit :: F (), and times :: F a -> F b -> F (a,b)
22:08:31 <dfeuer> Hmm.
22:08:40 <shachaf> It looks like I'm interrupting ski, actually.
22:08:43 * dfeuer can only think about one thing at a time.
22:08:45 <shachaf> So ignore me and listen to ski.
22:08:55 <ski> shachaf : hehe, no, it was a good interruption :)
22:09:00 <roboguy_> lpvb: well, I think the monoid in that definition refers to a monoid object not a monoidal category. Also, not all functors are endofunctors
22:09:34 <shachaf> I think the laws are probably clearest with unit/times
22:09:39 <lpvb> roboguy_: I thought all functors in haskell were endofunctors, since the category is types
22:09:46 <shachaf> And maybe the use is clearest with lift0/lift2
22:09:48 <ski> lpvb : yes
22:10:12 <shachaf> (<*>) is just a cute trick as far as I'm concerned and has no business being the primitive when you're trying to understand this.
22:10:20 <shachaf> (This isn't necessarily true in other categories.)
22:10:36 <dfeuer> lpvb, all Functors in Haskell are endofunctors. I don't think all functors in Haskell are.
22:11:11 <dfeuer> But ... I could be wrong, because I don't understand any of that category stuff.
22:11:49 <ski> dfeuer : `lift2 ($)' is called `(<*>)', alternatively, we can define `lift2' as `lift2 f ia ib = fmap (uncurry f) (times ia ib)' or as `lift2 f ia ib = pure f <*> ia <*> ib'
22:11:54 <roboguy_> lpvb: well, Applicative is a functor that preserves the monoidal structure of the categories. A monad is itself a monoid object (in the category of endofunctors)
22:12:07 <ski> dfeuer : that's right
22:12:11 <roboguy_> preserves up to natural isomorphism iirc
22:12:31 <ski> you can e.g. easily make a class in Haskell for functors from `* -> *' to `*'
22:12:57 <shachaf> Well, * -> * isn't quite a category (neither is *)
22:13:16 <dfeuer> I don't think you can express the notion of a non-full subcategory, however.
22:13:24 <dfeuer> Which limits what you can do.
22:13:26 <shachaf> Or maybe I'm saying something unhelpful, never mind.
22:13:36 <dfeuer> And I may be talking complete nonsense!
22:13:43 <lpvb> roboguy_: I'll try to keep that in mind
22:14:01 <dfeuer> So lift2 and unit/times.
22:14:08 <dfeuer> lift0/lift2 and unit/times.
22:14:33 <shachaf> Pick whichever one seems simplest. It's pretty easy to transate back and forth (exercise: translate back and forth)
22:14:58 <shachaf> I guess the category is endofunctors : * -> * in particular, and not just any old type with kind * -> *.
22:15:03 <roboguy_> lpvb: incidentally, a monoidal category's operation, as I understand it, satisfies the monoid laws up to a natural isomorphism (rather than up to actual equality)
22:15:20 <dfeuer> shachaf, how do you get from unit/times to anything else? It doesn't seem to give you a way to make anything but F (), F ((),()), and other such boring things.
22:15:30 <shachaf> dfeuer: Oh, you still have fmap.
22:15:34 <dfeuer> Ohhhh.
22:15:59 <dfeuer> What is unit for, then?
22:16:06 <dfeuer> Hrrr.
22:16:09 <dfeuer> Must be a reason.
22:16:20 <roboguy_> it brings a value into the "context"
22:16:43 <shachaf> Figuring it out is a good exercise.
22:17:18 <dfeuer> roboguy_, if unit::F (), that can't bring any value into anything, because it's not a function.
22:17:26 <dfeuer> Unless I'm reading something all wrong.
22:17:44 <roboguy_> dfeuer: mm, I think shachaf is right about figuring it out being a good execise
22:17:48 <roboguy_> *exercise
22:17:55 <ski> shachaf : yes, i think that's right
22:17:59 <dfeuer> Ooooka.
22:18:03 <dfeuer> Will do.
22:18:09 <roboguy_> dfeuer: think about the things that you have provided to you by Functor and by Applicative
22:18:15 <dfeuer> OK.
22:18:23 <athan> list comprehension-style fold from cryptol just blew my mind
22:18:27 <roboguy_> that's how I always start when I'm doing something like this: I look at everything I have and write it down
22:18:32 <dfeuer> OHhhhhhh
22:18:34 <dfeuer> I see.
22:18:46 <dfeuer> So you use fmap to replace the () with something else.
22:18:50 <ski> yep
22:18:51 <roboguy_> yep!
22:18:56 <ski>   fmap (\() -> x) unit
22:19:07 <Krautman> Isn't that just const?
22:19:08 <ski> that's `lift0 x'
22:19:21 * ski prefers to write it explicitly
22:19:22 <Krautman> fmap const, that is ;)
22:19:32 <Krautman> Ah, I'll be quiet :3
22:19:36 <ski> (itym `fmap . const')
22:19:46 <dfeuer> itym is not a word.
22:19:52 <shachaf> I suppose class Functor f => Monoidal f where monoidal :: HList (Map f ts) -> f (HList ts)
22:20:01 <ski> it's a common abbreviation for "i take/think you mean"
22:20:01 <shachaf> Is that some sort of higher-order natural transformation?
22:20:21 * dfeuer is not common enough to understand that :P
22:20:26 <ski> shachaf : what's that ?
22:20:43 * dfeuer goes to finish the exercise.
22:21:13 <ski> shachaf : oh, i see ..
22:21:16 <shachaf> ski: liftAn
22:21:21 * ski nods
22:21:48 <ski> dfeuer : anyway, now you are :)
22:22:02 <dfeuer> Heh.
22:22:33 <brtaylor92_mac> Sorry, newbie question - I have a data Lexeme = L AlexPosn LexemeType (Maybe String). I would like to write a lexemeToString function which will simply show lexemeType, or lexemeType ++ ": " ++ str if a string is present; can anyone give me some guidance on how to accomplish this?
22:22:37 * dfeuer just realized that ski must be all about S, K, and I combinators, however those work.
22:23:26 <gratimax> dfeuer: you are able to express any computable function in terms of SKI
22:23:37 <Krautman> taylor, what about Maybe?
22:23:53 <dfeuer> Yes, I've read that. I don't understand it, but I've read it. I'm not going to try to understand it today, though.
22:24:06 <dfeuer> Applicative seems more the order of the day.
22:24:08 <roboguy_> brtaylor92_mac: you could use a case expression
22:24:14 <dfeuer> And that foldrW/buildW mess.
22:24:22 <Krautman> ...Or indeed keep it simple and do that ;)
22:24:30 <brtaylor92_mac> roboguy_: let me back up a step. I'm having trouble just writing the arguments to the function...
22:24:44 <dfeuer> Keep it simple!
22:24:46 <roboguy_> dfeuer, Krautman: well, it's interesting that we are talking about both Applicative and SKI...
22:25:01 <dfeuer> What, are they related or something?
22:25:08 <dfeuer> Jeez, I guess everything is in Haskell.
22:25:10 <roboguy_> in one case, yeah
22:25:13 <Krautman> I was talking to taylor ;)
22:26:04 <ski> dfeuer : hehe
22:26:51 <ski> in fact, `S' is `(<*>)' and `K' is `pure' (for a particular applicative functor)
22:27:08 <dfeuer> . . . .
22:28:05 <roboguy_> yep! I didn't understand SKI until I worked with that Applicative instance. then it became a lot more clear
22:28:25 <dfeuer> I guess figuring out which instance is an exercise too.
22:28:26 <shachaf> And `I` is `(<*>) pure fmap`!
22:29:18 <brtaylor92_mac> roboguy_ or Krautman, so what would the arguments to lexemeToString be?
22:29:33 <shachaf> Wait, maybe fmap doesn't work.
22:29:39 * shachaf was thinking of values and not types.
22:30:05 <roboguy_> brtaylor92_mac: hmm, I'm not totally sure what you mean. I imagine the type would be lexemeToString :: Lexeme -> String
22:30:26 <ski> dfeuer : anyway, parsing is one of the original non-trivial applications of monads
22:31:12 <dfeuer> I noticed. I just don't know much about it :/
22:32:17 <ski> the main operations are sequencing and alternative
22:32:44 <dfeuer> But there seem to be a lot of details.
22:32:59 <ski> with the monadic `do' syntactic sugar, sequencing just becomes sequencing of `do'-commands
22:33:05 <ski>   do firstParseThis
22:33:11 <ski>      thenParseThat
22:33:58 <dfeuer> And alternatives? That's where things get into backtracking and the avoidance thereof, it seems, and everything gets complicated?
22:34:09 <dfeuer> Or is my impression wrong?
22:34:12 <ski> in general, running a parser can compute some kind of resulting "semantic value", typically a parse tree (though one could in some cases "interpret" what is being parsed, as it is being parsed)
22:34:25 <ski> dfeuer : no, that's right
22:34:27 <lpvb> why are some applicative instances still implemented in terms of monads, seems backwards
22:34:47 <ski>   do x <- firstParseThis
22:34:53 <ski>      y <- thenParseThat
22:34:59 <ski>      return (x,y)
22:35:17 <ski> this can be abbreviated to
22:35:26 <ski>   liftM2 (,) firstParseThis thenParseThat
22:35:39 <mauke> do x <- some digit; return (read x)
22:35:45 <ski> and `liftA2' is the same as `liftM2' here (the previous `lift2')
22:36:06 <ski> yes, in this case we'd have something like
22:36:15 <ski>   some :: Parser a -> Parser [a]
22:36:19 <ski> so, given a parser
22:36:27 <ski>   digit :: Parser Char
22:36:35 <dfeuer> Yes.
22:36:44 <ski> which attempts to parse one character, and succeeds if it is a digit, we get
22:36:52 <splintax> lpvb: i believe the answer is 'historical reasons'; some instances of Monad are part of the prelude or standard library, whereas Applicative instances are not
22:36:53 <ski>   some digit :: Parser String
22:37:08 <ski> which presumably would attempt to parse one or more characters, all being digits
22:37:51 <ski> anyway, the above pattern with `firstParseThis',`thenParseThat' can be expressed using applicative functors
22:38:16 <ski> because the second parser `thenParseThat' doesn't depend on the parse result `x' of the first parser `firstParseThis'
22:38:45 <ski> if we modify it into
22:38:51 <ski>   do x <- firstParseThis
22:38:55 <dfeuer> So if you run  some digit on the string  "123a" I assume you get something like [([],"123a"),([1],"23a"),([1,2],"3a"),([1,2,3],a)], right?
22:38:59 <nshepperd> if the Monad instance was implemented first, it's probably easiest to just set (<*>) = ap and hope the compiler can optimize it good enough
22:39:06 <ski>      y <- thenParseThatUsing x
22:39:13 <ski>      return (x,y)
22:40:00 <dfeuer> Right.
22:40:12 <nshepperd> actually, I'm not sure how often there's any efficiency difference between `ap` and handwritten <*>. maybe there's no difference generally
22:40:16 <ski> dfeuer : more or less. `digit' itself would in the above conception doesn't convert from `Char', so you'd not get a list of numbers, but a list of `Char's, by `some digit' (so that `read' can be applied to that list)
22:41:21 <ski> anyway, in the above example, since `thenParseThatUsing x' can use `x', it could just as well incorporate `x' in the result `y', so we don't need to bundle `x' with `y' in the "final result" (of this `do'-block) passed to `return'
22:41:27 <ski> so, we could just say
22:41:27 <dfeuer> ski, ah. But parsing with read after parsing with something else seems a waste...
22:41:30 <ski>   do x <- firstParseThis
22:41:32 <ski>      y <- thenParseThatUsing x
22:41:36 <ski>      return y
22:41:44 <ski> but now a monad law says that this is equal to
22:41:46 <ski>   do x <- firstParseThis
22:41:50 <ski>      thenParseThatUsing x
22:42:14 <ski> where `thenParseThatUsing x' implicitly will yield the result `y' to whoever is wanting the result from this whole `do'-block
22:42:22 <dfeuer> Mmmhmm..
22:43:30 <ski> dfeuer : yes, and if `read' fails, the program will abort with an exception, instead of triggering backtracking in the parsing processing -- though in this case we're ensured that it won't fail, since we only give it a nonempty list of digits
22:44:05 <ski> dfeuer : anyway, the above example, via `do'-syntax desugaring, is the same as `firstParseThis >>= thenParseThatUsing', so we're down to a monadic primitive here
22:44:28 <ski> however, let's attempt to see how we could achieve something almost the same
22:44:38 <ski> let's consider
22:44:47 <ski>   do x <- firstParseThis
22:44:56 <ski>      return (thenParseThatUsing x)
22:45:14 <ski> consider
22:45:19 <ski> @src liftM
22:45:19 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
22:45:32 <ski> which says that this is the same as `liftM thenParseThatUsing firstParseThis'
22:45:44 <ski> note that this doesn't do quite the same thing
22:46:15 <ski> the previous was a parser which first parsed according to `firstParseThis', getting a result `x', then parsed according to `thenParseThatUsing x'
22:46:38 <ski> (and then yielding the same parse result as `thenParseThatUsing x' does)
22:47:36 <ski> the current is a parser that first parses according to `firstParseThis', and the immediately yields a parse result ! namely the *action* of parsing according to `thenParseThatUsing x'
22:47:42 <ski> let's make this slightly more concrete
22:47:46 <ski> let's say we have
22:47:53 <ski>   firstParseThis :: Parser X
22:48:02 <ski>   thenParseThatUsing :: X -> Parser Y
22:48:05 <ski> then we had
22:48:14 <ski>   firstParseThis >>= thenParseThatUsing :: Parser Y
22:48:18 <dfeuer> Hmmm.
22:48:22 <ski> but, with the new version, we have
22:48:33 <dfeuer> So it's a parser that parses something and produces a parser.
22:48:34 <ski>   liftM thenParseThatUsing firstParseThis :: Parser (Parser Y)
22:48:59 <ski> this is a parser that yields as parse result a *new* parser, which would yield a result of type `Y' if invoked at some later point
22:49:04 <ski> yes
22:49:13 <dfeuer> Huh.
22:49:20 <ski> to turn this into the previous, we exactly need a combinator
22:49:20 <dfeuer> What's the advantage?
22:49:30 <ski>   join :: Parser (Parser a) -> Parser a
22:49:42 <dfeuer> Uh-huh.
22:50:22 <ski> such that `join ppa' will first parse input according to `ppa', yielding a parser `pa', and then parse input according to the just computed parser `pa', yielding a result `a', that is what is yielded by the whole `join ppa' parser
22:51:04 <ski> dfeuer : in some cases, such *staging* as in `Parser (Parser Y)' could be useful -- but it's not that commonly useful -- at least not in directly this form
22:51:35 <dfeuer> OK, so presumably the real concept is that for some reason (efficiency?) this join isn't always available.
22:51:49 <ski> however, `join' makes very explicit the capability of using information computed during parsing to guide further parsing
22:52:29 <ski> namely because with `join', the information computed during parsing *is* a parser to be immediately applied to continue parsing
22:53:56 <lpvb> ski: so if I wanted to parse a string escape character which depends on the previous char being a backslash, I would need to use monads instead of applicatives?
22:53:56 <ski> dfeuer : yes. not having a `join' operation (or anything equally powerful) can make parsing more efficient (e.g. enable pre-computing "first" and "follow" sets, if we're talking about yacc-style parsing generators)
22:54:42 <dfeuer> ski, I'm getting a bit tired (it's 2AM here). When do you tend to be around? I'm finding this somewhat enlightening, and would like to learn enough more to actually get going doing things like using those fancy combinator libraries....
22:54:53 <dfeuer> [and understanding their documentation, etc.]
22:55:04 <ski> dfeuer : anyway, `return' and `(>>=)' are the monadic primitives of the `Monad' class. however, one could equally well replace `(>>=)' with `join' (and the `fmap'/`liftA'/`liftM' operation). in that case `(>>=)' is definable in terms of the other operations
22:55:34 <dfeuer> Yes.
22:55:40 <dfeuer> I understand that fact, pretty much.
22:56:07 <ski> however, it can be a bit easier to get a conceptual grip on `join' than on `(>>=)', though the latter tends to be somewhat more performant in practice
22:56:13 <ski> if you consider
22:56:22 <ski>   join :: M (M a) -> M a
22:56:49 <ski> though you could roughly think of the first `M' as happening at "compile-time", and the second as happening as "run-time"
22:56:54 <dfeuer> But then things come to alternatives and backtracking and stuff without backtracking, and I get very lost....
22:57:08 <ski> and `join' then claims that we can smash those two together into one "time"
22:57:26 <dfeuer> Yah.
22:57:48 <ski> (in some vague sense, it says that we may have to do some "compilation" at run-time)
22:58:43 <ski> dfeuer : i suppose you haven't really played anything with logic programming such as Prolog, Kanren (or mini-Kanren, see "The Reasoned Schemer"), Mercury, or Oz ?
23:00:21 <ski> dfeuer : hm, i suppose i don't tend to be around at this time :)
23:00:56 <ski> (more commonly on the other half of the circadian rhythm)
23:01:27 <dfeuer> All right, I'm back, but not for long, probably.
23:01:46 <dfeuer> No, ski, I've never played with logic programming.
23:01:53 <ski> ok. too bad
23:02:12 <ski> it commonly uses backtracking
23:02:41 <ski> have you tried reading any of the original parsing combinator papers for Haskell ?
23:02:55 <dfeuer> Yes, I think I have.
23:03:16 <dfeuer> It's been some years since I made that attempt though.
23:03:20 <dfeuer> I'd probably understand better now.
23:03:35 <dfeuer> But then again, the actual libraries seem to be more complicated than those old papers.
23:05:40 <ski> "Monadic parsing in Haskell" by Graham Hutton,Erik Meijer in 1998-07 at <http://www.cs.nott.ac.uk/~gmh/bib.html#pearl>
23:06:45 <dfeuer> Long reading list.
23:07:00 <dfeuer> I'll have a look!
23:07:09 <ski> yes, Parsec uses an asymmetric committed choice operator (greedily committing to the first alternative that succeeds) for performance reasons, but it makes it harder to reason about and construct parsers
23:07:34 <ski> that paper is eight pages
23:07:57 <dfeuer> ski, does it have both asymmetric and symmetric, or just asymmetric?
23:08:32 <ski> you can express the symmetric one, but then you may lose performance gains in some cases
23:08:38 <dfeuer> *nod*
23:24:47 * hackagebot hspec-wai 0.4.0 - Experimental Hspec support for testing WAI applications (depends on hspec2!)  http://hackage.haskell.org/package/hspec-wai-0.4.0 (SimonHengel)
23:34:25 <Rugal> dfeuer, haha
23:35:03 <Rugal> You have to be stoned in order to understand Haskell
23:35:22 <Rugal> Right? Anyone? Anyone?
23:35:23 <Rugal> :)
23:35:40 <Krautman> Rugal
23:35:42 <Krautman> Agreed.
23:35:48 <Krautman> Though I'm not a stoner ;)
23:35:56 <Krautman> Haskell will do worse thoings to you
23:35:59 <Krautman> things*
23:36:01 <Rugal> No
23:36:09 <Rugal> It's just a language.
23:36:25 <Rugal> A lack of a deeper understanding of which will do terrible things to you.
23:36:44 <Rugal> You must quantify exactly that which will affect your cognitive deliverance.
23:37:24 <Rugal> And incidentally mates, I'm always stoned. Always. At all times. In every moment. In every second. Carry on.
23:37:34 <Krautman> You clearly haven't seen me react to a Haskell epiphany ;)
23:37:40 <Rugal> Hahaha
23:37:55 <Rugal> I barely understand this and the functional paradigm myself.
23:38:23 <Rugal> Struggling very hard. Frankly, various Cannabii give me the patience to sit there and read w/o losing it.
23:39:03 <Krautman> Well, if at any point you need advice, there's a good 1500 of us eager to help out
23:39:14 <nshepperd> so I was wonderng the other day what is the minimal X such that Applicative + X = Monad
23:39:29 <joelteon> >>=
23:39:32 <Rugal> I appreciate that very much. I try not to bother people w/ questions I can have myself answered by searching just a bit.
23:39:43 <nshepperd> no, I want more minimal than that!
23:39:47 <Krautman> That's a good stance ;)
23:40:03 <Rugal> I am only speaking here b/c I was highighted, otherwise I'd not be wasting useful channel buffer space w/ my shennanigans.
23:40:24 <Rugal> Carry on :)
23:40:25 <nshepperd> for example, I have figured out that you can make Applicative from Functor + (pure :: a -> f a) + (paste :: f a -> f b -> f (a,b))
23:40:53 <pharaun> Is it possible to override the MonadPlus instance already defined for Maybe ?
23:40:55 <Krautman> Well, I'm doing the exact same thing. I'd hardly consider myself worthy of channel buffer space, but I'm just a twat like that ;)
23:41:01 <nshepperd> such that you can't derive 'fmap' from 'pure' and 'paste' alone
23:41:05 <joelteon> okay...so Monad is Applicative plus >>=
23:41:10 <joelteon> I don't understand the problem
23:42:09 <nshepperd> joelteon: well, you can derive <*> from fmap and pure and >>=
23:42:19 <joelteon> okay
23:42:24 <joelteon> so?
23:43:01 <nshepperd> I'm interested if there's possibly an operator foo such that fmap, pure, paste, foo are all "independent"
23:43:16 <joelteon> what does that mean?
23:43:17 <nshepperd> in that none can be written in terms of the other three
23:43:20 <joelteon> why?
23:43:26 <joelteon> you can write fmap with pure and <*>
23:43:31 <nshepperd> curiosity
23:43:45 <joelteon> okay, well no, you can't
23:44:19 <nshepperd> the action of fmap is that same as (<*>) . pure, yeah
23:44:29 <joelteon> :t (<*>) . pure
23:44:31 <lambdabot> Applicative f => (a -> b) -> f a -> f b
23:46:58 <lericson_> what is a functor?
23:47:15 <c_wraith> lericson_: a very general abstraction
23:47:17 <nshepperd> which is why I invented (paste :: f a -> f b -> f (a,b)). you can write <*> in terms of 'fmap', 'pure' and 'paste', but you can't write fmap in terms of 'pure' and 'paste'. in that sense 'paste' is more "basic"
23:47:54 <nshepperd> which makes me wonder if there's an analogous basic operator that turns Functor + Applicative into Monad
23:48:36 <lericson_> @source Functor
23:48:36 <lambdabot> Unknown command, try @list
23:48:41 <lericson_> @list
23:48:42 <lambdabot> What module?  Try @listmodules for some ideas.
23:48:45 <lericson_> ...
23:48:55 <nshepperd> @src Functor
23:48:55 <lambdabot> class  Functor f  where
23:48:55 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
23:49:11 <lericson_> very interesting
23:49:53 <lericson_> i wish i understood what that means properly
23:50:06 <lericson_> f a is the application of f to a?
23:50:19 <dv-> > fmap (+ 1) (Just 2)
23:50:20 <lambdabot>  Just 3
23:50:26 <Cale> lericson_: Yes
23:50:57 <Cale> lericson_: f is a sort of type-level function, such as Maybe or IO or the brackets which go around a type to make the type of lists of elements of that type
23:51:58 <lericson_> so in your example the Functor is Maybe?
23:52:08 <Cale> yeah, in dv-'s example
23:52:14 <lericson_> oh yes sorry
23:52:21 <Cale> > fmap (* 10) [1,2,3]
23:52:23 <lambdabot>  [10,20,30]
23:52:33 <Cale> There's an example with lists
23:52:59 <lericson_> learning haskell is a lot like this http://d3819ii77zvwic.cloudfront.net/wp-content/uploads/2014/07/ik49VlPshlPIz.gif
23:53:34 <lericson_> wait how does that what
23:54:05 <Cale> That's with f a = [a]
23:54:25 <Cale> So fmap's type specialises to (a -> b) -> [a] -> [b]
23:54:31 <Cale> which is the same as the type of map
23:54:55 <mauke> you can even write [] a for [a]
23:55:00 <mauke> making f = []
