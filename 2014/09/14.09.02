00:18:11 <merijn> hmm, are all the ICFP nerds awake and on IRC yet? :p
00:20:03 <AfC> merijn: conference keynote. So, no, we're not :)
00:20:10 <merijn> :(
00:20:51 <merijn> Since no one wanted to pay for me to be there, I need someone to, like, corner Conor McBride or some other smart FP cookie and get them to figure out how I can fake sigma types in haskell :)
00:21:30 <merijn> Preferably something more efficient than using HList...
00:21:53 <shachaf> you can't hth
00:22:06 <merijn> :(
00:23:02 <merijn> What's hth?
00:23:24 <shachaf> hope that helps
00:23:34 <merijn> Well, not really ;)
00:23:38 <shachaf> Well, you can fake specific cases. Maybe that's what the word "fake" means, on the other hand.
00:23:46 <merijn> I don't think I need actual sigma types
00:25:23 <merijn> I'd be ok with the ability to have a function "proxy a b -> Foo b" that's restricted to some combinations of 'a' and 'b' where Foo is a type family
00:26:22 <merijn> Actually, I can already write that, but I'm not getting the exhaustiveness checks right, since GHC is inferring missing patterns that can never occur :\
00:29:03 <funfunctor> anyone know haskeline wellish? I would like to get completeFilename :: MonadIO m => CompletionFunc m  but with coloured output depending on filetype
00:29:13 <funfunctor> in my REPL
00:29:48 <bluebelle> How do you test .Internal modules?
00:30:07 <bluebelle> The .cabal config, I mean
00:30:29 <shachaf> You can export them from the package, or you can import the modules directly.
00:32:04 <bluebelle> shachaf : Now it is listed on other-modules, so when I ran cabal test (I use separate dir for testing) it cannot find the module
00:32:59 <Sensored> i can't seem to install Shake
00:33:15 <Sensored> i get this error message when installing it through cabal:
00:33:17 <Sensored> Development/Shake/FileInfo.hs:69:41: Not in scope: `hash'
00:33:19 <Sensored> Failed to install shake-0.13.2
00:37:25 <aleator> Has anyone recently seen cabal error "setup: snippet.hs doesn't exist"? I have a project that builds if I clean the sandbox but any furhter install fails with this.
00:41:33 <merijn> Hmm, type families cannot take other type families as arguments?
00:42:07 <makalu> does anyone know of a very primitive http server for serving static websites? Minimal dependencies, doesn't need to be fast at all. Something like SimpleHTTPServer in Python.
00:43:05 <aleator> makalu: SimpleHTTPServer in Python? :)
00:43:22 <makalu> thanks :)
00:43:58 <Sensored> haha
00:44:01 <Sensored> whyn ot try Scotty
00:45:34 <makalu> I have used Scotty, it's great, but overkill at the moment because of the dependencies
00:45:57 <merijn> makalu: Hakyll + an actual webserver?
00:49:05 <merijn> Whooo!
00:49:31 <makalu> http://hackage.haskell.org/package/http-server this seems interesting
00:49:39 <Sensored> does Hakyll work with github pages?
00:50:12 <unsymbol> in ruby you can achieve the same with: ruby -run -e httpd . -p 9090
00:50:16 <unsymbol> (sorry. hehe.)
00:50:38 <lpaste> merijn pasted “Realy confusing error with {-# LANGUAGE KitchenSink #-]{” at http://lpaste.net/110401
00:50:49 <merijn> Really confusing type error, who wants to help?
00:50:51 <merijn> :)
00:51:30 <Sensored> [17 of 41] Compiling Development.Shake.FileInfo ( Development/Shake/FileInfo.hs, dist/build/Development/Shake/FileInfo.o )
00:51:31 <Sensored> Development/Shake/FileInfo.hs:69:41: Not in scope: `hash'
00:51:33 <Sensored> Failed to install shake-0.13.2
00:51:35 <Sensored> any help?
00:52:17 <merijn> Sensored: hakyll works with github pages, since it just produces static html and github can serve static html :)
00:52:27 <merijn> Sensored: You'll need to build locally, though
00:52:49 <merijn> Sensored: Sounds like a version bounds error in shake where it tries to compile using a package that's to old so that API doesn't match?
00:53:01 <merijn> Sensored: You'll have to figure out where it's importing "hash" from
00:53:03 <makalu> this is nice and basic http://hackage.haskell.org/package/httpd-shed
00:53:51 <Sensored> hmm
01:04:52 <Sensored> The IO module exports a convenience function called try that executes an I/O action and returns Right result if the action succeeded or Left IOError if an I/O error was caught.
01:04:58 <Sensored> why has no guide ever talked about this
01:05:00 <Sensored> this is killer
01:06:05 <merijn> Sensored: Control.Exception has a whole bunch of stuff for throwing and handling exceptions
01:06:09 <cmears> Sensored, I think it has been covered here: http://book.realworldhaskell.org/read/error-handling.html
01:06:27 <merijn> Sensored: The only one to avoid is "throw", you should alway use throwIO instead if you want reliable exceptions
01:07:11 <Sensored> ah, so it has.
01:07:15 <Sensored> i should read this book again
01:07:17 <Sensored> ty guys
01:08:53 <sjoerd_visscher> Does anybody know why Hackage sometimes doesn't build a package? f.e. http://hackage.haskell.org/package/one-liner-0.5/reports/
01:09:18 <merijn> sjoerd_visscher: Usually it's either 1) batch process hasn't run yet or 2) build failure
01:09:38 <merijn> sjoerd_visscher: See http://fuuzetsu.co.uk/blog/posts/2014-01-06-Fix-your-Hackage-documentation.html to find out how to 1) check the build log or 2) manually upload docs
01:09:54 <sjoerd_visscher> merijn: it is neither, there are no build logs
01:10:13 <merijn> sjoerd_visscher: Then the batch build process hasn't build yet
01:10:25 <sjoerd_visscher> http://hackage.haskell.org/package/one-liner-0.4.1 is on there for 2 weeks
01:10:29 <merijn> I'd guess?
01:10:32 <sjoerd_visscher> and has not builds either
01:10:43 <merijn> sjoerd_visscher: Might wanna try #hackage?
01:10:52 <sjoerd_visscher> ah, thanks!
01:10:53 <merijn> I've mostly given up and just manually build + upload docs
01:11:09 <merijn> sjoerd_visscher: Works just fine with the instructions of Fuuzetsu
01:11:35 <sjoerd_visscher> merijn: I'm worried something is wrong with my package
01:11:54 <merijn> sjoerd_visscher: Lots of stuff doesn't build since the migration
01:12:03 <merijn> I dunno which GHC hackage is running, for example
01:21:17 <funfunctor> any idea's how to go about designing a internal man page system for a REPL? I was thinking about storing the docs in JSON format perhaps?
01:28:51 <lattenwald> Hi. I can compose applicative functors with <*> like \x -> f <*> (g <*> x)
01:29:00 <lattenwald> how can I write it in point-free style?
01:29:28 <lattenwald> something like f . g for functions
01:30:33 <Sensored> you can maybe use <*> not in infix
01:30:38 <lattenwald> hoogling for f (a -> b) -> f (b -> c) -> f (a -> c) did not yield good results
01:30:50 <lattenwald> hm
01:31:17 <lattenwald> I did let f = Just ((/2) . fromIntegral); g = Just show
01:31:26 <lattenwald> and f <*> g does not typecheck
01:31:40 <lattenwald> or I don't understand what do you mean
01:32:08 <lattenwald> g <*> f that is, does not typecheck
01:32:28 <Sensored> i'm not a very good haskeller myself, but letts see
01:32:51 <Sensored> \x -> f <*> (g <*> x ) can be written as
01:33:06 <Sensored> \x -> f <*> ( (<*>) g x )
01:33:29 <Sensored> and then maybe \x -> (<*>) f ( (<*>) g x )
01:34:01 <Sensored> :t (.)
01:34:02 <lambdabot> (b -> c) -> (a -> b) -> a -> c
01:34:23 <lattenwald> ((<*>) f) . ((<*>) g)
01:34:27 <lattenwald> hm, one moment :)
01:34:35 <Sensored> hmm is that right?
01:34:41 <lattenwald> checking
01:35:41 <Sensored> that makes sense to me
01:35:46 <Sensored> kinda confusing to parse in my head though heh
01:35:59 <lattenwald> yeah, thanks
01:36:21 <lattenwald> let f = Just ((/2) . fromIntegral); g = Just show in (((<*>) g) . ((<*>) f)) (pure 5)
01:36:24 <lattenwald> works
01:36:39 <lattenwald> (how do you make lambdabot to execute it?)
01:37:46 <BoR0> @pl \x -> f <*> (g <*> x)
01:37:46 <lambdabot> (f <*>) . (g <*>)
01:38:08 <lattenwald> ... thanks :)
01:38:17 <BoR0> > Just (+3) <*> Just 5
01:38:19 <lambdabot>  Just 8
01:38:28 <lattenwald> > let f = Just ((/2) . fromIntegral); g = Just show in (((<*>) g) . ((<*>) f)) (pure 5)
01:38:29 <lambdabot>  Just "2.5"
01:39:21 <jle`> if you're going to use it prefix and if you're doing it with something that is an instance of Monad, you can use the "prefix form" of (<*>), `ap`
01:39:52 <jle`> in some types though (<*>) will be operationally different from ap, though, despite producing the same result.
01:40:13 <jle`> :t (f <*>) . (g <*>)
01:40:14 <lambdabot> (FromExpr (f (a1 -> a)), FromExpr (f (a -> b)), Applicative f) => f a1 -> f b
01:40:17 <jle`> oops
01:40:21 <jle`> :t \f g -> (f <*>) . (g <*>)
01:40:22 <lambdabot> Applicative f => f (a -> b) -> f (a1 -> a) -> f a1 -> f b
01:40:30 <jle`> :t \f g -> ap f . ap g
01:40:31 <lambdabot> Monad m => m (a -> b) -> m (a1 -> a) -> m a1 -> m b
01:41:15 <lattenwald> I am going to use it with attoparsec Parser
01:42:13 <jle`> from what little i know about attoparsec, i don't think (<*>) and ap are different
01:42:31 <jle`> hm
01:42:35 <jle`> (<*>) might be a bit more efficient
01:45:39 <jle`> :t join `asAppliedTo` Nothing
01:45:40 <lambdabot> Maybe (Maybe a) -> Maybe a
01:45:50 <jle`> wait nvm
01:46:17 <lattenwald> I am happy with (f <*>) . (g <*>) for now :) thanks!
01:51:19 <jle`> np :)
01:55:21 <Sensored> :t join `asAppliedTo` Nothing
01:55:22 <lambdabot> Maybe (Maybe a) -> Maybe a
01:55:25 <Sensored> :t join $ join `asAppliedTo` Nothing
01:55:26 <lambdabot>     Precedence parsing error
01:55:26 <lambdabot>         cannot mix ‘$’ [infixr 0] and ‘asAppliedTo’ [infixl 0] in the same infix expression
01:56:25 <hyPiRion> :t (join . join) `asAppliedTo` Nothing
01:56:27 <lambdabot> Maybe (Maybe (Maybe a)) -> Maybe a
01:57:23 <jle`> :t (join.join) `asAppliedTo` []
01:57:24 <lambdabot> [[[a]]] -> [a]
01:57:53 <Sensored> why does that work?
01:57:57 <Sensored> and not my $
01:58:11 <Sensored> oh
01:58:13 <Sensored> heh
01:58:15 <Sensored> didnt read the error msg.
01:58:17 <Sensored> ~_~
01:58:44 <jle`> :t join (join `asAppliedTo` Nothing)
01:58:45 <lambdabot>     Couldn't match type ‘Maybe (Maybe a1) -> a’ with ‘Maybe a1’
01:58:45 <lambdabot>     Expected type: Maybe (Maybe a1) -> Maybe (Maybe a1) -> a
01:58:45 <lambdabot>       Actual type: Maybe (Maybe a1) -> Maybe a1
01:59:03 <Sensored> wtf
02:01:37 <Sensored> > [1..]
02:01:39 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
02:01:50 * hackagebot monad-journal 0.2.3.2 - Pure logger typeclass and monad transformer  http://hackage.haskell.org/package/monad-journal-0.2.3.2 (DimitriSabadie)
02:02:50 <Sensored> > show _
02:02:52 <lambdabot>  Found hole ‘_’ with type: a0
02:02:52 <lambdabot>  Where: ‘a0’ is an ambiguous type variable
02:02:59 <Sensored> > show it
02:03:01 <lambdabot>  Not in scope: ‘it’
02:03:01 <lambdabot>  Perhaps you meant one of these:
02:03:01 <lambdabot>    ‘id’ (imported from Data.Function),
02:03:01 <lambdabot>    ‘C.id’ (imported from Control.Category),
02:03:01 <lambdabot>    ‘i’ (imported from Debug.SimpleReflect)
02:05:32 <funfunctor> anyone used the highlighter package yet?
02:21:52 * hackagebot hindent 2.1 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-2.1 (ChrisDone)
02:23:48 <kuribas> Is it better to use ExceptT in the IO monad or exceptions?
02:24:54 <luite_> kuribas: there is no definitive answer to that
02:25:20 <luite_> kuribas: ExceptT is strictly less powerful than exceptions
02:25:41 <kuribas> I would think that IO exceptions are more efficient.
02:26:14 <luite_> kuribas: they are, they don't have overhead in bind, only when thrown/caught
02:26:43 <kuribas> ok, I think I'll go for IO exceptions.  It'll make my transformer stack cleaner.
02:42:11 <kuribas> So I have eliminated state (using IORef) and errors (using exceptions).  It seems I cannot make this any simpler: type MetaAction a = ReaderT (IORef GlobalState) IO
02:45:07 <luite_> kuribas: hmm, that IORef does raise some concerns about forkIO etc
02:47:12 <kuribas> Doesn't a IORef work with threads?
02:48:38 <kuribas> Although I may not need threads.  I am implementing the metafont language, which doesn't support parallelism.
02:50:07 <kuribas> The metafont language model is very imperative, you can even change the syntax of the language at runtime.
02:50:58 <Sensored> the state monad is a real trip
02:55:08 <jle`> Sensored: do you mean the State type, or its Monad instance?
02:59:19 <kuribas> Sensored: The state monad can be handy sometimes.
03:00:24 <Sensored> i mean both
03:00:38 <Sensored> i'm learning about monads right now
03:00:44 <Sensored> i understand them in some contexts
03:00:47 <Sensored> like Either and Maybe
03:00:54 <Sensored> State is confusing me a bit
03:03:24 <kuribas> State is very simple.  You are just threading the state through each function.  The State monad just hides the machinery.
03:04:10 <Sensored> i understand that
03:04:14 <Sensored> i'm trying to understand the machinery though
03:04:42 <kuribas> Sensored: What does State have to do with Either and Maybe?
03:04:58 <Sensored> nothing apart from the fact that they're all monads
03:05:46 <kuribas> yes
03:05:57 <Sensored> =P
03:06:30 <kuribas> You can represent state simply as a tuple (state, result), where result is the result from the computation.
03:06:45 <Sensored> :i State
03:06:58 * hackagebot lvmlib 1.1 - The Lazy Virtual Machine (LVM).  http://hackage.haskell.org/package/lvmlib-1.1 (JurriaanHage)
03:07:00 * hackagebot helium 1.8 - The Helium Compiler.  http://hackage.haskell.org/package/helium-1.8 (JurriaanHage)
03:07:01 <Sensored> @info State
03:07:02 <lambdabot> State
03:07:11 <Sensored> lol, what.
03:08:08 <Sensored> newtype State s a = State { runState :: s -> (a, s) }
03:08:18 <average> I'm really not a fan of Java, but Eclipse has these really nice warnings while I write the code
03:08:21 <Sensored> so thats a State
03:08:23 <average> can I get that in Haskell too somehow ?
03:08:32 <Sensored> average what IDE do you use
03:08:49 <Sensored> in vim i'm using syntastic and it does that
03:08:50 <average> I usually use Vim. For example for Java I use Vim + Eclim (which in turn uses Eclipse)
03:08:59 <average> Sensored: it does that ? that's really cool
03:08:59 <Sensored> for many more languages i might add
03:09:01 <Sensored> not just hs
03:09:05 <Sensored> yeah. it hilights the lines
03:09:07 <average> sweet
03:09:09 <Sensored> and lets me skip between then
03:09:18 <Sensored> i just discovered it like a day ago too
03:09:27 <Sensored> wondering about the same question you had :P
03:09:43 <Sensored> why did we call the field instide the State 'runState'
03:09:51 <Sensored> runState will have the type
03:10:02 <Sensored> runState :: State s a -> s -> (a, s)
03:10:03 <Sensored> yes?
03:10:23 <jle`> so: my suggestion is that "learning monads" is not a very meaningful or useful thing to do :)
03:10:27 <jle`> Sensored: ^^
03:10:29 <Sensored> why is this not getStateFunctionWrappedThingy
03:10:37 <kuribas> Sensored: yes, so you can run the state by unwrapping it.
03:10:48 <jle`> Sensored: i call that a neat trick/abuse
03:10:57 <jle`> look at the Endo newtype
03:11:06 <jle`> data Endo a = Endo { appEndo :: a -> a }
03:11:14 <jle`> Endo a just contains an (a -> a)
03:11:14 <Sensored> what the fuck
03:11:18 <average> how useful is learning category theory in order to ease things while doing Haskell ?
03:11:18 <Sensored> why is that useful
03:11:22 <average> is it actually useful ?
03:11:22 <jle`> average: not very useful :)
03:11:25 <average> jle`: ok
03:11:33 <average> then why do people talk about category theory ?
03:11:37 <average> was it just a fad
03:11:38 <jle`> average: because it's fun :)
03:11:46 <average> jle`: a lot of math is fun
03:11:50 <jle`> Sensored: well, appEndo is short for "applyEndo"
03:11:59 * hackagebot data-category 0.6.1 - Category theory  http://hackage.haskell.org/package/data-category-0.6.1 (SjoerdVisscher)
03:12:01 <average> but what I'm asking is if Category theory somehow applies to basic/medium Haskell
03:12:02 <jle`> so if you had an endo, say... plus3 = Endo (+ 3)
03:12:15 <Sensored> ooh
03:12:15 <jle`> > let plus3 = Endo (+ 3) in appEndo plus3 5
03:12:17 <lambdabot>  8
03:12:19 <Sensored> so then
03:12:21 <Sensored> -
03:12:23 <Sensored> yeah
03:12:30 <jle`> basically it's saying "apply plus3 to 5"
03:12:33 <jle`> it's a...cute trick
03:12:37 <Sensored> so you unwrap the endo
03:12:38 <jle`> to play with "english-like" things :)
03:12:39 <Sensored> to get a function
03:12:43 <Sensored> then go run that function on stuff
03:12:52 <Sensored> and we can cleverly name that appEndo
03:12:53 <Sensored> i see
03:12:55 <jle`> people like to set things up so that they can pretend they are speaking english when they code
03:13:03 <jle`> average: i would say...minimally.
03:13:16 <Sensored> runState is the same thing?
03:13:24 <Sensored> that function inside the State is going to get 'run' ?
03:13:39 <Sensored> s -> (a, s)
03:14:01 <Sensored> this is a function that takes in a state, does something with it, the returns a tuple of (some value, new state) ?
03:14:02 <kuribas> Sensored: Yes, you feed it state, and it returns the state and the answer
03:14:05 <jle`> average: i think category theory has primarily caught on as some fun for the mind...i think, in practice, CT is used to help guide the search for new abstractions and frameworks and stuff.  but to the everday haskell programmer, it's mostly just for fun and understanding fun things better :)
03:14:17 <jle`> Sensored: yes, it's a similar english trick
03:14:22 <Sensored> kk
03:14:34 <jle`> > let myState = state (\x -> (x, x+3)) in runState myState 5
03:14:36 <lambdabot>  (5,8)
03:14:45 <jle`> "run 'myState' with 5"
03:14:46 <average> so basically I don't need category theory at all
03:14:52 <jle`> average: nope
03:14:53 <average> I can study it separately
03:14:56 <Sensored> ahhh
03:14:59 <jle`> yup
03:15:01 <kuribas> Sensored: Think of it this way, every stateful "action" takes a state, and returns some result together with the state.  The state may have changed or not.
03:15:14 <Sensored> makes sense
03:15:15 <average> I'm just saying, I think it's kinda disingenous to throw fancy maths in the face of some Haskell newb
03:15:19 <jle`> Sensored: yeah, it's a silly english trick, but it pops up a lot in the common libraries
03:15:31 <jle`> average: i agree :)  but what is fancy?
03:15:45 <jle`> Sensored: much of them in Data.Monoid
03:15:46 <average> jle`: well that's something that's decided on a case-by-case basis
03:15:55 <kuribas> Sensored: So if you "return" a value, you just copy the state.
03:16:10 <jle`> > let myFirst = First (Just 5) in getFirst myFirst
03:16:12 <lambdabot>  Just 5
03:16:20 <jle`> > let mySum = Sum 5 in getSum mySum
03:16:22 <lambdabot>  5
03:16:24 <Sensored> so return = State $ \s -> (s, s) ?
03:16:31 <Sensored> for instance Monad (State s)
03:16:35 <jle`> Sensored: that has the wrong type :)
03:16:46 <kuribas> no "return v = State $ \s -> (s, v)"
03:16:46 <jle`> :t return
03:16:47 <Sensored> err
03:16:47 <lambdabot> Monad m => a -> m a
03:16:49 <average> jle`: what if someone told you  that in order to write Pascal you have to know Elliptical Modular Curves ?
03:16:54 <jle`> "fill in the blanks"
03:17:01 <Sensored> return s = State $ \s -> (s,s)?
03:17:05 <jle`> if it's a -> m a, and m ~ (State s), then...
03:17:07 <Sensored> oh hm what.
03:17:10 <jle`> it's a -> State s a
03:17:15 <kuribas> Sensored: "return v = State $ \s -> (s, v)"
03:17:20 <jle`> or, with less confusion, a -> (State s) a
03:17:23 <Sensored> what is 'v'
03:17:24 <average> and it turned out, that after you've asked some other people, they told you "No dude, you can just learn Pascal"
03:17:40 <Sensored> > runState (return 5) 1
03:17:41 <lambdabot>  (5,1)
03:17:47 <jle`> average: of course, i am not too happy with people throwing complex and unecessary math in newbies' faces when introducing them to haskell :)
03:18:08 <shachaf> You might want to take the conversation about State to #haskell-overflow
03:18:12 <Sensored> is 5 the value and 1 is the state?
03:18:22 <average> shachaf: it's ok, the subject is over
03:18:32 <shachaf> What?
03:18:44 <kuribas> Sensored: I got the order reversed.
03:19:07 <kuribas> Sensored: So yes.
03:19:27 <Sensored> so the state just passed through the computation here
03:19:33 <Sensored> the 1 just stepped through it
03:20:04 <kuribas> yes
03:20:07 <Sensored> > runState (State $ \s -> (s, s)) 99
03:20:09 <lambdabot>  Not in scope: data constructor ‘State’
03:20:09 <lambdabot>  Perhaps you meant ‘StateT’ (imported from Control.Monad.State)
03:20:31 <shachaf> average: I was talking to Sensored, not to you.
03:20:34 <ski> > runState (state (\s -> (s, s))) 99
03:20:36 <lambdabot>  (99,99)
03:20:38 <edlinde> I did: *Main> takeWhile odd [1,2,3,4,5]
03:20:39 <edlinde> [1]
03:20:41 <kuribas> Sensored: So if you want to read the state, you put the state in the value slot.
03:20:44 <edlinde> but when I do:
03:20:55 <edlinde> head takeWhile odd [1,2,3,4,5]
03:20:57 <edlinde> I get an error
03:21:01 <kuribas> Sensored: gets = State $ \s -> (s, s)
03:21:06 <Sensored> edlinde: try
03:21:10 <augur> > head (takeWhile odd [1,2,3,4,5])
03:21:11 <lambdabot>  1
03:21:13 <Sensored> > head $ takeWhile odd [1, 2, 3, 4 ,5]
03:21:14 <shachaf> edlinde: a b c d means (((a b) c) d)
03:21:16 <lambdabot>  1
03:21:24 <kuribas> > runState (get) 2
03:21:25 <jle`> edlinde: that is parsed as ((head takeWhile) odd) [1,2,3,4,5]
03:21:27 <lambdabot>  (2,2)
03:21:29 <shachaf> No, $ is for advanced users. Try parentheses.
03:21:33 <jle`> or (head takeWhile) odd [1,2,3,4,5]
03:21:38 <shachaf> head (takeWhile odd [1,2,3,4,5])
03:21:52 <edlinde> ok
03:21:58 <Sensored> :t state
03:21:59 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
03:22:05 <kuribas> Sensored: And put ignores the state it gets, and put you own value in.
03:22:15 <kuribas> > runState (put 5) 3
03:22:17 <lambdabot>  ((),5)
03:22:25 <jle`> Sensored: state is the same as your State constructor
03:22:35 <Sensored> where did the State constructor go
03:22:46 <jle`> it got abstracted away
03:22:53 <Sensored> w..hat
03:23:00 <jle`> best not to worry about it for now ;)
03:23:03 <Sensored> newtype State s a = State { runState :: s -> (a, s) }
03:23:05 <Sensored> ^^^
03:23:10 <Sensored> constructor plz haskell
03:23:26 <jle`> it's different in the current version of mtl/transformers, and in the version that lambdabot has loaded
03:23:32 <Sensored> does this involve transformers?
03:23:34 <Sensored> yeah i thought so
03:23:40 <Sensored> not sure what those are yet however
03:23:41 <jle`> transformers, the library, yes
03:23:41 <Sensored> :P
03:23:45 <jle`> so don't worry about it
03:23:48 <jle`> :)
03:24:03 <Sensored> :t >>=
03:24:04 <lambdabot> parse error on input ‘>>=’
03:24:06 <Sensored> :t (>>=)
03:24:07 <lambdabot> Monad m => m a -> (a -> m b) -> m b
03:24:13 <shachaf> Sensored: I recommend #haskell-overflow for this conversation again.
03:24:23 <kuribas> Sensored: you know why the result of put has a tuple?
03:24:38 <Sensored> shachaf: why? what is that channel for
03:24:58 <shachaf> It's for long conversations that are either getting drowned out in or drowning out #haskell.
03:25:07 <Sensored> kuribas: im thinking perhaps it put it there
03:25:19 <Sensored> but i cant think of how
03:25:42 <shachaf> Since this conversation has been going on for 25 minutes, that would be a better place for it.
03:25:55 <kuribas> Sensored: ok, let's go to #haskell-overflow
03:25:57 <Sensored> ok
03:26:11 <shachaf> Thanks.
03:27:03 <average> silicon valley programmers getting drugged out of their minds http://developers.slashdot.org/story/14/07/28/0441210/suddenly-visible-illicit-drugs-as-part-of-silicon-valley-culture
03:27:53 <shachaf> average: Not in #haskell, please.
03:37:02 * hackagebot http-test 0.2.3 - Test framework for HTTP APIs  http://hackage.haskell.org/package/http-test-0.2.3 (glutamate)
03:37:20 <edlinde> can someone show me how I can use the Haskell compiler here?
03:37:52 <edlinde> like the lambdabot giving results of haskell statements
03:39:59 <silver> > like that
03:40:00 <lambdabot>  Not in scope: ‘like’Not in scope: ‘that’
03:40:19 <edlinde> > 1+2
03:40:20 <lambdabot>  3
03:40:33 <silver> but be sure to use it in private query, so rest of us won't be notified of your activities :D
03:40:52 <edlinde> > takeWhile odd [1,2,3,4,5]
03:40:53 <lambdabot>  [1]
03:40:58 <edlinde> so I get why I get this
03:41:02 <edlinde> yeah silver got that :)
03:41:13 <edlinde> > takeWhile even [1,2,3,4,5]
03:41:16 <lambdabot>  []
03:41:21 <edlinde> why is that an empty list?
03:41:32 <osfameron> edlinde: the first entry isn't even
03:41:35 <silver> > even 1
03:41:38 <lambdabot>  False
03:41:40 <augur> edlinde: takeWhile takes the initial part of the list that satisfies the predicate
03:41:43 <edlinde> ah right
03:41:50 <edlinde> grrr
03:41:52 <augur> edlinde: so it stops taking elements when it hits a failing element
03:41:52 <edlinde> sorry
03:41:59 <augur> edlinde: what are you trying to do?
03:42:12 <edlinde> ah nothing just messing with takeWhile on ghci
03:42:25 <augur> compare to filter, btw.
03:42:29 <augur> >filter even [1,2,3,4,5]
03:42:31 <edlinde> I was trying to understand if its more efficient to use takeWhile or do a filter on an infinite list
03:42:36 <augur> > filter even [1,2,3,4,5]
03:42:38 <lambdabot>  [2,4]
03:42:38 <edlinde> augur: exactly
03:42:55 <augur> efficiency isnt a question here
03:43:05 <augur> they mean different things, so you cant substitute them
03:43:11 <edlinde> ok
03:43:18 <augur> you need to use the one that means what you intend!
03:43:42 <edlinde> well there are many ways of expressing the same problem too
03:43:56 <augur> yes
03:43:58 <edlinde> so I was thinking of a way to do it so that its probably faster to process
03:44:08 <edlinde> but I understand that we have lazy evaluation
03:44:13 <edlinde> so its ok anyway
03:44:18 <augur> lazy evaluation makes it easy to filter an infinite list :)
03:44:22 <edlinde> just trying out other ways than the given examples :)
03:44:26 <edlinde> yep
03:47:03 * hackagebot lvmrun 1.0 - The Lazy Virtual Machine (LVM) Runtime System.  http://hackage.haskell.org/package/lvmrun-1.0 (JurriaanHage)
03:52:30 <bernalex> main = [getLine | x <- getLine, y <- getLine, z <- [getLine >> putStr "trol" >> putStr "ol" >> putStrLn "ol." | x <- putStrLn "lol", y <- getLine >> putStrLn "lul"]] -- welp this was interestinag
03:57:23 <Sensored> bernalex: that didn't compile for me
03:57:44 <bernalex> "improved it"
03:57:47 <bernalex> main = putStrLn =<< join [z >> getLine | x <- getLine, y <- getLine, z <- [getLine >> putStr "trol" >> putStrLn "olol." | x <- putStrLn "lol", y <- getLine >> putStrLn "lul"]]
03:58:14 <MagneticDuck> do notation + list comprehensions = ..
03:58:22 <MagneticDuck> wait, never mind, no do notatoin
03:58:23 <MagneticDuck> I'm tired
03:58:36 <MagneticDuck> I mean... monad stuff
03:58:43 <bernalex> monad comprehensions?
03:58:43 <bennofs> -XMonadicListComp or something
03:58:50 <Sensored> still borked
03:58:50 <bernalex> MonadComprehensions
03:58:58 <Sensored> any way to enable extns in ghci?
03:59:05 <bernalex> :set -XMonadComprehensions
03:59:05 <bennofs> Sensored: :set -XMonadComprehensions
03:59:08 <Sensored> ty
03:59:28 <Sensored> lol. wtf.
03:59:35 <MagneticDuck> {-# LANGUAGE CrazyMonadStuff #-}
03:59:41 <Sensored> this function is pretty cryptic
03:59:54 <bernalex> I think we should use it to evangelise how haskell does IO
04:00:08 <bernalex> OK so Haskell is "pure". how does it do IO then?
04:00:10 <bernalex> main = putStrLn =<< join [z >> getLine | x <- getLine, y <- getLine, z <- [getLine >> putStr "trol" >> putStrLn "olol." | x <- putStrLn "lol", y <- getLine >> putStrLn "lul"]]
04:00:12 <bernalex> MONADS
04:00:17 <bernalex> sunglasses.jpeg
04:00:24 <MagneticDuck> WAU
04:00:29 <Sensored> sometimes i feel like haskell being so consise is not a good thing
04:01:06 <bernalex> Sensored: you can do stupid stuff in other languages too. at least in haskell you can beta-reduce the stupid stuff to see that it's stupid all the way down.
04:01:22 <Sensored> lolllllllll
04:01:26 <benma> hey guys, a quick question about haskell development in emacs: i am getting tired of manually writing all the import statements i need (for example, when i need mempty, I need to import it from Data.Monoid). is there some way to let emacs/ghc do this for me without much distraction?
04:02:13 <benma> ideally I would want emacs to notice that the identifier is not imported and ask me if I want to have it added to the import list
04:02:36 <benma> or invoke this manually while sitting on that identifier
04:02:50 <bennofs> benma: do you have haskell-mode installed?
04:03:28 <benma> bennofs: yes, I do. Plus ghc-mod and company-ghc
04:03:44 <benma> i mean ghc, not ghc-mod
04:03:57 <bernalex> Sensored: for maximised lols, try getting rid of the initial putStrLn =<< join, and have a guess what you think will be printed and what won't.
04:04:02 <MagneticDuck> well having ghc installed is pretty critical to doing haskell dev
04:04:12 <MagneticDuck> (lol an emacs plugin called "ghc"?)
04:04:25 <bennofs> benma: If you load the file in the REPL, i think haskell-mode will auto-suggest imports
04:04:44 <Sensored> bernalex: my head exploded a while ago
04:04:50 <Sensored> s im just going to run it and be surprised
04:05:17 <bernalex> Sensored: sunglasses.jpeg
04:05:24 <benma> MagneticDuck: package-list-packages, look for "ghc". It exists
04:05:24 <funfunctor> did someone say β-juice?
04:05:30 <funfunctor> oh no just β-reduction :)
04:05:50 <benma> bennofs: REPL tells me this: Not in scope: ‘mempty’ …
04:05:50 <benma>     Perhaps you meant ‘T.empty’ (imported from Data.Text)
04:05:50 <benma> Compilation failed.
04:05:50 <bernalex> funfunctor: pretty betajuicy betareduction tho
04:06:23 <kuribas> ghc is ghc-mod
04:06:32 <benma> ah, well then :)
04:06:40 <kuribas> the emacs package is just called ghc
04:06:52 <benma> my bad
04:07:34 <funfunctor> I don't understand this library https://hackage.haskell.org/package/highlighter-0.2.2 is this just the lexer or does it parse also?
04:07:53 <kuribas> benma: I don't know if ghc does what you want, but there is some info here: http://www.mew.org/~kazu/proj/ghc-mod/en/emacs.html
04:08:20 <MagneticDuck> grr
04:08:35 <MagneticDuck> what's the simplest lens-like package available (that's not defining its own seperate language >_>)?
04:08:48 <MagneticDuck> really just looking for some helpful template haskell and the general idea of lenses
04:09:23 <kuribas> benma: Look just above the heading "Type holes", doesn't that do what you want?
04:09:31 <bernalex> MagneticDuck: lens-family-core I guess
04:10:24 <MagneticDuck> seems to be haskell 98 for some reason
04:10:34 <MagneticDuck> is lens-family easier to learn than lens?
04:10:48 <MagneticDuck> I might have to learn lens eventually
04:10:51 <benma> kuribas: thanks for the link. Under `M-t` it says: On a symbol "foo" without definition, "foo = undefined" is inserted or a proper module is imported.
04:11:09 <benma> kuribas: when I do this on my unimported mempty, it only says "nothing to be done"
04:11:18 <MagneticDuck> ..but looking for something easier to understand first >_> (I get lenses, but I don't get all the other stuff that lens does)
04:11:22 <kuribas> benma, I have the same problem...
04:11:23 <bernalex> MagneticDuck: lens-family-core is haskell 2010, preferably with rank n polymorphism -- afaik
04:11:47 <kuribas> benma: maybe you need to use M-C-m first.
04:11:52 <funfunctor> surely someone has wanted to parse groff man pages before in haskell, google is not helping today :<
04:11:58 <bernalex> MagneticDuck: ekmett's lens library is uh batteries included, and more about folds & traversals than lenses. lens-family and lens-family-core are way easier to grok.
04:12:03 <MagneticDuck> the package description is "Haskell 98 lens families"
04:12:10 <benma> kuribas: I tried, also to no avali
04:12:21 <MagneticDuck> bernalex: yay
04:13:38 <bennofs> bernalex. MagneticDuck: lens-family and lens-family-core are also about traversals and folds! They contain no prisms or isos though and don't have so many complex combinators (like Control.Lens.Plated, Control.Exception.Lens, ...)
04:14:20 <benma> bennofs: the relevant elisp code does not look like it is trying to find a suitable import, as the documentation says
04:14:33 <MagneticDuck> bennofs: ._.
04:14:45 <MagneticDuck> ugh
04:14:49 <MagneticDuck> I'll just start using it
04:14:56 <MagneticDuck> I have something pretty simple I want to do
04:15:18 <benma> kuribas: the relevant elisp code does not look like it is trying to find a suitable import, as the documentation says
04:15:20 <MagneticDuck> lens-family-core provides template haskell stuff right?
04:15:40 <kuribas> benma: That's weird
04:16:00 <bennofs> MagneticDuck: the nice thing is: lens-family is a subset of lens, so you can build on your knowlegde of lens-family if you later want to learn lens, and the lenses from lens-family also work out of the box with lens
04:16:08 <MagneticDuck> okay
04:16:23 <bennofs> MagneticDuck: there is lens-family-th
04:16:52 <benma> kuribas: I guess I'll open an issue on github
04:16:59 <kuribas> benma: right
04:17:21 <MagneticDuck> what's the family and family2?
04:18:58 <kuribas> benma: perhaps it has hardcoded some functions.  It works with <*>
04:19:33 <bennofs> MagneticDuck: family / core is haskell98 only. family2 is haskell2010 + RankNTypes
04:20:08 <bennofs> MagneticDuck: you should just use family2 if you don't require strict haskell98 compat
04:22:30 <benma> kuribas: so how do you handle importing stuff? do you do it manually?
04:26:51 <kuribas> benma: yeah
04:27:05 <hyPiRion> hrm
04:27:38 <hyPiRion> > foldr (flip fmap) id [(*10), (+2)] $ 10
04:27:39 <lambdabot>  102
04:27:54 <hyPiRion> is there a better way to do this?
04:29:11 <hyPiRion> that is, I want the result to be (+2) $ (*10) $ 10
04:29:28 <l0cust> > [op 10 | op <- [(*10), (+2)]]
04:29:30 <lambdabot>  [100,12]
04:29:41 <l0cust> oh I see
04:29:59 <l0cust> hyPiRion: what's wrong with writing it manually?
04:30:18 <l0cust> > (+2) . (*10) $ 10
04:30:20 <lambdabot>  102
04:31:00 <hyPiRion> l0cust: nothing wrong with it, I was just curious if there was something else out there
04:31:04 <kuribas> benma: yes, it's hardcoded in ghc-ins-mod.el
04:31:11 <l0cust> hyPiRion: nothing that will be clearer
04:31:18 <hyPiRion> alright, thanks
04:32:00 <l0cust> hyPiRion: you could write a function
04:32:08 <hyPiRion> for some reason I thought foldr was (a -> b -> a) -> a -> [b] -> a, which was what confused me
04:32:30 <l0cust> @@ hyPiRion @let runfunctions = foldr (flip fmap) id
04:32:34 <lambdabot>  hyPiRion  Defined.
04:32:49 <l0cust> > runfunctions [(*10), (+2)] 10
04:32:51 <lambdabot>  102
04:33:02 <hyPiRion> yeah, more readable
04:33:04 <l0cust> @let runOn = runfunctions
04:33:05 <lambdabot>  Defined.
04:33:21 <l0cust> > [(*10), (+2)] `runOn` 10
04:33:23 <lambdabot>  102
04:33:52 <hyPiRion> :t runOn
04:33:53 <lambdabot> [b -> b] -> b -> b
04:34:07 <MagneticDuck> how do I "use TemplateHaskell"?
04:34:14 <hyPiRion> yup, what I wanted. Thanks again
04:34:21 <MagneticDuck> don't I just put a LANGUAGE pragma with TemplateHaskell at the beginning?
04:34:23 <l0cust> MagneticDuck: number of ways. Are you using cabal
04:34:26 <MagneticDuck> yes
04:34:56 <l0cust> MagneticDuck: okay, add a field to your executable/library called "default-extensions", add TemplateHaskell
04:35:09 <l0cust> MagneticDuck: the language pragma works, but it's a bit annoying to have to put it in every file
04:35:55 <MagneticDuck> uhm
04:36:10 <MagneticDuck> did that, now I get a parse error on "module"
04:36:45 <l0cust> MagneticDuck: one sec
04:36:48 <l0cust> MagneticDuck: pastebin it
04:37:07 <l0cust> MagneticDuck: see https://github.com/pharpend/castr/blob/master/castr.cabal
04:37:36 <MagneticDuck> eah I did that
04:37:39 <MagneticDuck> but in my actual source file
04:37:50 <MagneticDuck> I get a parse error on "module", the first word in the file
04:38:05 <l0cust> MagneticDuck: pastebin the source file
04:38:11 <l0cust> MagneticDuck: or at least the first few lines
04:38:20 <MagneticDuck> module CWData.Data where
04:38:22 <MagneticDuck> xD
04:38:31 <l0cust> MagneticDuck: that's the first line?
04:38:35 <MagneticDuck> yes
04:38:40 <l0cust> hmm
04:38:47 <l0cust> No preceding whitespace or anything?
04:39:11 <MagneticDuck> nop
04:39:19 <l0cust> Can you also paste the actual error message?
04:39:54 <MagneticDuck> k
04:39:57 <MagneticDuck> getting it
04:40:00 <MagneticDuck> http://ix.io/e9A
04:40:24 <MagneticDuck> I'll put the project on github actually
04:40:31 <l0cust> Okay, that looks like a th error
04:40:36 <l0cust> (no shit, right)
04:40:44 <l0cust> Okay
04:41:12 <trap_exit> what is the _largest_ workable haskell codebase ?
04:41:14 <l0cust> MagneticDuck: There are some other things you should be doing in the meantime. For instance, sandboxing.
04:41:19 <l0cust> trap_exit: Prelude
04:41:34 <bernalex> l0cust: not at all
04:41:36 <trap_exit> l0cust: Prelude.hs ?
04:41:42 <bernalex> prelude is tiny that makes no sense
04:41:49 <l0cust> trap_exit: aside from that, probably yesod or something from bos
04:42:01 <bernalex> I'm guessing something behind closed doors
04:42:01 <l0cust> yesod is pretty huge
04:42:02 <int-e> ghc isn't small either
04:42:06 <bernalex> maybe what don stewart is working with
04:42:13 <l0cust> int-e: most of ghc is C tho
04:42:17 <bernalex> l0cust: no
04:42:17 <int-e> l0cust: nope
04:43:02 <l0cust> Oh wow, 80% haskell. I thought it was mostly c
04:43:05 <l0cust> https://github.com/ghc/ghc
04:43:11 <l0cust> 12% C is still a pretty huge bit
04:43:15 <trap_exit> how many lines of code is that?
04:43:30 <bernalex> trap_exit: in 2011 it was around 140K
04:43:34 <trap_exit> I'm trying to figure out:
04:43:39 <trap_exit> is Haskell the last langauge I'll have to use
04:43:47 <trap_exit> i.e. it'll scale to my needs for the rest of my life
04:43:53 <trap_exit> (assuming a long life)
04:44:00 <bernalex> trap_exit: I think we'll move along whenever something better shows up.
04:44:06 <funfunctor> trap_exit: no, you may or may not need to talk to people in your life
04:44:07 <bernalex> also haskell can't do everything.
04:44:15 <l0cust> trap_exit: probably. C is always a good option.
04:44:23 <trap_exit> bernalex: as in Haskell will adapt?
04:44:31 <int-e> sloccount puts the compiler subdirectory at 133k lines of haskell code. (no C at all)
04:44:34 <l0cust> trap_exit: Something better will eventually come along. Haskell is probably the best as it stands
04:44:34 <bernalex> trap_exit: what do you mean?
04:45:00 <bernalex> int-e: yeah I was including stuff like STG, Core, profiling, utils, etc
04:45:31 <baasa> what is this place?
04:45:32 <trap_exit> so whatever the ideal langauge of the future is
04:45:32 <bernalex> the runtime system is where most of the C & C-- resides
04:45:33 <funfunctor> trap_exit: "The sum of human wisdom is not contained in any one language, and no single language is capable of expressing all forms and degrees of human comprehension."
04:45:49 <trap_exit> I have a hard time imagingin it not involving (1) purity, (2) monads, (3) and a powerful type system
04:45:56 <trap_exit> so basically it's going to be haskell like
04:45:59 <l0cust> baasa: this is the internet. It's mostly pictures of cats and naked girls.
04:46:53 <funfunctor> baasa: this is September, the enternal September.
04:47:18 <int-e> bernalex: I wasn't trying to contradict you. The repo contains several libraries (like base) nowadays and I didn't want to count those. RTS weighs in at 38k lines of cose, mostly C and CMM.
04:47:33 <trap_exit> where are the pictures of cats?
04:47:43 <l0cust> trap_exit: http://i.imgur.com/YredYGg.gif
04:47:44 <bernalex> int-e: isn't it only C & C--? the RTS I mean
04:47:50 <bernalex> int-e: it was a few years ago at least
04:47:58 <funfunctor> trap_exit: in /usr/bin
04:48:32 <trap_exit> so riddle me this
04:48:38 <bernalex> also I mean Cmm not C-- heh
04:48:45 <trap_exit> name a single idea in language design that has not been implemented as alibrary in Haskell
04:48:59 <benmachine> trap_exit: dependent types
04:49:01 <benmachine> linear types
04:49:07 <trap_exit> it seems that laziness + type system + monads to compose computation = other ideas can be added as libraries
04:49:09 <int-e> bernalex: there's one assembler source file in there, and some build system stuff
04:49:14 <bernalex> trap_exit: *full-spectrum* dependent types
04:49:19 <benmachine> checked totalilty
04:49:21 <trap_exit> as in Coq ?
04:49:25 <bernalex> yes.
04:49:35 <Fuuzetsu> benmachine: Agda is implemented in Haskell, does that count ;P
04:49:35 <int-e> (I don't know whether the assembler code is even used, it looks like something that's done with libffi nowadays)
04:49:36 <trap_exit> I've programmed in Coq. I'm not convined dependent types is useful right now.
04:49:36 <bernalex> int-e: ah yeah I wasn't including that, heh
04:49:41 <benmachine> Fuuzetsu: no
04:49:48 <funfunctor> trap_exit: checkout Idris lang btw
04:49:48 <bernalex> Fuuzetsu: point :-P
04:50:06 <bernalex> trap_exit: Coq is not a general purpose lang like e.g. idris
04:50:21 <trap_exit> hmm, what's the most useful project written in idris?
04:50:26 <trap_exit> it looks like haskell with it's syntax screwed up, extensions ripped out,
04:50:29 <trap_exit> and I'm not sure what I get in exchange
04:50:40 <bernalex> uhm 2048? lol
04:51:01 <trap_exit> 2048 was written in idris?
04:51:04 <bernalex> sure
04:51:05 <benmachine> I still think checked totality is a pretty good one
04:51:14 <bernalex> not the original if that's what you mean
04:51:20 <benmachine> I believe idris has that optional
04:51:22 <bernalex> benmachine: yeah but it's very esoteric I guess
04:51:36 <benmachine> bernalex: checked totality doesn't strike me as esoteric at all
04:51:39 <bernalex> kind of like having correct and working programs. we all know that's for academic wankers.
04:51:43 <benmachine> :P
04:51:46 <int-e> trap_exit: http://www.quora.com/Haskell-in-Industry/What-is-the-largest-commercial-program-written-in-Haskell mentions a 1.3 Mio line codebase.
04:52:10 <companion_cube> trap_exit: uh, dependent types?
04:52:23 <bernalex> companion_cube: you're a little late
04:52:25 <int-e> (I imagine that this is a suite of many programs and tools, but it's still an impressive number)
04:52:25 <benmachine> I write so many functions that obviously don't crash, and so many functions that look like they don't crash but actually do
04:52:32 <benmachine> *please*, compiler, tell me which are which
04:52:44 <hyPiRion> int-e: that's not Idris though, I think that was what trap_exit asked for
04:52:52 <companion_cube> I mean, complaining about losing ghc extensions when you get dependent types...
04:52:59 <bernalex> benmachine: a haskell program that doesn't typecheck is not even wrong. you should employ denotational design. ask conal about it. ;-)
04:53:07 <benmachine> hyPiRion: trap_exit asked several questions
04:53:16 <trap_exit> what is denotational design?
04:53:25 <trap_exit> companion_cube: do you use idris more than you use haskell ?
04:53:29 <companion_cube> no
04:53:41 <hyPiRion> benmachine: oh, I just saw "hmm, what's the most useful project written in idris?"
04:53:46 <trap_exit> #haskell has many answers
04:53:52 <trap_exit> need to learn more
04:53:55 <companion_cube> idris is much younger than haskell though
04:54:20 <int-e> hyPiRion: I was still occupied with an earlier question (asked about 15 minutes ago)
04:54:22 <benmachine> Haskell provides an excellent tradeoff of maturity and sophistication, I think this channel would generally agree
04:54:24 <bernalex> trap_exit: https://www.youtube.com/watch?v=zzCrZEil9iI
04:54:30 <benmachine> but there is more sophistication in the world, and some day it might become mature
04:54:57 <benmachine> so I would strongly suspect that Haskell absolutely is not the last language you will ever need
04:55:21 <dfdsfsfsdf> is there a way to check that multiple lists have the same length without writing 'length' multiple times?
04:55:41 <trap_exit> map length
04:55:44 <benmachine> dfdsfsfsdf: what's wrong with writing length multiple times?
04:55:53 <dfdsfsfsdf> benmachine: too verbose
04:56:04 <trap_exit> map length
04:56:22 <dfdsfsfsdf> trap_exit: how do I check that all elements are the same?
04:56:27 <dfdsfsfsdf> after mapping
04:56:49 <dfdsfsfsdf> fold?
04:56:49 <trap_exit> ==
04:56:50 <benmachine> dfdsfsfsdf: case xs of [] -> True; x:xs -> all (== x) xs, I guess
04:57:00 <dfdsfsfsdf> benmachine: still too verbose
04:57:03 <bernalex> dfdsfsfsdf: make a list of lists and then map lengthL
04:57:27 <bernalex> s/L/?
04:57:30 <trap_exit> dfdsfsfsdf: do you have a github account that charges you by the byte ?
04:57:33 <benmachine> dfdsfsfsdf: your verbosity requirements seem quite stringent to me :P
04:58:02 <int-e> @type null . drop 1 . group . map length
04:58:04 <lambdabot> [[a]] -> Bool
04:58:14 <bernalex> int-e: yeah that was what I thought about lol
04:58:16 <trap_exit> nub
04:58:23 <bernalex> but with nub
04:58:51 <trap_exit>  nub $ map length lst
04:58:51 <int-e> nub is ... actually quite okay for this application.
04:59:22 <trap_exit> (drop 1 $ nub $ map length lst) == []
04:59:23 <benmachine> the usual bad asymptotics don't materialise if you're only interested in the first two elements
04:59:28 <dfdsfsfsdf> trap_exit: nope, but when you repeat, there's a chance to make an error.
04:59:36 <trap_exit> what?
04:59:42 <trap_exit> I disagree
04:59:54 <trap_exit> wtf is 'there is a chance'
04:59:57 <trap_exit> either it is correct or it is wrong
05:00:01 <trap_exit> haskell is a determinsitic language
05:00:01 <benmachine> dfdsfsfsdf: you can be overzealous about that kind of rule
05:00:12 <dfdsfsfsdf> ugh
05:00:21 <dfdsfsfsdf> nevermind
05:00:52 <bernalex> length (nub $ map length xs)==1 -- lol
05:00:57 <trap_exit> no
05:00:58 <trap_exit> you used length twice
05:01:02 <trap_exit> that's why you have to do drop 1 == []
05:01:16 <trap_exit> the whole point is to only type length once
05:01:19 <int-e> trap_exit: that's not a good reason
05:01:25 <bernalex> yeah it's not
05:01:25 <companion_cube> let l = length in ... ?
05:01:29 <int-e> a better reason is that ==1 fails for an empty list.
05:01:40 <int-e> (it should be <= 1, I think
05:01:41 <int-e> )
05:01:42 <trap_exit> I don't agree with the problem statement
05:01:47 <bernalex> also I thought we were shaving chars here
05:01:54 <benmachine> we're not shaving chars
05:01:55 <bernalex> wasn't that the big "problem". verbosity
05:02:06 <benmachine> we're trying to reduce the number of repeated expressions of the same idea
05:02:12 <kuribas> benma: I have some succes with creating import statements.
05:02:21 <bernalex> benmachine: that's not the question as I understood it
05:02:22 <trap_exit> let's discuss something else :-)
05:02:24 <trap_exit> I think the asker left
05:02:28 <srhb> Indeed.
05:02:32 <kuribas> benma: It doesn't seem to work on types, but it works on functions.
05:04:22 <trap_exit> alriht; let's debate idris + dependent types vs haskell
05:04:27 <Sensored> :t nub
05:04:28 <lambdabot> Eq a => [a] -> [a]
05:04:45 <Sensored> > nub [0, 1, 2, 3]
05:04:47 <lambdabot>  [0,1,2,3]
05:04:47 <bernalex> trap_exit: not really a fair arena. if you go to #idris, the outcome will likely be different. ;-)
05:04:57 <bernalex> Sensored:
05:05:03 <bernalex> > nub [1,1,1,2,2]
05:05:04 <lambdabot>  [1,2]
05:05:06 <Sensored> > nub [0, 1, 2, 3, 3]
05:05:07 <lambdabot>  [0,1,2,3]
05:05:08 <Sensored> yeah
05:05:12 <Sensored> does this run in n^2
05:05:28 <trap_exit> I think it's linear time
05:05:29 <trap_exit> but screws up on non-sorted lists
05:05:30 <trap_exit> nub [0, 1, 0]
05:05:33 <benmachine> Sensored: worst-case yes
05:05:36 <trap_exit> > nub [0, 1, 0]
05:05:38 <lambdabot>  [0,1]
05:05:39 <benmachine> trap_exit: no, that's different
05:05:41 <trap_exit> hmm
05:05:43 <Sensored> best case?
05:05:44 <benmachine> you're thinking of group, I think
05:05:46 <trap_exit> I'm wrong
05:05:47 <bernalex> trap_exit: what do you mean "screws up"?
05:05:49 <bernalex> oh.
05:05:59 <Sensored> to do it in linear time you'd need a hash table
05:06:01 <bernalex> benmachine: well for group, that behaviour makes sense.
05:06:05 <benmachine> Sensored: well, I suppose a more precise statement would be it runs in O(kn), where n is the length of the list and k is the number of distinct elements
05:06:07 <trap_exit> I expeted the output to b e[0, 1, 0] because "it thought the list was sorted"
05:06:24 <bernalex> > group [0, 1, 0, 1]
05:06:24 <Sensored> space complexity?
05:06:26 <lambdabot>  [[0],[1],[0],[1]]
05:06:26 <trap_exit> what?
05:06:28 <trap_exit> what's a weird algorithm
05:06:29 <trap_exit> O(k n)
05:06:31 <bernalex> > group [0, 0, 1, 1]
05:06:33 <lambdabot>  [[0,0],[1,1]]
05:06:40 <bernalex> is that what you were thinking of, trap_exit ?
05:06:42 <kuribas> Sensored: https://github.com/nh2/haskell-ordnub
05:06:58 <int-e> bernalex: something like  map head . group
05:07:09 <trap_exit> bernalex: no, I thought it was linear time but fails on not-sorted (i.e. it assumes the items are increasing or decreasing; so you only have ot check adjacent items)
05:07:21 <trap_exit> also, worst case is O(n log n): (1) use n log n to sort, then (2) only check neighbors
05:07:28 <benmachine> Sensored: as I understand it, nub [] = []; nub (x:xs) = x : delete x (nub xs)
05:07:28 <trap_exit> O(n ^2 ) algorith would be a very slow one
05:07:36 <int-e> @type nub
05:07:37 <lambdabot> Eq a => [a] -> [a]
05:07:43 <bernalex> @src nub
05:07:43 <lambdabot> nub = nubBy (==)
05:07:44 <trap_exit> @src nub
05:07:44 <lambdabot> nub = nubBy (==)
05:07:49 <bernalex> of course
05:07:52 <benmachine> O(n^2) is the only way you can do it given you only have equality and not ordering
05:07:53 <int-e> trap_exit: with just Eq, O(n^2) is the best you can do
05:07:54 <trap_exit> @src nubBy
05:07:54 <lambdabot> nubBy eq []     = []
05:07:54 <lambdabot> nubBy eq (x:xs) = x : nubBy eq (filter (\ y -> not (eq x y)) xs)
05:08:05 <trap_exit> benmachine , int-e: hmm, you're right
05:08:08 <mr-> trap_exit: nub works without having to be able to order the elements.
05:08:18 <nateb> Is there some way of specifying a constraint that relates two constraints? like `(A x y, B y z) => C x z`?
05:08:36 <benmachine> Sensored: anyway, so space complexity is O(k), using the same notation as before
05:08:40 <kuribas> There's a benchmap here that shows that naive set operations on lists are always worse: http://htmlpreview.github.io/?https://github.com/nh2/haskell-ordnub/blob/master/report.html
05:08:51 <augur> nateb: in what sense?
05:08:55 <benmachine> this all becomes more complicated when you consider Haskell is lazy, so you don't have to consume the entire output necessarily
05:09:04 <bernalex> yeah
05:09:08 <bernalex> > nub [0..] -- weee
05:09:09 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
05:09:10 <nateb> augur: in that 'y' doesn't occur in the right hand side.
05:09:32 <augur> nateb: ahh. so can you have a variable that doesnt appear in the constraint
05:09:36 <augur> good question!
05:09:43 <augur> what error happens when you try it?
05:09:44 <MagneticDuck> https://github.com/MagneticDuck/CWData/tree/master/src
05:09:49 <Shapeshifter> Hi. Does someone know the locatino of "The Monad.Reader Issue 5" in pdf format? Looking for this chapter http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue5/Practical_Graph_Handling but with illustrations...
05:09:49 <nateb> that is to say, "C in relation to x and z is defined such that there is an A and a B with a y that relates them
05:09:49 <MagneticDuck> error is in top level directory
05:09:52 <nateb> "
05:09:53 <MagneticDuck> any ideas...?
05:09:55 <int-e> benmachine: right. head . nub  is constant time :)
05:10:02 <MagneticDuck> this error started when I added TemplateHaskell to the language extensions
05:10:10 <nateb> augur: all kinds of stuff, but usually I wind up at overlapping instances
05:10:24 <benmachine> int-e: :)
05:10:28 <nateb> I've banged my head on this for about two days :^(
05:10:32 <augur> nateb: yes, that seems plausible
05:10:54 <augur> consider a trivial case:    instance C a b => C' a
05:11:06 <augur> there could be two b's that make C a b satisfiable
05:11:19 <augur> haskell has no a-priori way of knowing there arent
05:11:25 <nateb> Right.
05:11:27 <ij> The b is undecided, so it won't work, right?
05:11:29 <int-e> laziness has other funny consequences. merge sort is a nice example; if you implement it with lazy lists, the execution behaves like a heap sort (and hence you get the first element in O(n) and all subsequent elements in O(log n) comparisons, where n is the length of the input list)
05:11:33 <Sensored> @src nub
05:11:33 <lambdabot> nub = nubBy (==)
05:11:35 <augur> ij: who says its undecidable?
05:11:46 <Sensored> @src nubBy
05:11:46 <lambdabot> nubBy eq []     = []
05:11:46 <lambdabot> nubBy eq (x:xs) = x : nubBy eq (filter (\ y -> not (eq x y)) xs)
05:11:50 <Sensored> thats clever as shit
05:12:05 <ij> augur, no one, but it hasn't been decided — it can be anything, so an instance can't be found?
05:12:20 <augur> ij: that doesnt follow
05:12:26 <nateb> I tried using functional dependencies to resolve this, but every time I wound up tying myself in knots.
05:12:34 <augur> nateb: what is your goal?
05:12:43 <augur> Sensored: why is that clever?
05:12:51 <augur> (gosh im full of questions!)
05:13:10 <int-e> (To clarify, by "heap sort" I mean sorting using any heap data structure, not the in-place array version.)
05:14:02 <nateb> augur: My goal, ultimately, is to create a group of types that have known (and explicit) relationships, and to leverage that to knit them together with minimal boilerplate.
05:14:28 <augur> nateb: can you give a minimal example?
05:14:50 <nateb> That is, if I have some `data A = A B; data B = B C; data C` I shold be able to make an A from a C without concerning myself with B.
05:14:53 <kuribas> There is no reason to ever use nub, intersection, etc...
05:15:59 <nateb> But that if I have types [A .. Z] in the same sort of relationships, that I could make an A from an M, and a J from a W, etc.
05:16:23 <int-e> kuribas: but that doesn't mean that using "nub" is always bad.
05:16:53 <nateb> (the relationships are not so simple, but I don't mind being explicit about those as part of an instance for each type)
05:16:53 <Sensored> augur
05:16:55 <kuribas> int-e: not bad, but inefficient.
05:17:04 <int-e> kuribas: again, not always.
05:17:11 <Sensored> from what i can tell, nub does this:
05:17:25 <augur> kuribas: no reason? why not?
05:17:36 <Sensored> you take your list, (x:xs). you will then return a list x:(xs') where xs' is xs filtered to have no values of x in it
05:17:51 <kuribas> int-e, augur: https://github.com/nh2/haskell-ordnub
05:17:51 <Sensored> that xs' is computed recursively
05:18:19 <Sensored> with a sub-call to nub in nub
05:18:26 <int-e> kuribas: as discussed above, if you're only interested in a (small) constant number of elements of the result, nub becomes a linear time operation.
05:18:26 <augur> Sensored: nub computes unique elements
05:18:34 <benma> kuribas: mempty is a function. how did you manage to make it work?
05:18:34 <kuribas> The benchmark shows that nub is slower than ordNub in all cases.
05:18:34 <augur> > nub [0,1,2,3,0,1,2,3,0,1,2,3]
05:18:36 <lambdabot>  [0,1,2,3]
05:18:42 <Sensored> yes, i know
05:18:50 <Sensored> i was explaining why i thought it was really cool
05:19:09 <pilz> Hi. What do the different parentheses mean? http://lpaste.net/4543837088612614144
05:19:10 <kuribas> benma: I didn't, it seamed to work already.
05:19:10 <phadej> kuribas: microbenchmarks are microbenchmarks
05:19:26 <benma> kuribas: what command exactly, on what symbol?
05:19:38 <augur> Sensored: the recursive all is kind of necessary tho. i mean.. you remove the copies of x from the rest of the list, leaving an x-less tail, but you still need to remove the tails duplications
05:19:48 <phadej> take 2 . nub would be quite efficient if the input list contains almost unique elements only
05:19:52 <kuribas> benma: I tried test a b = fmap a b
05:19:58 <int-e> kuribas: Btw, I'm playing Devil's advocate here, mostly. I do avoid "nub" out of habit, because the exceptions where its use is actually ok are very rare indeed.
05:19:59 <phadej> but not with ordnub
05:20:00 <Sensored> augur: yes :)
05:20:12 <augur> nub is a tricky algorithm to define with a fold
05:20:22 <augur> uniques, i mean. nub itself isnt defined with a fold. but.
05:20:28 <Sensored> what
05:20:32 <Sensored> i think you can define nub with a fold
05:20:38 <augur> good luck :)
05:20:41 <Sensored> but
05:20:43 <Sensored> not efficiently
05:20:45 <Sensored> :P
05:20:47 <augur> well yes, i mean
05:20:55 <augur> you can do all sorts of crazy things to simulate general recursion
05:21:05 <ski> pilz : both of those two sets of brackets could be removed
05:21:07 <augur> the tricky thing is that nub isnt structurally recursive on the face of it, right
05:21:12 <benma> kuribas: but fmap is already in prelude? what did you import?
05:21:19 <Sensored> no it absolutely is
05:21:22 <Sensored> from the defn
05:21:26 <augur> no its not
05:21:32 <augur> the definition is manifestly not structurally recursive
05:21:38 <kuribas> benma: it then shows a list of modules that I can import.
05:21:40 <augur> the recursive call has the structure    nub (x : xs) = x : nub (f xs)
05:21:51 <kuribas> benma: I used C-cC-m
05:21:51 <Sensored> yeah. looks like recursion there
05:21:58 <augur> Sensored: but not _STRUCTURAL_ recursion
05:22:25 <augur> to be structurally recursive, `nub` has to be called on a sub-term of the input. but its not, its called on the result of some auxiliary computation _over_ the subterm
05:22:31 <kuribas> benma: The only thing is that it makes a new definition, instead of merging it.
05:22:43 <kuribas> benma: import statement I mean.
05:22:44 <augur> a structurally recursive list function has this form in general:
05:22:46 <phadej> it's not structural recursion, though it's easily proven to be terminating (induction on list length)
05:22:49 <augur> f [] = z
05:22:58 <augur> f (x : xs) = g x (f xs)
05:23:03 <phadej> just try to define one with idris or agda ;)
05:23:10 <kuribas> benma: That could be implemented though.
05:23:11 <Sensored> ah i think i see what you mean
05:23:22 <augur> g is easy, its just :
05:23:23 <benma> kuribas: you did this on fmap? when I do it, it says 'No module guessed' :(
05:23:27 <Sensored> we threw and f over the xs and so you can't be certain it's structurally recursive
05:23:31 <Sensored> threw an f*
05:23:42 <augur> i wonder if there's a generalization of fold
05:23:45 <benma> kuribas: same for mempty and any other I try
05:23:45 <ski> @type let nub = unfoldr (\xs -> do x:xs <- return xs; return (x,filter (x /=) xs)) in nub
05:23:46 <lambdabot> Eq a => [a] -> [a]
05:23:48 <benmachine> > foldr (\x -> (x:) . delete x) [] [1,2,3,4,3,2,1,2,3,4,5,4,3,2,1]
05:23:50 <lambdabot>  [1,2,3,4,5]
05:23:56 <kuribas> benma: even when you press C-M-m first?
05:24:01 <augur> gfoldr g f z [] = z
05:24:16 <benma> kuribas: C-M-m => No new modules
05:24:19 <augur> gfoldr g f z (x : xs) = f x (gfoldr g f z (g xs))
05:24:31 <BoR0> @src foldr
05:24:31 <lambdabot> foldr f z []     = z
05:24:31 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:24:49 <ski> augur : with `g' being decreasing ?
05:25:02 <augur> @hoogle ([a] -> [a]) -> a -> (a -> b -> b) -> [a] -> b
05:25:06 <lambdabot> No results found
05:25:15 <augur> ski: it would have to be to terminate, i think
05:25:29 <kuribas> I am using ghc from melpa.
05:25:39 <kuribas> benma: I am using ghc from melpa.
05:25:51 <benmachine> augur: I claim that the foldr-based definition I just gave is of nub and is reasonably straightforward
05:26:00 <ski> i suppose if `f' is `\x _ -> h x', it would also work
05:26:20 <augur> ski: i think the general requirement being that g is uh... whats the term
05:26:24 <augur> well founded? or something like that
05:26:44 <augur> forall xs, exists n, g^n xs = []
05:26:59 <augur> i think that is probably the right requirement?
05:27:23 <augur> benmachine: ahh yes, that one works better :)
05:27:32 <augur> benmachine: put the delete outside the recursive call, not inside!
05:27:39 <benmachine> right
05:27:40 <zwarn> i am looking to write a modular extendable interpreter. Are there libraries for that?
05:27:41 <augur> benmachine: so to compare
05:27:44 <augur> nub [] = []
05:27:47 <benma> kuribas: me too... well, thanks anyway :)
05:27:53 <augur> nub (x : xs) = x : nub (delete x xs)
05:27:56 <augur> vs
05:27:58 <augur> nub' [] = []
05:28:07 <BoR0> what does nub mean?
05:28:08 <augur> nub' (x : xs) = x : delete x (nub' xs)
05:28:51 <int-e> BoR0: "essence"
05:29:17 <benmachine> BoR0: 'nub' in this case is a function that takes a list and returns a list which has had all repetitions of elements dropped
05:29:20 <augur> benmachine: that probably suggests a relationship between foldr and gfoldr
05:29:38 <ski> @type let nub xs = foldr (\x f xs -> x : filter (x /=) (f xs)) id xs xs in nub  -- another `foldr' version
05:29:39 <lambdabot> Eq a => [a] -> [a]
05:29:50 <kuribas> benma: maybe a problem with ghc-mod?
05:30:19 <mizu_no_oto> Is it possible to use cabal to depend on something that currently exists only on github?
05:30:24 <benmachine> ski: to what extent is that one just mine but CPSified?
05:30:44 <arianvp> mizu_no_oto.  Yes you can use  "cabal sandbox add-source"
05:30:49 <augur> ski: foldr (x /=) = delete x
05:31:03 <arianvp> Though you'll need to pull in the github project to local disk first manually
05:31:14 <augur> oh, yes i see, theres an extra thing in there
05:31:56 <benma> kuribas: looks like it.. i'll figure it out
05:32:01 <kuribas> benma: try "ghc-mod list" on the command line.
05:32:35 <kuribas> benma: ghc-mod also doesn't work with the latest cabal file formats.
05:33:00 <ski> > let nub xs = foldr (\x f xs -> x : filter (x /=) (f xs)) id xs xs in nub "abacaba"
05:33:01 <lambdabot>  "abc"
05:33:04 <benmachine> augur: I think your requirement that g be well-founded is not sufficient. consider g that adds an element to lists of odd length, and drops 2 from lists of even length, then g is well-founded according to your definition but gfoldr g (:) [] [(),()] does not terminate
05:33:08 <ski> > let nub xs = foldr (\x f xs -> x : f (filter (x /=) xs)) id xs xs in nub "abacaba"
05:33:09 <lambdabot>  "abacaba"
05:33:26 <benmachine> or... maybe it does
05:33:30 * benmachine scratches his head a bit
05:33:30 <kuribas> benma: since it reads in a file from the .cabal directory.
05:33:36 <benmachine> I'm sure something along those lines doesn't :P
05:33:49 <kuribas> benma: I have 1.18.0.5
05:34:17 <augur> benmachine: it might not be enough
05:34:32 <int-e> @type let nubOrd xs = foldr (\x f xs -> (if x `S.member` xs then id else (x:)) (f (x `S.insert` xs))) (const []) xs S.empty
05:34:33 <augur> i think ski's description is more or less sufficient
05:34:33 <lambdabot> <no location info>:
05:34:33 <lambdabot>     not an expression: ‘let nubOrd xs = foldr (\x f xs -> (if x `S.member` xs then id else (x:)) (f (x `S.insert` xs))) (const []) xs S.empty’
05:34:38 <int-e> @type let nubOrd xs = foldr (\x f xs -> (if x `S.member` xs then id else (x:)) (f (x `S.insert` xs))) (const []) xs S.empty in nubOrd
05:34:39 <lambdabot> Ord a => [a] -> [a]
05:34:52 <augur> the crucial thing is that forall xs, length xs >= length (g xs)
05:35:01 <augur> that will be sufficient, but is it necessary?
05:35:12 <ski> benmachine : in your version, each `1' in the input produces an `1' in the output, which is subsequently removed by the previous `1' in the input, if any
05:35:52 <augur> also: to what extent is it true that   gfoldr g f z xs = foldr f z (h xs)
05:35:57 <lericson_> i have a foldr expression that gives me a two tuple (a,b), how do i "unpack" these so i can calculate let's say (b - 2) / a?
05:35:57 <augur> for some h determined by g?
05:36:13 <ski> augur : in my `unfoldr' and `foldr' version, the first `1' in the input removes all the subsequent `1's in the input so that they are never considered later
05:36:16 <augur> i would bet you 100% that there is always such an h
05:36:39 <benmachine> ski: ah, I see what you're saying
05:36:53 <ski> augur : i think you can do some lexicographic ordering on lists, wrt `g' would be decreasing
05:36:53 <benmachine> ski: I did wonder if there was an inefficiency I was introducing without noticing
05:37:00 <benma> kuribas: 1.18.0.5 of what? my ghc-mod is 5.0.1.1, the ghc emacs package is at 5.0.0
05:37:09 <augur> nub isnt definable with gfoldr tho actually
05:37:15 <augur> you need something more
05:37:19 <kuribas> benma: cabal
05:37:30 <augur> gfoldr2 :: (a -> [a] -> [a]) -> (a -> b -> b) -> b -> [a] -> b
05:37:35 <augur> gfoldr2 g f z [] = z
05:37:47 <benma> kuribas: I am at 1.20.0.2...
05:37:51 <augur> gfoldr2 g f z (x : xs) = f x (gfoldr g f z (g x xs))
05:37:58 <kuribas> benma: that may be the problem.
05:38:08 <augur> then nub = gfoldr2 delete (:) []
05:38:38 <int-e> lericson_: you can use let, case or lambda, and in some cases uncurry. let (a,b) = <some expression> in (b-2)/a; case <expression> of (a,b) -> (b-2)/a; (\(a,b) -> (b-2)/a) (<expression>); uncurry (\a b -> (b-2)/a) (<expression>).
05:38:53 <int-e> lericson_: those should be the most common ways, besides using fst and snd.
05:39:17 <augur> but for just gfoldr, i bet you good money that forall g, there exists an h such that   gfoldr g f z = foldr g z . h
05:39:18 <lericson_> int-e: alright
05:39:32 <lericson_> int-e: i want my function to return (b-2)/a
05:39:37 <lericson_> i guess case
05:39:39 <ski> augur : perhaps a free theorem could prove it ..
05:39:50 <benma> kuribas: I got it. just this morning I moved OverlodedStrings to the cabal section "extensions", out of source file headers. That tripped up ghc-mod
05:40:00 <benma> kuribas: I moved it back, now it works
05:40:32 <benma> kuribas: thanks for the help.
05:40:40 <kuribas> benma: np
05:40:41 <augur> ski: i bet you that h is something like... h [] = [] ; h (x : xs) = x : g (h xs)
05:41:57 <augur> @free f :: ([a] -> [a]) -> (a -> b -> b) -> b -> [a] -> b
05:41:57 <lambdabot> $map g . k = p . $map g => (forall x. h . q x = f1 (g x) . h) => h . f k q y = f p f1 (h y) . $map g
05:42:09 <benma> kuribas: now i only need to find out of ghc-mod can work with extensions defined in the .cabal file
05:42:31 <augur> @free gfoldr :: ([a] -> [a]) -> (a -> b -> b) -> b -> [a] -> b
05:42:31 <lambdabot> $map f . h = k . $map f => (forall x. g . p x = q (f x) . g) => g . gfoldr h p y = gfoldr k q (g y) . $map f
05:42:39 <augur> 0_0
05:43:15 <ski> hm, it would be nice if `free' could be convinced to simplify free theorems to equivalent, but simpler ones, as far as possible
05:43:29 <benmachine> ski: sounds tricky
05:43:33 <ski> yes
05:46:14 <augur> gfoldr g f z [a,b,c]  =  f a (gfoldr g f z (g [b,c]))  ={ g [b,c] = [b',c'] }=  f a (f b' (gfoldr g f z (g [c'])))  ={ g [c'] = [c''] }=  f a (f b' (f c'' z))
05:46:24 <augur> if g is non-length-changing
05:47:11 <nateb> augur: http://www.pastebin.com/hrGKPEfY
05:47:13 <benma> kuribas: by the way, M-s can merge the imports
05:47:28 <augur> ofcourse:   f a (f b' (f c'' z)) = foldr f z [a,b',c'']
05:47:50 <nateb> That's a minimal example of my goal - but the code is almost 100% boilerplate.
05:47:51 <augur> nateb: too abstract :(
05:47:56 <kuribas> benma: yes, but it's cumbersome.
05:48:16 <nateb> augur: what do you mean?
05:48:38 <augur> nateb: its very abstract. A's and B's and C's, rather than something more concrete and meaningful
05:48:47 <augur> its hard for me to interpret such things
05:49:19 <nateb> augur: the "concrete and meaningful" thing is not - I promise.
05:49:23 <benma> kuribas: I find it acceptable. The available functions can be easily combined to do it without manual interference
05:49:33 <nateb> I can replace all the names, but the problem is the same problem.
05:49:55 <lericson_> what about going from a boolean value to a number? true = 1 and false = 0
05:50:02 <augur> nateb: its just useful to understand the intentions
05:50:08 <nateb> Indeed the actual problem has a lot more types with ridiculous names.
05:50:13 <lericson_> if a then 1 else 0 is a little roundabout
05:50:42 <nateb> augur: The intentions is the last line - print $ A $ def $ Dd (def G) $ def G
05:50:48 <nateb> Run it and you'll see what I mean.
05:51:04 <augur> nateb: i mean, the reason i ask is that there might be a better way of solving "The Problem" than this, but it depends on what "The Problem" is, which is usually easier to understand from actual (pared down) examples
05:51:47 <nateb> Oh... this is the problem.  I just changed the names and got rid of some of the constructors.
05:52:21 <nateb> The actual problem is that I want to make an A from a G.  Currently, with the code I pasted, I can do A $ def G, and I get one.
05:52:22 * hackagebot aws-ec2 0.2.2 - AWS EC2/VPC, ELB and CloudWatch client library for Haskell  http://hackage.haskell.org/package/aws-ec2-0.2.2 (VladimirKirillov)
05:52:26 <augur> so your problem is purely abstract?
05:52:30 <nateb> Very!
05:53:21 <nateb> my real problem is that I have a group of types that all knit together in a specific way, but I just find myself writing pages of boilerplate to make even the most basic type.
05:53:36 <nateb> err... to make the most basic value, I mean.
05:54:46 <nateb> So the solution that I came up with was the one in the pastebin (with basically just the names changed), but even that one is quite verbose, and repetitious.
05:55:58 <nateb> I mean, it's entirely possible that my actual problem is a totally different problem... I may just be thinking about it in a completely incorrect way.  I'm going to have to level up a bit mentally before I can think about it in a more Haskelly way.
05:58:43 <nateb> augur: I came up with a different solution entirely, once, by making [A..G] type synonyms of something that instanced Default in the same way as I showed here, but that came with its own bag of issues.
05:59:21 <nateb> Namely that I was stuck with that type's constructors, which made it impossible to figure out what was going on.
06:02:10 <zwarn> is there a library for modular interpreters?
06:03:31 <phadej> Sensored: https://gist.github.com/phadej/4a23dfed8beca3f19f01
06:04:21 <Sensored> wht am i reading
06:04:35 <phadej> looks like coq got even smarter, cause it accepts nubByOrig.
06:04:56 <phadej> Sensored: proof that two nubBy definitions are equivalent (structural and original ones)
06:09:08 <Rebecca22>  Hi! I give you some videos. I hope you like! http://bit.ly/1mFMmyS
06:09:54 <sipa> @where ops
06:09:54 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
06:12:24 * hackagebot digestive-functors-heist 0.8.6.0 - Heist frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-heist-0.8.6.0 (JasperVanDerJeugt)
06:17:53 <bennofs> Is there a simple library for sending emails on hackage?
06:18:10 <Sensored> perhaps off-topic question
06:18:12 <Sensored> is haskell worth it
06:18:17 <Sensored> :S
06:18:33 <fizbin> Often times? I'll admit to wondering that myself.
06:18:46 <tdammers> Sensored: you might get slightly biased answers here, but: YES, ABSOLUTELY
06:18:51 <Sensored> i'm learning more and more of it
06:18:57 <Sensored> and my head explodes now and then
06:18:59 <Sensored> i have to wonder
06:19:02 <Sensored> why am i doing this
06:19:07 <tdammers> Haskell tends to do this to people
06:19:10 <alpounet> that's perfectly normal yeah
06:19:30 <fizbin> For example, we recently had a large project cancelled and in the post mortem one of the points raised was "we were doing this in Haskell, which neither of us has serious professional experience in".
06:19:35 <tdammers> becoming proficient in Haskell requires about a dozen brain detonations
06:20:03 <Sensored> i can't seriously see people developing software with haskell
06:20:10 <tdammers> fizbin: the problem there wasn't haskell though, but the fact that you didn't have any experience with it
06:20:17 <tdammers> Sensored: yet people do it
06:20:24 <Sensored> i guess /somebody/ must do it
06:20:29 <Rarr> Hello :) I've got one question: I have this fragment of code:
06:20:31 <Laquendi> i can't seriously see people developing software in dynamicaly typed languages
06:20:41 <Sensored> oh yeah screw that Laquendi
06:20:47 <Sensored> i really really like strong typing
06:20:50 <tdammers> Sensored: flagship applications include XMonad (an X11 window manager), Pandoc (cross-compiler for documentation formats)
06:20:52 <Sensored> i really can't go back to python..
06:20:53 <geekosaur> pandoc, xmonad, git-annex get decent amounts of use
06:21:01 <fizbin> tdammers: You're mistaking "no serious professional experience" with "no experience".
06:21:02 <Sensored> do they have like
06:21:07 <Sensored> legible code
06:21:16 <Sensored> no offense but damn haskell is cryptic as hell sometimes
06:21:21 <fizbin> And the experience I'd have was that I'd spend a day feeling like I had worked *really hard*, and I had, because every day I was solving what felt like a dozen little tricky math problems to get everything to type-check.
06:21:21 <davidthomas> not if you don't speak the language
06:21:25 <tdammers> Sensored: can't speak about xmonad or git-annex, but Pandoc is highly readable
06:21:37 <davidthomas> but then, Don Quixote isn't terribly legible if you don't speak Spanish
06:21:49 <tdammers> davidthomas: indeed
06:21:51 <fizbin> But at the end of the day, I hadn't actually progressed that far on the actual code.
06:21:52 <Sensored> true
06:21:52 <hyPiRion> unless you read a translated version
06:22:00 <davidthomas> hyPiRion: true
06:22:00 <bernalex> hmm
06:22:05 <bernalex> is there a way to do
06:22:16 <fizbin> So working in Haskell gave me the illusion of working really hard, without the actual effect of work getting done.
06:22:18 <bernalex> (++) <$> Just "blah" <*> Nothing
06:22:22 <bernalex> that returns "blah", rather than Nothing?
06:22:25 <Sensored> Rarr: fragment of code please
06:22:28 <tdammers> fizbin: if you need a 60% correct solution ASAP, then Haskell is not your friend
06:22:40 <Sensored> :t (<$>)
06:22:40 <geekosaur> xmonad's core is pretty readable. contrib is .. variable
06:22:41 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:22:49 <bernalex> s/is there a/what was the/ really, because I've done it before
06:22:53 <fizbin> tdammers: Thing is, though, like many business projects we didn't completely know what we needed.
06:22:58 <geekosaur> (xmonad has proved to be something of a gateway drug :)
06:23:00 <davidthomas> That said, I think one issue in Haskell practice
06:23:12 <fizbin> "Using haskell" was hardly the only issue with this project.
06:23:14 <davidthomas> is that there's no distinction between statements and expressions
06:23:17 <Rarr> foreign import ccall "test2.h &myFunction" c_myFunction :: MyAwesomeFunction foreign import ccall "dynamic" c_myFunctionWrapper :: FunPtr(CInt -> IO ()) -> CInt -> IO () foreign import capi "test2.h value myStructPtr" c_myStructPtr :: Ptr MyStruct
06:23:20 <fizbin> But it was one.
06:23:20 <Rarr> damn, no new lines
06:23:29 <Rarr> foreign import ccall "test2.h &myFunction" c_myFunction :: MyAwesomeFunction
06:23:33 <tdammers> fizbin: as with any language, it takes some experience to find the sweet spot where your abstractions are powerful enough without being in the way of radical course changes
06:23:35 <Rarr> foreign import ccall "dynamic" c_myFunctionWrapper :: FunPtr(CInt -> IO ()) -> CInt -> IO ()
06:23:38 <davidthomas> which means there's no *naturally enforced* boundary of how much you cram into what kind of abstraction
06:23:46 <Rarr> foreign import capi "test2.h value myStructPtr" c_myStructPtr :: Ptr MyStruct
06:23:55 <geekosaur> Rarr, use a pastebin
06:23:57 <geekosaur> @paste
06:23:57 <lambdabot> Haskell pastebin: http://lpaste.net/
06:23:57 <Sensored> Rarr: use the paste link in the topic
06:24:05 <Rarr> oh, ok
06:24:13 <davidthomas> This means that that's something you need to learn in Haskell, that you don't in other languages
06:24:14 <geekosaur> it's not gonna be readable in a busy channel, newlines or no
06:24:20 <fizbin> tdammers: Thing is, in most other languages I don't get the deceptive feature of feeling accomplished while having actually made no progress.
06:24:29 <davidthomas> (the flexibility has upside, too!)
06:24:40 <fizbin> In other languages, I feel frustrated and annoyed when I spend an hour to do some little thing.
06:24:48 <Sensored> ^
06:24:50 <Sensored> YES
06:24:52 <Sensored> that
06:25:02 <Sensored> is annoying
06:25:04 <davidthomas> fizbin: It's totally possible to do that, though - building out useless class hierarchies in Java or whatever
06:25:04 <Sensored> bu
06:25:06 <Sensored> i have the same exp in haskell
06:25:14 <fizbin> In haskell, getting the overall expression to finally type check can feel like a huge accomplishment.
06:25:23 <fizbin> When in fact, it's barely anything.
06:25:43 <Laquendi> types check, let's ship it
06:25:45 <fizbin> Haskell screws with my own internal "am I getting things done" sense.
06:26:24 <fizbin> To the point where I was a little bit worried about using it for this research work project I just finished.
06:26:33 <bennofs> I have had the opposite experience with my own, personal projects. Haskell is the only language in which I actually ever got a project into a mostly complete state.
06:26:37 <tdammers> fizbin: I think that's more a problem with your mindset, or maybe Haskell isn't a match for your perception of getting things done
06:26:41 <SwashBuckla> bennofs: agreed
06:26:50 <int-e> Laquendi: some people feel opressed when the compiler won't let them write obviously wrong code ;)
06:26:52 <Rarr> geekosaur, Sensored : http://lpaste.net/110409
06:26:54 <fizbin> Now, there it happened to work wonderfully, but if it hadn't I don't think I would have known until I'd wasted a huge amount of time.
06:27:13 <SwashBuckla> maintenance times will decrease
06:27:36 <SwashBuckla> int-e: haha
06:27:53 <Laquendi> int-e: that is so true i might cry
06:28:17 <Rarr> geekosaur, Sensored : uh, sory, forgot to use whole code
06:28:23 <Rarr> geekosaur, Sensored : gonna repost
06:28:27 <fizbin> When it fits a problem, it's as good as any time a tool really fits a problem. But when I'm using the wrong abstractions in Haskell or off on the totally wrong path, I find that I can't tell until it's a long time later with nothing to show for it.
06:28:43 <bennofs> I feel like in Haskell, you can just start out with "dirty" code to make it work (as simple as possible), and it's still not too hard to later refactor it into a clean architecture. When I tried the same recently with C++, I ended up with lots of global variables which made refactoring later really hard.
06:29:05 <bernalex> anyone in the mood for some golf?
06:29:08 <bernalex> http://lpaste.net/1033765153172094976 halp me
06:29:17 <Rarr> geekosaur, Sensored : http://lpaste.net/110410 fixed
06:29:25 <Laquendi> so, how do i convince my boss to let me port rails app to haskell?
06:29:31 <Rarr> (in sense it's full code)
06:29:46 <fizbin> bennofs: Well, sure. In C++/Java, you use the first thing as a kind of bague outline, and write the better thing from scratch.
06:29:53 <flux> laquendi, does he drink whisky?
06:30:00 <fizbin> "vague" outline, even.
06:30:12 <geekosaur> writing in haskell does require thinking a bit differently than in, say, python --- but I do that anyway, different languages have different strengths and I try to write to each language's strengths rather than trying to force the same style on every language
06:31:31 <bennofs> fizbin: ah, that's what I was doing wrong, then. I just like gradually improving the code, not having to start from scratch and rewrite everything :)
06:32:15 <SwashBuckla> try not to write any code!
06:32:33 <bernalex> SwashBuckla: hallo simon!
06:32:38 <SwashBuckla> http://harmful.cat-v.org/software/ -- All software sucks
06:32:41 <SwashBuckla> hey bernalex
06:32:43 <SwashBuckla> sup?
06:32:50 <fizbin> bennofs: To be fair, you can sometimes do something like that in Java if the initial component interfaces are well-factored. But then all you're really doing is limiting the "trash it, write from scratch" process to one component at a time.
06:32:55 <bernalex> SwashBuckla: playing some golf: http://lpaste.net/1033765153172094976 -- how about you?
06:33:57 <bennofs> fizbin: yeah, I guess in Java/C++ it really makes sense to spend some time upfront thinking about the design, whereas in Haskell I can just start coding and later worry about the design
06:34:07 <ski> bernalex : define `f' and `b' with several defining equations ?
06:34:10 <SwashBuckla> bernalex: haha, nice. I am at work
06:34:20 <bernalex> SwashBuckla: will it be shorter though?
06:34:24 <bernalex> sorry ski ^
06:34:42 <fizbin> bernalex: One easy simplification is to move "on the wall" into b.
06:34:42 <bernalex> ski: in my current version I uh removed f entirely since it's only used once lol
06:34:48 <bernalex> fizbin: not that easy tho
06:34:57 <bernalex> fizbin: notice that it's not on the wall always
06:35:09 <ski> bernalex : also, rename `f' and `b' to some more meaningful names :)
06:35:15 <SwashBuckla> hahah
06:35:26 <fizbin> bernalex: Missed the one time it isn't.
06:35:28 <bernalex> SwashBuckla: well that certainly won't shave chars :-P
06:35:37 <SwashBuckla> golf xor easy names
06:35:39 <ski> bernalex : it won't waste tokens, either
06:35:54 <SwashBuckla> do they count tokens or filesize?
06:36:05 <ski> why are "they" ?
06:36:06 <fizbin> bernalex: Okay, then (let b' x = b x ++ " on the wall")
06:36:12 <SwashBuckla> the golfers
06:36:16 <bernalex> fizbin: ohhh
06:36:18 <fizbin> And use b' where appropriate.
06:36:19 <bernalex> of course I can just do that
06:36:29 <fizbin> I think the three savings are worth the extra def.
06:36:44 <nyuszika7h> hi, I don't understand the error GHCi is giving - http://lpaste.net/8490640986840498176
06:37:11 <nshepperd> do you ever finish a good productive haskell coding session, only to realise you've actually been doing code golf?
06:37:22 <nyuszika7h> nshepperd: haha
06:37:34 <fizbin> bernalex: Next, make b take a second parameter that is the thing to print after.
06:37:53 * ski . o O ( "Douglas Fredericks and the House of They" by Joe Kelly,Ben Roman in 2009-06-10 at <http://www.comicbookresources.com/?page=preview&id=2784> )
06:38:03 <bernalex> fizbin: yeah I had that thought
06:38:36 <bernalex> right now it's main = forever $ mapM_ putStrLn [b' x ++ ", " ++ b x ++ ". " ++ (if x == 0 then "go to the store and buy some more, " ++ b' 99 ++ "." else "take one down, pass it around, " ++ b' (x-1) ++ ".") | x <- [99,98..0]]
06:38:47 <remdezx> \join #ghc
06:39:21 <bernalex> fizbin: with b' = (++ " on the wall") . b
06:39:53 <fizbin> bernalex: In general, (show x ++ "some text") == (shows x "some text")
06:40:11 <nyuszika7h> bernalex: couldn't you shorten b' to another single-letter variable name to shorten it?
06:40:19 <bernalex> nyuszika7h: of course
06:40:25 <bernalex> c follows b so that's more intuitive
06:41:26 <nyuszika7h> speaking of single letter variable names, off-topic: anyone know if "u" and "v" have any particular meaning? I see it used for greatest common divisor algorithms (gcd(u, v))
06:41:45 <nshepperd> nyuszika7h: try adding a type signature for isEven
06:42:05 <bernalex> main = let b x = (case x of 0 -> "no more bottles" ; 1 -> show x ++ " bottle" ; _ -> show x ++ " bottles") ++ " of beer" ; c = (++ " on the wall") . b in forever $ mapM_ putStrLn [c x ++ ", " ++ b x ++ ". " ++ (if x == 0 then "go to the store and buy some more, " ++ c 99 ++ "." else "take one down, pass it around, " ++ c (x-1) ++ ".") | x <- [99,98..0]]
06:42:10 <bernalex> many readable wow
06:42:28 <ski> nyuszika7h : two problems : (a) you either need to provide a type signature for `isEven', or define it pointful, or enable `NoMonomorphismRestriction'
06:42:56 <ski> nyuszika7h : (b) `binaryGcd' needs `Bits a', which is seen if you do (a)
06:43:19 <nyuszika7h> yeah I noticed that when I added the constraint as suggested
06:43:24 <nyuszika7h> now it works, except it doesn't work right
06:43:27 <nyuszika7h> *Main> binaryGcd 123 456
06:43:28 <nyuszika7h> 1
06:44:34 <nyuszika7h> hi Exio!
06:45:47 <bernalex> I could write b as 'b = (++ " of beer") . ap (flip if' "no more bottles" . (0 ==)) (ap (liftM2 if' (1 ==) ((++ " bottle") . show)) ((++ " bottles") . show))' but I think I'll refrain
06:49:18 <mthvedt> haskell newbie here—is there a simple way to describe an isomorphism between two types? maybe something in lens?
06:49:57 <fizbin> bernalex: I attempted to reply to your lpaste, but accidentally edited it instead; see http://lpaste.net/1033765153172094976
06:50:45 <bernalex> fizbin: yeah I see heh
06:51:12 <ski> @type iso
06:51:13 <lambdabot> (Profunctor p, Functor f) => (s -> a) -> (b -> t) -> p a (f b) -> p s (f t)
06:53:22 <fizbin> bernalex: More characters can be squeezed out by writing c=(.(" on the wall"++)).b
06:54:10 <Sonderblade> mthvedt: an isomorphism is just a function
06:56:08 <mthvedt> Sonderblade: something you can do algebra on, like say you wanted to get the inverse relation yielded by an isomorphism
06:57:31 * hackagebot Spock 0.6.4.0 - Another Haskell web framework for rapid development  http://hackage.haskell.org/package/Spock-0.6.4.0 (AlexanderThiemann)
06:57:57 <Sonderblade> mthvedt: haskell functions aren't invertible
06:58:11 <mthvedt> Sonderblade: …that’s why I’m asking for something else
06:58:46 <fizbin> An isomorphism, as in the type class Iso (part of the lens library) is invertible.
06:59:37 <mthvedt> fizbin: ty
07:00:14 <int-e> bernalex: http://lpaste.net/5645341405120299008 is my attempt (still pretty, many of the spaces can be removed)
07:00:49 <bernalex> int-e: pretty lol
07:00:56 <bernalex> int-e: but yeah this looks nice
07:01:15 <bernalex> int-e: you need to cycle or whatever tho
07:01:22 <bernalex> int-e: notice the forever in my solution
07:01:45 <int-e> bernalex: it does cycle
07:02:07 <bernalex> int-e: ah right yeah I see it
07:02:11 <bernalex> int-e: nice!
07:02:32 * hackagebot process-listlike 0.9 - Enhanced version of process-extras  http://hackage.haskell.org/package/process-listlike-0.9 (DavidFox)
07:07:10 <fizbin> int-e: I think your solution prints "on the wall" too often.
07:09:08 <int-e> fizbin: ah. it prints too little, it misses the repetition of "<n> bottles of beer".
07:11:40 <makalu> has anyone tried to use pandoc for creating man pages? I can't seem to be able to create man pages with headings
07:12:28 <SwashBuckla> makalu: not personally, but there are plenty of nice examples on the website. I think there is also a #pandoc?
07:12:32 <int-e> fizbin: I edited http://lpaste.net/5645341405120299008 to fix that. one more auxilliary function, hmm.
07:13:21 <makalu> SwashBuckla: interesting, thanks. I tried reading the documentation first but wasn't successful.
07:16:40 <fizbin> int-e: Instead of all that ++ , could you do: g n s m = mapM putStr [b n, ", ", c n, s, b m, ".\n"] >> f m
07:16:56 <fizbin> I think that saves enough ++ to be worth it.
07:17:05 <dfeuer> If I say "nomeata" three times, will he appear?
07:17:22 <MagneticDuck> is there any easy way to also export lenses generated by TH? (lens-family-th)
07:18:40 <int-e> dfeuer: it's a matter of timing :)
07:19:20 <MagneticDuck> anybody? :(
07:19:26 <MagneticDuck> okay I'll read the docs
07:19:47 <MagneticDuck> nop, nothing there >:(
07:19:59 <dfeuer> int-e, there's an issue with concat . inits breaking the arity analysis in a rather disastrous fashion--we'd like to know if this will affect other, more important things.
07:20:31 <WraithM> Is there a name for a monad without a return operation? A semimonad or something?
07:22:34 * hackagebot idris 0.9.14.3 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.14.3 (EdwinBrady)
07:26:31 <WraithM> Or does that just not even make sense as a thing?
07:26:44 <dfeuer> Will Microslug ever get the memo and drop this silly "\r\n" thing? That's so 1970s.
07:26:51 <int-e> fizbin, bernalex: ok, final version: http://lpaste.net/2201891524906582016 (including the mapM suggestion)
07:27:02 <mr-> That would be a Semigroup in End. Too bad Semigroup wasn't called Semimonoid
07:27:38 * hackagebot eprocess 1.7.0 - *Very* basic Erlang-like process support for Haskell  http://hackage.haskell.org/package/eprocess-1.7.0 (CorentinDupont)
07:27:40 * hackagebot hint-server 1.4.0 - A server process that runs hint.  http://hackage.haskell.org/package/hint-server-1.4.0 (CorentinDupont)
07:29:27 <int-e> dfeuer: does that apply to all versions of inits?
07:30:42 <dfeuer> int-e, no. I ran into this problem writing a version of inits using a fusible scanl' that nomeata (Joachim) wrote. The problem is this case goes away if inits is made NOINLINE (which is probably perfectly fine) but he was speculating that the problem may be more on the concat side of things.
07:30:59 <dfeuer> And if we have a problem with concat, I think, we have a real problem.
07:32:37 <dfeuer> There's basically nothing to be gained from letting inits fuse with anything in the usual way anyway--there's a nice fusion rule for concat . inits, but no one other than me seems to think it's worth bothering with.
07:33:07 <dfeuer> [That is, a fusion rule totally unrelated to what foldr/build would do to it if allowed]
07:35:21 <int-e> dfeuer: not completely unrelated, I think, if you take the view that  inits xs = map (`take` xs) [0..length xs], then you have something that looks like concatMap.
07:36:43 <dfeuer> int-e, that may make some sense. It's also an inits implementation I'm not sure anyone tried.
07:37:02 <int-e> dfeuer: it's wrong as stated, because 'length xs' is way too strict.
07:37:33 <dfeuer> int-e, ah, yes. And the fix by Bertram turns out to be slower than the Breitner/Feuer initsQ'.
07:37:45 <int-e> dfeuer: my initsT' is very close to that idea.
07:37:54 <dfeuer> I should say Breitner/Kmett/Feuer.
07:38:09 <dfeuer> Yes, I forget that int-e = Bertram sometimes.
07:38:15 <int-e> it's ok :)
07:39:35 <rylev> Has anyone here run Scotty in production? We have some questions around multithreading and whether we need a load balancer in front of it.
07:40:48 <dfeuer> rylev, you might be better of asking when merijn (sp?) is around. He seems to be all about the concurrency.
07:41:03 <dfeuer> But there may be others.
07:42:09 <rylev> dfeuer: thanks!
07:42:40 * hackagebot x509 1.4.12 - X509 reader and writer  http://hackage.haskell.org/package/x509-1.4.12 (VincentHanquez)
07:42:42 * hackagebot twentefp-number 0.1.0.0 - Lab Assignments Environment at Univeriteit Twente  http://hackage.haskell.org/package/twentefp-number-0.1.0.0 (sebaslafleur)
07:42:44 * hackagebot crypto-random 0.0.8 - Simple cryptographic random related types  http://hackage.haskell.org/package/crypto-random-0.0.8 (VincentHanquez)
07:44:13 <nshepperd> > let inits xs = map (`take` xs) (0 : zipWith const [1..] xs) in take 10 (inits [1..])
07:44:15 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1...
07:52:53 <clrnd> :t <$>!
07:52:54 <lambdabot> parse error on input ‘<$>!’
07:52:58 <clrnd> :t (<$>!)
07:52:59 <lambdabot>     Not in scope: ‘<$>!’
07:52:59 <lambdabot>     Perhaps you meant ‘<$>’ (imported from Control.Applicative)
07:56:53 <zq> :t ((<$>) (!))
07:56:55 <lambdabot> (Ix i, Functor f) => f (Array i e) -> f (i -> e)
07:57:07 <zq> :t ((!) <$>)
07:57:08 <lambdabot> (Ix i, Functor f) => f (Array i e) -> f (i -> e)
07:58:10 <zq> is (<$>) always == fmap? strange that Functor instead of Applicative showed up
07:58:33 <barrucadu> <$> is just an infix fmap
07:59:09 <zq> that's not immediately obvious from the applicative laws, though
07:59:30 <barrucadu> <$> isn't part of the applicative typeclass
08:00:52 <dfeuer> @type sequence_
08:00:54 <lambdabot> Monad m => [m a] -> m ()
08:00:59 <zq> nvm, it is obvious from the applicative laws
08:01:14 <dfeuer> @type mapM_
08:01:16 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
08:01:32 <prodolof> .join #topology
08:01:44 <dfeuer> @src mapM_
08:01:44 <lambdabot> mapM_ f as = sequence_ (map f as)
08:02:42 * hackagebot twentefp-number 0.1.0.1 - Lab Assignments Environment at Univeriteit Twente  http://hackage.haskell.org/package/twentefp-number-0.1.0.1 (sebaslafleur)
08:04:18 <prodolof> Can I ask some basic math questions in here (topology)?
08:09:09 <pjdelport> mapM_ f = foldr ((>>) . f) (return ())
08:09:22 <pjdelport> or mapA_ f = foldr ((*>) . f) (pure ())
08:11:02 <MagneticDuck> can anybody help with something attoparsec?
08:12:21 <MagneticDuck> https://github.com/MagneticDuck/CWData/blob/master/src/CWData/Data.hs#L94 is a parser I have that turns "<tag>contents</tag>" into ("tag", "contents
08:12:39 <MagneticDuck> but when I try to use it https://github.com/MagneticDuck/CWData/blob/master/src/CWData/Data.hs#L133 ...
08:13:06 <MagneticDuck> (scoreParser is supposed to take a "<record><tag>contents</tag><tag2>...</record>" and do some stuff with it)
08:13:19 <MagneticDuck> I get a "not enough input" error from attoparsec
08:13:21 <MagneticDuck> any ideas?
08:13:48 <MagneticDuck> that [] should be replaced with contents at line 140
08:14:16 <MagneticDuck> ugh ._.
08:22:09 <phaazon> oh
08:22:38 <phaazon> I feel really surprised to see that much downloads on my logging lib https://hackage.haskell.org/package/monad-journal
08:22:43 <phaazon> it impresses me :–’
08:22:49 <halvorg> Any simple way to validate a path in haskell? i.e. disallow "../../../private.file" and "ÆÅØÅÆÅ{[]¡¡{£[¡@£¡@£.file"
08:22:50 <phaazon> I thought I’d be the single one using that
08:24:57 <MagneticDuck> @faq can haskell validade a path
08:24:57 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
08:25:07 <MagneticDuck> no, that's not the right answer lambdabot
08:25:10 <MagneticDuck> ugh
08:25:16 <MagneticDuck> he's supposed to say "yes, haskell can do that"
08:25:56 <Cale> What's wrong with either of those paths?
08:25:59 <ChristianS> MagneticDuck: lambdabot has become more pessimistic in recent times
08:26:33 <halvorg> Cale: ../../ would be a security issue
08:26:47 <halvorg> different from path validation I agree, but something I want.
08:26:56 <MagneticDuck> well there's a thing on unix...
08:27:03 <MagneticDuck> it's called user permissions or something
08:27:08 <MagneticDuck> you might look into that =P
08:27:11 <Cale> and the other one seems fine too?
08:27:15 <halvorg> man MagneticDuck you a funny guy eh?
08:27:23 <MagneticDuck> please don't kill me
08:27:26 <halvorg> none of those letters are illegal?
08:27:35 <halvorg> guess not
08:27:37 <Cale> cale@ender:~$ touch "ÆÅØÅÆÅ{[]¡¡{£[¡@£¡@£.file"
08:27:37 <Cale> cale@ender:~$ ls Æ*
08:27:37 <Cale> ÆÅØÅÆÅ{[]¡¡{£[¡@£¡@£.file
08:28:16 <MagneticDuck> question: how evil is unsafeCoerceIO?
08:28:37 <Cale> MagneticDuck: Do you mean unsafeCoerce, or unsafePerformIO?
08:28:57 <MagneticDuck> well right now I"m having fun with coercing
08:29:07 <MagneticDuck> it was a rhetorical question
08:29:09 <MagneticDuck> I'm going to hell
08:29:51 <Cale> Well, you can cause arbitrary code execution with unsafeCoerce, and you can write unsafeCoerce with unsafePerformIO.
08:32:48 * hackagebot debian 3.83.4.1 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.83.4.1 (DavidFox)
08:37:48 * hackagebot debian 3.83.4.2 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.83.4.2 (DavidFox)
08:41:59 * MagneticDuck deals with the wonderful wide world of internet transmission error
08:42:28 <MagneticDuck> oh come on, I don't want to add some sort of error catching framework... just don't mess up, IP!!
08:42:49 * hackagebot dice-entropy-conduit 1.0.0.0 - Cryptographically secure n-sided dice via rejection sampling.  http://hackage.haskell.org/package/dice-entropy-conduit-1.0.0.0 (PeterRobinson)
08:45:20 <MagneticDuck> oh wait lols
08:45:27 <MagneticDuck> hGetContents can't read file with unicode?
08:45:30 <MagneticDuck> "invalid byte sequence"
08:45:37 <thinkpad20> hey guys is there a way to disable the storage of consecutive duplicate entries in GHCI command history? It's really annoying to have to scroll up through 20 ":r"s...
08:46:26 <l0cust> MagneticDuck: which hGetContents
08:46:31 <thinkpad20> if it's not there I would pull req it if someone can point me to the relevant part of the code base
08:46:35 <l0cust> MagneticDuck: ByteString?
08:46:45 <l0cust> thinkpad20: hmmm
08:46:47 <funfunctor> anyone good with text.prettyprinter can give me a hand for a sec?
08:46:57 <MagneticDuck> l0cust: just the normal one
08:47:06 <l0cust> MagneticDuck: ah, you really should be using ByteString
08:47:08 <funfunctor> https://gist.github.com/victoredwardocallaghan/7972602ac424165af829 i've kind of made a mess of the layout
08:47:12 <l0cust> MagneticDuck: much faster than String
08:47:17 <MagneticDuck> http://ix.io/e9L
08:47:28 <MagneticDuck> here is the terrible character that hGetContents can't read
08:47:35 <MagneticDuck> l0cust: I'm dealing with small strings >:(
08:47:49 * hackagebot tls 1.2.9 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.2.9 (VincentHanquez)
08:47:50 <MagneticDuck> wait
08:47:53 <MagneticDuck> no character in that file
08:48:04 <l0cust> MagneticDuck: seriously. Never. Use. String.
08:48:09 <MagneticDuck> http://ix.io/e9M
08:48:11 <MagneticDuck> waht
08:48:11 <l0cust> MagneticDuck: ByteString and Text are all you need
08:48:25 <l0cust> MagneticDuck: you suck at pasting
08:48:28 <l0cust> :)
08:48:35 <MagneticDuck> !?!?
08:48:37 <MagneticDuck> wth
08:48:46 <MagneticDuck> http://knucklecracker.com/creeperworld3/scoreQuery.php?gameUID=c5b70f604ac097e5988cd2ee7c786646
08:48:55 <joelteon> When will Data.ByteString be moved to ByteString?
08:49:01 <MagneticDuck> find the sequence "pgh"
08:49:02 <thinkpad20> looking here: https://github.com/ghc/ghc/blob/9692393d7ba91a091c1e61b6754d79ad17c5f193/ghc/GhciMonad.hs#L85 the monad stores the last command, so it would be beyond trivial to just say "when (thisCommand /= last_command) ..."
08:50:28 <MagneticDuck> seriously though
08:50:45 <MagneticDuck> try and read http://knucklecracker.com/creeperworld3/scoreQuery.php?gameUID=c5b70f604ac097e5988cd2ee7c786646 <- this file with readFile (hGetContents and friends)
08:51:04 <MagneticDuck> aren't Strings unicode and such?
08:51:51 <MagneticDuck> l0cust: HELP MEH
08:51:55 <MagneticDuck> will bytestrings fix the problem?
08:51:56 <l0cust> Oh didn't see that
08:52:02 <joelteon> why would you care about unicode with XML?
08:52:15 <l0cust> MagneticDuck: strings are usually unicode
08:52:24 <MagneticDuck> try and replicate my problem
08:52:26 <l0cust> MagneticDuck: the issue is with the implementation, just really inefficient
08:52:26 <joelteon> Oh, I know why
08:52:30 <MagneticDuck> download that file and get it into a ghci session
08:52:34 <joelteon> because there's an invalid byte sequence
08:52:35 <joelteon> that'll do it
08:52:37 <MagneticDuck> yes
08:52:47 <joelteon> yeah, Strings are unicode, that file isn't though
08:52:54 * MagneticDuck checks file
08:53:06 <joelteon> that's why readFile says "invalid byte sequence"
08:53:08 <MagneticDuck> ISO-8859
08:53:16 <MagneticDuck> how I fix
08:53:25 <joelteon> read it with bytestring, decode as latin-1
08:53:29 <l0cust> MagneticDuck: ByteString
08:53:32 <MagneticDuck> nuuuu
08:53:35 <MagneticDuck> nooooe
08:53:37 <MagneticDuck> goodbye String
08:53:38 <l0cust> Took me like 2 seconds
08:53:39 <joelteon> well, don't do it then
08:53:44 <Enigmagic> System.IO.hSetEncoding :P
08:53:47 <l0cust> Bl.readFile "file.xml"
08:54:05 <MagneticDuck> Enigmagic: that works too?!
08:54:12 <MagneticDuck> I just want to do this thing fast
08:54:21 <MagneticDuck> the rest of my program is with Strings
08:54:29 <l0cust> MagneticDuck: ByteString is muy fast
08:54:35 <MagneticDuck> oh well
08:54:36 <joelteon> MagneticDuck: I would recommend taking our advice.
08:54:43 <joelteon> if you don't want to do that, you're welcome to solve it on your own.
08:54:54 <Enigmagic> MagneticDuck: probably
08:55:32 <joelteon> yeah, it works
08:55:34 <MagneticDuck> okay I'll replace String with ByteStrings
08:55:35 <joelteon> just don't use withFile, use openFile
08:56:43 <MagneticDuck> readFile works too?
08:57:07 <MagneticDuck> k
08:57:13 <joelteon> you can't specify an encoding with readFile...
08:57:18 <MagneticDuck> ugh
08:57:51 * hackagebot process-progress 0.14 - Run a process and do reportsing on its progress.  http://hackage.haskell.org/package/process-progress-0.14 (DavidFox)
08:57:53 <l0cust> MagneticDuck: with byteString, you read the raw bytes, convert it to string or text
08:58:01 <l0cust> @hoogle :: ByteString -> String
08:58:03 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
08:58:04 <lambdabot> Data.ByteString.Lazy.Char8 unpack :: ByteString -> [Char]
08:58:04 <lambdabot> Data.ByteString.Char8 head :: ByteString -> Char
08:58:29 <Enigmagic> MagneticDuck: openFile followed by hGetContents does something pretty close to readFile and would allow you to set the handle encoding.
08:59:02 <MagneticDuck> yes I understand
09:04:18 <MagneticDuck> got it working
09:08:38 <edlinde> am trying to make sense of an example in LYAH
09:08:43 <edlinde> >  let listOfFuns = map (*) [0..]
09:08:45 <lambdabot>  not an expression: ‘let listOfFuns = map (*) [0..]’
09:09:15 <josephle> :t map (*) [0..]
09:09:16 <lambdabot> (Num a, Enum a) => [a -> a]
09:09:17 <edlinde> hmm why isn’t that working on lambdabot? :)
09:09:37 <edlinde> > (listOfFuns !! 4) 5
09:09:38 <lambdabot>  Not in scope: ‘listOfFuns’
09:09:39 <benzrf> > let listOfFuns = ["games", "programming"]
09:09:41 <lambdabot>  not an expression: ‘let listOfFuns = ["games", "programming"]’
09:09:42 <josephle> 'let' is somewhat different on lambdabot iirc
09:09:53 <edlinde> ok
09:09:57 <edlinde> then maybe
09:09:59 <benzrf> edlinde: lambdabot expects an expression
09:10:02 <benzrf> not a line in a do-block
09:10:03 <benzrf> use @let
09:10:15 <benzrf> @let -- this line goes into a source file that gets loaded
09:10:20 <lambdabot>  Defined.
09:10:48 <benzrf> @let import Data.Map
09:10:49 <lambdabot>  .L.hs:172:16:
09:10:49 <lambdabot>      Ambiguous occurrence ‘foldr’
09:10:49 <lambdabot>      It could refer to either ‘Data.List.foldr’,
09:10:49 <lambdabot>                               imported from ‘Data.List’ at .L.hs:89:1-16
09:10:49 <lambdabot>                               (and originally defined in ‘GHC.Base’)
09:10:54 <edlinde> > ((map (*) [0..]) !! 4) 10
09:10:56 <lambdabot>  40
09:11:02 <edlinde> ok that worked
09:11:05 <benzrf> >usin (!!)
09:11:07 <edlinde> now when I try something else
09:11:41 <edlinde> > (take 2 (map (*) [0..])) 100
09:11:43 <lambdabot>  Couldn't match expected type ‘a1 -> t’
09:11:43 <lambdabot>              with actual type ‘[a0 -> a0]’
09:11:49 <edlinde> it doesn’t like that
09:11:55 <benzrf> read the error
09:11:55 <josephle> :t (take 2 (map (*) [0..]))
09:11:56 <lambdabot> (Num a, Enum a) => [a -> a]
09:12:53 <edlinde> I don’t get the [a->a]
09:12:55 <benzrf> > (take 2 (map (*) [0..])) <&> 100
09:12:57 <lambdabot>  Could not deduce (GHC.Num.Num ((a0 -> a0) -> b))
09:12:57 <lambdabot>    arising from the ambiguity check for ‘e_120100’
09:12:57 <lambdabot>  from the context (GHC.Num.Num ((a -> a) -> b),
09:12:57 <lambdabot>                    GHC.Num.Num a,
09:12:57 <lambdabot>                    GHC.Enum.Enum a)
09:12:58 <edlinde> what does that mean?
09:12:59 <benzrf> huh
09:13:02 <benzrf> :t (<&>)
09:13:04 <lambdabot> Functor f => f a -> (a -> b) -> f b
09:13:05 <benzrf> oh
09:13:07 <edlinde> its a list of functions?
09:13:12 <josephle> (take 2 (map (*) [0..])) <*> 10
09:13:13 <benzrf> edlinde: yez
09:13:17 <josephle> > (take 2 (map (*) [0..])) <*> 10
09:13:18 <lambdabot>  No instance for (GHC.Show.Show b0)
09:13:19 <lambdabot>    arising from a use of ‘M40386317545112827678754.show_M40386317545112827678...
09:13:19 <lambdabot>  The type variable ‘b0’ is ambiguous
09:13:19 <lambdabot>  Note: there are several potential instances:
09:13:19 <lambdabot>    instance [safe] GHC.Show.Show
09:13:25 <benzrf> josephle: u forgot a pure in there
09:13:26 <edlinde> thats what I thought...
09:13:36 <josephle> benzrf: curses, I knew something was wrong!
09:13:46 <edlinde> then why am I unable to do a take… and that I am expecting should give me a list of functions too right?
09:14:31 <benzrf> edlinde: u can do a takeey
09:14:32 <benzrf> *take
09:14:34 <edlinde> so if I am able to pick just one function by doing a !! 4 on that infinite list of functions
09:14:37 <benzrf> you just cant apply a list
09:14:39 <josephle> you have a list of functions, but the list itself isn't a function
09:14:59 <edlinde> ah i see what you mean
09:15:01 <hnoob> > (map (\x -> x 100) (take 2 (map (*) [0..])))
09:15:02 <lambdabot>  [0,100]
09:15:57 <edlinde> hnoob: not sure I got the (\x -> x 100) part
09:15:59 <Sonderblade> does haskell try to ensure that file handles & similar aren't leaked?
09:16:07 <edlinde> ah is that a lambda fn?
09:16:12 <josephle> yes
09:16:20 <edlinde> ok cool.. haven’t reached that yet
09:16:26 <josephle> it's lambda taking a function x, then applying x to 100
09:16:36 <hnoob> what he said
09:16:40 <edlinde> yep
09:17:16 <edlinde> so we get a list of two fns .. [ (0*), (1*) ]
09:17:22 <edlinde> is that right?
09:17:29 <edlinde> for the (take 2… ) part
09:17:34 <josephle> Sonderblade: without going into details that I have no understanding of, I believe haskell's GC will close file handles when possible
09:17:53 * hackagebot cabal-debian 4.17.4 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-4.17.4 (DavidFox)
09:17:57 <hnoob> yep, I think so.  It won't print if you just do that by itself because print isn't implement for those
09:17:59 <josephle> the devil is in the "when possible"
09:18:15 <hnoob> or 'show', that is
09:18:16 <edlinde> hnoob: yeah I got that error
09:18:48 <monochrom> no matter what Haskell or any programming language does, someone will find a way to re-define "leak" so that programs can leak.
09:19:41 <Sonderblade> josephle: what about other resources like sockets, mutexes and so on?
09:19:43 <josephle> "program safety/correctness", the ever-moving goalpost
09:19:45 <monochrom> for example, in C, "leak" means forget to free(p). in Java and Haskell, you cannot forget to free(p), it's automatic, but people find a new definition of "leak" so that Haskell programs can leak space.
09:20:19 <josephle> Sonderblade: those will be GC'd too, but if you don't do it explicitly you're at the mercy of the runtime system
09:20:29 <monochrom> for example, in Haskell, foldl (+) can "leaks space". but not in the C's sense of "leak".
09:21:05 <Enigmagic> Sonderblade: it's preferrable to use functions that guarantee deterministic cleanup of resources (handles, sockets, etc)
09:21:17 <hnoob> in both cases they'd run fine on a machine with infinite resources
09:21:41 <Enigmagic> sockets aren't infinite ;-)
09:23:30 <Sonderblade> Enigmagic: for sure, but in "the real world" it's not always working like that
09:24:05 <Enigmagic> Sonderblade: what's not? writing programs that close sockets explicitly?
09:24:21 <monochrom> "the real world" is what you make of it. you have control.
09:24:49 <Sonderblade> Enigmagic: yes
09:25:11 <Enigmagic> Sonderblade: if you're dealing with legacy, then sure. there are plenty of libraries to help do it nowadays.
09:26:42 <Sonderblade> a switch that throws an error when the gc finds a leaked handle would be nice
09:26:49 <Sonderblade> but not sure how doable that is
09:27:41 <edlinde> are lambda fns always returning functions?
09:28:04 <sipa> > (\x -> 5) 3
09:28:06 <lambdabot>  5
09:28:08 <sipa> No.
09:28:09 <edlinde> or the datatype of what they return depends on the type definition of the function?
09:28:36 <edlinde> hmm ok in LYAH it said that its returning a function
09:28:40 <sipa> a lambda expression is just an anonymous function
09:28:50 <sipa> the lambda itself returns a function
09:28:55 <jfischoff> edlinde: it is probably best to think of functions as “reducing” vs. “returning”
09:28:57 <sipa> that returned function can do anything
09:29:26 <edlinde> jfischoff: whats the difference?
09:29:42 <Enigmagic> Sonderblade: not really possible, anything relying on unsafeInterleaveIO (like hGetContents) relies on the finalizer to close handles
09:29:44 <edlinde> sipa: so by “the lambda” you are referring to the “\” symbol right?
09:30:22 <Enigmagic> Sonderblade: you could do it with a datatype that wraps Handle though..
09:30:29 <edlinde> sipa: so in your example the lambda fn is returning Int right?
09:30:39 <Enigmagic> but at that point you may as well just use a resource finalization library ;-)
09:30:44 <sipa> edlinde: yes
09:30:46 <edlinde> ok
09:31:09 <edlinde> In LYAH: The expression (\xs -> length xs > 15) returns a function that tells us whether the length of the list passed to it is greater than 15.
09:31:10 <jfischoff> edlinde: In Haskell functions are expressions that reduce. They either termintate and produce a normal form, a value, or they diverge and recurse forever.
09:31:25 <edlinde> thats the part that threw me off .. is that right though?
09:31:35 <sipa> edlinde: yes
09:31:47 <edlinde> I thought it just returns True or False
09:32:12 <sipa> if you pass it a list, it will reduce to True or False
09:32:14 <monochrom> edlinde: read my http://www.vex.net/~trebla/haskell/prerequisite.xhtml#function . equal, not return.
09:32:22 <sipa> > (\xs -> length xs > 15) [1,2,3,4]
09:32:24 <lambdabot>  False
09:32:32 <sipa> > (\xs -> length xs > 15) [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]
09:32:34 <lambdabot>  True
09:32:35 <edlinde> jfischoff: ok
09:32:42 <jfischoff> edlinde: in a language like C the functions are a list of statements, and they might produce a value for the caller to consume.
09:32:51 <sipa> > (\xs -> length xs > 15)
09:32:53 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
09:32:53 <lambdabot>    arising from a use of ‘M80276005443130128819017.show_M80276005443130128819...
09:32:53 <lambdabot>  The type variable ‘a0’ is ambiguous
09:32:53 <lambdabot>  Note: there are several potential instances:
09:32:53 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
09:33:09 <Sonderblade> Enigmagic: no, the idea is to force the programmer to write hClose somewhere after hGetContents or else suffer an error
09:33:30 <jfischoff> edlinde: on the other hand Haskell functions always reduce to a value, if they terminate at all.
09:34:18 <edlinde> ok I will read that link monochrom passed me
09:34:19 <Enigmagic> Sonderblade: if you have access to the handle at some point in the future you can use a resource finalization library..
09:34:37 <edlinde> I have a C programming background too.. so got to think more maths and less programming :)
09:35:18 <sipa> edlinde: yes; don't think of a function as a definition of a piece of code with a name
09:35:34 <edlinde> but more as a math fn?
09:35:35 <sipa> edlinde: a function is any expression that evaluates to an expression of a function type
09:35:40 <Enigmagic> Sonderblade: lots of legacy apps assume that lazy IO will clean up the handles when the finalizer runs, so there is no way to even recover the Handle value, let alone close it explicitly
09:35:45 <sipa> 'id' is a function
09:35:48 <sipa> (+) is a function
09:35:55 <sipa> (\x -> x * 3) is a function
09:35:56 <monochrom> yes, math function
09:36:18 <monochrom> except that anonymous functions are also possible
09:36:52 <jfischoff> edlinde: C has statements and expressions, but Haskell (after do notation desugaring) just has expressions. It has less to do with math, and more to do with the syntatical properties of the languages.
09:36:58 <Sonderblade> Enigmagic: yes, but as he have resolved, not calling hClose after hGetContents is still a programming error, right?
09:36:58 <yyttr3> Is there a way to make a subrange type in haskell? I want to encode a range into a type.
09:37:25 <Enigmagic> Sonderblade: no, it is not an error. it's a "feature" of lazy IO.
09:37:32 <c_wraith> Sonderblade: actually, calling hCLose after hGetContents is very suspicious.
09:37:38 <edlinde> ok so basically think of everything as an expression
09:38:12 <athan> is it wise to put constraints in data declarations?
09:38:32 <c_wraith> athan: in general, it doesn't do what yout hink
09:38:41 <athan> c_wraith: ):
09:38:45 <athan> thank you!!
09:38:59 <Sonderblade> then if you *dont* call hClose, then when will the hGetContents file be closed?
09:39:15 <c_wraith> Sonderblade: either when you read the full file, or when the string is garbage collected
09:39:25 <pablo|> does anyone know why Data.List.sum is implemented as a foldl/explicit recursion and not just foldr?
09:39:37 <pablo|> right now sum doesn't get fused, a foldr would
09:40:09 <c_wraith> pablo|: efficiency. Fusion isn't the only metric
09:40:18 <jfischoff> edlinde: Yeah pretty much, well not everything there are declaractions, annotations, lots of top level constructs.
09:40:20 <c_wraith> pablo|: (however, in GHC 7.10, foldl will fuse)
09:40:30 <Sonderblade> c_wraith: when is the string garbage collected?
09:40:32 <edlinde> ok
09:40:33 <pablo|> c_wraith: yay!
09:40:35 <yyttr3> How do you specify a type as a subrange of another type? Like I want the letters between a-z as a type in and of themselves.
09:41:29 <c_wraith> Sonderblade: it maybe garbage collected some time after there are no longer any live references to it.  It may not.  garbage collection is nondeterministic.
09:41:35 <c_wraith> *may be
09:41:49 <jfischoff> yyttr3: Haskell’s type system is not setup for that type of thing, although you can encode it with singletons.
09:42:04 <c_wraith> Sonderblade: if you're thinking this is bad for when you want to read from lots of files - yes, lazy IO is bad for when you want to read from lots of files.
09:42:12 <jfischoff> yyttr3: it is inconvient
09:43:08 <edlinde> http://www.vex.net/~trebla/haskell/prerequisite.xhtml : Didn’t get the Interlude example
09:43:20 <edlinde> with the rand(6) + rand(6)
09:43:23 <edlinde> :)
09:43:38 <monochrom> do you understand it now?
09:43:54 <edlinde> monochrom: nope
09:44:04 <edlinde> the example isn’t making sense to me
09:44:31 <yyttr3> jfischoff : Thank you, that's really disappointing.
09:44:33 <monochrom> if f(x)=x+x, then f(rand(6)) = rand(6) + rand(6). do you agree?
09:44:36 <edlinde> This forbids rand(6) from being different numbers at different times (e.g., random number) or performing I/O. ...
09:44:40 <edlinde> that part esp
09:44:46 <edlinde> monochrom: yes I do
09:45:38 <Sonderblade> c_wraith: just holding one file open for an indeterministic time seems bad enough to me
09:45:43 <edlinde> I didn’t get from the example how Haskell is upholding Leibniz’s substitutability principle
09:46:03 <monochrom> by insisting that rand(6) is always the same number
09:46:03 <jfischoff> yyttr3: Idris can probably do better
09:46:54 <edlinde> hmm
09:46:58 <c_wraith> Sonderblade: In many cases, your program will open a file, do some stuff, and then finish - all without pausing.  In that case, why does it matter if it closes the file descriptor or not?  (It doesn't matter unless you run out of available file descriptors)
09:47:08 <edlinde> but is that the right way?
09:48:39 <monochrom> there are two parts. the first part is that rand(6) does not change. the second part is that you still need a provision for effects and random generators.
09:48:41 <edlinde> I mean in reality will you have “rand(6) + rand(6)” always be say “3+3”?
09:48:52 <monochrom> in haskell yes
09:48:52 <joelteon> define the rand() function in haskell
09:48:57 <yyttr3_> j
09:49:00 <joelteon> how would it return a different value
09:49:09 <monochrom> in C no, but C is not my reality.
09:49:36 <monochrom> anyway, my article say that it will not talk about the second part.
09:49:42 <edlinde> ok :)
09:49:55 <edlinde> where do I get the story behind part 2?
09:49:58 <monochrom> "I won't describe it here" do you see that?
09:50:11 <monochrom> http://www.vex.net/~trebla/haskell/IO.xhtml
09:50:53 <joelteon> anyway, randRIO (0,6) == randRIO (0,6)
09:51:36 <edlinde> yep saw that part
09:52:20 <Sonderblade> c_wraith: in programs like that it doesn't matter, doesn't matter if they have memory leaks either or is unsafe in other ways
09:53:37 <c_wraith> Sonderblade: and lazy IO is a bad hack to make programs like that easy.  I really wish getContents/readFile/etc weren't made so easy to use - people mistake them for anything other than cheap hacks.
09:53:38 <kludgy> joelteon: Operationally, think about what happens if you follow this pattern: rand(rand(6)), rand(rand(rand(6))), rand(rand(rand(rand(6))))... call 6 your seed. The trick is coming up with a more convenient notation and efficient execution for generative evaluation of the series.
09:53:55 <joelteon> I don't see what that has to do with this
09:54:51 <monochrom> kludgy: joelteon's question was a guiding question.
09:55:06 <kludgy> monochrom: whoops :)
09:57:18 <mbrock> yyttr3_: what you can easily do is create a newtype wrapper with constructors that verify the range; then you will know that any such value is within the range, but at some point you will need to check the inclusion at runtime
09:57:57 * hackagebot rest-gen 0.15 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.15 (AdamBergmark)
09:57:58 <mbrock> yyttr3_: this still gives you a lot of safety. statically verifying that a value is within a certain range is not an easy problem, and solutions involving dependent types will have you writing proofs and stuff
09:57:59 * hackagebot rest-happstack 0.2.10.2 - Rest driver for Happstack.  http://hackage.haskell.org/package/rest-happstack-0.2.10.2 (AdamBergmark)
10:01:33 <yyttr3_> mbrock: Thank you!
10:02:34 <mbrock> yyttr3_: so you would have a module that exports the name of the newtype -- not its constructor -- and a function such as Char -> Maybe LimitedChar, and probably LimitedChar -> Char
10:02:58 * hackagebot command 0.1.1 - Conveniently run shell commands  http://hackage.haskell.org/package/command-0.1.1 (NiklasHambuechen)
10:03:41 <yyttr3_> I was thinking about doing something similar, having a type synonym for Char and a function  f:: Char -> Maybe LimitedChar
10:04:12 <c_wraith> yyttr3_: if it's just a type synonym, that won't give you safety.  a newtype would
10:04:40 <yyttr3_> c_wraith: I'm a bit new to haskell, how would that give any extra type safety?
10:05:08 <c_wraith> yyttr3_: type synonyms create new names for a type that can be used interchangeably with the original
10:05:30 <c_wraith> yyttr3_: newtype creates a... well... new type... that can't be used interchangeably with what it wraps
10:05:30 <yyttr3_> c_wraith: I see,
10:07:59 * hackagebot MazesOfMonad 1.0.9 - Console-based Role Playing Game  http://hackage.haskell.org/package/MazesOfMonad-1.0.9 (JeanPhilippeMoresmau)
10:08:47 <Fuuzetsu> I'm looking at the default cereal Serialize instance and I'm getting some empty bytes where I don't expect them
10:08:48 <Fuuzetsu> *Network.HsTorrent.Peer> Data.ByteString.unpack $ runPut $ put ("abc")
10:08:49 <Fuuzetsu> [0,0,0,0,0,0,0,3,97,98,99]
10:08:56 <Fuuzetsu> what are the leading 0s for?
10:09:48 <merijn> Fuuzetsu: Binary uses it's own specific encoding tags
10:10:03 <merijn> Fuuzetsu: If you need to match an existing format (like me), don't use get/put
10:10:04 <Fuuzetsu> guess I have to write the instance by hand
10:10:06 <c_wraith> doesn't Binary use a well-known format now?
10:10:15 <merijn> Fuuzetsu: No, an instance won't work
10:10:17 <c_wraith> Or is that still an upcoming change?
10:10:21 <Fuuzetsu> merijn: why?
10:10:33 <merijn> Fuuzetsu: I did that and spend 2 hours at the haskell meetup debugging why my code didn't work
10:10:46 <merijn> Fuuzetsu: Because the get/put of the Binary class still inserts it's own junk
10:10:59 <Fuuzetsu> this is Serialize, not Binary
10:11:00 <merijn> Fuuzetsu: If you wanna use an existing protocol use explicit Get and Put
10:11:15 <merijn> Fuuzetsu: Oh, in that case, use Binary and then do what I said ;)
10:11:29 <Fuuzetsu> why can't I just use Serialize but define instance myself?
10:11:32 <merijn> I'm pretty sure Serialize does the same thing
10:11:53 <yyttr3_> Is there at least a way to define some generic array of types? Like if I want to declare a type with 100 instances but I don't care about their names, I just want a way to easily refer to them
10:11:58 <merijn> Fuuzetsu: You can define an instance yourself, but I'm pretty sure Serialize (like Binary) inserts it's own junk
10:12:23 <Fuuzetsu> I don't think it does, guess I have to try
10:12:23 <merijn> Fuuzetsu: But anyway, afaik cereal is on the way to being deprecated by binary
10:12:27 <Peaker> Does anyone know if the Mu dialect of Haskell is unboxed for everything or boxed like GHC?
10:12:34 <Fuuzetsu> merijn: oh
10:12:43 <kuribas> Can I use quickcheck like property checking on a fixed set of testcases?  For example I want to test bezier curves, so I want all degenerate cases to be checked.
10:12:50 <merijn> Fuuzetsu: binary now supports incremental decoding using strict ByteStrings too
10:12:57 <Peaker> I dream of an aggressively-unboxing GHC
10:13:15 <merijn> Fuuzetsu: The only thing it doesn't support is encoding to strict ByteString, but that's easily solved by encoding lazily and adding "toStrict" at the end
10:13:48 <Fuuzetsu> does that hurt performance?
10:13:54 <jfischoff> Peaker: yeah, but I find with enough strictness most things unbox though. Is there some particular that is not?
10:14:21 <merijn> Fuuzetsu: I've been informed encoding to lazy is much more efficient than encoding strict, so the toStrict should be less expensive than encoding strict in the first place
10:14:27 <Peaker> jfischoff: Imagine things like Binary.get.  In C, I can just cast a bytestring to my struct
10:14:29 <merijn> Fuuzetsu: But I don't have numbers to back that up :)
10:14:39 <Fuuzetsu> ok
10:14:44 <Peaker> jfischoff: in Haskell, there's a whole lot of boxing going on to build the data-types
10:14:45 <jfischoff> Peaker: oh yeah, that would be cool
10:14:58 <jfischoff> definitely
10:15:05 <Peaker> jfischoff: all polymorphic fields in data types cannot be unboxed
10:15:12 * jfischoff nods
10:15:18 <Peaker> Lazy fields *could* be unboxed if they just steal a single bit from the unboxed representation
10:15:20 <merijn> Peaker: I looked into doing unboxed structs in Haskell at some point
10:15:39 <merijn> Peaker: I'm convinced it's possible, but didn't have time to get any prototype working
10:16:58 <Peaker> merijn: it sounds like a huge project to do this in ghc
10:17:24 <jfischoff> Peaker: I think there a lot of trade-offs when you go in that direction. Rust seems like the most promising language in that direction
10:17:59 <Peaker> jfischoff: I think C++ went all-in the unboxed approach, and it paid off
10:18:43 <Peaker> (i.e: not that much of a trade-off, unboxed >> boxed :-) )
10:18:52 <nshepperd> you can also use binary to decode lazily, but you have to write the State.Lazy wrapper yourself currently
10:18:55 <Peaker> compile-times may be a trade-off, though Haskell compile times are atrocious anyway :)
10:20:07 <nshepperd> maybe I should upload what I wrote for that somewhere
10:27:32 <lpvb> <|> in parsec and <|> in applicative have the same effect right?
10:28:31 <Peaker> lpvb: I think so, but "many" from Parsec is slightly different from "many" in Applicative and possibly other functions differ too
10:29:16 <lpvb> okay
10:39:02 <sm> Peaker: how is "many" different ?
10:40:18 <Peaker> sm: Parsec's "many" validates that the parser given is not empty
10:40:43 <Peaker> btw, when writing Parsec, you have to be careful to structure your parser in a way that avoids exponential behavior, lots of backtracking, etc..
10:41:31 <Peaker> Has anyone written a CFG parser rather than a Turing Complete parser, using an Applicative composition (with some extensions, e.g: explicit "fix") so that the parser can be checked and compiled to an efficient state machine?
10:41:35 <merijn> Peaker: Well, for C style structs it should be fairly easy, no? GHC has primitives manipulating byte arrays already, etc.
10:41:39 <Peaker> and then you can structure it more modularly in any way you want?
10:42:00 <Peaker> merijn: but you can't really have nice ordinary data-types that come from efficient no-op deserialization as you can in C
10:42:15 <merijn> Peaker: How would that even work for haskell?
10:42:42 <merijn> Peaker: GHC/haskell don't guarantee a type has any specific runtime representation
10:42:51 <Peaker> merijn: well, it could
10:42:56 <merijn> Peaker: Hell, it's not even guaranteed that a type *has* a runtime representation
10:42:59 <Peaker> merijn: it could at least guarantee a self-compatible format
10:43:11 <Peaker> merijn: C is similar in that regard
10:43:21 <merijn> Peaker: That would mean losing vectorised returns, etc.
10:43:42 <merijn> Peaker: No it's not, C at least guarantees that a struct will exist at runtime
10:44:07 <c_wraith> Peaker: it might be possible in haskell, but it'd never be in GHC.  the thunk implementation GHC uses is too pointer-oriented, and unlikely to change
10:44:08 <Fuuzetsu> *Network.HsTorrent.PeerSpec> :t BS.length
10:44:09 <Fuuzetsu> BS.length :: BS.ByteString -> Int
10:44:09 <Fuuzetsu> *Network.HsTorrent.PeerSpec> :t BSL.length
10:44:11 <merijn> Peaker: GHC does not guarantee an ADT will actually exist at runtime if it gets compiled to vectored returns
10:44:11 <Fuuzetsu> BSL.length :: BSL.ByteString -> GHC.Int.Int64
10:44:14 <Fuuzetsu> WHY
10:44:17 <Fuuzetsu> WHY
10:44:18 <Peaker> merijn: C doesn't guarantee anything will exist at any time :)
10:44:33 <Fuuzetsu> why the hell does the lazy BS return different type for length than the strict one
10:44:34 <Peaker> merijn: it's allowed to compile it all away to nothing
10:44:37 <Fuuzetsu> who thought this was a good idea
10:44:39 <merijn> Fuuzetsu: Because Bytestring are not bounded
10:44:46 <merijn> Fuuzetsu: *lazy*
10:44:58 <Fuuzetsu> OK, I see now
10:45:00 <merijn> Fuuzetsu: There was a discussion to change the length/other operations to Int64 too
10:45:34 <merijn> Fuuzetsu: But strict ByteString are only guaranteed to work with length up to machine int size, lazy bytestrings can be longer
10:46:11 <merijn> Peaker: I can take address of a struct member, which means the struct member has to exist somewhere
10:46:24 <Fuuzetsu> doesn'th this mean BSL.length should return Integer?
10:46:47 <merijn> Fuuzetsu: Well, they are bounded, I guess, but at Int64, regardless of machine word size :)
10:46:58 <Fuuzetsu> ;P
10:47:07 <merijn> And really, will you need ByteString's longer than Int64? :)
10:47:24 <RchrdB> Fuuzetsu, no, because it'll take about a century to count from 0 up to 2<<64 at 1GHz.
10:48:08 <RchrdB> > (2^64) / (86400*365.25)
10:48:09 <lambdabot>  5.845420460906263e11
10:48:19 <RchrdB> > (2^64) / (86400*365.25*1e9)
10:48:20 <lambdabot>  584.5420460906264
10:48:27 <RchrdB> Oh, five centuries.
10:49:04 <clrnd> nice
10:49:05 <Fuuzetsu> RchrdB: Well, right, I'm aware of that, just saying in principle
10:49:07 <cow_2001> o-o
10:49:48 <cow_2001> how did you get 86400?
10:49:56 <RchrdB> > 24 * 60 * 60
10:49:58 <lambdabot>  86400
10:50:03 <cow_2001> hm
10:50:08 <cow_2001> i see
10:50:11 <RchrdB> Seconds in a day.
10:50:17 <cow_2001> thanks :)
10:51:00 <cow_2001> wow, that's longer than i had imagined.
10:51:19 <Peaker> merijn: you can take the address of a struct member, but that address only has to be "real" in so far that it is unique and that it addresses that field when you dereference
10:51:35 <RchrdB> > map product . tails $ [365.25, 24, 60, 60, 1]
10:51:37 <lambdabot>  [3.15576e7,86400.0,3600.0,60.0,1.0,1.0]
10:52:04 <RchrdB> oh and handy rule,
10:52:15 <Peaker> merijn: for example:  struct foo x; *(&x.y)=1; printf("%d\n", x.y);  <-- entirely conceivable that this gets compiled to: puts("1\n");]
10:52:40 <catsup>     <command line>: can't load .so/.DLL for: ${PWD}/.cabal-sandbox/lib/i386-linux-ghc-7.8.3/SDL-ttf-0.6.2/libHSSDL-ttf-0.6.2-ghc7.8.3.so (${PWD}/.cabal-sandbox/lib/i386-linux-ghc-7.8.3/SDL-ttf-0.6.2/libHSSDL-ttf-0.6.2-ghc7.8.3.so: undefined symbol: TTF_Linked_Version)
10:52:48 <Peaker> merijn: C compilers have to give the proper illusion of the semantics, they don't have to commit to any operational behavior w.r.t memory, afaik
10:52:57 <catsup> SDL-ttf was compiled with -dynamic-too
10:53:07 <catsup> why doesn't this work??
10:53:10 <Denommus> hm, is there any version of the frag game that compiles?
10:53:22 <benzrf> sup Denommus
10:53:40 <Denommus> benzrf: hey
10:53:55 <RchrdB> > ((100*365.25*24*60*60)/1e9) / (pi) -- pi seconds ~= a nano-century
10:53:56 <lambdabot>  1.0045096064233592
10:55:00 <RchrdB> Peaker, arguably they do have to commit to operational behaviour under certain circumstances, foremost: to satisfy the requirements of the platform's C ABI when performing run-time linking.
10:55:25 <Peaker> RchrdB: sure -- though so does ghc
10:55:26 <RchrdB> "To satisfy the platform's C ABI when performing separate compilation" used to be a thing too, but cross-module optimisation blurs it.
10:55:35 <Peaker> RchrdB: I don't think Haskell and c differ in this regard
10:56:24 <cow_2001> RchrdB: where do you get tails
10:56:31 <cow_2001> @hoogle tails
10:56:33 <lambdabot> Data.List tails :: [a] -> [[a]]
10:56:33 <lambdabot> Data.ByteString tails :: ByteString -> [ByteString]
10:56:33 <lambdabot> Data.ByteString.Char8 tails :: ByteString -> [ByteString]
10:56:35 <RchrdB> They do a little. There isn't a standard platform ABI for Haskell, and it's not expected that you should be able to link code compiled with YHC or AJHC against dynamic libraries compiled with GHC.
10:56:37 <catsup> i've been unable to write code for days because of ghc linker problems
10:56:49 <cow_2001> oh.
10:56:51 <cow_2001> wow.
10:56:52 <catsup> i am losing my mind from the constant frustration
10:57:18 <RchrdB> On the other hand, there IS a standard platform ABI for C, and you ARE expected to be able to link code compiled using gcc against dynamic libraries compiled with clang or vice-versa.
10:57:58 <RchrdB> (or tcc, icc, AMD's C compiler whose name I forget...)
10:58:10 <Denommus> benzrf: how are you doing?
10:58:19 <catsup> RchrdB: so you understand the ghc 7.8 linker behavior?
10:58:34 <merijn> catsup: ghc7.8 uses the system linker
10:58:36 <catsup> RchrdB: please help me, i am desperate
10:58:41 <catsup> merijn: yes i know
10:58:57 <RchrdB> catsup, what does "ldd ${PWD}/.cabal-sandbox/lib/i386-linux-ghc-7.8.3/SDL-ttf-0.6.2/libHSSDL-ttf-0.6.2-ghc7.8.3.so" print?
10:59:00 <catsup> i have spent three days doing nothing but reading about it
10:59:14 <benzrf> Denommus: pretty good
10:59:19 <benzrf> ive been learnin me some math
10:59:37 <Peaker> catsup: are you using SDL or is it in a dependency of yours?
10:59:48 <Denommus> benzrf: and I have been learning about FRP
10:59:57 <catsup> RchrdB: it doesn't show sdl-ttf, look:
10:59:58 <catsup> $ ldd ${PWD}/.cabal-sandbox/lib/i386-linux-ghc-7.8.3/SDL-ttf-0.6.2/libHSSDL-ttf-0.6.2-ghc7.8.3.so|grep -i sdl | sed "s?${PWD}?"'${PWD}?g'
11:00:01 <catsup>         libHSSDL-0.6.2-ghc7.8.3.so => ${PWD}/.cabal-sandbox/lib/i386-linux-ghc-7.8.3/SDL-0.6.2/libHSSDL-0.6.2-ghc7.8.3.so (0xb7705000)
11:00:04 <catsup>         libSDL-1.2.so.0 => /usr/lib/i386-linux-gnu/libSDL-1.2.so.0 (0xb6f31000)
11:00:25 <benzrf> i'd just like to interject for a moment. what you are referring to as frp is actually dctp
11:00:40 <benzrf> Denommus: any particular framework
11:00:44 <catsup> Peaker: yeah i'm using SDL, i am building with cabal, SDL is listed
11:00:59 <catsup> it also succeeds linking SDL right before failing SDL-ttf
11:01:31 <Denommus> benzrf: no, I was trying to apply it on Rust to create a library, but closures in Rust are still too unstable. And I guess that, even if they solve the issues, they'll still be too restrictive
11:01:37 <benzrf> huh
11:02:00 <benzrf> what do you need from closures to implement frp that rust doesnt give you?
11:02:18 <Denommus> benzrf: I can't return closures yet. The compiler breaks
11:02:54 <benzrf> dang
11:03:00 <benzrf> downward-funargs only?
11:03:01 <Peaker> catsup: I suggest using GLFW-b and opengl rather than SDL, I think it's easier to set up
11:03:02 <josephle> I thought unboxed closures were just released?
11:03:05 <phaazon> is there an easy way to “cache” something in a function by partially apply it?
11:03:10 <Peaker> catsup: and was faster (not sure if it still is)
11:03:22 <phaazon> for instance, foo a b c ; make (foo a b) internals compute only once, for all c
11:03:29 <Denommus> josephle: yes, but they still have too many issues. Anyway, this is getting too offtopic
11:03:44 <mokkake> hi, is there a "instance Show (a -> b)" such as: show f = "f" ?
11:03:49 <catsup> i think i had problems with that as well :/  i don't really remember what tho
11:03:51 <Denommus> I'm looking at Yampa and Helm for inspiration, though. And I was trying to compile frag to check a running game made with AFRP
11:03:58 <Denommus> but the code is too old, and too broken :-/
11:04:00 <Peaker> mokkake: that would be a useless instance?
11:04:15 <mokkake> Peaker: why ? i need to show the name of my function
11:04:28 <phaazon> isn’t (a -> b) Typeable?
11:05:06 <mokkake> i didn't used Typeable yet, can it help me ?
11:05:16 <catsup> i tried a whole bunch of stuff and wrote an application using gloss (which uses glut by default or glfw optionally) on osx
11:05:18 <phaazon> mokkake: for functions, I don’t know, but for anytime, yeah
11:05:21 <Peaker> mokkake: you mean you want it to show names of functions, not "f" everywhere?
11:05:25 <phaazon> > typeOf (1,3)
11:05:26 <lambdabot>  (Integer,Integer)
11:05:31 <phaazon> > typeOf show
11:05:32 <lambdabot>  () -> [Char]
11:05:35 <catsup> but when i ran the gloss application on linux, the input handling was broken
11:05:37 <mokkake> Peaker: yes, show show = "show"
11:05:37 <Peaker> mokkake: what would the name of ((\x -> x) . foo) be?
11:05:42 <rom1504> typeOf phaazon
11:05:50 <rom1504>  > typeOf phaazon
11:06:03 <rom1504> bah..
11:06:09 <phaazon> you can’t get the type of a polymorphic value ;)
11:06:14 <phaazon> phaazon is polymorphic
11:06:16 <benzrf> > typeOf phaazon
11:06:16 <phaazon> it could be anything
11:06:18 <lambdabot>  Not in scope: ‘phaazon’
11:06:22 <benzrf> phaazon: ur not in scope
11:06:22 <benzrf> get out
11:06:26 <catsup> (plus gloss has limitations i need to get around, especially with fonts)
11:06:26 <phaazon> > typeOf "phaazon"
11:06:27 <lambdabot>  [Char]
11:06:28 <phaazon> ahah benzrf
11:06:57 <mokkake> Peaker: well… (a -> b) -> Maybe String ? :p returning Nothing for anonymous functions
11:07:03 <mokkake> i think i lost myself
11:07:20 <neothemachine> Hi,
11:07:21 <mokkake> this is quite undoable… maybe TemplateHaskell
11:07:48 <monochrom> there is no way to recover the name of functions
11:07:59 <benzrf> funkshuns dont even have names
11:08:16 <benzrf> functions are values, values dont know about variables
11:08:17 <phaazon> > tyConName . typeRepTyCon $ typeOf show
11:08:18 <lambdabot>  "(->)"
11:08:22 <phaazon> yeah.
11:08:29 <oisin765> I want to write a data type that looks like: data World = World { wTerrain :: ...container of some type... }, where the container can easily be swapped out for a List, Quadtree, Octree, etc. Would I use a typeclass for this and what would be the easiest / nicest way to do so?
11:08:37 <phaazon> > tyConString . typeRepTyCon $ typeOf show
11:08:38 <lambdabot>  "(->)"
11:09:19 <neothemachine> I have some trouble getting aeson (0.3.2.11) built on ghc 7.4.2 within travis ci, I'm not doing anything special, someone have an idea? https://travis-ci.org/adp-multi/adp-multi/jobs/34132803#L407
11:09:25 <phaazon> > let plouf = id in typeOf plouf
11:09:26 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
11:09:27 <lambdabot>    arising from a use of ‘Data.Typeable.Internal.typeOf’
11:09:27 <lambdabot>  The type variable ‘a0’ is ambiguous
11:09:27 <lambdabot>  Note: there are several potential instances:
11:09:27 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
11:09:36 <phaazon> > typeOf id
11:09:37 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
11:09:37 <lambdabot>    arising from a use of ‘Data.Typeable.Internal.typeOf’
11:09:37 <lambdabot>  The type variable ‘a0’ is ambiguous
11:09:37 <lambdabot>  Note: there are several potential instances:
11:09:37 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
11:09:46 <phaazon> > typeOf (id :: Int -> Int)
11:09:47 <lambdabot>  Int -> Int
11:09:57 <mokkake> what if i pattern-match the function name somehow
11:10:06 <phaazon> nope
11:10:07 <mokkake> yea… no
11:10:13 <phaazon> maybe with Data.Reflection
11:10:18 <phaazon> I don’t know that module very well
11:10:30 <phaazon> or with some TH ;)
11:10:49 <RchrdB> catsup, just to check the blindingly obvious, /usr/lib/i386-linux-gnu/libSDL_ttf.so exists, right? and "objdump -T /usr/lib/i386-linux-gnu-libSDL_ttf.so | grep TTF_Linked_Version" prints a line like "0000000000002880 g    DF .text	000000000000001d  Base        TTF_Linked_Version"?
11:11:09 <mokkake> yes, i was thinking about TH too. Data.Reflection seems quite heavy… I'll figure out a solution, thanks for your help ! :)
11:12:19 <phaazon> hm
11:12:21 <phaazon> > 'id
11:12:22 <lambdabot>  Syntax error on 'id
11:12:23 <lambdabot>  Perhaps you intended to use TemplateHaskell
11:12:30 <phaazon> yeah I was.
11:12:53 <stolaruk> On Mac OS X 10.9.4, I get "bind: permission denied" when I try to "listenOn" port 23. Anyone know how to get around this issue?
11:12:56 <phaazon> Prelude Data.Typeable> let foo = bar where bar = id
11:12:56 <phaazon> Prelude Data.Typeable> 'foo
11:12:56 <phaazon> foo_1627406946
11:12:58 <phaazon> hm :D
11:13:01 <phaazon> good luck with that :D
11:13:08 * hackagebot network-uri 2.5.0.0 - URI manipulation  http://hackage.haskell.org/package/network-uri-2.5.0.0 (JohanTibell)
11:14:06 <phaazon> off, see you
11:14:32 <RchrdB> catsup, oh and what OS are you using, please? 32-bit Ubuntu or something?
11:14:54 <cpennington> oisin765: data World c = World { wTerrain :: c, ... }
11:15:12 <cpennington> and then functions that operate on wTerrain can constrain c using typeclasses
11:15:25 <sm> Peaker: oh right, parsec rejects many (string "") for example
11:15:39 <catsup> $ objdump -T /usr/lib/i386-linux-gnu/libSDL_ttf.so |grep TTF_Linked_Version
11:15:40 <catsup> 00002460 g    DF .text  00000027  Base        TTF_Linked_Version
11:15:44 <catsup> 32 bit debian
11:16:40 <catsup> i actually got GLFW-b-demo installed and working on both osx and that debian box just now...
11:17:10 <catsup> well i didn't test the visuals on the debian box but it ran
11:17:58 <edlinde> In :  elem' y ys = foldl (\acc x -> if x == y then True else acc) False ys
11:18:09 * hackagebot network 2.6.0.2 - Low-level networking interface  http://hackage.haskell.org/package/network-2.6.0.2 (JohanTibell)
11:18:12 <edlinde> are all the elements in the list going to be checked?
11:18:19 <catsup> that's still not enough for fonts though i guess heh
11:18:31 <edlinde> even if we find the one we are looking for.. it seems like it will just continue till all the elements in the list are exhausted
11:18:33 <edlinde> is that right?
11:19:39 <edlinde> its not going to stop checking right after its found x in y:yz right?
11:19:51 <edlinde> sorry y:ys
11:20:46 <oisin765> cpennington: Thanks!
11:21:41 <catsup> actually the SDL-ttf stuff works fine if there's no template haskell
11:21:48 <catsup> i should have said that, sorry
11:21:58 <catsup> it's only the TH compile-time linking that fails
11:22:02 <edlinde> anyone?
11:22:14 <josephle> edlinde: in your case, I believe the answer is yes.
11:22:22 <edlinde> josephle: ok thanks
11:22:44 <edlinde> so then I am wondering how the actual elem does it
11:22:47 <josephle> but you can abuse short-circuiting to get early termination.
11:23:00 <edlinde> can you show me how?
11:23:01 <josephle> @src or
11:23:02 <lambdabot> or = foldr (||) False
11:23:07 <josephle> @src and
11:23:07 <lambdabot> and  = foldr (&&) True
11:23:10 * hackagebot network-uri 2.6.0.1 - URI manipulation  http://hackage.haskell.org/package/network-uri-2.6.0.1 (JohanTibell)
11:23:36 <edlinde> hmm
11:23:38 <edlinde> ok
11:23:42 <RchrdB> catsup, I have _no idea_ about linking and TH.
11:24:10 <edlinde> how do you see the source of inbuilt functions in ghci?
11:24:20 <edlinde> I wasn’t able to do “@src”
11:24:21 <Fuuzetsu> I have a class like this ‘class Foo a ⇒ Bar a where’ with fully default definition and I was expecting I could say ‘instance Foo a ⇒ Bar a where’ and be done with it but it seems I need FlexibleInstances, is this a valid use-case?
11:25:04 <josephle> edlinde: I think this is an extra feature of lambdabot
11:25:25 <Fuuzetsu> …and UndecidableInstances
11:25:29 <edlinde> hmm so no way to do the same on ghci?
11:25:39 <edlinde> that feature is quite useful
11:25:40 <edlinde> :)
11:27:24 <mauke_> edlinde: @src is lies
11:28:06 <edlinde> mauke_: meaning?
11:28:07 <pjdelport> @src is just a hand-maintained database, as far as I know.
11:28:07 <lambdabot> Source not found. I feel much better now.
11:28:18 <pjdelport> Thank you, lambdabot.
11:28:23 <josephle> hehe
11:28:23 <edlinde> ok
11:28:26 <mauke_> it's a text file someone put together
11:28:31 <shachaf> fsvo "maintained"
11:28:32 <mauke_> it's not necessarily connected to reality
11:28:53 <nschoe> Hey fellow haskellers, I am developping two alonsgside projects in cabal sandboxes, one is a executable, one is a library. I need the executabel to import the library, how can I specify this ?
11:29:07 <S11001001> nschoe: perhaps they should share a sandbox?
11:29:27 <edlinde> mauke_: then is there a good way to look how inbuilt fns are written in haskell?
11:29:43 <ij> @src head
11:29:44 <lambdabot> head (x:_) = x
11:29:44 <lambdabot> head []    = undefined
11:29:44 <nschoe> S11001001, is there a way to link two sandboxes
11:29:48 <nschoe> ?
11:30:06 <S11001001> nschoe: I doubt it.  But I don't see why you couldn't just use one sandbox in both projects.
11:30:21 <S11001001> nschoe: If you mean them to work together it's not like they could use conflicting deps anyway
11:30:28 <ij> Oh, I scrolled up and how the convo went about.
11:30:32 <josephle> edlinde: 'or' and 'and' aren't "built-in". They're located in the base package
11:30:41 <edlinde> ok
11:31:13 <cpennington> nschoe: cabal sandbox add-source
11:31:49 <josephle> edlinde: they're found here http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-List.html
11:32:08 <josephle> edlinde: you can click the grey "Source" links to see the source
11:32:35 <edlinde> cool
11:32:42 <edlinde> thanks josephle
11:32:50 <josephle> no problem :)
11:33:11 * hackagebot ghc-mod 5.0.1.2 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-5.0.1.2 (DanielG)
11:33:13 <mokkake> i don't really get the utility of Typeable
11:33:13 <nschoe> S11001001, well, I could have, yeah. But I've made one git inside each sandbox. We're several to work on the project, so I guessed it was easier that way :/
11:33:28 <nschoe> cpennington, hum, yeah okay. I'll look into that, thanks.
11:35:46 <zmbmartin> Is this a UTCTime -> Tue Jun 10 2014 14:03:48 GMT+00:00 ?
11:36:01 <edlinde> is $ used much?
11:36:13 <joelteon> edlinde: yes
11:36:16 <glguy> way too much
11:36:18 <mokkake> edlinde: yes, but i don't like it
11:36:22 <edlinde> it looks like it can save braces and all.. but I am not sure if its improving readability?
11:36:35 <mokkake> (.) much more elegant imo
11:36:41 <zmbmartin> I am trying to pull from a db and when I set my type for that attribute as Maybe UTCTime I get a error -> Exception: when expecting a UTCTime, encountered Object instead
11:37:07 <lebek> if I've got a compiler where deep functions generate dependencies along with their return values, but dependencies can't really be handled that deep, is a monad a good way to handle gather those dependencies?
11:37:30 <edlinde> whats (.)?
11:38:00 <josephle> :t (.)
11:38:01 <lambdabot> (b -> c) -> (a -> b) -> a -> c
11:38:19 <mokkake> edlinde: that's function composition. f $ g x == f . g $ x == (f . g) x
11:38:27 <S11001001> nschoe: your sandboxes are in a VCS?
11:38:34 <monochrom> (.) is function composition (chaining)
11:38:40 <c_wraith> lebek: It's a way.  Whether it's a good way depends on other design choices.
11:38:54 <nschoe> S11001001, actually now, the .cabal-sanbox is in .gitignore
11:39:08 <edlinde> mokkake: are they having the same affect?
11:39:21 <monochrom> yes
11:39:31 <edlinde> I thought  f $ g x is same as  f (g x)
11:39:43 <monochrom> yes too
11:40:09 <monochrom> it may be best to get $ out of the way altogether
11:40:19 <monochrom> f (g x) = (f . g) x
11:40:43 <monochrom> one more example. h (f (g x)) = (h . f . g) x
11:40:47 <edlinde> i get the function composition part
11:41:08 <nschoe> When using cabal sandbox add-source, what target should I point 'add-source' to ? I tried pointing to the folder in which there are is the sandbox, it bviously didn't work.
11:41:20 <nschoe> Should I point to the compiled file ?
11:41:40 <lebek> c_wraith: makes sense
11:41:43 <josephle> edlinde: when you're exposed to the "points-free" style of haskell programming, the popularity of (.) becomes clearer
11:41:44 <edlinde> if I wanted to write your last one with $’s … would it be    h $ f $ g x
11:41:45 <edlinde> ?
11:41:54 <mauke_> yes
11:42:05 <monochrom> I don't know. I keep forgetting precedence of $.
11:42:08 <sm> nschoe: a folder containing a .cabal file, maybe
11:42:13 <sm> the docs should say
11:42:27 <edlinde> guess its just a matter of preference then?
11:42:31 <monochrom> yes
11:42:31 <Peaker> it would be nice if   (f . g) x   was actually the same as f (g x)   (With RankNTypes, it's not!)
11:42:39 <edlinde> some programmers prefer writing it with $
11:42:43 <edlinde> ok
11:42:44 <nschoe> sm, yeah, that's what I did... but it can't find it.
11:42:48 <Peaker> $ is precedence 0, and . is precedence 9
11:43:27 <edlinde> but do we need a . when we have a space?
11:43:33 <nschoe> Maybe I'm importing it wrong. In my library sandbox, in the .cabal I have exposed-modules: Connection, Version, and in the executable Haskell source file, I use import Connection import Version and I get 'Could not find module'
11:43:37 <mauke_> edlinde: map (f . g)
11:43:39 <edlinde> is  h f g x not clear?
11:43:42 <monochrom> . is not space
11:43:50 <mauke_> h f g x means ((h f) g) x
11:43:57 <monochrom> h f g x is clear. it is clearly what mauke_ says
11:44:00 <edlinde> I was just thinking that space has highest priority yeah?
11:44:05 <mauke_> no
11:44:15 <mauke_> (a)(b) contains no spaces
11:44:21 <edlinde> so . has higher priority than space?
11:44:28 <mauke_> space isn't a thing
11:44:35 <c_wraith> juxtaposition is a thing
11:44:46 <c_wraith> space is a common method of juxtaposition, but it's not the only one.
11:44:55 <monochrom> yeah, to the parser, it is seeing tokens, rid of spaces
11:45:07 <edlinde> ok
11:45:26 <edlinde> so when should I use . ?
11:45:27 <edlinde> :)
11:45:36 <mauke_> when you need to compose functions
11:45:37 <edlinde> I mean where do you see the best use of it
11:45:38 <c_wraith> when you want to compose functions
11:45:39 <sm> code a bit, you'll see
11:45:41 <nschoe> Ah ! I had forgotten to include the name library in the executable's .cabal file. Now I've got cabal: At least the following dependencies are missing:
11:45:41 <nschoe> mylibrary -any
11:45:52 <monochrom> sometimes I side with Dijkstra on giving a symbol to function application
11:46:16 <c_wraith> edlinde: many times you'll think "Oh, I can solve this by just feeding the output of this one function to that other function".  That's function composition!
11:46:28 <monochrom> map (abs . sin) my_list
11:46:39 <edlinde> mauke_: you had an example like  map (f.g)
11:46:43 <Peaker> map (runST . forever) ... oops!
11:46:45 <edlinde> I think that makes sense more
11:46:54 <shachaf> monochrom: Get the best of both worlds with U+2061  FUNCTION APPLICATION  [⁡]
11:46:56 <edlinde> more sense
11:47:04 <shachaf> By best I mean worst.
11:47:26 <mauke_> there better be an invisible multiplication sign
11:47:27 <monochrom> haha
11:47:27 <benbangert> How would I supply an extensible system, prolly using type-classes, where I find the instance by doing a lookup with an int? (I have an int in this case that should result in finding the appropriate instance)
11:47:27 <Fuuzetsu> no liftM6 ;(
11:47:35 <c_wraith> argh...  invisible semantic markup in unicode!  Too bad unicode has no clue what it wants to be.
11:47:46 <mauke_> Fuuzetsu: that's what <*> is for
11:48:00 <monochrom> unicode is not a person. it wants as much as information does.
11:48:01 <edlinde> think I am going to forget the $ for now :)
11:48:02 <Fuuzetsu> right, was just getting rid of those with lifts
11:48:04 <c_wraith> benbangert: type classes do lookup by type, not value.  Sounds like you just want a data structure.
11:48:12 * hackagebot aws-performance-tests 0.1.1 - Performance Tests for the Haskell bindings for Amazon Web Services (AWS)  http://hackage.haskell.org/package/aws-performance-tests-0.1.1 (larsk)
11:48:14 * hackagebot rest-example 0.1.0.2 - Example project for rest  http://hackage.haskell.org/package/rest-example-0.1.0.2 (AdamBergmark)
11:48:20 <shachaf> Yes, Unicode has INVISIBLE TIMES, INVISIBLE SEPARATOR, INVISIBLE PLUS.
11:48:31 <c_wraith> invisible plus?  That's exciting
11:48:38 <monochrom> which code point is invisible plus?
11:48:42 <benbangert> c_wraith: yea... thats what I thought, seems I'll need to let the user supply a data structure to map the int to the right type
11:48:45 <nschoe> Argh :/] still not working
11:48:57 <monochrom> oh, soon after invisible application
11:49:03 <shachaf> U+2064
11:49:06 <mauke_> INVISIBLE BICYCLE + COMBINING CAT ABOVE
11:49:10 <shachaf> <fizzie> "May you live in INVISIBLE TIMES." --Old Chinese proverb. (It can look confusing when written with the proper Unicode.)
11:49:19 <Peaker> I wish Map.singleton was called ==>
11:50:04 <nateb> In Text.PrettyPrint, how does one have a zero-width Doc (other than zeroWidthText)?  I keep having offsets introduced from <+>.
11:50:10 <nschoe> Doh ! I had forgotten to call "cabal install --only-d" after using "cabal sandbox add-source" ! Now it works. Thanks everyone for the hlpe :-)
11:50:13 <nschoe> help*
11:50:22 <edlinde> one last thing :)
11:50:25 <monochrom> invisible plus example: 3⁤½ = 3 + 1/2
11:50:38 <mauke_> yes, mr. columbo?
11:50:40 <monochrom> you have been using invisible plus all your life
11:50:42 <edlinde> could “map ($ 3) [(4+), (10*), (^2), sqrt] “ have been rewritten using function composition?
11:50:55 <monochrom> isn't life exciting?
11:51:10 <shachaf> monochrom: I need INVISIBLE PARENTHESES to go along with that.
11:51:22 <mauke_> edlinde: I don't see how
11:51:40 <mauke_> > sequence [(4+), (10*), (^2), sqrt] 3
11:51:42 <lambdabot>  [7.0,30.0,9.0,1.7320508075688772]
11:51:43 <edlinde> mauke_: ok so in some situations $ can also be quite handy
11:51:59 <shachaf> $ and , are rarely competitors.
11:52:04 <shachaf> s/,/./
11:52:09 <edlinde> ok
11:52:17 <Peaker> shachaf: in every f $ g $ x pipeline you can also do f . g $ x
11:52:27 <mauke_> > map (`id` 3) [(4+), (10*), (^2), sqrt]
11:52:28 <lambdabot>  [7.0,30.0,9.0,1.7320508075688772]
11:52:28 <shachaf> Yes. That's the only situation.
11:52:38 <Peaker> shachaf: but it's really common
11:52:44 <Taneb> nateb, empty
11:52:48 <pablo|> > [(4+), (10*), (^2), sqrt] <$> 3
11:52:49 <lambdabot>  Couldn't match expected type ‘a0 -> b’
11:52:49 <lambdabot>              with actual type ‘[a1 -> a1]’
11:52:55 <pablo|> umm
11:53:03 <pablo|> > [(4+), (10*), (^2), sqrt] <*> 3
11:53:05 <pjdelport> Note the associativity, though:  f $ (g $ x) versus (f . g) $ x
11:53:05 <lambdabot>  No instance for (GHC.Show.Show b0)
11:53:05 <lambdabot>    arising from a use of ‘M796165951707114129510950.show_M7961659517071141295...
11:53:05 <lambdabot>  The type variable ‘b0’ is ambiguous
11:53:05 <lambdabot>  Note: there are several potential instances:
11:53:05 <lambdabot>    instance [safe] GHC.Show.Show
11:53:10 <shachaf> But it's hardly the only use for ($). Saying "you should use . there" isn't saying "$ is useless".
11:53:12 <Peaker> And I've changed my preference from . to $ chain because $ chain works in more circumstances because of inadequacies of the GHC type checker
11:53:14 <nateb> Taneb: is there a way to make a non-empty Doc look empty?
11:53:22 <pablo|> > [(4+), (10*), (^2), sqrt] <*> [3]
11:53:23 <lambdabot>  [7.0,30.0,9.0,1.7320508075688772]
11:53:47 <mauke_> > liftM (fmap fix return `flip` 3) [(4+), (10*), (^2), sqrt]
11:53:49 <lambdabot>  [7.0,30.0,9.0,1.7320508075688772]
11:53:50 <Taneb> nateb, no.
11:54:24 <Taneb> The definition of (<+>) and (<>) is special-cased for Empty, in the internal Doc ADT
11:55:02 <edlinde> how do I lookup the defns of functions like liftM?
11:55:07 <Taneb> nateb, you could use (<>), which doesn't insert a space
11:55:43 <nateb> Taneb: Then, is there a way to turn off automatic indents?  After my newlines, it's shuffling my text way to the right. I tried `style { mode = LeftMode }`, but that didn't make a difference.
11:55:45 <josephle> edlinde: http://www.haskell.org/hoogle/ and follow the links
11:55:52 <monochrom> [digression] are haskell and php in competition? to some people, the answer is "rarely" because the only overlap is web programming. to some other people, the answer is "all the time" because web programming is the only thing.
11:56:28 <nateb> Taneb: Yeah, but I wan't those spaces, and the empty identity is quite handy.
11:56:39 <mauke_> edlinde: http://www.haskell.org/hoogle/?hoogle=liftM => http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Monad.html#v:liftM => http://hackage.haskell.org/package/base-4.7.0.1/docs/src/Control-Monad.html#liftM
11:56:46 <nateb> Granted, I could make my own zero-width <+> equivalent.
11:57:10 <monochrom> (don't you love how I just have to move "only" from the left to the right and get the opposite meaning? Galois connection :) )
11:57:17 <edlinde> mauke_: could you help me understand map (`id` 3) [(4+), (10*), (^2), sqrt]
11:57:24 <edlinde> don’t quite get how that worked
11:57:28 <mauke_> edlinde: ($) = id
11:57:32 <mauke_> basically
11:58:01 <mauke_> f $ x = ($) f x = f x
11:58:04 <mauke_> id f x = f x
11:58:12 <Taneb> nateb, I'm sorry, I don't know the library well enough
11:58:17 <pablo|> @ty (`id` 3)
11:58:18 <lambdabot> Num a => (a -> t) -> t
11:58:22 <josephle> > map (($) 3) [(4+), (10*)]
11:58:24 <lambdabot>  Could not deduce (GHC.Num.Num ((a0 -> a0) -> b))
11:58:24 <lambdabot>    arising from the ambiguity check for ‘e_13410’
11:58:24 <lambdabot>  from the context (GHC.Num.Num ((a -> a) -> b), GHC.Num.Num a)
11:58:24 <lambdabot>    bound by the inferred type for ‘e_13410’:
11:58:24 <lambdabot>               (GHC.Num.Num ((a -> a) -> b), GHC.Num.Num a) => [b]
11:58:26 <pjdelport> :t ($)
11:58:26 <Taneb> I was just too amused at the similarity of our nicks to not try to help :)
11:58:27 <lambdabot> (a -> b) -> a -> b
11:58:33 <josephle> oops, have to flip the $
11:58:45 <edlinde> i see
11:58:47 <pjdelport> edlinde: Read that as: (a -> b) -> (a -> b)
11:58:47 <edlinde> thanks mauke_
11:58:48 <nateb> Taneb: I appreciate the attempt, though.  You did give me a good idea.
11:58:56 <Taneb> :D
11:58:58 <pjdelport> Just id specialized to (a -> b) as the value
11:59:09 <mauke_> :t [id, ($), ask, asks]
11:59:10 <lambdabot> [(a -> a1) -> a -> a1]
11:59:34 <monochrom> wait, Bose?!
12:00:26 <Fuuzetsu> chr '\SOH'
12:00:29 <Fuuzetsu> > chr '\SOH'
12:00:31 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
12:00:31 <lambdabot>              with actual type ‘GHC.Types.Char’
12:00:37 <Fuuzetsu> oh
12:00:38 <mauke_> double Char
12:00:41 <monochrom> ord
12:01:01 <mauke_> chr :: Char -> Char^2
12:01:41 <monochrom> "how to add pointer equality to a pure function, without Eq being Ord"
12:03:40 <mauke_> > reallyUnsafePtrEq# + pure
12:03:42 <lambdabot>  Not in scope: ‘reallyUnsafePtrEq#’
12:05:36 <monochrom> s/function/language/
12:06:08 <mauke_> sorry, no modification allowed
12:06:24 <monochrom> haha
12:08:13 <dfeuer> What is reallyUnsafePtrEquality# good for?
12:09:03 <mauke_> comparing pointers in a really unsafe way
12:09:17 <dv-> comparing addresses?
12:09:21 <monochrom> for everything Java programs use pointer equality for
12:09:55 <monochrom> one of which is serialization
12:10:16 <dfeuer> Oh. So it's used to serialize cyclic data structures?
12:10:24 <monochrom> yes
12:10:56 <mauke_> doesn't that have issues with the GC moving things around?
12:11:42 <c_wraith> Yes.  It can have false negatives
12:11:44 <dfeuer> Yes, mauke_, it does. I would conjecture that if GHC happens in the middle, it could lengthen the cycle.
12:11:50 <monochrom> I forgot how that is solved.
12:12:11 <dolio> Just test three times.
12:12:16 <friden> anyone here knows if xmonad works well with ubuntu 14.04?
12:12:24 <mauke_> ahh, java2k
12:12:24 <dfeuer> I would imagine, that is, that it could end up turning cycle [a,b,c] into cycle [a,b,c,a,b,c]
12:12:30 <dfeuer> But what do I know?
12:12:41 <dfeuer> xmonad is ... a window manager or something?
12:13:02 <mauke_> yes
12:13:05 <friden> dfeuer: yeah^^
12:13:07 <friden> written in haskell
12:13:15 <friden> configs and all in in haskell too
12:13:34 <dfeuer> friden, I read somewhere that it doesn't work too well with the recent GNOME desktop things, so you probably have to not use GNOME desktop.
12:13:53 <friden> yeah, i've heard something similar, that's why i asked here^^
12:14:06 <danlamanna> can anyone point out the obvious error in a custom reverse function? https://gist.github.com/danlamanna/38ce37c2c1ff20065a67
12:14:12 <dfeuer> friden, maybe you should just not use GNOME desktop....
12:14:58 <monochrom> part of Java serialization is done by the RTS IIRC, in particular the cycle detection part. the programmer just has to specify "I want to save x, y, and z". some primitive is responsible for discovering that x and z happen to be the same guy.
12:15:08 <dfeuer> But then again, it looks like xmonad hasn't been updated since 2009.
12:15:11 <pablo|> denlamanna: (l, rev_l) is not a list, it's a pair
12:15:31 <pablo|> use [l, rev_l]
12:15:54 <friden> (l:rev_l)
12:15:55 <pablo|> wait, you store an accumulator
12:16:12 <dfeuer> Also, you should never ever say   length l == 0
12:16:21 <dolio> Java doesn't give you false negatives for 'x == y' when GC moves things, though.
12:16:31 <dolio> So you could do it all yourself.
12:16:34 <friden> use null instead^^
12:16:39 <pablo|> denlamanna: the type should be ([Integer], [Integer]) -> [Integer]
12:16:40 <dfeuer> Idiomatically, you should use pattern matching, but alternatively you could use null.
12:16:50 <dfeuer> O wait.
12:16:52 <dfeuer> OW.
12:17:05 <dfeuer> danlamanna, also, init and last are each O(n).
12:17:17 <dfeuer> You definitely should rewrite this thing to use head and tail instead.
12:17:38 <c_wraith> you mean pattern-matching? :P
12:17:57 <dfeuer> c_wraith, well, ideally.
12:18:45 <dfeuer> But ... the whole code is actually wrong.
12:18:50 <c_wraith> dfeuer: since you've been studying this a ton recently - is it better to use foldr than pattern matching when it's a good fit, just because of fusion?
12:18:53 <dfeuer> So I don't even know where to start.
12:20:01 <ryantrinkle> are there any special things I have to do to use mkWeak# ?
12:20:04 <dfeuer> c_wraith, it seems to depend on whether it's going to fuse in a useful way or not. If the thing naturally *looks* like a left fold, writing it as one will often make intent clearer anyway.
12:20:20 <ryantrinkle> i'm getting segfaults that I don't expect that seem to be related to that
12:20:58 <dolio> c_wraith: Not all fusion is good, even.
12:21:12 <dolio> Even some stuff that looks good.
12:22:19 <dfeuer> The big "gotchas" for that are expensive producers in general and situations where fusion leads to lots of reboxing of the same things over and over instead of sharing.
12:22:27 <dfeuer> These are the big gotchas I know about.
12:22:56 <dfeuer> There are also some gotchas with lefty stuff, because the arity analysis is pretty amazing but not perfect.
12:23:01 <dolio> filter p . reverse was another example.
12:23:32 <dfeuer> And when the arity analysis goes wrong, demons will come out of your nose. Well not quite, but you could run out of RAM.
12:24:14 <c_wraith> Now I'm looking at my favorite use of foldr, and wondering if it can even fuse usefully.
12:24:16 <dfeuer> dolio, I can't quite remember what made filter . reverse bad, but I remember it wasn't *horrible*. Just a little bad.
12:24:48 <dolio> Allocating closures was more expensive than allocating an intermediate list.
12:24:54 <dfeuer> Right, that.
12:25:15 <dfeuer> But concat . inits  making arity analysis fail? That was epic.
12:25:16 <dolio> That's kind of the same problem as when arity analysis goes awry.
12:25:17 <benmachine> c_wraith: there are a lot of people who prefer foldr on purely stylistic grounds
12:25:56 <dolio> When arity analysis doesn't do its thing, you're allocating closures that correspond to the intermediate list. And that's worse than just allocating a list.
12:26:04 <benmachine> c_wraith: i.e. foldr stops you from writing explicit recursion, which in particular stops you from getting the recursion wrong :)
12:26:06 <dolio> Or, most likely is.
12:26:12 <benmachine> er, e.g. not i.e.
12:26:19 <dfeuer> I don't understand the full situation, dolio, but I think the arity analysis is important for strictness analysis of left folds. So when the arity analysis fails, the strictness analysis fails too, and then you're toast.
12:26:36 <dfeuer> Unless you use an explicit strict fold.
12:27:14 <kuribas> I've read about Free Monads.  If I understand it correctly, it's a way to turn a Functor in a Monad.   Why would that be useful?
12:27:46 <monochrom> no turn. build upon.
12:27:47 <c_wraith> kuribas: it is more specific than that
12:28:05 <c_wraith> kuribas: it lets you turn a functor into an expression tree, more or less
12:28:12 <shachaf> Would you say that [] is a way to turn a type into a type of lists?
12:28:16 * hackagebot entropy 0.3.3 - A platform independent entropy source  http://hackage.haskell.org/package/entropy-0.3.3 (ThomasDuBuisson)
12:28:35 <waldohatesyou> does anyone know how many companies actually use haskell?
12:28:46 <benmachine> waldohatesyou: no, because not all do so publically
12:28:47 <MitchellSalad> waldohatesyou: not enough
12:28:56 <benmachine> but: some? I guess?
12:29:00 <dfeuer> danlamanna, your revised code still suggests that you do not understand the problem. I suggest you start over. Reverse some lists by hand without Haskell, and see if you can figure out what you need to do.
12:29:08 <dolio> I also think no one knows.
12:29:14 <MP2E> http://www.haskell.org/haskellwiki/Haskell_in_industry
12:29:15 <danlamanna> dfeuer: you checked the gist i just updated?
12:29:16 <MP2E> pretty good list
12:29:22 <c_wraith> waldohatesyou: does anyone know how many companies use java?  I mean, it's equally unanswerable.
12:29:25 <dfeuer> waldohatesyou, no, no one knows that.
12:29:43 <ryantrinkle> waldohatesyou: skedge.me does; our backend is 100% haskell
12:29:53 <monochrom> when you define a free monad, it has a skeleton, the skeleton is a functor. you have the choice of just writing the skeleton, or writing the whole thing. is it useful to write less than the whole thing?
12:30:00 <dfeuer> danlamanna, yes, I did. Unfortunately, it makes no sense whatsoever.
12:30:09 <latk> I've got a library that analyses data, stored in folders in a particular hierarchy. I've currently hardcoded this as a function dataPath = "/this/is/some/path". If I want to generalise this to run on other computers, what would be the best way of specifying the location of this data directory ?
12:30:10 <waldohatesyou> dfeuer: true, I probably should have asked what haskell is used for in the industry?
12:30:31 <ryantrinkle> waldohatesyou: we're an enterprise appointment booking service
12:30:43 <ryantrinkle> so, web app/web service
12:30:49 <ryantrinkle> frontend in JS, backend in haskell
12:31:05 <dfeuer> danlamanna, I just PMed you.
12:31:11 <waldohatesyou> ryantrinkle:awesome
12:31:25 <c_wraith> :t \p -> foldr (\c r -> if p c && null r then [] else c : r) [] -- I have no idea if this even *can* fuse usefully!  :)
12:31:26 <lambdabot> (a -> Bool) -> [a] -> [a]
12:31:45 <waldohatesyou> ryantrinkle:did you have trouble hiring people?
12:31:53 <ryantrinkle> waldohatesyou: no, not especially
12:32:03 <dfeuer> c_wraith, are you folding over the empty list, or am I reading that wrong?
12:32:09 <c_wraith> dfeuer: that's the base case
12:32:12 <waldohatesyou> ryantrinkle:cool
12:32:13 <ryantrinkle> there are a lot of people who want to work in Haskell
12:32:21 <ryantrinkle> we're not a huge company (about 15 people)
12:32:24 <c_wraith> I can't imagine any company that pays decent rates having trouble hiring
12:32:27 <ryantrinkle> it'd be hard if we were IBM
12:32:32 <dfeuer> c_wraith, can you lpaste the whole thing? I can't read that.
12:32:38 <ryantrinkle> and needed 10k programmer
12:32:38 <ryantrinkle> s
12:32:59 <c_wraith> dfeuer: that is the whole thing.  you can name it dropWhileR if it makes it clearer. :)
12:34:01 <c_wraith> dfeuer: I suspect the explicit call to null just wrecks any chance at fusion as a consumer.
12:34:18 <dfeuer> Oh, I'm reading it wrong.
12:34:30 <dfeuer> Yes, it does.
12:35:00 <dolio> You can't write it with build, if that's what you mean.
12:35:24 <c_wraith> dolio: well, it's both a consumer and a producer, but I was considering it as a consumer rather than a producer
12:35:24 <benmachine> I work for a company that exclusively uses a functional programming language and routinely hires people with no experience in it
12:35:28 <benmachine> sooo it's not *that* hard
12:35:40 <dfeuer> c_wraith, what's it supposed to do, exactly?
12:36:15 <c_wraith> dfeuer: it drops the trailing subsequence of elements of a list that match the predicate.  It's dropWhile, except on the trailing part of the list.  And yes, it works with laziness
12:36:20 <dfeuer> benmachine, are you hiring for any entry-level positions?
12:36:44 <waldohatesyou> I read that companies in the financial industry use functional programming languages a lot, is that true?
12:37:11 <dolio> Yes. Several do.
12:37:11 <benmachine> dfeuer: we're always hiring new developers, and often take them fresh out of university, so I guess so
12:37:12 <benzrf> it sounds right
12:37:24 <dfeuer> benmachine, what company is that?
12:37:26 <benzrf> benmachine: how about fresh out of high school
12:37:29 <benzrf> :y
12:37:30 <benmachine> dfeuer: Jane Street
12:37:39 <dfeuer> Thanks for the info.
12:37:43 <c_wraith> So they're one of the aforementioned financial services companies!
12:37:52 <benmachine> yep :P
12:38:05 <benmachine> well I'm not sure I'd describe it as a service as such >_>
12:38:17 * hackagebot setlocale 1.0.0 - Haskell bindings to setlocale  http://hackage.haskell.org/package/setlocale-1.0.0 (Kritzefitz)
12:38:21 <c_wraith> Ok.  Financial companies.  Fair enough.
12:38:37 <benmachine> we mostly spend our own money on making money for ourselves
12:38:45 <benmachine> incentives work out better that way :P
12:40:32 <dolio> c_wraith: I think you could write it another way that allows you to write it with build, though.
12:40:44 <dolio> It would probably be less efficient, though.
12:41:14 <c_wraith> dolio: I mostly keep that around as an example of the flexible laziness properties of foldr
12:41:23 <benmachine> benzrf: you'd probably have to work a bit harder to prove you were smart, but there are plenty of ways to do that
12:41:27 <dolio> That definition has no problem fusing with a build in the last argument, though.
12:41:29 <michael1> Hello #haskell!
12:41:30 * benmachine will stop talking offtopic now
12:41:42 <benmachine> hello michael1!
12:41:58 <michael1> oh, wrong nick :)
12:42:10 <dfeuer> c_wraith, that's a pretty nifty expression.
12:42:24 <benmachine> hello RedNifre!
12:42:35 <RedNifre> hello benmachine!
12:43:17 * hackagebot MFlow 0.4.5.9 - stateful, RESTful web framework  http://hackage.haskell.org/package/MFlow-0.4.5.9 (AlbertoCorona)
12:44:04 <RedNifre> So, I'm currently looking into creating custom type classes and I wonder if what I'm trying to do is impossible.
12:44:44 <benzrf> RedNifre: such as?
12:44:57 <RedNifre> class Keyable i where key :: i -> Eq
12:45:45 <RedNifre> Basically, I want to do key someData to get a value from someData that I could use, for example, in a map.
12:45:50 <benzrf> Eq isn't a type, bub
12:46:22 <RedNifre> Yeah, it looks like I can only do it with very specific types, e.g. String or Int
12:46:49 <RedNifre> But that's not what I want to do, I would like it to work with the type class Eq, not with a concrete type.
12:46:55 <benzrf> RedNifre: ah
12:47:02 <benzrf> you may want multiparamtypeclasses
12:47:07 <benzrf> or existential quantification
12:47:15 <RedNifre> Sounds fun. What is it?
12:47:31 <benzrf> multiparam typeclasses allows you to make typeclasses that take multiple parameters
12:49:12 <RedNifre> Could it be that whenever I want to do something, I have to add another GHC language extension? :)
12:49:38 <monochrom> the financial industry uses many, many things a lot.
12:49:51 <RedNifre> This is really great, no matter what stumbling block I encounter, there's always a GHC language extension for it.
12:50:07 <dfeuer> RedNifre, you just need to use a language pragma for those.
12:50:44 <prodolof_> do you guys think unicode characters for mathematical symbols will enter into programming eventually?
12:50:59 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/87535/
12:50:59 <dfeuer> prodolof_, they already have. What are you talking about?
12:51:07 <dolio> c_wraith: http://lpaste.net/2053183908689739776
12:51:11 <prodolof_> dfeuer: i mean into actual source code
12:51:20 <RedNifre> dfeuer I think that is what I meant.
12:51:32 <dfeuer> prodolof_, that's been done for years....
12:51:45 <prodolof_> dfeuer: I havent seen any programming language that actually use them, at least any popular language
12:51:49 <RedNifre> Still haven't written that Haskell vocabulary book which I probably should ;)
12:52:09 <benmachine> prodolof_: a couple of unpopular languages do it
12:52:21 <dfeuer> prodolof_, see APL....
12:52:24 <benmachine> prodolof_: pure coincidence I am sure :P
12:52:34 <prodolof_> do you guys think its a good idea?
12:52:54 <benmachine> prodolof_: I like to use it, but I basically think it decreases productivity
12:52:55 <prodolof_> it seems to me to be quite painful to write
12:53:00 <dfeuer> I mean, that was before Unicode, but I imagine it's Unicode these days....
12:53:13 <prodolof_> ah okay
12:53:14 <dfeuer> That's what space cadet keyboards are for!
12:53:24 <benmachine> or emacs input modes
12:53:31 <prodolof_> maybe when we get some special computer science oriented keyboards or something
12:54:04 <prodolof_> space cadet keyboards?
12:54:09 <dolio> You can program your keyboard today to type those symbols.
12:54:17 <dolio> But there are too many in general.
12:54:38 <prodolof_> true
12:54:58 <dolio> It isn't that hard to input them with multi-key inputs.
12:55:27 <prodolof_> yeah, but when you collaborate on something it can be a pain i think
12:55:32 <dolio> But you have to remember names.
12:55:56 <monochrom> thousands of Chinese characters can be input on the puny English keyboard. but you have to enter several keys per character.
12:56:41 <dolio> There are other issues besides input, though.
12:56:53 <RedNifre> brb
12:57:55 <monochrom> on one year's April 1st, Google Japan announced a really huge keyboard. it had many keys for Kanji, but also many keys for emoticons :)
12:58:26 <monochrom> on the next year's April 1st, Google Japan announced a single-key keyboard that made you use Morse code :)
13:05:06 <RedNifre> So how would I use multi param type classes to create class Keyable k where key k -> Ord, so that I can write a function put :: (Keyable k Data.Map m) => k -> m -> m; put k m = Data.Map.insert (key k) m ?
13:06:19 <RedNifre> Or is there another way to do that?
13:07:16 <merijn> RedNifre: You can put constraints on classes
13:07:32 <merijn> RedNifre: i.e. "class Ord k => Keyable k"
13:07:43 <monochrom> in "put k m = Data.Map.insert (key k) m", where does "key" come from?
13:07:50 <merijn> RedNifre: Which means "k can only be made an instance of Keyable IF k is an instance of Ord"
13:08:11 <RedNifre> no no, k shouldn't be an instance of Ord necessarily
13:08:27 <RedNifre> key comes from class Keyable k where key k :: Ord
13:08:40 <merijn> oh, looks you want an associated type
13:08:58 * RedNifre looks that up
13:09:08 <Guest9837> Hello everyone. Hope you are all having a good Tuesday
13:09:38 <merijn> "class Keyable k where type Key k :: *; key :: Ord (Key k) => k -> Key k" or something along those lines
13:09:48 <RedNifre> or multi param type classes or existential quantification?
13:09:55 <mokkake> Guest9837: thanks :)
13:10:06 <mokkake> hello!
13:10:08 <merijn> Existential quantification is (almost) never the correct answer to any problem
13:10:19 <merijn> @where existential-antipattern
13:10:19 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
13:11:50 <mokkake> i have a class Query q, is there a way to explicitly say that q should be of type (e -> a) ?
13:12:23 <Exio> use (e -> a) instead of q?
13:12:24 <Guest9837> Can somebody tell me what I'm doing wrong here? It's only a 1 liner XD http://lpaste.net/110418
13:13:37 <RedNifre> Help I encounter interesting Haskell concepts faster than I can read about them!
13:13:56 <mokkake> Exio: ghc doesn't seem to allow that: Unexpected type e -> a
13:15:48 <Exio> i don't really know, sorry :P
13:17:53 <mokkake> Exio: okay, np
13:18:09 <mokkake> i think i need some kind of newtype wrapper, but can't figure out which one
13:18:34 <merijn> mokkake: Without seeing code it's hard to say, you may want a type equality constraint?
13:18:45 <dolio> Can we stop having people link to that article and saying "existential quantification is never the correct answer to any problem"?
13:19:05 <dolio> That article is specifically about using existential quantification together with type classes in a certain way.
13:20:01 <RedNifre> merijn, could you explain the meaning of your Keyable k::* example?
13:20:07 <RedNifre> I mean how to read that code.
13:22:08 <RedNifre> @let class Keyable k where type Key k :: * ; key :: Ord (Key k) => k -> Key k
13:22:08 <lambdabot>  Parse failed: TypeFamilies is not enabled
13:22:14 <merijn> RedNifre: It defines a type family (basically, type level function) from the type 'k' to another type with kind *. So you can write "instance Keyable Char where type Key Char = Int" and then the type of "key :: Ord (Key k) => k -> Key k" turns into "key :: Ord Int => Char -> Int"
13:22:26 <eitan_chatav> why doesn't haskell have a exists keyword dual to forall?
13:23:09 <merijn> RedNifre: There's a (very readable!) good paper explaining type functions called "Fun with Type Functions"
13:23:30 <merijn> RedNifre: https://research.microsoft.com/en-us/um/people/simonpj/papers/assoc-types/fun-with-type-funs/typefun.pdf
13:23:48 <jfischoff> eitan_chatav: no good reason that I know of. UHC has one I think
13:24:32 <eitan_chatav> jfischoff: I see. Good to know
13:24:34 <jfischoff> eitan_chatav: http://www.cs.uu.nl/wiki/Ehc/UhcUserDocumentation#A_3.6_Existential_types
13:24:38 <dolio> There is a good reason. It's complicated to type check.
13:24:50 <jfischoff> eitan_chatav: ^ there you go
13:24:58 <RedNifre> Ah, I think I get it.
13:25:00 <dolio> And it probably gets more complicated when you try to add it to everything else GHC has.
13:25:01 <shachaf> I hear it's incompatible with the way GHC compiles Haskell, or with its intermediate language, or type-checking strategy, or something.
13:25:19 <shachaf> I haven't heard the details.
13:25:26 <eitan_chatav> That's not really a good reason. You can still do existential types that are hard to typecheck. It's just also hard to annotate it's type signature
13:25:30 <dolio> Even UHC's version is limited, last I checked. You can't use it with type classes.
13:25:38 <josephle> existential types are a great source of bugs in F-omega interpreters :P
13:25:57 <shachaf> I'm not even entirely sure what the behavior of exists would be like.
13:26:26 <shachaf> I suppose many of the issues come up with rank-n types too, though...
13:26:33 <dolio> Also, just having an exists keyword wouldn't replace the forall use in GHC.
13:27:03 <eitan_chatav> All I want is a keyword that desugars to the usual forall representation
13:27:13 <dolio> Because there's no way to turn 'data Foo = forall e. C e (e -> e)' into a use of exists without tweaking the constructor.
13:27:16 <eitan_chatav> but I want to write the right thing, ya know
13:27:27 <shachaf> ==dolio
13:28:38 <shachaf> In the example dolio gave, forall is the right keyword.
13:28:47 <eitan_chatav> data Foo where C :: exists e. e -> (e -> e) -> Foo
13:28:53 <shachaf> I don't know how you'd improve that.
13:28:53 <eitan_chatav> should give the same thing
13:29:05 <shachaf> No, that should be a fotall.
13:29:09 <dolio> That is not the correct type for the constructor.
13:29:32 <shachaf> Because that's the type of the constructor. It works for all types e.
13:30:15 <eitan_chatav> I'm not getting why it's wrong
13:30:31 <merijn> RedNifre: TypeFamilies are like one of the coolest things in GHC :)
13:30:41 <merijn> RedNifre: I highly recommend that paper :)
13:31:09 <eitan_chatav> it should work "for all" e
13:31:19 <linman32> lambdabot: :t '~'
13:31:21 <eitan_chatav> it should just translate to the forall thing
13:31:26 <dolio> Then why did you write exists?
13:31:28 <RedNifre> Will read it :)
13:31:37 <eitan_chatav> because it's existential
13:31:43 <eitan_chatav> it is a sum over all e
13:31:46 <eitan_chatav> not a product
13:31:46 <dolio> Not in the type of the constructor.
13:31:49 <merijn> linman32: If ~ is in the type it's type level equality
13:32:05 <linman32> lambdabot: :t 'a'
13:32:06 <dolio> In declarations of that form, you are giving the type of the constructor.
13:32:30 <dolio> Which is forall e. e -> (e -> e) -> Foo
13:32:32 <linman32> merijn: where is lambdabot? i want to give him a spin
13:32:33 <phaskell> No symbol 'lambdabot' found anywhere.
13:32:40 <shachaf> I'm typing this on a phone so I can't type a long explanation.
13:32:53 <linman32> haha
13:32:56 <shachaf> thoughtpolice: U+261D
13:33:10 <merijn> linman32: Lambdabot doesn't reply to lines starting with her name
13:33:16 <merijn> :t 'a'
13:33:18 <lambdabot> Char
13:33:21 <linman32> :t 'a'
13:33:23 <lambdabot> Char
13:33:25 <linman32> :)
13:33:30 <eitan_chatav> forall e. e -> (e -> e) -> Foo doesn't have any nonbottom elements, does it?
13:33:36 <c_wraith> @version
13:33:36 <lambdabot> lambdabot 5.0-int-e
13:33:36 <lambdabot> git clone git://github.com/int-e/lambdabot.git
13:33:40 <eitan_chatav> id is in forall e. e -> e
13:33:40 <c_wraith> linman32: ^
13:33:47 <eitan_chatav> but what is in forall e. e?
13:33:47 <josephle> Bob Harper has a whole section on the definability of exists in terms of forall
13:33:50 <eitan_chatav> only bottom
13:33:56 <dolio> C is the element.
13:33:57 <shachaf> Sure it does. It has a constructor.
13:33:58 <eitan_chatav> it should be an exists
13:34:00 <dolio> By fiat.
13:34:13 <shachaf> No, exists doesn't make sense there.
13:34:15 <dolio> C :: forall e. e -> (e -> e) -> Foo
13:34:30 <eitan_chatav> i disagree with you guys
13:34:37 <eitan_chatav> ;-)
13:34:52 <monochrom> universal type is when caller chooses. existential type is when callee chooses. it seems fair to say they are each useful half of the time. existential type does not always appear in existential form, it can appear as rank-2 universal form
13:35:44 <josephle> eitan_chatav, exists e. t == forall a. (forall e. t -> a) -> a
13:35:47 <josephle> iirc
13:35:51 <dolio> Foo ~ (exists e. (e, e -> e))
13:35:53 <eitan_chatav> right now it must appear in rank-2 universal form...it'd be nice to express it simply with an exists keyword
13:36:13 <dolio> The constructor for that type has type: forall e. e -> (e -> e) -> (exists e. (e, e -> e))
13:36:17 <shachaf> I can explain it at the next Haskell thing if you'll be there. Maybe I should do one of those short talks they keep asking people to do about this topic.
13:36:26 * dfeuer is very confused about this exists/forall stuff too.
13:36:31 <eitan_chatav> that'd be cool shachaf
13:36:37 <monochrom> parametric polymorphism, though, is the real limiting factor here. (well, limits cavalier power, enhances predictive power.) parametricity means: whoever does not choose, he/she does not know what is chosen either.
13:36:47 <eitan_chatav> and then do ends and coends!
13:38:07 <dolio> If C had type (exists e. e -> (e -> e) -> Foo), you would not be able to call it, because you would not know which e you were allowed to use to construct it.
13:38:31 <eitan_chatav> any e which exists
13:38:58 <eitan_chatav> exists is summing over all types e
13:39:02 <shachaf> No. There exists one particular e.
13:39:15 <shachaf> It's summing, not multiplying.
13:39:29 <eitan_chatav> that's if you put the exists in the front of the constructor
13:39:35 <shachaf> So there's only one type e that works. And you don't know which one.
13:39:38 <monochrom> eitan_chatav, have you written down a type system that does what you're saying now?
13:39:43 <eitan_chatav> no
13:39:48 <josephle> you'd need extra "primitives" in haskell just solely for constructing existentials
13:39:56 <monochrom> then I suggest you do before making claims.
13:39:57 <eitan_chatav> also everyone disagrees with me so i'm likely confused
13:40:26 <shachaf> dolio disagrees with you. That should be enough, surely.
13:40:55 <RedNifre> merijn hm ghci says that Keyable is illegal polymorphic. Why is that?
13:41:12 <monochrom> similarly, when I said all those things about who chooses, I could say them because I have at least read type systems that do what I said, so in principle I can write one down as well.
13:42:45 <merijn> RedNifre: Hard to say without code and exact error
13:43:48 * dfeuer kills whoever decided to do that CR/LF thing. Kills with his bare hands.
13:43:56 <dfeuer> Even if they're dead.
13:44:04 <eitan_chatav> I want to be able to write this:
13:44:05 <eitan_chatav> type Day f g a = Day (exists x y. ((x -> y -> a) , f x , g y))
13:44:31 <monochrom> I think some CP/M folk did that CR/LF thing
13:44:32 <shachaf> OK. That's a valid thing to write.
13:44:49 <dolio> Well, that exact line would never be.
13:44:50 <eitan_chatav> and have it translate to the corresponding forall definition
13:44:57 <shachaf> It's kind of odd to -- wait, that's a type synonym.
13:45:08 <benmachine> the CRLF thing is surely not the result of one decision gone wrong
13:45:09 <eitan_chatav> oops
13:45:12 <eitan_chatav> meant data
13:45:15 <benmachine> but rather of three decisions that all went different ways
13:45:20 <eitan_chatav> or newtype
13:45:23 <eitan_chatav> whatever
13:45:25 <RedNifre> merijn exactly your code and the error is illegal polymorphic or qualified type: Ord (key k) => k -> Key k
13:45:27 <eitan_chatav> or no constructor
13:45:39 <monochrom> ok, so dfeuer have at least 3 persons to kill :)
13:45:49 <dfeuer> benmachine, the fact that this thing persists creates needless pain.
13:45:52 <shachaf> I thought it said data, and I was saying it's odd to have a constructor containing just a tuple.
13:45:57 <eitan_chatav> type Day f g a = exists x y. ((x -> y -> a) , f x , g y)
13:46:20 * dfeuer is looking into refactoring hPutStr, and CRLF turns the problem from a simple 3-way into a messy 5-way.
13:46:22 <dolio> Having that would require first-class existentials, which complicates the language in various ways.
13:46:22 <shachaf> That's a valid thing to want.
13:46:33 * shachaf , want-police
13:46:33 <dolio> Which is why it hasn't been implemented.
13:46:39 <eitan_chatav> woohoo
13:47:00 <eitan_chatav> well, in my dreams we have first class existentials
13:47:12 <dolio> I'd like it, too. But don't hold your breath.
13:47:14 <eitan_chatav> and I don't have to translate them into universals by hand
13:47:37 * dfeuer still has no idea what this forall/exists thing is about.
13:47:45 <dfeuer> Or first class existentials.
13:47:45 <dolio> You never have to translate them to universals. You just need to declare a datatype.
13:48:04 <monochrom> do you mind writing "data Day f g a = forall x y. Ctor (x -> y -> a) (f x) (g y)"? it is legal in GHC.
13:48:48 <eitan_chatav> I kinda mind having to write forall for an existential...it bugs me because if I'm writing it on paper I would write it with a backwards E not an upside-down A
13:49:16 <monochrom> ok, that is a debate over keyword spellings.
13:49:27 <dolio> You wouldn't write it that way if it were in the same position as the forall is.
13:49:34 <dolio> Unless you wanted to be writing the wrong thing.
13:49:47 <eitan_chatav> yes, i'm not wanting to debate about type systems...that's why I said, I just want it to desugar to the appropriate thing when I write that
13:50:07 <monochrom> people debate over what to call "return", too.
13:50:15 <eitan_chatav> I really like return
13:50:29 <monochrom> wait, return is not even a keyword...
13:51:03 <eitan_chatav> it makes perfect sense to me when thinking of monads as imperative dsls
13:51:05 <Qfwfq_> You could define Monad with that function renamed, but you'd lose a lot of instances.
13:51:49 <Qfwfq_> Unless: 'instance Monad a => MyMonad a where'
13:52:11 <Qfwfq_> You'd lose the do notation.
13:52:30 <monochrom> I must make clear that I have grown out of arguing over syntax and spellings.
13:53:53 <monochrom> well, except this debate: are meaningful names meaningful?
13:54:07 <dfeuer> That's a debate?
13:54:17 <monochrom> yes, because I say no.
13:55:07 <Qfwfq_> I think calling 'Functor' 'Mappable' would make typeclasses more accessible, but I don't care enough to argue about it.
13:55:19 <benmachine> monochrom: if you think you have "grown out" of syntax debates, I think you underestimate the importance of syntax
13:55:54 <dfeuer> monochrom, so ... we could just make life simpler by requiring all variables to be the letter v followed by a number?
13:56:15 <dfeuer> And all constructors the letter V followed by a number.
13:56:17 <monochrom> no. names are mnemonics.
13:56:33 <dfeuer> Doesn't that make them meaningful?
13:56:53 <monochrom> what does the name "return" mean to everybody?
13:56:55 <ReinH> What even is meaning? This is going to end up nowhere pretty quickly.
13:57:14 <Qfwfq_> "return" means "Monad m => a -> m a".
13:57:15 <eitan_chatav> return means Kleisli identity morphism
13:57:24 <monochrom> and I serious mean: absolutely everybody. all programmers.
13:57:37 <dfeuer> v1 (V1 v2) (V2 v3 v4) = v5 (V6 v2 v4) v3 (v1 V2)
13:58:01 <dmj`> monochrom: in C, "get out of", in Haskell, "put into"
13:58:11 <dfeuer> Pretty much.
13:58:12 <eitan_chatav> it means Kleisli identity morphism in imperative programming too...plus break control flow
13:58:27 <monochrom> yes, so you have a disagreement between two groups what "return" means.
13:58:36 <ij> Can I find source of stuff like lambdabot in ghci? I can't find where exaclty this happens in lambdabot's source.
13:58:54 <eitan_chatav> well...our if also isn't for control flow either
13:58:55 <monochrom> a mnemonic is only required to be recognizable in a small circle, not all programmers.
13:59:17 <dmj`> ij: cabal unpack lambdabot
14:00:03 <monochrom> anyway, thank you for participating in my debate, so that I prove that there is a debate.
14:00:03 <Fuuzetsu> is length on strict ByteString constant time?
14:00:06 <zwer> it seems like it was no accident that return name was picked to make do blocks appear more like code in imperative languages. and that similarity confuses more than it enlightens
14:00:27 <dolio> Fuuzetsu: Yes.
14:00:37 <Fuuzetsu> OK, it is.
14:00:43 <Fuuzetsu> should have just went straight for docs
14:00:55 <eitan_chatav> it enlightened me...it helped me understand imperative programs
14:01:38 <dmj`> @src Arse
14:01:38 <lambdabot> Source not found. Do you think like you type?
14:01:42 <dmj`> @typ Arse
14:01:43 <lambdabot> Not in scope: data constructor ‘Arse’
14:02:38 <dmj`> sorry, its from the assert package, http://hackage.haskell.org/package/assert-0.0.1.2/docs/Control-Exception-Assert.html
14:03:46 * shachaf is off phone now.
14:03:56 <shachaf> Was the existential crisis resolved?
14:04:05 <merijn> Fuuzetsu: Even lazy bytestring's O(n) is merely n/32kb, so it's not bad
14:04:30 <eitan_chatav> lol
14:04:30 <zwer> it confuses newbies from imperative languages because they see something familiar which acts kind of like imperative return in some examples, while it is actually quite different
14:05:03 <Fuuzetsu> dmj`: -- The name comes from abbreviating ‘assert’ and translating the result to
14:05:03 <Fuuzetsu> -- my native tongue.
14:05:04 <Fuuzetsu> ;P
14:05:25 <doismellburning> is there any reading on the etymology of monadic "return"?
14:05:51 <hakujin> installed ghc 7.8.3 on an Ubuntu VM where 7.8.2 worked correctly. getting ld errors (can't find -lHStext-1.1.1.3, -HSstm-2.4.3, etc) during cabal install (async, ghc-mod, hslint, etc) but I see the libraries in ~/.cabal/lib. how do I tell ld where to look? and what did I do wrong during the update?
14:05:51 <Fuuzetsu> doismellburning: any category theory book?
14:06:15 <shachaf> Fuuzetsu: Huh?
14:06:15 <Peaker> doismellburning: it's often at the end of "do" blocks and looks like imperative code that uses the same keyword in that position (with a completely different meaning)
14:06:32 <doismellburning> Peaker: I am aware
14:06:36 <Fuuzetsu> shachaf: I think I misunderstood what he was asking…
14:06:39 <shachaf> I don't think the name "return" was ever used in category theory. It's what Peaker said.
14:06:46 <mokkake> is there a way to add a (e -> a) constraint in a class implementation somehow ?
14:06:59 <merijn> mokkake: What would that constraint do?
14:07:01 <Fuuzetsu> righty
14:07:02 <doismellburning> Peaker: oh, sorry, right, you mean that _is_ the etymology? :s
14:07:09 <eitan_chatav> shachaf: not quite resolved. let's see if I can turn it into a question. is it necessary to have first class existentials, or can you just have an extension that turns on some syntax sugar that will translate some existential types with existential syntax into rank-N types?
14:07:12 <Peaker> doismellburning: I am pretty sure it is :)
14:07:26 <unenough> yo
14:07:28 <merijn> eitan_chatav: Yes!
14:07:37 <mokkake> merijn: something like: (Func q) => Class q, so that the q's in Class can be used as functions
14:07:38 <merijn> eitan_chatav: I read an SO answer explaining how yesterday :)
14:07:41 <shachaf> eitan_chatav: It's not necesary to have first-class existentials. You can tell because Haskell doesn't.
14:07:54 <shachaf> eitan_chatav: Or: Necessary for what?
14:07:58 <merijn> eitan_chatav: Lemme find the link
14:08:19 <monochrom> I am curious about all the "can't find lib files" errors. a lot of people have them. I don't have them. the difficulty now is I can't reproduce them, so I can't even test any theory.
14:08:20 <merijn> eitan_chatav: https://stackoverflow.com/questions/13653532/how-to-express-existential-types-using-higher-rank-rank-n-type-polymorphism
14:08:34 <eitan_chatav> necessary to support me writing the Day type as earlier and other similar examples for existential types.
14:08:47 <eitan_chatav> merijn: thanks
14:08:52 <merijn> eitan_chatav: I don't think you can get a more relevant SO question/answer ;)
14:08:56 <shachaf> First-class existentials are necessary for that, yes.
14:09:11 <shachaf> You can translate them to rank-n types, but it's not just a matter of syntax sugar.
14:09:11 <eitan_chatav> looks like now we have a debate!
14:09:19 <Fuuzetsu> monochrom: pretty sure it happens when you have stale (different GHC version or whatever) libs lying around
14:09:30 <merijn> mokkake: There's ~ which it type level equality which would let you write "(q ~ e -> a) => Class q"
14:09:40 <eitan_chatav> is the translation not mechanical?
14:09:48 <monochrom> no, can't be, each GHC version does not even know the database of other GHC versions.
14:10:12 <Fuuzetsu> right
14:10:20 <Fuuzetsu> I succesfully used many versions at once myself
14:10:28 <hakujin> monochrom: my order of events was axe ~.cabal & ~.ghc -> ./configure -> make install -> cabal update -> cabal install cabal-install (from 1.16 to 1.20.0.2) -> get ld errors when reinstalling ghc-mod, async, etc
14:10:47 <hakujin> ghci and ghc work correctly and report 7.8.3
14:11:06 <Fuuzetsu> does cabal report 1.20?
14:11:12 <hakujin> yep
14:11:16 <Fuuzetsu> does it also report similar version for the library?
14:11:37 <hakujin> cabal-install is 1.20.0.3, library is 1.20.0.2
14:11:44 <Fuuzetsu> ok then I don't know
14:11:47 <mokkake> merijn: thanks for the answer, this is what i wanted, but then ghc complains: Not in scope: type variable 'e' and 'a'
14:11:49 * Fuuzetsu looks down from his nix ivory tower
14:11:55 <hakujin> :P
14:13:31 <dolio> eitan_chatav: If all you wanted was GHC to translate types involving 'exists' into isomorphic types involving 'forall', that would be easy. But it would not be like having first class existential types in many ways.
14:13:35 <monochrom> perhaps I should try that sequence after the break
14:14:02 <dolio> And depending on how much you required people to know about the translation, it would be more difficult to implement.
14:14:22 <eitan_chatav> dolio: That's interesting. I would ideally like first class existentials but was settling for asking about translating.
14:14:46 <clrnd> quick question, can I subtract two ZonedTimes ?
14:15:01 <dmj`> Fuuzetsu: ah thanks
14:15:26 <dolio> For instance, it is natural to say that if (x :: Int) then (x :: exists a. a).
14:15:48 <dolio> But this is not true if you are just desugaring into encodings by rote.
14:16:12 <eitan_chatav> what would the rote desugaring of exists a. a be?
14:16:23 <dolio> You only have: if (x :: Int) then ((\k -> k x) :: exists a. a)
14:16:41 <eitan_chatav> ahh
14:16:46 <dolio> exists a. a = forall r. (forall a. a -> r) -> r
14:17:01 <eitan_chatav> neat
14:17:17 <monochrom> I now see what is going on, after a careful simulation of the sequence in my head. I knew enough theory to explain it.
14:17:25 <hakujin> oddly, if I init a blank sandbox and try cabal install (package) it works
14:18:25 <merijn> hakujin, monochrom: Oh! Idea!
14:18:36 <merijn> You said you used cabal 1.16?
14:18:47 <merijn> Isn't that the one that doesn't have the correct dynamic settings?
14:18:54 <merijn> i.e. doesn't 7.8 require cabal >1.18
14:19:00 <monochrom> yes, it comes down to that
14:19:10 <Fuuzetsu> clrnd: what package is this in?
14:19:11 <merijn> Plus throwing out the old .cabal/configure file
14:19:14 <hakujin> merijn: I used 1.16 to install 1.20
14:19:27 <clrnd> Fuuzetsu, Data.Time
14:19:28 <merijn> hakujin: Right, so you build stuff using 1.16, which is what broke stuff
14:19:37 <hakujin> oh!
14:19:45 <merijn> hakujin: You cannot use 1.16 to build things with ghc 7.8
14:19:55 <k00mi> clrnd: no, you have to convert to UTCTime, then use diffUTCTime
14:19:57 <Fuuzetsu> clrnd: That's not in base, what package?
14:20:00 <hakujin> roger. I'll scrap it and grab a fresh binary and try again
14:20:01 <merijn> hakujin: cabal >1.18 deals properly with the new linking stuff in GHC
14:20:12 <merijn> hakujin: So you need a binary of >1.18 to bootstrap :)
14:20:18 <hakujin> yep yep
14:20:22 <clrnd> k00mi, yeah I was hoping that wasn't the only way, thanks!
14:20:43 <monochrom> the config file does not matter. it has "-- shared: whatever" commented out. you're looking at 1.16 and 1.20 using different defaults. (and 1.16's default is bad for GHC 7.8)
14:20:48 <clrnd> Fuuzetsu, package time
14:20:48 <merijn> hakujin: Make sure to axe any old .cabal/configure file too
14:20:56 <Fuuzetsu> ok noted
14:21:08 <Fuuzetsu> hakujin: you could try out nix if you have some time
14:21:09 <merijn> monochrom: Well, I meant if he had edited his config file
14:21:28 <monochrom> ah, but he started by rm -rf .cabal, the config file was gone anyway
14:21:39 <monochrom> everything was defaulting
14:22:02 <eitan_chatav> exists x y. ((x -> y -> a) , f x , g y) === forall r. (forall x y. (x -> y -> a) -> f x -> g y -> r) -> r ?
14:22:02 <monochrom> always build cabal-install in a sandbox, then copy out the exe, throw away the sandbox.
14:22:19 <hakujin> Fuuzetsu: I'm tempted but until OSX support is in it's not going to win me over
14:22:21 <monochrom> you absolutely do not want the collateral stuff
14:22:39 <Fuuzetsu> hakujin: but we have plenty of OSX users
14:22:44 <joelteon> define "support"
14:22:45 <hakujin> oh?
14:22:49 <joelteon> we have a Darwin-specific stdenv now
14:22:53 <shachaf> eitan_chatav: Yes.
14:22:55 <Fuuzetsu> joelteon is here, you can ask him all about it ;)
14:23:13 <shachaf> eitan_chatav: Or the uncurried form, forall r. (forall x y. (x -> y -> a, f x, g y) -> r) -> r
14:23:28 <eitan_chatav> yarp
14:23:29 <hakujin> I researched it a few months ago and the answer was "some stuff works but most doesn't"
14:23:37 <Fuuzetsu> joelteon: does it work properly?
14:23:41 <Fuuzetsu> does Hydra use it?
14:23:49 <joelteon> yes and no
14:24:00 <joelteon> Hydra is using an operating system 3 major versions old
14:24:03 <Fuuzetsu> would it solve the binary issue thing on OSX?
14:24:05 <Fuuzetsu> heh
14:24:09 <joelteon> yeah
14:24:12 <joelteon> but then again, upgrading would fix that anyway
14:24:16 <Fuuzetsu> I see
14:24:26 <Fuuzetsu> I thought Eelco said they were upgrading Soon™
14:24:37 <joelteon> we should probably take this to #nixos
14:24:46 <joelteon> hakujin, if you're curious about nix, feel free to join
14:24:54 <monochrom> except I can't trace the dependency from cabal-install to text
14:27:08 <eitan_chatav> shachaf: So if I did have that translation available, it would be pretty easy to construct elements naiveley, right? just use flip ($) (function,fx,gy)
14:27:18 <monochrom> oh, -> network -> parsec -> text
14:28:43 <eitan_chatav> although I guess the non-continuation-passing version is a bit nicer...
14:29:57 <eitan_chatav> oh, no wait...it's exactly the same...just think of flip ($) as the constructor...you could even have that as part of the translation
14:30:00 <monochrom> more importantly, it's before splitting off network-uri
14:31:57 <shachaf> flip ($) won't give you the rank-n type.
14:33:28 * hackagebot purescript 0.5.5 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.5.5 (PhilFreeman)
14:47:00 <ReinH> eitan_chatav: is this the part where we talk about how this is a yoneda embedding? ;)
14:47:14 <eitan_chatav> lol
15:15:13 --- mode: ChanServ set +o glguy
15:16:04 --- mode: glguy set -b *18!~*18@*$#haskell-ops
15:16:08 --- mode: glguy set -o glguy
15:23:33 * hackagebot mvc 1.0.2 - Model-view-controller  http://hackage.haskell.org/package/mvc-1.0.2 (GabrielGonzalez)
15:23:52 <monochrom> hrm, building Cabal the lib takes 600MB (GHC)
15:24:13 <monochrom> and it's still growing
15:29:00 <eacameron> does FFI support some sort of "thread init" hook? libmysqlclient supports multithreading, but you have to "register" each thread with the lib; thus, all the Haskell mysql bindings (that I know of) do not support concurrency!
15:29:07 <sinelaw> is there no builtin fromRight?
15:29:19 <sinelaw> fromRight (Right x) = x
15:29:24 <sinelaw> fromRight _ = error ....
15:29:44 <monochrom> does Data.Either have it?
15:30:02 <sinelaw> monochrom, nope
15:30:10 <eacameron> sinelaw: could `Right x <- getEiether` work for you? That works in do notation and in list comps
15:30:42 <sinelaw> @where getEither
15:30:43 <lambdabot> I know nothing about geteither.
15:31:04 <eacameron> sinelaw: I made that up, it's the pattern matching that I'm trying to show you
15:31:10 <sinelaw> i see
15:31:13 <sinelaw> that will work, yes
15:31:24 <merijn> Don't use fromRight :(
15:31:40 <merijn> Either (ha! pun!) use lefts/rights or use either
15:31:42 <merijn> :t lefts
15:31:43 <lambdabot> [Either a b] -> [a]
15:31:47 <merijn> :t rights
15:31:48 <lambdabot> [Either a b] -> [b]
15:31:50 <merijn> :t eithe
15:31:51 <lambdabot>     Not in scope: ‘eithe’
15:31:52 <lambdabot>     Perhaps you meant ‘either’ (imported from Data.Either)
15:31:53 <merijn> :t either
15:31:54 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
15:52:44 <codygman> Is this a horrible way to do this? It seems cool to me, lol: filterM (return . and . sequence [(/= "."), (/= "..")]) =<< getDirectoryContents "/home"
15:53:26 <c_wraith> codygman: that use of return seems basically useless.  Why not take it out and just use filter?
15:53:53 <c_wraith> codygman: oh, you'll also need to change the =<< to something like <$>
15:54:24 <Peaker> codygman: filter (`notElem` [".", ".."]) <$> getDirectoryContents "/home" ?
15:54:34 <frerich_> codygman: I suaully write that as filter (`notElem` [".", ".."]) <$> getDirectoryContents "/home"
15:59:47 <codygman> c_wraith: Because I didn't realize "Functor! Duh..." :)
16:00:04 <codygman> Peaker, frerich_: Thanks!
16:14:21 <frerich_> Does anybody have some thoughts on how to define a ‘merge’ function nicely which can merge sequences of steps into the same direction? The types and my current solution are at http://lpaste.net/110420 — my solution seems overly complicated though, but the alternatives I tried (which weren’t built on a catamorphism of Instruction) weren’t really pretty either.
16:14:36 <gennady> This may seem like a stupid question, but can haskell be used to solve all the euler problems?
16:15:21 <shachaf> Haskell can do anything.
16:15:25 <dfeuer> gennady, Haskell is a general-purpose programming language....
16:15:57 <frerich_> @faq Can Haskell solve all the Euler problems?
16:15:57 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
16:16:07 <frerich_> Boo :-(
16:16:21 <gennady> I was just kind of wondering if there was "limits" to it I guess.
16:16:31 <shachaf> The only limit is yourself.
16:16:36 <gennady> >:)
16:16:58 <shachaf> You're not doing yourself any favors by prefixing your question with that, by the way.
16:17:24 <gennady> The "stupid question" remark?
16:17:30 <shachaf> Yes.
16:18:13 <gennady> Sorry. :|
16:18:32 <shachaf> Maybe that came out more hostile than I intended.
16:20:07 <dfeuer> gennady, there are languages that limit what you do in order to offer strict real-time bounds and things. Haskell is not like that.
16:21:08 <Exio4> well, there may be a limit, your computer has finite ram, and can only do a finite number of instructions per second
16:21:22 <gennady> Lol
16:22:21 <Fuuzetsu> Exio4: we just need to improve GHC ;P
16:22:46 <dfeuer> frerich_, move left and move right are pretty boring to merge, I think.
16:23:18 <dfeuer> But you're trying to be fancy about it, I guess?
16:24:07 <frerich_> dfeuer: I’m just playing with different ways to do it, and none of them seemed to hit the sweet spot between “short” and “pretty” so far :-}
16:24:35 <dfeuer> frerich_, it probably depends on what you consider pretty.
16:25:14 <Fuuzetsu> :t let f x y z = x >=> y <=< z in f
16:25:15 <lambdabot> Monad m => (a -> m b) -> (b1 -> m c) -> (b -> m b1) -> a -> m c
16:25:30 <frerich_> dfeuer: My first version was just using manual recursion, which made the code quite short but somehow I hoped that there was a nicer way which would avoid manual recursion.
16:25:52 <eacameron> is there any way to use the type system to help ensure you don't use an particular variable in more than one thread?
16:26:01 <Fuuzetsu> :t let f x y z = x >=> z >=> y in f
16:26:02 <lambdabot> Monad m => (a -> m b) -> (b1 -> m c) -> (b -> m b1) -> a -> m c
16:26:05 <Fuuzetsu> boring
16:26:49 <josephle> eacameron: that sounds like linear types, which haskell doesn't have :(
16:26:51 <dfeuer> frerich_, what *I* would do is write  howFarRight::Instruction->Int, map it over the Program, sum the list, and then apply  goRightThisFar::Int->Instruction   But maybe that's too boring for you.
16:26:52 <benzrf> eacameron: probably
16:27:14 <Peaker> The ST s monad makes sure you only use its variables in only one "thread"
16:27:15 <eacameron> josephle: is that what Agda has?
16:27:19 <benzrf> Peaker++
16:27:24 <benzrf> eacameron: no, that's dependent
16:27:29 <dfeuer> oh wait.
16:27:32 <benzrf> eacameron: linear types prevent you from reusing variables
16:27:38 <dfeuer> Sorry frerich_ I misunderstood your intention.
16:27:40 <benzrf> eacameron: you may be interested in something St-like
16:27:41 <dfeuer> altogether.
16:27:42 <benzrf> *ST
16:27:44 <Fuuzetsu> you can implement linear with dependent can't you
16:27:49 <dfeuer> I read that program wronnnnng.
16:27:52 <benzrf> Fuuzetsu: heck if i know
16:28:04 <Peaker> You can encode linear with dependent, I think, but it's not pretty
16:28:15 <Fuuzetsu> well well, no one said it has to be pretty
16:28:15 <Peaker> I think even Haskell can encode ugly linear types via indexed monads
16:28:39 <Fuuzetsu> do you have an example?
16:28:40 <dfeuer> The language with linear types that everyone has heard of is Clean. I have no idea how much it's actually used.
16:28:40 * hackagebot toml 0.1.2 -   http://hackage.haskell.org/package/toml-0.1.2 (seliopou)
16:28:47 <eacameron> Peaker: "even Haskell" haha now that's not a phrase I hear in my neck of the woods
16:29:01 <Fuuzetsu> dfeuer: is that the one with uniquness typing
16:29:06 <dfeuer> Yeah.
16:29:10 <frerich_> dfeuer: In hindsight, my first “manual recursion” version (added that now as the second annotation to http://lpaste.net/110420 ) doesn’t look so bad. It’s certainly short. :-}
16:29:40 <frerich_> Err, http://lpaste.net/110424 is the one
16:30:53 <dfeuer> frerich_, you could surely use unfoldr.
16:30:59 <roboguy_> Fuuzetsu: I think this is the main paper about indexed monads https://personal.cis.strath.ac.uk/conor.mcbride/Kleisli.pdf
16:31:34 <Fuuzetsu> I have a vague recollection of that, don't think it had linear types implementation
16:31:37 <jmcarthur> a lot of well-known monads become indexed monads if you just don't constrain the types of return and bind
16:31:37 <josephle> well, the question is how does the encoding of linear types using indexed monads look like?
16:31:48 <roboguy_> frerich_: that second implementation was my first thought when I saw the problem
16:32:15 <Fuuzetsu> (are indexed monads indexed in the way that slice categories index things?)
16:32:54 <frerich_> roboguy_: Yeah I suspect it comes kind of natural, it was what I started with and then I went on a trip much like in http://www.willamette.edu/~fruehr/haskell/evolution.html ...
16:32:57 <Fuuzetsu> guess I'll just read the paper
16:33:41 * hackagebot toml 0.1.3 -   http://hackage.haskell.org/package/toml-0.1.3 (seliopou)
16:33:58 <josephle> the open/closed file handle can probably be generalized to used/unused variables
16:35:05 <eacameron> josephle: I imagine it would be *very* difficult to do compile-time verification that a handle was opened *before* it is closed (in time)
16:35:36 <josephle> that's what the indexed monad paper is discussing :)
16:36:14 <eacameron> josephle: interesting!
16:36:47 <roboguy_> one thing to note about that paper is that we now have real PolyKinds, so we don't need that preprocessor
16:37:15 <roboguy_> unless there's something else too that it needs, I can't remember
16:40:39 <dfeuer> OK, that's weird..
16:41:10 <dfeuer> It appears the xmonad website died a sudden death in 2009 (I hope not caused by a human death). xmonad development appears to have continued somewhere in the shadows.
16:41:39 <dfeuer> I can't quite figure out where, but the mailing list message subjects clearly suggest that....
16:42:06 <dfeuer> And the fact that the Haskell wiki links to newer version.
16:42:07 <dfeuer> s.
16:42:19 <Fuuzetsu> the mailing list is active
16:42:28 <Fuuzetsu> IIRC they have an issue tracker on Google Code
16:42:39 <Fuuzetsu> the #xmonad channel is fairly big
16:42:52 <dfeuer> So what happened to the website? Any idea?
16:43:10 <Fuuzetsu> *shrug*
17:37:04 <Fuuzetsu> in the indexed monads paper, class IFunctor (f ∷ ({i} → *) → {o} → *) where …
17:37:07 <Fuuzetsu> why is the {o} needed here?
17:37:34 <Fuuzetsu> looking at imap ∷ (s :→ t) → fs :→ f t , it does not seem necessary
17:38:11 <Fuuzetsu> (where s :→ t = ∀ i. s {i} → t {i})
17:40:08 <Fuuzetsu> sorry, that meant to be ‘f s :→ f t’ of course
17:40:24 <dolio> If there's no {o}, the codomain of the functor is not indexed types.
17:41:04 <roboguy_> Fuuzetsu: f needs to take two arguments
17:41:19 <Fuuzetsu> I just realised that it's using the fact that → right-associates so it's ({o} → *)
17:41:23 <roboguy_> one of them is given in the signature of imap, the other is given buy :->
17:41:25 <roboguy_> *by
17:43:58 <Fuuzetsu> How does it manage to go ({i} → *) → ({o} → *), what makes the indexing change? It seems like it should be {i} → *) → ({i} → *), guess I can't see the case where that's untrue
17:44:41 <dolio> If they were both i, you would only be doing endofunctors.
17:45:20 <roboguy_> Fuuzetsu: something like vmap wouldn't work in that case
17:45:54 <Fuuzetsu> would it not? It's defined in terms of :→ which preserves the indexing
17:46:57 <roboguy_> Fuuzetsu: the expanded type of vmap is vmap :: (a -> b) -> (forall i. Vec a i -> Vec b i)
17:48:19 <roboguy_> also i has kind Nat and a and b have kind *
17:48:45 <roboguy_> so it would more explicitly look like vmap :: (a -> b) -> (forall (i :: Nat). Vec a i -> Vec b i)
17:53:50 * hackagebot hsConfigure 0.1.0.2 - By using this package, you can make application configurable.  http://hackage.haskell.org/package/hsConfigure-0.1.0.2 (YoshikuniJujo)
17:56:29 <ScrewLoose007> I am trying to get lambdabot to connect to another room. Was successful for a couple of days, now getting an error:
17:56:34 <ScrewLoose007> [NOTICE] Plugin.base: ["*",":*** Looking up your hostname..."]
17:56:34 <ScrewLoose007> [NOTICE] Plugin.base: ["*",":*** Checking Ident"]
17:56:35 <ScrewLoose007> [NOTICE] Plugin.base: ["*",":*** Couldn't look up your hostname"]
17:56:35 <ScrewLoose007> [NOTICE] Plugin.base: ["*",":*** No Ident response"]
17:56:35 <ScrewLoose007> [ERROR] : <socket: 8>: hGetLine: end of file
17:57:23 <Makoryu> ScrewLoose007: The server is expecting that the machine your bot runs on has an Ident server
17:57:56 <ScrewLoose007> More info please, I be an apprentice.
17:58:08 <Fuuzetsu> I don't think the error is directly connected to ident
17:58:31 * Fuuzetsu has never ran ident on any of his boxes, including those that ran lambabot sometimes 
17:59:33 <ScrewLoose007> Works fine locally until I try connecting to a room in here
18:00:31 <k00mi> the "Couldn't look up your hostname" part is unusual, but I don't know what might be causing it
18:01:16 <Fuuzetsu> debugging is the only way to go about it, no point guessing
18:13:46 <jonseymour> Hello new to Haskell, reading the "Lazy Functional State Threads" paper.
18:14:13 <jonseymour> Is it true that 'thenST' described in that paper is equivalent to '>>=' ?
18:15:41 <Fuuzetsu> hm, just stumbled upon an e-mail from 2001 about people complaining about the monomorphism restriction, over a decade later and it's still here
18:15:56 <napping> I assume so
18:16:05 <roboguy_> Fuuzetsu: I think they got rid of at least part of it in GHC 7.8
18:16:38 <roboguy_> or maybe that's just ghci 7.8
18:16:44 <Fuuzetsu> just GHCi IIRC
18:17:10 <napping> Does anyone here use eclipsefp? I'd like to stop it from building all its stuff in workspaces that don't even have any haskell projects
18:17:46 <Fuuzetsu> jonseymour: it certainly looks like you could define the >>= for that particular Monnad instance with thenST, I find your question a little strange however
18:18:27 <roboguy_> jonseymour: it definitely wouldn't be equivalent in general, but maybe for that specific type it is
18:19:00 <tac_> Fuuzetsu: You don't want to break backwards compatibility, do you??
18:19:47 <Fuuzetsu> tac_: I used GHC 7.9 extensions before they were even finished ;P
18:20:03 <Fuuzetsu> 7.7 rather but whatever
18:20:03 <jonseymour> well, let's put the question another way - I was trying to find the type signature of thenST in ghci but I couldn't find a definition for the function anywhere…was wondering if Haskell uses a different name for that function in practice?
18:20:20 <Fuuzetsu> tac_: In all seriousness, no currently compiling programs stop compiling, do they?
18:20:40 <napping> jonseymour: probably just >>=
18:20:51 <napping> maybe at type ST s a -> (a -> ST s b) -> ST s b
18:20:57 <tac_> Fuuzetsu: The monomorphism restriction was just one of many bad design decisions in the early haskell language that should have withered away and died years ago
18:21:03 <tac_> along with about a third of the prelude
18:21:43 <roboguy_> jonseymour: it would be (>>=), but you can do other things with >>= as well
18:21:53 <roboguy_> because it is defined differently for different types
18:22:16 <Fuuzetsu> jonseymour: did you look into the source of http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Monad-ST-Lazy.html ?
18:22:33 <roboguy_> tac_: wait, that would break backwards compatibility?
18:24:17 <roboguy_> :t (>>=)
18:24:18 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:24:24 <jonseymour> fuuzetsu: looking at it now - what should I be seeing :-)?
18:24:47 <Fuuzetsu> the definition for >>= under instance Monad (ST a)
18:24:53 <tac_> roboguy_: Probably in some obscure way
18:25:06 <tac_> Most likely not anything of value
18:25:32 <jonseymour> fuuzetsu: ah, right thanks
18:27:12 <Oksana> Can anybody read Haskell code of PanDoc and say what's wrong, in one particular place? It is said in User's Guide that LaTeX reader does pass through untranslatable LaTeX commands, even if -R is not specified. I do not see it in reality. An example is converting X\underline{Y}Z from tex to docx. Line 368, function inlineCommand in https://github.com/jgm/pandoc/blob/master/src/Text/Pandoc/Readers/L
18:27:14 <Oksana> aTeX.hs
18:27:38 <Oksana> Sorry,  https://github.com/jgm/pandoc/blob/master/src/Text/Pandoc/Readers/LaTeX.hs
18:28:00 <nshepperd> according to the wiki page, removing the monomorphism restriction would cause some programs to suddenly take exponentially more time
18:28:47 <Fuuzetsu> nshepperd: in theory it could for some cases which is why the restriction is there to begin with I believe
18:29:12 <Fuuzetsu> Oksana: It seems like you should be filing an issue, even if there's no problem with the code and it's a user error then it's a documentation bug
18:29:14 <roboguy_> isn't it the defaulting that stops that not MMR?
18:31:04 <nshepperd> if only we had ScopedTypedVariables all along
18:31:18 <Fuuzetsu> Oksana: it does seem to me that it does not pass through commands without -R (assuming -R is parseRaw)
18:32:20 <Fuuzetsu> https://github.com/jgm/pandoc/blob/master/src/Text/Pandoc/Readers/LaTeX.hs#L382 specifically
18:33:20 <DanC__> I'm building my first haskell program (in a long time) and I seem to be about 40 screenfuls into the cabal documentation with no sign of Hello World yet. Surely I'm doing it wrong?
18:33:51 <tac_> DanC__: http://lpaste.net <- paste the error
18:34:20 <DanC__> I don't have an error. I don't have any code yet.
18:34:27 <lpvb> why would cabal documentation mention hello world
18:34:42 <roboguy_> DanC__: putStrLn is what you want
18:34:44 <DanC__> I got the impression that "cabal init" is how one starts a haskell project
18:34:44 <pjdelport> DanC__: "cabal init" and go from there?
18:35:06 <lpvb> DanC__: edit HelloWorld.hs
18:35:21 <DanC__> yes, I did "cabal init". it generated a file with:
18:35:23 <DanC__> -- Initial txcollect.cabal generated by cabal init.  For further
18:35:23 <DanC__> -- documentation, see http://haskell.org/cabal/users-guide/
18:35:24 <lpvb> ghc -o helloworld HelloWorld.hs
18:36:24 <Oksana> What is applyMacros' ? It seems to me that transformed = rawcommand , and it goes straight to https://github.com/jgm/pandoc/blob/master/src/Text/Pandoc/Readers/LaTeX.hs#L385 . I have specifically chosen \underline{text} as a built-in LaTeX command which requires no macros, packages or includes.
18:36:28 <DanC__> yeah, well, I was hoping to copy and paste HelloWorld.hs. I don't recall the syntax for a main program/function
18:36:37 <Fuuzetsu> DanC__: did you say yes when it asked you to put in documentation on each field?
18:36:54 <roboguy_> DanC__: main :: IO (); main = ...
18:36:55 <DanC__> no; the default was "no" and I wasn't sure what it was asking
18:37:02 <jle`> DanC__: you can start a new project, but you can always just compile a single file :)
18:37:10 <threestrikes> DanC:  I'm new to haskell as well feel free to PM me so we can stumble through this together
18:37:15 <jonseymour2> thanks for the help all
18:38:24 <lpvb> DanC__: echo 'main = putStrln "Hello World!"' > HelloWorld.hs && ghc -o helloworld HelloWorld.hs
18:38:35 <Fuuzetsu> Oksana: applyMacros' is defined elsewhere, it's not a LaTeX specific thing
18:38:41 <Oksana> And anyway, it does the same when using -R switch. And it does not matter whether I convert to docx or to html. Still X\underline{Y}Z is turned into XZ.
18:38:58 <roboguy_> lpvb: if we're using cabal we may as well build with cabal though
18:40:42 <Fuuzetsu> Oksana: oh, maybe it is to do with LaTeX looking at Text.Pandoc.Parsing; anyway it does not matter, you should file an issue with the project, it's difficult to say without properly diving into the code and it seems like waste of effort if the maintainer can resolve it
18:46:50 <Oksana> Ah, I see the mempty: if transformed = rawcommand then {if parseRaw then return $ rawInline "latex" rawcommand else return mempty} else {parseFromString inlines transformed}
18:46:52 <Oksana> The issue is filed : https://github.com/jgm/pandoc/issues/1598
18:46:53 <Oksana> Actually, if I tell it to parseRaw, and output native format, I see that it does store Raw LaTeX code. It just does not convert it into any HTML or Docx format. But how do I ask it to text-ify unknown LaTeX commands, instead of deleting them?..
18:52:57 <augur> does cabal store compiled haskell libs in some place different than what GHC uses? probably right?
18:53:27 <lpaste> DanC pasted “cabal dependencies: webdriver” at http://lpaste.net/110428
18:54:12 <DanC__> I want to use webdriver; what's the usual way to add that to my build environment? I tried just putting it in my .cabal and rebuilding, but no joy
18:54:56 <Fuuzetsu> just putting it in build-depends should work
18:55:07 <Fuuzetsu> make sure to cabal install --only-dependencies it afterwards
18:56:26 <DanC__> oh. http://www.haskell.org/cabal/users-guide/developing-packages.html#modules-imported-from-other-packages doesn't mention that.
18:56:52 <napping> augur: I'm not sure what you mean about different places, but your .cabal/lib and .ghc/<arch>-
18:57:05 <DanC__> should I be filing bugs against cabal docs?
18:57:09 <napping> .ghc/<arch>-<version>/package.conf.d are places to look
18:57:11 <Fuuzetsu> DanC__: Doesn't mention what? Installing docs?
18:57:23 <Fuuzetsu> uh, installing deps*
18:57:26 <DanC__> doesn't mention "make sure to cabal install --only-dependencies it"
18:57:58 <Fuuzetsu> because technically it doesn't have to, you may already have the package on your system
18:58:02 <roboguy_> DanC__: it assumes that you already have the packages installed
18:58:09 <augur> napping: yeah, my ghc lib isnt in that place, but ok. thnk you :)
18:58:24 <napping> augur: the libraries themselves are put under .cabal/lib
18:58:32 <napping> then package descriptions telling ghc where to look go wherever
18:58:55 <napping> I'm not sure there's actually a "place GHC uses" for libraries
18:59:15 <augur> napping: oh, how can i look up descriptions in ghc?
18:59:28 <DanC__> ok, Fuuzetsu --only-dependencies seems to be the clue I was looking for. thanks.
18:59:29 <napping> a sandbox contains an <arch>-<version>-packages.conf.d directory with the descriptions
18:59:43 <augur> i have to manually import some .a's into xcode and mtl and parsec arent with the rest of them
19:00:09 <napping> the .conf files in the packages.conf.d directories are human readable
19:01:08 <napping> the library-dirs: line is probably the one you care about
19:01:35 <napping> and seems to generally go to .cabal[-sandbox]/lib/<arch>-<version>/<package>/
19:01:37 <augur> hmm nope thats not what i need
19:01:38 <augur> hmm hmm
19:01:39 <napping> which contains actual .a files and so on
19:02:38 <augur> is this .cabal/lib/... thing local to the project? because theres nothing in my project that has .a's like that
19:02:44 <augur> afaict
19:02:53 <napping> .cabal is usually under your home directory
19:03:03 <augur> ok ill look to see if they're there
19:03:12 <napping> if you are using a sandbox you have .cabal-sandbox/lib/...
19:03:50 <napping> maybe somewhere a bit different if you are sharing a sandbox or something
19:04:33 <augur> hm. napping: so the dir is there but the subdirs are all empty :(
19:04:42 <napping> weird
19:05:57 <augur> well maybe all of them? the dir has lots of data according to finder
19:06:05 <napping> what directory
19:06:13 <augur> ah but the relevant two dont
19:06:19 <augur> ~/.cabal/lib
19:06:59 <napping> well, are you using a sandbox?
19:07:11 <augur> i believe so, yes
19:07:23 <napping> then look in the sandbox
19:08:55 <augur> napping: as i said, there's nothing in the local dir
19:08:59 <augur> however there _is_ a tar file
19:09:17 <napping> is there a .cabal-sandbox/lib directory in your project?
19:09:33 <DanC__> Prelude> :m Test.WebDriver
19:09:33 <DanC__> Prelude Test.WebDriver> :t defaultConfig
19:09:33 <DanC__> <interactive>:1:1: Not in scope: `defaultConfig'
19:09:36 <DanC__> :-/
19:10:05 <augur> nope, not that
19:10:05 <DanC__> I'm just trying to use the hello world from https://github.com/kallisti-dev/hs-webdriver ; any clues about why I'm losing?
19:10:11 <augur> napping: no
19:10:19 <augur> just .cabal-sandbox
19:11:49 <napping> is there nothing in there?
19:11:50 <Fuuzetsu> DanC__: works for me
19:11:52 <Fuuzetsu> Prelude> :m Test.WebDriver
19:11:53 <Fuuzetsu> Prelude Test.WebDriver> :t defaultConfig
19:11:53 <Fuuzetsu> defaultConfig :: WDConfig
19:12:14 <Fuuzetsu> perhaps you got some old version, did you ever run ‘cabal update’?
19:12:30 <DanC__> I got some warnings earlier about the age of my cabal something... trying cabal update now...
19:12:45 <Fuuzetsu> yep, those warnings tell you to run cabal update
19:12:50 <augur> napping: there's a packages dir and a conf.d dir
19:12:54 <augur> neither have libs of any sort
19:13:06 <augur> nor any data, really
19:13:08 <DanC__> hmm... now how do I tell it to get the current webdriver?
19:13:12 <DanC__> cabal clean or something?
19:13:27 <napping> augur: well, the .conf files is how ghc is pointed at the extra libraries, anything in there?
19:13:40 <Fuuzetsu> I think you can install --only-dependencies again
19:13:44 <Fuuzetsu> might have to cabal configure afterwards
19:14:12 <meretrix> I have a large application that essentially takes many external events, processes them with multiple threads and timers, and outputs events.  I want to test it by replaying events and checking my application's behavior.  Is there a library that would help with this?
19:14:16 <augur> napping: nothing i can read. lots of $ paths tho
19:14:40 <augur> napping: i suspect this might be a clue: libsubdir: $arch-$os-$compiler/$pkgid
19:15:42 <augur> but maybe not
19:15:49 <DanC__> it's not recompiling webdriver. hm.
19:15:57 <augur> no, actually i dont think it is napping
19:16:11 <napping> augur: try a "find" for .conf files
19:16:12 <augur> hmm hmm hmm
19:16:13 <napping> or .a files
19:16:44 <gennady> If I am supplying a function with one integer, how do I create a variable and keep track of that without supplying an empty list?
19:18:31 <benzrf> gennady: huh?
19:18:35 <Fuuzetsu> ^
19:19:03 <Fuuzetsu> my dubious guess is that he wants Reader (which does mean an empty list although not passed explicitly)
19:19:03 <zwer> yeah I failed to make sense of that too. try to elaborate or give an example of desired input and output values
19:19:09 <gennady> I have a function "solveMe x = ..." and in there I need to start keeping track of stuff done with x
19:19:09 <augur> napping: nothing in the project dir
19:19:15 * DanC__ imagines gennady is thinking in python terms and maybe wants the state monad
19:19:46 <augur> napping: is there a way to get ghc to tell me where it's looking when its compiling?
19:19:49 <Fuuzetsu> gennady: solveMe x = let y = doSomeStuff x; … ?
19:19:50 <augur> what dirs its searching
19:20:01 <gennady> I am basically trying to write this in haskell, http://lpaste.net/7819103346664407040
19:20:02 <zwer> gennady what's the bigger picture? what (not how) are you trying to implement
19:20:06 <napping> probably enough -v
19:20:14 <napping> the ghc side is described here: http://www.haskell.org/ghc/docs/latest/html/users_guide/packages.html#package-databases
19:20:44 <gennady> This is my horrible half written function that doesn't run right now, lol. http://lpaste.net/1243858860049956864
19:21:52 <Sensored> is there a way to just nuke all pakcages installed and start fresh
19:21:55 <benzrf> gennady: you want a fold
19:22:04 <benzrf> :t foldr
19:22:06 <lambdabot> (a -> b -> b) -> b -> [a] -> b
19:22:07 <zwer> so given 123 you want 6 as a result?
19:22:11 <benzrf> oh wait
19:22:16 <benzrf> hmm
19:22:23 <gennady> Yes
19:22:26 <benzrf> actually that's probably an unfold
19:22:35 <benzrf> no, better
19:22:45 <benzrf> it's a metamorphism!
19:22:49 <benzrf> or is it a hylomorphism p:
19:23:09 <benzrf> yeah it's a hylomorphism
19:23:15 <benzrf> is there a function for doing hylomorphisms in base
19:23:16 <roboguy_> gennady: sum should be +
19:23:20 <roboguy_> also you are shadowing p
19:23:24 <benzrf> gennady: this aint lispy
19:23:28 <benzrf> er, lisp
19:23:45 <augur> napping: aha!
19:23:56 <gennady> This is the type of stuff I wasn't wanting to do in haskell, finding its a million times more complicated for me. :|
19:23:58 <augur> it was in the original dir i was looking in, but in some cache file maybe?
19:24:07 <augur> ghc was searching in /Library/Frameworks/GHC.framework/Versions/7.8.3-x86_64/usr/lib/ghc-7.8.3/package.conf.d/package.cache
19:24:11 * DanC__ just did `rm -rf ~/.cabal` to nuke all packages and start fresh
19:24:20 <gennady> hmm so I need to look up unfold?
19:24:27 <benzrf> gennady: protip
19:24:29 <benzrf> make a digits function
19:24:33 <benzrf> then make digitSum just sum with that
19:24:34 <zwer> or fix your recursive function
19:24:40 <benzrf> :t unfold
19:24:42 <lambdabot>     Not in scope: ‘unfold’
19:24:42 <lambdabot>     Perhaps you meant one of these:
19:24:42 <lambdabot>       ‘BS.unfoldr’ (imported from Data.ByteString),
19:24:43 <benzrf> :t unfoldr
19:24:45 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
19:25:01 <gennady> Well I was going through the rescursive part of lyah and wanted to try to implement something easy doing it
19:25:05 <gennady> apparently was a bit more than I thought :P
19:25:08 <benzrf> gennady: well, you can do ThatOtherPerson
19:25:09 <benzrf> *that
19:25:18 <benzrf> gennady: it's just that HOFs tend to be more idiomatic than manual recursion
19:25:20 <benzrf> and more expressive
19:25:33 <benzrf> gennady: like control structures vs goto
19:25:39 <ThatOtherPerson> benzrf: He can?
19:25:46 <benzrf> ThatOtherPerson: >.>
19:26:02 <benzrf> gennady: a fold takes a structures and a function for combining elements and collapses the structure
19:26:22 <benzrf> gennady: an unfold takes a value and a function for expanding a value and builds a structure
19:26:44 <benzrf> gennady: in your case you want a function that breaks a number apart a piece at a time
19:26:46 <roboguy_> gennady: I would just pass (x `div` 10) into the recursive call and then add (x `mod` 10) to the result of that
19:26:51 * BMeph points - TA-DA!!
19:26:56 <benzrf> gennady: then you can use unfold to expand that into a list
19:26:59 <gennady> Doh
19:27:00 <gennady> :|
19:27:08 <benzrf> better yet
19:27:09 <benzrf> :t divMod
19:27:10 <lambdabot> Integral a => a -> a -> (a, a)
19:27:27 <benzrf> :t quotRem
19:27:28 <lambdabot> Integral a => a -> a -> (a, a)
19:27:29 <benzrf> hmm
19:27:38 <benzrf> > let (quot, rem) = 10 `divMod` 3
19:27:39 <lambdabot>  not an expression: ‘let (quot, rem) = 10 `divMod` 3’
19:27:43 <benzrf> er
19:27:46 <benzrf> > 10 `divMod` 3
19:27:48 <lambdabot>  (3,1)
19:27:53 <benzrf> > 10 `quotRem` 3
19:27:55 <lambdabot>  (3,1)
19:27:58 <benzrf> are they just alises?
19:28:00 <benzrf> *aliases
19:28:13 <DanC__> now `cabal configure` says     Could not find module `Test.WebDriver'
19:28:13 <DanC__>     There are files missing in the `webdriver-0.5.4' package,
19:28:23 <augur> napping: ahhhh! theres also /Library/Haskell/ghc-7.8.3-x86_64/lib/mtl-2.1.3.1! aha!
19:28:34 <roboguy_> benzrf: quotMod uses quot and divMod uses div
19:28:38 <benzrf> oh
19:28:41 <DanC__> I thought I just blew away cabal's entire state and started over. where is it hiding stuff?
19:28:41 <roboguy_> er divRem
19:28:41 <benzrf> uh
19:28:43 <benzrf> :t quot
19:28:44 <lambdabot> Integral a => a -> a -> a
19:28:46 <benzrf> :t divRem
19:28:47 <lambdabot> Not in scope: ‘divRem’
19:28:58 <BMeph> :t quotMod
19:28:59 <lambdabot> Not in scope: ‘quotMod’
19:29:00 * benzrf shrugs
19:29:04 <roboguy_> > 2 `quot` (-3)
19:29:05 <lambdabot>  0
19:29:07 <roboguy_> > 2 `div` (-3)
19:29:08 <lambdabot>  -1
19:29:09 <benzrf> gennady: here look @ this
19:29:13 <benzrf> gennady: wait, do you know about Maybe yet
19:29:13 <roboguy_> ^ benzrf
19:29:16 * BMeph snickers at benzrf
19:29:46 <gennady> I guess one way you solve it in another language doesnt mean it will be solved the same in this one as well? IE: as you said before just creating a list of digits than sum'ing that
19:30:10 <roboguy_> benzrf: I feel like introducing a hylomorphism is overcomplicating it slightly ha
19:30:27 <benzrf> roboguy_: no need for ThatOtherPerson
19:30:34 <benzrf> er
19:30:35 <benzrf> that
19:30:37 <benzrf> ThatOtherPerson: sorry, sorry
19:30:52 <benzrf> i-i'm sure there's a need for you somewhere
19:30:53 <BMeph> gennady: If you solve the same problems the same way in "different" languages...then how "different" are they, really? ;þ
19:31:01 <benzrf> gennady: do you know about Maybe?
19:31:06 <roboguy_> gennady: well, Haskell doesn't even have a while loop so no
19:31:11 <ThatOtherPerson> benzrf: Thanks :)
19:31:30 <benzrf> roboguy_: now, now
19:31:31 <benzrf> what about whileM
19:31:32 <gennady> Eh I meant that in pretty loose terms, but yeah. lol.
19:32:09 <roboguy_> a little different, but I guess close enough
19:32:14 <benzrf> :t unfold -- gennady
19:32:15 <lambdabot>     Not in scope: ‘unfold’
19:32:15 <lambdabot>     Perhaps you meant one of these:
19:32:15 <lambdabot>       ‘BS.unfoldr’ (imported from Data.ByteString),
19:32:18 <benzrf> :t unfoldr -- gennady
19:32:19 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
19:32:41 <Sensored> DanC__: are you having troule with cabal?
19:32:50 <Sensored> i am so i just uninstalled all of haskell platform and am doing it again
19:32:50 <benzrf> gennady: you write a function that takes the original value and either a) breaks it into a result and a new original or b) says "we're done here"
19:32:52 <DanC__> you could say that
19:33:02 <benzrf> gennady: then u give that and a base value to unfoldr, and it'll do the rest
19:33:12 <gennady> but what about keeping track of 2 different values from one?
19:33:17 <Sensored> nuked from low earht orbit
19:33:20 <benzrf> gennady: don't worry about ThatOtherPerson
19:33:22 <benzrf> ughhh
19:33:23 <benzrf> *that
19:33:27 <DanC__> "All the requested packages are already installed". grr! where?! I just blew away ~/.cabal!
19:33:28 <roboguy_> haha
19:33:32 <benzrf> gennady: just write the breaking function, then you can use unfoldr on it
19:33:36 <benzrf> and then sum on that
19:33:38 <ThatOtherPerson> Nobody should worry about me
19:33:40 <benzrf> compositionality & hofs B)
19:33:42 <ThatOtherPerson> I'm not planning anything
19:33:46 <gennady> lol
19:33:47 <Sensored> DanC__: check /Library/Haskell
19:33:53 <ThatOtherPerson> Certainly no world domination schemes over here
19:34:04 <DanC__> I'm not on OS X
19:34:18 <benzrf> gennady: the b in the type of unfoldr is the original value you're building into a list; the a is the type of items in the list
19:34:22 <Sensored> oh. eh. idk.
19:34:24 <benzrf> gennady: what will a and b be in your case?
19:34:39 <DanC__> aha... dist...
19:35:49 <gennady> each were suppose to be running totals
19:35:50 <geekosaur> DanC__, ~/.cabal isn't what needs to be removed. ~/.ghc is
19:36:02 <DanC__> oh. ok.
19:36:07 <benzrf> gennady: u can still do manual recursion if u want
19:36:11 <geekosaur> all you did was leave behind package database entries that are now dangling
19:36:36 <gennady> I could have already solved it a different way, I am trying to solve it this way for learning purposes is the thing.
19:36:41 <benzrf> gennady: oki
19:36:44 <gennady> :|
19:37:03 <augur> thank you napping :)
19:37:18 <DanC__> compiling only seems to use 20% of my CPU; I think that means 1 out of 4 cores or something. is there a -j analog?
19:37:43 <roboguy_> DanC__: -j
19:37:53 <DanC__> oh. tee hee
19:38:01 <linman32> :t Int
19:38:02 <lambdabot>     Not in scope: data constructor ‘Int’
19:38:02 <lambdabot>     Perhaps you meant one of these:
19:38:02 <lambdabot>       ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
19:38:08 <napping> I think recent cabal-install will do that by default
19:38:09 <linman32> :t 9
19:38:10 <lambdabot> Num a => a
19:38:34 <roboguy_> :k Int
19:38:35 <lambdabot> *
19:39:24 <roboguy_> ^ linman32
19:39:46 <DanC__> does anybody use the NixOS Distributions? or does everybody build from source all the time?
19:40:33 <DanC__> whew! ghci *finally* groks :t defaultConfig
19:41:43 <linman32> roboguy_: what is :k?
19:41:47 <augur> YES
19:41:49 <augur> VICTORY
19:41:52 <lf94> Ok Haskell programmers, why the heck is this not valid:
19:41:52 <roboguy_> linman32: it tells you the kind of a type
19:41:52 <augur> (hopefully)
19:42:11 <lf94> Couldn't match expected type `[(x00, y00)]' \n with actual type `(t0, t1)'
19:42:26 <roboguy_> lf94: we'll need more context
19:42:35 <lf94> Yeah, this is the line causing that: prices = plot_lines_values .~ [(0,1)]
19:43:03 <napping> you have more or less layers of list around that than you need
19:43:27 <napping> probably plot_lines_values .~ [[(0,1)]]?
19:43:52 <lf94> Isn't expected type [()] exactly what I put though?
19:44:00 <lf94> (You are right though napping)
19:44:03 <roboguy_> linman32: a kind is to a type what a type is to a value
19:44:07 <roboguy_> :k Maybe
19:44:08 <lambdabot> * -> *
19:44:10 <lf94> (Looking for an explanation now)
19:44:31 <napping> it's saying it found a type like (a,b) where it needed a type like [(x,y)]
19:44:54 <lf94> Ah, you are right!
19:44:59 <lpvb> lf94: /w b3
19:44:59 <lf94> In the expression: (0, 1)
19:44:59 <augur> ok it all comes down to this now... cross your fingers, people!
19:45:05 <lpvb> lf94: ignore that
19:45:10 <lf94> ?
19:45:10 <napping> that's simplified a bit from you passing something I'll pretend is [(Float,Float)] where it wanted [[(Float,Float)]]
19:45:45 <lf94> lpvb: what
19:45:51 <napping> except type variables because it's probably saying Num or RealFrac or something
19:45:55 <linman32> roboguy_: interesting
19:46:00 <lf94> napping: right
19:46:05 <linman32> :k Functor
19:46:06 <lambdabot> (* -> *) -> Constraint
19:46:08 <lf94> Alright, it's just my misunderstanding of error messages
19:46:24 <roboguy_> linman32: type classes have a special kind: Constraint
19:46:31 <roboguy_> because they can go to the left of a =>
19:46:54 <roboguy_> or, at least, that is the return kind of a type class. they can take different argument kinds
19:46:57 <roboguy_> :k Monoid
19:46:57 <lambdabot> * -> Constraint
19:54:25 <lf94> What does the 'def' keyword do in haskell?
19:54:35 <lf94> I see it a lot for this charting api
19:54:58 <roboguy_> lf94: it's not a keyword
19:55:03 <lf94> function, my bad
19:55:21 <roboguy_> it's from this http://hackage.haskell.org/package/data-default-class-0.0.1/docs/Data-Default-Class.html
19:55:38 <roboguy_> it's a (controversial) way to provide a type a default value
19:55:38 <katsh> can function names have a - or _ ?
19:55:42 <katsh> just learned they can have '
19:55:45 <roboguy_> katsh: _ but not -
19:55:49 <roboguy_> unless it's an operator
19:55:49 <lf94> Oh, interesting
19:55:50 <katsh> gotcha. thanks
19:55:52 <roboguy_> you can make new operators
19:58:35 <roboguy_> lf94: one reason it's controversial is that typically with a well designed type class, you have a set of laws that go with it. it's not possible to define any laws for that type class
19:59:01 <lf94> Mmmm, ok
19:59:29 <roboguy_> Functor, for instance, has fmap id = id and fmap f . fmap g = fmap (f . g)
19:59:52 <merijn> roboguy_: Of course, one of those is redundant in haskell :)
20:00:02 <roboguy_> merijn: yep. one implies the other
20:00:05 <lf94> I feel like there is some implicit explanation I'm missing because of my inexperience.
20:00:24 <roboguy_> lf94: regarding what?
20:00:37 <lf94> Well I didn't understand your example at all
20:00:45 <merijn> lf94: The idea is that, given the type signature "Functor f => f a" I know something useful, because I know that all lawful instance of functor obey the laws
20:00:49 <roboguy_> lf94: oh, have you looked at Functor yet?
20:00:58 <lf94> Nope :/
20:01:05 <roboguy_> oh. well, don't worry about it too much yet
20:01:12 <merijn> lf94: This means that, when I write generic functor code I can reason about how it will behave for an arbitrary instance
20:01:31 <roboguy_> it will make more sense when you get to it
20:01:42 <lf94> I feel like 'laws' are a haskell concept I've yet to encounter
20:01:51 <merijn> They are not a haskell concept
20:01:52 <FreeFull> Rust has a "Default" trait
20:02:00 <FreeFull> And it's working out ok
20:02:13 <merijn> lf94: laws in this case just means "rules that should be obeyed"
20:02:23 <augur> HAHAHAAA VICTORY IS MINE!
20:02:26 <lf94> Well I know that, but why does putting Functor matter at all? heh
20:02:33 <lf94> Just to let developers know?
20:02:37 * augur dances with napping and Cale and bennofs who isnt here and everyone else
20:02:47 <roboguy_> augur: what are you working on?
20:02:53 <augur> roboguy_: a thing :3
20:03:01 <augur> roboguy_: http://www.languagengine.co/
20:03:01 <roboguy_> lf94: no, it's part of the type
20:03:26 <lf94> I know it's a part of the type now, but why bother at all? What special properties does it give other than letting a developer know that a type is "lawful"?
20:03:27 <merijn> lf94: It's about being able to reason about code
20:03:32 <roboguy_> augur: wow, nice
20:03:53 <merijn> lf94: Functor provides the function "fmap :: Functor f => (a -> b) -> f a -> f b"
20:04:03 <merijn> lf94: You may know fmap's little (less generic) brother: map
20:04:16 <merijn> :t fmap :: (a -> b) -> [a] -> [b]
20:04:17 <lambdabot> (a -> b) -> [a] -> [b]
20:04:22 <merijn> > map (+1) [1..10]
20:04:23 <HeladoDeBrownie> augur, is that your dependently typed thing?
20:04:24 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
20:04:27 <merijn> > fmap (+1) [1..10]
20:04:28 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
20:04:36 <roboguy_> lf94: one example is, if you have code written in one way that's slow, a law can sometimes guarantee that it will work exactly the same way written another way (but possibly faster/less memory usage)
20:04:42 <merijn> lf94: The difference is that fmap works on other types too
20:04:48 <merijn> > fmap (+1) (Just 2)
20:04:49 <lambdabot>  Just 3
20:04:53 <merijn> > fmap (+1) Nothing
20:04:55 <lambdabot>  Nothing
20:05:01 <lf94> Oh neat
20:05:02 <FreeFull> > fmap (+1) (+3) 5
20:05:04 <lambdabot>  9
20:05:25 <merijn> lf94: So Functor provides a "generalised" map
20:05:32 <augur> HeladoDeBrownie: yep!
20:05:33 <FreeFull> > fmap (+1) ('a',6)
20:05:34 <lambdabot>  ('a',7)
20:05:47 <lf94> Ok that is cool
20:05:52 <roboguy_> augur: wait, dependent types? in Obj-C and Java?
20:06:43 <merijn> lf94: Basically, because of the laws of Functor, you know that fmap is not allowed to change the structure of a "container", only it's contents
20:06:59 <augur> roboguy_: no, the core is haskell
20:07:01 <merijn> lf94: I put container between quotes, because things that are not containers can also be functors (like functions)
20:07:06 <augur> roboguy_: ObjC/Java will wrap around it
20:07:16 <augur> roboguy_: what im exciting about is that i just got the ObjC wrapper to work :)
20:07:28 <augur> roboguy_: ive been hacking at that for like a week and a half
20:07:32 <FreeFull> fmap on functions is function composition
20:07:54 <lf94> What's the name behind Functor mean
20:07:55 <merijn> lf94: i.e. if I know "fmap id [1..10] == id [1..10]", then I know that fmap for lists can't simply be "fmap _ xs = []"
20:08:00 <lf94> When I see Functor what should I think right away
20:08:04 <FreeFull> The name comes from mathematics
20:08:08 <roboguy_> augur: ahh. That's really cool
20:08:09 <merijn> lf94: That example type checks, but it's clearly "wrong"
20:08:11 <lf94> "Oh, the type provides fmap?"
20:08:26 <roboguy_> lf94: yeah
20:08:50 <lf94> FreeFull: So how does it apply to this? Functor is a mapping function in mathemathics?
20:08:52 <merijn> lf94: The name comes from math, but really for haskell all you need to know is "provides fmap and fmap follows the rule that "fmap id x == id x""
20:08:58 <augur> roboguy_: VERY cool indeed :D
20:09:02 <lf94> Why is there a difference between Functor and map?
20:09:13 <roboguy_> lf94: to help out beginners
20:09:15 <FreeFull> What's funny is that different languages use the word "Functor" with completely different meanings
20:09:21 <merijn> lf94: Because 25 years ago people decided that "map" is easier to explain to beginners :)
20:09:39 <merijn> lf94: And now people don't wanna change it since errors with fmap tend to have scarier messages than with map
20:09:41 <roboguy_> the type errors would be more confusing at first
20:09:44 <lf94> Well I'm a beginner and I've got to say it's confusing :-)
20:10:00 <merijn> lf94: Every language has historical warts :)
20:10:20 <lf94> Ok so from now on, guess I'm using Functors and friends
20:10:20 <merijn> lf94: Same silly reason we have a "dumb" mapM and an advanced one
20:10:26 <merijn> :t mapM
20:10:27 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
20:10:30 <augur> merijn: we need wart removal
20:10:31 <merijn> :t T.mapM
20:10:31 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
20:10:38 <lf94> Monad is the next thing I've got to tackle
20:10:41 <FreeFull> Hysterical raisins
20:10:48 <roboguy_> lf94: I'd suggest Applicative first
20:10:55 <FreeFull> AMP is firmly in by now, right?
20:11:02 <FreeFull> I haven't been keeping up with Haskell
20:11:04 <roboguy_> lf94: Applicative builds on Functor and Monad builds on Applicative
20:11:08 <merijn> FreeFull: In HEAD, yes, afaik
20:11:12 * nshepperd can't wait for 7.10
20:11:19 <FreeFull> Ok, 7.10 isn't out yet
20:11:22 <lf94> Well actually first I want this chart program to run! It's my 4th attempt and hopefully I get somewhere tonight.
20:11:36 <lf94> roboguy_: Ah, good to know
20:12:02 <roboguy_> merijn: it always looks a little ugly to me when I see someone use mapM when they could have used fmap
20:12:37 <lf94> renderableToSVGFile :: Renderable a -> Double -> Double -> FilePath -> IO (PickFn a)
20:12:38 <FreeFull> I got enchanted with Rust, which is funny because Haskell made me forget for a bit how to even write imperative code
20:12:42 <lf94> For IO can I just put "def" ?
20:12:43 <roboguy_> I guess I'm just getting AMPed up for 7.10
20:12:49 <merijn> roboguy_: eh, those two are not replaceable with eachother...
20:12:58 <roboguy_> merijn: I know, which is why I qualified it
20:13:13 <roboguy_> hopefully they will be soon!
20:13:16 <nshepperd> down with `mapM`, up with `traverse`
20:13:25 <roboguy_> (well, in one direction)
20:13:29 <merijn> roboguy_: huh, no...
20:13:44 <FreeFull> :t mapA
20:13:45 <lambdabot>     Not in scope: ‘mapA’
20:13:46 <lambdabot>     Perhaps you meant one of these:
20:13:46 <lambdabot>       ‘mapM’ (imported from Control.Monad.Writer),
20:13:51 <nshepperd> I  think roboguy_ is thinking of traverse
20:13:56 <merijn> roboguy_: mapM and fmap can never be used in the same position, AMP is irrelevant, the types are wrong
20:14:01 <lf94> :t renderableToSVGFile
20:14:02 <lambdabot> Not in scope: ‘renderableToSVGFile’
20:14:11 <nshepperd> or possibly liftM
20:14:14 <roboguy_> oh, right liftM
20:14:17 <FreeFull> liftM is fmap
20:14:26 <Fuuzetsu> merijn: const fmap; const liftM – check-mate
20:14:27 * BMeph oves AMP!
20:14:38 <Fuuzetsu> (I kid)
20:15:17 <athan> Yo guys, so I think I'm trying to make "subtypes" of Integer into instances of Bounded... is this OCaml's job?
20:15:30 <athan> (for enumerating)
20:15:35 <DanC__> I'm having trouble following this webdriver code... where are the actual HTTP network messages sent? trying SourceGraph...
20:16:10 <Fuuzetsu> DanC__: http://hackage.haskell.org/package/webdriver-0.6.0.1/docs/Test-WebDriver-Config.html ?
20:16:19 <Fuuzetsu> sent to 127.0.0.1:4444
20:16:44 <DanC__> what I mean is: what line of code causes HTTP messages to be sent?
20:17:24 <roboguy_> DanC__: you mean how do you use the API to send message or how does the package work internally?
20:17:25 <DanC__> what stack of function calls goes from runSession and openPage down to the HTTP library
20:17:30 <merijn> Fuuzetsu: I said fmap is not mapM, obviously fmap is liftM
20:17:30 <DanC__> internally
20:17:34 <DanC__> I'm trying to read the code
20:17:38 <Fuuzetsu> DanC__: WDSession has a Manager which does HTTP stuff
20:17:54 <roboguy_> DanC__: I'm sure eventually it boils down to foreign calls to C code
20:18:08 <Fuuzetsu> merijn: wow, I failed to make a stupid joke, I think I'll just go to bed
20:18:14 <DanC__> sure, it's sockets at the bottom; I'm just trying to figure out how it gets there
20:18:49 <Fuuzetsu> just grep for wdSessHTTPManager
20:18:52 * DanC__ hunts for WDSession in https://github.com/kallisti-dev/hs-webdriver/tree/master/src/Test/WebDriver
20:19:01 <katsh> installing ghci. almost 800mb.  is this right?
20:19:08 <lf94> Man the documents are even confusing for how I use IO() properly
20:19:21 <Fuuzetsu> katsh: http://stackoverflow.com/questions/4858585/why-is-ghc-so-large-big
20:19:23 <lf94> IO if I understand correctly is just a function?
20:19:25 <DanC__> Fuuzetsu, did you figure that out just now?
20:19:43 <lf94> Myfunc :: IO a => a
20:19:52 <Fuuzetsu> DanC__: Yes, I never looked at webdrive except to answer your questions
20:19:59 <roboguy_> DanC__: it looks like it uses http-client (http://hackage.haskell.org/package/http-client) which in turn uses network (http://hackage.haskell.org/package/network)
20:20:04 <katsh> by the power of greyskull. holy ****
20:20:06 <roboguy_> or do you mean up a level?
20:20:08 <Fuuzetsu> lf94: that should be -> not =>
20:20:29 <roboguy_> lf94: IO is a type
20:20:30 <DanC__> so did you grep for http, Fuuzetsu? how did you zoom in on it?
20:20:32 <Fuuzetsu> lf94: in fact you can't really have that type, can't escape the IO unless you do unsafe stuff
20:20:46 <lf94> I'm just trying to fill in an IO parameter with something
20:21:04 <dspies> How do I randomly uniformly select an element from a Data.Set.Set in O(logn) time
20:21:07 <dspies> ?
20:21:09 <roboguy_> > undefined :: IO Int
20:21:10 <lambdabot>  <IO Int>
20:21:17 <roboguy_> > return 1 :: IO Int -- Better
20:21:18 <Fuuzetsu> DanC__: no, I didn't grep for it, I went on http://hackage.haskell.org/package/webdriver, click on something likely (http://hackage.haskell.org/package/webdriver-0.6.0.1/docs/Test-WebDriver-Config.html) and I saw the Manager there
20:21:19 <lambdabot>  <IO Int>
20:21:19 <merijn> lf94: "IO a" is "an IO action that produces an Int"
20:22:10 <merijn> katsh: https://stackoverflow.com/questions/4858585/why-is-ghc-so-large-big
20:22:18 <Fuuzetsu> ‘IO action that if ever ran produces an Int’ is probably better
20:22:35 <lf94> renderableToSVGFile :: Renderable a -> Double -> Double -> FilePath -> IO (PickFn a) <- this is what I'm trying to fulfill
20:22:53 <lf94> My current line: main = renderableToSVGFile chart 800.0 600.0 "example1_big.png"
20:22:58 <Fuuzetsu> lf94: the last argument is what you get out, you're not asked to give IO at all
20:22:58 <merijn> lf94: That's the result type of the function
20:23:08 <lf94> Oh right
20:23:10 <lf94> FFFFFFFFFFF
20:23:18 <lf94> Gah, totally forgot.
20:23:24 <Fuuzetsu> ;P
20:23:42 <DanC__> ah... so you were familiar with Network.HTTP.Client , then, Fuuzetsu?
20:24:05 * hackagebot hOpenPGP 1.5 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-1.5 (ClintAdams)
20:24:08 <DanC__> "There are three core components to be understood here: requests, responses, and managers. ..."
20:24:25 <katsh> merijn: Fuuzetsu just showed me that. thanks anyway
20:24:25 <DanC__> hmm... maybe SourceGraph will finish building overnight.
20:24:36 <Fuuzetsu> DanC__: I happened to know about Manager having used it in the past but the ‘Use the given http-client Manager instead of the default’ comment and the fact that the field is called ‘wdHTTPManager’ are far more than enough to guess what it does
20:24:45 <Fuuzetsu> also you can just click on ‘Manager’ and see where it takes you
20:24:53 <katsh> does that mean my if i create a hs program, user will have to install the 800mb ghci?
20:25:03 <DanC__> ok. cool. thanks.
20:25:13 <Fuuzetsu> katsh: no
20:25:29 <merijn> katsh: No, ghc compiles to native code
20:25:34 <dspies> How do I randomly uniformly select an element from a Data.Set.Set in O(logn) time?
20:25:50 <merijn> katsh: Just like with C the user doesn't need a compiler at all to run a program
20:27:29 <katsh> oh thank goodness
20:27:55 <katsh> still 800mb. how was this acceptable 15yrs ago when hard drives were like 1-4gb?
20:28:35 <roboguy_> it probably wasn't that big 15 years ago
20:28:52 <roboguy_> ghc is under active development with new features being added still
20:28:53 <MP2E> it definitely was not that big 15 years ago.
20:29:09 <katsh> ok
20:29:26 <lf94> .~ does what again?
20:29:45 <Fuuzetsu> set
20:30:07 <Fuuzetsu> > (1, 2, 3) & _2 .~ 999
20:30:08 <lambdabot>  (1,999,3)
20:30:43 <DanC__> SourceGraph took quite a while to install, but it seems to run quickly. I suppose I should get used to that, as contrasted with python
20:31:00 <Fuuzetsu> katsh: it wasn't this big always, also it's only 800MB for you because you're probably getting multiple flavours of libraries shipped by your distro, all docs and god knows what else
20:31:19 <Fuuzetsu> the GHC binary and single flavour of essential libraries is certainly not that big
20:31:32 <DanC__> oh. it only analyzed my trivial program, not the webdriver library. hm
20:32:19 <Fuuzetsu> DanC__: you need to run it on the source of the project you're interested in, it can't do magic ;P
20:32:29 <Fuuzetsu> cabal unpack webdriver
20:32:55 <DanC__> yeah
20:33:09 <katsh> someone who studied compsci - accessing last element of a long list takes time. would it be better to reverse it and get the head?
20:33:14 <katsh> whats the big o on that
20:33:30 <merijn> katsh: Both O(n) :)
20:33:33 <Fuuzetsu> katsh: it would be better to open the first chapter of Okasaki and implement a Queue
20:33:34 <roboguy_> katsh: that would be worse if anything
20:33:42 <roboguy_> unless you only reverse at certain times
20:34:02 <dspies> Or you can use Data.Seq
20:34:28 <Fuuzetsu> which is built on these queues IIRC
20:34:40 <katsh> thanks
20:35:32 <katsh> actually did google okasaki and am looking inside his book on amazon
20:35:34 <roboguy_> it might use finger trees
20:35:56 <Fuuzetsu> according to the module header it does
20:36:10 <Fuuzetsu> the Wiki page on finger trees is bad
20:36:11 <roboguy_> katsh: I think there's a legal free version of his thesis (which, iirc, is almost the full book)
20:36:12 <dspies> katsch: It's a good book
20:36:17 <dspies> Worth reading even today
20:36:31 <Fuuzetsu> I went to look at it and it refered to the codebase of the project I was looking at to begin with (Yi) ;(
20:36:34 <katsh> must be. price is still high
20:36:55 <dspies> Try implementing a real-time queue at some point in Haskell (he says not possible in a purely lazy language, but with `seq` it is)
20:36:57 <Fuuzetsu> katsh: okasaki pdf
20:37:09 <Fuuzetsu> katsh: https://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
20:37:16 <Fuuzetsu> it's freely available
20:37:32 <lf94> :t Rational
20:37:34 <lambdabot> Not in scope: data constructor ‘Rational’
20:37:40 <lf94> :t Double
20:37:41 <lambdabot> Not in scope: data constructor ‘Double’
20:37:45 <roboguy_> every time I start to read it, the ML syntax puts me off but I've heard nothing but good things. So someday...
20:37:46 <lf94> I'm doing this wrong
20:37:48 * DanC__ calls it a night
20:37:49 <Fuuzetsu> lf94: you have to use :i
20:37:52 <roboguy_> :k Double
20:37:52 <lambdabot> *
20:37:56 <lf94> :i Double
20:37:58 <roboguy_> :k Rational
20:37:59 <lambdabot> *
20:38:02 <Fuuzetsu> lambdabot doesn't do :i
20:38:03 <katsh> thanks
20:38:19 <roboguy_> lf94: :k tells you the kind of a type
20:38:31 <lf94> Why is it spitting out *
20:38:48 <roboguy_> lf94: that's the kind of (typical, boxed) types that have values in them
20:38:56 <dfeuer> dspies, it's definitely possible to implement a real-time queue in Haskell without seq; it's just annoying.
20:38:57 <roboguy_> :k Maybe
20:38:58 <lambdabot> * -> *
20:39:11 <roboguy_> :k Maybe Int
20:39:12 <lambdabot> *
20:39:15 <dfeuer> Only mildly annoying, but annoying.
20:39:40 <dspies> dfeuer: By real-time I mean all computations take worst-case constant time.  Are you sure?
20:39:53 <dfeuer> Yes, dspies, I am.
20:39:59 <roboguy_> :k Functor
20:40:00 <lambdabot> (* -> *) -> Constraint
20:40:06 <lf94> GHC.Real.Ratio Integer <- Is that Rational?
20:40:29 <roboguy_> lf94: yeah, Rational is a type synonym for that
20:40:49 <dfeuer> dspies, the only things that can't be forced without `seq` are 1. functions and 2. polymorphic things.   Neither of those must be forced to make a realtime queue.
20:40:50 <lf94> I find that odd because I'm returning a double
20:41:01 <lf94> Pastebinning code for my sanity
20:41:12 <dfeuer> For other things, you just need to pattern match on them to force them.
20:41:42 <dspies> dfeuer: Oh, but that's just cheating
20:42:06 <lf94> roboguy_: http://pastebin.com/s6q3BrMg
20:42:17 <dfeuer> dspies, in the early history of Haskell, there *was* no fully-polymorphic seq. seq was a member of a typeclass.
20:42:20 <roboguy_> dspies: that's how Core does it
20:42:33 <dfeuer> Some people think that's how it should be now...
20:42:35 <lf94> bjbj.hs:46:27: No instance for (PlotValue (GHC.Real.Ratio Integer)) arising from a use of `def'
20:43:03 <dspies> What's the argument for eliminating seq?
20:44:07 <dfeuer> Presumably  "deriving Seq" would do the right thing, but otherwise, say,     instance Seq Maybe where seq Nothing = Nothing ; seq x = x
20:44:14 <dspies> Is Data.Set.elemAt new?
20:44:44 <dfeuer> dspies, seq is evil from a theory perspective, and breaks some nice fusion rules. Not sure what else.
20:45:07 <dspies> The compiler doesn't seem to recognize it
20:45:24 <dspies> Do I need the latest ghc?
20:45:24 <dfeuer> dspies, look through versions on Hackage?
20:45:40 <lpvb> should I start using stackage?
20:46:10 <dspies> There's no list of versions here: http://www.haskell.org/ghc/docs/7.8.3/html/libraries/containers-0.5.5.1/index.html#
20:46:44 <roboguy_> lf94: hmm, it might help if you add type signatures to prices and layout
20:46:47 <dfeuer> dspies, I can verify that it is in 7.8.3.
20:47:11 <dspies> oh, I see it's here: https://hackage.haskell.org/package/containers-0.5.0.0
20:47:15 <dfeuer> And it was not in 7.6.3.
20:48:00 <lf94> 1.0 etc is considered a Rational?
20:48:14 <dfeuer> lf94, 1.0 = 1/1
20:48:32 <lf94> How do I specify that it means Double
20:49:01 <roboguy_> lf94: it can mean either automatically
20:49:04 <roboguy_> :t 1.0
20:49:05 <lambdabot> Fractional a => a
20:49:29 <roboguy_> both are instances of Fractional
20:49:30 <athan> Is there an n-ary zip?
20:49:35 <dfeuer> Yes.
20:49:35 <lf94> Oh nevermind , it is looking for a Double
20:49:42 <dfeuer> Double is the default.
20:49:43 <roboguy_> lf94: I think the problem is the (x, (bjbj x)) part
20:49:46 <roboguy_> x is a Rational
20:49:51 <dfeuer> But you can say  (1.0::Double)
20:49:59 <dfeuer> Or you can say (1.0::Rational)
20:50:11 <lf94> roboguy_: It says here it is a Double <_>
20:50:19 <roboguy_> lf94: where's here?
20:50:23 <lf94> After adding a new function, bob :: Double -> Double
20:50:25 <dfeuer> Or you can say (1.0::Integral n => Ratio n), I think.
20:50:30 <lf94> and then doing: (bob x, bjbj x)
20:50:45 <roboguy_> lf94: that can't type check
20:50:53 <roboguy_> because bob needs a Double and bjbj needs a Rational
20:50:55 <roboguy_> you need to convert
20:51:05 <lf94> Yeah I just got to that point X)
20:51:14 <lf94> Doing this now: (x, toRational(bjbj x))
20:51:18 <lf94> er
20:51:21 <lf94> on the x, rather
20:51:25 <lf94> within bjbj
20:51:32 <roboguy_> probably you need to make it into a Double
20:51:36 <roboguy_> not the other way
20:51:51 <pithon> I've been told by Learn You a Haskell for Great Good, that this channel is useful resource. That the people in here are nice, patient, and understanding. Is this true?
20:51:57 <lf94> Oh right, the return value
20:52:17 <lf94> er
20:52:21 <lf94> the return value is a Double
20:52:49 <Cale> pithon: I hope so!
20:52:49 <lpaste> merijn pasted “Confusing type errors with {-# LANGUAGE KitchenSink #-}” at http://lpaste.net/110431
20:52:59 <lf94> Expected type: Rational   Actual type: a0 -> Rational ;o;
20:53:02 <lf94> So close
20:53:03 <dspies> It seems to be as of containers-0.5.2
20:53:08 <pithon> Cale: I'm jk. I just started reading the book. I'm on freenode a lot :p
20:53:15 <merijn> Anyone have a clue how GHC can come up with "Could not deduce (Readable sock) arising from a use of ‘f’ from the context (Readable sock)"
20:53:19 <merijn> ?
20:53:26 <merijn> That seems like the most trivial deduction possible...
20:53:42 <roboguy_> lf94: hmm, update your paste with the new code
20:53:52 <Cale> pithon: Well, we try to be useful. Feel free to ask any questions you might have about the language.
20:54:11 * hackagebot hOpenPGP 1.5.1 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-1.5.1 (ClintAdams)
20:54:11 <katsh> pithon: me too! im on the list range section
20:54:23 <pithon> katsh: did you get it for school?
20:54:23 <roboguy_> merijn: It might be because that type family isn't defined on all types
20:54:28 <katsh> no
20:54:30 <katsh> personal
20:54:40 <merijn> roboguy_: I tried defining it on all types and then it still doesn't work
20:54:41 <pithon> I did, it will be interesting to learn anyway
20:54:48 <pithon> I was working on learning D and F#
20:54:52 <katsh> schools teach haskell now?
20:54:57 <katsh> i should go back
20:54:59 <pithon> katsh: mine does
20:55:01 <pithon> lol
20:55:09 <merijn> roboguy_: I tried having a Readable typefamily that returned Bool and then having a "~ True" constraint, but that doesn't work either
20:55:11 <pithon> Most of the languages I know I've learned outside of scool though
20:55:11 <dspies> pithon: I like D
20:55:18 <pithon> D seems nice
20:55:24 <katsh> in school we learned java, which i havent used since
20:55:31 <pithon> I loath java
20:55:32 <katsh> my jobs have been in php python and js
20:55:32 <pithon> but
20:55:41 <pithon> I have to learn it
20:55:46 <pithon> I like C# way more than java
20:55:58 <pithon> I don't get why people compare java and c++.. they should teach java or C#
20:56:02 <katsh> the only thing java classes taught me was how fast it was. and made me realize i dont like it.
20:56:03 <lf94> roboguy_: ok
20:56:10 <merijn> roboguy_: Basically, I'm trying to get a function type whose result need only be defined for some subset of valid operations, rather than for all possible ones, depending on which SocketType there is
20:56:21 <pithon> katsh: I hated it as soon as I learned how java prints lines...
20:56:32 <merijn> I have no clue whether that's even possible, but you never know till you try :)
20:56:46 <lf94> roboguy_: http://pastebin.com/d2E7jKbq
20:56:57 <katsh> alas, lots of java jobs out there though
20:57:06 <dspies> pithon: Java has it's uses.  On programming contests I use Java pretty much exclusively
20:57:13 <katsh> but i will drive a cab or uber before i try to do those
20:57:35 <dspies> pithon: Eclipse autocomplete and various other features make it the quickest to find what you're looking for in a crunch
20:57:47 <roboguy_> lf94: I think the problem that the first element of the pair is a Rational and it should be Double. So you can probably get rid of toRational and do something like (fromRational x, ...)
20:57:55 <pithon> The only thinkg I like about eclipse is that it suggests what packages you might need
20:57:58 <pithon> Saves me a lot of time
20:58:05 <dspies> that's nice too
20:58:14 <dspies> and refactoring shortcuts
20:58:15 <roboguy_> lf94: also, that function call syntax is wrong
20:58:24 <dspies> easy-to-use debugger
20:58:26 <lf94> Whoops~
20:58:46 <dspies> that uses toString to display objects
20:59:04 <dspies> Also, Java's documentation surpasses any other I know of
20:59:24 <lf94> roboguy_: no go
20:59:29 <lf94> more scary errors
20:59:40 <lf94> http://paste.debian.net/119055/
20:59:49 <dspies> Sure the language doesn't give you much freedom, but what it does, it does well.
21:00:49 <mbuf> where in the base or Haskell package can I find the definition of 'class Eq a' and 'instance Eq Int'?
21:01:00 <roboguy_> lf94: try adding a type signature to layout and prices
21:01:00 <lf94> roboguy_: this is what I have now: prices = plot_lines_values .~ [[ (fromRational x, bjbj x) | x <- [0.0, 1.0..3000.0] ]]
21:01:20 <lf94> ok
21:01:29 <lf94> Not sure what I'm going to put but ok
21:01:35 <roboguy_> lf94: it should disambiguate the types
21:01:55 <roboguy_> it won't know how to select an instance without type signatures
21:01:58 <lf94> The author of the example I based this off of totally made this extremely complicated
21:02:07 <dspies> (freedom meaning freedom to optimize and create lightweight types)
21:02:47 <lf94> roboguy_: isn't prices some sort of object
21:03:06 <roboguy_> lf94: Haskell doesn't have objects
21:03:41 <roboguy_> it's a PlotLines Double Double value
21:04:23 <roboguy_> also, even if this doesn't totally fix the errors, it should make the error messages *much* more readable
21:04:24 <talios> roboguy_ - is there a correct term to an instance of a data type?  which is what I'd assume an 'object' would be in relation to class/object
21:04:35 <roboguy_> talios: instance
21:04:47 <roboguy_> (always add type signatures to top-level definitions by the way. it makes things way easier)
21:04:56 <pithon> well, I'm off to continue reading. I have programs to write
21:04:58 <pithon> lol
21:04:59 <lf94> roboguy_: where did you find the PlotLines Double Double definition
21:05:04 <pithon> see yah guys soon I'm sure.
21:05:06 <roboguy_> talios: oh, you mean of a data type. value probably
21:05:12 <talios> I suppose its just a binding of values?
21:05:13 <roboguy_> lf94: http://hackage.haskell.org/package/Chart-1.2/docs/Graphics-Rendering-Chart-Plot-Lines.html
21:07:09 <lf94> So...I add PlotLines :: Double Double to the top?
21:07:20 <lf94> Or literally PlotLines Double Double
21:08:06 <roboguy_> lf94: no, in the where add prices :: PlotLines Double Double
21:08:23 <roboguy_> that tells the compiler the type of prices is PlotLines Double Double
21:10:06 <lf94> I'm just a doofus- looked up type signature and was about to type what you gave me
21:10:47 <lf94> What do you know, program works no problem
21:10:51 <lf94> *sigh*
21:10:55 <roboguy_> lf94: nah, it just takes practice
21:11:00 <lf94> Thank you sincerely for all your help.
21:11:06 <roboguy_> this is one common trick: Add type signatures. They can help a lot
21:11:17 <roboguy_> especially add type signatures to all top-level functions/bindings
21:11:31 <lf94> You know I was sort of doing that, but instead running the variable through a function
21:11:46 <lf94> Remember the function 'bob' I mentioned earlier? that's what I was doing...heh
21:11:57 <lf94> I noticed it gave better error output
21:12:09 <roboguy_> oh, you definitely want to use type signatures instead of making functions like that
21:12:21 <nitrix> Would haskell still be a good choice for a program that does IO extensively?
21:12:24 <roboguy_> it's a lot less error-prone and more readable
21:12:31 <roboguy_> nitrix: yep!
21:12:38 <lf94> Yeah yeah, now I know :) I haven't needed to write type signatures yet. I'm new to Haskell so I'm still making my way around.
21:12:46 <linman32> is it possible to map fnct over two lists? map fnct [0,1,2] [3,4,5]
21:12:52 <zwer> :t zipWith
21:12:53 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
21:12:53 <roboguy_> nitrix: in fact, I think haskell does IO better than a lot of other languages. In Haskell, IO actions are first class values
21:13:04 <ryantrinkle> nitrix: definitely; skedge.me's whole backend is in haskell, and it's basically all web services and database code
21:13:05 <merijn> nitrix: FWIW, I write lots of IO heavy haskell and even quick hacky shell scripts in haskell
21:13:10 <roboguy_> linman32: well, there's at least two things that could mean
21:13:18 <roboguy_> what are you looking for in particular?
21:13:33 <linman32> looks like zwer has solution?
21:13:39 <merijn> nitrix: Even if every single function returns "IO a" (unlikely) then you still get to have the nice type system and convenient syntax, higher order functions, etc.
21:14:02 <merijn> nitrix: And for servers, GHC's IO manager is insanely fast
21:14:13 * hackagebot hopenpgp-tools 0.9 - hOpenPGP-based command-line tools  http://hackage.haskell.org/package/hopenpgp-tools-0.9 (ClintAdams)
21:14:15 <roboguy_> linman32: it depends on if you want to zip them or do a cartesian product style thing
21:14:16 <linman32> uh, let me think.. no return val is needed on this one
21:14:29 <roboguy_> > zipWith (,) [1,2,3] [10, 100, 1000]
21:14:29 <linman32> roboguy_: what is cartesian product?
21:14:31 <lambdabot>  [(1,10),(2,100),(3,1000)]
21:14:33 <roboguy_> vs
21:14:36 <merijn> nitrix: There's a SDN (software defined networking) program implemented in haskell that could route like 40k messages per second (or was it more? I forget...)
21:14:40 <ryantrinkle> merijn: haha yeah, those nodejs guys think their stuff is slick... ;)
21:14:41 <roboguy_> > (,) <$> [1,2,3] [10,100,1000]
21:14:42 <lambdabot>  Couldn't match expected type ‘[t1] -> f a’ with actual type ‘[t0]’
21:14:47 <roboguy_> > (,) <$> [1,2,3] <*> [10,100,1000]
21:14:49 <lambdabot>  [(1,10),(1,100),(1,1000),(2,10),(2,100),(2,1000),(3,10),(3,100),(3,1000)]
21:14:53 <roboguy_> ^ linman32: that
21:15:01 <nitrix> I've spent a couple months learning Haskell and reading on every topics whatsoever. I'd say I'm quite comfortable with the whys and whatnot. I think the only thing that prevents me from being efficient (because I did try to write something), is that I realised that I knew no standard functions. So like, I'm there, thinking "I know what I want to do, but is there a function that does that? Search on hoogle,
21:15:03 <nitrix> no. Okay, let's break it down. Great, these two." Boy it's very slow.
21:15:12 <nitrix> It reminds me of when I was learning C of something.
21:15:51 <linman32> roboguy_: interesting
21:16:01 <ryantrinkle> nitrix: what kind of stuff are you looking to write?
21:16:10 <merijn> nitrix: Err, apparently it was 20 million requests per second :D
21:16:31 <roboguy_> linman32: one way to look at that is as a nondeterministic computation. the first argument is can be thought of as a nondeterministic computation that either results in 1, 2 or 3 and likewise for the second argument
21:17:11 <trap_exit> I have two options: (1) spend 10 minutes implementing a hack that is (a) is wrong, (b) but works for most cases, and (c) is only occasionallyw rong or (2) spend 10 hours implementing a correct algorithm; so my qeustion is -- should I implement something hacked and get an end-to-end system first, or should I get this algorithm right first instead of optimizg for end to end ?
21:17:17 <nitrix> merijn: Good to know. I expected the opposite actually, since it's garbage collected and I suspect those messages must generates lot of garbage?
21:17:31 <merijn> nitrix: http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf
21:17:41 <merijn> nitrix: Paper on the new IO manager implemented for ghc 7.8
21:18:05 <ryantrinkle> trap_exit: i guess that depends on how much use it's gonna get :)
21:18:22 <merijn> nitrix: The nice thing is you can really abuse forkIO threads when writing server software :) They're more lightweight than Erlang processes and the IO manager scales them really well now :)
21:18:38 <nitrix> merijn: Are they like Go's routines?
21:18:54 <merijn> nitrix: Yes, although they may actually be lighter
21:19:08 <merijn> nitrix: Not too familiar with how much stack goroutines get
21:19:21 <nitrix> It's beefy.
21:19:34 <merijn> nitrix: And there's an equivalent of channels too :)
21:19:45 <nitrix> Glad to see Haskell is getting some love :)
21:19:56 <merijn> I think haskell's had this stuff before Go >.>
21:20:38 <nitrix> I'm very _very_ happy by every little detail so far, except for the garbage collector in GHC.
21:20:54 <ryantrinkle> hm, what's the gc issue?
21:20:56 <nitrix> I'm having a hard time understanding why such thing is necessary given the semantics of the language.
21:21:34 <merijn> Well, how else would you avoid running out of memory?
21:21:50 <merijn> And why is GC a problem?
21:22:20 <roboguy_> nitrix: it would be more surprising to me if it didn't have GC because then you'd have to manually allocate and deallocate memory everywhere
21:22:34 <roboguy_> which doesn't fit well with referential transparency and stuff like that, I think
21:22:39 <merijn> I can see stop-the-world being a problem for semi-hard soft-realtime and twitch FPS games, otherwise...
21:22:44 <lispy> nitrix: What were you hoping for? scoped resource usage, reference counting, magic compiler that gets it precise without run-time, or ... ?
21:23:13 <nitrix> Well, reference counting could be one approach, or you known, some linear types, I don't know.
21:23:48 <lispy> Reference counting becomes GC once you have the option of cyclic data.
21:23:56 <merijn> Reference counting? Why would you possibly want that?
21:24:02 <lispy> nitrix: has anyone mentioned Clean yet?
21:24:11 <nitrix> lispy: I've looked at it on my own.
21:24:17 <lispy> nitrix: also, Rust
21:24:28 <nitrix> Rust's Arc does exactly that.
21:24:39 <nitrix> So why Haskell didn't use the same approach?
21:24:54 <roboguy_> nitrix: well, the generational GC GHC uses is pretty efficient
21:25:04 <nitrix> But it's still stopping the world :(
21:26:25 <nitrix> It'd make it better than C if it wasn't of that. Yay, Haskell so great. Now I want to write a video game, ah, can't. Flight controller, ah, can't.
21:26:29 <lispy> nitrix: Haskell as a language doesn't mandate how the GC should work. GHC in particular has a GC that was developed as research while trying to figure out what would be optimal given that Haskell is very different than the majority of existing languages.
21:26:53 <lispy> I think making it asynchronous would be the next logical step, but Simon Marlow has left MSR
21:27:02 <nitrix> Right, I'm confusing specifications with implementations.
21:27:12 <nitrix> I'm still disapointed GHC took that approach.
21:27:31 <lispy> Are you disappointed enough to implement the one you want :)
21:27:40 <nitrix> Possibly.
21:27:49 <lispy> https://github.com/ghc/ghc
21:28:00 <nitrix> But then, I'd lose on all the other optimizations.
21:28:00 <lispy> https://ghc.haskell.org/trac/ghc/
21:28:08 <roboguy_> nitrix: there's some other Haskell implementations you might be interested in too. I don't think they're quite production ready, but they could be worth a look
21:28:23 <lispy> nitrix: also this  http://blog.codersbase.com/posts/2013-08-03-getting-started-with-ghc-hacking.html
21:28:25 <merijn> nitrix: Some people PSU were working on a strict haskell dialect for systems programming, but I dunno how alive that still is
21:28:38 <lispy> habit
21:28:55 <lispy> http://hasp.cs.pdx.edu/
21:28:56 <int-e> nitrix: Note that ghc doesn't have a whole lot of manpower behind it. A real-time GC would affect the entire RTS design and it would sacrifice batch performance for quick response times. So ideally, one would have two RTSs, two compiler backends... which requires manpower to maintain.
21:29:53 <roboguy_> nitrix: region inference is also something that I thought looked interesting. I've heard that it's more trouble than it's worth though
21:30:24 <lispy> roboguy_: never played with it, but I think someone told me it tends to degenerate into "this is the everything region"
21:30:42 <roboguy_> lispy: hmm, that doesn't sound very effective
21:31:15 <int-e> I would expect that lazy evaluation makes region inference hard and barely useful; too much stuff is allocated to be evaluated later in a context you know nothing about.
21:32:24 <merijn> lispy: As long as the "everything" region is big enough, it works just fine ;)
21:32:40 <merijn> lispy: Same way you GC tune Java code, right? Just add more RAM and increase the max heap :)
21:34:04 <lf94> lol
21:34:06 <lispy> nitrix: anyway, I think you have a valid complaint. I'm just not sure how we (as in, everyone involved) can improve it. I think we need a new GC champion to appear and start tweaking the RTS.
21:34:14 * hackagebot liquid-fixpoint 0.2.0.0 - Predicate Abstraction-based Horn-Clause/Implication Constraint Solver  http://hackage.haskell.org/package/liquid-fixpoint-0.2.0.0 (EricSeidel)
21:34:16 * hackagebot liquidhaskell 0.2.0.0 - Liquid Types for Haskell  http://hackage.haskell.org/package/liquidhaskell-0.2.0.0 (EricSeidel)
21:34:41 <lispy> nitrix: in a similar vein I've heard people request JIT for GHC.
21:35:07 <lispy> It *may* add a lot to GHC's performance but thus far no one has taken the bull by the horns.
21:35:27 <nitrix> Right.
21:36:15 <nitrix> What's up with the functions that begins with 'h' ?
21:36:23 <lispy> handle
21:36:24 <roboguy_> nitrix: handle
21:36:24 <int-e> lispy: would that be for ghci?
21:36:57 <lispy> int-e: No. I think the idea is that JIT can actually produce more optimal code for long running things.
21:36:59 <nitrix> Meaning it implies some kind of State monad?
21:37:09 <lf94> That is one thing that bothers me with Haskell (and many other language's) functions: not typing out words completely.
21:37:09 <joelteon> No, that would be in the RTS
21:37:25 <lispy> nitrix: no, they're like file descriptors but not as general or flexible and they're built into the language.
21:37:33 <nitrix> Okay
21:37:46 <int-e> lispy: I thought that mainly holds for dynamically typed languages.
21:37:51 <merijn> Well...I wouldn't call them built into the language
21:38:01 <merijn> AFAIK Handle is just implemented in a library
21:38:09 <lispy> built in in the sense that the Haskell report uses them
21:38:30 <merijn> nitrix: putStrln is to hPutStrLn as printf is to fprintf
21:38:52 <nitrix> merijn: That's more clear now.
21:39:01 <lispy> int-e: This is something I'm only partially aware of. Certainly not something I know a lot about.
21:39:58 <lispy> oh yeah, FILE* is a much better analogy than file descriptor
21:40:00 <MP2E> Why would a JIT speed up GHC? Ahead of time compilation almost always produces faster code, because you can perform more aggressive optimizations
21:40:07 * lispy makes a note to give that example next time
21:40:15 <MP2E> Plus the code doesn't have to be compiled block by block as called >_>
21:40:23 <simpson> MP2E: Typeclass dictionaries, automatic vectorization, etc.
21:40:36 <MP2E> hmm
21:40:57 <merijn> simpson: To be fair, GHC already aggressively inlines dictionaries when they're statically known :)
21:40:59 <yarl_> hi
21:41:11 <jle`> is there any case where a dictionary is not statically known...?
21:41:22 <lispy> fmap
21:41:23 <copumpkin> separate compilation of libraries
21:41:26 <roboguy_> jle`: you can do polymorphic recursion
21:41:26 <merijn> jle`: Sure, when the instance selection depends on runtime data
21:41:39 <jle`> copumpkin: i can see that
21:41:54 <jle`> roboguy_: oh
21:42:00 <jle`> i can see that too
21:42:02 <copumpkin> (fingertrees, for example)
21:42:15 <jle`> merijn: yeah, that's what i couldn't imagine :P
21:42:30 <merijn> jle`: Simple example, heterogeneous list :)
21:45:18 <roboguy_> jle`: another thing is, you can actually reify values into type class dictionaries and pass them around at compile time
21:45:32 <roboguy_> that's what the reflection package does
21:45:45 <jle`> the whole world feels very scary now
21:46:02 <simpson> IIUC JHC can always inline away dictionaries because it does whole-program analysis and specializes for every possibility.
21:46:05 <c_wraith> jle`: f :: Show a => a -> Int -> String ; f x 0 = show x ; f x n = f [x] (n - 1)
21:46:06 <lispy> You have Oleg to thank for that :)
21:46:11 <roboguy_> you can go the other way too, and reify type class constraints into values
21:46:20 <int-e> jle`: you don't have to look too deep. You just need a function like  sort :: Ord a => [a] -> [a]  that is too big to be inlined and is called with several times. Sure, you can specialize it to particular types but there's a limit to how many copies of the code you can afford. But yes, code where the used instances of a class is not finite exists. Say, data Tree a = Level a | Nest (Tree (a,a)) deriving (Eq,Ord)
21:46:24 <c_wraith> simpson: can't inline away dictionaries in my example!
21:46:38 <lispy> simpson: I think JHC assumes it can always do that; whether it can in practice is less certain.
21:47:25 <yarl_> Is there a "simple" way to have a type that represents example ByteStrings of length 16? Another way than length-tester-constructors, I mean can that be a constraint on the type? If it is simple then can you tell me? else some pointers? thanks!
21:47:51 <c_wraith> yarl_: There is not, in the way you hope.
21:48:08 <yarl_> c_wraith, ooh :(
21:48:19 <roboguy_> yarl_: well, you can have statically typed checked fixed size vectors. But I feel like that isn't what you're looking for
21:49:31 <yarl_> roboguy_, where should I look for informations about what you are telling me?
21:50:15 <int-e> lispy: I tried that tree example once and found that JHC falls back to a runtime representation of types of values if the class methods are not statically known. These type representations take the role of class dictionaries, more or less.
21:52:30 <yarl_> c_wraith, How would you do what I need? in a sentence.
21:53:07 <roboguy_> yarl_: I can't think of one good source, but here's an example I found https://github.com/slindley/dependent-haskell/blob/master/Box/Vec.hs
21:53:21 <roboguy_> although, it doesn't use the fancy new features
21:53:27 <c_wraith> yarl_: historically, I've done it with smart constructors.  In recent GHCs, you can do it a little more generically, but it still needs smart constructors
21:53:37 <c_wraith> roboguy_: that doesn't support bytestring as the backing structure
21:54:00 <c_wraith> roboguy_: that's inherently an inductive structure, and so not memory-compact
21:56:10 <yarl_> ok thank you both roboguy_ and c_wraith.
21:58:11 <lispy> int-e: Ah. Makes sense, but are those representations any better than dictionaries?
22:00:26 <mbuf> where in the base or in a Haskell package can I find the definition of 'class Eq a' and 'instance Eq Int'?
22:01:34 <lispy> mbuf: http://www.haskell.org/definition/haskell2010.pdf
22:01:41 <roboguy_> mbuf: you can find that by typing :i Eq into ghci
22:01:57 <roboguy_> looks like GHC.Classes
22:02:32 <int-e> lispy: it's just totally different. I've sketched the idea here: http://lpaste.net/110434
22:03:37 <roboguy_> int-e: hmm, that looks similar to the dictionary approach to me
22:05:42 <int-e> roboguy_: There's quite a big difference between passing functions (actual implementations of (==)) or type representations. Of course they both implement typeclasses.
22:06:22 <roboguy_> oh, right
22:06:31 <DanC__> findElem (ByXPath expr) might raise a NoSuchElement exception. I want to catch and ignore it. I keep getting pages and pages of error messages. suggestions?
22:07:03 <jonseymour> in a definition like: "data Int = GHC.Types.I# GHC.Prim.Int#" what does the # mean?
22:07:20 <roboguy_> jonseymour: it means it's an unboxed type
22:07:49 <jonseymour> roboguy_: thank you
22:07:58 <int-e> jonseymour: it does not mean anything really. With the MagicHash extension, ghc treats # as an ordinary part of identifiers.
22:08:23 <merijn> jonseymour: The naming convention is that names with # refer to primitive types
22:08:29 <int-e> jonseymour: But it's used for unboxed types, builtin primitives, and the like.
22:09:06 <jonseymour> int-e, merijn: thanks
22:09:32 <DanC__> the catchIt :: Exception -> Maybe () decl in realworldhaskell seems to be out of date or something; Exception has kind * -> * , no?
22:09:55 <DanC__> rather: it's a typeclass
22:09:57 <merijn> DanC__: You'll want the Control.Exception module
22:10:06 <merijn> DanC__: Note, you can only catch exceptions in IO
22:10:23 <DanC__> yes, I'm importing Control.Exception
22:10:41 <merijn> DanC__: What library is this, btw
22:10:56 <DanC__> I'm trying to use waitUntil from https://hackage.haskell.org/package/webdriver-0.6.0.1/docs/Test-WebDriver-Commands-Wait.html
22:11:24 <merijn> DanC__: You should be able to just write "findElem (ByXPath expr) `catch` f" where "f :: NoSuchElement -> IO a"
22:11:26 <geekosaur> DanC__. it's out of date, the exception sunbsystem was rewritten about the time the book was published
22:11:33 <c_wraith> Ok, I feel like either I'm really dumb tonight, or GHC has something very complicated going on:  http://lpaste.net/110435
22:11:46 <geekosaur> sometimes the haskell ecosystem changes faster than print can keep up with
22:11:56 <merijn> c_wraith: Hah!
22:12:06 <merijn> c_wraith: I ran into the exact same error and was hoping for help debugging :)
22:12:11 <int-e> lispy: JHC's approach to type classes is quite clever really: You can start translating a program by adding type representations everywhere, and then use aggressive inlining and elimination of unused arguments to erase most of them. But I still couldn't say that either approach (class dictionaries or type representations) is better than the other.
22:12:19 <merijn> c_wraith: Oh, wait, no. Mine is even more confusing
22:12:54 <merijn> c_wraith: You have 'n' vs 'n0' implying they're different, I have: http://lpaste.net/110431
22:13:02 <c_wraith> merijn: I could swear my use of the "out" binding should be pinning down the type variable...  Unless...  MonoLocalBinds is off?
22:13:14 <roboguy_> c_wraith: you need a type signature + scoped type variables
22:13:19 <c_wraith> roboguy_: I shouldn't
22:13:23 <roboguy_> hmm
22:13:32 <merijn> c_wraith: I think TypeFamilies/GADTs eliminates MonoLocalBinds?
22:13:47 <c_wraith> roboguy_: I'm using the same value as the proxy and the output.  It should make the type variables the same.
22:14:06 <mauke> what's the type of natVal?
22:14:07 <southp0105> Hi. I'm going through http://www.seas.upenn.edu/~cis194/spring13/lectures.html to teach myself Haskell. I just finished homework #1, but not sure if I did it "stylish and concise" as the problem statements said. So I put it on GitHub and created a pull request: https://github.com/southp/cs194/pull/1 . Would anyone kindly help me review the code?
22:14:07 <DanC__>     Not in scope: type constructor or class `NoSuchElement'
22:14:08 <DanC__>     A data constructor of that name is in scope; did you mean -XDataKinds?
22:14:09 <DanC__> whimper
22:14:21 * hackagebot wai-app-static 3.0.0.1 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-3.0.0.1 (MichaelSnoyman)
22:14:22 <c_wraith> mauke: proxy n -> Integer
22:14:33 <mauke> c_wraith: that looks wrong
22:14:34 <c_wraith> mauke: err, KnownNat n => proxy n -> Integer
22:14:37 <mauke> better
22:14:52 <merijn> DanC__: oh, it's not a type?
22:15:07 <DanC__> https://hackage.haskell.org/package/webdriver-0.6.0.1/docs/Test-WebDriver-Exceptions.html#v:NoSuchElement
22:15:17 <merijn> DanC__: oh, right use "FailedCommandType" as type
22:15:26 <c_wraith> Ok, yeah.  If I add MonoLocalBinds, it works.
22:15:36 <c_wraith> Huh, I could have sworn MonoLocalBinds was the default
22:15:47 <c_wraith> Or maybe that's only when also using GADTs. >_>
22:15:49 <DanC__> or maybe FailedCommand ? FailedCommandType doesn't seem to be an Exception instance
22:16:09 <mauke> yeah, 'out' looks polymorphic to me
22:16:12 <mauke> like Nothing
22:16:41 <c_wraith> mauke: I guess I'm just used to local bindings always being made monomorphic - too much time spent with extensions that require it!
22:17:09 <mauke> just use fix(tm)
22:17:14 <c_wraith> hah
22:17:16 <merijn> DanC__: Yeah, FailedCommand, typing is hard :)
22:17:34 <merijn> mauke: Any insights into my mess? :p
22:18:08 <mauke> it scares me
22:18:08 <DanC__>     Could not deduce (wd ~ IO)
22:18:15 <DanC__> is wd ~ IO a type?
22:18:17 <jonseymour> In "newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))", what does the first hash of (# State# RealWorld) mean?
22:18:38 <joelteon> It's an unboxed tuple
22:18:45 <jonseymour> ok, thanks
22:18:51 <mauke> DanC__: type constraint, ~ meaning equals
22:19:04 <DanC__> ah. hm.
22:19:19 <merijn> mauke: Aww, fear breeds character ;)
22:20:11 <DanC__> I wonder if I need to lift something. I'm trying to ignore exceptions inside this
22:20:21 <DanC__> inside waitUntil :: WDSessionState m => Double -> m a -> m a that is
22:20:55 <DanC__> class MonadBaseControl IO s => WDSessionState s where ...
22:21:05 <mauke> merijn: sorry, too many extensions I've never used. the error message looks like a ghc bug, though
22:22:09 <DanC__> this makes my head hurt: liftBaseWith (const (m >>= f)) = liftBaseWith (const m) >>= liftBaseWith . const . f
22:22:48 <int-e> southp0105: I see only minor things. I would object to  toInverseDigits(dropLastDigit n)  (put a space between the function and its argument) and similarly to double_worker(rs) (there should be a space, and then the parentheses are superfluous). I also wouldn't give a name to  rl = reverse dl.
22:23:12 <c_wraith> yarl_: http://lpaste.net/110436  This is an example of using smart constructors with some new GHC features to make what you were asking about pretty easy.  It's obviously incomplete, but there's enough there to show the basic idea.
22:23:15 <mauke> DanC__: that looks like some kind of distributive law
22:23:24 <Markz> ghc.exe: internal error: evacuate: strange closure type 248701520
22:23:25 <Markz>     (GHC version 7.8.3 for x86_64_unknown_mingw32)
22:23:26 <Markz> pls
22:23:32 <DanC__> "Lift control operations, like exception catching, through monad transformers". um... yeah, I guess that's what I'm doing...
22:23:44 * DanC__ hasn't gotten the hang of lift yet
22:24:08 <yarl_> ok, thank you, I'm reading things about DataKinds right now :)
22:24:13 <yarl_> c_wraith
22:24:22 * hackagebot xmpipe 0.0.0.1 - XMPP implementation using simple-PIPE  http://hackage.haskell.org/package/xmpipe-0.0.0.1 (YoshikuniJujo)
22:24:24 * hackagebot yesod-bin 1.2.12.7 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.12.7 (MichaelSnoyman)
22:24:38 <southp0105> int-e: Thanks for the comment. How would you suggest the naming ?
22:25:07 <int-e> southp0105: just replace rl by (reverse dl) above
22:27:13 <southp0105> int-e: Oh...you are right. That's more concise.
22:27:21 <int-e> southp0105: introducing rl as you did is by no means wrong. I just don't feel that it improves the readability of the program.
22:27:40 <lispy> int-e: At a glance it reminds me of defunctionalization
22:29:23 * hackagebot xmpipe 0.0.0.2 - XMPP implementation using simple-PIPE  http://hackage.haskell.org/package/xmpipe-0.0.0.2 (YoshikuniJujo)
22:32:08 <merijn> Cale: Whoo! I got it (semi) working, but now I have a different problem >.>
22:32:37 <merijn> I managed to produce code where including the SRead constructors leads to a type error, but excluding it leads to "non-exhaustive pattern" error :D
22:33:53 <mbuf> lispy, I was wanting to look at the source file (.lhs) or (.hs)
22:34:18 <merijn> oh, I guess this is a matter of GHC's solver not being smart enough :\
22:35:07 <lispy> mbuf: ah. In that case I'd recommend getting the sources of ghc (probably easiest if you unpack a source .tar.gz) and then use the trick others suggestion with ghci.
22:35:46 <mbuf> lispy, I was actually looking into base and primitive packages in hackage
22:35:47 <lispy> mbuf: hoogle is another good way to get to the sources but may not work for the specific example you had
22:36:01 <lpaste> merijn revised “Confusing type errors with {-# LANGUAGE KitchenSink #-}”: “Even more {-# LANGUAGE KitchenSink #-}” at http://lpaste.net/110431
22:36:26 <merijn> So excluding SRead gives non-exhaustive pattern error, including it leads to type error
22:36:37 <merijn> Somehow GHC is not smart enough to see that SRead is never valid
22:36:52 <merijn> Any suggestions how I can force GHC into seeing things my way?
22:37:14 <mbuf> lispy, I found base-4.6.0.1/Prelude.hs mentions Eq((==), (/=)), but, couldn't find the definition
22:37:27 <dfeuer> merijn, that is funny.
22:37:31 <Sensored> src/Text/Parse/ByteString.hs:326:22: parse error on input ‘if’
22:37:33 <Sensored> Failed to install polyparse-1.9
22:37:35 <Sensored> wtf
22:37:55 <dfeuer> merijn, how do you get lpaste to stick stuff in the channel? I've never been able to do that.
22:37:56 <merijn> dfeuer: I know, right :)
22:38:07 <merijn> dfeuer: Just select the channel in the dropdown?
22:38:25 <dfeuer> Yeah, I've done that! And clicked "public". And .. no dice.
22:38:46 <DanC__> merijn, interested to look at this webdriver exception puzzle for me? https://gist.github.com/dckc/5bf50193dbf98d330679
22:39:18 <dfeuer> merijn, ah, I guess you have to choose private.
22:39:43 <merijn> dfeuer: I clicked public
22:40:00 <dfeuer> Huh. Weird.
22:42:43 <merijn> DanC__: You want "ignoreNoSuchElement :: FailedCommand -> wd ()" <- requires scopedtypevariables
22:43:07 <mbuf> lispy, found it in libraries/ghc-prim/GHC/Classes.hs
22:43:16 <merijn> DanC__: And then you want "ignoreNoSuchElement NoSuchElement = return ()" and "ignoreNoSuchElement e = liftIO (throwIO e)"
22:43:51 * DanC__ gives it a whirl...
22:44:20 <int-e> dfeuer: giving a title and author could also help.
22:44:31 <merijn> DanC__: Should probably work without the type signature too
22:44:47 <SrPx> Is it true that pierce himself doesn't advise the use of types?
22:44:51 <dfeuer> int-e, I *have*. But just now in #ghc was the first success. I don't know what the deal is with that....
22:45:21 <merijn> I guess it's time to consult glasgow-haskell-users for advice on why things are broken
22:47:18 <DanC__>     Could not find module `Control.Monad.IO.Class'
22:47:18 <DanC__>     It is a member of the hidden package `transformers-0.3.0.0'.
22:47:23 <DanC__> do I really need that for liftIO?
22:47:44 <DanC__> that's where hoogle says it lives
22:47:55 <geekosaur> @index liftIO
22:47:55 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
22:48:34 <geekosaur> usually you import Control.Monad.Trans as the primary public module for it
22:49:55 <DanC__> without the type sig, I get 3 huge error messages. Do I need scopedtypevariables even without the type sig?
22:51:18 <DanC__> with ScopedTypeVariables and the decl, I still lose.
22:51:31 <DanC__>     Couldn't match expected type `FailedCommand'
22:51:31 <DanC__>                 with actual type `FailedCommandType'
22:51:34 <DanC__> hmm
22:51:38 <merijn> DanC__: oh, try replacing liftIO with liftBase
22:51:52 <merijn> DanC__: FailedCommandType doesn't exist, afaict?
22:52:02 <DanC__> yes, it does
22:52:30 <DanC__> but it's not an instance of Exception
22:52:34 <merijn> It's not the type you want, anyway
22:52:40 <merijn> because it's not the type of NoSuchElement
22:52:53 <DanC__> when I change to FailedCommandType, I get :   Could not deduce (Exception FailedCommandType)
22:52:53 <DanC__>       arising from a use of `catch'
22:53:17 <int-e> dfeuer: maybe you end up wioth a spam rating between 60 and 100 somehow. https://github.com/chrisdone/lpaste/blob/master/src/Hpaste/Model/Spam.hs is partly illuminating, but the main work seems to be done by spam assassin
22:54:07 <DanC__> any chance liftBaseWith will help?
22:54:10 <dfeuer> int-e, I really wouldn't know why... My first successful message (just now) was garbage; all the rest has been perfectly sensible code.....
22:54:59 <merijn> DanC__: Why are you trying to use FailedCommandType?
22:55:10 <merijn> DanC__: That's not the type of NoSuchElement, so that will never do what you want...
22:55:29 <DanC__> I'm flailing
22:55:35 * DanC__ comments out the type decl
22:55:36 <merijn> DanC__: And replace the liftIO in my initial code with liftBase
22:55:45 <DanC__> yes, trying liftBase
22:56:16 <DanC__> last message is now:
22:56:17 <DanC__>     Could not deduce (Exception FailedCommandType)
22:56:17 <DanC__>       arising from a use of `throwIO'
22:57:50 <lucky> I'm using Data.Aeson and I have a question about the derived Generic FromJSON stuff
22:58:06 <DanC__> maybe:     ignoreNoSuchElement FailedCommand NoSuchElement = return ()
22:59:01 <DanC__> I'm down to 1 error with: ignoreNoSuchElement (FailedCommand NoSuchElement _) = return ()
22:59:13 <lucky> one of the keys is a Haskell keyword, "type"
22:59:15 <merijn> DanC__: Why are you writing FailedCommand there?
22:59:35 <merijn> DanC__: That should just be NoSuchElement
22:59:41 <DanC__> that constructs a FailedCommand (which is an exception) out of NoSuchElement
23:00:41 <lpaste> mbuf pasted “meaning of I#?” at http://lpaste.net/110439
23:00:47 <merijn> DanC__: No, it's constructing a FailedCommandType, as you can see by the error
23:01:39 <DanC__> the errors about FailedCommandType are gone
23:01:53 <DanC__> I'm down to just  Could not deduce (wd ~ IO)
23:02:17 <merijn> DanC__: oh, "liftBase (throwIO e)"
23:02:23 <merijn> I'm guessing
23:02:45 <DanC__> yes, I'm using:
23:02:46 <DanC__>     ignoreNoSuchElement (FailedCommand NoSuchElement _) = return ()
23:02:46 <DanC__>     ignoreNoSuchElement e = liftBase (throwIO e)
23:02:55 <merijn> dfeuer: Well, I've thrown it on glasgow-haskell-users, we'll see if anyone knows
23:03:11 <amar^> what are disadvantages of Union/Occurence types over Algebraic Data types?
23:03:19 * DanC__ updates the gist...
23:03:26 <merijn> DanC__: Maybe this wd monad they're using wants a different version of throw, I'm not sure
23:03:27 <dfeuer> merijn, I didn't even know that list existed.
23:03:46 <merijn> dfeuer: There's a ton of lists :)
23:03:57 <c_wraith> lucky: you won't be able to auto-derive an instance matching your data then.  aeson isn't the greatest for matching a pre-existing format, though it can be made to do that.
23:04:17 <merijn> dfeuer: http://www.haskell.org/mailman/listinfo
23:04:29 * hackagebot http-client 0.3.8.2 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.3.8.2 (MichaelSnoyman)
23:04:29 <amar^> So (a -> a -> b) -> ((U a null)-> (U a null) -> (U b null))
23:04:51 <dfeuer> I see it, merijn. Of course, you *could* take the silly way out and give it a _, but that should not by any means be necessary.
23:05:05 <DanC__> updated: https://gist.github.com/dckc/5bf50193dbf98d330679
23:05:56 <merijn> dfeuer: But having to add _ defeats the entire purpose
23:06:08 <merijn> dfeuer: That is, statically guaranteeing all necessary cases have been handled
23:06:23 <merijn> If I'm gonna do that I might as well strip out the entire encoding thing I've got going
23:06:37 <merijn> And just do "SockOp -> IO a" or whatever
23:06:40 <dfeuer> merijn, it doesn't *actually* defeat it, but it defeats the appearance of it.
23:06:51 <merijn> It does defeat
23:06:59 <merijn> I won't have a way to know I've handled all cases
23:07:18 <merijn> If I miss a mandatory case and have a _ pattern it will silently do the wrong thing
23:07:45 <dfeuer> Well, the compiler doesn't tell you so. But the fact that adding the case gives you a type error is a proof of a different color.
23:08:00 <merijn> dfeuer: That only protects against adding *wrong* cases
23:08:08 <merijn> dfeuer: It doesn't protect against leaving out cases
23:08:17 <merijn> The latter is much worse
23:08:51 <merijn> Impossible cases can't happen anyway (that's why they're impossible)
23:09:38 <dfeuer> merijn, what the type system is doing here is proving for you that the case is impossible. Obviously, that is not good enough. I'm not arguing that it is. Just that it's something.
23:11:54 <mbuf> What do the 'I# x' mean in the definition of eqInt and neInt functions at https://www.haskell.org/ghc/docs/7.4.1/html/libraries/ghc-prim-0.2.0.0/src/GHC-Classes.html ?
23:12:02 <merijn> dfeuer: I'm just saying that your suggestion of adding a _ pattern would silently hide mandatory cases
23:12:07 <merijn> mbuf: I# is a constructor
23:12:25 <merijn> mbuf: The same way "Just" is a constructor
23:12:37 <merijn> mbuf: The # character is used to indicate unboxed/primitive types
23:14:19 * merijn goes back to obsessive-compulsively refreshing the mailing list for answers
23:14:39 <c_wraith> mbuf: in practical terms, it means it's doing low-level stuff with the internal representation of Int - usually not necessary, but sometimes a big performance win.
23:15:00 <mbuf> merijn, c_wraith okay
23:15:15 <c_wraith> mbuf: the ghc-prim library actually defines a lot of higher-level operations in terms of the low-level stuff
23:15:21 <dfeuer> c_wraith, unfortunately GHC.List doesn't import GHC.Types, so everything in that whole module uses those primitives. It's kind of disgusting.
23:16:07 <dfeuer> Hah, merijn! I can relate to that obsessive refreshing!
23:18:30 <DanC__> ooh... ./src/Test/WebDriver/Firefox/Profile.hs:          copyFile src dest `catch` ignoreIOException
23:19:31 <merijn> dfeuer: I can't really do much useful with my library until I decide how to tackle this and I'm not ready to give up on the fancy statically typed approach
23:19:45 <merijn> But on the other hand, I'm not sure what else to try without any feedback...
23:38:33 <jonseymour> can anyone provide me a gentle introduction to how the use of a rank-2 type in the definition of runST prevents '"capture" of references from one thread to another'. I have read the "Lazy Functional State Threads" paper but I guess I don't really understand the key paragraphs properly ( I don't have any background in the underlying maths )
23:41:40 <merijn> jonseymour: It has to do with "who" can pick the value of 's'
23:41:50 <merijn> jonseymour: Normal polymorphic types like
23:41:54 <merijn> :t Nothing
23:41:56 <lambdabot> Maybe a
23:42:32 <merijn> jonseymour: Can be read as "Nothing :: forall a . Maybe a", i.e. it's a value of type 'Maybe a' for ANY 'a' I could pick
23:43:21 <merijn> jonseymour: With RankNTypes you can write types like "foo :: forall b . (forall a . a -> Foo) -> Bar b"
23:43:54 <merijn> jonseymour: It's important to see that the *outer* forall is like the traditional polymorphism for things like Nothing, where the *caller* gets to pick the value of 'b'
23:44:33 * hackagebot hakaru 0.1.3 - A probabilistic programming embedded DSL  http://hackage.haskell.org/package/hakaru-0.1.3 (z)
23:44:39 <merijn> jonseymour: However, the *inner* forall is part of the functions type, so I have to give 'foo' a function that works for *any* type 'a' (i.e. foo gets to decide internall what type 'a' actually is)
23:45:11 <merijn> jonseymour: Compare with "bar :: forall b a . (a -> Foo) -> Bar b", here the caller of 'bar' gets to pick both 'a' *and* 'b'
23:47:17 <c_wraith> merijn: I sometimes feel like it's redundant for both of us to be here.  We both answer the same kinds of questions at the same time of day.  We need to work out shifts or something.
23:48:19 <merijn> c_wraith: Normally I'm in the EU time zone :p
23:48:30 <merijn> But I'm in the valley until the end of the year :p
23:48:32 <jonseymour> merijn: ok, that helps. will have to ponder it some more - thank you very much!
23:49:02 <c_wraith> jonseymour: I don't think he's done yet, either. :)
23:49:39 <jonseymour> apologies :-)
23:49:53 <merijn> jonseymour: The trick is that all operations like reading/writing to an STRef all carry this extra 's' parameter which is part of the monad instance
23:50:31 <merijn> jonseymour: Now, runST only works for '(forall s . ST s a) -> a', which means that runST gets to pick the value of 's'
23:51:05 <merijn> jonseymour: But if you try to return an STRef or action reading from one from an ST action that STRef will have a *specific* 's'
23:51:30 <merijn> jonseymour: Trying to use the resulting value in a new ST block will cause the 's' parameter to no longer be polymorphic, causing runST to reject it
23:51:48 <merijn> c_wraith: Well, you can take the extra time to help fix the bugs stopping me from working in GHC ;)
23:52:20 <merijn> thoughtpolice actually downgraded the priority of the bug I was complaining about earlier today :(
23:52:52 <c_wraith> merijn: Does it have to do with exhaustiveness checking and GADTs?
23:53:16 <mroman_> GHCi runtime linker: fatal error: I found a duplicate definition for symbol fps_minimum :(
23:53:41 <merijn> c_wraith: Yeah
23:54:00 <c_wraith> merijn: yeah, that's been flaky... probably since GADTs were added.
23:54:30 <merijn> I really need to stop postponing buying a new laptop so I can actually sanely hack on GHC and actually test the 2 bugfixes for GHC I already have lying around
23:54:45 <merijn> c_wraith: Alternatively, I'm open to suggestions for different ways to achieve the same thing :p
23:55:27 <jonseymour> merijn: ok,let me play this back to you to see if I got it
23:55:46 <merijn> c_wraith: Although SPJ implied a few people are working on improving the situation now :)
23:56:06 <c_wraith> jonseymour: it's helpful to know that nothing ST does at the type level is privileged. You can enable RankNTypes and play with them yourself
23:56:27 <merijn> c_wraith: Careful
23:56:41 <merijn> Before you know it he'll be yet another {-# LANGUAGE KitchenSink #-} addict ;)
23:56:54 <c_wraith> RankNTypes are just *so* useful!
23:57:11 <merijn> Sure
23:57:25 <c_wraith> and ImpredicativeTypes would be useful too, if they didn't destroy inference in exceptionally painful ways.
23:57:47 <merijn> c_wraith: And weren't utterly broken
23:57:59 <merijn> c_wraith: I've asked on ghc-devs to disable/mark it as deprecated
23:58:12 <c_wraith> oh, you mean the occasional error complaining that two exactly identical types don't match?
23:58:16 <merijn> Because SPJ told me it's completely broken, bitrotted and untrustworthy nowadays
23:58:41 <c_wraith> It was supposed to be removed in 6.12
23:58:53 <c_wraith> It was kind of surprising to everyone that it wasn't
23:59:27 <merijn> It starts with "RankNTypes is nice" and ends with "the first 10 lines of my file are language pragmas" :)
23:59:43 <c_wraith> Pfft.  They don't need to be one pragma per line!
