00:00:10 <merijn> Well, I admit the RankNTypes trick was confusing at first. But I don't think it gets any less confusing by practicing more haskell
00:00:11 <shachaf> I mostly don't think ST is very important or relevant for whatever the question was.
00:00:13 <bmuk> merijn: Ok, but I am interested in theory.
00:00:26 <merijn> I think you just have to struggle through it until it clicks
00:00:35 <shachaf> But it's useful to know about, sure.
00:00:53 <shachaf> RankNTypes is confusing until you have the right perspective and then it's not confusing.
00:00:54 <merijn> shachaf: Well, if he's learning CT too, clearly important/relevancy doesn't appear to be high on the list of priorities :)
00:01:17 <shachaf> But the main reason ST exists is practical in the first place.
00:01:35 <shachaf> Also, you can't implement ST yourself in Haskell, not even inefficiently.
00:01:44 <shachaf> (At least without some extra primitives.)
00:01:49 <merijn> Might be, but I've never had to use it and I found reading about it very neat and intersting
00:01:59 <Cale> Well, you can implement ST and STRef, but you can't implement runST
00:02:12 <shachaf> Cale: Can you?
00:02:15 <Cale> yep
00:02:24 <shachaf> Well, I'm not sure what it means to implement ST and STRef without runST.
00:02:27 <Cale> Use MonadPrompt or something, it's not hard :)
00:02:28 <shachaf> Sounds pretty useless.
00:02:33 <Cale> You can interpret to IO
00:02:35 <bmuk> shachaf: I'm having trouble wrapping my brain around that. I mean Haskell is turing complete?
00:02:45 <shachaf> Oh, well, OK, but that's boring.
00:02:58 <Cale> Yeah, or of course, you can interpret via the existing ST :)
00:03:00 <merijn> bmuk: I think the point of this discussion is "this is all pretty neat, but don't get to distracted by reading a whole bunch of stuff, unless you're reading it "for fun"" :)
00:03:06 <Cale> (but that's also probably considered boring)
00:03:08 <shachaf> Haskell is Turing-complete. You shouldn't care about Turing completeness.
00:03:19 <merijn> Turing-completeness is a suckers game
00:03:26 <shachaf> Cale: I mean implementing it without any magic.
00:03:36 <Cale> But the main point is that the monad itself is representable, just that the runST interpreter for it has a weird type that requires some magic to do
00:03:45 <merijn> It doesn't mean very much, and most people who talk about it don't realise that
00:03:46 <shachaf> You could almost do it except for the fact that STRefs are polymorphic.
00:03:54 <bmuk> shachaf: It was only an example :p I'm questioning what you mean when you say it can't be implemented
00:04:26 <merijn> bmuk: Turing-completeness just means you could implement something that is isomorphic
00:04:27 <shachaf> bmuk: Haskell is Turing-complete, but if it didn't have IO then you couldn't implement IO. If it didn't have FFI then you couldn't implement FFI calls.
00:04:42 <Haskellfant> is it safe to have two threads using the sample handle one only reading and one only writing?
00:04:45 <shachaf> None of these are about computability.
00:05:05 <fread2282> shachaf: could you implement IO with FFI?
00:05:08 <merijn> Haskellfant: All handle operations are implicitly atomic due to an MVar inside, so yes, but they might block eachother
00:05:14 <fread2282> (it's semantics)
00:05:20 <Haskellfant> merijn: ok thx
00:05:27 <merijn> fread2282: Well, you need IO to implement an FFI (at least one that makes sense)
00:05:44 <shachaf> fread2282: IO doesn't have semantics. Also that's really beside the point.
00:05:47 <Haskellfant> merijn: do you know where this is documented? i couldn't find it in the docs to handle
00:05:47 <bmuk> shachaf: I see what you mean.
00:06:14 <merijn> Haskellfant: I'm not sure
00:06:16 <shachaf> bmuk: Why do we write language extensions to Haskell when it's Turing-complete without them?
00:06:43 <merijn> Hell, I don't even want haskell to be Turing-complete!
00:07:00 <merijn> The more total, the better \o/
00:08:20 <trap_exit> is there a publoic statement anywhere stating that fpcomplete either uses (or funds) the likes of fay/haste/ghcjs ? (I'm just curious as I study what fpcomplete offers)
00:08:38 <bmuk> You say we couldn't implement IO or FFI in haskell before they were added to the language. Maybe my understanding of turing completeness is flawed (probably), but couldn't you obviously implement anything (I mean if we emulate an x86 processor..), it's just a matter of efficiency?
00:09:07 <Total_1mmersion> Has anyone had any luck getting ide-haskell to work in Atom?
00:09:09 <yyttr3> You can implement any computational task.
00:09:20 <merijn> bmuk: You can implement something isomorphic to any other turing complete program
00:09:29 <merijn> Isomorphic != useful
00:09:30 <Haskellfant> trap_exit: iirc chris done said in haskell cast, that they're using fay for the frontend
00:09:47 <arbn> bmuk: Conway's game of life is Turing complete. Does it have IO? Lots of really simple, primitive systems are universal machines. It's not an interesting claim.
00:09:48 <bmuk> merijn: meaning it has the same functionality?
00:09:52 <splintax> bmuk: say you wanted to write to disk, you'd also have to emulate the disk :)
00:09:57 <trap_exit> Haskellfant: cool, thanks!~
00:10:09 <yyttr3> A lot of tasks  we consider like graphics or IO are not apart of what a turing machine can do.
00:10:10 <merijn> bmuk: No, meaning that there's a two-way lossless conversion between the two
00:10:12 <fread2282> bmuk: given memory (IO!) operations, yes, but those memory operations are IO
00:10:18 <Haskellfant> trap_exit: which isn't that surprising. after all chris done has created fay :)
00:10:55 <merijn> bmuk: An isomorphism 'f' and 'g' consists of two functions (the mathematical sort), such that "f (g x) == x" and "g (f x) == x"
00:11:13 <bmuk> merijn: so inverses
00:11:20 <merijn> bmuk: Right
00:11:35 <jle`> more the fact that inverses can *exist*
00:11:49 <merijn> bmuk: I could simulate an x86 on a Turing machine made of people that push around clay tablet, but that's not very useful
00:12:20 <tdammers> merijn: at least you wouldn't have to worry about a UPS
00:13:24 <fread2282> bmuk: in order to do input/output haskell has to somehow call into the OS (or C, or so). IO is what provides that
00:14:07 <bmuk> merijn: True. I do understand why it isn't interesting or useful to discuss things in terms of turing completeness, that is just the fundamental way I think of computers, and as long as something can be defined in it, it isn't "magic"
00:14:33 * hackagebot phonetic-code 0.1.1.1 - Phonetic codes: Soundex and Phonix  http://hackage.haskell.org/package/phonetic-code-0.1.1.1 (BartonMassey)
00:15:16 <fread2282> bmuk: turing completeness (of a PL) doesn't imply access to the underlying instruction set
00:15:42 <merijn> bmuk: But the thing is, turing completeness is not a very useful property and it comes at a heavy price
00:16:10 <bmuk> merijn: what is that price?
00:16:21 <merijn> bmuk: Halting problem
00:16:43 <merijn> bmuk: Total languages aren't Turing complete, but what that buys you is the ability to statically prove that a program always halts
00:17:18 <merijn> bmuk: So the question that's more interesting than "is it Turing complete?" is "How flexible a language can we make, without introducing the halting problem?"
00:17:30 <MP2E> is there anything useful a Turing complete language can do but a Total one can't?
00:17:34 <shmookey2> and by extension allows you to prove whole bunch of other stuff
00:17:36 <MP2E> either theoretically or in practice
00:17:39 <merijn> MP2E: That's an open question
00:17:41 <bmuk> merijn: but then wouldn't you lose the ability to express certain problems we don't know if they ever finish?
00:17:48 <MP2E> ah i see, so that is *the* question :)
00:17:51 <merijn> MP2E: Also, you can sneak Turing completeness in using a hacky :)
00:18:05 <merijn> bmuk: Sure, but how many problems like that are there?
00:18:24 <merijn> bmuk: For example, a web server request should probably always return in finite time, no?
00:18:41 <fread2282> bmuk: there's something called termination checking which is a really useful (optional!) feature some programming languages have that essentially guarantees you have no infinite loops
00:18:44 <merijn> MP2E: It's basically the same trick we use for IO in Haskell
00:19:02 <bmuk> merijn: yes, but isn't the collatz conjecture one of those problems?
00:19:20 <fread2282> bmuk: the idea is to be able to turn it off when you need
00:19:21 <splintax> the problem is whether it terminates or not
00:19:26 <merijn> MP2E: Have an "infinite loop monad" that yields a continuation in a finite number of steps and have a runtime system that infinitely executes the next continuation
00:19:38 <MP2E> ahh
00:19:48 <MP2E> that makes a lot of sense, and makes me more interested in total langauges
00:19:50 <MP2E> languages*
00:20:00 <killy9999> is there a function with signature "a -> [a -> b] -> [b]" somewhere in the libraries?
00:20:08 <killy9999> hoogle shows up nothing
00:20:08 <bmuk> fread2282: so you could have portions of the program which cannot be shown to terminate, if need be?
00:20:13 <merijn> bmuk: I'm not saying we "never" want Turing completeness, I'm saying that 99.9% of all programming may never need that, so should we pay that prize for 99.9% of our code if only 0.1% needs it?
00:20:29 <jle`> killy9999: looks like sequence
00:20:34 <jle`> um
00:20:37 <jle`> flip sequence
00:20:40 <bmuk> merijn: of course not, I was just checking my understanding
00:20:41 <jle`> :t flip sequence
00:20:43 <lambdabot> b -> [b -> a] -> [a]
00:20:59 <edlinde> hi guys, if I had a function called recurse.. and its body had something like: recurse (n-1) * recurse (n-2) … and say n = 3, then would this expression reduce as : recurse(2) * recurse(1)?
00:21:04 <jle`> wow i'm surprised that actaully worked out
00:21:13 <tdammers> merijn: some languages are Turing-incomplete on purpose, but they're not general-purpose languages
00:21:14 <merijn> MP2E: It makes a lot of sense to develop servers like that, have finite request handlers that just get called repeatedly by a non-total runtime :)
00:21:17 * killy9999 tries sequence
00:21:18 <edlinde> would n be substituted in both the recursive calls?
00:21:44 <merijn> tdammers: I got into an argument with a supervisor when I said that once, so now I take care to say "total language"
00:21:49 <killy9999> yup, sequence works
00:21:58 <merijn> tdammers: The vast majority of Turing-incomplete languages are not very useful :)
00:22:15 <splintax> is the concept of a total language at odds with general purpose programming?
00:22:22 <edlinde> just trying to understand the sequence of calls.. if it means that it will first bottom out for  recurse(n-1) and then later do recurse(n-2)?
00:22:27 <fread2282> merijn: the main languages that do this are dependently typed ones where there are also used for theorem proving (and trivially, {a :: Anything; a = a}, now you can prove anything), so it's necissary to have it, but yes
00:22:28 <jle`> killy9999: yay!
00:22:31 <bmuk> merijn: is there an example of a total language in existence today?
00:22:38 <merijn> splintax: I'm more and more convinced that it is not, as I believe general purpose programming doesn't need it
00:22:40 <MP2E> Agda, I think?
00:22:42 <merijn> bmuk: Coq and Agda are total
00:22:44 <MP2E> Agda is total right?
00:22:44 <splintax> bmuk: HTML
00:22:48 <MP2E> ah okay
00:22:57 <MP2E> HTML isn't total, it's non-turing complete though
00:23:06 <splintax> what is the difference?
00:23:06 <bmuk> splintax: not sure if you're joking
00:23:08 <merijn> splintax: HTML isn't a programming language, it's a markup language
00:23:12 <merijn> splintax: You can't evaluate it
00:23:27 <fread2282> bmuk: ^
00:23:33 <fread2282> whops
00:23:34 <splintax> i'm not sure what the significance of that distinction is
00:23:44 <MP2E> because total languages can't terminate
00:23:54 <merijn> splintax: HTML can't compute
00:23:56 <MP2E> but how useful is termination properties if you aren't describing a program
00:24:15 <edlinde> anyone?
00:24:34 * hackagebot cassava 0.4.2.0 - A CSV parsing and encoding library  http://hackage.haskell.org/package/cassava-0.4.2.0 (JohanTibell)
00:24:45 <splintax> merijn: how do you define whether a language can compute or not?
00:24:54 <fread2282> bmuk: Agda, Coq, and Idris all have termination checking (that you can disable!)
00:25:13 <merijn> I don't know a good formal definition of computation
00:25:20 <MP2E> edlinde: n will be replaced by 3 yes, however that function won't terminate because there's no base case for recursion to fall back on
00:25:26 <MP2E> or at least, none that you posted :P
00:25:40 <merijn> splintax: But if you can't for example implement addition, you don't really have anything that can compute
00:25:56 <edlinde> MP2E: but will it be replaced in both the recursive calls?
00:26:13 <Haskellfant> edlinde: yes
00:26:29 <merijn> splintax: If you give me a HTML file it's just a file, it doesn't describe any computation, you can write expressions that can be evaluated in it
00:26:30 <edlinde> hmm
00:26:36 <merijn> s/can/can't
00:26:45 <bmuk> merijn: isn't computation numerical calculation?
00:26:50 <tdammers> merijn: SQL. XML. JSON.
00:26:55 <tdammers> quite useful.
00:27:04 <splintax> merijn: sounds a little circular to me
00:27:10 <edlinde> Haskellfant: so it keeps putting in the values in both calls.. and stored the expressions on a stack.. and when it bottoms out then it starts to evaluate it?
00:27:19 <tdammers> they're just not *programming* languages in the strict sense
00:27:31 <merijn> splintax: I'm not aware of any formal definition of computation
00:27:41 <merijn> splintax: In fact, that's the weakest part of the Church-Turing thesis
00:27:44 <merijn> tdammers: SQL can compute
00:27:53 <merijn> tdammers: XML and JSON can't, though
00:27:56 <tdammers> merijn: sure
00:28:00 <Haskellfant> edlinde: due to lazy evaluation it's difficult to say when exactly which parts gets evaluated
00:28:11 <tdammers> merijn: still, ANSI SQL isn't Turing complete
00:28:21 <edlinde> Haskellfant: but the end result is the same?
00:28:34 <splintax> what's the difference between main :: IO () and <computation id="main"> ...
00:28:36 <merijn> tdammers: I'm not familiar with the details of ANSI SQL
00:28:49 <merijn> splintax: IO is not part of the haskell language
00:28:52 <Haskellfant> edlinde: at the end it recurses until it finds some base case that doesn't contain recursion
00:28:57 <merijn> splintax: And there is no semantics for evaluating it
00:29:12 <merijn> splintax: But that's a detail of IO, not of haskell
00:29:13 <Haskellfant> edlinde: if you don't have that this function will never terminate
00:29:20 <edlinde> Haskellfant: yeah I get that
00:29:24 <merijn> Haskell has denotational semantics describing it's evaluation
00:29:34 * hackagebot hindent 3.3 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-3.3 (ChrisDone)
00:29:41 <edlinde> this was just the part that was a bit confusing as to what order the reductions will take place in
00:29:47 <splintax> merijn: those semantics can be encoded in an XSD
00:29:52 <splintax> or even assumed
00:30:51 <merijn> splintax: Sure, I can specify an arbitrary syntax for my programming language, including one that could be XML. But that doesn't make it XML, that means I have a different language that I invented which syntax just happens to be XML
00:31:12 <splintax> i don't see how you can formally distinguish between programming and markup languages without a formal definition of computation
00:31:29 <splintax> of course, i realise there is a practical difference between the two, but the lines seem blurry to me
00:32:09 <merijn> splintax: Well, the lack of formal definition of what a computation means seems a pretty clear distinction :)
00:32:38 <merijn> (Hey! By this logic PHP is not a programming language, score!)
00:32:49 <merijn> Although I guess PHP's semantics is "whatever the interpreter does"
00:32:56 <merijn> Which is not very useful, but it is *a* semantics
00:33:01 <merijn> XML and HTML don't have even that
00:33:25 <splintax> what about "whatever the browser does"?
00:33:44 <splintax> the fact that there are competing and subtly incompatible implementations seems to be a difference of degree not kind
00:34:22 <splintax> i'm not sure how the lack of a formal definition of 'compute' helps you to distinguish between languages that can compute (programming languages) and those that can't (document/markup languages)
00:34:23 <fread2282> there's specs for HTML and XML though
00:34:36 <merijn> splintax: The browser doesn't evaluate HTML, it just displays it
00:35:04 <merijn> splintax: Unless you're including javascript, but than we're no longer talking about HTML
00:35:24 <splintax> merijn: and isn't the difference between those two that evaluation implies computation, which we haven't/can't define
00:35:33 <splintax> (i'm ignoring JS too)
00:36:29 <merijn> In this context I'm using "computation" and "evaluation" (as in, reducing an expression to a normal form) interchangeably
00:36:46 <splintax> the point i'm trying to argue is that you can't formally distinguish between programming and markup languages without formally defining computation
00:36:54 <splintax> i'm not sure if you actually disagree with that
00:38:16 <merijn> splintax: Like I said, the lack of a good formal definition of the term computation is the main point of criticism of the Church-Turing thesis, but there appears to be a relatively universal consensus on what it "should mean"
00:39:24 <fread2282> note html+css is turing complete: https://github.com/elitheeli/stupid-machines
00:40:08 <splintax> merijn: what's the definition of a 'total' language?
00:40:36 <fread2282> (sorta)
00:40:44 <splintax> i was treating it as meaning "useful, but not turing-complete"
00:40:49 <killy9999> hm.. I'm thinking about optimisations that GHC performs during compilation
00:40:56 <killy9999> is beta-reducation always safe to perform?
00:41:22 <killy9999> this is actualy a more general question that goes beyonf GHC
00:42:12 <merijn> splintax: A total language is one in which every expression has a normal form
00:42:27 <merijn> splintax: Are you vaguely familiar with lambda calculus/simply typed lambda calculus?
00:42:44 <splintax> yes, although maybe i should put some emphasis on the word vaguely
00:43:03 <merijn> splintax: You know how the simply typed lambda calculus is strongly terminating?
00:43:21 <merijn> splintax: total is just another term for strongly terminating
00:43:33 <splintax> right
00:43:43 <merijn> splintax: That is, every expression has a normal form reachable in a finite number of steps
00:44:02 <merijn> splintax: This doesn't hold for the untyped lambda calculus, because, for example, the Y combinator has no normal form
00:44:19 <splintax> yes
00:44:53 <merijn> That's basically the difference
00:44:57 <splintax> can't you say that HTML satisfied this definition, in a weak, technical sense?
00:45:29 <splintax> since you can decide on a canonical form (a DOM, or pretty-print / browser engine output)
00:45:46 <merijn> splintax: Only if you define all HTML to always be in normal form
00:46:26 <splintax> why is that necessary? for example, you could say that HTML in normal form has no whitespace
00:46:54 <splintax> then you "evaluate" or "compute" HTML by parsing it into a valid DOM
00:46:56 <merijn> splintax: But that's not what the HTML spec says and it's not what browsers do
00:47:14 <merijn> splintax: You can make up a new spec/semantics for HTML, but then, is that really still HTML?
00:47:29 <merijn> splintax: Or is it a new language that just happens to look the same as HTML
00:47:44 <merijn> Which is a more philosophical argument than I have time for when I should be sleeping :)
00:48:04 <tdammers> well, put simply, you cannot write a HTML document that doesn't terminate
00:48:12 <tdammers> (at least not without using CSS or JavaScript)
00:48:28 <tdammers> any HTML document can be rendered in finite time
00:48:31 <splintax> right. the philosophical argument is basically what i'm trying to get at
00:48:56 <splintax> i would say that HTML is a total language beacuse of what tdammers said
00:49:16 <tdammers> javascript is obviously turing-complete; css3 is less obviously so
00:49:29 <tdammers> so throwing these into the mix would get you potentially non-terminating HTML documents
00:49:29 <splintax> where evaluation is "what browsers do", ie. convert it to a DOM and then convert that to a bitmap
00:49:35 <merijn> In the same trivial sense that "english is a total language because every valid English sentence is in normal form, therefore english is strongly terminating"
00:49:55 <headbangin> a package I am trying to use (aws), makes use of Default on Response from http-conduit / http-client. Browsing the source on github I can see that the instance is defined in http-client/Network/HTTP/Client/Request.hs, but a simple use like print $ def { HTTP.host = C.pack "http://foobar.com" } the compiler complains that no instance is defined.
00:50:05 <merijn> Trivial properties are never interesting properties
00:50:18 <tdammers> OTOH, if you define "evaluating an HTML document" as "following all hyperlinks", then a non-terminating HTML document is trivial to write
00:50:29 <tdammers> just include a hyperlink to the document itself
00:50:46 <splintax> merijn: i disagree on both points!
00:51:13 <lpaste> headbangin pasted “no instance” at http://lpaste.net/111404
00:51:14 <tdammers> the English language is actually an interesting analogy
00:51:16 <merijn> splintax: Trivial properties are uninteresting by definition
00:51:35 <merijn> splintax: They either hold for everything or for nothing, so they convery zero information
00:51:47 <merijn> splintax: Anyway, we'll have to agree to disagree, then.
00:51:57 <splintax> in that case, maybe i just disagree with your claim that it is trivially true that english is a total language :)
00:52:04 <tdammers> "This sentence is a lie" - can be "parsed" by a human in finite time, but deciding whether it is true or not does not terminate
00:52:22 <jTT> Hey, I have a function that generates [ Maybe [Text]]. I am filtering out ‘Nothing’ so to retain only [ Just [Text]]. I now try to concatenate this and have tried my luck with Data.Foldable.concatenate (or Data.Monad.liftM Data.Foldable.concatenate) but to no avail. Any hints?
00:52:29 <merijn> tdammers: I was not talking about evaluating "truthfulness"
00:52:54 <splintax> merijn: i suppose that is what you meant to exclude by the word "trivial"
00:53:06 <fread2282> tdammers: depends on the decision algo, and the human brain has one that will decide in finite time
00:53:10 <tdammers> merijn: I know. The reason I'm saying this is because it's analogous to different definitions of "interpreting an HTML document"
00:53:15 <merijn> splintax: Oh? Why? Like I said, I just define a semantics that says "Every valid English sentence is a normal form in the English language", that's what I said
00:53:32 <tdammers> fread2282: the human brain has ways of deciding that the problem is undecidable, yes
00:53:35 <merijn> splintax: Do you 1) disagree with the fact that that is total or 2) that that is not a valid semantics?
00:53:48 <merijn> splintax: If 2), how is it different from your definition of semantics for HTML?
00:54:11 <splintax> 2), and i'm not sure if it is different
00:54:43 <merijn> splintax: Then I advice you to ponder why it would be different and if not, what that means for your opinion on HTML before we continue :)
00:55:01 <splintax> that is exactly what i'm doing
00:55:12 <merijn> Although, I will probably ditch the continuation of this discussion anyway, as it's almost 1 AM and I have work tomorrow :)
00:55:19 <splintax> get some sleep!
00:55:44 <tdammers> merijn: pun intended?
00:55:55 <chintanparikh> Can someone explain why factorial :: (Integral a) => a -> a   is different from factorial :: => Integral -> Integral please?
00:56:09 <tdammers> :info Integral
00:56:27 <tdammers> chintanparikh: Integral is a typeclass. Which means the first one is valid, the second one is not.
00:56:28 <merijn> tdammers: Always :)
00:57:03 <tdammers> chintanparikh: if you mean factorial :: Integer -> Integer for the second one, then I can explain :D
00:57:05 <tdammers> merijn: ;)
00:57:09 <tdammers> merijn: now get some sleep
00:57:17 <tdammers> merijn: sleep is awesome, let me tell you
00:57:21 <chintanparikh> tdammers: Oh, so you can't use typeclasses in type declarations? Only regular types?
00:57:39 <tdammers> chintanparikh: a typeclass is not a type, so you can't use typeclasses as types directly
00:57:41 <chintanparikh> tdammers: Nope, didn't mean that. Was just curious as to why the book said the first and not the second
00:57:52 <chintanparikh> tdammers: Got it, thanks!
00:57:54 <tdammers> chintanparikh: because the first is valid and the second is not
00:58:05 <tdammers> chintanparikh: do you understand what those declarations mean?
00:58:43 <tdammers> chintanparikh: Integral a => a -> a -- a function that maps values of a type "a" onto values of the same type, where "a" implements the "Integral" typeclass
00:59:04 <tdammers> chintanparikh: Integer -> Integer -- a function that maps values of type Integer onto values of type Integer
00:59:04 <chintanparikh> tdammers: I think so. Basically that a must be an Integral, and the input and output of factorial is an integral
00:59:11 <jle`> it's an (a -> a), where both a's are the same type, and a must be an instance of Integral
00:59:11 <chintanparikh> tdammers: Right right
00:59:20 <tdammers> chintanparikh: yes, but also, the input and the output must be of the exact same type
00:59:26 <jle`> chintanparikh: note that if we somehow allowed Integral -> Integral to work, as a short-hand, it would be less expressive
00:59:39 <chintanparikh> jle`: Mind going into that a little more?
00:59:42 <jle`> if we deicded to go back and change the syntax
00:59:47 <jle`> what would that translate to?
00:59:52 <jle`> Integral a => a -> a ?
00:59:58 <jle`> or (Integral a, Integral b) => a -> b?
01:00:07 <tdammers> indeed
01:00:12 <tdammers> a choice would have to be made
01:00:13 <jle`> what about functions when you actually *want* the two types to be different?
01:00:16 <tdammers> an arbitrary one
01:00:23 <jle`> or...sometimes you have a -> b -> c -> a
01:00:29 <jle`> where you would want two to be the same...and two to be different...
01:00:32 <jle`> it happens a lot :)
01:00:52 <jle`> so the syntax as it is makes these decisions unambiguous
01:01:39 <tdammers> IMO, if a shorthand were introduced, it would have to translate to all independent type variables
01:01:41 <headbangin> are instances scoped? do they need to be exported or are they always exported?
01:01:54 <tdammers> but the current situation is still better I guess
01:02:10 <tdammers> if only because it makes it absolutely clear which identifiers are types and which are typeclasses
01:02:27 <chintanparikh> jle`: Hm, I don't fully understand. What would be wrong with Integral a -> Integral a?
01:02:34 <jle`> if they were all independent, then you wouldn't really be able to say something like a -> b -> a...but yeah, it's bad anyways, heh
01:02:36 <chintanparikh> As opposed to (Integral a) => a -> a
01:02:48 <chintanparikh> Besides the fact that the syntax is wrong
01:02:55 <chintanparikh> But I'm just interested in what you meant by less expressive
01:02:56 <jle`> what about
01:03:00 <tdammers> jle`: you wouldn't, but that's kind of the point - you'd have to resort to longhand for those
01:03:06 <jle`> :t \x -> x < 3
01:03:07 <lambdabot> (Ord a, Num a) => a -> Bool
01:03:17 <jle`> hm
01:03:20 <tdammers> chintanparikh: the syntax is also way too similar to parametrized types
01:03:28 <jle`> :t \x y -> x < 3 && y > 2
01:03:30 <lambdabot> (Ord a1, Ord a, Num a1, Num a) => a -> a1 -> Bool
01:03:37 <jle`> er
01:03:41 <tdammers> foo :: Maybe a -> Either a b
01:03:43 <jle`> :t \x y -> x + y < 3
01:03:44 <lambdabot> (Ord a, Num a) => a -> a -> Bool
01:03:45 <tdammers> vs.
01:03:54 <tdammers> foo :: SomeClass a -> OtherClass a b
01:04:03 <jle`> yeah, that's probably a stronger reason :P
01:04:37 <tdammers> it would be rather trivial to define unambiguous rules for such a shorthand notation, but I don't think it would make code any clearer
01:04:37 <chintanparikh> Hmm, still confused. It's cool, I'll keep reading the book :)
01:04:48 <jle`> chintanparikh: in the end, this is just all syntax design questions
01:04:56 <jle`> hopefully if you understand the actual syntax, you should be okay :P
01:05:02 <tdammers> chintanparikh: think of it this way: everything *right* of the => is the type signature
01:05:12 <tdammers> chintanparikh: the type signature can contain type variables
01:05:23 <tdammers> chintanparikh: type variables default to "any type is allowed"
01:05:38 <jle`> (Constraint1, Constraint2, ...) => types
01:05:48 <tdammers> chintanparikh: but the part left of the => can constrain types by demanding typeclasses on them
01:06:04 <jle`> (Constraint, Constraint, ...) => *     -- to use consistent terminology
01:06:32 <tdammers> chintanparikh: note, especially, that "any type is allowed" also means "you can only apply things to this variable that are guaranteed to work on all types"
01:07:01 <jle`> GHC allows you to specify omre things as constraints than typeclass constraints, but for now you only have to worry about typeclass constraints :)  basically the general pattenr is (all your constraints) => your types
01:07:19 <chintanparikh> Got it, thanks!
01:07:27 <jle`> (Integral a) is a constraint
01:07:33 <jle`> a -> b is a type
01:07:53 <jle`> (Maybe a) is a type
01:08:01 <jle`> unfortunately, they both kind of look the same, syntax wise
01:08:14 <jle`> so you kind of just have to remember what is what, or have GHC yell at you.  or you can ask too on ghci
01:08:53 <tranma> is there a nice way to manage a project with multiple local dependencies? I use http://lpaste.net/111407
01:18:46 <jTT> has anyone got a hint on how to achieve a function like: F:: [Maybe [a]] -> [a]?
01:19:13 <joelteon> concat . catMaybes
01:19:49 <jTT> ah great
01:19:50 <jTT> cheers
01:19:56 <shachaf> That depends on what it does.
01:20:41 <ion> @type fold . fold `asAppliedTo` (undefined :: [Maybe [a]])
01:20:42 <lambdabot> [Maybe [a]] -> [a]
01:21:00 <fread2282> :t fold
01:21:01 <lambdabot> (Monoid m, Foldable t) => t m -> m
01:21:37 <shachaf> i,i [x | Just xs <- ys, x <- xs]
01:22:42 <wz1000> Wouldn't having a strict version of '>>=' solve a lot of problems that conduits and other things try to solve?
01:22:43 <chintanparikh> So it looks like there are a billion ways to write the same thing in Haskell. Is there usually a Haskell way of doing things?
01:23:26 <shachaf> wz1000: No.
01:24:01 <wz1000> shachaf: Why?
01:24:19 <shachaf> I don't know. Which problems are you talking about and which solution are you proposing?
01:24:33 <joelteon> chintanparikh: yes
01:24:41 <wz1000> shachaf: lazyIO doing lots of weird things
01:24:46 <joelteon> [x | Just x <- xs] is catMaybes xs
01:25:04 <joelteon> catMaybes is the standard library function that does it
01:25:15 <shachaf> Well, the whole point of all those libraries is that we *want* the lazy I/O behavior.
01:25:36 <shachaf> Or at least there are a bunch of parts of it that we want.
01:25:55 <jle`> wz1000: (>>=) strict on its arguments?
01:26:04 <jle`> evaluationg (IO a) doesn't evaluate the result of the computation
01:26:19 <jle`> it just evaluates the description of the computation
01:26:29 <jle`> similarly, evaluating (a -> IO b) doesn't evaluate any results, either
01:26:41 <jle`> or mayb ei am misunderstanding something
01:26:45 <wz1000> jle`: No, not on its arguments
01:27:31 <jle`> also, i always thought that conduit, etc. were for solving predictable streaming IO behavior?
01:27:35 <jle`> not necessarily strict IO
01:27:55 <jle`> reading a file line by line and operating at it one at a time and closing it is the desired behavior, not reading it all in at once, processing it all in memory, and then closing
01:28:25 <jle`> the problem with "Lazy IO" is that you can't really predict or control anything that happens
01:29:04 <jle`> making everything strict only makes conduit/pipes/etc. even more obviously needed :)
01:29:39 <wz1000> jle`: I meant that it should be strict on what it 'feeds' to  (a -> m b)
01:36:59 <nshepperd> strict IO is actually the 'normal' case, I believe
01:39:51 <nshepperd> in that the implementation of lazy getContents involves unsafeInterleaveIO to get around the usual sequencing of actions
02:05:40 <Jamie23>  You can find funny videos here. http://tinyurl.com/ozfvxy3
02:49:45 * hackagebot shell-conduit 3.0 - Write shell scripts with Conduit  http://hackage.haskell.org/package/shell-conduit-3.0 (ChrisDone)
02:54:45 * hackagebot hindent 3.4 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-3.4 (ChrisDone)
02:55:31 <beckyconning> does anyone know of something between threadDelay and timeout? like timeout but that always waits for the provided duration before providing the result. i was going to re-implement it from the code for timeout but i think a bunch of mingw compatability stuff was added in the last few days.
03:00:03 <mvr> hey, I have some external program that is constantly appending to a text file. Is there a way to read this file in haskell so I don't have to go from the beginning of the file each time I check for new data? Ideally it would end up as a lazy infinite something that blocks until the next chunk is ready
03:01:49 <danilo2> Hello! Does anybody know how should we handle tab to space conversion in Trifecta in proper way?
03:02:45 <tdammers> danilo2: I wonder if Trifecta should handle that at all
03:03:04 <tdammers> danilo2: wouldn't it make more sense to leave it up to whatever parsing rules you write against it?
03:03:29 <tdammers> danilo2: after all, there is not one single universally correct way of converting
03:04:37 <danilo2> tdammers: hmm, I do not think so. I want to convert it using my rules, but before parsing the text. I'm writing indentation based parser and I'm asking trifecta what is current line / column. To get proper results I've got to convert tabs to spaces before parsing Iif I'm not wrong
03:05:03 <tdammers> hmm
03:05:24 <tdammers> pragmatic thought: pre-process your input, converting tabs to n spaces?
03:05:48 <tdammers> also, depends on your definition of "column"
03:06:04 <tdammers> 1 tab = 1 column? 8 columns? move forward to next multiple of 8?
03:06:42 <danilo2> tdammers: Not so easy. This language has option to change this setting (using pragma) even inside of the file. So I want to do it during parsing. Additional - I would love to ask how to preprocess it in proper way, when using some functions like parseFromFile - I think there are some bytestring optimizations under the hood and I just do not know this topic well
03:06:48 <Arahael> columns rely on a notion of fixed width characters, imho.
03:07:18 <tdammers> Arahael: sure, but tabs are kind of an implementation-defined exception
03:07:24 <danilo2> Arahael: yeah, but tabs can be of 10 spaces width if you wish to :)
03:07:38 <Arahael> or to configurable tabstops? ;)
03:08:34 <ChristianS> move forward to next multiple of either 4 or 8 is most typical, but generally tabs are a mess
03:09:30 <tdammers> ChristianS: correction: tabs inside a line are a mess
03:09:39 <tdammers> tabs at the beginning of a line are quite convenient actually
03:10:53 <tdammers> (not that I want to start yet another flamewar...)
03:10:54 <Guest42469> @type MaybeT
03:10:54 <lambdabot> Not in scope: data constructor ‘MaybeT’
03:10:56 * ChristianS wisely decides not to flame back at tdammers
03:11:01 <Guest42469> @type Control.Monad.Trans.MaybeT
03:11:03 <lambdabot>     Not in scope: data constructor ‘Control.Monad.Trans.MaybeT’
03:11:07 <danilo2> tdammers: I fully agree with you
03:11:10 <chintanparikh> Hey people - I'm having a little troubling understanding how this code generates the fibonacci sequence. `fib = 1 : 1 : zipWith(+) fib tail(fib)`. Here's my logic. You start with a list [1, 1]. The next element takes [1, 1], and [1] and adds them together while zipping, so you get 2. So now fib is [1, 1, 2]. Repeating this process - zipWith(+) [1, 1, 2] [1, 2] is [2, 3]. I'm confused as to how the 3 is added onto the list inste
03:12:00 <shachaf> Your message was cut off at "list inste".
03:12:07 <shachaf> Anyway, there's only one list here.
03:12:23 <shachaf> Things aren't "added onto" the list -- you might say that you "discover" more of the list as you go along.
03:12:37 <shachaf> [1, 1] -- a 2-element list -- is never a thing at any point in time.
03:13:13 <chintanparikh> list instead of [2, 3]
03:13:29 <chintanparikh> And hm okay - any chance you could explain how it works to me?
03:14:06 <shachaf> Do you understand simpler examples?
03:14:14 <shachaf> l = 1 : l -- what's l?
03:14:25 <chintanparikh> 1?
03:14:46 <ion> If that was the case then 1 = 1 : 1
03:14:49 <shachaf> Wait, you're the person who confused :l with :1 earlier. You must have a confusing font.
03:14:56 <shachaf> foo = 1 : foo
03:14:59 <shachaf> What's foo?
03:15:07 <chintanparikh> Uh
03:15:08 <chintanparikh> Not sure
03:15:15 <Jaxan> it starts with a 1
03:15:22 <Jaxan> that's for sure
03:15:38 <shachaf> Well, start with what its type is.
03:15:40 <chintanparikh> Yep that makes sense
03:16:02 <chintanparikh> shachaf: Num?
03:16:11 <Gurkenglas> :t (:)
03:16:13 <lambdabot> a -> [a] -> [a]
03:16:17 <shachaf> Num isn't a type. :-(
03:16:27 <shachaf> OK, let's go for a simpler example.
03:16:33 <shachaf> foo = 1 : []
03:16:53 <shachaf> Let's pretend that 1 :: Int, to avoid unhelpful type class business.
03:17:31 <chintanparikh> Okay, so foo is the list [1] right?
03:17:42 <shachaf> Right.
03:18:01 <shachaf> And its type is [Int]
03:18:20 <chintanparikh> shachaf: Makes sense
03:18:40 <shachaf> How about foo = 1 : 2 : 3 : []?
03:18:46 <chintanparikh> [1, 2, 3]
03:18:50 <shachaf> Diablo 2 assassin 58:52 speedrun - segment 6-9
03:18:50 <shachaf> How Diablo 2 assassin 58:52 speedrun - segment 6-9
03:18:54 <shachaf> Er.
03:19:03 <chintanparikh> But, I don't get why [] basically ends the list
03:19:06 <shachaf> How about foo = 1 : 2 : 3 : foo?
03:19:20 <shachaf> "the end of the list" is what [] is.
03:19:21 <chintanparikh> In my head, I'm comparing it to a string termination character in C, but i'm assuming that's wrong
03:19:26 <chintanparikh> Ah okay
03:19:31 <Gurkenglas> What? No.
03:19:39 <shachaf> Compare it to NULL in a linked list in C.
03:19:41 <haasn> [] is not a character
03:19:50 <chintanparikh> Oh, so then foo is an infinite list of [1, 2, 3, 1, 2, 3 ...]?
03:19:52 <haasn> [] is an empty list
03:19:58 <Gurkenglas> ":" takes a value on its left side, and a list of the same value type on its right side
03:20:08 <Gurkenglas> Appends the left side to the beginning of the right side and outputs the result
03:20:29 <Gurkenglas> Appending 1 to the front of the empty list gives a list that consists only of [1], thats why he used [] ther
03:20:33 <chintanparikh> Ah okay, so it's basically just appending to an empty list
03:20:58 <chintanparikh> Got it, so foo = 1 : foo is [1, 1, 1, ...] right?
03:21:05 <shachaf> Pretty much.
03:21:16 <shachaf> That ] is kind of out of place there, because the list never actually ends.
03:21:22 <shachaf> [1, 1, 1, 1, ...
03:21:33 <chintanparikh> Got it
03:21:58 <haasn> > let foo = 1 : foo in foo
03:22:00 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
03:22:25 <shachaf> Now: foo = 1 : map (+1) foo
03:22:34 <Gurkenglas> The computer never "realizes" that the list is endless, but if you ask it for the third element it goes like this: "The third element of foo is the third element of 1:foo is the second element of foo is the second element of 1:foo is the first element of foo is the first element of 1:foo is 1
03:22:43 <Gurkenglas> *."
03:23:04 <chintanparikh> shachaf: [1, 2, 3, ...]
03:23:32 <shachaf> Yes. How does that work?
03:23:44 <chintanparikh> shachaf: Trying to wrap my head around it
03:23:58 <chintanparikh> shachaf: It makes sense, I just can't put it in words
03:24:58 <chintanparikh> shachaf: Actually I'm not too sure
03:25:49 <chintanparikh> shachaf: I'm used to thinking in iterations, but that clearly wouldn't work
03:26:25 <Gurkenglas> Try to think through what it would do if you ask it for the second or third element.
03:27:47 <Gurkenglas> Shall I demonstrate?
03:27:52 <chintanparikh> One sec
03:28:14 <chintanparikh> Here's what I'm thinking: Asking for the first element is 1, it's already defined. Asking for the second element takes the 1, and adds 1 to it, so 2. So now you have 1, 2. Asking for the third element takes the [1, 2] and adds one, so [2, 3]. But that's clearly not right. Where am I going wrong?
03:29:00 <Gurkenglas> What's not right about that?
03:29:02 <nyuszika7h> it's like the fibonacci sequence, which is usually implemented with recursion too
03:29:26 <shachaf> There's no [1, 2] or [2, 3] anywhere.
03:29:41 <chintanparikh> Gurkenglas: The third element is 3, not [2, 3]
03:30:00 <chintanparikh> shachaf: Then what does it map over?
03:30:05 <shachaf> An infinite list.
03:30:11 <nyuszika7h> for [1, 2, 3... the first element is N, which is known to be 1, the second is (N+1), the third is ((N+1)+1), etc.
03:30:18 <shachaf> foo = 1 : bar
03:30:24 <shachaf> bar = map (+1) foo
03:30:44 <shachaf> What's map (+1) foo? Well, since foo is 1 : bar, it's the same as (1+1) : map (+1) bar
03:30:47 <shachaf> Right?
03:31:01 <nyuszika7h> (IIRC in Haskell, it won't actually compute it over and over again, it will already know that (N+1) is 2 and so on)
03:31:04 <fread2282> chintanparikh: the list starts as (1 : Thunk) then becomes (1 : 2 : Thunk), etc
03:31:20 <Gurkenglas> chintanparikh, the third element is the second element of map (+1) [1,2,(something)
03:31:23 <shachaf> Oh well, I'm done anyway.
03:31:37 <nshepperd> I think it's easier to construct head/tail than nth element directly
03:32:15 <chintanparikh> Hmm okay I think this makes sense. Thanks people!
03:32:47 <Gurkenglas> I have the feeling he just fled because of the crowding :I
03:34:47 <chintanparikh> Wait so for anyone still around. Shachaf said "What's map (+1) foo? Well, since foo is 1 : bar, it's the same as (1+1) : map (+1) bar "
03:35:00 <chintanparikh> So then the list is 1:2:bar
03:35:12 <chintanparikh> How do you go to the next step then?
03:35:44 <nshepperd> (1+1) : map (+1) bar
03:36:09 <nshepperd> so the list is 1 : 2 : map (+1) bar
03:36:16 <nshepperd> (not 1:2:bar)
03:36:40 <fread2282> 1: (let new = (1+1) : map (+1) new in new)
03:37:03 <nshepperd> and bar = map (+1) foo, so that's actually 1 : 2 : map (+1) (map (+1) foo)
03:37:15 <fread2282> 1 : 2 : map (+1) (2 : map (+1) ...)
03:37:24 <nshepperd> or, 1 : 2 : map (+2) foo
03:37:32 <nshepperd> rinse, repeat, etc
03:37:37 <chintanparikh> Ahh
03:37:42 <chintanparikh> That finally makes sense
03:37:44 <chintanparikh> Thanks so much!
03:46:06 <kcc> Hi, question here. I have written a custom container which is instance of Functor. I can write `fmap ((,)0) a` to turn each value into a tuple (0, value). But how can I make the value increasing (different at each time)? It's like `zipWith (,) [0..] a` except for a custom Functor type.
03:46:52 <kcc> I'm thinking of using the state monad but I don't know how/where to write the state transform function
03:48:03 <steffen> When I want to use the FFI to wrap a function which can get stdout or stderr as an arguemnt, what type do I use in Haskell and what do I pass for stdout or stderr?
03:50:23 <ClaudiusMaximus> steffen: what type does your foreign code expect?  FILE * ?
03:51:30 <ClaudiusMaximus> kcc: sounds like a use-case for Traversable, maybe see if your container can be made an instance of that
03:53:10 <kcc> so I will use ((->)r) as the applicative?
03:59:16 <nshepperd> :t hoist
03:59:18 <lambdabot> Not in scope: ‘hoist’
03:59:50 * hackagebot conduit-iconv 0.1.0.0 - Conduit for character encoding conversion.  http://hackage.haskell.org/package/conduit-iconv-0.1.0.0 (slomo)
04:01:50 <Arahael> So I was looking the other day at teh Haskell implementations.
04:02:03 <Arahael> Am I right to feel that non-ghc implementations are dying?
04:03:48 <steffen> ClaudiusMaximus: yes
04:05:52 <ClaudiusMaximus> steffen: http://hackage.haskell.org/package/base-4.7.0.1/docs/Foreign-C-Types.html#t:CFile  but it seems there are no functions to generate one from a handle or anything
04:07:15 <nshepperd> kcc: you can use State as the applicative
04:08:30 <dzhus> monochrom: thank you for http://lpaste.net/110762#a110769, i've just got the message
04:09:41 <ClaudiusMaximus> steffen: so i guess one hack might be to fdopen() 1 or 2 in a foreign wrapper function...
04:10:05 <ClaudiusMaximus> steffen: ...and if you're having to use a foreign wrapper function you might as well use the foreign stdout/stderr
04:11:20 <ClaudiusMaximus> steffen: there exists handleToFd in the unix package, but that closes the handle, which would probably cause the rest of the haskell stuff to break
04:12:59 <ClaudiusMaximus> kcc: not sure, i've never made a Traversable myself, just assuming that its mapM with State could do what you want
04:13:57 <kcc> ClaudiusMaximus: ah thanks, I'll try
04:14:50 <nshepperd> traverse (\b -> do { a <- get; put (a+1); return (a,b) })
04:15:50 * hvr realizes he finds it's surprisingly satisfying to write code containing "pure Nothing"
04:16:35 <kcc> I used mapM and it seems to do it: runState (mapM counter "hello") 0 where counter t = state $ \ctr -> ((ctr,t),succ ctr)
04:17:23 <kcc> Now I'll try to figure out how to make my container Traversable, thanks
04:18:34 <nshepperd> alternatively, if you can write a zippy Applicative instance for your container, and also the equivalent of [0..] you could write liftA2 (,) [0..] a
04:22:16 <steffen> ClaudiusMaximus: okay thank you for now, I'll try with that
04:27:33 <Taira> Hi people! I am trying IO for the first time and I have a problem. The following code does no run and I do not understand the error message.
04:27:34 <Taira> http://pastebin.com/qYdkcWUc
04:27:41 <Taira> Any idea?
04:28:36 <doismellburning> Taira: it is hard to help you usefully without the error message + a definition of "does not run"
04:28:50 <Taira> Oh, give me a sex
04:28:52 <Taira> sec*
04:29:42 <tdammers> Taira: freudian? :x
04:32:04 <Taira> http://pastebin.com/vJXfivY3
04:32:09 <Taira> The error
04:33:02 <Taira> And well, "does not run" means that I  am unsure what to call it. Does not compile?
04:33:37 <doismellburning> :t num
04:33:39 <lambdabot>     Not in scope: ‘num’
04:33:39 <lambdabot>     Perhaps you meant one of these:
04:33:39 <lambdabot>       ‘sum’ (imported from Data.List),
04:33:53 <doismellburning> Taira: what do you believe line 3 does?
04:34:09 <tdammers> Taira: num is polymorphic
04:34:12 <tdammers> so is print
04:34:29 <ClaudiusMaximus> Taira: it doesn't know what type your num is, maybe try   (1, 100 :: Int)
04:34:54 <tdammers> so the type checker cannot unambiguously infer exactly one type
04:35:03 <Taira> tdammers: I do not know of what polymorphic means
04:35:23 <tdammers> foo :: Int -> Int -- this is not polymorphic
04:35:27 <tdammers> foo :: Int -> a -- this is
04:35:37 <Taira> Oh I see
04:35:50 <tdammers> print is polymorphic in its argument: it accept anything that implements Show
04:36:04 <tdammers> and num is polymorphic in its return value: it can produce anything that implements Num
04:36:14 <Taira> But is not Int a member of Show?
04:36:18 <tdammers> it is
04:36:22 <tdammers> but there are more
04:36:37 <tdammers> and other code, outside the current module, might introduce even more
04:37:07 <tdammers> for starters, the type checker cannot decide whether it should be using Int, or Integer, or Double, or Float, or any of the other types that implement both typeclasses
04:37:23 <Taira> When I tried the range with characters instead of integers it worked for some reason...
04:37:29 <tdammers> yes
04:37:36 <tdammers> that's because character literals are not polymorphic
04:37:40 <tdammers> :t 'a'
04:37:42 <lambdabot> Char
04:37:44 <tdammers> :t 1
04:37:45 <lambdabot> Num a => a
04:37:49 <tdammers> see?
04:37:57 <Taira> Yes
04:38:12 <tdammers> so the range isn't polymorphic, which makes the call to randomR also not polymorphic, which again makes num not polymorphic
04:38:26 <Taira> Oh
04:38:32 <tdammers> and once num isn't polymorphic, it dictates the type that print has to consume
04:38:48 <Taira> So I need to specify that the range numbers are Ints for example?
04:38:56 <tdammers> that would be one solution
04:39:08 <tdammers> you could also give `num` an explicit non-polymorphic signature
04:39:32 <tdammers> i.e., write `num :: IO Integer` (or Int, or Double, or whatever you prefer)
04:40:00 <tdammers> well, not actually IO, but I think you get what I mean
04:40:06 <Taira> I do
04:40:10 <Taira> Thank you very much
04:41:50 <Taira> Now it works all right
04:41:54 <tdammers> np
04:46:47 <Arahael> I'm trying to get ghcjs to work, but I have these errors; do I need to update my LD_PRELOAD path?
04:46:50 <Arahael> /usr/bin/ld: cannot find -lHSmtl-2.2.1-ghc7.8.3
04:46:52 <Arahael> /usr/bin/ld: cannot find -lHStransformers-0.4.1.0-ghc7.8.3
04:48:33 <Arahael> (Hmm, indeed, those libraries don't exist on my system)
04:54:11 <BoR0> @hoogle not :: Bool -> Bool
04:54:14 <lambdabot> Prelude not :: Bool -> Bool
04:54:14 <lambdabot> Data.Bool not :: Bool -> Bool
04:54:14 <lambdabot> Data.Foldable notElem :: (Foldable t, Eq a) => a -> t a -> Bool
04:54:22 <BoR0> @src Data.Bool.not
04:54:22 <lambdabot> Source not found. I've seen penguins that can type better than that.
04:58:58 * Arahael considers challenging lambdabot to that claim.
05:10:07 <hvr> > complement True
05:10:09 <lambdabot>  False
05:10:34 <hvr> > True .|. True
05:10:36 <lambdabot>  True
05:11:33 <hvr> > True `xor` False
05:11:34 <lambdabot>  True
05:13:35 <tdammers> hvr: lambdabot responds to private messages, too
05:31:07 <exio4> ng
05:31:15 <exio4> oops
05:38:13 <DannyFritz> I'm having trouble figuring out types for my euler project #2 function definition. http://hastebin.com/omojijuqab.hs
05:39:27 <RegEchse> DannyFritz: are you _still_ (for about 10 h now) working or again? :D
05:39:38 <DannyFritz> RegEchse: i went to sleep. :P
05:39:59 <RegEchse> oh, so you're dreaming of haskell right now? :)
05:40:13 <DannyFritz> i actually did dream a little bit about haskell
05:40:55 <exio4> in a few months you'll start dreaming about category theory!
05:41:14 <DannyFritz> lol, i dreamt about that back in my computer science days
05:42:22 <DannyFritz> i think this error is telling me it can't go from the type of sum fibs -> b
05:46:32 <RegEchse> :t 4e6
05:46:33 <lambdabot> Fractional a => a
05:46:42 <RegEchse> DannyFritz: ^ that's you first problem
05:47:31 <RegEchse> and maybe you want simply 'Integral a' in the type of problem2
05:47:58 <DannyFritz> can i not use scientific notation and get an int?
05:48:00 <RegEchse> also fibs lacks a type signature, which is a bad idea because of the monomorphism thingy
05:49:13 <RegEchse> > 4e6 :: Int
05:49:15 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Types.Int)
05:49:15 <lambdabot>    arising from the literal ‘4e6’
05:49:17 <RegEchse> no ;)
05:49:24 <RegEchse> > 4*10^6 :: Int
05:49:26 <lambdabot>  4000000
05:49:47 <exio4> > fromIntegral (4e6) :: Int
05:49:48 <lambdabot>  No instance for (GHC.Real.Integral a0)
05:49:49 <lambdabot>    arising from a use of ‘GHC.Real.fromIntegral’
05:49:49 <lambdabot>  The type variable ‘a0’ is ambiguous
05:49:49 <lambdabot>  Note: there are several potential instances:
05:49:49 <lambdabot>    instance GHC.Real.Integral GHC.Types.Int
05:50:02 <RegEchse> DannyFritz: http://www.haskell.org/haskellwiki/Monomorphism_restriction  @ fibs not having a type signature
05:50:19 <RegEchse> fibs :: (Integral a) => [a]   -- would work fine
05:50:57 <exio4> but isn't that going to be O(^n)?
05:52:32 <DannyFritz> it seems O(n) to me
05:53:33 <exio4> oh, nevermind, was thinking about the naive memoized version
05:54:20 <DannyFritz> I memoize a lot in other languages. Is it easy to do in Haskell?
05:54:52 <doismellburning> surely memoisation is pointless since you have referential transparency?
05:55:12 <DannyFritz> yeah, i guess it isn't really as applicable
05:55:47 <bezirg> hello, how do I write inline comments in .cabal ? -- works only in the beginning
05:56:04 <exio4> http://www.haskell.org/haskellwiki/Memoization
05:56:10 <RegEchse> DannyFritz: btw, "I'm having trouble (...)" <- is that a "can someone show me a correct version of my snipped" or a "give me pointers"? ;D
05:57:04 <XniX23> doismellburning, could you explain this? what is this word?
05:57:30 <doismellburning> XniX23: what word
05:57:31 <doismellburning> ?
05:58:05 <DannyFritz> RegEchse: i just picked up haskell yesterday and have been going through the learnyouahaskell book. decided the next step to learn was euler project problems. I keep hitting snags and my Haskell Google fu hasn't been up to snuff so I have been turning here for help.
05:58:21 <XniX23> doismellburning,  referential transparency
05:58:38 <DannyFritz> RegEchse: pointers as opposed to answers preferred
06:03:37 <RegEchse> DannyFritz: ok. I gave you a few. Here's another: you should specify a type class (of e.g. 'Integral') for b, too, as your function otherwise promises that its output can act as any type i like (which it doesn't).
06:03:44 <bezirg> I use "cabal freeze"  and this generates a cabal.config file under the project's dir. If I distribute my project as git, will cabal pickup this frozen constraints?
06:04:35 <doismellburning> XniX23: https://en.wikipedia.org/wiki/Referential_transparency_(computer_science)
06:06:17 <k00mi> DannyFritz: there are a few memoization libraries on hackage
06:06:35 <XniX23> oh i see, thanks doismellburning
06:07:15 <k00mi> doismellburning: ref. trans. is a prerequisite for memoization, in no way does it make it pointless
06:07:34 <doismellburning> k00mi: pointless in the context of compiler optimisations
06:07:50 <quchen> RegEchse, DannyFritz: There is a new extension, NumDecimals, that allows things like 1e6 for any Num.
06:07:55 <quchen> Since 7.8.
06:08:24 <DannyFritz> hooray, i got it RegEchse. thanks. I'm not completely convinced "Integer" was the best way to go fo everything though: http://codepad.org/SDZwkYj9
06:08:52 <doismellburning> (no?)
06:09:00 <k00mi> DannyFritz: a common simple approach to memoization is to lazily create a list where the index is the parameter
06:09:15 <DannyFritz> k00mi: a map?
06:09:54 <k00mi> not really, you can't have infinite maps
06:09:56 <RegEchse> quchen: interesting
06:10:25 <DannyFritz> quchen: oh, i'll look into NumDecimals. Thanks
06:10:39 <Gurkenglas> Anyone know the function that has type (a->b)->(a->c)->(b->c->d)->a->d and makes sense?
06:10:57 <quchen> ?djinn (a->b)->(a->c)->(b->c->d)->a->d
06:10:57 <lambdabot> f a b c d = c (a d) (b d)
06:11:06 <k00mi> doismellburning: even as a compiler optimization, ref. trans. makes memoization much easier
06:11:30 <Gurkenglas> @pl f a b c d = c (a d) (b d)
06:11:30 <lambdabot> f = flip . (ap .) . flip (.)
06:11:33 <RegEchse> DannyFritz: gratz. Here https://gist.github.com/J0J0/3c61891d8ec9157a38ab is the polymorphic version of your working code. ;)
06:11:53 <Gurkenglas> Hmm, I thought there's some kind of conglomeration of symbols that does that
06:12:01 <Gurkenglas> Something with join or lift or * or sth
06:12:25 <DannyFritz> RegEchse: ooooh, (Integral a, Integral b) is what I wasn't getting. I didn't think of specifying the poly form twice because they can be different.
06:12:37 <RegEchse> DannyFritz: but in ghci at least i've got no difference in  answer :: Int  and  answer :: Integer
06:12:50 <RegEchse> (*timing difference)
06:12:50 <k00mi> Gurkenglas: the Applicative instance for ((->) a) can be used for that
06:13:09 <ij> lambdabot do djinn & pl?
06:13:14 <ij> can*
06:13:16 <ClaudiusMaximus> :t (&&&) `asAppliedTo` id
06:13:18 <lambdabot> (a -> a) -> (a -> c') -> a -> (a, c')
06:13:35 <ClaudiusMaximus> :t (&&&) `asAppliedTo` (undefined :: a ->b)
06:13:36 <lambdabot> (a -> b) -> (a -> c') -> a -> (b, c')
06:13:47 <DannyFritz> oh ,i see a typecast fromIntegral too
06:13:55 <k00mi> :t \f g h x -> h <$> g <*> f $ x
06:13:56 <lambdabot> (s -> a) -> (s -> a1) -> (a1 -> a -> b) -> s -> b
06:14:07 <RegEchse> DannyFritz: yes, because <= can't compare different Integrals
06:14:20 <DannyFritz> fromIntegral seems to be much slower to me
06:14:23 <k00mi> :t liftA2 `asAppliedTo` (+)
06:14:24 <lambdabot> (Applicative f, Num c) => (c -> c -> c) -> f c -> f c -> f c
06:14:45 <k00mi> hrm
06:15:10 <k00mi> Gurkenglas: it's liftA2 but the combining function comes first
06:16:20 <exio4> @pl \x y f -> fun f x y
06:16:21 <lambdabot> flip . flip fun
06:16:51 <Gurkenglas> kthx
06:23:18 <Gurkenglas> > sum . filter (liftA2 (||) ((==0) . (flip mod 5)) ((==0) . (flip mod 3))) $ [1..1000]
06:23:20 <lambdabot>  234168
06:23:46 <Gurkenglas> Either that line was wrong or project euler lists the wrong answer to its first problem.
06:24:38 <Gurkenglas> Oh. _Below_ 1000. Nvm.
06:26:13 <mr-> > sum [x | x <- [1..1000], x `mod` 5 == 0 || x `mod` 3 == 0]
06:26:15 <lambdabot>  234168
06:27:06 <Ferdirand> but you used variables ! it's spooky !
06:28:41 <mr-> > sum $ do {x <- [1..1000]; guard (x `mod` 5 == 0 || x `mod` 3 == 0); return x} -- Variable? What's that?
06:28:43 <lambdabot>  234168
06:30:03 * hackagebot yesod-auth-oauth2 0.0.9 - Library to authenticate with OAuth 2.0 for Yesod web applications.  http://hackage.haskell.org/package/yesod-auth-oauth2-0.0.9 (PatrickBrisbin)
06:30:50 <int-e> > sum$filter((>1).gcd 15)[1..999]
06:30:52 <lambdabot>  233168
06:40:03 * hackagebot json-rpc 0.2.0.2 - Fully-featured JSON-RPC 2.0 library  http://hackage.haskell.org/package/json-rpc-0.2.0.2 (XenoGenesis)
06:50:57 <yitz> > sum $ map (ap (*) $ ((-) 1) . (`mod` 2) . (`mod` 15) . (^ 8)) [1..999]
06:50:59 <lambdabot>  233168
06:53:12 <quchen> There's also a closed O(1) solution for this.
06:53:39 <yitz> > 233168 -- sure, quchen. like this.
06:53:40 <lambdabot>  233168
06:54:02 <quchen> But that one doesn't scale very well.
06:54:11 <mr-> it does work for all n
06:57:23 <mr-> quchen: what is your solution?
07:00:04 * hackagebot hydrogen-version 1.0.1 - Hydrogen Syntax  http://hackage.haskell.org/package/hydrogen-version-1.0.1 (JulianFleischer)
07:00:06 * hackagebot hydrogen-prelude 0.3.1 - Hydrogen Prelude  http://hackage.haskell.org/package/hydrogen-prelude-0.3.1 (JulianFleischer)
07:01:00 <quchen> mr-: You can calculate the sum of consecutive numbers up to N in a closed form expression ("Euler's formula").
07:01:38 <quchen> You can use that to calculate the sum of multiples of 3 and 5 up to 999. To take into account double-counting, you'll have to subtract the sum of multiples of 15 in the end.
07:02:02 <kwantam> > 1 + ((999^2 + 999) / 2) - 3 * ((333^2 + 333) / 2) - 5 * ((199^2 + 199) / 2)
07:02:03 <mr-> quchen: Oh, you are saying it's 15(n(n+1)/2) - something
07:02:04 <lambdabot>  233168.0
07:02:50 <quchen> mr-: Not really, but maybe in the same spirit. http://lpaste.net/111421
07:02:50 <albeit> Is there a way to import specific functions qualified? Like, "import qualified Map (insert) as (Map.insert)"?
07:03:16 <quchen> albeit: import qualified Data.Map as Map (insert)
07:03:18 <quchen> … I think.
07:03:35 <quchen> Might also be import qualified Data.Map (insert) as Map
07:05:59 <albeit> quchen: was the first one, thanks!
07:07:20 <zmbmartin> I am looking to write a web api in haskell. Can I get some opinions on the options? I have glanced at Yesod, Snap, Scotty, Rest(Silkapp https://github.com/silkapp/rest), and Apiary (https://github.com/philopon/apiary)
07:08:34 <bergmark> levenshtein "rest" "best" = 1
07:09:32 <zmbmartin> bergmark: What do you like about rest?
07:09:42 <bergmark> i like that i'm one of the maintainers :P
07:09:52 <zomg> zmbmartin: Scotty is an alright lightweight approach. If you just want a RESTful API, I think Yesod may be a bit overkill but otherwise it's a very good framework
07:10:05 * hackagebot pit 0.3.0 - Account management tool.  http://hackage.haskell.org/package/pit-0.3.0 (chiro)
07:10:35 <zmbmartin> bergmark: Fair enough
07:10:48 <zmbmartin> zomg: Thanks!
07:10:54 <zomg> I've never used Rest but bergmark usually knows what he's talking about
07:10:55 <zomg> =)
07:10:58 <bergmark> but seriously, it depends... scotty is probably easiest to get started with, but if you want to have a rest api i think it makes sense to use a framework dedicated to that, otherwise you have to reimplement all the rest-y boilerplate
07:11:56 <bergmark> i think the coolest thing about rest is that it generates api clients for you
07:12:26 <zmbmartin> bergmark: OK cool I will check it out today. I am still learning haskell, so are questions for rest best asked in here or somewhere else?
07:12:50 <bergmark> we have a mailing list: https://groups.google.com/a/silk.co/forum/#!forum/code
07:14:03 <zmbmartin> bergmark: Cool thanks!
07:15:38 <zomg> http://www.ehow.com/how_7450803_encrypt-card-information-sql-database.html
07:15:39 <zomg> Oh god.
07:16:25 <danilo2> Hello! Does anybody know how should we use the buildExpressionParser from parsers (Text.Parser.Expression) ? The example in the documentation does not work (http://hackage.haskell.org/package/parsers-0.12.1/docs/Text-Parser-Expression.html) complaining about the amount of arguments
07:21:13 <danilo2> ahh ,there is an error in documentation (http://hackage.haskell.org/package/parsers-0.12.1/docs/Text-Parser-Expression.html) how can I fix it? Have I to write to the maintainer?
07:22:07 <bergmark> danilo2: open an issue on the bug tracker
07:22:17 <danilo2> bergmark: ok
07:23:20 <bergmark> or even better, send a pull request
07:23:23 <bcap> hello! im learning haskell through learnyouahaskell.com and reached the let in / where part. let in looks so much more flexible and I got curious: Do you often see the where clause on day to day production code?
07:24:00 <bcap> to clarify, im coparing the use of "let in" expressions against "where" guards expressions
07:25:55 <quchen> bcap: It's mostly a matter of choice/style. They are not equivalent though. Most importantly, let/in is an expression, but where is not. You can't write "foo = (1 + n where n = 3) / 2" for example.
07:26:17 <meretrix> bcap: I'm not sure what you mean by where guard expressions, but I use where all of the time.  It's nice because it puts the definitions at the end of the function.
07:26:18 <quchen> On the other hand, "foo = (1 + let n = 3 in n) / 2" is legal.
07:27:19 <bcap> I got interested how the where expression has a subset of the let in expression features
07:27:38 <quchen> Neither is a subset of the other.
07:27:39 <bcap> the only reason i see for using the where would be what meretrix just told me now
07:27:41 <exio4> they're "different things" at the language-level
07:28:20 <dfeuer> quchen, I noticed you haven't updated the AMP status report to reflect your recent victory.
07:28:33 <bcap> ok, but in a general rule, could you replace all "wheres" for "let in"s?
07:28:38 <dfeuer> Yes.
07:28:45 <quchen> dfeuer: Haha good catch, will do :-)
07:28:51 <quchen> Got a link to the merge?
07:28:58 <dfeuer> let and where are different ways to accomplish the same thing; in Core, they are all let.
07:29:08 <dfeuer> quchen, I don't know what that means.
07:29:28 <bcap> dfeuer interesting, that was what i was trying to reach with my subset argument
07:29:32 <dfeuer> Oh, some git thing? No, quchen, I haven't learned git yet.
07:29:33 <quchen> dfeuer: The "recent victory" you were talking about was the merge of Applicative=>Monad in HEAD, I assume?
07:29:37 <zmbmartin> bergmark: Sorry if this is a stupid question but how do I build/install the example with wai? I am not sure of the how to use flags.
07:29:40 <dfeuer> quchen, yeah.
07:29:40 <bcap> so its a matter of style, got it
07:30:19 <dfeuer> bcap, yeah, but you might have to twist your code around harshly to switch from one to the other.
07:30:35 <bcap> makes sense
07:30:52 <bcap> its not my purpose to never use where clauses
07:31:00 <bcap> just got interested in the topic
07:31:09 <dfeuer> You may have to introduce a case expression, for instance.
07:31:39 <bcap> thanks for the replies dfeuer quchen  exio4 and meretrix
07:31:59 <bergmark> zmbmartin: cabal install -fsnap
07:32:08 <bcap> dfeuer are case expressions bad somehow?
07:32:25 <zmbmartin> bergmark: Thanks :)
07:32:57 <dfeuer> bcap, it could be rather more to type and read.
07:33:34 <bcap> ok, readability is the issue, makes sense
07:34:05 <dfeuer> Like I said, once Haskell is "desugared" to Core, there is no more where.
07:34:20 <dfeuer> So there basically *can't* be a deep difference.
07:34:23 <dfeuer> It's all surface.
07:37:55 <bcap> dfeuer got it, thanks
07:56:45 <Gurkenglas> :info Expr
07:56:54 <Gurkenglas> @info Expr
07:56:54 <lambdabot> Expr
07:56:56 <Gurkenglas> 
07:57:18 <tjger> can anyone recommend a comprehensive tutorial on (atto)parsec besides the one in rwh?
08:03:10 <tdammers> tjger: do you understand how parser combinators work in general? if so, all you need is the documentation for (atto)parsec
08:04:29 <quchen> Gurkenglas: from the simple-reflect package
08:04:44 <tjger> tdammers: i suppose i dont. :-( can you guess my next question?
08:05:09 * hackagebot unlit 0.2.0.0 - Tool to convert literate code between styles or to code.  http://hackage.haskell.org/package/unlit-0.2.0.0 (pepijnkokke)
08:05:11 * hackagebot hOpenPGP 1.7 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-1.7 (ClintAdams)
08:12:28 <tjger> can anyone point me to a collection of examples on (atto)parsec?
08:22:32 <sivteck> tjger, i just started reading this: http://www.cs.nott.ac.uk/~gmh/monparsing.pdf
08:28:03 <tjger> i can maybe elaborate further on my problem: im trying to parse a file. the file contains a multiline string, separated by newline characters. i want the parser to return the string without \ns. so far i have not been successfull, leading me to conclude that my knowledge of parsers is lacking
08:28:40 <tjger> sivteck: thanks, ill give it a read
08:30:46 <iIl> tjger: how about filter (/= '\n') "foo\nbar\nbaz\n"?
08:31:10 <iIl> or lines <string>
08:31:20 <davidthomas> tjger: Is this one part of a larger parser, or is this the entire task?  If the latter, something like iIl describes could work
08:32:09 <tjger> davidthomas, iIl: part of a larger parser. precisely, i want to parse a FASTA-file as described here: http://rosalind.info/problems/gc/
08:32:10 <DanielDiaz> > (unwords . lines) "a\nword\nper\nline"
08:32:12 <lambdabot>  "a word per line"
08:33:21 <tjger> DanielDiaz: thanks, but i already new that much. how would one implement the same functionality with parsec?
08:33:59 <DanielDiaz> tjger: many $ manyTill anyChar newline
08:34:24 <davidthomas> tjger: Break it down.  You have many lines that contain a pile of "AGCT" followed by a newline
08:34:45 <DanielDiaz> that will give you a "Parser [String]", where each "String" is a line
08:35:12 * hackagebot persistent-zookeeper 0.0.1 - Backend for persistent library using Zookeeper.  http://hackage.haskell.org/package/persistent-zookeeper-0.0.1 (junjihashimoto)
08:35:14 * hackagebot dot2graphml 0.1.0.2 - Converter from GraphViz .dot format to yEd GraphML  http://hackage.haskell.org/package/dot2graphml-0.1.0.2 (IlyaPortnov)
08:35:41 <DanielDiaz> not sure of how that handles the eof, so you might try "many $ manyTill anyChar (newline <|> eof)" too
08:37:06 <DanielDiaz> > :t manyTill
08:37:08 <lambdabot>  <hint>:1:1: parse error on input ‘:’
08:37:37 <DanielDiaz> @type manyTill
08:37:39 <lambdabot> Not in scope: ‘manyTill’
08:39:10 <tjger> DanielDiaz: when i run that with parseOnly it just parses until the first newline
08:39:25 <tjger> DanielDiaz: correction: it returns a list
08:39:46 <ParahSailin> tjger: i have made a lot of fasta parsing stuff
08:40:13 <ParahSailin> do you want one for pipes?
08:40:51 <tjger> ParahSailin: sure. ill have a look at it and maybe it will make me smarter
08:42:06 <DanielDiaz> tjger: try with "many $ manyTill anyChar (void newline <|> eof)", (void comes from Control.Monad)
08:44:06 <ParahSailin> tjger: https://github.com/rcallahan/FastxPipes
08:45:11 <tjger> DanielDiaz: doesnt terminate
08:45:13 * hackagebot persistent-zookeeper 0.0.2 - Backend for persistent library using Zookeeper.  http://hackage.haskell.org/package/persistent-zookeeper-0.0.2 (junjihashimoto)
08:45:15 * hackagebot haar 0.1 - Haar wavelet transforms  http://hackage.haskell.org/package/haar-0.1 (AmyDeBuitleir)
08:45:19 <ParahSailin> its a bit more micro-optimization than the usual monadic parser combinator thing
08:46:23 <tjger> DanielDiaz: correction: doesnt terminate with endOfInput. works with void (im using attoparsec atm)
08:46:40 <tjger> ParahSailin: thanks.
08:46:56 <ParahSailin> i have a bunch more bioinfo stuff that ive neglected to post to github yet
08:47:56 <tjger> is using liftM concat the best way to make the parser return a single string?
08:48:56 <ParahSailin> tjger: you are gonna run into issues with memory and time if you are loading a large genome file that way
08:50:07 <tjger> DanielDiaz: what difference does prepending void make?
08:50:13 <tjger> ParahSailin: please elaborate
08:52:39 <DanielDiaz> tjger:  in attoparsec there is no difference. In parsec, newline :: Parser Char, however eof :: Parser (). In order to make "(<|>) :: Parser a -> Parser a -> Parser a" typecheck, I had to skip the "Char" of "newline" with void.
08:52:55 <ParahSailin> @src concat
08:52:56 <lambdabot> concat = foldr (++) []
08:53:05 <tjger> DanielDiaz: good to know
08:53:29 <tjger> ParahSailin: are you referring to lack of laziness?
08:53:49 <ParahSailin> actually you might be fine
08:53:54 <adas> i tried "cabal install --dry-run ghc-mod". It shows that it will install version "0.3" instead of "5.1". Can someone please explain to me, why this is happenin?
08:53:59 <beckyconning> sorry to ask again but does anyone know how i can get something like timeout (http://hackage.haskell.org/package/base-4.7.0.1/docs/System-Timeout.html#v:timeout) but that always waits for the given duration before calling the bound function with the Maybe (even if its a Just)?
08:54:15 <ParahSailin> @src many
08:54:16 <lambdabot> Source not found. Whoa.
08:54:29 <DanielDiaz> > head $ concat $ repeat [1,2,3]
08:54:31 <lambdabot>  1
08:55:54 <tjger> so does anyone have a more elegant solution than liftM concat?
08:56:18 <adas> anyone?
08:56:57 <shapr> :t liftM concat
08:56:59 <lambdabot> Monad m => m [[a]] -> m [a]
08:58:51 <adas> im using GHC 7.8.3
08:59:10 <adas> and I have persistent-2.0.3 installed
08:59:24 <adas> I tried "jay@hbox:~/persis$ cabal install --dry-run ghc-mod==5.1.0.2
08:59:58 <adas> but i get a warning that some packages might be broken
09:00:25 <adas> oh.. 5.1.0.2 is the latest version of ghc-mod
09:00:35 <bergmark> adas: cabal doesn't break packages by default, you can either reinstall them at the same time or unregister them
09:00:44 <bergmark> or use separate sandboxes
09:01:53 <adas> bergmark: you mean unregister the packages that will be broken if I install ghc-mod=5.1.0.2?
09:02:43 <ParahSailin> tjger: my mistake, i was thinking of concat for bytestring having issues with that
09:06:00 <adas> bergmark: i created a seperate sandbox and tried "cabal install --dry-run persistent persistent-sqlite persistent-template ghc-mod" and it still tries to install "ghc-mod (0.3)"
09:06:45 <adas> "0.3.0" to be exact and in parenthesis it says "latest: 5.1.0.2"
09:08:42 <bergmark> adas: i think sometimes sandboxes reuse packages from the user database, i never install anything outside sandboxes so i don't know the details
09:09:43 <adas> np. ill try to figure it out. Thanks
09:25:16 * hackagebot haeredes 0.4.2 - Confirm delegation of NS and MX records.  http://hackage.haskell.org/package/haeredes-0.4.2 (MichaelOrlitzky)
09:30:22 <johnw> jfischoff: sure, write a backend which doesn't use disk at all?
09:31:08 <jfischoff> johnw: cool so it’s possible?
09:31:27 <johnw> absolutely
09:31:36 <johnw> gitlib is just an interface; what it does behind the scenes can be entirely up to you
09:42:00 <adas> is there a way to serve package documentation locally?
09:42:17 <adas> i downloaded the packages docs
09:43:29 <monochrom> if you have the files locally, you can just use urls of the form file:///home/xxx/.cabal/share/doc/...
09:43:48 <monochrom> if you don't have the files locally, first you have to get the files locally.
09:46:29 <adas> monochrom: but the files are inside a docker container..im trying to read the docs on firefox which is running on the host
09:46:47 <monochrom> then I don't know docker.
09:47:25 <monochrom> I don't use docker, and file:///... has always worked for me, every browser.
09:49:19 <adas> monochrom: thanks..ill try to find a way. there must be a way to expose a container's filesystem running in docker to the host.
09:49:39 <adas> i use docker containers simply because it keeps my GHC installs neat and clean
09:49:55 <johnw> adas: in the Nix project having fully local access is a priority
09:49:58 <johnw> just as another data point
09:50:21 <monochrom> I use simply "./configure --prefix=/usr/local/ghc-7.8.3-the-3rd-instance"
09:51:37 <adas> well.. its not almost the same thing..but it works
09:51:40 <monochrom> unlike some C libraries and compiles, GHC already comes with high compartmentalization
09:51:54 <adas> johnw: meaning?
09:52:14 <johnw> meaning it's another way to install things that keep the installation clean and fully usable in the pattern you're referencing
09:52:15 <adas> you mean having access to the actual host is a must?
09:52:22 <adas> ah okay
09:52:25 <johnw> meaning local access to docs and even hoogle
09:53:19 <usr> hi
09:54:04 <btubbs> hi usr
09:56:43 <usr> how do i learn this language
09:56:45 <usr> btubbs:
09:57:23 <btubbs> usr: i don't know.  reading http://learnyouahaskell.com/ is useful but not sufficient
09:57:25 <btubbs> i would start there
09:57:54 <usr> How did you learn it?
09:58:18 <btubbs> i'm still learning it :)
09:58:23 <usr> ah
09:59:01 <usr> yea that book is too slow
09:59:02 <usr> for m
09:59:03 <usr> me*
09:59:07 <usr> I want something faster
10:00:04 <adas> usr: just read it faster
10:00:11 <cite-reader> There's always the tried-and-true method of saying, "I want to do X, and I want to do it in Haskell" then asking questions every time you get stuck. Presumably after enough iterations, you'll have learned Haskell.
10:00:11 <usr> adas useless
10:00:27 <drdanmaku> usr: what do you mean by "too slow"?
10:00:27 <usr> cite-reader what do i want to do in haskell though
10:00:37 <cite-reader> I can't answer that question for you.
10:00:46 <drdanmaku> usr: if you haven't written any haskell programs i'm not sure you're in a position to call it soo slow
10:00:51 <usr> drdanmaku it uses repetition for learning
10:01:07 <usr> I've learned throughout my life, and I know what the best way to learn for me is
10:01:11 <usr> And it's not through repetition
10:01:23 <adas> usr: i really meant it. quickly get thru lyah. move on the Real world haskell. Haskell wikibook on the internet... in between write haskell code
10:01:25 <drdanmaku> usr: that's a rather ambitious statement
10:01:46 <adas> LYAH has the basics
10:01:56 <usr> Why can't I just jump in Real World Haskell
10:02:20 <simpson> You can. Go for it.
10:02:32 <usr> ok thanks i'll do that
10:05:05 <Candie23>  Here some videos. I hope you like them! http://tinyurl.com/ozfvxy3
10:05:12 <joseph07_> usr: Note that RWH references some deprecated libraries
10:05:19 * hackagebot clientsession 0.9.1 - Securely store session data in a client-side cookie.  http://hackage.haskell.org/package/clientsession-0.9.1 (FelipeLessa)
10:05:24 <usr> ah :/ joseph07_
10:05:41 <usr> even in the newest edition?
10:06:00 <Qfwfq> Yes. http://stackoverflow.com/questions/23727768/which-part-of-real-world-haskell-is-now-obsolete-or-considered-bad-practise
10:06:45 <usr> thanks Qfwfq
10:07:05 <Qfwfq> I don't really know how to answer "How should I learn Haskell?" anymore.
10:07:12 <usr> how did you learn it
10:07:21 <doismellburning> LYAH + RWH?
10:07:28 <usr> lyah is a waste of time
10:07:31 <Qfwfq> LYAH, RWH, reading lots of stuff on GitHub.
10:07:40 <usr> ye i usually just read source code
10:07:42 <usr> to learn languages
10:07:46 <doismellburning> why is LYAH a waste of time?
10:07:48 <usr> but I heard haskell is completely alien
10:07:59 <simpson> usr: Well, do you know anything in the ML family already?
10:08:02 <MagneticDuck> I'm trying to understand Network.Socket, is "sock <- socket AF_UNIX Stream defaultProtocol; bind sock (SockAddrUnix "127.0.0"); (flip hPutStrLn "test") =<< socketToHandle sock WriteMode" valid?
10:08:06 <usr> No i don't simpson
10:08:13 <Qfwfq> Try Hutton's book for enough to start reading code.
10:08:17 <simpson> I wouldn't expect to be able to learn *any* language just by reading code examples in a language. In fact, that sounds very counter-productive.
10:08:27 <MagneticDuck> hPutChar says transport end point is not connected
10:08:51 <usr> simpson that's how I learned most of my languages
10:08:51 <Qfwfq> ..Marlow, making lots of mistakes, a patient compiler..
10:09:00 <pellis> honest question - is there a point to learn Haskell additionally to clojure? if so where could I find Haskell useful where Clojure is not?
10:09:09 <usr> you just memorize enough source code
10:09:12 <usr> till it makes sense
10:09:36 <joseph07_> usr: http://bit.ly/1si6JGD Might be useful for digging into more advanced concepts
10:10:03 <MagneticDuck> any ideas guys?
10:10:57 <usr> thanks joseph07_ bookmarked
10:10:57 * hackagebot unlit 0.2.0.1 - Tool to convert literate code between styles or to code.  http://hackage.haskell.org/package/unlit-0.2.0.1 (pepijnkokke)
10:10:57 <Gurkenglas> usr's question inspires me to ask: Does someone know an introduction to haskell that only gives you the definitions and syntax (and maybe some useful lemmas and theorems) and lets you figure out the rest?
10:10:58 <zmbmartin> bergmark: Do you mind if I ask you some questions here about rest?
10:10:58 <usr> Gurkenglas: that's what i'm looking for
10:10:58 <bennofs> usr: so if you want to read source code,just pick a haskell project and read it?
10:10:58 <usr> bennofs i heard it's alien to anything I know
10:11:02 <usr> so I don't want to learn it wrong
10:11:09 <usr> cause once I learn it wrong I'll never be succesful at the language
10:11:18 <simpson> Oh, if you learn it wrong, just unlearn.
10:11:26 <usr> i can't unlearn
10:11:35 <usr> well it's very difficult
10:11:37 <usr> it takes much longer
10:11:40 <usr> than when I first learned it
10:11:40 <simpson> Oh. Well, learn to unlearn! :3
10:11:45 <iIl> pellis: sure
10:12:04 <usr> lol simpson i know how but I have to use dreaded repetition
10:12:06 <usr> to unlearn
10:12:11 <usr> which is the slowest way to learn
10:12:23 <pellis> iIl: i can also rephrase to avoid flamewar. my question is also - do clojure cover haskell in capabilities or the other way around - or am i doing apples to oranges?
10:12:26 <iIl> usr: what's the fastest way?
10:12:28 <bennofs> usr: you can probably skim the first few chapters of lyah where it talks about all the list functions etc
10:12:44 <usr> bennofs yea was doing that
10:12:50 <simpson> pellis: Apples to oranges, definitely.
10:12:50 <usr> iIl just looking at it
10:12:56 <bennofs> later it doesn't do so much repetion iirc
10:13:08 <usr> ah ok thanks bennofs i'll see
10:13:18 <simpson> usr: Anyway, if you never get your hands dirty, you'll never have the experience of building things.
10:13:26 <bennofs> usr: I also skipped the long list of functions it sometimes has, just looked at them when I needed it later
10:13:29 <usr> yea simpson i'll code right away
10:13:29 <pellis> simpson: i see. i guess i'm not knowledgeable to undestand why it's different fruit then. can you name juse one thing that makes them so different? (ignoring for a moment the JVM etc)
10:13:44 <iIl> type safety
10:13:47 <usr> bennofs cool i'll do that I feel you learn the same way as me
10:14:04 <pellis> iIl: which clojure has since it runs on the JVM? (maybe not default, but still)
10:14:13 <Gurkenglas> usr, if nobody comes up with something better, maybe you can look at the sourcecode of the libraries? They are documented from what little I've seen of it
10:14:21 <bergmark> zmbmartin: sorry, i'm pretty busy at the moment. Need to finish up some stuff before my vacation. But if you send an e-mail to code@silk.co or adam@silk.co i'll try to answer before i leave on wednesday
10:14:30 <Gurkenglas> Doesn't get much closer to "only the definitions and syntax"
10:14:36 <josephle> pellis, perhaps you should state your definition of type-safety so the discussion doesn't go in circles
10:14:59 <simpson> pellis: Clojure is a Lisp. Haskell is a close relative of the ML family.
10:15:25 <pellis> josephle: i'll do better. i'll explain my context. i want to add another language to my toolchain - more in order to excercise my brain rather for it to be useful - BUT - i would really enjoy it if it were really useful.
10:15:32 <zmbmartin> bergmark: No worries, I will hit the mailing list or catch you some other time when you are on. Enjoy your vacation :)
10:15:38 <bergmark> thanks!
10:15:44 <iIl> pellis: in clojure, can you check that your function accepts a string instead of a number at compile time?
10:15:45 <pellis> josephle: so right now, i'm considering Haskell, and Rust. (if you have others - please tell me :)
10:15:54 <Gurkenglas> urs, maybe this? http://www.haskell.org/onlinereport/standard-prelude.html
10:15:55 <pellis> iIl: not at compile time
10:16:00 <Gurkenglas> *usr
10:16:23 <iIl> pellis: right, that's the benefit already.
10:16:24 <pellis> josephle: but since Clojure is functional, and i had a short dive there.. if Haskell is really close to clojure id rather take something that takes me to a different direction
10:16:34 <sivteck> usr, https://github.com/bitemyapp/learnhaskell
10:16:57 <merijn> simpson, pellis: There is no need to define type safety, it has a very narrow and technical meaning. Which is the following, "a language is type-safe IFF given a specific model of operational/denotational semantics, ALL well-typed program will behave according to those semantics"
10:17:19 <pellis> also  - what is the best workload of Haskell? what does it excel in?
10:17:37 <merijn> So to have any meaningful discussions about type-safety, the first step is to define WHICH model you're using
10:17:42 <pellis> my first hunch is to go and try make a web service with it. just because, but maybe that's wrong?
10:18:04 <josephle> merijn, maybe I should ask them to state their theorems for progress and preservation?
10:18:13 <simpson> merijn: I did not do any such thing. In my mind, the differences in execution model between Lisps and MLs are already severe enough.
10:18:47 <bennofs> pellis: web service sounds pretty good. just be sure to pick an easy framework, like scotty (snap and yesod are both quite advanced so maybe not so good if you're just starting out)
10:18:48 <phaazon> hey
10:19:05 <pellis> bennofs: so in real life - this is what you use Haskell for?
10:19:09 <merijn> simpson: oh, I guess I meant josephle and I misread which nick said what :)
10:19:15 <phaazon> bitemyapp: do you know when ghc-mod starts using monad-journal, and why? I’m curious about feedback experience :)
10:19:41 <MagneticDuck> does anybody here understand Network.Socket?
10:20:00 <merijn> pellis: tbh, I wouldn't consider haskell close to clojure in any shape or form :)
10:20:15 <joelteon> keep your friends close and your enemies closer
10:20:16 <merijn> ALthough, admittedly, I've not looked at the typed clojure stuff
10:20:22 <Gurkenglas> @src (==)
10:20:22 <lambdabot> x == y = not (x /= y)
10:20:25 <Gurkenglas> @src (/=)
10:20:26 <lambdabot> x /= y = not (x == y)
10:20:28 <josephle> merijn: I think it was iIl and pellis. I agree with pellis that the JVM guarantees type saftey under a certain model :)
10:20:28 <Gurkenglas> What is this
10:20:47 <merijn> MagneticDuck: Network.Socket is basically a transparent wrapper of C socket functions
10:20:57 <pellis> merijn: i have to confess type theory deters me today. it was more attractive when i was younger. so today a language like Scala that's packed with academics just turns me off.
10:20:59 <cite-reader> Gurkenglas: That's the default implementations. When you create an instance of Eq, you need to override one or both.
10:21:14 <MagneticDuck> merijn: okey
10:21:21 <merijn> pellis: TBH, scala is widely considered ridiculously complicated by most haskellers
10:21:40 <joelteon> s/haskellers/humans/
10:21:56 <josephle> subtyping + higher kinded types == not so fun times
10:22:03 <josephle> and that's just the beginning
10:22:03 <joelteon> Look at the Scala homepage, there's a nice summary of their philosophy.
10:22:13 <merijn> pellis: The only Scala programmers I know are those who started doing haskell after they considered Scala to complex :)
10:22:18 <joelteon> If all of the elements are good things, combined they should be a good thing too.
10:22:46 <fizbin> pellis: If you're collecting examples, my current real-world haskell working use is a bunch of careful graph manipulations (which we have proofs for), and the graph manipulations work out into a tight binary format for a proprietary pattern matching system. I expose this via a web service internally, and developers (and CI build machines) access this web service with a tiny python client.
10:23:41 <josephle> pellis, with respect to your haskell or rust decision, I'd argue that both bring something new to the table
10:23:56 <josephle> when compared to closure
10:24:01 <josephle> *clojure
10:24:33 <iIl> haskell also seems to be more popular in the industry compared to the mentioned languages, if you care about that
10:24:35 <eriksensei> pellis, bennofs: snap is actually pretty simple, and quite easy to get started with: https://gist.github.com/cschneid/a3d9a77a19c55e6684e5
10:26:14 <bennofs> eriksensei: snap is certainly easier than yesod, but still a little bit more complex than scotty. The snaplet infrastructure confused my quite a bit at first, even though I already knew lenses. Maybe it's just because I wanted to know how/why it works instead of just copy-pasting examples :)
10:26:34 <joelteon> except the templating system is whack
10:26:54 <joelteon> You write functions that process DOM trees...or something like that
10:26:58 <iIl> to be fair, happstack is not that difficult either and the book is well-written
10:27:16 <Gurkenglas> Is an axiom that all (==) implementations (for, say, the type T) should follow (in the same way that all implementations of fmap should be homomorphic) that (x :: T) == (y :: T) iff for all f :: Eq a => T -> a, f x == f y?
10:27:25 <athan> joelteon: What system is this?
10:27:33 <joelteon> Whatever snap uses
10:27:37 <bennofs> hesit
10:27:42 <joelteon> I think it's called heist
10:27:44 <athan> oh, huh
10:27:50 <bennofs> that's what i wanted to say
10:27:58 <athan> I'm actually working on a dom combinator library
10:28:15 <eriksensei> bennofs: well, you're free to not use the features you think are too compilcated
10:28:21 <luite> athan: which one, and what style?
10:28:29 <athan> best check it out
10:28:42 <joelteon> if you don't use the features you think are too complicated, you're missing out on a lot
10:28:57 <joelteon> for example, with heist, you're missing out on a minimally functional templating language
10:29:06 <LysergicDreams> I'm trying to get positional arguments working with CmdArgs, but the argPos index required seems random: http://sleepanarchy.com/p/Ay82Ej
10:29:13 <LysergicDreams> I was under the impression they should all be 0.
10:29:15 <athan> luite: Well, i want it to feel like blaze-html, but give the facility to build a dom tree up and select things out of it, like the current stylings of nodes, like jQuery but on the server side, and can understand styles
10:29:17 <mightybyte> bennofs: Snaplets are completely optional.  Snap existed for quite awhile before snaplets were introduced.
10:29:19 <eriksensei> you're missing out on a lot if you choose scotty to keep things simple, too; i thought that was more or less the point of recommending scotty
10:29:23 <athan> later I'll integrate event binding
10:29:44 <joelteon> after using Yesod and snap I definitely prefer yesod
10:29:53 <joelteon> It's very "kitchen sink"
10:30:36 <mightybyte> athan: You can use Heist with blaze-html syntax
10:31:35 <athan> mightybyte: But does it give that functionality? For adding styles to particular nodes, and watching the dom grow as you add more templates?
10:31:46 <akagr> Hi everyone. haskell newbie here... what's the easiest way to see source of functions?
10:31:58 <joelteon> akagr: read the documentation
10:32:05 <Gurkenglas> @src reverse
10:32:05 <lambdabot> reverse = foldl (flip (:)) []
10:32:05 <joelteon> there will be a source link
10:32:16 <joelteon> well, @src works for about 15 functions afaict
10:32:25 <Gurkenglas> Challenge accepted!
10:32:39 <Gurkenglas> Except I don't want to spam the channel.
10:32:40 <mightybyte> athan: It works with a node tree that you can traverse and work with.
10:32:41 <luite> athan: cool. do you think it might be usable on the client too? i'm looking into the various ways to program DOM, there are some react/virtualdom bindings, and low-level ghcjs-dom bindings for GHCJS, but nothing that really combines selectors, event handling and a nice notation yet
10:33:37 <athan> luite: Its going to be a while, but I plan on porting it to purescript :)
10:33:48 <pellis> merijn: i guess where Haskell stands compared to Scala is encouraging
10:34:10 <athan> mightybyte: Hmm okay
10:34:44 <athan> luite: After I get this part done, I'm going to work on a geometry package, to make a wysiwyg and template conversion tool :)
10:34:49 <luite> athan: oh i was more thinking about compiling it directly obviously, with GHCJS, but it would be interesting to find out what changes you need to make it usable on the client
10:35:15 <mightybyte> athan: At it's core, heist is all about DOM manipulation.
10:35:29 <joelteon> its
10:36:14 <athan> luite: The issue with ghcjs is it's massive overhead runtime. It's a few MB if I remember. Its pretty fun :) (that was for you, joelteon >:D)
10:36:42 <joelteon> > fix grammar
10:36:44 <lambdabot>  Not in scope: ‘grammar’
10:36:44 <athan> mightybyte: I'm definitely going to have to check it out then :)
10:36:46 <joelteon> damn
10:37:05 <athan> lol
10:37:07 <joelteon> the "shakespeare" family of languages is pretty great
10:37:26 <joelteon> of course it does heavily use template haskell though
10:37:37 <joelteon> a lot of stuff snap does is in an effort to avoid using template haskell
10:37:46 <joelteon> I'm not totally sure what bothers people so much about TH except maybe compile times?
10:38:04 <Kinnison> I think TH is hard to port to some platforms
10:38:17 <joelteon> well, I dev on OSX and deploy to Linux
10:38:19 <athan> joelteon: errors for me :/
10:38:27 <joelteon> oh, that and cross compiling
10:38:35 <joelteon> okay, yeah, that and debugging generated splices
10:38:40 <joelteon> which doesn't happen all that often
10:38:52 <joelteon> still, I would take it over heist any day of the week
10:39:40 <saml> hey, what is -> mean in   f (a, b -> c) = ..
10:39:48 <saml> can -> be used in pattern?
10:39:48 <ion> ViewPatterns
10:39:50 <luite> athan: it's smaller than that (gzipped/compressed you get ~60kB for hello world currently) and i'm still working on improvements. i don't want to break compatibility though, so progress is a bit slower, modifying libraries like base, containers etc. in the future when a module system like backpack is supported, we can swap out whole implementations (things like Data.Map for example) for more space-conscious versions
10:39:51 <joelteon> that's a view pattern
10:39:53 <saml> thanks
10:40:16 <bitemyapp> phaazon: I really don't know ghc-mod internals that well, you should read the code or ask Kazu.
10:40:18 <joelteon> f (g -> b) = ... is the same as f arg = let b = g arg in ...
10:40:45 <ion> but “b” can also be any pattern.
10:40:52 <phaazon> bitemyapp: I read a few commits, but they’re many :D
10:40:55 <luite> athan: but we're in for the long haul, this is going to take some effort and time (i joined the core libraries committee for it) :)
10:40:55 <joelteon> yeah, but it can in the LHS of a let binding
10:40:57 <phaazon> I tried to talk to Kazy then
10:41:07 <joelteon> so my example is still theoretically sound, boooyah
10:41:08 <ion> joelteon: But the semantics are not the same.
10:41:12 <joelteon> shit
10:41:51 <luite> joelteon: someone is helping port the GHCJS template haskell implementation for cross compilers, which should make it possible to support TH in 7.10 on all cross compilers
10:42:23 <bennofs> luite: so to cross-compile TH code, you need to compile the code to JS and the run it on node?
10:42:51 <athan> luite: Oh no way! That's awesome! I'm gonna have to mess with it a bit :)
10:42:53 <luite> athan: code size does not always equate performance though, the purescript compiler compiled by ghcjs was much bigger, but faster than the experimental purescript-in-purescript compiler
10:43:16 <joelteon> oh yeah, I was trying to figure out how to support TH in cross compiling but I couldn't quite figure it out
10:43:34 <athan> luite: Sorry, I'm watching attack on titan right now xD
10:44:28 <luite> bennofs: yep it takes TH out of the GHC process, but it still requires some target environment to run the code. for JS it's node, usually it'd be some device emulator, a virtual machine or something like wine
10:45:20 <luite> bennofs: the goal is to have the infrastructure merged in 7.10, and have users set up specific implementations as a kind of plugins
10:45:24 <dreams> hi, i'm trying to print a list. main = print [1..10], it works in ghci but does not with ghc. How do you print a list with ghc?
10:45:58 <mightybyte> joelteon: Quasiquoted TH DSLs are significantly less flexible because they're not very composable.
10:46:13 <dreams> eh nevermind.
10:46:15 <cwraith> dreams: that should work with GHC.  Care to lpaste your compile error?  (It would get a warning with GHC, but it should work)
10:46:47 <luite> mightybyte: less composable than heist templates?
10:47:04 <mightybyte> luite: Less composable than Haskell.
10:48:18 <mightybyte> I'm not really talking about template languages, but more general TH.
10:48:36 <joelteon> right
10:48:53 <luite> mightybyte: sure, but you have heist since you don't always need the full flexibility of haskell (and perhaps sometimes for when you need templates to be changeable at runtime), so you trade off flexibility for a cleaner or easier to reason about language/notation.
10:49:27 <dreams> How would you add seq to (x+1) in http://lpaste.net/111424
10:49:27 <mightybyte> That trade is more related to compile times and working with non-haskell people.
10:51:55 <mightybyte> But yes, that's definitely the trade implicit in using a template language.
10:52:08 <luite> mightybyte: would you prefer blaze (or similar) over heist if you didn't have to work with non-haskell people for a project?
10:52:34 <adas> ive installed hoogle and i have package documentation installed in the sandbox.. but when i run the server, im not able to view the documentation. Could someone pelase point me in the right direciton?
10:52:47 <mightybyte> Me personally, no.  I like having my templates not be compiled.
10:53:50 <mightybyte> But if you valued the flexibility/composability/abstraction factor more, then yes, I think blaze (or similar) would be the right choice.
10:54:24 <supki> dreams: addList (x : xs) = let y = x + 1 in y `seq` y : addList xs
10:54:48 <glguy> dreams: http://lpaste.net/111424
10:54:50 <mightybyte> If you needed introspection on the DOMs, then blaze + xmlhtml might be the right choice.
10:55:30 <luite> mightybyte: i'm a bit behind on the developments, but what are compiled heist templates exactly?
10:55:50 <adas> anyone?
10:56:16 <mightybyte> luite: A way to move the bulk of DOM traversal/processing to application load time instead of doing it all every time the template is rendered.
10:56:41 <mightybyte> It's related to the HoleyMonoid idea that chrisdone mentioned the other day.
10:56:42 <monochrom> interesting, it turns out that : has higher precedence than seq already, so, y `seq` y : xxx does not need parentheses :)
10:56:53 <dreams> supki, glguy thanks.
10:57:53 <dfeuer> quchen, monochrom, I do think that y `seq` y should trip a compiler warning (when actually parsed so).
10:58:04 <mightybyte> luite: It basically transforms a DOM tree into a concatenative series of chunks of static and dynamic bytes.
10:58:17 <dfeuer> Er ... I did not mean to say quchen.
10:58:29 <monochrom> heh
10:59:33 <luite> mightybyte: ah thanks. i kind of thought that's what always happened to the templates when being loaded. are there limitations compared to the old approach?
10:59:41 <mightybyte> Yes
11:00:03 <shachaf> Sounds like a lint warning. No particular reasont to put it in the compiler unless you have a general mechanism for putting lint warnings in the compiler.
11:00:07 <mightybyte> The old approach did a whole DOM traversal every time the template was rendered.
11:00:33 <mightybyte> There are all kinds of complex things you can do in that world that you can't do with the concatenative/monoidal approach.
11:01:03 <dfeuer> @tell Cale I'd love to hear what you think about my idea for "unlikely context" warnings: https://ghc.haskell.org/trac/ghc/ticket/9624
11:01:03 <lambdabot> Consider it noted.
11:01:05 <mightybyte> But in practice you typically don't need that power very often.
11:01:39 <edlinde> is there a haskell project that rivals say the Map-Reduce framework?
11:01:59 <edlinde> like using Haskell to work on bigdata
11:02:09 <mightybyte> edlinde: Hadron.  https://github.com/soostone/hadron
11:02:34 <Cale> dfeuer: I'd imagine it'll be a lot of work once you start adding those to get reasonably good coverage, but it's a good idea in general.
11:02:49 <Cale> Show (a -> b) isn't *totally* out of the question.
11:02:53 <mightybyte> edlinde: There's a presentation about it here:  http://vimeo.com/90189610
11:02:56 <edlinde> mightybyte: yeah but this is just some interface written on top of Hadoop
11:03:26 <Cale> The main problem with Show (a -> b) is that sometimes you can do better than just giving the instance with  show _ = "<function>"  or something.
11:03:41 <mightybyte> edlinde: Oh, you're wanting something in pure haskell?
11:03:45 <edlinde> so it won’t optimize a series of map-reduce calls if there is a simple way around it
11:03:48 <Cale> But the others listed there are pretty likely to be out of the question.
11:03:48 <edlinde> yes
11:04:02 <mightybyte> edlinde: Ahh.  In that case, I don't know.
11:04:08 <edlinde> okie
11:04:24 <edlinde> coz I did see Parallel Haskell.. but wondering if it can scale well or not
11:04:36 <edlinde> are there any guys in this channel who work with Parallel Haskell?
11:04:37 <mightybyte> edlinde: Well, that's where hadoop comes in...
11:04:59 <dfeuer> Cale, I was just hoping for the top ten or something. I understand what you mean about Show (a->b). But now that I think about it, I don't really want warnings, do I? I really want modified error messages recognizing unlikely contexts.
11:05:03 <edlinde> yeah but Hadoop falls short in some cases… esp when you have iterative algorithms
11:05:13 <Cale> dfeuer: Right
11:05:20 <edlinde> you loose out a lot in those map-reduce rounds
11:05:22 <Cale> dfeuer: Or even custom messages of some sort
11:05:24 * hackagebot esqueleto 2.0.2 - Type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-2.0.2 (FelipeLessa)
11:05:31 <Cale> dfeuer: You could have a pragma for it
11:05:39 <luite> mightybyte: do you know a specific (relatively practical) example that's harder to do now? i've been experimenting with some client-side templating stuff at ICFP, using rules pragmas or TH (for blaze and quasiquoted style notations respecively) to fuse as much as possible into prerendered chunks, so it'd be useful to have a few good examples of more difficult use cases for this
11:06:05 <dfeuer> So if there's no instance for Show (a->b), it will say that you probably didn't mean to show a function, rather than complaining about the missing instance or whatever.
11:06:18 <Cale> dfeuer: That whenever a type error occurs because of a missing instance of a certain shape, add this string to the error message.
11:06:20 <mightybyte> luite: Hmmm, not off the top of my head.
11:06:37 <dfeuer> Yes, Cale. I will modify the feature request.
11:06:50 <mightybyte> I can't think of anything I've encountered in our development that couldn't be done in compiled heist.
11:07:07 <mightybyte> luite: Oh, actually, yes.
11:07:13 <mightybyte> Heist's bind tag
11:08:44 <mightybyte> luite: I could not implement bind and apply as compiled splices because they rely on the recursive nature of splices.
11:09:04 <mightybyte> Node -> [Node]
11:09:38 <kgadek> hi. I can't thing of how to do write a function `foo :: a -> String` that would return `show x` if `Show a` and would return "" otherwise. I suppose GADTs are the answer, just can't get it right
11:11:01 <monochrom> no, it cannot be written.
11:13:12 <kgadek> monochrom: that's a pitty… I suppose the reason is the lack of "instance Hask a => Foo a" right?
11:13:36 <monochrom> I do not what what is Hask and what is Foo.
11:13:53 <kgadek> Hask would be the type of all types
11:13:58 <kgadek> Foo would be e.g. my class
11:15:05 <dfeuer> Cale, I looked over my feature request ticket and ... it's already the way I mean it. Heh.
11:15:22 <k00mi> kgadek: the reason is parametricity, that is, there is no way to know what concrete type a is instantiated to
11:16:11 <k00mi> and then do different things based on what that a is
11:16:18 <mauke> @free id :: a -> a
11:16:18 <lambdabot> f . id = id . f
11:18:17 <jle`> i wonder if id . f = f is a free theorem
11:18:26 <kgadek> k00mi, monochrom: I believe it would be possible to infer that statically anyway. Because finally there are concrete monotypes and thus exploiting OverlappingInstances or sth would enable the use of `foo = const ""` in general case and `foo = show` when argument can be showed
11:18:38 <kgadek> not certain that it can be done in haskell though
11:19:31 <k00mi> uhh
11:19:41 <k00mi> whatever you're trying to do, that is not the solution
11:21:11 <monochrom> OverlappingInstance is unlikely to help. (I understand why it looks likely on the surface.)
11:21:13 <kgadek> k00mi: I'm writing a little logger. Would love to write `somefun x y z = calling "somefun" $ do …` so that it would log the result if result is in Show, and not log anything otherwise
11:22:01 <kgadek> I could make another function like "calling" and "callingFunctionThatHasShowableResult" but that's an ugly API to use
11:22:08 <lpaste> mhd pasted “ Non-exhaustive patterns in function” at http://lpaste.net/111426
11:22:53 <glguy> mhd: (head:tail) isn't going to match an empty list
11:23:14 <monochrom> is mhd here?
11:23:18 <mhd> why the code snippet  http://lpaste.net/111426 in comments generates this error message: "Non-exhaustive patterns in function myLength" but IMHO his full analogue (without case) works and doesn't generate this error?
11:23:35 <kgadek> yay for #haskell, answered the question before it was asked :D
11:23:49 <k00mi> kgadek: why not put a Show constraint on calling?
11:24:00 <monochrom> myLength [] is undefined.
11:24:12 <glguy> mhd:  and the pattern in your commented out code:  [a]
11:24:16 <glguy> only matches a singleton list
11:24:34 <kgadek> k00mi: because that would constrain the logger to functions with showable results. I don't want that
11:25:17 <monochrom> my meta-comment is I don't understand why, given the blessing of pattern-matching, you try so hard to hide it away and go back to the broken model of predicates and selectors. read my http://www.vex.net/~trebla/haskell/crossroad.xhtml
11:25:25 * hackagebot conduit-extra 1.1.4 - Batteries included conduit: adapters for common libraries.  http://hackage.haskell.org/package/conduit-extra-1.1.4 (MichaelSnoyman)
11:25:45 <glguy> mhd: (myTail [a]) will always return [], I think you are misunderstanding what the square brackets mean (whether or not this is a good way to write the function)
11:26:05 <adas> is there something similar to "hoogle data <package-name>"?
11:26:26 <kgadek> adas: hoogle data +package-name
11:26:27 <k00mi> kgadek: but you can't log anything that isn't Show anyway
11:26:50 <kgadek> k00mi: exactly. that's why I want to remember "" :)
11:27:01 <kgadek> (or Nothing, whatever is more convenient)
11:27:33 <albeit> Is it possible for a Chan to overlow? As in, write too much without reading fast enough, so some items get "magically" deleted unknowingly to make room?
11:27:52 <monochrom> it is possible with finite memory. that's the only cap.
11:28:16 <mauke> I doubt it would just drop items
11:28:23 <albeit> Okay
11:28:29 <monochrom> oh, when overflow, it simple OOMs.
11:28:37 <mauke> it's more likely to kill your whole process
11:28:54 <monochrom> well, OOM is a case of dropping everything, so I guess we all agree :)
11:29:10 <monochrom> all items get magically deleted :)
11:29:18 <mauke> let the bodies hit the floor
11:29:54 <albeit> Hmm is it possible for Unix domain socket to overflow?
11:30:39 <mauke> define "overflow"
11:30:40 <monochrom> I think no. I think the kernel blocks the writer.
11:31:24 <monochrom> but yeah I'm making presumptions about what "overflow" stands for.
11:32:16 <lpaste> Hinidu pasted “countSort” at http://lpaste.net/111427
11:32:20 <albeit> Overflow as in not enough space so it just removes some elements to make space
11:32:28 <albeit> (Or bytes)
11:32:54 <adas> is there a way to create hoogle database while installing a package? that way i can combine the default.hoo with a "<package>.hoo" and serve it locally?
11:33:20 <lpaste> Hinidu revised “countSort”: “No title” at http://lpaste.net/111427
11:46:54 <adas> does the "--haddock-hoogle" option do what I think it does?
11:47:22 <adas> is there a small library I can install to test with? a library with less dependencies
11:53:10 <bennofs> adas: try acme-year
11:55:43 <adas> bennofs: too late. already started with persistent and hoogle : ). about to finish
11:56:59 <solarus> adas: I don't know how --haddock-hoogle works but I guess the --enable-documentation flag is also relevant in this case
11:58:25 <hACKER> wassup my niggas
11:58:52 --- mode: ChanServ set +o mauke
11:59:39 <woffs_> Hi. I try to "cabal install amqp", and it fails while compiling tls-1.2.3. I have tls-1.2.9 already installed. Why does it try to compile tls-1.2.3?
12:00:16 <bergmark> woffs_: try adding --constraint="tls==1.2.9" and see what it complains about
12:00:47 <stolaruk> try praying to the gods of cabal
12:00:54 <woffs_> bergmark: socks-0.5.4 (reinstall) changes: cereal-0.3.5.2 -> 0.4.0.1
12:00:57 <woffs_> I see
12:01:09 <hACKER> stfu fag
12:01:14 --- mode: ChanServ set +o monochrom
12:01:26 --- mode: mauke set +b *!*@204.77.41.208
12:01:26 <woffs_> complex hidden dependency wirrwarr
12:01:41 <woffs_> thanks bergmark !
12:02:07 --- mode: monochrom set -o monochrom
12:02:51 <Hodapp> Hell hath no fury like a troll ignored.
12:02:57 <monochrom> you can always use "cabal install --dry-run amqp" to preview
12:03:01 <adas> solarus: surprisingly --haddock-hoogle had no effect..
12:03:19 <adas> i was expected to get a few hoo files
12:03:27 <adas> searched the sandbox .. none to be found
12:03:49 <adas> *expecting
12:04:24 <adas> so sad, serving package documentation could be this complicated
12:05:22 --- mode: mauke set -o mauke
12:08:15 <gdoteof> my application has a notion of 'sessions' and each session has an associated MVar () that acts as a locking mechanism on teh session
12:08:48 <gdoteof> when new session are created, i *was* modifying an IORef (Map String (Mvar ())) by adding a new MVar to it mapped to the session
12:09:07 <adas> anyone know what the "--haddock-hoogle" option does?
12:09:17 <gdoteof> i was runnign into a race condition on the modification of the "LockMap"
12:09:49 <ocharles> Is it possible to use storable vectors of storable vectors?
12:09:57 <gdoteof> instead I am using a a TVar (Map String (MVar ()))
12:10:13 <gdoteof> which is fine, except I am not sure where to create the new MVar
12:10:28 * hackagebot haskintex 0.5.0.1 - Haskell Evaluation inside of LaTeX code.  http://hackage.haskell.org/package/haskintex-0.5.0.1 (DanielDiaz)
12:10:34 <ocharles> I have an algorithm that takes a vector of vertices, an maps that into a vector of the vertex, its two connected triangle vertices, and all other vertices in the polygon
12:10:49 <ocharles> works fine for Data.Vector, but I'm wondering if I'd get a speed up with storable or unboxed vectors
12:11:23 <gdoteof> i want to do something like :::      atomically $ do; newLock <- newEmptyMVar; addLock locks newLock;
12:11:35 <gdoteof> but I can't do IO inside the STM monad
12:12:01 <gdoteof> and I am scared the create the MVar outside of the atomically in case it retries or something and I get multiple versions of the lock
12:13:33 <joelteon> uhh, if STM operations are retried the old operations are thrown away
12:14:43 <ocharles> Hmm, if I have a vector containing a vector, then maybe I'm meant to be using repa...
12:14:52 <mauke> gdoteof: that doesn't make sense to me
12:14:58 <gdoteof> mauke: which part?
12:15:09 <c_wraith> ocharles: or just one vector with custom indexing?
12:15:22 <mauke> gdoteof: print "hello"; while (foo()) { ... }  # what if it repeats and I get multiple hellos?
12:15:25 <gdoteof> joelteon: i know that.. but i don't know how to put the *creation of the MVar* inside the STM transaction
12:15:35 <ocharles> c_wraith: not sure what you mean
12:15:35 <stolaruk> Indeed you can't do IO inside STM, so you'll need to find a way to segment the two
12:15:38 <mauke> gdoteof: answer: if its outside the loop, it won't be repeated
12:16:10 <gdoteof> mauke: well that's fair
12:16:16 <stolaruk> Why would you want to create an MVar inside STM, why not use a TMVayp
12:16:21 <stolaruk> TMVar
12:16:29 <joelteon> yeah I'm curious why you would not be using TMVar
12:16:31 <c_wraith> ocharles: if you have a vector containing a bunch of (the same size) vectors, you can just use one vector and index into it with functions like those in Ix
12:16:44 <adas> perhaps ill get it working tomorrow. goodnight
12:16:44 <gdoteof> maybe (probably) this is wrong
12:16:45 <ocharles> Ah, I don't
12:16:54 <ocharles> or at least, I don't think I do...
12:17:00 <c_wraith> ocharles: well, if they're not the same size, you can't use Repa either
12:17:02 <gdoteof> but I have a TMVar (Map String (MVar ()))
12:17:09 <ocharles> Actually, now that I think about it, I'm not sure I need a vector of vectors
12:17:14 <ocharles> because all I ever do is take the first element :)
12:17:16 <joelteon> gdoteof: what are you trying to do?
12:17:19 <ocharles> (that satisfies a predicate)
12:17:20 <monochrom> gdoteof: it seems to me you only need to wrap atomically around addLock.
12:17:26 <c_wraith> ocharles: oh, that's a nice optimization. :)
12:17:49 <mauke> hmm :: IO (IO a -> STM a)
12:18:01 <monochrom> in fact, it seems to me that addLock should do its own atomically so the user doesn't care.
12:18:21 <mauke> (no, that doesn't work)
12:19:24 <monochrom> it also seems to me that the collection of locks is simply TVar (Map String (MVar ())). what extra things does TMVar buy you?
12:19:25 <gdoteof> joelteon: generally, i have N "sessions" talking to an external source
12:19:50 <gdoteof> but multiple "identical" sessions (meaning, they are talking to the same source) on different threads
12:20:03 <gdoteof> so i need to lock per source
12:20:12 <gdoteof> and also update the list of locks as new sources come in
12:21:07 <gdoteof> monochrom: tbh i don't know.  as might be apparent, i am flailing a bit trying to stop this deadlock
12:22:03 <MagneticDuck> http://ix.io/ere <- why no work :(
12:22:18 <MagneticDuck> I understand it's not reallly a haskell problem, but you guys are nice right?
12:22:31 <MagneticDuck> (code is haskell)
12:22:45 <dreams> Am I using seq wrong here? Its not running in constant space http://lpaste.net/111432
12:23:10 <mauke> dreams: x `seq` x is the same as x
12:23:20 <mauke> it means "evaluate x when you evaluate x"
12:23:21 <MagneticDuck> ..as lpaste helpfully suggests
12:23:23 <bennofs> dreams: x `seq` ... means: evaluate x before evaluating ....
12:23:35 <mauke> not necessarily before
12:23:36 <bennofs> dreams: it basically creates an "evaluation dependency"
12:23:48 <pavonia> MagneticDuck: What's the problem?
12:23:54 <MagneticDuck> well, it fails! :0
12:23:55 <bennofs> dreams: the evaluation of x already depends on x though, so x `seq` x is just x
12:23:57 <MagneticDuck> let me get the error
12:24:09 <MagneticDuck> "sendTo: invalid argument (Invalid argument)"
12:24:12 <dreams> but x will be evaluated strictly no?
12:24:28 <bennofs> dreams: what you probably want to say: evaluate x before evaluating length x xs
12:24:32 <monochrom> deadlocks are far more likely caused by mistakes when using MVar's than by using TVar
12:24:35 <mauke> dreams: what?
12:24:36 <dreams> bennofs: yes.
12:24:42 <bennofs> dreams: for that, you need to write x `seq` length x xs
12:25:05 <monochrom> in fact TMVar has the same high likelihood as MVar because they have the same bloody semantics.
12:25:05 <MagneticDuck> pavonia: any idea :<
12:25:19 <bennofs> dreams: the `seq` there creates a dependency: the evaluation of length x xs now depends on x, so x has to be evaluated first
12:25:33 <mauke> monochrom: I thought TMVar didn't guarantee queueing behavior
12:25:59 <dreams> bennofs: let me try.
12:27:03 <monochrom> the conclusion is that time spent on modifying your atomically's is wasted. you're better off looking at how you use your MVar's.
12:27:07 <pavonia> MagneticDuck: No, sorry
12:27:21 <dreams> bennofs: ah I see. a bit tricky.
12:40:36 <fryguybob> gdoteof: Perhaps you already solved your problem, but there shouldn't be a problem with: do v <- newEmptyMVar ; atomically $ addLock locks v
12:44:15 <stefan_1__> I got a newbie question, trying to understand functors and stuff... Would you say that functors are a way of encapsulating data in some kind of behavior?
12:45:10 <merijn> stefan_1__: Short answer: no
12:45:11 <ocharles> stefan_1__: that feels like a reasonable first approximation to understanding them
12:45:18 <mauke> stefan_1__: maybe
12:45:28 <merijn> Whoo, helpful :)
12:45:52 <stefan_1__> hmm
12:46:26 <monochrom> Functor exposes so little, you may be right to say, simply "encapsulate".
12:46:35 <merijn> stefan_1__: Over time I find that the most helpful and true thing about functors is just "types whose argument type can be changed using a function"
12:46:58 <merijn> stefan_1__: The most helpful thing is really it's type signature plus the two simple laws it provides
12:47:07 <stefan_1__> right
12:47:12 <merijn> (Although that's easy to say in hindsight...)
12:47:13 <mauke> start with simple functors, like containers
12:47:14 <stefan_1__> i need to memorize those laws
12:47:18 <mauke> then forget about containers
12:47:26 <monochrom> yes, by and far, "a -> b -> F a -> F b" tells you everything you need to know
12:47:35 <stefan_1__> would you say that Maybe is a container?
12:47:41 <mauke> yes
12:47:47 <mauke> it's a list with at most 1 elements
12:49:08 <stefan_1__> thanks for the help, I'm a little more confused now :D
12:49:11 <coppro> iwn 55
12:49:15 <mauke> you're welcome
12:49:16 <stolaruk> Of course, you can put a list in a Maybe
12:49:20 <stefan_1__> are there any exercises or something like that for practicing functors?
12:49:34 <merijn> stefan_1__: I think Typeclassopedia has exercises
12:49:49 <stolaruk> just practice your heavy liftin
12:49:56 <merijn> stefan_1__: Also, just duplicate prelude data types and try to implement functor instances by hand
12:50:06 <mauke> define your own Functor class and instances for Maybe, Identity, [] and ((->) e)
12:50:14 <mauke> and IO
12:50:44 <merijn> "class MyFunctor f where myFmap :: (a -> b) -> f a -> f b"
12:50:51 <stefan_1__> I have done those by following the functor chapter in learn you a haskell
12:50:58 <stefan_1__> i understand how they work
12:51:03 <stefan_1__> (i think)
12:51:06 <mauke> good. you're an expert now
12:51:07 <merijn> stefan_1__: Typeclassopedia contains more complex examples
12:51:34 <merijn> stefan_1__: Try implementing functor for this: "data RoseTree a = Leaf a | Branch [RoseTree a]"
12:52:03 <Qfwfq> I wonder if a singleton-related compile error has ever been successfully deciphered.
12:52:04 <stefan_1__> I will get on it right away
12:57:18 <monochrom> stefan_1__: I wonder if you're measuring your understanding by the popular but misguided measure of "what happens if I express it in the words outside the niche of Haskell programming and/or category theory"
12:57:57 <stefan_1__> I hope not
12:58:00 <stefan_1__> what words would those be?
12:58:07 <monochrom> for example you think you understand FIFO data structures by saying that they corresponds to people lining up at bus stops.
12:58:51 <mauke> pfft, not in germany!
12:58:58 <monochrom> unfortunately this measure cannot possibly work for functors because outside Haskell and category theory, no one uses functors, so no one describes them. unlike queues.
12:58:59 <mauke> it's some kind of unordered heap
12:59:18 <kev1210> Hey guys this is my first time here. Just wanted to say hello!
12:59:47 <stefan_1__> well, I haven't read much about category theory, but when I think of Maybe for example, I simply think "A Maybe a is either Nothing or Just a"
13:00:03 <stefan_1__> I don't try to think of it in imperative programming terms or anything like that
13:00:09 <mauke> kev1210: hi
13:00:43 <mauke> data I am = I am
13:03:26 <stefan_1__> merijn: here's my functor instance of RoseTree http://lpaste.net/111439
13:03:32 <stolaruk> kev1210: hi
13:03:41 <stefan_1__> wait
13:04:17 <stefan_1__> fixed it: http://lpaste.net/111440
13:06:51 <Mokosha> can anyone tell me why my hackage documentation is not building? http://hackage.haskell.org/package/netwire-input
13:07:52 <monochrom> looks correct, stefan_1__.  (P.S. did you know that the "Edit" button allows destructive updates? :) )
13:08:16 <stefan_1__> good to know, thanks for having a look
13:08:37 <Hijiri> hackage haddock generation is turned off/broken I think
13:09:33 <Hijiri> you can manually upload docs but I don't remember how
13:09:33 <Mokosha> for how long? I uploaded that package back in august
13:10:01 <Hijiri> I don't know, they're remodeling hackage or something
13:10:09 <merijn> stefan_1__: See also http://www.haskell.org/haskellwiki/Typeclassopedia for more exercises
13:10:33 <merijn> Hijiri, Mokosha: http://fuuzetsu.co.uk/blog/posts/2014-01-06-Fix-your-Hackage-documentation.html
13:10:44 <Hijiri> thanks
13:10:54 <stefan_1__> merijn, cheers
13:19:14 <Fuuzetsu> Hijiri: Mokosha: https://gist.github.com/Fuuzetsu/8276421
13:20:39 <Mokosha> thanks, everyone
13:21:21 <joshkirklin> A quick question: why can I do "return $ if True then 1 else 0" but not "return if True then 1 else 0"? Why is the ($) required?
13:22:16 <Thooms> for return is a function
13:22:19 <mauke> that's a good question and I have no idea
13:22:29 <mauke> f do ... is also not allowed
13:22:50 <benzrf> joshkirklin: just a stupid parsing and precedence issue!
13:22:56 <Thooms> return if .. would be parsed as return (if) True
13:23:06 <benzrf> joshkirklin: most non-application syntactic forms seem to require that
13:23:09 <benzrf> i.e. lambdas, ifs, do-notation
13:23:11 <benzrf> i think lets.
13:23:18 <mauke> Thooms: no, it wouldn't
13:23:19 <benzrf> > pure let x = 3 in x
13:23:21 <lambdabot>  <hint>:1:6: parse error on input ‘let’
13:23:24 <benzrf> yep
13:23:24 <simpson> joshkirklin: For (historical?) reasons, Haskell doesn't recognize if-exprs or do-exprs or case-exprs with the right precedence.
13:23:24 <Fuuzetsu> Thooms: why would it, if_then_else_ is special
13:23:29 <mauke> Thooms: 'if' is not a valid identifier
13:23:30 <benzrf> > pure (let x = 3 in x)
13:23:31 <lambdabot>  No instance for (GHC.Show.Show (f0 a0))
13:23:32 <lambdabot>    arising from a use of ‘M451966733825276945418037.show_M4519667338252769454...
13:23:32 <lambdabot>  The type variables ‘f0’, ‘a0’ are ambiguous
13:23:32 <lambdabot>  Note: there are several potential instances:
13:23:32 <lambdabot>    instance [safe] GHC.Show.Show a =>
13:23:40 <Thooms> that's what I meant
13:23:58 <Thooms> the absence of ($) lead to a parse error
13:24:07 <mauke> yes, for no good reason
13:24:17 <benzrf> that's just
13:24:22 <HeladoDeBrownie> Maybe they intentionally did that, ostensibly for readability?
13:24:23 <benzrf> that's just what the syntax is ;-;
13:24:42 <HeladoDeBrownie> Alternatively it might have made some syntax production simpler
13:24:43 <mauke> they allowed f x { y = 42 }
13:24:46 <benzrf> you cannot directly apply a prefix function to any syntactic form other than a literal or another application
13:25:18 <simpson> It's almost certainly to ease parsing.
13:25:22 <HeladoDeBrownie> benzrf, where does (grouping) fit into that?
13:25:35 <joshkirklin> are there any plans to eliminate the need in ghc?
13:25:38 <hexagoxel> "f if a then b else g if c then d else e" would be ambiguous
13:26:05 <benzrf> HeladoDeBrownie: by 'directly apply' i mean without any groupin
13:26:33 <hexagoxel> dunno if that explains why just-one-parameter cases are problematic..
13:27:04 <mauke> hexagoxel: why ambiguous?
13:27:15 <albeit> Is it wrong to hook up an io-stream to a non-streaming (datagram) socket?
13:27:31 <hexagoxel> f (if a then b else g) (if c then d else e)
13:27:37 <hexagoxel> f (if a then b else g (if c then d else e))
13:27:52 <mauke> hexagoxel: then 'if a then b else c d' would also be ambiguous
13:28:32 <HeladoDeBrownie> It could use the longest rule like lambdas use
13:28:46 <HeladoDeBrownie> +match
13:28:49 <joshkirklin> is the problem that certain keywords aren't defined as right associative or left associative?
13:28:54 <joshkirklin> or am I wrong in stating that
13:29:18 <HeladoDeBrownie> That statement doesn't make sense to me in context
13:29:35 <HeladoDeBrownie> Right- and left-associativity is about parsing infix function application
13:30:26 <trap_exit> so I'm redoing my haskell setup
13:30:34 <joshkirklin> I know that, but it seems like a similar concept could apply here
13:30:40 <HeladoDeBrownie> Explain.
13:30:41 <trap_exit> what do I use besides haskell-mode ?
13:30:43 <Fuuzetsu> nix
13:30:44 <Fuuzetsu> ;^)
13:30:45 <trap_exit> do I also use ghc-mod + scion ?
13:30:52 <joshkirklin> it's not quite right associative etc
13:31:20 <joshkirklin> but rather some rule to eliminate the ambiguity above noted by hexagonel
13:31:27 <joelteon> no you use nix + nixpkgs
13:31:31 <benzrf> scion
13:31:45 <joshkirklin> just spouting ideas though
13:31:47 <Fuuzetsu> I only use haskell-mode
13:32:03 <Fuuzetsu> not much at that, highlighting and that's about it
13:32:06 <Fuuzetsu> oh and module import/sort
13:32:11 <HeladoDeBrownie> Sure, we even have something like that with lambdas, as I suggested: Lambdas go as far to the right as possible. You could also parse only as much as necessary but then in practice you'd be throwing in parens everywhere
13:32:56 <albeit> If I have a socket receiving datagrams, how can I parse the datagram as it is received? I don't want to receive the full datagram into a ByteString, and then parse it.
13:33:20 <HeladoDeBrownie> More parens, anyway; there are already places you might want to use a lambda where you'd need parens, e.g., f (\x -> x) y
13:33:25 <simpson> albeit: Mu; your kernel *already* received the full datagram, unless you've got jumbo datagrams.
13:33:36 <simpson> albeit: So just receive the entire thing and then put it into your parser.
13:34:36 <albeit> simpson: Oh! Okay. So when I read it into a Bytestring then pass that to a parser, its not doing a "double-pass" on the data?
13:34:53 <simpson> albeit: Pretty much.
13:35:56 <albeit> simpson: Thanks! But what do you mean by pretty much... are there some catches?
13:38:40 <Normangorman> i'm struggling with a tricky question in a haskell textbook - i'm wondering if anyone can give any insight: A function "fix" is defined as fix f = f (fix f)
13:38:46 <Normangorman> what is the type signature of "fix"?
13:39:03 <vanila> Normangorman, to start with assume fix :: a, and f :: b
13:39:08 <Thooms> (a -> a) -> a, no ?
13:39:14 <yesthisisuser> is there no Prelude function f a b = if a then Just b else Nothing?
13:39:50 <vanila> Normangorman, now inspecting the term we have  (fix f)  in there so  a must be a function type say, fix :: b -> y, f :: b
13:40:28 <vanila> Normangorman, but we also have f (fix x) so f must be a function type too:  b = y -> c, so   fix :: (y -> c) -> y, f :: y -> c
13:40:58 <Normangorman> ok
13:41:05 <vanila> Normangorman, to finish you also need to take into account that fix f :: y  has the same type as   f (fix f) :: c  so y=c and  fix :: (c -> c) -> c
13:43:20 <Normangorman> thanks! is yesthisisuser right in thinking that "fix" is essentially just a substitute for an "if p then c else a" clause?
13:43:41 <Qfwfq> ...
13:43:55 <glguy> Normangorman: That question was unrelated to yours
13:44:12 <yesthisisuser> yes it was.. sorry.. hehe
13:44:25 <glguy> No, that function doesn't exist in the Prelude
13:45:13 <yesthisisuser> is there a neat way of writing that? without an if then statement, that is
13:46:14 <josephle> ...pattern match on a?
13:46:56 <hexagoxel> yesthisisuser: guard a >> Just b (not that short, either..)
13:47:05 <simpson> albeit: I mean that you can't be sure that you're getting a zero-copy experience. But that's fine.
13:47:20 <solidus-river> whats an example of a Real number that is not Rational?
13:47:32 <sinelaw> does anyone have a reference for subtyping + HM?
13:47:54 <shiona> solidus-river: pi?
13:48:00 <benmachine> > toRational pi
13:48:01 <lambdabot>  884279719003555 % 281474976710656
13:48:11 <glguy> yesthisisuser: If your goal is to write something clever instead of the straightforward "if then else" you can use MonadComprehensions,   (\a b -> [ b | a ]) :: Bool -> a -> Maybe a
13:48:26 <hexagoxel> yesthisisuser: or "guard a $> b"
13:48:30 <shiona> of course there is no such thing as irrational number on computers
13:48:42 <shiona> since that would take infinite memory
13:48:51 <benmachine> shiona: that's untrue
13:48:55 <solidus-river> pi seems rational
13:49:05 <solidus-river> isn't it by definition a ratio?
13:49:06 <yesthisisuser> i wonder if there is even such a thing as irrational numbers outside of computers
13:49:08 <albeit> simpson: As in that's up to the underlying kernel, and theres nothing I can do about it?
13:49:09 <glguy> hexagoxel: Do you mean     b <$ guard a ?
13:49:15 <glguy> or is there a $> hiding out somewhere
13:49:19 <Cale> solidus-river: hm?
13:49:25 <benmachine> yesthisisuser: the diagonal of a unit square
13:49:26 <Qfwfq> It's in Control.Applicative I think?
13:49:28 <benmachine> is not rational length
13:49:34 <shiona> benmachine: how so
13:49:44 <Cale> yesthisisuser: outside of computers?
13:50:05 <Cale> People are saying so many confusing things that I don't know where to begin!
13:50:06 <Cale> :)
13:50:06 <Qfwfq> I guess not.
13:50:18 <hexagoxel> glguy: Data.Functor
13:50:28 <benmachine> shiona: cut a square from one corner to the opposite corner, then the length of the diagonal is not equal to any particular ratio of integers you care to name
13:50:32 <Cale> solidus-river: pi is not expressible as a ratio of two integers
13:50:39 <yesthisisuser> i was just being constructivist
13:50:43 <glguy> hexagoxel: Ah, thanks
13:50:46 <benmachine> assuming the side of the square is (say) 1
13:51:00 <yesthisisuser> irrational numbers are controversial
13:51:04 <Cale> yesthisisuser: How so?
13:51:04 <benmachine> http://hackage.haskell.org/package/cyclotomic here are some irrational numbers in computer science
13:51:21 <Cale> Even in constructive logics, you can define the reals and show that there are irrational numbers.
13:51:40 <shiona> benmachine: I'm not saying sqrt(2) isn't irrational. I'm saying sqrt(2) cannot be saved to infinite precision on a computer
13:51:46 <simpson> albeit: As in, Haskell doesn't say much about when stuff is copied.
13:51:55 <benmachine> shiona: sure it can, it's all a question of representation
13:51:56 <Cale> shiona: That really depends on your choice of representation!
13:52:19 <josephle> yesthisisuser: http://en.wikipedia.org/wiki/Construction_of_the_real_numbers
13:52:36 <Cale> shiona: There are certainly ways of representing numbers which will allow you to exactly represent numbers like sqrt(2) and pi
13:52:37 <yesthisisuser> Cale: I have been watching some of the video series on http://www.youtube.com/user/nwildberger
13:52:48 <benmachine> as a simple example, you can represent numbers of the form a + b sqrt 2 for rational a and b, just by remembering what a and b are
13:52:48 <sinelaw> shiona, "square root of two", there, I saved it.
13:52:51 <benmachine> just pairs of rationals
13:53:03 <benmachine> then you can add and multiply them
13:53:06 <josephle> Dedekind cuts are a constructive representation of reals...
13:53:07 <vanila> and a + pi b + pi^2 c + ... ?
13:53:07 <benmachine> in the usual way
13:53:08 <Cale> yesthisisuser: I'd take everything he says with a pinch of salt. He frequently overstates things.
13:53:16 <sinelaw> shiona, to be precise you mean that using base-N notation there is no way to save them on a computer.
13:53:33 <Cale> yesthisisuser: and often seems unaware of the work that's already been done with respect to constructive reasoning
13:53:44 <shiona> sinelaw: where N is a rational, yes
13:53:52 <benmachine> sinelaw: even that seems possibly untrue
13:54:01 <Cale> Or, if he is aware, he doesn't let on, in order to be able to more forcefully state his opinion about how everything is terrible
13:54:06 <benmachine> it is possible to write a function nthDigitOfPi :: Integer -> Integer
13:54:30 <yesthisisuser> I am not really qualified to say.. I find his approach helpful sometimes
13:54:32 <sinelaw> benmachine, that yes, but not to save the actual digits
13:54:45 <sinelaw> which doesn't mean much, because who needs that
13:54:46 <benmachine> sinelaw: what's the difference? I can retrieve whatever digit I want whenever I want
13:54:51 <sinelaw> benmachine, exactly.
13:55:08 <benmachine> which is exactly what I would be able to do if I actually had them stored somewhere
13:55:11 <benmachine> on my infinite tape
13:55:25 <josephle> on the other hand, since equality of real numbers is undecidable, I'm not sure why you'd want them on a computer :P
13:55:36 * hackagebot hOpenPGP 1.8 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-1.8 (ClintAdams)
13:55:53 <Cale> yesthisisuser: It's a bit annoying, because a lot of the time I'd mostly agree with him, except that the way that he argues for some of his opinions is easy to pick apart.
13:56:14 <benmachine> josephle: equality of general computable reals is undecidable, but equality of say, cyclotomic numbers is decidable
13:56:44 <Cale> josephle: Well, even on things like floating point numbers, equality is a very questionable operation
13:57:01 <vanila> nwildberger is completely insane
13:57:06 <Cale> It's almost always a mistake to be comparing floating point numbers for equality.
13:57:15 <josephle> Cale: when it comes to floating point, even addition is suspect
13:57:18 <yesthisisuser> vanila: how so?
13:57:21 <vanila> he used to be a good mathematician but now he learned that buy saying false yet exciting/striking things you get a lot more page views
13:57:30 <brisbin> is there a standard library function to do this? https://github.com/thoughtbot/carnival/blob/master/Helper/Auth.hs#L20-29
13:57:42 <josephle> Floating point with addition is not even a monoid :/
13:57:48 <trap_exit> of course pi is rational
13:57:59 <Cale> trap_exit: Kappa
13:57:59 <trap_exit> rational numbers are numbers that can be expressed as num / denom
13:58:07 <trap_exit> pi = circumference / diamater = rational
13:58:11 <Cale> trap_exit: lol
13:58:14 <trap_exit> Cale: ?
13:58:24 <joseph07> trap_exit: alternatively, pi / 1
13:58:24 <trap_exit> what does Kappa mean ?
13:58:26 <Cale> trap_exit: If that were the case, all numbers would be rational
13:58:44 <josephle> the rationals are numbers that can be expressed by two integers...
13:59:00 <stolaruk> In Japanese culture, kappa are mythical creatures that do vile things
13:59:03 <vanila> I have talked to him privately about it and he just ignores any mathematical arguments that he doesnt want to hear. it's disappointing because his earlier work is actually good
13:59:09 <Cale> trap_exit: Oh, "Kappa" referred to a particular facial expression which is available on twitch.tv's chat :)
13:59:32 <Cale> http://img2.wikia.nocookie.net/__cb20131126013116/adventuretimewithfinnandjake/images/8/81/Kappa.png
13:59:36 <mauke> :t \ma -> maybe ma return
13:59:38 <lambdabot> Monad m => m a -> Maybe a -> m a
13:59:50 <trap_exit> installing ghc-mod
13:59:55 <trap_exit> this better be worth it in emacs
14:00:19 <trap_exit> I've always admired how erlang guys can just 'jack-in' to a live running erlang node
14:00:20 <mauke> :t \ma mmb -> mmb >>= maybe ma return
14:00:21 <trap_exit> and start doing work
14:00:21 <lambdabot> Monad m => m b -> m (Maybe b) -> m b
14:01:33 <homesitter> hi folks
14:01:56 <trap_exit> how's home sitting
14:02:04 <trap_exit> hmm, someone should create an uber for home sitting
14:02:08 <Fuuzetsu> I restrained myself from asking if it's a profession
14:02:14 <homesitter> :)
14:03:30 <benzrf> trap_exit: but
14:03:33 <benzrf> haskell is relatively stateless
14:03:42 <benzrf> there's not quite the same notion of a live haskell node
14:03:50 <benzrf> welllll ok maybe not, i dunno
14:04:01 <benzrf> but it certainly doesn't have a mutable global environment the way erlang does
14:04:08 <benzrf> i can't imagine how you could jack in in a meaningful way
14:04:44 <Fuuzetsu> Running programs are not relatively stateless
14:05:10 <benzrf> true....
14:05:20 <benzrf> but i mean,
14:05:34 <homesitter> a function can receive the current state and return a new state
14:05:35 <benzrf> it's all relatively confined to the stack. sort of. fuck i dunno how to phrase it
14:05:36 <trap_exit> benzrf: dude
14:05:50 <trap_exit> benzrf: I'm sure there's some monad which expresses 'jack-in' of a live interpreter while code is running
14:05:51 <Fuuzetsu> I know what you're trying to say but it's wrong
14:05:53 <homesitter> if you want a state machine
14:05:56 <trap_exit> we just haven't figured out how to write >>= yet
14:05:59 <benzrf> Fuuzetsu: explain :|
14:06:01 <Haskellfant> is there a one liner to generate [(1,1),…(1,n),…,(n,n)]
14:06:20 <benzrf> Haskellfant: replicateM 2 [1..n]
14:06:22 <Fuuzetsu> Haskellfant: list comprehension
14:06:35 <benzrf> Haskellfant: liftA2 (,) [1..n] [1..n]
14:06:41 <Haskellfant> thx :)
14:06:55 <benzrf> > replicateM 2 [1..4]
14:06:57 <lambdabot>  [[1,1],[1,2],[1,3],[1,4],[2,1],[2,2],[2,3],[2,4],[3,1],[3,2],[3,3],[3,4],[4,...
14:07:01 <benzrf> wait crap
14:07:02 <sm> jack-in to a running web app would be great
14:07:03 <benzrf> that's list
14:07:04 <benzrf> der
14:07:12 <benzrf> yeah you need the liftA2 (,0
14:07:43 <sm> I assume that'd mean, to start with, a ghci-like REPL
14:08:02 <benzrf> yeah, but what would the environment be that'd be different from starting it from scratch
14:08:42 <monochrom> a system that lets you hot-swap code must disable all inlining.
14:08:45 <sm> app-specific I guess. For a yesod app, your app context. Most likely you'd be in the request monad
14:08:56 <monochrom> it also has to much weaken its static types
14:10:30 <hexagoxel> join (liftA2 (,)) [1..n] -- this probably has worse memory consumption due to sharing..
14:11:56 <monochrom> in some sense, it also has to be imperative by nature.
14:14:40 <xeno> I'm there now...
14:14:44 <xeno> opps
14:14:53 <xeno> a little scrolling issue
14:15:03 <monochrom> congrats for reaching there, whatever there is. :)
14:15:05 <joseph07> monochrom: What if you hot-swapped at the function-level, and enforced equivalent types? You still wouldn't be able to inline, and you would break referential transparency, but what would be the result?
14:15:24 <xeno> anyway, I'm using conduit, and it seems that the current version doesn't export runResourceT - how do I get around that?
14:16:02 <monochrom> the result would be f 0 + f 0 = 2 + 3
14:16:04 <sm> xeno: separate package, isn't it ? resourcet
14:16:17 <Cale> xeno: import Control.Monad.Trans.Resource ?
14:16:30 <Cale> xeno: It still appears to be there
14:16:43 <monochrom> this is one example why the system becomes imperative
14:17:01 <Fuuzetsu> resourcet package
14:17:17 <Fuuzetsu> http://hackage.haskell.org/package/resourcet-1.1.2.3/docs/Control-Monad-Trans-Resource.html
14:17:56 <joseph07> monochrom: I'm not sure I'd call that imperative, more like stateful. Your program would suddenly depend on a big map of function names to functions, and those functions are mutable
14:18:03 <t-l-o> I have a strange problem with a function that decodes a Json-String with Data.Aeson: If I have a main-function within the same file and call this function, the decoding (of a fixed test-string) works. Now if I export the function as a module and import it in another file, the decoding does not work (I just get "Nothing"). Any hints why the exact same code can behave differently if I use "import"?
14:18:53 <monochrom> a C program that does not perform I/O, but merely performs the stateful, mutable "c = c + 1", is already called imperative.
14:19:06 <Fuuzetsu> t-l-o: that sounds fishy, maybe it's a TH problem you're hitting
14:19:21 <Fuuzetsu> or maybe you have orphans or something
14:19:38 <joseph07> monochrom: well if you say so. I guess the long and short of is that hot-swapping in Haskell is a wacky notion
14:19:54 <benmachine> hot-swapping is clearly an effect, that needs to be sequenced with other effects
14:20:04 <benmachine> but we can do that
14:20:04 <t-l-o> Fuuzetsu: TH?
14:20:09 <benmachine> just throw IO in all the things
14:20:14 <monochrom> I look at semantics, not syntax. if your description of semantics is "stateful, mutable", then it's imperative.
14:20:16 <Fuuzetsu> TemplateHaskell; anyway, you should post your code somewhere people can see
14:20:30 <monochrom> I can agree that Erlang has functional syntax, for example.
14:20:50 <t-l-o> Fuuzetsu: OK, will do that
14:21:48 <monochrom> but I am inclined to say that Erlang is imperative semantics wrapped in functional syntax.
14:27:37 <monochrom> semantics affects code optimizations. code optimizations affect performance. performance affects your coding style for real jobs. a seemingly theoretic change in semantics has huge change in your practical programming style.
14:28:33 <monochrom> if Haskell had hot-swapping of definitions, then you would not, in #haskell, encourage beginners to write like "filter (< 3) . map sin"
14:29:22 <monochrom> here is why. because of the prospects of hot-swapping, the compiler is too afraid to inline filter or map or sin, or God forbids, fuse anything.
14:29:24 <codehero> i have a word search puzzle. what would be the easiest way to solve it with haskell, without using the wordsearchsolver puzzle?
14:29:28 <benmachine> I think that erlang encourages a greater use of functional style code than the average
14:29:53 <monochrom> therefore, things like "filter (< 3) . map sin" are going to be dog slow.
14:29:58 <benmachine> erlang encourages limiting mutability, although clearly it still has mutability
14:30:38 <monochrom> you would be, instead, encourage beginners to write a custom recursion, because that's the only thing guaranteed to perform fast.
14:30:40 <benmachine> monochrom: however I would still use filter and map like that if there weren't any fusion
14:30:44 <simpson> If only somebody had invented JITs.
14:30:49 <benmachine> indeed I do, when there isn't
14:31:19 <monochrom> yes, I'm using a small example. a larger example will have a much amplified impact on performance.
14:31:21 <simpson> (Also, can I swap "hot-swapping" for "typeclasses" or "arrows"?)
14:31:36 <monochrom> anyway, you would end up writing imperatively.
14:31:43 <benmachine> monochrom: I basically think you're overstating the importance of performance
14:31:44 <t-l-o> Fuuzetsu: strange, after some minor cleanup (nicer names, etc.) it works. Need to have a closer look at these "minor" changes... :) Thanks anyway!
14:31:55 <albeit> I'm sending datagram packets with sendTo, but some of them seem to not be sent unless I add a "threadDelay (1)" after sending each message. Any idea why?
14:32:02 <benmachine> monochrom: although I'd agree that writing high-performing code in an idiomatic style is definitely something that you can't really get outside Haskell
14:32:17 <benmachine> well, a Haskell-idiomatic style, anyways :P
14:33:12 <levi> I know elm supports hot-swapping of definitions in running programs.  See Evan's StrangeLoop presentation that was posted yesterday (I think) for a demo.
14:35:33 <monochrom> benmachine, I don't overstate the importance of performance. some other people do. I am however stating, but not overstating, their greater influence on the rest of us, because they are louder.
14:36:35 <benmachine> monochrom: I guess I just don't bump into those people
14:38:08 <monochrom> I bumped into a few in this channel. and you only need a few, strongly convicted and outspoken, to change everything that shapes the rest of us.
14:39:25 <monochrom> for example, why does bytestring and even Data.List contain so many RULES pragmas, and so much work into heroically working out the right equations to put inside those RULES pragmas?
14:39:40 <monochrom> answer: because Don Stewart et al. walked among us.
14:40:39 * hackagebot hOpenPGP 1.9 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-1.9 (ClintAdams)
14:45:47 <xeno> next question... where is "Application" located?
14:46:33 <sm> grep -r Application .
14:48:25 <Fuuzetsu> hm I thought it was in http-conduit but apparently not
14:48:27 <iIl> monochrom: would it be better without rules?
14:49:30 <sm> oh I take it back, some libs define that (wai..) http://hayoo.fh-wedel.de/?query=Application
14:49:45 <Fuuzetsu> type Application = Request -> IO Response is maybe what you're looking ofr
14:49:59 <Fuuzetsu> as seen on http://www.yesodweb.com/blog/2012/01/conduits-buffering
14:50:10 <sm> xeno: hayoo is great for finding which package things are in, I recommend a browser shortcut
14:50:31 <Fuuzetsu> hm, I liked the old hayoo look better
14:50:36 <Fuuzetsu> so much wasted space now
14:50:38 <monochrom> better for what, iIl?
14:51:10 <iIl> monochrom: better for whatever compared to the current state of things
14:51:38 <monochrom> you would get slower code. is that better?
14:51:41 <xeno> found it btw, it's in network-conduit
14:51:59 <monochrom> unless you also have in mind a replacement for rules, but I cannot know that.
14:52:34 <xeno> opps, it wasn't
14:52:53 <iIl> monochrom: No, of course.  I thought you were arguing against rules.  It seems I misunderstood.
14:53:13 <Fuuzetsu> xeno: I think I used that type in the past, let me see if it's in my code somewhere
14:53:47 <Fuuzetsu> bathroute-server/src/Bathroute/Communication.hs:132:client ∷ Server → Application (ResourceT IO)
14:53:49 <Fuuzetsu> haha, I knew it
14:54:02 <Cale> xeno: Are you using Yesod?
14:54:06 <xeno> no
14:54:13 <Cale> xeno: What library then?
14:54:24 <xeno> I'm just following the book 'Beginning Haskell' and doing a ton of examples and exercises
14:54:28 <xeno> right now, just conduit
14:54:40 <xeno> or, well, not only that...
14:55:02 <Cale> I'm pretty sure that conduit doesn't define Application
14:55:20 <Fuuzetsu> xeno: here are the imports from that module http://lpaste.net/111448 , it must be in there
14:55:28 <Fuuzetsu> Cale: I think the network one does
14:55:31 <Fuuzetsu> perhaps an older version
14:55:48 <Fuuzetsu> oh network-conduit got deprecated, interesting
14:56:14 <Fuuzetsu> anyway, http://hackage.haskell.org/package/network-conduit-1.0.4/docs/Data-Conduit-Network.html#t:Application
14:56:25 <Cale> ah, you're right, the old version does
14:56:33 <Cale> yeah
14:56:56 <Fuuzetsu> http://hackage.haskell.org/package/conduit-extra-1.1.3.4/docs/Data-Conduit-Network.html#t:AppData is the new guy
14:56:57 <xeno> the book got multiple problems like that... things have changed...
14:57:07 <Fuuzetsu> you can just define ‘type Application m = AppData m -> m ()’ yourself
14:57:41 <Fuuzetsu> …or you could if AppData type didn't change
14:57:52 * Fuuzetsu wishes luck and scurries off before confusing things further
14:58:01 <Thule> Hi guys. I am writing an assignment where I need to show the equational reasoning behind two examples. It can be found here: http://lpaste.net/111449. There are some things I am unsure about. For a statement like (something1) && (something2) what is evaluated first? something1 or something2? If I have (1+1) <= (2+2), which is evaluated first? (1+1)
14:58:01 <Thule>  or (2+2)?
14:58:33 <Fuuzetsu> Thule: order of the operations is not guaranteed
14:58:55 <josephle> Fuuzetsu: I'm pretty sure it's deterministic for (&&) and (||) for the sole purpose of short-circuiting
14:59:02 <monochrom> it is fair to want to know evaluation order. but this is independent to equational reasoning.
14:59:03 <Cale> If you look at equations for (&&) though, you can work out the order in the case of lazy evaluation
14:59:21 <Cale> But yes, this is mostly independent of equational reasoning
14:59:39 <Cale> I say mostly, because treatment of _|_ can sort of detect it
14:59:42 <yukko> hi #haskell - I'm making a little wrapper library around some linux system calls, but when I call the exit system call via GHCI, it just hangs instead of exiting
15:00:04 <Cale> But even with treating _|_'s properly, there are many evaluation orders that will work
15:00:11 <Thule> so does it take the left side or the right side of && first?
15:00:19 <Cale> @src (&&)
15:00:19 <lambdabot> True  && x = x
15:00:19 <lambdabot> False && _ = False
15:00:21 <yukko> (it works when I call it from the main function of a normal program though)
15:00:26 <Cale> It matches on the first argument
15:00:35 <yukko> is it supposed to work like that
15:00:37 <Cale> So _|_ && x = _|_
15:00:41 * hackagebot haskell-neo4j-client 0.2.0.1 - A Haskell neo4j client  http://hackage.haskell.org/package/haskell-neo4j-client-0.2.0.1 (asilvestre)
15:00:53 <Cale> But  False && _|_ = False
15:01:08 <Thule> what is _|_?
15:01:10 <monochrom> yukko: I don't think it's healthy to do that.
15:01:29 <yukko> to call system calls from ghci?
15:01:36 <Cale> Thule: The value which represents nontermination, called "bottom", because it is the least element of the definedness ordering.
15:01:40 <monochrom> to call exit wantonly
15:01:58 <yukko> ah okay
15:02:10 <Thule> ah. So if the left part of && evaluates to false, then obviously there is not need to evaluate the right part
15:02:16 <Cale> right
15:02:36 <yukko> you're probably right, that's just the one I did first since it's the first system call
15:02:37 <Cale> and so even if you put a nonterminating expression there, the evaluation will proceed just fine
15:02:46 <Thule> how about the (1+1) and (2+2) thing. It cannot be determined?
15:02:56 <monochrom> many other system calls should be fair game
15:02:59 <Cale> Probably not.
15:03:22 <Cale> It would depend on the particular implementation of (<=) which one is evaluated first, but it will likely match on both its arguments.
15:04:04 <Cale> So long as you pick an evaluation order that terminates, any such evaluation order will obtain the same result though.
15:04:25 <Cale> So for equational reasoning on totally defined values, it really doesn't matter.
15:04:40 <Thule> okay great. Thanks
15:05:43 <spoyler> go g
15:05:46 <spoyler> go on
15:06:40 <Thule> In my function on pastebin I have 3 guards. Guard 1 and 2 uses y and z, and guard 3 uses z. y is (2+2) and is evaluated in guard 1, whereas z is (1+1) and is evaluated in guard 2.
15:06:40 <Thule> Since y is evaluated in guard 1, is it then reevaluated in guard 2, or does it store the value, so it does not have to evaluate(2+2) again?
15:10:00 <Hijiri> yes
15:10:12 <Hijiri> y points to a + 2 2
15:10:17 <Hijiri> which gets reduced to 4
15:10:25 <Hijiri> and then if you use y again it will still be pointing to that
15:10:42 * hackagebot ply-loader 0.4.1 - PLY file loader.  http://hackage.haskell.org/package/ply-loader-0.4.1 (AnthonyCowley)
15:11:00 <Hijiri> same with z
15:11:14 <Thule> great. thanks :)
15:11:19 <Thule> Just as I thought
15:11:47 <khyperia> Are there any haskell libraries for networking with messages, more specifically things like "command->reply->possible reply to reply", etc.? I'm trying to get a server-client distributed computing thing, 8ish nodes, the messages are both the initial source code and updates to parameters (mostly just updates)
15:12:03 <Rembane> khyperia: Try zeromq
15:12:06 <xeno> Fuuzetsu: network-conduit doesn't use Application anymore, the right type now was HasReadWrite ad => ad -> IO 0, where HasReadWrite is from Data.Streaming.Network
15:12:49 <spoyler> freenode
15:12:55 <spoyler> free node
15:13:00 <xeno> free hat
15:13:12 <spoyler> what is node
15:13:26 <sipa> how is nodde formed?
15:13:30 <joelteon> javascrpt on the server too
15:13:32 <Rembane> Free hat hacker.
15:14:00 <xeno> spoyler: a javascript http server based on callbacks
15:14:24 <spoyler> are you sure
15:14:59 <khyperia> anything higher-level than zeromq4-haskell, Rembane?
15:15:03 <spoyler> fence
15:15:06 <benzrf> zeromq is the shiiit
15:15:16 <zeiris_> khyperia: there's an interesting Erlang clone-in-progress, called cloud haskell or something trendy like that.
15:15:18 <benzrf> khyperia: have you seen pipes?
15:15:24 <benzrf> pipes-concurrency is neat
15:15:25 <khyperia> I have not touched pipes
15:15:27 <zeiris_> Do you need this to be production-grade? :p
15:15:31 <Rembane> khyperia: I have no clue. :)
15:15:33 <benzrf> also, i hooked up zmq to pipes thta one time
15:15:45 <benzrf> khyperia: conduit, then? or have you not touched streaming stuff
15:15:58 <khyperia> I can probably learn easily enough
15:16:09 <khyperia> doesn't have to be production at all, this is just for fun
15:16:11 <benzrf> khyperia: look into pipes, it's neat :-)
15:16:20 <benzrf> and DEFINITELY look into ømq
15:16:42 <spoyler> what is Haskell
15:17:00 <spoyler> why am i here
15:17:07 <spoyler> i don't know
15:17:33 <benzrf> khyperia: basically, ømq gives you 'sockets' that can send and recv, but instead of being plain 1-to-1 streams of bytes, they're something-to-something (based on a few baked-in types) with automatic routing, and you have discrete messages
15:17:45 <sivteck> spoyler, install ghc and ask ghci
15:17:48 <khyperia> ah, cool, okay
15:17:58 <benzrf> so for example if you create a REP socket, recving will block until somebody makes a request, then sending will send back to the last socket to request
15:18:05 <benzrf> so you can just recv, process, send, etc
15:18:12 <benzrf> no need to accept or anything
15:18:20 <spoyler> sivteck OK
15:18:31 <beckyconning> is there a way to start two IOs or threads, wait for both of them to finish, then return the value of one of them (or an operation based on both values)?
15:18:59 <benzrf> khyperia: so a functioning echo server (with appropriate bindings) would look something along the lines of
15:19:15 <Hijiri> beckyconning, you could use two MVars
15:19:18 <benzrf> sock <- bind "tcp://*:9001"
15:19:27 <benzrf> forever $ recv sock >>= send sock
15:19:35 <Hijiri> have the final calculation be based on the contents, and the program will block until they get filled
15:19:38 <khyperia> oh, cool
15:19:48 <benzrf> khyperia: in practice there's a little bit of boilerplate
15:20:03 <beckyconning> Hijiri: could i do that on a separate thread?
15:20:20 <Hijiri> yes, have the separate thread write to the MVar it's assigned to
15:20:30 <benzrf> pipes, meanwhile, is a library that provides a monad transformer that extends your monad with the ability to yield and request values in various schemes
15:20:36 <benzrf> khyperia: so you could write something like
15:20:37 <Hijiri> you set up to MVars, give one to the first thread, and give the other to the second thread
15:20:40 <benzrf> somePipes = do
15:20:43 <benzrf> er
15:20:51 <Hijiri> Then the main thread can try and read each MVar
15:21:06 <Hijiri> and the read operation will block the main thread until that MVar is filled
15:21:09 <benzrf> somePipe = forever $ do val <- await; yield val; yield val;
15:21:22 <benzrf> you can stick that after a producer of values and it'll double each one
15:21:23 <beckyconning> hmm..
15:21:32 <benzrf> you can also use it for request-response, like
15:22:12 <benzrf> well actually you know what ignore that
15:22:16 <benzrf> it's advanced topics, w/e
15:22:30 <benzrf> khyperia: the point is that for some schemes it'd work well with something like ømq
15:22:42 <khyperia> yeah, I'll just go off and try and implement it and come back with questions :)
15:22:53 <khyperia> thanks!
15:22:56 <benzrf> khyperia: besides REP and REQ, ømq has PUSH and PULL for fanning in and out, and PUB and SUB for broadcasting
15:22:59 <benzrf> np
15:24:05 <beckyconning> what i'm looking for / trying to make is essentially a "timeout" that always waits for the timeout to elapse before calling the bound functions. the one in System.Timeout provides the value early if the operation doesn't timeout.
15:26:26 <beckyconning> so i want getChar and threadDelay running asyncronously and then when threadDelay has completed to get Just the value from getChar or Nothing.
15:26:55 <beckyconning> or whateverIOComputation and threadDelay
15:28:16 <Hijiri> You could make two MVars, and prefill one with Nothing, and have the whateverIOComputation replace it with Just result when it finishes
15:28:42 <Hijiri> And then use the other MVar to block the thread until your threadDelay thread puts something to it
15:28:52 <Hijiri> actually you wouldn't need a separate thread
15:28:58 <Cale> beckyconning: Are you just running the thing for effect, or does it have a result that will need to be captured at some later point as well?
15:29:23 <beckyconning> Hijiri: that sounds good i'll definitely try that thanks : )
15:29:30 <Cale> beckyconning: Either you could just use forkIO and threadDelay (in the case that it's not required to get the result), or if it is required, consider using the async library
15:29:31 <Hijiri> threadDelay can go in the main thread
15:29:45 <Hijiri> If he wants to always wait
15:30:07 <beckyconning> the main thread is a guy? : P
15:30:17 <Cale> x <- async (threadDelay t >> action)
15:30:29 <beckyconning> Cale: that looks promising : )
15:30:32 <Cale> and then later you can use  wait x  to get the result
15:30:46 <Cale> which will block if the value hasn't been computed yet
15:31:07 <beckyconning> i'm not used to all this blocking coming from javascript lol : )
15:31:10 <Cale> If you'll never need the result, just replace async with forkIO and don't worry about capturing the result
15:31:19 <beckyconning> Cale: yeah i do need the result
15:31:29 <beckyconning> i'll try that out now thanks! : )
15:31:57 <Cale> http://hackage.haskell.org/package/async-2.0.1.6/docs/Control-Concurrent-Async.html -- there are a lot of fun things here
15:32:24 <Cale> (see also: race, concurrently)
15:34:14 <beckyconning> yeah i just saw concurrently looks promising : )
15:35:11 <Cale> In place of wait, you can also poll, which will examine the status of the Async, giving Nothing if it is still running, or Just (Left e) if it has thrown an exception e, or Just (Right x), if it completed successfully with result x
15:46:33 <jollygood> anyoneusinggladewith gtk2hs? what am I suppose to do in the haskell source after setting some widet's signal handler in glade?
15:46:52 <jollygood> sorry about space malfunction
15:47:24 <dcoutts> jollygood: you don't set signal handlers in glade, you grab names of widgets in the Haskell code, and bind signal handlers there. See the gt2hs glade demos.
15:47:46 <dcoutts> or rather gtkbuilder these days rather than glade format
15:47:54 <dcoutts> but still using the glade application
15:48:08 <jollygood> dcoutts, why can't I set them in glade? I know how to do it manually, but thought this would save me some time
15:48:49 <dcoutts> jollygood: it's not how the Haskell binding works (for various good reasons)
15:49:55 <dcoutts> it makes some sense for C because C has a notion of global vars etc, but in Haskell you want to set a handler within some context/environment, and then it doesn't make sense to just bind it by name in a .glade file because you can't give that context
15:50:44 <dcoutts> jollygood: also, I don't think it saves any time in the end, it's one line either way
15:51:47 <khyperia> benzrf, it looks like zeromq just passes around bytestrings, do I need another library to parse messages out of those? (if I didn't want to just do it myself)
15:51:48 <jollygood> one lineper signal (plus potential additional line per widget). but yeah, not a deal breaker
15:52:04 <dcoutts> but the main reason is that it doesn't really make sense in languages other than C that don't have or don't encourage global vars
15:52:41 <jollygood> but rather than saving lines, it is convenient to see all the signals in the glade and just pick the ones you need
15:53:19 <dcoutts> jollygood: have a look at the gtkbuilder/glade demos. It's actually rather pleasant.
15:53:31 <dcoutts> or threadscope for a "real" example
15:54:12 <benzrf> khyperia: yeah.
15:54:24 <benzrf> khyperia: ømq is a generic language-agnostic library
15:54:32 <benzrf> it's not designed to work with haskell in particular
15:54:38 <khyperia> yeah
15:54:46 <jollygood> as a side note, do you find new way to handle signals with on odd?
15:56:43 <friden_> Is it possible to put a line gotten from hGetLine back into the Handle? I kind of want to do a hLookAhead but with a whole line
15:57:20 <Fuuzetsu> …no
15:57:41 <friden> Fuuzetsu: figured so, anyways, thanks
15:57:46 <arboris> what are good ways emulate ocamls module system in haskell, especially ocamls functors?
15:57:53 <arboris> *to
15:58:08 <joelteon> backpack
15:58:30 <Fuuzetsu> that's on a level up
15:58:51 <Fuuzetsu> maybe a typeclass would work
15:58:51 <arboris> is that implemented yet?
15:59:04 <Fuuzetsu> AFAIK backpack is mostly finished
15:59:11 <arboris> well I don't nescessarily want a literal translation
15:59:28 <glguy> friden_: Some Handles are seekable (hIsSeekable) namely ones backed by files, perhaps you could use: hTell to find the current location, then use hGetLine, and then go back with hSeek
15:59:30 * Fuuzetsu wants Agda modules
15:59:48 <arboris> the problem i want to solve is that an internal library implementation should depend on concrete types supplied by the "application"
16:00:16 <glguy> Just looking at haddocks there is also "hGetPosn/hSetPosn" which I've never had to use but could be relevant
16:00:42 <glguy> (Oh, they just wrap up the hTell/hSeek behavior I described)
16:02:51 <arboris> one thing that could work would be to make the internal representation polymorphic
16:03:00 <arboris> and wrap it in a newtype
16:03:37 <arboris> what makes Agda modules better?
16:06:04 <Fuuzetsu> they can be parametrised and you can open them wherever, name them however, make them wherever, make private modules, rename things they export…
16:06:27 <Fuuzetsu> well, ignore the naming part I suppose
16:07:11 <Welkin> like importing a python module inside a function call?
16:07:38 <Fuuzetsu> except you can't parametrise Python modules and importing it doesn't involve running code inside ;^)
16:08:00 <Fuuzetsu> but in Agda you can do somethng like f x = … where open Foo
16:08:01 <arboris> most of those things can be done with ocaml modules, no?
16:08:20 <Fuuzetsu> arboris: Maybe, I was comparing to Haskell, I have not used OCaml
16:09:11 <Fuuzetsu> what I really want is to be able to define ADTs inside a where…
16:09:21 <arboris> my favorite thing about ocaml modules is that you can use ModuleName.() and names of the module are unqualified in the bracket
16:09:51 <arboris> i am not really used to ocaml either
16:10:03 <Fuuzetsu> that's just like opening a module in Agda
16:10:16 <Fuuzetsu> except not scoped by () but usual scoping rules
16:10:16 <arboris> right, they took that from ML/Ocaml
16:10:21 <Fuuzetsu> perhapss
16:10:38 <arboris> it's sugar for let open ModuleName in
16:10:45 <Blizzy> if someone wanted to go into the Web Development field, would learning Haskell be a good language to learn?
16:10:49 <arboris> they also have e1 with open ModuleName
16:10:57 <arboris> i think anyways
16:11:18 <Fuuzetsu> is there renaming though
16:11:21 <Fuuzetsu> renaming is great
16:11:27 <arboris> sure
16:11:34 <Fuuzetsu> cool
16:11:40 <Fuuzetsu> hope we get such things in Haskell eventually
16:11:59 <Fuuzetsu> or that Agda takes over the world
16:12:11 <arboris> it's tricky because typeclasses are sort of in the way
16:12:29 <Thule> I need to check whether a list contain a number or not. However if I encounter the number then I do not want to check the rest of the list. In normal imperative programming I would just return or break, what is done in Haskell?
16:12:46 <Fuuzetsu> Thule: why not just use ‘elem’?
16:12:52 <Thule> not allowed :)
16:13:07 <Fuuzetsu> just look how it's done then
16:13:09 <Fuuzetsu> @src elem
16:13:09 <lambdabot> elem x = any (== x)
16:13:15 <Fuuzetsu> well, that doesn't help
16:13:18 <Fuuzetsu> @src any
16:13:18 <lambdabot> any p = or . map p
16:13:19 <Iceland_jack> Thule: So you need to write the function yourself (for school?)?
16:13:20 <Fuuzetsu> christ
16:13:36 <Thule> iceland_jack I have written a function. But I want to know how to make it more clever
16:13:45 <Fuuzetsu> Thule: what's your current implementation?
16:14:00 <Thule> I using my own matches function and checks whether the length is 0 or above
16:14:10 <Thule> use*
16:14:15 <Fuuzetsu> if you're using length, you're probably doing it wrong
16:14:18 <Iceland_jack> Thule: Are you familiar with pattern matching
16:14:20 <Fuuzetsu> in most cases
16:14:24 <Thule> Iceland_jack ya
16:14:34 <obb> Prelude> let divisorCount n lastDivisor = if lastDivisor > sqrt n then 0 else if n `mod` lastDivisor == 0 then 2 + divisorCount n (lastDivisor+1) else divisorCount n (lastDivisor+1)
16:14:35 <obb> Prelude> divisorCount 9 1
16:14:35 <obb> <interactive>:153:1:
16:14:35 <obb>     Could not deduce (Integral a10)
16:14:35 <obb>       arising from a use of divisorCount
16:14:36 <obb>     from the context (Num a)
16:14:38 <obb>       bound by the inferred type of it :: Num a => a
16:14:40 <obb>       at <interactive>:153:1-16
16:14:42 <obb>     The type variable a10 is ambiguous
16:14:45 <obb>     Note: there are several potential instances:
16:14:46 <obb>       instance Integral Int -- Defined in GHC.Real
16:14:47 <Fuuzetsu> obb: use a paste site
16:14:48 <obb>       instance Integral Integer -- Defined in GHC.Real
16:14:50 <obb>       instance Integral GHC.Types.Word -- Defined in GHC.Real
16:14:52 <obb>     In the expression: divisorCount 9 1
16:14:54 <Iceland_jack> Thule: Okay, you'll want to get your function on this form:
16:14:54 <Iceland_jack>     blah value []     = ...
16:14:54 <Iceland_jack>     blah value (x:xs) = ...
16:14:54 <Fuuzetsu> jesus christ
16:14:54 <obb>     In an equation for it: it = divisorCount 9 1
16:14:56 <arboris> WTF
16:14:57 <obb>  can someone explain to me why i get this error and what it means please? i don't get it
16:15:02 <beckyconning> if you have an io and want to modify the value thats in it before returning it would there be any advantage in keeping it inside the IO?
16:15:21 <arboris> IRC should really be replaced with something better
16:15:35 <joseph07> Thule: in short we can rely on laziness to avoid scanning the whole list. elem is lazy so 4 `elem` [0..] actually works
16:15:39 <MP2E> why? What would you add to IRC?
16:15:46 * hackagebot gruff 0.3.4 - fractal explorer GUI using the ruff library  http://hackage.haskell.org/package/gruff-0.3.4 (ClaudeHeilandAllen)
16:16:00 <arboris> well for example sensible multiline messages
16:16:01 <Iceland_jack> MP2E: A way of sharing and modifying code without having to rely on external services
16:16:05 <Fuuzetsu> MP2E: fewer netsplits and better handling of multiline
16:16:06 <Thule> Not allowed to do `elem` - I have to implement my own joseph07
16:16:16 <MP2E> great answers haha
16:16:18 <MP2E> :P
16:16:29 <joseph07> Thule: oh for school?
16:16:30 <MP2E> I guess I hadn't thought about that before for whatever reason
16:16:30 <Iceland_jack> Thule: joseph07 was just telling you that you don't need to break explicitly
16:16:34 <Fuuzetsu> obb: your problem is that it doesn't know the type of numbers it's working on
16:16:38 <Thule> iceland_jhack I got it now :)
16:16:39 <Thule> thanks
16:16:40 <int-e> obb: type :t divisorCount, I think you'll see that the first argument has to be both Integral and Floating.
16:16:44 <Thule> Iceland_jack: *
16:17:03 <Fuuzetsu> obb: relevant http://www.haskell.org/haskellwiki/Converting_numbers
16:17:06 <int-e> obb: I wouldn't use sqrt, and your function will fail for squares.
16:17:14 <Iceland_jack> Thule: if you follow the earlier pattern you should be fine, start by considering the empty list:
16:17:14 <Iceland_jack>     foo value [] = ...
16:17:49 <Thule> iceland_jack think I got it :)
16:17:50 <Fuuzetsu> I wonder which school is teaching Haskell, a lot of beginner for-school questions recently
16:18:08 <Iceland_jack> Sorry for putting too fine a point on it
16:18:43 <Thule> It is all good :)  I ended up with this http://lpaste.net/111453. Thanks guyes
16:18:46 <Thule> guys*
16:19:17 <Fuuzetsu> Thule: you could shorten it with (||)
16:19:33 <Iceland_jack> Thule: nice solution
16:19:33 <Fuuzetsu> elem match (x:xs) = match x || elem match xs
16:20:10 <Thule> ahh clever
16:20:12 <joseph07> Thule: nice
16:20:33 <joseph07> You know it's weird how infrequently I write explicitly recursive functions in haskell
16:20:34 <obb> Fuuzetsu would you mind giving an example by changing my line?
16:20:56 <Fuuzetsu> obb: what do you want an example of?
16:21:13 <Thule> joseph07 I am in a beginners course, so I have to do it a lot.. which makes sense :)
16:21:14 <obb> how to convert sqrt to integral(?)
16:21:18 <Fuuzetsu> :t sqrt
16:21:19 <lambdabot> Floating a => a -> a
16:21:29 <Fuuzetsu> :t round . sqrt
16:21:30 <lambdabot> (RealFrac b, Integral c, Floating b) => b -> c
16:22:02 <Fuuzetsu> > round . sqrt $ 16 :: Integer
16:22:04 <lambdabot>  4
16:22:33 <Fuuzetsu> you can't convert to Integral, Integral is not a type
16:23:04 <Iceland_jack> They did say integral in lower case
16:23:18 <Fuuzetsu> I can only make assumptions
16:23:36 <Iceland_jack> Not that I'd have a problem with saying that a function 'Integral n => ... -> n' returns an Integral :)
16:23:38 <Fuuzetsu> :t round . sqrt $ 16
16:23:39 <lambdabot> Integral c => c
16:23:46 <Fuuzetsu> there
16:23:53 <ClaudiusMaximus> @check \x y -> (x > sqrt (fromIntegral y)) == (x * x > y)  -- probably a better way avoiding sqrt
16:23:55 <lambdabot>  <hint>:1:119:
16:23:55 <lambdabot>  parse error (possibly incorrect indentation or mismatched brackets)
16:24:03 <ClaudiusMaximus> @check \x y -> (x > sqrt (fromIntegral y)) == (x * x > y)  {- probably a better way avoiding sqrt -}
16:24:05 <lambdabot>  No instance for (Test.QuickCheck.Arbitrary.Arbitrary a0)
16:24:05 <lambdabot>  arising from a use of ‘Lambdabot.Plugin.Haskell.Check.ShowQ.myquickcheck’ Th...
16:24:08 <Fuuzetsu> Iceland_jack: you should have a problem because then you get people asking how to return Num &c
16:24:19 <ClaudiusMaximus> @check \x y -> (x > sqrt (fromIntegral y)) == (x * x > (y :: Int))  {- probably a better way avoiding sqrt -}
16:24:20 <lambdabot>  No instance for (GHC.Float.Floating GHC.Types.Int)
16:24:21 <lambdabot>  arising from a use of ‘GHC.Float.sqrt’
16:24:32 <ClaudiusMaximus> i give up..
16:24:44 <Fuuzetsu> ClaudiusMaximus: try in /query lambdabot first
16:24:52 <The-God> hehe, sqrt
16:25:55 <Iceland_jack> I wouldn't have a problem with that shorthand either, if people know what they're talking about
16:29:28 <ClaudiusMaximus> @check \x y -> (x >= 0 && y >= 0) ==> (fromIntegral x > (sqrt . fromIntegral) y) == (x * x > (y :: Int))  {- ... -}
16:29:29 <lambdabot>  +++ OK, passed 100 tests.
16:36:52 <dhrosa> does anyone have tips on making Parsec output more useful debug info, like somehow being able to see what combinators it tried?
16:37:29 <dhrosa> I think someone linked me this a while ago here
16:38:06 <khyperia> is there suck thing as an "untilM", as in untilM :: (Monad m) => (a -> Bool) -> (a -> m a) -> a -> m a, or do I have to write it myself?
16:38:26 <khyperia> wow, such a* not suck
16:38:33 <simpson> khyperia: There's Control.Monad.Loops.
16:38:41 <simpson> http://hackage.haskell.org/package/monad-loops-0.3.0.2/docs/Control-Monad-Loops.html
16:38:43 <khyperia> alright, thanks
16:39:54 <monochrom> haha http://hackage.haskell.org/package/liboleg exists
16:39:56 <arboris> dhrosa, you can sort of debug by hand, by intentionally introducing syntax errors after each token
16:40:13 <arboris> then it will tell you what it expected
16:40:32 <arboris> *each->a
16:40:36 <dhrosa> I know what was expected, but the parser is only saying that because that's the last option from a long list of other possible parsers
16:40:51 <dhrosa> like, (choice . map try) long_list_of_parsers
16:40:59 <dhrosa> I want to see how far it got in each parser, or something like that
16:41:17 <dhrosa> I feel like I can do this somehow through the user state type or the underlying monad
16:41:19 <arboris> have you tested the parsers individually?
16:42:18 <arboris> you can also throw in trace, not sure if that would help
16:42:19 <dhrosa> the program can accept arbitrary input, and has to be able to usefully tell the user where they screwed up, so I want to keep track of parsec's state and such
16:42:27 <dhrosa> and print that in a user-friendly way
16:42:46 <monochrom> dhrosa, perhaps you had my http://www.vex.net/~trebla/haskell/parsec-generally.xhtml in mind?
16:43:07 <sm> dhrosa: I probably linked you to my ptrace, which is handy for developing (not for showing to users)
16:43:19 <arboris> dhrosa, you are using <?>?
16:44:18 <dhrosa> arboris: yes, that's not my problem
16:44:38 <dhrosa> arboris: my problem is that Parsec reaches the bottom of a long list of parsers, and complains that you're missing something needed for the final parser
16:45:10 <dhrosa> monochrom: oo, that looks great! I've been trying to figure out how to utilize the underlying monad
16:45:18 <dpn`> i have a typeclasses question... are they an optimisation? Why is Eq :: A -> A -> Bool not enough to know that A belongs to Eq?
16:45:41 <dpn`> sorry why is the existence of a function with the right type signature
16:45:43 <dpn`> *
16:45:47 <arboris> dhrosa, oh I see.
16:45:49 * hackagebot twentefp-eventloop-graphics 0.1.0.2 - An eventloop based graphical IO system. Used as Lab Assignments Environment at Univeriteit Twente  http://hackage.haskell.org/package/twentefp-eventloop-graphics-0.1.0.2 (sebaslafleur)
16:45:51 * hackagebot twentefp-trees 0.1.0.2 - Tree type and show functions for lab assignment of University of Twente. Contains RoseTree and ParseTree  http://hackage.haskell.org/package/twentefp-trees-0.1.0.2 (sebaslafleur)
16:45:52 <dhrosa> dpn`: f a b = True
16:45:53 * hackagebot twentefp-graphs 0.1.0.0 - Lab Assignments Environment at Univeriteit Twente  http://hackage.haskell.org/package/twentefp-graphs-0.1.0.0 (sebaslafleur)
16:45:56 <jollygood> fno way to set the color of the text in widgets in Gtk? I have tried haskell equivalent to this (widgetModifyText entry StateNormal (Color 255 0 0)) and as noted in the thread it did not work because theme is overriding color. http://www.gtkforums.com/viewtopic.php?t=318
16:46:00 <dhrosa> dpn`: that has no Eq => a constraint
16:46:31 <dpn`> dhrosa, right - so it's too ambiguous?
16:47:25 <sm> dhrosa: you probably want to some of your parsers to "commit".. ie if they start to match successfully, they should either go all the way or: fail "specific error message here"
16:47:53 <dhrosa> sm: maybe less promiscuous use of try in my code?
16:48:10 <sm> ie terminate the whole parse. Maybe fail isn't the way to do that.
16:48:15 <sm> yes maybe that too
16:48:44 <arboris> dpn`: The idea is that Eq a encodes the fact that the provided function satisfies the laws expected for equality, namely that it is idempotent, that is x == x, symmetric x == y implies y == x and transitive x == y and y == z implies x == z
16:49:43 <benzrf> arboris: idempotent
16:49:50 <benzrf> don't you mean reflexibe
16:49:53 <benzrf> *reflexive
16:50:01 <arboris> right sorry
16:50:04 <dibblego> idempotence is f(f(x)) = f(x)
16:50:07 <dpn`> arboris, right gotcha
16:50:12 <arboris> i know
16:50:18 <arboris> it's late here
16:50:24 <dpn`> but that would be for Eq :: a -> b -> Bool
16:50:33 <dpn`> what about explicitly with A -> B -> Bool ?
16:50:48 <dpn`> (kinda being devils advocate here as I think I get it)just want to clarify
16:51:35 <dpn`> you prob missed my reply arboris
16:51:39 <jollygood> ah nevermind, it works! Color accepts 16 bit integer, not 8 bit
16:51:47 <arboris_> yeah sorry got disconnected
16:52:06 <dpn`> arboris, https://gist.github.com/dpnova/d3b725d80a1ddf6fdd2e
16:53:48 <sm> I think any time you allow backtracking with try, you should consider checking the partial match for an obvious malformed input to be reported immediately
16:54:01 <arboris_> sorry, don't understand the question, not everything with signature A -> A -> Bool would satisfy the laws i've stated
16:54:37 <sm> (and I'm not sure how to do that, other than poking around in parsec's state)
16:55:35 <arboris_> i'm surprised that parsec does not simply report an error stating that none of the tried parsers match
16:55:40 <arboris_> that should be simple enough
16:55:59 <arboris_> and i think trifecta does that
16:56:37 <sm> arboris_: it does at the end, the problem is that the resulting error may be suboptimal
16:56:39 <dpn`> arboris_, actually that's exactly the answer .. thanks!
16:59:10 <arboris_> sm: maybe just refactor your grammar? nothing is stopping you from grouping the long list of parsers into meaningful subsets, right?
16:59:33 <arboris_> if you are using parsec, performance can't be your main concern anyways
17:00:00 <Thule> List comprehension is acting a big strange. Here is the pastebin: http://lpaste.net/111454 If I invoke returnLoan "thule" "thulebog1" then both ("thule","thulebog1") and ("sigrid", "thulebog1") is removed from the list. Howcome? Do I have to put && in the list compresion?
17:02:09 <glguy> > let returnLoan db pers book = [(x,y) |(x,y) <- db, x /= pers, y /= book]; exampleBase = [("thule","thulebog1"),("thule","thulebog2"),("sigrid","thulebog1")] in returnLoan exampleBase "thule" "thulebog1"
17:02:11 <lambdabot>  []
17:02:32 <glguy> Thule: Maybe you need to save your file or something?
17:03:02 <Thule> The same thing happens in your example.. Why are both "sigrid,thulebog1" and "thule","thulebog1" removed?
17:03:19 <Thule> why is it not only "thule","thulebog1"
17:04:23 <glguy> The first two are removed because the pers matched
17:04:32 <sm> arboris_: I might be wrong, but I don't think that helps with the particular goal I'm walking about: giving specialised and parse-terminating errors when certain parsers partially succeed
17:04:35 <glguy> the last one is removed because book matched
17:04:52 <Thule> So both conditions do not have to be matched? Just any of them?
17:05:06 <glguy> Both conditions must be true for the result to be returned
17:05:10 <glguy> and /= means "not equal to"
17:05:26 <Fuuzetsu> are there any good resources on representable functors?
17:05:45 <Fuuzetsu> the next thing in this book is Yoneda so I'm kind of wary of proceeding without understanding things better
17:05:59 <Thule> yes, so x cannot be equal to "thule" AND y cannot be equal to "thulebog1".. It should not remove "sigrid","thulebog1"
17:06:05 <Fuuzetsu> maybe I should go through the material again…
17:07:04 <nshepperd> Thule: (¬a=b) && (¬c=d) is not the same as ¬(a=b && c=d)
17:07:05 <glguy> Thule: your expression simplifies to:   true AND false
17:07:10 <glguy> false
17:07:37 <Thule> yes glguy true AND false = false. Therefore only "thule","thulebog1" should have been removed. "sigrid","thulebog1" should not
17:08:40 <nshepperd> Thule: it's not removing things, it's including them. thing is only included if the expression is true
17:08:58 <Thule> ahh.. of course.. thank you :)
17:09:19 <Thule> Wrapped my head the wrong way around it...
17:09:33 <sm> for example, what if parsec let you run a predicate on the partial match whenever it's about to backtrack, which could choose to terminate the whole parse if it sees a very clear-cut error in the input
17:12:23 <Axman6> Thule: think as filter as filtering water, you're only left with what you want, not what you don't
17:12:40 <Thule> ye, thanks
17:13:46 <Fuuzetsu> I can never remember which way it is ;/
17:14:03 <Fuuzetsu> maybe we only want the clean water
17:15:35 <arboris_> Fuuzetsu, representable functors are about the presheaf category for a small category
17:15:48 <arboris_> the motivation is mostly from geometry
17:16:12 <Fuuzetsu> ah, I don't get to presheaves until later
17:16:28 <arboris_> representable functors are those objects in the presheaf category that come from actual objects in original category
17:16:28 <Fuuzetsu> presheaves are more or less the goal here
17:17:11 <arboris_> so you think of elements of the presheaf category as generalized objects and of representable functors as those that actually come from objects
17:17:25 <arboris_> the yoneda lemma provides the justification for that
17:18:08 <arboris_> the reason why this is useful, is that certain categories don't have enough objects, so you need to manufacture new ones :)
17:18:41 <Fuuzetsu> seems I'll have to do some research later…
17:19:24 <arboris_> i don't know why you want to learn this stuff, but it is a good idea to have some geometric / commutative algebra examples in mind
17:19:31 <arboris_> and not just learn the abstract nonsense
17:21:24 <joelteon> with hs-boot files, "module {...} cannot be linked; it is only available as a boot module"
17:21:28 <joelteon> is there a cabal directive i need to add?
17:21:55 <Fuuzetsu> arboris_: my uni project is about implementing http://homepages.inf.ed.ac.uk/gdp/publications/Abstract_Syn.pdf so I'm just learning CT as prerequisite
17:24:38 <yukko> is there any benefit to using Foreign.C.Types.CChar versus Int8 for things that have to talk to a C FFI?
17:24:53 <arboris_> http://mathoverflow.net/questions/3184/philosophical-meaning-of-the-yoneda-lemma, look at Sridhar Ramesh answer, maybe that is helpful aswell.
17:25:18 <arboris_> it seems to be more in line with what you need it for anyways
17:27:30 <Fuuzetsu> I'll read it after I work through the abstract nonsense first ;P
17:28:45 <exio4> does anyone know any toy operating system written in a total functional language?
17:29:00 <exio4> totally unrelated to #haskell, but whatever :P
17:29:04 <monochrom> yukko: it has a benefit when C char is not C int8.
17:29:50 <yukko> but the CChar type is a newtype that takes an int8
17:29:56 <monochrom> Haskell CChar always tracks C char. Haskell Int8 always tracks C int8.
17:30:05 <yukko> ohh
17:30:09 <monochrom> where did you read that?
17:30:40 <joelteon> what do I do to make cabal aware of hs-boot files
17:30:57 <yukko> https://hackage.haskell.org/package/base-4.7.0.0/docs/Foreign-C-Types.html#t:CChar
17:31:02 <Fuuzetsu> you'll regret using boot files
17:31:05 <joelteon> okay
17:31:07 <joelteon> how do i use them
17:31:12 <sm> chickens. It likes chickens.
17:31:34 <Fuuzetsu> joelteon: it shouldn't need any special work on cabal side
17:31:42 <Fuuzetsu> just make sure to import with {-# SOURCE #-} in your modules
17:31:56 <joelteon> yeah, i figured you missed my earlier messages
17:31:58 <joelteon> hang on a sec
17:32:00 <joelteon> with hs-boot files, "module {...} cannot be linked; it is only available as a boot module"
17:32:02 <joelteon> is there a cabal directive i need to add?
17:32:06 <monochrom> ok, that is because that code already knows or assumes what kind of C compilers you use, and it happens that char = int8 there.
17:32:29 <Fuuzetsu> huh
17:32:42 <Fuuzetsu> do you not have a regular module along with boot file?
17:32:51 <joelteon> .....
17:32:53 <nshepperd> how many platforms have char != int8?
17:32:55 <joelteon> no, it's there
17:32:57 <joelteon> I didn't remove it
17:33:16 <monochrom> very few, and no Haskell compilers on those platforms yet.
17:33:18 <Fuuzetsu> I don't know what the problem is then, it should just work without extra cabal work
17:33:46 <yukko> monochrom I see!
17:33:47 <monochrom> so every existing Haskell compiler can make that assumption. but you may not like to make it yourself.
17:33:55 <joelteon> okay thanks
17:34:01 <Fuuzetsu> we use boot files in Yi https://github.com/yi-editor/yi/blob/master/yi/yi.cabal and we have no extra handling
17:34:06 <yukko> so CChar is automatically generated depending on the system you're running it on?
17:34:17 <Fuuzetsu> but we regret using them so they are going to go soon
17:34:21 <joelteon> cool
17:34:23 <monochrom> yes.
17:34:33 <yukko> thank you for clearing that up for me!
17:34:38 <monochrom> in fact, Haskell Int is more interesting.
17:34:59 <yukko> really?
17:35:12 <monochrom> GHC's Haskell Int tracks your choice of 32-bit or 64-bit.
17:35:33 <joelteon> okay
17:35:33 <zq> define choice
17:35:37 <joelteon> it compiles the boot module ok
17:35:45 <joelteon> the part it gets confused about is when it tries to compile the real module
17:35:50 <joelteon> which uses template haskell, so maybe that's the problem.
17:35:53 <yukko> how do you choose which int you want?
17:36:03 <joelteon> so you can't use TH in modules that have an hs-boot?
17:36:05 <monochrom> GHC built for 64-bit uses 64 bits for Int. GHC built for 32-bit uses 32 bits for Int.
17:36:13 <zq> blah
17:36:13 <monochrom> it's a build-time choice.
17:36:18 <yukko> ohh
17:36:35 <Fuuzetsu> I just filed some bugs about test-suites failing on 32-bit systems the other day ;)
17:36:39 <Fuuzetsu> those pesky Ints
17:36:59 <monochrom> so if you download 32-bit GHC, and you read its HsFFI.h file, you find HsInt typedef'ed to int32.
17:37:20 <monochrom> if you download 64-bit GHC, its HsFFI.h typedef's HsInt to int64
17:37:45 <monochrom> however, in both cases, CInt tracks C int reliably.
17:39:27 <nshepperd> variable sized ints don't seems so useful
17:39:53 <nshepperd> unless you're trying to stick a C pointer into an Int
17:40:06 <monochrom> sure. on both x86 and x86_43, C int is 32 bits.
17:40:43 <monochrom> but C long is different.
17:41:16 <monochrom> err, s/x86_43/x86_64/
17:42:02 <monochrom> not too long ago, in Turbo C, int was 16-bit.
17:42:47 <davean> um. monochrom I think you'll find that varies by OS and more
17:43:02 <davean> monochrom: you may wish to look up "ILP64"
17:43:26 <monochrom> yes, I assumed linux.
17:43:55 <davean> Well, linux is even more complicated then
17:44:00 <yukko> I think Int is a bit silly, and should only be used if you're worried about FFI/speed-related things
17:44:09 <yukko> everyone should use Integer by default
17:44:10 <davean> you can have a 64 system and executable, operating on 64bit ints with 32bit pointers
17:44:43 <monochrom> well I already said x86 and x86_64, so read "assumed linux" in that context.
17:45:02 <davean> monochrom: yes, x86_64 Linux, you can have 32bit pointers
17:45:13 <davean> It is an avialable mode
17:45:37 <monochrom> ok, but I was talking about int only.
17:46:01 <vanila> (Bool, (Bool, (Bool, (Bool, (Bool, (Bool, (Bool, (Bool, ())))))))))))))) portable implementation of Int8
17:46:09 <davean> Sure, my point is it is variable even then.
17:48:25 <nshepperd> down with variable sized ints!
17:48:36 <pjdelport> Now With More Bottoms!™
17:48:50 <nshepperd> newtype Int = Int Int32
17:49:25 <yukko> nshepperd chyeah
17:50:22 <nshepperd> or is it "type Int = Integer"
17:50:26 <joelteon> not with (# Int#, (# Int#, (# Int#, (# Int#, (# Int#, (# Int#, (# Int#, (# Int#, () #) #) #) #) #) #) #) #)!
17:50:57 <yukko> nshepperd even better!
17:52:04 <pjdelport> joelteon: now if only you could unbox to bits.
17:52:22 <joelteon> hmm
17:52:26 <joelteon> maybe (# Int8# #)
17:57:16 <khyperia> http://www.haskell.org/haskellwiki/GHC/Memory_Management This page says that "The trick is that immutable data NEVER points to younger values"... how does that work with thunks? Are they a special case? As in can thunks see into the future? For example, consider: `let a = 1 : b; b = 2 : a in a` - it's impossible for everything to point to something older than it, because it's a lop
17:58:39 <joelteon> was it ever resolved that cabal repl fails if the project doesn't compile under ghc 7.8.3?
17:58:56 <joelteon> because it builds first, *then* loads all the modules into ghci
17:59:14 <khyperia> Whatever the answer is, though, I really like the phrase "thunks can see into the future!", heh
18:00:27 <trap_exit> what's a good emacs to use on windows?
18:00:33 <splintax> how come you can write "func = \x -> 2*x" in a haskell source file, but in ghci you have to write "let func = \x -> 2*x" ?
18:00:42 <trap_exit> hmm, wrong channel
18:00:52 <trap_exit> what's a good ide fo rhaskell dev on windows? do I need to sintall cygwin ?
18:01:04 <Fuuzetsu> splintax: ??
18:01:12 <nshepperd> I'm not sure, that sounds like a lie. thunks are mutable - it is their purpose
18:01:13 <Fuuzetsu> oh sorry I misread that
18:01:19 <Fuuzetsu> GHCi is a bit special
18:01:23 <joelteon> ghci wants let because ghci is sort of like running inside the IO monad.
18:01:27 <joelteon> except with an import statement.
18:01:29 <Fuuzetsu> thinking of it as if you are inside ‘do’ for IO monad helps
18:01:37 <Fuuzetsu> with exceptions
18:01:44 <splintax> ah
18:01:50 <joelteon> afaik it used to not have import, you had to use :m +somemodule instead
18:02:06 <splintax> "let <expr>" doesn't seem to make a whole lot of sense without a corresponding "in <scope>"
18:02:17 <splintax> that's not part of haskell, right?
18:02:19 <trap_exit> except during a 'do'
18:02:20 <Fuuzetsu> it does inside ‘do’ however
18:02:25 <trap_exit> Fuuzetsu++
18:02:30 <trap_exit> almost as quick as me
18:02:39 <Fuuzetsu> but you don't have fancy quotes
18:02:57 <splintax> hmm
18:03:09 <splintax> is that a different thing to "func <- \x -> 2*x"
18:03:33 <nshepperd> > do { let a = 1; print a}
18:03:36 <lambdabot>  <hint>:1:24: parse error on input ‘}’
18:03:52 <monochrom> you need more {}s
18:04:02 <splintax> ah i see, it is actually a part of the do syntax
18:04:04 <monochrom> > do { let {a=1}; print a }
18:04:05 <lambdabot>  <IO ()>
18:04:19 <nshepperd> ah
18:04:35 <monochrom> it does not have "in" because it is implied and there is no good place to make it explicit
18:04:53 <Fuuzetsu> ‘let … in everything below’
18:04:58 <splintax> cool thanks
18:05:57 <dfeuer> monochrom, isn't it basically to avoid pushing everything to the right?
18:06:07 <monochrom> yes
18:06:20 <Welkin> do blocks are evil!
18:07:13 <dfeuer> Welkin, I think you're confusing do blocks with doo blocks.
18:08:17 <nshepperd> do notation is magical and great
18:08:29 <MP2E> scooby doo blocks
18:10:08 <Fuuzetsu> it's great but it's not magical
18:10:19 <Welkin> it feels wrong to use do notation in haskell
18:10:26 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/91920/
18:10:36 <vanila> Welkin, same , but never know what to use instead
18:10:50 <vanila> I like the idea of a language that lets you use monads without 'do'
18:10:54 <vanila> but then it woulnd't be lazy
18:11:28 <dfeuer> vanila, isn't GHC bringing monad comprehensions back?
18:11:31 <monochrom> before the do-notation, people wrote like this:
18:11:39 <vanila> monad comprehensions isn't "it" for me though
18:11:44 <monochrom> getLine           >>= \s ->
18:11:56 <monochrom> putStrLn s          >>= \_ ->
18:12:02 <monochrom> putStrLn (s ++ s)
18:12:21 <monochrom> if you try to align those >>='s, it looked ok
18:12:21 <Fuuzetsu> aren't monad comprehensions back already
18:12:44 <vanila> in scheme, using continuations, I can write  (from-list-monad (+ (to-monad (list 1 2 3)) (to-monad (list 5 6))))
18:13:01 <vanila> do mean  do a <- [1,2,3] ; b <- [5,6] ; return (a+b)
18:13:02 <Fuuzetsu> good thing you're not using scheme then because that looks terrible
18:13:40 <vanila> something like this is nice, but this requires strict evaluation order so you would only be albe to use lazyness explicitly
18:18:34 <khyperia> heh, splintax just sent me on a crazy chase trying to figure out what "func <- \x -> 2 * x" meant in the function monad... apparently it's the same as "func <- asks (\x -> 2 * x)" in the Reader monad
18:19:08 <khyperia> so... wait, asks = newtype-d id?
18:19:12 <dfeuer> vanila, I do not even understand what that's supposed to mean, or how laziness relates.
18:19:14 <trap_exit> you know
18:19:18 <trap_exit> someone really needs to build something like leksah
18:19:23 <trap_exit> someone needs to build leksah
18:19:23 <monochrom> @type ask
18:19:24 <lambdabot> MonadReader r m => m r
18:19:25 <khyperia> err, ask = id
18:19:26 <trap_exit> but using web tech
18:19:37 <monochrom> looks like yes
18:21:05 <monochrom> next time you see the conversation "<A> can I ask a question? <B> just ask", you know it is a newtype version of:
18:21:17 <joelteon> :t Just ask
18:21:19 <lambdabot> MonadReader r m => Maybe (m r)
18:21:21 <monochrom> <A> what function should I apply to my question? <B> id
18:21:46 <trap_exit> I don't get the joke.
18:21:48 <trap_exit> Someone please explain.
18:22:06 <monochrom> ask is a newtype away from id
18:22:16 <trap_exit> @type id
18:22:17 <lambdabot> a -> a
18:22:19 <trap_exit> @type ask
18:22:20 <lambdabot> MonadReader r m => m r
18:22:29 <shachaf> monochrom: Where does Maybe get involved?
18:22:45 <monochrom> no Maybe is involved. my "just" is English.
18:24:01 <khyperia> trap_exit, the function instance for MonadReader is... well, lemme show you source
18:24:21 <khyperia> https://hackage.haskell.org/package/mtl-1.1.0.1/docs/src/Control-Monad-Reader.html not sure of the line number, but the line with "instance MonadReader r ((->) r) where"
18:24:24 <Fuuzetsu> trap_exit: I'll let you in on a secret that hamishmack already is thinking about something like that ;)
18:24:52 <hamishmack> trap_exit: The plan for the Leksah UI is to replace it with ghcjs-dom one
18:25:30 <trap_exit> hamishmack: I will put you in contact with my patent lawyer.
18:25:37 <MP2E> heh
18:25:39 <trap_exit> hamishmack: so this removes the gtk depndency ?
18:27:08 <hamishmack> Exactly.  Making the Windows and OS X builds of Leksah work consumes a lot of time largely because of Gtk
18:27:35 <hamishmack> It also means Windows and OS X users are less likely to contribute to Leksah
18:27:45 <trap_exit> hamishmack: exactly
18:27:56 <Fuuzetsu> FTR there are some very fresh plans to maybe perhaps write an SDL frontend for Yi to be more portable than the gtk one
18:27:59 <trap_exit> hamishamck: I'm installing virtual box right now just becuase osx / leksah is impossible to install
18:28:09 <trap_exit> I'm installing virtual box to install virtualbox to run leksah on my mbp
18:28:26 <Fuuzetsu> trap_exit: sounds harder than getting GTK to work
18:28:27 <hamishmack> You know there is a binary for Leksah on OS X
18:28:39 <trap_exit> Fuuzetsu: nah, virtual box + ubuntu are easy
18:28:52 <trap_exit> Fuuzetsu: bet you did not install gtkhs on osx
18:29:08 <Fuuzetsu> no, OSX is right after Web on my list of stuff I hope to not touch
18:30:58 <hamishmack> trap_exit: I use macports to install Gtk on OS X (except GHC which I compile from source)
18:31:23 * hackagebot hath 0.2.2 - Hath manipulates network blocks in CIDR notation.  http://hackage.haskell.org/package/hath-0.2.2 (MichaelOrlitzky)
18:31:25 <hamishmack> but virtual box + ubuntu is much easier
18:32:03 <Fuuzetsu> wonder if leksah is in nixpkgs
18:32:07 <trap_exit> ha
18:32:09 <trap_exit> i lied
18:32:12 <trap_exit> I'm actually downloading nixos
18:32:13 <trap_exit> not ubuntu
18:32:16 <Fuuzetsu> apparently not
18:32:19 <trap_exit> Fuuzetsu: do you use nixos?
18:32:22 <Fuuzetsu> yes
18:32:43 <trap_exit> Fuuzetsu: can I PM you with nixos help? (take a hit for #haskell :-) )
18:32:54 <Fuuzetsu> why not ask in #nixos instead?
18:40:59 * hackagebot pipes-zlib 0.4.1 - Zlib and GZip compression and decompression for Pipes streams  http://hackage.haskell.org/package/pipes-zlib-0.4.1 (RenzoCarbonara)
18:53:06 <Kron> oh god someone actually USED my old quadtree library! Gave me a thank you in a github issue and everything :D
18:53:09 <Kron> eeee so happy
18:53:15 <Kron> or wait, maybe that should be in #haskell-blah
18:56:00 * hackagebot mvc-updates 1.2.0 - Concurrent and combinable updates  http://hackage.haskell.org/package/mvc-updates-1.2.0 (GabrielGonzalez)
18:56:07 <joelteon> wow, I'm pleasantly surprised with how less bad persistent 2.0 is
19:03:55 <erikd> joelteon: what makes you say that?
19:04:21 <joelteon> well, keys have separate newtypes now
19:05:54 <erikd> joelteon: i've not been able to move to 2.0 yet because it doesn't support ZonedTime where as < 2.0 does. haven't had the time to sit down and sort it out.
19:06:11 <joelteon> unbelievable!
19:09:06 <erikd> joelteon: the change? apparently there's a good reason for it : https://github.com/yesodweb/persistent/issues/290
19:10:31 <joelteon> oh, it's postgres' fault
19:10:57 <erikd> yeah
19:30:24 <dhrosa> what does it mean when parsec says "unknown parse error"?
19:37:48 <dibblego> it means using strings in error messages means you are going to have a nice day
19:40:35 <Sorella> You could extend that to just about anything in programming :D
19:41:08 <Fuuzetsu> I don't know, error messages generally mean you're already having a shitty day
19:44:25 <dhrosa> :
19:44:26 <dhrosa> :/
19:45:53 <simpson> Also, writing parsers.
19:46:27 <TheMoonMaster> Is there anything in Haskell like Ruby's Kernel.exec? Replace the current process with another one
19:46:37 <TheMoonMaster> In my case I want my executable to be replaced with `less`
19:47:31 <dfeuer> TheMoonMaster, yes.
19:47:57 <TheMoonMaster> dfeuer: Any idea what it is?
19:48:20 <dfeuer> That's actually not a Haskell or Ruby thing, per se; it's more a system thing. Which suggests System.____ would be a good place to look. One sec.
19:48:46 <Fuuzetsu> I imagine he was looking for ‘yes p’ ;)
19:48:51 <TheMoonMaster> Yeah, but not all languages give you access to that directly.
19:49:01 <TheMoonMaster> Erlang/Elixir for instance don't.
19:49:06 <TheMoonMaster> executeFile ?
19:50:09 <dfeuer> TheMoonMaster, GHC is pretty good about giving access to basics like that.
19:50:11 <Hafydd> TheMoonMaster: I think you'd have to use System.Posix.Process, since such a thing isn't possible on Windows.
19:50:27 <TheMoonMaster> Don't even care about Windows support.
19:50:35 <TheMoonMaster> They can deal with it if any of them ever want to use it
19:51:03 <Hafydd> (It's possible to create a process in Windows that inherits file descriptors, but the parent process will still count as having terminated.)
19:51:18 <dfeuer> TheMoonMaster, there's certainly http://hackage.haskell.org/package/unix-2.7.0.1/docs/System-Posix-Process.html
19:51:45 <dfeuer> If you don't want to rely on a package like that, you can always use the FFI to call exec yourself.
19:52:38 <TheMoonMaster> I don't mind relying on it
19:52:44 <TheMoonMaster> FFI sounds worse, ha.
19:54:04 <TheMoonMaster> Thanks for the help.
19:54:04 <Arahael> TheMoonMaster: you have a strange definition of worse.
19:54:14 <TheMoonMaster> Arahael: How would FFI be better?
19:56:30 <Arahael> TheMoonMaster: you're making a system call that says "rip out this entire process, and replace it with some other process". at this point, an ffi isn't worsemor better than anything else.
19:56:53 <TheMoonMaster> Yeah it is, because that's one more thing I have to maintain.
19:57:13 <Arahael> TheMoonMaster: please do be aware of locks, even from other threads though.
19:57:29 <Arahael> exec will never change.
19:57:35 <TheMoonMaster> My use case is so simple I shouldn't hit an issue with it.
19:57:39 <TheMoonMaster> Thanks for the heads up though
19:57:46 <dhrosa> using parsec, how do I retrieve the next token in the stream, do a pattern match on it, and then put it back into the stream (similar to try) if the pattern doesn't match the way I want
19:58:32 <Arahael> TheMoonMaster: i do suggest a different call though, less edge cases.
19:59:30 <dfeuer> Arahael, like what?
20:00:17 <Arahael> dfeuer: how do you clean up resources?
20:00:36 <TheMoonMaster> Which call?
20:00:40 <Arahael> release locks, remove temporary files, any of that?
20:00:44 <TheMoonMaster> I literally need to replace it with less, then exit.
20:00:54 <dfeuer> Arahael, I see what you're saying.
20:01:05 * hackagebot http-common 0.7.2.0 - Common types for HTTP clients and servers  http://hackage.haskell.org/package/http-common-0.7.2.0 (AndrewCowie)
20:01:07 * hackagebot http-streams 0.7.2.2 - An HTTP client using io-streams  http://hackage.haskell.org/package/http-streams-0.7.2.2 (AndrewCowie)
20:01:36 <Arahael> TheMoonMaster: i suggest just launching a process and then wsiting for it to close.
20:02:42 <TheMoonMaster> I have no idea how to do that.
20:02:46 <dfeuer> Arahael, it depends on whether the held resources need to be finalized in some fashion, right?
20:03:08 <TheMoonMaster> All I need to do is get some text, send it to less, then die.
20:03:21 <dfeuer> TheMoonMaster, just put cardamom in your rice pudding.
20:04:12 <Arahael> dfeuer: the finalizers aren't called, generally.
20:04:15 <dfeuer> TheMoonMaster, what happens if you fork a new process and then *don't* wait for it?
20:04:37 <Arahael> (unless i'm badly mistaken... but how could they be?)
20:05:07 <TheMoonMaster> I'm sure bad things happen.
20:05:08 <dfeuer> Arahael, no, of course not. But if they don't need to be, that might be okay? I meant to ask you what happens if you fork a new process and then don't wait for it.
20:05:48 <Arahael> dfeuer: then you have the classic unix c multiprocessing model.
20:06:19 <Arahael> dfeuer: you do mean fork, right, because that also has issues.
20:06:29 <dfeuer> Hrmmm.
20:06:32 <dfeuer> I dunno.
20:06:40 <dfeuer> I don't remember almost any of this stuff.
20:07:17 <dfeuer> It's been years since I touched Advanced Programming in the Unix Environment, and I didn't understand everything back then either.
20:07:32 <Arahael> dfeuer: fork may or may not duplicate the threads, iirc, and you may or may not inherit any locks or resources, which may or may not end up being released or finalised twice.
20:07:44 <dfeuer> Yuck.
20:08:16 <flebron> Literally every time I've tried to install something Haskell-related on Gentoo, I've deeply regretted it for a long time.
20:09:12 <dfeuer> Arahael, I guess the correct solution might've been to allow a program to return not only an exit code but also a "continuation" asking its parent to execute another command on its behalf.
20:09:25 <Arahael> dfeuer: it's one reason why you see people fork and then immediately exec on unix.
20:09:30 <dfeuer> But permissions for that could be ugly.
20:09:53 <Arahael> dfeuer: you mean, like system?
20:10:07 <dfeuer> Yeah, but if you have multiple GHC threads and one of them is trying to exec and another is trying to do something else.... ew.
20:10:39 <Arahael> dfeuer: then your entire haskell process might be gone.
20:11:06 * hackagebot hdevtools 0.1.0.6 - Persistent GHC powered background server for FAST haskell development tools  http://hackage.haskell.org/package/hdevtools-0.1.0.6 (SchellScivally)
20:11:10 <dfeuer> OK, I don't understand all these issues right.
20:11:33 <dfeuer> I just meant that the fork/immediate exec trick might not work properly in Haskell.
20:11:56 <Arahael> just use a sub process and don't worry. fork doesn't exist on windows anyway so you are more portable. yay!
20:12:38 <dfeuer> Arahael, except you don't actually want to wait for the child before you finalize! You want to finalize and *then* wait for the child!
20:12:43 <Arahael> ah, yeah fork then exec could be tricky - i havent done enough haskell to know though.
20:12:59 <dfeuer> Arahael, I'm only speculating; I'm not really sure.
20:13:22 <nshepperd> posix has `spawn` now, I think
20:13:39 <nshepperd> that's probably a better idea
20:13:51 <Fuuzetsu> is there a typeclass for natural transformations or would it not make sense to have one considering there are many such transformations?
20:13:52 <dfeuer> nshepperd, what's that do?
20:13:56 <Arahael> anything is a better idea.
20:14:11 <nshepperd> well, any pre-baked "create a new process" routine really
20:14:37 <nshepperd> dfeuer: directly spawn a process instead of fork/execing, iirc
20:16:18 * geekosaur notes that posix_spawn has the usual problems for such a function: it's baroque
20:16:26 <Arahael> dfeuer: mind you - exec is faster because you don't finalise, the os can release certain resources for you
20:18:17 <Arahael> so just use s library - and forget about fork/exec/clone
20:18:29 <Arahael> *a
20:19:07 <dfeuer> All righty.
20:43:48 <jollygood> how come I am not getting ambigious type in here?  fun str = show $ read str + 1
20:44:06 <eazar001> SML?
20:44:17 <shachaf> The thing to look up is "defaulting".
20:51:10 <vanila> jollygood, show $ read str + 1 parses as show $ (read str) + 1  beacuse function application binds tighter than operators
20:51:30 <jollygood> i understand how it binds
20:51:30 <vanila> oh sorry that's not relevant to the problem
20:51:43 <vanila> I think you need show $ (read str + 1 :: Int)
20:51:45 <jollygood> yeah
20:51:45 <vanila> for some number type
20:51:53 <jollygood> no, it is not needed
20:51:57 <jollygood> that is what threw me off
20:52:34 <eazar001> > show $ read $ str + 1
20:52:36 <lambdabot>  Not in scope: ‘str’
20:53:02 <eazar001> > let fun = show . (+1)
20:53:03 <lambdabot>  not an expression: ‘let fun = show . (+1)’
20:53:15 <eazar001> > let fun = show . (+1) . read
20:53:15 <jollygood> > show $ read $ "10" + 1
20:53:17 <lambdabot>  can't find file: L.hs
20:53:17 <lambdabot>  not an expression: ‘let fun = show . (+1) . read’
20:53:25 <eazar001> > let fun = show . (+1) . read in fun "1"
20:53:26 <lambdabot>  "2"
20:53:26 <jollygood> uhm
20:53:31 <eazar001> > let fun = show . (+1) . read in fun "3"
20:53:32 <lambdabot>  "4"
20:53:34 <eazar001> > let fun = show . (+1) . read in fun "3.02121"
20:53:36 <lambdabot>  "*Exception: Prelude.read: no parse
20:53:41 <eazar001> > let fun = show . (+1) . read in fun "3.0"
20:53:43 <lambdabot>  "*Exception: Prelude.read: no parse
20:53:50 <eazar001> it default to Integral
20:54:21 <monochrom> jollygood: my answer would be the same as shachaf's answer.
20:55:14 <jollygood> monochrom I am glad you shared that with us.
20:56:12 <monochrom> show $ read "99999999999999999999999999999999999999999" + 1 would hint at what it defaults to.
20:56:32 <eazar001> > let fun = show . (+1) . read in fun "99999999999999999999999999999999999999999"
20:56:34 <lambdabot>  "100000000000000000000000000000000000000000"
20:57:41 <eazar001> there aren't "adaptable" defaults?
20:57:48 <eazar001> Integral for example
20:58:02 <eazar001> hmmm, i dunno
20:58:04 <monochrom> what counts as adaptable?
20:58:18 <eazar001> Int, or Integer
20:58:22 <eazar001> for exammple
20:58:32 <nshepperd> if you default to a typeclass you haven't defaulted at all
20:58:39 <eazar001> Integral
20:58:46 <eazar001> yea i guess so
20:59:36 <nshepperd> if you need something to be polymorphic, it's better to just put the type signature
20:59:51 <eazar001> well (+1) is just Num a => a -> a
20:59:53 <monochrom> there is a declaration you can write to change the defaults. but it won't really choose between Int and Integer.
20:59:56 <eazar001> so that part is easy
21:01:01 <eazar001> actually
21:01:15 <jollygood> have a lovely night everyone. monochrom, shachaf, fuck you very much.
21:01:24 <eazar001> let fun = show . (+1.0) . read in fun "3.04"
21:01:31 <eazar001> > let fun = show . (+1.0) . read in fun "3.04"
21:01:33 <lambdabot>  "4.04"
21:01:35 <eazar001> you jackass
21:01:38 <eazar001> you should have stayed
21:01:43 <shachaf> Huh?
21:01:53 <eazar001> i was going to make his shit work
21:02:01 <eazar001> i made a mistakke in my example
21:02:13 <vanila> How do I make haskell give a warning/error for things like  show . read ?
21:02:16 <eazar001> fucking people can't get past "instant gratification"
21:02:18 <vanila> instead of it silently picking a type for me
21:02:37 <monochrom> @type show . read
21:02:38 <lambdabot> String -> String
21:03:36 <eazar001> vanila: what do you mean by warning?
21:03:55 <eazar001> vanila: you mean when no parse occurs?
21:03:56 <geekosaur> afaik it already gives an error, since defaulting can't apply to it
21:04:02 <eazar001> vanila: i guess use a maybe solution
21:04:17 <nshepperd> > (show . read) "()"
21:04:17 <eazar001> Nothing for no Parse
21:04:19 <lambdabot>  "()"
21:04:38 <nshepperd> ^^ sane default? who knows
21:04:41 <geekosaur> otherwise, you can either turn on warnings for defaulting (I think -Wall has them on by default anyway) or turn off defaulting. for ghci, consider :set -XNoExtendedDefaultRules
21:04:52 <geekosaur> to knock it down to the same defaulting rules as compiling
21:04:56 <pharaun> can you define the defaulting or is this a thing in language spec?
21:04:59 <vanila> {-# LANGUAGE NoExtendedDefaultRules #-}
21:04:59 <vanila> fun str = show . (+1) . read
21:05:02 <vanila> this still doesn't give a warning
21:05:02 <monochrom> vanila: ghci and lambdabot have non-standard defaulting. if you give this file to ghc, you will get the correct error: main = print ((show . read) "x")
21:05:13 <geekosaur> yes, that has Num in it
21:05:24 <eazar001> Num a is the most general you can get
21:05:27 <monochrom> oh, if you have (+1) involved, then it's subject to standard Haskell 2010 defaulting
21:05:38 <pharaun> so the defaulting is a thing in the spec then?
21:05:39 <eazar001> for that case at leasst
21:05:40 <pjdelport> vanila: There's also -fwarn-type-defaults
21:06:03 <monochrom> pharaun, some defaulting is in Haskell 2010, some others are ghci additional
21:06:16 <geekosaur> -fwarn-type-defaults?
21:06:30 <geekosaur> sorry, I see someone mentioned that already
21:06:47 <vanila> {-# OPTIONS_GHC -fwarn-type-defaults #-}
21:06:47 <vanila> fun str = show . (+1) . read
21:06:54 <vanila> This gives me: Defaulting the following constraint(s) to type `Integer'
21:07:01 <vanila> thanks!
21:08:13 <monochrom> well, if you turn that on, you'll get a warning for even "main = print 1"
21:08:31 <vanila> i see
21:08:39 <monochrom> or "x = 5"
21:08:47 <geekosaur> as for disabling it, there is a keyword "default". `default ()` should disable all defaulting
21:08:49 <pharaun> monochrom: oh is this also semi-related to the monomorphism restriction (cos of having to pick a default, and CAFs) ?
21:08:59 <monochrom> yes
21:09:07 <geekosaur> the DMR is a key instigator of defaulting, yes
21:09:34 <vanila> {-# LANGUAGE NoMonomorphismRestriction #-}
21:09:35 <vanila> {-# OPTIONS_GHC -fwarn-type-defaults #-}
21:09:49 <vanila> This could be a nice start to haskell files
21:10:00 <pharaun> always wondered about the MR thing, i now at least get it a bit mroe
21:10:02 <pharaun> *more heh
21:10:26 <geekosaur> it's an ongoing argument, some people think those should be always on, some always off, some want some admixture
21:10:53 <geekosaur> nobody seems to care enough to push dor an official change...
21:15:41 <lpaste> threestrikes pasted “Example not accurate” at http://lpaste.net/111466
21:15:59 <threestrikes> Working on an example but getting error
21:16:07 <threestrikes> not sure what the problem is
21:16:19 <threestrikes> I copied it verbatim
21:16:28 <monochrom> what is Type11?
21:18:22 <lpaste> threestrikes revised “Example not accurate”: “No title” at http://lpaste.net/111466
21:19:18 <monochrom> ok, it looks like psuedocode. you're supposed to replace Type11 by an actual type. Similarly Type12 etc.
21:20:09 <geekosaur> yes. the Type<mumble> need to exist already; use existing types or define them yourself
21:20:27 <threestrikes> ok thanks
21:20:41 <threestrikes> I thought it was actual code it confused me
21:20:58 <threestrikes> doesn't help drinking rum :)
21:21:15 <geekosaur> well, it's real world code assuming you already have Type11 et al
21:21:23 <eazar001> also don't capitalize Type11
21:21:30 <geekosaur> huh
21:21:33 <geekosaur> huh?
21:21:43 <threestrikes> thought it had to be capitalized?
21:21:47 <dibblego> it does
21:21:49 <eazar001> I  thought that was Constr1
21:22:00 <threestrikes> ok
21:22:04 <geekosaur> Type11 is some concrete type
21:22:11 <eazar001> ohhhh
21:22:14 <eazar001> then capitalize it =]
21:22:25 <geekosaur> data AlgDataType type11 = Constr1 type11         would also be valid
21:22:35 <eazar001> or no ....
21:22:36 <eazar001> data constructor
21:22:39 <eazar001> you capitalize
21:22:43 <eazar001> field you DON'T capitalize
21:23:07 <geekosaur> you are confusing plain ADTs with record syntax, I think
21:23:19 <geekosaur> named fields, the field name must start with lowercase\
21:23:20 <eazar001> who me/
21:23:29 <geekosaur> but there is no named field in this ADT
21:23:54 <geekosaur> just data constructors parameterized by types
21:23:56 <eazar001>  data AlgDataType Type11 = Constr1 Type11
21:24:00 <eazar001> that shouldn't work ^
21:24:03 <geekosaur> yes, it should
21:24:11 <geekosaur> oh wait, *tjat* no
21:24:20 <monochrom> but no one wrote that.
21:24:27 <geekosaur> [23 04:21] <geekosaur> data AlgDataType type11 = Constr1 type11         would also be valid
21:24:31 <geekosaur> note lowercase type11
21:24:32 <eazar001> hmmm, okay let me look at paste again
21:24:38 <eazar001> i think i'm going crazy
21:24:47 <geekosaur> the paste has no parameterized ADT
21:24:56 <geekosaur> that is, it is data AlgDataType = ...
21:25:02 <Fuuzetsu> I see Wiki uses Set^C for the functor category of all covariant functors from C to Set; is that the standard notation? The book I'm reading uses Func(C, Set)
21:25:06 <geekosaur> not data AlgDataType Type11 = ...
21:25:29 <eazar001> oh okay okay
21:25:44 <eazar001> my mistake
21:26:08 <threestrikes> Thanks
21:26:23 <threestrikes> Always a lively bunch :)
21:34:40 <eazar001> threestrikes: yea it's a great channel
21:34:53 <eazar001> threestrikes: and sorry for the confusion, my wires got crossed
21:41:08 <Crockeo> Does anyone here know any tips for avoiding a <<loop>> when working with Netwire?
21:41:47 <Fuuzetsu> kan-extensions has a higher number of downloads than I would have imagined
21:41:57 <Fuuzetsu> probably all edwardk's own packages though
21:42:26 <Crockeo> I'm working with a Wire that requires an initial value, could that have something to do with it?
21:42:39 <Crockeo> Specifically that I'm generating that initial value through IO (randomIO, specifically)
21:43:33 <threestrikes> eazar001: no worries I'm just hoping .01% of some of the peoples brain power here will rub off on me :)
21:45:36 <mauke_> <<loop>> means you have an infinite loop
21:46:47 --- mode: ChanServ set +o copumpkin
21:46:58 <Crockeo> mauke_: I'm aware of that; I'm using {-# LANGUAGE Arrows #-} to work with ArrowLoop. In some situations you can write inter-dependent wires through using the 'rec' keyword, but sometimes in results in a <<loop>>.
21:47:05 --- mode: copumpkin set +b jollygood!*@*$#haskell-ops
21:47:16 <Crockeo> I'm more wondering if there are specific practices to avoid when writing Wires to avoid <<loop>>s when using 'rec' around them.
21:49:10 <jle`> Crockeo: netwire documentation has hints for you
21:49:22 <jle`> most of the wires have a "depends:" note
21:49:35 <jle`> make sure that at least one of your wires is not depends: now
21:49:48 <jle`> if they are all depends: now, then you're going to have problems
21:50:00 <Crockeo> jle`: Ahh, I was wondering when that'd come into play. Lemme review the documentation.
21:50:01 <jle`> using `delay` can introduce a fixed point
21:50:04 <Crockeo> Thanks for pointing me in the right direction.
21:50:41 <jle`> np :)
21:50:49 <jle`> i ahd a lot of frustration with this
21:50:58 <jle`> but i noticed the depends hints
21:51:06 <jle`> for the record, there's #haskell-game
21:51:20 <jle`> where FRP people like the inventor/maintainer of netwire hang out
21:51:47 <Crockeo> I didn't know that either! I'm gonna go check 'em out right now.
21:53:15 <jle`> Crockeo: basically, how to make rec work out, is you need a 'Wire' that can output its "first output" without taking into account anything else
21:53:41 <jle`> it's kind of weird in that it sort of forces you to leave FRP land
21:53:45 <jle`> and into Auto/implementation land
21:53:45 <Crockeo> Yeah, I had that inkling, but I didn't really know how to implement that in my current situation.
21:54:51 <erikd> is there a #lens channel for Control.Lens related stuff?
21:54:59 <jle`> erikd: there's #haskell-lens
21:55:09 <erikd> thanks jle`
21:55:33 <Crockeo> It may not be the most elegant solution but I solved it for now by just adding a delay to each of the offending wires. Tested it out and works perfect.
21:56:04 <jle`> Crockeo: yeah, adding a delay works :)  try to narrow down which delays are necessary
21:56:40 --- mode: copumpkin set -o copumpkin
21:57:51 <Crockeo> I just tested it out (removing one delay and not the other for both of them), both seem to be necessary.
21:58:15 <jle`> sometimes for now it just works ;)
21:58:37 <jle`> it depends on your situation if you afford a delay
21:58:58 <jle`> also what sometimes helps is switching the delay between before and after a wire, because it matters for some reason.  not sure why >_>
21:59:11 <Crockeo> I think it should be fine here; I'm just working on some vinyl-gl stuff using Netwire.
21:59:26 <Crockeo> And that /is/ weird.
21:59:35 <Thule> When I do a foldr with inline function, I normally do like this: foldr (\x acc -> something) [] [list of something]. But I was wondering why x comes before acc in the anonymous function, when [] comes before [list of something]
21:59:38 <Crockeo> Honestly, some of Netwire just seems like a black box to me. I guess that's the nature of abstraction in some ways.
22:00:13 <Crockeo> Because foldl takes the other way?
22:00:23 <Crockeo> How do you do calls to lambdabot again?
22:00:24 <dibblego> Thule: it is an important property of foldr that (foldr (:) [] x == x) and this would not hold if the arguments flipped
22:00:46 <LePalestineFace> http://puu.sh/bbSP0.jpg << HELP!!!!!
22:01:02 <Thule> ah okay. Thanks
22:01:09 <LePalestineFace> http://puu.sh/bbSP0.jpg << HELP!!!!!
22:01:11 <Crockeo> Just a warning, LePalestineFace's thing is a screamer.
22:01:15 --- mode: ChanServ set +o dibblego
22:01:17 --- kick: LePalestineFace was kicked by dibblego (LePalestineFace)
22:01:21 <LePalestineFace> http://puu.sh/bbSP0.jpg << HELP!!!!!
22:01:29 --- mode: dibblego set +b *!*Ryan@*unaffiliated/lepalestineface
22:01:31 --- kick: LePalestineFace was kicked by dibblego (LePalestineFace)
22:02:15 <geekosaur> arrows are ime something of a black box, and yes the abstraction is a part of it.
22:02:35 --- mode: dibblego set +b *!*@unaffiliated/lepalestineface
22:02:41 --- mode: dibblego set -b *!*Ryan@*unaffiliated/lepalestineface
22:03:04 --- mode: dibblego set -o dibblego
22:03:08 <geekosaur> it's harder to see when not having a delay (effectively something to insert laziness) makes for a function that immediately recurses into itself, because arrows don't look like functions but are
22:03:34 <Crockeo> I suppose it would be worth it to learn about the inner-workings of Arrows.
22:03:56 <Crockeo> Possibly similar to learning about the inner workings of memory when working in a language such as C?
22:04:30 <Crockeo> Maybe there's a baseline level of abstraction you need to peer through.
22:05:02 <brrrrian> hi
22:05:33 <geekosaur> I've always found Arrows a difficult abstraction, and tend to avoid them; Applicatives and Categories cover most of the use cases and are easier for me to comprehend. (Arrowized FRP being a notable exception)
22:05:46 <brrrrian> I'm looking for this function: (m a -> m b) -> [a] -> m [b]
22:05:54 <brrrrian> but I don't think it exists...
22:06:15 * hackagebot eternal 0.0.8 - everything breaking the Fairbairn threshold  http://hackage.haskell.org/package/eternal-0.0.8 (Heather)
22:06:18 <geekosaur> that looks wrong to me since you have an a, not an m a
22:06:29 <geekosaur> or rather, as specified the only possible m is []
22:07:10 <geekosaur> well, I giuess not if you assume the first thing it does is return a >>= ...
22:07:22 <simpson> :t \m l -> map m $ map return l
22:07:23 <lambdabot> Monad m => (m a -> b) -> [a] -> [b]
22:07:25 <geekosaur> but then you might as well just include that in something more gneral
22:07:26 <eazar001> :t mapM
22:07:27 <jle`> Crockeo: for the purposes of this, you are probably better off learning the inner workings of Auto
22:07:27 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
22:07:39 <geekosaur> like mapM, yes :)
22:07:41 <mauke_> :t \f xs = mapM (f . return) xs
22:07:42 <lambdabot> parse error on input ‘=’
22:07:43 <jle`> it's one of those things where...if you want to learn how Maybe works, you don't learn about Monads, you learn about Maybe
22:07:50 <mauke_> :t \f xs -> mapM (f . return) xs
22:07:51 <lambdabot> (Monad m1, Monad m) => (m1 a -> m b) -> [a] -> m [b]
22:08:01 <eazar001> there you go
22:08:11 <mauke_> but then, why do you have a function that takes m a in the first place?
22:09:10 <eazar001> just use (>>=) i guess
22:09:53 <brrrrian> hmmm... i just refactored the (m a -> m b) into a (a -> m b) and now I think I can use mapM
22:10:08 <gamegoblin> @pl \x y -> f (g x y) (h x y)
22:10:09 <lambdabot> ap (ap . (f .) . g) h
22:10:37 <brrrrian> mauke_: it's an (IO a -> IO a)
22:10:46 <brrrrian> I wanted to map [a] over it
22:11:21 <Fuuzetsu> dibblego: if one squints, your hostname looks like static.typing.…
22:11:32 <brrrrian> so I just "lifted the function out" and made it an (a -> IO a) and now I can mapM it
22:11:44 <eazar001> :hoogle (m a -> m b) -> [a] -> m [b]
22:11:51 <brrrrian> tried
22:12:00 <eazar001> k =]
22:12:03 <dibblego> eazar001: (=<<) with a return in there
22:12:30 <eazar001> dibblego: right, yea
22:13:05 <dibblego> @type \f -> (=<<) (return . f)
22:13:06 <lambdabot> Monad m => (a -> b) -> m a -> m b
22:13:10 <dibblego> no not that
22:13:28 <dibblego> @type \f -> (=<<) (f . return)
22:13:28 <lambdabot> (Monad m1, Monad m) => (m1 a -> m b) -> m a -> m b
22:14:23 <brrrrian> dibblego: I see
22:14:38 <brrrrian> that's neat
22:25:24 <adas> does anyone know what "cabal install --haddock-hoogle <package1> <package2>" does?
22:26:00 <gamegoblin> What’s wrong with: data PlayerI p g m e = PlayerI { getMove :: p -> GameI g m e -> g -> e (Either String (m, p)) }
22:26:12 <gamegoblin> Gives me  `e' is applied to too many type arguments
22:26:39 <gamegoblin> in this case, e is supposed to be an arbitrary monad
22:27:28 <gamegoblin> so it could be IO and it would return an IO (Either String (m, p))
22:28:10 <geekosaur> what does GameI's definition look like?
22:28:34 <gamegoblin> it actually doesn’t use e right now (but it will in the future)
22:29:01 <geekosaur> ah. absent that you probably need an extension so you can specify the kind, since it will probably be inferred as * otherwise
22:29:01 <gamegoblin> so I guess it’s a phantom type for GameI right now
22:29:44 <geekosaur> data PlayerI p g m (e :: * -> *) = ...          may need an extension to use a kind signature though
22:29:49 <jle`> gamegoblin: it infers that e :: (* -> *)
22:29:51 <jle`> so
22:30:01 <jle`> GameI must take a (* -> *) in its last argument
22:30:16 <jle`> it looks like it is inferring that e :: *
22:30:23 <jle`> so that must mean that GmaeI expects * as its third argument
22:30:51 <gamegoblin> I’m trying to make it like in Parsec, your parsec can return stuff out of an arbitrary monad
22:30:56 <gamegoblin> parser*
22:31:05 <jle`> GameI :: a -> b -> (* -> *) -> *
22:31:08 <jle`> will work
22:31:11 <jle`> what is the kind of GameI right now?
22:31:30 <jle`> actually, GameI :: * -> * -> (* -> *) -> * is the only thing taht will work
22:31:34 <gamegoblin> let me just paste it
22:31:57 <gamegoblin> jle`: here http://lpaste.net/3062826159000518656
22:32:30 <jle`> oh, it's just phantom, huh
22:32:34 <gamegoblin> for now
22:33:09 <gamegoblin> I am working on adding a `play` bit to Game that will take two players and play a game
22:33:26 <gamegoblin> But since a player’s getMove can be returned in an arbitrary monad, the play must return a type inside that monad
22:33:31 <gamegoblin> that monad will be e
22:33:35 <gamegoblin> most likely IO
22:33:42 <gamegoblin> but I figured I’d let it be arbitrary
22:33:48 <jle`> gamegoblin: i don't see the type error if that's all is there
22:34:11 <gamegoblin>     Expecting one more argument to `e'
22:34:11 <gamegoblin>     In the type `Monad e =>
22:34:12 <gamegoblin>                  p -> GameI g m e -> g -> e (Either String (m, p))'
22:34:13 <gamegoblin>     In the definition of data constructor `PlayerI'
22:34:14 <gamegoblin>     In the data declaration for `PlayerI'
22:34:22 <gamegoblin> Sorry, forgot to paste it
22:38:55 <gamegoblin> jle`: ideas?
22:40:03 <jle`> nope :/
22:40:09 <jle`> any luck with adding a kind signature?
22:40:25 <jle`> how about removing the Monad constraint?
22:41:07 <gamegoblin> when I remove the monad constraint, it says e is applied to too many type arguments
22:42:17 <gamegoblin> somehow parsec does this without specifying kind signature
22:42:34 <Crockeo> I haven't been particularly active anyways, but I can feel that sort of sleep-deprived sensation of the world being almost dream-like. I think that's my cue to go to bed. G'night everyone. And thank you so much jle`!
22:42:51 <kvanb> bye dude
22:43:07 <Cale> gamegoblin: Why is GameI parameterised by e?
22:43:26 <gamegoblin> Cale: I am not using it now, but I will be using it as soon as I can figure out why this isn’t working
22:43:29 <Cale> gamegoblin: Your problem appears to be the fact that kinds default to * whenever they're unconstrained
22:43:55 <Cale> Since you don't use e in the definition of GameI, it's assumed to be a type variable of kind *, that is, one with no parameters
22:44:18 <gamegoblin> Huh ok
22:44:39 <Cale> You could fix it by turning on KindSignatures and adding an explicit one, or turning on PolyKinds which should allow it to generalise
22:45:51 <Cale> (or just using e in the definition somehow)
22:46:18 * hackagebot lzma-conduit 1.1.1 - Conduit interface for lzma/xz compression.  http://hackage.haskell.org/package/lzma-conduit-1.1.1 (NathanHowell)
22:50:29 <yyttr3> Is there a simple equivalent to java's string.replaceAll(x,y) in haskell that i'm missing?
22:51:36 <shachaf> Data.Text.replace
22:51:40 <Axman6> @hoogle Eq a => a -> a -> [a] -> [a]
22:51:43 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
22:51:44 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
22:51:45 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
22:54:32 <adas> is haddock capable of generating relative urls instead of absolute?
22:55:22 <adas> there is an option for haddock "-q" that qualifies identifiers.. and one of the arguments for that option is "relative"
22:55:43 <adas> but not sure if its talking about relative URLs
22:55:55 <adas> i have a feeling it has nothing to do with uRLs at all
23:03:37 <Fuuzetsu> adas: that's not what the relative there means
23:04:00 <Fuuzetsu> it tells you in the Haddock manual what they mean
23:04:23 <adas> Fuuzetsu: thanks.. somehow i figured that out
23:04:29 <Fuuzetsu> http://www.haskell.org/haddock/doc/html/invoking.html
23:04:45 <Fuuzetsu> Example: If you generate documentation for module A, then the identifiers A.x, A.B.y and C.z are qualified as follows. ; none: x, y, z ; full: A.x, A.B.y, C.z ; local: x, A.B.y, C.z ; relative: x, B.y, C.z
23:04:54 <gamegoblin> Hmmm… how many type variables in a data type is too many type variables...
23:05:10 <Fuuzetsu> gamegoblin: the more the merrier
23:05:18 <Fuuzetsu> more types is always the answer
23:05:18 <gamegoblin> currently 6
23:05:26 <Fuuzetsu> you might want so type aliases however
23:05:33 <Fuuzetsu> some*
23:06:03 <gamegoblin> The data type defines a Match, and it has type variables: player1 type, player2 type, game type, game move type, monad type, and result type
23:06:10 <gamegoblin> =_=
23:06:40 <Fuuzetsu> do you really need to have type vars for players?
23:06:50 <Fuuzetsu> maybe you want something like TFs or GADTs instead
23:08:21 <gamegoblin> TF?
23:08:29 <Fuuzetsu> TypeFamilies
23:08:37 <Fuuzetsu> don't know if that's what you need but who knows!
23:08:46 <jle`> why not!
23:09:17 <Fuuzetsu> more TFs!
23:09:39 <gamegoblin> I suspect I can’t get around having type variables for each player
23:09:54 <Fuuzetsu> well, then feel free to use them of course
23:10:04 <Fuuzetsu> I am merely speculating
23:10:36 <gamegoblin> because when I ask a player what move they want to make, they return both a move, and another object of the same type of themselves
23:10:44 <gamegoblin> so that a player can modify itself as it plays
23:10:52 <gamegoblin> (i.e. an AI keeping some state between moves)
23:12:37 <adas> is it possible to install only the documentation of a package?
23:13:01 <Fuuzetsu> Install in what way? Some distros provide docs separately from the package
23:13:40 <Fuuzetsu> but if you want to generate it yourself then you can although you still have to run it for a bit (typecheck and rename), I think cabal haddock will run cabal build anyway
23:16:20 * hackagebot reactive-haskell 0.0.1 - minimal fork of io-reactive  http://hackage.haskell.org/package/reactive-haskell-0.0.1 (Heather)
23:39:40 <adas> how do most folks here view package documentation ... especially now that hackage has stopped buidling documentation?
23:41:17 <merijn> adas: 1) setup cabal to install local docs 2) yell at maintainers to manually upload docs
23:43:12 <adas> merijn: i have local docs installed but all them are installed with absolute urls. meaning if I copy the documentation to another location.. the links in the documentation don't work no more
23:43:32 <adas> is there any way to ask cabal to install the documentation with relative paths?
23:44:22 <pharaun> is there a story behind hackage stopping doc building (something bout cpu/ram?)
23:45:48 <splintax> adas: i use a shell script to find docs in the current cabal sandbox https://github.com/splintax/haskell-local-docs
23:47:57 <adas> splintax: how do you view them? right there on the command line or does it run some server.. where you can use a browser to browse the docs?
23:48:24 <yyttr3> I don't understand this IO. If I read from one file, open another temp file, manually close the first and try to write to the second I get an error.
23:48:57 <yyttr3> openFile : resource busy (file is locked)
23:49:00 <splintax> adas: it just calls "open index.html", which on OS X will open an html file the same as if you clicked it in the finder (ie. in a web browser)
23:49:06 <splintax> i assume there is a similar utility on most linux distros
23:49:13 <adas> ah okay cool
23:49:45 <adas> splintax: its unfortunate that im running my entier haskell setup inside a docker container..
23:49:56 <adas> so i have the documentation installed
23:50:12 <adas> but i can't view them on a browser or anything
23:50:24 <adas> tried copying the doc folder to the host..
23:50:28 <adas> but links get broken
23:51:00 <splintax> ah that's irritating. you can't share the whole .cabal or .cabal-sandbox directory with the host OS?
23:51:05 <merijn> yyttr3: Which function are you using to read the file?
23:51:23 <yyttr3> hGetContents
23:51:25 <adas> tried running a hoogle server to serve the documentation..
23:51:30 <merijn> yyttr3: ding, ding.
23:51:39 <adas> but cabal install does not buuild hoogle databases while installing a package
23:51:41 <yyttr3> What's wrong with that?
23:51:42 <merijn> yyttr3: hGetContents is lazy IO, causer of despair
23:51:51 <splintax> adas: i'm pretty sure it can be configured to do so
23:52:01 <merijn> yyttr3: hGetContents won't start reading from the file until you try and use the String it produces
23:52:02 <adas> yea must be a way
23:52:09 <splintax> adas: but yeah, cabal + haddock integration is pretty frustrating
23:52:20 <merijn> yyttr3: By using hGetContents and closing the file before trying to use the String it crashes
23:52:20 <yyttr3> I thought the file wouldn't close until fully read, so when I closed manually it would read the file in.
23:52:29 <splintax> i find it particularly annoying that there's no easy way (afaik) to build the docs without recompiling the library
23:52:46 <merijn> yyttr3: Manually closing the file will just close it, that's what it does
23:53:09 <yyttr3> Not closing the file doesn't help
23:53:18 <merijn> yyttr3: Two options, either use strict Text/ByteString to read in non-lazy or use some streaming IO library, depending on your needs
23:53:24 <merijn> hmmm, that's odd
23:53:36 <adas> yup.. thats annoying.. but one good thing about sandboxes and docker is that i can simply create a new sandbox and reinstall with documentation making sure to recompile parallely
23:54:03 <adas> takes 2 minutes.. but thats not bad unless you try installing everything on hackage
23:54:03 <yyttr3> If I have two files, one passed via CL and the other by openTempFile
23:54:31 <yyttr3> I'm trying to write to openTempFile,
23:54:37 <splintax> adas: your computer must be more powerful than mine. it takes me a lot longer than 2 minutes to compile, say, yesod, in a new sandbox
23:54:58 <splintax> adas: https://github.com/haskell/haskell-mode/wiki/Browsing-Haddocks might be of interest if you're already an emacs user
23:55:31 <adas> splintax: use the -j option next time while installing. might help
23:55:50 <splintax> it does, but not enough to come close to 2 minutes!
23:55:55 <yyttr3> merijn: https://gist.github.com/yyttr3/53d4709b19b9e53e20b8
23:56:30 <adas> i use -j4 and the difference ishuge
23:57:10 <splintax> i use a laptop, so :/
23:57:27 <merijn> yyttr3: oh, duh
23:57:40 <splintax> now if -j could run parallel builds on the GPU using accelerate...
23:57:48 <merijn> yyttr3: you're doing "writeFile filename", but the temp file is already open
23:58:09 <merijn> splintax: That doesn't make sense, GPUs would be terrible for compilation
23:58:10 <adas> mines a laptop too.. 8 logical cores..never tried -j8.. but i dont think it makes much difference
23:58:31 <merijn> yyttr3: openTempFile already returns a handle...
23:58:46 <yyttr3> I can't write to an open file?
23:59:11 <splintax> merijn: i was joking :)
