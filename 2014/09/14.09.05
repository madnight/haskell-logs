00:01:20 <sgronblo> Is Hackage really slow right now?
00:01:30 <Krautman> It is
00:01:30 <srhb> All of haskell.org is brokenish since yesterday
00:01:32 <Krautman> Yesterday too
00:01:37 <sgronblo> oh
00:02:04 <sgronblo> I hope the sites are implemented in PHP rather than Haskell :)
00:02:17 <Krautman> You WANT Haskell.org to remain down?
00:03:43 <lericson_> mauke: how do you mean i can write it [] a
00:04:55 <srhb> lericson_: fmap :: Functor f => (a -> b) -> f a -> f b. For the cast of lists, you have (a -> b) -> [] a -> [] b
00:05:08 <srhb> That is, f ~ []
00:05:13 <lericson_> oui
00:05:52 <srhb> Though we generally write [] a as [a] -- but the former makes the equivalence more visually direct.
00:06:30 <lericson_> so this is an allowed syntax? sum >> Num a => [] a -> a
00:06:34 <lericson_> sorry ::
00:07:23 <srhb> > let xs :: [] Int; xs = [1,2,3] in xs
00:07:24 <lambdabot>  [1,2,3]
00:09:56 <mauke> :t sum :: Num a => [] a -> a
00:09:57 <lambdabot> Num a => [a] -> a
00:10:19 <lericson_> so the application of [] to a gives [a]?
00:10:42 <lericson_> because ([]) 1 doesn't give me [1]
00:11:56 <srhb> lericson_: Indeed, [1,2,3] is special syntax. The actual constructors are : for cons cells and [] for empty list
00:12:50 <lericson_> so why doesn't it work?
00:12:56 <lericson_> if [a] ~ [] a
00:13:09 <Krautman> Because a is a type variable
00:13:17 <Krautman> Not an actual value
00:13:22 <Krautman> Right? ;)
00:13:26 <srhb> Not quite.
00:13:33 <srhb> Well.. Depends what you mean.
00:13:45 <Krautman> I mean that you can't just write [] 8
00:14:00 <srhb> > 1 : [] -- works on the value level because [] is a correct value constructor that represents the empty list
00:14:01 <lambdabot>  [1]
00:14:04 <Krautman> But [] Int is equivalent to [Int]
00:14:10 <lericson_> :t (:)
00:14:11 <lambdabot> a -> [a] -> [a]
00:14:17 <srhb> Right, because [] is a type constructor that takes one argument
00:14:20 <lericson_> aha ok
00:14:29 <Krautman> Exactly, type constructor vs data constructor
00:14:33 <lericson_> [] is a type constructor *as well* then
00:14:47 <srhb> But [] is not a value constructor that takes an argument (it takes none)
00:14:48 <lericson_> :kind []
00:14:56 <lericson_> [] :: * -> *
00:15:09 <Krautman> No, [] is just syntactic sugar for the cons operator
00:15:17 <srhb> What.
00:15:31 <lericson_> i see now
00:15:36 <Krautman> I'll just be quiet then ;)
00:15:38 <lericson_> it's different to use [] in types and not
00:15:38 <srhb> (:) is the cons operator
00:15:43 <srhb> [] is the empty list
00:15:54 <srhb> [] is also a type constructor, but types live on another level
00:15:59 <Krautman> I know, and [x] translates to x:[]
00:16:05 <srhb> AH, ok, like that
00:16:07 <lericson_> or [] x depending on context ;)
00:16:15 <srhb> Yes, [1,2,3] is sugar for 1:2:3:[]
00:16:16 <Krautman> Yeah, I'm terrible with human language
00:16:19 <srhb> :D
00:16:24 <trap_exit> can someone please explain to me how this works: https://github.com/valderman/haste-compiler/blob/master/examples/haste-app/haste-app.hs  ? I have it working ... but I read the code, and I'm just like "WTF .... HOW DOES THIS WORK" ?
00:16:47 <lericson_> i feel like 99% of #haskell activity is people asking "wtf how does this work"
00:16:48 <lericson_> [] :: * -> *
00:16:52 <lericson_> ops
00:16:53 <trap_exit> it's not clear to me at all how the server / client are talking to each other and how ... all this magic works
00:17:18 <trap_exit> lericson_ : are you looking for ops, or saying "oops" ?
00:17:42 <lericson_> saying oops as i accidentally pasted the kind of []
00:18:19 <Krautman> Come to think of it, Haskell not being a reflective language is a real plus here
00:18:57 <Krautman> You can just have the same constructs on the value level as the type level, and they'll never interfere
00:20:20 <srhb> trap_exit: Well, you'd need to look up some of those functions to see what goes on behind the scenes
00:21:14 <trap_exit> arhb: nah, i'm goign to study https://github.com/valderman/haste-compiler/blob/master/examples/chatbox/chatbox.hs first
00:22:10 <Hafydd> What is with that -- |?
00:22:51 <srhb> Layout? I guess.
00:22:58 <trap_exit> i'm living in an apartment where turning on my printer causes lights to flicker
00:23:01 <trap_exit> this is not good
00:23:07 <Hafydd> "Layout"?
00:23:30 <Krautman> Your printer draws a higher peak current that the lights?
00:28:54 <sgronblo> Wait, what is the connection/difference between Reader and MonadReader?
00:29:23 <trap_exit> omg
00:29:27 <trap_exit> haste is brilliant
00:30:42 <trap_exit> is hackage down?
00:30:46 <trap_exit> i'm getting 50s all over the place
00:30:50 <trap_exit> 503s
00:30:55 <sgronblo> me too
00:30:58 <WraithM> Yeah, I see a 503 here too
00:31:02 <wavewave> sgronblo: Reader is a type and MonadReader is a type class.
00:31:02 <WraithM> It was down all day
00:31:04 <trap_exit> brb, writing an app to poll hackage 60 times a second to report when it's back up
00:31:04 <srhb> sgronblo: MonadReader is the typeclass relating to transformers, is it not?
00:31:21 <trap_exit> this is unfortunate, there goes my attempt at reading docs
00:31:49 <WraithM> If you need docs, you could use FP Complete's hackage thing
00:32:28 <trap_exit> i will have to install it when hackage gets back up
00:33:00 <wavewave> sgronblo: MonadReader allows you to 'ask' at any level of monad transformer stack which has ReaderT component
00:33:00 <WraithM> https://www.fpcomplete.com/hoogle
00:33:08 <WraithM> trap_exit: That'll give you docs
00:33:17 <sgronblo> wavewave: ah right
00:33:22 <trap_exit> WraithM: ah, did not know it was a separate site; thanks!
00:33:27 <WraithM> Yep!
00:33:54 <WraithM> I don't think it has every package from hackage. They sorta curate the packages for stable compatible stuff.
00:34:48 * hackagebot antisplice 0.17.0.2 - An engine for text-based dungeons.  http://hackage.haskell.org/package/antisplice-0.17.0.2 (implementation)
00:34:50 * hackagebot ironforge 0.1.0.33 - A technical demo for Antisplice.  http://hackage.haskell.org/package/ironforge-0.1.0.33 (implementation)
00:34:52 * hackagebot data-interval 0.6.0 - Interval arithmetic for both open and closed intervals  http://hackage.haskell.org/package/data-interval-0.6.0 (MasahiroSakai)
00:34:54 * hackagebot language-c-inline 0.7.6.0 - Inline C & Objective-C code in Haskell for language interoperability  http://hackage.haskell.org/package/language-c-inline-0.7.6.0 (ManuelChakravarty)
00:34:56 * hackagebot lss 0.1.0.0 - Lexical Style Sheets - a language for writing styles that is focused around lexical (ie, static) scoping and re-use of large components.  http://hackage.haskell.org/package/lss-0.1.0.0 (DanielPatterson)
00:35:09 <WraithM> trap_exit: Speak of the devil, hackage is back up
00:35:33 <trap_exit> erveryone; here's your change to cabal install what you need :-)
00:36:12 <srhb> WraithM: It's up and down since yesterday
00:36:47 <trap_exit> it's dying half way throuhgmy docs reading
00:36:55 <trap_exit> screw this, I'm going to just read the *.hs files instead
00:39:58 * hackagebot snaplet-lss 0.1.0.0 - Lexical Style Sheets - Snap Web Framework adaptor.  http://hackage.haskell.org/package/snaplet-lss-0.1.0.0 (DanielPatterson)
00:40:00 * hackagebot irc-ctcp 0.1.0.0 - A CTCP encoding and decoding library for IRC clients.  http://hackage.haskell.org/package/irc-ctcp-0.1.0.0 (barrucadu)
00:40:02 * hackagebot irc-ctcp 0.1.1.0 - A CTCP encoding and decoding library for IRC clients.  http://hackage.haskell.org/package/irc-ctcp-0.1.1.0 (barrucadu)
00:40:04 * hackagebot irc-ctcp 0.1.2.0 - A CTCP encoding and decoding library for IRC clients.  http://hackage.haskell.org/package/irc-ctcp-0.1.2.0 (barrucadu)
00:40:06 <statusbot> Status update: The hackage build daemon has caused a massive load spike on the host virtualization system for haskell.org. We've stopped the process for now, meaning builds are stopped - restoring almost all operational capabilities in the mean time. We're still investigating/monitoring the situation. -- http://status.haskell.org
00:40:06 * hackagebot irc-ctcp 0.1.2.1 - A CTCP encoding and decoding library for IRC clients.  http://hackage.haskell.org/package/irc-ctcp-0.1.2.1 (barrucadu)
00:40:21 <remdezx> Hello! When using ghc-api, in GhcMonad Is it safe to clean `ic_instances` to redefine declared instances on runtime? See code snippet: http://lpaste.net/110544
00:44:13 <Twey> Is there a typeclass for things like UTCTime, that support addition and subtraction with a different type?
00:45:08 * hackagebot scion-browser 0.3.3 - Command-line interface for browsing and searching packages documentation  http://hackage.haskell.org/package/scion-browser-0.3.3 (JeanPhilippeMoresmau)
00:45:10 * hackagebot fay 0.20.1.4 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.20.1.4 (AdamBergmark)
00:45:12 * hackagebot antagonist 0.1.0.22 - A web interface to Antisplice dungeons.  http://hackage.haskell.org/package/antagonist-0.1.0.22 (implementation)
00:45:14 * hackagebot tidal 0.4.11 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.4.11 (AlexMcLean)
00:45:16 * hackagebot tidal-vis 0.1.6 - Visual rendering for Tidal patterns  http://hackage.haskell.org/package/tidal-vis-0.1.6 (AlexMcLean)
00:45:44 <AbigailBuccaneer> Twey, "addition" as in (+)?
00:45:54 <Twey> AbigailBuccaneer: As in addUTCTime
00:46:07 <Twey> (and diffUTCTime)
00:48:41 <AbigailBuccaneer> Twey, i don't know if there's a typeclass, but duration is conceptually the derivative of UTCTime
00:50:18 * hackagebot MonadRandom 0.3 - Random-number generation monad.  http://hackage.haskell.org/package/MonadRandom-0.3 (BrentYorgey)
00:50:20 * hackagebot tagstream-conduit 0.5.5.2 - streamlined html tag parser  http://hackage.haskell.org/package/tagstream-conduit-0.5.5.2 (YiHuang)
00:50:22 * hackagebot hs-php-session 0.0.9.0 - PHP session and values serialization  http://hackage.haskell.org/package/hs-php-session-0.0.9.0 (elblake)
00:50:24 * hackagebot tagstream-conduit 0.5.5.3 - streamlined html tag parser  http://hackage.haskell.org/package/tagstream-conduit-0.5.5.3 (YiHuang)
00:50:26 * hackagebot hspec-wai 0.4.0 - Experimental Hspec support for testing WAI applications (depends on hspec2!)  http://hackage.haskell.org/package/hspec-wai-0.4.0 (SimonHengel)
01:10:23 * hackagebot compdata 0.7.0.2 - Compositional Data Types  http://hackage.haskell.org/package/compdata-0.7.0.2 (PatrickBahr)
01:13:29 <osa1_> is hackage down??
01:14:14 <chrisdotcode> osa1_: yup
01:16:55 <osa1__> any mirrors?
01:18:50 <alpounet> osa1: http://hdiff.luite.com/
01:18:56 <alpounet> see instructions there
01:20:24 * hackagebot base-prelude 0.1.4 - The most complete prelude formed from only the "base" package  http://hackage.haskell.org/package/base-prelude-0.1.4 (NikitaVolkov)
01:24:52 <bernalex> what does "Exposed modules use unallocated top-level names" really mean? it's from hackage
01:25:24 * hackagebot plailude 0.3.0 - plaimi's prelude  http://hackage.haskell.org/package/plailude-0.3.0 (alexander)
01:26:59 <sgronblo> Sometimes it would be nice to know someone IRL who was better at Haskell than me who could do some mentoring
01:29:18 <AbigailBuccaneer> sgronblo, hang out in functional programming bars. they must surely exist, right?
01:29:44 <Enigmagic> AbigailBuccaneer: they exist in Gothenberg for a few more days ;-)
01:29:47 <bernalex> sgronblo: having someone on IRC works well too
01:30:25 * hackagebot generic-aeson 0.2.0.0 - Derivation of Aeson instances using GHC generics.  http://hackage.haskell.org/package/generic-aeson-0.2.0.0 (AdamBergmark)
01:30:35 <bernalex> sgronblo: you'll find that most haskellers are really geeky people who get ridiculously excited and ecstatic to talk about haskell-y things.
01:31:26 <sgronblo> bernalex: yeah but its not really the same
01:32:10 <sgronblo> i know many people who are curious. but even though i am still kind of a noob i dont know anyone who is better than me.
01:34:20 <sgronblo> whee, i think i finally kind of got the basics of the reader monad now
01:34:47 <bernalex> sgronblo: protip: don't do a master thesis at a school where you're the closest thing to a haskell expert :-P
01:34:51 <sgronblo> at least i was able to work my way through the calc_isCountCorrect example :)
01:35:09 <sgronblo> why?
01:35:16 <sgronblo> so ronery?
01:35:25 * hackagebot json-schema 0.7.0.0 - Types and type classes for defining JSON schemas.  http://hackage.haskell.org/package/json-schema-0.7.0.0 (AdamBergmark)
01:36:02 <bernalex> sgronblo: no but when nobody knows better than you, it's hard to improve and get help. even for things like figuring out what direction to take the thesis etc.
01:38:01 <sgronblo> bernalex: yeah thats kind of the situation im facing, except less serious because atm i'm only learning haskell because I'm very interested.
01:39:04 <trap_exit> luite: !
01:39:06 <bernalex> sgronblo: personally, shutting myself out from the outside world while reading LYAH was a nice introduction. next up, various people I knew on IRC mentored me. :-]
01:40:22 <iamanoob> Hi guys :) I heard that Haskell is a hard programming language to learn... instead i should learn Rust/Go/Nimrod... is that true my friends? ^_^
01:40:38 <bernalex> iamanoob: not really.
01:40:43 <sgronblo> i would have to agree its a quite hard language to learn, although many will disagree with me
01:40:49 <bernalex> iamanoob: do you know any programming languages already?
01:40:54 <iamanoob> yep, python.
01:41:04 <bjz> iamanoob: learnyouahaskell.com
01:41:15 <bergmark> iamanoob: hard to learn doesn't mean hard to use
01:41:18 <bernalex> iamanoob: OK then other non-functional languages will be easier to learn initially, because they are more similar.
01:41:38 <trap_exit> haskell was hard to learn
01:41:45 <trap_exit> until I tried to write a large scale prog in clojure
01:41:48 <trap_exit> and was like WTF ... I wnat types
01:41:51 <trap_exit> and then haskell was very easy to learn
01:41:56 <iamanoob> Yep, i tried Go and got instantly a little Guess game... but in Haskell i could'nt even create a little loop...
01:41:59 <bjz> iamanoob: often folks say that learning Rust helps them to learn Haskell
01:42:02 <bernalex> iamanoob: but once you get past the whole "oh, this isn't imperative at all", and learn to think in a functional way, it's not especially difficult.
01:42:08 <bernalex> iulian: haskell doesn't have loops lol
01:42:23 <trap_exit> haskell has loops
01:42:25 <trap_exit> it's called recursion
01:42:41 <ski> recursion generalize iteration
01:42:42 <bernalex> iamanoob: so the problem with learning haskell for people who know e.g. python is because they expect programming to work in this specific imperative way, which we try to avoid in haskell.
01:42:48 <sgronblo> i think swift will also be a good stepping stone towards haskell adoption
01:42:59 <trap_exit> sgronblo: I agree
01:43:02 <bjz> sgronblo: yeah, I agree
01:43:02 <sgronblo> yeah if you know python i think you are in for a hard climb
01:43:05 <bernalex> iamanoob: so the initial stuff will be hard, because you'll have to unlearn things.
01:43:12 <trap_exit> was trying swift earlier and was like "this feels like sorta-baby-haskell but I can write ios apps"
01:43:17 <ski> iamanoob : it's probably easier to learn haskell if you don't know any imperative programming language
01:43:25 <bernalex> iamanoob: but then... at some point, you just get it. and you might find that you'll learn a lot more advanced stuff than you ever did in python.
01:43:29 <sgronblo> haskell with a high emphasis on abstraction + mathy concepts + purity
01:43:38 <iamanoob> oh god :) thanks guys :)
01:43:51 <sgronblo> i think most people are more familiar with thinking about algorithms in terms of "first i do this, then i do that"
01:43:52 <bjz> sgronblo: both Swift and Rust make the transition easier. They also make you realise just how elegant and conscise Haskell is.
01:44:01 <t7> "Haskell is useless"
01:44:01 <bernalex> iamanoob: haskell isn't inherently a steeper learning curve than e.g. python. it's just that the learning never stops. there's always something new and cool to learn. :-]
01:44:05 <sgronblo> instead of how can i define an expression that evaluates to the required answer
01:44:46 <ski> sgronblo : recursion is naturally occuring in human language, though
01:44:49 <bernalex> t7: yeah ideally people who learn haskell should not do any explicit IO, and just use GHCI I think, heh.
01:45:00 <sgronblo> ski: elaborate please :)
01:45:42 <ski> sgronblo : a noun phrase can include a relative phrase which can include new noun phrases that ...
01:46:29 <iamanoob> bernalex: nice :) that sounds good. i will read my way through the book ;) lets see. thanks for the link!
01:46:39 <ski> sgronblo : "the cat which the dog chased ate the rat hiding under the house which johhny owned", &c.
01:47:57 <hyPiRion> or just noun := adjective noun | actual_noun
01:50:27 * hackagebot rest-gen 0.15.0.2 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.15.0.2 (AdamBergmark)
01:50:29 * hackagebot rest-core 0.32 - Rest API library.  http://hackage.haskell.org/package/rest-core-0.32 (AdamBergmark)
01:53:24 <iamanoob> can i cross-compile in haskell as easy as in go?
01:53:54 <Lowl3v3l> iamanoob, it is possible to set up ghc as a cross compiler
01:54:19 <Lowl3v3l> iamanoob, but one warnung : you cannot set ghc up as a canadian cross in one step as you could with gcc
01:54:38 <iamanoob> Lowl3v3l: so lets say i'm on windows... i can compile to a macosx target ?
01:55:18 <Lowl3v3l> i don't know about osx enough to tell you.... and building a cross compiler on windows is hell ;)
01:55:27 * hackagebot rest-types 1.10.2 - Silk Rest Framework Types  http://hackage.haskell.org/package/rest-types-1.10.2 (AdamBergmark)
01:55:29 * hackagebot rest-stringmap 0.2.0.2 - Maps with stringy keys that can be transcoded to JSON and XML.  http://hackage.haskell.org/package/rest-stringmap-0.2.0.2 (AdamBergmark)
01:55:31 * hackagebot rest-example 0.1.0.2 - Example project for rest  http://hackage.haskell.org/package/rest-example-0.1.0.2 (AdamBergmark)
01:55:33 <latk> I'm attempting to set up ghc/cabal/etc on a fresh ubuntu box, and believe I have done so. When I cabal install --dependencies-only one of my packages, I get an error about ghc-7.8.3 likely being broken by reinstalls. Why ?
01:55:42 <iamanoob> Lowl3v3l: ouch :( okay. thanks :))
01:56:09 <Lowl3v3l> iamanoob, the problem there is totally one-sided a windows problem
01:59:40 <latk> I even get this message about breaking ghc when I install in a sandbox :s
01:59:44 <latk> what gives :(
02:06:17 <supki> latk: because the installation plan reinstalls a dependency of ghc api package
02:06:23 <supki> most likely transformers
02:06:42 <supki> you can safely ignore it if you do not use ghc api
02:09:54 <sgronblo> You can make kinds instances of typeclasses?
02:09:58 <tibbe> do we have a: newtype Fix f = In { out :: f (Fix f) } in base somewhere?
02:10:26 <tibbe> (hoogle doesn’t give anything)
02:10:36 <Enigmagic> i think it's in transformers?
02:11:01 <sgronblo> oh wait, types have a kind?
02:11:52 <bernalex> sgronblo: hm? kinds are for types what types are for values
02:12:05 <bernalex> sgronblo: Just 3 is a value. Maybe Int is its type. * is its kind.
02:12:34 <bernalex> sgronblo: Int has kind *. Maybe has kind * -> *. which means it cannot be a value by itself. you can't have a function be Int -> Maybe -> Int.
02:13:00 <sgronblo> well that means that my first question was completely confused
02:13:13 <sgronblo> i had mixed up my concepts
02:13:29 <bernalex> sgronblo: Int -> Int means that you have a function that takes an Int and returns an Int. * -> * means you have a kind that takes a type with kind * and returns a type with kind *.
02:13:45 <bernalex> sgronblo: Maybe is * -> *. Int is *. so if we give Int to Maybe, we get Maybe Int with kind *.
02:13:50 <bernalex> sgronblo: hope that makes sense. chew on it for a while.
02:14:57 <sgronblo> Yeah yeah this makes complete sense
02:15:24 <sgronblo> But for a moment I was confusing myself that only thing with kind * are types
02:15:30 * hackagebot multipart 0.1.2 - HTTP multipart split out of the cgi package  http://hackage.haskell.org/package/multipart-0.1.2 (AdamBergmark)
02:15:44 <bernalex> sgronblo: that's sort of true. ish. :-P Maybe by itself isn't a type, right. Maybe Int is a type.
02:19:18 <bmuk> Hey everyone, I am tidying up my config files, and decided to follow this guide - http://tim.dysinger.net/posts/2014-02-18-haskell-with-emacs.html for my emacs. When I go to a haskell file, emacs says ghc-mod is not found, but I know I have installed it and am able to run it from the command line.
02:20:05 <bergmark> bmuk: it needs to be in emacs' path as well
02:21:02 <bmuk> bergmark: That's probably what the problem is. Though I would think el-get would set that up
02:21:03 <bergmark> check (getenv "PATH")
02:22:44 <sgronblo> bernalex: really? what is maybe by itself then?
02:23:18 <bmuk> aha. Thank you bergmark++ I should have realized
02:23:20 <sgronblo> I was just checking LYAH a bit which seemed to be using language that indicated that Maybe was a type with kind * -> *
02:23:21 <bernalex> sgronblo: I guess technically it is a type. you just can't make any value of type Maybe.
02:23:53 <nexx> it is a type constructor
02:24:24 <Peaker> Is anyone following haskell-libs?  I am wondering if my suggestion to have uninterruptibleMask on cleanup handlers is being understood, given the replies that seem to repeat the same misunderstandings (e.g: about withMVar)
02:25:21 <sgronblo> Is something with kind * -> * -> * then a type constructor constructor?
02:26:21 <bernalex> sgronblo: ordinary types are *, and type constructors are P -> Q, where P & Q are kinds, e.g. *.
02:26:27 <bernalex> sgronblo: so, yes.
02:27:03 <nexx> "A type constructor may have zero or more arguments" http://www.haskell.org/haskellwiki/Constructor#Type_constructor
02:30:54 <sgronblo> Ah so even a type is technically a type constructor
02:31:46 <nexx> I guess if you would parially apply a type constructor you could name it a type constructor constructor
02:32:01 * ski would say `Either Integer' is not a type constructor, but still a type function
02:32:29 <ski> (otoh, i'd say `Bool' is a type constructor, but not a type function)
02:32:58 <nexx> sgronblo that part is also new to me :) but it seems ok to define it like that
02:33:39 <bernalex> sgronblo: I guess technically all lhs of adts are type constructors
02:34:19 <bernalex> ski: data Bool = True | False -- lhs is the type constructor, rhs are value constructors. technically.
02:34:51 <bernalex> but nullary type & data constructors are usually just called types and values/constants
02:35:15 <bernalex> uhm ski that was for sgronblo but ok
02:50:45 <bernalex> > pure <*> map (+25) $ [0..10]
02:50:47 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10]
02:53:18 <AbigailBuccaneer> :t (pure <*> map (+25))
02:53:19 <lambdabot> Num b => [b] -> [b]
02:54:12 <bernalex> :t (pure <*>)
02:54:13 <lambdabot> (a1 -> a) -> a1 -> a1
02:54:13 <bernalex> :-]
02:54:46 <bernalex> > pure <*> head $ [0..10]
02:54:47 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10]
03:03:32 <adas> :t pure
03:03:33 <lambdabot> Applicative f => a -> f a
03:06:10 * hackagebot friday 0.1.5 - A functionnal image processing library for Haskell.  http://hackage.haskell.org/package/friday-0.1.5 (RaphaelJavaux)
03:16:14 <bmuk> What is the difference between hayoo and hoogle?
03:22:02 <Jonhy-lembrouill> Hello
03:22:06 <gilligan-> hi
03:22:11 <Jonhy-lembrouill> What's the language spoken?
03:22:18 <Jonhy-lembrouill> Is it merly english ?
03:22:22 <Jonhy-lembrouill> *merely
03:22:27 <adas> in haskell, the infix functions with higher "precedence numbers" has higher precedence right?
03:22:33 <Kinnison> Jonhy-lembrouill: here? mostly English, yes.
03:22:40 <Jonhy-lembrouill> thx Kinnison
03:22:52 <Kinnison> Jonhy-lembrouill: Some of us can cope with French or German if it's clearer for you to ask your question in those languages
03:22:56 <Jonhy-lembrouill> And what's the general topic ? Hacking I assume
03:22:58 <Kinnison> Jonhy-lembrouill: but the reply is likely to be in English
03:23:10 <Kinnison> The general topic is Haskell :-)
03:23:23 <Jonhy-lembrouill> That's alright I speak french and english, so I should figure it out :)
03:23:39 <Jonhy-lembrouill> Haskell, what does that mean ? I don't know that
03:25:20 <Kinnison> Well, start at www.haskell.org and go from there
03:25:24 <Kinnison> :-)
03:25:27 <HENK29933> did someone already mentioned haskell.org is slow? ;-)
03:25:33 <HENK29933> sorry
03:26:09 <hyPiRion> HENK29933: it looks down from here actually
03:26:11 <gilligan-> Jonhy-lembrouill, ehrm..how did you end up in this channel?
03:27:10 <Jonhy-lembrouill> gilligan- why is that so ? are you the gestapo ?
03:27:12 <Jonhy-lembrouill> haha
03:27:23 <gilligan-> ...
03:27:55 <Jonhy-lembrouill> That was a joke, I ended here 'cause I was lookin' for other irc servers than the one I was on
03:28:08 <Jonhy-lembrouill> And your chan is on the top of the chan list
03:28:30 <sivteck> Jonhy-lembrouill, haskell is a general purpose programming language
03:28:38 <Jonhy-lembrouill> So I tried it, 'cause it hit me when I read the topic, or at least the first word
03:28:44 <sivteck> Jonhy-lembrouill, you can use it to make your computer do menial jobs
03:29:08 <Jonhy-lembrouill> Ohhhhh, I understand now !
03:29:16 <Jonhy-lembrouill> I just went on the website, thx !
03:29:22 <Kinnison> :-)
03:29:34 <Jonhy-lembrouill> But since I know nothing about programming, I'm on a bad start ^^
03:29:52 <sivteck> Jonhy-lembrouill, check out learnyouahaskell.com
03:29:57 <sivteck> its a good read
03:30:58 <Jonhy-lembrouill> Alright I'll try it !
03:32:08 <solarus> http://tryhaskell.org might be a good start also
03:32:23 <adas> pure <*> head $ [1,2] <- how does that work?
03:34:04 <hopnotch> in general, when would you not prefer newtype to type when possible?
03:35:15 <b_jonas> adas: I think the <*> is in the list monad there, let's check
03:35:52 <b_jonas> > pure <*> head $ [1,2]
03:35:53 <lambdabot>  [1,2]
03:36:03 <b_jonas> > liftM pure head $ [1,2]
03:36:05 <lambdabot>  No instance for (GHC.Show.Show (f0 t0))
03:36:05 <lambdabot>    arising from a use of ‘M744105898485146928828310.show_M7441058984851469288...
03:36:05 <lambdabot>  The type variables ‘f0’, ‘t0’ are ambiguous
03:36:05 <lambdabot>  Note: there are several potential instances:
03:36:05 <lambdabot>    instance [safe] GHC.Show.Show a =>
03:39:11 <adas> i got it
03:39:38 <adas> reason i was having trouble understanding that was because of wrong evaluation order
03:44:27 <adas> i think the functor here in this case is the function itself and not the list
03:47:57 <solarus> > pure <*> (undefined :: [a] -> a) $ [1,2,3]
03:47:59 <lambdabot>  [1,2,3]
03:53:41 <Krautman> Could anyone recommend me a few good text editors for Haskell?
03:54:39 <rom1504> I guess vim
03:55:04 <Krautman> I've tried that one already, really didn't like it at all
03:55:07 <Krautman> Just too much clutter
03:55:22 <int-e> vim has too much clutter?!
03:56:04 <Krautman> I'm really looking for a lightweight editor
03:56:13 <Krautman> Vim was lightweight on the computer, sure
03:56:27 <Krautman> But it was like bringing a gun to a fistfight
03:57:39 <sivteck> There's atom/lighttable/sublime/cat/sed but nothing beats vim/emacs o_o
03:58:19 <int-e> Krautman: http://www.haskell.org/haskellwiki/Editors ... pick any you like?
03:58:33 <Krautman> Alright, I haven't heard of atom or lighttable before
03:58:39 <Krautman> I'll take a look at those
03:59:15 <Krautman> And I've looked at the Haskell.org list as well for that reason, but alas :(
03:59:37 <osfameron> lighttable sounds like it's brilliant-but-weird.  Bret Victor is quite inspiring
04:00:22 <Krautman> Lighttable is the thing I'm trying to avoid, but Atom looks very promising
04:00:37 <Krautman> I'm basically looking for notepad minus the typical flaws ;)
04:00:55 <osfameron> I've not heard of atom
04:01:23 <holo> hi
04:01:36 <Krautman> Good day
04:02:03 <holo> I'm going to learn haskell. Is there a book for functional programmers?
04:02:10 <osfameron> oh, atom.io.  I wasn't taken with the description
04:02:40 <Krautman> Plenty of books around, the staple would be Leanr You A Haskell
04:02:44 <Krautman> Learn*
04:03:38 <holo> Krautman, but Learn You A Haskell says this on their website: his guide is meant for people who have programmed already, _but have yet to try functional programming_.
04:04:15 <holo> Krautman, I'm already a functional programmer, so is this an adequate reading for me? thanks
04:07:19 <ArchStacker> cabal install pandoc
04:07:19 <ArchStacker> Resolving dependencies...
04:07:21 <ArchStacker> cabal: Codec.Compression.Zlib: premature end of compressed stream
04:07:23 <ArchStacker> How to solve it?
04:08:53 <RchrdB> ArchStacker, I have no clue, but I strongly suspect that "premature end of compressed stream" and "cabal" are the important parts of that message, and googling them brings up http://blog.pangyanhan.com/haskell/2014-03-04-how-to-solve-cabal-codec-compression-zlib-premature-end-of-compressed-stream-the-easy-but-time-consuming-way.html
04:09:27 <Kinnison> holo: I found LYAH to be good despite having a small amount of background in functional programming
04:09:43 <Kinnison> holo: Indeed LYAH helped me to consolidate my understanding of various aspects of FP
04:11:31 <holo> kinnison, krautman thanks. I'm going to try that one!
04:11:34 <ArchStacker> RchrdB: I have found it before.But it is interesting that for some packages,when this error occur,I can cabal install it again to solve it.But texmath is different from others
04:12:26 <Krautman> sivteck: Atom appears to be what I needed, thank you very much!
04:14:26 <sivteck> good!
04:15:30 <holo> great! haskell even has more job ads than clojure on stackoverflow careers
04:15:58 <Krautman> Sadly it came with 400 million packages pre-installed, but I'll have those out in no time ;)
04:16:19 <vanila> holo: only django python php in my area :(
04:17:56 <holo> vanilla, there is this fn.py library. it's awesome. it has persistent data structures, lazy seqs and lots of missing pieces from functools. did you try that? btw, I'm thinking of integrating it with Hy
04:20:57 <Krautman> ...atom won't work without its shovelware
04:21:13 <Krautman> Oh well, thanks for the help anyway.
04:22:24 <sivteck> you will not find a better editor than vim/emacs !
04:22:57 <Krautman> If I were running Linux, indeed not ;)
04:23:38 <Krautman> The windows version was a monstrosity
04:28:47 <bmuk> In emacs, how can I make it so that RET binds to shm/newline-indent like C-j does? I have tried define key but for some reason return is still defined as haskell-newline-and-indent?
04:29:14 <RedNifre> Hello there!
04:29:54 <Krakarn> RedNifre: hi!
04:30:06 <RedNifre> How can I run a command and get the output? e.g. "ls"
04:30:25 <doismellburning> RedNifre: System.Process (but for `ls`, there are better ways...)
04:30:42 <RedNifre> ls is just an example, I actually want to run "fortune" ;)
04:30:48 <doismellburning> hah
04:30:54 <RedNifre> Thanks, I'll look into System.Process
04:32:31 <hopnotch> i think lambdabot has a fortune plugin and it should be on github
04:32:51 <tuusj> I am experimenting with gtk2hs, and I can't figure out how to simply map a keybinding to an action. Nor can I find any working examples. But it seems that gtk itself has these mappings. So I am wondering if anybody knows whether this part of gtk hasn't been included in gtk2hs?
04:33:39 <pertl> I was pretty surprised that "let a = [1];   let a = 2:a " will create an infinite list (and not " 2:1:[] " ) . isn't let creating a new(!) binding of "a" concatenating the old value of "a" with "2" ?
04:34:17 <pertl> ^ inside ghci
04:34:33 <Krautman> pertl: You're actually shadowing your previous definition of a
04:34:53 <Krautman> So at that point, the more recent definition of a refers to itself
04:35:11 <pertl> so I could consider it kind of a "closure" ?
04:35:22 <pertl> referring to the _actual_ value of a
04:35:34 <Krautman> In a sense, perhaps, but Haskell isn't a strict language
04:35:49 <pertl> yep, just couldn't find a better word for it
04:35:58 <Krautman> The actual "value" of a is only constructed when you ask for it
04:36:06 <Krautman> If you try "take 10 a"
04:36:12 <Krautman> You'll only compute 10 elements
04:36:12 <pertl> lazy as always :-)
04:36:46 <pertl> so a strict evaluation kind of "let" would work as I expected?
04:36:53 <Krautman> If you want it in terms of closures, basically everything ends up being a closure
04:37:31 <Krautman> Do note 'basically'
04:37:41 <Krautman> I'm massively oversimplifying ;)
04:37:46 <pertl> lol
04:37:49 <pertl> actually this thing makes a lot of sense to me now (thinking about haskell's lazyness) :-)
04:38:02 <pertl> Krautman: thanks a lot for your time and helping :-)
04:38:26 <Krautman> A lot of people tend to stumble over lazy evaluation, so don't worry about it
04:39:13 <pertl> my favorite is " let fibs = 0:1:zipWith (+) fibs (tail fibs) " :-) love that one!
04:39:47 <Krautman> There's many ways to skin a cat ;)
04:40:00 <pertl> rofl
04:40:08 <Krautman> I actually have 0:scanl (+) 1 fibs
04:40:29 <Krautman> Just for the sake of dropping as many cons operations as I can
04:40:46 <pertl> cool expression!
04:40:57 <Krautman> Tip: Look up Haskell on Wikipedia in various languages
04:41:07 <pertl> did that
04:41:15 <Krautman> They're all different ;)
04:41:18 <pertl> haskell is the shortest and most expressive always
04:41:19 <RedNifre> Hm, System.Process looks complicated. How can I get what gets printed to std.out?
04:42:16 <RedNifre> I'm looking for something that is equivalent to ruby's f = `fortune` where the command "fortune" gets run and what it prints goes into the variable f
04:42:39 <Taneb> > let infixr f in x `f` y `f` z
04:42:40 <lambdabot>  <hint>:1:12: parse error on input ‘f’
04:42:46 <Taneb> > let infixr f in x `f` y `f` z :: Expr
04:42:47 <lambdabot>  <hint>:1:12: parse error on input ‘f’
04:42:53 <Taneb> :(
04:44:03 <ski> holo1 : may i ask which FPLs you've seen before ?
04:44:11 <Krautman> Taneb: You don't need an infix statement for  ` style infix
04:44:29 <ski> holo1 : if you have seen Clean or any of the MLs, you might try for the "Gentle Introduction to Haskell"
04:44:31 <Taneb> Krautman, I wanted it to be specifically infixr
04:44:44 <holo1> ski, just Clojure, Hy and camllight at school
04:45:15 <RedNifre> I mean, I was looking in System.Process for something that ends in -> IO String, but it looks I can only get the exit codes. I'm very new to Haskell so I might be missunderstanding all this.
04:45:18 <doismellburning> RedNifre: readProcess '/usr/bin/fortune' [] "" :: IO String
04:45:24 <ski> > let infixr `f` in x `f` y `f` z
04:45:25 <lambdabot>  The fixity declaration for ‘f’ lacks an accompanying binding
04:45:35 <ski> > let infixr `ff`; ff = f in x `ff` y `ff` z
04:45:37 <lambdabot>  Could not deduce (GHC.Show.Show t0) arising from a use of ‘ff’
04:45:37 <lambdabot>  from the context (Debug.SimpleReflect.Expr.FromExpr t)
04:45:37 <lambdabot>    bound by the inferred type of
04:45:37 <lambdabot>             it :: Debug.SimpleReflect.Expr.FromExpr t => t
04:45:37 <lambdabot>    at Top level
04:46:07 <doismellburning> > readProcess '/usr/bin/fortune' [] ""
04:46:10 <lambdabot>  <hint>:1:14: parse error on input ‘/’
04:46:23 <doismellburning> oops
04:46:30 <doismellburning> > readProcess "/usr/bin/fortune" [] ""
04:46:31 <lambdabot>  Not in scope: ‘readProcess’
04:46:33 <RedNifre> oh. Why is that not on the system.process hackage page? How would I find that function by myself?
04:46:35 <holo1> ski, so maybe camllight at school, a lot of years ago is insufficient background for ML
04:46:36 <doismellburning> (too much Puppet)
04:46:39 <Krautman> What about the 'system' function?
04:46:43 <doismellburning> RedNifre: it is - http://hackage.haskell.org/package/base-4.7.0.0/docs/System-IO.html#t:FilePath
04:46:54 <doismellburning> RedNifre: sorry wrong link; http://hackage.haskell.org/package/process-1.2.0.0/docs/System-Process.html
04:48:14 <RedNifre> Aha, the first duckduckgo hit brought me to process-1.0.0.0 instead of 1.2.0.0. Will check the version from now on. Thanks.
04:48:21 <ski> holo1 : perhaps
04:54:35 * hackagebot limp-cbc 0.2.8.6 - bindings for integer linear programming solver Coin/CBC  http://hackage.haskell.org/package/limp-cbc-0.2.8.6 (amosrobinson)
05:05:36 <gilligan-> meh..haskell.org still seems super slow
05:08:32 <Krautman> Is there any way to load a function an instance after a call to loadLibrary?
05:08:44 <Krautman> function from* an instance
05:11:05 <Cale> Krautman: I'm confused about what your question means.
05:11:13 <Cale> What library is loadLibrary from?
05:12:00 <Krautman> loadLibrary is from System.Win32
05:12:23 <Krautman> System.Win32.DLL, sorry
05:14:04 <Cale> So that's really a windows API question I guess
05:14:05 <Cale> hm
05:15:08 <Krautman> Indeed, Windows doesn't seem to be popular with the Haskell community ;)
05:16:06 <Cale> I think the next thing you're meant to do, assuming the pointer isn't null, is to use getProcAddress on it
05:16:19 <Cale> The types look different, but really they're the same
05:17:13 <Krautman> getProcAddress doesn't seem to exist in the Haskell platform
05:17:20 <Krautman> http://www.haskell.org/ghc/docs/7.6-latest/html/libraries/Win32-2.3.0.0/System-Win32-DLL.html
05:17:31 <trap_exit> yo
05:17:33 <trap_exit> is there any good app for reading haskell code
05:17:34 <Krautman> That's where I stumbled upon loadLibrary
05:17:34 <trap_exit> on an ipad
05:17:46 <trap_exit> i want something that lets me view a bunch of *.hs files
05:17:48 <trap_exit> in color
05:19:44 <trap_exit> what's a good *.hs -> html converter?
05:19:50 <Cale> Krautman: Seems to be documented there
05:20:50 <DanielDiaz> trap_exit: hscolour?
05:20:51 <Cale> trap_exit: hm, what was that thing called again...
05:20:56 <Cale> yeah, hscolour
05:20:59 <superlinux-hp> درس 20 عن لغة هاسكل صار على الفرن... تابع قناتي على العنوان التالي:
05:20:59 <superlinux-hp> Lesson 20 of Haskell programming language tutorial series is in the oven now. Subscribe to my youtube channel:
05:20:59 <superlinux-hp> Http://youtube.com/user/ranixlb
05:21:15 <trap_exit> DanielDiaz: nice, thanks!
05:21:25 <superlinux-hp> I meant lesson 23
05:21:27 <superlinux-hp> sorry.
05:22:02 <Cale> superlinux-hp: :)
05:22:32 <superlinux-hp> Cale, ☺ hi.
05:23:16 <superlinux-hp> is any of you guys watching any episode of my haskell tutorials?
05:23:31 <superlinux-hp> I am following the wikibook.
05:24:06 <superlinux-hp> it looks good after reading it it long enough.
05:25:11 <humanoyd> Hey, when I'm trying to "cabal install something" in a sandbox, I get "Warning: The following packages are likely to be broken by the reinstalls" and a list of globally installed packages (pandoc related)...I thought with the use of sandboxes I wouldn't have to care about globally installed packages
05:29:07 <Cale> humanoyd: I'm not sure that cabal install <packagename> uses your sandbox in any way
05:29:48 <Cale> cabal install (i.e. just installing the package in the sandbox itself) will
05:30:09 <bennofs> humanoyd: is pandoc system-wide installed (via package manager) or user-wide via cabal itself?
05:30:29 <Cale> and if you want to install a bunch of dependencies, you can  cabal install --only-dependencies
05:30:43 <bennofs> Cale: it does use the sandbox iirc
05:30:44 <humanoyd> bennofs: via package manager (pacman on Arch Linux)
05:30:48 <Cale> bennofs: hm, okay
05:30:56 <RedNifre> Hm. So I want to convert a String to Text so I use pack. But I get the error that pack returns Data.Text.Internal.Text whereas I need T.Text. What does that mean, what is going on?
05:31:01 <bennofs> humanoyd: then all it says is that you won't be able to use pandoc together with the sandbox
05:31:12 <bennofs> humanoyd: globally installed packages cannot be ignored by current GHC versions
05:31:21 <bennofs> humanoyd: the sandbox only hides user-wide pkgs
05:31:33 <Cale> RedNifre: What's the import line for T?
05:31:48 <Cale> RedNifre: Perhaps it's complaining about the distinction between strict and lazy Text
05:31:56 <humanoyd> bennofs: so I should be fine with a --force-reinstalls?
05:32:30 <bennofs> humanoyd: i'm not sure
05:33:06 <Cale> humanoyd: Just make sure you're not sudoing anything, and the amount of damage you can do should be limited to your user's ~/.ghc anyway
05:33:18 <Cale> (even if it does evade the sandbox)
05:33:53 <RedNifre> Ah, yes, T is Data.Text.Lazy
05:33:56 <Krautman> Oh hey, getProcAddress worked out, thanks Cale ;)
05:34:03 <Cale> Krautman: cool
05:34:16 <Krautman> It was just a horrible mess on Windows' behalf
05:34:32 <RedNifre> Thanks, that solved the problem.
05:35:29 <humanoyd> bennofs: Cale: Thanks!
05:39:17 <RedNifre> If imperative real world programming is done by passing the world through monads, how can that still be functional when running code in parallel? Don't two parallel monad sequences share the same mutable world?
05:40:19 <deni> i have a function that's (a -> b -> c). but i have Maybe b. how to pass that to the function?
05:40:54 <deni> i feel like it would be easier if it was Maybe a and Maybe b but when i have just one param it's confusing
05:41:03 <vanila> deni, if f is the function and a :: a, b :: Maybe b then you can do   f a <$> b
05:41:04 <Krautman> deni: You could use flip on the function and then use fmap
05:41:12 <luite> RedNifre: it's an implementation detail to enforce correct ordering within the same thread
05:41:16 <vanila> :t \f a b -> f a <$> b
05:41:17 <lambdabot> Functor f => (t -> a -> b) -> t -> f a -> f b
05:41:26 <vanila> this gives you Maybe b as the result
05:41:31 <vanila> yeah it's fmap just as Krautman said
05:41:58 <luite> RedNifre: realworld doesn't have a runtime representation, it's a zero-size value, but it prevents unsound rewrites in the optimizer
05:42:29 <deni> Krautman: vanila tnx...checking it out
05:43:13 <Cale> RedNifre: That's not actually how things are done
05:43:26 <deni> Krautman: vanila actually i got the question wrong...it's 3 parameters a b and c...and i've got b (the middle one) wrapped in Maybe
05:44:09 <deni> Krautman: vanila so (a->b->c->d) and only b is wrapped in Maybe
05:44:24 <trap_exit> is it psosible for HsColour to rea da bunch of *.hs files
05:44:25 <vanila> f a <$> b <*> return c
05:44:27 <trap_exit> and generate separtate *.html files
05:44:30 <Cale> RedNifre: Well, okay, if you're looking at GHC's implementation of IO, you'll see some RealWorld stuff, but that's just hackery to let GHC's dependency analysis stand in as a mechanism for keeping the order of effects straight. GHC's implementation of IO uses impure functions.
05:44:38 <vanila> or f <$> return a <*> b <*> return c
05:44:50 <trap_exit> is it possible for HsColour to read a bunch of *.hs files, and generate a *.html file for each *.hs file, and give me a nice way to click throuhg the html files? I don't wnat a single html file as output
05:44:54 <vanila> or (\b -> f a b c) <$> b
05:45:22 <luite> GHC's implementation of pure fuctions uses impure functions :p
05:45:33 <Krautman> Here's a question to make a few people cry: Is there any way to invoke (as an IO) a function from its raw address?
05:45:48 <deni> vanila: Krautman tnx. got it.
05:45:54 <silver> well, I don't know how this implemented in GHC, but theoretically it can be done by classical means like locks, atomic updates etc.
05:46:01 <Cale> RedNifre: However, a better mental model for how IO works would be to imagine that IO values are some sort of data structure representation for what is to be done, and there's an interpreter for that in the runtime system churning through main and actually carrying out the effects described.
05:46:57 <Cale> e.g. in GADT syntax, you could write something like:
05:47:04 <Cale> data IO a where
05:47:09 <Cale>   ReturnIO :: a -> IO a
05:47:17 <Cale>   BindIO :: IO a -> (a -> IO b) -> IO b
05:47:22 <Cale>   GetChar :: IO Char
05:47:28 <Cale>   PutChar :: Char -> IO ()
05:47:33 <Cale>   etc. etc.
05:47:43 <RedNifre> something something lift?
05:48:52 <Cale> Well, you can define a Monad instance trivially there by taking ReturnIO to be the implementation for return and BindIO the implementation for (>>=), and that gets you fmap/liftM
05:49:18 <slomo> if i have a transformer stack with two readers, how can i use the ask of the inner monad?
05:49:23 <Cale> Of course, with this particular choice of representation, you'd have to be cautious about the monad laws
05:49:38 <luite> Krautman: it's a bit risky, but you'll probably want to make a StablePtr out of it and use things in RtsAPI
05:49:42 <Cale> But there are similar ones which would be automatically Monad instances (i.e. using free monads)
05:50:01 <Cale> slomo: Use lift
05:50:18 <luite> Krautman: rts_evalIO in partcicular
05:50:20 <Cale> slomo: lifting an appropriate number of times ought to work
05:50:31 <Cale> slomo: However, one would have to wonder why you're doing that
05:51:14 <RedNifre> I just don't understand how you can have pure programming that interfaces with the real world when you have parallelism.
05:51:16 <RedNifre> I mean, if you only have one thread, then it takes the world as input, performs some pure functions and outputs the new state of the world.
05:51:31 <RedNifre> But if you have two such threads in parallel that take time to execute, how can they possibly still act pure?
05:51:39 <Cale> This is just my personal taste, but I feel that using ReaderT is almost always a design mistake, and you'd usually be better off with plain function parameters.
05:51:57 <Cale> RedNifre: That's not actually how anything works
05:52:13 <Cale> RedNifre: It's just a crappy mental model which indeed doesn't work in the face of concurrency
05:52:28 <Jafet> Sometimes I use ReaderT when I plan for a design mistake (ie. it may turn out that a StateT is needed later)
05:53:15 <eikke__> Krautman: dunno from within haskell proper, but should work using a little C trampoline I guess...
05:53:19 <slomo> Cale: ah lift, not liftM... i was confused :) thanks! i'm doing that because i have some function that is called from inside a reader monad, wants to use its own reader with a differently typed environment... and then want to get fields from both environments
05:53:26 <Cale> But in any case, if you're using more than one ReaderT, you're almost certainly better off lumping them together into a single one
05:53:40 <RedNifre> But how about this: Say you have a function that reads a text file, reverses the text and writes it back to the file. Would that be pure given that it takes a world with a text file as input and outputs a world where the text file content is reversed?
05:54:09 <Cale> RedNifre: What is the argument to that function?
05:54:21 <Cale> In Haskell, that wouldn't be a function
05:54:25 <Cale> It would be an IO action
05:54:48 <Cale> Unless it's a function of the filename which produces an IO action, perhaps
05:55:08 <RedNifre> hmmm
05:55:11 <slomo> Cale: but i want to keep the second environment local to that function and not leak it to the outside
05:55:16 <trap_exit> this is kinda crazy
05:55:22 <trap_exit> but is there any shell written in haskell?
05:55:25 <Cale> The function which produces the action would be pure (given the same filename, it would always produce the same action, as you described it)
05:55:26 <trap_exit> http://www.yesodweb.com/blog/2012/03/shelly-for-shell-scripts seems sorta outdated
05:55:33 <eikke__> trap_exit: fish, afaik
05:55:37 <Cale> But execution of the action itself would not be pure
05:55:43 <deni> Anyone uses the hackage search extension for chrome here? And if so can anyone tell me if there's anything similar for firefox?
05:56:04 <Cale> slomo: okay
05:56:19 <eikke__> trap_exit: uh no, my bad
05:56:19 <eikke__> trap_exit: https://github.com/chrisdone/hell
05:56:26 <trap_exit> yeah
05:56:26 <trap_exit> fish haskell dod not bring up much
05:56:28 <Cale> slomo: Well, I suppose I don't know the whole context of what you're doing, it could for some reason be okay.
05:57:02 <Cale> slomo: But I tend to avoid bare monad transformers which haven't been newtyped, and ReaderT in particular is totally equivalent to just passing parameters around
05:57:20 <Cale> slomo: Usually the parameter passing is less noisy than all the lifting you have to do when using ReaderT
05:57:58 <slomo> Cale: yeah, that's what i'm doing now in the end as it's simpler :) was just curious how to solve it differently
05:58:40 <mo-> Hello
05:59:14 <RedNifre> okay, guess I'll read some more.
06:08:45 <Jafet> Haskell shell: main = forever $ handle (print :: SomeException -> IO ()) $ do (c:as) <- words <$> getLine; runProcess c as Nothing Nothing Nothing Nothing Nothing >>= waitForProcess
06:09:32 <mo-> I need to assemble an infinite list wrapped in an IO monad. Somehow I loose lazyness in my approach and I don't know why. Example code is at http://lpaste.net/110550 (16 lines). I would be very happy about some help here.
06:10:27 <Jafet> @src liftM2
06:10:27 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
06:10:31 <brycelane> how does cabal project aggregation work? (or does it?)
06:10:44 <bennofs> mo-: that is impossible
06:11:03 <bennofs> mo-: if it were possible, you could implement unsafePerformIO
06:11:20 <mo-> Hmm. Didn't see that.
06:11:39 <bennofs> mo-: assume I do list <- infList 3;
06:11:42 <brycelane> I'm looking at a github repo, the Charts repo, and it has a few sub projects that have a dependency among each other. I'm looking for some documentation for that configuration.
06:12:07 <bennofs> mo-: then you want that foo 1, foo 2, ... haven't been computed yet, right?
06:12:31 <mo-> I'd like to traverse this list until I find a certain element.
06:12:40 <bennofs> mo-: but then, I can pass (list !! 3) to pure code, and that pure code will then be the reason that foo 4 is executed!
06:13:05 <mo-> Hmmm.
06:13:28 <mo-> Thanks for the elaboration. Maybe it helps when I explain what I actually want to do.
06:14:07 <deni> there's a serach engine addon for hoogle for ff....cool
06:14:54 <mo-> the basic 'problem' is that most functions in System.Time need to be wrapped in IO. I want to create an infinite list, given a start CalendarTime, produces an infnite list of items holding some information about each day.
06:15:21 <mo-> for this, I need to something like incrementCalendar :: CalendarTime -> IO CalendarTime
06:16:19 <mo-> Now i'd like to write a function with signature CalendarTime -> [DayInfo]. But because of the IO wrapping it actually needs to be CalendarTime -> IO [DayInfo]
06:16:46 <doismellburning> mo-: where'd the IO come from?
06:17:03 <mo-> doismellburning: I don't understand, sorry
06:17:29 <doismellburning> mo-: why does it need to be `CalendarTime -> IO [DayInfo]`?
06:17:56 <mo-> doismellburning: because of the signature of incrementCalendar.
06:18:23 <doismellburning> mo-: ah, wasn't clear that you planned on using incrementCalendar in that function
06:18:24 <superlinux-hp> hi. what's the purpose of the deriving keyword?
06:18:30 <deni> what's the preffered way/lib to use for string formatting in haskell? (ie. so I don't do "http://example.com/url/" ++ "bla" but rather something like "http://example.com/{0}" % "bla"
06:18:36 <mo-> doismellburning: sorry, yes I want to. :)
06:18:40 <doismellburning> deni: don't do either of those ;)
06:18:50 <deni> doismellburning: educate me! :)
06:18:53 <doismellburning> deni: for _that_, the proper way is types
06:19:22 <deni> for url formatting you mean?
06:19:22 <doismellburning> deni: well, for EVERYTHING the proper way is types, just, sometimes there isn't a sufficiently expressive type system ;)
06:19:37 <doismellburning> deni: but for constructing URLs, you never want to treat them as "just a string"
06:19:38 <deni> yeah i'm getting that vibe :D
06:19:59 <doismellburning> deni: you want a URL object that maybe eventually ends up as a(n opaque) string
06:20:16 <doismellburning> deni: check out http://hackage.haskell.org/package/url-2.1/docs/Network-URL.html
06:20:40 <doismellburning> deni: I've actually found that Network.URI and Network.URL don't do everything I want them to in terms of manipulation, but they get you most of the way
06:21:42 <silver> superlinux-hp, automatic default implementation of type classes
06:21:56 <deni> doismellburning: checking it out now. tnx!
06:22:15 <superlinux-hp> silver, I am still at baby steps in haskell
06:22:41 <superlinux-hp> i have not reached type classes yet in the wikibook.
06:23:06 <deni> doismellburning: this is more for url encoding
06:23:11 <deni> doismellburning: i'm more just building a url path
06:23:58 <doismellburning> deni: sure
06:24:12 <doismellburning> deni: one of the things that I found missing ;)
06:24:14 <doismellburning> deni: http://hackage.haskell.org/package/network-uri-2.6.0.1/docs/Network-URI.html
06:26:36 <deni> doismellburning: tnx
06:26:51 <doismellburning> deni: (particularly `relativeTo` and `parseURI`)
06:27:33 <doismellburning> I wish more libraries like that had something akin to `parseDefinitelyIsAURI` that did the `fromJust` themselves
06:28:20 <dreams> hai
06:28:34 <dreams> I read that core is a second-order language, what does that mean anyway?
06:36:00 <ski> @tell RedNifre re concurrency, you might be interested in checking out "A Poor Man's Concurrency Monad" by Koen Claessen in 1993-01 at <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.8039>
06:36:00 <lambdabot> Consider it noted.
06:38:24 <hseg> Hi. I have a 2D array. Is there a simple way to convert it into a row-minor or column minor form? I need to do analyses on each column/row separately.
06:38:29 <deni> doismellburning: the example from there doesn't really work. "foo" `relativeTo` "http://bar.org/"
06:39:29 <hseg> Anything better than groupBy ((==) `on` fst) . assocs?
06:40:28 <doismellburning> deni: yes, you'll need to go via parseURI
06:42:09 <deni> doismellburning: parseURI "foo" will not work in that case
06:42:13 <deni> doismellburning: it will just return nothing
06:42:52 <doismellburning> deni: ugh
06:42:54 <doismellburning> deni: one moment
06:43:06 <deni> doismellburning: yeah this is a stupid problem to have.
06:43:10 <deni> XD
06:43:29 <doismellburning> deni: but yes you've hit my issues with Network.URI too
06:43:52 <doismellburning> I might sit down with some coffee + the RFCs and try to come up with something
06:44:14 <deni> doismellburning: that's why i want just simple string formatting
06:44:16 <doismellburning> deni: there is alas no blank uri
06:44:18 <deni> and i'm sure there's a simple way
06:44:28 <doismellburning> deni: yeah ok concatenate lists with ++
06:44:32 <doismellburning> life's too short :(
06:44:58 <deni> doismellburning: well something a notch up from that....
06:45:03 <deni> just plain old string formatting
06:45:10 <deni> unware that it's formatting an url is fine
06:45:30 <doismellburning> deni: http://hackage.haskell.org/package/base-4.7.0.1/docs/Text-Printf.html might dtrt
06:45:36 <doismellburning> but yeah, it's all grimness
06:46:24 <deni> doismellburning: printf yes
06:52:26 <levicampbell> Why doesn't cabal automatically fetch all package dependencies before building and installing everything?
06:53:58 <bennofs> levicampbell: it should iirc
06:54:10 <bennofs> levicampbell: or do you mean it should parallize downloading/building more?
06:55:37 <levicampbell> Hmm, maybe my version of cabal is out of date then.
06:55:46 <bennofs> levicampbell: what are you doing?
06:56:15 <levicampbell> I just finished installing Yesod.
06:57:40 <bennofs> levicampbell: and cabal install yesod didn't work for that?
06:58:22 <levicampbell> I think the problem was with my internet connection.
06:59:29 <deni> sigh...i really hate the String vs. Text difference
06:59:47 <deni> there isn't a programming languageu on this world that does this right
07:00:19 <Cale> deni: What in particular is causing you problems?
07:01:50 <deni> Cale: i have overloaded strings set...so the when I use literals i don't get String but rather IsString...which doesn't really work well with most of the functions i want to use
07:02:08 <deni> Cale: so then I can resort to casting...which is ugly
07:02:10 <Cale> Well, the IsString constraint is satisfied by String
07:02:32 <Cale> So if you use a literal in a place which demands a String, it should be interpreted correctly.
07:02:37 <deni> Cale: yes but s function is epexcint String...not IsString
07:02:44 <Cale> IsString isn't a type
07:02:48 <Cale> It's a type class
07:02:48 <deni> Cale: i know
07:02:55 <deni> sorry for the confustion
07:02:59 <deni> *confusion
07:03:10 <Cale> The function which is expecting a String should cause the String instance of IsString to be selected
07:03:24 <Cale> So you shouldn't need to write an explicit type signature even
07:03:31 <deni> all i know is that i can't do for instance "asd" ++ "asd"
07:03:44 <Cale> You ought to be able to
07:04:03 <Cale> At least, if it's known that this is a String
07:04:03 <eacameron1> So a "safe" C FFI requires that the C code correctly handle interrupt signals?
07:04:48 <deni> Cale: http://dpaste.com/3KGVS2Z
07:05:06 <Cale> deni: Right, that's *just* at the ghci prompt
07:05:27 <Cale> deni: Because it doesn't have enough type information there to tell whether you want the result to be a String or Text, or what.
07:05:38 <deni> Cale: it happens in code as well
07:05:45 <deni> not for the exact example
07:05:47 <deni> but yes
07:06:13 <Cale> deni: It's possible, but much less likely that you'll lack the information about what type it needs to be.
07:06:15 <deni> Cale: one other thing i have is type synonyms like Something = String.
07:06:24 <deni> not sure how this should work as well
07:06:45 <Cale> Of course, if it bothers you, you can just turn OverloadedStrings off
07:07:02 <Cale> (I don't tend to use that extension myself.)
07:07:15 <deni> Cale: i'm not sure why it's recommended as a defacto default
07:07:19 <Cale> Type synonyms are transparent to everything
07:07:25 <deni> or atleast that's the vibe i'm getting
07:07:52 <Cale> I suppose if you're using lots of libraries where everything is Text rather than String, it saves you the trouble of explicitly applying pack to your literals.
07:08:07 <deni> Cale: so i shouldn't do :: Something -> Bool but rather :: IsString -> a -> Bool ?
07:08:19 <Cale> uhh
07:08:26 <Cale> Do you mean  IsString a => a -> Bool?
07:08:35 <deni> Cale: args..typo..yes
07:09:19 <Cale> Well, a meaningful function of that type isn't really possible
07:09:34 <Cale> IsString has only one method:  fromString :: (IsString a) => String -> a
07:09:58 <Cale> So if you know the type a has an instance of IsString, you can convert Strings *to* that type
07:09:59 <deni> Cale: I was thinking in the sense that I want my function for work either with Text or with String
07:10:27 <Cale> But then if you have no other information about what type it is, there's nothing more you could do.
07:11:01 <Cale> I suppose you could do something like  foo :: (IsString a, Eq a) => a -> Bool; foo x = fromString "hello" == x
07:12:25 <deni> Cale: i'm sorry i'm unclear how this works with type synonyms? for intance if i have type Endpoint = String. And a function (Endpoint -> URL) how can apply (printf "%s" "bla") to the first argument of that function
07:13:00 <deni> Cale: when printf is obviously giving me back a Text...and the function is expecting an Endpoint which is just a synonym for string?
07:13:06 <Cale> what?
07:13:17 <Cale> I didn't know printf could give you a Text
07:13:34 <fizbin> :t printf
07:13:35 <lambdabot> PrintfType r => String -> r
07:13:42 <Jafet> printf can return IO () too
07:13:45 <Jafet> It's the best
07:14:09 <deni> Cale: hmmm okay then i'm missing something
07:14:14 <Cale> I'm pretty sure it just does String, and IO ()
07:14:17 <Cale> (and function types)
07:14:19 <Jafet> Though, I don't see any Text instance
07:14:22 <Cale> yeah
07:14:32 <fizbin> Prelude Text.Printf> :info PrintfType
07:14:33 <fizbin> class PrintfType t where
07:14:33 <fizbin>   Text.Printf.spr :: String -> [Text.Printf.UPrintf] -> t
07:14:33 <fizbin>   	-- Defined in `Text.Printf'
07:14:33 <fizbin> instance [safe] IsChar c => PrintfType [c]
07:14:33 <fizbin>   -- Defined in `Text.Printf'
07:14:33 <fizbin> instance [safe] PrintfType (IO a) -- Defined in `Text.Printf'
07:14:34 <fizbin> instance [safe] (PrintfArg a, PrintfType r) => PrintfType (a -> r)
07:14:34 <fizbin>   -- Defined in `Text.Printf'
07:15:09 <Cale> deni: But yeah, if you have a type synonym like that, you can just replace any occurrence of Endpoint by String without changing the meaning of the program
07:15:51 <deni> Cale: but then i loose the semantic information that Endpoint is conveying to someone reading the type signature... :/
07:15:58 <Cale> Well, yes
07:16:14 <Cale> But as far as the compiler is concerned, they're identical
07:16:55 <Jafet> There is no semantic information, because it is equal to String
07:17:06 <Cale> (actually, I often find type synonyms to be unhelpful when I'm trying to work out how to use things, I'd prefer newtypes or nothing most of the time)
07:17:13 <Jafet> It's syntactical information
07:17:25 <deni> Jafet: there is to someone reading the code
07:17:25 <Cale> The one exception to that possibly being Lens
07:17:54 <fizbin> I'm puzzled by "instance [safe] PrintfType (IO a)"; does that mean that there's a PrintfType definition for (IO Text) ? If so, what does it return?
07:18:26 <Cale> fizbin: My GHC doesn't report that quite the same way
07:18:34 <Cale> I have: instance [safe] a ~ () => PrintfType (IO a)
07:18:55 <Cale> I'm not sure why it doesn't just say IO ()
07:19:41 <fizbin> Huh. Trying to use it I get:
07:19:49 <fizbin> *** Exception: PrintfType (IO a): result should not be used.
07:20:11 <geekosaur> fizbin, you can't use it that way
07:20:13 <geekosaur> it's IO ()
07:20:36 <Cale> fizbin: Weird
07:20:40 <geekosaur> what would IO Text mean in this case?
07:20:41 <Cale> fizbin: Which version of GHC is that?
07:20:51 <fizbin> Well, no, it isn't. Because, after all, it compiles.
07:20:55 <Jafet> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.7.0.1/src/Text-Printf.html#PrintfType
07:21:12 <fizbin> But apparently the "a" value is something like undefined, which you shouldn't ever try to evaluate.
07:21:29 <geekosaur> the IO instance assumes you want to actually do I/O
07:21:30 <fizbin> Prelude Text.Printf Data.Text> do {(a::Int) <- printf "%s" "12321"; putStrLn (show a)}
07:21:30 <fizbin> 12321*** Exception: PrintfType (IO a): result should not be used.
07:21:42 <geekosaur> it's not something you can abuse to get something like IO Text
07:21:47 <geekosaur> and again, what do you expect IO Text to mean there?
07:21:48 <fizbin> $ ghci --version
07:21:48 <fizbin> The Glorious Glasgow Haskell Compilation System, version 7.6.3
07:21:50 <Jafet> It's probably due to how HPrintfType is implemented.
07:22:05 <Cale> fizbin: Oh, okay, that's a bit old
07:22:27 <Cale> That problem is gone in GHC 7.8.2 at least
07:22:28 <geekosaur> the thing to keep in mind is that PrintfType is an awful hack
07:22:36 <fizbin> geekosaur: You're right, I don't expect a value, which is why it was really surprising to me that the static type was given as (IO a) and not as (IO ())
07:23:02 <Cale> geekosaur: It's still possible to have the instance of PrintfType for IO () instead (with FlexibleInstances)
07:23:04 <geekosaur> it's surprising to me as well but sounds like it's a fixed bug?
07:23:23 <geekosaur> yes. I'm not sure what is going on there unless the idea was to block other IO instances
07:23:42 <fizbin> Do you suppose this was done to make printf implementable without whatever language extension you need to say "instance MyClass (IO ())" ?
07:23:44 <Jafet> You shouldn't need FlexibleInstances for that
07:23:44 <Cale> Maybe the intention was to be Haskell 98 compatible
07:23:52 <Cale> Yes you do
07:23:58 <geekosaur> except ~ isn't Haskell 98
07:24:03 <fizbin> Right, FlexibleInstances.
07:24:10 <geekosaur> it *was* supposed to be Haskell98 compatible, yes
07:24:14 <fizbin> I can never keep my language extensions straight.
07:24:23 <Cale> Instance heads in H98 must consist of a type constructor applied to distinct type variables
07:24:26 <Jafet> Or maybe I'm spoiled by ghc too much to remember the medieval restrictions of h98
07:24:28 <fizbin> I just keep adding what the compiler tells me to add.
07:25:20 <fizbin> Huh. You know, there is a new haskell platform with a 7.8 ghc. I should upgrade.
07:25:31 <Cale> For example, you're not allowed to have an instance of a type class for String in H98.
07:25:39 <Cale> But you may have one for [a]
07:26:05 <Cale> (which then applies to String, because it's [Char])
07:26:50 <Jafet> Which then gets redirected to showList
07:27:13 <Cale> In the case of Show, yeah
07:27:40 <Jafet> Which is another hack
07:27:53 <Cale> Well, it's a reasonable one given the restriction
07:28:10 <Cale> Actually, in some ways that's better than using OverlappingInstances, I think
07:28:38 <Cale> It makes the instance resolution more straightforward.
07:28:57 <latk> i'm trying to install alex via cabal, and getting an error about haddock-interfaces being missing for primitive. What are haddock-interfaces, and how can I instsall them ?
07:30:50 <Jafet> I doubt anyone uses the IO instance anyway. Maybe if Kernighan and Ritchie had decided to use a more complicated example...
07:32:45 <hseg> How do I pretty-print a 2d array so that columns are aligned and the rows/columns are headed by their indexes?
07:32:55 <Jafet> Haddock links? primitive has no documentation, so your haddocks will not have links to its documentation. That is all.
07:33:24 <latk> Hm. It is failiing, I assumed this was why :s
07:33:28 <edlinde> In: toList :: Map k a -> [(k, a)] , is “Map” a data type?
07:33:38 <edlinde> if so, where can I see how its defined?
07:33:40 <latk> Jafet: Perhaps it fails for some other reason. Let me check.
07:34:03 <Jafet> @index Map
07:34:04 <lambdabot> Data.Map
07:35:06 <edlinde> so what is Map then?
07:35:25 <latk> Jafet: Yep, had messed up permissions so cabal couldn't write to .ghc.
07:35:31 <latk> Jafet: Thanks :)
07:35:34 <Jafet> Map is probably the type Data.Map.Map.
07:36:34 <edlinde> ok so its a type
07:36:47 <edlinde> just trying to understand types and typeclasses
07:37:12 <edlinde> so k and a I assume would be the type parameters yeah?
07:37:30 <fizbin> edlinde: Yes.
07:37:38 <edlinde> ok thanks
07:38:28 <fizbin> edlinde: If you want the full gory code, http://www.haskell.org/ghc/docs/latest/html/libraries/containers/src/Data-Map-Base.html#Map
07:38:56 <Jafet> It's not all that gory
07:39:46 <fizbin> True, but if you're just starting out it can be more confusing than the docs primarily because of how the code ends up being laid out vs. how you typically see it imported.
07:40:25 <edlinde> looks quite neat though
07:40:28 <edlinde> :)
07:42:06 <JacquesC> oops?
07:42:42 <dpwright> I'm reading this blog post about equational reasoning: http://www.haskellforall.com/2013/12/equational-reasoning.html
07:43:38 <dpwright> in which Tekmo suggests the following property for `sequence_`: sequence_ . (f <=< g) = (sequence_ . f) . (sequence_ . g)
07:43:38 <dpwright> or, pointfully, sequence_ (concatMap f (g x)) = sequence_ (f (sequence_ (g x)))
07:44:02 <Jafet> -- We do not use BangPatterns, because they are not in any standard and we want the compilers to be compiled by as many compilers as possible.
07:44:11 <Jafet> Yo dawg, someone likes compilers
07:44:26 <quchen> Jafet: Is that from Data.Map?
07:44:55 <Jafet> Linked above.
07:45:10 <dpwright> I'm trying to work through the proof, but I can't see how that can work unless f is a function expecting a monad as input... I think I may have just answered my own question :-!
07:45:13 <quchen> Kind of a silly comment, because using STRICT_X_OF_Y relies on CPP, which is also not standard Haskell
07:45:20 <quchen> And looks bad
07:46:21 <Peaker> Why is StackOverflow an async exception, that's maskable, and not a synchronous exception?
07:48:29 <dfeuer> quchen, CPP could always be run manually, but avoiding bang pattern because now-obsolete compilers couldn't handle them seems a bit silly.
07:48:37 <dpwright> ...no, I still don't get it
07:49:42 <dpwright> in concatMap f (g x), f must be "a -> [b]" and g must be "t -> [a]"
07:49:56 <latk> when I try to install my package via cabal, I get the message "cabal: The following packages are likely to be broken by the reinstalls: ghc-7.8.3 QuickCheck-2.7.6".
07:50:07 <latk> How can ghc be broken by a reinstall ?
07:50:18 <quchen> dfeuer: BangPatterns are also a very simple extension. I can see why you would want to avoid RankNTypes or DataKinds and so on.
07:51:08 <quchen> But I'm still betting on BangPatterns becoming standard in the next revision.
07:51:09 <dpwright> but in f (sequence_ (g x)), f must be "m () -> t" and g must be "a -> [m b]"
07:51:28 <Krautman> What would be the cleanest way of setting up ghci on startup?
07:51:41 <quchen> Krautman: "setting up"?
07:52:06 <Jafet> :t sequence . (?f >=> ?g)
07:52:07 <lambdabot> (?g::b -> [m a1], ?f::a -> [b], Monad m) => a -> m [a1]
07:52:10 <dpwright> sorry, sequence_ (f (sequence_ (g x))), so f must be "m () -> [m t]" I guess
07:52:28 <dpwright> ahhh, I think it's starting to come together...
07:53:18 <Jafet> :t sequenceA . (?f >=> ?g)
07:53:19 <lambdabot>     Not in scope: ‘sequenceA’
07:53:19 <lambdabot>     Perhaps you meant one of these:
07:53:19 <lambdabot>       ‘T.sequenceA’ (imported from Data.Traversable),
07:53:25 <Jafet> :t T.sequenceA . (?f >=> ?g)
07:53:26 <lambdabot> (?g::b -> t (f a1), ?f::a -> t b, Traversable t, Applicative f, Monad t) => a -> f (t a1)
07:54:18 <quchen> dpwright: You can also use `asTypeOf` to check how two types unify.
07:54:21 <quchen> :t \f g -> (sequence_ . (f <=< g)) `asTypeOf` ((sequence_ . f) . (sequence_ . g))
07:54:22 <lambdabot> (Monad m1, Monad m) => (m1 () -> [m a1]) -> (a -> [m1 ()]) -> a -> m ()
07:55:19 <Krautman> Oh wow. Only now did I find out to use /notice instead of /msg....
07:55:38 <quchen> You can also write in this channel directly.
07:55:58 <quchen> I'm not sure there's a good way to autoload stuff in GHCi.
07:56:26 <dpwright> quchen: thanks, that looks useful!
07:56:26 <quchen> You can load things in your ghci.conf, but the problem with that is that :r unloads it or something along those lines.
07:56:52 <Krautman> Well, what I have right now is the ghci.conf that switches directory to my preferred folder
07:57:01 <Krautman> And runs an 'autorun' script in there
07:57:10 <Krautman> And no, :r is handled just fine
07:57:28 <Krautman> It just seems a bit hackish to have ghci.conf run another autorun script
07:57:50 <Krautman> I'd expected there to be some :set autorun or something like that
07:58:36 <quchen> Maybe you can also invoke GHCi with command line parameters to load things? You could then write a small launcher script that executes it with the desired options
07:58:52 <slack1256> In "Open Type families are not modular" ezyang say at the end that we shouldn't use typeclasses for things like equality.
07:59:00 <slack1256> I don't understand what he meant by that.
07:59:16 <slack1256> I am thinking is not about the Eq class right?
07:59:20 <Krautman> Well, I usually start up GHCi from my command line, but that's sound advice for anyone else in my position ;)
07:59:57 <quchen> I meant to load your default modules via command line.
08:00:10 <quchen> ghci --with-module=Data.Text -- something like that
08:00:54 <Krautman> Yes, I know what you meant, but that beats the purpose up to what I have right now
08:01:25 <Krautman> Oh well, it's not a real problem, I was merely curious, thanks ;)
08:02:36 <nshepperd> slack1256: maybe talking about equality of types
08:03:56 <slack1256> nshepperd: Any concrete example I could look at?
08:06:40 <nshepperd> I don't know
08:06:41 <EmreY`> so is it true that you guys once convinced a guy who came to troll to learn haskell?
08:06:52 <carette> How do I hide all the join/quit messages?
08:07:27 <Sornaensis> yes, haskell is a very powerful religion
08:08:12 <slack1256> Although that has lead to people trying to troll #haskell because of the story
08:08:21 <Krautman> That is what convinced me to join here ;)
08:08:38 <cschneid> carette: that's very specific to the irc client you're using, look in the options menu :)
08:08:58 <EmreY`> look here carette, http://wiki.xkcd.com/irc/hide_join_part_messages#ERC
08:09:30 <Jafet> So is this, like, a metatroll
08:11:09 <carette> I am using the webchat client.  Google found many ways for me to do this on OTHER clients...
08:13:20 <Krautman> Hm, haskell.org is still slowing down.
08:16:03 <latk> what is the easiest way to remove all installed packages without destroying cabal etc ?
08:17:22 <Jafet> The easiest (and, in fact, only): rm ~/.ghc/xxx/package.conf.d
08:19:12 <latk> Jafet: I don't have to remove something from .cabal as well ?
08:23:46 <shapr> YAY HASKELL!
08:23:54 <shapr> Time for code!
08:24:20 <Krautman> That's the face of enthusiasm right there :D
08:28:08 <Krautman> Hm, I appear to have killed off the conversation.
08:30:57 <hamid> Krautman, nope. natural cause.
08:31:55 <lpvb_> carette: it's on the little icon in the top left under Options
08:32:28 <carette> lpvb_: found it, thanks.  Channel is much quieter now.
08:33:06 <Phillemann> Can anyone recommend a simple HTTP server library which is fairly low-level? I imagine getting a "raw" request object and being able to send, basically raw bytes and a status code back.
08:33:24 <RchrdB> Phillemann, WAI.
08:34:51 <cschneid> Phillemann: and/or snap-core & snap-server, it does similar I think.
08:35:09 <RchrdB> Phillemann, the library "wai" exposes Network.Wai, which is a low-level interface for HTTP applications, and libraries such as "warp" implement it.
08:35:42 <RchrdB> Phillemann, if you want to go a ~little bit~ higher level, I'm told that "scotty" is really nice.
08:36:14 <Phillemann> Yes, I'm using scott right now and I think it's a bit too high level. Not sure yet, though. Thanks for the suggestion(s) :)
08:36:17 <Phillemann> *scotty
08:37:36 <latk> is hackage down again ?
08:37:44 <Krautman> Just slow, wait a while ;)
08:37:52 <latk> :s
08:37:56 <latk> it is really slow..
08:37:57 <latk> :p
08:40:34 <latk> timed out
08:42:52 <Krautman> Press F5 a lot
08:47:17 <RchrdB> There is a Hackage mirror linked in the /topic of this channel.
08:47:24 <Iceland_jack> hey maru`!
08:59:24 <arboris> hi, cabal tells me that "Parse of field 'exposed-modules' failed, the list of modules is quite long and i am not sure what i am looking for
09:00:03 <arboris> is a number as first character allowed?
09:00:40 <arboris> ok that fixed it
09:03:42 <Krautman> @pl (x, f x)
09:03:42 <lambdabot> (x, f x)
09:03:50 <Krautman> Oh, woops
09:04:04 <Krautman> @pl \x -> (x, f x)
09:04:04 <lambdabot> ap (,) f
09:04:13 <doismellburning> :t ap
09:04:13 <lambdabot> Monad m => m (a -> b) -> m a -> m b
09:04:26 <Krautman> Already on it ;)
09:05:11 <conal> Krautman: also: id &&& f
09:05:21 <doismellburning> :t (&&&)
09:05:22 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
09:05:37 <Krautman> I like to keep it elementary ;)
09:06:05 * conal wonders which elementary.
09:07:30 <Krautman> Elementary, dear Watson.
09:07:49 <Krautman> Though I think he never really said that.
09:18:36 <monochrom> \x -> (x, f x) is the most elementary. id &&& f is the second most.
09:20:36 <lpvb_> > second (+1) . join (,) $ 1
09:20:38 <lambdabot>  (1,2)
09:20:54 <vanila> :t second
09:20:55 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
09:23:07 <Krautman> How does Data.Function.fix work?
09:23:25 <Krautman> > fix (&& True)
09:23:29 <lambdabot>  mueval-core: Time limit exceeded
09:23:35 <monochrom> see my http://www.vex.net/~trebla/haskell/fix.xhtml
09:23:58 <nshepperd> > fix (1:)
09:24:00 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
09:24:03 <Krautman> Oh hang on... *facepalm*
09:24:08 <Krautman> Now I see.
09:24:08 <nicoo> @code fix
09:24:08 <lambdabot> Not enough privileges
09:24:14 <nicoo> Tsss
09:24:15 <Krautman> Wrong level ;)
09:24:29 <Cale> Krautman: fix f = x where x = f x
09:24:46 <monochrom> actually fix (False &&) will work nicely.
09:25:02 <nicoo> Cale: It was I who requested it, but thanks, that's indeed the definition I though of
09:25:11 <nicoo> > fix (False &&)
09:25:12 <lambdabot>  False
09:25:24 <nicoo> > fix (&& False)
09:25:28 <lambdabot>  mueval-core: Time limit exceeded
09:25:28 <nicoo> :)
09:25:33 <monochrom> yeah
09:25:35 <Krautman> Right.
09:25:39 <Krautman> >fix (&& True)
09:25:56 <Krautman> I'll get it right SOME day ;)
09:26:15 <benzrf> > fix (&& True)
09:26:19 <nshepperd> @src fix
09:26:19 <lambdabot> fix f = let x = f x in x
09:26:19 <lambdabot>  mueval-core: Time limit exceeded
09:26:23 <benzrf> > fix (True && )
09:26:26 <nicoo> > fix (True &&)
09:26:27 <lambdabot>  mueval-core: Time limit exceeded
09:26:30 <lambdabot>  mueval-core: Time limit exceeded
09:26:31 <benzrf> hmm....
09:26:33 <benzrf> but shouldnt that work?
09:26:39 <nicoo> > fix (True ||)
09:26:39 <monochrom> also consider fix (True ||)
09:26:40 <benzrf> wait
09:26:41 <lambdabot>  True
09:26:44 <benzrf> ohhh
09:26:46 <nicoo> monochrom: Yup :)
09:26:46 <benzrf> i was thinking of (||)
09:26:51 <nicoo> Got to love short circuit
09:26:56 <nshepperd> (True&&) has two fixed points
09:27:13 <nicoo> nshepperd: Sure, it is identity for bool
09:27:15 <benzrf> YEAH
09:27:19 <benzrf> *yeah
09:27:25 <Krautman> So non-deterministic functions don't have a fixpoint?
09:27:41 <nshepperd> well, three including bottom. in this case fix chooses bottom :p
09:27:44 <monochrom> the least fixed point is preferred, because it's all the dumb computer can try
09:27:51 <nicoo> Krautman: (Pure) non-deterministic functions don't exist
09:27:55 <c_wraith> Krautman: it's deterministic, it just might be non-terminating
09:28:20 <monochrom> bottom is less than the other fixed points in the case of (True&&)
09:28:28 <Krautman> Ahhh, right, I get it now. It's still a valid request to make, just not computable in finite memory
09:28:51 <LoRez> lambdabot: help
09:29:05 <Krautman> It's 2014 and I want my quantum computer.
09:29:14 <monochrom> a smarter computer (one that can find and prove theorems) can notice greater fixed points
09:29:29 <quchen> LoRez: Lambdabot doesn't have a help(ful) helping feature. Just ask your question out loud.
09:29:30 <Krautman> I'll stick to pen and paper, thanks monochrom ;)
09:29:47 <nicoo> Krautman: Quantum computing don't push back the boundaries of computability
09:30:08 <LoRez> quchen: don't really have one, just checking that another bot is properly ignoring it.
09:30:15 <nicoo> At best, they can deal with PSPACE problems in polynomial time and space (and bounded error probability)
09:30:17 <nshepperd> I think the basic 'fix' only works for things that can return a data constructor without examining its argument, right?
09:30:44 <benzrf> nshepperd: wnhf
09:30:50 <benzrf> they have to be lazy
09:30:51 <nshepperd> well, 'works' in that it returns non-bottom
09:30:52 <benzrf> basically
09:30:59 <Cale> fix always finds the least-defined fixed point.
09:31:13 <Cale> If undefined is a fixed point of your function, that's what you'll get.
09:31:32 <monochrom> fix (const id) may contain no data constructor you can think of
09:31:34 <Cale> i.e. nontermination
09:31:46 <benzrf> bbiab
09:32:50 <nshepperd> oh, I suddenly understand how this relates to strictness and that semantics jazz
09:33:05 <shapr> I am strictly non-strict.
09:33:30 <Krautman> Logic has feelings too, shapr :(
09:34:16 <monochrom> yes, you need sufficient non-strictness for fix to give interesting answers
09:34:21 <nshepperd> fix f where f is strict necessarily spins forever, because f forces the evaluation of its argument, ad infinitum
09:34:52 <nicoo> > fix (const id)
09:34:53 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
09:34:53 <lambdabot>    arising from a use of ‘M4668174089798624584391.show_M4668174089798624584391’
09:34:53 <lambdabot>  The type variable ‘a0’ is ambiguous
09:34:53 <lambdabot>  Note: there are several potential instances:
09:34:53 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
09:34:55 <monochrom> this can be summarized as: fix is monotonic
09:34:58 <nicoo> :)
09:34:59 <nshepperd> which is the same as saying (because f is strict), f bottom = bottom, and therefore bottom is the least-defined fixpoint
09:35:07 <Cale> > fix (const id) 5
09:35:08 <lambdabot>  5
09:35:23 <Cale> :t fix (const id)
09:35:24 <lambdabot> a -> a
09:35:42 <nicoo> Cale: I know that « fix (const id) » is id :D
09:36:24 <Taneb> :t fix (const _a)
09:36:25 <lambdabot>     Found hole ‘_a’ with type: a
09:36:25 <lambdabot>     Where: ‘a’ is a rigid type variable bound by
09:36:25 <lambdabot>                the inferred type of it :: a at Top level
09:36:31 <Krautman> You could make a lot of heads hurt by replacing every use of Eq x with fix (const id) x
09:36:41 <Taneb> :t fix (const 1)
09:36:41 <lambdabot> Num a => a
09:36:46 <Taneb> :t fix (const Fale)
09:36:47 <lambdabot>     Not in scope: data constructor ‘Fale’
09:36:47 <lambdabot>     Perhaps you meant ‘False’ (imported from Data.Bool)
09:36:51 <Taneb> :t fix (const False)
09:36:51 <lambdabot> Bool
09:36:58 <Krautman> Haskell obfuscation contest, anyone? :3
09:37:32 <nshepperd> so fix . const = id
09:40:02 <c_wraith> nshepperd: it's even kind of obviously so - fix passes the result of itself to the supplied function.  const doesn't care what it was passed.
09:40:03 <monochrom> replace ($) by (fix . const) :)
09:40:04 <nshepperd> does this mean that among functors Fix Constant = Identity?
09:40:47 <monochrom> too bad I can't use (fix . const) infix directly
09:41:09 <Krautman> Infix is too readable anyway ;)
09:41:39 <c_wraith> yes.  replace all do-blocks with prefix (>>=) application
09:41:55 <Krautman> I'm guilty of that.
09:42:05 <vanila> nshepperd, Fix Constant will not work
09:42:26 <Krautman> I found prefix (>>=) to be more readable personally, so I went with that when binding
09:48:40 <Krautman> How come Data.Bits is in scope in GHCi when it's not imported anywhere?
09:48:50 <merijn> /quit/quit
09:49:12 <Krautman> Well, I was curious as to why, :show modules and :show imports doesn't list it
09:49:39 <Krautman> And restarting GHCi doesn't work either
09:49:43 <phaazon> !tell edwardk I guess M** (in linear) should be newtype and (*) = (!*!) ; it surprised me a lot seeing my application going right in the wall because of that :D
09:49:48 <ekuam> what do you mean, in scope?
09:50:05 <Krautman> I can use anything defined in Data.Bits from GHCi
09:50:20 <Krautman> Yet it's not in imports, modules, nor imported in any files
09:50:20 <ekuam> too vague
09:50:46 <Krautman> What more can I tell?
09:53:12 <ekuam> actual input/output
09:54:21 <Krautman> As a trivial example, starting a new instance of GHCI, I can just write popCount 127
09:54:32 <Krautman> Yet popCount is defined in Data.Bits
09:54:40 <Krautman> Which is not imported anywhere
09:54:53 <shachaf> Perhaps there's a .ghci file involved.
09:55:12 <Krautman> No, double-checked that already
09:55:12 <ekuam> ok, so an unqualified identifier and no command line arguments
09:55:18 <Krautman> Yes
09:55:29 <shachaf> Your prompt is "Prelude> "?
09:55:38 <Krautman> And as I said :show modules and :show imports don't list it either
09:55:45 <ekuam> yeah, that's interesting
09:55:51 <ekuam> report a bug?
09:56:07 <Krautman> I do have some other imports, namely Data.List and Data.Maybe
09:56:11 <shachaf> Figure out what's going on first and then see whether it's actually a bug.
09:56:11 <Krautman> Those are the only two
09:56:37 <shachaf> Can you start a fresh ghci session?
09:56:44 <Krautman> Yes, no problem
09:56:54 <Krautman> But I already did that several times
09:57:05 <shachaf> And each time you imported Data.List and Data.Maybe?
09:57:09 <Angrier> starting a new ghci and typing "popCount 127" gets me a not in scope error. What version are you using?
09:57:10 <Krautman> (That is, :q and running ghci.exe)
09:57:11 <shachaf> (Really, information like "I do have some other imports" is necessary for a question like that.)
09:57:42 <Krautman> As I said, I have Data.List and Data.Maybe imported in my ghci.conf
09:58:21 <shachaf> What else is in your ghci.conf?
09:58:46 <shachaf> So your ghci prompt is "Prelude Data.List Data.Maybe> "?
09:58:47 <Krautman> Nothing, just the two imports
09:58:57 <Krautman> Well, I have the custom lambda prompt ;)
09:59:05 <shachaf> Sigh.
09:59:07 <Krautman> I can take that out for a moment
09:59:27 <shachaf> I'm not asking what else you think is relevant in your ghci.conf. I'm asking what is actually in there.
09:59:50 <shachaf> If you :set prompt "%s> ", what's in your ghci prompt?
09:59:59 <Krautman> Oh nevermind, I'm not asking questions to get sneered at.
10:00:16 <xenog> Krautman, I would recommend you change the name of your ghci.conf file, and then start ghci, it should start with default settings
10:00:23 <shachaf> If you only look at what you think is relevant, you won't figure out what's going on. The answer must be hiding somewhere where you aren't looking.
10:00:32 <xenog> Krautman: if you do this, you should not have access to the popCount function
10:00:42 <ekuam> we're not asking questions to get incomplete rephrasing of the actual information
10:00:55 <xenog> Krautman: unless, of course, you do "import Data.Bits" or ":m + Data.Bits"
10:01:27 <lpvb_> anyway to get around ghci prompt not showing added modules after :set prompt has been called?
10:02:15 <monochrom> Krautman, shachaf is not sneering at you.
10:02:20 <xenog> Krautman: some modules will re-export functions from other modules, and it is possible that you have imported something that re-exports popCount, or maybe one of those modules has its own version of the popCount function, although that is less likely
10:02:38 <monochrom> all you can fairly conclude is, he asks questions you don't like to answer.
10:07:37 <Angrier> it's driving me nuts, how can a generate a list of all the Int8s?
10:08:07 <shachaf> [minBound..maxBound] :: [Int8]
10:08:09 <ekuam> > [minBound .. maxBound :: Int8]
10:08:10 <lambdabot>  [-128,-127,-126,-125,-124,-123,-122,-121,-120,-119,-118,-117,-116,-115,-114,...
10:12:10 <Angrier> thank you I've been trying for near a day to get it to compile before that one.
10:17:12 <lpvb_> Angrier: what was wrong with [-128..127]
10:17:47 <Angrier> [0..21] for instance was being considered a [Int]
10:18:45 <merijn> Angrier: Because that's what it defaults to without a type, in case of doubt, more type annotations :)
10:19:51 <ekuam> Int is not on the default list
10:20:06 <Angrier> still new to the language. Completing projecteuler problems now. Can you always just add a ::Type after a function ( or argument )
10:20:16 <ekuam> after an expression
10:21:39 <Angrier> ekuam, it was part of a list comprehension. That's probably what caused it since the guard had to have the number casted with fromIntegral.
10:21:55 <Angrier> ( after the ::Int8 fix )
10:22:34 <ekuam> how do you know it was an [Int]?
10:23:51 <Angrier> ghci type error output
10:50:21 <angerman> I never knew compiling ghc took *that* long... O_O. Make you not want to delete the final result.
10:53:04 <JEF__> A link in which I detail my question: http://pastebin.com/Rb6dNFf2 . I'd be more than satisfied with just links to more reading.
10:54:05 <wopr14> Is there a howto or something like that which describes how to use Haskell and Erlang together. Long time ago I read a blog about defining the computational side of an application in Haskell and the process management in Erlang ...
10:55:01 <wopr14> ... but I do not remember the address and maybe there is an up to date document for bridging Haskell to Erlang and vice versa.
11:10:16 <burp> !seen edwardk
11:11:49 <edlinde> whats the best way to understand the difference between a “type constructor” and a “value constructor”?
11:12:05 <edlinde> A type constructor can take multiple type parameters right?
11:12:28 <kadoban> A type constructor makes types, a value constructor makes values?
11:13:34 <vanila> yes, the first exists only at type level (right side of ::) - the second only at value level (left side of ::)
11:13:40 <edlinde> it looks to me a lot like the type constructor is the base class and the value constructors are like derived classes in OOP
11:14:16 <vanila> it's not like that
11:14:22 <edlinde> ok
11:16:18 <edlinde> data Vector a = Vector a a a deriving (Show)
11:16:19 <edlinde>  vplus :: (Num t) => Vector t -> Vector t -> Vector t
11:16:20 <edlinde> (Vector i j k) `vplus` (Vector l m n) = Vector (i+l) (j+m) (k+n)
11:16:23 <edlinde> was trying to understand this
11:16:55 <edlinde> so the type constructor is “Vector a” and “Vector a a a” is the value constructor?
11:17:05 <vanila> Vector a is a type because Vector a :: *
11:17:13 <vanila> Vector :: * -> * is a type constuctor
11:17:55 <vanila> on the value level you have the constructor Vector :: a -> a -> a -> Vector a, which has the same name as the type constructor - but they are different things (and you could give them two different names for example)
11:18:20 <edlinde> yeah the same names is confusing
11:18:42 <vanila> so let's say data VectorT a = VectorV a a a deriving (Show)
11:18:46 <vanila> then the code is the same as
11:18:52 <vanila> vplus :: (Num t) => VectorT t -> VectorT t -> VectorT t
11:18:59 <vanila> (VectorV i j k) `vplus` (VectorV l m n) = VectorV (i+l) (j+m) (k+n)
11:19:33 <edlinde> ok so what does it mean to say (VectorV i j k) ?
11:19:42 <edlinde> why do we have the parenthesis there?
11:19:54 <edlinde> is that to surround a value constructor?
11:20:40 <vanila> it's the same as this
11:20:44 <vanila> VectorV i j k `vplus` VectorV l m n = VectorV (i+l) (j+m) (k+n)
11:21:02 <edlinde> I didn’t get why we have to say “VectorT a” ?
11:21:02 <vanila> the author might not have known that you can omit the parens, or just didn't like to
11:21:15 <edlinde> I get the value constructors I think
11:21:23 <edlinde> ok
11:21:36 <vanila> it's pattern matching on the two inputs, to unpack them so it can access the 3 values they each store
11:22:14 <edlinde> so I just want to understand how to read this data defn I guess
11:22:28 <edlinde> data VectorT a = VectorV a a a deriving (Show)
11:22:50 <edlinde> here we saying that we are building a new data type called VectorT which will take one arg of type a?
11:22:57 <vanila> that's exactly right
11:23:18 <edlinde> but we never use VectorT?
11:23:21 <edlinde> or?
11:23:22 <vanila> and then you define all the constructors of it, only one this time: VectorV a a a means that it holds 3 "a"s whatever they are (they could Ints for example)
11:23:39 <edlinde> ok Num types I think
11:23:51 <vanila> well you could have data Letter = A | B | C
11:23:59 <edlinde> so I get that the VectorV needs to have the x,y,z co-ordinates
11:24:03 <vanila> then you have three constructors A,B,C all of which have type Letter
11:24:26 <vanila> whenever you use A or B or C the compiler checks that "Letter" is the right thing in that context
11:24:41 <edlinde> so can I understand it as “VectorV a a a” as just another way of saying “VectorT a"?
11:24:52 <vanila> and in this situation when you use VectorV x y z it checks that x y and z all have the same type a - and that it needs a VectorT a in that context
11:25:01 <vanila> that's not quite right
11:25:06 <edlinde> hmm
11:25:11 <JEF__> A link in which I detail my question: http://pastebin.com/Rb6dNFf2
11:25:21 <vanila> the 'data' syntax is a little weird in that is mixes values and types
11:25:32 <vanila> another way of writing this that might be clearer is
11:25:34 <edlinde> yeah :(
11:25:37 <vanila> data VectorT a where
11:25:44 <vanila>  VectorV :: a -> a -> a -> VectorT a
11:26:09 <vanila> which is declaring a data type 'VectorT a', VectorT is the type constructor. And then it lists out all the constructors of the data type & their types
11:26:11 <edlinde> hmm
11:26:31 <vanila> so the first (only) constructor is VectorV which constructors a VectorT a given 3 'a's
11:27:08 <vanila> data VectorT a = VectorV a a a   is a shorthand (and it is a lot shorter) but from the compactness it's a little harder to understand
11:27:25 <edlinde> just one thing
11:27:32 <edlinde> In : VectorV :: a -> a -> a -> VectorT a
11:27:52 <edlinde> should I understand it as VectorV is taking three args of type a and returns a type VectorT?
11:28:05 <edlinde> and this VectorT has a param a
11:28:09 <vanila> yes almost, it returns a value of type VectorT a
11:28:16 <edlinde> yep
11:28:19 <vanila> so e.g.    VectorV 1 2 3 :: VectorT Int
11:28:35 <vanila> and    VectorV "foo" "bar" "baz" :: VectorT String
11:28:42 <edlinde> whats the significance of :: again?
11:28:45 <edlinde> I forget
11:28:57 <vanila> v :: T  means that the value v has type T
11:29:03 <edlinde> ok
11:29:44 <edlinde> and I can read any function in those terms?
11:29:50 <edlinde> I mean in term of the v::T
11:30:35 <vanila> yeah - everything that's valid code in haskell will have a type, that's one of the really nice things about haskell
11:30:55 <vanila> in other languages you can make mistakes that the compiler won't notice like (+ 3 "x") - and it'll error at runtime
11:30:57 <edlinde> In “VectorV 1 2 3 :: VectorT Int” .. is “VectorV 1 2 3” still a function? or we call it something else? like an instance of VectorV?
11:31:04 <vanila> but haskell catches that during compilation
11:31:13 <edlinde> ok
11:31:22 <vanila> it's not a function
11:31:39 <vanila> you will always have a judgement like f :: a -> b when 'f' is a function
11:31:52 <edlinde> yes
11:32:10 <vanila> so VectorV 1 2 is a function, since VectorV 1 2 :: Int -> VectorT Int
11:32:15 <edlinde> so the v::T logic only applies to types?
11:32:42 <vanila> it relates a value and a type
11:32:47 <edlinde> are you talking about an applied function there?
11:33:01 <vanila> it's important in haskell to think about the values and data you work with, as well as what type they have
11:33:04 <edlinde> when you said “VectorV 1 2"
11:33:43 <josephle> "VectorV 1 2" is a function, but you can also see it as VectorV being partially applied with 1 and 2
11:33:59 <edlinde> ok
11:34:21 <MeatPuppet> There is haskell platform for archlinux arm on raspberry
11:34:23 <MeatPuppet> ?
11:34:33 <josephle> it can also be seen as "VectorV 1" partially applied with 2 :)
11:35:11 <edlinde> yep
11:36:02 <edlinde> I understood “VectorV 1 2 :: Int -> VectorT Int” as VectorV 1 2 is partially applied.. so it has one arg left to take and then it will return “VectorT Int”
11:37:02 <edlinde> did I get that right josephle ?
11:37:45 <quchen> The distinction between functions and "other values" is not always obvious, and depends in what context you're talking about things. There are mathematical, practical, handwavy and what have you definitions. The important thing is that the distinction does not really matter very often.
11:38:15 <quchen> Functions are values. Worry about values.
11:38:27 <quchen> s/values/data/
11:38:58 <merijn> The distinction between functions and "other values" is always obvious, one has type "a -> b", the other doesn't :D
11:39:20 <quchen> merijn: And then "type" happens
11:39:27 <edlinde> yep
11:39:30 <quchen> f :: Hello -- Is this a function?
11:39:32 <edlinde> merijn: I do read it like that
11:39:52 <merijn> quchen: That's what :kind! is for
11:39:54 <edlinde> so f has Type Hello?
11:39:54 <quchen> And then "newtype" happens. f :: Hello -- Is this a function? Denotationally no, operationally arguably?
11:40:15 <quchen> merijn: And then type families!
11:40:18 <Peaker> merijn: saw the many replies?
11:40:19 <merijn> quchen: No, because you can't call newtypes
11:40:31 <merijn> quchen: :kind! applies to type families as much as type :)
11:40:35 <edlinde> I tried: data Vector a = Vector a a a deriving (Show) on ghci
11:40:47 <edlinde> <interactive>:1:0: parse error on input `data'
11:40:55 <merijn> Peaker: Yeah, bikeshed time :)
11:40:58 <edlinde> wondering what module I need to load?
11:41:01 <merijn> edlinde: You can't define data in ghci
11:41:05 <edlinde> ah
11:41:22 <merijn> edlinde: I usually recommend editing a .hs file in $EDITOR and loading the file into ghci
11:41:29 <edlinde> ok
11:41:36 <edlinde> do I need to import any module for this?
11:41:40 <edlinde> or its included in base
11:41:40 <merijn> edlinde: You can use ":l file.hs" to load a file and :r to reload any changes
11:41:48 <merijn> edlinde: No, that should just work without imports
11:41:57 <Peaker> merijn: I see a lot of the Nirvana fallacy in many replies
11:42:00 <edlinde> ok cool
11:42:12 <merijn> Peaker: What's the nirvana fallacy?
11:42:24 <quchen> merijn: If you have to use kind! to check whether something is a function then I call that non-obvious.
11:45:09 <Peaker> merijn: comparing the solution with some perfect, idealized solution that does not actually exist and thus ruling it out as worse, when in fact the current situation is orders of magnitude worse
11:45:25 <edlinde> merijn: whats :kind telling me?
11:45:41 <edlinde> so I set up this data type:  data VectorT a = VectorV a a a deriving (Show)
11:46:07 <edlinde> >:t VectorV     >VectorV :: a -> a -> a -> VectorT a
11:46:09 <edlinde> I get that
11:46:20 <edlinde> *Main> :kind VectorT   > VectorT :: * -> *
11:46:43 <edlinde> *Main> :kind VectorT               > VectorT :: * -> *
11:46:49 <edlinde> wondering what that is telling me
11:47:14 <edlinde> *Main> :t VectorV 1 2 3    > VectorV 1 2 3 :: (Num t) => VectorT t
11:47:31 <edlinde> all that :t stuff is now making sense thanks to vanila :)
11:48:54 <cow_2001> using a big screen on xmonad is something else
11:49:10 <linman32> hey why is this incorrect?
11:49:11 <linman32> getSomething Ord dtype :: Int -> ([dtype], [dtype]) -> [dtype]
11:49:28 <linman32> error is, Should be of form <variable> :: <type>
11:49:52 <monochrom> edlinde: every type belongs to a kind. the most basic example is that Int, Double, Char, they all belong to the kind *
11:50:12 <edlinde> ok
11:51:13 <monochrom> I can actually say what the kind * stands for. Iff T has kind *, T has values. For example, Int has values.
11:52:11 <monochrom> Next, you have probably heard of Maybe. "Maybe Int" has values. "Maybe Char" has values. Therefore, "Maybe Int" has kind *, "Maybe Char" has kind *, etc. Now the question is, what about "Maybe" alone?
11:52:55 <edlinde> ok
11:53:17 <monochrom> we say: "Maybe" has kind * -> *, it's waiting for you to plug in a type before you can talk of values. that's the second * in "* -> *"
11:53:20 <edlinde> so a list cannot have kind * yeah?
11:53:25 <edlinde> coz it can be [] ?
11:53:38 <monochrom> the type you plug in, must also have values. that's the first * in "* -> *"
11:53:49 <monochrom> [] has kind * -> * too
11:53:54 <edlinde> but with Maybe we also have Nothing right?
11:54:30 <monochrom> Nothing's type is Maybe Int, or Maybe Char, or Maybe Something. Nothing's type is not Maybe.
11:55:05 <edlinde> ok
11:55:16 <monochrom> VectorT is in a similar situation as Maybe and []. they are all of kind * -> *, they're waiting for you to plug in a type.
11:55:40 <edlinde> ok gotcha
11:55:41 <edlinde> :)
11:55:58 <edlinde> so this is what helps do type inference?
11:56:13 <edlinde> so Haskell deduces type based on the context?
11:56:31 <linman32> :k Ord
11:56:32 <lambdabot> * -> Constraint
11:56:41 <monochrom> this is kind inference. I haven't talked about type inference.
11:56:50 <edlinde> ok
11:57:54 <edlinde> I got an error when I typed > :k Ord
11:58:07 <edlinde> Class `Ord' used as a type
12:00:04 <edlinde> monochrom: did u write LYAH?
12:02:47 <monochrom> no
12:02:55 <edlinde> ok :)
12:04:45 <ysz> hi
12:06:05 <MeatPuppet> hello
12:06:10 <ysz> i'm thinking about making a come back to Haskell programming after 3-4 years of stall. I was mostly doing dynamic (Lisp,Prolog). How do you estimate current market for Haskell programmers/consultants? Should I dive back in? Or find some other niche? I'm going to be more on finance engineering/data science side
12:07:05 <Elora22>  Hi! I give you some videos. I hope you like! http://bit.ly/1mFMmyS
12:07:29 <epta> Elora22: oh you
12:12:36 <levi> ysz: There are people hiring Haskell programmers; I have no idea how the number compares to those hiring Lisp or Prolog programmers, though.
12:12:39 <sm> a LYAH written by monochrom would be a very different book. :)
12:13:57 <athan> is there a math library in haskell that does fast factorials? Or, even better, numerical combinations/permutations?
12:14:00 <ysz> levi, jfyi prolog number is close to zero. prolog is not so much about commodity programming but about problem solving so it rarely listed
12:15:12 <il> i am hiring haskell devs
12:15:28 <il> applicants must have 20 years of experience
12:15:50 * sivteck is 21
12:15:50 <sigma914> Huh, that's actually possible
12:15:55 * sivteck applies
12:16:05 <luite> i have multiple capabilities, so i've accumulated that experience in a shorter amount of time
12:16:35 <athan> il: Do you need janitors? :D
12:16:52 <athan> crap, is hackage still down?
12:19:20 <hamid> athan, Isn't Repa what you want?
12:20:00 <athan> hamid: :P I want to check out clash
12:20:04 <levi> ysz: Yeah, I suspected it'd be pretty low in the list of explicitly requested job skills on the market today.
12:20:49 <vanila> What is the best way to get started working as a programmer? If you just came out of studying
12:21:30 <il> athan, janitors must have 10 years of haskell experience
12:23:04 <levi> vanila: Well, the easiest way is to know someone who can influence the hiring at the company they work for and thinks you'd be good there.
12:23:05 <athan> il: Do you accept hyperbolic time chambers?
12:23:24 <ysz> vanila, fix some bugs in some open source project?
12:24:11 <il> athan, yes
12:24:58 <athan> il: Perfect!
12:25:09 * athan instant transmissions
12:25:40 <monochrom> vanila: the best way to get start going to school, if you just came out of pre-schooling, is to apply to a school. the best way to get start going to work, if you just came out of school, is applying for work.
12:27:02 <chirpsalot> vanila: define best :P
12:27:25 <vanila> anything that will work for me
12:27:31 <monochrom> to a large extent, my way is the unique way, therefore it is the best regardless of definition
12:27:47 <luite> what's the best way to get 20 years of haskell experience?
12:27:54 <monochrom> I guess it is also the worst way
12:28:23 <mauke> luite: cannibalism
12:28:24 <simpson> luite: Time machine, obviously.
12:28:31 <monochrom> mindmeld with 20 people, each person 1 year of haskell experience.
12:28:37 <chirpsalot> luite: from whose frame of reference?
12:28:37 <mauke> eat simon's brain
12:29:01 <tnks> start now, come back in 20 years?
12:29:49 <monochrom> oh, there is a Hong Kong kung-fu fiction, in which one character practiced a creepy magical kind of kung-fu, such that he absorbed other people's kung-fu abilities by eating them.
12:29:49 <athan> just make a focal lens on timespace, that's all you need to spend more temporal experience in less time ._.
12:30:18 <geekosaur> ...but can you use the lens package for that?
12:30:52 <athan> if you make it asymptote, you basically solve `x/0`
12:30:58 <athan> and P=NP
12:31:08 <monochrom> edwardk has a lens package and a machine package. for the time package, GHC already has it.
12:31:23 <athan> geekosaur: It needs 7.10 right now :/
12:31:30 <monochrom> build-depends: lens, time, machine
12:31:33 <athan> for the InvertUniverse language extension
12:31:36 <josephle> all you need is a turing machine that computes each step twice as fast as the previous one
12:31:39 <athan> hahaha
12:32:18 <il> physics = computer science in the universe that created ours
12:32:23 <monochrom> I agree with the accelerating turing machine
12:32:40 <il> our computer science will be physics for the worlds we will create
12:32:43 <Javran> hi, how can I persuade myself the uniqueness of skew binary number system?
12:32:59 <athan> il: Do we give an IO Monad?
12:33:05 <monochrom> by creating a universe in which the statement is true
12:33:35 <monochrom> @quote monochrom Kripke
12:33:35 <lambdabot> monochrom says: There are truths, damn truths, and Kripke structures.
12:33:56 <il> athan: i am new to haskell
12:34:20 <athan> il: :)
12:34:52 <Javran> maybe just prove by induction..
12:35:01 <il> Javran, impossible
12:35:27 <slack1256> In "Open Type families are not modular" ezyang say at the end that we shouldn't use typeclasses for things like equality.
12:35:32 <monochrom> induction should work
12:35:33 <slack1256> I don't understand what he meant by that.
12:36:00 <slack1256> Anybody got a concrete example of equality class that is not modular
12:36:11 <monochrom> could you ask him?
12:39:24 <RyanGlScott> Is it expected that show . read ≡ id?
12:39:38 <monochrom> except for parse errors
12:40:03 <monochrom> mostly yes
12:40:05 <RyanGlScott> Alright, good to know
12:45:24 <wz1000> Today i got a context reduction stack overflow.
12:47:05 <wz1000> while compiling my xmonad.hs
12:48:10 <geekosaur> I think that's known with ghc 7.8 and complex layouts?
12:49:31 <Javran> https://www.fpcomplete.com/user/edwardk/online-lca I'm reading this article, this definition: "data Skew = Two !Int Skew | One !Int Skew | Zero" won't guarantee that any value of Skew is a valid skew binary number, right?
12:49:49 <wz1000> I  just increased the stack size, which fixed it.
12:49:53 <geekosaur> yes
12:50:08 <geekosaur> we've previous reports of that problem with ghc 7.8
12:51:20 <Javran> abhiranjan: hi :)
12:51:39 <abhiranjan> Javran: Hello :)
12:51:45 <mauke> [(Bool, Int)]
12:53:17 <athan> is there a natural language library that can convert arbitrary numbers into their english phonetic form? ie: 12 = "twelve", 25 = "twenty-five", etc.?
12:53:22 <Javran> abhiranjan: just doing some search about purely functional LCA algorithm, your challenge on HR reminds me of that :)
12:53:44 <abhiranjan> :)
12:55:27 <abhiranjan> Javran: It will be easy, you are near to it :D
12:58:59 <Javran> abhiranjan: I'm worrying about time complexity, even if I can deal with each LCA query in O(log n), I still need to traverse the path to count elements within range, that might result in TLE if the tree is almost linear
13:00:05 <abhiranjan> Javran: so it boils to another subpart.
13:00:31 <abhiranjan> Javran: This query can also be solved in O(log n)
13:02:12 <Javran> abhiranjan: hope I can figure that out, but I have to leave in a minute, see you then
13:02:50 <abhiranjan> Javran: Bye :)
13:09:23 <Fuuzetsu> yi: Prelude.undefined
13:09:24 <Fuuzetsu> kill me
13:10:01 <athan> Can you chain guards? Something like this: http://lpaste.net/110560
13:10:10 <athan> s/chain/nest
13:10:40 <mauke> that syntax can't work
13:11:02 <athan> :( thanks mauke
13:11:40 <mauke> guards aren't layout based
13:15:20 <athan> mauke: What would be a good way to do that? Where clauses?
13:16:34 <pavonia> athan: Here one option: http://lpaste.net/110561
13:17:08 <Fuuzetsu> zz, when does ICFP finish?
13:17:08 <athan> pavonia: Ahh, okay. I've never really used case statements. Thank you!
13:17:40 <Fuuzetsu> (Data.Rope.last :: Rope -> Char) (Data.Rope.fromString "abc") throws an undefined…
13:22:00 <Fuuzetsu>     last = undefined -- TODO
13:22:01 <Fuuzetsu> oh god damn it
13:22:32 <mauke> haha
13:22:38 * simpson slow claps
13:22:39 <mauke> not even error "not implemented"?
13:22:46 <Fuuzetsu> not even that!
13:23:06 <Fuuzetsu> I see     head = Prelude.head . unpack
13:23:07 <Fuuzetsu>  
13:23:13 <Fuuzetsu> was last = Prelude.last . unpack too much to ask for?
13:53:34 <LunarJetman> I've just decided to learn Haskell, bought the elephant book.
13:53:54 <levi> LunarJetman: Cool. :)
13:54:04 <LunarJetman> I want to find out where you are all hiding state. :)
13:54:55 <jle`> LunarJetman: congrats :D
13:54:59 <levi> Right under your nose!
13:55:03 <jle`> LunarJetman: actually, it is the contrary
13:55:07 <jle`> imperative languages are the ones that hide state
13:55:12 <jle`> haskell is the language that doesn't
13:55:29 <jle`> :)
13:56:10 <LunarJetman> I am only learning it to understand monads and such and to play with at home; I doubt I will ever use it at work.
13:56:11 <Taneb> LunarJetman, chapter 11 or so (don't skip to it!)
13:57:02 <jle`> LunarJetman: don't learn monads for the sake of leanring monads...i have found it to be a very frustrating, meaningless, and useless quest :)
13:58:05 <jle`> "knowing monads" isn't even really a practical requirement to programming haskell practically
13:58:30 <LunarJetman> jle`: imperative languages don't hide state: virtual every line in an imperative program is a state change.
13:58:36 <jle`> LunarJetman: yes, but where is that state?
13:58:48 <jle`> where is it hidden?
13:58:54 <LunarJetman> it isn't hidden
13:59:12 <jle`> can you tell me every single part of your state at a given line in a program?
13:59:20 <jle`> global state that could be changing without you knowing
13:59:33 <jle`> state that could be changing in between lines from concurrency
13:59:33 <jfischoff_> LunarJetman: what state does `void foo()` modify?
13:59:52 <jle`> even local state in an algorithm...you have to think and use your brain to understand all of the variables
14:00:00 <LunarJetman> state can be in a CPU register, CPU pipeline, CPU cache, main memory, HDD, network connection...
14:00:02 <jle`> and sometimes it's not that simple
14:00:42 <jle`> LunarJetman: that's a lot of places where state can be!
14:00:48 <cschneid> serendipity, I run across this in an article: http://aphyr.com/data/posts/317/state.gif
14:00:50 <LunarJetman> it certainly isn't hidden
14:01:04 <cschneid> LunarJetman: honestly, start writing programs. You'll hit small & large issues, then investigate and ask here.
14:01:10 <cschneid> it's how I learned mostly.
14:01:17 <jle`> LunarJetman: in practical terms, could you really keep track of every aspect of state at every line of your program?  you just listed a long list of where you can find state
14:01:25 <LunarJetman> I will wait until the elephant book arrives in Sunday
14:01:31 <LunarJetman> great that Amazon now deliver on Sundays
14:01:36 <cschneid> LunarJetman: if I am not mistaken, isn't it online somewhere?
14:01:47 <merijn> cschneid: It is
14:01:48 <cschneid> http://learnyouahaskell.com/chapters
14:02:32 <LunarJetman> jle`: where the state is is unimportant.
14:02:58 <jle`> state is a part of your environment, your system.  it can be anywhere and everywhere.  we only pretend we are able to keep track of it all, or even of some part of it.
14:03:14 <cschneid> LunarJetman: in the sense of the program (not the machine running it), state in haskell is very explicit.  it's a data structure you pass around and keep track of. The type signature restricts what you can possibly do in that function
14:03:25 <LunarJetman> jle`: I have no problem keeping track of all the state I mutate in my imperative programs.
14:03:58 <jle`> then it is possible that you are much, much smarter than I
14:04:00 <cdk_> LunarJetman: you're saying you never write buggy code related to state? that's very impressive!
14:04:01 <jle`> :)
14:04:15 <LunarJetman> I never said I don't create bugs
14:04:16 <catsup> what's the lens %~ equivalent that handles Maybe?  is there one?  i tried putting a ? in every place
14:04:19 <cite-reader> LunarJetman: Lucky. I'm staring at a 2Mloc PHP project, trying to figure out what $bluh contains.
14:04:53 <jle`> LunarJetman: well then...what about trying to maintain other people's programs?
14:05:14 <jle`> can you jump into someone else's codebase and then instnatly be able to recognize every aspect of state they are taking advantage of, every object...without thinking?
14:05:16 <LunarJetman> I have been using my language of choice since 1993; I am very good with it .. I don't use global variables for example.
14:05:28 <falafel> LunarJetman: think of it this way, all state at any given point is contained within the part of code you're working with.
14:05:40 <cschneid> LunarJetman: don't fight haskell :)  You're going to find that it teaches you to look at problems differently, even as you go back to day-job code.
14:06:17 <jle`> (what about your own codebase that you have not looked at for six months?)
14:06:18 <falafel> LunarJetman: if you don't have to keep track of other state, then everything becomes simpler, and you can reason about your abstraction, and not the state
14:07:06 <LunarJetman> if you are not doing it wrong you don't have to keep track of all the program's state; this is why we have OOP.
14:07:36 <LunarJetman> you partition the state into objects so you can reason about it in smaller pieces
14:07:40 <cschneid> LunarJetman: and you'll find that the abstractions in haskell are different, but just as effective.
14:07:56 <Qfwfq> http://www.downforeveryoneorjustme.com/hackage.haskell.org
14:08:12 <Qfwfq> (Back up.)
14:08:30 <LunarJetman> the real reason I am learning Haskell is so that I don't have to learn Perl. :)
14:09:02 <luite> right, haskell is for implementing perl, not learning it
14:09:05 <jle`> :P
14:09:37 <LunarJetman> I wouldn;t implement a compiler in haskell as I don't like slow compilers.
14:09:59 <burp> is ghc not implemented in haskell?
14:10:11 <luite> LunarJetman: make it an optimizing compiler and have it optimize itself
14:10:29 <jle`> LunarJetman: isn't partitioning of state into hidden sections...hiding state? :)
14:10:51 <LunarJetman> Haskell's runtime system is not written in Haskell
14:10:53 <jle`> LunarJetman: actually, haskell is pretty suited for compilers.  compilers has been called haskell's "killer app" :)
14:11:13 <LunarJetman> jle`: the state is not hidden; the state is abstracted by a class's interface.
14:11:25 <jle`> LunarJetman: ah, i see
14:12:02 <falafel> LunarJetman: So it is encapsulated, and encapsulation === hidden
14:12:13 <monochrom> burp: so far, the workaround I have found is: don't dlclose :)
14:12:25 <LunarJetman> falafel: encapsulation is a good thing as are class invariants.
14:12:53 <falafel> LunarJetman: Im not saying it is not a good thing, I am saying that your point is wrong
14:13:00 <falafel> LunarJetman: OOP is all about hidden state
14:13:25 <LunarJetman> falafel: no it isn't. OOP is all about objects and objects are state.
14:13:25 <jle`> LunarJetman: i'll admit that i was playing a bit loose with words.  the difference i was trying to point out was that in imperative languages, state is an ambient part of the language; any line could potentially modify state.  (yeah, they are language features that can help reasoning about state). but in haskell, any state you take advantage of is "first-class", just a normal pure value, in your face,
14:13:28 <jle`> explicitly manipulated
14:13:34 <jle`> falafel: no need to get into a "you are wrong" thing here :)
14:13:39 <burp> monochrom: um, sadly that is no viable solution to me ;)
14:14:19 <jle`> in haskell, you are always aware of state because all state is explicit.
14:15:07 <jle`> this is because there really isn't a notion of 'execution order' embedded into the language
14:15:10 <josephle> you *can* encapsulate state in haskell, but whether or not you want to is a separate matter :)
14:15:28 <jle`> all lines in haskell are just...pure functions
14:15:33 <jle`> um
14:15:39 <jle`> at this point i think it's best to just read the elephant book :)
14:15:49 <jle`> sorry for any confusion i might have caused for the sake of a silly platitude :)
14:16:10 <falafel> The thing I learned about Haskell, is that you can apply these concepts to many other languages and see benefits
14:16:20 <LunarJetman> jle`: a monadic sequence of operations on an IORef when executed is not pure in the slightest
14:16:29 <burp> monochrom: the full code is a numerical integration, where the integration functions get dynamically linked and unlinked during runtime
14:16:40 <jle`> LunarJetman: the functions are all pure
14:16:46 <jle`> LunarJetman: the algorithm they represent is not pure
14:17:12 <LunarJetman> I have no idea what you mean by that. better read the book.
14:17:14 <jle`> all haskell functions are pure, but you can use pure functions to construct an AST representing a stateful computation, mright?
14:17:22 <burp> monochrom: but somehow it only seems to segfault after the last dlclose
14:17:31 <Fuuzetsu> @pl f x = g <$> z x
14:17:31 <lambdabot> f = (g <$>) . z
14:17:45 <burp> monochrom: if I just replicate the DL.withDL part twice, it doesn't segfault after the first
14:17:46 <dfeuer> It seems the wiki is having trouble again.
14:18:03 <jle`> LunarJetman: imagine programming in a text editor.  you create a "pure text file".  then a compiler goes and compiles the program that the text file represents
14:18:11 <napping> LunarJetman: a function like mapM_ :: (a -> m b) -> [a] -> m () is itself pure
14:18:21 <burp> monochrom: so if it just segfaults right on exit I probably don't care for now
14:18:23 <monochrom> the computer keeps a reference counter on how many times you have dlopen'ed the same thing.
14:18:26 <jle`> you can use pure functions to construct a representation of your algorithm...and then have a run time environment interpret the representation and actually execute it
14:18:43 <jle`> haskell constructs the algorithm.  a computer runs it
14:19:04 <LunarJetman> napping: that is meaningless gibberish to me right now; I don't know Haskell.
14:19:07 <napping> Understanding what's going on with IORef's is as stateful as anything, but you can refactor the IO computation itself like any pure program
14:19:46 <monochrom> and yeah it current just segfaults at program exit, not even right at any dlclose time
14:20:10 <jle`> LunarJetman: you can do the same thing in your language of choice, actually.  provide a pure and declarative way to "construct" your algorithm...in some sort of DSL...and then have a function that executes the representation of the algorithm
14:20:27 <jle`> in haskell, we stop at the construction/declaration part
14:20:36 <jle`> the rest is the responsibility of the CPU
14:20:53 <napping> meh, you still need to worry a bit about what happens when stuff runs, but minimizing state helps
14:20:55 <jle`> and of course, our ComputationRepresenation -> Binary function
14:21:01 <monochrom> burp: second workaround I've just discovered: -threaded
14:21:30 <jle`> if you are working with IORefs, you are basically purely constructiong a stateful computation.  the 'layout'/declaration of it.
14:22:02 <LunarJetman> I might attempt to write a simple text editor in Haskell to see how useful the language really is.
14:23:00 <jle`> anyways, got to go.  i hope we were helpful!  we are usually good with answering questions, although this channel can sometimes tend to get carried away with some technicalities sometimes.  there's also #haskell-beginners and #nothaskell here on freenode
14:23:03 <dfeuer> LunarJetman, simple text editors are not common applications.
14:23:03 <burp> monochrom: just for you then
14:23:09 <monochrom> burp: no no, I take that back, I have a polluted experiment
14:23:16 <LunarJetman> dfeuer: nonsense
14:23:18 <jle`> LunarJetman: best of luck and i hope you enjoy the experience :)
14:23:24 <LunarJetman> bye jle`.
14:23:31 <falafel> whats #nothaskell about?
14:23:31 <DanC> hackage seems really slow. Is it just me?
14:23:44 <burp> I stumbled upon another strange memory corruption issue while tinkering with c/ffi, but wasn't able to make a minimal reproducible example yet
14:23:50 <vanila> LunarJetman, a text editor is a cool project - would be interested in how that goes
14:23:56 <jle`> #nothaskell is supposed to be a more moderated and constructive and safe (environment wise) version of #haskell
14:23:59 <jle`> from what i understand
14:24:03 <dfeuer> LunarJetman, in your work, how often do you find yourself needing to write a simple text editor?
14:24:27 <monochrom> wait, #nothaskell exists?!
14:24:38 <LunarJetman> vanila: writing a text editor would be trivial in the language I already know with its mutable state; wondering how easy it is to do with no mutable state.
14:24:40 <jle`> yes it has been in a state of existence for almost a year or so now i think
14:25:00 <LunarJetman> dfeuer: it is no better or worse than any other type of program
14:25:13 <vanila> LunarJetman, zippers could be useful!  it's a trick to let you move around inside a data structure and edit parts, in a pure way
14:25:35 <LunarJetman> is a zipper a monad?
14:25:48 <vanila> i think it can be
14:25:59 <josephle> vanila: zippers are comonads, iirc
14:26:21 <LunarJetman> "moving around inside a data structure and edit parts" sounds totally IMPURE to me
14:26:30 <napping> well, you have some kind of state
14:26:38 <vanila> josephle, ah! thank you
14:26:55 <dfeuer> LunarJetman, well, you can move around in there and edit it, and then you have the old one and the new one too....
14:27:09 <LunarJetman> sounds incredibly inefficient
14:27:17 <napping> If you wanted to, you toss everything in IO and use as much state as you like
14:27:21 <dfeuer> Unless you don't need the old one, in which case you don't have it anymore.
14:27:29 <LunarJetman> that also sounds incredibly IMPURE.
14:27:58 <dfeuer> Well, that would be. And tossing everything into IO is not generally so efficient either.
14:28:32 <LunarJetman> the fact Haskell does that is what makes me suspicious of claims that Haskell is pure.
14:28:41 <cdk_> LunarJetman: it _sounds_ impure because you're not familiar with the concept. Rest assured, zippers are entirely pure constructs
14:28:52 <cdk_> take a zipper for a list
14:29:03 <cdk_> data Zipper a = Zipper [a] a [a]
14:29:13 <napping> well, one way to put is that Haskell tends to make it clear what parts of your code are pure
14:29:16 <cdk_> are you familiar with this syntax?
14:29:25 <LunarJetman> cdk_: until I read the elephant book that is just gibberish to me
14:29:36 <HeladoDeBrownie> LunarJetman, the thing that Haskell purports to be pure is evaluation of expressions. The runtime system is allowed to contain impurity.
14:29:54 <vanila> the elephant book?
14:30:00 <LunarJetman> yes
14:30:03 <HeladoDeBrownie> LYAH has an elephant on it, I think
14:30:23 <napping> and also to encourage getting as much done with the pure stuff as you can, to minimize the state you need to deal with
14:30:34 <carette> @pl \xs ws -> [ x ++ w | x < xs, w < ws ]
14:30:34 <lambdabot> (. (return . (w <))) . (:) . (x ++ w | x <)
14:30:53 <vanila> "(x ++ w | x <)"
14:31:18 <carette> @pl \xs ws -> [ x ++ w | x <- xs, w <- ws ]
14:31:18 <lambdabot> (. (return . (w <-))) . (:) . (x ++) . ((w | x) <-)
14:31:19 <cdk_> LunarJetman: it's a data constructor. It's basically: class Zipper<A>(left: List[A], focus: A, right: List[A])
14:31:32 <jle`> i think we could probably just let LunarJetman read the elephant book first ;)
14:31:42 <LunarJetman> cdk_: still gibberish mate :)
14:32:29 <josephle> LunarJetman: when you learn how certain monads are implemented, you'll understand why not all state is impure :)
14:33:00 <LunarJetman> a sequence of operations to run later is still state in my book, even before it is executed
14:33:25 <carette> @pl \xs ws -> do { x <- xs ; w <- ws ; return (x ++ w) }
14:33:25 <lambdabot> (line 1, column 14):
14:33:25 <eacameron> is it at all possible to build haskell in "Non-cool" mode where all threads are REAL OS threads and "unsafe" C FFI calls don't block everything? I want to use Haskell for this project, but the underlying C library is not conducive to its threading strategy
14:33:25 <lambdabot> unexpected '{'
14:33:25 <lambdabot> expecting variable, "(", operator or end of input
14:33:34 <dfeuer> A recipe for cake is not cake. If you eat it, it probably won't taste so good.
14:33:43 <vanila> The reason we say that haskell is purely functional is that it has the property that when a = b, f a = f b
14:33:56 * DanC gets another failure from hackage
14:33:57 <napping> eacameron: is forkOS too much trouble?
14:33:58 <vanila> this isn't true for languages like c where 'f' might increment a counter
14:33:59 <rodlogic_> is it possible to make a polyvariadic function here (http://okmij.org/ftp/Haskell/polyvariadic.html#introduction) accept zero args? I.e. in addition to f "Hello" "world" or f "Hello" I would like to have f simple return a constant string.
14:34:05 <LunarJetman> vanila: I know what a pure function is
14:34:17 <monochrom> oh, is someone needing an IO tutorial? :)  my http://www.vex.net/~trebla/haskell/IO.xhtml is the best IO tutorial.
14:34:17 <DanC> comonad-4.2.2.tar.gz: ErrorMisc "Error HTTP code: 502")
14:34:19 <LunarJetman> the latest version of the language I already use has pure functions.
14:34:31 <dfeuer> @undo  \xs ws -> do { x <- xs ; w <- ws ; return (x ++ w) }
14:34:31 <lambdabot> \ xs ws -> xs >>= \ x -> ws >>= \ w -> return (x ++ w)
14:34:37 <HeladoDeBrownie> monochrom, you *would* say that. (And probably be right.)
14:34:47 <eacameron> napping: as far as I know, "unsafe" calls will still block all threads
14:35:14 <carette> Thanks LunarJetman
14:35:14 <napping> do you need to make "unsafe" calls?
14:35:22 <LunarJetman> vanila: I even created my own language which include support for pure functions.
14:35:32 <carette> @pl \xs ws -> xs >>= \x -> ws >>= \w -> return (x ++ w)
14:35:32 <lambdabot> liftM2 (++)
14:35:56 <vanila> rodlogic_, no
14:36:10 <carette> Now, isn't "liftM2 (++)" also called something else?
14:36:11 <monochrom> eacameron: is it alright to use "safe"? do you understand all issues in my http://www.vex.net/~trebla/haskell/ghc-conc-ffi.xhtml
14:36:35 <rodlogic_> vanila: ok. I would have been quite nice
14:37:12 <eacameron> napping, monochrom: well it's actually the mysqlclient library, and as bos painfully discovered, it doesn't handle SIG_INT (which is apparently how GHC interleaves C calls on the same OS thread)
14:37:14 <napping> eacameron: forkOS is the thing that is designed to help with libraries that are picky about what OS threads they run on
14:37:17 <HeladoDeBrownie> carette, well, it's the same as liftA2 (++) besides the constraint.
14:37:20 <vanila> rodlogic_, there might be a different approach - what kind of thing are you doing?
14:37:34 <LunarJetman> vanila: from my own language: http://ideone.com/JYDWn4
14:37:43 <monochrom> do you accept modifying mysqlclient source code?
14:37:50 <Qfwfq> Approaches to dynamic loading of user-supplied functions? With a fixed type signature.
14:38:34 <monochrom> it is entirely possible that changing every "unsafe" to "safe" may suffice
14:38:35 <carette> Right, but isn't (++) the <*> or [] ?
14:38:36 <vanila> LunarJetman, cool - does it detect if a function is pure automatically?
14:38:44 <LunarJetman> yes
14:38:46 <eacameron> monochrom: how so?
14:39:08 <monochrom> well last time we talked, the issue was with all the "unsafe"s in the source code
14:39:12 <carette> Arg, 'of' not 'or'
14:39:17 <HeladoDeBrownie> carette, look at the types
14:39:19 <josephle> carette: (++) is the (<>) of [] :)
14:39:20 <HeladoDeBrownie> @type (++)
14:39:20 <lambdabot> [a] -> [a] -> [a]
14:39:23 <HeladoDeBrownie> @type (<*>)
14:39:24 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
14:39:27 <HeladoDeBrownie> They don't match
14:39:28 <josephle> :t (<>)
14:39:29 <lambdabot> Monoid m => m -> m -> m
14:39:31 <rodlogic_> vanila: (body div) == <body><div/><body>, (body (div (attr (cls "myclass))) == <body><div class="myclass"/></body>, etc.
14:40:01 <eacameron> monochrom: bos wraps many of the mysql API calls with versions that block various SIGs so that the mysql client doesn't just crash miserably; but that doesn't solve the actual problem of being able to run multiple mysql calls in different threads simultaniously
14:40:25 <carette> ApplicativePlus ?
14:40:27 <carette> ;)
14:40:40 <vanila> rodlogic_, why don't you use div' for <div/> and div otherwise?
14:40:42 <monochrom> ApplicativePlus is called Alternative
14:40:47 <augur> anyone know of a tutorial for using emacs/aquamacs for haskell, especially in such a way that hierarchical projects behave nicely?
14:41:04 <vanila> rodlogic_, because I think stuff like polyvariadic functions will not give good error messages
14:41:41 <monochrom> eacameron, are you implying that "safe" and bos's approach do not mix?
14:41:44 <vanila> although you can make div a function from a typeclass, which can either take tags or not, to create a tag
14:42:09 <nateb> Is there a Haskell equivalent of Python's os.path.relpath? System.FilePath.makeRelative seems to be a little less versatile.
14:42:09 <josephle> :t (<|>)
14:42:10 <lambdabot> Alternative f => f a -> f a -> f a
14:42:27 <bennofs> nateb: what does relpath do?
14:42:34 <eacameron> monochrom: yes...but I might be wrong. I mean, I can call it "safe" but any attempts to interrupt the C call will simply fail, defeating the purpose, no?
14:42:57 <napping> what's this about interrupting C calls?
14:43:19 <nateb> bennofs: os.path.relpath("foo/biz/bar.txt", "foo/baz.txt") == '../biz/bar.txt'
14:43:39 <eacameron> napping: I'm inferring from some reading that GHC uses signals to interrupt C calls to interleave them on an OS thread (like it does with native haskell)
14:43:48 <carette> But (liftA2 (++)) is not the same as <|> specialized to [].  Oh well.
14:43:54 <holo> all those commas inside lists give me a headache. is there any way to disable them?
14:43:57 <eacameron> but in the case of "unsafe" it can't do that, so it just blocks all threads
14:44:14 <napping> Perhaps it tries that sometimes, but it certainly also runs C calls on their own threads
14:44:54 <monochrom> I do not really known whether and when GHC RTS sends signals to to an OS thread running C. but I know something else that may render this irrelevant.
14:45:06 <eacameron> monochrom: I'm all ears!
14:45:25 <carette> :t nub
14:45:26 <lambdabot> Eq a => [a] -> [a]
14:45:37 <LunarJetman> Haskell will be a grown up language when its runtime is also implemented in Haskell. :)
14:45:41 <nateb> bennofs: It just does system-dependent path difference, in this case the location of the first path relative to the location of the second path (which it treats like a directory).
14:46:02 <monochrom> the way "safe" works is that all other green threads are moved to a different OS thread and happily continue to run there
14:46:53 <HeladoDeBrownie> carette, (<|>) specialized to f = [] and liftA2 (++) have different types. However, (++) has the type of (<|>). Could they be equal? Well, check the definition :)
14:47:02 <vanila> LunarJetman, haskell isn't appropriate for programming things like a compiler runtime
14:47:17 <LunarJetman> why not? too much state mutation going on?
14:47:22 <eacameron> monochrom: so why would you ever use "unsafe"...ever?
14:47:33 <vanila> you would normally do this in a lower level language like assembly or C
14:47:34 <monochrom> because "safe" has overhead.
14:47:39 <LunarJetman> vanila: why?
14:47:40 <HeladoDeBrownie> vanila, would you mind backing up or qualifying that statement? I'm not sure how it would be justified
14:47:43 <napping> eacameron: it's faster, if you know you are calling something that will return quickly
14:48:07 <eacameron> monochrom: so *perhaps* I could just change most/all of the unsafes to safes and hope for the best??
14:48:20 <vanila> because haskell is lazy (you don't have a lot of tight control over execution or resource usage), and has GC etc.
14:48:23 <monochrom> to a large extent, if you're calling C's cos, you have a case of using "unsafe" for higher efficiency
14:48:44 <monochrom> yes, I'm making that bet.
14:48:58 <carette> HeladoDeBrownie thanks for that reality check.  Apparently I've been trying to collapse too many things as "the same".
14:48:58 <LunarJetman> vanila: most problems I need to solve involve tight control over execution or resource usage.
14:49:00 <eacameron> monochrom: hmmmm....it's definitely worth a try
14:49:14 <napping> LunarJetman: Java isn't a "grown up" language?
14:49:26 <eacameron> what's all the SIG_INT business about that bos bent over backwards to accomodate?
14:49:38 <LunarJetman> napping: Java native compilers exist
14:49:41 <monochrom> I don't know.
14:49:57 <napping> LunarJetman: but Java runtimes written in Java?
14:50:15 <napping> GHC is written in Haskell, but that's not the runtime
14:50:24 <napping> like the garbage collector and the threading and such
14:50:32 <LunarJetman> personally I don't think Java is particularly grown up
14:50:51 <napping> If you say "systems programming", that might be a reasonable benchmark
14:50:54 <nateb> bennofs: makeRelative seems to be missing the parent directory part.
14:51:26 <hnoob> maybe rust would be more your thing, LunarJetman.  but its for sure not grown up yet.
14:52:08 <LunarJetman> hnoob: I am quite happy with my primary language; I am learning Haskell just for fun mostly.
14:52:13 <nateb> bennofs: makeRelative "foo/" "foo/biz" == "biz", which is good.  makeRelative "foo/baz" "foo/biz" == "foo/biz", which is not what I'm looking for.
14:52:27 <HeladoDeBrownie> carette, twice I mentioned the types, which is a good negative test: If they're not the same type, they can't possibly be the same. However, be careful of the reverse. For example, there are many implementations of [a] -> [a] or IO A or whatnot.
14:52:45 <vanila> HeladoDeBrownie, does that answer your question?
14:52:54 <HeladoDeBrownie> vanila, yes, I see your reasoning, thanks.
14:52:56 <vanila> ok!
14:54:43 <carette> :t liftA2 (++)
14:54:43 <lambdabot> Applicative f => f [a] -> f [a] -> f [a]
14:54:51 <napping> eacameron: I vaguely recall something about the SIG_INT flying around for pre-empting Haskell code
14:55:14 <eacameron> napping: pre-empting C FFI calls you mean?
14:55:29 <napping> no, for preempting Haskell code
14:55:40 <napping> but an FFI call to C lets the C run on the OS thread that had been running Haskell
14:55:49 <eacameron> napping: OHHH
14:55:59 <napping> so it might get a signal that was meant to interrupt Haskell
14:56:05 <carette> I tell others to look at the types all the time.  Serves me right...
14:56:08 <napping> and if it handles it poorly...
14:56:10 <eacameron> napping: no way!
14:56:49 <napping> I'm not sure there are no other reasoning it might send SIG_INT - perhaps it does try to send the signal to pre-empt foreign calls too?
14:57:39 <napping> "safe" means to put the state of the "Haskell Execution Context" in a nice enough state that another OS thread could start running it, or other cores could confirm it's not in the middle of allocating stuff to do a GC or that sort of thing
14:57:56 <eacameron> napping: huh, that would seem pretty sloppy to me, and if monochrom is right that all green threads are moved to another OS thread, then I'm not sure how that would happen
14:58:19 <napping> well, you can read the RTS papers. I think they are reasonably up to tdate
14:58:58 <napping> forkOS marks the Haskell thread or something so the runtime takes care to run any foreign calls from that Haskell thread on a particular reserved OS thread rather than whatever thread happens to be handy
14:58:59 <eacameron> napping: where can I find those?
14:59:09 <bennofs> Is there
14:59:30 <napping> the Haskell code can run on any thread/core/etc, but it makes sure foreign calls all happen in the same thread (in case you have thread-local state or something)
14:59:35 <bennofs> Is there a faster nubBy somewhere? (not quadratic)
14:59:51 <napping> There's "haskell on a shared-memory multiprocessor"
15:00:11 <eacameron> bennofs: My guess is you don't want to use lists for that
15:00:19 <bennofs> eacameron: what else?
15:00:32 <napping> yopu can go through Set
15:00:49 <eacameron> bennofs: Set or Map or something more ideal for detecting uniqueness
15:00:53 <bennofs> Is there a newtype Comparing a b = Comparing (a -> b) a    ?
15:01:10 <bennofs> with the Ord instance using the function before comparing?
15:02:06 <nateb> bennofs: any suggestions?  Or am I on my own?  I think I can figure out how to write one (famous last words...)
15:02:16 <bennofs> nateb: I have no idea
15:02:17 <napping> oh, nubBy
15:02:18 <napping> hmm
15:02:50 <eacameron> bennofs: In fact, using Set would keep your data unique at all times anyway, but you'd need a newtype with your own Eq instance to get the "by" part ;)
15:04:01 <napping> you'd have to use something like "reflection" to invent an Ord instance for that
15:04:12 <napping> a bit tricky for my tastes
15:04:21 <napping> maybe sortBy and then remove adjacent duplicates?
15:04:23 <eacameron> bennofs: perhaps Set.fromList would help too? O(n*log n)
15:04:43 <napping> eacameron: I think the nub*By* part is significant
15:04:48 <bennofs> eacameron: the problem is the by part
15:06:17 <eacameron> hmm
15:09:03 <eacameron> bennofs: so the "by" clause is not known at insertion?
15:09:30 <bennofs> eacameron: it is. I actually just newtype'd it now, just wondering if there was something more general pre-existing
15:17:03 <aristid> huh, ever tried (1/3) :: Scientific?
15:17:13 <aristid> it hangs my ghci:D
15:18:00 <linman32> (1/3) :: Scientific
15:18:39 <linman32> :t 1
15:18:39 <lambdabot> Num a => a
15:21:14 <monochrom> burp: no, it doesn't just segfault at program exit. it segfaults exactly at every GC time after dlclose.
15:23:05 <burp> oh I see
15:23:15 <napping> bennofs: you can use sortBy
15:23:19 <napping> or you can play with "reflection"
15:23:24 <nateb> bennofs: oh well, thanks for your honesty.
15:23:31 <napping> reify (Order (\x y -> compare y x)) (\p -> mkOrd p "hello" < MyOrd "abcd")
15:23:34 <eacameron> monochrom: Does it look like bos used safe/unsafe entirely backwards here? https://github.com/3noch/mysql/blob/master/Database/MySQL/Base/C.hsc
15:23:43 <napping> with suitable definitions of stuff
15:24:32 <eacameron> monochrom: you'll notice trivial functions like "mysql_errno" are "safe" while the heavy-hitters are "unsafe"
15:24:47 <monochrom> that's an interesting theory
15:25:44 <eacameron> and the "nonblocking" ones are safe, while the blocking ones are unsafe...smells backwards to me
15:25:56 <eacameron> (not that the whole nomeclature of safe/unsafe is intuitive to begin with)
15:26:52 <monochrom> yeah, "please make it safe" vs "please assume it safe"
15:27:52 <gdoteof> I have a Lazy ByteString that I want to write to a file with Data.Text.IO.writeFile
15:27:57 <coppro> safe means "you can paralellize this"
15:28:17 <gdoteof> do i need to go ByteString -> Char -> ByteString ?
15:29:45 <kvanb> gdoteof: nope
15:30:02 <HeladoDeBrownie> gdoteof, hackage.haskell.org/package/binary-0.7.2.1/docs/Data-Binary.html#v:encodeFile seems more like what you want
15:30:32 <HeladoDeBrownie> Or writeFile, probably a better idea
15:30:36 <kvanb> Nah, there's a thing in Data.ByteString somewhere
15:30:39 <gdoteof> HeladoDeBrownie: i have a some json i want to write.  using data.aeson i have it as a lazy bytestring
15:30:46 <eacameron> monochrom: I'll run with that theory for now, 50% of the way there. Now I need to register each OS thread with mysql API...probably with something like "forkMysql act = forkOS (register >> act >> unregister)
15:31:17 <HeladoDeBrownie> gdoteof, not sure why that's relevant
15:31:20 <gdoteof> i see though there is writeFile for lazy and strict
15:31:29 <gdoteof> HeladoDeBrownie: maybe it's not
15:31:31 <HeladoDeBrownie> Besides what you already mentioned
15:32:04 <gdoteof> but i thought i might have given the wrong idea
15:32:13 <HeladoDeBrownie> Either way, your best bet is to use something that takes a ByteString and writes it to a file as-is. Otherwise, you'd run the risk of writing incorrect data.
15:32:37 <HeladoDeBrownie> The thing I linked is a good starting point, but I'm not sure if it's exactly what you want, I just searched it.
15:42:35 <byorgey> @tell Fuuzetsu no, the test suite for split should take on the order of perhaps ten seconds
15:42:35 <lambdabot> Consider it noted.
15:43:03 <byorgey> @tell Fuuzetsu can you open a ticket?
15:43:03 <lambdabot> Consider it noted.
15:43:10 <Fuuzetsu> byorgey: ping pong
15:43:31 <Fuuzetsu> what am I opening a ticket for?
15:43:32 <byorgey> Fuuzetsu: hey there
15:43:39 <Fuuzetsu> oh, the test-suite timing out
15:43:44 <byorgey> Fuuzetsu: 13 days ago you left me a @messages saying... right
15:43:55 <Peaker> merijn: btw: the claim about stack overflow being an async exception is a true problem -- though luite said it might be fixed by having it be thrown from the same thread to itself (which mask will then not mask)
15:44:12 * byorgey has been away from IRC starting a new job and writing a dissertation and such
15:44:21 <Fuuzetsu> OK, don't have time right this moment but I will see if it still happens in the next few days and open a ticket if it is
15:44:21 <sm> wb byorgey
15:44:38 <byorgey> Fuuzetsu: cool, thanks
15:44:55 <byorgey> sm: thanks
16:00:50 <MorpheusBeing> ?fortune
16:00:50 <lambdabot> The fashion wears out more apparel than the man.
16:00:51 <lambdabot>                -- William Shakespeare, "Much Ado About Nothing"
16:01:13 <jle`> is there a data type that is like Maybe with only Nothing, [] with only []?
16:01:19 <jle`> (list with only nil)
16:01:34 <jle`> i mean...a commonly used one in base or something
16:01:53 <jle`> or one with a meaningful name form math or something fun like that
16:02:22 <Peaker> jle`: () ?
16:02:23 <koala_man> is it different from ()?
16:02:34 <Peaker> jle`: Maybe Void and [Void] too :)
16:02:40 <jle`> it would still have the type parameter
16:02:51 <jle`> data K a = K
16:02:59 <bennofs> jle`: Proxy from tagged package
16:03:00 <Peaker> Const ()  ?
16:03:05 <Fuuzetsu> hackage dying again
16:03:14 <jle`> it would be interesting maybe because K Void would be inhabited
16:03:28 <jle`> Peaker: ah, that works
16:03:34 <jle`> bennofs: oh i see
16:03:38 <jle`> i would look at it if hackage was up
16:03:52 <jle`> is this a...useful thing/concept?
16:03:56 <fizbin> If I'm in a weird limited environment with only cabal 7.4.1, how do I get the equivalent of Data.Map.Strict?
16:07:53 * ski first thought jle` was thinking about `data Sierpinski = Observable'
16:08:16 <jle`> sierpinski, there's a name i didn't expect to hear in this context
16:08:34 <jle`> doesn't he just study snowflakes?
16:09:11 <jle`> ...and make carpets?
16:09:21 <ski> <https://en.wikipedia.org/wiki/Sierpi%C5%84ski_space>
16:09:30 <ski> also see
16:09:36 <ski> @where topology
16:09:36 <lambdabot> "topology in Haskell" <http://www.haskell.org/pipermail/haskell/2004-June/014134.html> and "Synthetic topology of data types and classical spaces" <http://www.cs.bham.ac.uk/~mhe/papers/entcs87.(pdf|dvi|ps)> by Martn Escard
16:09:57 <jle`> i see
16:10:16 <jle`> thanks :)
16:10:25 <ski> one can think of `Sierpinski' as containing two values, "observably/terminatingly true" and "unobservably/nonterminatingly false" (iow the bottom)
16:11:26 <ski> one can e.g. consider a `parallelOr :: Sierpinski -> Sierpinski -> Sierpinski' operation that runs the two arguments concurrently, until the first one of them terminates
16:11:39 <ski> (a conjunction is easy to define in Haskell)
16:12:18 <ski> also, one can define an `ifS :: Sierpinski -> a -> a', such that `ifS s a' yields `a' when `s' terminates to `Observable'
16:12:38 <jle`> and if it doesn't, then it returns bottom, ofc
16:12:42 <ski> yep
16:12:43 <ski> @where impossible
16:12:43 <lambdabot> <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>,<http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/>
16:12:46 <jle`> there isn't quite a way to encode a false
16:12:49 <ski> is also related to this stuff
16:12:51 <jle`> er, a false branch
16:13:20 <jle`> no notS :: Sierpinski -> Sierpinski?
16:13:22 <jle`> :P
16:13:23 <chirpsalot> Is there a way to tell cabal install to add a dependency?
16:13:24 <ski> right
16:13:46 <jle`> so it's not quite a boolean algebra
16:14:15 <ski> for various datatypes `T', one could define `forallS :: (A -> Sierpinski) -> Sierpinski' and `existsS :: (A -> Sierpinski) -> Sierpinski'
16:14:32 <ski> `A's for which `forallS' can be defined are called "compact"
16:14:34 * geekosaur wonders if --constraint would work
16:14:42 <ski> `A's for which `existsS' can be defined are called "overt"
16:15:10 <chirpsalot> geekosaur: I tried that, but it didn't seem to. I might be using it incorrectly, though.
16:15:13 <chirpsalot> http://lpaste.net/115498138810187776
16:15:41 <ski> `A's for which `apartS :: A -> A -> Sierpinski' (iow, a kind of disequality, a one-sided `Sierpinski' version of `(/=)') are called "haussdorff"
16:15:42 <chirpsalot> I'm running into that problem, so I tried to add --constraint"network-uri >= 2", but that didn't help.
16:16:02 <ski> er, for which that can be defined, i mean
16:16:40 <ski> jle` : this is interesting, since it connects topological concepts with computational concepts
16:17:19 <ski> (and if you haven't seen the "impossible" blags before, then i suggest you read them)
16:17:25 <geekosaur> huh. that's kinda broken
16:18:23 <ski> jle` : it's interesting that `forallS' can be defined even for some types `A' with an infinite number of elements ..
16:18:51 <ski> (so it's not just as simple as "check the given property on every element of the type")
16:19:00 <geekosaur> chirpsalot: I think you need --constraint='network == 2.4.1.2', but beware of breakage as you appear to have a later version installed
16:19:28 <geekosaur> also email to libraries@haskell.org list might be in order
16:20:15 <chirpsalot> geekosaur: I just installed the later version because it wouldn't work, so I tried a manual install.
16:20:27 * chirpsalot is very bad at cabal :(.
16:21:00 <chirpsalot> geekosaur: thanks, though. Progress is being made!
16:21:04 <geekosaur> odd. remove the newer one and use the --constraint I just gave you
16:22:20 <geekosaur> still suggest mail to the libraries list since it sounds like the stuff they set up to avoid breakage with the network-uri split isn't working as intended
16:23:55 <ski> .. Martín Escardó also has several more cool papers related to above topics
16:25:00 <ski> e.g. a proof that given any infinite sequene of types in type theory, you can prove that it converges to whatever type you like
16:26:17 <ski> which means that (sequentially) topologically, you can't in a meaningful sense distinguish between elements (i.e. types) of a universe (a type of types)
16:26:53 <statusbot> Status update: GHC Trac is experiencing high load and service disruption as we investigate potential problems. -- http://status.haskell.org
16:27:28 <ski> from this follows e.g. a weak version of : it's impossible to write a decidable predicate which determines whether any given type is inhabited
16:27:31 <sm> nice, statusbot
16:29:56 <ski> the notion of a converging sequence depends on an extension of the type of natural numbers, which more or less adds an "infinity" element
16:31:47 <ski> i believe this is equivalent to the greatest-fixedpoint solution of `Nat = 1 + Nat' which one automatically gets in Haskell by `data Nat = Zero | Succ Nat', by also considering the element `inf' defined by `inf = Succ inf' (but not considering any partial elements)
16:33:19 <ski> whereas an ordinary infinite sequence of elements of `A' is basically a function from (the ordinary naturals) `|N' to `A'. a *converging* infinite sequence would be a function from the above type of extended naturals, to `A'. the element of `A' which it coverges to would be the one indexed by `inf'
16:33:39 <ski> (and all these functions are assumed to be non-partial, iow total)
16:33:44 <benmachine> a continuous function
16:34:11 <ski> yes, by the notion of continuity induced by the computability
16:34:25 <benmachine> right
16:34:49 <benmachine> sorry I just started following what you were talking about
16:35:14 <ski> so, while you can distinguish any finite elements of `Nat' from each other, you can't distinguish `inf' from any of the finite elements
16:35:40 <benmachine> well, you can distinguish it from any of the finite elements, just not from all of them :P
16:35:59 <benmachine> "any" is a difficult word sometimes
16:36:44 <ski> yeah, i suppose what i should have said is that you can't decide whether any (total) element is finite or not
16:37:09 <ski> in Escardó's paper, he explicitly constructs his extended naturals as decreasing infinite sequences of bits
16:37:26 <ski> where `inf' corresponds to the constantly `1' sequence `[1,1,1,...]'
16:37:52 <ski> while any finite natural `n' corresponds to the infinite sequene that starts with `n' `1's, and then has only `0's
16:39:24 <ski> deciding whether such a sequence ever reaches `0' is equivalent to assuming the validity of the Limited Principle of Omniscience (LPO) .. which is a classical logic principle, which is a special case of the Law of Excluded Middle / Principle of Omniscience
16:40:59 <ski> (LPO states that `forall bs : |N -> 2. (exists i : |N. bs i = 0) \/ (forall i : |N. bs i = 1)')
16:41:10 <ski> however
16:41:38 <ski> what's interesting here is that LPO for these *extended* naturals hold, i.e. if you replace `|N' by this type of extended naturals
16:43:28 <ski> Escardó also relates this stuff to the "drinker paradox" ("in any inhabited bar, there's a person such that if that person drinks, then everyone at the bar drinks")
16:44:36 <contiver> Since I'm coming here more lately, how does the karma system work? Do I just type the users name literally, followed by two + signs?
16:44:57 <ski> yes, or you type `@karma+ nickname'
16:45:05 <ski> @list karma
16:45:06 <lambdabot> karma provides: karma karma+ karma- karma-all
16:45:14 <ski> @karma lambdabot
16:45:14 <lambdabot> lambdabot has a karma of 28
16:45:46 <ski> .. though i don't think we employ this karma system *that* much
16:46:42 <ski> however, if you want to express that you thought a comment or question or answer was well stated, or deserving of note, then one way to express that could be to increment the utterer's karma
16:46:44 <contiver> still, I guess it's good manners, some probably don't care, others might do.
16:46:54 <HeladoDeBrownie> A channel I used to op had to get rid of the karma system because a troll abused it by patiently downvoting someone until their score was zero, and that person refused to take it lying down and started fighting it. Fortunately, this channel seems tamer.
16:48:27 <zomg> @karma- zomg
16:48:27 <lambdabot> You can't change your own karma, silly.
16:48:32 <zomg> but but...
16:48:33 <zomg> :D
16:49:00 <geekosaur> I think someone caught doing so here would find themselves banned from channel, or possibly put on the bot's ignore list
16:49:01 <ski> @karma- zomg
16:49:01 <lambdabot> zomg's karma lowered to 0.
16:49:04 <ski> there you go :)
16:49:09 <ski> @karma+ zomg
16:49:10 <lambdabot> zomg's karma raised to 1.
16:49:10 <zomg> aww, it doesn't go below 0
16:49:11 <monochrom> indeed, we don't even care that C has an unusually high karma :)
16:49:11 <ski> (:
16:49:19 <monochrom> @karma c
16:49:19 <lambdabot> c has a karma of 2
16:49:21 <zomg> on another channel with another bot, some guy had like -3000
16:49:37 <monochrom> @karma C
16:49:37 <lambdabot> C has a karma of 2
16:49:38 <contiver> I'm trying to learn about argument handling in Haskell, and seeing this http://www.haskell.org/haskellwiki/Command_line_option_parsers , there seems to be quite a few packages I could start with. Anyone has a particular recommendation?
16:49:42 <ski> @karma- unused_nick
16:49:42 <lambdabot> unused_nick's karma lowered to -1.
16:49:44 <ski> @karma+ unused_nick
16:49:44 <lambdabot> unused_nick's karma raised to 0.
16:49:48 <geekosaur> the C karma thing was fixed, and then state lost
16:49:53 <sipa> @karma- c++
16:49:53 <lambdabot> c++'s karma lowered to -9.
16:49:53 <monochrom> oh wait, I guess people took the time to downvote C afterall :)
16:49:56 <sipa> lol
16:49:57 <HeladoDeBrownie> geekosaur, naturally, although ops might not be around, as was often the case in this instance.
16:49:59 <ski> zomg ^
16:50:02 <geekosaur> ("C++" is special cased)
16:50:02 <zomg> oh
16:50:15 <zomg> right does it actually start at karma 1 instead of karma 0
16:50:22 <zomg> 'cause I don't remember anyone ever @karma+'ing me :P
16:50:25 <sipa> @karma- c#
16:50:25 <lambdabot> c#'s karma lowered to 1.
16:50:50 <ski> zomg : i think it starts at `0', so someone must have incremented your count ..
16:51:00 <zomg> guess so
16:51:02 <geekosaur> we have ops around the world and it's possible to summon them at need, although for that kind of thing it's better to pop into #haskell-ops (see /topic) and discuss
16:51:35 <sipa> @karma sipa
16:51:35 <lambdabot> You have a karma of 5
16:51:37 <sipa> :o
16:51:47 <sipa> oh, this isn't blah
16:52:26 <geekosaur> heh
16:55:43 <merijn> contiver: optparse-applicative seems fairly popular? But I have no strong opinions
17:02:59 <contiver> merijn: I'll look into that then, thanks :)
17:05:27 <cin> what's up with hackage
17:05:33 <cin> 504 Gateway Time-out
17:08:57 <Fuuzetsu> it's dead jim
17:09:02 <sm> contiver: cmdargs and optparse-applicative seem to be about equivalently powerful. cmdtheline is another less popular one
17:09:29 <Fuuzetsu> http://status.haskell.org/
17:09:33 <sm> cmdargs has the best docs
17:11:32 <contiver> sm: saw cmdargs mentioned before asking here, so I guess I can't go too wrong starting with any of those two.
17:21:05 <meretrix> Is acid-state appropriate for storing data on the order of 100 million events?
17:40:59 <codehero> what's the best way to define a multiline string?
17:41:59 <geekosaur> string gaps is the usual way
17:42:23 <codehero> string gaps?
17:42:32 <geekosaur> http://lpaste.net/92725
17:43:15 <codehero> okay, cool. thank you ^^
17:44:09 <vanila> I always used unlines [ "line one" , "line two" ]
17:47:32 <cin> string  gaps  are awful, better to use concat and a list
17:48:15 <cin> half the letters you want to use are special escape sequences to the following line like \n will be a parse error. the string gap syntax is just garbage
17:48:43 <codehero> unlines also sounds like a good idea
17:49:26 <codehero> it also seems to have the advantage that emacs can correctly indent it :P
17:51:41 <codehero> does haskell also have something like execvp?
17:52:05 <codehero> where the new process replaces the current one
17:53:41 <codehero> ah, found it
17:55:56 <spopejoy> any pointers for using State monad within map? or actually map->map ...
17:57:22 <spopejoy> if I call a function returning State a b, and within that function I want to map over a list ... and within the mapping function, I want to get/modify state ...
18:00:27 <halvorg> I want to hash passwords for storage in a database, any leading library for this?
18:00:53 <halvorg> pwstore-fast seems nice from hackage description
18:01:59 <simpson> On a scale of "You're cool and your idea is cool too" to "I WILL HUNT YOU DOWN", how bad is it to have a newtype monad transformer, and hand-derive my own Monad instance so that I can fill out a definition of fail which isn't partial?
18:12:26 <finlandssvenska> has anyone used happy?
18:12:30 <finlandssvenska> the parser generator
18:13:14 <pavonia> Yes, anyone has
18:13:55 <finlandssvenska> anyone here I mean
18:14:00 <vanila> pavonia, that is not not helpful
18:15:09 <spopejoy> let me try to actually enumerate the use case. 1) The function is [Braid] -> [[(Phrase,Int)]]. Each Braid has a list [Strand]; from each Strand I create (Phrase,Int). Thus it's map . map in structure. 2) That Int in the pair has to cycle through a modulo, let's say 4, such that if the first Braid results in [(_,0),(_,1)], the next Braid would generate [(_,2),(_,3),(_,0)], the next [(_,1)], and so forth. Winding an i
18:15:09 <spopejoy> ncrementor through two map calls would seem to be a good job for State. But I can't get my head around it.
18:15:24 <pavonia> finlandssvenska: Why are you asking?
18:16:08 <finlandssvenska> just curious as to whether it's any good... kind of a parsing and haskell noob
18:16:24 <spopejoy> I'm also wondering if a Continuation monad would make sense, not that I have any f'ing idea where to start with that.
18:16:37 <vanila> finlandssvenska, I recommend against it, parser combinator libraries like Parsec or ReadP are better because they don't require a preprocessing stage
18:17:18 <finlandssvenska> alright
18:18:40 <pavonia> For complex grammars writing Parsec parsers can become error-prone quickly, though
18:28:11 <finlandssvenska> hmm
18:31:14 <codehero> hmm
18:31:24 <codehero> executeFile doesn't return to the original process
18:31:28 <codehero> ummm
18:31:45 <codehero> i guess i need to fork it
18:32:54 <lpaste> spopejoy pasted “State?” at http://lpaste.net/110570
18:33:36 <spopejoy> ok state question as a pastie: http://lpaste.net/110570 . cmon friday nite coders!
18:37:13 <codehero> come on. haskell has to have some way of doing that
18:38:05 <benzrf> @faq
18:38:05 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
18:38:09 <benzrf> D:
18:38:13 <benzrf> i keep forgetting
18:38:16 <benzrf> @nobotsnackforyou
18:38:16 <lambdabot> Unknown command, try @list
18:39:02 <codehero> it's not there
18:39:40 <codehero> what i want to do is to start an external process. let's say for example sh and then return to my original haskell process when sh terminates
18:39:40 <jle`> ski: that's indeed interesting
18:39:55 <spopejoy> codehero: have you tried createProcess?
18:42:02 <codehero> spopejoy: i haven't but if i understand it correctly then it'll spawn in the background and i'd be able to talk to it via stdin and stdout
18:42:52 <spopejoy> codehero: yes, and readProcess is even simpler if you just want output ...
18:43:10 <cody__> anyone else been getting some trouble from Hackage?
18:43:12 <codehero> but i don't really want interaction
18:43:25 <ski> jle` : yes :)
18:43:51 <codehero> it should work sort of like a shell does. you run a program and that program "replaces" the shell
18:44:03 <codehero> when the program terminates it returns to the shell
18:45:15 <spopejoy> sure, but do you want the user to interact with that shell? that's not very simple outside of sh. If you just want to run a lengthy process, simple, but otherwise you're building a shell (which you can do with createProcess)
18:46:31 <codehero> yes, i want the user to interact with the shell
18:47:14 <L8D> What's the function to filter out the first element that returns true in a list instead of all?
18:47:32 <ski> @type find
18:47:32 <lambdabot> (a -> Bool) -> [a] -> Maybe a
18:47:44 <L8D> i.e. filter (/= 1) [1 2 1 2 1] -> [2 1 2 1]
18:47:55 <ski> oh, the other way around
18:48:00 <L8D> yea
18:48:06 <simpson> :t splitAt
18:48:07 <lambdabot> Int -> [a] -> ([a], [a])
18:48:15 <simpson> Er, wait, there's a split-on-predicate, I think.
18:48:19 <spopejoy> codehero: hmm, so you'd probably want the haskell process to bg 21:46 <simpson> Er, wait, there's a split-on-predicate, I think.
18:48:23 <zwer_> :t find
18:48:24 <lambdabot> (a -> Bool) -> [a] -> Maybe a
18:48:24 <spopejoy> darn emacs
18:48:33 <spopejoy> codehero: hmm, so you'd probably want the haskell
18:48:33 <spopejoy>                  process to bg
18:48:35 <zwer_> > find even [1,3,5,6,7]
18:48:36 <lambdabot>  Just 6
18:48:45 <simpson> @hoogle (a -> Bool) -> [a] -> ([a], [a])
18:48:47 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
18:48:47 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
18:48:47 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
18:48:50 <l0cust> :t find
18:48:51 <lambdabot> (a -> Bool) -> [a] -> Maybe a
18:48:57 <jle`> i remember when i first learned haskell, `find` was the hardest thing ever to work with
18:48:58 <simpson> Ah, break is what I'm thinking of.
18:49:02 <ski> > delete 1 [0,1,0,2,0,1,0]
18:49:03 <jle`> because i didn't know how to work with Maybes v.v
18:49:04 <lambdabot>  [0,0,2,0,1,0]
18:49:04 <ski> > [0,1,0,2,0,1,0] \\ [2,1]
18:49:06 <lambdabot>  [0,0,0,1,0]
18:49:13 <L8D> :t delete
18:49:14 <lambdabot> Eq a => a -> [a] -> [a]
18:49:22 <L8D> ski: ok delete actually works
18:49:26 <l0cust> jle`: maybes are a bit silly
18:49:33 <L8D> ski: thanks I guess
18:49:37 <jle`> maybes are the best thing ever tho :
18:49:39 <ski> but it requires the element to remove, rather than a predicate
18:49:39 <jle`> :|
18:49:56 <codehero> spopejoy: heh. emacs is great. yes having the haskell process bg would be awesome but then it would just return to the shell it was opened from but i want this to work with any interactive process i want
18:50:04 <L8D> ski: My old code was "filter (/= x) xs"
18:50:05 <spopejoy> anybody feeling up to my pastie state question????  http://lpaste.net/110570
18:50:16 <L8D> ski: But that had the bug of removing more than one.
18:50:22 * ski nods
18:50:54 <L8D> How about we all build an editor in Haskell?!?!
18:51:07 <L8D> we did it with a window manager didn't we?
18:51:08 <spopejoy> codehero: do you know how to even do this in sh?? [I don't, I just know how to type Ctrl-Z]
18:51:18 <jle`> there's yi
18:51:41 <L8D> So why don't we all use yi over emas?
18:51:43 <L8D> emacs*
18:51:54 <spopejoy> Because Emacs Is The One True Editor
18:51:56 <ski> emacs has more libs ?
18:51:59 <codehero> well, yeah. that's what you do, ctrl-z
18:52:11 <codehero> L8D: i don't think that yi can compete with emacs
18:52:31 <spopejoy> freakin flycheck + haskell is serious luv
18:52:31 <codehero> i wish rms would've been a haskell nerd
18:53:04 * ski thinks the project that's attempting to rebase Emacs on Guile is interesting
18:53:46 <ski> (where Guile is obviously then growing an Emacs Lisp part)
18:55:15 <L8D> @pl tasks ts = either (:ts) (flip delete ts)
18:55:15 <lambdabot> tasks = ap (either . flip (:)) (flip delete)
18:55:24 <l0cust> codehero: I don't think Haskell is a gread language for an editor, honestly
18:55:40 <codehero> hmm. probably not
18:56:03 <L8D> @pl scanl (ap (either . flip (:)) (flip delete)) []
18:56:03 <lambdabot> scanl (ap (either . flip (:)) (flip delete)) []
18:56:21 <jle`> would haskell be good for a scripting language
18:56:31 <jle`> if i had to use a scripting language i might use purescript
18:56:43 <L8D> jle`: With use of the right libraries it could
18:57:27 <L8D> @hoogle delet
18:57:27 <lambdabot> Data.HashTable delete :: HashTable key val -> key -> IO ()
18:57:27 <lambdabot> Data.List delete :: Eq a => a -> [a] -> [a]
18:57:27 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
18:57:34 <akurilin> question: what's the difference between blaze.markup and blaze.html
18:57:44 <akurilin> they contain a MarkupM and a HtmlM
18:58:11 <L8D> ski: deleteBy
18:58:44 <jle`> L8D: i think it is the compiled nature that makes me hesitant
18:59:04 <L8D> jle`: just use runhaskell and alias it to hs
18:59:18 <jle`> hm
18:59:24 <L8D> jle`: compiles and runs as fast a ruby or python JIT or v8 optimizations
18:59:34 <jle`> ah
18:59:44 <akurilin> ooh I think markup and html were merged into the same thing eventually
18:59:49 <jle`> can i runhaskell with libraries and stuff loaded?
19:00:28 <L8D> jle`: All it does is compile to a tmp directory and run the executable
19:00:36 <L8D> but it compiles with flags to compile faster
19:00:48 <L8D> instead of compile for speed
19:01:20 <jle`> hm
19:01:28 <jle`> i could just do that instead
19:01:50 <ski> L8D : oh, right
19:02:53 <L8D> Does GHCJS do FRP?
19:03:04 <benmachine> I'm not sure that's *literally* what runhaskell does, I think it uses a ghci-like mechanism
19:04:18 <finlandssvenska> runhaskell is just a shell script
19:04:19 <L8D> benmachine: I know at least you can trust that `ghc a.hs && ./a` and `runhaskell a.hs` will do the same thing. :/
19:04:25 <finlandssvenska> #!/bin/sh
19:04:25 <finlandssvenska> exedir="/usr/lib/ghc-7.8.3/bin"
19:04:25 <finlandssvenska> exeprog="runghc"
19:04:25 <finlandssvenska> executablename="$exedir/$exeprog"
19:04:25 <finlandssvenska> datadir="/usr/share"
19:04:27 <finlandssvenska> bindir="/usr/bin"
19:04:30 <finlandssvenska> topdir="/usr/lib/ghc-7.8.3"
19:04:32 <finlandssvenska> #!/bin/sh
19:04:35 <finlandssvenska> exec "$executablename" -f "$bindir/ghc" ${1+"$@"}
19:04:37 <finlandssvenska> oops
19:05:42 <benmachine> L8D: sure, that's a good description of what it does, just saying that it might not ever actually create an executable file to run
19:06:26 <spopejoy> how many ways shall I beg that somebody look at my question. Or does everyone just uniformly loath the State monad?  http://lpaste.net/110570
19:07:15 <codehero> hmmm
19:07:28 <codehero> i think i now know how to actually do this
19:07:39 <L8D> spopejoy: I'm pretty sure you shouldn't use State. :P
19:07:51 <codehero> in my original c code i first forked and then called execpv. i guess i'll have to do the same in haskell
19:10:03 <Rembane> spopejoy: What do you want the code to do?
19:10:29 <L8D> spopejoy: you are using computePhrase as a function but defined it as a list
19:11:06 <spopejoy> L8D: computePhrase is irrelevant, that's just placeholder code.
19:12:40 <spopejoy> Rembane: within a map.map context, I want to "globally" cycle a value through [0..modulo-1], ie the Int value in the (Phrase,Int) pair
19:12:41 <L8D> spopejoy: You realize that take 1 . cucle . [0..x] is always 0
19:12:46 <L8D> er... [0]
19:13:05 <L8D> @pl f x = take 1 . cycle . [0..x]
19:13:05 <lambdabot> f = ((take 1 . cycle) .) . enumFromTo 0
19:13:10 <Rembane> spopejoy: Sounds iffy.
19:13:30 <L8D> @pl f x = take 1 . cycle $ [0..x]
19:13:30 <lambdabot> f = take 1 . cycle . enumFromTo 0
19:13:42 <spopejoy> Rembane: what sounds iffy, using state? Hopefully not my requirement
19:13:47 <L8D> > take 1 . cycle $ [0..10]
19:13:49 <lambdabot>  [0]
19:13:51 <L8D> > take 1 . cycle $ [0..100]
19:13:52 <lambdabot>  [0]
19:13:55 <Rembane> spopejoy: ^^
19:13:55 <L8D> > take 1 . cycle $ [0..-100]
19:13:56 <lambdabot>  Not in scope: ‘..-’
19:13:57 <lambdabot>  Perhaps you meant ‘...’ (imported from Control.Lens)
19:14:06 <L8D> > take 1 . cycle $ [0..(-100)]
19:14:08 <lambdabot>  *Exception: Prelude.cycle: empty list
19:14:09 <lucky> Hi.  I've got several types that are similar but not interchangeable, let's say Ab Cd Ef Gh, I'm writing a function that can read a string into any of these types but there seems to be no way to pass the type to the function at runtime, or am I just going about this in a very wrong way?
19:14:59 <L8D> lucky: imlpement that function as a typeclass
19:15:22 <lpaste> spopejoy revised “State?”: “No title” at http://lpaste.net/110570
19:15:40 <L8D> typeclass MyTypeClass a where myFunc :: String -> a
19:15:51 <spopejoy> OK I edited it. My intention is to cycle values through [0..modulo - 1] "globally"
19:16:49 <L8D> instance MyTypeClass Ab where myFunc s = (somethingWith s :: Ab)
19:16:55 <spopejoy> So hopefully I haven't derailed the entire discussion. It could be a simple incrementor.
19:17:24 <lucky> L8D: okay, i'll have to do some reading, thanks
19:18:17 <spopejoy> But the point is, the state has to make it through two "map" calls to be constantly incrementing. I could do this with complicated folds or recursive functions (a la clojure or something), but c'mon, isn't there some haskell magic that can maintain this state for me?
19:18:19 <merijn> Is my understanding that fundeps have better inference than type families correct?
19:21:03 <L8D> spopejoy: I think I get it now...I'll see what I can do
19:23:50 <L8D> spopejoy: what you should do it compute the counter seperately from doing the maps
19:23:59 <L8D> spopejoy: Just compute the counter based on lengths
19:24:12 <zwer_> @hoogle "[a] -> Int -> ([a], [a])
19:24:13 <lambdabot> Parse error:
19:24:13 <lambdabot>   "[a] -> Int -> ([a], [a])
19:24:13 <lambdabot>   ^
19:24:19 <zwer_> @hoogle [a] -> Int -> ([a], [a])
19:24:19 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
19:24:20 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
19:24:20 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
19:25:07 <trap_exit> what idiotic thing did I do to get this error: https://gist.github.com/anonymous/d941c1c7917c3c344fa8 ... and how do I fix it?
19:25:15 <trap_exit> I wake up thi smonring, and WAAAAH, ghc is broken
19:25:35 <trap_exit> do I want to use monads-tf or mtl ? and how do I tell ghc which one to use
19:26:45 <L8D> spopejoy: you can get the number by performing "(% (modulo - 1)) . length . concat
19:26:57 <L8D> concat flattens the array
19:27:01 <spopejoy> L8D: sure, could zipWith .... cycle [0..modulo-1] or something too
19:27:32 <spopejoy> but it's hard to un-flatten when done
19:27:49 <spopejoy> these aren't of the same size, so that means going back through and unflattening
19:27:53 <L8D> spopejoy: nonono, you are calculating the number seperately
19:28:00 <L8D> you don't need to "unflatten"
19:28:19 <L8D> you only flatten to get the number
19:28:41 <L8D> then you use the "mod" function
19:28:45 <jollygood> is it possible to pattern match *last* two elements in a list?
19:28:57 <spopejoy> L8D: how am I supposed to know where I am in a sublist of a list?
19:29:11 <jle`> jollygood: not directly
19:29:21 <L8D> spopejoy: hm...
19:29:22 <jollygood> that is a shame
19:29:32 <spopejoy> I've mapped into the top list; it has an variable number of sublist items.
19:29:44 <jle`> jollygood: it has to do with what lists actually are, actually
19:29:50 <jle`> how would taht work, for example, with infinite lists?
19:29:56 * spopejoy looking fondly at older procedural versions of this same code
19:30:04 <L8D> spopejoy: I believe you can do cycle [0..modulo - 1] zipped into the list
19:30:16 <jle`> the reason you can pattern match on lists is because they literally are just a data type with an element and a pointer to the next list
19:30:19 <spopejoy> ... flattened.
19:30:31 <jollygood> jle` it wouldn't, like some other useful things don't work with infinite lists. reverse, foldl
19:30:33 <jle`> so when you pattern match out...you are just getting the two fields of the tuple :)
19:30:39 <L8D> spopejoy: I believe there is a way to zip into lists of lists without flattening
19:30:48 <jle`> jollygood: i meant, structurally.  would it be non-terminating?
19:31:00 <jle`> you can use pattern synonyms, if you want to
19:31:18 <jle`> foo (reverse->(x:xs)) = ...
19:31:22 <jle`> er wait, that's view patterns
19:31:31 <L8D> jollygood: you can pattern match for [x, y]
19:31:35 <trap_exit> should I "ghc-pkg hide" mtl or monads-tf ?
19:31:39 <trap_exit> which one of the two packages is about to die?
19:31:53 <jle`> a pattern match is a structural thing...it basically directly breaks up the actual representation of the data type in memory, sorta
19:32:01 <jollygood> now that I think about it, no reason why pattern matching last element wouldn't work with infinite lists.. it would just never match
19:32:03 <spopejoy> why pattern match? why not just guard | last foo == bar?
19:32:18 <jle`> a list is just a tuple, so pattern matching is just getting the components of the tuple
19:32:45 <spopejoy> I was thinking that pattern matching on a list is actually matching on specific inhabitants of the list type
19:32:46 <jle`> jollygood: how would you handle it if there were other possible matches after the reverse match?
19:33:17 <jle`> how would you "skip" it? :)
19:33:25 <jollygood> not getting the question
19:34:14 <jle`> so if you could reverse pattern match as (xs :~ x), to get the last element and the rest, how would you handle foo (xs :~ x) = ...; foo (x:xs) = ..., for infinite lists?
19:34:16 <spopejoy> It seems like State is more for long-term state over diverse functions that have the same "dimensionality" with respect to the state. That is, if State is good for friggin' anything
19:34:19 <jle`> which pattern would it match on?
19:35:00 <jollygood> xs :~ x, x being first element, and xs rest?
19:35:46 <jollygood> wait, my client is changing that with silly smileys. let me copy/paste to text editor
19:35:47 <merijn> trap_exit: You should use mtl
19:35:54 <merijn> trap_exit: Almost no one uses monads-tf
19:36:00 <L8D> @hoogle [[a]] -> [b] -> [[(a,b)]]
19:36:00 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
19:36:00 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
19:36:00 <lambdabot> Data.ByteString.Builder.Prim (>*<) :: Monoidal f => f a -> f b -> f (a, b)
19:36:12 <L8D> derp
19:36:21 <trap_exit> merijn: cool,k thanks, there were some idiotic SO answers from past years saying monads-tf were the future and I was almost convinced
19:36:43 <L8D> @hoogle [a] -> [Int] -> [[a]]
19:36:43 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
19:36:44 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
19:36:44 <lambdabot> Prelude drop :: Int -> [a] -> [a]
19:36:54 <merijn> trap_exit: They use two alternative implementation techniques, but it turns out the type families one doesn't really improve on the fundeps one all that much and like 80% of people use mtl
19:37:00 <jollygood> jle` if (x :~ x) was first, you would get infinite loop.  if (x:xs) was first (as it should be), it would be matched first
19:37:28 <trap_exit> merijn: what was type families supposed to imporve on? improved performance? improved generality? in what direction was it supposed to improve ?
19:37:35 <jollygood> the reason I wanted to pattern match last two, by the way, was to avoid this mess. calling reverse three times: http://lpaste.net/110576
19:37:35 <spopejoy> L8D: this example, while real, is nonetheless trivial. What if I really needed more complicated state than just cycle [0..n]? It seems like there should be some way to use State to do it.
19:37:43 <merijn> trap_exit: Prettier types/confusing type errors
19:38:09 <jle`> jollygood: well, you understand why it is fundamentally different than a pattern match, right?
19:38:12 <merijn> trap_exit: eh, less confusing type errors, obviously
19:38:17 <spopejoy> although ... I wonder if there's a LENS for that
19:38:24 <L8D> spopejoy: the real world solution would be to structure your data to not use [[(Int,Bool)]] and instead use something more flattenable
19:38:25 <jle`> jollygood: pattern matches match on the actual structure of the data type
19:38:25 <jollygood> sure
19:38:29 <jle`> jollygood: lists are literally just tuples
19:38:29 <trap_exit> merijn: right, yeah, some mtl errors initially reminded me of C++ template errors
19:38:35 <trap_exit> merijn: but I find then more readalbe now
19:38:42 <jollygood> pattern match works on constructors.. still, i hoped there would be one
19:38:47 <merijn> trap_exit: You learn to pick up what's important over time :)
19:38:48 <jle`> jollygood: or well, a product, or nil
19:38:51 <trap_exit> merijn: they should have something simple like; "dude, in your RWS monad, you switched W and S" instead of what it currently outputs
19:39:00 <gennady> Oh hey jollygood, I was looking at that code you sent me why did you put ord in front of the vars? I thought you had to do stuff like x::Double
19:39:02 <spopejoy> L8D: as in a tree or somthing?
19:39:11 <jle`> jollygood: if you find yourself using reverse a lot, and having to find the last item a lot, it is a sign that you might be using the wrong data structure
19:39:15 <merijn> trap_exit: There was a nice talk at IFL2013 on simpler/better type errors, it's just a really hard topic
19:39:25 <jle`> jollygood: there are data structures that offer O(1) access to the beginning and end of a sequence
19:39:31 <merijn> trap_exit: Because "better" means you have to realise what the user intended from some wrong context
19:39:34 <jle`> jollygood: lists are actually of a pretty narrow usage case
19:39:42 <jollygood> any improvement suggestions for that code, by the way?  greet ["one", "two"] -> "one and two", greet ["one", "two", "three"] -> "one, two and free". (greet is probably a crappy name)
19:40:08 <jollygood> I do not need O(1) in here
19:40:20 <jle`> jollygood: by O(1), i mean direct access to be able to pattern match on the end of the list
19:40:30 <trap_exit> merijn: yeah, and if you have a compiler that can make suggestions; you might as well as make it fix compiler errors
19:40:30 <jle`> the end of the list is always-there, and is a part of the structure
19:40:37 <trap_exit> merijn: and, at taht point, we have HaskellSkyNet
19:40:44 <merijn> Any experienced fundeps abusers around? I'm looking for a way to construct a typeclass "Foo a b" such that for a specific 'a' and 'b' GHC is able to infer that such an instance can never exist
19:40:50 <jollygood> I don't think performance of my code is bad, I am reversing, but that is still just O(N), no? since O(3N) == O(N). I am concerned with messy code
19:40:51 <jle`> Data.Seq offers this; just like how [] has the head of the list as a part of its internal structure, Seq has the last element of the list as
19:41:24 <jollygood> and it would still be O(N) even if you used a collection with O(1) last element access
19:41:33 <L8D> trap_exit: SkyNet was written in Erlang. Arnie-Terminator was written in Haskell. T-1000 was written in JavaScript
19:42:13 <jollygood> anyway, as far as list goes, how could I improve above code?
19:42:19 <L8D> Well....Ada with sprinkles of erlang
19:44:56 <jle`> jollygood: by O(1), it was less a point about the algorithmic complexity and more about the fact that the last and first elements of Seq are...the "same", and neither is more accessible than the other
19:45:32 <jle`> just like head is easy to get out of a list, head and tail are equally easy, none more priveleged than the other, in Seq
19:46:03 <jollygood> well, if we aren't concerned with complexity, there's always last :: [a] -> a :)
19:46:31 <jle`> jollygood: heh. but the last element isn't a "part" of the list data type.  it has to be computed
19:46:46 <spopejoy> is there a reason why so many functional languages start off with [] as a cons structure?
19:46:50 <jle`> it's like f (x,_) = x, vs f (x,y) = x + y
19:47:17 <jollygood> jle` do you use Text as your default string type?
19:47:18 <l0cust> spopejoy: comes from lisp
19:47:46 <trap_exit_> jollygood: if you care about performance, I recommend LazyText
19:47:53 <spopejoy> sure, but lisp is old. haskell is new-ish.
19:47:59 <trap_exit_> the mnost common string ops people really do is probably ++
19:48:07 <zwer_> spopejoy how else would you represent a list?
19:48:08 <trap_exit_> and for LazyText, ++ is (I think) consta time
19:48:15 <spopejoy> well, like Seq
19:48:24 <merijn> trap_exit: "It depends"
19:48:32 <trap_exit_> merijn: explain more :-)
19:48:36 <spopejoy> as in back it with a structure that has a constant-time length, etc.
19:48:43 <Jafet> Seq cannot represent infinite lists.
19:48:46 <merijn> trap_exit: It can fuse, which would make it near constant time, but ideally you'd want a DList approach
19:48:48 <jollygood> trap_exit I usually don't care about string performance, though. when I do, I do use Text. but I default to String, for convenience
19:48:54 <Jafet> (Or lazy lists, for that matter.)
19:49:01 <trap_exit> merijn: http://xkcd.com/386/
19:49:05 <l0cust> spopejoy: thing is, in most languages, lists are variable-size. You can't have variable-size arrays. Haskell is immutable, so it really doesn't make sense to use cons structures as the default vector type
19:49:25 <trap_exit> merijn: wait what? I thought LazyText ++ is "create a node, point first half to first string; point second half to second thing" = contant time
19:49:30 <trap_exit> but tell me where I'km wrong :-)
19:49:36 <merijn> trap_exit: If you do it once, yes
19:49:42 <spopejoy> but it's trivial to *represent* a list with an array behind the scenes. Array copy is fast.
19:49:54 <trap_exit> merijn: oh, is there a "flatten" aspect if the text gets 'too deep' ?
19:49:57 <l0cust> trap_exit: I thought your xkcd woul7d be this one - https://xkcd.com/163/
19:49:58 <merijn> trap_exit: But suppose you want to do fold ++ over a list it can become linear
19:50:12 <merijn> > foldr (++) z [a,b,c,d]
19:50:13 <lambdabot>  Couldn't match expected type ‘[a]’
19:50:13 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match e...
19:50:13 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match e...
19:50:13 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match e...
19:50:13 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match e...
19:50:16 <merijn> aww
19:50:28 <merijn> > foldr (++) z [a,b,c,d] :: [Expr]
19:50:29 <lambdabot>  Couldn't match expected type ‘[Debug.SimpleReflect.Expr.Expr]’
19:50:29 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match e...
19:50:29 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match e...
19:50:29 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match e...
19:50:29 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match e...
19:50:33 <Jafet> > foldr (+) z [a,b,c,d]
19:50:34 <lambdabot>  a + (b + (c + (d + z)))
19:50:40 <merijn> oh
19:50:40 <trap_exit> merijn: well fine, if your inpjut is$n$ strings, then sure, concating them should take O(n) time; agreed
19:50:41 <merijn> duh
19:50:45 <spopejoy> but I agree about infinite/lazy lists being isomorphic with cons lists
19:50:49 <Jafet> That works, do you mean foldl?
19:50:51 <merijn> trap_exit: But you can do bettr!
19:51:02 <merijn> trap_exit: You can concat n strings in O(1)! :)
19:51:05 <trap_exit> merijn: well, don't leave us hanging
19:51:14 <trap_exit> merijn: because haskell is lazy'
19:51:19 <trap_exit> and creates a thunk that when needed, concats the strings
19:51:27 <trap_exit> but creaging the thunk would take O(n) time
19:51:31 <Jafet> jollygood: write a takeFromEnd function and use it as a view.
19:51:37 <merijn> trap_exit: I'm looking for a good example
19:52:18 <jollygood> Jafet I don't know what "use it as a view" means
19:52:38 <merijn> trap_exit: This seems like a decent explanation: http://h2.jaguarpaw.co.uk/posts/demystifying-dlist/
19:53:11 <Jafet> > let takeFromEnd n = reverse . take n . reverse; f (takeFromEnd 2 -> [a,b]) = a ++ b in f ["a","b","c"]
19:53:12 <lambdabot>  "bc"
19:53:43 <jollygood> I still don't know what "use it as a view" means :)
19:54:52 <jollygood> as far as rewriting my function goes, we need both last two, and the all the prior arguments, no? so we need something more than takeFromEnd. something likesplitAt
19:55:00 <jollygood> all the prior elements*
19:55:05 <Jafet> Do that, then.
19:55:11 <jollygood> I am, it is fugly
19:55:18 <jollygood> http://lpaste.net/110576
19:55:32 <spopejoy> maybe there's some lensy way to do this. Given a structure [[(String,Int)]], say [[("hi",0),("hello",0),("howzit",0)],[("goodbye",0),("bye",0)]], how to replace those 0's with a monotonic series?
19:55:39 <Jafet> I don't see a splitAtFromEnd in there.
19:56:23 <jollygood> I could write it, but then I would just hide the ugliness behind that function
19:56:37 <lucky> Is it possible to pass a type as a parameter?
19:56:42 <merijn> lucky: No
19:56:49 <merijn> lucky: Types don't exist at runtime
19:56:51 <edwardk> > [[("hi",0 :: Int),("hello",0),("howzit",0)],[("goodbye",0),("bye",0)]] & partsOf biplate.traversed %@~ const
19:56:52 <lambdabot>  [[("hi",0),("hello",1),("howzit",2)],[("goodbye",3),("bye",4)]]
19:57:05 <spopejoy> aww yeah!!
19:57:07 <Jafet> Heh, the horse speaks
19:57:31 <edwardk> > [[("hi",0 :: Int),("hello",0),("howzit",0)],[("goodbye",0),("bye",0)]] & indexing (traverse.traverse.traverse) %@~ const
19:57:32 <lambdabot>  [[("hi",0),("hello",1),("howzit",2)],[("goodbye",3),("bye",4)]]
19:57:38 <edwardk> that version is less magic
19:57:38 <jollygood> edwardk is there some cool Lens one liner that would do this? http://lpaste.net/110576
19:57:41 <merijn> edwardk: You seem like the insane masochistic typing type to know the answer to my question :)
19:58:05 <jollygood> <jollygood> any improvement suggestions for that code, by the way?  greet ["one", "two"] -> "one and two", greet ["one", "two", "three"] -> "one, two and free". (greet is probably a crappy name)
19:58:11 <jollygood> probably not, but who knows
19:58:14 <spopejoy> edwardk: actually the real problem needs to cycle, say [0..4]. Ideas?
19:58:19 <edwardk> jollygood: not really =)
19:58:36 <merijn> edwardk: Is it possible to create a multiparam typeclass "Foo a b" (regardless of how much fundeps abuse it takes) where GHC will succesfully conclude that "Foo a b" can never happen (for a specific combination of 'a' and 'b')
19:58:45 <edwardk> > [[("hi",0 :: Int),("hello",0),("howzit",0)],[("goodbye",0),("bye",0)]] & indexing (traverse.traverse.traverse) %@~ \i _ -> mod i 2
19:58:46 <lambdabot>  [[("hi",0),("hello",1),("howzit",0)],[("goodbye",1),("bye",0)]]
19:59:04 <edwardk> ^- change 2 appropriately
19:59:19 <vanila> lucky, not in haskell but there are languages where you can like System F (which haskell is based on)
19:59:35 <edwardk> merijn: that sounds fundamentally at odds with the open universe assumption
19:59:50 <spopejoy> edwardk: much thanks
19:59:57 <lucky> I need to type something in different ways depending on runtime factors
20:00:03 <merijn> edwardk: :(
20:00:25 <merijn> edwardk: I managed to do it easily enough with closed type families, but GHC is to dumb to get my point :)
20:00:30 <lucky> or i guess it doesn't have to be at runtime, but i don't want to write dozens of nearly identical functions just changing the type definition
20:00:36 <vanila> lucky, what about using  data Tagged = I Int | S String | ...
20:00:48 <vanila> lucky, hmm can i see?
20:00:56 <merijn> I have a friend who's patched it, but I have no clue when that patch will wind up in GHC and I'd like to get it work ASAP >.>
20:00:57 <Jafet> > (\(x,y) -> x ++ " and " ++ y) . (intercalate ", " . init &&& last) $ ["a", "b", "c", "d"]
20:00:57 <edwardk> merijn: can you just make a closed type family be the thing you need of kind constraint?
20:00:58 <lambdabot>  "a, b, c and d"
20:01:07 <lucky> vanila: it's really ugly (I'm very new to Haskell), but yes hold on
20:01:13 <merijn> edwardk: Yeah, but GHC is to dumb to see it
20:01:16 <jollygood> Jafet whoa
20:01:18 <edwardk> strange
20:01:35 <merijn> edwardk: Not really, the exhaustiveness check for GADTs is kinda stupid
20:01:41 <edwardk> merijn: oh, that
20:01:43 <Jafet> (It could be even prettier with acme-cadre.)
20:01:44 <edwardk> good luck =)
20:02:01 <merijn> edwardk: There's people working on improving it, but like I said I don't wanna wait until 7.10 before being able to write my code >.>
20:02:18 <jollygood> there are useful acme- libraries? I only used acme-cutegirl so far
20:02:24 <edwardk> Jafet: what, no oxford comma?
20:02:42 <gn0> hello
20:02:59 <merijn> I wonder if there's non GADT approaches that might work
20:03:18 <finlandssvenska> sublime text 3 doesnt highlight things correctly
20:03:23 <finlandssvenska> and i hate it
20:03:32 <finlandssvenska> not on topic here, but still
20:03:45 <lucky> vanila: http://lpaste.net/110580 not all of it, but the relevant bits.  The last two lines.  I'd like to generalize reading into any of the currency types with just one function
20:03:48 <L8D> How am I supposed to write f [] _ = []; f _ [] = []
20:03:53 <Jafet> Oxford commas are dumb, silly, and superfluous.
20:03:54 * edwardk catches a couple of hours of sleep before the talks.
20:04:27 <merijn> edwardk: pffft, I thought you didn't need sleep? :p
20:04:36 <edwardk> merijn: long week =)
20:04:48 <L8D> spopejoy: btw, I'm super close to the solution
20:04:49 <jollygood> as an added bonus, it even works with infinite strings. not that it needs to, but still neat
20:05:03 <L8D> spopejoy: and it's not very complicated
20:05:08 <jollygood> infinite list of strings, even
20:05:47 <vanila> lucky, i don't see what you want to generalize it across sorry
20:06:21 <merijn> edwardk: I've got something for you to dream about :p The rough sketch of what I'm trying to do is: http://lpaste.net/110431 i.e. have a set of N operations and M types that support a subset of those operations and I wanna statically check all the supported operations are actually implemented, I'm running out of ideas of what to try, so if anyone brilliant has an idea :p
20:06:54 <merijn> I thought about just having a different typeclass per operation, but then I don't have a good way of storing the relevant operations in the record :\
20:06:55 * edwardk dreams of other things.
20:06:57 <edwardk> night all =)
20:07:03 <merijn> edwardk: Night :)
20:07:04 <Jafet> jollygood: you can write splitAtFromEnd without reverse, which is equally lazy. \k xs -> f xs (drop k xs) where f xs [] = ([], xs); f (x:xs) (_:ys) = first (x:) $ f xs ys
20:07:08 <dreams> edwardk: night
20:07:18 <hiptobecubic> heh
20:08:10 <lucky> vanila: the type for rate or amount could be any of the currencies, not just the hard-coded ones there
20:10:00 <finlandssvenska> http://curl.io/get/n59bmzgk/b4b6d25a608ab54c32ccbeb8b8e4e62f8cb522b4
20:10:21 <finlandssvenska> see
20:11:21 <merijn> lucky: Typeclass can't help you, because if you want to support non-hardcoded currencies, how would you use a typeclass to read a nonexistent type?
20:11:25 <merijn> lucky: You may wanna read
20:11:37 <merijn> @hoogle Gabriel Gonzalez Scrap Your Typeclasses
20:11:37 <lambdabot> Did you mean: :: Gabriel Gonzalez Scrap Your Typeclasses
20:11:37 <lambdabot> No results found
20:11:38 <merijn> eh
20:11:41 <merijn> @google Gabriel Gonzalez Scrap Your Typeclasses
20:11:43 <lambdabot> http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
20:11:43 <lambdabot> Title: Haskell for all: Scrap your type classes
20:12:16 <L8D> spopejoy: http://lpaste.net/110570
20:12:17 <L8D> boom
20:12:30 <Jafet> LANGUAGE KitchenSink    -- rip glasgow-exts
20:12:30 <L8D> I mean that part of the code isn't tested
20:12:34 <L8D> whoops forgot a line
20:12:35 <merijn> Jafet: :D
20:12:43 <merijn> Jafet: I thought it was funny :)
20:12:54 <L8D> http://lpaste.net/110570
20:13:10 <merijn> Jafet: It works too! As soon as GHC gets patched to be smart enough...
20:13:36 <lucky> merijn: well I mean one of the types in data Currency = ....
20:13:43 <merijn> Right now GHC will produce "non-exhaustive pattern!" warning, but if you add the missing pattern it's a type error >.>
20:14:17 <lucky> rather than the two hard-coded in the last two lines of my paste
20:14:25 <L8D> spopejoy: http://lpaste.net/110570
20:14:34 <L8D> nooooooo I was too late
20:14:49 <L8D> I lost another one guys.
20:14:53 <L8D> I'm so sorry.
20:15:07 <L8D> I'm the reason haskell isn't as popular as it should be.
20:15:34 <xcthulhu> Hey, I was wondering: is there something like haskell-src-exts, but compiles and parses Core rather than raw Haskell syntax?
20:15:53 <jollygood> are there any other must-use warnings, like -fwarn-incomplete-patterns ?  that one catches a lot of bugs
20:16:15 <xcthulhu> I am working on a website which will have haskell exercises, and I am trying to blacklist various functions and modules
20:16:17 <L8D> jollygood: Just use -Wall
20:16:37 <merijn> xcthulhu: Read the SafeHaskell section of the GHC manual
20:16:47 <L8D> xcthulhu: It's called GHC I think
20:17:04 <jollygood> L8D I tried.. getting too much warnings. and many aren't critical
20:17:22 <merijn> xcthulhu: And I'm not quite sure there's a way to feed Core back into GHC, but I dunno whether there's a standalone parser for it
20:17:28 <jollygood> too many*
20:17:31 <L8D> jk. but it has options to export the compiled Haskell definitions instead of copmiling them to C or LLVM
20:17:44 <Cale> merijn: I seem to recall that was coming...
20:17:46 <merijn> xcthulhu: You might be better of restricting input code to no use IO?
20:17:56 <xcthulhu> Nah, that won’t fly
20:17:59 <jollygood> I am wondering why -fwarn-incomplete-patterns isn't default?
20:18:20 <xcthulhu> We want to have exercises where you use SQL and MongoDB and stuff
20:18:26 <xcthulhu> So IO has to be there.
20:19:23 <xcthulhu> I can walk the output of `parseFile` from haskell-src-exts, but I just thought maybe it might be easier to inspect if code is using a function or module in System FC
20:19:29 <Cale> xcthulhu: There's http://hackage.haskell.org/package/extcore
20:19:43 <Jafet> Use vm snapshots. Safe haskell code means nothing here.
20:19:52 <Cale> However, in GHC 7.8 apparently the support for external core is broken
20:20:02 <Cale> er, wait, no
20:20:02 <xcthulhu> Bums
20:20:04 <L8D> xcthulhu: What environment are you compiling for? You could try using GHCJS or Haste to have the user/whoever to run Haskell in their browser
20:20:15 <Cale> 6.8, maybe it's been fixed :)
20:20:26 <Jafet> (Or chroot, if you trust your kernel's implementation)
20:20:30 <Cale> https://www.haskell.org/ghc/docs/latest/html/users_guide/ext-core.html
20:20:37 <Cale> "Currently (as of version 6.8.2), GHC does not have the ability to read in External Core files as source."
20:20:43 <xcthulhu> L8D:  So this website already has exercises for other languages; everything is run inside of docker containers on cloud computers
20:20:45 <Cale> But that's in the latest user's guide
20:20:47 <Cale> :P
20:21:06 <L8D> xcthulhu: And you couldn't just run ghc inside those
20:21:17 <xcthulhu> I do run ghc inside of those
20:21:26 <L8D> xcthulhu: So what's your end goal now?
20:21:41 <xcthulhu> I just want to prevent people from using `reverse` somehow, so I can force them to code it from scratch
20:22:17 <L8D> xcthulhu: You should be able to compile GHC with a custom implementation of Prelude
20:22:30 <L8D> derp
20:22:36 <L8D> use GHC to compile with a custom prelude
20:22:39 <xcthulhu> Well, sometimes you want them to have reverse, and sometimes you don’t
20:22:40 <Cale> Or just import Prelude ()
20:22:44 <L8D> ^
20:22:48 <Jafet> :t F.toList . Seq.reverse . Seq.fromList
20:22:49 <lambdabot> [a] -> [a]
20:22:55 <L8D> Then inject all of the stuff you want to give them
20:23:58 <xcthulhu> Well, I don’t make all of the exercises; users make the exercises.  And every day they want to blacklist some new crazy thing
20:24:04 * Cale feels weird whenever someone uses the word "inject" in a way which isn't mathematically formal :D
20:24:20 <xcthulhu> Like Kleisli composition arrows from Control.Monad, for example
20:24:34 <L8D> @src (++)
20:24:35 <lambdabot> []     ++ ys = ys
20:24:35 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
20:24:35 <lambdabot> -- OR
20:24:35 <lambdabot> xs ++ ys = foldr (:) ys xs
20:24:45 <xcthulhu> So I can’t just hack Prelude, because I don’t know what people will want to blacklist; I need to make something flexible
20:24:51 <Jafet> :t map snd . sort . zip [1,0..]
20:24:53 <lambdabot> Ord b => [b] -> [b]
20:25:40 <xcthulhu> So I am afraid that derp solutions might not be good engineering :(
20:25:50 <Jafet> :t map snd . sortBy (comparing fst) . zip [1,0..] -- better type
20:25:51 <lambdabot> [b] -> [b]
20:25:59 <xcthulhu> @Cale:  extcore looks really promising
20:25:59 <lambdabot> Unknown command, try @list
20:26:07 <Cale> xcthulhu: Nah, just import Prelude differently
20:26:32 <Cale> xcthulhu: For each example, have an uneditable import Prelude line, which hides stuff that you want them to implement
20:26:39 <xcthulhu> What if they want to blacklist Control.Monad, or Control.Monoid?
20:26:59 <xcthulhu> Or just particular things from it?
20:27:44 <Cale> Okay, well, you could also just parse the user input with haskell-src-exts and make sure there are no import declarations in it.
20:28:04 <merijn> xcthulhu: Always compile with -XNoImplicitPrelude and have every exercise export it's own prelude which can hide whatever they want
20:28:19 <Cale> Though, I'm not sure how much it's worth trying to prevent people from sidestepping the exercises
20:28:36 <Cale> Like, they'd only be cheating themselves :P
20:29:08 <xcthulhu> Cale:  That’s where I’m at.  Blacklisting a whole module is easy, but people might want to have more finess
20:30:11 <xcthulhu> Dude, people cheat all the time on this website
20:30:23 <xcthulhu> I have no idea why
20:30:48 <xcthulhu> Probably because Javascript makes it really, really easy to cheat
20:30:58 <yeboot> so when I code with random data in C, I end up using /dev/random as my source of entropy, I've noticed that System.Random is a pseudo-random number generator, is there a haskell-appropriate way of getting true random data? (library, even)
20:32:43 <Cale> xcthulhu: Well, that's okay? I don't know what the purpose of the website is, but if it's to teach the language, there's no problem with people cheating, so long as you make it clear what they're *meant* to do.
20:33:20 <xcthulhu> People who write exercises tend to demand the ability to blacklist stuff from time to time
20:34:16 <xcthulhu> In Python/Ruby/Javascript it’s easy, since they are all dynamically bound.  Haskell is harder…
20:35:00 <Jafet> Mail them $5 so they can hire a grad student to grade the exercises
20:35:21 <merijn> yeboot: Well, you could just use /dev/random?
20:35:24 <Jafet> Blacklisting symbols accomplishes nothing/
20:35:27 <xcthulhu> Some of the exercises have been completed 15,000 times
20:35:32 <merijn> yeboot: It's just a file, you can read from it easily enough in haskell :)
20:36:01 <merijn> I dunno if someone already created a convenient library for that, though
20:36:04 <xcthulhu> Jafet:  What’s wrong with blacklisting symbols?  It works for the other languages...
20:36:22 <Jafet> What does "works" mean?
20:36:32 <yeboot> thaks merijn
20:36:37 <merijn> Jafet: Well, if he doesn't care about security...
20:36:48 <Cale> People who really want to cheat could always look up the source code from the libraries and copy/paste it
20:36:55 <merijn> Jafet: i.e. it runs in a sandboxed VM, then hiding the functions they are supposed to implement makes sense-ish?
20:37:00 <xcthulhu> People blacklist “Array.prototype.length” in javascript and force people to write their own
20:37:17 <Cale> xcthulhu: Just importing the Prelude hiding length should do
20:37:23 <Cale> I think
20:37:37 <Jafet> There is no way to automatically grade program code in a way that forces the programmer to learn anything
20:37:38 <Cale> I mean, the main thing is just that there isn't something already in scope called length, right?
20:37:54 <xcthulhu> Jafet:  We don’t grade
20:38:41 <xcthulhu> Cale:  Code injection like that is pretty hard, but we might have to do this
20:39:04 <Jafet> Anyway, you can make an index of all the symbols in base and which modules export them, or something
20:39:06 <xcthulhu> I mean, it will require a lot of front end work
20:39:15 <Jafet> And add "hiding" clauses appropriately
20:40:16 <xcthulhu> Jafet:  Eh, what you’re saying isn’t more elegant than parsing the code, looking for which symbols are not bound and checking them against a blacklist
20:41:07 <xcthulhu> I came here hoping that maybe looking at the Core output might be better, since it will have done more work at resolving symbols...
20:43:35 <lpvb> cabal install in a sandbox doesn't isntall to any system/user directories does it?
20:55:55 <Nodenn> hey, anyone out there?
20:57:03 <fread2282> Nodenn: yep
20:57:23 <Nodenn> I don't know if i'm in the right place...i'm trying to find a REAL hacker to talk to
20:57:34 <Nodenn> i don't want to waste anyone's time
20:57:39 <jle`> Nodenn: hopefully you want to talk to them about haskell :)
20:57:42 <Nodenn> but this is my last resort
20:59:18 <Nodenn> i'm hoping that someone could point me in the direction of a place i could ask for help regarding real life harassment
20:59:19 <Jafet> You should be able to find some real oldschool hackers in ##nethack.
20:59:42 <Nodenn> nethack you say? do you think they'd be willing to help?
20:59:46 <codehero> Jafet: :D
20:59:51 <codehero> Nodenn: definitely
20:59:56 <codehero> oh wait
20:59:58 <codehero> ##
20:59:59 <codehero> hmm
21:00:09 <codehero> just try
21:00:18 <Nodenn> i'm not a troll, i have a real issue and my fiance is in danger
21:00:40 <codehero> then irc isn't the place to ask or advice
21:00:44 <codehero> honestly
21:00:47 <codehero> please
21:01:03 <Nodenn> the police in her country aren't working fast enough... i don't know what else to do
21:01:41 <codehero> what is it about?
21:02:34 <codehero> because there are few cases that would need you hacking someone
21:02:46 <Nodenn> not hacking someone
21:02:53 <Nodenn> but to trace a person
21:03:01 <Nodenn> or to find an identity
21:03:44 <codehero> well. if that person is a danger then why don't you just help your fiance get away from that person?
21:03:58 <Nodenn> are you busy? i could explain if you have time
21:04:13 <codehero> i don't want to get involved into anything :P
21:04:27 <Nodenn> no, but i can at least get my situation heard
21:04:46 <codehero> i can't give you any legal advise
21:04:56 <codehero> neither can i give you advise in tracing people
21:05:02 <Nodenn> no that's fine
21:05:14 <Nodenn> but i'd like to talk
21:05:23 <codehero> well, okay
21:05:48 <sgronblo> haskell.org still seems to be having trouble
21:05:54 <Nodenn> so uh..i'm just out of ideas... i'll start explaining now
21:06:08 <Nodenn> my fiance is up in canada
21:06:17 <codehero> okay
21:06:57 <Nodenn> she occasionally hangs out with a friend, and that friend lived with a malicious roommate named Lucia
21:08:20 <Nodenn> Lucia has used social websites to impersonate the friend of my fiance
21:08:37 <Nodenn> also dating websites
21:08:39 <merijn> This seems rather off-topic and unrelated to haskell
21:08:50 <Nodenn> i apologize
21:09:33 <Nodenn> is there somewhere i can go to speak with you Codehero? i don't wish to bother these other fine users
21:09:45 <Nodenn> but
21:09:55 <sgronblo> I'm kind of getting into the story now
21:09:56 <Nodenn> i do wish to be overheard by as many people as possible
21:10:13 <codehero> sgronblo wants to hear it
21:10:19 <Nodenn> does anyone mind if i continue to explain?
21:10:22 <codehero> and there's no other conversation going on
21:10:33 <codehero> *there are
21:10:39 <Nodenn> haha, no worries
21:10:44 <peddie> Nodenn: why don't you discuss it in private message ?
21:10:44 <Nodenn> alright, i'll continue
21:10:46 <codehero> *there is
21:10:48 <codehero> duh
21:11:16 <Nodenn> alright umm
21:11:22 <Nodenn> so this Lucia girl
21:11:43 <Nodenn> has even gotten this friend abducted and raped
21:11:51 <Nodenn> back in May of this year
21:11:57 <Nodenn> using these websites
21:12:47 <codehero> okay
21:12:50 <Nodenn> she somehow had the living address of our friend(Stephanie)
21:13:36 <Nodenn> and sent users to Stephanie's house expecting to get what they were offered on the website
21:15:17 <Nodenn> she continues to use a certain kinky dating website local to where they reside, to further harass Stephanie. and has also threatened to arrange for my fiance to be raped
21:16:43 <Nodenn> everyday we're looking for imposter profiles on that website
21:17:42 <Nodenn> and we've informed the website's customer service about the problem, but they will only work with the police for anything related to tracing the attacker
21:18:20 <codehero> Nodenn: well. tracing alone won't help you
21:18:56 <codehero> to be honest. i think the best thing for her would be to just move away
21:18:58 <Nodenn> it's better than nothing, isn't it?
21:19:09 <codehero> it's not really better
21:19:17 <monochrom> there is #haskell-blah for this
21:19:32 <codehero> there's #haskell-blah?
21:19:36 <monochrom> yes.
21:19:44 <Nodenn> i'm sorry monochrom, i don't mean to bother you.
21:20:04 <codehero> cool. didn't know that
21:20:36 <codehero> what are you expecting to do with the data?
21:20:41 <Jafet> I should join #ubuntu so that this channel stops appearing at the top of lists
21:20:55 <codehero> heh
21:21:08 <monochrom> please continue in #haskell-blah and most importantly stop here.
21:21:17 <codehero> okay
21:21:30 <Nodenn> present it to the police(if that's even a smart option)
21:21:37 --- mode: ChanServ set +o monochrom
21:21:42 --- mode: monochrom set +b *!*@gateway/web/freenode/ip.67.189.90.191
21:21:43 --- kick: Nodenn was kicked by monochrom (Nodenn)
21:22:42 <sgronblo> does that top the weirdness list for this channel?
21:23:00 <codehero> not sure
21:23:21 <codehero> i didn't actually know that there are irc channels that are against off-topic stuff
21:24:03 <sgronblo> some people seem to have very low tolerance
21:26:05 <merijn> codehero, sgronblo: This channel is supposed to be helpful to (beginning) haskellers, channels that don't enforce topic-ness tend to get stranded in discussing the daily life of a certain "in-crowd" over there supposed purpose
21:26:24 <codehero> hmmm
21:26:30 <merijn> Try getting any useful answers from #macosx, for example, all they talk about is concerts and whatever
21:27:50 <codehero> lol
21:27:54 <codehero> those hipsters
21:27:57 <spopejoy> L8D: nice one.
21:28:17 <spopejoy> but edwardk already lensed it up.
21:28:40 <monochrom> before you consider me low-tolerance, please first notice: 1. it had already gone on for 25 minutes; 2. I had already instructed twice where to go.
21:30:00 <joelteon> even if we called you low-tolerance, you're the one with ops
21:31:33 <sgronblo> http://en.wikibooks.org/wiki/Haskell/More_on_datatypes Isn't the Either example using Left and Right incorrectly here?
21:32:00 <spopejoy> don't think that was low-tolerance at all, that convo was way NSFHaskell
21:32:28 --- mode: monochrom set -o monochrom
21:32:36 <Iceland_jack> sgronblo: How is it incorrect?
21:33:22 <sgronblo> Iceland_jack: Using Right to represent the error?
21:33:28 <Iceland_jack> If you're referring to Left denoting error and Right denoting success then that's just a convention
21:33:45 <monochrom> the example is self-consistent.
21:33:59 <monochrom> by that I mean it type-checks
21:34:07 <merijn> Iceland_jack: A convenient made very useful by the monad instance of Either
21:34:11 <merijn> *convention
21:34:18 <Iceland_jack> merijn: That's right, it should preferably be changed
21:34:18 <sgronblo> But doesnt the Monad instance of Either also short circuit based on Left?
21:34:36 <merijn> sgronblo: Right
21:34:45 <sgronblo> Just because it doesnt type-check doesnt make it right?
21:34:54 <sgronblo> I mean because it typechecks
21:34:55 <Iceland_jack> sgronblo: That's right
21:35:07 <merijn> sgronblo: Clearly you haven't seen Edwin Brady's new t-shirt :p
21:35:17 <sgronblo> And especially in the context of a book about haskell
21:35:17 <spopejoy> Whence the biasing for Right as correct, and using Either in general for such behavior (instead of Failure or something)? Is it a preference to avoid proliferating sum types?
21:35:19 <monochrom> it does not use the Either Monad. there is no problem.
21:35:28 * merijn runs of to find the link on le twitterz
21:35:40 <monochrom> it was also written long before Either got its Monad instance.
21:36:07 <sgronblo> So nobody updates this book even though its a wiki?
21:36:17 <merijn> sgronblo: That sounds about right
21:36:19 <spopejoy> Is Monad necessary for short-circuiting a la Maybe/Either, or can you do this applicatively?
21:36:25 <merijn> sgronblo: Feel free to improve :)
21:36:27 <Jafet> spopejoy: if you want a type isomorphic to Either, you might as well use Either or a newtype of it.
21:36:28 <Iceland_jack> sgronblo: Feel free!
21:36:34 <merijn> spopejoy: The Applicative can short circuit to, yes
21:36:50 <jle`> spopejoy: you can short circuit with appliative, but you can't chose whether or not to short-circuit based on the contents of an Either
21:36:51 <merijn> sgronblo: https://twitter.com/edwinbrady/status/507670569916301312/photo/1
21:36:53 <Jafet> You won't need to reimplement Data.Either or any of Either's instances, then.
21:36:55 <jle`> er, the contents of the Right
21:37:12 <jle`> which is one of a big use cases of Either's short-circuiting.  "do this, and then do this with the result"
21:37:44 <spopejoy> How do you newtype Either, especially if you want special names for Left and Right? You can't alias constructors can you?
21:37:54 <Iceland_jack> spopejoy: You can use pattern synonyms
21:38:11 <Iceland_jack>     pattern Result a = Left a
21:38:11 <Iceland_jack>     pattern Error  b = Right b
21:38:11 <spopejoy> Recently I was wanting to do this with Ordering
21:38:30 <Iceland_jack>     pattern Equal    = EQ
21:38:30 <Iceland_jack>     pattern LessThan = LT ...
21:38:50 <Iceland_jack> Need GHC 7.8+
21:39:22 <spopejoy> OK, new sauce then. Don't feel quite so stupid.
21:39:35 <Iceland_jack> Yes, it's a nice feature
21:39:42 <sgronblo> Fixed
21:39:51 <Iceland_jack> sgronblo: Thank you
21:40:11 <spopejoy> When are reusable record fields coming? I tire of prefixing
21:40:11 <Iceland_jack> spopejoy: You can look at a post I made about it, hope it will show some applications: http://www.reddit.com/r/haskell/comments/24fvyz/pattern_synonyms_for_dates_and_an_irc_bot/
21:40:22 <Iceland_jack> spopejoy: OverloadedRecordSyntax should ship in 7.10
21:40:32 <jle`> i totally thought it was scheduled for 7.8
21:40:34 <Iceland_jack> Should grab a bite before ICFP
21:40:34 <jle`> and totally forgot about it
21:40:40 <Jafet> ghc already has some extension for record fields
21:40:45 <jle`> grab the bites, Iceland_jack
21:40:49 <Jafet> (that nobody uses)
21:41:02 <Iceland_jack> Jafet: I'm Mr. Nobody then :)
21:41:26 <sgronblo> So originally Either was not considered as representing success failure, just one or another?
21:41:27 <spopejoy> I've started to see the light regarding newtyping instead of defining isomorphic types, but patterns would make my code much more legible in this regard
21:42:09 <jle`> sometimes i wonder if it would be worthwhile to have sums be a part of the language
21:42:12 <Iceland_jack> sgronblo: That is really the meaning of Either, in a theoretical sense (coproduct), having nothing to do with failure
21:42:13 <jle`> in the same way that products are
21:42:20 <Iceland_jack> jle`: Anonymous sums? I've though about that
21:42:35 <spopejoy> Product is (,)?
21:42:39 <Iceland_jack> Yes
21:42:41 <jle`> yes
21:42:42 <sgronblo> Iceland_jack: I can see that. But still by convention it seems to have come to be used to represent success or failure.
21:43:04 <Iceland_jack>     foo :: (a + b) -> ..
21:43:04 <Iceland_jack>     foo = \case inj1 aVal -> ...
21:43:04 <Iceland_jack>                 inj2 bVal -> ...
21:43:05 <jle`> sgronblo: i think you might have it backwards.  by convention, success/failure uses Either.  but Either is useful for many things too
21:43:09 <spopejoy> I was wondering if pattern-matching on lists could be seen as selecting inhabitants of the list type.
21:43:16 <jle`> it's just that success/failure is a common tool in general :)
21:43:34 <spopejoy> ie, [], [a], (a:as), (a:a:as) being 0,1,2,3
21:44:28 <spopejoy> So you CAN short circuit with applicatives, but NOT on Either being Left?
21:44:44 <jle`> Iceland_jack: the case/injection syntax seems a bit more awkward than for products
21:44:57 <jle`> spopejoy: Applicative for shirt-circuiting requires the success to be the Right, as well
21:45:14 <Iceland_jack> jle`: Yeah, the LambdaCase already exists but I don't know of a nicer way of writing the patterns
21:45:25 <sgronblo> Are there any updates about the status of haskell.org?
21:45:53 <jle`> maybe we can throw syntax operators at it
21:45:57 <Jafet> Anonymous unions would make more sense in a structural type system (a + b <: a + b + c)
21:46:06 <monochrom> does http://status.haskell.org/ count?
21:46:14 <spopejoy> Hmm... a lot of the Applicative material I've read and played around with seems to fall into the zipWith/liftM2 category. I would like to see more that discusses control-flow, or state-monad style function interaction
21:46:24 <Jafet> Also, I hold that the tuple system is terrible
21:46:26 <sgronblo> monochrom: yeah i just found this one too
21:46:45 <spopejoy> What, fst and snd aren't good enough for you? :P
21:46:47 <merijn> spopejoy: You can shortcut on Either being Left, but not on values inside the Right
21:47:06 <nshepperd> foo = (\aVal -> ...) ||| (\bVal -> ...)
21:47:22 <nshepperd> hooray for arrow combinators :D
21:47:37 <jle`> spopejoy: parsers often use applicative interfaces...failure can dictate whether or not to consume or replace the text stream
21:47:43 <monochrom> you short-circuit on Left simply because of the currying and partial application "instance Applicative (Either x)".
21:47:44 <Iceland_jack> nshepperd: Doesn't quite work for arbitrary coproducts :) except up to an isomorphism
21:48:01 <Jafet> I would prefer snd (a,b,c) = (b,c)
21:48:20 <merijn> spopejoy: The main (only) difference between Applicative and Monad is the ability to make behaviour depend on the actual value in the monadic value
21:48:23 <sgronblo> where do i find the source for the monad instance of either?
21:48:25 <jle`> and we all know that in haskell these "isomorphisms" aren't really isomorphisms
21:48:29 <merijn> Jafet: So use a heterogeneous list?
21:48:32 <jle`> @src (>>=) Either
21:48:32 <lambdabot> Source not found. It can only be attributed to human error.
21:48:34 <jle`> darn
21:48:37 <Iceland_jack> sgronblo: You can use :i Either in GHCi
21:48:41 <merijn> Jafet: they're really easy now that we have DataKinds and GADTs
21:48:47 <Iceland_jack> "Defined in ‘Data.Either’"
21:48:50 <Jafet> Yes, tuples should have been hlists
21:48:54 <Jafet> merijn: syntactically easy?
21:49:02 <merijn> Jafet: Sure
21:49:12 <monochrom> that's all there is. if we were all Arabic, we would short-circuit on Right simply because "(x rehtiE) evitacilppA ecnatsni"
21:49:19 <jle`> monochrom: :P
21:49:26 <sgronblo> Iceland_jack: cool, thanks
21:49:33 <Iceland_jack> > reverse "(x rehtiE) evitacilppA ecnatsni"
21:49:34 <lambdabot>  "instance Applicative )Either x("
21:49:47 <jle`> Right x >>= f = f x
21:49:54 <jle`> Left e >>= _ = Left e
21:50:06 <jle`> sgronblo
21:50:08 <spopejoy> I was wondering if it was pointfree-style bias. "If it's on the Right you don't even have to look at it"
21:50:28 <sgronblo> https://hackage.haskell.org/package/base-4.2.0.1/docs/src/Data-Either.html#Either doesnt seem to be in this one
21:50:38 <sgronblo> jle`: teach me how to fish instead :)
21:50:50 <Jafet> Control.Monad.Instances
21:51:06 <jle`> sgronblo: :)
21:51:17 <sgronblo> but ghci told me "instance Monad (Either e) -- Defined in `Data.Either'"
21:51:26 <nshepperd> so we need to define (|||) :: (ProjectiveSpace e, Arrow a) :: a b d -> a c d -> a (e b c) d ?
21:51:28 <jle`> spopejoy: the main reason is because we don't have type level lambdas
21:51:37 <jfischoff> how do I insert links to google fonts in html generated by pandoc from markdown?
21:51:51 <jle`> note the type signature for, say, (*>)
21:51:53 <jle`> :t (*>)
21:51:54 <lambdabot> Applicative f => f a -> f b -> f b
21:52:01 <nshepperd> or something. I'm sure projectivespace isn't actually the right terminology
21:52:09 <monochrom> does 4.2.0.1 match the version of base you actually use?
21:52:12 <jle`> if f ~ Either e, then you get Either e a -> Either e b -> Either e b
21:52:32 <jle`> you can't 'vary' the e parameter, it has to be the same
21:52:37 <Jafet> Heh, C.M.I contains Functor instances.
21:53:00 <sgronblo> I was just thinking, would it make sense to change the monad instance for either to not short circuit for left and instead define a new Try (is this what they call it in Scala) that can be Success r | Failure m for which the monad would short circuit?
21:53:14 <Jafet> Also, base-4.2 is somewhat ancient
21:54:03 <jle`> sgronblo: i'm not totally sure what you are asking, sorry :/
21:54:15 <jle`> what would usage of Try look like?
21:54:20 <nshepperd> what would you do instead of shortcircuiting
21:54:24 <Jafet> If you want a different behaviour, you can define a newtype with its own instance.
21:54:39 <jle`> i don't think that there are any lawful instances of Monad other than the one that there is now
21:54:48 <jle`> that being said, this brings up a question i have thought about earlier
21:54:57 <jle`> are Monad instances for a given type unique?
21:55:13 <jle`> i can't seem to think of a type that has two or more monad instances
21:55:17 <sgronblo> jle`: try would be like the current either
21:55:43 <Jafet> Overlapping monad instances sounds like a bad idea
21:55:50 <sgronblo> but either would go back to being more of a true either by not cementing the success/failure semantics in the monad instance
21:55:56 <jle`> Jafet: i mean, some types have multiple possible Applicative instances
21:56:00 <Jafet> Or do you mean, is it possible to define multiple instances
21:56:17 <jle`> Jafet: no, i'm wondering if a given type be instanced a Monad in multiple ways
21:56:19 <jle`> er
21:56:25 <jle`> um
21:56:31 <monochrom> I like to simplify matters by splitting a two-part question into two questions.
21:56:38 <jle`> i can't think of a way to state it without being ambiguous
21:56:47 <spopejoy> Monoid can. Applicative probably can. Monad ...
21:56:48 <jle`> is there more than one legal Monad instance for any type?
21:56:53 <jle`> Applicative can
21:57:06 <jle`> interestingly enough, Functor instances are also unique
21:57:10 <jle`> s/also//
21:57:15 <nshepperd> jle`: like how we have ziplists and, er, trylists for Applicative?
21:57:20 <lpaste> merijn pasted “Haskell HList” at http://lpaste.net/110584
21:57:20 <jle`> nshepperd: yeah
21:57:21 <nshepperd> combinelists
21:57:31 <merijn> Jafet: That's all you need for HList and friends
21:57:33 <monochrom> question 1: can I rewrite "instance Monad (Either x)" to not short-circuit? answer: no, it's the same problem as not short-circuiting on Nothing in Maybe.
21:57:47 <monochrom> question 2: can I write a Try type? answer: yes.
21:58:18 <jle`> Functor instances are unique.  Applicative instances can be non-unique.  Monad instances...?
21:58:29 <jle`> i might never know
21:58:33 <merijn> Jafet: Not many ways I can think of that could be simpler (sure, it requires {-# LANGUAGE KitchenSink #-}, but the actual code is trivial)
21:59:14 <merijn> And head/tail are essentially your desired fst/snd
21:59:25 <nshepperd> jle`: actually, I think the reverse state monad might be an example
21:59:49 <nshepperd> normal state and reverse state are both :: s -> (a, s)
21:59:57 <monochrom> [*] makes baby Jesus cry :)
22:00:02 <jle`> oh, really?
22:00:04 <merijn> monochrom: Why? :(
22:00:05 <jle`> :O
22:00:07 <merijn> [*] is lovely
22:00:11 <merijn> I <3 [*]
22:00:15 <nshepperd> assuming RState actually satisfies the monad laws
22:00:19 <monochrom> list of kinds. this is way too deep.
22:00:24 <merijn> monochrom: You should see my atrocity on glasgow-haskell-users :D
22:00:49 <merijn> monochrom: http://lpaste.net/110431
22:00:55 <monochrom> data HMonad :: Monad * -> * ...
22:01:11 <monochrom> no wait I'm confused
22:01:21 <Jafet> That sounds too classy
22:01:31 <monochrom> data HIHO :: IO * -> *
22:01:34 <merijn> monochrom: That paste actually works too, if you disregard GHC's broken exhaustiveness checks :)
22:01:40 <jle`> hm
22:01:47 <spopejoy> I was also wondering if 'do' came from list monad, in the sense of "do"-ing through a list and concatenating the results
22:01:53 <merijn> monochrom: For fun, try to compile it with -Wall and then follow GHC instruction to fix the exhaustive warning ;)
22:03:01 <merijn> GADTs and type families are love, as long as you don't have to interact with the outside world for the types containing them :)
22:04:22 <nshepperd> backwards state monad makes my brain hurt though, so I'm stopping now
22:04:46 <jle`> i don't think (>>=) is total, either
22:04:52 <jle`> but i'm not sure if that is a requirement for monad instances
22:04:58 <merijn> I managed to get GHC to statically check the code paths for the authentication handshakes in my library, ensuring that the code path taken must always match the authentication used :D
22:05:15 <spopejoy> what about free instances?
22:06:43 <jle`> but if (>>=) doesn't have to be total, then we can also count the Stream monad instances when used for lists
22:08:31 <merijn> Oh!
22:08:34 <merijn> Horrific idea
22:08:41 <spopejoy> Ouch, I was rereading Typeclassopedia and found myself:  “Hmm, it doesn’t compile ... maybe I’ll stick in an fmap here ... nope, let’s see ... maybe I need another (.) somewhere? ... um ...”
22:09:01 <merijn> Maybe I can use reflections to create a GADT carrying a reified typeclass instance and then use that to force what I want :D
22:09:19 <merijn> spopejoy: Use typedholes more often :)
22:11:11 <merijn> And now I'm reading Oleg papers, where did I go wrong in life?
22:13:13 <spopejoy> I started by reading Oleg papers and learned Haskell years later. The perils of cruising LtU
22:14:33 <merijn> spopejoy: Yes, but I'm trying to do dirty real world programming :p
22:15:29 <spopejoy> I've maintained a clear separation between the two. Java at the day job, lisp (now haskell) at home :)
22:15:41 <spopejoy> I changed that by quitting the job :)
22:16:46 <nshepperd> the free monad for a functor is unique right? is there a relation between that and the functor's own monad instance?
22:17:16 * spopejoy scrolls up to see where I asked about free monad instances
22:17:50 <spopejoy> Typeclassopedia opines that "Usually, for a given implementation of (<*>) there is only one possible implementation of pure."
22:17:52 <merijn> Actually, can someone explain me the point of "reflection"? All the examples I've seen can trivially be replaced by lambda's?
22:17:57 <spopejoy> I guess emphasis on Usually?
22:18:08 <Sgeo> What does "Type of kind * used as a constraint" mean?
22:18:28 <merijn> Sgeo: Constraints must have kind Constraint, * is the kind of types of values
22:18:32 <merijn> i.e.
22:18:34 <merijn> :k Int
22:18:35 <lambdabot> *
22:18:38 <spopejoy> Is a >>= for a free monad total?
22:18:39 <merijn> :k Read Int
22:18:40 <lambdabot> Constraint
22:18:49 <merijn> :k Monad Maybe
22:18:50 <lambdabot> Constraint
22:19:17 <merijn> Sgeo: So you have a type of kind * on the left of a => arrow
22:19:49 <Sgeo> I don't... see that here:
22:19:50 <Sgeo> traverseOf :: (Applicative f) => (forall p. Profunctor p, Strong p, Redundant p => p a b -> p s t) -> (a -> f b) -> s -> f t
22:20:17 <merijn> Sgeo: You're missing parenthesis around the constraints in the first argument?
22:20:43 <merijn> So if I look at the 2nd piece of code in https://www.fpcomplete.com/user/thoughtpolice/using-reflection what does reify/reflect give you that a lambda doesn't?
22:20:44 <Sgeo> Ah, there we go. Now I'm getting a different type error, hooray!
22:20:57 <Sgeo> Thank you
22:25:53 <Sgeo> Cannot use record selector runFuncApp as a function due to escaped type variables
22:46:02 <t4nk004> whay f b = if b then 3 else Nothing
22:46:05 <t4nk004> compiles
22:46:21 <t4nk004> any flag to disable this?
22:46:28 <t4nk004> reconsilation
22:48:00 <jle`> t4nk004: what if someone adds a Num instance for (Maybe a) ?
22:48:09 <jle`> oh
22:48:34 <t4nk004> its compiling successfully that's my concern
22:48:40 <jle`> you can probably add a type signature, and it won't compile.
22:48:44 <t4nk004> unless I put type signature
22:49:07 <cocon> Why should it not compile?
22:49:13 <jle`> is the monomorphism restriction on?
22:49:20 <t4nk004> because it will fail at runtime if does
22:49:24 <jle`> t4nk004: it won't
22:49:26 <jle`> ...?
22:49:31 <jle`> it should work fine at runtime
22:50:16 <jle`> that is, if it compiled
22:50:41 <cocon> It does compile, for me.
22:50:56 <t4nk004> it fails try on promt without type signature
22:51:29 <jle`> t4nk004: can you give instructions to reproduce?
22:52:05 <cocon> Did you put a 'let' in front of it? What's the error message?
22:52:06 <t4nk004> > let f x = if x then 3 else Nothing
22:52:07 <lambdabot>  not an expression: ‘let f x = if x then 3 else Nothing’
22:52:20 <t4nk004> f True
22:52:25 <cocon> what's your ghc version?
22:52:34 <jle`> that's not a runtime error, that's a compile time error
22:52:38 <merijn> :t let f x = if x then 3 else Nothing in f
22:52:39 <lambdabot> Num (Maybe a) => Bool -> Maybe a
22:52:50 <t4nk004> 7.6.3
22:52:50 <jle`> because there is no instance for Num (Maybe a)
22:52:51 <merijn> wait, what
22:52:54 <merijn> @undefine
22:52:54 <lambdabot> Undefined.
22:52:55 <jle`> this would have been caught at compile-time
22:53:04 <merijn> > let f x = if x then 3 else Nothing in f True
22:53:05 <lambdabot>  No instance for (GHC.Show.Show a0)
22:53:05 <lambdabot>    arising from a use of ‘M83641589797280097410299.show_M83641589797280097410...
22:53:05 <lambdabot>  The type variable ‘a0’ is ambiguous
22:53:05 <lambdabot>  Note: there are several potential instances:
22:53:05 <lambdabot>    instance [safe] GHC.Show.Show
22:53:12 <merijn> :t let f x = if x then 3 else Nothing in f True
22:53:12 <lambdabot> Num (Maybe a) => Maybe a
22:53:33 <jle`> if this was in an actual file, if it did error, it would have errored at compile time, not at runtime
22:56:30 <merijn> oh, it can't decide due to the lack of 'a', I think
22:56:33 <jle`> try writing a file and compiling it and see if an otherwise runtime error would escape compilation :)
22:56:38 <merijn> :t let f x = if x then 3 else Nothing in f True :: Maybe Int
22:56:39 <lambdabot>     No instance for (Num (Maybe Int)) arising from a use of ‘f’
22:56:39 <lambdabot>     In the expression: f True :: Maybe Int
22:56:39 <lambdabot>     In the expression:
22:56:44 <merijn> There we go
22:58:16 <merijn> It doesn't complain because it can't prove there isn't *some* 'a' for which there is a num instance for Maybe
22:58:19 <t4nk004> whay its allowing (Num (Maybe Int))
22:58:41 <t4nk004> whay its nt allowing (Num (Maybe Int)) but wllowing polymor[phic one
22:59:02 <jle`> because you might have done something like instance Num (Maybe Int) where ...
22:59:26 <jle`> so your function would actually work, if you asked for a Maybe Int
22:59:28 <merijn> t4nk004: Because it can't prove there isn't *some* 'a' for which "Num (Maybe a)" holds?
22:59:50 <t4nk004> oops proof by contradiction ?
23:12:22 <merijn> @define instance Num a => Num (Maybe a) where (+) = liftM2 (+); (*) = liftM2 (*); abs = fmap abs; signum = fmap signum; negate = fmap negate; fromInteger = Just
23:12:23 <lambdabot>  .L.hs:158:23:
23:12:23 <lambdabot>      Could not deduce (a ~ Integer)
23:12:23 <lambdabot>      from the context (Num a)
23:12:23 <lambdabot>        bound by the instance declaration at .L.hs:152:10-33
23:12:23 <lambdabot>        ‘a’ is a rigid type variable bound by
23:12:30 <merijn> eh
23:12:35 <merijn> @undefine
23:12:35 <lambdabot> Undefined.
23:12:42 <merijn> @define instance Num a => Num (Maybe a) where (+) = liftM2 (+); (*) = liftM2 (*); abs = fmap abs; signum = fmap signum; negate = fmap negate; fromInteger = Just . fromInteger
23:12:44 <lambdabot>  Defined.
23:13:05 <merijn> > let f b = if b then 3 else Nothing in f True
23:13:07 <lambdabot>  Just 3
23:13:17 <merijn> :p
23:13:26 <merijn> > 2 + 5 :: Maybe Double
23:13:28 <lambdabot>  Just 7.0
23:13:42 <merijn> > 3 + Nothing
23:13:44 <lambdabot>  Nothing
23:14:27 <jle`> > sum [3,8,10,Nothing]
23:14:28 <lambdabot>  Nothing
23:14:34 <jle`> > sum [3,8,10]
23:14:35 <lambdabot>  21
23:14:39 <jle`> > sum [3,8,10] :: Maybe Int -- oops
23:14:40 <lambdabot>  Just 21
23:15:19 <jle`> sometimes i wish that typeclass overlappingness worked in a way such that instance (Applicative f, Num a) => Num (f a) where (+) = liftA2 (+) etc. was a feasable thing to do
23:16:16 <jle`> hm
23:16:21 <jle`> well, because @undefine exists...
23:16:23 <jle`> @undefine
23:16:23 <lambdabot> Undefined.
23:16:50 <jle`> @defune instance (Applicative f, Num a) => Num (f a) where (+) = liftA2 (+); (*) = liftA2 (*); abs = fmap abs; signum = fmap signump; negate = fmap negate; fromInteger = pure . formInteger
23:16:50 <lambdabot>  .L.hs:156:23:
23:16:51 <lambdabot>      Not in scope: ‘signump’
23:16:51 <lambdabot>      Perhaps you meant ‘signum’ (imported from Prelude)
23:16:51 <lambdabot>  
23:16:51 <lambdabot>  .L.hs:158:30:
23:16:55 <jle`> @defune instance (Applicative f, Num a) => Num (f a) where (+) = liftA2 (+); (*) = liftA2 (*); abs = fmap abs; signum = fmap signum; negate = fmap negate; fromInteger = pure . formInteger
23:16:56 <lambdabot>  .L.hs:158:30:
23:16:56 <lambdabot>      Not in scope: ‘formInteger’
23:16:56 <lambdabot>      Perhaps you meant one of these:
23:16:58 <lambdabot>        ‘fromInteger’ (imported from Prelude),
23:17:00 <lambdabot>        ‘formatInteger’ (imported from Text.Printf),
23:17:03 <jle`> @defune instance (Applicative f, Num a) => Num (f a) where (+) = liftA2 (+); (*) = liftA2 (*); abs = fmap abs; signum = fmap signum; negate = fmap negate; fromInteger = pure . fromInteger
23:17:04 <lambdabot>  Defined.
23:17:07 <jle`> defune >_>
23:17:15 <jle`> > sum [3, 5, 10] 100
23:17:16 <lambdabot>  18
23:17:24 <Jafet> @defun nan = 0.0 / 0.0
23:17:25 <lambdabot>  Defined.
23:17:29 <Jafet> > 3 + nan
23:17:31 <lambdabot>  NaN
23:18:47 <jle`> > 1 2
23:18:49 <lambdabot>  1
23:18:50 <jle`> > 1 2 3
23:18:51 <lambdabot>  1
23:18:59 <jle`> > 1 2 3 4 5
23:19:00 <lambdabot>  1
23:20:08 <jle`> > 3 <*> [1,2,3]
23:20:10 <lambdabot>  [3,3,3]
23:20:13 <jle`> hehe
23:20:31 <l0cust> :t (<*>)
23:20:32 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
23:21:03 <jle`> l0cust: oh i recommend not trying to dig into that >_> it was made to be particularly annoying to understand
23:21:11 <jle`> um, the thing that i typed
23:21:22 <l0cust> okay, so 3 is a list function? wut?
23:21:24 <l0cust> :t 3
23:21:25 <lambdabot> Num a => a
23:21:55 <jle`> um, i made an (Applicative f, Num a) => Num (f a) instance
23:22:19 <l0cust> oh jeez
23:22:20 <jle`> where fromInteger is pure . fromInteger
23:22:21 <l0cust> okay
23:22:24 <l0cust> I saw your previous things
23:22:42 <l0cust> jle`: have you just made it your mission to ruin lambdabot?
23:22:50 <jle`> it's all temporary :)
23:23:36 <jle`> @define instance (Applicative f, Monoid a) => Monoid (f a) where mappend = liftA2 mappend; mempty = pure mempty
23:23:37 <lambdabot>  Defined.
23:23:37 <merijn> l0cust: Lambdabot used to have a "instance Num a => Num (r -> a)" :)
23:23:51 <Jafet> > 3 :: IO Integer
23:23:52 <lambdabot>  <IO Integer>
23:23:57 <Jafet> Well done
23:24:03 <jle`> thank you
23:24:14 <l0cust> Lambdabot isn't as fun as phrik. All in favor of making lambdabot more stupid and useless, say aye
23:24:52 <jle`> > show <> show $ 6
23:24:53 <merijn> l0cust: If you want to see examples on how to make lambdabot worse you should checkout acme-php :p
23:24:53 <lambdabot>  No instance for (GHC.Show.Show s0)
23:24:53 <lambdabot>    arising from a use of ‘GHC.Show.show’
23:24:53 <lambdabot>  The type variable ‘s0’ is ambiguous
23:24:55 <lambdabot>  Note: there are several potential instances:
23:24:57 <lambdabot>    instance [safe] GHC.Show.Show
23:25:02 <Jafet> @brain
23:25:02 <lambdabot> Now, Pinky, if by any chance you are captured during this mission,
23:25:02 <lambdabot> remember you are Gunther Heindriksen from Appenzell. You moved to Grindelwald
23:25:03 <lambdabot> to drive the cog train to Murren.  Can you repeat that?
23:26:02 <merijn> l0cust: "acme-php: At last, a module that combines the dynamic flexibility of Haskell with the strong design principles of PHP!"
23:26:37 <l0cust> um
23:26:39 <l0cust> wut
23:26:42 <Jafet> acme-php is actually more internally consistent than php, if you can believe that
23:26:54 <merijn> l0cust: All acme packages are essentially jokes :)
23:27:10 <merijn> l0cust: acme-php abuses String instance for Num and that sorta nonsense :p
23:46:36 <merijn> Anyone familiar with edwardk's constraints package?
