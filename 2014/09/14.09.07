00:02:13 <Fuuzetsu> so for functors F : C → D and G : D → C we have u_c : c → G(F(c)) with property that ∀ f. f : c → c' of C, G(F(f)) = u_c' ∘ f ∘ u_c⁻¹; in this sense, it knows how to go G(F(c)) → G(F(c')) by going ‘through’ the original ‘f’ arrow
00:02:19 <Fuuzetsu> is it wrong to think this way?
00:05:52 <solidus-river> is there a built in factorial or should i make one?
00:06:19 <solidus-river> let fac 0 = 1; fac n = n * fac (n - 1); in fac 7
00:06:24 <solidus-river> let fac 0 = 1; fac n = n * fac (n - 1); in fac 7
00:06:29 <solidus-river> > let fac 0 = 1; fac n = n * fac (n - 1); in fac 7
00:06:31 <lambdabot>  5040
00:06:32 <mauke> > product [2 .. 7]
00:06:34 <solidus-river> :( i've been fat fingerin it
00:06:34 <lambdabot>  5040
00:07:08 <Fuuzetsu> http://www.willamette.edu/~fruehr/haskell/evolution.html
00:07:10 <solidus-river> product [1 .. 7]
00:07:15 <solidus-river> > product [1 .. 7]
00:07:17 <lambdabot>  5040
00:07:30 <solidus-river> touche
00:08:45 * hackagebot Salsa 0.2.0.2 - A .NET Bridge for Haskell  http://hackage.haskell.org/package/Salsa-0.2.0.2 (TimMatthews)
00:08:45 * hackagebot word12 1.0.0 - Word12 library.  http://hackage.haskell.org/package/word12-1.0.0 (minpou)
00:09:42 <threestrikes> > product [1..9]
00:09:43 <lambdabot>  362880
00:24:12 <solidus-river> huh
00:24:16 <solidus-river> i'm getting the wierdest error
00:24:17 <solidus-river> check this out
00:24:22 <solidus-river> http://lpaste.net/110651
00:24:43 <solidus-river> for some reason that function returns 3 and not waht it 'should' return given 52 and 3
00:25:25 <dmwit> > product [2..52] :: Int
00:25:27 <lambdabot>  -8452693550620999680
00:25:35 <dmwit> > product [2..52] :: Int32
00:25:36 <lambdabot>  0
00:25:54 <dmwit> Use a real number type, please.
00:26:30 <Fuuzetsu>  > product [2 .. 52] :: Integer
00:26:40 <Fuuzetsu> > product [2 .. 52] :: Integer
00:26:41 <lambdabot>  80658175170943878571660636856403766975289505440883277824000000000000
00:26:52 <solidus-river> lol, hmm, tahts something to note i guess, maybe i should stop specifying int everywhere in my code
00:27:36 <solidus-river> yep, changing it to Integer fixed things
00:27:50 <solidus-river> 'Int'eresting!
00:30:21 <Jafet> > product [2..52] :: Real a => a
00:30:22 <lambdabot>  Could not deduce (GHC.Enum.Enum a1)
00:30:22 <lambdabot>    arising from the arithmetic sequence ‘2 .. 52’
00:30:22 <lambdabot>  from the context (GHC.Real.Real a)
00:30:22 <lambdabot>    bound by the inferred type of it :: GHC.Real.Real a => a
00:30:22 <lambdabot>    at Top level
00:30:43 <dv-> Integer is slow though
00:30:55 <mauke> use Float then
00:31:33 <mauke> > let really :: Real a => a -> a; really = id in really (product [2 .. 52])
00:31:35 <lambdabot>  80658175170943878571660636856403766975289505440883277824000000000000
00:32:06 <jle`> oh really
00:32:31 <Jafet> Really slow
00:32:53 <mauke> > product [2 .. 52] :: Float
00:32:54 <lambdabot>  Infinity
00:33:00 <jle`> heh
00:33:09 <jle`> > product [2 .. 52] :: Double
00:33:10 <lambdabot>  8.065817517094388e67
00:33:20 <Jafet> > let bfold f z [] = z; bfold f z [x] = x; bfold f z xs = uncurry (bfold f z) $ splitAt (length xs `div` 2) xs in bfold (*) 1 [1..10^6]
00:33:21 <lambdabot>  Occurs check: cannot construct the infinite type: b1 ~ [b1 -> c1]
00:33:22 <lambdabot>  Expected type: ([b1 -> c1], b1)
00:33:22 <lambdabot>    Actual type: ([b1 -> c1], [b1 -> c1])
00:33:22 <lambdabot>  Relevant bindings include
00:33:22 <lambdabot>    xs :: [b1 -> c1] (bound at <interactive>:1:52)
00:34:22 <mauke> makes sense
00:34:24 <jle`> > let x = product [2 .. 52] in (x, x, x, x, x) :: (Int, Integer, Rational, Float, Double)
00:34:26 <lambdabot>  (-8452693550620999680,806581751709438785716606368564037669752895054408832778...
00:34:39 <jle`> that didn't end up like i expected
00:34:53 <jle`> > product [2 .. 52] :: Rational
00:34:54 <lambdabot>  80658175170943878571660636856403766975289505440883277824000000000000 % 1
00:35:02 <jle`> always take the rational approach
00:35:05 <jle`> :)
00:35:05 <Jafet> That's reassuring
00:35:07 <jle`> (don't)
00:35:28 <mauke> :t toRational
00:35:29 <lambdabot> Real a => a -> Rational
00:35:48 <jle`> > toRational (product [2 .. 52] :: Double)
00:35:51 <lambdabot>  80658175170943876845634591553351679477960544579306048386139594686464 % 1
00:35:54 <jle`> ew
00:36:04 <mauke> > toRational pi
00:36:06 <lambdabot>  884279719003555 % 281474976710656
00:36:34 <jle`> > (toRational (product [2 .. 52] :: Double) - product [2 .. 52]) / product [2 .. 52]
00:36:35 <lambdabot>  (-3066038170557043129877657180880094553) % 143277701118449624878189462251760...
00:36:43 <mauke> > 884279719003555 / 281474976710656
00:36:45 <lambdabot>  3.141592653589793
00:37:08 <mauke> > toRational (exp 1)
00:37:10 <lambdabot>  6121026514868073 % 2251799813685248
00:37:13 <Jafet> > toRational (pi :: CReal)
00:37:14 <lambdabot>  *Exception: CReal.toRational
00:37:26 <Jafet> What a cop-out.
00:38:00 <mauke> > toRational (0 / 0)
00:38:01 <lambdabot>  (-26965397022934738615939577861835371004269654684134598591014512173659901370...
00:38:09 <jle`> that's rational
00:38:32 <jle`> > toRational (1 / 0)
00:38:34 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
00:39:06 <mauke> > let x = 1 / 0 in toRational (-x) == -toRational x
00:39:07 <lambdabot>  True
00:41:20 <jle`> so toRational is an odd function
00:41:39 <mauke> :t odd
00:41:40 <lambdabot> Integral a => a -> Bool
00:41:58 <jle`> odd :: Real a => (a -> a) -> Bool
00:42:20 <jle`> odd sin = False
00:42:23 <jle`> odd cos = True
00:42:43 <jle`> definitely sounjds like a function one could write
00:47:30 <Hafydd> odd f = forall x. f (-x) = -(f x)
00:50:23 <jle`> i wonder if there's a language where you could write that
00:50:38 <Hafydd> odd f = and [f (-x) = -(f x) | x <- enumFromTo minBound maxBound]
00:50:45 <Hafydd> Er.. ==
00:51:18 <jle`> only works for types where Enum represents some sort of spanning function :'(
00:51:22 <Hafydd> @let fodd f = and [f (-x) == -(f x) | x <- enumFromTo minBound maxBound]
00:51:25 <lambdabot>  Defined.
00:51:39 <Hafydd> > fodd (sin . floor)
00:51:40 <lambdabot>  No instance for (GHC.Num.Num a10) arising from a use of ‘L.fodd’
00:51:40 <lambdabot>  The type variable ‘a10’ is ambiguous
00:51:40 <lambdabot>  Note: there are several potential instances:
00:51:40 <lambdabot>    instance GHC.Num.Num GHC.Types.Double
00:51:40 <lambdabot>      -- Defined in ‘base:GHC.Float’
00:52:18 <Hafydd> > fodd (floor . sin . floor :: Integer -> Integer)
00:52:20 <lambdabot>  No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
00:52:21 <lambdabot>    arising from a use of ‘L.fodd’No instance for (GHC.Real.RealFrac b0)
00:52:24 <lambdabot>    arising from a use of ‘GHC.Real.floor’
00:52:25 <lambdabot>  The type variable ‘b0’ is ambiguous
00:52:27 <Hafydd> > fodd (floor . sin . floor :: Int -> Int)
00:52:28 <lambdabot>  Note: there are several potential instances:
00:52:29 <lambdabot>  can't find file: L.hs
00:52:35 <Hafydd> > fodd (floor . sin . floor :: Int -> Int)
00:52:37 <lambdabot>  No instance for (GHC.Real.RealFrac b0)
00:52:39 <lambdabot>    arising from a use of ‘GHC.Real.floor’
00:52:41 <lambdabot>  The type variable ‘b0’ is ambiguous
00:52:44 <lambdabot>  Note: there are several potential instances:
00:52:45 <lambdabot>    instance GHC.Real.RealFrac GHC.Types.Double
00:52:55 <Hafydd> Fuck.
00:53:04 <Hafydd> > fodd (floor . sin . fromIntegral :: Int -> Int)
00:53:05 <lambdabot>  False
00:53:08 <Hafydd> !
00:53:12 <jle`> :O
00:53:31 <jle`> > fodd (floor . cos . fromIntegral :: Int -> Int)
00:53:33 <lambdabot>  False
00:53:41 <int-e> > (floor (sin (-1)), floor (sin 1))
00:53:43 <lambdabot>  (-1,0)
00:54:01 <int-e> honestly, what did you expect?
00:54:06 <shachaf> I suggest testing your code in /msg first to avoid half a screen of lambdabot spam.
00:54:23 <Hafydd> My apologies.
00:54:39 <pavonia> > fodd (abs :: Int -> Int)
00:54:41 <lambdabot>  False
00:55:02 <Hafydd> I wasn't expecting anything sensible. 'Twas merely a jape.
00:55:33 <pavonia> > fodd (id :: Int -> Int)
00:55:37 <lambdabot>  mueval-core: Time limit exceeded
00:55:42 <Hafydd> Hahaha.
00:56:26 <shachaf> If you don't expect anything sensible then there's no point in using lambdabot at all.
00:56:40 <shachaf> Remember, IRC bots are DoS amplifiers.
00:57:26 <Hafydd> What's the point of doing anything?
00:58:04 <int-e> So we're finally back to a haskell topic: lazy evaluation
00:59:32 <dmwit> jle`: If you don't like Enum, you might like the spelling fodd f = and [f (-x) == -(f x) | x <- universe]. ;-)
01:01:12 <Jafet> You just need a type for functions that are odd by construction.
01:02:40 <Fuuzetsu> does endo + iso = auto?
01:03:19 <shachaf> endo * iso = auto
01:03:33 <shachaf> But this is only vocabulary, not particularly useful.
01:04:15 <Fuuzetsu> the ‘+’ here was informal, the question was is a morphism that's an isomorphism and an endomorphism an automorphism?
01:04:26 <Fuuzetsu> but now I wonder why you used *, what does it denote here?
01:04:42 <shachaf> The * was also informal.
01:05:01 <Fuuzetsu> is it just for product (and) as opposed to sum (or)?
01:05:10 <shachaf> Sure.
01:05:12 <Fuuzetsu> ok
01:05:33 <Jafet> I believe that is the definition of an automorphism.
01:08:28 <Fuuzetsu> yeah
01:09:39 <dv-> @check abs(a) == abs(-a)
01:09:41 <lambdabot>  *** Failed! Falsifiable (after 1 test):
01:10:03 <prophile> lambdabot's insight never fails to amaze me
01:10:18 <Fuuzetsu> Passed, 100 OK!
01:10:52 <prophile> if a is Int then abs(minBound) may be a weird case
01:11:00 <prophile> s/is/is an/
01:11:25 <Fuuzetsu> > abs (minBound :: Int)
01:11:27 <lambdabot>  -9223372036854775808
01:11:27 <prophile> apparently not
01:11:42 <prophile> > abs (negate minBound :: Int)
01:11:43 <lambdabot>  -9223372036854775808
01:11:56 <prophile> it's negative but abs(a) == abs(-a)
01:12:01 <nshepperd> dammit lambdabot now we're stuck wondering what the failed testcase was
01:12:49 <Fuuzetsu> I can now imagine quite a few places where | abs x >= 0 = foo; | otherwise = error "can't happen!" exists…
01:13:17 <Jafet> @check \a -> abs a == abs (-a)
01:13:18 <lambdabot>  +++ OK, passed 100 tests.
01:13:45 * hackagebot hruby 0.2.7 - Embed Ruby in your Haskell program.  http://hackage.haskell.org/package/hruby-0.2.7 (SimonMarechal)
01:13:51 <Jafet> > -a
01:13:52 <lambdabot>  negate a
01:22:15 <Fuuzetsu> is there any name for arrows between categories that aren't functors?
01:22:46 <shachaf> Arrows.
01:22:50 <Fuuzetsu> thought so
01:23:15 <shachaf> I don't think the question makes sense.
01:23:33 <shachaf> An "arrow" is something in a category.
01:23:43 <shachaf> Are you asking whether there are other categories than Cat that have categories as objects?
01:23:50 <shachaf> If so, sure.
01:24:13 <Fuuzetsu> I guess that's a much better way to think about it
01:24:44 <prophile> as in morphisms or Hughes arrows?
01:24:46 <nyuszika7h> nyuszika7h@cadoth ~ > cabal --version
01:24:48 <nyuszika7h> cabal: /lib/x86_64-linux-gnu/libc.so.6: version `GLIBC_2.14' not found (required by cabal)
01:24:51 <nyuszika7h> using the binary Haskell Plato
01:24:59 <nyuszika7h> Platform on Debian wheezy
01:26:32 <shachaf> As in morphisms.
01:27:06 <shachaf> By the way, "the category of Xs", where Xs are the objects in the category you're talking about, is not very good terminology.
01:27:46 <shachaf> For some reason the category where the arrows are functions is called Set. But there are lots of other categories with sets as objects.
01:28:32 <nyuszika7h> is it possible to make cabal work? I don't want to update glibc and potentially break things :/
01:28:49 <nyuszika7h> wheezy has 2.13
01:28:56 <Fuuzetsu> nyuszika7h: stick around, if someone knows then they'll answer
01:29:16 <Fuuzetsu> shachaf: yes, I agree, I don't think I implied such a view
01:35:03 <Jafet> If you're using debian's Platform, use debian's cabal-install.
01:35:55 <nyuszika7h> Jafet: I used to use that but then I downloaded the binary version of the newer platfork
01:35:58 <nyuszika7h> platform
01:36:05 <Philonous> I keep getting "setup: Main.hs doesn't exist" when I try to cabal build. Is this a known problem?
01:36:21 <nyuszika7h> I can't use Debian's Haskell Platform to compile it, because too old cabal (1.14 vs. 1.16)
01:37:32 <Fuuzetsu> Philonous: the obvious question is whether Main.hs exists
01:37:55 <Fuuzetsu> do you say where it as in the cabal file?
01:38:23 <Philonous> Fuuzetsu, It does, at least it didn't disappear in the last 10 minutes, and it actualy did build once
01:38:59 <Jafet> I would download ghc and install cabal-install and the platform packages from source.
01:39:05 <Fuuzetsu> are your source-dirs specified properly?
01:39:13 <Fuuzetsu> (or is it src-dirs, I forget)
01:40:02 <Fuuzetsu> you're not really giving a lot of info here
01:41:26 <joelteon> hs-source-dirs
01:41:57 <Philonous> https://github.com/Philonous/pontarius-service/blob/master/pontarius-service.cabal <-- I think so
01:42:04 <Philonous> The strange thing is, it used to build
01:42:04 <solidus-river> hmm, interesting, if i gave something an Ordering via a deriving clause and i wanted to make sure that it was < 2
01:42:07 <solidus-river> how would i do that?
01:42:33 <solidus-river> like i have a thing deriving ordering and i subtract it and take the absolute value of it
01:42:50 <solidus-river> and i want to make sure that is within 2
01:43:25 <Philonous> solidus-river, You could do it with Enum, not with ordering
01:43:49 <Jafet> :t abs (?x - ?y) < 2
01:43:50 <lambdabot> (?y::a, ?x::a, Ord a, Num a) => Bool
01:44:18 <solidus-river> whats the ?x mean?
01:44:25 <Fuuzetsu> I think ‘range’ would also work
01:44:35 <Fuuzetsu> uh, rangeSize rather
01:44:46 <Fuuzetsu> > rangeSize 1 3
01:44:48 <lambdabot>  Couldn't match expected type ‘a1 -> t’
01:44:48 <lambdabot>              with actual type ‘GHC.Types.Int’
01:44:51 <Jafet>  ?x is just a variable name.
01:44:54 <Fuuzetsu> > rangeSize (1, 3)
01:44:55 <lambdabot>  3
01:45:12 <solidus-river> oh balls, i cant actually use my Enumerations or Ordering data types because they are not an instance of Num
01:45:19 <solidus-river> would deriving Num make sense?
01:45:28 <Fuuzetsu> no
01:45:35 <Philonous> solidus-river, Num can't be derived
01:45:39 <Jafet> Only if it is a newtype.
01:45:47 <Fuuzetsu> > rangeSize ((), ())
01:45:49 <lambdabot>  1
01:45:49 <nyuszika7h> hmm, I could do 'cabal install cabal cabal-install' apparently
01:45:49 <solidus-river> damn.. i was close
01:45:52 <Fuuzetsu> use that
01:46:08 <Philonous> @type rangeSize
01:46:09 <lambdabot> Ix a => (a, a) -> Int
01:46:18 <Jafet> I'm not sure if upgrading cabal is a good idea.
01:46:44 <Philonous> > fromEnum True - fromEnum False
01:46:45 <solidus-river> whats Ix
01:46:45 <lambdabot>  1
01:47:01 <Fuuzetsu> http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Ix.html#t:Ix
02:09:58 <solidus-river> well, i let this code get abominable but .. fun fact if your playing 7 card stud, if you decide to fold on any opening hand that isnt a triplet, a pair of aces, all below 8, all of the same suit, or all in a row
02:10:04 <nyuszika7h> "Installing executable(s) in /root/.cabal/bin" wtf?
02:10:14 <solidus-river> you can play on 23.28% of hands dealt
02:11:20 <solidus-river> nyuszika7h: what user are you runing cabal as?
02:11:30 <nyuszika7h> I ran it as root
02:12:00 <solidus-river> nyuszika7h: does your root user have a home folder? some systems are set up where root doesn't have a home dir
02:12:07 <nyuszika7h> yes, it does, it's /root
02:12:15 <nyuszika7h> I expected it to install to /usr/local or something
02:12:20 <nyuszika7h> but I'm running as my user now, doesn't really matter since I only need this cabal to compile the newer Haskell Platform
02:13:13 <Philonous> Fuuzetsu, I found the problem. It ended up being a missing Main.hs, but in one of the dependencies.
02:14:00 <Philonous> Fuuzetsu, That is, a dependency I pulled in via add-source
02:15:12 <Philonous> But it's still a pretty useless error message
02:16:47 <Fuuzetsu> I imagine it wasn't just a one-line error but you also had information before and after it about the dependency building and failing to build which collectivelly is not useless. Next time lpaste the full error.
02:19:12 <Philonous> Fuuzetsu, Heh, no, that _was_ the error message in it's entirety(!).
02:20:46 <Fuuzetsu> hm, ok, then that's pretty useless; maybe -v would help
02:21:14 <Philonous> That's actually a good hint.
02:21:26 <Philonous> I eded up chasing the problem down with strace
02:21:31 <Philonous> ended*
02:22:29 <Philonous> Fuuzetsu, Anyway, thanks for you help
02:27:13 <nyuszika7h> haddock: internal error: /home/nyuszika7h/.cabal/share/doc/x86_64-linux-ghc-7.8.3/Cabal-1.20.0.2/html/Cabal.haddock: openBinaryFile: does not exist (No such file or directory)
02:29:37 <Fuuzetsu> haddock --version? when does this happen?
02:29:38 <SlickRick420> hey
02:29:42 <SlickRick420> long time no see
02:29:58 <SlickRick420> updated my weed blog few days ago www.salvia420.blogspot.com <3
02:30:01 <SlickRick420> its pretty dank
02:30:04 <Fuuzetsu> @where ops
02:30:04 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
02:30:06 <scopedTV> @where ops
02:30:07 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
02:30:15 <SlickRick420> dunn
02:30:18 --- mode: ChanServ set +o mauke
02:30:20 <SlickRick420> just bot here
02:30:23 <SlickRick420> there u go
02:30:27 --- mode: mauke set +b *!*@c-76-108-169-140.hsd1.fl.comcast.net
02:30:33 * Fuuzetsu thought to @where it on his first message
02:30:51 <nyuszika7h> Haddock version 2.10.0, (c) Simon Marlow 2006
02:30:52 <nyuszika7h> Ported to use the GHC API by David Waern 2006-2008
02:30:54 <nyuszika7h> when compiling Haskell Platform
02:30:58 --- kick: SlickRick420 was kicked by mauke (SlickRick420)
02:30:59 <Fuuzetsu> that's old
02:31:02 <Fuuzetsu> like, really old
02:31:09 <nyuszika7h> it's Debian's Haskell Platform >_>
02:31:11 <nyuszika7h> I tried "cabal install haddock", complains about something else
02:31:12 <Fuuzetsu> are you on like GHC 7.4.2 or something
02:31:18 <nyuszika7h> src/Haddock/Interface/LexParseRn.hs:67:52:
02:31:19 <nyuszika7h>     Not in scope: type constructor or class `SafeHaskellMode'
02:31:21 <nyuszika7h> close eough
02:31:23 <nyuszika7h> 7.4.1
02:31:24 <nyuszika7h> *enough
02:31:27 <mauke> old as balls
02:31:34 --- mode: mauke set -o mauke
02:31:36 <Fuuzetsu> sasuga Debian
02:31:48 <Fuuzetsu> you should probably seek help in Debian channels with this
02:32:52 <Fuuzetsu> I would not expect cabal install haddock to work for you, you wouldn't get a more recent version anyway
02:33:46 <nyuszika7h> Fuuzetsu: I installed a newer cabal and cabal-install via the existing cabal, because 1.14.0 is too old for compiling the Haskell Platform
02:33:48 <erikd> is there a CPP hack I can use to detect OSX? (i'm hacking on language-c-inline and want to disable the OSX/ObjC tests on linux).
02:34:13 <nyuszika7h> erikd: __APPLE__ might work, not sure if that works with GHC
02:34:30 <erikd> nyuszika7h: thanks, i'll try that
02:34:43 <Fuuzetsu> there is but I'm pretty sure it's not __APPLE__
02:35:07 <merijn> erikd: http://sourceforge.net/p/predef/wiki/OperatingSystems/
02:35:28 <erikd> merijn: thanks. google failed to find that for me
02:36:04 <nyuszika7h> yup, it says "__APPLE__ && __MACH__" for OS X
02:36:39 <merijn> nyuszika7h: GHC just uses gcc/clang for CPP
02:36:53 <nyuszika7h> ah
02:37:05 <merijn> Which is why OSX' clang switch broke the platform so badly last year :>
02:39:53 <erikd> so if i use "#if (__APPLE__ && __MACH__)" in haskell code that will work on OSX?
02:39:58 <Fuuzetsu> and broke Haddock for every OSX user
02:40:46 <erikd> sorry, just getting off train. back in 10 min.
02:42:11 <merijn> erikd: use "#if defined(__APPLE__) && defined(__MACH__)"
03:03:12 <CARAM> I'm really struggling with monads / do notation... if I have a pure function (a -> b), how can I apply it to an (m a) to get an (m b)?
03:03:32 <CARAM> I swear I'm going mad
03:03:33 <Fuuzetsu> @hoogle Monad m => (a -> b) -> m a -> m b
03:03:33 <dmwit> :t fmamp
03:03:35 <lambdabot>     Not in scope: ‘fmamp’
03:03:35 <lambdabot>     Perhaps you meant ‘fmap’ (imported from Control.Monad.Writer)
03:03:35 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
03:03:35 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
03:03:35 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
03:03:40 <dmwit> ugh
03:03:42 <dmwit> :t fmap
03:03:43 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:03:58 <dmwit> There's also (<$>), liftA, liftM, and probably a few other spellings beside.
03:04:24 <dmwit> Or, if you're really into do notation, you can do { v <- ma; return (f v) }, where f is your "a -> b" function and "ma" is your monadic value.
03:04:25 <Fuuzetsu> Hoogle It™
03:06:14 <jayashree> hey everyone
03:08:12 <CARAM> got it, thanks!
03:16:27 <nyuszika7h> good news
03:16:34 <jle`> CARAM: there's that cheat sheet that goes around
03:16:34 <nyuszika7h> I got things pretty much working
03:16:41 <jle`> if you have an (f a)
03:16:50 <jle`> if you have an (a -> b): use fmap
03:16:57 <jle`> if you have an f (a -> b): use ap/(<*>)
03:17:08 <jle`> if you have an (a -> f b), use (=<<)
03:17:20 <nyuszika7h> I've overwritten the Haskell Platform bindist's cabal with the version I built using Debian's Haskell Platform
03:17:24 <nyuszika7h> and it works
03:17:36 <nyuszika7h> I'm replacing HsColour, alex, happy, etc. - the ones that complain about glibc
03:17:40 <nyuszika7h> so far works fine
03:18:15 <jle`> nice :)
03:18:43 <lpaste> nyuszika7h pasted “No title” at http://lpaste.net/3080973224754806784
03:18:49 <nyuszika7h> hmm... error when trying to build happy ^
03:19:20 <nyuszika7h> I guess I have to rebuild mtl then
03:19:37 <nyuszika7h> I alo had to rebuild cabal with itself to get it to work properly with the bindist
03:19:39 <nyuszika7h> *also
03:32:53 <nomeata> Hi. Is there an equivalent to "--constraint 'pkg (== 1235)'" (where that version does not exist on hackage) to prevent a package from being considered?
03:33:04 <nomeata> (Talking about cabal install here... :-))
03:33:50 <dmwit> Cool question.
03:34:05 <dmwit> nomeata++
03:35:07 <Jafet> Doesn't that work?
03:35:33 <dmwit> It works until somebody uploads that version.
03:35:55 <Jafet> Use 0
03:36:44 * dmwit shrugs
03:36:58 <dmwit> We can all pick a version number we think will never exist on Hackage.
03:37:03 <dmwit> That doesn't invalidate the question.
03:37:52 <nomeata> Jafet: it works, but it’s a hack
03:37:55 <prophile> stupid answer, without actually knowing cabal: could you specify reversed upper and lower bounds?
03:37:55 <Jafet> I don't understand if the question is actually a cabal-install feature request
03:38:16 <prophile> as in, >=2 && <2?
03:38:59 <dmwit> prophile: An unsatisfiable constraint is not the same thing.
03:39:25 <dmwit> Jafet: It sounded like a "should I file a feature request" question to me.
03:39:33 <nyuszika7h> hmm, 'ghc-pkg check' lists many broken packages...
03:39:45 <nomeata> Jafet: If no such flag exists, I guess it is
03:39:54 <dmwit> Well.
03:40:10 <dmwit> I guess an unsatisfiable constraint *is* the same thing.
03:40:26 <dmwit> So does "--constraint (pkg == 1235)" actually work?
03:40:46 <nomeata> yes
03:40:56 <dmwit> I'm actually a little surprised.
03:41:22 <dmwit> I wonder what the semantics of constraints is.
03:41:31 <Jafet> A sure workaround is to remove the package from 00-index.cache.
03:41:41 <nomeata> even more of a hack :-)
03:41:41 <Taneb> Hmm, hFlush must not work like I think it must
03:41:43 <dmwit> It's odd that "pkg == 1235" is satisfied by not installing "pkg" at all.
03:42:01 <dmwit> I would think it's satisfied *only* by installing exactly version 1235 of pkg.
03:42:06 <nomeata> As I said: It works, I am only wondering if there is (or should be) a dedicated flag for it
03:42:06 <dmwit> Perhaps it's a bug.
03:42:26 <nomeata> dmwit: I don’t think so. People put things like "constraint: mtl >= 2.2" in their config
03:42:30 <Jafet> Only if you also ask cabal to install pkg
03:42:32 <dmwit> I don't know if there is. It sounds like a useful constraint to have.
03:42:34 <Jafet> It makes sense to me.
03:42:35 <nomeata> that does not mean that they want to install mtl with every installation
03:42:40 <Taneb> I'm doing 'putStr "> " >> hFlush stdout >> etc' so it prints the "> " on line-buffered mode, but it doesn't seem to be working
03:42:59 <dmwit> nomeata: No. But it does mean they want mtl. Not installing mtl would be a weird way to satisfy that constraint.
03:43:35 <nomeata> dmwit: no, it does _not_ mean that. It just means that they want to restrict the range of acceptable versions of mtl
03:43:35 <dmwit> nomeata: Interpreting the syntax "mtl >= 2.2" to mean "satisfied when a version of mtl is installed that's bigger than 2.2" seems perfectly reasonable to me.
03:43:42 <Taneb> Anyone know what I'm doing wrong?
03:43:58 <dmwit> nomeata: ...uh? That's not what I mean when *I* write "mtl >= 2.2" in my cabal file!
03:44:13 <nomeata> dmwit: cabal file dependencies are different from "--constraint" flags
03:44:22 <Taneb> Ah, I wasn't actually recompiling it
03:44:37 <dmwit> nomeata: I believe you. But I don't have to like it.
03:44:45 <nomeata> a cabal file dependency "mtl >= 2.2" is equivalent to 'cabal install mtl --constraint "mtl (>= 2.2)"'
03:44:54 <Taneb> I'm an idiot
03:45:06 <nomeata> dmwit: I don’t see the problem. --constraint serves a very important use-case that it would not under your semantics
03:45:16 <nomeata> dmwit: otoh, I don’t see what problem would be solved with your semantics
03:45:30 <nomeata> dmwit: if you want a package to be installed by cabal-install, give the package name as an argument
03:46:35 <dmwit> What's the very important use case?
03:47:57 <nomeata> filed as https://github.com/haskell/cabal/issues/2092
03:48:27 <nomeata> assume mtl 2.2 fixes an important bug
03:48:40 <nomeata> then I might put "constraint: mtl >= 2.2" in my cabal config
03:48:49 <nomeata> possibly with "allow-newer: mtl"
03:49:13 <nomeata> Or assume I update my suite of packages foo-a, foo-b, foo-c, and I want to test my reverse dependencies
03:49:35 <nomeata> then I want to build them with at least the new version, without adding extra things to install
03:50:14 <dmwit> Cool. I did not understand this corner of cabal.
03:51:14 <nomeata> and --constraint can also specify flags
03:52:20 <int-e> nomeata: interestingly, Cabal (the library) defines noVersion :: VersionRange internally as > 1 && < 1
03:52:55 <int-e> but it would be nice to have -none (in analogy to -any)
03:52:59 <nomeata> so you could globally configure certain packages to always have a flag enabled, without affecting the choice of _what_ to install
03:53:40 <nomeata> int-e: ah, there is a constraint -any? then -none makes sense. would you mind adding that suggestion to https://github.com/haskell/cabal/issues/2092
03:53:57 <int-e> I was just about to do that
04:03:43 <lpaste> nyuszika7h pasted “No title” at http://lpaste.net/3917648234293493760
04:03:51 <nyuszika7h> trying to fix broken packages... ^
04:03:59 <nyuszika7h> I'm using --reinstall, but it's telling me to use --reinstall >_>
04:04:08 * hackagebot xlsx 0.1.0.3 - Simple and incomplete Excel file parser/writer  http://hackage.haskell.org/package/xlsx-0.1.0.3 (KirillZaborsky)
04:06:00 <Jafet> "Incomplete"
04:07:19 <Jafet> @where sicp
04:07:19 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized Packages"
04:07:35 <Jafet> may be useful
04:17:15 <Andrew___> Is it somehow possible to take a function which produces an IO action and turn it into an a IO action which produces an equivalent function? Something like (a -> IO b) -> IO (a -> b). Am struggling
04:17:46 <Andrew___> to think how that would be implemented which I suspect means such a thing would be impure.
04:18:13 <Geraldus> Hi friends! Can anybody help a bit with Aeson?
04:18:41 <Trollinator> Andrew___: it can't be done.
04:19:10 <Andrew___> Thanks. Suspected as much but was struggling to come up with the right intuition as to why.
04:19:26 <mauke> consider the function hGetLine
04:20:25 <Geraldus> I have some data type, I read Value from environment, and then I want to convert it to my custom data type. I could do this in ugly way with lookups and cases, but I believe there should be some pretty way to do that.
04:26:44 <Trollinator> Andrew___: The only way to perform side effects is to execute an IO action. Now, a -> IO b is just an IO action that is parametrized by an a. This means that the side effects it'll perform may depend on that a. Now, when you have an IO (a -> b), there's no way you can perform the same side effects, because when you execute the IO action, the a isn't known yet, and when you apply the resulting function, the a is known but you can't
04:26:46 <Trollinator> perform side effects because the function is pure.
04:31:27 <wz1000> Is xmonad a good codebase to learn from?
04:32:48 <Trollinator> I don't believe in learning from real-world code bases.
04:34:02 <Jafet> It's better to learn from imaginary ones.
04:34:57 <Trollinator> For one thing, there's a *lot* of bad code out there. And for another, most projects do stuff one particular way, but they don't document the reasons, which is what you should be interested in when learning stuff.
04:37:25 <Odda> sorry, seems I dropped out of the channel for some reason, did I miss a reply to my cabal question?
04:38:03 <Trollinator> Odda: check the history.
04:38:04 <Trollinator> http://ircbrowse.net/day/haskell/today?mode=recent
04:38:17 <Odda> Trollinator: thanks!
04:38:32 <Trollinator> happy to help.
04:40:59 <Odda> hmm, my question doesn't seem to have made it through, so I'll risk it again
04:41:14 <Odda> trying to install cqrs-types with cabal, it's complaining about 'Module ‘Data.Conduit’ does not export ‘ResourceT’'. How do I get around this, just modify cqrs-types.cabal?
04:44:11 * hackagebot snap-cors 1.2.5.1 - Add CORS headers to Snap applications  http://hackage.haskell.org/package/snap-cors-1.2.5.1 (OliverCharles)
04:50:28 <MindIsAVortex> hi there, I just started on a course on functional programming, so very little experience as of yet. I was wondering if anyone could tell me why I'm getting two Not A Numbers for output here here when I call the function with args 1 3 4, or any other args as well really. https://gist.github.com/MindIsAVortex/042c3d4d692b36fcdc73
04:58:02 <valdyn> MindIsAVortex: you cant take the root of a negative value
04:58:44 <nyuszika7h> @help
04:58:44 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:58:47 <nyuszika7h> @list
04:58:48 <lambdabot> What module?  Try @listmodules for some ideas.
04:58:52 <nyuszika7h> @hoogle %
04:58:53 <lambdabot> Data.Ratio (%) :: Integral a => a -> a -> Ratio a
05:03:46 <MindIsAVortex> valdyn: Ah, I see it now. Basic high school stuff really :S  Thanks!
05:11:50 <Emre_> testing
05:16:03 <Taneb> Emre_, ?
05:16:40 <bennofs> How can I implement Hashable for Data.Vector.Unboxed ?
05:35:04 <yitz> bennofs: re-implement the list algorithm, except with faster iteration over a vector. perhaps you can even re-use some of the code.
05:38:19 <augur> oh dear. tekmo promoting SYTC again
05:39:02 <int-e> . o O ( scrap your type-checking )
05:40:09 <yitz> bennofs: oh, perhaps you can simply use hashPtrWithSalt if the vector is stored in a contiguous block of memory.
05:40:48 <bennofs> yitz: Data.Vector.Unboxed doesn't seem to expose a function to access the underlying ByteArray# :( I'm currently trying Data.Vector.Primitive
05:41:21 <yitz> bennofs: right. you'll definitely want the internals here if efficiency is important.
05:41:45 <augur> int-e: x3
05:41:49 <augur> int-e: scrap your type classes
05:42:03 <yitz> augur: not exactly *promoting*.
05:42:54 <Iceland_jack> carter: hey, hope you got home safely
05:43:01 <yitz> augur: "My opinion on type classes has mellowed since I wrote this post, but I still keep it around as a critique against the excesses of type classes."
05:43:29 <augur> yitz: sure. except it's not even remotely a critique of type classes
05:43:33 <augur> the entire blogpost is a strawman
05:44:24 <augur> the argument in the post is essentially "we don't need typeclasses to do X, so we can and should avoid them"
05:44:53 <augur> but this is fallacious. X is not the purpose of typeclasses, Y is, and you can't do Y without typeclasses or something similar that Haskell does not have
05:45:12 <augur> it's like saying "we don't need typeclasses to do recursion, so we can and should avoid them"
05:46:05 <yitz> augur: not that i agree with the post. but actually i think your argument against it is exactly that strawman argument.
05:46:17 <int-e> Yeah, there's a lot of convenience in not having to think about creating new dictionaries, or which functions need them and in which order...
05:47:01 <dpn`> noob here - I've cabal installed a lib, and can see it in my ~/Library/Haskell/ghc-7.8.3-x86_64/lib/flowdock-0.2.0.0/Chat/Flowdock
05:47:03 <dpn`> but can'
05:47:10 <dpn`> can't import it..
05:47:19 <augur> the post's example use of typeclasses is *explicitly* not the purpose of type classes and has long been one of those things that Haskellers haave to tell newbies not to do
05:47:56 <yitz> augur: you mean defining a Monad instance for Maybe?
05:47:58 <augur> so SYTC could in principle serve a purpose, but as a cautionary tale for misguided OO programmers coming to haskell, NOT as an argument against type classes
05:48:14 <augur> yitz: no I mean defining type classes instead of data
05:48:29 <int-e> it shouldn't use our beloved "Monad" typeclass as an example.
05:50:29 <yitz> dpn`: it needs to appear in the build-depends field in the cabal file of your project.
05:50:45 <yitz> dpn`: the package, that is
05:50:52 <dpn`> yitz ok thanks I'll investigate that
05:52:18 <panosGR_> Hello to everyone !
05:52:27 <vanila> hi :)
05:52:35 <panosGR_> I am a newbie in Haskell (NOT a student).
05:52:39 <panosGR_> :)
05:52:56 <panosGR_> I am trying to learn but i am a bit stuck on type classes !!!
05:52:57 <panosGR_> :(
05:53:06 <vanila> what are you stuck on?
05:53:17 <panosGR_> Hm...ok let me explain...
05:53:38 <panosGR_> i am having a data constructor (my own)...
05:53:56 <panosGR_> and then i am making a data class with just a dummy function...
05:54:47 <panosGR_> ...then i am trying to create an instance of my data constructor from this class...
05:55:03 <latro`a> your terminology is a bit...off
05:55:09 <panosGR_> :(
05:55:12 <panosGR_> Sorry.....
05:55:25 <latro`a> it's OK, but I think rephrasing may clear up some of your confusion
05:55:28 <panosGR_> Do you mind if i show you here ?
05:55:45 <latro`a> you have a type; it has a data constructor, that is, a function that is used to create values of that type
05:55:46 <panosGR_> Am i allowed to paste smallscripts here ??
05:55:48 <int-e> panosGR_: do you have some code you could show us? you can put it on lpaste.net
05:55:52 <latro`a> use lpaste.net
05:56:03 <panosGR_> One moment please.
05:57:29 <lpaste> Panos pasted “No title” at http://lpaste.net/110655
05:57:50 <panosGR_> Hm... the link is.... http://lpaste.net/110655
05:58:48 <panosGR_> Why Type Classes are SOOO hard ??? :(
05:59:38 <latro`a> here your problem is a kind problem
06:00:00 <panosGR_> In my code i am not trying to accomplish anything....just playing around in order to understand ! :)
06:00:15 <int-e> lpaste told us already. Anyway, Haskell's type classes do not work this way. Any type can, in principle, become an instance of MyDataClass. So the type class constraint in  showWhichData :: (MyDataClass a) => a -> [Char]  does not help the compiler at all; all it says is that  testClass  can be used on the argument.
06:00:15 <panosGR_> What do you mean ?
06:00:18 <latro`a> you're basically trying to make all types of the form "MyData a" be an instance of MyDataClass
06:00:30 <sipa> panosGR_: so, the function showWhichData doesn't know that a will always be of type MyData
06:00:41 <sipa> panosGR_: all it knows is that it's some type which satisfies MyDataClass
06:00:47 <int-e> panosGR_: what are you trying to do that is not accomplished by  showWhichData :: MyData a -> [Char] ?
06:00:50 <sipa> so all you can do, is apply testClass on the argument
06:02:33 <latro`a> oh, right, I was thinking of a higher level problem that might not be a problem
06:03:03 <panosGR_> So you mean that in my sipa showWhichData i should not just use "a" but directly the "MyData a" ?
06:03:06 <latro`a> sipa's point is that even though you've only made one instance of MyDataClass, the compiler doesn't know that; all it knows when you provide the constraint is that testClass is defined
06:03:47 <latro`a> so because you can't use testClass alone to define showWhichData, the type should just be MyData a -> [Char] (no constraint on a)
06:03:49 <sipa> panosGR_: right; open world assumption; there may be other types that satisfy MyDataClass, which it doesn't know about right now (perhaps they're defined in a different module)
06:04:11 <sipa> and they won't support pattern matching using MyData1 or MyData2
06:04:18 <panosGR_> OH !!!!! I SEE !!!!!!!
06:04:41 <panosGR_> Now i feel like a stupid !!!! :(
06:04:53 <sipa> you should feel enlightened instead
06:05:03 <int-e> use fewer exclamation mark and you will feel smarter already. ;-)
06:05:14 <latro`a> this is a nontrivial point
06:05:15 <panosGR_> :)
06:05:18 <latro`a> so don't feel stupid
06:05:42 <panosGR_> You mean that it is the same as the (Num a)...meaning that all the numbers belong to that type class ?
06:06:24 <int-e> Type classes in Haskell have almost nothing to do with classes in OO languages. It's a major hurdle for programmers coming to Haskell.
06:06:51 <latro`a> the best way of thinking about it is that if you have a function whose signature is Class a => a->b, all you can do with the argument is apply the functions provided by Class
06:07:10 <int-e> panosGR_: Any type with a Num instance (Integer, Rational, Int, Float, Double...) supports the operations in the type class (addition, multiplication, integer literals (!), etc)
06:07:15 <int-e> @type 0
06:07:16 <lambdabot> Num a => a
06:07:23 <panosGR_> Yeah ! I know what you mean ! By whole programming background (15 years+) is in OO languages !
06:07:25 <latro`a> for example, if Class = Num, all you can use is the functions provided by Num. This *does not* include, among other things, (/)
06:07:34 <int-e> > (0 :: Integer, 0 :: Double, 0 :: Rational) -- so this works
06:07:36 <lambdabot>  (0,0.0,0 % 1)
06:08:13 <panosGR_> Hm...all right...another question rises then...
06:08:14 <yitz> panosGR_: a type class is a little bit (but not exactly) like an "interface" in, say, java.
06:08:40 <panosGR_> Yes, yes ! Correct. I have understood that it is like an interface. :)
06:09:11 <panosGR_> But how come i can have a function signature like (Num a) => a -> Bool ?
06:09:27 <panosGR_> Isn't Num like my MyDataClass type class ?
06:09:56 <latro`a> sure. the function testClass has exactly the signature MyDataClass a => a -> Bool
06:10:05 <latro`a> so there are functions with that signature
06:10:17 <int-e> @type let  foo x = 2*x - 1 < 3  in foo -- foo works for any number. note that (*), (-) and the literals are all provided by the Num class.
06:10:18 <lambdabot> (Ord a, Num a) => a -> Bool
06:10:49 <yitz> "(Num a) => a -> Bool" means: a function that can be applied to any type which is an instance of Num and returns a Bool.
06:10:52 <latro`a> (actually, there are exactly two functions with that signature, testClass and not . testClass)
06:11:02 <int-e> oops. You need something to actually get a Bool out of it -- Ord in this case (providing (<))
06:11:14 <int-e> otherwise you'll end up with just constant functions. Tricky.
06:11:44 <panosGR_> Oh ! I see.
06:12:26 <panosGR_> Thank you really really ALL of you for your time.
06:12:27 <panosGR_> :)
06:12:41 <panosGR_> I will try harder.
06:22:36 <LunarJetman> should be receiving the elephant book today...
06:22:42 <dpn`> I can't find info on the usage of hash here...
06:22:59 <dpn`> count n = do cl >>> (b # text n)  count (n+1)
06:25:34 <Fuuzetsu> The Japanese cover of the elephant book is pretty nice
06:26:23 <dfeuer> LunarJetman, you do know that you can read LYAH for free online, right?
06:28:38 <LunarJetman> dfeuer: I prefer paper
06:37:32 <yitz> bennofs: oh cool. hashable knows how to handle both Storable memory, and GHC ByteArray#. so you should be good for both storable vectors and primitive vectors.
06:38:06 <bennofs> yitz: unfortunately, current vector on hackage also doesn't expose the Prim Vector constructor (git head does)
06:40:12 <yitz> ohhh... bummer
06:40:47 <yitz> it does for mutable tho
06:41:02 <yitz> maybe unsafeThaw it?
06:42:16 <bennofs> yitz: yeah, I could probably unsafeThaw it, extract the MutableByteArray, then unsafeFreeze that
06:45:36 <LunarJetman> my elephant book has arrived.
06:46:37 <Fuuzetsu> get going then ;P
06:46:53 <LunarJetman> Now I need to find the time to read it...
06:46:55 <coppro> for great good!
06:47:52 <marchelzo_> i read somewhere that having lazy evaluation by default is generally considered to be a mistake in haskell. is that true?
06:47:56 <LunarJetman> I will probably make my own Haskell compiler
06:48:24 <exio4> what book is that one?
06:48:46 <LunarJetman> exio4: it is THE haskell book apparantly.
06:49:06 <Fuuzetsu> marchelzo_: opinions vary
06:49:31 <Fuuzetsu> exio4: he means LYAH
06:49:47 <Fuuzetsu> LunarJetman: LYAH won't tell you how to make a compiler, it's a beginner book
06:49:59 <LunarJetman> Fuuzetsu: I already know how to make a compiler.
06:50:14 <wei2912> marchelzo_, well, lazy evaluation in Haskell actually brings about a lot of benefits
06:50:21 <Fuuzetsu> LYAH won't teach you enough Haskell for you to implement a compiler for it*
06:50:25 <wei2912> i can't tell you much about it bc i don't know a lot of Haskell
06:50:32 <wei2912> but from what I know so far, it's a pretty useful feature
06:51:04 <marchelzo_> I'm not doubting that it's useful, but I read that a lot of people think it should be opt-in.
06:51:32 <LunarJetman> Fuuzetsu: LYAH will teach more enough Haskell for me to implement a compiler for the Haskell it teaches me
06:52:09 <exio4> Fuuzetsu: oh, LYAH, should have guessed :P
06:53:22 <vanila> LunarJetman, you should read SPJs book on STG after LYAH to write a haskell compiler
06:53:42 <LunarJetman> STG?
06:53:57 <vanila> it's an intermediate language for compiling haskell
06:53:57 <Fuuzetsu> the GHC commentary is also a fine resource
06:54:16 <LunarJetman> no; I would invent my own intermediate for,
06:54:18 <LunarJetman> form
06:56:07 <Iceland_jack> ch
06:56:07 <Jafet> I read somewhere that claiming that you read some absurd claim somewhere and throwing it at an irc channel without any sort of justification or context is a good way to start a useful discussion
06:56:55 <zwer_> marchelzo_ you miss some of the benefits if laziness isn't default. such as code reuse. http://augustss.blogspot.com/2011/05/more-points-for-lazy-evaluation-in.html
06:57:19 <LunarJetman> the last thing I would look at when making my own Haskell compiler would be GHC.
06:59:02 <Fuuzetsu> Why?
06:59:24 <LunarJetman> because I would be doing it for fun and see how someone else has done it spoils the fun.
07:01:33 <LunarJetman> also I may come up with original solutions to problems that may be better than GHC's solutions to same problems; this is how evolution works.
07:02:24 <vanila> that's a brave and inspiring attitude!
07:02:27 <Jafet> That is... not how evolution works
07:02:30 <Jafet> But ok
07:02:34 <wei2912> lol
07:02:47 <LunarJetman> Jafet: yes it is .. the shark eats the little fish
07:03:42 <Fuuzetsu> Yes, I suppose there is a chance that a person who hasn't even started LYAH might solve problems they don't even know about yet better than a group of people doing this for years, some of which have decades of experience in their respective areas.
07:03:55 <LunarJetman> I shall call my Haskell compiler "elephant".
07:04:18 <jmcarthur> like the postgresql front end? :P
07:04:22 <LunarJetman> Fuuzetsu: I graduated in Computer Science in 1993 mate and I started programming in 1984.
07:04:24 <jmcarthur> oh sorry
07:04:39 <jmcarthur> i misremember a related thing
07:04:50 <Fuuzetsu> LunarJetman: Yes, I'm sure those are the better credentials than everyone else's on the GHC team ‘mate’.
07:05:22 <vanila> Fuuzetsu, Why are you trying to push down his enthusiasm?
07:05:32 <jmcarthur> JHC was originally a project to learn Haskell
07:05:34 <Fuuzetsu> vanila: I'm not, I'm just pointing out his bold statements.
07:06:26 <vanila> Fuuzetsu, you sarcastically belittle him in a horrible pessimistic way that makes it look like live in a world where all creativity has dried up
07:06:29 <Jafet> Whether or not he can make a better haskell compiler is not haskell-related, kindly leave it.
07:06:46 <jmcarthur> i think we should be encouraging
07:06:51 <jmcarthur> if anything
07:06:52 <vanila> I agree
07:07:13 <Fuuzetsu> I encourage him making a compiler, I just don't like the empty words after that part…
07:07:40 <jmcarthur> that's fair
07:07:46 <Septell> Hello, Is there a way to list all the members of a typeclass? I can't find it anywhere.
07:08:04 <jmcarthur> Septell: in ghci? try :i NameOfTypeClass
07:08:05 <Fuuzetsu> Septell: You can use :i TypeClassName to find out the members that are in scope
07:09:23 <jmcarthur> i interpreted "members" as "methods", but the same answer works for both
07:09:28 <Septell> jmcarthur: Exactly what I was going for, thanks!
07:14:06 <LunarJetman> Fuuzetsu: what empty words?
07:14:39 <Fuuzetsu> Discussing this is pointless so I'm not going to.
07:14:49 <Fuuzetsu> I wish you luck on your endavour
07:15:00 <Faith> hello guysss
07:15:25 <Faith> anyone knows how to remove password from bios o
07:15:37 <Fuuzetsu> Faith: That's off-topic on this channel.
07:15:38 <LunarJetman> hopefully it will be as successful as my XML parser: probably the fastest XML parser/generator there is for the language it is implemented in
07:15:53 <Faith> sorry Fuuzetsu
07:19:25 * hackagebot Agda 2.4.2 - A dependently typed functional programming language and proof assistant  http://hackage.haskell.org/package/Agda-2.4.2 (AndreasAbel)
07:21:04 <nitrix> Guys, I need help understanding hackage.
07:21:13 <nitrix> I'm looking at https://hackage.haskell.org/package/sdl2-1.1.0/docs/Graphics-UI-SDL-Video.html
07:21:22 <nitrix> This function: createWindowAndRenderer :: CInt -> CInt -> Word32 -> Ptr Window -> Ptr Renderer -> IO CInt
07:21:46 <nitrix> Nowhere it is documented what those CInt -> CInt -> word32 ares...
07:21:59 <Fuuzetsu> nitrix: did you try clicking on them?
07:22:10 <Fuuzetsu> It takes you to another page which tells you what they are…
07:22:18 <ion> That’s not what he’s asking.
07:22:22 <nitrix> ^
07:22:28 <Fuuzetsu> oh, I see, you're asking what they *do*
07:22:29 <ion> From the source: foreign import ccall "SDL.h SDL_CreateWindowAndRenderer" createWindowAndRenderer :: CInt -> CInt -> Word32 -> Ptr Window -> Ptr Renderer -> IO CInt
07:22:36 <nitrix> It's saddening me that I must assume it has the same interface as the C version.
07:22:42 <Fuuzetsu> you should look up the docs for native SDL functions
07:22:43 <ion> You’ll need to look at SDL_CreateWindowAndRenderer’s documentation.
07:22:50 <ion> The author of the bindings was lazy.
07:23:14 <nitrix> But why hackage doesn't show it's a foreign import?
07:23:29 * Fuuzetsu hides
07:23:37 <ion> It doesn’t (need to) know things like that.
07:24:39 <nitrix> Last thing then, is it idiomatic to work with libraries like this? CInt and Word32 in haskell?
07:25:13 <ion> It would be idiomatic to build a Haskell-like higher-level wrapper on top of those low-level bindings.
07:25:59 <nitrix> ion: Thank for reading betweent he lines. I'm doing terrible at writing cohesives sentences today.
07:26:06 <nitrix> Appreciated.
07:41:43 <yitz> marchelzo_: not just laziness - laziness *by default* provides a lot of advantages
07:42:39 <yitz> oops - gone. forgot that my buffer was scrolled up. sorry folks.
07:49:27 * hackagebot diagrams-lib 1.2.0.3 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-1.2.0.3 (bergey)
07:49:30 * hackagebot diagrams-cairo 1.2.0.2 - Cairo backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-cairo-1.2.0.2 (bergey)
07:49:32 * hackagebot tuple 0.3.0.0 - Various functions on tuples  http://hackage.haskell.org/package/tuple-0.3.0.0 (LennartAugustsson)
07:49:34 * hackagebot diagrams-rasterific 0.1.0.2 - Rasterific backend for diagrams.  http://hackage.haskell.org/package/diagrams-rasterific-0.1.0.2 (bergey)
08:03:58 <nawal> Hey guys
08:04:25 <vanila> hi
08:04:57 <nawal> As an excuse to learn the subtleties of compilation in haskell, I installed the packages http into a cabal sandbox, and the ghc came with bytestring.. I'm trying to compile a simple script using only ghc in the commandline.
08:04:58 <nawal> http://pastebin.com/GBR25T3e
08:05:39 <nawal> For some reason I can't get the -hidir option to see the .hi files in the correct places
08:06:20 <nawal> This includes the error: http://pastebin.com/Ddw5d7ug
08:06:30 <nawal> hello.hs:8:1:
08:06:31 <nawal>     Failed to load interface for ?Network.HTTP.Conduit?
08:06:31 <nawal>     Locations searched:
08:06:31 <nawal>       Network/HTTP/Conduit.hi
08:06:31 <nawal>       Network/HTTP/Conduit.hi-boot
08:06:44 <nawal> All I did in the code is import and attempt to use the module
08:10:08 <nawal> So the question is how do I tell ghc to find the .hi files over there in the right folders?
08:10:29 <Fuuzetsu> @hoogle Monad m => (a -> m ()) -> Maybe a -> m ()
08:10:42 <lambdabot> Data.Foldable mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
08:10:42 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
08:10:42 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
08:12:01 <Fuuzetsu> :t mapM_ (undefined :: Int -> IO String) (undefined :: Maybe Int)
08:12:02 <lambdabot>     Couldn't match expected type ‘[Int]’ with actual type ‘Maybe Int’
08:12:03 <lambdabot>     In the second argument of ‘mapM_’, namely
08:12:03 <lambdabot>       ‘(undefined :: Maybe Int)’
08:12:13 <Fuuzetsu> :t Data.Foldable.mapM_ (undefined :: Int -> IO String) (undefined :: Maybe Int)
08:12:14 <lambdabot> IO ()
08:12:19 <Fuuzetsu> neat.jpeg
08:14:30 * hackagebot tuple 0.3.0.1 - Various functions on tuples  http://hackage.haskell.org/package/tuple-0.3.0.1 (LennartAugustsson)
08:15:23 <Taneb> Which is better, putChar '\n' or putStrLn ""?
08:15:57 <hpc> @src putStrLn
08:15:57 <lambdabot> putStrLn s = do putStr s; putChar '\n'
08:16:09 <hpc> whichever looks better for your use case
08:16:28 <Jafet> $+$
08:16:51 <wandernauta> Hey all! Is there a slightly-less-lazy version of Control.Concurrent.Chan's getChanContents? I'd like to see what's in a channel right now, without removing them.
08:18:06 <Jafet> dupChan
08:19:19 <yitz> nawal: try this: ghc -package-db .cabal-sandbox/x86_64-osx-ghc-7.8.3-packages.conf.d --make hello.hs
08:19:51 <yitz> nawal: why do you want to use raw ghc, and not cabal?
08:20:07 <yitz> nawal: especially inside a cabal sandbox
08:20:38 <wandernauta> Jafet: Hmm, I looked at that, but the hackage docs claim "the duplicate channel begins empty" - would you dup the channel before ever writing to it? And would you still use getChanContents? Thanks.
08:21:14 <Jafet> Oh well, I assumed it duplicated the channel.
08:21:16 <Fuuzetsu> what's a nicer way to write this: M.keys . (^. publishedActions) <$> askCfg
08:21:35 <wandernauta> Jafet: It seems it duplicates some kind of reference to the channel, not its contents.
08:21:47 <yitz> Taneb: or putStr "\n" or putStr (unlines [""]). all fine
08:22:16 <Taneb> hpc, yitz, OK
08:23:10 <Luke> is there a way to pass command line args to a bin run from 'cabal run' from within the cabal file?
08:24:31 * hackagebot tuple 0.3.0.2 - Various functions on tuples  http://hackage.haskell.org/package/tuple-0.3.0.2 (LennartAugustsson)
08:24:54 <Jafet> You could make your own channel that can be frozen atomically.
08:25:32 <bvad> Hi guys, I'm having trouble understanding why (return $ randomRIO (1,6)) fits the (a -> m b) part of forM, since the type of (return $ randomRIO (1,6)) is m (IO a).. Any hints?
08:26:58 <Iceland_jack> :t return (randomRIO (1,6))
08:27:00 <lambdabot> (Random a, Num a, Monad m) => m (IO a)
08:27:02 <Iceland_jack> :t return (randomRIO (1,6)) :: (Num a, Random a) => a -> IO a
08:27:03 <lambdabot> (Random a, Num a) => a -> IO a
08:27:07 <edlinde> just started to read about functors. To look at fmap: :(a->b)-> f a -> f b, this is just map for lists… does that mean the “f” is just “[]”?
08:27:07 <yitz> bvad: what is the "return" for? what monad? randomRIO is already in IO.
08:27:24 <wandernauta> Jafet: Hmm, I guess I'll have to try that. Thanks!
08:27:26 <simpson> edlinde: It can be, but other Functors exist as well.
08:27:28 <yitz> @type randomRIO
08:27:29 <lambdabot> Random a => (a, a) -> IO a
08:27:29 <Jafet> data Q a = Q (MVar ()) (IORef Int) (Chan a) or so
08:27:32 <Iceland_jack> edlinde: f can be [], but also other things
08:27:53 <edlinde> simpson: Iceland_jack : I get that.. but in the case of lists.. is it always going to be [] ?
08:28:07 <Iceland_jack> sure
08:28:11 <Iceland_jack> :t fmap :: (a -> b) -> [a] -> [b]
08:28:12 <lambdabot> (a -> b) -> [a] -> [b]
08:28:13 <edlinde> or it can be some other function too for lists?
08:28:22 <simpson> bvad: Because the type system knows that (->) is a Monad!
08:28:26 <zwer_> @src [] fmap
08:28:26 <lambdabot> fmap = map
08:28:29 <Iceland_jack> edlinde: Just one thing
08:28:43 <edlinde> Iceland_jack: what?
08:28:57 <Jafet> f is not a function; f is a type variable. In this case f ~ [].
08:29:10 <yitz> @type return (randomRIO (1,6)) :: Maybe (IO Int)
08:29:11 <lambdabot> Maybe (IO Int)
08:29:13 <Iceland_jack> 'fmap' is just one function for lists
08:29:18 <edlinde> Jafet: ok
08:29:21 <Iceland_jack> namely 'fmap = map'
08:29:29 <Jafet> Substituting f~[], fmap :: (a -> b) -> [] a -> [] b
08:29:31 * hackagebot checkers 0.4.0 - Check properties on standard classes and data structures.  http://hackage.haskell.org/package/checkers-0.4.0 (ConalElliott)
08:29:34 * hackagebot geniplate 0.6.0.5 - Use Template Haskell to generate Uniplate-like functions.  http://hackage.haskell.org/package/geniplate-0.6.0.5 (LennartAugustsson)
08:29:35 * hackagebot checkers 0.4.1 - Check properties on standard classes and data structures.  http://hackage.haskell.org/package/checkers-0.4.1 (ConalElliott)
08:29:39 <edlinde> ok
08:29:46 <Fuuzetsu> let f :: Maybe Int; f = do { let [x, y, z] = []; return y } in f
08:29:51 <Fuuzetsu> > let f :: Maybe Int; f = do { let [x, y, z] = []; return y } in f
08:29:53 <lambdabot>  <hint>:1:59: parse error on input ‘}’
08:29:57 <Fuuzetsu> > let f :: Maybe Int; f = do { let [x, y, z] = []; return y; } in f
08:29:59 <lambdabot>  <hint>:1:58: parse error on input ‘;’
08:29:59 <edlinde> I guess I need to understand when something is a “concrete type” vs. being a “type constructor"
08:30:13 <edlinde> so [a] is a concrete type?
08:30:16 <Fuuzetsu> hm, seemed legit to me
08:30:17 <zwer_> edlinde do you understand kinds?
08:30:30 <yitz> bvad: the extra return could wrap any monad around your IO return type, but you almost never want to do this. in this case, you are defaulting to the function monad for some strange reason.
08:30:31 <edlinde> zwer_: yeah maybe
08:30:34 <Fuuzetsu> > let f = do { let [x, y, z] = []; (return y :: Maybe Int); } in f
08:30:35 <lambdabot>  <hint>:1:57: parse error on input ‘;’
08:30:40 <edlinde> just read about kinds briefly in LYAH
08:30:44 <Fuuzetsu> what's the problem here?
08:30:58 <Iceland_jack> edlinde: If you use 'concrete type' to mean something of kind *, then [a] is a concrete type
08:31:00 <Jafet> let also has block syntax
08:31:09 <Iceland_jack> @kind ∀a. [a]
08:31:10 <lambdabot> *
08:31:14 <wandernauta> Jafet: I think I'll try to cook up something with STM :) Exciting stuff.
08:31:16 <Jafet> > do let {a = b}; in ()
08:31:17 <lambdabot>  <hint>:1:17: parse error on input ‘in’
08:31:26 <Jafet> > do let {a = b}; return ()
08:31:27 <lambdabot>  No instance for (GHC.Show.Show (m0 ()))
08:31:28 <lambdabot>    arising from a use of ‘M56345010624897619846257.show_M56345010624897619846...
08:31:28 <lambdabot>  The type variable ‘m0’ is ambiguous
08:31:28 <lambdabot>  Note: there are several potential instances:
08:31:28 <lambdabot>    instance [safe] GHC.Show.Show a =>
08:31:48 <Jafet> Why isn't Identity the default or something
08:31:50 <Fuuzetsu> > let f = do { let { [x, y, z] = []}; (return y :: Maybe Int); } in f
08:31:52 <lambdabot>  Just *Exception: <interactive>:3:20-33: Irrefutable pattern failed for patte...
08:32:22 <Fuuzetsu> hm, I thought it would call Maybe's fail
08:32:44 <Fuuzetsu> at least this code here seems to think it would
08:32:45 <srhb> Fuuzetsu: You didn't put the return in the same do block though
08:33:00 <srhb> Not that I'm sure it will then, but surely that is a minimum requirement
08:33:06 <bvad> So the example comes from http://en.wikibooks.org/wiki/Haskell/Understanding_monads/Solutions/State
08:33:17 <Jafet> That isn't a bind, so there is no monadic fail.
08:33:24 <monochrom> Fuuzetsu: no, let is not desugared to use fail, only <- is.
08:33:27 <Fuuzetsu> srhb: it's in do
08:33:29 <yitz> bvad: here is what I get in ghci: return (randomRIO (1, 6)) :: (Random a, Num a, Monad m) => m (IO a)
08:33:45 <Jafet> > do x <- Nothing; return x
08:33:46 <Fuuzetsu> monochrom: yeah, I just realised that the Nothing I'm able to get here is from a line before the match
08:33:47 <lambdabot>  Nothing
08:33:51 <Iceland_jack> bvad: that's a pretty bad example
08:34:01 <Fuuzetsu> perhaps should should catch that too…
08:34:03 <bvad> yitz: exactly, but it fits into (a -> m b)
08:34:15 <bvad> Iceland_jack: I thought that as well..
08:34:16 <yitz> bvad: that is the real type. what lambdabot is saying is weird. probably because of all the crazy lens stuff they put into scope in lambdabot.
08:34:17 <Iceland_jack> @ty \n -> replicateM n (randomRIO (1, 6))
08:34:18 <lambdabot> (Random a, Num a) => Int -> IO [a]
08:34:40 <monochrom> let's desugaring only adds an "in".
08:35:05 <Iceland_jack> ghci> import System.Random
08:35:06 <Iceland_jack> ghci> replicateM 10 (randomRIO (1, 6))
08:35:06 <Iceland_jack> [3,3,1,6,1,5,5,6,5,6]
08:35:07 <yitz> bvad: because the type (->) a is an instance of Monad
08:35:31 <bvad> Iceland_jack: Of course..
08:35:43 <bvad> yitz: I should just realize that everything is a monad :)
08:36:04 <monochrom> naw, not everything
08:36:06 <Iceland_jack> bvad: Basically the 'return' is const there
08:36:16 <yitz> bvad: not everything. and the extra monad is really a red herring here.
08:36:20 <Iceland_jack> ghci> forM [1..5] (return $ randomRIO (1,6))
08:36:20 <Iceland_jack> [4,2,2,5,5]
08:36:20 <Iceland_jack> ghci> forM [1..5] (const $ randomRIO (1,6))
08:36:20 <Iceland_jack> [4,4,1,5,3]
08:36:41 <Iceland_jack> it's a terrible example, I need to run: can someone edit the example on WikiBooks??
08:36:42 <bvad> yitz: I was exaggerating just a bit :)
08:37:00 <Iceland_jack> ghci> forM [1..5] (\_ → randomRIO (1,6))
08:37:00 <Iceland_jack> [3,4,5,1,1]
08:37:16 <bvad> Iceland_jack: That was the solution I came up with
08:37:24 <bvad> which one fits the wikibook?
08:37:36 <Jafet> ... unicode arrow, but not lambda?
08:37:46 <Iceland_jack> Jafet: a lambda doesn't work
08:38:06 <Iceland_jack> bvad: I'm not sure if there is a greater context, if the book is introducing forM or something I'd use const or \_ -> ..., otherwise replicateM for sure
08:38:08 <Jafet> I thought UnicodeSyntax enabled that.
08:38:22 <geekosaur> lambda happens to be a *letter* not a math symbol
08:38:28 <Iceland_jack> bbl
08:38:32 <bvad> Iceland_jack: It's part of "Understanding monads"
08:38:51 <Jafet> Something about hobgoblins of little minds
08:39:19 <geekosaur> you're welcome ot pitch your cultural imperialism at the haskell language committee
08:39:28 <Iceland_jack> bah, missed my bus
08:40:01 <bvad> Iceland_jack: Sorry about that :o
08:40:26 <simpson> Hm. Is there any way to, when doing heap profiling in GHC, examine where things are allocated? I see lots of lists, but I don't know where they are.
08:40:30 <Iceland_jack> no problem
08:40:32 <nshepperd> only a monster would try to stop me using λ in my variable names
08:43:24 <yitz> bvad, Iceland_jack oh my, yes, what a terrible code example
08:43:40 <yitz> Iceland_jack: are you fixing it now that you missed your bus? :P
08:43:50 <Iceland_jack> Sure
08:43:52 <bvad> yitz: I turned it into the const version
08:44:11 <bvad> Not quite sure if that's the best example..
08:44:13 <yitz> nah the normal way is Iceland_jack's way
08:44:17 <Iceland_jack> Is there any reason not to use replicateM?
08:44:28 <bvad> Iceland_jack: Not really
08:44:33 * hackagebot djinn 2014.9.7 - Generate Haskell code from a type  http://hackage.haskell.org/package/djinn-2014.9.7 (LennartAugustsson)
08:44:37 <Iceland_jack> I'll avoid using flip
08:44:45 <yitz> replicateM n $ randomRIO (1, 6)
08:44:57 <edlinde> In : class Functor f where   fmap :: (a -> b) -> f a -> f b   … Is f a “type variable” or a functor?
08:45:16 <bvad> yitz: I like that one
08:45:49 <edlinde> I am trying to make sense of this statement —> “fmap takes a function from one type to another and a functor applied with one type and returns a functor applied with another type.”
08:45:51 <edlinde> is that right?
08:45:52 <triliyn> It's a type variable representing a type that must be a functor
08:46:13 <edlinde> triliyn: thats how I understood it initially
08:46:14 <Iceland_jack> it's also inconsistent on how it writes a tuple
08:46:18 <Iceland_jack> might as well change that too
08:47:23 <yitz> oh wow, augustss upload a new version of djinn for the first time in years. looks like just a port to github though.
08:47:36 <edlinde> triliyn: so it should be more like.. returning a function that is a functor, which takes an arg of type a?
08:48:00 <edlinde> arg of type b sorry
08:48:30 <triliyn> edlinde: the functions themselves or the arguments to fmap aren't really functors; a functor technically refers to the type constructor together with the implementation of fmap
08:48:41 <triliyn> It might help to consider how it works on particular functors
08:48:51 <edlinde> ok
08:49:05 <triliyn> [] is a functor; fmap specialized to [] takes a function and returns a similar function that acts on lists
08:49:29 <triliyn> (Or you could say that it takes a function and a list and applies the function to each element of the list)
08:50:02 <edlinde> ok
08:50:08 <Fuuzetsu> @hoogle b -> (a -> Maybe b) -> b
08:50:12 <lambdabot> Data.IntMap.Strict updateMax :: (a -> Maybe a) -> IntMap a -> IntMap a
08:50:12 <lambdabot> Data.IntMap.Lazy updateMax :: (a -> Maybe a) -> IntMap a -> IntMap a
08:50:12 <lambdabot> Data.IntMap.Strict updateMin :: (a -> Maybe a) -> IntMap a -> IntMap a
08:50:24 <edlinde> instance Functor [] where fmap = map
08:50:42 <edlinde> I guess that explains how [] is an instance of a Functor typeclass?
08:51:12 <triliyn> Yes
08:51:19 <monochrom> edlinde: “fmap takes [a function from one type to another] (a->b) and [a functor applied with one type] (f a) and returns [a functor applied with another type] (f b).”  This sentence is technically right and most importantly proves why you should just write the type itself and not bother "explain" in natural language. what's wrong with natural language? answer: lacks scoping, too few pronouns, pronouns used ambiguously.
08:51:21 <edlinde> ok
08:51:38 <Iceland_jack> monochrom: (absolutely)
08:51:58 <Iceland_jack> Explaining types in natural language ==> https://i.imgur.com/bJ5C9.gif
08:52:40 <trap_exit> anyone here using eclipse fp?
08:52:43 <trap_exit> i'm looking at eclipse fp haskell demos
08:52:46 <trap_exit> and am convinced this is the shit
08:52:50 <Fuuzetsu> Iceland_jack: not enough hand-waving
08:53:07 <Taneb> trap_exit, it's damned annoying to set up
08:53:12 <Fuuzetsu> It's Eclipse.
08:53:28 <trap_exit> yeah
08:53:31 <trap_exit> but for > 10K loc projects
08:53:33 <trap_exit> I find emacs a bit lacking
08:53:37 <trap_exit> i.e. I want an IDE, not an editor
08:53:45 <trap_exit> Taneb: how bad is it to setup?
08:53:49 <Fuuzetsu> hasktags is all you need
08:53:54 <sshine> Fuuzetsu, at least you are right whatever you mean. ;)
08:53:54 <trap_exit> isnt' tit download eclipse, downlaod java 7, download eclipse fp, then start jar hell
08:54:00 <edlinde> thanks monochrom
08:54:07 <Taneb> trap_exit, syntax highlighting fails without telling you why sometimes
08:54:19 <Taneb> (the answer is .cabal/bin needs to be in $PATH, iirc)
08:56:03 <Fuuzetsu> @pl takeCommand x = fromMaybe x (x ^? prefixed prompt)
08:56:03 <lambdabot> takeCommand = ap fromMaybe (^? prefixed prompt)
08:56:14 <Fuuzetsu> damn ap, I always forget you
08:56:55 <Iceland_jack> if you like operators
08:56:56 <Iceland_jack> @ty fromMaybe <*> (^? ?refixed ?prompt)
08:56:57 <lambdabot> (?refixed::t -> Getting (First a) a a, ?prompt::t) => a -> a
08:57:13 <geekosaur> someday @pl should be taught about applicative, yeh
08:58:31 <Fuuzetsu> I have that now
08:59:03 <Fuuzetsu> I think I pretty much always use <*> in favour of ap
08:59:22 <Fuuzetsu> guess it's nicer than a section
09:04:09 <Iceland_jack> Maybe I'll take another jab at catching the bus :)
09:04:25 <bvad> Iceland_jack: Good luck :)
09:04:48 <Iceland_jack> Thanks bvad, good luck with your Haskelling
09:05:37 <bvad> Iceland_jack: Thank you!
09:06:10 <Iceland_jack> also s/jab/shot/
09:08:27 <yitz> Fuuzetsu: before the days of <*>, everyone always used ap as infix anyway
09:08:45 <yitz> Fuuzetsu: except @pl
09:11:12 <Fuuzetsu> that's way before my time
09:22:37 <yitz> Fuuzetsu: if you don't like ap in the results of @pl, you can always replace it with ((join .) . flip (.) (flip (.)) . flip (.))
09:22:42 <yitz> @type (join .) . flip (.) (flip (.)) . flip (.)
09:22:42 <lambdabot> (a1 -> b -> a) -> (a1 -> b) -> a1 -> a
09:24:01 <Fuuzetsu> that doesn't look right
09:24:01 <Fuuzetsu> :t ap
09:24:02 <lambdabot> Monad m => m (a -> b) -> m a -> m b
09:25:09 <Fuuzetsu> I guess it works out, yeah
09:25:19 <Fuuzetsu> only for (-> a1) though
09:25:26 <yitz> @pl takeCommand x = fromMaybe x (x ^? prefixed prompt)
09:25:26 <lambdabot> takeCommand = ap fromMaybe (^? prefixed prompt)
09:25:26 <Fuuzetsu> (->) a1 rather
09:25:57 <yitz> @type \ x -> fromMaybe x (x ^? prefixed prompt)
09:25:58 <lambdabot> Not in scope: ‘prompt’
09:26:23 <Fuuzetsu> prompt = "Yi> "
09:26:30 <Fuuzetsu> but yes I see that it works just by substituting m
09:26:39 <yitz> @type \ x -> fromMaybe x (x ^? prefixed "Yi> ")
09:26:40 <lambdabot> [Char] -> [Char]
09:27:18 <yitz> @type ((join .) . flip (.) (flip (.)) . flip (.)) fromMaybe (^? prefixed "Yi> ")
09:27:19 <lambdabot> [Char] -> [Char]
09:28:22 <yitz> Fuuzetsu: that's the only thing @pl uses it for
09:28:41 <Zenol> Can some one explain me why  fmap (take 5) $ sequence . repeat $ return "String" didn't return a list of 5 "hello" (inside a IO monad). Actualy y have some computation that create random objects, typed IO Stuff, and I would like to filter only some of thos generated things.
09:29:37 * hackagebot setlocale 1.0.0.1 - Haskell bindings to setlocale  http://hackage.haskell.org/package/setlocale-1.0.0.1 (Kritzefitz)
09:29:44 <Fuuzetsu> :t fmap (take 5) $ sequence . repeat $ return "String"
09:29:45 <lambdabot> (Functor f, Monad f) => f [[Char]]
09:29:54 <Fuuzetsu> this is a pretty convoluted way to do something
09:30:27 <nshepperd> > replicateM 5 "String"
09:30:28 <lambdabot>  ["SSSSS","SSSSt","SSSSr","SSSSi","SSSSn","SSSSg","SSStS","SSStt","SSStr","SS...
09:30:40 <nshepperd> whoops
09:31:10 <nshepperd> not quite the right thing there
09:31:19 <yitz> Zenol: sequence in the IO monad will force all of the "calculations" to be run. so this will hang.
09:31:21 <Zenol> the return "String" is actualy some complex computation typed IO StateMachine. And only some of those randomly generated VM are actualy usable.
09:31:35 <Fuuzetsu> it didn't work because you're trying to sequence an infinite list
09:31:44 <Fuuzetsu> (of computations
09:31:45 <Fuuzetsu> )
09:31:48 <Zenol> yitz: Thanks. Is there something else than sequence I can use to compute a lazy list?
09:32:44 <Fuuzetsu> are you just trying to get a list of a result of computation ran N times?
09:33:15 <Zenol> the computation use System.Random, so yes, a list of the same computation but not with the same result.
09:33:35 <yitz> Zenol: how do you know which ones are usable? do you need to test each result? do you stop after the first failure?
09:34:05 <nshepperd> so you want N random values such that _?
09:34:20 <Zenol> yitz: I should test each result, I would like to use something like filter on an infinite list, and then apply "take 10" for exemple.
09:35:33 <Zenol> nshepperd: Some of the generated VM are ill, and theorically they could all be ill (although the probability is 0, hehe), and I wan't 10 VM non-ill.
09:38:43 <nshepperd> > let replicateMWith pred m 0 = return []; replicateMWith pred m n = m >>= (\x -> if pred x then x : replicateMWith pred m (n-1) else replicateMWith pred m n) in replicateMWith (>0.5) getRandom 5
09:38:45 <lambdabot>  Not in scope: ‘getRandom’
09:38:50 <nshepperd> boo
09:43:34 <yitz> Zenol: yeah i would probably just write the loop manually using recursion and a test like nshepperd. there are various libraries for imperative-style looping. some of them might have something useful. but i would just write it.
09:43:35 <bvad> I added a second solution to exercise 3 at https://en.wikibooks.org/w/index.php?title=Haskell/Understanding_monads/Solutions/State&stable=0, should I keep the old one there? The old one matches a function shown earlier, but it's very verbose..
09:45:58 <Fuuzetsu> @package monad-loops
09:45:59 <lambdabot> http://hackage.haskell.org/package/monad-loops
09:46:16 <nshepperd> whoops, main body should be replicateMWith pred m n = m >>= (\x -> if pred x then (x:) <$> replicateMWith pred m (n-1) else replicateMWith pred m n)
09:46:31 <Jafet> @type unfoldrM
09:46:34 <lambdabot>     Not in scope: ‘unfoldrM’
09:46:35 <lambdabot>     Perhaps you meant one of these:
09:46:35 <lambdabot>       ‘BS.unfoldr’ (imported from Data.ByteString),
09:46:38 <Fuuzetsu> :t iterate
09:46:39 <lambdabot> (a -> a) -> a -> [a]
09:46:40 <Jafet> Weak
09:46:42 <Fuuzetsu> :t iterateM
09:46:43 <lambdabot>     Not in scope: ‘iterateM’
09:46:44 <lambdabot>     Perhaps you meant one of these:
09:46:44 <lambdabot>       ‘iterate’ (imported from Data.List),
09:46:45 <Fuuzetsu> hm
09:46:58 <Fuuzetsu> :t liftM iterate
09:46:59 <lambdabot> Monad m => m (a -> a) -> m (a -> [a])
09:48:05 <yitz> bvad: not sure. where is the exercise? it could be that writing out the state monad calculation (basically re-inventing the wheel of replicateM) is needed in context of where the exercise appears.
09:48:23 <Fuuzetsu> > liftM2 iterate (\c -> Just c:'x') (Just 'y')
09:48:24 <lambdabot>  Couldn't match expected type ‘a0 -> [Data.Maybe.Maybe a0]’
09:48:24 <lambdabot>              with actual type ‘Data.Maybe.Maybe
09:48:24 <lambdabot>                                  (GHC.Types.Char -> GHC.Types.Char)’Couldn't ...
09:48:24 <lambdabot>              with actual type ‘GHC.Types.Char’
09:48:24 <lambdabot>  Relevant bindings include c :: a0 (bound at <interactive>:1:18)
09:48:41 <Fuuzetsu> > liftM2 iterate (Just $ \c -> c:'x') (Just 'y')
09:48:42 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘[GHC.Types.Char]’
09:48:42 <lambdabot>  Expected type: Data.Maybe.Maybe (GHC.Types.Char -> GHC.Types.Char)
09:48:42 <lambdabot>    Actual type: Data.Maybe.Maybe
09:48:42 <lambdabot>                   (GHC.Types.Char -> [GHC.Types.Char])Couldn't match expected...
09:48:42 <lambdabot>              with actual type ‘GHC.Types.Char’
09:50:06 <Fuuzetsu> > take 20 <$> liftM2 iterate (Just succ) (Just 0)
09:50:08 <lambdabot>  Just [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]
09:50:12 <nshepperd> iterateUntil from monad-loops looks like the thing for this scenario
09:50:44 <nshepperd> replicateM 5 $ iterateUntil predicate $ getRandomValue
09:50:49 <bvad> yitz: Basically the exercise tells you to implement the same function that you did in exercise 1, but this time using state
09:51:14 <bvad> "
09:51:16 <bvad>     Similarly to what was done for rollNDiceIO, implement a function rollNDice :: Int -> GeneratorState [Int] that, given an integer, returns a list with that number of pseudo-random integers between 1 and 6.
09:51:19 <bvad>     Similarly to what was done for rollNDiceIO, implement a function rollNDice :: Int -> GeneratorState [Int] that, given an integer, returns a list with that number of pseudo-random integers between 1 and 6.
09:51:21 <bvad>     Similarly to what was done for rollNDiceIO, implement a function rollNDice :: Int -> GeneratorState [Int] that, given an integer, returns a list with that number of pseudo-random integers between 1 and 6.
09:51:27 <yitz> nshepperd: not exactly. you want to keep going until you have found a certain number of results that satisfy the predicate. so there is state involved.
09:51:28 <bvad> Wow, sorry about that
09:52:55 <yitz> bvad: hmm, yeah. if we use replicateM for exercise 1, there is no change in the answer for exercise 3. but it sounds like the intention is to write out a state monad calculation. so this whole thing needs more thought.
09:52:57 <nshepperd> yitz: no need, you can convert sometimesBadRandom into alwaysGoodRandom with iterateUntil, then you replicateM to get 5 goodRandoms
09:53:42 <bvad> yitz: Which is why I thought it was a good idea to leave both solutions there :)
09:54:20 <yitz> nshepperd: i suppose. not neat enough to make it worth the external dependency. i would just write it out like you did originally.
09:54:47 <bvad> yitz: I guess the first solution illustrates how to use put and get, but that isn't how you would typically write your own code..
09:55:12 <nshepperd> I guess
09:55:25 <yitz> bvad: yeah, i see. not sure what would be best here.
09:55:45 <nshepperd> though you can just paste in the monad-loops implementation, and save yourself some effort
09:55:47 <bvad> yitz: I'll leave both!
09:55:56 <dart> hi
09:56:05 <bvad> hi dart
09:56:37 <dart> what is the web framework that gets less in your way ? can't decide between yesod and snap
09:56:45 <srhb> What does that mean?
09:56:59 <bvad> I went with snap, seems to be a bit more simplistic in its implementation..
09:57:25 <benzrf> it seems to me that snap is more like sinatra and yesod is more like rails
09:57:35 <dart> that's what i thought
09:57:44 <bvad> benzrf: Oh my, rails.. :)
09:58:24 <dart> i was playing with hast this weekend, it's pretty cool
09:58:26 <dart> *haste
09:59:22 <dart> is it possibile to use it with snap in a clean way ? anyone has any experience ?
10:00:44 <bvad> dart: haste looks cool :O
10:01:43 <dart> bvad: yeah, i got stuck trying to pass to the client a file downloaded on the server :S
10:02:42 <dart> bvad: but it allows a really fast development workflow
10:02:53 <bvad> dart: it sure looks like it
10:07:17 <vanila> https://www.youtube.com/watch?v=TS1lpKBMkgg
10:07:27 <vanila> scala talk relevant to haskell compilers
10:07:32 <yitz> dart: there are a number of nice haskell-to-js packages. another popular one is fay. ghcjs is probably the most featureful, but has a pretty big js runtime.
10:11:55 <bvad> yitz, dart: Don't forget PureScript :)
10:13:28 <hiptobecubic> christiansen`, turns out that video is as bad as the abstract would suggest.
10:13:43 <yitz> bvad: sure, there are a bunch of them. i don't know all of them.
10:14:01 <stepcut> don't forget idris!
10:14:24 <bvad> yitz: I've just been hearing good things about purescript, that's all.
10:14:37 <bvad> stepcut: idris to JS?
10:14:48 <yitz> stepcut: ok but it's not exactly haskell. like elm, in that sense. (but not at all like elm of course)
10:14:49 <stepcut> bvad: yup -- builtin by default
10:14:58 <bvad> stepcut: Cool!
10:15:01 <stepcut> yitz: it's like haskell -- but better ;)
10:15:32 <stepcut> yitz: if you ignore all the fancy stuff -- it's actually a lot like H98
10:15:41 <lpaste> latermuse pasted “Ghci looking for modules in wrong directory.” at http://lpaste.net/110669
10:15:43 <yitz> stepcut: better in some sense, maybe. still a bit experimental i think. but really really cool and always improving.
10:15:56 <latermuse> Can someone help me figure out a quick problem with GHCI? I put the details in that paste.
10:17:28 <bvad> latermuse: Just a shot in the dark - does ghci pick up the cabal config? shouldn't it go into ~/.ghci?
10:17:46 <Fuuzetsu> why would GHCi look for cabal config?
10:17:56 <yitz> stepcut: once they make it lazy by default and with full type inference, i'm on board (just kidding)
10:18:05 <Fuuzetsu> I'm guessing latermuse mixed --user and and --global
10:18:09 <stepcut> yitz: yuck!
10:18:22 <bvad> cabal repl would probably look at .cabal/*
10:18:52 <stepcut> yitz: With GHC 7.10, there will be a strict option and it doesn't have full type inference already with enough extensions enabled ;)
10:18:55 <latermuse> Okay great. How can I get ghci to look at the correct directory? Is there a config for that?
10:19:08 <Fuuzetsu> you can use -i
10:19:16 <Fuuzetsu> ghci --help
10:19:21 <Fuuzetsu> you should probably fix your packages
10:19:23 <stepcut> yitz: so clearly idris is ahead of the curve
10:19:28 <Fuuzetsu> does ghc-pkg check not say you have broken packages?
10:19:44 <latermuse> It says nothing about broken packages
10:19:58 <yitz> stepcut: so that's why i mostly avoid those extensions, or use them only very carefully. and you definitely won't see me using the "strict" option. a good alias for that would be "not-haskell".
10:20:17 <latermuse> I can use -i, but thats a inconvenient every time I load ghci
10:20:23 <geekosaur> ghc-pkg supposedly works there. one question I would ask is, are you running it as meow or as admin? and how did you get there (login, su, sudo, ...)
10:20:25 <latermuse> Isnt there a config file somewhere for that?
10:20:32 <latermuse> running as admin
10:20:44 <latermuse> normal tty login
10:21:13 <yitz> stepcut: but of course idris won't be going in that direction. it's inspired in many ways by haskell, and so has many similarities, but it's definitely not haskell and never will be.
10:21:19 <latermuse> I suppose I could use :set in the .ghci config file, but that feels a bit hacky to me
10:21:36 <stepcut> yitz: indeed, Haskell is not the greatest language ever -- only the language used to implement the greatest language ever
10:21:38 <latermuse> there must be a way to point it at the correct location or even add locations
10:22:00 <yitz> stepcut: this is starting to sound religious
10:22:00 <Fuuzetsu> latermuse: fixing your package directories is the correct way, not adding it somewhere in .ghci or whatever
10:22:27 <latermuse> What is broken about my package directories though? GHC can see the modules just fine
10:23:18 <latermuse> oh I see
10:23:31 <latermuse> the files in my package.conf.d are pointing at the wrong directory
10:23:39 <stepcut> yitz: anyway, the strictness in idris is nice. If you actually want to make a control structure like 'if' it is very easy to add the Lazy marking and the compiler does all the lifting automatically. If you want to work with infinite streams, then you use a proper codata structure like the Stream type.
10:23:50 <latermuse> so I can do a quick sed 's/meow/admin/g' and fix it?
10:23:54 <geekosaur> you copied it from the other user, didn't you
10:24:08 <geekosaur> you'll need to edit them and then: ghc-pkg recache --user
10:24:09 <latermuse> yes, it was copied
10:24:15 <Fuuzetsu> latermuse: you really are asking whether you should ‘sed’ to change your conf files while insisting there is nothing wrong with your setup?
10:24:20 <latermuse> can ghc-pkg edit it automatically?
10:24:48 <yitz> stepcut: it's a different approach. i still like haskell's. so far, anyway. not moving my commercial codebase to idris just yet...
10:24:53 <stepcut> yitz: Seems like I would add 'Lazy' in Idris far less than I would want to add ! in Haskell
10:25:15 <latermuse> fuuzetsu: obviously something is wrong with my setup or I wouldnt be on here asking for help
10:25:35 <bitemyapp> stepcut: how much Haskell have you written?
10:25:57 <stepcut> bitemyapp: gobs and gobs. Been a full-time Haskell developer for 10+ years
10:26:08 <bitemyapp> stepcut: do you do a lot of perf/timing sensitive work?
10:26:10 <yitz> stepcut: i almost never need to use ! in haskell.\
10:26:21 <monochrom> latermuse: I think it's time to read my http://www.vex.net/~trebla/haskell/sicp.xhtml . It's very strange to copy stuff like this from another user. It's brittle.
10:26:45 <stepcut> bitemyapp: some
10:26:47 <bitemyapp> stepcut: I don't use ! very much at all. I've got some rather fast code that I wrote recently and ! is literally the perf item of least concern.
10:26:51 <latermuse> I didnt actually copy it. I got a new computer and used migration.
10:27:03 <latermuse> If a simple sed command can solve this, then thats better than sitting and waiting for everything to recompile
10:27:17 <Fuuzetsu> nix can automatically share packages as if by magic *hint* *hint*
10:27:36 <monochrom> alright, I don't know what migration does.
10:27:44 <bitemyapp> stepcut: there's not a particularly good reason for a language with mandatory garbage collection to default to strictness. You've already given up applicability to hardcore systems problems, you might as well get nice functions by default as well.
10:28:12 <latermuse> osx migration tool. It works well except for hard-coded directories like in the haskell package conf files
10:28:34 <geekosaur> it just copies files. it has little knowledge of what's in them, and for example cannot rewrite hardcoded pathnames
10:28:49 <latermuse> exactly
10:28:56 <yitz> stepcut: i don't really care about whether it's codata vs. data under the hood. i want the nicer semantics of lazy by default.
10:29:28 <latermuse> why is haskell using hard coded path names anyways? it would be better if you could change it from a config file
10:29:45 <latermuse> anyways thats not my business. talk to you guys later. thanks for the help
10:29:53 <yitz> latermuse: you can do that. use sandboxes.
10:29:55 <geekosaur> I was just wondering if perhaps it should be changed to use paths relative to the package.conf.d
10:30:05 <geekosaur> (also for sandboxes)
10:30:26 <latermuse> I use sandboxes when appropriate
10:30:42 <bitemyapp> stepcut: ditto re: nicer semantics.
10:30:47 <latermuse> talk to you guys later
10:31:08 * yitz looks up the screen. oh, hard-coded paths inside ghc package descriptions. yeah.
10:31:26 <monochrom> migration preserves and breaks this depending on whether the new location has the same path as the old location
10:31:44 <yitz> heh
10:32:03 <monochrom> my "migration" is a simple tar from /home/trebla to /home/trebla. nothing breaks.
10:32:51 <monochrom> actually I don't even keep much of packages in user. I have them in global instead. my "migration" is a simple tar from /usr/local/ to /usr/local again.
10:33:06 <stepcut> in a total language like Idris, you get the same result whether your evaluation is lazy or eager -- which is not true in Haskell, so might as well go strict
10:33:10 <yitz> monochrom: i regularly need to migrate between linux, windows, and mac os x boxes. that makes it trickier.
10:33:47 * geekosaur wonders about -fllvm
10:34:44 * hackagebot mandrill 0.1.0.1 - Library for interfacing with the Mandrill JSON API  http://hackage.haskell.org/package/mandrill-0.1.0.1 (AlfredoDiNapoli)
10:36:52 <geekosaur> mm, you'd need to convert between object file / library formats still, so no
10:37:40 <monochrom> a lot more software than you think uses absolute paths
10:41:15 <spopejoy> lens q. Given a list of records and a lens, how can I transform the list into a list of the viewed item? data User = User { _name :: String, _age :: Int}; lens "age. For [user1,user2,user3] I want a list [age1,age2,age3].
10:42:11 <shachaf> In this particular case there are multiple answers.
10:42:26 <shachaf> For example, you can write map (view age) [...]
10:43:20 <shachaf> You can also write toListOf (traverse . age) [...]
10:43:52 <shachaf> These are pretty different in general but will give you the same result here.
10:44:30 <coppro> map . view is more clear imo
10:44:39 <coppro> err
10:44:41 <coppro> map view
10:44:47 <spopejoy> toListOf was what I was looking for actually, I had (traverse . age) and couldn't get there
10:44:52 <coppro> you know what I mean
10:45:16 <spopejoy> map view is good but my eventual goal is traverse.traverse.traverse style stuff
10:53:45 <kali-linux> hey
11:03:04 <KiwiHeretic> Lots of people coming and going
11:03:23 <kali-linux> yup
11:03:28 <kali-linux> why??
11:03:36 <kali-linux> kiwi
11:03:39 <kali-linux> are u there??
11:03:51 <KiwiHeretic> Yeah
11:04:07 <kali-linux> whats up??
11:04:17 <KiwiHeretic> Freenode is a nit like that
11:04:39 <KiwiHeretic> A bit like that
11:04:47 * hackagebot memcached-binary 0.1.2 - memcached client using binary protocol.  http://hackage.haskell.org/package/memcached-binary-0.1.2 (HirotomoMoriwaki)
11:04:49 * hackagebot persistent-template 2.0.1.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-2.0.1.1 (MichaelSnoyman)
11:05:01 <KiwiHeretic> Just surfing the rooms
11:05:39 <KiwiHeretic> I didn't think anything was persistent with Haskell
11:05:58 <benmachine> everyone needs persistence
11:06:05 <kali-linux> i need
11:06:23 <kali-linux> about ssh
11:06:50 <KiwiHeretic> Ssh library?
11:07:20 <KiwiHeretic> Hackage
11:09:27 <kali-linux> can u hack ssh account??
11:09:48 * hackagebot yesod-bin 1.2.12.8 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.12.8 (MichaelSnoyman)
11:09:50 * hackagebot mime-mail-ses 0.3.0 - Send mime-mail messages via Amazon SES  http://hackage.haskell.org/package/mime-mail-ses-0.3.0 (MichaelSnoyman)
11:12:10 <KiwiHeretic> Well, if someone guesses the ssh password
11:14:23 <kali-linux> no its possible without guesses password
11:14:45 <vanila> kali-linux,  how?
11:14:59 <KiwiHeretic> If private key is compromised
11:15:34 <joelteon> not if you're not using public key authentication!
11:16:20 <kali-linux> using metaexploit shell
11:17:42 <hiptobecubic> i always though metasploit was a stupid name
11:17:47 <hiptobecubic> you aren't exploiting exploits
11:18:05 <joelteon> also, it isn't spelled ecksploit
11:19:49 * hackagebot irc-conduit 0.1.0.0 - Streaming IRC message library using conduits.  http://hackage.haskell.org/package/irc-conduit-0.1.0.0 (barrucadu)
11:20:06 <phaazon> god…
11:20:16 <phaazon> I’ve just discovered the --sandbox switch of cabal sandbox
11:20:17 <phaazon> :D
11:20:26 <phaazon> I think it’s gonna make my life way easier :D
11:20:30 <benmachine> kali-linux: discussing illegal activity is not allowed on this channel, keep that in mind
11:20:43 <kali-linux> ok
11:20:55 <benmachine> (on freenode in general, indeed)
11:21:19 <nikyr0x91> hi people
11:21:26 <benmachine> hi
11:22:35 <kali-linux> hey
11:23:36 <kali-linux> any muslim out there??
11:25:53 <joelteon> take it to #haskell-blah
11:29:46 <vlads> phaazon: cabal --sandbox is not that old, but yeah, some things become easy. Although sometimes you have to install like 300MB of libs because of broken dependency. Or I just can't properly use it.
11:38:31 <hopnotch> > printf "%04.1f" 0.3
11:38:32 <lambdabot>  No instance for (GHC.Show.Show a0)
11:38:32 <lambdabot>    arising from a use of ‘M90578951761763646669253.show_M90578951761763646669...
11:38:32 <lambdabot>  The type variable ‘a0’ is ambiguous
11:38:32 <lambdabot>  Note: there are several potential instances:
11:38:32 <lambdabot>    instance [safe] GHC.Show.Show
11:38:51 <mauke> > "" ++ printf "%04.1f" 0.3
11:38:53 <lambdabot>  "00.3"
11:39:23 <hopnotch> ok, weird. i was gonna ask why it doesn't print the result it printed
11:39:33 <hopnotch> thanks
11:39:37 <monochrom> it could be String or IO ()
11:51:20 <Darwin226> Hey guys. I'm working on my own language and for the purpose I wrote my own parsing library. I've seen haskell parsers before and mine is inspired my them. A parser is [a] -> Maybe ([b],[a]). A single parser is expected to take a list of xs and return a list of results (usually just the xs that it consumed) and a list of xs that it didn't parse.  (continued..)
11:53:24 <Darwin226> The result is wrapped in a Maybe. It should return Nothing if it doesn't parse anything. Then I wrote come combiners that take parsers and compose them into complex parsers. The |>| operator takes two parsers and if the first succeedes to parse, it gives the unparsed part to the second one and if that also succeedes, the returned value contains the concatenation of the strings they parsed.
11:53:52 <Darwin226> Hope I'm expressing myself properly
11:54:20 <HeladoDeBrownie> Darwin226, what in particular did you want help with?
11:54:29 <Darwin226> Yeah, yeah, I'm getting to it :D
11:54:54 <Darwin226> Well, I've wrote other combiners. The OR combiner, oneOrMany combiner,... stuff like that. It works great
11:55:18 <Darwin226> But what I wanted to do now is somehow elegantly implement skipping whitespaces
11:56:22 <Darwin226> What I decided was to make a skipWhitespaces parser that instead of splitting the given list into parsed and unparsed parts, it just returns Just ([], filter notWhitespace list)
11:56:38 <mauke> dropWhile
11:56:54 <mauke> unless your language is weird
11:57:08 <Darwin226> Now this does work bt I have a feeling that I'm abusing the API a bit. How are these things usually handled?
11:58:19 <Darwin226> Basically, being able to write "parse a number, then a letter, then a number" is great. But what's the best way to do "parse nunber, then letter, then a number BUT ignore whitespaces"
11:59:05 <jmcarthur> the usual way is to consume whitespace without returning useful data (because there is none)
11:59:19 <jmcarthur> the idea as you described it sounds fine, although your implementation looks wrong
11:59:40 <Darwin226> jmcarthur: Wrong how?
11:59:41 <jmcarthur> filter will remove all whitespace from the input, not just the next sequence of whitespace characters
12:00:02 <jmcarthur> you probably want dropWhile, as mauke suggested
12:00:41 <Jafet> As a rule, each token's parser should skip all whitespace after it. This is what parsec's tokenizer does.
12:01:12 <Jafet> (Or equivalently, all whitespace before it)
12:01:12 <Darwin226> jmcarthur: Yes. That is a problem but it seems like I have two options and both are bad. The first is to just ignore the whitespaces in the front, but then I have to insert the ignoreWhitespaces parser everywhere. The second as you said removes ALL of them...
12:01:36 <jmcarthur> Darwin226: why is it bad to say explicitly where it's okay to skip whitespace?
12:01:51 <jmcarthur> Darwin226: unless there is some pattern you are aware of that i am not
12:02:29 <Darwin226> jmcarthur: Well, I'd like this to be as flexible as possible. Perhaps I want to skip whitespaces by default, only not skip them in some cases.
12:03:08 <Darwin226> jmcarthur: It's be great if I could compose a bunch of parsers and then somehow attach a whitespace-ignorer to that composed parser
12:03:13 <jmcarthur> Darwin226: how do you know when one token ends and another begins?
12:03:58 <SwashBuckla> :t flip
12:03:59 <lambdabot> (a -> b -> c) -> b -> a -> c
12:04:20 <Darwin226> jmcarthur: Well, this is after I've tokenized the file. My parsers can consume any list, not just strings
12:04:42 <Darwin226> jmcarthur: so I'm using the same combinators for parsing the syntax after tokenization
12:04:47 <jmcarthur> Darwin226: if it's already tokenized, then you possibly should have already accounted for whitespace
12:04:50 <exio4> if you've tokenized the input, why do you have spaces?
12:05:22 <Darwin226> I'd be fine with that if there are surely no edgecases where I still need them
12:05:52 <jmcarthur> Darwin226: why do you still need them after tokenizing?
12:05:59 <Darwin226> It's still important in haskell because of alignment, isn't it?
12:06:35 <jmcarthur> i admit i do not know exactly how parsing of layout-aware syntax works
12:07:04 <Darwin226> jmcarthur: you and me both, but it seems like I can't just throw them away
12:07:18 <jmcarthur> Darwin226: i wouldn't be sure until i know how it should work
12:09:25 <sinelaw> I'm trying to implement Out (from Text.Pretty.Generic) for Maps and get a strange error:
12:09:27 <sinelaw> instance (Out k, Out v) => Out (Map.Map k v) where
12:09:27 <sinelaw>     doc map = doc $ Map.assocs map
12:09:32 <Jafet> Existing parsers don't have magical "whitespace-ignorers". haskell-src's lexer parses the block layout and produces virtual tokens for the desugared form.
12:09:45 <ThatOtherPerson_> http://i.imgur.com/IWANnWe.png what were you guys up to this time
12:10:04 <sinelaw> error: http://lpaste.net/110671
12:10:11 <Jafet> If you have some idea to design these parsers better, you can try it. (There was an icfp paper on this recently?)
12:10:12 <sinelaw> any clues?
12:10:33 <hpc> ThatOtherPerson_: it just doesn't recognize the hash
12:10:45 * hackagebot diagrams-canvas 0.2.0.2 - HTML5 canvas backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-canvas-0.2.0.2 (jeffreyrosenbluth)
12:10:47 * hackagebot LargeCardinalHierarchy 0.0.0 - A transfinite cardinal arithmetic library including all known large cardinals  http://hackage.haskell.org/package/LargeCardinalHierarchy-0.0.0 (Stephen_E_A_Britton)
12:10:52 <hpc> and thinks it is a significant file because of the wonky filename
12:10:56 <Darwin226> Jafet: well, I'm thinking about it but I doubt I'm anywhere near smart enough to come up with something original
12:11:31 <ThatOtherPerson_> hpc: not the only channel I'm in, and I'm in channels all day daily ;D
12:11:59 <hpc> dunno then
12:12:13 <hpc> maybe the file starts with the right magic bytes or something
12:12:45 <ThatOtherPerson_> hpc: At some point before in another channel, someone was talking about the ILOVEYOU virus, I think, and pasted part of the code into the chat
12:12:48 <Jafet> Perhaps someone pasted the test virus string. Actually, that sounds like a fun thing to do in an irc channel...
12:12:51 <ThatOtherPerson_> And it flagged that >.>
12:12:54 <hpc> antivirus isn't the most convenient thing to reason about
12:12:59 <ThatOtherPerson_> nope
12:13:11 <sinelaw> anybody understand this error?  http://lpaste.net/110671
12:13:14 <mauke> X5O!P%@AP[4\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*
12:13:22 <Jafet> Thanks
12:14:46 <sinelaw> it goes away if I implement also docPrec _ = doc
12:14:47 <Fuuzetsu> sinelaw: it's trying to automagically derive the Pretty
12:14:59 <Fuuzetsu> you should either derive Generic or manually implement
12:15:17 <sinelaw> I did manually implement, but only the "minim required" which is just doc
12:15:22 <sinelaw> if I implement also docPrec it works
12:20:46 * hackagebot LargeCardinalHierarchy 0.0.1 - A transfinite cardinal arithmetic library including all known large cardinals  http://hackage.haskell.org/package/LargeCardinalHierarchy-0.0.1 (Stephen_E_A_Britton)
12:26:39 <Jafet> No Ord Card?
12:27:58 <Emre_> do you use vim or emacs?
12:28:17 <Jafet> Yes.
12:31:47 <ion> yeah
12:33:17 <Emre_>  /ignore -channels #haskell * JOINS PARTS QUITS NICKS
12:33:44 <shapr> Emre_: good idea
12:33:45 <rom1504> on the whole freenode even
12:34:00 <exio4> the best command is actually /ignore *
12:34:30 <rom1504> well then you might want to know about /quit
12:34:40 <Emre_> meant to paste that without the space...
12:35:38 <vlads> Emre_: How is that command supposed to work?
12:36:50 <mauke> /set activity_hide_level joins parts quits nicks
12:38:52 <ion> /set irc.look.smart_filter on, /filter add irc_smart * irc_smart_filter *, /set irc.look.smart_filter_delay 60, /set irc.look.smart_filter_join_unmask 60
12:39:28 <hpc> /kick hpc
12:40:49 <mauke> /notice #haskell hey sup
12:41:32 <Fuuzetsu> pretty sure every channel with >10 users has notices disabled
12:43:12 <mauke> you can disable notices?
12:43:17 <mauke> that sounds stupid
12:43:35 * hpc pretends to know what /notice is
12:43:39 <Fuuzetsu> maybe I'm thinking of the wrong thing
12:45:16 <mauke> hpc: in theory it's a lighter version of /msg
12:45:18 <ion> hpc: NOTICE is the IRC command for bot messages. Bots are forbidden from triggering stuff from incoming NOTICE and bots are required to send their messages using NOTICE. This prevents bot loops. As a bonus, IRC clients can render NOTICEs in a less prominent manner than PRIVMSGs.
12:45:27 <mauke> in practice all irc clients implement it wrong and make it super annoying
12:45:45 <hpc> haha
12:46:30 <mauke> HEY HERE'S A LESS IMPORTANT MESSAGE! HOW ABOUT A LOUD BEEP!
12:47:02 <joelteon> yeah, it is annoying
12:47:43 <parc> is there a way to get the sourcePos/line number/other information within parsec? Like a combinator Parser SourcePos? i want to make a parser that always succeeds on any input, like Parser (Either ErrorMessage a), so that i can handle the error message within the parser monad
12:48:14 <Fuuzetsu> I thought parsec had such a thing already
12:48:42 <parc> i couldn't find anything in hayoo, but maybe it does
12:49:14 <twanvl__> Text.Parsec.Prim.getPosition
12:49:16 <mauke> http://hackage.haskell.org/package/parsec-3.1.5/docs/Text-Parsec-Prim.html#v:getPosition
12:49:24 <mauke> found with hayoo "getPos"
12:49:43 <parc> awesome, thanks :)
12:51:36 <wombawomba> So I'm trying to write a small DSL in Haskell, and have run into a problem: I want to be able to specify two sets of functions, e.g. X = {a :: A -> B, b :: A -> C} and Y = {c :: C -> D, d :: B -> D}, from which I then want to generate all combinations x \in X, y \in Y such that x . y :: A -> D. Is this possible?
12:52:43 <wombawomba> (in this case, the desired output would be [(a, d), (b, c)])
12:53:17 <wombawomba> (or even [a . d, b . c])
12:53:18 <vanila> wombawomba, this is hard because you need to look at the types to know how to do the computation - but types don't exist at runtime
12:53:27 <wombawomba> right
12:53:42 <wombawomba> preferably I'd like to do it at compile-time though
12:54:20 <vanila> are the types A,B,C,D a fixed set?
12:54:42 <wombawomba> hmm
12:54:46 <dmwit> Does read . show have the type A -> D?
12:54:47 <wombawomba> technically yes, I guess
12:54:51 <dmwit> If so, what was the middle type?
12:54:57 <dmwit> sorry
12:55:01 <dmwit> show . read
12:55:05 <parc> wombawomba: i've been trying to do something similar, where the functions also allow ad-hoc polymorphism, and requests for a set from any arbitrary type, and i haven't found a good way without template haskell /and/ runtime compilation
12:55:09 <dmwit> The point is the same. Polymorphism may make your problem unsolvable.
12:55:11 <vanila> wombawomba, then you could define a data type to represent these
12:55:49 <dmwit> If everything is monomorphic, I suppose Typeable would be enough to do it at runtime.
12:56:12 <dmwit> Perhaps something similar would be doable at compile time, but I don't know enough about Template Haskell to say.
12:57:33 <wombawomba> hm, maybe I'd have to look into template haskell
12:57:42 <vanila> wombawomba, like for example data T a where ATy :: T A ; BTy :: T B ; ..., then  data To a where To :: T b -> a -> b  and  data From b where From :: T a -> a -> b.  Now the DSL could be like   [To BTy a, To CTy b], [From CTy c, From BTy d]
12:58:00 <vanila> and it's possible to build the composiitions out of these
12:58:21 <dmwit> Is it absolutely necessary to operate on Haskell functions?
12:58:26 <parc> if you import Language.Haskell.TH and {-# LANGUAGE TemplateHaskell #-} you can play around with template haskell using runQ [| someVal :: someType |] to see how it represents types
12:58:45 <dmwit> If you can operate on your DSL terms instead it's probably easier. Since presumably you can just inspect the DSL type using normal old data.
13:00:22 <wombawomba> dmwit: well, I was hoping I could make this lightweight, so using haskell functions is really convenient
13:00:36 <vanila> is that clear?
13:01:30 * dmwit nods agreeably
13:01:46 <wombawomba> vanila: how would I build a result list from that?
13:02:30 <vanila> you can just go over the lists looking at the type tags to see if you can compose the functions
13:04:24 <dmwit> Typeable is the non-ad-hoc way to represent both the to and from type.
13:04:30 <dmwit> well
13:04:35 <dmwit> "less" ad-hoc, anyway
13:05:28 <trap_exit> is it possible to get ghci as a library? (imagine I'm writing a web-repl for haskell -- client sends cmd to server, server execs it inside a ghci and sends it back)
13:05:29 <vanila> Typeable is open universe but requires unsafeCoerce internally, the GADT lets you implement this on a closed universe without any unsafe functions
13:05:46 <wombawomba> vanila: well that does sound nice.. I'm not really able to wrap my head around how it would work in practice, but I'll look into it
13:05:52 <dmwit> trap_exit: ghc-api, see also hint
13:05:53 <geekosaur> trap_exit: "hint" on hackage
13:06:24 <trap_exit> dmwit geekosaur: I'm glad neither of you like bad puns
13:06:25 <dmwit> vanila: Typeable doesn't use unsafeCoerce.
13:06:40 <dmwit> vanila: Maybe you're thinking of Dynamic.
13:06:44 <mauke> (hint, hint)
13:06:57 * geekosaur likes bad puns, in the appropriate context
13:07:32 <mauke> :t cast
13:07:34 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
13:07:57 <parc> if you have an arbitrary collections of functions you want to select from to compose into your desired datatype you'll probably want Dynamic to put all the functions into a single set anyway
13:08:05 <parc> if things are monomorphic that is
13:08:32 <dmwit> Possibly. But Dynamic isn't unsafe.
13:08:59 <mauke> but Typeable is
13:09:08 <dmwit> Yes, that's the correct argument. Forget this "it doesn't use unsafeCoerce" nonsense. The right argument is that it's a safe use of unsafeCoerce anyway.
13:09:18 <mauke> unless you're oleg
13:09:49 <wombawomba> what if things aren't monomorphic
13:09:51 <wombawomba> ?
13:10:16 <mauke> newtype T a = T a; instance Typeable (T a) where typeOf _ = typeOf (undefined :: Int)
13:10:20 <dmwit> As mentioned above: the problem may not have a finite number of solutions. =)
13:10:37 <parc> Typeable/Dynamic won't work for polymorphic functions. at least, i haven't gotten them to work
13:10:38 <dmwit> Then things get much more complicated.
13:10:41 <shachaf> You can't write Typeable instances by hand anymore, can you?
13:11:02 <k00mi> yes, you can only derive them
13:11:14 <parc> i did see a complex way to fmap a polymorphic function over a Dynamic value on stack overflow, but i don't think it's terribly relevant to the problem
13:11:22 <wombawomba> oh yeah
13:12:03 <wombawomba> I reckon limiting myself to monomorphic functions would probably be fine, anyway
13:12:14 <shachaf> So now you'll need to do https://ghc.haskell.org/trac/ghc/ticket/7634 to make it unsafe.
13:12:49 <vanila> wombawomba, http://lpaste.net/110674
13:12:55 <parc> i thought idris might be relevent for this type of problem. you can use a dependent pair to represent a dynamic value, including rank N polymorphism as far as i can tell, but apparently you need to use typecase to be able to do anything with it, and i couldn't find any helpful documentation
13:13:10 <vanila> you don't need dependent types, just GADT
13:13:32 <wombawomba> vanila: thanks!
13:14:04 <vanila> You can create typeclasses to write 'to' for To BTy, To StrTy etc. it places the tag for you
13:15:18 <wombawomba> yeah, that's a really neat solution, I think I'll go with that for now
13:15:57 <vanila> dmwit, it uses unsafeCoerce http://hackage.haskell.org/package/base-4.7.0.1/docs/src/Data-Typeable.html
13:17:25 <dmwit> vanila: You are now attacking a strawman argument. =)
13:17:36 <vanila> That was in response to <dmwit> vanila: Typeable doesn't use unsafeCoerce.
13:17:47 <dmwit> I know.
13:18:34 <dmwit> Nevertheless, my message from 3 minutes later refines my claim.
13:19:50 <hseg> Reading through a recent commit to yi, https://github.com/yi-editor/yi/blob/79b0ebc7a2c44ef6afbaacbbf50317b1b3275fb3/yi/src/library/Yi/Eval.hs#L164 I found the line Evaluator{..} where ... How is this valid Haskell?
13:20:01 <Fuuzetsu> hseg: RecordWildcards
13:20:12 <Fuuzetsu> I just removed that use anyway
13:20:53 <hseg> Yeah, but it shows up in the deleted lines in the diff.
13:21:07 <benzrf> wait
13:21:10 <benzrf> what would that do?
13:21:12 <benzrf> fill in undefs?
13:21:25 <hseg> benzrf: No, it would work like a record update
13:21:37 <hseg> except it would use the in-scope bindings for values
13:21:45 <benzrf> ok yeah i was about to ask
13:21:50 <benzrf> that seems a little leaky
13:21:56 <Fuuzetsu> which is why I changed it
13:21:58 <benzrf> does it search all the way up to the module leve
13:21:58 <benzrf> l
13:22:01 <Fuuzetsu> it's handy as hell but not necessary there
13:22:06 <mauke> > let runIdentity = 42 in Identity{..}
13:22:08 <lambdabot>  Illegal `..' in record construction
13:22:08 <lambdabot>  Use RecordWildCards to permit this
13:22:28 <hseg> benzrf: What do you mean "up to  the module level"?
13:22:39 <hseg> If the field isn't exposed?
13:23:05 <benzrf> like
13:23:07 <mauke> would bare Identity{..} :: Identity (Identity a -> a)?
13:23:07 <benzrf> can i do
13:23:14 <benzrf> runIdentity = 3
13:23:18 <benzrf> foo x = something
13:23:26 <Fuuzetsu> try and see
13:23:28 <benzrf>   where bar = Identity{..
13:23:28 <benzrf> }
13:23:29 <Fuuzetsu> I suspect yes
13:23:31 <benzrf> creppy
13:23:46 <mauke> spoopy
13:23:48 <Fuuzetsu> as is overriding a field name
13:24:02 <hseg> ugh. that's not nice.
13:24:23 <Fuuzetsu> yeah it's not nice but it's great for large record updates &c
13:24:42 <shachaf> mauke: No, it's :: Identity a, with a warning.
13:24:49 <hseg> and simplifies semantics - field accessors are just functions
13:25:00 <shachaf> But let runIdentity = Data.Functor.Identity.runIdentity in Identity{..} has the type you said.
13:25:26 <hseg> Fuuzetsu: I know you just edited that, I'm reading through the commit.
13:26:12 <benzrf> mauke: 2spoopy
13:27:41 <hseg> Fuuzetsu: Git's lack of knowledge of how insignificant whitespace and ordering changes are makes the commit a bit messier to read than strictly necessary.
13:27:50 <hseg> But that's a git problem
13:27:56 <Fuuzetsu> hseg: no, GitHub's lack of knowledge does
13:28:03 <Fuuzetsu> you can tell git to ignore whitespace changes
13:28:13 <hseg> I stand corrected.
13:28:36 <Fuuzetsu> GitHub interface is only fine for basic stuff, anything else and you have to browse locally
13:28:46 <Fuuzetsu> they seem to be very anti actual features
13:29:15 <mauke> benzrf: https://www.youtube.com/watch?v=-DRXudT1bos
13:29:26 <hseg> Yup. Just diffing between two commitishes is already pushing it
13:30:05 <hseg> I just had to do that to find out what ekmett meant when he said Isos would be derived automatically when appropriate.
13:30:54 * hackagebot tasty 0.10 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.10 (RomanCheplyaka)
13:32:53 <Fuuzetsu> hseg: you should totally come and hack for Yi if you're interested
13:33:24 <benzrf> mauke: oh my god
13:33:38 <hseg> Fuuzetsu: I think I'll do just that. First need to get GHC set up, though.
13:33:51 <Fuuzetsu> GHC is a good first step ;P
13:34:53 <hseg> Fuuzetsu: :). Why did you change a call to void to a pattern match on _ https://github.com/yi-editor/yi/commit/acb2e80acc34178a1178135ed652dc761d14cd3d#diff-99d141f65ea2d0184374deb279d4ff5eL175
13:35:12 <hseg> I'd think void would be clearer, no?
13:35:29 <Fuuzetsu> mauke: pretty good (but should go in -blah)
13:35:47 <Fuuzetsu> hseg: because I was going te merge it into one line but it ended up looking ugly
13:36:30 <Fuuzetsu> also I prefer _ <- anyway if it's not inline
13:36:49 <hseg> Makes sense.
13:37:51 <Fuuzetsu> the existing code tends to be pretty ugly at times (IMHO) so I change it at will rather than trying to preserve it
13:37:55 <Fuuzetsu> some of it is a decade old…
13:39:45 <Fuuzetsu> I think just that Eval.hs mixed 2, 3, 4 and 5 spaces for alignment
13:41:05 <hseg> Ugh. Couldn't we have modelines on the code, and reindent everything? would make things much easier. OTOH, some things are aligned vertically, so that probably would look a bit ugly.
13:41:28 <hseg> Still, it would kill indentation problems. And prevent future such problems.
13:42:21 <Fuuzetsu> yeah but there are more problems than that that need fixing
13:42:49 <Fuuzetsu> adding some comments, reflowing code/comments, fixing up the data -> lens regex hackjob
13:42:58 <Fuuzetsu> making stuff safer &c
13:43:07 <hseg> Yeah.
13:43:15 <hseg> data -> lens regex hackjob?
13:43:31 <Fuuzetsu> we were using data-acessor or whatever that package is called
13:43:34 <Fuuzetsu> pre-lens era
13:43:56 <Fuuzetsu> the migration to lens involved someone sitting down and doing a lot of replacements
13:44:11 <Fuuzetsu> didn't exactly end up with most idiomatic code
13:45:16 <hseg> Ouch.
13:45:40 <hseg> Question: I assume most of the docs you removed in that commit are out-of-date?
13:46:01 <Fuuzetsu> well, cleanups give me a pretty nice chance to look at the code
13:46:10 <Fuuzetsu> I learn quite a bit about how things work
13:46:12 <hseg> Like e.g. Bernardy's slides and the reference to A Selective Undo Mechanism for Graphical User Interfaces Based On Command Objects
13:46:13 <hseg> ?
13:46:53 <Fuuzetsu> hm, I think that one is relevant, what directory was it in?
13:46:56 <Sornaensis> what would be the best way to store a 2D array where you can quickly get a list of all neighbors of any cell
13:47:08 <Fuuzetsu> hseg: most of the stuff I removed is linked at the bottom of README
13:47:11 <hseg> Yeah, and vice versa. I probably will find things to cleanup when I read through the code.
13:47:20 <Fuuzetsu> the doc/ was mostly sources for the papers there
13:48:13 <Fuuzetsu> well, normally how I do a cleanup is to look at some issue or whatever and notice the modules I look through aren't nice ;P
13:49:21 <hseg> doc/haskell05/yi.bib and doc/IncrementalParsing.odp respectively
13:49:24 <latk> is there something like startsWith for Data.Text ?
13:50:02 <mauke> latk: if so it'll be called isPrefixOf
13:50:10 <latk> Ah, cool
13:50:11 <hseg> latk: isPrefixOf
13:50:16 <latk> Thanks :)
13:50:24 <Fuuzetsu> Incremental parsing is linked to at the bottom of README
13:51:43 <hseg> Right, but the slides are not. Then again, a thesis is better than slides are.
13:51:56 <hseg> usually.
13:51:56 <Fuuzetsu> ;P
13:52:15 <Fuuzetsu> if it's about the same topic then no point having the same thing twice, the paper is quite easy
13:52:44 <hseg> Is there any other language that has theses as part of its documentation (apart from idris and agda)?
13:53:10 <Fuuzetsu> a lot
13:53:21 <Fuuzetsu> think anything not maintstream
13:53:53 <Jafet> We have languages where someone's thesis is the documentation
13:54:09 <Fuuzetsu> sadly ;P
13:54:28 <hpc> imo that more means "there's no documentation"
13:54:38 <hpc> as applied to the output of a research paper
13:55:16 <begriffs> How do I "coalesce" two lists? So if x :: [a], y :: [a] then x `coalesce` y returns y if x is empty otherwise x?
13:55:34 <Jafet> Pragmatically, you need documentation to work with it, so the thesis is going to be it.
13:55:38 <hpc> > "" <|> "yes"
13:55:39 <lambdabot>  "yes"
13:55:44 <hpc> > "no" <|> "yes"
13:55:45 <lambdabot>  "noyes"
13:55:50 <hpc> doh
13:55:56 <geekosaur> not quite...
13:55:58 * hackagebot github 0.11.1 - Access to the Github API, v3.  http://hackage.haskell.org/package/github-0.11.1 (cesar_nataren)
13:56:00 <hseg> > maybe (listToMaybe x) y
13:56:01 <lambdabot>  Couldn't match expected type ‘[a1]’
13:56:02 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’Couldn't match e...
13:56:02 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’
13:56:02 <Jafet> I think that's the wrong alternative
13:56:04 <hpc> > "no" `mplus` "yes"
13:56:06 <lambdabot>  "noyes"
13:56:13 <hseg> > maybe (listToMaybe []) "foo")
13:56:15 <lambdabot>  <hint>:1:29: parse error on input ‘)’
13:56:20 <hpc> yeah, there's definitely something already existing for it
13:56:23 <hseg>  > maybe (listToMaybe []) "foo"
13:56:29 <hseg> > maybe (listToMaybe []) "foo"
13:56:31 <lambdabot>  Couldn't match expected type ‘a -> Data.Maybe.Maybe a1’
13:56:31 <lambdabot>              with actual type ‘[GHC.Types.Char]’
13:56:38 * hseg sucks at programming
13:56:47 <hseg> at least in haskell
13:57:08 <hseg> > maybe (listToMaybe "") "foo"
13:57:09 <lambdabot>  Couldn't match expected type ‘a -> Data.Maybe.Maybe GHC.Types.Char’
13:57:09 <lambdabot>              with actual type ‘[GHC.Types.Char]’
13:57:16 <begriffs> I thought maybe there's a monadic concept that might apply where [] is like mzero but I couldn't figure it out.
13:57:20 <hseg> What? How doesn't that unify?
13:57:41 <hpc> it's a different instance
13:57:47 <hpc> like Sum/Product
13:57:51 <Jafet> > listToMaybe "abc"
13:57:52 <lambdabot>  Just 'a'
13:57:59 <begriffs> In a way I'm looking for the opposite of (>>)
13:58:13 <Fuuzetsu> <<
13:58:18 <hpc> haha
13:58:20 <begriffs> :)
13:58:23 <mauke> <*
13:58:28 <hpc> (:
13:58:30 <silver> @hoogle (<<)
13:58:32 <lambdabot> Text.Html (<<) :: HTML a => (Html -> b) -> a -> b
13:58:32 <lambdabot> Text.XHtml.Strict (<<) :: HTML a => (Html -> b) -> a -> b
13:58:32 <lambdabot> Text.XHtml.Frameset (<<) :: HTML a => (Html -> b) -> a -> b
13:58:42 <Fuuzetsu> :t flip (>>)
13:58:43 <lambdabot> Monad m => m b -> m a -> m b
13:58:49 <begriffs> > [] >> [1,2]
13:58:50 <lambdabot>  []
13:59:07 <mauke> > [1,2] <* []
13:59:08 <lambdabot>  []
13:59:23 <Jafet> > [1,2] <* [3,4]
13:59:24 <lambdabot>  [1,1,2,2]
14:00:09 <hseg> > maybe "foo" id (listToMaybe [])
14:00:10 <lambdabot>  "foo"
14:00:16 <hseg> > maybe "foo" id (listToMaybe "bar")
14:00:17 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘[GHC.Types.Char]’
14:00:18 <lambdabot>  Expected type: [[GHC.Types.Char]]
14:00:18 <lambdabot>    Actual type: [GHC.Types.Char]
14:00:20 <ion> fromMaybe
14:00:59 * hackagebot hssqlppp 0.4.2 - SQL parser and type checker  http://hackage.haskell.org/package/hssqlppp-0.4.2 (JakeWheat)
14:01:22 <Jafet> Maybe, Just Maybe, you should do this somewhere else.
14:02:39 <hpc> Jafet: kind error :D
14:03:19 <ion> Now now, it wasn’t that obtrusive so far.
14:03:49 <silver> maybe he was making a point
14:04:53 <Fuuzetsu> we'll never know if the answer to all these maybes is Nothing!
14:05:21 <Jafet> :k Just Maybe
14:05:22 <lambdabot> Maybe (* -> *)
14:05:25 <hpc> data Maybe a = Perhaps | IHaven'tDecided
14:05:38 <Fuuzetsu> … | FileNotFound
14:05:46 <hpc> heehee
14:05:57 <ion> Make FileNotFound an implicit member of all types in addition to bottom.
14:06:10 <Fuuzetsu> make bottom FileNotFound
14:06:21 <Jafet> instance Exception FileNotFound
14:12:47 <benmachine> :k Maybe Nothing
14:12:48 <lambdabot>     The first argument of ‘Maybe’ should have kind ‘*’,
14:12:48 <lambdabot>       but ‘Nothing’ has kind ‘Maybe k0’
14:12:48 <lambdabot>     In a type in a GHCi command: Maybe Nothing
14:12:55 <benmachine> oh, fair point
14:13:02 <szabba> I've got some understanding of Yampa, but can't find any clear materials on non-arrowized FRP.
14:14:03 <szabba> I know that there's something called a Behaviour in classic FRP, but I couldn't find any good explanations of it.
14:14:45 <silver> it's simple
14:14:48 <silver> function of time
14:15:39 <szabba> silver: Signals in Yampa are conceptually functions of time too.
14:16:22 <gregnwosu> hello, im trying to cabal install and each time its failing because i dont have the dependencies, is there a way of getting ghc-mods full outstanding dependencies
14:17:16 <Fuuzetsu> you should lpaste your error
14:17:21 <szabba> How do they relate?
14:17:21 <merijn> benmachine: That'd work if you had DataKinds, but lambdabot doesn't :)
14:17:30 <gregnwosu> ok will do
14:17:49 <merijn> szabba: Conal Elliot's Push-Pull FRP is a pretty good explanation of classic FRP
14:18:03 <merijn> That, and FRAN
14:18:13 <benmachine> merijn: wrong on both counts :P
14:18:14 <merijn> http://conal.net/papers/push-pull-frp/
14:18:22 <merijn> benmachine: oh? Why?
14:18:32 <benmachine> :k Just Int
14:18:33 <lambdabot> Maybe *
14:18:51 <merijn> oh, lambdabot has datakinds now? :D
14:18:53 <benmachine> yes
14:19:01 <benmachine> the problem with what I did is that Maybe still only accepts arguments of kind *
14:19:06 <merijn> Yeah
14:19:13 <merijn> I just realised I was thinking crooked :p
14:19:32 <merijn> szabba: And http://conal.net/fran/
14:20:00 <vramana> What's difference between writing map sum $ transpose [[0,3,5,9],[10,0,0,9],[8,5,1,-1]] and map (sum . transpose) [[0,3,5,9],[10,0,0,9],[8,5,1,-1]] ??
14:20:01 <merijn> Conal's also pretty active on SO with answering FRP questions, he's occasionally in here, but that's rarer
14:20:34 <merijn> vramana: the former applies transpose to the outer list, the latter to the inner list
14:20:38 <Fuuzetsu> vramana: transpose whole list vs transpose each list separately
14:20:43 <mauke> > map sum $ transpose [[0,3,5,9],[10,0,0,9],[8,5,1,-1]] :: [Expr]
14:20:45 <lambdabot>  [0 + 0 + 10 + 8,0 + 3 + 0 + 5,0 + 5 + 0 + 1,0 + 9 + 9 + negate 1]
14:20:52 <merijn> vramana: Perhaps you meant "map sum . transpose"?
14:21:06 <vramana> merijin: got it. Me so noob
14:21:13 <mauke> > map (sum . transpose) [[0,3,5,9],[10,0,0,9],[8,5,1,-1]] :: [Expr]
14:21:14 <lambdabot>  Couldn't match type ‘[a0]’ with ‘Debug.SimpleReflect.Expr.Expr’
14:21:15 <lambdabot>  Expected type: [[a0]] -> [Debug.SimpleReflect.Expr.Expr]
14:21:15 <lambdabot>    Actual type: [[a0]] -> [[a0]]
14:23:32 <merijn> @define type family Restrict (a :: k) (as :: [k]) :: Constraint where { Restrict a (a ': as) = ("Error!" ~ "Tried to apply a restricted type!"); Restrict x (a ': as) = Restrict x as; Restrict x '[] = () }
14:23:33 <lambdabot>  Parse failed: Parse error: where
14:23:36 <merijn> awww
14:23:48 <merijn> which version of ghc does lambdabot use?
14:24:05 <merijn> :k Read Int
14:24:06 <lambdabot> Constraint
14:24:12 <hpc> new enough
14:24:28 <merijn> @define import GHC.Exts (Constraint)
14:24:30 <lambdabot>  .L.hs:118:1:
14:24:30 <lambdabot>      GHC.Exts: Can't be safely imported! The module itself isn't safe.
14:24:34 <merijn> :(
14:25:11 <merijn> I have no clue which of the necessary extensions is missing for that type family >.<
14:25:30 <merijn> Is there a way to check which extensions are on?
14:25:56 <hseg> Finally figured it out. Ugly version:
14:25:57 <hseg> > curry (uncurry (<>) . bimap (First . (\x -> const x <$> listToMaybe x)) (First . Just)) [3] [1]
14:25:58 <lambdabot>  First {getFirst = Just [3]}
14:26:03 <hseg> > curry (uncurry (<>) . bimap (First . (\x -> const x <$> listToMaybe x)) (First . Just)) [] [1]
14:26:04 <lambdabot>  First {getFirst = Just [1]}
14:26:16 <hseg> Nice version:
14:26:17 <hseg> > (\x y -> First (const x <$> listToMaybe x) <> First (Just y)) [] [1]
14:26:18 <lambdabot>  First {getFirst = Just [1]}
14:26:22 <hseg> > (\x y -> First (const x <$> listToMaybe x) <> First (Just y)) [3] [1]
14:26:23 <lpaste> gregnwosu pasted “ghc errors” at http://lpaste.net/110677
14:26:23 <lambdabot>  First {getFirst = Just [3]}
14:26:56 <hseg> Shouldn't there be some function that computes const x <$> listToMaybe x?
14:27:49 <gregnwosu> listToMaybe?
14:27:55 <pavonia> :t \x -> const x <$> listToMaybe x
14:27:56 <lambdabot> [a] -> Maybe [a]
14:27:59 <hseg> > listToMaybe []
14:28:01 <lambdabot>  Nothing
14:28:05 <hseg> > listToMaybe [1..]
14:28:07 <lambdabot>  Just 1
14:28:44 <merijn> :t \xs -> if null xs then Nothing else Just xs
14:28:45 <lambdabot> [a] -> Maybe [a]
14:28:51 <merijn> Why so difficult?
14:28:56 <gregnwosu> hi can anyone tell me how to make cabal install all the dependencies , when trying to install ghc-mod it keeps installing up to a point which it cant find a library and then i have to begin again
14:29:16 <gregnwosu> ” at http://lpaste.net/110677
14:29:24 <hseg> It feels unelegant. I want something concise, something with style. I want.. A prism!
14:30:03 <geekosaur> something looks very wrong in that paste
14:31:24 <gregnwosu> geekosaur : what looks wrong?
14:31:27 <gregnwosu> its an arm port
14:31:31 <geekosaur> however the important part of the paste seems to not have been pasted, namely the actual error in the "either" package
14:31:51 <geekosaur> all the weird errors after you get the prompt back
14:32:03 <geekosaur> that is, everything from line 11 on
14:32:19 <gregnwosu> geekosaur: ah i think thats just me pasting onto the command line by mistake the log that was on the clipboard
14:32:20 <geekosaur> did you paste the error messages into your shell?
14:32:27 <gregnwosu> ill clean it up
14:35:20 <joelteon> is hackage slow for anyone else, or is it on my end?
14:35:32 <geekosaur> slow here as well
14:35:40 <Fuuzetsu> again?
14:35:53 <Fuuzetsu> is thoughtpolice farming BitCoins on the haskell.org box?
14:36:07 <joelteon> does it have a capital C now?
14:37:21 <Fuuzetsu> don't know
14:37:29 <joelteon> nice
14:37:30 <Fuuzetsu> apparently not
14:37:35 <thoughtpolice> Fuuzetsu: it seems to be OK for me, but right now it's catching up on some builds it missed from the past 2 days
14:37:44 <Fuuzetsu> ah ok
14:37:53 <merijn> gregnwosu: Run cabal with -v3
14:37:54 <thoughtpolice> i had to stop the builder to decrease some of the load. in the mean time we migrated a server off that same host we were using
14:38:02 <Fuuzetsu> some transparent mirrors would be great
14:38:04 <thoughtpolice> so i re-enabled it about 2 hours ago, so the builder may need to play catch up for a little while
14:38:21 <thoughtpolice> Fuuzetsu: yes, when we move to hackage to Rackspace (that's next), a mirror is planned hopefully.
14:38:30 <Fuuzetsu> ok awesome
14:38:34 <joelteon> more like hackspace
14:38:36 <joelteon> or rackage
14:38:45 <Fuuzetsu> sick
14:38:53 <Fuuzetsu> combine the two and you get ‘hackage’!
14:38:55 <Fuuzetsu> COINCIDENCE?
14:41:09 <hseg> :t "test"
14:41:09 <lambdabot> [Char]
14:41:29 <hseg> Huh. Lambdabot seems to be ignoring my private messages.
14:41:39 <hseg> > combine "hackspace" "rackage"
14:41:41 <lambdabot>  Not in scope: ‘combine’
14:41:46 <hseg> :(
14:43:20 <mauke> hseg: :t doesn't work in private
14:43:44 <hseg> Usually it does.
14:43:47 <shachaf> mauke: It does now.
14:43:57 <shachaf> It has for a year or so?
14:44:00 <mauke> oops
14:44:02 <DanZimm> > System.FilePath.Posix.combine "hackspace" "rackage"
14:44:03 <lambdabot>  Not in scope: ‘System.FilePath.Posix.combine’
14:44:17 <DanZimm> eh I tried :P
14:44:19 <hseg> nm, it was a problem with my IRC client.
14:45:14 <Fuuzetsu> :t System.FilePath.combine
14:45:15 <lambdabot> FilePath -> FilePath -> FilePath
14:45:17 <Fuuzetsu> ;)
14:45:23 <Fuuzetsu> :t System.FilePath.combine "hackspace" "rackage"
14:45:24 <lambdabot> FilePath
14:45:25 <Fuuzetsu> > System.FilePath.combine "hackspace" "rackage"
14:45:27 <lambdabot>  Not in scope: ‘System.FilePath.combine’
14:45:35 <Fuuzetsu> WHY
14:45:41 <Fuuzetsu> it wasa literally just there
14:46:29 <hseg> The Heisenscope strikes again!
14:46:46 <mauke>  @type and @run are different
14:46:50 <merijn> Fuuzetsu: :t and > user different scopes
14:46:57 <merijn> :t getLine
14:46:58 <lambdabot> IO String
14:46:58 <Fuuzetsu> obviously.
14:47:01 <merijn> > getLine
14:47:03 <lambdabot>  <IO [Char]>
14:47:07 <merijn> oh, that one works?
14:47:09 <Fuuzetsu> ;P
14:47:10 <merijn> unlucky
14:47:12 <merijn> :p
14:47:36 <exio4> but combine is pure
14:48:06 <Fuuzetsu> pure maiden
14:49:09 <athan> Hey guys, can Djinn derive functions/values in types that use higher kinds? Like `a -> m a`, for instance?
14:49:34 <Fuuzetsu> try and see?
14:49:37 <Fuuzetsu> @djinn a -> m a
14:49:37 <lambdabot> -- f cannot be realized.
14:50:09 * Fuuzetsu found out about the free theorem generator the other day
14:50:22 <begriffs_> Does anyone know how to transform a Response in the wai 3 package? I'd like to add headers to an already built Response.
14:50:39 <hseg> It's fun, except it doesn't work with typeclasses, which gets annoying.
14:50:52 <hseg> Was trying to find the free theorem for traverse.
14:51:04 <Fuuzetsu> begriffs_: I'd find out for you but Hackage is losing it ;(
14:51:31 <hseg> Has anyone seen this http://commonmark.org/ ? The chances of getting Markdown in Haddock are improving!
14:51:36 <Fuuzetsu> hseg: you can define own data types right? you could try to leverage that
14:52:08 <hseg> Yeah. Create the typeclass dictionaries yourself. It's a lot of boilerplate, though.
14:52:14 <begriffs_> Fuuzetsu: I'm looking at Hackage, and it seems like I should construct a new Response out of an old one, but there are lots of options to build them. Kind of confusing.
14:52:16 <Fuuzetsu> hseg: Yes, I saw that before I even proposed Markdown in Haddock. We do not have Markdown in Haddock today so your chances are not better than they were a year ago ;P
14:52:59 <hseg> :P. Sure, but at least the lack of standardisation point is gone. ish.
14:53:32 <Fuuzetsu> 13th standard, add it to the pile
14:53:59 <hseg> We'll just have to wait and see.
14:54:24 <Zer000> Hello. I'm pretty new to haskell, I've only learned some of the basics but I program in Python a lot. I recently wrote a server in Python that uses asynchronous programming to handle lots of connections with callbacks. I don't really like that style of programming because it's harder to reason about but it is fast. How are such things done in haskell?
14:54:25 <Fuuzetsu> sure, but all the other points still hold
14:55:06 <hseg> IIRC, they're the fact that A) we already have something good enough and B) it wouldn't play well with haddock itself?
14:55:06 <Fuuzetsu> there is no clear mapping Markdown ⇔ existing Haddock syntax or Markdown ⇔ Haddock backends resulting in something awkward
14:55:18 <Fuuzetsu> yes and yes, more or less
14:55:20 <gregnwosu> its resolved itself, only by me continually adding dependencies to get stuff to lpaste
14:55:39 <hseg> Right. Eh.
14:55:52 <hseg> Anyway, regarding the free theorems, it might be nice to have a Haddock directive/option to have it emit the free theorems for functions in the docs.
14:56:35 <Fuuzetsu> hseg: even assuming Markdown somehow makes it in, that means that the maintainers (me) have to maintain two parsers and we're restricted in what we can do
14:56:55 <Fuuzetsu> we'd have to invent new Markdown syntax for new constructs which makes the standard part go into the bin
14:57:39 <Fuuzetsu> hseg: pandoc now has Haddock reader/writer, perhaps you could have a look at that if you want to write some longer docs in Markdown
14:58:45 <hseg> Hm. I just mentioned it because I saw other people asking for it.
14:58:46 <spooderman> Hey guys. I'm trying to make a function that takes in two bool values and returns a single bool value. I am reading a book on haskell but I can't seem to do it correctly (as examples have shown)...
14:59:04 <spooderman> I defined the function nameIS x y = do stuff
14:59:10 <spooderman> It can't load it though
14:59:14 <spooderman> What am I doing wrong?
14:59:19 <sinelaw> @hoogle [a] -> b -> [(a,b)]
14:59:19 <sbrg> spooderman: paste code?
14:59:21 <Fuuzetsu> Right yes, don't forget that I was initially going to implement this but I just don't think it's worth all the trouble anymore after sitting down and thinking about it.
14:59:21 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
14:59:22 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
14:59:22 <lambdabot> Data.ByteString.Builder.Prim (>*<) :: Monoidal f => f a -> f b -> f (a, b)
14:59:25 <hseg> spooderman: define "load it"
14:59:37 <spooderman> hseg: ghci application.hs
14:59:46 <mauke> spooderman: define "can't"
15:00:01 <hseg> Or better yet, paste a terminal session.
15:00:08 <sbrg> @type zip a . repeat -- sinelaw ?
15:00:09 <lambdabot>     Couldn't match expected type ‘[a]’ with actual type ‘Expr’
15:00:09 <lambdabot>     In the first argument of ‘zip’, namely ‘a’
15:00:09 <lambdabot>     In the first argument of ‘(.)’, namely ‘zip a’
15:00:10 <spooderman> mauke: "parse error on input 'then' Failed, modules loaded: none
15:00:11 <sbrg> eh
15:00:17 <mauke> spooderman: show code
15:00:37 <sinelaw> sbrg, yes.
15:01:08 <hseg> spooderman: Answer with data up to now - your code is incorrect. Paste code for more helpful answers.
15:01:31 <spooderman> hseg: please hold
15:01:54 <spooderman> http://pastebin.com/ynP3w2fB
15:02:08 <mauke> spooderman: missing )
15:02:17 <spooderman> haha
15:02:18 <spooderman> thanks
15:02:19 <mauke> you have 'if (... then'
15:02:45 <mauke> 'if X then True else False' better written as 'X'
15:03:02 <mauke> also, boolean xor is spelled /=
15:03:08 <mauke> exOr = (/=)  -- fixed
15:03:22 <spooderman> mauke: thanks
15:05:07 <hseg> Suggestion as to a more elegant way to write (\p x -> if p x then Just else Nothing)?
15:05:22 <ij> Just what?
15:05:33 <hseg> Oops. Just x
15:05:43 <vanila> that's already written well
15:05:57 <vanila> just give it a name and you can use it elsewhere
15:05:58 <vanila> foo p x = if p x then Just else Nothing
15:06:00 <kvanb> :t bool
15:06:00 <lambdabot> a -> a -> Bool -> a
15:06:03 <kvanb> :t maybe
15:06:04 <lambdabot> b -> (a -> b) -> Maybe a -> b
15:06:21 <hseg> Yeah, but I feel it should already exist, and that I'm just reinventing the wheel..
15:06:29 <hseg> bool might help.
15:06:33 <vanila> it doesn't already exist
15:07:03 <tabemann_> (/=) is not equals, not exclusive or!
15:07:10 <kvanb> > let f p x = bool (Just x) Nothing (p x) in f (>3) 5
15:07:11 <mauke> tabemann_: what's the difference?
15:07:11 <lambdabot>  Nothing
15:07:15 <kvanb> > let f p x = bool (Just x) Nothing (p x) in f (>3) 2
15:07:17 <lambdabot>  Just 2
15:07:23 <vanila> if you;re in Maybe monad you can do do guard (p x) ; return x I think
15:07:33 <hseg> tabemann_: For Bool, it has the same semantics.
15:07:40 <tabemann_> tis true
15:07:46 <kvanb> I wonder if there's an alternative instance
15:07:56 <hseg> kvanb: Of what?
15:08:00 <vanila> :t (liftM2 bool Just (const . Nothing) .)
15:08:01 <lambdabot>     Couldn't match type ‘b1 -> b0’ with ‘Maybe b’
15:08:01 <lambdabot>     Expected type: b -> Maybe b
15:08:01 <lambdabot>       Actual type: b -> b1 -> b0
15:08:07 <kvanb> I don't know, something maybe
15:08:13 <kvanb> *something `Maybe`
15:08:42 <mauke> :t (== 1) `on` fromEnum
15:08:43 <lambdabot>     Couldn't match type ‘Bool’ with ‘Int -> c’
15:08:43 <lambdabot>     Expected type: Int -> Int -> c
15:08:43 <lambdabot>       Actual type: Int -> Bool
15:08:54 <kvanb> > (>3) 2 <|> Nothing
15:08:56 <lambdabot>  Couldn't match expected type ‘Data.Maybe.Maybe a’
15:08:56 <lambdabot>              with actual type ‘GHC.Types.Bool’
15:10:23 <capisce> let f p x = find p [x]
15:10:46 <merijn> thoughtpolice: ping?
15:11:18 <kvanb> interesting capisce
15:11:20 <merijn> Or anyone well-versed in the reflection package, I guess
15:11:28 <kvanb> smart, but probably very ineffecient.
15:11:34 <beid7712> http://sx69sx.com/
15:11:47 <Fuuzetsu> ^ porn
15:11:50 <kvanb> dont click that
15:11:55 <kvanb> especially not at uni in a hall
15:11:57 <kvanb> ;__;
15:12:01 <geekosaur> heh
15:12:12 <Fuuzetsu> kvanb: it's sx69sx, not sure what you expected
15:12:17 * geekosaur tends to think "someone pops in, pastes url" is auto dont click
15:12:22 <kvanb> well you know
15:12:36 <merijn> geekosaur: Some people (like me) don't have joins visible :p
15:12:37 <Fuuzetsu> hm, maybe I shouldl make my next blogpost have a lewd title
15:12:46 <kvanb> x2048
15:12:48 <kvanb> xn24
15:12:56 <kvanb> I didn't read the numbers ;_;
15:13:02 <mauke> http://www.5z8.info/uniqueinvestmentopportunity_x8e2jh_inject_worm
15:13:12 <thoughtpolice> merijn: pong
15:13:29 <kvanb> I ...
15:13:42 <kvanb> I don't want to get trolled a second time, but I feel I've seen mauke around here
15:13:45 <merijn> thoughtpolice: If you have some time, I have some questions on your reflection tutorial (since edwardk is not here for me to bug :p)
15:14:07 <Fuuzetsu> you were going to bug edwardk instead of the person who made the tutorial?
15:14:13 <merijn> kvanb: mauke is a bot that automatically corrects any mistaken knowledge you have about the C standard (or almost any other standard)
15:14:19 <merijn> Fuuzetsu: Well, it's his library...
15:14:52 <mauke> the first prototype of the C standard was created in 1908 by the germans
15:14:53 <spooderman> In my xor function, would it be better just to compare x and y? I mean, it will make the function smaller.
15:15:06 <mauke> I already made it smallest
15:15:45 <spooderman> mauke: But you forget the value of y
15:15:51 <spooderman> That matters, I thought
15:16:12 <hseg> mauke: Didn't you listen in history class? The black plague was caused by an overly-creative compiler writer's interpretation of undefined behaviour.
15:16:13 <spooderman> mauke: I don't want to just do what you say without understanding it.
15:16:18 <merijn> thoughtpolice: Basically, I've been trying to reify a record into a typeclass/constraint so that I can construct a value of type "Dict (Foo a)", but I'm not sure whether that's actually possible and/or sane?
15:16:28 <mauke> spooderman: what about the value of y?
15:16:52 <spooderman> mauke: the value of y has no relation to x. Only evaluating the value of x leaves room for error
15:16:53 <merijn> (for some known value of 'a', that is)
15:17:04 <mauke> spooderman: ok, and what does that have to do with my code?
15:17:10 <hseg> merijn: It might cause problems with assumptions regarding typeclasses.
15:17:33 <hseg> merijn: e.g. uniqueness of instances
15:17:52 <spooderman> mauke: from my understanding, you are suggesting that I just check the value of x. If x then true
15:17:58 <mauke> no
15:18:07 <mauke> I'm suggesting exOR = (/=)
15:18:31 <mauke> but in general, if you have an expression of the form 'if X then True else False', you can shorten it to 'X'
15:18:31 <merijn> hseg: I'm pretty sure dynamically creating typeclass instance already breaks everything known to man, so since I'm already using reflection I'm not worried about breaking a few more things :p
15:18:35 <mauke> where X is an arbitrary expression
15:19:06 <spooderman> mauke: ah, let me test that...not to say you are wrong. I just understand better when I experience it
15:19:09 <spooderman> lol
15:19:30 <hseg> merijn: :). Yes and no. Oleg discusses recovering uniqueness in the paper linked in the tutorial.
15:19:32 <merijn> spooderman: If X already has type bool, then explicitly returning a Bool using if/then/else is redundant
15:19:58 <mauke> similarly, 'X == True' => 'X', and 'X == False' => 'not X'
15:20:36 <hseg> > (/=) <$> [False, True] <*> [False, True]
15:20:37 <lambdabot>  [False,True,True,False]
15:21:00 <merijn> hseg: Sure, I'm not entirely convinced what I want is sane, it's just that I don't understand reflection well enough to decide on the sanity of what I want :)
15:21:24 <hseg> > (\x y -> (x && not y) || (not x && y)) <$> [False, True] <*> [False, True]
15:21:25 <lambdabot>  [False,True,True,False]
15:22:02 <hseg> merijn: Yeah. I've been looking into this in the hopes of finding a way of eliminating all these *By and *On functions.
15:23:05 <merijn> Like the Lift newtype in that post isn't quite what I want
15:26:16 <hseg> merijn: What's missing?
15:26:43 <hseg> merijn: BTW, I definitely need to reread that part. Don't remember seeing that before.
15:26:53 <hseg> merijn: Is this packaged somewhere?
15:27:06 <merijn> hseg: What? The reflection stuff?
15:27:13 <merijn> hseg: It's edwardk's library
15:27:16 <merijn> @hackage reflection
15:27:16 <lambdabot> http://hackage.haskell.org/package/reflection
15:27:18 <merijn> plus
15:27:21 <merijn> @hackage constraints
15:27:21 <lambdabot> http://hackage.haskell.org/package/constraints
15:27:32 <hseg> No, just the code he uses in that section to dynamically create instances
15:27:46 <merijn> At the end of the tutorial?
15:27:55 <hseg> Yep
15:28:06 <merijn> No, I meant, that's it :)
15:28:37 <merijn> What's missing is that: 1) I'm not trying to lift arbitrary existing typeclasses and 2) it assumes typeclasses of kind "* -> Constraint", neither of which I have
15:29:47 <hseg> 1) What are you trying to lift 2) what typeclasses *do* you have whose target kind isn't Constraint?
15:30:06 <merijn> The target kind is constraint, the input kind isn't *
15:30:37 <hseg> Ah.
15:30:38 <superfunc> How would I specify the type of read in a map call like this: map read . (\x -> [x]) $ show num ?
15:30:46 <hseg> What are you trying to do?
15:30:47 <merijn> I have a class "Foo :: Bar -> Constraint" and I'm trying to dynamically create an instance for it
15:30:54 <shachaf> (read :: String -> ...)
15:31:00 <shachaf> But you probably oughtn't use read for that.
15:31:20 <shachaf> You probably also want more parentheses, if you do end up using read for that.
15:31:23 <superfunc> yeah, I was just messing around and noticed that I didn't understand that syntax well enough
15:31:24 <merijn> s/probably oughtn't/really shouldn't
15:31:38 <shachaf> :t digitToInt -- one option
15:31:39 <lambdabot> Char -> Int
15:31:49 <superfunc> I was just trying to specify the return type
15:31:52 <zwer_> > map read ["1", "2", "3"] :: [Int]
15:31:53 <lambdabot>  [1,2,3]
15:32:38 <hseg> merijn: Lifted kinds?
15:33:05 <merijn> Yes
15:34:33 <zwer_> superfunc and what was the problem? you can specify return type just fine
15:35:22 <superfunc> I had it as (read::Integer) as opposed to (read::String->Integer)
15:36:46 <hseg> merijn: hm.
15:38:53 <hseg> merijn: wouldn't just changing the signatures for p and a so that they're kind-polymorphic in ReifiableConstraint and Lift suffice?
15:39:53 <merijn> hseg: No, you need to change Lift too, because "lower :: a" is now a type error (a is not *)
15:40:03 <merijn> And then it becomes wholly unobvious
15:40:45 * hackagebot postgresql-simple 0.4.4.1 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.4.4.1 (LeonSmith)
15:41:07 <superfunc> Could someone tell me why this produces a list of individual numbers: map (read::String->Integer) $ map (\x -> [x]) $ show num while this gives me a list containing one number: map (read::String->Integer) . (\x -> [x]) $ show num
15:41:13 <hseg> merijn: I said you also had to change Lift.
15:41:24 <merijn> hseg: Sure, but it's unclear in what way :)
15:41:57 <hseg> merijn: OK, the question is how to write kind-polymorphic signatures that GHC'll accept.
15:42:07 <merijn> hseg: The rest of the code relies on implenting every reifiable typeclass on top of lift, which I'm not sure how to do as Lift is not a valid argument for the typeclass
15:42:31 <merijn> Since the typeclass are Bar -> Constraint, not *-> Constraint and Lift has kind *
15:43:32 <hseg> Hm. We somehow want to say that Lift is also of kind Bar.
15:43:40 <hseg> But aren't lifted kinds closed?
15:44:21 <merijn> hseg: Hence my difficulties :p
15:44:29 <hseg> :)
15:44:41 <hseg> Now we're (more or less) on the same page.
15:45:48 <hseg> So either we need open lifted kinds, or we need a way to fake using a type of kind Bar
15:46:09 <merijn> or we need a wholly different approach than used in the tutorial :)
15:46:16 <merijn> Let's not make this an XY problem :p
15:46:41 <hseg> :)
15:48:12 <hseg> Wait a minute. Does your typeclass accept newtypes wrapping Bar types?
15:48:27 <merijn> No, newtypes always have kind *
15:49:24 <hseg> :(. So given a kind with n types, there are precisely n instances that can be given.
15:49:50 <hseg> Unless we break either datakinds or typeclasses.
15:49:52 <benzrf> merijn: huh?
15:50:00 <benzrf> merijn: what do you mean 'newtypes always have kind *'
15:50:08 <merijn> benzrf: Fully applied ones
15:50:13 <benzrf> oh
15:50:19 <benzrf> well that's true of data too
15:50:28 <merijn> Sure
15:53:30 <hseg> I don't know. Strong enough in the Types, I am not.
15:55:03 <vramana> Why does the author of LYAH keeps the comma at the start of next line rather at the end of the line ? For readability ?
15:55:17 <merijn> vramana: It's a fairly common style in haskell circles
15:56:19 <merijn> vramana: To make all names line up despite parenthesis/brackets
15:57:03 <vramana> merijn: That makes sense. Thanks
15:57:34 <platz> i think maybe also because one tends to add to the end of a list of names rather than the beginning, so it prevents having to fiddle with commas
15:57:39 <merijn> But there's no technical reason to not have them at the end of line, it'd be eqaully valid syntactically
15:57:51 <merijn> platz: It certainly helps with that, yes
16:00:53 <vramana> merijn: Okay. I am reading Algebraic Data Types intro now. They seem very similar to how you construct classes in JavaScript using functions. Is there any kind of relation between the two?
16:01:17 <jollygood> I found that style of comma placing weird when I first saw it but then it grew one me
16:01:45 <merijn> They're more similar to a mix of C/C++/etc. union/enum/struct after going through a blender
16:02:15 <hseg> jollygood: I missed it when I had to use other languages.
16:08:48 <jobeN> What is an ordered type?
16:09:00 <merijn> A type that has an ordering?
16:09:45 <jobeN> merijn: so if I am to make a function that is accepting a value from any ordered type, they are explicitly saying something that is already implied?
16:10:18 <merijn> Who is they? What is already implied?
16:10:19 <jobeN> I don't see why they said it...if it goes without saying.
16:10:40 <jobeN> merijn: that a good function would take a value of any ordered type. "they" being my school
16:11:19 <rom1504> so
16:11:22 <jobeN> A good function should already take that into account. It seems weird to specify that
16:11:23 <rom1504> what is your point ?
16:11:31 <merijn> Your questions do not have nearly enough information to give any sensible information
16:11:32 <jobeN> rom1504: I don't know if they meant something else. It confused me
16:11:47 <merijn> You have specified which function, what type, what input or really anything useful
16:12:16 <hseg> As far as I can understand your question, they're asking that you make use of the assumption that your type is an instance of Ord. But that's as much as I can deduce from your partial information.
16:12:25 <Rufflewind> Your question is very confusing and vague.
16:12:31 <jobeN> merijn: A function tat computes the maximum value in a nonempty list of integers. Generalize the function by making it polymorphic, accepting a value of any ordered type.
16:12:35 <merijn> hseg: I try to resist the temptation to guess
16:12:56 <jobeN> that*
16:13:05 <rom1504> ok, what's the problem merijn ?
16:13:13 <hseg> merijn: I didn't think I was guessing.
16:13:41 <merijn> jobeN: Right, that seems like an unambiguous definition?
16:13:56 <hseg> jobeN: What's the problem, then?
16:13:58 <rom1504> oh I meant jobeN
16:14:31 <jobeN> I was confused that possibly "any ordered type" meant something other than the obvious. Because they stated it, it just seems like something that doesn't need being said.
16:14:42 <jobeN> So I thought there was something that I was missing
16:14:55 <merijn> An ordered type is any type that implements the Ord typeclass
16:14:55 <jobeN> anyway
16:15:04 <jobeN> thanks
16:15:04 <rom1504> but it's needed to say it ?
16:15:05 <hseg> Well, in order to be able to define a maximum, you need some kind of ordering, so yeah, it is obvious.
16:15:29 <jobeN> thanks guys
16:15:31 <rom1504> yeah
16:15:33 <merijn> hseg: Not to JS and PHP programmers ;)
16:15:58 <hseg> Blergh
16:16:26 <dpwright> it may be obvious, but *not* saying it would be wrong -- as in, "accepting a value of any type" would be impossible to do
16:16:37 <dpwright> oh, he's gone
16:19:01 <hseg> Found another use for dependent types - creating predicate-indexed monoid instances.
16:19:31 <merijn> Man
16:19:40 <merijn> -XInstancesSigs should just be on by default
16:21:57 <merijn> hseg: Whoo!
16:22:03 <merijn> I may have found a way to get what I want
16:22:07 * merijn continues hacking
16:22:38 <hseg> Oooh.
16:22:43 <hseg> Excellent.
16:23:12 <merijn> It requires dark voodoo and 13 lines of {-# LANGUAGE KitchenSink #-}, but still :p
16:23:13 <burp> monochrom: so, I'll post on haskell-cafe regarding the segfault, maybe it's a bug
16:24:26 <hseg> dark voodoo = unsafe*?
16:24:42 <hseg> dark lord = dead?
16:24:49 <hseg> dark _ = evil?
16:24:54 <merijn> Not unsafe*
16:25:05 <merijn> Well, not yet...
16:25:13 <hseg> Hopefully.
16:25:36 <merijn> The reflection tutorial use unsafeCoerceConstraint, so...
16:25:57 <zwer_> what does the code do? I only managed to crash haskell program when using FFI
16:27:03 <hseg> zwer_: What code? merijn's code?
16:27:37 <zwer_> the code that is segfaulting.. sorry I should probably scroll up
16:28:07 <jollygood> can unsafePerformIO  cause segfault?
16:28:11 <merijn> Sure
16:28:22 <jollygood> how?
16:28:36 <merijn> Just unsafePerformIO into C territory :)
16:29:13 <jollygood> that is cheating :)
16:29:36 <merijn> hseg: Ah, damn, maybe this still won't work >.<
16:29:52 <hseg> What did you attempt?
16:30:27 <merijn> Wrote a bunch of class/instance combinations to reify the operation I want, but that still doesn't let me create a witness for the class
16:30:47 <merijn> Guess I'll just wait for edwardk to wake up so I can ask whether what I want is possible at all
16:31:46 <eitan_chatav> Hey, how do you prove (assuming the statement is true) that `x :: forall Profunctor p. p a b -> p s t` is equivalent to `x = dimap f g for some inverse pair f,g?
16:33:14 <hseg> eitan_chatav: Do you mean to say that the only possible inhabitants of the type forall p. Profunctor p => p a b -> p s t are of the form dimap f g?
16:33:33 <eitan_chatav> yes
16:34:01 <hseg> What do you mean by "inverse pair"?
16:35:04 <eitan_chatav> f . g === id and g . f === id
16:35:39 <nkpart> @seen danclien
16:35:39 <lambdabot> danclIEN
16:35:48 <etherael> @seen lilac
16:35:48 <lambdabot> LIlaC
16:36:16 <nkpart> That's... not what I remember @seen doing
16:36:34 <etherael> I thought it was supposed to tell you when such and such was last here?
16:36:50 <hseg> Simple refutation:
16:36:57 <hseg> > dimap succ succ succ 3
16:36:59 <lambdabot>  6
16:37:08 <merijn> etherael: lambdabot has never had a @seen
16:37:12 <hseg> :t dimap succ succ
16:37:13 <lambdabot> (Profunctor p, Enum d, Enum b) => p b d -> p b d
16:37:41 <merijn> hseg: succ is not it's own inverse
16:37:42 <etherael> @merijn: Just inferring from that functionality I had seen on other bots. I’m curious though, what is it actually doing?
16:37:42 <lambdabot> Unknown command, try @list
16:37:50 <eitan_chatav> indeed
16:37:55 <merijn> etherael: Probably @leet
16:38:00 <hseg> merijn: I know, that's why it's a refutation.
16:38:01 <etherael> ahh.
16:38:04 <merijn> etherael: It has an autocorrect
16:38:25 <eitan_chatav> succ is also not total
16:38:33 <eitan_chatav> let's stick with total functions
16:38:41 <hseg> eitan_chatav: Fine.
16:38:56 <hseg> > dimap (+1) (+1) (+1)
16:38:57 <lambdabot>  <Integer -> Integer>
16:39:09 <jollygood> :t dimap
16:39:10 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
16:39:51 <hseg> eitan_chatav: Profunctor generalises the fact that you can pre- and post- compose to a function.
16:39:51 <eitan_chatav> :t dimap ((+1) :: Integer -> Integer) ((+1) :: Integer -> Integer)
16:39:52 <lambdabot> Profunctor p => p Integer Integer -> p Integer Integer
16:40:55 <benmachine> merijn: lambdabot had a @seen long ago, but it got binned because it had a memory leak, I think
16:40:57 <eitan_chatav> ok, so then what's the justification for the profunctor representation for Iso?
16:42:32 <benmachine> also, succ is total on Integer
16:42:45 <hseg> eitan_chatav: I have no idea.
16:43:42 <eitan_chatav> I guess it's up to coder to only generate law preserving Isos?
16:44:56 <djfoote>  \query lambdabot
16:45:47 <hseg> I dunno, ask a lensman.
16:48:34 <eitan_chatav> oops, thought i was in #haskell-lens :-)
16:49:12 <hseg> :). It's OK, just beyond my knowledge.
16:49:35 <eitan_chatav> no worries. Thanks for your help!
16:50:35 <hseg> nnp
17:01:33 <merijn> hmm
17:01:45 <merijn> Maybe I really just want ImplicitParams instead of reflection
17:06:30 <merijn> ugh
17:06:42 <merijn> Although I can't construct implicit param constraints on the fly, I'm guessing
17:07:00 <merijn> :k (?cmp :: a -> a -> Ordering)
17:07:01 <lambdabot> Not in scope: type variable ‘a’
17:07:01 <lambdabot> Not in scope: type variable ‘a’
17:07:07 <merijn> :k forall a . (?cmp :: a -> a -> Ordering)
17:07:08 <lambdabot> Constraint
17:08:33 <ryantrinkle> is there a higher-performance implementation of MonadState? it's ok if it requires IO under the hood
17:09:01 <merijn> What do you mean by higher performance?
17:09:27 <kristof> probably without all the boxing/unboxing
17:09:45 <merijn> ugh, I can't share type variables between implicit param constraint and outer function?
17:10:38 <ryantrinkle> merijn: well, i've got a huge computation that uses MonadState to accumulate stuff
17:10:58 <ryantrinkle> originally i was using WriterT, but found StateT to be much faster (CPU time)
17:11:15 <ryantrinkle> then, i switched to ReaderT (IORef blah), which was faster still
17:11:26 <merijn> Whether there is something faster really depends on what kind of computation
17:11:52 <enthropy> merijn in some ghcs i think you can have implicit parameters constraining a class (out maybe an instance)
17:12:22 <merijn> enthropy: That's not really related to my question, I think?
17:12:36 <merijn> nvm, ghetto hacks to the solution!
17:13:30 <enthropy> My understanding was that you are looking to fake local instances
17:13:32 <merijn> I can share a type variable by simply doing "foo :: forall a . (?bar :: Proxy a -> OpType a) => OpType a" and doing "?bar (Proxy :: Proxy a)" :)
17:14:11 <enthropy> Which might be an earlier problem
17:14:23 <ryantrinkle> merijn: i suppose you're right about it depending on the type of the computation, but i'm basically just concerned about the fact that >>= for ReaderT seems to do a ton of allocation
17:15:26 <merijn> tbh, allocation is cheap in haskell
17:15:58 <merijn> oh, bollocks
17:16:16 <merijn> oh, no, the day may still be safed
17:16:28 <ryantrinkle> merijn: i wish it were cheap! i'm targeting ghcjs as well as ghc
17:18:53 <merijn> ah
17:24:21 <merijn> Is there any significant difference (in terms of performance) between an unpacked heterogeneous list and a tuple?
17:24:38 <merijn> Can I even unpack a heterogeneous list?
17:25:43 <shachaf> What sort of heterogeneous list?
17:26:21 <merijn> shachaf: "data HList :: [*] -> * where HNil :: HList '[]; HCons :: x -> HList xs -> HList (x ': xs)"
17:26:23 <shachaf> HList [...] style?
17:26:27 <shachaf> OK.
17:26:27 <merijn> Or along those lines
17:26:50 <merijn> I just realised I don't even know how to write unpack pragma's for GADT syntax
17:27:02 <shachaf> HList [A,B,C] is like (A,(B,(C,())))
17:27:48 <merijn> shachaf: Right, basically, I'm hoping to somehow get GHC do be able to direct indexing for fixed length HList's
17:27:49 <shachaf> Oh, that sort of unpack.
17:28:21 <shachaf> You want it to be like (A,B,C)?
17:28:43 <merijn> Basically
17:28:54 <marchelzo_> is there a combinations function? Like Int -> [a] -> [[a]]? I have a list of numbers and I want every 5 number combination of the numbers in the list.
17:29:01 <shachaf> I don't think that's very feasible.
17:29:09 <merijn> shachaf: I was afraid of that :(
17:29:31 <shachaf> something something boxed cat
17:29:57 <ttuegel> is anyone aware of an implementation of okasaki's O(1) queues on hackage? i can't find anything, but that seems like a huge omission for this community :)
17:29:58 <merijn> I'm ok with only unboxing the list, not the contents
17:30:21 <hseg> marchelzo_: well, you could cook something up using repeat and the list instance for applicative
17:30:36 <hseg> marchelzo_: but i don't know of anything specific
17:30:44 <shachaf> You can write a function like (a -> b) -> HList (a ': ts) -> HList (b ': ts)
17:30:49 <merijn> shachaf: Unboxing the list items would of course not work
17:30:59 <shachaf> Which works on arbitrary size HLists.
17:31:26 <merijn> shachaf: Sure, but how does that help with unboxing the list constructors?
17:31:47 <shachaf> It doesn't. It does the opposite of helping.
17:32:16 <merijn> How so?
17:32:32 <merijn> As long as 'a' is boxed that has no effect on the unboxing of the list, no?
17:32:42 <shachaf> Maybe I don't follow what you're asking.
17:32:57 <shachaf> Also I'm typing on a phone right now.
17:33:19 <merijn> shachaf: I want "HList [A,B,C]" as a densely packed group, that A, B and C are boxed I can live with
17:33:38 <merijn> But I plan to frequently index into the list to read an element and having O(n) access time is not acceptable to me
17:33:43 <shachaf> Yes. I'm not talking about unboxing the values.
17:34:12 <geekosaur> I don't think there's any way to make HList a vector
17:34:16 <shachaf> In talking about following n pointers for an n-element tuple etc.
17:34:33 <merijn> geekosaur: :(
17:34:53 <shachaf> But see what I said above.
17:34:56 <marchelzo_> hseg: I can't figure out how do it like that, do you know?
17:34:59 <geekosaur> not without a complete reimplementation at least, and I don't know how that would impact it
17:35:13 <shachaf> You can write a function that operates on an HList of unknown length.
17:35:14 <geekosaur> HList involving type hackery above my pay grade
17:35:16 <merijn> geekosaur: I'm not talking about HList the library, but the trivial GADT I just defined
17:35:31 <shachaf> How would you make that work with your packed HList?
17:35:37 <merijn> geekosaur: "data HList :: [*] -> * where HNil :: HList '[]; HCons :: x -> HList xs -> HList (x ': xs)"
17:36:11 <merijn> shachaf: It would have to copy the entire list? The exact same way that "data Pair a b = Pair {-# UNPACK #-} a {-# UNPACK #-} b" has to copy the entire Pair?
17:36:32 <geekosaur> looks to me like that's still recursively defined? (but type level lists, still above my pay grade...)
17:36:39 <yukko> hi I have a question about the glut package in hackage - I have a keyboard/mouse callback set up, and when I hold a key down it sends a bunch of events that say the key is rapidly alternating between up and down, even when I'm just holding it down. is this standard behavior for glut, or is this a bug in the haskell glut bindings?
17:36:45 <shachaf> But it doesn't know how long the list is.
17:36:56 <merijn> geekosaur: Sure, if you know a way to define it without recursion, I'm all ears
17:37:14 <geekosaur> I don't, and that's the problem. I'm not sure it's doable
17:37:26 <merijn> shachaf: I'd be perfectly fine with fixed length ones, but I don't want to define 10 different Pair datatypes, that would make me sad
17:37:45 <merijn> At that point I might as well just define a type family that returns an apropriate tuple and index that
17:37:54 <shachaf> Wait, now I'm confused.
17:38:34 <merijn> shachaf: Basically, I'm just trying to fake indexed records in an efficient way
17:39:00 <geekosaur> yukko: that sounds like standard key repeat behavior?
17:39:09 <shachaf> And I'm way too slow on this phone so maybe I'll go for a bit and come back later if it isn't resolved.
17:39:52 <nshepperd> ttuegel: I dunno, there's Seq which has O(1) operations on both ends, so maybe people decided that was sufficient
17:40:19 <merijn> shachaf: This seems to work: "data List a = Nil | Cons {-# UNPACK #-} !a {-# UNPACK #-} !(List a)"
17:40:34 <merijn> shachaf: Wouldn't the GADTs one be conceptually the same?
17:40:34 <geekosaur> yukko: I would expect that keyboard repeat has to be disabled, possibly externally to opengl.
17:40:54 <geekosaur> merijn: that removes only one level of indirection, its still following a chain of Cons-es to find an individual element
17:40:56 <merijn> Or rather, it doesn't produce an error?
17:41:03 <merijn> geekosaur: I guess :\
17:41:15 <yukko> geekosaur I see! thank you, I'll look into that :)
17:41:17 <geekosaur> so O(n). the implicit constant is just a bit smaller with unpack
17:43:01 <ttuegel> nshepperd: i guess so, it has the advantage of being O(log n) for random access, but it's also O(log n) for concatenation, rather than O(1)
17:43:34 <ttuegel> thanks, though. i guess i know what i'm doing tonight :)
17:43:47 <tb01110100> rip in peace bukkit :(
17:43:55 <tb01110100> oh wait
17:43:58 <tb01110100> wrong channel :D
17:44:28 * tb01110100 turns a lovely shade of red
17:44:41 <nshepperd> hmm, I didn't know there was a functional queue with O(1) concatenation
17:44:45 <nshepperd> seems magical
17:45:31 <merijn> geekosaur: I keep coming back to the only efficient way of doing it being a function that just does a dispatch on it's input argument, unfortunately until GHC is patched that can't work either >.>
17:46:42 <hseg> nshepperd: Basically, you maintain a list of appended elements and a list of output elements, then amortize the cost of reversing the input list over the course of the concatenation of the two.
17:47:38 <hseg>  marchelzo_, well, basically what I'd do is foldrM (liftM2 (:)) (return []) $ replicate n l
17:47:44 <hseg> s/foldrM/foldr
17:48:37 <hseg> > foldr (liftA2 (:)) (return []) $ replicate 3 [False, True]
17:48:38 <lambdabot>  [[False,False,False],[False,False,True],[False,True,False],[False,True,True]...
17:48:56 <hseg> > foldr (liftA2 (:)) (return []) $ replicate 2 [False, True]
17:48:57 <lambdabot>  [[False,False],[False,True],[True,False],[True,True]]
17:49:11 <marchelzo_> that is just replicateM, no?
17:49:29 <ttuegel> nshepperd: what hseg said, except you keep a list of appended *queues*
17:49:30 <hseg> marchelzo_: I'm an idiot. Yes
17:50:08 <marchelzo_> hseg: hah, it's ok.
17:50:20 <nshepperd> ah, right
17:51:03 <shachaf> merijn: That doesn't work for a bunch of reasons.
17:51:12 <shachaf> merijn: One of them is that GHC doesn't do unboxed sums.
17:51:32 <hseg> ttuegel: So basically, the difflist approach to okasaki's queues?
17:51:36 <shachaf> merijn: But also recursive unboxed types don't make that much sense in the first place.
17:51:55 <nshepperd> like the impl whose name I can't remember where you have data Queue a = Queue { in :: [a], out :: [a] } and you reverse `out` and add it to `in` when `in` runs out, right?
17:52:06 <shachaf> merijn: Think about the memory layout.
17:52:25 <nshepperd> er, other way around
17:52:44 <nshepperd> obviously you take elements from `out`, not `in`
17:53:06 <ttuegel> hseg: yeah, okasaki describes it in his book/thesis, but i don't think he explicitly constructs it
17:53:45 <ttuegel> nshepperd: you do the reversing while the queue runs to amortize the cost, and then you make a queue of those queues, which is O(1) catenable
17:55:01 <merijn> shachaf: Should probably file a bug about ghc not complaining if that doesn't work, then
17:55:46 <merijn> With -Wall it silently accepts it without complaining
17:55:56 <shachaf> merijn: Also {-# UNPACK #-} !a doesn't take make sense, since it's parametric -- you don't know what a is, so you can't unpack it.
17:56:20 <shachaf> That's sort of surprising. I'm pretty sure I've gotten warnings for "can't unpack this" before.
17:56:25 <shachaf> Oh, I think I know what's going on.
17:56:51 <enthropy> Merijn, geekosaur, shachaf there is a http://code.haskell.org/HList/Data/HList/RecordU.hs but i have no proof that it is any faster
17:57:11 <shachaf> merijn: it doesn't warn because with optimizations off it just ignores the UNPACK pragma.
17:57:29 <shachaf> merijn: If you put it in a file and compile with -O it'll warn.
17:57:32 <nshepperd> hmm. data Queue a = Queue { in :: [Queue a], out :: [a] }?
17:57:56 <merijn> enthropy: I'll check it out
17:58:09 <merijn> shachaf: Odd that it only warns with -O
17:59:44 <enthropy> By no proof, I mean that some benchmarks show that it is not faster
18:00:27 <merijn> enthropy: I don't see that module in HList to begin with?
18:01:49 <shachaf> That's probably why he linked to a darcs repository.
18:01:56 <enthropy> I wrote it a couple months ago so it isn't on a release yet
18:03:30 <merijn> I guess I'll just need to suck it up and wait for my bug to be fixed in 7.10 (hopefully)
18:03:50 <merijn> And cross my fingers that I don't make any errors until the typechecking actually works >.>
18:04:09 <dfeuer> YES.
18:04:15 <merijn> dfeuer: No!
18:04:20 <merijn> dfeuer: Giving up is for losers!
18:04:55 <dfeuer> yEs Yes YeS YEs yES yeS yes
18:05:29 <dfeuer> merijn, it's not "giving up". It's "taking the long view".
18:05:54 <merijn> dfeuer: But it means I can't compile -Wall -Werror like usual :(
18:06:01 <dfeuer> YES.
18:06:36 <shachaf> What are you doing, dfeuer?
18:06:47 <dfeuer> merijn, -Wall implies -fwarn-name-shadowing, right? That's a silly warning in my opinion.
18:07:03 <merijn> dfeuer: So you just do -fno-warn-name-shadowing?
18:07:31 <nshepperd> it makes me grump when ghc-mod complains about name shadowing
18:07:32 <shachaf> Warning on name shadowing seems reasonable to me.
18:07:34 <dfeuer> Well, okay.
18:07:45 <shachaf> -fwarn-type-defaults is going too far.
18:07:46 <merijn> shachaf: dfeuer Believes I'm wasting my time try to get it to work the way I want to :)
18:08:00 <Fuuzetsu> type defaults is too noisy
18:08:06 <no-doz> :t partition
18:08:07 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
18:08:23 <nshepperd> every time I have to write ^(2::Int) a kitten cries
18:08:47 <dfeuer> -fwarn-type-defaults makes perfect sense to me.
18:08:53 <dfeuer> :type (^)
18:08:58 <dfeuer> @type (^)
18:08:59 <lambdabot> (Num a, Integral b) => a -> b -> a
18:09:16 <geekosaur> did you mean -fno-warn-type-defaults?
18:10:42 <dfeuer> Well, actually, I guess it makes sense not to warn for type defaults once you've done  default (Int, Double)
18:11:13 <dfeuer> Or default (Int, Rational) for that matter.
18:20:05 <no-doz> :t loopup'
18:20:05 <lambdabot>     Not in scope: ‘loopup'’
18:20:06 <lambdabot>     Perhaps you meant one of these:
18:20:06 <lambdabot>       ‘lookup’ (imported from Data.List),
18:20:10 <no-doz> :t lookup'
18:20:11 <lambdabot>     Not in scope: ‘lookup'’
18:20:11 <lambdabot>     Perhaps you meant one of these:
18:20:11 <lambdabot>       ‘lookup’ (imported from Data.List),
18:28:01 <merijn> You know what I need? A type level "show" >.>
18:28:12 <merijn> "Show :: k -> Symbol" >.>
18:33:12 <fp_noob> hello guys, I am real noob in haskell... nice to meet you
18:35:29 <mmachenry> Nice to meet you too.
18:51:12 <Schoening> Hello! I have been learning JavaScript for about two years now. I would like to learn a second language. I was recommended either Clojure or Haskell. Could I get some biased suggestions?
18:51:29 <srhb> Yep, learn Haskell.
18:51:34 <srhb> You're in #haskell after all.
18:52:14 <vanila> What do you want out of a second language to learn?
18:52:25 <mmachenry> Schoening: They're both great. Learning a statically-typed language, however, might really increase your understanding of programming languages and software engineering since you're coming from the dynamic world.
18:53:25 <Schoening> mmachenry yeah I got a C++ I am currently reading. But then I got into a chat with someone about clojure. And since I have absolutely no clue how these functional languages are supposed to work I thought it might be a good idea
18:53:56 <srhb> What you won't get with Clojure is an equally great type system.
18:54:06 <merijn> I would recommend haskell just because it's "more different"
18:54:24 <merijn> I believe everyone should know at least one Hindley-Milner typed language
18:54:44 <exio4> i'd recommend coursera's proglang, if you can take it
18:55:47 <Schoening> exio4: is that a online course?
18:56:24 <exio4> yep, http://coursera.org/course/proglang
18:58:10 <Schoening> Now it is bookmarked :)
18:59:24 <katsh> why is Abrakadabra" < "Zebra"  True?
18:59:36 <dreams> Only if that course is in Haskell
18:59:44 <mmachenry> katsh: It comes first in the alphabet.
18:59:45 <merijn> katsh: Because that's how lexical ordering is defined?
19:00:06 <exio4> dreams: if you mean proglang, it is SML, Racket and Ruby
19:00:08 <katsh> mmachenry: thats what i thought. then why is "zoooo" == "z" false?
19:00:12 <mmachenry> merijn: Is that a question?
19:00:20 <merijn> mmachenry: A rhetorical one
19:00:21 <dreams> exio4: yeah I know.
19:00:34 <merijn> katsh: Because that's also how lexical ordering works :)
19:00:47 <mmachenry> merijn: It comes off as a little condescending when you answer like that.
19:00:49 <merijn> "z" is not equal to "zoooo"
19:00:52 <katsh> where can i read the lexical rules
19:01:12 <merijn> katsh: https://en.wikipedia.org/wiki/Lexicographical_order
19:01:21 <merijn> hmm
19:01:27 <merijn> actually, that looks like a terrible article
19:02:06 <hseg> I'm trying to clean up a type signature by extracting repeated components as type synonyms. However, GHC complains about Skolem typevars escaping. What to do?
19:02:20 <Jafet> I think it's not condescending to assume that people know how to use a phone book or dictionary.
19:02:23 <merijn> hseg: Don't let those typevars escape? :)
19:03:28 <hseg> :)
19:03:49 <vanila> katsh, < will compare the first element, but if the first element is equal it will compare the tails
19:04:01 <vanila> katsh, and the base case [] < anything
19:04:04 <katsh> vanila: thank you :)
19:04:13 <hseg> Wait a minute... I just found out that one of the functions I was passing was defined without parameters.
19:04:18 <hseg> Monomorphism?
19:04:36 <Schoening> I think I'm gonna play around with http://tryhaskell.org/ for a while. ^^
19:04:50 <shachaf> Skolem? I 'ardly know 'em!
19:05:14 <shachaf> Perhaps if you showed your code I would know 'em slightly better.
19:05:30 <exio4> you could check LYAH
19:05:33 <hseg> That solved it.
19:05:57 <hseg> shachaf: nm, I think I solved it.
19:05:58 <exio4> (how did you link LYAH with lambdabot? :P)
19:06:07 <Schoening> exio4 you mean me?
19:06:19 <shachaf> Inefficiently.
19:07:08 <exio4> Schoening: yeah :P
19:07:42 <enthropy> hseg you could make the alias local to the signature: f:: ty ~ Vec a b c => ty -> ty
19:08:14 <dreams> Is the left-pattern matching space leak still in GHC?
19:08:24 <Schoening> Thanks for the link. Handy stuff. I like how I write 5 + 5 and not (+ 5 5) lol ^^
19:08:47 <jle`> i wonder how life would be if seq was a typeclass
19:08:51 <hseg> Wouldn't GHC need to be able to check that? e.g. what if I use specific instances of typeclasses?
19:08:57 <StoneToad> Schoening: you can do (+) 5 5 if you really want to
19:09:03 <tabemann> they made seq a type class once
19:09:16 <dreams> jle`: are you using seq to reduce space?
19:09:24 <jle`> no
19:09:28 <jle`> it's just a thought experiment
19:09:29 <tabemann> they changed it to not having a type class because it made it nearly impossible to add seq to existing code
19:09:30 <jle`> :)
19:09:35 <hseg> enthropy: Also, the aliases are common to several sigs
19:09:37 <Schoening> lol :p why would I want to StoneToad? (+) 5 5 5 5 5 5 5 5 ? or something like that?
19:09:45 <dreams> jle`: I wonder what else it is used for.
19:10:16 <tabemann> theoretically seq having a type class is better, but practically it is worse
19:11:30 <bms1> Why should seq be a typeclass? What shouldn't you be allowed to seq?
19:12:12 <tabemann> there's theoretical reasons for why seq having a type class is better, particularly w.r.t. certain kinds of compiler optimizations not working with seq without a type class
19:12:20 <tabemann> particularly deforestation
19:12:24 <bms1> oh
19:13:01 <dreams> tabemann: are they optimized with seq or $!?
19:13:23 <bms1> tabemann: is there anything I could read about what you just brought up
19:13:26 <bms1> ?
19:13:27 <tabemann> but they found that *practically* having seq have a type class is a bad idea, because then Seq a => ends up infecting all of your code, and whenever you have to add seq to some code that doesn't have it yet you have to add Seq a => all the way down your call chain
19:14:31 <tabemann> dreams: they must special-case seq with them so that it doesn't try to optimize them, or otherwise certain things would break
19:14:40 <tabemann> bms1: I'll try to find the PDF
19:14:46 <Schoening> stackoverflow: "The problem with trying to be specific, is that trying to tell a non-Haskeller what they'll learn from Haskell is like trying to explain the color "green" to a blind guy."  haha.. I'm just gonna try and learn then I guess
19:15:10 <tabemann> http://www.haskell.org/pipermail/haskell/2002-May/009653.html
19:15:22 <dreams> seq is mostly used in strictification analyses right?
19:15:41 <bms1> tabemann: Thanks!
19:15:47 <vanila> lol that's so ridiculous
19:18:19 <dreams> Is there a notation to eliminate sharing?
19:18:51 <merijn> dreams: Why would you want that?
19:19:11 <dreams> merijn: to fire the GC.
19:19:19 <merijn> dreams: The simplest way would be the make the thing you don't want to share into a function, I guess?
19:19:44 <bms1> dreams: fire the GC? there are functions for controlling garbage collection in GHC Haskell
19:19:58 <dreams> bms1: really? which?
19:21:40 <bms1> dreams: Well, I just realized I think we were talking about different things. I mean like there was an IO action to force a garbage collection (I wasn't talking about like to free a specific piece of a data structure)
19:21:50 <bms1> but I'll try to find it anyway
19:22:11 <merijn> Should be in GHC.Prim
19:22:35 <merijn> But that'll just trigger a GC, doesn't guarantee object X gets gc'ed
19:22:51 <bms1> right
19:22:53 <bms1> http://hackage.haskell.org/package/base-4.7.0.1/docs/System-Mem.html
19:23:00 <dreams> merijn: f hugelist = foo hugelist + bar hugelist. So you're suggesting to write it as: f = foo hugelist; g = bar hugelist. then f + g?
19:23:27 <dreams> bms1: ah ok.
19:23:53 <merijn> dreams: What, exactly, are you trying to achieve?
19:24:36 <shachaf> Presumably the goal is to make something like avg l = sum xs / "length" l work by "cloning" the list and traversing it twice.
19:24:46 <shachaf> So that it can be GCed separately each time.
19:24:58 <dreams> merijn: I want the list to be GC's after foo hugeList
19:25:23 <bms1> dreams: Then how can you apply bar to hugelist?
19:25:25 <merijn> dreams: Avoiding sharing just means you know have TWO hugeList...
19:25:28 <dreams> shachaf: yes.
19:25:44 <dreams> merijn: yes I know that.
19:25:53 <merijn> That seems strictly worse?
19:26:03 <bms1> dreams: I don't see the advantage to that
19:26:15 <dreams> merijn: bar does little work with the list.
19:26:27 <merijn> dreams: Yes, but it'll still keep the copy alive
19:26:28 <dreams> foo traverses the whole thing.
19:26:50 <shachaf> merijn: If you can GC a list as you go, you can use ~constant memory.
19:26:58 <shachaf> sum [1..1000000] / "length
19:27:01 <dreams> but because bar has a copy, hugeList can't be GCed when traversed, causing a memory peak
19:27:33 <shachaf> (sum [1..1000000] / "length" [1..1000000]) will probably use a lot less memory than let l = [1..1000000::Int]; (sum l / "length" l)
19:28:01 <merijn> The real solution is to sum and length at the same time in a single traversal
19:28:04 <bms1> dreams: How about  let fo = foo hugelist in fo `seq` fo + bar hugelist?
19:28:04 <shachaf> s/;/in/
19:28:28 <bms1> so you compute foo hugelist before you even start bar?
19:28:29 <shachaf> merijn: That's a real solution in this particular case.
19:28:42 <shachaf> What if you have an infinite tree, and two functions which traverse two different parts of it?
19:29:02 <merijn> shachaf: In other words EINSUFFICIENTCONTEXT
19:29:13 <dreams> bms1: yes
19:29:18 <shachaf> I think it's a reasonable question on its own. But the answer is that there's no easy way to do it, and it's trickier than it seems.
19:29:40 <merijn> \o/
19:30:03 <merijn> Apparently there's a class that represent implicit params, so I can still construct them on the fly :)
19:30:14 <shachaf> I looked on Google and found http://stackoverflow.com/q/11675807
19:30:21 <shachaf> Now I remember reading about ghc-dup
19:30:30 <shachaf> Probably not practical to do this, though.
19:30:35 <bms1> shachaf: I think the best answer to something like that is to go back before you even make the list; and think of it more as a stream instead
19:30:44 <nshepperd> what if you did: let a = foo hugelist; b = bar hugelist in a `par` (a,b)
19:31:06 <merijn> nshepperd: Still keeps the entire list in memory
19:31:16 <merijn> nshepperd: The problem is wanting to consume hugelist in constant memory
19:31:29 <nshepperd> does it?
19:31:56 <merijn> nshepperd: Yes, hugeList can't be GCed in a streaming way
19:32:05 <merijn> nshepperd: Since another function has a live reference
19:32:10 <nshepperd> I'd hope that if foo and bar both traverse the list once, then doing both in parallel should allow the gc to collect the heads as they go
19:32:14 <merijn> not 100% sure, but still
19:32:54 <shachaf> nshepperd: For one, that won't work when you're running your program on one core.
19:33:24 <nshepperd> yes, I'd assume it does nothing if ghc doesn't allocate two threads in the first place
19:33:54 <bms1> The best way to duplicate the list is to go back to when you create the list, and have foo and bar each ask that function to create that list
19:34:30 <bms1> which is basically what merijn said previously I guess
19:36:37 * hackagebot file-location 0.4.5.3 - common functions that show file location information  http://hackage.haskell.org/package/file-location-0.4.5.3 (GregWeber)
19:36:40 * hackagebot data-util 0.4 - utilities for handle data  http://hackage.haskell.org/package/data-util-0.4 (KatsutoshiItoh)
19:40:42 <haasn> Is par equal to seq or pseq?
19:40:45 <haasn> I guess seq
19:40:49 <haasn> (Or neither?)
19:41:20 <nshepperd> I guess it really has to be (a `par` b) `seq` (a,b) or something, so that both evaluations happen at the same time. it's fragile though, I suppose
19:41:38 * hackagebot twentefp-websockets 0.1.0.0 - A fork of the popular websockets package. It is used for the practical assignments of the University of Twente. A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/twentefp-websockets-0.1.0.0 (sebaslafleur)
19:41:39 <haasn> This sounds like the job for a Fold
19:41:40 * hackagebot twentefp-eventloop-graphics 0.1.0.0 - An eventloop based graphical IO system. Used as Lab Assignments Environment at Univeriteit Twente  http://hackage.haskell.org/package/twentefp-eventloop-graphics-0.1.0.0 (sebaslafleur)
19:41:42 * hackagebot twentefp-rosetree 0.1.0.0 - RoseTree type and show functions for lab assignment of University of Twente.  http://hackage.haskell.org/package/twentefp-rosetree-0.1.0.0 (sebaslafleur)
19:41:52 <shachaf> haasn: Neither, surely.
19:42:04 <shachaf> _|_ `par` x should be equal to x?
19:42:40 <haasn> Oh, right
19:42:43 <nshepperd> yeah, if it's a normal list, you would ideally be able to to express your operation as a left fold and combine them applicatively
19:42:51 <haasn> `par` doesn't enforce evaluation of the left hand side at all.
19:44:28 <haasn> Has somebody written some sort of Fold applicative for some sort of generic fold (eg. recursion-schemes)?
19:44:36 <haasn> Or even just Generic
19:47:38 <merijn> haasn: Wasn't Tekmo working on some Fold type?
19:47:41 <shachaf> haasn: seq and pseq are also "equal".
19:47:59 <merijn> shachaf: In what way?
19:48:21 <haasn> shachaf: The only difference being which _|_ gets chosen?
19:48:45 <haasn> (In the case of pseq, always the left one; in the case of seq, who knows?)
19:49:18 <shachaf> Yes.
19:50:12 <shachaf> I am the Cat who walks by himself, and all _|_s are alike to me.
19:53:39 <cgag> ghc-mod + syntastic, by way of haskell-vim-now, is giving me this error on all my imports:   Bad interface file: /usr/lib/ghc-7.8.3/base-4.7.0.1/Data/Monoid.hi mismatched interface versions (wanted 7082 got 7083), anyone seen this or know how to fix it?
20:02:32 * haasn .oO( id :: Void -> Void )
20:06:43 * hackagebot magma 0.3.0.0 - magma is an algebraic structure consisting a set together with an binary operation.  http://hackage.haskell.org/package/magma-0.3.0.0 (KatsutoshiItoh)
20:07:39 <Lola22>  Hi! I give you some videos. I hope you like! http://tinyurl.com/ozfvxy3
20:08:58 --- mode: ChanServ set +o johnw
20:08:59 --- mode: johnw set +b *!~Lola21@95.141.27.41
20:08:59 --- kick: Lola22 was kicked by johnw (Kicked)
20:08:59 --- mode: johnw set -o johnw
20:09:25 <kristof> Someone set this channel to +r
20:09:31 <merijn> kristof: Why?
20:09:46 <kristof> There's no good reason to let unregistered users be voiced!
20:09:54 <joelteon> I can think of one
20:09:56 <merijn> kristof: I and many others disagree
20:10:26 <merijn> People who stumble into haskell IRC from #tryhaskell/etc. should be able to ask questions without needing to know or understand IRC
20:10:50 <kristof> Okay, that's probably true.
20:11:02 <merijn> Blocking the 1 person every half day that posts a spam message isn't worth ruining that
20:11:11 <merijn> Especially given the responsiveness of mods, etc.
20:11:12 <kristof> I suppose so.
20:11:44 * hackagebot pcap-enumerator 0.5 - Convert a pcap into an enumerator.  http://hackage.haskell.org/package/pcap-enumerator-0.5 (KatsutoshiItoh)
20:12:47 <nshepperd> hmm, catamorphisms are interesting
20:13:00 <vanila> nshepperd, Yeah
20:14:17 <nshepperd> it looks like a generalisation of a foldr though? is it possible to make them streaming?
20:14:53 <merijn> nshepperd: We only have like fifteen billion versions of streaming libraries these days ;:)
20:15:16 <johnw> one library to stream them all, and in the darkness >>= them
20:16:06 <merijn> Is there a convenient to have TH generate part of an export list?
20:21:03 <dfeuer> kristof, there are people (as in several of them, I believe) who regularly hang out in this channel and who have the authority to kill and ban someone from all of Freenode. Don't worry too much about the occasional spammer....
20:21:38 <merijn> Relatedly, is there a way to avoid defining two datatype every single time I want to define an enumeration and type-tagged version of said enumeration?
20:22:27 <merijn> i.e. right now I have "data Foo = Bar | Baz | Quux" and "data TaggedFoo :: Foo -> * where TBar :: TaggedFoo Bar; TBaz :: TaggedFoo Baz; TQuux :: TaggedFoo Quux"?
20:22:54 <johnw> merijn: you could look at the way singletons used to do type lifting
20:23:04 <johnw> merijn: I bet the basic TH code is very similar
20:23:31 <merijn> johnw: Oh, I can figure out how to write that using TH, but I was wondering if there was a way to not need two datatypes
20:23:39 <johnw> ah
20:23:47 <johnw> use Data.Tagged
20:24:18 <merijn> No, doesn't work
20:24:20 <johnw> then you'd have Foo and Tagged Foo
20:24:28 <merijn> That'd just be like "Proxy Bar", no?
20:24:37 <merijn> i.e. I can't pattern match on different cases
20:25:04 <johnw> it's not just like Proxy
20:25:12 <johnw> it carries a phantom
20:25:25 <johnw> newtype Tagged s b = Tagged b
20:25:37 <johnw> Proxy drops the 'b' on both sides
20:25:47 <merijn> oh, wait, hmm
20:26:14 <merijn> You mean "Tagged Bar Foo" where the value inside is Bar?
20:26:19 <merijn> That's not good enough
20:26:24 <johnw> the value inside would be of type Foo
20:26:29 <johnw> Bar would be the discriminator
20:26:40 <johnw> like, Tagged n Foo is different from Tagged (Succ n) Foo
20:26:48 <johnw> even if they hold the same Foo
20:26:49 <merijn> johnw: That won't work in my code because GHC can't prove that "Tagged Bar Foo" contains Bar
20:27:01 <johnw> it wouldn't contain Bar
20:27:15 <merijn> johnw: It has to, else how can I branch based on the tag?
20:27:32 <johnw> can you give me a code sample to play with?
20:27:34 <merijn> The reason I have TaggedFoo is to be able to branch based on type level tags
20:28:20 <merijn> johnw: Basically this: http://lpaste.net/110431
20:28:51 <merijn> johnw: Matching on SRead lets me determine that the tag is 'Read, fixing the right hand side of = to be "OpType 'Read"
20:29:22 <merijn> johnw: So different tags can return different types, because GHC can prove that the enum correspond to a type level tag
20:29:23 <johnw> right
20:29:37 <merijn> It's just really cumbersome to duplicate the type/GADT tag every time
20:29:39 <johnw> that's a GADT feature
20:29:48 <johnw> not sure Tagged will help you, since it's just a plain newtype
20:29:58 <merijn> johnw: I'm pretty sure it won't help me :)
20:30:22 <merijn> I think I'm running into "Haskell is not actually a dependently typed language" again :)
20:31:53 <jle`> whoa nobody told me this when i signed up
20:32:09 <merijn> jle`: :)
20:32:14 <merijn> Time to install Idris ;)
20:32:18 <jle`> i'm out, guys
20:32:23 <johnw> parts of ICFP were about making Haskell more dependently typed :)
20:32:50 <merijn> johnw: I know, I saw the tweet of Wadler's remark to Stephanie ;)
20:33:17 <merijn> I was sad I couldn't be there :\
20:33:33 <johnw> i know, you should have been!  lots of people from OPLSS were there
20:33:37 * jle` decides to stick around for a while
20:33:51 * tabemann wants to try out Idris
20:34:02 <merijn> johnw: No one was paying for me to go there and I don't think Oracle would've given me the time to go anyway
20:34:51 <merijn> johnw: Yeah, Agata told me George is actually the person fixing my current GHC problem :p
20:34:58 <tabemann> the problem with dependently typed languages for me, though, is that I couldn't prove my way out of a wet paper bag, and from all appearances using them requires proving things a lot
20:35:28 <johnw> tabemann: that, or designing your types so that the properties you care about are implied by construction
20:35:41 <merijn> tabemann: Well, you need to realise that Coq and Agda were really designed to be theorem provers first and not really programming languages in the traditional sense
20:35:55 <zwer_> wht about Idris?
20:35:59 <tabemann> merijn: hence my interest in Idris
20:36:04 <merijn> tabemann: Idris on the other hand is designed to be practical programming language first, theorem prover second
20:36:07 <merijn> zwer_: ^^
20:36:24 <merijn> They're also explicitly targeting existing haskellers as target audience
20:36:38 <merijn> So it should be significantly easier to learn/work with Idris
20:37:22 <merijn> Once you start abusing DataKinds/GADTs/TypeFamilies/KitchenSink a proper dependent language will probably quickly be easier :)
20:37:55 <tabemann> merijn: that's the impression I get, actually
20:38:02 <merijn> It's true
20:38:19 <merijn> Lots of things become complicated just because haskell doesn't natively support some things
20:38:42 <merijn> i.e. look at my earlier code sample, it's mostly a hack to work around haskell's inability to use values at the type level
20:41:16 <merijn> tabemann: DT printf in idris: https://www.youtube.com/watch?v=fVBck2Zngjo
20:41:41 <tabemann> it seems to me you can't really embed nontrivial data at the type level in Haskell, with you being limited to simple things like data Zero ; data Succ a ; etc.
20:42:22 <Hodapp> hasochism!
20:42:43 <merijn> tabemann: You can do more interesting things
20:42:56 <merijn> tabemann: The biggest problem is actually the inability to depend on actual input
20:43:14 <merijn> tabemann: With type families and DataKinds you can do a lot better than "data Zero; data Succ a"
20:44:08 <merijn> tabemann: i.e. https://gist.github.com/merijn/39dc86e345e87276c523
20:44:26 <merijn> tabemann: The biggest problem is (for example) that you can't index that Vector using a normal Int
20:45:43 <merijn> Because you can't really lift an Int to the type level without a lot of ugly hacks
20:47:29 <tabemann> yeah
20:52:29 * tabemann isn't used to the idea of calling functions in types
20:52:44 <merijn> tabemann: Means you need to use more TypeFamilies ;)
20:52:56 <merijn> I recommend the "Fun with Type Functions" paper as remedy
20:57:15 <tabemann> okay, I'm gonna get to bed now
20:57:26 <tabemann> will read that paper when I get the chance
21:01:55 <redtricycle> http://lpaste.net/110694 How do I fix the error 'Couldn't match type [] with IO'?
21:02:13 <redtricycle> Line 28
21:02:28 <redtricycle> trying to print (0, "line1") (1, "line2") etc
21:02:54 <tranma> anyone knows pipes-parse and pipes-aeson? I'd like to build an incremental json parser that has to hold on to several pieces of input until it can successfully parse, or perhaps encounter a particular input that triggers failure
21:03:04 <tranma> should I slap a state on top of decode in https://hackage.haskell.org/package/pipes-aeson-0.4.1.1/docs/Pipes-Aeson-Unchecked.html?
21:04:11 <merijn> redtricycle: You're trying to use <- for something that is not an IO action, you probably just want let
21:04:40 <merijn> redtricycle: Or even simpler, why not "let parsedEnty = zip [0..] (lines contents)"?
21:05:03 <merijn> tranma: You probably don't want to layer StateT on top of parser, it doesn't play well with Parser's Rank2Type
21:05:28 <redtricycle> Ah, im getting closer, yeah
21:05:34 <redtricycle> still don't fully understand <- vs let/=
21:05:39 <redtricycle> in the IO monad
21:05:47 <merijn> tranma: What does "hold on to several pieces of input until it can succesfully parse" mean?
21:06:40 <merijn> redtricycle: I personally tend to recommend not using do-notation until you understand what it's doing. "do { x <- foo; bar x }" gets desugared into: "foo >>= \x -> bar x"
21:06:53 <merijn> Now, if we look at the type of >>= we see
21:06:56 <merijn> :t (>>=)
21:06:57 <lambdabot> Monad m => m a -> (a -> m b) -> m b
21:07:20 <merijn> If we putty on our fuzzy glasses we can read that as "(>>=) :: IO a -> (a -> IO b) -> IO b"
21:08:07 <merijn> So it wants "foo" to be something with type "IO a", but in your earlier example, "zip [0..] rawEntry" actually has type "[(Int, String)]"
21:08:18 <merijn> So it's complaining "hey, a list is not an IO value!"
21:09:04 <merijn> redtricycle: "let foo = x" on the other hand just defines that "foo" now refers to the expression "x"
21:09:30 <merijn> redtricycle: Actually, it could even be simpler and skip the let entirely
21:10:12 <merijn> redtricycle: And I see another issue, parsedEntry is [(Int, String)], but unlines wants [String]
21:10:17 <jle`> redtricycle: how i see it is: in a do block, if you have an IO a, and you want to name the 'a', use <-.  If you have an a, and you want to name the a, use let.
21:11:19 <redtricycle> merijn: ya, im working through that too...
21:11:24 <redtricycle> Making a "stringify" with
21:11:45 <redtricycle> stringify x = show (fst x) ++ " " ++ show (snd x)
21:11:54 <redtricycle> and working through those issues, hm
21:12:37 <merijn> redtricycle: I'd recommend "stringify (i, s) = show i ++ " " ++ s" :)
21:12:58 <merijn> Pattern matching is almost always nicer than things like fst/snd
21:13:06 <merijn> Additionally, 's' is already a String :)
21:13:47 <lpaste> merijn annotated “Couldn't match type '[]' with 'IO'” with “Couldn't match type '[]' with 'IO' (annotation)” at http://lpaste.net/110694#a110696
21:13:57 <merijn> One big pipeline mode :)
21:14:36 <merijn> In reality that'd probably be nicer with some more local definitions, rather than having everything in one big line, but I'm lazy
21:15:06 <redtricycle> that worked, thanks merijn
21:15:26 <redtricycle> I like the map
21:16:10 <merijn> redtricycle: Try and see if you know the types of all the parts in the pipeline
21:17:24 <tranma> merijin: something like the partial result in attoparsec. So I think I want a `https://hackage.haskell.org/package/pipes-parse-3.0.2/docs/Pipes-Parse.html#t:Parser https://hackage.haskell.org/package/bytestring-0.10.0.2/docs/Data-ByteString.html#t:ByteString m (https://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#t:Maybe (https://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Either.html#t:Either https://hackage.h
21:17:32 <tranma> oops, sorry
21:17:34 <tranma> html paste
21:19:30 <merijn> tranma: I'm pretty sure pipes-aeson already does that
21:19:40 <merijn> In fact, that's the entire point of pipes-aeson :)
21:20:53 <merijn> tranma: Can you expain me what you think is wrong with the current pipes-aeson things?
21:22:25 <merijn> Okay, obscure GHC runtime trivia question time: What happens if I throw an exception to a thread that's die already? Is that just a no-op?
21:23:14 <joelteon> What else would it do?
21:23:28 <solatis> just a quick noob question about Haskell's syntax. consider this function declaration and definition:
21:23:33 <solatis>                        toInt            :: String -> Int
21:23:34 <solatis>                        toInt            = read
21:23:36 <slack1256> is it sent to the main thread that reaps it?
21:23:50 <solatis> is there any way to get the declaration and definition in 1 line?
21:24:05 <shachaf> Use a semicolon.
21:24:12 <solatis> as in, provide the type I want to have to `read` without explicitly declaring the return type?
21:24:26 <slack1256> toInt a = (read a) + (0 :: Int)
21:24:33 <merijn> solatis: How would you provide it without explicitly declaring it?
21:24:37 <shachaf> I would call that the type signature and the definition, or something. It's pretty different from e.g. "int toInt(string);" in C.
21:24:42 <shachaf> Oh.
21:24:48 <solatis> merijn: well i would think about casting or something
21:24:53 <merijn> solatis: You could let it be inferred, but...
21:24:55 <shachaf> toInt = read :: String -> Int
21:25:02 <shachaf> toInt x = read x :: Int
21:25:05 <shachaf> Something like that.
21:25:15 <solatis> shachaf: let me try that!
21:25:15 <shachaf> That's not "casting", though.
21:25:24 <merijn> solatis: Haskell doesn't have casts*
21:25:32 <merijn> * - well, maybe a little, kinda, sorta
21:25:41 <slack1256> has coercions and even those are hiden
21:25:42 <merijn> But not in a way useful to beginners :)
21:25:51 <merijn> slack1256: No, we have cast too :)
21:26:01 <solatis> yeah i know, this is not casting, it's type inference, right?
21:26:02 <merijn> > cast 1 :: Maybe Char
21:26:04 <lambdabot>  Nothing
21:26:07 <merijn> > cast 1 :: Maybe Int
21:26:08 <lambdabot>  Nothing
21:26:12 <merijn> oh
21:26:15 <shachaf> (a :: T) is a type annotation.
21:26:15 <slack1256> :t cast
21:26:15 <merijn> > cast 1 :: Maybe Integer
21:26:16 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
21:26:16 <dfeuer> I've seen the word `cast` show up in Core, but never known what it is.
21:26:16 <lambdabot>  Just 1
21:26:42 <merijn> dfeuer: In core it's just either unsafeCoerce or asTypeOf, I think
21:26:43 <shachaf> It's the opposite of inference.
21:27:00 <shachaf> Fortunately the GHC Commentary documents exactly what it means.
21:27:19 <merijn> shachaf: But reading is hard! ;)
21:27:22 <dfeuer> I may need to refrain from suppress-all to see anything useful about it, now that I think about it.
21:27:52 <shachaf> There's also a paper, which the GHC commentary links to.
21:28:17 <solatis> merijn: well let's just say that it takes a while when you're able to properly navigate your way in all the haskell documentation
21:28:40 <shachaf> It's neither unsafeCoerce nor asTypeOf. It takes an argument containing evidence.
21:29:54 <solatis> anyway this fixed my 'problem', thanks shachaf
21:29:57 <solatis> (and merijn)
21:30:05 <merijn> Ok, so it's unsafeCoerce with evidence that it's a safe unsafe :p
21:31:55 * hackagebot Chart 1.3.1 - A library for generating 2D Charts and Plots  http://hackage.haskell.org/package/Chart-1.3.1 (TimDocker)
21:31:57 * hackagebot Chart-cairo 1.3.1 - Cairo backend for Charts.  http://hackage.haskell.org/package/Chart-cairo-1.3.1 (TimDocker)
21:31:59 * hackagebot Chart-gtk 1.3.1 - Utility functions for using the chart library with GTK  http://hackage.haskell.org/package/Chart-gtk-1.3.1 (TimDocker)
21:32:01 * hackagebot Chart-diagrams 1.3.1 - Diagrams backend for Charts.  http://hackage.haskell.org/package/Chart-diagrams-1.3.1 (TimDocker)
21:32:23 <dfeuer> shachaf, are you talking about the whole Coercible mechanism? I skimmed the paper.
21:32:41 <jle`> solatis: ideally, in real code, you would eventually use the read value in a way that its desired type is unambiguous
21:32:50 <jle`> > read "1" + 4
21:32:52 <lambdabot>  5
21:32:56 <shachaf> @google coresyntype
21:32:56 <lambdabot> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType
21:33:00 <merijn> Ideally in real code you wouldn't use "read" :)
21:33:01 <dfeuer> That's still ambiguous.
21:33:06 <jle`> merijn: that too :P
21:33:13 <merijn> readMaybe <3
21:33:15 <dfeuer> read was a mistake in the standard.
21:33:24 <merijn> Actually, don't even use readMaybe in real code
21:33:30 <dfeuer> reads?
21:33:40 <merijn> dfeuer: reads is readMaybe, but suckier
21:33:41 <zwer_> merijn why not?
21:33:44 <dfeuer> Or do you just write your own parsers?
21:33:50 <dfeuer> :t reads
21:33:51 <lambdabot> Read a => ReadS a
21:33:51 <solatis> jle`: sounds like that is somewhat related to the whole 'lazy' approach to these problems?
21:33:53 <merijn> zwer_: The performance is abysmal
21:34:15 <merijn> zwer_: For anything "real" you'll want to use a proper parser library
21:34:23 <jle`> solatis: it's not quite laziness, actually
21:34:27 <jle`> if that's what you mean
21:34:33 <solatis> compile-time laziness :)
21:34:39 <jle`> :P
21:34:41 <solatis> but i know what you mean
21:34:42 <dfeuer> > reads "123 456 789 101112" :: [(Int, String)]
21:34:44 <lambdabot>  [(123," 456 789 101112")]
21:34:58 <jle`> actually type inference is a lot like a giant constraint solving problem
21:35:05 <merijn> > Text.Read.readMaybe "123 456 789 101112" :: Maybe Int
21:35:07 <lambdabot>  Not in scope: ‘Text.Read.readMaybe’
21:35:09 <merijn> aww
21:35:14 <merijn> :t Text.Read.readMaybe
21:35:15 <lambdabot> Read a => String -> Maybe a
21:35:22 <merijn> @import Text.Read
21:35:22 <lambdabot> Unknown command, try @list
21:35:23 <solatis> yeah i'm actually quite impressed by haskell's ability to 'understand what i want to do'
21:35:29 <merijn> @define import Text.Read
21:35:31 <lambdabot>  Defined.
21:35:34 <merijn> > Text.Read.readMaybe "123 456 789 101112" :: Maybe Int
21:35:36 <lambdabot>  Nothing
21:35:56 <jle`> what the
21:36:03 <jle`> you can just drop an import into L.hs?
21:36:06 <merijn> > Text.Read.readMaybe "123" :: Maybe Int
21:36:07 <lambdabot>  Just 123
21:36:15 <merijn> jle`: Only for Safe modules, but sure
21:36:23 <dfeuer> merijn, am I missing something or is reads ... utterly silly?
21:36:34 <merijn> dfeuer: reads is a basic building block
21:36:36 <jle`> i think reads is used in the implementation of read
21:36:44 <merijn> dfeuer: But it sucks for actually using
21:36:56 * hackagebot Chart-simple 1.3.1 - A wrapper for the chart library to assist with basic plots (Deprecated - use the Easy module instead)  http://hackage.haskell.org/package/Chart-simple-1.3.1 (TimDocker)
21:37:10 <dfeuer> I guess it's better than readMaybe for working within a listy context?
21:37:23 <merijn> zwer_: Anyway, for "real" code you probably want to use either binary or attoparsec as they're orders of magnitude faster then read
21:37:48 <merijn> Carefully written attoparsec parsers can perform close to hand-rolled C parsers
21:38:44 <solatis> yeah but performance is not a real issue here
21:38:50 <solatis> but i understand
21:39:39 <merijn> solatis: Yeah, for playing around read is okay, but you should probably use readMaybe
21:39:52 <merijn> > readMaybe "123" :: Maybe INt
21:39:53 <lambdabot>  Not in scope: type constructor or class ‘INt’
21:39:53 <lambdabot>  Perhaps you meant ‘Int’ (imported from Data.Int)
21:39:55 <merijn> > readMaybe "123" :: Maybe Int
21:39:57 <lambdabot>  Just 123
21:39:59 <merijn> > readMaybe "123" :: Maybe Char
21:40:00 <lambdabot>  Nothing
21:40:08 <merijn> > read "123" :: Int
21:40:09 <lambdabot>  123
21:40:12 <merijn> > read "123" :: Char
21:40:13 <lambdabot>  *Exception: Prelude.read: no parse
21:40:29 <merijn> solatis: Read throws exceptions that are tricky to handle :)
21:40:40 <jle`> and who likes partial functions anyway
21:40:44 <jle`> not i
21:40:51 <solatis> yeah i have to switch my mind towards using Maybe more and relying less on Exceptions
21:41:12 <frustrated> aargghh... can anyone help me install wreq on windows 7?
21:41:29 <solatis> i just have this habit on just using exceptions as assertions in these cases and not handling them
21:41:48 <jle`> solatis: Maybe is not too hard at all to work with if you take advantage of its Functor, Applicative, and Monad instances that sort of let you treat Maybe values as if they were "normal" values
21:42:15 <jle`> with the proper abstractions, you might not even realize it's there :)
21:42:26 <frustrated> i386-windows-ghc-7.8.3\network-2.5.0.0\HSnetwork-2.5.0.0.o: unknown symbol `_shutdownWinSock'
21:42:48 <solatis> haha yeah, and in my case i would probably abuse fromJust :p
21:42:55 <slack1256> What do they mean when people say typeclasses are global?
21:43:04 <slack1256> that the instance are always imported?
21:43:06 <solatis> but that's not a proper abstraction
21:43:17 <slack1256> *instances
21:43:19 <jle`> heh :)
21:43:38 <merijn> solatis: Don't use fromJust, use fromMaybe/maybe
21:43:40 <merijn> :t fromMaybe
21:43:41 <lambdabot> a -> Maybe a -> a
21:43:43 <merijn> :t maybe
21:43:43 <lambdabot> b -> (a -> b) -> Maybe a -> b
21:44:00 <solatis> merijn: what's your rationale?
21:44:01 <merijn> slack1256: That you can't hide typeclasses from other parts of the program
21:44:03 <jle`> slack1256: a given type can only have one instance, globally
21:44:09 <solatis> :t fromJust
21:44:10 <lambdabot> Maybe a -> a
21:44:13 <merijn> solatis: fromMaybe/maybe doesn't crash :)
21:44:14 <solatis> :t fromMaybe
21:44:15 <lambdabot> a -> Maybe a -> a
21:44:17 <jle`> solatis: those alternatives are total :)
21:44:24 <merijn> > fromMaybe 1 Nothing
21:44:25 <lambdabot>  1
21:44:29 <merijn> > fromMaybe 1 (Just 2)
21:44:30 <lambdabot>  2
21:44:36 <lenage`> :t fromMaybe
21:44:37 <lambdabot> a -> Maybe a -> a
21:45:00 <merijn> > maybe 1 ord (Just 'c')
21:45:01 <slack1256> Oh that I can always import from everywhere in the program. Yep that is non modular
21:45:01 <lambdabot>  99
21:45:07 <merijn> > maybe 1 ord Nothing
21:45:07 <slack1256> but is there any other way?
21:45:08 <lambdabot>  1
21:45:29 <merijn> slack1256: In any program there can only be a single instance of a typeclass Foo for type Bar
21:45:30 <jle`> slack1256: you can reify them as method dictionaries
21:45:41 <merijn> slack1256: This includes all other libraries, etc. used inside the program
21:45:52 <dpn`>  wreq looks cool
21:45:55 <slack1256> hence the use of newtype
21:46:08 <frustrated> wreq looks cool but it doesn't install under windows
21:46:08 <slack1256> jle`: that is what tekmo propose as scrap 'em
21:46:12 <dpn`> first thought was "looks like requests" .. then saw he actually refers to it heh
21:46:33 <jle`> you might have noticed that if you wrote foo :: Eq a => [a] -> [a], for example, it would be identical in functionality to foo :: (a -> a -> Bool) -> [a] -> [a]
21:46:58 <jle`> yeah, that's a good overview of this
21:47:15 <frustrated> network which is a dependency builds
21:47:17 <frustrated> but then we get
21:47:19 <frustrated> AppData\Roaming\cabal\i386-windows-ghc-7.8.3\network-2.6.0.2\HSnetwork-2.6.0.2.o: unknown symbol `_shutdownWinSock'
21:47:22 <jle`> in the alternative foo, your 'a' can basically have "any Eq instance"...any comparison function
21:47:33 <solatis> where's readMaybe defined? hoogle seems to fail
21:47:34 <frustrated> even google doesn't help me
21:47:43 <merijn> solatis: Text.Read
21:47:55 <slack1256> but you have to pass it manually
21:48:04 <merijn> I forgot whether it appeared in 7.6 or 7.8?
21:48:09 <frustrated> i just want it to work out of the box... even java can do that
21:48:23 <slack1256> I remember agda did some funny with typeclasses
21:48:31 <slack1256> it parametriced by them?
21:48:45 <slack1256> or I am remembering gibberish
21:51:43 <merijn> frustrated: How did you install the network package?
21:51:55 <merijn> frustrated: Did you just install Haskell Platform?
21:52:39 <frustrated> yes, it was a fresh install of haskell platform
21:52:58 <frustrated> i installed network thru cabal, had to do force-reinstall
21:53:38 <frustrated> using cygwin... and setting compiler path to the ghc one (export PATH="/cygdrive/.../ghc-7.8.2/mingw/bin:$PATH" )
21:54:46 <merijn> oh...
21:54:53 <merijn> frustrated: NEVER do force-reinstall
21:55:05 <merijn> It only ends in tragedy
21:55:17 <joelteon> I definitely get mixed messages about force-reinstalls
21:55:23 <merijn> Big chance your best bet is to delete the entire platform and reinstall
21:55:35 <merijn> joelteon: Really? Who told you they were *ever* a good idea?
21:55:47 <frustrated> what's the option apart from force-reinstall
21:55:55 <merijn> joelteon: The reason cabal hell existed was that cabal would silently use "force-reinstalls"
21:56:14 <frustrated> i've reinstalled once already...
21:56:18 <merijn> frustrated: Unregister everything that depends on the package you need to upgrade and manually installed them
21:56:26 <frustrated> so i use cabal sandbox?
21:56:31 <frustrated> ok
21:56:54 <merijn> frustrated: force-reinstalls will just hard upgrade the pacakge and anything that happens to depend on your package better cross it's fingers it will still link
21:56:58 * hackagebot kan-extensions 4.1.0.1 - Kan extensions, Kan lifts, various forms of the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-4.1.0.1 (EdwardKmett)
21:57:34 <joelteon> merijn: The other half of the mix was me doing it anyway
22:03:13 <merijn> I think cabal should output it's "will break your shit" warning for force-reinstalls in like bright red or something...
22:04:29 <solatis> damn, hlint really is merciless
22:04:40 <nitrix> I don't know. "Force" is already quite explicit that its to your own risk.
22:04:46 <BMeph> Mercy is fior the Weak!
22:05:01 <solatis> i just like to use parenthesis more than hlint seems to like them...
22:07:19 <nitrix> Games in haskell looks like a pain.
22:09:33 <merijn> solatis: hlint is pretty aggressive in getting rid of parenthesis :)
22:10:49 <solatis> merijn: yeah, i trust hlint in having a good rationale behind it so i adhere to its laws :p
22:13:05 <jle`> sometimes i like leaving parentheses in types with multiple parameters
22:14:13 <prog1232> what would cause me to get the error Could not deduce (Ord b) arising from a use of `add'     from the context (Ord a)
22:14:37 <jle`> prog1232: can you offer some code? :)
22:14:54 <jle`> first guess might be a scoped type variables thing
22:15:10 <jle`> but it's hard to say without code
22:20:21 <dfeuer> solatis, hlint has some pretty stupid things to say sometimes. What it claims to be "redundant lambdas" usually are there for a reason. And its penchant for asking you to eta-reduce everything is a bit obnoxious.
22:22:11 <shachaf> I think asking people to eta-reduce is a good default.
22:22:17 <shachaf> You can turn it off if you like.
22:23:46 <dfeuer> Redundant lambdas, though? Come now. If I say foo x y = \z -> e  then dammit, that's what I mean! Either I think it's easier to understand that way or I want to manipulate saturation.
22:26:54 <dfeuer> shachaf, I'd be much happier if it would recognize zipWith, foldr, foldl, foldM, mapM, etc., forms and suggest them—I've found two spots in the GHC source so far that are clarified by using zipWith and foldM.
22:27:15 <dfeuer> Sorry. Not foldM.  mapAccumL.
22:27:20 <shachaf> Feel free to add that.
22:27:31 <shachaf> I think mapAccumL might be a little overrated.
22:28:26 <dfeuer> Maybe so, but rewriting a six or seven line thing to one line that makes it more obvious what's going on is a plus.
22:30:02 <prog1232> jle` I messaged you some of my code
22:30:14 <jle`> prog1232: you can always lpaste :)
22:30:16 <dfeuer> shachaf, https://ghc.haskell.org/trac/ghc/attachment/ticket/9529/CSE.diff
22:30:43 <lispy> I never think to use mapAccumL. I usually just use a fold.
22:32:26 <jle`> prog1232: what's the type signature for 'add'?
22:32:39 <jle`> and treeLookup
22:33:17 <prog1232> add :: Ord a => a -> BST a -> BST a
22:33:24 <prog1232> treeLookup :: Ord a => a  -> BST (a,b) -> Maybe b
22:34:24 <prog1232> treeLookup :: Ord a => a  -> BST (a,b) -> Maybe b
22:34:43 <prog1232> ^sorry didn't mean to double paste
22:35:10 <jle`> prog1232: if that's the case, then you are passing in (a, b) into add
22:35:38 <jle`> and a tuple's Ord instance requires that both fields be Ord
22:37:04 * hackagebot hOpenPGP 1.5.2 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-1.5.2 (ClintAdams)
22:37:06 * hackagebot hydrogen-prelude 0.1.1 - Hydrogen Prelude  http://hackage.haskell.org/package/hydrogen-prelude-0.1.1 (JulianFleischer)
22:37:11 <prog1232> jle` thank you!
22:37:17 <jle`> np! hope it helped
22:41:16 * dfeuer tried to make add::y->o->m->a->m->a  but couldn't figure out a way to do it for some reason (fatigue, probably)
22:42:04 * hackagebot hydrogen-prelude 0.2 - Hydrogen Prelude  http://hackage.haskell.org/package/hydrogen-prelude-0.2 (JulianFleischer)
22:44:38 <frustrated> merijn: thanks for your help... i uninstalled and cabal installed from the beginning, but end up with the same error
22:44:51 <frustrated> merijn: no force reinstalls this time
22:46:47 <merijn> What exactly are you installing and what's the error?
22:47:56 <frustrated> merijn: I'm installing wreq, and the error is: "AppData\Roaming\cabal\i386-windows-ghc-7.8.3\network-2.6.0.2\HSnetwork-2.6.0.2.o: unknown symbol `_shutdownWinSock'"
22:48:28 <merijn> That doesn't provide a lot of context
22:48:42 <merijn> Try installing with "cabal -v3" and paste the output on lpaste
22:51:59 <frustrated> merijn: i've just tried in a cabal sandbox (that should be on a clean slate, right?)... cabal install wreq... and it ends up with that error
22:52:14 <merijn> frustrated: Run cabal install with -v3
22:52:21 <merijn> And then lpaste the output
22:52:30 <merijn> Because a missing symbol error is not really useful
22:56:07 <L8D> Haskell has vectors right?
22:56:18 <merijn> L8D: Yes
22:56:24 <L8D> merijn: in what form?
22:56:35 <merijn> eh, in Vector form?
22:56:42 <merijn> What's that question mean?
22:56:47 <L8D> :t Vector
22:56:48 <lambdabot> Not in scope: data constructor ‘Vector’
22:57:04 <merijn> @hackage vector
22:57:04 <lambdabot> http://hackage.haskell.org/package/vector
22:57:32 <L8D> And these are the "efficient addition at the end" vectors?
22:57:38 <merijn> No
22:58:07 <shachaf> :t isn't a magical "tell me things about this symbol" operation
22:58:14 <L8D> oh so their "list of arbirary types" vectors?
22:58:25 <L8D> shachaf: I know, I should use :i
22:58:32 <L8D> but lambdabot doesn't have :i
22:58:36 <merijn> :i isn't a magical one either
22:58:37 <L8D> :i List
22:58:45 <merijn> List is not a type anyway
22:58:50 <L8D> I know...
22:59:01 <TwoPoint7182818> Which operation is the magical one?
22:59:07 <merijn> And I don't know what a "list of arbitrary types vectors" are either
22:59:12 <merijn> TwoPoint7182818: There is no magic
22:59:38 <L8D> merijn: the 'vector' package is for using lists with elements that have different types
22:59:49 <shachaf> That's not true.
22:59:49 <merijn> eh, no it isn't
23:00:04 <merijn> Where did you get that idea?
23:00:46 <L8D> "Boxed vectors of arbitrary types."
23:00:59 <merijn> That's not what that means at all
23:01:23 <merijn> "data [] a" is "a list of arbitrary types"
23:01:23 <L8D> oh...
23:01:27 <L8D> derp I'm a fucking idiot
23:04:15 <jle`> not an idiot :D
23:06:38 <bitemyapp> L8D: your wording was ambiguous. You meant heterogenous and vector is homogenous. When people want heterogenous collections usually they want HList.
23:07:07 * hackagebot persistent 2.0.2 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-2.0.2 (MichaelSnoyman)
23:07:09 * hackagebot persistent-template 2.0.2 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-2.0.2 (MichaelSnoyman)
23:08:05 <merijn> What's the best type for an "IO ()" that needs to signal error?
23:08:19 <merijn> "IO (Either String ())" feels silly, somehow
23:08:30 <bitemyapp> merijn: that's not silly and don't use strings.
23:08:31 <merijn> But exceptions are bad
23:08:38 <bitemyapp> merijn: use Either with a real datatype, not String.
23:08:49 <merijn> bitemyapp: String is just an example
23:08:55 <bitemyapp> merijn: use Either.
23:08:58 <bitemyapp> merijn: please?
23:09:01 <bitemyapp> or EitherT?
23:09:28 <Taneb> merijn, ErrorT?
23:09:29 <bitemyapp> merijn: if you really want to elide type-noise then silent IO exceptions are an option but that makes the panda cry.
23:09:35 <bitemyapp> Taneb: ErrorT == EitherT, no?
23:09:47 <merijn> bitemyapp: I don't want exceptions, I just said
23:09:57 <merijn> exceptions are the "alternative" API
23:10:02 <bitemyapp> merijn: Either or EitherT then.
23:10:14 <bitemyapp> http://hackage.haskell.org/package/either-3.4/docs/Control-Monad-Trans-Either.html
23:10:22 <simpson> EitherT is like ErrorT but better.
23:10:25 <bitemyapp> "EitherT is a version of ErrorT that does not require a spurious Error instance for the Left case."
23:10:27 <Taneb> bitemyapp, they've the same definition but ExceptT has the benefit that it's in mtl
23:10:42 <bitemyapp> EitherT is in either.
23:10:55 <merijn> either has some silly dependencies...
23:11:03 <bitemyapp> merijn: then use Either :P
23:11:05 <Taneb> And mtl and transformers are much more common
23:11:07 <merijn> Like monad-control
23:11:18 <Taneb> And ExceptT doesn't require the Error instance on the e
23:12:36 <merijn> hmm
23:13:00 <merijn> Actually, probably the least painful way is to just throw exceptions and then catch them into ExceptT before returning
23:16:03 <bitemyapp> merijn: do you want a stripped down EitherT?
23:16:23 <merijn> I don't have any preference
23:16:42 <bitemyapp> merijn: well, dependencies are why you're not using either right?
23:16:48 <merijn> I just want to signal exceptions to users that don't explicitly pick the exception throwing option
23:17:04 <merijn> bitemyapp: But I might as well use ExceptT, then
23:17:08 * hackagebot hydrogen-prelude 0.2.0.1 - Hydrogen Prelude  http://hackage.haskell.org/package/hydrogen-prelude-0.2.0.1 (JulianFleischer)
23:17:13 <merijn> I already depend on mtl/transformers anyway
23:36:37 <bitemyapp> merijn: is that what you ended up doing?
23:37:13 <merijn> bitemyapp: Current plan is to just use exceptions and wrap them into ExceptT using try
23:37:28 <bitemyapp> merijn: cool.
23:46:47 <merijn> Since none here is doing anything, I've got an opinion question. I have a datatype for a network protocol that is supposed to contain 1 or more frames of ByteStrings, any preferences on how that should be modeled? Right now I'm using "data Message = Message [ByteString] ByteString"
23:48:00 <dfeuer> merijn, look at NonEmpty in edwardk's semigroup package.
23:48:40 <merijn> I'm going to use a datatype that doesn't exist in other libraries anyway
23:48:50 <merijn> Just curious what people would like as an API
23:48:58 <merijn> So using NonEmpty is out of the question anyway
23:52:05 <mauke_> http://kingjamesprogramming.tumblr.com/post/96777334879/
23:53:10 <Taneb> mauke, heh
23:53:58 <bitemyapp> merijn: why not use NonEmpty?
23:54:11 <bitemyapp> merijn: I didn't understand the objection. That's what it was made for.
23:54:19 <merijn> bitemyapp: Because NonEmpty is a terrible type for network messages
23:54:56 <bitemyapp> merijn: oh. Well, perhaps learn from the API then?
23:55:15 <bitemyapp> merijn: hrm. a final encoding of NonEmpty...
23:57:35 <merijn> I'm just wondering whether I should for example have "data Message = Foo ByteString | Bar [ByteString]" or "data Message = Message [ByteString] ByteString" or something else entirely
23:59:19 <bitemyapp> merijn: this is why I'm suggesting you look at NonEmpty.
23:59:30 <bitemyapp> merijn: to get inspiration from the API for how to represent it.
