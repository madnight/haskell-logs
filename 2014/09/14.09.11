00:02:35 <Jookia> Hello! I'm doing Typeclassopedia so this might be homework, but is "data IsInt a = Is Int | Not a" able to be a Functor?
00:03:01 <Hafydd> Jookia: yes.
00:03:17 <Hafydd> Just apply the function to the a value, if it's there, or otherwise leave it as it is.
00:03:29 <Jookia> Mmm
00:03:54 <Hafydd> But note that IsInt Int has a value Not a, where a :: Int!
00:04:42 <Jookia> Yes, I'm getting in to areas of dependent types with that, I'm just trying to find something that isn't able to be a Functor and has a kind of * -> *, so I still have to think about it
00:05:27 <shachaf> Jookia: Do you want an answer?
00:05:27 <Cale> Jookia: data Endo a = MkEndo (a -> a)
00:05:34 <shachaf> I guess you're getting one.
00:05:56 <Jookia> You're lucky just after I wrote that I wrote "data NotFunc a = NotFunc (a -> a)" in my thing
00:06:08 <shachaf> Slightly simpler is newtype Op r a = Op (a -> r)
00:06:26 <Jookia> schlumpi: That's * -> * -> * is it not?
00:06:36 <shachaf> Well, (Op r) for any r.
00:06:50 <shachaf> You can say newtype Pred a = Pred (a -> Bool) if you prefer.
00:07:15 <Jookia> Yes, I realized that as long as it can't be a -> b then it can't be a Functor
00:07:28 <shachaf> (Op r for any r except ().)
00:07:33 <shachaf> ?
00:07:34 <Jookia> Learning type classes woo! I also found that fmap is equivalent to function composition
00:08:28 <Jookia> Cale: Wait, that seems like it can be a functor
00:08:58 * hackagebot http-conduit 2.1.4.3 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-2.1.4.3 (MichaelSnoyman)
00:08:58 * hackagebot hailgun 0.1.0.2 - Mailgun REST api interface for Haskell.  http://hackage.haskell.org/package/hailgun-0.1.0.2 (RobertMassaioli)
00:11:15 <Jookia> Oh I see
00:14:25 <Jookia> Cale: Why can't that not be a Functor?
00:15:49 <jle`> Jookia: try writing an instance :)
00:16:05 <Jookia> jle`: I am, but it seems like it could be
00:16:50 <jle`> so you want to be able to take any (a -> b), and turn an (a -> a) into a (b -> b) with it
00:17:40 <jle`> @djinn (a -> b) -> (a -> a) -> (b -> b)
00:17:40 <lambdabot> f _ _ a = a
00:18:21 <Jookia> jle`: a -> a -> a -> b -> b, it seems like you could use 'id' in there
00:18:35 <Jookia> jle`: This compiles: jle`: fmap' f' (NotFunc _) = NotFunc id
00:19:24 <jle`> try going through the functor laws :)
00:19:36 <jle`> in particular, fmap id = id
00:20:10 <shachaf> But fmap id x ≠ x
00:20:20 <jle`> fmap id (Endo (+ 3)) == Endo (+ 3) -- ?
00:20:41 <shachaf> I think my example with Op or Pred is simpler. The second occurrence of a in Endo is a red herring.
00:22:08 <jle`> Jookia: fmap id (Endo (+ 3)) = Endo id, using your definition
00:22:14 <jle`> which certainly isn't Endo (+ 3) ;)
00:25:52 <jle`> although incidentally i think that fmap f . fmap g = fmap (f . g) does hold...doesn't it?  what gives?
00:26:07 <jle`> i have always heard that that functor law falls from the fmap id = id...
00:26:59 <Jookia> gah i see, it kinda made sense but you'd need a higher order function to fmap this
00:27:41 <jle`> oh i see.  i am mixing up things i can do with logical implication
00:28:16 <jle`> not P and Q is still consistent with P -> Q
00:32:05 <baconwichsand> greetings
00:33:31 <jle`> hello baconwichsand
00:33:56 <baconwichsand> I'm building an AI/machine learning engine for financial markets that is currently in Pasqual. As a long-time math person I am interestd in simplifying the mathematical aspects of the programming tasks. Has Haskell progressed to a point where it makes sense to learn and transition to the language?
00:34:10 <baconwichsand> sorry not pasqual, python
00:35:10 <jle`> i'd say yes.  from what i've heard there are plenty of internal financial companies that internally use haskell for their data science applications
00:35:50 <baconwichsand> ok, i  like how it is purely functional. other than that are their better languages than python? it seems a little slow
00:36:16 <Jookia> baconwichsand: if it's slow you should probably check your algorithms
00:36:43 <jle`> better for machine learning?
00:36:55 <baconwichsand> Jookia, yeah ive optimized that as much as possible, but this will be solved with distributing processing across various hardware
00:36:59 <tdammers> haskell is in the "more than half as fast as C" league
00:37:07 <tdammers> there are some performance caveats that can bite you
00:37:16 <baconwichsand> better for building a full-scale fintech operation
00:37:28 <tdammers> but generally speaking, it should be possible to write pretty damn fast software with it
00:37:37 <baconwichsand> ok cool
00:37:50 <Jookia> baconwichsand: if you're doing it across hardware, haskell and pure functions are good for writing parallel code
00:37:51 <jle`> i've heard some good things about julia on this front
00:37:54 <baconwichsand> i didnt realize was so fast
00:38:09 <tdammers> frankly, python isn't exactly great for parallel computing, really
00:38:15 <baconwichsand> Jookia, ok thanks thats very helpful
00:38:28 <baconwichsand> yeah im starting to realize that
00:38:30 <Jookia> i think pure functions may help with parallel computing? i'm not sure
00:38:43 <tdammers> yes, purity and parallel computing are a heavenly match
00:38:43 <baconwichsand> or recursive stuff for that matter
00:38:43 <jle`> but really, if i switched from python to haskell, performance would only be one small part of the immense benefit
00:39:05 * tdammers nods at jle`
00:39:11 <Jookia> baconwichsand: haskell provides better ideas than recursive stuff, you use folds and higher-order functions
00:39:14 <jle`> yeah, in parallel computing, immutability is a big deal :P
00:39:18 <baconwichsand> if you have a solid background in math thats all you need?
00:39:28 <jle`> not really
00:39:35 <jle`> well
00:39:43 <jle`> by that, i mean a solid background in math is not required
00:39:48 <Jookia> baconwichsand: i have no idea about maths, i think the only part of haskell that requires maths is the usage of category theory?
00:39:48 <jle`> there isn't too much required
00:40:01 <baconwichsand> Jookia, yeah ok
00:40:08 <jle`> i mean, if you're writing fintech, you're probably going to be using a lot of math for your algorithm implementations
00:40:09 <baconwichsand> well ill check it out
00:40:10 <Jookia> jle`: am i wrong on that? besides saying 'requires'
00:40:26 <jle`> i don't think that practical haskell usage requires much or any knowledge of category theory
00:40:37 <baconwichsand> yeah were all about algortihm and i/o and memeory efficiency
00:41:01 <jle`> but a maths background isn't required for haskell itself
00:41:06 <baconwichsand> ok
00:41:09 <tdammers> more important than performance, IMO, are compile-time guarantees through the type system, enormous abstractive power, painless and safe refactoring, explicit effects with fine-grained control, a very straightforward STM implementation, and a highly intelligent community
00:41:23 <jle`> maintainability is a big plus too
00:41:32 <baconwichsand> why dont you hear about it that  much ?
00:41:42 <tdammers> because that power comes at a cost
00:41:57 <jle`> you probably have heard more about haskell's contributions to the design of many of today's modern languages :)
00:42:12 <baconwichsand> yeah i just watched this https://www.youtube.com/watch?v=iSmkqocn0oQ
00:42:16 <Jookia> you have to structure your code a bit differently
00:42:24 <Jookia> specifically, side effects
00:42:43 <Zeedox> jle`: Hasn't ML had a big influcence as well?
00:42:58 <jle`> Zeedox: not mutually exclusive :)
00:43:01 <tdammers> the crux is, most of these upsides are as powerful as they are because they are non-optional
00:43:18 <tdammers> compile-time guarantees only work well because *all* code has to play along
00:43:20 <Jookia> you also don't have mutable variables or friendly imperative programming stuff, so it's a lot different
00:43:48 <baconwichsand> yeah its just straight up
00:43:51 <jle`> i don't really subscribe to the idea that haskell is inherently more difficult to understand or trickier to program than other languages
00:43:51 <baconwichsand> i like that
00:43:56 <jle`> i think it's just different
00:44:11 <Jookia> jle`: it's different
00:44:20 <jle`> and there are a bunch of anecdotal tales about how people new to programming pick up haskell faster than new people pick up, say, python
00:44:27 <jle`> and everyone knows that anecdote = evidence, so
00:44:30 <Jookia> a personal anecdote is that i've found people more likely to use functional programming when learning programming
00:44:34 <baconwichsand> the syntac probably is easier, but understanding functions and data structures is much tougher
00:45:12 <Jookia> jle`: dude i've saw someone give me a solution to project euler and it was basically functional programming in C++ (who does that?) using higher order functions in the STL
00:45:30 <Zeedox> jle`: Well, I'd say it's harder to learn than say, C.
00:45:41 <Zeedox> All the operators can be hard to look up / google.
00:45:50 <baconwichsand> hmm ok
00:45:58 <Jookia> baconwichsand: oh yeah, the >>= operator is the 'bind' operator
00:46:30 <Jookia> baconwichsand: i'm just saying, if you get in to haskell and try googling that as it doesn't have an analogous function, you're going to have a bad time :P
00:46:32 <baconwichsand> Jookia, yeah  ive been playing around with it all day, seems promising but very niche
00:46:50 <baconwichsand> Jookia, haha yeah understood
00:47:15 <baconwichsand> Jookia, less degugging tho
00:47:28 <Jookia> baconwichsand: haskell is a bit of a difficult language, and its ecosystem is a bit in flux, and the tools are a little ... different
00:47:51 <Jookia> baconwichsand: i've tried to do debugging using ghci but haven't had much success but i put that down to me doing it wrong
00:48:12 <baconwichsand> Jookia, looking forward to playing around a bit...see how it goes, will probably revert back to python
00:48:58 <Muon> does anyone know of any way to speed up List.intersect on small lists?
00:49:00 <Jookia> baconwichsand: heh. i suggest that you play with haskell until you're comfortably writing programs in it, THEN revert to python (if you want), as you learn a lot through purely functional programming
00:49:23 <Muon> it's being a major bottleneck, for some reason
00:49:35 <baconwichsand> Jookia, ok thats a good plan
00:49:40 <Muon> lots of time and allocations spent there
00:50:00 <Muon> or rather, I need the length of said intersection
00:50:18 <baconwichsand> Jookia, im trying to implement this as part of my financial markets sate analysis http://classes.yale.edu/fractals/IntroToFrac/DrivenIFS/DataIFS/DataIFS.html
00:50:32 <baconwichsand> Jookia, its awesome
00:51:27 <MagneticDuck> haskell is "niche"?
00:51:34 <Jookia> baconwichsand: if you ever implement it in haskell i'd look forward to seeing how the code compares
00:53:25 <baconwichsand> Jookia, yeah ill be posting my P\L of 200-800% here in no time
00:53:34 <Jookia> :V
00:53:36 <baconwichsand> gotta run
00:53:38 <baconwichsand> beack
00:53:49 <Jookia> ciao
01:01:37 <ph88> hey guys, im trying to do  cabal install cairo-0.13.0.0    but im getting this error     http://pastebin.com/t2cw6jNM  can someone help ?
01:04:11 <jle`> Zeedox: if anything i think haskell is much easier to learn than C :P
01:04:40 <jle`> but this is a meaningless statement without further qualification
01:21:02 <erikd> why is it that causes some haddocks not to render on the new hackage?
02:08:10 <Jookia> composition is confusing
02:12:47 <tdammers> Jookia: how so?
02:12:52 <Jookia> :\ how does composition work with variable arguments
02:12:59 <tdammers> variable arguments?
02:13:12 <tdammers> we don't really have those in haskell
02:13:27 <Jookia> the function signature confuses me
02:13:38 <Jookia> (.) :: (b -> c) -> (a -> b) -> a -> c
02:13:42 <tdammers> ah
02:13:44 <tdammers> ok
02:14:00 <tdammers> (.) f g = f . g -- you understand this much right?
02:14:07 * hackagebot blaze-markup 0.6.1.1 - A blazingly fast markup combinator library for Haskell  http://hackage.haskell.org/package/blaze-markup-0.6.1.1 (JasperVanDerJeugt)
02:14:07 <Jookia> yes
02:14:09 <tdammers> ok
02:14:23 <tdammers> now, read the signature as (b -> c) -> (a -> b) -> (a -> c)
02:14:36 <tdammers> it's the same, the extra parentheses are technically redundant
02:14:39 <tdammers> *but*
02:14:54 <tdammers> if you read it that way, you have two arguments and a return value
02:15:03 <tdammers> both arguments are unary functions, and so is the return value
02:15:22 <tdammers> so, in f . g = h:
02:15:41 <tdammers> f :: (b -> c); g :: (a -> b); h :: (a -> c)
02:16:11 <tdammers> (f . g) x == f (g x)
02:16:24 <tdammers> trace the types through that and see how it works out
02:16:48 <Zeedox> tdammers: When would it be useful to do `f . g x` instead of `f(g x)`?
02:17:04 <tdammers> Zeedox: you mean (f . g) x?
02:17:28 <Zeedox> tdammers: Ah, of course. Messed up the parse order.
02:17:30 <Jookia> :\ but not all functions have 2 arguments
02:17:49 <tdammers> it's not usually useful except for readability; composition starts being useful when you aren't passing the arguments immediately, but rather construct a new functions from existing ones to pass to yet another function
02:18:12 <tdammers> Jookia: technically, *all* Haskell functions take exactly one argument; some return a value, others return a new function
02:18:36 <tdammers> but for convenience, we often say that functions that return functions take more than one argument
02:18:40 <tdammers> for example:
02:18:53 <Jookia> tdammers: and here c/b can be functions with multiple arguments?
02:18:54 <tdammers> > let add x y = x + y -- trivial, but let's go with it
02:18:55 <lambdabot>  not an expression: ‘let add x y = x + y -- trivial, but let's go with it’
02:18:57 <Zeedox> tdammers: I can see that the concept would be useful, but not when it would be better than, say, `f $ g x`, which is even more terse.
02:19:07 * hackagebot blaze-html 0.7.0.3 - A blazingly fast HTML combinator library for Haskell  http://hackage.haskell.org/package/blaze-html-0.7.0.3 (JasperVanDerJeugt)
02:19:28 <tdammers> Zeedox: example:
02:19:53 <tdammers> > map ((+ 5) . negate) [1,2,3]
02:19:55 <lambdabot>  [4,3,2]
02:20:01 <tdammers> this reads as:
02:20:16 <tdammers> map the composition of "add 5" and "negate" over the list [1,2,3]
02:20:39 <tdammers> it also allows us to express functions in terms of other functions directly
02:20:57 <Jookia> yes but what happens with functions with more than one argument
02:21:07 <tdammers> > let choppity = take 5 . reverse in choppity "Hello, world!"
02:21:09 <lambdabot>  "!dlro"
02:21:17 <Zeedox> Jookia: They become partial functions.
02:21:19 <tdammers> Jookia: "there are none"
02:21:20 <Zeedox> Right?
02:21:36 <Jookia> > :type (fmap . fmap) -- ?
02:21:38 <lambdabot>  <hint>:1:1: parse error on input ‘:’
02:21:39 <tdammers> for the purpose of this discussion, a -> b -> c is a -> (b -> c)
02:21:42 <Jookia> alrighty then
02:21:52 <tdammers> :t fmap. fmap
02:21:53 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
02:21:58 <Zeedox> > :t +1
02:22:00 <lambdabot>  <hint>:1:1: parse error on input ‘:’
02:22:00 <Jookia> how does that even
02:22:10 <tdammers> :t fmap
02:22:10 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:24:54 <Jookia> yeah, i've hit my limit of understanding. i figure i should go do something else and come back to it after i've done other exercises
02:31:23 <Zeedox> What is the best analogue to objects in Haskell?
02:32:18 <opqdonut> Zeedox: a record to contain data and functions to operate on that record
02:32:19 <Zeedox> For example, is I have a class "Car" with many different properties.
02:32:45 <Zeedox> opqdonut: data Type = Type {....} ?
02:32:48 <opqdonut> yep
02:33:29 <opqdonut> http://learnyouahaskell.com/making-our-own-types-and-typeclasses might help
02:33:45 <Zeedox> Yes, I've read that, but the examples felt too small.
02:35:14 <tdammers> "object" is really an amalgamation of several orthogonal concerns
02:35:35 <tdammers> Haskell has features to address each of these, but they're not bundled into a monolithic abstraction
02:35:49 <tdammers> you can, for example, bundle fields by using record syntax
02:35:59 <tdammers> you can have compile-time polymorphism using typeclasses
02:36:15 <tdammers> you can have run-time polymorphism using higher-order functions and the like
02:36:44 <tdammers> you can bundle state with behavior using closures, or again using higher-order functions
02:37:01 <Cale> The heart of object oriented programming, at least as I see it, is to have values which are determined by the way in which they respond to messages (or methods). Since Haskell has first class functions, you can construct records with fields for each of the messages an object should be able to respond to, and define values of that type with the responses.
02:37:18 <Zeedox> tdammers: I'm 'translating' an old program I've written in python to Haskell as an excercise, so there are a few big objects to refactor into something more functional.
02:37:25 <Cale> Functions that construct such objects can take parameters which act as "private" data.
02:37:36 <bernalex> trying to translate imperative code to functional code is almost always a really bad idea.
02:37:42 <tdammers> Zeedox: I think you should take a step back and redesign the program entirely
02:37:46 <bernalex> instead, a clean-room engineering type approach should be employed.
02:38:01 <Cale> There are two options for how to deal with state: you can do it the pure way, and have objects which respond to messages with updated versions of themselves
02:38:14 <Zeedox> Seems like it would take a little longer, but perhaps cause less headaches.
02:38:31 <bernalex> it will take longer the first time you do it at least
02:38:32 <Cale> Or you can have objects that respond with IO actions which update state in the form of internal IORefs and such.
02:38:47 <tdammers> well, the alternative would be to define some sort of imperative DSL inside haskell that allows you to "transcribe" your original program
02:38:50 <bernalex> at some point you become enlightened and find yourself solving problems functionally in your head -- you become a haskell native.
02:39:06 <Cale> I dunno, once you've done it a bit, translating imperative code to functional code is pretty straightforward, I think.
02:39:23 <Zeedox> I tend to agree with Cale here.
02:39:25 <bernalex> I don't translate imperative code to functional code
02:39:26 <Cale> But yeah, you should learn to just write it in a functional way from the start :)
02:39:43 <tdammers> imperative to functional; yes. object-oriented to functional can be trickier
02:39:44 <bernalex> I reimplement programs in a functional style, giving no thought to the imperative implementation at all
02:39:55 <Zeedox> Objects are often namespaces / structs with makeup.
02:40:11 <bernalex> the denotation of the program is what matters, not the implementation. once you know the denotation, you can implement it any way you are capable of implementing it without too much trouble.
02:40:24 <Cale> http://www.reddit.com/r/haskell/comments/2cin7p/is_there_any_way_to_elegantly_represent_this/cjfvbpg -- here's a simple example of a (small but messy and meaningless) imperative program that I translated into a pure functional one.
02:40:49 <Cale> The obvious translation is just to turn all the mutable variables into function parameters, and to have a function for each point of control in the imperative program
02:40:55 <bernalex> and if you are a capable functional programmer, I find that "solve problem X" functionally is a lot easier than "translate this imperative OOP piece of code".
02:41:13 <Cale> and then those functions call each other with the updated values of the mutable variables
02:41:26 <Cale> according to the flow of control
02:41:53 <Zeedox> bernalex: Well, my case is more like data description and a little bit of presentation rather than "solve problem X".
02:41:54 <bernalex> lastly, translating a program *will* limit you. your mind will be closed, and your functional translation will suffer from the imperative-induced myopia.
02:41:57 <Cale> This immediately results in a mess, but it's a mess which you can immediately start to clean up by making substitutions
02:42:03 <tdammers> as long as you don't have any run-time polymorphic objects, it's not difficult
02:42:24 <Zeedox> Cale: refactoring is the fun part of programming. :)
02:42:26 <bernalex> Zeedox: well, what are you trying to do, specifically?
02:42:39 <tdammers> Zeedox: unless you're using Python or Perl or some such
02:42:46 <Zeedox> bernalex: It's a toy planetarium written in python+pygame.
02:42:58 <bernalex> Zeedox: don't say that too loudly. your manager will put you to refactor that 100K python codebase that works as long as you squint enough.
02:43:14 <Zeedox> bernalex: That's actually my job description.
02:43:36 <tdammers> my conclusion is that "refactoring python code" is a fundamentally unsolvable problem
02:43:42 <ph88> hey guys, im trying to do  cabal install cairo-0.13.0.0    but im getting this error     http://pastebin.com/t2cw6jNM  can someone help ?
02:43:48 <bernalex> tdammers: once you hit 10K SLOC, I agree.
02:44:06 <tdammers> well, the fundamental problem is that there are no build-time guarantees whatsoever
02:44:16 <bernalex> Zeedox: have you by any chance read Eloquent Javascript?
02:44:17 <tdammers> it's even possible to have *parse errors* pop up at run time
02:44:36 <Zeedox> bernalex: perhaps snippets online, don't remember buying it.
02:44:46 <bernalex> of all things... that book has a functional implementation of an ant terrarium. which is a similar problem, I assume.
02:44:52 <bernalex> it's available gratis online
02:45:04 <tdammers> so basically, any change you introduce can break things in ways that you cannot protect yourself against completely
02:45:14 <Zeedox> tdammers: yeah, trying to figure out return types of functions and call graphs is what made me remember haskell and try to pick it up again.
02:45:36 <bernalex> tdammers: I'm not convinced it's python-related as much as just "side effects are bad, mkay?".
02:45:38 <tdammers> in Haskell, renaming a function is trivial - just make the change, compile, and work your way through the compiler erros
02:46:13 <bernalex> tdammers: it happens more frequently in python in my experience, sure, but that might be related to the kind of programmers that gravitate towards python.
02:46:21 <tdammers> not really, you see
02:46:45 <tdammers> you can never tell for sure what the consequence of a name change is in Python without exercising your code through all possible code paths
02:46:53 <bernalex> I have some experience with programmers who discover that "wow python is so much easier than java and c++!", and then proceed to take an endless range of shortcuts in their code.
02:47:04 <tdammers> at best, you can assume that people adhere to coding standards and such.
02:47:14 <tdammers> even with well-written Python code
02:47:18 <bernalex> "name change"? what's different from e.g. ruby?
02:47:24 <bernalex> also maybe reply in #haskell-blah at this point...
02:47:31 <tdammers> ruby has the same problem
02:48:20 <Zeedox> tdammers: wouldn't any dynamic language have the same weakness?
02:49:59 <Intolerable> can't dialyzer cope w/ that?
02:50:10 <hyPiRion> Zeedox: Depends on what you mean by dynamic language I guess. The Clojure compiler would complain if the function name isn't existing at compile time, for instance.
02:51:29 <tdammers> Zeedox: yes
02:51:37 <tdammers> Zeedox: even Java does
02:53:35 <Mon_Ouie> hyPiRion: not f you use the runtime metaprogramming facilities that Clojure has, though
02:53:36 <Zeedox> I'm hoping for function annotations to change the field for python even slightly.
02:54:50 <hyPiRion> Mon_Ouie: macros? They are expanded at compile time. Or do you mean something else?
02:55:45 <Mon_Ouie> Things like http://clojuredocs.org/clojure_core/clojure.core/resolve
02:58:49 <hyPiRion> ah. Yeah, if you're crazy enough to use resolve, you're on your own I guess
03:02:50 <edlinde> wondering if its ok to skip newtype for now? :)
03:03:00 <edlinde> is it a really important concept to understand/
03:03:01 <edlinde> ?
03:03:46 <tdammers> edlinde: not reall
03:04:00 <tdammers> edlinde: you can treat it as a performance hack for certain kinds of `data` definitions for now
03:04:09 <edlinde> yeah thats how I understood it
03:04:17 <edlinde> saves you from wrapping unwrapping etc
03:04:26 <tdammers> well
03:04:33 <edlinde> and Monoids? useful?
03:04:35 <tdammers> syntax-wise, you're still wrapping and unwrapping
03:04:46 <hexagoxel> is there a way to semi-defer-type-errors? i want typed holes to work, but still don't want compilation "success"
03:04:54 <edlinde> I am getting impatient.. think I want to dive into Monads asap :)
03:04:59 <tdammers> but the compiler can optimize that away for you
03:05:02 <tdammers> anyway
03:05:04 <tdammers> monoids are easy
03:05:08 <jle`> edlinde: why would you want to do that? :P
03:05:15 <edlinde> haha dunno :)
03:05:23 <tdammers> rite of passing, haha
03:05:26 <jle`> i don't really think that understanding monads is really a useful thing
03:05:29 <jle`> or meaningful even
03:05:35 <edlinde> really?
03:05:37 <jle`> yes
03:05:43 <jle`> especially in haskell
03:05:44 <edlinde> hmm I am dissapointed
03:05:45 <edlinde> hah
03:06:06 <tdammers> the key to understanding monads is discovering that there's not a lot to understand after all
03:06:20 <doismellburning> tdammers: heh yes that threw me for some time
03:06:27 <jle`> i wonder why people seem to think that monads are a big deal of some sort
03:06:36 <tdammers> apart from 'do' sugar, there is nothign special about monads - they're just another typeclass with just another set of methods
03:06:40 <edlinde> because there is so much talk about it
03:06:41 <edlinde> :)
03:06:45 <jle`> yes, but why ;_;
03:07:10 <jle`> i think silly language like "IO monad" helps contribute
03:07:22 <edlinde> so I was hearing this talk where this guy is trying to figure out a new language that works on massively parallel systems and he was going on about his research on Monads
03:07:45 <doismellburning> yeah all my monad "fear" came from "monads must be magic and hard because IO is magic and hard"
03:07:47 <edlinde> but then his work was all about the data and the filesystems .. so maybe IO was very important to him
03:08:12 <edlinde> so whats the easy way to understand a Monad?
03:08:12 <gfixler_> Brian Beckman made a big deal about how monads were the way of controlling complexity in the future
03:08:35 <doismellburning> (IO may not be magic or hard, but I'm not sure I could implement it, whereas when I looked at _other_ monads, everything seemed much simpler)
03:08:39 <edlinde> do Monads really play a big role when we start talking Parallel Haskell?
03:08:53 <jle`> not really
03:08:59 <edlinde> hmm I see
03:09:01 <gfixler_> edlinde: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
03:09:19 <gfixler_> edlinde: that's the easy way - maybe not the complete way, but you'll get a nice, top-level view in pictures that makes sense
03:09:21 <edlinde> gfixler_: thanks seen that one before
03:09:28 <gfixler_> edlinde: didn't work for you?
03:09:33 <edlinde> yeah worked fine
03:09:41 <folex> edlinde: I think that the best way to learn monads is to use them.
03:09:42 <edlinde> I get the idea of it.. like the high level concept
03:09:44 <gfixler_> edlinde: did you do step 1?
03:10:00 <doismellburning> I also loved that "you could have invented monads" thing
03:10:15 <gfixler_> doismellburning: I had a talk 2 years ago with a friend who grokked monads
03:10:23 <gfixler_> doismellburning: we both agreed I had independently invented monads
03:10:32 <gfixler_> doismellburning: 2 years later I realize that no I didn't
03:10:40 <gfixler_> doismellburning: whatever I was thinking wasn't even close
03:11:02 <edlinde> so now all of you are in agreement that Monads are not really a big deal?
03:11:03 <edlinde> :)
03:11:14 <gfixler_> edlinde: oh, they're a big deal for my future resume
03:11:25 <doismellburning> edlinde: they're a big deal for making my life easier
03:11:26 <jle`> monad instances are each useful in their own way
03:11:33 <doismellburning> and really useful
03:11:36 <gfixler_> edlinde: I'm having a metal press machined so I can stamp "grok monads" in silver leaf
03:11:39 <adas> can somone tell why this is valid? "pure <*> head". doesn't make sense..
03:11:50 <doismellburning> :t pure <*> head
03:11:51 <jle`> just like and the monad typeclass is useful because you can have a generic interface
03:11:51 <lambdabot> [a] -> [a]
03:11:58 <doismellburning> :t (<*>)
03:11:59 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:12:00 <jle`> but other than that, not really a big deal
03:12:14 <jle`> it's teh same as every numerical type having its own usage, and a Num typeclass useful so you can use + with different types
03:12:22 <edlinde> ok
03:12:29 <gfixler_> types are like water balloons
03:12:40 <gfixler_> when you ask #haskell a question, 5 people throw them at your face
03:12:41 <jle`> adas: time to play the unification game :D
03:12:59 <jle`> :t (<*>)
03:12:59 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:13:03 <jle`> :t pure
03:13:04 <lambdabot> Applicative f => a -> f a
03:13:05 <adas> jle`: i don't understand. please eplain me
03:13:15 <jle`> you are applying (<*>) to pure, first
03:13:18 <chrismed> is it possible to write a function that converts (0::Int) to (Proxy 'HZero), (1::Int) to (Proxy ('HSucc 'HZero)) and so on? I'm using HList library and I need such Proxy as a first argument to hDeleteAtHNats function
03:14:18 <adas> jle`: but (<*>) doesn't take "a -> f a" as its first argument
03:14:29 <jle`> so that means that Applicative g => (c -> g d) has to unify with the input of (<*>), Applicative f => f (a -> b)
03:14:56 <jle`> hm.  this seems tricky!
03:14:58 <jle`> let's try the second argument
03:15:03 <jle`> :t head
03:15:03 <lambdabot> [a] -> a
03:15:22 <jle`> so [e] -> f has to unify with the second input of (<*>), Applicative f => f a
03:15:25 <jle`> hm.
03:15:32 <jle`> oops, i use f twice there
03:15:41 <jle`> [e] -> h has to unify with Applicative f => f a
03:15:55 <jle`> hm.
03:15:55 <adas> jle`: what do you mean when you say "unify"?
03:16:07 <jle`> oh, we pick values of e, h, f, a, etc. so that they match up
03:16:17 <jle`> for example, let's say f ~ ([e] ->)
03:16:33 <jle`> ( ~ can be said to be type equality kinda)
03:16:41 <jle`> so if we set f to be ([e] ->)....
03:17:07 <jle`> then we now have to unify [e] -> h with ([e] ->) a, or [e] -> a
03:17:12 <jle`> hm.
03:17:16 <jle`> that's easy, h ~ a :D
03:17:37 <adas> jle`: so 'f' here is a type (e ->0
03:17:42 <adas> (e ->)?
03:17:50 <jle`> yeah, which, incidentally, is an instance of Applicative
03:18:48 <jle`> so our overall game is to unify Applicative f => f (a -> b) with Applicative g => (c -> g d), and to unify Applicative f => f a with ([e] -> h)
03:18:50 <adas> jle`: is this idiomatic? although valid... is it idiomatic? to me, its like an abomination...only because I don't get it..
03:19:00 <jle`> yes, you wouldn't see this in real code
03:19:33 <jle`> so we see that we can unify this if we set h ~ a, and f ~ ([e] ->).  that gets rid of two "variables", h and f.
03:20:32 <jle`> we can substitute in h ~ a and f ~ ([e] ->) into the first argument's unification funny stuff and we see that we now need to unify [e] -> (a -> b) with Applicative g => (c -> g d)
03:20:40 <jle`> hm.
03:21:08 <jle`> well it looks like c ~ [e] is a good start
03:21:30 <jle`> [e] -> (a -> b)  ~  [e] -> g d
03:21:33 <adas> making sense.. the problem here is that it takes a while to understand that the function type itself is an applicative in this pice of ocde
03:21:36 <adas> *code
03:21:40 <jle`> oh...and also g ~ (a ->)
03:21:48 <nshepperd> :t const <*> head
03:21:49 <jle`> and d ~ b
03:21:49 <lambdabot> [b] -> [b]
03:22:22 <Phillemann> Are there any example on how to use Parsec with Data.Text? Do I have to manually pack any "many1 char" parser into a Text?
03:23:02 <adas> jle`: thanks for the clarification
03:23:31 <jle`> so now we have h ~ a, f ~ ([e] ->), c ~ [e], and d ~ b.  i think that's all we need, now.  i'll leave the rest to you :)
03:23:32 <tdammers> :t many1
03:23:33 <lambdabot>     Not in scope: ‘many1’
03:23:33 <lambdabot>     Perhaps you meant ‘many’ (imported from Control.Applicative)
03:23:38 <tdammers> ah hmm
03:23:41 <tdammers> well
03:23:43 <tdammers> many1 returns a list
03:23:49 <tdammers> Data.Text is not a list
03:24:03 <ziman> there's a Text instance for Stream: http://hackage.haskell.org/package/parsec3-1.0.0.7/docs/Text-Parsec-Text.html
03:24:20 <tdammers> ziman: that covers parsing *from* texts, but not *to*
03:24:51 <ziman> hmmm, I see
03:25:37 <fgc1> so I have added a bunch of haskell stuff to my emacs config an now some lines in my code have a squiggly underline and a question mark in the margin. Can't see anything wrong with them.
03:26:00 <Kinnison> does hovering over the squiggles and/or question-mark tell you anything?
03:26:19 <Kinnison> (hovering might equal mouse, or cursor, depending on which mode you're using)
03:26:29 <fgc1> oh, I wasn't hovering long enough, thanks!
03:26:50 <tdammers> ziman: if performance isn't a critical concern, just write a little utility function that does the conversion for you
03:27:03 <tdammers> (or use one of the string conversion libraries)
03:27:25 <tdammers> the thing is, many1 doesn't generalize to arbitrary return values easily
03:28:58 <Phillemann> I see.
03:30:29 <fgc1> squiggles gone, just some var shadowing warnings, thanks Kinnison
03:37:38 <gfixler_> wow, reading through adit's pictures page... I think I just fully grokked monads
03:38:09 <gfixler_> probably a bad word to use - grokked might imply I get all the implications surrounding them now, which I'm sure I don't
03:38:17 <solatis> :)
03:38:29 <gfixler_> but like, when and why and how to use them - seems fairly straightforward
03:38:42 <solatis> my trick for learning them a month ago was to look at a javascript implementation of the IO monad
03:39:03 <solatis> and suddenly the relation to the monads, transformers and purity inside the monad clicked with me
03:39:03 <gfixler_> solatis: I tried my current home language - Python - didn't work for me
03:39:16 * hackagebot persistent-template 2.0.2.2 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-2.0.2.2 (MichaelSnoyman)
03:40:38 <solatis> we all have each our own way of making ourselves understand them -- i believe explaining monads is nearly impossible a task :)
03:40:59 <gfixler_> solatis: the problem feels familiar
03:41:03 <gfixler_> solatis: it's "layers"
03:41:05 <solatis> i read somewhere that understanding monads and having the ability to explain them are mutually exclusive
03:41:16 <solatis> that about sums it up i think :)
03:41:34 <gfixler_> solatis: each layer is nice and simple, especially when explained well
03:41:47 <gfixler_> but for me, I need time on each layer to let it soak in and become something I can take for granted
03:41:49 <keko_> ̃.3
03:41:59 <keko_> oops
03:42:07 <gfixler_> and then turn around and say "why did that take time? that's so easy!"
03:42:11 <gfixler_> then I can move to the next layer
03:42:14 <solatis> gfixler_: that's normal, depending on your background
03:42:30 <gfixler_> solatis: my background is in not being a human data processing and perfect logic machine
03:42:37 <solatis> :)
03:42:43 <chrismed> hello, does anybody have any thoughts or know the answer to the question I asked?
03:43:02 <gfixler_> solatis: I'm a bit embarrassed to say it, but I do all of my thinking in a meat-based computer
03:43:14 <solatis> yes, and it runs at about 4 hz
03:43:33 <gfixler_> solatis: wow, like a BASIC Stamp microcontroller
03:43:36 <solatis> :)
03:44:07 <solatis> chrismed: i missed your question, and i think many others did -- can you please repeat it?
03:44:11 <gfixler_> I need to get to bed, or I'm going to be thinking at about 2.5Hz at $DAYJOB tomorrow
03:44:18 <gfixler_> night!
03:44:23 <solatis> gn
03:47:01 <chrismed> is it possible to write a function that converts (0::Int) to (Proxy 'HZero), (1::Int) to (Proxy ('HSucc 'HZero)) and so on? I'm using HList library and I need such Proxy as a first argument to hDeleteAtHNats function
03:47:35 <chrismed> if it's possible, what is the signature of such function?
03:49:15 <solatis> chrismed: looks like a recursive function to me
03:50:26 <solatis> use pattern matching for 0, and myFun x = myFun 'HSucc x
03:50:29 <solatis> or something like that
03:51:17 <solatis> and 0 just returns 'HZero
03:51:23 <solatis> and wrap the thing in a Proxy
03:53:03 <chrismed> solatis: sure, the problem is it doesn't type check
03:54:13 <chrismed> solatis: it's easy to write a function that returns a HNat, that is it returns a Peano number at the value level
03:54:48 <chrismed> solatis: but I have no idea how to indicate that a function returns a type of kind HNat instead of a value of type HNat
03:59:13 <solatis> chrismed: ok, in that case, you should ask someone more familiar with your problem domain than me :)
04:07:37 <lpaste> srhb pasted “FlexibleInstanceWoes” at http://lpaste.net/8515940182459940864
04:07:50 <srhb> So this is terrible and wrong, but why?
04:08:45 <srhb> (I'm just going to make a pretty printer instead, but the error makes me curious)
04:09:20 * hackagebot tasty-ant-xml 1.0.0.10 - Render tasty output to XML for Jenkins  http://hackage.haskell.org/package/tasty-ant-xml-1.0.0.10 (OliverCharles)
04:10:31 <srhb> Oh, same issue there.
04:10:37 <srhb> So it's not FlexibleInstances but Printf.
04:12:56 <supki> srhb: well, the result type of  show  is  String, so  roundComplex :: Complex Double -> Char
04:13:08 <srhb> oh derp.
04:13:10 <srhb> concat
04:13:33 <srhb> supki: Thanks. I need more coffee. :-)
04:33:43 <srhb> So, what are the risks I run when enabling FlexibleInstances? I can't imagine I'd suddenly be missing an instance at runtime, could I?
04:36:02 <hpc> FlexibleInstances is almost zero-risk
04:36:44 <hpc> it removes only the most onerous of haskell restrictions on class definitions (which were put in place to make writing a compiler easier iirc)
04:36:56 <srhb> hpc: OK, thank you. :)
04:37:01 <hpc> i don't think it even has an effect on actual instance resolution
04:37:12 <srhb> So when does it know to kick in?
04:37:23 <srhb> I mean, there must be some sort of choice going on in the compiler.
04:40:04 <hpc> srhb: start reading from here: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-decls
04:40:10 <srhb> Thanks!
04:40:12 <hpc> er
04:40:18 <hpc> without the anchor, start from the top
04:40:34 <hpc> it explains what standard haskell does and how the extension changes it
04:40:36 <srhb> Got it :)
04:52:06 <srhb> Really easy to read. Fantastic. So even OverlappingInstances is pretty safe, but UndecidableInstances not so much
04:54:17 <jmcarthur> srhb: ? why is UndecidableInstances unsafe?
04:54:50 <srhb> Er, I meant incoherent
04:55:02 <jmcarthur> why is it incoherent?
04:55:13 <jmcarthur> oh
04:55:26 <jmcarthur> you mean IncoherentInstances
04:55:57 <srhb> IncoherentInstances * :)
04:56:09 <srhb> Though I see the docs also consider problems with OverlappingInstances without IncoherentInstances
05:01:54 <iXeno> hi, how do I make a module a "main module" in cabal? I thought I did it, but I get an error message that there is no main module, so I obviously didn't
05:02:54 <Intolerable> do u have it marked as Main-is: in ur .cabal
05:03:08 <iXeno> yes
05:03:33 <Intolerable> whats the exact error
05:03:40 <iXeno> "Warning: output was redirected with -o, but no output will be generated"
05:03:47 <iXeno> main-is:         Chapter8/FindFactors.hs
05:06:07 <Intolerable> iirc ur main has to be called Main
05:06:34 <Intolerable> i.e. a module Main where … called Main.hs / Main.lhs
05:07:00 <Intolerable> make sure ur definitely trying to build an executable
05:07:07 <Intolerable> i know thats caught me out once or twice
05:09:48 <iXeno> oh crap
05:10:39 <iXeno> so cabal couldn't just say "error, the main module is not named Main.hs"
05:10:41 <iXeno> :/
05:11:02 <ion> The filename does not matter.
05:11:26 <iXeno> ion: it did
05:11:47 <Intolerable> u all sorted?
05:13:06 <epta> Is there a way to set cabal contraints directly in *.cabal file?
05:13:56 <Intolerable> dependency constraints?
05:14:10 <epta> Intolerable: yep
05:14:31 <Intolerable> does base == 4.7.*, package > 2 && < 3 not work?
05:15:23 <Intolerable> syntax might be a bit off but thats the idea
05:16:23 <Intolerable> http://www.haskell.org/ghc/docs/7.0.3/html/Cabal/authors.html#buildinfo might be useful
05:16:33 <iXeno> Intolerable: almost
05:18:02 <favetelinguis> Im lost on how to prove the following p->!p, !p->p |- _|_ What happend when i have bottom as a conclution?? Any logic people here?
05:20:27 <NikolajK> can I make this work:
05:20:28 <NikolajK> Prelude> import Data.List
05:20:28 <NikolajK> Prelude Data.List> (join::[[Int]]->[Int]) [[1,2],[],[3]]
05:21:08 <iXeno> I thought I was set
05:21:15 <pjdelport> > (join::[[Int]]->[Int]) [[1,2],[],[3]]
05:21:17 <lambdabot>  [1,2,3]
05:21:50 <pjdelport> You could equally just say:
05:21:50 <pjdelport> > join [[1,2],[],[3]] :: [Int]
05:21:52 <lambdabot>  [1,2,3]
05:22:01 <iXeno> I have a module declared with 'module MyPackage.FindFactors (findFmain) where'
05:22:17 <iXeno> and in Main.hs, I have 'main = MyPackage.FindFactors.findFmain'
05:22:24 <iXeno> but it complains that it can't find findFmain
05:22:51 <Intolerable> make sure u "import MyPackage.FindFactors"
05:23:22 <Intolerable> ur Main.hs can just literally be "import MyPackage.FindFactors; main = findFmain"
05:23:40 <k00mi> iXeno: the module containing the main of you program must be called Main, but the filename can be anything
05:24:09 <iXeno> k00mi: ok
05:25:28 <hexagoxel> NikolajK: join is in Control.Monad
05:25:58 <Intolerable> k00mi: doesnt cabal usually whine if ur modules dont match their filenames? is Main an exception for that
05:26:04 <NikolajK> hexagoxel: thx
05:26:10 <k00mi> favetelinguis: bottom as a conclusion means your premise is impossible
05:26:26 <k00mi> Intolerable: yes, that's the only case where module name and filename don't have to match AFAIK
05:28:10 <PudgePacket> Is there a more up to date version of real world haskell? This one has an error in the example Parsec code (http://book.realworldhaskell.org/read/using-parsec.html)
05:29:03 <tdammers> PudgePacket: the general advice re. RWH is "read with caution"
05:29:10 <k00mi> PudgePacket: did you look at the comments? They often contain corrections
05:29:10 <tdammers> (a.k.a. "apply brain")
05:29:30 <tdammers> IIRC, RWH covers an old Parsec version
05:30:01 <tdammers> you can extract the general idea from RWH, and then fill the gaps using the documentation for a more recent Parsec
05:30:20 <PudgePacket> I looked for the parsec documentation but the website it on no longer hosts it.
05:30:28 <PudgePacket> Hackage points to a dead link
05:30:55 <Intolerable> what version does rwh use?
05:32:21 <Intolerable> hackage has some docs for 2: https://hackage.haskell.org/package/parsec-2.1.0.1/docs/Text-ParserCombinators-Parsec.html
05:34:29 * hackagebot fay 0.20.1.4 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.20.1.4 (AdamBergmark)
05:34:31 * hackagebot fay-builder 0.2 - Compile Fay code on cabal install, and ad-hoc recompile during development  http://hackage.haskell.org/package/fay-builder-0.2 (AdamBergmark)
05:40:14 <trap_exit> I've already done "cabal install ALUT"
05:40:15 <trap_exit> xs-mbp-2% ghc test.hs [1 of 1] Compiling Main             ( test.hs, test.o ) Linking test ... ld: framework not found ALUT clang: error: linker command failed with exit code 1 (use -v to see invocation)
05:40:22 <trap_exit> wtf .... how do I get ALUT ?
05:40:25 <trap_exit> I've already done "cabal install ALUT"
05:44:01 <solatis> hmm
05:44:08 <Intolerable> u have alut installed via brew or w/e right?
05:44:10 <solatis> i'm bending my mind over how to elegantly solve this problem:
05:44:18 <PudgePacket> is parsec 3 the latest?
05:44:21 <Intolerable> yes
05:44:30 * hackagebot fay-text 0.3.0.2 - Fay Text type represented as JavaScript strings  http://hackage.haskell.org/package/fay-text-0.3.0.2 (AdamBergmark)
05:45:05 <PudgePacket> the wording of the parsec3 description in hackage makes it sound like an older version
05:45:06 <solatis> given the following list: ["a","b","this", "a", "c", "that", "a", "d", "and this"] -- i want to filter on "a", and take all the items exactly 2 positions behind it, such that the end result would be a list of ["this", "that", "and this"]
05:45:13 <burp> monochrom: thanks for figuring out the segfault :)
05:45:15 <solatis> what is an elegant way to solve this problem?
05:45:15 <trap_exit> no
05:45:17 <trap_exit> I need to install ALUT ?
05:45:24 <trap_exit> is ALUT not part of OSX?
05:45:47 <solatis> it seems like i would need to build my own filter function?
05:45:50 <trap_exit> https://github.com/vancegroup/freealut ?
05:47:10 <Intolerable> solatis: pattern match on something similar to "a":_:x:_
05:47:50 <solatis> Intolerable: perfect!
05:48:04 <solatis> but indeed, that would involve my own filter' function, right?
05:49:53 <Intolerable> solatis: http://lpaste.net/110868
05:50:04 <Intolerable> u shouldnt need a custom filter if u use mapMaybe
05:50:35 <Intolerable> trap_exit: do "brew install alut" then install the alut package
05:51:05 <Intolerable> it installs fine for me if i install it w/ brew
05:51:09 <Claudius1aximus> > let xs = words "a b this a c that a d and this" in map snd . filter ((=="a") . fst) $ zip xs (drop 2 xs) -- solatis
05:51:10 <lambdabot>  ["this","that","and"]
05:51:18 <michaelt> brew install freealut
05:51:33 <solatis> Claudius1aximus: woa, brain explode
05:51:35 <Nimatek> > map (!! 1) . tail . splitOn ["a"] $ ["a","b","this", "a", "c", "that", "a", "d", "and this"]
05:51:37 <lambdabot>  ["this","that","and this"]
05:52:17 <Intolerable> all these pointfree suggestions and mine uses an explicit function
05:56:15 <solatis> Intolerable: yours is most readable to the uneducated mind of me
05:58:54 <zenguine> anyone here familiar with using delimited continuations? I've got a question. specially about the shift/reset variety
06:03:22 <farmerworking> hi, if I define data Term = TrueTerm | FalseTerm
06:03:44 <farmerworking> Does Haskell provide TrueTerm? for me?
06:04:12 <farmerworking> or I have to make a function with pattern match to do that for myself
06:04:36 <zenguine> farmerworking: If you define that haskell will define TrueTerm , FalseTerm :: Term for you
06:05:03 <michaelt> farmerworking: you can write toBool TrueTerm = True; toBool FalseTerm = False , for example , on the next line
06:05:40 <zenguine> but the two values of type Term named TrueTerm and FalseTerm will be available to use regardless
06:06:17 <farmerworking> It's just a example
06:06:28 <zenguine> does anyone have any advice "knot tying" with respect to returning the current continution out from a callCC or the like?
06:06:51 <zenguine> in particular, I want to do this with shift in delimeted continuations.. something like
06:07:00 <zenguine> reset (shift (\k -> return k))
06:07:11 <farmerworking> @michaelt it's just a example, in read code I have , I have many value constructer
06:07:11 <lambdabot> Unknown command, try @list
06:07:31 <zenguine> which is related to callCC $ \k -> k, if you don't know delimited continutaions
06:07:47 <zenguine> but I can't pull it off infinite type recursion.. but I know it must be possible.. any ideas?
06:07:48 <pjdelport> solatis: Here's a version of ClaudiusMaximus's approach that maybe reads a bit easier:
06:07:48 <pjdelport> > let foo p xs = catMaybes $ zipWith (\a b -> if p a then Just b else Nothing ) xs (drop 2 xs) in foo ("a" ==) ["a","b","this","a","c","that","a","d","and this"]
06:07:49 <lambdabot>  ["this","that","and this"]
06:07:56 <michaelt> callCC, yipe
06:08:31 <zenguine> s/off/off because of/
06:08:57 <pjdelport> Or equally, with a bit less Maybe noise:
06:08:57 <pjdelport> > let foo p xs = concat $ zipWith (\a b -> if p a then [b] else []) xs (drop 2 xs) in foo ("a" ==) ["a","b","this","a","c","that","a","d","and this"]
06:08:58 <lambdabot>  ["this","that","and this"]
06:09:22 <zenguine> michaelt: yeah.. I find playing with CPS code interesting.. but the type system seems to screw me in a couple places.. and I've seen that there are weird tying the knot work arounds that are counter intuitive. but I don't get the general principle
06:10:26 <pjdelport> And here's a version just for fun:
06:10:26 <pjdelport> > let foo p xs = execWriter $ zipWithM (\a b -> when (p a) (tell [b])) xs (drop 2 xs) in foo ("a" ==) ["a","b","this","a","c","that","a","d","and this"]
06:10:27 <lambdabot>  ["this","that","and this"]
06:12:11 <pjdelport> That uses Writer to zip through the lists and "log" the b for each matching a; execWriter then just returns the final log.
06:14:25 <michaelt> > let foo p = execWriter. ap (zipWithM (\a b -> when (p a) (tell [b]))) (drop 2) in foo ("a" ==) ["a","b","this","a","c","that","a","d","and this"]
06:14:26 <lambdabot>  ["this","that","and this"]
06:14:33 * hackagebot persistent-postgresql 1.3.1.2 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-1.3.1.2 (MichaelSnoyman)
06:14:35 * hackagebot aeson-utils 0.2.2.1 - Utilities for working with Aeson.  http://hackage.haskell.org/package/aeson-utils-0.2.2.1 (AdamBergmark)
06:14:37 * hackagebot json-schema 0.7.0.1 - Types and type classes for defining JSON schemas.  http://hackage.haskell.org/package/json-schema-0.7.0.1 (AdamBergmark)
06:14:55 <ph88> hey guys, im trying to do  cabal install cairo-0.13.0.0    but im getting this error     http://pastebin.com/t2cw6jNM  can someone help ?
06:16:26 <michaelt> ph88: hm, there is a mismatch between the Cabal library being looked at, and SetupVersion in cairo
06:16:47 <kalusn> favetelinguis: that relation just says that the two implications leads to absurdity? what is the question?
06:17:34 <ph88> michaelt: do you know what i can do about it ?
06:17:45 <michaelt> ph88: SetupWrapper.hs rather. Let me think
06:18:10 <michaelt> ph88: what does "ghc-pkg list Cabal" tell you
06:18:43 <Intolerable> configCompilerEx was added in 1.18
06:19:01 <Intolerable> ph88: make sure ur cabal is newer than v1.18
06:19:30 <farmerworking> hi, I have data Term = FalseTerm | TrueTerm | ... and many value constructor, Does Haskell have something like instanceof in Java or build TrueTerm? and FalseTerm? for me?
06:19:34 * hackagebot tostring 0.2.0.2 - The ToString class  http://hackage.haskell.org/package/tostring-0.2.0.2 (AdamBergmark)
06:19:36 * hackagebot uri-encode 1.5.0.3 - Unicode aware uri-encoding.  http://hackage.haskell.org/package/uri-encode-1.5.0.3 (AdamBergmark)
06:19:38 * hackagebot rest-core 0.32 - Rest API library.  http://hackage.haskell.org/package/rest-core-0.32 (AdamBergmark)
06:19:40 * hackagebot rest-example 0.1.0.3 - Example project for rest  http://hackage.haskell.org/package/rest-example-0.1.0.3 (AdamBergmark)
06:20:10 <ph88> michaelt Intolerable http://pastebin.com/dkpL7L9N
06:20:34 <Intolerable> can u get rid of ur global copy of ghc?
06:20:42 <Intolerable> how did u install it?
06:20:50 <sopvop> is there a decent smtp client with tls support on hackage?
06:21:19 <michaelt> ph88: this is one of the rare cases where you get in trouble with two versions of Cabal  , just a sec
06:22:04 <Intolerable> sopvop: have u looked at haskellnet-ssl
06:22:06 <ph88> Intolerable: i don't know how to get rid of my global copy of ghc (i didn't know i had one). What i did was install the haskell platform and then install a new version of cabal
06:22:42 <sopvop> Intolerable: I'm looking at now, it dies with hPutBuf on closed handle :(
06:22:57 <sopvop> sends mail ok though :)
06:23:08 <Hafydd> farmerworking: are you asking for a function which returns True iff its argument is structurally equal to FalseTerm, for example?
06:23:42 <michaelt> ph88: yes, I see how it happened. SetupWrapper.hs has a comment about the level  of hackery its doing
06:24:12 <Hafydd> farmerworking: there might be such a thing, but you should consider whether having "deriving Eq" and just using (== FalseTerm) would be as good.
06:24:34 * hackagebot rest-gen 0.15.0.2 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.15.0.2 (AdamBergmark)
06:24:36 * hackagebot rest-types 1.10.2 - Silk Rest Framework Types  http://hackage.haskell.org/package/rest-types-1.10.2 (AdamBergmark)
06:24:38 * hackagebot rest-wai 0.1.0.3 - Rest driver for WAI applications.  http://hackage.haskell.org/package/rest-wai-0.1.0.3 (AdamBergmark)
06:24:50 <ph88> michaelt: do you know what i can do to fix this problem? i don't know where i can find the comment you are refering to
06:25:27 <michaelt> ph88: i'm just looking in the source "cabal unpack cairo"
06:25:58 <Hafydd> farmerworking: your actual problem would probably be better solved by pattern-matching on the value, anyway.
06:26:02 <Hafydd> Instead of something liek "
06:26:24 <Hafydd> like "if isFalseTerm x then y else z", use "case x of { FalseTerm -> y; _ -> z }"
06:26:51 <solarus> ph88: you can also try cabal --version
06:27:17 <solarus> it should say it's using the 1.20... cabal version
06:27:44 <solarus> if its not then you probably need to add ~/.cabal/bin to your path
06:27:51 <solarus> probably :)
06:28:15 <farmerworking> this means I need to introduce a function to do pattern matching. Is that right?
06:28:30 <ph88> solarus: http://pastebin.com/MDjG3Ad5
06:28:37 <Hafydd> No, not necessarily. It doesn't require any additional function to be introduced.
06:28:57 <Hafydd> You can pattern-match using a case expression.
06:28:58 <solarus> ph88: then try to run ~/.cabal/bin/cabal install cairo
06:29:08 <mroman_> farmerworking: you can. but you don't need to if you use a case
06:29:21 <mroman_> farmerworking: http://codepad.org/brTvNk4Q
06:29:24 <mroman_> ^- like in line 12
06:29:37 <solarus> if that doesn't work you need to run "cabal install cabal-install" first :)
06:29:41 <hexagoxel> man, why is Data.Map.Lazy.Map == Data.Map.Strict.Map?
06:29:42 <bergmark> farmerworking: top level declarations desugar to use case expressions
06:29:44 <michaelt> ph88: it may work if you emend line 51 to read
06:29:45 <michaelt>                         bytestring, mtl, array, Cabal==1.20.*
06:29:55 * hexagoxel just used strict methods on a map that i thought was lazy
06:30:09 <farmerworking> thanks, I need give it a try
06:30:45 <bergmark> hexagoxel: it's the same data type, just different interfaces to it
06:30:56 <mroman_> farmerworking: *technically* you can also do this: http://codepad.org/x091Rbom
06:31:02 <ph88> solarus: ➜  ~  ~/.cabal/bin/cabal install cairo zsh: no such file or directory: /home/philippe/.cabal/bin/cabal
06:31:19 <michaelt> ph88: oh interesting, your newer cabal is not the first one in path, maybe if you just change that it will go well
06:31:30 <solarus> ph88: yea you need to install the latest version of cabal first then it will work
06:31:47 <solarus> or cabal-install that is
06:31:49 <mroman_> (that also works if you have other data constructors as well: http://codepad.org/eeNjnKP4)
06:32:06 <michaelt> solarus: but strangely he already has a recent version of the library...
06:32:12 <hexagoxel> bergmark: yeah, i am aware.
06:32:21 <solarus> michaelt: hmm strange
06:32:22 <michaelt> maybe he did 'cabal install cabal' and not 'cabal install cabal-install'
06:32:26 <farmerworking> Is there a way to do pattern match with the value computed in where expression
06:32:40 <farmerworking> without use case or introduce a function
06:32:49 <hexagoxel> bergmark: but it feels unnecessarily non-type-safe
06:33:31 <bergmark> farmerworking: x + y where (x,y) = (1,2)
06:33:55 <michaelt> ph88: what happens if you do "cabal install cabal-install --dry-run" ?
06:34:43 <brisbin> i have a package on hackage where a build of 0.0.1 failed because my version constraints were wrong (http://hackage.haskell.org/package/load-env-0.0.1/reports/1/log), i quickly pushed 0.0.2 which added base >= 4.7 which should fix this build failure, but hackage has no build reports for 0.0.2 (or newer) which i take to mean it hasn't attempted to build the newer versions -- is there a reason for this? or a
06:34:45 <brisbin> way to trigger it to try again?
06:35:01 <farmerworking> No, it's something like that (let (t' (eval t)) ...)
06:35:14 <farmerworking> and do pattern match on t'
06:35:27 <albeit> Would an IntMap be significantly faster than a Map (Int,Int)?
06:35:39 <mroman_> farmerworking: What do you want to do?
06:36:13 <Intolerable> albeit: do u mean faster than a Map Int Int?
06:36:17 <mroman_> also that looks like Lisp-Code.
06:36:31 <albeit> Intolerable: No, IntMap a vs Map (Int,Int) a
06:37:02 <farmerworking> mroman_:  I will come up a demo
06:37:05 <albeit> Trying to decide wheter I want to convert a key like (5,6) to a single Int, or just use a map with that as a key
06:40:10 <farmerworking> 	case t' of
06:40:10 <farmerworking> 		ZeroTerm -> ZeroValue
06:40:10 <farmerworking> 		(SuccValue t'') -> t''
06:40:12 <farmerworking> 	where t' = eval t
06:40:59 <farmerworking> That' what I want to do
06:41:25 <ph88> michaelt: i did do:  cabal install cabal    and not    cabal install cabal-install
06:41:54 <michaelt> oh, you need to install cabal-install, else there's not much point in having the new version of the Library, ph88
06:42:38 <ph88> michaelt: http://pastebin.com/1vhPiZ56
06:43:08 <ph88> michaelt: ok i did    cabal install cabal   by Cale his advice ^^   ..  i will try    cabal install cabal-install   now
06:43:10 <michaelt> ph88: does ghc-pkg list HTTP show another http installed
06:43:32 <ph88> just 1
06:43:44 <mroman_> farmerworking: that should work. of course it's the same thing as writing case (eval t) of
06:43:51 <mroman_> which I would actually prefer ;)
06:44:03 <ph88> michaelt: http://pastebin.com/QrdGLjfe
06:44:18 <mroman_> case (eval t) of { ZeroTerm -> ZeroValue; SuccValue t' -> t'; }
06:44:19 <solarus> mroman_: I think he doesn't want to use the case match for some reason
06:44:49 <farmerworking> mroman_: However I wonder is there any instanceof like java to do that
06:45:12 <farmerworking> mroman_: Just to learn more about Haskell
06:45:31 <michaelt> ph88: oh so you will end up with 2 HTTPs now, I can't say I like this... but you might just get rid of the new one once you have built the cabal-install executable. i think that makes sense
06:45:35 <solarus> farmerworking: maybe you want to look at viewpatterns?
06:45:59 <michaelt> ph88: is this the new version of the haskell platform?
06:45:59 <mroman_> farmerworking: there's no instanceof but there's at least 3 different ways of achieving that exact thing
06:46:12 <mroman_> you can use pattern matching on function level, in a case
06:46:18 <mroman_> you can even use (==)
06:47:11 <farmerworking> mroman_: to use ==, I have to derive Eq. right?
06:47:29 <mroman_> yes.
06:47:40 <mroman_> derive Eq or write an instance for it yourself
06:47:52 <the_other_cat> Hey there. Sorry for whining, but i'm a bit fed up by constant problems (broken packages after installing something via cabal). Right now i've got a bazillion broken packages reported by ghc-pkg check. I tried to whipe everything out by reinstalling haskell-platform, ghc and cabal-install via apt-get but after reinstalling ghc-pkg reports the same state :( How can i end this mess?
06:47:57 <mroman_> however, SomeInt == (SomeInt 5) doesn't work then ;)
06:48:20 <ph88> michaelt: i think im using the older version of the haskell platform ... but im not sure on how to check the version number
06:48:26 <farmerworking> the default behaviour of == is structure compare or return true if it's the same type
06:48:36 <Intolerable> the_other_cat: did u wipe ur ~/.ghc
06:48:38 <farmerworking> or instance compare
06:48:51 <zerokarmaleft> the_other_cat: I'd recommend using sandboxes
06:48:57 <mroman_> farmerworking: compare structure
06:49:06 <ph88> michaelt: i don't know how to uninstall the new version of HTTP .. but if it's not a problem  i'm ok with just leaving it installed
06:49:09 <michaelt> ph88: it doesn't matter, i think the current plan of installing 'cabal-install' but then unregistering the new HTTP should be fine
06:49:17 <mroman_> mainly because the type is the thing right after "data"
06:49:22 <mroman_> i.e data Foo = Bar | Baz Int
06:49:24 <Intolerable> i'd also recommend not installing ghc etc. from apt
06:49:25 <mroman_> Baz Int is of type Foo
06:49:31 <farmerworking> mroman_: Ok I get it
06:49:39 <mroman_> > data Foo = Bar | Baz Int
06:49:39 <farmerworking> mroman_: thanks. back to coding
06:49:40 <lambdabot>  <hint>:1:1: parse error on input ‘data’
06:49:45 <mroman_> > let data Foo = Bar | Baz Int
06:49:46 <lambdabot>  <hint>:1:5: parse error on input ‘data’
06:49:55 <mroman_> I don't remember how that works with lambdabot
06:50:00 <michaelt> ph88: ghc-pkg unregister HTTP-<version-number>  It may not matter, keep it in mind if you get troubule though
06:50:06 <exio4> @let data Foo = Bar | Baz Int
06:50:08 <lambdabot>  Defined.
06:50:11 <zerokarmaleft> Intolerable, the_other_cat: there's a good PPA if you're on ubuntu
06:50:13 <mroman_> @type (Baz Int)
06:50:14 <lambdabot>     Not in scope: data constructor ‘Int’
06:50:14 <lambdabot>     Perhaps you meant one of these:
06:50:14 <lambdabot>       ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
06:50:17 <mroman_> @type (Baz 5)
06:50:18 <lambdabot> Foo
06:50:36 <michaelt> ph88: even sandboxes will see and prefer the HTTP in the global ghc-pkg registry or whatever you call it
06:50:36 <ph88> michaelt: ok    cabal install cabal-install    has finished, what should i do now ?    cabal --version  still shows the old cabal version
06:51:03 <Intolerable> zerokarmaleft: i havent used ubuntu in a while but i remember installing haskell shit w/ apt was horrendous
06:51:11 <michaelt> ph88: yes, /usr/bin or /usr/local/bin are ahead of ~/.cabal/bin in $PATH
06:51:51 <the_other_cat> Intolerable: Thanks, i did this, which seems to end my problems for now. By the way, whats located in ~/.cabal/ ? It has 1.5G
06:52:28 <mroman_> of course, you can always abuse Show to do stuff
06:52:41 <mroman_> http://codepad.org/Gx0EiQ1W <- like that
06:52:48 <Intolerable> the_other_cat: iirc its cached versions of packages and docs and bins and whatnot
06:52:50 <mroman_> but now people will throw rotten fruit at me *hide*
06:53:01 * Hafydd throws rotten fruit at mroman_!
06:53:07 <michaelt> ph88: there is the usual range of options, I just have export PATH = <local cabal bin path>:$PATH in my .profile  thingy
06:53:27 <zerokarmaleft> the_other_cat: bitemyapp's guide and links on platformless haskell has largely reduced my cabal headaches to nil, fwiw https://github.com/bitemyapp/learnhaskell#getting-started
06:53:49 <ph88> michaelt: yes i have put that command in my .zshrc file
06:53:51 <mroman_> > (read$(show 5))::Double
06:53:53 <lambdabot>  5.0
06:54:38 <michaelt> ph88: well now open a new terminal and see what happens with cairo.  It may be that we still need to edit the line i mentioned above, but it may just work
06:55:22 <ph88> michaelt: your commands worked it no longer has a problem with the SetupWrapper  http://pastebin.com/Z7QuPp1s   however i do seem to miss some packages
06:55:58 <michaelt> you need to install gtk2hs-buildtools
06:56:14 <ph88> is that a system package ?
06:56:36 <ph88> ill search for it with apt-cache search
06:56:50 <michaelt> no its just some little executables that do stuff like check the gtk version and so on
06:57:09 <michaelt> ph88: just cabal install gtk2hs-buildtools
06:59:39 * hackagebot abeson 0.1.0 - interconversion between aeson and bson.  http://hackage.haskell.org/package/abeson-0.1.0 (HirotomoMoriwaki)
07:00:02 <the_other_cat> Thanks for the link, i will definetly check it out. I really dig haskell but i seem to have major problems with the ecosystem around it.
07:01:13 <Intolerable> using sandboxes for EVERYTHING is very helpful
07:02:18 <the_other_cat> I will inform myself about that. Thanks for your comments!
07:03:02 <ph88> michaelt: problem with gtk2hs is fixed http://pastebin.com/LvdgRuAc
07:05:22 <michaelt> ph88: well that *is* as system package ! ... I have pkg-config --version / 0.28
07:07:14 <vanila> hello
07:07:29 <vanila> is there anything like STT (ST transformer) which works with nondeterminism?
07:08:10 <ski> i don't think so
07:08:14 <ph88> michaelt: i only have that here   ./usr/share/bash-completion/completions/pkg-config    so i guess it's not installed
07:08:18 <benzrf> so i had some thoughts about Pipes
07:08:33 <ski> however, if you want backtracking, it's possible to implement that on top of `ST s' or `IO' style references
07:08:36 <MagneticDuck> pipes are like wires that carry streams
07:08:38 <benzrf> it's definitely a functor in the output arguments, and it's definitely a contravariant functor in the input arguments
07:08:48 <benzrf> im less sure about other things
07:08:48 <michaelt> ph88: I'm a bit out of my depth with pkg-config
07:08:54 <benzrf> i THINK it is monadic in the output arguments
07:09:03 <ski> vanila : there's a paper by Seres and Spivey, iirc, and one by Claessen, which is about that
07:09:12 <hexagoxel> what magic causes hoogle to show Show/Eq as superclasses of Num?
07:09:29 <ski> hexagoxel : previously, they were
07:09:32 <vanila> I use StateT Logic right now
07:09:35 <benzrf> and i thiiiiiiiiiiiink it's a little bit comonadic in the input arguments
07:09:38 <vanila> but I need that extra power that ST gives you
07:09:40 * hackagebot memcached-binary 0.2.0 - memcached client using binary protocol.  http://hackage.haskell.org/package/memcached-binary-0.2.0 (HirotomoMoriwaki)
07:09:44 <vanila> multiple mutable cells of different type
07:09:50 <ski> vanila : right
07:09:51 <vanila> I will check those papers, thank you!
07:10:03 <edwardk_> a little bit comonadic?
07:10:21 <ski> vanila : i made a project for a course which built on those papers :)
07:11:05 <michaelt> edwardk_ is a little bit comonadic , sure, but pipes ?
07:11:43 * ski . o O ( edwardk_ is a little bit comonadic ? .. i suppose so )
07:11:46 <hexagoxel> ski: and in the 2010 report they still are. that does not answer my question.
07:12:33 <ski> hexagoxel : .. i would suppose it shows superclasses according to the definitions that it knows about
07:12:41 <ph88> michaelt: i think it's not a problem with pkg-config .... because it said the  pkg-config PACKAGE cairo  version could not be found ... so it's about the cairo version that i specified i think
07:13:06 <michaelt> ph88: oh you did apt-get cairo or whatever
07:13:11 <ph88> hhmmm but even if i don't specify the cairo version number it goes wrong
07:13:14 <ph88> no no
07:14:02 <ph88> michaelt: http://pastebin.com/jPXxDYMh
07:14:45 <hexagoxel> ski: ah, and because hoogle knows about base-4.3.0.0 (or one of those), it keeps the connection? indeed, that is a possiblity, thanks.
07:15:46 <michaelt> ph88: this suggests that you need to install the cairo c lib with your package manager
07:16:24 <michaelt> ph88: unless maybe you have it but gtk2hs cairo requires a supermodern version or something like that
07:17:12 <ph88> michaelt: you mean one of these packages ? http://pastebin.com/hGsswNMc
07:17:33 <ph88> maybe this one    libcairo2
07:17:46 <ph88> ill try that one ^^
07:18:06 <ph88> libcairo2 is already the newest version.   ....   hmm
07:19:07 <exio4> @pl \l -> (head l, length l)
07:19:08 <lambdabot> liftM2 (,) head length
07:20:12 <michaelt> ph88: i see the gtk2hs page says sudo apt-get install libgtk2.0-dev libgtk-3-dev   https://github.com/gtk2hs/gtk2hs
07:20:34 <solarus> ph88: try libcairo2-dev
07:20:36 <mr-> exio4: or (,) <$> head <*> length
07:20:45 <michaelt> hm, what's "cabal-meta"
07:21:43 <exio4> mr-: oh, applicative style, didn't remember
07:23:00 <solarus> :t head &&& length
07:23:00 <lambdabot> [a] -> (a, Int)
07:24:04 <michaelt> ph88: right like solarus says, I'd think, they want -dev versions clearly
07:26:17 <pjdelport> > let (·<) = flip (<$>); (>·) = (<*>) in head ·<(,)>· length $ "fnord"
07:26:19 <lambdabot>  ('f',5)
07:26:32 <Qfwfq> @src sequence
07:26:32 <lambdabot> sequence []     = return []
07:26:32 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
07:26:32 <lambdabot> --OR
07:26:32 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
07:29:11 <ph88> michaelt: thanks so much, after i did    sudo apt-get install libgtk2.0-dev libgtk-3-dev    and i tried installing cairo again everything seemed to work perfectly !
07:30:44 <michaelt> ph88: oh great.
07:31:41 <michaelt> ph88: so you have the infrastructure for whatever other gtk2hs libraries you might want
07:32:03 <ph88> cool
07:32:20 <ph88> my mission was to install  plot  to get a graph  .. cairo was one of it's dependencies
07:32:53 <michaelt> ag right
07:34:05 <michaelt> ... six hours later, and you're ready to print a histogram! ...
07:36:07 <farmerworking> hi
07:36:23 <vanila> farmerworking, hi
07:36:31 <farmerworking> data Term = TrueTerm | FalseTerm | OtherTerm
07:36:38 <doismellburning> michaelt: lol
07:36:48 <farmerworking> fun TrueTerm = Bool
07:36:59 <farmerworking> fun FalseTerm = Bool
07:37:16 <farmerworking> is there a way to combine these to a single one ?
07:37:16 <ski> `Bool' is not a value, it's a type
07:37:18 <vanila> farmerworking, You cannot write functions of type Term -> *
07:37:44 <doismellburning> farmerworking: can you try again with something real?
07:37:59 <farmerworking> type_checker :: Term -> Type
07:38:00 <farmerworking> type_checker TrueTerm = BoolType
07:38:00 <farmerworking> type_checker FalseTerm = BoolType
07:38:01 <doismellburning> farmerworking: I can't parse your pseudocode
07:38:04 <doismellburning> ok
07:38:10 <ski> farmerworking : maybe you meant to define something like `data Type = BoolType | ...', and then to say `fun TrueTerm = BoolType; fun FalseTerm = BoolType; ...' ?
07:38:23 <farmerworking> data Type =
07:38:23 <farmerworking> 	BoolType |
07:38:24 <farmerworking> 	NumType |
07:38:25 <farmerworking> 	NotMatchType
07:38:27 <farmerworking> 	deriving (Show)
07:38:29 <farmerworking> yes
07:38:33 <farmerworking> that's what I mean
07:38:41 * ski would remove the brackets around `Show', there ..
07:38:53 <ski> btw, i'd exclude `NotMatchType' there
07:38:59 <ph88> i just installed plot   but now i see Chart:  An even simpler framework for creating 2D charts in Haskell.       which one is easiest for a bigger to plot a sine wave ?
07:39:01 <glguy> You can make a data constructor named "Bool"
07:39:09 <ski> since it's not a real type, it really signifies a type error
07:39:54 <ski> @let data Type = BoolType | NumberType deriving Show
07:39:56 <lambdabot>  Defined.
07:40:02 <farmerworking> It's just an example, What I want to know is there any way to combine
07:40:39 <farmerworking> two pattern of a function which result the same result
07:40:40 <ski> @let data TypeCheckResult = Checked Type | TypeMismatch deriving Show
07:40:41 <lambdabot>  Defined.
07:41:37 <ph88> where can i find the documentation of this package?   https://hackage.haskell.org/package/plot
07:41:44 <ski> @let data Term = FalseTerm | TrueTerm | Literal Integer | Plus Term Term | GreaterThan Term Term | If Term Term Term deriving Show
07:41:46 <lambdabot>  Defined.
07:42:05 <farmerworking> I don't quite understant
07:42:35 <Intolerable> ph88: https://hackage.haskell.org/package/plot-0.2.3.1
07:42:40 <ski> @let typeCheck :: Term -> TypeCheckResult; typeCheck FalseTerm = Checked BoolType; typeCheck TrueTerm = Checked BoolType; typeCheck _ = error "not defined yet !"
07:42:42 <lambdabot>  Defined.
07:43:00 <ski> farmerworking : perhaps you'd want to do something like that ?
07:43:12 <Intolerable> should be fairly similar or u can "cabal get plot-0.2.3.2" and then "cabal haddock" to generate ur own
07:43:20 <ski> > typeCheck FalseTerm
07:43:22 <lambdabot>  Checked BoolType
07:43:38 <farmerworking> ski: I get what you mean. However can I do something similar like type_checker TrueTerm | FalseTerm = BoolType
07:43:41 <ski> > typeCheck (Plus FalseTerm (Literal 0))
07:43:42 <lambdabot>  *Exception: not defined yet !
07:43:47 <ph88> thx Intolerable
07:43:51 <coltfred> I was trying to build Haskakafka and I'm receiving errors at the command line. https://gist.github.com/coltfred/786a55ef4e332f184acf Has anyone tried to build this library?
07:43:59 <coltfred> Not sure if my last message sent so resending.
07:44:01 <coltfred> sorry.
07:44:14 <ski> farmerworking : unfortunately Haskell doesn't have disjunctive patterns, so you can't say `type_checker (TrueTerm | FalseTerm) = BoolType'
07:44:44 * hackagebot snap-core 0.9.6.3 - Snap: A Haskell Web Framework (core interfaces and types)  http://hackage.haskell.org/package/snap-core-0.9.6.3 (DougBeardsley)
07:45:19 <farmerworking> ski: So the only way is to copy and paste or do something like subtype?
07:45:19 <ski> farmerworking : you'll have to repeat the common result (`BoolType') in two separate defining equations for `type_checker'
07:45:46 <ski> farmerworking : i don't understand your question
07:46:59 <farmerworking> ski: in my situation, I have to repeat the common result or define a type for TrueTerm and FalseTerm?
07:47:42 <ski> you have already defined a type (namely `Term') for `TrueTerm' and `FalseTerm', so i don't understand the latter part
07:48:00 <ski> .. perhaps you're talking about something like :
07:48:14 <ski>   data Term = MkBoolTerm BoolTerm | ...
07:48:24 <ski>   data BoolTerm = TrueTerm | FalseTerm
07:48:30 <ski> in which case you could indeed say
07:48:46 <ski>   typeCheck (MkBoolTerm _) = Checked BoolType
07:49:19 <ski> (of course, instead of defining a new type `BoolTerm', you could here just use the ordinary Haskell type `Bool', which already has `False' and `True' as values)
07:49:28 <farmerworking> Is there union type in haskell
07:49:49 <Cale> farmerworking: Probably not in the way you're thinking?
07:49:56 <Kron> gah, had an internet hiccup. Did I actually post my hat install error?
07:50:14 <Cale> farmerworking: data types with multiple constructors give you disjoint unions of a sort
07:50:35 <Cale> farmerworking: What are you trying to do?
07:50:48 <farmerworking> I give you a example
07:51:03 <Intolerable> Kron: seems not
07:51:14 <Kron> <Kron> i'm trying to install hat and running into a recurring problem in the cabal install
07:51:14 <Kron> <Kron> trans/Environment.hs:497:13:    Not in scope: data constructor ‘PExplTypeArg’
07:51:14 <Kron> <Kron> how can I fix this? I'm not sure what's going wrong exactly
07:51:37 <farmerworking> data BoolType = FalseType | TrueType
07:51:38 <farmerworking> data OtherType = OtherType
07:51:38 <farmerworking> data Type = (union BoolType OtherType)
07:51:43 <farmerworking> how about that
07:51:56 <Kron> Either?
07:52:06 <ski> farmerworking : you could include values of a type `BoolTerm' into another type like `Term', by making a data constructor of the latter take an argument of the former type
07:52:11 <farmerworking> what about three or four cases
07:52:15 <Cale> Kron: Apparently building it against too new a version of haskell-src-exts
07:52:22 <jTT_> Hi, I am struggling with defining my own types/data here (obvs i’m a beginner). I’m trying to write parsers, and one thing will be a ‘Query’. Currently I have this (data Query = Query (Maybe [T.Text]) | NoRequest deriving (Show, Eq, Read)).  This is basically redefining Maybe. How can I just make ‘Query’ be Maybe [T.Text] | Nothing? Sorry for being inane
07:52:25 <Kron> how do I fix that, Cale
07:52:29 <ski> farmerworking : there is no subtyping, no union types, no intersection types, no refinement types in Haskell
07:52:58 <Cale> Kron: I guess fix Hat's .cabal file to set an appropriate upper bound on the version of haskell-src-exts used.
07:53:09 <farmerworking> Your way to fix this don't seems nature
07:53:10 <srhb> jTT_: type Query = Maybe [T.Text] ? Is that what you're trying to do?
07:53:12 <Cale> Kron: Or else use a commandline argument to cabal-install to add a constraint
07:53:25 <Intolerable> jTT_: u probably just want data Query = Query (Maybe [Text]) or a type synonym
07:53:30 <Intolerable> (or a newtype)
07:53:48 <farmerworking> :ski making a data constructor seems like a wrapper
07:53:50 <ski> farmerworking : you can define `data Term = MkBoolTerm BoolTerm | MkIntegralTerm IntegralTerm | MkListTerm (ListTerm Term)' and so on
07:53:55 <Cale> farmerworking: data Type = B BoolType | O OtherType
07:53:58 <ski> farmerworking : yes, it's a wrapper
07:54:02 <Kron> i'm not sure what arguments I need to set, nor appropriate upper bounds
07:54:09 <jTT_> srhb: I guess. the thing is now attoparsec complains that Query is not in scope
07:54:10 <Kron> shouldn't cabal set this already? hmm
07:54:21 <srhb> jTT_: Then do it with newtype instead
07:54:23 <Cale> farmerworking: You need that tag, or else you'd have no idea at runtime whether the value was a BoolType or an OtherType value.
07:54:28 <Kron> I guess hat is misconfigured with a bad upper bound
07:54:32 <Kron> does anyone else have a working hat?
07:54:46 * hackagebot type-level-sets 0.5 - Type-level sets (with value-level counterparts and various operations)  http://hackage.haskell.org/package/type-level-sets-0.5 (DominicOrchard)
07:54:46 <srhb> jTT_: newtype Query = Query (Maybe [T.Text])
07:54:56 <farmerworking> :ski Is there any official documentation about why haskell not support union type or all other thing?
07:55:12 <srhb> jTT_: That is, if you really want to be able to pattern match on the Query constructor (and have it be a different type from Maybe [T.Text])
07:55:15 <Cale> Kron: You can go through the old versions of haskell-src-exts on hackage and use the documentation index to find the latest one which defines that symbol.
07:55:47 <srhb> jTT_: You can't have it both ways. :)
07:55:51 <Cale> farmerworking: Well, suppose you had a value like FalseType, which type should be inferred for it?
07:56:11 <jTT_> srhb: thanks!
07:56:16 <srhb> jTT_: Sure.
07:56:25 <Cale> farmerworking: In the presence of your union type, it would be ambiguous: we wouldn't know whether it was intended to be BoolType or Type
07:57:16 <ski> farmerworking : type inference gets real complicated in the presence of subtyping
07:57:24 <Cale> farmerworking: The damage that subtyping and union types do to type inference and polymorphism is generally regarded as not worth it.
07:58:01 <farmerworking> I get what you mean
07:58:44 <mroman_> what's a "union type"?
07:58:45 <Cale> Look at the complications surrounding what Java calls generics for instance -- you have to care about variance of type constructors
07:58:48 <mroman_> like C unions?
07:58:57 <farmerworking> :) maybe when I know more about type inference will have another chat with you guys
07:59:12 <farmerworking> thanks
07:59:55 <Cale> farmerworking: Like, if you have some type constructor T, and some types A and B with A being a subtype of B, then is T A a subtype of T B, or the other way around, or neither?
08:00:10 <Cale> Oh, he left
08:00:15 <mroman_> yep
08:00:43 <Iceland_jack> mroman_: Yes, like sum types in Haskell but without the tags
08:00:57 <mroman_> I think he tries to "emulate" concepts of Java (presumingly?) in Haskell
08:01:10 <ski> it's hard to say
08:01:12 <Kron> hmmmm
08:01:21 <Kron> hat's developer hasn't been on github in around 2 years I think
08:01:23 <jTT_> Intolerable: thanks too!
08:01:38 <Kron> it looked so useful too :(
08:01:44 <vanila> hi Kron :)
08:01:52 <Kron> hi vanilla
08:02:05 <oisin212> Should I ever be worried about testing my data types - or should I only ever focus on functions?
08:02:35 <Intolerable> i test instances of shit like FromJSON
08:02:43 <yukko> how does one test a datatype exactly...
08:02:47 <mroman_> I don't know what his "union types" we're supposed to be for
08:03:02 <mroman_> or what they are supposed to do
08:03:43 <oisin212> yukko: I couldn't think of any examples, but I wasn't sure if it was just an oversight on my part
08:04:47 * hackagebot snap-server 0.9.4.5 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.9.4.5 (DougBeardsley)
08:04:52 <Kron> anyway, gtg. Thanks for everyone's help
08:06:50 <yukko> oisin212 well what I do is I just figure out my datatypes and then I write whatever it is I'm trying to write, and if my datatypes seem difficult to use or don't have enough information then I can change them
08:07:16 <yukko> but I don't really think there's anything to discretely test about the datatypes themselves
08:09:38 <yukko> they're kind of correct by definition - you can think of datatypes as your model or specification, which your functions are supposed to conform to
08:10:28 <oisin212> yukko: I see - thank you :)
08:10:50 <ski> well .. sometimes you replace you data type by one which makes the code you're writing more efficient
08:11:01 <ski> s/replace you/replace/your/
08:11:27 <nicoo> ski: s,e/y,e y/
08:12:06 <ski> ty
08:13:29 <pqmodn> @pl (\f g x -> f x (g x))
08:13:29 <lambdabot> ap
08:14:09 <hc> aha! /win 22
08:14:13 <hc> sry
08:14:58 <oisin212> ski: But I think that still only affects whatever functions make use of the data type
08:15:38 <ski> yes (directly or indirectly)
08:16:27 <nicoo> hc: Win32 is so much better :>
08:20:05 <dfeuer> http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Applicative.html says "As a consequence of these laws, the Functor instance for f will satisfy   fmap f x = pure f <*> x". I really don't see how that could be, when none of those laws mention fmap.
08:20:45 <vanila> http://gup.ub.gu.se/records/fulltext/99880.pdf
08:20:50 <vanila> To get full static typing we need to use the Haskell extensiTo get full static typing we need to use the Haskell extensions of
08:20:50 <vanila> quantied types and the ST-monadons of
08:20:50 <vanila> quantied types and the ST-monad
08:21:00 <vanila> But im worried about the STT monad
08:21:08 <vanila> http://hackage.haskell.org/package/STMonadTrans-0.2/docs/Control-Monad-ST-Trans.html
08:21:14 <vanila> The reason is that the will be duplicated across the different answers and this cause Bad Things to happen
08:21:23 <vanila> "This monad transformer should not be used with monads that can contain multiple answers, like the list monad"
08:21:28 <vanila> So I can't use STT Logic can i?
08:21:30 <hc> nicoo: haha
08:21:52 <monochrom> LogicT (ST s) may be much safer
08:22:09 <monochrom> STT has the same problems as IOT
08:22:09 <ski> "The reason is that the will be duplicated across the different answers and this cause Bad Things to happen" ?
08:22:26 <vanila> monochrom, but for a logic language I think that I can't use that, I need variables set to roll back
08:22:28 <doismellburning> dfeuer: I think the wording is slightly poor
08:22:35 <vanila> roll back on backtracking
08:23:00 <monochrom> yikes. but STT s Logic will not roll back either.
08:23:00 <ski> vanila : so define it to roll back ?
08:23:06 <doismellburning> dfeuer: i.e. it presupposes you reading http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Monad.html#t:Functor which doesn't seem totally unreasonable
08:23:06 <vanila> ski - I don't know exactly the problem but I understand that I shouldn't use STT Logic
08:23:15 <vanila> Right now I use StateT Logic, and it's perfect except for one thing
08:23:21 <Cale> I don't even understand why STT exists
08:23:25 <vanila> I can't have typed unification since I only have on cell
08:23:27 <vanila> one* mutable cell
08:23:45 <vanila> I can't make a hetrogenous store of data without having a closed universe or using unsafeCoerce
08:23:56 <vanila> so I need the extra typing power of something like ST
08:24:20 <ski> vanila : `data LogVar ref a = Free | Bound a | Alias (ref (LogVar ref a))' ?
08:24:34 <ski> where `ref' can be instantiated to `IORef' or `STRef s', as desired
08:24:43 <vanila> ski, yes like that
08:24:49 * hackagebot heist 0.13.1.2 - An Haskell template system supporting both HTML5 and XML.  http://hackage.haskell.org/package/heist-0.13.1.2 (DougBeardsley)
08:24:56 <vanila> Cale, Molog uses STT but I'm worried about the safety
08:25:13 <ski> vanila : hm, i thought Molog was implemented in Prolog ..
08:25:16 <vanila> https://github.com/acfoltzer/Molog/blob/master/src/Molog.hs
08:25:19 <Cale> vanila: Yeah, it's just dangerous for no good reason
08:25:20 <vanila> newtype Molog s a = M { unM :: STT s Logic a }
08:25:21 <ski> (or is this a different Molog ?)
08:25:27 <vanila> it must be a different one ski
08:25:32 <vanila> this is related to minikanren I think
08:26:14 <MagneticDuck> !!!! (const putStrLn "why is this not workinggggg" <$> return undefined) !!!!
08:26:22 <MagneticDuck> I'm about to learn something new about how haskell deals with IO
08:26:28 <Guest7194> anyne using haskell-mod from brew?
08:26:31 <Guest7194> is it updated?
08:26:32 <ski> vanila : "MOLOG - a tool for non-classical logic programming" <http://www.irit.fr/ACTIVITES/EQ_ALG/Herzig/molog.html> is the one i know about
08:26:35 <vanila> Is there an STM transformer?
08:26:44 <vanila> maybe STM could be more useful than STT?
08:26:46 <vanila> safer*
08:26:51 <monochrom> no, that's even worse than STT and IOT
08:27:01 <vanila> or perhaps one could implement msplit with STM?
08:27:04 <Cale> Why are you looking for a transformer of this?
08:27:07 <vanila> monochrom, ah, thanks
08:27:08 <Cale> LogicT exists
08:27:14 <Qfwfq> MagneticDuck: or precedence
08:27:18 <Cale> and it's actually a monad transformer
08:27:23 <vanila> Cale, LogicT State means that the state is not undone after backtracking
08:27:30 <MagneticDuck> Qfwfq: hm
08:27:33 <vanila> but with StateT Logic, when it backtracks it undoes state changes
08:27:40 <ski> @type const putStrLn "why is this not workinggggg" <$> return undefined
08:27:41 <vanila> so im not able to use LogicT, I think
08:27:41 <lambdabot> (Functor f, Monad f) => f (IO ())
08:27:43 <Qfwfq> :t const putStrLn
08:27:44 <lambdabot> b -> String -> IO ()
08:28:06 <MagneticDuck> ah
08:28:16 <MagneticDuck> so, join
08:28:21 <MagneticDuck> right.
08:28:32 <MagneticDuck> not sure why I used fmap and not bind
08:28:35 <monochrom> IOT (STT s (STMT IO)) -- tackling the new awkward squad XD
08:28:41 <Cale> vanila: Yeah, okay, but anything like ST which uses real mutation isn't going to interact nicely with backtracking either.
08:28:45 <vanila> monochrom, haha
08:29:08 <dfeuer> doismellburning, I don't see how the Functor laws combined with those other laws can get you to an equation with fmap on one side and pure and <*> on the other side. Unless I'm missing something, there's an underlying assumption somewhere here that is not being stated.
08:29:13 <Cale> monochrom: Maybe throw in a ListT just to make it really broken
08:29:16 <dfeuer> Of course, I could be missing something.
08:29:21 <vanila> Cale, ST gives us two things - of which I only need one
08:29:25 <ski> vanila : `data Logic m a = L (forall o. ({- success -} a -> m o -> m o) -> ({- failure -} m o) -> m o)'
08:29:31 <vanila> * ST gives a pure interface to mutable state
08:29:40 <vanila> * ST gives a hetrogenous store of types
08:29:48 <vanila> so I only need the second one
08:29:52 <Cale> vanila: It only does the former?
08:29:54 <vanila> StateT gives me only a single mutable cell
08:30:09 <vanila> ST lets us implement e.g. well typed unification
08:30:12 <vanila> that you cannot do with State only
08:30:30 <vanila> I don't need the internal mutation stuff - that's just an optimization
08:30:34 <vanila> I only need the hetrogenous store
08:30:57 <vanila> and I can simulate that on a closed universe using GADTs but I want to have an open universe (without unsafe functions)
08:31:06 <Cale> I'm not sure I understand what you mean about the heterogeneous store -- you mean the entire contents of the heap?
08:31:12 <doismellburning> dfeuer: ...good point
08:31:42 <Cale> vanila: Perhaps you're looking for Dynamic/Typeable?
08:31:54 <vanila> no because those use unsafe functions
08:32:06 <Cale> Er, maybe internally they do
08:32:09 <dfeuer> doismellburning, unless ... is there a proof somewhere that a type can only have one sensible Functor instance, up to Eq? I mean, that would seem surprising, but maybe not too surprising?
08:32:16 <Cale> But the interface to Typeable is safe
08:32:17 <ski> vanila : `(\/) :: Monad m => Logic m a -> Logic m a -> Logic m a; L g0 \/ L g1 = L (\exit fail -> g0 exit (g1 exit fail))', &c.
08:32:24 <Cale> as well as Dynamic
08:32:26 <doismellburning> dfeuer: that exists iirc
08:32:44 <Cale> vanila: ST's implementation is obviously unsafe internally as well
08:32:51 <dfeuer> doismellburning, how would one prove such a thing?
08:33:00 <vanila> you have a point but :(
08:33:05 <Cale> Look at how runST works :P
08:33:35 <vanila> I don't want to use unsafe functions
08:33:38 <Cale> huh?
08:33:47 <doismellburning> dfeuer: er pass, sorry; it's been a while since I had to do anything like that
08:33:58 <Cale> If (safe) coerce counts as an unsafe function, then surely runST should as well.
08:34:10 <Cale> :t coerce
08:34:11 <lambdabot> (Contravariant f, Functor f) => f a -> f b
08:34:20 <Cale> er
08:34:51 <Cale> oh, right, cast
08:34:53 <Cale> :t cast
08:34:54 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
08:35:09 <vanila> so I think there is an expressivity problem with haskell
08:35:16 <Cale> What?
08:35:29 <vanila> I can't re-implement ST in a pure way without unsafe functions
08:35:53 <vanila> the type system stops me
08:35:55 <Cale> Why would you expect to be able to?
08:36:15 <vanila> I know that I can't do it
08:36:22 <vanila> but I need to
08:36:44 <Cale> Well, you can implement ST in a pure way with no unsafety if runST produces an IO action
08:36:54 <vanila> oh using IO refs?
08:37:03 <Cale> Yes
08:37:14 <Cale> Well, just as a free monad
08:37:16 <vanila> I don't think I can justify IOT Logic though
08:37:27 <Cale> With an IO interpretation using IORefs
08:37:30 <vanila> maybe FreeIOT Logic? And the intrepret it into IO somehow? I really don't know
08:38:03 <Cale> I don't know what FreeIOT is
08:38:07 <Cale> But it sounds odd
08:38:26 <vanila> well you mentioned using free monad
08:38:48 <Cale> There's no need for IOT
08:39:10 <vanila> will I still be able to get mutation to rollback when backtracking occurs?
08:39:23 <Cale> What I would do is just to work out what the operations in the language were and use either a finally tagless or GADT representation of that
08:39:29 <Cale> and then write interpreters
08:39:54 <Cale> If your language makes sense at all, it shouldn't be hard to write an interpreter for it in IO
08:41:42 <osfameron> even if your language doesn't make sense, it should be possible (see perl6 ;-)
08:42:12 <Cale> Well, perl 6 was probably a bit of a challenge :)
08:43:05 <dfeuer> Cale, do you know if there can only be one valid Functor instance for a type, up to Eq? If so, do you know where I could find a proof?
08:44:06 <Cale> dfeuer: It's probably true due to parametricity, but not true without it
08:44:28 <dfeuer> Cale, sounds like Deep Magic.
08:44:51 * hackagebot effect-monad 0.6 - Embeds effect systems into Haskell using parameteric effect monads  http://hackage.haskell.org/package/effect-monad-0.6 (DominicOrchard)
08:47:54 <hexagoxel> how do i name the function with type "Monad m => (a1 -> EitherT e m a) -> [a1] -> m (Either e [a])"
08:48:36 <monochrom> dfeuer: similarly, your previous question about fmap f x = pure f <*> x may also be answered by parametricity, IIRC
08:49:01 <monochrom> someone even posted a proof on lpaste
08:49:44 <dfeuer> monochrom, those are the same question. (pure f <*>) obeys the functor laws, so if there can only be one function that does, it must be that.
08:50:19 <monochrom> I see, yeah
08:50:27 <dfeuer> monochrom, someone posted a proof on lpaste?
08:50:45 <monochrom> yeah! IIRC. but I don't know how to find it.
08:51:09 <monochrom> well, I'm googling "site:lpaste.net pure fmap" for now
08:51:58 <dfeuer> Cale, why does coerce count as an unsafe function? Is that needed because some things inferred as representational are intended to be nominal but not (yet) annotated so?
08:53:40 <dfeuer> monochrom, the proof that (pure f <*>) works is trivial. It's the uniqueness thing that seems tricksy.
08:54:09 <monochrom> yes, the proof is about uniqueness
08:54:43 <Intolerable> hexagoxel: isnt that just runEitherT . mapM?
08:55:41 <Intolerable> rather \f -> runEitherT . mapM f
08:55:52 <Intolerable> no clue what to call it tho
08:56:00 <vanila> How do we use parametricity
08:56:11 <vanila> fmap :: forall a b. (a -> b) -> (f a -> f b)
08:56:16 * dfeuer is rereading Gill and Hutton's "The worker/wrapper transformation" now that he's actually seen worker/wrapper in practice, and it makes a little more sense now!
08:56:49 <Cale> dfeuer: Sorry, I was actually thinking of cast, and it doesn't count as unsafe, I was trying to understand what vanila was saying about not wanting to use unsafe functions.
08:56:54 <ski> vanila : free theorems is the most well known application
08:58:29 <dfeuer> @free (a -> b) -> (f a -> f b)
08:58:29 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
08:59:53 * hackagebot snap 0.13.2.9 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.13.2.9 (DougBeardsley)
09:00:07 <ski> @free fmap :: (a -> b) -> (F a -> F b)
09:00:07 <lambdabot> g . h = k . f => $map_F g . fmap h = fmap k . $map_F f
09:00:34 <vanila> hmm
09:00:34 <vanila> lol
09:00:38 <vanila> its trivial
09:01:00 <hexagoxel> Intolerable: \a b -> sequence <$> mapM (runEitherT . a) b
09:02:02 <oisin123> Does anyone know if there are any Haskell libraries for loading Collada animations / meshes?
09:02:13 <oisin123> The ones I find only seem to load lights, cameras, and scenes.
09:02:18 <lpaste> Cale pasted “An example using MonadPrompt” at http://lpaste.net/110885
09:02:26 <Cale> vanila: ^^ have a look at that
09:03:23 <Cale> vanila: I should probably have included an example, but the idea is you can just write actions using newRef/readRef/writeRef in the obvious way, and then choose to interpret them using ST or IO as you please
09:04:19 <vanila> Cale: Thank you very much im reading it
09:06:41 <Cale> vanila: So, if you wanted to get rid of WriteRef, you could easily do so :)
09:07:05 <vanila> Cale, I'm just lookking at the prompt stuff on hackage - is this related to exteff at all?
09:07:15 <Cale> This is using the MonadPrompt package
09:07:51 <bergey> oisin123: http://hackage.haskell.org/package/graphics-formats-collada looks like it loads meshes, but I haven't used it. Have you tried it?
09:07:55 <Cale> vanila: I don't know what exteff is
09:07:57 <Intolerable> hexagoxel: arent \f xs -> runEitherT $ mapM f xs & \a b -> sequence <$> mapM (runEitherT . a) b the same
09:08:17 <Cale> vanila: But MonadPrompt is basically free monads
09:08:19 <vanila> Cale, oh okay just some thing i read that splits off the 'effect' part of a monad in a simialr way to this
09:08:27 <vanila> http://www.cs.indiana.edu/~sabry/papers/exteff.pdf
09:08:38 <vanila> so this is really interesting I will try it o ut
09:08:48 <vanila> except monadpromptT
09:09:15 <Cale> vanila: Yeah, and you get a transformer here, which is an honest to goodness monad transformer
09:10:32 <Cale> Not some hackery like STT
09:10:42 <vanila> wonderful :D
09:10:54 <Cale> (but runPromptT is much harder to use, I'll admit!)
09:11:59 <Cale> vanila: It's basically one of the eighty kajillion ways people have come up with for separating representation of computations from their interpreters.
09:12:10 <vanila> ok :)
09:13:30 <hexagoxel> Intolerable: oh, you are right, neat! (that's still (runEitherT .).mapM)
09:13:35 <Cale> The 'free' package provides very similar capabilities, and then there are approaches which just use type classes, like this: http://okmij.org/ftp/tagless-final/JFP.pdf
09:15:20 <Intolerable> hexagoxel: no idea what u should actually call it but its shorter
09:18:18 <hexagoxel> ill go with runEitherTmapM :)
09:18:38 <hexagoxel> i spend way too much time thinking about names for such generic functions
09:29:56 * hackagebot haskell-formatter 0.1.0 - Haskell source code formatter  http://hackage.haskell.org/package/haskell-formatter-0.1.0 (evolutics)
09:31:52 <Qfwfq> @src liftM2
09:31:52 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
09:35:02 <vanila>     No instance for (MonadPrompt (RefOps ref0) [])
09:35:02 <vanila>       arising from a use of `liftP'
09:35:19 <vanila> Cale, should I write a monad instance?
09:36:00 <Cale> vanila: I'd have to see what you're trying to do
09:36:06 <Cale> vanila: But probably not
09:36:42 <Cale> vanila: Oh, that indicates that you're trying to use a list as if it were an instance of MonadPrompt, in which case, you're doing it wrong :P
09:37:16 <Cale> vanila: You probably don't want liftP there at all
09:37:23 <vanila> ah
09:37:25 <vanila> thanks
09:37:34 <vanila> im confused about how to built PromptT actions
09:37:40 <vanila> I managed to implement interpretTIO :: PromptT (RefOps IORef) [] a -> IO [a]
09:37:58 <vanila> (although I think its not correct yet)
09:38:06 <Cale> Maybe you just wanted lift?
09:39:59 <Cale> :t lift
09:40:00 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
09:40:10 <vanila> thank you I assumed i shouldnt use lift!
09:40:42 <Cale> Well, there wouldn't be much point in calling it a monad transformer if it didn't have lift :)
09:42:36 <augur> hm.. i think there might be a way to do equational unification without actual equations
09:43:46 <augur> it would have to be in the state monad, but i think it could be done. hmm
09:43:56 <augur> and you could make it look like equality tests as a result
09:44:43 <augur> unify (Foo x y) (Foo x' y') = unify x x' <&&> unify y y'
09:44:58 * hackagebot markdown 0.1.10 - Convert Markdown to HTML, with XSS protection  http://hackage.haskell.org/package/markdown-0.1.10 (MichaelSnoyman)
09:45:09 <pqmodn> looks like an equation to me. what do you mean?
09:45:27 <augur> pqmodn: the general algorithm for unification looks something like this:
09:46:04 <augur> unify ({ Foo x y =? Foo x' y' } U C) = unify ({ x =? x', y =? y' } U C)
09:46:18 <augur> abstractly
09:46:57 <augur> where you wittle down equations in C until there are no more equations that need to be broken down, just equations of the form   x =? val   or   val =? x
09:47:15 <pqmodn> right, val are constants then?
09:47:33 <augur> well, they're constructor headed patterns
09:47:34 <pqmodn> or i guess not necesarrily
09:47:35 <pqmodn> yeah
09:47:41 <augur> where x is a variable pattern
09:47:57 <pqmodn> ok, i'm following so far
09:48:41 <augur> usually you want to get out a mapping from vars to values/patterns
09:49:01 <augur> so you want to get out something like [(Var,Pat)]
09:49:15 <augur> let type Unifier = [(Var,Pat)]
09:49:48 <pqmodn> sure. i suppose you need to use that to do substitution during unification too
09:50:16 <augur> i figure you can probably just avoid this whole mess of intermediate equation sets and use   State [Unifier] () or something like that
09:51:08 <pqmodn> hmm, the equation set is C?
09:51:45 <augur> yeah
09:51:56 <augur> U was supposed to bet set union before, btw
09:53:01 <pqmodn> but isn't the equation set the input into your unification algorithm? how do you "avoid" it, or do you mean replacing elements in the set with other (sub-equation) elements?
09:53:39 <augur> pqmodn: well, the initial equation set is just   { Val1 =? Val2 }
09:54:04 <augur> so you just start with the equation for the two objects you want to unify
09:55:13 <pqmodn> oh, so are you saying you don't actually need a set of equations? i agree, you can just recursively call unify on the equations you would've added to the set
09:56:02 <augur> i think you can avoid it nicely, which still having the effect of equations
09:56:02 <pqmodn> solving in "depth-first order" rather than however using the set would've ordered the evaluation
09:56:25 <pqmodn> yeah. makes sense
09:56:36 <augur> actually i think what equations are doing is actually reifying the call stack to some degree
09:56:52 <augur> so lets think of a list instead of equations
09:56:55 <augur> er
09:56:57 <augur> instead of sets
09:57:20 <augur> my unification code looks like this when i write it:
09:57:33 <augur> unify (Foo x y :=: Foo x' y' : eqs) = unify (x :=: x' : y :=: y' :=: eqs)
09:58:22 <augur> now suppose we call this:   unify [ Foo (Bar x y) z :=: Foo (Bar x' y') z' ]
09:58:41 <augur> in one step this will become    unify [ Bar x y :=: Bar x' y', z :=: z' ]
09:58:57 <augur> and in another it will become     unify [ x :=: x',  y :=: y',  z :=: z' ]
09:59:09 <augur> now lets instead put the complex arg second
09:59:43 <augur> unify [ Foo x (Bar y z) :=: Foo x' (Bar y' z') ]   =   unify [ x :=: x' , Bar y z :=: Bar y' z' ]
10:00:11 <augur> now, if x itself were complex, it would get broken down, but the equation  Bar y z :=: Bar y' z'  would be untouched until we get rid of everything before it
10:01:04 <augur> this is like building a call stack for a genuinely recursive function like    unify (Foo x y) (Foo x' y') = unify x x' `then` unify y y'
10:01:31 <augur> because the left unification will occur, and the right unification will be put on the stack
10:02:14 <augur> hm. this is interesting
10:02:43 <pqmodn> right, you can use a "stack" of equations, or a "set", or some other discipline, because the order in which you solve the equations doesn't matter
10:02:57 <pqmodn> .... so long as there is a solution
10:03:14 <pqmodn> order can matter when you want to report errors, though.
10:03:26 <augur> yeah. but the collection of equations is itself a reification of the call stack of an actually-recursion equation-less version of the algorithm
10:03:53 <augur> actually-recursive
10:04:10 <augur> thats the interesting part
10:04:19 <augur> i wonder if thats a well-known thing
10:04:48 <augur> i really enjoy learning about reification of calls. its like magic to me
10:09:16 <hnoob> where's the implementation for >>= for List?
10:09:31 <vanila> hnoob, flip concatMap
10:09:42 <hnoob> what file is that in?
10:10:01 * hackagebot yesod-text-markdown 0.1.5 - Yesod support for Text.Markdown.  http://hackage.haskell.org/package/yesod-text-markdown-0.1.5 (ArashRouhani)
10:10:03 <vanila> oh sorry i misread you
10:10:04 <tibbe> Does State suffer from the O(n^2) behavior e.g. LogicT suffers from if the binds are nested to the left e.g. (a >>= b) >>= c?
10:10:06 <Cale> hnoob: It's in the Prelude, but if you mean in GHC...
10:10:39 <Cale> hnoob: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Base.html#Monad -- just below this point
10:11:00 <hnoob> ok cool, thx.
10:11:29 <Cale> Interesting that it's implemented directly in terms of foldr
10:11:38 <Cale> Probably there's no particular reason for that
10:12:38 <Cale> You could likely write  xs >>= f = concatMap f xs  or even  xs >>= f = concat (map f xs)  and end up with the same resulting code. The latter would require optimisations to be on though.
10:12:48 <srhb> Whoever put two spaces there needs whipping.
10:12:57 <srhb> instance  Monad []  where
10:13:09 <Cale> heh
10:13:25 <Cale> I guess it makes the 'where' line up with the one for the Functor instance
10:13:33 <srhb> just move the where though
10:13:47 <srhb>  /instance\w+Monad -- sadface
10:13:55 <srhb> Or whatever whitespace is
10:14:03 <geekosaur> \s
10:14:03 <hnoob> alignment > grepping
10:14:08 <Cale> Eh, I'm not all that bothered by it
10:14:10 <srhb> hnoob: :P
10:14:15 <geekosaur> \w is word chars
10:14:20 <srhb> geekosaur: Righto :)
10:14:27 <Cale> oh, I see, you were trying to grep :D
10:14:33 <srhb> Yes. :P
10:14:41 <srhb> And I thought "instance Monad" would do
10:14:48 <geekosaur> (also needs GNU grep -P)
10:14:55 <srhb> mumblemumble
10:15:09 <Cale> I just went to the haddock for the Prelude and clicked on the first instance of the word "Monad" that I found, and then "Source"
10:15:09 <f-a> hello #haskell, I heard someone saying (here?) that installing haskell plaftorm on, say, debian, isn't great because of system-wide packages
10:15:14 <f-a> is that correct?
10:15:29 <geekosaur> ti depends
10:15:48 <srhb> f-a: Opinions differ on that. But given that it's Debian I assume the ghc version is still running on steam or hamsters, so yeah...
10:15:50 <geekosaur> if you mostly use bleeding edge stuff like yesod, you'll need to avodi the platform; it wants its own ("stackage")
10:15:54 <f-a> and more in general, I am happy with debian but would like to keep up with ghc, (in this case, to use ghcjs and other shiny stuff), is there a suggested way of doing it?
10:16:11 <geekosaur> and there is that, that debian is almost always out of date
10:16:14 <f-a> 7.4.1 srhb
10:16:26 <srhb> Not too terrible, but 7.8 has many nice things.
10:16:34 <Cale> f-a: Just install the generic linux binary from the GHC website
10:16:56 <Cale> f-a: and then grab the tarball of cabal-install from Hackage and run the bootstrap.sh script from there
10:17:10 <srhb> And I second what Cale says. It has always caused me the least trouble.
10:17:18 <f-a> Cale: I guess you should od that *without* installing hp, right?
10:17:28 <Cale> Yeah, you don't need anything else.
10:17:43 <Cale> If you want the stuff from the Haskell Platform at that point, you can just cabal install it.
10:17:53 <f-a> mh, I have it installed
10:18:04 <f-a> I guess I should remove it before doing what you are saying?
10:18:11 <Cale> Shouldn't really matter
10:18:28 <Cale> But yeah, if you care about the disk space
10:18:37 <f-a> not really I gues
10:18:37 <f-a> s
10:22:06 <f-a> to wrap this up, should I nuke ~/.cabal before doing all that?
10:23:02 <Cale> Shouldn't be necessary
10:23:55 <Cale> Also, if you ever need to nuke your locally installed packages, it's ~/.ghc that you want to kill rather than ~/.cabal
10:24:53 <f-a> thanks
10:26:50 <Cale> (you can delete ~/.cabal too if you want, but you might want to hang on to ~/.cabal/config and ~/.cabal/bin -- I usually make the latter into a symlink to ~/bin anyway though.
10:30:21 <eyebloom> Is there an allocation overhead associated with every call to Foreign.Storable poke ?
10:31:17 <Cale> eyebloom: Well, that's a class method.
10:31:34 <eyebloom> I have what I think is a tail recursive blitting function that calls poke and plusPtr and it’s slower than I expected and has a high allocation percentage.
10:31:53 <eyebloom> Do you think there is overhead from the typeclass?
10:32:11 <Cale> Well, what it does depends on which instance you're using
10:32:41 <Cale> There won't be much overhead from the type class machinery, the instance is like an additional parameter to poke
10:33:00 <eyebloom> I see. I’m looking
10:33:27 <eyebloom> The parameter to Storable is Word32
10:33:28 <Cale> I wouldn't usually expect poke to do a whole lot of allocation.
10:34:25 <eyebloom> I was thinking that maybe the marshalling machinery is creating the issue…
10:34:58 <Cale> Well, that's going to use writeWord32OffPtr
10:34:59 <luite> eyebloom: a Ptr is a boxed object, if that doesn't get optimized out you'll get a newly allocated object for every plusPtr
10:35:18 <eyebloom> Aha
10:35:34 <eyebloom> So is there a way to work with unboxed Ptr
10:35:35 <Cale> Ah, that's a good point
10:35:53 <Cale> If you can use pokeElemOff instead, that might be better?
10:35:56 <luite> eyebloom: in particular with code in multiple modules you'll want to be careful that everything can be inlined. usually the strictness analyzer can take care of it, but only if unfoldings are avaialble
10:36:27 <Cale> Though if you're calculating indices, those values will of course involve about as much allocation :)
10:36:31 <luite> Cale: well that has the same issue since Int is a boxed object too
10:37:09 <Cale> But if you already had the indices around, it might be better
10:37:16 <eyebloom> Here is some offending code: http://lpaste.net/110888
10:37:42 <luite> eyebloom: ack that is very polymorphic
10:38:07 <eyebloom> Yeah sorry s is currently a Float
10:38:19 <eyebloom> Ortho and XDimension are newtypes
10:38:23 <luite> eyebloom: is blitActives in a different module than the one you're calling it frome?
10:38:48 <Cale> eyebloom: How is it that you're using RealFrac?
10:38:49 <eyebloom> Currently blit1 and movePtr are in different modules
10:39:28 <eyebloom> Cale: Sorry this code needs some revision there, it’s the inner loop from a rasterizer.
10:39:43 <eyebloom> I used to do more math in the inner loop
10:40:18 <luite> eyebloom: hmm i don't think blit1 is the issue here
10:40:33 <eyebloom> What about movePtr?
10:41:21 <luite> eyebloom: but manipulating that polymorphic value will likely prevent unboxing. can you replace everything with just Float? or add some specialize or inline pragma to blitActives
10:42:18 <eyebloom> I could unwrap the polymorphic values when I create the [Active s]
10:42:43 <luite> it's recursive so i'm not sure inlining directly will do much
10:43:04 <Cale> eyebloom: Which things have type s?
10:43:34 <eyebloom> Type s is currently applied to PixelSpace …  newtype PixelSpace   = PSpace {unPSpace :: Int} deriving (Num, Ord, Eq, Ix, Enum, Real, Integral)
10:44:03 <Cale> Oh, I guess x :: Ortho XDimension s and you're definitely using the Ord instance on that.
10:44:14 <eyebloom> No wait, I’m confusing myself
10:44:53 <eyebloom> s = DisplaySpace … newtype DisplaySpace = DSpace {unDSpace :: Float} deriving (RealFrac, Real, Fractional, Num, Ord, Eq)
10:45:11 <eyebloom> The rasterizer goes from DisplaySpace to PixelSpace
10:46:31 <eyebloom> And the other type involved is called Active s … data Active s = Act (Ortho XDimension s) (Ortho XDimension s) Word32 deriving (Show)
10:47:00 <eyebloom> Which is an active edge with the current position slope and color
10:47:51 <eyebloom> Basically I move down lists of edges and then blit out scanlines.
10:48:39 <eyebloom> Working pretty great, does entire page of text on one processor in about a second.
10:49:04 <eyebloom> Coming straight from TrueType outlines.
10:49:34 <eyebloom> With no caching for characters so far.
10:50:36 <RARJEF> question: if I have a type data Square = Square (Int, Int), and want to pass a list of these to a function that would normally take a type [(a,b)], why won't it, even though a Square is an encapsulated pair?
10:52:18 <RARJEF> do I need to write a function to unwrap it?
10:52:19 <simpson> RARJEF: Haskell considers them to be distinct types.
10:52:34 <simpson> You can write a function pretty easily: f (Square t) = t
10:52:46 <RARJEF> simpson: (a,b) should be generic types though?
10:52:55 <simpson> And then: map f yourListOfSquares
10:53:36 <simpson> RARJEF: Not necessarily. They can be unified with specific types for specialization.
10:53:40 <simpson> :t map
10:53:41 <lambdabot> (a -> b) -> [a] -> [b]
10:53:52 <simpson> :t map (*2)
10:53:53 <lambdabot> Num b => [b] -> [b]
10:54:13 <RARJEF> simpson: I'm getting expected type [(a0, b0)] ; actual type [Square]
10:54:36 <monochrom> have you used f?
10:55:35 <RARJEF> if I need to just write an unwrapper I can, I'm just trying to understand better. I know it's distinct types, but am not fully understanding why it doesn't allow the square to go through. Is it just strict typing?
10:55:58 <simpson> Pretty much.
10:56:06 <RARJEF> okay
10:56:27 <RARJEF> thank you
10:56:29 <S11001001> monochrom: you just sent me looking for https://en.wikipedia.org/wiki/F_%28programming_language%29
10:57:07 <monochrom> it is nominal typing (vs structural typing). structuring typing says the type's internal is used during checks. nominal typing says no.
10:57:37 <monochrom> haha S11001001
10:58:15 <RARJEF> okay. Thank you for your help
10:59:02 <monochrom> I think I haven't seen a structural typing language for a while
11:07:41 <hnoob> in LYAH it talks about lists being 'for non-deterministic' values in its monad discussion.
11:08:05 <f-a> indeed hnoob
11:08:06 <hnoob> I guess because you have more than one value at a time, like in this expression:
11:08:07 <hnoob> [1,2,3,4] >>= (\x -> ([1,2,3] >>= (\y -> [x,y])))
11:08:18 <hnoob> but the answer is entirely deterministic
11:08:22 <hnoob> ?
11:08:43 <f-a> the non-determinism here means output will not be a single value, but a list of them
11:08:46 <hnoob> determinism =? multiplicity
11:08:50 <coppro> hnoob: one way of looking at it is that the list output a number of possible values
11:09:04 <coppro> for instance, you could use the list monad to encode the computation of a non-deterministic automaton
11:09:25 <cite-reader> This is the non-determinism of computability theory, there a nondeterministic Turing machine takes every path of a branch simultaneously.
11:09:40 <cite-reader> I've never been happy with this vocabulary, but it's what we have.
11:10:06 <hnoob> seems like a different definition of deterministic from usual.  I've always thought
11:10:33 <hnoob> "deterministic" just means that hte outcome is predetermined, ie the same computation produces the same output.
11:10:59 <hnoob> sounds like this is a special definition of the word for computability theory
11:12:01 <etandel> for automaton theory, non-deterministic means that you don't know *which* path will match, but you generally don't care.
11:12:19 <etandel> (you only care if the automaton finishes or not)
11:12:26 <hnoob> so you don't 'determine' which path to take
11:12:39 <MasterMastic> But with lists don't you just take all paths?
11:12:44 <etandel> and deterministic means you do know which path it will take, because there's only one possible path.
11:14:01 <lpaste> eyebloom revised “Blitter”: “No title” at http://lpaste.net/110888
11:14:08 <eyebloom> My god, removing polymorphism from that function cut the run time and allocation time by half.
11:14:10 <etandel> well, a non-deterministic automaton theoritically takes *all* paths at the same time, so the list is being interpreted as all the possible ways a ND automaton will compute.
11:14:17 <eyebloom> See the revised version
11:14:24 <eyebloom> http://lpaste.net/110888
11:14:29 <geekosaur> MasterMastic, thats the point, and why the list monad is often called the nondeterminism monad
11:14:37 <eyebloom> Still a huge amount of allocation though
11:14:42 <geekosaur> it behaves like a non-deterministic automaton
11:15:08 * hackagebot tasty-hspec 0.2 - Hspec support for the Tasty test framework.  http://hackage.haskell.org/package/tasty-hspec-0.2 (mitchellwrosen)
11:15:10 * hackagebot UISF 0.2.0.0 - Library for Arrowized Graphical User Interfaces.  http://hackage.haskell.org/package/UISF-0.2.0.0 (dwincort)
11:15:27 <eyebloom> I’m blown away.
11:15:48 <f-a> Cale, geekosaur , srhb : one last q; having downloaded cabal-install, where do I configure it to have documentation and profiling on? I guess I have to do it before bootstrap, but don't know how
11:16:24 <Cale> In ~/.cabal/config
11:16:43 <Cale> You want library-profiling: True and documentation: True
11:17:02 <f-a> Cale: so *after* bootstrapping?
11:17:08 <geekosaur> I think f-a wants to know how to get the bootstrap dependencies of cabal-install built with them too?
11:17:16 <f-a> geekosaur: yes
11:17:27 <f-a> otherwise I'd have problems with profiling, iirc
11:17:33 <eyebloom> Is there a way to use unboxed Ptr’s in haskell?
11:17:44 <geekosaur> .cabal/config won't help for that as cabal-install can't use itself to bootstrap its dependencies
11:18:16 <luite> eyebloom: yes, but you probably don't want that. check the core first by using -ddump-simpl
11:18:56 <eyebloom> I think the remaining inefficiency I have, comes as you said from boxing and unboxing.
11:19:43 <luite> eyebloom: in most cases you can get the compiler to unbox the inner loop for you, by making arguments strict for example
11:20:21 <eyebloom> Ah, how would I specify them as strict
11:21:13 <luite> eyebloom: you can use bang patterns
11:21:32 <eyebloom> Gotcha.
11:22:04 <luite> eyebloom: i don't know if that'll do the trick here, but you can find out what the code is doing if you dump the optimized core
11:22:36 <f-a> geekosaur: aaaaaaaaand... is there a solution?
11:23:06 <geekosaur> I don't know of one. I was hoping one of the cabal devs would pipe up
11:23:35 <f-a> is there a channel for cabal? I could pester them there
11:24:30 <luite> i'm pretty sure that the bootscript script builds profiling libs too
11:24:35 <geekosaur> usually it's handled here. the question is whether anyone's around. (the cabal mailing list might be a better place to ask)
11:24:59 <luite> although it might be too new to be in 1.20
11:26:10 <eyebloom> luite: Ok, this has been a great help
11:26:42 <luite> eyebloom: oh use -dsuppress-all to get rid of some of the type noise
11:27:27 <spopejoy> Is there an easy way to concat on keys, to create a "multi-map"? Given [("a",1),("b",2),("a",3)], output [("a",[1,3]),("b",[2])] ...
11:28:03 <silver> yeah
11:28:18 <RyanGlScott> Is there a list of GHC extensions along with the versions of GHC they were introduced in? Trying to figure out the minimum version of base I need is difficult otherwise.
11:28:53 <silver> fromList/fromListWith
11:28:54 <luite> spopejoy: you can build that using (:[]), (++) and fromListWith / toList
11:29:07 <monochrom> f-a: bootstrap.sh does not use ~/.cabal/config at all. however, you can edit bootstrap.sh to add flags to enable profiling and documentation
11:29:16 <Intolerable> spopejoy: look at GHC.Exts.groupWith
11:29:53 <Intolerable> groupWith fst might be useful
11:30:38 <luite> Intolerable: you'd have to sort first though
11:30:39 <monochrom> actually, I now see that it enables doc by default, you have to say --no-doc to disable.
11:31:09 <luite> Intolerable: and I'd prefer groupBy then
11:31:24 <Intolerable> luite: doesnt groupWith sort first?
11:32:01 <f-a> okie monochrom , will try to do that
11:32:07 <luite> Intolerable: oh i was thinking about groupBy, GHC.Exts things are rather less common
11:33:23 <monochrom> but it still omits profiling.
11:33:31 <MasterMastic> Does anyone know how to batch test with QuickCheck in version 2?
11:34:38 <monochrom> set environment variable EXTRA_CONFIGURE_OPTS='--enable-library-profiling' to get profiling. see the shell script itself
11:34:53 <spopejoy> > groupWith seems to work w/o sorting
11:34:54 <lambdabot>  Not in scope: ‘groupWith’Not in scope: ‘seems’Not in scope: ‘work’Not in sco...
11:34:54 <lambdabot>  Perhaps you meant one of these:
11:34:54 <lambdabot>    ‘storing’ (imported from Control.Lens),
11:34:54 <lambdabot>    ‘setting’ (imported from Control.Lens)
11:35:01 <monochrom> or edit the shell script to set it. it has hints near the top.
11:35:16 <spopejoy> oops
11:36:28 <xplat> what's a good haskell library for xml/html these days (is there one?)
11:36:47 <monochrom> I regret that programmers pay lip service to external documentation and make you always read implementation details.
11:37:45 <MasterMastic> xplat: I'd say it would vary between html & xml.
11:38:11 <MasterMastic> Check this out: http://stackoverflow.com/questions/1361307/which-haskell-xml-library-to-use
11:38:18 <xplat> monochrom: all the programmers who can stand to write the same thing over and over and over again have been absorbed by the java industry, leaving none to write programs with documentation
11:39:00 <monochrom> I do not see it as writing the same thing over and over again.
11:39:18 <monochrom> external documentation is at an entirely different level of abstraction from implementation
11:41:13 <xplat> MasterMastic: that answer is kind of old (3 yrs), besides being discouraging
11:41:26 <monochrom> imagine if person M suggested "I regret that programmers don't write more top-level type sigs" and person X replied "programmers who can stand writing the same thing over and over again have been absorbed by the C++ industry"
11:42:02 <f-a> haha
11:42:04 <Saizan> you don't write type sigs, you get emacs mode do to it for you
11:42:18 <monochrom> darn
11:42:37 <monochrom> more seriously, external documentation is at the same level as type sigs.
11:42:45 <xplat> monochrom: type sigs at least are checkable, too.  documentation gets out of date all the time without your noticing
11:43:39 <bennofs> xplat: that kind of depends on what you want to do. Do you just want to pick out a few things from a complex html webpage? Then I've made good experiences with xml-lens and html-conduit
11:43:46 <xplat> doubly so for external documentation
11:45:06 <xplat> bennofs: most of what i'm going to be doing is 'parse something and make a few queries against it that might occasionally be a bit involved', yeah
11:46:01 <monochrom> if you don't write type sigs, then nothing gets out of date, ever.
11:46:05 <bennofs> xplat: I think both xml-lens and HaXML can do that.
11:46:30 <xplat> hm, xml-lens isn't listed under 'XML' on hackage
11:47:24 <xplat> (neither is xml-html-conduit-lens)
11:47:41 <DanielDiaz> any reason to why Hackage is not building this package? http://hackage.haskell.org/package/binary-list , there are no reports: http://hackage.haskell.org/package/binary-list-0.3.2.0/reports , so it seems is not even trying
11:49:14 <ChristianS> DanielDiaz: it can take a few days until the newest version has been built, that's normal
11:49:54 <DanielDiaz> ChristianS: never took this long to me, that's why I am askin
11:50:00 <DanielDiaz> g
11:50:42 <xplat> i wonder why «el» in xml-lens isn't a prism, too
11:51:18 <DanielDiaz> ChristianS: plus, some packages that were uploaded after that one have indeed built already
11:51:25 <xplat> oh, right, you couldn't review it
11:55:12 * hackagebot hindent 3.0 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-3.0 (ChrisDone)
11:57:29 <dmj`> anyone know where that mailing list / blog post about the latest features in haddock is?
12:09:03 <krgn__> hey, is there a short/concise way in hspec to only expect a Right regardless of the value?
12:10:40 <supki> krgn__: _ `shouldSatisfy` isRight
12:10:57 <supki> krgn__: isRight  is from Test.Hspec.Expectations.Contrib
12:10:57 <krgn__> supki: ah thanks! :)
12:11:06 <krgn__> is that a separate package?
12:11:27 <supki> it's from hspec-expectations, a dependency of hspec
12:11:47 <krgn__> ah ok then
12:11:55 <krgn__> thanks!
12:21:49 <thatafricanguy> smoke weed everyday!
12:22:19 <krgn__> :)
12:22:25 <GetShrektKid> We're the cruel regulators smoking CIGARO CIGARO CIGAR
12:22:31 <thatafricanguy> [Hittman] Xxplosive, West coast shit My nigguh-ish ways attract, girls that used to turn they back Causin me to yank they arm and pose like I would do the harm Now I'm sayin thank you cause they tell me, my shit's the bomb Xxplosive.. ..for my niggaz drinkin Cognac, smokin weed, always pack mo' than one, firearm, chrome rims, ridin on Chronic in yo' system, let me know, my shit's the bomb - Xxplosive..  [Kurupt] West coast 
12:23:06 <thatafricanguy> Xxplosive, West coast shit My nigguh-ish ways attract, girls that used to turn they back Causin me to yank they arm and pose like I would do the harm Now I'm sayin thank you cause they tell me, my shit's the bomb Xxplosive.. ..for my niggaz drinkin Cognac, smokin weed, always pack mo' than one, firearm, chrome rims, ridin on Chronic in yo' system, let me know, my shit's the bomb - Xxplosive..
12:23:13 --- mode: ChanServ set +o mauke
12:23:16 <GetShrektKid> EbolaFTW
12:23:20 --- mode: mauke set +b *!*@gateway/web/freenode/ip.206.176.124.180
12:23:36 --- kick: GetShrektKid was kicked by mauke (GetShrektKid)
12:23:39 --- kick: thatafricanguy was kicked by mauke (thatafricanguy)
12:24:18 <krgn__> right on
12:24:44 --- mode: mauke set +b-b *!*@206.176.124.180 *!*@gateway/web/freenode/ip.206.176.124.180
12:25:34 --- mode: mauke set -o mauke
12:25:46 <phaazon> hey
12:25:53 <phaazon> I have a design question about instances
12:26:08 <phaazon> I maintain monad-journal, and I have a few instances (for IdentityT, ListT, MaybeT, and so on)
12:26:19 <phaazon> so that we can use my MonadJournal’s methods in there
12:26:29 <phaazon> should I also so the reverse stuff?
12:26:30 <phaazon> for instance
12:26:45 <phaazon> runEitherT . runJournalT $ throwError … -- doesn’t work since the instance is missing
12:26:55 <phaazon> where such an instance should be placed?
12:26:58 <phaazon> in either?
12:27:01 <phaazon> (the pkg)
12:27:02 <phaazon> or in mine?
12:33:44 <dmj`> Is it better to keep module names plural or singular?
12:33:58 <dmj`> for example, Web.Stripe.Customer vs. Web.Stripe.Customers
12:34:02 <MagneticDuck> I.. err... why is it an issue to have, for example, "instance (Num a) => Num (a, a)", while "instance (Num a, Num b) => Num (a, b)" is fine?
12:34:13 <MagneticDuck> I .. am tired, not seeing things straight?
12:34:25 <dmj`> in OOP land I think the convention is classes should be singular
12:34:49 <mauke> MagneticDuck: probably because it's not always obvious whether two types are equal
12:35:05 <MagneticDuck> It isn't?
12:35:11 <MagneticDuck> hmm, example?
12:35:51 <mauke> sorry, I'm thinking about stuff and things
12:36:07 <mauke> would instance (Num a, a ~ b) => Num (a, b) work, I wonder
12:36:19 <uotbw> Hi all, there was a command in inferior haskell or interactive haskell to send just a chunk of code (not complete file) to ghci, I forgot it and cannot find it again. Could you help me, I'm desperate?
12:36:51 <monochrom> MagneticDuck: I think it may raise similar questions as "do we allow 'f x x = x+x'?"
12:36:51 <MagneticDuck> mauke: yeah, it works
12:36:59 <MagneticDuck> monochrom: oh huh
12:37:20 * MagneticDuck thinks
12:37:28 <uotbw> I mean in emacs haskell-mode, searched now for 2 hours :-(
12:37:41 <phaazon> ok, no one for my instances issue? (see above)
12:38:52 <dmj`> I don't think the style guide covers this though
12:41:33 <phaazon> ok
12:41:38 <phaazon> I guess I’m on my own :D
12:41:40 <phaazon> thank you anyway
12:44:14 <sinelaw> Peaker, yozers
12:44:29 <sinelaw> flycheck is awesome :)
12:47:33 <benzrf> yorick:
12:47:35 <benzrf> *yo
12:48:15 <uotbw> Emacs haskell-mode can I send an expression only (not the complete file) to the interactive-haskell buffer?
12:48:36 <sinelaw> hey conal
12:51:25 <conal> sinelaw: hi :)
12:53:29 <dmj``> uotbw: yea, you can
12:54:52 <dmj``> uotbw: C-h C-m to check the options for the mode, there's one that sends the expression above the cursor
12:58:17 <uotbw> dmj``: thanks, that is exactly what I'm searching for, but in my current emacs exactly this command vanished somehow
12:58:58 <Intolerable> phaazon: exactly what instances were u looking to define?
12:59:16 <krgn__> uotbw: maybe you can see what the key does now with describe-key?
12:59:33 <krgn__> uotbw: then you see which mode might have overridden it
12:59:40 <phaazon> Intolerable: EitherT for JournalT
13:01:16 <sinelaw> Peaker, yo?
13:02:15 <Intolerable> phaazon: id just define as many obviously sensible instances as u can get ur hands on
13:02:27 <phaazon> yeah
13:02:28 <Peaker> sinelaw: yo
13:02:32 <phaazon> I think I’m gonna do that
13:03:07 <sinelaw> Peaker, yo.
13:05:07 <sinelaw> Peaker, undefined in javascript = bottom? that's the best I could come up with without literring my entire type system with Maybe
13:05:38 <sinelaw> not really actually bottom, but some dummy type that never unifies with anything
13:08:13 <dfeuer_> Ha! I found the paper I was looking for: Red-black trees with types, but Stefan Kahrs. Now I just have to figure out how it relates to what I wanted it for.
13:11:25 <laktech> link?
13:15:22 * hackagebot morte 1.0.0 - A bare-bones calculus of constructions  http://hackage.haskell.org/package/morte-1.0.0 (GabrielGonzalez)
13:15:51 <dfeuer_> laktech, http://dl.acm.org/citation.cfm?id=968482
13:16:22 <laktech> thx
13:28:06 <xplat> the HaXML webpages seem to have vanished somewhere along the line
13:28:38 <xplat> whoa, what is tekmo doing with CoC?
13:31:42 <dmj``> how do you get source links to show up in haddock generated documentation
13:32:27 <merijn> xplat: He's been twittering pigworker a lot about implementing a generalised framework that allows interchange between different lambda cube calculi
13:33:02 <xplat> hm, i wonder what kind of interchange he means
13:33:54 <bahamas> how well has real world haskell aged? are there parts that are more outdated than others?
13:33:59 <latk> what are peoples opinions on environment variables vs config files ?
13:34:24 <Sornaensis> config
13:35:18 <merijn> xplat: Blah, I can't get the link from twitter
13:35:24 <dmj``> bahamas: http://www.reddit.com/r/haskell/comments/2dp19v/which_chapters_of_real_world_haskell_are_still/
13:35:25 <merijn> bahamas: It depends on your point of view
13:35:26 <geekosaur> latk, both
13:35:45 <merijn> bahamas: Code samples tend to have bitrotted, but a lot of the high level overview is still correct
13:35:49 <mauris> hi! when should i use: Int vs. Integer vs. Integral a => a?
13:36:11 <geekosaur> to some extent it depends on what you're doing, but I generally go for maximal configuration: config file, envars, command line options
13:36:20 <merijn> bahamas: For example, I wouldn't expect the Parsec code samples to work, but I'd expect you to be able to go to the Parsec3 haddocks and figure everything out yourself after reading the Parsec chapter
13:36:42 <Sornaensis> ^
13:37:03 <merijn> bahamas: Because the design of Parsec has not fundamentally changed only the API (RWH covers Parsec 2 instead of 3)
13:37:26 <geekosaur> and the API hasn't changed that much aside from module names
13:37:31 <Peaker> merijn: so what happens after the mixed feedback on Haskell-libs?
13:37:36 <merijn> bahamas: So I feel it's still a valuable book for learning the high level design of many common libraries
13:38:10 <merijn> Peaker: Control.Exception is part of base, right?
13:38:17 <Peaker> merijn: yeah
13:38:43 <merijn> Peaker: I guess then either GHC HQ or the core libraries committee has the final say
13:38:47 <latk> Hmm, okay. Are there any open source projects that anyone could point me at with examples of how to do config/etc ?
13:38:53 <merijn> Peaker: Usually people just keep arguing until consensus is reached
13:38:59 <bahamas> merijn: I see. so it's more useful to have an idea how to do different things in haskell, even if the way they're done in the book is outdated
13:39:13 <dmj``> latk: http://hackage.haskell.org/package/configurator
13:39:28 <bahamas> dmj``: thanks as well
13:39:31 <luite> is the code/text for rwh still freely available?
13:39:59 <merijn> bahamas: If you've read LYAH I would recommend skipping the first several chapters on haskell syntax and treat RWH as a reference guide for the various subjects to be read "just-in-time" before you work in that area
13:40:03 <merijn> luite: Yes
13:40:13 <merijn> bahamas: Also, the online comments should contain corrections
13:40:28 <Peaker> merijn: people didn't seem to continue arguing.  I am disappointed that people seem to have missed the point: Everyone seems to agree that interruptible cancel actions are currently a bug, but many seem to support fixing each cancel one by one (by masking it) rather than masking all of them by default, and the arguments are weird! "Recovery from bugs". I don't think "recovery from bugs" is a practical idea
13:41:25 <merijn> Peaker: "people stop arguing" tends to means either 1) people have reached agreement or 2) no one agrees, but everyone is out of ideas
13:41:27 <luite> merijn: hmm, then i think hosting it on a github repo as a cabal package would be a good idea. for all bigger examples one version that stays close to the book but still compiles with modern packages/ghc, and where useful something that is more idiomatic modern haskell
13:41:35 <luite> or does that already exist?
13:42:09 <merijn> Peaker: An alternative proposal would be to add uninterruptibleMasked versions to Control.Exception in addition to the current ones, that might be more palatable to the complainers
13:42:10 <Peaker> merijn: did you read the thread?
13:42:25 <Peaker> merijn: (to help me understand which case it is? :-) )
13:43:10 <merijn> Peaker: It's 2 :)
13:43:19 <Peaker> merijn: btw, one good point that was raised, is that   stack overflow   is currently an async exception, which makes sense for implementation reasons -- but it *should* be thrown form the same thread to itself
13:43:38 <Peaker> currently the stack limits are merely suggestions because you can uninterruptible-mask them
13:43:57 <merijn> Peaker: No one has any alternative ideas on how to solve it, but they're to conservative to make bracket uninterruptible
13:44:35 <merijn> Peaker: A solution would be to just add Control.Exception.Uninterruptible which exports Control.Exception but has uninterruptible cleanup versions for bracket, etc?
13:44:42 <Peaker> the current behavior is super-terrible though.. and if "bracketBetter" is introduced, all the "withFile" actions all over the place will remain broken
13:44:57 <merijn> Ah, true
13:44:58 <Peaker> merijn: everything built on top of broken-bracket remains broken that way :(
13:45:03 <merijn> :\
13:45:31 <bahamas> merijn: yeah, I read LYAH a few months ago and didn't use haskell in the meantime, so I want to pick it up again
13:45:46 <Peaker> also, my argument that deadlocks that manifest AT your buggy lines are nicer bugs than cryptic broken invariants that manifest at WHO-KNOWS  -- was ignored
13:47:16 <merijn> Peaker: Might want to send a summary of all the arguments so far and your conclusions to the list to keep things alive
13:48:19 <luite> merijn: should StackOverflow etc ever be maskable?
13:48:41 <merijn> luite: No, but like Peaker said, that's an implementation artifact
13:48:52 <merijn> luite: StackOverflow should clearly not be an async exception
13:49:06 <luite> merijn: it can only be an async exception
13:49:11 <merijn> luite: Why?
13:49:51 <luite> merijn: because it's not caused by the computation itself, the same computation might succeed if it's run at a different point on the stack
13:50:05 <merijn> So?
13:50:21 <merijn> I don't see why that means it has to be async
13:50:53 <fragamus> howdy.  Is there any living project for bindings to ubigraph
13:50:58 <luite> merijn: only async exceptions have the correct behaviour for this
13:51:01 <merijn> luite: Just to be sure we're on the same terminological page: async exceptions are exceptions thrown externally to a thread
13:51:13 <Peaker> merijn: luite convinced me that StackOverflow should be an async-exception at the thunk-level. But it should have sync-exception semantics at the masking-level. This is easily achieved by having it be thrown from the same thread to itself
13:51:31 <luite> merijn: thrown with throwTo, it can be from a thread to itself, in which case it's not masked
13:51:31 <nbouscal> Is there any way to constrain a phantom type in a newtype? I want to be able to derive Num, which only appears to work for newtypes, but I also want to have a phantom type that I can constrain to types of a certain class. The only way I know to do the latter is using a GADT
13:51:32 <Peaker> merijn: thunk-state wise, StackOverflow behaves like an async exception and not like a sync exception
13:52:34 <luite> merijn: it's impossible to continue a computation interrupted by a non-async exception
13:52:40 <merijn> Right, to me that was the same thing, but if you think they're different, that's fine
13:52:57 <luite> merijn: the implementation is very different
13:53:14 <merijn> I don't care about implementation
13:53:18 <merijn> I care about semantics
13:53:42 <merijn> stackoverflow should clearly not have it's current masking semantics
13:54:14 <luite> merijn: the semantics are different too. since a non-async exception comes from the computation itself, all thunks are overwritten by something that immediately raises the exception
13:55:49 <mjrosenb> does haskell also suffer from the call/cc + exceptions can be dealt with in two different ways issue?
13:56:40 <luite> merijn: so semantically a StackOverflow is an async exception, the question is just whether it comes from outside the thread (in which case it's subject to masking) or from the thread itself
13:56:43 <glguy> Haskell doesn't have call/cc, but you can implement it to work however you want
13:57:34 <monochrom> haskell does not have built-in call/cc, so there is nothing to interfere with built-in exception handling
13:58:00 <monochrom> user-defined call/cc will of course interfere with user-defined exception mechanism
13:58:05 <luite> merijn: if there's a valid use case for masking StackOverflow at times, then none of the proposed options so far are ideal
13:58:50 <Peaker> luite: that makes stack limits merely suggestions
13:58:54 <Peaker> luite: probably a very bad idea
13:59:53 <merijn> I can't think of any valid use cases for masking StackOverflow
14:01:02 <monochrom> I agree that it's interesting to note that stack overflow is "async" in the sense "can happen out of the blue" and at the same time "not async" in the sense "not a message from someone else"
14:03:12 <luite> monochrom: right, that makes it reasonably defendable to make it an async exception from a thread to itself, and therefore not subject to masking. that's why i suggested it, but i have a suspicion that it doesn't capture all possible use cases
14:06:29 <luite> since some things would need to be changed anyway, adding a masking level or some class of RTS exceptions for this might be a better way
14:07:22 <monochrom> ah
14:07:40 <monochrom> isn't semantics exciting? :)
14:08:41 <luite> more exciting than implementing these things at least...
14:10:12 <Peaker> luite: to me it sounds like having it be sent to itself -- is a perfect solution :)
14:12:18 <Qfwfq> Any particular reason why GHC defines tuples only up to length 62? Is it an architectural constraint (is it lower on other machines)? (Want to know how many instances to program.)
14:12:28 <luite> Peaker: except that it's never maskable then, which is a bit problematic if you're doing some cleanup just under the stack limit
14:14:32 <geekosaur> Qfwfq, tuples are not a single type, each one is a separate type. someone has to generate the instances. I don't know if there are other limits (used to be that overly large tuples made the compiler dump core but that was fixed)
14:15:00 <monochrom> last night I heard of the theory that if you try to add the next one, it crashes GHC. :)
14:15:02 <geekosaur> also if you're using 62-tuples, I'm tempted to say you're doing it wrong :)
14:15:06 <Peaker> luite: I don't think you really want to really handle buggy code paths, and a stack overflow should simply be considered a buggy code paths
14:15:11 <Peaker> luite: once bugs are hit, all bets are off
14:15:24 <Peaker> (recovery attempts are often worse than futile)
14:17:44 <Qfwfq> geekosaur: I'm not, personally. Defining functions between first-order and arbitrarily-high-order Markov models, where states happen to be mapped to n-tuples.. could use indexed vectors instead.. The types might actually work out nicer that way!
14:17:45 <fragamus> what do you use for graph visualization
14:17:55 <luite> Peaker: that's a reasonable point of view
14:18:00 <Qfwfq> geekosaur: (Thanks for the hint.)
14:19:15 <Qfwfq> geekosaur: But yeah, the instances are (were) coming out of a TH function.
14:19:32 <Peaker> if you can truly segregate pieces of software behind well understood boundaries, then handling bugs by crashing/restarting those components is reasonable, though -- all the async exception stuff is unrelated to this approach
14:19:49 <Sonderblade> what's the best way to read the first two lines of a process's stdout on windows (without waiting for the process to finish)?
14:20:18 <Qfwfq> fragamus: I usually write out CSVs and then use R+ggplot. But go look at what criterion uses.
14:20:22 <Peaker> Sonderblade: I think System.Process should work on Windows?
14:20:29 <Peaker> Sonderblade: so you can use it to get an stdout Handle which you can read
14:21:08 <Qfwfq> fragamus: One of these days I'll get off my ass and implement the grammar of graphics in H, but it'll probably be another year or so.
14:23:00 <burp> ggplot2 for Haskell? please do that
14:23:35 <Qfwfq> It's pleasantly monoidal, in principle.
14:24:01 <benzrf> 'pleasantly monoidal' ah
14:24:41 <fragamus> pleasantly monoidal in this case means you can send it commands one by one?
14:26:27 <Sonderblade> Peaker: not sure which of the functions in that package are appropriate
14:27:14 <Peaker> Sonderblade: http://hackage.haskell.org/package/process-1.2.0.0/docs/System-Process.html#v:createProcess
14:27:45 <Peaker> Sonderblade: http://hackage.haskell.org/package/process-1.2.0.0/docs/System-Process.html#t:CreateProcess <-- build this record, perhaps via "shell"
14:28:04 <Peaker> Sonderblade: see the examples in the doc there
14:38:13 <f-a> hello people from haskell. Is there a way to know whether package x depends on package y (where y is `template-haskell`)
14:38:24 <Peaker> f-a: cabal info x
14:38:39 <Peaker> also: ghc-pkg describe x
14:38:55 <Fuuzetsu> is there a better way to go Int -> Text than pack . show?
14:39:11 <monochrom> that may not show you indirect dependencies transitively.
14:39:12 <Fuuzetsu> @hoogle Int -> Text
14:39:14 <lambdabot> Data.Text drop :: Int -> Text -> Text
14:39:15 <lambdabot> Data.Text.Unsafe dropWord16 :: Int -> Text -> Text
14:39:15 <lambdabot> Data.Text replicate :: Int -> Text -> Text
14:39:31 <f-a> Peaker: that's unfortunately just 'one step'. I try to avoid template haskell like plague, installed `either` because I saw no dep.
14:39:38 <monochrom> I end up doing "cabal install --dry-run -v3 x" and look for y in the huge output
14:39:52 <f-a> but either depends on `free` and, ta-daa, free depends on th
14:39:52 <Peaker> f-a: cabal install x --constraint "template-haskell == 0.0.0.0"
14:40:03 <monochrom> oh haha, that's smart
14:40:07 <Peaker> (preferably with "--dry-run" yeah)
14:40:21 <f-a> monochrom: Peaker , thanks
14:40:32 <mauris> i've been thinking about Int vs. Integer vs. Integral a => a
14:40:39 <f-a> an since we are there
14:40:45 <mauris> i know the differences between them but i'm not sure where to actually *use* which
14:40:54 <f-a> is there a non th dependent thing like ``either``?
14:40:55 <mauris> is the last one preferred? i guess it's the most general?
14:41:12 <merijn> mauris: If you don't need polymorphism default to Integer, if you need polymorphism use "Integral a => a"
14:41:22 <glguy> Incidentally, speaking of TH, the lens library doesn't use use the template haskell extension in its implementation any more
14:41:24 <mauris> aha
14:41:38 <mauris> Int is only used in prelude functions and stuff for historical reasons i guess?
14:41:43 <f-a> glguy: really?
14:42:32 <Intolerable> wat
14:42:46 <Intolerable> how does it derive lenses and whatnot from data decls
14:42:56 <Intolerable> if not th
14:42:59 <glguy> without the extension
14:43:31 <glguy> The extension provides name quoting, splicing and syntax quoting
14:45:03 <glguy> https://github.com/ekmett/lens/compare/v4.4.0.1...v4.4.0.2
14:45:06 <merijn> mauris: Int is slightly faster, but using it is premature optimisations
14:45:11 <glguy> That's the main difference between the last two versions
14:45:59 <glguy> It means you can use lens in cross-compiler situations where you don't have TH extension available. I don't know if anyone will ever do that but it was brought up
14:47:53 <Peaker> The TH extension is also horribly horribly slow and it conflates deterministic code generation with undeterministic IO at compile-time
14:47:55 <luite> glguy: and TH should be available in cross compilers in 7.10
14:48:18 <Peaker> with TH, you never know if you need to rebuild the module -- if you rebuild you might get a different result
14:56:40 <dmj``> hey guys, I'm trying to run some unit tests, but getting strange linker errors when I call "cabal test"
14:56:48 <dmj``> http://lpaste.net/110894 <-- here's what they look like
14:58:24 <dmj``> I bet I'm not exporting something from the library
15:00:16 <WanderingSpectre> Quick question, is recursion the idiomatic way to do iteration in Haskell?
15:01:06 <srhb> WanderingSpectre: Normally we use higher order combinators for that
15:01:07 <monochrom> sometimes, if Data.List has things you can use, you can use them; some other times, you write your own recursion.
15:01:12 <srhb> WanderingSpectre: But they in turn are defined with recursion
15:01:28 <simpson> Also Control.Monad.Loops.
15:02:40 <WanderingSpectre> srhb: Thanks for pointing me in the right direction.
15:02:56 <srhb> WanderingSpectre: Sure thing. If you're just starting out, check out map and foldr
15:03:19 <srhb> (Also implement them. :-))
15:15:12 <earldouglas> How can I install something (e.g. hoogle), and have it use the necessary version of a dependency?
15:15:27 <earldouglas> I can't install hoogle, because some constructor in wai has changed.
15:15:38 <earldouglas> Shouldn't cabal know how to get the right version of wai in this case?
15:16:13 <earldouglas> Do I need to use a sandbox?
15:17:13 <earldouglas> In general: can cabal handle the presence of multiple versions of the same library on my system?
15:17:27 <c_wraith> earldouglas: if you know that a constructor has changed, you've probably been bitten by Snoyman's refusal to use correct upper bounds.
15:17:40 <c_wraith> earldouglas: otherwise you'd just be told that the constraints can't be satisfied
15:18:19 <earldouglas> Ah, so hoogle might specify a range of version support of wai, but there's an unexpected breaking change in a version within that range?
15:18:53 <c_wraith> earldouglas: cabal can handle multiple versions of the same package, but it gets hairy.  You're probably better off with a sandbox.  And you'll probably need to experiment with adding build constraints manually.
15:19:12 <srhb> I usually end up grabbing the source and fixing whatever constructor changed
15:19:25 <earldouglas> Yikes.
15:19:29 <c_wraith> well, the problem's with whatever transitively depends on wai
15:19:30 <mgaut721> whats a good way of having a list that can consist of values of 2 different types?
15:19:40 <c_wraith> mgaut721: [Either a b]
15:19:45 <srhb> Right, but it's usually quite easy.
15:19:56 <srhb> mgaut721: Either?
15:19:58 <mgaut721> c_wraith: how about one of N types
15:20:03 <srhb> mgaut721: That is, [Either a b]
15:20:19 <srhb> :t [Left 2, Right "foo"]
15:20:21 <lambdabot> Num a => [Either a [Char]]
15:20:35 <srhb> Wow, the lags.
15:21:01 <srhb> mgaut721: Make your own data type instead of Either a b :)
15:21:19 <mgaut721> srhb: sounds good
15:21:21 <mgaut721> thanks
15:21:39 <srhb> mgaut721: There's also tuples, but that's probably a bad idea.
15:22:12 <mgaut721> srhb: don't think that would work, as the container is arbitrarily sized
15:22:23 <srhb> mgaut721: Oh, right. Brainfart. :P
15:22:31 <srhb> Either, not And.
15:30:33 * hackagebot diagrams-canvas 0.2.0.3 - HTML5 canvas backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-canvas-0.2.0.3 (jeffreyrosenbluth)
15:36:09 <CrazyM4n> How do you add two complex numbers in haskell?
15:36:15 <srhb> With +
15:36:29 <CrazyM4n> I tried that.
15:36:35 <srhb> > (1 :+ 0) + (1 :+ 10)
15:36:37 <lambdabot>  2.0 :+ 10.0
15:36:39 <CrazyM4n> I got this: ¨No instance for (RealFloat Integer) arising from a use of `+'¨
15:36:53 <CrazyM4n> When I have the function ¨quadratic c z = z * z + c
15:36:53 <CrazyM4n> ¨
15:37:04 <CrazyM4n> With the type signature ¨Complex Integer -> Complex Integer -> Complex Integer¨
15:37:51 <benmachine> CrazyM4n: Complex as a type does not support Integer as a parameter
15:37:56 <benmachine> because of abs, basically
15:38:02 <benmachine> it's annoying, but there you go
15:38:10 <CrazyM4n> So use int?
15:38:22 <CrazyM4n> Or float? Double? What´s the reccomended type then?
15:38:36 <burp> :t abs
15:38:37 <lambdabot> Num a => a -> a
15:38:45 <benmachine> you basically have to use Float or Double
15:38:56 <benmachine> or make your own complex type
15:38:56 <CrazyM4n> Double is more precise, correct?
15:38:59 <benmachine> yes
15:39:04 <CrazyM4n> Okay, thanks!
15:39:15 <Intolerable> just use double by default unless u know u neat float
15:39:30 <CrazyM4n> No, I think double would be good for a mandelbrot fractal
15:40:47 <Intolerable> are there any other types that are instances of realfloat anywhere?
15:40:51 <Intolerable> Data.Scientific isnt
15:41:31 <benmachine> Intolerable: there are some, but they're often a bit strange
15:54:08 <visionec> Hi
15:54:27 <visionec> I'm assuming some of you know your shit so this message is to those who actually do
15:54:59 <visionec> If you'd like to make SONY fall down again let me know please, I have all the information but a few team members would come in handy
15:55:21 <glguy> That's definitely off-topic, please take it to another forum
15:57:19 <visionec> I don't even know what this irc is about honestly
15:58:47 <hpc> visionec: it's a long-running ARG
15:58:57 <hpc> we made up a programming language and now we pretend it will take over the world ;)
16:01:50 <srhb> I think you need Haskell to take down Sony. At the very least.
16:01:58 <srhb> First the world, then Sony.
16:04:04 <ion> We even have an almost realistic looking website for the language. You have to dig a bit to see that all the monad tutorials are just nonsense.
16:08:21 <Total_1mmersion> Is there a way to use "double" from Data.Attoparsec.ByteString.Char8 with "parse" from Data.Attoparsec.ByteString.Lazy?
16:16:33 <CrazyM4n> so how would I print things based on the x and y coords
16:16:59 <CrazyM4n> I have an array of complex numbers that I want to print based on their location
16:20:20 <srhb> CrazyM4n: array?
16:20:34 <CrazyM4n> well, no
16:20:38 <CrazyM4n> I think I got it
16:20:38 <srhb> A list, then?
16:20:47 <CrazyM4n> but how do I split a string every X characters?
16:21:34 <srhb> There's a splitEvery somewhere.
16:21:57 <CrazyM4n> okay, thanks
16:22:05 <Iceland_jack> > chunk 4 "this is fine"
16:22:07 <lambdabot>  ["this"," is ","fine"]
16:22:30 <Iceland_jack> from 'split'
16:22:33 <Iceland_jack> @hackage split
16:22:33 <lambdabot> http://hackage.haskell.org/package/split
16:22:43 <srhb> synonymous with splitEvery, fyi
16:23:04 <CrazyM4n> okay, thanks
16:23:57 <Iceland_jack> srhb: splitEvery has been depricated afaik
16:24:03 <srhb> Iceland_jack: Oh, really
16:24:22 <srhb> Iceland_jack: Appears you're correct. It's not there anymore.
16:24:46 <CrazyM4n> so chunk is what I want to use
16:25:19 <srhb> Iceland_jack: So is chunk, it seems. It's now chunksOf
16:25:30 <CrazyM4n> I just found that out
16:25:35 <Iceland_jack> ah
16:25:50 <Iceland_jack> > chunksOf 4 "this is fine"
16:25:51 <lambdabot>  ["this"," is ","fine"]
16:25:53 <Iceland_jack> okay works as well
16:25:55 <CrazyM4n> ugh, what´s the function to go from a number to an integer?
16:25:59 <Iceland_jack> good to know :)
16:26:04 <CrazyM4n> I always forget
16:26:04 <srhb> CrazyM4n: A "number" ?
16:26:07 <CrazyM4n> double
16:26:14 <srhb> :t Double -> Integer
16:26:15 <lambdabot> parse error on input ‘->’
16:26:16 <srhb> Eek
16:26:20 <srhb> @hoogle Double -> Integer
16:26:21 <Iceland_jack> CrazyM4n: round? ceiling? floor? truncate?
16:26:22 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
16:26:22 <lambdabot> Prelude floatRadix :: RealFloat a => a -> Integer
16:26:22 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
16:26:23 <CrazyM4n> wait
16:26:28 <Iceland_jack> depends on what you want
16:26:37 <srhb> Well, those were all bad suggestions lambdabot :(
16:26:37 <Iceland_jack> > round pi :: Integer
16:26:38 <lambdabot>  3
16:26:42 <CrazyM4n> Well
16:26:48 <Iceland_jack> lambdabot sucks at suggesting numeric functions
16:26:51 <srhb> Yeah.
16:26:52 <CrazyM4n> I want to have as little floating point errors as possible
16:26:52 <phao> Hi. Is there any guide out there how database usage can be integrated neatly in a FP program?
16:27:05 <CrazyM4n> So probably round
16:27:16 <srhb> phao: There are some resources tied to the various web frameworks like Yesod and phao
16:27:25 <phao> And phao? =D
16:27:29 <srhb> phao: But usually it just involves doing something in I.
16:27:35 <srhb> IO*
16:27:49 <Iceland_jack> Round decreases floating point errors? :)
16:28:00 <phao> srhb, any chance you have some code I could see, or a link to it?
16:28:11 <srhb> phao: Umm..
16:28:13 <nbouscal> phao: there's a proliferation of database stuff, the hard part is choosing between them
16:28:19 <benzrf> @let data Test = Test {testField :: Int}
16:28:20 <CrazyM4n> Well, I´m dividing a constant, 3, by the precision I´m using
16:28:21 <lambdabot>  Defined.
16:28:47 <phao> srhb, Found =) http://book.realworldhaskell.org/read/using-databases.html
16:28:51 <phao> nbouscal, hehehehe
16:28:56 <srhb> phao: That's probably ancient, though.
16:28:57 <benzrf> > let {anotherField = testField; Test {anotherField = v} = Test 4}; in v
16:28:59 <lambdabot>  <hint>:1:65: parse error on input ‘;’
16:29:01 <srhb> I would not trust it.
16:29:05 <phao> srhb, Ok.
16:29:06 <srhb> But it gives you an idea of the method
16:29:08 <benzrf> > let {anotherField = testField; Test {anotherField = v} = Test 4} in v
16:29:09 <lambdabot>  ‘anotherField’ is not a (visible) field of constructor ‘L.Test’
16:29:10 <srhb> Just don't expect it to run out of the box
16:29:12 <benzrf> hm
16:29:16 <nbouscal> phao: RWH is out of date on this topic, yeah. you can look at persistent or groundhog if you want ORM-like stuff
16:29:27 <nbouscal> phao: if you just want to write queries, if you're using postgresql look at postgresql-simple
16:29:35 <phao> ok.
16:29:55 <nbouscal> phao: or mysql-simple for mysql, etc
16:29:57 <srhb> Oh and acid-state is really cool
16:30:03 <nbouscal> yes, definitely check out acid-state :)
16:30:04 <srhb> Store your haskell datatypes directly!
16:31:06 <phao> Ok... =D
16:31:08 <phao> Thanks all.
16:32:48 <CrazyM4n> How would I split an array when a value changes?
16:33:15 <Iceland_jack> > group "aabbbddb" -- this?
16:33:16 <lambdabot>  ["aa","bbb","dd","b"]
16:33:19 <bcap> hello fellow haskell programmers. After reading some resources on functional languages, I was convinced to learn haskell. I started following the guide at http://learnyouahaskell.com/ . Is it a good starting point? Any comments on that?
16:33:35 <srhb> bcap: I think it's a most excellent starting point!
16:33:42 <srhb> Some people dislike the style, I think it's fantastic.
16:33:57 <Iceland_jack> And use 'arrays'  called
16:33:57 <srhb> bcap: And stick around in this channel, resources abound whenever you need them. :)
16:34:03 <Iceland_jack> *use 'lists' instead of 'arrays'
16:34:19 <bcap> srhb thanks for your reply, thats very kind of you
16:34:19 <CrazyM4n> Iceland_jack: I have an array of complex numbers, and I want to split on every time the imaginary part changes
16:34:29 <CrazyM4n> so I don´t think group would work
16:34:33 <srhb> groupBy then
16:34:51 <bcap> i will stick to this channel in the following haskell learning days :)
16:35:13 <Iceland_jack> CrazyM4n: Just to be sure, you're talking about lists like [Complex Double]?
16:35:17 <CrazyM4n> Yes
16:35:19 <CrazyM4n> Exactly
16:35:20 <srhb> > groupBy (\(_ :+ x) (_ :+ y-
16:35:22 <lambdabot>  <hint>:1:28:
16:35:22 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
16:35:22 <srhb> argh
16:35:23 <Iceland_jack> There are other data structures called Arrays
16:35:27 <bcap> also, I think i will try doing the exercises at http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems while i learn the language
16:35:37 <CrazyM4n> Err, it´s an array in other languages, haha
16:35:52 <bcap> if you got any more helpful comments on learning haskell, I would like to know
16:35:56 <Iceland_jack> Arrays in C are not quite the same as lists in Haskell :)
16:36:08 <geekosaur> Haskell has arrays. Lists aren't them
16:36:08 <srhb> > groupBy (\(_ :+ x) (_ :+ y) -> x==y) $ [1 :+ 2, 2 :+ 2, 2 :+ 3]
16:36:09 <CrazyM4n> I guess
16:36:10 <lambdabot>  [[1 :+ 2,2 :+ 2],[2 :+ 3]]
16:36:15 <Iceland_jack> bcap: you can evaluate expressions here on #haskell by writing '> ' and expression
16:36:17 <Iceland_jack> > 2 + 10
16:36:19 <lambdabot>  12
16:36:24 <srhb> CrazyM4n: And lists in C are not like arrays in C either. :)
16:36:36 <cdk> > groupBy ((==) `on' imagPart) [1 :+2, 2 :+2, 2:+3] -- srhb
16:36:37 <lambdabot>  <hint>:1:20: parse error on input ‘imagPart’
16:36:37 <CrazyM4n> Ahhh semantics are hard
16:36:55 <cdk> ahh well, imagPart is from Data.Complex :)
16:36:58 <srhb> cdk: I know it :)
16:37:04 <nbouscal> bcap: as with any language, it's usually easiest to learn if you have a motivating project.
16:37:24 <Iceland_jack> cdk: You just wronte the backtick wrong
16:37:25 <Iceland_jack> > groupBy ((==) `on` imagPart) [1:+2, 2:+2, 2:+3]
16:37:26 <lambdabot>  [[1.0 :+ 2.0,2.0 :+ 2.0],[2.0 :+ 3.0]]
16:37:33 <Iceland_jack> *wrote :)
16:37:35 <bcap> Iceland_jack thats a good tip, very handy!
16:37:37 <CrazyM4n> How does groupBy (\(_ :+ x) (_ :+ y) -> x==y) $ [1 :+ 2, 2 :+ 2, 2 :+ 3] work though?
16:37:47 <bcap> nbouscal couldnt agree more
16:37:50 <srhb> CrazyM4n: So the lambda checks if x and y are equal
16:38:00 <srhb> CrazyM4n: If they are, no split happens. If not, it splits
16:38:20 <nbouscal> bcap: and srhb isn't kidding about asking questions in this channel. best resource ever.
16:38:22 <geekosaur> :t (==) `on` imag
16:38:23 <lambdabot>     Not in scope: ‘imag’
16:38:23 <lambdabot>     Perhaps you meant ‘imap’ (imported from Control.Lens)
16:38:24 <bcap> nbouscal my initial project is something small. I want to get a dictionary of common passwords and generate a rainbow table of md5 and sha1 hashs of it
16:38:25 <CrazyM4n> srhb: but how does it get the current value from the list?
16:38:29 <srhb> CrazyM4n: We're pattern matching on the :+ constructor to get at the imaginary parts.
16:38:33 <Iceland_jack> srhb: You need to be a bit familiar with pattern matching and anonymous functions before getting the ‘groupOn’ part
16:38:37 <srhb> CrazyM4n: groupBy does the recursion
16:38:47 <CrazyM4n> srhb: Oh, I see
16:38:50 <geekosaur> :t (==) `on` Data.Complex.imagPart
16:38:51 <lambdabot> RealFloat b => Complex b -> Complex b -> Bool
16:38:53 <CrazyM4n> srhb: That makes sense
16:39:04 <bcap> nbouscal its always nice to see an active and helpful channel
16:39:21 <CrazyM4n> What does ¨on¨ do then?
16:39:29 <CrazyM4n> Hoogle gives a pretty complicated description
16:39:31 <cdk> CrazyM4n: on is a little tricky
16:39:32 <geekosaur> @src on
16:39:32 <lambdabot> (*) `on` f = \x y -> f x * f y
16:39:44 <bcap> hanging in freenode has teached me a lot about all kinds of things in computing
16:39:52 <srhb> geekosaur: Huuuh
16:40:13 <Iceland_jack>     ((==) `on` imagPart)
16:40:13 <Iceland_jack> is the same as
16:40:13 <Iceland_jack>     (\x y -> imagPart x == imagPart y)
16:40:19 <geekosaur> so (==) `on` imagPart means take a 2-parameter function (==), and apply another function (imagPart) to each of its parameters
16:40:26 <CrazyM4n> Oh. That´s easier to understand
16:40:31 <Iceland_jack> but it's possible that some more foundation is needed
16:40:37 <bcap> nbouscal anyway I wanted to harness the full potential of my 4 cores while doing so. Its an experiment for how fast can I go (no gpu computation, only cpu)
16:41:22 <cdk> CrazyM4n: on is nice for all sorts of comparisons
16:41:23 <srhb> bcap: You'll be pleased to find that working on multiple cores is pure bliss in Haskell. :-)
16:41:34 <nbouscal> bcap: for parallelism-related things, this book is fantastic: http://chimera.labs.oreilly.com/books/1230000000929
16:41:47 <cdk> > sortBy (comparing `on` fst) [(3,3), (2,5), (5,2), (1,6)]
16:41:49 <lambdabot>  Couldn't match type ‘b -> GHC.Types.Ordering’
16:41:49 <lambdabot>                with ‘GHC.Types.Ordering’
16:41:49 <lambdabot>  Expected type: (b -> a) -> (b -> a) -> GHC.Types.Ordering
16:41:49 <lambdabot>    Actual type: (b -> a) -> b -> b -> GHC.Types.Ordering
16:41:56 <cdk> > sortBy (compare `on` fst) [(3,3), (2,5), (5,2), (1,6)]
16:41:58 <lambdabot>  [(1,6),(2,5),(3,3),(5,2)]
16:42:01 <Iceland_jack> > sortBy comparing [(3,3), (2,5), (5,2), (1,6)]
16:42:03 <lambdabot>  Couldn't match type ‘b -> GHC.Types.Ordering’
16:42:03 <lambdabot>                with ‘GHC.Types.Ordering’
16:42:03 <lambdabot>  Expected type: (b -> a) -> (b -> a) -> GHC.Types.Ordering
16:42:03 <lambdabot>    Actual type: (b -> a) -> b -> b -> GHC.Types.OrderingCouldn't match expect...
16:42:07 <Iceland_jack> bah!
16:42:08 <cdk> > sortBy (comparing fst) [(3,3), (2,5), (5,2), (1,6)]
16:42:10 <lambdabot>  [(1,6),(2,5),(3,3),(5,2)]
16:42:12 <Iceland_jack> :) exactly
16:42:29 <cdk> I think comparing is a little uneeded
16:42:35 <srhb> Part of the fun of this channel is having your secret lambdabot fail counter increased.
16:42:53 <exio4> how can I check where a function is defined, locally?
16:43:03 <CrazyM4n> We should keep tallys
16:43:22 <geekosaur> cdk: it's there because it came before on
16:43:35 <geekosaur> in fact it is what was generalized to create on
16:44:13 <exio4> @type comparing
16:44:14 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
16:45:15 --- mode: ChanServ set +o monochrom
16:45:22 --- mode: monochrom set -b *!*@gateway/web/freenode/ip.67.189.90.191
16:45:26 --- mode: monochrom set -o monochrom
16:45:26 <bcap> srhb i read that, and that pleased me a lot :D
16:45:38 <bcap> nbouscal good, will take a look!
16:46:01 <bcap> by the way
16:46:04 <bcap> haskell and the gpu
16:46:10 <bcap> an I talking nonsense?
16:46:13 <srhb> Nope.
16:46:15 <merijn> accelerate
16:46:29 <srhb> @hackage accelerate
16:46:29 <lambdabot> http://hackage.haskell.org/package/accelerate
16:46:32 <merijn> bcap: Yes and no, depends on what you want and how much you care about speed :)
16:47:15 <bcap> merijn i see. The question is more a "Can i run haskell on the GPU? Does it worth use it when you need the GPU power?"
16:47:36 <bcap> never programmed for the GPU though
16:47:47 <srhb> You can't just RUN Haskell on the GPU.
16:47:52 <bcap> I will take a look on accelarate also
16:47:57 <hseg> Reading Edward Yang's post on how GHC doesn't check for global instance uniqueness. I wonder, wouldn't it make sense to change Haskell's semantics to be that f :: ctx => sig means that f has type sig, where there exist (potentially non-unique) witnesses to discharge ctx?
16:48:05 <srhb> (At least, not any Haskell!)
16:48:19 <bcap> srhb well makes sense !
16:48:31 <bcap> or else GPU would be replacing CPUs, I think, ha
16:48:40 <srhb> They're good at different things.
16:48:44 <bcap> indeed
16:49:01 <bcap> the problem I have is hashing a ton of words
16:49:13 <MasterMastic> Just got in but if anyone wanna learn how to use hardware acceleration, Simon Marlow's book on parallelism covers it.
16:49:15 <hseg> In that case, Data.Set would be at fault for assuming witnesses were stable across function invocations, and should use a phantom type proxy for the witness to make sure that the same witness was used across invocations on the same set.
16:49:16 <srhb> Sounds like a plausible application for accelerate
16:49:17 <bcap> was wondering about gpu power for that
16:49:21 <merijn> There's some libraries for accelerating things on the GPU, which, depending on what you wanna do are either nice or suck :)
16:50:07 <MasterMastic> Hehe bcap is it that bad? ;) have you tried just parallelism?
16:50:14 <srhb> bcap: But I'd say you are a ways off before just diving into GPU programming with Haskell. :-)
16:50:38 <bcap> hahaha you are totally right
16:50:43 <bcap> im getting ahed of myself
16:50:50 <merijn> MasterMastic: "just parallelism" is not good enough if you have a few billion things to compute
16:50:53 <MasterMastic> And if you do I must re-mention: Marlow's book is divine.
16:50:55 <bcap> but wanted to know the potential of the language im diving in
16:51:25 <srhb> bcap: Sure. :) Haskell is an awesome general purpose language. There are few things I don't use it for. but the biggest bonus is probably that it's fun. :P
16:51:32 <bcap> MasterMastic well, parallellism can surely do. Im talkin about 70 million words
16:51:41 <MasterMastic> Oh, ouch. You win hehe.
16:52:29 <bcap> its a rainbow table exercise for my curiosity :)
16:52:43 <bcap> i like cripto stuff
16:53:08 <bcap> in this case, more hashing functions than criptography itself
16:53:50 <bcap> srhb Yeah thats quite interesting. I get this fun argument often
16:54:30 <bcap> one of the best guys I personally know in computing is a great fan of Haskell
16:54:43 <bcap> he will be very pleased that im learning it
16:55:00 <srhb> :)
16:55:08 <bcap> thanks for the good reception and all the help guys
16:55:16 <bcap> time to learn some haskell ;)
16:55:23 <srhb> Have fun!
16:55:39 * hackagebot jammittools 0.3 - Export sheet music and audio from Windows/Mac app Jammit  http://hackage.haskell.org/package/jammittools-0.3 (mtolly)
16:58:14 <MasterMastic> I have a type that inside it has a key field, and a value field. Is there a way to use it in a hash map?
16:58:54 <MasterMastic> (It's just a newtype for a tuple. I could break it down but I wouldn't want to lose the abstraction).
17:00:04 <CrazyM4n> Does anyone know how to find the width of a line in a Mandelbrot fractal?
17:00:29 <CrazyM4n> like
17:00:41 <CrazyM4n> hold on
17:02:25 <CrazyM4n> http://lpaste.net/2603018698436378624 Does anyone know what I could do here?
17:03:18 <Rembane> CrazyM4n: What are you trying to do and what does it do?
17:03:34 <CrazyM4n> Mandlebrot fractal renderer
17:03:43 <Rembane> Fancy
17:03:53 <CrazyM4n> I have an array with all the coords for the fractal
17:04:02 <CrazyM4n> in ¨doesEscapeArray¨
17:04:17 <CrazyM4n> but there´s too many floating point errors so I can´t use ¨arrayGroup¨
17:04:21 <CrazyM4n> So what do D:
17:04:54 <merijn> MasterMastic: Map by default uses Ord, so just make sure your Ord instance only compares the key
17:05:06 <merijn> MasterMastic: Or split and recombine when inserting into a Map?
17:06:12 <MasterMastic> merijn: Yeah I'm taking the second approach. No user has to know ;) (API won't break). Thank you ^^
17:06:50 <dfeuer_> Is edwardk around?
17:07:03 <Rembane> CrazyM4n: What kind of floating point errors, your code won't compile, so I can't try it
17:07:03 <holo1> hi
17:07:36 <edwardk> nope
17:08:06 <CrazyM4n> Rembane: Actually, I think I got it
17:08:20 <CrazyM4n> What´s the x range of the mandelbrot set?
17:08:35 <CrazyM4n> I screwed it up I think
17:09:07 <edwardk> dfeuer_: if he, theoretically, were around, how could he help?
17:09:28 <dfeuer_> @tell edwardk, The paper I was thinking about was "Red-black trees with types", but Stefan Kahrs. It's too complicated for me to figure out quickly just what sort of coercion it needs to avoid the problem described on page 429.
17:09:28 <lambdabot> Consider it noted.
17:09:54 <dfeuer_> Since he's not around, I just left him a message.
17:10:34 <dfeuer_> edwardk, I just thought I'd let you know since I mentioned it way back, and couldn't remember anything about the title or author.
17:11:16 <edwardk> dfeuer_: i've now lost context for what the problem was =)
17:13:07 <dfeuer_> edwardk, we were discussing the potential of   class Represent a b | a -> b where getRepresentation::a->b
17:13:21 <dfeuer_> With magical instances.
17:13:29 <dfeuer_> (Or something like that)
17:14:16 <edwardk> oh, ew. =)
17:14:25 <holo> hey why is # so crowded, but so little job opportunities out in the wild? the haskell programmer isn't likely to be a startup founder? or is it something else?
17:14:41 <bcap> having some issues with haskell installed by homebrew on mac OSX 10.9.3 :/
17:14:57 <vanila> holo, cause all the people in here took the haskell jobs up already!
17:15:10 <bcap> ghci exits with a fatal error stating a "Reason: image not found" error
17:15:13 <merijn> holo: Lot's of companies running haskell, they just have better things to do than blog about it :)
17:15:19 <dfeuer_> edwardk,  Well, that's probably not correct, but the idea was extending coercion from maps to catamorphisms.
17:15:21 <bcap> does it rings a bell?
17:16:04 <holo> vanilla so there is no job liquidity in this industry?
17:16:26 <edwardk> holo: there is a lot of demand at the top end for haskell talent. there is a lot of supply at the low end
17:16:42 <edwardk> holo: if you stick with it long enough the demand curve inverts
17:17:15 <merijn> bcap: It is not recommend to use homebrew for haskell
17:17:23 <merijn> bcap: The formula's are badly maintained
17:17:34 <bcap> merijn oh great
17:17:35 <merijn> bcap: I would recommend just downloading and installing haskell platform
17:17:46 <bcap> ok, will do
17:17:51 <bcap> thanks merijn !
17:18:02 <CrazyM4n> So, I´m completely stumped
17:18:05 <CrazyM4n> Like, 100%
17:18:11 <bcap> (btw i can see how bad they are maintained, it doesnt even work)
17:18:16 <holo> bcap i have it installed with brew, but i guess i didn't iterate enough to run into those problems :s
17:18:32 <CrazyM4n> I´m trying to print the Mandelbrot fractal using http://lpaste.net/4469433351509377024
17:18:58 <CrazyM4n> But it´s really skewed
17:19:05 <holo> edwardk the low end supply can't do the job?
17:19:14 <CrazyM4n> http://lpaste.net/1304006058804510720
17:19:19 * merijn is lazy and hasn't ever used anything but the platform
17:19:42 <bcap> holo when you say that you didnt iterate enough, you mean that you didnt update it?
17:20:17 <holo> bcap, oh i updated yes. no problems :) what is your problem by the way?
17:20:18 <edwardk> holo: At the bottom end there is a glut of supply, lots of folks out there who would kill to write haskell who will take anything that purports to be in haskell, often at a discount. At the top end there is a glut of demand, lots of folks looking for the comparatively sparse set of folks who've gone deep on haskell and who aren't being drowned in money by their current employer. In the middle it's more give and take.
17:20:32 <bcap> holo installed and just executed a ghci command
17:20:36 <edwardk> holo: It more comes down to whether you want to 'build or buy' your talent. Usually you want to do a bit of both.
17:20:42 * hackagebot morte 1.0.1 - Bare-bones calculus of constructions  http://hackage.haskell.org/package/morte-1.0.1 (GabrielGonzalez)
17:20:44 * hackagebot crypto-api 0.13.1 - A generic interface for cryptographic operations  http://hackage.haskell.org/package/crypto-api-0.13.1 (ThomasDuBuisson)
17:20:51 <bcap> he tries to load this lib /usr/local/lib/libgmp.10.dylib but it doenst exists
17:21:50 <CrazyM4n> So does nobody know what´s going wrong with my program
17:22:01 <holo> bcap i vaguely remember having run some update and some small trick which is easy to find on the web. i'm not sure if it's related to your problem :(
17:22:07 <edwardk> If nothing else learning Haskell is a way to become a very good Scala programmer, and you can always sidle off and do something in that space if you get tired of looking for a Haskell job. =P
17:22:35 <bcap> holo no problem though. I am hitting into brew issues more and more nowadays
17:22:50 <merijn> Or just take a non-haskell job and make it a haskell job :D
17:22:51 <bcap> im installing the platform from the dmg file
17:23:29 <bcap> holo by stating that I just mean that im not surprised with brew not working properly
17:24:00 <holo> edwardk sounds too tough. why not just create some startups and use it?
17:24:07 <bcap> brew behaves really bad after you do an OS upgrade. I keep resintalling stuff since then
17:24:38 <edwardk> holo: there are quite a few of them popping up. every time i turn around someone else tells me about one =P
17:26:14 <holo> edwardk, where can I find that activity?
17:27:20 <holo> bcap, aren't you supposed to access libs on "Cellar"?
17:28:06 <c74d> bcap: I hear the package manager Nix works on Apple OS X, and has good Haskell support
17:28:10 <holo> bcap I feel your pain. I made two upgrades. never did a clean install here
17:28:43 <c74d> (<https://nixos.org/nix/>)
17:28:44 <holo> bcap had to do alot of 'doctor' stuff with brew to get it straighter
17:28:48 <bcap> holo indeed i am, but somehow ghc, thats installed on cellar, wants to access that
17:29:04 <bcap> even doctor sometimes wont solve stuff
17:29:21 <bcap> cause brew thinks that something is installed when it actually inst
17:29:22 <edwardk> In the last couple of years here, lets see, Silk, Better, Soostone, Carter has a consulting company, Zalora recently started doubling down on Haskell branching it out from their data science team to the company at large... At CUFP last week we had two different folks come out and talk about Haskell doing mission control for satellites, AfC came out and talked about how they are taking over their whole business with it...
17:29:29 <bcap> so i ahve to reinstall stuff
17:29:47 <holo> bcap, try to understand which brew lib is related to that lib file and install it. it should use that lib instead
17:30:18 <bcap> yeap, thats the way
17:30:30 <bcap> i need to redo my whole brew installation
17:30:31 <holo> edwardk zalora! god i would love working in singapore :3 :3
17:30:38 <bcap> or else i keep pinpointing problems
17:30:43 * hackagebot crypto-api 0.13.2 - A generic interface for cryptographic operations  http://hackage.haskell.org/package/crypto-api-0.13.2 (ThomasDuBuisson)
17:30:50 <bcap> for now im using haskell from the dmg file
17:31:17 <holo> bcap yes, that's a good idea
17:32:53 <holo> merijin, I see, introducing new technology to a company in a sneaky way :)
17:35:57 <CrazyM4n> lol, just finished my Mandelbrot thing
17:36:00 <CrazyM4n> but it´s rotated
17:36:01 <CrazyM4n> http://prntscr.com/4lyy8k
17:36:03 <CrazyM4n> looks creepy
17:36:40 <merijn> holo: Pretty sure Standard Chartered is almost permanently recruiting haskellers for singapore
17:36:58 <holo> edwardk there's some names there I didn't find on the web before. thanks! always good to know where to knock at. "Zalora recently started doubling down on Haskell branching it out from their data science team to the company at large…" what do you mean? they made the rest of the company use haskell? actually for the last months I saw them searching for haskell developers for doing web dev
17:38:18 <holo> guys you are awesome :) i'm going to note all those names. haskell is so sexy. i hope someday i can use it in real life
17:39:42 <solatis> holo: yeah i can safely say that #haskell is *the* reason i am able to learn haskell
17:39:51 <merijn> There's also Jane Street
17:40:02 <merijn> They don't do haskell, but ocaml is still better than Java :p
17:40:04 <solatis> that, and github code search to find out how to use certain libraries
17:41:59 <holo> merijin, i considered jane street recently. they have an open position for systems developer, which is not so cool, but maybe i could open other doors. but I'm still at the beginning of haskell. going for ocaml now doesn't seem very productive!
17:43:13 <holo> solatis, i see. it's very hard only using books?
17:44:11 <edwardk> holo: they are starting to do more haskell outside of the data science team, doing more services etc in haskell.
17:44:30 <solatis> holo: well, for me personally it takes me great effort to properly interpret the hackage docs of a library
17:44:31 <holo> i'm a bit of a lisp traitor. been doing clojure for 3 years now, but i find the haskell mathematical correctness so sexy omg :D
17:45:10 <solatis> so, for example, when i'm looking to find out how to use certain Text.Json abilities, i do that this way:
17:45:12 <solatis> https://github.com/search?l=Haskell&q=%22text.json%22&ref=advsearch&type=Code&utf8=%E2%9C%93
17:45:31 <solatis> and voila, hundreds of code samples on how to use that library
17:45:32 <edwardk> holo: we lured john wiegley away from CL / C++, so you'd hardly be the first "lisp traitor" in the fold ;)
17:46:08 <solatis> does using Emacs count as being a lisp traitor? :)
17:46:17 <holo> solatis i also do that often :D
17:46:24 * johnw cackles gleefully
17:46:52 <solatis> holo: i think it's one of the most underrated ways to learn by example
17:47:01 <solatis> it beats searching google for answers 9 out of 10 times
17:47:02 <holo> solatis indeed!
17:48:30 <CrazyM4n> How do you convert an int to a double?
17:48:49 <trap_exit> anyone have a good tutorial of "how to implement prolog in haskell (say with list monad)" ?
17:48:57 <edwardk> CrazyM4n: fromIntegral
17:49:25 <holo> edwardk i still find lisp to be great, but haskell is calling me more now. only time will tell
17:49:27 <edwardk> trap_exit: http://okmij.org/ftp/papers/LogicT.pdf + https://hackage.haskell.org/package/logict
17:50:26 <CrazyM4n> edwardk: Thanks
17:50:41 <trap_exit> edwardk: nice, thanks!
17:51:15 <edwardk> trap_exit: you may also have luck digging into minikanren and its various haskell variants
17:51:25 <trap_exit> edwardk: I thought minikanren was scheme
17:51:37 <edwardk> its been ported in part several times
17:52:28 <edwardk> https://github.com/JaimieMurdock/HK  https://github.com/acfoltzer/Molog https://github.com/jvranish/MiniKanrenT https://github.com/Oregu/featherweight ...
17:53:10 <vanila> edwardk, its' weird how Molog uses STT but the docs say don't use STT with backtracking monads
17:53:24 <johnw> clearly there should be a miniKanren in Perl 6, so that it can be ported even more times
17:53:25 <edwardk> trap_exit: mix and match that, logicT above, various datalogisms, etc. and roll yourself a prolog
17:53:37 <edwardk> or take something like http://www.cs.ox.ac.uk/jeremy.gibbons/publications/wam.pdf and do it in a more principled way
17:54:47 <edwardk> STT is just an IntMap based ST monad, no?
17:55:11 <edwardk> i've always rolled it myself when needed
17:56:31 <CrazyM4n> So after trying to roll my own Mandelbrot generator, I realized just how clever http://warp.povusers.org/MandScripts/haskell.html is
17:56:37 <dfeuer_> If edwardk should arrive at some point, I would appreciate his thoughts on what sorts of laws might be required for Takano Akio's foldrW/buildW stuff to work right. There's a sort of wildly-layered worker/wrapper thing going on, and correctness of particular wrap/unwrap/cons combinations seems non-trivial.
17:57:49 <edwardk> I've yet to fully internalize the foldrW/buildW stuff it struck me as kinda hideous and I backed away. On the other hand if dolio seems to be making headway with it, then there is a chance it could be salvaged. I trust his judgment.
17:58:34 <dolio> I'm not terribly convinced by it.
17:59:13 <dolio> It requires more investigation.
17:59:21 <edwardk> then I'll back off and let dolio figure it out ;)
17:59:28 <dfeuer> dolio, the workers, wrappers, conses, and nils need to continue to make sense as they get pushed down the stack together.
18:00:05 <edwardk> I've outsourced the understanding of RULES to shachaf and dolio. ;)
18:00:09 <dfeuer> I tried proving that your scanl wrapper was safe, and I couldn't figure out how.
18:00:25 <edwardk> I mean I understand them, but at the same time, generally try to avoid depending on them
18:00:33 <dolio> That doesn't seem like a very sustainable framework.
18:01:07 <dfeuer> Well, if it's to be sustained, someone needs to formulate the necessary laws.
18:01:22 <dolio> For every wrapper, check that it's okay with every other combination of wrappers.
18:01:34 <dfeuer> No, that's absolutely horrible.
18:01:50 <sm> will the world explode if I upgrade cabal-install in a windows haskell platform setup ?
18:01:52 <dfeuer> That would never do. We'd need rules that would ensure compositionality.
18:02:13 <dolio> Right, but we don't have them yet.
18:02:32 <dfeuer> Correct.
18:02:38 <dfeuer> Or at least I don't.
18:02:41 <dolio> And it's not obvious what they are.
18:03:05 <dolio> I don't really even know which of the two interacting ones that we know are bad together is actually bad.
18:03:09 <dmj`> sm: no, with that said, I wouldn't use the defaults haskell-platform on windows gives you
18:04:19 <dmj`> sm: you could always cabal install cabal-install into a sandbox, then pull it out and overwrite your global cabal with it to be safe
18:06:30 <lucky> hi, i've Googled a bunch and read all the haddock docs on Aeson, and I'm still sort of scratching my head.  Can someone point me to a good tutorial/starter piece on it?
18:06:54 <dmj`> lucky: https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/json
18:07:54 <lucky> thanks, already read that one but I should probably reread it
18:08:55 <dmj`> lucky: do you have a project in mind to use aeson for?
18:09:08 <dolio> dfeuer: There are other problems with buildWStatic, too.
18:09:23 <lucky> Yep, just scraping some JSON data sources
18:09:27 <dfeuer> dolio, we've already trashed buildWStatic, right? Let's forget that.
18:09:37 <dolio> Okay.
18:09:54 <dolio> The HOFs weren't always eliminated in conjunction with other builders.
18:10:00 <dolio> Er, wrappers.
18:10:02 <dfeuer> A builder gets wrap, unwrap, cons, and nil from above.
18:10:11 <dfeuer> Well, from downstream, I should perhaps say.
18:10:29 <dfeuer> What is it and isn't it allowed to do with them?
18:10:55 <dfeuer> That is the first question.
18:11:07 <dfeuer> The next question is what properties they need in order to support that.
18:12:11 <dfeuer> Obviously, wrap . unwrap = id would be sufficient, but things like the foldl wrapper don't satisfy that.
18:12:50 <dfeuer> I have the strong feeling that if we find the right answer, it will tell us that the types are wrong and need to be adjusted to help enforce that ...
18:20:04 <hseg> Seeing that GHC doesn't enforce global instance uniqueness anyway, would it make sense to only require local instance uniqueness? And have any group of functions whose semantics depends on their using the same instance across all calls use phantom types to do so, as is done in ST and oleg's reflection paper?
18:22:06 <sm> dmj`: true. So far so good anyway
18:22:29 <dmj`> sm: cool
18:22:46 <matt2> has anyone worked with haskell on fedora? I'm in dependency hell and I'm trying to claw my way out
18:23:40 <sm> aha, fatal to say that. Trouble with aeson, as usual
18:24:46 <sm> will bash on it some more tomorrow
18:25:43 <matt2> in particular I've got 2 versions of bytestring installed, one from yum and one from a cabal dependency
18:25:51 <matt2> they aren't playing nice together
18:26:00 <matt2> anyone know what I could do?
18:26:18 <matt2> uninstalling either breaks deps
18:27:42 <dmj`> matt2: are you using a sandbox?
18:29:18 <nshepperd> my approach on archlinux was to not install any haskell stuff from repos except for ghc itself and do everything else with cabal
18:29:25 <matt2> dmj`: not sure, i think when I was following the yesod setup guide it told me to use that, but I don't really know what it does
18:29:45 <nshepperd> occasionally nuking ~/.ghc so that diamond dependencies go away
18:30:19 <matt2> nshepperd: i feel like I've tried to do that before and something went wrong, I might give it another shot eventually
18:30:31 <matt2> if i can't get sandboxing to work
18:31:00 <dmj`> matt2: I'd git clone your project into a new folder, and call cabal sandbox init, then cabal install --dependencies-only, see if something blows up, if not, cabal freeze it, then commit the cabal.config to source control
18:31:14 <dmj`> and cabal build :)
18:32:04 <WraithM>  /q dmj`
18:32:21 <WraithM> Oops, ignore that
18:32:37 <dmj`> WraithM: :P
18:33:02 <matt2> dmj`: ok I'll give that a shot, I'm also reading up on how to use sandboxes
18:43:11 <trap_exit> what webserver is recommended for using Haste.App ?
18:43:22 <trap_exit> basically I'm writing my ajax app in Haste.App
18:43:32 <trap_exit> and as for picking a webserver, I don't care about templating or any of the standard features
18:43:39 <trap_exit> all I want is -- what works best with Haste.App, and I'll use it
18:53:43 <erikd> i'm looking at https://www.fpcomplete.com/user/tel/lens-aeson-traversals-prisms but ghci can't find the '^?' operator. clues anyone?
18:54:06 <roboguy_> erikd: it's in Control.Lens.Fold
18:54:11 <shachaf> Did you import Control.Lens?
18:54:32 <erikd> no, just imported Data.Aeson.Lens
18:54:47 <shachaf> I would say import Control.Lens, then.
18:55:43 <erikd> thanks shachaf and roboguy_ . working now.
19:10:19 <hseg> I'm reading https://github.com/sjoerdvisscher/blog/blob/master/2012/2012-09-06%20constraint-based%20generics.md In section #the-single-constructor-case, near the end, he writes something like f c x = e for f :: ctx => in -> out. out is a simple type. Am I to understand that c :: Constraint?
19:12:10 <hseg> And that, with ConstraintKinds on, => becomes ->, except that the type is of kind Constraint?
19:14:13 <hseg> Unless he mistyped, because I see proxies being passed around everywhere else.
19:16:22 <enthropy> hseg f is that Constraints type family?
19:17:52 <hseg> no. The exact code I'm confused about is:
19:18:00 <hseg> build :: (Record t, Constraints t c) => (forall s. c s => (t -> s) -> s) -> t build for f = runIdentity $ buildA for (Identity . f)
19:18:15 <hseg> ugh. newlines swallowed.
19:18:25 <hseg> build :: (Record t, Constraints t c) => (forall s. c s => (t -> s) -> s) -> t
19:18:30 <hseg> build for f = runIdentity $ buildA for (Identity . f)
19:23:30 <athan> So I'm getting an "upsweep (partially) failed error" with the process package... what should I do?
19:24:25 <solatis> hmmm i'm getting 'not in scope: typeOf' error messages when building the protocol-buffers package
19:24:40 <solatis> is anyone familiar with that type of error? is it a language extension i'm missing?
19:25:19 <solatis> google tries to be smart, so googling for 'typeOf' yields no useful results
19:25:43 <roboguy_> :hoogle typeOf
19:25:48 <roboguy_> @hoogle typeOf
19:25:50 <lambdabot> Data.Typeable typeOf :: Typeable a => a -> TypeRep
19:25:50 <lambdabot> Data.Typeable typeOf1 :: Typeable1 t => t a -> TypeRep
19:25:50 <lambdabot> Data.Typeable typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
19:25:54 <enthropy> hseg looks like there should be an argument with type For c in the signature
19:26:18 <solatis> is anyone else able to `cabal install protocol-buffers`, or is the package corrupt (hasn't been updated in 2 years)
19:26:45 <shachaf> http://hackage.haskell.org/package/protobuf was last uploaded this month.
19:26:49 <shachaf> Perhaps it'll work better.
19:26:55 <shachaf> I've not used either.
19:27:23 <solatis> i know, but i want to install rethinkdb, which depends on protocol-buffers :/
19:27:30 <roboguy_> solatis: they changed Typeable in ghc 7.8 so that might be causing some issues
19:27:56 <solatis> roboguy_: i suspect that might be it then
19:28:12 <solatis> https://github.com/alphaHeavy/protocol-buffers/blob/master/Text/ProtocolBuffers/WireMessage.hs#L54
19:28:20 <solatis> it does seem to import Typeable properly
19:28:50 <solatis> last updated +- 2.5 years ago
19:28:52 <shachaf> FSVO "properly"
19:28:54 <shachaf> It's not importing typeOf
19:29:15 <shachaf> typeOf used to be a method of Typeable. Now it's not.
19:29:20 <solatis> right
19:29:26 <solatis> so that is the problem
19:29:29 <solatis> let's fix it :)
19:29:30 <enthropy> Syb-with-class might also be worth looking at, since it seems to be solving the same problem and it predates constraint kinds, hseg
19:30:23 <hseg> enthropy: I'm reading this for pleasure, not as a solution. My question is only whether this weird syntax is actually correct.
19:31:27 <benzrf> bye
19:36:39 <jayunit100_m> maybe (0) (add 2 _) (Just 3) -- how to use maybe to add 3 + 2 ?
19:36:52 <athan> Is there any way you can list the dependencies that cabal computes?
19:38:35 <jayunit100_m> ah got it maybe (0) (add 2) (Just 3)
19:38:49 <roboguy_> > maybe 0 (+ 2) (Just 3)
19:38:50 <lambdabot>  5
19:39:15 <hseg> G'night
19:44:04 <ryantrinkle> is there any cost associated with using existential quantifiers, if you don't include any typeclass constraints? e.g.: is there any difference in performance between data Blah = forall a. Blah a versus data Blah = Blah GHC.Exts.Any ?
19:45:02 <haasn> ryantrinkle: Try comparing the Core
19:45:14 <shachaf> ryantrinkle: No.
19:45:17 <shachaf> Well, shouldn't be.
19:45:28 <shachaf> Of course there'll be a different comapred to (newtype Blah = Blah Any)
19:45:33 <ryantrinkle> right
19:46:13 <ryantrinkle> i guess it might interfere with some optimizations?
19:46:17 <shachaf> s/[()]/"/g
19:46:21 <roboguy_> athan: try cabal install --dry-run
19:46:48 <athan> roboguy_: Ah! Thank you. Crap... now I have a useless SO question... want points? :D
19:47:11 <copumpkin> ryantrinkle: I'd consider it a bug if there was
19:47:25 <copumpkin> I'd love a newtype that supported contextless existentials
19:47:33 <ryantrinkle> copumpkin: yeah, that would be nice
19:47:36 <roboguy_> athan: haha sure
19:47:39 <copumpkin> dolio has a decent argument against them, but I also want them
19:47:50 <ryantrinkle> huh, what's his argument?
19:47:58 <shachaf> ==copumpkin
19:48:01 <athan> roboguy_: http://stackoverflow.com/questions/25799923/how-to-list-dependecies-cabal-calculates !!!
19:48:26 <copumpkin> ryantrinkle: it lets you make values that would otherwise need infinite types
19:48:31 <roboguy_> athan: yep I got it
19:48:39 <ryantrinkle> ahh
19:48:44 <ryantrinkle> is that bad?
19:48:47 <ryantrinkle> seems ok to me :P
19:48:56 <copumpkin> well, it's odd
19:48:58 <athan> roboguy_: Thanks man haha.
19:49:03 <ryantrinkle> yeah, that's true
19:49:23 <shachaf> Things like "exists (n::Nat). Vec n a", right?
19:49:34 <lpaste> jfeltz pasted “Shake based test runner” at http://lpaste.net/110914
19:49:41 <roboguy_> copumpkin: hmm, what benefits would you get?
19:49:57 <roboguy_> athan: no problem!
19:50:05 <ryantrinkle> newtypes are already kinda used for that sort of thing
19:50:12 <copumpkin> shachaf: yeah, you can make an infinite vec that way, and thus get a vec whose `n` doesn't actually exist
19:50:14 <ryantrinkle> breaking type cycles
19:50:23 <jfeltz> just curious if anyone is on that knows some the more low-level use of Shake, e.g. custom Rule
19:50:39 <copumpkin> roboguy_: no penalty for passing around indexed types
20:09:08 <Moggle> mueval doesn't seem to want to work (out of date with the current ghc apparently, since it using control.monad.error), does anyone know of any forks or alternatives to get it working?
20:21:05 <jayunit100_m> how come :type Maybe fails?
20:21:31 <athan> because it's a type, not a value
20:21:33 <roboguy_> jayunit100_m: Maybe is a type not a value level binding, like a function
20:21:47 <athan> :i Maybe should work, though
20:21:49 <roboguy_> jayunit100_m: you can ask for Maybe's kind with :kind (a kind is like a type for types)
20:21:55 <joelteon> types lack types
20:21:59 <roboguy_> :kind Maybe
20:22:15 <jayunit100_m> ah ok.  so how do i get the info about what a  type is  from ghci
20:22:21 <roboguy_> :k Maybe
20:22:22 <athan> @kind Maybe --...?
20:22:22 <lambdabot> * -> *
20:22:23 <lambdabot> * -> *
20:22:28 <athan> :D
20:22:35 <jayunit100_m> joelteon: ok thanks i see
20:22:45 <jayunit100_m> and others also
20:22:46 <athan> via :info
20:22:48 <athan> @info Maybe
20:22:48 <lambdabot> Maybe
20:22:57 <athan> o.O
20:23:05 <roboguy_> unfortunately, lambdabot doesn't have :info
20:23:07 <jayunit100_m> haskell community == best of all langs
20:23:12 <athan> :(
20:23:16 <athan> :)
20:23:34 <athan> jayunit100_m: It's fun here, imo
20:23:50 <athan> until robots start analyzing your personality, predicting your thoughts :O
20:24:25 <athan> and wizards start time warping around your compiler
20:25:09 <roboguy_> athan: it's already starting... http://ircbrowse.net/nick/athan
20:30:53 <Moggle> for anyone who was curious about mueval, apparently it was just a single line change to Context.hs changing Control.Monad.Error to Control.Monad.Except because apparently it hasn't been updated in 8 months :(
20:31:02 <Moggle> i am curious as to what ghc lambdabot is running
20:31:08 <Moggle> if it actually compiled that without issue.
20:32:10 <jayunit100_m> athan: agreed !
20:32:19 <Moggle> > :!ghc --version
20:32:20 <lambdabot>  <hint>:1:1: parse error on input ‘:!’
20:35:43 <athan> Moggle: Ghc-server!
20:39:02 <Moggle> thanks!
21:01:30 <platinuum> hi can anyone help me out with cabal?
21:06:03 * hackagebot yesod-auth 1.3.4.4 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.3.4.4 (MichaelSnoyman)
21:14:02 <athan> platinuum: Whats up?
21:21:59 <platinuum> hey athan when i try to update cabal, i run cabal install cabal-install and i get this error http://lpaste.net/110916
21:22:49 <platinuum> same goes with installing anything really, through cabal, i also tried to install hlint and i got the same error
21:22:50 <athan> platinuum: What's your current version of cabal / ghc?
21:23:09 <platinuum> i just downloaded the haskell package installer from the website
21:23:29 <athan> try a `ghc --version` && `cabal --version`
21:23:37 <platinuum> i ran ghc --version, 7.8.3
21:23:56 <platinuum> cabal 1.18.1.4
21:24:00 <athan> oh wow... hmm.
21:24:20 <platinuum> is that old ? lol
21:24:38 <athan> no not at all haha
21:24:43 <athan> ummm. Hold please
21:25:05 <platinuum> no worries
21:25:19 <athan> try `ghc-pkg recache`
21:25:43 <platinuum> hmm it says i dont have permission to modify the file...
21:26:31 <athan> `sudo $$` :)
21:26:50 <athan> er... idk how that works. But just try `sudo ghc-pkg recache`
21:27:35 <Fuuzetsu> @check \x y z -> x - y - z == x - (y - z)
21:27:38 <lambdabot>  *** Failed! Falsifiable (after 2 tests and 3 shrinks):
21:27:38 <lambdabot>  0 0 1
21:27:59 <athan> :o
21:28:27 <jle`> :O
21:28:42 <athan> :(____)
21:29:00 <mauke_> @check (==)
21:29:01 <lambdabot>  +++ OK, passed 100 tests.
21:29:09 <jle`> x - (y - z) = x + (-y - (-z)) = x + (-y + z) = x - y + z
21:38:12 <jle`> mauke_: i suspect that that was a pretty boring test run
21:38:32 <jle`> because it's testing (==) :: () -> () -> Bool, right?
21:39:09 <mauke_> yes
21:39:25 <mauke_> @check (< 1000)
21:39:26 <lambdabot>  +++ OK, passed 100 tests.
21:40:57 <tac_> @check \x y => x >= 0 && y >= 0 ===> x + y == y + x
21:40:57 <lambdabot>  <unknown>.hs: 1: 6:Parse error: =>
21:41:00 <tac_> ;(
21:41:10 <tac_> whoops. I accidentally idrised in there
21:41:14 <tac_> @check \x y -> x >= 0 && y >= 0 ===> x + y == y + x
21:41:14 <lambdabot>  : -1: -1:Ambiguous infix expression
21:41:22 <tac_> bah
21:43:00 <jle`> @check (== 0)
21:43:02 <lambdabot>  *** Failed! Falsifiable (after 2 tests and 1 shrink):
21:43:02 <lambdabot>  1
21:43:12 <jle`> sometimes when i run it it says "after 3 tests"
21:43:43 <jle`> oh, it picks them randomly, doesn't it.  it must be picking zero twice.
21:44:56 <mauke_> @check (/= 0)
21:44:58 <lambdabot>  *** Failed! Falsifiable (after 1 test):
21:44:58 <lambdabot>  0
21:44:59 <platinuum> athan: everythings good to go thanks.  another quick question, when i install these packages can i use the plugins in vim? or how does that work
21:46:02 <athan> platinuum: Plugins? You mean like hdevtools?
21:46:10 <jle`> @check (/= 25)
21:46:11 <lambdabot>  *** Failed! Falsifiable (after 38 tests):
21:46:11 <lambdabot>  25
21:46:14 <jle`> @check (/= 25)
21:46:15 <lambdabot>  *** Failed! Falsifiable (after 40 tests):
21:46:15 <lambdabot>  25
21:46:37 <jle`> man lambdabot you kept on giving True every time i asked you on /q.  you're always trying to ruin my jokes ;_;
21:46:41 <platinuum> athan: yeah i guess, like syntastic as wel
21:46:48 <platinuum> i just installed hlint
21:46:51 <athan> platinuum: I think you might have to install an editor-specific package, like ghc-mod for emacs or hdevtools for vim
21:46:57 <platinuum> ah ok
21:47:11 <athan> I haven't messed around much with vim :/ I am sticking with yi for now
21:47:19 <platinuum> im just starting out in haskell on osx, ive been able to build files and everything just trying to get the best set up for the commandline
21:47:31 <athan> platinuum: (:
21:47:49 <platinuum> athan: got a functional programming class hehe
21:47:51 <athan> I definitely suggest you read this: http://dev.stephendiehl.com/hask
21:48:01 <platinuum> will do, thanks
21:48:02 <athan> D: I wish I went to school :/
21:48:05 <athan> np!!
21:48:48 <platinuum> athan: ha your not missing out on much, your here and you know haskell if not other languages
21:49:04 <platinuum> just no schedule to whip you on track
21:49:17 <athan> :) Idk, I don't have anyone to measure myself against (very consistently, at least)
21:49:22 <athan> right haha
21:49:26 <athan> or waste your time ;)
21:49:46 <athan> I really feel like I'm missing out on some coverage, though
21:49:57 <platinuum> maybe fundamentals and basics
21:50:09 <platinuum> but i still get all that frmo youtube and pdfs anyways
21:50:21 <athan> platinuum: Yeah... my machine basically has staples and duct tape holding it together :x
21:50:26 <platinuum> the first year classes were geared towards logic and circuits too so we got a taste of the hardware
21:50:47 <athan> nice! man... if only...
21:51:10 <athan> i think I'm going to go into school later in life, just to explode my potential
21:51:33 <athan> make a compiler to interpret the java in my intro to data structures class.. :P
21:57:47 <athan> when I get a new laptop, what should I do to my old one? It's cursed with voodoo magic.
22:17:21 <platinuum> Ha see now that would impress the prof, building your own compiler in intro to data structures
22:22:22 <bakibour> Greetings
22:22:55 <bakibour> Can i build functions like Maybe -> a -> Maybe a?
22:23:28 <bakibour> I do guess that kinds of * -> * are not within the type system and not legal as a type?
22:23:29 <simpson> bakibour: Hm. What would that do?
22:23:29 <carter> bakibour: you mean Maybe b -> a -> Maybe a
22:23:38 <carter> bakibour: terms have to have kind *
22:23:51 <bakibour> Ah ok so how would i model something like that?
22:24:08 <MichaelBurge> bakibour: What would Maybe -> a -> Maybe a mean?
22:24:12 <bakibour> Like a function that gets an element and a constructor and produces some element of that thingy.
22:24:25 <carter> :t ($)
22:24:26 <lambdabot> (a -> b) -> a -> b
22:24:27 <carter> like that?
22:24:41 <carter> bakibour: a constructor has a type
22:24:42 <carter> :t Just
22:24:43 <lambdabot> a -> Maybe a
22:24:50 <carter> :t Nothing
22:24:51 <lambdabot> Maybe a
22:24:52 <bakibour> Ah
22:24:56 <carter> :t Right
22:24:57 <lambdabot> b -> Either a b
22:24:58 <carter> :t Left
22:24:59 <lambdabot> a -> Either a b
22:25:13 <bakibour> I see
22:25:21 <carter> bakibour: your turn :)
22:25:32 <bakibour> ty :)
22:36:33 <farmerworking> Can I do import moduel1, module2, .. in Haskell?
22:40:17 <carter> sure
22:40:27 <carter> import Module1
22:40:30 <carter> import Module2
22:41:12 <Hafydd> import [module1, module2, ..]
22:41:33 <Hafydd> (not really.)
22:42:40 <jle`> Hafydd: do you mean map import [module1,..] ?
22:43:02 <Hafydd> jle`: I'm not assuming that (succ module1) is module2.
22:43:27 <jle`> ah of course.
22:43:33 <jle`> but without the `map` it doesn't even typecheck
22:44:10 <Hafydd> What `map`?
22:47:25 <Hafydd> Oh, I see.
22:52:35 <lpaste> latermuse pasted “Not sure why this doesnt work?” at http://lpaste.net/110918
22:52:53 <latermuse> Hey guys, can you help me figure out why I am getting a strange type error on this code?
22:53:12 <latermuse> Im not sure why the `number <- extraIO` bit doesnt work correctly.
22:55:33 <tranma> liftIO extraIO
22:56:21 <Total_1mmersion> What's the easiest way to convert String to Data.ByteString.Lazy.ByteString? BS.pack is ([Word8] -> BS.ByteString), not ([Char] -> BS.ByteString)
22:57:04 <mauke_> using what encoding?
22:58:12 <latermuse> tranma: thanks pal
22:58:48 <Total_1mmersion> mauke_, I'm not sure. I'm using Aeson if that's of any indication.
23:01:54 <latermuse> hey total_1mmersion, one moment
23:02:46 <lpaste> latermuse pasted “for total-1mmersion” at http://lpaste.net/110919
23:03:01 <latermuse> Total_1mmersion: This is what works for me. Its kind of hacky. Im not sure if theres any better way or not.
23:03:27 <epta> This haskell wiki page http://www.haskell.org/haskellwiki/Windows says that `If a package depends (either directly or indirectly) on the unix package, you cannot compile it on Windows.' It it true?
23:04:00 <latermuse> Epta: I have not verified that, but it makes sense to not be able to compile binaries meant for unix on windows.
23:05:09 <epta> latermuse: it sounds pretty hard to verify a statement like "you cannot do X"
23:05:29 <latermuse> its not hard to verify. just try to do it and see if it works or not.
23:05:39 <Total_1mmersion> latermuse, but then pack "hi" will have type ByteString.Lazy.Char8.ByteString right? Not ByteString.Lazy.ByteString
23:05:51 <latermuse> It will have type ByteString.Lazy.ByteString
23:09:04 <Total_1mmersion> Wow you're right. I thought that every module had its own ByteString data type and they weren't compatible, but now I realize that Char8 simply re-exports the Internal definition of ByteString
23:10:06 <Total_1mmersion> That was really confusing. I wonder if it would be helpful to put a label next to data types in Haddock which say where the type originates from
23:18:14 <carter> epta: my (half joking/half serious) suggested workaround for windows support is GHCJS
23:18:18 <carter> 'cause wepages tend to be protable
23:18:22 <carter> *portable
23:18:32 <Hafydd> pro_table
23:18:38 <carter> that too
23:18:39 <farmerworking> I want to import several module at once like that import [Test.HUnit, Term, Value, Arith]
23:18:47 <farmerworking> How to do that right
23:18:47 <carter> farmerworking: then do one per line
23:19:07 <farmerworking> No way to do that with single import ?
23:19:15 <carter> nope
23:19:16 <Hafydd> No. Why would you want that?
23:19:17 <carter> sorry
23:19:20 <carter> you have to type words
23:19:32 <farmerworking> Why? it's convenient
23:19:47 <Hafydd> It's convenient to write, but not to read.
23:20:06 <mroman_> import [Foo hiding (bar), Map as Q]?
23:29:01 <farmerworking> If I do error "stuck" in Haskell. How do I test it
23:29:25 <farmerworking> to make sure the program raise an error with string "stuck"
23:29:54 <carter> error "stuck"
23:30:00 <carter> THOUGH
23:30:25 <dontdieych> https://gist.github.com/612606e2b3265a906c05 - Could anyone tell me how I can set multiple headers?
23:31:42 <farmerworking> cater: I don't get it
23:34:07 <adas> is there such a thing as a definitive ORM module for haskell?
23:35:19 <kandinski> beginner question in CT: I'm reading Wadler's paper on Comprehending Monads, and he says that "for our purpoes", a monad goes together with a function "join :: M(M x) -> M x"
23:35:57 <carter> farmerworking: maybe i dont understand your question
23:36:36 <kandinski> is that only for that paper, or do all monads have to have a join? http://www.haskell.org/haskellwiki/Monad_laws does not include join
23:36:52 <farmerworking> carter: (check-error (eval (IsZeroTerm (TrueTerm))) "stuck") this is written in racket
23:37:05 <carter> > error "stuck"
23:37:06 <lambdabot>  *Exception: stuck
23:37:17 <farmerworking> carter: where IsZeroTerm will do something like error "stuck"
23:37:28 <farmerworking> how do I test such thing in Haskell
23:37:30 <carter> i dont understand your question
23:37:43 <carter> test what
23:37:50 <carter> i'm bad at metaphors after 1am
23:38:07 <farmerworking> test an application do execute (error "stuck")
23:38:19 <carter> test in what sense
23:38:35 <kandinski> (it doesn't help that when I first read "Comprehending Monads" I thought it meant "Understanding Monads", as if it were a primer, and I was already invested in reading it when I realised it was about Monads that perform comprehensions)
23:39:05 <farmerworking> Because that's what the function should behave --- error "stuck"
23:39:15 <carter> :t error
23:39:15 <farmerworking> And I want to do unit test
23:39:16 <lambdabot> [Char] -> a
23:40:09 <carter> johnw: i'm not successfullying helping farmerworking , maybe you can?
23:41:15 <mauke> we could get philosophical and ask whether error is a behavior
23:41:29 <farmerworking> carter: I have another question. What's the primitive assertion in Haskell
23:41:39 <carter> i dont understand your sentence
23:42:01 <mauke> Control.Exception.Base.assert
23:42:08 <farmerworking> without help form HUnit, Is there a assert function?
23:42:18 <carter> whats the meaning of assert
23:42:21 <farmerworking> Because what I want to test is super light
23:42:31 <glguy_> farmerworking, this can be brittle, but here's how you might do your original question: farawayexplorer,
23:42:33 <farmerworking> (assert 1 1)
23:42:36 <glguy_> http://lpaste.net/110920
23:44:27 <farmerworking> glguy_: So I have to do that by my own hand and can't get any help from Hunit framework or primitive in haskell?
23:44:55 <mauke> I don't think you're really supposed to "catch" error
23:44:58 <glguy_> I don't know if you can't do it with HUnit, I haven't wanted to
23:47:12 <carter> i'm also not understanding the goal here
23:47:18 <Haskellfant> dontdieych: just append more like "let opts = defaults & param "foo" .~ ["bar"] & param "bar" .~ ["foo"]"
23:48:04 <mauke> carter: automatic software testing
23:53:07 <mroman_> farmerworking: "my own hand". It's like 4 lines of code to do it "own hand"
23:53:43 <mroman_> Maybe http://www.haskell.org/haskellwiki/Error_vs._Exception helps
23:54:10 <farmerworking> mroman_: Just in other language, this is so common to even think about it
23:54:33 <jle`> farmerworking: haskell doesn't really work this way :)  errors mean different things in haskell than it does in other languages
23:55:26 <farmerworking> jle`: what's errors mean really?
23:55:34 <farmerworking> in your opinion
23:55:40 <jle`> in haskell?
23:55:43 <farmerworking> yes
23:55:52 <mroman_> I'd say it's like System.exit(-1); :)
23:56:02 <mroman_> that's what error is for me personally
23:57:09 <farmerworking> So in Haskell and my situation, instead of do error "something", I should wrap it with Maybe and return Nothing?
23:57:30 <mroman_> Also keep in mind that haskell isn't strict
23:57:31 <mroman_> so
23:57:38 <mroman_> > [error "ERROR", 5] !! 1
23:57:39 <lambdabot>  5
23:57:45 <mroman_> ^- totally works
23:58:23 <farmerworking> wired.. I have to say that
23:59:07 <mroman_> > [(\x -> if x == 0 then error "divbyzero" else x)5,6/x]!!1
23:59:09 <lambdabot>  6 / x
23:59:34 <mroman_> > let y = 0 in [(\x -> if x == 0 then error "divbyzero" else x)y,6/y]!!1
23:59:36 <lambdabot>  Infinity
23:59:41 <mroman_> > let y = 0 in [(\x -> if x == 0 then error "divbyzero" else x)y,6/y]!!0
23:59:43 <lambdabot>  *Exception: divbyzero
