00:06:41 * hackagebot interpolate 0.1.0 - String interpolation done right  http://hackage.haskell.org/package/interpolate-0.1.0 (SimonHengel)
00:08:08 * hackagebot witty 0.0.1 - A network server to show bottlenecks of GHC  http://hackage.haskell.org/package/witty-0.0.1 (KazuYamamoto)
00:08:08 * hackagebot interpolate 0.1.0 - String interpolation done right  http://hackage.haskell.org/package/interpolate-0.1.0 (SimonHengel)
00:16:11 <southp0105> I tried to perform "cabal install hlint". It emitted lots of compile error and finally a failure message: "haskell-src-exts-1.16.0 failed during the building phase." How can I fix this?
00:21:13 <krgn_> you might have to manually install alex and/or happy first
00:23:07 <nkar> chrisdone: I'm building shell-conduit in a sandbox.  cabal-install fails to find 'Data.Conduit.Process' even though conduit-extra is specified as a dependency of shell-conduit.  Do I need to make conduit-extra a dependency of my package?
00:26:41 <MagneticDuck> package A depends on package B which depends on package C; you're building package A depending on package B and you're trying to import a module from package C?
00:27:01 <MagneticDuck> pretty sure that's how its supposed to work; you only get modules directly from the packages you depend on
00:27:59 <nkar> MagneticDuck: my package imports only Data.Conduit.Shell.
00:28:42 * MagneticDuck gtg :<
00:35:52 <jle`> does array offer an api to do a map with access to the index?
00:35:58 <jle`> should i just switch to Vector
00:37:36 <southp0105> krgn_: I just did 'cabal install alex' and 'cabal install happy' successfully, but the failure persists :(
00:37:47 <Fuuzetsu> jle`: why do you want such a thing?
00:38:53 <Fuuzetsu> maybe you can use ixmap and fmap separately
00:40:07 <jle`> (i -> a -> b) -> Array i a -> Array i b
00:40:31 <jle`> i want to fmap...but the function i'm mapping wants the index at the element to be mapped
00:43:59 <Fuuzetsu> I don't think there's a function that does that
00:49:06 <jle`> it would be like mapWithIndex from Data.Map
00:49:09 <jle`> hm, yeah, apparently not
00:49:11 <jle`> oh well
00:49:53 <jle`> it's kind of weird that the best solution is to literally create a new array from a list
00:50:00 <jle`> hm
00:50:13 <jle`> i guess if you go through MArray you can take advantage of the fact that it's the same size
00:50:20 <pjdelport> amapWithIx f a = array (bounds a) . amap (uncurry f) . assocs  $ a
00:50:22 <pjdelport> ?
00:50:37 <jle`> yeah, but...i feel like you should be able to take advantage of the fact that the arrays are teh same size
00:50:45 <jle`> instead of going through list and back
00:50:57 <jle`> copy a contiguous segment of memory
00:51:00 <jle`> edit the new one in-place
00:51:14 <jle`> which i assume is what amap and imap are doing
00:53:30 <jle`> its ok
00:53:51 <jle`> ty all
01:01:22 <pjdelport> jle`: They just use unsafeArray and unsafeAt internally.
01:01:30 <pjdelport> (and list comprehensions)
01:01:43 <pjdelport> So it should be straightforward to write the above in a similar style.
01:01:53 <pjdelport> http://hackage.haskell.org/package/array-0.5.0.0/docs/src/Data-Array-Base.html#amap
01:02:52 <pjdelport> jle`: In fact, it would only be a single-character change to amap's source to make it pass the i in scope, too.
01:07:27 <jle`> yay
01:07:35 <jle`> thank you :)
01:14:24 <beckyconning> whats the point of do notation?
01:14:47 <beckyconning> to me (a beginner) it just seems to hide whats going on
01:15:16 <hughfdjackson> beckyconning: yup - that's exactly what's going on :) I guess that's the nature of syntactic sugar
01:15:21 <pjdelport> beckyconning: It's just syntax sugar that makes some things easier and clearer to express: particularly imperative-style code.
01:15:43 <pjdelport> beckyconning: Not everything is made clearer by do syntax though, of course.
01:15:50 <pjdelport> So it should be considered on a case by case basis.
01:16:01 <hughfdjackson> if you re-write a 5-line do-notation block into the equivalent 'regular' syntax, it might become clear why people wanted that ;)
01:16:38 <pjdelport> beckyconning: It's much like the question of using list comprehensions versus using combinations of filter and map and friends.
01:16:48 <beckyconning> i suppose i'm just so used to using promises and lining up "thens" etc that lining up binds looks much nicer to me : P
01:17:10 <hughfdjackson> beckyconning: javascriper?
01:17:12 <hughfdjackson> *javascripter
01:17:29 <beckyconning> hughfdjackson: thats my background yes : )
01:17:35 <capisce> any sufficiently advanced syntactic sugar is indistinguishable from magic
01:17:37 <hughfdjackson> mine too
01:17:58 <hughfdjackson> and I used to think the same, but then I used scala Futures (the scala equivalent to Promises) - they have a `for comprehension`, which is equivalent to haskell's do notation
01:18:15 <hughfdjackson> and after i got my head around it, now its easier on my eyes
01:18:24 <hughfdjackson> it definitely took a few days though -.-
01:18:58 <hughfdjackson> (easier for the 'long' strings of operations)
01:23:37 <nkar> chrisdone: nevermind, got it working in a fresh sandbox
01:33:33 <asfp> How come cabal sandbox has access to the global package database?  How can I avoid that?
01:38:30 <erikd> asfp: if you install ghc globally some of the ghc package will be installed globally. you probably want those packages.
01:39:42 <dmj`> asfp: 'cabal exec bash' that will drop into a terminal where you package db is set to that of the sandbox
01:39:47 <dmj`> your*
01:45:59 <Fuuzetsu> nix can do this with your packages + system packages and it does binary caches so you don't have to recompile stuff for the ‘sandbox’
01:46:06 <Fuuzetsu> if you're interested in that kind of thing of course
01:48:09 * hackagebot tasty-html 0.3 - Render tasty output to HTML  http://hackage.haskell.org/package/tasty-html-0.3 (jdnavarro)
01:49:45 <bernalex> can someone concisely explain why the IO monad is not a "real monad"? I sort of have it in my head, but my thoughts are not organised enough to put them to paper. please remedy this!
01:49:57 <doismellburning> bernalex: where did you get that from?
01:50:06 <asfp> erikd: no I absolutely do not want them.  They are installed because I have some utilities in my environment that are written in haskell.
01:50:44 <bernalex> doismellburning: maths don't do that whole "put things onto screen", so I'm quite certain the IO "monad" won't make much sense in category theory.
01:51:08 <nkar> Fuuzetsu: could you elaborate on the "don't have to recompile" bit?  do sandboxes get stuff from the nix store?
01:51:09 <doismellburning> bernalex: oh you mean monad in the CT sense rather than Haskell Monad
01:51:16 <bernalex> also there's the whole "IO String is a set of instructions which when performed in runtime may deliver a string", which is not very maths lol.
01:51:17 <doismellburning> bernalex: pass, g'luck
01:51:17 <Fuuzetsu> nkar: yep
01:51:27 <bernalex> doismellburning: ah, yeah in maths not as in the haskell typeclass
01:51:28 <Fuuzetsu> nkar: no more recompiling lens 5 times for every project
01:51:34 <doismellburning> (though iirc Haskell Monads aren't maths-monads or something, nfi)
01:51:39 <asfp> Fuuzetsu: I use nix, but cabal is more updated.  I'm really disappointed that the cabal *sandbox* chooses to use the global store.  Is it *yet another* non-solution in this space?
01:51:53 <Fuuzetsu> asfp: what do you mean cabal is more updated?
01:52:05 <bernalex> doismellburning: they are... ish. at least they could be. but for IO I don't think it's possible at all.
01:52:22 <asfp> Fuuzetsu: I can do 'cabal update' and recompile.
01:52:48 <Fuuzetsu> bernalex: ??? that's all IO is, set of instructions
01:52:54 <Fuuzetsu> putStrLn gives you the same set every time
01:53:00 <nkar> Fuuzetsu: but how's it implemented? ordinary cabal-install knows nothing about nix, is there a wrapper of some sort?
01:53:08 <bernalex> Fuuzetsu: yeah and that's not something that exists in maths
01:53:09 <asfp> Fuuzetsu: with nixpkgs I have to do a git merge because I have lots of local changes.  It's just slightly more inconvenient.   I use nixpkgs when building for production though, so it's far from clear cut.
01:53:20 <Fuuzetsu> nkar: there's a wrapper on GHC which knows how to find packages we ask for
01:53:37 <Fuuzetsu> bernalex: ????
01:53:46 <bernalex> Fuuzetsu: your question mark key seems to be broken.
01:53:56 <Fuuzetsu> bernalex: no, your idea does
01:54:10 <Fuuzetsu> you can't have a set of instructions in maths?
01:54:11 <Fuuzetsu> since when?
01:54:16 <nkar> Fuuzetsu: I wasn't aware of this exciting feature.  thanks for letting me know.
01:54:39 <Fuuzetsu> bernalex: what exactly makes the IO structure impossible in maths?
01:54:40 <bernalex> Fuuzetsu: ah. I see what you mean now.
01:55:15 <bernalex> Fuuzetsu: that's what I'm asking. :-] I'll wait for conal to come on. he tends to have a clear view of these things, as well as being a patient senpai.
01:55:44 <Fuuzetsu> well I'm telling you right now that you can have a set of instructions
01:56:13 <Fuuzetsu> better, we can compose those sets with >>=
01:58:11 <hughfdjackson> bernalex: If you didn't evaluate the IO monad (i.e. didn't 'run' it), what would be the difference between that and the Maybe monad?
01:58:35 <jle`> .b 25
01:59:06 <Fuuzetsu> hughfdjackson: what a strange question
01:59:22 <hughfdjackson> Fuuzetsu: :p i'll 'retract' it then - don't want to confuse things
01:59:26 <hughfdjackson> ignore me !
02:00:45 <hughfdjackson> Fuuzetsu: ah, yea, come to think of it.. maybe is an awful comparison :|
02:01:29 <Fuuzetsu> I can only vaguely guess what you meant by it but I don't want to pursue it
02:02:10 <Fuuzetsu> next monad tutorial will be how IO is like Maybe
02:02:11 <hughfdjackson> (I think I meant something like State - where some control structure is reified, but comes into use when evaluated)
02:02:34 <hughfdjackson> 'evaluated' in the sense of being run
02:03:18 <hughfdjackson> :| in any case, feel free to continue being more lucid than me, I'll go get another coffee
02:06:06 <nshepperd> bernalex: maths can contain all sort of "non-mathsy" things
02:06:29 <nshepperd> for example, the singleton set consisting of george washington
02:10:39 <nshepperd> granted, which is probably something that doesn't exist in constructive set theory since you arguably can't construct the actual george washington from any number of sets
02:10:51 <nshepperd> but that doesn't stop you from doing category theory on him!
02:18:11 * hackagebot iban 0.1.1.0 - Validate and generate IBANs  http://hackage.haskell.org/package/iban-0.1.1.0 (ibotty)
02:22:22 <jfeltz> i have a third party lib that I don't want to handle certain command line args, and they don't allow those to be paramatized, is there a way to modify the args in the environment? e.g. a setArgs? I know the problem is ridiculous, but this would save me some time
02:22:49 <ClaudiusMaximus> @hoogle withArgs
02:22:50 <lambdabot> System.Environment withArgs :: [String] -> IO a -> IO a
02:23:01 <jfeltz> ahh
02:23:12 * hackagebot snaplet-mysql-simple 0.2.0.2 - mysql-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-mysql-simple-0.2.0.2 (ibotty)
02:23:36 <jfeltz> thanks
02:25:37 <troyd> hey all!
02:26:36 <troyd> so I have Ubuntu 12.04 and I've installed ghc 7.8.3 from sources on it, now how do I install haskell-platform from sources? build scripts says that I don't have cabal installed but afaik cabal is part of haskell-platfom
02:27:12 <dmj`> troyd: ghc and cabal come with haskell platform afaik
02:28:20 <troyd> dmj`: the compiled binary version of haskell-platform yes
02:28:39 <troyd> however ghc is not a part of haskell platform source distribution
02:28:50 <troyd> nor it's meant to be
02:28:59 <troyd> it's just packaged for convenience I guess
02:29:04 <troyd> don't know for sure
02:29:10 <troyd> was like that few years ago
02:29:23 <Hijiri> it's packaged with it and not just a dependency?
02:30:00 <troyd> I think haskell-platform is just a series of commonly used cabal packages
02:30:05 <troyd> that are must have
02:30:21 <dmj`> troyd: if you already have ghc installed, just wget cabal, you can skip the haskell-platform
02:30:59 <tdammers> haskell-platform is kind of a "batteries included" starter package
02:31:18 <tdammers> "all you need to get cracking" - ghc, cabal, and a concise set of general-purpose libraries
02:34:00 <troyd> also does cabal know about http proxy?
02:34:34 <troyd> I have firewall that requires all http traffic to go through a http proxy
02:34:37 <nkar> troyd: I've seen a related bug
02:34:49 <troyd> and I do have specified enviroment variable called http_proxy
02:38:13 * hackagebot hooks-dir 0.1.1.0 - run executables in a directory as hooks  http://hackage.haskell.org/package/hooks-dir-0.1.1.0 (ibotty)
02:38:24 <nkar> troyd: https://github.com/haskell/cabal/issues/1602
02:40:24 <troyd> nkar: ahh, thx
02:45:05 <Arahael_Twin> what's haskell like on multicore these days?
02:47:31 <Cale> Arahael: Pretty good as always?
02:47:51 <dmj`> Arahael_Twin: how its been for a while, incredible
02:48:33 <Arahael> Cale: Well, I got the impression that multicore was pretty poor once you got to more than 4 cores. And also, "real world haskell" reports relatively minimal gains for using multiple cores - attributed to GC overhead.
02:48:49 <Arahael> But I think that was in GHC 6.x, apparently 7.8.x is much better at this?
02:48:57 <Arahael> Then again, wasn't the overhead actuallyin the IO layer?
02:49:12 <tdammers> there is some intrinsic overhead to most programming problems in general
02:49:23 <Cale> Well, I don't have any experience working with more than 4 cores.
02:49:42 <tdammers> I don't think ghc is particularly bad at this - my experience so far has been pretty good actually
02:49:54 <Cale> But I think they may have done some things to improve it lately, there has been a lot of work done to the I/O manager.
02:50:07 <Arahael> Cale: When was that?
02:50:16 <Cale> I'm pretty sure that parallelism scaling past 4 cores has always been pretty decent.
02:50:49 <tdammers> why would 4 cores be the breaking point anyway?
02:50:55 <Arahael> tdammers: Dunno.
02:51:18 <Cale> Feb 2013?
02:51:18 <Arahael> Real World Haskell must predate this work.
02:51:27 <Cale> RWH predates a lot of stuff
02:52:02 <Arahael> Cool, so I shouldn't be worried then. (Besides, I should benchmark it if/when it becomes a problem, anyway)
02:52:24 <dmj`> haskell on windows works well with 20 cores, I can only imagine linux would be better
02:52:37 <Cale> http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf
02:52:42 <Arahael> dmj`: Awesome. :)
02:53:08 <Arahael> Cale: That link lookso familiar - he had a blog but it was very incomplete.
02:54:05 <Arahael> Nice.
02:54:52 <dmj`> Araheal: http://chimera.labs.oreilly.com/books/1230000000929
02:54:56 <Arahael> Cale: That paper was exactly what I wanted. :)
02:55:28 <Arahael> dmj`: Thanks. :)
02:56:53 <kazagistar> huh, TIL people run haskell in windows on 20 core machines
02:58:33 <Cale> Arahael: I think it was only ever certain I/O computations which scaled poorly, because there are many earlier papers which show good scaling up to 16 or 32 cores for a variety of tasks
02:59:09 <Cale> But the new IO manager is better in a lot of ways, so that's good :)
02:59:50 <Arahael> Cale: Good to know - I was mostly curious.  One thing I've noticed, though, is that there is a lot of benchmarks for haskell, however they tend to be focused on outdated GHC's.
03:00:05 <Arahael> Maybe my search engine is biased.
03:01:37 <dmj`> kazaigistar: yea, I have a pool of threads, when a queue message comes in a thread jumps out of the pool and runs the job down to completion. The pool can have 20+ threads swimming in it
03:03:16 <Arahael> dmj`: The section in RWH was focusing on par, pseq, and force.
03:03:50 <Arahael> The section in RWH *I* was focusing on, rather.
03:12:02 <SwashBuckla> This B. Yorgey's course intro, http://www.seas.upenn.edu/~cis194/spring13/lectures/01-intro.html, mentions something I don't understand
03:12:12 <SwashBuckla> "One major downside, however, is that reasoning about time and space usage becomes much more complicated!"
03:12:28 <Hijiri> In lazy evaluation, you don't evaluate something until it's needed
03:12:51 <Hijiri> so sometimes you can't easily know how many resources will be used computing something
03:12:57 <SwashBuckla> ah
03:13:12 <Hijiri> and instead of actual values, unevaluated things are stored as thunks
03:13:34 <Hijiri> sometimes storing as thunks can take more memory, and also there's overhead when reducing them
03:24:39 <AshyIsMe> so web-encodings is deprecated, what replaced it?
03:24:40 <AshyIsMe> https://hackage.haskell.org/package/web-encodings
03:27:01 <AshyIsMe> i wanted to use decodeHtml
03:27:14 <AshyIsMe> to swap &lt; into < and all the other mappings
03:38:11 <Arahael> How do I do an 'import Foo (#!)'?
03:38:17 <Arahael> Specifically, that #!.
03:38:43 <nkar> import Foo ((#!))
03:39:21 <Arahael> That works - thanks.  Is this the usual way to escape symbols like that in names?
03:40:08 <nkar> Yes, but I'm not sure that "escape" is the right term.
03:40:22 <pavonia> That's the way to make an infix operator a function name
03:40:49 <pavonia> > 1 + 2 == (+) 1 2
03:40:50 <lambdabot>  True
03:41:31 <Arahael> AWESOME. :)
03:41:45 <Arahael> Not so awesome: My caps lock isn't a control on this laptop. :(
03:41:54 <kazagistar> the reverse is backtick quotes
03:42:08 <Arahael> I was trying to use backticks, wasn't sure why they didn't work. :)
03:42:45 <kazagistar> > 3 `elem` [1..10]
03:42:47 <lambdabot>  True
03:42:58 <kazagistar> ... hmm
03:43:18 * hackagebot snaplet-mysql-simple 0.2.0.3 - mysql-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-mysql-simple-0.2.0.3 (ibotty)
03:43:19 <kazagistar> >  2 `(+)` 3
03:43:20 <lambdabot>  <hint>:1:4: parse error on input ‘(’
03:43:27 <doismellburning> heh
03:43:56 <kazagistar> > (`elem`) 3 [1..10]
03:43:57 <lambdabot>  <hint>:1:8: parse error on input ‘)’
03:44:23 <kazagistar> huh, that one was surprising
03:46:48 <pavonia> > (`elem` [1..10]) 3
03:46:50 <lambdabot>  True
03:47:15 <AshyIsMe> ah sweet, MissingH looks like a sweet package
03:48:29 <Hijiri> does import ((`foo`)) work?
03:49:33 <Hijiri> nope
03:50:14 <Hijiri> which would make sense since (`foo`) doesn't work to identify functions either
03:50:35 <benzrf> @src Cont (<*>)
03:50:35 <lambdabot> Source not found. :(
03:51:10 <benzrf> @djinn ((a -> r) -> r) -> ((b -> r) -> r) -> (((a, b) -> r) -> r)
03:51:10 <lambdabot> f a b c = b (\ d -> a (\ e -> c (e, d)))
03:51:15 <jle`> @src (<*>) Cont
03:51:15 <lambdabot> Source not found. That's something I cannot allow to happen.
03:52:07 <benzrf> aha... !
03:52:16 <benzrf> it's cartesian product!
03:52:39 <benzrf> as i thought... there is some sneaky resemblence between Cont and List??
03:53:30 <augur> benzrf: yes and no
03:53:42 <benzrf> augur: please elaborte
03:53:44 <benzrf> *elaborate
03:53:45 <augur> what sort of resemblance were you imagining?
03:53:51 <augur> or, why are you asking
03:53:59 <benzrf> hmm... cont has always struck me as a sort of list-equipped-with-fold
03:54:17 <augur> you mean the type of fold looks suspiciously continuationy?
03:54:24 <benzrf> well
03:54:25 <benzrf> more like
03:54:44 <benzrf> a Cont r a will produce 0 or more values of a, then it lets you map over them and then it folds
03:54:54 <augur> er..
03:55:02 <augur> Cont r a  =  (a -> r) -> r
03:55:14 <benzrf> yes
03:55:26 <augur> there is no sense in which its producing 0 or more values of a yadda yadda
03:55:48 <benzrf> it produces them in the sense that it yields them to your continuation
03:56:00 <augur> no
03:56:07 <augur> there is no sense in which it does that, either
03:56:15 <benzrf> oh
03:56:15 <benzrf> ?
03:56:17 <augur> some particular values might well do that
03:56:24 <augur> but in general there is no sense in which it does that
03:56:40 <augur> > cont (const 5)
03:56:41 <lambdabot>  No instance for (GHC.Show.Show
03:56:41 <lambdabot>                     (Control.Monad.Trans.Cont.Cont r0 a0))
03:56:41 <lambdabot>    arising from a use of ‘M558871557750967501723231.show_M5588715577509675017...
03:56:41 <lambdabot>  The type variable ‘r0’ is ambiguous
03:56:41 <lambdabot>  Note: there are several potential instances:
03:56:47 <augur> :t cont (const 5)
03:56:47 <lambdabot> Num r => Cont r a
03:56:48 <benzrf> yes, that yields 0 :-)
03:56:54 <augur> it does no such thing
03:56:55 <benzrf> :t cont
03:56:56 <lambdabot> ((a -> r) -> r) -> Cont r a
03:57:01 <benzrf> i mean it yields 0 values
03:57:15 <augur> thats a strange way of viewing it
03:57:22 * benzrf shrugs
03:57:30 <augur> but now im inclined to think you might be on to something
03:57:33 <augur> it cant simply be listy
03:57:40 <benzrf> shit i gotta go
03:57:46 <augur> benzrf: however!
03:57:48 <augur> wait dont go
03:57:57 <augur> however: yoneda is possibly relevant here
03:58:22 <augur> benzrf|offline:    yoneda says   f a   ~   (a -> b) -> f b
03:58:31 <augur> its just flip fmap
03:58:33 <augur> :t flip fmap
03:58:34 <lambdabot> Functor f => f a -> (a -> b) -> f b
03:59:01 <augur> yo = flip fmap   unyo f = f id
04:00:57 <augur> benzrf|offline: yoneda says an   (a -> b) -> f b   secretly has a hidden f a. so many cont says it also has a hidden f b -> b
04:01:40 <augur> :t all
04:01:41 <lambdabot> (a -> Bool) -> [a] -> Bool
04:01:54 <augur> :t cont . flip all
04:01:55 <lambdabot> [a] -> Cont Bool a
04:03:04 <augur> @hoogle [Bool] -> Bool
04:03:06 <lambdabot> Prelude and :: [Bool] -> Bool
04:03:06 <lambdabot> Data.List and :: [Bool] -> Bool
04:03:06 <lambdabot> Prelude or :: [Bool] -> Bool
04:03:17 <augur> :t \xs -> cont $ \p -> and (map p xs)
04:03:18 <lambdabot> [a] -> Cont Bool a
04:09:06 <augur> oh i should be clear, the parametric aspect of the type is important
04:10:09 <dwat3r> hi guys,why is the pcap library so buggy?
04:10:45 <dmj`> dwat3r: because you haven't submitted a pull to fix it yet
04:11:19 <dwat3r> can you suggest me a good lib for working with raw packets? packets raw like really, so I can build them from data link layer, even the ethernet packet header too.
04:12:03 <beckyconning> how can you use getChar without it queuing extra keystrokes?
04:12:43 <dmj`> dwat3r: what is buggy about it?
04:13:48 <dwat3r> for example, i can't even install it without modifying one of the sources.
04:14:17 <dmj`> whats the error?
04:14:51 <dwat3r> the good old bytestrings are messing with each other
04:17:14 <dwat3r> by default, we all have a version of ByteString in the standard ghc library,but it needs another. but that's not a problem if you manage to install it. the main problem with the library that it's unstable. I've created a package construction library with it,and when i try to send an ARP request, sometimes the kernel tooks 1 minute to process the reply. okay,not the kernel, i really don't know what, but it is awful.
04:19:29 <dwat3r> i'm thinking about the lib which relies on the packet sockets. not BSD sockets, they are literally the bytestream which the network interface decodes from wire
04:37:30 <bitonic> lhs2TeX works weirdly with RecordWildCards.  it spaces the {..} too much (from the record data constructor)
04:37:35 <bitonic> how do you fix this kind of thing?
04:38:56 <dramforever> bitonic, I'm not sure, but I think it involves changing lhs2TeX
04:40:41 <dramforever> I'm not sure how popular is RecordWildCards, but if it's popular enough maybe the lhs2TeX developers will be happy to fix it
04:41:01 <bitonic> on the other hand, if I try to hardcode it (e.g. %format Foo{..} = "Foo\{..\} ") lhs2TeX blows up and goes out of memory :P
04:42:23 <hpc> perhaps "Foo\\\{..\\\} "?
04:43:18 <hpc> (since it's a rewrite rule, following the bash string school of troubleshooting)
04:43:38 <bitonic> hpc: nope
04:46:31 <Arahael> As a new, naive haskeller, how do I convert from a String to a ByteString.
04:47:00 <Arahael> I've tried many options, including Data.ByteString's pack, but the type error just keeps changing.
04:47:22 <Arahael> I do have the 'OverloadedStrings' extension loaded, although I've yet to fully know what that does.
04:47:59 <hpc> to answer the specific question, use pack from Data.ByteString.Char8 or Data.ByteString.Lazy.Char8
04:48:06 <Arahael> The original typerror is: Couldn't match type ‘[Char]’ with ‘ByteString’
04:48:25 <dwat3r> :t pack
04:48:26 <lambdabot>     Not in scope: ‘pack’
04:48:26 <lambdabot>     Perhaps you meant one of these:
04:48:26 <lambdabot>       ‘BS.pack’ (imported from Data.ByteString),
04:48:31 <dwat3r> :t BS.pack
04:48:32 <lambdabot> [Word8] -> BSC.ByteString
04:48:48 <hpc> OverloadedStrings uses an implicit call to fromString the same way numeric literals use fromInteger
04:49:20 <Arahael> hpc: That causes the compiler to really exploade.  I now get half a screen of errors.
04:49:22 <hpc> Arahael: to address the underlying problem, you likely don't want to be passing textual data around as a bytestring
04:49:23 <dwat3r> you don't need overloaded strings for converting strings to bytestring. you just "pack" them.
04:49:24 <Arahael> hpc: Ah, that makes sense.
04:49:43 <solarus> :t Data.ByteString.UTF8.fromString
04:49:44 <lambdabot> String -> BSC.ByteString
04:49:49 <Arahael> hpc: I'm not the one trying to do that. I'm trying to feed teh output of 'show' into a function that expects a bytestring.
04:49:51 <hpc> Arahael: you are probably importing multiple different ByteStrings
04:50:01 <hpc> ah
04:50:17 <Arahael> hpc: I'm using import Foo (pack), for many different Foo's.
04:50:32 <augur> benzrf|offline: i think you were basically right but needed to generalize from lists to functors
04:50:33 <tdammers> two gotchas: lazy vs. strict bytestrings, and encodings
04:50:49 <hpc> you need to make sure you're using the right one of lazy/strict
04:50:55 <tdammers> lazy vs. strict is a matter of managing your imports and calling fromStrict / toStrict appropriately
04:51:02 <tdammers> encoding is a bit trickier
04:51:26 <tdammers> as long as all your bytestrings are ASCII, you can use conversion methods from Char8
04:51:30 <hpc> usually the encoding will be utf-8, but when it isn't you get spectacular problems
04:51:37 <tdammers> but usually, you want to convert using utf-8
04:52:08 <tdammers> either way, you need to know the encoding of the bytestring, otherwise doing the conversion correctly is logically impossible
04:53:02 <hpc> out of curiosity, what function are you using that takes text as a bytestring?
04:54:09 <Arahael> hpc: SnapFramework's writeBS.
04:54:23 <hpc> ah yes, for writing BS
04:54:32 <hpc> :P
04:54:44 <Arahael> naturally. :)  I've probably jumped off the deep end.
04:54:44 <tdammers> you're outputting HTML?
04:54:47 <Arahael> Indeed.
04:55:01 <Arahael> Or rather, just "{hey}", while I struggle to figure out what the heck I'm doing!
04:55:09 <Arahael> But one day, believe me, it will be HTML.
04:55:12 <tdammers> in that case, your HTTP headers and/or the HTML itself should specify utf-8 as the output encoding, and you should use utf-8 for the conversion
04:55:50 <Arahael> tdammers: Yeah, I will need to do a fair bit of work with the headers, as I still need to change the mime types.
04:55:52 <tdammers> http://hackage.haskell.org/package/utf8-string
04:55:56 <tdammers> check this out
04:56:03 <dramforever> maybe text
04:56:06 <dramforever> @hackage text
04:56:06 <lambdabot> http://hackage.haskell.org/package/text
04:56:11 * tdammers wonders why snap doesn't do that for you automatically
04:56:33 <dramforever> tdammers: why I want utf-8
04:56:49 <tdammers> dramforever: what else?
04:57:34 <dramforever> tdammers: for example here in China gbk is still very popular
04:57:51 <dramforever> many sites has gbk pages
04:57:53 <tdammers> yeah, but you control the output, right?
04:57:59 <beckyconning> what does Something{..} mean?
04:58:05 <Arahael> dramforever: Because UTF-8 is pretty darn good. (Although codepage conversions can still be iffy)
04:58:13 <dramforever> beckyconning: RecordWildCards
04:58:24 <tdammers> I mean, when you read stuff from elsewhere, sure, you need to be prepared to handle a reasonable selection of encodings (for some values of "reasonable")
04:58:26 <beckyconning> dramforever: oh so get all the record fields?
04:58:41 <beckyconning> as variables in the scope of the function
04:58:55 <dramforever> iirc, get all the fields as RecordPuns
04:59:12 <dramforever> so if data Foo = {a::Int, b::Int, c::Int}
04:59:17 <tdammers> but if you're building HTTP responses yourself, you can safely assume that the user agent can handle at least utf-8, or else default to ASCII or latin-1, which would cause mild breakage but still keep the ASCII-compatible parts readable
04:59:26 <dramforever> and you do f Foo{..} = ...
04:59:30 <Arahael> tdammers: I'm too new to haskell to understand how to use utf8-string.
04:59:35 <dramforever> then you get a, b, c in ...
04:59:41 <beckyconning> dramforever: cool thanks : )
04:59:48 <Arahael> tdammers: At least, in the context of my particular bytestring, which, as it turns out, doesn't seem to be a lazy bytestring.
05:00:11 <tdammers> utf8-string has functions for lazy and strict bytestrings
05:00:21 <dramforever> Arahael: I think snap can send Data.Text.Text
05:00:26 <tdammers> anyway, suppose you have a String, and you need to convert it to a ByteString
05:00:44 <tdammers> then Data.ByteString.UTF8.fromString is what you want
05:01:13 <tdammers> but of course, if snap can understand one of the actual string types (String, Data.Text.Text), just use those
05:01:14 <Arahael> tdammers: Thanks. :) (I did say I was a newbie. :( )
05:01:23 <tdammers> Arahael: you did, and there's nothing wrong with it
05:01:47 <dramforever> tdammers: IIRC snap *can* send Data.Text.Text
05:02:49 <tdammers> dramforever: I'm not a snap person myself, so idk, but it would strike me as odd if it couldn't
05:02:59 <Arahael> tdammers: That also results in a lot more errors. I am now suspecting that the first error with this type was masking the second error, now that haskell nows the type.
05:03:13 <Arahael> *now that haskell knows the type, rather.
05:04:00 <tdammers> add more explicit type signatures ;)
05:04:16 <tdammers> if you don't know what they are, you should figure it out anyway :D
05:04:50 <Arahael> tdammers: Already on that. :)
05:05:20 * dramforever didn't think that Arahael mentioned type errors...
05:05:39 <dramforever> But that's the most common...anyway...
05:09:47 <dramforever> tdammers: Ha, it's called writeText, right here: http://hackage.haskell.org/package/snap-core-0.9.6.3/docs/Snap-Core.html#v:writeText
05:10:01 <Arahael> dramforever: I've got bigger issues, trying to figure out the type.
05:10:05 <Arahael> route :: MonadSnap m => [(ByteString, m a)] -> m a
05:10:24 <Arahael> So, given that I'm writing a function which I pass as 'm' there, do I have enough information there to know what type it should be?
05:12:35 <dramforever> Arahael: if you are not using snaplets and you did not use monad transformers, then you should just read MonadSnap m => m as Snap
05:13:33 <Arahael> dramforever: Ok, so the type of my route handler should be "foo :: Snap m -> m"?
05:14:09 <dramforever> why not just Snap a?
05:14:16 <Fuuzetsu> is there a good way to have cabal build spit out a profiled and non-profiled binary?
05:14:39 <Arahael> dramforever: No, that doesn't work. :/
05:14:48 <dramforever> route [(B.pack "asd", handleAsd), (B.pack "sss", handleSss)]
05:14:57 <Fuuzetsu> --enable-library-profiling --enable-executable-profiling just spits out a profiled guy which is much slower than actual product and sometimes I want to play with the faster version if I don't care for the profiling output
05:15:36 <dramforever> Arahael: hey, maybe your handlers are not returning the same type
05:15:39 <Arahael> http://paste.debian.net/123591/
05:15:47 <Arahael> dramforever: I give up, there's the pastebin.
05:16:14 <Arahael> THe route itself is [("api", serveApiData)]
05:16:27 <dramforever> Arahael: you are not understanding polymorphisms...
05:16:44 <Arahael> dramforever: I haven't covered them yet.  I'm _very_ new to this.
05:16:51 <dramforever> change that to serveApiData :: Snap ()
05:16:54 <Arahael> But if that's what they are, now I have something to google.
05:17:31 <Arahael> That also fails to compile.
05:17:45 <Arahael> It still expects Handle App App ()
05:17:48 <Arahael> *Handler
05:18:05 <dramforever> Arahael: Oh you are using snaplets?
05:18:15 <Arahael> dramforever: I wasn't aware I was.
05:18:25 * hackagebot hills 0.1.0.0 - Generate STL models from SRTM elevation data.  http://hackage.haskell.org/package/hills-0.1.0.0 (djf)
05:18:28 <Arahael> dramforever: Well, I do have a snaplet to serve heist templates in a different route.
05:18:36 <Arahael> dramforever: But I wasn't aware that would influence _this_ route?
05:18:57 <dramforever> Arahael: snaplets and (so called) regular snap apps have different types
05:19:10 <dramforever> Arahael: did you do makeLenses ''App?
05:19:17 <Arahael> dramforever: Let me check.
05:19:41 <Arahael> The Application.hs has that - seems 'snap init' does that by default.
05:19:47 <Arahael> I've yet to know what that does.
05:19:55 <dramforever> Arahael: oh snap init uses snaplets
05:20:23 <dramforever> Arahael: are you following some tutorial?
05:20:53 <Arahael> dramforever: I'm only using the snapframework site there.  I do have Real World Haskell as well though, which I'm reading.
05:21:21 <dramforever> http://snapframework.com/docs/tutorials/snaplets-tutorial <- this?
05:21:45 <Arahael> No, not that one.
05:21:58 <Arahael> All I wanted to do was return static text for a given handler, didn't realise I was using snaplets.
05:22:25 <Arahael> So I tried to use the Snap.Core docs instead, to keep it simple(!)
05:22:49 <dramforever> Arahael: maybe you should try starting from scratch
05:23:00 <dramforever> snap init is not your friend in this way...
05:23:48 <dramforever> Arahael: http://snapframework.com/docs/tutorials/snap-api are you reading this?
05:24:14 <dramforever> if so then "snap init" is not for you
05:24:28 <Arahael> dramforever: I've read it, yes.
05:24:38 <dramforever> then snap init is not for you
05:24:45 <Arahael> dramforever: That's pretty much what I'm doing. Now, that's nuts.
05:25:10 <t7> snap init barebones
05:25:24 <Arahael> dramforever: I thought snap init was the easiest way for me to do this. :(  I needed to use a heist template in a different route.
05:25:33 <Arahael> Now I just wanted to implement an ajax callback.
05:26:23 <Arahael> I mean, I tried 'snap init barebones' first.  But it didn't do heist.
05:27:43 <Arahael> Any more suggestions?
05:28:26 * hackagebot lxc 0.3 - High level Haskell bindings to LXC (Linux containers).  http://hackage.haskell.org/package/lxc-0.3 (NickolayKudasov)
05:28:33 <Arahael> I'm getting a little frustrated here, but this is just a personal project - so thankfully not under any sort of time pressure whatsoever.
05:29:00 <Arahael> So in the mean time, I should read up on polymorphic types, right? Anything else in particular?
05:29:03 <vanila> Arahael, you could try a lighter weight library
05:29:26 <Arahael> vanila: Do you have a suggestion?
05:30:01 <vanila> Arahael, I was actually looking out for more lightweight ones yesterday but I didnt find a nice one - maybe someone here knows of one?
05:30:18 <vanila> snap is good but quite a serious framework
05:30:48 <Arahael> vanila: I'd personally like to figure this out, especially as I'll learn quite a bit of haskell in the process, by the sounds of it.
05:31:11 <Arahael> I actually quite like heist, too.
05:31:11 <vanila> sure!
05:31:32 <tdammers> vanila: scotty is *very* lightweight
05:31:48 <tdammers> vanila: if you want something even lighter, talking to Warp directly might work
05:31:59 <tdammers> but then you have to do all your POST variable parsing etc. yourself
05:32:00 <vanila> thanks tdammers :)
05:32:17 <srhb> Arahael: Adding heist to the barebones init is super simple
05:32:20 <Arahael> tdammers: I actually considered warp first, but I didn't find many docs for it - snapframework seemed to have lots of helpful docs.
05:32:31 <tdammers> warp is quite low-level
05:32:42 <tdammers> you need to know what you're doing, basically
05:32:53 <tdammers> if you do, then the haddock it provides should be enough
05:33:11 <tdammers> and if you don't, you're better off stepping up a level in terms of abstraction
05:33:22 <tdammers> (i.e., use a more comfortable framework)
05:33:39 <Arahael> tdammers: I'm pretty comfortable with raw http, actually, but I'd rather step up in abstraction a bit.
05:33:50 <tdammers> look into scotty maybe
05:34:00 <srhb> Arahael: Happstack has a more barebonesy feel than Snap, too.
05:34:15 <tdammers> oh right, happstack
05:34:19 <tdammers> that one is very nice, too
05:34:22 <tdammers> good documentation, too
05:34:30 <srhb> Definitely.
05:34:39 <Arahael> Sounds like I should probalby use happstack, then?
05:35:03 <srhb> Arahael: I missed the start of the conversation, but assuming you want more barebones than Snap, Happstack is a viable choice, yes/
05:35:38 <srhb> OTOH I don't understand why anyone would ever use Warp as a basis of building a web application directly, so YMMV
05:35:45 <Arahael> srhb: No, all I wanted to do was return the string "{foo}", for a given route.
05:36:13 <tdammers> srhb: depends... if you need full control over HTTP, and you're building something that's not a dynamic website in the conventional sense, I can understand
05:36:13 <srhb> Arahael: Right, but that's really simple in both Snap and Happstack
05:36:28 <tdammers> it's also trivial in scotty
05:36:34 <srhb> Indeed.
05:36:44 <Arahael> srhb: And we seem to have gotten into a tangent, despite the fact that I'm very happy with heist, but apparently "snap init" is radically different to "snap init barebones", so different infact, that I might as well disregard the documentation.
05:36:48 <srhb> My point was that there's no real difference in how complicated it is
05:36:53 <Arahael> srhb: I'm being a bit snarky, I appologise. :(
05:36:58 <srhb> Arahael: That's not true. :)
05:37:23 <srhb> Arahael: The snap init thing is nice especially if you want the dynamic loader, but you might as well forego it if you don't want it.
05:37:40 <srhb> Arahael: The fact that the base application in the barebones init doesn't wrap itself in a snaplet is the only difference, which is trivially altered.
05:37:40 <Arahael> srhb: The dynamic loader has been extremely useful, actually.
05:37:49 <srhb> Arahael: Right, which is why snap init is nice, really. :)
05:38:26 * hackagebot simple-sendfile 0.2.18 - Cross platform library for the sendfile system call  http://hackage.haskell.org/package/simple-sendfile-0.2.18 (KazuYamamoto)
05:38:32 <Arahael> srhb: There's a fair few very nice things I like about the snap framework - but my lack of haskell knowledge is letting me down :(
05:39:02 <srhb> Arahael: Well, feel free to ask if you need help. My bet is you'd run into similar problems with all other frameworks too. Might as well get help to understand one of them first.
05:39:10 <srhb> Arahael: Otherwise you'll just be bouncing back and forth with no real reason/
05:39:21 <Arahael> srhb: I'm inclined to agree.
05:39:38 <Arahael> srhb: But I do need a pointer or suggestion as to the next thing to learn and read up on.
05:40:04 <Arahael> srhb: Because right now no matter what type signature I put onto the function that I put into my routes list, I get a bunch of type errors.
05:40:35 <srhb> Arahael: This is where starting out with web apps is perhaps a bit daunting, but how about we work with a specific problem and start to sort that out and try to point you to the necessary knowledge to fix that/
05:40:48 <srhb> Arahael: I'd be happy to help with that at least, and I'm around for some hours from now at least.
05:40:56 <Arahael> srhb: Ok, http://paste.debian.net/123591/ <-- That's the immediate issue.
05:41:12 <Arahael> srhb: Note: The code in serveApiData is probably wrong as well.
05:42:05 <srhb> Arahael: So the immediate problem is that you're claiming that serveApiData has type Snap a, which it does not.
05:42:10 <Arahael> srhb: The web app aspects I'm OK with - it's new to me but I've been programming for a long time. The haskell bit, however, is a bit daunting as it's very different - I haven't even done ML languages.
05:42:16 <srhb> Arahael: You can verify that by checking the type of writeBS
05:43:09 <nkar> Arahael: try to read about monad transformers since they are used in most (all?) web frameworks
05:43:33 <Arahael> nkar: Is that in Real World Haskell? I must confess I don't know much about them yet.
05:43:37 <Arahael> srhb: That seems to be: writeBS :: MonadSnap m => ByteString -> m ()
05:43:40 <srhb> That's good advice, but the problem is in fact simpler than that in that case. It's similar to me claiming foo :: String; foo = 12
05:44:09 <srhb> Arahael: Yes, and since the value of serveApiData is writeBS $ ... -- it's type is the resulting type of writeBS as well
05:44:35 <srhb> Arahael: And while Snap is an instance of MonadSnap, (so Snap ... is a correct type) -- but () and a are quite different.
05:44:53 <nkar> Arahael: any accessible article will do.  no need to stick to rwh.
05:45:06 <Arahael> nkar: I've got RWH.
05:45:14 <srhb> I dislike RWH for that purpose personally.
05:45:23 <srhb> I'd look at this: http://en.wikibooks.org/wiki/Haskell/Monad_transformers
05:45:37 <srhb> And then recurse to simpler topics in that, as long as it's NOT accessible. :-)
05:45:49 <tdammers> rwh is great for getting a general overview of concepts and idioms, but it's not so good as far as libraries go - just too old to be relevant there
05:45:53 <Arahael> That confuses me? "as long as it's NOT accessible."?
05:45:57 <nkar> I'd also recommend that.
05:46:21 <Arahael> tdammers: Ah - so I should read and learn RWH, but realise it won't teach me about newer, modern changes?
05:46:28 <srhb> Arahael: I meant if there are things in the article I linked you do not understand, you should read a guide on those specific topics first
05:46:35 <Arahael> srhb: Ah, ok.
05:46:35 <srhb> Arahael: Then come back to the monad transformer article
05:47:05 <Arahael> srhb: Sounds good.  Perhaps we should stop here (as it's getting late) - also now because I've got a clear task to do next, which is read that article.
05:47:13 <tdammers> Arahael: yeah. Read RWH, it's a good book, but know that what it says may be outdated, and just extract the useful wisdom from it.
05:47:14 <srhb> Arahael: OK :)
05:47:22 <Arahael> tdammers: Thanks. :)
05:47:24 <tdammers> Arahael: it is no longer a good book for "coding along"
05:47:26 <tdammers> ;)
05:47:27 <Arahael> srhb: And thanks especially to you.
05:48:53 <srhb> o/
05:49:48 <augur> benzrf: generalizing to functors f also creates a very nice connection to the meanings of data types
05:50:54 <augur> benzrf: the result is that every continuation value   x :: Cont r a   corresponds to split fold for some data type
05:52:02 <augur> a split fold**
05:54:31 <pokoko222> best introductory books for lambda calculus?
05:56:22 <augur> pokoko222: i would recommend not using a book but instead watching some lectures from OPLSS 2012
05:56:39 <pokoko222> augur: link?
05:56:48 <augur> namely, pfenning's. from there you can then look for books or whatever, i guess
05:56:51 <augur> @where oplss2012
05:56:51 <lambdabot> https://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html
05:57:26 <augur> the most important lecture is the first; the rest are somewhat secondary, but they introduce you to some extended LC concepts that are actually really useful and help you properly grasp whats going on
05:58:01 <augur> theres the basic LC  λ→  and then theres the general concept of "an LC" which is far more important
05:58:28 * hackagebot mighttpd2 3.2.2 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-3.2.2 (KazuYamamoto)
05:59:31 <pokoko222> augur: thank you! why are there no lambda calculus textbooks? this is such a bad thing
05:59:52 <augur> there are
06:00:00 <augur> well
06:00:36 <augur> i think the closest thing is going to be a textbook on like..  functional program generally, or perhaps implementing typed functional languages, or whatever
06:00:50 <augur> because they're going to be aiming for a very broad target
06:01:12 <augur> and theyre also going to be assuming you have a bunch of things in mind when coming to the book
06:01:26 <defanor> > toUpper $ toLower '\7838'
06:01:28 <lambdabot>  '\223'
06:01:37 <pokoko222> if i come from computer science background i guess i should read the book types and programming languages
06:01:41 <pokoko222> that one seems standard
06:01:48 <augur> whereas, if you're innocent of the LC, the best route is to have a very simple introduction
06:01:52 <augur> pokoko222: no no thats my point
06:01:58 <augur> TAPL is what i meant by general
06:02:25 <pokoko222> augur: oh so that is bad?
06:02:50 <augur> TAPL isnt an intro book so much as a "ok you get the gist of things, now lets really make it do some work"
06:02:53 <augur> book
06:03:03 <augur> thats my opinion, anyway
06:03:27 <pokoko222> i found a good one called introduction to lambda calculus by Henk Barendregt
06:03:44 <augur> that might work
06:04:00 <augur> i'd still suggest starting with the first pfenning video, pokoko222
06:04:01 <vanila> That is _the_ book on lambda calculus
06:04:04 <pokoko222> yep i am on chapter 2
06:04:14 <pokoko222> ok i am downloading the video thanks
06:04:34 <pokoko222> vanila: but it is only 50 and some pages :(
06:05:10 <augur> vanila: which?
06:05:44 <vanila> The Lambda Calculus, Its Syntax and Semantics
06:06:16 <pokoko222> no no not that one
06:06:38 <pokoko222> this one http://www.cse.chalmers.se/research/group/logic/TypesSS05/Extra/geuvers.pdf
06:07:22 <pokoko222> vanila: anyway, is the one you mentioned, available for beginners?
06:07:50 <augur> vanila: possibly. i guess im just a bit cautious about packing too much into one book. the STLC is intimately wrapped up in modern proof theory and the surrounding philosophy
06:08:17 <augur> so i feel like you'd really want to devote a whole book to that topic, so that the foundational issues are cemented
06:08:29 * hackagebot fb-persistent 0.3.4 - Provides Persistent instances to Facebook types.  http://hackage.haskell.org/package/fb-persistent-0.3.4 (FelipeLessa)
06:08:31 * hackagebot yesod-fb 0.3.4 - Useful glue functions between the fb library and Yesod.  http://hackage.haskell.org/package/yesod-fb-0.3.4 (FelipeLessa)
06:08:33 * hackagebot fb 1.0.6 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-1.0.6 (FelipeLessa)
06:08:35 <augur> and then from there the more complicated formal stuff can be tackled with ease
06:09:10 <augur> but then, im biased towards a somewhat philosophical outlook :)
06:09:19 <pokoko222> augur: i will watch the lecture, and read this one http://www.cse.chalmers.se/research/group/logic/TypesSS05/Extra/geuvers.pdf and then finally the book that vanila suggested
06:09:23 <pokoko222> augur: sounds good?
06:09:37 <augur> thats almost certainly fine
06:09:49 <augur> the Pfenning lecture is a good starting point
06:09:53 <vanila> You don't need to read the book I mentioned
06:09:57 <augur> from there, things are just much easier
06:10:08 <augur> but pokoko222, the pfenning lecture is DENSE and SUBTLE
06:10:11 <augur> keep that in mind
06:11:11 <pokoko222> i need only the first one for start?
06:12:06 <augur> pokoko222: pretty much, tho the whole thing is really good
06:12:20 <pokoko222> oki doki, thank you so much!
06:12:21 <augur> pokoko222: you can also watch the videos on youtube -- search for "proof theory foundations"
06:12:34 <pokoko222> but i dont know anything about proof theory
06:12:35 <augur> pokoko222: the linked videos are 4 lectures, split into 3 vids each
06:12:47 <augur> each video is large (~1.5 gigs) hence the split
06:12:51 <augur> the youtube vids are smaller, but lower res
06:12:58 <augur> pokoko222: the lectures introduce proof theory :)
06:13:12 <augur> pfenning is giving a really bare bones "from nothing" introduction
06:13:19 <pokoko222> together with lambda calculus? ok that is scary
06:13:29 * hackagebot yesod-auth-fb 1.6.5 - Authentication backend for Yesod using Facebook.  http://hackage.haskell.org/package/yesod-auth-fb-1.6.5 (FelipeLessa)
06:13:34 <augur> you cant avoid the LC when you do modern proof theory, really
06:14:01 <augur> thats one of the insights that has emerged over the last 50 or so years
06:14:14 <augur> proof theory and the LC are inseparable
06:14:49 <pokoko222> ok i will do as you say captain :D
06:14:58 <vanila> where are the pfenning notes?
06:15:42 <augur> vanila: the vids are
06:15:45 <augur> @where oplss
06:15:45 <lambdabot> I know nothing about oplss.
06:15:47 <augur> whoops
06:15:49 * ddellacosta loves lurking on #haskell for the awesome information that floats by
06:15:50 <augur> @where oplss2012
06:15:50 <lambdabot> https://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html
06:15:57 <augur> or on youtube as i mentioned
06:16:05 <augur> there are also lecture notes on his website
06:16:07 <vanila> oh
06:16:23 <doismellburning> ddellacosta: likewise
06:16:23 <augur> http://www.cs.cmu.edu/~fp/courses/15317-f09/schedule.html
06:16:25 <augur> the readings here
06:16:47 <ddellacosta> doismellburning: :-)
06:16:54 <vanila> thanks
06:22:53 <augur> vanila: the notes on the page are actually _even better_ than the videos as an introduction
06:23:00 <augur> they REALLY go into the fundamentals
06:23:03 <augur> its wonderful
06:23:05 <vanila> great :D
06:23:16 <vanila> im loking at his compiler design page now
06:24:42 <augur> the notes on classical logic are also very interesting because of how they elucidate certain aspects of the judgmental system
06:25:11 <vanila> http://www.cs.cmu.edu/~fp/courses/linear/ looks interesting
06:25:59 <augur> its also very good, yes
06:26:08 <augur> you have to go through the constructive logic notes first tho
06:29:43 <MagneticDuck> hum... using the +s option in ghci doesn't actually tell you the time delta between when you hit enter and when you got your result, does it
06:29:53 <MagneticDuck> what kind of utility WOULD do that?
06:30:31 * MagneticDuck realises what I'm asking is much simpler than what most timing utilities were intended to do
06:31:08 <ChristianS> MagneticDuck: ghci is not intended for profiling, methinks
06:31:34 <MagneticDuck> I'm not looking at profiling
06:31:37 <geekosaur> not only that, there is zzero optimization and the bytecode interpreter wasn't designed for efficiency
06:31:42 <MagneticDuck> I'm looking at time deltas on networks =P
06:32:08 <MagneticDuck> t <- getTime >> doOperation >> (print $ timeDelta t - now)
06:32:36 <srhb> MagneticDuck: Sounds simpler to just write that function which takes doOperation as its argument?
06:32:52 <srhb> Taking laziness into account.
06:36:33 <bernalex> I'm confused
06:36:53 <bernalex> does "data kind Foo = Blah" actually exist?
06:39:23 <bennofs> bernalex: not yet iirc
06:39:42 <bernalex> bennofs: oh. please implement it. :-P
06:46:11 <MagneticDuck1> I have a bunch of UDP queries to make to a bunch of different servers
06:46:28 <MagneticDuck1> each of them takes around 250 ms, and most of that time is waiting for "recv"
06:46:45 <MagneticDuck1> what's a good reccomended way to make at concurrent, if, say, I have a list of them?
06:46:56 <MagneticDuck1> s/at/that
06:48:20 * MagneticDuck1 reading Control.Concurrent documentation, realising that there isn't really anything for this specific type of problem and he'd probably have to make his own system using IORefs
06:49:39 <MagneticDuck1> uhm, or is there a better way to do this?
06:51:39 <MagneticDuck1> anybody home?
06:52:17 <doismellburning> MagneticDuck1: forkIO?
06:53:35 <Haskellfant> MagneticDuck1: http://hackage.haskell.org/package/async-2.0.1.6/docs/Control-Concurrent-Async.html#v:mapConcurrently
06:53:45 <Haskellfant> :t mapConcurrently
06:53:46 <lambdabot> Not in scope: ‘mapConcurrently’
06:53:46 <MagneticDuck1> D
06:53:48 <MagneticDuck1> *:D
06:53:50 <MagneticDuck1> yay
06:53:54 <MagneticDuck1> ding ding ding ding
06:54:18 <MagneticDuck1> "mapConcurrently id" is kind of a concurrent form of "sequence", right?
06:54:27 <MagneticDuck1> wait, I mean
06:54:29 <MagneticDuck1> mapConcurrently return
06:54:38 <MagneticDuck1> uhm. never mind actually.
06:55:02 <Haskellfant> that's not sequence
06:55:05 <Haskellfant> :t sequence
06:55:05 <lambdabot> Monad m => [m a] -> m [a]
06:55:08 <MagneticDuck1> I understand
06:55:10 <MagneticDuck1> it's mapM
06:55:15 <MagneticDuck1> :t mapM
06:55:16 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
06:55:26 <MagneticDuck1> uhm.
06:55:29 <MagneticDuck1> :t mapM return
06:55:30 <lambdabot> Monad m => [b] -> m [b]
06:55:35 <Haskellfant> mapConcurrently is a concurrent mapM
06:55:40 <MagneticDuck1> yes, I got that
06:55:46 <MagneticDuck1> trying to remember how to turn mapM into sequence
06:55:46 <Haskellfant> with the monad fixed to io
06:55:49 <MagneticDuck1> thanks btw o/
06:56:02 <Haskellfant> np
06:56:16 <Haskellfant> not sure if you can get from mapM into sequence
06:56:36 <bennofs> :t mapM id `asTypeOf` sequence
06:56:37 <lambdabot> Monad m => [m b] -> m [b]
06:56:48 <MagneticDuck1> yes exactly
06:56:55 <Haskellfant> ah right
06:56:57 <MagneticDuck1> :t mapM id
06:56:58 <lambdabot> Monad m => [m b] -> m [b]
06:57:16 <MagneticDuck1> lol not sure why I immediately dismissed "mapM id"
07:00:59 <etandel> why does read throw an error instead of returning a Maybe?  (inb4, I know about readMaybe, but I find this strange).
07:01:58 <geekosaur> hysterical raisins
07:03:02 * hackagebot yesod-auth-fb 1.6.5 - Authentication backend for Yesod using Facebook.  http://hackage.haskell.org/package/yesod-auth-fb-1.6.5 (FelipeLessa)
07:03:02 * hackagebot iso8583-bitmaps 0.1.0.0 - Parse and merge ISO 8583-style bitmaps  http://hackage.haskell.org/package/iso8583-bitmaps-0.1.0.0 (IlyaPortnov)
07:06:06 <NikolajK> I'm trying to code up treefold as catamorphism from the Tree data type, but without coding that Tree data type, but via specification of is as the fixed point for the f-algebra underlying it.
07:06:06 <NikolajK> for this I need the more raw functor mapping b to a+b\times b. I think it's
07:06:06 <NikolajK> data Container a b = Either a (b,b)
07:06:08 <MagneticDuck1> etandel: because errors never occur
07:06:10 <NikolajK> and then I need the functor, as fmap is part of catas case analysis
07:06:10 <NikolajK> I assume it's something along the lines of
07:06:10 <NikolajK> instance Functor Container where
07:06:10 <NikolajK>     fmap f (Left x) = f x
07:06:10 <NikolajK>     fmap f (Right x) = (f (fst x), f (snd x))
07:06:12 <MagneticDuck1> ^ formal mathematical proof
07:09:33 <NikolajK> Container alone is *->*->* and there I'm stuck right now
07:11:35 <NikolajK> it doesn't take
07:11:35 <NikolajK> instance Functor Container a where
07:11:35 <NikolajK>     fmap f (Left x) = x
07:11:35 <NikolajK>     fmap f (Right pair) = (f (fst pair), f (snd pair))
07:13:04 * hackagebot putlenses 0.1.2 - Put-based lens library  http://hackage.haskell.org/package/putlenses-0.1.2 (HugoPacheco)
07:13:08 <NikolajK> how to write the fmap for such a bifunctor?
07:13:42 <quchen_> NikolajK: fmap turns Eithers into Eithers. Your Left case turns an Either something into a something.
07:14:38 <quchen> A correct way to write the Left case would be `fmap f l@(Left _) = l`.
07:14:54 <quchen> Eh wait, no.
07:14:54 <NikolajK> what is | and @
07:15:09 <quchen> This way, `fmap f (Left x) = Left x`.
07:15:28 <NikolajK> and also, I'm not 100% sure if my container is the right buling operation for List
07:16:08 <NikolajK> and is writing
07:16:08 <NikolajK> instance Functor Container a where
07:16:08 <NikolajK> legal?
07:16:10 <srhb> NikolajK: @ is used to making pattern aliases. So I can write l@(x:_) where l is now a name for the entire list, and x is a name for the head
07:16:13 <NikolajK> with the type variable a there
07:16:17 <quchen> Second, you can't write "data Container a b = Either a (b,b)", since the Either name is already taken. What you mean is probably "data Container a b = Container (Either a (b,b)).
07:16:17 <quchen> "
07:16:19 <nshepperd> instance Functor (Container a) where
07:17:22 <quchen> And now you can write a Functor instance for this thing, using "fmap f (Container (Left x)) = Container (Left x); fmap f (Container (Right (x,y))) = Container (Right (f x, f y))".
07:17:44 <nshepperd> Anyway, if you're trying to write the underlying functor for Tree, you can do it by taking the normal definition of Tree and replacing recursive instances of (Tree a) with the type variable
07:18:27 <nshepperd> eg. data TreeB a b = LeafB a | NodeB b b
07:19:26 <etandel> MagneticDuck: well, I don't think it's useful for read to throw an error when it can't parse.
07:19:41 <etandel> so I always use readMaybe
07:19:52 <nshepperd> which is indeed equivalent to Either a (b,b), but it saves you a layer of wrapping
07:20:16 <etandel> I'm just curious about when it's actually useful for it to error.
07:23:31 <srhb> etandel: It's not. Hysterical raisins, as someone said.
07:23:42 <srhb> etandel: read should only be used if you know that the parse cannot possibly fail.
07:24:02 <NikolajK> okay
07:24:03 <NikolajK> data Container a b = ContainerLeft a | ContainerRight b b
07:24:03 <NikolajK> instance Functor (Container a) where
07:24:03 <NikolajK>     fmap f (ContainerLeft z) = (ContainerLeft z)
07:24:03 <NikolajK>     fmap f (ContainerRight x y) = (ContainerRight (f x) (f y))
07:24:03 <NikolajK> compiles
07:24:04 <srhb> etandel: Or for toy programs where you just don't care.
07:24:20 <srhb> etandel: Same goes for head and tail, etc.
07:24:47 <etandel> oh
07:24:48 <etandel> thanks all
07:26:54 <sgraf_> Has anyone experience with PE parsing? I found the peparser and pecoff libraries on hackage and wonder which one to use.
07:29:31 <nshepperd> NikolajK: yep, that looks right
07:29:49 <killerstorm> hey, any haste-compiler users here? I've installed it via cabal, and it is kinda unruly :(
07:30:45 <lf94> killerstorm: I was thinking about it but Elm looks way more functional (I mean that in the "can do way more" sense)
07:34:05 <killerstorm> lf94: how close is it to Haskell?
07:35:07 <lf94> killerstorm: They claim it is not meant to be like haskell, but it really is close
07:35:29 <lf94> There are subtle differences, but they are actually helpful than harmful
07:35:35 <lf94> :: and : are switched
07:35:46 <lf94> and data and type will be switching IIRC
07:36:11 <lf94> Otherwise, when I first looked at it, looked exactly like Haskell
07:39:48 <bmuk> So arrows are morphisms, but in Category Theory morphisms are more general than functions? In Set Theory, the morphisms *are* functions, but because a category need not be a set (or even resemble a set) the morphisms are not always functions?
07:45:08 <beckyconning> does anyone know how to clear the 'haCharBuffer' between 'hGetChar's?
07:45:10 <nshepperd> bmuk: they can be non-function things
07:46:48 <nshepperd> bmuk: I think an example is a category induced by a partially ordered set. The objects are elements of the set, and there is exactly one morphism A -> B iff A ≤ B
07:48:05 <nshepperd> bmuk: in this case "what the morphisms are" doesn't really matter, except that they witness the fact A ≤ B, or ¬(A ≤ B)
07:48:07 * hackagebot rakhana 0.2.0.2 - Stream based PDF library  http://hackage.haskell.org/package/rakhana-0.2.0.2 (YorickLaupa)
07:48:39 <bmuk> nshepperd: Last time I brought this up, there were several examples (I believe including this one). ekmett brought up the category of integers where the arrows are A -> B, A < B
07:49:45 <bmuk> so that is a similar situation. I have read that Set Theory is concered with what mathematical objects *are*, whereas Category Theory is more concerned with how they behave.
07:49:59 <edwardk> bmuk: alternately a Monoid, where you have a single formal object that doesn't matter, and arrows that all go from that object to itself, where mappend is now (.) and mempty is id
07:50:56 <edwardk> so if you are talking about addition you have 'arrows' 4, 6, 1203, etc. and 4 . 6 = 10
07:51:41 <bmuk> I see. This is all very interesting - it presents a radically new way to view mathematics as a whole.
07:52:40 <nshepperd> well, it seems to me that category theory takes the abstract algebra approach of stating a few axioms and seeing 1. what sort of things match those axioms and 2. what sort of theorems can be derived from these axioms
07:52:45 <bmuk> But it is somewhat difficult for me to imagine a monoid as a category with a single object when I have no intuition of *what* that object is. I suppose it does not matter.
07:53:45 <lf94> monads functors applicatives what has this programming world come to
07:54:19 <bmuk> Other than numerical monoids, can you give me an example of a monoid that you have used in your code? (That you defined)
07:54:23 <lf94> What's an isomorphism
07:54:54 <lf94> What's the true meaning of polymorphic
07:55:21 <bmuk> lf94: if a morphism is a "mapping" or more formally, an operation A -> B, an isomorphism is the inverse - B -> A
07:56:28 <nshepperd> an isomorphism is a morphism that has an inverse
07:56:48 <bmuk> nshepperd: so it isn't the inverse? Just a morphism that has an inverse?
07:57:29 <bennofs> bmuk: I think an isomorphism is a pair of morphisms f, g such that f . g = id = g . f
07:57:47 <nshepperd> a morphism f : A → B such that g : B → A exists, and f . g and g . f are both identity morphisms
07:58:23 <nshepperd> you can call f itself or the pair (f,g) an isomorphism
07:58:26 <bmuk> Ah okay. So having an inverse is the defining property of an isomorphism
07:58:37 <lf94> Here we go, different definitions of morphisms
07:58:49 <hpc> it's not really interesting to talk about f itself as the isomorphism, so it's usually the pair that is used
07:58:50 <lf94> And this is why my mind explodes
07:59:23 <bmuk> lf94: hold on to that feeling, it's how we grow :)
08:00:30 <lf94> So what's a morphism? A transformation of a set?
08:00:37 <lf94> (According to your notation)
08:00:50 <lf94> Turning A into a new set B
08:01:02 <lf94> But to be isomorphic you can change B back to A?...
08:02:03 <bmuk> lf94: as I understand it, a morphism is an operation. Not necessarily a function, not necessarily on sets. It is more general than that. http://en.wikipedia.org/wiki/Morphism
08:02:09 <johnw> lf94: morphisms are a generalization; transformation of a set (a function) is a kind of morphism
08:02:12 <danilo2> edwardk: Hello Edward! :) I've got a little complex trifecta question. Is it possible to somehow write a parser combinator foo, which will parse lets say a string and based on the result it will fail or continue parsing in such way, that if it fails, we handle the string parsing as if it would be inside try block? For example I want to parse string. If the parsed string was "bar" I want this parser to behave exactyly as this string 
08:02:47 <johnw> lf94: for example, in the category of graphs, edges are morphisms; in the category of a monoid, the "values" are the morphisms
08:02:59 <edwardk> how does that differ from writing your parser combinator foo inside a try block?
08:02:59 <nshepperd> in this context a morphism is just a "thing" with a "from" and a "to" end
08:03:20 <lf94> johnw: ok
08:03:28 <lf94> I can live with that
08:03:40 <edwardk> bmuk: the single object is just a formal place to hang those arrows.
08:04:04 <johnw> yeah, in one sense objects aer just a way to distinguish morphisms, nothing else
08:04:12 <bmuk> edwardk: So it is just a formalism, since it is the arrows themselves (the integers) that we are interested in.
08:04:18 <johnw> since any object is equivalent to the set of morphisms in or out
08:04:32 <edwardk> bmuk: yes, but in general that is the case of all objects, they are just a place to hang arrows
08:04:38 <edwardk> and categories are just a place to hang functors
08:04:46 <johnw> :)
08:04:47 <edwardk> and functors are just a place to hang natural transformations
08:05:08 <edwardk> and natural transformations are just so we can know how to talk about adjunctions ;)
08:05:10 <vanila> yeah wasnt category theory just  invented to define natural transofmrs? :)
08:05:16 <vanila> oh adjunctions!
08:05:41 <johnw> i like adjunctions because they can give you an isomorphism in places where you were sure none existed
08:05:45 <bmuk> so when we are talking about the monoid of integers, we are therefore actually talking about integers. But in the category of integers where the arrows are addition, it is the addition that we are interested in, not the integers?
08:05:57 <SwashBuckla> heh, simple things like
08:06:02 <SwashBuckla> y = y + 1
08:06:13 <johnw> btw, if no one has read it yet, the paper "Reason Isomorphically!" (http://www.cs.ox.ac.uk/ralf.hinze/publications/WGP10.pdf) is absolutely fantastic
08:06:22 <SwashBuckla> make me realise the implications of definition instead of assignment
08:06:24 <lf94> johnw: what makes a morphism a morphism?
08:06:40 <danilo2> edwardk: it differs. Lets think about such use case: We've got a (Map String (Parser ...)). If we for example parse string "if" then we look for an if-parser and start using it further. So If the string was "if" we do not want to use try block outside to get any sensible errors during further parsing. brb
08:06:42 <johnw> lf94: the presence of a domain and codomain, composition and an identity for composition
08:06:52 <lf94> OK :)
08:07:08 <edwardk> danilo2: oh you are looking to race parsers
08:07:14 <blogle> does anyone know of some resources to quickly get to speed on extending lambda calculus to support floating point operations?
08:07:15 <johnw> in fact, many libraries define categories simply by identify the shape of its morphisms
08:07:23 <vektor> Hey folks. I need the type signatures of a few functions as Strings - is there any way I can get GHCi's :t output into a file or so in a convenient way?
08:07:30 <lf94> johnw I bet you have a math master degree
08:07:31 <lf94> B)
08:07:35 <johnw> lf94: nope
08:07:39 <lf94> PhD B)
08:07:44 <johnw> no degree at all
08:07:44 <danilo2> edwardk: Of course the idea with "if" sounds crazy. But think about language which allows you to declare such functions like "def (if then else) ... :" - if I parse "if" then I'm looking for appropriate parser for this function. But If I p[arse something that does not exist, I want the aprser to fail and then I need the try block
08:07:47 <edwardk> danilo2: https://github.com/ekmett/trifecta/issues/28 talks about that somewhat and how we need a combinator for it
08:07:51 <lf94> then you are one smart cookie
08:08:26 <lf94> I'll give that paper a read
08:08:32 <johnw> lf94: my recipe for success: hang out around edwardk, and set yourself the task of continuing to read whatever he suggests that you to read until he doesn't sound like he's talking nonsense all the time
08:08:53 <vektor> lol
08:09:00 <johnw> i'm 100% serious
08:09:03 <nshepperd> bmuk: there isn't really a "monoid of integers". there's a monoid of integer addition, which consist of the set of integers together with the addition operation. when you represent such a monoid can be represented as a category, the integers live in the arrows, so it is the arrows that are interesting
08:09:05 <vanila> blogle, that question doesn't make much sense
08:09:07 <johnw> edwardk is my whetstone
08:09:12 <lf94> Who is edwardk
08:09:35 <lf94> johnw: do you have anything else to read
08:09:41 <vanila> blogle, you can add any pure functions to lambda calculus, float stuff shouldn't be special/different in any way
08:09:41 <dgpratt> is there an easy way to show a String as a list of Char?
08:09:58 <johnw> lf94: I have so much to read it's not helpful to share it all; but if you have a specific interest, I can offer a few things I'm sure
08:10:05 <edwardk> johnw: i give you props for sticking with the 'decode edwardk program' so long ;)
08:10:25 <danilo2> edwardk: Ok good to know that. You are right. I need to race oparsers - what is the status of its support in ttrifecta or trifecta2?
08:10:29 <lf94> johnw: just something about fundamentals of something that will help me with haskell
08:10:45 <edwardk> danilo2: will be supported in the next major release
08:10:51 <edwardk> danilo2: not available now
08:11:10 <edwardk> for now i'd 'try' and accept the 'moved' error messages
08:11:25 <danilo2> edwardk: Additional - I've got a question regarding trifecta2 - would you consider making errors a data types? I would love to be able to throw a datatype error and then handle it in proper way. Strings are good, but custom datatypes which are instances of some class woudl be much more usefull.
08:12:08 <danilo2> edwardk: What do you mean by "accept the 'moved' error messages" ?
08:12:30 <johnw> lf94: to grasp the fundamentals of a language like Haskell, I'd recommend something that talks about the lambda calculus and how it works, like Pierce's book on Types and Programming Languages.  Don't worry if the first few chapters are a bit dry, that book gets a lot more interest about 5 chapters in
08:12:31 <blogle> vanila: I was curious if there was a similar representation for floats as church numerals are to real numbers
08:12:41 <edwardk> danilo2: the problem with that is that i'd have to parameterize the type
08:12:57 <lf94> johwn: Alright :)
08:13:06 <edwardk> danilo2: well, if you try foo <?> "foo" and an error occurs inside foo it just complains that what you wrote isn't a foo.
08:13:09 <vektor> So... what I need is something like ("head", "[a] -> a"), just for a bunch of functions. Do you guys know how to make haskell do that?
08:13:09 <vanila> blogle, ah,  well you can encode any algebraic data type pretty easily
08:13:15 <edwardk> danilo2: regardless of where in foo it failed
08:13:21 <vanila> so if you can make an ADT that lets you implement something like floats that woul dbe a good start
08:13:37 <vanila> thne look up how to encode other algebraic structures than just numbers in the church encoding
08:13:39 <edwardk> so it 'moves' you back to the foo, and complains there
08:13:41 <danilo2> edwardk: I understand, but maybe it is a good decision? After parsing I would just love to get datatype with result or my custom error consturctor, which I can handle further. Right now this is one fo the biggest problem we've got while writing any parser using trifecta / parsec
08:14:20 <johnw> edwardk: knowing a person who can be a constant well of inspiration like yourself is supremely valuable; you have no idea how much I appreciate that, and how much it's gotten me to where I am now :)
08:14:43 <edwardk> danilo2: i tried that approach first actually. i got bogged down trying to make it happen in practice
08:14:48 <danilo2> edwardk: Of course - then this error is not understancfdable - right now - if I've got error inside of if construction I've got "expecting expression" error. Would you mind providing me any informations when the next release could happen ?
08:15:10 <lf94> I bet edwardk is a prodigy
08:15:15 <NikolajK> quchen: (treefold via functor fixed point and f-algebras)
08:15:15 <NikolajK> http://pastebin.com/ffQacznZ
08:15:15 <edwardk> danilo2: it is going to be entirely driven by my needs at the office, sorry
08:15:22 <edwardk> danilo2: i don't have a good timeline right now
08:15:23 <blogle> vanila: thanks I will start to explore along that path
08:15:24 <bennofs> edwardk: btw, are there any plans to support using a custom lexer with trifecta (or is it already supported?)
08:15:28 <edwardk> danilo2: most of the work is done
08:15:40 <danilo2> edwardk: Oh :( That would be much better approach than any existing one. do you think it would be possible to try it again ?
08:15:56 <johnw> lf94: he's smart, dedicated and doesn't sleep much; that's always a good recipe for progress
08:16:14 <edwardk> bennofs: that is also something i initially set out to support, but got too complicated and was pulled. it _also_ becomes a parameter on the parser, slows things down even further, and interacts in very complex ways with what is the whole point of trifecta to me, which is error reporting
08:16:50 <johnw> lf94: if you're looking for something more interactive (and in my opinion, a lot more fun), check out http://www.cis.upenn.edu/~bcpierce/sf/current/index.html
08:16:50 <edwardk> with trifecta my main goal was providing clang style error reporting. both of these goals were getting in the way of that, so they got pulled
08:17:10 <danilo2> edwardk: Ok, so could you just give me some hints how would you implement parser raising? If I'll have more time maybe I would dig inside it and try to improve it?
08:17:28 <edwardk> parser racing you mean?
08:17:43 <edwardk> it doesn't work in current trifecta, we lose too much info in the Error case right now
08:17:49 <edwardk> that's why it needs the rewrite to be finished
08:18:06 <danilo2> edwardk: yes, I mean parser racing
08:18:17 <danilo2> edwardk: oh :(
08:18:29 <edwardk> the error case needs to know the position at which it fails, and to not have not collapsed the error message yet
08:18:30 <lf94> reisio: xchat ftw
08:18:42 <danilo2> edwardk: by the way - parametrised parser would be slower? I think If it is used in proper way, ghc would inline it, am I right?
08:18:49 <edwardk> then when i race two parsers if they make it to the same point then i have to combine errors, right now we don't
08:19:00 <edwardk> danilo2: it'll be slower
08:19:05 <edwardk> danilo2: too many recursive parsers
08:19:10 <edwardk> expect little inlining
08:19:52 <danilo2> edwardk: ahh, so the slowdown would occur when using recursive parsers? So GHC would not wortk as C++ compiler? I mean - would it not create specialized implementations ?
08:20:12 <edwardk> danilo2: it generally can't. remember we have polymorphic recursion, unlike c++
08:21:55 <danilo2> edwardk: That is very interesting. In fact you've just provided an info I was very long looking for. Could you tell me please a few words more about polymorphic recursion? Why cannot we create all the specializations needed for such recursion? We know all the types of all recursion calls rduring compilation time, dont we?
08:22:31 <edwardk> consider data Jet f a = a :- Jet f (f a)
08:22:45 <edwardk> if you look at it, it is something like a :- f a :- f (f a) :- f (f (f a)) :- ...
08:23:34 <edwardk> data Complete a = Tip a | Bin (Complete (a,a)) -- which is either Tip a, Bin (Tip (a,b)), Bin (Bin (Tip ((a,b),(c,d))))...
08:23:43 <edwardk> notice the changing shape as we recurse
08:24:13 <edwardk> there are an infinite number of cases to compile, it is a fundamentally different problem than c++ template specialization
08:24:25 <danilo2> edwardk: ok, I see it - thank you very much! But will GHC specialize it If we do not use such "complicated" data types ?
08:24:30 <edwardk> no
08:24:55 <edwardk> it might specialize the loop, but in my experience ghc is very bad at doing anything automatic around recursive functions
08:25:28 <edwardk> it'll invariably pick a bad loop breaker, and inlining in these cases is not always a win
08:25:46 <danilo2> edwardk: Ok so to sum this up - GHC could do it (theoretically) but it is just bad at it when dealing with recursion?
08:25:57 <edwardk> i don't think ghc could, honestly
08:26:09 <edwardk> there is a whole cottage industry of super-optimizers that do this, but they don't do it soundly
08:26:48 <edwardk> and i don't think there is any good cost / detection heuristic to get it to happen 'in the few cases it could'
08:26:54 <edwardk> i'd happily be proven wrong
08:27:00 <danilo2> edwardk: Ok, thank you for all the informations and help! :)
08:27:01 <edwardk> but that is my gut reaction
08:27:19 <edwardk> gotta go
08:27:38 <danilo2> edwardk: Interesting. I've got to read about it and maybe talk more in a time on #GHC :) Thank you very much! :)
08:28:55 <troyd> is there a way to update cabal database manually? my corporate http proxy blocks .tar.gz urls
08:32:06 <johnw> sure
08:32:26 <johnw> troyd: you can use this: https://gist.github.com/839377573eb8efe3328e
08:32:46 <johnw> "cabal update" just downloads a file, that's all, so you can download that file however you want to, so long as you unzip it and put it in the right place
08:33:12 <troyd> johnw: thx
08:34:03 <johnw> if you use pv, drop the "-s $size" field
08:34:15 <johnw> there's a way to get Hackage to tell you, but I hadn't figured it out yet, and the download happens fast enough
08:38:06 <troyd> johnw: well I did it but now I can't install anything using cabal as everything is packaged into .tar.gz
08:38:25 <troyd> I think I'll have to manually install everything myself
08:38:42 <johnw> troyd: let's talk in #hackage?
08:46:12 <shmookey> having trouble getting the signature for a type-safe 'filter' right, any advice? http://lpaste.net/111817
08:48:12 * hackagebot creatur 5.6.3 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.6.3 (AmyDeBuitleir)
08:48:52 <shmookey> i think the general issue is that ghc can't determine an unambiguous value for m from n
08:51:59 <vanila> shmookey, you can't write filter with length indexed lists
08:52:24 <vanila> oh you have a m <= n constaint
08:52:34 <vanila> that may be possible
08:52:56 <vanila> let me try this..
08:54:19 <vanila> shmookey, what you currently have seems to be saying that for ANY n,m with m <= n, IntList n filters to IntList m
08:54:25 <vanila> but there's only one such m
08:56:17 <vanila> it's not clear how you wouldexpress that filter IntList n gives you an IntList which is smaller
08:56:59 <eacameron> Has anyone seen this rosetta code analysis? It doesn't paint Haskell in good light in terms of performance and I'm curious what others think: http://arxiv.org/pdf/1409.0252.pdf
08:57:24 <eacameron> Actually, go here: http://se.inf.ethz.ch/people/nanz/research/rosettacode.html
08:57:41 <eacameron> that provides a summary
08:59:05 <nshepperd> shmookey: looks like m needs to be existential quantified here
09:00:14 <shmookey> vanila: yeah :/
09:00:27 <shmookey> nshepperd: i suspect so but i'm having a lot of trouble figuring out where
09:00:34 <nshepperd> or do a cps transformation and accept a polymorphic continuation
09:01:38 <ChristianS> eacameron: rosetta code snippets are quite small and not always complete, i wonder how the actually compiled and run the programs?
09:02:28 <ChristianS> eacameron: anyone, such small snippets hardly allow drawing any interesting performance conclusion, especially as they weren't written to be fast
09:02:53 <nshepperd> filter :: (Int -> Bool) -> IntList n -> (forall m. (m :<= n ~ 'True) => IntList m -> c) -> c
09:03:06 <nshepperd> or some such
09:03:31 <ChristianS> eacameron: in my experience, haskell is quite fast if you try a bit to make it fast, certainly much much faster than python or other scripting languages
09:03:45 <vanila> "My brain just exploded"
09:04:16 <eacameron> christians: That's what I've seen as well, but the analysis seems to say Haskell is terribly slow in comparison
09:04:22 <simpson> Languages are not fast or slow. Implementations are fast or slow.
09:04:30 <eacameron> simpson: good point
09:04:38 <eacameron> it's more about "cap" speed
09:04:48 <eacameron> or max speed
09:04:49 <shmookey> nshepperd: wow, ok thanks! that's an unfamiliar technique to me so i'll have to study it for a bit
09:04:59 <eacameron> which is likely very hard to determine
09:05:26 * simpson shrugs
09:05:48 <simpson> When you talk in terms of "scripting" languages, and writing languages off based on what you hear rather than what is possible, then you lose.
09:06:19 <b0fh_ua> Hello! Given a list of tokens, is there some library, which could have a function to generate N unique sequences by M tokens in each?
09:07:39 <Haskellfant> b0fh_ua: can the same token occur multiple times in the same sequence?
09:07:55 <b0fh_ua> nope, only once
09:08:14 * hackagebot haskelldb 2.2.4 - A library of combinators for generating and executing SQL statements.  http://hackage.haskell.org/package/haskelldb-2.2.4 (JustinBailey)
09:08:23 <b0fh_ua> the number of tokens in a sequence is 3-4
09:08:31 <b0fh_ua> and the total number of tokens is around 1000
09:09:09 <vanila> shmookey, http://lpaste.net/111817
09:13:14 * hackagebot som 7.2.3 - Self-Organising Maps  http://hackage.haskell.org/package/som-7.2.3 (AmyDeBuitleir)
09:13:43 <shmookey> vanila: the url i posted?
09:14:36 <vanila> I annotated it
09:15:17 <shmookey> ah yep i see now
09:17:12 <shmookey> vanila: interesting, thanks!
09:17:52 <srhb> b0fh_ua: Generate sequence, check if it's already there, if so discard, rinse and repeat? :-P
09:23:15 * hackagebot ghcid 0.1.3 - GHCi based bare bones IDE  http://hackage.haskell.org/package/ghcid-0.1.3 (NeilMitchell)
09:27:38 <rascal> hello, is anyone not in the course going through the CIS 194 assignments (http://www.seas.upenn.edu/~cis194/lectures.html)
09:29:33 <shlomocomputer> I'm having trouble finding the syntax for using library functions without an "import" statement.
09:29:55 <shlomocomputer> Can you do something like "Data.List.elemIndex" without explicitly importing Data.List?
09:30:02 <merijn> shlomocomputer: eh, that would be because you can't
09:30:12 <shlomocomputer> Then that would make that make sense, then.
09:30:38 <shlomocomputer> merijn: thank you
09:33:57 <rascal> I'm trying to build a function that does this: 1234 -> [1,2,3,4]
09:34:10 <rascal>  toDigits :: Integer -> [Integer] toDigits 0 = [] toDigits n = toDigits (dropLastDigit n) : [lastDigit n]
09:34:59 <rascal> this is better: http://lpaste.net/111819
09:35:13 <rascal> the toDigits function is not working
09:37:11 <rascal> any ideas?
09:38:27 <bennofs> rascal: doesn't that produce a type error?
09:38:43 <rascal> yes
09:39:22 <bennofs> Here's a hint: appending to haskell linked-lists is evil. What about first building the list in reverse (prepending each new digit) and the applying reverse at the end?
09:40:52 <bennofs> rascal: the cause of the type error is this: (:) :: a -> [a] -> [a], but you're passing toDigits (dropLastDigit n) as first argument, which has type [Integer], not Integer
09:41:40 <rascal> thanks for the hint, I'll try the reverse idea
09:42:23 <kcc> > reverse $ unfoldr (\i -> if i == 0 then Nothing else Just (rem i 10, div i 10)) 1234
09:42:25 <lambdabot>  [1,2,3,4]
09:42:50 <joelteon> :t rem &&& div\
09:42:51 <lambdabot> parse error on input ‘\’
09:42:55 <joelteon> whoops sorry lambdabot
09:44:04 <bennofs> :t quotRem
09:44:05 <lambdabot> Integral a => a -> a -> (a, a)
09:44:08 <merijn> :t map digitToInt . show -- bah, silly overcomplicated solutions
09:44:09 <lambdabot> Show a => a -> [Int]
09:44:19 <joelteon> now do base 11!
09:44:29 <merijn> > map digitToInt . show $ 9759752
09:44:30 <lambdabot>  [9,7,5,9,7,5,2]
09:44:49 <bennofs> > base 11 # 10
09:44:50 <lambdabot>  "a"
09:46:19 <rascal> wow nice. i'm trying to go thru the assignments from the penn cis 194 course just as a way to learn haskell (not a student there) so that is why it  appears overcomplicated
09:49:09 <zipper> After reading Learn You a Haskell I am looking for something to do, to better myself. Any suggestions?
09:49:37 <vanila> zipper, maybe create a project
09:51:15 <josephle> vanila: the hard part is finding a project...maybe harder than actually coding it :)
09:51:18 <ajcoppa> zipper: there are a few good courses we recommend with exercises for you to do to reinforce the knowledge you learned from LYAH
09:51:41 <ajcoppa> i recommend checking out this link and joining us in #haskell-beginners: https://github.com/bitemyapp/learnhaskell
09:51:44 <srhb> zipper: You could have invented monads, typeclassopedia :-)
09:52:17 <zipper> ajcoppa: Thanks :)
09:52:37 <zipper> ajcoppa: Are you bitemyapp?
09:52:47 <ajcoppa> nope
09:52:54 <ajcoppa> bitemyapp is bitemyapp :)
09:53:15 <merijn> You can write my tests for me, because I'm lazy :p
09:53:17 * hackagebot yst 0.4.1.1 - Builds a static website from templates and data in YAML or  CSV files.  http://hackage.haskell.org/package/yst-0.4.1.1 (JohnMacFarlane)
09:57:28 <zipper> merijn: I actually would like that but I don't know if I am good enough yet. Link to the repo?
09:59:15 <shlomocomputer> OK, so I'm pretty new to Haskell but I think I have a pretty good grasp of IO, Control.Monad, and the like
09:59:26 <shlomocomputer> What it very tough for me is more of a poetic thing I guess
09:59:42 <shlomocomputer> Do notation is *such* a close call with monadic binding and lambdas
09:59:58 <shlomocomputer> It is just so hard to settle on any kind of consistent style.
10:00:02 <srhb> shlomocomputer: What do you mean close call?
10:00:38 <shlomocomputer> Like, they're almost as:  verbose, clear, expressive, etc.
10:00:43 <shlomocomputer> as each other
10:00:56 <srhb> shlomocomputer: Well, if you have a ton of >>= \a -> ... >>= ... -- do notation might be clearer :)
10:01:15 <srhb> shlomocomputer: But of course it's the same.
10:01:23 <shlomocomputer> Thing is, because of a desire to have short and sweet functions, I never really do have "a ton"
10:01:34 <srhb> Then you might opt to stay with >>= and lambdas.
10:01:50 <shlomocomputer> srhb:  Why?
10:01:57 <shlomocomputer> It is more "haskelly"?
10:02:01 <srhb> shlomocomputer: Well, it's often neat and readable if it's short enough.
10:02:35 <shlomocomputer> I agree.  It looks like composition.
10:02:39 <srhb> shlomocomputer: I would say >>= is idiomatic when a) it doesn't get too long, b) it couldn't be done with functors and applicatives
10:03:15 <srhb> If I end up with foo >>= \x -> case x of ... or something similar, I will convert to do notation.
10:03:39 <shlomocomputer> indeed.  I found that to be a clear call as well.
10:04:20 <shlomocomputer> I was reading about a feature request to be able to say "case of" and have that mean "\s -> case s of"
10:04:36 <srhb> shlomocomputer: There's lambda case.
10:04:49 <shlomocomputer> Is that in ghc?
10:04:56 <srhb> shlomocomputer: Yes.
10:05:07 <shlomocomputer> no kiddin'
10:05:10 <merijn> Only 7.8 and up, though afaik
10:05:15 <merijn> Or was it 7.6
10:05:28 <srhb> 7.6 I think
10:05:29 <geekosaur> 7.6 had lambdacase
10:05:39 <shlomocomputer> ...googling...
10:06:01 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#lambda-case
10:06:11 <srhb> shlomocomputer: Enable LambdaCase, then you can do foo >>= \case x -> ...; y -> ...
10:06:35 <geekosaur> more to the point, http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/syntax-extns.html#lambda-case
10:06:37 <NemesisD> i'm trying to force a possible exception out of some pure code while in an IO block, is the best practice to use something like try . evaluate (from Control.Exception.Base)
10:06:46 <josephle> that's some pretty sweet sugar!
10:06:57 <srhb> josephle: Yes, that and multi-way-if are quite nice
10:07:04 <NemesisD> i'm using the errors package but as far as i can tell it does not provide anything in the way of pure exceptions
10:07:17 <shlomocomputer> seems "if |" is prettier
10:07:21 <jfischoff> NemesisD: exceptions does
10:07:22 <geekosaur> what is a pure exception?
10:07:25 <shlomocomputer> but both are interesting, thanks
10:07:45 <jfischoff> NemesisD: https://hackage.haskell.org/package/exceptions
10:07:47 <geekosaur> that said, Monad's fail along with Either or Maybe ?
10:07:49 <NemesisD> geekosaur: exception thrown in pure code using "error" or the like
10:09:02 <shlomocomputer> gtg, but I was going to go on about do notation both: 1) looking like, and 2) compiling to mutable state
10:09:38 <merijn> NemesisD: "error" is not meant to be caught
10:09:40 <shlomocomputer> It's the number 2) that makes me a bit skeptical re: the whole "do notation is just sugar for the more idiomatic >>= \s ->" thing
10:09:49 <shlomocomputer> anyway, later :)
10:09:57 <NemesisD> merijn: basically i mean dumb stuff like divide by zero errors in code i don't control
10:10:05 <NemesisD> that i don't want to crash my software over
10:10:13 <geekosaur> but do does not provide mutable state. it makes it easier to fake it via "programmable semicolon".
10:10:18 <merijn> jfischoff: Also, exceptions' "pure" exceptions aren't actually safe, afaik
10:10:31 <geekosaur> other imperative-like things aren't from do, they're from the nature of IO
10:10:35 <geekosaur> they're not even from Monad
10:10:38 <jfischoff> merijn: in what sense?
10:10:40 <geekosaur> IO is just weird
10:10:55 <shlomocomputer> geekosaur:  I agree
10:11:02 <jfischoff> merijn: I’m only somewhat familiar with the package
10:11:42 <NemesisD> merijn: this is a failsafe i need to put in. and if i'm sure that whnf would encounter the error, if try . evaluate is a good idea
10:11:52 <merijn> jfischoff: https://github.com/ekmett/exceptions/issues/4
10:12:57 <merijn> NemesisD: division by 0 is probably catchable since division (for most Num instances) is strict, thus forcing the throw of an error
10:13:01 <jfischoff> merijn: that is difficult to get around. I agree with supki
10:13:28 <jfischoff> I think throw/error just should not be catchable, but throwM should be
10:13:33 <merijn> NemesisD: But in general catching lazy errors is not doable
10:13:46 <NemesisD> merijn: what's the point of evaluate then?
10:13:47 <merijn> jfischoff: Right, but that's exactly what NemesisD is trying to do :)
10:14:14 <jfischoff> oh
10:14:16 <merijn> NemesisD: evaluate only finds errors that trigger during WHNF evaluation
10:14:30 <merijn> NemesisD: That doesn't prevent any "errors" from being deeper inside the computation
10:14:45 <merijn> evaluate lets you catch "head []"
10:15:13 <NemesisD> christ what a nightmare
10:15:53 <merijn> NemesisD: You're better off changing the code to not need to catch "error"
10:16:04 <jfischoff> I think Haskell would be better and easier to reason about if error was abort and not catchable
10:16:24 <merijn> jfischoff: No, because then a single exception could take down a server
10:16:27 <NemesisD> maybe in the sense that it would motivate an angry mob when someone used error
10:16:36 <jfischoff> merijn: restart it
10:16:44 <merijn> jfischoff: The clear correct solution is to have a thread with proper handlers and let that die
10:16:49 <merijn> jfischoff: That's unacceptable
10:17:07 <merijn> jfischoff: "oh, let's just disconnect X thousand clients due to one exception"
10:17:23 <srhb> I suppose it's meant as a deterrent to ever using error.
10:17:50 <srhb> "If you do this, your code will forever be broken. Good luck."
10:18:02 <merijn> Pretty much
10:18:20 * hackagebot music-dynamics-literal 1.7.2 - Overloaded dynamics literals.  http://hackage.haskell.org/package/music-dynamics-literal-1.7.2 (HansHoglund)
10:18:22 * hackagebot music-pitch-literal 1.7.2 - Overloaded pitch literals.  http://hackage.haskell.org/package/music-pitch-literal-1.7.2 (HansHoglund)
10:18:24 <jfischoff> merijn: Kill the thread fine
10:18:24 * hackagebot abcnotation 1.7.2 - Haskell representation and parser for ABC notation.  http://hackage.haskell.org/package/abcnotation-1.7.2 (HansHoglund)
10:18:26 * hackagebot musicxml2 1.7.2 - A representation of the MusicXML format.  http://hackage.haskell.org/package/musicxml2-1.7.2 (HansHoglund)
10:18:27 <merijn> This is why you should always use throwIO/throwM, instead of throw
10:18:28 * hackagebot lilypond 1.7.2 - Bindings to Lilypond  http://hackage.haskell.org/package/lilypond-1.7.2 (HansHoglund)
10:18:33 <pharpend> Somebody's active
10:18:50 <merijn> jfischoff: That's exactly the current behaviour, though :)
10:18:58 <Kaidelong> I think throw is a little ugly because it's an escape from the type system
10:19:07 <jfischoff> merijn: except you can catch it
10:19:19 <Kaidelong> "I can't think of a good enough type for this function, or haskell can't express it, so I will make it partial"
10:19:37 <jfischoff> I think the mistake is conflating bottom and catchable exceptions
10:20:00 <Kaidelong> I think although it's bad for a language like haskell it's also neccessary
10:21:13 <Kaidelong> if you do run into a "catchable bottom" you do want to be able to handle it, report it, save persistant state, even if you may not be able to recover
10:21:37 <Kaidelong> it wouldn't really be acceptable to make it so that you can't catch exceptions from pure code
10:22:20 <jfischoff> we can’t catch loops though
10:22:32 <jfischoff> which we accept
10:22:51 <Kaidelong> if we could, do you not think people would want to?
10:23:06 <Kaidelong> the reason we don't catch loops is because it isn't really feasible or possible to do so in the general case
10:23:30 * hackagebot music-score 1.7.2 - Musical score and part representation.  http://hackage.haskell.org/package/music-score-1.7.2 (HansHoglund)
10:23:32 * hackagebot music-pitch 1.7.2 - Musical pitch representation.  http://hackage.haskell.org/package/music-pitch-1.7.2 (HansHoglund)
10:23:34 * hackagebot music-dynamics 1.7.2 - Abstract representation of musical dynamics.  http://hackage.haskell.org/package/music-dynamics-1.7.2 (HansHoglund)
10:23:36 * hackagebot music-articulation 1.7.2 - Abstract representation of musical articulation.  http://hackage.haskell.org/package/music-articulation-1.7.2 (HansHoglund)
10:23:37 <Kaidelong> but if GHC had features to detect some infinite loops then I'm sure people would use them
10:23:38 * hackagebot music-parts 1.7.2 - Musical instruments, parts and playing techniques.  http://hackage.haskell.org/package/music-parts-1.7.2 (HansHoglund)
10:24:23 <NemesisD> looks like all the pure results i'm working with have strict fields, so evaluating to whnf with evaluate shold be sufficient
10:27:15 <merijn> Kaidelong: GHC does catch some infinite loops :)
10:27:38 <merijn> Kaidelong: You've never run into the <<<loop>>> error?
10:28:06 <bennofs> > let x = x in x
10:28:10 <lambdabot>  mueval-core: Time limit exceeded
10:28:54 <geekosaur> many of the older <<loop>> occurrences no longer happen because of code entering the same thunk in multiple threads
10:29:14 <bennofs> hmm, seems it doesn't work in interpreted mode
10:30:00 <crobbins> is there a more general way to approach a function :: e -> Maybe (Maybe a) -> Either e (Maybe a) ?  Here's an example implementation:
10:30:00 <crobbins> f e mx = case mx of Just Nothing -> Left e; _ -> Right $ join mx
10:30:23 <merijn> crobbins: maybe?
10:30:25 <merijn> :t maybe
10:30:26 <lambdabot> b -> (a -> b) -> Maybe a -> b
10:30:51 <merijn> :t \x -> maybe (Left x) Right
10:30:52 <lambdabot> a -> Maybe b -> Either a b
10:31:00 <crobbins> merijn: i tried that, but couldn't get it worked out quite right.  the condition needs to be Left only when the pattern is Just Nothing
10:31:10 <merijn> oh
10:31:11 <merijn> hmmm
10:31:28 <crobbins> that's why using join seemed to work nicely
10:31:33 <ReinH> :t fmap maybe
10:31:34 <lambdabot> Functor f => f a -> f ((a1 -> a) -> Maybe a1 -> a)
10:31:36 <merijn> tbh, that type doesn't make a lot of sense to me?
10:31:59 <merijn> What's the point of peeling off only one Maybe?
10:32:48 * hackagebot music-sibelius 1.7.2 - Interaction with Sibelius.  http://hackage.haskell.org/package/music-sibelius-1.7.2 (HansHoglund)
10:32:48 * hackagebot music-suite 1.7.2 - A set of libraries for composition, analysis and manipulation of music.  http://hackage.haskell.org/package/music-suite-1.7.2 (HansHoglund)
10:32:54 <crobbins> merijn: consider when you maybe something like `Maybe Thing`, and Thing is defined as `Thing { getId :: Maybe Int }`
10:32:58 <ReinH> crobbins: That function doesn't seem to generalize in any obvious way.
10:33:23 <ReinH> What sort of generality are you looking for?
10:33:35 <crobbins> i was thinking something around the Maybe or Either monad
10:33:46 <crobbins> or Error monad
10:33:51 <ReinH> That specifically deals with Just Nothings?
10:34:00 <ReinH> Unlikely.
10:34:09 <crobbins> or maybe there was a pattern that was more general i just wasn't seeing
10:34:09 <vanila>     No instance for (Enum (t0, t1)) arising from a use of `it'
10:34:11 <vanila> Why isnt'there any instant
10:34:13 <vanila> instance?
10:34:18 <ReinH> What are you doing with these values?
10:35:05 <crobbins> ReinH: i need to extract the getId from the Maybe Thing.  it is ok if Maybe Thing is Nothing but it is not ok if the getId is Nothing
10:35:24 <crobbins> my function works, i have just wondered if there was a more general way to approach it than what i did
10:35:50 <crobbins> again, my implementation is: f e mx = case mx of Just Nothing -> Left e; _ -> Right $ join mx
10:35:59 <crobbins> it just seems too specialized, but maybe that's ok in this case
10:36:17 <ReinH> You're doing a pretty specialized thing
10:36:35 <bitemyapp> ajcoppa: indeed.
10:37:30 <crobbins> thanks ReinH, for some reason i felt like i was missing some obvious pattern
10:38:57 <ReinH> Consider also that Maybe (Maybe a) is isomorphic to data Response a = NotFound | SomeOtherError | Response a (up to bottoms). Maybe you want to use a data type that gives you a bit more information than Maybe (Maybe a)
10:40:48 <crobbins> ReinH: possibly, to be more specific I'm dealing with converting Persistent types to and from pure types so that we get foreign key objects as a part of the data structure
10:41:57 <crobbins> so i have something like: PureObject { pureObjectEntityKey :: Maybe (ObjectId), pureObjectName :: Text }
10:42:16 <crobbins> which is analogous to: Object { objectName :: Text }
10:42:38 <crobbins> when used in the context of a database entity, it is: Entity ObjectId Object
10:43:51 <jfischoff> crobbins: I used something more like Ref a = Ref Int a
10:44:06 <jfischoff> type PureObject = Ref Object
10:45:18 <crobbins> jfischoff: but i'd like to be able to have pure types that don't depend on an entity already existing, so we need Maybe ObjectId
10:45:40 <crobbins> plus, ObjectId is it's own type, even though it's basically an Int
10:45:56 <jfischoff> sure
10:46:41 <bitemyapp> crobbins: that changed in Persistent 2 did it not?
10:46:51 <jfischoff> oh wait
10:46:53 <bitemyapp> ObjectId can be other kinds of primary keys now, so I was told.
10:47:00 <jfischoff> this is for Persistent
10:47:10 <bitemyapp> jfischoff: what did you think it was for?
10:47:13 <jfischoff> I thought you were just giving some background
10:47:27 <jfischoff> I didn’t scroll up so my bad
10:50:08 <joeyh> trying to figure out the cabal os() value for the hurd. I was once told it was os(gnu), but it seems hackage didn't like that.
10:51:24 <crobbins> oh that's a good point bitemyapp.  either way i'm just using the ObjectId anyway so it should be fine
10:51:39 <crobbins> i wonder, though, if there is a better way to deal with foreign key objects
10:57:14 <jonkri> I think I'm doing something dumb with acid-state, but does anyone know why I get the error "user error (Pattern match failure in do expression at src/Data/Acid/Remote.hs:507:20-30)" when I try to perform execute an Update remote on a remote server? Queries seem to work fine.
11:01:29 <crobbins> why does ghc report "Top-level binding with no type signature" warnings with forall in the type?  Seems usually that should be omitted entirely, especially when you aren't use RankNTypes or something similar
11:05:03 <monochrom> that's strange. last time I did that, it's a parser error because of the "." in "forall s . "
11:07:45 * hackagebot shell-conduit 4.0 - Write shell scripts with Conduit  http://hackage.haskell.org/package/shell-conduit-4.0 (ChrisDone)
11:14:31 <crobbins> monochrom: yeah, ghc always does that.  if you use a tool to auto-insert the type signature then you have to manually delete the forall part.  annoying
11:15:01 <merijn> crobbins: There's an extension that lets you keep the forall
11:15:22 <merijn> -XExplicitForall although that's not a great solution
11:15:29 <crobbins> merijn: yeah, RankNTypes works, but i shouldn't have to add that.  there's no reason for ghc to output forall in those cases
11:16:09 <crobbins> merijn: for example: xs :: forall t. [t]
11:16:25 <crobbins> that's if i define an empty list
11:16:46 <crobbins> obviously, no good use case for that, but it exemplifies the point
11:17:24 <crobbins> or rather, something like: innerRequired'' e mx = case mx of Just Nothing -> Left e; _ -> Right $ join mx
11:17:27 <crobbins> gives me: Top-level binding with no type signature: innerRequired'' :: forall a a1. a -> Maybe (Maybe a1) -> Either a (Maybe a1)
11:17:41 <crobbins> yet again, no reason for the forall
11:19:12 <crobbins> looks like i'm not the only one complaining: http://sourceforge.net/p/eclipsefp/backlog/134/
11:20:31 <glguy> Don't worry, there's never a shortage of people complaining
11:20:47 <jfischoff> heh
11:35:01 <xeno> so, is there any fun haskell cloud service, heroku style?
11:35:26 <burp> I think you can deploy general binaries on heroku, so haskell works
11:35:39 <beckyconning> https://devcenter.heroku.com/articles/third-party-buildpacks
11:36:11 <beckyconning> btw what is <- when people show it out of a do block? do they mean put this in a do block? whats up with that?
11:36:15 <BeardedCoder> xeno: Scotty wiki has some info around this. http://adit.io/posts/2013-04-15-making-a-website-with-haskell.html
11:37:34 <geekosaur> in what context? sometimes it's implying a do block, sometimes it's a list comprehension, also there are pattern guards
11:37:48 * hackagebot shell-conduit 4.1 - Write shell scripts with Conduit  http://hackage.haskell.org/package/shell-conduit-4.1 (ChrisDone)
11:40:03 <xenomachina> What is the easiest way to get a working ghc 7.8.x + cabal installed on Ubuntu? I was using "haskell-platform", but the Ubuntu package seems to be pretty old (7.6.3).
11:40:22 <beckyconning> geekosaur: are those the only three options?
11:40:47 <geekosaur> just the ones that came to mind immediately
11:41:09 <geekosaur> there may be others, but likely to beobscure. and I think in 99% of cases an unattributed <- is assuming a do block
11:41:22 <beckyconning> geekosaur: context is this http://www.reddit.com/r/haskell/comments/2hnarl/snake_in_haskell_170_lines_my_first_haskell_app/ckv74z9
11:41:29 <beckyconning> geekosaur: yeah i think thats whats happening here : )
11:41:43 <geekosaur> since list comprehensions and view patterns both tend to require surrounding syntax that makes them obvious
11:41:47 <beckyconning> geekosaur: although i'm not sure i can get what this person is proposing working
11:42:23 <geekosaur> the `currentKey <- do`? yes, that's assuming an outer do block
11:44:00 <beckyconning> thanks : )
11:48:17 <Cale> beckyconning: In the reddit thread there, you should be careful about the precedence of (>>)/(>>=) and ($)
11:49:08 <Cale> beckyconning: ($) has lower precedence, so all the stuff after "forever $"  is part of the second argument to that ($)
11:49:12 <beckyconning> Cale: *nods* i thought that $ seems to go further right than it would have done in the do block
11:49:57 <beckyconning> although i haven't worked out how to make his thing work yet lol
11:57:49 * hackagebot uuid-le 0.2014.1 - Universally Unique Identifiers with little-endian-ish encoding tools  http://hackage.haskell.org/package/uuid-le-0.2014.1 (StijnVanDrongelen)
12:05:09 <ReinH> beckyconning: One thing that might help understanding how ($) affects an expression is to remove it and mentally wrap everything on either side with parens: so foo bar $ bizz quux would become (foo bar) (bizz quux)
12:05:26 <ReinH> This becomes a bit more complicated when you have multiple ($) but it's a decent rule of thumb
12:05:43 <lf94> well if you read it from right to left it isn't that difficult
12:05:50 <ReinH> true
12:05:58 <lf94> that was my problem ;)
12:06:00 <ReinH> :)
12:06:24 <system-lord> I have no problem with $ but so far I have no idea what . is for
12:07:06 <johnw> system-lord: . composes two functions
12:07:16 <johnw> (f . g) x = f (g x)
12:07:51 <japesinator> system-lord: look at the types
12:07:56 <system-lord> right, it's just that so far I haven't been able to use it
12:08:01 <monochrom> . is higher order. if you see "(f . g) x", then it's immediately f (g x). but if you see "f . g" alone, then you have to provide the missing parameter in order to explain in elementary terms, \x -> f (g x).
12:08:25 <lf94> johnw: I think he means why not use: f $ g x
12:08:38 <system-lord> yeah, I mean, I get what it is supposted to do but I still haven't got it in practice
12:08:41 <johnw> because sometimes you don't have 'x'
12:08:51 <lf94> Ohhhh, I see
12:09:03 <lf94> So to create partial functions or whatever
12:09:07 <system-lord> yep
12:09:12 <monochrom> http://www.vex.net/~trebla/weblog/pointfree.html
12:09:33 <monochrom> if you have written shell pipelines, you have used .
12:09:51 <jfischoff> system-lord: a common use of ‘.’ is with map, map (show . negate) [1,2,3]
12:10:00 <lf94> nice!
12:10:10 <lf94> that's a really nice example
12:10:24 <system-lord> actually, I did manage to use it recently
12:10:26 <system-lord> https://github.com/yaccz/base-stats/blob/master/src/BaseStats.hs#L32
12:10:40 <jfischoff> yeah
12:10:56 <jfischoff> it’s not used as often as $
12:19:41 <dmj`> if I blow away my package.conf.d folder is that cool?
12:20:10 <lf94> package.conf.d might like it.
12:22:09 <lf94> Guys why would getChar just hang
12:22:16 <lf94> Even if I'm mashing buttons
12:22:25 <sinelaw> wrong keyboard?
12:22:55 <bennofs> lf94: maybe you need a newline?
12:22:57 <lf94> Apparently my guess was correct- you need to press Enter for getChar to get a character
12:23:10 <lf94> Ain't that silly?
12:23:14 <sinelaw> lf94, sometimes the stdin is bufferred by newlines
12:23:17 <hpc> welcome to the wonderful world of buffering
12:23:19 <sinelaw> there's a way to unbufer it
12:23:27 <lf94> I figured that
12:23:34 <hpc> stdin is newline buffered by default and files are block buffered by default (linux)
12:23:35 <lf94> But come on, getChar
12:23:40 <hpc> block size 4096-ish
12:23:47 <lf94> Even a newline should be considered a character
12:24:01 <hpc> it is
12:24:11 <lf94> How do I get it? Enter enter?
12:24:22 <beckyconning> try hSetBuffering stdinNoBuffering >> getChar
12:24:36 <beckyconning> hSetBuffering stdin NoBuffering >> getChar
12:25:01 <monochrom> the 2nd getChar will see the newline
12:25:31 <monochrom> main = do { c <- getChar; d <- getChar; print (fromEnum c, fromEnum d) }
12:25:33 <ReinH> monochrom: irt pointfree, that's a nice analogy. Richard Bird said that pointfree is for reasoning about function composition and pointful is for reasoning about function application. I like that too.
12:25:54 <monochrom> enter x, then press return.
12:26:41 <ReinH> Since we tend to do a lot of reasoning about function composition (this is, essentially, what writing a functional program *is*), pointfree style tends to be useful in program construction. ;)
12:27:51 <ReinH> system-lord: http://www.cs.tufts.edu/~nr/cs257/archive/richard-bird/sudoku.pdf is one of my favorite examples of using function composition to construct a program
12:34:27 <Yxven> I appreciate the help with the buffering beckyconning
12:34:38 <beckyconning> Yxven: did it work? : )
12:35:10 <Yxven> no =/ it seems to be a long-standing bug in Windows https://ghc.haskell.org/trac/ghc/ticket/2189
12:36:00 <beckyconning> oh, what a shame. maybe try using vty's input stuff instead? http://hackage.haskell.org/package/vty-5.1.0/docs/Graphics-Vty-Input.html
12:36:17 <sinelaw> or curses wrappers
12:36:43 <geekosaur> curses is kinda asking for pain
12:37:05 <beckyconning> i know vty is tested on windows and is a bit simpler so it might be a better option
12:37:21 <MagneticDuck> what's the preferred way to delay a single-threaded program by x milliseconds?
12:37:33 <MagneticDuck> System.Posix.Unistd.sleep?
12:37:40 <MagneticDuck> Control.Concurrent.threadDelay?
12:37:44 <hpc> that
12:37:50 <MagneticDuck> the second one?
12:37:52 <beckyconning> oh no wait i'm wrong
12:38:45 <hpc> to some extent, importing a posix module is giving up ;)
12:39:17 <benmachine> threadDelay is okay to use on your only thread
12:41:10 <merijn> hpc: Define giving up
12:41:35 <merijn> For sleep, probably, for a lot of other things? Not really
12:41:51 <hpc> yeah
12:42:00 <hpc> i mean, if you're dealing with FDs there is no other way
12:42:11 <hpc> but posix is pretty big and a lot of it is covered by standard libraries
12:42:19 <monochrom> Control.Concurrent.threadDelay (x * 1000) delays x milliseconds. this is good for single-threaded programs too.
12:42:47 <monochrom> a square is still a quadrilateral. a single-threaded program is still a concurrent program.
12:43:08 <monochrom> and 1 is still a number
12:43:21 <hpc> pi is exactly 3!
12:43:25 <beckyconning> this is a big ask but could someone please make a quick example that takes input and gives visual output based on this example here? http://www.reddit.com/r/haskell/comments/2hnarl/snake_in_haskell_170_lines_my_first_haskell_app/ckvj1e0 i've been working on it for 4 hours and i still haven't managed to make it do anything other than hang
12:44:02 <monochrom> did you know: ancient Greeks did not consider 1 to be a number. Euclid's proof had to do a case-analysis on n=1 and n=number.
12:44:04 <beckyconning> could be as simple as giving an output character every second or anything really
12:44:34 <hpc> monochrom: that's ridiculous, everyone knows the only non-number is zero
12:51:21 <Cale> beckyconning: http://lpaste.net/111826
12:52:54 * hackagebot haskellscrabble 0.1.0.0 - A scrabble library capturing the core game logic of scrabble.  http://hackage.haskell.org/package/haskellscrabble-0.1.0.0 (happy0)
12:52:58 <beckyconning> Cale:thank you so much! : D
12:53:03 <Vlyn> Hey there! I just started learning Haskell but ran into a problem: If I want to write an infix function like 4 'elem' [1,2,3,4] he doesn't like my quotation marks (syntax error). I'm German, so maybe the ones I usually use (in programming too) could be the problem in Haskell? When I copied the ' symbol out of my tutorial it worked.
12:53:19 <monochrom> use ` not '
12:53:20 <Cale> Vlyn: You need to use backticks like `
12:53:39 <Vlyn> Cale: Now I just have to figure out how to create them xD
12:54:22 <Cale> At least on my keyboard, it's the topmost leftmost key in the main part of the keyboard (just below escape)
12:54:48 <koala_man> Vlyn: are you able to type "è"?
12:55:14 <koala_man> on a layout with dead keys, it's the same thing but with space instead of "e"
12:56:08 <Vlyn> koala_man: I know what you mean, but I use a different keyboard layout (NEO2) which doesn't provide this quotation mark easily it seems. Why doesn't Haskell use the standard ' ?
12:56:39 <monochrom> wait until you need 'c' :: Char
12:57:16 <koala_man> like monochrom says, it uses both
12:57:17 <monochrom> > 'c' `elem` ['a', 'b', 'x']
12:57:19 <lambdabot>  False
12:57:44 <Vlyn> Great, my layout can do this: g̀̀̀
12:57:55 <Vlyn> Stack the symbol, now I only need to know how to make a simple one xD
12:58:20 <Vlyn> got it, thanks!
12:59:31 <Redz> hello
12:59:45 <Redz> i could need some help making a decision. http://stackoverflow.com/questions/26085936/express-extensibility-with-stacking-higher-order-functions-or-rws-monad-transfor
13:02:38 <mattbrandt> anyone built an arm-linux-eabi cross compiler on OS X?
13:04:02 <dfeuer> ping erikd
13:14:11 <Redz> blub
13:29:28 <erikd> dfeuer: hey!
13:30:35 <dfeuer> erikd, did you see the comments on your bug report?
13:32:43 <erikd> yes, responding now
13:38:50 <Haskellfant> what's the best way to get a -> (a,a) so just copying a value and creating a tuple from it?
13:39:18 <simpson> \x -> (x, x)
13:39:43 <Haskellfant> simpson: hm k, thought I might be able to use return 1 or something like this but (,) is not a monad
13:40:40 <simpson> Haskellfant: Well, it's related to the Writer monad, sure, but there's not much point to golfing this.
13:40:54 <Haskellfant> simpson: you're right :)
13:41:07 <simpson> > (length "\x->(x,x)", length "return")
13:41:09 <lambdabot>  <hint>:1:12:
13:41:09 <lambdabot>      lexical error in string/character literal at character '-'
13:41:52 <sinelaw> @pl \x -> (x,x)
13:41:52 <lambdabot> join (,)
13:42:23 <geekosaur> I was thinking join, yeh, but I like to understand my code a month after writing it :p
13:42:53 <Haskellfant> geekosaur: well I wasn't going to use it, I just wanted to know if it's possible
13:43:27 <Haskellfant> that's the (->) r monad right?
13:43:37 <josephle> took me a while to figure out the monad for that join
13:44:18 <Vlyn> Whoa.. Haskell is really powerful. Lots of math but impressive (Based on the tutorial I just calculated all right triangles with side lengths <= 10 and a circumference of 24, all in one line of code!)
13:47:59 <geekosaur> "@pl" loves the ((->) r) monad
13:48:35 <Haskellfant> I nearly never use it in my own code
13:48:49 <Kaidelong> I use ReaderT all the time
13:49:18 <Kaidelong> runReaderT just eliminates so much noise from code when dealing with library functions that all take similar parameters
13:50:48 <Haskellfant> well yeah I use ReaderT
13:53:00 <sinelaw> does it make sense to call a function that adds a non-polymorphic variable to the environment (of some ADT) by the name "introduceMonomorph"?
13:53:32 <sinelaw> or does 'monomorph' usually mean something else
13:53:39 <zmbmartin> Anyone give a quick pointer on this. All I am trying to to is pass in a user set the _id to a uuid I generate and insert into mongodb. -> https://gist.github.com/codedmart/fc1d71da45154671313a
13:54:15 <glguy> zmbmartin:     id <- M.insert "users" $ toDoc user      should probably be:    let id = M.insert "users" (toDoc user)
13:54:41 <glguy> _ <- _  is part of do-notation and expands to using the >>= operator
13:54:50 <glguy> let _ = _   is how you name a value
13:55:57 <geekosaur> (also I'd want a different name than id...)
13:56:24 <zmbmartin> glguy: That doesn't solve it. So can I not have two <- in one function? Is that bad?
13:56:39 <glguy> zmbmartin: No, they just mean different things
13:56:39 <zmbmartin> geekosaur: Yes I should rename things.
13:57:03 <zmbmartin> M.insert is an IO operation.
13:57:57 <geekosaur> heh, I bet glguy assumed that was Data.Map. "users" kinda not a valid Map though... :p
13:58:18 <glguy> zmbmartin: Ah, I'm just used to M being Data.Map everywhere.
13:58:29 <glguy> It looks like the actual issue is that you need to liftIO some IO operation
13:58:42 <glguy> to run in M.Action
13:59:43 <zmbmartin> glguy: ok let me try that.
14:00:06 <glguy> but all your imports are hidden away so there's no easy way to guess what the types of the things you're using are
14:00:07 <NemesisD> is it possible in GHCI to see the version of a package in use?
14:00:48 <NemesisD> looks like :show packages does it actually
14:04:34 <zmbmartin> glguy: Yeah that solves that problem. Thanks!
14:04:50 <zmbmartin> glguy: How do you know when to use liftIO?
14:05:14 <glguy> When you have something:   IO a    and you need something     Something a, and that Something is a MonadIO instance
14:05:41 <zmbmartin> glguy: Thanks again!
14:09:51 <jacereda> hi... I'm trying to make a Haste wrapper for a JS library and I'm constantly repeating things like this for each object: instance Pack Renderer  instance Unpack Renderer  instance JSTrace Renderer... what should I do to avoid replicating that?
14:16:43 <jacereda> looks like I can turn that into 'deriving (Pack, Unpack, JSTrace)' if I use -XTypeSynonymInstances -XFlexibleInstances -XGeneralizedNewtypeDeriving, but I'm not sure that's The Right Thing...
14:17:38 <jfischoff> XTypeSynonymInstances -XFlexibleInstances -XGeneralizedNewtypeDeriving are prefectly reasonable extensions, not sure why you are worried though
14:20:06 <joelteon> GeneralizedNewtypeDeriving is no longer unsafe
14:20:28 <joelteon> FlexibleInstances and TypeSynonymInstances are used in just about every non-trivial library
14:21:28 <jacereda> well, it's just that I want to figure out what the 'right' solution is... maybe there should be a typeclass, say MyLibHandle, that groups all of those (Pack, Unpack, JSTrace), since all of the JS handles will look the same. Is it possible to write a typeclass that 'derives' from those three so I don't need to list all of them for all the handle objects?
14:25:34 <NemesisD> is there any possible way i could get more information of the source of an exception without trashing my sandbox and reinstalling all dependencies with profiling?
14:26:12 <NemesisD> i can even get the exception to come up in ghci but -fbreak-on-exception gets stuck in the weeds on exceptions in other threads or something
14:26:36 <hpc> what's the exception?
14:26:44 <NemesisD> a divide by zero
14:28:11 <kess> hey
14:28:20 <hpc> hmm
14:29:45 <kess> what's the best way to put a typeclass restriction on a functor?
14:30:52 <cjenkin1> kess: (Functor f, MyTypeClass f) ?
14:31:38 <kess> no I mean in creating a functor, how can you make sure the type 'wrapped' by the functor is of a particular class
14:32:17 <kess> wait I'm doing this all wrong I think
14:33:01 * hackagebot Nomyx-Language 0.7.1 - Language to express rules for Nomic  http://hackage.haskell.org/package/Nomyx-Language-0.7.1 (CorentinDupont)
14:38:02 * hackagebot Nomyx-Core 0.7.1 - A Nomic game in haskell  http://hackage.haskell.org/package/Nomyx-Core-0.7.1 (CorentinDupont)
14:38:04 * hackagebot Nomyx 0.7.1 - A Nomic game in haskell  http://hackage.haskell.org/package/Nomyx-0.7.1 (CorentinDupont)
14:48:07 <NemesisD> is it possible to set the +RTS -xc flags within ghci/cabal repl?
14:49:06 <hexagoxel> kess: (Functor f, MyTypeClass a) => f a
14:50:55 <mattbrandt> anyone have experience building ghc OS X -> arm-linux?
14:57:20 <MrWoohoo> Curious if anyone familiar with the nomyx package is lurking about. (It's a haskell implementation of Nomic)
14:57:32 <MrWoohoo> er, The GAME of Nomic
14:58:26 <MrWoohoo> Just been thinking it would be a fun project to work on but looking at the web site it seems pretty inactive
15:00:28 <sinelaw> MrWoohoo, are you the one who just deployed a new version of Nomyx?
15:00:39 <sinelaw> http://hackage.haskell.org/package/Nomyx
15:00:43 <sinelaw> published a few minutes ago
15:00:52 <MrWoohoo> No. sorry
15:00:58 <MrWoohoo> hadn't heard about it
15:01:14 <MrWoohoo> saw the project a few months ago but I have been lollygagging
15:01:26 <sinelaw> in that case, there's an answer. I have no idea what nomic/nomyx is
15:01:33 <sinelaw> but a new version was just published.
15:01:37 <MrWoohoo> serendipity :)
15:01:55 <Hijiri> I played blognomic once
15:02:14 <MrWoohoo> how did the game go? was it interesting? Fun?
15:02:46 <Hijiri> It was fun, it's a persistent nomic game you play with other players on a blog
15:03:13 <MrWoohoo> What sort of resources did you deal with/make laws ago?
15:03:17 <MrWoohoo> about
15:03:28 <Hijiri> I don't really remember
15:03:37 <MrWoohoo> how long ago was this?
15:03:42 <Hijiri> a few years
15:03:45 <Hijiri> they're still up though
15:04:03 <Hijiri> blognomic.com
15:04:34 <MrWoohoo> Just curious, how would you sum up your experience with the game today?
15:06:00 <Hijiri> Things stayed fresh since new rules would be proposed often
15:06:24 <Hijiri> if the game was active, anyway
15:07:16 <MrWoohoo> Seems like the existing ruleset would swamp any players who wanted to join mid-game
15:07:41 <Hijiri> yeah, that was how I felt
15:08:02 <MrWoohoo> is that your blog you posted the link to?
15:08:08 <Hijiri> no
15:08:12 <Hijiri> I didn't make blognomic
15:08:14 <Hijiri> I just played it
15:08:40 <Hijiri> Dynasties sort of limit the growth of the ruleset, since all of the dynasty-specific rules get wiped when someone wins
15:09:07 <MrWoohoo> Ah, you play on the site... I thought maybe it was distributed across blogs somehow
15:09:25 <Hijiri> nope, everyone just posts on the same blog
15:10:30 <MrWoohoo> With the whole arab spring thing you'd think there'd be stronger interest in democracy software..
15:11:01 <MrWoohoo> Imagine a revolution where suddenly your cel phone becomes a secure voting booth
15:12:21 <NemesisD> does anyone know how to set RTS flags for cabal repl
15:12:23 <Hijiri> that would be tough
15:12:38 <Hijiri> you would need the entire phone's software stack to not be proprietary
15:12:49 <Hijiri> and have openly-documented hardware
15:13:14 <MrWoohoo> There's a fair number of disenfranchised and unemployed programmers around... maybe they've finally hit critical mass
15:14:46 <MrWoohoo> True enough... even if the phone wasn't subverted you'd want some sort of back-up methods to constantly check for it... odd vote distributions, etc
15:23:54 <MrWoohoo> sinelaw: thank you again for pointing out the update
15:24:35 <sinelaw> MrWoohoo, sure, matter of luck. I just happened to notice this in the chat room:
15:24:36 <sinelaw> * hackagebot Nomyx-Language 0.7.1 - Language to express rules for Nomic  http://hackage.haskell.org/package/Nomyx-Language-0.7.1 (CorentinDupont)
15:26:04 <apo_> O_o
15:26:33 <kau> sinelaw, MrWoohoo, Hijiri: actually I'm the authors of Nomyx :)
15:26:46 <sinelaw> ;)
15:27:05 <kau> I plan to start and advertise a new game tomorrow
15:27:07 <apo_> kau: Nerd!
15:27:17 <kau> :)
15:27:38 <usr> kau wat game?
15:27:42 <kau> there is a website: www.nomyx.net
15:28:09 <usr> What's in the tar
15:28:12 <kau> I also just made a tutorial: http://www.corentindupont.info/blog/posts/2014-09-23-first-Nomyx-tutorial.html
15:28:14 <usr> The game?
15:28:46 <usr> Does the game teach people haskell kau?
15:29:27 <usr> well Nomyx
15:29:29 <kau> usr: it can :)
15:30:19 <kau> it's not specifically designed for that, but since it's a game... it's more fun to learn haskell
15:31:30 <sinelaw> @pl (\p x xs -> if p then x:xs else xs)
15:31:30 <lambdabot> flip flip id . (ap .) . (. (:)) . (.) . if'
15:31:38 <sinelaw> b e a u t i f u ll
15:32:26 <sclv> luite: the following, while ugly, should recover the for behaviour you want without changing the ast http://lpaste.net/6207089081231343616
15:32:53 <sinelaw> @pl (\p -> if p then (:) else id)
15:32:54 <lambdabot> flip (flip if' (:)) id
15:33:26 <dfeuer> @pl (\p -> foldr (\x r -> if null r && p x then [] else x:r) [])
15:33:27 <lambdabot> flip foldr [] . (`ap` (:)) . (ap .) . flip flip [] . ((flip . (if' .) . flip ((&&) . null)) .)
15:33:32 <dfeuer> Oh my.
15:33:43 * dfeuer barfs a little.
15:34:02 <dfeuer> What is if', by the way?
15:34:07 <dfeuer> @src if'
15:34:07 <lambdabot> Source not found.
15:34:15 <sinelaw> dfeuer, if' is the function for if
15:34:19 <sinelaw> @type if'
15:34:20 <lambdabot>     Not in scope: ‘if'’
15:34:20 <lambdabot>     Perhaps you meant ‘f'’ (imported from Debug.SimpleReflect)
15:34:22 <geekosaur> it doesn't actually exist.
15:34:23 <zipper> heh, thanks to CS194 lectures I feel like I've learnt more haskell in one evening than in the last two weeks.
15:34:32 <sinelaw> bah
15:34:39 <dfeuer> And why are bool's arguments in such an odd order?
15:34:54 <merijn> dfeuer: Partial application
15:35:08 <merijn> :t bool
15:35:09 <lambdabot> a -> a -> Bool -> a
15:35:14 <dfeuer> bool else_branch then_branch condition
15:35:23 <merijn> dfeuer: bool is not if/then/else
15:35:29 <merijn> It's Bool elimination
15:35:46 <geekosaur> postscript, anyone? (although it sounds like it mirrors either/maybe)
15:35:49 <dfeuer> merijn, explain that? Isn't it kind of like if-then-else with a different type?
15:35:52 <merijn> False comes before True, so that's what comes first
15:36:05 <joelteon> it's either for Bool
15:36:06 <merijn> dfeuer: i.e. same reason why the arguments of either have the order
15:36:08 <merijn> :t either
15:36:09 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
15:36:17 <dfeuer> What is that reason?
15:36:23 <merijn> dfeuer: Left before Right, therefor a elimination before b elimination
15:36:32 <dibblego> bool False True = id
15:36:33 <merijn> dfeuer: False elimination comes before True elimination
15:36:34 <dfeuer> What makes that better?
15:36:41 <dibblego> either Left Right = id
15:36:44 <dibblego> foldr (:) [] = id
15:36:45 <merijn> dfeuer: Consistency, tradition
15:36:59 <dfeuer> merijn, I'm not saying it's wrong, I just don't understand.
15:37:04 <merijn> dfeuer: It's how elimination rules are defined
15:37:25 <dfeuer> When I think of "elimination rule" I think of a logic thingum.
15:37:36 <dfeuer> Eliminating a logical connective or whatever.
15:37:45 <dibblego> bool is the function that, given the constructors for Bool, produces id
15:37:52 <dibblego> foldr is the function that, given the constructors for [], produces id
15:37:57 <merijn> dfeuer: inductive data types can be seen as having introduction rules (constructors) and elimination rules
15:37:59 <dibblego> either is the function that, given the constructors for Either, produces id
15:38:07 <merijn> elimination being pattern matching
15:38:08 <dfeuer> o.O
15:38:12 <dibblego> maybe is the function that, given the constructors for Maybe, produces id
15:38:19 <dfeuer> Whoa.
15:38:23 <merijn> Traditionally, elimination rules happen in the same order as introduction rules
15:38:24 <dfeuer> That's crazy stuff.
15:38:44 <merijn> And since False comes before True, False-elim comes before True-elim
15:39:08 <dfeuer> Thanks!
15:39:37 <dfeuer> I still think fromMaybe is a lot easier to understand than maybe, but that gives me *some* appreciation for it.
15:40:19 <dibblego> maybe is fromMaybe and fmap
15:40:27 <c_wraith> dfeuer: another way of looking at it is that maybe is foldr
15:40:52 <c_wraith> dfeuer: because foldr is the eliminator for lists.  If you reverse its arguments for some reason.
15:40:56 <dibblego> @type (`maybe` id)
15:40:56 <lambdabot> b -> Maybe b -> b
15:42:26 <dfeuer> c_wraith, if you reverse the arguments of what?
15:43:43 <dibblego> @type \n j -> fromMaybe n . fmap j
15:43:43 <lambdabot> c -> (a -> c) -> Maybe a -> c
15:44:08 <c_wraith> dfeuer: foldr's arguments are backwards - recursive case -> base case
15:44:22 <dfeuer> :t maybe
15:44:23 <lambdabot> b -> (a -> b) -> Maybe a -> b
15:44:27 <dfeuer> Oh.
15:44:52 <dfeuer> c_wraith, or maybe maybe's arguments are backwards? How can you tell?
15:45:17 <c_wraith> dfeuer: it should go in the constructor order. :)
15:45:30 <dfeuer> c_wraith, and what determines that?
15:45:40 <dfeuer> Aside from what someone happened to write, that is?
15:46:12 <c_wraith> Nothing more than the order they decided on. But it's usually also reflected in the type's Ord instance
15:46:25 <c_wraith> > Nothing < Just 10
15:46:27 <lambdabot>  True
15:46:37 <c_wraith> > [] < [10]
15:46:39 <lambdabot>  True
15:47:11 <joelteon> > Left () < Right ()
15:47:12 <lambdabot>  True
15:48:21 <c_wraith> dfeuer: it's only "backwards" by convention, and that's because it's the conventional order for foldr.  When you have opposing conventions, someone's unhappy. :)
15:48:48 <dfeuer> Huh.
15:48:53 <dfeuer> All right.
15:49:54 <dfeuer> erikd, you have a very strange bug there. Did you try using diff? If you -ddump-simpl -dsuppress-uniques you have a pretty good chance of getting something meaningful. You might need to suppress some more things.
15:53:13 <erikd> dfeuer: over there ----> in #ghc
15:53:29 <Redz> @hoogle Double -> Float
15:53:30 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
15:53:30 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
15:53:30 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
15:56:21 <Redz> (GHC.Float.float2Double)
15:58:18 <usr> w/in 22
16:09:24 <dnkndnts> is there a concise way to express a recursive function call? oftentimes i give my function a descriptive name, which is great for the public interface, but incredibly verbose/inconvenient within the function itself, especially with multiple recursion points.
16:09:35 <Fuuzetsu> yes, fix
16:10:49 <c_wraith> Or just a recursive helper name with a silly function like "go" defined in a where clause
16:13:18 <dnkndnts> hmm, checking out fix now
16:13:33 <dnkndnts> it's definitely interesting; i'm trying to figure out if it's what i want/how to use it
16:13:43 <Fuuzetsu> a helper is almost always better
16:14:56 <Fuuzetsu> > fix (\f x -> if x <= 1 then 1 else x * f (x - 1)) $ 10
16:14:57 <c_wraith> I prefer fix to helpers when there are a bunch of local bindings inside a do block that I want in scope.
16:14:58 <lambdabot>  3628800
16:15:07 <c_wraith> but that's about it.
16:15:46 <c_wraith> fix $ \loop -> do ...
16:16:20 <dnkndnts> hmm, ok so it basically moves the recursion to the first argument as a lambda?
16:16:56 <c_wraith> It lets you turn a non-recursive function of a certain form into a recursive function.  Much like you describe, yes
16:17:57 <dnkndnts> ya, it's almost what i want -- but in the specific example i'm working on, i have pattern matching over several cases
16:18:13 <dnkndnts> and as far as i can see, i'd have to write fix for each pattern, right?
16:18:26 <dnkndnts> i can't just fix before the pattern match (or can i?)
16:19:32 <Fuuzetsu> fix (\f x -> case x of …)
16:19:35 <Fuuzetsu> but just write a helper
16:20:51 <Fuuzetsu> c_wraith: mdo let's you achieve that doesn't it
16:21:34 <c_wraith> Fuuzetsu: mdo is more about allowing cyclic binds
16:21:52 <Fuuzetsu> yeah, I just concluded that it's in fact not what you are after
16:21:52 <dnkndnts> hmm, ya i think it's possible, but i've confused the parser and i don't know how to unconfuse it -- currently, i have like... functionName a b =
16:22:04 <dnkndnts> then several lines starting with vertical bars for my cases
16:22:15 <c_wraith> :t mfix
16:22:16 <lambdabot> MonadFix m => (a -> m a) -> m a
16:22:28 <dnkndnts> when i wrap this in a lambda, it messes up the parsing somehow
16:22:38 <c_wraith> whereas fix :: (m a -> m a) -> m a
16:24:35 <dnkndnts> http://pastebin.com/F4zCXSud
16:24:47 <dnkndnts> that's my code ^^
16:25:14 <trap_exit> how do I tell haste to build in .build
16:25:17 <dnkndnts> the revision doesn't parse
16:25:25 <Fuuzetsu> what is the point of second version
16:25:33 <Fuuzetsu> and it won't parse because it's not valid
16:25:50 <Fuuzetsu> it looks like ‘f grid size -> | … ’
16:27:06 <Fuuzetsu> you can use case () of _ | … trick to be able to use guards but that makes your attempt even more silly, you should just use the first version
16:28:03 <dnkndnts> i'm just confused -- when are vertical bars allowed for pattern matching? why do they work in the original but not in the second case?
16:28:10 * hackagebot persistent 2.1 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-2.1 (GregWeber)
16:28:12 * hackagebot persistent-mongoDB 2.1 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-2.1 (GregWeber)
16:28:14 * hackagebot persistent-mysql 2.1 - Backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-2.1 (GregWeber)
16:28:16 * hackagebot persistent-postgresql 2.1 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-2.1 (GregWeber)
16:28:18 * hackagebot persistent-sqlite 2.1 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-2.1 (GregWeber)
16:28:31 <joelteon> yay, more persistent updates! i knew it
16:30:04 <geekosaur> I don't think they work in lambda syntax but if they did they;d need to be before the -> (and probably replace the = with ->)
16:30:10 <Fuuzetsu> http://www.haskell.org/onlinereport/exps.html 3.13
16:30:17 <pjdelport> dnkndnts: You can think of the | guard syntax as being attached to the pattern match on the left of it.
16:31:18 <pjdelport> (That's not the whole syntax, but first approximation.)
16:32:16 <Fuuzetsu> it's a pretty good approximation
16:33:05 <pjdelport> So, in other words: foo <pattern> | <guard1> = <expr1>  | <guard2> = <expr2>  | ...
16:33:14 <luite> sclv: [jmacro| var i; test: for(i=0;i<10;i++) { console.log(i); if(i>5) break test; } |]
16:33:19 <pjdelport> You can mentally pronounce the | in that case as "where"
16:33:20 * hackagebot persistent-template 2.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-2.1 (GregWeber)
16:33:39 <jle`> i read it as 'if'
16:33:41 <jle`> myself
16:33:48 <jle`> or 'only if'
16:33:50 <pjdelport> That works too.
16:33:54 <geekosaur> "such that"
16:33:59 <jle`> oh yeah
16:34:01 <jle`> such that is the best
16:34:04 <pjdelport> Or perhaps "when", when there are multiple guards.
16:34:23 <geekosaur> which reminds me, next time someone formats the online report, please add link-anchors to the paragraphs, I get tired of having to use examine/copy as html and editing... (for example many wikis will display a gray paragraph symbol after a heading at any level, which is a link to it)
16:34:45 <pjdelport> foo x | (x == 1) = "one"   | (x == 2) = "two"  | ...
16:35:01 <jle`> ah
16:35:19 <dnkndnts> ya, it makes sense to me, but apparently it shouldn't -- because the parser isn't accepting what i'm doing, which means i have the wrong concept in my mind
16:35:23 <dnkndnts> here's what i have currently:
16:35:23 <dnkndnts> http://pastebin.com/GQgAG5LX
16:35:52 <dnkndnts> when i try to run this, the parser says the vertical bars are bad
16:35:53 <pjdelport> You can pronounce that as: foo x, when x equals 1, is "one"; when x equals 2, is "two", (and so on)
16:36:29 <pjdelport> dnkndnts: Right, guards are not allowed in standard lambda expressions
16:36:42 <pjdelport> They're part of the named definition syntax.
16:37:10 <dnkndnts> awww, ok well in that case, yeah, if i can't use this syntax then using fix/lambda is pretty pointless
16:37:21 <jle`> case, too
16:37:24 <dnkndnts> i'll just use the original
16:38:04 <dnkndnts> thanks for the help!
16:38:26 <pjdelport> dnkndnts: You'll probably very rarely use fix and lambda like that in Haskell.
16:38:34 <pjdelport> (except for demonstration or learning purposes)
16:38:56 <dnkndnts> well, if the above guard syntax worked in lambdas it would be perfect for my case
16:39:48 <pjdelport> dnkndnts: You can use case inside of the lambda to do that, though!
16:40:02 <pjdelport> Like Fuuzetsu mentioned.
16:40:58 <pjdelport> case <expr> of <pat> | <guard1> = <expr1> | <guard2> = <expr2> | ...
16:41:14 <dnkndnts> i'm
16:44:04 <dnkndnts> pjdelport: i can't make it work, and it seems like it would take more text than just using the original function name (or a short where alias) in the first place
16:44:18 <pjdelport> dnkndnts: Yup.
16:44:18 <zenkeku> Hey guys! I'm having some unfortunate issues. I'm following the tutorial "Write Yourself A Scheme In 48 Hours," listed on the haskell website; specifically this page: http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/First_Steps However, attempted to compile the first code example (http://lpaste.net/111836) provides this error: http://lpaste.net/111837
16:44:21 <zenkeku> Any ideas?
16:44:27 <pjdelport> dnkndnts: That's why the usual function syntax is there, after all.
16:44:48 <zenkeku> attempting*
16:45:11 <pjdelport> zenkeku: You probably need to de-indent that import statement.
16:45:16 <dnkndnts> pjdelport: anyway, thanks for helping me out!
16:45:25 <jle`> dnkndnts: less text isn't always better :)
16:45:35 <zenkeku> pjdelport: Hmm.. haskell-mode in emacs automatically indents to that.
16:46:10 <zenkeku> However, after removing said indendation, it functions correctly. I'll have to change the default indentation scheme for haskell-mdoe. Thank you!
17:01:29 <quchen> Is there a way to build GHC documentation as one long monolithic HTML file instead of the paginated version? Searching would be much easier that way.
17:01:45 <shachaf> haasn is the expert on these things.
17:02:04 <Fuuzetsu> I would not take him as an expert of building single-page GHC documentation
17:07:11 <pjdelport> It would be nifty if Haddock could generate docs with client-side (JS-based) indexed search, like Sphinx (of Python) does.
17:07:27 <Fuuzetsu> it would be nifty if people sent me patches for such things ;)
17:07:35 <edwardk> Cale: around?
17:07:57 <edwardk> cale: i'd appreciate it if you could look at https://phabricator.haskell.org/D238 and comment. i seem to recall you having strong opinions about nub/nubBy
17:09:00 <shachaf> I,I When are we getting an efficient nub that uses Ord?
17:09:47 <shachaf> The trouble is where the right place to put it is. The obvious implementation uses Set, but that means it can't go in base, and it hardly belongs in containers. And if it went in its own package no one would use it.
17:10:11 <shachaf> Also the Set implementation doesn't let you write a nubBy :: (a -> a -> Ordering) -> ..., since it relies on an instance.
17:10:23 <shachaf> (Unless you use reflection or something awful like that.)
17:10:51 <edwardk> shachaf: stuff like this is why it hasn't happened
17:11:34 <shachaf> edwardk: Well, I don't really care about what happens to nub because it's so inefficient that I'll never use it for anything that isn't a toy.
17:11:50 <shachaf> (Or very small lists, I suppose. If a list has two or three elements nub is fine.)
17:11:56 <edwardk> i've had one use that had to use Eq for it in 6 years ;)
17:12:16 <johnw> shachaf: how about https://gist.github.com/349a0044a4b8fe43802a
17:12:22 <shachaf> I did commit a nub that uses Ord to GHC.
17:12:25 <johnw> (uses Ord rather than Eq)
17:12:28 <johnw> ah
17:12:41 <quchen> edwardk: You probably remember that case because it's next to your "foldl used over foldl'" entry on the list of curious code?
17:12:47 <Cale> edwardk: I would like to be able to rely on the original behaviour of the algorithm in the report. I think in general whenever we have a higher order function which applies some function to elements drawn from a list, and there's a choice about which order the arguments to that function go in, we should preserve the order in which they occurred in the list.
17:13:18 <edwardk> cale: hence why i'm trying to get you to opine on phabricator ;)
17:13:33 <Cale> Oh, commenting here isn't good enough? :)
17:13:35 <shachaf> Wait, no, the one I committed sorts too.
17:13:45 <shachaf> johnw: Yes, I've written that exact function many times.
17:13:56 <edwardk> Cale: you can log in right on the sight, then i can recommend all sorts of fun things for you to opine upon ;)
17:14:00 <shachaf> johnw: Now do one :: (a -> a -> Ordering) -> ...
17:14:05 <edwardk> (in all seriousness this is the only thing i can think of right now)
17:14:12 <edwardk> er on the site
17:14:40 <Cale> lol, I can log in using my twitch.tv account, wat?
17:14:47 <edwardk> johnw: the problem is Set isn't available in base
17:15:02 <edwardk> johnw: one could write a one-off set-like that is used just for the nubOrd function or whatever
17:15:19 <shachaf> So much for code reuse.
17:15:28 <johnw> ah, ok
17:15:28 <edwardk> shachaf: =P
17:16:17 <shachaf> edwardk: Weren't there rumours that reflection is going in base?
17:17:10 <edwardk> shachaf: spj offered to bring it in. the trick is finding the right API for it, getting it into ghc proper, writing the wiredin. i did some patches for it with thoughtpolice last year, but then we dropped it because 7.8 was "imminent" ;)
17:17:35 <jayunit100> the  case statement in haskell seems, funny, how can it work with == as well as pattern matching?
17:17:50 <jayunit100> i.e. case "A" of "A" -> "A" -- works
17:18:05 <shachaf> jayunit100: case doesn't use == except for a few special cases (numbers, OverloadedStrings, etc.).
17:18:05 <mhall> Are .cabal build information fields case-insensitive for the most part? I sometimes see them with the first letter capitalized, sometimes not
17:18:48 <Cale> tsk, phabricator is telling me that it sent mail to my email address, but I didn't get it, and there's nothing in spam
17:18:50 <jayunit100> then how can you do  ''' case "A" of "A"  -> "A" '' ? is that not using == ? (thanks btw shachaf )
17:18:57 <shachaf> jayunit100: It's not.
17:19:06 <shachaf> It's structural pattern-matching.
17:19:09 <jayunit100> ohhh
17:19:21 <quchen> mhall: "Case is not significant in field names, but is significant in field values." -- Cabal user guide
17:19:41 <orb__> == in general can do arbitrary things.  You are expected to make it an equivalence relation, but that's about it.
17:19:49 <pjdelport> jayunit100: That's exactly like saying: case "A" of ['A'] -> "A"
17:19:56 <mhall> quchen: thanks, I had searched that document but missed that line :)
17:19:57 <jayunit100> case "A" of "B" -> "B" -- however, that fails, isnt that the same strucutre?
17:20:01 <pjdelport> or 'A':[] instead of ['A']
17:20:16 <orb__> "B" doesn't match "A"..
17:20:36 <jayunit100> how can we determine a "match", without using == ?
17:20:37 <pjdelport> jayunit100: case Just 'A' of Just 'B' -> "B"
17:20:53 <jayunit100> sorry for my ignorance.  if this is an RTFM feel free to point me somewhere :)
17:20:56 <orb__> jayunit100, it's the other way 'round, == often uses pattern matching.
17:20:58 <tsani> jayunit100: 'A' is a constructor for the Char type.
17:21:13 <pjdelport> jayunit100: == is just a plain function, and not special, in Haskell :)
17:21:26 <orb__> Pattern matching is special, though.
17:21:33 <tsani> jayunit100: so case 'A' of 'A' -> 'A' is just matching on that constructor.
17:21:36 <pjdelport> Pattern matching is what == is built on.
17:21:44 <orb__> pjdelport, (most of the time).
17:21:51 <pjdelport> (Right.)
17:21:57 <shachaf> pjdelport: Well, maybe.
17:22:07 <shachaf> That's kind of an odd thing to say.
17:22:21 <shachaf> It's not "built on" it any more than any function.
17:22:45 * jayunit100 reads/thinks
17:23:47 <pjdelport> (shachaf: That's the point i was trying to get across, more or less. :)
17:23:52 <shachaf> jayunit100: I think any introduction to Haskell talks about this. case is very important, a fundamental part of the language. (==) is a convenience, part of the library.
17:24:01 <Cale> edwardk: Okay, so phabricator doesn't let me log in because its emails don't reach me, so I can't confirm. You can put a comment there with my name in it if you like.
17:24:34 <tsani> shachaf: isn't any function essentially built on pattern matching?
17:24:51 <tsani> (unless you write it point-free, I guess.
17:24:54 <shachaf> jayunit100: To understand case-of, make your life easier by avoiding numbers, characters, strings.
17:25:14 <shachaf> Just use algebraic data types.
17:25:42 <edwardk> commented
17:26:57 <Cale> I wonder what phabricator uses to send mail
17:27:06 <jayunit100> shachaf: example of what you mean?
17:27:32 <jayunit100> algaebreic data types are great predicates for pattern matching.  that i understand.
17:27:53 <jayunit100> but, how it is that they can be used to replace mathematical or char primitives , seems beyone me
17:30:06 <tsani> jayunit100: You can think of Int as a sum type defined like "data Int = ... | -1 | 0 | 1 | 2 | ..."
17:30:06 <johnw> jayunit100: are you familiar with the Peano encoding of natural numbers?
17:30:25 <tsani> (Or you can go the way of Peano arithmetic, yeah.)
17:30:56 <shachaf> jayunit100: I'm not saying they can be used to replace those (though they can), I'm saying it's simpler to ignore them for now.
17:30:59 <quchen> tsani: The problem is that Int isn't a straightforward sum type, which is why shachaf suggested avoiding it.
17:31:12 <benzrf> tsani: those ones are special-cased by the compiler
17:31:23 <benzrf> tsani: but you could of course represent chars as ints
17:31:29 <benzrf> and ints as peanos
17:31:33 <benzrf> or just a really big sum typ
17:31:59 <tsani> That's why I'm just saying "think of X as". It's a simple intuition to see how ADTs can be used for pretty much anything.
17:32:02 <shachaf> I don't think talking about Peano naturals or what-have-you is making life simple.
17:32:58 <jayunit100> johnw: no im not
17:33:09 <jayunit100> shachaf: okay, im going to try that
17:33:23 <johnw> jayunit100: suffice it to say that it's a road down which math and ADTs intersect, but it may be too far astray from the topic at hand
17:33:47 <johnw> or maybe not, I'm not sure exactly what it is you want to grok
17:33:48 <jayunit100> maybe rebuilding a integer numeric system in ADTs could be a good haskell exersize?
17:34:18 <johnw> it's not Haskell, but http://www.cis.upenn.edu/~bcpierce/sf/current/index.html will show you how to build up math and proofs using nothing but ADTs
17:34:33 <johnw> (and case and some other core primitives)
17:37:16 <shachaf> It's not Haskell, but https://en.wikipedia.org/wiki/Principia_Mathematica will show you how to build up 1+1=2 using only a few hundred pages of proofs.
17:37:43 <Cale> edwardk: Ah, finally got a bunch of emails from phabricator all at once now :P
17:37:52 <edwardk> hah
17:38:12 <Cale> shachaf: :D
17:39:01 <Cale> If you seriously want to approach that sort of thing, I would recommend, well, anything more modern.
17:40:13 <shachaf> Cale: What, you want your attempts at formalizing mathematics to be post-Gödel?
17:41:13 <Cale> shachaf: Well, that and the fact that their notation is garbage
17:42:42 <codehero> does (x:xs) match [] ?
17:42:51 <shachaf> No.
17:42:56 <johnw> no, because (:) is a different constructor from []
17:42:58 <shachaf> A list is either (x:xs) or []
17:42:59 <codehero> okay. thank you
17:43:17 <codehero> what i thought. i was afraid that i'd have to change all my code :P
17:46:51 <coiler3> why is it that I can write "  (*2) <$> ZipList [1,5,10]  " in GHCi and get the expected answer, but when I try "   fmap (*2) ZipList [1,5,10]    " I get "No instance for (Num (ZipList t0)) arising from a use of `it'" ? I thought <$> is just an infix way to write fmap?
17:47:22 <Fuuzetsu> it is but the associativity is different
17:47:41 <Fuuzetsu> ‘fmap (*2) (ZipList [1,5,10])’ would work
17:47:54 <shachaf> coiler3: That mean (((fmap (*2)) ZipList) [1,5,10])
17:47:56 <shachaf> ameans
17:47:58 <shachaf> means
17:48:01 * shachaf sighs.
17:48:05 <coiler3> aha, that makes sense, thanks
17:49:53 <bucetron> how high-level signals commands, work on low level signals on the processor architecture?
17:51:27 <Fuuzetsu> Through a compiler? I think I don't understand what you're trying to ask
17:56:42 <bucetron> how the binary ASCII code cammands in haskell activates the compiler
17:57:32 <simpson> bucetron: What's your background? What, more specifically, are you working on?
17:59:01 <bucetron> is to understand the mechanics of code translation. 'm beginner in programming
18:00:24 <simpson> Well, parsers and compilers are a very big topic.
18:02:15 <bucetron> thx
18:14:59 <stolaruk> I'm using System.Directory.renameFile, and trying to figure out what exceptions I might be able to handle. I'm familiar with isDoesNotExistError and isPermissionError, but what about these others listed in the API docs, such as HardwareFault, InvalidArgument, etc? How do I catch and test for these? http://hackage.haskell.org/package/directory-1.2.1.0/docs/System-Directory.html
18:16:18 <Fuuzetsu> use ‘catch’
18:17:59 <shachaf> stolaruk: Those are all IOErrorTypes. GHC.IO.Exception.IOErrorType defines data IOErrorType = AlreadyExists | NoSuchThing | ...
18:18:19 * hackagebot clock 0.4.1.2 - High-resolution clock functions: monotonic, realtime, cputime.  http://hackage.haskell.org/package/clock-0.4.1.2 (CetinSert)
18:18:30 <stolaruk> ok. They don't have links in the docs I'm looking at, and Hoogle couldn't find them either
18:18:51 <stolaruk> thanks!
18:20:03 <stolaruk> Wow, gotta drill into the source to find those
18:20:32 <geekosaur> even more fun perhaps, source won't tell you much about them. `man 2 rename` might be more useful
18:20:35 <shachaf> Yes. It seems a bit suspicious if that's the standard API.
18:21:18 <geekosaur> also, fwiw hayoo isn't linking them either. something wrong with the haddock for IOErrorType?
18:22:15 <stolaruk> Notably, the FP complete hosted Hoogle pointed me to a related lens, which the non-FP complete Hoogle didn't
18:25:21 <stolaruk> PaCPiH has some great stuff on exceptions
18:25:22 <brycelane__> if I have an existential type Foo = forall x . Bar x => Foo x, how do a write the type signature of an accessor, getFoo (Foo x) = x ?
18:25:32 <shachaf> brycelane__: You can't.
18:25:45 <brycelane__> shachaf, why is that?
18:25:51 <CrazyM4n> Vectors have O(1) random access correct?
18:25:57 <shachaf> Because you don't know what type to write for it.
18:26:20 <shachaf> I mean, why are you having trouble with it? That's the reason you can't do it.
18:27:06 <brycelane__> shachaf, I would write getFoo :: Bar x => Foo -> x; is that not well formed in some way I'm not understanding?
18:27:39 <shachaf> That type means that I can choose x.
18:27:40 <hiptobecubic> Why do you need this in the Peano axioms: "For all a and b, if a is a natural number and a = b, then b is also a natural number. That is, the natural numbers are closed under equality." Not why do you need it to be true, but why do you need to state it? Doesn't it follow logically from equality?
18:27:52 <hiptobecubic> oh... this isn't #math
18:27:58 <benzrf> hey edwardk remember i asked you about `Lens s t a b -> Lens [s] [t] a b' and you pointed out that that's not quite total
18:27:58 <shachaf> For example, if Int is an instance of Bar, I can choose to make getFoo :: Foo -> Int
18:28:00 <brycelane__> shachaf, you're right.
18:28:02 <benzrf> what about sized vectors.
18:28:05 <shachaf> Or I can make getFoo :: Foo -> Char
18:28:12 <shachaf> You want *you* to be able to choose what x is.
18:28:13 <bryanedds> hallo haskell frenz :)
18:28:16 <edwardk> for sized vectors it works fine
18:28:23 <edwardk> in fact, there is a name for it already
18:28:25 <edwardk> :t inside
18:28:26 <benzrf> oh huh
18:28:26 <lambdabot> (Data.Profunctor.Rep.Corepresentable p, Functor f) => ALens s t a b -> (p e a -> f (p e b)) -> p e s -> f (p e t)
18:28:30 * benzrf flinches 
18:28:35 <benzrf> aah letter spam
18:28:35 <edwardk> a sized vector is Corepresentable
18:28:45 <brycelane__> shachaf, thanks for the help.
18:28:51 <edwardk> :t outside
18:28:52 <lambdabot> (Data.Profunctor.Rep.Representable p, Functor f) => APrism s t a b -> (p b r -> f (p a r)) -> p t r -> f (p s r)
18:29:06 <edwardk> and that converts a prism to a lens by using the other side of it
18:29:23 <benzrf> i can't read those types at all without like 5 minutes
18:29:28 <benzrf> oh wait
18:29:41 <benzrf> umm... i think i recognize an optic pattern
18:29:44 * benzrf squints
18:29:50 <benzrf> what's a corepresentable
18:29:52 <edwardk> in linear there is a function named 'column' that takes a lens and applies it underneath a corepresentable functor
18:30:01 <edwardk> this one works with a corepresentable profunctor
18:30:42 <edwardk> http://hackage.haskell.org/package/linear-1.10.1.1/docs/Linear-Matrix.html#v:column
18:30:51 <edwardk> column :: Representable f => LensLike (Context a b) s t a b -> Lens (f s) (f t) (f a) (f b)
18:31:01 <edwardk> that should be a bit more understandable
18:31:16 <benzrf> but. what is a corepresentable
18:31:39 <edwardk> Data.Functor.Rep has a Representable f which means f is isomorphic to x -> a for some x --
18:31:42 <Fuuzetsu> it's just a dual of a representable functor ;^)
18:31:51 <benzrf> Fuuzetsu: b-but what's a representable
18:31:59 <benzrf> >inb4 dual of corep
18:32:05 <Fuuzetsu> hue
18:32:16 <edwardk> Data.Profunctor.Corepresentable says you have a profunctor p such that p a b is isomorphic to a -> f b
18:32:29 <benzrf> oh..
18:32:35 <edwardk> Data.Profunctor.Representable says you have a profunctor p such that p a b is isomorphic to f a -> b
18:32:42 <edwardk> note two representables
18:32:45 <edwardk> one for profunctors
18:32:47 <edwardk> one for functors
18:32:58 <benzrf> what does representable mean in ct
18:33:04 <edwardk> if f = Const x then you get the same notion in disguise
18:33:05 <shachaf> i,i profunctor representable by a representable functor
18:33:10 <Fuuzetsu> should I somehow know know what profunctors are before I learned about representable functors
18:33:25 <Taneb> Hmm, an appropriately-kinded Unit would be corepresentable
18:33:32 <edwardk> Fuuzetsu: representable functors are easy
18:33:36 <benzrf> Fuuzetsu: profunctors seem simpler than reps to me
18:33:39 <edwardk> just things that look like functions
18:33:43 <benzrf> they are
18:33:51 <benzrf> just bifunctors that are contravariant in the 1st argument
18:33:57 <benzrf> :o)
18:34:00 <edwardk> f is isomorphic to (->) x for some x
18:34:10 <benzrf> edwardk: oh
18:34:10 <edwardk> that is all a representable Functor is
18:34:22 <edwardk> Complex is isomorphic to (->) Bool
18:34:23 <benzrf> i assume thats in terms of Set in ct
18:34:36 <benzrf> Complex is a Functor?
18:34:38 <benzrf> :k Complex
18:34:38 <lambdabot> * -> *
18:34:40 <benzrf> ah
18:34:42 <edwardk> benzrf: replace (->) with another category and you get the right definition
18:34:49 <edwardk> and Complex _should_ be a functor ;)
18:35:04 <benzrf> "replace (->) with another cateogry"?
18:35:14 <edwardk> benzrf: what i mean is nothing is magic about Set here
18:35:26 <edwardk> you can have representable functors to/from other categories
18:35:39 <benzrf> h-hm
18:35:51 <edwardk> and (co)representable profunctors as well
18:35:56 <Fuuzetsu> benzrf: ok, profunctors are easy then
18:35:56 <benzrf> wait shit i'm mentally conflating morphisms with functors because of (->) D:
18:36:03 * benzrf punches his brain
18:36:23 <Fuuzetsu> oh, I shouldn't have scrolled down to profunctor composition…
18:36:26 <benzrf> :t dimap -- this is profunctr
18:36:26 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
18:36:45 <Fuuzetsu> putting thing in Haskell world is hard ;P
18:37:06 <benzrf> i dont like thing
18:37:26 <Fuuzetsu> maybe I should study CT today
18:37:29 * benzrf tries to figure out what (r ->) looks like as a ct functr
18:37:36 <benzrf> Fuuzetsu: 2math
18:38:49 <edwardk> :t Data.Functor.Contravariant.Representable.Representable
18:38:50 <lambdabot>     Not in scope:
18:38:50 <lambdabot>       data constructor ‘Data.Functor.Contravariant.Representable.Representable’
18:39:36 <benzrf> aaah
18:40:03 <edwardk> :t :t Data.Functor.Contravariant.Rep.tabulate
18:40:04 <lambdabot> parse error on input ‘:’
18:40:08 <edwardk> :t Data.Functor.Contravariant.Rep.tabulate
18:40:08 <Fuuzetsu> Google results for bifunctor 1. Data.Bifunctor on Hackage 2. bifunctor package on Hackage 3. Functor page on wikipedia
18:40:09 <lambdabot>     Not in scope: ‘Data.Functor.Contravariant.Rep.tabulate’
18:40:18 <edwardk> bah ;)
18:40:24 <edwardk> anyway its in there
18:40:31 <benzrf> bifunctor from C to D is literally just functor from C × C to D
18:40:45 <benzrf> who decided that morphism was gonna be the Word of the Topic in CT
18:40:54 <benzrf> couldnt they have picked something with LESS THAN 8 LETTERS
18:41:14 <benzrf> i swear to god i probably couldve saved a day of my life by now if morphism were half its length
18:42:07 <edwardk> hence why i stick to 'hom' ;)
18:42:08 <Fuuzetsu> →
18:42:18 <benzrf> endo→
18:42:22 <benzrf> i can get behind this
18:42:33 <benzrf> mono→, epi→, cata→
18:42:51 <Fuuzetsu> mono and endo usually have their own arrows so that's even easier
18:43:14 <benzrf> do you mean mono and epi
18:43:20 <Fuuzetsu> yes
18:43:21 <benzrf> i associate `epi
18:43:35 <benzrf> i associate `epi' with epipens so its weird for `epi' to not signify an injection
18:43:38 <benzrf> :^)
18:43:49 <Fuuzetsu> anyway if you're using emacs then just type morC-. and it will pretty much always come out to morphism
18:44:31 <benzrf> >usin emacs
18:44:39 <benzrf> vim is the 1 true editor
18:44:53 <Fuuzetsu> enjoy typing in morphism every time and no input methods
18:45:16 <Fuuzetsu> afk
18:45:21 <benzrf> >yfw :inoremap mm morphism
18:45:33 <benzrf> >mfw this causes an input lag every time i type an m
18:46:03 <madariaga> mor^N?
18:46:13 <benzrf> or that :-)
18:54:12 <pjdelport> benzrf: Try :set ttimoutlen=100 or similar
18:54:41 <pjdelport> Or actually, in that case, reducing timeoutlen a tad perhaps
18:54:56 <pjdelport> Or perhaps better, using :abbrev
18:55:18 * pjdelport hopefully reaches a fixed point of self-correction.
19:06:59 <hiptobecubic> Is this the only set of HDF5 bindings we have right now?
19:07:02 <hiptobecubic> https://github.com/jwiegley/bindings-dsl/blob/master/bindings-hdf5/src/Bindings/HDF5.hs
19:08:52 <L8D> @pl \(x, y) -> (f x, f y)
19:08:52 <lambdabot> f *** f
19:09:06 <L8D> @pl \(x, y) -> (f x, g y)
19:09:06 <lambdabot> f *** g
19:09:25 <L8D> @hoogle (***)
19:09:26 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
19:11:12 <stolaruk> If I want to propagate an exception to the parent thread, I must catch it on the child thread and then rethrow it, right? Otherwise the child thread will just die quietly?
19:17:31 <Fuuzetsu> IIRC all this is described in the parconc book
19:17:55 <dfeuer> If lambdabot is telling me the truth, the types of flip (.) flip (.) ...    are pretty fascinating.
19:18:06 <fiatjaf> :t (a -> b) -> a -> b
19:18:07 <lambdabot> parse error on input ‘->’
19:18:24 <dfeuer> :k (a -> b) -> a -> b
19:18:25 <lambdabot> Not in scope: type variable ‘a’
19:18:25 <lambdabot> Not in scope: type variable ‘b’
19:18:25 <lambdabot> Not in scope: type variable ‘a’
19:18:32 <dfeuer> Oh well.
19:18:36 <fiatjaf> :t flip
19:18:37 <lambdabot> (a -> b -> c) -> b -> a -> c
19:18:41 <dfeuer> :k forall a b . (a -> b) -> a -> b
19:18:42 <lambdabot> *
19:18:45 <dfeuer> There you go.
19:20:15 <flebron> Hey, remind me. Can parametricity actually prove that f :: a -> a is exactly id?
19:20:30 <dfeuer> I kind of wonder if 7.10 is really going to come out on time. Also whether it should be named 8.0. It seems like a pretty major big-deal kind of release.
19:20:57 <flebron> (The free theorem would be that forall morphisms g :: X -> Y, we have f . g = g . f, where we're fmapping over the identity functor.)
19:21:31 <dfeuer> flebron, without non-termination, yes.
19:21:39 <dfeuer> With it, no.
19:21:50 <flebron> Assume nontermination. How would you prove it?
19:21:54 <flebron> Err.
19:22:00 <flebron> Assume no non-termination. Damn double negatives.
19:22:09 <dfeuer> I  do not know. I only know it can be done.
19:22:31 <shachaf> @free foo :: a -> a
19:22:31 <lambdabot> f . foo = foo . f
19:22:44 <flebron> Yeah. Does that prove f is id?
19:22:56 <dfeuer> flebron, actually, I have some sense of it.
19:23:29 <flebron> Well, I guess categorically it proves it.
19:23:30 <numberten> what does @free do?
19:23:43 <flebron> Compute the free theorem of a function type.
19:23:49 <flebron> @free Maybe a -> [a]
19:23:49 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
19:23:55 <flebron> @free foo :: Maybe a -> [a]
19:23:55 <lambdabot> $map f . foo = foo . $map_Maybe f
19:27:22 <numberten> i see
19:39:36 <VBlizzard> so, I have a question.
19:39:47 <VBlizzard> is Haskell good server-side/WebDev?
19:40:27 <L8D> how long until Haskell supports {1, 2, 3} for sets?
19:41:59 <karshan> Hello, I have a question about Parsec: Is it possible to parse a file into an AST and retain line/column number information of the nodes in the AST ?
19:42:40 <karshan> Specifically I have looked at language-java and it doesn't seem like you can get back line number information from the AST. I was wondering if this is a fundamental decision that comes from using Parsec ?
19:44:39 <Cale> karshan: getPosition :: Monad m => ParsecT s u m SourcePos
19:44:54 <Cale> and see https://hackage.haskell.org/package/parsec-3.1.7/docs/Text-Parsec-Pos.html#t:SourcePos
19:45:00 <karshan> thank you Cale, I guess I should have looked at the parsec API
19:45:27 <Cale> https://hackage.haskell.org/package/parsec-3.1.7/docs/Text-Parsec-Prim.html#v:getPosition for getPosition
19:47:08 <Cale> Ah, it seems in the case of language-java, they use a separate lexer first, and they don't put information about the sizes of tokens into the tokens.
19:48:34 <Cale> karshan: So, the first step if you wanted to add that feature would be to get the lexer to annotate tokens with sizes, and then find where they're likely using tokenPrim / tokenPrimEx to parse individual tokens, and set the function which updates the SourcePos accordingly
19:48:36 <karshan> Yea, that does seem to be the case. Because the data structures I get from the "parser" function aren't in the ParsecT monad
19:48:46 <shachaf> flebron: Well, let's say f :: () -> T; f _ = x. Certainly foo :: () -> () is id. f (foo ()) = f () = foo (f ()), so foo x = x
19:49:39 <Cale> oh, the lexer is generated with alex
19:49:59 <karshan> Cale: yup it is generated with alex
19:50:22 <Cale> In Language.Java.Parser, you have type P = Parsec [L Token] ()
19:50:59 <karshan> Yup, but the way I've been parsing a file so far is basically calling "parser compilationUnit sourcecode"
19:51:17 <Cale> type Parsec s u = ParsecT s u Identity
19:51:21 <karshan> which returns a CompilationUnit (which is a plain ADT as far as I recall)
19:52:11 <karshan> Cale: oops I might be being stupid. let me check something real quick
19:53:11 <Cale> It doesn't look like their syntax tree is annotated with source positions
19:53:56 <Cale> oh!
19:54:16 <Cale> The L type really is annotated with positions at least
19:54:45 <Cale> So it is keeping track of position information correctly, I misread it at first
19:54:57 <karshan> ok
19:54:57 <Cale> But it's not storing that in the syntax tree
19:55:01 <karshan> yea
19:55:30 <Fuuzetsu> edwardk: when is Ermine getting a Wikipedia page?
19:57:45 <benzrf> :t shift
19:57:46 <lambdabot> Bits a => a -> Int -> a
19:57:49 <benzrf> mfw
19:57:53 <benzrf> :t Control.Monad.Cont.shift
19:57:54 <lambdabot>     Not in scope: ‘Control.Monad.Cont.shift’
19:57:54 <lambdabot>     Perhaps you meant one of these:
19:57:54 <lambdabot>       ‘Control.Monad.Cont.lift’ (imported from Control.Monad.Cont),
19:57:58 <benzrf> ¯\(°_o)/¯
19:58:26 <karshan> Cale: So I can fix this by adding a SourcePos field in nodes of the syntax tree and using getPosition :: Monad m => ParsecT s u m SourcePos to set them ?
20:00:04 <merijn> karshan: Pretty much
20:00:35 <squidz> kind of an off-topic question, but I wanted to ask what you haskellers do in you off-time that you aren't using to 'think programmatically', be it actual code/math/anything analytical. I don't won't to get burnt out reading and hacking and was wondering what yall do to 'balance' yourselves
20:00:54 <merijn> squidz: Binge watch netflix and drink whiskey :p
20:01:18 <shachaf> I grouch at people on IRC.
20:01:26 <merijn> oh, that too
20:02:43 <Fuuzetsu> feel bad about wasting time when I should be hacking instead
20:02:54 <splintax> squidz: cycling. you can think about programming while you do it if you want
20:03:00 <merijn> Fuuzetsu: High-five!
20:03:06 <exio4> I don't feel bad after a nice ... nap ;)
20:03:48 <Fuuzetsu> I have a similar question, what do you do when waiting for compilation to finish? People with fast computers need not apply.
20:03:54 <merijn> Fuuzetsu: I decided 2 weeks ago "I'm going to quickly finish the alpha version of this code and throw it on github", 2 weeks later, still have a ton to do before that point :p
20:03:56 <Fuuzetsu> I don't drink coffee and I don't own a sword either…
20:04:00 <merijn> Fuuzetsu: I go annoy my coworkers
20:04:03 <sellout> squidz: Rock climbing – give it a go. I feel like it’s a very attractive sport to programmers.
20:04:10 <merijn> Fuuzetsu: 15 minute compiles, whoo!
20:04:11 <sellout> Fuuzetsu: Work on a different repo ;)
20:04:21 <usr> yep no atheleticism needed
20:04:32 <squidz> sellout: thanks, I wonder what it is that makes it a good compliment
20:04:37 <Fuuzetsu> sellout: But that requires more processor power and RAM which is all hogged up by initial compile ;P
20:05:27 <sellout> squidz: There’s an element of problem solving, but quite different from that of programming. And often the problems are solved with body position and balance rather than strength.
20:05:58 <squidz> sellout: thanks, that's usefull
20:19:29 <lowfyr> Hello o/
20:20:11 <zRecursive> OCaml seems to be a strict haskell ?
20:21:01 <StoneCypher4k> buhuuuuhhuhuhuhuhuhuhuh
20:22:15 <zRecursive> I am impressed with its fast compiling speed :-)
20:24:45 <hiptobecubic> it also runs quite fast
20:25:04 <lowfyr> Are there any Haskell ninjas in this channel which happen to use emacs as their editor? I am really new to the language and kinda confused.
20:25:05 <hiptobecubic> But among many other things, you give up typeclasses
20:25:27 <hiptobecubic> unfortunately, a great many haskellers use emacs
20:25:38 <shachaf> I don't know of any Haskell ninjas in the world.
20:26:11 <shachaf> Some probably exist. But you might be better off asking, say, Haskell programmers instead.
20:26:23 <lowfyr> ok, excuse me, did not want to be rude
20:27:16 <pjdelport> lowfyr: Confused by Haskell, or the Emacs side of it?
20:27:48 <lowfyr> More by the emacs side of it, i am trying to set up haskell mode.
20:28:14 <pjdelport> lowfyr: I don't use emacs, but there are probably a lot of people here that can answer specific questions.
20:28:21 <pjdelport> There is also #haskell-emacs :)
20:29:25 <dfeuer> zRecursive, OCaml appears to be a perfectly good language that is only vaguely similar to Haskell.
20:30:21 <dfeuer> When I type *sigh* at the command line, bash tells me command not found.
20:30:25 <dfeuer> How could it be so wrong?
20:31:08 <zRecursive> dfeuer: i think so
20:31:36 <dfeuer> But I fixed it. *sigh* works now!
20:32:08 <lowfyr> When I open/create a *.hs file, and want to start the haskell interpreter, it asks me again if I want to create a new file, I can't open another one, it won't show them. So I was wondering a bit on how to work with haskell and emacs in general.
20:33:56 <lowfyr> Also, thanks for the mention of #haskell-emacs, I did not know this channel existed.
20:37:10 <dfeuer> Is there a Haskell shell that's decent for interactive use?
20:37:28 <merijn> zRecursive: ocaml is quite different, no typeclasses, no higher kinded types, first class modules, structural subtyping
20:38:01 <merijn> uglier syntax ;)
20:38:29 <sipa> structural subtyping != substructural typing
20:38:32 <joefiori_> Getting HTTP 400 errors trying to cabal update, has anyone else seen this?
20:38:36 <matdes> is there a haskell function that gives you a list of the result of successive applications of drop?
20:38:44 <sipa> :t drop
20:38:45 <lambdabot> Int -> [a] -> [a]
20:38:45 <merijn> > tails [1..10]
20:38:47 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[4,5,6,7,8,9...
20:38:57 <dfeuer> merijn, what's the impact of the lack of higher-kinded types?
20:39:00 <joefiori_> I've now seen it on two machines, different OSes, anytime I try to cabal install or cabal update
20:39:01 <matdes> ahhh nice, tails
20:39:14 <merijn> dfeuer: No monad transformers?
20:39:35 <merijn> StateT :: (* -> *) -> * -> *
20:39:38 <merijn> eh
20:39:41 <merijn> I miss a * there
20:39:42 <dfeuer> matdes, there's also inits, but that's not going to be efficient till 7.10 comes out, and then only if I can get a patch in.
20:39:46 <merijn> But you get what I mean :)
20:39:49 <pjdelport> matdes: There's iterate
20:39:52 <pjdelport> :t iterate
20:39:53 <lambdabot> (a -> a) -> a -> [a]
20:40:11 <matdes> I’m trying to make a sliceIntoChunks kind of method
20:40:24 <merijn> dfeuer: Anyway "StateT :: * -> (* -> *) -> * -> *" <- second argument is higher-kinded
20:40:34 <pjdelport> > iterate (drop 1) [1..10]
20:40:35 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[4,5,6,7,8,9...
20:40:43 <matdes> so like sliceIntoChunks 3 [1..10] would give you [1,2,3], [2,3,4], [3,4,5] ..
20:40:48 <dfeuer> I see. So you have kinds like * -> * -> *, but not ones like (*->*) -> *
20:40:51 <pjdelport> (That's not precisely the same as "tails", due to the end condition.)
20:41:01 <matdes> pjdelport++
20:41:09 <merijn> dfeuer: If I'm correct, yes. I'm only about 85% sure :)
20:41:20 <dfeuer> merijn, sounds likely.
20:45:36 <pjdelport> > let chunks n = unfoldr split where split [] = Nothing; split xs = Just (splitAt n xs) in chunks 3 [1..10]
20:45:37 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
20:48:31 * hackagebot esqueleto 2.1.0 - Type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-2.1.0 (MichaelSnoyman)
20:50:42 <splintax> hmm, trying to get started with haskellmode-vim
20:50:56 <pjdelport> matdes: unfoldr is pretty great for this kind of thing. :)
20:51:00 <splintax> it works fine but breaks when importing stuff from hackage
20:51:29 <splintax> because it just calls ghci, and my project's internal files fail to load with "ghci Some/Internal/File.hs"
20:51:43 <splintax> because ghci can't see all the libraries installed in the cabal sandbox
20:52:02 <suyase> Why are types important?
20:52:12 <splintax> anyone else successfully solved this problem? can i remap haskellmode-vim to use `cabal repl` or something instead?
20:53:31 * hackagebot warp 3.0.2 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.2 (MichaelSnoyman)
20:53:58 <Fuuzetsu> suyase: because they tell us all kinds of useful stuff before the program is ever ran
20:54:31 <suyase> Fuuzetsu: like what?
20:55:44 <Fuuzetsu> like that you're not trying to add strings to integers
20:56:00 <Fuuzetsu> or that your ‘divide’ function doesn't actually shoot missiles
20:56:10 <pjdelport> suyase: Good type systems eliminate large classes of human error, and also guide the structure and design of programs.
20:56:52 <suyase> pjdelport: what makes a type system good
20:56:54 <pjdelport> suyase: You can think of them as an computer-powered amplifier of one's programming ability.
20:57:58 <pjdelport> suyase: What makes it good is basically achieving the above goals. :) Generally, that means the type system should be unobtrusive (for example, by supporting automatic inference), and also powerful enough to express strong properties about your program.
20:58:31 * hackagebot hRESP 0.1.0.0 - haskell implementation of RESP (REdis Serialization Protocol).  http://hackage.haskell.org/package/hRESP-0.1.0.0 (YiHuang)
20:58:33 * hackagebot yesod 1.4.0 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.4.0 (MichaelSnoyman)
20:58:35 * hackagebot yesod-auth 1.4.0 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.4.0 (MichaelSnoyman)
20:58:37 * hackagebot yesod-auth-oauth 1.4.0 - OAuth Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-oauth-1.4.0 (MichaelSnoyman)
20:58:39 * hackagebot yesod-bin 1.4.0 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.0 (MichaelSnoyman)
20:58:51 <suyase> pjdelport: I'm not sure I buy it - if types were just for categorizing information into different containers, then they're no better than classes
20:58:55 <pjdelport> There's a spectrum of convenience and power, for the user (programming): a good type system seeks to find a balance that maximises both.
20:59:13 <pjdelport> suyase: A good type system does a lot more than that.
20:59:21 <suyase> pjdelport: right, what's the other stuff
20:59:28 <splintax> suyase: type inference is one thing
20:59:37 <pjdelport> Well, the easiest way to understand it is to work with it. Are you learning Haskell?
20:59:54 <suyase> splintax: how is type inference different from class inference?
21:00:10 <suyase> pjdelport: I'm studying types at the moment
21:00:24 <pjdelport> The above is a summary of it, but it's hard to "sell" anything if you're coming from a perspective of "prove it to me", without wanting to actually learn it.
21:00:26 <Fuuzetsu> Hopefully not by asking on IRC ;P
21:00:40 <pjdelport> suyase: So the best way is to go through a Haskell tutorial or two and get a feel for it.
21:00:50 <HeladoDeBrownie> suyase, what are you referring to as "class inference"?
21:01:20 <suyase> HeladoDeBrownie: I'm trying to understand what types are that makes them so important
21:01:38 <suyase> HeladoDeBrownie: I've used types for years in java, C, C++, scala, etc.
21:01:43 <suyase> HeladoDeBrownie: but I've never known why
21:02:01 <exio4> talking about types, coding without algebraic datatypes is really hard after you got used to them :(
21:02:01 <splintax> C doesn't really have types
21:02:03 <pjdelport> suyase: Seriously, you will save a lot of time by just spending an hour or so with Haskell.
21:02:05 <suyase> HeladoDeBrownie: there must be a reason stronger than "because they're good for categorizing information"
21:02:10 <Fuuzetsu> splintax: there's int!
21:02:11 <Fuuzetsu> and int!
21:02:22 <splintax> and if classes aren't types, then i'm not really sure that C++ or java have types either?
21:02:24 <pjdelport> suyase: It's easy for the line of questioning you're engaging in to sound like trolling, even if that isn't your intent.
21:02:28 <exio4> there is also void*... wait, nvm!
21:02:29 <suyase> pjdelport: no, the syntax will get in the way of the truth
21:02:54 <CrazyM4n> So, is there any way to time what GHC does?
21:02:56 <suyase> pjdelport: no, I'm not trolling, I actually want to know what types are
21:03:09 <exio4> do you know what bounded // parametric polymorphism is?
21:03:10 <Fuuzetsu> suyase: if you want to know ‘the truth’ then why don't you go and study type theory?
21:03:26 <pjdelport> suyase: Learning some Haskell is the best way to learn what types are, in Haskell.
21:03:31 <suyase> Fuuzetsu: that's why I'm here - I don't know how to find type theory, and I thought you guys might know
21:03:41 * hackagebot yesod-core 1.4.0 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.4.0 (MichaelSnoyman)
21:03:42 <Fuuzetsu> suyase: Types and Programming Languages is a good book
21:03:44 * hackagebot yesod-eventsource 1.4.0 - Server-sent events support for Yesod apps.  http://hackage.haskell.org/package/yesod-eventsource-1.4.0 (MichaelSnoyman)
21:03:45 <pjdelport> suyase: If you don't intend to learn any Haskell, then nothing people will say to you will make much sense, probably.
21:03:46 * hackagebot yesod-form 1.4.0 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.4.0 (MichaelSnoyman)
21:03:46 <suyase> pjdelport: I know plenty of typed languages, another one won't fix that
21:03:48 * hackagebot yesod-newsfeed 1.4.0 - Helper functions and data types for producing News feeds.  http://hackage.haskell.org/package/yesod-newsfeed-1.4.0 (MichaelSnoyman)
21:03:50 * hackagebot yesod-persistent 1.4.0 - Some helpers for using Persistent from Yesod.  http://hackage.haskell.org/package/yesod-persistent-1.4.0 (MichaelSnoyman)
21:04:02 <exio4> do you know any from the ML family?
21:04:14 <suyase> exio4: me?
21:04:17 <exio4> yep
21:04:18 <pjdelport> suyase: Yes, it will, if you haven't used one with a type system like Haskell's. :)
21:04:18 <splintax> suyase: how much mathematics background do you have? "types" mean something very different to a type theorist (mathematician) and a java programmer, and in haskell the word "type" has a meaning that's somewhere in between
21:04:23 <suyase> exio4: nope
21:04:25 <CrazyM4n> Also, is there an easy way to make a function print status messages without having to make everything unpure?
21:04:26 <splintax> (but probably closer to the mathematician's definition)
21:04:35 <pjdelport> CrazyM4n: There's Debug.Trace
21:04:42 <splintax> and unsafePerformIO ;)
21:04:47 <CrazyM4n> Oh god please no
21:04:48 <pjdelport> (if it's just for debugging)
21:04:48 <HeladoDeBrownie> suyase, probably all the programming languages you've used are typed, however some of them, usually those called dynamically typed languages, may be unityped, i.e., every value is of the same type. The upshot being you can't statically distinguish any of its various cases from each other
21:04:51 <Fuuzetsu> splintax: that's just trace though
21:04:52 <suyase> splintax: I'm not sure I understand the question
21:04:52 <exio4> debug.trace == unsafePerformIO
21:04:53 <tabemann> Debug.Trace though often won't do what you intend it to
21:05:00 <Fuuzetsu> CrazyM4n: writer monad
21:05:08 <CrazyM4n> Fuuzetsu: Thanks
21:05:14 <HeladoDeBrownie> suyase, of course, unityped is such a degenerate case we usually don't say it's typed ;)
21:05:29 <dfeuer> liftM is just a confusing name for fmap, right?
21:05:33 <suyase> HeladoDeBrownie: but statically distinguishing only enables compile-time checking
21:05:38 <splintax> suyase: well, i was going to recommend the introductory chapter of homotopy type theory (free type theory book) as an introduction to what abstract type systems are
21:05:46 <Fuuzetsu> dfeuer: it's fmap for Monad
21:05:46 <exio4> suyase, you may find learning a little bit of Haskell really useful
21:05:47 <shachaf> No, but they are equal.
21:05:50 <HeladoDeBrownie> suyase, that would be the major advantage although I'm unsure if the only
21:05:59 <suyase> exio4: I may eventually
21:06:04 <suyase> HeladoDeBrownie: interesting
21:06:08 <Fuuzetsu> does AMP make liftM = fmap?
21:06:12 <suyase> splintax: I'm sure I'd be fine with it
21:06:15 <CrazyM4n> Could someone give an example of using the writer monad? It´s a bit confusing
21:06:22 <shachaf> liftM is as useful as liftA.
21:06:26 <Fuuzetsu> CrazyM4n: LYAH has examples
21:06:27 <suyase> splintax: I did lang's algebra last year and it was pretty reasonable
21:06:27 <CrazyM4n> Say I have a function, add2 = (2+)
21:06:32 <HeladoDeBrownie> suyase, also, what you said is practically true by construction. Static refers to compile-time
21:06:35 <CrazyM4n> Ok
21:06:47 <splintax> suyase: cool, well, http://hottheory.files.wordpress.com/2013/03/hott-online-611-ga1a258c.pdf
21:06:51 <dfeuer> shachaf, the purpose being to constrain the type and catch errors earlier? Or something else?
21:07:04 <shachaf> You can write instance Functor F where fmap = liftM
21:07:17 <suyase> HeladoDeBrownie: So there are unityped, and statically typed....what prevents classes from being static types?
21:07:23 <suyase> splintax: thanks
21:07:24 <splintax> tbh i haven't made it too far past the introduction of HoTT myself, but afaict everything you could ever want to know about type theory is in there somewhere ;)
21:07:42 <coiler3> reading about haskell makes me want to complete a math degree :)
21:07:43 <HeladoDeBrownie> suyase, I'm not sure, since I don't know enough about the semantics of classical OO languages, but I think classes are types of a sort
21:08:01 <CrazyM4n> coiler3: Reading about haskell makes me want to write more haskell :)
21:08:25 <exio4> haskell is THE gateway drug to lots of crazy things
21:08:28 <suyase> coiler3: the degree is just a piece of paper, you can learn whatever content a math degree would validate you having without enrolling in  a degree program =)
21:08:30 <suyase> HeladoDeBrownie: Hmm
21:08:31 <splintax> HeladoDeBrownie: yeah, it seems like something most haskellers would disagree with, but imo types = classes is an OK first approximation for OO programmers
21:08:32 <HeladoDeBrownie> suyase, assuming the classes are checked at compile time, I don't mean Python classes or anything like that. Python is one of those dynamic/unityped languages.
21:08:34 <dfeuer> suyase, Haskell classes end up implemented as types in GHC Core. I think jhc does something different about them though. Not sure about other implementations (or what implementations other than GHC have an hope of practical relevance)
21:08:38 <coiler3> that too, although to be honest I'm not sure if I'll ever get a chance to work on a 'real world' project in haskell
21:08:47 <coiler3> suyase - I agree!
21:08:52 * hackagebot yesod-sitemap 1.4.0 - Generate XML sitemaps.  http://hackage.haskell.org/package/yesod-sitemap-1.4.0 (MichaelSnoyman)
21:08:54 * hackagebot yesod-static 1.4.0 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-1.4.0 (MichaelSnoyman)
21:08:56 * hackagebot yesod-test 1.4.0 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-1.4.0 (MichaelSnoyman)
21:08:58 * hackagebot yesod-websockets 0.2.0 - WebSockets support for Yesod  http://hackage.haskell.org/package/yesod-websockets-0.2.0 (MichaelSnoyman)
21:09:02 <Fuuzetsu> dfeuer: you're making things more confusing, he's asking about OO-language classes not Haskell classes
21:09:05 <exio4> mathematics, dependant types...
21:09:06 <suyase> dfeuer: JHC and GHC are implementations of the haskell compiler?
21:09:08 <dfeuer> Oh.
21:09:19 <dfeuer> Fuuzetsu, I missed that context, apparently.
21:09:23 <splintax> HeladoDeBrownie: imo python's classes are "types" just as much as java/c++
21:09:36 <splintax> HeladoDeBrownie: they just lack good static analysis tools
21:09:38 <suyase> Fuuzetsu: dfeuer that's not confusing =P...
21:09:39 <coiler3> I think going back to java is going to be difficult :p
21:09:43 <HeladoDeBrownie> splintax, for purposes of this discussion I'm going to have to strongly disagree
21:09:48 <HeladoDeBrownie> splintax, exactly
21:10:00 <Fuuzetsu> suyase: it should be considering Haskell classes have nothing to do with the regular use of the word
21:10:04 <dfeuer> suyase, to the best of my knowledge, GHC is currently the only *practical* Haskell compiler. The rest are either old and dead or still very young and incomplete.
21:10:06 <exio4> splintax, duck typing makes it weird
21:10:23 <joefiori_> is there a workaround for the transformers-0.4.* vs. transformers-0.3.0.0 issue?
21:10:29 <suyase> exio4: duck typing is a paradigm, not a mechanism
21:10:37 <splintax> if the question is "how can types be used to build reliable software", then i guess you can consider python untyped
21:10:48 <dfeuer> jhc is one of the young, incomplete ones, as I understand it.
21:11:06 <suyase> dfeuer: is the J java? as in it compiles to bytecode?
21:11:17 <suyase> dfeuer: and what's the G
21:11:19 <dfeuer> suyase, not in the least. It compiles to C.
21:11:27 <suyase> dfeuer: cool
21:11:33 <dfeuer> GHCJS compiles to Javascript though.
21:12:25 <suyase> It just all seems to wishy washy
21:12:26 <exio4> suyase, I meant Python's "duck typing" makes it weird :P
21:12:30 <dfeuer> suyase, GHC compiles to Cmm usually, but alternatively to LLVM, and there's still an old C backend kept around for porting purposes.
21:12:42 <dfeuer> suyase, GHC = Glorious Glasgow Haskell Compiler.
21:12:49 <pjdelport> suyase: Learn a bit of Haskell. I promise you it will make things a lot less wishy washy.
21:13:02 <HeladoDeBrownie> suyase, to put it one way, if you learned type theory from first principles then Java's type system might seem terribly arbitrary to you
21:13:04 <suyase> dfeuer: is LLVM lawerence livermore virtual machine?
21:13:05 <pjdelport> suyase: And it will almost certainly stay sounding wishy washy until you do.
21:13:11 <CrazyM4n> Seirously, wasn´t there a command line argument that told you what was taking up the most time?
21:13:17 <HeladoDeBrownie> suyase, Haskell's somewhat less so but still with some band-aids
21:13:25 <suyase> pjdelport: none of the wishy bits or the washy bits are haskell specific . . .
21:13:27 <pjdelport> There's no substitute or shortcut for actually having some experience working with a type system like Haskell's
21:13:35 <dfeuer> suyase, I dunno. Could be. It's a popular cross-platform "portable assembly language".
21:13:48 <pjdelport> suyase: Sure, but Haskell is probably the quickest and easiest example to learn from.
21:13:55 <splintax> iirc LLVM did stand for "low level VM" but now it's just LLVM
21:13:57 <suyase> dfeuer: yea, I think that's related to the lawerence livermore national laboratory rose compiler . . .
21:13:59 <pjdelport> suyase: You're free to try others too, of course.
21:14:21 <pjdelport> (e.g. OCaml, if that's more to your taste)
21:14:21 <suyase> pjdelport: I'm not worried about that part yet
21:14:22 <splintax> suyase: not related.
21:14:27 <suyase> splintax: ah
21:14:33 <pjdelport> suyase: What i'm trying to say is that you should be. :)
21:14:37 <exio4> HeladoDeBrownie, didn't know Java had a real type system, I thought it was a bunch of useless garbage that was needed for having more characters per line (because that is how you measure productivity, no?)!
21:14:38 <dfeuer> suyase, dunno. Whether via Cmm or LLVM, it ends up machine code. Unless luite gets his hands on it and turns it into Javascript instead.
21:14:42 <pjdelport> Otherwise you are just dancing around the issue.
21:14:44 <suyase> pjdelport: Right, I reject your assertion =)
21:14:50 * pjdelport shrugs.
21:15:02 <suyase> dfeuer: haha
21:15:08 <HeladoDeBrownie> exio4, well, it has static checking of some things, that's basically a type system, right? :)
21:15:30 <dfeuer> exio4, before Generics, Java's type system was mostly good for increasing the character count, but it's a lot better now. Not great, but a lot better.
21:15:40 <splintax> HeladoDeBrownie: i think you might be talking about type safety rather than type systems (admittedly both terms are ill-defined)
21:15:46 <dfeuer> *Useful*.
21:16:05 <exio4> I am over exaggerating a _little_ bit :P
21:16:09 <suyase> HeladoDeBrownie: why would java's type system seem arbitrary to someone who learned type systems from first principles?
21:16:35 <splintax> because the concept of classes and methods doesn't naturally emerge out of the simplest type systems (ie. simply typed lambda calculus)
21:16:42 <HeladoDeBrownie> ^
21:16:47 <suyase> HeladoDeBrownie: ahh
21:16:57 <suyase> splintax: ah
21:17:09 <HeladoDeBrownie> I'll echo the advice to read Pierce's Types and Programming Languages for a good primer
21:18:54 <CrazyM4n> So can anyone help think of any ways to make this code more efficient? http://lpaste.net/3350335264114343936
21:18:58 <CrazyM4n> And yes, I´m still working on this
21:19:04 <suyase> So if we hypothetically checked all java object types at compile time as static types, the major compunction still remaining for java classes to be types would be that they don't emerge naturally from typed lambda calculus....and as a consequence it's hard to prove anything about them, which weakens them as a type system
21:19:37 <splintax> i don't know what is practically possible wrt java static analysis
21:19:47 <suyase> splintax: hm
21:20:19 <suyase> So, Pierce's types and programming languages, HOTT...anything else?
21:20:29 <splintax> but the fact that java isn't an extension of lambda calculus makes it less mathematically elegant, and it makes it harder to carry over ideas about verifiability etc. from mathematical research
21:20:35 <pjdelport> CrazyM4n: Have you profiled?
21:20:40 <suyase> splintax: aha
21:20:52 <splintax> suyase: i don't know what it would mean to "check all java object types as static types"
21:21:03 <HeladoDeBrownie> Bed time, good night all~
21:21:03 <suyase> splintax: I'm not sure I do either
21:21:11 <CrazyM4n> pjdelport: No, I haven´t
21:21:13 <suyase> splintax: I appreciate your perspective though
21:21:14 <CrazyM4n> How?
21:21:15 <matdes> any nitpicks on my exercism submission? http://exercism.io/submissions/45bf99bd4b2d9c156a914a92 (can upload to lpaste if desired)
21:21:27 <VBlizzard> I have a question.
21:21:40 <VBlizzard> what are the uses of Haskell? I plan to have a field in WebDev.
21:21:41 <splintax> suyase: what are object types, as opposed to static types?
21:21:46 <pjdelport> CrazyM4n: Check out https://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
21:22:11 <CrazyM4n> pjdelport: One other question, I´m kinda having a problem where
21:22:12 <CrazyM4n> you know
21:22:18 <CrazyM4n> the whole thing runs out of memory
21:22:18 <suyase> splintax: I think the type of an object (a class) could be checked at compile time, making it a static type
21:22:26 <pjdelport> CrazyM4n: Short version is to compile with: -prof -fprof-auto -rtsopts
21:22:26 <pjdelport> and then run your program with: +RTS -p
21:22:33 <CrazyM4n> because I keep the whole file in RAM at once. Could you suggest anything to do about that? :P
21:22:36 <matdes> http://lpaste.net/6355119926566453248 is the lpaste
21:22:41 <pjdelport> That will produce a foo.prof file, that contains profiling info.
21:22:58 <pjdelport> It will show you both where CPU time and memory allocation happens.
21:23:00 <CrazyM4n> I´ll decrease the size of the file so it doesn´t overflow and try profiling it
21:23:06 <suyase> splintax: unless there are other necessary properties for a static type
21:23:16 <pjdelport> CrazyM4n: Oh, and are you compiling with -O2 ?
21:23:20 <CrazyM4n> Yes
21:23:24 <pjdelport> Just checking.
21:23:25 <CrazyM4n> Is that a problem?
21:23:29 <pjdelport> That makes a big difference :)
21:23:31 <simpson> suyase, splintax: Java already does this, except for the reflective bits, which erase all types to Object.
21:23:36 <suyase> splintax: but I would appreciate an opportunity to revise my definition if that is explicated as the reality
21:23:55 <suyase> simpson: hmm...
21:24:09 <pjdelport> (No, it's no problem: it's just that a lot of time the answer to "my program runs slow" turns out to be just compiling without any optimizations enabled. :)
21:24:28 <pjdelport> (So always compile with -O2 if you care about speed.)
21:24:40 <splintax> suyase: another thing you might want to look into is hindley-milner type inference. http://stackoverflow.com/questions/12532552/what-part-of-milner-hindley-do-you-not-understand
21:25:04 <splintax> suyase: this allows you to write a haskell program (which is strictly + statically typed) without any type annotations at all
21:25:25 <suyase> simpson: Why are there so many FP articles flaming java classes then?...it seems so...inflammatory (the constant snide parentheticals polluting the pristine programming) and it seems they're using a separate criteria for types than myself
21:25:43 <suyase> splintax: that's cool
21:26:01 <CrazyM4n> Okay, ran the profiler
21:26:06 <splintax> the inference algorithm comes from mathematical "type theory"; it's language-agnostic. i believe rust uses it to infer types as well
21:26:16 <simpson> suyase: It's almost as if the kind of programming that one does has no bearing on the ridiculous things that they might say.
21:26:28 <CrazyM4n> Oh my god it´s a tiny image and it´s all being stored in memory
21:26:31 <CrazyM4n> No wonder it crashes
21:26:40 <CrazyM4n> It´s so big
21:26:51 <CrazyM4n> http://lpaste.net/4937926498666414080
21:27:28 <CrazyM4n> So I see the laggiest function now, but I don´t quite know how I could fix it
21:27:39 <CrazyM4n> I´d like to at least not have it store all the working things in memory
21:27:43 <CrazyM4n> But I don´t know how
21:28:11 <suyase> simpson: hah, right. I've just been trying to learn some FP lately, and it's hard to dig through the...well the inflammatory crap to get down to the skills, tenets, patterns, and concepts
21:29:13 <suyase> simpson: like the #scala channel is a waste of time for the most part
21:29:33 <simpson> suyase: It helps to remember that functions, like objects or values or rules or grammars, are merely concepts that are not necessarily the only building blocks provided by a language.
21:29:46 <suyase> simpson: sure
21:30:26 <suyase> simpson: so these paradigms and their schisms are really just differences in opinion regarding how best to construct software
21:30:34 <pjdelport> CrazyM4n: Just a quick guess, but try adding a strictness annotation to the arguments of mandelbrot?
21:30:50 <CrazyM4n> pjdelport: What´s a strictness annotation?
21:31:15 <pjdelport> CrazyM4n: Try changing the definition to: mandelbrot !x c iter = ...
21:31:24 <simpson> suyase: And of course software engineering is far too young to actually have any good expectations of The One Right Way™ to build things.
21:31:26 <CrazyM4n> Okay, I´ll try that
21:31:28 <splintax> suyase: i guess they are just "differences of opinion", but FP is disproportionately represented in academia and most functional programmers know more than a few languages
21:31:29 <CrazyM4n> Thanks
21:31:30 <pjdelport> You'll need to enable LANGUAGE BangPatterns for that.
21:31:57 <CrazyM4n> Isn´t that just the {!-- looking thing at the top?
21:32:01 <pjdelport> CrazyM4n: The ! is a strictness annotation: it tells Haskell to always evaluate that argument strictly (eagerly), instead of allowing it to be lazy.
21:32:04 <splintax> suyase: so you can see why the FP community can sometimes be seen as elitist
21:32:22 <simpson> Oh, whatever. All communities are sometimes seen at elitist.
21:32:31 <Hijiri> php?
21:33:30 <splintax> i've never perceived the community of any programming language i use at work as elitist
21:34:00 <pjdelport> (CrazyM4n: Actually, on closer inspection, that might not make a big difference. Hmm.)
21:34:18 <CrazyM4n> I will still try it and report back with a new PROF file
21:34:21 <suyase> simpson: hm
21:34:32 <suyase> splintax: yes it's understandable
21:34:47 <CrazyM4n> http://lpaste.net/7477792225615675392 Made a new one with harsher settings also
21:36:38 <Enigmagic> CrazyM4n: how about "file = header ++ mandelColormapString
21:36:39 <pjdelport> CrazyM4n: On the whole, that profiling output doesn't look too suspect, actually.
21:37:18 <pjdelport> CrazyM4n: To avoid everything being kept in memory, you might want to avoid sharing mandelSet as a top-level definition.
21:37:19 <CrazyM4n> Enigmagic: The ++ is O(n) time, and mandelColormapString is a huge, huge string
21:37:37 <Enigmagic> CrazyM4n: reverse is O(n) space.
21:37:50 <CrazyM4n> But it is only called twice
21:37:58 <Enigmagic> on a huge huge string ;-)
21:38:05 <CrazyM4n> I used to use ++, this is a huge speedup :P
21:38:18 <CrazyM4n> It was called over and over again, and there was a reason why, but I forgot how I wrote it
21:38:31 <Enigmagic> except if it's huge, you need to store the whole thing in memory..
21:38:38 <Enigmagic> but ++ you don't (just a thunk)
21:38:41 <pjdelport> CrazyM4n: It's not actually "called"; it's just a single data value that's shared between both uses of it.
21:39:01 <CrazyM4n> pjdelport: so I should make it local to mandelbrot or something?
21:39:02 <Enigmagic> so ++ plus some bang patterns runs in 8mb of ram on my laptop
21:39:05 <pjdelport> So if that's what's growing too big, you need to make it a local value instead.
21:39:18 <CrazyM4n> Enigmagic: Really? That´s actually really impressive
21:39:24 <pjdelport> CrazyM4n: Well, probably local to mandelColormapString
21:39:25 <CrazyM4n> How fast though?
21:40:01 <Enigmagic> CrazyM4n: i don't know how fast it is, or if the results are correct but this is it https://gist.github.com/NathanHowell/44f4fd5ddc74e208c46c
21:40:24 <CrazyM4n> The settings at the top should be Doubles
21:40:33 <CrazyM4n> But hm
21:40:38 <CrazyM4n> I´ll try this
21:40:41 <CrazyM4n> With strict
21:40:41 <mgaut72> hi all.  I am currently having my first run-in with the dreaded "cabal hell" I tend to use cabal sandboxes when I can, but I guess I wasn't diligent enough.  Whats the recommended way to manage libraries and such?
21:40:45 <CrazyM4n> Plus the local mandelSet
21:40:52 <CrazyM4n> Hopefully it will run at super speed :)
21:41:38 <CrazyM4n> Thanks guys
21:41:40 <Enigmagic> CrazyM4n: show/words/unwords isn't terribly fast either..
21:41:54 <CrazyM4n> Enigmagic: That was what was reccommended for me to use
21:42:07 <CrazyM4n> Enigmagic: Would there be anything faster?
21:43:35 <splintax> mgaut72: i don't think there is any better advice than "always use cabal sandboxes" right now :(
21:44:04 <mgaut72> splintax: so should I basically trash my ~/.cabal/lib dir?
21:44:09 <splintax> mgaut72: oh, and also consider using stackage if you have problems with unstable dependencies? i haven't gone down that path yet though
21:45:16 <splintax> mgaut72: that depends on the problem you're having
21:45:19 <CrazyM4n> This whole program is a mess
21:45:47 <CrazyM4n> Thanks so much for all this help though
21:45:53 <CrazyM4n> I´m testing it
21:47:37 <CrazyM4n> http://lpaste.net/7477792225615675392 vs http://lpaste.net/7477792225615675392
21:47:43 <CrazyM4n> Not actually that much of an improvement..
21:47:53 <splintax> mgaut72: some dependencies also live in ~/.ghc so nuking ~/.cabal might not be enough...
21:48:05 <Fuuzetsu> CrazyM4n: you sent the same paste twice
21:48:10 <CrazyM4n> Oh
21:48:13 <CrazyM4n> Oops
21:48:22 <CrazyM4n> http://lpaste.net/7477792225615675392 vs http://lpaste.net/4295130122505158656
21:48:24 <CrazyM4n> My bad
21:48:25 <mgaut72> splintax: I don't see a "cabal uninstall".  is there some equivalent?
21:48:53 <splintax> mgaut72: not really. you can remove ghc packages though, eg. http://www.haskell.org/haskellwiki/Ghc-pkg
21:48:57 <CrazyM4n> https://gist.github.com/CrazyM4n/0acb4cbabdb731220ecf This is the code
21:49:45 <dmj`> mgaut72: cabal sandbox hc-pkg unregister package-name
21:49:51 <Fuuzetsu> that [[[Int]]] screams ‘kill me’
21:49:53 <dmj`> if you're in a sandbox
21:50:26 <mgaut72> dmj`: the problem was, I wasn't in a sandbox, did a few "cabal install"s and shit hit the fan
21:50:35 <Fuuzetsu> CrazyM4n: parconc had a mandelbrot example using repa IIRC, you could peek at that
21:51:08 <mgaut72> splintax: dmj`: its past my bedtime.  I noted your advise, and I will have to look into that in the morning.  Thanks
21:51:19 <splintax> dmj`: hmm, that's a useful command
21:51:26 <Hijiri> @pl parseNewAccount text = xmlToNewAccount =<< parseXMLDoc text
21:51:26 <lambdabot> parseNewAccount = (xmlToNewAccount =<<) . parseXMLDoc
21:51:40 <splintax> one day i will actually understand why cabal hell exists and how to fix it
21:51:48 <L8D> > map (,[]) ["poop", "foo", "bar"]
21:51:50 <lambdabot>  [("poop",[]),("foo",[]),("bar",[])]
21:52:34 <coiler3> I think L8D was trying to say something.
21:55:39 <dmj`> mgaut72: I recomomend using a sandbox, or talk to Fuuzetsu about nix
21:56:13 <dmj`> recommend*
21:57:04 <Fuuzetsu> CrazyM4n: http://fuuzetsu.co.uk/images/1412052941.png gee I wonder where the memory is going
21:58:13 <CrazyM4n> I realize that :P
22:00:25 <Fuuzetsu> hm, seems GHC unpacks everything pretty well
22:00:42 <CrazyM4n> Well then how should I decrease the energy usage of that function?
22:07:09 <Fuuzetsu> .
22:07:22 <Fuuzetsu> christ, ran out of memory, GHC spun out ;/
22:08:37 * hackagebot putlenses 0.1.3 - Put-based lens library  http://hackage.haskell.org/package/putlenses-0.1.3 (HugoPacheco)
22:09:29 <CrazyM4n> Fuuzetsu: Maybe we could make it discard the original array in mandelSet as it´s being used
22:09:35 <CrazyM4n> Is that possible?
22:09:51 <Fuuzetsu> you can use explicit arrays if you want to
22:10:18 <CrazyM4n> How do those work?
22:10:55 <Fuuzetsu> magic and dragons
22:10:56 <Fuuzetsu> @package array
22:10:56 <lambdabot> http://hackage.haskell.org/package/array
22:11:44 <Fuuzetsu> well, vector is the more popular choice
22:12:05 <CrazyM4n> I´ll look at them
22:12:14 <Fuuzetsu> http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial
22:13:11 <CrazyM4n> Thanks man
22:14:56 <wz1000>  /set aspell.check.enabled on
22:15:14 <wz1000> oops
22:18:50 * hackagebot yackage 0.7.0.4 - Personal Hackage replacement for testing new packages. (deprecated)  http://hackage.haskell.org/package/yackage-0.7.0.4 (MichaelSnoyman)
22:22:55 <adarc> hey. is there any way to specify optimization (-O2) using a pragma etc in a source .hs file?
22:23:05 <dmj`> ghc-options: -O2
22:23:10 <copumpkin> {-# OPTIONS -O2 #-}
22:23:19 <adarc> cool thanks folks
22:23:23 <dmj`> er, that's for a cabal file
22:23:54 <adarc> ya, hoping the OPTIONS -O2 decl works.. i've seen that before though now that copumpkin pointed it out
22:25:06 <Hijiri> Is it considered ok to use partial pattern matches in do notation if the monad has a sensible fail instance
22:26:27 <CrazyM4n> What´s the difference between a vector and an unboxed vector?
22:27:06 <Fuuzetsu> unboxed vectors only work over unboxed values
22:27:31 <Fuuzetsu> you really need to write nicer code ;/
22:27:34 <Fuuzetsu> this is a pain to change
22:27:53 <CrazyM4n> It wasn´t meant to get this big
22:28:00 <CrazyM4n> I´m almost done converting it to vector
22:28:01 <CrazyM4n> I think
22:28:09 <Fuuzetsu> as am I
22:29:50 <CrazyM4n> I officially have no idea what I´m doing.. Just trying to add a ¨V.¨ infront of everything that uses lists, haha
22:30:18 <CrazyM4n> No, it´s almost done. Just one pesky little bug I can´t quite track
22:31:08 <Fuuzetsu> mine compiles ;)
22:33:17 <CrazyM4n> Nice
22:33:21 <L8D> is there a way I can clear the console in Haskell?
22:34:00 <dmj`> like ghci? Or clear the terminal screen when running a console app
22:34:13 <L8D> clear the terminal screen
22:34:15 <Fuuzetsu> boo, it just grinds up my CPU and eats more memory ;P
22:34:18 * Fuuzetsu half-expected this
22:34:26 <dmj`> http://hackage.haskell.org/package/ansi-terminal-0.6.1.1/docs/System-Console-ANSI.html
22:34:31 <dmj`> http://stackoverflow.com/questions/2472391/how-do-i-clear-the-terminal-screen-in-haskell
22:34:37 <L8D> I'm writing game of life and want a fancy way to show the animation
22:34:50 <CrazyM4n> Fuuzetsu: Aww, that´s sad
22:35:07 <CrazyM4n> L8D: Link me when you´re done, that sounds really cool
22:35:26 <CrazyM4n> Actually, I want to make my own
22:35:59 <wz1000> L8D: Use ncurses
22:36:14 <L8D> actually I could hook this into GHCJS and some d3 and make it look REALLY cool
22:36:56 <L8D> fine I'll use ncursees
22:37:35 <L8D> It'll probably be easier actually...
22:38:52 <L8D> fuuuuuuu
22:41:07 <CrazyM4n> We don´t have anything as nice as http://hackage.haskell.org/package/ansi-terminal-0.5.0/docs/System-Console-ANSI.html in other languagees D:
22:46:08 <Fuuzetsu> you also don't have all the other nice things ;P
22:56:58 <L8D> @pl [ [ (x, y) | x <- [0..] ] | y <- [0..] ]
22:56:58 <lambdabot> [[(x, y) | x <- [0..]] | y <- [0..]]
22:57:14 <L8D> -.-
23:01:05 <wz1000> > map (0,) [1..]
23:01:09 <lambdabot>  [(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(0,10),(0,11),(0,12),...
23:01:13 <wz1000> > map (0,) [0..]
23:01:15 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(0,10),(0,11),(...
23:02:59 <wz1000> > map (,0) [0..]
23:03:00 <lambdabot>  [(0,0),(1,0),(2,0),(3,0),(4,0),(5,0),(6,0),(7,0),(8,0),(9,0),(10,0),(11,0),(...
23:03:19 <wz1000> L8D: That is what you are looking for.
23:03:28 <L8D> wz1000: no
23:03:31 <L8D> > [ [ (x, y) | x <- [0..] ] | y <- [0..] ]
23:03:33 <lambdabot>  [[(0,0),(1,0),(2,0),(3,0),(4,0),(5,0),(6,0),(7,0),(8,0),(9,0),(10,0),(11,0),...
23:04:00 <L8D> > drop 1 [ [ (x, y) | x <- [0..] ] | y <- [0..] ]
23:04:02 <lambdabot>  [[(0,1),(1,1),(2,1),(3,1),(4,1),(5,1),(6,1),(7,1),(8,1),(9,1),(10,1),(11,1),...
23:04:10 <shiona> what are you trying to get
23:04:22 <L8D> an infinite matrix
23:05:11 <simpson> With what enumeration order?
23:05:13 <shiona> well, there you have one, not too useful though as it never touches anything but the first row
23:05:14 <L8D> [[(0, 0), (1, 0), (2, 0), (3, 0), ...], [(0, 1), (1, 1), ...], ...]
23:06:05 <L8D> @pl [ [ (x, y) | x <- [0..length (g !! y)] ] | y <- [0..length g - 1] ]
23:06:05 <lambdabot> [[(x, y) | x <- [0..length (g !! y)]] | y <- [0..length g - 1]]
23:16:48 <L8D> has anyone else been getting random compile errors when using 7.8.3 and cabal 1.20 on OS X?
23:17:03 <dmj`> not me, what errors are you getting?
23:17:22 <L8D> stupid shit like: System/Random.hs:217:12: parse error on input ‘<-’
23:17:32 <L8D> Control/Sequential/STM.hs:40:2: parse error on input ‘x’
23:17:46 <L8D> [29 of 43] Compiling Data.Text.IO     ( Data/Text/IO.hs, dist/dist-sandbox-f6fda2e3/build/Data/Text/IO.o )
23:17:49 <L8D> Data/Text/IO.hs:236:29:
23:17:52 <L8D>     The last statement in a 'do' block must be an expression
23:17:54 <L8D>       n1 <- writeCharBuf raw n '\r' writeCharBuf raw n1 '\n' >>= inner s'
23:17:57 <L8D> Data/Text/IO.hs:237:49:
23:17:58 <L8D> selected more than I thought
23:18:00 <L8D>     Not in scope: ‘n1’
23:18:03 <L8D>     Perhaps you meant one of these: ‘n’ (line 230), ‘s1’ (line 228)
23:18:05 <L8D> whoops
23:18:09 <L8D> dmj`: look at alll familiar?
23:18:19 <L8D> I thought I went over this problem a month or two ago with you dmj`
23:18:19 <dmj`> no :/
23:18:27 <L8D> remember me?
23:18:47 <dmj`> how could I forget :)
23:19:10 <L8D> I gave up on using haskell...until now...
23:19:48 <L8D> dmj`: any ideas?
23:20:00 <dmj`> don't give up
23:20:12 <dmj`> can you paste your code?
23:20:16 <dmj`> lpaste.com
23:20:40 <L8D> there isn't any code
23:20:42 <dmj`> I guess I need more info about your scenario
23:20:55 <dmj`> so this occurrs on cabal install?
23:20:57 <L8D> I'm just running: cabal sandbox init; cabal install ncurses
23:22:43 <dmj`> k one sec, I'll try
23:24:35 <L8D> I'm so sad :( I googled my error and the only result was from when I lpasted my error over a month ago. :('''''
23:26:02 <jle`> that is sad :(
23:26:26 <shachaf> I recommend applying the usual debugging strategy.
23:26:53 <AshyIsMe> L8D: have you created an actual project first using "cabal init" ?
23:26:53 <shachaf> In this case, syntax errors are a pretty odd thing, so maybe look at Data/Text/IO.hs:263 and see what's going on there.
23:26:54 <L8D> shachaf: giving up on haskell?
23:27:08 <shachaf> Giving up on Haskell works too.
23:27:08 <jle`> is JuicyPixels the recommended library for working with image formats?
23:27:19 <dmj`> shachaf: lol
23:29:20 <L8D> AshyIsMe: I now  have
23:30:33 <dmj`> L8D: have you tried blowing away your haskell installation
23:30:46 <L8D> dmj`: yes...that's why I'm trying this
23:31:38 <AshyIsMe> L8D: so you're just at the start of a brand new mess around project yeah?
23:32:36 <AshyIsMe> steps for setting up a project are:  mkdir myproject ;  cabal init  (and follow the prompts) ; (create Main.hs and add some helloworld code) ; cabal sandbox init; cabal install
23:32:38 <L8D> AshyIsMe: yes
23:33:10 <AshyIsMe> do all the steps within the new project directory you create first, i forgot to put "cd myproject" in after that
23:33:32 <AshyIsMe> after doing all that you should be able to run your program with: cabal run
23:33:43 * hackagebot ncurses 0.2.11 - Modernised bindings to GNU ncurses  http://hackage.haskell.org/package/ncurses-0.2.11 (JohnMillikin)
23:33:45 <L8D> AshyIsMe: my problem is that I can't install text
23:34:26 <dmj`> what version of ncurses?
23:34:44 <L8D> 0.2.11 now
23:35:32 <L8D> the problem is that whenever I go to install text, either text 1.2 or 1.19 it gets that syntax error
23:37:14 <L8D> and I can't really dive into the source
23:37:51 <AshyIsMe> are you on linux, windows or osx?
23:37:56 <L8D> os x
23:38:01 <L8D> ghc 7.8.3, cabal 1.20
23:38:11 <L8D> 1.20.0.3
23:39:06 <AshyIsMe> ah you've got a newer ghc than i do
23:39:45 <AshyIsMe> i'm still on 7.6.3
23:41:15 <L8D> oh god I have a cache 22
23:41:31 <L8D> so apperently there are weird errors in cabal 1.20.0.2
23:41:38 <L8D> and they were fixed in 1.20.0.3
23:42:15 <zRecursive> `cabal install  cabal-install` takes so long time to install both Cabal-1.20.0.2 and Cabal-1.20.0.3. There already is Cabal-1.20.0.3, why does it still install Cabal-1.20.0.2 :-(
23:42:23 <L8D> ^
23:42:38 <L8D> that's part of my problem
23:43:03 <L8D> "cabal-install version 1.20.0.3" "using version 1.20.0.2 of the Cabal library"
23:47:29 <AshyIsMe> haskell is a nice language but cabal is not so nice
23:47:33 <AshyIsMe> especially at first
23:48:03 <L8D> cabal needs to be like npm
23:49:20 <zRecursive> In fact it is "linking" to take so much time
23:50:56 <adas> is there some intuitive way to thinkk about type families and data families? Are they both related?
23:51:28 <shachaf> data families are like type families except they define data types
23:51:38 <AshyIsMe> L8D: i hate to say it but maybe you could spin up a linux vm and mess around with haskell in that?
23:51:44 <shachaf> That makes them injective. I.e. if F A = F B then A = B
23:51:45 <AshyIsMe> vagrant is pretty nice for doing that
23:52:02 <merijn> adas: Type families are simple, they're type level functions
23:56:16 <adas> merijn: can you elaborate a bit? what do you mean by type level functions? are we talking about the "kind" of types here?
23:57:23 <merijn> adas: I mean, you can literally define a function on the type level
23:57:31 <merijn> adas: i.e. a function that takes a type and returns a type
23:57:46 <merijn> adas: The "Fun with Type Functions" paper is a very good introduction
23:58:16 <adas> oh .. thanks.. searching for that paper
23:58:26 <tranma> http://research.microsoft.com/en-us/um/people/simonpj/papers/assoc-types/fun-with-type-funs/typefun.pdf
23:58:26 <adas> merijn: so kind of like a way to create new types at runtime?
23:58:44 <adas> tranma: thanks for the link
23:59:05 <merijn> adas: No, type families are statically check at compile time
23:59:55 <merijn> adas: You can define a function that takes a type and returns a Constraint, for example (e.g. https://gist.github.com/merijn/6130082 and https://gist.github.com/merijn/39dc86e345e87276c523)
