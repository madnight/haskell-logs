00:00:07 <mroman_> although I guess that's 99% of the time not really a problem :)
00:00:30 <mroman_> but usually for small things Maybe or Either is good to indicate errors
00:01:22 <jle`> yeah, why not make errors "first class"?
00:01:31 <jle`> and not a language feature?
00:02:05 <mroman_> also there's monad maybe for that matter
00:02:27 <jle`> not even Monad, Functor and Applicative alone make Maybe values easy to work with as if they were "normal" values
00:02:44 <jle`> so there is minimal cost of abstraction
00:03:28 <jle`> GHC does provide an *Exception* system for its runtime system
00:03:57 <jle`> you know, there are a lot of goodies that the runtime system has that you can access explicitly.  all to let you write nice IO programs
00:04:08 <jle`> the exception system of ghc only makes sense in IO
00:04:22 <jle`> because it's just a tool within the IO type
00:04:48 <jle`> it gives you a system/framework to handle things like IO exceptions (file not found, locked, etc.) within the runtime system
00:05:48 <mroman_> > let safeDiv y z = case z of { 0 -> Nothing; _ -> Just (y / z);} in Just 6 >>= safeDiv 6 >>= return . (1-) >>= safeDiv 6
00:05:49 <lambdabot>  Nothing
00:05:57 <mroman_> > let safeDiv y z = case z of { 0 -> Nothing; _ -> Just (y / z);} in Just 9 >>= safeDiv 6 >>= return . (1-) >>= safeDiv 6
00:05:58 <lambdabot>  Just 17.999999999999996
00:06:56 <mroman_> that way you can chain functions that rely on previous calculations or previous input
00:07:12 <mroman_> and have them "abort" and return Nothing if any function in the "chain" returned Nothing (i.e. indicated an error)
00:08:53 <mroman_> compare
00:09:10 <mroman_> > (\xs -> succ $ head xs) [2]
00:09:11 <lambdabot>  3
00:09:13 <mroman_> > (\xs -> succ $ head xs) []
00:09:15 <lambdabot>  *Exception: Prelude.Enum.().succ: bad argument
00:09:17 <mroman_> ^- boom
00:09:18 <mroman_> vs.
00:09:30 <mroman_> > let head' (x:_) = Just x; head' [] = Nothing in (\xs -> head' xs >>= return . succ) []
00:09:31 <lambdabot>  Nothing
00:09:38 <mroman_> ^- not boom, but "error"
00:09:40 <mroman_> > let head' (x:_) = Just x; head' [] = Nothing in (\xs -> head' xs >>= return . succ) [2]
00:09:42 <lambdabot>  Just 3
00:10:07 <mroman_> (yes, I've become a huge fan of the Maybe-Monad)
00:10:30 <dontdieych> Haskellfant, Thanks. There is no error but no effect. "Content-Type" header is still "application/octet-stream". What I trying to is POST xml file. How can I do this? Original POST request - https://gist.github.com/cd95ef7620b7e317c0f0
00:10:43 <mroman_> It's like encapsuling everything in a try { }
00:12:10 <Haskellfant> dontdieych: could you post the code you tried? i've never used wreq myself, but maybe i can spot an error
00:13:08 <dontdieych> Haskellfant, https://gist.github.com/365a63515f7dbab2fa9f
00:13:31 <farmerworking> Is there an accessor for Just xxx
00:13:39 <farmerworking> Maybe type
00:13:58 <Haskellfant> farmerworking: what exactly do you mean?
00:14:28 <farmerworking> I want to do (Just_accessor (Just 1)) to return 1
00:14:41 <Haskellfant> dontdieych: hm looks fine to me, sorry can't help you there
00:14:51 <Haskellfant> farmerworking: what should it do with Nothing?
00:15:14 <dontdieych> Haskellfant, Thanks.
00:15:54 <Haskellfant> farmerworking: unless you can't guarantee that you'll never get Nothing you should use fromMaybe http://haddocks.fpcomplete.com/fp/7.4.2/20130829-168/base/Data-Maybe.html#v:fromMaybe
00:16:00 <Haskellfant> if you can guarantee it there's fromJust
00:16:18 <Haskellfant> but this will error if you pass in Nothing
00:17:12 <farmerworking> Ok that's what I want
00:18:08 <kadoban> There's also just pattern matching of course, depending on which one makes sense in context.
00:18:25 <farmerworking> It seems wired to me. If I want to handle error I can wrap my function with Maybe and return Nothing when it goes wrong
00:18:29 <mroman_> farmerworking: http://codepad.org/k2Pev0oL <- not sure if this helps you
00:19:04 <farmerworking> But if the function is recursive and I have to unwrap the result to get the value
00:19:10 <mroman_> if there's a divByZero somewhere deep down in the expression to evaluate it will just evalute to Nothing
00:19:32 <farmerworking> It's so painful
00:20:36 <mroman_> (as you can see I don't have to check for Nothing anywhere manually)
00:20:49 <farmerworking> mroman_: I don't get it why you do it like that
00:21:00 <farmerworking> eval has nothing to do with IO
00:21:35 <farmerworking> It's natural to think eval as a pure function
00:21:49 <Mon_Ouie> and `do' has nothing to do with IO or non-purity
00:22:02 <farmerworking> :t return
00:22:03 <lambdabot> Monad m => a -> m a
00:22:37 <Mon_Ouie> IO is a monad, and so is Maybe
00:22:54 <jle`> farmerworking: note that if you have an (a -> b) and a Maybe a, you can apply it to your Maybe a
00:22:59 <jle`> so you don't really ever have to pattern match
00:23:13 <jle`> if you have an (a -> Maybe b) and you have a Maybe b, you can apply it to your Maybe a as well
00:23:17 <jle`> using (=<<) or  (>>=)
00:23:39 <bernalex> Mon_Ouie: IO is an instance of Monad. it is not really a Monad in the mathematical sense.
00:24:53 <bernalex> farmerworking: using Maybe for errors is not the Right Thing, necessarily. it effectively breaks laziness and therefore modularity.
00:25:30 <bernalex> writing a version of head that uses Maybe is fine, writing last is much worse.
00:27:24 <mr-> bernalex: how does Maybe break laziness?
00:27:46 <bernalex> hm. why did I write last? I did not mean last. that's not an example. head. tired.
00:28:05 <tero-> should I use R or Haskell to analyze financial data?
00:28:26 <bernalex> mr-: infinite lists as input to a function that evaluates every member will now stack overflow.
00:28:43 <mroman_> I guess using IO (Maybe a) isn't really comfortable, I have to admit
00:28:58 <mroman_> http://codepad.org/o2teYzDP <- it can be done
00:28:59 <tero-> I think R has more methods already implemented but I'm not familiar with it, so I'm inclining towards Haskell
00:29:07 <jle`> mroman_: it is relatively unpainful if you wrap it in a newtype and implement your own (>>=) for it
00:29:32 <jle`> mroman_: newtype MaybIO a = MaybIO { runMaybIO :: IO (Maybe a) }
00:29:33 <bernalex> mroman_: though TBF you can (nearly?) always get around it with a non-naïve approach.
00:29:37 <bernalex> erm mr- ^
00:29:40 <mroman_> bernalex: really? It breaks laziness?
00:29:56 <mr-> bernalex: I think I don't understand that
00:29:59 <Cale> mroman_: x >>= return . f  =  fmap f x
00:30:10 <bernalex> maybe I need to think of an example
00:30:24 <Cale> mroman_: Also, do { x ; } = do { x } = x
00:30:36 <bernalex> oh, or link this example so that I don't have to. my brain is already stretching it by doing this level of thinking. it's too early yet. http://book.realworldhaskell.org/read/error-handling.html#errors.maybe
00:30:42 <alanb99> hi can anyone point me to somewhere I can learn about "extended default rules" please?
00:30:55 <bernalex> IIRC they also show how to do it whilst preserving laziness
00:31:53 <Cale> alanb99: https://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html#extended-default-rules
00:32:13 <dontdieych> anyone who experienced with `wreq` please show me how to POST xml file with proper content-type header? https://gist.github.com/dontdieych/365a63515f7dbab2fa9f
00:33:09 <alanb99> Cale: thx
00:33:54 <mroman_> bernalex: Makes sense that it breaks laziness in that construction on rwh
00:34:18 <PudgePacket> How do I find which line an ErrorCall came from?
00:34:18 <bernalex> mroman_: yeah so I should have qualified that I meant in a naïve "I'll just wrap this function with Maybe", it can break laziness.
00:34:37 <bernalex> & in general there are nicer ways of dealing with errors, of course. what went wrong? "Nothing"...
00:34:38 <mroman_> that's what you want from divBy anyway
00:34:49 <mroman_> otherwise you'd just use
00:35:22 <mroman_> > let safeDiv _ 0 = Nothing; safeDiv x y = x / y in map (safeDiv 50) [0..10]
00:35:24 <lambdabot>  No instance for (GHC.Show.Show a0)
00:35:24 <lambdabot>    arising from a use of ‘M70388589415857097434600.show_M70388589415857097434...
00:35:24 <lambdabot>  The type variable ‘a0’ is ambiguous
00:35:24 <lambdabot>  Note: there are several potential instances:
00:35:24 <lambdabot>    instance [safe] GHC.Show.Show
00:35:57 <mroman_> > let safeDiv _ 0 = Nothing; safeDiv x y = x / y in (map (safeDiv 50) [0..10]) :: [Just Int]
00:35:59 <lambdabot>  Expected kind ‘*’,
00:35:59 <lambdabot>    but ‘Data.Maybe.Just GHC.Types.Int’ has kind ‘Data.Maybe.Maybe *’
00:36:02 <mroman_> hu
00:36:05 <Hafydd> > return (fail "") :: Maybe (Maybe a) -- no, really, what's wrong, baby?
00:36:06 <mroman_> well... something like that :)
00:36:06 <lambdabot>  Just Nothing
00:36:07 <PudgePacket> Also, does anyone know where I can find the parsec documentation? Hackage has a dead link.
00:36:27 <mroman_> > let safeDiv _ 0 = Nothing; safeDiv x y = Just $ x / y in (map (safeDiv 50) [0..10]) :: [Just Int]
00:36:29 <lambdabot>  can't find file: L.hs
00:36:32 <mroman_> > let safeDiv _ 0 = Nothing; safeDiv x y = Just $ x / y in (map (safeDiv 50) [0..10]) :: [Just Int]
00:36:34 <lambdabot>  Expected kind ‘*’,
00:36:34 <lambdabot>    but ‘Data.Maybe.Just GHC.Types.Int’ has kind ‘Data.Maybe.Maybe *’
00:36:40 <mroman_> damn
00:36:59 <Haskellfant> PudgePacket: http://haddocks.fpcomplete.com/fp/7.4.2/20130829-168/parsec/Text-Parsec.html
00:37:09 <mroman_> it works in my ghci
00:37:15 <mroman_> oh
00:37:19 <mroman_> > let safeDiv _ 0 = Nothing; safeDiv x y = Just $ x / y in (map (safeDiv 50) [0..10])
00:37:20 <lambdabot>  [Nothing,Just 50.0,Just 25.0,Just 16.666666666666668,Just 12.5,Just 10.0,Jus...
00:42:55 <mroman_> > mconcat [Just 1, Just 2]
00:42:56 <lambdabot>  No instance for (GHC.Show.Show a0)
00:42:57 <lambdabot>    arising from a use of ‘M10517068645908155554754.show_M10517068645908155554...
00:42:57 <lambdabot>  The type variable ‘a0’ is ambiguous
00:42:57 <lambdabot>  Note: there are several potential instances:
00:42:57 <lambdabot>    instance [safe] GHC.Show.Show
00:43:03 <mroman_> ^- what's up with that anyway?
00:43:09 <mroman_> @type mconcat [Just 1, Just 2]
00:43:10 <lambdabot> (Monoid a, Num a) => Maybe a
00:43:14 <mroman_> It does have a type
00:43:16 <mroman_> so it type checks
00:43:38 <mroman_> @type fromJust $ mconcat [Just 1, Just 2]
00:43:39 <lambdabot> (Monoid a, Num a) => a
00:43:46 <mroman_> > fromJust $ mconcat [Just 1, Just 2]
00:43:48 <lambdabot>  No instance for (GHC.Show.Show a0)
00:43:48 <lambdabot>    arising from a use of ‘M28700649960567880524787.show_M28700649960567880524...
00:43:48 <lambdabot>  The type variable ‘a0’ is ambiguous
00:43:48 <lambdabot>  Note: there are several potential instances:
00:43:48 <lambdabot>    instance [safe] GHC.Show.Show
00:43:53 <mroman_> ^- boom
00:44:21 <mroman_> > (fromJust $ mconcat [Just 1, Just 2]) :: Int
00:44:23 <lambdabot>  No instance for (Data.Monoid.Monoid GHC.Types.Int)
00:44:23 <lambdabot>    arising from a use of ‘Data.Monoid.mconcat’
00:44:33 <mroman_> ow
00:44:35 <mroman_> I see.
00:44:59 <mroman_> > (fromJust $ mconcat [Just (Sum 1), Just (Sum 2)])
00:45:00 <lambdabot>  Sum {getSum = 3}
00:51:22 * hackagebot compdata-dags 0.1 - Compositional Data Types on DAGs  http://hackage.haskell.org/package/compdata-dags-0.1 (PatrickBahr)
00:56:23 * hackagebot xml-push 0.0.0.0 - Push XML from/to client to/from server over XMPP or HTTP  http://hackage.haskell.org/package/xml-push-0.0.0.0 (YoshikuniJujo)
01:06:21 <slomo> the conduit overview says that a consumer can be used as a sink and as a conduit... but for using it as a conduit (e.g. Data.Conduit.Combiners.dropWhile) you'll have to use something like "dropWhile f >> awaitForever yield"... or am i missing something?
01:54:20 <solatis> bah, all the language bindings for nosql datastores for haskell seem to suck... it's almost as if no-one cares about us :(
01:54:28 <solatis> couchdb seems to be the most mature one
02:10:32 <krgn> is the couchdb one usable though? I have to look into it one of these days
02:39:33 <luite> does anyone have a good setup for overlaying hoogle docs for the name at the cursor in emacs?
02:52:10 <mroman_> > fmap sum . sequence . fmap (fmap (succ)) $ [Just 1, Just 2]
02:52:11 <lambdabot>  Just 5
02:52:20 <mroman_> ^- any suggestions to de-bloat this?
02:55:04 <akagr> Hi everyone. Can someone guide on what's wrong with https://ghostbin.com/paste/n9fpr
02:55:33 <Intolerable> mroman_: fmap (sum . fmap succ) . sequence loses u a fmap and some parens
02:55:34 <akagr> I have listed the code as well as error. I am new haskell
02:55:48 <r444> akagr: it should be takenew :: Num a, Eq a => a -> [b] -> [b]
02:56:21 <Intolerable> akagr: u will need parens around those constraints like (Num a, Eq a) =>
02:56:29 <akagr> r444: can you tell me why?
02:56:46 <jkarni> > sum $ succ <$> catMaybes [Just 1, Just 2]
02:56:48 <lambdabot>  5
02:56:48 <akagr> because pattern matching requires Eq?
02:57:10 <akagr> I guess I am trying to get 0 matched exactly
02:57:21 <lpaste> solatis pasted “No title” at http://lpaste.net/2414769895305641984
02:57:23 <Intolerable> jkarni: catMaybes != sequence
02:57:25 <akagr> so it might be doing a == behind the scenes
02:57:39 <akagr> please correct my deduction if wrong
02:57:43 <r444> haskell doesn't know how to interpret 0
02:57:45 <r444> is it Int?
02:57:49 <r444> is it Double?
02:58:15 <krgn> luite: there is company-ghc, it something along those lines I think https://github.com/iquiw/company-ghc#display-hoogle-document-as-doc-buffer
02:58:20 <akagr> r444: Num not enough? It's numeric... right?
02:58:24 <akagr> I am confused
02:58:40 <Intolerable> akagr: Num doesn't imply Eq
02:58:48 <xnyhps> akagr: Eq is no longer a superclass of Eq (since 7.4), so you have to specifiy it there.
02:58:59 <Intolerable> u can have a valid Num type iirc that doesn't have a sensible Eq instacnce
02:59:23 <r444> Num doesn't imply Eq
02:59:34 <r444> and it should be Eq to pattern match
02:59:58 <akagr> ok I get it... somewhat. Need to study typeclasses first it seems.
03:00:03 <r444> when you pattern match 0, haskell will check it for equality
03:00:30 <r444> xnyhps: i think you mean Num
03:01:29 <xnyhps> Uh, yeah. That second one was Num.
03:02:48 <r444> akagr: generally i'd think: "Do i really want it to be polymorphic? Is it okay to go with Int?". If you really want it to be polymorphic, you'll have to enforce even more boilerplate constraints on other functions in this module.
03:02:57 <r444> just saying
03:04:08 <mroman_> @type catMaybes
03:04:10 <lambdabot> [Maybe a] -> [a]
03:04:15 <akagr> r444: yeah. thanks
03:04:38 <Intolerable> > sequence [Nothing, Just 1]
03:04:39 <lambdabot>  Nothing
03:04:46 <Intolerable> > catMaybes [Nothing, Just 1]
03:04:47 <lambdabot>  [1]
03:04:58 <mroman_> > catMaybes [Just 1, Just 2]
03:05:00 <lambdabot>  [1,2]
03:05:01 <mroman_> ah
03:05:02 <mroman_> k
03:05:46 <mroman_> @hoogle f a -> a
03:05:47 <Laquendi> > foldM (\a b -> ((+a) .  succ) <$> b) 0 [Just 1, Just 2]
03:05:48 <lambdabot> Language.Haskell.TH.Syntax Q :: (forall m. Quasi m => m a) -> Q a
03:05:49 <lambdabot> Network.BufferType buf_empty :: BufferOp a -> a
03:05:49 <lambdabot> Data.Monoid getDual :: Dual a -> a
03:05:49 <lambdabot>  Just 5
03:06:01 <mroman_> there's no f a -> a for Functors
03:07:20 <mroman_> I've always wanted a typeclass for that
03:07:49 <Hijiri> I know there's a "comonad" that has an extract function as part of its definition
03:08:07 <Hijiri> I don't remember the rest of it though
03:08:20 <bergmark> mroman_: just thinking about it, if you have a monoid you can't do this, but if you only have a semigroup you can
03:11:04 <hexagoxel> > sum <$> mapM (succ<$>) [Just 1, Just 2]
03:11:05 <lambdabot>  Just 5
03:11:47 <mroman_> @kind All
03:11:48 <lambdabot> *
03:11:55 <mroman_> @kind Sum
03:11:56 <lambdabot> * -> *
03:11:58 <mroman_> wtf
03:12:29 <mroman_> @type All
03:12:30 <lambdabot> Bool -> All
03:12:34 <mroman_> @type Sum
03:12:35 <lambdabot> a -> Sum a
03:12:43 <mroman_> ok?
03:14:37 <bergmark> @kind Sum Int
03:14:38 <lambdabot> *
03:18:01 <mroman_> yeah
03:18:20 <mroman_> but Any takes an argument
03:18:29 <mroman_> but not a type
03:18:30 <mroman_> hm.
03:26:40 * hackagebot monad-journal 0.2.4 - Pure logger typeclass and monad transformer  http://hackage.haskell.org/package/monad-journal-0.2.4 (DimitriSabadie)
03:29:09 <mroman_> *Main> (+1) </> (Sum 9)
03:29:09 <mroman_> Sum {getSum = 10}
03:29:15 <mroman_> forwhatever I'd ever need that
03:31:09 <Hijiri> is </> something from lens?
03:31:41 <Intolerable> its from System.FilePath
03:32:14 <Hijiri> but mroman didn't use it that way
03:32:27 <slomo> mroman_: for things like "foldMap Sum [1, 2, 3, 4, 5]" for example
03:32:52 <slomo> > foldMap Sum [1, 2, 3, 4, 5]
03:32:53 <lambdabot>  Sum {getSum = 15}
03:36:34 <edlinde> it looks like monads could be super useful in parallel environments. where say we dsitributed a task and if a single task fails then the chaining in the monads will instantly fail
03:37:01 <edlinde> just extapolating a little from the LYAH section that I read on how Monads let you chain a lot of functions together
03:38:01 <srhb> edlinde: You are correct :)
03:38:39 <edlinde> srhb: could you expand a little on that if you have experience with this sort of stuff?
03:38:43 <edlinde> its quite interesting
03:38:51 <Intolerable> endlinde: have u looked at Control.Concurrent.Async?
03:38:58 <edlinde> no
03:39:09 <edlinde> I am reading the last few chapters of LYAH on Monads now
03:40:30 <edlinde> I am trying to understand where Monads would be useful
03:41:05 <Intolerable> have a look at Applicative once ur done
03:41:11 <edlinde> when I saw that you can fail immediately when a function returns failure in this whole chain of functions, then I thought of fault tolerance in distributed environments
03:41:43 <edlinde> but I wonder how in distributed environments state can be saved .. or the computation can continue without one of the failing nodes etc
03:42:01 <edlinde> I already read the Applicative functor
03:42:07 <edlinde> Intolerable: is that what you mean?
03:42:13 <edlinde> or the package?
03:42:23 <Intolerable> the functor
03:42:33 <Intolerable> typically u use monad if u want something sequenced
03:43:29 <Intolerable> if u use the applicative instance tho u can guarantee that everything can be run in parallel
03:43:50 <Intolerable> as long as ur not doing effectful things
03:44:02 <edlinde> hmm interesting
03:44:26 <Intolerable> https://github.com/facebook/Haxl does something similar, its quite impressive
03:44:44 <edlinde> so with the applicative instance are you talking about something like   (+1) <$> (*3) <$> (+4)
03:45:17 <edlinde> so that would take an argument like say 10 and apply (*3) and (+4) to 10 in parallel?
03:45:30 <edlinde> which is then added up?
03:45:52 <edlinde> sorry it should have been  (+) <$> …
03:45:57 <Intolerable> the example haxl uses is: "numCommonFriends x y = length <$> (intersect <$> friendsOf x <*> friendsOf y)"
03:46:16 <edlinde> and also <*> for the second one
03:46:20 <Intolerable> and the applicative instance in this case says that u can go and fetch friendsOf x and friendsOf y in paralle
03:46:25 <Intolerable> *parallel
03:46:43 <edlinde> cool just as I thought
03:46:44 <edlinde> nice
03:46:52 <edlinde> very nifty example
03:47:31 <Intolerable> as long as u can guarantee that ur functions are "pure" then ur things will be fetched in parallel
03:47:57 <Intolerable> (pure as in no effects on the system, not necessarily "no IO")
03:48:07 <edlinde> yep
03:48:48 <edlinde> so you saying applicatives good for parallel stuff and Monads for sequential?
03:49:06 <edlinde> so they can be combined in powerful ways to setup parallel programs?
03:49:11 <Intolerable> essentially all that u get for Monad over Applicative is the concept of ordering
03:49:27 <Intolerable> the ability to say "this computation depends on this other computation"
03:49:31 <edlinde> yep
03:49:45 <edlinde> like a workflow
03:49:47 <Intolerable> and if u put them together u get nice looking parallel stuff
03:49:50 <Intolerable> exactly
03:49:58 <edlinde> hmm
03:50:25 <edlinde> have you read http://chimera.labs.oreilly.com/books/1230000000929?
03:50:31 <sqrt2> :t liftM2
03:50:32 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
03:50:35 <edlinde> think I will look at it next
03:50:35 <sqrt2> :t liftM2 id
03:50:36 <lambdabot> Monad m => m (a2 -> r) -> m a2 -> m r
03:50:53 <sqrt2> why is the inferred type a1 :: a2 -> r, and not r :: a1 -> a2?
03:50:56 <sqrt2> what is the rule there?
03:51:30 <Intolerable> edlinde: i have only read some of it but its a very good book
03:51:43 <edlinde> thanks
03:51:51 <edlinde> will read it after I am done with lyah
03:52:29 <Intolerable> there are a lot of good papers re: concurrent / parallel haskell
03:52:44 <Intolerable> most of the stuff is included in the book tbh
03:53:10 <Intolerable> if u havent already, take a look at monoid too
03:53:23 <Intolerable> can be useful for generalizing parallelizable stuff
03:53:26 <edlinde> I read monoid
03:53:36 <edlinde> it looked simple enough
03:53:46 <edlinde> with the identity and associativity
03:54:08 <edlinde> ofcourse this is when you look at it from the surface
03:54:09 <edlinde> :)
03:54:19 <Intolerable> iirc its trivial to make mconcat parallel
03:54:31 <Intolerable> (if u can split ur work up properly)
03:55:02 <Intolerable> so if u can guarantee something is monoidal u get parallel stuff "for free"
03:56:30 <pjdelport> You get the *potential* to be parallel for free.
03:56:43 * hackagebot html-conduit 1.1.1.1 - Parse HTML documents using xml-conduit datatypes.  http://hackage.haskell.org/package/html-conduit-1.1.1.1 (MichaelSnoyman)
04:00:02 <pertl> can somebody explain how to make this evaluate?
04:00:03 <pertl> mappend (Just 3) (Just 4)
04:00:20 <pertl> I get an "ambigous" error
04:00:29 <Iceland_jack> > mappend (Just (Sum 3)) (Just (Sum 4))
04:00:31 <lambdabot>  Just (Sum {getSum = 7})
04:00:37 <Iceland_jack> > Just (Sum 3) <> Just (Sum 4)
04:00:38 <lambdabot>  Just (Sum {getSum = 7})
04:01:10 <pertl> isn't (Maybe a) itself a monoid?   " instance Monoid a => Monoid (Maybe a) "
04:01:11 <Iceland_jack> Int or Integer do not have Monoid instances
04:01:20 <Iceland_jack> pertl: Yes, only if the 'a' is also a Monoid
04:01:36 <pertl> aaahh, now I see it
04:01:40 <pertl> thanks Iceland_jack
04:01:47 <Iceland_jack> So 'foo :: Maybe Int' is not a monoid, 'bar :: Maybe (Sum Int)' is
04:01:51 <pertl> I missed the constraint
04:01:51 <Iceland_jack> you're welcome :)
04:02:09 <Iceland_jack> > Just "hello" <> Just " " <> Just "world"
04:02:11 <lambdabot>  Just "hello world"
04:02:48 <pertl> I know <*> and <$> but what is <> ?
04:03:00 <Iceland_jack> (<>) = mappend
04:03:01 <Iceland_jack> :)
04:03:06 <Iceland_jack> just a nicer way of writing it
04:03:08 <pertl> nice :-)
04:03:13 <pertl> thanks Iceland_jack
04:03:19 <hpc> or if you are a certain type of terrible person, (<>) = getLine
04:03:20 <hpc> :D
04:03:41 <adas> i installed persistent .. but im not able to import Database.Persist.Sqlite
04:04:05 <pertl> :-P
04:04:13 <bergmark> adas: that's in another package
04:04:23 <adas> bergmark: oh .. persistent-sqlite?
04:04:45 <Haskellfant> hpc: who does such things?
04:05:03 <hpc> http://hackage.haskell.org/package/acme-php-0.0.3/docs/src/Prelude-PHP.html#%3C%3E
04:05:18 <pertl> whoa?!
04:05:41 <pertl> "haskell" -- every day a new surprise
04:06:20 <Haskellfant> hpc: nice :)
04:06:28 <Haskellfant> data Bool = TRUE | FALSE | FILE_NOT_FOUND
04:06:30 <Haskellfant> lol
04:06:44 * hackagebot auto-update 0.1.1.3 - Efficiently run periodic, on-demand actions  http://hackage.haskell.org/package/auto-update-0.1.1.3 (MichaelSnoyman)
04:07:31 <pertl> hpc: that's disgusting :-)
04:08:29 <Haskellfant> isn't f x = if f x then False else True
04:08:48 <hpc> Haskellfant: that only exists to make sortBy pointfree
04:14:22 <sagittarian> does anyone know of a real example where functions are used as monads?
04:14:30 <hpc> Reader
04:14:59 <hpc> more precisely, where ((->) r) is used as a monad
04:15:32 <sagittarian> yes
04:15:33 <Iceland_jack> sagittarian: It's usually wrapped in a newtype (Reader)
04:15:51 <tdammers> pi = "3.14" -- this is my personal favorite
04:16:03 <Iceland_jack> the actual implementation in monad transformers is more involved but that's the general idea
04:16:44 <mroman_> Hijiri: It's my own operator
04:16:46 * hackagebot crypto-random-effect 0.2.0.4 - A random effect using crypto-random  http://hackage.haskell.org/package/crypto-random-effect-0.2.0.4 (ibotty)
04:19:09 <nshepperd> sagittarian: I've used this "newtype ChainReader a = CR (Map String Int -> UV.Vector Double -> a)" which is a specialized monad wrapping ((->) r) twice
04:19:51 <sagittarian> i was thinking of something like >>= with functions specifically
04:20:18 <sagittarian> i understand the definition, but it's not clear to me why i would ever want to do m >>= f >>= g etc where m is a function and f and g are functions that return functions
04:21:36 <mroman_> http://codepad.org/Nm65ekYa @Hijiri
04:24:10 <Laquendi> sagittarian: you can think of Reader as a read only State monad
04:24:20 <sagittarian> okay
04:24:26 <sagittarian> thanks everyone
04:25:00 <Laquendi> for example a game engine might run its main loop in a Reader monad and store keyboard/mouse input there
04:26:47 * hackagebot crypto-random-effect 0.2.0.4.1 - A random effect using crypto-random  http://hackage.haskell.org/package/crypto-random-effect-0.2.0.4.1 (ibotty)
04:27:33 <zenguine> sagittarian: another example and my personal use case for the reader monad relates to laquendi's suggestion.  I want to allow people to write custom characters in a game and allow them to view the gamestate, but onyl modify it according to a preset language that I gave them.  Using "Reader Gamestate" allows me to staticalyl ensure that they can freely programmatically look at the gamestae values, but that they can't modify it outside of
04:27:33 <zenguine> the ways that I give them
04:39:52 <mroman_> http://codepad.org/0RDphb5P <- something like that.
04:40:03 <mroman_> codepad doesn't know First/Last for some reason
04:46:51 <hexagoxel> in HaskellSrcExts, the syntax tree constructor for type class instances (Decl.InstDecl) has [TyVarBind] as its third parameter. What is that parameter for?
04:47:37 <hexagoxel> is there a full grammar definition for the language ghc accepts (with enabled extensions..?) somewhere?
04:50:13 <adas> im trying to follow this tutorial about persistent "https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/persistent-db". But it uses something called "Database.Persist.TH" which is not available even after installing persistent and persistent-sqlite. Any pointers?
04:52:19 <mauris> i'm writing some code that uses Data.Modular: i have    data Point = Point { _x :: ℤ/80, _y :: ℤ/24 }
04:52:34 <mauris> i'd like to write:
04:52:47 <mauris> liftP :: Num a => (a -> a) -> (Point -> Point)
04:52:50 <mauris> liftP f (Point x y) = Point (f x) (f y)
04:53:11 <int-e> hexagoxel: there's the source code, of course. https://github.com/ghc/ghc/blob/master/compiler/parser/Parser.y.pp
04:53:29 <mauris> but ghc seems to want f to be of the more specific types ℤ/80 -> ℤ/80 or ℤ/24 -> ℤ/24 (which of course doesn't work and errors out)
04:53:48 <mauris> why does it need to be? why can't i use a generic Num a => (a -> a) function?
04:54:57 <asfp> is there a way to get a To/FromJSON instance automatically derived without '_'-prefix when using lens on the record?
04:55:00 <lpaste> mauris pasted “No title” at http://lpaste.net/110924
04:55:09 <mauris> ^ like so
04:57:52 <ClaudiusMaximus> mauris: liftP :: (forall a . Num a => a -> a) -> (Point -> Point) -- with -XRankNTypes
04:58:13 <mauris> ah, i just thought that might be it and was figuring out how to get the forall right :)
04:59:52 <WilliamDhalgren> hi! uh, is it common that debian sid still doesn't have the current sable ghc, now 7.8, so long after release? and even experimental doesn't have it for arm arch, which is what I'm waiting for. Template haskell should supposedly work finally on arm w 7.8...
05:02:56 <mauris> hm, this i'm also not sure how to tackle:
05:02:57 <mauris>     Can't make a derived instance of `Show Point':
05:02:57 <mauris>       Constructor `Point' must have a Haskell-98 type
05:03:08 <mauris> roll my own "show"?
05:03:28 <Iceland_jack> mauris: You can use stand-alone deriving
05:03:52 <Iceland_jack> Something like: (I haven't seen the definition of Point)
05:03:52 <Iceland_jack>     deriving instance Show Point
05:03:54 <Iceland_jack> may work
05:04:34 <zenguine> but rolling your own show instance shouldn't be hard if it comes to that , no?
05:04:47 <mauris> cool, Iceland_jack
05:04:52 <mauris> zenguine: it isn't as neat...
05:06:59 <hexagoxel> int-e: hmm, thanks.
05:07:12 <hexagoxel> apparently, you can write "instance forall a . Functor (Either a) where [..]"
05:07:33 <hexagoxel> and the forall stuff gets put into TyVarBinds
05:11:43 <sdfgsdfdsfs> is there a way to pattern match record syntax in an anonymous function to update a field based on the previous value? such as \st -> st { stack = (n:stack) } the latter stack being the value from the passed argument
05:14:29 <nshepperd> \st -> st { stack = n : stack st }
05:15:02 <sdfgsdfdsfs> cool thanks
05:16:51 <zenguine> sdfgsdfdsfs: f st@(Constructor {stack = s}) = st {stack = (n : s)}
05:16:53 <zenguine> works also
05:17:01 <zenguine> if you've got access to the constructor
05:17:32 <zenguine> I assume it works for anonymous functions too.. but I'm not sure
05:18:09 <zenguine> just tested it.. it does work
05:18:10 <mroman_> oh
05:18:23 <mroman_> is there any guide about how to write Generators for QuickCheck?
05:19:30 <zenguine> mroman_: I found this useful http://matt.might.net/articles/quick-quickcheck/
05:19:49 <zenguine> and this: http://www.cse.chalmers.se/~rjmh/QuickCheck/manual.html
05:20:24 <volty> hi, I have  discr :: [a] -> ([a] -> Bool) -> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=a, so  discr lst (\r -> sum r == 40) // is there a way to write it without lambda notation (without \r -> ) ?
05:20:40 <mroman_> zenguine: thx
05:20:59 <volty> hi, I have  discr :: [a] -> ([a] -> Bool) -> [ [a] ], so  discr lst (\r -> sum r == 40) // is there a way to write it without lambda notation (without \r -> ) ?
05:21:08 <mroman_> that looks rather easy actually @gen
05:21:38 <zenguine> volty: replace (\r -> sum r == 40) with (== 40) . sum should work
05:21:49 <mroman_> can you throw away values?
05:21:51 <mauris> @pl \r -> sum r == 40
05:21:51 <lambdabot> (40 ==) . sum
05:22:18 <zenguine> I always forget how awesome @pl is and how well it works haha
05:22:22 <mroman_> (You obviously can with guard)
05:22:33 <Guest75014> hey guys, Is there any function un ghci that has TS [a] -> [[a]]
05:22:53 <mroman_> @type TS
05:22:54 <lambdabot> Not in scope: data constructor ‘TS’
05:22:56 <mroman_> what's TS?
05:23:04 <volty> zenguine: yes, with $ (==40). sum, thx
05:23:42 <Guest75014> what i want to do is - func 2 [1, 2, 3, 4] => result will be [[1, 2], [3, 4]]
05:23:50 <Guest75014> I have implemented my own SplitN
05:24:02 <Guest75014> TS is abbrevation for type signature ;)
05:24:15 <Guest75014> couldnt find anything relevant on hoog;e
05:24:33 <Iceland_jack> Guest75014: chunksOf from split
05:24:39 <Iceland_jack> > chunksOf 2 [1,2,3,4]
05:24:41 <lambdabot>  [[1,2],[3,4]]
05:25:01 <Guest75014> @type chunksOf
05:25:02 <lambdabot> Int -> [e] -> [[e]]
05:25:07 <Guest75014> grea
05:25:34 <zenguine> where is that function defiend?
05:25:35 <Guest75014> what module?
05:25:48 <Iceland_jack> Data.Split
05:25:51 <Iceland_jack> @hackage split
05:25:51 <lambdabot> http://hackage.haskell.org/package/split
05:26:08 <Iceland_jack> *Data.List.Split
05:26:21 <volty> I see, it's because the only argument (r) must come at the end, so I have to compose a function that accepts only one argument (given that I express myself correctly) ?
05:26:53 * hackagebot xml-push 0.0.0.1 - Push XML from/to client to/from server over XMPP or HTTP  http://hackage.haskell.org/package/xml-push-0.0.0.1 (YoshikuniJujo)
05:26:53 <zenguine> volty: not sure what you mean. can you rephrase?
05:28:02 <Guest75014> wondering why hoogle couldnt find it ;)
05:28:23 <steffen> How would you call the act of creating a concrete type from a typeconstructor like Maybe? like, what's the name of doing something like that: type MData = Maybe Data? could you say "make Data an instance of Maybe, or "instanced"" (I know instance actually used for typeclasses, that's why I'm looking for a better word)
05:29:31 <zenguine> instantiation?
05:29:47 <volty> zenguine: relatively new to haskell, I was trying to get that thing work without lambda, and I forgot that to achieve that I have to make a function accepting one argument (but never mind, I was just thinking keyboardly :)), thx again
05:30:07 <zenguine> volty: gotcha, glad to help :)
05:30:13 <steffen> Or maybe "instantiation of type Maybe" ?
05:31:39 <steffen> Maybe I got it now: Could I say "... so that the instantiation of type Maybe for MyType looks like the following: type MTy = Maybe MyType"?
05:33:19 <silver> beware of OOP conotations
05:33:26 <bergmark> steffen: fully applied type, perhaps. what you are after is that the type has kind *
05:34:18 <steffen> bergmark: yes, thank you!
05:35:26 <zenguine> or saying that the type is concrete
05:37:35 <johnw> carter: ?
05:53:32 <mroman_> Wasn't there some module that allowed one to inspect how much RAM something is eating
05:55:24 <mroman_> i.e. to measure how much RAM my data stored in an IORef is currently taking
06:01:00 <mroman_> > (map id [1..]) `seq` (take 2) $ [1..]
06:01:01 <lambdabot>  [1,2]
06:01:06 <mroman_> I'm surprised this terminates
06:01:32 <Iceland_jack> > seq (undefined:undefined) ()
06:01:34 <lambdabot>  ()
06:02:12 <mroman_> > print 9 `seq` return 1
06:02:14 <lambdabot>  No instance for (GHC.Show.Show (m0 a0))
06:02:14 <lambdabot>    arising from a use of ‘M8858576725325168489237.show_M8858576725325168489237’
06:02:14 <lambdabot>  The type variables ‘m0’, ‘a0’ are ambiguous
06:02:14 <lambdabot>  Note: there are several potential instances:
06:02:14 <lambdabot>    instance [safe] GHC.Show.Show a =>
06:02:35 <Iceland_jack> > print 9 `seq` ()
06:02:36 <lambdabot>  ()
06:02:56 <sagittarian> how does that work?
06:03:10 <Iceland_jack> There is a difference between evaluating an expression and executing an action
06:03:25 <sagittarian> @pl \x -> (x, x)
06:03:25 <lambdabot> join (,)
06:03:46 <Iceland_jack> The above expression evaluates 'print 9' to something called weak-head normal form (WHNF) but it doesn't execute the action
06:03:51 <sagittarian> is there a way to tell lambdabot not to use certain functions to arrive at a pointless form?
06:04:26 <Iceland_jack> Not really
06:04:29 <sagittarian> @pl \f -> \x -> f xx
06:04:29 <lambdabot> const . ($ xx)
06:04:35 <Iceland_jack> @ty (id &&& id)
06:04:36 <lambdabot> c' -> (c', c')
06:04:37 <sagittarian> @pl \f -> \x -> f x x
06:04:37 <lambdabot> join
06:04:43 <sagittarian> genius
06:04:52 <Iceland_jack> If you want to avoid join
06:05:00 <fizbin> Anyone on who has a decent amount of experience with fgl?
06:05:36 <sagittarian> nice idea, thanks Iceland_jack
06:06:03 <fizbin> Actually, no, that's not really necessary. Let me figure out how to rework my problem to present it with all the fgl stuff abstracted away, since it isn't really graph-specific.
06:06:04 <Iceland_jack> Also
06:06:05 <Iceland_jack> :t (,) =<< id
06:06:06 <lambdabot> a -> (a, a)
06:06:13 <Iceland_jack> > ((,) =<< id) 'a'
06:06:15 <lambdabot>  ('a','a')
06:06:25 <Iceland_jack> but that's cheating
06:15:07 <sagittarian> that's cheating because it uses functions as monads which have join defined for them?
06:24:34 <theme2> hi
06:24:57 <Iceland_jack> hey theme2
06:27:00 * hackagebot cndict 0.2.3 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  http://hackage.haskell.org/package/cndict-0.2.3 (DavidHimmelstrup)
06:32:00 * hackagebot arith-encode 0.6.0 - A practical arithmetic encoding (aka Godel numbering) library.  http://hackage.haskell.org/package/arith-encode-0.6.0 (emc2)
06:32:22 <bb6xt> @hoogle STM a
06:32:25 <lambdabot> Did you mean: :: STM a
06:32:25 <lambdabot> package STMonadTrans
06:32:25 <lambdabot> package stm-channelize
06:32:48 <akagr> :q
06:32:54 <akagr> sorry
06:33:40 <bb6xt> @hoogle <$>
06:33:40 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
06:33:40 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
06:39:44 <lericson_> :t ($)
06:39:45 <lambdabot> (a -> b) -> a -> b
06:40:23 <lericson_> @pl \ x y -> abs(x - y)
06:40:23 <lambdabot> (abs .) . (-)
06:40:47 <lericson_> > map (+1) [1 2 3]
06:40:49 <lambdabot>  can't find file: L.hs
06:40:53 <lericson_> > map (+1) [1 2 3]
06:40:55 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> a1 -> b))
06:40:55 <lambdabot>    arising from the ambiguity check for ‘e_11123’
06:40:55 <lambdabot>  from the context (GHC.Num.Num (a -> a2 -> b),
06:40:55 <lambdabot>                    GHC.Num.Num a2,
06:40:55 <lambdabot>                    GHC.Num.Num a,
06:40:58 <lericson_> ..?
06:41:07 <Intolerable> > map (+1) [1, 2, 3]
06:41:09 <lambdabot>  [2,3,4]
06:41:18 <Intolerable> dont forget ur commas
06:41:22 <Intolerable> this aint lisp
06:41:29 <lericson_> haha, oh sorry
06:41:58 <lericson_> how does @pl work?
06:43:06 <theme2> @help
06:43:06 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:43:10 <lpaste> fizbin pasted “Some graph manipulation” at http://lpaste.net/110934
06:43:10 <theme2> @help pl
06:43:11 <lambdabot> pointless <expr>. Play with pointfree code.
06:43:15 <Intolerable> it makes a function u give it pointfree
06:43:19 <theme2> lericson_: there you go
06:43:27 <lericson_> theme2: that's what it does, not how it works
06:43:29 <lericson_> !
06:43:35 <theme2> wait a sec, a pointless command for a pointfree function?
06:43:47 <theme2> lol
06:44:01 <theme2> @help list
06:44:01 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
06:44:07 <KorriX> Hello!
06:44:08 <theme2> list
06:44:12 <theme2> @list
06:44:12 <lambdabot> What module?  Try @listmodules for some ideas.
06:44:16 <theme2> KorriX: hi
06:44:20 <theme2> @listmodules
06:44:20 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
06:44:31 <theme2> that's a lot of modules :/
06:44:44 <Intolerable> has djinn got significantly better in the past year or so? i havent looked at it in a while
06:44:46 <lericson_> @help system
06:44:46 <lambdabot> system provides: listchans listmodules listservers list echo uptime listall join part leave msg codepage quit flush admin ignore reconnect
06:44:48 <Intolerable> @help djinn
06:44:48 <lambdabot> djinn <type>.
06:44:48 <lambdabot> Generates Haskell code from a type.
06:44:48 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
06:44:56 <KorriX> Which haskell compression library will perform well with floationg number data?
06:45:06 <Intolerable> djinn (a, b) -> (b, a)
06:45:11 <Intolerable> @djinn (a, b) -> (b, a)
06:45:11 <lambdabot> f (a, b) = (b, a)
06:45:18 <fizbin> So I have an issue with how to make my graph manipulation better; I posted it in an lpaste at http://lpaste.net/110934 if anyone cares to take a look. Does not require experience with fgl, even though that's what I'm using.
06:45:48 <lericson_> @djinn Num a => a -> [a]
06:45:48 <lambdabot> Error: Undefined type []
06:45:53 <lericson_> @djinn Num a => a -> [] a
06:45:53 <lambdabot> Cannot parse command
06:45:55 <luite> KorriX: do you know what compression method in general works well on your data?
06:45:57 <Intolerable> @djinn halts :: (a -> b) -> a -> Bool
06:45:57 <lambdabot> Cannot parse command
06:46:01 <Flonk> @@ @pl @djinn (a, b) -> (b, a)
06:46:01 <lambdabot>  f = uncurry (flip (,))
06:46:31 <Intolerable> :t swap
06:46:32 <lambdabot> (a, b) -> (b, a)
06:46:36 <fizbin> In a way, part of my issue could be viewed as a problem in how to automatically prove/discover whether two infinite lists are in fact equal.
06:46:56 <theme2> Intolerable: seriously, you can't solve an uncomputable problem here
06:46:58 <KorriX> luite: No :) My data are image-channels with every pixel encoded as a float in range 0 .. 1
06:47:40 <Intolerable> theme2: i thought haskell could do anything
06:47:45 <Intolerable> halting problem be damned
06:47:51 <theme2> O_o
06:48:00 <Intolerable> (/s)
06:48:17 <theme2> ???
06:48:50 <KorriX> luite: I don't need anything sophisticated. Just something "better" than just dumping raw matrices to ByteString :)
06:50:26 <luite> KorriX: does it need to be lossless?
06:50:43 <KorriX> I think it should
06:54:34 <luite> KorriX: unless you have large solid color patches or repeating patterns i'd probably look for some generic image compression lib. jpeg2000 supports single precision float channels and lossless, but i don't know how good compression is then
06:55:11 <KorriX> luite: Thanks for help
06:55:19 <KorriX> luite: I'l try this
06:56:59 <KorriX> By the way - Why ghc is checking constraints after instance matching? I'm just curious why such "algorithmic decision" was made
06:57:24 <KorriX> It would be cool to be able to write two instances with same head and different constraints
06:57:46 <KorriX> (If constraints are overlapping then such case could be resolved as a type error)
06:57:58 <Intolerable> look into the OverlappingInstances extension
06:58:27 <jkarni> KorriX: http://www.haskell.org/haskellwiki/GHC/AdvancedOverlap
06:59:14 <jkarni> KorriX: it doesn't quite get you to the point where you can actually write the same instance head (with different contraints) but it shows how you can emulate the behavior you'd get
06:59:30 <jkarni> KorriX: (the stuff on that link, I mean)
06:59:36 <luite> yeah you probably want to avoid that extension in most situations
06:59:37 <KorriX> jkarni: I know that tehniques
07:00:10 <lpaste> fizbin revised “Some graph manipulation”: “Some graph manipulation” at http://lpaste.net/110934
07:00:10 <KorriX> But for some reason ghc typechecker behaves like that: It checks constraints after the instance matching
07:00:24 <KorriX> I'm just intrested why I's done like that
07:00:41 <KorriX> I hope that there is a deeper reason behind that
07:01:39 <jkarni> KorriX: yeah, I'm not sure myself, but GHC *would* need to do some search and backtracking in order to enable that
07:03:22 <jkarni> KorriX: And given that types further along might depend on which instance gets picked, things could get pretty hairy
07:05:10 <KorriX> jkarni: I don't see any problems if constraints would be dysjoint
07:06:06 <Intolerable> dont u then run into issues w/ guaranteeing that constraints are / arent disjoint
07:06:49 <KorriX> if you would have "instance Read a => X a" and "instance Num a => X a" it makes problem, because for let's say Int instance is ambigous
07:09:29 <jkarni> KorriX: It's not just that - you could maybe use a similar "must be more specific" tack, in the way that OverlappingInstances does
07:10:31 <jkarni> KorriX: my point was, are you convinced (1) that there would still be an intuitive semantics, and (2) a feasible way of implementing it, given all the tricky backtracking involved?
07:11:09 <jkarni> KorriX: we might end up in Prolog-land, where you need a sense of the execution model to know what the result would be
07:13:39 <KorriX> For me the instance notation after such change would be more flexible
07:15:51 <KorriX> imagine a geometry class with few kinds of vectors and simple calculs on them. Then if class Vector would be a subclass of Num you'd be out to do "instance Vector a => Num a"
07:16:08 <jkarni> KorriX: I agree it'd be convenient on many counts
07:16:25 <jkarni> KorriX: I've often wanted it myself
07:17:54 <albeit> How can I truncate a list at the first instance of a repeated value? [1,2,3,1,2] -> [1,2,3]
07:19:08 <KorriX> jkarni: Me too :) This "intuition" is quite natural for instance notation. I think that something like that should come in the further versions of ghc
07:20:38 <jkarni> KorriX: I agree - it's natural, and very nice - but I'm not sure I'm ready to say it should be in future GHCs
07:21:09 <jkarni> KorriX: people have strong opinions against overlapping instances already, and the reasons would carry over
07:22:07 <sokrasf> hello
07:22:18 <sokrasf> I have a question about haskell
07:22:22 <Intolerable> hello
07:22:39 <sokrasf> I am currently reading this book about Monads
07:22:40 <sokrasf> http://learnyouahaskell.com/for-a-few-monads-more
07:23:07 <sokrasf> but it seems that the version of the type Writer that it is using is different form the version of Writer in the haskell of my pc
07:23:33 <sokrasf> I want to do this code
07:23:38 <sokrasf> gcd' :: Int -> Int -> writer [String] Int
07:23:38 <sokrasf> gcd' a b
07:23:38 <sokrasf>   | b == 0    = do
07:23:38 <sokrasf>       tell ["Finished with " ++ show a]
07:23:38 <sokrasf>       return a
07:23:39 <sokrasf>   | otherwise = do
07:23:43 <sokrasf>       tell [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)]
07:24:10 <Intolerable> "Writer", not "writer"
07:24:25 <sokrasf> oh :D
07:24:30 <sokrasf> thank you
07:24:35 <Intolerable> Writer is an actual type, writer is a type variable
07:25:05 <KorriX> jkarni: There are few places like that, where architecture of Haskell / libraries is not following natural intuition
07:26:20 <KorriX> jkarni: I also can't understand why cabal allows for maximal package version constraints
07:27:06 * hackagebot dimensional 0.13.0.1 - Statically checked physical dimensions.  http://hackage.haskell.org/package/dimensional-0.13.0.1 (BjornBuckwalter)
07:28:10 <datura> "Functor is to Lens as Applicative is to Biplate" - are there any good articles on this considering van laarhoven lenses?
07:29:23 <Intolerable> KorriX: it's so that u can specify "i want to keep this library in a state where the api will not change significantly"
07:29:41 <KorriX> jkarni: It sounds for me more like "my package works for any version of package X greater than y, but I'm sure that will break with version z even if such is not relased yet :)
07:30:17 <Intolerable> point releases don't (read: shouldn't) change the api so ur code should compile w/ any version of a major release iirc
07:30:40 <RchrdB> KorriX, background: http://www.haskell.org/haskellwiki/Package_versioning_policy or just read about "semver".
07:31:06 <doismellburning> semver ftw
07:31:35 <zenguine> datura: it was my impression that Functor is to Lens as Applicative is to Traversal
07:31:43 <zenguine> datura: where is that quote from?
07:32:46 <datura> zenguine: it's the title of a paper by russell o'connor http://arxiv.org/pdf/1103.2841v2.pdf
07:32:50 <jkarni> KorriX: It's not "I'm sure it'll break" but rather "I'm not sure it won't"
07:33:47 <datura> zenguine: so, you mean traversal is the same as biplate? that would help me understanding things a lot...
07:34:00 <fgc> what I don't get about cabal is why I can't have multiple versions of the same package installed and have it use the best one for the current build spec
07:34:09 <jkarni> KorriX: also, to go back to the previous topic, a less intrusive (and probably less controversial) extension to GHC would be to automatically derive "class predicate" instances, so that the AdvancedOverlap technique becomes possible without any boilerplate
07:34:20 <jkarni> KorriX: I think I myself would much prefer that
07:36:34 <datura> hah! it seems i never read that paper thoroughly, but gave up early - in the last 3rd paragraph he's talking about a "van Laarhoven representation of a Biplate" which is exactly a van laarhoven lens with the functor replaced by an applicative.
07:36:39 <zenguine> datura: I don't know.  Reading the paper as we speak..
07:36:44 <datura> thank you very much for listening :)
07:36:49 <zenguine> datura: I just meant as far as the types go
07:37:23 <albeit> I always see it recommended to use folds/maps instead of explicit recursion, so why do some built-in libraries use explicit recursion? Specifically, deleteBy in Data.List here http://hackage.haskell.org/package/base-4.7.0.1/docs/src/Data-List.html#deleteBy
07:37:54 <zenguine> datura: type Lens s a = forall f . Functor f => (a -> f a) -> s -> f s
07:37:56 <zenguine> is the type of Lens
07:38:10 <zenguine> and type Traversal s a = forall f . Applicative f => (a -> f a) -> s -> f s
07:38:22 <CasW> Hey guys, can you help me? I try to compile a script of mine, but it says "Not in scope: '>>>'". What should I do?
07:38:30 <zenguine> is the type of traversal.. if memory serves me correctly, I'm not sure if the paper is referring to some deeper correspondence though.. I'm looking at it
07:38:50 <zenguine> CasW: import Control.Arrow ((>>>))
07:38:51 <fgc> CasW: import Control.Arrow    ?
07:39:08 <nshepperd> it would be cool if the compiler could automatically derive version compatibility by type-matching magic
07:39:53 <zenguine> datura: If the paper says that, then I guess a Biplate is a traversal? hmm.. I don't know what Biplate is so I've gotta read a bit more :)
07:40:00 <CasW> It worked, thank you!
07:40:12 <zenguine> CasW: np :)
07:40:32 <datura> zenguine: i was stuggling with traversal, and just came back to the paper after a long time because i noticed i "invented" a specialization of biplate to validation (scalaz calls it like that) last year ;)
07:41:02 <datura> (for migrating some JSON data from one schema to another)
07:41:08 <zenguine> datura: I found simon peyton jones talk on lenses the best exposition that I've seen, in terms of actually understanding the types involved.
07:41:16 <zenguine> datura: I'd recommend you watch it.. let me see if I can find a link
07:41:52 <zenguine> datura: here - https://skillsmatter.com/skillscasts/4251-lenses-compositional-data-access-and-manipulation
07:42:08 <zenguine> I thought it was super clear, and it gets into traversals toward the end
07:43:01 <datura> zenguine: thanks a lot again, i'll watch it right now
07:43:46 <zenguine> datura: glad to help
07:45:47 <Intolerable> is there a way to watch that w/o signing up?
07:45:52 <zenguine> datura: let me know if I can help explain anything you're confused about as you're watching.  I'm no expert but I think my understanding is good enough to be dangerous :D
07:46:06 <zenguine> Idk I'm sure there is a link somewhere
07:55:05 <nyuszika7h> http://dpaste.com/0K3S91R
07:55:12 <nyuszika7h> I already ran the command it says
07:55:32 <legittalon> I’m looking for the haskell version of the Clojure Koans?
07:55:35 <nyuszika7h> GHC 7.6.3 and cabal-install 1.16.0.2
07:55:45 <nyuszika7h> (openSUSE 13.1)
07:55:59 <nyuszika7h> FUSL
07:56:00 <nyuszika7h> er
07:56:03 <nyuszika7h> typo
07:56:05 <nyuszika7h> ignore that
08:06:33 <EvilMachine> I’m stuck with » Data.Binary.decodeFile :: FilePath -> IO [Double] « flooding my RAM and hogging my CPU when I try it on a big file.
08:06:45 <EvilMachine> How do I solve something like that?
08:07:01 <EvilMachine> Am I right in suspecting laziness?
08:07:11 * hackagebot diagrams-contrib 1.1.2.2 - Collection of user contributions to diagrams EDSL  http://hackage.haskell.org/package/diagrams-contrib-1.1.2.2 (bergey)
08:08:17 <steffen> When I have a "pipeline" of many functions chained together via $ the function that gets executed first is shown last and the last is shown first. Is there an easy way to reverse that ordering? (without using high skilled things like lenses and similar stuff please :) )
08:09:20 <EvilMachine> Weird… Hexchat crashed. Sorry. If anyone replied… I missed it.
08:10:37 <ekuam> > (show >>> length) True
08:10:39 <lambdabot>  4
08:11:20 <edwardk> steffen: (&) in lens composes in the other order. x & f = f x     , x & f & g = g (f x)
08:13:57 <steffen> edwardk: is it safe to blindly use it like that without having a understanding of the rest of the lens functions and the concepts?
08:18:33 <bergey> steffen: (&) is fine.  It's (^.) and (%~) you have to watch out for :)
08:19:48 <mauris> and good old (%%@=), of course
08:20:34 <Intolerable> steffen: shameless plug http://intolerable.me/lens-operators-intro/
08:20:49 <Intolerable> mauris: <<.&.= is the best one
08:22:12 * hackagebot MiniAgda 0.2014.9.12 - A toy dependently typed programming language with type-based termination.  http://hackage.haskell.org/package/MiniAgda-0.2014.9.12 (AndreasAbel)
08:22:14 * hackagebot tasty-rerun 1.1.3 - Run tests by filtering the test tree depending on the result of previous test  runs  http://hackage.haskell.org/package/tasty-rerun-1.1.3 (OliverCharles)
08:23:32 <steffen> so it's literally just (&) = flip ($)? if so, I don't even have to intruduce lens as dependency and I can just use it like that :D
08:24:00 <zenguine> steffen: It probably has different fixity also
08:24:11 <zenguine> though I haven't looked
08:25:16 <Intolerable> lens' (&) is infixl 1
08:25:52 <edwardk> infixl 1 & lets it bind just a _little_ tighter than $ so you can mix them
08:27:13 * hackagebot c2hs 0.18.2 - C->Haskell FFI tool that gives some cross-language type safety  http://hackage.haskell.org/package/c2hs-0.18.2 (IanRoss)
08:27:15 * hackagebot monad-journal 0.3 - Pure logger typeclass and monad transformer  http://hackage.haskell.org/package/monad-journal-0.3 (DimitriSabadie)
08:27:32 <steffen> Intolerable: Thank you for that link (and for writing it?!), I'll check it out!
08:29:25 <albeit> Is there an easy way to take the union of two maps, and at the same time get the keys in the first map that were updated?
08:34:47 <bcap> let me test something
08:35:01 <bcap> > [(1,2),(3,'4')]
08:35:02 <lambdabot>  Could not deduce (GHC.Num.Num GHC.Types.Char)
08:35:02 <lambdabot>    arising from the literal ‘2’
08:35:02 <lambdabot>  from the context (GHC.Num.Num t)
08:35:02 <lambdabot>    bound by the inferred type of
08:35:02 <lambdabot>             it :: GHC.Num.Num t => [(t, GHC.Types.Char)]
08:35:20 <bcap> > [(1,2),(3,4,5)]
08:35:21 <lambdabot>  Couldn't match expected type ‘(t, t3)’
08:35:21 <lambdabot>              with actual type ‘(t0, t1, t2)’
08:35:33 <bcap> very interesting
08:35:54 <bcap> in the first case, the expectation error comes from the 1st tuple in the array
08:36:09 <bcap> in the second, comes from the 2nd tuple in the array
08:36:26 <Twey> bcap: They both come from the first
08:36:54 <bcap> look at the second error
08:37:04 <bcap> expected is tuple of 2
08:37:11 <bcap> actual is a tuple of 3
08:37:14 * hackagebot type-list 0.0.0.0 - Operations on type-level lists and tuples.  http://hackage.haskell.org/package/type-list-0.0.0.0 (mjmrotek)
08:37:18 <Twey> bcap: Expected is the type of the first, actual is the type of the second
08:37:39 <Twey> bcap: And in the previous likewise: a constraint is generated from the first that then can't be resolved for the second
08:38:04 <Twey> (namely that the second element is of some type with a Num instance)
08:38:20 <bcap> i got a bit lost in the first error, but it looked to me that it came from the first tuple
08:39:49 <Twey> bcap: It sees [(1,2)] and infers that the type of the expression is (Num a, Num b) ⇒ [(a, b)].  Then it sees a Char in the second position of the second tuple, so it tries to unify Char with Num b ⇒ b and correctly fails, stating that there would need to be a Num Char instance
08:41:32 <Twey> Actually, looks like it concludes first that the whole thing must be of type (Num t, Num Char) ⇒ [(t, Char)] and *then* fails
08:42:13 <bcap> Twey well, i started learning haskell yesterday and I still get a bit lost on error messages
08:42:25 <bcap> I think I will understand it more over time
08:42:32 <bcap> but thanks for the explanation!
08:42:50 <Twey> bcap: It doesn't really matter that you understand the precise order in which checking happens
08:43:04 <Twey> (or it shouldn't, anyway)
08:43:05 <bcap> makes sense, I just got curious
08:43:20 <bcap> the first element of an array defines the array elements type
08:43:26 <Twey> bcap: It's a list, not an array
08:43:31 <bcap> oh, ok
08:43:57 <Twey> But yes, looks like.  But notice that the unification *succeeds* in the former case
08:44:49 <Twey> (Num a, Num b) ⇒ [(a, b)] successfully unifies with Num a ⇒ [(a, Char)] to give (Num a, Num Char) ⇒ [(a, Char)]
08:45:40 <Twey> Only when it tries to solve the Num Char constraint does it fail — and indeed it would be okay to define a Num Char instance, and then that typechecks
08:46:06 <Twey> @let instance Num Char where fromIntegral x = 1
08:46:07 <lambdabot>  .L.hs:166:9:
08:46:07 <lambdabot>      ‘fromIntegral’ is not a (visible) method of class ‘Num’
08:46:18 <Twey> Oops
08:46:29 <Twey> @let instance Num Char where fromInteger x = 'a'
08:46:30 <lambdabot>  .L.hs:165:10: Warning:
08:46:31 <lambdabot>      No explicit implementation for
08:46:31 <lambdabot>        ‘+’, ‘*’, ‘abs’, ‘signum’, and (either ‘negate’ or ‘-’)
08:46:31 <lambdabot>      In the instance declaration for ‘Num Char’
08:46:31 <lambdabot>  
08:46:50 <Twey> :t [(1, 2), (3, 'd')]
08:46:51 <lambdabot>     Could not deduce (Num Char) arising from the literal ‘2’
08:46:51 <lambdabot>     from the context (Num t)
08:46:51 <lambdabot>       bound by the inferred type of it :: Num t => [(t, Char)]
08:47:07 <Twey> Aww.  Guess stuff with warnings doesn't get saved in λb.
08:47:45 <Twey> @let instance Num Char where fromInteger x = 'a'; (+) = undefined; (*) = undefined; (-) = undefined; negate = undefined; abs = undefined; signum = undefined
08:47:48 <lambdabot>  Defined.
08:47:51 <Twey> :t [(1, 2), (3, 'd')]
08:47:52 <lambdabot> Num t => [(t, Char)]
08:47:59 <Twey> [(1, 2), (3, 'd')]
08:48:05 <Twey> > [(1, 2), (3, 'd')]
08:48:07 <lambdabot>  can't find file: L.hs
08:48:13 <Twey> >.<
08:48:15 <bcap> wow
08:48:15 <Twey> > [(1, 2), (3, 'd')]
08:48:17 <lambdabot>  [(1,'a'),(3,'d')]
08:48:23 <chrisdone> does anyone have a function like generate :: Data a => a?
08:48:24 <Twey> Sorry, lambdabot gets a bit muddle-headed sometimes.
08:48:35 <Twey> @undefine
08:48:35 <lambdabot> Undefined.
08:48:39 <bcap> ahahhaha
08:49:02 <bcap> well I got to be honest with you, I didnt understand what you were doing
08:49:08 <bcap> but it was fun
08:49:21 <bcap> I will surely do over time
08:49:26 <bcap> still getting lost on syntax
08:49:44 <Twey> bcap: I defined a (stupid) Num Char instance, so that the ‘2’ in the first pair was interpreted as the character 'a'
08:52:21 <Twey> chrisdone: I think Void is a valid Data…
08:54:42 <chrisdone> Twey: so? =)
08:55:15 <Twey> Heh
09:12:18 * hackagebot instant-generics 0.4.1 - Generic programming library with a sum of products view  http://hackage.haskell.org/package/instant-generics-0.4.1 (JosePedroMagalhaes)
09:12:51 <SwashBuckla> in LYAH, http://learnyouahaskell.com/for-a-few-monads-more (specifically), they mention "We see that our monad doesn't know how to join all of the False outcomes where all coins don't land tails into one outcome."
09:12:55 <SwashBuckla> I don't see how to do this
09:13:10 <SwashBuckla> googling turned up this: http://stackoverflow.com/questions/15190429/specializing-bind-for-monads-over-special-typeclasses-in-haskell which does NOT look simple
09:14:42 <dhrosa> using Parsec, how can I figure out which parser failed?
09:14:55 <dhrosa> I'm getting a ParseError out and I can't tell which one of my parsers generates it
09:15:01 <Intolerable> dhrosa: are u labeling ur parsers properly?
09:15:06 <dhrosa> with <?>
09:15:07 <Intolerable> use <?>
09:15:08 <dhrosa> ?
09:15:08 <dhrosa> yes
09:15:09 <Intolerable> yes
09:15:13 <Intolerable> odd
09:15:25 <Intolerable> what's ur result looking like?
09:16:09 <vlads> I have a type A with all fields of Eq class, is there a possibility to apply some f :: Eq a => [a] -> Bool to [A] to get [Bool] being list of results of f applied to each of fields?
09:16:09 <vlads> As an example of manual application suppose data A = A {x::Int, y::Char}, f = all (==0), result as = [f . map x $ as, f . map y $ as]
09:16:21 <chrisdone> Twey:
09:16:21 <chrisdone> λ> case (generate :: (Int,String,Char,(Int,String),[Int],Void)) of (i,s,c,d,_,_) -> (i,s,c,d)
09:16:21 <chrisdone> (123,"foo",'a',(123,"foo"))
09:16:31 <chrisdone> http://www.reactionface.info/sites/default/files/imagecache/Node_Page/images/1310408064982.jpg
09:16:59 <chrisdone> λ> case (generate :: (Int,String,Char,(Int,String),[Int],Void)) of (i,s,c,d,_,v) -> dataTypeOf v
09:16:59 <chrisdone> DataType {tycon = "Data.Void.Void", datarep = AlgRep [Void]}
09:17:06 <chrisdone> legit
09:17:42 <lpaste> chrisdone pasted “Data.Generate” at http://lpaste.net/110936
09:18:28 <chrisdone> Twey: my use-case is to generate values from from HSE's AST, a la quickcheck's generation, but without having to write much code
09:22:19 * hackagebot HarmTrace-Base 1.1.0.1 - Parsing and unambiguously representing musical chords.  http://hackage.haskell.org/package/HarmTrace-Base-1.1.0.1 (JosePedroMagalhaes)
09:27:18 <SwashBuckla> How do I join up all of the False probabilities in [(False,1 % 40),(False,9 % 40),(False,1 % 40),(False,9 % 40),(False,1 % 40),(False,9 % 40),(False,1 % 40),(True,9 % 40)] ?
09:27:38 <SwashBuckla> http://stackoverflow.com/questions/15190429/specializing-bind-for-monads-over-special-typeclasses-in-haskell
09:27:51 <dhrosa> (False, 40 % 100)
09:27:57 <dhrosa> err not quite
09:28:05 <SwashBuckla> there is a True
09:28:37 <SwashBuckla> and I want to be able to do this automatically, i.e. the Monad knows to do this
09:28:53 <Intolerable> add a monoid instance for whatever type ur using
09:29:02 <SwashBuckla> and define mconcat?
09:29:05 <SwashBuckla> ah
09:29:12 <SwashBuckla> I KNEW IT (well, kinda)
09:29:16 <Intolerable> no just define adding two probabilities
09:29:24 <Intolerable> and ur mconcat will do it for u
09:29:34 <Intolerable> (ofc if u have a more efficient way define that)
09:30:03 <simpson> :t foldr
09:30:04 <lambdabot> (a -> b -> b) -> b -> [a] -> b
09:30:28 <simpson> :t \(b, x) acc -> if b then acc + x else acc
09:30:29 <lambdabot> Num a => (Bool, a) -> a -> a
09:30:37 <SwashBuckla> thanks Intolerable
09:30:53 <simpson> :t foldr (\(b, x) acc -> if b then acc + x else acc) (0 % 1)
09:30:53 <lambdabot> Integral a => [(Bool, Ratio a)] -> Ratio a
09:31:02 <simpson> SwashBuckla: ^^^
09:31:02 <Intolerable> isnt there an arrow for that
09:31:17 <SwashBuckla> stop!
09:31:23 * SwashBuckla looks away
09:32:01 <simpson> Huh? I'm just answering your original question.
09:32:35 <Twey> > sum $ filter (not . fst) [(False,1 % 40),(False,9 % 40),(False,1 % 40),(False,9 % 40),(False,1 % 40),(False,9 % 40),(False,1 % 40),(True,9 % 40)]
09:32:37 <lambdabot>  No instance for (GHC.Show.Show a0)
09:32:37 <lambdabot>    arising from a use of ‘M59754990327338502212021.show_M59754990327338502212...
09:32:37 <lambdabot>  The type variable ‘a0’ is ambiguous
09:32:37 <lambdabot>  Note: there are several potential instances:
09:32:37 <lambdabot>    instance [safe] GHC.Show.Show
09:32:40 <Twey> Oops
09:32:48 <Twey> > sum . map snd $ filter (not . fst) [(False,1 % 40),(False,9 % 40),(False,1 % 40),(False,9 % 40),(False,1 % 40),(False,9 % 40),(False,1 % 40),(True,9 % 40)]
09:32:50 <lambdabot>  31 % 40
09:33:42 <Intolerable> Map.insertWith would work too
09:34:06 <ClaudiusMaximus> or Map.fromListWith
09:34:35 <spopejoy> Language question. I want a word to describe how (<*>) "looks like" ($). Reaching for "isomorphic" but feeling like that's not it.
09:34:37 <ClaudiusMaximus> > M.fromListWith (+) [(False,1 % 40),(False,9 % 40),(False,1 % 40),(False,9 % 40),(False,1 % 40),(False,9 % 40),(False,1 % 40),(True,9 % 40)]
09:34:39 <lambdabot>  fromList [(False,31 % 40),(True,9 % 40)]
09:34:44 <spopejoy> :t <*>
09:34:45 <lambdabot> parse error on input ‘<*>’
09:34:51 <spopejoy> :t (<*>)
09:34:52 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
09:34:57 <spopejoy> :t ($)
09:34:58 <lambdabot> (a -> b) -> a -> b
09:35:04 <Twey> :t liftA2 ($)
09:35:05 <lambdabot> Applicative f => f (b -> c) -> f b -> f c
09:35:08 <Intolerable> :t toList . M.fromListWith (+)
09:35:09 <lambdabot>     Not in scope: ‘toList’
09:35:09 <lambdabot>     Perhaps you meant one of these:
09:35:09 <lambdabot>       ‘F.toList’ (imported from Data.Foldable),
09:35:16 <Intolerable> :t M.toList . M.fromListWith (+)
09:35:17 <lambdabot> (Ord k, Num a) => [(k, a)] -> [(k, a)]
09:35:28 <Twey> spopejoy: (<*>) is an applicative ‘lifting’ of ($)?
09:35:30 <glguy> spopejoy: You could call it "lifted"
09:35:30 <Intolerable> :i Bool
09:35:41 <Twey> SwashBuckla: As a more elegant solution, you probably want to define some sort of ‘odds’ number type
09:36:27 <dhrosa> Intolerable: http://lpaste.net/110938 This is part of my parser, this tries to parse a char literal from a C-like language
09:36:38 <spopejoy> "lifted" is accurate. Just isn't very latinate/greek :)
09:36:45 <spopejoy> thx
09:36:45 <dhrosa> Intolerable: I have an "unexpected" token, because this project requires that we continue lexing even if there's a lexing error
09:36:48 <albeit> If I have a folder Graph, how can I structure it so that when I "import Graph" it imports the "main" file there? Right now I have Graph/Graph.hs, and "import Graph.Graph", but seems redundant
09:37:11 <dhrosa> hmm wait
09:37:15 <dhrosa> this is not enough to show the problem
09:37:20 * hackagebot FComp 1.0.1 - Compose music  http://hackage.haskell.org/package/FComp-1.0.1 (JosePedroMagalhaes)
09:37:24 <geekosaur> albeit, that's a non-thing
09:37:45 <geekosaur> `import Graph` imports Graph.hs, it ignores a directory Graph regardless of what files are in it
09:38:20 <monochrom> consider having both folder Graph and file Graph.hs, and re-exports
09:41:05 <albeit> monochrom: So Graph.hs would be in the main project directory, and it would import Graph/(files) and them rexport? So other programs would just "import Graph"?
09:41:20 <monochrom> yes
09:41:26 <albeit> Gotcha, thanks
09:41:37 <dhrosa> Intolerable: http://lpaste.net/8809367211341774848 This is the entire file, this is the lexer for compiling a C-like language. The project requires that the program continue lexing, even if there's an error, so there's an "unexpected" token that can be parsed
09:42:35 <dhrosa> Intolerable: when I feed the input "'\p'" and then a newline to the tokens parser, it should reject it as an invalid escaped char literal, by returning an "unexpected p" token
09:42:54 <dhrosa> but instead my "unexpected" alternative parser is never called, and parsec reaches the top with a ParseError
09:43:14 <Intolerable> honestly my first thought is "put a bunch more labels in it"
09:44:03 <NemesisD> hey guys i've been told about an obscure cabal feature. in foo.cabal i've got library foo, and test suite test. test depends on foo, but i can't actually test foo because all of its dependencies are hidden
09:44:27 <NemesisD> i've been told cabal does or used to have a feature that if a library coud be resolved to the same cabal file that it would drag in/union its dependencies with the ones you explicitly write
09:44:45 <NemesisD> i want to avoid copying a large dependency list into my test suite's dependencies and thus have 2 pieces of info that can go out of sync
09:44:52 <glguy> Yes, you can have the test suite depend on the library. Make sure your test suite and library are not sharing source directories
09:45:31 <dhrosa> Intolerable: where? every top-level parser is labeled inside the tokens parser
09:45:42 <NemesisD> glguy, they are in different source dirs, but the issue is that ghc/cabal hide's all the dependencies that the lib references
09:45:45 <dhrosa> do I need to label each of the sub-parsers, like oneOf and char too
09:45:45 <dhrosa> ?
09:45:57 <Intolerable> i usually just label EVERYTHING tbh if something goes wrong
09:46:16 <glguy> NemesisD: That's only an issue if your test code references those modules directly. If your tests *do* use some of those modules then the test must explicitly depend on them
09:46:20 <NemesisD> glguy, i.e. if foo depends on time, in order to get the test suite to run, i have to add "time" to the library dependencies *and* the test suite dependencies
09:46:31 <Intolerable> like add a <?> "whatever" to each of ur definitions
09:46:39 <glguy> You'll only need to add time to the tests if the code in the tests also use the time module directly
09:46:41 <chrisdone> NemesisD: that sounds like a classic case of sharing the src dirs
09:46:52 <Intolerable> ill take a look at it but im gonna be without internet for a few hours most likely
09:47:01 <dhrosa> oh I think I just understood where the error comes from
09:47:13 <chrisdone> test-suite should have hs-source-dirs: tests/ or w/e, rather than src/
09:47:18 <glguy> NemesisD: If you have your source directories overlapping you'll create this kind of problem
09:47:21 <NemesisD> ahhh
09:47:40 <Intolerable> dhrosa: see, labels are magical ;)
09:48:00 <NemesisD> oh man what a wonderfully simple fix. thanks glguy, chrisdone. this was a *huge* problem for me
09:48:11 <dhrosa> Intolerable: the labels on my top-level parsers didn't help for some reason
09:48:17 <chrisdone> np. tripped me up for a while too
09:48:19 <monochrom> print : debugging programs :: label : debugging parsers
09:48:51 <dhrosa> the charLiteral parses consumes the ', the \, then sees a p,  returns an unexpected token. Then it interprets the second ' as the opening to another char literal :/
09:48:56 <dhrosa> I hate this project
09:48:59 <Intolerable> dhrosa: i find adding them to everything helps immensely in working out where my parsers are going wrong
09:49:08 <dhrosa> mostlybecause our error messages have to match EXACTLY what ANTLR would put out
09:49:11 <Intolerable> not just the top level tokens
09:49:18 <Intolerable> but every parser i define
09:49:22 <dhrosa> and we have to keep lexing if there's an error
09:49:28 <Intolerable> that sounds awful
09:49:31 <dhrosa> which produces ambiguous bullshit like this
09:50:00 <dhrosa> how is it obvious that '\p' should only produce one error for the p, and consume the second char too :/
09:50:15 <dhrosa> lexiing bad input is meaningless
09:50:20 <dhrosa> I should complain to the professor
09:50:33 <Intolerable> if in doubt, complain
09:50:39 <rom1504> yes
09:50:41 <Intolerable> thats just good general advice
09:50:56 <cite-reader> Fun troll: teach the first half of your compilers course in SML, then the second half in Java.
09:51:03 <rom1504> but then you'll be Intolerable
09:51:03 * cite-reader shakes his fist at his old professor.
09:51:12 <dhrosa> i'm taking a class on compilers, they offer us java scala and haskell as options for the compiler
09:51:21 <dhrosa> BUT, they're test suites basically assume you're using ANTLR
09:51:27 <Intolerable> rom1504: only the fourth shitty joke about "intolerable" today
09:51:31 <dhrosa> and your errors must match exactly where ANTLR would
09:51:39 <rom1504> Intolerable: you're welcome :D
09:52:02 <monochrom> there is a notion of recovery from parse errors. but it is much more sophisticated than "just continue". and it is in active research.
09:52:28 <dhrosa> the problem is there's plenty of arbitrary choices for where to continue lexing frmo in case of an error
09:52:41 <dhrosa> and it's annoying to make it match ANTLR's choices exactly..
09:52:49 <Intolerable> heres my arbitrary choice: dont. immediately die
09:52:57 <monochrom> is ANTLR formally specified?
09:52:57 <dhrosa> I want to do that
09:56:37 <monochrom> perhaps the prof is on to "the language syntax treats lex errors as comments"
09:58:08 <cite-reader> Or. Maybe it's preparation for parsing HTML. Because any stream of bytes is a well-defined HTML 5 document. For reasons.
10:02:28 <wz1000> I am planning to write a daemon which listens for certain network communication. It will spawn a lot of child processes, with a lot of concurrent open connections. Is Haskell well suited for this kind of work?
10:03:53 <davidthomas> wz1000: basically yes, although better if "child processes" are not actually a design requirement
10:04:35 <davidthomas> wz1000: because Haskell's M:N threads are very nice for concurrency
10:05:26 <albeit> If I have a parameterized datatype "Foo a", and a must implement a specific typeclass, do I specify that in the datatype and/or in all functions that use Foo?
10:06:54 <Cale> albeit: Usually the functions that use Foo
10:07:31 <albeit> Cale: And can each function only specify that classes it requires for that function, or will they have to specify all?
10:07:50 <Cale> The specific ones
10:08:10 <wz1000> Also, how portable are binaries compiled with GHC? Is it feasible to distribute binaries for systems like Windows? I would not like to have GHC as a dependency.
10:08:20 <albeit> Cale: Thanks
10:10:44 <sm> wz1000: it is doable, if you stick to pure haskell libraries
10:10:48 <Cale> wz1000: You shouldn't need GHC on the machine. Compile things statically though.
10:11:27 <phaazon> edwardk: hey, I’ve found a few libs of yours missing their hackage documentations :(
10:11:45 <dhrosa> What's a good way of catching a parse error in Parsec, getting the source position at that point, and continuing to attempt parsing? My attempts to insert an "unexpected" token into the stream by adding parsers everywhere is getting unreasonable fast
10:11:46 <edwardk> phaazon: i've yet to go figure out what the arcane process is for uploading new docs
10:11:49 <dhrosa> and is hard to get 100% coverage with'
10:11:56 <dhrosa> and unfortunately I have to try to continue parsing
10:12:06 <davidthomas> wz1000: I regularly build Haskell on one system and deploy on another - haven't tried that with Windows personally, though
10:12:22 <phaazon> arcane process?
10:13:44 <wz1000> Anything I should keep in mind when writing cross platform network code?
10:14:18 <tommd> Test in on more than one platform?
10:14:46 <thoughtpolice> wz1000: if you're using Windows, distributing .exe files produced by GHC should be easy; just copy them. if your windows program links to any external DLLs (say, written in C, like 'sdl' or something), then you'll need to bundle those
10:15:00 <thoughtpolice> but otherwise there aren't any external dependencies (the situation is obviously slightly different on Linux)
10:15:01 <sm> dhrosa: http://hub.darcs.net/simon/shelltestrunner/browse/Utils/Debug.hs#70
10:15:45 <sm> oh I misunderstood your question, but you might find it useful anyway
10:16:59 <sm> usage example: http://hub.darcs.net/simon/shelltestrunner/browse/Parse.hs#31
10:20:59 <albeit> Cale: Is it possible to specify all the necessary class instances in the datatype declaration, so I don't need to go through every function and specify specific classes?
10:23:14 <Cale> albeit: Using new extensions, it's possible to somewhat reduce the number of classes you'll need in some contexts, while increasing it in others.
10:23:40 <Cale> albeit: Not in standard Haskell though.
10:24:44 <syllogismos> l
10:24:49 <Cale> albeit: In standard Haskell, you can put a class context on your data declaration, but this just makes it so that the data constructors are constrained by the type classes, so wherever you use the data constructor, you'll need to add an appropriate class context
10:25:09 <merijn> Cale: Actually, you can't :)
10:25:15 <Cale> (assuming that you're using it polymorphically)
10:25:29 <merijn> Cale: DatatypeContexts is not in Haskell2010, therefore it is *not* standard haskell anymore :)
10:25:34 <Cale> ah
10:25:49 <merijn> It was removed because they were bloody stupid :)
10:25:52 <Cale> Probably a good thing
10:25:55 <Cale> yeah
10:26:54 <syllogismos> I forgot about (:) operator and neither hoogle nor hayoo return it when I searched for a -> [a] -> [a]
10:31:09 <albeit> If I want a wrapper over say, Int, is it best to do "data Price = Price Int" and implement Ord,Eq,Show,Read,Num, etc... for Price? Or is there a better way?
10:32:05 <hexagoxel> newtype?
10:32:25 <Cale> Yeah, that's what newtype (and newtype deriving) are for
10:33:10 <merijn> syllogismos: I think hoogle only searches functions, not data constructors?
10:33:13 <chrisdone> -XGeneralizedNewtypeDeriving newtype Albeit = Albeit Int deriving (Ord,Eq,Show)
10:33:28 <merijn> chrisdone: That doesn't need GeneralizedNewtypeDeriving
10:33:45 <merijn> You only need that for deriving non-derivable classes
10:33:53 <albeit> Ah so I can derive what I want to be the same for Int, then for other classes I want to be differnet I can implement my own instances?
10:34:00 <merijn> albeit: Yes
10:34:18 <albeit> Ah perfect, thansk
10:34:31 <chrisdone> merijn: true. but sooner or later you will want to derive a class that isn't magic
10:35:11 <albeit> Ah, "Num" is not a derivable class, so guess I need to use that extension
10:35:19 <chrisdone> =)
10:35:30 * chrisdone polishes his crystal ball
10:37:36 <chrisdone> albeit: although instances for some of the magic classes like Show and Read will be different from the instance for the original type. so show (Albeit 1) /= show 1. something to be aware of
10:37:59 <albeit> Okay
10:41:09 <RyanGlScott> Does bindings-DSL have a mechanism for wrapping C functions that expect struct arguments instead of struct pointer arguments?
10:41:45 <RyanGlScott> e.g., int func(struct_t t) couldn't have an FFI import directly, you'd have to make a wrapper function int func_wrap(struct *t) first
10:45:24 <luite> is there an easy way to get haskell-mode/ghc-mod to search haddock docs for the package i'm working on + deps?
10:45:58 <sagittarian> luite, yes
10:46:20 <chrisdone> @google haskell codex
10:46:21 <lambdabot> https://hackage.haskell.org/package/codex
10:46:43 <chrisdone> hm, codex doesn't quite do that
10:51:23 <lpaste> chrisdone pasted “@ luite” at http://lpaste.net/110939
10:52:18 <lpaste> chrisdone annotated “@ luite” with “--modules” at http://lpaste.net/110939#a110940
10:52:50 <chrisdone> luite: maybe you can cabal install your project and then use haskell-docs to search it and its dependencies
10:53:09 <chrisdone> not sure whether i implemented sandbox support
10:53:10 * chrisdone checks
10:54:22 <chrisdone> luite: anyway, haskell-docs does work for you, you can run M-x haskell-describe foo RET and it will open a *Help* buffer a la C-h f
10:54:40 <luite> chrisdone: ok sounds good, i'll install it
10:55:20 <luite> finally getting close to a properly working emacs again, without my broken customizations from years ago :)
10:55:25 <chrisdone> hehe
10:56:20 <luite> i'm not quite brave enough to try structured-haskell-mode yet though
10:57:41 <chrisdone> seems that sandboxes are possible with haskell-docs https://github.com/chrisdone/haskell-docs/pull/9 manually, but i'd like to make it automatic. have some code to do that lying around
10:57:43 <chrisdone> luite: few are =p
10:58:18 <chrisdone> luite: might be of interest https://github.com/chrisdone/hindent
10:59:04 <luite> chrisdone: can haskell-docs be sped up by ghc-server?
10:59:15 <chrisdone> that'd be my plan
11:00:28 <chrisdone> rather than reading in interface files every time, just open them once and build an index. the --modules flag uses an index, but the general search doesn't
11:00:36 <Fuuzetsu> I should steal structured mode for Yi later
11:00:48 <luite> some small buffer that automatically shows the docs for the thing at cursor would be useful :)
11:00:49 <chrisdone> i had some trouble with it, but it later turned out that my local docs for the default apt-get install were shafted
11:01:05 <chrisdone> luite: indeed. like SLIME
11:01:52 <chrisdone> Fuuzetsu: \o/
11:02:12 <Fuuzetsu> Soon™
11:02:18 <Fuuzetsu> currently porting to Text
11:02:19 <chrisdone> slowly the wheel of haskell tooling progress turns
11:02:30 <chrisdone> ah is it currently all Stringy?
11:02:46 <chrisdone> does yi predate the text package?
11:02:52 <alpounet> yeah
11:02:58 <chrisdone> nod
11:03:00 <Fuuzetsu> we previously used a rope on top of bytestring + strings for everything else and we took a hit on conversions
11:03:17 <Fuuzetsu> Yi predates a lot of packages ;/
11:04:42 <luite> i hope to do some backpack experiments soon. something where Text can be exchanged with JSString without typeclasses everywhere would be a great help for making Haskell webscale for GHCJS
11:05:14 <Fuuzetsu> I wonder how well backpack will work in practice
11:05:32 <alpounet> chirpsalot: afaict from the commit history, it dates back to 2004
11:05:35 <luite> Fuuzetsu: if it doesn't work well it should be fixed :)
11:05:50 <chirpsalot> alpounet: what does?
11:06:02 <alpounet> woops
11:06:07 <alpounet> that was meant for chrisdone
11:06:10 <alpounet> sorry
11:06:22 <chirpsalot> Ah ;)
11:06:27 <alpounet> (we were talking about the Yi editor)
11:06:36 <luite> Fuuzetsu: it sounds like it might get a bit messy, who maintains module definitions for what. and i don't think there's a good solution for orphans yet
11:06:38 <Fuuzetsu> AFAIK it was started 2003ish but I'm unsure
11:07:30 <luite> Fuuzetsu: but even then i really really really want the pluggable implementation functionality :)
11:08:04 <luite> feels much more attractive than patching the actual text package
11:08:19 <chrisdone> luite: is that referring to functionality like ML functors?
11:08:33 <merijn> chrisdone: Similar-ish
11:09:00 <chrisdone> yeah, something like that would be helpful sometimes
11:09:06 <merijn> chrisdone: http://blog.ezyang.com/2014/08/a-taste-of-cabalized-backpack/
11:09:50 <chrisdone> i like ezyang's blog theme. it reminds me of someone else's ;)
11:11:17 <luite> chrisdone: it's been compared to that, although i don't know the exact differences. i haven't actually tried to use it yet, but from his blog posts and HiW talk it sounded exactly like what i need :)
11:11:56 <luite> although HiW was the last day of a sleep-deprived ICFP week, dunno how good my critical thinking was at the time
11:14:49 <merijn> chrisdone: Also, as part of the project ezyang is working on allowing GHC to compile binaries with multiple different versions of the same library :)
11:15:10 <chrisdone> D:
11:15:11 <chrisdone> want
11:15:16 <luite> merijn: which gives you funky version numbers in the haddocks :)
11:15:41 <chrisdone> luite: you mean haddocks of libraries produced with multiple versions of depdenencies?
11:16:00 <luite> i'm pretty sure that multiple versions already worked, but that multiple instances of the same version is being added now
11:16:28 <chrisdone> hm. last time i tried to do that, it worked for some libraries, not others
11:16:37 <chrisdone> bytestring nope, parsec maybe
11:16:53 <chrisdone> but that was about 5 years ago when cabal hell wasn't even called cabal hell
11:17:13 <luite> chrisdone: it uses a package key instead of version+id now, and i don't think haddock has been updated yet to handle them nicely
11:17:35 <merijn> luite: No
11:17:44 <merijn> luite: You could have multiple versions *installed*
11:17:50 <merijn> luite: Not compiled into the same program
11:18:04 <merijn> i.e. program depends on libraries A and B
11:18:12 <dfsdfsdfs> Is there a way to share data between functions, which are not connected to each other?
11:18:16 <chrisdone> merijn: i think i've done that in the past transitively
11:18:22 <merijn> A depends on C version 1 and B depends on C version 2
11:18:23 <Fuuzetsu> luite: there is a patch for that on ghc-head branch
11:18:25 <luite> merijn: cabal would warn you about that, but symbols are already versioned
11:18:41 <merijn> luite: I tried that in the past and it didn't work?
11:18:43 <luite> merijn: but only with the package version number, so multiple instances of the same version would clash
11:18:43 <chrisdone> the cabal message used to be "library X and Y depend on two versions of the same library. proceeding is dangerous" or whatever
11:18:46 <silver> http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
11:18:49 <merijn> dfsdfsdfs: You're going to have more specific
11:19:01 <dfsdfsdfs> merijn: sure, trying to come up with a example
11:19:35 <luite> merijn: it was unreliable, but if something used ByteString internally and never exposed it, and the rest of your program used a different ByteString version, then it could work
11:21:08 <glguy> dfsdfsdfs: You can't have a private scope defined across multiple definitions
11:21:58 <glguy> without nesting it all under some other definition
11:22:14 <dfsdfsdfs> glguy, merijn: I need something like that http://dpaste.com/1NDPRHS.txt  Is there a trick that could help me?
11:22:45 <dfsdfsdfs> glguy: That's what I thought.  Unfortunate.
11:23:30 <chrisdone> dfsdfsdfs: you could do something evil
11:23:31 <chrisdone> like
11:23:39 <dfsdfsdfs> I don't want mutability though
11:23:41 <dfsdfsdfs> chrisdone: ^
11:23:51 <chrisdone> (foo,bar) = (foo',bar') where
11:23:51 <chrisdone>  foo' = …
11:23:51 <chrisdone>  bar' = …
11:23:51 <chrisdone>  f x = …
11:24:19 <dspies> does anyone here use eclipsefp?
11:24:35 <chrisdone> mutation is for the masses
11:24:49 <dfsdfsdfs> That's not going to work for the task at hand since foo and bar can be far away from each other.
11:25:07 <dfsdfsdfs> chrisdone: perhaps I should explain what I'm trying to do.
11:25:19 <chrisdone> worth a shot
11:27:12 <dfsdfsdfs> basically, I want to define the memoize function that would be as easy to use as in languages with mutability.  So I could write foo x = {...} memoize f x {...}; bar x = {...} memoize f x {...}.  The straightforward way to do it in other langauges is to define a dictionary as a global variable and mutate that, but it's not going to work in Haskell.
11:27:28 <luite> chrisdone: do you happen to know how to change the window background color for a theme but leave the rest the same?
11:29:09 <chrisdone> luite: nope
11:29:14 <dfsdfsdfs> chrisdone: We could avoid the global variable by returning the dictionary with the result, but it's not going to work anyway due to the thing mentioned by glguy.
11:30:38 <dfsdfsdfs> It should be possible if you want to do it inside a single function, like: foo x = ... memoize f x ... memoize f x ... but that's not what I want.
11:31:27 <dfsdfsdfs> So I wonder whether metaprogramming could help.  Probably not.
11:31:31 <chrisdone> dfsdfsdfs: i think this is a well-trodden topic. there'll be something on the wiki
11:32:02 <chrisdone> http://www.haskell.org/haskellwiki/Memoization http://stackoverflow.com/questions/141650/how-do-you-make-a-generic-memoize-function-in-haskell
11:32:21 <Intolerable> can u not just dump it all into Data.Dynamic and use unsafePerformIO
11:32:25 <Intolerable> fuck the type system
11:32:59 <hnoob> in LYAH Writer is claimed to be defined thusly:      newtype Writer w a = Writer { runWriter :: (a, w) }
11:33:06 <hnoob> but really its this:  type Writer w = WriterT w Identity
11:33:14 <hnoob> did this change since LYAH was written?
11:33:32 <chrisdone> Intolerable: Straight Outta Python?
11:33:58 <Intolerable> lol
11:34:10 <Intolerable> maybe get some nasty "decorators" going w/ th as well
11:34:16 <dfsdfsdfs> chrisdone: all the solutions I've found do it inside a single function, but I want to find a way to share the resuls.
11:34:43 <luite> chrisdone: and for haskell-describe, do you happen to have a macro that sets the default value to the word under the cursor? (but editable in the minibuffer)
11:34:57 <chrisdone> luite: yeah, hold up
11:35:11 <phaazon> god
11:35:12 <jophish> dfsdfsdfs, for dynamic programming solutions, often what I do is pass in an array representing the table of results to the function and return that array, and use fix to populate it
11:35:14 <chrisdone> luite: haskell-ident-at-point
11:35:22 <phaazon> I’m trying to help fixing semigroups’ documentation
11:35:24 <phaazon> https://hackage.haskell.org/package/semigroups-0.15.3
11:35:35 <phaazon> we HAD to change the cronie haddock job
11:35:43 <phaazon> we don’t have any feedback information on what’s going on
11:35:47 <phaazon> it’s really annoying :(
11:36:00 <phaazon> in local I just get a weird warning about Data.Monoid’s documentation
11:36:21 <chrisdone> luite: https://github.com/haskell/haskell-mode/commit/14f705ec8c8909c0fcad635ed09fef605db3984a
11:36:42 <bergey> Is the reports feature of Hackage broken, or is Hackage way behind on building docs in general?
11:36:52 <dfsdfsdfs> jophish: I haven't used fix much, but I'm not sure it'd help.  You'd still need to share the array between functions.  Could you show an example?
11:37:04 <chrisdone> bergey: it seems to have stopped working this week
11:37:05 <luite> chrisdone: hehe thanks, that was fast
11:37:27 <chrisdone> np
11:37:45 <jophish> dfsdfsdfs, this does have a local scope, so perhaps not exactly what you're looking for
11:38:16 <luite> i guess i'll need to switch to the git version now, i hope i'll be able to resist the temptation to contribute
11:38:17 <bergey> I'll plan on uploading all my docs manually, then.
11:38:30 <jophish> are you certain that your calculation is actually getting run more than once
11:38:39 <phaazon> ok, thank you for the feedback
11:39:20 <dfsdfsdfs> jophish: But couldn't template haskell help?  I'm not familiar with it at all.  And could it be still counted as memoization, not preprocessing?
11:39:23 <jophish> whenever a value is evaluated its thunk is replaced by a pointer to its value
11:41:03 <jophish> dfsdfsdfs, have you looked at this: http://hackage.haskell.org/package/memoize
11:43:51 <dfsdfsdfs> jophish: I've seen it, but I doubt it solves the problem, which is scope-related basically.
11:44:35 <monochrom> what scope relation do you want? f local to foo and to bar?
11:44:38 <jophish> Perhaps you could try it out. If it doesn't work for you this sounds like a good question for stackoverflow
11:44:55 <monochrom> must f be really that local?
11:45:24 <monochrom> i.e., must f be invisible to everything other than foo and bar?
11:45:33 <dfsdfsdfs> monochrom: No.
11:45:45 <monochrom> then memoize f, simply.
11:45:53 <jophish> having said that, if there don't exist any solutions to your problem you may want to reconsider what you want. If nobody has run into this before then perhaps there is a better way of thinking about it
11:46:14 <dfsdfsdfs> jophish: I gather.  Think of it as an exercise.
11:47:04 <imalsogreg> in a package w/ lots of other-modules, I'm trying to let the testsuite build-depends on the library, without including the library source in the test suit's hs-source-dirs (so I can avoid mentioning whether each library module is exposed- or other- for a second time in the test-suite section of the cabal file). But this effectively hides those internal modules from the test suite :( and from hpc. Anyone know a workaround?
11:47:34 <dfsdfsdfs> monochrom: Could you provide an example, please?  Here's the problem: http://dpaste.com/1NDPRHS.txt  I may want to get the memoized f in some other function later.
11:47:41 <Intolerable> the workaround is "only test ur public api"
11:48:31 <jophish> dfsdfsdfs, you could pass in (f x) to foo and bar instead of or alongside x
11:48:49 <imalsogreg> Intolerable: Gah, that's too bad.  Thanks!
11:49:19 <monochrom> suppose f was "f 0 = True; f x = f (x - 1)". then using package "memoize", f is now written "f = memoFix helper where {helper self 0 = True; helper self x = self (x-1)}
11:49:19 <dfsdfsdfs> jophish: hehe, I don't want that because f is an expensive computation.  I don't want to recompute it that's the point.
11:49:38 <jophish> 'Lazy evaluation'
11:49:55 <dfsdfsdfs> jophish: Lazy evaluation what?
11:50:07 <dfsdfsdfs> How is it relevant I mean?
11:50:19 <Intolerable> imalsogreg: if u really need to test ur private stuff, u might want to take another look at whether they need to be exposed or not
11:50:21 <jophish> it won't be evaluated unless you need it
11:50:41 <dfsdfsdfs> jophish: Right, but I'll need it two times, and it'll be evaluated two times as well.
11:50:59 <Intolerable> typically ur modules will be hidden if theyre prone to instability
11:51:38 <dfsdfsdfs> jophish: But I want that computation to be evaluated once for the same input.
11:52:09 <imalsogreg> Intolerable: : Ok. I'm not sure if that's the case here. I'm working on someone else's library, where they like to have 100% test coverage.
11:53:00 <dfsdfsdfs> monochrom: Thanks for the example, I'll try to understand the API before asking further questions.
11:53:09 <jophish> dfsdfsdfs, http://ideone.com/eKY1Nr
11:53:17 <jophish> "expensive computation" is only printed once
11:54:38 <monochrom> dfsdfsdfs: in general, rewriting definitions until you can use "fix". see my http://www.vex.net/~trebla/haskell/fix.xhtml for how. then, simplify replace "fix" by "memoFix". that's how to use memoFix, and that's all there is.
11:55:41 <dfsdfsdfs> jophish: that's different.  you're able to do that because both foo and bar are invoked in main where fx is already bound.  I don't want to have them in the same function, but I still need to share the result.
11:55:42 <jophish> monochrom's solution is probably nicest
11:55:49 <jophish> and I have a lunch date, so bye!
11:55:54 <dfsdfsdfs> jophish: Thanks for your time anyway.
11:56:26 <jophish> no problem, I hope it works out
11:56:39 <dfsdfsdfs> monochrom: will take a look, thanks.
11:57:48 <Intolerable> is there a term for two functions that recurse on eachother?
11:57:58 <Hafydd> Mutually recursive.
11:58:28 <Intolerable> ty
11:58:52 <Intolerable> i initially went for "corecursive" but its obviously not
11:59:03 <monochrom> a flame war is a mutually recursive conversation :)
11:59:16 <hopnotch> clojure people call it trampoline
11:59:26 <monochrom> IIRC "corecursive" may mean the same thing
11:59:30 <cite-reader> Trampolining is an implementation detail.
11:59:47 <hopnotch> it still sounds more fun
11:59:52 <cite-reader> True.
11:59:53 <iXeno> so, I need a newer "binary" package than what I can't, but I can't seem to be able to do that...
11:59:57 <Intolerable> can't u do some form of tco w/ trampolining?
11:59:59 <iXeno> so halp
12:00:30 <monochrom> yes, trampolining is one way to translate tail calls
12:00:38 <Intolerable> iXeno are u working from a sandbox
12:02:48 <iXeno> Intolerable: maybe, I swapped projects so much I don't remember...
12:02:53 <iXeno> how do I check?
12:03:19 <iXeno> now I am
12:03:20 <hopnotch> i'm reading this arrows introduction, and it defines >>> for normal functions and it's Kleisli type where each is defined for both arguments in the same instance, but the result still works across and i don't understand why.
12:03:43 <Intolerable> iXeno if u just created a sandbox try installing it now
12:10:46 <hopnotch> nope. misunderstood what was happening. nvm.
12:15:37 <LunarJetman> iXeno: it's a bug hunt.
12:28:17 <joshkirklin> what library could I use to get information about modules, in particular what they export?
12:30:28 <monochrom> in ghci, :browse Module_Name_Here helps
12:32:46 <joshkirklin> I'd like to be able to access the information directly from inside haskell code. Do you know of a package that exposes that functionality?
12:33:27 <geekosaur> haskell doesn't really do introspection
12:34:08 <nyuszika7h> why does platform.sh restart the build from scratch eveey time? >_>
12:34:22 <mzero> it shouldn't
12:34:23 <joshkirklin> not even to inspect the modules available in the current cabal environment?
12:35:32 <nyuszika7h> *every
12:35:39 <joshkirklin> let me clarify: I don't want to be able to inspect modules available at build time. I want to build something that can inspect modules available in any given environment.
12:35:46 <mzero> joshkirklin: you want the ghc-api module
12:36:09 <geekosaur> and/or the Cabal module
12:36:18 <mzero> nyuszika7h: are you altering the build tree in anyway between runs?
12:36:31 <nyuszika7h> no, I'm just installing build dependencies
12:36:33 <mzero> Cabal won't tell you about what a module exports
12:36:42 <nyuszika7h> with zypper
12:36:48 <joshkirklin> mzero, geekosaur, thanks, I'll check those out
12:37:07 <mzero> nyuszika7h: the build dependencies of hptool?
12:37:17 <nyuszika7h> I guess so
12:37:38 <nyuszika7h> I did "zypper si -d haskell-platform" now though
12:37:42 <mzero> okay - well, once hptool is built -then the rest of the platform shouldn't require restart from the top if you stop and restart it
12:37:47 <mzero> I don't know what is zypper
12:38:00 <nyuszika7h> openSUSE's package manager
12:38:07 <nyuszika7h> zypper si -d is like apt-get build-del
12:38:09 <nyuszika7h> *dep
12:38:31 <mzero> hmmm.... I've no idea how or who packaged the platform for openSUSE -
12:39:38 <nyuszika7h> I didn't install the whole platform, only ghc, cabal, hscolour, haddock, and other necessary things
12:39:48 <nyuszika7h> I'm trying to compile a newer version
12:39:59 <nyuszika7h> it didn't error again yet...
12:41:15 <merijn> Why are you trying to compile platform?
12:41:49 <nyuszika7h> because openSUSE comes with the 2013 version
12:42:09 <nyuszika7h> and the bindist doesn't work on it
12:42:25 <mzero> nyuszika7h: ah - you have an older GHC, etc... and you want the newer? did you start with the source of HP from github, or the source tarball for the platform?
12:42:33 <mzero> and you will need the bindist for GHC 7.8.3
12:42:42 <nyuszika7h> I have the GHC bindist and source tarball
12:43:13 <nyuszika7h> I think the problem is I didn't install the whole platform package in the first place, only ghc, cabal-install, haddock, hscolour, etc.
12:43:19 <merijn> nyuszika7h: So, install that, download and install cabal-install and call it a day?
12:43:29 <nyuszika7h> but now I installed haskell-platform's dependencies so it should work
12:43:33 <nyuszika7h> still compiling...
12:43:39 <merijn> nyuszika7h: Platform is really not meant as a "build it yourself"-thing
12:43:47 <mzero> okay - expect it to take ~1 hour on a modern machine
12:43:49 <merijn> It's meant for packaging the entire platform for distributors
12:44:35 <mzero> true - but too many distros are well behind, and people want to be newer, hence they build it themselves.... I'm endevouring to make it easier to build ---
12:44:56 <mzero> this latest HP is MUCH easier to build that the preivous ones were!
12:45:03 <mzero> though it does have more prerequisites
12:45:20 <monochrom> (fan letter) I already use your binary tarball for Haskell Platform!
12:45:24 <merijn> mzero: Sure, but if you're gonna build stuff yourself does the platform really offer all that much over just installing GHC+cabal and installing stuff by hand?
12:45:38 <nyuszika7h> would be nice if I wouldn't need all those GL libraries on a headless server but oh well
12:46:20 <davidthomas> Is there a semantic reason why GHC generates calls to fail for exhaustive bindings, or is it just an implementation detail?
12:47:07 <mzero> merijn: well, building some of the bits are tricky - and the HP sort of sets up everything to some sort of sane default
12:47:11 <monochrom> hmm, is that true?
12:47:23 <mzero> nyuszika7h: we have plans to fix that in the next release!
12:47:28 <nyuszika7h> mzero: :)
12:47:42 * hackagebot ghc-mod 5.1.0.0 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-5.1.0.0 (DanielG)
12:47:45 <nyuszika7h> build is done
12:47:58 <mzero> ah - you have a ncie beefy machine!
12:48:27 <nyuszika7h> http://ivanmiljenovic.wordpress.com/2010/03/15/repeat-after-me-cabal-is-not-a-package-manager/
12:48:28 <nyuszika7h> er
12:48:30 <nyuszika7h> wrong paste
12:48:48 <nyuszika7h> model name      : Intel(R) Xeon(R) CPU E5-1650 v2 @ 3.50GHz
12:48:55 <nyuszika7h> it's an openvz container, 4 cores
12:49:12 <nyuszika7h> I compiled with -j5
12:49:13 <luite> hmm all my haskell-mode hooks don't run anymore after switching from the haskell-mode package
12:49:18 <luite> to the git repo
12:49:28 <napping> mzero: what are you building? I'd say HP is nice for getting C dependencies on windows
12:50:04 <napping> nyuszika7h: a recent cabal will pick a decent default -j
12:50:41 <mzero> napping: ? I'm the release manager for HP - and I do the offical Mac builds as well
12:50:41 <nyuszika7h> I updated cabal-install to 1.20 with itself because 1.16 didn't have a sandbox and HP wouldn't build
12:50:50 <nyuszika7h> good to know
12:50:55 <napping> mzero: ah, never used a mac
12:51:46 * iXeno kinda wonders why people choose to publish on APress
12:51:56 <iXeno> less bureacracy? less strategic road blocks?
12:52:42 * hackagebot hsimport 0.6 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.6 (DanielTrstenjak)
12:53:06 <S11001001> iXeno: for a while I thought they'd be the next o'reilly, what with the really nice Practical Common Lisp.  Ah well
12:53:58 <iXeno> I'm going through Beginning Haskell now... I love the book, but the amount of typos also is consistent with my impression of APress as a publisher who don't do QA
12:54:10 <nyuszika7h> \o/
12:54:10 <Hodapp> ahh, Apress...
12:54:13 <nyuszika7h> nyuszika7h@nevorn ~ > ghc --version
12:54:13 <merijn> mzero: And I <3 you for the mac platform :)
12:54:14 <nyuszika7h> The Glorious Glasgow Haskell Compilation System, version 7.8.3
12:54:29 <iXeno> the worst I had was that Lift book though... that was horrible... references to appendixes that didn't exist and just a horrible mess all over
12:54:30 <Hodapp> They ran a deal once where all textbooks were $10 or something like that.
12:54:43 <Hodapp> and I went to town on their Springer textbooks that were normally $100-$200.
12:55:06 <S11001001> Hodapp: every year they have a day where every ebook is about that much; seen it for a couple years anyway
12:55:14 <S11001001> days?  maybe
12:55:31 <Hodapp> S11001001: last year they did not have Springer textbooks under this deal.
12:55:32 <iXeno> S11001001: btw, Manning is the new O'Reilly
12:55:50 <mzero> merijn: welcome!
12:55:51 <hopnotch> i keep buying beta books on manning
12:55:53 <S11001001> iXeno: yeah I noticed that.  But PCL came out before the Manning thing happened
12:56:13 <S11001001> iXeno: I feel like Manning is sure doing a better job of it than O'Reilly ever did.
12:56:22 <iXeno> S11001001: I agree
12:57:37 <S11001001> I mean, I'm glad Marlow found a nice home at O'Reilly and all, but such incidences seem to be rare these days
12:57:40 <iXeno> and then you have Pragmatic Programmers - which is the Udacity of computer books
12:58:06 <S11001001> iXeno: what does that mean?
12:58:38 <S11001001> iXeno: (tbh I'm not a fan of pragprog)
12:58:45 <iXeno> udacity started as an online university, but quickly decided that they didn't wanna weed out people, so they just lowered the bar so that *everyone* would do great... so it just dropped to way below high school level
12:59:17 <iXeno> I signed up for a udacity class on physics, and they just plainly stated - with no reservations or whatever - that G was 10...
13:00:04 <iXeno> S11001001: Pragmatic Programmers had one good book (The Pragmatic Programmer) and the rest are pretty crap...
13:00:15 <hopnotch> they didn't say where they were recording, maybe it was true? :)
13:00:15 <iXeno> except Practical Vim - that one is worth getting
13:00:33 <doismellburning> iXeno: I've worked with enough astronomers to know that, hey, it's the right order of magnitude, it's exactly thr same number :P
13:00:49 <iXeno> :)
13:01:34 <iXeno> yeah, that works on all the 10 flat planets of our solar system :)
13:01:40 <doismellburning> ;)
13:04:26 <luite> iXeno: if they said that, the bigger problem would've been confusing G and g, rather than simplifying the numbers for exercises
13:04:51 <iXeno> it could have been g :)
13:05:21 <iXeno> anyway, I signed up for their compiler class too, just to have some fun... it was the most worthless class ever...
13:05:40 <iXeno> unless you just wanted to exercise some simple python
13:06:16 <luite> iXeno: well clearly you can blame being sloppy on your education now ;)
13:06:31 <iXeno> :)
13:07:12 <iXeno> yeah, well... I started by doing AI Class (the one that started this whole mooc thing) - and that was a great class - but still oh so sloppy
13:07:36 <iXeno> the one with Thrun & Norvig
13:10:47 <hopnotch> so what are good non-sloppy offerings?
13:14:52 <iXeno>  hopnotch: few of them are non-sloppy, but my preference is coursera. edx is good if you can stand the horrible interfaces
13:15:50 <hopnotch> but good courses in particular?
13:16:05 <iXeno> but when I took the coursera/stanford cryptography class, they managed to send out a diploma after where I had like 67 out of 66 homework assignments correct,  got a 2/3 score on home assignments for skipping the optional ones... and well... first edition lacked my name...
13:16:54 <iXeno> hopnotch: depends on what you're after...  the crypto one was good. If you're into it, the "computer architecture" one is good (it's about modern CPU architecture)
13:17:04 <iXeno> but many other I liked
13:17:07 <iXeno> the Machine Learning one
13:17:12 <iXeno> lemme check
13:18:03 <iXeno> you have principles of reactive programming (scala)
13:18:10 <hopnotch> i did that one
13:18:17 <exio4> the only course I really "did", was "Programming languages" (proglang) in coursera
13:18:43 <iXeno> exio4: that one was also decent
13:18:51 <iXeno> automata is good
13:19:01 <iXeno> and introduction to logic
13:19:08 <hopnotch> how introductory is that?
13:19:22 <dfeuer> I don't get it. There's a note in GHC.List about the HBC version of (!!), saying that the semantics are not quite the same for error conditions as the prelude version. Could someone explain the difference? They look the same to me.
13:20:09 <iXeno> hopnotch: well, propositional, relational, induction and such...
13:20:55 <iXeno> it's a quick course, so worth the investment if you're shaky...
13:21:21 <iXeno> there are some ok calculus courses
13:21:40 <iXeno> and World History since 1300 was good
13:21:47 <shapr> I misread that as calculus corpses....
13:22:08 <shapr> death from brain overload?
13:22:16 <shapr> man killed in math lab explosion?
13:22:23 * shapr goes back to coding
13:23:35 <luite> <- too, my emacs is awesome now so i only have myself to blame for distractions from now on :)
13:24:15 <iXeno> https://www.coursera.org/course/comparch - I signed up, looked pretty good but wasn't a good prio for me at the time so I unsigned again
13:24:39 <zenguine> luite: care to share your .emacs?
13:26:46 <luite> zenguine: it's mostly this setup https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md
13:27:22 <zenguine> aye gotcha, I've stolen a fair bit from that too hah
13:27:31 <zenguine> finally made me switch to company-mode
13:28:04 <dfeuer> Anyone have a clue about that (!!) note?
13:28:05 <luite> zenguine: with the latest commit by chrisdone to default haskell-describe to the ident at point
13:28:56 <zenguine> haskell-describe?
13:29:23 <luite> zenguine: yeah, it uses haskell-doc to find info about a name
13:29:37 <luite> it's somewhat sluggish, but really useful
13:30:22 <zenguine> how does it differ from ghc-show-info or haskell-process-do-info?
13:30:28 <luite> zenguine: i've added icicles and magit to the things from that tutorial. any other useful packages i should knwo about
13:31:09 <luite> zenguine: it searches docs and displays haddock
13:31:24 <zenguine> ah cool
13:31:27 <Haskellfant> luite: does it find the docs if those packages are installed into a sandbox?
13:31:49 <Haskellfant> so far i haven't managed to get this working with anything (i haven't tried very hard)
13:32:14 <luite> Haskellfant: dunno, my current project is not in a sandbox. ask chrisdone :)
13:32:22 <Haskellfant> k :)
13:32:33 <zenguine> luite: my .emacs is full of a bunch of stuff. not sure if you asking about haskell specific stuff or just general cool emacs things.  but you can look here: https://github.com/phenguin/dotfiles
13:32:47 <luite> zenguine: general
13:33:03 <zenguine> luite: there is alot, you'd have to ask a more specific question
13:34:03 <luite> zenguine: oh i don't have any specific question, just want to browse :)
13:35:25 <zenguine> luite: okay.  have at it :)
13:42:47 * hackagebot bytestring-conversion 0.2.1 - Type-classes to convert values to and from ByteString.  http://hackage.haskell.org/package/bytestring-conversion-0.2.1 (ToralfWittner)
13:51:03 <hasnokell> Hey guys i've just started to learn haskell, i'm kinda stuck, i want to make a function that takes an array and calculates the sum of the array. Here is my code : https://gist.github.com/d555453a6019ddb8e2ae
13:51:15 <hasnokell> how do i find out if an argument is a non-empty list
13:52:11 <kadoban> hasnokell: Just as a matter of terminology, those are lists, not arrays (haskell also has arrays, but they work differently)
13:52:25 <hasnokell> i'm sorry, i'm kinda.. new
13:52:33 <mauke> a list is either [] (empty list) or x : xs (where x is the first element and xs is another list)
13:52:40 <kadoban> hasnokell: No need to apologize. You have kind of the right idea, but a little confused too
13:52:48 * hackagebot swagger 0.2.1 - Implementation of swagger data model  http://hackage.haskell.org/package/swagger-0.2.1 (ToralfWittner)
13:53:16 <hasnokell> mauke, i already had that working, but i wanted to try it out with 'head'
13:53:28 <mauke> why?
13:53:42 <kadoban> hasnokell: pattern matching is a good way, but what you probably want on line 3 is: sumarr (l:ls) = l + sumarr ls
13:53:48 <merijn> head is a terrible function >.>
13:53:53 <oisin123> What's the easiest way for me to access via FFI Assimp's C++ functions from Haskell? (There don't seem to be any bindings for it that are completed so I'll have to create my own.)
13:53:53 <mauke> well, you could do something like: sumarr [] = 0; sumarr l = head l + sumarr (tail l)
13:53:53 <hasnokell> oh..
13:53:56 <exio4> then you need to check "head", "tail" and "null"
13:54:00 <ski> hasnokell : `sumarr (l:) = ...' is bad syntax. perhaps you wanted to say `sumarr l = ...' or `sumarr l | not (null l) = ...' or `sumarr (n:l) = ...' ?
13:54:30 <merijn> oisin123: FFI only does C, so have C bindings for the relevant C++ stuff and call those from haskell
13:54:46 <hasnokell> this one works.. https://gist.github.com/c7df1ebb34f859466364
13:55:02 <hasnokell> so i should stay away from head and tail?
13:55:06 <mauke> hasnokell: unlikely
13:55:16 <mauke> that looks like a type error or three
13:55:29 <oisin123> merijn: So write a C wrapper and then generate using h2... something?
13:55:39 <hasnokell> yeah , sorry about that, i didnt coppy it correctly
13:55:41 <hasnokell> mine works
13:56:43 <kadoban> head and tail should be avoided where you can i'd say. Non-total functions (ones that bomb out on some inputs) are troublesome. You have to be very careful calling them or you end up with errors down the road.
13:56:48 <mauke> sumlist = sum
13:56:51 <merijn> oisin123: Depends does the code you wanna call use structs, etc. that you need to access on the haskell side?
13:56:54 * mauke <- expert haskell programmer
13:57:02 <kadoban> mauke wins
13:57:04 <oisin123> merijn: All over the place, yes.
13:57:05 <hasnokell> this one works
13:57:05 <hasnokell> https://gist.github.com/870c0ec6930cd9740f21
13:57:10 <sipa> :t sumlist
13:57:11 <lambdabot> Not in scope: ‘sumlist’
13:57:22 <exio4> :t foldr1 (+)
13:57:23 <lambdabot> Num a => [a] -> a
13:57:24 <ski> kadoban : aka "partial functions"
13:57:29 <kadoban> ya, thanks
13:57:35 <merijn> oisin123: Ok, then you'll need to use something like c2hsc, etc. to generate Storable instances for those structs
13:57:55 <merijn> oisin123: (Note, that's only really need if haskell needs to modify/read those structs)
13:58:37 <hasnokell> i really like how haskell looks and makes you think about what you will write, although i don't know anything about haskell, i am certainly interested in learning it. Are there any really good books out there?
13:58:45 <hasnokell> i've heard about learn you a haskell for the greater good..
13:58:51 <merijn> @where lyah
13:58:52 <lambdabot> http://www.learnyouahaskell.com/
13:58:54 <merijn> @where rwh
13:58:54 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
13:59:05 <oisin123> merijn: It's an file format reader so I think so - I don't see another way. So, the process looks like: C++ .h files -> C wrapper -> c2hsc -> calling the generated .hs files?
13:59:06 <merijn> I heard Bird's book is pretty good, but that's not online, afaik
13:59:32 <hasnokell> bookmarked those
13:59:48 <merijn> oisin123: Pretty much.
13:59:57 <oisin123> merijn: Thanks :)
14:00:00 <kadoban> I learned the basics by alternating between those two when I got stuck/bored and it seemed to work out pretty well
14:00:15 <hasnokell> are there any cool things i can check out that are mainly written in haskell
14:00:32 <fgc> hasnokell: this course is also pretty good: http://www.seas.upenn.edu/~cis194/spring13/lectures.html
14:00:36 <kadoban> http://exercism.io is nice for learning some basic style, pretty helpful people on there
14:01:11 <zenguine> hasnokell: The XMonad window manager is an example people usually give
14:02:12 <rqiu> test
14:02:14 <merijn> Xmonad, pandoc, ghc
14:02:18 <hasnokell> is there any difference between Data.Text and String?
14:02:28 <Intolerable> yes
14:02:37 <Intolerable> use Text unless you have a specific reason not to
14:02:38 <merijn> hasnokell: Yes, String is a linked list of characters, Data.Text is densely packed text
14:02:52 <Fuuzetsu> hasnokell: Text is the holyshitsofast one
14:02:58 <Fuuzetsu> String is shit son what are you doing one
14:02:59 <hasnokell> i see
14:03:11 <hasnokell> so never use string?
14:03:13 <kadoban> String is usually only good for playing around, it's quite slow when you want to get real work done. But it's fine for practicing
14:03:16 <mauke> String is nicer to use in many cases
14:03:20 <Fuuzetsu> I would not say never
14:03:23 <rqiu> *Main> let a = [[1,2,3], ['a', 'b']]
14:03:23 <rqiu> <interactive>:25:11:
14:03:23 <rqiu>     No instance for (Num Char) arising from the literal ‘1’
14:03:23 <Fuuzetsu> many libraries only take string
14:03:25 <rqiu>     In the expression: 1
14:03:27 <rqiu>     In the expression: [1, 2, 3]
14:03:29 <rqiu>     In the expression: [[1, 2, 3], ['a', 'b']]
14:03:39 <rqiu> but it works fine in Scala
14:03:41 <Fuuzetsu> if you're working with text rather than each separate character then use Text
14:03:54 <rqiu> scala> val a = List(List(1,2,3), List('a','b'))
14:03:54 <rqiu> a: List[List[AnyVal]] = List(List(1, 2, 3), List(a, b))
14:04:07 <Intolerable> in scala it unifies to AnyVal
14:04:18 <merijn> rqiu: Don't paste more than 1-2 lines of text in the channel
14:04:26 <rqiu> sorry
14:04:35 <Intolerable> that's not particularly helpfully typed
14:04:35 <Ptival> is there a Haskell parser generator with EBNF support? :\
14:04:35 <rqiu> newbie here
14:04:47 <merijn> rqiu: Scala is using the fact that all objects subclass AnyVal (I'm guessing)
14:04:54 <rqiu> correct
14:04:59 <merijn> rqiu: Haskell has no inheritance, therefore there is no valid type for your list
14:05:06 <rqiu> but sometimes it is convenient to do it
14:05:20 <merijn> rqiu: Lists of characters are not lists of integers, therefore you can't mix them in a single list
14:05:22 <rqiu> i guess i need to do type class
14:05:31 <exio4> datatype*?
14:05:32 <merijn> No, typeclasses don't help
14:05:41 <exio4> I don't really see how a typeclass could be useful
14:05:46 <merijn> You'll want something like "[Either [Int] [Char]]"
14:06:13 <kadoban> It really depends what the actual goal is too...
14:06:15 <merijn> :t [Left [1,2,3,4], Right ['a','b','c']]
14:06:16 <lambdabot> Num t => [Either [t] [Char]]
14:06:22 <rqiu> instead of using the built-in list [], use a different typeclass
14:06:30 <merijn> List is not a typeclass
14:06:50 <kadoban> Perhaps you want a tuple?
14:07:04 <merijn> rqiu: The word typeclass has absolutely 0 in common with any notion of class that you may have from Scala or any OO language
14:07:07 <kadoban> :t ([1,2,3], ['a', 'b', 'c'])
14:07:08 <lambdabot> Num t => ([t], [Char])
14:07:41 <rqiu> the return results are put in a list, where i need to do pattern-matching on, the type is not determined
14:07:47 <exio4> @let SList a b = ACons a (SList a b) | BCons b (SList a b) | Nil
14:07:47 <lambdabot>  Parse failed: Parse error: |
14:07:50 * hackagebot hplayground 0.1.0.5 - a client-side haskell framework that compiles to javascript with the haste compiler  http://hackage.haskell.org/package/hplayground-0.1.0.5 (AlbertoCorona)
14:07:52 * hackagebot wai-predicates 0.8.3 - WAI request predicates  http://hackage.haskell.org/package/wai-predicates-0.8.3 (ToralfWittner)
14:07:54 <geekosaur> you can;t pattern match to discriminate types
14:07:59 <mauke> rqiu: you can't do pattern matching if the type is unknown
14:08:03 <exio4> @let data SList a b = ACons a (SList a b) | BCons b (SList a b) | Nil
14:08:06 <lambdabot>  Defined.
14:08:18 <mauke> [Either a b]
14:08:22 <merijn> exio4: Needs more GADT + DataKinds :)
14:08:23 <rqiu> the types are from a known list of types
14:08:51 <geekosaur> data MyValue = MyInt Int | MyChar Char | ...
14:08:59 <geekosaur> and pattern match the constructor?
14:09:23 <rqiu> geekosaur, yes, probably this is the right solution
14:09:48 <rqiu> in Scala, i will just need to pattern match on the case class/object
14:10:04 <merijn> rqiu: Right, because Scala is object-oriented
14:10:22 <merijn> rqiu: You can't match on the type of a value in Haskell, because types don't exist at runtime
14:10:23 <mauke> s/object-oriented/weird/
14:10:23 <kadoban> rqiu: Is there a particular problem you're trying to solve with this? Perhaps we could point out the nice way to do it in haskell if so.
14:10:41 <merijn> mauke: Those two are not mutually exclusive :)
14:11:04 <exio4> I'd say "object-oriented" => weird
14:11:07 <rqiu> i think i need to pre-define the data types then match on constructors
14:12:37 <rqiu> the objective is to dynamically match the return result type, and decide how to process the result.
14:13:08 <mauke> you can't match types
14:13:35 <rqiu> pattern matching on ADT constructors will be the solution, i guess
14:13:52 <Intolerable1> just run it through Data.Dynamic
14:13:59 <Intolerable1> (REALLY don't do that)
14:14:02 <merijn> Intolerable1: Not helping
14:14:15 <rqiu> one data type for all the result types but with different constructors
14:14:23 <exio4> anyway, what are you really trying to do?
14:14:27 <merijn> Intolerable1: Making such jokes to confused newbies only confuses them more and it's even all that funny
14:14:50 <S11001001> rqiu: In essence, in Haskell, you *have* to follow the Scalazzi Safe Scala Subset rules.  That means no runtime type casing.
14:14:55 <kadoban> rqiu: You kind of didn't really describe the goal, just backed off one step in how you're trying to achieve it.
14:14:57 <S11001001> rqiu: yes
14:15:14 <S11001001> rqiu: also, maybe add a type parameter.
14:15:22 <wyager> Hello all. I would like to try GUI programming in haskell, just for fun. Apparently FRP is the hip new thing for GUI programming. Can anyone recommend a good (set of) libraries to try this out?
14:15:31 <fizbin> Anyone good with Debug.Trace.trace? In general, if I say (trace "a" a `seq` trace "b" b `seq` trace "c" c `seq` trace "d" d), and observe a long delay after the "b" is printed, does that mean it's taking a long time to compute b or to compute c?
14:15:56 <merijn> fizbin: The evaluation order of seq is not specified
14:16:07 <Intolerable1> wyager: take a look at gloss-banana
14:16:13 <wyager> fizbin: `seq` is not guaranteed to fully evaluate the thing
14:16:23 <shachaf> GHC is allowed to reörder those.
14:16:38 <shachaf> Look at the generated code or something to be sure. Or use `pseq`, which gives you a stronger guarantee.
14:16:39 <wyager> fizbin: You may want to use `force` as well, which forces full evaluation
14:16:45 <wyager> Intolerable1: Thanks
14:17:17 <shachaf> Don't use force or deepSeq or any of those things if you can help it. :-(
14:17:23 <wyager> ^^ best advice
14:17:32 <wyager> Performance in Haskell is weird
14:17:39 <rqiu> data ReturnResult a = ResultType1 a | ResultType2 a
14:17:53 <wyager> I wrote a bit of actor code a while back. Adding a single putStrLn to my program sped it up over 5x
14:17:54 <shachaf> wyager: That was a quick change of mind.
14:17:56 <rqiu> matchResult :: ReturnResult -> IO ()
14:18:10 <wyager> shachaf: I assumed he couldn’t help it. No change of mind there :)
14:18:10 <rqiu> matchResult ResultType1 a = do something
14:18:24 <rqiu> matchResult ResultType2 a = do something else
14:18:36 <rqiu> matchResult ResultType2 a = do something else
14:18:44 <fizbin> So, there's no way to use Debug.Trace.trace to guess which of several things is taking the surprising amount of time to evaluate?
14:18:48 <shachaf> You can always help it.
14:19:18 <shachaf> fizbin: There are plenty of ways. I mentioned one above.
14:19:19 <wyager> fizbin: I usually just make each thing I’m trying to benchmark the entire program. e.g. “main = putStrLn $ show $ <slow thing>"
14:19:36 <mauke> putStrLn . show = print
14:19:45 <wyager> The assumption is that show forces full evaluation
14:20:17 <shachaf> "full evaluation" is not the issue here.
14:20:22 <shachaf> There's no reason to bring it up.
14:20:23 <fizbin> Unfortunately, it's in the middle of a large function, and pulling that to the top level is going to be painful.
14:20:59 <wyager> shachaf: Yes, it is. You won’t get an accurate idea of how much time something takes if you only evaluate it to WHNF when you mean to check the evaluation time of the whole thing
14:22:21 <shachaf> But fizbin is already "observing a long delay".
14:22:26 <fizbin> Wait, is seq special with re-ordering? Why would GHC be allowed to re-order (a `seq` b `seq` c)
14:22:36 <merijn> fizbin: seq doesn't specify ordering
14:22:46 <shachaf> NFData is a last resort.
14:22:51 * hackagebot wai-routing 0.11 - Declarative routing for WAI.  http://hackage.haskell.org/package/wai-routing-0.11 (ToralfWittner)
14:22:56 <sm> why are you seq'ing ?
14:23:08 <merijn> fizbin: seq may evaluate in order, "a, b, c", "a, c, b", "b, a, c", "b, c, a" or any other variation
14:23:17 <shachaf> fizbin: The only promise seq makes is that (_|_ `seq` x) = _|_; (_ `seq` x) = x
14:23:19 <merijn> fizbin: Hell, it may even evaluate them in parallel or random order
14:23:27 <merijn> shachaf: Well, that's not the only promise
14:23:32 <shachaf> But in (x `seq` y) GHC can force y then x if it wants to.
14:23:47 <fizbin> It may. Is that, in practice, what actually happens?
14:24:00 <shachaf> Sometimes.
14:24:09 <wyager> shachaf: The important thing is that you want to fully evaluate your slow thing without being confused about when it happens. That’s why show is useful.
14:24:17 <merijn> shachaf: It also promises that "IF x and y are not bottom THEN after evaluating "x `seq` y" x and y will be evaluated" :)
14:24:57 <napping> fizbin: pseq is provided specifically to guarantee order, it's not worth worrying whether GHC happens not to often use the freedom it reserves for seq
14:24:59 <shachaf> merijn: I don't think the Report talks about "evaluated" things at all.
14:25:09 <shachaf> wyager: Whatever. I'll stop talking about it now.
14:26:58 * fizbin does some more tests and concludes that the answer to his initial question was b
14:27:38 <shachaf> The answer to your initial question is "who knows". :-)
14:32:51 * hackagebot tinylog 0.10.5 - Simplistic logging using fast-logger.  http://hackage.haskell.org/package/tinylog-0.10.5 (ToralfWittner)
14:37:35 <ski> fizbin,merijn : it may even evaluate `a' after some other evaluation after `b', in `seq a b' ..
14:37:52 * hackagebot redis-resp 0.3.1 - REdis Serialization Protocol (RESP) implementation.  http://hackage.haskell.org/package/redis-resp-0.3.1 (ToralfWittner)
14:40:23 <holo> hi
14:41:27 <holo> is there a book that covers all the mathematic fundamentals needed for financial programmers?
14:41:30 <ski> fizbin : strictness analysis may show that some subexpression must always be evaluated when the larger containing expression is evaluated. in such case an implementation could e.g. choose to evaluate that subexpression prior to when it would naively be evaluated. it could also possibly reorder individual (required) subcomputations of that subexpression
14:41:53 <Ptival> so... no EBNF parser generator in Haskell? :(
14:42:08 <`^_^v> what kind of financial programming?
14:42:20 <`^_^v> it ranges from "a 12 year old can do the math" to "you need a phd"
14:42:43 <kadoban> Ptival: Do you need one? That kind of thing is pretty natural to do in Parsec, unless I'm missing something (always possible)
14:42:49 <dfsdfsdfs> holo: there is definitely none that covers ALL the fundamentals
14:42:50 <napping> Ptival: what about bnfc?
14:43:05 <holo> `^_^v, hold on a sec. thanks
14:43:17 <ski> Ptival : perhaps <http://bnfc.digitalgrammars.com/> would be interesting
14:43:24 <holo> oh my, i should activate nick auto-complete
14:44:04 <ski> @botsmack
14:44:37 <Ptival> kadoban: hmmm parser combinators are a pain in my humble experience
14:45:03 <kadoban> Fair enough. I kinda like them, but then I don't parse things very often.
14:45:15 <Ptival> napping: let me look into that, basically anything that doesn't require me to manually expand iteration and option patterns would be great
14:45:17 <earthy> 4
14:47:03 <Ptival> I'm using Happy right now but I feel dumb every time I have to write something like (a |
14:47:08 <Ptival> (a | b)+
14:47:33 <ski> Ptival : BNFc can generate Happy and Alex
14:47:41 <holo> haha, do you guys sport at hard to reproduce nicknames
14:47:41 <napping> kadoban: happy is a perfectly good BNF parser generator
14:48:14 <Ptival> it ends up looking like P1 := a P2 | b P2, P2 := {- empty -} | a P2 | b P2
14:48:30 <ski> @where bnfc
14:48:38 <lambdabot> BNF Converter, http://bnfc.digitalgrammars.com/
14:48:38 <Ptival> for sufficiently complex and b it requires a lot of indirection or redundancy
14:48:39 <ski> there we go ..
14:49:00 <ski> Ptival : *nod*, left-recursion elimination
14:49:17 <napping> kadoban: I assumed the E in ENBF was there for a reason
14:49:36 <Ptival> ski: thanks, I'll look into that
14:49:48 <Ptival> napping: thanks too :)
14:50:22 <Fuuzetsu> Text docs don't say concat is subject to fusion while append is; should I prefer x `append` y `append` z over concat [x, y, z], performance wise?
14:51:09 <holo1> `^_^v, dfsdfsdfs: almost copy pasting job ad requirements: Trade life cycle; Risk management; pricing; structuring; P&L/Risk calculations; structured/derivates product. this is what I need to know just for one business
14:52:44 <Ptival> kadoban: I like parser combinators for simple things yeah. I had bad experience parsing something more than a toy though, maybe because I am stupid though :)
14:52:53 * hackagebot redis-io 0.3.1 - Yet another redis client.  http://hackage.haskell.org/package/redis-io-0.3.1 (ToralfWittner)
14:53:21 <merijn> Ptival: You can write efficient parser combinator parsers, they require careful thought, though
14:53:24 <kadoban> Hehe, I could see that being possible. I've done some things that were non-toy, but they weren't terribly complicated either so they worked out okay.
14:53:30 <merijn> Ptival: And parsec is not really good at it
14:53:46 <Ptival> efficiency was not so much of a concern
14:54:04 <merijn> attoparsec with it's direct slicing for Text/ByteString is pretty good, but you should avoid writing parsers that end up backtracking
14:54:07 <Ptival> I remember having to think very carefully about try/backtracking issues
14:54:09 <ski> Fuuzetsu : `build'/`foldr'-fusion ?
14:54:16 <ski> oh, `Text'
14:54:37 <Fuuzetsu> right
14:54:54 <merijn> Ptival: Attoparsec doesn't have try, so it's just backtracking you need to think of ;)
14:55:10 <merijn> Well, it has "try" for compatibility with parsec, but try is a no-op
14:55:48 <ski> backtracking isn't very complicated. `try' (and committing disjunction) is
14:56:26 <merijn> Hence why attoparsec > parsec ;)
14:56:31 <dfsdfsdfs> monochrom: still around?
14:57:41 <wyager> What should I use to send messages from a single thread to many other threads?
14:57:49 <holo1> dfsdfsdfs: hey, did you see my list? sorry, my connection broke some minutes ago
14:57:50 <wyager> Every thread has to get every message
14:57:59 <merijn> wyager: Chan + dupChan?
14:58:28 <merijn> Speaking of which, I got 0 response to my newBroadcastChan proposal :(
14:58:44 <merijn> I'll just file a ticket and try to sneak it in without discussion
14:58:49 <wyager> Thanks. And reading from a dup’d chan won’t remove the broadcasted data from other chans?
14:59:08 <merijn> wyager: No, see docs
14:59:57 <napping> merijn: what was the proposal?
15:00:15 <merijn> napping: "let's add newBroadcastChan" :
15:00:17 <merijn> :p
15:00:29 <napping> how is a Chan not already suitable for broadcasting?
15:00:38 <merijn> napping: Space leak if you never read the original
15:01:01 <napping> oh, hmm
15:01:07 <napping> is there any way to fix that currently?
15:01:10 <merijn> napping: Suppose I have a Chan that I write to and spawn X threads that all dupChan and read from the duplicates, the write end is never emptied
15:01:18 <dfsdfsdfs> holo1: yeah, I've seen it, but I don't want to add: there'll never be such a thing as the book containing all the information you may need.  you have to search around.  even if it contains enough information (for now), some chapters may be poorly written, etc.  so, find multiple sources and read the ones you like, that it.  stopping chatting offtopic.
15:01:37 <merijn> napping: And since the write end keeps it's own read-end alive you leak space, which makes me sad :(
15:01:43 <dfsdfsdfs> I don't know what to add*
15:01:57 <monochrom> dfsdfsdfs: hello
15:02:06 <napping> yeah, but you need to keep the read end until you have passed it on to other threads
15:02:13 <merijn> no
15:02:21 <merijn> dupChan only duplicates the write end
15:02:28 <jophish> dfsdfsdfs, Did you find a solution to your woes?
15:02:37 <dfsdfsdfs> jophish: still struggling
15:02:45 <merijn> dupChan doesn't preserve history, a dupChan channel only receives values written *after* the dupChan
15:03:09 <Fuuzetsu> is there a text version of regex-tdfa?
15:03:19 <Fuuzetsu> oh, of course, regex-tdfa-text
15:03:28 <merijn> napping: Weirdly enough TChan *does* have newBroadcastTChan to avoid the exact same leak
15:05:03 <holo1> dfsdfsdfs: I will follow your advice. thanks a lot!
15:05:15 <dfsdfsdfs> np
15:06:26 <dfsdfsdfs> monochrom: I've read your fix page.  But I'm still now sure how memoFix works.  In particular, will different functions calling the same memoized function be able to benefit from memoization?  For instance, if two toplevel functions call the memoized function with the same argument, will the second toplevel function need to recompute?
15:06:34 <dfsdfsdfs> s/now/not/
15:06:51 <monochrom> yes.
15:07:18 <napping> that all sounds good then
15:07:18 <monochrom> oh, two questions. yes, no.
15:07:38 <dfsdfsdfs> monochrom: oh, wow!
15:08:49 <monochrom> under the hood, memoFix uses a lazy binary search tree. this tree is infinite. lazy evaluation makes it finitely expanded at every finite point of time.
15:09:05 <dreams> is there a way to get the last element of a list without traversing the whole list?
15:09:29 <dfsdfsdfs> monochrom: but how does it share the tree between toplevel functions?
15:09:39 <mauke> dreams: not with ]
15:09:43 <mauke> dreams: not with []
15:09:51 <monochrom> ah, this is why you have to be careful when you use it.
15:09:55 <dreams> mauke: with what then
15:10:14 <monochrom> "f = memoFix blahblah" see the "f =" as opposed to "f x ="?
15:10:56 <monochrom> this ensures that there is only one tree, and it is attached to f itself. f is shared, therefore the tree is shared.
15:11:11 <mauke> dreams: an array, for example. or Seq
15:11:15 <dfsdfsdfs> dreams: look at the type of [] (with :i in ghci), you must examine the head to know what's inside since (:) is defined like so: a : [a]
15:11:28 <dreams> mauke: arrays are mutable?
15:12:04 <dfsdfsdfs> monochrom: so it's basically like passing a variable, right?
15:12:28 <monochrom> I don't entirely understand. I think the answer is yes.
15:12:30 <kadoban> dreams: It depends on the array type, there's several
15:12:49 <mauke> dreams: some are, some aren't
15:13:10 <monochrom> but you don't even pass f. you let f be stuck there globally, no? and the tree is attached to f, so the tree is also stuck there globally.
15:13:49 <monochrom> of course, only f sees the tree... but every "f xxx" will go through the tree, memoFix does that.
15:17:31 <dfsdfsdfs> monochrom: it generates a lazy bst, so you only compute what's necessary.  but in order to memoize, you'd have to know that you've already constructed the tree up to a certain point, otherwise you're basically recomputing again.  so how would you do that?  f is a toplevel variable that cannot be changed once it's defined.
15:17:39 <trap_exit> so template haskell basically takes strings, parses it, gets haskell code out of it, then passes it to ghc for compilation right? so besides (1) a slightly slower compile time and (2) slightly harder to read compile errors, are there any down sides to TH ?
15:18:11 <merijn> trap_exit: TH doesn't take strings, TH is a full-blown haskell code evaluated at compile time
15:18:25 <merijn> trap_exit: You're in no way required or restricted to use Strings
15:18:27 <trap_exit> merijn: yeah, but haskell expands "strings" to ahskell code, no ?
15:18:38 <trap_exit> merijn: what does TH expand to get haskll code?
15:18:44 <trap_exit> merijn: what is the input to TH ?
15:18:56 <merijn> TH doesn't require input
15:19:11 <trap_exit> merijn: wtf are you serious?
15:19:11 <merijn> You can do IO to get input, but that's not needed
15:19:20 <merijn> trap_exit: Why would it require input?
15:19:27 <dfsdfsdfs> monochrom: am I being clearl should I ask differently?
15:19:29 <monochrom> dfsdfsdfs: it does some sneaky thing. the actual tree depends on which arguments are encountered earlier!
15:19:32 <mauke> merijn: TH takes strings as input
15:19:33 <trap_exit> merijn: even macros have "input"
15:19:44 <trap_exit> merijn: macros = compile time expansion, where input = sexp,and output = sexp
15:19:47 <trap_exit> merijn : (in lisp)
15:19:49 <merijn> trap_exit: Template Haskell is literally "haskell code that generates haskell AST at compile time"
15:19:58 <trap_exit> merijn: it seems that any _transform_ must have some fortm of input
15:20:08 <merijn> mauke: QuasiQuoters take Strings as input, but not all TH is quasiquoters
15:20:11 <trap_exit> merijn: hmm, so you're telling me, TH can do something like "sftp to a server, pull a file, and use that as AST during compile time" ?
15:20:12 <mauke> merijn: source code is strings
15:20:24 <merijn> mauke: TH is not required to read in source
15:20:42 <merijn> trap_exit: Yes
15:21:01 <mauke> merijn: I'm not even sure how to respond to that
15:21:02 <trap_exit> merijn: there are days where I find your pedanticism annoying
15:21:03 <dfsdfsdfs> monochrom: could you elaborate?  how does it do that?  once I've defined x = 5 at the toplevel, I cannot do x = x + 1.
15:21:08 <trap_exit> merijn: today, I find your pedantic nature insightful
15:21:16 <mauke> that's like "a compiler is not required to read in source"
15:21:22 <trap_exit> mauke++
15:21:45 <trap_exit> mauke: I also don't get merijn's point about TH not using strings as input; but knowing that it can pull files from sftp and compile it is useful
15:21:49 <dfsdfsdfs> at icfp, spj mentioned two template haskells, which is which?
15:22:03 <merijn> mauke: How does TH require String as input?
15:22:14 <trap_exit> the one spj said good things about is the real one, the other one is false
15:22:21 <mauke> merijn: no
15:22:24 <merijn> People seem very adamant now, but most TH I wrote just took quasiquoted haskell as input
15:23:08 <merijn> trap_exit: You can use a quasi quoter that turns haskell code into a haskell AST and pass that to your TH functions
15:23:30 <trap_exit> hmm, can TM ge taccess to *.hs files being compiled ?
15:23:31 <merijn> trap_exit: That's how you'd normally modify haskell code, manipulate AST directly
15:23:39 <trap_exit> i.e. can I write TH code which is like "read, existing *.hs file, do shit with it, compile it"
15:23:47 <benzrf> i gotta say haskell seems kinda clunk for web work :i
15:23:51 <benzrf> *clunky
15:23:56 <mauke> trap_exit: sure
15:23:57 <merijn> trap_exit: You can query information from the file currently being compiled
15:24:09 <merijn> trap_exit: You can also read arbitrary .hs files if you know where to find them
15:24:19 <trap_exit> hmm
15:24:22 <merijn> I haven't done much of that sorta thing
15:24:24 <trap_exit> I need a bette runderstanding of TH
15:24:27 <trap_exit> how can I get this understanding
15:24:31 <trap_exit> what's a good tutorial to work through?
15:24:40 <merijn> trap_exit: TH can do anything Haskell can
15:24:43 <trap_exit> i feel my understanding is very superficial
15:24:46 <joelteon> trap_exit: the term is pedantry
15:24:55 <napping> The most commonly used TH things are probably functions like makeLenses
15:25:04 <trap_exit> joelteon: what are you, a SAT/GRE verbal tutor ?
15:25:05 <joelteon> Template Haskell is haskell code that runs at compile time
15:25:05 <napping> that just take a simple argument like a quoted type name and generate some code
15:25:10 <pqmodn> @pl (\_, b) -> (x, b)
15:25:11 <lambdabot> (line 1, column 7):
15:25:11 <lambdabot> unexpected ")"
15:25:11 <lambdabot> expecting letter or digit, operator, ",", pattern or "->"
15:25:13 <joelteon> thus it can perform any task that haskell can
15:25:18 <pqmodn> @pl \(_, b) -> (x, b)
15:25:19 <lambdabot> (,) x . snd
15:25:30 <dfsdfsdfs> napping: aeson instances as well
15:25:31 <trap_exit> yeah, but I bet there are clever black magic tricks that I have never thought about
15:25:34 <benzrf> pqmodn
15:25:38 <trap_exit> someone needs to write "TH blackmagic"
15:25:41 <benzrf> const x *** id
15:25:43 <merijn> trap_exit: There's a Q monad that is used to produce haskell ASTs and you can use the splice operator to splice that AST into the existing file
15:25:50 <pqmodn> benzrf: ah, thanks
15:25:50 <joelteon> (*** id) is "first"
15:25:57 <benzrf> j
15:26:05 <benzrf> joelteon: oh yeah
15:26:11 <benzrf> pqmodn: do what joelteon said?
15:26:16 <benzrf> first (const x)
15:26:37 <benzrf> >mfw first isnt over arbitrary bifunctors
15:27:29 <merijn> trap_exit: But since you can do IO in the Q monad and the functions used to generate AST are just haskell you can do anything you want
15:27:37 <dfsdfsdfs> monochrom: could you construct a concrete example please showing how the computation gets shared between toplevel functions?
15:30:49 <shachaf> If you were inventing a syntax for unboxed sums, what would it be?
15:30:58 <shachaf> Hmm, not a good time to ask a question.
15:31:03 <L8D_> @pl f x = print x >> return x
15:31:03 <lambdabot> f = liftM2 (>>) print return
15:31:15 <L8D_> @hoogle liftM2
15:31:17 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
15:31:21 <hpc> unboxed sum as in sum type?
15:32:03 <benzrf> L8D_: x <$ print x
15:32:13 <L8D_> benzrf: thanks?
15:32:17 <L8D_> @hoogle <$
15:32:17 <lambdabot> Data.Functor (<$) :: Functor f => a -> f b -> f a
15:32:17 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
15:32:17 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
15:32:24 <L8D_> ok
15:32:39 <benzrf> whoa lotsa nick changes
15:32:49 <L8D_> I have to do extra pattern matching anyways so I couldn't do that...
15:32:53 <hpc> benzrf: idents
15:33:01 <benzrf> hpc: ?
15:33:11 <L8D_> benzrf: nickserv restarted or something
15:33:17 <hpc> when you time out on ident it renames you to $nick\_
15:33:18 <benzrf> h
15:33:32 <zenguine> solar storm perhaps?
15:33:37 <shachaf> hpc: Yes.
15:33:51 <dolio> shachaf: InN# ?
15:33:56 <hpc> shachaf: there's the unboxed tuple syntax (# foo, bar #) iirc
15:34:10 <dolio> Actually, that's probably not good.
15:35:05 <shachaf> dolio: What do you mean?
15:35:21 <shachaf> hpc: I know there's that syntax. What would it look like for sums?
15:35:51 <hpc> oh derp, got product and sum mixed up
15:35:55 <shachaf> Maybe it's worth always thinking of a sum as a sum of products...
15:36:02 <dolio> N would be the number of the constructor you want.
15:36:03 <hpc> i don't think you can unbox a sum
15:36:08 <hpc> it'd be like an untagged union
15:36:19 <shachaf> dolio: Ah, so no special syntax. I suppose that's an option.
15:36:41 <shachaf> hpc: I want a tagged union.
15:37:01 <dolio> That one I just suggested has problems. It'd have to be overloaded, but it also can't be polymorphic, so you'd need annotations to use them.
15:37:16 <coppro> shachaf: Sum types are just Data Foo = Bar Int | Baz Char
15:37:17 <dolio> Unless you do InMofN#
15:37:29 <shachaf> coppro: I know what sum types are.
15:37:46 <coppro> shachaf: ok then I'm confused. whta's the original problem?
15:38:02 <shachaf> Unboxed sum types.
15:38:15 <shachaf> dolio: I wonder how big unboxed sums should be allowed to get.
15:38:25 <coppro> shachaf: ohhh. hmm
15:38:31 <coppro> iunno
15:38:41 <shachaf> dolio: It would be nice to turn even a large enum into an Int#
15:39:34 <dolio> Well, you could do that already. It's just kind of ad-hoc.
15:40:08 <shachaf> Sure. I'd like it to be a special case of unboxed sums in general.
15:40:33 <merijn> shachaf: I tried to argue for that for the FFI, but got shot down :\
15:40:41 <shachaf> merijn: ?
15:41:07 <merijn> shachaf: Having unboxed enum types where you can control the int every constructor maps too, for use with FFI
15:41:36 <merijn> I plan to fake it using TH and patterns as soon as TH supports patterns and we have exhaustiveness checks for patterns
15:41:46 <shachaf> That sounds pretty different from the sort of thing I'm talking about.
15:42:16 <merijn> shachaf: unboxed sum types are not how I originally proposed it, but they'd be good enough for what I want
15:42:45 <shachaf> Getting the FFI involved makes it rather different. This is only for representation internal to GHC.
15:43:56 <shachaf> Not good IRC weather for a conversation.
15:44:49 <ski> what's good IRC weather ?
15:45:02 <augur_> ski: what
15:45:15 <shachaf> Usually it has less join/part noise.
15:45:26 <augur_> oh
15:46:13 <merijn> Solution: hide joins/parts ;)
15:46:37 <ski> shachaf : btw, by "unboxed sum type", i'd mean something different :)
15:46:41 <shachaf> There's also the fact that everyone is parting and joining, irrespective of the noise.
15:46:45 <shachaf> ski: What would you mean?
15:47:58 * hackagebot peyotls 0.1.5.5 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.1.5.5 (YoshikuniJujo)
15:48:26 <coltfred> I was trying to build Haskakafka and I'm receiving errors when using cabalg. https://gist.github.com/coltfred/786a55ef4e332f184acf Has anyone tried to build this library?
15:50:40 <ski> shachaf : the continuation being unboxed
15:51:47 <shachaf> ski: Ah, I think you've talked about this before.
15:51:54 <shachaf> Can you explain in more detail?
15:52:02 <ski> e.g. as in "Multi-return function call" by Olin Shivers in 200[46] at <http://www.ccs.neu.edu/home/shivers/citations.html#mrlc>
15:52:49 <ski> "Multi-return Function Call example" <http://lpaste.net/13301> is how i imagine it might look as a Haskell extension
15:53:20 <ski> (oh, right, the paper was coauthored with David Fisher)
15:56:03 <ski> shachaf : the idea is that to implement `case recur lis of Left# g_0 -> ..g_0..; Right# () -> ...', you pass a *pair* of continuations (corresponding to the two `case' branches) to the `recur lis' call, which then will select one of them to return through
15:56:10 <CaptainASDF> I'm trying to do computations within a state monad that return an Either value, what's the idiomatic solution? Code sample at http://pastebin.mozilla.org/6457606
15:56:43 <shachaf> ski: Right.
15:56:44 <ski> shachaf : this allows the idea of "semi tail calls", where some of the alternative continuations you pass on are the same, but not all of them are
15:57:00 <ski> to get this otherwise, you have to explicitly write in CPS
15:57:22 <mhall> hi. what is an "infinite type" error? does it mean that there is some kind of infinite recursion in the type definition?
15:57:43 <shachaf> ski: The goal of this is just sharing the tail?
15:57:56 <ski> and an code-improving implementation may of course *sometimes* be able to rewrite the code to do this anyway. but the point here is *guarantees*
15:57:59 * hackagebot xml-push 0.0.0.2 - Push XML from/to client to/from server over XMPP or HTTP  http://hackage.haskell.org/package/xml-push-0.0.0.2 (YoshikuniJujo)
15:58:25 <CaptainASDF> mhall http://stackoverflow.com/questions/795317/why-does-this-haskell-code-produce-the-infinite-type-error
15:58:31 <ski> mhall : it may e.g. mean that you're somewhere confusing a list for a list element
15:58:34 <shachaf> mhall: Well, it's a type which is infinite in some way -- e.g. you're unifying a with [a]. It doesn't have to be defined recursively.
15:58:40 <CaptainASDF> Basically, it means you've created a type that contains within itself infinite similar subtypes
15:58:59 <ski> mhall : to be more specific, you need to provide more context, possibly showing some code
15:59:23 <ski> shachaf : the goal of that particular example, yes
15:59:47 <CaptainASDF> Anyone have any thoughts on using Either and State together? My head is hurting from this wallbanging I've been doing
15:59:50 <mhall> ski: it was last night and i didn't have an internet connection. it was something simple but i could see where i made the mistake, i was curious about the name 'infinite type'
16:00:03 <ski> CaptainASDF : what are you trying to do ?
16:00:35 <CaptainASDF> ski perform a stateful calculation and return Either Left Error or Right Answer with my state
16:00:57 <CaptainASDF> ski http://pastebin.mozilla.org/6457606 the top half is what I have, the bottom half is pseudocode for what I'd like
16:00:58 <shachaf> ski: So what would you call (# Int#, ... #) unboxed sums?
16:01:03 <mhall> shachaf: quick question: what does 'unification' refer to?
16:01:05 <shachaf> Maybe you wouldn't call them anything.
16:01:37 <shachaf> https://en.wikipedia.org/wiki/Unification_(computer_science)
16:01:44 <shachaf> Maybe that article isn't good.
16:01:55 <ski> mhall : e.g. consider `foo (x:xs) = [x,xs]' -- this is attempting to put an element `x' side-by-side with a list of elements `xs', in the same result list. to solve this, the type system needs to solve the type equation `a = [a]', where the solution would be `a = [[[[...]]]]', with infinitely many nested list levels. however, this is prohibited in Haskell (for practical reasons)
16:02:25 <ski> shachaf : i'm not sure
16:03:49 <mhall> ski, shachaf: hmm i think i understand a bit. thanks
16:04:16 <CaptainASDF> ski: my only current idea is to define some type Blah which is Error | Int, which seems stupidly hacky to me
16:04:54 <ski> CaptainASDF : i think it would be better if you used `StateT MachineState (Either Error) Int' here
16:05:46 <ski> CaptainASDF : in any case, you could define something like
16:05:54 <ski>   pop :: State MachineState (Either Error Int)
16:06:00 <ski>   pop = state helper
16:06:02 <ski>     where
16:06:15 <ski>     helper :: MachineState -> (Either Error Int,MachineState)
16:06:55 <CaptainASDF> Yeah, that sounds about as good as I'm going to get. I remain convinced there should be some nicer solution, but I'll take a practical one. Thanks
16:06:56 <ski>     helper (MachineState (prog,pc,[  ],regs)) = (Left StackUnderflow,(MachineState (prog,pc,[],regs)))
16:07:14 <ski>     helper (MachineState (prog,pc,x:xs,regs)) = (Right x            ,(MachineState (prog,pc,xs,regs)))
16:08:03 <ski> however, i think it probably doesn't make much sense in your case to return a `MachineState', in case the computation failed (with `StackUnderflow')
16:08:07 <ski> CaptainASDF : does it ?
16:09:47 <CaptainASDF> I don't see any /harm/ in returning the MachineState
16:09:57 <shachaf> dolio is gone.
16:10:00 <ski> it depends on what your aims are
16:10:32 <CaptainASDF> The program will terminate with an error, so in that sense the machine state has no further use
16:10:38 <ski> CaptainASDF : will you always discard the current `MachineState' in case of failure ? or will you sometimes actually need to use it (maybe to continue in some way) ?
16:10:54 <CaptainASDF> I'll use it to output the machine state upon error so I can debug
16:11:09 <ski> CaptainASDF : in case you don't intend to use the `MachineState' further, i think it would be better to simply not return it in this case
16:11:44 <CaptainASDF> Why? I've got to return some valid MachineState to satisfy the function signature, it may as well be the current one, no ski ?
16:11:55 <ski> well .. one option would be to put (perhaps portions of) the `MachineState' into your `Error', on failure
16:12:15 <ski> CaptainASDF : "I've got to return some valid MachineState to satisfy the function signature" is exactly what i question :)
16:12:18 <ski> consider again
16:12:25 <ski>   pop :: State MachineState (Either Error Int)
16:12:37 <ski> if we ignore the `State' wrapping, then this is essentially the same as
16:12:47 <ski>   pop :: MachineState -> (Either Error Int,MachineState)
16:12:56 <ski> (and this is actually the type of `helper' above)
16:13:00 <ski> CaptainASDF : ok, so far ?
16:13:07 <CaptainASDF> Yup
16:13:08 <CaptainASDF> With you
16:13:21 <ski> now, i'm suggesting it could possibly be better to have something corresponding to
16:13:28 <ski>   pop :: MachineState -> Either Error (Int,MachineState)
16:13:46 <ski> so that a new successor `MachineState' is only returned in the case of success
16:13:47 <augur_> has hackage been modified lately?
16:13:48 <augur_> links to modules on package pages arent working
16:14:03 <ski> CaptainASDF : do you see the difference ?
16:14:37 <CaptainASDF> I do indeed ski
16:14:39 <augur_> oh weird, its just on the most recent parsec page
16:14:54 <ski> now, it just so *happens*, that this can be expressed as :
16:14:55 <ski>   pop :: StateT MachineState (Either Error) Int
16:15:06 <ski> using the `StateT' wrapping as opposed to the `State' one
16:15:14 <ski> see how this differs from the earlier
16:15:19 <ski>   pop :: State MachineState (Either Error Int)
16:15:21 <ski> one
16:15:26 <ski> CaptainASDF : ok ?
16:16:16 <CaptainASDF> I do. What's the advantage to doing it? (I'm assuming StateT is State expressed as a monad transformer?)
16:16:24 <ski> (yes, it is)
16:16:26 <ski> CaptainASDF : now, you'd use the `StateT' data constructor, instead of the `state' one
16:16:35 <ski>    pop :: StateT MachineState (Either Error) Int
16:16:44 <ski>   pop = StateT helper
16:16:45 <ski>     where
16:16:55 <ski>     helper :: MachineState -> Either Error (Int,MachineState)
16:17:14 <ski>     helper (MachineState (prog,pc,[  ],regs)) = Left StackUnderflow
16:17:27 <ski>     helper (MachineState (prog,pc,x:xs,regs)) = Right (x,MachineState (prog,pc,xs,regs))
16:18:12 <ski> CaptainASDF : the advantage is expressing more exactly what you intend, not letting the types allow expressing any excess slack values that you don't need
16:19:11 <CaptainASDF> Fair enough. Thank you very much for the cogent and patient explanation, I'm going to sit down and think about exactly what I /do/ intend
16:21:35 <ski> CaptainASDF : this is e.g. similar to how using `Maybe Foo' is often preferable to using `(Bool,Foo)'
16:23:21 <CaptainASDF> Yeah, makes sense
16:37:38 <L8D_> How do I write a recursive type declaration?
16:37:50 <L8D_> I want to do: type Runner = [(String, Runner)] -> [Int] -> [Either String Int] -> IO [Int]
16:37:56 <shachaf> You can't.
16:38:04 <L8D_> :(
16:38:32 <L8D_> I just wasted soooooo much time.
16:45:58 <dreams> Why the first function terminates while the other doesn't?
16:46:03 <dreams> http://lpaste.net/110960
16:48:51 <Enigmagic> dreams: why would it terminate?
16:48:59 <hexagoxel> dreams: well, with the second definition, what is the first step when computing f 3 3?
16:50:13 <dreams> hexagoxel: it will check if 3 is 0 in the first pattern matching?
16:50:34 <ski> L8D_ : you can declare a recursive `newtype' or `data' type, though
16:51:05 <L8D_> ski: too late I've already refactored my code. :/
16:51:05 <hexagoxel> dreams: ah thats a very small step, but ok :)
16:51:06 <ski> L8D_ : like `newtype Runner = MkRunner {applyRunner :: [(String, Runner)] -> [Int] -> [Either String Int] -> IO [Int]}', e.g.
16:51:14 <hexagoxel> dreams: next step?
16:51:49 <ski> L8D_ : .. into ?
16:52:10 <dreams> hexagoxel: next, f 3 3 is rewritten to f 3 (3-1)
16:52:33 <geekosaur> now take the next step
16:52:44 <exio4> f 3 (3-1)!
16:53:09 <geekosaur> (hopefully you will recognize your mistake at that point)
16:53:19 <monochrom> the next step checks if 3-1 is 0. this invokes the substep of crunching 3-1 down to 2.
16:53:21 <dreams> the next step (3-1) is evaluated to check if its 0?
16:53:29 <geekosaur> nope
16:53:32 <geekosaur> look again
16:53:32 <monochrom> sorry
16:53:42 <L8D_> ski: Having the functions which were inside the dict not take more dicts
16:53:58 <hexagoxel> geekosaur: wait, what?
16:53:59 <monochrom> where is f defined? :)
16:54:20 <geekosaur> dreams: well, it does that but that's not the important part of it. f 3 3 -> f 3 (3-1) -> ?
16:54:40 <geekosaur> fill in the next reduction, not the next micro action
16:54:57 <hexagoxel> geekosaur: don't just say "nope" then
16:55:11 <hexagoxel> only because you don't like the stepsize
16:55:22 * geekosaur brainoed a bit, sorry
16:56:38 <dreams> geekosaur: f 3 3 -> f 3 (3-1) -> f 3 ((3-1) - 1)
16:56:44 <monochrom> this is too bad, the netsplit storm is still here
16:56:53 <hexagoxel> now, nope is appropriate
16:57:01 <L8D_> @pl find d = fromMaybe (return . (0:)) . (flip lookup d)
16:57:01 <lambdabot> find = (fromMaybe (return . (0 :)) .) . flip lookup
16:57:30 <L8D_> wait...
16:57:36 <Fuuzetsu> huh what, you can match of Text with literals?
16:57:40 <geekosaur> dreams: look closely, that is not the next actual step
16:57:44 <Fuuzetsu> is this OverloadedStrings magic?
16:57:48 <L8D_> find d = fromMaybe (return . (0:)) $ flip lookup d
16:57:50 <L8D_> @pl find d = fromMaybe (return . (0:)) $ flip lookup d
16:57:50 <lambdabot> find = fromMaybe (return . (0 :)) . flip lookup
16:57:52 <geekosaur> you may facepalm when you realize what's wrong
16:58:01 <monochrom> f (n=3) (d=does not matter) -> f (n=3) (n-1=3-1)
16:58:36 <dreams> oh shit
16:58:37 <L8D_> @pl find d = fromMaybe (return . (0:)) . flip lookup d
16:58:37 <lambdabot> find = (fromMaybe (return . (0 :)) .) . flip lookup
16:58:44 * dreams facepalms
16:59:50 <monochrom> :)
17:01:46 <dreams> geekosaur: thanks btw. I guess I get stupid after a long day.
17:02:14 <geekosaur> it happens. (my day's been a bit longer, note earlier mistake trying to prompt you through this...)
17:02:18 <yyttr3> Are there any good, actively maintained FRP GUI libraries for haskell?
17:02:56 <Fuuzetsu> are there any maintained GUI libraries…
17:03:06 * Fuuzetsu uses gtk2hs when he wants GUI 
17:03:17 <yyttr3> Besides wxHaskell
17:05:11 <yyttr3> gtk2hs doesn't seem very well supported..
17:05:12 <dolio> yyttr3: reactive-banana
17:05:56 <srhb> yyttr3: Really? Haven't had any real problems with it.
17:06:09 <Fuuzetsu> yyttr3: well, it doesn't have an FRP interface so that's that but otherwise it works pretty well
17:06:31 <Fuuzetsu> you just need to learn how to read its docs, I think that's the biggest challenge at the beginning
17:06:36 <yyttr3> I see.
17:06:38 <srhb> Besides WX and GTK I guess there's only QT, and I don't know how good those bindings are.
17:07:17 <solatis> so, what's the best way to resolve cabal package conflicts? shoot myself?
17:07:37 <srhb> solatis: Pretty much. Otherwise build things in a sandbox.
17:07:42 <hexagoxel_> shoot the package maintainer!
17:07:51 <srhb> or both.
17:07:55 <Fuuzetsu> no shooting
17:07:59 <solatis> i might just do that
17:08:08 <silasm> solatis: I'm looking into running a bunch of virtual machines, to be honest :S
17:08:25 <Fuuzetsu> silasm: or you could just use nix
17:08:32 <solatis> silasm: if you go that route, go with Docker
17:08:39 <Fuuzetsu> you know the situation is bad when people want to run VMs to be able to develop…
17:08:50 <silasm> Fuuzetsu: I've used nix. It leaves me with a bit of a bad taste in my mouth. I can see why people would like it though.
17:08:51 <solatis> they are like chrooted environments on steroids
17:09:01 <srhb> Fuuzetsu: Same goes for Nix, really. Though they solve the problem for us.
17:09:05 <dolio> People want that anyway, from what I hear.
17:09:10 <silasm> solatis: I'll look into it, thanks.
17:09:22 <Fuuzetsu> silasm: can't be worse than using VMs
17:09:28 <solatis> silasm: it's new, but they recently declared version 1.0 -- for devOps, it's a bliss
17:10:00 <nshepperd> build in sandbox, cabal install everythng at once
17:10:02 <silasm> Fuuzetsu: yes, actually, it can, because I know where everything is in a gentoo VM. My problem with nix is that there's a whole lot of relearning involved that I just don't want to deal with.
17:10:23 <silasm> (I realize this is basically laziness)
17:10:28 <silasm> (the bad kind)
17:10:35 <Fuuzetsu> ;P
17:10:35 <solatis> silasm: i think you're not the only one
17:10:41 <srhb> I think Nix is inevitably. No matter how annoying that is.
17:10:46 <Fuuzetsu> I agree that there's a learning curve at the beginning
17:10:47 <srhb> and that's not just for Haskell stuff.
17:10:58 <srhb> Inevitable*
17:11:04 <Fuuzetsu> I do think it's much easier than setting and managing a billion VMs though
17:11:21 <solatis> but here we are in #haskell -- and complaining about the learning curve of nixos :p
17:11:22 <silasm> I just don't like the crazy centralization it entails.
17:11:39 <silasm> Furthermore I kinda need to learn how to manage Qemu instances for work, so there's that...
17:12:03 <dolio> This could probably be discussed elsewhere.
17:12:10 <silasm> yeah, sorry.
17:12:28 <23LABHU4O> solatis: As someone who's learning both NixOS and Haskell at the same time, Haskell is 1000x easier:)
17:12:34 <23LABHU4O> Gah harder.
17:12:49 <23LABHU4O> I can't think straight on friday night:(
17:13:00 <Fuuzetsu> solatis: you know what they say, no exposure is bad exposure
17:14:31 <srhb> 23LABHU4O: You know what they say, Ballmer peaking is awesome peaking.
17:14:40 <solatis> haha
17:15:23 <solatis> i actually stopped drinking coffee -- the amount of focus you get in return is amazing /offtopic
17:17:51 <solatis> i think the ballmer peak doesn't work for haskell, though
17:17:52 <solatis> http://www.sultanik.com/images/ballmer.png
17:18:32 <sm> I find it very easy to quickly get "There are files missing in the (random package) package", in a fresh sandbox. Any idea what causes that ?
17:20:26 <Laquendi> why are java and malbolge in the different ends of "Language safety & complexity" I don't understand
17:21:16 <the_jeb> ok, I am going to do a little bit of channel swinging here, should I learn Lisp or Haskell? I only know python and I like the field of artificial intelligence a lot
17:22:45 <silasm> the_jeb: porque no las dos? https://upload.wikimedia.org/wikipedia/commons/a/aa/Write_Yourself_a_Scheme_in_48_Hours.pdf
17:22:47 <solatis> the_jeb: i think you should learn both and then make your choice, tbh
17:23:21 <solatis> language choice is often more a user preference than an objective, rational decision
17:25:08 <ski> the_jeb : read SICP and learn Haskell
17:28:48 <the_jeb> my internet crashed. did anybody recommend something after silasm?
17:28:55 <lpaste_> solatis pasted “Cabal dependency conflics” at http://lpaste.net/110961
17:29:49 <solatis> ok, am i correct in intepreting that the package 'couchdb-conduit' depends on deepseq, which requires http-types 0.8, and at the same time couchdb-conduit requires http-types 0.7.* ?
17:29:54 <solatis> as in, this package is horribly broken?
17:33:41 <dolio> solatis: I think it's conflicting with the version of deepseq you actually have installed.
17:33:59 <solatis> aha
17:34:01 <ski> the_jeb : see private messages
17:34:01 <solatis> !
17:34:05 <solatis> that might be it
17:34:27 <solatis> but deepseq is installed as a global package for me
17:34:37 <solatis> and i've always been taught not to mess with global packages
17:35:12 <the_jeb> ski: thanks!
17:37:38 <aranea> Oh heck, -2 luck from last Sokoban level
17:37:49 <aranea> Oh, sorry, wrong channel
17:38:15 <kadoban> -2 luck from the #haskell level now too
17:39:11 <trap_exit> when it comes down to it, must of haskell involves taking objects of type A and producting objects of type B. Now, I often find myselveves wondering "wtf are all the constructors of data B" ... when I need to consturct an object of type B. this generally results in "C-x C-s" (save for vim-users), grep, guess which file it is, open the new file, look at it, then going back to the old file
17:39:30 <MichaelBurge> solastic: Do a 'cabal sandbox init' in the directory you're working in, and then 'cabal install'. Oftentimes, if you install packages one-by-one Cabal can get stuck, but if you start fresh and give it the whole picture it can figure out the dependencies
17:39:36 <trap_exit> I'd prefer to be able to just press "C-x magic", then type in the data constructor name, and have all the possible ways of constructing the object pop up
17:39:39 <trap_exit> is this too much to ask ?
17:39:55 <solatis> MichaelBurge:  i tried that, did not work
17:41:09 <kadoban> I seem to be having more and more problems building things from hackage recently...sigh. Wonder if I'm doing something wrong, or if other people go through this Fun too
17:41:51 <trap_exit> kadoban: oh, I previously had problems with hackage
17:42:00 <trap_exit> kadoban: and I thought I was doing something wrong
17:42:10 <trap_exit> kadoban: it turns out the problem was that hackage was under heavy load and often unreacahble
17:42:29 <trap_exit> kadoban: and cabal reported "I can't download from hackage" as "hey user, something went wrong"
17:42:40 <zinfandel> kadoban: If you install more stuff it increases the possibility to get in problems :)
17:43:08 * hackagebot hactor 1.1.0.0 - Lightweight Erlang-style actors for Haskell.  http://hackage.haskell.org/package/hactor-1.1.0.0 (Forkk)
17:43:11 <kadoban> Hmm. I don't think it's that, it's more like, things just fail to build for weird reasons that make little sense to me
17:43:23 <kadoban> Well, yeah it could be just that I'm installing more crap.
17:43:32 <aranea> kadoban: Examples?
17:43:37 <trap_exit> i recommend installing more quality packages instead
17:44:00 <hpc> cabal install quality
17:44:08 <trap_exit> cabal install work-first-time-damnit
17:44:10 <kadoban> aranea: Well, currently pandoc keeps failing to build, which I need for hakyll
17:44:22 <hpc> that reminds me of a perl linting service called kwalitee
17:44:30 <merijn> kadoban: Try building with -v3 and see what the error is
17:44:34 <aranea> pandoc is a beast, dependency-wise
17:44:43 <merijn> kadoban: Do you have library-profiling enabled?
17:44:45 <trap_exit> I'm almost depsearte enough to write down all data construtors on paper, which seems stupid
17:44:52 <aranea> But still, I never had building problems with it
17:44:59 <trap_exit> is there no automated tool to build a db of all data constructors?
17:45:10 <kadoban> merijn: I'll see if I can, this computer is slow so it'll take a while. Yeah, library prof is on.
17:45:26 <merijn> kadoban: Then I suspect that, how much RAM does your machine have?
17:45:34 <hpc> trap_exit: all of them ever? there's a list comprehension for that ;)
17:45:45 <trap_exit> hpc: ?
17:45:48 <merijn> kadoban: One of pandoc's dependencies hits a bug in GHC causing GHC's memory usage to explode
17:45:51 <trap_exit> hpc: only the ones I have defined
17:45:52 <kadoban> merijn: 3GB I believe
17:45:53 <hpc> (bad syntax joke)
17:46:00 <kadoban> Oh really? Hmm
17:46:09 <merijn> kadoban: Like...300 something file that grew to like 10GB of GHC before GHC died
17:46:35 <kadoban> I wonder if that's what's going on. Would that cause it to sometimes build, sometimes fail with very minor changes in my setup?
17:46:43 <merijn> kadoban: Try building with -v3 for cabal and see where it dies, if it's on some dependency, try installing it manually and if that crashes GHC somehow (like for me) try installing pandoc without profiling
17:47:14 <solatis> impressive, google... it has already indexed my lpaste from 15 minutes ago and now it's turning up in my google search results, while still trying to solve my issue
17:47:16 <kadoban> Ahh, maybe it's not it, it seemed to be dying on actually building pandoc itself, but I'll see if I can get more info this time.
17:50:26 <merijn> kadoban: If builds fail always use -v3 when you try again, it's much more informative :)
17:50:59 <kadoban> Sounds like good practice
17:52:03 <solatis> ok
17:52:05 <solatis> that is it
17:52:19 <solatis> i'm getting rid of my OS installed version of GHC and rolling out my own
17:52:30 <trap_exit> solatis: use nixos
17:56:01 <Fuuzetsu> solatis: I did that in the past, it gets very boring very fast
17:56:42 <Fuuzetsu> you end up doing package management by hand with a lot of sandboxes and a way, way too much rebuilding
17:56:45 <solatis> Fuuzetsu: yeah i have no idea how to resolve my package conflicts at the moment...
17:57:17 <Fuuzetsu> nix/NixOS
17:57:32 <solatis> Fuuzetsu: that would require me reinstalling my OS -- i rather not do that
17:58:08 <Fuuzetsu> solatis: you can use the nix package manager alongside your existing distro
17:58:26 <solatis> that sounds scary
17:58:32 <Fuuzetsu> Why?
17:58:42 <solatis> as if it would create even more conflicts
17:58:50 <Fuuzetsu> no, it would not
17:59:02 <Fuuzetsu> it is disjoint from the crap your distro ships, it has its own version of everything it needs
17:59:18 <solatis> that sounds interesting
18:00:32 <solatis> ah, interesting
18:00:35 <solatis> arch linux even has a nix package
18:00:58 <Fuuzetsu> nice
18:01:20 <solatis> ok, so step 1: get rid of all my ghc-related packages from arch
18:01:22 <solatis> step 2: install nix
18:01:23 <Fuuzetsu> hopefully it doesn't delete your ~ when it sees you're ditching pacman
18:01:29 <Fuuzetsu> yes
18:01:36 <solatis> step 3: use nix instead of pacman
18:02:17 <Fuuzetsu> perhaps, I don't know how well installing system services from nix while not being on NixOS works
18:02:35 <solatis> nah i would only install things in ~ if it allows me to
18:02:36 <Fuuzetsu> I think you're meant to manage your system-level stuff yourself if you're only running nix
18:03:03 <solatis> this will just be for my personal dev-related environment
18:03:07 <Fuuzetsu> it stores things in /nix/store/… and creates symlinks
18:03:14 <solatis> right
18:03:24 <Fuuzetsu> yes, it should work very well for dev
18:03:31 <Fuuzetsu> just don't mix tools
18:04:03 <Fuuzetsu> I wish I got paid for getting people to try nix
18:04:37 <solatis> Fuuzetsu: :)
18:05:09 <solatis> we need a @bittip for hackagebot
18:05:24 <solatis> now that i mention that, that actually sounds like a great idea
18:05:39 <L8D_> What's the shell thing for piping stderr?
18:05:49 <HeladoDeBrownie> L8D_, 2>
18:05:52 <solatis> L8D_: 2>tmp
18:05:57 <L8D_> piping
18:06:02 <HeladoDeBrownie> Oh
18:06:10 <L8D_> foo |& head
18:06:16 <L8D_> in zsh
18:06:19 <L8D_> but in bash?
18:06:36 <solatis> L8D_: https://stackoverflow.com/questions/3618078/pipe-only-stderr-through-a-filter
18:07:15 <L8D_> thx
18:07:47 <solatis> L8D_: in effect you make 1>3, 2>1, 3>2
18:07:52 <solatis> so stdout becomes stderr and vice versa
18:08:00 <solatis> it's quite elegant imho
18:08:10 * hackagebot science-constants 0.2.0.0 - Mathematical/physical/chemical constants  http://hackage.haskell.org/package/science-constants-0.2.0.0 (cbou)
18:08:14 <HeladoDeBrownie> s/le/xtrava/
18:09:01 <solatis> HeladoDeBrownie: well it's about as good as it gets
18:09:21 <HeladoDeBrownie> solatis, oh I wasn't arguing it wasn't :P
18:09:27 <L8D_> geez nickserv
18:09:32 <solatis> Fuuzetsu: looks like we still need to educate google -- it auto-replaces 'nix' with 'unix'
18:10:11 <Fuuzetsu> solatis: I don't bother looking for ‘nix’ alone, it's always wrong, I usually have to throw in NixOS too
18:10:25 <Fuuzetsu> which is a good idea anyway because of NixOS wiki and all that
18:16:42 <stephenmac7> Is it possible to use attoparsec to create an instance of read?
18:17:08 <Fuuzetsu> sure, although readMaybe is probably more reasonable
18:17:32 <stephenmac7> Fuuzetsu: Sorry, Read
18:17:37 <stephenmac7> Not read
18:17:43 <Fuuzetsu> yes, I gathered that much
18:18:33 <Fuuzetsu> simply create your Parser MyThing and your read x = case parseOnly myparser x of { Left _ -> error "oh shit, should have used readMaybe!"; Right y = y}
18:18:50 <solatis> meh, it feels like i might as well just completely install NixOS instead of arch
18:19:00 <Fuuzetsu> solatis: ;P
18:19:02 <shachaf> You should be defining readsPrec in your read instance anyway.
18:19:11 <solatis> i'm getting all kinds of errors of missing files etc
18:19:29 <solatis> error: getting information about `/home/lmergen/.nix-defexpr': No such file or directory
18:19:30 <shachaf> I mean Read instance.
18:19:32 <solatis> that kind of stuff
18:19:39 <Fuuzetsu> solatis: that should be created by nix
18:19:44 <Fuuzetsu> maybe the arch package is crap
18:19:44 <stephenmac7> shachaf: I haven't been able to find any information on how to use readsPrec
18:20:09 <Fuuzetsu> solatis: actually, you might want to add a channel, I think channel update will create that
18:20:11 <stephenmac7> I never really got NixOS
18:20:12 <solatis> Fuuzetsu: it's in the community-driven user repository, not the officially maintained packages
18:20:15 <shachaf> The Report probably gives all the information you need.
18:20:25 <solatis> Fuuzetsu: yeah https://nixos.org/wiki/Error_Messages agrees with you
18:20:42 <Fuuzetsu> http://nixos.org/nixpkgs/download.html try the two commands at the top
18:21:18 <Forkk_> bleh... Every time I write template Haskell stuff, it turns into a huge mess .-. https://github.com/Forkk/ChatCore/blob/feature_quassel/ChatCore/Protocol/Quassel/TH.hs
18:21:33 <Forkk_> I'm having trouble coming up with a more elegant way of doing that though
18:21:52 <Forkk_> also my nick is derping ._.
18:21:53 <L8D_> @pl deflt d s ws = run d (0:s) ws
18:21:53 <lambdabot> deflt = (. (0 :)) . run
18:22:08 <solatis> time to join #nix i think :)
18:22:10 <Fuuzetsu> I wrote some TH once, what a mistake that was!
18:22:14 <Fuuzetsu> solatis: #nixos
18:22:29 <Forkk> heh
18:22:29 <hexagoxel> solatis: just out of curiosity, what are you trying to build?
18:22:30 <L8D_> @pl deflt s ws = run 10 (0:s) ws
18:22:30 <lambdabot> deflt = run 10 . (0 :)
18:22:31 <solatis> hexagoxel: i'm having cabal package conflict hell
18:22:34 <Forkk> Fuuzetsu, in this case, it's kind of a necessary evil
18:22:42 <Fuuzetsu> my favourite piece of TH is the one that loads (and perhaps ‘read’s) files at compile time
18:22:51 <solatis> hexagoxel: Fuuzetsu suggested the big hammer of Nix to me instead of trying to work around cabal
18:22:52 <Forkk> I need it to define this data structure: https://github.com/Forkk/ChatCore/blob/feature_quassel/ChatCore/Protocol/Quassel/TH.hs
18:23:11 * hackagebot hledger-lib 0.23.3 - Core data types, parsers and utilities for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-lib-0.23.3 (SimonMichael)
18:23:13 * Fuuzetsu always suggests the big hammer of nix, pretty sure #haskell is sick of it by now
18:23:13 * hackagebot hledger 0.23.3 - The main command-line interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-0.23.3 (SimonMichael)
18:23:15 <Forkk> I need to be able to read a QVariant value for a given integer ID
18:23:15 * hackagebot hledger-web 0.23.3 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.23.3 (SimonMichael)
18:23:34 <stephenmac7> Fuuzetsu: You're writing something for Quassel... in Haskell! I'm going to have to star that.
18:23:39 <Forkk> and get the ID for a given value
18:23:43 <Fuuzetsu> stephenmac7: I'm not, Forkk is
18:23:48 <Forkk> stephenmac7, wrong person :P
18:23:52 <stephenmac7> Sorry, Forkk
18:23:59 <stephenmac7> I typed F<tab>
18:24:35 <stephenmac7> I don't know how quassel picks who to select
18:24:41 <Forkk> It's basically a thing to replace the Quassel core and also support other protocols like ZNC-style IRC emulation and some JSON protocol I made up
18:25:04 <Forkk> so I can connect to a bouncer with whatever client I want
18:25:23 <Forkk> also, implementing the Quassel protocol is a pain in the asssssssssss
18:25:44 <Forkk> https://github.com/Forkk/ChatCore/blob/feature_quassel/ChatCore/Protocol/Quassel/QVariant.hs#L131
18:26:10 <stephenmac7> Forkk: Looks bad.
18:26:16 <Forkk> Most of that code is really shitty right now. I was really pissed off when I wrote it.
18:26:35 <stephenmac7> I'm merely working on a library for reading jan's qm format. Much, much simpler.
18:26:59 <dpn`> i have a slightly odd question about dev processes
18:27:03 <Fuuzetsu> you know what's also a pain? Migrating a 140 module program from String to Text
18:27:08 <Forkk> LOL
18:27:10 <dpn`> (learning here so bare with me)
18:27:18 <stephenmac7> Fuuzetsu: That... is terrible
18:27:31 <dpn`> adding and removing fields from a typeclass fundamentally changes the type
18:27:33 <Fuuzetsu> stephenmac7: I think I'm nearly done, thank god for -fdefer-type-errors
18:27:40 <Fuuzetsu> hopefully it doesn't go into day 3
18:27:40 <Forkk> Fuuzetsu, I would rather lick the floor in a public restroom
18:27:41 <dpn`> so you would have to go and modify every function that takes it
18:28:00 <bitemyapp> Fuuzetsu: why was it all written in terms of String?
18:28:08 <dpn`> is there a way to be able to modify types without having to change al lthe functions that take them as params?
18:28:17 <Fuuzetsu> bitemyapp: because Text did not exist when it was written
18:28:20 <dpn`> I'm thinking like adding removing fields from a class in a OO language
18:28:22 <stephenmac7> Fuuzetsu: Useful in that case
18:28:52 <Fuuzetsu> dpn`: you can use vinyl
18:29:07 <dpn`> Fuuzetsu, I'll check it out
18:29:09 <Forkk> Fuuzetsu, defer type errors?
18:29:13 <dpn`> I'm not having a problem with this now
18:29:22 <stephenmac7> Forkk: It makes type errors happen at runtime instead of compile time
18:29:26 <dpn`> it's just in an OO language I'd define classes first if I have a good understanding of the problem up front
18:29:26 <Fuuzetsu> Forkk: it makes type errors into warnings, it's quite magic how well it actually works
18:29:31 <Forkk> hoooooooooooooly shit
18:29:34 <dpn`> but I know I can modify them without too many issues later
18:29:35 <Forkk> want
18:29:36 <bitemyapp> Fuuzetsu: lawd.
18:29:39 <Forkk> I want it
18:29:43 <Fuuzetsu> you don't want it
18:29:59 <Fuuzetsu> you only want it if you have type errors during dev but you really want to load in the file anyway so you can hack it
18:30:03 <Forkk> are you kidding? For fixing shit, that would be so useful
18:30:17 <Fuuzetsu> right, that's the only valid case
18:30:18 <dpn`> bots...
18:30:23 <stephenmac7> dpn`: You can try using record syntax
18:30:23 <bitemyapp> dpn`: nope.
18:30:32 <bitemyapp> dpn`: I know some of those people.
18:30:32 <Forkk> like, hey, ghc, I know this doesn't compile correctly right now, but please just ignore that
18:30:50 <Fuuzetsu> Forkk: just :set -fdefer-type-errors in GHCi and knock yourself out
18:31:02 <Fuuzetsu> combine in with sprinkling holes for max profit
18:31:10 <dpn`> stephenmac7, i guess that's my real question.. where do you draw the line between record and other
18:31:11 <bitemyapp> Fuuzetsu: type errors manifest as 'error "type error I would've gotten' when the values are forced right?
18:31:13 <Fuuzetsu> I normally only ever use it for huge changes
18:31:14 <_lo> Has anyone considered a light haskell-like language designed to compile to C, mix with a C codebase, and replace parts of codebases? Compile list recursion to while loop loops, use (and derive) C types, strict typing, and more easily correct code.
18:31:24 <bitemyapp> _lo: atom or Ivory?
18:31:28 <bitemyapp> LordDeath: or just using FFI?
18:31:31 <bitemyapp> er
18:31:33 <bitemyapp> _lo: ^^
18:31:35 <Fuuzetsu> bitemyapp: I think so but I'm not running the code
18:31:36 <dpn`> I've spent a large part of my life writing non-static languages
18:31:38 <Fuuzetsu> I can try I guess
18:31:50 <dpn`> if I'm going to use one, I sure as hell want the benefits of static typing :P
18:32:08 <dpn`> bitemyapp, ... right weird
18:32:11 <stephenmac7> dpn`: It depends on what type it is. If it's something fundamental, like data Pair a b = Pair a b then, don't use record syntax.
18:32:17 <Forkk> You have to really try if you want to break haskell's static typing
18:32:30 <Fuuzetsu> eh, can't run it in GHCi easily, whatever
18:32:33 <Forkk> It's not difficult to do at all
18:32:39 <Forkk> but it's hard to do on accident
18:33:14 <Fuuzetsu> there is a recently filed bug that boot files + TypeFamilies = unsafeCoerce ;)
18:33:17 <dpn`> stephenmac7, just realised that record syntax actually does what I want
18:33:17 <stephenmac7> dpn`: If it's something that, for example, represents something that may change, say data DictionaryEntry = Entry String String then record syntax is preferable
18:33:28 <dpn`> assuming you aren't pattern matching on the tuple layout in functions
18:33:36 <stephenmac7> dpn`: You
18:33:38 <dpn`> not sure that's even possible with record syntax defined types
18:33:49 <stephenmac7> *You're not always pattern matching
18:34:07 <_lo> bitemyapp: Read over those, none seem to compile to C.
18:34:08 <dpn`> stephenmac7, right.. got it
18:34:08 <stephenmac7> Wall of text...
18:34:15 <dpn`> that was helpful.. thanks :)
18:34:22 <solatis> Fuuzetsu: could it be that my install of nix isn't really good? i'm missing all kinds of directories that nix assumes are available, like ~/.nixpkgs
18:34:29 <hexagoxel> dpn`: it is still possible
18:34:46 <stephenmac7> dpn`: Record syntax creates a new function for every field so you don't have to pattern match. Instead, use the function to extract that value.
18:34:51 <bitemyapp> _lo: is that so?
18:34:55 <bitemyapp> _lo: ivory-backend-c: a backend for compiling Ivory programs to C
18:35:01 <bmuk> _lo: Ivory compiles to C, sort of. It is a safe subset of C designed for verifying embedded systems
18:35:03 <dpn`> i guess in some ways, you would want to use record syntax for anyhting you would call "domain data"
18:35:22 <dpn`> stephenmac7, yeah I'd forgotten about that. nice
18:35:26 <_lo> bmuk|bitemyapp: Woops, thx
18:35:32 <Fuuzetsu> solatis: I don't have much experience of nix without NixOS but if you ask in #nixos you can probably be helped pretty quickly
18:35:33 <bitemyapp> _lo: is FFI somehow not going to suffice?
18:35:36 <stephenmac7> dpn`: You're welcome, thanks for asking.
18:35:54 <stephenmac7> Helps me brush up on my "helping people skills"
18:36:03 <_lo> bitemyapp: I want to use it for kerneldev, to build an easily verifiable kernel.
18:36:09 <dpn`> :D
18:36:09 <Fuuzetsu> solatis: on upside nix doesn't expect many directories so even if your inital package was botched, it should be very easy to recover
18:36:10 <_lo> GC sucks in kernelspace.
18:36:17 <_lo> (At least, that's what I'd like to play with.)
18:36:26 <bitemyapp> _lo: "easily verifiable
18:36:32 <_lo> Better than C.
18:36:39 <bitemyapp> _lo: I want to know what you've written on the scale of a kernel that is easily verified.
18:36:46 <bitemyapp> _lo: are you familiar with seL4?
18:36:54 <_lo> I am, but they used haskell to prove it.
18:37:02 <bitemyapp> _lo: have you done proofs in a language like Coq?
18:37:03 <Fuuzetsu> no, they didn't use Haskell to prove it
18:37:06 <Forkk> holy shit. Nix looks fucking awesome... Why have I not heard of this before
18:37:16 <bitemyapp> Forkk: because it's not a panacea and doesn't work on Windows.
18:37:23 <bitemyapp> Forkk: and for a lot of people, flat out doesn't work that reliably.
18:37:30 <Fuuzetsu> Forkk: you must have been on when I was unconcious
18:37:36 <bmuk> _lo: You may be interested in this - http://plv.csail.mit.edu/bedrock/
18:37:38 <_lo> bitemyapp: I'm looking to minimize typos causing security holes.
18:37:41 <bitemyapp> Forkk: it's still alpha-grade, i.e. "be ready to tinker and poke a lot"
18:37:44 <Forkk> Fuuzetsu, what?
18:37:52 <bitemyapp> _lo: you think typos are a primary cause of security problems?
18:37:52 <_lo> Haskell is better at that than C.
18:37:57 <Fuuzetsu> Forkk: Nothing, just saying I shill it here a lot.
18:38:04 <bitemyapp> _lo: you should study the domain a bit before diving into a specific project.
18:38:04 <_lo> bitemyapp: I think poorly maintained and written functions are.
18:38:15 <Fuuzetsu> bitemyapp: Definitely not alpha-grade but you're expected to be able to write expressions, that's just how it is
18:38:17 <Forkk> ah. I just joined here a moment ago :P
18:38:17 <bitemyapp> _lo: particularly one as ambitious as writing your own "verified" kernel.
18:38:31 <_lo> bitemyapp: I didn't clarify, that was an example.
18:38:33 <Forkk> I asked myself "why the fuck am I not in #haskell" and so I joined
18:38:52 <bitemyapp> Fuuzetsu: I have tried to install and make Nix work 4 times over the last ~1.5 years on Mac and Linux. It's a mess and the documentation is borderline counter-productive.
18:39:13 <bitemyapp> I realize some people can use it effectively. Cool.
18:39:14 <_lo> I'm actually interested in general use.
18:39:25 <bitemyapp> But that's not an experience that is trivially reproduced without a lot of support from other Nix users.
18:39:42 <Fuuzetsu> bitemyapp: I have tried and managed to install it every time, it's not a mess but the documentation could be better. If you want help with it then ask, I haven't seen you asking in #nixos
18:39:52 <bitemyapp> any project that requires that much effort and manual intervention on top of the documentation is simply not release grade yet.
18:39:52 <_lo> bitemyapp: A functional preprocessor for C would be useful.
18:40:19 <solatis> ok,that's it, i'm going full NixOS
18:40:25 <bitemyapp> Fuuzetsu: I did ask 2-3 times before, got no help, moved on. The documentation looks like something wrote so they could check a box, zero thought given for the new user.
18:40:31 <_lo> Haskell's typing system, semantics, and constructor manipulation is excellent.
18:40:46 <bitemyapp> Fuuzetsu: last time I tried it was 2 or so months ago.
18:41:03 <Fuuzetsu> bitemyapp: if you have issues with documentation then file bugs, it's pointless if you don't complain to people who can fix it
18:41:11 <bitemyapp> I have never seen documentation about a package manager try so very hard to avoid talking about to manage packages.
18:41:13 <Fuuzetsu> also I'm very surprised you would have gottenno help
18:41:20 <bitemyapp> Fuuzetsu: *shrug*
18:41:23 <bitemyapp> Fuuzetsu: I'm scary.
18:41:47 <bitemyapp> Fuuzetsu: you saw how impatient I got with the Cabal haddocks nonsense. That was bad UX and documentation too.
18:41:49 <Fuuzetsu> well, ping me when/if you try it again, I can probably handhold a bit
18:41:56 <bitemyapp> Fuuzetsu: and that was relatively trivial compared to how irritated I got with Nix.
18:42:03 <bmuk> bitemyapp: I just installed it for the first time myself, I would say that it is still a little hard to find how to do what ever you want to do. I just bugged everyone on #nixos (including Fuuzetsu) and now I've got pretty much everything set up.
18:42:11 <Fuuzetsu> bitemyapp: I'm not aware of this Cabal haddocks incident you're talking about
18:42:14 <bitemyapp> Fuuzetsu: I use an apt-based distro. Between that and sandboxes, Nix doesn't relieve any pain for me.
18:42:26 <bitemyapp> Fuuzetsu: long story.
18:43:03 <Forkk> Oh wow. Fuuzetsu, I just realized you're the guy who wrote the blog post about fixing hackage docs that I was reading like 30 minutes ago.
18:43:05 <Fuuzetsu> bitemyapp: of course if your current setup works then that's great, I'm promoting it to people who have problems with their current setup
18:43:09 <bitemyapp> Fuuzetsu: at present, hackage doesn't build packages and hasn't done so reliably for months. You have to upload docs.
18:43:13 <Fuuzetsu> Forkk: sure, it is I
18:43:22 <Forkk> bitemyapp, yep, exact problem I was having
18:43:34 <bitemyapp> Fuuzetsu: right now I Have hacky nonsense in my Makefile based on your (two) blog posts about generating and uploading haddocks.
18:43:51 <bitemyapp> Fuuzetsu: there were subtler-than-I'd-like issues with generating the correct haddocks. Particularly concerning html-location and something else.
18:44:04 <Fuuzetsu> it does build packages but reliability differs, as you have clearly read my blog I also think that reliability fell
18:44:07 <bitemyapp> Fuuzetsu: I put a bug in the ear of the Cabal elves and hopefully a `cabal upload --haddock` will manifest.
18:44:12 <bitemyapp> Fuuzetsu: no, it doesn't build packages.
18:44:17 <bitemyapp> Fuuzetsu: the build process was shut off the other day.
18:44:26 <bitemyapp> Fuuzetsu: it will not build packages again until after the migration.
18:44:37 <Fuuzetsu> bitemyapp: it is back up and if you look at haskell-infrastructure there is migration to new box
18:44:39 <Fuuzetsu> yes
18:44:40 <Forkk> yeah I'm fairly sure it's just not even trying
18:44:43 <bitemyapp> You have to upload docs manually until that happens and even then, there's no way of knowing if it'll get reliable again.
18:44:51 <Fuuzetsu> bitemyapp: but it was only shut off few days ago, not months are you said
18:44:51 <bitemyapp> Fuuzetsu: I didn't know the migration had already occurred.
18:44:57 <Fuuzetsu> bitemyapp: I think it's still in progress
18:45:01 <bitemyapp> Fuuzetsu: I said the builds weren't *reliable* for months.
18:45:04 <bitemyapp> Fuuzetsu: because they weren't.
18:45:20 <bitemyapp> Fuuzetsu: I struggled for a couple days trying to get hackage to build my damn library with carter until I gave up and used your method to push docs.
18:45:27 <Fuuzetsu> I looked into some numbers months ago and it's actuall as unreliable as it was for a long time already
18:45:28 <bitemyapp> no build reports either.
18:45:41 <Fuuzetsu> but yeah, I agree the situation is subpar
18:45:42 <bitemyapp> I don't have exact numbers, okay?
18:45:46 <Forkk> bitemyapp, it's not really that difficult to upload them anyway once you have a script for it
18:45:48 <bitemyapp> it wasn't working for me and a lot of other people. Period.
18:45:54 <bitemyapp> Forkk: idgaf
18:45:58 <bitemyapp> Forkk: it should just work.
18:45:59 <Fuuzetsu> bitemyapp: I know, I wrote my blogpost precisely because of that reason
18:46:06 <Forkk> it should
18:46:11 <bitemyapp> Forkk: we have superior foundational tooling with a community of smart people.
18:46:29 <shachaf> dolio: I think maybe even InNofM# isn't enough, since you'd want to know the other summands to know what the memory layout should look like.
18:46:37 <Forkk> well go yell at the hackage devs on their bug tracker
18:46:46 <bitemyapp> there is no reason anything as important as documentation shouldn't be in place for everything on Hackage.
18:46:46 <Forkk> you're doing the same thing you were doing with nix
18:46:50 <Fuuzetsu> there is plenty of yelling there already
18:46:57 <bitemyapp> Forkk: uh, I've patched and worked on Hackage.
18:47:04 <Forkk> if you have a problem with something, go yell at the devs, not random people in IRC
18:47:06 <bitemyapp> Forkk: and they're fully aware of the problems. I talked to 'em before.
18:47:08 <bitemyapp> Forkk: I *did*
18:47:10 <Forkk> well then fix it yourself if you want
18:47:15 <bitemyapp> Forkk: dude
18:47:22 <Fuuzetsu> sure is getting heated in here, gonna go back to refactoring
18:47:30 <bitemyapp> Forkk: I am telling Fuuzetsu about this because cabal-install is getting a feature based on his blog post.
18:47:39 <bitemyapp> Forkk: I have already addressed the problem. Fixes are on the way.
18:47:39 <Forkk> alright
18:47:44 <Fuuzetsu> bitemyapp: by the way do you know what version that will happen?
18:47:46 <bitemyapp> Forkk: github issues were filed, patches are coming.
18:47:50 <Fuuzetsu> I think I saw the ticket a while back
18:47:51 <bitemyapp> Fuuzetsu: the target is .22
18:48:09 <Fuuzetsu> cool
18:48:13 <Fuuzetsu> hopefully it works well
18:48:18 <bitemyapp> Fuuzetsu: if a patch doesn't manifest around the time they start talking about a release, I'll do it myself. I'd rather not as I don't know Cabal or cabal-install internals very well.
18:48:20 <Fuuzetsu> can't be worse than 10 lines of bash
18:48:28 <bitemyapp> Fuuzetsu: oy. I don't know.
18:48:39 <Fuuzetsu> Surely™
18:48:43 <bitemyapp> Fuuzetsu: I hope so? I just want things to work.
18:48:53 <Fuuzetsu> I would also like things to work
18:49:42 <Forkk> hmm
18:49:51 <Forkk> Is netwire actively maintained?
18:50:14 <Forkk> looks like the last release was in 2013 :|
18:50:32 <Fuuzetsu> Forkk: you could wait for a bit for the maintainer to come on IRC
18:50:42 <bitemyapp> Forkk: best to just idle.
18:52:08 <Forkk> Fuuzetsu, why would I need to wait for the maintainer? I'm just wondering if it's actively maintained. I'd rather not use it if it's not going to be updated for new versions of other packages
18:52:19 <Fuuzetsu> should I feel bad for using <$> instead of map?
18:52:29 <Forkk> Why would you?
18:52:31 <nshepperd> nah, <$> is great
18:52:44 <Forkk> <$> is my best friend
18:52:45 <Fuuzetsu> there are some fmap . fmap pearls here too
18:52:51 <Forkk> lol
18:53:09 <Forkk> I think I had a lift $ lift $ RC $ lift $ lift earlier .-.
18:53:15 <Fuuzetsu> :t fmap . (<$>)
18:53:15 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
18:53:18 <Forkk> I got rid of it thankfully
18:53:23 <Fuuzetsu> look map, no repetition!
18:53:26 <Fuuzetsu> look ma*
18:54:12 <nshepperd> also you can use <$> instead of (.)
18:54:24 <nshepperd> :t fmap <$> (<$>)
18:54:25 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
18:54:41 <tabemann> now what I don't get is why didn't they just make fmap map, rather than having separate fmap and map
18:54:43 <Fuuzetsu> I like . though
18:54:52 <Forkk> mb <- lift $ lift $ RC $ lift $ getMailBox -- Do you even lift?
18:54:53 <nshepperd> :t (<$>) <$> (<$>)
18:54:54 <Forkk> yeah
18:54:54 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
18:54:58 <Fuuzetsu> also <$> is hard to type, the $ is on a pinky for me
18:55:15 <Forkk> tabemann, because backwards compatibility
18:55:17 <Forkk> I think
18:55:27 <_lo> bitemyapp: Thanks for pointing me to ivory. It's good for embedded purposes, but doesn't let you step away from the C. Know of anything between Ivory and regular haskell?
18:55:29 <bmuk> tabemann: I've heard the argument is that it would be confusing for newcomers as well
18:55:34 <bitemyapp> Fuuzetsu: I once did (fmap . fmap . fmap) in real code.
18:55:40 <Fuuzetsu> tabemann: we had this discussion many times, it's about Scary Errors™ that beginners will see
18:55:41 <bitemyapp> Fuuzetsu: I'm proud of my filth. Like a hog in a sty.
18:55:46 <tabemann> bmuk: that's the argument I've heard
18:55:48 <Forkk> bmuk, yeah, but that's a really stupid argument
18:55:52 <_lo> (Generic functional preprocessor / overlay, not specifically haskell.)
18:56:17 <bmuk> I agree, just passing along the propaganda.
18:56:20 <Fuuzetsu> the counter-argument is that we should have a prelude that uses the easy version of stuff that people learning could use
18:56:27 <Forkk> anyway, what I want to know is why <$> isn't in prelude
18:56:32 <Forkk> tired of importing applicative
18:56:34 <Fuuzetsu> but the counter-counter argument is that it won't teach them the code as it's written…
18:56:44 <bitemyapp> Forkk: write yer own Prelude.
18:56:56 <Fuuzetsu> bitemyapp: but then he has to import that!
18:57:00 <Forkk> exactly
18:57:09 <nshepperd> won't <$> be in prelude soon, what with the F-M-A thing
18:57:16 <bmuk> _lo: are we talking about performace? Why do you need C? Unless you are doing pointer arithmetic or managing your own memory, haskell can do everything C can do and more. Just as fast usually.
18:57:31 <Fuuzetsu> F-M-A patches were applied ~2 days ago I think
18:57:32 <Forkk> I should write a vim command that adds "import Control.Applicative" to the top of the file
18:57:53 <nshepperd> I hope it will
18:57:57 <_lo> I have benchmarks that say it's closer to java-level performance. This is fine for most cases, but I do some kernel work, and GC is frowned upon.
18:58:04 <Fuuzetsu> Forkk: I'm sure vim has yasnippet or something
18:58:10 <Forkk> probably
18:58:15 <Forkk> but I'm laaaaaaaaaaaaaaaaaaaaaazy
18:58:20 <Fuuzetsu> shame elisp is a piece of crap so my Haskell snippets now overflow ;^)
18:58:26 <Forkk> Installing vim plugins would require not being lazy
18:58:28 <bmuk> Forkk: when Applicative becomes a super class of monad, will it be in the Prelude?
18:58:36 <Forkk> bmuk, I hope
18:58:36 <nshepperd> also I just realised that the name of the functor-applicative-monad proposal spells out "fmap"
18:58:46 <Forkk> LOL
18:58:49 <Forkk> that's awesome
18:58:49 <Fuuzetsu> nshepperd: with a flip in the middle
18:58:55 <bmuk> _lo: let me look for an article, hang on
18:59:01 <_lo> bmuk: I'm looking for something build-time, no dependencies. kk.
18:59:11 <nshepperd> well, almost spells it out yeah
18:59:14 <Forkk> actually, nshepperd, that spells out famp
18:59:14 <Fuuzetsu> also it's known as applicative-monad , functor already is a superclass of applicative
18:59:38 <nshepperd> dammit
18:59:43 <bitemyapp> Fuuzetsu: luckily we're not *that* silly
18:59:43 <Forkk> Fuuzetsu, buzzkill D:
19:00:02 <gfixler> Forkk: :map ,ca ggOimport Control.App;icative<Esc>``
19:00:12 <Forkk> YES
19:00:24 <Forkk> THANK YOU
19:00:28 <catsup> applicative is already a superclass of monad
19:00:38 <gfixler> Forkk: note that the ; should be l - Vim isn't *that* weird
19:00:39 <Fuuzetsu> catsup: ??
19:00:46 <Forkk> lol
19:00:52 <gfixler> Forkk: and the `` at the end isn't line noise
19:00:58 <catsup> https://github.com/ghc/ghc/commit/d94de87252d0fe2ae97341d186b03a2fbe136b04#diff-4255ad26ea25b80cc5d2a001a2e23e1eR412
19:01:06 <Fuuzetsu> oh, yes, patches did land as I said
19:01:08 <Forkk> gfixler, I dunno... vim regexes are pretty odd
19:01:11 <Fuuzetsu> I thought you meant something else
19:01:19 <gfixler> Forkk: s/odd/awesome/
19:01:22 <gfixler> Forkk: and I agree
19:01:30 <Fuuzetsu> gfixler: I honestly spent some time wondering if that ; was intentional
19:01:35 <Forkk> s/\(odd\)/\1ly awesome/
19:01:41 <gfixler> Fuuzetsu: I was eating Sun Chips
19:01:58 <gfixler> Fuuzetsu: they were messing up my typing
19:02:08 <tabemann> hmm maybe I should just write a test of Network.TLS
19:02:10 <bitemyapp> Fuuzetsu: doesn't Traversable need mangled a bit to take advantage of the AMP?
19:02:31 <Fuuzetsu> bitemyapp: yes, I think there is some stuff about roles
19:02:38 <tabemann> to determine whether recvData is blocking or not
19:02:39 <bmuk> _lo: you are saying you want no run time dependencies?
19:03:12 <Fuuzetsu> I don't know about roles more that it's a thing I don't understand so I can't explain more
19:03:13 <_lo> bmuk: Take algorithms, described functionally, and compile them into C source files.
19:03:32 <_lo> Only outside dependencies are those available to C files in the project.
19:03:39 <tabemann> dammit I really need Network.TLS to support a non-blocking receive, or failing that, allow writing and reading simultaneously in different threads
19:03:57 <_lo> Something between Ivory and full Haskell.
19:04:25 <_lo> (Though, haskell is a bad example for a few reasons. Something that steals the type system, the lazy eval, and a few other things.)
19:04:27 <bmuk> I thought that GHC could generate C files?
19:04:44 <tabemann> how do you have lazy eval without GC?
19:04:52 <tabemann> bmuk: it did at one time, it doesn't anymore
19:05:08 <_lo> Intermediate, they rely on garbage collection, they don't work so nicely as part of a project.
19:05:13 <_lo> Fake lazy-eval.
19:05:44 <_lo> There are cases where you must write an algorithm using it, but many can be compile into procedural things.
19:05:50 <_lo> (all, technically, but not cleanly.)
19:06:01 <_lo> Sorry, wrong question.
19:06:14 <tabemann> compiling to C and then native code results in slower code than compiling directly to native code or compiling to LLVM and then native code
19:06:25 <bitemyapp> _lo: the concern I have here is that you want to tackle "Make a bugatti veyron" when you don't sound like you've changed the oil in a hilux before.
19:06:30 <heatsink> Without letrec and mutability, objects can only have references to older objects, so reference counting is possible.
19:06:50 <bitemyapp> _lo: you should just tackle smaller projects of verified software a la Coq and see if it's even the sort of thing you like. Maybe study how seL4 was made as well.
19:06:52 <_lo> bitemyapp: I've built a smartcar, but I used matchsticks.
19:06:56 <_lo> It worked beautifully.
19:07:24 <_lo> I'm not actually verification oriented. I'm a C guy who's interested in a functional overlay.
19:07:57 <bmuk> there's http://www.rust-lang.org/
19:07:57 <_lo> (For the strong typing system, excellent recursion, composition, first order logic, ....)
19:08:32 <_lo> IIRC rust doesn't do much of that. I'll recheck if you have better knowledge.
19:08:58 <bitemyapp> _lo: but you want a verified kernel.
19:08:58 <tabemann> you're not going to find a language that does much of what Haskell does without garbage collection
19:09:10 <bjz> _lo: I think that might be the next systems lang after Rust
19:09:15 <bitemyapp> _lo: I'm pointing you to how non-trivial writing a verified kernel is.
19:09:23 <_lo> bitemyapp: I don't want a verified kernel.
19:09:27 <bjz> _lo: that is my wish list
19:09:36 <bitemyapp> _lo: and suggesting that you might want to learn how to write proofs in languages like Coq and study how an actual verified kernel was written before chasing toys.
19:09:44 <bjz> _lo: but for now Rust suits my needs
19:09:50 <_lo> bitemyapp: I'm not looking to verify anything.
19:09:55 <vanila> seL4 was done using HOL
19:09:56 <_lo> I mentioned that due to work on seL4.
19:10:46 <vanila> _lo, what is it you'd like to do?
19:10:54 <bmuk> tabemann, exactly. _lo: I think you have to realize there is a trade off here. Either you have the nice features provided by GC, or you don't. I have thought about something like a language extension to haskell where you could write pointers and such in a monad. But Ivory pretty much did that for me.
19:11:10 <bmuk> You can call Ivory code from haskell iirc.
19:11:20 <_lo> bmuk: It's an excellent example.
19:11:33 <nshepperd> hmm, the AMP patch gives (>>=) a default definition in terms of `join . fmap f`, but `join` still isn't in the typeclass?
19:11:35 <dpn`> the main thing that people seem to complain about with hs when compared to say rust is how hard it is to reason about runtime complexity etc because of lazy eval
19:11:46 <dpn`> I'm used to working with iterators because of concurrency in other languages
19:11:51 <dpn`> is it really that much of a problem?
19:11:51 <bitemyapp> nshepperd: it's not "done"
19:11:59 <Fuuzetsu> I think it's hard to reason about anything in rust because it's either broken or will be broken in 3 days
19:12:03 <nshepperd> oh
19:12:07 <_lo> bmuk: I understand the tradeoffs, but I'm looking at a large fraction of haskell and C codebases, and thinking the mapping isn't NP-Complete.
19:12:17 <bjz> dpn`: doesn't SPJ say if he was to do haskell again he'd do it eagerly?
19:12:26 <bitemyapp> bjz: no
19:12:31 <dpn`> bjz, hadnt heard that
19:12:39 <MP2E> bjz: never heard that
19:12:46 <vanila> _lo, I missed the start just curious
19:12:50 <dpn`> my understanding is that things like forkIO and friends are mostly possible because of the lazy nature
19:12:55 <dpn`> to me the laziness is a _feature_
19:12:59 <bitemyapp> dpn`: it is.
19:13:06 <bitemyapp> bjz: he thought laziness was more important than it actually ended up not being the *most* important thing.
19:13:16 <bitemyapp> I'd still rank it up there in the top 3 or 5.
19:13:23 <bmuk> I think if we knew what you wanted to do, _lo, we'd be able to help more.
19:13:24 <dpn`> surely the cloud hs guys would be loving the laziness though
19:13:26 <tabemann> I read that he said that the good side of lazy evaluation was that it forced the language to be pure, despite the problems with space complexity
19:13:32 <_lo> vanila: I made the mistake of being young in functional languages.
19:13:40 <Fuuzetsu> bjz: pretty sure that's just something people repeat
19:13:43 <bjz> bitemyapp: oh ok
19:13:55 <L8D_> _lo: Don't worry. A lot of functional programmers do
19:13:57 <bjz> Fuuzetsu: yeah I might have it wrong
19:14:04 <vanila> _lo, PM me? I am not going to attack you like other people here
19:14:06 <L8D_> initially
19:14:08 <_lo> I'm thinking about a C-oriented functional language, with haskell like strong typing / syntax / eval semantics, and compiletime.
19:14:13 <dpn`> are there tools to help with that kind of stuff?
19:14:14 <bjz> bitemyapp: I do like Idris how you can opt in to laziness
19:14:23 <dpn`> profiling running code in a meaningful way?
19:14:25 <_lo> vanila: I'm in plenty of communities myself. I don't think this is abnormal.
19:14:26 <bitemyapp> bjz: I don't want to opt-in. I want laziness by default and opt-in to strictness.
19:14:28 <bmuk> _lo, I didn't mean to seem like I am attacking you
19:14:29 <tabemann> I was thinking of Idris!
19:14:38 <heatsink> _lo: I think Ur runs without GC and interfaces with C
19:14:38 <tabemann> bitemyapp: Haskell already has that
19:14:44 <vanila> _lo, yeah just hard to see through the noise a bit
19:14:46 <bjz> bitemyapp: isn't it harder to go the other way around though?
19:14:49 <bitemyapp> bjz: laziness should be the default. I don't know that I'd mind if there was a way to type strictness, but I still don't care that much.
19:14:49 <dpn`> _lo, that sounds like go?
19:14:49 <_lo> bmuk: More refering to bitemyapp. I made the mistake of making him think I was looking to make a verified kernel on my own.
19:14:53 <dpn`> or maybe rust...
19:14:56 <bitemyapp> tabemann: I...know that.
19:15:08 <dpn`> _lo, oops missed the functional bit.. ignore me
19:15:22 <tabemann> the thing is that without GC you can't have closures
19:15:23 <Forkk> oh wow
19:15:29 <Forkk> I never had a look at rust before now
19:15:34 <bitemyapp> tabemann: well. Sorta.
19:15:36 <tabemann> and without closures higher-order functions are quite impractical
19:15:40 <Forkk> I'm totally throwing C++ out the window
19:15:41 <dpn`> tabemann, using ref counting you can
19:15:45 <_lo> dpn`: Consider this: function = map capitalize
19:15:46 <bitemyapp> tabemann: you can have closures without GC. It's just that nobody likes the answer :)
19:15:50 <_lo> It would compile to a while loop.
19:15:56 <tabemann> dpn`: I was counting ref counting in as well
19:15:57 <Forkk> Rust took some things I loved in Haskell and put them in C++
19:16:00 <bitemyapp> tabemann: ref-counting is the least ridiculous answer among them all.
19:16:09 <vanila> heatsink, Ur/Web? It allocates a slab of memory per page which grows if needed and is discareded after the page is served
19:16:09 <vanila> whether that's GC or not is debatable, it's certainly efficient
19:16:11 <dpn`> tabemann, gotcha
19:16:14 <_lo> dpn`: You'd get that in a C file, that you could mix with all your other ones.
19:16:23 <tabemann> ref counting has its problems though, beyond cycles
19:16:28 <bjz> dpn`: yeah, rust aint functional. but it has lots of ideas from statically typed FP
19:16:32 <dpn`> _lo, surely someone has done that as a bunch of preprocessor functions ? :D
19:16:34 <bitemyapp> vanila: reminds me of slab allocation in memcached.
19:16:37 <tabemann> constant updating of reference counts wreaks havoc on caches
19:16:50 <heatsink> vanila: Ok.  Where did you see that?  The Ur docs are incomplete.
19:17:01 <tabemann> and adds constant branches that could be mispredicted
19:17:15 <_lo> dpn`: I can't imagine someone compiling lazy eval + constructor based recursion into procedural C that intelligently.
19:17:31 <bmuk> _lo I don't think compilers can generate looped functions from recursive functions for all functions. It's pretty hard, there's a problem in SICP where you do it for a function that calculates all the possibilities of coins given a value amount.
19:17:31 <dpn`> _lo, agreed :)
19:17:32 <vanila> heatsink, I think the manual is pretty complete? maybe im overlooking something
19:17:57 <bjz> Fuuzetsu: yeah Rust is neat. syntax is bloody ugly though, and you can't throw around functions like you do in Haskell. But I do most of my work in it right now
19:17:57 <tabemann> ref count isn't realtime either, due to chains of frees occurring at unpredictable times
19:18:08 <tabemann> so ref counting isn't a solution
19:18:14 <bmuk> How is go compared to rust?
19:18:22 <Fuuzetsu> Go is just bad compared to anything.
19:18:25 <bjz> Fuuzetsu: woops - I meant Forkk
19:18:26 <_lo> bmuk: I've been looking into the problem for some time. I know. Many cases could be tuned, and I'm afraid this would be no simple algo.
19:18:31 <_lo> (Nor possible?)
19:18:36 <dpn`> bjz, to be fair the function ref sysm in rust is tolerable.. would definitely be a barrier to doing FP-style stuff though
19:18:40 <carter> tabemann: i've been talking with some folks ablut how to do region based allocation / freeing nicely
19:18:43 <vanila> _lo, are you interested in design and implementation of such a language?
19:18:47 <Forkk> bjz, aw, no first class functions? D:
19:18:49 <Fuuzetsu> bmuk: there's a fun comparison to a certain language from the 60s if you haven't seen that yet
19:18:50 <_lo> bmuk: A backdrop should be possible for complicated cases.
19:18:52 <Forkk> I love throwing around functions
19:18:54 <bjz> Forkk: it has them
19:19:08 <dpn`> they're just more like C function pointers
19:19:09 <dpn`> :P
19:19:11 <Forkk> ah
19:19:12 <carter> tabemann: the trick is to do region based lifetimes/allocation, BUT use refcounting on the region handles
19:19:12 <Forkk> bleh
19:19:16 <_lo> vanila: Very. Something like that could be used to change existing (messy) codebases into something more readable.
19:19:16 <bjz> Forkk: you can do some nice higher order stuff using closures
19:19:19 <carter> so you're not doing that much ref count managment
19:19:21 <bmuk> Fuuzetsu: comparison to Lisp?
19:19:28 <bjz> Forkk: like mapping over iterators and such
19:19:28 <Fuuzetsu> bmuk: no
19:19:41 <_lo> Quicksort is a fun example.
19:19:47 <vanila> _lo, me too - I think there's a lot of rich soil here that hasn't been used
19:19:51 <nshepperd> for writing safe systems code, I think you probably want a strongly typed imperative language?
19:19:52 <Fuuzetsu> bmuk: http://cowlark.com/2009-11-15-go/ knock yourself out
19:19:52 <bjz> Forkk: I'm talking about pervasive curryting and such
19:19:58 <Forkk> ah
19:19:58 <_lo> vanila: Are you experienced in this communit?
19:20:02 <_lo> community*?
19:20:07 <bjz> dpn`: Rust has closures
19:20:08 <vanila> no
19:20:14 <_lo> The blind leading the blind, then.
19:20:22 <dpn`> bjz, yep
19:20:32 <vanila> I think you're being rude to me
19:20:39 <_lo> Nah.
19:20:44 <nshepperd> I mean that's basically what Ivory is. it uses haskell as a type system, where you write imperative code
19:20:47 <MP2E> _lo: vanila is being modest, she is quite capable
19:20:48 <_lo> I'm just hoping there's a reason bitemyapp's a dick.
19:20:59 <Forkk> Anyway, I'm thinking of switching from the crazy actor model nonsense I'm using for my project and trying to incorporate FRP. The actor model stuff seems like it's going to be hard to maintain.
19:21:01 <dpn`> nshepperd, i reckon hs would be fine for it - you just want to be careful about the whole runtime/lazy/reasoning thing
19:21:03 <bjz> bmuk: Go is more targeted at the domain of Java and server side C++. Rust is targeted at the bulk of C++'s domain
19:21:08 <Forkk> code is here: https://github.com/Forkk/ChatCore/blob/master/ChatCore/UserController.hs
19:21:18 <vanila> _lo,  it is not acceptable to insult people like that here
19:21:23 <_lo> MP2E: I don't doubt it.
19:21:32 <Forkk> Anyone have any advice on FRP? Would it be good for that kind of thing?
19:21:49 <_lo> vanila: It wasn't intended as an insult. If two people (relatively new) joined a community and had an idea for some "Unused soil", it generally isn't wise.
19:21:53 <bitemyapp> Forkk: what problem is FRP solving for you?
19:21:59 <carter> _lo: what'd he do this time? pm me the relevant bit of scroll back? : )
19:22:03 <Forkk> nothing at the moment
19:22:03 <bitemyapp> Forkk: usually it's more helpful when you have a lot of sources and sinks interacting.
19:22:15 <vanila> _lo, ok. everything you're talking about is totally offtopic for this channel
19:22:16 <bitemyapp> Forkk: that's why people really like to try to use it with interactive interfaces.
19:22:25 <Forkk> right now I have a bunch of threads sending messages to each other over channels
19:22:30 <bitemyapp> vanila: and the Saint falls.
19:22:35 <_lo> vanila: Sorry. Is there a #functional?
19:22:35 <Forkk> basically, I'm using erlang without using erlang .-.
19:22:54 <_lo> carter: Whonow?
19:22:57 <Fuuzetsu> Forkk: which is cool because you get types
19:23:01 <Forkk> yes
19:23:01 <carter> nvm
19:23:38 <vanila> bitemyapp? I was sticking up for you
19:23:47 <bjz> nshepperd: Ivory looks cool
19:23:54 <Forkk> I even built a library for it (inspired by thespian, but using STM instead) https://hackage.haskell.org/package/hactor
19:24:00 <bmuk> Fuuzetsu: haha, good article. I hadn't ever seen algol before.
19:24:00 <Forkk> it needs some work though
19:24:03 <dpn`> nshepperd, man ivory looks awesome
19:24:05 <carter> why the heck is everyone typing so fast
19:24:06 <bjz> nshepperd: it can't do allocation though right?
19:24:07 <carter> its a friday night
19:24:08 <Forkk> need to support exception handling
19:24:14 <bjz> nshepperd: ie. heap allocation
19:24:18 <Fuuzetsu> carter: FRRRRRRRRRRRRRRRIDAY NIGHT, gotta shitpost on #haskell
19:24:23 <carter> Fuuzetsu: :)
19:24:28 <gfixler> carter: everybody's typing for the weekend
19:24:30 <tabemann> I like STM with channels better than actor models because then each thread can listen on more than one channel at once, and you can even send TMVars over them to receive responses without having to pick out responses from all the other messages your receiving in a single mailbox
19:24:34 <bitemyapp> vanila: I was gently teasing you :)
19:24:38 <vanila> alright
19:24:51 <dpn`> carter, saturday morning and I'm procrastinating from writing a bunch of DB stuff in python
19:24:51 <dpn`> :P
19:24:52 <Forkk> tabemann, well, each actor has its own internal STM channel
19:24:59 <nshepperd> bjz: you're not "supposed to" because heap allocation kills realtimeness
19:25:00 <Fuuzetsu> Forkk: I assume you looked into the cloud Haskell stuff?
19:25:01 <vanila> bitemyapp, I'm setting up isabelle and other tools to have a look at seL4 soon
19:25:01 <Forkk> and there's an STM receive function
19:25:07 <Forkk> Fuuzetsu, cloud haskell?
19:25:12 <bitemyapp> vanila: awesome :)
19:25:14 <Fuuzetsu> you're missing out
19:25:20 <bitemyapp> Fuuzetsu: you're a fan?
19:25:21 <Forkk> oh right I saw this before
19:25:26 <vanila> yeah it's really fascinating stuff - I hope it doesn't go over my head too much
19:25:27 <Forkk> never really looked at it
19:25:31 <nshepperd> bjz: but you can call malloc with basically ffi
19:25:32 <bitemyapp> Fuuzetsu: I've been considering making a cloud haskell service wrapper for a library of mine.
19:25:38 <bjz> nshepperd: ah ok. so it's not really aimed at soft realtime?
19:25:40 <Fuuzetsu> bitemyapp: no, but I hear nothing but good things so I may become one if I do use it
19:25:49 <bjz> nshepperd: oh, I mean safe allocation
19:25:52 <_lo> vanila: Sorry, I think you missed the context. bitemyapp was a bit harsh when I joined, and kept arguing that I should practice more.
19:25:58 <bjz> nshepperd: like rust
19:26:01 <Fuuzetsu> anything with the word ‘cloud’ tends to make me sick anyway
19:26:02 <Forkk> I don't know, though. Cloud Haskell seems a bit too much for my purposes though
19:26:14 <carter> Forkk: cloud haskell also tried to hard to erlang
19:26:15 <nshepperd> right, I don't think there's any heap safeness built in
19:26:15 <tabemann> I dislike the word "cloud" as well
19:26:15 <Fuuzetsu> Forkk: sure, just putting it out there
19:26:23 <Forkk> Like, I'm not looking to write a distributed quassel core or anything
19:26:26 <L8D_> omg. butt-to-butt for irssi is too good
19:26:27 <nshepperd> your would have to write your own primitives for that
19:26:28 <dpn`> cloud haskell is like OTP but without erlang ;)
19:26:29 <vanila> _lo, well I'm really interesting in this programming language design space it'd be useful if there was a place to talk about this
19:26:31 <carter> nshepperd: bjz  i think ivory/tower can be used fo rhtat
19:26:32 <bjz> nshepperd: would be cool if it had the linear types/regions combo
19:26:43 <Forkk> L8D_, butt haskell?
19:26:47 <Fuuzetsu> L8D_: I used to run an addon in my browser for that but it made everything slow
19:26:51 <carter> bjz: i've been talking with some folks about how to do do a GC free subset of haskell
19:26:54 <carter> rpbably wont happen for a while
19:26:54 <_lo> vanila: Know of any channels?
19:26:56 <L8D_> Forkk: yep...
19:26:58 <vanila> (that's why I was trying to move to PM before bluntly saying this isn't the right place)
19:27:02 <bjz> carter: that would be neat
19:27:06 <carter> but i want it to happen  or at least be be explored
19:27:07 <vanila> no - you coul dform one
19:27:23 <bjz> carter: I definitely think a pure systems lang would be super cool
19:27:27 <L8D_> Except I have a unicode character set for the double-t so I don't accidentally mess up
19:27:34 <lpaste_> edwardk pasted “alignable” at http://lpaste.net/110963
19:27:35 <heatsink> GCless FP would be useful
19:27:36 <nshepperd> tower is supposed to be used for event handling, or something? I couldn't get it working
19:27:50 <Forkk> anyway, I just want to determine whether FRP could be a good replacement or addition to my existing stuff
19:28:01 <yyttr3> Is there a version of Quicktime compatible with mac OSX? I'm trying to use wxHaskell and I get the following error: "can't load framework: QuickTime ...  mach-o, but wrong architecture"
19:28:06 <carter> Forkk: whats the domain youre doing?
19:28:13 <Forkk> because right now I'm doing event handling manually with IO monads everywhere
19:28:16 <tabemann> it would be nice to have a systems language with type inference, higher-kinded types, real tail call optimization, etc. etc. etc. even if you can't have, say, closures
19:28:19 <edwardk> Is there a version of Alignable from that code snippet that other folks are already using?
19:28:34 <edwardk> I've rederived it a few times in unifiers and the like
19:28:36 <heatsink> align looks like a generalization of zip
19:28:43 <edwardk> heatsink: its very similar to one
19:28:46 <yyttr3> Compatible with wxHaskell I mean.
19:28:57 <bjz> carter: http://www.reddit.com/r/rust/comments/2ejxk6/minutes_from_last_weeks_workweek_lots_here/ck0ytbh
19:28:58 <edwardk> heatsink: the key observation here is if the shape is mismatched it has to reject with empty
19:29:02 <geekosaur> yyttr3, no idea what you are doing but /System/Library/QuickTime.framework comes with the OS
19:29:06 <edwardk> not just drop the mismatched parts
19:29:10 <Forkk> carter, passing messages between threads and stuff. I'm basically making an IRC bouncer
19:29:15 <carter> Forkk: ah
19:29:15 <geekosaur> er /System/Library/Frameworks/QuickTime.framework
19:29:22 <bjz> carter: also http://www.reddit.com/r/rust/comments/2ejxk6/minutes_from_last_weeks_workweek_lots_here/ck0vvaf
19:29:23 <carter> Forkk: STM or Mvars
19:29:31 <Forkk> that's what I'm using right now
19:29:31 <geekosaur> if you installed one from somewhere else, lose it.
19:29:39 <bjz> carter: would the subset be eager? that would be neat
19:29:47 <carter> bjz: haven't thought that far
19:29:48 <Forkk> but it gets pretty messy https://github.com/Forkk/ChatCore/blob/master/ChatCore/UserController.hs
19:29:58 <yyttr3> Trying to run a wxHaskell program in ghci tells me that QuickTime is installed but it's the wrong architecture
19:30:01 <edwardk> heatsink: this winds up being the core of what you need for a unifier. the ability to take a thing and walk down and match up the immediate child parts that match up
19:30:14 <carter> bjz: but the fact that we'll have a mini version of the StrictLanguage pragma landing soonish means that someting could be done
19:30:34 <carter> bjz: but strict doesnt mean eager
19:31:01 <tabemann> what exactly is the difference between strict and eager?
19:31:04 <bjz> carter: basically, I think Rust has pushed the bar much higher for systems langs, but it could be higher, especially in terms of ergonomics
19:31:20 <geekosaur> yyttr3, then you are not using the system QuickTime or you have installed the wrong architecture ghc somehow
19:31:23 <bjz> carter: Haskell/Idris etc. have super slick ergonomics
19:31:38 <carter> bjz: have you noticed how i'm ocd about ergonomics?
19:31:49 <bjz> carter: no
19:31:52 <bjz> :P
19:32:00 <carter> oh, yer trollin
19:32:03 <carter> :P
19:32:26 <bjz> carter: no, actually, I haven't
19:32:41 <yyttr3> I installed ghc from "The haskell platform" a few minutes ago, and quicktime only comes 32bit?
19:33:03 <carter> yyttr3: currently we dont have a 32bit build of GHC for OS X
19:33:13 <carter> at least a 7.8 build
19:33:38 <carter> yyttr3: i think someone was trying to get that working recently, BUT i dont recall definitively
19:33:51 <yyttr3> Then wxHaskell wont work at all on macs?
19:33:52 <GnuBoi> I'm currently writing web api. I just have one question what would be more RESTFUL. To make a GET request to like server, for a public post. /api/post/{post_id}/views or is there any other url pattern to make it more RESTFUL?
19:33:59 <carter> yyttr3: ... how'd you install wx?
19:34:05 <geekosaur> hm, I think that might actually be the case, they moved to something else for the x86_64 framework and the currently distributed QuickTime framework is backward compatibility only
19:34:19 <carter> that could be likely
19:34:20 <geekosaur> so your real problem is getting a WxHaskell that is up to date with Apple's ecosystem
19:34:27 <ski> tabemann : .. and existentials !
19:34:47 <carter> bjz: you've seriously not noticed i'm ocd about api design for my own libs?
19:34:48 <yyttr3> carter: "brew install wxmac --devel ", then "cabal install wx cabal-macosx"
19:34:58 <ski> (can't have a real systems language without existentials)
19:35:09 <carter> :)
19:35:14 <yyttr3> I followed the documentation exactly: http://www.haskell.org/haskellwiki/WxHaskell/Mac
19:35:21 <bjz> carter: I guess if you put it that way, then yes
19:35:38 <geekosaur> ah, right, Apple dropped the QuickTime framework in favor of AVFoundation as of 10.7
19:35:56 <carter> bjz: i actually tend to get stuck and not make progress on coding when i've hit design problem and dont know the answer
19:35:58 <geekosaur> so presumably either or both of WxHaskell or Wx itself has to be updated to use the modern API
19:36:13 <carter> and i tend to not understand what the design problem is until i've figured out the answer half the time
19:36:44 <yyttr3> Is there anything I can do>
19:36:49 <carter> bjz: i dont buy the "existentials are pricey" argument
19:37:19 <heatsink> edwardk: I haven't done exactly that.  I've used something similar-looking to generalize zipWith over index spaces.
19:37:50 <cdc_> > 1 + 1 -- test
19:37:51 <lambdabot>  2
19:38:06 <carter> bjz: we know how to do pretty nice type preserving compilation
19:38:12 <carter> and optimize the shit out of stuff
19:38:31 <carter> plus you can always erase types into a dumber version and optimize there
19:39:31 <carter> bjz: i've actually grown to have the stance that most problems have a hidden 2nd dimension to the trade off space "work really hard at making the trade off go away so i can have nice thing"
19:39:32 <bjz> carter: but can the programmer understand how it optimizes?
19:39:37 <bmuk> Does anyone here use yi as your primary editor?
19:39:37 <carter> sure
19:40:17 <carter> bjz: i dont think rust has a strong claim there, except isofar as how LLVM optimizes C/C++ languages is "obvious"
19:40:23 <bjz> carter: like, a good systems lang can let you write nice code in a way that you *know* what the generated code would look like.
19:40:31 <carter> bjz: not quite true
19:40:38 <heatsink> edwardk: For a unifier, wouldn't you need to the a/b/c types to be Alignable too, so you can recursively unify them?
19:40:38 <carter> you just think that becuase it usually works that way
19:40:46 <bjz> carter: this is true
19:40:57 <edwardk> heatsink: you tie the knot separately with a free monad through the variable type
19:41:00 <bjz> carter: iterators are a case where that falls down
19:41:05 <edwardk> you can use alignable to lift alignable
19:41:06 <carter> iterators are a fucking nasty hack
19:41:13 <edwardk> align (align f) xs ys  -- works two levels deep
19:41:14 <bjz> hah
19:41:48 <heatsink> okay
19:41:53 <carter> bjz: like, i can actually provably show you some examples for array computation where iterators are simply a way to paper over fundamental design flaws
19:42:40 <geekosaur> yyttr3, it looks like the problem is with wxwindows, not the haskell binding. nothing you can do if there's no longer 32 bit ghc on os x
19:43:20 * geekosaur did a quick search and first hit was someone grumping about the app store rejecting a wxwindows app because it used quicktime instead of avfoundation... bad sign)
19:43:23 <carter> bjz: eg, in Eigen and Pretty much every other matrix lib i've seen that nominally has sparse matrices, they don't have the correct reprsentation for Address for Sparse 2d matrices, so they just dont let you work in the address (array offset space) and just give you a few crippled higher level operations and an interator
19:43:25 <carter> *iterator
19:44:20 <carter> bjz: i actually crucially needed Associated Types to give the correct address rep
19:44:24 <carter> for sparse matrices
19:44:43 <carter> otherwise the complexity of a lot of operations is worse by a factor of log n
19:45:28 <yyttr3> gookosaur: I assume gtk2hs will work at the very least.
19:45:43 <edwardk> heatsink: so if you write down something like newtype Var s t = Var { runVar :: STRef s (Maybe (Free t (Var s t))) } -- then you can work with Free t (Var s t) as expressions with unification variables in it
19:45:56 <edwardk> and Var s t  -- as unification variables
19:46:01 <yyttr3> I though wxHaskell was the defacto GUI library for haskell though? So It should work on all platforms.
19:46:14 <carter> yyttr3: ... theres no defactor one yet
19:46:16 <carter> you should write one!
19:46:25 <edwardk> heatsink: ermine uses more or less that approach in the typechecker
19:46:42 <ski> edwardk : no aliasing ?
19:46:55 <edwardk> ski: we throw a type alias at it, but that is about it
19:48:20 <geekosaur> yyttr3, any non-native gui on OS X is a problem
19:48:28 <pqmodn> .
19:48:49 <yyttr3> carter: Haskell's popular enough. I find it strange that a gui library isn't apart of the standard haskell library
19:49:10 <carter> whats a good gui lib look like?
19:49:15 <geekosaur> wxhaskell has this problem, gtk2hs has the problem that getting gtk for os x at all sanely requires brew or macports, and nobody's done a native Aqua binding because neither objc nor c++ is particularly friendly to binding to other languages
19:49:32 <geekosaur> also there is a standard gui library, sort of. opengl
19:49:34 <carter> geekosaur: though language inline c sidestep it nice
19:49:43 <carter> *nicely
19:49:49 <carter> yyttr3: what platform do you wanna dev for?
19:49:58 <geekosaur> because it's pretty much the only thing that is truly cross platform any more. but it's pretty raw
19:50:37 <carter> yyttr3: if you're familiar with OS X stuff,  https://hackage.haskell.org/package/language-c-inline might be the best way to roll
19:50:44 <carter> or doing native whatever platform
19:50:50 <edwardk_> er anyways before i unexpectedly had to reboot. ski: https://github.com/ermine-language/ermine/blob/master/src/Ermine/Unification/Meta.hs#L129 is the meta variable type we use, with the aliases we tend to use given below it
19:51:08 <edwardk_> one thing i do like about unbound is they have a much less noisy story for meta variables, but i like not having to live in a fixed monad to work
19:51:09 <yyttr3> carter: Preferably I'd like a cross platform solution. I'm fairly use to working in languages with cross platform solutions.
19:51:29 <carter> yyttr3: ... but do guis actually work the same in different platforms?
19:51:43 <tabemann> GUIs certainly aren't crossplatform
19:51:58 <_lo> (I gave a kernel as an example, after much consideration and encouragement from seL4)
19:52:13 <_lo> woops, accidnetal paste)
19:52:18 <geekosaur> this is why most "cross platform gui" stuff is web based these days
19:52:33 <carter> the future is ghcjs :P
19:52:34 <tabemann> probably the closest thing to a crossplatform GUI is raw X... because Mac OS X comes with an X server, and you can easily get Xming for Windows
19:52:37 <carter> or threepeny gui
19:52:40 <yyttr3> carter: I suppose the JVM doesn't count, but right now I just want it to run of OS X
19:52:53 <ezrios> closest thing to a crossplatform GUI is the web
19:52:58 <carter> yyttr3: ok, language c inline might be the best way to roll if you want pretty polished guis on mac
19:53:08 <carter> and nice native sdk powahs
19:54:01 <carter> yyttr3: because if you want all the native nice things of a platform
19:54:04 <carter> you need to talk with them
19:54:26 <ski> edwardk_ : well, i meant aliasing between logic variables ..
19:54:41 <ski> edwardk_ : btw, how do you fit skolems into that ?
19:54:54 <geekosaur> (also note that using either macports or homebrew to get gtk means using them to get a working ghc / haskell platform / gtk2hs, brew's haskell platform is broken, and macports hasn't updated to the latest platform yet. I hope to make a start on that this weekend, $DEITY willing)
19:55:14 <edwardk_> ski: we used to use a separate constructor, now we use a check to make sure it didn't get bound to a concrete thing
19:55:17 <carter> geekosaur: you need not use ghc via brew to use brew libs
19:55:36 <carter> geekosaur: lemme know if you need help lobbying a PR on brew
19:55:45 <geekosaur> no? I know brew has the same libiconv horror that macports does (and for the same reason, thanks Apple)
19:55:54 <yyttr3> So, unless I want to essentially use another language via FFI, I can't. That's disappointing.
19:55:56 <carter> geekosaur: what issue?
19:55:59 <edwardk_> ski: https://github.com/ermine-language/ermine/blob/master/src/Ermine/Unification/Meta.hs#L284
19:56:02 <vanila> ski, did you read the new logic programming thing?
19:56:10 <carter> yyttr3: well, someone as to do the hard work
19:56:18 <geekosaur> apple's ancient iconv vs. pretty much any modern software, including gtk, requiring a nnewer one
19:56:19 <carter> to give us nic ethings
19:56:30 <carter> geekosaur: whats that gotta do with ghc?
19:56:35 <geekosaur> and without ugly linker tricks, getting apple's instead gets you a core dump
19:56:38 <ski> vanila : hm, i didn't read it yet. ty for reminding me
19:56:40 <edwardk_> we construct skolems like any other meta variable, then merely when we're done with the scope that introduced them check that they didn't get bound to a concrete term and that all my skolems are still distinct and they they haven't changed rank outward
19:56:50 <geekosaur> gtk2hs, the topic of my comment, is what it has to do with ghc
19:57:01 <carter> ... i've not seen this issue
19:57:03 <edwardk_> ski: that lets use use normal unification variables for all of our skolems
19:57:07 <carter> could it be that i've been using brews all along?
19:57:25 <yyttr3> Haskell's fairly old now, and still popular. It should have a nice GUI library by now.
19:57:31 <carter> yyttr3: why
19:57:34 <geekosaur> but ghc itself uses iconv; while it will work with apple's , gtk will not, and linking multiple iconv libraries will cause core dumps
19:57:36 <carter> whats a good gui look like
19:57:50 <geekosaur> so you need ghc runtime linked against an iconv compatible with gtk to use gtk2ks
19:57:51 <carter> geekosaur: ... i've been using standard ghc with gtk things
19:58:03 <carter> and the gtk things were brew built
19:58:07 <carter> been a while
19:58:08 <carter> but i have
19:58:24 <ski> edwardk_ : hmm .. i used a boolean flag to distinguish between skolems and logvars. however i didn't really check for escape
19:58:48 <geekosaur> for a while brew was using apple's iconv. I iknow more recently they migrated away and ended up with the same iconv problem macports has had for a while, due to needing a later one than apple ships
19:58:51 <carter> geekosaur: anyways, if you have trouble getting the brew patches merged, holler on the githubs
19:59:05 <carter> @google iconv
19:59:06 <lambdabot> http://php.net/manual/en/book.iconv.php
19:59:06 <lambdabot> Title: PHP: iconv - Manual
19:59:13 <L8D_> What's the modulo thing for integrals?
19:59:17 <yyttr3> I can have a simple python program on a new computer running in about ~10 minutes, including installing python and a gui lib.
19:59:25 <L8D_> omg my nick
19:59:37 <carter> yyttr3: saying that wont make it happen faster
19:59:44 <carter> yyttr3: have you see th QT Quick stuff?
19:59:53 <edwardk_> ski: we used to just have them be a variable like any other but with no reference buried in them, merging them into the same kind of thing made for fewer cases to consider in the common case and a small check at the end as they go out of scope, which i was already going to have to do got a little more complicated to track distinctness
20:00:01 <yyttr3> No, I haven't?
20:00:02 <carter> https://hackage.haskell.org/package/hsqml yyttr3  is another option
20:00:12 <carter> now you have
20:00:22 <L8D_> > 10 % 5
20:00:23 <lambdabot>  2 % 1
20:00:23 <carter> http://www.gekkou.co.uk/software/hsqml/
20:00:48 <L8D_> > 10 `mod` 5 :: Intergal a => a
20:00:49 <lambdabot>  Not in scope: type constructor or class ‘Intergal’
20:00:50 <lambdabot>  Perhaps you meant one of these:
20:00:50 <lambdabot>    ‘Integral’ (imported from Prelude),
20:00:50 <lambdabot>    ‘Interval’ (imported from Data.Number.Interval)
20:00:55 <L8D_> > 10 `mod` 5 :: Integral a => a
20:00:56 <lambdabot>  0
20:01:34 <ski> edwardk_ : i had a global flag which interchanged skolems and booleans
20:01:38 <yyttr3> I'll try it,
20:01:48 <ski> edwardk_ : er, which interchanged skolems and logvars
20:02:24 <carter> yyttr3: anyways, the problem is perhaps that people set too high a bar for what they want out of a portable haskelly gui, and then dont settle for something less than some platonic ideal
20:02:30 <carter> rather than using some icky hacky
20:02:38 <edwardk_> ski: basically we found that by removing the flag for tracking what was skolem we had fewer cases to consider overall and the extra complications in the escape check weren't all that big or all that slow, so a lot of code melted away
20:02:42 <L8D_> > mod (10 :: Double) (5 :: Double)
20:02:43 <lambdabot>  No instance for (GHC.Real.Integral GHC.Types.Double)
20:02:43 <lambdabot>    arising from a use of ‘GHC.Real.mod’
20:02:51 <L8D_> What's going on?
20:02:58 <carter> or at least, no one has show me a truly portable gui thats also high level and nice
20:03:13 <HeladoDeBrownie> :t mod
20:03:14 <vanila> carter, I don't think that exists [sad truth about GUIs]
20:03:14 <lambdabot> Integral a => a -> a -> a
20:03:18 <carter> vanila: yup
20:03:22 <HeladoDeBrownie> L8D_, there is no Integral Double instance in scope.
20:03:22 <edwardk_> ski: we figured it out when we were working on how to do partial type signatures and how to generalize the way to deal with inferring types for binding groups
20:03:25 <vanila> carter, The best is i know of tcl/tk
20:03:33 <HeladoDeBrownie> (And there isn't really a reasonable one.)
20:03:37 <carter> vanila: roughly: Portable, Pretty, Nice to Use, pick 2
20:03:40 <L8D_> HeladoDeBrownie: How would I import that?
20:03:49 <carter> haskellers seems to get stuck on Portable
20:03:55 <edwardk_> ski: btw- i totally didn't think to see if you were in the area when i was out at ICFP this year.
20:04:01 <vanila> carter, it's weird - there's nothing stopping alll 3 but yeah it just doesn't happen
20:04:09 <HeladoDeBrownie> L8D_, you don't, you use something that doesn't require Integral.
20:04:17 <carter> vanila: well, i think we'd be better off with a different amazing gui lib for each OS
20:04:27 <L8D_> HeladoDeBrownie: Is there a different modulo function for doubles then?
20:04:28 <carter> and then say "design a different gui for each OS"
20:04:49 <carter> vanila: but we're so used to building tools that are nominally portable
20:04:51 <vanila> hmmm
20:04:54 <HeladoDeBrownie> L8D_, I'm not sure, I don't recall seeing one, I'm trying to look it up if it exists
20:05:12 <HeladoDeBrownie> L8D_, Data.Fixed.mod' maybe?
20:05:25 <vanila> I do think that's pragmatic
20:05:25 <yyttr3> GUI programming on the JVM is fairly portable and nice.
20:05:58 <carter> .... i hate every java gui i see on os x, they all look weird
20:06:03 <carter> vanila: yeah
20:06:14 <L8D_> HeladoDeBrownie: That works thanks
20:06:17 <carter> i think its the only approach that makes the whackamole tractable
20:06:17 <ski> edwardk_ : apparently i missed it being in Gbg this year
20:06:35 <yyttr3> That's because no one knows how to write for OS X. Apple provides LookAndFeels for GUI applications.
20:06:39 <tabemann> if we want portable doing what Swing does is probably the best we can get
20:06:52 <carter> portable is also ugly
20:07:26 <carter> yyttr3: people know how to write for OS X
20:07:35 <carter> its just that that community is a different one that you interact with
20:07:44 <yyttr3> Move the menu bar, change the look and feel conditionally on the OS, and a few other minor changes and it will look nice.
20:07:45 <vanila> I was learning XCB a bit recently, wrote a haskell binding and implemented this: http://i.imgur.com/kML9nsA.png
20:07:47 <yyttr3> What do you mean?
20:07:59 <L8D_> Is there a way to show a double without ".0" if it is an integer?
20:08:08 <vanila> but XCB is very hard to use beyond this..
20:08:21 * hackagebot toysolver 0.1.0 - Assorted decision procedures for SAT, Max-SAT, PB, MIP, etc  http://hackage.haskell.org/package/toysolver-0.1.0 (MasahiroSakai)
20:08:55 <yyttr3> Nevermind, stupid question.
20:09:18 <carter> yyttr3: i guess my point is that i've seen a lot of people try very hard to build gui tools that are nice and portable
20:09:23 <carter> and they all fail
20:09:33 <carter> or at least get symied
20:09:48 <carter> yyttr3: if you wanted a very very dumb portable gui, threepenny gui might be sweet
20:09:59 <carter> https://hackage.haskell.org/package/threepenny-gui
20:12:15 <ezrios> carter: how is the learning curve for this library?
20:12:15 <HeladoDeBrownie> L8D_, well the Show instance for Double adds the point, so it seems to me you'd have to check that there is no fractional part and if so use show on the number converted to an integer, using floor or something.
20:12:19 <yyttr3> I'll try it. I'm still searching for a solution to wxHaskell. I'm still hoping I can get it to worksomehow.
20:12:21 <carter> ezrios: which lib?
20:12:24 <ezrios> tried to learn reactive-banana and got lost
20:12:26 <ezrios> carter: threepenny
20:12:35 <carter> ezrios: its very bare bones
20:12:37 <HeladoDeBrownie> L8D_, something like \x -> if x `mod'` 1 then show (floor x) else show x
20:12:39 <carter> i've not really used it
20:12:44 <carter> but its pretty small
20:12:55 <L8D_> HeladoDeBrownie: ok thanks
20:13:19 <carter> ezrios: gui apps are kinda weird... at least to me, its like desiging a system archtecture
20:13:46 <carter> decomposing your compute from interaction handling is probably a good design pattern for gui'd apps right?
20:13:49 <carter> think client server?
20:14:18 <carter> idk
20:14:37 <carter> ezrios: either way, its probably the best "zero dependencies" gui lib i've seen for haskell yet
20:14:57 <carter> ezrios: yyttr3  i've toyed withtrying to port the Racket Lang gui lib to haskell
20:14:59 <vanila> if anyone is expereinced with X you could help improve it :)
20:14:59 <carter> but its HUGE
20:15:21 <merijn> carter: So you're in th Bay area next week? :)
20:15:26 <carter> merijn: yeah
20:15:28 <yyttr3> carter: Have you had any success?
20:15:33 <carter> still need to finalize travel
20:15:40 <carter> yyttr3: didn't do it
20:16:05 <carter> yyttr3: its very hard to translate OO / Mixin kinda idioms to simple haskell
20:16:23 <merijn> carter: Let me know when you're there :)
20:16:37 <merijn> Or well, here, I guess
20:16:39 <yyttr3> carter: Assuming I wanted to create a GUI library myself, where would I start? I don't know much about these things.
20:16:52 <carter> yyttr3: hrmm
20:16:55 <carter> good question
20:17:10 <carter> yyttr3: native gui ?
20:17:10 <merijn> Step 1) Question your sanity :)
20:17:17 <carter> merijn: be nice
20:17:35 <merijn> I mean that in the nicest way possible
20:17:44 <merijn> Hell, I started designing one
20:17:45 <carter> merijn: i'll be around somepoint thurs/late wednesday -sunday early afternoon, assumign the travel details work out
20:17:52 <yyttr3> would I have to use the FFI?
20:17:58 <carter> yyttr3: ffi is really easy
20:18:10 <merijn> I'm not saying you shouldn't do it, I'm just saying it helps to bed in that cackling mad genius stage :)
20:18:29 <merijn> yyttr3: FFI is a piece of cake, assuming you know the basics of C
20:18:43 <carter> yeah, haskell FFI is really nice to use
20:18:50 <yyttr3> I know a lot of C, that's all we used in my undergraduate
20:18:55 <carter> yyttr3: also, the inline objective c thing i linked earlier will help A LOT
20:18:59 <carter> i think
20:19:00 <merijn> yyttr3: Right, then the FFI will be trivial
20:19:48 <merijn> yyttr3: Most people I see run into confusion with FFI are people who don't really understand the basics of linking, symbols, etc. if you can manage to build a C library and link it into an executable you should know plenty :)
20:20:58 <yyttr3> merijn: I can. So I assume  I can create a library by calling raw X11 in Haskell?
20:21:13 <carter> yyttr3: ... but you probably want to use something nicer than X on each platform
20:21:15 <merijn> yyttr3: Actually, I wrote a minimal skeleton example of how to have a C main function and call haskell for someone a few weeks back, maybe it gives you an idea of what to expect: https://gist.github.com/merijn/4a0fee2b3a5ef3476aa4
20:21:39 <yyttr3> Thank you
20:21:59 <merijn> You don't have to have a C main function, which means you can even ignore most of that
20:23:41 <yyttr3> What about openGL, i've never use it. I wouldn't assume it's possible to build a GUI library using that?
20:24:00 <merijn> yyttr3: Sure
20:24:14 <MP2E> you could, it'd be from scratch, but it's possible
20:24:16 <yyttr3> Since that's already built into haskell
20:27:12 <carter> not built in
20:27:17 <carter> just a portable lib
20:27:24 <merijn> yyttr3: That's just using the FFI to call the OpenGL libs, though
20:37:55 <tabemann> OpenGL has disadvantages w.r.t. trying to use it for a GUI
20:37:59 <L8D_> @hoogle a -> [a] -> Maybe a
20:38:01 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
20:38:02 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
20:38:02 <lambdabot> Prelude asTypeOf :: a -> a -> a
20:38:15 <tabemann> e.g. there's no easy way to support working with multiple windows simultaneously with OpenGL
20:38:37 <tabemann> since the OpenGL context is implicit
20:39:22 <tabemann> okay, I'm not going to use tls, and instead am going to use HsOpenSSL
20:39:40 <Fuuzetsu> haha it compiles!
20:39:41 <tabemann> since HsOpenSSL has good support for nonblocking operations, while tls appears to have none
20:39:52 <Fuuzetsu> it only took 2 days to get this to compile with Text
20:39:58 <Fuuzetsu> now for it to crash ;_;
20:40:03 <tabemann> I'd've preferred to've used a pure-Haskell solution here, but oh well
20:41:08 <tabemann> I still can't believe that the developer of tls wouldn't've thought that someone might need to use it nonblocking though
20:43:20 <merijn> tabemann: Why do you need non-blocking in haskell?
20:44:40 <merijn> carter: Oh, btw, apparently next Thursday is also the Haskell Hackers meetup in Mountain View, so if you're looking for a place to show off your cool stuff
20:44:57 <carter> merijn: i dont have a car
20:45:04 <carter> and i wont have a good presentation / demo set yet
20:45:18 <merijn> ah, too bad
20:45:27 <carter> merijn: though tim did ask if i wanna come by and present some time
20:45:32 <carter> not sure if next week is sane
20:45:39 <carter> wrt me giving a talk i'll be happy with
20:45:56 <L8D_> @hoogle (IO a, b) -> IO (a, b)
20:45:56 <lambdabot> No results found
20:46:09 <L8D_> @hoogle Monad m => (m a, b) -> m (a, b)
20:46:09 <lambdabot> No results found
20:46:24 <merijn> That's strength, but I dunno if it's in any library
20:46:40 <merijn> :t \(x, y) -> fmap (,y) x
20:46:41 <lambdabot> Functor f => (f a, t) -> f (a, t)
20:46:56 <tabemann> merijn: I need to be able to read and write to a connection near-simultaneously
20:47:16 <merijn> tabemann: So one thread for reading, one thread for writing?
20:47:30 <tabemann> I ideally would like to be able to read in one thread and write in another thread, but that obviously would be unsafe with the way the tls library is designed
20:48:06 <tabemann> and I can't even do that with plain sockets, due to the file descriptors being in MVars internally
20:48:40 <merijn> huh
20:48:48 <merijn> You most definitely can do that with plain sockets
20:48:58 <merijn> Else none of the socket code I've ever written would work
20:49:57 <tabemann> okay so there's separate locks for reads and writes on Handles?
20:51:04 <merijn> tabemann: I'm not sure about that, but Socket's don't use Handles
20:51:58 <L8D_> @pl \a -> fmap concat $ mapM readFile a
20:51:58 <lambdabot> fmap join . mapM readFile
20:53:01 <tabemann> okay, you were using Network.Socket not Network
20:53:15 <merijn> Even Network returns a Socket
20:53:27 <merijn> oh, I guess accept doesn't
20:54:41 <merijn> Entirely unrelatedly
20:54:53 <tabemann> wait, why does Network.Socket.recvFrom return a String?
20:55:02 <merijn> tabemann: Use Network.Socket.ByteString
20:55:17 <merijn> Does anyone know a good trie library for haskell? ByteString preferably
20:59:52 <tabemann> hmm I should check whether HsOpenSSL supports simultaneous reads and writes from separate threads
21:00:07 <tabemann> as that's what I ideally would want to do
21:03:02 <Fuuzetsu> hm, there's (not . (n ==)) here, I'm afraid to look for the Eq instance
21:03:02 <rqiu> test
21:06:36 <joshcough> can anyone tell me how to detect the current operating system from some haskell code?
21:11:36 <merijn> How reliable does it have to be :p
21:13:53 <Makoryu> joshcough: Test for the existence of standard files
21:14:18 <Makoryu> Obviously this will fail on some installations
21:14:20 <joshcough> http://hackage.haskell.org/package/base-4.7.0.1/docs/System-Info.html#v:os
21:14:35 <Total_1mmersion> Is it possible to store the alternative of a value as a value itself? For example, I would like to be able to lookup Left 3 in a list [(Left, "left"), (Right, "right")] to get a string, but I don't know how to do that without using a function (isLeft/isRight) or pattern matching. I don't want to use a function because I want to be able to serialize the association list.
21:14:36 <merijn> Makoryu: That's much worse than System.Info
21:15:02 * Makoryu shrugs
21:15:59 <heatsink> Left 3 is not in that list
21:16:12 <heatsink> Left is in that list
21:16:27 <Total_1mmersion> I know, I want it to return "left" because the input is the Left alternative
21:17:00 <heatsink> What is wrong with using isLeft?
21:17:25 <heatsink> > (\x -> lookup (isLeft x) [(True, "left"), (False, "right")]) (Left 3)
21:17:27 <lambdabot>  Just "left"
21:18:47 <Total_1mmersion> My actual use case is with JSON Values, which have more than 2 alternatives
21:20:11 <Total_1mmersion> lookup (Number 5) [(Object, "obj"), (Number, "num"), ...]
21:20:27 <heatsink> I still think the right solution is to map the values to an enumerative type.
21:20:50 <Total_1mmersion> Yeah I think that's the only way to do it
21:23:25 <Fuuzetsu> can someone tell me what ‘o’ does in vim?
21:23:27 <Total_1mmersion> I'm a little surprised there is no built-in way to store alternatives and check for equality
21:23:34 * Fuuzetsu only broke 15 out of 525 tests!
21:24:01 <wakalabis> @Fuuzetsh: it creates another row of text below the current line
21:24:01 <lambdabot> Unknown command, try @list
21:24:16 <wakalabis> And goes to insert mode
21:24:47 <Fuuzetsu> interesting
21:24:51 <dehflingus> hrm, never knew that one
21:24:52 <Fuuzetsu> so is it like go down and insert mode?
21:25:04 <wakalabis> go dow, insert line and go to insert mode
21:25:04 <Fuuzetsu> dehflingus: seems like a key one would press sometimes…
21:25:14 <wakalabis> it creates a new line
21:25:20 <Fuuzetsu> ok, great
21:25:25 <Fuuzetsu> hopefully easy fix
21:25:27 <wakalabis> I use it all the time
21:25:32 <slack1256> me too
21:25:34 <dehflingus> this is true, ive always just arrowed around and hit a when i wanted to add something in
21:25:39 <dehflingus> that.. and dd
21:25:46 <dehflingus> and thats all i ever really use
21:25:47 <dehflingus> ;p
21:26:31 <wakalabis> Guys, I was reading an article on free monads.
21:26:39 <wakalabis> It defined a type: data FixE f e = Fix (f (FixE f e))
21:26:46 <heatsink> I think the right name for "alternative" is data constructor.
21:26:59 <wakalabis> I could not derive Show
21:27:12 <wakalabis> How can I do that?
21:27:20 <merijn> wakalabis: You can, but not using the standard deriving syntax
21:27:48 <wakalabis> merjin:  will I have to "manually" do it?
21:28:00 <wakalabis> -> instance Show FixE ...
21:28:18 <merijn> wakalabis: You need to use the StandaloneDeriving extension and then you can write "instance (Show a, Show (f a)) => Show (FixE f a)"
21:28:30 <merijn> I think, I'm not sure I got it right :)
21:28:44 <wakalabis> merjin: thanks! I will try that and report back
21:28:58 <merijn> wakalabis: GHC is not smart enough to infer the entire thing is printable without some help
21:29:56 <wakalabis> I can never remind by heart language prama
21:30:08 <wakalabis> {-# LANGUAE xxxxxx #-}
21:31:21 <merijn> It means you need to use {-# LANGUAGE KitchenSink #-} more often :D
21:31:34 <wakalabis> LOL
21:31:38 <MP2E> haha, is that a real pragma? :P
21:32:00 <wakalabis> MP2E: It imports x-rated content
21:32:35 <wakalabis> merjin: this is what I got: on type-variable argument in the constraint: Show (f a)
21:32:36 <wakalabis>     (Use -XFlexibleContexts to permit this)
21:32:37 <wakalabis>     In the context: (Show a, Show (f a))
21:32:38 <wakalabis>     While checking an instance declaration
21:32:39 <wakalabis>     In the instance declaration for `Show (FixE f a)'
21:32:56 <merijn> MP2E: No
21:33:18 <merijn> wakalabis: Solution: Turn on FlexibleContexts ;)
21:33:46 <merijn> The FlexibleContexts warning is probably the only "use this extension warning" that is actually correct (i.e., it solves the problem producing the warning)
21:34:17 <merijn> The haskell report is very conservative in what it allows for typeclass contexts
21:34:19 <MP2E> agreed, I never hesitate to add FlexibleContexts if I see that error message. There's no reason not to
21:34:23 <MP2E> afaik anyway
21:35:10 <lpaste_> heatsink pasted “A paradox” at http://lpaste.net/110968
21:36:24 <wakalabis> merjin:
21:36:36 <wakalabis> No instance for (Show (f (FixE f e)))
21:36:36 <wakalabis>       arising from the 'deriving' clause of a data type declaration
21:36:37 <wakalabis>     Possible fix:
21:36:38 <wakalabis>       add an instance declaration for (Show (f (FixE f e)))
21:36:39 <wakalabis>       or use a standalone 'deriving instance' declaration,
21:36:51 <wakalabis>            so you can specify the instance context yourself
21:36:52 <wakalabis>     When deriving the instance for (Show (FixE f e))
21:37:27 <merijn> oh, right
21:38:24 <wakalabis> this is the same as what I got initially :)
21:38:24 <merijn> I should've written "deriving instance (Show a, Show f a) => Show (FixE f a)", which needs -XStandaloneDeriving
21:39:12 <merijn> http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html#stand-alone-deriving
21:42:48 <wakalabis> merjin: http://lpaste.net/110969
21:43:02 <wakalabis> merjin: Am I missing something?
21:43:22 <heatsink> I can compile deriving instance Show (f (FixE f a) => Show (FixE f a)
21:43:26 <merijn> wakalabis: Parenthesis
21:43:35 <merijn> "Show (f a)"
21:43:52 <merijn> Now it's parsed as "((Show f) a)"
21:45:01 <heatsink> I don't think it's possible to take Show (f a) and deduce Show (f (FixE f a))
21:46:34 <nshepperd> oh, you probably actually need Show1 f here
21:46:46 <merijn> heatsink: No, hat's why there's a "Show a" constraint
21:47:18 <dashster18> Hi
21:47:36 <dashster18> Anyone have advice for completing chapters 20+ in RWH on a Windows machine :S
21:47:36 <merijn> heatsink: From "(Show a, Show (f a))" you can derive "Show (FixE f a)", from which "Show (f (FixE f a))" follows trivially
21:48:08 <merijn> nshepperd: Why?
21:48:29 <nshepperd> merijn: I don't think it does, Show (f a) is different from (forall a. Show (f a))
21:48:36 <heatsink> How do you derive Show (FixE f a) from Show a and Show (f a)?
21:48:59 <merijn> heatsink: The same way you derive "Show" for any data type?
21:49:31 <heatsink> merijn: You mean, by first deriving 'Show' for the type of each field?
21:50:32 <heatsink> which means, you first have to derive Show for the type f (FixE f a)
21:50:52 <merijn> Which follows from "Show (f a)" and "Show a"
21:51:08 <nshepperd> no it doesn't
21:51:14 <merijn> Why not?
21:51:18 <nshepperd> Show (f a) could be a special case, for all you know
21:51:25 <nshepperd> it's not universally quantified over a
21:52:04 <nshepperd> you need Show (f (FixE f a)) which is different from Show (f a)
21:52:23 <merijn> hmm
21:52:26 <nshepperd> and you can't turn 'FixE f a' into 'a'
21:52:36 <wakalabis> merjin: like this: http://lpaste.net/110971?
21:52:42 <nshepperd> Show1 does provide the universal quantification you need
21:53:00 <heatsink> wakalabis: See my annotation on your earlier paste
21:53:14 <merijn> Maybe I should test more before typing :)
21:54:04 <nshepperd> I think (Show a, Show1 f) should do the trick, assuming ghc is smart enough to figure out the instance
21:54:13 <merijn> hmm, there appear to be only 2 actual trie implementations on hackage, TrieMap and bytestring-trie, anyone know anything about their performance/popularity?
21:54:44 <wakalabis> merjin: it worked ! thanks
21:55:00 <wakalabis> now I have to read the link you gave me and learn WHY it worked :D
21:55:18 <merijn> 1 reverse dependency for TrieMap and 1 for bytestring-trie, that's not reassuring :\
21:56:42 <heatsink> wakalabis: look at how merijn is spelled
21:56:48 <nshepperd> oh, I guess (Show a, Show (f (FixE f a))) works wherever the second can be inferred, which should include through Show1, that makes more sense
21:57:30 <merijn> heatsink: It's how you spot Americans and Brits on the web
21:57:38 <heatsink> huh?
21:57:51 <MP2E> haha
21:58:12 <nshepperd> it's how you spot people who don't know about tab completion yet :)
21:58:14 <merijn> heatsink: So far it appears native English speakers feel a compulsion to correct the "wrong" order letters
21:58:19 <merijn> :)
21:58:31 * hackagebot persistent-mongoDB 1.4.4.4 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-1.4.4.4 (GregWeber)
21:58:53 <heatsink> Um. both Americans and Brits would be native English speakers.
21:59:12 <merijn> Yes, that was my point
21:59:30 <heatsink> oh, I see.
21:59:57 <wakalabis> LOL
22:00:04 <wakalabis> I didn't know about tab completion!
22:00:10 <heatsink> I have heard at least one Indian say "Didjikstra"
22:00:26 <solatis> merijn: i think many non-native people get taught british english, tho
22:00:58 <solatis> what's with the netsplits today?
22:01:53 <wakalabis> haskell community is, by far, the greatest I've seen
22:02:23 <solatis> wakalabis: #boost is pretty awesome too if c++ is your thing
22:02:36 <merijn> solatis: ##c++ isn't >.>
22:02:50 <solatis> no, it is not by a very, very large margin
22:02:55 <solatis> it's one of the most hostile irc channels i know
22:02:58 <wakalabis> solatis: I'll try #boost too, then
22:03:07 <merijn> solatis: Together with ##c? ;)
22:03:16 <wakalabis> and avoid ##c
22:03:16 <MP2E> those are some hostile irc channels heh
22:03:26 <MP2E> went there once, left about 15 minutes later
22:03:31 <solatis> yeah
22:03:47 <wakalabis> this is the proof: https://gist.github.com/quchen/5280339
22:04:28 <solatis> i feel like in those channels you always have to defend your right to even ask a question
22:04:46 <solatis> and the people that actually are knowledgable on the subject stay away from those channels
22:05:01 <solatis> (and #boost is where a lot of very, very talented c++ programmers hang out in)
22:05:03 <MP2E> you do. "hey I want to do X." Answer: "Why would you want to do X? No one in their right mind would want to do X instead of Y!"
22:05:12 <solatis> MP2E: haha yeah
22:07:00 <solatis> wakalabis: haha that paste is actually quite interesting to read
22:07:12 <solatis> counter-trolling the troll by being polite
22:07:41 <MP2E> interestingly enough, someone read that post and decided to come into #haskell and troll to see what would happen, and was subsequently banned :P
22:07:45 <MP2E> I guess they weren't in the mood that day hehhe
22:08:04 <MP2E> to be fair, you can't try to convert *every* troll >_>
22:08:05 <wakalabis> hehehe
22:18:33 * hackagebot prove-everywhere-server 0.1.1 - The server for ProveEverywhere  http://hackage.haskell.org/package/prove-everywhere-server-0.1.1 (ShoheiYasutake)
22:20:23 <alphonse23_> what are dependent types?
22:21:08 <MP2E> types dependant on data, this is useful for proving properties about a program at compile-time
22:21:21 <octopuscabbage> can anyone tell me a type that is both integral and fractional
22:21:41 <merijn> octopuscabbage: None
22:21:54 <octopuscabbage> merijn: wait, really?
22:21:56 <merijn> Use round/fromIntegral as appropriate
22:22:06 <MP2E> alphonse23_: take a sized vector type in a dependently typed language, if you make a head function for said vector you could ensure at compile-time that it wasn't passed an empty vector
22:22:08 <merijn> octopuscabbage: Well anything that is Integral by definition can't be fractional
22:22:13 <MP2E> otherwise it would fail with a compiler error
22:22:41 <octopuscabbage> okay hmm, let me just post my code it's small enough that you can see it
22:22:53 <octopuscabbage> i'm having a weird issue with a type and i think i just don't understand fromIntegral correctly
22:23:11 <merijn> octopuscabbage: Likely problems leading to this question are: 1) you're not using round/fromIntegral or 2) you're trying to do Integer division using / (use div)
22:23:45 <kvanb> I would consider it a bug in other languages that you can do integer division with /
22:23:49 <kvanb> it feels so wrong to do, even
22:23:59 <octopuscabbage> http://lpaste.net/110973
22:24:10 <alphonse23_> MP2E: is it like inferring the type based on the value assigned to it during compile time?
22:24:24 <octopuscabbage> should i just use integer division in findFirstFactor
22:24:48 <kvanb> add types
22:24:54 <kvanb> this is confusing with no type annotations
22:25:09 <merijn> octopuscabbage: Looks like you want integer division, yes, but hard to tell without types
22:25:15 <alphonse23_> MP2E: and then using that information to reason about what it will do, during runtime. Like you said, if a vector is assigned to a variable that has a size, you know it's no empty. And now you can use that information to assume it's not null? I guess...
22:25:18 <kvanb> ghc makes bad decisions sometimes too
22:25:20 <merijn> > 19 `div` 8
22:25:22 <lambdabot>  2
22:25:29 <octopuscabbage> http://lpaste.net/110973
22:25:31 <merijn> > 15 `div` 5
22:25:32 <lambdabot>  3
22:25:36 <kvanb> like making things that should be Double Int instead or vice verca or even Integer
22:26:18 <octopuscabbage> oh sorry i have conceal on
22:26:25 <kvanb> whats the error
22:26:25 <octopuscabbage> those division signs are `div`
22:26:29 <octopuscabbage> i have no error now
22:26:34 <octopuscabbage> because i changed it to `div`
22:26:49 <octopuscabbage> the division signs in that were origianlly /
22:26:56 <octopuscabbage> should i just use `div` when i want integer divison
22:27:10 <kvanb> :t factors
22:27:11 <lambdabot> Not in scope: ‘factors’
22:27:22 <kvanb> i swear there was a thing to do this
22:27:26 <merijn> octopuscabbage: Yes
22:27:27 <merijn> :t div
22:27:28 <lambdabot> Integral a => a -> a -> a
22:27:32 <merijn> :t (/)
22:27:33 <lambdabot> Fractional a => a -> a -> a
22:27:53 <octopuscabbage> kvanb: There might be a thing to do this but i'm doing it for project euler so i don't want the library function haha
22:27:54 <MP2E> alphonse23_: Well a null vector/list can only be size 0 if you set the datatype up correctly. It's not quite inference because you have to set up the datatype to be able to do this, but in dependently typed languages it's pretty easy to make the type depend on the value.
22:27:55 <merijn> octopuscabbage: (/) explicitly only works for Fractional data (which by definition can't be Integral)
22:28:05 <MP2E> alphonse23_: a good way to get some better intuition on it is to read this : http://jozefg.bitbucket.org/posts/2014-08-25-dep-types-part-1.html
22:28:12 <octopuscabbage> i understand now
22:28:14 <MP2E> it covers lightweight dependent types in haskell
22:28:22 <MP2E> not quite 'the real thing' but it introduces the concepts
22:28:29 <octopuscabbage> second question: does anyone know of any haskell meetups in the KC area
22:28:30 <merijn> octopuscabbage: Alternatively, you could use
22:28:32 <merijn> :t round
22:28:32 <lambdabot> (RealFrac a, Integral b) => a -> b
22:28:59 <merijn> But that doesn't make sense if integer division was what you wanted in the first place :)
22:29:35 <alphonse23_> thanks MP2E. I'll read it, and try to make sense of it.
22:29:59 <merijn> octopuscabbage: The explicit conversion for numeric types seems a bit annoying (especially when you're doing Project Euler stuff), but I can tell you from experience that after spending 2 weeks hunting a silent numeric conversion bug in C that explicit conversion is *much* better :)
22:30:34 <octopuscabbage> merijn: i understand the point of explicit conversions, i work in python
22:31:15 <octopuscabbage> merijn: i mean javascript, my mind is kind of baked right now
22:31:23 <merijn> :)
22:32:09 <ni8949> j
22:32:36 <merijn> I need a trie that supports an efficient way of querying all elements whose keys are prefixes of a given value, am I stuck implementing it myself/hacking up someone's existing trie library or does this already exist?
22:35:16 <octopuscabbage> is there a function of type [Maybe a] -> [a] which only keeps the non-nothing values
22:35:24 <merijn> :t catMaybes
22:35:25 <lambdabot> [Maybe a] -> [a]
22:35:29 <octopuscabbage> ty
22:35:41 <merijn> octopuscabbage: Also, for future reference, consult Hoogle :)
22:35:47 <merijn> @hoogle [Maybe a] -> [a]
22:35:49 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
22:35:49 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
22:35:49 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
22:35:53 <merijn> @where hoogle
22:35:53 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
22:42:44 <hamid> this(http://cufp.org/jobs/language/31) gives me `Not found`.
22:43:50 <octopuscabbage> math question: is is true that a number is prime if it's not even and not divisible by any odd numbers less than half it
22:44:32 <MP2E> it's prime if it's not divisible by anything but itself and 1
22:44:40 <MP2E> 2 is also prime, despite being even
22:45:08 <octopuscabbage> how about for cases besides 2
22:45:23 <MP2E> it's never even past 2 because every even number is divisble by 2
22:45:27 <MP2E> divisible*
22:45:47 <merijn> Half is to stringent even
22:45:58 <jle`> if you are checking if a number is prime, then you don't have to check anything above the sqare root of the number
22:46:05 <MP2E> ah, nice
22:46:09 <MP2E> good point
22:46:11 <merijn> A number is prime if it's not divisible by any number between 1 and it's square root
22:46:16 <jle`> that's because factors come in pairs
22:46:17 <octopuscabbage> i remember that now
22:47:42 <jle`> any factor higher than the square root will have a partner lower than the square root
23:15:24 <octopuscabbage> isn't there an operator you can use which puts the parameter before the function
23:16:02 <mauke> > x & sqrt
23:16:04 <lambdabot>  sqrt x
23:16:50 <octopuscabbage> ty
23:21:34 <octopuscabbage> on hackage
23:21:50 <octopuscabbage> how do i see how a monad's bind function works
23:22:11 <mauke> hope it's described in the documentation
23:22:25 <mauke> or click on source links to hunt down the instance declaration
23:26:10 <octopuscabbage> hey guys remember how you specifically warned me that in my algorithm for checking primeness i forgot about 2
23:26:18 <octopuscabbage> guess what i just spent 15 minutes tracking down
23:26:35 <kadoban> haha
23:26:35 <joelteon> carmen sandiego
23:27:26 <kvanb> lol
23:27:51 <kvanb> I remember playing the carmen sandiego thing on windows 98 computers in primary school
23:28:15 <mauke> > let isprime n = n > 1 && (n == 2 || all (\d -> n `mod` d /= 0) (takeWhile (\d -> d * d <= n) [3, 5 ..])) in filter isprime [1 ..]
23:28:16 <lambdabot>  [2,3,4,5,6,7,8,10,11,13,14,16,17,19,20,22,23,26,28,29,31,32,34,37,38,41,43,4...
23:28:28 <mauke> excellent
23:28:41 <mauke> > let isprime n = n > 1 && (n == 2 || all (\d -> n `mod` d /= 0) (takeWhile (\d -> d * d <= n) (2 : [3, 5 ..]))) in filter isprime [1 ..]
23:28:43 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
23:29:11 <mauke> I don't need that n == 2 check, do I
23:30:32 <mauke> @where primes
23:30:32 <lambdabot> let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p^2 <= n) primes) in primes
23:31:06 <octopuscabbage> look
23:31:07 <MP2E> hm neat
23:31:09 <mauke> @. run where primes
23:31:11 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
23:31:11 <octopuscabbage> i understand there's a lot of fun ways to take primes
23:31:29 <MP2E> lol
23:32:03 <octopuscabbage> so i think i finally understand monads. monads aren't really as hype as you think they're going to be for how intially confusing they seem.
23:32:18 <mauke> monads are boring
23:32:26 <joelteon> I just can't get my head around integers
23:32:31 <mauke> > nubBy(((>1).).gcd)[2..]
23:32:33 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
23:32:34 <kvanb> lots of people like to tell you monads are <insert explanation of free monads>
23:32:48 <kvanb> these people are poisonous.
23:32:52 <Jookia> joelteon: rofl
23:33:09 <shachaf> I think free monads are great for intuition, better than most examples.
23:33:40 <kvanb> but most the monads a beginner might get friendly with
23:33:48 <kvanb> ie state, reader, writer, are not free
23:33:59 <kvanb> IO could be, I guess.
23:34:33 <kvanb> you can model it as Free, but it's more like a state monad imo
23:34:40 <mauke> there ain't no such thing as a Free Lunch
23:34:50 <dolio> It is not a state monad.
23:34:57 <shachaf> It's nothing like State. It's also not much like Free.
23:34:57 <kvanb> dolio: why not
23:35:01 <ski> > let isPrime p = 1 `mod` p /= 0 && and [a `mod` p == 0 || b `mod` p == 0 | a <- [1 .. p],b <- [1 .. p],(a * b) `mod` p == 0] in filter isPrime [1 .. 100]
23:35:03 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
23:35:08 <kvanb> State RealWorld#
23:35:15 <dolio> No.
23:35:16 <shachaf> If I want to give someone examples of monoid, you can be sure I'll mention lists early on. The same is reasonable for monads.
23:35:22 <kvanb> Don't just say No, explain why.
23:35:33 <dolio> Because it is not an adequate semantics of IO programs.
23:35:37 <mauke> kvanb: forkIO
23:35:43 <dolio> It doesn't work for infinite IO programs.
23:36:08 <mauke> 1 `mod` p?
23:36:21 <kvanb> Frankly, I think that's such a technical detail you could ignore it when explaining the internals of how IO works
23:36:39 <shachaf> Who said anything about internals?
23:36:40 <ski> mauke : yes ?
23:36:52 <mauke> that's a weird way of checking for 1
23:37:01 <kvanb> does forkIO even make sense in any model of IO?
23:37:12 <ski> mauke : it's the nullare case corresponding to the binary case
23:37:21 <jle`> yes it does...in the model of IO that haskell actually explicitly and represents :P
23:37:21 <ski> s/are/ary/
23:37:23 <dolio> It better make sense, or else you don't have a model of IO.
23:37:31 <mauke> kvanb: my personal problem with RealWorld is that it's not real
23:37:35 <jle`> *actually and explicitly represents
23:37:36 <kvanb> Haskell does not have a proper model of IO
23:37:44 <shachaf> "State RealWorld#" sounds like it's trying to be "State# RealWorld", but State# has approximately nothing to do with State anyway.
23:37:46 <mauke> kvanb: that is, the universe does not actually get piped through my haskell program
23:38:11 <dolio> The representation that GHC uses works for its implementation.
23:38:16 <jle`> (IO a) representing a computation that computes an a
23:38:22 <dolio> But it is not a good explanation of what IO is.
23:38:46 <dolio> GHC is just using side effectful functions and using a token to make sure things happen in the right order.
23:38:52 <kvanb> jle`: how does your model work with forkIO
23:39:05 <jle`> forkIO etc. are computation transformers
23:39:25 * ski is wondering why it doesn't work for infinite I/O programs
23:39:43 <kvanb> dolio: unless you actually think about it like you should
23:39:52 <kvanb> and that's that the universe is being piped through the program
23:40:05 <kvanb> so each function needs the current universe to alter it subtly
23:40:07 <MP2E> But that's not what happens.
23:40:18 <kvanb> computers are a giant freaking lie
23:40:21 <dolio> It doesn't matter how you think about it.
23:40:26 <jle`> it transforms a blocking computation computing a value into a non-blocking computation computing a treadId
23:40:28 <mauke> kvanb: but that's not even a useful model
23:40:48 <kvanb> what's the alternative?
23:40:50 <jle`> the IO a as a computation model is useful and easy understandable and fits well with Haskell's IO semantics and won't ever fail :/
23:40:55 <mauke> kvanb: wtf
23:41:04 <kvanb> .. is it a Free model?
23:41:05 <dolio> The semantics of Haskell functions will tell you two things are equivalent when they demonstrably are not as functions on RealWorld.
23:41:22 <jle`> and it won't lead you astray when trying to reason with it in situations like parallelism etc.
23:41:49 <Jookia> jle`: sounds like someone's jealous ;)
23:41:54 <jle`> :P
23:42:02 <kvanb> I have this argument every like 2 weeks here, twitter, reddit, whatever
23:42:10 <kvanb> they tell me there's some magical model where forkIO will work
23:42:20 <kvanb> but I haven't heard it's precise definition yet
23:42:27 <Jookia> kvanb: if forkIO didn't work then why would they put it in there ;)
23:43:02 <jle`> didn't i just explain :|  IO as a first-class representation of a computation for a computer or something to perform. and forkIO as a computation trasnformer
23:43:14 <dolio> ski: forever (print 5) is the same as \s -> undefined.
23:43:26 <kvanb> jle`: so show me how that actually works as a monad definition
23:43:35 <kvanb> first of all, is it a Free representation?
23:43:40 <dolio> If your model is World -> (a, World)
23:43:43 <jle`> it is whatever representation you want
23:43:48 <kvanb> shut up.
23:43:52 <kvanb> this is why I get angry
23:43:58 <jle`> IO isn't inherently monadic
23:44:03 <MP2E> IO *is* not a Monad, it just can happen to be a monad
23:44:09 <jle`> you could have the same IO type, and have it not be a monad
23:44:12 <jle`> with the same semantics
23:44:26 <jle`> monadness is not an inherent properly of how IO is built
23:44:31 <kvanb> So if the best representation we have is the same as our best implementation; state with fork
23:44:44 <jle`> i could implement IO as a text file with C source file
23:44:47 <mauke> that implementation is not haskell
23:45:02 <jle`> an IO String is literally a plaintext C source file that returns a string
23:45:14 <jle`> and when i forkIO, i do a textual transformation on the text file
23:45:23 <mauke> RealWorld is an artifact of an intermediate language in ghc. it does not show up in Haskell or the generated code
23:45:25 <jle`> to return a new source file that represents the same program, but non-blocking, etc.
23:45:50 <ski> dolio : for a short while i was thinking one could accumulate changes, but now i see that'd only work for an output monad
23:45:50 <jle`> when i do (>>), i do a textual transformation that takes two C source files, and returns a new C source file that combines the actions of the first two
23:46:16 <jle`> that's one way I could implement IO
23:46:24 <jle`> with the same semantics
23:47:09 <jle`> IO is a Monad instance, but its actual semantics or foundations don't have to have to do anything with Monad...Monad is just a convenient interface
23:47:09 <ski> (jle` : btw, itym s/inherently/a priori/ ?)
23:47:27 <jle`> ski: perhaps :)
23:47:53 <MP2E> heh :/ how immature
23:48:26 <jle`> i do feel a little bad because remember i was kind of harsh one time i think when talking about this to him.
