00:17:36 <cwl> @djinn a-> b -> a
00:17:37 <lambdabot> f a _ = a
00:18:03 <cwl> @djinn (a -> b) -> (c -> b) -> Either a c -> b
00:18:03 <lambdabot> f a b c =
00:18:03 <lambdabot>     case c of
00:18:03 <lambdabot>     Left d -> a d
00:18:03 <lambdabot>     Right e -> b e
00:34:29 <dremok> To your best knowledge, is there any kind of program, that noone has ever written in Haskell?
00:34:31 <arj> I don't really see the difference between  Text.ParserCombinators.Parsec and Text.Parsec can someone help me here?
00:35:38 <arj> dremok: controlling system for atomic power plant? They are always written in C because you can f*ck up things there, more easily…
00:36:47 <jfischoff> chrisdone: Hey I found my “simpler” inference project, also not done, probably working? https://github.com/jfischoff/simple-poly/blob/master/src/Language/SimplePoly/Infer.hs#L83-L100
02:21:19 <jle`> chrisdone: any chance of me getting my library dev channel on irc-browse?  i'd understand if not, it's probably not too important and i wouldn't want to clutter up the front page list
02:40:59 * hackagebot hspec 1.12.3 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-1.12.3 (SimonHengel)
02:41:01 * hackagebot hspec-meta 1.12.3 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.12.3 (SimonHengel)
03:08:48 <bernalex> hm. is there a way for me to have class Stringish s where string :: Stringish a => s -> a, so that I can do string ("bough" :: String) :: Text, or ("bough" :: String) :: ByteString?
03:09:16 <bernalex> so I'd want to have instance Stringish String, and then string :: String -> String would be id, String -> Text would be pack, etc
03:09:44 <tdammers> bernalex: see my string-convert package
03:10:07 <bernalex> tdammers: ah yes you pretty much do this trick
03:10:38 <tdammers> the bytestring part is only semi-nice, because it assumes you want utf-8
03:10:48 <tdammers> which is usually correct, but it's still an assumption
03:10:49 <bernalex> tdammers: you do it the same way I originally thought I'd have to do it, with two classes.
03:10:58 <bernalex> I hate the names though heh
03:11:02 <tdammers> haha
03:11:14 <tdammers> it could be one class, but then I'd force the conversion both ways
03:11:15 <bernalex> I twitch whenever I see toFoo and fromFoo. makes me think of Java. ;_;
03:11:34 <bernalex> fair point
03:11:48 <bernalex> with two classes you could have Int -> String without needing String -> Int
03:11:48 <tdammers> the naming is pretty much in line with much of the rest of Haskell's ecosystem though
03:11:55 <tdammers> fromIntegral, fromList, etc.
03:12:02 <bernalex> yes I hate those too ;_;
03:12:13 <bernalex> but how would I do it with one class?
03:12:13 <tdammers> maybe you just hate Haskell
03:12:23 <bernalex> I'm not sure I *want* to just use one class... yet...
03:12:28 <tdammers> well, just throw all the method together in one class
03:12:29 <bernalex> but what would the syntax for it be?
03:12:37 <bernalex> I have class Stringish s where
03:12:40 <bernalex>   string   :: Stringish a => s -> a
03:12:42 <bernalex>   unstring :: Stringish a => a -> s
03:12:52 <tdammers> ah, no
03:12:59 <bernalex> :-D
03:13:00 <bernalex> how then?
03:13:09 <bernalex> teach me ur ways tdammers-senpai
03:13:15 <bernalex> yoroshiku onegaisimasu
03:13:17 <tdammers> wait
03:13:18 * bernalex bows
03:13:19 <tdammers> t
03:13:21 <tdammers> haha
03:13:24 <tdammers> been a while since I wrote that
03:13:38 <tdammers> ah, right
03:14:00 <tdammers> ok, so you *could* throw the ToString and FromString classes together, and just have it implement both the fromString and toString methods
03:14:03 <Fuuzetsu> that just llooks like IsString class
03:14:09 <tdammers> Fuuzetsu: yes, it does
03:14:26 <bernalex> tdammers: yes so that's what I want to do. at least to try it on for size.
03:14:53 <bernalex> but, this, I suspect, might be wrong? : class Stringish s where string   :: Stringish a => s -> a ; unstring :: Stringish a => a -> s -- or is that actually OK?
03:14:56 <tdammers> Fuuzetsu: but IsString is one-way, and interwoven with OverloadedStrings; I felt making it a separate class was more appropriate
03:15:13 <tdammers> bernalex: I don't see any problem with that
03:15:20 <bernalex> how would the instances look then?
03:15:38 <tdammers> why, just like you'd expect, no?
03:15:42 <bernalex> like how would I wirte instance Stringish String, and then write string/unstring for String -> String, and then String -> Text/Text -> String etc?
03:15:50 <Fuuzetsu> well there is always Show for the other way ;P
03:16:01 <Fuuzetsu> (stop Show abuse though, for real guys)
03:16:10 <tdammers> instance Stringish Text where string = unpack; unstring = pack
03:16:12 <tdammers> basically
03:16:17 <bernalex> tdammers: oh
03:16:19 <bernalex> yeah
03:16:21 <bernalex> I'm a pillock
03:16:23 <tdammers> haha
03:16:28 <bernalex> something something trees forests
03:16:39 <tdammers> my StringConvert class works on two types at once though
03:16:52 <bernalex> but to write that you can't have class Stringish s though
03:17:02 <tdammers> yes you can
03:17:20 <tdammers> but you have to go through String, always
03:17:22 <bernalex> uh no? then you'd be applying it to too many arguments with instance Stringish String String
03:17:32 <tdammers> oh, that way
03:17:42 <tdammers> no, the String part would be hard-coded
03:17:54 <tdammers> that's why my StringConvert class has *two* type parameters
03:18:19 <tdammers> which, incidentally, requires dangerous extensions
03:18:38 <tdammers> FlexibleInstances, OverlappingInstances :x
03:18:38 <bernalex> pffffffft
03:18:43 <bernalex> I already have those
03:18:46 <bernalex> what do you think I am, an amateur
03:18:52 <tdammers> no, that would be me
03:19:21 <bernalex> the way I write haskell lately is turn on GeneralizedNewtypeDeriving and just derive everything and not actually do anything myself. GHC extensions for the win.
03:19:36 <tdammers> GeneralizedNewtypeDeriving is a godsent
03:20:29 <bernalex> I'm so amazed how it pretty much always works exactly like you would want it to
03:21:43 <tdammers> bernalex: it's pretty trivial isn't it? in a way?
03:22:09 <tdammers> like, it's just a matter of stepping into the newtype wrapper and lifting the implementation from there
03:22:21 <tdammers> newtype Foo = Foo { unFoo :: T }
03:22:30 <bernalex> tdammers: I guess it is. but I mean that you can just derive a Functor kind of melts my brain when I think about it still. just the sheer lunacy of how elegant and ingenious it is.
03:22:40 <tdammers> deriving any method is just a matter of throwing Foo / unFoo around the payload value
03:22:52 <tdammers> it pretty damn elegant, yes
04:41:11 <ocharles> Has anyone used the MemoTrie library to write their own instances? I have `Foo Bar Baz`, where I have `HasTrie Bar`, `HasTrie Baz` - but I can't figure out how to write `HasTrie Foo`
04:47:26 <ocharles> Ok, got it... trie f = trie (trie . (\a -> \b -> f (Foo a b))
05:36:41 <Baluse> http://raw.pro-chan.com/Raw/t/674_1382207920
05:37:50 <mauketwork> Baluse: not clicking, but that url looks off-topic
05:38:31 <Baluse> then check it at liveleak www.liveleak.com/view?i=4c5_1382115025&comments=1
05:38:55 <mauketwork> are you sure you're not a spammer?
05:39:01 <t5`> ,a
05:39:06 <t5`> 87777777777778
05:39:12 <wei2912> ...
05:39:18 <mauketwork> cat-like typing detected
05:39:28 * Hodapp bats at mauketwork's keyboard~
05:39:35 <wei2912> try pouring water
05:39:52 <t5`> keyboard maintenance
05:40:10 <t5`> replacing the battery, sorry
05:40:14 <mauketwork> try pouring water
05:40:24 <MP2E> apply 5 cats
05:40:52 <t5`> i'll try to throw it against the window from the 11th floor
05:41:02 <HeladoDeBrownie> It helps if you keep your keyboard still; after all, Haskell is a statically typed language
05:41:07 * hackagebot github-post-receive 1.1.0.0 - GitHub webhooks library  http://hackage.haskell.org/package/github-post-receive-1.1.0.0 (ShoheiYasutake)
05:41:12 <Baluse> I am not a spammer
05:41:16 <nshepperd> main = cat <$> keyboard
05:41:40 <t5`> lol
05:41:40 <MP2E> well played
05:41:44 <MP2E> play him off, keyboard cat
05:51:14 <Kinokkory> eij
05:51:41 <bendesk> I'm trying to install gtk2hs on OSX 10.9.5 using the Haskell Platform 2014, ghc 7.8.3, I'm getting errors with C block syntax. Can someone take a look?   http://pastebin.com/raw.php?i=CP0AxXEm
05:53:12 <mauketwork> what's in line 147 of /usr/include/dirent.h?
05:54:41 <geekosaur> an Apple C extension that gtk2hsc2hs doesn't know how to parse, as bendesk said
05:55:26 <mauketwork> yeah, but what does that extension look like? I'm curious
05:55:28 <geekosaur> ...iirc there is something wrong with preprocessor defines
05:55:36 <hamishmack> bendesk: That should be fixed in newer versions 0.13.  Try cabal update.
05:56:12 <geekosaur> int scandir_b(const char *, struct dirent ***, int (^)(const struct dirent *), int (^)(const struct dirent **, const struct dirent **))
05:56:41 <geekosaur> where the (^) thingies are Apple's closure extension ("blocks")
05:56:44 <mauketwork> oh, ouch
05:57:00 <arj> eh what? The function `guard' is applied to two arguments, but its type `Bool -> IO () -> ()' has only two
05:57:39 <Iceland_jack> @ty guard
05:57:39 <lambdabot> MonadPlus m => Bool -> m ()
05:57:49 <mauketwork> why do these closures have their own type?
05:57:52 <Iceland_jack> @ty guard :: Bool -> IO ()
05:57:52 <lambdabot> Bool -> IO ()
05:58:07 <mauketwork> :t guard :: Bool -> IO () -> ()
05:58:08 <lambdabot>     No instance for (MonadPlus ((->) (IO ())))
05:58:08 <lambdabot>       arising from a use of ‘guard’
05:58:08 <lambdabot>     In the expression: guard :: Bool -> IO () -> ()
05:58:18 <arj> guard is obviously wrong, but the error message confused me…
05:58:48 <geekosaur> I don't recall offhand
05:59:07 <Iceland_jack> arj: 'guard' only accepts a single argument and the type you mentioned is incorrect
05:59:15 <mauketwork> (gcc gives you normal function pointers)
05:59:16 <Iceland_jack> > guard True :: Maybe ()
05:59:18 <lambdabot>  Just ()
05:59:19 <Iceland_jack> > guard False :: Maybe ()
05:59:20 <lambdabot>  Nothing
05:59:28 <Iceland_jack> > guard True :: [()]
05:59:29 <lambdabot>  [()]
05:59:29 <Iceland_jack> > guard False :: [()]
05:59:31 <lambdabot>  []
05:59:55 <bendesk> hamishmack: Thanks for taking a look. "cabal update" doesn't help sadly, it sais "Downloading the latest package list from hackage.haskell.org" and stops. "cabal --version" sais that cabal-install is 1.20.0.3 and cabal itself is  1.20.0.2.
05:59:56 <arj> Iceland_jack: I agree, but this was the exact error message from the compiler.
06:00:06 <mauketwork> arj: looks like a compiler bug
06:00:47 <arj> worth reporting?
06:00:55 <Iceland_jack> arj: Post the code first
06:00:58 <CVV> the best prank www.youtube.com/watch?v=w283-a4ciLc
06:00:59 <CVV> the best prank www.youtube.com/watch?v=w283-a4ciLc
06:01:14 <hamishmack> bendesk: cabal update is just to make sure cabal knows about version 0.13 of gtk2hs
06:01:41 <mauketwork> arj: in general, yes :-)
06:01:54 <mauketwork> they can always CLOSE INVALID if it doesn't apply
06:01:55 <bendesk> Oh, so It's not working then.
06:02:28 <bendesk> Or the package Im actually trying to install (helm) relies on 0.12 of gtk2hs
06:03:22 <hamishmack> bendesk: You might need to update that to let it work with 0.13 then
06:03:46 <hamishmack> bendesk: Not a lot has changed in 0.13, so it will probably work
06:03:50 <lpaste> arj pasted “No title” at http://lpaste.net/113848
06:04:14 <hamishmack> you might also need to cabal install gtk2hs-buildtools
06:04:31 <arj> mauketwork: Iceland_jack: http://lpaste.net/113848
06:04:32 <hamishmack> to make sure you have the latest version
06:04:48 <bendesk> So you mean adjust the helm package? It doesn't direct depend on gtk2hs I think :/
06:05:11 <larsen> hello o/
06:05:38 <hamishmack> Just change the <0.13 to <0.14 on the gtk dependency in helm.cabal
06:05:56 <bendesk> Ill try that. Thanks
06:11:19 <bendesk> Sorry, but I can't find the helm.cabal file on my system. Do you know where they are commonly stored?
06:13:17 <Kinokkory> I read that "hyperfunctions" can be an Arrow instance, but I couldn't find on the web how to write the method "first". Does anybody know how to write it?
06:15:54 <phaazon> hey, I’m looking for some hindsight. I have an expression tree for my EDSL project, and I have no idea how to represent lambda application so that I can inspect it. See https://github.com/phaazon/ash/blob/master/src/Ash.hs#L27 , here, the Lam constructor is correct because I can inspect the whole chain of lambda, however, have a look at (:$), which is the lambda application. I don’t know how to express in the type the fact I’v already « eaten » a
06:34:17 <bernalex> how do I derive a multi parametre typeclass? can I?
06:34:44 <bitonic> is there a natural numbers library that uses Int instead of Integer (as nats does)?
06:41:21 <joe9> This is my first time using monad transformers and I think it shows. I cannot figure out the high level structure of this program.  http://codepad.org/xBEXwJi3 is my program. I cannot figure out how to structure the type definitions of scheduler in Line 193 and roundRobin in Line 186. Any advice, please?
06:41:43 <joe9> I got the contT and the pause monad working properly individually.
06:42:10 <joe9> but, I cannot figure out how to go about structuring them together.
06:42:55 <joe9> The reason that I am using the ContT monad is that I want to be able to fork.
06:43:01 <joe9> using callCC.
06:45:19 <albeit> From within a running program in IO, is there a way to tell how evaluated a variable is?
06:45:47 <joe9> johnw: johnw_: any comments on my problem, please?
06:46:03 <albeit> (Similar to the GHCI :sprint command)
06:46:08 <mauketwork> albeit: not as far as I know
06:48:11 <JonReed> Hi, Haskellers! How can I match this using parsec/attoparsec? "ignore some random text (match this inside brackets) and ignore ending text". E.g., using regex that woudl be something like  "(?<=\()(.*?)(?=\))". In parsec, I've tried "between (string "(") anyChar (string ")") ", but it doesn't work because it expects it to start with "(" instead of ignoring anytext until "(" which is what I want. Can anybody help me?
06:48:52 <tdammers> many (noneOf "(") >> what you had before
06:49:02 <mauketwork> rewrite to [^(]*\(([^)]*)\)
06:49:11 <clrnd> JonReed, skipMany or ^
06:49:20 <tdammers> or skipMany, yeah
06:49:22 <tdammers> :P
06:49:23 <mauketwork> then turn that into parsec
06:49:52 <clrnd> doesn't a regex-to-parsec thingy exist yet?
06:50:09 <benzrf> it should
06:50:24 <mauketwork> what would it do with 'a*a'?
06:50:25 <dramforever> well, how about a regex combinator library
06:50:45 <clrnd> dramforever, Data.String.Util
06:50:47 <clrnd> :P
06:50:56 <dramforever> huh? which package
06:51:21 * clrnd realizes it was a bad joke
06:51:45 <dramforever> well
06:52:01 <dramforever> well...
06:55:37 <Denommus> hi
06:57:03 <bernalex> I have a class Stringish a b where strish :: a -> b. then I have instances like instance Stringish String Text and so on. how can I use this class with a new type? data Waffle = Bake String -- I want to be able to get Bake String -> Text for free, based on String Text being an instance of Stringish
06:58:29 <JonReed> clrnd: tdammers: mauketwork: Thank you.
06:59:25 <tdammers> bernalex: something like multi-param newtype deriving?
06:59:27 <tdammers> oh boy
06:59:33 <bernalex> basically, yes
06:59:47 <dramforever> StandaloneDeriving maybe?
07:00:16 <bernalex> IDR what that does, but I don't think so
07:00:19 <Kinokkory> hyper
07:00:31 <tdammers> I think it's fundamentally impossible to do directly
07:00:37 <bernalex> why would it be?
07:00:41 <tdammers> idk
07:00:42 <dramforever> bernalex: why data not newtype
07:00:42 <tdammers> lol
07:00:50 <bernalex> dramforever: how does that matter
07:01:09 <tdammers> bernalex: because of GeneralizedNewtypeDeriving
07:01:14 <dramforever> yep
07:01:15 <bernalex> tdammers: data Waffle = Bake String -- it is fundamentally simple, IMO, to understand that this is a String with a wrapper. so treating it as a String should be trivial.
07:01:23 <bernalex> tdammers: right. it won't work with data. true.
07:01:24 <dramforever> no
07:01:36 <dramforever> that would be what newtype does
07:01:49 <Denommus> anyone here working with reactive-banana?
07:02:11 <dramforever> newtype Waffle = Bake String -- Everyone knows that Waffle is a "Bake"r around a String
07:02:21 <dramforever> okay, "Bake"r -> wrapper
07:02:32 <bernalex> still
07:02:35 <bernalex> you can't do
07:02:40 <bernalex> newtype Waffle = Bake String (deriving Stringish)
07:02:45 <bernalex> but
07:02:47 <bernalex> hmm
07:02:52 <bernalex> newtype Waffle = Bake String deriving (Stringish String)
07:02:54 <bernalex> ???
07:02:56 <bernalex> success?
07:03:11 <dramforever> deriving instance Stringish Waffle Text
07:03:45 <bernalex> oh but that's still damn annoying
07:03:47 <JonReed> tdammers: I've tried "many (noneOf "(") >> many (noneOf ")")". But it matches the first bracket as well. Is there any way I can not match it? E.g., right now it will match "(match inside brackets".
07:03:49 <bernalex> you'd have to derive all the things you want
07:03:49 <dramforever> that would need {-# LANGUAGE StandaloneDeriving #-} or -XStandaloneDeriving
07:03:59 <dramforever> hmmm...
07:04:02 <dramforever> does this work?
07:04:04 <bernalex> instead of just deriving "Stringish a" or whatever
07:04:06 <bernalex> yeah it works
07:04:13 <bernalex> but it means you need to derive all the ones you want
07:04:20 <bernalex> (I think)
07:04:27 <dramforever> deriving instance Stringish String x => Stringish Waffle x
07:04:41 <tdammers> JonReed: the first many . noneOf skips the characters up to and excluding the first (
07:04:49 <tdammers> (skipMany would work the same)
07:04:51 <dramforever> does that one work?
07:04:55 <Iceland_jack> bernalex: Would you prefer every String/Text newtype automatically became an instance of that class?
07:05:03 <tdammers> after that, you need to do the 'between' thing you had before
07:05:07 <bernalex> Iceland_jack: yeah
07:05:27 <Iceland_jack> bernalex: What about newtypes defined in other libraries that import that class?
07:05:32 <bernalex> Iceland_jack: everything that wraps String/ByteString/Text and lazy variants thereof, which is what I have implemented.
07:05:43 <bernalex> Iceland_jack: it's imported sparingly, so sure
07:06:02 <albeit> Does heap profiling work with +RTS -Nx? When I run heap profiling on cost centers I get just one cost center "PINNED"
07:06:22 <Iceland_jack> What if someone wants different behaviour?
07:06:42 <JonReed> tdammers: Ok. And what about if it will be a string instead of one char like "(". E.g, "starting noise .. match after me match me don't match me"?
07:06:59 <tdammers> I think "between" would still work
07:07:12 <Iceland_jack> It's very common to introduce newtypes for a different type class instance
07:08:11 <bernalex> Iceland_jack: I'm not sure what you mean.
07:08:45 <bernalex> hmm how does deriving instance work?
07:08:50 <bernalex> deriving instance Stringish String a => Stringish Waffle a
07:08:55 <joe9> need some design advice on using monad transformers, please? http://codepad.org/xBEXwJi3 is my program. I cannot figure out how to structure the type definitions of scheduler in Line 193 and roundRobin in Line 186. Any advice, please? I am using the ContT monad so I could use callCC for fork.
07:09:03 <bernalex> says "the last argument of the instance must be a data or newtype application"
07:12:02 <albeit> When I heap profile my program with "-hm", in the *.hp file it shows appropriate size values, except for a SYSTEM entry that is orders of magnitude larger than anything else. What is that? Can I ignore it?
07:12:19 <bernalex> Iceland_jack: really ideally I would have "opt-in" I guess. I just want a terse and neat way to say that newtype Waffle = Bake String should work like String's Stringish instances.
07:24:05 <Denommus> so, I'm using accumB to alternate the value of a boolean value
07:24:51 <Denommus> the problem is... the value only starts to change after the second time the event happens
07:31:23 <HeladoDeBrownie> Denommus, show what you're trying (I don't know the library but it's what anyone would ask before they could help)
07:36:29 <albeit> If I write a custom parser and implement Functor/Applicative/Monad, will GHC inline the instance implementation functions with "-O"?
07:40:23 * geekosaur reading Swift documentation, shakes head at unfortunate implementation of "optional"
07:41:09 <geekosaur> (if I have to use this, I may be tempted to write my own Maybe...)
07:42:00 <Denommus> HeladoDeBrownie: I have no idea what to try
07:42:25 <Denommus> HeladoDeBrownie: let me upload my code to Github
07:44:45 <SaBer> geekosaur: the "if let" syntax is very strange, but what else did you find wrong with it?
07:45:22 <geekosaur> wired-in fromJust (! suffix), in two forms, the second of which is only slightly better than not having a Maybe/Option type at all
07:45:26 <EvanR> MonadPlus implies Monoid? mplus is associative?
07:45:29 <Phillemann> Why do I need a Monoid instance for the statement [1,2,3] ^. (ix 1)?
07:45:58 <Denommus> HeladoDeBrownie: here is my main file: https://github.com/Denommus/SpellChat/blob/master/src/Main.hs
07:46:17 <geekosaur> ("implicit unwrapping", wtf)
07:46:44 <bennofs> Phillemann: because ix 1 can fail
07:46:55 <bennofs> Phillemann: consider [1,2,3] ^. ix 4. What should that return?
07:47:06 <bennofs> Phillemann: with the Monoid instance, it can return mempty.
07:47:18 <Phillemann> Hmmm, I see.
07:47:35 <Iceland_jack> You can use (^?):
07:47:36 <Iceland_jack> :t [1,2,3] ^? (ix 1)
07:47:37 <bennofs> Phillemann: if you like to get a Maybe a a result, without a Monoid instance, you can use ^? (non-infix name is preview)
07:47:37 <lambdabot> Num t => Maybe t
07:47:44 <bennofs> > [1,2,3] ^? ix 1
07:47:46 <lambdabot>  Just 2
07:47:46 <bennofs> > [1,2,3] ^? ix 5
07:47:48 <lambdabot>  Nothing
07:47:53 <Phillemann> Ah ok, thanks you two
07:48:39 <bennofs> If you're really sure that the the index exists, you can also use ^?!, which uses error if the index doesn't exist
07:48:48 <bennofs> > [1,2,3] ^?! ix 2
07:48:49 <lambdabot>  3
07:48:55 <bennofs> > [1,2,3] ^?! ix 4
07:48:57 <lambdabot>  *Exception: (^?!): empty Fold
07:49:51 <Phillemann> Ok, that answers all of my questions :)
07:52:05 <EvanR> does ghc use "laws" of certain typeclasses to rearrange expressions for optimization
07:52:35 <bennofs> EvanR: I don't think it does currently as it would break too much
07:56:12 * hackagebot kyotocabinet 0.1.2 - Mid level bindings to Kyoto Cabinet  http://hackage.haskell.org/package/kyotocabinet-0.1.2 (FrancescoMazzoli)
07:59:51 <Phillemann> Hm, but this is still a bit confusing: (ix 2 .~ 10) [1,2,3,4,5] works, although ix is supposed to...be careful. :)
08:00:10 <EvanR> :t guard
08:00:11 <lambdabot> MonadPlus m => Bool -> m ()
08:01:13 <Iceland_jack> Phillemann: That never results in an error though
08:01:30 <bennofs> Phillemann: this is because ix is a Traversal. Setting a Traversal only sets all focused elements (a traversal can focus multiple elements). ix i is a traversal of 0 elements if i is not in the list, otherwise it traverses 1 element (only the element at that index)
08:01:33 <naudiz> I want to generate an infinite list containing three-tuples of integer numbers like this [(1,0,0),(1,1,0),(1,1,1),(2,0,0),(2,1,0),(2,1,1),(2,2,0),(2,2,1),(2,2,2),(3,0,0),(3,1,0),...] Does someone have an idea how to do this?
08:02:06 <Phillemann> bennofs: Ah, ok, that makes sense.
08:02:18 <EvanR> naudiz: not started at (0,0,0) ?
08:02:47 <naudiz> EvanR: it's for lattice planes, (0,0,0) doesn't make sense in this case
08:03:10 <EvanR> you can define a succ operation for (Int,Int,Int)
08:03:16 <EvanR> and iterate
08:03:24 <EvanR> or, unfoldr
08:03:36 <naudiz> that's an idea. thanks
08:03:42 <EvanR> :t unfoldr
08:03:44 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
08:04:00 <EvanR> :t iterate
08:04:01 <lambdabot> (a -> a) -> a -> [a]
08:04:07 <EvanR> iterate makes more sense
08:04:30 <EvanR> > iterate succ 0
08:04:32 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
08:04:45 <naudiz> didn't think about a succ operater. I guess it should work
08:05:33 <EvanR> case analysis on the possible combinations of the 2 rightmost elements
08:05:35 <SvenskFisk> I have a recursive function that needs to keep track of the values already searched, so I'm passing it as a third argument. The problem is whenever I call the function I have to write "recursiveFunction piece game []", the empty list being the pieces searched so far. Is there a way to give it a default value? Are there any alternatives to having to remember to pass an empty list to the function each ti
08:05:41 <SvenskFisk> me?
08:06:02 <Iceland_jack> SvenskFisk: You can make an auxiliary/local function
08:06:24 <Iceland_jack>     recursiveFunction piece game = aux piece game [] where
08:06:24 <Iceland_jack>       aux p g = ...
08:06:45 <miku_miku> Is there a 'tail' function for any-length tuple?
08:06:57 <lericson> miku_miku: no, tuples are types so it should be impossible!
08:07:18 <geekosaur> tuples are not recursive types
08:07:27 <tdammers> if I'm not mistaken, a general solution would require dependent types or some such
08:07:30 <SvenskFisk> Sounds good, I'll try that, thanks Iceland_jack
08:07:40 <Iceland_jack> tdammers: You can write it in Haskell, but it's ugly
08:07:50 <geekosaur> there are ways to do it but they're painful (a typeclass and an instance for every length tuple)
08:08:04 <tdammers> yeah, you have to type out every possible tuple length, right?
08:08:13 <EvanR> HList
08:08:33 <tdammers> but IMO, if you think you want tail for tuples, you are probably using tuples when you shouldn't
08:08:47 <tdammers> OTOH, it could probably done with TH in a semi-sane way
08:08:56 <geekosaur> yeh, you want a recursive type, i.e. a list or similar
08:09:05 <geekosaur> maybe a Seq if you need the tail a lot
08:09:13 <orbital> Given x :: Maybe A, y :: A -> [B] and z :: [B] -> IO (Maybe C); how can they be combined to get the (Maybe C) out of x?
08:09:16 <EvanR> Data.Sequence
08:09:27 <tdammers> something like class UnCons a b where uncons :: a -> (b, a)
08:09:48 <tdammers> with | a -> b
08:10:09 <bennofs> orbital: you can get a IO (Maybe C), but no Maybe C
08:10:33 <vanila> hi
08:11:33 <Iceland_jack> Like tdammers said, this is the wrong solution. But for the sake of interest:
08:11:33 <Iceland_jack>     class Last a where
08:11:33 <Iceland_jack>       type LastTy a :: *
08:11:36 <EvanR> you can get a Maybe (IO (Maybe C)) ;)
08:11:36 <Iceland_jack>       lastTup :: a -> LastTy a
08:11:39 <orbital> bennofs: that's fine. This inside a 'do' for another IO * function, so i can '<-' it out.
08:12:06 <Iceland_jack> With:
08:12:06 <Iceland_jack>     instnace Last (a, b, c) where
08:12:06 <Iceland_jack>       type LastTy (a, b, c) = c
08:12:06 <Iceland_jack>       lastTup :: (a, b, c) -> c
08:12:09 <Iceland_jack>       lastTup (x, y, z) = z
08:12:11 <EvanR> <-, the "get values out of an IO operator" ;)
08:12:16 <Kaidelong> I need help with pandoc, is there any better place to ask than here?
08:12:22 <Iceland_jack> The instance type signature won't work in the latest GHC, but it should
08:12:51 <orbital> EvanR: :)
08:13:30 <bennofs> orbital: then you can cust do: fmap join $ Data.Traversable.traverse (z . y) x
08:13:35 <bennofs> s/cust/just
08:13:48 <orbital> just a bit confused about notation. Would like to carry the maybeness all the way up, in a single line :)
08:14:14 <EvanR> orbital: just compose them then
08:14:27 <EvanR> z . y . x
08:14:53 <EvanR> oops, the beginning maybe
08:15:11 <EvanR> x >>= (z . y)
08:15:16 <orbital> EvanR: ... carry in such a way that it's free to fail at x or z
08:15:19 <bennofs> EvanR: won't work either because of IO
08:15:25 <bennofs> orbital: fmap join $ Data.Traversable.traverse (z . y) x
08:15:32 <orbital> bennofs: going ot meditate on that, thanks
08:16:23 <EvanR> bennofs: wont it? x >>= (z . y) is Maybe (IO (Maybe C)) right
08:16:39 <bennofs> EvanR: no. fmap (z . y) x :: Maybe (IO (Maybe C)
08:17:03 <EvanR> oh
08:17:05 <bennofs> EvanR: for x >>= (z . y), z . y would have to be of type [B] -> Maybe <something>
08:17:11 <EvanR> right
08:19:52 <EvanR> suggests the fmap then
08:19:57 <Kaidelong> @ty mapMaybeT id
08:19:58 <lambdabot>     Not in scope: ‘mapMaybeT’
08:19:58 <lambdabot>     Perhaps you meant one of these:
08:19:58 <lambdabot>       ‘IM.mapMaybe’ (imported from Data.IntMap),
08:20:18 <Kaidelong> lambdabot doesn't know about mtl?
08:21:12 <Kaidelong> oh
08:21:16 <simpson> :t Control.Monad.Trans.Maybe.mapMaybeT
08:21:17 <lambdabot> (m (Maybe a) -> n (Maybe b)) -> Control.Monad.Trans.Maybe.MaybeT m a -> Control.Monad.Trans.Maybe.MaybeT n b
08:21:22 <simpson> :t Control.Monad.Trans.Maybe.mapMaybeT id
08:21:23 <lambdabot> Control.Monad.Trans.Maybe.MaybeT n b -> Control.Monad.Trans.Maybe.MaybeT n b
08:22:36 <bennofs> @let import Control.Monad.Trans.Maybe
08:22:38 <lambdabot>  Defined.
08:22:46 <bennofs> :t mapMaybeT id
08:22:47 <lambdabot> MaybeT n b -> MaybeT n b
08:25:09 <Benzi-Junior> hey anyone here ever implemented a gradient descent algorithm for lilllllinear rergression in haskell ?[A
08:28:24 <albeit> If I mapM an IO function over a list, and the list is not used/referenced afterwards, will stream fusion work, or will the earlier list elements be held in memory until the full mapM is complete?
08:29:13 <Kaidelong> @src mapM
08:29:13 <lambdabot> mapM f as = sequence (map f as)
08:29:22 <Kaidelong> @src sequence
08:29:23 <lambdabot> sequence []     = return []
08:29:23 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
08:29:23 <lambdabot> --OR
08:29:23 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
08:29:37 <geekosaur> you probably want mapM_ in that case, so it doesn't build the list
08:29:49 <albeit> Should have said, I am using mapM_
08:30:35 <albeit> So since its (sequence . map), isnt the whole IO computation being built up by the map, and then only once sequence is called everything is evaluated?
08:31:10 <EvanR> seems like it would be lazy
08:31:51 <Kaidelong> @src sequence_
08:31:51 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
08:32:12 <Kaidelong> mmm well
08:32:18 <geekosaur> for mapM_, it's lazy until the sequence_, which shouldn't build a list
08:32:22 <Kaidelong> that should be subject to fusion anyway
08:32:36 <geekosaur> and yes, I would expect it to be subject to fusion
08:35:31 <maki> hi
08:35:55 <Guest36744> what text editor do you guys use for haskell?
08:36:25 <Kaidelong> gvim, personally
08:36:41 <Kaidelong> I've tried lighttable but the haskell support for it is a real fixer upper
08:36:43 <albeit> vim/gvim as well
08:36:45 <Kaidelong> most people swear by emacs
08:36:59 <Guest36744> i'm new to haskell that's why i'm asking xD
08:37:05 <chpatrick> sublime
08:37:11 <EvanR> notepad.exe
08:37:11 <lucs> And the rest, s/by/against/
08:37:21 <EvanR> vim
08:37:31 <Guest36744> thank you ^^
08:37:31 <albeit> I was really hoping you were joking EvanR, phew
08:37:43 <EvanR> apparently theres a plugin for intellij called haskforce
08:38:03 <Cale> notepad.exe is pretty inappropriate, but most things are okay. The main important feature you need is the ability to convert tabs to spaces automatically, and most good editors have such a feature.
08:38:05 <Kaidelong> eclipse is also an option IDE wise
08:38:24 <dcoutts_> Guest36744: I just use gedit under gnome, nothing sophisticated
08:38:34 * dcoutts_ has implemented IDE backends, but doesn't use one
08:38:38 <Cale> So I'd just say use whatever you're comfortable with, but configure it to convert tabs to spaces :)
08:38:59 <Kaidelong> support for sections is also pretty helpful
08:39:04 <Kaidelong> folds?
08:39:05 <Kaidelong> folds
08:39:15 <EvanR> as in "code folding"
08:39:38 <Cale> I used to have folding turned on in vim, but I never really used it that much somehow
08:41:16 <EvanR> i like to see my code
08:41:27 <EvanR> if it cant fit on the screen, its buggy ;)
08:41:40 <Hodapp> EvanR: But this would mean that all Java code is bu.... okay, point taken.
08:41:58 <wei2912> EvanR: no it isn't
08:43:09 <HeladoDeBrownie> Cale, same here, but I decided to just let it go. The code never bothered me anyway.
08:48:11 * t5` is away (auto-away after 2hrs of inactivity) - (02:45 pm)
08:52:07 <albeit> If I do something like "bsLines <- LBS.lines <$> LBS.readFile "path.txt"; mapM_ print bsLines" (where LBS is ByteString.Lazy), shouldn't the file be consumed lazily, so really only allocating one line's length at a time?
08:53:10 <Iceland_jack> albeit: Yes it should run in constant space given that you don't use "bsLines" somewhere else
08:54:00 <albeit> Iceland_jack: It's running in constant space, but at 160KB constant space... and the lines are max 2KB...
08:54:36 <EvanR> what tool are you using to measure that?
08:54:39 <Iceland_jack> That's odd
08:54:59 <albeit> The profiler, with various -h values, and it is being allocated to ByteStrings / ARR_WORDS
08:55:00 <simpson> Maybe due to GC?
08:55:34 <EvanR> i would be surprised if it was using exactly 2KB
08:56:29 <EvanR> actually im amazed its only using 160K
08:57:19 <albeit> Even though its allocating a constant ~110KB to ByteStrings?
08:58:10 <EvanR> id expect a big advanced gc system to be tuned for many many megabytes commonly in use
08:58:13 <simpson> Maybe it's because the GC keeps allocating BS values that are being consumed in a regular pattern?
08:58:53 <albeit> simpson: What do you mean by a regular pattern? So the GC may be pre-allocating values?
08:59:18 <EvanR> the gc is generational, so its supposed to be regularly collecting your very tempoary values like the lines of the file
08:59:19 <simpson> albeit: I mean that your program keeps doing the same thing over and over, as in a loop, which means that the GC gets into a rhythm.
08:59:42 <EvanR> depending on what you do with the lines
09:00:08 <simpson> Think of a washing machine with a belt inside. The belt keeps getting thrown against the machine at regular intervals, resulting in a relatively stable pattern that isn't necessarily the same between washes.
09:00:24 <albeit> Ah, so the GC is letting a bunch of lines be allocated, say to 100KB worth, and then when more than that are allocated, it starts to GC the oldest ones? I would expect that to show spikes from 0KB->100KB->0KB etc... no?
09:00:51 <EvanR> its definitely not collecting them as soon as they are lost, like a reference counter would
09:01:21 <EvanR> but its pretty soon if they are lost soon
09:04:58 <EvanR> albeit: given how much memory everybody has on their PC, id expect the gc to be geared more towards faster performance and better gc latency than memory usage
09:05:12 <Guest36744> is anybody using haskell on windows?
09:05:16 <EvanR> latency, how long the gc spends doing work at a time
09:06:02 <albeit> Okay, thanks
09:07:20 <sm> Guest36744: yes, some people are
09:07:42 <Guest36744> what editor do you use for windows?
09:08:48 <zomg> Guest36744: GVim
09:09:00 <sm> people talk about sublime text, notepad++.. there's also emacs, intellij+plugin, and eclipse+plugin
09:09:27 <Guest36744> do you know where can i download it please?
09:09:53 <albeit> Google probably knows...
09:10:04 * sm helpfully hands Guest36744 a card that reads: http://www.sublimetext.com/2
09:10:28 <Guest36744> thank you xD
09:11:55 <muzzle> i want to read a bit about category theory, are there any resources that you could recommend me ?
09:13:00 <vixlur> Guest36744, gvim
09:13:05 * sm hands muzzle a different card, on which is embossed: http://bartoszmilewski.com/category/category-theory/
09:13:26 <Guest36744> thanks you ^^
09:14:31 <muzzle> thanks :D
09:14:35 <josephle> sm, how big is that deck of yours?
09:15:02 <kadoban> One Google big or so probably :)
09:15:10 <lericson> he just had to have a category named category theory ;)
09:16:23 <Baluse> http://raw.pro-chan.com/Raw/t/674_1382207920  that big
09:17:11 <phaazon> hey, given a lambda constructor for an EDSL by Lam :: E a (E b c) -> a -> E b c
09:17:29 <phaazon> woh, no, this is the application
09:17:34 <phaazon> not the lambda
09:17:38 <phaazon> it’s Ap.
09:17:43 <phaazon> then, how can I inspect Ap?
09:17:53 <phaazon> since a is existentially quantified? :/
09:18:03 * sm slips the cards into a pocket, smiles and walks quickly away
09:18:17 --- mode: ChanServ set +o mauke
09:18:17 --- kick: Baluse was kicked by mauke (no)
09:19:21 <phaazon> holy shit Baluse, get the fuck out
09:19:37 <Baluse> :(
09:20:11 <Baluse> thank you for watching
09:20:17 --- mode: mauke set -o mauke
09:20:39 <mauke> Baluse: why did you come here?
09:21:06 <Baluse> randpmly
09:21:14 <phaazon> yeah, now get out.
09:21:22 <Baluse> why
09:21:31 <mauke> you keep spamming that link
09:21:37 <Baluse> no
09:21:38 <phaazon> because we don’t want that on #haskell
09:21:39 <mauke> and you have no interest in haskell
09:22:29 <Baluse> who uses haskell ?
09:22:49 <muzzle> ban, anyone ?
09:22:54 <piskrist> Baluse: I do!
09:23:01 <lericson> /ignore baluse
09:23:02 <bennofs> Baluse: me to!
09:23:04 <mauke> Baluse: most people in this channel, I guess
09:23:05 <lericson> not that hard, people
09:23:22 <AleksejsHome> Hi, any idea how to solve this? http://vpaste.net/XO6Ec
09:23:48 <simpson> lericson: Education is more important than ignorance.
09:24:02 <Fuco> I have a function which takes an IO action where I don't care about the return type. Should I require "IO ()" or can I leave it as "IO a"... I never use the return value, so in the first case user would specifically need to "void $ ...". Which is the prefered way to do it?
09:24:07 <Saizan> AleksejsHome: run ghc-pkg check
09:24:12 <Kaidelong> web developers, financial people, and high assurance people
09:24:12 <Iceland_jack> lericson: It's also easier to kick a single nick than for hundreds of people to put them on ignore
09:24:34 <phaazon> Fuco: what is the return value?
09:24:45 <mauke> Fuco: my instinct is to leave it as IO a, but I have no arguments
09:24:47 <Fuco> phaazon: I don't care about the return value
09:24:56 <phaazon> so leave it a
09:25:02 <AleksejsHome> Saizan: http://vpaste.net/tHnsn
09:25:02 <phaazon> so that people can care :)
09:25:08 <Fuco> right
09:25:17 <lericson> Iceland_jack: evidently not true ;)
09:25:23 <phaazon> () is used when you don’t want it to return anything
09:25:25 <Fuco> basically, I'm taking some callbacks and adding some MVar wrappers to execute them synchronously
09:25:35 <Iceland_jack> Heh
09:25:35 <phaazon> yeah, especially in callbacks
09:25:44 <piskrist> Fuco: I suspect IO a as well since that means "any return value" while IO () means "no return value". But it smells like deeper issue
09:25:55 <Baluse> I mean it doesnt seem to me much common for web development at least.
09:26:00 <simpson> GHC 7.6.3 won't let me derive Foldable.
09:26:07 <Fuco> piskrist: yea, the code right now is quite crap :/ I'm just experimenting with this right now
09:26:11 <piskrist> Fuco: since you never use the return value it might make sense to force IO () to denote this
09:26:18 <simpson> Baluse: That's okay. Things don't have to be common. After all, PHP is pretty common, but that doesn't make it good.
09:26:23 <Fuco> piskrist: that's what I thought
09:26:24 <phaazon> Baluse: please take your PHP ass out of here.
09:26:37 <piskrist> Fuco: anyway, if you are unsure it probably makes sense to just do whatever and see how it works / what happens
09:26:44 <mauke> phaazon: using PHP as an insult? o_O
09:26:48 <simpson> It claims, despite setting -XDeriveFoldable, that Foldable isn't a derivable class.
09:26:52 <piskrist> Fuco: unless you are designing a nuclear reactor or missile defense system, of course
09:26:58 <phaazon> mauke: it is, rihgt? :D
09:27:03 <Saizan> AleksejsHome: seems like you managed to lose the time pkg, you might need to reinstall ghc
09:27:12 <mauke> P*P
09:27:19 <Iceland_jack> phaazon: No?
09:27:32 <Fuco> here's a sample code if anyone want to check it out: http://sprunge.us/hKSj
09:27:47 <lericson> i think web development with haskell would be awesome
09:27:56 <phaazon> yeah well, I have my opinion about those languages…
09:27:58 <Iceland_jack> If you want someone to kick Baluse ask the ops, don't tell them to get their PHP ass out of here
09:27:59 <Baluse> ok I am not going to write here. Php just works for many dudes. You are wrong for hating someone posting a video that you dont like. It is reallity dude
09:28:00 <phaazon> lericson: it is, see happstack.
09:28:23 <phaazon> Baluse: sure, but it’s off topic
09:28:24 <phaazon> and NSFW
09:28:29 <lericson> Baluse: grow a pair and admit when you screw up
09:28:31 <sivteck> Baluse, you are posting nsfw videos and that's not cool
09:29:07 <Baluse> I dont give piece of shit if you ban me. I wanted to show you that video even if out of context I dont care.
09:29:13 <mauke> ok
09:29:15 --- mode: ChanServ set +o mauke
09:29:15 --- mode: mauke set +b $a:Baluse
09:29:26 <phaazon> yeah thank you mauke
09:29:31 <Fuco> trolls are getting really lazy these days
09:29:39 <Fuco> like, this didn't even raise my beat rate
09:29:40 <wei2912> can they troll better pls
09:29:42 <wei2912> it's damn boring
09:29:52 <wei2912> i wasn't even aware of it
09:29:58 <lericson> i don't think he was trying to troll tbh
09:29:59 <simpson> Okay, figured it out. GHC doesn't know what "Foldable" means automatically, so one must import Data.Foldable first.
09:30:26 <lericson> he just made an inappropriate comment and couldn't handle the negative reaction
09:30:40 <mauke> lericson: it wasn't just a comment
09:30:50 <phaazon> he was trolling
09:31:00 <mauke> they joined this channel "randomly" and posted nothing but links to that video
09:31:05 <lericson> oh i see
09:31:10 <mauke> I counted at least three
09:31:14 <lericson> very well
09:31:15 <Denommus> so, I'm experimenting with reactive-banana
09:31:20 --- mode: mauke set -o mauke
09:31:20 <Denommus> and I made a simple project: a webkitgtk window that has a link and a list. When the link is pressed, the list should alternate between hide and show
09:31:21 <phaazon> Denommus: have fun
09:31:28 <phaazon> I like reactive-banana :)
09:31:32 <clrnd> so you are experimenting with bananas ....
09:31:32 <Denommus> this is my main file: https://github.com/Denommus/SpellChat/blob/master/src/Main.hs
09:31:41 <Denommus> but the "visible" behavior is not acting as I intended. It is only alternating after the second press on the link
09:31:47 <Denommus> can anyone help me?
09:32:03 <RedNifre>  /join #programming
09:32:14 <RedNifre> silly keyboard...
09:32:24 <Denommus> RedNifre: wouldn't it be ##programming?
09:32:44 <Denommus> phaazon: so do I, but this issue with accumB is very weird
09:32:46 <RedNifre> I think it redirects automagically.
09:32:48 <lericson> i'm doing a project in numerical methods with matlab, i realize now that haskell would kick butt at this. several questions come to mind: are there *good* ODE solvers in haskell; and more importantly, how is the graphing toolkit?
09:34:21 <phaazon> Denommus: yeah, I don’t use reactive-banana a lot, so I can’t help you right now…
09:37:43 <Denommus> FRP seems so revolutionary, and yet so few people seem to be using it
09:38:10 <albeit> Denommus: How so? Not too familiar with FRP
09:38:35 <wei2912> Denommus: oh hi, you're here too
09:38:49 <silver> Denommus, well not that few
09:38:56 <piskrist> I enjoyed the video though
09:40:02 <johnw> ryantrinkle is doing some very cool things with FRP
09:40:32 <Denommus> albeit: it describes variable values as time depending functions
09:40:54 <favetelinguis> All the eamples about ad hoc polymorphism look like this sort of myFunc :: (RealFloat a) => [(a, b)] -> [b]. But how do i do if i want to limit the values of b also, not only a??
09:41:11 <johnw> (RealFloat a, RealFloat b)
09:41:22 <Denommus> albeit: one awesome thing about that is that you define the whole behavior of the value during the whole duration of the program on its declaration
09:41:32 <favetelinguis> hehe ok that was easy enogh
09:41:36 <mauke> :t (!)
09:41:37 <lambdabot> Ix i => Array i e -> i -> e
09:41:39 <lericson> johnw: can't you do T a => T b => a -> b
09:41:48 <johnw> lericson: I don't see why not
09:41:59 <johnw> even T a => a -> (T b => b)
09:42:15 <lericson> quite
09:45:55 <clrnd> mmm I don't know how to do this, I have a 'Type a b c d' and a 'Type2 (Maybe a) (Maybe b) ...' and I need to merge them
09:46:35 <EvanR> you can write a function
09:46:56 <EvanR> pattern matching on the a b c d Maybe a Maybe b ...
09:47:10 <piskrist> fx (Type x1 x2 x3 x4) = Type (fromJust x1) (fromJust x2) (fromJust x3) (fromJust x4)
09:47:26 <piskrist> but it smells like deeper design flaw
09:47:34 <EvanR> fx (Type2 ...
09:47:40 <piskrist> d'oh. The first Type is suppsoed to be Type2
09:47:47 <piskrist> EvanR: yeah, thanks.
09:48:20 <piskrist> There are some nice tricks that can be done with Control.Applicative and <*> and <$> on Maybes, I think
09:48:48 <clrnd> yeah I wanted something more 'general'
09:49:00 <clrnd> without involving TH :P
09:49:06 <EvanR> theres generics
09:49:25 <piskrist> clrnd: maybe show how do you get Type2 with all the mabes in the first place
09:50:03 <clrnd> wait a sec, I can't write this function, I have Type2, and I need Type
09:50:04 <wz1000> Hi! I just whipped up a static http server using bytestring in a couple of hours. This is the first 'proper' haskell application I've written, and it's performance is blowing me away. It's completely naive, and I've implemented no caching mechanism, yet its blowing away every nodejs or python static server I can find with over 7000 requests per second. Does static compilation make this much of a difference?
09:50:42 <clrnd> piskrist, basically I have an optparse-applicative, one without optional on every field :P
09:50:51 <clrnd> and one with optional
09:50:57 <EvanR> wz1000: having no dynamic types probably makes a big difference
09:51:04 <EvanR> lazy evaluation might be making a difference
09:52:00 <orbital> when playing with types in ghci, is it possible to create a typed entity with no value? For example, "here is *something* of type Maybe [Foo -> Bar], now tell me ":t map xyz <that thing of type Maybe [Foo -> Bar]>"
09:52:01 <bennofs> wz1000: GHCs IO manager is pretty optimized
09:52:26 <wz1000> orbital: Use type holes or undefined
09:52:30 <Iceland_jack> orbital: You can write "undefined"
09:52:38 <Iceland_jack> :t map undefined
09:52:39 <lambdabot> [a] -> [b]
09:52:40 <orbital> ooh.
09:52:41 <Iceland_jack> :t map undefined undefined
09:52:42 <mietek> Any MFlow users here?
09:52:42 <lambdabot> [b]
09:52:51 <orbital> wz1000 Iceland_jack thanks
09:53:29 <merijn> wz1000: GHC having an insanely optimised IO manager (see MIO paper) and compilation help tons, yes
09:53:33 <wz1000> orbital: You can constain its type too.
09:53:47 <wz1000> :t map (undefined :: Int -> String)
09:53:48 <lambdabot> [Int] -> [String]
09:54:05 <orbital> this is awesome
09:54:06 <EvanR> wz1000: and you dont even have to twist your program into nested node callbacks ;)
09:54:07 <clrnd> I basically have to update an object trough a REST API, so I GET it, replace the fields the user supplied, and POST it
09:54:15 <merijn> wz1000: Also note, that libraries like ByteString have seen insane levels of performance tuning, so while the API is high level, a lot of operations are about as fast as the equivalent handwritten C would be
09:54:30 <Denommus> I fixed my problem
09:54:32 <orbital> wz1000: even better!
09:54:37 <Denommus> it wasn't a problem with reactive-banana
09:54:56 <Denommus> it was a problem with using <a href="#"> as my button
09:55:08 <merijn> wz1000: But, yes, in general I would be surprised if a haskell web server *didn't* outperform node.js by an order of magnitude or so
09:55:11 <orbital> rewarding ghci experiences in the morning, better than coffee
09:55:18 <wz1000> merijn: Also, I think it was on par with others performance (2000 requests per second) when I was using String
09:55:26 <EvanR> i never knew about the :t undefined trick
09:56:04 <merijn> EvanR: Check out asAppliedTo and asTypeOf too :p
09:56:20 <yunxing> merijn: what's MIO paper? I can't find it on google...
09:56:23 <merijn> :t map `asAppliedTo` (undefined :: Int -> String)
09:56:24 <lambdabot> (Int -> String) -> [Int] -> [String]
09:56:43 <EvanR> @src asAppliedTo
09:56:43 <lambdabot> Source not found. Take a stress pill and think things over.
09:56:45 <SwashBuckla> Iceland_jack: that looks so strange (map undefined undefined)!
09:56:46 <Iceland_jack> yunxing: http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf
09:56:52 <yunxing> Iceland_jack: Thanks!
09:56:52 <orbital> wow, i can even use unbound type variables inside the constraint
09:56:55 <wz1000> > map _ ['a',
09:56:57 <lambdabot>  <hint>:1:12:
09:56:57 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
09:57:00 <merijn> yunxing: http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf
09:57:06 <wz1000> > map _ ['a','b','c']
09:57:06 <merijn> Drat, too slow :)
09:57:07 <lambdabot>  Found hole ‘_’ with type: GHC.Types.Char -> b
09:57:07 <lambdabot>  Where: ‘b’ is a rigid type variable bound by
09:57:07 <lambdabot>             the inferred type of it :: [b] at Top level
09:57:08 <simpson> :t asAppliedTo
09:57:09 <lambdabot> (a -> b) -> a -> a -> b
09:57:12 <EvanR> > map undefined undefined
09:57:14 <Iceland_jack> SwashBuckla: You can also replace "map" with undefined :)
09:57:14 <lambdabot>  *Exception: Prelude.undefined
09:57:16 <merijn> EvanR: asAppliedTo == const with different type :)
09:57:20 <Iceland_jack> > map undefined []
09:57:21 <lambdabot>  []
09:57:27 <EvanR> > undefined undefined
09:57:29 <lambdabot>  *Exception: Prelude.undefined
09:57:37 <wz1000> > map _CharToSomething ['a','b','c']
09:57:38 <lambdabot>  Found hole ‘_CharToSomething’ with type: GHC.Types.Char -> b
09:57:39 <lambdabot>  Where: ‘b’ is a rigid type variable bound by
09:57:39 <lambdabot>             the inferred type of it :: [b] at Top level
09:57:48 <EvanR> > undefined `asAppliedTo` undefined
09:57:49 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
09:57:49 <lambdabot>    arising from a use of ‘M33978599660672402613660.show_M33978599660672402613...
09:57:49 <lambdabot>  The type variable ‘b0’ is ambiguous
09:57:49 <lambdabot>  Note: there are several potential instances:
09:57:49 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
09:57:55 <SwashBuckla> :t undefined undefined undefined
09:57:57 <lambdabot> t
09:58:00 <EvanR> :t undefined `asAppliedTo` undefined
09:58:01 <lambdabot> a -> b
09:58:03 <merijn> Can we stio the undefined spam?
09:58:06 <merijn> *stop
09:58:09 <wz1000> :t fmap fmap
09:58:10 <lambdabot> (Functor f1, Functor f) => f (a -> b) -> f (f1 a -> f1 b)
09:58:12 <SwashBuckla> ok
09:58:17 <wz1000> :t fmap fmap fmap fmap
09:58:18 <lambdabot> (Functor f2, Functor f1, Functor f) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
09:58:55 <EvanR> :t fix undefined "spam"
09:58:56 <lambdabot> t
10:01:22 <MiguelAcosta> what up
10:08:43 <wz1000> Ok, shit. lighttpd handles 40,000 requests per second. Almost six times my servers.
10:08:55 <monochrom> :)
10:10:10 <albeit> When a Map is updated with a new value that is the same as the old value, does GHC optimize and "skip" the update, or is the old equivalent value thrown out / garbage collected?
10:11:04 <albeit> (As in, is the pointer to the value changed to the location of the new value?)
10:11:29 <merijn> wz1000: To be fair, that's probably only for static files
10:11:32 <Hijiri> Map from containers?
10:12:04 <albeit> Hijiri: Yes
10:12:16 <albeit> But sort of applicable to data structures in general
10:12:21 <Hijiri> I don't see how GHC could do that, the value might not even have an EQ instance
10:12:29 <Hijiri> Eq*
10:12:50 <merijn> Hijiri: That's not true
10:12:53 <merijn> Map requires Ord
10:12:57 <merijn> And Ord implies Eq
10:13:02 <Hijiri> but that's in hte keys
10:13:05 <Hijiri> not the values
10:13:35 <naudiz> I've got a function f with the type (a -> b -> a)... can I do something like map (map f list) list? Doing it like this gives me an error.
10:13:52 <merijn> Hijiri: Oh, true
10:13:53 <wz1000> merijn: Even my server is only for static files. But I expected something like that given it is ~100 lines of code and about 2 hours of effort :)
10:13:56 <Iceland_jack> naudiz: Do you want to map it to two lists? In that case you can use "zipWith"
10:13:58 <Iceland_jack> @ty zipWith
10:13:58 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
10:14:04 <merijn> wz1000: :)
10:14:16 <Iceland_jack> @ty zipWith (undefined :: a -> b -> a)
10:14:17 <lambdabot> [c] -> [b] -> [c]
10:14:31 <naudiz> Iceland_jack: but I want to have all possible permutations
10:16:14 <naudiz> Iceland_jack: using zipWith just gives me the combinations of the n-th arguments in each list
10:16:43 <kadoban> naudiz: Can you give an example of what you expect it to do?
10:17:46 <HeladoDeBrownie> (<*>) from Control.Applicative applies every function in the first list to every element in the second list
10:18:05 <HeladoDeBrownie> @type (<*>)
10:18:06 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
10:18:12 <HeladoDeBrownie> Just substitute f ~ []
10:18:18 <HeladoDeBrownie> [a -> b] -> [a] -> [b]
10:18:42 <naudiz> kadoban: I'm calculating distances in a lattice grid using bragg angles. Therefor I've got a function d=n*lambda/(2*sin(theta)), so I want to apply lists of possible values for n and theta
10:18:55 <naudiz> HeladoDeBrownie: thanks this might help
10:18:59 <pyrtsa> naudiz: f <$> a <*> b
10:20:06 <naudiz> yes, this is exactly what I wanted. thanks
10:23:27 <EvanR> i have seen people get confused when seeing Just "foo" evaluate to Just "foo". this kind of data is definitely different from normal languages. but i just realized a way to explain it, like an array where the first element is a symbol: [:Just "foo"]
10:24:39 <HeladoDeBrownie> That sounds misleading to me
10:25:07 <EvanR> well you dont have tuples in many languages you just use arrays
10:25:15 <centolire1967> hellooooooooooooooooooooooooooo
10:25:16 <EvanR> people are used to not messing with arrays, i think
10:25:19 <HeladoDeBrownie> However there is an intuition for Maybe that you reminded me of that definitely works, which is that Maybe A is a list of length at most one of A
10:26:14 <EvanR> i dont know if someone familiar with ruby or javascript will get that
10:26:20 <EvanR> neither of which have lsits
10:26:33 <HeladoDeBrownie> They have arrays, right? So just s/list/array/
10:26:54 <EvanR> but when dealing with maybe in haskell, or either, you dont have [] or ["foo"]
10:26:55 <HeladoDeBrownie> Not quite as good but eh
10:27:16 <EvanR> theres this tag not getting evaluated somehow, because its just there
10:27:19 <HeladoDeBrownie> Well sure, the syntax is different, but conceptually Maybe is exactly a list of length at most one
10:27:29 <EvanR> yeah, its isomorphic
10:27:51 <EvanR> but im just talking about the idea of constructing data that can be pattern matched, what the results even are
10:28:12 <EvanR> people get confused with the difference between Just 3 and Maybe Int
10:28:59 <wz1000> Would there be any performance difference between writing to a handle using hPutStr from ByteString vs using send from Network.Socket.ByteString?
10:29:06 <HeladoDeBrownie> If you're trying to avoid that sort of confusion, then I would probably hold off on talking about lists as well, since their type and data constructors look similar
10:29:08 <Fuco> is there some easy way to add "timeout" to a haskell function? (in IO of coure)
10:29:11 <EvanR> [] vs ["foo"] doesnt differentiate this from any old array, what even the point would be
10:29:20 <EvanR> Fuco: theres System.Timeout
10:29:23 <HeladoDeBrownie> Oh, I think I sort of see what you mean
10:29:40 <Fuco> EvanR: sweet, thanks
10:29:45 <HeladoDeBrownie> Another reason lists look weird compared to other types: syntactic sugar
10:29:53 <bergmark> in our workshops we define our own list type instead
10:30:04 <HeladoDeBrownie> bergmark, why?
10:30:10 <EvanR> [:Nothing] [:Just 3] [:Left 3] [:Right 3] are all obviously different "data" in ruby, should be more familiar
10:30:11 <HeladoDeBrownie> To avoid that confusion?
10:30:46 <EvanR> i just thought of this looking at this API, which uses this representation for the DSL http://docs.datomic.com/transactions.html
10:31:03 <bergmark> no sugar like HeladoDeBrownie said, and to distinguish type and values
10:31:27 <HeladoDeBrownie> Sounds reasonable
10:31:56 <kadoban> Sounds a bit horrible though. You have to reimplement a bunch of stuff then, don't you?
10:32:13 <bergmark> kadoban: the whole point of the exercise is to reimplement some stuff :-)
10:32:19 <pantsman-> I think it's incredibly valuable to reimplement stuff like List as a learning exercise
10:32:28 <HeladoDeBrownie> "workshop" to me implied a class of some sort
10:32:36 <kadoban> Oh I missed that part. I see
10:32:36 <HeladoDeBrownie> rather than for getting actual work done
10:32:55 <EvanR> yeah thats a sweatshop ;)
10:33:00 <kadoban> Hah
10:33:30 <centolire1967> !list
10:33:30 <monochrom> centolire1967: http://lpaste.net/browse
10:34:12 <merijn> I never know whether monochrom has a script for that or is just easily bored... :p
10:35:03 <HeladoDeBrownie> There are ways to find out
10:35:06 <Hijiri> are author names ever added to the spam filter?
10:35:43 <kadoban> Hijiri: ?
10:36:26 <Hijiri> I don't remember the name, but I was trying to post something with an author name filled in and it was blocked by the spam filter
10:36:34 <Hijiri> but when I reversed the author name it went through
10:36:45 <Hijiri> with the same content
10:37:05 <kadoban> I think I'm missing context
10:38:03 <Hijiri> I don't see how context would make it clearer
10:38:05 <Hijiri> oh
10:38:06 <Hijiri> I'm talking about lpaste
10:38:19 <kadoban> Ah
10:43:47 <AleksejsHome> Hi, I'm still in cabal hell. hslogger-1.2.4 contains some bug and fails to install. I install hslogger-1.2.6, then I install missingH, which decides to install hslogger-1.2.4, and it fails
10:44:20 <AleksejsHome> how to explain to missingH that he doesn't need to install hslogger?
10:44:43 <jfischoff> yes allow-newer and constraint=“hslogger-1.2.6”
10:46:13 <jfischoff> cabal install --allow-newer=hslogger --constraint="hslogger-1.2.6" missingH
10:46:16 <jfischoff> I think that will work
10:46:35 <jfischoff> assuming you have cabal version >= 1.20
10:46:50 <dcoutts> syntax is hslogger==1.2.6, I don't think it accepts foo-1.0 style
10:46:59 <dcoutts> since it's a constraint not a package id
10:47:52 <jfischoff> oh right
10:48:27 <jfischoff> cabal install --allow-newer=hslogger --constraint="hslogger==1.2.6" missingH
11:03:26 <natschil_> Hi, does show::[Integer]->String return
11:03:47 <natschil_> sorry, I pressed enter by mistake, ingnore the above
11:03:54 <AleksejsHome> cabal: unrecognized option `--allow-newer=hslogger'
11:04:03 <AleksejsHome> how is that possible?
11:04:40 <merijn> AleksejsHome: Your cabal is too old?
11:05:20 <AleksejsHome> 1.16
11:06:21 <merijn> Yeah, I think allow-newer is only around since 1.18 or 1.20?
11:07:28 <AleksejsHome> is there any painless way to upgrade it?
11:08:06 <Hijiri> cabal install cabal and cabal install cabal-install
11:08:06 <AleksejsHome> nvm
11:08:34 <RyanGlScott> Is there a library that can automatically derive Show instances using Template Haskell?
11:09:06 <Hijiri> well you can automatically derive them already for ADTs with Show-able fields
11:10:22 <merijn> RyanGlScott: Why not use StandaloneDeriving?
11:11:06 <RyanGlScott> It's for learning purposes. I have a library (text-show) that provides a Text equivalent of Show, and I'd like to make it easier to create instances.
11:14:43 <merijn> RyanGlScott: class TextShow a where textShow :: a -> Text; default textShow :: Show a => a -> Text; textShow = T.pack . show
11:15:14 <merijn> RyanGlScott: Now people can write "instance TextShow Foo" for any Foo which is a Show instance and they'll be done
11:15:23 <RyanGlScott> merijn: That would work, but that requires the type to be an instance of Show in the first place. I'd like to entirely avoid the old Show.
11:16:03 <merijn> RyanGlScott: Then I think you'll have to implement it yourself
11:17:12 <RyanGlScott> I ask since ndmitchell's derive library has close to what I need (http://hackage.haskell.org/package/derive-2.5.18/docs/Data-Derive-Show.html), but it doesn't work for type operators.
11:17:36 <RyanGlScott> I was wondering if there was just another implementation lurking somewhere deep in Hackage.
11:19:16 <sm> nobody knows what's lurking deep in Hackage
11:19:35 <bergmark> RyanGlScott: syb has a gshow with a Data constraint
11:20:47 <bergmark> there's also a GShow in generic-deriving
11:21:12 <RyanGlScott> bergmark: I've considered using Generics, but I can't seem to get DefaultSignatures to play nicely with Show.
11:22:12 <RyanGlScott> See here http://hackage.haskell.org/package/text-show-0.2.0.0/docs/Text-Show-Text.html
11:22:50 <monochrom> merijn: the response to !list was programmed, don't worry :)
11:22:52 <RyanGlScott> Show is minimally defined by showbPrec or showb, so if I put a default signature one of those functions, it prevents one from being defined in terms of the other.
11:23:21 <monochrom> however, it is true that one needs to be bored in order to even bother to program it up :)
11:24:40 <merijn> Are CPS transforms really easy, or is the fact that my default background for thinking is haskell skewed my vision since laziness/Core is trivial to CPS transform?
11:24:47 <RyanGlScott> GShow from generic-deriving gets around this by requiring gshowsPrec to always be defined, but I feel like that sacrifices some flexibility.
11:25:07 <monochrom> CPS transforms are pretty easy.
11:25:26 * monochrom defines "easy" to mean "can be done by a computer in linear time" :)
11:25:32 <bergmark> RyanGlScott: ok, i don't think i've tried doing that
11:25:33 <mauke> if your language has first-class functions
11:25:45 <monochrom> that's true
11:26:29 <RyanGlScott> bergmark: I'd be OK with only supporting a Template Haskell autoderiving mechanism if it means keeping the same behavior as String's Show.
11:27:19 <RyanGlScott> I guess, at least, I'd need to learn how infix data constructors are represented in TH.
11:28:08 <AleksejsHome> from cabal manual: " Sometimes the older installed version is still on the program search $PATH" - I can see that cabal still uses 1.16. How to explain him to use the newer one?
11:28:57 <merijn> monochrom: I was just reading a post on compiling with CPS transforms, which had a ton of complexity that I didn't see the point of. But I guess you need it in impure languages to maintain the right semantics
11:29:20 <RyanGlScott> On a related question, is it true that Template Haskell cannot be used on the iOS version of GHC?
11:30:00 <bergmark> RyanGlScott: template-haskell has InfixC, not sure exactly how it behaves though
11:30:37 <RyanGlScott> bergmark: Ooh, that looks promising. I'll check that out.
11:30:45 <monochrom> AleksejsHome: in PATH, order matters. do you already know this?
11:33:59 <clrnd> my brain is suffering the trauma of working with nested Maybe types :S
11:34:30 <HeladoDeBrownie> @type fmap . fmap
11:34:31 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
11:35:06 <monochrom> use join to collapse two levels to one :)
11:35:13 <monochrom> > join (Maybe (Maybe True))
11:35:14 <lambdabot>  Not in scope: data constructor ‘Maybe’
11:35:15 <lambdabot>  Perhaps you meant ‘MaybeT’ (imported from Control.Monad.Trans.Maybe)Not in s...
11:35:15 <lambdabot>  Perhaps you meant ‘MaybeT’ (imported from Control.Monad.Trans.Maybe)
11:35:18 <monochrom> oops
11:35:26 <monochrom> > join (Just (Just True))
11:35:28 <lambdabot>  Just True
11:37:33 <ij> "@src" join is so simple, I think it's even funny.
11:38:43 <merijn> RyanGlScott: You can't use TH for cross-compilation, no. I think luite is working on fixing that for ghcjs
11:39:24 <RyanGlScott> merijn: In the meantime, is it considered good practice to put a flag in your packages that allows them to build without template-haskell?
11:39:53 <merijn> I have no idea
11:40:30 <RyanGlScott> Hm, I actually can't find any packages that do this, now that I look.
11:41:22 <vanila> @src join
11:41:22 <lambdabot> join x = x >>= id
11:41:25 <bergmark> i wouldn't do that unless someone requested it
11:45:12 <mauke> @. unpl src join
11:45:12 <lambdabot> join x = x >>= \ a -> a;
11:45:23 <mauke> @. do . unpl src join
11:45:24 <lambdabot> <unknown>.hs: 1: 8:Parse error: =
11:45:26 <mauke> :-(
11:45:32 <y> do a ← x; a
11:45:38 <mauke> @do x >>= \ a -> a
11:45:38 <lambdabot> do { a <- x; a}
11:45:46 <mauke> well, that's boring
11:45:57 <clrnd> monochrom, I had a Maybe a and another a' and needed a' if first was Nothing, otherwise (Just a) so I did 'Just ma' and I wanted 'Just <$> ma' so lol ...
11:46:02 <clrnd> debugging was hard
11:46:18 <k00mi> RyanGlScott: I do remember seeing such a flag, but it certainly isn't very common
11:47:01 <clrnd> but also pretty fun!
11:55:48 <mietek> Any Wheb framework users?
11:55:52 <mietek> Silly name is silly.
11:56:53 <belst> hey guys, a function of mine (which is very slow) benchmarks for specific inputs like this:
11:56:53 <belst> (19.30 secs, 58093202144 bytes)
11:57:06 <belst> really 58GB?
11:57:42 <albeit> belst: Do you have the code?
11:57:57 <belst> its pretty long
11:58:04 <belst> and its not very good :D there are better solutions
11:58:24 <belst> but the problem is genericReplicate with big numbers i guess
11:58:40 <JohnRo> Hey, I have a "UTCTime" and I want to compare that to the current time using "diffUTCTime". But "getCurrentTime" gives me an "IO UTCTime". Any idea how to do that?
11:58:46 <clrnd> belst, haskell's profiler is super good
11:59:01 <belst> so the 58GB are probably correct i guess :D
11:59:35 <clrnd> JohnRo, getCurrentTime is a IO action, you'll need to do it In The Monad
11:59:38 <bergmark> mietek: i assumed you typoed that...
11:59:45 <mauke> JohnRo: attach a callback with >>=
12:00:03 <clrnd> difference <- diffUTCTime t1 =<< getCurrentTime
12:00:16 <mauke> that looks wrong
12:00:20 <mauke> :t diffUTCTime
12:00:20 <albeit> belst: It's probably correct, but there is something wrong in the code almost certainly
12:00:20 <lambdabot> Not in scope: ‘diffUTCTime’
12:00:36 <albeit> belst: Well, not wrong, but not ideal
12:00:51 <belst> albeit, not really :D its by far not the best solution. But it wasnt supposed to be
12:00:54 <mietek> bergmark: no...
12:00:54 <mauke> do { now <- getCurrentTime; let { d = diffUTCTime t1 now }; ... }
12:01:05 <EvanR> JohnRo: you can compare two utctimes without any conversion, its an instance of Ord
12:01:21 <mietek> bergmark: https://github.com/hansonkd/Wheb-Framework
12:01:27 <EvanR> :t compare
12:01:28 <lambdabot> Ord a => a -> a -> Ordering
12:01:39 <mietek> Trying to figure out how to set the listen port in this thing
12:02:31 <clrnd> JohnRo, difference <- return . diffUTCTime t1 =<< getCurrentTime
12:02:49 <mauke> >>= return . is liftM/fmap
12:03:06 <mauke> difference <- diffUTCTime t1 <$> getCurrentTime
12:03:48 <clrnd> ahhh yeah, that's what I was looking for in my Control.* mental database
12:06:38 <EvanR> now <- getCurrentTime; let diff = diffUTCTime then now; ... ;)
12:06:49 <EvanR> variables for the win
12:07:15 <Iceland_jack> EvanR's version is probably the nicest to understand
12:07:21 <mauke> EvanR: I already did that
12:07:32 <EvanR> yeah i see that
12:07:57 <mr_rm> i'm trying to make sure i understand this... (Integral a, Fractional a) => [a -> a -> a]    does it mean that any function in this list must be in ONE of those type classes but can be either one?
12:08:01 <EvanR> insert within any old do block
12:08:23 <mauke> mr_rm: no, it means all functions in this list work on a type that is both integral and fractional
12:08:45 <clrnd> mr_rm, it means the list contains functions a -> a -> a where a is Integral AND Fractional
12:08:52 <EvanR> all the a are the same
12:09:21 <mr_rm> [(*),(/),div] :: (Integral a, Fractional a) => [a -> a -> a]
12:09:51 <mr_rm> but div is only Integral, right?
12:09:59 <mauke> div requires Integral
12:10:04 <mauke> (/) requires Fractional
12:10:16 <mauke> if you put them in the same list, they unify and require something that's both
12:10:30 <EvanR> :t div :: (Integral a, Fractional a) => a -> a -> a
12:10:31 <lambdabot> (Integral a, Fractional a) => a -> a -> a
12:10:39 <EvanR> so that specializes the type
12:10:40 <mr_rm> mauke: ah, ok that's what i wasn't getting. that they "unify" like that
12:10:50 <mauke> all elements of a list have the same type
12:10:59 <mr_rm> that makes sense
12:11:36 <mr_rm> i thought it would just go up to some type class further up, like Num
12:12:33 <EvanR> i have to understand subtypes at least to be able to explain why they wont work in situation X ;)
12:13:44 <mauke> there are no subtypes
12:13:55 <EvanR> mr_rm: sounds like youre thinking that if you put various things together theres a least common type or something, where something like Any is the last resort
12:14:20 <EvanR> which is not how it works with typeclass constrained types
12:14:28 <mauke> it goes the other way
12:14:32 <mauke> constraints stack
12:15:06 <mr_rm> mauke: yes that makes sense and clears up my confusion. obviously i've done too much OOP lately!
12:15:35 <mauke> I don't think this would have worked even in OOP land
12:16:00 <mr_rm> it would if you have a common superclass for everything in the mix
12:16:10 <mauke> you have some Num methods and (/), which is only defined in the Fractional subclass
12:16:11 <EvanR> yes, if you could only operate on nums, then the fractional functions might accidentally be used on something that didnt support fractional operations
12:16:27 <y> @type √
12:16:28 <lambdabot> parse error on input ‘√’
12:16:37 <y> @type sqrt
12:16:39 <lambdabot> Floating a => a -> a
12:16:43 <mr_rm> mauke: true. you'd have to pull those "methods" up to the parent class :)
12:16:50 <kadoban> :t (√)
12:16:51 <lambdabot> Not in scope: ‘√’
12:17:03 <y> what would sqrt do with Num(s)? crash?
12:17:13 <EvanR> mr_rm: thats essentially what it does, the union of all these constrains can be thought of the "superclass" but it has fewer inhabitants not more
12:17:16 <monochrom> it would be a type error
12:17:39 <mauke> > let foo :: (Num a) => (a -> a) -> a; foo f = f 2 in foo sqrt
12:17:41 <lambdabot>  1.4142135623730951
12:17:53 <mauke> :3
12:18:59 <monochrom> > let foo :: (a -> a) -> a; foo f = f 2 in foo sqrt
12:19:01 <lambdabot>  Could not deduce (GHC.Num.Num a1) arising from the literal ‘2’
12:19:01 <lambdabot>  from the context (GHC.Float.Floating a)
12:19:01 <lambdabot>    bound by the inferred type of it :: GHC.Float.Floating a => a
12:19:01 <lambdabot>    at Top level
12:19:01 <lambdabot>  Possible fix:
12:19:06 <monochrom> oh heh
12:19:31 <EvanR> what the heck
12:19:42 <monochrom> :)
12:19:57 <y> @type sqrt :: Num a => a -> a
12:19:58 <lambdabot>     Could not deduce (Floating a1) arising from a use of ‘sqrt’
12:19:58 <lambdabot>     from the context (Num a)
12:19:58 <lambdabot>       bound by the inferred type of it :: Num a => a -> a at Top level
12:21:43 <monochrom> so-called "foo sqrt" is better written as "(foo :: (Double -> Double) -> Double) sqrt" after type inference, defaulting, etc.
12:22:04 <monochrom> so you are still looking at sqrt::Double->Double. nothing fancy.
12:22:32 <monochrom> Num b => (forall a. Num a => a -> a) -> b  will reject sqrt
12:23:39 <EvanR> :t undefined :: (forall a. Num a => a -> a) -> b
12:23:40 <lambdabot> (forall a. Num a => a -> a) -> b
12:23:53 <EvanR> :t undefined :: (forall a. a) -> b
12:23:54 <lambdabot> (forall a. a) -> b
12:23:57 <EvanR> k
12:24:12 <mauke> :t 1 :: 2
12:24:13 <lambdabot>     Expected a type, but ‘2’ has kind ‘GHC.TypeLits.Nat’
12:24:13 <lambdabot>     In an expression type signature: 2
12:24:13 <lambdabot>     In the expression: 1 :: 2
12:28:43 <EvanR> is there a good reference, examples of using RankN in practice
12:34:18 <absence> several talks at cppcon focus on the importance of writing (c++) code that is cpu cache friendly. how good/bad is ghc at being cache friendly in the code it generates?
12:35:57 <ErikBjare_> Is 'Learn You A Haskell For Great Good' still the primary learning resource for newcomers?
12:36:39 <RchrdB> absence: depends almost entirely on what data structures you use. Often ~kinda okay~ because the size of the zeroeth (most often collected) GC generation is picked to fit in most chips' L2.
12:37:14 <clrnd> ErikBjare_, yeah pretty much
12:37:17 <RchrdB> absence: "how cache-efficient is this code?" is almost always a question about the data structures that the code uses, not the programming language that it was written in.
12:37:43 <gilligan_> any nix users here who tried ghci-ng ? I am failing at creating a default.nix for it
12:37:48 <EvanR> the most obvious question is how cache-efficient is Data.Map ;)
12:38:03 <ErikBjare_> clrnd: Thanks
12:38:24 <RchrdB> Heh. :)
12:38:25 <ErikBjare_> Going to take the functional programming course at my uni this semester and want to be a bit prepared.
12:38:38 <kadoban> ErikBjare_: lyah, rwh and http://www.seas.upenn.edu/~cis194/spring13/lectures.html are what I usually point people towards.
12:39:26 <ErikBjare_> kadoban: Ty
12:39:45 <absence> RchrdB: yes, i imagine using ByteString, Text, Vector, etc where possible is important, i was more curious about the thunk/laziness stuff
12:41:18 <RchrdB> absence: http://stackoverflow.com/questions/13982863/how-much-memory-does-a-thunk-use should be relevant.
12:41:53 <RchrdB> I'd expect the answer re: thunks to be about, how long do you leave them lying around for, when and in what kind of pattern do you force them?
12:42:26 <RchrdB> which also dovetails suspiciously neatly with questions like "what's the GC overhead of using thunks?" :)
12:47:18 <absence> RchrdB: interesting stuff, thanks :)
12:47:53 <EvanR> this is really amazing to me, that you can get memory usage at runtime
12:47:57 <dmj`> how do I get a value out of a Producer?, runEffect returns unit
12:48:10 <merijn> dmj`: pipes?
12:48:21 <dmj`> for (yield 4 >> yield 4) (lift . print) works... but what if I want to return that last result
12:48:22 <dmj`> yea
12:48:32 <clrnd> so I'm ordering a book from Amazon, and since delivery is quite expensive for Latin America, I'm thinking of adding a Haskell book, any recommendation?
12:48:49 <EvanR> they were talking about "thompson" in #haskell-beginners
12:49:12 <dmj`> merijn: I'm using http-pipes that has a Producer BytesString IO () for a body, full of json
12:49:12 <ReinH> Bird's new book looks pretty great
12:49:19 <dmj`> pipes-http*
12:49:35 <ReinH> It's a "completely rewritten" version of one of my favorite FP books of all time
12:49:44 <ReinH> Thomson's 2011 edition is also very nice
12:49:52 <clrnd> ReinH, I was checking it, you mean Thinking Funtionally?
12:49:57 <clrnd> dunno about thompsons
12:49:58 <ReinH> Yep.
12:50:01 <merijn> dmj`: Ok, so the problem you have here is that http-pipes is using () as return value
12:50:16 <absence> i imagine all the pointer indirection from boxed types will add up, but nothing worse than "naive" OO code in other languages. i guess that's one of the reasons unboxing helps for performance
12:50:16 <ReinH> clrnd: Haskell: The Craft of Functional Programming
12:50:18 <merijn> dmj`: The reason for this is "because they can prematurely abort the pipe"
12:50:20 <monochrom> Bird's new book is on my Black Friday shopping list :)
12:50:39 <ReinH> clrnd: a few more at http://reinh.com/notes/posts/2014-07-25-recommended-reading-material.html, but those two would be my first port of call
12:50:47 <ReinH> monochrom: I couldn't wait that long ;)
12:50:56 <merijn> dmj`: If you want to somehow return, say Int. You have to "fmap" over the "Producer ByteString IO ()" to change () to Int
12:50:58 <ReinH> Also I need to update that page now
12:51:20 <merijn> dmj`: Now, what that fmap does depends on what qualifies as sensible behaviour for premature termination
12:52:12 <ReinH> merijn: () -> Int is isomorphic to const :)
12:52:17 <clrnd> mmm Bird's looks kind of basic, it ends with Parsec
12:52:17 <ReinH> (up to bottoms)
12:52:27 <merijn> ReinH: Sure
12:52:37 <merijn> ReinH: But which Int to return depends on his usecase
12:52:39 <ReinH> clrnd: Well, what Bird's book teaches you isn't library use, it's reasoning about construction of Haskell programs
12:52:57 <ReinH> Which is a far more valuable thing to learn
12:53:18 <clrnd> I like that it has a chapter on proofs
12:53:44 <ReinH> The previous version of that book is the best book on FP I have ever read.
12:53:55 <clrnd> let's see
12:54:30 <clrnd> ReinH, of Bird's? can't find it
12:54:43 <monochrom> The previous version was the first book, ever, to explain the memory usage of foldl (+) and why foldl' solves it
12:54:54 <ReinH> clrnd: http://www.cs.ox.ac.uk/publications/books/functional/
12:54:59 <ReinH> monochrom: :)
12:55:02 <monochrom> and still the only book, I think
12:55:21 <ReinH> I am very excited by this new version.
12:55:33 <monochrom> it also went as far as monad transformers
12:55:42 <monochrom> @quote monochrom Bird.*history
12:55:43 <lambdabot> monochrom says: krad!  I'm reading Bird's haskell book now.  It has fusion, parser monad, and monad transformers!  If I read this book instead of Paulson's ML book ten years ago, the history of the entire human race would have to be rewritten!
12:55:55 <ReinH> hahaha
12:56:08 <EvanR> krad!
12:56:14 <ReinH> Libraries come and go. The algebra of programming is forever. :)
12:56:23 * hackagebot ghcid 0.3.2 - GHCi based bare bones IDE  http://hackage.haskell.org/package/ghcid-0.3.2 (NeilMitchell)
12:57:08 <EvanR> probably due to monochrom's nick i imagine that irc message come through in black and white
12:57:14 <EvanR> ing
12:58:23 <clrnd> well change of plans, the first book is Tufte's Visual Display of Quantitative Information, suggest a second
12:59:13 <monochrom> on the theory side, it has induction proofs for correctness and deriving programs, and the induction works for lazy data too. (it's easy, just add one more base case for bottom.)
12:59:42 <monochrom> it is something uncompromising on both theory and practice
13:02:21 <clrnd> i does look very solid and interesting, it's just that I'm not in the mood for that kind of book ... just finished SICP 2nd ed
13:02:42 <EvanR> lisp D:
13:04:10 <ReinH> clrnd: I don't have enough information to suggest a book based on which mood you are currently in :p
13:04:14 <clrnd> i lol'd, it's a nice book nevertheless!
13:04:38 <dmj`> merijn: that's not cool
13:04:40 <clrnd> ReinH, I mentioned a book related to my mood up there ^ ;)
13:04:59 <dmj`> merijn: how am I supposed to get the request body if I can't extract the value out of a consumer?
13:05:06 <dmj`> merijn: I could dump it into an mvar
13:05:15 <ReinH> clrnd: I don't have a Book -> Mood decoder ring, sorry :p
13:05:22 <dmj`> producer*
13:05:45 <dreams> The guy who found parser combinators is not a human.
13:05:48 <clrnd> instance Mood Applicative where ... nevermind
13:06:49 <dreams> Its so complicated
13:06:52 <dmj`> merijn: fmapping over unit isn't too helpful :/
13:07:13 <ReinH> clrnd: Maybe this one http://books.google.com/books?id=5Xk-AQAAIAAJ
13:07:36 <vanila> dreams, it's quite simple!
13:07:37 <merijn> dmj`: I think you're approaching this the wrong way?
13:08:20 <vanila> dreams, there's a writeup on how to develop parsec from scratch that shows how it all comes about
13:08:25 <dreams> vanila: its simple when you look at it in a declarative manner. I have tried to trace the computations by hand. Its incredible.
13:08:30 <merijn> dmj`: You can "fmap (const Nothing)" over "Producer ByteString IO ()" and then have "Consumer ByteString IO (Maybe Document)"
13:08:42 <vanila> it is incredible, yeah :)
13:08:49 <merijn> dmj`: The problem is that the author of http-pipes seems to have exposed a completely unhelpful producer
13:09:07 <vanila> using a monad to consume input and handle backtracking
13:09:24 <dreams> vanila: Which tutorial?
13:09:43 <dfeuer_> Hmmm... I wonder what laws Cale thinks Alternative and MonadPlus should satisfy.
13:10:04 <merijn> dmj`: The type of that producer should clearly have been "Producer ByteString IO (Either HttpError a)"
13:10:39 <merijn> dmj`: Then you'd just use "fmap Right (myConsumer)" with "myConsumer :: Consumer ByteString IO a"
13:11:05 <clrnd> ReinH, now this is what I'm talking about! thanks!
13:11:12 <vanila> let me see
13:11:19 <clrnd> yay algebra!
13:11:30 <sinelaw> meh
13:12:04 <merijn> dmj`: Actually, why are you not using "Pipes.HTTP.stream"?
13:12:28 <dmj`> merijn: where is this package?
13:12:36 <dmj`> it's not a part of pipes-http
13:12:41 <vanila> having trouble finding it..
13:12:48 <merijn> Yes it is...
13:13:07 <dmj`> https://hackage.haskell.org/package/pipes-http-1.0.0
13:13:08 <ReinH> clrnd: There's plenty of algebra in Bird's book. Most of it is thinly disguised algebra. ;)
13:13:13 <dmj`> I don't see that module listed...
13:13:13 <merijn> dmj`: http://hackage.haskell.org/package/pipes-http -> click Pipes.HTTP module -> scroll down
13:13:20 <merijn> It's a function
13:13:40 <merijn> "stream :: Producer ByteString IO () -> RequestBody"
13:13:44 <dmj`> merijn: stream is for request body, not a response body
13:13:56 <dmj`> I am using stream, for the req body
13:15:45 <dmj`> the withHTTP method, second argument, I thought I could attach a Consumer, await, then return and then connect them, runEffect doesn't return unit, just unsure how to get out of the Producer Monad, or Proxy monad
13:16:14 <merijn> responseBody :: Response body -> body, that produces "Producer ByteString IO ()"
13:16:31 <dmj`> yea, here let me lpaste
13:16:35 <merijn> dmj`: Well, the entire point of pipes is to consume the body in a streaming fashion
13:17:38 <merijn> You could do "Pipes.ByteString.toLazyM", but that kinda defeats the point...
13:17:52 <dmj`> http://lpaste.net/113859
13:17:55 <vanila> dreams, http://research.microsoft.com/pubs/65201/parsec-paper-letter.pdf found it, pg 8 shows the definition
13:18:09 <vanila> sorry 9
13:18:46 <dmj`> merijn: yes, streaming with the body and parsing are a must for perf, I guess I'm just struggling to see how to get the result of the sink out of pipe
13:20:05 <merijn> dmj`: You probably want to use pipes-parse + pipes-attoparsec to do streaming parsing
13:20:41 <merijn> dmj`: What you want is "detect end of input, then return everything so far"
13:21:30 <merijn> dmj`: But you *can't* detect early termination. The fixed result type of pipes is used to guarantee exactly that
13:21:44 <dmj`> merijn: yea I want to stream the Producer ByteString IO () into a FromJSON a => Producer (Either ParseException a) IO (), then pull that out and return it
13:21:49 <merijn> dmj`: If you need to detect early termination, like for network protocols you need pipes-parse
13:22:05 <dreams> vanila: this one http://tinyurl.com/lkzxzdx ?
13:22:52 <dmj`> merijn: yea, was going to use the parsers from Data.Aeson.Parsers and the parse function from pipes parse
13:23:30 <merijn> dmj`: You want Pipes.Attoparsec.parse to turn an attoparsec parser into a pipes-parse parser and then use evalStateT to get the result
13:24:02 <dmj`> yes yes! he has that in his blog post, but the problem is that I still need to return the result out of the Producer
13:24:04 <dreams> vanila: thanks, before I read it. Does it give enough info to build a parser?
13:24:21 <dmj`> son <- evalStateT (parse json') (responseBody resp)
13:24:24 <dmj`> json*
13:24:44 <dmj`> merijn: but he never returns it... he just prints it, http://www.haskellforall.com/2014/02/pipes-http-10-streaming-httphttps.html
13:24:46 <merijn> Anyway, mail the mailing list, Tekmo is really responsive and wrapping your head around pipes-parse is tricky initially. I need to get back to work :\
13:25:04 <dmj`> merijn: k thanks
13:29:03 <sinelaw> is there an executable I can run on a module (.hs file) that will run all quickcheck on all predicates within?
13:35:02 <dmj`> merijn: evalStateT pulls the parsed bytestring out of the produer, boom
13:40:50 <joe9> http://hackage.haskell.org/package/monad-coroutine-0.6.1/docs/Control-Monad-Coroutine.html just want to check if the coroutine's can fork?
13:51:26 * hackagebot binary-list 1.0.0.0 - Lists of length a power of two.  http://hackage.haskell.org/package/binary-list-1.0.0.0 (DanielDiaz)
13:59:10 <johnw> joe9: heya
13:59:43 <deech> What is the best way of running shell commands portably from a Cabal script? Right now I'm using `rawSystemExit`.
14:01:22 <johnw> deech: you could use shake for that, or shelly
14:01:54 <deech> johnw: I'd rather not take on another dependency if possible.
14:12:25 <joe9> GeneralizedNewtypeDeriving seems really cool that it writes the functor, applicative and monad instances automatically for you
14:12:44 <juanpablo_> joe9: doesn't it just take the instance from the type it wraps?
14:13:12 <juanpablo_> Does anyone know why Aeson's `decode` works, but `fromJSON` fails?
14:13:23 <juanpablo_> It uses the same instance, right?
14:17:27 <albeit> @src decode
14:17:28 <lambdabot> Source not found. Wrong!  You cheating scum!
14:17:36 <albeit> @src Data.Aeson.decode
14:17:36 <lambdabot> Source not found. stty: unknown mode: doofus
14:19:02 <albeit> They do appear to be slightly different. decode = decodeWith json fromJSON
14:19:38 <dmbaturin> What is the most idiomatic way to write a function that applies a function to e.g. every nth element of a list and leaves the rest unchanged?
14:20:54 <vanila> dmbaturin, make a cyclic list [f,id,id,id,f,id,id...] and then zipWith ($)
14:21:13 <Iceland_jack> :t cycle [f,id,id,id]
14:21:14 <lambdabot> (FromExpr a, Show a) => [a -> a]
14:22:44 <dmbaturin> vanila: Oh, I didn't know about cycle. Thanks!
14:33:41 <joelteon> that's very, uh, clever
14:36:27 * hackagebot binary-list 1.0.0.1 - Lists of length a power of two.  http://hackage.haskell.org/package/binary-list-1.0.0.1 (DanielDiaz)
14:43:08 <Guest19807> Indeed very neat, but I'm feeling it's more of a trickery, it might take a reader a few 'cycles' to realise what it does...
14:51:59 <dfeuer_> :t replicate
14:52:00 <lambdabot> Int -> a -> [a]
14:55:25 <Schluri> :pl \x y -> fromIntegral x + 1000*y
14:58:32 <phaazon> anyone here could help me with my EDSL?
14:59:31 <phaazon> the idea is that I’d like to be able to capture lambda application without existentially quantification
14:59:43 <phaazon> in my EDSL, a lambda is:
15:00:32 <phaazon> Lam :: E ar a a -> c -> E ar a c
15:00:46 <phaazon> (forget about the ar, it’s just a name)
15:00:55 <phaazon> the application is :
15:01:27 <jesyspa> Schluri: flip (.) (1000*) . (+) . fromIntegral
15:01:45 <phaazon> (:$) :: E a (E ar b c) -> a -> E b c
15:02:06 <phaazon> a is existentially quantified
15:02:28 <phaazon> so I can’t extract the a value out of the expression tree when compiling the EDSL
15:02:31 <phaazon> any idea?
15:02:42 <phaazon> (:$) :: E ar a (E ar b c) -> a -> E ar b c
15:02:51 <phaazon> (missed the ar at some places)
15:02:59 <wjlroe> I have a function String -> IO String which I want to use with interact, but that wants String -> String    - how can I make them work together?
15:03:23 <monochrom> can't do that.
15:04:46 <phaazon> ok, no one seems to know :D edwardk maybe?
15:06:02 <wjlroe> monochrom ok, for some reason I thought reading all stdin was going to be harder than just getContents... anyway, cheers
15:06:46 <monochrom> getContents and then doing your own stuff is more flexible than interact, yeah.
15:08:19 <phaazon> hm, I guess lambda application has to keep the applied type
15:08:25 <phaazon> so that when I do a :$ b
15:08:43 <phaazon> the resulting type gives me the type of a and the type of b, and the resulting type
15:08:59 <vanila> phaazon, what is the AST for?
15:09:20 <phaazon> absract shaders, see https://github.com/phaazon/ash
15:09:42 <phaazon> I have a GLSL compiler written here
15:09:47 <phaazon> but it fails on (:$)
15:09:52 <phaazon> which is obvious
15:11:59 <vanila> I don't realy understand the approach you're using
15:12:07 <phaazon> which one?
15:12:20 <lorettOrangina> @pl x y ->  x y
15:12:20 <lambdabot> (line 1, column 7):
15:12:20 <lambdabot> unexpected '>'
15:12:20 <lambdabot> expecting operator
15:12:23 <phaazon> vanila: I want strongly typed AST with name binding
15:12:31 <vanila> http://lpaste.net/113866
15:12:33 <vanila> so let's just focus on this
15:12:40 <phaazon> yeah
15:12:41 <vanila> well
15:12:48 <lorettOrangina> @pl \x y ->  x y
15:12:49 <lambdabot> id
15:12:50 <vanila> why not use lambda to represent binders?
15:12:54 <lorettOrangina> way too late for this
15:13:10 <phaazon> vanila: I do actually
15:13:16 <lorettOrangina> @pl \x y ->  fromIntegral x + 1000*y
15:13:16 <lambdabot> (. (1000 *)) . (+) . fromIntegral
15:13:16 <phaazon> sort of
15:13:19 <vanila> I can't see that in your GADT definition
15:13:28 <phaazon> there’s a Let expression though
15:13:32 <phaazon> vanila: but first
15:13:37 <phaazon> what don’t you understand?
15:13:47 <vanila> the definition of E
15:13:52 <phaazon> ok
15:13:53 <phaazon> well
15:14:09 <phaazon> the firt type variable, ar, is some kind of arrow representing names
15:14:26 <phaazon> I use it to represent names
15:14:43 <phaazon> ar a b represents a name of type b and open on a
15:14:55 <phaazon> a function a -> b, for instance
15:14:59 <vanila> ooh okay
15:15:19 <phaazon> a free variable is commonly ar a a
15:15:24 <phaazon> a close variable is ar () a
15:15:28 <phaazon> (I may switch to Void though)
15:15:35 <phaazon> closed*
15:16:24 <phaazon> then
15:16:33 <phaazon> Lit lifts a literal up in the EDSL
15:16:38 <phaazon> b -> E ar () b
15:16:51 <phaazon> Var lifts any kind of variable up in the EDSL
15:17:00 <phaazon> so ar a b -> E ar a b
15:17:06 <phaazon> if a ~ b, it’s a closed variable
15:17:08 <phaazon> (bound)
15:17:12 <vanila> alright
15:17:16 <phaazon> Lam…
15:17:54 <phaazon> Lam takes an open expression, another one to assign the open expression to, and yields an open expression
15:18:06 <phaazon> if you look at (~>) at the bottom of the file
15:18:18 <phaazon> you’ll see I turn the free variable into a closed one in c
15:18:41 <vanila> it seems a bit complex to have to use typeclasses for this
15:18:58 <phaazon> how would you do?
15:21:58 <phaazon> vanila: (:$), on the other hand, is a bit trickier I guess
15:21:58 <lorettOrangina> @pl p x = mod x 1000:p (div x 1000)
15:21:58 <lambdabot> p = fix (ap ((:) . flip mod 1000) . (. flip div 1000))
15:22:08 <phaazon> since I want to keep any value
15:22:29 <phaazon> I have to express some kind of « eaten type » concept in the resulting EDSL
15:22:38 <phaazon> and I have no idea how to do that
15:23:14 <vanila> what do you mean exactly?
15:23:39 <lorettOrangina> :pl (\x->if x== 0 then Nothing else Just $swap$ divMod x 1000)
15:23:48 <lorettOrangina> @pl (\x->if x== 0 then Nothing else Just $swap$ divMod x 1000)
15:23:48 <lambdabot> ap (flip if' Nothing . (0 ==)) (Just . swap . flip divMod 1000)
15:24:12 <phaazon> vanila: (:$) takes an open expression and try to close it with another one
15:24:22 <phaazon> if it closes the expression, I lose the variable :
15:24:29 <phaazon> (:$) :: E a b -> a -> b
15:24:38 <phaazon> which is impossible for a GADT, so :
15:24:48 <phaazon> (:$) :: E a (E b c) -> a -> E b c
15:24:58 <phaazon> here, a is existentially qualified
15:25:04 <phaazon> I can’t inspect such a value
15:25:08 <vanila> http://lpaste.net/113866
15:25:09 <phaazon> since it could be anything :(
15:25:12 <vanila> how about something like this
15:25:33 <vanila> I wrote "see" to make sure this is usable
15:26:08 <lorettOrangina> @pl \x->if x== 0 then Nothing else Just (mod x 1000, div x 10000)
15:26:08 <lambdabot> ap (flip if' Nothing . (0 ==)) (Just . ap ((,) . flip mod 1000) (flip div 10000))
15:26:12 <phaazon> interesting vanila
15:26:22 <phaazon> why « Note »?
15:26:26 <phaazon> why not V
15:26:31 <phaazon> like in the bound lib?
15:26:40 <vanila> I don't know that lib
15:27:12 <phaazon> data Note ty = Bound ty | Free String
15:27:13 <phaazon> ok
15:27:36 <phaazon> however
15:27:43 <phaazon> you’re Lam sounds wrong
15:28:00 <vanila> I just added 'ev' to the example
15:28:45 <phaazon> how do you observe the lambda?
15:28:49 <phaazon> I guess you can’t
15:28:57 <vanila> I just posted two examples of doing that
15:29:19 <phaazon> yeah but I don’t get it
15:30:04 <phaazon> why
15:30:08 <phaazon>  Lam :: (Note a -> STLC b) -> STLC (a -> b)
15:30:10 <phaazon> instead of
15:30:16 <phaazon>  Lam :: Note a -> STLC b -> STLC (a -> b)
15:30:37 <vanila> that's so we can use haskells lambda to represent an object language binder
15:30:47 <vanila> like this:  Lam (\x -> Lam (\y -> Var y :$ Var x))
15:31:07 <phaazon> yeah but you lose the name
15:31:18 <phaazon> you have to reconstruct it in the compiler
15:31:25 <phaazon> as you do with your State
15:31:26 <vanila> if you want to store variable names you can use   Lam :: String -> (Note a -> STLC b) -> STLC (a -> b)
15:31:31 <vanila> and write  Lam "x" (\x -> ...)
15:31:56 <phaazon> yeah but
15:32:06 <phaazon> how do you see the body of the lambda?
15:32:26 <phaazon> body <- see (f (Free v))
15:32:28 <phaazon> that’s weird
15:32:32 <phaazon> I’d have pass it a Bound
15:32:49 <vanila> there are different use cases
15:33:09 <vanila> ev demonstrates Bound and see demonstrates Free
15:33:17 <phaazon> I don’t see ev
15:33:26 <vanila> http://lpaste.net/113867
15:33:28 <phaazon> can you paste the new link?
15:33:29 <phaazon> thanks
15:34:11 <phaazon> interesting
15:34:29 <phaazon> so I guess I can change my ar a b to v a
15:34:40 <phaazon> E :: (* -> *) -> * -> *
15:34:47 <phaazon> E v a
15:34:57 <phaazon> and define lambda as
15:35:31 <phaazon> Lam :: (v a -> E v b) -> E v (a -> b)
15:35:37 <phaazon> and the application as
15:35:52 <phaazon> (:$) :: E v (a -> b) -> E v a -> E v b
15:35:53 <phaazon> dammit
15:35:54 <vanila> that seems like a good idea!
15:36:02 <phaazon> still quantified
15:37:45 <vanila> phaazon, does your language have a closed universe of types? e.g. you only have Int, Bool, ty -> ty, Either ty ty maybe and no newly definable ones ?
15:38:48 <phaazon> no vanila
15:38:55 <vanila> okay, that makes it harder
15:39:00 <phaazon> vanila: for instance
15:39:06 <phaazon> a vertex shader should represent tuples
15:39:15 <phaazon> (see my (:.) types)
15:39:24 <phaazon> (which is a total mess right now)
15:39:26 <phaazon> (:D)
15:39:46 <vanila> hehe
15:40:24 <Gurkenglas> http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Arrow.html names the axiom arr (f >>> g) = arr f >>> arr g, but (>>>) outputs a cat a b and arr takes a function. Am I getting this wrong?
15:40:37 <vanila> btw another thing I would suggest,
15:40:43 <lorettOrangina> @pl f x = Just$ swap$ divMod x 1000
15:40:43 <lambdabot> f = Just . swap . flip divMod 1000
15:40:54 <vanila> Add, Sub, ..., Pi, Exp, ..., ACosH
15:41:09 <vanila> You could take all of these out of the GADT and make them into a couple data types
15:41:14 <vanila> and then use something a bit like Lit to embed them
15:41:24 <vanila> this will make pattern matching on the GADT much easier
15:41:24 <monochrom> Gurkenglas: that means the >>> on the left is just function composition, i.e., just using the (->) instance of Category
15:41:30 * hackagebot keter 1.3.5.2 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-1.3.5.2 (MichaelSnoyman)
15:41:44 <phaazon> vanila: indeed
15:41:46 <phaazon> thanks :)
15:42:24 <Gurkenglas> Ah, thanks.
15:44:08 <phaazon> vanila: I think I can do better
15:44:20 <phaazon> E :: (* -> *) -> (* -> *) -> * -> *
15:44:37 <phaazon> E b f a
15:44:41 <phaazon> bound, free, type
15:44:51 <phaazon> I think that’s how edwardk does in bound
15:45:07 <phaazon> so that I can express closure in the type system
15:45:44 <phaazon> however that makes me to add a new ctor
15:45:49 <phaazon> and drop the Var one
15:45:56 <phaazon> Free :: f a -> E b f a
15:46:05 <phaazon> Bound :: b a -> E b f a
15:46:09 <phaazon> sounds okay though
15:46:20 <vanila> this seems awfully complex
15:46:39 <phaazon> vanila: yeah but with your solution
15:46:50 <phaazon> I could end up with bound variable where it shouldn’t be
15:48:56 <phaazon> anyway, thank you very much for your help vanila :)
15:49:02 <phaazon> you’ve been a great help to me!
15:49:03 <vanila> sure :)
15:51:02 <Gurkenglas> :t collatz
15:51:03 <lambdabot> (Integral a, Fractional a) => a -> a
15:51:05 <Gurkenglas> > collatz 5
15:51:07 <lambdabot>  No instance for (GHC.Show.Show a0)
15:51:07 <lambdabot>    arising from a use of ‘M915972272943260294320427.show_M9159722729432602943...
15:51:07 <lambdabot>  The type variable ‘a0’ is ambiguous
15:51:07 <lambdabot>  Note: there are several potential instances:
15:51:07 <lambdabot>    instance [safe] GHC.Show.Show
15:51:09 <Gurkenglas> What is this
15:51:27 <benzrf> is unagi-chan a pun
15:52:03 <FireFly> > collatz 5 :: Int
15:52:04 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Types.Int)
15:52:04 <lambdabot>    arising from a use of ‘L.collatz’
15:52:35 <FireFly> Hum, both integrla and fractional eh
15:52:38 <FireFly> integral*
15:53:39 <Gurkenglas> <Gurkenglas> @define collatz x = if x%2==0 then x/2 else 3*x+1
15:53:39 <Gurkenglas> <lambdabot>  Defined.
15:54:27 <monochrom> replace % by `rem`
15:54:41 <monochrom> and / by `div`
15:57:49 <phaazon> vanila: I can’t show Lam
15:57:55 <ij> Does acid-state takes O(n_updates) to start up?
15:57:56 <phaazon> since a -> b is not showable
15:58:21 <phaazon> I guess the typical fix to do to is data a :-> b = a :-> b
15:58:39 <phaazon> Lam :: f a -> E b f c -> E b f (a :-> c)
15:59:21 <vanila> I showed how to implement a show function called see
16:00:43 <phaazon> hm
16:05:39 <zennist1> Is cabal install <package name> same as going to the hackage page, downloading the cabal source package and install it?
16:06:23 <merijn> zennist1: Pretty much
16:06:35 <merijn> minus some dependency solution business
16:07:01 <merijn> i.e. it will try to figure out a compatible set of dependencies for you based on version bounds
16:07:18 <zennist1> merijn: <https://hackage.haskell.org/package/BerkeleyDB> take this package for example, I find the package I get using cabal install berkeleydb to be different from what I get from the webpage
16:08:19 <merijn> You're getting an older version? Perhaps newer ones have dependencies inconsistent with what you have installed?
16:09:02 <zennist1> Yes, cabal install berkeleydb gives me an older version (dates back to 2008). I downloaded manually from web and installed without problem though
16:10:06 <merijn> peculiar....
16:10:11 <batchm> > _ >>= putStrLn
16:10:13 <lambdabot>  Found hole ‘_’ with type: GHC.Types.IO GHC.Base.String
16:10:18 <merijn> If you can reproduce, file a ticket on trac?
16:10:20 <batchm> how can I get that in ghci?
16:10:29 <merijn> batchm: The hole warning?
16:10:37 <batchm> I guess?
16:10:42 <batchm> the _ thingy
16:11:08 <merijn> Good question
16:11:15 <Iceland_jack> You can set ':set -fwarn-typed-holes'
16:11:31 * hackagebot keter 1.3.5.3 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-1.3.5.3 (MichaelSnoyman)
16:11:32 <merijn> Iceland_jack: That's on by default, though
16:11:44 <batchm> in ghci? I am getting this: Some flags have not been recognized: -fwarn-typed-holes
16:11:55 <Iceland_jack> merijn: Are you sure?
16:11:56 <batchm> too old of a version maybe?
16:12:00 <merijn> Iceland_jack: Yes
16:12:04 <batchm> 7.6.3
16:12:10 <josephle> that's too old
16:12:14 <Iceland_jack> Starting 'ghci -ignore-dot-ghci' and ':set' gives me no warnings set
16:12:16 <merijn> batchm: typed holes are new in 7.8
16:12:24 <batchm> too bad
16:12:51 <merijn> Although it doesn't seem to work with 7.8 either
16:12:56 <Iceland_jack> merijn: (Never mind) :)
16:13:14 <batchm> > head [1, _]
16:13:15 <lambdabot>  Found hole ‘_’ with type: a
16:13:15 <lambdabot>  Where: ‘a’ is a rigid type variable bound by
16:13:15 <lambdabot>             the inferred type of it :: a at Top level
16:13:35 <batchm> and it is strict too.. cool
16:13:44 <merijn> batchm: It's not strict
16:13:47 <batchm> but you say it doesn't work in 7.8 either?
16:13:50 <merijn> batchm: Typed holes are a typechecking error
16:13:58 <merijn> Therefore don't have anything to do with laziness
16:14:14 <Iceland_jack> batchm: It works in 7.8 (https://www.haskell.org/ghc/docs/7.8.3/html/users_guide/typed-holes.html)
16:14:31 <merijn> I'm not sure why GHCi reports "<interactive>:2:1: Pattern syntax in expression context: _"
16:14:48 <geekosaur> 7.6?
16:14:57 <geekosaur> hm
16:15:01 <merijn> geekosaur: 7.8 and 7.9
16:15:13 <jle`> wat there is already a 7.9 branch
16:15:22 <geekosaur> with :set -fwarn-typed-holes? that sounds wrong
16:15:37 <merijn> geekosaur: Without that set, -fwarn-typed-holes is on by default
16:15:55 <merijn> jle`: There's been a 7.9 branch since slightly before the 7.8 release?
16:16:27 <merijn> Well, maybe I've already fixed this, let me recompile GHC to check
16:17:15 <jle`> oh
16:17:39 <merijn> Odd numbered versions are development branches
16:17:46 <batchm> > undefined _
16:17:47 <lambdabot>  Found hole ‘_’ with type: t0
16:17:47 <lambdabot>  Where: ‘t0’ is an ambiguous type variable
16:18:11 <merijn> ok, ghci apparently does *not* enable typed holes by default
16:18:30 <merijn> ":set -fwarn-typed-holes" works for me
16:19:14 <merijn> Anyway, it's a moot point since if I have my way there won't be a way to disable typed holes in 7.10 :p
16:20:54 <linman32> does foldr start evaluating on the last value of a list, or the first? or better maybe, is foldr memory efficient?
16:21:28 <jle`> linman32: one easy way to check: manually expand it out yourself :)
16:21:33 <jle`> @src foldr
16:21:33 <lambdabot> foldr f z []     = z
16:21:33 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
16:21:49 <merijn> > foldr (||) False (True : repeat False)
16:21:50 <lambdabot>  True
16:22:14 <merijn> linman32: foldr is lazy if f is lazy in it's second argument (as the implementation shows)
16:23:51 <linman32> merijn: makes sense i think. it hits true, then it stops. but i still can't wrap my head around if it starts w/ first value or last
16:24:05 <linman32> how could it start with first in this example? f x1 (f x2 (f x3 (f x4 ... (f xn z) ... )))
16:24:22 <merijn> linman32: If "f" never looks at the second argument
16:24:27 <merijn> linman32: Like my (||) example
16:24:29 <jle`> linman32: it evaluates whatever `f` wants
16:24:37 <jle`> @src (||)
16:24:37 <lambdabot> True  || _ =  True
16:24:37 <lambdabot> False || x =  x
16:24:50 <merijn> Since the left argument is True, (||) never evaluates the second recursive argument
16:25:05 <jle`> > foldr const 1 [2..]
16:25:06 <lambdabot>  2
16:25:20 <jle`> > foldr const undefined [1..]
16:25:21 <lambdabot>  1
16:25:35 <jle`> const 1 (const 2 (const 3 ...))
16:25:40 <jle`> const 1 _ = 1
16:25:44 <linman32> ok
16:25:44 <jle`> so it all = 1
16:26:02 <jle`> @src const
16:26:03 <lambdabot> const x _ = x
16:26:09 <linman32> how about? (1 + (2 + (3 + z)))
16:26:19 <linman32> has to start with 3 + z, right?
16:26:26 <jle`> no
16:26:34 <jle`> it starts with the (+) in 1 + ...
16:26:46 <jle`> well
16:26:49 <jle`> it looks there first
16:26:53 <linman32> the parens are lies?
16:26:53 <jle`> _ + _
16:27:00 <jle`> the parents are for associativity
16:27:02 <jle`> not for evaluation
16:27:11 <linman32> hmm
16:27:12 <jle`> in this case the first addition actually done is 3+z
16:27:50 <jle`> it looks at the outermost + and says "what do you need to give me an answer"
16:28:01 <jle`> and the + says "well...i need 1, and (2 + (3 + z))"
16:28:22 <merijn> Right, just checked, holes will be on by default in ghci for the next release
16:28:24 <jle`> and to get that, it asks that second + what it needs. and it says "well, i need 2 and the result of (3 + z)
16:28:31 <linman32> so then it is memory inefficient?
16:28:32 <jle`> and to get that, it asks that deepest (+)
16:28:43 <jle`> that's implementation-dependent ;)
16:29:21 <merijn> "foldr (+) 0" is a memory inefficient way of doing sum, yes
16:29:38 <linman32> ok. makes sense, w/ (||) and (+) example i think, but what do you mean implementation-dependent?
16:29:51 <linman32> ahh
16:29:59 <merijn> linman32: He means that (+) might be lazy for some types
16:30:15 <merijn> But the general simple case of Int/Integer/Double/etc. this will be inefficient, yes
16:30:34 <absence> it builds thunks for the whole list?
16:31:18 <absence> > foldr (+) 0 [1..1000000]
16:31:20 <lambdabot>  500000500000
16:31:27 <absence> > foldr (+) 0 [1..10000000]
16:31:32 <lambdabot>  mueval-core: Time limit exceeded
16:31:32 <lambdabot>  mueval: ExitFailure 1
16:31:38 <absence> bleh
16:31:43 <batchm> does ? work in ghc as well or just ghci?
16:31:50 <jle`> > sum [1..10000000]
16:31:52 <batchm> hole
16:31:55 <lambdabot>  mueval: ExitFailure 1
16:32:03 <absence> jle`: sum is foldl, no?
16:32:03 <batchm> does hole work in ghc as well or just ghci?
16:32:18 <linman32> so is foldl memory efficinet?
16:32:25 <jle`> i am foldl
16:32:38 <mietek> Any "Wheb" framework users?
16:32:41 <absence> linman32: for (+), no :) you need foldl'
16:32:54 <absence> linman32: it's a wart
16:33:00 <jle`> linman32: it's kind of hard to really make general statements
16:33:14 <jle`> you kind of just have to think about what you are doing
16:33:18 <Eduard_Munteanu> linman32, foldr would be fine with non-strict operations, unlike (+) on Integers and such
16:33:20 <jle`> (unfortunately?)
16:33:32 <jle`> usually the thinking isn't so bad
16:33:43 <jle`> and just manually unfolding a few steps should give you an answer
16:33:48 <jle`> @src foldl
16:33:48 <lambdabot> foldl f z []     = z
16:33:48 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
16:33:50 <jle`> @src foldr
16:33:50 <lambdabot> foldr f z []     = z
16:33:50 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
16:33:53 <linman32> ok, i have been reading this top answer some. it talks about it: http://stackoverflow.com/questions/3082324/foldl-versus-foldr-behavior-with-infinite-lists
16:34:46 <linman32> thanks all. this is really helpful
16:35:51 <zennist1> What is the function for joining string by a separator
16:36:05 <jle`> zennist1: give a type :D
16:36:10 <absence> but why does "foldr (+) 0 [1..10000000]" die from time limit? shouldn't it blow up like sum [1..10000000]?
16:36:30 <jle`> zennist1: what is the type of the function you are looking for? :)
16:36:35 <Eduard_Munteanu> zennist1, intercalate/intersperse
16:36:37 <zennist1> jle`: String->[String]->String
16:36:40 <linman32> longwinded haha; maybe a blog post with a diagram explaining fold(s) operations characteristics w/ respect to non-strictness and such would be helpful
16:37:01 <jle`> @hoogle [String] -> String -> String
16:37:03 <lambdabot> System.Process showCommandForUser :: FilePath -> [String] -> String
16:37:04 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
16:37:04 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
16:37:05 <zennist1> join sep ls -> joined_string
16:37:18 <nshepperd> most usually, you use foldl' for stricty f, foldr for lazy f
16:37:39 <jle`> also, you will rarely ever use foldl
16:37:58 <zennist1> jle`: that's it! intercalate! I always forget this one
16:38:01 <absence> linman32: have you seen the diagrams here? i often find them useful:  https://www.haskell.org/haskellwiki/Fold
16:38:11 <jle`> zennist1: luckily hoogle doesn't forget :)
16:38:52 <zennist1> jle`: any chance of me doing this conveniently in my shell? lambdabot looks really convenient
16:39:06 <jle`> hoogle is a command line tool
16:39:51 <jle`> :D
16:39:51 <linman32> absence: no, i haven't. thanks =)
16:40:03 <lorettOrangina> @pl f x = Just$ swap$ divMod x 1000
16:40:03 <lambdabot> f = Just . swap . flip divMod 1000
16:40:20 <absence> linman32: just remember to use foldl' instead of foldl
16:40:42 <jle`> zennist1: http://chromaticleaves.com/posts/how-to-hoogle.html
16:42:22 <zennist1> jle`: cool, cheers!
16:44:04 <jle`> np!
16:44:37 <phaazon> vanila: ahah my EDSL rocks
16:44:39 <phaazon> \o\
16:44:54 <phaazon> but, I haven’t found out how to show a literal
16:45:10 <phaazon> *Ash> Lam (\x -> x + 3) :: E V V (Int -> Int)
16:45:10 <phaazon> Lam (0) (Add (0) (<lit>))
16:45:34 <phaazon> if I put a constraint (Show a,…)
16:45:40 <phaazon> I can’t recurse anymore
16:45:45 <phaazon> (on the Lam ctor)
16:46:28 <zennist1> What is the correct way of doing encoding conversion in haskell? Do I need to install any package for this?
16:46:32 <vanila> phaazon, nice work :)
16:46:50 <vanila> maybe you coul create a record for showable literals
16:46:54 <Eduard_Munteanu> zennist1, what encodings? UTF-8 and such?
16:47:20 <vanila> data Lit a = Lit { val :: a, showLit :: a -> String } or something
16:47:32 <jle`> the text package has some nice tools i think, iirc
16:47:37 <zennist1> Eduard_Munteanu: no, it's for cjk, so for example chinese gbk encoding
16:47:59 <phaazon> vanila: yeah, but when I say show, I mean more generally “inspect”
16:48:07 <phaazon> for a compiler to use the value, for instance
16:48:42 <vanila> ah, well I think the problem is that litearl can be anything
16:48:54 <vanila> you would need to restrict to a universe which you have a way to handle each possible case
16:49:07 <phaazon> yeah
16:49:11 <phaazon> LitInteger
16:49:13 <phaazon> LitDouble
16:49:15 <phaazon> and so on
16:49:37 <Enigmagic> zennist1: text-icu (if you have icu4c available) would probably do the trick
16:49:44 <phaazon> it should not be that restrictive since shaders don’t use a lot of types
16:49:52 <phaazon> I’ll just need to be able to create vectors
16:49:57 <phaazon> like V3 Int
16:51:30 <phaazon> oh
16:51:31 <phaazon> *Ash> Lam (\x -> Lam $ \y -> x + y) :: E V V (Int -> Int -> Int)
16:51:31 <phaazon> Lam (x0) (Lam (x1) (Add (x0) (x1)))
16:51:33 <phaazon> lovely :)
16:53:40 <phaazon> ahahah
16:53:48 <phaazon> the application is now trivial to write vanila !
16:53:54 <vanila> sweet
16:54:10 <phaazon> f :$ x -> case f of { Lam g -> showE (g x); _ -> error "should not happen" }
16:54:20 <phaazon> let’s try this out…
16:54:37 <phaazon> oh god it works
16:54:37 <phaazon> :D
16:55:00 <phaazon> ah, _ -> is wrong
16:55:06 <phaazon> I need to do something here
16:55:16 <phaazon> *Ash> let λ = Lam (\x -> Lam $ \y -> x + y) :: E V V (Int -> Int -> Int)
16:55:16 <phaazon> *Ash> λ :$ 1
16:55:16 <phaazon> Lam (x0) (Add (<lit>) (x0))
16:55:16 <phaazon> *Ash> λ :$ 1 :$ 1
16:55:16 <phaazon> *** Exception: should not happen
16:55:19 <phaazon> :D
16:56:41 <phaazon> that’s funny how it changes names though
17:00:10 <fuziontech____>  _______
17:01:17 <zennist1> How to convert between String and DAta.Text
17:01:50 <pavonia> @hoogle Text -> String
17:01:51 <lambdabot> Data.Text.Lazy.Internal showStructure :: Text -> String
17:01:51 <lambdabot> Data.Text.Internal showText :: Text -> String
17:01:51 <lambdabot> Data.Text.Lazy unpack :: Text -> String
17:02:04 <pavonia> @hoogle String -> Text
17:02:05 <lambdabot> Data.Text.Lazy pack :: String -> Text
17:02:05 <lambdabot> Data.Text pack :: String -> Text
17:02:05 <lambdabot> Prelude read :: Read a => String -> a
17:07:21 <zennist1> @hoogle Text -> String
17:07:21 <lambdabot> Data.Text.Lazy.Internal showStructure :: Text -> String
17:07:21 <lambdabot> Data.Text.Internal showText :: Text -> String
17:07:21 <lambdabot> Data.Text.Lazy unpack :: Text -> String
17:08:58 <SvenskFisk> Hey guys, I'm working on making a Go game in Haskell, I posted here earlier about how to traverse the pieces of the game to find the strings (groups of pieces), and found out how to do that. Now I'm trying to write a function that, given a list of pieces, finds all the strings. The problem is it shouldn't return duplicate strings. The way I did it seems sort of hack-ish : http://lpaste.net/113869. I tr
17:09:04 <SvenskFisk> ied using fold and map originally to avoid recursion, but I couldn't figure it out. Is there a cleaner way to go about this?
17:16:36 <sohum> is there a quick way to check what, for instance, the instance Functor ((->) r) looks like?
17:17:50 <goglosh> SvenskFisk: your code looks kindof like what I'd do
17:18:05 <goglosh> SvenskFisk: what exactly bothers you?
17:19:04 <simonator_> hi. I'm experimenting with making a program that analyses a syntax tree and possibly delivers multiple errors (rather than stopping at the first). I thought I'd use a writer - can anyone tell me if there's a neater way of analysing the cases than a case-of? http://lpaste.net/113870
17:19:16 <phaazon> sohum: source code
17:20:40 <phaazon> sohum: http://hackage.haskell.org/package/base-4.7.0.1/docs/src/GHC-Base.html#Monad
17:20:47 <phaazon> see just below
17:20:48 <pavonia> @src Functor (->)
17:20:48 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
17:20:56 <pavonia> @src Functor ->
17:20:56 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
17:21:02 <phaazon> @src (->) Functor
17:21:02 <lambdabot> Source not found. Do you think like you type?
17:21:08 <phaazon> @src ((->) r) Functor
17:21:08 <lambdabot> Source not found. :(
17:21:09 <HeladoDeBrownie> (->) has the wrong kind
17:21:19 <phaazon> @src Functor ((->) r)
17:21:20 <lambdabot> Source not found. Whoa.
17:21:30 <HeladoDeBrownie> ¯\_(o_0)_/¯
17:21:34 <phaazon> yeah well
17:21:36 <phaazon> see my link.
17:21:41 <phaazon> instance Functor ((->) r) where fmap = (.)
17:22:14 <zennist1> I have a slightly off-topic question but still related to Haskell. I'm trying to write a Haskell dicitonary program where it should give me the Chinese words given the corresponding alphabetic spelling (pinyin). Now I have the database and I have the choice to put it down as a plain text file and tell Haskell to 'grep' for the particular line or I can dump it into a proper database and use one of Hackage's packages to retr
17:22:38 <HeladoDeBrownie> simonator_, looks okay to me
17:23:20 <zennist1> For option 1 I can implement it purely in basic Haskell but I suppose the performance won't be better?
17:23:26 <HeladoDeBrownie> zennist1, you cut off at "to retr"
17:23:57 <zennist1> HeladoDeBrownie: sorry. ..to retrieve words. My question, which approach is better?
17:24:02 <sohum> phaazon: thanks!
17:24:09 <pavonia> @src (->) fmap
17:24:09 <lambdabot> fmap = (.)
17:24:13 <pavonia> \o/
17:24:35 <phaazon> pavonia: lambdabot source are not those defined in hackage, right?
17:24:41 <sohum> pavonia: yay! yea, that's exactly what I wanted
17:24:51 <phaazon> it sounds wrong
17:24:56 <phaazon> fmap doesn’t exist for (->)
17:25:14 <phaazon> (bimap does)
17:25:19 <HeladoDeBrownie> zennist1, depends on your requirements. Do you want it to be human-readable? Would one option be significantly slower than the other?
17:25:26 <pavonia> phaazon: Yes, it's an extra file with code snippets
17:25:29 <HeladoDeBrownie> zennist1, I suppose the latter is what you're asking?
17:25:38 <pavonia> https://github.com/mokus0/lambdabot/blob/master/lambdabot/State/source
17:26:00 <phaazon> yeah
17:26:06 <phaazon> I prefer using the official source :)
17:26:12 <lorettOrangina> @pl scheissArrowswolltennichtfunktionieren (x:xs) (y:ys) = x ++[y] ++scheissArrowswolltennichtfunktionieren xs ys 	
17:26:13 <lambdabot> scheissArrowswolltennichtfunktionieren = fix ((`ap` tail) . (. head) . flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .)) .) . flip ((.) . (.) . (.) . (++)) . (flip ((.) . (:)) .))
17:26:15 <phaazon> oh btw
17:26:15 <HeladoDeBrownie> If so, you'd probably best test and see
17:26:17 <lorettOrangina> oh god
17:26:19 <phaazon> I’m curious
17:26:32 <phaazon> is the Applicative-Monad proposal is going to throw return away?
17:26:32 <zennist1> HeladoDeBrownie: I'm currently developing the prototype with the database approach. I'm hoping that it provides a better performance.
17:26:43 <phaazon> or defined it as return = pure?
17:26:50 <zennist1> HeladoDeBrownie: During the process though I realize that there is this constant tradeoff in Haskell
17:27:08 <phaazon> wtf lorettOrangina :D
17:27:36 <simonator_> HeladoDeBrownie: I was thinking of something like Eq m, Monoid m => (m, a) -> Either m a, depending on whether m is empty (which would probably necessitate Eq, not sure if the type signature is right)
17:27:38 <lorettOrangina> ikr
17:27:41 <zennist1> HeladoDeBrownie: where I can always opt to use arbitrary third-party packages that use low level (C-like) interface that 'promises' to give me better performance
17:27:53 <HeladoDeBrownie> zennist1, don't just assume something will perform significantly better. You might have other good reasons to prefer a database, like ease of use, but assuming something will perform a certain way is often erroneous
17:27:56 <zennist1> HeladoDeBrownie: but at the same time, I lose that functional elegance
17:28:15 <HeladoDeBrownie> zennist1, what "functional elegance" are you referring to?
17:28:40 <zennist1> HeladoDeBrownie: the level of purity..?
17:29:12 <HeladoDeBrownie> zennist1, evaluation in Haskell is pure. Period. (Unless you use a back door.) So purity isn't really something you're trading away.
17:29:27 <zennist1> HeladoDeBrownie: for example, the functions from Prelude and Data.List Monad, etc. seem pretty natural to me, but some packages I'm going to use are basically C in the syntax of haskell
17:29:56 <HeladoDeBrownie> Although that is a good point, foreign libraries are somewhat more likely to use a back door, but hopefully in a safe manner
17:30:09 <HeladoDeBrownie> Either way I suspect that's not the issue at hand
17:30:20 <HeladoDeBrownie> Can you give an example of how a certain way would be "less pure" than nother?
17:30:26 <HeladoDeBrownie> another*
17:30:35 <zennist1> HeladoDeBrownie: do you have any link or keyword for me to search on Google which explains the 'purity' stuff in more detail for haskell?
17:31:07 <HeladoDeBrownie> What level of detail do you want? Most introductory readings will give you at least a basic explanation
17:31:10 <HeladoDeBrownie> E.g., LYAH
17:31:53 <zennist1> all right guess I'll read up first
17:33:18 <zennist1> HeladoDeBrownie: I see my problem now. It seems to me that extensive use of data types just looks 'less functional' to me
17:33:32 <HeladoDeBrownie> zennist1, I'm still curious what you mean. Example?
17:34:27 <zennist1> e.g. someData <- createHandle a b c d e .....operations on that 'someData' in the form of 'operation1 someData', and all in one big 'do' block
17:34:47 <simonator_> zennist1: I have the opposite impression. algebraic types to me very much reminds me of functional programming.
17:35:28 <HeladoDeBrownie> zennist1, is it because of the do expression that you see it as less pure? Do expressions are just a convenient way to compose things together, basically.
17:36:04 <zennist1> cool. I suppose it's just a style problem
17:36:05 <simonator_> zennist1: there's not that many non-functional languages that support pattern matching, and that's a language feature where you see algebraic types a lot.
17:36:18 <HeladoDeBrownie> Like when you say do { foo ; bar } :: IO (), you are really gluing together these two procedures, foo and bar, to create a new procedure. Nothing impure there.
17:36:55 <HeladoDeBrownie> What *is* impure is *execution* of IO () values, but that's a separate issue from evaluation, and is only done by the I/O system.
17:37:36 <simonator_> zennist1: actually, do-blocks will look more procedural in a lot of cases (depending on the semantics of the underlying monad), but without necessary cost to the safety and purity of the underlying computations.
17:37:39 <zennist1> somehow whenever I read code like the example I mentioned above I wish I never design an interface like that ....
17:37:53 <fread2282> can someone help me find a blog (post)? the site was minimally styled w/ no comments, the post was about an algorithm on starsemigroups that is useful in many cases (it provided regular expressions as an example)
17:57:51 <simonator_> @pl catMaybes <$> mapM f
17:57:51 <lambdabot> catMaybes <$> mapM f
18:09:46 <ReinH> simonator_: um, fmap catMaybe (mapM f ...) ... are you sure you have the right abstraction? ;)
18:11:07 <ReinH> fread2282: Ah, roconnor's iirc... one sec
18:11:16 <simonator_> ReinH: probably not :) I'm still changing my mind a little. I have a list of things to check, all of which might provide errors through a writer and some of which might provide a part of the result.
18:13:02 <fread2282> ReinH: yep, thank you
18:15:43 <simonator_> ReinH: maybe I should just foldM and avoid the Maybes...
18:16:13 <ReinH> fread2282: sweet
18:17:38 <simonator_> oh well... I'm going to bed! night!
18:23:28 <vanila> this seems like a good programming problem: How to turn a list of strings into a tree (merging by prefixes)
18:23:46 <Schluri> i wonder
18:23:47 <Schluri> @pl stretch(p:ps) = doppelt :doppelt : stretch ps where doppelt = concat [[a]++[a] |a<-p]
18:23:47 <lambdabot> (line 1, column 62):
18:23:47 <lambdabot> unexpected " "
18:23:47 <lambdabot> expecting operator
18:25:11 <Schluri> :pl stretch(p:ps) = concat [[a]++[a] |a<-p] :concat [[a]++[a] |a<-p] : stretch ps
18:25:17 <Schluri> @pl stretch(p:ps) = concat [[a]++[a] |a<-p] :concat [[a]++[a] |a<-p] : stretch ps
18:25:18 <lambdabot> stretch = fix ((`ap` tail) . (. head) . ap ((.) . (:) . join . return . (a :) . (([a] | a) <-)) . flip ((.) . (:) . join . return . (a :) . (([a] | a) <-)))
18:34:27 <SvenskFisk> Can anyone give me a snippet of code that shows how to get a random element from a list? I've been trying with Data.Random.Extras(choice) for the last half hour and I can't decipher the cryptic complaints about type that the compiler throws at me
18:37:03 <vanila> let randomFromList l = do i <- randomRIO (0, length l - 1) ; return (l !! i) in  randomFromList "foobar"
18:37:06 <vanila> I think that might work
18:45:17 <SvenskFisk> vanila: There's no way to avoid the IO thing right?
18:46:37 * hackagebot yi 0.11.1 - The Haskell-Scriptable Editor  http://hackage.haskell.org/package/yi-0.11.1 (MateuszKowalczyk)
18:47:05 <yukko> SvenskFisk randomR is pure
18:47:27 <yukko> but getting a StdGen requires IO
18:49:08 <SvenskFisk> yukko: Could you explain that a bit more if it's not too much trouble?
18:51:48 <yukko> oh sure! in System.Random there are a few functions to generate random numbers, some of these functions are actually pure because they just take a seed value, use it to get a "random" number, and return a new seed
18:53:02 <yukko> you don't actually strictly need IO for any of this, because you can create a seed from an integer via mkStdGen
18:53:03 <nshepperd> you can just do (mkStdGen 4) if you don't mind your "random" numbers being the same every time you run the program
18:57:13 <SvenskFisk> Oh okay, that helps, thanks yukko and nshepperd!
19:01:38 * hackagebot HFuse 0.2.4.4 - HFuse is a binding for the Linux FUSE library.  http://hackage.haskell.org/package/HFuse-0.2.4.4 (M15K)
19:06:36 <TTimo> can anyone help me with installing packages with cabal
19:06:49 <TTimo> https://gist.github.com/TTimo/31530fdb4302d6034fa1
19:07:04 <TTimo> I'm not sure what my options are when faced with this
19:07:19 <Welkin> haha
19:07:24 <Welkin> the dependency is hell?
19:07:34 <Welkin> wpuld that be "haskell shell"?
19:07:36 <TTimo> I'm trying to install hell, interestingly :)
19:07:37 <Welkin> would*
19:07:41 <TTimo> yes
19:07:48 <Welkin> there is such a thing as "Cabal hell"
19:07:49 <Welkin> you know
19:07:56 <yukko> literal dependency hell
19:08:00 <TTimo> that's what I'm finding out
19:08:15 <Welkin> just install it in a sandbox
19:08:21 <Welkin> all should be fine
19:08:27 <Welkin> install all your packages in sandboxes
19:08:35 <int-e> it won't, th unix package comes with ghc, and it's too old.
19:08:37 <Welkin> cabal sandbox init
19:08:38 <TTimo> so waht does that mean
19:09:17 <int-e> TTimo: you're in ghc 7.6.x, right? That's getting quite dated; a lot of packages rely on ghc 7.8.x now.
19:09:20 <Welkin> are you using cabal 1.18 or later?
19:09:33 <TTimo> debian sid
19:09:35 <TTimo> up to date
19:09:37 <Welkin> you could just download haskell platform 2014
19:09:43 <Welkin> it is mostly up to date
19:09:55 <Welkin> don't use your package manager
19:09:58 <TTimo> haskell-platform in apt is 2013 something
19:10:11 <Welkin> https://www.haskell.org/platform/
19:10:39 <goglosh> 3/part
19:10:43 <goglosh> sorry
19:10:43 <int-e> https://packages.debian.org/sid/ghc ... yes, still 7.6.3.
19:10:51 <TTimo> ok .. has debian become a minor / unknown distribution to the point that things like haskell are no longer kept up to date in the distro packaging system?
19:10:54 <TTimo> that's pretty sad
19:11:04 <Welkin> TTimo: they are just slow to update
19:11:21 <Welkin> they focus on stability over new features
19:11:38 * hackagebot hoauth2 0.4.3 - hoauth2  http://hackage.haskell.org/package/hoauth2-0.4.3 (HaishengWu)
19:11:45 <int-e> https://packages.debian.org/experimental/ghc is a 7.8 (strange version though) - I guess they're still fighting compatibility issues.
19:11:55 <jayleo> is there some new drama over ‘lack of inclusiveness’ in Haskell or something?
19:12:59 <sebastiankg> Is there some kind of problem with the "pandoc" package? My installation of the sourcegraph package is getting stopped in its tracks because pandoc won't install
19:16:30 <int-e> oh. since jessie has just been frozen that means that ghc 7.6.3 will continue to hunt us for some time ... sigh.
19:16:43 <int-e> *haunt
19:18:10 <Welkin> you can always compile platform from source
19:18:13 <jayleo> you guys are not including me by answer my question
19:18:23 <Welkin> jayleo: your question doesn't make sense
19:18:27 <Clint> int-e: yup, 7.8 still broken on arm*
19:18:40 <int-e> Clint: I see.
19:18:55 <jayleo> is there some new drama over ‘lack of inclusiveness’ in the Haskell community or something? [sorry, I use shorthand sometimes]
19:19:09 <Welkin> that doesn't make sense
19:19:15 <jayleo> and by new, I mean recent
19:19:24 <Welkin> what do you mean by "drama" and "lack of inclusiveness"?
19:19:46 <jayleo> dictionary would suffice for those. i mean the standard definitions
19:19:48 <Welkin> haskell is the most welcoming community I have ever come across online
19:19:51 <int-e> Welkin: Yes, of course. I usually do that (not even the platform, just ghc and cabal-install)
19:19:58 <Welkin> there is no lack of inclusiveness
19:20:49 <jayleo> ok, i thought so as well. but i saw something in my twitter feed that seemed to indicate that there is some problem
19:22:07 <vanila> jayleo, we could do better! so let's
19:24:30 <mikimoto_> how to use minBound to get the min value of Int and Integer, under ghci command line?
19:24:59 <Welkin> > (minBound :: Int)
19:25:00 <lambdabot>  -9223372036854775808
19:25:06 <Welkin> > minBound :: Integer
19:25:07 <lambdabot>  No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
19:25:07 <lambdabot>    arising from a use of ‘GHC.Enum.minBound’
19:25:18 <Welkin> of course, there is no min for Integer
19:25:28 <mikimoto_> OK, thanks
19:33:51 <TTimo> alright so I downloaded haskell-platform, trashed the old distro packages, got cabal to install hell correctly
19:34:14 <TTimo> now if I try to install xmonad
19:34:29 <TTimo> https://gist.github.com/TTimo/7edb5e7838108612a724
19:35:15 <TTimo> I guess that's why someone was recommending using sandbox?
19:36:01 <TTimo> the workflow is .. pretty much one sandbox per piece of software I want?
19:36:31 <MP2E> basically yeah, or a group of packages that can coexist
19:36:40 <MP2E> in this case you might be able to force-rebuild and then reinstall network-2.5.0.0
19:36:42 <Tekmo> So there are basically two ways to use software in Haskell
19:36:43 <MP2E> or whatever depends on it
19:36:54 <Tekmo> If you are installing applications, like xmonad, you absolutely want to use sandboxes
19:37:11 <Tekmo> If you are doing library development, you can probably get away with using a shared package database
19:37:29 <Tekmo> Generally, applications are much less responsible about their dependencies than libraries.  That's why
19:37:34 <dfeuer> Tekmo is here? That's rather unusual and exciting.
19:37:52 <Tekmo> Hi! :)
19:38:49 <dfeuer> The challenge, of course, is that one can easily run out of room on one's SSD, or run out of time for compiling things.
19:39:11 <dfeuer> So sandboxes rule, and sandboxes suck.
19:39:51 <Tekmo> Also, applications are much more likely to depend on lens, which takes forever to install -.-
19:40:04 <Tekmo> I don't know why people don't use `lens-family-core` or `lens-family`
19:40:17 <HeladoDeBrownie> In my case, the answer would be lack of knowledge
19:40:42 <Tekmo> Maybe I should just write a blog post that's like "Hey, `lens-family` exists <end of post>"
19:40:43 <edwardk> because folks use indexed traversals, indexed lenses, the nice classes for overloading at, etc. zoom for things where the state isn't the outermost thing, getters/setters, etc.
19:40:50 <Welkin> dfeuer: compiling sure takes a while with a lot of haskell packages
19:41:08 <edwardk> i don't use lens-family because i wrote lens to get the hell away from it
19:41:23 <dfeuer> And why on Earth does the time package do its day calculations with Integers? Shouldn't it use Int64?
19:41:39 <jle`> it's future-proof
19:41:41 <jle`> :)
19:42:08 <jle`> don't need a y2billiontrillion problem in the future
19:42:40 <dfeuer> jle`, beyond proton decay/the big rip/the big freeze/.... we really don't need time.
19:42:46 <HeladoDeBrownie> Well, why *would* you use Int64? Just because it's faster? Is Integer demonstrably too slow?
19:42:47 <Cale> I tend to think of prematurely using limited range Int types as inviting bugs to happen
19:42:49 <bananagram> it doesn't need them on Earth necessarily
19:42:52 <dfeuer> Certainly we don't need *days*
19:43:04 <dfeuer> The day will not be meaningful then at all.
19:43:23 <dfeuer> Cale, but it does some manipulations with them and then converts to Int!
19:43:47 <dfeuer> Oh wait, let me make sure I read that right.
19:43:47 <edwardk> Tekmo: my experience is folks like bos come into the lens channel and ask 'how can i do this' and we give them the one line lens answer and the 8 line lens-family answer and eventually folks give up on using the 'simpler' solution =P
19:44:04 <dfeuer> No, sorry, read that wrong.
19:44:09 <Cale> Well, I don't know the details of the computations you're talking about
19:44:19 <Tekmo> edwardk: Relax, it's not a competition.  `lens` and `lens-family` can peacefully coexist
19:44:33 <jle`> actaully it's a competition.
19:44:34 * jle` gets popcorn
19:44:36 <Tekmo> Haha
19:44:37 <Cale> But Integer is relatively safe, and if I don't *need* to use something smaller, I generally will stick with it
19:45:02 <dfeuer> Cale, what kinds of bugs? If I ask it for the day of the week sometime before the Earth existed, or after the Sun destroys it, I'm going to get a wrong answer anyway.
19:45:10 <jmcarthur> no single Int can take up all my memory though ;)
19:45:11 <edwardk> Tekmo: i mostly just wanted to point out that for the most part it isn't just 'people being lazy'
19:45:40 <dfeuer> What's the relationship between lens and lens-family?
19:45:49 <Cale> I don't know how it might come up in the context of the time library, but for instance, perhaps some intermediate computation will use picoseconds, and then larger numbers of days will result in overflow
19:45:49 <edwardk> dfeuer: none
19:45:58 <edwardk> dfeuer: : they work together by design but neither depends on the other
19:46:07 <Tekmo> dfeuer: They are compatible with each other, but neither incurs a dependency on the other
19:46:27 <jmcarthur> just like Tekmo and edwardk
19:46:31 <dfeuer> So they use all/none of the same names?
19:46:35 <Cale> dfeuer: Integer uses machine integers internally when the numbers being represented are small enough
19:46:41 <Tekmo> dfeuer: lens-family is basically lens with a much smaller set of dependencies and smaller feature set
19:46:45 <edwardk> nah, i think tekmo has at least one edwardk dependency somewhere ;)
19:46:51 <jle`> thas cause actual lenses and optics stuff don't actually need new data types to work, they are just type synonyms for normal things
19:46:56 <Cale> dfeuer: So you pay a little bit for a few conditionals here and there, but the performance hit is usually pretty minor
19:47:09 <Tekmo> My applications have like a million edwardk dependencies
19:47:15 <Tekmo> I'm only anal about dependencies for libraries
19:47:23 <jle`> so a library who wants to allow people to use optics can just provide the optics/lenses in terms of normal things
19:47:30 <jle`> and lens/lens-family gives you tools for working with them
19:47:34 <jle`> ....i think that's how it works
19:47:45 <edwardk> jle`: for the most part
19:48:01 <Tekmo> Also, I'm glad bifunctors is finally in base
19:48:05 <Tekmo> I hope contravariant will follow soon
19:48:06 <Welkin> it's the kid-friendly version of lens
19:48:09 <Welkin> for the whole family
19:48:29 <edwardk> Welkin: there is a certain irony that i started lens because i found lens-family's API eye-bleedingly bad ;)
19:48:51 <Tekmo> I don't mind the API at all
19:49:24 <edwardk> importing a module Lens.Family2? having that re-export synonyms that are defined in terms of misleadingly similar identically named synonyms that happen to be 98 from a second package?
19:49:50 <edwardk> those are the things that caused me to just drop lens-family and write my lens library inline in my physics package... which i then split out when folks asked
19:49:56 <Tekmo> Those never bothered me
19:50:17 <Tekmo> I put up with much bigger warts built into base and the Prelude.  That's minor by comparison
19:52:00 <Tekmo> One of those warts being the LACK OF A STANDARD VOID TYPE
19:52:01 <Tekmo> :)
19:54:35 <edwardk> i think shachaf at one point wanted to propose or did propose moving Data.Void into base
19:55:04 <gravity_well> If I have data types like so http://pastebin.com/BVSXb1NU then how do I make a function that constructs data of type car? (returns car)
19:55:07 <gravity_well> I can't figure it out
19:55:41 <Tekmo> gravity_well: For future reference, use `lpaste.net`, which doesn't have ads
19:55:47 <gravity_well> thanks
19:56:00 <pharaun> what the heck is a void type?
19:56:11 <gravity_well> hm?
19:56:16 <Tekmo> pharaun: An unhabited type (impossible to create)
19:56:20 <pharaun> ahh
19:56:22 <edwardk> but when folks take one of my packages and pull it into base, you get a ton of bikeshedding discussions that lead to it just randomly losing functionality, so I confess I'm not in a huge hurry to deal with it
19:56:23 <Tekmo> pharaun: data Void -- Nothing on the right-hand side
19:57:01 <pharaun> edwardk: bikeshed like the one with the tranversal stuff?
19:57:05 <pharaun> traversal sorry
19:57:30 <edwardk> well foldable/traversable has been pretty straightforward. that isn't anything of mine its already well understood, etc.
19:57:44 <Tekmo> gravity_well: Do you have `Door`, `Wheel`, `Handle`, and `Window` types, too?
19:57:54 <Tekmo> gravity_well: You would write something like: Car [Wheel ???]
19:57:55 <dfeuer> edwardk, this Alternative/MonadPlus situation is really horribly horrible. I know you can't fix it today, but how about Monday?
19:58:06 <Tekmo> gravity_well: ... where the ??? depends on how the `Wheel` type is defined
19:58:09 <gravity_well> Tekmo: Yes I do
19:58:16 <dfeuer> edwardk, yes, but it's a terribly leaky abstraction :-(
19:58:25 <edwardk> but even just moving bifunctors is tricky, because you get things like how bimap on (,) uses a lazy pattern match, which is what arrow's (***) does, but fmap is strict, but if you go strict then you lose a bunch of knot tying tricks folks use the arrow combinators for
19:59:17 <tolt> Is there an irc channel for cabal?
19:59:32 <pharaun> edwardk: ah i see
19:59:39 <dfeuer> tolt, yes, but barely.
19:59:53 <vanila> @src groupBy
19:59:53 <lambdabot> groupBy _  []     =  []
19:59:53 <lambdabot> groupBy eq (x:xs) =  (x:ys) : groupBy eq zs
19:59:53 <lambdabot>     where (ys,zs) = span (eq x) xs
20:00:19 <edwardk> dfeuer: my point is mostly that what you are asking for is absolutely ginormous and underspecified and addresses a source of relatively few pains by creating far more.
20:00:39 <edwardk> Folks get an alarming amount of work done with MonadPlus despite its general detachment from sanity
20:00:44 <TTimo> so those problems I am having with installing packages .. that's because multiple versions of the same packages can't cohabit at different versions ?
20:00:57 <Tekmo> edwardk: What's wrong with `MonadPlus`?
20:01:09 <Tekmo> TTimo: That's right
20:01:34 <edwardk> Tekmo: dfeuer recently discovered the old MonadPlus-reform-proposal in light of the fact that he wanted to nail down the laws for Alternative
20:01:35 <dfeuer> edwardk, I understand that people use it a lot, but it deosn't *mean* anything. Whenever someone sticks a "MonadPlus =>" or "Alternative" context on a function, they're almost certainly *lying*.
20:02:06 <edwardk> dfeuer: not as much as you'd think. i personally check my reasoning under both sets of laws to see that it does what i want it to do and use it anyways
20:02:06 <dfeuer> Because they don't really mean MonadPlus or Alternative; they mean Parser or something.
20:02:14 <Tekmo> edwardk: Aren't the `Alternative` laws just the monoid laws?  I don't understand why we insist on this extra `some`/`many` business
20:02:24 <edwardk> almost always i'm borrowing the semantics of the underlying monad in the monad transformer stacks
20:02:36 <edwardk> some/many _have_ to exist or Parsec is dead
20:02:50 <Tekmo> edwardk: I don't follow
20:02:53 <dfeuer> The Alternative laws are the Monoid laws, yes. Which is why it is so very strange for Applicative f => Alternative f.
20:03:10 <Tekmo> dfeuer: Yeah, I don't understand why we use that super-class either
20:03:20 <Tekmo> dfeuer: It seems like Alternative should just be a higher-kinded `Monoid` class
20:03:39 <dfeuer> Well that's what I said, and edwardk started yelling at me.
20:03:40 <edwardk> parsec is CPS'd since 3.1 or so. if you used the direct definition for some/many and not allow it to overload on the class it'd fail to terminate.
20:04:09 <Tekmo> edwardk: I don't mind having `some`/`many` being part of the class
20:04:36 <Tekmo> edwardk: I'm just saying there shouldn't be any additional laws about how they should behave
20:04:40 <edwardk> Alternative isn't just "a monoid" it is a monoid with "vague nebulous laws" tying it to Applicative.
20:05:15 <edwardk> one set of folks would like it to have a left catch law, others would like it to have a right distributive law, but its also not even a monoid
20:05:18 <dfeuer> Which means that the laws aren't determined by the class at all, but by the module or something.
20:05:33 <edwardk> er rather
20:05:40 <edwardk> its not cancellative w.r.t the applicative
20:06:09 <dfeuer> Cancellative probably isn't what you mean either, I'm guessing.
20:06:15 <dfeuer> But I'm not sure.
20:06:16 <Tekmo> This is why I like the bog-standard laws like the monoid laws.  Everybody agrees on them.  All of these library-specific laws just muddy the waters
20:06:17 <edwardk> dfeuer: and yet we can write whole piles of monad transformers that can lift over this abstraction and delegate to whatever underlying set of laws you want to apply
20:06:44 <vanila> i don't get why prelude even exists when you can just import it
20:07:05 <Tekmo> vanila: I suppose mainly for consistency with other languages
20:07:34 <dfeuer> vanila, because of lists, and list comprehensions, and numeric literals, at least.
20:07:40 <Tekmo> vanila: Some languages can't even disable the prelude, like Scala
20:07:49 <edwardk> ok, i'm out. later
20:07:50 <dfeuer> But yes, the prelude is probably a lot bigger than it should be.
20:07:55 <dfeuer> Bye edwardk.
20:08:08 <dfeuer> FOOM.
20:08:27 <dfeuer> I guess I scared him off with my insanity.
20:08:52 <dfeuer> And here is Insanity133, right on cue.
20:09:39 <Insanity133> Haha
20:09:48 <dfeuer> <dfeuer> I guess I scared him off with my insanity.
20:09:49 <dfeuer> * Insanity133 (~Insanity1@219-89-4-131.dialup.xtra.co.nz) has joined #haskell
20:14:00 <SashaGrey> so how do monads work?
20:14:20 <dfeuer> Tekmo, let me know when you've figured out how to fix the Alternative/MonadPlus thing so everyone's satisfied :)
20:14:33 <dfeuer> SashaGrey, monads don't work; they're mathematical abstractions.
20:14:39 <Welkin> monads, how do they work?
20:14:44 <Welkin> just like magnets, or rainbows
20:14:57 <MP2E> and icp songs
20:14:58 <Tekmo> dfeuer: Pretty much just ignore Edward
20:15:03 <dfeuer> monads >>= how do they >>= return work
20:15:06 <Tekmo> dfeuer: He's the only one that objects to the obvious solution
20:15:15 <vanila> SashaGrey, you can think of it like an API you program to
20:15:27 * BMeph warns everyone not to touch his bottle of Faygo! ;)
20:15:35 <dfeuer> Tekmo, he may be a bit cantankerous at times, but I don't think it's very helpful to ignore him.
20:16:19 <dfeuer> SashaGrey, it's a very ... limited API. To weak for most things, but then Haskellers are an odd bunch, so it's too strong for some.
20:16:24 <Tekmo> dfeuer: He gets too hung up on library-specific idiosyncracies
20:16:58 <dfeuer> Tekmo, what's the obvious solution, in your opinion?
20:17:07 <MP2E> his point was that Alternative/MonadPlus isn't a pinned down concept, it's used in different ways and different people have different expectations as to what laws it should follow
20:17:17 <Tekmo> Once `Applicative` is a superclass of `Monad`, make `Alternative` a super-class of `MonadPlus`.
20:17:40 * edwardk is back.
20:17:45 <edwardk> Tekmo: that much is done
20:17:46 <MP2E> at least I think that was the point!
20:17:48 <edwardk> that isn't the problem
20:17:54 <Tekmo> edwardk: Then what are you referring to?
20:18:28 <edwardk> dfeuer was talking about the fact that MonadPlus _itself_ is actually multiple sets of laws under one umbrella.
20:18:33 <Tekmo> Oh
20:18:39 <dfeuer> The problem is that <|> and empty don't actually *mean* anything in general; their meaning is entirely contextual, as are the laws to go with them.
20:18:41 <edwardk> which is what the old MonadPlus reform proposal was about
20:18:43 <edwardk> but even that lies
20:18:54 <edwardk> because both of its proposed sets of laws aren't actually satisfied by almost anything
20:18:58 <dfeuer> Which law is "wrong" there, edwardk?
20:19:11 <edwardk> the mplus a mzero law for anything with effects
20:19:27 <edwardk> er
20:19:28 <edwardk> sorry
20:19:29 <dfeuer> The wat?
20:19:57 <Tekmo> edwardk: The distributivity laws are satisfied by pretty much every effectful container (i.e. `ListT`, `MaybeT` and everything similar)
20:20:13 <SashaGrey> so how often are monads used?
20:20:20 <Tekmo> edwardk: By those I mean: mzero >>= f = mzero, (m `mplus n) >>= f = (m >>= f) `mplus` (n >>= f)
20:20:23 <dfeuer> SashaGrey, every day!
20:21:08 <MP2E> In Haskell, you will be hard pressed to find a program that doesn't use any monads at all :)
20:21:16 <edwardk> dfeuer: i meant the one you proposed earlier. m <*> empty = empty  but got tripped up in haste
20:21:20 <Tekmo> edwardk: There is also a practical benefit of picking the distributivity laws: they allow you to write effectful streaming code with only a dependency on `base`
20:21:37 <Tekmo> edwardk: That's a pretty compelling argument for making them the standard `MonadPlus` laws
20:21:50 <edwardk> Tekmo: and yet Maybe exists.
20:22:15 <edwardk> and folks _use_ the fact that both are MonadPlus when they define an overloaded list-of-successes style parser
20:22:30 <HeladoDeBrownie> SashaGrey, it really depends on what you mean. How often do you use a particular instance of Monad? Pretty often, considering it's a very convenient way to compose IO procedures together. How often do you program to the general interface? Usually only if you're doing particularly abstract things, mostly libraries rather than applications.
20:22:37 <edwardk> so that baby gets thrown out with the bathwater
20:22:40 <dfeuer> edwardk, yeah, that one works for some things, but not others. I think empty <*> m = empty is probably more often true.
20:23:08 <Tekmo> edwardk: What about `Maybe`?  It satisfies the laws I just mentioned
20:23:11 <edwardk> dfeuer: that one runs afoul of Backwards
20:23:12 <SashaGrey> any resources for getting a better understanding of monads(preferrably with practical example)? just finished that chapter in lyah and watched some youtube vids, but I still don't understand them enough to use without references
20:23:24 <HeladoDeBrownie> SashaGrey, do you know what Functor is?
20:23:26 <dfeuer> Distributivity for Applicative looks like (a <|> b) <*> c = (a <|> c) <*> (b <|> c), or maybe sometimes the other way around.
20:23:36 <edwardk> mplus (Just a) Nothing = Just a;   mplus Nothing (Just a) = Just a;   mplus _ _ = Nothing -- would satisfy those laws
20:23:46 <Tekmo> SashaGrey: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
20:24:17 <dfeuer> edwardk, what's Backwards do? Some kind of flipping of <*>?
20:24:30 <edwardk> dfeuer: yeah flips <*> its like 'Dual' for monoid
20:24:32 <gravity_well> Tekmo: I can't get it to work :/ http://lpaste.net/113877
20:24:47 <dfeuer> edwardk, and that actually makes a valid Applicative?
20:24:54 <edwardk> > dfeuer: yes
20:24:56 <lambdabot>  Not in scope: ‘dfeuer’Not in scope: ‘yes’
20:24:58 <dfeuer> o.O
20:25:04 <SashaGrey> HeladoDeBrownie: yes
20:25:06 <dfeuer> HURRAY! I'm not in scope!
20:25:28 <HeladoDeBrownie> SashaGrey, what about Applicative?
20:26:00 <edwardk> > let ghc x = x; dfeuer = fix ghc in dfeuer
20:26:04 <lambdabot>  mueval-core: Time limit exceeded
20:26:16 <edwardk> i think lambdabot just told us you are going to spin forever trying to fix ghc
20:26:18 <dfeuer> :-)
20:26:34 <HeladoDeBrownie> edwardk, I don't get what's so hard about fixing these errors
20:26:36 <HeladoDeBrownie> > fix error
20:26:36 <dfeuer> Yes, edwardk, I know you have that Ermine thing going.
20:26:37 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
20:26:42 <Tekmo> gravity_well: Your `harsh` function only accepts a single `Part`, but you are passing a list of `Part`s, which has type `[Part]`
20:26:56 <pharpend> I must be missing something here - https://github.com/pharpend/mittens/blob/journals/lib/Mittens/Mtn/Journal.hs
20:27:36 <Tekmo> gravity_well: `[Wheel Round]` means a one-element list whose single element is `Wheel Round`
20:27:53 <pharpend> I'm getting this error - http://lpaste.net/113878
20:28:00 <Tekmo> gravity_well: Replace the brackets with parentheses and it will still work
20:28:02 <gravity_well> Tekmo: Thanks
20:28:02 <gravity_well> yeah
20:28:03 <dfeuer> SashaGrey, from a Haskell perspective, monadic "actions" are thingums you can manufacture with "return" and hook up to functions with >>=
20:28:05 <Tekmo> gravity_well: harsh (Wheel Round)
20:28:07 <pharpend> the type of entry is Journal
20:28:27 <Guest32666> Well I'm also a beginner in Haskell but https://www.haskell.org/haskellwiki/Typeclassopedia this looks a good resource for understanding of monads
20:29:23 <pharpend> oh geez
20:29:27 * pharpend facedesks
20:29:29 <dfeuer> If you have a thingum, m, and you take a function, f, you can make a new thingum, m >>= f
20:29:31 <pharpend> i forgot how monads work
20:29:53 <dfeuer> If you have a value, x, you can make a thingum, return x.
20:30:06 <Guest32666> As I understand, monad is just a way to manipulate data inside containers
20:30:17 <dfeuer> Not exactly.
20:30:34 <assia_t> Hey guys, I'm developing a library that'll have to use channels as the primary means of sending messages across threads and I was wondering which general approach made more sense: Using multiple channels, one for each event producing child thread VS. Using a single channel, which is passed around and tagged with the child's ID.
20:30:39 <dfeuer> Although it can be that sort of.
20:31:15 <Tekmo> assia_t: So I generally don't recommend this architectural style, but if I had to pick one I would have separate channels
20:32:01 <Tekmo> Guest32666: If you define container to be `Functor`, then yes
20:32:28 <Guest32666> in haskell IO is implemented by monad so all monads look having side effects but It was not that
20:32:41 <Guest32666> After looking several monads Only IO monads were impure
20:32:42 <HeladoDeBrownie> Guest32666, that's wrong
20:32:51 <assia_t> Tekmo: What architectural style would you recommend? I'm writing a bittorrent client...
20:33:03 <HeladoDeBrownie> Guest32666, Monad is simply a way to *compose* IO procedures together, among other things. It has nothing to do with how it's implemented
20:33:04 <Tekmo> Some people use container in the type sense (i.e. a type that contains another type), not in the collections sense
20:33:09 <Tekmo> I think that's what Guest32666 is getting at
20:33:17 <emmanueloga> hi. Anybody knows why reads returns an empty list on read failures instead of Nothing (Maybe)?
20:33:58 <HeladoDeBrownie> emmanueloga, because it could potentially return multiple parses, so Maybe was not an appropriate datatype choice
20:34:22 <Tekmo> assia_t: Don't pass around channels.  Instead pass around STM transactions that read from those channels
20:34:23 <HeladoDeBrownie> A string could either not parse, have a unique parse, or be ambiguous, i.e., have multiple parses
20:34:38 <HeladoDeBrownie> You can represent that by lists of length 0, 1, and greater than 1 respectively
20:34:46 <dfeuer> emmanueloga, yes, because reads is stupid.
20:35:03 <int-e> Right, the (misguided, imho) idea is that to support backtracking.
20:35:09 <Tekmo> assia_t: STM transactions have nice algebraic properties (you can combine them together in nifty ways).  Channels are not easily "combinable"
20:35:13 <yukko> Guest32666 there are other monads that aren't pure but they use compiler-provided primitives to do so, you can't have impure code without them
20:35:13 <dfeuer> Oh, it actually supports that?
20:35:24 <dfeuer> I thought reads was just stupid.
20:35:32 <HeladoDeBrownie> emmanueloga, in practice, you may want readMaybe
20:35:53 <dfeuer> HeladoDeBrownie, what types support that sort of ambiguous parsing with reads?
20:36:09 <int-e> dfeuer: I'm not aware of any instance where that backtracking is actually used.
20:36:18 <emmanueloga> HeladoDeBrownie: ah, readMaybe sounds nice. Any example of that multiple parses case? Can't figure out how reads could return a list of length > 1.
20:36:21 <HeladoDeBrownie> dfeuer, no idea! I've never ever seen it happen
20:36:26 <HeladoDeBrownie> emmanueloga, ^
20:36:32 <emmanueloga> :)
20:36:48 <HeladoDeBrownie> emmanueloga, in short, I agree with dfeuer to a degree, it's silly
20:36:57 <Tekmo> assia_t: If you're new to STM, I recommend this tutorial series: https://www.fpcomplete.com/school/advanced-haskell/beautiful-concurrency
20:37:10 <int-e> > read "((()))" :: () -- some sort of backtracking is happening, but Maybe should be enough.
20:37:11 <lambdabot>  ()
20:37:56 <dfeuer> int-e, how is it reading that successfully?
20:38:04 <assia_t> Tekmo: I've read the Parallel and concurrent book, but didn't read that series; I'll take a look
20:38:27 <int-e> > read "(1)" :: Int
20:38:28 <lambdabot>  1
20:38:29 <assia_t> I was about to ask you for resources or examples; because I don't think I got what you meant...
20:39:00 <edwardk> dfeuer: anyways i totally support folks going off and writing a library for something like MonadPlus/MonadOr factoring and trying to get others to adopt it. If it can get any traction there it becomes a much more viable candidate. Otherwise it strikes me more like a 'hey i wish haskell had ml syntax, why can't haskell always be strict?' in terms of how
20:39:00 <edwardk> productive conversations go. i definitely didn't mean to come across as yelling at you though. i apologize if that was the tone i conveyed.
20:39:16 <Tekmo> assia_t: This is a more general discussion of what I have in mind: http://www.haskellforall.com/2014/04/scalable-program-architectures.html
20:39:23 <int-e> dfeuer: "read" supports parsing parentheses (mainly for more complicated data types, I think, but it works for the base types as well)
20:39:28 <dfeuer> edwardk, that sounds reasonable.
20:39:30 <Tekmo> assia_t: You want your central abstractions to be things that are "combinable"
20:39:37 <Tekmo> assia_t: STM transactions are combinable, but channels are not
20:39:46 <dfeuer> int-e, oh, I see.
20:40:02 <assia_t> Tekmo: Wow; Thanks for that link!
20:40:03 <Tekmo> assia_t: In the case of STM specifically, you have `retry` and `orElse`, and they behave like a `Monoid`
20:40:08 <Tekmo> assia_t: Your'e welcome!
20:40:15 <Tekmo> assia_t: For example: retry `orElse` m = m
20:40:20 <Tekmo> assia_t: m `orElse` retry = m
20:40:28 <int-e> > read " ( 1 ) " :: Int -- whitespace, too
20:40:30 <lambdabot>  1
20:40:35 <Tekmo> assia_t: (m1 `orElse` m2) `orElse` m3 = m1 `orElse` (m2 `orElse m3)
20:40:57 <Tekmo> assia_t: Also `STM` forms a `Monad`, so you also get the `Monad` laws for free, too:
20:41:01 <dfeuer> edwardk, you can see, though, that it's annoying that <|> is basically like "that operation we like to talk about", where the operation depends on who's talking :P
20:41:02 <Tekmo> assia_t: f >=> return = f
20:41:06 <Tekmo> assia_t: return >=> f = f
20:41:13 <Javran> How to ignore HLint suggestions if OverloadedStrings are used?
20:41:14 <Tekmo> assia_t: (f >=> g) >=> h = f >=> (g >=> h)
20:41:24 <Tekmo> assia_t: Notice how similar those laws are to the `Monoid` laws
20:41:59 <dfeuer> Them is category laws though, isn't they?
20:42:02 <Tekmo> When you stick to combinable abstractions, you simplify your program architecture and you begin to discover even more higher-order patterns as you go
20:42:05 <Tekmo> Yes
20:42:43 <codeonwort> I know only few basic monads like IO, State, Read, Write, Cont (which appear at many beginner tutorials). After reading some parts of real world haskell, my conclusion was that data manipulation in haskell world is pure, but when it's needed to interact with environments like networks, databses, gui, the way is implemented via moand
20:43:13 <int-e> dfeuer: the downside is that 'read' is abysmally slow. this is not just due to backtracking; there is actually a tokenizer followed by a parsing pass, leading to behaviour that really doesn't make sense
20:43:28 <HeladoDeBrownie> codeonwort, "real-world stuff" is orthogonal to Monad. Monad is a way to compose things. The real-world stuff is handled by the interpreter of a type, usually IO () or similar.
20:43:36 <int-e> > read ("\""++reapeat ' ') :: Int -- surely an Int can never start with a quote?
20:43:37 <Tekmo> codeonwort: The free monad takes this idea to the extreme: http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
20:43:38 <lambdabot>  Not in scope: ‘reapeat’
20:43:38 <lambdabot>  Perhaps you meant one of these:
20:43:38 <lambdabot>    ‘repeat’ (imported from Data.List),
20:43:38 <lambdabot>    ‘BSLC.repeat’ (imported from Data.ByteString.Lazy.Char8),
20:43:38 <lambdabot>    ‘BSL.repeat’ (imported from Data.ByteString.Lazy)
20:43:49 <int-e> > read ("\""++repeat ' ') :: Int
20:43:53 <lambdabot>  mueval-core: Time limit exceeded
20:43:56 <Tekmo> codeonwort: You can think of a free monad as a computation which generates a syntax tree describing how you wish to interact with the outside world
20:44:18 <assia_t> Tekmo: I'll read-up the links you just sent me; but I don't get how I'd be able to return, for example, a stream of events which happen on a Peer's connection with a single STM transaction... I'm using TChan's, rather than Chans, btw
20:44:23 <Tekmo> codeonwort: It looks imperative, but the whole thing is just a pure computation that has no side effects and just generates a tree waiting to be interpreted
20:44:24 <HeladoDeBrownie> codeonwort, case in point: You can "do" real-world computations just by writing: main = putStrLn "Hello, world" -- and nowhere here do you use Monad
20:44:52 <Tekmo> assia_t: You can use `ListT STM a`
20:45:02 <Tekmo> assia_t: That's a lazy stream of events, each one guarded behind an STM transaction
20:45:08 <int-e> > (reads :: ReadS Int) "1.0" -- why not return [(1,".0")]?
20:45:09 <lambdabot>  []
20:45:11 <Tekmo> assia_t: That's using `ListT` from `pipes`, not `transformers`, though
20:45:18 <Tekmo> assia_t: The `ListT` in `transformers` is not lazy at all
20:46:30 <Tekmo> assia_t: In fact, given a read function of type `STM (Maybe a)` (where `Nothing` indicates that the stream is exhausted), you can mechanically create the corresponding `ListT` stream
20:46:42 <Tekmo> assia_t: stream :: STM (Maybe a) -> ListT STM a
20:47:22 <Tekmo> assia_t: stream m = m >>= \x -> case x of Nothing -> mzero; Just a -> return a `mplus` stream m
20:48:05 <Tekmo> Oops, that is slightly wrong
20:48:14 <Tekmo> The first part should be `lift m >>= ...`
20:51:42 * hackagebot influxdb 0.8.0 - Haskell client library for InfluxDB  http://hackage.haskell.org/package/influxdb-0.8.0 (MitsutoshiAoe)
20:53:02 <dfeuer> int-e, so read pulls a whole "token" off first before it even looks at it?
20:53:53 <int-e> dfeuer: right.
20:56:26 <dfeuer> Yuck.
20:59:32 <TTimo> so once my package has been compiled in a sandbox .. how to actually use it .. I've put the .cabal-sandbox/bin in the PATH, should that be enough?
21:00:02 <Tekmo> If the binary is in `.cabal-sandbox/bin`, then yes
21:00:02 <TTimo> xmonad for instance, moans about could not find module etc.
21:00:49 <Tekmo> Is it possible for you to use your package-manager to install `xmonad`?
21:01:18 <TTimo> yeah that was my setup before
21:01:24 <trap_exit> ./Main +RTS -xc -- can I get line #'s on functions called too?
21:01:27 <int-e> TTimo: xmonad is tricky because it uses ghc. You can try running it with  cabal exec .cabal-sandbox/bin/xmonad, but expect trouble later
21:01:29 <trap_exit> when I get an exception
21:01:36 <trap_exit> I only get line # on the line that causes the exception
21:01:48 <TTimo> but I don't really want to keep both the old outdated haskell from my distro
21:01:49 <trap_exit> I don't get line #'s for the 'outer' thunks that were opened up to compute the value
21:01:58 <TTimo> and have the haskell-platform I downloaded manually
21:02:05 <trap_exit> use xmonad with latest haskell
21:02:06 <TTimo> that's just asking for even more trouble ..
21:02:07 <trap_exit> problem solved
21:02:15 <TTimo> yes that's what I'd like to do
21:02:34 <TTimo> except .. xmonad.hs 'Could not find module 'XMonad'
21:03:31 <trap_exit> have you tried #xmonad ?
21:03:40 <trap_exit> this may be an xmonad config issue  that #xmonad poele are more fmiliar with
21:04:24 <dfeuer> @google xmonad
21:04:25 <lambdabot> http://xmonad.org/
21:04:26 <lambdabot> Title: xmonad | the tiling window manager that rocks
21:05:05 <TTimo> think I'll just go back to the distro packages and drop this whole manually installed platform thing
21:05:09 <TTimo> was a fun evening of exploration
21:06:15 <TTimo> packages that actually work, maintained by my distro, more valuable than being able to install some of the newer/more obscure stuff and breaking everything else
21:06:43 <chao-tic> What's the recommended package for doing quick-and-dirty HTTPS requests with session/cookie management in Haskell nowadays?
21:07:00 <chao-tic> http-conduit-browser seems quite capable but appears to be dead?
21:08:10 <chao-tic> wreq seems to be the one people mention but HTTPS support seems to be still in the TODO list?
21:09:06 <Tekmo> chao-tic: wreq, or `http-client-tls` (which `wreq` depends on)
21:09:17 <Tekmo> I'm pretty sure wreq supports https
21:09:30 <Tekmo> But if not, then `http-client` + `http-client-tls` definitely do
21:12:19 <zmthy> Probably when my dad woke my brother and me up in the middle of the night while visiting grandma and grandpa to make us WALK to the airport. My dad is a very unstable person, and he can lose his shit at the drop of the hat. I was 11, visiting my grandparents in Florida with my dad. He went out, got piss drunk, lost his cell phone, and decided that we were leaving. He woke us up in the middle of the night to pack our bags. Cut to the three of us walking do
21:12:25 <zmthy> wn the street with our bags while my grandparents coast next to us begging us to get in the car. We walked for a little while, then caught a cab. Once we got to the airport, I guess my dad realized he couldn't possibly pay for 3 more tickets home, so he lost it (again), threw his suitcase across the terminal, and left. Just walked out of the airport. I can still see him disappearing at the top of a hill. My brother and I got our bags, found a maintenance
21:12:31 <zmthy> guy (who saw everything but didn't give a shit), and asked where the pay phone was. I guess we were going to look up my grandparents' number or something. But then they showed up and took us home. In the morning, dad was there, acting like nothing ever happened. Worst Christmas ever.
21:12:36 <zmthy> Whoooopos
21:12:38 <vanila> zmthy, wrong channel?
21:12:39 <vanila> :)
21:12:46 <zmthy> Accidentally middle clicked on the terminal
21:12:53 <zmthy> While highlighting a reddit thread, I guess
21:13:03 <chao-tic> Tekmo: Thanks, but they are more barebone (without the niceties like session management provided by http-conduit-browser)...
21:13:23 <chao-tic> Tekmo: thanks anyway
21:14:11 <Tekmo> chao-tic: http://www.reddit.com/r/haskell/comments/2k8cr2/building_a_rest_client/clj3oub
21:14:18 <Tekmo> chao-tic: That's a really concise example that uses https
21:15:56 <chao-tic> Tekmo: Cool, wreq that is
21:16:24 <chao-tic> Tekmo: Thanks a lot~
21:17:22 <Tekmo> chao-tic: You're welcome!
21:24:01 <simonator_> Tekmo: very cool indeed.
21:27:35 <gravity_well> Tekmo: Hey what if I wanted to do this (line 19) http://lpaste.net/113879
21:27:56 <gravity_well> ignore the comment in the code lol
21:28:16 <simonator_> gravity_well: you could make a car with seven wheels and no windows...
21:28:24 <gravity_well> simonator_: so?
21:28:46 <gravity_well> simonator_: That is why they are going to the car compound xD
21:28:54 <gravity_well> impound*
21:29:17 <simonator_> gravity_well: so, I'd probably call 'Wheel' for 'Shape' since that's what the constructor names suggest they really are.
21:29:57 <gravity_well> simonator_: I'm just doing this quickly - I realize they wouldn't work as cars...
21:30:00 <simonator_> gravity_well: I might also use a record rather than a list of parts, since I'd expect a car to have a set of basic components.
21:30:06 <gravity_well> I didn't want to find actual types of wheels
21:30:08 <Tekmo> addCarStack (Car ps) p = Car (p:ps)
21:30:32 <gravity_well> simonator_: this is just practice. I have an idea in mind and I'm just tyring to get basic concepts lol
21:30:59 <simonator_> gravity_well: ok :) well, anything I have to say has more to do with basic datatype modelling rather than Haskell syntax.
21:31:01 <jle`> Tekmo: how does it feel to get that #haskell rush feeling again
21:31:20 <gravity_well> Thanks though, simonator_
21:33:11 <TTimo> so it seems ghc has it's own package system of sorts, with the ghc-pkg stuff?
21:34:05 <merijn> TTimo: ghc-pkg tracks libraries, not packages
21:34:25 <merijn> Anyone familiar with docbook (specifically GHC's documentation?)
21:36:44 * hackagebot rethinkdb 1.15.2.1 - A driver for RethinkDB 1.15  http://hackage.haskell.org/package/rethinkdb-1.15.2.1 (EtienneLaurin)
21:39:43 <simonator_> gravity_well: I was thinking something like http://lpaste.net/113880
21:40:39 <Tekmo> jle`: :)
21:46:47 <gravity_well> simonator_: Yeah I've done something like that before. It's really useful
21:50:37 <chasketch> hi
21:57:50 <adarc> hey everyone.. i'm trying to implement some permutation function from C, in haskell.. for fun/exercise (using ST/STArray etc).. My array doesn't seem to be getting 'modified' after the first modification.. anyone mind taking a very brief look at the (funky) code? Am I just using ST completely wrong? http://hastebin.com/jukeyoviru.hs
22:00:51 <adarc> is it my use of freeze/thaw
22:00:56 <adarc> heeh.. nubing it up hard right now
22:02:02 <merijn> Blah, writing documentation sucks >.>
22:02:16 <augur> self documenting code
22:02:17 <merijn> Any bored people with a passion for writing? :p
22:02:38 <merijn> augur: That argument won't fly >.>
22:02:51 <adarc> ooo.. i changed unsafeFreze to freeze
22:02:53 <adarc> and it did something
22:03:07 <adarc> there's not much documentation in GHC.Arr that's hwy im kind of shooting in the dark so far
22:03:20 <carter> freeze will do a deep copy
22:03:25 <augur> merijn: give it wings with redbull!
22:03:38 <carter> augur: theres a law suite over that language :)
22:03:44 <carter> augur: did YC say yes?
22:03:53 <augur> carter: no :(
22:03:57 <carter> augur: sorry to hear about it
22:04:11 <carter> augur: i think they want more mature biz dev angle these days
22:04:13 <adarc> so say i'm trying to achieve 'max performance' .. i'd want to use the unsafe version then right?
22:04:15 <carter> or magic tech demos
22:04:20 <carter> adarc: no
22:04:21 <carter> benchmark
22:04:22 <carter> then tune
22:04:30 <carter> adarc: criterion is magic,use it
22:04:48 <adarc> i've used it i guess i just need to figure out this GHC.Arr library tho
22:04:51 <merijn> adarc: Also, "my code behaves weird when I use functions with the name unsafe*" is never a bug :)
22:05:01 <carter> augur: ... why aren't you using the array package
22:05:02 <augur> carter: i think thats probably true, yeah. we need to build the magic demo (which we will)
22:05:03 <adarc> true hah
22:05:10 <carter> @hackage array
22:05:10 <lambdabot> http://hackage.haskell.org/package/array
22:05:12 <carter> adarc: use that
22:05:22 <stevejb> Greetings. I have a quick cabal question. I am working in a cabal sandbox, and trying to put monadrandom >= 0.3 in the build depends. When I do "cabal install monadrandom", "All the requested packages are already installed: MonadRandom-0.3". Howerver, cabal build does not seem to find it.
22:05:23 <carter> adarc: or better yet
22:05:24 <carter> use vector
22:05:32 <augur> carter: also i think we might look to get angels first
22:05:33 <adarc> i can't.. i'm using the native libraries
22:05:37 <adarc> i'm doing this for a code challenge
22:05:42 <adarc> ;d
22:05:52 <carter> augur: array comes with ghc
22:05:55 <augur> carter: or even go accelerator-less, if we can find a good angel
22:06:00 <carter> stevejb: spelling
22:06:01 <augur> carter: you and your a-tab's
22:06:06 <carter> çase sensitive
22:06:09 <carter> augur: i know
22:06:36 <carter> augur: you need to find someone who can do the biz dev / sales hustle for you
22:06:38 <carter> or no one cares
22:07:09 <carter> and also figure out domains where your better precision / semantics MATTERS
22:07:16 <stevejb> carter: double checking that
22:07:19 <adarc> unsafeIndex etc is named unsafe because it doen't check bounds etc. no mention of what it means for unsafeFreeze* vs freeze* etc
22:07:33 <augur> carter: yeah, we'll see man. were gonna do product hunt and stuff when we have the whizz-bang demo. i think if we have that demo, itll be VERY attractive
22:07:33 <adarc> so i'm not sure why 'freeze' works but unsafeFreeze doesn't
22:07:45 <carter> adarc: unsafeFreeze doesnt deep copy the array
22:07:46 <carter> freez does
22:07:54 <augur> carter: maybe -blah is better for this, too
22:08:08 <carter> adarc: i bet if you compile with -O0 the unsafeFreeze code stops being wrong
22:08:21 <stevejb> carter: does seem to be a spelling issue
22:08:27 <adarc> oo.. i'm in ghci.. havn't compiled it
22:08:34 <carter> ..... wat
22:08:40 <carter> then perf doesnt matter
22:08:50 <adarc> it does eventually.. im just testing it in ghci
22:09:02 <adarc> basically im just trying to get it to work in ghci.. is what i mean
22:09:03 <carter> share teh code or theres no bugs
22:09:09 <adarc> then ill compile/test
22:09:11 <adarc> hm?
22:09:23 <adarc> i linked it the test code
22:09:28 <adarc> if u wanted to take a quick look
22:09:44 <adarc> http://hastebin.com/jukeyoviru.hs
22:10:55 <carter> adarc: runSTArray :: (forall s . ST s [[e]]) -> [[e]]
22:10:55 <carter> runSTArray st = runST st
22:10:56 <carter> that worries
22:10:57 <carter>  me
22:11:01 <stevejb> carter: never mind it was a case senstive thing
22:11:12 <carter> lol
22:12:06 <adarc> i'm going to re-read this http://en.wikibooks.org/wiki/Haskell/Libraries/Arrays
22:12:06 <adarc> d
22:12:07 <adarc> ;d
22:26:46 * hackagebot github-post-receive 1.2.0.0 - GitHub webhooks library  http://hackage.haskell.org/package/github-post-receive-1.2.0.0 (ShoheiYasutake)
22:26:48 * hackagebot github-post-receive 1.2.0.1 - GitHub webhooks library  http://hackage.haskell.org/package/github-post-receive-1.2.0.1 (ShoheiYasutake)
22:30:14 <adarc> http://hastebin.com/ubumoyuzof.hs i've been reading up on unsafe vs safe thaw/freeze etc.. i have NO CLUE why the commented code in that url works.. but the unsafe versions don't work. anyone have an idea?
22:30:46 <adarc> it's basically the same operation except freeze/thaw should be making a copy, while unsafe freeze/thaw allow 'direct memory access', no ?
22:31:30 <adarc> with the commented code, i see my array modifications.. with the unsafe variation, the array seems to 'never get modified'.. ie, it's the same array that i start with originall
22:31:33 <adarc> y
23:06:47 * hackagebot keystore 0.6.3.1 - Managing stores of secret things  http://hackage.haskell.org/package/keystore-0.6.3.1 (ChrisDornan)
23:56:32 <Schluri> @pl (\x ->  (2*x *signum x) +1-signum x)
23:56:33 <lambdabot> ap ((-) . (1 +) . liftM2 (*) (2 *) signum) signum
23:56:53 <Schluri> @pl (\x ->  1-signum x + 2*x *signum x )
23:56:53 <lambdabot> ap ((+) . (-) 1 . signum) (liftM2 (*) (2 *) signum)
