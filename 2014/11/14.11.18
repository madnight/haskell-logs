00:07:04 <Rufflewind> shachaf jle`: I think I found another solution :)  (without altering the type of Lens)
00:07:16 <Rufflewind> I used church-encoding of tuples instead of plain tuples
00:07:50 <Rufflewind> it works because in the church-encoding the tuple retains the Functor in its signature, so I can still disambiguate explicitly as needed
00:08:21 <Rufflewind> still kind of a hack but at least I think it's more general
00:10:22 * hackagebot wai-routing 0.11.1 - Declarative routing for WAI.  http://hackage.haskell.org/package/wai-routing-0.11.1 (ToralfWittner)
00:10:48 <jle`> oh neat
00:12:48 <Gatis> is haskell better than C#?
00:13:06 <simpson> Gatis: In what way?
00:13:08 <jle`> better at some things, worse at others
00:13:46 <Gatis> simpson, i don't know
00:13:50 <Gatis> I know c#
00:14:05 <simpson> Gatis: Then perhaps it's a question you'll have to answer for yourself.
00:15:14 <theorbtwo> Learning Haskell will likely make your programming more flexable, and improve your c#... but the same is true of more or less any language.
00:15:22 * hackagebot h-booru 0.3.0.0 - Haskell library for retrieving data from various booru image sites  http://hackage.haskell.org/package/h-booru-0.3.0.0 (MateuszKowalczyk)
00:15:24 * hackagebot linear 1.15.0.1 - Linear Algebra  http://hackage.haskell.org/package/linear-1.15.0.1 (EdwardKmett)
00:16:47 <Hijiri> oh, the h stands for haskell
00:40:22 * hackagebot tasty-html 0.4.1 - Render tasty output to HTML  http://hackage.haskell.org/package/tasty-html-0.4.1 (jdnavarro)
00:40:26 <makalu> is there anything like fromJust for Either? Like fromLeft and fromRight?
00:41:01 <jle`> @hoogle Either a b -> a
00:41:03 <lambdabot> Data.Either lefts :: [Either a b] -> [a]
00:41:03 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
00:41:03 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
00:41:19 <MP2E> @hoogle Either a b -> Maybe a
00:41:19 <lambdabot> Data.Graph.Inductive.Graph lab :: Graph gr => gr a b -> Node -> Maybe a
00:41:19 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
00:41:19 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
00:41:52 <jle`> fromLeft = either id (error "why are you using fromLeft")
00:41:53 <MP2E> huh, either it is.
00:42:00 <MP2E> haha
00:42:05 <hyPiRion> lefts, rights
00:44:25 <faveteli_> :i Maybe
00:44:38 <faveteli_> >:i Maybe
00:44:53 <shachaf> lambdabot isn't ghci and won't answer questions like that.
00:45:02 <faveteli_> ok
00:45:30 <faveteli_> it is my understanding that Maybe is an instance of Applicative
00:45:40 <shachaf> Yes.
00:45:43 <faveteli_> but :i Maybe does not show this?
00:45:48 <faveteli_> what am i missing
00:45:53 <shachaf> Do you have Applicative in scope?
00:46:21 <jle`> `import Control.Applicative` should bring it in if it is not already
00:47:22 <faveteli_> yes you are correct that was the problem
00:47:23 <faveteli_> ty
00:48:46 <t2n> my code doesn't work well. what is the problem?
00:48:56 <t2n> test = case parse (manyTill parag eof) "" "Hello\nWorld\n\nTest\n" of
00:48:56 <t2n>         Right res -> res == ["Hello\nWorld", "Test\n"]
00:48:56 <t2n>  
00:48:56 <t2n> parag :: Parsec String u String
00:48:59 <t2n> parag =
00:49:02 <t2n>   do many emptyLine
00:49:05 <t2n>      try $ manyTill anyChar (string "\n\n")
00:49:08 <t2n>   <|> do manyTill anyChar eof
00:49:11 <mauke> don't paste into the channel
00:49:11 <shachaf> t2n: Please don't paste more than a couple of lines of code into the channel.
00:49:11 <t2n>  
00:49:21 <t2n> sorry
00:49:24 <jle`> @where lpaste
00:49:24 <lambdabot> http://lpaste.net/new/haskell
00:49:42 <mauke> 1) it makes it really hard to copy/paste the code into a clean file
00:49:51 <mauke> 2) you may be interrupted by other people talking
00:50:00 <mauke> 3) it's scrolling off the screen
00:50:20 <mauke> 4) "doesn't work" is not a problem description. what's the error?
00:50:32 <t2n> http://lpaste.net/114480
00:51:30 <t2n> i expected it to result in ["Hello\nWorld", "Test\n"], but it actually result in ["Hello\nWorld\n\nTest\n"]
00:52:10 <mauke> hmm. what happens without line 8?
00:53:05 <t2n> throw error -> Non-exhaustive patterns in case
00:53:43 <mauke> ok, and if you handle the other cases?
00:54:46 <t2n> if i try "Hello,World\n\nTest\n" as input, then it returns ["Hello,World","Test\n"] ( this seems to be right. )
00:55:17 <mauke> ooh
00:55:31 <t2n> maybe it fails at first '\n'
00:55:32 <mauke> manyTill anyChar (try (string "\n\n")) -- ?
00:56:36 <t2n> oh, it works well!
00:56:42 <dwat3r> hi guys, i have trouble with c2hs
00:56:52 <t2n> thanks a lot!
00:58:09 <dwat3r> i found a nasty bug in the libssh2 package, which doesn't allow me to use it to build an ssh client, and the solution is to modify the binding of a function.
00:58:52 <dwat3r> how can i bind a macro definition into haskell via c2hs? not a macro constant.
00:59:29 <mauke> I don't know c2hs but I know how to do it directly with the FFI
00:59:42 <dwat3r> how?
01:00:03 <mauke> two possible solutions
01:00:06 <dwat3r> i paste the #define here
01:00:17 <mauke> 1) write a custom wrapper function that uses the macro, then foreign import that
01:00:20 <mauke> 2) use https://www.haskell.org/ghc/docs/latest/html/users_guide/ffi.html#ffi-capi
01:00:23 * hackagebot extensible-effects 1.7.1.1 - An Alternative to Monad Transformers  http://hackage.haskell.org/package/extensible-effects-1.7.1.1 (shergill)
01:00:25 * hackagebot extensible-effects 1.7.1.0 - An Alternative to Monad Transformers  http://hackage.haskell.org/package/extensible-effects-1.7.1.0 (shergill)
01:08:01 <shergill> dcoutts: my hackage account (<http://hackage.haskell.org/user/shergill>) is suffering from the "package uploaders" bug (<https://github.com/haskell/hackage-server/issues/248>). could you add me to the "Package uploaders" group?
01:30:23 * hackagebot hakyll 4.6.1.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.6.1.0 (JasperVanDerJeugt)
01:35:23 * hackagebot hasql-backend 0.2.0 - API for backends of "hasql"  http://hackage.haskell.org/package/hasql-backend-0.2.0 (NikitaVolkov)
01:35:25 * hackagebot hasql 0.2.0 - A minimalistic general high level API for relational databases  http://hackage.haskell.org/package/hasql-0.2.0 (NikitaVolkov)
01:35:27 * hackagebot hasql-postgres 0.7.0 - A "PostgreSQL" backend for the "hasql" library  http://hackage.haskell.org/package/hasql-postgres-0.7.0 (NikitaVolkov)
03:02:48 <phischu> hi, has anyone recently managed to register an account on hackage? I am having difficulties because i do not get the confirmation mail.
03:08:54 <Heather> hello
03:09:10 <Heather> Im looking for better ways of getting data fields
03:09:29 <mauke> inb4 lens
03:09:47 <Heather> e.g. (myfield datathing) and I want datathing.myfield
03:09:56 <mauke> how is that better?
03:10:35 <Heather> mauke: no brackets
03:10:56 <mauke> myfield datathing
03:11:24 <Heather> mauke: its not the same )
03:23:48 <Heather> is there something to simplefy : if Nothing then False, if Just x then x
03:24:24 <wei2912> Heather: what're you trying to do?
03:24:30 <shachaf> Is x a boolean?
03:24:50 <wei2912> could you give us more details?
03:24:59 <tdammers> it has to be, otherwise it won't typecheck would it
03:25:24 * hackagebot zlib 0.5.4.2 - Compression and decompression in the gzip and zlib formats  http://hackage.haskell.org/package/zlib-0.5.4.2 (DuncanCoutts)
03:26:31 <mauke> Heather: fromMaybe False
03:26:40 <Heather> shachaf: yes
03:27:12 <Heather> :t fromMaybe
03:27:13 <lambdabot> a -> Maybe a -> a
03:27:32 <wei2912> > fromMaybe False Nothing
03:27:33 <mauke> @. djinn type fromMaybe
03:27:33 <lambdabot>  False
03:27:34 <lambdabot> f a b =
03:27:34 <lambdabot>     case b of
03:27:34 <lambdabot>     Nothing -> a
03:27:34 <lambdabot>     Just c -> c
03:27:36 <wei2912> > fromMaybe False (Just True)
03:27:37 <lambdabot>  True
03:28:29 <Heather> mauke: yes, thanks
03:30:24 * hackagebot http-client 0.4.3 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.4.3 (MichaelSnoyman)
03:30:26 * hackagebot http-conduit 2.1.5 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-2.1.5 (MichaelSnoyman)
03:42:52 <Boreeas> :t lift
03:42:53 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
03:45:24 * hackagebot happindicator3 0.1.0 - Binding to the appindicator library.  http://hackage.haskell.org/package/happindicator3-0.1.0 (mlacorte)
04:22:51 <Peaker> Hey, given GHC.Generics seems to be the new/modern way to do auto-instantiations of various classes -- is there any viable strategy to handle the problem where having a Generic instance makes a type non-abstract?
04:23:50 <Peaker> I guess one could newtype around each type to re-export all the instances except Generic?
04:38:48 <dreixel> Peaker: see, for example, the Data instance of Map: https://www.haskell.org/ghc/docs/latest/html/libraries/containers/src/Data-Map-Base.html#Map
04:38:57 <dreixel> I suppose you could do something similar for Generic
04:41:30 <Peaker> dreixel: I don't quite understand that, I've not read the SYB papers/etc
04:43:18 <dreixel> Peaker: the idea is that you can give a manual instance which hides the implementation details
04:52:19 <sshine> is it good style to use liftM rather than fmap after the functor-applicative-monad proposal?
04:52:59 <tdammers> sshine: I'd say no, but that's personal preference
04:53:13 <Gatis> God bless you
04:53:16 <Gatis> What a wonderful song
04:54:28 <Gatis> https://www.youtube.com/watch?v=zC617kE1maU
05:10:18 <Heeenkk> ?src head
05:10:18 <lambdabot> head (x:_) = x
05:10:18 <lambdabot> head []    = undefined
05:28:36 <ocramz> ?src mapM_
05:28:36 <lambdabot> mapM_ f as = sequence_ (map f as)
05:29:19 <ocramz> I love you lambdabot
05:31:30 <dfeuer> Morning, Haskellites.
05:31:45 <ocramz> good morning dfeuer
05:33:44 <dfeuer> ocramz, it's actually better to define sequence_ = mapM_ id
05:34:02 <dfeuer> (It's a little gentler on the optimizer)
05:34:30 <dfeuer> (Most of the time, there's no difference, but occasionally there is one.)
05:36:32 <ocramz> dfeuer, thanks! though I haven’t reached this level of sophistication yet
05:37:34 <dfeuer> ocramz, I'm just letting you know; I found that changing the libraries to define those the other way around had a major impact on one of the "nofib" benchmarks, so that'll happen in the next version :-)
05:37:42 * dfeuer is not sophisticated.
05:37:59 * dfeuer is good at trying things out.
05:40:24 * hackagebot hspec-contrib 0.1.0 - Contributed functionality for Hspec  http://hackage.haskell.org/package/hspec-contrib-0.1.0 (SimonHengel)
05:42:38 <meretrix> I want to use a very basic socket request-response based IPC using Binary serialization.  Is there a Haskell library that can intelligently receive an arbitrary length encoded bytestring from a socket?
05:42:54 <meretrix> Or are my only options to write my own or use something like zeromq?
05:44:55 <meretrix> I think the only tricky part is knowing how many bytes to receive from the socket to get a bytestring that can be decoded by Binary.
05:46:03 <tdammers> why not zeromq?
05:46:14 <tdammers> haskell bindings are there, it's platform-neutral, and it works
05:46:30 <tdammers> plus you get a bunch of nice features for free
05:47:07 <meretrix> I didn't want to pull in another non-Haskell library, but I guess that's not a big deal.
05:51:12 <saep> Parsec kills me: "unexpected end of input" "expecting end of input or ..."
06:04:02 <dwat3r> can somebody help me with a c2hs problem?
06:06:03 <dwat3r> i found a wrong binding in libssh2 package, the one named libssh2_channel_process_startup
06:06:23 <shergill> dcoutts_: ping
06:06:38 <dcoutts_> shergill: pong
06:06:44 <dwat3r> but c2hs fails to preprocess it, beause it says that i bound wrong parameters
06:07:00 <dwat3r> but i didn't, i checked it at least a 1000000 times
06:07:05 <shergill> dcoutts_: my hackage account (<http://hackage.haskell.org/user/shergill>) is suffering from the "package uploaders" bug (<https://github.com/haskell/hackage-server/issues/248>). could you add me to the "Package uploaders" group?
06:07:17 <dwat3r> please explain to me what the fuck is happening
06:09:06 <dcoutts_> shergill: done
06:09:20 <shergill> dcoutts_: cheers
06:15:17 <dwat3r> thanks the help
06:15:24 <ChristianS> what's up with haskell.org?
06:17:25 <novns> ChristianS, it works
06:18:19 <ChristianS> novns: yeah, but it seems pretty slow
06:19:27 <novns> no problems here
06:42:07 <ocramz> hullo there!
06:43:43 <ocramz> a tooling related question: how do I get emacs to only see a specific cabal sandbox? I’ve tried fiddling with the call to ghci in inf-haskell.el, to no avail
06:44:23 <indiagreen> ocramz: set Haskell process to be “cabal repl”
06:45:21 <ocramz> indiagreen: thanks, but cabal repl requires having a .cabal file, and I seldom set up a cabalized package for small experiments
06:45:35 <indiagreen> ah, right
06:45:37 <indiagreen> hm
06:48:59 <dcoutts_> ocramz: cabal repl in a sandbox without a package also works now
06:50:25 * hackagebot binary-list 1.0.1.0 - Lists of length a power of two.  http://hackage.haskell.org/package/binary-list-1.0.1.0 (DanielDiaz)
06:50:53 <dwat3r> c2hs: src/C2HS/Gen/Bind.hs:(1132,5)-(1150,66): Non-exhaustive patterns in function addDft
06:51:02 <dwat3r> can sby help me?
06:51:03 <ocramz> dcoutts_: er, is there a new cabal out? I have 1.18.0.5
06:51:49 <dcoutts_> ocramz: 1.20
06:52:17 <isomorphic> ocramz:  I usually do a quick cabal init, then rename my file Main.hs for that -- much easier
06:53:06 <isomorphic> dcoutts_:  Can you make the cabal repl work if the package is broken?
06:53:29 <isomorphic> dcoutts_:  from memory if it doesn't build, it doesn't import the module
06:53:34 <isomorphic> modules*
06:54:24 <isomorphic> That may sound silly - I mean the non-broken modules, obviously not the broken one ;)
06:56:50 <dcoutts_> isomorphic: by default it'll try to load all modules, but if some don't load then you get a ghci session with some loaded and the error messages
06:56:51 <ocramz> isomorphic: a new sandbox every time? I mean, if using large/many packages, this would imply much wasted space for copies of libraries..
06:57:28 <bitraten> hi, is filestore not in stackage anymore?
06:57:29 <dcoutts_> ocramz: isomorphic means a dummy .cabal package, not a sandbox. But as I say, it's not necessary as cabal repl inside a sandbox will work.
06:58:25 <isomorphic> dcoutts_:  Cool.  So what I had in mind - and I didn't realize it wouldn't be clear until after I'd written - I'm thinking of the case where I've broken some code and I'd like to load it and use ghci to figure out types... nice to get as much as possible loaded in that situation
07:00:17 <dcoutts_> isomorphic: you can also just :load things once ghci starts
07:04:14 <isomorphic> dcoutts_:  Good plan :)
07:04:16 <isomorphic> Thanks
07:05:36 <ocramz> dcoutts_ , isomorphic : thanks guys, I’m updating cabal and I’ll set emacs to launch cabal repl rather than ghci
07:09:20 <jeltsch> > fix show
07:09:21 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
07:12:34 <magicman> > fix error
07:12:35 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
07:13:27 <mauke> > fix fail
07:13:28 <lambdabot>  ""
07:15:27 <dfeuer> Somebody fmap me.
07:15:38 <benzrf> @let me = const (text "some things are unfixable")
07:15:40 <benzrf> > fix me
07:15:41 <lambdabot>  Defined.
07:15:44 <lambdabot>  some things are unfixable
07:17:09 <ocramz> benzrf : lol
07:19:47 <RobT-> You guys checked out these Haskell resources yet? https://haskell.zeef.com/konstantin.skipor
07:21:49 <clrnd> lol
07:29:04 <ocramz> dcoutts_ : o frabjous day, cabal 1.20 does the Right Thing! thank you so much sir
07:47:29 <JonReed> Hi! Is there any easy way to do something like this [1, 2, 3] -> [4, 5, 6] -> [1, 4, 2, 5, 3, 6], in other words, [a, a] -> [a1, a1] -> [a, a1, a, a1] ?
07:48:53 <jesyspa> JonReed: concatMap (\(a, b) -> [a, b]) . zip comes to mind
07:48:55 <hape01> JonReed: zip
07:49:18 <ClaudiusMaximus> > concat (transpose [[1,2,3],[4,5,6]])
07:49:19 <lambdabot>  [1,4,2,5,3,6]
07:49:39 <ocramz> :t transpose
07:49:39 <lambdabot> [[a]] -> [[a]]
07:50:05 <JonReed> Thank you!
07:52:03 <wei2912> is there a `choice` in Parsec but it backtracks when a parser fails?
07:52:38 <clrnd> wires`, mmmm `try`?
07:52:52 <clrnd> try pa <|> pb
07:52:56 <clrnd> :t try
07:52:57 <lambdabot> Exception e => IO a -> IO (Either e a)
07:52:59 <clrnd> lol
07:53:05 <wei2912> that works, but i need it for a huge list
07:53:08 <clrnd> wei2912, *
07:53:11 <wei2912> okay, not really huge\
07:53:14 <wei2912> but i'm lazy
07:53:35 <clrnd> wei2912, jaja, I dunno, define your own <|>
07:57:07 <wei2912> also, is there a way to loop till EOF?
07:57:52 <shiona> :t getContents
07:57:53 <lambdabot> IO String
07:59:02 <alkabetz> wei2912: Regarding 'try', you might want to read http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/
07:59:46 <wei2912> alkabetz: ty
08:00:03 <alkabetz> You’re welcome.
08:01:52 <wei2912> and... third question, is it possible for me to write a parser that loops for every newline till EOF?
08:02:22 <alkabetz> wei2912: Do you want your parser to emit output before the EOF occurs?
08:02:42 <wei2912> alkabetz: whichever way is easier
08:02:53 <wei2912> alkabetz: which i suppose is to emit output after EOF?
08:02:59 <alkabetz> If you’re using Parsec, yes.
08:03:19 <alkabetz> There are other parser libraries (e.g., attoparsec), that can parse stuff as it comes in
08:03:40 <alkabetz> This is essential for, e.g., XMPP, where an entire chat conversation spanning many hours gets represented as a single XML document.
08:03:52 <wei2912> i see
08:04:46 <alkabetz> So I would recommend something like 'getContents >>= (printOutput . parseMyString)', where you define 'printOutput' and 'parseMyString'.
08:05:07 <alkabetz> Put that in your main function, and then have 'parseMyString' call out to Parsec to produce a syntax tree.
08:09:22 <wei2912> alkabetz: hmm, i'm new to this, so could you provide some elaboration? perhaps it'd be best if i explain my scenario, since i don't need a syntax tree
08:09:37 <alkabetz> What are you parsing?
08:09:40 <wei2912> on every line there's a date of varying format
08:09:56 <wei2912> and that's about it
08:10:37 <alkabetz> Ah, I see.  So every time I said ‘syntax tree’, think ‘list of parsed dates’.
08:11:04 <alkabetz> I’d recommend writing a parser for a single line, and then using the 'lines' function to split your input into lines before passing them off to your parser.
08:13:01 <wei2912> alkabetz: that was my original plan, but errors don't indicate the correct line number
08:13:41 <alkabetz> Oh, of course.
08:13:51 <alkabetz> I think there’s a Parsec function to manually set the line, but I don’t actually remember.
08:14:45 <alkabetz> So you could keep track of the line in your non-Parsec code (e.g., 'getContents >>= (parseNumberedLine . zip [1..] . lines)').
08:14:54 <clrnd> or you can provide line errors manually catching parsec's error
08:14:59 <clrnd> that ^
08:15:22 <wei2912> alright
08:15:29 <wei2912> i'll see if i can find the function to manually set the line
08:15:50 <wei2912> thanks clrnd alkabetz for your help!
08:15:56 <alkabetz> You’re welcome.  Good luck!
08:16:17 <JonReed> Hi! Right now I'm using vim with a bunch of plugins as a haskell IDE, but I'm thinking about switching to an IDE that has vim bindings. There is a new HaskForce plugin for IntelliJ and there's also Leksah. Do you guys have any opinions on which IDE is the best for haskell (with the support for vim bindings)?
08:19:13 <wei2912> JonReed: you don't really need an IDE for haskell (and i don't think vim with a bunch of plugins is considered an IDE?)
08:19:53 <wei2912> JonReed: you can probably survive with another terminal and perhaps a file browser (that is command line?)
08:20:59 <wei2912> or you could try a tiling window manager for productivity and to align the videos (if you don't want a full blown window manager, there's probably tmux for that)
08:28:19 <Enigmagic> JonReed: IntelliJ's vim bindings are okay.. depends on how many vim features you rely on.
08:28:37 <{AS}> There are many good Haskell modes for Emacs, and it contains an excellent vim emulation mode (evil)
08:29:32 <{AS}> Like Structured Haskell Mode
08:38:34 <wei2912> how do i repeat getLine till i hit EOF?
08:38:55 <wei2912> on second thoughts, nvm
09:07:24 <Hijiri> what verion were typed holes added to ghc?
09:12:11 <dmj`> 7.8.3
09:12:30 <dmj`> https://www.haskell.org/ghc/docs/7.8.3/html/users_guide/typed-holes.html
09:13:11 <Hijiri> thanks
09:13:43 <red_> having trouble reasoning through the recursion in the following .. somebody haaaaaalp
09:13:46 <red_> cp (xs:xss) = [x : ys | x <- xs, ys <- cp xss]
09:14:05 <red_> cp :: [[a]] -> [[a]]
09:18:56 <johannes__> doesn't it just duplicate the list?
09:19:35 <mauke> it's missing a base case
09:19:46 <mauke> but it looks like it's tracing all possible paths through a list of lists
09:20:19 <mauke> > sequence ["abc", "DE", "xy"]
09:20:20 <lambdabot>  ["aDx","aDy","aEx","aEy","bDx","bDy","bEx","bEy","cDx","cDy","cEx","cEy"]
09:20:26 <mauke> like that
09:21:36 <EvanR> :t sequence `asAppliedTo` [""]
09:21:37 <lambdabot> [[Char]] -> [[Char]]
09:27:00 <lf94> Is there something like this for Haskell? http://jodd.org/doc/jerry/
09:27:08 <ski> red_ : "arbitrarily pick one element from the first list" `x <- xs'
09:27:30 <ski> red_ : "arbitrarily pick one element each from the remaining lists" `ys <- cp xss'
09:28:27 <ski> red_ : "put the first picked element in front of the rest. collect a list of all possible ways to make the earlier choices" `[x : ys | ...]'
09:31:27 <zomg> lf94: you could probably use tagsoup or hxt or something like that
09:31:49 <lf94> zomg: I'll check it out
09:33:59 <clrnd> lf94, http://egonschiele.github.io/HandsomeSoup/
09:34:02 <red_> ski: thanks .. that helps . the second recursive step was boggling me .. but (with a base case) you end up getting a bunch of singletons that are going to be cons'd onto x.
09:34:19 <red_> :t sequence
09:34:20 <lambdabot> Monad m => [m a] -> m [a]
09:34:33 <clrnd> :t sequenceA
09:34:34 <lambdabot>     Not in scope: ‘sequenceA’
09:34:34 <lambdabot>     Perhaps you meant one of these:
09:34:34 <lambdabot>       ‘T.sequenceA’ (imported from Data.Traversable),
09:34:39 <clrnd> :t traverseA
09:34:40 <lambdabot>     Not in scope: ‘traverseA’
09:34:40 <lambdabot>     Perhaps you meant one of these:
09:34:40 <lambdabot>       ‘traversed’ (imported from Control.Lens),
09:34:47 <clrnd> :t T.sequenceA
09:34:48 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
09:35:12 <red_> kinda the same type .. is sequencA more general?
09:35:18 <ski> red_ : what's your base case ?
09:35:31 <lf94> clrnd: perfect.
09:35:36 <red_> cp [] = [[]]
09:35:43 <clrnd> as I see it sequenceA just <*>'s everything and sequence just >>='s everything
09:36:00 <ihatehex> is there any sensible reason that I should learn haskell besides "it's pretty"?
09:36:01 <ski> `sequenceA' is more general than `sequence', yes, since every monad is an applicative/idiomatic functor (and because lists are traversable)
09:36:05 <ski> @type sequence
09:36:05 <lambdabot> Monad m => [m a] -> m [a]
09:36:14 <ski> @type T.sequence
09:36:14 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
09:36:17 <ski> @type T.sequenceA
09:36:17 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
09:36:42 <clrnd> ihatehex, yess, you will learn a lot and improve your overall understanding of the basis of programming
09:36:53 <clrnd> also it's quite sexy
09:37:06 <ihatehex> I don't see how it explains anything about the 'basis of programming'
09:37:19 <lf94> ihatehex: haskell is clean, expressive, and makes you think in terms of data flow
09:37:30 <lf94> It's really hard to explain
09:37:37 <ihatehex> so is a rinsed pineapple, doesn't mean I'm going to use it for a new application
09:37:37 <lf94> But use it and  I promise you'll be enlightened
09:37:46 <clrnd> because people are used to thinking programming is just boxes and mutation, when in reality it is more about the notion of computation and there are several ways to arrive there, mutability being only one way
09:38:08 <clrnd> imperativity*
09:38:08 <ski> red_ : looks good. "there is only one way to pick one element each from an empty list of lists, and that's the empty list of zero picked elements, one from each of the zero lists" `cp [] = [[]]'
09:38:39 * geekosaur is getting closer and closer to just re-uploading old-locale as date-locale
09:38:47 <zomg> ihatehex: as someone who wrote code in mostly OO and dynamic typed langs, learning Haskell did require a much different way of thinking. I can certainly say that it did make me a better programmer as cheesy as it may sound =)
09:39:04 <geekosaur> since it's been how many years now and nobody wants to admit that it was incorrectly deprecated
09:39:16 <clrnd> geekosaur, yay
09:40:18 <clrnd> ihatehex, have you ever thought "ugh if add a variable here things will probably break somewhere else"?
09:40:36 <clrnd> ihatehex, haskell teachs you to cure that :P
09:40:37 <ihatehex> clrnd: no, I have good coding habits
09:40:41 <red_> ihatehex: "rinsed pineapple"!! purity and the the strong typing make it easy to reason about behavior ... since you can compose pure functions to your heart's content
09:40:54 <simpson> clrnd: That's funny; that only really happens in Haskell for me. "Oh, I could just add a type variable here!"
09:41:12 <clrnd> simpson, jajja
09:41:53 <EvanR> ihatehex: after learning to think differently in haskell, the next challenge is to relearn how to think in the original way when you go back to your job which is using something else
09:42:13 <clrnd> (that can be frustrating ...)
09:42:14 <ihatehex> so haskell is like a drug
09:42:18 <ihatehex> and it makes your job suck more than usual
09:42:19 <ihatehex> ok
09:42:25 <dmj`> or just don't go back to your old job?
09:42:25 <exio4> a gateway drug
09:42:29 <EvanR> haskell is basically drugs
09:42:31 <merijn> ihatehex: That sounds pretty accurate, actually
09:42:38 <zomg> yep
09:42:47 <zomg> haskell is like heroin
09:42:49 <dmj`> make your own haskell job
09:42:49 <clrnd> yes
09:42:56 <zomg> you can use cannabis (your old language)
09:42:56 <merijn> Any type wizards around? I can't manage to beat GHC into accepting my code without needing to insert typeclass constraints throughout my codebase :\
09:42:56 <clrnd> yeah that's pretty much it
09:42:59 <zomg> but you'll always want more heroin
09:43:01 <zomg> lol
09:43:12 <Haskellfant> So in a boring lecture today I wondered if Pipes are a profunctor and I managed to write an instance for it but only using a newtype to change the order of type arguments which makes this not very usable. I wonder if there are some ghc extensions that would allow me to do this without the newtype http://lpaste.net/114503
09:43:25 <simpson> Honestly, none of this actually sounds like Haskell. Haskell's just another language.
09:43:54 <ihatehex> simpson: I'm fairly sure someone just launched a Haskell-based drone to your location
09:43:55 <clrnd> well, most pop languages are impure and eager, haskell being lazy and pure is quite differnt I'd say
09:44:03 <Haskellfant> the only difference is that it sucks a bit less than most other languages
09:44:10 <merijn> I have "authMode :: forall (mode :: AuthMode) . Auth mode -> AuthMode; authMode _ = fromSing (sing :: Sing mode)", but GHC isn't smart enough to infer that all possible values of 'mode' have SingI instances, so it complains that there's "no SingI instance for mode"
09:44:16 <clrnd> actually a pure and lazy python would make a hell of a ride
09:44:26 <ocfx> heroin
09:44:27 <ocfx> ?
09:44:50 <merijn> clrnd: I started to design that, but I stopped when I realised I was literally reinventing haskell
09:45:09 <monochrom> @quote monochrom downloaded.ghc
09:45:10 <lambdabot> monochrom says: I was trying to design a sensible language... then I downloaded ghc.
09:45:14 <chrisdone> ski: i think i came up with a good summary of what i'm after (ideally) regarding the expansion stuff. i want a program that'll take in a haskell module (of definitions, for scope) and an expression, reduce it by one step (breadth first) and then output a new, valid expression
09:45:14 <chrisdone> ski: been pondering it more and i think you can do it by wrapping your things up with a label for what part of the hierarchy it sits in (or what source span). those trace-like things spit a stream of source spans via some unsafePerformIO nasty business.
09:45:15 <chrisdone> ski: so e.g. when a function is applied (f 5), first you expand `f`, that's one step => ((\x -> x*x) 5). the whole "f 5" source span is replaced with this. then you ignore the rest of the stream. now when you have a lambda in application position, ((\x -> x*x) 5) spits out a source span and replacement text of "5 * 5", ignore the rest of the stream, and output a new expression with this update
09:45:30 <simpson> ihatehex: Well, I *do* live in one of the big Haskell areas (Portland).
09:45:45 <ihatehex> There's an AREA for Haskell?
09:45:50 <ihatehex> Kind of like a quarantine zone?
09:45:55 <ihatehex> Is it like Detroit, but for programmers instead of black people?
09:45:55 <monochrom> haha
09:45:58 <sivteck> cabal sandbox
09:46:00 <clrnd> merijn, yeah I was thinking, you'll need all the categorical party-van to make pure code platible
09:46:05 <Haskellfant> ihatehex: you gotta protect those java devs
09:46:12 <chrisdone> they call it… “the IO monad”
09:46:15 <ihatehex> Haskellfant: Yes, I'll probably be one of them. :P
09:46:23 <chrisdone> "you are banished to IO!" "noooo"
09:46:36 <merijn> clrnd: No, I was just going to do "pure python + type inference" not even lazy, but it looked so much like haskell + IO I decided it wasn't worth it
09:46:57 <simpson> merijn: It exists, it's calls RPython, it's a cool research venue.
09:47:35 <merijn> Does anyone know if any singletons people hang around here or on #ghc?
09:47:54 <ihatehex> I don't even know what a singleton is
09:47:56 <ihatehex> :(
09:47:58 <chrisdone> it's a chat up line
09:48:09 <clrnd> ihatehex, didn't you just say you were a java guy ...
09:48:10 <ihatehex> Singletons == chat up line?
09:48:18 <ihatehex> clrnd: I probably will be at one point
09:48:44 <ihatehex> I coded minute amounts of Python years ago, now I am in college and programming Java
09:48:58 <clrnd> @where LYAH
09:48:58 <lambdabot> http://www.learnyouahaskell.com/
09:49:00 <ihatehex> and Haskell gives IRC-coders a hard one
09:49:04 <ihatehex> I've been reading it
09:49:08 <ihatehex> It's mostly very well written
09:49:59 <merijn> ihatehex: singletons is a library for pseudo dependent types in haskell
09:50:01 <ihatehex> SvenskFisk: Are you sure you aren't a Russian submarine?
09:50:03 <osa1> question about QuickTest's test generation: let's say I have `oneof [arbitrary1, arbitrary2, ... artbitraryN]`. in what order tests are generated? if I run this test for this exactly N times, does that generate one test for each case?
09:50:16 <JonReed> Is Haskell.org dead?
09:50:39 <Haskellfant> JonReed: works for me
09:50:44 <JonReed> Not anymore... strange. There was a wierd bug where it kept refreshing
09:50:48 <ihatehex> JonReed: Doesn't look dead
09:50:50 <JonReed> For 10 sconds or so
09:50:59 <simpson> ihatehex: Welcome to college! You've got lots of time while you're here. Learn Forth, Prolog, and APL. This'll be your last chance to indulge in spare time for a while.
09:51:10 <simpson> (And each of those will bend your mind just as much as Haskell.)
09:51:18 <ihatehex> I heard Prolog was awful
09:51:24 <ihatehex> I don't know what Forth and APL are
09:51:47 <simpson> You won't learn them to use them in production. You'll learn them so that you have more ways to think about things.
09:51:47 <geekosaur> prolog is "awful" because it's so different
09:52:20 <clrnd> APL and J are quite good languages, really cryptic but incredibly powerful
09:52:45 <ihatehex> I want to use LOLCODE in production
09:53:05 <larsen> I had plenty of good time learning (and debugging) Prolog for my AI exam, back in the days. It is an interesting language (never used since then, tho')
09:53:07 <ihatehex> I wonder if one could make Haskell read like LOLCODE
09:53:25 <simpson> LOLCODE is just papered-over Python.
09:55:13 <ski> @quote hoare
09:55:13 <lambdabot> hoare says: There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies, and the other way is to make it so complicated that there are no obvious deficiencies. The first method is far more difficult.
09:55:21 <ski> @quote elegance
09:55:21 <lambdabot> O'Keefe says: "Elegance is not optional."
09:55:25 * hackagebot units 2.2 - A domain-specific type system for dimensional analysis  http://hackage.haskell.org/package/units-2.2 (RichardEisenberg)
09:55:34 <ski> @remember Dijkstra How do we convince people that in programming simplicity and clarity —in short: what mathematicians call "elegance"— are not a dispensable luxury, but a crucial matter that decides between success and failure?
09:55:34 <lambdabot> I will never forget.
09:55:45 <ski> @remember Dijkstra Simplicity is a great virtue but it requires hard work to achieve it and education to appreciate it. And to make matters worse: complexity sells better.
09:55:45 <lambdabot> Okay.
09:55:51 <ski> @quote conventional.wisdom
09:55:51 <lambdabot> monochrom says: And so, I use formal logic all the time, and can still be very practical and speedy. This is contrary to most people's conventional wisdom. This is because they have only seen very primitive formal logics, like if you have only seen assembly code, you think programming is undoable.
09:56:05 <ski> hm
09:56:07 <ski> @quote conventional.wisdom.shared
09:56:07 <lambdabot> Knuth says: The conventional wisdom shared by many of today's software engineers call for ignoring efficiency in the small; but I believe this is simply an overreaction to the abuses they see being practiced by pennywise-and-pound-foolish programmers, who can't debug or maintain their "optimized" programs.
09:56:12 <ski> @quote premature.optimization
09:56:12 <lambdabot> Knuth says: We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%.
09:56:27 <ski> ihatehex : i just thought you could find the above quotes interesting
09:57:02 <ski> (the monochrom one was unintentional, but possibly also appropriate in this context)
09:57:59 <ihatehex> I should learn COBOL just to be a hipster
09:58:05 <simpson> Don't.
09:58:20 <josephle> COBOL is not even hipster
09:58:31 <simpson> I learned COBOL when I was younger. Turns out that they're well-compensated mostly because COBOL maintenance is painful and soul-sucking.
09:58:55 <ihatehex> Yes, I heard it's a good way to make money and lose your mind simultaneously.
09:59:32 <fragamus> obviously you guys aren't using FP-COBOL
09:59:46 <monochrom> much as I like the symmetry in natural deduction, it is still pretty primitive. it doesn't streamline equations and inequalities. http://www.cs.utoronto.ca/~trebla/eq-wiltink.pdf
10:00:00 <ski> monochrom : i agree
10:00:23 * ski has been pondering systems to attempt to address that question for some years now ..
10:00:45 <ihatehex> Maybe I should learn ActionScript
10:01:00 <monochrom> Jim Grundy's "window inference" may inspire you.
10:01:47 <geekosaur> my brain is now trying to envision what fp cobol would look like. I hate you all. <3
10:02:17 <sivteck> n\
10:02:56 <monochrom> FP COBOL will syntactically look like using Applicative except you say "by" instead of "<*>"
10:03:09 <simpson> What would you do for ALTER?
10:03:24 <monochrom> multiply <$> readIO `by` readIO
10:03:53 <monochrom> I don't know ALTER. my knowledge of COBOL stops at "multiple x by y into z"
10:04:20 <simpson> Ah. Well, first you need to know GOTO. GOTO causes execution to jump to an indirect code label.
10:04:37 <simpson> ALTER takes an indirect code label and points it to another indirect code label.
10:04:51 <clrnd> I think i just crap my pants
10:05:07 <bennofs> that's mutation on a whole new level
10:05:25 * hackagebot units-defs 2.0 - Definitions for use with the units package  http://hackage.haskell.org/package/units-defs-2.0 (RichardEisenberg)
10:05:26 <mauke> simpson: how deep/early is this?
10:05:51 <simpson> mauke: You're presented with this fairly early on; COBOL is not a structured language.
10:05:55 <monochrom> I wonder if you can do the same in delimited continuations with dynamic prompts
10:06:04 <mauke> could you describe it using GNU C dynamic labels?
10:06:57 <simpson> I think that the docs are helpful: http://documentation.microfocus.com/help/topic/GUID-0E0191D8-C39A-44D1-BA4C-D67107BAF784/HRLHLHPDF803.html
10:07:45 <simpson> ALTER LABEL42 TO PROCEED TO PARAGRAPH5
10:08:10 <simpson> LABEL42: GO TO PARAGRAPH6
10:08:35 <simpson> So LABEL42 starts off going to PARAGRAPH6. However, when the ALTER is reached, LABEL42 now goes to PARAGRAPH5.
10:08:55 <simpson> And yes, this is generally considered bad practice.
10:09:17 <glguy> From the look of those warnings at the top of the documentation it's known to be a bad thing and excluded from ANSI'85 and X/Open COBOL
10:09:29 <mauke> ALTER A TO T1; ALTER B TO A; ALTER A TO T2; GO TO B
10:09:29 <phaskell> T2: Move wiki to rackspace vm - https://phabricator.haskell.org/T2
10:09:29 <phaskell> T1: SSL for monitor.haskell.org/nagios - https://phabricator.haskell.org/T1
10:09:35 --- mode: ChanServ set +o mauke
10:09:35 --- kick: phaskell was kicked by mauke (phaskell)
10:11:35 --- mode: mauke set -o mauke
10:12:42 <mauke> 1) is this valid code?  2) does it go to T1 or to T2?
10:14:06 <simpson> mauke: It's not in quite the right structure, but if A and B were both labels, then this would jump to T2.
10:14:28 <simpson> I'll let cowan have the last word: http://home.ccil.org/~cowan/cobol-horrors.html
10:15:26 <simpson> <cowan> Naturally, when code gets paged out, the ALTERs in the paged-out code are forgotten.
10:17:12 <ski> monochrom : ty
10:17:36 <merijn> What's the right place for obscure Oleg-ian "how do I bend GHC to my will" questions? -cafe?
10:18:37 <geekosaur> generally yes
10:20:24 <merijn> bleh, -cafe seems so high traffic I wanted to avoid subscribing :\
10:20:53 <newsham> if you make an FFI call to some IO operation that can block, do you have to integrate to the threading system somehow to make it work properly, or does the threading system properly handle that already?
10:21:10 <newsham> for exapmle, if you wanted to make an FFI call to sendto() instead of using whats in the std libs
10:22:04 <merijn> newsham: The threaded runtime will run it in a separate OS thread
10:22:44 <merijn> If you're able to make it non-blocking that'd work better, but it will work this way too
10:24:19 <newsham> how do you do nonblocking io ops in ffi?   do you mean expose the start of operation and compeltion or polling to haskell?
10:26:42 <merijn> newsham: Right
10:26:59 <mauke> threadWaitWrite, probably
10:27:33 <merijn> newsham: Exactly, if you can manage to get a file descriptor for your operation you can use threadWaitRead/threadWaitWrite
10:27:41 <merijn> And since recently their STM equivalents :D
10:30:28 <newsham> ahh,  I see..  hook into the thread systems own event loop.. i like that
10:31:21 <ski> @hoogle threadWait
10:31:21 <lambdabot> Control.Concurrent threadWaitRead :: Fd -> IO ()
10:31:21 <lambdabot> Control.Concurrent threadWaitWrite :: Fd -> IO ()
10:31:21 <lambdabot> GHC.Conc.IO threadWaitRead :: Fd -> IO ()
10:32:17 <ihatehex> what's a hoogle?
10:32:27 <adamse> ihatehex: http://haskell.org/hoogle/
10:32:38 <adamse> a search engine for haskell functions and types
10:32:47 <ihatehex> so it's like google but for things no one needs
10:33:01 <ihatehex> also it won't load
10:33:08 <adamse> nope seems to not load right now
10:33:08 <merijn> haskell.org is down, atm
10:33:13 <mauke> ihatehex: are you trying to troll?
10:33:18 <adamse> but hoggle is suuuuper useful
10:33:21 <JonReed> ihatehex: You can also search there types, which is very useful
10:33:25 <adamse> wouldn't do haskell without it
10:33:27 <merijn> mauke: Obviously
10:33:43 <sivteck> hayoo is nice too
10:33:47 <sivteck> @where hayoo
10:33:47 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html – See also Hoogle: http://haskell.org/hoogle
10:33:52 <ihatehex> adamse: So someone is trying to bring Haskell to its knees by DDOSing Hoogle?
10:33:53 <ihatehex> D:
10:34:03 <newsham> -- The manual says the following functions (actually macros)
10:34:03 <newsham> -- are constant and thus we do not have to use IO monad.
10:34:06 <newsham> *sigh*
10:34:31 <EvanR> newsham: whu?
10:34:34 <newsham> macro peeks into memory
10:34:35 <ihatehex> What does monad mean?
10:34:46 <newsham> clearly not pure
10:34:47 <JonReed> ihatehex: E.g., you know that you want some function, but you don't know whether it's already been written. Then you can search the type signature and find out. "[Maybe a] -> a" and hoogle will give you the function that goes that
10:35:10 <hiptobecubic> the function(s)
10:35:18 <JonReed> hoogle is one of the reasons I love haskell
10:35:28 <merijn> ihatehex: A monad is just the name for a common reoccurring abstraction pattern (or interface?), the name originally comes from math, but the actual interface as used in haskell has fairly little to do with that
10:35:38 <jmct> indeed hoogle is great. Having a local install is worthwhile as well.
10:35:43 <EvanR> [Maybe a] -> a, required to be partial function right
10:35:48 <ihatehex> I clearly don't know enough math to learn Haskell
10:35:50 <ihatehex> :[
10:35:52 <clrnd> LYAH explains monads eventually
10:36:03 <clrnd> no you don't need to know matha t all, trust me
10:36:09 <hiptobecubic> hoogle is just a database. The real reason it's useful is function purity.
10:36:22 <hiptobecubic> so there's some hope that the functions you find will do what you want
10:36:34 <EvanR> @hoogle [Maybe a] -> a
10:36:34 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
10:36:35 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
10:36:35 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
10:37:09 <JonReed> EvanR: I meant [Maybe a] -> [a]
10:37:33 <ihatehex> can Haskell do server-side type things?
10:37:39 <merijn> ihatehex: Math knowledge is overrated for haskell
10:37:44 <mauke> ihatehex: what's a server?
10:37:46 <ihatehex> Can it interact in any sensible way with html/css/javascript?
10:38:08 <jmct> JonReed: Then it doesn't have to be partial
10:38:11 <dav> any idea what to do with this cabal error: http://paste.debian.net/132370/ ?
10:38:11 <clrnd> ihatehex, there are complex web frameworks yes, just like in any other language
10:38:12 <ski> newsham : memory that may be mutated ?
10:38:36 <newsham> ski: indeed.
10:39:33 <mauke> dav: that looks like http-conduit isn't specifying its dependencies completely
10:39:40 <mauke> maybe this is fixed in a newer version?
10:40:09 <chrisdone> i think you need a flag
10:40:13 <dav> mauke: it is, but handa-gdata seems to want this version specifically
10:40:19 <JonReed> ihatehex: You can also compile haskell to javascript with e.g. Fay
10:40:26 * hackagebot uhc-light 1.1.7.0 - Part of UHC packaged as cabal/hackage installable library  http://hackage.haskell.org/package/uhc-light-1.1.7.0 (AtzeDijkstra)
10:40:43 <ski> @hoogle [Maybe a] -> [a]
10:40:43 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
10:40:43 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
10:40:43 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
10:40:44 <ski> ihatehex : ^ that's one example of using Hoogle to search for a function with a certain type (which you hope has the behaviour you're looking for)
10:40:51 <merijn> dav: It is not
10:40:54 <dav> mauke: can I tell cabal to assume handa-gdata's dependencies are present and to proceed?
10:40:55 <ski> in this case `catMaybes' fits the bill
10:41:06 <ski> @hoogle+
10:41:06 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
10:41:06 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
10:41:07 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
10:41:11 <mauke> dav: no idea
10:41:14 <ihatehex> you can never have enough cats.
10:41:16 <merijn> dav: If conduit needs the URI parsing from network it can't accept network 2.6 without depending on network-uri
10:41:23 <dav> merijn: http-conduit-2.1.5 installed just fine
10:41:30 <mauke> this is why I don't like upper version bounds
10:41:38 <ski> can be used to see more alternative from Hoogle's search (not often that useful, unless Hoogle first lists stuff you know you're not interested in)
10:41:41 <jmct> does anyone know if criterion forces GCs between runs?
10:42:02 <mauke> dav: oh, maybe you can constraint network to an older version
10:42:07 <mauke> *constrain
10:42:41 <asdfsf> We need a Haskell to java converter
10:42:49 <asdfsf> so I cna program in Haskell at my new job
10:42:53 <mauke> that's called a compiler
10:43:03 <dav> merijn, mauke - this is what I actually care to install: http://paste.debian.net/132371/ -- what would you suggest?
10:43:19 <asdfsf> mauke: well it has to produce somewhat nice code
10:43:22 <clrnd> no, converter so workmates can read the java
10:43:27 <clrnd> :P
10:43:31 <asdfsf> since I need to check it in as source
10:43:47 <asdfsf> yes, clrnd got it
10:43:53 <dav> asdfsf: look up frege
10:44:02 <Hijiri> @hoogle Ord b => (a -> b) -> [a] -> a
10:44:02 <lambdabot> GHC.Exts sortWith :: Ord b => (a -> b) -> [a] -> [a]
10:44:02 <lambdabot> Data.Generics.Schemes everywhere :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
10:44:02 <lambdabot> Data.Generics.Schemes everywhere' :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
10:44:47 <asdfsf> problem: you want to hide a function from getting exported. but then you cannot test it. you can only test it by testing the function that calls that function.
10:44:58 <asdfsf> can you get around module hiding for testing purposes?
10:45:20 <EvanR> dont hide, just put it in an internal module
10:46:21 <chrisdone> ski: ok, here's a dumb attempt:
10:46:21 <chrisdone> λ> fmap interpret (readIORef translated_ex)
10:46:21 <chrisdone> ["(\\x -> (\\y -> x * y)) 5 7","(\\y -> 5 * y) 5 7","5 * 7"]
10:46:51 <lpaste> chrisdone pasted “Reducing steps” at http://lpaste.net/114511
10:48:48 <chrisdone> ski: the "show" are a hack here, rather it should substitute the textual representation of that part of the tree, i think…
10:49:18 <ski> chrisdone : hm, why "reduce it by one step (breadth first)" specifically ?
10:49:20 <chrisdone> ski: the idea is every node that gets forced triggers an update in a stream of patches
10:49:51 <dav> merijn, mauke: I think I managed to trick it but unfortunately that didn't work out :( http://paste.debian.net/132375/
10:49:53 <chrisdone> ski: well, it can be a stream of reductions, like this, i suppose
10:50:18 <ski> chrisdone : it could be nice to have a setting that omits the intermediate step of expanding `f' to `\x -> x*x', at least if `f' was defined like `f x = x*x' instead of `f = \x -> x*x'
10:50:20 <chrisdone> ski: i was just trying to put enough restriction on it to say it should be "valid program in -> valid program out"
10:51:11 <chrisdone> ski: i suppose that could be a configuration option, yeah. sometimes you want to see that stuff, sometimes not
10:51:13 <ski> chrisdone : `(\y -> 5 * y) 5 7' looks wrong
10:51:33 <chrisdone> ah, that's just my manual position info messed up
10:51:43 <chrisdone> it should replace also the '5'
10:51:56 <chrisdone> i dunno whether this patch approach makes sense or not, just considering it
10:52:24 <houshuang> Getting some weird ghc error about "  Failed to load interface for ‘Data.Frame.Internal’", when doing exactly the same import works perfectly in ghci? http://lpaste.net/114512
10:53:07 <ski> chrisdone : "the idea is every node that gets forced triggers an update in a stream of patches" -- yeah, so i'd expect it to expand in the order things are forced
10:53:21 <chrisdone> ski: it's easy to spit out every node that gets forced, but reconsituting that back into its original source representation is the good stuff, and seems subtle to get right
10:53:52 <chrisdone> ski: right
10:54:06 <red_> bird's book is bloing my mind .. anyone have a good resource on equational reasoning in haskell that helped them?
10:55:05 <ski> chrisdone : also, after forcing the top node of the expression (and all the steps required to finish that), you might want to continue with forcing some of the children in some order (e.g. in the argument order, which would be used with a derived `Show') -- possibly inserting some indication when starting a new "force-chain" like this
10:55:57 <chrisdone> ski: you mean to get a full deepseq'd evaluation of of the whole thing?
10:56:12 <ski> well, possibly
10:56:21 <ski> like you'd get if you `show'ed the top expression
10:56:47 <ski> but this could be an option. otherwise only forcing the top node
10:56:52 <chrisdone> right
10:57:30 <ski> also, for abstract stuff like arrays, you presumably want to output them in the `array ...' format used by `Show'
10:58:42 <ski> @let tabulate :: Ix i => (i,i) -> (i -> e) -> Array i e; tabulate ix f = listArray ix [f i | i <- range ix]
10:58:44 <lambdabot>  Defined.
10:58:48 <chrisdone> ski: right, and fromList etc for the others
10:59:02 <ski> > tabulate (0,9) $ \i -> i^2
10:59:03 <lambdabot>  array (0,9) [(0,0),(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81)]
11:00:32 <chrisdone> ski: so it seems like there are a few things in (let's say desugared) haskell that are ever actually forced. we've got functions in application position: *f* x y, we've got case expressions: case *e* of …, and of course `seq` and strict functions like (+)
11:00:45 <chrisdone> ski: and that it's at these locations where you need to have some awareness of surrounding nodes
11:00:56 <chrisdone> e.g. (case e of …)
11:01:22 <chrisdone> when e is forced, then you know it's time to replace the whole (case e of …) with whatever the value of the matching case alt yields (put simply)
11:01:56 <ski> chrisdone : another thing which could be good as an option : add some kind of notation for "focusing" a subexpression, which will explain why a particular subexpression is being forced
11:02:03 <EvanR> chrisdone: unless the case is just irrefutable patterns
11:02:19 <chrisdone> EvanR: then `e' will not be forced
11:02:41 <ski>      {take 2 (map (^ 2) [0 ..])}
11:02:57 <ski>   =  {take 2 {map (^ 2) [0 ..]}}
11:03:03 <ski>   =  {take 2 {map (^ 2) {[0 ..]}}}
11:03:22 <ski>   =  {take 2 {map (^ 2) (0 : [1 ..])}}
11:03:39 <ski>   =  {take 2 (0 ^ 2 : map (^ 2) [1 ..])}
11:03:58 <ski>   =  0 ^ 2 : take 1 (map (^ 2) [1 ..])
11:04:02 <ski> something like that
11:04:31 <chrisdone> ahh, that's when taking the head
11:05:23 <ski> the point being to show that we're forcing `[0 ..]' because it's wanted by `map (^ 2) [0 ..]' which is forced because it's wanted by `take 2 (map (^ 2) [0 ..])'
11:06:01 <ski> for briefness, you could (option ?) don't show the forcing of stuff that's already in WHNF (like `2' above)
11:06:48 <ski> chrisdone : another thing to ponder : how to handle `let' and `where'
11:07:07 <chrisdone> ah, i get the focusing idea
11:07:31 <chrisdone> yeah, if it was lisp one could perhaps replace lets with lambdas
11:07:32 <ski> in case a `let'-bound variable is used more than once, it's probably as good to keep the `let', so show the sharing of forcing
11:07:34 <dav> cabal help requested: http://paste.debian.net/132371/ -- any ideas on what to do to get this package to install?
11:07:45 <chrisdone> in this case it seems the let's must remain until the `in …` part is done
11:08:04 <dcoutts> dav: try --constraint='network < 2.6'
11:08:09 <ski> also, `where's should probably get translated to `let's when expanding function calls with `where's ..
11:08:25 <dcoutts> dav: and/or --constraint='network < 2.6' --constraint='network-uri < 2.6'
11:08:38 <ski> however, `let's should probably (?) be floated and joined together at the top (is that good ?)
11:08:47 <benzrf> edwardk: hey can u answer my question[s] about generalized free monoids
11:08:58 <ski> so, perhaps one should syntactically make that distinct, by using `where' notation for this "heap", instead
11:09:02 <chrisdone> ski: floated and joined at the top?
11:09:11 <ski> i mean like
11:09:26 <dav> dcoutts: thanks. --force-reinstalls ?
11:09:40 <dcoutts> dav: depends on what it'll break
11:09:42 <WigglesMcMuffin> Is it possible to do compound truth equations in Haskell? Something akin to A ^ B V ~(A ^ B)?
11:10:21 <benzrf> WigglesMcMuffin: you may want Coq
11:10:22 <benzrf> or not
11:10:25 <benzrf> WigglesMcMuffin: what's the use case
11:10:31 <WigglesMcMuffin> (i.e. true/true == true and false/false == true)
11:10:32 <dav> dcoutts: http://paste.debian.net/132376/ - looks pretty safe to me?
11:10:33 <benzrf> WigglesMcMuffin: is this about proofs or boolean comparisons
11:10:56 <WigglesMcMuffin> benzrf: boolean comparisons
11:11:10 <benzrf> WigglesMcMuffin: ah
11:11:15 <benzrf> yes, you can nest expressions in haskell :b
11:11:28 <benzrf> > 3 * (4 - 1)
11:11:30 <lambdabot>  9
11:11:30 <ski> WigglesMcMuffin : `a == b'
11:11:36 <WigglesMcMuffin> Then perhaps it's the syntax? I'm used to && || and !
11:11:38 <ski> WigglesMcMuffin : where `a' and `b' are booleans
11:11:58 <dcoutts> dav: yep, though you may then want to unregister the broken packages to avoid clutter
11:12:07 <josephle> :t \a b -> (a && b) || not (A && B) -- you mean like this?
11:12:08 <lambdabot> Not in scope: data constructor ‘A’
11:12:09 <lambdabot> Not in scope: data constructor ‘B’
11:12:10 <statusfailed> WigglesMcMuffin: (&&) and (||) exist
11:12:13 <josephle> oops
11:12:14 <saep> > True && False || True && not False
11:12:15 <lambdabot>  True
11:12:52 <WigglesMcMuffin> So it's not instead of !?
11:12:53 <dav> dcoutts: more errors :( http://paste.debian.net/132377/
11:12:56 <ski> > (2 > 3) == (2 - 1 >= 3)  -- WigglesMcMuffin, here `A' is `2 > 3' and `B' is `2 - 1 >= 3'
11:12:57 <lambdabot>  True
11:13:17 <statusfailed> WigglesMcMuffin: I had a really hard time reading that sentence :p
11:13:21 <statusfailed> WigglesMcMuffin: and yes
11:13:45 <lf94> multi/div/add/sub have higher precedence over binary operators?
11:13:47 <WigglesMcMuffin> statusfailed: Haha, "So it's `not` instead of `!`?"
11:13:52 <ski> lf94 : yes
11:13:56 <lf94> never thought of using them like that
11:14:12 <lf94> (2-1 >= 3) seems a little silly though
11:14:12 <WigglesMcMuffin> Thanks guys
11:14:23 <statusfailed> WigglesMcMuffin: good luck :)
11:14:25 <lf94> (1 >= 3) is better, but even then that is silly
11:14:32 <ski> lf94 : well, for integers, `m > n' is equivalent to `m - 1 >= n'
11:14:35 <lf94> Just put False B)
11:14:59 <ski> it's just an example, and had to be closed for lambdabot to evaluate it :)
11:15:34 <lf94> `m > n' is equivalent to `m - 1 >= n'
11:16:04 <lf94> coolio
11:16:15 <ski> lf94 : not for rationals or reals, though
11:16:29 <lf94> 10 > 10, 9 >= 10; 11 > 10, 10 >= 10
11:16:42 <ski> lf94 : it's also equivalent to `m > n + 1' (obviously)
11:16:45 <lf94> ski: what is the rational behind using m-1 > n
11:16:57 <lf94> >= n*
11:17:04 <ski> lf94 : i'm not sure what you're asking ?
11:17:11 <lf94> why would you ever use those variations
11:17:34 <ski> it's just an example of two boolean expressions, to compare i they're equivalent, in a specific case
11:17:52 <ski> lf94 : when doing math, sometimes you have `>', but want `>=', or vice versa
11:18:02 <ski> so you can use the above to rewrite
11:18:12 <lf94> In math you have >= and > though
11:18:17 <ski> i know
11:18:48 <ski> i mean that sometimes you have an assumption phrased in terms of `>', but want it rephrased in terms of `>=' (but still meaning the same thing)
11:19:25 <fragamus> I need a function in the IO monad which is semantically equivalent to the mv command. It looks like the renaming facilities in System.Directory don't support mv's polymorphism with respect to files and directories
11:21:05 <lf94> ski: ah, ok
11:21:08 <chrisdone> ski: i'll think about it some more. i want to avoid having to implement name resolution. for (\x -> x * x) (foo bar) => (foo bar) * (foo bar) i don't want to have to resolve the `x' to produce the `(foo bar)`
11:21:15 <chrisdone> gotta go, see you later
11:21:25 <EvanR> theres rename in the posix package
11:21:34 <EvanR> :t rename
11:21:35 <lambdabot> Not in scope: ‘rename’
11:21:41 <EvanR> rename :: FilePath -> FilePath -> IO ()
11:28:47 <statusbot> Status update: One of the disks in our host RAID array has been lost, meaning we'll be moving www.haskell.org immediately. You will probably see disrupted service in the mean time. -- http://status.haskell.org
11:38:23 <benzrf> @let newtype KEndo m a = KEndo {runKEndo :: a -> m a}
11:38:24 <lambdabot>  Defined.
11:38:32 <benzrf> @let instance
11:38:32 <lambdabot>  Parse failed: Parse error: EOF
11:38:33 <benzrf> er
11:39:28 <benzrf> @let instance Monad m => Monoid (KEend m a) where mempty = KEndo return; mappend = (KEndo .) . (<=<)
11:39:29 <lambdabot>  .L.hs:175:31: Not in scope: type constructor or class ‘KEend’
11:39:36 <benzrf> @let instance Monad m => Monoid (KEndo m a) where mempty = KEndo return; mappend = (KEndo .) . (<=<)
11:39:37 <lambdabot>  .L.hs:177:31:
11:39:37 <lambdabot>      Couldn't match type ‘b0 -> m a’ with ‘KEndo m a’
11:39:37 <lambdabot>      Expected type: KEndo m a -> KEndo m a -> a -> m a
11:39:37 <lambdabot>        Actual type: (b0 -> m a) -> (a -> m b0) -> a -> m a
11:39:37 <lambdabot>      Relevant bindings include
11:39:40 <benzrf> aw
11:40:07 <benzrf> @let instance Monad m => Monoid (KEndo m a) where mempty = KEndo return; mappend (KEndo f) (KEndo g) = (KEndo (f <=< g))
11:40:08 <lambdabot>  Defined.
11:40:10 <benzrf> neat.
11:40:26 * hackagebot tidal 0.4.21 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.4.21 (AlexMcLean)
11:42:18 <ski>      {let x = 3; f y = z * z - x where z = y + 1 in f (f 2)}
11:43:07 <EvanR> has anyone looked at flow static typing for javascript
11:43:32 <ski>   =  {f (f 2)}
11:43:39 <ski>        where x = 3
11:43:46 <ski>              f y = z * z - x
11:43:50 <ski>                where z = y + 1
11:44:23 <ski>   =  {z0 * z0 - x}
11:44:41 <ski>        where z0 = f 2 + 1
11:44:51 <ski>              ...
11:45:12 <ski>   =  {{z0} * z0 - x}
11:45:18 <ski>        where ...
11:45:30 <ski>   =  {{z0} * z0 - x}
11:45:40 <ski>        where z0 = {f 2 + 1}
11:45:48 <ski>              ...
11:45:54 <ski>   =  {{z0} * z0 - x}
11:46:12 <ski>        where z0 = {{f 2} + 1}
11:46:14 <mads-> EvanR: flow static typing?
11:46:28 <ski>              ...
11:46:29 <josephle> EvanR: does flow make the types mandatory or optional/gradual?
11:46:37 <ski>   =  {{z0} * z0 - x}
11:47:08 <ski>        where z0 = {{z1 * z1 - x} + 1}
11:47:23 <ski>              z1 = 2 + 1
11:47:24 <ski>              ...
11:47:35 <ski>   =  {{z0} * z0 - x}
11:47:46 <ski>        where z0 = {{{z1} * z1 - x} + 1}
11:47:53 <ski>              z1 = {2 + 1}
11:47:54 <ski>              ...
11:49:26 <ski> chrisdone : and so on, i think you get the point. whenever `z1' here is forced, we replace `{z1}' by its value -- and of course, many of the steps above would be elided unless you ask to see all the forcing focusing `{...}'
11:49:30 <EvanR> josephle: its optional gradual, by the virtue of you must run a checker to get a report of what it things may be wrong, you cant stop a browser from running the code
11:49:47 <EvanR> flowtype.org
11:49:53 <josephle> but if you run it, does everything have to be typed?
11:50:07 <EvanR> it runs on unmodified js
11:50:18 <ski> chrisdone : perhaps it would be better to use something like <http://en.wikipedia.org/wiki/Structured_derivations> in monochrom used in "Lazy Evaluation of Haskell" <http://www.vex.net/~trebla/haskell/lazy.xhtml>, for the nested reductions, though
11:50:22 <EvanR> and allows type annotations
11:51:07 <josephle> hmmm, in my experience gradual means "assume unannotated types are 'any'/'dynamic'"
11:51:08 <mads-> EvanR: looks pretty exciting
11:51:31 <EvanR> josephle: theres an any annotation, which, if you use it, basically nullifies the point of the checker
11:51:33 <ski> chrisdone : also, one would need to decide how to handle guards (and maybe `if' and `case' with the same methods) -- to show that forcing an expression requires to check a guard to be able to decide which defining equation to use
11:51:46 <josephle> EvanR: okay, that makes sense
11:52:06 <EvanR> josephle: i havent used this but i was wondering if anyone here has and has thoughts
11:52:11 <josephle> I mean, it nullifies the point of the checker for that specific scope
11:52:32 <ski> chrisdone : perhaps one could use e.g. `foo (x * 2) | x * 2 > 0' as an expression in case `foo' is defined like `foo n | n > 0 = ..n..'
11:52:40 <EvanR> for that variable, it causes everything to unify with everything
11:52:47 <josephle> yes
11:52:48 <EvanR> it seems
11:53:34 <ski> (and then `blah | True' would reduce to `blah. and a definition `foo | test0 = result0 | test1 = result1' would be seen as shorthand for `foo | test0 = result0; foo | test1 = result1')
11:53:49 <josephle> I like that flow is just a typechecker
11:54:29 <ski> chrisdone : for pattern-matching, it would be nice to be able to disable showing the individual steps in the expansion to `case' (or maybe `if' in some cases ?)
11:55:19 <ski> chrisdone : for `if' and `case', one could of course insert them into the expression that's being reduced. but often it would read nicer if one could avoid doing that, in some useful way
11:56:42 <ski> chrisdone : re "i want to avoid having to implement name resolution", i assume that by this you don't want to keep around local variables in `where' and `let', as i sketched. even so, one would need to make a choice whether to evaluate as if we're in call-by-name. or still do call-by-need, while eliding showing the intermediate local variables
12:00:22 <ski> chrisdone : regarding such bindings. one'd want to have a GC rule (probably not as a separate step), that removes unused local variable bindings. preferably as soon as possible. see "Abstract Models of Memory Management" by Greg Morrisett,Matthias Felleisen,Robert Harper in 1995 at <http://www.cs.cmu.edu/~rwh/papers/gc/fpca95.pdf> for an operational semantics using an outermost `let' for a heap, wrapping the expression to be evaluted
12:00:41 <ski> chrisdone : cut off : "... for an operational semantics using an outermost `let' for a heap, wrapping the expression to be evaluted"
12:02:36 <clrnd> what's the closest I can get to a `let` binding in Postgres?
12:02:48 <clrnd> I suspect WITH can help but it's confusing
12:03:22 <mauris> heya. i'm having trouble with non-buffering getChar on windows, and apparently this is a six year-old (!) GHC bug
12:03:59 <mauris> i've found a workaround that calls getch in conio.h, but i'm writing some networking code, and need Handle -> IO (), not IO ()
12:04:06 <mauris> err IO Char
12:04:24 <ChristianS> mauris: why do you need getChar?
12:04:47 <ChristianS> mauris: char-by-char IO is rarely a good idea
12:05:14 <EvanR> getChar implicitly is decoding utf8 (or whatever it is on your system) which could crash
12:05:17 <mauris> i'm writing a telnet server that interacts on keypresses (press 'q' to quit, not 'q-newline')
12:05:24 <benzrf> :t over
12:05:24 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
12:05:26 * hackagebot json-schema 0.7.3.0 - Types and type classes for defining JSON schemas.  http://hackage.haskell.org/package/json-schema-0.7.3.0 (ErikHesselink)
12:06:35 <ski> EvanR : is that related to <https://web.archive.org/web/20140725093000/http://www.haskell.org/ghc/docs/latest/html/users_guide/defer-type-errors.html>, and to various papers (Racket, Wadler, &c.) about mixing untyped and typed code (possibly with contracts), and correctly assigning blame in case a contract breaks ?
12:06:38 <EvanR> mauris: for literally doing what youre talking about, theres hGet :: Handle -> Int -> IO ByteString
12:07:36 <yyttr3> Why is the haskell platform down?
12:07:53 <ski> <statusbot> Status update: One of the disks in our host RAID array has been lost, meaning we'll be moving www.haskell.org immediately. You will probably see disrupted service in the mean time. -- http://status.haskell.org
12:08:00 <EvanR> ski: it doesnt appear that this thing has any contracts, nor does it seem to be able to correctly assign any blame when the program still crashes at runtime
12:08:09 <mauris> EvanR: i'll try that
12:08:57 <ski> EvanR : the contracts stuff is sortof an extension of type checking. you can imagine assigning blame only for when types are violated
12:09:07 <mauris> EvanR: should it be non-buffering by default?
12:09:16 <ChristianS> yyttr3: haskell.org went down for surprise maintenance, you can join #haskell-infrastructure for updates
12:09:29 <EvanR> mauris: yeah, if you want to get a single Q without a newline
12:09:35 <EvanR> its not the default though
12:09:36 <alphonse23_> join #freebsd
12:09:39 <yyttr3> Thank you
12:10:03 <ChristianS> yyttr3: or check https://status.haskell.org/
12:10:07 <fragamus> :t fromJust
12:10:08 <lambdabot> Maybe a -> a
12:10:08 <ski> EvanR : and then there's a difference between raising a violation in case you convert from one type to a distinct type, but back again before you do anything with it; and only raising a violation if you actually try to *use* a value at the wrong type
12:11:15 <EvanR> ski: it seems to have a mixed type to handle cases where you will do a dynamic check, and any for cases where for some reason a check will not be performed and you will possibly crash at runtime
12:11:15 <mauris> @hoogle Word8 -> Char
12:11:16 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
12:11:16 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
12:11:16 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
12:11:30 <mauris> haha unsafeCoerce clearly yes
12:11:49 <EvanR> it also doesnt have any way to express the behavior of member lookup or array indexing (possibly undefined)
12:11:50 <mauke> :t chr . fromIntegral
12:11:51 <lambdabot> Integral a => a -> Char
12:12:07 <EvanR> hoogle is really helpful recommending unsafeCoerce
12:12:15 <EvanR> but in this case it is right?
12:12:21 <mauris> what i probably want is Data.ByteString.Char8 instead
12:12:23 <ski> EvanR : "mixed type" meaning ?
12:12:28 <fragamus> i think haskell.org might be down
12:12:48 <ski> fragamus : see what statusbot,ChristianS said above
12:12:54 <adamse> fragamus: its super down, a disk in raid crashed, https://status.haskell.org/
12:12:58 <EvanR> ski: a variable which has a dynamic type, you can assign anything to it
12:12:59 <indiagreen> mauris: but Data.ByteString.ByteString and Data.ByteString.Char8.ByteString are synonyms
12:13:09 <EvanR> ski: but you cant use it anywhere, i think
12:13:27 <ski> EvanR : ok
12:13:30 <ski> EvanR : hm, why ?
12:13:31 <sinelaw> halwa
12:13:43 <mauris> indiagreen: i mean i should be using Data.ByteString.Char8.head instead of Data.ByteString.head and some other function
12:13:50 <indiagreen> ah, yes
12:14:05 <EvanR> ski: well, i think you can use it, only in a type checking case
12:14:30 <EvanR> why youd want to write code like this i do not know
12:15:15 <mauris> EvanR: nope, it's also buffering like getChar :<
12:15:27 <EvanR> mauris: well, you have to enable no buffering
12:15:46 <EvanR> :t hSetBuffering
12:15:47 <lambdabot> Not in scope: ‘hSetBuffering’
12:15:51 <EvanR> something like that
12:16:38 <mauris> EvanR: i did
12:16:42 <athan> With higher-order logic unification, references are made to "lambda terms". Would those be higher-kinded terms, in haskell-speak?
12:16:53 <mauris> i'm assuming it's this https://ghc.haskell.org/trac/ghc/ticket/2189
12:16:57 <EvanR> mauris: what happens, it blocks?
12:17:01 <mauris> yeah
12:17:17 <EvanR> hGet 1 h ?
12:17:33 <EvanR> oh this is STDIN on windows
12:17:42 <mauris> h 1 but yeah
12:19:41 <Yuras> mauris: probably hGetSome?
12:20:22 <EvanR> no i think hes screwed, after reading this ticket
12:21:12 <EvanR> 1. setting a console handle to unbuffered mode breaks ghci input with cmd.exe and cygwin
12:21:30 <EvanR> among others
12:22:40 <EvanR> mauris: well so much for ghc's ancient windows console support, off the top of my head glfw-b should let you get keypresses, though im not sure what kind of program youre writing
12:23:01 <EvanR> maybe ncurses?
12:23:57 <athan> ):
12:24:06 <EvanR> well ncurses on windows doesnt seem to be an existing concept
12:24:40 <mauris> eek :( i think i'll just install a linux vm to develop and run this thing on, honestly
12:24:42 <marchelzo_> well there is pdcurses
12:25:15 <EvanR> thats probably your best bet in general, basically every project (except windows software)
12:25:45 <merijn> dcoutts: ping?
12:26:33 <marchelzo_> i had trouble getting any of the curses bindings libraries for haskell to build in windows though
12:27:21 <EvanR> using unbuffered stdin seems like a fiddly really old thing to do
12:27:33 <EvanR> only a terminal emulator would dare try!
12:27:53 <ParahSailin_> is there a reason aeson doesnt use TH for all the tuple instances?
12:29:39 <merijn> ParahSailin_: TH limits the usability
12:29:52 <merijn> ParahSailin_: There is no TH for cross-compilation and ghcjs yet
12:30:12 <EvanR> i think aeson does use TH though
12:30:18 <ParahSailin_> template-haskell is a prereq in the .cabal though
12:30:33 <btbngr> hmm. any idea when haskell.org will be back online?
12:30:54 <ParahSailin_> am i just seeing cached pages on haskell.org or is it up?
12:31:37 <EvanR> backuporjustcached.com
12:32:08 <athan> There should be if-statements in urls...
12:36:30 <geekosaur> btbngr, check status.haskell.org, otherwise no.
12:36:38 <geekosaur> but: apparently download.haskell.org is now a thing
12:36:55 <btbngr> geekosaur: ah, thanks
12:37:19 <ocfx> anyone know of a mirror for  the platform on windows?
12:37:43 <ocfx> nvm
12:37:45 <ocfx> you just gave one
12:38:02 <ocfx> thx geekosaur
12:38:14 <merijn> geekosaur: All of haskell.org should be moving to be cached through cloudflare, afaik
12:38:25 <merijn> (Well, the exception being the git repos)
12:45:37 <dfeuer> Does anyone happen to understand Data.Sequence.applicativeTree? I can't seem to make head or tail of what it's even *supposed* to do.
12:49:04 <dfeuer> I think I understand replicateA, but the "generalization" applicativeTree is very mysterious. To begin with, I don't understand the meaning of the mSize parameter.
12:49:25 <dmj`> is the hedis guy here?
12:49:43 <EvanR> dfeuer: theres a comment there in the source for it
12:50:38 <dfeuer> EvanR, I've read it. I just don't understand it. What is the size of a piece of a tree in this context? In particular, I don't see how that makes any sense given the type signature.
12:50:55 <dfeuer> Evidently, it must. But I just don't see how.
12:51:06 <Gurkenglas> Running https://www.fpcomplete.com/user/Gurkenglas/angemathe gives "The code threw an exception : SomeAsyncException: stack overflow". What gives?
12:51:24 <dfeuer> Gurkenglas, a stack overflow, clearly.
12:52:17 <dfeuer> Gurkenglas, what on Earth is that? It fills my screen with messages about creating a project or something.
12:52:33 <Gurkenglas> fpcomplete does that. Let it run for a few seconds
12:53:38 <Gurkenglas> (Replacing the main line with the commented-out main line produces usable output)
12:53:54 <EvanR> dfeuer: mSize is a number divisible by 3 ;)
12:53:59 <Gurkenglas> Oh wait, I should probably tell you that my question is about Aufgabe1_2
12:54:14 <dfeuer> No, Gurkenglas, after a few seconds, it uses 100% CPU.
12:54:27 <Gurkenglas> Weird, it works for me. Anyone else using fpcomplete?
12:54:40 <dfeuer> EvanR, that's ... not so helpful?
12:54:56 <dfeuer> But maybe you're on the way to understanding it?
12:55:41 <EvanR> seems to be an operation which replicates a tree
12:55:52 <EvanR> in applicative style
12:55:56 <Gurkenglas> I googled the whole error line, when that didnt yield quick results I resorted to this channel. I probably should have googled something like "haskell debugging stack overflows" first
12:56:00 <dfeuer> EvanR, the big weirdness is that I don't understand how (f a) can be producing a "piece of a FingerTree" of a fixed size when f is an arbitrary Applicative.
12:56:05 <dfeuer> What do they really mean?
12:56:44 <EvanR> the first argument to Deep is an Int, which is where these numbers end up
12:57:10 <EvanR> that might be what size is referring to
13:00:15 <EvanR> dfeuer: the Deep takes an Int, two Digits, and a FingerTree. the way this applicative tree function is written, this Deep function (with size partially applied) is being lifted into the applicative f
13:00:46 <EvanR> so its not building a FingerTree, its building a f FingerTree
13:00:53 <dfeuer> Hmm.
13:01:33 <sshine> why is order of the accumulator function arguments different for foldl/foldr?
13:01:34 <EvanR> so the applicative can control the final form of the tree
13:02:04 <Gurkenglas> Is there a (a->String) alternative to show that combines well with trace?
13:02:24 <t4nk166> Hello everybody
13:02:31 <dfeuer> EvanR, this is all slightly over my head. But given that it produces an f (FingerTree a), how does it ever end up using n*mSize?
13:02:33 <mauke> Gurkenglas: what's wrong with show?
13:02:34 <jle`> hi t4nk166 !
13:02:42 <clrnd> hi
13:02:57 <Gurkenglas> mauke, the piece of code where I want to see what I'm doing is general enough that I don't have show
13:02:57 <clrnd> :t traceShow
13:02:58 <lambdabot> Not in scope: ‘traceShow’
13:03:07 <benzrf> hello t4nk166
13:03:17 <t4nk166> I am stuck with a small bit of haskell. Is this an appropriate place to ask?
13:03:20 <EvanR> dfeuer: i think the client code writing the tree builder would have to use it, it would be available there
13:03:21 <geekosaur> if you do not have show then you can't do very much
13:03:28 <clrnd> t4nk166, yes
13:03:30 <jle`> it's not an appropriate place to ask if you can ask, but it's definitely an appropriate place to ask :D
13:03:49 <mauke> Gurkenglas: hmm, that would require breaking type safety
13:04:03 <clrnd> sshine, I think's because one takes left-assoc funcs and the other right ones
13:04:05 <Gurkenglas> Doesn't Debug.Trace do that already?
13:04:16 <dfeuer> Breaking type safety is okay.
13:04:58 <Gurkenglas> clrnd, that also requires Show
13:05:22 <clrnd> hajam
13:05:24 <Gurkenglas> Hmm, maybe unsafeCoerce.
13:05:24 <merijn> Gurkenglas: You can't show an non-showable data, no
13:05:25 <EvanR> dfeuer: so the function itself is making a "replicateA" which produces a finger tree instead of a list, whatever that means ;)
13:05:36 <merijn> Gurkenglas: unsafeCoerce == segfaults
13:05:40 <Gurkenglas> k
13:05:48 <EvanR> :t replicateA
13:05:49 <lambdabot>     Not in scope: ‘replicateA’
13:05:49 <lambdabot>     Perhaps you meant one of these:
13:05:49 <lambdabot>       ‘Seq.replicateA’ (imported from Data.Sequence),
13:05:59 <EvanR> :t Seq.replicateA
13:06:00 <lambdabot> Applicative f => Int -> f a -> f (Seq.Seq a)
13:06:05 <EvanR> nevermind, instead of a Seq
13:06:09 <Gurkenglas> @hoogle a -> Maybe b
13:06:09 <lambdabot> Prelude Just :: a -> Maybe a
13:06:10 <lambdabot> Data.Maybe Just :: a -> Maybe a
13:06:10 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
13:06:18 <mauke> can you even get at the appropriate class dictionaries, given a runtime type representation?
13:06:28 <t4nk166> I'm trying to write a program that generates the infinite list of prime. primes = 2:3:[ x | x <- [4..], null (divisibleBy x (takeWhile (\prime -> prime < squareRoot x ) primes))  ].
13:06:36 <benzrf> mauke: yes, it's easy!
13:06:37 <benzrf> check this out:
13:06:53 <benzrf> @let monoidDict = (mappend, mempty, mconcat)
13:06:54 <lambdabot>  Defined.
13:06:57 <benzrf> mauke: :b
13:07:02 <mauke> huh?
13:07:06 <merijn> mauke: With an extistential you can
13:07:11 <Gurkenglas> Is there a function that converts applies Just to any Int and turns anything other than an Int into a Nothing?
13:07:14 <mauke> merijn: no, without writing code
13:07:16 <Gurkenglas> -converts
13:07:16 <benzrf> oh wait i misunderstood
13:07:17 <benzrf> rats
13:07:20 <LordBrain> haskell.org down?
13:07:22 <merijn> mauke: Then not afaik
13:07:24 <clrnd> t4nk166, hajam
13:07:30 <t4nk166> I have also written my squareRoot function which works by successive approximation.
13:07:33 <jle`> Gurkenglas: any Int?
13:07:46 <Gurkenglas> jle', like (a->Maybe Int)
13:07:47 <jle`> can you state the type of your function?
13:07:56 <jle`> the function you want
13:08:00 <merijn> Gurkenglas: You might be able to use cast, but that requires "Typeable a"
13:08:02 <mauke> Gurkenglas: trivial with a Typeable constraint
13:08:10 <mauke> probably not possible without
13:08:27 <jle`> foo :: Typeable a => a -> Maybe Int
13:08:32 <Gurkenglas> Dang, don't want to put Typeable everywhere in my code just for a trace
13:08:34 <EvanR> Gurkenglas: this is like Data.Dynamic, which uses Typeable
13:08:38 <t4nk166> I get this error when running it     No instance for (Ord a0) arising from a use of ‘squareRoot’     The type variable ‘a0’ is ambiguous     Relevant bindings include       prime :: a0 (bound at a4.hs:20:65)       x :: a0 (bound at a4.hs:20:20)       primes :: [a0] (bound at a4.hs:20:1)     Note: there are several potential instances:       instance Integral a => Ord (GHC.Real.Ratio a)         -- Defined in ‘GHC.Real’     
13:08:47 <jle`> Gurkenglas: if not, then how would it even work?
13:08:52 <EvanR> Gurkenglas: for trace you usually just print out a string
13:09:04 <fds4345> anyone know if its possible to compile an expression and then parse it back to haskell using TH?
13:09:37 <clrnd> t4nk166, try pasting your code in lpaste.net
13:09:37 <jle`> t4nk166: try giving type signatures to various things
13:09:37 <LordBrain> compile it to machine code?
13:09:46 <jle`> in particular, prims :: ...?
13:10:02 <Gurkenglas> My problem is that my (stabilize :: (a->a->Bool) -> [a] -> (Int, a)) apparently was stackoverflowing so I wanted to see the values, but it doesn't constrain the type
13:10:37 <fds4345> LordBrain: I want to take a block of code and return (block, hack_of_block)
13:10:40 <fds4345> hash*
13:10:48 <LordBrain> theoretically, even if you could uncompile something from machine code to haskell, it wouldn't be the haskell that went in what with all the optimizations.
13:11:03 <LordBrain> oh
13:11:24 <LordBrain> hash of hte haskell or hash of the binary?
13:11:50 <fds4345> so currently im trying with a QuasiQuoter, but you cant go String -> code.
13:12:05 <fds4345> hash of the literal haskell expression as a string
13:12:08 <t4nk166> clrnd, http://lpaste.net/114518
13:12:16 <LordBrain> yeah, i think something along those lines could work...
13:12:20 <merijn> fds4345: I would classify the difficulty of decompiling haskell as somewhere along the lines of "doable, but multimillion dollar project"
13:12:44 <fds4345> merijn: i mis-expressed, i just want to get the hash of a block of code using templatehaskell
13:12:50 <merijn> fds4345: What would you do with the hash of the block?
13:12:56 <Gurkenglas> Is it considered bad coding style if my code requires multiple lines of refactoring to do an inspection like that?
13:12:58 <dfeuer> EvanR, I think I *might* have figured it out—I think the type variable a is supposed to to represent some kind of tree piece, which is assumed to have the given size. Nothing about the type actually implies this.
13:12:59 <LordBrain> well he isn't really decompiling tho, it sounds to me, he means making a hash of the syntax tree prior to compilation
13:13:15 <fds4345> merijn: just need an "algorithm version" :)
13:13:56 <merijn> fds4345: ok, then a quasiquoter should be doable
13:14:36 <Peaker> merijn: I've had a loooong argument with Yuras on Reddit after the mailing chain
13:14:36 <Peaker> merijn: did you see my mail about doing it for all the cleanup handlers and not just for bracket's cleanup?
13:14:55 <fds4345> merijn: havnt found a way to take the function as a string and return the function.
13:14:56 <clrnd> t4nk166, you seem to have a lot of conflicting types, haskell has different types for Integers and Doubles for instance
13:15:03 <sinelaw> hey Peaker
13:15:13 <sinelaw> exception woes? :)
13:15:15 <LordBrain> could use that to sort of fake a Eq membership for functions, is that your idea fds4345 ?
13:15:21 <Peaker> sinelaw: hey, yeah
13:15:24 <EvanR> dfeuer: maybe that is how its used somewhere, but in that function itself, a can be anything
13:15:27 <Gurkenglas> merijn, unsafeCoerce also == segfaults if my function coerces its argument to int, and happens to only ever be called with ints?
13:15:54 <t4nk166> clrnd, Aha yes my final list has to be all of the same type right?
13:16:00 <Peaker> merijn: hey, btw :-)
13:16:13 <merijn> Peaker: Yes, I did
13:16:42 <merijn> I take it this means we "won"? If we wanna get this in base for 7.10 we need a patch by friday >.>
13:16:44 <Gurkenglas> (Can segfaults corrupt my disc or something, or do they merely crash the program?)
13:16:45 <dfeuer> EvanR, yes, I think the type signature is a *lie*. I think it sticks numbers into the size fields of the tree it builds based on the assumption that what you're sticking in are actually FingerTrees of the specified size. It's a disgusting lie.
13:16:56 <clrnd> t4nk166, not only that, but when you do `>= 0.00001` x has to be Float or Double, but when you do `mod x y` x and need to be from Integral
13:16:57 <merijn> Gurkenglas: Only crash the program
13:17:10 <mauke> Gurkenglas: a segmentation fault is a memory access error. the worst it can do is kill a running process
13:17:11 <clrnd> (Integral is a class that has Int and Integer among others)
13:17:12 <Gurkenglas> Ah well then, I'll just try stuff
13:17:15 <EvanR> dfeuer: thats weird
13:17:30 <dfeuer> EvanR, that's my best interpretation for now. I don't claim to *understand* it properly.
13:17:32 <merijn> Peaker: So I think this won't be in until 7.12, because I doubt there's an interest in making a backwards incompatible fix in base on a minor GHC version >.>
13:17:39 <dfeuer> But that's the only way I've come up to make any sense of it.
13:17:41 <EvanR> its an implementation detail though, right, this isnt a public function
13:18:00 <EvanR> dfeuer: you finally uncovered the disgusting lie, roll insanity
13:18:03 <clrnd> :t mod
13:18:04 <lambdabot> Integral a => a -> a -> a
13:18:13 <clrnd> :t (<= 0.0001)
13:18:13 <lambdabot> (Ord a, Fractional a) => a -> Bool
13:18:42 <merijn> dfeuer is at the point in his haskell carreer where he's looking around for the cavalry to save him, only to realise he is the cavalry :p
13:18:51 <Peaker> merijn: sure, I only care that it gets fixed at all, without urgency since my own code can use my own wrappers for Control.Exception
13:19:07 <fds4345> LordBrain: Nah, its just for a toy example I'm making
13:19:19 <fds4345> Illustrative purposes
13:19:25 <Yuras> Peaker: hi. I hope you didn't lose an interest yet :)
13:19:25 <dfeuer> EvanR, here's the funny thing: applicativeTree seems to be used only to implement replicateA. I'm guessing it was intended to be used to implement (*>), but someone forgot.
13:19:50 <Peaker> Yuras: Hey.. Haven't had much time to continue the arguments :)
13:19:57 <t4nk166> clrnd, What is wrong with my lambda (\prime -> prime < squareRoot x) ?
13:20:03 <Yuras> OK :(
13:20:24 <clrnd> t4nk166, there is nothing wrong with anything, I even did it work adding just a couple of types
13:20:44 <mauke> prime*prime < x
13:21:06 <clrnd> the thing is, squareRoot seems to want to return a Float so prime should be one too
13:21:06 <fds4345> ~.
13:21:45 <t4nk166> clrnd, We haven't quite covered types yet in class :( He said we can add them if we want to look ahead which I have done. Why does it need types?
13:22:04 <clrnd> t4nk166, because there are several conflicting operations between values
13:22:30 <clrnd> GHC can't infer if you want to use Int or Float because you are using Int-only operations along Float-only ones
13:22:36 <Peaker> Yuras: I think the disagreement was narrowed down: A) For some reason, you want hClose to always close the handle, even when it could provide strong exception safety?
13:23:09 <Peaker> Yuras: B) You believe it makes sense to reason about whether there's an interruptible operation in the cleanup - and then you'd uninterruptibleMask it. I believe you should just use uninterruptibleMask
13:23:10 <t4nk166> clrnd, why can you not do Int < Float?
13:23:21 <t4nk166> mauke, Very clever ;)
13:23:38 <mauke> :t (<)
13:23:39 <lambdabot> Ord a => a -> a -> Bool
13:23:44 <Peaker> Yuras: C) You believe that the way we think about and "handle" sync exceptions in cleanups is similar to the way we handle async ones
13:23:49 <mauke> t4nk166: because (<) always takes two values of the same type
13:24:02 <Peaker> Yuras: and finally, D) You believe bracket invariants are less important than unbounded blocking -- which I vehemently disagreee with
13:24:08 <EvanR> > (3 :: Int) < (4 :: Float)
13:24:09 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
13:24:09 <lambdabot>              with actual type ‘GHC.Types.Float’
13:24:35 <t4nk166> mauke, How come I can do 1.5 < 10 in the REPL?
13:24:43 <mauke> t4nk166: those are both of type Double
13:24:44 <EvanR> > 3 < 4 :: Maybe ()
13:24:45 <lambdabot>  Couldn't match expected type ‘Data.Maybe.Maybe ()’
13:24:45 <lambdabot>              with actual type ‘GHC.Types.Bool’
13:25:29 <t4nk166> mauke, Aha, Why is 10 a double? Is it promoted or is it just the default type for a number literal in ghci?
13:25:36 <clrnd> t4nk166, because GHC infers compatible types
13:25:46 <mauke> t4nk166: literals are polymorphic. they can be any numeric type
13:25:57 <clrnd> nono, written numbers will coerce to what they need to be to work, as longs as it is possible
13:25:59 <EvanR> > 3.14 :: Int
13:26:00 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Types.Int)
13:26:00 <lambdabot>    arising from the literal ‘3.14’
13:26:08 <mauke> t4nk166: 1.5 is a Double, (<) takes two values of the same type, so 10 must be a Double too
13:26:19 <clrnd> exactly
13:26:20 <red_> [1,2] -> [[],[1],[2],[1,2],[2,1]]  .. what library fcn is this? kinda like powerset
13:26:21 <Peaker> clrnd: except for the DMR
13:26:41 <Peaker> red_: filterM (const [False,True])
13:26:47 <Yuras> Peaker: A) - yes; B) - yes in most cases; C) - yes ; D) - no
13:26:50 <clrnd> gotta go, sorry t4nk166
13:26:52 <mauke> Peaker: that won't give you [2,1]
13:26:55 <Peaker> red_: actually, not exactly because of the order, yeah
13:27:13 <red_> i'm trying to write it as a single list comprehension
13:27:27 <red_> (except for the empty pattern)
13:27:42 <Peaker> red_: you probably need recursion too
13:28:10 <t4nk166> clrnd, mauke, Thank you both very much :)
13:28:23 <red_> Peaker: agreed
13:28:34 <Peaker> mauke: I think   perms <=< filterM (const [False,True])   would work?
13:47:48 <Boreeas> :t [3+2, 1`div` 0]
13:47:49 <lambdabot> Integral t => [t]
13:48:38 <Boreeas> @let x=[3+2, 1`div` 0]
13:48:39 <lambdabot>  Defined.
13:48:43 <Boreeas> :t x
13:48:43 <lambdabot>     Ambiguous occurrence ‘x’
13:48:44 <lambdabot>     It could refer to either ‘L.x’,
13:48:44 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:152:1
13:49:05 <Boreeas> :t Prelude.x
13:49:06 <lambdabot>     Not in scope: ‘Prelude.x’
13:49:07 <lambdabot>     Perhaps you meant one of these:
13:49:07 <lambdabot>       ‘Prelude.id’ (imported from Prelude),
13:49:45 <Boreeas> @let x''''=[3+2, 1`div` 0]
13:49:46 <lambdabot>  Defined.
13:49:50 <Boreeas> :t x''''
13:49:51 <lambdabot> Integral t => [t]
13:50:10 <mauke> @undefine
13:50:10 <lambdabot> Undefined.
13:50:18 <Hiro`> Hey guys I want to redefine 'and', so I have a line at the top of my script that says, "import Prelude hiding (and)", but when I try to compile it, it fails and I get error messages saying, "Ambiguous occurrence `and' … It could refer to either `Main.and', defined at... or `Prelude.and', imported from `Prelude'..."
13:50:32 <mauke> Hiro`: show your code
13:50:47 <Vulume> yo yo sup everybody. haskell.org is offline so can you guys be my google?
13:51:05 <benzrf> Vulume: i suppose
13:51:08 <mauke> Vulume: have you tried googling on bing?
13:51:15 <benzrf> mauke: shoosh
13:51:20 <Vulume> why can't I compile files with # symbols in them? Like unsafeCoerce#
13:51:27 <EvanR> use blecko
13:51:28 <benzrf> Vulume: you need an txn
13:51:30 <benzrf> *extn
13:51:33 <mauke> because that requires a language extension
13:51:34 <benzrf> -XMagicHashs
13:51:35 <benzrf> -XMagicHash
13:51:36 <Boreeas> So lambdabot tells me the type of x'''' is Integral t => [t]. GHCI tells me otherwise: http://lpaste.net/114521
13:51:37 <Peaker> Hiro`: maybe you have more than one import Prelude line?
13:51:40 <mauke> # is normally an operator
13:51:43 <Boreeas> Anyone can explain that to me?
13:51:44 <EvanR> -XJazzHands
13:51:49 <Vulume> aight thx
13:51:57 <jle`> Boreeas: you might not be on ghc 7.8+
13:52:04 <mauke> Boreeas: monomorphism restriction maybe
13:52:08 <jle`> before that, ghci has the MonomorphismRestriction on by default
13:52:26 <Vulume> yeah it told me that # was an operator, and that i maybe meant unsafeCoerce# in stead of unsafeCoerce
13:52:26 <jle`> :set -XNoMonomorphismRestriction should give you the lambdabot behavior
13:52:41 <Boreeas> Huh, I'm on 7.6.3, right. Thanks
13:52:57 <jle`> you might as well add it to ~/.ghci because there aren't many occasions on ghci where it would be too useful
13:53:16 <jle`> it's off by default on 7.8+
13:53:32 <Vulume> or upgrade
13:53:49 <Boreeas> So monomorphism restriction tries to force a specific type as soon as possible?
13:54:33 <dmj`> anyone here use hedis?
13:54:35 <Boreeas> Vulume: Too much effort - I'm on an old replacement laptop that's still running Ubuntu 13.10. There are no new packages, I'd need to run a dist upgrade first
13:55:06 <Vulume> fair enough :)
13:55:25 <Hiro`> mauke: http://pastebin.com/Yv3v450W
13:55:27 * hackagebot machines 0.4.0.1 - Networked stream transducers  http://hackage.haskell.org/package/machines-0.4.0.1 (EricMertens)
13:55:55 <Hiro`> Peaker: Indeed I do. Is that the problem?
13:56:28 <mauke> Hiro`: line 1 imports (^); line 2 imports and
13:56:35 <Peaker> Boreeas: the monomorphism restriction is a pretty ad-hoc, weird rule: For definitions that: A) Have no *syntactic* arguments left of =, B) Have no explicit type signature, C) Have type-class constraints in their inferred type --> A specific instance is chosen as soon as it is used
13:56:39 <Vulume> another question about magic. the Any type in Prim is defined as "data Any k" , but it has kind *. What's that all about?
13:57:18 <Peaker> Boreeas: all 3 must hold for the MR to fire into your foot
13:57:53 <Peaker> and this weird combination of rules makes reverse-engineering its behavior a bit tricky, so people end up with all sorts of weird notions about what the MR actually does
13:59:07 <Hiro`> mauke: Am I being dense? I thought that line 1 /hides/ (^), and that line 2 hides and.
13:59:23 <mauke> line 1 imports everything except (^), including 'and'
13:59:48 <mauke> er
14:00:09 <mauke> line 1 imports everything except 'and', including (^)
14:00:20 <mauke> line 2 imports everything except (^), including 'and'
14:00:28 <Hiro`> Ah, I see. Of course.
14:00:31 <mauke> so you end up with everything in Prelude
14:00:43 <mauke> you want: import Prelude hiding ((^), and)
14:00:49 <Hiro`> So, is there a way to hide more than one Prelude function at a time?
14:00:57 <Hiro`> Thanks!
14:01:38 <Nervkind1> hey guys hoogle seems to be offline do you guys know an alternative?
14:01:50 <chaosmasttter> hayoo
14:01:54 <tolt> http://hayoo.fh-wedel.de/
14:02:00 <Nervkind1> thank you!
14:02:06 <merijn> Vulume: Prim is not subject to normal rules :)
14:03:05 <Vulume> I figured that. Ah well. It got the Typeable constraint out of my library. Now I declare Applicatives yay.
14:03:28 <merijn> Vulume: Basically, Prim is stuff that's hardcoded in GHC being exposed
14:04:18 <Yuras> Peaker: re A): after a bit of thinking, my answer is "yes" only because I don't see good reason for the opposite. So I may change my mind. But I think IRC is not good for such discussion
14:06:03 <Vulume> merijn: so it's "Prim" for "primitive". Alright. I think I'm going to keep my hands of the rest of that module.
14:06:05 <merijn> Nervkind1: FP complete hosts another hoogle
14:06:09 <EvanR> the package "future" seems pretty interesting, though i never heard about it before
14:06:19 <EvanR> funny that "C++" is slapped all over the brochure
14:06:32 <merijn> Nervkind1: Hoogle is down due to an emergency migration of haskell.org
14:07:41 <chrisdotcode> merijn: what's the emergecy reason?
14:07:50 <Vulume> Nervkind1: "https://www.fpcomplete.com/hoogle?q=XXX" is the query to add to your search engine list. It's more complete and faster than regular Hoogle, too.
14:07:57 <merijn> chrisdotcode: There was a migration planned for the near future, but a RAID disk died
14:08:02 <chrisdotcode> Ouch.
14:08:06 <Vulume> For example it indexes Lens
14:08:19 <merijn> chrisdotcode: So rather than investing the time to fix the RAID volume, they decided to migrate it now rather than later
14:08:29 * chrisdotcode nods.
14:08:37 <chrisdotcode> I must say, cloudfare designs good offline pages.
14:08:51 <chrisdotcode> Very aesthetically pleasing.
14:12:18 <Peaker> Yuras: A) "yes" as in you want hClose to violate strong exception safety and close handles even if it could have no effect in an exception case?
14:14:11 <EvanR> whats strong exception safety?
14:15:11 <shiona> EvanR: if an exception is thrown the application state is the same as when the action started
14:15:20 <Yuras> Peaker: in the ideal world, hClose should not throw; in haskell it throws, that breaks exception safety anyway. So in theory either way works. Probably there are practical reasons to choose one.
14:15:31 <Yuras> here I mean hClose as a destructor
14:15:43 <shiona> I guess that should mean there were no side effects
14:16:04 <EvanR> cool, strong exception safety rox
14:16:24 <Yuras> err either way *doesn't* work :)
14:18:45 <Peaker> Yuras: I don't think of hClose as a destructor. It's just an ordinary IO action
14:19:10 <Peaker> Yuras: and an ideal world still has unreliable networks and still does writes asynchronously, so an ideal world still has problems closing sometimes :)
14:19:25 <EvanR> hClose throws exceptions sometimes? when used on a handle?
14:19:26 <Peaker> Yuras: maybe an ideal world has some sort of linear types to guarantee you only close flushed handles
14:19:38 <Peaker> EvanR: buffers may need to be flushed
14:20:13 <Peaker> Yuras: so if you think of hClose as an IO action that closes, and not a destructor, then it should provide strong exception safety and *not* close if it throws
14:20:31 <Peaker> Yuras: it can be *used* as a destructor, but it is not a destructor.  I might have a completely opposite bracket like:  bracket hClose reopenTheFile ...
14:22:43 <EvanR> i guess close may give EINTR when interrupted by a signal (in addition to real errors related to doing IO)
14:22:56 <EvanR> not sure what the ghc semantics of that is
14:23:26 <Yuras> Peaker: ok, but them we need two different hClose implementations :)
14:24:25 <Peaker> Yuras: perhaps: hClose and hForceClose, the latter of which is useful under mask, not expected to actually flush, and doesn't throw exceptions. Then in cleanups, you can use hClose .. `catch` .. hForceClose
14:25:14 <Peaker> The last piece of code can have a name:  hBestEffortClose  or such
14:25:50 <Peaker> or, hUnsafeForceClose, hUnsafeBestEffortClose :)
14:26:17 <Yuras> Peaker: if you think different exception guarantees are useful here, then I'm ok
14:26:57 <Peaker> Yuras: of course, hClose is the thing you do when you care about flushing (almost always!), and hUnsafeForceClose you'd do when you realize you're in trouble and you want to at least not leak the handle
14:28:22 <Yuras> I disagree with "almost always", but that is just an opinion. I never needed that
14:28:46 <EvanR> yeah you dont even need to close, just exit ;)
14:28:52 <EvanR> it will auto flush
14:28:58 <sdx23> hi. i read that the real world haskell chapter on databases is obsolete - what is currently the recommended way for handling database access in a type based approach?
14:29:16 <EvanR> sdx23: which database?
14:29:34 <Peaker> Yuras: if you try to write something and some arbitrary parts of your write won't happen -- and that's fine (with no error reporting, even!) -- why do you attempt to write at all?  It's fine to just not write at all then?
14:29:54 <sdx23> EvanR: not necessarily any specific. Currently thinking about sqlite.
14:30:30 <EvanR> i would go for mysql-simple, postgresql-simple for quick and dirty db stuff, maybe there is an sqlite-simple
14:30:58 <Axman6> sdx23: there are quite a few options. Persistent is quite nice, particularly if you don't need to do too many relational queries (joins for example), but Esqueleto is a nice layer on top of persistent to allow that. Postgresql-simple is quite nice and easy to use once you figure it out. there's a new hasql project which looks promising too
14:31:54 <juanpablo_> sdx23: Persistent can be nice if your type-fu is good enough. Postgres-simple is my favorite
14:32:25 <Axman6> I believe there's also a sqlite-simple
14:32:30 <sdx23> Axman6: I like the type-based approach of persistent - but i dislike that they need that you have to implement new types with their template-haskell based thingy (if I understood correctly)
14:32:32 <fragamus> ugh I have to ask a question that sucks
14:32:33 <Axman6> modled on postgresql-simple
14:33:02 <Axman6> sdx23: it's not necessary to use the templates, but it's a hell of a lot easier to do so
14:33:09 <sdx23> hm, the simple stuff seems not reusable. Is it good practice to use that?
14:33:23 <Yuras> Peaker: no, you are thinking about hClose, but should think about components
14:33:34 <juanpablo_> sdx23: you don't necessarly need to use the TH, but be prepared to write lots of boilerplate that TH would otherwise do for you
14:34:25 <fragamus> I am using System.Directory.renameFile and I get a getSymbolicLinkStatus: does not exist (No such file or directory)    BUT... when I do it in GHCI it works fine and renames the file
14:34:37 <sdx23> juanpablo_: well, then better the TH. I'll look into sqlite-simple and that hasql thing first though.
14:34:48 <merijn> fragamus: Is ghci running with the same working directory?
14:34:50 <fragamus> so it fails as a compiled executable
14:34:59 <fragamus> i think so
14:35:04 <Peaker> Yuras: how does that help?
14:35:14 <fragamus> lemme check
14:35:43 <sdx23> thanks for your suggestions
14:35:46 <Peaker> Yuras: if you say: Run action X but don't care if it actually happens -- then save performance and don't run action X :)
14:35:50 <Yuras> Yuras: you have a component, that writes something to file. It's guarantee: in case of exception file is closed. if exception is thrown, then it doesn't matter what was written to file
14:36:08 <EvanR> haha
14:36:09 <EvanR> no
14:36:12 <Peaker> Yuras: what if you reached the hClose cleanup without an exception?
14:36:14 <EvanR> use "don't"
14:36:54 <Yuras> if there were no exception, the component should do what it is supposed to
14:37:56 <Peaker> Yuras: let's say you have:  bracket openFile.. hCloseOrWrapper $ do { write to file }   and a problem occurs during the hCloseOrWrapper
14:37:58 <Yuras> Peaker: ok, I see your point. I'll think about that.
14:38:14 <t4nk166> Is the length of a list stored in Haskell?
14:38:20 <Axman6> t4nk166: no
14:38:25 <Yuras> Peaker: IRC is not good for such discussion because requires quick answers :)
14:38:35 <Axman6> lists can be infinitely long and their length may be impossible to predict
14:38:38 <Peaker> Yuras: that's why it's great for such a discussion if you've already thought about it a lot :)
14:38:38 <dmj`> t4nk166: after you compute it yes :)
14:38:49 <Axman6> (well, without executing the code to completion, if it terminates)
14:39:01 <Peaker> Yuras: with offline slow messages - you often waste a lot of round trips/time misunderstanding each other rather than reaching the core issue quickly
14:39:03 <Yuras> Peaker: good point :)
14:39:15 <Axman6> @src []
14:39:15 <lambdabot> data [] a = [] | a : [a]
14:39:39 <Yuras> Peaker: how C++ solves that issue?
14:39:44 <Axman6> that's the whole definition for the list type: a list of a's is wither empty or an a followed by a list of a's
14:40:25 <merijn> Yuras: In C++ raising an exception in an exception handler is considered wrong
14:40:32 <merijn> Yuras: And C++ doesn't have async exceptions
14:40:46 <Yuras> merijn: no, that is not about async
14:41:13 <mauke> wait, since when is throwing from an exception handler considered wrong?
14:41:14 <Yuras> merijn: it is about sync exception from flushing buffer
14:41:16 <merijn> Yuras: In C++ you have no guarantees that cleanup runs if the cleanup raises an exception
14:41:46 <merijn> mauke: Well, it certaintly means part of your cleanup didn't run if it throws
14:42:01 <EvanR> rethrow as a last action?
14:42:06 * Guest37032 wants to make sure that haskell.org outage is a known thing
14:42:12 <mauke> yeah, ok
14:42:14 <merijn> mauke: See the gigantic thread on make bracket cleanup uninterruptible on libraries@ for context
14:42:22 <johnw> Guest37032: mention it in #haskell-infrastructure
14:42:31 <mauke> but it doesn't break the language, unlike throwing from destructors
14:42:35 <merijn> johnw, Guest37032 It is
14:42:40 <merijn> They're migrating haskell.org
14:42:42 <t4nk166> Axman6, Thank you, was just trying to come up with an efficient way to check if a list contains a value that meets a predicate. I'm currently using filter but I want to stop as soon as I find an exception. I was messing around with takeWhile but I needed to use then length then to compare.
14:42:50 <merijn> There's a thread on reddit, ETA unknown
14:42:58 <mauke> :t find
14:42:59 <lambdabot> (a -> Bool) -> [a] -> Maybe a
14:42:59 <Guest37032> cool, thanks!
14:43:12 <bennofs> Guest37032: see also http://status.haskell.org
14:43:20 <mauke> t4nk166: not . null . filter p
14:43:33 <Axman6> using length is almost always a code smell; you probably don't need it
14:43:40 <merijn> Guest37032: Basically, haskell.org was planned to be migrated soon, but a RAID disk died. So rather than invest time to fix the RAID now and migrate later, they just ad hoc moved the migration forward
14:43:53 <Axman6> isNothing . find p :\
14:44:16 <Axman6> merijn: "Fuck it, we'll do it live!"
14:44:26 <t4nk166> mauke, Aha so as soon as the list from filter contains anything it will return and will not continue checking.
14:44:40 <Axman6> t4nk166: that's laziness for you
14:45:52 <Axman6> huh, love the status updates on status.haskell.org. so much nicer than knowing nothing at all as usual
14:47:30 <bennofs> Axman6: to be fair, this was also posted to haskell-cafe + reddit r/haskell :)
14:48:13 <EvanR> length in general is a partial function ;)
14:48:34 <EvanR> its as bad as head!
14:49:02 <Yuras> Peaker: OK, not I see you point
14:49:31 <Yuras> I was wrong here, thank you for teaching me
14:49:44 <Yuras> Peaker: so, A) - no
14:50:45 <Yuras> Peaker: but I don't think I relied on that anywere
14:50:47 <fragamus> hey I have integers in a string with various white space thingies like return characters and spaces and tabs...    any quick parsing thing to give me a list of integers
14:51:11 <Yuras> Peaker: in the article I mean
14:51:56 <DTSCode> is there a page i can see for the general syntax of a let statement?
14:52:07 <DTSCode> cause i kind of get it but i want to be sure
14:53:40 <EvanR> theres the haskell report
14:55:54 <DTSCode> EvanR: this? https://www.haskell.org/definition/haskell2010.pdf
14:56:02 <EvanR> that should work
14:56:24 <DTSCode> ty
14:57:01 <sshine> formatting error in the docs: http://hackage.haskell.org/package/base-4.7.0.1/docs/src/GHC-List.html#unzip
14:57:07 <shiona> has anyone followed these https://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html and if so are they worth it?
14:57:31 <shiona> I thought I could do with someone teaching me the maths since I'm a terrible reader
14:58:40 <Peaker> Yuras: well, your article claimed that code runs with exceptions masked normally (I don't think that's true), and that reasoning about whether something is "interruptible" is like reasoning about whether it throws sync exceptions
14:59:16 <Peaker> Yuras: I think the whole "interruptible" thing is really just a short-cut for the "correct" behavior which is only having unmasked and uninterruptible-masked states, and explicitly "restoring" when async exceptions are acceptable
14:59:42 <Peaker> Yuras: and that outside of cleanups, this short-cut is usually fine as long as you can give exception safety
15:00:04 <Peaker> Yuras: but in cleanups -- I don't know of a single actual case where you want the "interruptible" behavior. do you?
15:03:55 <blicero> how can i find out which blas library hmatrix linked against
15:04:45 <dmj`> blicero: cabal unpack hmatrix, or look at the hackage docs?
15:04:48 <Yuras> Peaker: for example, when timeout exception is raised, I don't want hClose to flush buffers
15:05:14 <Yuras> Peaker: I don't care about them anymore
15:06:14 <Yuras> Peaker: with uninterruptibleMask flushing buffers can take unbound amount of time, that is bad
15:07:03 <Yuras> Peaker: I didn't get the short-cut thing
15:07:37 <Peaker> Yuras: so you have a timeout where you want a "hard abort" of your task?
15:08:04 <Peaker> Yuras: which aborts everything at any price -- even breaking all possible invariants
15:08:57 <Yuras> Peaker: I don't see how it breaks basic guarantees
15:08:59 <Peaker> Yuras: I think such hard aborts are a bad idea. it is fine to have hard timeouts like that externally, but for your cleanups you cannot guarantee the timings and you should code around this limitation knowingly
15:09:31 <Yuras> Peaker: the component (file) is in valid state, so everything is ok
15:10:10 <Peaker> Yuras: well, with hClose there's supposedly a way to "Just schedule its closing at some future point".  But what if you have a child process that you need to guarantee is done? There's simply no way to force it to die now immediately
15:10:39 <Peaker> Yuras: even hClose is problematic, because scheduling the close for later might mean you run out of FDs
15:11:04 <Yuras> Peaker: no scheduling in case of hClose required
15:11:37 <Yuras> Peaker: for processes, is most cases eventual terminating is fine
15:12:34 <Yuras> Peaker: unless for some reasons you need to guarantee that only one is working at a time
15:12:47 <merijn> That's not very rare
15:12:59 <Yuras> Peaker: in that case either change design or use uninterruptibleMask
15:14:25 <Yuras> Peaker: I even want one more masking state, when all interruptible actions are interrupted immediately
15:15:05 <merijn> Yuras: What do you mean by "interruptible actions"?
15:15:29 <Yuras> merijn: sorry?
15:15:35 <blicero> dmj` as far as i can tell it just links to standard lapack/blas headers and i have both atlas and accelerate providing those so i'm not sure which one it is linking to
15:16:03 <merijn> Yuras: Are you referring to "I want all blocking actions interrupted immediately"? Because that already happens
15:16:24 <Peaker> Yuras: You need the sceduling because the underlying "close" in POSIX (at least) does not support a "Close it now, damnit", and will block/wait indefinitely
15:17:03 <Yuras> merijn: only the current is interrupted. I want all successive to be interrupted too
15:17:06 --- mode: card.freenode.net set +o ChanServ
15:18:21 <Yuras> Peaker: well, ghc's scheduler doesn't guarantee anything too
15:19:27 <Yuras> Peaker: but it doesn't mean we should wait forever because of misconfigured network.
15:19:31 <merijn> Yuras: So you want level triggered instead of edge triggered exceptions?
15:19:52 <merijn> Yuras: You won't, because networks have maximum timeouts
15:20:32 <Yuras> merijn: level triggered? I don't know the term
15:20:53 <Peaker> Yuras: if you want to avoid waiting forever, you have to fix the problem at its root. You cannot pretend the problem disappeared because you're tired of waiting for it to be resolved
15:21:48 <Peaker> Yuras: GHC's scheduler supposedly guarantees non-starvation, btw
15:22:35 <Yuras> merijn: yes, level triggered
15:23:15 <Yuras> Peaker: where is the root?
15:23:34 <Yuras> re scheduller: ok, good to know
15:24:05 <Peaker> Yuras: Some operation is failing to [n]acknowledge. Some process is refusing to die. Some handle is refusing to close. You can just give up and ignore the problem - but it persists
15:24:36 <Peaker> Yuras: it is a much better approach, if you are indeed independent of the persistence of the problem - to express that independence as a different thread, and not have it happen after the bracket
15:25:12 <Yuras> Peaker: I agree here, I never said an opposite
15:25:31 <Peaker> Yuras: you said the process bracket may exit the bracket while the process is still alive
15:25:35 <mauris_> could anyone in here who's running linux run this little server, try "nc localhost 8887", and see if hGetChar blocks? https://bpaste.net/raw/5b357583565e
15:25:48 <Peaker> Yuras: and that's quite pointless -- it makes the bracket pointless, just use (>>) instead
15:25:54 <Yuras> Peaker: but do you see what I state about hiding bugs?
15:26:02 <mauris_> i'm setting buffering to NoBuffering but i'm not sure if its failure is my setup's fault or haskell's
15:26:29 <geekosaur> it will block, I don't need to run it. buffering *is not* the problem
15:27:06 <geekosaur> not in your haskell program at least
15:27:29 <geekosaur> note that nc may well be reading in line mode, as that is the default, so the q doesn't get sent by nc until the newline is entered
15:27:38 <EvanR> mauris_: windows?
15:27:49 <mauris_> EvanR: ubuntu vm now :)
15:27:50 <geekosaur> "who's running linux"
15:27:53 <Yuras> Peaker: "you said the process bracket may exit the bracket while the process is still alive" -- yes, if you are prepared for that. but not if you are not
15:28:00 <Peaker> Yuras: Yes, but I completely disagree about it - because I believe that the cleanup actions have nothing useful to do in exceptions, therefore async exceptions do not help us get any more "sync exception safety"
15:28:37 <Peaker> Yuras: if you are "prepared for that", that pretty much means that you need (>>) and not "bracket"
15:29:44 <Yuras> Peaker: no, >> doesn't guarantee anything. eventual guarantee is necessary at least
15:30:12 <bitonic> is there any script to easily consult .prof script?  e.g. sort by time spent
15:30:33 <geekosaur> mauris_, test what this does first:  printf q | nc localhost 8887
15:30:40 <Yuras> Peaker: you disagree where? you think there are no such situations?
15:30:43 <Peaker> Yuras: if I sent a kill to the process, there might be some "eventual guarantee", but it is not useful for such a bracket
15:31:09 <eric__> hi! i'm try to make a recursive implementation for the minimum function. Easy. But i want that the base case be the empty list, using the Bounded class. Here is my code, but doesn't work. Any help will be helpfull: http://pastebin.com/hzKd6iVk
15:31:17 <mauris_> geekosaur: ah, quits with "Okely-dokely."
15:31:33 <geekosaur> right, so the line buffering is in nc.
15:32:31 <Peaker> Yuras: I guess you could divide brackets into 2 uses: A) Just guaranteeing scheduling of resource cleanup,  B) Guaranteeing some invariant about inner/outer of bracket.   I'd say B is/should be prevalent.
15:32:48 <Peaker> Yuras: with the scheduling/eventual approach, we can run out of resources and cannot reason about how many resources we're using at all
15:34:01 <Yuras> Peaker: you can, but it is not deterministic any more
15:34:56 <Yuras> Peaker: anyway, you disagree that such "hiding bug" situations exist?
15:34:57 <michaelt> eric__: you do not need the signature for maxBound :: a
15:35:41 <Yuras> Peaker: or you disagree that they are common enough?
15:36:02 <eric__> but the compile is telling me that i'm making somethng wrong...
15:36:02 <michaelt> eric__: you can use it, but you need to enable ScopedTypeVariables . This works. Maybe there's something simlper http://lpaste.net/5865127749378637824
15:36:38 <michaelt> eric__: yes, the compiler doesn't like the signature :: a, since that means 'any type whatever, never mind what I wrote in the top level signature'
15:37:01 <eric__> ok
15:37:12 <Peaker> Yuras: I disagree that hiding bugs exists *in cleanup handlers*
15:37:18 <Peaker> Yuras: for async masking
15:37:29 <Peaker> Yuras: I agree that async exceptions may expose exception safety bugs in non-cleanup code
15:37:29 <michaelt> eric__: with ScopedTypeVariables and a forall a . at the top level, the 'a' in maxBound :: a  is bound by tthe top level signature. It's what you intended.
15:37:30 <eric__> how is the correct for use maxBound?
15:37:53 <eric__> is another way to do this?
15:37:59 <eric__> more correct?
15:38:07 <newsham> whats the most popular industrial web server/framework for haskell these days?  yesod?
15:39:08 <Yuras> Peaker: here: "bracket ((,) <$> opefFile... <*> openFile) (\(h1, h2) -> hClose h1 >> hClose h2) $ do ..."
15:39:12 <michaelt> eric__: if, in the code you pasted, you just omit the signature for maxBound in line 2 everything is fine. I may not be following ....
15:39:12 <Peaker> Yuras: But I don't agree with your approach of letting cleanup handlers be interrupted - and then pretend they can leave the cleanup despite the resource/action not freeing/completing, and hoping for the best.  I think it's fine for some higher-level logic to give up by then, but it should run in another thread and not cause these brackets to leave. There's basically no benefit for these brackets to leave
15:39:20 <Yuras> Peaker: do you think it is a bug?
15:39:57 <mauris_> geekosaur: solved my problem by using telnet and some negotiation codes, instead! thanks for helping me figure out where the problem was
15:39:59 <Peaker> Yuras: Yes, it'd be better to use `finally` instead of (>>) or perhaps even a retry loop or such, or maybe a hUnsafeForceClose
15:40:30 <Peaker> Yuras: we don't really have hUnsafeForceClose, so there's no non-buggy way to write that code right now anyway, but it can be slightly improved
15:41:01 <Yuras> Peaker: but uninterruptibleMask will hide the bug -- you'll almost never will see resource leak here
15:41:08 <Peaker> Yuras: the thing is -- async exception during that code will cancel the first close -- and go to the 2nd close, and that itself is a bug, because they need to be masked
15:41:09 <Yuras> Peaker: but the bug is here
15:41:21 <Peaker> Yuras: to avoid leaking either file
15:41:41 <Peaker> Yuras: what you're saying is: If we allow async exceptions to cause leakage of the first file -- then we can expose a bug regarding sync exception leaking the 2nd file
15:41:48 <eric__> michaelt (thanks for all) i'm try this: http://pastebin.com/6h9QULNc this compile, but crash when run
15:42:15 <Yuras> Peaker: no, hClose doesn't leak in case of async exception
15:42:35 <geekosaur> mauris_: I was considering telling you how to set that up but wasn't sure you wanted it. another solution is to use stty to put the terminal into character mode, but that's rather annoying
15:42:37 <Peaker> Yuras: we already agreed that like all IO actions, hClose should provide strong exception safety and NOT close if possible on exception
15:43:05 <Peaker> Yuras: and that maybe we need an hUnsafeForceClose  that does its best to close (ignoring buffers) and does not have any exceptions, sync or async
15:43:13 <Yuras> Peaker: probably in ideal world, but it does
15:43:14 <michaelt> eric__: what is it crashing on, I get  minimo' "California" = 'C'
15:43:18 <tomberek> I would love to have any feedback or suggestions: https://www.fpcomplete.com/user/tomberek/cyclic-types
15:43:36 <Peaker> Yuras: and then we might have:  hUnsafeForceClose h1 >> hUnsafeForceClose h2    <-- is safe, because it guarantees no sync exceptions. That is, if you do the sensible thing of uninterruptibleMask
15:44:01 <eric__> michaelt: minimo' [1,2,3]
15:44:07 <Peaker> Yuras: Didn't the mailing list show that hClose doesn't actually close in case of exception during its execution?
15:44:37 <geekosaur> I thought it showed that it always closed but might not do other cleanup
15:44:47 <michaelt> eric__: it doesnn't know the type, try minimo' [1,2,3::Int]
15:45:24 <Yuras> Peaker: no, not in that case
15:45:48 <Yuras> Peaker: only in case of concurrent access
15:45:49 <Peaker> geekosaur: John Lato wrote a test program and said: "You might argue that hClose should use uninterruptibleMask internally (which is the only way to fix the issue).  Possibly so.  However, this is a really pervasive problem, which is why it makes some sense to place the mask in bracket and fix every handler properly"
15:45:50 <eric__> michaelt: oooooh thanks =) sorry for your lost time
15:46:01 <Peaker> i.e: hClose does not guarantee closing the handle, and neither does underlying POSIX close
15:46:26 <Peaker> Yuras: and?
15:47:23 <Yuras> Peaker: and uninterruptibleMask hides bugs
15:47:29 <Peaker> Yuras: the point is, hClose is not safe, and the correct solution is to use something else that to guarantee safety, does away with sync exceptions too, and gives no guarantees about flushed buffers/etc. Once you do that - you see you're safe to use (>>) there
15:47:33 <Yuras> Peaker: in cleanups
15:47:52 <EvanR> was strong exception safety a thing when they designed posix system calls
15:47:55 <Peaker> Yuras: Only "bugs" under a set of bad/wrong assumptions
15:47:56 <geekosaur> Peaker: but it had been demonstrated that the OS resource was closed. the *Haskell* stuff might leak.
15:48:14 <Peaker> EvanR: Strong exception safety says an error in close should make it *not* close
15:48:26 <EvanR> i gathered that from this conversation
15:48:52 <EvanR> but a half-flush that gets rolled back seems like something the OS would rather not do
15:49:02 <Peaker> geekosaur: "Note that "closed" was printed, so we should assume that hClose had a chance to run as well.  The handle clearly was not closed (I confirmed this with lsof as well)."
15:49:12 <geekosaur> hm
15:49:30 <Peaker> EvanR: it's fine for flushes not to be rolled back, because "flush" is not a visible effect
15:49:38 <Peaker> EvanR: flushes are happening in the background, invisibly, anyway
15:50:58 <Peaker> Yuras: Async exception in cleanup *causes* a bug. It might "expose" a bug in code as well. But a feature that adds random bugs *and* exposes other, unrelated bugs in addition to that is a useless one
15:51:32 <michaelt> eric__: oh good. You're welcome!
15:52:43 <eric__> there are any project open source in haskell, usefull for learning?
15:53:54 <Yuras> Peaker: but then the proposal fixes wrong issue anyway. haskell is broken w.r.t. exceptions, ans that should be fixed
15:54:24 <Peaker> Yuras: only hClose is broken for use as a cleanup, we need something else for cleanups
15:54:50 <Peaker> Yuras: but what else is broken (besides, obviously, allowing async interruptions to cancel critical cleanups and inject exceptions into code that must not have exceptions)
15:56:56 <Yuras> Peaker: OK, you convinced me
15:57:09 <Yuras> Peaker: thank you for the discussion
15:58:08 <Peaker> Yuras: That's great to hear! Thank you too for your patience
15:58:34 <newsham> hmm.. https://www.haskell.org/ -> Error 522
15:58:47 <newsham> is anyone else seeing that?
15:58:55 <mauris_> yeah
15:59:00 <mauris_> they're migrating
15:59:09 <mauke> to africa
15:59:12 <mauke> for the winter
15:59:17 <newsham> whats the ETA on the migrate?
15:59:46 <mauke> none, but https://status.haskell.org/
16:04:00 --- mode: ChanServ set +o geekosaur
16:04:50 <orion> I've read that functions go a long way in Haskell, and advanced type system features should be avoided if simpler features can be used. Could someone give me an example of when an advanced feature such as parametric/polymorphic type classes are very necessary over, say, record types?
16:05:15 <alphonse23_> does haskell do raw floating point computation?
16:05:32 --- topic: set to 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org (migrating) | http://downloads.haskell.org' by geekosaur
16:05:37 --- mode: geekosaur set -o geekosaur
16:05:41 <alphonse23_> does 0.1 + 0.2 = 0.3000004
16:05:50 <geekosaur> it uses machine floats/doubles, yes
16:05:51 <EvanR> > 0.1 + 0.2
16:05:53 <lambdabot>  0.30000000000000004
16:06:04 <EvanR> > 0 / 0
16:06:05 <lambdabot>  NaN
16:06:07 <Peaker> btw, if we're looking for broken things in Haskell exceptions, I'd say that stack overflow async exception being maskable is wrong because it makes the stack size limit in Haskell be a recommendation only
16:06:14 <alphonse23_> would that be like a violation of purity though??
16:06:31 <geekosaur> many people hate that it's specced to do IEEE floating point, yes
16:06:33 <EvanR> its even more pure because division by zero doesnt crash
16:06:36 <alphonse23_> I thought the whole idea was to not use memory???
16:06:39 <Peaker> alphonse23_: Purity can happily accomodate referentially transparent wrong code :)
16:07:00 <geekosaur> but it's not impure, just follows rules other than the ones you might expect
16:07:11 <alphonse23_> maybe....
16:07:19 <EvanR> it breaks several "laws"
16:07:43 <alphonse23_> makes no sense. I thought I could use haskell to prove things about numbers..... but how can you do that when 0.1 + 0.2 = 0.3000000000004..
16:08:13 <alphonse23_> is there a decimal type that doesn't use machine floating points?
16:08:14 <geekosaur> > (maxBound :: Int) + 1
16:08:15 <lambdabot>  -9223372036854775808
16:08:21 <Peaker> alphonse23_: unfortunately there's no way to accurately model real numbers on a computer.. There's an interesting subset of real numbers you can model (computable ones) but doing that is slow (The CReal type does)
16:08:21 <geekosaur> so not even very different
16:08:40 <Peaker> alphonse23_: CReal, but it is slow
16:08:48 <EvanR> alphonse23_: Data.Fixed gives decimal fixed point numbers
16:08:57 <mauke> > 0.1 + 0.2 :: Rational
16:08:58 <lambdabot>  3 % 10
16:09:56 <alphonse23_> Peaker: really, there's no way to actually map real numbers. But I thought haskell was a programming language meant for proof writing...
16:10:09 <geekosaur> also worth noting is that Haskell's standard Prelude does not follow strict math rules anyway; this has led to several alternative numerical Preludes that do
16:10:19 <geekosaur> (even for integral types)
16:10:31 <Peaker> CReal doesn't seem to be lazy enough. showing 10000 digits requires computing them all to show the first, even in non-edge cases
16:10:44 <alphonse23_> meaning, even haskell is unreliable if I want to proof something mathematically. that really puts a quink in my faith in haskell -- just to let you know.
16:10:48 <geekosaur> but little can be done about the reals since they cannot be represented by a computer; Cantor's diagonal argument applies both to bits and to memory addresses
16:10:57 <geekosaur> eng
16:10:59 <Peaker> alphonse23_: Haskell isn't actually meant for proof writing, and is not that useful for that purpose
16:10:59 <geekosaur> enh
16:11:09 <geekosaur> if you want proof writing then you want coq or agda
16:11:10 <EvanR> alphonse23_: check out coq and agda
16:11:11 <alphonse23_> this is a bummer..
16:11:13 <Peaker> alphonse23_: for that you might want to use Agda, Coq, Idris, ...
16:11:21 <geekosaur> and you won't be using numerical methods, you'll be using theoretical on es
16:11:44 <exio4> alphonse23_: Haskell's isn't a proof assitant, that is Coq/Adga
16:12:08 <alphonse23_> well, i know of agda
16:12:36 <EvanR> id like to see some proofs of things about ieee floating point
16:12:54 <geekosaur> again, perfect real math on a computer is not a thing. no language can help you
16:13:37 <EvanR> use a very precise slide rule
16:13:58 <exio4> EvanR: I'd guess the best you could get would be ∃a∃b. a+b ≠ b+a
16:14:00 <alphonse23_> huge bummer. haskell can't do math right
16:14:23 <geekosaur> cantor is always waiting to diagonalize you
16:14:32 <EvanR> > let _ + _ = 5 in 2 + 2
16:14:33 <lambdabot>  5
16:14:56 <EvanR> @faq can haskell do math wrong
16:14:56 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
16:15:12 <josephle> just define some dedekind cuts and you're good to go :P
16:15:13 <geekosaur> cantor, and later gödel, harshed a lot of buzzes
16:15:55 <alphonse23_> I'm sure, but that doesn't apply to the logic of computers
16:16:04 <alphonse23_> it's said, my computer can't be trusted
16:16:08 <alphonse23_> it was my last hope
16:16:19 <EvanR> the uncompromising logic of floating point
16:16:19 <geekosaur> you wish...
16:16:26 <vanila> alphonse23_, Haskell itself is not a mathematicaly sound logic
16:16:36 <vanila> its just a programming language
16:16:37 <exio4> > undefined
16:16:38 <lambdabot>  *Exception: Prelude.undefined
16:16:43 <mightybyte> What's up with "Could not find module 'System.Environment', perhaps you meant System.Environment (from base), System.Environment (needs flag -package haskell2010)"?
16:17:18 <geekosaur> computers are even *more* limited in fact because they have finite memory
16:19:38 <bananagram> is haskell.org down?
16:19:43 <mightybyte> yes
16:19:48 <mightybyte> scheduled maintenance
16:21:09 <dfeuer> That's not true.
16:21:10 <hexagoxel> disk failure; not really scheduled, i think
16:21:19 <bananagram> aw man
16:21:35 <glguy> Scheduling your disk failures sounds like a good idea, though
16:21:37 <dfeuer> They were planning to do some maintenance, but decided to change the schedule when the disk failed. I don't know why, though.
16:21:53 <mightybyte> Oh, well I saw some notice about it, so I assumed it was scheduled.
16:21:59 <dfeuer> Shouldn't a RAID array be able to keep on going while it rebuilds?
16:22:04 <EvanR> its unscheduled scheduled maintenance
16:22:09 <EvanR> optional mandatory
16:22:25 <glguy> dfeuer: it puts tremendous IO load on the disks while they rebuild afaik
16:22:27 <bananagram> scheduled unscheduled maintenance
16:22:44 <bananagram> it does in raid 5, at least
16:23:16 <dfeuer> In principle, shouldn't you be able to balance the IO load against the time to rebuild?
16:23:48 <merijn> dfeuer: They're migrating it
16:24:04 <merijn> dfeuer: haskell.org was planned to be migrated to newer (better) facilities anyway
16:24:23 <dfeuer> Why does migration require extended downtime?
16:24:32 <merijn> So the choice was 1) waste a lot of time rebuilding the RAID, degrading performance and than migrate later and 2) migrating the machine now
16:24:56 <geekosaur> basically it's raid but it blew *both* copies
16:25:00 <merijn> dfeuer: Because the migration wasn't planned for today
16:25:06 <dfeuer> Oh.
16:25:12 <dfeuer> Hmm.
16:26:11 <newsham> i need a haskell web server to serve static content over https..  ideally with standard request logging.
16:26:19 <newsham> anyone have recommendations?
16:26:29 <geekosaur> apparently drives from the same batch, which failed at around the same time. those of us who do this professionally try hard to make sure drives from different manufacturers or at least different batches are used to try to avoid this kind of thing
16:26:41 <mightybyte> newsham: Snap should be able to do that pretty easily.
16:26:54 <simpson> geekosaur: Oh noes! That's horrible when it happens.
16:26:58 <newsham> do you know what snap uses for https?
16:27:10 <dfeuer> geekosaur, oof. So does that mean they'll be pulling backups?
16:27:52 <mightybyte> newsham: https://github.com/snapframework/snap-server/blob/master/snap-server.cabal#L125
16:27:55 <mightybyte> HsOpenSSL
16:28:00 <newsham> hrmm.. :(
16:28:22 <newsham> do any of them use http://hackage.haskell.org/package/network-conduit-tls ?
16:28:43 <newsham> or http://hackage.haskell.org/package/tls rather
16:29:18 <Yuras> Peaker: do you have a roadmap how to fix hClose?
16:29:46 <Yuras> Peaker: it is almost impossible without breaking everything
16:30:09 <geekosaur> dfeuer, you can check in #haskell-infrastructure but my understanding is they got one drive sort of working and are moving data as fast as possible
16:30:36 <geekosaur> backups not so useful since the new system is in the cloud anyway so they'd need a machine with good disks to restore the backup on and then copy it
16:31:14 <glguy> Yuras: Which part of hClose is broken?
16:31:20 <Peaker> Yuras: I don't think it's possible to actually fix it, because the underlying primitives are broken in POSIX
16:31:31 <merijn> glguy: Lots :)
16:32:20 <Yuras> Peaker: so thing we should not?
16:32:44 <merijn> Yuras: We should, but it's a separate issue
16:32:49 <Peaker> glguy: hClose itself could be said to be fine (rolls back side-effect of closing on exception). However, for cleanups, you want a different primitive that lets you knowingly forego proper finalization and just release the resource. POSIX doesn't allow it, but you can get close
16:32:58 <Yuras> merijn: I'm not sure
16:33:44 <glguy> Yeah, I saw some grumbling about it being blocking/interruptible but don't consider that an issue, I figure there's more though
16:33:46 <geekosaur> I do not understand that assertion. we use file descriptors, not stdio handles? so it's just an Int and closing is up to the kernel, either the fd is good and closed or the fd is bad and an errno is returned
16:34:10 <geekosaur> oh, blocking, right. aka unixy systems do not provide reasonable device support :(
16:34:39 <Peaker> glguy: you might want something like this for cleanups:  hClose handle `catch` \e -> logException e >> markInconsistentState >> hUnsafeReleaseFileHandle handle
16:35:38 <Peaker> hUnsafeReleaseFileHandle isn't possible to implement but you can avoid flushing any application/high-level buffers or syncing and directly try to close(2)
16:35:59 <Peaker> (2) is how it appears in my manpage :)
16:36:16 <geekosaur> yes, that's convention. function(mansection)
16:36:18 <geekosaur> 2 being syscalls
16:36:29 <Peaker> yeah, was clarifying in case it's not clear from context
16:37:11 <Yuras> merijn: that makes we think that semantical changes are necessary
16:37:16 <geekosaur> and whil in theory posix aio would help with this, in practice *working* posix aio is a very rare beast indeed
16:37:34 <Peaker> btw, I have a relatively new laptop, and "cabal build" takes about 6.2 seconds for an empty build in a medium-sized project. Any idea why it takes so long? I'm wondering whether to embark on an adventure to try and fix that
16:37:43 <Yuras> then it is better not to tough anything without clean view what to do
16:37:50 <Peaker> geekosaur: Linux aio is also broken in various ways :-((
16:37:55 <geekosaur> yes
16:38:16 <Peaker> Yuras: but hClose is just one function that's broken.. bracket is used for many many purposes
16:38:54 <Peaker> Yuras: whatever you do with hClose, you're going to try to stop sync exceptions from happening if you use it correctly in cleanups. And then, you of course do not want async exceptions tearing your cleanup apart
16:38:58 <hamishmack> merijn: ghcjs has TH support.  It used to work by compiling all the code twice (once to JS and once using the normal GHC gen).  Luite has made it so it now uses nodejs now to run the TH code (so it only needs the JS code path).
16:40:23 <Yuras> Peaker: you can't claim anything because you can't rely on anything anymore :)
16:40:32 <merijn> hamishmack: It's not finished yet, though and not polished enough to work for cross compilation yet
16:41:06 <Yuras> I don't buy "mostly works" exception handling
16:41:55 <merijn> Yuras: Then you'll be glad to know I've been thinking of proper exception handling for my own (vaporware) language :p
16:42:07 <merijn> Yuras: Retro-fitting proper exception handling in any existing language is pretty hard
16:43:14 <glguy> async exceptions are only a risk for hClose when you've accidentally leaked the file descriptor out of the scope of the bracket, its not universally broken, at least
16:45:02 <merijn> glguy: Nope, wrong
16:47:25 <merijn> glguy: How does leaking the file descriptor outside of the bracket scope affect anything?
16:47:48 <hamishmack> merijn: Just thought I would point it out in case people thought they could not use packages that relied on TH with ghcjs (not saying it works with other cross compilers or advocating TH use when it can be avoided)
16:48:27 <glguy> That statement assumes that the only way that hClose is interruptible is if you handed it to another thread that was using it causing hClose to block waiting to take the MVar inside the handle
16:48:28 <merijn> hamishmack: AFAIK it's still experimental for ghcjs too
16:48:37 <glguy> I don't know another way for hClose to be interruptible
16:51:11 <Yuras> glguy: it can be -- when flushing buffers. but the issue is much deeper
16:51:33 <Yuras> glguy: I still think the current situation is mostly OK
16:51:49 <Yuras> this *mostly* is very bad actually :)
16:52:11 <Yuras> but uninterruptibleMask doesn't fixes that too
16:53:29 <Yuras> and I'm not sure what *mostly* I prefer, with or without uninterruptibleMask :)
16:53:53 <hamishmack> merijn: That is fair to say for the new nodejs implementation.
16:54:06 <fragamus> hey I have integers in a string with various white space thingies like return characters and spaces and tabs...    any quick parsing thing to give me a list of integers
16:54:33 <luite> merijn: the implementation is a bit hacky, since 7.8 doesn't have the API to extend it in the ideal location to run TH outside the compiler process, but everything does work, including all reification and annotations
16:55:18 <merijn> luite: oh, neat :)
16:55:25 <luite> merijn: it's still relatively new, so it's experimental in the "please do use it and tell us about any problems" sense
16:55:38 <EvanR> Peaker: when hclosing, you might get an async exception? or just normal, like errno exception
16:56:40 <luite> merijn: and i'll probably submit the api adjustments to allow for a much cleaner implementation in 7.10
16:56:44 <luite> merijn: today
16:57:05 <texasmynsted> rrrut-roooh.  Looks like typecastopedia is down
16:58:22 <texasmynsted> oh snap.  Looks like haskell.org is down
16:59:18 <EvanR> hax
16:59:42 <dmj`> typecastopedia ;)
16:59:44 <orion> texasmynsted: https://status.haskell.org/
16:59:53 <texasmynsted> who would hax haskell.org?
16:59:59 <dmj`> cia
17:00:27 * texasmynsted nods gravely 
17:01:15 <Hijiri> enemies of the cabal
17:01:24 <texasmynsted> It is one of those sites used by people who think^^^^^^terr-ists
17:01:28 <carter> lol
17:02:15 <orion> Next thing you know: ISIS used Haskell to program 3D printers which print weapons which they sell for bitcoin.
17:02:18 <texasmynsted> There can be only one . . . cabal
17:02:27 <texasmynsted> heh
17:02:39 <texasmynsted> orion?
17:02:46 <orion> texasmynsted?
17:02:49 <texasmynsted> heheh
17:02:58 <EvanR> "close should not be retried after an EINTR since this may cause a reused descriptor from another thread to be closed"
17:03:07 <texasmynsted> I did not know you hung out here
17:03:23 <EvanR> man you cant get ahead in this game
17:04:35 <fds4345> is it possible to do like... higher level type functions. so I could write a function to go from (a -> f a) and then apply it to a polymorphous container
17:04:42 <fds4345> polymorphic*
17:04:55 <ubbersith> hi guys, is there someone from brazil here? =]
17:05:45 <dmj`> I think SrPx is
17:05:50 <EvanR> fds4345: check out fmap and <*>
17:06:00 <EvanR> Functor Applicative
17:06:49 <joelteon> haskell.org, please
17:10:44 <fds4345> how do you execute expressions in here?
17:10:45 <fds4345> > over both id (1, '1')
17:10:47 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Char)
17:10:47 <lambdabot>    arising from the literal ‘1’
17:11:09 <fds4345> EvanR: thats what im trying to do, essentially ^^
17:12:10 <nshepperd> :t both
17:12:11 <lambdabot> (Data.Bitraversable.Bitraversable r, Applicative f) => (a -> f b) -> r a a -> f (r b b)
17:12:55 <vanila> >  let ob f g = \(x,y) -> (f x, g y) in ob id id (1, '1')
17:12:56 <lambdabot>  (1,'1')
17:14:13 <fds4345> vanila: theres no way to do if you're dealing with a typeclass though, right? then you dont know how many type variables there are
17:17:27 <fds4345> looks like im going to have to generate x*y versions of this function to handle all the different numbers of inputs and outputs
17:17:41 <vanila> what is it?
17:17:44 <fds4345> there should be some clever trick with tuples or something
17:18:23 <fds4345> its linking together functions that have different numbers of inputs and different numbers of outputs which are executed in a a managed context
17:18:52 <vanila> i'd have to understand it more concretely to see if i can give any input
17:18:59 <vanila> its likely you can write it with one version
17:19:41 <fds4345> I think for each combination of x and y I'll need to have another function ie (out1, out2) = node2_2 f input1 input2
17:20:51 <vanila> can you explain the probem in a simple way?
17:20:57 <vanila> I don't understand
17:22:28 <fds4345> take an (a -> b) where a can and b can both be heterogenous containers
17:22:56 <fds4345> then wrap it in a box and label it
17:23:33 <fds4345> then link it up in a workflow with other functions... all of which can be run independently of each other
17:23:43 <fds4345> hard to explain :)
17:24:35 <vanila> do you want to have a composition of functions like f . g . h, but be able to run each one at time?
17:25:56 <Cale> Perhaps you should write part of the program in an awkward way so that we'd have a better idea what to suggest you do to clean it up
17:29:26 <fds4345> I cant see a clean way to fix it so I think I'll just embrace it... I love looking at the source code for Data.Tuple looks like pyramids
17:29:35 <iteratee> Control.Lens question: why is there a Contravariant constraint on Fold?
17:29:59 <iteratee> contramap isn't mentioned in the sources for Control.Lens.Fold
17:30:28 * hackagebot hspec-core 2.0.2 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-core-2.0.2 (SimonHengel)
17:30:30 * hackagebot hspec-discover 2.0.2 - Automatically discover and run Hspec tests  http://hackage.haskell.org/package/hspec-discover-2.0.2 (SimonHengel)
17:30:32 * hackagebot hspec 2.0.2 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-2.0.2 (SimonHengel)
17:40:28 * hackagebot snaplet-stripe 0.3.0 - Stripe snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-stripe-0.3.0 (LukeHoersten)
17:40:47 <Axman6> iteratee: might be worth pinging edwardk with your question
17:46:28 <jmcarthur> trying to decide what a good name would be for a type class for Profunctors that are kind of Divisible (as in http://hackage.haskell.org/package/contravariant-1.2/docs/Data-Functor-Contravariant-Divisible.html) on the left and kind of Applicative on the right
17:47:10 <dfeuer> jmcarthur, how about "too hard to understand"?
17:47:46 <jmcarthur> that is, it would have two functions:    foo :: p a ()   and   bar :: (a -> (b, c)) -> (d -> e -> f) -> p b d -> p c e -> p a f
17:47:58 <jmcarthur> err, i guess the former isn't a function, but whatever
17:48:13 <jmcarthur> dfeuer: how pessimistic! :P
17:48:39 <dfeuer> jmcarthur, type signatures like that make me want to run and hide.
17:49:01 <jmcarthur> dfeuer: but they are so nice! :(
17:49:43 <dfeuer> Maybe they come from Nice, but that doesn't really seem relevant.
17:50:05 <jmcarthur> maybe edwardk would have an idea (there's the highlight)
17:50:41 <dfeuer> jmcarthur, I already tried pinging him about something else (rather more mundane); I don't think he's here.
17:51:23 <jmcarthur> bummer. i cloned profunctors to add this and got stuck on something silly like naming
17:51:53 <Yuras> Peaker: OK, now I see that it was a trap :) I agree that I was wrong regarding exceptions in hClose. But if hClose can't be no-throw, then (under regular mask) you should be prepared to handle exception from it, sync or async. So async exceptions *expose* bugs in cleanups. They might *cause* bugs too, but that doesn't mean they should me completely masked
17:51:54 <dfeuer> jmcarthur, just call it a cubic taco and hope someone else does better.
17:52:16 <jmcarthur> it would go great with my unicorn burritos
17:52:20 <HeladoDeBrownie> jmcarthur, what instances are there?
17:52:58 <alphonse23_> I don't know if anyone here remembers me asking about floating point arithmetic a couple of hours ago
17:53:05 <alphonse23_> is there a round of error in Data.Number.CReal?
17:53:15 <dfeuer> alphonse23_, you might want to ask carter.
17:53:33 <dfeuer> Or else go to #numeric-haskell
17:53:54 <alphonse23_> it's called the epsilon. All data types of a margin of error?
17:54:22 <jmcarthur> HeladoDeBrownie: well, (->) is kind of an obvious example. i have some more complicated examples in mind for myself. i haven't gone through the list of profunctor instances visible in the hackage docs for Profunctor yet, but i suspect a lot of them could be instances of this too
17:54:41 <jmcarthur> i'll go ahead and write some instances i guess, with some dummy name for the thing
17:55:12 <alphonse23_> damn, hit the wrong command on irc
17:55:17 <dfeuer> Don't worry, jmcarthur. It'll end up permanent.
17:55:18 <alphonse23_> so there's no one in numeric-haskell
17:55:26 <Hijiri> I think CReal is supposed to provide exact real arithmetic for computable reals
17:55:29 <dfeuer> alphonse23_, I seem to have named the channel wrong, or it's empty.
17:55:36 <alphonse23_> it's empty
17:55:42 <Hijiri> you choose how precise it gets calculated
17:56:00 <alphonse23_> and there's no possibility of error
17:56:17 <jmcarthur> dfeuer: not committing until i have at least something unembarrasing :P
17:56:20 <alphonse23_> I was just reading about this, and there's a limit to where all hardware apparently can make a mistake
17:56:41 <batchm> how usable is reactive banana? would you use it in production? for hobby projects?
17:56:51 <alphonse23_> I guess I was just wonder, how do they check that it's 100% accurate..
17:56:55 <alphonse23_> *wondering
17:57:08 <dfeuer> alphonse23_, there's always a possibility of cosmic rays, design errors, etc.
17:57:12 <dfeuer> Nothing you can do about it.
17:57:14 <Hijiri> It's based on some magical mathematical representations with some kind of series
17:57:27 <Hijiri> it's stored in that abstract way until you try to extract digits
17:58:56 <alphonse23_> magic -- haha I thought so
17:59:13 <Hijiri> it's magic if I don't understand it :P
17:59:26 <Hijiri> there are some papers in this
17:59:29 <Hijiri> on this*
17:59:37 <Hijiri> one in particular is in my cellphone browser history
18:00:31 <Hijiri> I 2.
18:00:33 <Hijiri> .
18:00:37 <Hijiri> http://www.dcs.ed.ac.uk/home/mhe/plume/
18:00:45 <Hijiri> sorry, I messed up pasting the first two times
18:00:50 <alphonse23_> on the Cdata page on Hackage, it says "Note that the comparison operations on CReal may diverge since it is (by necessity) impossible to implementent them correctly and always terminating."
18:00:53 <alphonse23_> what does this mean?
18:01:27 <Hijiri> It might loop forever
18:01:34 <Hijiri> if you try to compare two CReals
18:01:59 <Hijiri> You might have two ways to compute the same real number
18:02:05 <simpson> > pi :: CReal
18:02:07 <lambdabot>  3.1415926535897932384626433832795028841972
18:02:10 <Hijiri> but to compare them you have to compare them infinitely
18:02:18 <simpson> > pi :: CReal == pi
18:02:19 <lambdabot>  Not in scope: type constructor or class ‘==’
18:02:28 <simpson> > (pi :: CReal) == pi
18:02:29 <lambdabot>  True
18:02:42 <simpson> I, uh. That's surprising.
18:02:47 <alphonse23_> hmm, that paper mentions the problem is it's representation in binary -- but how could that matter?
18:02:50 <dfeuer> You don't want to compare two CReals if they're equal.
18:03:40 <Pamelloes> What IO functions are directly built into Haskell?
18:04:17 <Hijiri> Is there a typeclass that provides Floating b => a -> b?
18:04:33 <nshepperd> jmcarthur: isn't that just forall a. Applicative (p a)?
18:04:36 <Hijiri> or at least a -> Double
18:05:03 <Cale> Pamelloes: Lots of stuff? It'
18:05:09 <Cale> It's hard to say what counts :)
18:05:18 <Johannes13> is there a way to write a function that behaves differently if called with a certain type
18:05:20 <Johannes13> ?
18:05:34 <jmcarthur> nshepperd: no, because that only accounts for the covariant bit
18:05:59 <Cale> Johannes13: You can define a type class, and instances for each type at which you want to use the function that specify how it's supposed to behave.
18:06:05 <nshepperd> jmcarthur: foo = pure (); bar f g x y = g <$> lmap (fst . f) x <*> lmap (snd . f) y
18:06:06 <Pamelloes> Cale: well I know there are lots of functions that are IO, but which ones are built into the language and which ones are built using features in the language?
18:06:34 <jmcarthur> nshepperd: ah, no, note that the last two arguments have *different* left type arguments
18:06:40 <tac_> Pamelloes: It depends on the implementation
18:06:55 <tac_> and FFI can extend IO without touching the compiler
18:06:57 <Johannes13> Cale, while this sounds possible, it's probably hard to make a function that
18:07:01 <jmcarthur> err
18:07:06 <jmcarthur> oh
18:07:09 <jmcarthur> maybe i'm crazy
18:07:14 <Johannes13> works for every type (like id)
18:07:39 <Cale> Johannes13: Well, a function whose type is a -> X for some type X must be a constant function.
18:08:08 <jmcarthur> nshepperd: you're right
18:08:10 <Johannes13> ex: extract x = x (default implementation)
18:08:12 <Cale> Johannes13: Types are removed by compilation
18:08:22 <Johannes13> extract (Just x) = x
18:08:27 <Cale> Johannes13: However, there are ways to preserve this information, like the Typeable class
18:08:38 <Johannes13> extract (x:_) = x
18:08:38 <Pamelloes> tac_: What would you say the absolute minimum would be?
18:09:02 <Cale> A function whose type is (Typeable a) => a -> Integer  might indeed produce different values for different types.
18:09:25 <Johannes13> sounds interesting...
18:09:36 <tac_> Pamelloes: IO is funny in that there is no "absolute minimum"
18:09:50 <Johannes13> So Typeable is the reflection stuff of haskell?
18:09:51 <tac_> I could define a haskell implementation where the only IO functions are getLine and puStr
18:09:53 <tac_> and that would be enough
18:09:57 <jmcarthur> nshepperd: i guess the only real difference is that the combined operation can memoize f
18:09:57 <tac_> or none at all, even!
18:10:01 <Pamelloes> how so?
18:10:07 <tac_> but then my language couldn't talk over the network or open a window
18:10:09 <benzrf> tac_: oh yeah
18:10:14 <batchm> Pamelloes are you asking what IO functions and values are defined by the Haskell report? or something else
18:10:17 <benzrf> have you seen that one language that can compute anything
18:10:37 <benzrf> but it has no i/o facilities
18:11:37 <Pamelloes> batchm: from a research perspective, I'm curious as to how little I/O is needed for a full implementation of Haskell. So I guess that means what is defined by the report.
18:11:46 <tac_> Pamelloes: IO is "open"
18:11:50 <tac_> You can always extend it with the FFI
18:12:07 <tac_> It's not like Int or [a].
18:12:19 <tac_> Those types are closed. We know at the point they are defined what all the values will look like
18:12:37 <tac_> but any new IO capability can be introduced at any time with the FFI
18:12:46 <jmcarthur> nshepperd: oh i guess another nice thing about what i had in mind is that you don't have to try to express that forall in the constraint
18:12:59 <tac_> all a module has to do is say "here's the C header file and here's what we're linking against"
18:13:01 <jmcarthur> nshepperd: same motivation as using Alternative instead of Monoid, etc.
18:13:26 <Pamelloes> Interesting. So basically, the absolute minimum is an FFI implementation, and then the rest can be implemented through that.
18:13:56 <tac_> yeah
18:14:00 <tac_> Or you could have an IO-less haskell
18:14:39 <tac_> Pamelloes: perhaps you want to know what an IO type might look like if you were to define it as an algebraic data type?
18:15:11 <Pamelloes> Sure
18:15:12 <Pamelloes> !
18:15:23 <Pamelloes> Oops... That was supposed to be one line :/
18:16:11 <tac_> One way to think about it,roughly, is as an "infintie game tree" with the user
18:16:57 <nshepperd> jmcarthur: yes. there's an implementation of universally quantified constraints in ekmetts constraints package, but it might not be nice to work with
18:17:12 <nshepperd> so maybe there's a use for an ApplicativeProfunctor class
18:17:24 <tac_> You will end up having something like a type for Commands that the runtime can perform
18:17:40 <tac_> and a type of Responses that the environment (user, OS) can reply with
18:19:24 <nshepperd> or you could call it Arrowish since you have 2/3rds (Profunctor, Applicative, Category) of Arrow
18:19:26 <Pamelloes> Huh, that makes sense. So IO would be type IO = Command -> Response?
18:19:28 <tac_> And an IO will be something like data IO a = (Command, Reply -> (a, IO a))
18:19:31 <tac_> or something like that
18:19:52 <tac_> I read a paper on it a while back, but it used dependent types
18:19:58 <tac_> But I think the above might work
18:20:00 <Pamelloes> Interesting
18:20:10 <tac_> The IO a object issues a command
18:20:14 <tac_> and then listens for a response
18:20:36 <orion> How do I set up my cabal file to allow unit testing of non-exposed modules?
18:20:40 <tac_> The Reponse -> (a, IO a)   (I typoed above and called it "Reply") can be though of
18:20:46 <jmcarthur> ApplicativeProfunctor is a fine candidate name. not sold on Arrowish
18:20:50 <tac_> as "one (a, IO a) pair for every possible response"
18:21:29 <jmcarthur> nshepperd: thanks
18:22:07 <bitemyapp> dysinger: cool stff
18:22:22 <dysinger> stff ?
18:22:45 <Pamelloes> tac_: I have to go, thanks for your explanation :)
18:22:56 <tac_> no problem
18:22:59 <tac_> see ya
18:23:07 <dysinger> bitemyapp ah http://www.stff.org/en/ yes I go to that every year
18:23:18 <nshepperd> some posts on fpcomplete about kan extensions talk about ways to implement IO as an ADT
18:23:30 <tac_> I'm sure they do
18:23:35 <tac_> ;X
18:23:44 * tac_ has no idea what a kan extension is
18:25:46 <Johannes13> interesting stuff, that Data.Typeable. show (typeOf gcd) = "Integer -> Integer -> Integer"
18:25:50 <bitemyapp> dysinger: *stuff*
18:26:00 <dysinger> :)
18:26:10 <nshepperd> I think the upshot of it was data IO a = Pure a | Roll Command (Reply -> IO a)
18:26:25 <nshepperd> except that you can make it faster with some church encoding mumbo jumbo
18:27:09 <gcganley> :t (>>=)
18:27:09 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:27:27 <gcganley> :t (flip >>=)
18:27:28 <lambdabot> ((b1 -> a -> c) -> (a -> b1 -> c) -> b) -> (a -> b1 -> c) -> b
18:27:36 <gcganley> :t (swap >>=)
18:27:36 <lambdabot> ((b1, a) -> (a, b1) -> b) -> (a, b1) -> b
18:27:41 <gcganley> :/
18:27:50 <gcganley> :t swap
18:27:51 <lambdabot> (a, b) -> (b, a)
18:27:52 <batchm> :t (flip (>>=))
18:27:53 <lambdabot> Monad m => (a -> m b) -> m a -> m b
18:27:59 <gcganley> oh lol
18:28:05 <batchm> and.. I have no clue why you got that garbage without parenthesis
18:28:23 <batchm> flip (>>=) is (=<<)
18:30:02 <Johannes13> :t flip (>>=)
18:30:02 <lambdabot> Monad m => (a -> m b) -> m a -> m b
18:30:13 <batchm> :t (flip >>=)
18:30:14 <lambdabot> ((b1 -> a -> c) -> (a -> b1 -> c) -> b) -> (a -> b1 -> c) -> b
18:30:16 <batchm> what is that crap all about?
18:30:19 <Johannes13> :t >>=
18:30:20 <lambdabot> parse error on input ‘>>=’
18:30:25 <Johannes13> :t id >>=
18:30:26 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
18:30:33 <gcganley> :t (>>=)
18:30:34 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:30:36 <Johannes13> :t (id >>=)
18:30:36 <lambdabot> (a -> a -> b) -> a -> b
18:30:41 <batchm> are we using the function monad there, or something?
18:30:51 <Johannes13> looks lik
18:30:51 <gcganley> :t flip
18:30:52 <Johannes13> e
18:30:52 <lambdabot> (a -> b -> c) -> b -> a -> c
18:30:58 <Johannes13> yeah, function monad
18:31:15 <gcganley> :t (.) >>=
18:31:16 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
18:31:24 <gcganley> :t ((.) >>=))
18:31:25 <lambdabot> parse error on input ‘)’
18:31:29 <Johannes13> :t ((.) >>=)
18:31:30 <gcganley> damn
18:31:30 <lambdabot> (((a -> b1) -> a -> c) -> (b1 -> c) -> b) -> (b1 -> c) -> b
18:31:36 <gcganley> yay weird types
18:32:08 <gcganley> :t (>=>)
18:32:09 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
18:32:51 <Johannes13> :t typeOf id
18:32:51 <lambdabot>     No instance for (Typeable a0) arising from a use of ‘typeOf’
18:32:52 <lambdabot>     The type variable ‘a0’ is ambiguous
18:32:52 <lambdabot>     Note: there are several potential instances:
18:32:54 <batchm> > (do x <- id; y <- (+1); z <- (^2); return (x, y, z)) 10
18:32:56 <lambdabot>  (10,11,100)
18:33:07 <Johannes13> :t typeOf gcd
18:33:07 <lambdabot> TypeRep
18:33:12 <Johannes13> > typeOf gcd
18:33:14 <lambdabot>  Integer -> Integer -> Integer
18:33:17 <Johannes13> > typeOf id
18:33:18 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
18:33:18 <lambdabot>    arising from a use of ‘Data.Typeable.Internal.typeOf’
18:33:18 <lambdabot>  The type variable ‘a0’ is ambiguous
18:33:18 <lambdabot>  Note: there are several potential instances:
18:33:18 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
18:34:31 <Johannes13> > cast id
18:34:32 <lambdabot>  Could not deduce (Data.Typeable.Internal.Typeable a0)
18:34:32 <lambdabot>    arising from a use of ‘Data.Typeable.cast’
18:34:32 <lambdabot>  from the context (Data.Typeable.Internal.Typeable b)
18:34:32 <lambdabot>    bound by the inferred type of
18:34:32 <lambdabot>             it :: Data.Typeable.Internal.Typeable b => Data.Maybe.Maybe b
18:34:34 <batchm> > sequence [id, (+1), (^2)] 10
18:34:35 <lambdabot>  [10,11,100]
18:34:41 <Johannes13> > cast id :: a -> b
18:34:43 <lambdabot>  Couldn't match expected type ‘a1 -> b1’
18:34:43 <lambdabot>              with actual type ‘Data.Maybe.Maybe b0’
18:34:53 <Johannes13> > cast id :: Maybe (a -> b)
18:34:54 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b1)
18:34:55 <lambdabot>    arising from a use of ‘Data.Typeable.cast’
18:35:06 <Johannes13> :t cast id :: Maybe (a -> b)
18:35:07 <lambdabot>     No instance for (Typeable b1) arising from a use of ‘cast’
18:35:07 <lambdabot>     In the expression: cast id :: Maybe (a -> b)
18:35:45 <Johannes13> :t cast id :: Maybe ((->) a b)
18:35:46 <lambdabot>     No instance for (Typeable b1) arising from a use of ‘cast’
18:35:46 <lambdabot>     In the expression: cast id :: Maybe ((->) a b)
18:35:50 <Johannes13> :t cast id :: Maybe ((->) a)
18:35:51 <lambdabot>     Expecting one more argument to ‘(->) a’
18:35:51 <lambdabot>     The first argument of ‘Maybe’ should have kind ‘*’,
18:35:51 <lambdabot>       but ‘(->) a’ has kind ‘* -> *’
18:36:11 <Hijiri> > typeOf (id :: Int -> Int)
18:36:12 <lambdabot>  Int -> Int
18:36:43 <Hijiri> no polymorphic TypeReps
18:36:52 <Johannes13> :(
18:36:53 <Hijiri> > typeOf (id :: Integral a => a -> a)
18:36:54 <lambdabot>  Integer -> Integer
18:37:04 <Hijiri> that doesn't count
18:37:04 <DTSCode> ok... i think i fgured out the let statement. can someone tell me if im write? the syntax is one of two things: let variable = value in expression, and then there is let function argument_s_ = expression in values passed
18:37:05 <L8D> What
18:37:15 <DTSCode> s/write/right/
18:37:17 <L8D> What's the name of Haskell's type inferer strategy?
18:38:08 <Johannes13> > foldr gcd [2,3]
18:38:09 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
18:38:09 <lambdabot>    arising from a use of ‘M106302492848487978523604.show_M1063024928484879785...
18:38:09 <lambdabot>  The type variable ‘t0’ is ambiguous
18:38:09 <lambdabot>  Note: there are several potential instances:
18:38:09 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
18:38:21 <batchm> L8D hindley-milner ?
18:38:27 <L8D> batchm: THANK YOU
18:38:45 <Hijiri> I thought HM was just the name of the type system? or is the inferer strategy part of the type system
18:39:34 <mauke> DTSCode: let { EQUATIONS } in EXPR
18:39:44 <Hijiri> it's also not just plain HM, for example typeclasses
18:39:44 <mauke> actually, DECLARATIONS
18:39:55 <DTSCode> hmmm ty
18:40:00 <mauke> > let { foo :: Int; foo = 42 } in foo
18:40:01 <lambdabot>  42
18:40:02 <alrunner4> isn't GHC's algorithm based on http://research.microsoft.com/en-us/um/people/simonpj/papers/constraints/jfp-outsidein.pdf these days?
18:40:04 <Hijiri> without even mentioning type families, GADTs, other fancy things I don't know that well yet
18:40:23 <L8D> okay.... where should I go to learn about how Haskell's type system is implemented?
18:40:27 <mauke> > let { foo = bar + 1; bar = 41 } in foo
18:40:28 <lambdabot>  42
18:41:17 <Hijiri> the paper that alrunner4 posted I guess
18:50:15 <L8D> is there some way I can leverage the existing code used in GHC as a library?
18:50:30 <L8D> for type checking and inference
18:50:41 <RchrdB> L8D: maybe. GHC has an API.
18:50:44 <gcganley> ghc does come with an API i belive
18:51:24 <L8D> but I don't want to compile Haskell, I'm wanting to apply Haskell's type system to another language
18:51:34 <L8D> could I use GHC's API for that?
18:51:41 <gcganley> i belive so
18:51:44 <L8D> ok
18:52:02 <gcganley> ghcjs uses the ghc API to typecheck the haskell then compile it to javascript
18:52:29 <gcganley> are you just curious or is there a use case you were thinking of
18:55:04 <L8D> I'm trying to write a type system for JavaScript
18:55:08 <RchrdB> L8D: AIUI, using GHC's API for any phase of compiling from a source language that isn't Haskell is unlikely to work well. You may want to start out by reading documentation about how GHC works rather than trying to directly apply it.
18:55:12 <L8D> with annotations done in comments
18:55:21 <simpson> Oh, like the Closure compiler.
18:55:31 <L8D> sort of
18:55:35 <gcganley> closure compiler is the bomb
18:55:44 <L8D> Closure compiler doesn't have a type system?
18:55:48 <gcganley> i used the closure compiler when i learned clojure
18:55:52 <alrunner4> L8D: better than TypeScript?
18:55:54 <RchrdB> L8D: you may want to look at TypeScript.
18:56:03 <simpson> https://developers.google.com/closure/compiler/docs/js-for-compiler
18:56:13 <simpson> L8D: ^^ It totally has types.
18:56:15 <L8D> I'm very familiar with TypeScript and Flow
18:56:37 <L8D> the point is to use HASKELL's type system
18:56:42 <gcganley> L8D: have you checked out GHCJS or fay?
18:56:47 <L8D> which is like 10x more powerful
18:57:01 <L8D> I'm very familiar with GHCJS, Haste, PureScript and Fay
18:57:03 <simpson> Haskell's type system can't deal with retyping names.
18:57:16 <simpson> var a = 42; a = "42"; /* What now? */
18:57:25 <L8D> ^ would be a type error
18:57:34 <L8D> like so:
18:57:46 <L8D> > let { a = 42; a = "42" } in a
18:57:47 <lambdabot>  Conflicting definitions for ‘a’
18:57:47 <lambdabot>  Bound at: <interactive>:1:7
18:57:47 <lambdabot>            <interactive>:1:15
18:57:55 <gcganley> but thats not a type error in javascript...
18:57:58 <simpson> Sure, but JS is not Haskell.
18:58:14 <L8D> gcganley: WHICH IS THE POINT OF THE TYPE SYSTEM
18:58:33 <simpson> Anyway, clearly I'm just getting in the way. Best of luck!
18:58:34 <L8D> to make these things errors
18:59:10 <gcganley> i wonder if there are some sort of static analysis tools for that sorta thing :/
18:59:28 <trap_exit> are there any studies relating # of monitors and haskell productivity? in particular, how many monitors do some of hte most prodcutive haskellers use?
18:59:45 <trap_exit> k.e. the two simons, edwardk, dons, .... hackers of ghc, xmonad, packages on cabal
18:59:45 <L8D> trap_exit: uno
18:59:49 <trap_exit> how many monitors do they use ?
18:59:52 <L8D> uno
18:59:57 <L8D> one
18:59:58 <L8D> 1
19:00:00 <Hijiri> I'm pretty unproductive but I use one monitor with tiling
19:00:06 <L8D> ^
19:00:08 <L8D> xmonad ftwe
19:00:12 <L8D> although I use two monitors
19:00:23 <trap_exit> i'm finding my triple monitor setup distracting
19:00:28 * hackagebot google-drive 0.1.0 - Google Drive API access  http://hackage.haskell.org/package/google-drive-0.1.0 (PatrickBrisbin)
19:00:29 <trap_exit> like my eyes have no idea where the fuck to look
19:00:36 <L8D> trap_exit: 90% of Haskellers use one monitor
19:00:36 <gcganley> i use two monitors with emacs so i have enough space to do pretty much anything
19:00:42 <trap_exit> whether to look at emacs, docs, or the youtube video playing on monitor 3
19:00:46 <gcganley> wow google drive support thats neat
19:00:47 <MP2E> i use a tiling wm but to help me focus I typically just have one window per workspace in fullscreen
19:00:52 <MP2E> heh :P
19:00:54 <batchm> one 30" monitor is enough for me
19:01:04 <gcganley> batchm: what res?
19:01:06 <MP2E> 1 monitor is fine for me too
19:01:17 <gcganley> one monitor to rule them all
19:01:43 <batchm> 2560x1600. I will not buy monitor with very high ppi until all the software starts properly supporting it
19:01:47 <Hijiri> It only occured to me a couple days ago that I should take tutorial tabs in my browser to a separate window and have them in the same workspace as the code
19:02:03 <Hijiri> before then I was switching between workspaces (my main browser window is fullscreen)
19:02:05 <L8D> ew... tutorial tabs
19:02:12 <L8D> why not just use the documentation?
19:02:24 <Hijiri> which documentation?
19:02:37 <Hijiri> I was reading a post on lens
19:02:45 <gcganley> batchm: damn, yeah that'll work just fine
19:02:50 <L8D> like... people want tutorials to learn how to use things when the documentation is perfectly adequite
19:03:00 * L8D doesn't know how to spell adequite
19:03:06 <Hijiri> the lens documentation is scary without lens knowledge though
19:03:10 <trap_exit> alright
19:03:15 <trap_exit> I need to get rid of 2 of http://www.amazon.com/gp/product/B009H0XQPA/
19:03:17 <trap_exit> suggestions ?
19:03:22 <L8D> it's how I learned most of my Haskell stuff
19:03:23 <edwardk> Hijiri: i confess i wrote lens for me, then somehow users showed up
19:03:35 <gcganley> L8D: some docs are spooky. i start with tutorials and then get deeper into dofcs as i need more stuff
19:03:47 <gcganley> s/dofcs/docs
19:04:02 <jack_rabbit> trap_exit, mail one to me.
19:04:10 <L8D> trap_exit: donate them to your local Haskell meetup or coworking space
19:04:17 <trap_exit> jack_rabbit: will you pay for shipping?
19:04:24 <jack_rabbit> trap_exit, sure.
19:04:27 <gcganley> lens are fucking scary. then again so were monads
19:04:37 <nshepperd> > let a = 42 in let a = "42" in a
19:04:38 <lambdabot>  "42"
19:04:50 <L8D> monads were fucking scary until I just paid attention to the type signature
19:05:04 <L8D> nshepperd: you monster
19:05:13 <DTSCode> is the haskell site down?
19:05:13 <gcganley> nshepperd: MY EYES
19:05:18 <dfeuer> DTSCode, yes.
19:05:22 <DTSCode> damn
19:05:22 <L8D> DTSCode: yes.
19:05:27 <DTSCode> damn damn
19:05:28 * hackagebot extensible-effects 1.7.1.2 - An Alternative to Monad Transformers  http://hackage.haskell.org/package/extensible-effects-1.7.1.2 (shergill)
19:05:35 <L8D> damn damn damn
19:05:35 <Yxven> a lot of docs aren't adequate
19:05:36 <nshepperd> :D
19:05:42 <dfeuer> DTSCode, big hardware failure. And they decided to take the opportunity to do a big migration.
19:05:52 <dfeuer> DTSCode, lurk in #haskell-infrastructure for more details.
19:05:55 <gcganley> finally!
19:06:05 <L8D> it's a good think that cabal automatically compiles haddock documentation locally
19:06:06 <DTSCode> dfeuer: ok ty
19:06:09 <gcganley> hasnt that migration been forever in the working
19:06:28 <L8D> Haskell.org should use erlang
19:06:33 <dfeuer> ?
19:06:45 <gcganley> also when is hackage 2 coming out?
19:06:56 <gcganley> or is already out and im just way behind on my news...
19:07:02 <dfeuer> gcganley, hasn't it been running Hackage for ages now?
19:07:32 <gcganley> dfeuer: there was supposed to be an updated hackage coming out of a google summer of code project
19:07:45 <dfeuer> gcganley, I think it did.
19:08:04 <nshepperd> Hackage 2, now a major motion picture
19:08:13 <gcganley> dfeuer: i need to stop listening to 2 year old podcasts...
19:08:56 <nshepperd> I think the real problem with let { a = 42; a = "42" } is that bindings in the same let-scope don't have any particular ordering or precedence
19:09:08 <nshepperd> > let {a = 1; a = 2 } in a
19:09:09 <lambdabot>  Conflicting definitions for ‘a’
19:09:09 <lambdabot>  Bound at: <interactive>:1:6
19:09:09 <lambdabot>            <interactive>:1:13
19:10:04 <gcganley> sometimes lambdabot makes me cry
19:10:11 <nshepperd> you can shadow a name, but it's meaningless to try and define it twice simultaneously
19:10:53 <dfeuer> gcganley, does it make you cry because it's not yet sentient?
19:11:21 <jmcarthur> > let a = 1 in let a = 2 in a
19:11:22 <lambdabot>  2
19:11:41 <gcganley> dfeuer: what are you talking about, this is the movie him. a varient of her
19:12:00 <dfeuer> ?
19:12:08 <gcganley> the spike lee movie
19:12:18 <L8D> dfeuer: "her"
19:12:19 <gcganley> i think that was directed by spike lee...
19:12:21 <L8D> the movie
19:12:30 <batchm> > let a = 1 in (let a = 2 in a, a)
19:12:31 <lambdabot>  (2,1)
19:12:34 <L8D> I know it's cover was red with a face on it
19:12:46 <dfeuer> gcganley, no idea what you mean.
19:12:53 <gcganley> its a movie about a man falling in love with a computer AI
19:13:02 <L8D> https://en.wikipedia.org/wiki/Her_(film)
19:13:24 <L8D> Spike Jonze
19:13:27 <seafood> Is the haskell.org website down?
19:13:34 <gcganley> seafood: yes
19:13:41 <nshepperd> unfortunately, lambdabot's sentience is limited to berating us for typos
19:14:00 <seafood> gcganley: Thanks.
19:14:14 <L8D> wait a second
19:14:20 <L8D> just think about it.
19:14:47 <L8D> lambdabot would be the perfect platform to test an experimental AI algorithim with
19:14:56 <gcganley> how so
19:15:02 <L8D> for learning things slowly over time
19:15:18 <gcganley> learning typos and how to fix them?
19:15:22 <L8D> people are constantly giving input to it, but in a very simple and easy-to-parse way
19:15:35 <L8D> (easy to parse in comparison to watching videos or looking at images)
19:16:06 <L8D> and if it was an AI, no one would be the wiser
19:16:34 <nshepperd> you could use sentiment analysis on the #haskell chat to find out whether monads make people happier or sadder on average
19:17:17 <seafood> gcganley: It was direct by Spike Jonze. But Spike Lee is also excellent.
19:18:50 <gcganley> seafood: i can see where i may have been mistaken
19:22:26 <Zer000> gents I have a list of n numbers and a list of n-1 dyadic functions. I need to take the first two values, feed them to the first function, then the result of that and the next value to the next function and so on until I get the result. I'm not really sure how to begin
19:24:16 <gcganley> that sounds like an odd mix of foldable and applicative
19:25:11 <Zer000> gcganley, foldable and applicative what exactly? I should have mentioned I'm a beginner
19:25:32 <Zer000> err unless that wasn't directed at me
19:25:44 <gcganley> Zer000: is this for uni
19:25:49 <gcganley> and yes that was for you
19:27:05 <Zer000> no - actually I'm trying to solve this problem http://imgur.com/279IhjI posted on reddit using a haskell program
19:27:10 <gcganley> so dyadic functions are (a -> a -> a)?
19:27:12 <Zer000> yes
19:27:31 <Hijiri> If you don't know Foldable and Applicative yet you could just do it recursively on both lists with pattern matching
19:27:54 <Hijiri> maybe some other list-specialized functions could be used to simplify it
19:28:28 <gcganley> :t foldl'
19:28:29 <lambdabot> (b -> a -> b) -> b -> [a] -> b
19:28:41 <L8D> :t foldl
19:28:42 <lambdabot> (b -> a -> b) -> b -> [a] -> b
19:28:48 <Hijiri> there's two lists to go over though
19:28:55 <batchm> Zer000 perhaps zipping functions with list elements and then folding on the resulting list
19:29:02 <L8D> @src foldl'
19:29:02 <lambdabot> foldl' f a []     = a
19:29:02 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
19:29:05 <L8D> @src foldl
19:29:05 <lambdabot> foldl f z []     = z
19:29:06 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
19:29:21 <gcganley> the difference is it forces the thunk
19:29:31 <L8D> when is that useful?
19:29:34 <Hijiri> maybe you could have a sort of backwards accumulator that holds the remaning functions, but that would be unwieldy
19:29:35 <gcganley> much better performancs on small lists
19:29:40 <Hijiri> when you don't want to accumulate thunks
19:29:49 <gcganley> or big lists really
19:29:58 <batchm> Zer000 what is your input and desired output?
19:30:02 <gcganley> just dont use normal foldl is what ive been told
19:30:03 <L8D> so better performance in general?
19:30:08 <Hijiri> Any time the function isn't a constructor
19:30:21 <gcganley> L8D: its so you dont build massive thunk chain
19:30:28 * hackagebot sbv 3.2 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  http://hackage.haskell.org/package/sbv-3.2 (LeventErkok)
19:30:34 <L8D> is there ever a constructor with type b -> a -> b ?
19:30:35 <Hijiri> if it's a constructor then you can use foldr
19:30:44 <Hijiri> :t (:)
19:30:45 <lambdabot> a -> [a] -> [a]
19:30:49 <Hijiri> :t flip (:)
19:30:50 <L8D> what about scanl ?
19:30:50 <lambdabot> [a] -> a -> [a]
19:31:01 <gcganley> :t foldl'
19:31:01 <lambdabot> (b -> a -> b) -> b -> [a] -> b
19:31:12 <L8D> @src scanl'
19:31:13 <lambdabot> Source not found. You speak an infinite deal of nothing.
19:31:29 <Hijiri> scanl calculates the intermediate steps already
19:31:47 <Zer000> batchm, I can't zip the lists since they are different lengths...
19:31:59 <Hijiri> at least, I think it does
19:32:07 <L8D> so with scanl it doesn't matter
19:32:12 <Hijiri> maybe it will have a pyramid of thunks, I'm not sure
19:32:21 <gcganley> @src scanl
19:32:21 <lambdabot> scanl f q ls = q : case ls of
19:32:21 <lambdabot>     []   -> []
19:32:21 <lambdabot>     x:xs -> scanl f (f q x) xs
19:32:25 <L8D> > take 10 $ scanl (+) 0 [1..]
19:32:26 <lambdabot>  [0,1,3,6,10,15,21,28,36,45]
19:32:34 <gcganley> it looks like it builds thunks...
19:32:42 <Zer000> what's a thunk?
19:32:45 <L8D> > take 10 $ 0:scanl (+) 1 [1..]
19:32:46 <lambdabot>  [0,1,2,4,7,11,16,22,29,37]
19:32:53 <Hijiri> a thunk is an unevaluated expression
19:32:56 <L8D> Zer000: an unevaluated thunk
19:33:01 <gcganley> Zer000: a thunk is an unevaluated expression
19:33:10 <L8D> Zer000: which means it can either be a value or an error
19:33:16 <L8D> or just unevaluated
19:33:33 <Zer000> ah
19:33:39 <Hijiri> it could be a non-error bottom
19:33:40 <gcganley> or _|_
19:33:42 <gcganley> lol
19:33:48 <Zer000> that's undefined isn't it?
19:33:53 <gcganley> yes
19:34:02 <Hijiri> anything where the calculation doesn't terminate is bottom
19:34:04 <L8D> doesn't haskell catch most bottoms?
19:34:07 <Hijiri> that includes infinite recursion
19:34:15 <Hijiri> not if it recurses indefinitely
19:34:15 <L8D> > last [0..]
19:34:19 <lambdabot>  mueval-core: Time limit exceeded
19:34:24 <Hijiri> lambdabot just catches that
19:34:25 <Zer000> lol
19:34:43 <L8D> well some types of recursion it catches
19:34:45 <MP2E> notice lambdabot cheats though, it just puts a time limit on calculations :)
19:34:52 <gcganley> its from the 40's and had a really long name. like the eufindisher problem talking about how some programs will never terminate and how to determine which programs those are
19:35:27 <mauke> what, the decision problem?
19:35:29 <L8D> gcganley: yes but there are still different forms that can be detected
19:35:42 <L8D> like, indefinitely takeMVar'ing
19:36:06 <L8D> > forever (Just 1)
19:36:10 <lambdabot>  mueval-core: Time limit exceeded
19:36:13 <L8D> -.-
19:36:37 <L8D> > let f 0 = f 0; f x = x + 1 in f 0
19:36:40 <lambdabot>  mueval-core: Time limit exceeded
19:36:51 <L8D> well it works in ghci
19:37:25 <Hijiri> what version?
19:37:29 <Hijiri> it's not terminating for me
19:37:35 <Hijiri> but I'm using 7.6.3
19:38:07 <L8D> 7.8.3
19:39:51 <gcganley> compiles fine on ghc-head
19:39:57 <dfeuer> 7.8.3 is so old.
19:40:22 <L8D> yeah yeah... 7.10 is the new hotness
19:40:30 <L8D> er... 7.9 for now
19:40:46 <dfeuer> 7.12 all the way.
19:40:48 <mauke> don't be so eager
19:41:03 <dfeuer> mauke, I ain't eager; I lazy.
19:41:10 <gcganley> yeah! monad-applicative
19:41:45 <dfeuer> I made Data.Foldable.fold[rl]1 and Data.List.unwords  lazier for 7.10 :-P
19:42:17 <gcganley> :t foldr1
19:42:18 <lambdabot> (a -> a -> a) -> [a] -> a
19:42:33 <dfeuer> gcganley, wrong one.
19:42:36 <gcganley> i forgot about fold[rl]1
19:42:39 <dfeuer> :t Data.Foldable.foldr1
19:42:40 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
19:42:46 <gcganley> oh ok
19:42:50 <gcganley> woops
19:43:08 <gcganley> when are they merging Foldable into the prelude
19:43:10 <gcganley> like really
19:43:23 <dfeuer> But the default one in Foldable was accidentally potentially too strict.
19:43:37 <dfeuer> gcganley, in its entirety? Maybe never.
19:43:52 <dfeuer> But a lot of it is happening in 7.10.
19:44:38 <zymurg> @pl \x y -> x+y==100
19:44:38 <lambdabot> flip flip 100 . ((==) .) . (+)
19:44:40 <gcganley> right now im just happy they are doing the monad-applicative proposal. it makes perfect sense and they are finally doing it
19:44:54 <gcganley> :t flip flip
19:44:55 <lambdabot> b -> (a -> b -> c) -> a -> c
19:45:04 <dfeuer> gcganley, see how hard it was to get Word in the Prelude. And how people are fighting tooth and nail about the details of Natural.
19:45:19 <gcganley> :k Nat
19:45:20 <lambdabot> Not in scope: type constructor or class ‘Nat’
19:45:28 <merijn> gcganley: You mean
19:45:29 <merijn> :k 1
19:45:30 <lambdabot> GHC.TypeLits.Nat
19:45:37 <gcganley> woops
19:45:38 <merijn> Nat is already a kind :p
19:45:39 <gcganley> yeah
19:45:40 <dfeuer> gcganley, it's apparenly going to be Natural, rather than Nat, and it doesn't exist yet.
19:45:53 <dfeuer> But people can't agree on subtraction, or where it should go.
19:46:31 <gcganley> ive been watching the edwardk talks and i kind of think all that mumbo jumbo is defined
19:46:44 <dfeuer> All what what?
19:47:05 <gcganley> its his talk on the category Hask
19:47:08 <gcganley> ill find it
19:47:24 <dfeuer> I'll mumbo your jumbo.
19:47:42 <gcganley> https://www.youtube.com/watch?v=Klwkt9oJwg0 -- Edward Kmett on Hask
19:47:56 <mauke> I'll banjo your kazooie
19:48:44 <zymurg> @pl \f (a, b) -> f a b
19:48:44 <lambdabot> (`ap` snd) . (. fst)
19:48:52 <zymurg> :t ap
19:48:53 <lambdabot> Monad m => m (a -> b) -> m a -> m b
19:49:15 <gcganley> zymurg: whatcha doin there?
19:49:40 <gcganley> :t (<*>)
19:49:41 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
19:49:49 <dfeuer> Thanks, gcganley.
19:50:09 <gcganley> dfeuer: its super mind bendy stuff
19:50:29 * hackagebot spritz 0.1.0.0 - An implementation of the Spritz RC4-like stream cipher in Haskell  http://hackage.haskell.org/package/spritz-0.1.0.0 (RickyElrod)
19:50:36 <mauke> :t curry
19:50:36 <lambdabot> ((a, b) -> c) -> a -> b -> c
19:50:47 <gcganley> :t uncurry
19:50:48 <lambdabot> (a -> b -> c) -> (a, b) -> c
19:51:01 <gcganley> :t (swap curry)
19:51:02 <lambdabot>     Couldn't match expected type ‘(a, b)’
19:51:02 <lambdabot>                 with actual type ‘((a0, b0) -> c0) -> a0 -> b0 -> c0’
19:51:02 <lambdabot>     Probable cause: ‘curry’ is applied to too few arguments
19:51:09 <batchm> :t curry uncurry
19:51:10 <lambdabot>     Couldn't match type ‘a1 -> b1 -> c’ with ‘(a, b)’
19:51:10 <lambdabot>     Expected type: (a, b) -> (a1, b1) -> c
19:51:10 <lambdabot>       Actual type: (a1 -> b1 -> c) -> (a1, b1) -> c
19:51:17 <gcganley> damn
19:51:28 <c74d> :t curry . uncurry
19:51:28 <lambdabot> (a -> b -> c) -> a -> b -> c
19:51:37 <gcganley> there we go
19:51:40 <batchm> :t uncurry curry
19:51:41 <lambdabot> ((b, b1) -> c, b) -> b1 -> c
19:51:58 <gcganley> :t (&&&)
19:51:59 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
19:52:13 <gcganley> nope
19:52:19 <gcganley> :t (***)
19:52:20 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
19:52:24 <gcganley> not that one either
20:04:43 <L8D> :t curry uncurry
20:04:44 <lambdabot>     Couldn't match type ‘a1 -> b1 -> c’ with ‘(a, b)’
20:04:44 <lambdabot>     Expected type: (a, b) -> (a1, b1) -> c
20:04:44 <lambdabot>       Actual type: (a1 -> b1 -> c) -> (a1, b1) -> c
20:04:48 <L8D> -.-
20:05:01 <L8D> :t uncurry . curry
20:05:02 <lambdabot> ((a, b) -> c) -> (a, b) -> c
20:17:51 <L8D> @pl \x f -> f x
20:17:51 <lambdabot> flip id
20:18:42 <L8D> :t \xf -> f x
20:18:43 <lambdabot> FromExpr t1 => t -> t1
20:18:52 <L8D> -.-
20:18:55 <L8D> :t \x f -> f x
20:18:56 <lambdabot> t1 -> (t1 -> t) -> t
20:19:23 <L8D> :t (>>=)
20:19:23 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:20:04 <L8D> so (>>=) = flip id for Identity
20:20:57 <Axman6> I'm not sure that's right...
20:21:08 <L8D> how so?
20:22:18 <L8D> :t
20:22:27 <L8D> :t f x
20:22:28 <lambdabot> FromExpr t => t
20:22:41 <L8D> what is this shit?
20:23:09 <simpson> IIRC it's Expr from simple-reflect.
20:23:35 <L8D> effing reflection
20:25:29 * hackagebot hspec-contrib 0.2.0 - Contributed functionality for Hspec  http://hackage.haskell.org/package/hspec-contrib-0.2.0 (SimonHengel)
20:26:07 <AR45> Hello I want to learn Haskell. Where do I start?
20:26:24 <shachaf> @where faq
20:26:25 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
20:26:29 <batchm> what languages, if any, do you know already?
20:26:35 <shachaf> Oh, bad link.
20:26:35 <Hijiri> https://github.com/bitemyapp/learnhaskell
20:26:53 <dfeuer> AR45, most people start with either "Learn You a Haskell for Great Good" or "Real World Haskell", but yes, bitemyapp has a good list.
20:27:16 <Hijiri> haskell.org is dead right now
20:27:29 <Hijiri> which could be a problem if you want to use hoogle while learning
20:27:33 <dfeuer> Hopefully it will be back within a few hours.
20:27:35 <Hijiri> or look anything on there up
20:28:01 <dfeuer> Well, "back" on a completely new system.
20:28:01 <MaxGabriel> fpcomplete has a hoogle if you need it https://www.fpcomplete.com/hoogle
20:28:44 <L8D> we're getting new-www.haskell.org woot!
20:29:00 <merijn> See also: https://status.haskell.org/
20:29:54 <dfeuer> Yes, merijn, updated 8 hours ago.
20:30:29 * hackagebot hspec-test-framework-th 0.0.0 - Run test-framework tests with Hspec  http://hackage.haskell.org/package/hspec-test-framework-th-0.0.0 (SimonHengel)
20:30:50 <Zer000> I really confused myself. I defined "combine f g = \x y z -> g (f x y) z" and I don't get how this for example would be evalueated: "combine (+) (combine (-) (*))" (in what order)
20:31:30 <shachaf> Zer000: One step at a time.
20:31:34 <L8D> Zer000: @pl \f g -> \x y z -> g (f x y) z
20:31:37 <L8D> @pl \f g -> \x y z -> g (f x y) z
20:31:37 <lambdabot> flip ((.) . (.))
20:31:43 <L8D> roflmao
20:31:49 <shachaf> L8D: Do you really think you're helping?
20:31:55 <L8D> I didn't expect that
20:32:02 <shachaf> Someone is confused about what some piece of code does, so let's make it way more complicated to help them?
20:33:00 <shachaf> Zer000: You can substitute: combine (-) (*) = \x y z -> (*) ((-) x y) z = \x y z -> (x - y) * z
20:33:21 <shachaf> Call that foo: foo a b c = (a - b) * c
20:33:33 <L8D> I was hoping for something like: combine f g x y = g (f x y)
20:33:54 <shachaf> combine (+) foo = \x y z -> foo ((+) x y) z = foo (x + y) z
20:34:18 <L8D> wait... can you use operators as function arguments?!
20:34:41 <shachaf> = \x y z -> (\a b c -> (a - b) * c) (x + y) z
20:34:43 <L8D> > (\(+) -> 1 + 2) (*)
20:34:44 <lambdabot>  2
20:34:50 <L8D> my life has changed
20:35:12 <shachaf> = \z -> (\c -> ((x + y) - z) * c)
20:35:31 <L8D> = \z c -> ((x + y) - z) * c
20:35:31 <shachaf> Er...
20:35:32 <Zer000> shachaf, thank you very much that really helped!!
20:35:50 <shachaf> OK, I messed it up a bit in the middle there. But it looks like you got the idea.
20:36:20 <shachaf> Just substitute step by step.
20:37:23 <dfeuer> L8D, @pl *almost* never makes code more readable.
20:37:48 <L8D> dfeuer: is there a function that does?
20:38:10 <dfeuer> Mmmm... the opposite, sometimes.
20:38:25 <dfeuer> @pointy ap xs ys
20:38:25 <lambdabot> (xs >>= \ b -> ys >>= \ a -> return (b a))
20:38:59 <shachaf> It's useful to use /msg lambdabot to investigate @pl, when you're not sure that it won't terribly confuse the person you're talking to.
20:39:56 <L8D> but /msg lambdabot is so tedious
20:40:08 <L8D> when you have like 50+ irc channels open
20:40:08 <dfeuer> L8D, that's what /query lambdabot is for.
20:40:28 <dfeuer> If you have 50+ IRC channels open, that is another problem.
20:40:29 * hackagebot linear 1.15.1 - Linear Algebra  http://hackage.haskell.org/package/linear-1.15.1 (EdwardKmett)
20:40:48 <MP2E> wat 50
20:40:51 <L8D> the default for irssi to start a /query on /msg instead of doing an inline thing
20:40:57 <L8D> MP2E: it's hard to explain
20:41:15 <L8D> basically: botnets
20:41:35 <dfeuer> . . .
20:42:10 <L8D> bascially: kids who play minecraft are gullible
20:42:28 <shachaf> L8D: This is not a good topic for this channel.
20:42:51 <L8D> agreed
20:44:49 <simpson> L8D: Contribute to Baskerville, the Minecraft server written in Haskell.
20:45:02 <simpson> https://github.com/bravoserver/baskerville
20:45:10 <MP2E> neat!
20:45:29 * hackagebot hspec-test-framework 0.1.0 - Run test-framework tests with Hspec  http://hackage.haskell.org/package/hspec-test-framework-0.1.0 (SimonHengel)
20:45:31 * hackagebot hspec-test-framework-th 0.1.0 - Run test-framework tests with Hspec  http://hackage.haskell.org/package/hspec-test-framework-th-0.1.0 (SimonHengel)
20:45:37 <L8D> simpson: nice!
20:46:22 <simpson> It's still in the earliest of early stages, because I stopped caring about Minecraft, but there's a maintainer, a channel, and a bunch of people who like Minecraft.
20:46:53 <emmanueloga> Hi. Somebody mentioned that the next version of Haskell may include some sort of new, first-class extensible records feature. Does anybody have a link to a discussion about that?
20:47:02 <L8D> oh well I've stopped caring about Minecraft too :(
20:47:02 <emmanueloga> Last thing I found about that is https://ghc.haskell.org/trac/ghc/ticket/1872 (22 months old!)
20:49:53 <meiji11> st
20:50:45 <emmanueloga> hmmm, perhaps https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields ?
20:53:15 <merijn> emmanueloga: I doubt haskell will have first-class extensible records any time soon
20:53:48 <merijn> OverloadedRecordFields allow record accessors to be shared between types, but that' not close to similar
20:56:04 <Zer000> hoogle and haskell docs are down, is that a known thing?
20:56:16 <shachaf> It is known.
20:56:28 <benzrf> what the heck is an extensible record
20:57:12 <Zer000> if I define a function in my Main.hs module (but never use it) can I load that function into ghci?
20:57:18 <Zer000> if so how do I do it?
20:57:28 <L8D> Zer000: :load Main.hs
20:57:33 <L8D> or just :load Main
20:57:40 <merijn> benzrf: Basically, you know how python classes are maps of member names (strings) to the value of that member and how you can simply "add" members to one?
20:57:41 <Zer000> cool! ty
20:57:49 <benzrf> yea
20:57:52 <merijn> benzrf: Imagine that, but with static typing to check the type and presence of a field
20:57:54 <benzrf> merijn: well, py objs
20:58:07 <benzrf> merijn: is this anything like the row typing PS uses to handle js objs
20:58:19 <merijn> benzrf: Probably
20:58:26 <merijn> benzrf: Ur does something similar using row typing
21:16:00 <codygman> Anyone know why this function would cause my program to hang? addToMap pairs m = head $ map (\(k,v) -> M.insert k v m) pairs
21:16:32 <Axman6> what is pairs?
21:17:03 <Axman6> also, that seems like an odd definition for a thing which adds only a single pair to the passed in map
21:17:16 <Axman6> /for a thing named as it is
21:17:54 <shachaf> @free head
21:17:55 <lambdabot> f . head = head . $map f
21:17:59 <Hijiri> are you creating a map for every element of the list?
21:17:59 <shachaf> Free theorems to the rescue!
21:18:32 <shachaf> lambdabot tells us that you can rewrite that as addToMap pairs m = (\(k,v) -> M.insert k v m) (head pairs)
21:18:36 <Hijiri> you're writing this as  if haskell has mutable state in pure code
21:18:56 <Hijiri> This will only give you the result of adding the first element to the map
21:19:07 <shachaf> Hijiri: I think you're making too many assumptions about codygman's mental state/intention.
21:19:16 <Hijiri> ok, sorry
21:19:27 <Hijiri> but a fold is probably what what work here
21:19:29 <shachaf> Well, you might be right, who knows.
21:19:38 <Hijiri> yeah, I shouldn't assume
21:19:43 <shachaf> But it's a good idea to ask codygman what they want and what they expected, rather than guess.
21:19:58 <shachaf> That way they'll learn to ask better questions, if nothing else!
21:20:00 <Thule> Hi guys. I do not understand why the type for step is not correct. I do not understand the error message - can any of you help? I know I can just not write the type, but I would like to know why, it does not work. http://lpaste.net/114544
21:20:49 <shachaf> Thule: Those 'a's aren't the same.
21:20:55 <codygman> Axman6: I'm trying to add a list of tuples to a map with that function.
21:21:03 <shachaf> Thule: I.e. it's the same as if you wrote step :: b -> [b] -> [b]
21:21:09 <shachaf> Thule: It's a comlpetely different a.
21:21:28 <shachaf> You can get around that with an extension called ScopedTypeVariables, if you want this behavior.
21:22:04 <Thule> shachaf but even though it is a different a, why does it not work? (I have treid with b -> [b] -> [b] also, so I thought it might be the same)
21:22:24 <shachaf> Thule: Oh, you're right, I didn't look carefully enough.
21:22:31 <Axman6> codygman: what you've written just adds the first pair to the map and returns it.
21:22:32 <shachaf> Thule: Oh, no, I did.
21:22:41 <shachaf> Thule: You're trying to use pred, which is :: a -> Bool, on a b.
21:22:48 <Axman6> (it = the map that was passed in, with the pair added)
21:23:41 <adas> are there any signature libraries in haskell? yesod and repa come to mind. Anything else?
21:23:43 <Thule> isn't x of type a according to takeWhile2 types?
21:23:43 <codygman> Hijiri: I was treating it as mutable, I guess what I wanted to do was a fold.
21:23:56 <Thule> since xs is type [a]
21:24:11 <codygman> Axman6: So to add all elements of a tuple and return the resulting map I'd want fold right?
21:24:13 <Axman6> adas: signature libraries?
21:24:34 <Axman6> codygman: yep. there are probably other ways too though
21:25:02 <Hijiri> oh, hoogle's back up
21:25:05 <Hijiri> did someone already note that
21:25:07 <adas> Axman6: yea .. i mean libraries that are well known in the haskell community and libraries that might make other folks want to start using haskell.. Parsec and attoparsec is another that comes to mind
21:25:13 <Thule> shachaf:  can you tell me what the type is for step?
21:25:17 <Thule> I cannot figure it out
21:26:00 <shachaf> Thule: You can't really write it in normal Haskell.
21:26:04 <Thule> Is it because it depends on what is passed to takeWhile2 and therefore only works with type inference?
21:26:11 <Thule> ah ok
21:26:54 <Thule> Thank you
21:27:12 <Axman6> adas: depends on the audience; parsec/attoparsec are quite cool, at a lower level all the parallelism and concurrency stuff in the language should be touted because it makes some very hard problems much easier
21:28:29 <adas> Axman6: is there any library that is defacto for doing concurrenc and parallelism?
21:29:20 <Axman6> well, Control.Concurrent is the obvious place to start; then there's the async library for some nice reusable patterns
21:30:14 <L8D> adas: Data.Lens ?
21:30:23 <L8D> I guess that wouldn't make others want to use Haskell
21:30:28 <Hijiri> If you want parallelism without concurrency there's http://hackage.haskell.org/package/parallel-3.2.0.4
21:30:29 * hackagebot geodetic 0.1.2 - Geodetic calculations  http://hackage.haskell.org/package/geodetic-0.1.2 (TonyMorris)
21:30:39 <L8D> hasql is pretty sweet though
21:30:55 <L8D> and any of the web frameworks should be motivation enough to use Haskell
21:31:04 <Axman6> the Text library is very cool
21:31:12 <Axman6> oh, Haxl from Facebook is really awesome too
21:31:16 <adas> persist, esqueleto
21:31:28 <L8D> Axman6: but non-Haskellers wouldn't understand why it's so useful
21:32:09 <adas> thanks for all the examples.. i wanted to ask this question cos this morning a colleague at work asked me about signature libraries in haskell and i could only tell him only 2 or 3
21:32:41 <Axman6> L8D: I doubt that, it's not like it's a problem that others don't also have
21:32:58 <codygman> I had a an infinite loop error, lol. let var' = map f var'
21:33:06 <codygman> s/a //
21:33:36 <L8D> Axman6: it's not a problem that JavaScript or Ruby developers have
21:35:01 <Axman6> but who cares about them anyway >_>
21:35:26 <codygman> I got a working solution, can anyone recommend a better one?
21:35:27 <Axman6> actually, twitter used to be written in ruby, and they certainly have the issues that Haxl addresses
21:35:29 <codygman> > foldl (\m ->(\(k,v) -> M.insert k v m)) M.empty [(0,1),(1,3)]
21:35:31 <lambdabot>  fromList [(0,1),(1,3)]
21:35:46 <Axman6> heh
21:36:00 <L8D> Axman6: JavaScript and Ruby developers make up the future of the tech industry
21:36:07 <L8D> *mainstream tech industry
21:36:25 <L8D> I guess I lot of them are migrating to Go/Rust
21:36:36 <L8D> but those languages don't have that problem either
21:36:47 <L8D> :s/have/care about/
21:36:48 <Axman6> sure they do...
21:37:23 <merijn> L8D: ahahaha
21:37:32 <merijn> L8D: None of them are migrating to Rust
21:37:34 <merijn> I wish...
21:37:48 <Axman6> Go is specifically aimed at a domain where Haxl solves many problems
21:37:49 <L8D> merijn: well all the ruby developers I met were in the process of learning Rust
21:40:01 <L8D> oh wait
21:40:04 <L8D> I'm fucking stupid
21:40:22 <L8D> they were learning rust because there was a presentation on rust the week before at the same meetup
21:40:29 * hackagebot liquid-fixpoint 0.2.1.0 - Predicate Abstraction-based Horn-Clause/Implication Constraint Solver  http://hackage.haskell.org/package/liquid-fixpoint-0.2.1.0 (EricSeidel)
21:40:31 * hackagebot liquidhaskell 0.2.1.0 - Liquid Types for Haskell  http://hackage.haskell.org/package/liquidhaskell-0.2.1.0 (EricSeidel)
21:40:48 <L8D> is it just me or does liquid types sound bad?
21:41:16 <luite> does refinement types sound better?
21:41:24 <merijn> Liquid Types is not some of this "optional typing" nonsense
21:41:27 <L8D> much better
21:41:37 <merijn> L8D: It's actually far more powerful than haskell's existing type system
21:41:47 <merijn> Google Liquid Haskell, it's pretty neat
21:41:49 <L8D> that says a lot
21:42:05 <L8D> anything "more powerful than Haskell's" must be good
21:42:11 <jle`> not necessarily :)
21:42:15 <L8D> yeah I guess so
21:42:36 <L8D> damnit I can't think of any funny examples
21:42:44 <L8D> jle`: what are some funny examples?
21:43:06 <jle`> oh i was meaning like...a more powerful type system might require more verbose proofs
21:43:11 <jle`> to be able to do anything
21:43:22 <jle`> type inference might become undecidable
21:43:45 <luite> L8D: it's relatively free-form predicates (refinements) over haskell types, using an SMT solver to do the bulk of the work
21:43:50 <jle`> liquid's pretty great though
21:46:16 <merijn> jle`: You don't even need much more powerful
21:46:31 <merijn> Hell, RankNTypes is sufficient to make type inference undecidable
21:46:44 <jle`> mhmf
21:46:46 <jle`> *mhm
21:58:08 <Zer000> how come when I divide two integers and get a Fractional, the type signature of the divide function (/) is still a -> a -> a - doesn't (2/3) typecast the ints to floats or something?
22:01:29 <merijn> Zer000: No, in Haskell numerical literals are polymorhpic
22:01:30 <merijn> :t 3
22:01:31 <lambdabot> Num a => a
22:02:00 <merijn> :t 3 :: Fractional a => a
22:02:01 <lambdabot> Fractional a => a
22:02:56 <merijn> Zer000: So '2' and '3' start out as "Num a => a", the application of (/) restricts them to "Fractional a => a" (Fractional being a subclass of Num)
22:04:01 <jle`> you can't divide two integers and get a fractional with (/)
22:04:12 <jle`> > (1 :: Int) / (4 :: Int)
22:04:13 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Types.Int)
22:04:13 <lambdabot>    arising from a use of ‘GHC.Real./’
22:04:14 <merijn> > ((2 :: Int) / 3) -- <- look, craps out
22:04:15 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Types.Int)
22:04:15 <lambdabot>    arising from a use of ‘GHC.Real./’
22:04:47 <jle`> :t [3, 2.4 :: Double]
22:04:48 <lambdabot> [Double]
22:05:02 <jle`> that 3 is a Double
22:05:15 <jle`> :t [3, 2.5]
22:05:16 <lambdabot> Fractional t => [t]
22:05:22 <jle`> it's a list of Fractional's
22:05:29 * hackagebot watchit 0.1.0.0 - File change watching utility  http://hackage.haskell.org/package/watchit-0.1.0.0 (tanimoto)
22:09:42 <Zer000> Interesting, merjin, jle` thanks
22:15:53 <Zer000> ok, I know there's a better way to do this but I want to know why this won't compile: http://dpaste.com/3PZKWJB
22:16:42 <shachaf> You should use hpaste.org. It automatically gives you useful suggestions on improving your program.
22:16:48 <shachaf> Anyway, why don't you tell us?
22:17:38 <Zer000> I guess there's no way to have a type for a function with a variable number of arguments hugh
22:18:05 <Zer000> because adding "cmb :: [a -> a -> a] -> b" doesn't work either
22:18:38 <Zer000> but maybe there's a way to express this?
22:19:35 <jle`> what are you trying to do...?
22:19:51 <jle`> what is the error?
22:20:28 <L8D> if you're typing out .0 then you're doing it wrong
22:20:38 <jle`> btw, the pattern on line 10 is never going to be matched
22:20:40 <jle`> :'(
22:20:46 <jle`> poor little pattern
22:22:41 <Zer000> well here are the errors http://lpaste.net/114546 for http://lpaste.net/114545
22:23:15 <Zer000> what i'm trying to do is "fold" all the a -> a -> a functions into one function with as many arguments as the length of the list plus one.
22:23:25 <Zer000> I'm just experimenting
22:23:46 <jle`> hm
22:23:50 <jle`> what is the resulting function then?
22:23:56 <jle`> after folding your [a -> a -> a] ?
22:24:03 <jle`> say i had [f, g, h]
22:24:24 <Zer000> a -> a -> a -> a -> a
22:24:26 <Zer000> for that oen
22:24:33 <jle`> what would it be defined as?
22:24:37 <Zer000> but it has as many arguments as the length of the list + 1
22:24:43 <jle`> myFunc [f, g, x] = \x ....?
22:24:50 <jle`> er, [f, g, h]
22:25:02 <jle`> i'm not sure what it would even be
22:25:09 <Zer000> hang on the combine function would take care of that
22:25:29 * hackagebot nibblestring 0.0.1 - Packed, strict nibble arrays with a list interface (ByteString for nibbles)  http://hackage.haskell.org/package/nibblestring-0.0.1 (jamshid)
22:25:33 <jle`> i mean, for this specific list
22:26:01 <jle`> for example, foldr (.) id [f, g, h] = \x -> f (g (h (id x)))
22:27:57 <Zer000> it would be (i think) \ a b c d -> f (g (h a b) c) d
22:29:37 <jle`> yeah, i don't think your function has a well-defined type.
22:30:22 <Zer000> welp that's that then
22:30:31 <Zer000> thanks though
22:31:24 <begriffs> Weird question...if I have a string is there a way to try parsing it as a Double, then as an Int, and finally as a String then take the first result that worked and plug it into a function? (The function is part of a type class that can handle Double, Int or String just fine)
22:32:18 <ThreeOfEight> Zer000: you could do that with HLists, for example
22:32:26 <ThreeOfEight> but the question is why you would want that
22:32:38 <jle`> how would HLists help?
22:33:01 <johnw> begriffs: that's the kind of thing parsec lives for
22:33:02 <jle`> all of the items in the list are of the same type, right?
22:33:04 <ThreeOfEight> wait, I think I mistunderstood what he wants
22:33:54 <jle`> the thing is that...if his list has one item, it returns an a -> a -> a; if it has two items, it returns a -> a -> a -> a; if it has three items, it returns a -> a -> a -> a -> a
22:34:10 <jle`> there is probably a way to do a typeclass hack
22:34:33 <jle`> but there is likely a simpler way
22:34:48 <begriffs> johnw: are there any beginner parsec docs that would cover this kind of case?
22:34:58 <ThreeOfEight> jle`: ah
22:35:32 <ThreeOfEight> then he could take an HList xs and return an HList xs -> a -> a
22:35:55 <ThreeOfEight> but HList would be overkill, yes
22:35:56 <jle`> hm
22:36:02 <ThreeOfEight> because all the types in xs are the same
22:36:03 <jle`> in that case he could just use [xs]
22:36:06 <jle`> yeah
22:36:25 <johnw> begriffs: first you "try" to parse for "number . number"; then "try" to parse for number; then parse whatever remains
22:36:28 <ThreeOfEight> so a list with type-level length annotation would be better
22:36:39 <johnw> the use of try is needed so that it rewinds back to the beginning to make another attempt
22:36:46 <ThreeOfEight> or an ad-hoc type class hack, of course
22:36:55 <johnw> you can use <|> to separate the attempts
22:36:57 <jle`> i'd probably try another path before continuing down this route
22:37:04 <ThreeOfEight> needless to say, this is probably not the best way to do this
22:37:11 <Zer000> yes i'm doing it another way
22:37:31 <begriffs> johnw: thanks, I'll try that
22:38:43 <Zer000> Should I use Float or Num or Fractional or Real or something else?
22:38:54 <Zer000> *i'm just doing basic arithmatic
22:39:06 <johnw> begriffs: try (concat <*> sequenceA [many digit, char '.', many digit]) <|> try (many digit) <|> try (many anyChar)
22:39:15 <ThreeOfEight> Zer000: if you're just doing arithmetic, use Num
22:39:21 <johnw> oh, no try needed for the third parser
22:39:25 <Zer000> Ok
22:39:49 <ThreeOfEight> if you also need division, use Fractional
22:40:05 <ThreeOfEight> or just don't write any type annotation at all, the compiler will tell you what to use
22:40:17 <int-e> begriffs: this looks silly: http://lpaste.net/114547 (I put Int first because anything that parses as Int will also parse as Double)
22:42:03 <begriffs> Thanks for the examples. While looking at attoparsec number stuff it directed me to the scientific package which has this function http://hackage.haskell.org/package/scientific-0.3.3.2/docs/Data-Scientific.html#v:floatingOrInteger
22:42:47 <begriffs> So maybe I could attempt parsing a scientific then mess with the Either. But the pattern match looks pretty clean and maybe would be faster too.
22:48:26 <fragamus> doesFileExist appears to see a file when I run it from GHCI but my compiled executable does not see the file. I have verified that working directory is identical.
22:49:04 <merijn> doesFileExist is a race condition anyway
22:49:42 <merijn> Also, how did you verify the working directory?
22:50:21 <fragamus> I used getCurrentDirectory
22:50:37 <fragamus> there is no race condition in this particular case
22:50:44 <fragamus> the file is sitting there static
22:51:02 <merijn> What if the file gets deleted between doesFileExist and you doing something with it?
22:51:27 <fragamus> now I find that the function does not work when I load my *whole program* and execute within GHCI
22:51:34 <fragamus> so it looks like my bug
22:52:00 <fragamus> your what if does not apply
22:53:17 <fragamus> OMG merely loading the program in GHCI seems to affect the operation of doesFileExist
23:06:46 <fragamus> OK it was a race condition
23:06:59 <fragamus> I admit I was wrong
23:07:41 <merijn> fragamus: It's ok, I love being right ;)
23:08:11 <fragamus> and I love being wrong
23:08:21 <fragamus> that's why IM SO HAPPY right now
23:09:09 <merijn> Anyway, the general best model for dealing with file existence is "just try and do whatever you wanted to do with them and catch any exceptions"
23:10:36 <fragamus> that's what I'm doing but I had some asynchrony that needed to get gone
23:12:31 <homesitter> Hi, which is the most-often-used gfx lib for haskell ?
23:15:42 <merijn> homesitter: In the gui sense or in the 3d graphics sense?
23:16:05 <homesitter> merijn: 2d gfx, maybe later on opengl
23:16:23 <merijn> homesitter: edwardk has been doing some cool stuff with OpenGL, check out https://github.com/ekmett/quine
23:16:41 <merijn> homesitter: There's also SDL, but tbh, I haven't used much. You may wanna ask around in #haskell-games
23:16:53 <merijn> (or was it #haskell-game ? I forget...)
23:17:21 <homesitter> okay, thx
23:17:46 <homesitter> haskell-games is empty
23:17:51 <edwardk> #haskell-game
23:18:04 <homesitter> merijn: I want to port a java application to haskell
23:18:23 <homesitter> I need combo-boxes an labels and a canvas
23:18:43 <edwardk> homesitter: i'll be frank. heretofore haskell has kinda sucked at graphics, we have bindings for things like wx, and gtk, but they are kinda brutal to install across platform
23:19:14 <edwardk> there is some stuff like threepenny-gui for making little apps that use a web front end, those work pretty well
23:19:14 <homesitter> edwardk: exactly !
23:19:22 <merijn> I think the biggest problem is installation and the fact that no one's made nice high level wrappers, no?
23:19:31 <edwardk> merijn: the installation is killer
23:19:42 <edwardk> e.g. wx is just broken on mac 64 bit right now
23:19:47 <merijn> :\
23:19:57 <edwardk> because it tries to use a framework that _will never be ported to 64 bit_
23:20:01 <edwardk> and doesn't filter it out
23:20:06 <homesitter> are there X11 bindings for writing a haskell-native gui lib ?
23:20:09 <merijn> oh, nice...
23:20:33 <homesitter> like java having  its own one ?
23:20:37 <edwardk> and right now its sort of hoping against hope that eventually the wxmac folks will merge in some changes downstream
23:21:03 <merijn> Are there even any non-64bit macs left?
23:21:07 <edwardk> homesitter: i don't know actually, there are things like xmonad out there, but its a whole desktop window manager
23:21:26 <edwardk> merijn: you can see the source of my consternation
23:21:39 <edwardk> wx _almost_ has the best installation process out there for a windowing library
23:21:49 <edwardk> except for the fact that when its done it just doesn't work
23:21:53 <edwardk> because of that issue on a mac
23:22:04 <edwardk> i was this close to actually starting to build code on top and wham
23:22:18 <merijn> edwardk: Sure
23:22:52 <edwardk> in theory the brew folks have said they'd take a patch to the recipe that caused it to disable mediactl on a 64-bit mac, which would avoid trying to link the old 32-bit quicktime framework
23:23:07 <edwardk> and the wxmac folks have a patch in the pipeline
23:23:12 <edwardk> so in a year there'll be a workaround
23:23:16 <edwardk> but i'm not waiting a year to do anything
23:23:23 <edwardk> i don't even know what i'll care about then =)
23:23:24 <luite> gtk isn't all that easy to get going on a mac either, but hamishmack told me that it's possible and that i have to try it now i have a new mac and can't use lack of storage as an excuse anymore ;)
23:23:26 <merijn> I think it's a matter of the "painfulness of maintaining bindings" to "rewards for maintaining GUI bindings" ratio is kinda low atm
23:23:46 <edwardk> luite: i've never once successfully installed a gui framework for haskell on a mac.
23:23:52 <edwardk> luite: that is despite multiple days of trying
23:24:19 <edwardk> and a reasonably good knowledge of both mac development and haskell =)
23:24:35 <jle`> [citation needed]
23:24:54 <merijn> If edwardk's knowledge of haskell is "reasonably good", where do I rank? "Pathetic scrub"? >.>
23:25:13 <homesitter> http://hackage.haskell.org/package/X11-1.6.0.2
23:25:39 <homesitter> I think, I should try that out
23:27:24 <edwardk> ok, i have a reasonably coherent explanation of what i want for the inner loop for quine written down
23:27:30 <edwardk> and it actually seems to make sense
23:27:40 <edwardk> so much stuff to do in a frame to make this thing usable
23:27:47 <edwardk> https://github.com/ekmett/quine/wiki/Pipeline
23:28:27 <merijn> edwardk: How long did those screenshots take you to make?
23:28:29 <edwardk> lots of that can be shelved until other parts work, but i wanted to see if in the end there were too many stalls in the pipeline to run it in one frame, or if i was going to have to split it over two frames 'in the round'
23:28:42 <edwardk> merijn: they render 15-30fps
23:29:02 <homesitter> Hey, if I could write a small gui lib and put it on github, could anyone help me, create a valid haskell package with the right dependencies ?
23:29:06 <edwardk> merijn: faster once i get conetracing in
23:29:12 <merijn> edwardk: I meant in coding time :p
23:29:25 <edwardk> the scenes themselves are mostly adapted shader toys
23:29:41 <merijn> homesitter: Creating a haskell package is pretty easy
23:29:45 <edwardk> there are author attributions in each one
23:29:53 <homesitter> merijn: k
23:30:38 <edwardk> the main concern with quine up until now was getting a harness up, test out corners of the new 'gl' package, etc.
23:30:47 <edwardk> now its switching into core 'build an engine' mode
23:31:24 <begriffs> homesitter: some notes I put together about making packages http://begriffs.com/posts/2014-10-25-creating-package-hackage.html
23:31:30 <edwardk> my main goal right now is to see if it is possible to build a viable, middle-tier style engine that does all its drawing through signed distance fields
23:32:15 <homesitter> begriffs: thx
23:32:16 <edwardk> to get there i need to use a bunch of pretty scary stuff, e.g. clustered shading to try to get back some of the quality lost from not having a single signed distance field for the scene
23:32:30 <edwardk> but in exchange i can pay 'by the pixel' for the complexity of the pipeline
23:32:55 <edwardk> so what i've established is that what i want isn't easy but i can't yet rule out that its possible =)
23:34:30 <merijn> I'll just wait for you to do all the hard work, then :p
23:35:20 <merijn> At the current rate of getting work done on my own stuff it'll be years before I get to graphics anyway :p
23:36:54 <homesitter> I never wrote a GUI lib before. Might be fun :)
23:37:44 <merijn> Not exactly the simplest task, but knock yourself out :)
23:38:02 <homesitter> :)
23:41:43 <homesitter> adn netbeans needs a haskell module
23:45:30 * hackagebot yaml 0.8.9.4 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.9.4 (MichaelSnoyman)
