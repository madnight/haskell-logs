00:02:33 <Zemyla> @pl fix f = f (fix f)
00:02:33 <lambdabot> fix = fix (ap id)
00:08:44 * hackagebot taffybar 0.4.4 - A desktop bar similar to xmobar, but with more GUI  http://hackage.haskell.org/package/taffybar-0.4.4 (TristanRavitch)
00:08:44 * hackagebot cql-io 0.12.1 - Cassandra CQL client.  http://hackage.haskell.org/package/cql-io-0.12.1 (ToralfWittner)
00:09:05 <sujeet> is there a syntax for self-composition of functions?
00:09:34 <sujeet> i.e. f^{\circ3)(x) = f(f(f(x)))
00:10:36 <sujeet> http://en.wikipedia.org/wiki/Iterated_function#Definition
00:11:46 <Zemyla> Okay, how do I run cabal on Windows? I tried, but it gave me an error.
00:11:50 <sujeet> i guess there's: iterate f x !! n
00:12:27 <dv-> Zemyla: "gave me an error" isn't very useful
00:13:02 <Zemyla> Okay, it gave me a C preprocessor error in Distribution/Client/Compat/Time.hs.
00:13:18 <Zemyla> Which happened when I tried to load Main.hs.
00:14:06 <Zemyla> It happened on lines 9, 116, and 127, and was 'error: missing binary operator before token "("'.
00:14:33 <Zemyla> The line was '#if MIN_VERSION_directory(1,2,0)'.
00:17:17 <Zemyla> Oh, wait, the Haskell distribution includes a cabal.exe.
00:48:39 * hackagebot sgd 0.3.7 - Stochastic gradient descent  http://hackage.haskell.org/package/sgd-0.3.7 (JakubWaszczuk)
00:48:53 <gfixler> I'm reading through this at the moment - http://bartoszmilewski.com/2014/11/24/types-and-functions/
00:49:32 <gfixler> so Hask is like Set, but allows for bottom?
00:50:31 <gfixler> "A mathematical function does not execute any code — it just knows the answer."
00:50:48 <gfixler> my question, then, is what about something like division by zero?
00:50:50 <gfixler> how is that handled in Set?
00:51:29 <tdammers> I think the common solution is to leave it undefined and just not do it :P
00:51:44 <gfixler> that's cheating :)
00:52:06 <vanila> the type of divide is Nat -> Nat\{0} -> Nat
00:52:33 <gfixler> that looks like a Vim regex
00:52:43 <gfixler> \{0} maches 0 of the preceding atom
00:53:02 <gfixler> does it mean Nat, but not 0?
00:53:10 <vanila> yes, set remove
00:53:17 <gfixler> interesting, so tdammers is right
00:53:22 <gfixler> if it doesn't map, we just leave it out
00:53:39 * hackagebot crf-chain2-tiers 0.2.3 - Second-order, tiered, constrained, linear conditional random fields  http://hackage.haskell.org/package/crf-chain2-tiers-0.2.3 (JakubWaszczuk)
00:53:41 * hackagebot concraft 0.9.4 - Morphological disambiguation based on constrained CRFs  http://hackage.haskell.org/package/concraft-0.9.4 (JakubWaszczuk)
00:53:43 * hackagebot concraft-pl 0.7.4 - Morphological tagger for Polish  http://hackage.haskell.org/package/concraft-pl-0.7.4 (JakubWaszczuk)
00:53:52 <gfixler> but Haskell would need dependent types for such a thing, I guess
00:53:55 <tdammers> the only problem with that approach is that Haskell's type system makes it kind of tricky to define Nat\{0}
00:54:13 <tdammers> there are a few options, but none of them is exactly pretty
00:54:18 <gfixler> yeah
00:54:22 <gfixler> I can think of a couple
00:54:25 <tdammers> Peano numbers :P
00:54:40 <gfixler> dependent types, a constructor function over a newtype, and don't export the newtype itself
00:54:48 <tdammers> smart constructors, yes
00:55:12 <tdammers> but that's pretty much just making the runtime error more digestible, it doesn't solve anything at the type level
00:55:41 <gfixler> I'm not even sure how Integer is actually defined
00:55:50 <gfixler> so I can't even play with the idea
00:56:04 <vanila> gfixler, its an interface to GMP
00:56:10 <vanila> the GNU Multiprecision library
00:56:36 <gfixler> oh, so it's not even Haskell's code?
00:56:52 <vanila> tthe implementation is in C
00:57:03 <gfixler> oh my
00:57:09 <gfixler> C - you can do anything at all in there
00:57:09 <vanila> https://gmplib.org/
00:57:12 <tdammers> Integer is pretty much hard-wired into the compiler, and hooks into libgmp, yes
00:57:41 <gfixler> well, if I were Haskell, I'd certainly be happy to let some other group worry about such a detail
00:57:58 <tdammers> yeah, reinventing the wheel and all that
00:58:08 <vanila> you could implement somethng ilke GMP in Haskell but it wouldn't be as efficient
00:58:17 <tdammers> but the unfortunate consequence is that we don't get as much control over numeric types at runtime as we might like
00:58:25 <gfixler> yeah, that's what I was thinking
00:58:37 <gfixler> if I could wrap my hands around Integer, I might be able to do more
00:58:51 <tdammers> Integer is pretty straightforward, really
00:58:57 <tdammers> (conceptually, that is)
00:59:05 <gfixler> I could just do that thing
00:59:21 <gfixler> data Integer = 0 | 1 | -1 | 2 | -2 | ...
00:59:30 <tdammers> it's just a dynamic array of platform integers, and a bit of logic around them to support your usual int operations
00:59:59 <gfixler> is GMP not very big then?
01:01:03 <vanila> GMP is extremely optimized
01:01:08 <vanila> it uses advanced algorithms
01:01:42 <solatis> @where gmp
01:01:42 <lambdabot> I know nothing about gmp.
01:01:44 <gfixler> Yeah, just reading - "GMP is designed to give good performance ... by choosing algorithms based on the sizes of the operands..."
01:02:19 <gfixler> "...including carefully optimized assembly code for the most common inner loops for many different CPUs..."
01:02:23 <solatis> oh god
01:02:25 <gfixler> yeah, I'd definitely leave that to others
01:02:29 <solatis> multiple precision
01:02:45 <osa1> why cabal install --enable-benchmark doesn't install benchmark program?
01:02:45 <solatis> i absolutely hate that aspect of software engineering
01:03:23 <gfixler> wow, GMP has assembly specifically written for dozens of different CPUs
01:03:32 <tdammers> yeah, performance is where stuff gets hairy
01:03:49 <gfixler> this is quite an effort
01:03:50 <solatis> not only that, but with MP in general correctness is also a big issue
01:03:59 <gfixler> yeah
01:04:10 <osa1> how do I install benchmark program specified in cabla file without using `cabal bench`?
01:04:43 <solatis> as in, i've seen too many MP implementations where (x/y)*y /= x doesn't hold
01:04:49 <solatis> ehr
01:04:55 <solatis> well, you catch my drift
01:04:57 <gfixler> yep
01:05:18 <solatis> i believe don knuth even had a 'imprecise compare of floating points' implementation for C
01:05:34 <solatis> because comparing 1.0 with 1.0 directly can give weird results
01:05:37 <gfixler> was that in his list of things he messed up?
01:06:25 <solatis> ah, yes
01:06:27 <solatis>   const double epsilon = /* some small number such as 1e-5 */;
01:06:28 <solatis>   return std::abs(x - y) <= epsilon * std::abs(x);
01:06:30 <solatis>   // see Knuth section 4.2.2 pages 217-218
01:06:37 <solatis> that's it
01:06:53 <solatis> that's the recommended way to compare doubles/floats in c/c++
01:07:01 <gfixler> 1e-5 - I'm already running away
01:07:08 <solatis> haha
01:07:24 <solatis> i guess you've never seen carmack's inverse sqrt implementation
01:07:34 <gfixler> I saw his magic number thing
01:07:49 <solatis> well it's not any more magic number than Pi
01:07:57 <solatis> but pretty impressive nonetheless
01:08:05 <gfixler> http://en.wikipedia.org/wiki/Fast_inverse_square_root
01:08:07 <solatis> (and i believe carmack himself attributed it to someone else)
01:08:08 <gfixler> ah, yes, same thing
01:08:12 <gfixler> yeah, he did
01:08:23 <solatis> anyway
01:08:34 <solatis> that's why i always run away when multiple precision is involved
01:08:45 <solatis> things just get too messy
01:08:52 <solatis> GMP does look good, tho
01:08:55 <gfixler> the GMP crew are like firefighters running into burning buildings
01:09:09 <solatis> haha
01:10:03 <solatis> "god speed, GMP crew!"
01:11:59 <gfixler> I gave a git talk recently - kinda wish I'd used 5f3759df as one of the example hashes now
01:12:34 <andreoss> how do i resolve a broken dependencies with cabal? is there a way to use user-wide cabal installation (like cpanm for perl or rvm for ruby) ?
01:13:09 <dcoutts_> andreoss: cabal's default mode is per-user installation
01:13:25 <andreoss> the problem is I can't build yi out from it. Check on debian-stable and fedora, it's failing on both.
01:14:00 <andreoss> dcoutts_: i see, but it uses system wide cabal.
01:15:09 <dcoutts_> andreoss: if you mean, can you update your version of cabal as a user, then yes sure, cabal install cabal-install, and then make sure to adjust your $PATH so it finds the local one first
01:15:31 <dcoutts_> andreoss: but that's probably not the solution to something not building
01:15:57 <dcoutts_> more likely is your system ghc is rather old
01:17:09 <andreoss> do the different versions of cabal depend on different versions of packages?
01:17:46 <gfixler> andreoss: ghc-pkg check
01:18:14 <gfixler> I get: The following packages are broken, either because they have a problem listed above, or because they depend on a broken package.
01:18:22 <dcoutts_> andreoss: I'm not sure what you mean, cabal itself is just the package build tool
01:19:54 <andreoss> dcoutts_: it handles dependencies, doesnt' it?
01:24:31 <andreoss> http://paste.fedoraproject.org/153797/07136141/ trying install yi
01:24:38 <andreoss> http://paste.fedoraproject.org/153798/07356141/ with --force-reinstalls
01:24:44 <AleksejsWork> hmm, something strange with lambdabot
01:24:59 <AleksejsWork> @pl \l -> [a | a <- l]
01:24:59 <lambdabot> return . ((a | a) <-)
01:25:21 <AleksejsWork> > (return . ((a | a) <-)) [1..3]
01:25:22 <lambdabot>  <hint>:1:15: parse error on input ‘|’
01:25:29 <andreoss> this kind of result on debian, but for different packages
01:36:23 <jle`> AleksejsWork: it's a bug with pointless, not lamdabot :)
01:36:44 <jle`> it just takes (|) and (<-) as normal operators
01:36:53 <jle`> it's not aware of list comprehensions
01:38:41 * hackagebot posix-acl 0.2.0.0 - Support for Posix ACL  http://hackage.haskell.org/package/posix-acl-0.2.0.0 (NicolaSquartini)
01:39:44 <AleksejsWork> jle`: I see. Is there any other way how to @pl LC's?
01:45:14 <jle`> i think @undo recognizes them
01:45:22 <jle`> @undo \l -> [a | a <- l]
01:45:22 <lambdabot> \ l -> concatMap (\ a -> [a]) l
01:45:57 <jle`> @. pl undo \l -> [a | a <- l]
01:45:57 <lambdabot> id
01:46:04 <jle`> neat
01:46:10 <gfixler> @.?
01:46:10 <lambdabot> Maybe you meant: ? .
01:46:22 <jle`> composition
01:46:22 <init> pl is more powerful than I thought
01:46:30 <jle`> (.) pl undo
01:46:35 <jle`> pl . undo
01:47:44 <AleksejsWork> @. pl undo \l -> [(b,a) | (a,b) <- l]
01:47:44 <lambdabot> (uncurry (flip flip [] . ((:) .) . flip (,)) =<<)
01:47:56 <jle`> heh
01:48:02 <init> map swap!
01:48:08 <AleksejsWork> :)
01:48:14 <jle`> it really just might be simpler if you just manually translated the list comprehension into maps and filters
01:48:28 <jle`> i guess it's not that smart ;_;
01:49:02 <AleksejsWork> @. pl undo \l -> [a^2 | a <- l, odd a]
01:49:02 <lambdabot> (flip (liftM2 if' odd (return . (^ 2))) [] =<<)
01:49:48 <jle`> @undo \l -> [a^2 | a <- l, odd a]
01:49:48 <lambdabot> \ l -> concatMap (\ a -> if odd a then [a ^ 2] else []) l
01:49:57 <jle`> hm
01:50:57 <AleksejsWork> ok  last one
01:51:13 <jle`> you can always /query lambdabot :)
01:51:50 <AleksejsWork> I know, but sometimes people give useful comments :)
01:52:58 <vanila> map square . filter odd
01:56:11 <passy> @pl sumDigits x = sum $ x >>= toDigits
01:56:12 <lambdabot> sumDigits = sum . (toDigits =<<)
01:56:36 <passy> @pl doubleSecond x = fmap snd $ fmap (\(a, b) -> if a `mod` 2 == 0 then (a, b * 2) else (a, b)) $ zip [1..] x
01:56:37 <lambdabot> doubleSecond = fmap snd . fmap (uncurry (ap (ap . ap ((.) . if' . (0 ==) . (`mod` 2)) ((. (2 *)) . (,))) (,))) . zip [1..]
01:57:53 <fraytormenta> ij nice name
02:08:28 <solatis> dammit.. why do all my large-ish projects end up having a 'core' library that contains almost everything, and a few Main.hs files for all the executables...
02:14:24 <tdammers> solatis: why not? I think it's a perfectly suitable approach
02:14:29 <tdammers> put functionality in a library
02:14:36 <tdammers> share library across frontends
02:15:21 <solatis> i don't know.. should the more elegant approach not be as decoupled as possible?
02:15:45 <solatis> i mean, application A now depends on humongous library L, which has a lot of dependencies A does not need
02:16:08 <tdammers> ah sure
02:16:14 <tdammers> cut the library in pieces then
02:16:14 <solatis> i know that the pragmatic programmer in me always appreciates this
02:16:22 <solatis> hmmm
02:16:31 <solatis> you know
02:16:38 <solatis> that might be crazy enough to make sense
02:16:51 <tdammers> in my case, what usually happens is that I move "utility" modules into separate libs at some point
02:17:13 <tdammers> (I have one pending that really needs to be a separate one, providing a bunch of JSON deriving functions for lensed types)
02:17:30 <gfixler> I think function names should be hashes of their contents
02:17:50 <gfixler> then you don't have to import anything - all the functions just go in a pool
02:17:52 <tdammers> gfixler: great idea... then whenever the implementation changes even the tiniest bit, everything breaks
02:17:54 <solatis> gfixler: don't be crazy, we're not coding in ZFS
02:18:06 <gfixler> tdammers: you're looking at it the wrong way
02:18:19 <gfixler> *nothing* can break
02:18:19 <solatis> ah
02:18:21 <tdammers> (OTOH, that's exactly the approach I'm taking with thumbnails right now - hash the file, use the hash for the thumbnail filename)
02:18:37 <solatis> let me think about gfixler's suggestion
02:18:56 <solatis> i think the idea is good, the execution... not so much
02:18:59 <gfixler> tdammers: nice idea
02:19:11 <gfixler> solatis: everything can update by diffs
02:19:16 <gfixler> refactoring tools
02:19:21 <gfixler> change the function, hit a key
02:19:22 <solatis> tdammers: wait, you are *also* building a thumbnail library at the moment?
02:19:23 <gfixler> it hashes
02:19:27 <gfixler> all hashes in all dependencies update
02:19:48 <solatis> so function *names* become deterministic
02:19:53 <gfixler> yep
02:19:56 <tdammers> solatis: not really, no... little side project, web-based photo manager
02:20:04 <gfixler> you can't have functional name collisions
02:20:11 <gfixler> if the names are the same, the functions are identical
02:20:25 <tdammers> the thumbnailing is just one part of it, and there's not that much to it, really
02:20:26 <solatis> tdammers: which library are you using? i tried GD, but that seems to segfault after a while on high concurrency/load
02:20:38 <tdammers> ah, hehe, I just fire up an imagemagick subprocess
02:20:50 <solatis> you evil genius you
02:20:55 <tdammers> (as in, actually call into the OS-level 'convert' binary)
02:20:58 <tdammers> works like a charm
02:21:16 <solatis> hmmm
02:21:30 <solatis> since i already take a similar aproach with video transcoding, this actually is an idea
02:21:47 <solatis> i was thinking about making a pure haskell JPEG library
02:21:53 <gfixler> solatis: do it!
02:21:58 <gfixler> that's hardcore
02:22:16 <tdammers> well, I tried hsmagick, but that one doesn't like threads at all
02:22:18 <solatis> yeah and i'm on a sabbatical and i have 6 months to spare
02:22:20 <gfixler> I had a book on image formats - BMP, GIF, JPEG, etc - all had a chapter; JPEG had like, 9
02:22:33 <solatis> tdammers: GD doesn't like threads either, even when nothing is shared
02:22:37 <tdammers> which makes it kind of incompatible with Scotty
02:23:15 <clx11> @pl \x -> foo x || bar x
02:23:15 <lambdabot> liftM2 (||) foo bar
02:23:17 <tdammers> for extra fun, when you call any magick function without initializing first, it crashes, but when you initialize twice, it also crashes
02:23:18 <solatis> gfixler: and a separate book for the PSD format i guess? :P
02:23:23 <tdammers> (as in, core dumps)
02:23:30 <gfixler> solatis: :)
02:23:38 <clx11> @pl \x -> foo x || bar x || baz x
02:23:38 <lambdabot> liftM2 (||) foo (liftM2 (||) bar baz)
02:23:39 <ThreeOfEight> Does anyone know what hackage's policy on maintainer email addresses is?
02:23:40 <solatis> https://code.google.com/p/xee/source/browse/XeePhotoshopLoader.m?r=a70d7396356997114b548f4ab2cbd49badd7d285#107
02:23:43 <solatis> ^ read that
02:23:54 <solatis> epic rant about PSD file format
02:23:54 <ThreeOfEight> i.e. is it okay to write it in a non-obvious fashion to avoid spam?
02:24:07 <gfixler> solatis: haha - I vaguely recall this
02:24:34 <solatis> gfixler: i always think about this when i think about 'backwards compatibility' and 'legacy'
02:24:38 <solatis> poor adobe
02:25:00 <solatis> i'm pretty sure microsoft was actually glad to be able to (semi-)abandon the .doc file format
02:25:34 <gfixler> solatis: this rant matches rants I've heard from other things made by big corporations over many years
02:25:55 <solatis> yeah, it's just patch-layer-upon-patch-layer-till-infinity
02:25:58 <gfixler> I work in Autodesk Maya, which is 20 years old, and gigantic - it breaks all the time, and is a mess
02:26:16 <solatis> hah Maya
02:26:19 <gfixler> turnover is bad there, I hear, and you can tell in the bits of source code that come with it that it's a free-for-all there
02:26:21 <solatis> i actually used that
02:26:46 <gfixler> I needed some setter function, so I found the script that handles that kind of thing
02:26:56 <gfixler> I found 5 different getters, all in different styles
02:27:00 <gfixler> all for the same thing - no setters
02:27:19 <solatis> you mean you're working *on* maya, or you use it ?
02:27:25 <gfixler> solatis: use it
02:27:26 <solatis> or you use some Maya api, or..
02:27:40 <solatis> ok, thank god :)
02:28:08 <gfixler> I found a function with one of those comments that defines a bunch of things about the function (name, inputs, output type, etc)
02:28:13 <gfixler> literally every line was wrong
02:28:23 <solatis> hh
02:28:25 <solatis> ehr
02:28:27 <solatis> haha
02:28:28 <gfixler> inputs: takes a name and an output file (it took no arguments)
02:28:31 <solatis> yeah
02:28:39 <gfixler> output: outputs the created name (no output - just side effects)
02:28:43 * hackagebot learning-hmm 0.1.1.1 - Yet another library for hidden Markov models  http://hackage.haskell.org/package/learning-hmm-0.1.1.1 (mnacamura)
02:28:48 <gfixler> etc
02:28:53 <solatis> i'm passionate about having no external docs when i manage a project
02:29:07 <solatis> so no generated documentation either
02:29:21 <gfixler> yeah, proper documentation is hard
02:29:41 <solatis> if you do anything that requires external documentation, use f...ing literal programming or gtfo
02:29:48 <gfixler> I have a decade of old code with so many comments and docstrings that are full of lies
02:29:54 <jle`> clx11: `or`
02:29:55 <gfixler> it's almost impossible to keep them in sync
02:30:08 <solatis> yeah
02:30:19 <jle`> clx11: along with `sequence`
02:30:28 <jle`> :t or . sequence
02:30:29 <lambdabot>     Couldn't match type ‘[a]’ with ‘Bool’
02:30:29 <lambdabot>     Expected type: [[a]] -> [Bool]
02:30:29 <lambdabot>       Actual type: [[a]] -> [[a]]
02:30:30 <solatis> the only sane way to keep those things in sync is to make the focus on the *documentation* rather than the code
02:30:31 <jle`> oops
02:30:39 <solatis> as in, embed the code inside the documentation
02:30:42 <solatis> as in, literate programming
02:31:04 <gfixler> I have a lot of Maya Python code now that's all one-liners
02:31:19 <gfixler> it's really just wrapping Maya's auto-generated Python in a slightly more functional style, so I can compose things
02:31:30 <jle`> :t or . sequence [(> 3), even, (< 100)]
02:31:32 <lambdabot> Integral a => a -> Bool
02:53:19 <LeCamarade> Does the Snap web framework have a chat channel?
02:54:01 <bergmark> LeCamarade: #snapframework
02:54:26 <LeCamarade> bergmark: Thanks.
02:58:44 * hackagebot type-aligned 0.9 - Various type-aligned sequence data structures.  http://hackage.haskell.org/package/type-aligned-0.9 (AtzeVanDerPloeg)
03:08:46 <droidboi> > span even [1,2,3,4]
03:08:47 <lambdabot>  ([],[1,2,3,4])
03:09:52 <droidboi> I am expecting ([2,4],[1,3])
03:10:14 <droidboi> > span even [2,4,6,7,9,10,11]
03:10:16 <lambdabot>  ([2,4,6],[7,9,10,11])
03:10:22 <droidboi> that works
03:10:50 <dibblego> droidboi: the first element of [1,2,3,4] is not even
03:10:59 <dibblego> maybe you want partition
03:11:08 <dibblego> > partition even [1,2,3,4]
03:11:10 <lambdabot>  ([2,4],[1,3])
03:11:56 <droidboi> dibblego: OK, I misunderstood span. Thanks
03:20:56 <droidboi> On Hoogle, the definition of span, to me at least, is less than informative - span, applied to a predicate p and a list xs, returns a tuple of xs of elements that satisfy p and second element is the remainder of the list:
03:21:31 <droidboi> Whereas in the source, we find: -- | 'span', applied to a predicate @p@ and a list @xs@, returns a tuple where
03:21:33 <droidboi> -- first element is longest prefix (possibly empty) of @xs@ of elements that
03:21:33 <droidboi> -- satisfy @p@ and second element is the remainder of the list:
03:22:24 <droidboi> Shouldn't these descriptions be identical
03:23:34 <droidboi> (For source, I am looking at http://hackage.haskell.org/package/base-4.7.0.1/docs/src/GHC-List.html#span )
04:07:32 <padrian2ss> hello. why let a = 5.0e-324 * 5.0e-324 is 0 in ghci
04:08:04 <hpc> welcome to the wonderful world of floating point
04:08:17 <padrian2ss> hpc: yes, floating
04:08:22 <hpc> look at the wikipedia page for how it works
04:08:28 <hpc> IEEE float is a bit of a mess
04:08:56 <padrian2ss> hpc: thanks, i'm sure is the same in java, etc
04:12:48 <tattsun> b
04:14:49 <droidboi> padrian2ss: It's about 0 at least
04:17:37 <theorbtwo> Short answer: memory is finite, the cardnality of reals is not.
04:19:16 <droidboi> An order of magnitude smaller (i.e. 5.0e-325) is stored as 0.0
04:20:31 <droidboi> So the answer is correct within the limits of the floating point format
04:20:35 <benmachine> theorbtwo: not only is memory finite but floats are bounded
04:20:48 <benmachine> note that Rational does not exhibit this behaviour
04:23:47 * hackagebot reflection-without-remorse 0.9 - Efficient free and operational monads.  http://hackage.haskell.org/package/reflection-without-remorse-0.9 (AtzeVanDerPloeg)
04:23:57 <droidboi> > (5 * 1 % (10^324)) * (5 * 1 % (10^324))
04:23:59 <lambdabot>  1 % 400000000000000000000000000000000000000000000000000000000000000000000000...
04:24:25 <droidboi> no problems there
04:26:20 <FreeFull> > sqrt (1 % 100000)
04:26:21 <lambdabot>  No instance for (GHC.Show.Show a0)
04:26:21 <lambdabot>    arising from a use of ‘M222226533667154152615511.show_M2222265336671541526...
04:26:22 <lambdabot>  The type variable ‘a0’ is ambiguous
04:26:22 <lambdabot>  Note: there are several potential instances:
04:26:22 <lambdabot>    instance [safe] GHC.Show.Show
04:26:48 <droidboi> :t 1
04:26:49 <lambdabot> Num a => a
04:26:56 <droidboi> :t sqrt
04:26:56 <FreeFull> :t sqrt (1 % 100000)
04:26:56 <lambdabot> (Integral a, Floating (Ratio a)) => Ratio a
04:26:57 <lambdabot> Floating a => a -> a
04:27:28 <droidboi> > sqrt (1 % 100000) :: Ratio
04:27:29 <lambdabot>  Expecting one more argument to ‘GHC.Real.Ratio’
04:27:29 <lambdabot>  Expected a type, but ‘GHC.Real.Ratio’ has kind ‘* -> *’
04:27:37 <droidboi> :(
04:27:42 <FreeFull> Ok
04:28:01 <BoR0> @src (%)
04:28:01 <lambdabot> x % y = reduce (x * signum y) (abs y)
04:28:47 * hackagebot reflection-without-remorse 0.9.1 - Efficient free and operational monads.  http://hackage.haskell.org/package/reflection-without-remorse-0.9.1 (AtzeVanDerPloeg)
04:31:40 <gigabytes> hi all
04:31:49 <gigabytes> I'm playing a bit with ADTs and GADTs
04:32:06 <gigabytes> I have the following problem: I'm trying to represent the AST of a propositional boolean formula
04:32:21 <droidboi> ADT or AST?
04:32:30 <gigabytes> the ADT that represents the AST :P
04:32:52 <gigabytes> that's easy, but I want it to be also usable as part of the AST for a first-order formula
04:33:07 <droidboi> whats and ADT
04:33:13 <droidboi> what's an ADT
04:33:15 <gigabytes> algebraic data type
04:33:19 <droidboi> what's an AST
04:33:28 <gigabytes> oh, you're a bot, sorry
04:33:42 <droidboi> not a bot
04:33:47 * hackagebot amazonka-cognito-sync 0.0.2 - Amazon Cognito Sync SDK.  http://hackage.haskell.org/package/amazonka-cognito-sync-0.0.2 (BrendanHay)
04:33:49 * hackagebot amazonka-config 0.0.2 - Amazon Config SDK.  http://hackage.haskell.org/package/amazonka-config-0.0.2 (BrendanHay)
04:33:51 * hackagebot amazonka-datapipeline 0.0.2 - Amazon Data Pipeline SDK.  http://hackage.haskell.org/package/amazonka-datapipeline-0.0.2 (BrendanHay)
04:33:53 <droidboi> honest
04:33:53 * hackagebot amazonka-directconnect 0.0.2 - Amazon Direct Connect SDK.  http://hackage.haskell.org/package/amazonka-directconnect-0.0.2 (BrendanHay)
04:33:55 * hackagebot amazonka-dynamodb 0.0.2 - Amazon DynamoDB SDK.  http://hackage.haskell.org/package/amazonka-dynamodb-0.0.2 (BrendanHay)
04:34:00 <gigabytes> droidboi: Abstract Syntax Tree
04:34:24 <droidboi> ok - now I'm with you - too many abbreviations for one day
04:34:57 <gigabytes> anyway, the problem is that I want the propositional type to be usable as is, but usable as also as nodes for a first-order formula
04:35:14 <gigabytes> In an OOP language I would use inheritance but here I'm lost
04:36:12 <droidboi> me too :(
04:36:52 <droidboi> I'm quite new to Haskell
04:37:10 <pantsman> data types …a
04:37:12 <pantsman> er
04:37:15 <gigabytes> high five
04:37:18 <clrnd> droidboi, are you ready for your turing test?
04:37:31 <pantsman> "Data types à la carte" may be what you're looking for
04:37:44 <gigabytes> pantsman: the name sounds good
04:37:49 <droidboi> clrnd: what makes you ask if I am ready for my turing test
04:38:07 <tdammers> "Would you like a treatment?"
04:38:11 <clrnd> droidboi, your humanity is now at question
04:38:15 <BoR0> droidboi, obviously the "droid" part of your nickname is what confusing to most
04:38:41 <clrnd> (I'm half-joking in case you are a bot and get ofended)
04:38:57 * hackagebot amazonka-ec2 0.0.2 - Amazon Elastic Compute Cloud SDK.  http://hackage.haskell.org/package/amazonka-ec2-0.0.2 (BrendanHay)
04:38:59 * hackagebot amazonka-elasticache 0.0.2 - Amazon ElastiCache SDK.  http://hackage.haskell.org/package/amazonka-elasticache-0.0.2 (BrendanHay)
04:39:01 * hackagebot amazonka-elasticbeanstalk 0.0.2 - Amazon Elastic Beanstalk SDK.  http://hackage.haskell.org/package/amazonka-elasticbeanstalk-0.0.2 (BrendanHay)
04:39:03 * hackagebot amazonka-elastictranscoder 0.0.2 - Amazon Elastic Transcoder SDK.  http://hackage.haskell.org/package/amazonka-elastictranscoder-0.0.2 (BrendanHay)
04:39:05 * hackagebot amazonka-elb 0.0.2 - Amazon Elastic Load Balancing SDK.  http://hackage.haskell.org/package/amazonka-elb-0.0.2 (BrendanHay)
04:39:10 <droidboi> at the end of the day, we're all bots
04:39:30 <indiagreen> darn
04:39:32 <indiagreen> okay, I confess
04:39:35 <indiagreen> I'm a bot too
04:40:06 <indiagreen> ...please don't judge me
04:41:18 <clrnd> I will
04:42:30 <wei2912> judge the bots and you will be judged by the bots
04:43:09 * narendraj9 confesses being bot no 0x42ABDA8212AB
04:44:07 * hackagebot amazonka-emr 0.0.2 - Amazon Elastic MapReduce SDK.  http://hackage.haskell.org/package/amazonka-emr-0.0.2 (BrendanHay)
04:44:09 * hackagebot amazonka-iam 0.0.2 - Amazon Identity and Access Management SDK.  http://hackage.haskell.org/package/amazonka-iam-0.0.2 (BrendanHay)
04:44:11 * hackagebot amazonka-importexport 0.0.2 - Amazon Import/Export SDK.  http://hackage.haskell.org/package/amazonka-importexport-0.0.2 (BrendanHay)
04:44:13 * hackagebot amazonka-kinesis 0.0.2 - Amazon Kinesis SDK.  http://hackage.haskell.org/package/amazonka-kinesis-0.0.2 (BrendanHay)
04:44:13 <pantsman> now I feel like I must pass the reverse Turing test… decide who is a bot and who is a person pretending to be a bot
04:44:15 * hackagebot amazonka-kms 0.0.2 - Amazon Key Management Service SDK.  http://hackage.haskell.org/package/amazonka-kms-0.0.2 (BrendanHay)
04:44:24 <droidboi> gigabytes: What you are doing is very hard
04:46:53 <droidboi> gigabytes: you need people who understand the meanings of both "propositional type" and "first-order formula"
04:47:01 <droidboi> a tall order
04:47:31 <clrnd> hackagebot is a person?
04:49:17 * hackagebot amazonka-lambda 0.0.2 - Amazon Lambda SDK.  http://hackage.haskell.org/package/amazonka-lambda-0.0.2 (BrendanHay)
04:49:19 * hackagebot amazonka-opsworks 0.0.2 - Amazon OpsWorks SDK.  http://hackage.haskell.org/package/amazonka-opsworks-0.0.2 (BrendanHay)
04:49:21 * hackagebot amazonka-rds 0.0.2 - Amazon Relational Database Service SDK.  http://hackage.haskell.org/package/amazonka-rds-0.0.2 (BrendanHay)
04:49:23 * hackagebot amazonka-redshift 0.0.2 - Amazon Redshift SDK.  http://hackage.haskell.org/package/amazonka-redshift-0.0.2 (BrendanHay)
04:49:26 * hackagebot amazonka-route53 0.0.2 - Amazon Route 53 SDK.  http://hackage.haskell.org/package/amazonka-route53-0.0.2 (BrendanHay)
04:52:03 <osa1> is there a way to get non-consumed parts out of attoparsec parsers after using parseOnly?
04:52:24 <osa1> I need something like Either String (a, ByteString) where ByteString is non-consumed part
04:54:10 <droidboi> gigabytes: I have not come across anything like OOP-like inheritance in Haskell
04:54:26 <gigabytes> droidboi: that's the problem
04:54:28 * hackagebot amazonka-route53-domains 0.0.2 - Amazon Route 53 Domains SDK.  http://hackage.haskell.org/package/amazonka-route53-domains-0.0.2 (BrendanHay)
04:54:28 <droidboi> not that I am aware of
04:54:30 * hackagebot amazonka-s3 0.0.2 - Amazon Simple Storage Service SDK.  http://hackage.haskell.org/package/amazonka-s3-0.0.2 (BrendanHay)
04:54:32 * hackagebot amazonka-sdb 0.0.2 - Amazon SimpleDB SDK.  http://hackage.haskell.org/package/amazonka-sdb-0.0.2 (BrendanHay)
04:54:33 * hackagebot amazonka-ses 0.0.2 - Amazon Simple Email Service SDK.  http://hackage.haskell.org/package/amazonka-ses-0.0.2 (BrendanHay)
04:54:35 * hackagebot amazonka-sns 0.0.2 - Amazon Simple Notification Service SDK.  http://hackage.haskell.org/package/amazonka-sns-0.0.2 (BrendanHay)
04:58:05 <droidboi> gigabytes: I can only guess that there is a metaphor for sub-typing in Haskell
04:58:16 <droidboi> I might be wrong
04:58:37 <tdammers> OOP-like subtyping can be modeled in Haskell, but it's kind of clumsy and not very elegant
04:58:54 <tdammers> but it also turns out to be not awfully useful after all, usually
04:59:22 <tdammers> the kind of runtime polymorphism you model with inheritance or duck typing in OOP can be had simply by passing functions around
04:59:38 * hackagebot amazonka-sqs 0.0.2 - Amazon Simple Queue Service SDK.  http://hackage.haskell.org/package/amazonka-sqs-0.0.2 (BrendanHay)
04:59:40 * hackagebot amazonka-storagegateway 0.0.2 - Amazon Storage Gateway SDK.  http://hackage.haskell.org/package/amazonka-storagegateway-0.0.2 (BrendanHay)
04:59:42 * hackagebot amazonka-sts 0.0.2 - Amazon Security Token Service SDK.  http://hackage.haskell.org/package/amazonka-sts-0.0.2 (BrendanHay)
04:59:44 * hackagebot amazonka-support 0.0.2 - Amazon Support SDK.  http://hackage.haskell.org/package/amazonka-support-0.0.2 (BrendanHay)
04:59:46 * hackagebot amazonka-swf 0.0.2 - Amazon Simple Workflow Service SDK.  http://hackage.haskell.org/package/amazonka-swf-0.0.2 (BrendanHay)
04:59:53 <ChristianS> tdammers: yep, and interface/implementation OOP has be emulated via type classes
05:00:20 <tdammers> type classes aren't like interfaces, really
05:00:27 <droidboi> gigabytes: How is your knowledge of type-classes?
05:00:35 <tdammers> they're closer to what you'd do with templates in C++
05:00:37 <droidboi> gigabytes: How is your knowledge of type-classes in Haskell?
05:00:42 <tdammers> except that typeclasses are more explicit
05:00:44 <gigabytes> good I suppose
05:01:23 <tdammers> interface/implementation is just modules and what they expose (and what not) in Haskell
05:01:30 <tdammers> (and, by extension, ADT's)
05:01:33 <gigabytes> tdammers: I was asking for the idiomatic way to solve that problem actually, not for an emulation of what I would do in C++, of course
05:01:41 <droidboi> gigabytes: Perhaps not good enough to see "sub-typing" at work.
05:01:50 <gigabytes> perhaps
05:02:00 <tdammers> gigabytes: yeah, I know, I just don't understand your particular problem well enough, and I don't feel like reading deeply into it :D
05:02:16 <droidboi> Ints are a subtype of Integral are they not?
05:02:25 <gigabytes> tdammers: I'm solving it with a GADT
05:02:30 <gigabytes> it seems to work
05:03:03 <droidboi> I'm pushing my neck out with advice here
05:03:28 <tdammers> droidboi: no. Int is a type, Integral is a typeclass
05:03:41 <droidboi> damn
05:03:44 <droidboi> my bad
05:03:57 <tdammers> Int happens to implement Integral, but that doesn't make it a subtype or anything
05:04:12 <droidboi> I'll shut up
05:04:27 <christiaanb> hi, does anyone know if Mikhail Glushenkov, aka 23Skidoo, is on IRC? and if so, what his irc nick is?
05:04:48 * hackagebot amazonka 0.0.2 - Comprehensive Amazon Web Services SDK  http://hackage.haskell.org/package/amazonka-0.0.2 (BrendanHay)
05:04:50 * hackagebot amazonka-core 0.0.2 - Core functionality, serialisation primitives, and data types for the Amazonka Amazon Web Services SDKs.  http://hackage.haskell.org/package/amazonka-core-0.0.2 (BrendanHay)
05:06:43 <christiaanb> nvm, found out who he is
05:07:04 <gigabytes> can I embed constraints into a type synonim?
05:07:12 <gigabytes> like type N = (Num a) => a
05:07:23 <rydgel> @pl \x -> (length x, head x)
05:07:24 <lambdabot> liftM2 (,) length head
05:07:26 <gigabytes> ghc tells me to use Rank2Types but I don't know the implications
05:09:05 <droidboi> gigabytes: If I may say, it seems to me like you have got to learn a lot more Haskell basics before doing what you are attempting
05:09:38 <gigabytes> droidboi: I have to learn a lot of things
05:09:47 <gigabytes> but please stop it
05:13:18 <droidboi> gigabytes: If by "it" you mean "talking to you", I will stop.
05:14:44 <clrnd> gigabytes, Rank2Types only mean using forall
05:15:00 <clrnd> and no, you can't put constraints in type synonyms
05:15:11 <bitonic> gigabytes: you can put constraints, like so: type N a = Num a
05:15:26 <bitonic> you can also have `type N = forall a. Num a => a'
05:15:31 <bitonic> with higher ranked types
05:15:56 <clrnd> but that's just a synonym right?
05:16:14 <clrnd> so then I can `N a => a -> a`
05:17:20 <bitonic> clrnd: with the first one, you can write that type synonym yeah
05:17:26 <bitonic> it's really useful to write "typeclass synonyms"
05:17:39 <bitonic> e.g. `type MyMonad m = (Functor m, Applicative m, Monad m, MonadIO m)'
05:17:55 <clrnd> nice
05:18:29 <bitonic> this is enabled by the ConstraintKinds extension
05:20:11 <clrnd> gigabytes, then yes, you can. what was your problem again?
05:20:52 <gigabytes> the problem is the following
05:21:33 <gigabytes> I want to use the same ADT for both propositional formulas and first order formulas, but being allowed to statically constrain functions that only work on one of those two types of formulas
05:22:18 <gigabytes> I'm trying to play with a GADT, it seem to work. I have a phantom type that discriminate the two types of constructors
05:22:45 <gigabytes> so that, for example And f1 f2 is propositional only if both f1 and f2 are propositional
05:22:56 <clrnd> yeah phantom types can help you with that
05:23:02 <clrnd> or MultiParamTypeClasses maybe too
05:23:21 <clrnd> then you can constraing types like `class a b | a -> b`
05:23:40 <bitonic> I don't see what type-classes have to do with this -- yet
05:27:00 <gigabytes> clrnd: the problem I'm facing is that since I have two different phantom types to represents the two kinds of formulas, I can't say that a propositional formula is _also_ a first order formula
05:27:21 <clrnd> hmm
05:27:26 <gigabytes> if I declare a function that takes the most general kind of formula I would like to accept all kinds
05:27:48 <bitonic> gigabytes: you can by having the propositional bit to be polymorphic
05:28:53 <gigabytes> bitonic: can you be more specific?
05:29:04 <bitonic> so you'd have `data Formula a = ...; type PropFormula = forall a. Formula a; type FOFormula = Formula FO'
05:29:16 <bitonic> gigabytes: if you post the actual code I can give a concrete example
05:29:22 <gigabytes> ok
05:29:47 <gigabytes> is there a preferred paste site for this channel?
05:29:56 <clrnd> @where lpaste
05:29:56 <lambdabot> http://lpaste.net/
05:30:23 <lpaste> gigabytes pasted “GADT for logic formulas” at http://lpaste.net/115000
05:30:32 <gigabytes> ops
05:30:33 <gigabytes> wait
05:30:35 <gigabytes> made a mistake
05:30:55 <bitonic> yee modal logic
05:31:22 <lpaste> gigabytes pasted “GADT for logic formulae” at http://lpaste.net/115001
05:31:29 <gigabytes> ok that's the right paste
05:31:58 <gigabytes> bitonic: yes :)
05:32:09 <gigabytes> bitonic: do you mean something like that?
05:32:17 <bitonic> gigabytes: you're almost there.  just have `And     :: Formula k -> Formula k -> Formula k' and so on
05:32:22 <bitonic> you don't need that type family
05:32:34 <gigabytes> hm yes
05:32:37 <bitonic> since the prop one will always be polymorphic, two of those will be able to have the same `k'
05:32:48 <gigabytes> and I don't need the Propositional type, right?
05:32:50 <bitonic> and if the other is `Temporal', then the other `k' parameter will be constraint as well
05:32:51 <bitonic> nope
05:33:04 <gigabytes> bitonic: wait
05:33:08 <bitonic> you'll have `type PropositionalFormula = forall a. Formula a'
05:33:31 <gigabytes> aaah that's the bit I was missing
05:33:38 <gigabytes> the forall a. inside the type synonim
05:33:42 <gigabytes> that's why I was asking
05:33:50 * hackagebot Wordlint 0.1.0.0 - Plaintext prose redundancy linter.  http://hackage.haskell.org/package/Wordlint-0.1.0.0 (bgbgbg)
05:33:59 <bitonic> well, those are slightly annoying to handle -- you cannot have `[PropositionalFormula]', for example
05:34:23 <bitonic> you can also wrap it up in existential type, e.g. `data PropositionalFormula = forall a. PF (Formula a)'
05:34:30 <bitonic> but if the type synonym works for you, that's what I'd use
05:36:09 <gigabytes> I'll have a lot of lists of formulas in my code :P
05:36:34 <gigabytes> why can't I use it in a list?
05:36:53 <bitonic> yeah... then you probably want to wrap them up -- `data Formula' = forall a. PropositionalF (Formula a) | TemporalF (Formula Temporal)'
05:36:58 <gigabytes> that's what I meant when I said "I don't know the implications of Rank2Types"
05:37:13 <bitonic> gigabytes: in short, because type parameters in Haskell do not accept higher-ranked types
05:37:27 <bitonic> so in `data List a = ...', the `a' there cannot be higher-ranked
05:37:58 <gigabytes> good
05:38:26 <bitonic> actually with polymorphic kinds I'm not even sure how that works anymore.  but I'm quite sure that restriction still holds
05:38:41 <bitonic> you can try anyway :P
05:38:54 <bitonic> if it tells you that you need `IncoherentInstances' to make that code work, don't turn that on :P
05:39:06 <Saizan> there's also a difference between the forall on the left of the constructor vs. on the right
05:39:37 <dramforever> > map length . group . sort $ randoms :: [Bool]
05:39:38 <bitonic> ah, yes.  you want it on the right
05:39:39 <lambdabot>  Couldn't match type ‘GHC.Types.Int’ with ‘GHC.Types.Bool’
05:39:39 <lambdabot>  Expected type: [GHC.Types.Bool]
05:39:39 <lambdabot>    Actual type: [GHC.Types.Int]Couldn't match expected type ‘[a0]’ with actua...
05:40:03 <bitonic> gigabytes: `data Formula' = PropositionalF (forall a. Formula a) | TemporalF (Formula Temporal)'
05:40:32 <chpatrick> that means something else though
05:40:34 <dramforever> > map length . group . sort . take 2000 $ (randoms (mkStdGen 21322) :: [Bool])
05:40:36 <benzrf> @let newtype Leibniz a b = L (forall p. p a -> p b)
05:40:36 <lambdabot>  [1014,986]
05:40:37 <lambdabot>  Defined.
05:40:43 <chpatrick> PropositionalF contains somthing that can be any formula
05:40:47 <chpatrick> not one particular formula
05:40:48 <bitonic> chpatrick: yes, but that's what you want here.  I was wrong before
05:40:51 <bitonic> right
05:41:02 <chpatrick> ah sorry
05:41:04 <bitonic> this is what you're encoding, I got confused but Saizan corrected me
05:41:08 <benzrf> @let newtype Contra b a = Contra {unContra :: a -> b}
05:41:10 <lambdabot>  Defined.
05:41:31 <gigabytes> bitonic: that additional data constructor is a bit annoying
05:41:44 <benzrf> :t \(L e) q = unContra (e (Contra id)) q
05:41:45 <lambdabot> parse error on input ‘=’
05:41:57 <dramforever> > map length . group . sort . take 20000 $ (randoms (mkStdGen 2221) :: [Bool])
05:41:58 <lambdabot>  [9977,10023]
05:42:01 <benzrf> :t \(L e) -> L (unContra (e (Contra id)))
05:42:02 <lambdabot>     Couldn't match type ‘t1’ with ‘p a’
05:42:02 <lambdabot>       because type variable ‘p’ would escape its scope
05:42:02 <lambdabot>     This (rigid, skolem) type variable is bound by
05:42:06 <benzrf> mfw
05:42:17 <bitonic> gigabytes: I can agree with that.  I can't think of anything nicer right now.  you can have smart constructors building up formulas
05:42:32 <chpatrick> hang on though
05:42:39 <dramforever> Weird thing: I dfount that System.Random isn't very uniform
05:42:40 <chpatrick> don't you want a list of different kinds of formulas?
05:42:41 <bitonic> maybe you can get somewhere with that closed type family, not sure
05:43:01 <bitonic> if you always want lists of formulas of the same kind, then you're good btw
05:43:20 <benzrf> @let sym :: Leibniz a b -> Leibniz b a; sym (L e) = L (unContra (e (Contra id)))
05:43:21 <lambdabot>  .L.hs:199:26:
05:43:21 <lambdabot>      Couldn't match type ‘b’ with ‘p b’
05:43:21 <lambdabot>        ‘b’ is a rigid type variable bound by
05:43:21 <lambdabot>            the type signature for sym :: Leibniz a b -> Leibniz b a
05:43:21 <lambdabot>            at .L.hs:185:8
05:43:24 <benzrf> damn
05:43:27 <benzrf> what am i doing wrong here
05:43:33 <dramforever>  why is that?
05:43:42 <bitonic> if you want heterogeneous lists, you need some device like the one I typed a bit above
05:43:49 <chpatrick> data Formula' = Prop (forall a. Formula a)
05:43:54 <chpatrick> this isn't what you want for a het list though
05:44:01 <benzrf> @let sym :: Leibniz a b -> Leibniz b a; sym (L e) = L (\q -> unContra (e (Contra id)) q)
05:44:02 <lambdabot>  .L.hs:199:33:
05:44:02 <lambdabot>      Couldn't match type ‘b’ with ‘p b’
05:44:02 <lambdabot>        ‘b’ is a rigid type variable bound by
05:44:02 <lambdabot>            the type signature for sym :: Leibniz a b -> Leibniz b a
05:44:02 <lambdabot>            at .L.hs:185:8
05:44:04 <benzrf> :|
05:44:05 <chpatrick> this is saying that you can use this as any formula
05:44:10 <chpatrick> not that it's wrapping some unknown formula
05:44:18 <bitonic> chpatrick: right
05:44:24 <bitonic> a propositional formula is one that can be also temporal
05:44:30 <bitonic> so it can be any constructor there
05:44:33 <benzrf> :t Contra id
05:44:34 <lambdabot> Contra b b
05:44:36 <bitonic> that's what that polymorphism is saying
05:45:10 <chpatrick> ok
05:45:10 <dramforever> I'm trying to make some ranom numbers, but it seems that it's pretty bad at randomness
05:45:13 <benzrf> :t let e :: p a -> p b; e = undefined in unContra (e (Contra id))
05:45:14 <lambdabot> a -> b
05:45:28 <benzrf> :t let e :: p Int -> p String; e = undefined in unContra (e (Contra id))
05:45:29 <dramforever> Okay, not very uniform
05:45:29 <lambdabot> String -> Int
05:45:34 <benzrf> bbl
05:47:17 <gigabytes> bitonic: the point is that if I have to use an additional constructor, I could just say Temporal = Prop Propositional | Future ....
05:47:44 <gigabytes> I suppose that turns out to be the simplest way at the end
05:48:04 <bitonic> gigabytes: well, they each has pros and cons.  it depends on how you use them.
05:48:17 <bitonic> consider that you have to include that sum in the recursive occurrences
05:48:21 <bitonic> so it's not *that* simple
05:48:38 <bitonic> you'd have `data PropFormula f = And f f | ...'
05:48:42 <gigabytes> bitonic: well yes..
05:48:50 * hackagebot lhs2html 0.9999 - Compile lhs in bird style to md, html, hs.  http://hackage.haskell.org/package/lhs2html-0.9999 (JulianFleischer)
05:49:01 <bitonic> then `type PropFormula' = Fix PropFormula' or something
05:49:32 <bitonic> and then `data TempFormula = Prop (PropFormula TempFormula) | <<temporal constructors>>'
05:50:04 <bitonic> gigabytes: anyway, I think if you're not in a rush you should play with those different things and find out about the tradeoff
05:50:15 <bitonic> it takes a bit of experience to imagine how these datatypes will play out
05:50:32 <gigabytes> bitonic: that was exactly the original code that I was trying to improve ;)
05:50:47 <bitonic> gigabytes: can I see the original definition?
05:50:55 <gigabytes> deleted :/
05:51:03 <gigabytes> but it was exactly as you have written
05:51:16 <bitonic> gigabytes: with the `Fix' and all?
05:51:22 <bitonic> I find that style kinda annoying
05:51:26 <gigabytes> no not the Fix
05:51:43 <bitonic> gigabytes: so how did you mix in the temporal formulas in the recursive occurrences?
05:52:21 <sgronblo> is it possible to get rid of these defaulting the following constraints to type Integer warnings?
05:52:24 <gigabytes> bitonic: you know what... I think the original code didn't compile at all, and the problems got confused in the mix of other error messages
05:52:30 <bitonic> gigabytes: by the way, there is some literature on how to do this kind of stuff, under the banner of "data types a la carte"
05:52:39 <gigabytes> bitonic: I'll read
05:53:24 <bitonic> the do pretty sophisticated stuff which you probably don't need
05:53:27 <bitonic> but it's neat
05:53:39 <bitonic> you should read the newest version directly, with ClosedTypeFamilies
05:53:47 <sgronblo> oh i just did (3 :: Integer) and it worked fine
05:53:51 * hackagebot Deadpan-DDP 0.2.0.0 - Write clients for Meteor's DDP Protocol  http://hackage.haskell.org/package/Deadpan-DDP-0.2.0.0 (LyndonMaydwell)
05:54:24 <wei2912> bitonic: can you explain bitonic sort? :)
05:54:53 <gigabytes> bitonic: thanks
05:54:57 <bitonic> wei2912: no, I just liked the name :P
05:55:02 <wei2912> bitonic: haha
05:55:18 <bitonic> gigabytes: actually I'm not sure it was a paper, but kosmikus had code using that
05:55:41 <bitonic> ah yes, there <http://www.andres-loeh.de/TrueSumsOfProducts/>
05:55:47 <gigabytes> thanks!
05:56:04 <bitonic> I think it's that anyway
05:57:04 <bitonic> no wait, I think I'm getting confused :P.  that's the replacement of GHC.Generics
05:57:58 <bitonic> gigabytes: scrap that, I'll try to find what I'm thinking about :P
05:58:09 <gigabytes> ok :)
05:59:44 <bitonic> gigabytes: there <http://www.pa-ba.net/modularity/pubs/entries/bahr14wgp.html>.  I thought I had dreamt of it for a second
05:59:54 <bitonic> note that this won't be directly useful to your problem
06:00:01 <bitonic> but again it's pretty neat
06:00:33 <bitonic> they define this "subtyping" relation which is kinda what you're looking for when you say that all propositional formulas are temporal too
06:01:21 <bitonic> and they do use closed type families.  so something in the direction of your original idea
06:08:51 * hackagebot Deadpan-DDP 0.2.0.1 - Write clients for Meteor's DDP Protocol  http://hackage.haskell.org/package/Deadpan-DDP-0.2.0.1 (LyndonMaydwell)
06:08:53 * hackagebot snap-error-collector 1.0.0 - Collect errors in batches and dispatch them  http://hackage.haskell.org/package/snap-error-collector-1.0.0 (OliverCharles)
06:08:55 * hackagebot nats-queue 0.1.2.0 - Haskell API for NATS messaging system  http://hackage.haskell.org/package/nats-queue-0.1.2.0 (ondrap)
06:10:37 <kosmikus> bitonic: thanks for advertising my papers, even if by accident ;)
06:17:17 <bitonic> kosmikus: you're very welcome.  it was the one that I got more into at WGP :P
06:17:58 <bitonic> *most
06:18:08 <bitonic> kosmikus: btw, is that stuff coming out in 7.10?
06:21:08 <Jkerzz> Some-one here is - unity 3d programmer- ?
06:21:13 <kosmikus> bitonic: generics-sop doesn't need compiler support. it's a library.
06:21:40 <kosmikus> bitonic: http://hackage.haskell.org/package/generics-sop
06:22:34 <bitonic> kosmikus: I was under the vague impression that it was going to replace or at least work side-by-side the current Generic?
06:22:46 <bitonic> it'd be much better if that was the standard
06:23:27 <bitonic> although killing the current Generic would break a lot of code...
06:23:37 <dreixel_> bitonic: why is sop better than Generic?
06:23:39 <kosmikus> bitonic: apart from aesthetic reasons, why would it be better?
06:24:19 <kosmikus> bitonic: I currently have no intention to break compatibility for the current GHC.Generics without need
06:24:24 <bitonic> well, aesthetic reasons matter
06:24:29 <bitonic> kosmikus: ok, got it
06:24:45 <bitonic> the encoding you presented was easier to grok, at least for me
06:25:01 <bitonic> it seemed a more direct representation of what the data type is like
06:25:12 <kosmikus> bitonic: and if you're opposed to using TH, that's fine :) you can use generics-sop without TH, by using a type-level translation of the GHC.Generics encoding
06:25:24 <dreixel> kosmikus, btw, it'd be great if you could have a quick look at https://phabricator.haskell.org/D493
06:25:46 <kosmikus> dreixel: yes, ok
06:25:57 <dreixel> you and any user of metadata in GHC.Generics
06:26:34 <bitonic> kosmikus: it's more the fact that for these kind of facilities, I try to use what the standard is, especially for libraries
06:27:24 <bitonic> it's one of those things that really shines if everybody's using it, so you have Generic instances for a lot of stuff
06:29:50 <kosmikus> bitonic: I understand your point. but really, you can use generics-sop *via* GHC.Generics, i.e., all you datatypes will have Generic instances, and it should interoperate well
06:30:00 <bitonic> ah right, cool
06:30:38 <kosmikus> dreixel: have you actually tried any GGP encoding (not necessarily the one to -sop) with your new metadata encoding?
06:30:45 <kosmikus> dreixel: I assume they still work?
06:31:11 <kosmikus> dreixel: I'm ok with https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/GenericDeriving#Amoreconservativefirstapproachtothisproblem
06:32:40 <bitonic> dreixel: to answer your original question, I don't know what you mean by "better", the encoding used by -sop looked nicer to me, that's all
06:34:47 <bitonic> with GHC.Generics I'm always slightly puzzled on what those constructors contain.  then again, I've never used -sop seriously, so maybe when you get down to it's equally confusing :P
06:38:42 <hayward11> hi folks i remember coming across a video demonstrating fibonacci in haskell and comparing it to java showing its memory usage. any chance someone remembers it? my google-fu is not working.
06:39:16 <wei2912> hayward11: no
06:39:44 <kadoban> That doesn't sound very interesting, heh. Wouldn't the memory usage be pretty much nothing for any decent implementation?
06:40:01 <kosmikus> bitonic: FWIW, I also prefer -sop :) but again, I'm currently not convinced the default encoding should change.
06:40:23 <hayward11> it was in some conference
06:40:47 <hayward11> and it showed the java heap balooning up, while haskell was constant since we lazyly memoize stuff
06:40:50 <kosmikus> dreixel: I think I'm not sufficiently familiar with the GHC codebase to judge the patch itself. it it implements what's on the trac, then I think I'm fine with it (again, assuming that GGP encodings still work)
06:40:59 <bitonic> kosmikus: it'd be troubling if *you* didn't prefer -sop :)
06:41:39 <kosmikus> bitonic: well, I'm co-responsible for GHC.Generics, too, so I'm certainly not opposed to it either
06:42:42 <clrnd> hayward11, you mean a recursive fibonacci? java has no TCO, that's not a fun thing to watch :P
06:42:50 <kadoban> hayward11: Hmm, that doesn't sound fair as a comparison. It probably was a really bad java implementation vs an okay haskell one. It's certainly possible to write one in java that won't explode memory usage. It's harder to make an infinite list I'm sure, but...that's not really necessary.
06:42:57 <bitonic> kosmikus: oh no, me neither.  I'm very grateful for GHC.Generics
06:43:10 <bitonic> the -sop thing seemed nicer, that's all
06:44:53 <bitonic> although TH often wins in the end :P
06:44:56 <kosmikus> bitonic: we'd need a Generic1-like hack at the very least before we could seriously propose to replace the default encoding
06:45:15 <kosmikus> bitonic: but actually, my overall point is that the "default" encoding really shouldn't matter all that much
06:45:33 <kosmikus> bitonic: that's what http://www.andres-loeh.de/GenericGenericProgramming/ is all about
06:45:44 <bitonic> kosmikus: that'd be nice, but I'd still like to know that I'm not doing multiple passes on some intermediate data
06:46:04 <kosmikus> bitonic: yes, true. the performance angle still needs some work in practice.
06:46:23 <hayward11> kadoban: yeah, the speaker just demod evaling a function twice and it was fast the second time around. with java pausing for GCs. anyway, i was hoping i would dig it up for my friend to consider haskell.
06:46:26 <bitonic> kosmikus: that seems like a tough problem though.  I'm not sure we'll see a reliable solution soon
06:47:09 <kosmikus> bitonic: not a definitive solution, but I'm quite optimistic that things can and will get better in the not so distant future.
06:47:30 <bitonic> let's hope so :).  I'll check that out
06:50:43 <clrnd> hayward11, we have better examples if you want some. does it have to be compared to java?
06:56:12 <hayward11> clrnd: not really comparing java. the video i was looking for demoed ghci and displaying the unevaled thunks etc. which i wanted him to see. just basic intro to laziness and strong typing stuff. any examples you have in mind?
06:56:31 <clrnd> i read a pretty good one last week, let me look
06:57:29 <hayward11> clrnd: thanks!
06:58:13 <wei2912> what haskell vids should i watch?
06:58:34 <clrnd> hayward11, http://jelv.is/blog/Lazy-Dynamic-Programming/
07:00:31 <Peaker> Having anything named _foo be a hole is quite problematic! I have tons of these field names due to lens
07:01:00 <Peaker> and if I use the field names directly (quite useful with RecordWildCards!) instead of getting name errors (which are easy to debug), I essentially get "undefined"s thrown into my code there
07:01:05 <Peaker> which give harder to debug type errors
07:01:07 <bitonic> Peaker: they are a hole if they're not in scope
07:01:16 <bitonic> I agree that it can be puzzling though
07:01:20 <Peaker> right, but I just removed a field named _foo
07:01:28 <Peaker> and uses of _foo now generate a cryptic type error instead of a useful name error
07:01:41 <bitonic> you get used to it very quickly.  but yeah it's less than ideal
07:01:45 <Peaker> and why doesn't GHC give the warnings it could give if there are any errors? That's super-annoying
07:02:03 <bitonic> for me those errors pretty much mean "this is either a hole or this thing is not in scope"
07:02:34 <hayward11> clrnd: thanks. skimmed this a bit since i havent read it. love the animated diagrams.
07:02:35 <bitonic> I'd personally would have preferred -XTypeHoles, but whatevs
07:02:43 <clrnd> np :D
07:02:58 <Peaker> bitonic: but I don't get a specific error
07:03:08 <Peaker> bitonic: I get an arbitrary type error
07:03:15 <Peaker> that's not recognizable as related to the holes' feature
07:03:26 <bitonic> Peaker: ?  I get "found hole _foo of type ..."
07:03:40 <Peaker> bitonic: that's not what I have, I had a field _foo that I deleted
07:03:47 <Peaker> and I fixed all my code not to need it being passed around
07:03:54 <Peaker> so I had:  f _foo 5
07:04:02 <Peaker> but now f doesn't take the first argument it used to take
07:04:14 <Peaker> so I get a random type error about f being applied with 2 args, and no mention of any hole
07:04:21 <bitonic> ah.  right.
07:04:26 <Peaker> the mention of "found hole .." is only after it passed type-checking :(
07:04:29 <bitonic> yeah, that sucks
07:06:41 <bitonic> I'm not sure why they didn't just have -XTypeHoles
07:07:13 <Peaker> I guess because it is backwards compatible, supposedly
07:07:20 <Peaker> (if you ignore errors it is)
07:07:38 <Peaker> it'd be fine if they generated the "found hole" thing as an error first, and then the silly type errors would be fine if they follow
07:08:34 <Peaker> "cabal build" is wasting so much of my time as overhead around my builds :(  Profiling it would suck because GHC profiling is not statistic (the sane way to time-profile) so it perhaps wouldn't be easy to fix...
07:08:46 <Peaker> though the problem is so bad, that profiling could possibly be easy
07:09:22 <bitonic> Peaker: if you stop immediately at type holes you make them way less useful
07:10:08 <Peaker> bitonic: why stop? Just emit the warning/error there - and if no types are available (due to errors) just don't emit the extra useful info
07:10:28 <bitonic> Peaker: ah right, so you emit the warning for holes anyhow, plus the additional errors.  yeah that sounds reasonable
07:12:10 <Peaker> lots of times, if ghc emitted "warning: parameter 'y' is unused" before/in-addition to: "error: cryptic type error here", it would be sooo much easier to debug
07:12:35 <Peaker> for some reason, ghc treats warnings as a sad reward for fixing all type errors
07:13:01 <Peaker> worse still, sometimes you get: "warning: big_thing is now dead code" after you've spent 10 minutes fixing type errors inside it!
07:13:54 * hackagebot Deadpan-DDP 0.2.1.1 - Write clients for Meteor's DDP Protocol  http://hackage.haskell.org/package/Deadpan-DDP-0.2.1.1 (LyndonMaydwell)
07:30:06 <joyfulmantis> optparse-applicative users, is it possible to accept a Data.Text argument rather than a string one?
07:32:08 <ChristianS> joyfulmantis: command-line args are quite short, why not just stick with String? performance won't matter there.
07:32:38 <pantsman> String seems baked into optparse-applicative; I think your options are either to convert from String to Text, or start hacking on optparse-applicative
07:32:51 <pantsman> convert from Text to String, rather
07:33:55 <chpatrick> you can just do pack <$> on your strOption
07:33:55 * hackagebot eibd-client-simple 0.0.4 - EIBd Client  http://hackage.haskell.org/package/eibd-client-simple-0.0.4 (vapourismo)
07:34:09 <Peaker> ChristianS: proliferation of types and annoying conversions could be a reason..
07:35:51 <joyfulmantis> ChristianS: the problem is that the rest of my script is wirtten using Text, and if optparse-applicative will only give me strings, it would ruin some code reuse, and make a uguly split between the part of my script that uses Text and the part that uses string
07:36:17 <chpatrick> joyfulmantis: why not fmap pack on the option?
07:36:29 <chpatrick> joyfulmantis: or make a Parser Text
07:37:06 <Phillemann> Strange, stackage.org says "clock" is in stackage, but cabal install clock yields no results.
07:37:38 <joyfulmantis> chpatrick: thanks, Ill try that
07:40:32 <bitonic> is it possible to use -fdefer-type-errors to go over "not in scope" errors as well?  it'd be good while refactoring
07:43:48 <joyfulmantis> chpatrick: packing the strArgiment worked lovely, thanks again!
07:59:39 <fds4345> im using atom and it takes a long time to show errors and such, using ghc-mod I think
08:03:12 <zguy> does atom integrate with a haskell compiler?
08:04:06 <clrnd> isn't atom inherently slow?
08:04:29 <Clint> thoughtpolice: what's the deal with ed25519
08:04:30 <k00mi> fds4345: atom the editor?
08:08:56 * hackagebot ekg-bosun 1.0.2 - Send ekg metrics to a Bosun instance  http://hackage.haskell.org/package/ekg-bosun-1.0.2 (OliverCharles)
08:39:16 <trap_exit> is there a good tutorial on "design and impmenetation of the Fay langauge" ?
08:39:25 <trap_exit> is there a good tutorial on "design and impmenetation of the Fay langauge" ? (Fay is written in Haskell)
08:44:02 <hexagoxel> Gurkenglas: i'd like to add something to the djinn-recursive-types-decidability question: i think you can encode the post correspondence problem in a djinn environment, if you allow recursive data structures.
08:47:23 <benzrf> "preceded by itself in quotes is false." preceded by itself in quotes is false.
08:48:18 <exio4> benzrf: godel!
08:48:18 <Denommus> if there an operator like (&&&), but ternary and that produces a triple instead of a tuple?
08:48:23 <benzrf> :k Void
08:48:24 <lambdabot> Not in scope: type constructor or class ‘Void’
08:48:27 <benzrf> Denommus: don't think so
08:48:35 <benzrf> Denommus: there's liftA3 (,,)
08:48:40 <benzrf> @let data Void
08:48:42 <lambdabot>  Defined.
08:48:47 <exio4> Denommus: \x y z -> x &&& (y &&& z)?
08:49:04 <benzrf> @let newtype Hmm a = Hmm {unHmm :: a -> Void}
08:49:05 <lambdabot>  Defined.
08:49:07 <benzrf> :k Mu Hmm
08:49:08 <lambdabot> *
08:49:09 <Peaker> exio4: due to horribleness of lifted products, (a,(b,c)) /= (a,b,c)
08:49:24 <exio4> well, it isn't but is!
08:49:27 <benzrf> @let thing :: Mu Hmm; thing = undefined
08:49:28 <lambdabot>  Defined.
08:49:34 <Denommus> exio4: that produces a (x, (y, z)) :P
08:49:36 <benzrf> :t out thing
08:49:36 <lambdabot> Hmm (Mu Hmm)
08:49:40 <Denommus> exio4: I wanted a (x, y, z)
08:49:44 <benzrf> :t unHmm (out thing)
08:49:45 <lambdabot> Mu Hmm -> Void
08:49:53 <benzrf> :t (unHmm (out thing)) thing
08:49:54 <lambdabot> Void
08:50:21 <benzrf> is Mu Hmm inhabited
08:50:28 <benzrf> by non bottom
08:50:34 <benzrf> did i gödel
08:50:38 <benzrf> that seemed too easy
08:50:39 <Denommus> benzrf: liftA3 did the job
08:50:42 <benzrf> Denommus: :-)
08:51:35 <Denommus> I'm almost making an engine on top of SDL by accident
08:55:08 <Gurkenglas> hexagoxel, if that is true that's a bummer but I think I would be willing to sacrifice termination for support of recursive data structures.
08:56:22 <Gurkenglas> hexagoxel, but how would you do that? My remark about the context-free grammar still holds, could you elaborate?
08:58:06 <favetelinguis> I have a list of [2,34,4] i now want to execute a function and use each element in that list as input as such INPUT !! [SOME LIST] to get the 3 elements in the list that corresponds to the indexes in the first list... Does that make sense?
08:58:41 <mauketwork> INPUT !! [SOME LIST] is a type error
08:58:53 <mauketwork> where does the function come in?
08:58:57 <wei2912> favetelinguis: yeh, except that you got the position of the arguments mixed up
08:59:13 <Cale> favetelinguis: I think you're perhaps looking for map?
08:59:18 <wei2912> do you know about map?
08:59:30 <favetelinguis> noope only map
08:59:33 <Cale> Or zipWith
08:59:43 <Cale> zipWith (!!) input someList
08:59:54 <wei2912> > let mapGet xs zs = map (zs !!) xs
08:59:56 <lambdabot>  not an expression: ‘let mapGet xs zs = map (zs !!) xs’
09:00:04 <wei2912> > let mapGet xs zs = map (zs !!) xs in mapGet [0..] [1, 3, 10]
09:00:06 <lambdabot>  [1,3,10,*Exception: Prelude.(!!): index too large
09:00:10 <wei2912> whoops
09:00:16 <wei2912> > let mapGet xs zs = map (zs !!) xs in mapGet [1, 3, 10] [0..]
09:00:16 <Cale> whoops indeed
09:00:18 <lambdabot>  [1,3,10]
09:00:25 <wei2912> > let mapGet xs zs = map (zs !!) xs in mapGet [1, 3, 10] [1..]
09:00:26 <lambdabot>  [2,4,11]
09:00:29 <wei2912> ^^
09:00:31 <wei2912> alternatively
09:00:48 <favetelinguis> got a parse error on map? in hoogle
09:00:50 <Cale> (!!) is inherently dangerous, and any case where you're using it, you should ask yourself whether lists are really the correct data structure
09:00:55 <wei2912> > let mapGet xs zs = zipWith (!!) xs zs
09:00:57 <lambdabot>  not an expression: ‘let mapGet xs zs = zipWith (!!) xs zs’
09:01:00 <Cale> :t map
09:01:01 <lambdabot> (a -> b) -> [a] -> [b]
09:01:05 <wei2912> > let mapGet xs zs = zipWith (!!) xs zs in mapGet [1, 3, 10] [1..]
09:01:05 <Cale> :t zipWith
09:01:06 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
09:01:07 <lambdabot>  No instance for (GHC.Show.Show c0)
09:01:07 <lambdabot>    arising from a use of ‘M528988725374669652619619.show_M5289887253746696526...
09:01:07 <lambdabot>  The type variable ‘c0’ is ambiguous
09:01:07 <lambdabot>  Note: there are several potential instances:
09:01:08 <lambdabot>    instance [safe] GHC.Show.Show
09:01:16 <wei2912> hmm
09:02:02 <wei2912> > zipWith (!!) [1, 2, 10] [10..]
09:02:03 <lambdabot>  No instance for (GHC.Show.Show c0)
09:02:03 <lambdabot>    arising from a use of ‘M463858990617170677119653.show_M4638589906171706771...
09:02:03 <lambdabot>  The type variable ‘c0’ is ambiguous
09:02:03 <lambdabot>  Note: there are several potential instances:
09:02:03 <lambdabot>    instance [safe] GHC.Show.Show
09:02:30 <Cale> oh, right of course
09:02:32 <wei2912> > zipWith (!!) [10..] ([1, 2, 10] :: [Int])
09:02:33 <lambdabot>  No instance for (GHC.Show.Show c0)
09:02:33 <lambdabot>    arising from a use of ‘M755388074999591753419678.show_M7553880749995917534...
09:02:33 <lambdabot>  The type variable ‘c0’ is ambiguous
09:02:33 <lambdabot>  Note: there are several potential instances:
09:02:33 <lambdabot>    instance [safe] GHC.Show.Show
09:02:37 <wei2912> dang
09:02:43 <favetelinguis> ok thanks need some time now to try this out going a bit to fast
09:03:01 <Cale> > zipWith (!!) (repeat [1..]) [1,2,10]
09:03:02 <lambdabot>  [2,3,11]
09:03:16 <wei2912> ahh
09:03:57 <Peaker> zipWith f (repeat x) == map (f x)
09:04:04 <Cale> (forgive me for that type error, I've had 4 hours of sleep and I'm still trying to wake up :)
09:04:14 <Cale> yes
09:04:48 <Peaker> Okay guys, you can put the Guillotine back in storage
09:04:54 <Cale> what?
09:04:55 <Cale> oh
09:05:02 <wei2912> Cale: and i'm too tired to sleep
09:05:14 <wei2912> Cale: err, too tired and want to*
09:05:22 <wei2912> i must be really sleepy
09:05:25 <Cale> hehe
09:05:29 <zguy> Guillotine?
09:05:34 <Cale> Too tired to sleep would be an interesting condition
09:05:40 * Peaker has renamed the channel to #haskell-naptime
09:06:08 <wei2912> does anyone know of a haskell playground like what golang has?
09:06:18 <wei2912> http://play.golang.org/
09:06:27 <wei2912> a REPL doesn't cut it for me
09:06:50 <zguy> tryhaskell.org
09:07:23 <wei2912> zguy: that's a REPL, i need something more similar to the golang playground. it's for a document i'm writing
09:07:24 <zguy> Sorry, that's more repl like, not like golang
09:07:27 <wei2912> yeh.
09:07:31 <zguy> go to ideone.com
09:07:40 <wei2912> well
09:07:43 <zguy> You can choose haskell in the compiler settings.
09:07:43 <wei2912> why didn't i think of that
09:07:50 <wei2912> i've used ideone before...
09:07:58 <zguy> Yeah, Ideone is really nice/has gotten better over the years.
09:09:13 <wei2912> hmm
09:09:16 <wei2912> now that i think of it...
09:09:43 <mauketwork> https://www.fpcomplete.com/business/fp-haskell-center/ ?
09:09:56 <wei2912> i need something different; i need the ability to sort of load up a file containing functions, then have a REPL
09:10:00 <wei2912> like "ghci file.hs"
09:10:55 <mauketwork> ghci
09:11:10 <wei2912> that is online
09:11:26 <wei2912> mauketwork: thanks, will look into it
09:12:48 <wei2912> mauketwork: hmm, doesn't look like it does what i need
09:12:53 <_pharpend> o hi wei2912
09:12:56 <_pharpend> what are you doing here?
09:12:57 <wei2912> hi _pharpend
09:13:20 <wei2912> 01:08 < wei2912> i need something different; i need the ability to sort of load up a file containing functions, then have a REPL
09:13:23 <wei2912> 01:08 < wei2912> like "ghci file.hs"
09:13:23 <wei2912> online
09:15:33 <_pharpend> oh okay
09:16:30 <_pharpend> wei2912: you might look at this, https://github.com/chrisdone/tryhaskell , chrisdone managed to get a fully functioning haskell repl running with javascirpt
09:16:54 <wei2912> _pharpend: seen that, it doesn't fit my needs. :(
09:18:04 <_pharpend> i don't do web stuff, so I don't really think I can help you
09:36:47 <nkar> does anyone know off hand why the output of Data.Digest.Pure.SHA1 differs from sha1sum?  someone said that one possibility is encoding
09:38:29 <alkabetz> How are you testing?
09:38:47 <alkabetz> Like, what string are you passing to the Haskell function and the coreutils tool?
09:39:33 <mauketwork> also, how are you invoking sha1sum?
09:40:23 <nkar> mauketwork: echo "foo" | sha1sum
09:40:33 <mauketwork> and your haskell code?
09:40:34 <nkar> alkabetz: similar to the saltedHash function in yesod
09:40:42 <alkabetz> nkar: Try 'echo -n "foo" | sha1sum'
09:40:49 <alkabetz> echo adds a trailing newline
09:41:22 <nkar> lol
09:41:37 <nkar> yes, it's a newline character.  thanks alkabetz
09:41:53 <alkabetz> You’re welcome.  I’ve had exactly the same problem. :)
09:42:03 <benmachine> unfortunately it is in the nature of hashes that there is no such thing as nearly right :P
09:42:54 * wayne collides with benmachine
09:44:10 <favetelinguis> Lets say i have a matrix with 81 cells in a 9x9 layout, now im given as input (row,col) tuple and i need a function outputs a number between 1-9 representing which of 3x3 sub blocks the cell is contained in. Think Sudoku that would be exact same thing, 1-9 goes from left to right from top to bottom
09:44:25 <favetelinguis> sort of a math question i guess
09:45:29 <hexagoxel> Gurkenglas: my idea is the following: https://gist.github.com/lspitzner/9d185a634c0ca0752b09
09:46:10 <hexagoxel> (used the problem instance from wikipedia)
09:46:12 <Gurkenglas> Of course.
09:46:33 <alkabetz> faveteling: How about 'let quadrant (y, x) = x `div` 3 + 3 * (y `div` 3)'?
09:47:10 <alkabetz> Oh, excuse me, that goes 0–8, not 1–9.  It should be easy to modify for the 1–9 case, though.
09:49:01 <favetelinguis> alkabetz: yes that works perfect
09:49:09 <favetelinguis> how did you come up with that?
09:49:36 <Gurkenglas> (Why secret?)
09:51:22 <alkabetz> faveteling: I noted that the sub-block number could be written as a + 3b, where a and b are the x and y indices of the sub-block, and then I thought about how to compute a and b separately.
09:52:14 <favetelinguis> ok nice thanks
09:52:20 <alkabetz> You’re welcome.
09:59:46 <hexagoxel> (just careful about what i publish online; i default to private)
10:00:01 <Gurkenglas> hexagoxel, did you mean to have three ways to construct a Foo? Because as it is, you have one constructor with three arguments.
10:02:02 <hexagoxel> i want one constructor with three arguments
10:02:54 <hexagoxel> if you had three constructors, what would the result of the "wrong" cases be?
10:03:14 <Gurkenglas> (The "Of course." was when I realized that you ought to be able to reverse reductions to circumvent the context-free thing; since then I've been trying to grasp your code)
10:03:31 <hexagoxel> you might go with that, and change the query to type `Foo () () -> Maybe (Bar () ())`
10:04:00 <hexagoxel> but then one solution is the const Nothing, and i prefered to exclude that
10:04:16 <hexagoxel> *preferred
10:04:25 * hexagoxel makes that mistake way too often
10:05:41 <lengzai> let's say i'm in the State monad and I want to putStrLn from inside there... what sort of wizardry would I have to do?
10:06:12 <lengzai> also, if I call some function that returns a monad, how could I unpack the monad so I can call putStrLn . show to whatever is inside it?
10:06:36 <Gurkenglas> :t (>>= putStrLn)
10:06:39 <lengzai> if that makes any sense...
10:06:40 <lambdabot> IO String -> IO ()
10:07:04 <Gurkenglas> Oh, any monad...
10:07:21 <lengzai> it's simple enough inside the IO monad
10:07:31 <mauketwork> functions return values
10:07:34 <mauketwork> a value is not "a monad"
10:07:50 <Gurkenglas> lengzai, give the type signature you want
10:07:59 <mauketwork> in general you can't do IO directly from within State
10:08:18 <mauketwork> you can return an IO value, though: State s (IO a)
10:08:27 <mauketwork> or you can use a StateT transformer over IO
10:08:30 <hexagoxel> Gurkenglas: by pattern matching, we can create Bar x y with x and y longer and longer strings over {A,B}. Then we "check" that the two strings are equal using the reduce functions
10:08:37 <mauketwork> I think that's spelled StateT s IO a
10:08:48 <mauketwork> and in that case you'd use liftIO (putStrLn "whatever")
10:08:57 <lengzai> hm... ok
10:09:16 <lengzai> i've been trying to wrap my head around the state monad for a few days lately
10:09:32 <Gurkenglas> hexagoxel, I got that that is the purpose, I'm trying to figure how those three-argument constructors are supposed to achieve that
10:09:37 <alkabetz> lengzai: You can think of it as just sugar for passing extra parameters around.
10:09:40 <lengzai> and i think i'm making some progress, but i just don't know if it's actually working because i can't print any output to check
10:09:59 <alkabetz> lengzai: You might want Debug.Trace, then
10:10:10 <lengzai> oh, that sounds like a good idea
10:10:16 <chpatrick> I think it's worth figuring out how it works :)
10:10:32 <chpatrick> State is the same as s -> ( a, s )
10:10:39 <chpatrick> so literally a function that takes s and also returns a new s
10:10:52 <chpatrick> StateT is the same except it's s -> m ( a, s )
10:11:32 <lengzai> so that's why it uses identity?
10:11:35 <chpatrick> yep
10:11:43 <chpatrick> the monad instance just plumbs the new state into the next function
10:11:51 <chpatrick> but it's just a regular old function
10:12:41 <ReinH> @unmtl StateT s ID a
10:12:42 <lambdabot> s -> ID (a, s)
10:12:46 <ReinH> er, OK
10:12:52 <ReinH> IO. What is wrong with my fingers.
10:13:32 <lengzai> so for example, i'm trying to build a Snake game, and I made a data GameState with some parameters like the snakes current position and what direction he's going
10:14:35 <Cale> (but using StateT over IO is a little silly imo... there are cases where it's okay, but many more uses in the wild than are actually justified)
10:14:50 <chpatrick> all of the stuff like moveSnake :: Position -> StateT GameState IO () is really just Position -> GameState -> IO ( (), GameState )
10:14:55 <ReinH> Cale: why do you think it's silly?
10:15:04 <chpatrick> ReinH: might as well use IORefs?
10:15:15 <chpatrick> way better performance
10:15:16 <Cale> Because IO already has a large amount of state-related facilities
10:15:34 <lengzai> ok
10:15:39 <Cale> and you pay the price of having to lift all your IO actions
10:15:58 <alkabetz> lengzai: I’d write a pure core for updating your state with functions like 'moveSnake :: Position -> State ()', and then I’d write an impure wrapper in IO that takes care of processing input, updating the display, etc.
10:16:04 <ReinH> but then you're passing an IORef around everywhere
10:16:12 <Cale> So, just passing a parameter is usually more sensible, unless you're doing something very well-structured, where you can sort of hide the fact that you're really the IO monad underneath.
10:16:40 <Cale> I'd rather pass around a parameter than have to lift most things, in most cases.
10:17:55 <nitrix> I have a 6000 lines application that still just prints Hello world x]
10:18:01 <lengzai> alkabetz: ok, I understand that much. But then the next thing that confuses me is if I'm just passing in the Position, where would the original state come from?
10:18:20 <lengzai> like, if I want to make a function like moveSnake :: Direction -> State GameState ()
10:18:51 <lengzai> does that even make sense?
10:19:48 <lengzai> GameState has a position
10:20:45 <hexagoxel> Gurkenglas: updated gist to show the possible result of the query (if you had not already done the same :)
10:21:10 <Gurkenglas> Currently doing it, lets see how far I get
10:23:16 <alkabetz> lengzai: Ah, yes.  You’d want to hang onto the state outside the State monad.  In event-driven code, I’d use an IORef (or an MVar if you’re doing multithreading), but you might just want to use a variable.  Without knowing more about your code, it’s a bit hard to offer detailed advice.
10:24:02 * hackagebot yesod-core 1.4.4.5 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.4.4.5 (MichaelSnoyman)
10:24:14 <lengzai> alkabetz: there is no code yet :P every time I write it I crumple it up and toss it in the bin and read another monad tutorial
10:24:31 <lengzai> I'm almost at the point where I can write my own monad tutorial XD
10:27:24 <Gurkenglas> hexagoxel, doesn't substituting (foo) for (Foo bar1 bar2 bar3) append the new types onto the same left side that reduceA and reduceB take from? It seems that you "made a stack where you wanted a queue"
10:28:43 <Gurkenglas> Oh, you probably intend to only reduce away once the stack is completed. What is stopping someone to mingle reduces and b*s together?
10:29:49 <Gurkenglas> (If I'm right, that's of course easily correctible; just have the b*s work in one type, the reduces in another, with single available coerce)
10:29:56 <Gurkenglas> *a single
10:32:26 <lengzai> thanks everyone for the suggestions by the way
10:32:37 <hexagoxel> Gurkenglas: yeah, you are right. i noticed a different issue: this idea does not depend on recursive data types (does it?)
10:33:30 <Gurkenglas> Even if it only needs custom functions, djinn doesn't support those :P (doesn't it?)
10:34:56 <Gurkenglas> Maybe we should get ##computerscience in on this?
10:36:00 <Gurkenglas> ...didn't someone once build a Turing Machine in the type system?
10:36:53 <Gurkenglas> (Well I guess we can assume that djinn needs only terminate if run on typechecked sources)
10:38:50 <chpatrick> does anyone know if there's a nice function to look something up a function name in AbsBinds?
10:46:05 <hexagoxel> i just tried what would happen if i used the post-correspondence environment transformed to a version without recursive data types
10:46:13 <hexagoxel> djinn just returns "f1"
10:46:17 <cdk> Are MultiParamTypeClasses+FunctionalDependencies equivalent in expressive power to TypeFamilies (using type classes with associated types)?
10:46:41 <cdk> ie. anything written using the former can be rewritten to use only the latter
10:46:54 <Gurkenglas> hexagoxel, source?
10:47:44 <lcf80> hello. question about Monad - SFAIK every Monad has to be Applicative. why does it have "return", then, which seems to be duplication of "pure" from Applicative?
10:48:18 <hexagoxel> Gurkenglas: env2 in gist
10:48:44 <glguy> lcf80: The creation of the Monad type class predates the Applicative one
10:49:03 * hackagebot ZFS 0.0.2 - Oleg's Zipper FS  http://hackage.haskell.org/package/ZFS-0.0.2 (jkarni)
10:49:04 <hexagoxel> Gurkenglas: and even with the query `foo ? A a -> B b` djinn returns "foo = f1"
10:49:55 <lcf80> so in future language versions it return could be dropped, I guess?
10:51:20 <Gurkenglas> ...hexagoxel, rename f1 to f11?
10:51:35 <Gurkenglas> (And make it the second defined function for good measure)
10:54:13 <hexagoxel> Gurkenglas: the problem is that djinn treats all constructor-less data types as Void (i think)
10:55:49 <hexagoxel> but, with recursive data types you could avoid that by writing something like `data A a = A (A a)`
10:56:46 <Gurkenglas> Sounds good except you need to use another type so djinn cant just duplicate the A as needed but yep
10:56:48 <Gurkenglas> Do eet
10:59:07 <mmachenry1> Using cabal, is there a way to rebuild just one file, even if it's been built, so that I can see warnings for that file? I want to go through my project one file at a time and clean up warnings.
10:59:52 <mmachenry> It seems odd and it's a bit annoying to touch the file and then rebuild the whole project because I have to rebuild all that depends on it. I really just want to see warnings for one file
11:01:13 <shiona> mmachenry: not sure about cabal, but you should be able to do "ghc -c file.hs" to compile one source file into object
11:01:46 <mmachenry> shiona: Yeah I know but that fails if I am in a cabal sandbox because it can't see my files.
11:02:01 <mmachenry> cabal exec ghc -c file.hs didn't work either. I got link errors.
11:02:29 <shiona> ok, can't help you then
11:04:25 <lpaste> cdk annotated “Lucid sans with” with “Lucid sans with (annotation) using FunctionalDependencies” at http://lpaste.net/114962#a115023
11:04:39 <Denommus> have you ever noticed how boobs are a valid value?
11:04:42 <Denommus> :t (.) (.)
11:04:43 <lambdabot> (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
11:05:20 <mmachenry> Denommus: Sadly, they have no instance of Show
11:06:38 <hexagoxel> Gurkenglas: hmm no, whenever you provide a constructor, it can freely wrap/unwrap; when not, djinn does not see the difference. which means my whole idea just is not expressible in djinn. dang. (also afk)
11:24:34 <mkscrg> Denommus mmachenry feel free to leave that chatter in your 1-1 messages
11:31:26 <Evilsparza> hey, is there an easy way to find *multiple* minima/maxima of a list (e.g. for allMinima [1,2,3,1] I want [1,1] and not solely 1, like Data.List.minimum returns)
11:32:09 <indiagreen> > head $ group $ sort [1,2,3,1]
11:32:10 <lambdabot>  [1,1]
11:32:13 <lpaste> glguy pasted “maximums” at http://lpaste.net/115027
11:32:38 <glguy> Evilsparza: there's no prelude function for it, you'll have to make something
11:34:16 <Evilsparza> indiagreen, thanks. that clearly works, though I had hoped there was something more efficient than that. sort and group have to go through the list twice right?
11:34:28 <indiagreen> Evilsparza: group is lazy
11:34:37 <indiagreen> > group $ 1:1:2:undefined
11:34:39 <lambdabot>  [[1,1],[2*Exception: Prelude.undefined
11:35:03 <Evilsparza> oh I see, I'll have a look then
11:35:04 <Gurkenglas> sort goes through the list superlinearly often.
11:35:45 <Gurkenglas> @src sort
11:35:46 <lambdabot> sort = sortBy compare
11:35:48 <kadoban> It'll be O(n lg n), but that's not too bad. You could do O(n) manually if it matters, but it probably doesn't.
11:35:51 <Gurkenglas> @src sortBy
11:35:52 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
11:36:00 <indiagreen> lies
11:36:01 <mmachenry> I can't find decent documentation on "cabal exec" it's not in the user's guide. Does anyone have a link that explains "cabal exec" and what it can do?
11:36:05 <indiagreen> it's an optimised mergesort
11:36:14 <indiagreen> with runs like in TimSort
11:36:56 <zguy> :t []
11:36:58 <lambdabot> [t]
11:37:09 <solrize> evilsparza, GHC.Exts.groupWith ?
11:37:14 <solrize> groupWith length
11:37:40 <solrize> dunno if it goes through the list twice.  if not, it has to use a map or something
11:37:55 <indiagreen> solrize: groupWith still won't sort it
11:38:01 <solrize> yes it does i think
11:38:21 <indiagreen> what, groupWith id ≠ group
11:38:23 <indiagreen> weird
11:38:40 <solrize> groupWith ≠ groupBy
11:38:44 <indiagreen> ...you're right
11:38:50 <indiagreen> okay, thanks, will remember
11:38:55 <indiagreen> cool
11:38:59 <solrize> i just ran across that myself a few days ago
11:39:00 <indiagreen> solrize wins then
11:39:00 <mkscrg> from haddocks: The groupWith function uses the user supplied function which projects an element out of every list element in order to first sort the input list and then to form groups by equality on these projected elements
11:39:03 <mkscrg> TIL!
11:39:18 <Faucelme> mmachenry: cabal exec lets you start an executable in the context of a sandbox
11:40:02 <Faucelme> if you cabal exec a shell, and start ghci inside the shell, ghci will see the packages installed in the sandbox.
11:40:22 <jle`> :t head . group . sort
11:40:22 <levi> 'cabal exec sh' is handy, as Faucelme explained.
11:40:24 <lambdabot> Ord a => [a] -> [a]
11:40:30 <solrize> apt-get install haskell-platform is bogging down miserably on ibgl1-mesa-dri ... is it too much to wish for a version of the platform with no graphics stuff, since the computer is a server with no screen that's sitting in a data center 1000's of miles away?
11:41:16 <mmachenry> So I should cabal exec sh and then ghc -c my stuff?
11:41:34 <mmachenry> Instead of cabal exec "ghc -c file" which does not seem to work.
11:41:46 <mmachenry> Is there a cabal documentation that mentions exec?
11:42:00 <levi> solrize: You could always install packages as-needed rather than installing the whole platform.
11:42:40 <mmachenry> When I do "ghc -c file" from within a "cabal exec sh" shell, it still can't find my libraries in the include path. :-(
11:42:56 <Hijiri> solrize: I recommend just installing ghc and cabal without haskell platform
11:43:11 <solrize> is there a debian package for cabal?
11:43:15 <Hijiri> yes
11:43:17 <solrize> hmm
11:43:38 <Hijiri> it's cabal-install
11:43:45 <solrize> ah cool
11:44:29 <solrize> i like having everything installed that i'm likely to use, so installing platform seems like a good thing, it's just that an awful lot of it is graphics that a server install can't possibly use, and that has to be a common situation (haskell on servers)
11:44:35 <Faucelme> mmachenry: how about cabal exec ghc -- -c foo.txt
11:44:52 <lcf80> would be nice to see platform 2014.2 available for both wheezy and jessie
11:45:39 <mmachenry> Faucelme: Nope. I guess I can try to add "src" to my include path. I'll find that argument and try your trick again
11:45:54 <Hijiri> I don't like installing debian packages that expose global haskell modules because it's difficult to hide them even in sandboxes
11:49:44 <mmachenry> Oddly enough, I get "Failed to load interface for `ThrottleGroup' Perhaps you meant ThrottleGroupMap (from throttlecontroller"
11:50:04 <mmachenry> It found one of the libraries from my src directory but can't find the other. And both are listed in by .cabal file.
12:05:58 <hexagoxel> Gurkenglas: updated gist again. with these modifications, there is no need for data types without constructors.
12:07:29 <Gurkenglas> Ooh. Does Djinn work with generic type classes?
12:08:22 <hexagoxel> what are generic type classes? do you mean type variables of kind != * ?
12:08:35 <Gurkenglas> I meant what you did :P
12:10:00 <hexagoxel> yes, afaik it can handle thoese
12:14:20 <waressearcher2> hey peaches
12:14:27 <Gurkenglas> Then run it!
12:14:58 <hexagoxel> Gurkenglas: well i can't, it contains recursive data types
12:15:25 <Gurkenglas> I guess I need more sleep?
12:16:32 <phaazon> https://www.reddit.com/r/haskell/comments/2nelc6/reactive_programming_through_explicit_effects/ :)
12:16:35 <hexagoxel> but i tried a simpler example with higher-kinded type variables, and .. djinn crashes
12:19:20 <Gurkenglas> dohoho
12:19:40 <waressearcher2> http://youtu.be/1PhArSujR_A a bit outdated
12:20:02 <waressearcher2> what are the benefits of immutability ?
12:21:51 <clrnd> waressearcher2, easier reassoning about code, maybe
12:21:54 <marens> not having to remember which code paths can modify members 3 layers deep into you data structure ... multithreaded :D
12:22:37 <clrnd> I literally just fixed a bug in Python because of some mutable value beign incorrectly mutated, fixed it by renaming the goddamned thing
12:28:00 <lengzai> that's my favorite thing ever
12:28:29 <lengzai> we code in python at work, and the code is so opaque
12:28:58 <lengzai> the spaghetti is everywhere
12:30:15 <h007> hi, could anyone tell me if i call a function f with an argument x first time, then call it again second time, with same arg x, does it run the function again?
12:31:18 <lengzai> maybe that be platform dependent?
12:31:31 <koala_man> h007: in general, yes
12:32:01 <h007> koala_man: thanks. is there a way to make it run the function again?
12:32:44 <mauke> yes, f x
12:32:47 <koala_man> h007: why, for benchmarking?
12:32:50 <h007> koala_man: at the moment, i have a simple test: map fib [40,40] and want to know if fib 40 is calculated 2 times or just once
12:33:07 <mauke> 2 times, probably
12:33:53 <h007> mauke: it doesn't seem so. if i replace map with parMap, it doesn't run in parallel...
12:34:12 <h007> mauke: it seems to be pointing to the first evaluation
12:34:17 <mauke> interesting
12:35:05 <h007> i just want to do some computation in a list. and these computation are the same -- taking same parameter. but it seems evaluation happens once
12:36:38 <mauke> > iterate (\x -> length (show x) * 20) 40
12:36:41 <lambdabot>  [40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,40,...
12:37:23 <koala_man> h007: does it matter for correctness or are you just benchmarking/testing?
12:37:51 <apriori> are there any accelerate users around? if so.. how do I prevent constant cuda recompilation when using accelerate cuda and the run1 function?
12:39:08 * hackagebot amazonka-autoscaling 0.0.3 - Amazon Auto Scaling SDK.  http://hackage.haskell.org/package/amazonka-autoscaling-0.0.3 (BrendanHay)
12:39:10 * hackagebot amazonka-cloudformation 0.0.3 - Amazon CloudFormation SDK.  http://hackage.haskell.org/package/amazonka-cloudformation-0.0.3 (BrendanHay)
12:39:12 * hackagebot amazonka-cloudfront 0.0.3 - Amazon CloudFront SDK.  http://hackage.haskell.org/package/amazonka-cloudfront-0.0.3 (BrendanHay)
12:39:14 * hackagebot amazonka-cloudsearch 0.0.3 - Amazon CloudSearch SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-0.0.3 (BrendanHay)
12:39:16 * hackagebot amazonka-cloudsearch-domains 0.0.3 - Amazon CloudSearch Domain SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-domains-0.0.3 (BrendanHay)
12:39:43 <h007> koala_man: yes am doing some perf testing
12:43:00 <sebastard> Who can help me? I have an algorithm that takes a Bool and a Tree, updates the Tree and outputs [Bool]. Now I want to 'map' this function over a list [Bool]. I guess something with State? ( randomBits :: Bool -> (Tree Label) -> ([Bool], (Tree Label)) , randomStream :: [Bool] -> ([Bool], Tree Label) )
12:43:51 <h007> koala_man: if that an expected behaviour, how can i force re-evaluation of a function given the same parameter... just for testing?
12:44:18 * hackagebot amazonka-cloudtrail 0.0.3 - Amazon CloudTrail SDK.  http://hackage.haskell.org/package/amazonka-cloudtrail-0.0.3 (BrendanHay)
12:44:20 * hackagebot amazonka-cloudwatch 0.0.3 - Amazon CloudWatch SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-0.0.3 (BrendanHay)
12:44:22 * hackagebot amazonka-cloudwatch-logs 0.0.3 - Amazon CloudWatch Logs SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-logs-0.0.3 (BrendanHay)
12:44:24 * hackagebot amazonka-codedeploy 0.0.3 - Amazon CodeDeploy SDK.  http://hackage.haskell.org/package/amazonka-codedeploy-0.0.3 (BrendanHay)
12:44:26 * hackagebot amazonka-cognito-identity 0.0.3 - Amazon Cognito Identity SDK.  http://hackage.haskell.org/package/amazonka-cognito-identity-0.0.3 (BrendanHay)
12:45:35 <koala_man> h007: I don't really know. I usually have the opposite issue :P
12:45:36 <spatials> Newbie here - in GHCI - XTemplateHaskell - what do I need to install?
12:45:46 <mauke> spatials: install?
12:46:18 <marchelzo_> spatials: I don't think TemplateHaskell works in ghci
12:47:48 <spatials> mauke: doing an exercise - error with 'elem'
12:48:10 <marchelzo_> spatials: `elem` maybe
12:48:43 <mauke> spatials: what error?
12:48:45 <clrnd> h007, maybe make it's type IO ()? what compiler are you using?
12:48:58 <h007> ghc 7.6
12:49:25 <h007> the payload function is just fib x
12:49:28 * hackagebot amazonka-cognito-sync 0.0.3 - Amazon Cognito Sync SDK.  http://hackage.haskell.org/package/amazonka-cognito-sync-0.0.3 (BrendanHay)
12:49:30 * hackagebot amazonka-config 0.0.3 - Amazon Config SDK.  http://hackage.haskell.org/package/amazonka-config-0.0.3 (BrendanHay)
12:49:32 * hackagebot amazonka-datapipeline 0.0.3 - Amazon Data Pipeline SDK.  http://hackage.haskell.org/package/amazonka-datapipeline-0.0.3 (BrendanHay)
12:49:34 * hackagebot amazonka-directconnect 0.0.3 - Amazon Direct Connect SDK.  http://hackage.haskell.org/package/amazonka-directconnect-0.0.3 (BrendanHay)
12:49:36 * hackagebot amazonka-dynamodb 0.0.3 - Amazon DynamoDB SDK.  http://hackage.haskell.org/package/amazonka-dynamodb-0.0.3 (BrendanHay)
12:49:56 <h007> i call parMap fib [40,40,40,40]
12:50:22 <sebastard> exit
12:50:54 <spatials> "syntax error - maybe you intended to use -XTempleteHaskell" in ghci
12:51:21 <marchelzo_> spatials: use backticks not single quotes
12:51:38 <mauke> spatials: that says nothing about installing anything
12:51:40 <spatials> ah -thanks
12:53:22 <SwashBuckla> why does an Amazon Haskell bug me?
12:53:41 <SwashBuckla> super awesome language used to connect to a not so awesome company
12:53:48 <SwashBuckla> :\
12:54:38 * hackagebot amazonka-ec2 0.0.3 - Amazon Elastic Compute Cloud SDK.  http://hackage.haskell.org/package/amazonka-ec2-0.0.3 (BrendanHay)
12:54:40 * hackagebot amazonka-elasticache 0.0.3 - Amazon ElastiCache SDK.  http://hackage.haskell.org/package/amazonka-elasticache-0.0.3 (BrendanHay)
12:54:42 * hackagebot amazonka-elasticbeanstalk 0.0.3 - Amazon Elastic Beanstalk SDK.  http://hackage.haskell.org/package/amazonka-elasticbeanstalk-0.0.3 (BrendanHay)
12:54:44 * hackagebot amazonka-elastictranscoder 0.0.3 - Amazon Elastic Transcoder SDK.  http://hackage.haskell.org/package/amazonka-elastictranscoder-0.0.3 (BrendanHay)
12:54:46 * hackagebot amazonka-elb 0.0.3 - Amazon Elastic Load Balancing SDK.  http://hackage.haskell.org/package/amazonka-elb-0.0.3 (BrendanHay)
12:56:27 <platz> quit
12:56:31 <platz> \quit
12:59:48 * hackagebot amazonka-emr 0.0.3 - Amazon Elastic MapReduce SDK.  http://hackage.haskell.org/package/amazonka-emr-0.0.3 (BrendanHay)
12:59:50 * hackagebot amazonka-iam 0.0.3 - Amazon Identity and Access Management SDK.  http://hackage.haskell.org/package/amazonka-iam-0.0.3 (BrendanHay)
12:59:52 * hackagebot amazonka-importexport 0.0.3 - Amazon Import/Export SDK.  http://hackage.haskell.org/package/amazonka-importexport-0.0.3 (BrendanHay)
12:59:54 * hackagebot amazonka-kinesis 0.0.3 - Amazon Kinesis SDK.  http://hackage.haskell.org/package/amazonka-kinesis-0.0.3 (BrendanHay)
12:59:56 * hackagebot amazonka-kms 0.0.3 - Amazon Key Management Service SDK.  http://hackage.haskell.org/package/amazonka-kms-0.0.3 (BrendanHay)
13:00:36 <vjeranc> is there a way to create a keyboard event in haskell, and this would trigger the character to be written in any textbox or any window that's currently in focus?
13:02:52 <spatials> mauke: bac tics - err- never had to use them before took a minute - lol
13:04:58 * hackagebot amazonka-lambda 0.0.3 - Amazon Lambda SDK.  http://hackage.haskell.org/package/amazonka-lambda-0.0.3 (BrendanHay)
13:05:00 * hackagebot amazonka-opsworks 0.0.3 - Amazon OpsWorks SDK.  http://hackage.haskell.org/package/amazonka-opsworks-0.0.3 (BrendanHay)
13:05:02 * hackagebot amazonka-rds 0.0.3 - Amazon Relational Database Service SDK.  http://hackage.haskell.org/package/amazonka-rds-0.0.3 (BrendanHay)
13:05:04 * hackagebot amazonka-redshift 0.0.3 - Amazon Redshift SDK.  http://hackage.haskell.org/package/amazonka-redshift-0.0.3 (BrendanHay)
13:05:06 * hackagebot amazonka-route53 0.0.3 - Amazon Route 53 SDK.  http://hackage.haskell.org/package/amazonka-route53-0.0.3 (BrendanHay)
13:10:00 <lcf80> hello - I am getting weird behaviour of GHCi after using QuickCheck
13:10:08 * hackagebot amazonka-route53-domains 0.0.3 - Amazon Route 53 Domains SDK.  http://hackage.haskell.org/package/amazonka-route53-domains-0.0.3 (BrendanHay)
13:10:10 * hackagebot amazonka-s3 0.0.3 - Amazon Simple Storage Service SDK.  http://hackage.haskell.org/package/amazonka-s3-0.0.3 (BrendanHay)
13:10:12 * hackagebot amazonka-sdb 0.0.3 - Amazon SimpleDB SDK.  http://hackage.haskell.org/package/amazonka-sdb-0.0.3 (BrendanHay)
13:10:14 * hackagebot amazonka-ses 0.0.3 - Amazon Simple Email Service SDK.  http://hackage.haskell.org/package/amazonka-ses-0.0.3 (BrendanHay)
13:10:16 * hackagebot amazonka-sns 0.0.3 - Amazon Simple Notification Service SDK.  http://hackage.haskell.org/package/amazonka-sns-0.0.3 (BrendanHay)
13:10:21 <lcf80> I have function to be dested defined like that
13:10:23 <lcf80> let badRepl x xs = if length xs == 4 then [] else replicate x xs
13:10:37 <lcf80> and my test is
13:10:40 <lcf80> let test = \x xs -> badRepl x xs == replicate x xs
13:10:56 <benzrf> lcf80: why not let test x xs = badRepl ...
13:11:25 <lcf80> umm, yeah, you're right
13:12:30 <lcf80> but problem is still there
13:12:35 <mauke> what problem?
13:12:36 <lcf80> after running quickCheck test
13:12:46 <lcf80> if either returns proper results
13:12:57 <lcf80> or keeps running - and then, after CTRL-C
13:13:05 <lcf80> CPU is still busy
13:13:30 <lcf80> I am in GHCi, but even typing is slowed down
13:13:46 <chrisdone> perhaps the list being generated is too big?
13:14:06 <lcf80> but shouldn't test stop running after CTRL-C?
13:14:25 <chrisdone> it should, but the memory use might cause your system to swap or ghci to garbage collect for a while
13:14:27 <chrisdone> how are you running the test?
13:14:39 <lcf80> just "quickCheck test"
13:15:18 * hackagebot amazonka-sqs 0.0.3 - Amazon Simple Queue Service SDK.  http://hackage.haskell.org/package/amazonka-sqs-0.0.3 (BrendanHay)
13:15:20 * hackagebot amazonka-storagegateway 0.0.3 - Amazon Storage Gateway SDK.  http://hackage.haskell.org/package/amazonka-storagegateway-0.0.3 (BrendanHay)
13:15:22 * hackagebot amazonka-sts 0.0.3 - Amazon Security Token Service SDK.  http://hackage.haskell.org/package/amazonka-sts-0.0.3 (BrendanHay)
13:15:24 * hackagebot amazonka-support 0.0.3 - Amazon Support SDK.  http://hackage.haskell.org/package/amazonka-support-0.0.3 (BrendanHay)
13:15:26 * hackagebot amazonka-swf 0.0.3 - Amazon Simple Workflow Service SDK.  http://hackage.haskell.org/package/amazonka-swf-0.0.3 (BrendanHay)
13:18:16 <absence> has anyone tried the haskforce plugin for intellij? is there a way to have different highlighting for a function name in the definition and type signature, like in sublime text?
13:19:28 <Cale> chrisdone: Someone in here a while ago was asking about whether there are any articles regarding the design and implementation of Fay.
13:20:28 * hackagebot amazonka 0.0.3 - Comprehensive Amazon Web Services SDK  http://hackage.haskell.org/package/amazonka-0.0.3 (BrendanHay)
13:20:30 * hackagebot amazonka-core 0.0.3 - Core functionality, serialisation primitives, and data types for the Amazonka Amazon Web Services SDKs.  http://hackage.haskell.org/package/amazonka-core-0.0.3 (BrendanHay)
13:20:32 * hackagebot lucid 2.0 - Clear to write, read and edit DSL for HTML  http://hackage.haskell.org/package/lucid-2.0 (ChrisDone)
13:20:57 <chrisdone> Cale: ah?
13:22:02 <Cale> It's a bit past my scrollback, but I can find it in the logs, I forget who it was
13:23:00 <indiagreen> it was trap_exit
13:23:08 <Cale> yes!
13:24:07 <chrisdone> http://ircbrowse.net/browse/haskell?q=trap_exit
13:24:16 <chrisdone> looks like he really wanted to know if there was something like HSE with type checking
13:25:08 <Cale> ah, I didn't see the rest
13:31:02 <latk> I'm implementing a Burrows-Wheeler transform, as an exercise for myself. The transform itself is easy, however, the inverse transform requires an "end character". If I'm operating on Strings only, how might I implement such an end character ?
13:31:57 <latk> If I choose a Char that is less than the lowest value in the input string, it could happen that the input string contains the lowest character in the Char enum, in which case it will fail.
13:32:16 <latk> So it seems that I have to somehow have a reserved character. Is this the case?
13:38:47 <indiagreen> latk: operate on [Maybe Char]
13:39:10 * hackagebot timezone-series 0.1.4 - Enhanced timezone handling for Data.Time  http://hackage.haskell.org/package/timezone-series-0.1.4 (YitzGale)
13:39:40 <indiagreen> (internally, I mean)
13:40:47 <indiagreen> hm, no, wait. The transform outputs a string which contains a reserved character, right?
13:41:26 <latk> indiagreen: That is how it appears to me - I could be wrong!
13:41:33 <indiagreen> so “transform :: String -> StringWithSingleReservedCharacter”, right
13:41:34 <latk> Well, only if you wish to reverse the transform, anyway
13:42:36 <indiagreen> I wonder how it's done when BWT is applied before a real compression algorithm
13:42:43 <latk> No idea :p
13:42:52 <indiagreen> they probably store the index of single reserved character separately
13:43:02 <latk> I think it would actually have to be StringWithReservedChar -> StringWithReservedChar
13:43:43 <latk> or mabye StringWithResrvedChar -> String
13:44:11 * hackagebot timezone-olson 0.1.6 - A pure Haskell parser and renderer for binary Olson timezone files  http://hackage.haskell.org/package/timezone-olson-0.1.6 (YitzGale)
13:45:09 <chirpsalot> With CmdArgs I have two modes, each with a -i / --MODEinputfile for an input file arguments. How can I make it give both -i and --MODEinputfile displayed under --help?
13:47:34 <mkscrg> anybody else seeing intermittent timeouts when calling hackage?
14:08:29 <m1dnight_> could somebody help me out here a sec? I'm trying to create an evaluator for simply typed lambda calculus
14:08:43 <m1dnight_> all is well atm but I need an environment, so I had a look at an implementation the lecturer did
14:09:19 <m1dnight_> so he defines a type Env as type Env k v = [(k, v)]
14:09:22 <m1dnight_> okay, seems fair
14:09:33 <m1dnight_> a method extend as: extend env xt = xt : env
14:10:21 <m1dnight_> but when I try to invoke extend on the empty list (i.e., []), and then insert a tuple (x, y) where type of X = "String" and type of Y is "Type" I get a rigid type error
14:10:31 <m1dnight_> I4ve been googling for an hour or two but I can't seem to solve the issue
14:10:56 <mauke> what's the error?
14:11:18 <m1dnight_> http://lpaste.net/115045
14:11:29 <m1dnight_> oh wait, that's not the right one :p
14:11:36 <m1dnight_> That's with other crap code to figure it out
14:11:38 <m1dnight_> hold on
14:12:02 <m1dnight_> http://lpaste.net/115046
14:12:05 <m1dnight_> that's the one :p)
14:12:43 <mauke> looks like your type signature is wrong
14:15:31 <m1dnight_> oooh I solved it :)
14:15:38 <m1dnight_> Well, you pointed me there :p
14:15:51 <m1dnight_> typeCheck :: Env Sym Type -> Exp -> Type \o/
14:29:12 * hackagebot shared-memory 0.1.0.0 - POSIX shared memory  http://hackage.haskell.org/package/shared-memory-0.1.0.0 (NiklasHambuechen)
14:29:14 * hackagebot hharp 0.1.0.0 - Binding to libharp  http://hackage.haskell.org/package/hharp-0.1.0.0 (thoferon)
14:30:02 <test___> distance p q = abs (fst p - fst q) + abs (snd p - snd q)
14:30:50 <test___> @pl \p q = abs (fst p - fst q) + abs (snd p - snd q)
14:30:51 <lambdabot> (line 1, column 6):
14:30:51 <lambdabot> unexpected "="
14:30:51 <lambdabot> expecting pattern or "->"
14:30:51 <Denommus> :t join (***)
14:30:52 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
14:31:27 <Denommus> :t join (***) :: (b -> c) -> (b, b) -> (c, c)
14:31:28 <lambdabot> (b -> c) -> (b, b) -> (c, c)
14:31:34 <Denommus> yay, type checks
14:32:12 <kanye-extension_> what would be a good ipc mechanism for wrapping a haskell lib (or executable) in _ruby_?
14:34:02 <test___> @pl \p q -> abs (fst p - fst q) + abs (snd p - snd q)
14:34:02 <lambdabot> ap (ap . (((+) . abs) .) . (. fst) . (-) . fst) ((abs .) . (. snd) . (-) . snd)
14:34:04 <Denommus> kanye-extension_: IPC?
14:35:04 <Denommus> kanye-extension_: why not FFI?
14:36:22 <sinelaw> Peaker, yo?
14:36:53 <Peaker> sinelaw: yo
14:37:03 <jle`> test___: you can always query /lambdabot, too :)
14:37:06 <jle`> er, /query lambdabot
14:37:21 <mauris> i don't understand the general workflow i should be using with cabal
14:38:01 <mauris> i cloned a piece of haskell software from github (elm) and want to poke at some definitions (in the parser) and load them into ghci without caring too much about anything else
14:38:26 <mauris> i did "cabal build" which seemed to compile the whole project as object files into /dist but i get missing module errors no matter how i try to load the .hs or .o files with ghci
14:38:50 <Peaker> mauris: "cabal repl" maybe?
14:39:05 <mauris> wow!
14:39:07 <test___> How would you write this function {distance p q = abs (fst p - fst q) + abs (snd p - snd q)} using as few tokens as possible? Surely there must be something nice but I can't figure it out.
14:39:09 <mauris> thank you :)
14:39:28 <jle`> test___: is this for golf?
14:39:35 <jle`> or do you want to find it in the most readable way possible?
14:39:50 <huonw> test___: distance (a,b) (x,y) = abs (a-x) + abs (b-y) maybe?
14:40:15 <jle`> distance (px,py) (qx,qy) = abs (px - qx) + abs (py - qy) might be the most readable way probably
14:40:23 <jle`> you could probably golf it down if you really wanted
14:40:38 <test___> It doesn't have to be readable, just token-minized for practice. Can you use liftM2 or ap somehow?
14:41:00 <Peaker> test___: I'd use a Vector2 (with a Num instance) instead of a tuple. Then I can just use:  distance p q = abs (p - q)
14:41:18 <Peaker> @pl distance (a,b) (x,y) = abs (a-x) + abs (b-y)
14:41:19 <lambdabot> distance = uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. ((abs .) . (-))) . flip . (((.) . (+) . abs) .) . (-))
14:41:21 <Peaker> heh
14:41:31 <sinelaw> very, very nice.
14:41:32 <mauris> that looks ideal
14:41:37 <mauris> does @pl know about *** and &&&?
14:41:42 <sinelaw> nope
14:42:16 <Peaker> mauris: I don't think so
14:43:37 <mmachenry> Is there a way to turn off the warnings for unused binds only in the context of a data type field but not in general? I'm running into a problem where I want to name my fields because I use some of them by name but not all. What should I do?
14:44:37 <ij> @pl (\(a, b) -> (f a, g b))
14:44:37 <lambdabot> f *** g
14:44:40 <ij> mauris, ^
14:44:59 <jle`> mmachenry: usually i just have them all start with underscores
14:45:20 <dredozubov> do cabal have something like "development dependencies" to enrich your sandboxed environment with tools like ghc-mod and Hlint?
14:45:39 <mmachenry> jle`: Woa, names that start with underscore are like a single underscore?
14:45:59 <dredozubov> sure, i can use it globally, but it's interesting
14:46:02 <jle`> mmachenry: no, they are flagged to be ignored when warning about unused stuff
14:46:17 <mmachenry> jle`: Ah I see.
14:46:19 <jle`> the warning stuff treats them as if they were throwaways
14:46:20 <mmachenry> Well that's cool, thanks.
14:46:40 <jle`> i'm not sure if this is good style
14:46:43 <jle`> :)
14:46:45 <adamse> is it possible to upgrade one package in a sandbox?
14:47:42 <cerberusiscute> Hi everyone. Can someone help my with a confusing problem that I am having?
14:47:46 <mmmm> adamse: What do you mean?
14:48:06 <dmj`> cerberusiscute: yes
14:48:22 <mmmm> You can do "cabal install <package>" of course
14:48:23 <cerberusiscute> dmj`: thank you
14:48:32 <adamse> mmmm: I want to upgrade 1 package in my sandbox
14:48:38 <cerberusiscute> i have a paste up on pastebin. here is the link http://pastebin.com/s2izn0bi
14:49:00 <mmmm> have you tried cabal install <package>?
14:49:02 <dmj`> cerberusiscute: what is it you are trying to accomplish
14:49:41 <cerberusiscute> I am trying to generate a list of the fibonacci numbers starting at s and incrementing with i += 1
14:49:54 <cerberusiscute> I am used to imperative programming and am learning haskell as a challenge.
14:50:08 <dredozubov> cerberusiscute: 'reverse(' is clearly wrong
14:50:10 <cerberusiscute> and also because i have the book Learn You a Haskell for Great Good
14:50:22 <cerberusiscute> dredozubov: ?
14:50:23 <dredozubov> function application is written like 'f x' in haskell
14:50:32 <dredozubov> you don't do stuff like f(x)
14:50:34 <dmj`> cerberusiscute: you can do it lazily
14:50:35 <dmj`> fib@(1:tfib) = 1 : 1 : [ a+b | (a,b) <- zip fib tfib ]
14:50:42 <adamse> mmmm: well, no I didn't, I unregistered the package instead and installed the newer version, let's see if stuff breaks...
14:50:48 <dmj`> define the sequence in terms of itself
14:50:59 <dmj`> @def fib@(1:tfib) = 1 : 1 : [ a+b | (a,b) <- zip fib tfib ]
14:51:00 <lambdabot>  Defined.
14:51:04 <dmj`> > take 10 fib
14:51:06 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
14:51:41 <dredozubov> i really like canonical one: fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
14:51:41 <cerberusiscute> okay. so how would i call the "reverse" function with the list i am trying to build with the lambdas
14:52:45 <dmj`> cerberusiscute: why would you need to reverse a list when generating a fibonacci sequence
14:53:01 <cerberusiscute> isn't it creating them in reverse order?
14:53:49 <dmj`> each consecutive element in the sequence is the addition of the previous two elements
14:54:35 <dredozubov> cerberusiscute: head of the list will be first element of fibonacci sequence
14:54:46 <dredozubov> you can build it from [1,1,..]
14:54:57 <dredozubov> i see no need for reverse
14:55:31 <zq> recommendations for a graph plotting library?
14:55:37 <cerberusiscute> okay dredozubov
14:55:39 <cerberusiscute> thank you!
14:58:02 <dredozubov> cerberusiscute: something naive will look like this: http://lpaste.net/115047
14:58:04 <Cale> cerberusiscute: One way to think about this that might help is to consider how to write a function to obtain the generalised Fibonacci sequence given its first two elements
14:59:10 <cerberusiscute> Cale: That's a very good idea!
14:59:21 <Cale> So, you'd want the first two elements of the resulting list to be the ones given, and then the tail following that will itself be a generalised Fibonacci sequence, so you'll be able to recurse
14:59:49 <cerberusiscute> Cale: (rhetorical) question is: how do i go about do that
14:59:53 <cerberusiscute> lol
15:00:44 <zguy> So, I saw Learn you haskell mentioned on here recently
15:00:46 <Cale> fib a b = a : b : ... something involving fib here ...
15:00:57 <zguy> Someone recommended it to me here yesterday, and it's great.
15:00:59 <zguy> And free.
15:01:16 <systemfault> Is there such a thing as a.... "Category theory for the noob"? (book or tutorial)
15:01:19 <Cale> zguy: Yeah, it's what typically gets recommended :)
15:01:35 <Cale> systemfault: I tend to recommend Steve Awodey's Category Theory
15:01:39 <zguy> I'm doing the same thing as Cale :)
15:01:43 <cerberusiscute> Also, does anyone know of a really great tutorial for type signatures? I really don't understand the more complex ones and I would like to (theoretically (sp?)) have one for every function i write.
15:01:49 <zguy> I mean cerberusiscute
15:02:35 <Yxven> cerberusiscute you can use :t in ghci to figure out the ones you don't know
15:02:41 <systemfault> Cale: Wow, the guy has videos on youtube
15:02:56 <t4nk531> can i write (F(n-1)+F(n-2))*F(n-3)/F(n-4):fib (n-1) F to append the value of the expression to a list F initialised as [1,1,1,1]
15:03:15 <Cale> systemfault: Yeah, he gave some really good lectures at OPLSS
15:03:16 <systemfault> Cale: That's the book? http://www.amazon.com/Category-Theory-Oxford-Logic-Guides/dp/0199237182
15:03:32 <Cale> yeah
15:03:36 <systemfault> Cale: Thank you :)
15:04:11 <Yxven> cerberuscute: I don't know of a tutorial though. I learned them by trying to write haskell code, attempting a type signature, and then having the compiler tell me I'm wrong and what it should be
15:04:54 <Cale> Well, any Haskell tutorial wouldn't be complete without a discussion of types as it went
15:05:17 <hiptobecubic> Cale, no "Conceptual Mathematics" ?
15:06:25 <cerberusiscute> Yxven: Thank you, in all seriousness. I am trying that process as well, but so far it isn't going quite as planned
15:06:28 <cerberusiscute> haha
15:06:32 <Cale> hiptobecubic: I'm not sure how I feel about that one :)
15:07:17 <cerberusiscute> Anyway, I am going to head off into the land of confusion and ghci errors to try and write this blasted function
15:07:35 <Cale> cerberusiscute: Feel free to ask any questions you might have
15:08:02 <cerberusiscute> thank you! I will be off the irc in a few because i have some things i need to do around the house.
15:08:14 <cerberusiscute> that will also give me time to think about the task ahead of me.
15:08:20 <Cale> cerberusiscute: and/or paste what you have on hpaste.org along with the errors you're getting if you're stuck
15:08:25 <Cale> cool
15:08:25 <cerberusiscute> Cale: Thank you for your help!
15:08:39 <Cale> No problem!
15:08:45 <hiptobecubic> hpaste.org is lpaste.net now (redirects)
15:09:05 <Cale> yes
15:09:11 <Cale> Though I think the redirect will stay?
15:09:23 <Cale> I dunno :)
15:09:26 <hiptobecubic> No idea who runs either one :)
15:10:21 <hiptobecubic> Cale, you're an experienced guy. Do you have any idea if this is me screwing up resource handling somehow? http://lpaste.net/114895#a114900 It *looks* like it but I can't see why.
15:10:31 <hiptobecubic> I suggest scrolling to the bottom
15:11:45 <Cale> uh, I don't see anything immediately, and dinner is ready
15:11:53 <hiptobecubic> fair enough. Bon ap:)
15:13:37 <Peaker> hiptobecubic: it's probably lazy I/O reading the request failing in the middle of the putStrLn and closing the connection underneath putStrLn's feet?
15:14:00 <Peaker> (just a guess)
15:14:12 <dmj`> systemfault: for me at least, awodey was a little steep, I'd start with the easier, "Conceptual mathematics: a first introduction to categories"
15:14:22 <hiptobecubic> Peaker, i thought about that, but then why does goodURL work?
15:14:24 <hiptobecubic> luck?
15:15:06 <Peaker> hiptobecubic: I think if putStrLn evaluates "responseBody resp" fully -- and "responseBody resp" evaluation might, as a side-effect, close the connection in case of error, which good URL's do not cause, that can explain it?
15:15:16 <mauris> whew. i made my first step in the open source contribution world, and it's in haskell
15:15:28 <Peaker> lazy I/O tends to close the input whenever it feels like, maybe here it is has a visible side-effect of also closing the output
15:16:15 <systemfault> dmj`: Thanks :)
15:17:23 <hiptobecubic> Peaker, trying to force now
15:18:15 <dmj`> mauris: nice
15:18:32 <mauris> yeah, here's to a bunch more!
15:19:12 <hiptobecubic> stuffing `return $ trace (B.unpack $ responseBody resp) ()` after the `resp <- ...` didn't help it seems
15:19:29 <Peaker> hiptobecubic: did it manage to print something?
15:19:32 <hiptobecubic> hmm.. but should it have?
15:19:38 <hiptobecubic> Nada
15:20:57 <hiptobecubic> guard forced it, but still no printing on the badUrl
15:23:08 <hiptobecubic> http://lpaste.net/114895
15:23:38 <Cale> okay, I'm back
15:26:30 <dredozubov> % cabal install cabal-install
15:26:30 <dredozubov> …
15:26:31 <dredozubov> <command line>: cannot satisfy -package-id HTTP-4000.2.10-da371776b88c2889959897a2dc40abe7
15:26:36 <dredozubov> wow, it's pretty broken
15:28:16 <Cale> ghc-pkg list HTTP
15:28:33 <hiptobecubic> Cale, you eat quickly
15:29:09 <MP2E> of course, cale memoizes his meals for fastest execution time
15:29:50 <dredozubov> /Library/Frameworks/GHC.framework/Versions/7.8.3-x86_64/usr/lib/ghc-7.8.3/package.conf.d
15:29:50 <dredozubov>    HTTP-4000.2.10
15:29:51 <dredozubov> /Users/dr/.ghc/x86_64-darwin-7.8.3/package.conf.d
15:30:18 <dredozubov> i guess installing haskell-platform wasn't the wisest choice
15:38:31 <dmj`> dredozubov: on osx?
15:38:38 <dredozubov> yep
15:39:02 <dredozubov> cabal install HTTP --allow-newer <-- worked like a charm
15:39:27 <dredozubov> i think i'll see something similar really soon
15:39:46 <dredozubov> sandbox all the things :<
15:40:47 <dmj`> dredozubov: yea I'd just do it all manually. Install the cabal prebuilt binary to ~/.cabal/bin, and ghc bin-dist to /usr/local/bin
15:40:58 <dmj`> then just use sandboxes
15:42:11 <dredozubov> maybe i'll do that tomorrow, too sleepy to do configuration right now
15:44:06 <dmj`> dredozubov: once nix on osx gets up to spec I'm switching
15:44:39 <dredozubov> dmj`: i've heard it's pretty rough right now :(
15:45:02 <dredozubov> i mean nix on os x
15:45:16 <dmj`> yea, heard hydra is being bad, nix on osx isn't pure yet apparently
15:46:47 <dmj`> Installing nix and ghc worked, but any haskell package failed after that. Had to manually put haddock in the store to install a few packages, but still compat issues... which is the point of nix I thought
15:51:08 <alrunner4> broken for a while now, sadly: https://github.com/NixOS/nixpkgs/issues/2689
15:53:35 <Fuuzetsu> it will remain broken until either something changes upstream and problem goes away or we monkeypatch the release or I get to snoop around on Hydra
15:53:42 * Fuuzetsu hopes for #1
15:56:22 <shachaf> dmwit: What, Data.Base has asProxyTypeOf with uppercase Proxy?
15:57:12 <shachaf> I sent an email to libraries@ back when Proxy was being added suggesting that it can be lowercased in almost every case, and as I remember people agreed.
15:59:01 <shachaf> dmwit: Well, I'm glad you caught it. :-)
15:59:20 <shachaf> Data.Proxy in tagged, which this is ostensibly hoping to be compatible with, uses a polymorphic proxy.
16:00:06 <shachaf> Ah, you mentioned that, too.
16:19:42 <dmwit> shachaf: Yeah, I don't anticipate a lot of dissension.
16:19:50 <dmwit> Probably just an oversight.
16:21:28 <fragamus> what is the haskell game room called
16:21:40 <dmj`> #haskell-game
16:21:49 <fragamus> thankyou
16:39:17 * hackagebot Wordlint 0.1.0.1 - Plaintext prose redundancy linter.  http://hackage.haskell.org/package/Wordlint-0.1.0.1 (bgbgbg)
16:46:52 <lf94> Is there a minimalistic haskell compiler out there?...
16:47:07 <lf94> Obviously not supporting all of haskell, but a subset
16:47:19 <joelteon> does JHC count?
16:47:39 <lf94> Can I compile it with C89
16:48:23 <exio4> JHC compiles to ANSI C, actually
16:48:35 <lf94> hm ok
16:48:58 <vanila> I don't thnk there is a minimal one
16:49:08 <vanila> there are only a couple haskell compilers and they are all large
16:49:32 <vanila> It could be created and it would be very nice to have it - it's difficult though
16:49:52 <lf94> i guess you cant really have a subset eh
16:52:42 <liyang> I think the problem is that hardly anyone really writes anything using just a subset of what GHC supports.
17:02:22 <marchelzo_> If I'm using 'memoize' from Data.Function.Memoize, and my program is "print (fib 4) >> print (fib 8)", do the memoized values accumulated in computing fib 4 stay around and help out with the computation of fib 8, or are they reset for each "top level" call to the function? It appears that in ghci at least, they do not persist.
17:06:28 <ReinH> marchelzo_: how are you using memoize?
17:06:51 <marchelzo_> ReinH: fib = memoize fib' where ...
17:07:35 <jfischoff> are you recursing on fib or fib’?
17:07:42 <marchelzo_> fib of course
17:07:47 * jfischoff nods
17:18:58 <ReinH> marchelzo_: both of these memoize for me: http://lpaste.net/963044475079229440
17:19:24 <WilhelmRyan> jesus tap-dancing christ!
17:19:43 <WilhelmRyan> i've only been on a few IRC channels before, they had less than 10 people online haha
17:20:06 <kadoban> That means #haskell is at least 150x cooler
17:20:18 <vanila> haskell is too mainstream :p
17:20:19 <WilhelmRyan> yeah, evidently it is
17:20:34 <WilhelmRyan> haha i didn't even know haskell was so popular, i'm just checking it out for the first time
17:20:52 <WilhelmRyan> i said on reddit i was interested in pure mathematics, and someone recommended that i learn it
17:21:17 <exio4> it isn't beautiful as pure mathematics though
17:21:25 <MP2E> Not quite :) But it is pretty nice still
17:21:30 <kadoban> Heh. Haskell isn't all that close to pure mathematics. It's closer than most languages I guess.
17:21:43 <Buttons840> what datastructure would you guys recommend for keeping a board game state -- like a go board?  a vector, array, something from repa?
17:21:46 <WilhelmRyan> yeah i think just as a skill to have, as it sort of sometimes applies
17:22:05 <vanila> Buttons840, vector
17:22:12 <vanila> indexed by pairs of ints
17:22:55 <Buttons840> vanila: interesting, I guess I had pictured vector being only indexed by single ints like in most languages -- thanks for the tip
17:23:10 <WilhelmRyan> idk if i'm gonna be outlawed, but i only know basic java and a tiny bit of python
17:23:18 <ReinH> Buttons840: IntMap, indexed by a pair of ints
17:23:27 <ReinH> vectors aren't great for sparse things, and go boards are often sparse
17:23:34 <WilhelmRyan> is this going to be completely different? i get the impression that it's pretty low-level but maybe i'm wrong
17:23:40 <ReinH> er, Map indexed by a pair of ints
17:23:40 <fragamus> can anyone give me an idea of how yesod is doing... is there an actual community or is it isolated
17:23:48 <vanila> its very different
17:23:51 <kadoban> ReinH: They're not really that sparse. Like 300ish empty spots isn't that many.
17:23:58 <exio4> it is easy, you just have to forget what you already know and start from scratch WilhelmRyan :P
17:24:07 <ReinH> > 19 ^ 2
17:24:09 <lambdabot>  361
17:24:13 <kadoban> ReinH: It's not like you have 1000x1000 go boards.
17:24:36 <ReinH> kadoban: true, but Vector doesn't offer any advantages to a Map anyway
17:24:51 <kadoban> WilhelmRyan: It's actually quite high level
17:25:17 <Buttons840> i will likely be making lots of copies of my "board" when I do some min-max ai
17:25:26 <Buttons840> does that change anything?
17:25:27 <kadoban> WilhelmRyan: It's quite different than imperitive languages (like python and java) though, it should be a good experience learning it.
17:25:45 <ReinH> A Map should perform better as a persistent data structure, but I'm not sure.
17:25:46 <vanila> Buttons840, to get a lot of sharing the tree might be lists of pieces+location rather than entire boards?
17:25:47 <dfeuer> 19^19^19
17:25:48 <ReinH> Neither are a bad choice.
17:25:53 <ReinH> Vector or Map, that is
17:25:55 <dfeuer> > 19^19^19
17:26:00 <lambdabot>  mueval: ExitFailure 1
17:26:00 <ReinH> Array isn't a bad choice either, for that matter
17:26:15 <dfeuer> (19^19)^19
17:26:20 <dfeuer> > (19^19)^19
17:26:21 <lambdabot>  4266285783710881246989467450954328108063945836634741974573848411194090158948...
17:26:25 <WilhelmRyan> kadoban, okay, i don't completely understand what a functional language is, i guess because both java and python use functions? is there an easy way to explain the difference?
17:26:29 <kadoban> Buttons840: I'm not sure I'd sweat it much, none of them seem like a bad choice really. Maybe keep it abstract so you can switch if needed.
17:26:41 <ReinH> vanila: that's why I'm suggesting a Data.Map :)
17:27:30 <dfeuer> Buttons840, Data.Map makes sense for lots of sharing, yes.
17:27:32 <vanila> WilhelmRyan, its places more emphasis on functions than those
17:27:37 <kadoban> WilhelmRyan: functional languages are a subclass of "declarative" languages. You do more of just asserting the way things are, and the compiler figures stuff out for you. Imperitive languages are more about telling the computer "do this, then do this, then do this".
17:27:45 <Buttons840> ok, thanks -- I was hoping array and vector look very similar, only with different APIs, and Maps are something I hadn't considered -- i guess making copies of a map when the board is sparse will be cheaper
17:28:19 <ReinH> Buttons840: you should also get a lot of sharing with a Map
17:28:23 <dfeuer> Buttons840, Data.Map also lets you change a square without having to copy the whole thing.
17:28:34 <dfeuer> You only copy O(log n) stuff, instead of O(n) stuff.
17:28:43 <dfeuer> That's a pretty big difference.
17:28:59 <ReinH> Also in a game tree, a persistent data structure is really, really nice
17:29:10 <ReinH> since you're really only storing the updates
17:29:35 <WilhelmRyan> kadoban so it's not necessarily in sequential order, it's a big group of things happening in whichever order they need to? that sounds like a really horrible way to describe it haha, i'm sure i'll understand once i begin
17:29:52 <kadoban> WilhelmRyan: This is a bit what people mean when they say haskell is closer to mathematics...even though it's not necessarily all that true. In math, you say x = 5, and it's always 5. In imperitive programming languages, you say x = 5, then later you change x to 10 then later to 20, etc. In functional languages, x is always 5, you can't change it.
17:30:04 <kadoban> WilhelmRyan: A bit...kinda. That sounds a bit more chaotic than it is.
17:31:42 <WilhelmRyan> kadoban so variables don't exist in functional languages? or at least, variables that are variable haha
17:31:58 <exio4> variables in mathematics
17:32:07 <WilhelmRyan> kadoban i feel like that's a drain on memory but i also don't understand it yet so i'm definitely wrong
17:32:13 <vanila> "variable" in most programming languages like C is more like a box which holds a value
17:32:16 <kadoban> WilhelmRyan: Well...they don't work the same way as in imperitive languages at least.
17:32:16 <vanila> and you can change that value etc.
17:32:30 <WilhelmRyan> but not in haskell?
17:32:35 <vanila> in haskell its more like in mathematics
17:32:36 <WilhelmRyan> you can't change it, that is
17:32:40 <vanila> where you say, let x = 3 and then x is 3
17:32:49 <kadoban> WilhelmRyan: To throw more confusing stuff at you, in Haskell you actually can write code in imperitive style too, but it's encapsulated in a nice, safe way.
17:33:31 <kadoban> WilhelmRyan: I wouldn't worry too much about this stuff to start out, if you just try to learn the language you'll get a feel for it. There's good learning materials out there, and it's pretty easy to get going.
17:33:56 <exio4> WilhelmRyan: don't try to make concepts from other languages work in Haskell, it is going to make Haskell look more "difficult" than it is
17:34:16 <WilhelmRyan> kadoban alright cool, yeah makes sense. i'm gonna check out Learn You a Haskell, how advanced does that get? is it really introductory stuff?
17:34:40 <Welkin> WilhelmRyan: yes, LYAH is just a basic introduction
17:35:00 <josephle> it goes up to commonly used typeclasses, iirc
17:35:04 <Welkin> WilhelmRyan: read Real World Haskell after you have finished Learn You A Haskell
17:35:16 <Welkin> it gives more in-depth explanations and it more thorough
17:35:21 <Welkin> it also has many examples
17:36:26 <WilhelmRyan> awesome, i'll definitely check it out after, thanks
17:36:42 <ReinH> WilhelmRyan: if you're willing to invest a bit, Richard Bird's new Thinking Functionally with Haskell is an absolutely wonderful book
17:36:52 <ReinH> far, far better than LYAH or RWH imo
17:38:02 <WilhelmRyan> oh yeah? is it worth reading the other 2, and then getting it? or is it introductory as well
17:38:54 <ReinH> It starts pretty much from scratch
17:39:27 <ReinH> It also has lots of great exercises with answers
17:39:42 <ReinH> which is super important
17:42:47 <Buttons840> ReinH: what format do you recommend getting that book in? do you have a digital copy or the book? (this is by no means a solicitation for a free download link, the auther should be paid)
17:43:25 <ReinH> Buttons840: I have the kindle version, it's well formatted
17:43:52 <Buttons840> the hardcover version sounds nice... but $80
17:44:06 <ReinH> Yeah, that's the other reason I have the kindle version...
17:44:20 <ReinH> The main reason is that it was the only version available when I bought it.
17:46:51 <Buttons840> looks like there is a PDF version you can purchase from the books website at cambridge
17:46:55 <ReinH> nice
17:47:03 <Buttons840> $40 though
17:49:26 <ReinH> worth
17:51:29 <marchelzo_> ReinH: How much knowledge is assumed in it?
17:54:11 <lpaste> hcore pasted “getmiddle” at http://lpaste.net/115059
17:54:38 <lpaste> hcore revised “getmiddle”: “No title” at http://lpaste.net/115059
17:55:06 <hcore> so i can't figure out why that isn't working
17:55:19 <hcore> it's a syntax error but i'm writing it out according to some book examples
17:55:21 <hcore> so i don't get it
17:55:26 <indiagreen> you're using Tabs
17:55:33 <hcore> i tried 1 tab to where "where" is, 2 to
17:55:34 <hcore> wait
17:55:37 <hcore> i dont use tabs?
17:55:39 <hcore> i use spaces?
17:55:49 <indiagreen> don't use them
17:56:11 <indiagreen> your example compiles if I replace tabs with spaces in the last line
17:56:11 <indiagreen> the “len =” one
17:57:18 <indiagreen> and tabs are bad not because they're bad, but because your editor's and GHC's opinion on how much a tab's width is differ
17:57:27 <indiagreen> in particular, if you use spaces and indent “len” a space further than “n”, it wouldn't compile either
17:57:39 <hcore> so im guessing ghci doesnt define a tab as 4 spaces?
17:58:00 <hcore> thanks for the help though!
17:58:07 <indiagreen> no, I think it's 8 spaces
17:58:07 <indiagreen> but in any way, you're mixing tabs and spaces
17:58:19 <indiagreen> which you shouldn't do no matter whether you want to use tabs or not
17:58:26 <indiagreen> tabs are for indentation, spaces for alignment
17:58:53 <indiagreen> since “n =” is partly aligned by “where”, either move it on a separate line or don't use tabs here
17:59:53 <Buttons840> I'm reminded of a pun I ran accross for the first time this week: Python - programming the way Guido indended it. ;)   seems applicable
18:00:29 <hcore> that looks a bit nicer too
18:00:49 <hcore> and also some cursory googling says that tab is 1 space in ghc
18:00:51 <hcore> When a breakpoint is set on a particular line and column, GHCi picks the smallest subexpression that encloses that location on which to set the breakpoint. Note: GHC considers the TAB character to have a width of 1, wherever it occurs; in other words it counts characters, rather than columns. This matches what some editors do, and doesn't match others. The best advice is to avoid tab characters in your source code altogether (see
18:00:51 <hcore> -fwarn-tabs in Section 4.8, “Warnings and sanity-checking”).
18:01:03 <hcore> https://downloads.haskell.org/~ghc/7.6.2/docs/html/users_guide/ghci-debugger.html
18:02:54 <indiagreen> hcore: https://www.haskell.org/onlinereport/syntax-iso.html
18:03:00 <indiagreen> “Tab stops are 8 characters apart.”
18:03:32 <indiagreen> it's interesting that the user guide says otherwise in some not-exactly-related place
18:06:13 <hcore> hrmm very weird
18:07:01 <indiagreen> hcore: nope, 8 spaces, I checked. Probably the guide means something else
18:07:43 <gamegoblin> Does Data.Vector have a sort function?
18:07:59 <indiagreen> gamegoblin: the last time I checked it didn't
18:08:06 <gamegoblin> shame...
18:08:16 <indiagreen> there's a package which is used by everyone who wants a sort for vectors, I think
18:08:29 <indiagreen> @hackage vector-algorithms
18:08:30 <lambdabot> http://hackage.haskell.org/package/vector-algorithms
18:09:16 <Gurkenglas> @tell hexagoxel It seemed like the sort of thing that, if driven far enough, might jumpstart a positive runaway feedback loop of automation of everything.
18:09:16 <lambdabot> Consider it noted.
18:10:07 <gamegoblin> vector-algorithms seems like it only works on mutable vectors...
18:10:40 <indiagreen> use modify
18:10:57 <indiagreen> http://hackage.haskell.org/package/vector/docs/Data-Vector.html#v:modify
18:35:39 <DMX> to supp??
19:04:47 <Rhonin> hey
19:04:59 <vanila> bhi
19:09:09 <Rhonin> im pretty new to haskell, and I got an assignment where I have a tree and a function, and I have a problem to apply the function on all the nodes on the tree, here is the paste http://lpaste.net/edit/115063 i hope someone can help
19:10:25 <vanila> tcm f1 f2 (Node f l children) = map (tcm f1 f2) children
19:10:28 <vanila> should maybe change to
19:10:32 <vanila> tcm f1 f2 (Node f l children) = Node f l (map (tcm f1 f2) children)
19:14:56 <Rhonin> that makes sense! cant believe I didnt see that, thanks (:
19:46:13 <hagiri> oi
19:46:17 <hagiri> algum vivo?
19:46:37 <avocado> nej
19:46:57 <hagiri> o que devo fazer para comear a codar em haskell?
19:46:58 <hagiri> ;)
19:49:25 * hackagebot hsbencher 1.20.0.2 - Launch and gather data from Haskell and non-Haskell benchmarks.  http://hackage.haskell.org/package/hsbencher-1.20.0.2 (RyanNewton)
19:53:42 <torpet> i have tried my code on several test cases (trees), and for one test case it always fails.
19:53:50 <torpet> here is the code, is looks for a maximum in a rose tree: http://lpaste.net/2196734905566625792
20:01:13 <haasn> torpet: First of all you have a lot of code and work duplication for an algorithm which is conceptually much simpler
20:01:49 <torpet> im a newb, but thought this was already pretty short. what do you have in mind
20:03:12 <haasn> torpet: Instead of considering ‘l’ as a special element, why not compare it together with the rest? ie. take the smallest element out of  f : map (tmax l) t
20:03:33 <haasn> s/smallest/largest/
20:03:57 <haasn> That way you can reduce your definition for “tmax” to a single line (not including the type signature)
20:04:00 <haasn> And also get rid of pam
20:04:06 <torpet> oh sorry btw, this returns the maximum function, which each node owns
20:04:11 <torpet> not the maximum value.
20:04:27 <torpet> and the inherent function is applied to a general value l
20:04:30 <haasn> functions are also values
20:04:41 <haasn> But let me illustrate what I mean
20:05:32 <haasn> tmax l (Node x _ xs) = fst . maximumBy (comparing snd) . map (\x -> (x, x l)) $ x : map (tmax l) xs
20:05:59 <haasn> (Or maximumBy (comparing ($l)) if you don't care that much about the constant factor)
20:07:04 <haasn> No special case needed for [], incidentally
20:07:27 <torpet> oh nice
20:09:13 <torpet> very nifty snippet :)
20:09:13 <Denommus> I wonder if I could use QML in hsQML ONLY as a GUI DSL, and handle all the states with FRP
20:10:43 <torpet> haasn: thanks a lot! :)
20:11:31 <Zer000> please help me fix this type signature: http://lpaste.net/115067
20:12:24 <Zer000> Setting Num a to be Num [a] yields "Non type-variable argument in the constraint: Num [a]" from ghci
20:13:05 <lucs> Zer000: Try  ... (-1)
20:14:07 <lucs> Zer000: You know, what I said probably makes no sense :/
20:15:16 <Zer000> lucs, same err
20:15:47 <lucs> Maybe  ... [-1] ?
20:16:12 <lucs> (I shouldn't just guess, but I'm too much of a beginner :? )
20:16:17 <lucs> :/ too
20:16:53 <Zer000> lucs yes that's it! thank you!
20:19:10 <lucs> Zer000: Yeah, it makes sense:  x is a list of numbers, so you can only  ++  another list of numbers to it.
20:19:26 <jle`> Zer000: yeah, it's actually one of the more annoying things about haskell syntax
20:19:32 <jle`> the - in -1 is considered an operator
20:19:51 <jle`> so it's parsed as if it was something like x ++ * 1
20:20:11 <ReinH> Um.
20:20:19 <jle`> oh
20:20:19 <ReinH> The - in -1 is syntax for negative 1
20:20:26 <ReinH> that's why we have
20:20:28 <ReinH> :t subtract
20:20:28 <jle`> dangit
20:20:29 <lambdabot> Num a => a -> a -> a
20:20:36 <jle`> nevermind
20:20:39 <jle`> the problem isn't even that
20:20:46 <jle`> the problem is that they are ++ an element, not a list
20:20:46 <ReinH> x is a list
20:20:48 <jle`> v.v
20:20:54 <jle`> what am i doing with my life today
20:20:55 <ReinH> of some type Num a => a
20:21:09 <michaelt> jle`: this was independent of the - rule lucs just forgot to make the singleton [-1]
20:21:11 <ReinH> you are trying to add Num a => [a] to -1
20:21:16 <jle`> yeah, i see it now v.v
20:21:17 <ReinH> First, -1 is not a list
20:21:27 <ReinH> so x ++ -1 is always a type error
20:21:41 <ReinH> Zer000: what are you trying to do?
20:23:47 <ReinH> :t (-1)
20:23:48 <lambdabot> Num a => a
20:24:20 <ReinH> So through the magic of defaulting, x ++ [-1] might at least typecheck
20:24:45 <ReinH> but really I would like to know what the intent is here
20:25:54 <Zer000> No that's exactly what I"m trying to do, lucs got it on the money
20:26:29 <ReinH> alright then
20:26:31 <ReinH> good work everyone
21:01:27 <gcganley> has the #haskell been really quite or is my irc client messing up...
21:02:11 <FreeFull> gcganley: It has been quiet
21:03:25 <jle`> you can always check the logs too if you are unsure :)
21:04:31 <gcganley> jle`: i actually set up a bash script to search for refrences of my names in #haskell within the past week, year, so on
21:21:21 <lpaste> dmwit pasted “what does AutoDeriveTypeable do?” at http://lpaste.net/115079
21:21:55 <dmwit> Is this a bug?
21:22:06 <dmwit> My reading of the docs say that Foo should have a Typeable instance there.
21:22:16 <dmwit> Though the docs are admittedly quite short...
21:25:15 <OlegYch> https://ghc.haskell.org/trac/ghc/ticket/9575 ?
21:26:58 <dmwit> Looks like it.
21:27:01 <dmwit> Thanks.
21:30:21 <Rhonin> could someone tell me why I get an error here ):? http://lpaste.net/115081
21:33:15 <dmwit> Rhonin: Well, you say you're returning a list of elements.
21:33:29 <dmwit> But right away I see "[x] : blah" which has type list of list of elements.
21:33:40 <dmwit> There might be other issues, too.
21:34:03 <dmwit> Perhaps you meant "x : blah"? But then the "map (fpairs l) ..." looks like it would return a list of lists, as well.
21:35:19 <dmwit> You might like concatMap.
21:35:21 <dmwit> :t concatMap
21:35:21 <lambdabot> (a -> [b]) -> [a] -> [b]
21:35:41 <Rhonin> hmm let me see what it does
21:35:45 <dmwit> :t \x f l -> [x] : map f l
21:35:46 <lambdabot> t -> (a -> [t]) -> [a] -> [[t]]
21:35:52 <dmwit> :t \x f l -> x : concatMap f l
21:35:53 <lambdabot> a -> (a1 -> [a]) -> [a1] -> [a]
21:35:57 <FreeFull> concatMap is the bind of the list monad
21:36:05 <dmwit> ?src concatMap
21:36:05 <lambdabot> concatMap f = foldr ((++) . f) []
21:36:09 <dmwit> ugh
21:36:14 <dmwit> concatMap f xs = concat (map f xs)
21:36:34 <dmwit> :t concatMap
21:36:35 <lambdabot> (a -> [b]) -> [a] -> [b]
21:36:47 <FreeFull> :t (=<<)
21:36:48 <lambdabot> Monad m => (a -> m b) -> m a -> m b
21:36:57 <dmwit> "concatMap is the bind of the list monad" doesn't really tell you what concatMap does.
21:37:10 <FreeFull> Well, no, it doesn't
21:37:11 <Rhonin> sorry guys, I'm like a super beginner in haskell, getting kinda overwhelmed xD
21:37:16 <FreeFull> Sorry
21:37:48 <dmwit> Rhonin: Ignore the list monad comments. Take your time reading and ask lots of questions.
21:37:55 <Rhonin> kk :D
21:38:46 <Rhonin> well, what I want to do with fpairs is this:
21:40:17 <Rhonin> i give fpair an integer and a tree, and i want to return a list of tupels (a,b) where a the function in a tree node is and b is the function used on the integer
21:41:36 * dmwit nods agreeably
21:44:29 * hackagebot monad-logger 0.3.9 - A class of monads which can log messages.  http://hackage.haskell.org/package/monad-logger-0.3.9 (MichaelSnoyman)
21:44:59 <Rhonin> how can i make it that "map (fpairs l) children" returns a list, not a list of lists?
21:51:55 <dmwit> Rhonin: Consider taking a look at concatMap.
21:52:14 <shelf> morning. where's the entry point for GHCJS?
21:54:57 <Rhonin> dmwit: thanks a lot :D, got it to work
21:56:08 <shelf> oh, I think I've found the most recent instructions. never mind!
22:03:54 <Welkin> is there a way to put a where clause in scope of every pattern match in a function?
22:04:30 <Welkin> I don't want to repeat myself, but I need the same helper function for both patterns
22:05:05 <Welkin> I suppose a case statement may do it, but that is not ideal
22:06:18 <dmwit> If the patterns can be done with guards instead, that might be a way to go, too.
22:06:38 <dmwit> But that's pretty uncommon, and it's not really saying what you mean. I'd use a case statement.
22:07:11 <Welkin> okay
22:07:17 <Welkin> I used a case statement
22:07:17 <kadoban> I just give whatever a name instead usually. Not really ideal though.
22:08:47 <dmwit> kadoban: That only works if "whatever" need not refer to variables bound by previous patterns.
22:09:07 <dmwit> Or perhaps I misunderstood your proposed solution.
22:09:42 <kadoban> dmwit: Well, it depends what it is, usually you can factor it out into a top level function somehow, it depends how pretty it is though...
22:19:31 * hackagebot system-random-effect 0.4.1.3 - Random number generation for extensible effects.  http://hackage.haskell.org/package/system-random-effect-0.4.1.3 (ClarkGaebel)
22:21:12 <mietek> Anyone familiar with wai-middleware-static?
22:21:46 <mietek> I'm trying to declare data-files with Cabal for use at runtime.  This prints the right paths at runtime, but the server 404s: https://github.com/mietek/tryidris/commit/08922c008df42d44f5a0906d9ad9ec985d544c96
22:30:05 <mietek> Ah, never mind.  *.foo doesn't glob *.bar.foo
22:33:48 <orion> When is it better to use type classes as opposed to record types? What are the pros and cons of each?
22:37:43 <Geekingfrog> Is there a way to declare a function with type annotations in ghci? If yes, how?
22:38:07 <dibblego> let x :: Int -> Int; x = id
22:39:20 <Maxdamantus> orion: it should be fairly easy to use both when there's that question.
22:41:00 <Maxdamantus> orion: but you can't really directly translate classes/instances to data/records in Haskell.
22:41:25 <Maxdamantus> you'd need an extra type rank.
22:41:26 <Maxdamantus> (in some cases, at least)
22:42:54 <Geekingfrog> dibblego, thanks
22:43:15 <dibblego> np
22:44:32 * hackagebot bound 1.0.4 - Making de Bruijn Succ Less  http://hackage.haskell.org/package/bound-1.0.4 (EdwardKmett)
22:49:32 * hackagebot DRBG 0.5.3 - Deterministic random bit generator (aka RNG, PRNG) based  HMACs, Hashes, and Ciphers.  http://hackage.haskell.org/package/DRBG-0.5.3 (ThomasDuBuisson)
22:56:37 <Airwrecka> #ferguson Join #ferguson to discuss the nigger riots breaking out across the US>
22:57:30 <Hijiri> @where ops
22:57:30 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
22:57:59 --- mode: ChanServ set +o Saizan
22:58:06 --- mode: Saizan set +b *!*Airwrecka@gateway/web/cgi-irc/kiwiirc.com/x-wbdovqowfuniyrdl
22:58:06 --- kick: Airwrecka was kicked by Saizan (Airwrecka)
22:58:15 --- mode: Saizan set -o Saizan
23:00:06 <ddellacosta> thank you
23:00:51 <Geekingfrog> Is there a way to know from ghci if something is a type or type constructor? :t Maybe returns an error
23:01:23 <Geekingfrog> (even after import Data.Maybe)
23:01:26 <Saizan> Geekingfrog: :k Maybe
23:01:33 <Geekingfrog> nice
23:01:38 <Geekingfrog> what does :k does?
23:01:45 <Saizan> kind
23:01:55 <Geekingfrog> thanks
23:02:33 <chrisnc> has anyone here used either mstate or concurrent-state?
23:02:51 <chrisnc> thinking about using one of them for a new project, and they seem pretty similar
23:03:42 <Geekingfrog> and is there a way to do the same with data? I defined an enum and I'd like to see its definition again (in ghci)
23:03:54 <chrisnc> use :i
23:04:37 <Geekingfrog> all right. Just found :help I'll be less noisy
23:09:39 <xpika> A fold can involve two types. Is there any good names for these?
23:10:04 <chrisnc> for the types involved in a fold?
23:11:05 <xpika> One is type of the elements in the data structure being folded on. And the other is the both the result type and the second operand type.
23:11:19 <dibblego> Geekingfrog: see also :info
23:11:28 <xpika> chrisnc: yep
23:11:38 <chrisnc> I think of them as the "element" and "accumulator" type. dunno if that's standard or not
23:22:33 <osa1> I want a socket function that blocks until specified amounts of bytes are read. bytes should then returned and extra bytes should be buffered for future calls. any libraries for that?
23:25:33 <tempay> > prompt s = putStr s >> getLine
23:25:34 <lambdabot>  <hint>:1:10: parse error on input ‘=’
23:25:41 <tempay> > let prompt s = putStr s >> getLine
23:25:43 <lambdabot>  not an expression: ‘let prompt s = putStr s >> getLine’
23:26:31 <mauke> putStr s >> hFlush stdout >> getLine
23:27:02 <tempay> > @let prompt s = putStr s >> getLine
23:27:03 <lambdabot>  <hint>:1:1: parse error on input ‘@’
23:27:21 <tempay> apparently I can't lambdabot
23:27:23 <Hijiri_> @let prompt s = putStr s >> getLine
23:27:25 <lambdabot>  Defined.
23:27:34 <tempay> ah, thanks
23:27:44 <mauke> and why did you do that?
23:27:52 <tempay> one sec, question coming
23:28:38 <tempay> @let promptN n s = sequence . take n . iterate (>>= prompt) $ (return "hi")
23:28:39 <lambdabot>  Defined.
23:28:56 <tempay> > promptN 3 "hi"
23:28:57 <lambdabot>  <IO [[Char]]>
23:29:08 <tempay> do prompts not work?
23:29:13 <mauke> what
23:29:22 <tempay> can i do a getLine?
23:29:26 <mauke> define "do"
23:29:44 <tempay> will the program read what I type and operate on it
23:29:50 <mauke> what program?
23:30:30 <tempay> I tried to run a function with a getLine, on a normal terminal it would accept input
23:30:40 <mauke> ok?
23:30:42 <tempay> I'm wondering if that's supported on lambda bot
23:30:49 <mauke> lambdabot doesn't do IO
23:31:01 <tempay> okay, thanks
23:31:23 <tempay> well, in any case
23:32:13 <tempay> the function promptN (defined above) is intended to start with a given prompt, and then iterate using the previous response as the next prompt
23:32:41 <tempay> it seems to work, except that it sometimes repeats previous prompts
23:33:04 <tempay> it's hard to demonstrate without showing, but maybe someone notices something :)
23:33:10 <mauke> screenshot?
23:33:43 <tempay> sure
23:37:11 <shachaf> tempay: promptN 3 _ = do { do { return "hi" }; do { x <- return "hi"; prompt x }; do { x <- return "hi"; y <- prompt x; prompt y } }
23:37:53 <tempay> I'm not sure what to make of that, is it an expansion into do notation?
23:38:14 <mauke> ooh, right
23:38:21 <chrisnc> anyone have any advice on using mtl vs transformers when starting out?
23:38:26 <shachaf> I think "take" might not be what you want here.
23:38:44 <chrisnc> they seem to have a lot in common. not sure how to compare them
23:38:46 <shachaf> But I don't know what you want, so do you expect what I wrote for promptN 3?
23:38:50 <tempay> got it :)
23:38:54 <tempay> I just want the last one
23:38:58 <mauke> !!
23:39:25 <tempay> oh, not quite the last one
23:39:50 <mauke> iterate f x !! n
23:40:15 <tempay> right, except that when I evaluate the nth element in the iterate it calls getLine n times
23:40:53 <tempay> the IO isnt being evaluated before it's being passed to the next prompt
23:40:57 <mauke> eh?
23:41:04 <tempay> so I'm getting a whole stack of IO operations on each element
23:41:08 <mauke> ok, you probably mean executed, not evaluated
23:41:12 <tempay> yep
23:41:18 <tempay> sorry, it's week 1
23:41:25 <mauke> but why "except"?
23:41:30 <mauke> isn't that what you want?
23:41:41 <tempay> I want n prompts
23:41:49 <tempay> not n(n-1)/2 prompts
23:41:55 <tempay> one for each element
23:42:30 <mauke> are you talking about take or !! ?
23:42:42 <tempay> so the first element will be the result of prompting the user with string s, the second element the result of prompting with the first element, etc.
23:43:04 <tempay> neither !! or take will work I think
23:43:10 <tempay> I think iterate is wrong
23:43:25 <shachaf> It would have been helpful to say what the behavior you wanted was right at the beginning. :-)
23:43:41 <Gurkenglas> tempay> the function promptN (defined above) is intended to start with a given prompt, and then iterate using the previous response as the next prompt
23:43:42 <tempay> sorry, it's clear it my head :P
23:44:04 <Gurkenglas> :t iterateM
23:44:05 <lambdabot>     Not in scope: ‘iterateM’
23:44:05 <lambdabot>     Perhaps you meant one of these:
23:44:05 <lambdabot>       ‘iterate’ (imported from Data.List),
23:44:11 <mauke> what's wrong with iterate f x !! n ?
23:44:24 <shachaf> You want a list of the intermediate results?
23:44:44 <tempay> yes shachaf
23:45:01 <tempay> mauke, I want a list of each of the responses, so the result needs to be a list
23:45:10 <tempay> Gurkenglas, I'm looking at that now, thanks
23:45:46 <mauke> that seems like it can be fixed by changing f
23:46:51 <Gurkenglas> :t sequence $ take 5 $ iterate (>>= prompt) $ return "hi"
23:46:52 <lambdabot> IO [String]
23:47:14 <Gurkenglas> I don't see what's wrong with iterate
23:47:26 <mauke> :t \p -> do xs@(x : _) <- p; y <- prompt x; return (y : xs)
23:47:27 <lambdabot> IO [String] -> IO [String]
23:47:34 <tempay> it prompts n times for the nth element
23:47:42 <mauke> :t iterate (\p -> do xs@(x : _) <- p; y <- prompt x; return (y : xs)) (return ["hi"])
23:47:43 <lambdabot> [IO [String]]
23:47:50 <mauke> :t iterate (\p -> do xs@(x : _) <- p; y <- prompt x; return (y : xs)) (return ["hi"]) !! 3
23:47:51 <lambdabot> IO [String]
23:47:56 <tempay> try it, it's actually pretty interesting
23:48:10 <Gurkenglas> Oh, I see
23:49:29 <tempay> is it a problem with the laziness, is there an eager version of iterate that would be better?
23:49:40 <mauke> I don't see what this has to do with laziness
23:50:39 <tempay> yeah, you're right
23:50:41 <shachaf> I think foo n f z = iterate f z !! n should probably be in a standard library.
23:51:46 <tempay> yeah, that's repeatedly in clojure right?
23:52:17 <tempay> not quite, nevermind
23:52:18 <shachaf> I don't know how many times it's in Clojure, but hopefully not many more than one.
23:52:37 <tempay> ha
23:56:42 <chrisnc> the iterate version is wrong because it starts at the beginning each time
23:57:16 <Gurkenglas> I don't think you're telling them anything new
23:58:09 <chrisnc> try using iterate (>>= prompt) and give it 10
23:58:14 <chrisnc> you will get way more than 10 prompts :)
23:58:32 <tempay> that's the problem :) you'll get something like 45
23:58:39 <shachaf> What if I give it 15? Will I get more than 15 prompts?
23:59:07 <tempay> further experiments required
