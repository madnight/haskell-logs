00:00:03 <mrenaud__> Okay, now I have confirmation that sorting is slow as hell :YP
00:02:10 <mrenaud__> Does anyone have any advice on the fastest way to sort a collection of Ints?
00:02:28 <dmwit> mrenaud__: When you install with profiling, it installs two versions: one with profiling and one without.
00:02:37 <dmwit> So, no, the non-profiling versions' performance won't be affected.
00:02:51 <mrenaud__> dmwit: That makes sense, thanks.
00:02:55 <dmwit> Do you know anything about the distribution the Ints are drawn from?
00:03:02 <mrenaud__> Random.
00:03:10 <dmwit> That doesn't answer my question.
00:03:23 <mrenaud__> (minBound, maxBound)
00:03:26 <merijn> mrenaud__: What's wrong with just "sort"?
00:03:41 <mrenaud__> merijn: It's very slow
00:03:51 <merijn> How many ints are we talking?
00:03:58 <mrenaud__> 1000000
00:04:02 <merijn> wut
00:04:06 <merijn> How slow is that?
00:04:12 <merijn> Are you compiling with -O2?
00:04:18 <mrenaud__> Several seconds, and yes.
00:04:21 <merijn> Also, try putting them in a mutable vector and sorting that
00:04:24 <Welkin> well
00:04:32 <Welkin> Data.List.sort is mergesort
00:04:36 <Welkin> so it is n log n
00:04:41 <Welkin> you won't get better than that
00:04:49 <dmwit> You can get better than that.
00:04:50 <mrenaud__> Welkin: But it has a very high constant factor
00:04:54 <dmwit> Via radix sort or counting sort.
00:05:12 <mrenaud__> In terms of complexity, no, but there has to be ways to improve the constant factor.
00:05:17 <merijn> Welkin: Sure you can
00:05:22 <dmwit> Counting sort is not recommended for large uniform distributions, though.
00:05:34 <mrenaud__> I've played around with sorting it in the ST monad and that was even slower :/
00:05:36 <merijn> Welkin: In C++ I sort 10,000,000 in like 20ms
00:05:57 <mrenaud__> merijn: Yeah, C++'s sort is several orders of magnitude faster
00:06:15 <dmwit> mrenaud__: My suggestion is to toss everything in an IntSet (or IntMap if the counts matter) and read them out with toAscList.
00:06:24 <merijn> mrenaud__: Hence why I suggest using vector and a sort on that
00:06:34 <merijn> That s
00:06:37 <mrenaud__> Does IntSet preserve duplicates?
00:06:47 <merijn> That should be much faster, since it can sort in place
00:06:52 <dmwit> "or IntMap if the counts matter"
00:06:53 <merijn> list is really suboptimal for sorting
00:07:06 <mrenaud__> Ah, yeah read that after I hit enter :P
00:08:14 * hackagebot radian 0.0.2 - A floating-point wrapper for measurements that use radians.  http://hackage.haskell.org/package/radian-0.0.2 (TonyMorris)
00:08:14 * hackagebot egison 3.3.15 - Programming language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.3.15 (SatoshiEgi)
00:10:19 <mrenaud__> I have the input as Seq Int, would the best way to build it be a fold with insert?
00:12:50 <dmwit> I guess?
00:18:48 <mrenaud__> Hmm, IntSet is marginally faster
00:43:11 * hackagebot rest-core 0.33.1.1 - Rest API library.  http://hackage.haskell.org/package/rest-core-0.33.1.1 (ErikHesselink)
01:11:48 <lc80> hello. question about implementing Ord in my own type with multiple fields. how to do that to have ordering by multiple fields in specific order?
01:13:42 <opqdonut> lc80: a quick and dirty solution is to use tuple comparisons
01:14:14 <opqdonut> something like: instance Ord Mydata where compare (Mydata a b c d) (Mydata a' b' c' d') = compare (d,a,b,c) (d',a',b',c')
01:14:52 <lc80> ok, worked :)
01:14:54 <int-e> lc80: another possibility uses the Monoid instance of Ordering:  F a b c `compare` F x y z = msum [b `compare` y, c `compare` z, a `compare` x] ... but actually I'd prefer the tuple thing.
01:15:13 <lc80> tuple seems to be pretty clean and elegant
01:15:16 <int-e> err, I keep mixing these up: I mean mconcat, not msum.
01:16:02 <int-e> > map mconcat [[EQ,EQ],[LT,GT],[EQ,GT]]
01:16:04 <lambdabot>  [EQ,LT,GT]
01:17:07 <lc80> in my case it's now
01:17:09 <lc80> instance Ord Jedi where
01:17:13 <lc80> compare a b = compare (rank a, name a) (rank b, name b)
01:20:55 <cuci> hi guys! I'm trying to install auto-update but at the end I get: ghc-pkg: 1: Parse of field 'name' failed. Google told me it might be a failure to parse '-' from name. Any ideas how to fix this?
01:26:06 <bergmark> cuci: lots of packages have dashes in their name, i have never heard of that issue :o
01:26:24 <cuci> bergmark: https://github.com/snapframework/snap-core/issues/16
01:26:29 <cuci> got it from there
01:26:54 <cuci> then any ideas why ghc-pkg fails to parse the name?
01:26:55 <bergmark> cuci: that's underscores though :-)
01:27:26 <cuci> ah
01:27:44 <cuci> ok. Any ideas why ghc-pkg fails to register auto-update?
01:28:13 * hackagebot traverse-with-class 0.2.0.2 - Generic applicative traversals  http://hackage.haskell.org/package/traverse-with-class-0.2.0.2 (RomanCheplyaka)
01:28:28 <bergmark> cuci: maybe try installing with -v3
01:28:34 <bergmark> it registers fine for me
01:28:44 <cuci> -v3?
01:28:51 <bergmark> cabal install auto-update -v3
01:29:02 <bergmark> might give more information
01:29:56 <cuci> ah I'm not using cabal. I'm trying to install it with my distro's pkg manager
02:08:23 <Kaidelong> @hoogle Monoid e => ((e -> a) -> b) -> ((e -> a) -> (e -> b))
02:08:26 <lambdabot> No results found
02:08:37 <Kaidelong> is this a kind of continuation passing style?
02:08:42 <Kaidelong> wrt to how Traced works
02:16:34 <dibblego> Kaidelong: that type is the (-> m) Comonad
02:16:49 <dibblego> @type xtend
02:16:50 <lambdabot> Not in scope: ‘xtend’
02:16:50 <dibblego> @type extend
02:16:51 <lambdabot> Not in scope: ‘extend’
02:16:58 <dibblego> extend :: (f a -> b) -> f a -> f b
02:17:20 <dibblego> extend :: Monoid e => ((e -> a) -> b) -> (e -> a) -> (e -> b)
02:21:09 <akira__> hello everyone, could someone tell me how to use lhc file? I googled but find so few info about it. I only know it's called literature haskell
02:23:22 <pavonia> Do you mean lhs files?
02:24:48 <pavonia> https://www.haskell.org/haskellwiki/Literate_programming
02:29:43 <akira__> @pavonia thanks, that seems to be what I'm looking for
02:29:43 <lambdabot> Unknown command, try @list
02:38:36 <Kaidelong> dibblego: well sure, but I was wondering if extend for that comonad was a kind of continuation passing style
02:39:00 <Kaidelong> it seems so now that I'm reading up on the idea of how it's supposed to be used though
02:39:16 <Kaidelong> build up a big computation, only execute it when you're ready to use it
02:51:05 <makalu> can I run arbitrary code at compile time with template haskell?
03:03:16 * hackagebot old-time 1.1.0.3 - Time library  http://hackage.haskell.org/package/old-time-1.1.0.3 (HerbertValerioRiedel)
03:03:18 * hackagebot old-locale 1.0.0.7 - locale library  http://hackage.haskell.org/package/old-locale-1.0.0.7 (HerbertValerioRiedel)
03:06:51 <ClaudiusMaximus> @hoogle IO a -> Q a
03:06:53 <lambdabot> Language.Haskell.TH.Syntax runIO :: IO a -> Q a
03:06:53 <lambdabot> Language.Haskell.TH runIO :: IO a -> Q a
03:06:53 <lambdabot> Language.Haskell.TH.Syntax qRunIO :: Quasi m => IO a -> m a
03:07:11 <ClaudiusMaximus> makalu: ^
03:26:35 <uvelichitel> Hi there. I'm writing a post on popular resource about different computation models. It's russian resource, so don't bother with my english. In lambda calculus the computation can be seen as expression's reduction. In Turing machine it's just state flow. So question - what computation means in category theory? Explanations or links would be very appreciated.
03:35:38 <makalu> ClaudiusMaximus: cool :)
03:48:38 <zennist> the haskell standard of naming things is to use camelcase right?
03:49:09 <ClaudiusMaximus> yes
03:49:15 <faveteli_> are there any good turtorials out there how to use Generator combinators to make custom generators in QC? I mostly find into QC turtorials
03:49:15 <zennist> does that apply to everything? i.e. variable, function, local ones, ...
03:51:04 <ClaudiusMaximus> yes, but local bindings tend to have one-word names so camelcase isn't relevant, and use primes sometimes, like x, x', x''
03:53:18 * hackagebot shake 0.14.1 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.14.1 (NeilMitchell)
03:54:44 <nh2_work> favetelinguis: so far I've managed to understand most of what I needed from http://hackage.haskell.org/package/QuickCheck-2.7.6/docs/Test-QuickCheck-Gen.html - I don't know distinct tutorials for that. Is there something in particular that you'd like to get out of such a tutorial?
04:53:37 <favetelinguis> what does all the # mean in the implementation of intToDigit, does # have a speciel meaning in Haskell or is it just a name for the functions?
04:54:22 <favetelinguis> > intToDigit
04:54:24 <lambdabot>  <Int -> Char>
04:54:41 <sipa> favetelinguis: see https://downloads.haskell.org/~ghc/7.0.2/docs/html/users_guide/syntax-extns.html 7.3.2
04:54:52 <ClaudiusMaximus> normally it's just a symbol that you can use in operator names, but with -XMagicHash you can use it in identifiers, and it's conventionally used for primitives
04:55:43 <ClaudiusMaximus> primitives being low level things not implemented in haskell, like unboxed machine ints or floats
04:57:53 <mat10> what is difference between type and data ?
04:58:20 <chrisdone> 'type' makes a transparent synonym
04:58:35 <RchrdB> mat10: type just establishes aliases or nicknames. e.g. "type String = [Char]", means that you can use the name "String" to refer to the type [Char].
04:58:39 <chrisdone> Foo is equivalent to writing Int where type Foo = Int
04:58:50 <ClaudiusMaximus> type is a type synonym (you can use the original type anywhere you use the new type, and vice versa)
04:58:55 <mat10> aha
04:59:00 <RchrdB> mat10: data lets you define new datatypes. :)
04:59:08 <RchrdB> as does newtype
04:59:11 <mat10> alrght
04:59:25 <chrisdone> @quote answered stereo
04:59:25 <lambdabot> No quotes for this person. The more you drive -- the dumber you get.
04:59:34 <mat10> so type is similar to typedef in c?
04:59:52 <RchrdB> Yes.
05:00:42 <mat10> and data is almost like a struct ?
05:01:05 <RchrdB> Well, in C, you can have anonymous struct types
05:01:20 <mat10> tyvm
05:03:47 <RchrdB> mat10: Haskell's "data Foo = Bar { x :: Int, y :: Int }" is akin to C's "typedef struct Foo { int x, y; } Foo;"
05:05:00 <mat10> Foo is the data "name ? " but what the Bar do ?
05:05:12 <RchrdB> Bar is the constructor function.
05:05:43 <RchrdB> in that case, (Bar :: Int -> Int -> Foo), so ((Bar 1 2) :: Foo)
05:05:52 <mat10> ahhh'
05:07:20 <mat10> so if [Foo]  == [Bar a a] where a is int
05:07:22 <mat10> kind of ?
05:08:00 <ChristianS> mat10: if there is a single constructor (as in this case), it often has the same name as the type, i.e. "data Foo = Foo { x :: Int, y :: Int }"
05:08:11 <RchrdB> mat10: uh, with that declaration, Foo is a type, and (Bar a a) is a value with the type Foo.
05:08:12 <ChristianS> mat10: but that's up to you, and there can be multiple constructor functions
05:08:43 <mat10> right, so you have multiple constructor which lead to the same type
05:08:53 <ChristianS> yes
05:08:53 <mat10> i may have define one of the int before.
05:09:15 <RchrdB> e.g., data Either a b = Left a | Right b
05:09:27 <RchrdB> Left and Right are constructors for Either.
05:09:28 <mat10> data Foo = Foo{ x:: Int, y ::Int} | Foo' {3, x::Int}
05:09:44 <RchrdB> (Left :: a -> Either a b), (Right :: b -> Either a b)
05:09:49 <mat10> ah
05:10:08 <mat10> thanks you, thats clear up alot :)
05:10:29 <RchrdB> sorry for bringing record syntax into it a bit early, that's slightly confusing
05:10:37 <RchrdB> record syntax is just syntactic sugar
05:10:39 <mat10> nja, good to learn, i need to learn
05:11:01 <mat10> google record syntax :O
05:12:01 <RchrdB> mat10: this explains it quite well: http://en.wikibooks.org/wiki/Haskell/More_on_datatypes
05:12:49 <RchrdB> mat10: whoops, that's the intermediate page. The beginning page on datatypes is http://en.wikibooks.org/wiki/Haskell/Type_declarations
05:12:55 <mat10> Interface ?
05:13:05 <mat10> yes, Interface in Java  == data ?
05:13:09 <mat10> almost
05:13:16 <mat10> without all the function
05:13:50 <RchrdB> Interfaces in Java are most akin to typeclasses in Haskell.
05:14:13 <RchrdB> Java's interfaces describe methods which a given type must define.
05:14:26 <RchrdB> Haskell's typeclasses describe functions which must be defined on a given type.
05:15:03 <RchrdB> (though there are lots of things that you can say using typeclasses that you can't really with java's interfaces)
05:15:14 <mat10> hehe, better i forget all about java and C :p
05:16:27 <RchrdB> You *can* write Haskell programs that work like the corresponding C program. I have. You usually don't want to.
05:16:38 <BoR0> the haskell keyword "class" corresponds to java's interface. however, for the haskell keyword "data" you can't make an analogy good enough that will hold for C or Java, since those languages do not support algebraic data types
05:17:02 <BoR0> "data" is close to C's "enum", up to some point
05:18:57 <n4x> enum/struct/discriminated ∪?
05:19:56 <orion> Unions need to unite against discrimination!
05:20:17 <ibid> data corresponds to a particular idiom of C  involving struct, enum, and union
05:20:21 <mat10> so, lets see if i m clear about data, its a collection of constructor which are to have the same (type)
05:21:41 <SvenskFi1k> When I'm pattern matching with Maybe, is there a way to disregard all arguments instead of having to type 4 underscores? This is what I have now : case x of; Just (Deck _ _ _ _). It doesn't look nice and if I change how many arguments Deck takes later, I'll have to go through and change every case that uses it, any other options?
05:22:26 <lisbeth1> hey
05:22:44 <lisbeth1> why does: 9.999999999999999 equal 9.999999999999998 after truncating
05:23:13 <supki_> SvenskFi1k: case x of Just Deck {} -> ...
05:24:17 <SvenskFi1k> Great, thanks supki_!
05:24:39 <blicero> having trouble getting hmatrix to work, when ghc loads it i get:
05:24:42 <blicero> lookupSymbol failed in relocateSection (relocate external)
05:24:43 <blicero> /opt/local/lib/liblapack.a: unknown symbol `_ATL_xerbla'
05:25:34 <Yuras> > 9.999999999999999 == (9.999999999999998 :: Rational)
05:25:35 <lambdabot>  False
05:25:50 <Yuras> lisbeth1: they are not ^
05:26:14 <lisbeth1> open up ghci
05:26:15 <lisbeth1> and type
05:26:16 <lisbeth1> 9.999999999999999
05:26:21 <lisbeth1> and tell I'm wrong
05:27:07 <FireFly> Presumably because of limited precision of doubles
05:27:11 <Yuras> lisbeth1: ghci defaults in to double, but 9.999999999999999 is not representable as Double
05:27:23 <Yuras> 9.999999999999999 == (9.999999999999998 :: Double)
05:27:28 <Yuras> > 9.999999999999999 == (9.999999999999998 :: Double)
05:27:30 <lambdabot>  True
05:27:33 <geekosaur> blicero: something's wrong with your atlas library as the lapack library expects it
05:28:02 <blicero> i have numpy/scipy installed and depending on atlas libs and they work fine
05:28:02 <FireFly> lisbeth1: compare 9.999999999999999 :: Rational to 9.999999999999998 :: Rational in ghci
05:28:15 <geekosaur> lisbeth1: welcome to IEEE floating point. this isn't a haskell problem, I can find you people complaining about that with any language you care to name that uses floating point
05:28:22 <orion> If I am writing a function to be passed to foldl (which needs type b -> a -> b), can (ByteString, Int) -> Int -> (ByteString, Int) be considered a valid concrete type for the function?
05:28:35 <lisbeth1> that's just strange
05:28:38 <lisbeth1> thats all
05:28:58 <lisbeth1> I guess it has to do with the structure of the binary and not a design decision
05:29:11 <osa1> I'm looking for efficient functional and non-functional(ST/IO) queue implementations.. any ideas?
05:29:12 <geekosaur> it is, but it's a strange you eventually get used to because it happens everywhere. floating point is necessarily an approximation and it behaves strangely at the edges of precision
05:29:24 <ChristianS> orion: sure, why not? and you can always check in ghc whethere it accepts it
05:30:18 <geekosaur> it is not possible *in hardware* to exactly represent all real numbers
05:31:07 <bitonic> osa1: <https://www.haskell.org/pipermail/haskell-cafe/2013-March/107253.html>
05:32:08 <bitonic> nh2_work: ^^^ people are asking for efficient queues
05:32:44 <osa1> thanks
05:33:28 <orion> ChristianS: makes sense
05:33:33 <bitonic> osa1: so the takeaway from that message is that those 3 packages are not great, performance wise.  but there is some more information in that thread, iirc
05:35:04 <osa1> bitonic: thanks. actually I don't need priorities, I just want standard FIFO data structure so maybe I should just use FingerTree
05:35:35 <osa1> I'm also looking for mutable and more efficient ones.
05:36:06 <osa1> maybe I can hack one on top of mutable vectors.
05:36:23 <bitonic> osa1: so wait, you need Seq?
05:36:45 <osa1> what is Seq?
05:37:18 <bitonic> or you might just need `data Queue a = Queue [a] [a]', the fastest purely functional queue :P
05:37:35 <bitonic> push on the first, pop on the second, reverse the first when needed
05:37:35 <osa1> I'm wondering about Chan performance
05:37:53 <n4x> I only have used Data.Dequeue from dequeue, has anyone benchmarked it?
05:38:13 <bitonic> osa1: well that does much more -- the whole waiting and concurrency bit
05:38:31 <osa1> I know but it may still be faster than functional implementations
05:39:41 <bitonic> osa1: well yeah a mutable doubly linked list it's going to be faster
05:40:21 <bitonic> no doubt about that
05:41:26 <bitonic> osa1: what do you need to do anyway?
05:41:36 <dfeuer> bitonic, that email's about PSQueues.
05:42:20 <bitonic> dfeuer: yeah, I thought that's what he wanted.  I thought the matter on normal queues was pretty much set :P
05:42:58 <bitonic> you need functional -- you use two lists.  you're OK with mutable stuff -- you use a doubly linked list
05:43:45 <dfeuer> bitonic, is the banker's queue (two-list one balanced for sharing) good when it's much bigger than cache?
05:44:14 <osa1> bitonic: I'll push some tasks to workers, but I want to be able to filter task queue before dequeuing(e.g. take 10 tasks that is <some condition>) so Chans won't work.
05:44:19 <dfeuer> Oh, probably still about as good as it can be.
05:44:28 <dfeuer> Hmmmm.... maybe.
05:44:52 <bitonic> dfeuer: I wasn't considering cache issues -- I rarely do when thinking about data structures in Haskell.  if you're seeing things in that perspective, than growing a vector is probably the best thing
05:45:05 <dfeuer> Doubly linked lists are pretty lousy.
05:45:22 <dfeuer> For non-persistent, I mean.
05:45:28 <bitonic> osa1: then use TChan, you can unGet things
05:45:49 <bitonic> dfeuer: well I don't know if persistency is a requirement.  it rarely is
05:45:54 <dfeuer> For persistent, I'm just not sure. It might or might not be better to use a fancier queue when it gets really big.
05:46:26 <bitonic> osa1: well you can unGet things in chan too, but it's not the best idea iirc
05:46:30 <osa1> bitonic: it's STM though
05:47:09 <dfeuer> bitonic, as far as I know, the doubly linked list approach only makes sense if the pauses to grow arrays are unacceptable--i.e, you're doing something realtimey.
05:47:25 <bitonic> osa1: is that a problem?
05:47:39 <osa1> bitonic: I never used it so far :p
05:47:49 <bitonic> it's great!  good chance to try it
05:48:10 <bitonic> dfeuer: grow arrays?  with doubly linked list I mean... a linked list, no arrays
05:48:56 <dfeuer> bitonic, I know. What I'm saying is that growable arrays are likely better than doubly linked lists unless you can't take those pauses. Doubly linked lists have twice the excess baggage of singly-linked ones.
05:49:08 <bitonic> dfeuer: ah, sure
05:49:34 <bitonic> that's what I meant with "growing a vector is probably the best thing"
05:49:54 <dfeuer> Oh, and I thought you were talking about a persistent vector.
05:50:01 <dfeuer> Communication is lovely.
05:51:29 <bitonic> osa1: there <http://hackage.haskell.org/package/stm-2.4.3/docs/Control-Concurrent-STM-TQueue.html>
05:51:58 <bitonic> newTQueueIO to get it, and then `atomically writeQueue' and `atomically readQueue'
05:52:01 <bitonic> super easy
05:52:10 <bitonic> and `atomically $ takeWhileQueue f' or whatever
05:53:42 <bitonic> if you have some worker threads that accept tasks from multiple sources concurrently, that's definitely what you want
05:55:22 <osa1> bitonic: I have multiple workers but one source that sends tasks
05:56:40 <bitonic> osa1: but source and worker work concurrently right?
05:57:13 <osa1> bitonic: I create workers using `async`s async
05:57:18 <osa1> so yes
05:57:31 <bitonic> right.  I'd definitely use TQueue so you don't think about the concurrency issues at all
05:58:13 <bitonic> instead of mucking with some mutable structure with a MVar on top or something
05:58:21 <bitonic> TQueue is still probably going to be faster anyhow
05:58:59 <osa1> TQueue is faster than MVar + mutable queue? interesting.
05:59:41 <bitonic> well obviously it depends
05:59:57 <bitonic> but TVars can be faster than atomicallyModifyIORef with the right conditions
06:00:24 <bitonic> what I'd do if I were you is use TQueue and worry about performance later :P
06:00:42 <osa1> yeah that's what I'm going to do
06:00:47 <osa1> thanks for the pointeres
06:01:28 <osa1> oh
06:01:29 <bitonic> don't treat it as some sort of heavy duty queue (e.g. RabbitMQ or similar), it's still a very simple data structure
06:01:39 <bitonic> e.g. if you need your queues to be huge, you're going to run into problems
06:01:54 <osa1> I think I also can't do the filtering thing I mentioned
06:02:07 <bitonic> why not?
06:02:29 <bitonic> you can do anything you want in an `atomically'
06:02:32 <osa1> so really the API I need is this: I should be able to say "give me 10 tasks with <some conditions>"
06:02:49 <bitonic> osa1: yeah, no problem, read and push back in an `atomically' block
06:04:33 <dramforever> osa1: what's the problem?
06:05:35 <hexa> Hi, I'm recently learning haskell and using exercism.io to get my feets wet... in there I need to create a module that will be imported like so : import Sublist (Sublist(Equal, Sublist, Superlist, Unequal), sublist) ... but I don't understand this import syntax it means import Module Sublist and then another Submodule Sublist and the function sublist from the parent module ? ... trying to read the doc on import but I don't get this second Sublist() level.
06:05:35 <hexa> . ideas ?
06:06:04 <bernalex> is there a good way to do "a -> IO (Maybe a) -> a"? so like fromMaybe but with an IO (Maybe a) instead of a Maybe a.
06:06:10 <ClaudiusMaximus> hexa: it imports constructors from the Sublist type
06:06:11 <osa1> dramforever: see logs :p no problems really, I gotta go now. I was just asking ideas for how to implement a task queue that will be shared among worker threads etc. pretty standard stuff actually
06:06:26 <bernalex> or really, Monad m => m (Maybe a)
06:07:01 <hexa> ClaudiusMaximus, ok so I need to make a sublist type with a constructor Called Equal for example ?
06:07:16 <ClaudiusMaximus> hexa: probably
06:07:32 <supki_> :t fmap . fromMaybe
06:07:32 <lambdabot> Functor f => b -> f (Maybe b) -> f b
06:07:38 <hexa> ClaudiusMaximus, and I would export it like so ? module Sublist (Sublist(Equal..) ?
06:07:56 <ClaudiusMaximus> hexa: yes
06:08:08 <hexa> ClaudiusMaximus, k thx I'll dig in that direction :)
06:11:24 <bitonic> osa1: this kind of stuff <http://lpaste.net/114705>
06:11:27 <bitonic> STM is lovely
06:11:36 <bernalex> oh yeah I can just liftA in a clever way probably hmm
06:12:17 * bomb3r love u freenode! :@
06:18:48 * dramforever has a screenful of join and quit messages
06:19:00 <bomb3r> :)))
06:19:04 <bernalex> hm. what should I be doing instead of
06:19:16 <bernalex> fromMaybe (bunch . of . stuff) (returns <$> foo)
06:19:24 <bernalex> ? return <$> foo feels very wrong.
06:19:34 <bernalex> s/returns/return/ btw
06:19:52 <dramforever> :t fromMaybe
06:19:53 <lambdabot> a -> Maybe a -> a
06:19:58 <bitonic> fromMaybe <<blah>> <$> foo?
06:20:20 <dramforever> :t fromMaybe 2 <$> Just 1
06:20:21 <lambdabot> (Num (Maybe b), Num b) => Maybe b
06:20:25 <bernalex> bitonic: I wish
06:20:29 <dramforever> ouch, fail
06:20:44 <dramforever> :t (fromMaybe 2 <$>)
06:20:44 <nshepperd> :t return <$> a
06:20:44 <lambdabot> (Num b, Functor f) => f (Maybe b) -> f b
06:20:45 <lambdabot>     Couldn't match expected type ‘f a’ with actual type ‘Expr’
06:20:45 <lambdabot>     In the second argument of ‘(<$>)’, namely ‘a’
06:20:45 <lambdabot>     In the expression: return <$> a
06:20:46 <bernalex> I'm in a do block of a Parsable a => Text -> (a -> ActionE (Maybe (b))) -> ActionE b function, and ActionE is a burrito with like 4 monads and ughugh
06:21:12 <greymalkin> Anyone have any good tips on consuming [[String]] sequencially in a `do` block?
06:21:24 <dramforever> :t mapM
06:21:25 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
06:21:28 <dramforever> :t mapM_
06:21:29 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
06:21:43 <dramforever> :t mapM_ . mapM_
06:21:43 <lambdabot> Monad m => (a -> m b) -> [[a]] -> m ()
06:21:54 <greymalkin> dramforever: Are those directed at me?
06:22:01 <dramforever> greymalkin: yep
06:22:05 <dramforever> is that what you want?
06:22:21 <greymalkin> Sweet! It might be -- I don't know, I'll play around and see what comes of it.
06:22:41 <dramforever> greymalkin: it just iterates over all those Strings
06:23:20 <greymalkin> I'm looking to iterate over the internal [String] objects, but that might have the right effect.
06:23:24 * hackagebot ghc-make 0.3 - Accelerated version of ghc --make  http://hackage.haskell.org/package/ghc-make-0.3 (NeilMitchell)
06:23:33 <nshepperd> :t maybe
06:23:34 <lambdabot> b -> (a -> b) -> Maybe a -> b
06:23:46 <dramforever> :t fromMaybe
06:23:47 <lambdabot> a -> Maybe a -> a
06:23:58 <nshepperd> bernalex: `maybe (bunch . of . stuff) return foo`?
06:24:01 <dramforever> :t (\x -> maybe x id)
06:24:02 <lambdabot> b -> Maybe b -> b
06:24:04 <bitonic> bernalex: `maybe (do . some stuff) return $ foo'?
06:24:09 <bitonic> too late
06:24:19 <bitonic> don't know why I put a $ there
06:24:28 <nshepperd> bernalex: idk, you could pattern match it instead, for clarity of what's actuallly going on
06:24:41 <nshepperd> case foo of { blah }
06:24:44 <bernalex> bitonic: that won't work I think
06:24:53 <dramforever> @pl (\x -> maybe x id)
06:24:53 <lambdabot> flip maybe id
06:24:57 <dramforever> hmmm...
06:24:58 <bernalex> bitonic: oh. yes it will. I missed the '$'.
06:25:22 <dramforever> I think this $ has no effect here
06:25:30 <bitonic> :t \a b -> maybe a return b
06:25:31 <lambdabot> Monad m => m a -> Maybe a -> m a
06:25:52 <bitonic> yeah the $ is if foo is some compound expression that you don't want to parenthesise
06:26:00 <bitonic> to be fair, I'd probably pattern match too
06:28:24 * hackagebot lucid 0.3 - Clear to write, read and edit DSL for HTML  http://hackage.haskell.org/package/lucid-0.3 (ChrisDone)
06:29:48 <bitonic> chrisdone: that looks fairly similar to blaze-html, what's the difference?
06:35:26 <ruuns> hi :)
06:35:56 <dramforever> ruuns: hello
06:36:21 <clrnd> bitonic, he explains it here http://chrisdone.com/posts/lucid
06:36:23 <clrnd> hi
06:39:05 <chrisdone> alright i'm done fiddling with it for now =p
06:39:31 <clrnd> the Monad instance of Blaze is enough excuse to never use it again ever
06:39:43 <benzrf> clrnd: oh?
06:40:26 <clrnd> I'm reading chrisdone's article on the subject, I pasted it ^
06:42:10 <bitonic> clrnd: thanks
06:42:28 <bitonic> well I don't think it's a reason not to use blaze.  you need to be aware of it.  the Monad instance it's just meant to be used for sugar
06:42:49 <clrnd> chrisdone, what made you choose the underscore suffix?
06:42:57 <ruuns> hi chrisdone :)
06:43:01 <osfameron> ah, that's cute.  using HTML generation functions in the year that Perl's CGI has *finally* admitted that they were a terrible idea...
06:43:25 * hackagebot lucid 0.4 - Clear to write, read and edit DSL for HTML  http://hackage.haskell.org/package/lucid-0.4 (ChrisDone)
06:43:50 <chrisdone> (that's the last tweak, i promise =p)
06:43:54 <alpounet> chrisdone: two major releases in 15 minutes? :p
06:44:12 <chrisdone> nahh, that's minor. 1.0 would be major
06:44:14 <dramforever> hmmm....
06:44:30 <bitonic> chrisdone: read the article, nice.  although I was never too bothered by qualified imports, I agree on all the rest
06:44:40 <clrnd> I'm loving it, just not sure about the_ underscore_ suffix_ thing_
06:44:42 <dramforever> why not a html *monoid*?
06:44:48 <bitonic> chrisdone: have you mentioned that to jaspervdj
06:44:53 <chrisdone> clrnd: i wanted any character that would distinguish data from code, so the choice was pretty much ' or _. i preferred _ in the end. also _ is overloaded meaning "returns ()", which is what the combinators do =)
06:44:54 <clrnd> dramforever, it is a monoid
06:45:15 <alpounet> chrisdone: the two first numbers make the "major version number", per the pvp, don't they?
06:45:49 <clrnd> chrisdone, nice work :)
06:45:56 <chrisdone> clrnd: thanks =)
06:46:46 <chrisdone> alpounet: IME i found that with a.b.c i never end up using the `a'. so i use a.b for major.minor
06:47:20 <chrisdone> major = change of behaviour or API likely to break someone's build, minor = well, not that
06:47:22 <pantsman> chrisdone: you can have two qualified imports with the same alias, so the "import … as H" and "import … as A" seems like an unfair criticism
06:47:29 <alpounet> chrisdone: yeah, true, most of the time 'a' is 0, until the library becomes really mature, enough to make 'a' = 1
06:47:31 <pantsman> since they could both have been imported as H
06:47:45 <dramforever> chrisdone: have you considered about Text.HTML.Lucid rather than just Lucid?
06:48:19 <dramforever> to follow those hierarchical libraries
06:48:23 <chrisdone> pantsman: that's not how people work in practice. there are name conflicts with attributes and elements, so H.style or H.map would be ambiguous
06:48:24 <bitonic> ugh, I much rather prefer Lucid
06:48:39 <bitonic> the hierarchical bit never worked anyway
06:49:02 <bitonic> better to have a pretty unique top-level module namespace, imo
06:49:12 <pantsman> chrisdone: oh I see, there are conflicts even between the Blaze modules… I didn't get that from the article, sorry!
06:49:13 <chrisdone> dramforever: i'm not big on the pointless hierarchy anymore, personally…
06:49:24 <pantsman> chrisdone: that is indeed pretty bad
06:49:24 <chrisdone> pantsman: no problem
06:49:46 <dramforever> hmmm...you got a point there
06:49:55 <benzrf> lucid looks nice
06:49:57 <benzrf> chrisdone: :-)
06:50:00 <chrisdone> :D
06:50:29 <benzrf> i have not actually used blaze but your criticism of it totally convinced me to consider it harmful
06:50:32 <benzrf> :v
06:50:43 <chrisdone> heh heh
06:50:52 <bitonic> meh, it's not harmful
06:51:41 <chrisdone> well it's kind of a de facto standard on hackage. plenty of libraries using it. it's a great library. i'm just preempting the questions of 'why not blaze'
06:51:59 <chrisdone> i forgot to mention this, updated my post: http://chrisdone.com/posts/lucid#attributes-dont-compose
06:52:05 <chrisdone> that attributes problem bugged me for a while
06:52:24 <dramforever> I'm not sure if you should do this, though
06:52:46 <chrisdone> http://chrisdone.com/posts/lucid#composing-attributes
06:52:59 <chrisdone> ^ here's my solution. i'm not sure it's great, i'm going to see how it feels
06:54:25 <xplat> chrisdone: i like that attributes compose.  generally it seems i would like lucid better than blaze despite not sharing a lot of your tastes
06:55:49 <k00mi> chrisdone: are you aware that you can import several modules under the same qualifier?
06:56:26 <pantsman> heh, I think chrisdone needs to add a note that he knows this :P
06:57:04 <chrisdone> k00mi: indeed. http://ircbrowse.net/selection/haskell?title=Conversation&events=19505398,19505400,19505407
06:57:11 <xplat> chrisdone: i would actually use 'p_ `with` [stuff] $ do' or 'p_ `with` [stuff] $ mconcat [children]' though because i don't like the prefix 'with' hiding the element name
06:57:13 <chrisdone> pantsman: i might add a note, yeah =p
06:57:43 <k00mi> ok :-)
06:57:51 <xplat> (probably only when using inline though)
06:58:37 <chrisdone> xplat: understandable. i'm not 100% happy about that but i do prefer it to infixness. maybe my post might spark someone to come up with something better on the UX side
07:01:25 <chrisdone> one nice thing about clojure i noticed is that they have vector syntax similar to haskells: [1 2 (* 2 3)] is like [1,2,2 * 3]
07:01:36 <chrisdone> but they also have :foo syntax which just makes a symbol
07:01:45 <chrisdone> so they can trivially write [:p [:span "Hello!"]]
07:01:51 <clrnd> that may be the single best thing about clojure
07:01:57 <chrisdone> without having to declare :p and :span ahead of time
07:02:04 <chrisdone> yeah, pretty elegant
07:02:25 <clrnd> and the (:foo {:foo 5}) => 4 thing
07:03:12 <clrnd> enlive was a charm to work with
07:06:33 <fds4345> withFile myFile ReadMode hGetContents --  why does this always return ""
07:06:43 <benzrf> fds4345: lazy io
07:06:48 <benzrf> anybody have a link?
07:07:13 <benzrf> @google lazy io faq
07:07:14 <lambdabot> http://stackoverflow.com/questions/5892653/whats-so-bad-about-lazy-i-o
07:07:14 <lambdabot> Title: haskell - What's so bad about Lazy I/O? - Stack Overflow
07:07:21 <fds4345> grr. where are the strict file IO functions
07:09:33 <indiagreen> @hackage strict-io
07:09:33 <lambdabot> http://hackage.haskell.org/package/strict-io
07:09:39 <chrisdone> fds4345: are you working with binary or text?
07:10:06 <chrisdone> because i'd recommend either the bytestring or text libraries depending on the answer
07:10:23 <xplat> you quite likely want to use bytestring or text io instead of string io anyway if you're slurping a whole file strictly
07:10:27 <chrisdone> both of which have strict and lazy module hierarchies
07:10:37 <xplat> it's save you over 90% on space
07:12:20 <xplat> plain strings are actually rather good for use as transient structures going through a pipeline of transformations, but you basically don't want to use them for stuff that's going to hang around a while because for that they're slow and bulky
07:12:20 <fds4345> can something be an algorithm if it has no inputs
07:23:05 <greymalkin> I'm having a hell of a time figuring out how to propagate an error from pure code into IO; I know this is probably basic, but I still don't get it.
07:23:27 * hackagebot dao 0.1.0.1 - Dao is meta programming language with its own built-in  interpreted language, designed with artificial  intelligence applications in mind.  http://hackage.haskell.org/package/dao-0.1.0.1 (RaminHonary)
07:25:19 <EvanR> greymalkin: what are you using, Maybe, Either, throw?
07:25:21 <EvanR> :t throw
07:25:22 <lambdabot> Exception e => e -> a
07:26:47 <zolk3ri> Hafydd: Hello.
07:27:04 <greymalkin> I've tried Either (want to have at least *something* to show why) but I keep getting errors like "Could not deduce (m ~ IO)" and "ambiguous Either a0 Result"
07:27:25 <EvanR> Either makes sense
07:27:48 <EvanR> show code
07:27:52 <RchrdB> greymalkin: could you pastebin some of the code that you're having trouble with, please?
07:28:32 <greymalkin> It's changing again -- I think it's because I'm trying to be too generic about what comes back as an error -- if this doesn't work, I'll happily pastebin.
07:29:09 <EvanR> to come all the Eithers they need to have the same LHS error type
07:29:13 <EvanR> combine*
07:29:28 <EvanR> String for example
07:29:52 <greymalkin> Mostly, I already have a working program, but it's still very IO heavy.
07:30:23 <lengzai> hey all, is newtype sorta like a strict version of data?  I know there is bang(!) notation also, why would you use newtype over data?
07:32:02 <EvanR> > isJust (Just undefined)
07:32:04 <lambdabot>  True
07:32:45 <EvanR> > mconcat [Sum undefined]
07:32:47 <lambdabot>  Sum {getSum = *Exception: Prelude.undefined
07:32:50 <EvanR> hmm
07:34:24 <pantsman> lengzai: newtype creates a new type, so you'd use it when you want different semantics for operations on that data
07:34:48 <EvanR> yes but that doesnt explain how its different from data with one constructor with one field
07:35:06 <EvanR> > let x = Sum undefined in 3
07:35:08 <lambdabot>  3
07:35:19 <EvanR> > let Sum _ = Sum undefined in 3
07:35:20 <lambdabot>  3
07:35:44 <EvanR> neither does this
07:35:52 <indiagreen> > case Sum undefined of Sum _ -> 3
07:35:54 <lambdabot>  3
07:36:38 <pantsman> oh, I misread the question as "why would you use newtype over $!"
07:38:11 <lengzai> i've heard some people saying that instead of using type one should try and use newtype
07:38:24 <lengzai> because type is interchangeable with the type you're aliasing
07:38:27 * hackagebot verilog 0.0.8 - Verilog parser and DSL.  http://hackage.haskell.org/package/verilog-0.0.8 (TomHawkins)
07:38:31 <EvanR> only use type when you dont want to distinguish between the names of the type
07:38:59 <EvanR> use newtype when you want to be explicit about the conversion, and or add new operations
07:39:03 <EvanR> or replace operations
07:39:16 <lengzai> so if I have something like: type Point = (Int, Int)
07:39:21 <greymalkin> Okay, that didn't work ... http://pastebin.com/ba8JHLjf
07:39:28 <lengzai> would it make more sense just to make it: newtype Point = Point (Int, Int)
07:39:30 <pantsman> an alias has exactly the same semantics as the original, and you might not want to permit that
07:39:42 <greymalkin> There's a *lot* riding in IO right now, so I pulled most of it out to give the highlights.
07:39:42 <EvanR> lengzai: only if you wanted to redefine the Num instance, for example
07:40:04 <EvanR> well thats what reason why youd want a newtype
07:40:06 <greymalkin> But this has everything that causes ther error.
07:40:13 <dfeuer> :t liftA
07:40:14 <lambdabot> Applicative f => (a -> b) -> f a -> f b
07:40:31 <EvanR> @src liftA
07:40:31 <lambdabot> liftA f a = pure f <*> a
07:40:32 <dfeuer> Yes, it's hard for me to remember that liftA and liftM are really fmap in disguise.
07:40:55 <nshepperd> "newtype Point = Point (Int, Int)" stops you from accidentally mixing Points with non-Point Int pair
07:41:03 <lengzai> ok
07:41:17 <lengzai> would you say it's good practice to prefer newtype over type?
07:41:26 <EvanR> greymalkin: in your Either function, you are trying to do IO? you cant
07:41:29 <lengzai> in most cases
07:42:03 <dfeuer> lengzai, often. Your regrets will be shallower.
07:42:26 <EvanR> greymalkin: when you say "propagate errors from pure functions" you first need to actually have pure functions
07:42:38 <lengzai> haha, that's a great reason... thanks dfeuer, and EvanR
07:42:46 <lengzai> and pantsman
07:43:04 <lengzai> and nshepperd
07:43:20 <lengzai> did i miss anyone? :)
07:43:28 <EvanR> lengzai: we still didnt establish the difference between this and a simple new data
07:43:55 <greymalkin> EvanR: Sorry... some type signatures are off/missing. Try this: http://pastebin.com/VAjW8b3t
07:44:55 <greymalkin> I have a collection of other functions like doGrant -- all of them are pure, and they all simply modify the password (large structure)
07:45:03 <EvanR> greymalkin: doGrant has two argument but the type sig allows only one
07:45:20 <lengzai> so, EvanR would the difference just relate to how lazy it is?
07:45:40 <dfeuer> Is there any sense to the `seq` here:      _ -> let (q, r) = n `quotRem` 3 in q `seq` case r of
07:45:43 <lengzai> i read on stackoverflow that in that case the simple data type would not evaluate unless peaked inside
07:45:52 <lengzai> so you could pass around undefined values if you want
07:46:04 <greymalkin> Arg.... yes.
07:46:08 <greymalkin> EvanR: Thanks.
07:46:24 <EvanR> lengzai: something like that but i failed to produce a bot example. with newtype the "constructor" has no runtime representation, so it somehow cant delay its value as if it was a data type
07:47:13 <nshepperd> the newtype constructor is sort of a hallucination
07:47:27 <nshepperd> pattern matching on it always succeeds
07:47:53 <nshepperd> > case undefined :: Sum Int of Sum _ -> "hi"
07:47:55 <lambdabot>  "hi"
07:48:16 <indiagreen> nshepperd: cool, thanks for showing this
07:48:26 <dfeuer> nshepperd, I think it's semantically the same as a single-field strict record except for the bizarre pattern matching, right? But ends up compiled differently.
07:48:28 * hackagebot pugixml 0.3.0 - pugixml binding.  http://hackage.haskell.org/package/pugixml-0.3.0 (HirotomoMoriwaki)
07:48:36 <Darwin226> Hey. I'm playing with quasi quoting and template haskell. Is there a way to parse a part of the quote as regular haskell code? Like a default parser that does what the haskell parser would usually do?
07:49:25 <nshepperd> the semantically the same as the original data type being wrapped
07:49:49 <nshepperd> as in, the set of values inhabiting the type is identical
07:50:33 <nshepperd> the only purpose the constructor serves is type conversion
07:50:37 <EvanR> nshepperd: er, but there is some difference having to do with strictness
07:50:43 <nshepperd> in either direction
07:52:08 <nshepperd> (\(Sum x) -> x) = coerce
07:52:13 <nshepperd> Sum = coerce
07:52:44 <pantsman> "semantically the same" in what sense of semantics?
07:53:28 * hackagebot apiary 1.1.4 - Simple and type safe web framework that can be automatically generate API documentation.  http://hackage.haskell.org/package/apiary-1.1.4 (HirotomoMoriwaki)
07:53:30 * hackagebot apiary-helics 1.1.4 - helics support for apiary web framework.  http://hackage.haskell.org/package/apiary-helics-1.1.4 (HirotomoMoriwaki)
07:53:41 <lengzai> > case undefined :: Sum Int of Sum _ -> "hi"
07:53:42 <lambdabot>  "hi"
07:54:45 <EvanR> > case undefined :: Identity Int of Identity _ -> "hi"
07:54:46 <lambdabot>  "hi"
07:55:14 <nshepperd> pantsman: denotational semantics
08:03:33 <nshepperd> I think, according to domain theory Sum and getSum are both strict
08:03:42 <bernalex> is it possible to return a record selector from a class function?
08:03:54 <nshepperd> Sum undefined = undefined; getSum undefined = undefined
08:04:39 <EvanR> but (assuming Identity is a data not a newtype) isnt it the same thing?
08:04:50 <EvanR> > Identity undefined
08:04:52 <lambdabot>  Identity {runIdentity = *Exception: Prelude.undefined
08:05:17 <pantsman> nshepperd: my understanding of denotational semantics is sketchy, but I don't understand how this is the case
08:05:17 <EvanR> > runIdentity (Identity undefined)
08:05:19 <lambdabot>  *Exception: Prelude.undefined
08:05:44 <EvanR> > runIdentity undefined
08:05:46 <lambdabot>  *Exception: Prelude.undefined
08:05:58 <pantsman> let's say 1, Sum 1 and Product 1 have the same semantics - then wouldn't Sum 1 <> Sum 1 have to have the same semantics as Product 1 <> Product 1 ?
08:06:18 <pantsman> but obviously they denote different programs
08:06:28 <nshepperd> er, right
08:06:35 <nshepperd> I think I meant domain theory
08:06:54 <nshepperd> I mean there's a direct isomorphism between the two types
08:07:11 <nshepperd> expressed by Sum/getSum
08:07:19 <nshepperd> or Identity/runIdentity
08:08:50 <EvanR> :t getSum
08:08:51 <lambdabot> Sum a -> a
08:08:55 <enthropy> bernalex: no. I guess the next best thing (or maybe it's better?) is to return a ALens ...
08:09:02 <nshepperd> maybe 'semantically the same' is the wrong way of putting it. the srictness properties are the same as the original type, with nothing added
08:09:07 <EvanR> Sum is a newtype constructor and getSum is a function right
08:10:06 <enthropy> > (Sum 1){ getSum = 2 }
08:10:07 <lambdabot>  Sum {getSum = 2}
08:10:08 <fds4345> !hoogle (a -> Bool) -> [a] -> ([a], [a])
08:10:16 <bitraten> Is there an easy way to catch Control.Exception inside of Control.Monad.Error?
08:10:25 <EvanR> there appears to be a disconnect between common wisdom and this. newtype is considered somehow semantically different from data 1
08:10:30 <EvanR> (ok Sum is a data not a newtype)
08:11:00 <enthropy> it's newtype
08:11:04 <nshepperd> hmm? Sum is a newtype
08:11:11 <EvanR> oh, you can add record fields?
08:11:28 <enthropy> newtype Sum a = Sum {getSum :: a} -- Defined in ‘Data.Monoid’
08:11:34 <nshepperd> newtype 'record syntax' is just syntactic sugar
08:11:49 <nshepperd> that defines a convenient accessor function for you
08:11:56 <EvanR> ok
08:12:07 <triliyn> > undefined { getSum = 3 }
08:12:09 <lambdabot>  Sum {getSum = 3}
08:12:30 <enthropy> it's mostly useless for record updates, otherwise people would have seen it in the wild?
08:12:32 <EvanR> > undefined { runIdentity = 3 }
08:12:33 <lambdabot>  Identity {runIdentity = 3}
08:12:41 <pantsman> is it correct or nonsense to say that newtype Foo preserves the cardinality of the wrapped type, but data Foo doesn't because it adds Foo ⊥ ?
08:13:09 <EvanR> how do you observe the difference?
08:14:32 <nshepperd> pantsman: right, "data Foo = Foo Int" distinguishes between ⊥ and (Foo ⊥)
08:14:51 <EvanR> but how
08:15:21 <c_wraith> EvanR: pattern-matching on the constructor
08:15:25 <nshepperd> (case undefined :: Foo of Foo _ -> "hi") will crash
08:15:27 <triliyn> "case undefined :: Foo of _ -> whatever" is whatever
08:15:35 <EvanR> can you make the bot do this
08:15:54 <c_wraith> @let newtype NewType = NT Int
08:15:55 <lambdabot>  Defined.
08:16:06 <triliyn> > case undefined :: Either Int String of Left _ -> 6
08:16:08 <lambdabot>  *Exception: Prelude.undefined
08:16:08 <EvanR> we already did it with Sum and Identity
08:16:13 <triliyn> > case undefined :: Either Int String of _ -> 6
08:16:14 <c_wraith> > case undefined of NT _ -> ()
08:16:15 <lambdabot>  6
08:16:16 <lambdabot>  can't find file: L.hs
08:16:16 <EvanR> now do it with a single-constructor data
08:16:20 <c_wraith> > case undefined of NT _ -> ()
08:16:21 <lambdabot>  ()
08:16:35 <nshepperd> @let data Data = D Int
08:16:36 <lambdabot>  Defined.
08:16:57 <nshepperd> > case undefined :: Data of D _ -> "hi"
08:16:59 <lambdabot>  Ambiguous occurrence ‘Data’
08:16:59 <lambdabot>  It could refer to either ‘L.Data’, defined at L.hs:163:1
08:16:59 <lambdabot>                        or ‘Data.Data.Data’, imported from ‘Data.Data’ at L.hs...
08:17:09 <c_wraith> nshepperd: don't need the type ascription
08:17:09 <nshepperd> ...I regret that
08:17:19 <c_wraith> @undefine
08:17:19 <lambdabot> Undefined.
08:17:26 <c_wraith> try again with a better name. :P
08:17:41 <nshepperd> @let data Foo = Foo Int
08:17:42 <lambdabot>  Defined.
08:17:46 <nshepperd> everyone likes Foos
08:17:53 <nshepperd> > case undefined :: Foo of Foo _ -> "hi"
08:17:55 <lambdabot>  "*Exception: Prelude.undefined
08:18:10 <c_wraith> @let newtype Bar = Bar Int
08:18:11 <lambdabot>  Defined.
08:18:20 <c_wraith> > case undefined :: Bar of Bar _ -> "hi"
08:18:21 <lambdabot>  "hi"
08:18:26 <c_wraith> EvanR: that's the difference
08:18:29 <dfeuer> :t (<$>)
08:18:30 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:19:07 <c_wraith> EvanR: operationally, pattern-matching on a newtype constructor does nothing.  pattern-matching on a data constructor forces evaluation.
08:19:15 <EvanR> > case Foo undefined of Foo _ -> "Hi"
08:19:16 <lambdabot>  "Hi"
08:19:28 <EvanR> > case Bar undefined of Bar _ -> "Hi"
08:19:29 <lambdabot>  "Hi"
08:20:28 <EvanR> > let Foo x = undefined in "hi"
08:20:30 <lambdabot>  "hi"
08:20:33 <EvanR> > let Bar x = undefined in "hi"
08:20:35 <lambdabot>  "hi"
08:20:42 <EvanR> this is really tricky
08:20:59 <EvanR> in practice you might never run into a difference accidentally it seems like
08:21:05 <gcganley> EvanR: it just looks like its never eval'd
08:21:09 <c_wraith> EvanR: the difference is hugely important
08:21:52 <nshepperd> EvanR: those let-bindings aren't being evaluated there is x is never called for
08:22:05 <EvanR> yeah
08:22:15 <EvanR> same with the case though
08:22:33 <ab9rf> no, not same with case
08:22:53 <EvanR> no i guess it needs to know which case
08:23:05 <EvanR> even if theres only one case >_<
08:23:27 <triliyn> > let Bar x = undefined in x `seq` "hi"
08:23:28 <lambdabot>  "*Exception: Prelude.undefined
08:23:31 <gcganley> :t if
08:23:32 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
08:23:41 <gcganley> i was curious if that was function
08:23:43 <triliyn> > let Foo x = undefined in x `seq` "hi"
08:23:44 <lambdabot>  "*Exception: Prelude.undefined
08:23:44 <triliyn> oh wait
08:23:45 <ab9rf> 'if' is syntax, not function
08:23:48 <EvanR> same thing
08:23:59 <EvanR> :t bool
08:24:00 <lambdabot> a -> a -> Bool -> a
08:27:43 <lpaste> c_wraith pasted “newtype vs data” at http://lpaste.net/114716
08:27:57 <EvanR> why would you write such a case express for either newtype or data?
08:27:59 <c_wraith> EvanR: see that paste..  It really does matter
08:30:08 <nkar> I have a splice that accepts a string.  How can I pass in a variable of the String type?  For example, $(splice "foo") works, \foo -> $(splice foo) doesn't.
08:30:16 <EvanR> so if you changed the code to m >>= f = f (getStrict m), and, m >>= f = f (getLazy m)
08:30:30 <bernalex> hm. is there an eater way to do "isJust a && f a"? as opposed to fromMaybe or whatever.
08:30:30 <EvanR> would that make them act the same
08:30:34 <c_wraith> EvanR: that's make the strict one lazy, because it removes the case
08:30:36 <nshepperd> hey, that's a cool example
08:30:58 <nkar> bernalex: forM?
08:31:07 <nkar> from Data.Foldable
08:31:14 <bernalex> nkar: hmm. not sure. the monstrosity is: let rb = grf b in  isJust (grf b) && toJSON (srf a (grf b)) == toJSON b && as =^= bs
08:31:24 <bernalex> erm oops
08:31:34 <c_wraith> err, *that'd
08:31:35 <ab9rf> bernalex: there is but i'm trying to remmeber what it is
08:31:39 <bernalex> let rb = grf b in  isJust rb && toJSON (srf a rb) == toJSON b && as =^= bs
08:31:41 <bernalex> that ^
08:31:44 <ab9rf> bernalex: i use it all the time with maybe types
08:31:59 <bernalex> I'm not sure Foldable forM would make it much neater in this case
08:32:53 <nkar> merijn: hi, perhaps you know the answer: "I have a splice that accepts a string.  How can I pass in a variable of the String type?  For example, $(splice "foo") works, \foo -> $(splice foo) doesn't."
08:33:10 <ab9rf> bernalex: a lot of the time that's just fmap
08:33:37 <ab9rf> bernalex: but if you want the interior type and not a maybe that doesn't do what you want
08:34:45 <favetelinguis> have 3 lines of basic code that im to stupid to figure out why filter is not working on, i get a type error, http://lpaste.net/114717
08:34:48 <favetelinguis> what is up with that
08:35:05 <nkar> (going afk but will read the logs in case someone finds the solution)
08:35:12 <mauke> favetelinguis: return type makes no sense
08:35:19 <ab9rf> i don't know what =^= does, but i'd probably write that using fmap (or, actually, <$>)
08:35:30 <mauke> favetelinguis: filter returns a list, not bool
08:35:31 <indiagreen> favetelinguis: filter just removes elements from a list. If you wanted to check whether all elements satisfy the condition, use “all”
08:35:43 <indiagreen> :t all
08:35:44 <lambdabot> (a -> Bool) -> [a] -> Bool
08:35:50 <indiagreen> :t all (/= Nothing)
08:35:51 <lambdabot> Eq a => [Maybe a] -> Bool
08:35:51 <favetelinguis> aa ok, thanks :)
08:43:30 * hackagebot Dao 0.1.0.2 - Dao is meta programming language with its own built-in  interpreted language, designed with artificial  intelligence applications in mind.  http://hackage.haskell.org/package/Dao-0.1.0.2 (RaminHonary)
08:44:22 <Wingsorc> :t all (/= Nothing)
08:44:23 <lambdabot> Eq a => [Maybe a] -> Bool
08:48:12 <newsham> ?type all isNothing
08:48:13 <lambdabot> [Maybe a] -> Bool
08:48:47 <newsham> ?type all (not.isNothing)
08:48:48 <lambdabot> [Maybe a] -> Bool
08:49:09 <newsham> ?check \xs -> all (/= Nothing) xs == all (not.isNothing) xs
08:49:11 <lambdabot>  +++ OK, passed 100 tests.
08:49:26 <indiagreen> newsham: may I suggest “isJust” if you're going to import Data.Maybe anyway
08:49:46 <newsham> ?check \xs -> all (/= Nothing) xs == all isJust xs
08:49:48 <lambdabot>  +++ OK, passed 100 tests.
08:51:11 <indiagreen> also, a slight advantage of “isJust” is that it works on things which can't be compared (e.g. “Maybe (IO ())”), while “/= Nothing” can't
08:51:15 <indiagreen> *doesn't
08:51:35 <newsham> india: thats why I did the ?type above
08:51:51 <newsham> [06:43] < Wingsorc> :t all (/= Nothing)    vs    [06:47] < newsham> ?type all (not.isNothing)
08:52:06 <EvanR> > (0/0) == (0/0)
08:52:08 <lambdabot>  False
08:52:11 <EvanR> > (0/0) /= (0/0)
08:52:13 <lambdabot>  True
08:57:10 <bomb3r> how to repair my openssh ???
08:57:48 <dfeuer> Is there a standard/nice way to get an Applicative "stepper" out of a Foldable?
08:57:51 <mauke> bomb3r: how did you find this channel?
08:58:30 <bomb3r> gettin the list from
09:02:41 <dfeuer> Specifically, I want a State transformer to step through the elements of the Foldable. I don't know if this is possible.
09:04:09 <hcore> Has anyone noticed that the chapter numbering for the website and book versions of "Learn you a haskell for great good" differ?
09:04:30 <dfeuer> hcore, if they differ, I'm confident that someone has noticed
09:05:07 <hcore> Dfeuer, lol of course
09:05:11 <joshc> dfeuer: are you looking for traverse_ ?
09:05:39 <hcore> My real question was does anyone know if the difference is just the chapter numbering or if parts of the web version have changed
09:05:52 <dfeuer> joshc, I don't think so, but I'm pretty ignorant of this stuff. I think what I want is more an inside-out version of that.
09:06:49 <dfeuer> A sort of interruptable/resumable fold.
09:08:03 <newsham> [06:56] < bomb3r> how to repair my openssh ???  <- kind of off topic..  (whats the prob?)
09:25:35 <Jello_Raptor> Okay, my "You don't actually understand this" senses are tingling.
09:25:59 <Jello_Raptor> I'm Trying to write a tranform that will turn my AST into an IR
09:26:38 <Jello_Raptor> and It seems like a state monad is a correct wrapper for it, because I need to do things like generate unique names for things, and keep track of counters.
09:27:04 <Jello_Raptor> So, The plan is to have state be a tuple of (AST,IR,other state)
09:28:39 <Jello_Raptor> and I want to remove an element from the AST, place it into the state "box" perform a bunch of transforms on it, until I can insert it into the IR. While incrementing counters and things that are in "other state"
09:29:03 <simpson> Jello_Raptor: Sure.
09:31:30 <wz1000> Hi! Does anyone know what the status of the cabalized backpack project is?
09:34:26 <Jello_Raptor> simpson: what isn't clicking is how information will get threaded through branching calls. So the "box" has an AST expression like (1 + 2) in it, and then it will call (threading the counters and things through) the function that will transform the "1" into an IR element,and another to transform the "2" before it is able to assemble the IR version of the full "1_+ 2"
09:35:52 <coltfred> Has anyone here used SublimeHaskell before? I followed bitemyapp's install instructions for 7.8.3 and ghc, ghci, etc are working, but I'm getting an error saying "Could not find module `Documentation.Haddock'" -- I did a ghc-pkg check to ensure I had haddock, and I do. There were a few issues about this with ghc 7.6, but I can't seem to find people experiencing this with newish versions of ghc.
09:56:18 <simpson> Jello_Raptor: traverseM, sequenceM, etc. should help you with that. Just decide what order things should go in, and then use that order for traversal.
09:57:47 <bitemyapp> simpson: traverseM? You mean mapM?
09:57:56 <simpson> bitemyapp: Oh, yes, I probably do.
09:58:04 <bitemyapp> @ty sequence
09:58:05 <lambdabot> Monad m => [m a] -> m [a]
09:58:07 <bitemyapp> @ty sequenceM
09:58:08 <lambdabot>     Not in scope: ‘sequenceM’
09:58:08 <lambdabot>     Perhaps you meant one of these:
09:58:08 <lambdabot>       ‘sequence’ (imported from Control.Monad.Writer),
09:58:11 <bitemyapp> @ty sequenceA
09:58:12 <lambdabot>     Not in scope: ‘sequenceA’
09:58:12 <lambdabot>     Perhaps you meant one of these:
09:58:12 <lambdabot>       ‘T.sequenceA’ (imported from Data.Traversable),
09:58:15 <bitemyapp> oh come on.
09:58:18 <bitemyapp> @ty T.sequenceA
09:58:19 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
10:00:40 <wz1000> @src T.sequenceA
10:00:40 <lambdabot> Source not found. Sorry.
10:00:56 <benzrf> wz1000: it's a type class method
10:01:02 <benzrf> wz1000: but
10:01:14 <benzrf> traverse f a = sequenceA (fmap f a)
10:01:20 <benzrf> sequenceA = traverse id
10:01:26 <benzrf> then you may define one or the other
10:01:35 <benzrf> like (==) and (/=)
10:01:45 <wz1000> benzrf: Ah, OK
10:02:54 <benzrf> wz1000: traverse is to sequenceA as mapM is to sequence
10:03:28 <Jello_Raptor> simpson: the issue is less "I don't understand how to do this" and more "I don't understand what this does" , it's analogous to trying to write C without understanding what sort of assembly it's generating. The standard model of x >>= \ c -> ... doesn't seem to map to this operation where you need to enforce the order of state transformations as well as data transforms.
10:03:57 <simpson> Jello_Raptor: The effects (state updates, in this case) happen left-to-right.
10:04:27 <simpson> And descent into the tree is done by recursion, when you recurse.
10:08:13 <lc80> any seasoned haskeller that I could ask for help with monads?
10:08:33 <Jello_Raptor> simpson: I'm basically having trouble de-syntax-sugaring the state monad :/
10:08:45 <k00mi> lc80: it's better to just ask your question instead of asking to ask
10:08:58 <k00mi> you're more likely to get an answer that way
10:09:24 <lc80> k00mi: I am trying to make sense of it, reading tutorials after another, but it's still fuzzy idea for me, so guess will be more than one :P
10:09:35 <simpson> Jello_Raptor: Well, I'm not very good at explaining this, but basically (>>=) on State orders the state updates.
10:10:09 <lc80> I understand it's something allowing to bind and return
10:10:25 <lc80> looked at Monad []
10:10:36 <Haskellfant> have you understood functors and applicative functors?
10:10:53 <lc80> yup
10:11:00 <lc80> functors and applicative are pretty clear
10:11:10 <lc80> but when I compare
10:11:21 <lc80> [1..5] >>= \x -> [(x, x^2)]
10:11:27 <Haskellfant> monad just adds a join operation to that: join :: m (m a) -> m a
10:11:45 <lc80> and
10:11:46 <lc80> map (\x -> (x, x^2)) [1..5]
10:12:22 <lc80> they're pretty much the same, I don't see what makes it "Monad"
10:12:32 <lc80> in that binding example
10:12:47 <lc80> or how to use "return" in case of []
10:13:01 <quchen> concatMap is (flipped) >>= for lists.
10:13:03 <quchen> ?src [] (>>=)
10:13:04 <lambdabot> xs >>= f = concatMap f xs
10:13:12 <Haskellfant> the type of your function on the right is something like Integer -> [(Intege,Integer)]
10:13:14 <quchen> and concatMap f xs = concat (map f xs)
10:13:15 <Haskellfant> *Integer
10:13:48 <Haskellfant> so if you try to map your function over the list you get [[(Integer,Integer)]]
10:14:06 <Haskellfant> all that monads allows you over applicative is to flatten those two nested lists
10:14:11 <lc80> I understand that example here, I've wrotten it ;)
10:14:44 <lc80> but I don't see what's "monadic" in it, it's just normal transformation of list by applying a function over it
10:15:11 <Haskellfant> imagine you have something like [1..5] >>= \x -> [1..x]
10:15:15 <merijn> lc80: I would avoid monad tutorials like the plague
10:15:17 <Haskellfant> how would you write that using fmap?
10:15:35 <Haskellfant> (or normal map if you prefer that)
10:15:45 <merijn> lc80: "monadic" is not something special and this mysterious cult around it is harmful to understanding imo
10:16:11 <lc80> map (\x -> [1..x]) [1..5]
10:16:27 <Haskellfant> lc80: compare the results
10:16:31 <merijn> lc80: Something is monadic IF and ONLY IF it has two operations "(>>=) :: m a -> (a -> m b) -> m b" and "return :: a -> m a"
10:16:36 <Haskellfant> are you sure this is exactly the same?
10:16:37 <merijn> :t (>>=)
10:16:38 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:16:45 <merijn> :t flip concatMap
10:16:46 <lambdabot> [a] -> (a -> [b]) -> [b]
10:16:58 <merijn> lc80: See how those two signatures line up? :)
10:17:00 <lc80> hm, Haskellfant, ok, that's might be a trail
10:17:19 <Haskellfant> lc80: so you see the difference?
10:17:25 <lc80> yup
10:17:44 <lc80> monad is linking it all into single domain
10:17:47 <Haskellfant> join $ fmap (\x -> [1..x]) [1..5] would give you what you want
10:17:50 <merijn> lc80: Alternatively, the other perspective is that monads are "applicative + join"
10:17:53 <merijn> :t join
10:17:54 <lambdabot> Monad m => m (m a) -> m a
10:18:03 <Haskellfant> so it's exactly the join thing that is added
10:18:47 <lc80> merijin, okay, I am starting to see it
10:19:06 <lc80> and that return part is used for joining, right?
10:19:36 <Haskellfant> :t \f x -> join (fmap f x)
10:19:37 <lambdabot> (Functor m, Monad m) => (a1 -> m a) -> m a1 -> m a
10:19:41 <Haskellfant> lc80: no!
10:19:51 <Haskellfant> return is wrapping it up
10:19:58 <Haskellfant> which is pretty much the inverse of what join does
10:20:23 <lc80> hm
10:20:30 <Haskellfant> lc80: return is exactly pure from Applicative
10:20:33 <merijn> lc80: "return == pure"
10:20:50 <Haskellfant> :t return
10:20:50 <lambdabot> Monad m => a -> m a
10:20:51 <Haskellfant> :t join
10:20:52 <lambdabot> Monad m => m (m a) -> m a
10:21:15 <Haskellfant> so for lists: return 1 = [1]
10:21:21 <Haskellfant> for maybe: return 1 = Just 1
10:21:25 <lc80> ok, ok
10:21:28 <Haskellfant> for either: return 1 = Right 1
10:21:43 <davidturner_1> Anybody here know Yitzchak Gale?
10:21:50 <merijn> > join (Just (Just 1))
10:21:51 <lambdabot>  Just 1
10:22:27 <davidturner_1> He's the maintainer of timezone-series and timezone-olson - I'd like to ask for them to be added to Stackage but the email address on Hackage doesn't work
10:23:08 <merijn> davidturner_1: I think he's on here using the nick yitz (not sure!) occasionally
10:23:14 <merijn> Also, I've seen him on r/haskell
10:23:34 * hackagebot eibd-client-simple 0.0.4 - EIBd Client  http://hackage.haskell.org/package/eibd-client-simple-0.0.4 (vapourismo)
10:23:34 <ReinH> Explanations of Monad would benefit greatly by not including the term "wrap"...
10:23:45 <Haskellfant> sry
10:24:10 <merijn> lc80: Have you read Typeclassopedia?
10:24:24 <ReinH> It sort of works for Maybe, but how do you wrap a value in ContT?
10:24:52 <mauke> carefully
10:24:53 <ReinH> or IO, for that matter
10:24:58 <ReinH> mauke: :p
10:25:03 <merijn> ReinH: IO is easy :)
10:25:09 <ReinH> merijn: :p
10:25:11 <merijn> Just use "IO"
10:25:13 <Haskellfant> ReinH: well you sorta nest the type signatures, that's all I meant
10:25:32 <ReinH> Haskellfant: sure, but then people start to think that monads are for "wrapping things"...
10:25:41 <bitemyapp> I was amused when I discovered evaluate uses the IO tuple directly instead of return.
10:25:42 <ReinH> and we end up here, with this "cult of monad" as merijn put it
10:25:47 <lc80> merijin not sure - I've read LYAH, wiki, StackOverflow, then some random pages
10:25:55 <bitemyapp> a -> IO a
10:26:00 <lc80> (like few first from google)
10:26:03 <quchen> ReinH: That's what I do. The only thing that changed since the beginner days is that I'm feeling a bit dirty doing it :-þ
10:26:04 <chrisdone>  i should do some log analysis with ircbrowse's db to count how many instances per day there are of "monads are"
10:26:16 <ReinH> quchen: :p
10:26:21 <bitemyapp> evaluate a = IO $ \s -> seq# a s
10:26:23 <ReinH> chrisdone: indeed
10:26:24 <bitemyapp> like, seriously
10:26:26 <chrisdone> with sub sub-filtering for "about"
10:26:26 <bitemyapp> what
10:26:33 <ReinH> bitemyapp: nice
10:26:36 <quchen> chrisdone: There's this cool website that lets you do that! http://ircbrowse.net/browse/haskell?q=monads+are
10:26:37 <davidturner_1> merijn: Thanks
10:27:00 <bitemyapp> ReinH: it came up because somebody asked on the mailing asked how to force GHC to re-eval thunks without sharing
10:27:18 <chrisdone> quchen: =)
10:27:18 <merijn> lc80: https://www.haskell.org/haskellwiki/Typeclassopedia
10:27:25 <bitemyapp> ReinH: and I was immediately, "Stick it in IO!" then I said, "but how?" so I thought, "I'll use return!" which turned out to be more annoying than I would've liked.
10:27:31 <davidturner_1> oh, *now* I find the Haskell-Cafe emails with his address in them!
10:27:33 <davidturner_1> d'oh
10:27:39 <bitemyapp> ReinH: then I looked at evaluate's implementation and groaned at the cheating.
10:28:04 <merijn> lc80: That link is *far* more comprehensive and in depth then a bunch of random tutorials :)
10:28:19 <merijn> lc80: Plus, it comes with exercises!
10:28:32 <bitemyapp> merijn: NICTA course is a good progression for typeclassopedia material.
10:28:50 <bitemyapp> merijn: https://github.com/NICTA/course/tree/master/src/Course
10:29:01 <Jeena> Hi, I am trying to download some HTML from a https resource (Twitter) with simpleHttp which as far as I understand is suppoesed to be able to handle https resources, but I am getting this error (which I don't get with http resources): <socket: 3>: hPutBuf: illegal operation (handle is closed)
10:29:05 <lc80> thanks, merijin, gonna spent some time there, I guess :)
10:29:17 <lc80> but one more quick question before that ;)
10:29:17 <bitemyapp> merijn: that's why I recommend it as the follow up to cis194 - it firms up the functor/applicative/monad/foldable/traversable/parser combinator, etc. combo.
10:29:23 <chrisdone> how does evaluate a differ to (let !_ = a in return a)
10:29:30 <bitemyapp> lc80: give https://github.com/NICTA/course/ a shot as well.
10:29:44 <mauke> chrisdone: evaluate isn't strict
10:29:55 <lc80> about IO (so maybe I should read typeclassopedia first ;P)
10:30:07 <bitemyapp> lc80: the typeclassopedia won't explain IO per se.
10:30:12 <quchen> chrisdone: Did you read the manual entry of evaluate? http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Exception-Base.html#v:evaluate
10:30:14 <chrisdone> mauke: true
10:30:21 <EvanR> cult of monad
10:30:23 <chrisdone> quchen: a while back and didn't understand a word of it
10:30:25 <bitemyapp> lc80: understanding IO requires understanding laziness.
10:30:39 <bitemyapp> lc80: and why you wouldn't want value-sharing post thunk-eval in some cases.
10:30:43 <merijn> bitemyapp: Sometimes I feel we should put more emphasis on the fact that IO and monads have about 0 in common/to do with each other
10:30:44 <EvanR> sippin kleisliaid
10:30:47 <lc80> x <- getZonedTime
10:30:49 <bitemyapp> merijn: right
10:30:52 <bitemyapp> merijn: just an interface.
10:30:55 <kototama> Hi, any idea how I can change this lens expression to filter after the 'values' call to only get the one where the key "type" is equal to "photo" https://github.com/kototama/screepy/blob/89c728301bcb4a5b23d986e35f15122dc4bf368f/src/Screepy/Twitter.hs#L31 ?
10:30:58 <lc80> where does that syntax come from?
10:31:01 <bitemyapp> lc80: ignore the monad part for now, it's just an interface.
10:31:06 <merijn> lc80: Syntactic sugar
10:31:11 <bitemyapp> lc80: http://www.haskellforall.com/2014/10/how-to-desugar-haskell-code.html
10:31:25 <lc80> merijn and what's the other form for that?
10:31:33 <merijn> lc80: Read this chapter: https://en.wikibooks.org/wiki/Haskell/do_Notation
10:31:42 <EvanR> "how to consider the do notation as a primitive for the purposes of reading IO code"
10:32:04 <supki_> kototama: filtered (elemOf (key "type") "photo")
10:32:05 <EvanR> and >>= as occasional shorthand
10:32:16 <merijn> EvanR: I believe that's the wrong approach
10:32:26 <bitemyapp> EvanR: that's really not how you want to think about it.
10:32:32 <chrisdone> i would like somebody to write a blog post on why evaluate x = (return $! x) >>= return is different to evaluate x = return $! x
10:32:33 <bitemyapp> EvanR: do and <- is just >> and >>=
10:32:38 <merijn> Most people I've talked to that had difficulties with do notation had problems due to not understanding what's going on
10:32:59 <merijn> I strongly recommend all beginners to avoid do notation until they're comfortable writing the equivalent using >> and >>=
10:33:00 <bitemyapp> chrisdone: why?
10:33:02 <jle`> chrisdone: i calculate 2.2 "monads are" per day
10:33:04 <EvanR> bitemyapp: yeah but how does writing out huge nested lambdas help anyone understand *IO*
10:33:05 <chrisdone> hmm, perhaps because (return $! x) is equiv. to (let !_ = a in return a)
10:33:12 <chrisdone> maybe that's why?
10:33:14 <jle`> which is a little lower than i expected
10:33:20 <EvanR> that helps understand monads
10:33:23 <chrisdone> @src ($!)
10:33:23 <lambdabot> f $! x = x `seq` f x
10:33:25 <kototama> supki_: many thanks
10:33:30 <bitemyapp> chrisdone: I didn't argue with you, I just noted that evaluate's impl cheated :)
10:33:33 <chrisdone> hmm, perhaps that's it
10:33:34 <bitemyapp> EvanR: the nested lambdas are besides the point.
10:33:44 <chrisdone> bitemyapp: huh? who said anything about arguing? =)
10:33:47 <bitemyapp> EvanR: the nested lambdas are part of an interface for mapping over an abstract data type
10:33:56 <bitemyapp> EvanR: that's not the purpose for nor essence of IO
10:33:58 <chrisdone> hmmm let me try this
10:33:59 <bitemyapp> EvanR: neither is do syntax.
10:34:03 <EvanR> yeah, so this discussion is about explaining monads, not IO
10:34:05 <bitemyapp> chrisdone: there are better ways to nerd snipe me.
10:34:06 <glguy> chrisdone: the point is that evaluate isn't strict in its argument as a function, only executing that operation will actually force the argument
10:34:11 <bitemyapp> EvanR: he asked about IO.
10:34:15 <random123> Hi, everyone. How would you go about matching the last element in a list?
10:34:16 <merijn> EvanR: You don't "explain monads"
10:34:21 <chrisdone> glguy: right. i think i just epiphanied that
10:34:38 <merijn> random123: You'd have to recurse until you reach the end
10:34:38 <bitemyapp> so I don't need to write anything?
10:34:40 <bitemyapp> good.
10:34:41 <EvanR> "how does IO work" "ok heres how monads work" that seems bad
10:34:43 <chrisdone> thanks mauke and glguy, you helped me grok something i totally did not get last time i tried to get this
10:34:44 <lc80> okay, got some pages to read, hope will be able to feel it, soon :)
10:34:49 <bitemyapp> EvanR: don't talk about monads.
10:34:50 <merijn> random123: Which may infinite loop if the list is infinite
10:34:50 <lc80> thanks for help
10:34:59 <jle`> "how does IO work" => "here is how IO works" (good)
10:35:10 <jle`> "how does IO work" => "blah monads blah" (bad)
10:35:19 <EvanR> >>= notation for IO seems quite obtuse
10:35:25 <EvanR> for more than very simple expressions
10:35:33 <random123> but what i do is matching (x:xs)
10:35:48 <random123> how do i catch the last element instead of catching the tom element [] ?
10:35:52 <bitemyapp> EvanR: don't talk about >>=
10:35:53 <merijn> random123: "(x:[])" <- only matches single element list
10:35:57 <supki_> kototama: sorry, filtered (elemOf (key "type"._String) "photo")
10:35:59 <random123> alright, ty
10:36:00 <bitemyapp> EvanR: >>= and IO are totally orthogonal.
10:36:10 <merijn> random123: You can write arbitrarily nested patterns :)
10:36:12 <EvanR> bitemyapp: me? thats what you guys were discussing, the desugaring of do notation
10:36:15 <chrisdone> so then: evaluate x = do let !_ = x; return x -- would be a valid implementation
10:36:27 <chrisdone> (just to see what using bang would be like)
10:36:35 <bitemyapp> bang bang, he shot me down
10:36:43 <chrisdone> because of the implicit >>=
10:36:46 <chrisdone> oh wait
10:37:02 <bitemyapp> what
10:37:05 <chrisdone> no, that's legit
10:37:11 <kototama> supki_: both compiles
10:37:13 <bitemyapp> what implicit >>=?
10:37:40 <chrisdone> bitemyapp: in do x; y
10:37:42 <EvanR>  
10:38:33 <glguy> chrisdone: do {let decls; stmts}	=	let decls in do {stmts}
10:38:39 <glguy> https://www.haskell.org/onlinereport/exps.html#sect3.14
10:38:39 <random123> merijn: Okay thanks alot!
10:39:06 <chrisdone> glguy: ah, drat
10:39:06 <merijn> random123: "(x:y:z:[])" would match a list of exactly 3 elements, for example
10:39:09 <supki_> kototama: hmm, that's weird, the former shouldn't unless you have some weird IsString Value instance in scope or something
10:39:15 <bitemyapp> chrisdone: non-recursive let in a do block desugars to a lambda.
10:39:37 <chrisdone> glguy: i guess it'd have to be: do !x <- return x; return x
10:39:39 <random123> merijn: okay great to know, thanks!
10:39:51 * chrisdone likes bang patterns a lot
10:40:11 <bitemyapp> chrisdone: hold up
10:40:23 <bitemyapp> chrisdone: you told me there was an implicit >>= before you introduced the <- and I don't think that's the case.
10:40:35 <chrisdone> bitemyapp: yeah see my replies to glguy
10:40:36 <bitraten> hi, what's wrong about this? https://gist.github.com/bitraten/30092f4665acf0852562
10:40:36 <bitemyapp> do let x = y; z   ->   (\x -> z) y
10:40:46 <bitemyapp> sdfksjgerk
10:41:26 <glguy> bitraten: Your function claims to work for ALL Exception types 'e', but only works for the MyEx type
10:42:45 <bitraten> glguy: shouldn't this give a incomplete pattern matching error then?
10:43:07 <glguy> No, patterns can only match on expressions of a single type
10:43:27 <chrisdone> let evaluate x = let !x' = x in return x' in let !_ = evaluate undefined :: State () () in ()
10:43:30 <chrisdone> > let evaluate x = let !x' = x in return x' in let !_ = evaluate undefined :: State () () in ()
10:43:31 <lambdabot>  *Exception: Prelude.undefined
10:43:32 <glguy> If you want a function "ex" that can operate on multiple types you'd need to use a typeclass
10:43:33 <chrisdone> > let evaluate x = do !x <- return x; return x in let !_ = evaluate undefined :: State () () in ()
10:43:34 <lambdabot>  ()
10:43:39 <chrisdone> proof is in the pudding =)
10:44:51 <merijn> bitraten: It won't give incomplete warnings for type errors (and this is a type error)
10:46:12 <bitraten> Okay, thanks.
10:50:06 <chrisdone> bitemyapp: =)
10:53:34 <chrisdone> bitemyapp: do you live in the US?
10:53:57 <chrisdone> we should collab on a haskell learning wiki :3
10:54:22 <bitemyapp> chrisdone: I live in Best-US.
10:54:31 <chrisdone> united states are best states
10:54:39 <bitemyapp> chrisdone: Tex-US is Best-US
10:54:50 <bitemyapp> all hail tex-mex
10:55:36 <bitemyapp> chrisdone: what would this wiki do above and beyond the guide? You know I'm working on the book right?
10:56:22 <chrisdone> bitemyapp: the systematic break down of topics into small pieces that can ask you interactive questions
10:57:10 <bitemyapp> chrisdone: oh yes, socratics.
10:57:16 <chrisdone> s'right
10:57:23 <bitemyapp> chrisdone: the book is exercise driven. socratics could be a fun spin on that.
10:57:49 <chrisdone> hmm
10:58:18 <chrisdone> if i start trying to encode a lesson into such a system, it might be a source of feedback about what's explained clear and what's not
10:58:42 <bitemyapp> chrisdone: system?
10:58:48 <chrisdone> no learn is as stubbornly literal as a computer =)
10:58:57 <chrisdone> yeah, this thing of breaking ideas down into a graph
10:59:09 <rray> anyone got any nice introductory papers to pattern recognitions in big data?
10:59:14 <rray> or something along those lines
10:59:37 <bitemyapp> rray: linalg text is a good place to start
10:59:42 <bitemyapp> rray: then anything with eigen* in the name
10:59:48 <bitemyapp> rray: then statistics, linear regression
10:59:51 <chrisdone> bitemyapp: i'll play with a library for generating questions and answers in haskell and get back to you about it
10:59:58 <bitemyapp> rray: then stuff that begins with "neutral"
11:00:03 <bitemyapp> rray: er, neural*
11:00:11 <bitemyapp> chrisdone: generating questions and answers?
11:00:17 <rray> i see
11:00:29 <bitemyapp> rray: "deep learning", etc. a lot of it is blather.
11:00:34 <chrisdone> bitemyapp: http://www.reddit.com/r/haskell/comments/2mp3fb/learning_haskell_as_a_nonprogrammer/cm6xl85
11:00:39 <bitemyapp> rray: worth looking into what bits are reused in NLP and CV.
11:00:48 <chrisdone> bitemyapp: like that
11:00:56 <bitemyapp> oh dear, weechat breaks links.
11:00:58 <bitemyapp> that's not okay.
11:01:12 <ReinH> weechat :(
11:01:56 <chrisdone> gotta go
11:02:10 <ReinH> chrisdone: o/
11:06:11 <efznt> hi, can someone explain to me why [1,2] >>= \n -> ['a', 'b'] >>= \ch -> return (n, ch) is different from [1,2] >>= (\n -> ['a', 'b']) >>= \ch -> return (n, ch) ?
11:06:16 <L8D> chrisdone: bitemyapp is the one who posted that
11:06:46 <kototama> what is the meaning of the double quotes in
11:06:47 <kototama> makeLenses ''Game
11:06:49 <L8D> efznt: operator precedence
11:06:52 <kototama> (http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html)
11:06:57 <L8D> kototama: Template Haskell
11:07:00 <indiagreen> efznt: the latter one doesn't even work, actually
11:07:13 <L8D> > [1,2] >>= \n -> ['a', 'b'] >>=
11:07:14 <L8D> \ch -> return (n, ch)
11:07:15 <lambdabot>  <hint>:1:31:
11:07:15 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
11:07:16 <L8D> whoops
11:07:18 <indiagreen> you're restricting the scope in which “n” is available
11:07:20 <efznt> Yes, this is what makes me wonder
11:07:24 <L8D> > [1,2] >>= \n -> ['a', 'b'] >>= \ch -> return (n, ch)
11:07:26 <lambdabot>  [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
11:07:28 <indiagreen> > [1,2] >>= (\n -> ['a', 'b']) >>= \ch -> return (n, ch)
11:07:29 <lambdabot>  [(n,'a'),(n,'b'),(n,'a'),(n,'b')]
11:07:33 <L8D> -.-
11:07:39 <indiagreen> [1,2] >>= (\blah -> ['a', 'b']) >>= \ch -> return (blah, ch) ?
11:07:48 <L8D> it's because of operator precedence
11:07:52 <indiagreen> > [1,2] >>= (\blah -> ['a', 'b']) >>= \ch -> return (blah, ch)
11:07:57 <L8D> > [1,2] >>= \n -> (['a', 'b'] >>= \ch -> return (n, ch))
11:07:59 <lambdabot>  [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
11:08:01 <L8D> ^^^^^^
11:08:07 <L8D> efznt: ^
11:09:26 <efznt> okay, but how do i know which operator has higher precedence?
11:09:41 <L8D> -> has one of the highest precedences
11:09:42 <ab9rf> you remember :)
11:09:51 <ab9rf> but yeah, -> is pretty damn high
11:09:53 <merijn> efznt: You can query ghci
11:09:58 <merijn> -> is not an operator
11:10:00 <L8D> >>= is a function whereas \x -> is part of the native syntax
11:10:00 <merijn> It's syntax
11:10:05 <ab9rf> yea, it's syntax
11:10:06 <L8D> ^^^^^
11:10:07 <silasm_> isn't it that n occurs bound in `return (n,ch)' in the first case and free in the second one?
11:10:36 <merijn> efznt: ":i (*)" lists the fixity of an operator (if none is mentioned it's the default, infixl 9)
11:10:49 <efznt> good to know
11:10:51 <efznt> thanks
11:11:12 <merijn> Fun fact, infix applications of functions can have fixity too!
11:11:49 <merijn> If you type ":i elem" you'll see that `elem` has infix 4 :)
11:12:40 <efznt> you are right, but what about >>= ?
11:13:06 <efznt> is it one because it is a function?
11:13:14 <efznt> or it is defined with this level?
11:15:46 <merijn> efznt: Fixity is defined
11:16:25 <merijn> efznt: Someone in the library defining (>>=) wrote "infixl 1 >>="
11:16:41 <merijn> You can define your own fixity for custom operators
11:18:46 <merijn> See for example
11:18:47 <merijn> > let foo = (+); bar = (*); infixl 9 `foo`; infixl 1 `bar` in 1 `foo` 2 `bar` 3
11:18:49 <lambdabot>  9
11:19:16 <merijn> `foo` has higher fixity, thus it gets evaluated as (1 `foo` 2) `bar` 3
11:19:45 <efznt> alright. i get the fixity stuff :D
11:20:19 <efznt> but what about the anonymous functions with ->
11:20:33 <efznt> it was said it is syntax
11:20:49 <efznt> is this the reason it gets highest fixity?
11:20:58 <merijn> It doesn't have high fixity
11:21:08 <merijn> -> just scopes over the entire remaining line
11:21:16 <merijn> (unless there's parenthesis)
11:22:20 <merijn> Note that fixity can range from 0 up to 9, function application has fixity 10 (so always higher than operators!) and record syntax has fixity 11 (so even higher than function application)
11:23:39 <efznt> thank you so much. your last messages solved it for me
11:24:44 <Javran> is there an existing widget layout lib in Haskell? The input would be some width spec for widgets like: [FixedSize 100, Flexible, FixedSize 50], and if you give it a length e.g. 300, it will tell you the width of each widget e.g. [100,150,50] ?
11:26:03 <efznt> "-> just scopes over the entire remaining line" was the missing clue :)
11:26:28 <efznt> thanks again!
11:28:05 <JagaJaga> Hi! How does haskell get what is `a`?
11:28:07 <JagaJaga> fun :: (Num a, Read a) => String -> a
11:28:10 <JagaJaga> fun = read
11:28:39 <JagaJaga> Where does he output it?
11:28:49 <ionum> hi
11:28:52 <ionum> hi
11:29:47 <Ferdirand> it's more like a whole class of functions, one for each possible type a
11:30:20 <ab9rf> JagaJaga: that function is polymorphic.  the compiler will narrow the type each time fun is used, based on how its return type is used elsewhere
11:31:24 <JagaJaga> Ferdirand: ab9rf: I'm writing `fun "2"` and how he get the type of result?
11:31:48 <ab9rf> JagaJaga: it depends on how you use the result of that expression.
11:32:15 <JagaJaga> ab9rf: just typing in ghci
11:32:30 <ab9rf> JagaJaga: if you just type that into ghci you'll get a type error
11:32:36 <ab9rf> > read "2"
11:32:37 <lambdabot>  *Exception: Prelude.read: no parse
11:32:49 <ab9rf> > read "2" :: Int
11:32:49 <Ferdirand> > read "2" :: Int
11:32:50 <lambdabot>  can't find file: L.hs
11:32:50 <lambdabot>  2
11:33:07 <Ferdirand> :)
11:33:12 <ab9rf> > read "2" :: Float
11:33:13 <lambdabot>  2.0
11:33:13 <JagaJaga> ab9rf: fun "2"
11:33:16 <JagaJaga> 2
11:33:49 <JagaJaga> (at ghci)
11:34:48 <supki_> > read "()"
11:34:49 <lambdabot>  ()
11:35:00 <supki_> GHCi (and lambdabot) use extended defaulting rules
11:35:54 <ab9rf> yeah, it seems that the restriction to Num a is enough for read to generate a parse
11:37:02 <JagaJaga> ab9rf: yeah, seems to. thx.
11:37:42 <ab9rf> try fun "2.0" :)
11:38:26 <bitemyapp> chrisdone: Lucid looks nice by the by, but I don't think it addresses the UX concerns I had.
11:38:40 <bitemyapp> chrisdone: that said, if I need something Blaze-y in future, Lucid will be the first place I look.
11:52:10 <hexa> http://www.lapresse.ca/international/asie-oceanie/201411/21/01-4821257-quand-le-chef-de-la-junte-thailandaise-caresse-la-tete-dun-journaliste.php?utm_categorieinterne=trafficdrivers&utm_contenuinterne=cyberpresse_B9_international_29810_accueil_POS3
11:52:11 <hexa> oops
11:52:12 <hexa> !
11:52:21 <hexa> sorry wrong chan
11:53:29 <josiah14> is there a way to take a function "f :: a -> b -> c -> d" and run a function over it so that I get back "g :: b -> c -> a -> d" ?
11:53:36 <josiah14> it's like, a different version of flip
11:54:01 <n4x> :t let f g a b c = g b c a in f
11:54:02 <lambdabot> (t1 -> t2 -> t3 -> t) -> t3 -> t1 -> t2 -> t
11:54:17 <ab9rf> heh
11:54:20 <ajcoppa> @djinn (a -> b -> c -> d) -> (b -> c -> a -> d)
11:54:20 <lambdabot> f a b c d = a d b c
11:54:42 <josephle> :t flip flip
11:54:44 <lambdabot> b -> (a -> b -> c) -> a -> c
11:54:50 <josephle> that's not right
11:54:52 <n4x> :t flip.flip
11:54:53 <lambdabot> (b -> a -> c) -> b -> a -> c
11:55:06 <pharpend> Good morning everyone.
11:55:10 <n4x> the cool version of ($)
11:55:16 <n4x> hi pharpend!
11:55:27 <josephle> hah
11:55:37 <josephle> hmm actually
11:55:42 <josephle> :t flip.(flip.)
11:55:43 <lambdabot> (a -> a1 -> b -> c) -> b -> a -> a1 -> c
11:55:50 <josephle> but you shouldn't use this
11:55:50 <ab9rf> @pl let f g a b c = g c b a in f
11:55:50 <lambdabot> flip . (flip .) . flip
11:56:08 <ab9rf> @pl let f g a b c = g b c a in f
11:56:08 <lambdabot> flip . (flip .)
11:56:23 <ReinH> @. pl djinn (a -> b -> c -> d) -> (b -> c -> a -> d)
11:56:23 <lambdabot> f = (flip .) . flip
11:56:25 <ReinH> if you must
11:56:39 <ab9rf> heh
11:56:59 <josiah14> :t (flip .) . flip
11:57:00 <lambdabot> (a1 -> a -> b -> c) -> a -> b -> a1 -> c
11:57:05 <josephle> it might make sense if your arguments are a stack of pancakes
11:57:09 <ab9rf> people who acyually use things like (flip .).flip are vaguely evil
11:57:15 <josiah14> well
11:57:31 <josiah14> what I want to do is inject the data type at runtime
11:57:32 <josiah14> like
11:57:40 <josiah14> if I makes something like...
11:58:09 <josiah14> data Type = Type { func :: String -> String -> String }
11:58:34 <josiah14> then :t func is func :: Type -> String -> String -> String
11:58:37 * hackagebot stm-queue-extras 0.2.0.0 - Extra queue utilities for STM  http://hackage.haskell.org/package/stm-queue-extras-0.2.0.0 (JonSterling)
11:59:18 <josiah14> but if i want to build out that function and then decide at runtime which instance of Type I want to call func on
11:59:29 <josiah14> I need to reorder the params
12:00:17 <ReinH> josiah14: "which instance of type"?
12:00:36 <ReinH> josiah14: What problem are you trying to solve here?
12:00:59 <josiah14> let type1 = Type { func = a ++ b } ; let type2 Type = { func = b ++ a }
12:01:32 <josiah14> if I curry, then I can determine at runtime whether i want func a b type1 or func a b type2
12:01:45 <josiah14> I could say, func1 = func a b
12:02:06 <josiah14> and then say, if x == 5 then func1 type1 else func1 type2
12:02:12 <josiah14> and get different behavior
12:02:28 <ReinH>  Ok, but what are you using this for?
12:02:56 <josiah14> I'm building a program that stylizes prompts
12:03:08 <josiah14> so the functions are actually common between Zsh, Bash, Fish, etc
12:03:24 <josiah14> but which kind of prompt i build is determined by a cli arg
12:03:39 <questioneer> what has higher precedence? the dot operator or function application?
12:03:42 <ReinH> I'd think that you'd want to keep track of this stuff at runtime
12:03:45 <questioneer> the latter right?
12:03:53 <mauris> yes questioneer
12:03:54 <ReinH> not in an ad hoc way via if/then/else tests
12:03:57 <questioneer> k just making sure
12:04:04 <mauris> function application has the highest precedence, in fact
12:04:07 <ReinH> questioneer: function application has highest precedence
12:04:08 <josiah14> so I want to step into the IO monad, read the cli arg, and delegate the pure flow of the program from there without leaving the monad so that configuration of the prompts can be done declaratively
12:04:28 <ReinH> er, keep track of this stuff in the types
12:04:36 <ab9rf> this feels vaguely like an attempt to reinvent C++-style OOP
12:04:36 <josiah14> right
12:04:49 <josiah14> so I could create a ShellPrompt typeclass that has the methods I expect
12:04:54 <Fuuzetsu> ReinH: except when it doesn't… f x { y = z }
12:04:57 <ReinH> josiah14: can you give me a more concrete example? I'm struggling to see how this machinery would be applied to your problem.
12:05:08 <ReinH> Fuuzetsu: and Module.Namespace, yes
12:05:28 <josiah14> and then I could extend the program to support different prompts by creating data types for each one, and then currying those functions so that I can say, hey, we are building a zsh prompt, use the zsh module's functions
12:05:37 <ReinH> josiah14: I'd like to offer a different way, because this seems like it would be challenging to maintain
12:06:27 <ReinH> You're throwing a way a lot of the expressiveness of the type system if you hae a single data Type = Type { func :: String -> String -> String } type and then reorder it in ad hoc ways based on boolean tests
12:06:32 <ReinH> *have
12:06:44 <mauris> hm. so, i wrote a piece of Haskell code that the rest of the world might actually benefit from
12:06:56 <mauris> prettyTimeDiff (-2189.463) == "36 minutes ago"
12:07:04 <alrunner4> josiah14: it seems like you're halfway there - use a single type as the shared interface, and define a value for each concrete shell type
12:07:31 <ReinH> josiah14: the only real benefit I see to a typeclass is that it is extensible.
12:07:31 <mauris> is it worth getting this kind of tiny thing on hackage? i have no idea what the whole process is like or where to even start
12:07:56 <ReinH> Otherwise, you could just have data PromptFunc = Bash (String -> String -> String) | Zsh (String -> String -> String) ...
12:07:57 <mauris> i imagine there's a strict structure packages must adhere to, and i have to make haddock docs somehow, etc.?
12:08:19 <josiah14> Yah, I guess at the ShellPrompt stage, it would not need to be extensible any more
12:08:47 <josiah14> but at the highest level, I do need a Prompt typeclass, because I might add in TMux status line styling and such down the road
12:09:02 <josiah14> but the way I compose segments I want to remain uniform
12:09:56 <ReinH> josiah14: still, the machinery that applies a function should be typed, rather than ad hoc 4-adic flip combinators...
12:10:37 <ReinH> josiah14: what does the Prompt typeclass do? What are its members?
12:13:23 <josiah14> I guess, though, in the configuration file (which is just plain old haskell), I want to keep things simple by allowing the user to just register the prompts they have installed in the config, and then just naively build out a prompt like bulidPrompt [([bold , fgColor red, bgColor black], workingDirectory), ([bold, fgColor White, bgColor black], repoBranch)]
12:15:21 <josiah14> so I figured, if I curried those functions, I could pass buildPrompt into an exec function (exec $ buildPrompt ...) that would fold over the list of functions, apply the concrete data type to get the right version of bold, or whatever, and then lift that into the type returned by workingDirectory, repoBranch, etc
12:16:17 <Zer000> suppose I have a sequence, like s1, s2, ... sn how do I make a list that looks like this: [[s1, s1, ...], [s2, s1, ...], ..., [sn, s2, ...], [sn, sn, ...]]?
12:16:42 <josiah14> so workingDirectory and repoBranch would return a Functor that I could map String -> String functions over
12:16:52 <josiah14> such as a ShellPrompt segment
12:17:34 <L8D> ok, so now we need an irc client, terminal emulator, and init system written in Haskell
12:18:01 <L8D> volunteers?
12:18:14 <josiah14> well, I'm working on a shell prompt styler
12:18:39 <josiah14> not one of the 3, but still a useful system tool for developers if I can figure out how to build it in a maintainable way
12:18:42 <L8D> yeah chrisdone has already started on a shell
12:18:57 <L8D> and we have an editor and window manager
12:19:04 <Zer000> we have an editor?
12:19:09 <L8D> yes!
12:19:10 <josiah14> I'm building something more akin to PowerShell
12:19:11 <L8D> yi!
12:19:12 <bennofs> yi
12:19:15 <josiah14> rr
12:19:18 <josiah14> Powerline, rather
12:19:20 <bennofs> http://github.com/yi-editor/yi
12:19:36 <josiah14> the one written in Python that is broken on Linux because of a bad C header or something
12:20:35 <Zer000> pretty cool! I'm married to vim though
12:20:46 <L8D> Zer000: yi has vim bindings that are pretty good
12:20:56 <josiah14> yi looks pretty good
12:20:58 <L8D> Zer000: and if there's anything you don't like, it's trivial to add
12:21:08 <Zer000> but plugins
12:21:10 <josiah14> but I'm not good enough with Haskell yet to contribute in a very meaningful way
12:21:27 <L8D> well you don't need to contribute
12:21:41 <josiah14> that's the first thing Yi needs, is an easy way to extend it's behaviour via plugins
12:21:48 <L8D> you can show your support by simply using it and finding bugs or possible features
12:21:54 <Fuuzetsu> woah there
12:21:54 <Fuuzetsu> hello
12:21:57 <L8D> josiah14: it definitely has that
12:21:58 <Fuuzetsu> I heard Yi
12:22:02 <Zer000> you can aparantly extend it with haskell easily. I guess it's like emacs and lisp?
12:22:04 <josiah14> well, I would if I wanted to use it the way I use Vim
12:22:15 <L8D> Zer000: yep, that's the exact purpose of Yi
12:22:27 <josiah14> I would need to add most of TPopes plugins to be productive in Yi
12:22:32 <L8D> Fuuzetsu <-- person who contributes code to yi
12:22:44 <Fuuzetsu> although not in recent couple of weeks ;;
12:22:53 <josiah14> I would love to contribute code to Yi
12:23:06 <josiah14> which is why I'm working exclusively on Haskell in my spare time right now
12:23:11 <Fuuzetsu> and we would love for you to contribute code to Yi, I think we can make something work ;)
12:23:19 <josiah14> want to get the language down so that I can start writing real code
12:23:38 <Jamedjo> @pointful getListOf = fix ((((isEmpty >>=) . flip (flip if' (return []))) .) . flip liftM2 (:))
12:23:38 <lambdabot> getListOf = fix (\ s y -> isEmpty >>= \ d -> if' d (return []) (((:)) >>= \ m -> y >>= \ l -> return (s m l)))
12:23:39 <josiah14> Fuuzetsu: ++
12:23:40 <Fuuzetsu> personally I always tell people to go work on actual projects to learn
12:23:51 <Zer000> TPope wrote Clojure in viml. why not just make it so you can write vim plugins in haskell? Not that writing an editor isn't sweet, but vim is established
12:24:17 <josiah14> well, that's sort of what I'm doing.  I chose something i thought would be somewhat easier - cloning the Powerline project in Haskell - before diving into Yi
12:24:22 <L8D> Zer000: because Haskell doesn't compile to JVM or JavaScript as trivially
12:24:41 <L8D> Zer000: and you don't get nearly as many features
12:24:41 <Jamedjo> @redo getListOf = fix (\ s y -> isEmpty >>= \ d -> if' d (return []) (((:)) >>= \ m -> y >>= \ l -> return (s m l)))
12:24:41 <lambdabot> Maybe you meant: undo todo do
12:24:46 <Fuuzetsu> Zer000: and because in the end it's all on top of viml or whatever
12:24:58 * Fuuzetsu is sick beyond belief with ELisp
12:24:58 <L8D> Zer000: with yi, all of your configuration is done in Haskell
12:25:08 <Jamedjo> @do getListOf = fix (\ s y -> isEmpty >>= \ d -> if' d (return []) (((:)) >>= \ m -> y >>= \ l -> return (s m l)))
12:25:08 <lambdabot> getListOf = fix (\ s y -> do { d <- isEmpty; if' d (return []) (do { m <- ((:)); l <- y; return (s m l)})})
12:25:24 <josiah14> I've not heard a whole lot of good on Elisp besides it's better than VimScript
12:25:56 <Fuuzetsu> then you hear it all
12:25:57 <L8D> the majority of Haskell users develop illnesses when forced to use Lisps
12:26:16 <Fuuzetsu> heard*
12:26:26 <bitemyapp> josiah14: sounds right.
12:26:30 <L8D> and the rest try to write toy lisp dialects with static typing and lazy evaluation
12:26:45 <L8D> and cry when they realize their true fate
12:26:56 <josiah14> I don't find Clojure very painful
12:27:07 <josiah14> I didn't like Common Lisp, though
12:27:10 <L8D> josiah14: then don't continue to learn Haskell!
12:27:20 <josiah14> it wasn't obvious to me when a function would have side effects in that language
12:27:27 <L8D> josiah14: it will spoil your ways!
12:27:44 <josiah14> I would rather know how to program in both languages
12:27:51 <lc80> lisp clones have too many (), $ for the win! ;)
12:27:58 <Zer000> err could someone answer my question though? I am pretty new to hs and I think it can be done with a list comprehension but I don't know how. I will repost: suppose I have a sequence, like s1, s2, ... sn how do I make a list that looks like this: [[s1, s1, ...], [s2, s1, ...], ..., [sn, s2, ...], [sn, sn, ...]]?
12:28:09 <L8D> josiah14: I'm only joking. Just that the more you learn Haskell the more you'll wish Clojure was Haskell
12:28:34 <L8D> josiah14: because most of the difficulties with Haskell is becoming familiar with it instead of day-to-day programming issues
12:28:53 <josiah14> L8D: I see it as a trade-off between typesafety and dynamic type inference at runtime
12:29:03 <n4x> when you learn Haskell, you wish X was Haskell
12:29:10 <saep> Zer000: neovim will allow Haskell plugins at some point in the future.
12:29:33 <josiah14> well, I only really know Ruby, C, and Java truly well at the moment, and I wish all 3 of them were Haskell
12:29:45 <ab9rf> josiah14: that explains so much. :)
12:29:50 <L8D> josiah14: but you end up using core.typed anyway
12:29:53 <k00mi> L8D: you're generalizing vastly, I know quite a few people who prefer clojure over haskell
12:30:15 <L8D> k00mi: and are those people high-level Haskell developers?
12:30:22 <L8D> I mean... derp
12:30:29 <josiah14> I think it depends on when you prefer to do you debugging - at compile time or at runtime
12:30:35 <L8D> k00mi: and have those people built things with Haskell?
12:30:57 <k00mi> and it's not like you have don't have to deal with exactly the same issues in haskell as in other languages when developing actual applications
12:31:04 <angryzor> Zer000: i don't understand what the structure of your target sequence is supposed to be
12:31:04 <k00mi> yes they have
12:31:09 <josiah14> I know a lot of people who would rather have unit tests running in a tmux pane as they code so that they can be alerted when something breaks, rather than have the compiler tell them
12:31:41 <k00mi> L8D: haskell isn't the be-all-end-all you think it is
12:31:52 <L8D> josiah14: how is that different than the compiler running in a tmux pane?
12:32:09 <L8D> k00mi: why not?
12:32:37 <L8D> k00mi: it's very good at a lot more things than it's bad or mediocre at
12:32:43 <josiah14> with the linking, it can take a little longer to compile a change than it might take to just run the relevant unit tests, I guess
12:32:44 <n4x> it isn't perfect
12:33:01 <josiah14> that and I guess, unit testing is pretty (totally?) manual, so you have max control over what you want to check
12:33:26 <n4x> the typesystem doesn't catch all kind of errors
12:33:29 <n4x> tests are still needed
12:33:34 <k00mi> L8D: I'm not saying it's a bad programming language, I'm saying not all issues magically go away if you use haskell
12:33:40 <josiah14> but I'm in the camp of, I'd rather have the compiler decide for me what to check, and then have a unit test suite check the rest that the compiler can't verify for me
12:33:45 <L8D> josiah14: well with Haskell you only run the unit tests once the type checks pass
12:34:24 <josiah14> L8D: yes, I sympathize with that way of doing
12:34:32 <L8D> k00mi: agreed, earlier I meant that in comparison to programming with Clojure
12:34:46 <k00mi> L8D: interface design, async exceptions, exceptions-safety in general, all those things and more are no easier in haskell than in other languages
12:34:56 <pavonia> Zer000: Are you looking for something like the Cartesian product L^n of your initial list L?
12:35:14 <dmj`> k00mi: compare exception safety with C++ and Haskell, case closed
12:35:14 <L8D> the "hurdles" in developeing with Haskell are more to do with familiarity than with developer-made decisions that cause problems
12:35:16 <Zer000> pavonia, yes!
12:35:22 <houshuang> Looking for some help from Haskell experts to come up with a minimally functional data.frame implementation: https://groups.google.com/d/msg/haskell-cafe/81yZPU4RXHE/sMvIMvhOehAJ
12:36:33 <k00mi> dmj`: no, declaring that haskell is better at something than the worst example you can come up with does not make haskell good
12:36:33 <josiah14> L8D: Agreed.  I find that my main hurdle is thinking of types differently than in OO, where the tendancy there is to decide the type at runtime when you want to split paths between program execution based on some external state, like a configuration file or cli args
12:37:06 <merijn> Wait
12:37:09 <josiah14> It's unlearning all of the stupid IoC patterns I was taught in Java and C#
12:37:11 <pavonia> > let cart l = sequence $ replicate (length l) l in cart "abc"
12:37:13 <lambdabot>  ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","bb...
12:37:13 <hugomg> Is it possible to have multiple patterns ins a single clause of a pattern-match
12:37:17 <merijn> Are people implying C++ exception safety is worse than haskell?
12:37:19 <pavonia> Zer000: ^
12:37:34 <k00mi> L8D: I disagree, a lot of the high-level problems are the same in haskell and other languages
12:37:36 <merijn> I'm pretty sure writing exception safe code in C++ is simpler than in haskell
12:37:38 <hugomg> like how in ocaml you can do Foo(x, []) | Foo([], x) -> blax x
12:37:43 <josiah14> hugomg, sort of, you could use the @ operator to hold the whole value plus some pattern
12:38:03 <merijn> hugomg: Depends on what you mean by that?
12:38:21 <josiah14> why not pull blax x into a let variable and then just reuse it for the 2 different patterns?
12:38:23 <vanila> hugomg, you could create a view pattern to simulate that in haskell -- it's more work than ocaml version though
12:38:51 <L8D> i think there's a language extension that let's you do stuff like \(Foo x [])@(Foo [] x) -> ...
12:38:53 <josiah14> let blah x = blax x
12:38:58 <Zer000> pavonia, thank you! what's this 'in' keyword though? It looks like a Python list comprehension without the square brackets almost
12:39:09 <Zer000> I've never seen that before
12:39:11 <merijn> L8D: No, that's not valid haskell with any extension
12:39:12 <angryzor> it's part of the let
12:39:21 <Zer000> oh
12:39:24 <angryzor> let a = 5 in a
12:39:35 <merijn> "let <declarations> in <expression>"
12:39:36 <L8D> merijn: I've seen something like that before
12:39:41 <L8D> maybe I'm thinking of erlang too much
12:39:42 <pavonia> "let ... in e" defines local variables  that can be used in e
12:39:43 <josiah14> let (bindings) in (expresion)
12:39:52 <merijn> L8D: @ lets you alias a name, not specify two different patterns
12:39:55 <dmj`> k00mi: haskell's type safety shines when your code grows. As code base size grows in dynamic languages (even in java/c++) the code begins to own your life and soul, enslaving you, making you unable to perform changes w/ correctness guarantees.
12:39:59 <josiah14> merijn: ++ for getting to it before me
12:40:17 <k00mi> dmj`: the type system knows zero about exceptions
12:40:58 <ab9rf> exceptions in haskell are no cakewalk
12:41:04 <hugomg> this is what I'm thinking: http://lpaste.net/114741
12:41:27 <merijn> Exceptions are hard in any language atm
12:41:36 <ab9rf> merijn: indeed.
12:41:44 <k00mi> rust has a pretty damn good exception story
12:41:46 <dmj`> k00mi: The separation between pure and impure in haskell makes it a moot point. Other languages you don't know what kind of I/O their base libraries do
12:41:55 <josephle> k00mi: you mean no exceptions? ;)
12:41:56 <clrnd> mmm how do they handle exceptions i APL/J?
12:41:57 <Hodapp> Oh, yes, those hypothetical "actual applications" that always make you have to deal with the supposed "same problems"
12:42:19 <merijn> dmj`: How does purity make exceptions a moot point?
12:42:27 <Hodapp> Is that the same thing as the "problems of the real world" that Dijkstra discussed when he said that the problems of the real world are primarily those that you are left with when you refuse to ignore their effective solutions?
12:42:38 <Hodapp> refuse to apply, rather, not refuse to ignore.
12:42:39 <merijn> k00mi: Link to rust's exception handling?
12:42:58 <josephle> I thought rust only had fail! (now panic!)
12:43:06 <k00mi> dmj`: pure code can throw exceptions, and since you have no guarantees when pure code is evaluated you have at least as bad a situation in haskell
12:43:28 <Hijiri> you can be reasonably sure that pure code won't throw sync exceptions though
12:43:34 <k00mi> merijn: http://lucumr.pocoo.org/2014/11/6/error-handling-in-rust/
12:43:40 <Hijiri> it's not a good thing if a library has pure code that can throw exceptions
12:43:59 <merijn> k00mi: Thanks
12:44:03 <ab9rf> there's always "out of memory" and "unexpected machine error"
12:44:30 <Hijiri> that's why I qualified with "sync" exceptions
12:44:34 <merijn> This is all irrelevant since you still have no way to check you handle all exceptions in IO
12:44:35 <k00mi> merijn: basically they have only Either and no actual exceptions, but some sugar to make dealing with multiple exception types easier
12:44:37 <dmj`> merijn: It's moot because it's easily identifiable and can be handled. Not so in other code-bases. Gotta keep em' separated and total
12:44:56 <merijn> dmj`: oh? How is it easily identified?
12:44:58 <josephle> hmm, I still think Errors in Rust != exceptions
12:45:07 <dmj`> merijn: the I/O monad?
12:45:15 <Hijiri> I'd say it's easier to identify code where exceptions could pop up in languages where you can annotate that
12:45:20 <merijn> dmj`: How does that let you track whether you handle exceptions?
12:45:39 <Hijiri> well, it can be easier
12:45:43 <merijn> I've spent hours auditing my haskell code for async exception safety and the only thing to come out of it was "Control.Exception is broken", see the long thread on libraries@
12:45:45 <merijn> Hijiri: It's not
12:46:05 <Hijiri> oh
12:46:05 <merijn> Hijiri: Networking/concurrent code has IO everywhere, haskell is utterly unhelpful in auditing for exception safety
12:46:13 <Hijiri> I meant other languages
12:46:19 <dmj`> merijn: it doesn't? You're responsible for exception handling, I'm saying it's easier to know where exceptions can occur because of the I/O separation. If your pure code is throwing exceptions then you are doing some illegal pattern matching or using lazy I/O
12:46:21 <merijn> The only solution I've found is "audit the entire code path through all libraries"
12:46:39 <merijn> dmj`: No, that's not what I'm saying
12:46:55 <merijn> dmj`: "foo :: IO a" <- quick, tell me which exceptions I have to handle
12:47:02 <ab9rf> the problem with most code is that most code spends most of its time dealing with the Big Bad World, from which exceptions spawn with prodiguous frequency
12:47:06 <Hijiri> merijn: that's what I was saying
12:47:23 <merijn> At least in C++ I have noexcept
12:47:26 <Hijiri> other languages you can annotate exceptions, I was saying that exception handling is easier to figure out there
12:48:01 <k00mi> :t throw
12:48:02 <lambdabot> Exception e => e -> a
12:48:06 <k00mi> dmj`: ^
12:48:10 <merijn> k00mi: throw is unreliable
12:48:12 <Hijiri> if you use throw you are bad
12:48:23 <merijn> k00mi: throw won't throw until forced
12:48:33 <k00mi> merijn: I know, that's my point
12:48:36 <merijn> I'm not to worried about throw
12:48:38 <ab9rf> yeah, it's throw... sometime.  or not!
12:48:40 <dmj`> merijn: that's up to you to identify based on the libraries you're using...? What I'm saying is that the fact there is I/O is a big hint that an exception can occur there.
12:48:46 <k00mi> that and that it can be used in pure code
12:48:52 <merijn> dmj`: None of haskell's ecosystem documents that
12:49:02 <merijn> dmj`: The only way I have found is read *all* the source
12:49:14 <k00mi> dmj`: a lot of real code has IO everywhere
12:49:19 <merijn> dmj`: 80% of my library is IO, since I do networking
12:49:26 <Zer000> what does sequence do?
12:49:26 <Hijiri> What would be neat is a separate IO type parameterized by an open union of exception types, which you could handle progressively
12:49:34 <dmj`> merijn: you should be able to understand what possibilities of error are possible based on the kind of I/O you are doing, disk / network, etc.
12:49:40 <merijn> dmj`: So 80% of my code has "exception can occur here" and there's no way to audit it
12:49:54 <merijn> dmj`: Right, in other words, haskell is useless in helping me with exception safety
12:49:59 <Hijiri> and there could be an "unsafeRunExceptionalCode" IO r a -> IO a or something, when you don't care about having exceptions outside of it
12:50:06 <merijn> If I need to *know*, then haskell is clearly not helping
12:50:23 <merijn> The compiler should check!
12:50:45 <dmj`> the type system is helpess yes, but the purity shows you where it can happen. f :: Int -> Int -> Int, if total tells you an exception probably won't occur
12:50:53 <Zer000> "Evaluate each action in the sequence from left to right, and collect the results." - I don't understand how a list of lists is a list of actions
12:51:01 <k00mi> "probably won't occur"
12:51:06 <k00mi> that's a great guarantee
12:51:13 <merijn> dmj`: Right, which doesn't help at all in all the real code I've written
12:51:27 <merijn> Also, division by zero, etc. are all thrown in pure code
12:51:36 <Hijiri> I read about extensible effects, could you do something similar with exception handling?
12:51:39 <k00mi> and even if it is, it doesn't help me make my IO code (the largest part of many codebases) exception safe
12:51:45 <merijn> I like haskell, but saying it helps you with exception safety is silly
12:51:52 <dmj`> merijn: it's still a better story than imperative langs
12:51:57 <dmj`> purity helps you identify exceptions yes
12:51:57 <merijn> dmj`: I disagree
12:52:01 <hugomg> I need to test if a string matches a regular expression. Its a really simple regex with no captures or fancy features. What do I use? https://www.haskell.org/haskellwiki/Regular_expressions lists too many options!
12:52:05 <dmj`> merijn: then don't use haskell?
12:52:08 <merijn> dmj`: C++ is much more helpful in identifying exceptions
12:52:25 <dmj`> merijn: what about the C++ type system helps you do that?
12:52:36 <merijn> dmj`: noexcept guarantees no exceptions being thrown
12:52:42 <chaosmasttter> Zer000: you could probably view a list as an nondeterministic action, which could return all of the elements of the list
12:52:52 <ab9rf> hugomg: why are you using a regular expression?
12:53:11 <dmj`> merijn: since C++11
12:53:12 <merijn> dmj`: What kind of troll remark is that "if you don't like how haskell does X don't use haskell"? Why would I not discuss "the way haskell does X sucks, let's improve it"?
12:53:15 <Kaidelong> well haskell is supposed to do that by default, the problem is that the original prelude used exceptions to handle cases like "tail" in pure code
12:53:25 <k00mi> hugomg: regex-pcre is good
12:53:27 <dmj`> merijn: are you just looking for an argument?
12:53:37 <dmj`> merijn: because I'm not looking for that
12:53:37 <Kaidelong> rather than saving exceptions in pure code for truly exceptional cases
12:53:52 <ab9rf> the fact that head and tail are not total is a pita.
12:53:59 <hugomg> ab9rf: Its less error prone to write out [+-]?[A-Za-z][A-Za-z_0-9]* than to try to rewrite it as a state machine
12:53:59 <merijn> dmj`: No, I'm saying that we should acknowledge that haskell sucks for exception safety and that we should improve that
12:54:12 <merijn> dmj`: You directly contradict my claim that haskell is bad at exception safety
12:54:22 <Kaidelong> not sure how it sucks other than that exceptions can happen in pure code
12:54:23 <ab9rf> hugomg: just write itas a parsec recognizer.
12:54:31 <Kaidelong> but used correctly, that feature wouldn't be so bad
12:54:42 <merijn> Kaidelong: Unchecked exceptions make it impossible to guarantee you handle errors
12:54:50 <k00mi> Kaidelong: there are *zero* guarantees about exceptions anywhere
12:54:54 <Kaidelong> haskell does have checked exceptions though
12:54:57 <dmj`> I'm saying purity helps you identify where exceptions can occur, not that the type system enforces it... It's still up to you. I think we're arguing different things?
12:54:59 <hugomg> eh, I'm not really trying ot parse anything though - regexes are perfect for what I need
12:55:07 <merijn> dmj`: I'm not interested in arguments, I'm interested in getting the community to acknowledge there's a problem as first step to improving things
12:55:07 <Kaidelong> that's what ExceptT does
12:55:16 <hugomg> I mean, I just care if it matches or not, I dont extract anyt values
12:55:23 <Kaidelong> like Java and other implangs, it also has unchecked exceptions
12:55:35 <yukko> I still don't really understand what exceptions give that just using types (Either Error, Maybe, etc) doesn't
12:55:43 <merijn> Kaidelong: Except none of the important libraries like filesystem/network use ExceptT
12:55:50 <k00mi> Kaidelong: no, that does not guarantee an exception won't be thrown anyway
12:56:02 <yukko> someone mentioned a few things to me the last time I brought it up but it wasn't made clear to me at all what the point was
12:56:27 <merijn> dmj`: Right, and me and k00mi disagree with your premise that purity helps :) Anyway we've reached a point of fundamental disagreement
12:56:36 <Kaidelong> merijn: that's more a problem with the libraries than the language itself
12:57:04 <merijn> Kaidelong: The fact that libraries *can* hide this stuff is one of the fundamental warts of haskell, imo
12:57:20 <vanila> http://existentialtype.wordpress.com/2012/08/14/haskell-is-exceptionally-unsafe/
12:57:21 <k00mi> yukko: they are more flexible and having to use transformers everywhere is a pain
12:57:33 <Kaidelong> there are some cases where you do want unchecked exceptions
12:57:36 <Kaidelong> IE running out of memory
12:57:47 <Kaidelong> but I am willing to bet the vast bulk of the use of "error" has nothing to do with that
12:58:07 <vanila> imo haskell shouldnt have exceptions that pure code throws and that impure code catches
12:58:13 <merijn> btw, someone mentioned extensible effects, I've been looking for an intro to those if anyone has pointers
12:58:35 <merijn> (by intro I mean "intro to implementing them for my vaporware language")
12:58:36 <k00mi> vanila: that doesn't make it easier to write exception safe IO
12:58:42 <yukko> Kaidelong I don't really think you need to put that sort of failure mode into Haskell's model of how computers work
12:58:48 <Hodapp> oh, lovely, Dr. Harper's flamebait blog
12:58:54 <vanila> monad "fail" was added really early, im not sure if anyone has managed to remove it yet
12:59:07 <dmj`> merijn: so ((+) :: Int -> Int -> Int), (getBytes :: Handle -> IO ByteString), which do you thinkhas a higher likelihood of throwing an exception?
12:59:13 <dmj`> think has*
12:59:33 <dmj`> if you say it's equal then yes we have a disagreement
12:59:37 <Kaidelong> vanila: to be fair they had a pretty good reason for adding it; partial pattern matches in "do" notation wouldn't make much sense without it
12:59:37 <vanila> k00mi, one could use EitherT IO or find some other solution - exceptions don't fit nicely in haskell
12:59:43 <merijn> dmj`: (+) has a strong implication about what it does
12:59:49 <dmj`> as most things in haskell
12:59:55 <yukko> dmj` there's no such thing as a "liklihood of throwing an exception"
12:59:55 <merijn> dmj`: What if I change it to "div :: Int -> Int -> Int" ?
12:59:58 <yukko> it either can or can't
13:00:05 <Kaidelong> however I think haskell's pattern matching system might be something that could be totally reworked for a future language
13:00:14 <n4x> if it said something like "getBytes ∷ Handle → IO {EOF,..} ByteString" it would be easier
13:00:15 <Kaidelong> patterns are not first class, for example
13:00:27 <bitemyapp> lenses pls
13:00:27 <vanila> first class patterns? interesting idea
13:00:33 <merijn> Kaidelong: First class patterns don't seem all that valuable?
13:00:35 <bitemyapp> lenses are first class patterns.
13:00:41 <bitemyapp> but better!
13:00:45 <merijn> No extensible effects papers? :\
13:00:54 <bitemyapp> merijn: I thought there was.
13:00:57 <k00mi> vanila: I agree, but that's not what the vast majority of libraries (even base) do and it's not very flexible
13:00:59 <Hodapp> first class patterns?
13:01:13 <merijn> bitemyapp: There;s tons, I'm asking for educated pointers on learning about extensible effects
13:01:26 <merijn> bitemyapp: Asking people is generally more useful in terms of results than google
13:01:30 <Kaidelong> merijn: you can think of them as a subset of -> that is guaranteed to terminate where it is defined so being able to use them where you expect a -> would be nice
13:01:35 <Kaidelong> well unless you allow for view patterns
13:01:49 <ReinH> merijn: I assume you've read *the8 extensible effects paper?
13:01:52 <ReinH> *the*
13:01:52 <silasm_> merijn: you can look at Idris; afaict ext effs haven't gotten that far in Haskell. In Idris they're used more than Monad Transformers are.
13:01:56 <Kaidelong> but those are in a sense first class because they're made out of regular functions
13:02:04 <bitemyapp> merijn: http://okmij.org/ftp/Haskell/extensible/ http://www.cs.indiana.edu/~sabry/papers/exteff.pdf https://ocharles.org.uk/blog/posts/2013-12-04-24-days-of-hackage-extensible-effects.html http://ro-che.info/articles/2014-06-14-extensible-effects-failed
13:02:09 <bitemyapp> merijn: https://hackage.haskell.org/package/extensible-effects
13:02:09 <merijn> silasm_: I don't care about use, I care about theory and implementation
13:02:12 <merijn> bitemyapp: Thanks
13:02:17 <Ralith> silasm_: I don't know that enough Idris code is written for "used more than X" to be a meaningful statement
13:02:43 <dmj`> merijn: ok sure, div, dividing by 0 is one case an exception can occur. Network I/O has a ton of different failure scenarios.
13:02:50 <bitemyapp> merijn: extensible-effects is initial encoding, layers/mtl are final encoding
13:02:58 <bitemyapp> merijn: http://ezyang.tumblr.com/post/62065229179/haskell-extensible-effects-an-alternative-to-monad
13:03:06 <silasm_> Ralith: well the use and writing of Monad Transformers in Idris is _actively discouraged_.
13:03:18 <bitemyapp> merijn: http://jozefg.bitbucket.org/posts/2014-07-15-reading-extensible-effects.html
13:03:36 <bitemyapp> merijn: also, they're kinda slow.
13:03:44 <merijn> I don't know what initial/final means :)
13:03:56 <Ralith> silasm_: yes, in large part because we want to find out if they work well in practice, and that won't happen if nobody tries :P
13:04:00 <bitemyapp> merijn: initial = datatype, final = interface
13:04:09 <bitemyapp> merijn: datatype means: representation rigid, interpretation flexible.
13:04:27 <bitemyapp> merijn: interface means: representation flexible, interpretation rigid. Cf. "expression problem" (Wadler)
13:04:41 <merijn> bitemyapp: Anyway, thanks for the links, I need to get back to work ;)
13:04:43 <bitemyapp> merijn: escape hatch? Tagless final, sort.a
13:05:03 <Kaidelong> so many of harper's blog posts seem to consist of him shooting himself in the foot, and then complaining it's possible
13:05:08 <ab9rf> heh
13:05:18 <ab9rf> someone buy him some chainmail socks
13:05:27 <bitemyapp> Kaidelong: I should write shitty code in SML and then complain about SML.
13:05:41 <bitemyapp> nobody does that because nobody writes SML
13:05:44 <Kaidelong> even though he's doing stuff that you practically never have to do, where the documentation says never do this
13:05:46 * bitemyapp ba dum tish
13:06:01 <vanila> keep in mind that Bob Harper wrote The Definition of Standard ML
13:06:15 <vanila> it's likely he understands haskell etc. just as well as we do, if not better
13:06:20 <Kaidelong> like unsafePerformIO on things that aren't pure or custom Typeable instances
13:06:44 <Kaidelong> yes but he doesn't seem to understand that haskell is more like C++ in this regard than it is like SML
13:06:53 <Kaidelong> and the people who use it don't really care about these things
13:07:10 <Kaidelong> you're able to shoot yourself in the foot, but it's so easy not to it's better to have the power available when you need it
13:07:11 <ReinH> merijn: this is a nice, quick example of initial/final encodings that also sneaks in a bit of denotational design: https://creativelad.wordpress.com/2013/11/28/final-encodings-part-1-a-quick-demonstration/
13:07:32 <vanila> Kaidelong, that's a good point I notice that a lot actualy, I seem to care more about "purity" that most haskell programmers
13:08:05 <pablo|> I think i broke GHC
13:08:05 <Kaidelong> the inconsistency problems with haskell almost never rear their head in actual code
13:08:12 <pablo|> "Could not deduce (((x ++ y) ++ leftover) ~ (x ++ (y ++ leftover)) from the context (((x ++ y) ++ leftover) ~ (x ++ (y ++ leftover)))"
13:08:22 <ReinH> vanila: I always get a laugh when Haskellers try to be condescending to Bob Harper...
13:08:30 <vanila> that's because people carefully write code that doesn't break, or fix bugs when they show up
13:08:33 <ReinH> "Oh, he just doesn't *get it*."
13:08:46 <Kaidelong> vanila: is it really that hard though?
13:08:48 <merijn> Harper gets it, he's just trolling because he's mad SML lost
13:09:08 <cousteau> !help
13:09:11 <ReinH> merijn: He makes a lot of valid points.
13:09:22 <cousteau> bot, identify yourself!  I summon thee!
13:09:23 <bitemyapp> merijn: being angry because Nirvana became popular instead of the Meatpuppets, as I heard one person put it.
13:09:24 <Kaidelong> do you find yourself carefully considering how haskell does type coercion or how unsafeperformIO and seq are being used?
13:09:27 <vanila> Kaidelong, we'd have to look at specific examples but certainly its not hard! - it's more that there's an argument against making it possible at all
13:09:35 <ReinH> Non-strictness *does* pose problems, for instance. We just like them more than the problems posed by strictness.
13:09:36 <bitemyapp> ReinH: he made a lot of invalid points too.
13:09:36 <Kaidelong> I tend to just trust that things like "vector" are implemented correctly
13:09:41 <bitemyapp> ReinH: so how do we sift through it all?
13:09:47 <merijn> ReinH: Sure, but he also loves trolling people :)
13:09:48 <vanila> if something is protected at the language level (e.g. type safety) you can't even write code that isn't type safe
13:09:53 <ReinH> bitemyapp: Apparently the ansewr is "ignore him and hope he goes away"...
13:09:55 <bitemyapp> some of his points were off by enough to imply bad faith.
13:09:57 <vanila> and that applies to many more properties than well typedness
13:10:12 <bitemyapp> ReinH: you want to send him an email? I've tried pinging him via twitter.
13:10:16 <Kaidelong> vanila: all this remains true of haskell so long as you don't do certain things, though
13:10:19 <ReinH> bitemyapp: I totally don't :D
13:10:24 <Kaidelong> like making your own instances of Typeable
13:10:25 <bitemyapp> see?
13:10:34 <ReinH> I am happy for Bob Harper to keep on Bob Harpering. It doesn't affect me.
13:10:40 <Kaidelong> you have to make a concious effort to try and break that
13:10:48 <cousteau> Hey, I'm reading Learn You A Haskell, the part in which it tells you not to do [0.1,0.3..1], so I of course did it.  Why does it end in 1.0999…?
13:10:50 <Kaidelong> it's not something you're going to do by accident
13:11:01 <merijn> Kaidelong: You can't any more
13:11:03 <ReinH> Kaidelong: where certain things includes, say, "Using GADTs" ;)
13:11:13 <k00mi> I think it's funny how a lot of haskellers react exactly the same way proponents of imperative languages do if you show them a way to shoot yourself in the foot with their favorite language
13:11:17 <merijn> Kaidelong: You can't define custom Typeable classes in GHC
13:11:26 <cousteau> I understand that it suddenly stops displaying numbers "correctly" (0.8999… instead of 0.9), but why does it do this?
13:11:26 <k00mi> namely, "well don't do *that*, dumbass"
13:11:39 <Kaidelong> the things that can introduce that document that they're unsafe without a further proof obligations (IE lub)
13:11:45 <ReinH> > [0.1,0.3..1]
13:11:46 <lambdabot>  [0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]
13:11:59 <Kaidelong> ReinH: Really? GADTs can break type safety?
13:12:07 <Kaidelong> like a specific employment or pattern of them?
13:12:11 <yukko> I really don't like Typeable
13:12:14 <Kaidelong> I haven't played with them much
13:12:43 <ReinH> Kaidelong: e.g., http://joyoftypes.blogspot.com/2012/08/generalizednewtypederiving-is.html
13:13:12 <JonReed> cousteau:  From learn you ah askell "Because they are not completely precise (by definition), their use in ranges can yield some pretty funky results."
13:13:16 <cousteau> k00mi, so I should forget about that for now and keep learning until I'll eventually understand what's wrong?
13:13:35 <ReinH> I'm not sure what the state of GeneratlizedNewtypeDeriving is as of 7.8 or 7.10, though
13:13:57 <ReinH> cousteau: The answer is more or less, "floating point numbers are stupid"
13:14:00 <yukko> it's a really important part of strong static type systems that types don't exist at runtime, so being able to make runtime decisions based on the type of the arguments you get is a really bad idea I think
13:14:01 <cousteau> JonReed, but this isn't a problem of "slight lack of precision"; it went 0.0999 past the limit!
13:14:03 <ReinH> You won't learn much by investigating it
13:14:24 <Kaidelong> ReinH: looks like that's more a problem with GeneralizedNewtypeDeriving
13:14:34 <ReinH> Kaidelong: yes, but it's exposed by GADTs
13:14:34 <Kaidelong> which is worse for me because I regularly use that extension
13:14:37 <Kaidelong> not so much the other two
13:14:55 <Kaidelong> (library code could have the other two)
13:14:57 <ReinH> Kaidelong: also GADTs take away some of the nice mathematical properties of Hask
13:15:25 <ReinH> e.g., "every polymorphic function is a natural transformation" isn't true with GADTs, or so I have been told.
13:15:26 <k00mi> cousteau: my comment was not in response to your question, just try not to become irrationally attached to haskell (or any other language for that matter)
13:15:27 <Kaidelong> I have to admit I've never really worked with GADTs
13:15:41 <Kaidelong> or type families
13:15:48 <cousteau> k00mi, ok :)  wasn't sure it was directed to me or not
13:15:50 <merijn> <3 GADTs
13:15:54 <Kaidelong> the most hairy extension I've had to work with has been FunctionalDependencies
13:15:58 <ReinH> GADTs are nice though
13:15:59 <sivteck> ReinH, <https://skillsmatter.com/skillscasts/5296-safe-zero-cost-coercions-in-haskell> i haven't seen it though.
13:16:03 <ReinH> I'm not saying "don't use them"
13:16:04 <cousteau> k00mi, although it kinda fit
13:16:08 <yukko> type families are really fun
13:16:21 <JonReed> What would be an ideomatic way do this in haskell [a1, a2, a3, a4, a5, a6 ..] -> [ (a1, a2), (a3, a4), (a5, a6) ...]
13:16:23 <Kaidelong> well you certainly shouldn't use them if you don't need the extra expressive power
13:16:30 <ReinH> sivteck: nice, thanks
13:16:32 <yukko> you can use them to do computation inside the type system
13:16:51 <ReinH> JonReed: what do you want to do with an odd-length list?
13:16:55 <vanila> Does anyone have a reference for the thing about GADTs? I'd like to read up on that
13:17:04 <Kaidelong> JonReed: there isn't one, really, so just write it out recursively
13:17:06 <ReinH> vanila: which thing?
13:17:13 <k00mi> cousteau: hehe yes, although floating point numbers have the same quirks in every language ;-)
13:17:21 <Kaidelong> @hoogle Int -> [a] -> [[a]]
13:17:24 <lambdabot> Prelude drop :: Int -> [a] -> [a]
13:17:24 <lambdabot> Data.List drop :: Int -> [a] -> [a]
13:17:24 <lambdabot> Prelude take :: Int -> [a] -> [a]
13:17:26 <vanila> what properties they break and/or the naturality thing you said
13:17:29 <ReinH> Kaidelong: but the obvious solution is partial...
13:17:41 <cousteau> k00mi, that's why I asked this; I wouldn't have expected this behavior in any language
13:17:42 <ReinH> vanila: My source is "edwardk told me" :(
13:17:48 <merijn> vanila: GADTs by themselves don't break things
13:17:51 <vanila> okay
13:17:58 <vanila> JonReed, pairs (x : y : zs) = (x, y) : pairs zs ; pairs _ = []
13:18:10 <merijn> GeneralizedNewtypeDeriving/coercion breaks things in the presence of GADTs
13:18:31 <cousteau> I'd understand that it went a bit over 1 (e.g. 1.00000001) even though I asked it to stop at 1 due to rounding errors, but damn, it almost reached 1.1!
13:18:31 <Kaidelong> JonReed: I am a bit curious why you need this function and not the more common pairwise or sliding window functions
13:18:56 <JonReed> Rein: I just wanted to write a quick shortcut to generate a Data.Map from a string "key, value, another key, another value", so that I would then play with it in ghci
13:18:57 <merijn> But I hardly use GeneralizedNewtypeDeriving anyway
13:19:00 <vanila> ReinH, (But of course they break some properties that ADTs have, just like how fields break some properties algebraic structures that only use equality have)
13:19:07 <crobbins> JonReed: here's something that's bound to fail
13:19:08 <crobbins> > map (\[x,y] -> (x,y)) $ chunksOf 2 [1..10]
13:19:10 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10)]
13:19:23 <Kaidelong> I don't think the haskell prelude has those either
13:19:32 <vanila> it doesn't mean they're less mathematically sound, just they dont fit into the particular scheme of data types we're used to
13:19:36 <ReinH> > map (\[x,y] -> (x,y)) $ chunksOf 2 [1..11]
13:19:38 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10),*Exception: <interactive>:3:6-20: Non-exhaus...
13:19:40 <ReinH> womp womp
13:19:49 <vanila> > let pairs (x : y : zs) = (x, y) : pairs zs ; pairs _ = [] in pairs "foobars"
13:19:51 <lambdabot>  [('f','o'),('o','b'),('a','r')]
13:19:53 <ReinH> Thus the "what do you want to do with an odd-length list?" question
13:20:06 <alrunner4> @src Double enumFromThenTo
13:20:06 <lambdabot> Source not found. I feel much better now.
13:20:12 <Kaidelong> an F# prelude for haskell would be nice, really
13:20:17 <ReinH> vanila: that's probably the best option
13:20:23 <merijn> bitemyapp: I think extensible effects isn't what I want after all
13:20:30 <crobbins> nice vanila
13:20:32 <bitemyapp> merijn: I'm not surprised.
13:20:33 <ReinH> JonReed: The question I would ask is "how did you get a list of [key, value, key, value] anyway?
13:20:56 <merijn> bitemyapp: That's merely "encoding effects in types", I was planning to more have a separate type system for effects kind of deal :)
13:20:57 <yukko> you could also use Either with vanila's solution to indicate whether it dropped some elements at the end (ie, with an odd list)
13:21:04 <JonReed> ReinH: splitOn ", " "key, value, another key, another value"
13:21:20 <Jello_Raptor> is there some way to do multi case pattern matching is a do block? I want to have something like "(a:as) <- doathing" in a do block without forgoing the [] case
13:21:22 <merijn> bitemyapp: I guess the underlying idea is similar, but without cluttering up the "semantic" type of  a value
13:21:31 <vanila> > let pairs (x : y : zs) = Left (x, y) : pairs zs ; pairs [r] = Right r ; pairs [] = [] in pairs "yukko"
13:21:32 <lambdabot>  Couldn't match expected type ‘[Data.Either.Either (b2, b2) b1]’
13:21:32 <lambdabot>              with actual type ‘Data.Either.Either a0 b2’
13:21:32 <lambdabot>  Relevant bindings include
13:21:32 <lambdabot>    r :: b2 (bound at <interactive>:1:58)
13:21:32 <lambdabot>    pairs :: [b2] -> [Data.Either.Either (b2, b2) b1]
13:21:39 <vanila> > let pairs (x : y : zs) = Left (x, y) : pairs zs ; pairs [r] = [Right r] ; pairs [] = [] in pairs "yukko"
13:21:40 <lambdabot>  [Left ('y','u'),Left ('k','k'),Right 'o']
13:21:41 <ReinH> yukko: or use a tuple for the leftover
13:21:42 <vanila> nice idea yukko
13:22:07 <ReinH> vanila: I'd prefer ([(k,v)],Maybe k)
13:23:26 <k00mi> merijn: did you have a look at rust error handling? I'm curious what your impression is
13:23:33 <k00mi> (in #haskell-blah, maybe)
13:24:29 <gbarboza>  /w 2
13:28:11 <wctaiwan> Say I have a list of MVars x::[MVar ()], if I do putMVar (head x) (), does that put () in the first element in the list? or does it create a copy of the first element and put () in it without modifying the list?
13:28:26 <cousteau> interesting, there's "floating" and "fractional".  I'd have expected fractions ot exist in a language like this, but I didn't expect 1.1 to be a fraction
13:28:40 <ReinH> > let go (xs,₎ [x,y] = ((x,y):xs,Nothing); go (xs,₎ [x] = (xs,Just x); go (xs,y) [] = (xs,y) in foldl go ([],Nothing) (chunksOf 2 "hello")
13:28:41 <lambdabot>  <hint>:1:12: lexical error at character '\8334'
13:28:48 <ReinH> Uh.
13:30:02 <ReinH> Oh. I had latexify on. Woops.
13:30:05 <ReinH> > let go (xs,_) [x,y] = ((x,y):xs,Nothing); go (xs,_) [x] = (xs,Just x); go (xs,y) [] = (xs,y) in foldl go ([],Nothing) (chunksOf 2 "hello")
13:30:06 <lambdabot>  ([('l','l'),('h','e')],Just 'o')
13:30:38 <Jello_Raptor> Is there a better way to do this http://hastebin.com/oputulepuc.hs ?
13:31:42 <Jello_Raptor> It's something I do a lot, and frankly I'm quite tired of having to create those accessor functions.
13:31:59 <ReinH> > let go [x,y] (xs,z) = ((x,y):xs,z); go [x] (xs,_) = (xs,Just x); go [] (xs,y) = (xs,y) in foldr go ([],Nothing) (chunksOf 2 "hello")
13:32:00 <lambdabot>  ([('h','e'),('l','l')],Just 'o')
13:33:53 <ReinH> Jello_Raptor: you could make TransformState polymorphic and a Functor: data TransformStateF a = TransformStateF Program Int a deriving (Functor); liftAST = fmap
13:34:33 <ReinH> Jello_Raptor: or more generally you could create lenses.
13:34:42 <ReinH> Or have template Haskell create them for you
13:35:05 <Jello_Raptor> ReinH: huh, would that still work if i want similar accessors for all those fields?
13:35:13 <Jello_Raptor> to be honest I don't exactly understand lenses
13:35:25 <ReinH> data TransformerState = TransformerState { _ast :: P.Program, _ir :: Program, _counter :: Int }; makeLenses 'TransformerState; liftAST = over ast
13:36:10 <ReinH> liftIR = over ir; liftCounter = over counter
13:36:12 <Jello_Raptor> ReinH: what library would I use to do that?
13:36:17 <ReinH> Control.Lens
13:36:22 <ReinH> @hackage lens
13:36:22 <lambdabot> http://hackage.haskell.org/package/lens
13:36:43 <mauris> lens should come with a little warning label saying "warning: the rabbit hole goes deeeeeeeep"
13:36:50 <ab9rf> heh
13:37:09 <ReinH> It does. Burried somewhere within the rabbit hole.
13:37:21 <ab9rf> in a locked cabinet behind a stuffed jaguar.
13:37:41 <mauris> did anyone ever write that "basic-lens" library that would make the type signatures more sane?
13:37:56 <edwardk> mauris: there are plenty of them, they just aren't very useful
13:38:44 <mauris> probably useful for beginners though!
13:38:53 <titusg> I have got all sorts of problems with haskell-mode, anybody good at diagnosing that kind of thing?
13:39:14 <titusg> I switched to cabal-repl and now have elisp errors...
13:39:16 <mauris> (i remember similar ideas being thrown around for Prelude in the past, like the whole map/fmap thing preventing confusing error messages)
13:40:08 <merijn> mauris: There were tons of lens libraries before lens
13:40:22 <merijn> Most of them with simpler, but less useful type signatures
13:40:44 <edwardk> i'd argue all of them were simpler =)
13:40:52 <Kaidelong> is the modern lens actually still a coalgebra on the costate comonad?
13:41:09 <edwardk> Kaidelong: the 'costate comonad coalgebra' way to view a lens turns out to be sort of an evolutionary dead-end
13:41:30 <vanila> edwardk, do GADTs break polymorphic function -> natural transform? or some other mathematical properties?
13:42:20 <edwardk> vanila: parametricity is not naturality. its both stronger and weaker. in the absence of GADTs its stronger: you automatically get both fmap f . eta = eta . fmap f   AND contramap f . eta = eta . contramap f -- without even knowing the functor / contravariant instances
13:42:33 <k00mi> mauris: have a look at lens-family
13:42:37 <Kaidelong> I actually can't find the lens type synonym right now
13:42:48 <edwardk> vanila: in the presence of GADTs you don't get that, but then one might argue that it is impossible to write a 'true' Functor for such a GADT
13:43:06 <edwardk> type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
13:43:42 <edwardk> now that Lens definition is actually the costate definition in disguise
13:43:45 <edwardk> if you flip it
13:43:53 <edwardk> s -> forall f. Functor f => (a -> f b) -> f t
13:44:02 <edwardk> then that right hand side can be balled up in a newtype
13:44:12 <edwardk> that newtype turns out to be equivalent to the store comonad
13:44:20 <edwardk> (its indexed here)
13:44:42 <edwardk> which is kind of a neat result, but if you stop and rest on your laurels then you don't get to see how deep the rabbit hole goes
13:45:05 <edwardk> we have prisms in lens, and they are in some sense 'dual' to the notion of a lens (technically they aren't which i'll talk about in a bit)
13:45:47 <edwardk> but whereas a Lens' s a  looks at part of a product type, e.g. there exists some c for which s <-> (c,a)   is an isomorphism
13:45:52 <ReinH> vanila: there it is :)
13:46:13 <edwardk> we can build a construction that looks at part of a sum type, e.g. there exists some c. for which s <-> Either c a is an isomorphism
13:46:20 <edwardk> this is what gives rise to the notion of a prism
13:46:30 <edwardk> and at first you kinda think 'oh prism and lens are dual'
13:46:42 <edwardk> but in practice they are actually _both_ the same thing under a sufficiently generalized notion of a lens
13:47:36 <edwardk> along the way when working on lens one of the things i found was that the nicest way to talk about an isomorphism was through upgrading the (->)'s on either side of the main (->) in the lens signature to an arbitrary profunctors
13:47:58 <edwardk> type Iso s t a b = forall p f. (Profunctor p, Functor f) => p a (f b) -> p s (f t)
13:48:08 <edwardk> this is what permitted the definition of the prisms:
13:48:27 <edwardk> type Prism s t a b = forall p f. (Choice p, Applicative f) => p a (f b) -> p s (f t)
13:48:47 <edwardk> when p = (->) you get a traversal, so prisms cleanly downgrade to traversals, and lenses also cleanly downgrade to traversals
13:48:58 <edwardk> but that looks quite different at first from the notion of a lens
13:49:04 <ReinH> (I've always liked to read those with -+> instead of p
13:49:13 <edwardk> but if we instead remove the 'Applicative' part here
13:49:17 <edwardk> we could still define prism
13:49:19 <ReinH> (a -+> f b) -> (s -+> f t)
13:49:27 <edwardk> type Prism s t a b = forall p. Choice p => p a b -> p s t -- much cleaner
13:49:31 <edwardk> and Iso
13:49:38 <edwardk> type Iso s t a b = forall p. Profunctor p => p a b -> p s t
13:49:52 <edwardk> and there is a notion of 'strength' for a profunctor assigned to (,) we call 'Strong':
13:50:03 <edwardk> type Lens s t a b = forall p. Strong p => p a b -> p s t
13:50:18 <edwardk> and there are generalizations of the notion of a traversal, etc. that fit this notion
13:50:25 <edwardk> under this encoding the 'f' is gone
13:50:31 <edwardk> and there isn't a comonad in sight
13:51:19 <ReinH> Ah. (a ⇸ f b). Nice.
13:51:23 <edwardk> better still, Choice and Strong can be defined to be different versions of the same idea. they are 'this profunctor respects the tensor of the monoidal category in a nice way'   Strong is with regards to product and Choice is with respect to coproduct.
13:51:44 <edwardk> But _this_ notion has the benefit that it generalizes to completely different categories, with unrelated tensors that aren't either products, or coproducts
13:52:27 <hvr> edwardk: ping
13:52:30 <edwardk> for example, we can look at the category of endofunctors over Hask. you know "monads are monoids in the category of endofunctors", the monoidal tensor in that category folks use is functor composition.
13:52:47 <edwardk> hvr: heya, mid rant =)
13:52:55 <hvr> edwardk: ok, I'll wait =)
13:52:58 <hvr> rant on!
13:53:49 <edwardk> in that world we can define a notion of a Lens for "Compose", that lens lets you look at any sub-segment of a stack of functors you have composed.
13:54:23 <edwardk> so if you have a State s, that decomposes into two functors (->) s  and (,) s -- and you can literally focus in on the reader part and do stuff with it
13:54:46 <edwardk> but that seems to indicate we can focus in on part of a transformer stack or something, which is a bit wrong here
13:54:54 <edwardk> here we're just talking about Reader s and State s as Functors.
13:55:02 <edwardk> but we can go further down the rabbit hole
13:55:09 <edwardk> and find a notion of a lens into a monad transformer stack
13:55:18 <edwardk> monads don't compose, we know that
13:55:22 <edwardk> but monad transformers do.
13:55:46 <edwardk> if you have transformers s   and t, and a base monad m, then "s (t m)" is a monad.
13:56:17 <edwardk> so we can build a category of monad transformers, where the arrows are 'monad transformer homomorphisms', e.g. (forall m a. Monad m => s m a -> t m a)
13:56:43 <edwardk> e.g. the arrows can be things like 'embed ReaderT s actions into StateT s actions'
13:57:03 <edwardk> and then a natural tensor arises, like how composition nests functors, we can nest transformers newtype Tensor s t m a = Tensor (s (t m) a)
13:57:15 <hughfdjackson> :) morning all
13:57:16 <edwardk> and that tensor is associative, has a unit (IdentityT), etc.
13:57:19 <edwardk> and we can talk about lenses for it
13:57:27 <edwardk> those lenses let us focus in on any part of a monad transformer stack
13:57:53 <hughfdjackson> i was wondering if anyone knew of an abstraction for playing a recursive call step-by-step, even if the function isn't tail recursive
13:57:55 <edwardk> which means you can write code concretely to a particular monad transformer instantiation. ReaderT MyEnv IO Int -- and then run it inside something big and scary
13:58:16 <edwardk> anyways, that sort of thing is what i mean by saying that the costate comonad coalgebra view is a dead end
13:58:16 <hughfdjackson> i'm trying to 'step through' evaluation of a lambda calculus expression, but my current implementation is recursive..
13:58:25 <edwardk> you can't even get to the 'how do i dualize this' stage off of it
13:58:26 <vanila> hughfdjackson, good morning
13:58:30 <edwardk> it doesn't bootstrap
13:58:49 <edwardk> on the other hand the profunctor viewpoint lets us find all these generalizations of the underlying notion of a lens
13:58:56 <edwardk> and they all share exactly the same laws
13:59:04 <edwardk> almost all the exotic types in lens have the same set of laws
13:59:08 <edwardk> that is kind of amazing to me
13:59:09 <hughfdjackson> (https://github.com/hughfdjackson/abattoir/blob/master/src/Lambda.hs#L44-L51 <- this is function in question)
13:59:18 <hughfdjackson> vanila: :D hey
13:59:24 <edwardk> Kaidelong: sorry for the long winded ranty reply to a very innocent question =)
13:59:46 <edwardk> Kaidelong: but i figured it warranted a slightly more detailed explanation
13:59:57 <edwardk> hvr: ok, you got me. whats up?
13:59:58 <vanila> hughfdjackson, could try to make it monadic:   evalWithEnv :: Env -> Expr -> m Expr
14:00:16 <vanila> when m is writen monad, you could log each lambda expression as it gets executed
14:00:30 <vanila> you'd change let into a monadic bind <-
14:00:45 <hughfdjackson> vanila: I could do that with the write monad.. and i thought of doing it
14:01:01 <hughfdjackson> but that doesn't let me pause
14:01:15 <vanila> ah well if you want pausing too, then it's simple a change of monad
14:01:36 <vanila> you would replace Writer with some new monad that supports pause/resume
14:01:41 <hughfdjackson> :) if that's the case, then I think i need to have another bash at it - i failed at doing just that on the way home
14:01:59 <vanila> I would first try to make a pause/resume monad on its own separate from the lambda calculus
14:02:20 <vanila> i've seen one posted here recently based on continuations
14:04:10 <angryzor> as a haskell newbie:
14:04:30 <angryzor> what kind of advantage is there to such an approach?
14:04:55 <angryzor> in another language i would make the recursion explicit using a DFS
14:06:42 <hughfdjackson> angryzor: not DFS the sofa company, i imagine ;)
14:07:14 <angryzor> i mean i would keep the nodes in an explicit stack
14:08:56 <hughfdjackson> that could also work
14:09:18 <hughfdjackson> ;) i was hoping for some 'wrap some constructors around what you have already and call runRecurse on it' sorta solution
14:09:46 <hughfdjackson> :D we shall see what ends up happening
14:09:50 <angryzor> oh ok :p
14:10:57 <ReinH> edwardk: when can I expect to start using your monad transformer lens machinery thanks
14:11:18 <edwardk> ReinH: its tied to a bunch of hask'isms you need generalized profunctors.
14:11:44 <ReinH> Don't bore me with details ;)
14:14:57 <merijn> edwardk: So, am I correct in understanding that codensity transform is a generalised form of the DList approach to lists?
14:17:19 <edwardk> merijn: it is _exactly_ that!
14:17:30 <edwardk> if you 'curry' functor composition you get Ran
14:17:43 <merijn> Now I just need to read this paper 15 billion more times to remember it...
14:17:57 <edwardk> (Compose f g ~> h)    is isomorphic to   (f ~> Ran g h)
14:18:45 <edwardk> if you look at 'join' under a sufficiently nice lens you see join :: Compose m m ~> m -- so if you 'curry it' you get 'm ~> Ran m m'
14:18:53 <edwardk> this is the embedding of a monad m into Codensity m.
14:18:58 <edwardk> this is why that always works
14:19:03 <ReinH> edwardk: there it is.
14:19:05 <edwardk> and why 'Codensity' is a monad transformer
14:19:06 <ReinH> Nice.
14:19:28 <edwardk> otherwise Codensity at first blush looks like it has nothing to do with monads
14:19:44 <edwardk> but if you play with function composition, "Endo m" is always a monad even when m is not.
14:19:56 <edwardk> mappend can be viewed as the embedding of m into "Endo m"
14:20:02 <ReinH> merijn: this paper? http://www.cs.ox.ac.uk/ralf.hinze/Kan.pdf
14:20:11 <edwardk> mappend :: m -> Endo m -- obviously i'm throwing in newtypes where they don't exist
14:20:17 <merijn> ReinH: http://www.janis-voigtlaender.eu/papers/AsymptoticImprovementOfComputationsOverFreeMonads.pdf
14:20:33 <ReinH> merijn: Oh. Try the one I linked. It's awesome.
14:20:39 <merijn> edwardk: I don't know what Ran is
14:20:42 <edwardk> so mappend is the embedding of m into the larger space of mappings m^m. m^m is big enough and set up in a nice way, where it is always a monoid.
14:20:50 <ReinH> merijn: you will if you read the paper I linked! ;)
14:20:57 <edwardk> newtype Ran f g a = Ran (forall r. (a -> f r) -> g r)
14:21:06 <edwardk> its Codensity with the 'f' split in two.
14:21:18 <merijn> Lost me :)
14:21:33 <edwardk> lets just go play with monoids for a bit
14:21:38 <edwardk> and then we can come back to functors
14:22:00 <edwardk> so given any monoid, mappend takes m -> m -> m -- parenthesize that and you get m -> (m -> m)
14:22:03 <edwardk> the right hand side is Endo
14:22:13 <merijn> Right
14:22:17 <edwardk> so if m = [a] we have [a] -> ([a] -> [a])
14:22:22 <edwardk> this is where difference lists come from
14:22:25 <ReinH> edwardk: (which also helps make sense of "Yoneda is a right Kan extension along identity")
14:22:42 <edwardk> and the right hand side ha the property that 'its always a monoid', even when m isn't
14:23:06 <edwardk> Endo m is just a monoid, borrowing from the assocativity of function composition, and that id is a unit for it
14:23:13 <merijn> right
14:23:13 <edwardk> ReinH: yep
14:23:33 <ReinH> choose Identity for f and you get Yoneda
14:23:54 <edwardk> a mathematician things of the multiplication of a monoid as going from (m*m) -> m
14:24:01 <edwardk> but we go from m -> (m -> m) here
14:24:06 <edwardk> we've already 'curried it'
14:24:12 <edwardk> into the embedding into difference-monoid form
14:24:45 <ReinH> edwardk: this is a monoid action, right?
14:24:50 <edwardk> but we can take functor composition and show that (Compose f g ~> h) is isomorphic to (f ~> Ran g h) in that type above
14:24:57 <apriori> hello guys, I got a question about haskell -> C (via FFI). I won't to create a function pointer to a haskell function, which C code can call
14:25:14 <edwardk> ReinH: yeah that is viewing m as a left-action on itself as a set.
14:25:20 <apriori> now I stumbled over Foreign.Ptr.FunPtr, but its description is .. cryptic for me
14:25:25 <merijn> apriori: WHy a function pointer instead of a function?
14:25:44 <merijn> apriori: You can export functions directly to C
14:26:01 <apriori> merijn: that function pointer is used in a C++-functor object
14:26:02 <edwardk> anyway through that same power of reasoning we use to curry/uncurry, we can curry/uncurry functor composition, and get Ran/Codensity
14:26:18 <merijn> edwardk: ok, so mappend is a function from a monoid element to a difference monoid (i.e. Endo)
14:26:24 <edwardk> yep
14:26:24 <ReinH> edwardk: this requires internal homs, i.e. a CCC, right?
14:26:41 <edwardk> ReinH: yes
14:26:43 <merijn> apriori: Export a function and on the C side take the address of it?
14:26:51 <edwardk> we're basically using the fact that we're in a closed monoidal category
14:26:51 <apriori> merijn: yes
14:27:00 <ReinH> so fast and loose
14:27:04 <merijn> apriori: I mean, that's much cheaper than using FunPtr
14:27:15 <edwardk> (,) is the tensor, and (->) is the internal hom.
14:27:28 <ReinH> yep
14:27:31 <apriori> merijn: well, I got what you mean, but I'd prefer it to be a bit more dynamic
14:27:47 <apriori> merijn: also, things are a bit more complicated
14:27:47 <merijn> apriori: Note that creating FunPtr's is really expensive in haskell
14:27:57 <apriori> merijn: actually what I do, is:
14:27:58 <ReinH> edwardk: and the tensor/hom adjunction
14:28:01 <edwardk> yep
14:28:14 <merijn> edwardk: I'm not quite sure how Compose/Ran/Codensity fit into this picture, though
14:28:18 <lcf80> what's quickest way to get just hour in current time zone?
14:28:19 <edwardk> curry/uncurry in a sufficiently general reading are just the two halves of that adjunction
14:28:40 <edwardk> merijn: a monoid object in a category is defined with respect to a tensor for the monoidal category.
14:28:47 <edwardk> a monoidal category is just a normal category equipped with an extra bifunctor
14:28:53 <edwardk> Hask is usually equipped with (,)
14:28:58 <edwardk> that bifunctor has some nice properties
14:29:08 <edwardk> it is associative ((a,b),c) ~ (a,(b,c))
14:29:15 <edwardk> we can move back and forth there
14:29:20 <apriori> I've a C library binding to a C++-library (function minimization of functions of arbitrary arity) and want to use that in haskell.. in facts, its an algorithm working on a C++ functor object and evaluating a given function at a lot of points to find a minimum
14:29:28 <edwardk> and it has got a unit, () here
14:29:36 <merijn> edwardk: My CT knowledge is insufficient to follow :)
14:29:45 <merijn> I'll go back to meditating on this
14:30:01 <apriori> from haskell I feed that library with the specifications of the function (parameters to be altered and which are fix).. and want to provide it with a C pointer to the haskell function
14:30:04 <edwardk> and we can reassociate from (((a,b),c),d)   -> (a,(b,(c,d))) the two different paths and get the same answer
14:30:22 <edwardk> merijn: i'm trying to wind it down to the very concrete example of (,) and ()
14:30:31 <merijn> edwardk: Thanks :)
14:30:46 <edwardk> so above we have the easy ability to associate nested products
14:30:52 <edwardk> and to put in and take out ()'s
14:30:59 <merijn> yeah
14:31:01 <edwardk> (a,()) ~ a ~ ((),a)
14:31:12 <ReinH> (up to bottoms)
14:31:19 <Peaker> Lifted products :-(((
14:31:47 <Peaker> One of the design decisions I dislike most... Seq class and unlifted products would make Haskell that much nicer
14:31:54 <bitemyapp> ReinH: /nick ReinHarper
14:32:03 <ReinH> bitemyapp: :p
14:32:11 <bitemyapp> too good to ignore
14:32:13 <edwardk> and for (a,(b,(c,d)) there are two paths to (((a,b),c),d) that both commute based on the order you shuffle things around
14:32:27 <edwardk> add the obvious unit laws and you get a 'tensor for a monoidal categoyr'
14:32:37 <edwardk> which is just a category C equipped with a bifunctor with all those properties
14:32:43 <edwardk> here its haskell with (,)
14:32:55 <edwardk> on the other hand we can define a tensor for hask using Either and Void.
14:33:00 <merijn> I don't know what a tensor is
14:33:08 <edwardk> EIther a (Either b c) ~ Either (Either a b) c
14:33:13 <edwardk> 'its just a bifunctor with all that crap'
14:34:02 <edwardk> you can associate it, it has a unit, it satisfies that funny condition that it doesn't care how you go from (a,(b,(c,d))) -> (((a,b),c),d) you get the same answer
14:34:13 <merijn> right
14:34:17 <edwardk> that last thing is mac lane's 'pentagonal coherence condition' to invoke scary words
14:34:19 <edwardk> but its just that
14:34:30 <edwardk> Either satisfies all those laws when used with Void
14:34:43 <edwardk> in the category of endofunctors, Compose also satisfies all those conditions with Identity
14:34:51 <edwardk> Compose Identity f ~ f ~ Compose f Identity
14:35:05 <ReinH> Compose (Compose f g) h ~ Compose f (Compose g h), etc
14:35:05 <edwardk> Compose f (Compose g h) ~ Compose (Compose f g) h
14:35:09 <edwardk> yep
14:35:12 <ReinH> I WIN
14:35:36 <edwardk> these are all possible 'tensors' for monoidal categories
14:36:03 <edwardk> usually folks just talk about the category as being monoidal, but then hask equipped with Either becomes a different category than hask equipped with (,)
14:36:07 <edwardk> and we need to work with both at the same time
14:36:37 <edwardk> so i choose the 'category equipped with a monoidal tensor' vocabulary rather than just calling hask a monoidal category and making you guess which product i mean
14:36:48 <edwardk> now, we can define the notion of a monoid for any 'monoidal category'
14:37:27 <edwardk> or in the above parlance a 'category equipped with a monoidal tensor'  e.g. Hask with (,)   or Hask with Either   or [ Hask, Hask ] with Compose
14:37:39 <edwardk> for Haskell we usually use the Monoid class
14:37:51 <benzrf> oh boy is somebody learning about the magic of generalized monoids 8D
14:37:51 <edwardk> class Monoid m where mappend :: m -> m -> m; mempty :: m
14:37:54 <edwardk> but lets mangle this
14:37:54 <merijn> I don't get the [Hask, Hask] one?
14:38:02 <edwardk> that is 'the category of endofunctors over hask'
14:38:07 <edwardk> Hask^Hask
14:38:08 <merijn> benzrf: I'm not sure I'm learning yet :p
14:38:13 <ReinH> merijn: [C,D] is a way of saying "the category of functors C -> D"
14:38:20 <merijn> Right
14:38:29 <benzrf> merijn: it's not so bad
14:38:32 <merijn> At some point I should really continue Awodey
14:38:45 <benzrf> merijn: ok that's a lie
14:39:03 <benzrf> merijn: i had a hard enough time with a whiteboard in front of me to help
14:39:07 <ReinH> merijn: Yeah... or try Mac Lane and then come back to Awodey...
14:39:19 <ReinH> drawing out diagrams is hugely helpful though
14:39:20 <merijn> Mac Lane was even uselessser than Awodey
14:39:44 <ReinH> merijn: but Awodey does a pretty good job of explaining things in Mac Lane, so you can use Mac Lane as a forcing function to read Awodey
14:39:54 <ReinH> merijn: then you can use Awodey as a forcing function to read Lawvere ;)
14:40:12 <edwardk> ok,
14:40:16 <edwardk> so back to the trick at hand
14:40:23 <edwardk> lets take apart Monoid and make the API unusable
14:40:37 <edwardk> class Monoid m where mappend :: (m,m) -> m; mempty :: () -> m
14:40:46 <edwardk> now we're looking at it like a mathematician
14:40:50 <merijn> Right
14:41:08 <edwardk> we have some mu :: m*m -> m   and some eta :: 1 -> m
14:41:23 <edwardk> * here is the 'tensor' for our category
14:41:31 <edwardk> and we want Monoid to satisfy the obvious laws
14:41:59 <ReinH> (and 1 is a terminal object...)
14:42:03 <edwardk> in this case
14:42:13 <edwardk> but it matters more that 1 is the unit for (,)
14:42:23 <edwardk> eta :: e -> m
14:42:24 <edwardk> would be better
14:42:40 <benzrf> edwardk: >not using ⊗
14:43:09 <edwardk> so we talk about (Hask,*,e)  and we're working with a Monoid m   so we have mu :: m*m -> m   and eta :: e -> m
14:43:24 <edwardk> now the notions of a monoid you know and love fit this
14:43:32 <edwardk> but we can also talk about 'monoids' for Either. Void is one
14:43:43 <edwardk> mu :: Either Void Void -> Void     and eta :: Void -> Void -- both are definable
14:43:58 <edwardk> its a dumb monoid, but its a monoid.
14:44:23 <edwardk> and we can talk about monoids for 'Compose'   mu :: Compose m m ~> m     eta :: Identity ~> m
14:44:40 <edwardk> mu is 'join'    and eta is 'return'  sufficiently disguised
14:44:46 <merijn> Right
14:45:00 <merijn> That's the whole monoid in category of endofunctors nonsense
14:45:04 <edwardk> yep
14:45:13 <edwardk> but its not nonsense, its directly implementable as code
14:45:38 <edwardk> http://hackage.haskell.org/package/hask-0/docs/src/Hask-Tensor-Compose.html#Monad =)
14:45:41 <edwardk> see the bottom few lines
14:45:45 <ReinH> edwardk: what is ~>?
14:45:48 <merijn> But I'm not quite sure how this all relates back to Codensity :)
14:45:53 <edwardk> ~> there is 'natural transformation'
14:45:58 <edwardk> i'm working back up to that
14:46:02 <ReinH> merijn: this is the equipment we need to discuss kan extensions :)
14:46:12 <ReinH> which is what we need to discuss codensity
14:46:22 <edwardk> Endo m is the 'difference monoid' over m.
14:46:40 <edwardk> its made out of the internal hom, and 'currying' mappend.
14:47:00 <ReinH> (This is also why Foldable can use Endo to implement foldr and foldl from foldMap)
14:47:17 <edwardk> If we do the same thing to the definition of join, and 'curry' it, we get the embedding of a monad m into its codensity monad Ran m m ~ Codensity m
14:47:18 <ReinH> (you need a monoid for foldMap. Endo gives you one "for free")
14:47:53 <ReinH> sorry, that was a bad time to interrupt
14:48:03 <ReinH> edwardk: can you explain the Ran thing again? I didn't quite follow that.
14:48:10 <edwardk> sure
14:48:20 <ReinH> How do you get from m -> Endo m?
14:48:35 <merijn> A homfunctor was just a functor that mapped the entire category to itself, right? Or what?
14:49:31 <edwardk> "Hom_C: C^op * C -> Set" is the 'set of arrows' for a category C. it says you tell me the objects and i'll give you the set of arrows for those objects.
14:49:46 <edwardk> in 'enriched' category theory we start talking about Hom's that live somewhere other than C.
14:49:50 <edwardk> er than Set
14:50:02 <edwardk> a particularly interesting case of Hom arises when you consider Set itself.
14:50:05 <edwardk> it gets to cheat
14:50:06 <edwardk> right?
14:50:14 <edwardk> Hom_Set : Set^op * Set -> Set
14:50:16 <merijn> <- completely lost
14:50:19 <edwardk> its 'arrows live in itself'
14:50:22 <ReinH> heh
14:50:39 <edwardk> the set of arrows between any two objects for the category of sets is itself a set in set.
14:50:41 <merijn> Twisty maze of morphisms all alike :)
14:50:41 <ReinH> merijn: No worries, I am only vaguely not lost and I've been through this before
14:50:48 <ReinH> merijn: go north
14:50:56 <edwardk> this is a really nice property to have
14:51:05 <merijn> ReinH: Eaten by monoid homomorphism :(
14:51:07 <edwardk> because it means you can sort of self-describe a lot of stuff
14:52:03 <edwardk> there are categories where they have something that acts like Hom but which lives internally to the category "Hom_C :: C^op * C -> C"
14:52:11 <edwardk> we say those categories have an 'internal hom'
14:52:18 <edwardk> this lets them talk about arrows as objects in their own right
14:52:24 <edwardk> build up application, etc.
14:52:37 <edwardk> 'closed categories' fall into this framework
14:52:45 <merijn> edwardk: I'm too lost to follow this hom talk
14:52:55 <ReinH> edwardk: Maybe it would be good to explain the intuition for Cᵒp * C here
14:53:01 <edwardk> a 'closed monoidal category' is one where you have a tensor (something that acts like (,))  and an internal hom, something that acts like (->)
14:53:14 <edwardk> merijn: we can rewind a bit
14:53:17 <edwardk> one sec
14:53:23 <ReinH> er, Cᵒᵖ * C
14:53:24 <edwardk> too many distractions built up in the meantime
14:53:24 <merijn> ReinH: I don't even know what C^op * C is, so I doubt an intuition for it helps :)
14:55:33 <edwardk> merijn: you know what (->) is right? =)
14:55:44 <edwardk> you know that (->) is contravariant in its first argument?
14:55:57 <merijn> In haskell or in the more general morphism sense?
14:56:06 <merijn> (Well, the answer is yes to both, but still)
14:56:14 <edwardk> just in haskell
14:56:16 <edwardk> lets focus there
14:56:30 <edwardk> ok, so (->) is contravariant in its first argument, and covariant in the second one
14:56:43 <edwardk> one way to think of it is as a 'functor' from Hask^op * Hask -> Hask
14:56:54 <edwardk> a functor from Hask^op -> Hask is a contravariant functor
14:57:13 <edwardk> contramap :: Contravariant f => (a -> b) -> f b -> f a
14:57:39 <benzrf> a contravariant endofunctor, even
14:57:52 <merijn> C^op was C with flipped morphisms, right?
14:57:56 <edwardk> when we talk about a category we have a 'set of objects' and a 'set of arrows', and for every arrow we know the source object and target object, for every object there exists an arrow that has it as its source and target, etc.
14:57:57 <edwardk> yeah
14:57:59 <edwardk> thats all it is
14:58:02 <ReinH> merijn: flipped morphisms and flipped composition, yes
14:58:05 <benzrf> or a covariant non-endo functor
14:58:18 <edwardk> we also have the associativity of composition and unit laws in terms of those identity arrows per object
14:58:21 <edwardk> thats a category
14:58:46 <merijn> Right
14:59:05 <edwardk> we can describe the 'set of arrows' above instead as a functor that takes a choice of object in the category for source and target and gives you the set of arrows.
14:59:20 <benzrf> merijn: check this out:
14:59:31 <benzrf> @let Op p a b = Op {deOp :: p b a}
14:59:32 <lambdabot>  Parse failed: NamedFieldPuns is not enabled
14:59:46 <benzrf> @let newtype Op p a b = Op {deOp :: p b a}
14:59:47 <edwardk> this is the 'Hom' functor, the result of this functor is a set, and it is the set of homomorphisms from the source to the target.
14:59:48 <lambdabot>  Defined.
14:59:59 <benzrf> merijn: Op (->) is a type constructor for morphisms in Hask^op
15:00:10 <merijn> edwardk: ok, no I don't get that last bit
15:01:40 <ReinH> merijn: you have two functors: A covariant functor that maps objects in Hask to morphisms *from* those objects
15:02:00 <ReinH> and a contravariant functor that maps objects in Hask to morphisms *to* those objects
15:02:25 <benzrf> merijn: do you familiar with hom functors
15:02:35 <merijn> benzrf: No
15:02:42 <ReinH> e.g. for A, B in a category C, Hom(A,-) maps each object X in C to the set of morphisms from A to X
15:02:47 <merijn> ReinH: ah, right now I remember
15:03:04 <ReinH> while Hom(-,B) maps each object X in C to the set of morphisms from X to B
15:03:37 <ReinH> merijn: so Hom(-,-) is a bifunctor from C * C -> Set that is contravariant in the first argument and covariant in the second
15:03:40 <merijn> Right
15:03:48 <merijn> eh
15:03:48 <benzrf> merijn: in haskell, ((->) r) is the object mapping for the hom functor Hom(r, -)
15:03:56 <merijn> You interrupted my "right"!
15:04:02 <benzrf> merijn: the - is like a de bruijn index
15:04:04 <ReinH> merijn: :p
15:04:05 <benzrf> sort o
15:04:12 <ReinH> benzrf: ...
15:04:47 <benzrf> ok it's not like a de bruijn index, that was just the first implied-argument thing to pop into my head OK
15:04:56 <merijn> Hom(A,B) is the set of morphisms A -> B, right?
15:05:00 <ReinH> merijn: Yes
15:05:19 <ReinH> Hom(-,B) is the set of morphisms X -> B for all objects X
15:05:27 <ReinH> and vice versa for Hom(A,-)
15:05:47 <ReinH> the - is the thing that is quantified
15:06:18 <ReinH> merijn: so Hom(-,-) is the set of all morphisms X -> Y for all objects X, Y
15:06:27 <merijn> Right
15:07:36 <kototama> where should 'where' be put for module definition? and in general is there an official haskell guide style?
15:07:46 <ReinH> So if we treat Hom(-,-) as being contravariant in the first argument and covariant in the second argument, it is a bifunctor C * C -> Set
15:08:22 <merijn> kototama: I put it on the same line if there's no export list or I close the export list with ") where" on it's own line
15:08:44 <ReinH> merijn: and since a contravariant functor in C is a covariant functor in C op, it is covariant in both arguments when seen as a bifunctor C^op * C -> Set
15:09:16 <merijn> kototama: See https://github.com/merijn/broadcast-chan/blob/master/Control/Concurrent/BroadcastChan.hs#L30-L38
15:09:19 <benzrf> merijn: for the record, Hom(A, B) is not a set in all categories. the ones where it always is are called "locally small"
15:09:20 <ReinH> (a bifunctor isn't much more than a functor of two arguments)
15:09:54 <merijn> Wait, what it covariance again?
15:10:26 <ReinH> merijn: A covariant functor preserves the direction of arrows
15:11:23 <ReinH> a covariant functor F maps every arrow f : A → B to an arrow F(f) : F(A) → F(B)
15:11:33 <ReinH> a contravariant functor F maps every arrow f : A → B to an arrow F(f) : F(B) → F(A)
15:12:12 <kototama> merijn: thanks. ah! why are haskell programmers comas before the item?
15:12:19 <merijn> Right, so just "normal functor"?
15:12:21 <ReinH> :t contramap
15:12:21 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
15:12:26 <ReinH> merijn: yep
15:12:33 <merijn> kototama: Looks more consistent
15:12:39 <ReinH> fmap is covariant, contramap is contravariant
15:12:54 <ReinH> edwardk: ok, please proceed ;)
15:13:13 <merijn> kototama: If you delete the last export you don't have to mess around with the location of where, etc.
15:13:32 <kototama> i see
15:13:46 <merijn> kototama: You could put the commas behind and it'd be exactly the same
15:13:53 <ReinH> kototama: having used Haskell style for a while, I have trouble now with trailing commas...
15:14:05 <ReinH> But both are valid syntax
15:14:28 <merijn> Haskell style grows on you
15:14:30 <merijn> I used to hate it
15:14:37 <kototama> i'm mostly doing Clojure normally so i think i don't use comas that much
15:14:40 <ReinH> merijn: what is happening to us...
15:14:40 <merijn> Now I hate C style for making it hard to have consistent style
15:14:48 <edwardk> ReinH: got buried in #ghc stuff
15:14:49 <edwardk> most track
15:15:01 <ReinH> edwardk: no worries, I think I did a decent job explaining homs
15:15:10 <edwardk> where were we?
15:15:44 <merijn> (brb, nature calls :p)
15:16:15 <ReinH>  17:43     edwardk| and we can talk about monoids for 'Compose'   mu :: Compose m m ~> m     eta :: Identity ~> m
15:16:20 <ReinH> and then onwards to Ran and Codensity
15:20:50 <chrisdone> kototama: ah, the serenity of s-expressions
15:21:16 <apriori> merijn: one quesiton about FunPtr. is it possible to create such a pointer only once and reuse it through program execution or do I need to construct it for every invocation of the function?
15:21:40 <edwardk> you can hold onto a FunPtr as long as you like
15:22:24 <apriori> compared to a directly exported C function, is the call overhead significant in such a case?
15:22:47 <merijn> apriori: Overhead for calling should be 0
15:23:33 <apriori> ok, then about how to construct it... I don't quite get the docs in that regard. am I supposed to construct a value of the type of the function ptr on the heap in C and make haskell retrieve and work in that?
15:24:45 <apriori> edwardk: ty
15:27:05 <merijn> apriori: See here how to construct one: https://github.com/merijn/SNet2.0/blob/master/SNet/Interfaces/C.hs#L22-L23
15:27:08 <benzrf> ooh,can i follow along
15:27:08 <benzrf> i wanna hear about codensity
15:27:08 <benzrf> have you covered anything other than the definition of monoids, hom functors, and profunctors yet
15:27:17 <benzrf> if so i think i know enough to jump in
15:27:30 <benzrf> er, if not
15:27:32 <merijn> apriori: "wrapper" is builtin magic to convert any haskell function to a FunPtr
15:27:32 <kototama> chrisdone: the serenity of having a stacktrace dynamically when it could have been caught at compile time
15:28:02 <apriori> merijn: ah.. that was exactly the part that wasn't that obvious to me. thank you
15:29:10 <kototama> chrisdone: actually i think a mix between lisp and haskell would be great ;-) in the vein of Liskell
15:30:30 <fds4345> ~.
15:30:39 <fds4345> has there ever been talk of a "type macro"?
15:31:20 <kototama> oh well, you can make it ugly like template haskell
15:31:24 <fds4345> I'd like to expand (a, b, c) to mean that the value will be (Maybe a, Maybe b, Maybe c)
15:31:47 <kototama> ah ah
15:31:49 <fds4345> I guess thats a very simple template haskell splice right?
15:32:08 <vanila> fds4345, you could write  type M3 a b c = (Maybe a, Maybe b, Maybe c)
15:32:17 <vanila> then use M3 a b c instead of taking over (a, b, c)
15:33:28 <fds4345> vanila: then I can have a typeclass for M1, M2, M3, M4 etc and thus constrain the values that are passed
15:33:37 <benzrf> what's liskell again
15:33:38 <fds4345> or the types
15:33:45 <vanila> no typeclass
15:34:44 <fds4345> but if I dont know how many different values i'll need to pass in the tuple... I'll need some kind of type macro
15:37:23 <merijn> fds4345: What are you actually trying to do?
15:39:15 <fds4345> merijn: https://github.com/ssadler/many
15:39:55 <fds4345> writing some generic functions that deal with groups of type streams
15:41:52 <benzrf> fds4345: sounds like you want a list
15:41:55 <alrunner4> fds4345: i'm late to the conversation, but have you looked at type-level lists?
15:43:42 <merijn> I actually have two potentially relevant gists :)
15:43:55 <merijn> Heterogeneous list: https://gist.github.com/merijn/dc00bc7cebd6df012c5e
15:44:10 <merijn> Length indexed list: https://gist.github.com/merijn/39dc86e345e87276c523
15:48:31 <boxrick> Good evening guys!
15:49:49 <joe9> Which is the preferred version? Control.Monad.Free or Control.Monad.Trans.Free?  http://hackage.haskell.org/package/free-4.9/docs/Control-Monad-Trans-Free.html https://hackage.haskell.org/package/control-monad-free-0.5.3/docs/Control-Monad-Free.html
15:50:20 <joe9> They both seem to have similar functionality (to my newbie's eyes)..
15:51:56 <merijn> joe9: That's because Control.Monad.Free is a specialised version of Trans.Free :)
15:52:10 <merijn> joe9: Or generalised, depending on your point of view
15:52:22 <joe9> merijn: so, is that the preferred version?
15:52:37 <merijn> joe9: I would personally prefer Trans.Free where possible
15:52:49 <merijn> joe9: It's more concrete and probably easier to work with as beginner
15:53:12 <boxrick> This evening my brain is drooling out of my nose. Never good =(
15:54:05 <joe9> merijn: I am trying to write a Free monad in Idris too. For that scenario, which version would you recommend to clone from?
15:55:55 <ReinH> joe9: do you need a free monad *transformer*?
15:56:34 <glguy> Free monad? Is that a Black Friday deal?
15:57:04 <benzrf> glguy: indeed
15:57:15 <joe9> glguy: http://www.haskellforall.com/2013/06/from-zero-to-cooperative-threads-in-33.html it is pretty cool.
15:57:32 <joe9> ReinH: I want to have a Free Effect eventually (but that is in Idris)
15:57:58 <ReinH> joe9: I'd start with http://hackage.haskell.org/package/free-2.0.3/docs/Control-Monad-Free.html
15:58:02 <ReinH> or maybe even http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
15:58:29 <boxrick> Where is everyone from in here?
15:58:30 <joe9> ReinH: I have done those tutorials. But, used Control.Monad.Trans.Free
15:58:46 * hackagebot Sonnex 0.1.0.0 - Sonnex is an alternative to Soundex for french language  http://hackage.haskell.org/package/Sonnex-0.1.0.0 (zigazou)
15:58:58 <joe9> ReinH: Later, I came across Control.Monad.Free. and now, I am wondering which is better?
15:59:52 <adamse> joe9: the Control.Monad.Free you linked is not hte Control.Monad.Free from the free package..., the free package also has a Control.Monad.Free
16:00:05 <ReinH> joe9: Well, in the free package, one is a free monad, the other is a free monad transformer.
16:00:29 <ReinH> The ones in the free package are the ones I would use
16:00:50 <joe9> ReinH: adamse: oh, I should be using this: http://hackage.haskell.org/package/free-4.9/docs/Control-Monad-Free.html
16:00:57 <ReinH> joe9: I think so.
16:01:20 <adamse> joe9: use FreeT if you need a monad transformer?
16:01:35 <adamse> one is not better than the other, useful for slightly different tasks
16:04:22 <joe9> adamse: ReinH: Thanks.
16:05:03 <ReinH> joe9: np
16:05:13 <adamse> joe9: the Free in both Control.Monad.Free and Control.Monad.Trans.Free is the same, but ...Trans.Free also supplies FreeT which is a monad transforimer
16:07:13 <ReinH> adamse: They are equivalent, but the one in Trans.Free is FreeT Identity
16:07:27 <ReinH> the one in C.M.F is data Free f a = Pure a | Free (f (Free f a))
16:12:01 <kai23566> what do you think is best matrix library in pure haskell?
16:13:47 * hackagebot hplayground 0.1.2.2 - a client-side haskell framework that compiles to javascript with the haste compiler  http://hackage.haskell.org/package/hplayground-0.1.2.2 (AlbertoCorona)
16:13:48 <benzrf> data M a = Eta () | Mu (a, M a)
16:14:16 <benzrf> data M a t = Eta (Identity t) | Mu (Compose a (M a) t)
16:14:36 <benzrf> list & Free are both free monoids
16:14:42 <benzrf> on different categories though
16:14:47 <benzrf> with different bifunctors
16:15:19 <ReinH> kai23566: what does "matrix library" mean here?
16:15:44 <kai23566> something like hmatrix
16:16:52 <benzrf> wish i could do point free data constructors or sth
16:17:06 <benzrf> bbiab
16:19:55 <kai23566> ReinH: A library that provides nice API to work with general 2d arrays, not necessarily contains linear algebra functions.
16:21:02 <silasm_> kai23566: repa might be worth a look if you haven't already. I'd imagine "the best" will depend on your particular use case, however. Giving more info would probably help someone help you.
16:23:14 <kai23566> silasm_: repa is nice if you want parallel computing. But it's targeted for multiple-dimension arrays. It doesn't have nice API to work with matrix (2d array).
16:24:16 <kai23566> silasm_: Is there something like the vector package, but work with matrix?
16:25:09 <silasm_> kai23566: I only mentioned repa because I knew about it; I'm not generally familiar with such things, sorry.
16:25:28 <kai23566> silasm_: Thank you, anyway.
16:32:23 <merijn> kai23566: You may wanna check out #numerical-haskell
16:38:48 * hackagebot wkt 0.2.3 - Parsec parsers and types for geographic data in well-known text (WKT) format.  http://hackage.haskell.org/package/wkt-0.2.3 (BenGamari)
16:41:55 <ReinH> @hackage array
16:41:55 <lambdabot> http://hackage.haskell.org/package/array
16:41:57 <ReinH> kai23566:
16:42:09 <ReinH> That's probably what you're looking for
16:43:48 * hackagebot linear-opengl 0.2.0.3 - Isomorphisms between linear and OpenGL types  http://hackage.haskell.org/package/linear-opengl-0.2.0.3 (BenGamari)
16:43:50 * hackagebot chart-histogram 0.4.4 - Easily render histograms with Chart  http://hackage.haskell.org/package/chart-histogram-0.4.4 (BenGamari)
16:47:22 <kai23566> ReinH: This is for general arrays. Not designed for 2d array. As an example, it doesn't have some useful functions like transpose. The interface is too complicated if you just want to deal with matrices.
16:48:34 <AleksejsHome> Hi, could anyone give me a simple implementation for shuffling [1..n]?
16:50:19 <kai23566> merijn: Thanks.
16:58:53 <ReinH> AleksejsHome: what have you tried so far?
17:00:14 <int-e> http://hackage.haskell.org/package/random-shuffle-0.0.4/docs/System-Random-Shuffle.html is not simple, but looks easy to use.
17:01:48 <int-e> (this is where we find out whether this is a homework question)
17:03:25 <kai23566> int-e: try this: System.Random.MWC.Distributions.uniformShuffle
17:04:34 <AleksejsHome> seems shuffleM from random-shuffle is good enough for my case, thanks!
17:04:58 <kai23566> AleksejsHome: System.Random.MWC.Distributions.uniformShuffle
17:08:39 <woky_> Hi. Can GHC optimize this 'take 4 ([1, 2, 3] ++ [4, 5, 6])' by not doing the list addition?
17:10:46 <geekosaur> woky_, laziness should do that automatically, sort of
17:11:21 <geekosaur> the question itself assumes non-lazy evaluation, so the answer is "difficult"
17:11:32 <AleksejsHome> > take 4 $ [1..3] ++ [4..]
17:11:34 <lambdabot>  [1,2,3,4]
17:11:37 <vanila> You could look at the compiler output "Core" to see if it gets optimized
17:11:40 <silasm_> woky_: it'll only evaluate up to the 4 in the second list because of lazy evaluation. You can test this with :sprint in ghci, e.g. let x = [1,2,3]; let y = [4,5,6]; take 4 (x ++ y); :sprint y
17:11:43 <vanila> I would guess that it's not optimized
17:13:28 <kai23566> Even it is lazy, doesn't it need to allocate the list of [1,2,3,4,5,6] first, and then pick up the first 4 numbers?
17:13:33 <woky_> silasm_, :sprint printed [4, 5, 6]
17:13:34 <geekosaur> no
17:13:50 <vanila> kai23566, it would build up the list [1,2,3,4] without creating the full [1,2,3,4,5,6] I think
17:14:12 <geekosaur> it asks the expression [1..3] ++ [..6] to provide stuff incrementally. it does so by stepping through the first list until it is consumed, then the second
17:14:26 <geekosaur> lazy evaluation
17:14:37 <geekosaur> precreating the intermediate list is strict evaluation
17:14:39 <ReinH> @src (++)
17:14:39 <lambdabot> []     ++ ys = ys
17:14:39 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
17:14:39 <lambdabot> -- OR
17:14:39 <lambdabot> xs ++ ys = foldr (:) ys xs
17:14:49 <ReinH> @src take
17:14:49 <lambdabot> take n _      | n <= 0 = []
17:14:49 <lambdabot> take _ []              = []
17:14:49 <lambdabot> take n (x:xs)          = x : take (n-1) xs
17:15:10 <vanila> it would be doing something like  (1 : 2 : take 2 ([3] ++ [4,5,6])) then  (1 : 2 : 3 : take 1 [4,5,6]) then (1 : 2 : 3 : 4 : take 0 [5,6])
17:15:14 <woky_> now i think i get it =)
17:15:45 <ReinH> So first take 4 needs to pattern match on (x:xs)
17:15:57 <ReinH> so it evaluates enough of [1,2,3] ++ [4,5,6] to do so
17:16:08 <woky_> so does it really mean that i can use ++ in haskell without worrying about its O(n) complexity in languages with strict evaluation?
17:16:17 <geekosaur> sometimes, sometimes not
17:16:21 <vanila> ++ is O(n) in the length of the first argument
17:16:21 <ReinH> [1,2,3] ++ [4,5,6] = 1 : [2,3] ++ [4,5,6]
17:16:29 <silasm_> woky_: in general when testing stuff with :sprint I've found Ints tend to evaluate eagerly; I usually try to use different data types as the leaves when doing such tests.
17:16:40 <ReinH> then it can pattern match: 1 : take 3 ([2,3] ++ [4,5,6])
17:16:41 <vanila> you still have complexity but it's more difficult to figure it out
17:16:52 <ReinH> and it keeps doing this until it gets to take 0
17:17:02 <merijn> vanila: It is not
17:17:09 <geekosaur> the screw case in haskell is when you buid up a thunk of x ++ y ++ z ++ ... where to evaluate it may have to traverse the whole thing multiple times.
17:17:10 <vanila> that said, it's always less or equal to than the same code in a strict language
17:17:13 <merijn> vanila: The complexity of ++ depends on how you consume the list
17:17:17 <geekosaur> (and the cure for this is difference lists)
17:17:32 <ReinH> geekosaur: specifically, ((x ++ y) ++ z) ++ ...
17:17:38 <geekosaur> yes
17:17:40 <ReinH> otherwise associativity of (++) saves you
17:17:44 <geekosaur> but that is a common (anti)pattern
17:17:53 <ReinH> yes, just wanted to be clear that xs ++ ys ++ zs is fine per se
17:17:57 <geekosaur> that you can get by accident
17:18:22 <geekosaur> anyway ++ is not magic, it has screw cases, they're just different from the screw cases in strict languages.
17:18:50 * hackagebot propellor 1.0.0 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-1.0.0 (JoeyHess)
17:19:05 <ReinH> woky_: so take and (++) proceed together incrementally, driven by pattern matching.
17:19:12 <woky_> got it, thank you
17:24:28 <stepkut> do any of the lens libraries like lens, fclabels, etc, allow for overlapping field labels?
17:25:23 <vanila> Does anyone know of a well typed SQL library for haskell? One that is not based on strings
17:25:34 <stepkut> vanila: haskelldb?
17:26:16 <vanila> thanks stepkut!
17:26:46 <stepkut> vanila: there is also stuff like this, http://hackage.haskell.org/package/hssqlppp
17:27:03 <stepkut> vanila: not really clear what you are after
17:27:47 <kai23566> stepkut: http://statusfailed.com/blog/2013/02/19/overloading-record-fields-with-lens.html
17:27:49 <ReinH> stepkut: not directly, but it's pretty easy to write a typeclass
17:28:27 <ReinH> Oh, makeFields! nice
17:28:36 <ReinH> that'll save me some effort
17:28:50 * hackagebot dirstream 1.0.0 - Easily stream directory contents in constant memory  http://hackage.haskell.org/package/dirstream-1.0.0 (GabrielGonzalez)
17:35:29 <stepkut> kai23566: thanks!
17:39:39 <AleksejsHome> is there any way to perform IO action with repeat function?
17:39:49 <AleksejsHome> like repeat randomIO
17:40:33 <kai23566> AleksejsHome: Control.Monad.forever
17:42:00 <Welkin> kai23566: that would make an interesting title for a book, film, or video game
17:42:05 <Welkin> "Control Monad Forever"
17:42:32 <mmmm> Anyone know a good place to learn about equivalence of greatest and least fixed points in haskell?
17:43:05 <AleksejsHome> kai23566: is it lazy? can I, for example, take 10?
17:43:20 <merijn> AleksejsHome: You probably want randoms
17:43:21 <merijn> :t randoms
17:43:22 <lambdabot> (Random a, RandomGen g) => g -> [a]
17:43:34 <merijn> AleksejsHome: randoms produces an infinite random lazy list
17:44:09 <AleksejsHome> merijn: no, I used randomIO as an example of IO action
17:44:50 <merijn> :t repeatM
17:44:51 <lambdabot>     Not in scope: ‘repeatM’
17:44:51 <lambdabot>     Perhaps you meant one of these:
17:44:51 <lambdabot>       ‘repeat’ (imported from Data.List),
17:44:54 <merijn> hmmm
17:45:23 <merijn> There's a function somewhere, but I usually just use forever or my own recursion
17:50:16 <kai23566> AleksejsHome: Probably not.
17:50:41 <kai23566> AleksejsHome: If that's what you want, why not just: sequence . take 10 . repeat $ action
17:50:42 <AleksejsHome> ok, maybe it will be more usefull if I tell the problem: I have a function \list -> fmap (zip list) $ shuffleM list, I want to generate an infinite list of such lists, filter out by some function and then take first. I wrote a piece of code that works, but shuffleM always returns the same list
17:52:58 <edwardk> stepkut 'makeFields' in lens lets you pun names between record types
17:54:39 <systemfault> I started listening to the "Haskell Cast" podcasts today and someone "implied" that "traversables and foldables" are the real thing and better than what's available in prelude, is that true? (I'm a noob)
17:54:58 <systemfault> Ah.. lol
17:55:03 <systemfault> edwardk: I guess it was "your" podcast
17:59:26 <AleksejsHome> kai23566: here's a code http://lpaste.net/2572331930200571904 . shuffleM returns the same list all the time
18:00:40 <Cale> systemfault: I'd take that sentiment with a grain of salt. It's quite possible that putting Traversable and Foldable in the Prelude is a good idea. I don't like to downplay the importance of lists though.
18:01:04 <Welkin> lists have a purpose
18:01:34 <Welkin> but they do not give you better than linear access time
18:02:52 <Cale> Welkin: Well, right, any case where you want random access, lists are the wrong thing. What lists are useful for is every case where you want to iterate over something.
18:03:07 <Cale> (in linear order)
18:03:52 <Cale> Thinking of lists as loops that are waiting to happen is probably the right approach most of the time.
18:04:04 <Cale> and loops are quite common!
18:04:32 <n4x> I'd say haskell lists are used mostly for control flow, more than data
18:04:35 <Cale> yes
18:04:39 <systemfault> So, as a beginner, I should just continue to work with the prelude? And leave the traversable/foldables (and even stuff like vectors) for later?
18:04:48 <n4x> my english is crap, but well
18:04:58 <vanila> You can use traversable/foldables if you like
18:04:59 <Cale> systemfault: Well, yeah, you can learn about that stuff whenever you like.
18:05:01 <vanila> it's not needed
18:05:59 <Cale> systemfault: The more important thing if you want to write programs which perform somewhat acceptably is probably to learn about Data.Map and Data.Set. If you use lists for those tasks, it often won't go well.
18:06:21 <nshepperd> church encoding of a list is a partially applied foldr
18:06:23 <systemfault> Ah yeah, sure :)
18:06:23 <Cale> (at least, once the lists get pretty big)
18:06:43 <nshepperd> so in a way, lists are quite literally loops that are waiting to happen
18:07:23 <systemfault> So far, haskell has been a strange language to learn for me... I mean, I still have 0 productivity with it but I started using "haskell idioms" in other languages.
18:07:31 <geekosaur> loop encoded as data, yes
18:07:56 <zariuq> Lists have their uses ^_^. When you want to do something another data type is better for, learn to use that~
18:08:19 <Welkin> systemfault: wait until you get to the point where you gt frustrated with all the "missing" features in other languages and feel you are most productive in haskell
18:08:31 <Welkin> it's a good feeling
18:08:33 <systemfault> Welkin: Can't wait :D
18:16:43 <AleksejsHome> Could anyone help me with my IO problem? http://lpaste.net/2572331930200571904
18:18:36 <indiagreen> AleksejsHome: please post the error message as well when you have a compilation problem
18:19:13 <indiagreen> or is it not a compilation problem?
18:19:20 <AleksejsHome> there's no error. The problem is that shuffleM always returns the same list
18:19:31 <ab9rf> of course it does
18:22:09 <nshepperd> you're only 'running' shuffleM once there
18:22:32 <nshepperd> and duplicating the output infinitely
18:24:13 <vanila> :t foldr
18:24:14 <lambdabot> (a -> b -> b) -> b -> [a] -> b
18:28:18 <nshepperd> AleksejsHome: you can use untilJust from package monad-loops to repeat an IO action until it returns (Just something)
18:31:13 <nshepperd> eg. print =<< untilJust ((\shuf -> let zipped = zip [1..15] shuf in if isValid zipped then Just zipped else Nothing) <$> shuffleM [1..15])
18:35:17 <nshepperd> untilJust $ (mfilter isValid . Just . zip [1..15]) <$> shuffleM [1..15]
18:36:04 <nshepperd> odd, there isn't any built in (a -> Bool) -> a -> Maybe a
18:37:06 <Iceland_jack> There is:
18:37:06 <Iceland_jack> ghci> :set -XMonadComprehensions
18:37:06 <Iceland_jack> ghci> [ 'a' | isLower 'a' ] :: Maybe Char
18:37:06 <Iceland_jack> Just 'a'
18:37:35 <Iceland_jack> Which gets close
18:39:55 <nshepperd> :t bool
18:39:56 <lambdabot> a -> a -> Bool -> a
18:42:21 <nshepperd> :t mwhen <$> Just <*> f
18:42:22 <lambdabot>     Not in scope: ‘mwhen’
18:42:22 <lambdabot>     Perhaps you meant ‘when’ (imported from Control.Monad.Writer)
18:43:08 <nshepperd> oh well
18:52:06 <cdk> @pl \x y f g h -> h (f x y) (g x y)
18:52:06 <lambdabot> ap (ap . ((flip . (((.) . flip . flip id) .)) .) . flip . flip id) (flip . flip id)
19:43:44 <benzrf> i sleep now
19:58:33 <jle`> > mfilter isLower (Just a)
19:58:34 <lambdabot>  Couldn't match expected type ‘GHC.Types.Char’
19:58:34 <lambdabot>              with actual type ‘Debug.SimpleReflect.Expr.Expr’
19:58:37 <jle`> > mfilter isLower (Just 'a')
19:58:38 <lambdabot>  Just 'a'
19:59:16 <jle`> @pl \p x -> mfilter p (Just x)
19:59:16 <lambdabot> (. Just) . mfilter
19:59:19 <jle`> heh
19:59:53 <jle`> oh
20:00:12 <jle`> :t flip mfilter . Just
20:00:12 <lambdabot> a -> (a -> Bool) -> Maybe a
20:00:15 <jle`> :)
20:00:35 <jle`> not that you should use that in real code
20:01:24 <n4x> "nearly point-free" style is kinda neat, something like (\p → mfilter p . Just)
20:01:34 <jle`> nshepperd
20:01:50 <jle`> n4x: oh yeah that's neat
20:03:56 * hackagebot configuration-tools 0.2.7 - Tools for specifying and parsing configurations  http://hackage.haskell.org/package/configuration-tools-0.2.7 (larsk)
20:04:43 <Welkin> how do I enable language pragmas in ghci?
20:06:20 <merijn> Welkin: Either start ghci with -X or use ":set -X" + whatever pragma
20:07:18 <orion> Does there exist a function which will give me the last n bytes of a ByteString?
20:07:21 <Welkin> is using RecordWildCards advised over pattern matching?
20:07:34 <Welkin> or just using the record syntax to pull data out
20:07:42 <Hijiri> it depends on how big the record is
20:07:49 <Hijiri> and how many fields you're using
20:08:05 <Welkin> pattern matching on a data type with 9 fields is not fun
20:08:11 <Welkin> especially when I just want 2 or 3 of them
20:08:34 <Welkin> but the accessor functions are quite verbose as well
20:12:01 <jle`> Welkin: marlow uses record wildcards so it's ok by me
20:12:24 <jle`> i wouldn't use it for something like Sum or Identity of course
20:12:27 <jle`> or would i?
20:13:14 <Welkin> simplifying my programs after they are written and working is always fun in a way
20:13:18 <merijn> Welkin: fyi, you don't need to specify all record fields when matching!
20:13:32 <Welkin> merijn: I know, I use "_" in a lot of places
20:13:42 <merijn> No, I mean you can match 2 out of 9 fields
20:13:47 <Welkin> oh?
20:14:01 <jle`> @set {-# LANGUAGE RecordWildCards #-}
20:14:07 <merijn> @let data Foo = Foo { a1, a2, a3, a4, a5, a6, a7, a8, a9 :: Int}
20:14:08 <lambdabot>  .L.hs:160:1:
20:14:08 <lambdabot>      Multiple declarations of ‘Foo’
20:14:08 <lambdabot>      Declared at: .L.hs:153:1
20:14:08 <lambdabot>                   .L.hs:160:1
20:14:08 <lambdabot>  
20:14:12 <merijn> @undefine
20:14:12 <lambdabot> Undefined.
20:14:13 <merijn> @let data Foo = Foo { a1, a2, a3, a4, a5, a6, a7, a8, a9 :: Int}
20:14:15 <lambdabot>  Defined.
20:15:28 <merijn> > let { x = Foo { a1 = 1, a2 = 2, a3 = 3, a4 = 4, a5 = 5, a6 = 6, a7 = 7, a8 = 8, a9 = 9}; foo Foo { a1 = x, a9 = y } = (x,y) in foo x
20:15:29 <lambdabot>  <hint>:1:125: parse error on input ‘in’
20:15:35 <merijn> oh, duh
20:15:39 <merijn> > let { x = Foo { a1 = 1, a2 = 2, a3 = 3, a4 = 4, a5 = 5, a6 = 6, a7 = 7, a8 = 8, a9 = 9}; foo Foo { a1 = x, a9 = y } = (x,y) } in foo x
20:15:40 <lambdabot>  (1,9)
20:16:06 <merijn> Welkin: Fun fact, this trick can even work with non-record syntax!
20:16:17 <merijn> > let f Just{} = 1 in f (Just 3)
20:16:18 <lambdabot>  1
20:16:49 <Welkin> that's cool
20:16:50 <merijn> It's great when you only wanna match the constructor and don't care about any fields
20:17:09 <Welkin> I have tons of _'s littering my codebase
20:17:13 <Welkin> time to get rid of them
20:21:55 <danilo2> Hello! Would somebody be so nice and tell me why the following 5-liner code does not compile? What does the GADTs extension do, that this coede does not compile with it? (Without GADTs it ocmpile fine): http://lpaste.net/114754
20:24:14 <merijn> If that's true (which I have not decided I believe yet), that'd be a bug
20:24:33 <merijn> If this is all the code then GADTs can't stop this from compiling and it has nothing to do with this error message
20:25:05 <danilo2> merijn: thats all the code - just copy and paste it
20:25:18 <danilo2> merijn: -XFunctionalDependencies result in the same error
20:26:17 <danilo2> merijn: it behaves so in both ghc-7.6 and 7.8.*
20:26:20 <merijn> Oh, I remember, GADTs affect MonoLocalBinds, I think
20:27:03 <ReinH> merijn: did edwardk ever finish up that Codensity thing?
20:27:14 <lpaste> merijn annotated “No title” with “this works” at http://lpaste.net/114754#a114756
20:27:24 <merijn> ReinH: no
20:27:24 <danilo2> merijn: oh, that is awful. I want to use (~) syntax in my instances and because of that I've got GADTs enabled  - so how can I fix the code?
20:27:39 <merijn> ReinH: But my brain is to dead to follow atm anyway
20:27:50 <ReinH> danilo2: Do you need GADTs for ~?
20:27:54 <merijn> danilo2: What does ~ have to do with GADTs?
20:28:02 <ReinH> merijn: I was looking forward to it...
20:28:13 <ReinH> merijn: we got through the hom functor stuff though right?
20:28:17 <merijn> ReinH: I'll bug him again some other time to continue :p
20:28:24 <ReinH> merijn: ok then ping me :p
20:28:30 <danilo2> ReinH, merijn: If you want to write instance with context using (~) sntax, you have to enable either GADTs or TypeFamilies
20:28:46 <merijn> ReinH: I already knew hom functors, but I forgot due to lack of use
20:28:49 <merijn> danilo2: That's not true
20:28:52 <ReinH> merijn: ah :)
20:29:08 <merijn> ReinH: homfunctors are about as far as I got into Awodey this summer
20:29:26 <ReinH> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/equality-constraints.html
20:29:48 <ReinH> merijn: Awodey is nice. Have you seen any casters videos?
20:30:22 <ReinH> merijn: the adjunctions and representable functors videos might be relevant here
20:30:28 <danilo2> merijn: not true? Look: http://lpaste.net/114757 The ghc complains that I need to enable GADTs or TypeFamilies here
20:33:17 <merijn> That's because of the ~ but because of the constraint, as error says
20:33:43 <merijn> Also, that instances seems an odd way to write "instance X Int"
20:34:03 <danilo2> merijn: oh, right. Sorry - I was thinking about it. Anyway, can I somehow use such constrain and write that code without explicit typing in let? Why GADTs change the binding syntax?
20:34:04 <merijn> ReinH: Nope, I was thinking I should watch some online CT course
20:34:25 <merijn> danilo2: Yes, byt actually using 'p'
20:34:27 <ReinH> merijn: I'm not sure there's an "online CT course" (but I would love one)
20:34:38 <dfeuer> I think I may need a memoization table to do what I want. What are some reasonably okay ways to do that—note: I can only depend on things in base, and *maybe* containers.
20:34:45 <ReinH> merijn: but TheCatsters on YouTube have dozens of videos, most of them by Eugenia Cheng, which are wonderful
20:34:47 <merijn> danilo2: It can't infer the Monad in 'p' because you never use p
20:34:56 <ReinH> she is very enthusiastic
20:35:04 <danilo2> merijn: Hmm, would you be so nice and explain a bit, why this happens? Why GHC just cannot live without knowing what "m" exactly is or without explicit typing ?
20:35:13 <ReinH> merijn: also Awodey's lectures at the Oregon summer school thing are available on Youtube as well
20:35:14 <merijn> dfeuer: The Fun with Type Functions paper showed a simple memo approach
20:35:19 <ReinH> They are pretty nice
20:35:23 <danilo2> merijn: So why it can without the GADTs extension?
20:35:24 <danilo2> :(
20:35:35 <dfeuer> merijn, I'll check it out.
20:35:59 <merijn> danilo2: I don't know the details well enough to explain
20:36:00 <ReinH> dfeuer: sorry, what's the question?
20:36:11 <merijn> ReinH: So little time to watch them, though
20:36:21 <merijn> ReinH: Or rather, after an 8 hour work day I can't take a CT lecture
20:36:26 <ReinH> merijn: I... sometimes... watch them in bed...
20:36:37 <ReinH> They put me right to sleep! I mean...
20:36:44 <merijn> I have enough trouble doing something as simple as hacking haskell
20:37:00 <ReinH> merijn: I get that though, totally
20:37:01 <dfeuer> ReinH, I'm trying to improve the definition of (<*>) for Data.Sequence.Seq. I think to do it right I may need to memoize ways of splitting the right-hand argument.
20:37:08 <ReinH> merijn: it's different now that I actually do haskell for work...
20:37:27 <dfeuer> I'm still trying to understand the whole problem well enough.
20:37:39 <ReinH> dfeuer: that tends to be where I have trouble as well...
20:37:46 <dfeuer> Where?
20:37:51 <ReinH> understanding the problem...
20:37:54 <dfeuer> Heh.
20:37:58 <ReinH> :)
20:38:13 <dfeuer> Well, I think I've made *some* progress.
20:38:21 <danilo2> merijn: ok, thank you :)
20:39:01 <dfeuer> ReinH, want to work on this with me?
20:40:11 <merijn> Quick git question, "git remote set-url --push origin URL" lets me change the default URL it pushes to, but how do I tell it to pull from there? Am I stuck writing out the entire URL when writing "git pull"?
20:40:28 <ReinH> dfeuer: Tonight? Definitely not. In general? Yeah sure. :)
20:40:33 <dfeuer> Cool.
20:40:59 <ReinH> merijn: git config... one sec...
20:41:02 <Clint> merijn: lose the --push
20:41:07 <merijn> Clint: No
20:41:15 <merijn> Clint: I want to pull from the existing origin
20:41:19 * Clint squints.
20:41:20 <ReinH> git config branch.master.remote origin
20:41:30 <merijn> I just want to pull from push location ONCE
20:41:33 <Clint> oh
20:41:34 <ReinH> and possibly git config branch.master.merge refs/heads/master
20:42:01 <merijn> ReinH: Which does what?
20:42:03 <Clint> merijn: add the pushurl as an additional remote?
20:42:32 <merijn> Clint: i.e. I'm tracking GHC upstream and pushing to my github, but I want to sync a new checkout to my github
20:42:53 <merijn> ugh
20:42:58 <ReinH> merijn: 1) when you're on the master branch, use the remote `origin' 2) when using git pull on the master branch with no remote or branch specified, use the default (now origin) and merge from master
20:43:00 * merijn goes back to complaining about gir workflows
20:43:27 <Welkin> git was confusing when I started using it
20:43:33 <ReinH> Git is confusing.
20:43:34 <Welkin> but now it seems pretty simple
20:43:36 <merijn> ReinH: Sounds like a bunch of complicated stuff I don't want
20:43:44 <ReinH> It isn't simple, you've just grown accustomed to the complexity ;)
20:43:46 <merijn> Thank god for hg-git :)
20:43:50 <Welkin> it has a learning curve, like most things
20:43:54 <ReinH> merijn: do you want git pull to Just Work when on the master branch?
20:44:03 <Adamant> anyone still using darcs?
20:44:08 <Clint> sadly yes
20:44:12 <merijn> Welkin: The problem is not "git has a learning curve"
20:44:25 <ReinH> merijn: let me take a step back. What behavior do you want exactly?
20:44:31 <merijn> Welkin: The problem is "git's UI is aggressively user hostile and ad hoc with no regard for workflow"
20:44:48 <ReinH> "how do I tel it to pull from there"... what are "it" and "there"?
20:45:42 <ReinH> If the question is "how do I make `git pull' when checked out to the master branch automatically pull the master branch from the origin remote?" then my answer should be correct
20:45:47 <merijn> ReinH: Pull already normally pulls from GHC upstream. "remote set-url --push" let me make "git push" default to my github. Now occasionally I need to sync with my github so I want to just run "git pull pushdestination"
20:46:01 <ReinH> Ah.
20:46:17 <merijn> In Mercurial I'd just run "hg pull default-push"
20:47:03 <Clint> i still think adding your github repo as a remote is the easiest thing
20:47:20 <ReinH> merijn: let's say GHC upstream is `origin' and your remote is `merijn'. If you want to default pulls from origin, use the first git config command.
20:47:25 <merijn> Welkin: It's especially painful if, like me, you started with Mercurial. Mercurial's underlying model is pretty much isomorphic with git's (there's a transparent conversion extension that lets mercurial interact with git, that's how similar)
20:47:41 <ReinH> If you then want to pull or push to/from your remote, git pull merijn or git push merijn
20:48:01 <merijn> Welkin: Mercurial interface has considerably more attention put into consistency and simplicity of the commands
20:48:16 <ReinH> the second git config command ensures that either way, the matching remote branch will be `refs/heads/master'
20:48:56 <ReinH> i.e. push/pull master to/from master
20:49:05 <merijn> ReinH: I don't have a "merijn" remote and I have no idea how to add it
20:49:26 <ReinH> git remote add merijn <url>
20:49:30 <begriffs> Is there a shortcut to using catchJust with an exception that is an instance of Typeable? Can that typeclass help write me a function from Exception -> Maybe MyException ?
20:49:51 <merijn> begriffs: All exceptions are instances of Typeable
20:50:39 <ReinH> where url is git@github.com:merijn/ghc.git
20:50:49 <nbvcdrdd> hey i need help with a regex..
20:50:49 <ReinH> or https://github.com/merijn/ghc.git
20:51:20 <nbvcdrdd> ?
20:51:25 <ReinH> nbvcdrdd: ?
20:51:32 <Clint> that's a very simple regex
20:51:45 <merijn> begriffs: Can you explain what you're trying to do?
20:51:47 <ReinH> (invalid though)
20:52:02 <Clint> not if you count the space
20:52:19 * ReinH sighs
20:52:53 <php_on_rails> i have mo'nads
20:52:54 <TallerGhostWalt> ReinH: earlier you posted a link to merijn about Ran during a conversation with kmett concerning lens as profunctors... can you repost?  I lost it in my log :(
20:53:20 <merijn> TallerGhostWalt: ircbrowse logs all of #haskell
20:53:23 <ReinH> TallerGhostWalt: Um...
20:53:23 <begriffs> merijn: The exception in question is "Error" from the hasql package. I'd like to catch only these, but the function I've written seems not to discriminate and to catch nothing. I can also write a predicate that catches everything, but not just the one I want.
20:53:51 <php_on_rails> if exception = 'Error'
20:53:55 <TallerGhostWalt> sigh... fair enoguh
20:53:57 <php_on_rails> else:
20:54:07 <TallerGhostWalt> merijn: thanks!
20:54:09 <php_on_rails> suck a dick
20:54:14 <merijn> begriffs: If you make sure your handler has Error as input type it automagically works
20:54:29 <ReinH> tlevine: can you be slightly more specific?
20:54:44 <begriffs> I'll run one more test then post a gist of the code. The function seems pretty simple, not sure what's going on.
20:55:00 <ReinH> er
20:55:04 <ReinH> TallerGhostWalt: can you be slightly more specific?
20:55:08 <merijn> :t catchJust (\(e :: Error) -> Just 'c')
20:55:09 <lambdabot>     Expecting one more argument to ‘Error’
20:55:09 <lambdabot>     Expected kind ‘*’, but ‘Error’ has kind ‘* -> Constraint’
20:55:09 <lambdabot>     In the type ‘Error’
20:55:21 <ReinH> begriffs: you broke GHC! :)
20:55:33 <php_on_rails> why don't you just use Python?
20:56:02 <ReinH> php_on_rails: Is this your first time trying to troll #haskell? Welcome!
20:56:06 <MP2E> lol
20:56:21 <merijn> ReinH: Don't feed the bridge dwellers :)
20:56:50 <ReinH> I'm sure deep down they're just looking for love... and the sweet, sweet, embrace of Haskell
20:57:45 <TallerGhostWalt> ReinH: it's okay I don't mind looking for it in ircbrowse
20:58:00 <ReinH> TallerGhostWalt: I gave it a quick look and didn't see it :(
20:58:09 <ReinH> Oh!
20:58:13 <ReinH> I think I remmeber...
20:58:25 <php_on_rails> I am Functionally Retarded
20:58:26 <ReinH> TallerGhostWalt: was it... http://www.cs.ox.ac.uk/ralf.hinze/Kan.pdf ?
20:58:55 <ReinH> php_on_rails: would you like to learn some Haskell?
20:59:34 <php_on_rails> Yes!!!!
20:59:55 <ReinH> php_on_rails: Excellent decision.
21:00:02 <ReinH> php_on_rails: where would you like to start?
21:00:08 <php_on_rails> Your mom
21:00:13 <php_on_rails> I want to start with your mom.
21:00:18 <ReinH> Ah. Clever. But I've heard that one before.
21:00:20 <merijn> ReinH: Why are you bothering?
21:00:25 <php_on_rails> Your mom is very functional.
21:00:28 <TallerGhostWalt> http://www.cs.ox.ac.uk/ralf.hinze/Kan.pdf
21:00:30 <ReinH> merijn: It's 9pm on a friday night?
21:00:31 * ReinH shrugs
21:00:35 <merijn> ReinH: Responding just encourages more talking
21:00:36 <ReinH> TallerGhostWalt: I just posted that :p
21:00:38 <TallerGhostWalt> ReinH: !
21:00:49 <ReinH> php_on_rails: well, that much is true
21:00:57 <TallerGhostWalt> Thanks now... to read!
21:00:58 <solatis> how do i decide if I need a TMVar or an MVar? If I want to do 'more complex things' within STM, I use a TMVar, otherwise default to MVar ?
21:00:59 <ReinH> Was that supposed to be insulting
21:01:06 <php_on_rails> MRvar
21:01:10 <php_on_rails> mentally retarded var
21:01:14 <php_on_rails> that is like all of you
21:01:18 <solatis> or are there performance benefits to using TMVar over MVar ?
21:01:19 <merijn> solatis: Depends on the number of expected waiting threads
21:01:30 <merijn> solatis: TMVar suffers from thundering herd problem
21:01:36 <merijn> solatis: MVar guarantees single wakeup
21:01:37 <php_on_rails> Your mom is the only waiting thread
21:01:39 <solatis> ok
21:01:42 <solatis> then MVar it is
21:01:42 <merijn> @where ops
21:01:43 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
21:01:47 <php_on_rails> Your mom wakes up single guaranteed
21:01:58 --- mode: ChanServ set +o Cale
21:02:04 <php_on_rails> Hello
21:02:05 <ReinH> They try so hard. It's kind of cute.
21:02:05 <solatis> thanks cale
21:02:05 --- mode: Cale set +b *!*@199.180.249.102
21:02:05 --- kick: php_on_rails was kicked by Cale (php_on_rails)
21:02:11 <TallerGhostWalt> merijn: can you say more about the thundering herd problem or pointer?
21:02:12 --- mode: Cale set -o Cale
21:02:56 <merijn> TallerGhostWalt: Thundering herd should show up on google, but it's basically "1000 threads blocked on a TVar" -> TVar changes -> "1000 threads wake up and are scheduled to run, even though all but the first block immediately again"
21:03:09 <solatis> right
21:03:14 <ReinH> TallerGhostWalt: That's a fun paper! It points out that all of this was just an exercize in Mac Lane :D
21:03:17 <merijn> MVar guarantees only a single thread is woken up
21:03:40 <solatis> so what is the advantage of using TMVar?
21:03:49 <solatis> if i need additional STM on top of my MVar?
21:03:50 <merijn> You can use it transactionally? :)
21:03:55 <merijn> solatis: Yeah
21:03:56 <ReinH> TallerGhostWalt: But after you read the Codensity paper, also read Ed's http://comonad.com/reader/2011/free-monads-for-less/
21:04:07 <TallerGhostWalt> merijn: very interesting
21:04:09 <merijn> solatis: If you don't need any complex transactions, MVar is much cheaper
21:04:12 <solatis> ok, so the default choice should be MVar, unless you need more
21:04:15 <TallerGhostWalt> ReinH: also interesting
21:04:26 <TallerGhostWalt> balancing wanting to know more about low end and high end is so hard
21:04:26 <solatis> thanks merijn, that was the info i was looking for
21:05:58 <Cale> It would be so cool if STM transactions which weren't really being used transactionally were somehow as fast as their non-STM counterparts.
21:06:22 <TallerGhostWalt> I felt like that stuff edwardk was saying about lenses on transformers , and defining monoid with a tensor to unify the sum and product distnction sounded so interesting
21:07:09 <merijn> ReinH: So I added a remote but now when I run "git pull merijn" it complains that I didn't specify a branch
21:07:37 <merijn> Cale: The problem here is not one of speed, but that STM blocking has fundamentally different semantics than MVar
21:07:58 <begriffs> merijn: here is an excerpt from my exception mystery code. The fact that I'm seeing an error report on stdout means it got past my handler somehow. https://gist.github.com/begriffs/1df158ade342441975dc
21:07:59 <carter> TallerGhostWalt: a good way to avoid thundering herd is have threads sleep for a random amount of time
21:08:05 <merijn> Cale: The TMVar changes may trigger any number of different code paths in the retry
21:08:07 <carter> i dont understand TVar sleep that well
21:08:31 <merijn> carter: The problem is not the sleep, but TVar's don't have single wakeup on changes
21:08:36 <ddellacosta> opinions on the best introduction to arrows?  Not finding this one easy to grasp so far: https://www.haskell.org/haskellwiki/Arrow_tutorial
21:08:44 <carter> ddellacosta: you dont need arrows
21:08:48 <carter> applicative :)
21:08:48 <ddellacosta> wow, that was fast
21:08:50 <Cale> merijn: Well, yes, but if you don't make use of this, it would be nice if the compiler were smart enough to compile to (at least approximately) the same thing.
21:09:05 <ddellacosta> carter, is there still no utility in learning about them?
21:09:08 <Welkin> what are the best GUI frameworks that haskell supports?
21:09:18 <Cale> merijn: There are a bunch of things you'd have to watch out for, but it seems like there are a fair number of cases where you could skip the transaction log altogether
21:09:18 <ReinH> merijn: hmm
21:09:20 <carter> ddellacosta: ... do you understand applicatives yet?
21:09:29 <carter> Cale: fryguy is working on that i'm told
21:09:35 <ddellacosta> carter: barely.  So I guess I should focus on those first?
21:09:35 <Welkin> I read that Qt has great documentation and runs on nearly everything
21:09:35 <php_on_rails_> Hello
21:09:40 <carter> ddellacosta: yup
21:09:40 <merijn> begriffs: What does sqlErrHandler do?
21:09:40 <ddellacosta> oh, it's back
21:09:53 <ddellacosta> carter, okay, that gives me a direction.  Thanks!
21:10:01 <Cale> php_on_rails_: Are you ready to be a human being, or do I have to kick you again?
21:10:40 <Welkin> php_on_rails_: what a name...
21:10:53 <ReinH> ddellacosta: Arrows are interesting, but you can have a very productive Haskell career without ever using them
21:10:58 <TallerGhostWalt> I definitely use the TVar abstraction in a way that would cause tis
21:11:02 <merijn> ReinH: I just did "git remote add merijn URL" in addition to the "remote set-url --push"
21:11:04 <TallerGhostWalt> Going to have to review that stuff
21:11:14 <carter> TallerGhostWalt: my solution is to use mvars :)
21:11:15 * carter ducks
21:11:16 <begriffs> merijn: https://gist.github.com/begriffs/3c77665664b86c84bbaf
21:11:20 <TallerGhostWalt> yep
21:11:20 <Kaidelong> wikipedia says Haskell is self-hosting, as far as I know this isn't true of any of the Haskell aimplementations around right now?
21:11:22 <TallerGhostWalt> makes sense
21:11:24 <ReinH> merijn: did you do the git config branch.master.merge refs/heads/master ?
21:11:29 <Cale> Kaidelong: GHC
21:11:33 <TallerGhostWalt> carter: Gonna switch
21:11:35 <simpson> Kaidelong: GHC's self-hosting, right?
21:11:41 <geekosaur> define self-hosting
21:11:44 <Kaidelong> I thought GHC had parts written in C++, Perl, and Python?
21:11:45 <merijn> Kaidelong: Self-hosting just means "Compiler implemented in the language it compiles"
21:11:48 <ReinH> for some value of self-hosting
21:11:51 <carter> TallerGhostWalt: basically, anything with high contention and you're only working on a single var, use MVar
21:11:59 <merijn> Kaidelong: The runtime has some parts in C++, not the compiler
21:12:02 <merijn> eh, C
21:12:10 <carter> TMVar only makes sense if you NEED multiple mutable vars with transactional updates
21:12:11 <Kaidelong> oh okay, mmm
21:12:17 <TallerGhostWalt> carter: yeah I use it for a write locking mechanism
21:12:19 <Kaidelong> so the compiler can compile itself
21:12:23 <Kaidelong> I guess that's all you need
21:12:29 <ddellacosta> ReinH: thanks for the context--yeah, I was more just curious about them, especially when I read that they could be considered abstractions of monads
21:12:29 <merijn> Kaidelong: It's not impossible to change the runtime to be pure haskell, there's just not much to gain from it
21:12:40 <carter> TallerGhostWalt: a lot of use cases fit "put a large pure thing under an MVar"
21:12:44 <geekosaur> you can't write the guts of the runtime in haskell, unless you define a subset of haskell that can be implemented without garbage collection so you can write the garbage collector in it
21:12:46 <carter> oh, so only one MVar
21:12:49 <tarpman430> hello
21:12:53 <ReinH> ddellacosta: The most important typeclasses are covered in the Typeclassopedia (https://www.haskell.org/haskellwiki/Typeclassopedia)
21:12:54 <geekosaur> etc.
21:12:55 <vanila> hi
21:12:56 <php_on_rails1> hello
21:12:58 <carter> geekosaur: thinking about hw to do that
21:12:59 <vanila> hi
21:13:00 <merijn> ReinH: That gives the same error
21:13:02 <ReinH> ddellacosta: note that Arrow is second to last ;)
21:13:02 --- mode: ChanServ set +o Cale
21:13:11 <ReinH> merijn: Then I am unsure. My git fu is not what it once was. Sorry.
21:13:13 <TallerGhostWalt> carter: yeah exactly
21:13:14 <merijn> ReinH: (the git config command and then pull)
21:13:21 <merijn> I'll take it to -blah
21:13:25 <ddellacosta> ReinH: gotcha, yeah I keep finding myself back at the Typeclassopedia somehow...haha. :-)
21:13:26 <ReinH> merijn: I usually just say "git pull remote HEAD"
21:13:33 <carter> TallerGhostWalt: whats also awesome is that MVar over large pure thing === transactional reads are free ish
21:13:47 <ReinH> (I actually think comonads are more useful than arrows, but that's another discussion)
21:13:54 <php_on_rails1> hehe
21:15:35 <ddellacosta> ReinH: I'll file that away and provoke you to discuss it at a later date, once I am more conversant in the types you are talking about. :-)
21:15:50 <php_on_rails1> hello
21:16:03 <merijn> begriffs: Colour me confused then
21:16:30 <ReinH> ddellacosta: well file this away with it https://www.fpcomplete.com/user/edwardk/cellular-automata
21:16:32 <augur_> anyone know of a good overview of debugging techniques? like, a study of how people locate and diagnose bugs?
21:16:50 <begriffs> merijn: Yeah it's pretty weird, thanks for looking at it.
21:17:05 <ddellacosta> ReinH: oh, lovely link, thanks
21:17:27 <php_on_rails1> @augur_ http://en.wikipedia.org/wiki/Bugchasing
21:17:27 <lambdabot> Unknown command, try @list
21:17:32 <ReinH> augur_: no, but am would like to subscribe to your newsletter
21:17:38 <php_on_rails1> http://en.wikipedia.org/wiki/Bugchasing
21:18:09 <augur_> php_on_rails1: ..
21:18:44 <augur_> ReinH: wat
21:18:48 <php_on_rails1> wat???
21:18:55 <php_on_rails1> a/s/l??
21:18:58 --- mode: Cale set +b *!*@184.153.109.229
21:18:59 --- kick: php_on_rails1 was kicked by Cale (php_on_rails1)
21:19:00 <MP2E> rofl
21:19:02 <augur_> well then
21:19:15 <ddellacosta> *sigh* it's like wack-a-mole
21:19:19 <MP2E> someone took a wrong turn on his way to AIM
21:19:26 <vanila> what-a-trole
21:19:32 <vanila> whack*
21:19:32 <MP2E> haha
21:19:47 <ddellacosta> oh, I suspect that character knows exactly what s/he is doing, sadly
21:19:52 <Cale> Let's see if php_on_rails_ wants to comment.
21:20:02 <merijn> I recommend not even acknowledging their presence indirectly
21:20:06 <augur_> i dont get what the purpose of this behavior is
21:20:07 <augur_> anyway
21:20:08 <ddellacosta> yeah, fair enough
21:20:09 <augur_> ReinH: what?
21:20:11 <MP2E> ok merijn
21:20:15 <merijn> i.e. discussion of trolls beyond kicking is still counter productive
21:20:15 <ddellacosta> yes, anyways
21:20:18 <ddellacosta> yep
21:20:33 <begriffs> augur_: There's always traceShow in Debug.Trace. Kind of primitive but helpful.
21:20:41 <Cale> Not *always*, but this particular kind of troll is not worth interacting with.
21:21:22 <Cale> There's a certain kind of troll which can be usefully interacted with by simply providing useful information that other people will likely benefit from regardless.
21:21:27 <augur_> begriffs: i wonder also if anyone has written on the philosophy of debugging
21:21:38 <Cale> and sometimes that can result in better outcomes than just ignoring them
21:21:56 <vanila> sometimes a "troll" is just someone who didn't learn the correct behavior yet, or has come from a different culture
21:22:12 <ReinH> augur_: If you find any good literature on debugging, I would be interested to know about it
21:22:22 <augur_> there's a sense in which debugging has certain ontological and valuative commitments
21:23:01 <vanila> zen and the art of program execution
21:23:14 <augur_> like, ontologically, you're assuming that there is something to go after to explain what the cause of the bug is, which of course valuatively presuppose certain kinds of fixes are better than others
21:23:44 <augur_> ie when you encounter a bug in your function f, say, you generally don't write a function f' that wraps f and patches over the buggy cases
21:24:16 <augur_> thats a solution, but a "less valued" one, than the solution that finds the cause of the divergent behavior
21:24:37 --- mode: Cale set -o Cale
21:24:43 <begriffs> augur_: there's that whole Dijkstra school of thought like, "We could, for instance, begin with cleaning up our language by no longer calling a bug a bug but by calling it an error. ... The animistic metaphor ... is intellectually dishonest as it disguises that the error is the programmer's own creation." https://www.cs.utexas.edu/~EWD/transcriptions/EWD10xx/EWD1036.html
21:25:11 <augur_> begriffs: i dont know that thats much of a help, to be honest
21:25:19 <Cale> My initial response to such a book is "please kill me" :D
21:26:58 <begriffs> augur_: agreed. Didn't know what you mean by philosophizing about bugs, thought I'd throw it out there.
21:27:01 <merijn> I value Dijkstra's philosophy on programming, but I don't think this particular argument is very worth persuing
21:27:39 <begriffs> I feel kind of bad to district the chat with it, sorry I'll get back to being productive and...debugging my exception issue. :)
21:27:56 <begriffs> *distract
21:29:41 <dfeuer> Cale, you have a moment?
21:30:07 <ReinH> vanila: :)
21:30:13 <Cale> all right
21:30:30 <dfeuer> Was that a response to me?
21:30:37 <Cale> yes
21:31:36 <dfeuer> Well, I'm trying to figure out how to make <*> for Data.Sequence.Seq optimal, and I have a vague concept, but I'm not sure it's right/sane.
21:32:13 <Cale> hmm
21:32:44 <Cale> I don't know if it's possible to do much better than worker/wrapper with a list.
21:32:52 <dfeuer> The idea is to use the general structure of Ross Paterson's fromList' implementation here: https://www.haskell.org/pipermail/haskell-cafe/2014-November/117032.html
21:33:14 <Cale> oh, you're messing around with the trees directly
21:33:30 <dfeuer> But instead of doing things listy, I think the thing to do is to pass around a memoization table of ways to split the right-hand argument.
21:33:35 <dfeuer> Maybe.
21:33:42 <dfeuer> Except that sounds insane.
21:34:03 <Cale> You might be able to do some kind of time/space tradeoffs
21:34:29 <dfeuer> Well, okay, so maybe I'm over-thinking this. Maybe it's actually good enough to just split as needed?
21:34:32 <Cale> It seems kind of crazy to complicate the code for what's likely to be a small adjustment to the constant factor complexity
21:34:58 <dfeuer> It's not actually constant-factor, I don't think.
21:35:08 <dfeuer> Well, not in all contexts.
21:35:51 <dfeuer> For example, if I'm not mistaken,   last (fs <*> xs) is O(|fs|*|xs|)
21:35:55 <Cale> Well, it's an O(nm) operation
21:35:56 <Cale> yes
21:35:58 <dfeuer> But I don't think that has to be the case.
21:35:59 <Cale> er
21:36:02 <Cale> wait, last?
21:36:05 <dfeuer> Yeah.
21:36:11 <Cale> hmm
21:36:22 <dfeuer> I could be wrong, but I *think* it builds all the thunks along the way.
21:36:45 <Cale> yes, well, it would if you're implementing it with fromList/toList
21:36:48 <dfeuer> But it actually can be obtained in O(1) time.
21:36:58 <Cale> So, I suppose you can try to avoid that, yes
21:37:00 <dfeuer> Yeah, and I don't think the current implementation is different in that regard.
21:37:16 <dfeuer> Although I could be mistaken.
21:37:22 <moriarty> you could be, indeed
21:37:23 <Cale> Actually, what if you just use Seq.concat and fmap?
21:37:40 * dfeuer goes to look.
21:37:57 <Cale> Oh, is there an operation Seq (Seq a) -> Seq a?
21:38:10 <dfeuer> Hmmmm
21:38:41 <Cale> Maybe that's not implemented
21:38:50 <marchdown> how do I check if three numbers are equal? x == y == z does not work, nor does (x == y) and (y == z), nor foldl1 (==) [x, y, z].
21:38:51 <Cale> So that's the operation you'd want to focus on probably
21:39:02 <Cale> (join for the corresponding monad)
21:39:10 <dfeuer> Cale, that may make sense, yeah.
21:39:14 <simpson> marchdown: x == y && x == z
21:39:20 <marchdown> thanks
21:39:35 <marchdown> why doesn’t fold version work?
21:39:37 <dfeuer> That removes one level of complication, I think.
21:39:51 <dfeuer> But it's still complicated.
21:40:01 <dfeuer> Er ...
21:40:12 <Cale> marchdown: for the same reason that x == y == z doesn't typecheck
21:40:19 <dfeuer> No, Cale, you're wrong.
21:40:22 <Cale> (unless x, y, and z are all Bools)
21:40:24 <dfeuer> join is actually too general.
21:40:33 <Cale> dfeuer: oh?
21:40:57 <dfeuer> The advantage of <*>  over >>= for Seq is that you can calculate the length of <*> immediately from the lengths of its arguments.
21:41:44 <jle`> marchdown: expand it out :)
21:41:47 <dfeuer> So the shape of the tree is determined, and you can avoid any rebuilding.
21:42:01 <jle`> @src foldl1
21:42:01 <lambdabot> foldl1 f (x:xs) = foldl f x xs
21:42:01 <lambdabot> foldl1 _ []     = undefined
21:42:04 <jle`> and you shall see
21:42:07 <jle`> @src foldl
21:42:07 <lambdabot> foldl f z []     = z
21:42:07 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:42:16 <dfeuer> Well, that's why <*> can get better constant factors at least. It may be possible to get good asymptotics with join....
21:43:04 <Cale> I don't see how you're going to avoid rebuilding tree structure in any case
21:43:24 <Cale> There's really not a lot of sharing you can do, because none of the trees will in general have any elements in common.
21:43:31 <dfeuer> Take a look at https://www.haskell.org/pipermail/haskell-cafe/2014-November/117032.html
21:44:10 <marchdown> I see, thanks. with regard to types it should have been all (x ==) [y, z]; and that works.
21:44:57 <Cale> dfeuer: Well, this explicitly builds a tree
21:45:06 <jle`> marchdown: :D
21:45:16 <Cale> dfeuer: I guess it doesn't do it by adding one element at a time
21:45:56 <dfeuer> No, no sharing for <*> (only for *>), but you can build the tree top-down, I think, and avoid any do-overs. But there's extra book-keeping involved that could be an issue. If the right-hand argument is short, that's minimal; if it's long ... I'm not sure.
21:46:32 <dfeuer> But I think your idea of looking into join is a good one too.
21:48:27 <Cale> I see what you're getting at now though.\
21:49:22 <Cale> I'm not sure what you mean about the memo tables
21:50:33 <dfeuer> I think the memo tables thing may be insane.
21:51:15 <dfeuer> But here's the issue I'm thinking about:
21:51:20 <Cale> The important thing being that you can sort of do what mkTree in this post does, only, not with a list, but instead with these two input lists fs and xs, and perhaps a pair of (start,end) indices that you want to construct
21:51:33 <dfeuer> Yes, that was my vague idea.
21:52:04 <Cale> input sequences* rather
21:52:40 <dfeuer> The problem, I think, is that knowing the indices and having the sequences doesn't get you anything for free; you have to get to the right places in those sequences.
21:52:53 <Cale> Well, splitting sequences is cheap
21:53:39 <Cale> (certainly cheaper than splitAt for lists)
21:53:40 <danilo2> Hello! Is there any heterogenous map in haskell which bases on typeable objects?
21:53:41 <dfeuer> Cheap near the ends. If you split the same sequence over and over, I think you could be adding an O(log n) factor to the total cost of m<*>n
21:53:53 <dfeuer> I could be wrong though.
21:54:41 <dfeuer> The lunaticky memo table concept was to try to save splits, and then split near known split points. But I'm sure that's the wrong way.
21:55:49 <Cale> hmm
21:57:36 <Cale> dfeuer: I can imagine something might exist which wouldn't involve memoisation as such, but which takes the parts of xs that will be needed near the start and end of the range as arguments
21:58:09 <Cale> (which is in itself a kind of memoisation)
21:58:52 <Cale> It sounds awful to have to write though :D
21:59:06 <Cale> Do you get what I mean?
21:59:28 <dfeuer> Not yet.
22:00:34 <dfeuer> Oh wait, do you mean figuring out which ones *will* be needed from the start?
22:00:39 <Cale> yes
22:00:51 <Cale> When you chop the problem in two
22:01:17 <dfeuer> Well, as long as you can avoid actually calculating them at the start...
22:01:25 <Cale> you work out the index to cut the whole list at (which really just affects the start and end indices that get passed along)
22:01:50 <dfeuer> You don't usually chop the problem in two.
22:02:06 <dfeuer> Which is one of the things that makes this structure so confusing.
22:02:26 <Cale> Or k
22:02:47 * dfeuer really needs to draw some pictures, but first should go to sleep.
22:03:51 <dfeuer> Thanks, Cale. I'll think about this some more, and try some things.
22:04:40 <Cale> You might still end up chopping up xs at the same place a bunch of times...
22:05:11 <Cale> But I dunno, at least when you start cutting parts off of the end where you already cut, maybe you save a bunch of time there
22:06:13 <dfeuer> At the end where you already cut ...
22:06:58 <dfeuer> I don't know. I'm sure there's some math behind these cut points too. All sorts of prime numbers and GCDs and things.
22:09:06 <begriffs> merijn: I figured out the exception thing. Both Hasql and Hasql.Backend export an Error type. I had to be careful to catch specifically the one from Hasql.Backend. Not sure if this kind of nuance is normal in a Haskell library.
22:10:04 <merijn> begriffs: I'd consider that pretty bad design
22:10:31 <begriffs> K, I'll file an issue on its github project
22:12:00 <michaelt> dfeuer: now that you are a build/foldr expert, check out my variant for monadic lists (FreeT ((,) a) m r, Producer a m r, etc)  Somehow it is doing better than Data.List, so far .... http://michaelt.github.io/bench/seriesbench.html
22:12:24 <dfeuer> "expert" is exaggerating.
22:12:51 <michaelt> dfeuer: Ah, well, I read some of your remarks on the list ...
22:13:02 <dfeuer> I've gotten some sense of some of it.
22:13:30 <dfeuer> michaelt, I'm not sure what Criterion is reporting there.
22:13:44 <dfeuer> Also, what are "monadic lists"?
22:14:24 <solatis> dfeuer: it could be anything, it could be nothing
22:14:38 <michaelt> ListT done right , for example.  In this case I am trying to optimize pipes Producer
22:15:58 <trap_exit> if my laptop is SSD -- is there any reason I have to fear for magnets ?
22:16:00 <michaelt> a monadic action is necessary to access the next item of the list , e.g. newtype ListT m a = ListT (Maybe (a, ListT m a))
22:16:31 <michaelt> woops newtype ListT m a = ListT (m (Maybe (a, ListT m a)))
22:17:06 <michaelt> ordinary lists are equivalent to the specialization to ListT Identity a
22:17:08 <c74d> trap_exit: There should be some magnetic shielding on it, if it’s recent.
22:17:19 <dfeuer> OK.
22:17:25 <c74d> (I don’t know much on the subject, though.)
22:17:32 <trap_exit> are there any parts of a laptop that would be weak to magnets ?
22:17:54 <dfeuer> So ListT has nothing directly to do with actual lists?
22:18:11 <merijn> trap_exit: Screens don't particularly like magnets
22:18:21 <trap_exit> merijn: even LCD screens ?
22:18:28 <ReinH> trap_exit: try it!
22:18:31 * ReinH ducks
22:18:44 <michaelt> dfeuer: so I was testing a build/foldr framework and ListT Identity a turns out to be faster than Data.List .... but there must be downsides ...
22:18:48 <trap_exit> ReinH: I provide magnet. YOu provide screen. Okay?
22:18:56 <dfeuer> LCDs do better than CRTs in that regard.
22:19:31 <trap_exit> in the same way that getting hit by a bullet is better than getting hit by a nuke?
22:19:59 <ReinH> michaelt: that is... surprising..
22:20:06 <dfeuer> michaelt, well, it's not a list. I would guess you might be bypassing the difficulties of fusion by skipping the fusion part.
22:20:59 <ReinH> dfeuer: it's isomporphic to a list (up to bottoms)...
22:21:04 <michaelt> oh, the rules are firing like crazy.  i'm sure there is some trouble to come, these are all very conventional compositions.
22:21:39 <dfeuer> michaelt, I'd be interested in seeing the actual code you're talking about.
22:21:49 <dfeuer> No guarantee I'll understand it.
22:21:55 <michaelt> here's the shambolic library as it stands  https://github.com/michaelt/series fwiw
22:23:01 <dfeuer> michaelt, have you looked at the Core each generates? Are some fusion opportunities missed for lists?
22:23:19 <nshepperd> about as surprising as when I was messing around with the foldl package and found that FoldM Identity a b was faster than Fold a b in some case
22:23:37 <nshepperd> I guess it was just optimized more
22:23:55 <dfeuer> nshepperd, that is odd.
22:24:02 <nshepperd> since I think they should be identical once inlined
22:24:36 <michaelt> i wonder about that, as I said, I just started testing, and am using piles of compositions like sum . take n . map f . iterate and so on, and checking for rule firings and comparing Data.Vector.Unboxed and Data.List with my feeble attempts
22:24:50 <ReinH> I am confused now.
22:25:28 <dfeuer> michaelt, try some mapM and scanl and fun things like that.
22:26:22 <michaelt> hm, I'm just testing the pure case, I'll try to devise a test for mapM which is already defined.
22:26:56 <dfeuer> michaelt, you are talking about the Series type, right?
22:27:39 <michaelt> if there is anything worth thinking about it is that I am using a wrapped type that would be like using a wrapped type that would be like using Fold (forall b . (a -> b -> b) -> b ->  b)
22:28:11 <michaelt> dfeuer: yes,, Series ((,) a) Identity () is [a]
22:29:06 <dfeuer> Some of that stuff is just a bit over my head :-/
22:29:39 <michaelt> When defining a function Series -> Series, say , I melt it into a Fold , fiddle with the Fold, and then 'build'
22:30:08 <michaelt> dfeuer: the readme is slightly insane; mostly notes to myself
22:30:30 <dfeuer> No, I'm just ignorant. I don't understand pipes yet, for example.
22:31:12 <michaelt> pipes arent relevant, though the purpose is to optimize an aspect of them
22:32:34 <michaelt> dfeuer: anyway, its not that interesting, but I was wondering if this device of using an intermediate wrapped rank2 type might have something in it from a data.list point of view.
22:33:26 <michaelt> somehow the compiler seems to recognize every case for elimination, given the rule foldStream . buildStream = id .
22:33:46 <dfeuer> I will try to understand more after I've slept. I think I'm probably some months away from understanding, though. Your elimination rule is peculiarly simple.
22:34:25 <michaelt> dfeuer: yes, it's like the one in vector, except its regular build/foldr optimization
22:34:47 <michaelt> in vector the main rule is stream . unstream = id
22:36:16 <dfeuer> michaelt, how do you define simple things like cons and uncons?
22:36:42 <dfeuer> Oh, I guess uncons is just a fold
22:36:46 <dfeuer> But what about cons?
22:37:05 <dfeuer> Er...
22:37:08 <dfeuer> No, it's not a fold.
22:37:10 <dfeuer> I'm too sleepy.
22:37:25 <michaelt> hm, maybe i havent got to cons yet just a sec
22:37:43 <dfeuer> and uncons :P
22:37:52 <dfeuer> I'm not saying they'll be problems.
22:37:57 <dfeuer> Just trying to understand.
22:38:02 <michaelt> there's a "naive" cons , but how it would be fitted with the underlying fold framework dunno
22:39:15 <michaelt> dfeuer: I was thinking there was going to be more trouble where you get out of the standard combinators and e.g. deal directly with the constructors.
22:39:31 <dfeuer> The Construct constructor seems weird.
22:40:07 <michaelt> but in theory Data.List should be good with long compositons like  sum . take n . map f . replicate m
22:40:19 <dfeuer> let foo = Construct (Identity foo) in foo ?
22:40:38 <dfeuer> Long compositions can definitely have issues with the inliner.
22:40:40 <michaelt> dfeuer: the naming is ridiculous, i keep changing it; there I am being influenced by somethingn in Atkey
22:40:51 <ReinH> michaelt: that example doesn't require fusion though, right?
22:40:59 <ReinH> just lazy evaluation
22:41:00 <solatis> ok, I want to let multiple threads make use of a single (non-thread-safe) socket. in c++ i would just use a mutex. what's the haskell equivalent? a Bool MVar?
22:41:00 <dfeuer> No idea who Atkey is.
22:41:10 <solatis> or using STM?
22:41:38 <ReinH> solatis: Have a single thread manage the socket and communicate with it via a TChan?
22:41:41 <merijn> MVar ()
22:41:57 <merijn> solatis: ZMQ socket?
22:42:01 <solatis> ReinH: that essentially adds an in-process queueing layer, which is exactly the thing i like to avoid
22:42:03 <michaelt> infinite ones would be: ones = Construct (1 :> ones)
22:42:07 <solatis> merijn: ack
22:42:13 <solatis> merijn: when is your library done? :)
22:42:23 <trap_exit> Parsing is like [Char] -> AST ; is there something that is like Tree -> Tree ? i.e. 'pattern matching over trees' ?
22:42:26 <merijn> solatis: I hope to get in some solid hacking this weekend
22:42:30 <ReinH> solatis: fair enough
22:42:51 <ReinH> solatis: it's a good idea for some cases, not so much for others
22:42:58 <michaelt> ReinH: sum . take n . map f . replicate m would want fusion at each (.) except the one for sum
22:43:06 <ReinH> michaelt: why?
22:43:10 <solatis> merijn: awesome, keep me updated -- my whole application is distributed and put together using zeromq, but i'm currently suffering from some thundering hurd problems
22:43:10 <ReinH> what would be fused?
22:43:16 <michaelt> to avoid intermediate lists?
22:43:20 <solatis> so i would like to remove *all* queueing layers :)
22:43:24 <ReinH> michaelt: Ah. Yes.
22:43:39 <merijn> solatis: I needed to refactor a bunch of stuff, the major pain point is figuring out how to do compatibility testing with libzmq, writing the tests is annoying and it's hard to motivate myself to do annoying things after work :p
22:43:55 <solatis> merijn: i understand
22:43:58 <ReinH> solatis: thundering herd isn't generally solved by making the herd thunder slightly less ;)
22:44:06 <dfeuer> Good night, people. Talk again, michaelt.
22:44:11 <solatis> ReinH: it does make it more transparant and avoids memory overload
22:44:16 <michaelt> be good dfeuer
22:45:02 <ReinH> solatis: well, semaphors don't give you many other options...
22:45:47 <solatis> ReinH: i know, but i would like the problem to be solved 'as close to the metal as possible'
22:45:52 <ReinH> Thundering herd or lock convoy? Which is better? ;)
22:46:07 <solatis> as in, rather have zeromq's queuing mechanism solve the problem, than adding an additional queuing layer on top of it
22:46:15 <ReinH> solatis: full ack
22:46:26 <ReinH> solatis: or at least, don't make two problems
22:46:31 <solatis> exactly
22:46:35 <ReinH> makes sense
22:46:43 <solatis> that's why i asked about sharing the socket
22:46:46 <solatis> so MVar it is
22:46:58 <merijn> I'm not entirely happy with ZMQ's queueing as-is, but that's something for me to bother them on the mailing list about as soon as I figured out how to do sane interoperability testing :p
22:46:59 <solatis> MVar basicly is a more-flexible mutex
22:47:33 <solatis> merijn: i know. you're building a pure haskell implementation of the protocol, eh?
22:47:41 <merijn> solatis: That's actually done
22:47:49 <merijn> The socket bit is the hard part :p
22:47:56 <solatis> yeah
22:48:06 <solatis> the guy maintaining zeromq-haskell does have a fair amount of clue, tho
22:48:28 <solatis> i discovered some bug, and he fixed it in a very short timespan
22:48:33 <solatis> and it was not an easy fix
22:49:37 <solatis> merijn: https://github.com/twittner/zeromq-haskell/issues/55
22:49:39 <solatis> those kind of issues
22:49:52 <solatis> but, on the other hand, it does show how fragile his implementation is, kind of :)
22:50:41 <solatis> merijn: and then you get these kind of fixes: https://github.com/twittner/zeromq-haskell/commit/4a6bc238dcc81cee4c8407c32edb018e371ab1e4
22:52:45 <ReinH> solatis: Honestly, this sort of thing still scares me in Haskell :/
22:52:59 <ReinH> lowish-level networking + laziness = o_O
22:53:06 <merijn> solatis: This is mostly a problem with the C++ design not meshing well with haskell
22:53:24 <solatis> ReinH: yeah
22:53:27 <merijn> solatis: I have a basic implementation of the protocols and sockets in haskell and it works fairly well, no idea about the performance
22:53:47 <merijn> And I still need to carefully audit the exception safety
22:53:52 <merijn> eh
22:53:58 <merijn> s/solatis/ReinH
22:54:20 <solatis> :)
22:54:21 <merijn> ReinH: What's laziness got to do with it?
22:54:32 <solatis> merijn: thread safety i suppose?
22:54:55 <merijn> No, exception safety
22:55:03 <vermeille> Is there a lens to take the last element of a Data.Sequence? I didnt find anything in Data.Sequence.Lens. Am I missing something?
22:55:30 <merijn> I use multiple haskell threads per socket to do bidirectional communication, but that means properly shutting them down using async exceptions
22:55:33 <solatis> i'm scared of sharing my zeromq socket with multiple threads, because i do not know if haskell actually sends the data when i call ZMQ.send
22:55:55 <merijn> But as the huge thread on libraries@ shows exception safety is hard :>
22:56:09 <ReinH> merijn: makes it harder to reason about resource usage?
22:56:27 <ReinH> merijn: Also I read your comment to the tune of "What's Love Got To Do With It?"
22:56:43 <ReinH> resource usage and evaluation order/timing
22:56:47 <merijn> ReinH: Not really? Resource usage is fairly straightforward as long as you don't use lazy IO
22:56:54 <merijn> But lazy IO /= laziness
22:57:07 <solatis> merijn: maybe it's time for conduit-zeromq? :)
22:57:11 <ReinH> hmm
22:57:33 <ReinH> Ok, it is late and I am le tired. TTFN.
22:57:38 <merijn> solatis: I'm using pipes
22:57:43 <solatis> fair enough
22:57:48 <solatis> solving the same problems
22:59:02 * hackagebot Sonnex 0.1.0.1 - Sonnex is an alternative to Soundex for french language  http://hackage.haskell.org/package/Sonnex-0.1.0.1 (zigazou)
22:59:32 <solatis> merijn: ah, i see pipes has better SafeHaskell compatibility
22:59:35 <solatis> that's good to know
23:07:15 <trap_exit> I'm about to jump a plateasu in my haskell skills
23:07:33 <trap_exit> in the context of parsec, wtf is *> , <*, <$>, <*>, ?
23:07:44 <merijn> trap_exit: Control.Applicative
23:08:03 <merijn> trap_exit: Parsec predates Applicative, the combinators are exactly the same as their Applicative equivalents
23:08:27 <trap_exit> <*, >*, are not parsec specific and part of Applicative?
23:08:52 <merijn> trap_exit: Parsec exports Parsec specific versions of those things, but they do the same as their Applicative counterparts
23:08:55 <merijn> :t (<*)
23:08:56 <lambdabot> Applicative f => f a -> f b -> f a
23:09:02 * hackagebot gtk2hs-buildtools 0.13.0.3 - Tools to build the Gtk2Hs suite of User Interface libraries.  http://hackage.haskell.org/package/gtk2hs-buildtools-0.13.0.3 (HamishMackenzie)
23:09:06 <trap_exit> oh, this is too easy
23:09:13 <trap_exit> :t (>*)
23:09:14 <lambdabot>     Not in scope: ‘>*’
23:09:14 <lambdabot>     Perhaps you meant one of these:
23:09:14 <lambdabot>       ‘>>’ (imported from Control.Monad.Writer),
23:09:24 <merijn> :t (*>)
23:09:25 <lambdabot> Applicative f => f a -> f b -> f b
23:09:25 <trap_exit> :t (*>)
23:09:26 <lambdabot> Applicative f => f a -> f b -> f b
23:09:49 <merijn> trap_exit: Those are basically "fmap const" and "fmap (flip const)"
23:10:17 <trap_exit> which in parswec parlance is like "parse this, but throw it away" i.e. (a *> b) = "parse a, throw it away; parse b, return b"
23:10:24 <trap_exit> :t (<?>)
23:10:24 <lambdabot>     Not in scope: ‘<?>’
23:10:24 <lambdabot>     Perhaps you meant one of these:
23:10:24 <lambdabot>       ‘<*>’ (imported from Control.Applicative),
23:10:29 <merijn> trap_exit: Right
23:10:41 <merijn> trap_exit: <?> is parsec specific, it labels a parser with an error notification
23:10:47 <trap_exit> bah, I thought this was going to be black magic, the type signatures make too much sense
23:10:54 <merijn> trap_exit: :)
23:11:01 <trap_exit> :t (<|>)
23:11:01 <lambdabot> Alternative f => f a -> f a -> f a
23:11:15 <trap_exit> okay, this is just 'committing try', as opposed to 'try', which tries without committing
23:11:20 <trap_exit> :t (<$>)
23:11:21 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:11:27 <merijn> trap_exit: No
23:11:44 <trap_exit> hmm, and this type signature almost makes sense, I was expecting (f (a -> b)) -> f a -> f b ... but I guess that is already used by <*>
23:11:47 <merijn> At least, I think no?
23:11:53 <merijn> <$> is fmap
23:12:29 <trap_exit> merijn: what are we disagreeing on? I wrote a bunch of statemnts, then you said "no"
23:12:34 <merijn> trap_exit: try makes a combinator "backtracking"
23:12:53 <trap_exit> <|> does NOT backtrack, in the context of parsec, if the first one consumes input
23:12:55 <merijn> x <|> y  is "parse x, if it fails, parse y"
23:12:57 <trap_exit> "try" does backtrac
23:13:09 <merijn> trap_exit: try only has one argument
23:13:10 <trap_exit> no no, "x <|> y" is if x consuumes input, do not try y
23:13:16 <dmj`> :t (<**>)
23:13:17 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
23:13:21 <dmj`> :t (<*>)
23:13:22 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
23:13:23 <merijn> trap_exit: if 'x' consumes input and fails it will try 'y'
23:13:33 <merijn> trap_exit: But 'y' will most likely fail due to missing input :p
23:13:40 <trap_exit> I'm almost certain "x <|> y" _commits_ to x, if x consumes any input
23:13:49 <trap_exit> hmm
23:13:58 <merijn> trap_exit: More in-depth: http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/
23:14:02 * hackagebot glib 0.13.0.6 - Binding to the GLIB library for Gtk2Hs.  http://hackage.haskell.org/package/glib-0.13.0.6 (HamishMackenzie)
23:14:16 <trap_exit> Back in remainingCells, we have the first example of a choice in Parsec. The choice operator is <|>. This operator behaves like this: it will first try the parser on the left. If it consumed no input[35], it will try the parser on the right.
23:15:14 <merijn> I may be wrong on parsec's backtracking
23:15:22 <merijn> I mostly use attoparsec
23:16:48 <glguy_> If you have x<|>y in parsec and want to try y , you have to have try x <|> y
23:17:05 <glguy_> (want to try y even if x consumes any input)
23:17:11 <merijn> glguy_: See the post I just linked labeled "try a <|> b" considered harmful
23:17:15 <merijn> :p
23:17:26 <solatis> merijn: if i want an exception-safe MVar, should i be looking at TMVar instead, or is withMVar good enough?
23:17:42 <merijn> solatis: It depends on the type of exception safety you need
23:18:01 <solatis> well, it's "take mvar -> ZMQ.send -> put mvar"
23:18:10 <merijn> Use withMVar, yeah
23:18:14 <solatis> ok
23:18:24 <merijn> As long as you don't use async exceptions you'll be fine
23:18:36 <solatis> no i try to keep my code as simple as possible
23:18:52 <solatis> ok awesome, then i have enough info
23:18:54 <glguy_> merijn: Yeah, it's a good idea to use try at the last possible moment
23:19:24 <solatis> gah
23:19:33 <solatis> "However, it is only atomic if there are no other producers for this MVar."
23:19:43 <merijn> solatis: That's true for you, no?
23:19:49 <solatis> they mean that you should *always* follow the same pattern of take -> work -> put ?
23:19:56 <merijn> solatis: Yes
23:19:59 <solatis> ok
23:20:16 <merijn> solatis: Well you don't have to, but if you don't the putMVar may block!
23:20:27 <solatis> yeah i understand
23:20:27 <glguy_> withMVar is fine with async exceptions as long as you don't have a bug where you put something into the MVar inside the withMVar
23:20:34 <solatis> i'm more worried about race conditions, tho
23:20:53 <solatis> i miss c++'s RAII
23:20:58 <dmj`> solatis: why not use a chan? which is a linked list of mvars
23:21:01 <solatis> but bracket / withMVar seem to fill that gap
23:21:22 <solatis> dmj`: because i don't like to solve a queuing problem by implementing another queue on top of it :)
23:21:33 <merijn> solatis: bracket fills the RAII gap, with the only exception that async exceptions can still make things messy, which is a problem you don't have in C++
23:21:37 <dmj`> :) fair enough
23:22:05 <solatis> merijn: c++ has async exceptions now too
23:22:13 <solatis> they are, ehr, equally messy i guess
23:22:42 <merijn> solatis: In C++14?
23:22:49 <merijn> I didn't see async exceptions in C++11
23:23:37 <solatis> hmm wait
23:24:03 * hackagebot cairo 0.13.0.5 - Binding to the Cairo library.  http://hackage.haskell.org/package/cairo-0.13.0.5 (HamishMackenzie)
23:24:09 <solatis> http://en.cppreference.com/w/cpp/thread/async
23:24:11 <solatis> look at that
23:24:14 <solatis> and the exception handling
23:24:43 <solatis> you have to set an 'async | deferred' flag to determine the way exceptions are handled
23:25:00 <solatis> if it is deferred, you get well... deferred exceptions stored in the state of an async struct
23:25:03 <solatis> it's a messy minefield
23:25:13 <solatis> i believe they're attempting to solve the problem in c++17
23:25:47 <solatis> our c++ overlord bartosz is even trying to give c++17 monads :) http://bartoszmilewski.com/2014/02/26/c17-i-see-a-monad-in-your-future/
23:26:06 <merijn> solatis: I can't see whether what they're talking about is what I mean by async exceptions
23:26:34 <solatis> maybe we're not on the same page
23:26:43 <merijn> solatis: Ah, no, that's not what I mean
23:27:01 <merijn> solatis: async here just means that it stores the exception in the "future" and it's raised when you use the future, no?
23:27:20 <merijn> solatis: Haskell has async exceptions which means "exception thrown in the running thread raised in another thread"
23:27:34 <merijn> solatis: i.e. they're like intraapplication posix signals
23:28:00 <merijn> solatis: Which means your code can get excepted in completely unexpected contexts
23:28:20 <merijn> Which is far messier than the async exceptions mentioned in thread::async :)
23:29:03 * hackagebot pango 0.13.0.4 - Binding to the Pango text rendering engine.  http://hackage.haskell.org/package/pango-0.13.0.4 (HamishMackenzie)
23:29:05 * hackagebot gio 0.13.0.3 - Binding to the GIO.  http://hackage.haskell.org/package/gio-0.13.0.3 (HamishMackenzie)
23:29:36 <solatis> merijn: yeah exactly
23:29:48 <Guest76702> quit
23:30:05 <solatis> merijn: async c++ is a complete mess
23:30:24 <solatis> merijn: at least, you must make damn sure your threads don't leak exceptions
23:30:48 <solatis> otherwise you can get all kind of wonky race conditions
23:31:18 <solatis> thank god they have noexcept() since c++11, so at least your compiler guarantees that no exceptions are leaked (but abort() is called instead :))
23:34:03 * hackagebot gtk3 0.13.1 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk3-0.13.1 (HamishMackenzie)
23:34:57 <solatis> merijn: googling 'c++ async exception' seems to cough up way too many haskell sites for me :)
23:42:45 <mitchty> so, if i wanted to get ghc building on a musl ibc+busybox platform, would  https://ghc.haskell.org/trac/ghc/wiki/CrossCompilation be the start of where i'd look to attempt the crazy idea?
23:44:03 * hackagebot gtk 0.13.1 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk-0.13.1 (HamishMackenzie)
23:54:04 * hackagebot jsaddle 0.2.0.1 - High level interface for webkit-javascriptcore  http://hackage.haskell.org/package/jsaddle-0.2.0.1 (HamishMackenzie)
23:55:54 <edwardk> vermeille: Control.Lens.Cons works on lots of container types. the 'snoc' and 'last' machinery there can be used
