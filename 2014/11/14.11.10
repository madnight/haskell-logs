00:04:26 <trap_exit> damn
00:04:32 <trap_exit> so can you order latest episode of walking dea don itunes?
00:12:34 <osa1> anyone here using HTTP.Browser? it prints stuff to stdout by default, any ways to disable that?
00:18:37 <magthe> is 'reThrowError' defined somewhere already? (either throwError return)
00:19:17 <merijn> magthe: What would the point of that be?
00:19:29 <merijn> Why catch it in the first place if you're only gonna rethrow?
00:19:51 <adas> i was going thru the typeclassopedia and somewhere in there, i read  "conts are the mother of monads" or something similar. is there a defacto resource to understand continuations?
00:20:12 <merijn> adas: Heavy drinking and a psychologist :)
00:20:32 <johnw> adas: I did write https://www.fpcomplete.com/user/jwiegley/understanding-continuations
00:20:33 <merijn> Not necessarily in that order :p
00:21:16 <adas> merijn: i do that everyday. want to read continuations for a change. make me sober - )
00:21:23 <adas> johnw: thanks. ill check it out
00:32:14 <DTSCode> hey guys... im trying to build lambdabot on ubuntu with cabal 1.20, but when i do i get these errors: http://paste.ubuntu.com/8915272/ any help?
00:34:27 <magthe> merijn: when using one ErrorT-based Monad stack inside another
00:34:54 <magthe> merijn: but maybe I'm thinking all wrong...
00:36:14 * hackagebot colors 0.2 - A type for colors  http://hackage.haskell.org/package/colors-0.2 (FumiakiKinoshita)
00:36:22 <bergmark> magthe: i don't think it's defined anywhere, and it does make sense sometimes
00:37:26 <magthe> bergmark: I see it in a few places when looking for `Either a b -> m b` on Hayoo, but not in any "standard" module
00:37:36 <bergmark> e.g. right now i have `either throwError return <=< f . runErrorT' in a few places, i think it can be worked around using MonadBaseControl
00:40:38 <bergmark> magthe: but also note the type of the ErrorT/EitherT/ExceptT constructor, m (Either e a)
00:40:40 <magthe> bergmark: I did have a quick look at Control.Monad.Trans.Control the other day, but didn't see right away how I could apply it
00:42:12 <bergmark> @type [either throwError return, ErrorT . return]
00:42:13 <lambdabot> (Error e, Monad m) => [Either e a -> ErrorT e m a]
00:42:50 <DTSCode> anyone?
00:45:05 <bergmark> DTSCode: https://github.com/haskell/cabal/issues/1883
00:45:48 <DTSCode> is this the issue with mine?
00:51:16 <bergmark> DTSCode: does it seem similar?
00:51:25 <DTSCode> kind of
01:12:50 <rydgel> @pl \xs r -> foldl (\b a -> b + a^2) 0 xs <= r^2
01:12:51 <lambdabot> (. (^ 2)) . (<=) . foldl ((. (^ 2)) . (+)) 0
01:14:17 <dv-> @unpl (.)(.)
01:14:18 <lambdabot> (\ b c e f -> b c (e f))
01:19:09 <borkdude> What is a nice book to read about Haskell after LYAHFG?
01:22:01 <sinelaw> depends what you want to know.
01:22:05 <yogsototh> Hi all, could someone tell me why I "erotica" appears in my exectuable when I do a strings on it (both with asm and llvm backend)
01:22:36 <yogsototh> And a _lot_ of other words
01:22:53 <MP2E> lol what
01:22:55 <borkdude> sinelaw web programming is nice, so maybe the book on Yesod is a good choice, but also I would like to familiarize myself more with the Haskell platform/libraries in general
01:23:03 <obiwahn> http://cm.bell-labs.com/who/ken/trust.html
01:23:36 <sinelaw> borkdude, I guess yesod is a good choice then.
01:23:43 <bartavelle> I can confirm I also have erotica in one of my executables, amusign
01:24:23 <yogsototh> and around it I have these words: http://lpaste.net/114035
01:24:54 <obiwahn> wow
01:25:13 <bartavelle> password strength check ?
01:25:18 <yogsototh> I don't know which dependency added them to my executable, or it might be a GHC joke.
01:25:42 <bartavelle> it's not in a "hello world" program
01:25:56 <sinelaw> yogsototh, bartavelle looks like it comes from this package: https://hackage.haskell.org/package/publicsuffixlist
01:26:03 <bartavelle> Fichier binaire ./lib/x86_64-linux-ghc-7.8.3/publicsuffixlist-0.1/libHSpublicsuffixlist-0.1-ghc7.8.3.so concordant
01:26:04 <sinelaw> see https://hackage.haskell.org/package/publicsuffixlist-0.0.1/docs/src/Network-PublicSuffixList-DataStructure.html
01:26:10 <bartavelle> :)
01:26:16 <yogsototh> sinelaw: great :)
01:26:20 <sinelaw> it's a list of TLDs
01:26:27 <sinelaw> or something of the sort
01:27:03 <sinelaw> I wonder how many haskell executables have been flagged as trojans ;)
01:29:52 <yogsototh> Could you tell me how you found the right package?
01:30:41 <bartavelle> yogsototh, I rgrepped my package .cabal-sandbox
01:31:14 <bartavelle> (I first compiled hello world to check if it was in it)
01:31:36 <yogsototh> bartavelle: thanks!
01:32:48 <sinelaw> yogsototh, and I googled "haskell ingatlan"
01:33:02 <bartavelle> that was probably faster !
01:33:29 <yogsototh> :)
01:48:44 <Arahael> How did anyone learn haskell without hlint?
01:49:37 <sinelaw> using GHC
01:49:41 <sinelaw> and hoogle
01:50:12 <Arahael> sinelaw: I was already using those.
01:50:23 <sinelaw> are you using -Wall in ghc?
01:50:48 <Arahael> No...  Using default cabal to set it up.
01:50:53 <Arahael> Let me turn that on...
01:51:21 <Arahael> I don't actually know how yet! :)
01:51:22 <chirpsalot> Arahael: hlint is too good. It's scary.
01:52:06 <Arahael> chirpsalot: Yeah - to me it feels like ghc's better than any linter that could be made.  Didn't even think to see if there was a lint for Haskell...
01:52:23 <Arahael> Seems to me that hlint doesn't check for errors - it actually suggests improvements.
01:54:34 <chirpsalot> Yeah.
01:54:53 <chirpsalot> It's really good at it, too.
01:55:28 <Arahael> My routine is now to "make ghc happy", and then "make hlint happy", and then be amazed.
01:57:02 <sinelaw> Arahael, some editors, like emacs + flycheck, will give you the hlint+ghc errors as you type.
01:58:11 <Arahael> I should setup a haskell env for it.
01:58:30 <Arahael> Incidentally, have you had success with that on mac os x?
02:00:26 <pantsman> I've had some success using Aquamacs + flycheck-haskell
02:01:12 <Arahael> Maybe I'll give that a go, or set it up at homne first (seeing as I only seem to use haskell at home. Sadly)
02:02:05 <Arahael> Where do I read about giving compiler arguments to ghc when using cabal?
02:02:19 <Arahael> I want to enable this -Wall thing. :)
02:02:56 <pantsman> you can add ghc-options: -Wall to your .cabal file
02:03:16 <pantsman> in the 'library' or 'executable' section
02:04:05 <Arahael> Hmm, seems to work - how do I test that?
02:04:11 <Arahael> It doesn't do anything different.
02:04:43 <Arahael> I also want to know how to rewrite: bar s = (==) '+' (foo s)
02:04:47 <Arahael> In point-free style.
02:05:19 <hyPiRion> @pl bar s = (==) '+' (foo s)
02:05:20 <lambdabot> bar = ('+' ==) . foo
02:05:42 <Arahael> I always forget how that currying works! Makes sense.
02:06:18 * hackagebot postgresql-binary 0.1.0 - Encoders and decoders for the PostgreSQL's binary format  http://hackage.haskell.org/package/postgresql-binary-0.1.0 (NikitaVolkov)
02:16:55 <baconwichsand> would you recommend writing a financial trading backtesting app in haskell? currently using python
02:25:59 <southp> I'm doing Brent's cs194 to teach myself Haskell. Currently I'm at hw7. Here is my code which can't be compiled: https://github.com/southp/cs194/tree/master/hw7
02:26:07 <biglama> hi, I would like to contact the maintainer of this package to ask him if he can add the package to stackage
02:26:10 <biglama> http://hackage.haskell.org/package/strict-concurrency
02:26:19 <southp> runhaskell JoinListBufEditor.hs gave me the following errors:
02:26:22 <biglama> how can I do that ? I did not found any email on his website
02:26:24 <southp> runhaskell JoinListBufEditor.hs
02:26:24 <southp> Editor.hs:38:22: Warning:
02:26:25 <southp>     ‘Editor’ is an instance of Monad but not Applicative - this will become an error in GHC 7.10, under the Applicative-Monad Proposal.
02:26:26 <southp> JoinListBufEditor.hs:6:22:
02:26:28 <southp>     Not in scope: ‘fromString’
02:26:30 <southp>     Perhaps you meant ‘showString’ (imported from Prelude)
02:26:32 <southp> JoinListBufEditor.hs:11:16:
02:26:34 <southp>     Not in scope: type constructor or class ‘JoinList’
02:26:36 <southp> JoinListBufEditor.hs:11:26:
02:26:38 <southp>     Not in scope: type constructor or class ‘Score’
02:26:40 <southp> JoinListBufEditor.hs:11:33:
02:26:42 <southp>     Not in scope: type constructor or class ‘Size’
02:26:44 <southp> JoinListBufEditor.hs:13:34:
02:26:46 <southp>     Not in scope: ‘+++’
02:26:48 <southp>     Perhaps you meant ‘++’ (imported from Prelude)
02:27:19 <kadoban> southp: ...don't do that next time. Paste it to a pastebin, like the one linked in the channel topic.
02:27:56 <southp> kadoban: Sorry...
02:28:07 <kadoban> No biggie
02:28:30 <southp> I can't figure out why 'fromString' is not in scope. I should have it defined in JoinListBuffer.hs.
02:29:00 <ThreeOfEight> I wonder what the status of the heap package v the heaps package is
02:29:04 <ThreeOfEight> they both offer Data.Heap
02:29:55 <ThreeOfEight> heap looks a bit abandoned, but offers the functionality I need directly. It also seems to be slightly faster for my use case.
02:30:02 <southp> Secondly, even if JoinListBuffer.hs import JoinList, those functions defined in JoinList.hs seemed not visible in JoinListBufEditor. Does that mean import a module, A, that import the other module, B, doesn't imply module B is going to be imported as well?
02:30:19 <sinelaw> ThreeOfEight, ya, heap hasn't been updated in 5 years
02:31:03 <pantsman> southp: modules don't re-export their imports by default, no
02:31:17 <bergmark> biglama: there is an email address on the page you linked...
02:31:21 <kadoban> southp: I think you have to explicitly export things that you import, if you want to
02:31:44 <biglama> bergmark: d'oh! thanks
02:32:05 <biglama> I can't parse hackage apparently
02:32:46 <mauke> module A (module A, module B, module C) where import B; import C
02:33:39 <southp> Thanks. That makes sense.
02:35:29 <ThreeOfEight> So what package would you recommend for a fast max heap, ideally with explicit priorities?
02:35:35 <southp> Do anyone have an idea why my fromString is not not in scope? Sorry that I give the URL to the whole source directory instead of a code snippet to quickly inspect on.
02:36:31 <bergmark> southp: fromString is in Data.String
02:38:15 <southp> bergmark: I'm plan to use my own fromString. It turned out it's the same question I just got answered. I just needed to import all other modules.
02:45:22 <malllle> is there a name for sth that is neither a fold nor a map like: foo (+) [1,2,3,4] = [3,7]?
02:47:33 <mauke> > map sum (chunksOf 2 [1,2,3,4])
02:47:34 <lambdabot>  [3,7]
02:47:57 <MP2E> wow neat, chunksOf
02:48:21 <malllle> oh chunksOf is nice, but is there a name for something like that, like reduce or so?
02:48:51 <malllle> thx mauke
02:50:25 <bergmark> malllle: it can be written as a fold, map can too
02:51:19 * hackagebot hasql-postgres 0.2.0 - A "PostgreSQL" backend for the "hasql" library  http://hackage.haskell.org/package/hasql-postgres-0.2.0 (NikitaVolkov)
02:51:58 <malllle> bergmark: with groupsOf i can see that but without?
02:54:36 <sinelaw> let foo = \f (x:y:xs) -> (f x y) : foo f xs
02:54:56 <miko88> adon list
02:56:09 <sinelaw> of course that has a missing pattern... :)
02:56:20 * hackagebot hasql 0.1.4 - A minimalistic general high level API for relational databases  http://hackage.haskell.org/package/hasql-0.1.4 (NikitaVolkov)
02:56:38 <malllle> sinelaw: yeah i have something like this
03:03:24 <greg_f> How I can convert a digit like '5' to type Integer?
03:04:02 <opqdonut> :t digitToInt
03:04:03 <lambdabot> Char -> Int
03:04:20 <greg_f> opqdonut: its Int
03:04:38 <Kinnison> ((fromIntegral . digitToInt) '5') :: Integer
03:04:41 <opqdonut> :t fromIntegral
03:04:42 <lambdabot> (Num b, Integral a) => a -> b
03:04:43 <kadoban> :t fromIntegral . digitToInt
03:04:44 <opqdonut> yeah
03:04:44 <lambdabot> Num c => Char -> c
03:05:17 <greg_f> thank you
03:07:59 <sohum> @hoogle (a -> b) -> (c -> m a) -> c -> m b
03:07:59 <lambdabot> Control.Parallel.Strategies ($|) :: (a -> b) -> Strategy a -> a -> b
03:07:59 <lambdabot> Control.Parallel.Strategies ($||) :: (a -> b) -> Strategy a -> a -> b
03:07:59 <lambdabot> Control.Parallel.Strategies (.|) :: (b -> c) -> Strategy b -> (a -> b) -> (a -> c)
03:09:07 <sohum> @pl \x -> f <$> g x
03:09:07 <lambdabot> (f <$>) . g
03:09:22 <sohum> I suppose
03:15:03 <kadoban> @unmtl (ErrorT String (StateT Machine (WriterT Log Identity))) a
03:15:03 <lambdabot> (ErrorT String (StateT Machine (WriterT Log Identity))) a
03:15:12 <kadoban> Anyone know why that just spits the same thing back out?
03:17:18 <mauke> @unmtl ErrorT String (StateT Machine (WriterT Log Identity)) a
03:17:18 <lambdabot> (StateT Machine (WriterT Log Identity)) (Either String a)
03:17:47 <mauke> @unmtl StateT Machine (WriterT Log Identity) (Either String a)
03:17:48 <lambdabot> Machine -> (WriterT Log Identity) ((Either String a), Machine)
03:18:09 <kadoban> Ah, thanks
03:18:13 <mauke> @unmtl Machine -> WriterT Log Identity (Either String a, Machine)
03:18:13 <lambdabot> Machine -> WriterT Log Identity (Either String a, Machine)
03:18:18 <mauke> @unmtl WriterT Log Identity (Either String a, Machine)
03:18:18 <lambdabot> (Either String a, Machine, Log)
03:18:24 <mauke> it only expands the top level :-/
03:18:51 <kadoban> That makes sense, hehe...guess it might be kind of a mess to figure out if it did it all at once
03:57:37 <Arahael> baconwichsand: Im currently doing similar, but only for playing around.
03:58:13 <Arahael> baconwichsand: I don't think haskell offers anything particularly special (still learning haskell, though).  Very nice syntax, but...
03:59:01 <Arahael> baconwichsand: I don't think haskell would give any advantages over some financial package that does most of it for you.
04:04:28 <Arahael> baconwichsand: Ultimately, if you're happy writing special-purpose code for all your statistics, then go for it.  But if there are financial platforms out there, it might be difficult to integrate into them.
04:11:59 <lynnard> how can I quickly introduce if .. else .. branches into a segment code?
04:13:13 <lynnard> say I have do { l <- doActionAndReturnList; <want to write something like : | null l -> do something | someOtherPredicate -> do something }
04:13:39 <ion> case l of { [] -> do { foo }; _ -> do { bar } }
04:14:14 <lynnard> ion: I suppose this is the conventional way then...
04:15:07 <lynnard> ion: problem is if I have a lot of guard expressions to match inside _ -> ... branch then it would look a little ugle (many guarded branches inside one case branch)
04:15:41 <ion> What do those expressions look like?
04:17:03 <lynnard> e.g. case l of { [] -> do {foo}; _ | onepredicate -> do {bar} | otherpredicate -> do {...} | otherpredicate' -> do {...} }
04:17:21 <ion> What do those predicates look like?
04:22:36 <lynnard> predicates that can't possibly make use of pattern matching
04:22:43 <lynnard> mostly just calling predicate functions
04:23:17 <Arahael> predicates can be lhs's?
04:23:27 <Arahael> predicate *functions*?
04:31:23 * hackagebot bgmax 0.1.0.1 - Parse BgMax-files  http://hackage.haskell.org/package/bgmax-0.1.0.1 (petterb)
04:35:18 <henk> hi, any recommendations regarding configuration file formats? I’m considering using yaml for config files, as it seems universally supported and quite powerful, yet simple enough. Is that a bad idea?
04:37:38 <prophile> henk: yaml for configuration is generally pretty sane
04:37:53 <prophile> major alternatives: ini, json, lua
04:37:54 <SvenskFisk> Anybody here use hasktags? It keeps saying that the resource is busy when I try to generate the tags
04:39:35 <henk> prophile: I know about INI, but I think it’s not quite as nice and powerful as yaml, or is it? json is a subset of yaml, so if I support yaml, I could just as well use json in the end … lua? Thought that was a programming language?
04:40:05 <prophile> INI has the benefit of simplicity, but it's certainly not as nice or powerful as yaml
04:40:22 <prophile> json is a subset of yaml, but also opens up nicer options like using aeson to parse it
04:40:57 <prophile> lua is a programming language but it's also quite a nice way of writing configuration files, depending on what you want to do
04:41:36 <prophile> as in your configuration file is a lua script which assigns to some variables, which means that your basic config is easy enough (foo = "bar") but you can also be more flexible like doing conditional configuration based on environment variables and whatnot
04:42:23 <henk> prophile: hm, ok, might be worth a look, then. Thanks! (:
04:42:31 <prophile> nw
04:42:44 <RchrdB> I really dislike JSON as a config file format because it lacks a comment syntax.
04:43:08 <RchrdB> YAML has a perfectly nice comment syntax.
04:44:11 <henk> RchrdB: oh, that’s good to know, thank you. I wouldn’t like not to have ability to comment configs for my programs.
04:50:11 <clrnd> I usually take advantage that Aeson is already a dependency for using JSON as config files :P
05:04:11 <hsk8> Usually >>= is left-associative. But
05:04:11 <hsk8> [1,2] >>= \n -> ['a','b'] >>= \ch -> return (n,ch)
05:04:13 <hsk8> is equivalent to
05:04:14 <hsk8> [1,2] >>= (\n -> ['a','b'] >>= (\ch -> return (n,ch)))
05:04:14 <hsk8> making >>= right-associative here, in some sense. How do I make sense of this?
05:04:49 <hsk8> Is it the higher precedence of -> ?
05:04:52 <hsk8> or what
05:05:01 <hsk8> no sorry, LOWER precedence of ->
05:11:03 <SvenskFisk> How do I install a cabal package into a sandbox? If I run cabal install in a sandbox will it know to just install it locally?
05:11:29 <Iceland_jack> SvenskFisk: "cabal install" in the sandbox directory will do
05:12:03 <hsk8> ok I get it now, http://stackoverflow.com/questions/11237076/haskell-precedence-lambda-and-operator
05:12:03 <hsk8> The lambda totally override the >>= assocativity
05:12:05 <hsk8> in some sense
05:18:09 <faveteli_> can i reuse a where clause in manny patterns, that is if i use a fuction in every pattern but i only want to define it once in a where clause
05:19:47 <nyuszika7h> faveteli_: you can use 'case', I think
05:20:26 <stephenmac7> I'm running out of memory when compiling some haskell packages like regex-tdfa
05:20:39 <lpaste> nyuszika7h pasted “No title” at http://lpaste.net/2261478131644760064
05:20:44 <nyuszika7h> faveteli_: see above ^
05:21:01 <stephenmac7> Is the only solution creating a swap partition/swap file?
05:21:25 * hackagebot transformers 0.4.2.0 - Concrete functor and monad transformers  http://hackage.haskell.org/package/transformers-0.4.2.0 (RossPaterson)
05:21:28 <etaoinshrdlu> stephenmac7: What kind of hardware are you running?
05:21:55 <stephenmac7> etaoinshrdlu: Extra cheap VPS that I got just to try something out (not production)?
05:21:59 <stephenmac7> *.
05:22:04 <stephenmac7> 512 mb RAM
05:23:21 <pantsman> stephenmac7: have you tried limiting GHC's heap size using +RTS -Mxxxm -RTS when compiling?
05:23:30 <RchrdB> stephenmac7: export an environment variable "GHCRTS=-M450m"  to set the maximum heap size.
05:23:51 <stephenmac7> RchrdB: I already finished compiling using swap space but will try that next time
05:23:53 <stephenmac7> Thanks
05:24:18 <RchrdB> stephenmac7: also make sure that it isn't trying any kind of parallel build, though I suspect that it wouldn't on a VM with one CPU.
05:24:44 <stephenmac7> RchrdB: I'm not using -j
05:25:13 <RchrdB> Setting the -M RTS option to limit the heap size won't help if the heap really does need to go above that bound, though, you'll just get OOMing from the RTS instead of from the OS. :|
05:25:24 <RchrdB> Swap is usually the way to go.
05:26:14 <pantsman> I've had success in the past just limiting the heap, but ymmv
05:26:25 <faveteli_> nyuszika7h: aa ok so the way to think is that when i have this requirement i need to use case instead of patternmatching in functions
05:26:37 <prinsen> A question about functional dependencies. I have class Interpret f t | f -> t. However I want to write instance (Monad m) => Interpret A (B m) where... but thats not possible. Is there any solution?
05:26:55 <nyuszika7h> faveteli_: I think so, I'm quite new to Haskell so there might be some magic I'm not aware of :P
06:14:32 <xandaros> encoding an Int with Data.Binary returns a ByteString of 5 bytes? I'm confused...
06:16:44 <Taneb> xandaros, so am I, the source suggests it should be 8
06:16:54 <Taneb> Maybe something's happening with null bytes?
06:17:27 <xandaros> Maybe I'm just doing it wrong?
06:17:29 <xandaros> Data.ByteString.Lazy.length $ Data.Binary.encode 42
06:17:36 <xandaros> That's what returned the 5
06:17:46 <wei2912> > Data.ByteString.Lazy.length $ Data.Binary.encode 42
06:17:47 <lambdabot>  Not in scope: ‘Data.ByteString.Lazy.length’Not in scope: ‘Data.Binary.encode’
06:17:54 <wei2912> oh well
06:18:25 <chpatrick> are you sure that 42's an Int and not an Integer?
06:18:32 <xandaros> good point
06:18:34 <chpatrick> Data.ByteString.Lazy.length $ Data.Binary.encode (42 :: Int)
06:18:52 <xandaros> Now it's 8
06:18:55 <xandaros> thanks
06:20:43 <wei2912> :t (>>=)
06:20:44 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:29:04 <SvenskFisk> How do I use a package that I installed in a cabal sandbox? I installed codex and when I try to run it, it's not found. I found it by looking in .cabal-sandbox/bin, and running the executable there, but I don't want to have to navigate there every time
06:29:32 <etaoinshrdlu> SvenskFisk: Have you add the package to your projects cabal file?SvenskFisk: Have you add the package to your projects cabal file?SvenskFisk: Have you add the package to your projects cabal file?SvenskFisk: Have you add the package to your projects cabal file?
06:30:01 <SvenskFisk> Haven't done that, will try, but I don't think that adds it to my $PATH
06:30:05 <bergmark> SvenskFisk: if it's a binary you can just copy it somewhere else
06:35:31 <clrnd> SvenskFisk, it won't add it to your $PATH, I have a folder ~/Bin that's in my $PATH and I just put them there manually
06:36:15 <bergmark> SvenskFisk: there's also `cabal run'
06:44:33 <hsk8> if i compile with ghc on OS X 10.10, will the binary also run on 10.9, 10.9, etc?
06:44:41 <hsk8> where can I assume the binary will run?
06:44:43 <hsk8> all macs?
06:44:48 <hsk8> and all os x?
06:45:53 <beaky> hello
06:46:09 <beaky> is there something like foldr for ints
06:46:36 <wei2912> beaky: what're you trying to do?
06:46:53 <beaky> i want to take a seed value and turn it into a list
06:47:19 <michaelt> unfoldr?
06:47:35 <beaky> wow thanks ill try that
06:47:48 <wei2912> :t unfoldr
06:47:49 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
06:50:25 <Lucas_> Can I ask total beginner questions?
06:50:41 <wei2912> Lucas_: yes, but you may want to go to #haskell-beginners instead
06:50:54 <Lucas_> okay, thanks
06:51:00 <albeit> Lucas_: Ask away!
06:51:11 <ajcoppa> Lucas_: yep, ask away, #haskell-beginners is just a little lower-traffic and hence more focused
06:51:17 <wei2912> ^^
06:51:31 <wei2912> Lucas_: you could join both channels :)
06:51:44 <michaelt> > let coalgebra n = if n > 10 then Nothing else Just (n * n, n+1) in unfoldr coalgebra 1
06:51:46 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
06:52:15 <beaky> unfoldr is perfect! thanks
06:52:23 <Lucas_> Sooo I have the task to wirite a simple correction algorithm for simple words
06:52:53 <Lucas_> Like: "Did you mean: Thanks instead of Thansk"?
06:53:01 <wei2912> how does the algorithm work?
06:53:09 <Lucas_> just simple one
06:53:48 <Lucas_> you can make 4 operations, delete a char, put in a char, replace a char, or switch two chars in the string
06:54:00 <tdammers> Lucas_: throw your search against a dictionary, return entries below a certain levenshtein distance?
06:54:37 <etaoinshrdlu> tdammers: Sorry to jump in, but what's the difference between levenstein distance and hamming distance?
06:54:43 <Lucas_> tdammers: ... i dont really know, wahts that supposed to mean
06:54:52 <wei2912> Lucas_: then google it
06:55:03 <wei2912> Lucas_: but i don't think that's what you want
06:55:15 <wei2912> the levenshtein distance is the minimum number of *single-character* edits
06:55:16 <tdammers> https://en.wikipedia.org/wiki/Levenshtein_distance#Relationship_with_other_edit_distance_metrics
06:55:18 <Lucas_> no i know what the Levenshtein distance is
06:55:49 <Lucas_> but i dont know what "reutrn entries velow a certain levenshtein distance" means
06:55:55 <etaoinshrdlu> tdammers: Thanks! I should have just taken wei2912's advice and google it myself.
06:56:00 <wei2912> Lucas_: just filtering
06:56:13 <Lucas_> oh, okay its not soppused to be question
06:56:18 <tdammers> Lucas_: you calculate the levenshtein distance between your given value and every entry in the dictionary
06:56:37 <tdammers> Lucas_: then you return those values for which the levenshtein distance is below a predfined threshold
06:56:49 <wei2912> https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance is what you want, btw
06:56:55 <wei2912> has the 4 operations you mention
06:56:56 <Lucas_> nah, i just want to get every possible creation of a word, you can get with the 4 operations i mentioned above
06:57:12 <wei2912> that explains
06:57:28 <Lucas_> THe Problem is the synthax
06:57:49 <jedai> I think this homework ask explicitly to generate all string within edit distance 2 of the original word then filter by the dictionary
06:57:53 <wei2912> Lucas_: how many operations are required?
06:57:55 <Lucas_> my current function edits1 is just always repeating itself
06:58:03 <albeit> Lucas_: Can you post your current attempt?
06:58:04 <Lucas_> so its wasting space
06:58:05 <albeit> @where lpaste
06:58:05 <lambdabot> http://lpaste.net/new/haskell
06:58:13 <wei2912> Lucas_: err, what's the maximum number of operations?
06:58:19 <jedai> There was another person who asked for this specific question in #haskell-beginner recently
06:58:21 <albeit> wei2912: 4 I believe
06:58:27 <Lucas_> edits1 word = map (\x -> (head x))(group (sort ([ a ++ [c] ++ b | ( a, b ) <- [ (take i((map toLower . filter isAlpha)(word)), drop i ((map toLower . filter isAlpha)(word))) | i <- [0.. length word]], c <- alphabet ] ++ [ a ++ ( tail b ) | ( a, b ) <- [ (take i ((map toLower . filter isAlpha)(word)), drop i ((map toLower . filter isAlpha)(word))) | i <- [0.. length word]], (not.null) b ] ++ [ a ++ [c] ++ (tail b) | ( a, b ) <- [ (t
06:58:31 <wei2912> woah
06:58:32 <Lucas_> it works
06:58:42 <Lucas_> but it looks like shit
06:58:51 <albeit> Can you paste it in lpaste?
06:58:53 <jedai> Right, it does ;-)
06:58:59 <albeit> @where lpaste
06:58:59 <lambdabot> http://lpaste.net/new/haskell
06:59:05 <wei2912> if it always repeats itself, doesn't that mean it doesn't work? :P
06:59:15 <lpaste> Lucas_ pasted “edits1” at http://lpaste.net/114041
06:59:24 <jedai> wei2912: maybe he means the code repeats itself
06:59:31 <wei2912> jedai: i see
06:59:32 <Lucas_> yes thank you
06:59:38 <albeit> Sweet Jesus
06:59:42 <albeit> That is a long line
06:59:46 <Lucas_> yep
06:59:52 <jedai> first step : reindent
06:59:58 <jedai> !!
06:59:59 <Lucas_> and i dont know, how to comprimise it
07:00:11 <wei2912> i have no idea how you managed to do this
07:00:17 * wei2912 is impressed
07:00:19 <albeit> Lucas_: Did you write that yourself?
07:00:21 <clrnd> Lucas_, in haskell you can insert newlines anywhere, as long as you indent it
07:00:27 <beaky> might be subjective, but in what cases is let better than where
07:00:28 <jedai> also this should be much shoerter
07:00:35 <Lucas_> albeit: yep with a partner
07:01:08 <jedai> beaky: when you're in an expression centered form (like a lambda expression) rather than in a definition
07:01:11 <Lucas_> and you indent with "!!"?
07:01:21 <Lucas_> sorry, not a native english speaker
07:01:29 * hackagebot fay 0.21.2.1 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.21.2.1 (AdamBergmark)
07:02:02 <jedai> Lucas_: To indent means to write your code on several line with appropriate whitespace to make it readable
07:02:41 <Lucas_> jedai: i fidured, but when i wanted to split it at the "++"  I just got errors
07:02:41 <beaky> jedai: know any code sxample of that kind of thing?
07:03:21 <michaelt> > let coalgebra n = if n > 10 then Nothing else Just (n * n, n+1) in unfoldr coalgebra 1  -- this is one expression, it wont permit where, no?
07:03:23 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
07:03:23 <jedai> instead of writing "stuff = long stuff ++ another long expression"
07:03:23 <jedai> you write
07:03:24 <jedai> stuff =
07:03:24 <jedai>    long stuff
07:03:24 <jedai>    ++ another long expression
07:03:48 <Lucas_> ok, will try, jsut a moment
07:05:16 <jedai> ok, maybe the first step should be to run a search and replace for (map toLower . filter isAlpha)(word)) and replace it by an appropriate variable name...
07:05:16 <Lucas_> jedai: ok, it worke thanks!
07:05:49 <Lucas_> jedai: also tried that, but also didnt work
07:06:12 <jedai> Lucas_: so do the search and replace now and add "  where yourVariableName = map toLower . filter isAlpha)(word)" on the line after your definition
07:06:36 <jedai> here yourVariableName = (map toLower . filter isAlpha)(word)
07:07:15 <Lucas_> jedai: ahh ok, tried it with a complete different function
07:07:16 <jedai> search and replace for ((map toLower . filter isAlpha)(word))
07:07:42 <jedai> once you've got that working, repost on lpaste
07:08:17 <Lucas_> jedai: i will, thanks
07:08:33 <jedai> though you could also replace stuff like (\x -> (head x)) by just "head"
07:09:24 <shiona> is there any work in the lines of figwheel in haskell?
07:09:43 <beaky> is there a way to replace zipWith with applicaive operators like <*>
07:10:03 <michaelt> beaky: you have to use ZipList
07:10:25 <Iceland_jack> > zipWith (+) [1,2,3] [10,20,30]
07:10:26 <lambdabot>  [11,22,33]
07:10:29 <Iceland_jack> > (+) <$> ZipList [1,2,3] <*> ZipList [10,20,30]
07:10:31 <lambdabot>  ZipList {getZipList = [11,22,33]}
07:10:47 <michaelt> > getZipList $ (+) <$> ZipList [1..10] <*> [10,20..100]
07:10:49 <lambdabot>  Couldn't match type ‘[]’ with ‘Control.Applicative.ZipList’
07:10:49 <lambdabot>  Expected type: Control.Applicative.ZipList a
07:10:49 <lambdabot>    Actual type: [a]
07:10:55 <michaelt> bah
07:11:02 <michaelt> > getZipList $ (+) <$> ZipList [1..10] <*> ZipList [10,20..100]
07:11:03 <lambdabot>  [11,22,33,44,55,66,77,88,99,110]
07:11:22 <jedai> shiona: if I understand figwheel correctly, Yesod has a  development mode that will do that too (recompile and update your site when you change your code)
07:11:42 <Taneb> If I have createFoo :: Bar Foo, and destroyFoo :: Foo -> Bar (), and using a Foo after it's been destroyed is an error... is there a nicer way to do this?
07:11:53 <shiona> jedai: without overwriting the state?
07:12:12 <jedai> shiona: only if the state is persistent
07:12:26 <shiona> nice, I really should go take a look
07:12:48 <michaelt> bah, didn't notice Iceland_jack 's answer
07:12:55 <jedai> but I don't think the objective is exactly the same... Maybe Yesod + hplayground or things like that..
07:13:33 <clrnd> Taneb, what do you mean 'destroyed'? like in C++?
07:14:21 <Taneb> clrnd, not really knowing C++, something like that
07:14:47 <clrnd> Taneb, haskell has no mutability, what do you mean by destroying a variable?
07:14:57 <Taneb> This is all happening in a MonadIO
07:15:15 <Taneb> Or something similar
07:15:26 <jedai> Taneb: there's the classic "bracket" idiom
07:15:37 <Taneb> It's for a sprite-based rendering engine, deleteSprite will remove a sprite from the screen permanently
07:15:47 <Taneb> jedai, not really useful in this circumstance :(
07:16:07 <Taneb> Maybe I don't need to, though
07:16:10 <clrnd> Taneb, how are you managing state? State? ST?
07:16:18 <jedai> Taneb: there's ResourceT but it probably can't prevent you using a resource after you manually destroyed it
07:16:25 <Taneb> clrnd, at the moment I'm designing the API, haven't thought about it much
07:16:40 <Taneb> Thinking about it, I'm not even sure I need to delete them
07:16:48 <clrnd> :D
07:16:56 <Adeon> you could separate Foo and a key that tells that Foo is part of your scene
07:17:17 <Taneb> Adeon, that's probably what I'll end up doing
07:17:24 <Adeon> if you care that much
07:17:38 <Adeon> I'd probably experiment and if that's obnoxious then I would probably just raise user error if Foo is used when it shouldn't be
07:18:21 <Tokenizer_> can somone please help with cabal/haskell installation ( I get this error on OSX )  ...... http://pastie.org/9709715
07:19:13 <Lucas_> ok, i replaced even more
07:19:39 <Lucas_> http://lpaste.net/114042
07:20:07 <Lucas_> looks better and still works, thank you all
07:20:20 <michaelt> Tokenizer_: you deleted HTTP but somethign depends on it. Try ghc-pkg check ; do ghc-pkg unregister for what it reports
07:21:20 <michaelt> Tokenizer_: I mean, you deleted a version of HTTP but kept something that depended on it.
07:21:36 <jedai> Lucas_: ok, we can start to work with that
07:22:19 <snyp> http://www.stephendiehl.com/posts/vim_haskell.html what does it mean "background ghc process"
07:22:26 <michaelt> Tokenizer_: maybe there are some other possibilities like that; this is the natural inference when the compiler is looking for a particular hash; it is getting the reference from something it is using
07:22:27 <jedai> Lucas_: if I remember correctly, your assignment advised to have separate functions for the deletions, change, insertions and switch ?
07:22:29 <snyp> in the section ghc-mod
07:23:40 <snyp> There is no GHC_ShowType function my vim says
07:24:11 <Lucas_> jedai: well i could, but its not necessary. Only if the code has errors, the teacher can still give some points
07:24:28 <jedai> Lucas_: it's also clearer, probably
07:24:38 <Lucas_> jedai: true
07:24:42 <snyp> Who uses haskell with vim?
07:24:48 <Tokenizer_> michaelt: now I get this error ... http://pastie.org/9709730
07:24:59 <jedai> Lucas_: but if you're satisfied and your code works, that's probably good enough
07:25:01 <snyp> How to get types and crap to pop up all the time I type stuff?
07:25:17 <wei2912> michaelt: thanks for your advice, i had a problem with broken packages bc ~/.cabal/ got wiped out
07:25:22 <michaelt> Tokenizer_: that's okay its just a haddock (documentation0 error
07:25:36 <Lucas_> jedai: but I think iit would be nice how to reference functions correctly in a different function
07:25:51 <snyp> uh.. i found this: https://github.com/begriffs/haskell-vim-now
07:26:00 <michaelt> Tokenizer_: now if you start over does it crash?
07:26:13 <Lucas_> jedai: Now i hace to do the same, for the distance 2
07:26:26 <Lucas_> jedai: edits2 word =  [e2 | e1 <- edits1 word, e2 <- edits1 e1]
07:26:26 <jedai> though "map (\x -> (head x))(group (sort ([ a ++ [c] ++ b | ( a, b ) <- splits, c <- alphabet ]" seems a bit complicated for what it does... it's the insertions, right ?
07:26:49 <Lucas_> jedai: yep
07:27:10 <Tokenizer_> michaelt: no it keeps going ;-) ... hopefully it'll run to the end
07:27:20 <Tokenizer_> michaelt: thanks (let's hope it works)
07:27:25 <michaelt> wei2912: Tokenizer_ 's problem can arise if you delete the local ~/.cabal stuff, but not the ~/.ghc stuff.  Then ghc-pkg thinks it's there but it isnt
07:27:54 <qsuscs> which of those two solutions would you take? http://lpaste.net/114044
07:27:59 <qsuscs> list one or recursive one?
07:28:15 <wei2912> michaelt: i see
07:29:23 <michaelt> wei2912: in a sandbox they both go together when you do cabal sandbox delete
07:31:31 * hackagebot hspec-core 2.0.0 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-core-2.0.0 (SimonHengel)
07:31:33 * hackagebot hspec-discover 2.0.0 - Automatically discover and run Hspec tests  http://hackage.haskell.org/package/hspec-discover-2.0.0 (SimonHengel)
07:31:35 * hackagebot hspec 2.0.0 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-2.0.0 (SimonHengel)
07:32:29 <jedai> Lucas_: ok, you probably should write "map head . group . sort" as another function since it doesn't have much to do with the edits business
07:34:08 <jedai> Lucas_: also (take i (lowerCase), drop i (lowerCase)) is just "splitAt i lowercase" (splitAt is from Data.List)
07:34:40 <Lucas_> jedai: ahhh i see
07:38:06 <Lucas_> jedai: yep, everything okay
07:38:46 <jedai> Lucas_: last thing : [ a ++ ( tail b ) | ( a, b ) <- splits, (not.null) b ] is a bit clumsy, list comprehension can do that more nicely
07:39:09 <jedai> [ a ++ b | ( a, _:b ) <- splits ]
07:40:13 <Lucas_> jedai: .. well that looks nice, sure
07:40:23 <jedai> Lucas_: your three last cases can be rewritten using this property to look better
07:40:52 <Lucas_> jedai: but a bit too nice for a newbie of a week
07:41:04 <Lucas_> jedai:
07:41:31 * hackagebot hspec-core 2.0.1 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-core-2.0.1 (SimonHengel)
07:41:33 <Lucas_> jedai: i will leave at that for the moment, its only my first assignment
07:41:33 * hackagebot hspec-discover 2.0.1 - Automatically discover and run Hspec tests  http://hackage.haskell.org/package/hspec-discover-2.0.1 (SimonHengel)
07:41:39 <jedai> Lucas_: ok, I can see that, though keep it in mind, it's really one advantage the list comprehension have
07:42:00 <Lucas_> jedai: Of course!
07:45:16 <Lucas_> jedai: one last thing, your opinion on this? edits2 word =  [e2 | e1 <- edits1 word, e2 <- edits1 e1]
07:46:50 <jedai> Lucas_: Well that's straighforward, probably good though you'll have a lot of doublons. Maybe you should delete the original word though, I'm not sure it's right to classify it as having an edit distance of 2 with itself
07:49:46 <Lucas_> jedai: probably going to do that
07:51:07 <Lucas_> jedai: there seems to be problem with the first function though. The test environment that was given to us has the soltion of edits on "fp" and "aa" seperatly
07:51:31 * hackagebot http-conduit 1.9.6 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.9.6 (MichaelSnoyman)
07:51:56 <clrnd> so what does *Defaulting the following constraint(s) to type ‘Integer’* mean?
07:52:27 <Lucas_> jedai: "fp" is not included in the solution(although it could, "f" replace with "f") but "aa" is (switch "a" with "a")
07:52:29 <clrnd> I'm doing: [y, m, d] = map (fromIntegral . read) $ split "-" s :: [Int]
07:52:51 <Lucas_> jedai: so i cant just filter the original word
07:53:35 <jedai> Lucas_: Mmmmm ...  that seems more of a bug in the specification to me.
07:53:51 <jedai> Lucas_: We're still talking about edits2 here ?
07:53:56 <michaelt> clrnd: note that :: [Int] here applies to the whole expression.  It is reading the strings as Integers and converting to Int
07:54:08 <Lucas_> jedai: oh, no sorry. Edits1
07:54:25 <clrnd> michaelt, yeah, I tried to type it like :: (Integral a, Read a) => [a]
07:54:28 <clrnd> but it didn't work
07:54:48 <jedai> I really don't think "aa" should be seen as edit distance 1 of "aa"
07:54:54 <Lucas_> jedai: I wanted to do something like an if-expression to not replace a char with the same char
07:55:27 <michaelt> [y, m, d] = map fromIntegral (map read $ split "-" s :: [Int])   <--- clrnd
07:55:42 <Lucas_> jedai: well me neither, but thats what the professor explcztly said
07:55:46 <jedai> Lucas_: but if the assignment think that, maybe it really think the original word is at edit distance 2 of itself...
07:56:03 <jedai> which would avoid the complications
07:56:04 <michaelt> clrnd: ^^^ then you specify that we read at a definite type, Int, but permit use with other Integral types
07:56:04 <clrnd> michaelt, yeah that'll work, but it's so nice ...
07:56:27 <clrnd> but it's *not* so nice
07:56:27 <jedai> Do you have test cases ?
07:56:32 * hackagebot hspec 2.0.1 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-2.0.1 (SimonHengel)
07:56:42 <Lucas_> yep, thats why i know
07:57:02 <michaelt> clrnd: there's not too much you can do with 'read' ; it really needs a type signature.
07:57:18 <Lucas_> jedai: i fave to fitler the fp out of fp, but not aa out of aa
07:57:23 <clrnd> michaelt, wait a sec, I need three values, an Integer and two Int. I tried that thing with typeclasses and it worked in GHCi
07:57:43 <clrnd> but in GHC I had to do the [Int] thing
07:57:43 <jedai> Lucas_: Wait wait, are we still talking about edit1 or edits2 ?
07:57:50 <Lucas_> jedai: edit1
07:58:13 <michaelt> clrnd: I'm not following yet, but I have a suspicion this is the ghci uses -XNoMonomorphismRestriction, but your file doesnt
07:58:32 <clrnd> michaelt, aha! that's what I suspected, but didn't know exactly what extension was it
07:58:44 <wei2912> 23:49 < lpaste> wei2912 pasted “NFA” at http://lpaste.net/114048
07:58:45 <wei2912> 23:49 < lpaste> wei2912 annotated “NFA” with “NFA (annotation)” at http://lpaste.net/114048#a114049
07:58:46 <clrnd> michaelt, thanks!
07:58:55 <wei2912> the code doesn't compile; does anyone have an idea why? the stacktrace is the annotation
07:59:29 <michaelt> clrnd: sure
07:59:44 <jedai> Lucas_: you should avoid changing a letter by iself, just delete the letter from alphabet in your edits1
08:00:11 <jedai> Lucas_: or test for equality
08:00:31 <geekosaur> wei2912, at a guess, you need ScopedTypeVariables so the "s"-s in the where clause are the same as in the top level type signature
08:00:48 <wei2912> geekosaur: yeh, that's what i thought. but how do i do that?
08:00:52 <vanila> wei2912, comment out all the type sigs
08:00:59 <Lucas_> jedai: If i would delete the letter f in "fp" for example, i couldnt replace "p" with "f"?
08:01:06 <wei2912> vanila: thanks
08:01:12 <geekosaur> for a first cut, what vanila said so it infers the correct types
08:01:39 <jedai> Lucas_: you're not deleting it globally
08:01:45 <wei2912> when should i specify a type signature?
08:01:49 <jedai> just test for equality
08:02:22 <jedai> ++ [ a ++ [c] ++ (tail b) | ( a, b ) <- splits, c <- alphabet, (not.null) b, c /= head b ]
08:02:32 <geekosaur> otherwise you'd need {-# LANGUAGE ScopedTypeVariables #-} at the top and the signature on line 16 becomes step :: forall s. NFA s i ...
08:02:47 <geekosaur> usually it's good to specify type signatures, but in a case like this it can bite you
08:03:23 * wei2912 is still amazed at the power of monads
08:03:30 <wei2912> i spent ages writing the code above, using concat and map
08:03:44 <wei2912> and using the bind operator just simplified everything
08:03:50 <Lucas_> jedai: thats it? you can just add expressions at the end? wow i fell dumb
08:04:14 <wei2912> Lucas_: welcome to haskell
08:04:21 <wei2912> Lucas_: you'll feel dumb very often :P
08:04:33 <hiptobecubic> But that's a good thing!
08:04:39 <jedai> Lucas_: you can add any test in a list comprehension, if they're False, no element will be generated for this case
08:05:15 <Lucas_> greeaaattt
08:05:31 <Lucas_> I see, this is gonna be a fun semester
08:05:34 <jedai> Lucas_: you can also add them anywhere, not just at the end (though of course not before the variable they operate on have been defined, and here not before we check that b _has_ an head)
08:05:50 <Lucas_> jedai: goot to know
08:06:22 <jedai> Lucas_: it's better to add them as soon as possible since that prevent the generation of useless cases
08:06:22 <Lucas_> jedai: thanks again
08:06:43 <jedai> Lucas_: You're welcome, and good luck for the rest of the assignment :)
08:06:56 <wei2912> Lucas_: have fun, programming in haskell is enjoyable
08:07:18 <Lucas_> jedai: yeah hopefully we will be able to do it without that much help
08:07:34 <vanila> wei2912, I only put type signatures when writing them helps me program - most often i don't write them
08:07:51 <wei2912> vanila: i se
08:07:51 <wei2912> vanila: i see
08:08:16 <jedai> Lucas_: stylistic help is not really a problem in my opinion, and that's mainly what we've been doing here (apart from this last part)
08:11:05 <jedai> wei2912: the nice part about the list monad in this case is that it allows you to pretend you're more or less writing a DFA when you're really writing a NFA :)
08:11:57 <Lucas_> jedai: but it mostly crashes at the small things, we understand the theory and semantic but programming itself is our biggest enemy
08:11:58 <jedai> that's one of the more natural application of the list (non-deterministic) monad ! :-)
08:12:18 <wei2912> jedai: yeh
08:12:26 <wei2912> i'm impressed with haskell
08:12:38 <clrnd> yay let's love haskell
08:12:40 <wei2912> a NFA in 27 lines of code
08:12:44 <jedai> Lucas_: right, though Haskell used properly helps with that :-)
08:12:46 <wei2912> clean looking code
08:17:54 <Lucas_> ok, enough haskell for today
08:18:04 <bergmark> noo
08:36:33 * hackagebot json-autotype 0.2.4.0 - Automatic type declaration for JSON input data  http://hackage.haskell.org/package/json-autotype-0.2.4.0 (MichalGajda)
08:36:35 * hackagebot github-backup 1.20141110 - backs up everything github knows about a repository, to the repository  http://hackage.haskell.org/package/github-backup-1.20141110 (JoeyHess)
08:41:49 <eacameron> so I'm trying to build a project as a Windows DLL but my code depends on other packages. I'm assuming I need to somehow build all my dependencies so that they support being exported to C (-fPIC or something?). Does anyone know how to tell cabal to build dependencies in this manner?
08:51:34 * hackagebot mcmc-samplers 0.1.1.0 - Combinators for MCMC sampling  http://hackage.haskell.org/package/mcmc-samplers-0.1.1.0 (pravnar)
08:59:10 <Gurkenglas> 27 lines for a nfa? o.o
09:04:53 <lericson> the haskell.org "tutorial" on I/O in haskell is really, really bad
09:05:00 <lericson> in fact the code doesn't even work!
09:05:55 <vanila> lericson, damn
09:06:04 <vanila> lericson, we should at least put a marker that it's outdated
09:12:08 <lericson> specifically the part about catching exceptions
09:12:25 <a3gis> Hi! Could someone please help me out with cabal? While trying to install Idris I ran into the following: http://puu.sh/cL8Jn/56913c348b.png
09:15:03 <a3gis> edwardk: maybe you would know about this?
09:15:31 <zipper> Could you tell me why functions loadData and rLoadData are giving an empty list and an Exception in --> https://gist.github.com/urbanslug/54b1cd58c82a27539f71 The JSON file is http://www.seas.upenn.edu/~cis194/extras/06-monoid-io/markets.json
09:15:49 <zipper> I'm having issues converting a JSON file into a custom type.
09:16:35 * hackagebot mcmc-samplers 0.1.1.1 - Combinators for MCMC sampling  http://hackage.haskell.org/package/mcmc-samplers-0.1.1.1 (pravnar)
09:17:41 <edwardk> a3gis: unknown symbol stuff like that is usually something on the host machine, a borked config or something
09:18:44 <a3gis> edwardk: any way I can fix that? I have absolutely no idea what was modified / what modified it
09:19:02 <edwardk> a3gis: i'd try blowing away your ~/.ghc equivalent on windows and trying again
09:19:12 <a3gis> I'm on os x, but let me try that
09:19:24 <Gurkenglas> "data Monad m => X m {test :: Int -> m Int}" <- How do I do this correctly?
09:19:38 <vanila> data X m {test :: Int -> m Int}
09:19:45 <vanila> data X m = X {test :: Int -> m Int}
09:19:54 <edwardk> _aegis_: sorry, the color scheme made me assume dos shell =)
09:19:55 <Gurkenglas> How will it know m is a monad?
09:19:58 <vanila> it wont
09:20:02 <vanila> that's okay though
09:20:17 <vanila> just let it infer that for the types where you use m as a monad
09:20:42 <zipper> When parsing JSON into a custom type is it wrong to have just SOME of the fields of the JSON object in my type?
09:22:04 <a3gis> edwardk: haha maybe I should change it then, people might judge me for it
09:35:59 <Gurkenglas> http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Monad.html <- Why isn't Identity listed under the instances?
09:36:30 <favetelinguis> is there a preference between foldl forldr, i thought foldl was the most used on but now i hear it is foldr?
09:36:51 <opqdonut> depends on what you want
09:37:19 <favetelinguis> generalize every other funktion over a recursive datatype
09:37:22 <opqdonut> in general, foldr for a lazy function, foldl (or rather foldl') for a strict one
09:38:03 <favetelinguis> ok that makes better sense
09:38:05 <opqdonut> @src sum
09:38:05 <lambdabot> sum = foldl (+) 0
09:38:08 <opqdonut> @src concat
09:38:08 <lambdabot> concat = foldr (++) []
09:38:52 <favetelinguis> but in this case + is lazy?
09:39:15 <chrisdone> foldl is spine strict, or weak-head strict, whereas foldl' is both spine and strict in the value
09:39:35 <chrisdone> + is strict, but the production of it can be lazy
09:39:53 <chrisdone> well, + on standard numeric types is strict
09:40:06 <favetelinguis> is the only way to know if a function is strict by looking at the documentation?
09:40:31 <chrisdone> pretty much, there's nothing in the type system about it
09:41:29 <chrisdone> foldl is good if you want to build up a structure strictly, but where the values are left unstrict
09:41:29 <favetelinguis> are there any work done to make a more inovative module system for haskell or are the one in use fine? seems like that is the only thing in haskell that is just the same as every ther language :)
09:41:43 <chrisdone> foldl' is good for almost every use-case you probably want, though
09:42:08 <chrisdone> there's “backpack”
09:42:18 <chrisdone> for sort of package-level parametrization of modules
09:42:46 <chrisdone> i don't know much about it
09:43:23 <benzrf> why would you use "smart" quotes when there are good quotes
09:44:48 <bitemyapp> chrisdone: it's not really ready to use is it?
09:44:59 <bitemyapp> I had the impression it was on-going.
09:45:38 <favetelinguis> i have seen mention on different parts on the net that Haskell' or Haskell 2 is in the loop where we would have dependent types etc, is this rly something we want or is it just rumours?
09:45:58 <bitemyapp> favetelinguis: if you *really* think typeclasses aren't appropriate for your problem and want something like ML modules, you can get the rudiments thereof through the use of records of functions, which will let you change behavior at the call-sites rather than a global canonical instance such as with a typeclass.
09:46:35 <bitemyapp> favetelinguis: the dependent typing stuff is an independent project being pushed forward by Eisenberg. I don't know that I would call it Haskell' or Haskell 2 any more than was the case as GHC Haskell progressed towards GADTs.
09:47:21 <favetelinguis> im not refering to typeclasses much more basic that that, im just talking about the import and export of modules
09:49:35 <merijn> favetelinguis: Haskell' (i.e. haskell prime) has always been the name of the "in-progress next standard report"
09:49:51 <bitemyapp> which is less ambitious than the work on GHC would imply.
09:50:01 <merijn> But given then conservativeness of Haskell2010, I wouldn't expect anything as groundbreaking as dependent types
09:50:05 <bitemyapp> favetelinguis: what do you want changed with the namespaces?
09:50:19 <merijn> I would expect GHC extension to keep happily progressing into that territory
09:53:35 <favetelinguis> bitemyapp: just that today the techer was saying that namespaces in haskell was the only thing that was not new from what we had before. Just felt there must be some cool way of dooing it but the researcher were not focusing on this while haskell grew. but now when it is getting more mainstreem and used in larger projects soemthing "smater" wold be possible to avoid conflicts etc
09:56:39 <bitemyapp> favetelinguis: that new thing is what chrisdone and I started talking about, but if you don't know the surrounding context it's a bit lengthy to explain.
09:56:56 <bitemyapp> favetelinguis: and has less to do with namespacing and more to do with modularity, ad-hoc polymorphism, canonicity vs. fibration, etc.
09:57:32 <merijn> There's rooms for namespace improvements in haskell to
09:57:59 <merijn> Multi-file namespaces, and not needing nested directories for multi-level namespaces
09:58:22 <merijn> But backpack is neat, yeah
09:58:34 <merijn> ezyang has a good couple of intro blogposts on his work
10:04:49 <benzrf> in reactive-banana or similar how could i get an Event that represents updates in an rss feed
10:04:58 <benzrf> main loop that checks and then fires the event?
10:08:05 <merijn> benzrf: Basically
10:08:13 <benzrf> grose
10:08:29 <benzrf> isnt there some kind of polling combinator with an interval-to-check
10:09:15 <Fuuzetsu> checkCond followed by threadDelay?
10:22:49 <clrnd> hey hey I have an Aeson FromJSON instance that's just "fmap Type . parseJSON"
10:23:11 <clrnd> and when I "eitherDecode" it's giving me back a "Left mzero"
10:23:18 <clrnd> and I want an empty []
10:26:49 <ReinH> clrnd: either (const []) id . eitherDecode ?
10:26:59 <ReinH> or fromMaybe [] . decode ?
10:30:45 <clrnd> oh, really?
10:30:49 <clrnd> okay, thanks
10:31:03 <clrnd> I wasn hoping it was wrong I got mzero :P
10:36:21 <clrnd> but wait, I don't want to throw away the error
10:37:30 <HarbingTarbl> Is it feasible to embedd Haskell into a C/C++ program?
10:37:41 <merijn> HarbingTarbl: Yes
10:38:14 <merijn> HarbingTarbl: In fact, I would even call embedding haskell into C almost trivially easy (as long as you don't require haskell to modify structs, in which case it becomes a little messy)
10:39:08 <merijn> HarbingTarbl: I wrote a minimal example of using a C main function calling out to haskell not too long ago: https://gist.github.com/merijn/4a0fee2b3a5ef3476aa4
10:40:07 <HarbingTarbl> merijn: I'll give it a shot then, I don't actuall know Haskell but I was told that since I want to parse something it would be better to just do it in Haskell than bison/flex.
10:40:24 <merijn> I'm not sure whether the _stub.h bit is still strictly necessary, but at least it doesn't hurt
10:41:10 <HarbingTarbl> It seems like it should be, otherwise how else would you access the exported functions?
10:42:05 <a3gis> edwardk: sorry I didn't get back to you; after doing what you suggested I still ran into a similar error. At the suggestion of somone on #idris I "burned ghc with fire" (aka uninstall && rm cabal config) and installed a fresh ghc 7.8 from http://ghcformacosx.github.io/. Solved it for me :) Thanks for you help!
10:52:27 <jdegoes> i think i want something like (a -> Maybe b) -> (b -> a) -> f a -> f (Maybe b). is there something relevant in lens?
10:53:10 <shiona> jdegoes: where would you use the (b -> a) part?
10:53:26 <simpson> :t _Just
10:53:28 <lambdabot> (Choice p, Applicative f) => p a (f b) -> p (Maybe a) (f (Maybe b))
10:54:07 <edwardk> (a -> Maybe b) -> (b -> a) sounds like a Prism'
10:54:39 <jdegoes> yes, it’s a prism, a constructor / partial deconstructor for a sum type
10:55:12 <jdegoes> f is an invariant functor.
10:56:25 <edwardk> er then how do you map backwards?
10:56:41 <edwardk> with invariant/exponential functors like that you can't gain or lose information and a prism does
10:57:20 <edwardk> :t below
10:57:21 <lambdabot> (Choice p, Traversable f, Applicative f1) => APrism' s a -> p (f a) (f1 (f a)) -> p (f s) (f1 (f s))
10:57:29 <edwardk> that is the closest we have
10:57:31 <jdegoes> well, the functor has a zero.
10:58:01 <edwardk> you give it a prism and then you can make a prism that works under any traversable trying all the cases and only succeeding when they all match
10:58:26 <edwardk> so how does the combinator get access to use it?
10:58:35 <edwardk> i don't see how this thing you want works
10:58:42 <sccrstud92> @pl foo x = x + f x + g x
10:58:42 <lambdabot> foo = ap ((+) . ap (+) f) g
10:58:53 <jdegoes> edwardk: good point. i guess there can’t exist a general purpose combinator and i have to write my own.
10:58:59 <edwardk> if i only know f is 'invariant' and gives me some kind of (a -> b) -> (b -> a) -> f a -> f b -- then i can't do anything there
10:59:41 <jle`> jdegoes: can you give an example of a non-polymorphic instance
10:59:52 <jle`> and an implementation
11:00:07 <jle`> i'm not even sure of a specific purpose combinator ;)
11:00:22 <jle`> sccrstud92: sequence [id, f, g]
11:00:25 <jle`> wow he just left
11:00:29 <jle`> hope he didn't use the pl version
11:01:17 <jle`> :|
11:02:00 <jdegoes> jle’ : it’s a record where a type parameter appears in covariant and contravariant position. but there is a zero for the record.
11:02:50 <jdegoes> jle’ : (a -> Maybe b) -> (b -> a) -> f a -> f (Maybe b)
11:03:01 <jdegoes> jle’ : oops, https://github.com/purescript-contrib/purescript-strongcheck/blob/master/src/Test/StrongCheck/Perturb.purs#L78
11:05:27 <jdegoes> jle’ : i want to define something like `</\>`, but for sum types. a Perturber is an invariant functor, albeit with a zero (nonPerturber).
11:08:38 <besenwesen> weird. say, i’ve learned you don’t always have to «lift» with the monad transformers. but i’ve noticed not doing lift can make a huge performance difference. why might that be?
11:08:57 <besenwesen> to practice, i made a sort of «matrix screensaver» http://codepad.org/z67PnWpX
11:09:11 <besenwesen> when i remove the lift before the recursion, it will be horribly slow
11:09:19 <besenwesen> but i kinda don’t see why
11:11:13 <jle`> i think...without the lift, it's lifting every single "call" inside revealSnake individually, in a recursive/nested way.  but with th lift there, it composes all the revealSnake stuff w/out lifting and then lifts it all at the end
11:11:22 <jle`> the lift there changes the type of revealSnake in the call
11:11:34 <Guest95196> Dumb Q: So do is pure language syntax, it is not a function, anywhere
11:11:45 <Guest95196> the do keyword I mean
11:11:49 <jle`> idk
11:11:49 <cdk> Guest95196: yes
11:11:49 <notdan> Guest95196: no, it's not a function it's syntactic sugar
11:11:55 <notdan> jle`: sounds reasonable
11:12:15 <jle`> consider the type of your call to revealSnake with and without the left; they should be different
11:12:18 <notdan> although it shouldn't be too slow..
11:12:28 <Guest95196> are there any other syntactic sugars? or is `do` the only one?
11:12:39 <jle`> Guest95196: there are lots :)
11:12:42 <cdk> Guest95196: list comprehensions are sugar as well
11:12:45 <Guest95196> oh no
11:12:47 <Guest95196> ah
11:12:55 <jle`> for example, if you've ever defined a function like foo x = x + 3
11:12:57 <Guest95196> e.g. i <- [1,2,3]
11:12:58 <jle`> that's syntactic sugare
11:13:02 <jle`> foo = \x -> x + 3
11:13:15 <Guest95196> ok
11:13:21 <jle`> if you've ever used an if/then/else statement, that's syntactic sugar too.
11:13:25 <cdk> Guest95196: as in [x * 2 | x <- [0..5]] or similar
11:13:32 <jle`> if x then y else z is like case x of True -> y; False -> z
11:13:40 <Guest95196> wow
11:13:52 <Guest95196> I always thought all that was backed by some sort of function
11:13:58 <cdk> also pattern matching when defining functions like: fib 0 = 1; fib n = ... ==> fib n = case n of ...
11:14:07 <notdan> besenwesen: have you tried writing a separate recursive helper function revealSnake', and then running `runMaybeT` on it separately?
11:14:22 <notdan> I guess that will mimic the lift behaviour
11:14:37 <jle`> Guest95196: the core language of haskell, with all the sugar gone, is actually very very small
11:14:49 <besenwesen> mh, that might make it easier for me to understand what’s going on
11:15:47 <besenwesen> notdan, do you expect that to perform identically?
11:16:07 <cdk> Guest95196: all these sugar example are "backed by a function" (if I'm understanding you correctly). All these complicated language constructs desugar to simple function application.
11:16:20 <cdk> it's all functions, all the way down
11:16:56 <cdk> well, I suppose "case" isn't a function.
11:17:08 <hpc> case isn't sugar
11:19:00 <Guest95196> So anything that I can't declare a :type on is sugar. Would that be accurate?
11:19:14 <Guest95196> :type do (won't work)
11:19:44 <jle`> well you can only :t values
11:19:45 <Guest95196> :type case (won't work either)
11:19:58 <cdk> Guest95196: I don't think that's a good way to think of it
11:19:58 <jle`> case isn't sugar tho
11:20:03 <cdk> :t [0..5]
11:20:03 <lambdabot> (Num t, Enum t) => [t]
11:20:08 <albeit> :t case
11:20:09 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
11:20:13 <Guest95196> :t elem
11:20:15 <lambdabot> Eq a => a -> [a] -> Bool
11:20:16 <jle`> [0..5] is indeed sugar
11:20:20 <cdk> but [0..5] is sugar for enumFromTo 0 5
11:20:22 <solarus> :t do return 3
11:20:23 <lambdabot> (Num a, Monad m) => m a
11:20:29 <Guest95196> oh
11:20:31 <jle`> :t do 3
11:20:32 <lambdabot> Num a => a
11:20:35 <jle`> :t do "hello"
11:20:36 <lambdabot> [Char]
11:20:54 <jle`> :t do do do do do do do do do do False
11:20:55 <lambdabot> Bool
11:20:59 <napping> :type is closer to telling you if something is a legal expression
11:21:42 <Guest95196> it just seemed that if everything is curried in Haskell, I should be able to do:
11:21:47 <Guest95196> :t do
11:21:48 <lambdabot> Empty 'do' block
11:21:53 <Guest95196> and get some sort of function
11:21:58 <chpatrick> syntax isn't curried :)
11:22:03 <Guest95196> but I understand
11:22:15 <napping> Well, that does tell you that "do" isn't a function
11:22:17 <chpatrick> wtf does do False mean?
11:22:29 <merijn_> @undo do False
11:22:29 <lambdabot> False
11:22:30 <jle`> False is a value
11:22:33 <chpatrick> oh I guess it's no binds
11:22:39 <jle`> it's one of the constructors of the Bool type
11:22:44 <jle`> data Bool = False | True
11:22:45 <chpatrick> I know what False is :)
11:22:50 <chpatrick> I'm just surprised you can put it in do
11:22:58 <napping> I guess the base case of desuagring do leaves the expression alone, without any typechecking
11:22:59 <merijn_> chpatrick: do is not magical
11:23:00 <edwardk> jdegoes: does it make sense to take apart your positive and negative occurrences in your type and make it a profunctor?
11:23:01 <chpatrick> but it makes sense since there's no >>=
11:23:06 <jle`> do { x } = x
11:23:08 <jle`> :)
11:23:18 <merijn_> chpatrick: Single line do desugars to that 1 line :)
11:23:35 <napping> I'm pretty sure GHC typechecks before desguaring, so I guess it's typed that way on purpose
11:24:08 <jdegoes> edwardk: i can do that except for ‘perturb’, which is `Number -> a -> Gen a`
11:25:26 <notdan> besenwesen:  would expect the version with a helper to preform similarly to the lift version
11:25:47 <Guest95196> test
11:25:50 <Guest95196> grr
11:26:16 <notdan> besenwesen: it's actually a very interesting example, and I would like to hear more about it if you manage to investigate further :)
11:26:28 <haasn> Is there an easily accessible setNub :: Ord a => [a] -> [a] with O(n log n) performance somewhere?
11:26:35 <haasn> O(n²) is too slow for my purpose
11:26:54 <hpc> :t nub . sort
11:26:55 <lambdabot> Ord a => [a] -> [a]
11:26:59 <besenwesen> notdan, «massaging» the types now to make it work with the factored out version. not sure i grok monads/transformers enough to make it run, though
11:27:04 <haasn> I quite specifically don't want my values to be sorted
11:27:15 <hpc> then what you want is impossible
11:27:40 <edwardk> jdegoes: just go Gen a a then
11:27:40 <haasn> Why? Set operations are O(log n)
11:27:52 <merijn> haasn: Set is implicitly sorting
11:27:53 <besenwesen> i was surprised because i read it’s considered good practice to not lift when using transformers
11:28:00 <haasn> yes and?
11:28:06 <jle`> besenwesen: is it now
11:28:10 <jle`> where did you read that?
11:28:15 <merijn> haasn: So, either you sort, or you don't get faster then n^2
11:28:21 <napping> Set.toList . Set.fromList is easiest way to eliminate duplicates. You'll need to build your own to get a nub
11:28:22 <haasn> never mind, I'll write it myself..
11:28:28 <hpc> haasn: and so using Set to do your nub is equal to nub . sort
11:28:39 <edwardk> haasn: you can write it using a hashmap as an accumulator and mapAccumL or something pretty easy
11:28:44 <jdegoes> edwardk: hmm, you mean make Gen take two type params?
11:28:55 <besenwesen> jle, stumbled upon it somewhere on stack overflow when looking for someting else, and found lots of posts about it, that you don’t need lift most of the time
11:29:05 <merijn> besenwesen: That's the type of advice you need to take with a grain of salt
11:29:25 <besenwesen> i suppose for me just starting out with things explicitly lifting might be better
11:29:29 <merijn> besenwesen: It depends heavily on your transformers stack and what you're doing
11:29:30 <besenwesen> to keep track of what’s going on
11:29:37 <edwardk> jdegoes: most of the time someone hands me an 'invariant type constructor' it usually works to split those into positive and negative occurences
11:29:43 <jle`> if you're starting out with transformers, try using the `transformers` library instead of mtl :)
11:29:45 <merijn> besenwesen: One common way to reduce lift's is lifting entire blocks at a time
11:29:56 <jle`> mtl is preatty neat but one thing it's bad at dealing with is monad transformers
11:29:58 <edwardk> then i can just use the existing profunctor machinery, can figure out if i have more of the profunctor vocabulary for strong, choice, etc.
11:30:21 <besenwesen> jle: transformers is the «classic» one which doesn’t magically lift things, and «mtl» is the «fancy» one? i mix them up all the time
11:30:29 <edwardk> haasn: s/hashmap/map/ for just Ord of course
11:30:31 <jle`> transformers provides transformers
11:30:36 <jdegoes> edwardk: makes sense. i’ll see if i can make that work
11:30:48 <jdegoes> edwardk: thanks for all the help!
11:30:54 <edwardk> besenwesen: transformers provides the transformers and stays haskell 98. mtl wraps transformers and adds MPTCs for automatically lifting, etc.
11:31:02 <jle`> mtl abstracts over different monadic interfaces and provides instances for `transformers` types
11:31:25 <haasn> let nub' = go HS.empty where go s (x:xs) | HS.member x s = go s xs | otherwise = x : go (HS.insert x s) xs; go _ [] = []
11:31:27 <merijn> besenwesen: Note that you can lift entire blocks like so: http://lpaste.net/114055
11:31:29 <haasn> Not that ugly after all
11:31:40 <jle`> haasn: also not so Ord :)
11:31:52 <edwardk> mtl and transformers were split back when there was a big 'back to basics' push in the community
11:31:55 <vanila> haha
11:31:58 <vanila> isnt' that the whole point of mtl
11:31:58 <haasn> jle`: Sure, replace HashSet by Set or whatever. In my case I'm using Int either way
11:31:59 <merijn> jle`: Dealing with monad transformers is exactly what mtl is for...
11:32:02 <vanila> for monad transformers
11:32:11 <edwardk> jle`: swap in Set and it is
11:32:13 <vanila> I never had a problem with it until recently though
11:32:16 <besenwesen> right, the types got me interested in that, i kinda liked setting a constraint combining several monads and have it work, but after a few times i noticed it doesn’t always work like that :)
11:32:25 <jle`> don't you lose the original ordering in Set?
11:32:27 <edwardk> haasn: if you're going Int then clearly IntSet ;)
11:32:47 <edwardk> jle: he's not just smashing to a Set and taking it back out
11:32:51 <merijn> besenwesen: I kinda dislike mtl, it leads to ambiguity. I prefer just defining a type alias for an explicit transformer stack (or newtyping it)
11:33:02 <jle`> edwardk: oh, i see now. i didn't read carefuly enough
11:33:18 <edwardk> whereas i have the exact opposite take as merijn ;)
11:33:19 <haasn> This is a one-liner thing. I just need to get 200,000 distinct but otherwise randomly picked values in the range (1,2^30)
11:33:50 <haasn> My solution is do xs <- replicateM 300000 (randomRIO (1,2^30)); return (take 200000 $ nub xs)
11:33:56 <haasn> but Prelude.nub was way too slow
11:34:00 <jle`> as for me i think mtl and transformers occupy very different and almost non-intersecting usage spaces
11:34:09 <haasn> (Interrupted it at several minutes, whereas it took 1 second with HashSet's nub')
11:35:22 <chrisdone> edwardk: finally, someone else who likes mtl's classes
11:35:24 <edwardk> i pretty much use mtl classes for everything and then accumulate multiple constraints on the type
11:35:30 <chrisdone> <3
11:35:52 <edwardk> e.g. https://github.com/ekmett/quine/blob/master/Main.hs#L191
11:36:02 <edwardk> render :: (MonadIO m, MonadReader e m, HasEnv e, MonadState s m, HasDisplay s) => m () -> m ()
11:36:02 <benzrf> haasn: that's not even guarnateed to return 200000 values
11:36:11 <edwardk> now i can add more HasFoo constraints to e and s
11:36:34 <edwardk> and it enables me to clearly see what portions of the system depend on what
11:36:40 <edwardk> which enables me to refactor and pull code around
11:37:02 <merijn> edwardk: I guess my main problem is that I have a RankN type inside state in one of my stacks which completely breaks mtl if you try to use it :p
11:37:15 <chrisdone> edwardk: is that trick published anywhere? it gets around the multiple MonadReader instance problem afaik
11:37:27 <edwardk> uh, ImpredicativeTypes just screw you
11:37:29 <jfischoff> this is also what we do at work ^
11:37:43 <edwardk> chrisdone: i mentioned it on reddit once i think
11:37:46 <edwardk> we use it heavily in ermine, etc.
11:37:51 <chrisdone> feel like the idea should be more awared-of
11:38:02 <jfischoff> I think people don't like because of a fear of classes or something
11:38:03 <edwardk> it basically solves multiple-reader/writer/exception/state problems for me
11:38:09 * chrisdone tries to think of the word for flip aware
11:38:17 <merijn> edwardk: It's not an impredicativetype, I think I move the forall out of the StateT itself, but you can't really write the same with mtl
11:38:19 <chrisdone> yeah
11:38:31 <merijn> I wish we had proper impredicative types, though :(
11:38:42 <edwardk> merijn: i don't quite understand the type you are getting at
11:38:53 <merijn> btw, is the whole new record type stuff going into 7.10?
11:38:59 <edwardk> i have no idea
11:39:19 <chrisdone> core :: (MonadIO m, MonadState s m, HasSystem s (), MonadReader e m, HasEnv e, HasOptions e) => m a
11:39:20 <chrisdone>  
11:39:21 <chrisdone> lol
11:39:22 <merijn> edwardk: oh, hah, actually I apparently rewrote it to avoid the RankN
11:39:35 <vanila> I don't like all the type classes because it breaks type inference
11:39:47 <chrisdone> vanila: does it?
11:39:48 <edwardk> vanila: uh, the thing i wrote up there infers perfectly
11:39:52 <vanila> in my experience
11:39:56 <edwardk> you can rip all my type signatures off and it all compiles
11:40:16 <merijn> edwardk: Anyway, I feel that there's little point to mtl if your semantics rely on the order of your transformer stack :)
11:40:18 <edwardk> i very deliberately stay in the inferable fragment of haskell
11:40:37 <chrisdone> i think MPTC tend to suck at inference, but it's possible to stay in unamibguous land
11:40:37 <vanila> I guess I just had a bug in my code then
11:40:46 <merijn> edwardk: All the HasX class are lens?
11:40:49 <jfischoff> vanila: For multiparam typeclasses you need fdeps setup right
11:40:58 <edwardk> merijn: they get built by makeClassy, yeah
11:41:21 <jfischoff> vanila: it is easy to find yourself in a situation that cannot be inferred
11:41:21 <chrisdone> hmm, that's an interesting point
11:41:39 <merijn> edwardk: I still haven't converted to the cult of lens, despite having it as a dependency on my current code ;)
11:41:40 <chrisdone> how does HasFoo a differ to a Lens a Foo
11:41:55 <edwardk> merijn: well, for environments it works with just a function usually
11:42:20 * chrisdone thinks (1) implicit passing, (2) the obvious ability to do monadic things
11:42:25 <merijn> edwardk: Yeah, mostly I'm using Reader atm, so just using "asks" is sufficient without lenses for me :)
11:42:40 <edwardk> class HasFoo t where foo :: Lens' t Foo -- and it includes things like fooBar :: Lens' t Bar -- if foo has a field _fooBar of type Bar
11:43:10 <edwardk> i tend to use lenses even for my reader bits because it enables the use of local on parts of the environment
11:43:47 <chrisdone> ah, so it's basically an implicitly passed lens
11:44:11 <edwardk> chrisdone: HasFoo lets you overload the foo members so they can work on any larger record type that contains a Foo
11:44:19 <muzzle> In cabal, is there a way to load all modules into repl ? I also want to load all of those modules, that are not imported in the Main module of an executable.
11:44:41 <chrisdone> ah, this is from the overloaded record fields kind of school
11:44:49 <edwardk> well more principled in a way
11:44:59 <edwardk> because it groups functionality semantically rather than by name
11:45:13 <besenwesen> notdan, doing it like this doesn’t give me the performance meltdown, as you supposed http://codepad.org/qKTisYIH
11:45:30 <jle`> muzzle: cabal repl ?
11:45:41 <muzzle> yes
11:45:45 <edwardk> i typically use it for accumulating large sets of options, the bits and pieces of a compiler, a game engine, etc.
11:45:50 <jle`> muzzle: does it work?
11:45:53 <jle`> oh
11:45:57 <jle`> load them all at once
11:46:10 <muzzle> but how ?
11:46:19 <chrisdone> edwardk: how does it differ in principledness to e.g. the Has library?
11:46:22 <muzzle> usually when i call cabal repl it just loads the main module
11:46:45 <edwardk> chrisdone: i find that it infers better to have a class per thing and a method for each thing you want to look up
11:47:21 <chrisdone> the has library is more like named tuples, but each name must have a single type -- the class approach seems similarly principled, but not more
11:47:29 <edwardk> class Contains (Labelled e v) r => Knows e v r | e r -> v where injl :: e -> v -> r -> r; prjl :: e -> r -> v -- gives even me pause
11:48:14 <edwardk> i have a lot of code that can already use a lens =P
11:48:43 <edwardk> i kinda spent a year or two making those combinators usable =)
11:49:17 <edwardk> (^=) :: Knows e (TypeOf e) r => e -> TypeOf e -> r -> r -- doesn't compose
11:49:39 <edwardk> the lenses i get from the above code compose with . with any other lens
11:52:22 <chrisdone> sure, that's because has is just a dumb record, not a lens
11:53:04 <edwardk> sure, but you asked why i don't use it. i don't use it because it collides naming wise with a bunch of more useful stuff and fills a niche i already have filled
11:53:11 <chrisdone> i didn't ask that
11:53:39 <chrisdone> i just asked what is more principled about having a class HasFoo than overloaded record fields
11:54:13 <edwardk> really its more about utility than principle
11:54:40 <edwardk> its useful, doesn't clutter my semantics, can be pulled out of the class context, and can be turned into a lens i can compose with other stuff and passed that way when its not obvious form context
11:55:06 <jfischoff> The thing I like about the HasFoo approach is that it is simple
11:55:13 <chrisdone> +1
11:55:17 <edwardk> and my experience is things like 'has' 's Contains is that the MPTC basically destroys inference
11:55:20 <jfischoff> But it is also requires boilerplate
11:55:21 <besenwesen> speaking of records, something i’ve been wondering recently: why are records with uninstantiated fields not considered as functions? rather, they are always treated as the full type
11:55:40 <edwardk> boilerplate lens generates for me
11:55:41 * edwardk shrugs.
11:55:57 <fragamus> :t traverse
11:55:58 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
11:56:08 <edwardk> i'm allergic to asymptotic hits to the amount of code i write
11:56:10 <fragamus> what does it mean
11:56:16 <edwardk> but i'll take constants here and there
11:56:37 <edwardk> fragamus: http://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf
11:56:42 <chrisdone> i'd love TRex that produced lenses
11:57:15 <edwardk> i'm pretty much done looking for sexier record types. every time someone proposes one i look at it and see horrible constant factors performance wise
11:57:30 <edwardk> i have a thing that satisfices and lets me focus
11:57:44 <edwardk> there are parts of the lens solution i'd like to improve
11:58:08 <edwardk> e.g. making it easier to define HasFoo classes that automatically get superclasses from a richer version of makeClassy, etc.
11:58:24 <edwardk> but template haskell staging makes that hard
11:59:18 <chrisdone> the nice thing about trex is that it gives cheap throwaway named tuples, which is what the javascript programmers can do easily. hello=(foo=(bar="sup"),x=2) is so cheap. the js programmers can also do hello.foo.bar="bill". that's magic
11:59:56 <chrisdone> on-the-fly named tuples with composable update. /me sighs dreamily
12:00:37 <jle`> fragamus: are you familiar with mapM?
12:01:10 <chrisdone> it feels like the records thing is something that will have to be solved before people can use haskell for 'scripting' like they do with R or numpy
12:01:31 <Welkin> I already use haskell for scripting
12:01:41 * hackagebot js-flot 0.8.3 - Obtain minified flot code  http://hackage.haskell.org/package/js-flot-0.8.3 (NeilMitchell)
12:01:50 <Welkin> at least for little command line utilities
12:01:54 <chrisdone> Welkin: like r and numpy?
12:02:00 <chrisdone> ok
12:02:00 <Welkin> not like that
12:02:00 <edwardk> we have a bunch of things like hlists that can be used for records, i just find the inference hit from using them not to be worth the "convenience"
12:02:05 <Welkin> but I nevrr used R or numpy
12:02:10 <Welkin> I never had a use for it
12:02:41 <fragamus> jle`:yes
12:02:42 <chrisdone> edwardk: yeah. they should be as concrete as tuples are to be practical
12:03:03 <rqiu> trying out church number stuff, needs some help to understand the following: http://lpaste.net/114056
12:03:23 <chrisdone> fst (1,"x") or over _1 (+2) (1,"x") has no inference problems
12:03:44 <edwardk> besides, we already have extensible records: https://www.haskell.org/pipermail/haskell-cafe/2013-May/108334.html
12:04:19 <edwardk> Dict (?x :: Int, ?y :: Double)
12:04:23 <edwardk> tada
12:04:26 <edwardk> easy peasy
12:04:50 * edwardk ducks
12:05:38 <chrisdone> =p
12:06:05 <chrisdone> i guess implicit params are kind of an equivalent of keyword args
12:06:25 <chrisdone> which is almost always the convenience use-case for nonce records
12:06:27 <benzrf> ew
12:06:42 * hackagebot standalone-haddock 1.1.4.3 - Generate standalone haddock documentation for a set of packages  http://hackage.haskell.org/package/standalone-haddock-1.1.4.3 (RomanCheplyaka)
12:06:55 <chrisdone> it's also true that in most languages with dynamic scope, it's used for configuration
12:07:02 * jfischoff wishes Haskell had keyword args
12:07:05 <edwardk> @let data Dict p where Dict :: p => Dict p
12:07:05 <lambdabot>  Parse failed: Illegal class assertion
12:07:15 <edwardk> bah
12:07:28 <chrisdone> yeah it seems a constraint kind in this case seems better than the type aliases
12:07:33 <edwardk> chrisdone: i guess i'm alone in hating that =P
12:07:44 <jfischoff> I also want default argruments, and before you say the thing about partial application, I have a story for that
12:08:34 <chrisdone> so that'd be… renderChart :: Dict (?width :: Double, ?height :: Double) => …
12:08:40 <chrisdone> and then, what for defaults?
12:08:50 <edwardk> actually Dict isn't a constraint its a value
12:09:10 <edwardk> you'd just use (?width :: Double, ?height :: Double) => if you could stomach it for the setup
12:09:59 <chrisdone> ahh, just read your data decl
12:10:39 <chrisdone> and then when you case dict of … you have the implicit params in scope?
12:10:47 <edwardk> yeah
12:10:57 <edwardk> foo Dict = whatever just opens it
12:10:59 <chrisdone> pretty neat
12:11:33 <edwardk> absolutely horrid, but YMMV ;)
12:11:44 <chrisdone> what's horrid about it?
12:11:55 <edwardk> try using it some time =P
12:12:09 <edwardk> there are all sorts of weirdnesses when you bring into scope two implicit params at the same time
12:12:27 <edwardk> which one wins is a bit of a black art to determine
12:12:53 <chrisdone> i see
12:21:38 * dagle had it with package/cabal hell.
12:22:41 <johnw> I wonder if there are cabal demons
12:23:03 <edwardk> do they feed on rage? if so they have to be full by now ;)
12:23:14 <johnw> there should be a cabal level in Diablo
12:23:18 <S11001001> johnw: they're always lurking in the background.
12:23:48 <josephle> bad loot drops? blame the cabal demons.
12:23:53 <edwardk> i'm getting strange visuals of dcoutts in a cow suit. these visuals make me uncomfortable.
12:23:59 <johnw> hahaha
12:24:35 <edwardk> if i ever go back and do a game i think the bad guys have to be 'the cabal' =P
12:25:38 <Welkin> at the end, the player discovers that *they* are the cabal and have been the whole time
12:25:38 <johnw> and have trolls too
12:25:52 <Welkin> they have been fighting themself
12:26:01 <Welkin> theirself*
12:26:08 <Welkin> their self*?
12:27:16 <chrisdone> Welkin: no john, you are the cabal
12:27:40 <chrisdone> and then john was a failed build plan
12:28:53 <eacameron> my Setup.hs has a postBuild hook but I can't get it to be called. Any ideas?
12:29:22 <johnw> the end boss drops the "golden sandbox"
12:29:56 <chrisdone> eacameron: did you remember to set your build type to custom?
12:30:47 <eacameron> chrisdone: Yes. :D
12:30:50 <eacameron> thanks
12:31:19 <edwardk> johnw: clearly the whole game is to break out of the sandbox
12:31:38 <edwardk> the in the end you discover that the universe is immutable and you can't change anything
12:31:47 <dagle> How do you get users to install binaries with haskell-build deps? Got more users in 2 weeks for my C program than the same program in haskell in 1 year.
12:33:20 <kadoban> dagle: Does it matter what language a program is in to the user? I doubt it. Package it up nicely, regardless of language, and go from there.
12:33:47 <dagle> kadoban: People said the following: Wont install because of haskell and ghc.
12:34:12 <chrisdone> dagle: are they against receiving binaries?
12:35:34 <kadoban> dagle: I don't understand why they'd even care. Are you requiring your users to build it themselves or something? Relaese source if you want to, but you should also have binaries available, which is what most people will use.
12:36:02 <Welkin> dagle: if the software is hosted on a server, the user will never know or care what language is used
12:38:34 <dagle> Welkin: Nope.
12:39:19 <rqiu> try again.  Let's say two = \s z -> (s . s) z, three = \s z -> (s . s . s) z, as I can kinda see that two three is applying s for 9 time, but how to deduce that?
12:40:02 <jrc12> How much memory required to store ByteString of size 1 byte
12:40:59 <chrisdone> umm, sizeof void* + sizeof Int64 + sizeof(char*) + length string
12:41:01 <chrisdone> something like that
12:41:03 <dolio> Several bytes.
12:41:22 <dolio> There might be 2 Int64s.
12:41:24 <chrisdone> https://hackage.haskell.org/package/bytestring-0.9.2.1/docs/src/Data-ByteString-Internal.html#ByteString
12:41:26 <dolio> Offset + length?
12:41:31 <chrisdone> seems there're two, yeah
12:41:58 <chrisdone> i don't remember what size an Int is offhand
12:42:39 <dolio> It's dependent on whether you're running 32-bit or 64-bit code.
12:43:25 <jrc12> i see, and whats the difference between a string and a bytestring in terms of memory layout?
12:44:00 <stephenmac7> Is it really better style to use <$> over fmap?
12:44:05 <Welkin> jrc12: a string is a list of characters
12:44:12 <stephenmac7> HLint gets mad about my code because of it
12:44:18 <Welkin> jrc12: a bytestring is a sequence of bytes
12:44:21 <stephenmac7> (I usually use fmap)
12:44:25 <merijn> stephenmac7: It depends
12:44:32 <merijn> stephenmac7: I use whichever is more readable
12:44:38 <vanila> qiu  http://lpaste.net/114057
12:44:40 <vanila> rqiu,
12:44:50 <merijn> But I usually prefer <$> unless I'm partially applying fmap
12:45:04 <merijn> stephenmac7: i.e. "fmap (fmap foo)"
12:45:35 <joe9> How do I find the definition of fmap used for my monad when I use {-# LANGUAGE GeneralizedNewtypeDeriving #-}?
12:45:45 <Welkin> stephenmac7: you mean when using an applicative style?
12:45:55 <Welkin> <$> and <*>?
12:45:56 <stephenmac7> Welkin: No, looks like HLint asks for it any time
12:46:11 <Welkin> strange
12:46:20 <stephenmac7> http://lpaste.net/114059
12:46:31 <vanila> joe9, a complete guess - make ghc emit the core
12:46:41 <vanila> don't know if this will work or not
12:46:43 * hackagebot linear 1.13 - Linear Algebra  http://hackage.haskell.org/package/linear-1.13 (EdwardKmett)
12:46:55 <stephenmac7> Welkin: Guess it makes it look cooler or something
12:47:05 <stephenmac7> :P
12:47:10 <Welkin> well
12:47:24 <Welkin> it looks like because you are already using $
12:47:27 <junmin_> hello all, in linux, df is 100%, but df -i indicates only 23% used ... what should i do?
12:47:32 <rqiu> vanila, is step 6 right?  s has a signature of a -> a, but three doesn't
12:47:34 <Welkin> it would be less typing
12:47:36 <stephenmac7> Looks like it only does it when I have something like fmap fun $
12:47:45 <Welkin> that makes sense
12:47:48 <Welkin> it is a little bit cleaner
12:47:49 <stephenmac7> Guess so.
12:47:54 <stephenmac7> I'll go fix it then
12:48:53 <stephenmac7> Just makes more imports though...
12:48:58 <Welkin> yeah
12:49:03 <Welkin> do whatever you feel is right
12:49:15 <stephenmac7> Guess it looks better. I'll keep it. Thanks
12:49:15 <vanila> rqiu, you could do it differnetly but it's harder to follow
12:50:07 <rqiu> but this way doesn't seem to be right because the types don't match?
12:50:08 <vanila> three = \s z -> ... so it's ok to eta-expand that outer three
12:50:20 <vanila> which types
12:50:34 <rqiu> s and three
12:50:44 <vanila> i don't understand
12:51:29 <rqiu> in step 6, you substitute s with three but s has a type of a -> a while three has (a -> a) -> a -> a
12:52:47 <vanila> I don't really follow what you're saying
12:52:51 <vanila> = (\y -> three (three y))
12:52:51 <vanila> = (\y z -> three (three y) z)
12:52:56 <vanila> this part?
12:53:03 <rqiu> no
12:53:09 <rqiu> (\s z -> (s . s) z) three
12:53:19 <rqiu> (\z -> (three . three) z)
12:53:25 <vanila> that's beta reduction
12:53:40 <rqiu> ok, that is what i am missing
12:54:00 <rqiu> i will read up on that, thanks a lot
12:54:08 <vanila> i was mostly looking at a different place in the derivation, sorry
12:54:10 <vanila> so just let me poin this out though, about types
12:54:14 <vanila> :t (\s z -> (s . s) z)
12:54:15 <lambdabot> (a -> a) -> a -> a
12:54:24 <vanila> :t let three = \s z -> (s . s . s) z in three
12:54:25 <lambdabot> (a -> a) -> a -> a
12:54:33 <vanila> but
12:54:47 <vanila> (\s z -> (s . s) z) :: ((a -> a) -> a -> a) -> (a -> a) -> a -> a
12:54:49 <vanila> is a valid judgement too
12:54:55 <vanila> and this is what allows us to pass three in
12:55:18 <vanila> your original expression is well typed
12:55:27 <vanila> :t let two = \s z -> (s . s) z ; three = \s z -> (s . s . s) z in two three
12:55:28 <lambdabot> (a -> a) -> a -> a
12:55:46 <vanila> and that means any time you replace a name with its definition, or perform beta reduction - the result will be well typed too
12:56:16 <rqiu> got it, appreciate your help on this!
12:56:21 <vanila> glad to :)
12:56:34 <ReinH> a and (a -> a) there use different `a'
12:57:08 <rqiu> absolutely, this is the key
12:57:10 <ReinH> in (b -> b), (a -> a) is a valid b, giving (a -> a) -> a -> a :)
12:58:19 <ReinH> For instance,
12:58:20 <ReinH> :t id `asAppliedTo` id
12:58:21 <lambdabot> (a -> a) -> a -> a
12:58:50 <ReinH> (everything vanila said is correct as well ofc)
13:01:05 <stephenmac7> @pl (\x y z -> x `append` y `append` z)
13:01:05 <lambdabot> (append .) . append
13:01:06 <rqiu> thanks ReinH
13:01:13 <ReinH> edwardk: np :)
13:01:25 <stephenmac7> Don't like that...
13:01:30 <ReinH> stephenmac7: what is append?
13:01:39 <stephenmac7> ReinH: Data.Text.append
13:01:47 <ReinH> isn't there a concat?
13:02:12 <ReinH> Otherwise, append forms a monoid with empty, so foldr append empty
13:02:21 <merijn> :t T.concat
13:02:22 <lambdabot>     Not in scope: ‘T.concat’
13:02:22 <lambdabot>     Perhaps you meant one of these:
13:02:22 <lambdabot>       ‘F.concat’ (imported from Data.Foldable),
13:02:28 <stephenmac7> :t Data.Text.concat
13:02:29 <lambdabot> [Data.Text.Internal.Text] -> Data.Text.Internal.Text
13:02:30 <merijn> ReinH: There should be, yes
13:02:44 <ReinH> so T.concat [x,y,z]
13:02:54 <stephenmac7> That works
13:03:08 <merijn> Probably more efficient too
13:03:22 <ReinH> Yus
13:03:38 <ReinH> It uses ST
13:06:24 <stephenmac7> merijn: I'm working on readability... but efficiency is nice too
13:07:12 <merijn> stephenmac7: Alternatively, there's a Monoid instance for Text which lets you write "x <> y <> z" since <> is infix mappend
13:07:29 <stephenmac7> No, this is fine. Thanks for the info though.
13:07:59 <stephenmac7> I am using the Text Monoid instance though. For mempty though.
13:09:13 <dfeuer_> > mempty :: Text
13:09:15 <lambdabot>  Not in scope: type constructor or class ‘Text’
13:09:24 <dfeuer_> > mempty :: Data.Text.Text
13:09:26 <lambdabot>  Not in scope: type constructor or class ‘Data.Text.Text’
13:09:37 <merijn> dfeuer_: That's obviously just an empty string
13:09:42 <vjeranc> i'm developing two packages at once, and one depends on the other, how would I use the other if they are separated by two cabal sandboxes? i've tried using cabal sandbox add-source but it doesn't seem to do a thing...
13:09:53 <merijn> dfeuer_: i.e. 'mempty == T.pack ""'
13:10:32 <Clint> or T.empty
13:11:00 <dfeuer_> Yes, merijn, that makes sense. I'm just tired and stuff.
13:11:17 <L8D> how often do do blocks become harmful?
13:11:23 <merijn> edwardk: Does trifecta (or parsers) have a nice way to parse significant whitespace/indentation? Or do I need to roll that myself using State?
13:11:47 <merijn> L8D: The main problem with do-blocks is that they obscure what's going on from beginners
13:11:52 <edwardk> i have some code for it, that i'm actually in the process of packaging up actually
13:12:16 <merijn> L8D: There's not really any issue with do-blocks as-is, assuming the underlying code is really a monad that obeys the laws
13:12:17 <merijn> edwardk: \o/
13:12:22 <stephenmac7> merijn: I had trouble understanding do blocks for a while and used >>= exclusively until I could understand what it was doing.
13:12:31 <L8D> merijn: but when you're doing a lot of IO-heavy operations like managing concurrent threads, they make the code much more readable
13:12:46 <L8D> is there some inherit flaw with them?
13:12:50 <merijn> stephenmac7: Right, I strongly recommend beginners avoid do-notation until they're capable of writing identical code using >> and >>=
13:12:53 <edwardk> merijn: it may not match haskell in 100% of all corner cases though
13:12:54 <stephenmac7> L8D: No, it's just syntax
13:13:06 <merijn> edwardk: I don't plan to match haskell anyway
13:13:24 <merijn> edwardk: I think haskell is too lenient, I plan to be stricter
13:13:44 <merijn> L8D: No, they literally just desugar to >>, >>= and let/in
13:13:49 <L8D> I get that
13:14:00 <L8D> but what about the "do-blocks considered harmful" paper?
13:14:10 <merijn> L8D: Did you read it?
13:14:19 <L8D> no
13:14:25 <L8D> does someone have a link?
13:14:32 <stephenmac7> @undo do { a <- [1..10]; b <- filter odd [1..10]; return $ a * b }
13:14:32 <lambdabot> [1 .. 10] >>= \ a -> filter odd [1 .. 10] >>= \ b -> return $ a * b
13:14:46 <clrnd> L8D, they make the code look more imperative, 'readable' is a little too subjective
13:14:54 <stephenmac7> L8D: I used @undo extensively
13:15:03 <lericson> so i shouldn't use do notation as a beginner haskell writer?
13:15:11 <stephenmac7> It shows you what the difference
13:15:14 <clrnd> you can always use a lot of where clauses and it'd look more 'declarative'
13:15:16 <hc> L8D: do you mean this one? https://www.haskell.org/haskellwiki/Do_notation_considered_harmful
13:15:30 <stephenmac7> lericson: I would call myself a beginner. It's subjective. It's just syntax.
13:15:31 <L8D> hc: I think so thanks
13:15:51 <merijn> clrnd: I don't think that's true
13:15:53 <clrnd> lericson, L8D I'm a begginner and in my experence avoiding do brings more understanding
13:16:08 <merijn> clrnd: For IO heavy code it *is* much more readable
13:16:22 <L8D> especially when working with mvars
13:16:23 <clrnd> merijn, yeah because IO is sequential, ofc
13:16:52 <clrnd> but there lot's of Monads
13:16:56 <stephenmac7> In IO it, in my opinion, makes things more readable
13:17:03 <lericson> how do you encode a conditional using >>= and >>
13:17:04 <stephenmac7> For everything else, it makes it harder to understand
13:17:25 <clrnd> stephenmac7, State also looks clean with do :P
13:18:14 <clrnd> I usually code in 'do style' and after refactor it with applicative and monadic infix operators
13:18:28 <stephenmac7> clrnd: Guess so.
13:18:48 <L8D> also dsls can use do very well
13:18:50 <stephenmac7> lericson: What do you mean, encode a conditional?
13:19:14 <L8D> typed tagless-final DSL looks amazing in do
13:19:48 <lericson> stephenmac7: someFunc >>= if Truth then a else b
13:19:59 <clrnd> L8D https://hackage.haskell.org/package/BASIC-0.1.5.0/docs/Language-BASIC.html
13:20:45 <stephenmac7> lericson: That would run either function a or function b
13:21:01 <stephenmac7> I wonder...
13:21:02 <stephenmac7> @do  someFunc >>= if Truth then a else b
13:21:02 <lambdabot> do { d <- someFunc; (if Truth then a else b) d}
13:21:08 <merijn> Parsing and pipes also look much nicer with do
13:21:36 <lericson> stephenmac7: interesting
13:21:47 <stephenmac7> merijn: Parsing does... attoparsec is my best friend
13:21:59 <stephenmac7> lericson: I'm not sure that's what you were trying to write :)
13:22:07 <lericson> it wasn't at all, but it was interesting
13:22:08 <L8D> how different is comprehension-notaion from do-notaion?
13:22:26 <stephenmac7> L8D: Comprehension is for lists
13:22:42 <lericson> stephenmac7: i want the expression to evaluate to either the value of a or b depending on someFunc
13:22:45 <L8D> I'm well aware
13:22:53 <L8D> @do [ x | x <- e ]
13:22:53 <lambdabot> [x | x <- e]
13:23:12 <L8D> what's lambdabot's desugarer for comprehensiosn?
13:23:30 <jedai> stephenmac7: Well MonadComprehensions are back
13:23:34 <stephenmac7> L8D: do { x <- [1..10]; return x }
13:23:41 <stephenmac7> jedai: Never heard of it
13:24:09 <stephenmac7> lericson: You mean someFunc >>= (\x -> if x then a else b)
13:24:10 <jedai> stephenmac7: basically work like the list comprehension but with an arbitrary monad
13:24:23 <L8D> stephenmac7: I though comprehensions were for enums
13:24:42 <jedai> > [ x | x <- Just 5 ] :: Maybe Int
13:24:44 <lambdabot>  Couldn't match expected type ‘Data.Maybe.Maybe GHC.Types.Int’
13:24:44 <lambdabot>              with actual type ‘[t0]’Couldn't match expected type ‘[t0]’
13:24:44 <lambdabot>              with actual type ‘Data.Maybe.Maybe a0’
13:25:02 <jedai> stephenmac7: you need to activate the extension though
13:25:15 <stephenmac7> jedai: I don't think I want that...
13:25:21 <lericson> monads make my head explode .(
13:25:35 <jedai> L8D: no, they have nothing to do with each other (except you often use a range in list comprehensions)
13:25:35 <L8D> lericson: just focus on the type
13:25:37 <stephenmac7> Especially if it still uses [], which automatically makes my brain think: LIST!
13:25:38 <geekosaur> L8D: [1..] is not a comprehension, just shorthand for an Enum method
13:25:42 <L8D> :i Monad
13:25:57 <geekosaur> no :i
13:26:15 <L8D> geekosaur: yes, I'm referring to [x|x<-y, x<7] notations
13:26:28 <geekosaur> right, and that has nothing to do with Enum
13:26:29 <jedai> stephenmac7: they're sometimes useful I guess, still a bit disorientating though, I agree
13:26:40 <geekosaur> sometimes Enum is combined with it, but it doesn't have to be
13:27:15 <lericson> what does Control.Monad.guard do? how do i use it? how does it relate to guard notation?
13:27:55 <jedai> lericson: it doesn't apart from the general sense that there's a test that govern the execution or not of a piece of code
13:27:58 <jedai> :t guard
13:27:58 <stephenmac7> L8D: You can make it happen.
13:27:59 <lambdabot> MonadPlus m => Bool -> m ()
13:28:28 <stephenmac7> > data Test = A | B | C deriving (Enum, Show, Eq)
13:28:30 <lambdabot>  <hint>:1:1: parse error on input ‘data’
13:28:34 <lericson> jedai: can i do guard notation stuff on monad functions? (actually what do you even call them?)
13:28:37 <jedai> lericson: "guard test action" will only execute the action if the test is True
13:28:38 <stephenmac7> We can't do that?
13:28:39 <lericson> i probably can't can i
13:29:01 <stephenmac7> lericson: You can use guards.
13:29:04 <vanila> @let data Test = A | B | C deriving (Enum, Show, Eq)
13:29:05 <stephenmac7> In do notation
13:29:06 <lambdabot>  Defined.
13:29:09 <jedai> lericson: I don't know what you mean ? Monad function ? What's that ?
13:29:09 <stephenmac7> vanila: Thanks
13:29:17 <stephenmac7> > [x | x <- [A ..], x `elem` [C,A]] :: [Test]
13:29:19 <lambdabot>  [A,C]
13:29:34 <lericson> stephenmac7: but it returns some kind of magical mystery type, how do i know that it evaluates properly?
13:30:20 <jedai> lericson: magical mystery type ? Well that depends on the Monad, the Maybe monad is not mysterious at all
13:30:30 <nschoe> Hey, can somebody tell me what the problem is with that code : http://lpaste.net/114063
13:30:30 <nschoe> I get a parse error on line 3
13:30:33 <stephenmac7> lericson: MonadPlus is just for Monads which are also Monoids
13:30:38 <jedai> lericson: reead All about monad for some examples
13:30:40 <L8D> ROLLUUUUUUUUP ROLL UP FOR THE MYSTERY TOUR
13:31:00 <stephenmac7>     class Monad m => MonadPlus m where
13:31:00 <stephenmac7>         mzero :: m a
13:31:00 <stephenmac7>         mplus :: m a -> m a -> m a
13:31:04 <stephenmac7> Pardon my copy-paste
13:31:12 <L8D> "the magicaly mystery tour is waiting to take you awaaaaay"
13:31:18 <L8D> "waiting to take you awaaay
13:31:35 <L8D> "roollluuuuuup, roll up for the mystery tour"
13:31:36 <jedai> lericson: Right, gueard only works on this typeclass because it's :
13:31:39 <jedai> @src guard
13:31:39 <lambdabot> guard True  = return ()
13:31:39 <lambdabot> guard False = mzero
13:31:41 <lericson> i think i broke L8D
13:31:58 <stephenmac7> :t guard
13:31:59 <lambdabot> MonadPlus m => Bool -> m ()
13:32:10 <L8D> http://youtu.be/n4_TXuU9ars
13:32:29 <nschoe> No idea for the parse error ?
13:32:31 <stephenmac7> lericson: It's probably easiest with Maybe
13:32:40 <jedai> Ooops I explianed when rather than guard
13:33:09 <jedai> lericson: basically guard short circuit an optional computation
13:33:14 <stephenmac7> > guard True :: Maybe ()
13:33:16 <lambdabot>  Just ()
13:33:24 <stephenmac7> > guard False :: Maybe ()
13:33:26 <lambdabot>  Nothing
13:33:31 <lericson> head now exploded
13:33:34 <lericson> how does that even work?
13:33:44 <jedai> lericson: typeclass ?
13:33:47 <L8D> lericson: it's called expiramental music
13:33:57 <L8D> lericson: they were really popular in the 60s
13:34:08 <L8D> lericson: don't worry, it has that effect on a lot of people
13:34:23 <jedai> basically if you put a "guard test" in your sequence of monadic action, it will cut it short if the test is False
13:34:49 <stephenmac7> lericson: It's like this. Lets say we have (Just 5), yes?
13:34:51 <lericson> i couldn't guard using isEOF
13:34:56 <jedai> lericson: for Maybe, that's because "Nothing >>= _" == "Nothing
13:34:58 <lericson> yes, stephenmac7
13:35:15 <stephenmac7> lericson: Now, what happens if we do Nothing >>= (Just 5)
13:35:19 <lericson> jedai: so that's defined for the Maybe type?
13:35:23 <stephenmac7> Sorry (return $ Just 5)
13:35:27 <jedai> lericson: no because isEOF is monadic
13:35:48 <jedai> but you could "do b <- isEOF; guard b"
13:36:35 <stephenmac7> lericson: That would be Nothing, right?
13:36:55 <L8D> :t guard
13:36:56 <lambdabot> MonadPlus m => Bool -> m ()
13:37:10 <L8D> guard False >> Just "foo"
13:37:17 <L8D> > guard False >> Just "foo"
13:37:18 <lambdabot>  Nothing
13:37:22 <L8D> > guard True >> Just "foo"
13:37:23 <lambdabot>  Just "foo"
13:37:46 <stephenmac7> lericson: Following?
13:38:19 <stephenmac7> I think he broke...
13:38:20 <L8D> Just "foo" >>= guard . (== "foo") >> Just "bar"
13:38:22 <L8D> > Just "foo" >>= guard . (== "foo") >> Just "bar"
13:38:24 <lambdabot>  Just "bar"
13:38:30 <L8D> > Just "not foo" >>= guard . (== "foo") >> Just "bar"
13:38:31 <lambdabot>  Nothing
13:39:59 <lericson> sorry, baking a pretty cake, had to check on it
13:40:09 <L8D> although: putStrLn("foo bar baz"); is completely legitimate haskell
13:40:39 <pharpend>  L8D true
13:41:30 <stephenmac7> lericson: Did you follow the above?
13:41:36 <lericson> yes i think
13:41:55 <lericson> return $ Just 5 would be Just 5
13:42:08 <lericson> apparently not
13:42:19 <jedai> lericson: return 5 == Just 5
13:42:25 <jedai> in the MAybe Monad
13:42:34 <jedai> > return 5 :: Maybe Int
13:42:35 <lambdabot>  Just 5
13:42:38 <stephenmac7> lericson: My mistake. I should have used (const $ Just 5)
13:42:54 <stephenmac7> :t const
13:42:55 <lambdabot> a -> b -> a
13:43:21 <jedai> stephenmac7: or >> rather than >>=
13:43:26 <stephenmac7> > const 5 ["Some", "discarded", "stuff"]
13:43:28 <lambdabot>  5
13:43:32 <lericson> but const doesn't have anything to do with monads?
13:43:38 <stephenmac7> lericson: No
13:44:17 <stephenmac7> jedai: Even better
13:44:51 <stephenmac7> lericson: So, now we know that if there are any Nothings in the chain, we will always get Nothing as a result, right?
13:45:03 <stephenmac7> > Just 5 >> Nothing >> Just 6 >> Just 7
13:45:04 <lambdabot>  Nothing
13:45:13 <stephenmac7> > Just 5 >> Just 34 >> Just 6 >> Just 7
13:45:15 <lambdabot>  Just 7
13:45:18 <stephenmac7> See that?
13:45:51 * lericson blinks
13:46:21 <stephenmac7> lericson: (>>), by the way, is just (>>=) that discards the result
13:46:30 <lericson> yes i read that today
13:46:59 <L8D> [1, 2, 3] >>= (:[])
13:47:03 <L8D> > [1, 2, 3] >>= (:[])
13:47:04 <stephenmac7> So anyway, you see how the maybe monad will break if there are any nothings?
13:47:05 <lambdabot>  [1,2,3]
13:47:15 <L8D> > [1, 2, 3] >> [4, 5, 6] >>= (:[])
13:47:17 <lambdabot>  [4,5,6,4,5,6,4,5,6]
13:47:34 <lericson> what does >> do with lists?
13:47:47 <L8D> > [1, 2, 3] >>= \_ -> [4, 5, 6]
13:47:49 <lambdabot>  [4,5,6,4,5,6,4,5,6]
13:47:50 <stephenmac7> > [1..10] >> [1..10]
13:47:52 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,...
13:48:17 <stephenmac7> lericson: It will give you the result the number of times the element appears in the list
13:48:34 <L8D> lericson: bind is flatMap
13:48:43 <jedai> lericson: same, it discard the result (but xs >> act still repeat act as many time as there are element in xs)
13:48:44 <stephenmac7> > [25,34] >> [1..5]
13:48:45 <lambdabot>  [1,2,3,4,5,1,2,3,4,5]
13:49:01 <L8D> [] >> [1, 2, 3]
13:49:05 <L8D> > [] >> [1, 2, 3]
13:49:07 <lambdabot>  []
13:49:14 <lericson> makes zero sense to me
13:49:18 <lericson> why would you choose that behavior?
13:49:23 <lericson> what is it trying to tell me?
13:49:25 <stephenmac7> lericson: That's why we are doing the maybe, not the list monad
13:49:28 <stephenmac7> :)
13:49:35 <stephenmac7> The reason is because of the behavior of >>=
13:49:40 <L8D> lericson: are you not familiar with the flatMap function?
13:49:46 <lericson> i am not, L8D
13:49:55 <L8D> sorry... in Haskell it's concatMap but everywhere else it's flatMap or mapCat or just bind
13:49:56 <jedai> lericson: "xs >>= \x -> act" perform act for every value of x taken in xs (think of it as a for loop)
13:50:13 <lericson> aha
13:50:30 <L8D> lericson: so are you familiar with monoids?
13:50:33 <stephenmac7> > [1..5] >>= (\x -> [1..5] >>= (\x -> (x, y)))
13:50:34 <lambdabot>  Couldn't match type ‘(,) t0’ with ‘[]’
13:50:34 <lambdabot>  Expected type: [Debug.SimpleReflect.Expr.Expr]
13:50:34 <lambdabot>    Actual type: (t0, Debug.SimpleReflect.Expr.Expr)
13:50:34 <lambdabot>  Relevant bindings include x :: t0 (bound at <interactive>:1:32)
13:50:40 <jedai> lericson: "xs >> act" is the same except act can't use the value of the "current element" you're looping over
13:50:55 <stephenmac7> jedai: That's what I trying to show.
13:51:22 <stephenmac7> lericson: The inner function gets applied as many times as there are elements in the list. The results are then concatenated.
13:51:25 <L8D> lericson: do you understand how Maybe is a monoid?
13:51:33 <jedai> stephenmac7: sure but I find it a bit hard to see with just example (some explanation + exemple often does the trick)
13:51:35 <L8D> stephenmac7: you don't need to explain that
13:51:53 <L8D> stephenmac7: you just need to explain how a monad works
13:52:01 <hexagoxel> > [1..5] >>= (\x -> [1..5] >>= (\y -> return (x, y)))
13:52:02 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3,...
13:52:06 <stephenmac7> L8D: He's talking about the list monad, specifically
13:52:30 <L8D> lericson: Maybe is a Monoid, mempty = Nothing; mappend Nothing _ = Nothing; mappend (Just _) x = x
13:52:39 <stephenmac7> hexagoxel: Thanks. I did something wrong.
13:52:53 <L8D> stephenmac7: yes but if he understands monads correctly then the list behavior would make sense
13:53:11 <L8D> but since he lacks that understand, he can't understand the lists behavior first
13:53:20 <L8D> sure you could explain what it is doing
13:53:28 <L8D> but you aren't explaining *why* it is doing that
13:53:38 <L8D> "why would you choose that behavior?"
13:53:40 <fragamus> sequence (c : cs) = return (:) ‘ap‘ c ‘ap‘ sequence cs
13:53:47 <fragamus> ok I think I get it
13:53:57 <stephenmac7> L8D: Got it.
13:54:13 <L8D> lericson: does what I said above make sense?
13:54:20 <L8D> about Maybe being a Monoid
13:54:21 <fragamus> return (:) is a monadic function and is the first argument of `ap`
13:55:07 <stephenmac7> L8D: I feel like mappend (Just x) (Just y) = Just (x `mappend` y)
13:55:09 <fragamus> then, c is "applied" to it, and since (:) needs two arguments, it is partial application
13:55:10 <stephenmac7> Not sure though
13:55:32 <L8D> > mappend (Just 1) (Just 2)
13:55:33 <lambdabot>  No instance for (GHC.Show.Show a0)
13:55:33 <lambdabot>    arising from a use of ‘M2752811515334967902450.show_M2752811515334967902450’
13:55:33 <lambdabot>  The type variable ‘a0’ is ambiguous
13:55:33 <lambdabot>  Note: there are several potential instances:
13:55:33 <lambdabot>    instance [safe] GHC.Show.Show
13:55:55 <fragamus> so then along comes `ap` again with sequence cs as another value to apply
13:55:59 <stephenmac7> > mappend (Just 1) (Just (5 :: Int))
13:56:01 <lambdabot>  No instance for (Data.Monoid.Monoid GHC.Types.Int)
13:56:01 <lambdabot>    arising from a use of ‘Data.Monoid.mappend’
13:56:11 <L8D> ah
13:56:13 <L8D> I stand corrected
13:56:37 <ReinH> And with AMP, that can be the arguably more pleasant sequence (c:cs) = (:) <$> c <*> sequence cs
13:56:38 <stephenmac7> L8D: It's inconsequential at the moment though :0
13:56:41 <stephenmac7> *:)
13:57:04 <albeit> :t ap
13:57:05 <lambdabot> Monad m => m (a -> b) -> m a -> m b
13:57:07 <L8D> the point to get accross is that you can represent monoid-functors as monads
13:57:29 <L8D> a >>= f = mconcat (fmap f a)
13:57:36 <L8D> but then!
13:57:37 <ReinH> Or, with banana brackets, sequence (c:cs) = (| c : sequence cs |).
13:57:49 <L8D> why isn't that the case for most Monads?
13:57:55 <ReinH> wait, do banana brackets support infix? I forget.
13:57:56 <L8D> because Monads are the types of the constructors
13:58:14 <L8D> and monoids are the types in the constructors
13:58:27 <L8D> and then you go into monads from there
13:58:39 <ReinH> L8D: Int isn't a monoid, but
13:58:52 <ReinH> > Just (Sum 1) <> Just (Sum 2)
13:58:52 <albeit> So "ap" is just "<*>" but more general?
13:58:54 <lambdabot>  Just (Sum {getSum = 3})
13:59:00 <ReinH> albeit: ap is <*> with a Monad constraint
13:59:04 <ReinH> which is less general
13:59:07 <L8D> ReinH: it's to explain why a >>= f = mconcat (fmap f a) isn't true for all monads
13:59:14 <albeit> Sorry, thats what I meant. Okay
13:59:14 <ReinH> L8D: ah.
14:00:08 <ReinH> BTW, I still love that you can do this:
14:00:10 <L8D> albeit: I believe all functors are basically applicatives
14:00:11 <ReinH> > @. pl djinn (a -> b -> c) -> (a -> b) -> (a -> c)
14:00:13 <lambdabot>  <hint>:1:1: parse error on input ‘@.’
14:00:16 <ReinH> @. pl djinn (a -> b -> c) -> (a -> b) -> (a -> c)
14:00:16 <lambdabot> f = ap
14:00:41 <stephenmac7> Basically, there are two monoids for Int, one for addition and the other for multiplication
14:00:51 <L8D> ap x = fmap (\f -> f x)
14:01:00 <stephenmac7> > (Product 10) <> (Product 2)
14:01:02 <lambdabot>  Product {getProduct = 20}
14:01:08 <stephenmac7> > getProduct $ (Product 10) <> (Product 2)
14:01:10 <lambdabot>  20
14:01:15 <L8D> stephenmac7: but you're not using either when doing Just 10 >> Just 5
14:01:34 <ReinH> There are others, but Sum and Product are pretty commonly used
14:01:54 <stephenmac7> L8D: So, the monad instance must not use mappend
14:02:20 <L8D> stephenmac7: well, monads don't need to use monoid functions at all
14:02:27 <L8D> stephenmac7: which is part of the point
14:02:37 <L8D> stephenmac7: "why isn't that the case for most Monads?"
14:02:44 <L8D> stephenmac7: "because Monads are the types of the constructors"
14:02:51 <L8D> stephenmac7: "and monoids are the types in the constructors"
14:03:14 <L8D> monads are like monoids but for functors of values intead of the values
14:03:30 <L8D> "Monads are just Monoids in the category of endo-functors"
14:03:35 <L8D> stephenmac7: starting to make sense?
14:03:51 <stephenmac7> L8D: Yes
14:04:22 <L8D> stephenmac7: that structure of explanation is how I learned and how I teach other people
14:04:46 <stephenmac7> L8D: Got it.
14:04:58 <jedai> I think lericson has run for the hill ...
14:05:23 <L8D> "start with functors, then explain monoids, then explain how monads relate to monoids, but then explain how and why they're different"
14:05:33 <jedai> He should probably have asked on #haskell-beginner I guess, there's less cooks in the kitchen there
14:05:35 <L8D> jedai: why is he learning haskell?
14:05:39 <stephenmac7> The thing that made monads click for me was that monads "take the value out of context"
14:05:53 <jedai> L8D: good question ! :-)
14:06:22 <stephenmac7> There's a #haskell-beginner?
14:06:32 <L8D> with that type of explanation, you can explain bind as a combination of fmap and mappend
14:06:33 <ReinH> L8D: I think you're using "monoidal functor" in two different ways
14:06:42 <jedai> stephenmac7: #haskell-beginners
14:06:51 <stephenmac7> Oh. Interesting.
14:06:51 <ReinH> [] isn't a Monad because [a] is a Monoid.
14:07:01 <jedai> stephenmac7: it's supposed to be for more in-depth pedagogical sequence
14:07:08 <stephenmac7> Maybe that's why I always get clobbered when I ask a general haskell question here
14:07:13 <ReinH> A monoid in the category of endofunctors is *any one object, i.e. any particular endofunctor*
14:07:20 <stephenmac7> If it involves a library, all I hear is crickets
14:07:31 <stephenmac7> If it's in the standard or GHC, 5 people answer
14:07:34 <jedai> this channel is generally friendly but it has the attention span of a gnat
14:08:03 <int-e> @quote fugue
14:08:04 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
14:08:18 <jedai> and it loves discussing higher abstraction and deep links between concepts
14:08:34 <ReinH> haha
14:09:43 <stephenmac7> Got to go now though. I had fun. Bye
14:12:20 <akurilin> question: how do I make hlint not yell at me for "parsing errors" within quasiquoted blocks?
14:12:39 <lericson> sorry, i was tending to my cake
14:12:46 <akurilin> I could just suppress "Parse error" but it's actually helpful outside of quasiquotation
14:13:15 <monochrom> I would suppress hlint altogether, but that's just me.
14:13:52 <merijn> jedai: That's how you learn :)
14:14:07 <merijn> jedai: Everything I know about category theory, I learned by parroting people in here :p
14:14:08 <lericson> L8D: somewhat, re making sense of a monoid
14:14:38 <ReinH> L8D: Also, monoidal functor has a meaning in CT that is different http://ncatlab.org/nlab/show/monoidal+functor
14:14:38 <L8D> lericson: what doesn't make sense?
14:14:40 <lericson> but what does it mean that the mappend of Nothing and anything else is Nothing? i understand that this is what gives rise to … >>= Nothing >>= … evaluating to Nothing
14:14:45 <jedai> merijn: the channel is fantastic, but that depends a bit on your goal
14:15:09 <merijn> lericson: What do you mean "what does it mean?"?
14:15:13 <lericson> merijn: that's how you learn. that's how you learn. *squawk* *squawk*
14:15:22 <monochrom> when someone asks me about "1+2", I do not begin with monoids and semigroups.
14:15:37 <merijn> lericson: "Maybe shortcircuits after the first Nothing", that's all there is to that
14:15:52 <monochrom> but you could take me wrong and say "yeah I know, you would begin with categories!"
14:16:07 <_2_lexie1357> Hey everyone
14:16:21 <merijn> lericson: In other words, the Monad instance for Maybe models "short-circuit after error"
14:16:35 <lericson> merijn: i see
14:16:37 <_2_lexie1357> :D
14:16:40 <lericson> merijn: well pu
14:16:41 <lericson> t
14:17:00 <L8D> > mconcat [Nothing, Nothing, Nothing, Just "foo"]
14:17:02 <lambdabot>  Just "foo"
14:17:03 <merijn> lericson: As for "what does that mean?", it means "people found that convenient to use and it happens to conform to the monad laws"
14:17:07 <L8D> > mconcat [Nothing, Nothing, Nothing, Just "foo", Nothing]
14:17:09 <lambdabot>  Just "foo"
14:17:12 <ReinH> What is the proposed connection between Monoid and Monad here?
14:17:22 <merijn> I'm not sure about that either
14:17:23 <L8D> > mconcat [Nothing, Just "bar", Nothing, Just "foo", Nothing]
14:17:25 <lambdabot>  Just "barfoo"
14:17:27 <ReinH> I don't think there is one.
14:17:35 <merijn> There is one, but at the type level
14:17:43 <merijn> In other words, it adds nothing here
14:17:44 <L8D> ReinH: there isn't
14:17:45 <ReinH> merijn: I mean Monoid and Monad, the typeclasses
14:17:51 <ReinH> not monoids and monads
14:18:06 <ReinH> Then why are we discussing the behavior of instance Monoid Maybe in terms of mconcat?
14:18:17 <L8D> we shouldn't have been
14:18:25 <L8D> I think I misslead someone
14:18:34 <L8D> we need jle` to save the day
14:18:50 <ReinH> "A monad is a monoid in the category of endofunctors" has nothing to do with the Monoid typeclass.
14:18:53 <merijn> lericson: The point is that people found out, "hey lots of useful things conform to the monad laws", which turned into "I wonder if by looking at things that conform to the monad laws, we can find other useful things"
14:19:22 <merijn> lericson: See also, the great article "You Could Have Invented Monads (and Maybe You Already Have!)"
14:20:09 <merijn> lericson: For example, stuff like Maybe and even the ability to do IO existed in Haskell, before anyone noticed monads were useful for this. Monads were added to haskell *after the fact*
14:20:45 <L8D> "added"
14:20:52 <L8D> more like "included"
14:21:01 <merijn> Which is what a lot of people conveniently gloss over and then proceed to claim "haskell doesn't work without monads!", it does and it has. It just turns out they're an incredibly versatile abstraction :)
14:21:06 <L8D> because you could easily just write your own typeclass
14:21:11 <merijn> L8D: Well, do notation and similar sugar was added
14:21:15 <merijn> But, yeah
14:21:25 <ReinH> In a type `m a', the m is a type constructor, e.g., a mapping from types to types. join :: m (m a) -> m a means that this mapping has the first monoidal property (appending), return :: a -> m a provides the second monoidal property (left and right identity)
14:21:31 <ReinH> (along with the monad laws)
14:21:57 <lericson> hey i think i just converted somewhat complicated do notation to non-do
14:22:22 <ReinH> (Monad m => m a means "for some type constructor m that is an instance of Monad and for all a)
14:22:23 <lericson> there is something very zen about haskell
14:22:32 <L8D> other than a learning curve, what are the major disadvantages of adopting Haskell? (over something common like say ruby or java or js or whatever)
14:22:34 <lericson> http://pb.lericson.se/p/XtzWKf/
14:22:49 <lericson> L13-24
14:23:15 <Refia> is there a good GUI framework binding for haskell? I know there's one for qt quick but is that the best there is?
14:23:21 <lericson> merijn: i see
14:23:33 <L8D> Refia: shade
14:23:42 <lericson> merijn: i'm really trying to grasp what a monad abstracts but it is so very abstract already
14:24:04 <Refia> L8D: thanks, hadn't heard of this before
14:24:27 <merijn> lericson: My recommendation: Don't bother
14:24:34 <jedai> lericson: your code is where guard eof could be useful
14:24:47 <lericson> jedai: thought as much, where would you put it?
14:24:47 <merijn> lericson: Instead, try and figure out the *individual* monad instances and understanding types/typeclasses
14:24:49 <Refia> i remember kind of wishing there were a Qt binding for it as good as PyQt but i have no idea how hard that'd be to implement
14:25:05 <jedai> hhmmm though I may be wrong
14:25:17 <jedai> since we're in IO
14:25:17 <merijn> lericson: IN a few weeks after using 8 different monad instances you'll get an intuitive feeling for what they capture
14:25:28 <MarkyMark>  @undo do x <- [3..4] ; [1..2] ; return (x, 42)
14:25:34 <merijn> lericson: Looks good, although a more traditional style of writing that would be: http://lpaste.net/114066
14:26:15 <ReinH> :t (>>=)
14:26:16 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:26:18 <ReinH> :t return
14:26:19 <lambdabot> Monad m => a -> m a
14:26:22 <merijn> lericson: btw, in addition to "You Could Have Invented Monads (and Maybe You Already Have!)" (which I would strongly recommend), Wadler's original paper explaining Monads to the haskell community is pretty readable, IMO
14:26:26 <lericson> in other news, is there a better way to encode what i'm trying to say? istm a very useful thing that, to map some kind of transformation over the lines of a file or stdin
14:26:37 <ReinH> This (and the associagted laws) is what a Monad abstracts. All of it.
14:26:59 <ReinH> lericson: I suspect that what you really want is a better intuition for how to *apply* this abstraction to concrete things :)
14:27:05 <MarkyMark> @undo do x <- [3..4] ; [1..2] ; return (x, 42)
14:27:05 <lambdabot> [3 .. 4] >>= \ x -> [1 .. 2] >> return (x, 42)
14:27:12 <merijn> lericson: http://roman-dushkin.narod.ru/files/fp__philip_wadler_001.pdf it has like 3-4 examples that it walks through
14:27:22 <merijn> lericson: But yeah "types + laws" is really all there is
14:27:22 <ReinH> lericson: And for that, you're better off looking at the definition of *instances* of Monad, like Maybe and [].
14:27:35 <ReinH> lericson: Work your way through their definitions of (>>=) and return.
14:27:36 <ezyang> Are there any combinators in the base library for building custom Ord instances?
14:27:40 <merijn> Typeclassopedia might be interesting too, after a bit more
14:27:50 <merijn> ezyang: In what sense?
14:27:55 <ReinH> ezyang: o/
14:27:57 <Refia> also i should probably ask if there's a generally accepted resource for haskell that will contain everything i need to learn it? I've been using learn you a haskell but i don't know how far it'll take me
14:28:02 <ezyang> like, Ordering -> Ordering -> Ordering
14:28:04 <Refia> it's been pretty neat so far though
14:28:17 <merijn> ezyang: Ordering is a Monoid instance
14:28:22 <jedai> lericson: the basic way is "fmap (f. lines) getContent"
14:28:23 <lericson> thanks for all the good words, all of you
14:28:32 <ezyang> ohhhh, is it a lexicographic instance
14:28:40 <lericson> jedai: i tried that, didn't work at all!
14:28:48 <merijn> ezyang: I know, it's pretty neat :)
14:28:51 <lericson> but the incantation i saw was fmap lines . getContent
14:28:52 <ReinH> Refia: *everything* is a pretty tall order, but Richard Bird's new book is a great introduction, and will leave you with a pretty sophisticated understanding of functional programming and Haskell in particular.
14:28:56 <jedai> lericson: though that's lazy IO which has its pitfall (in small program/script it's really nice though
14:29:04 <monochrom> ezyang: Data.Function.on, Data.Ord.comparing, and surprisingly Ordering being a Monoid instance are very useful
14:29:10 <lericson> jedai: lazy i/o is fine in this context i think
14:29:20 <ReinH> :t fmap lines . getContent
14:29:21 <lambdabot>     Not in scope: ‘getContent’
14:29:21 <lambdabot>     Perhaps you meant one of these:
14:29:21 <lambdabot>       ‘getContents’ (imported from Prelude),
14:29:23 <ReinH> :t fmap lines . getContents
14:29:24 <lambdabot>     Couldn't match expected type ‘a -> f String’
14:29:25 <lambdabot>                 with actual type ‘IO String’
14:29:25 <lambdabot>     In the second argument of ‘(.)’, namely ‘getContents’
14:29:31 <benmachine> Monoid Ordering + Monoid b => Monoid (a -> b) = amazing
14:29:32 <Refia> ReinH: Haha I probably should have worded it differently I guess, but thanks for the advice
14:29:35 <lericson> but i realize lazy evaluation and i/o protocol expectations might interact in a funny way
14:29:35 <merijn> Refia: Learn You a Haskell is a good start for learning the language, but to become practical you'd need to learn a considerable amount of library ecosystem. Real World Haskell (despite it's code samples being a bit out of date) is a good intro to various ecosystem bits
14:29:37 <MarkyMark> @undo do existing <- liftIO $ getById tg id; return $ fmap (\x -> (gid, x)) existing;
14:29:37 <lambdabot> liftIO $ getById tg id >>= \ existing -> return $ fmap (\ x -> (gid, x)) existing
14:29:48 <benzrf> Refia: LYAH is pedagogically unsound!!
14:29:55 <jedai> :t (let f = head in fmap (f. lines) getContents)
14:29:56 <Refia> why's that
14:29:56 <lambdabot> IO String
14:30:06 <Refia> also thanks merijn, i'll consider both of those
14:30:08 <jedai> lericson: seems to work perfectly
14:30:15 <ReinH> :t let getContents = undefined :: IO String in fmap lines . getContents
14:30:16 <benzrf> Refia: well, how much experience do you have with programming outside of haskell?
14:30:16 <lambdabot>     Couldn't match expected type ‘a -> f String’
14:30:16 <lambdabot>                 with actual type ‘IO String’
14:30:16 <lambdabot>     In the second argument of ‘(.)’, namely ‘getContents’
14:30:20 <Refia> well
14:30:26 <ReinH> Oh, woops
14:30:28 <jedai> lericson: getContents is not a function, you can't compose it with (.)
14:30:37 <Refia> most of my experience is in C++ and some Java
14:30:37 <benmachine> in the "compare = mconcat [comparing lastName, comparing firstName, ...]" style
14:30:37 <ReinH> :t getContents
14:30:38 <lambdabot> IO String
14:30:50 <benzrf> Refia: have you ever read an introduction to a language
14:30:50 <Refia> I still can't make anything super useful yet though
14:31:05 <ReinH> lericson: Let's translate fmap lines . getContents and see where it goes wrong
14:31:08 <Refia> I'm not sure what that entails
14:31:09 <ReinH> @src (.)
14:31:09 <lambdabot> (f . g) x = f (g x)
14:31:15 <benzrf> Refia: well
14:31:23 <jedai> lericson: if you want to do the same with a file you can use "readFile filename"
14:31:24 <benzrf> did you read something to teach you java?
14:31:29 <Refia> no
14:31:31 <ReinH> (fmap lines . getContents) x = fmap lines (getContents x)
14:31:33 <jedai> lericson: instead of getContents
14:31:34 <benzrf> ok bad example :b
14:31:39 <Refia> well
14:31:40 <benzrf> Refia: no analogies then...
14:31:43 <ReinH> lericson: This implies that getContents is a function that takes a value
14:31:45 <ReinH> :t getContents
14:31:45 <benzrf> Refia: the problem with lyah is that it
14:31:46 <ReinH> but it is not
14:31:46 <lambdabot> IO String
14:31:55 <benzrf> Refia: the problem with lyah is that it's a fine overview of the language and its features
14:32:00 <benzrf> but it doesn't teach you how to think
14:32:03 <Refia> for C/C++ we had a book we used but it was pretty bad
14:32:08 <Refia> examples that didn't compile and whatnot
14:32:15 <Refia> so I didn't really use that either
14:32:23 <benzrf> it might be a good way to learn haskell if you already know how to program functionally and grok some of haskell's concepts from math
14:32:32 <Refia> yeah, I'm entirely new to functional program
14:32:37 <benzrf> but if you read it without that preexisting knowledge, lyah really just gives you a superficial grasp of haskell
14:32:42 <Refia> programming*
14:32:55 <Refia> and I should say really high level languages in general?
14:32:59 <benzrf> heh
14:33:03 <Refia> like most of my interaction with haskell has been like
14:33:06 <ReinH> @google Thinking Functionally Richard Bird
14:33:08 <lambdabot> http://www.cambridge.org/us/academic/subjects/computer-science/programming-languages-and-applied-logic/thinking-functionally-haskell
14:33:08 <lambdabot> Title: Thinking Functionally with Haskell | Programming languages and applied logic ...
14:33:15 <Refia> being amazed that I can even DO half of the stuff I can
14:33:17 <ReinH> Refia: try that book. It's wonderful
14:33:20 <Refia> as easily as it's implemented
14:33:28 <Refia> I'll check it out
14:33:32 <Arahael> the problem with lyah is it's moronic english.
14:33:39 <benzrf> Arahael: pfft
14:33:40 <Refia> lol
14:33:56 <benzrf> Arahael: you're just jealous that bonus is funkier than you
14:34:08 <Refia> but yeah a lot of the constructs presented earlier on
14:34:08 <Arahael> i actually find it difficult to understand.
14:34:11 <ReinH> It teaches very good principles. The first two are about reasoning compositionally and "type-driven programming", for instance.
14:34:14 <Refia> like zip and stuff
14:34:16 <Refia> are pretty neat
14:34:21 <Arahael> rwh is much better.
14:34:34 <benzrf> Refia: i recommend #haskell-beginners for didactically sound haskell education ;)
14:34:43 <ReinH> Such didactics
14:34:48 <ReinH> Very pedagogy
14:35:04 <benzrf> er. pedagocically
14:35:04 <benzrf> shit
14:35:09 <ReinH> :p
14:35:11 <benzrf> im confusing my self-forced memes
14:35:37 <Refia> well i'll at least make it a point to take a look at both of those books
14:35:47 <Refia> my main motivation for learning haskell is just to learn to think differently
14:35:47 <Arahael> heh - not everyone speaks american.
14:35:58 <Refia> the whole immutable variables thing is still kinda mind blowing to me
14:35:59 <Refia> lol
14:36:09 <Hijiri> in line with #haskell-beginners: https://github.com/bitemyapp/learnhaskell
14:36:12 <benzrf> haskell doesn't have variables!
14:36:14 <benzrf> just name binding
14:36:20 <benzrf> or rather
14:36:24 <benzrf> it has mathematical variables
14:36:29 <benzrf> not this imperative trash
14:36:31 <jedai> Refia: especially the fact that you don't need them !
14:36:38 <Refia> are they kind of like consts in natrue
14:36:41 <Refia> *nature
14:36:45 <monochrom> yes
14:36:48 * hackagebot postgresql-binary 0.2.0 - Encoders and decoders for the PostgreSQL's binary format  http://hackage.haskell.org/package/postgresql-binary-0.2.0 (NikitaVolkov)
14:36:49 <Refia> oh ok
14:36:53 <Refia> that's easier to understand
14:37:19 <Refia> i assume that'd also mean stuff runs faster? well I guess it might depend
14:37:24 <benzrf> Refia: to be precise, haskell allows you to bind expressions to names for convenience
14:37:31 <benzrf> Refia: but in any case you could just directly use those expressions
14:37:35 <benzrf> like you can say:
14:37:35 <Refia> right
14:37:44 <benzrf> let x = 10 + 5 * 13 in x / 2
14:37:49 <benzrf> but you could also just say
14:37:52 <benzrf> (10 + 5 * 13) / 2
14:38:02 <benzrf> top-level definitions are exactly the same
14:38:22 <muzzle> does anyone know how i can load all sources of a project in cabal repl (not just those that are imported in the main module ?)
14:38:23 <Refia> well the second is a lot more readable to me but I'm not very good at this point lol
14:38:27 <jedai> Refia: Note that that's not true in general in imperative language since expression can have side effects
14:38:46 <Refia> yeah
14:38:59 <Refia> i guess it'd be a lot harder (or impossible? idk) to do stuff without them
14:39:34 <Refia> or maybe just a different way of thinking about it
14:39:50 <dmbaturin> Refia: You can live a good, active life with very few and well-encapsulated side effects.
14:41:25 <lericson> @source return
14:41:25 <lambdabot> Unknown command, try @list
14:41:26 <Refia> yeah i guess i find in programming usually almost anything i can imagine is possible but i'm terrible at making it happen lol
14:41:29 <lericson> @src return
14:41:29 <lambdabot> Source not found. Are you on drugs?
14:41:35 <lericson> yes as a matter of fact, why
14:41:48 <lericson> :t return
14:41:49 <lambdabot> Monad m => a -> m a
14:41:56 <Refia> i've been doing a lot of x86 assembly lately and the more i struggle with it the more magical haskell and other high level languages seem
14:41:58 <Refia> lol
14:42:51 <lericson> Refia: heh, my university has an interesting layout for the second year students (like me): learn haskell, prolog and syntax analysis while simultaneously learning formal logic, TTL logic, and how to implement a computer with those gates
14:42:57 <lericson> kinda full circle really
14:42:59 <merijn> I thought the STG paper was very good at "demagicing" haskell :)
14:43:02 <ReinH> lericson: it's not obvious, but you can get the source for some typeclass methods by asking for a particular type:
14:43:05 <ReinH> @src [] return
14:43:05 <lambdabot> return x = [x]
14:43:16 <merijn> Although the STG paper is not all that useful for actually learning haskell
14:43:25 <Hijiri> is the memory number that the +s flag in ghci shows the total memory allocated? As opposed to the maximum memory used or something else
14:43:28 <ReinH> lericson: you can also find them via hoogle or hackage
14:43:28 <Blizzy> anyone have any simple projects that I could do in Haskell to harden my Haskell skill?
14:43:37 <ReinH> Blizzy: what are you interested in?
14:43:43 <Refia> i'm having a ton of trouble in MASM just like allocating a 2D array that holds 25 byte-long arrays of chars cause I figured I'd have to split it up into like 7 dwords for it to fit and it's really messy
14:44:00 <Refia> I can't even look at my project atm, it's terrible
14:44:03 <Blizzy> ReinH, well, I love math, and I plan to be a Full Stack Dev.
14:44:07 <merijn> Refia: If that interests you, the STG paper describes in great detail how to compile Core (a minimal, lazy language that's used as GHC's internal representation) to C/ASM
14:44:09 <Blizzy> so IDK really. something math related?
14:44:28 <Refia> lazy evaluation in general is pretty interesting to me
14:44:34 <ReinH> Blizzy: everything is math related, FSVO related ;) what kind of math are you interested in?
14:44:37 <lericson> @src return :: a -> IO a
14:44:37 <lambdabot> Source not found. Where did you learn to type?
14:44:46 <Refia> although i don't think it's a universal answer
14:44:48 <merijn> Refia: It's a bit dated, but it provides a pretty good intuition of cost for lazy evaluation
14:44:49 <dmbaturin> What is STG paper and where do I find it?
14:44:52 <Refia> but I guess haskell can force strictness
14:44:57 <Blizzy> geometry.
14:44:59 <dmbaturin> That is, what is the title.
14:45:00 <Blizzy> I guess.
14:45:08 <ReinH> lericson: IO is basically built-in to GHC.
14:45:28 <merijn> dmbaturin: 1 sec
14:45:43 <merijn> dmbaturin, Refia: http://research.microsoft.com/apps/pubs/default.aspx?id=67083
14:45:50 <Refia> thanks
14:45:51 <ReinH> Blizzy: well, you could work on something graphics related, like a simple raytracer, although that involves a bit more than just geometry.
14:46:14 <benzrf> lericson: in ghc, IO is implemented as a state monad that wraps around impure functions
14:46:19 <Refia> i'd love to be able to get to the point where i can use haskell as my language of choice; my impression of it so far is that it's really ahead of its time
14:46:25 <dmbaturin> Refia: I strongly prefer AT&T syntax for x86. ;)
14:46:26 <benzrf> sort of
14:46:35 <benzrf> Refia: it was invented in the early 90s :p
14:46:39 <Refia> yeah
14:46:50 <dmbaturin> merijn: Thanks!
14:46:51 <Refia> still pretty cool
14:46:57 <merijn> It's easy to forget the age of languages
14:47:01 <Refia> and a lot of other languages are like just recently implementing some functional things
14:47:03 <benzrf> haskell is older than i am D:
14:47:06 <ReinH> Blizzy: a lot of the algorithms and data structures involved are interesting to work with in a pure language.
14:47:08 <lericson> i think haskell is too esoteric to be of use widespread use in the industry
14:47:12 <merijn> Erlang is all the hype, despite being even older than Haskell :p
14:47:14 <benzrf> lericson: u wot m8
14:47:16 <monochrom> my http://www.vex.net/~trebla/haskell/lazy.xhtml is simpler than the STG papers if you just want to know lazy evaluation and big-O costs
14:47:29 <merijn> lericson: You do realise there's several banks with >1 million LOC haskell codebases? :)
14:47:36 <josephle> welp, time to switch to rust and its arcane lifetime calculations
14:47:42 <Refia> dmbaturin: we haven't learned that
14:47:43 <ReinH> And defense contractors, and etc
14:47:46 <lericson> merijn: sure, doesn't make it less esoteric ;)
14:47:53 <Refia> but I'm really bad at x86 so
14:47:57 <ReinH> lericson: I think that was intended to dispute the other half of your claim ;)
14:48:30 <lericson> ah well, by "the industry" i mean the layman implementing some software for a back-office system or something like that
14:48:33 <monochrom> when asked how much does a car cost, some people are inclined to answer: "work in a car factory to find out"
14:48:33 <Refia> in my program one of the MASM macros messes with ECX I believe so I couldn't use loop without fiddling
14:48:38 <Refia> my answer was to just use ebx
14:48:39 <Refia> lol
14:48:44 <dmbaturin> Refia: If x86 is too annoying, try ARM, its instruction set is less screwed up (although it does have its oddities too).
14:48:57 <Refia> unfortunately, I need to use x86 for my class
14:49:06 <Refia> i think the most frustrating thing is lack of resources
14:49:10 <merijn> monochrom: To be fair, he was talking about x86 asm, not about big O cost, else I would not have gone for the STG paper :)
14:49:20 <merijn> monochrom: Well, x86 asm + haskell being magic
14:49:22 <Refia> there's like
14:49:39 <Refia> the intel developer's handbook, the textbook we use, and MASM help files, and the MASM forum
14:49:48 <Refia> and a lot of times i just have no idea how to do anything
14:49:49 <Refia> lol
14:50:11 <dmbaturin> Refia: Do they make you use winapi from it?
14:50:15 <Refia> not yet
14:50:18 <lericson> Refia: if only there was some kind of program that could translate your readable code into machine code..!
14:50:21 <Refia> but we will be transitioning to winAPI
14:50:24 <Blizzy> oh, thank you, ReinH.
14:50:36 <Refia> lericson: like ollydbg?
14:50:43 <Refia> i tried that route and didn't gain much from it
14:50:46 <lericson> Refia: i was thinking more like gcc ;)
14:51:05 <dmbaturin> Too few assembly courses are any good.
14:51:17 <Refia> there was too much asm for me to really comprehend how it was manipulating my arrays
14:51:20 <Refia> so many instructions
14:51:52 <dmbaturin> Well, compiler-produced assembly is very far from what a human would write anyway, so it's mostly helpful if you already know how to do it by hand.
14:51:58 <Refia> yeah
14:52:05 <Refia> i gave up on that idea fast
14:52:06 <Refia> lol
14:52:18 <exio4> write really slow code that is basically a hand-compiled unoptimized ⊂ of C
14:52:25 <Refia> i know 2D arrays are basically still contiguous in memory anyway
14:52:34 <Refia> but getting it to work is terrible
14:52:41 <Refia> i might just use winAPI, it might be easier to do
14:53:33 <dmbaturin> Refia: http://savannah.nongnu.org/projects/pgubook/
14:54:43 <Refia> dmbaturin: this looks like a pretty useful book, thanks
14:57:33 <ReinH> Woo next Haskell Cast is scheduled.
14:57:59 <S11001001> dmbaturin: I have the softcover of that :)
14:58:04 <nkar> ReinH: yay!
15:00:18 <dmbaturin> S11001001: Is print quality any good?
15:00:31 <S11001001> dmbaturin: yes, it's very nice
15:00:53 <Refia> I started with C/C++ and I've always been learning kinda closer to the machine; sometimes I feel like I'd have done cooler stuff if I started with like python or something, but it's neat knowing how a bunch of stuff works under the hood
15:01:03 <Refia> i do kinda want to branch out more at some point though
15:01:19 <dmbaturin> S11001001: I'm still to see any of cafepress-produced books. Maybe I should order some.
15:03:20 <dmbaturin> I started with pascal. If anyone told me about python, ML, haskell etc. at the time, I think my asolescence would have been way happier. :)
15:03:33 <Refia> the book we used for C was one of the worst organized i ever read, and I feel like C in general taught me a lot of habits that I had to unlearn in C++ lol
15:03:46 <Refia> if I could do it over I'd have just started with C++
15:04:16 <Refia> sometimes i still use some of the C subset when there's a cooler/probably safer C++ way
15:04:38 <jzl> help
15:04:48 <jzl> oops, sorry, mt
15:05:35 <dmbaturin> Refia: Do you know about MISRA rules?
15:05:52 <Darwin226> Is there a way to avoid stuff like a <- f x; b <- f y; g a b? Like, some what to do just g (f x) (f y) but implicitly unwrap the values?
15:05:54 <Refia> no, i don't
15:06:40 <jedai> Darwin226: Right
15:06:48 <ReinH> @pl \g f x y -> g (f x) (f y)
15:06:54 <lambdabot> join . ((flip . ((.) .)) .) . (.)
15:06:58 <jedai> Darwin226: g <$> f x <*> f y
15:06:58 <ReinH> Heh.
15:07:06 <YayMe> It occurs to me, is the `(->) a` monad implementation effectively the cont monad?
15:07:13 <ReinH> jedai: I don't think so?
15:07:18 <exio4> @pl f >>= \x → g >>= \y → g x y
15:07:22 <lambdabot> (line 1, column 11):
15:07:28 <lambdabot> unexpected "\134"
15:07:32 <exio4> @pl f >>= \x -> g >>= \y -> g x y
15:07:38 <lambdabot> (g >>=) . g =<< f
15:07:38 <Refia> i've been spoiled in C++ by using RAII more though, it makes me wonder how you keep track of potential leaks otherwise
15:07:47 <exio4> er, well, close enough
15:07:48 <ReinH> YayMe: (->) r is the Reader monad
15:07:51 <Refia> i never really got very far in C though
15:08:02 <jedai> ReinH: well depends on the type of g
15:08:08 <mauke> Refia: that's easier in C: there are no exceptions
15:08:12 <Darwin226> jedai: That should work. Does it require that the monad is also applicative? Is that always the case?
15:08:21 <mauke> and no operator overloading, so you can tell where your control flow goes
15:08:25 <ReinH> jedai: Does it? What type wold make this work? Identity?
15:08:29 <jedai> Darwin226: All Monads are Applicative (they should anyway)
15:08:37 <Darwin226> jedai: Great!
15:08:41 <YayMe> ReinH: Ok...  I don't think I understand that, but ok.
15:08:59 <jedai> ReinH: probably none, I'm trying to think how to make it work
15:09:01 <ReinH> YayMe: Reader is just another name for the ((->) a) monad
15:09:29 <ReinH> YayMe: Cont is a different sort of Monad.
15:09:46 <Refia> yeah, i guess a lot of leaks come from throw
15:09:47 <Refia> lol
15:10:01 <Refia> or early returns
15:10:09 <ReinH> jedai: it should work for identity, since the application you want to make that work is regular old function application ;)
15:10:44 <jedai> :t let f :: Int -> IO Int; g :: Int -> Int -> IO Bool in g <$> f 5 <*> f 3
15:10:48 <ReinH> jedai: maybe
15:10:50 <lambdabot>     The type signature for ‘f’ lacks an accompanying binding
15:10:56 <lambdabot>     The type signature for ‘g’ lacks an accompanying binding
15:11:05 <ReinH> :t \g f x y -> g <$> f x <*> f y
15:11:08 <lambdabot> Applicative f => (a -> a -> b) -> (t -> f a) -> t -> t -> f b
15:11:15 <jedai> :t let f :: Int -> IO Int; f = undefined ; g :: Int -> Int -> IO Bool ; g = undefined in g <$> f 5 <*> f 3
15:11:17 <lambdabot> IO (IO Bool)
15:11:21 <ReinH> :t \g f x y - g (f x) (f y)
15:11:21 <lambdabot> parse error on input ‘-’
15:11:25 <ReinH> :t \g f x y -> g (f x) (f y)
15:11:26 <lambdabot> (t1 -> t1 -> t) -> (t2 -> t1) -> t2 -> t2 -> t
15:11:27 <jedai> So a join after ?
15:11:30 <ReinH> Not quite :)
15:11:40 <jedai> :t let f :: Int -> IO Int; f = undefined ; g :: Int -> Int -> IO Bool ; g = undefined in join (g <$> f 5 <*> f 3)
15:11:41 <lambdabot> IO Bool
15:11:44 <ReinH> unless f is Identity
15:11:49 * hackagebot hasql-postgres 0.3.0 - A "PostgreSQL" backend for the "hasql" library  http://hackage.haskell.org/package/hasql-postgres-0.3.0 (NikitaVolkov)
15:11:59 <jedai> ReinH: Right, with a join it works but it ains't so clear...
15:12:17 <ReinH> I would recommend... g (f x) (f y)
15:12:36 <Darwin226> So, what's the solution in the end?
15:12:37 <jedai> ReinH: no (f x) is m a whereas g takes an a
15:13:02 <jedai> Darwin226: join (g <$> f x <*> f y) works, don't know if there's better
15:14:17 <Darwin226> That's fine. Thanks
15:14:22 <Darwin226> I see why it needs a join
15:15:07 <ReinH> jedai: Well, this is basically the "CPS applicative":
15:15:09 <ReinH> > (\g x y -> g <$> ($ x) <*> ($ y)) (+) 1 2 id
15:15:10 <lambdabot>  3
15:15:30 <ReinH> > (\g x y -> g <$> ($ x) <*> ($ y)) (+) 1 2 (+1)
15:15:31 <lambdabot>  5
15:19:22 <Darwin226> Thanks guys.
15:21:33 <ReinH> jedai: Oh no, never mind, f is a kleisli arrow
15:29:25 <sbrg> Is this the idiomatic way to use First? msum $ map First listOfMaybes
15:31:40 <jedai> :t msum
15:31:41 <lambdabot> MonadPlus m => [m a] -> m a
15:31:56 <jedai> sbrg: First is a Monoid, not a MonadPlus
15:32:02 <jedai> :t mconcat
15:32:03 <lambdabot> Monoid a => [a] -> a
15:32:33 <sbrg> eh, yeah
15:32:38 <sbrg> I meant mconcat
15:32:41 <sbrg> not sure why I wrote msum
15:33:06 <dibblego> @type getFirst . foldMap First
15:33:07 <lambdabot> Foldable t => t (Maybe a) -> Maybe a
15:33:31 <bitemyapp> dibblego: up for some type tetris from #haskell-beginners?
15:33:48 <dibblego> what is type tetris? I am still in hospital by the way
15:34:02 <bitemyapp> dibblego: I thought you were still in the hosp, yes. Hope you're recovering quickly.
15:34:13 <bitemyapp> dibblego: oh just kicking around terms that are = undefined, but trying to combine functions sensibly.
15:34:36 <dibblego> brb
15:35:30 <dibblego> bitemyapp: what is an example of type tetris?
15:35:49 <carlo_au> What's the deal with the premature end of stream error when trying to do cabal update?
15:35:52 <carlo_au> $ cabal update
15:35:52 <carlo_au> Config file path source is default config file.
15:35:52 <carlo_au> Config file /home/carlo/.cabal/config not found.
15:35:52 <carlo_au> Writing default configuration to /home/carlo/.cabal/config
15:35:52 <carlo_au> Downloading the latest package list from hackage.haskell.org
15:35:53 <carlo_au> cabal: Codec.Compression.Zlib: premature end of compressed stream
15:36:13 <carlo_au> Had this once before and removing ~/.cabal and ~/.ghc seemed to fix it, but not helping today.
15:36:46 <bitemyapp> dibblego: https://twitter.com/bitemyapp/status/531952534253211648
15:37:04 <dibblego> bitemyapp: ah I see
15:37:14 <dibblego> bitemyapp: I am going to do a lot of IO in my answer :)
15:37:52 <dibblego> bitemyapp: (.>>=.)
15:37:53 <dibblego> http://hackage.haskell.org/package/UtilityTM-0.0.4/docs/Control-Monad-TM.html
15:38:21 <bitemyapp> dibblego: that's the same code, but good to know it exists.
15:38:57 <bitemyapp> dibblego: guess I was hoping for something that didn't feel as weird as fmap'ing a join over the result of a traversal.
15:39:08 <bitemyapp> but I guess since the sequence is the final operation, it's impossible.
15:39:14 <merijn> bitemyapp: Why are you using undefined instead of typed holes for type-tetris?
15:39:15 <dibblego> that's pretty much what it is
15:39:37 <bitemyapp> merijn: it's ez-pz with undefined.
15:39:43 <bitemyapp> merijn: and we don't care about terms.
15:39:46 <bitemyapp> merijn: or holes.
15:40:17 <merijn> But it's also ez-pz to forget to fix an undefined and leave it in your code :p
15:40:18 <jfischoff> you could also use MaybeT but it won't be any better
15:40:38 <jfischoff> maybe a little bit
15:40:45 <bitemyapp> merijn: we're using undefined in ghci, not in our code.
15:40:51 <bitemyapp> merijn: quit being a grump :)
15:41:13 <jfischoff> runMaybeT $ g =<< MaybeT (return f)
15:42:06 <jfischoff> bitemyapp: in your tweet you meant let g = undefined :: b -> IO (Maybe a) not let g = undefined :: b -> IO (Maybe c) ?
15:42:49 <bitemyapp> letter names not important.
15:42:53 <bitemyapp> but yeah sure.
15:42:59 <bitemyapp> I'm using the same letter name semantics as GHC there.
15:43:56 <jfischoff> There would be no way to get a IO (Maybe a) from f and g that is all ;)
15:44:11 <jfischoff> but maybe I am missing the point
15:44:39 <bitemyapp> a doesn't mean anything
15:44:50 <bitemyapp> fmap g f gets you Maybe (IO (Maybe
15:44:55 <bitemyapp> f >>= g doesn't typecheck
15:45:01 <bitemyapp> sequence $ fmap is just traverse
15:45:08 <bitemyapp> traverse g f is IO (Maybe (Maybe
15:45:13 <bitemyapp> then you fmap the join.
15:45:27 <bitemyapp> but as I said earlier, fmap'ing a join feels *really* strange.
15:45:34 <bitemyapp> not that it can't make sense, just feels weird.
15:45:53 <jfischoff> but that would give an IO (Maybe c) no?
15:46:01 <bitemyapp> the letters don't mean anything
15:46:10 <bitemyapp> as benzrf suggested, you could ghost the IO with UPIO, >>=, then return back into IO
15:46:19 <bitemyapp> but we decided that was nuttier than jif.
15:46:44 <bitemyapp> bindy-traversey is more to the point, thus why dibblego pointed out the utility-tm lib.
15:47:05 <jfischoff> I think you are missing my point, or I am missing yours
15:47:17 <bitemyapp> you're fixating on a bit that doesn't matter
15:47:22 <bitemyapp> I was using GHC semantics for type variables.
15:47:31 <bitemyapp> 'a' doesn't mean anything outside of its type expression.
15:47:38 <jfischoff> "GHC semantics for type variables"
15:47:41 <bitemyapp> we don't have issues reaching terminal value and the terms are 'undefined'
15:47:55 <bitemyapp> you're making the 'a' mean something outside of its solitary type signature - it doesn't
15:48:02 <bitemyapp> what's being grappled with is the structure
15:48:38 <jfischoff> I am not talking about meaning, I'm pointing out that I think you have a typo
15:49:07 <bitemyapp> I know you think it's a typo
15:49:14 <monochrom> make :: forall a. (forall b. Maybe b) -> (forall x y. x -> IO (Maybe y)) -> IO (Maybe a)
15:49:41 <monochrom> can you write code for make?
15:50:37 <merijn> I'm pretty sure the problem here is that jfischoff and bitemyapp differ on where they think the forall is :)
15:50:46 <monochrom> yes
15:51:45 <merijn> jfischoff: bitemyapp is assuming that 'a', 'b', etc. are completely free. i.e. that "a ~ b" is possible
15:52:01 <merijn> jfischoff: Whereas you seem to assume that 'a' are potentially bound :)
15:53:21 <monochrom> this is a strange instance of:
15:53:31 <monochrom> @quote monochrom go.*polymorphic
15:53:31 <lambdabot> monochrom says: All pointless debates can be settled by going polymorphic.
16:08:50 <benmachine> bitemyapp: you do however depend on the b variable in f and g being the same fixed b, no?
16:09:04 <benmachine> bitemyapp: otherwise you can apply g to whatever you like and get an answer
16:09:33 <bitemyapp> there's more context provided than the types in the original tweet.
16:10:01 <bitemyapp> fmap join (traverse g f) did end up being the best way to do it, aka .>>=., aka concatMapM, aka concatTraverse
16:11:52 * hackagebot pyffi 0.4.0.2 - Call python inline from haskell  http://hackage.haskell.org/package/pyffi-0.4.0.2 (russell91)
16:14:40 <hiptobecubic> interesting. There's also Happy? HaPy? One of those
16:18:55 <vjeranc> should I be doing this (http://pastebin.com/kaEyaJX7), if I need a set of common functions for strict and lazy text, instead of duplicating the same function but exchanging the T. with L. ?
16:21:52 * hackagebot sws 0.1.0.0 - A simple web server for serving directories, similar to weborf.  http://hackage.haskell.org/package/sws-0.1.0.0 (DerekElkins)
16:22:17 <jfischoff> bitemyapp: Don't like Has classes huh ;) What is the alternative you propose?
16:23:03 <bitemyapp> jfischoff: ORFs, if you must.
16:23:09 <L8D> vjeranc: first you should stop using pastebin, second you should start using 4-space indents for haskell
16:23:11 <bitemyapp> jfischoff: but ORF doesn't even real yet :(
16:23:20 <jfischoff> oh
16:23:31 <jfischoff> Overloaded Record Fields
16:23:36 <bitemyapp> jfischoff: http://hackage.haskell.org/package/lens-2.6/docs/Control-Lens-TH.html#v:makeClassy
16:23:39 <bitemyapp> errrrr
16:23:41 <jfischoff> yes
16:23:42 <bitemyapp> ancient fuckin' lens version google.
16:23:45 <bitemyapp> g'dammit.
16:23:56 <jfischoff> Yeah that is fancier version
16:23:57 <bitemyapp> anyway, dat: http://hackage.haskell.org/package/lens-4.5/docs/Control-Lens-TH.html#v:makeClassy
16:24:05 <jfischoff> and ORF even fancier
16:24:15 <bitemyapp> I'm not sure I'd call ORF fancier.
16:24:17 <L8D> vjeranc: third, no the APIs should already be compatible
16:24:20 <bitemyapp> you don't get lenses with ORF! :)
16:24:24 <bitemyapp> jfischoff: the idea of having to write that myself is o_O
16:24:28 <L8D> *types
16:24:45 <jfischoff> bitemyapp: At one point at least the design worked with lenses
16:24:58 <bitemyapp> jfischoff: didna know that. That'll be fun.
16:25:06 * jfischoff nods
16:25:12 <bitemyapp> jfischoff: I'm not a huge fan of lawless typeclasses in general, but if they must exist, I'd rather they not involve hand-writing.
16:25:27 <bitemyapp> OTOH, it's the sort of of typeclass that probably won't break anything at runtime.
16:25:35 <bitemyapp> because it's just poly a -> specific type b
16:25:45 <vjeranc> L8D: what should I use instead of pastebin? as for 4 space indents, I use them but not everywhere, apis should be compatible? how should I do that then? is there a class/type for both lazy and strict text?
16:25:46 <bitemyapp> so that aspect is unobjectionable.
16:26:00 <L8D> vjeranc: lpaste, hastebin, pastie
16:26:02 <jfischoff> they are workaround to row types
16:26:02 <L8D> gist
16:26:07 <merijn> vjeranc: lpaste.net :)
16:26:08 <bitemyapp> jfischoff: oh, I know :)
16:26:16 <merijn> vjeranc: lpaste will automatically hlint your pastes too
16:26:30 <bitemyapp> jfischoff: I tell people workarounds to row poly all the time. That's one of them.
16:26:38 * jfischoff nods
16:26:40 <merijn> vjeranc: Not yet, but ezyang's work on backpack should make this much easier in the future :)
16:26:46 <c74d> vjeranc: <https://dpaste.de>, <https://refheap.com>, <https://gist.github.com>, <https://paste.ee>
16:26:48 <L8D> vjeranc: you should be able to just import Text and use that on both Lazy and Strict
16:26:52 * hackagebot ActionKid 0.1.1.0 - An easy-to-use video game framework for Haskell.  http://hackage.haskell.org/package/ActionKid-0.1.1.0 (AdityaBhargava)
16:26:59 <L8D> @quote pastebin
16:26:59 <lambdabot> No quotes match.
16:27:06 <merijn> L8D: That's not true
16:27:17 <vjeranc> hahaha, so many paste sites
16:27:27 <L8D> c74d: paste.ee sucks
16:27:41 <L8D> vjeranc: lpaste is the standard for this channel though
16:27:58 <vjeranc> L8D: oki doki...
16:28:13 * c74d has never used <https://paste.ee>; did find the Adobe Flash bits offputting.
16:29:13 <kadoban> I refuse to even use paste sites that require javascript, heh...flash would be right out.
16:30:22 <c74d> It’s not so bad as to require it (at least not to merely view pastes, I don’t know about posting them).
16:30:44 <kadoban> Oh okay, yeah that's not so bad then probably
16:31:11 <kadoban> There's one people use sometimes where you have to enable javascript to even view a paste...pretty genius
16:32:35 * c74d keeps Adobe Flash disabled; wouldn’t suggest a pastebin requiring it.
16:35:54 <L8D> c74d: yet you did
16:36:53 * hackagebot pyfi 0.4.0.2 - Call python inline from haskell  http://hackage.haskell.org/package/pyfi-0.4.0.2 (russell91)
16:36:55 * hackagebot help-esb 0.1.1 - A Haskell client for the Help.com team's ESB.  http://hackage.haskell.org/package/help-esb-0.1.1 (suitupalex)
16:38:11 <c74d> L8D: it does require Adobe Flash?
16:38:23 <L8D> c74d: to view pastes
16:38:33 <L8D> it's got some weird encryption system thing
16:38:42 <L8D> (which is utterly pointless)
16:39:21 <c74d> Ah; I’ve never been given an encrypted paste.ee paste. I’ll not recommend it, then.
16:41:22 <L8D> why do people still use python or ruby?
16:41:29 <L8D> they're so old
16:41:41 <L8D> :s/old/outdated
16:41:53 * hackagebot pyfi 0.4.0.3 - Call python inline from haskell  http://hackage.haskell.org/package/pyfi-0.4.0.3 (russell91)
16:41:55 * hackagebot help-esb 0.1.2 - A Haskell client for the Help.com team's ESB.  http://hackage.haskell.org/package/help-esb-0.1.2 (suitupalex)
16:43:26 <Yxven> they are simple and well supported
16:44:11 <derekv> L8D haskell 1.0 1990, python 1.0 1994
16:44:25 <derekv> from the google.
16:44:33 <L8D> yeah but there's so many problems with them
16:45:08 <derekv> well, ruby is alive due to rails I think
16:45:50 <benmachine> there are problems everywhere
16:45:55 <benmachine> let no-one tell you that language design is easy
16:46:12 <simpson> L8D: Python's as old as Linux.
16:46:18 <L8D> yeah but look at the problems ruby has and the problems people try to solve with it
16:46:27 <L8D> I meant outdated
16:46:49 <L8D> or the problems python has the problems people try to solve with it
16:46:56 <simpson> The idea of outdatedness should be taken hand-in-hand with the idea of not learning from the past.
17:03:13 <tranma> I have a small question regarding async
17:03:27 <tranma> let f :: IO a; g :: a -> IO b
17:03:51 <tranma> if I do x <- f; async (g x), that works as intended
17:04:08 <tranma> but async (g <$> f) doesn't work, i.e the (g <$> f) never gets run
17:04:23 <merijn> tranma: You're getting the type wrong
17:04:33 <merijn> tranma: "g <$> f :: IO (IO b)"
17:04:43 <merijn> You want "f >>= g"
17:04:52 <tranma> oh, of course, I need a join if I want to do that
17:05:00 <merijn> tranma: Right :)
17:05:12 <tranma> and I didn't notice because that's also an IO and async is fine with that >__<
17:05:18 <tranma> damn, thanks
17:21:46 <giogadi> Hi everyone, I've just uploaded a package candidate to hackage, but the haddock docs aren't showing up; is there a step I'm missing, or do I just have to wait a while before the docs get compiled?
17:22:00 <bitemyapp> giogadi: you probably just have to wait a bit.
17:22:50 <giogadi> bitemyapp: ok, thanks!
17:23:12 <Enigmagic> sometimes they never get built -_-
17:23:21 <merijn> Enigmagic: That should be fixed now
17:23:34 <merijn> The problem used to be Hackage not having the necessary C libraries
17:23:58 <merijn> But there's dedicated docs building machines now, gracefully donated by some company I forgot the name of
17:24:12 <merijn> So if docs don't build, report it in #haskell-infrastructure
17:24:20 <giogadi> will do, thanks!
17:24:31 <merijn> (it may still take a while)
17:25:53 <bitemyapp> merijn: davean (user), and rackspace (company)
17:41:49 <begriffs_> I'm trying to serialize the output of a generic postgresql-simple query to JSON, but unsure how to navigate the types. It's giving me [r] where r is FromRow, and I want to make that an instance of ToJSON. Anyone have experience with this?
17:46:55 * hackagebot growler 0.3.2 - A revised version of the scotty library that attempts to be simpler and more performant.  http://hackage.haskell.org/package/growler-0.3.2 (IanDuncan)
17:49:01 <Pamelloes> Would it be better to store hierarchical data via Tree-like data structure or as a Map with a hierarchical key?
17:56:38 <BMeph> Pamelloes: Do both: Use a Trie! :)
17:58:28 <emmanueloga> Q: it is ok to say: "[1,2,3] is a functor" ? i.e., [1,2,3] is a value of type [Int], and [Int] is an instance of Functor, which means fmap is defined for [1,2,3] and obeys the Functor laws.
17:59:17 <L8D> @where lyah
17:59:24 <L8D> :(
18:04:06 <bitonic> emmanueloga: [Int] is not an instance of Functor
18:04:42 <bitonic> emmanueloga: you’d usually say that “[] is a functor”.  you’d probably spell ’[]’ “list” :P
18:05:47 <bitonic> ,
18:06:43 <emmanueloga> chan! I was afraid I would get something wrong. I try to put this stuff in informal words to see if I can settle down the concepts, but then I'm afraid I may get it wrong since I can't verify by myself my wording is correct  :)
18:07:18 <bitonic> emmanueloga: no worries.  terminology is important but I wouldn’t get too wound up in it, as soon as you know what you mean :)
18:07:23 <emmanueloga> ah! I think I know what you mean. Because the functor definition takes a partial type, right? I.e. Maybe and not Maybe Int, [] and not [Int], etc.
18:07:58 <bitonic> emmanueloga: well, I’ve never heard “partial type” before, but it takes something of kind ‘* -> *‘, something which has a non-applied type-parameter
18:08:03 <bitonic> > :k []
18:08:15 <bitonic> oh.  lambdabot’s dead
18:08:29 <bitonic> anyway.  ‘:k []’ would have been ‘* -> *’
18:08:38 <bitonic> ‘:k [Int]’ is ‘*’
18:08:59 <bitonic> that arrow tells you that ‘[]’ takes a type-parameter and forms a type
18:12:19 <emmanueloga> got it. s/partial type/not a concrete type/
18:13:20 <bitonic> emmanueloga: well, something of kind ‘* -> *’ is not a type at all, in the sense that it does not contain values.  I’d call it “type former”, or “type constructor” in this case
18:14:31 <bitonic> so you can call ‘[Int]’ type and ‘[]‘ type former.  or in this case, you have a more specific word – functor :)
18:15:03 <emmanueloga> cool :)
18:18:01 <ReinH> bitonic: The naming convention I've seen is that "type" refers to types of any kind, "type constructor" refers to types of kind * -> k, where k is any kind. On the other hand, the wiki says that a type constructor can have "zero or more arguments", so maybe there isn't any real consensus on the naming yet..
18:19:18 <bitonic> ReinH: right… personally I’d hesitate to call something of kind ‘* -> *’ type, since as I said it’s never going to appear to the right of a ‘::’.  but maybe I’m not in line with the Haskell mainstream ehe
18:19:41 <ReinH> (well, it won't appear unless fully saturated)
18:19:45 <bitonic> ReinH: I can understand that a type constructor can have n arguments including 0, that makes sense
18:20:01 <bitonic> ReinH: yeah I meant that it won’t appear as-is
18:20:09 <ReinH> Yeah, I see what you mean now.
18:20:25 <ReinH> "The right hand side of :: will never be of kind * -> k for any kind k"
18:20:47 <bitonic> personally I’d call it type former.  but if nobody gets type former than it’s useless :P.
18:21:31 <ReinH> Well, the kind "*" is also pronounced "type"...
18:21:51 <bitonic> ReinH: I’ve always pronounced that “star”
18:22:22 <ReinH> bitonic: http://en.wikipedia.org/wiki/Kind_(type_theory) 'a primitive type, denoted * and called "type"'
18:22:31 <ReinH> I hear "star" a lot though
18:22:56 <bitonic> ReinH: even that single phrase is confusing.  I think star is better.
18:23:04 <bitonic> a type if something of kind “*”.
18:23:05 <ReinH> A Functor is a particular kind of type constructor. Pun intended.
18:24:37 <ReinH> Which is to say: a Functor must be a type constructor of kind * -> *, like [], Maybe, or Either String
18:25:13 <davean> "Enigmagic sometimes they never get built -_-" "merijn Enigmagic: That should be fixed now" no, some will just never get built for a bunch of reasons, I will always TRY to build them now though.
18:25:26 <bitonic> dependent types make this terminology simpler.  probably one of the few things that they make simpler
18:25:36 <davean> I'm trying pretty hard to build everything
18:25:45 <davean> but somethings just aren't buildable
18:26:00 <ReinH> davean: <3
18:26:03 <davean> if it doesn't build though, please report it. I'll at least get you a very clear reason WHY
18:26:10 <Welkin> what is the easiest way to add a new non-null field to a postgres table?
18:26:19 <Welkin> if I add it, it will complain that the field is null
18:26:27 <Welkin> I want to generate the value based on existing fields
18:26:27 <davean> and do my best to fix anything else
18:27:03 <Welkin> otherwise, I would destroy the table and create a new one
18:29:22 <davean> "10:18:35 bitemyapp giogadi: you probably just have to wait a bit." the correct amount of time to wait is 2 hours, past that it is officially a bug
18:47:41 <Welkin> would it make sense to store the length of a list of text in the same table where the content is stored?
18:47:53 <Welkin> rather than calculating the length at runtime?
18:48:03 <Welkin> the length will never (or rarely) change
18:48:44 <Welkin> it seems like something that would be best done in a front-end cache, not the primary database, though
19:00:27 <davean> assuming that http://hackage.haskell.org/package/kdt-0.1.0/candidate is giogadi's issue package, there is definately an issue
19:00:40 <davean> docs are defiantely getting built.
19:01:12 <davean> That one got built
19:01:17 <davean> It has a log with no failures
19:01:22 <davean> but no report, and no docs tar.
19:01:28 <bitonic> davean: docs haven’t been building for a bit
19:01:33 <bitonic> you can find some info on the ML
19:01:42 <ReinH> Welkin: It seems reasonable to me.
19:01:48 <davean> bitonic: I mange the doc builder, they're building.
19:02:03 <ReinH> I
19:02:09 <ReinH> "I am the one who knocks"
19:02:20 <L8D> wait a second...
19:02:22 <bitonic> davean: oh.  so that’s fixed :)
19:02:28 <davean> bitonic: for a while now :)
19:02:29 <bitonic> I guess they’re not showing up though
19:02:31 <L8D> :t lift2
19:02:33 <lambdabot>     Not in scope: ‘lift2’
19:02:33 <lambdabot>     Perhaps you meant one of these:
19:02:33 <lambdabot>       ‘liftM’ (imported from Control.Monad.Writer),
19:02:36 <L8D> :t liftM
19:02:37 <ReinH> :t liftM2
19:02:37 <davean> Sure they are
19:02:37 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
19:02:38 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
19:02:52 <L8D> :t (=<<)
19:02:53 <lambdabot> Monad m => (a -> m b) -> m a -> m b
19:03:07 <ReinH> L8D: liftM is fmap with a Monad constraint. liftM2 f a b is f <$> a <*> b with a Monad constraint
19:03:14 <davean> bitonic: Just go down http://hackage.haskell.org/packages/recent and you'll see most have docs built
19:03:24 <L8D> ReinH: what's the difference between (=<<) and liftM?
19:03:28 <ReinH> :t fmap
19:03:30 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:03:31 <ReinH> :t (=<<)
19:03:32 <lambdabot> Monad m => (a -> m b) -> m a -> m b
19:03:34 <bitonic> davean: right, nice
19:03:38 <L8D> no liftM not fmap
19:03:42 <L8D> :t liftM
19:03:43 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
19:03:45 <ReinH> One takes a function (a -> b), the other takes a function (a -> m b)
19:03:47 <L8D> :t (=<<)
19:03:49 <lambdabot> Monad m => (a -> m b) -> m a -> m b
19:03:52 <ReinH> L8D: liftM is the same as fmap
19:03:53 <davean> bitonic: it was fixed sometime back in Oct.
19:03:57 <L8D> ReinH: oh got ti
19:03:58 <L8D> I see
19:04:05 <L8D> ReinH: what's the point of liftM
19:04:10 <bitonic> L8D: no, it’s not – liftM uses >>= as it’s implementation
19:04:12 <davean> bitonic: "sometime" being hard to define because it came in stages
19:04:16 <L8D> bitonic: oh
19:04:17 <ReinH> L8D: liftM is fmap with a Monad constraint.
19:04:27 <bitonic> L8D: so they might act differently
19:04:30 <L8D> but isn't there an instance of Functor for all Monads?
19:04:35 <ReinH> bitonic: No
19:04:38 <ReinH> @src liftM
19:04:38 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
19:04:41 <bitonic> L8D: not in GHC 7.8
19:04:48 <ReinH> bitonic: the monad laws say they are the same
19:04:48 <L8D> what?
19:04:52 <L8D> why not?!
19:04:59 <ReinH> L8D: historical reasons
19:05:04 <bitonic> L8D: there will be in 7.10, but I would expect the definition of ‘liftM‘ to stay
19:05:07 <benzrf> hysterical raisins
19:05:10 <ReinH> that too
19:05:25 <L8D> -.-
19:05:35 <L8D> also, while I'm at it
19:05:40 <L8D> what's the point of Applicative?
19:05:50 <L8D> aren't all functors applicatives?
19:05:55 <Hijiri> some things are applicative but not monad
19:05:58 <bitonic> ReinH: sure, but they’re not the same function.  nothing in the type system or the language guarantees you that they’re the same.
19:06:01 <L8D> or are there applicatives that are not functors?
19:06:10 <Hijiri> applicative is more powerful than functor
19:06:12 <ReinH> bitonic: they are morally equivalent
19:06:13 <bitonic> ReinH: so pretending they are is asking for trouble, imo.
19:06:17 <ReinH> if they are not equivalent, it is a bug
19:06:17 <merijn> Hijiri: No
19:06:22 <merijn> Hijiri: Functor is a superclass of Applicative
19:06:38 <bitonic> ReinH: sure, but they’re not “the same”
19:06:40 <ReinH> bitonic: it is totally reasonable to expect fmap and liftM to have the same behavior
19:07:03 <Hijiri> well something with an applicative instance is more powerful than something with a functor instance and no sensible applicative one
19:07:06 <ReinH> They are equivalent.
19:07:09 <bitonic> ReinH: it’s reasonable but if you tell me they’re “the same” I expect “liftM = fmap”
19:07:10 <ReinH> That's enough.
19:07:13 <Hijiri> I don't know what else I could have meant
19:07:18 <benzrf> bitonic: that's true
19:07:21 <benzrf> assuming law-abiding instance
19:07:22 <benzrf> s
19:07:35 <L8D> isn't: ap x = fmap ($ x)
19:07:35 <ReinH> bitonic: Ok. Not worth arguing.
19:07:42 <ReinH> L8D: ap is <*>
19:07:43 <Hijiri> and the former wouldnecessarily have a functor instance of course
19:07:45 <benzrf> L8D: wrong type
19:07:59 <L8D> could you not define ap that way?
19:08:05 <ReinH> :t fmap ($ x)
19:08:06 <lambdabot> Functor f => f (Expr -> b) -> f b
19:08:09 <ReinH> er
19:08:13 <ReinH> :t \x -> fmap ($ x)
19:08:14 <lambdabot> Functor f => a -> f (a -> b) -> f b
19:08:19 <ReinH> :t (<*>)
19:08:19 <L8D> :T ap
19:08:20 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
19:08:23 <ReinH> No.
19:08:31 <bitonic> ReinH: : OK, that’s definitely not true :P
19:08:37 <L8D> ooooh
19:08:44 <L8D> I need to pay more attention to these types
19:08:47 <bitonic> ReinH: ap can behave differently not breaking any laws, and in fact it does for many Applicatives that I use
19:09:01 <bitonic> or at least I see them in the wild
19:09:16 <ReinH> Like what?
19:09:23 <merijn> bitonic: The consesus is, that, given a type that can be both Applicative and Monad, the Applicative instance MUST match the monad instance
19:09:28 <merijn> See list for example
19:09:32 <ReinH> ap will be <*> in 7.10
19:09:40 <merijn> There's a reason the Applicative matches Monad, rather than ZipList
19:09:46 <bitonic> ReinH: for example some Future monad
19:09:52 <bitonic> e.g. the Hack library that facebook released
19:10:00 <ReinH> I would again consider any actual difference between ap and <*> to be a bug.
19:10:06 <ReinH> This one isn't backed up by equational reasoning
19:10:10 <ReinH> But it is backed up by practice.
19:10:10 <bitonic> ReinH: tell that to Simon Marlow :P
19:10:16 <merijn> bitonic: Both implementation have the same semantics and ap can trivially be implemented using <*>
19:10:24 <merijn> bitonic: Which is exactly what will happen in 7.10
19:10:39 <ReinH> bitonic: Ok. Maybe we'll have him on again and I can mention it :p
19:11:08 <merijn> bitonic: ap not being efficient is an artifact of history (i.e. ap not being a member of the Monad class)
19:11:08 <bitonic> merijn: still, saying now that they’re “the same” is asking for trouble.  I eagerly await the day where ap = (<*>)
19:11:27 <merijn> bitonic: They're denotationally the same
19:11:45 <bitonic> merijn: sure.  if you’re writing useful programs right now you need to know the difference
19:12:06 <bitonic> of why you might want to use “sequenceA” and not “sequence”, etc.
19:12:18 <bitonic> and this is a pretty big operational difference btw
19:12:24 <bitonic> some programs just won’t work if you use ap and not <*>
19:12:34 <ReinH> I That isn't the difference between sequence and sequenceA
19:12:40 <ReinH> :t sequence
19:12:41 <lambdabot> Monad m => [m a] -> m [a]
19:12:42 <ReinH> :t sequenceA
19:12:43 <bitonic> and surely saying that they’re “the same” doesn’t help anybody
19:12:43 <lambdabot>     Not in scope: ‘sequenceA’
19:12:43 <lambdabot>     Perhaps you meant one of these:
19:12:43 <lambdabot>       ‘T.sequenceA’ (imported from Data.Traversable),
19:12:47 <ReinH> :t T.sequenceA
19:12:47 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
19:12:52 <bitonic> ReinH: without considering the difference betwen [] and the traversable
19:13:03 <bitonic> I mean even if you instance t to []
19:13:15 <ReinH> Ah, I see. You're happy to ignore material differences so you can point out immaterial ones. :D
19:13:23 <bitonic> their difference is due to the difference between ap and <*>
19:13:35 <merijn> Anyway, this discussion is going in circles.
19:13:48 <merijn> Let's agree to disagree on the meaning of "the same"
19:13:53 <ReinH> +1
19:14:01 <bitonic> merijn: sure, I’ve made my point :P.  I’ve tripped over this personally
19:15:30 <ex3me> хуй
19:15:36 <bitonic> is the “burning bridges” thing definitely out with 7.10?
19:16:05 <merijn> Quick poll: Would there be an interest in a "Your first GHC patch" walkthrough on how to contribute to GHC?
19:16:14 <hiptobecubic> yes
19:16:24 <ReinH> merijn: yes
19:16:56 <merijn> Ok, I figured I could write up the steps I went through, but I don't wanna waste my time if everyone's already happy with the wiki :p
19:16:59 <darkbolt> merijn: im hardly qualified to write a patch for it, but i think it's a very healthy thing for a mature project to have
19:17:12 <merijn> darkbolt: Well, there's already a whole bunch of wiki material
19:17:39 <merijn> darkbolt: So I was thinking more of "quickstart" that distills the relevant bits from different wiki articles into a single walkthrough
19:18:02 <darkbolt> I think my point still stands in that scenario :)
19:18:07 <merijn> Although this'd go at the end of my todo queue, so it'll be a while before I get around to it
19:18:29 <Welkin> I'd like to use a Map in my database through Persistent
19:18:37 <Welkin> PersistMap is just an association list, though
19:18:37 <merijn> darkbolt: Actually, in my experience big Haskell projects are surprisingly easy to contribute to with moderate haskell skills :)
19:18:55 <davean> http://hackage.haskell.org/package/kdt-0.1.0/candidate now has docs, via manually uploading. It clearly has a reproducable upload (not build) issue. I'll be looking into it but there clearly is some deeper problem here.
19:18:59 <Welkin> is it better to work with the data as an association list or convert it to a Map?
19:19:09 <Welkin> I'd need to convert it back again to store it
19:19:10 <ReinH> merijn: one of the nice things is that purity gives you actual, tangible encapsulation.
19:19:13 <merijn> darkbolt: I've had *much* less difficulty patching/fixing pandoc and GHC than I've had with even very small python projects :)
19:19:26 <ReinH> purity and/or referential transparency
19:19:29 <merijn> ReinH: Plus: Types <3
19:19:32 <ReinH> merijn: yep
19:20:30 <Welkin> what is the runtime complexity of Data.List.length?
19:20:35 <merijn> Welkin: n
19:20:47 <Welkin> oops
19:20:52 <Welkin> I meant Data.List.sort
19:20:58 <merijn> Welkin: O(log n)
19:21:09 <merijn> Pretty sure the docs mention this
19:21:15 <Welkin> oh?
19:21:19 <merijn> It just uses merge sort
19:21:26 <Welkin> okay
19:21:37 <Welkin> you are right
19:21:40 <Welkin> it is merge sort
19:21:45 <Welkin> my favorite
19:21:51 <Hijiri> not n log n?
19:21:54 <merijn> hmm, apparently the docs don't mention it, but anyway, it's mergesort
19:21:58 <merijn> Hijiri: oh, right, yeah
19:22:02 <merijn> My bad >.>
19:22:15 <merijn> Welkin: Documentation patches welcome ;)
19:22:21 <ReinH> merijn: You have an O(log n) sort? I would like to subscribe to your newsletter.
19:22:36 <merijn> ReinH: Yeah, right next to my guaranteed compression algorithm :)
19:22:47 <ReinH> :D
19:31:56 <cerivera> in GHC, why does ":t (3, 'b')" return "Num t => (t, Char)" instead of "(Num, Char)"?
19:32:05 <cerivera> it seams to work with every other data type except for numbers
19:32:49 <Welkin> Num is a typeclass
19:32:51 <Welkin> not a type
19:33:06 <cerivera> thanks
19:33:09 <Welkin> it doesn't know if it is an Int, Integer, Double, etc
19:36:35 <Welkin> would it be better to write my own functions to insert into an association list, keeping it sorted, or convert it to a Map to perform operations, then convert it back into an association list when I am finished?
19:36:41 <numberten> is there a recommended lightweight http-server?
19:36:47 <Welkin> numberten: Warp?
19:37:20 <numberten> thanks :)
19:38:22 <Welkin> numberten: https://www.haskell.org/haskellwiki/Web/Servers
19:38:32 <numberten> yeah :D
19:39:05 <bitonic> Welkin: I would almost always use a Map, but it depends on how you use it
19:39:28 <Welkin> bitonic: well, I am only ever going to insert one item before converting it back and storing it in the database
19:40:08 <bitonic> Welkin: so wait, you store this assoc list, and when you want to add a new element, you deserialize, build a Map, insert one element, serialize?
19:40:17 <Welkin> unfortunately, it must be stored as an association list because of how PersistMap is implemented
19:40:24 <Welkin> yes
19:40:31 <Welkin> I want it to stay sorted
19:41:08 <merijn> Why not implement sorted insertion?
19:41:11 <bitonic> Welkin: yeah, then I’d insert it directly.
19:41:16 <merijn> Hell, that's what insert does
19:41:24 <merijn> (I think)
19:41:41 <bitonic> :t insertBy
19:41:42 <lambdabot> (a -> a -> Ordering) -> a -> [a] -> [a]
19:41:58 <bitonic> :t insertBy (comparing fst)
19:41:59 <lambdabot> Ord a => (a, b) -> [(a, b)] -> [(a, b)]
19:42:11 <merijn> bitonic: Pretty sure insert already does by ordering
19:42:16 <merijn> :t insert
19:42:16 <lambdabot> Ord a => a -> [a] -> [a]
19:42:24 <bitonic> merijn: presumably he needs to compare the key only
19:42:27 <merijn> tuples are sorted by first element first
19:42:52 <bitonic> merijn: right, but no point in comparing the second
19:42:56 <Welkin> okay, and yes, keys only
19:43:07 <Welkin> obviously the keys are unique, so that would work
19:43:08 <bitonic> Welkin: the only problem with this version is that it allows duplicates.  you need to watch out if you don’t want them.
19:43:17 <bitonic> Welkin: and you probably don’t, if a Map made sense to you.
19:43:18 <Welkin> heh, yes
19:43:24 <Welkin> I'd have to check for tht
19:44:31 <bitonic> Welkin: I almost always prefer a Map because that way you can’t get it wrong.  but this is really a case that begs for a sorted list I suppose
19:44:45 <bitonic> so be careful ehe
19:45:32 <bitonic> Welkin: can’t whatever database you’re using handle the sortedness for you?
19:45:45 <bitonic> that’s part of what databases are for
19:45:55 <Welkin> it is stored as text (json)
19:46:01 <Welkin> in a single field
19:46:13 <bitonic> Welkin: why?
19:46:18 <Welkin> I have to treat the data as a whole
19:46:29 <Welkin> I'm using postgres
19:47:08 <Welkin> it is variable length, so it doesn't make sense to store the items in separate fields
19:47:25 <bitonic> Welkin: what’s variable length?
19:47:45 <Welkin> the list
19:48:05 <Welkin> I haven't looked into postgres arrays, but supposedly the support is not that great
19:48:17 <bitonic> Welkin: right, you’d add and remove rows, and have those keys as indices.  but anyway, just wanted to make sure that you had considered that :)
19:48:21 <Welkin> I'm using Persistent, which stores lists as json
19:49:43 <Welkin> the data is meant to be retrieved all at once to be displayed to a user, so separating it didn't make sense
19:49:49 <Welkin> it is essentially a "document"
19:51:00 <bitonic> Welkin: OK.  just wanted to bring that point up, I often forget that when I’m using a DB I should take advantage of it, instead of using it as some glorified key-value store
19:51:29 <Welkin> bitonic: thank you for the input
19:51:41 <Welkin> designing database schemas can be tricky
19:52:37 <bitonic> I think databases get a bad rap.  in the end a thing like Postgres can really do a lot of lifting without too much effort.  by the way, these days it understands JSON as well
19:53:53 <bitonic> Welkin: good luck
19:54:15 <davidthomas> bitonic: SQL would make me happier if there were first class sum types
19:54:50 <Welkin> in fact, I may not have to sort the data at all if I build the page first, then use an ajax call to insert the missing pieces of data (out of order)
19:57:07 <eer> Is it customary to export the functions created by makeLenses, or should I just remake them in the module which imports a data structure?
19:57:16 <Welkin> that may make sense, since this data is updated/created by the user through ajax
19:58:06 <davidthomas> Welkin: it may - but generally I try not to depend on JS for a dumb view of static content :-P
19:58:33 <davidthomas> context dependent, though, for sure
19:58:49 <Welkin> it's just that I have to build the page sequentially, in order
19:59:18 <Welkin> and even if the data is sorted, there may be gaps
20:02:01 * hackagebot cufft 0.1.1.0 - Haskell bindings for the CUFFT library  http://hackage.haskell.org/package/cufft-0.1.1.0 (RobEverest)
20:07:47 <merijn> eer: If you're depending on lens and using makeLenses, I would expect you to export them, yes
20:17:26 <eer> ok - thanks!
20:18:31 <eer> the only thing is that for large records it's cumbersome to list all of the individual record names
20:20:09 <merijn> eer: The lack of TH export generation is a bummer, yes
20:20:48 <merijn> eer: The work around is the following. Export everything from an internal module (i.e. no export list) then have another module import + reexport it, hiding whichever identifiers you want to hide
20:21:46 <eer> yeah - I just thought of that...
20:22:09 <eer> one internal module per data structure :-)
20:27:02 * hackagebot kdt 0.1.0 - Fast and flexible k-d trees for various types of point queries.  http://hackage.haskell.org/package/kdt-0.1.0 (giogadi)
20:32:02 * hackagebot conduit-combinators 0.3.0.2 - Commonly used conduit functions, for both chunked and unchunked data  http://hackage.haskell.org/package/conduit-combinators-0.3.0.2 (MichaelSloan)
20:36:07 <merijn> edwardk: ping?
20:45:25 <edwardk> merijn: what's up?
20:46:52 <merijn> edwardk: Your gl package just came up as "worst offender" in terms of number of modules per directory, so I wanted to ask if you had any input on my planned changes to GHC file finder
20:47:12 <edwardk> i didn't even know you had planned changes
20:47:23 <edwardk> we do push 750+ modules out in gl though
20:47:24 <merijn> edwardk: Currently GHC just tries all 4 possible extensions to a module, but I was planning to switch to one that allows wildcard for literate haskell
20:47:31 <edwardk> and it is going to get worse with webgl support in the end
20:47:43 <merijn> edwardk: Well, you were one of the ones replying to my proposal ;)
20:47:47 <edwardk> meh, i don't think the file finding overhead is my biggest concern
20:48:13 <edwardk> merijn: I'm a little scattered these days. i vaguely recall one, just not that it was you =)
20:48:22 <merijn> edwardk: The total number isn't really relevant, the simplest solution is to scan the entire directory for a module, I just don't know how bad that would impact performance :)
20:48:49 <edwardk> well, i think the worst case we have is ARB or NV
20:48:52 <merijn> edwardk: Alternatively, since there's a module cache I could add the entire directory whenever I look for one module
20:49:13 <merijn> I'll probably do the latter if it's reasonably doable
20:49:28 <edwardk> we're talking 157 modules in a directory in my worst lib
20:49:42 <edwardk> we can also bound the problem because it seems windows craps out at about 700 total for a project
20:49:56 <edwardk> so in practice you are looking at a thing where you aren't the bottleneck
20:49:57 <edwardk> scan away
20:50:07 <merijn> edwardk: Right, with a single scan to add everything that'd be ok. A linear scan per module would be a bit painful if it has 157 ;)
20:50:18 <edwardk> > 157^2
20:50:19 <lambdabot>  24649
20:50:27 <edwardk> i don't think a loop that size will kill us =P
20:50:41 <edwardk> i hear computers can do things kinda fast
20:50:47 <merijn> edwardk: Lies!
20:50:51 <edwardk> get another digit on there and we have to talk ;)
20:51:16 <edwardk> just trying to put the problem scale in perspective
20:51:21 <edwardk> quadratic is fine for small n ;)
20:51:36 <merijn> edwardk: Yeah, I was fairly sure it'd be fine, just wanted to doublecheck :)
20:52:02 <edwardk> if you feel the need to scan linearly once and cache and stuff you can put any concern to rest but frankly i think you'd be fine doing 'the dumb thing' and just going with it
20:52:07 <edwardk> so i have no concerns in practice
20:52:36 <edwardk> the fact that gl kinda pushed the limits of how big a package can be and still build on all platforms pretty much shut down my concerns
20:52:51 <merijn> ok :)
20:57:03 * hackagebot conduit-combinators 0.3.0.3 - Commonly used conduit functions, for both chunked and unchunked data  http://hackage.haskell.org/package/conduit-combinators-0.3.0.3 (MichaelSloan)
21:02:39 <L8D> Why isn't Int like CUInt?
21:03:45 <merijn> L8D: Why isn't cat like dog? :)
21:03:59 <L8D> merijn: I mean why doesn't Int act like CUInt?
21:04:05 <L8D> and then... Why not just alias the two?
21:04:05 <merijn> Why would it?
21:04:15 <merijn> L8D: That would be terribad
21:04:23 <L8D> > fromInteger 9999999999999999999 :: Int
21:04:24 <lambdabot>  -8446744073709551617
21:04:24 <merijn> CUInt behaves like a C unsigned int
21:04:32 <merijn> Int is a haskell integer
21:04:35 <L8D> > fromInteger 9999999999999999999 :: CUInt
21:04:37 <lambdabot>  Not in scope: type constructor or class ‘CUInt’
21:04:38 <merijn> > maxBound :: Int
21:04:40 <lambdabot>  9223372036854775807
21:04:46 <L8D> > fromInteger 9999999999999999999 :: Foreign.C.Types.CUInt
21:04:47 <lambdabot>  Not in scope: type constructor or class ‘Foreign.C.Types.CUInt’
21:05:13 <merijn> L8D: I'm not sure what you're trying to point out with those?
21:05:17 <L8D> well the above evals to 2313682943
21:05:26 <L8D> merijn: Int doesn't seem bound
21:05:31 <merijn> It is
21:05:46 <int-e> for ghc, Int is 64 bits on 64 bit platforms
21:05:49 <merijn> But if you have 64bit GHC Int is 64 bit
21:05:55 <L8D> then why did it wrap to a negative val?
21:05:57 <merijn> As shown by lambdabot
21:06:02 <int-e> L8D: it's still signed
21:06:08 <MP2E> what do you mean? If it weren't bounded it wouldn't wrap.
21:06:14 <merijn> L8D: Because your value is bigger than the maximum value?
21:06:24 <L8D> I mean...
21:06:32 <L8D> why don't they have the same wrapping behavior?
21:06:37 <int-e> > (2^63-1 :: Int, 2^63 :: Int)
21:06:38 <lambdabot>  (9223372036854775807,-9223372036854775808)
21:06:38 <MP2E> Because one is signed and one isn't
21:06:45 <merijn> L8D: Because they're not the same size?
21:06:46 <MP2E> and also they may be different sizes even
21:06:49 <L8D> Ooooo
21:06:53 <merijn> L8D: And they're not even the same sign
21:06:56 <L8D> derp
21:07:00 <L8D> I'm retarded
21:07:04 <merijn> L8D: Unsigned int by definition is always positive?
21:07:18 <L8D> I forgot about the unsigned part
21:07:22 <L8D> derp
21:07:34 <merijn> L8D: But as MP2E points out they can be different sizes too
21:07:38 <prinsen> A question about functional dependencies. I have class Interpret f t | f -> t. However I want to write instance (Monad m) => Interpret A (B m) where... but thats not possible. Is there any solution?
21:07:49 <L8D> How big is CInt?
21:07:56 <merijn> L8D: It depends on your platform
21:08:17 <merijn> L8D: The C standard doesn't specify a size, other than "at least 32bit"
21:08:37 <merijn> On 64bit linux, for example, CInt is often 64bit. But on 64bit OSX CInt is 32bit
21:09:24 <L8D> why doesn't GHC specify?
21:09:27 <MP2E> Huh, didn't know there was an x86_64 OS that set C's Integer size to anything but 64-bit
21:09:35 <merijn> L8D: How can GHC specify what the size of C values are?
21:09:36 <MP2E> good to know
21:10:03 <merijn> MP2E: I know this because I found a bug in the haskell RTS triggered by this + linux' broken posix compatibility
21:10:05 <L8D> merijn: so it relies on gcc?
21:10:11 <merijn> MP2E: Needless to say it's a pain
21:10:17 <L8D> CInt directly translates to C?
21:10:18 <MP2E> I'll bet x.x
21:10:19 <merijn> L8D: No, it's determined by the C ABI
21:10:46 <int-e> merijn: actually the C standard allows 16 bit ints.
21:10:51 <merijn> L8D: At the machine code level there is no language. But if you want to call code compiled from another language you need to know what it looks like
21:11:01 <int-e> (but ghc will not work on such platforms)
21:11:17 <merijn> L8D: The ABI (Application Binary Interface) specifies what things look like in machine code
21:11:38 <L8D> how is that inferred?
21:11:42 <merijn> L8D: The goal of CInt and friends is to be used when calling C through the foreign function interface
21:11:43 <L8D> when GHC is compiled?
21:11:54 <merijn> L8D: It's not inferred, it's hardcoded for every platform
21:12:07 <L8D> I mean how does GHC infer the ABI?
21:12:17 <L8D> is there something in /sys or what?
21:12:22 <merijn> L8D: It doesn't, it uses the ABI of the OS you're compiling on
21:12:32 <L8D> so it gets it at compile time
21:12:56 <merijn> L8D: When *GHC* is compiled for platform X, the information for platform X is hardcoded
21:13:03 <L8D> got it
21:13:20 <L8D> I meant compile time as in when ghc is compiled
21:13:48 <merijn> L8D: Right
21:14:13 <merijn> L8D: In other words, the only guarantee you get about CInt is "it will match whatever int is on this platform"
21:14:30 <L8D> but couldn't you easily redefine int?
21:14:32 <L8D> in C
21:14:47 <L8D> for gcc
21:15:30 <prinsen> Is there any fancy way of expressing | f -> forallm.  t m as a fundep?
21:15:48 <int-e> L8D: where are you going with these questions?
21:16:08 <L8D> to understand Foreign.C better
21:16:37 <MP2E> You could redefine Int in gccs codebase, but I would hardly call it easy :)
21:16:41 <MP2E> you'd break a bunch of existing code
21:16:44 <nshepperd> prinsen: could you make it "class Interpret f t | f -> t where { ... }"
21:16:51 <MP2E> I doubt you would be able to compile GHC's dependencies, let alone it itself
21:16:57 <MP2E> without lots of patching at least!
21:17:15 <nshepperd> prinsen: and then have the functions in the class talk about (Monad m) => t m instead of just t
21:17:23 <merijn> int-e: Ugh, why is the standard so hard to check >.> I wanted to double check the minimum size of int, but can't find it >.>
21:17:33 <nshepperd> prinsen: that way your instance would just be "instance Interpret A B"
21:17:36 <int-e> L8D: there's usually a standard ABI, and gcc will adher to that. Anything else will just cause problems with libraries.
21:17:49 <prinsen> nshepperd: I have the class class Interpret f t where interpret :: f -> t
21:18:03 <merijn> L8D: The ABI is hardcoded inside gcc/clang too
21:18:22 <prinsen> I want to create instances like Interpret Int (TransT m Char)
21:18:31 <prinsen> but that is not possible
21:18:39 <int-e> merijn: searching for limits.h turns up a hit in 5.2.4.2.1 "Sizes of iinteger types <limits.h>"
21:18:51 <int-e> (minus the typo)
21:18:56 <nshepperd> hmm
21:19:14 <prinsen> nshepperd: In some cases there is no monad m
21:19:15 <merijn> int-e: Sure, but that's not the minimum required by the spec, afaik?
21:19:29 <prinsen> nshepperd: I have instances like Interpret Foo Bar where
21:19:36 <nshepperd> "instance Interpret Int (forall m. TransT m Char)"?
21:19:51 <prinsen> nshepperd: Ill try that
21:19:54 <int-e> merijn: it defined INT_MIN and INT_MAX, and afaik that's the data to use for inferrinf the minimum bit sizes.
21:19:59 <nshepperd> I don't know if that's allowed, might need some extension
21:20:41 <prinsen> nshepperd: Illegal polymorphic or qualified type:
21:20:54 <merijn> int-e: You're right
21:21:05 <merijn> int-e: I glossed over that
21:21:32 <prinsen> nshepperd: Illegal polymorphic or qualified type:
21:21:36 <prinsen> nshepperd: sry repost
21:21:56 <prinsen> nshepperd: RankNTypes does not help
21:22:25 <merijn> prinsen: Pretty sure that forall violates the fundep
21:22:45 <prinsen> merijn: seems so. Do you know any other solution=
21:23:47 <merijn> Not really, other than avoiding multiparam typeclasses
21:23:58 <merijn> prinsen: Can you explain a bit what you're trying to do?
21:28:41 <Welkin> how would I handle the case where a user's session has timed out (thus they are no longer authenticated) but they are still on a page which requires authentication and make an ajax request from that expired page?
21:29:03 <Welkin> currently, I get a pattern-match failure, because in my handler function I assume the user is authenticated
21:29:09 <Welkin> since the auth system should take care of that
21:29:13 <prinsen> merijn: Im writing an interpreter for ECMA-262. I have an AST and writing a type class for evaluating that AST. class Interpret f t where interpret :: f -> t. This works good but I need to add type declarations everywhere to specify the right instance, ie (t :: ExprTo) <- interpret e. As ECMA-script is stateful, interpreting some expressions need state so I have a stack ExceptT StateT m... Where m is used to implement host objects. So I hav
21:29:15 <Welkin> but it doesn't work in this special case
21:29:55 <merijn> Why exactly is this a typeclass?
21:30:09 <prinsen> one never knows ;)
21:30:16 <merijn> I'm not sure why "interpret :: f -> t" makes sense?
21:30:43 <merijn> prinsen: Experience teaches me that typeclasses tend to lead more pain than help if you don't know specifically why you need one
21:30:45 <prinsen> To avoid writing 300 differently named functions
21:31:37 <merijn> Why would you need to do that?
21:31:53 <merijn> Can you lpaste your AST type?
21:32:00 <prinsen> merijn: sure
21:32:25 <lpaste> prinsen pasted “AST” at http://lpaste.net/114076
21:33:32 <nshepperd> perhaps this AST would work better as one big GADT
21:33:41 <merijn> prinsen: Ouch, I expect you make this much nicer using GADTs and help solve your typing woes too
21:33:44 <merijn> nshepperd++
21:33:57 <merijn> prinsen: I would also consider simplifying your AST
21:34:13 <prinsen> merijn: Im trying to keeping this very close to the spec
21:34:21 <merijn> prinsen: For example, what's the value of having a "Finally" type?
21:34:43 <merijn> Why not turn "TryStmtBF Block Finally" into "TryStmtBF Block Block"?
21:34:44 <prinsen> I started of looking at HJS, but it was very hard as it differed so much from the spec
21:35:05 <nshepperd> data AST a where { ... BoolLit :: Bool -> AST Bool ... }
21:35:08 <nshepperd> for example
21:35:20 <merijn> prinsen: "keeping this very close to the spec" will cause you a lot of pain if you have such an overly specific AST
21:35:50 <prinsen> im not familiar with GADTS
21:36:29 <nshepperd> and then the equivalent of your interpret function is just "interpret :: AST a -> a"
21:36:59 <Basedsiren> elli
21:37:04 <prinsen> merijn: Well I have a lexer and a parser for this AST, just some "minor" inconviniences. Its over 4000 lines, I really dont want big changes :(
21:37:47 <merijn> prinsen: The problem is that such a specific AST might be "pretty" while parsing, but it makes modifying the AST an utter pain, as you're noticing
21:40:43 <prinsen> im going to be stubborn and complete this, almost done
22:03:49 <adas> what are my options if I want to use haskell on ARM?
22:04:05 <prinsen> merijn: Another question. I have type a + b = Either a b, and type JSMaybe a = a + Undefined
22:04:11 <prinsen> and the patterns
22:04:14 <prinsen> pattern JSNothing = Right Undefined
22:04:20 <merijn> adas: ARM is tier2, so you can probably make it work, but it'll probably involve scouring the wiki/asking around in #ghc
22:04:21 <prinsen> pattern JSJust a = Left a
22:04:36 <adas> merijn: tier2?
22:04:51 <Welkin> I ended up using Map for my data
22:04:53 <merijn> adas: GHC has a list of officially supported platforms and how well they're supported
22:04:54 <Welkin> it works very nicely
22:05:05 <prinsen> These two patterns should be complete right? But i still get Pattern match(es) are non-exhaustive
22:05:11 <adas> merijn: ah okay .. so arm support is tier 2
22:05:15 <merijn> adas: See https://ghc.haskell.org/trac/ghc/wiki/Platforms
22:05:16 <Welkin> I'm sure it is not the most efficient way of handling my constant database accesses
22:05:28 <Welkin> since I am converting back and forth between a Map and an association list every time
22:05:34 <merijn> adas: tier 2 is "mostly works, but needs work"
22:05:40 <Welkin> but it was really easy to implement
22:05:47 <adas> cool. thanks
22:05:49 <merijn> adas: "Tier 2 platforms work (to varying degrees), but we rely on community support for developing, testing, and building distributions. We may release GHC with some Tier 2 platforms not working."
22:05:53 <adas> thanks for the link
22:06:08 <merijn> adas: In other words, if you wanna make it better, help submit patches ;)
22:06:22 <merijn> adas: Especially documentation on how to make things work on the wiki/in the manual
22:07:08 <carter> merijn: adas  there are a number of folks who do haskell on Arm stuff
22:07:17 <carter> its apparently a lot nicer to use than it used to be :)
22:07:51 <adas> i asked about ARM support only because Im reallying interested in using haskell on the beaglebone
22:07:56 <adas> similar to Rpi
22:08:29 <merijn> adas: The biggest problem with the RPi (not sure how applicable it is to beaglebone) is that the lack of memory makes using GHC to compile on them hard
22:08:38 <merijn> adas: And cross-compilation still has rough edges
22:09:18 <adas> if memory is a concern then what you said might apply to beaglebone as well. Both have 512MB
22:09:40 <adas> newer version of beaglebone has 4 GB :)
22:10:49 <merijn> adas: Anyway, if you try cross-compilation, write up how you did it :)
22:11:44 <adas> not thinking about it. but if i do, I will. I've gotten so much from the community. tis only fair i give some back - )
22:12:17 <agibiansky> Is there a function with a signature such as foldMapM :: (Monad m, Monoid w) => (a -> m w) -> [a] -> w m? I want foldMap which operates in a monad. Looked on Hoogle and Data.Foldable/Traversable, can't seem to find it...
22:13:27 <johnw> there's a concurrent version in async-pool...
22:13:48 <johnw> but I'm not finding one either
22:14:41 <agibiansky> Also, is there a reason that instance (Monad m, Monoid w) => Monoid (m w) would be invalid (break the monoid laws)? mempty = return mempty and a <> b = do { a' <- a; b' <- b; return (a' <> b') }? Then the original foldMap would work.
22:14:48 <johnw> foldMapM f xs = liftM mconcat (mapM f xs)
22:16:50 <merijn> agibiansky: No
22:17:23 <agibiansky> merijn: Do you think it would be a worthwhile addition to Data.Monoid?
22:17:31 <merijn> agibiansky: That's perfectly lawful, I argued for a Monoid instance for IO, but some people complain about there being other valid monoids for Monads
22:18:17 <agibiansky> merijn: Oh, I see... good point. For example there's already a Monoid a => Maybe (Monoid a) instance, so this would overlap
22:18:46 <agibiansky> That's rather disappointing, it feels like a very proper and nice instance
22:19:20 <merijn> agibiansky: Agreed, you could newtype it if it's very convenient for your code
22:19:49 <agibiansky> Yeah, it's just a one-off program, so I can just define foldMapM and be done with it :)
22:19:54 <gfixler> :t (>>=)
22:19:55 <lambdabot> Monad m => m a -> (a -> m b) -> m b
22:20:06 <gfixler> I'm just realizing something...
22:20:10 <gfixler> I think I've had something wrong (new to monads)
22:20:19 <gfixler> the ms in this chain are all the same monad?
22:20:24 <Welkin> yes
22:20:36 <gfixler> I've been thinking that m a and m b meant one could be a Maybe and one could be a list
22:20:50 <gfixler> but it means that the same monad holds one type, and later holds another type
22:20:51 <gfixler> right?
22:20:52 <merijn> gfixler: No, all m's *must* be identical
22:21:01 <gfixler> that's actually a relief
22:21:11 <gfixler> :t map
22:21:12 <lambdabot> (a -> b) -> [a] -> [b]
22:21:16 <Welkin> the same variable represents the same type
22:21:19 <gfixler> so the list is always there
22:21:22 <gfixler> but the contents change
22:21:24 <merijn> :t concatMap
22:21:24 <gfixler> and same for monads
22:21:25 <lambdabot> (a -> [b]) -> [a] -> [b]
22:21:44 <gfixler> list in -> list out
22:21:46 <merijn> gfixler: >>= for list == flip concatMap :)
22:21:51 <merijn> :t flip concatMap
22:21:52 <lambdabot> [a] -> (a -> [b]) -> [b]
22:21:57 <gfixler> IO something in -> IO otherthing out
22:22:04 <merijn> :t (>>=) `asAppliedTo` []
22:22:05 <lambdabot> [a] -> (a -> [b]) -> [b]
22:22:06 * hackagebot snaplet-amqp 1.1.0.0 - Snap framework snaplet for the AMQP library  http://hackage.haskell.org/package/snaplet-amqp-1.1.0.0 (ParnellSpringmeyer)
22:22:13 <gfixler> what's all this then?
22:22:35 <gfixler> merijn: flip concatMap will take me a moment...
22:22:55 <Welkin> "flip" just flips the arguments
22:22:55 <merijn> gfixler: flip just reorders the first two arguments :)
22:22:57 <Welkin> :t flip
22:22:58 <lambdabot> (a -> b -> c) -> b -> a -> c
22:23:00 <gfixler> Welkin: I know flip
22:23:04 <merijn> :t concatMap
22:23:05 <lambdabot> (a -> [b]) -> [a] -> [b]
22:23:07 <gfixler> just not monads well enough to get how it applies here
22:23:07 <merijn> :t flip concatMap
22:23:08 <lambdabot> [a] -> (a -> [b]) -> [b]
22:23:18 <merijn> :t (>>=)
22:23:19 <lambdabot> Monad m => m a -> (a -> m b) -> m b
22:23:22 <gfixler> I know concatMap, too
22:23:26 <gfixler> man, I know a lot ;)
22:23:31 <merijn> compare the last two :)
22:23:40 <Welkin> gfixler: if you think you know a lot, you have a lot to learn
22:23:53 <gfixler> Welkin: I *did* put a ;)
22:24:05 <Welkin> the more you learn the less you realize you know
22:24:12 <gfixler> Welkin: yeah, it kinda sucks
22:24:25 <gfixler> it means if I live long enough, I'll be the biggest idiot ever
22:24:39 <begriffs> Is there a way to encode ad-hoc Aeson output (so not having to define a data type first)? Like encode $ [ ("foo", 1), ("bar", 2) ] ?
22:25:26 <begriffs> I don't want a lot of ceremony, I just want to make some quick output.
22:27:22 <gfixler> cool - gotta get back to work, but thanks for clearing up the m a -> m b thing, folks
22:40:14 <xpika> how do i replace "hot" with "cold" in "the hot day"?
22:40:51 <xpika> is there something in Data.List to help ?
22:45:27 <bergmark> xpika: i thought `replace' was in Data.lList but it seems not..., it's in Data.Text though if you use Text instead
22:46:09 <zRecursive> @hoogle replace
22:46:09 <lambdabot> Data.Text replace :: Text -> Text -> Text -> Text
22:46:10 <lambdabot> Data.Text.Lazy replace :: Text -> Text -> Text -> Text
22:46:10 <lambdabot> Data.Text.Encoding.Error replace :: b -> OnError a b
22:50:01 <Blizzy> question. so for example:
22:50:22 <Blizzy> x . y Haskell will apply y first, then x. right?
22:50:26 <Blizzy> if x and y are functions.
22:50:52 <zRecursive> :t (.)
22:50:53 <lambdabot> (b -> c) -> (a -> b) -> a -> c
22:51:05 <kadoban> So, yep.
22:51:29 <Blizzy> hmm, ok, thank you, zRecursive and kadoban.
22:51:35 <Blizzy> also, thanks, lambdabot. :3
22:51:41 <kadoban> Hehe
22:52:07 * hackagebot binary-streams 0.1.0.0 - data serialization/deserialization io-streams library  http://hackage.haskell.org/package/binary-streams-0.1.0.0 (petterb)
22:52:09 <benzrf> @let l = In [In [], In l]
22:52:10 <lambdabot>  .L.hs:160:19:
22:52:10 <lambdabot>      Ambiguous occurrence ‘l’
22:52:10 <lambdabot>      It could refer to either ‘L.l’, defined at .L.hs:160:1
22:52:10 <lambdabot>                            or ‘Debug.SimpleReflect.l’,
22:52:10 <lambdabot>                               imported from ‘Debug.SimpleReflect’ at .L.hs:11...
22:52:22 <benzrf> @let lre = In [In [], In lre]
22:52:23 <lambdabot>  .L.hs:160:21:
22:52:23 <lambdabot>      Couldn't match type ‘Mu’ with ‘[]’
22:52:23 <lambdabot>      Expected type: [Mu []]
22:52:23 <lambdabot>        Actual type: Mu []
22:52:23 <lambdabot>      In the first argument of ‘In’, namely ‘lre’
22:52:29 <benzrf> ?
22:52:46 <benzrf> @let lre = [In [], In lre]
22:52:47 <lambdabot>  Defined.
22:53:06 <benzrf> @let lre' = [[], lre']
22:53:07 <lambdabot>  .L.hs:161:13:
22:53:07 <lambdabot>      Occurs check: cannot construct the infinite type: t ~ [t]
22:53:07 <lambdabot>      Expected type: [t]
22:53:07 <lambdabot>        Actual type: [[t]]
22:53:07 <lambdabot>      Relevant bindings include lre' :: [[t]] (bound at .L.hs:161:1)
22:53:10 <benzrf> i thought so
22:54:35 <Blizzy> another question. so if it is (x . y) [1..5], Haskell will apply y to each number, then apply x. right?
22:54:46 <merijn> Blizzy: No
22:55:07 <Blizzy> whoops, meant to use 'map' before that.
22:55:13 <merijn> Blizzy: "(x . y) [1..5]" applies y to the *list* and then 'x' to the result of applying 'y' to the list
22:55:18 <merijn> Blizzy: Then yes
22:55:43 <merijn> > map (show . even) [1..5]
22:55:44 <lambdabot>  ["False","True","False","True","False"]
22:56:04 <Blizzy> > (show . even) [1..5]
22:56:05 <lambdabot>  No instance for (GHC.Real.Integral [t0])
22:56:05 <lambdabot>    arising from a use of ‘GHC.Real.even’No instance for (GHC.Enum.Enum t0)
22:56:05 <lambdabot>    arising from the arithmetic sequence ‘1 .. 5’
22:56:05 <lambdabot>  The type variable ‘t0’ is ambiguous
22:56:05 <lambdabot>  Note: there are several potential instances:
22:56:17 <Blizzy> oh ok. so you have to use map for that.
22:56:23 <merijn> Blizzy: That doesn't typecheck, because 'even' expects a number
22:56:40 <kadoban> > show . map even $ [1..5]
22:56:42 <lambdabot>  "[False,True,False,True,False]"
22:56:57 <Blizzy> ugh, Haskell is confusing.
22:57:25 <kadoban> You get used to it pretty quickly. It helps a ton if you look at the types and try to work it out
22:57:29 <merijn> Blizzy: It's not so bad, but it takes getting used to, depending on which languages you've used before :)
22:57:39 <Blizzy> true, lol.
22:58:07 <NemesisD> haskell feels backwards until you start using it a lot and then everything else does
22:58:41 <NemesisD> OOP languages chain methods left to right, haskell functions right to left, but then lenses compose left to right again :P
22:59:11 <pharpend_> haha
22:59:21 <pharpend_> well, lenses, the motivation was imperative-style composition
22:59:29 <pharpend_> correct me if i'm wrong, edwardk
22:59:32 <Blizzy> so, to what kadoban said. first it completes the array, then maps even to it. it then shows the array, which would be False, True, etc.
22:59:57 <pharpend_> @seen edwardk
22:59:57 <lambdabot> EDWARdx
22:59:57 <Blizzy> wouldn't it do the same thing without the $ then?
23:00:30 <pharpend_> Blizzy: no no
23:00:43 <kadoban> Then it would be: show . map even [1..5]          What's the type of map even [1..5] ? What's the type of (.) ?
23:00:46 <pharpend_> because the right argument to (.) has to be a function that takes an argument
23:00:47 <edwardk> lens kinda got forced back into oop style. it used to feel weird to me. now they just do the only thing they could do
23:01:05 <edwardk> its kinda nice in that it unifies the (.) from FP with the (.) from OOP
23:01:07 <pharpend_> :t map even [1..5]
23:01:08 <lambdabot> [Bool]
23:01:16 <pharpend_> :t (show .)
23:01:17 <lambdabot> Show b => (a -> b) -> a -> String
23:01:28 <pharpend_> edwardk: agreed
23:01:44 <pharpend_> edwardk: well, the . from fp is supposedly the compose operator from math, right?
23:01:51 <edwardk> the imperative API on top of lens was something that grew fairly organically. we had a few things in data-lens but nobody really used them
23:01:57 <kadoban> So the $ lets it build up the whole function on the left, then applies the one argument to it. Since: show . map even     is a fine function
23:02:06 <kadoban> :t show . map even
23:02:07 <lambdabot> Integral a => [a] -> String
23:02:12 <pharpend_> yep
23:02:15 <pharpend_> there you go
23:02:25 <pharpend_> > (show . map even) [1..10]
23:02:26 <lambdabot>  "[False,True,False,True,False,True,False,True,False,True]"
23:02:36 <edwardk> pharpend_: sure, its purely a syntactic pun, we use (.) because the center dot isn't available to us in haskell, and then the OOP use of (.) using the same symbol is pure serendipity
23:03:12 <pharpend_> kadoban: ($) can be read as "wrap everything before and after this in parentheses"
23:03:24 <pharpend_> kadoban: there's some fancy stuff going on with operator precedence
23:03:31 <pharpend_> kadoban: but that's the gist of it
23:03:33 <pharpend_> for instance
23:03:38 <pharpend_> @src ($)
23:03:39 <lambdabot> f $ x = f x
23:03:49 <pharpend_> it's really that simple
23:04:22 <kadoban> Blizzy: ^  (he was the one asking about it, I was just helping explain a tad)
23:04:47 <sujeet> hm
23:04:51 <pharpend_> ah yeah, sorry, I didn't read the conversation carefully enough
23:04:54 <Blizzy> show . map even $ [1..5] would pass the array through the map even, then show the array.
23:04:55 <kadoban> No worries
23:05:00 <pharpend_> Blizzy: yes
23:05:04 <sujeet> what's an exmple of $ usage
23:05:32 <pharpend_> sujeet: the haskell people will say "it reverses associativity" which is correct, but if you don't know what that means, it's pointless
23:05:36 <pharpend_> sujeet: um
23:05:41 <pharpend_> oh
23:05:55 <pharpend_> so (show . map even) [1..10] can be rewritten
23:06:01 <pharpend_> > show $ map even [1..10]
23:06:02 <lambdabot>  "[False,True,False,True,False,True,False,True,False,True]"
23:06:05 <pharpend_> which might be easier to read
23:06:16 <ioanna> hi, I'm very new to Haskell and I am trying to understand a program one wrote. The program has almost no comments or documentation of any sort, so I put the documentation myself in the modules, as I understand the code. I want to then use Haddock to make a documentation file, but running "haddock -h Main.hs" gives me the error that certain modules (from this program) cannot be found, I guess because they are in subfolders (in the folde
23:06:35 <ioanna> How do I correctly use haddock? searching on the internet has been very unhelpful... thanks
23:06:39 <pharpend_> ioanna: you will want to use a tool called cabal
23:06:43 <pharpend_> ioanna: which should come with the platform
23:06:48 <sujeet> pharpend_, ah cool
23:06:50 <Blizzy> show $ map even [1..10]. with the $, it maps the array first, then passes it through show.
23:06:51 <Blizzy> right?
23:07:08 <kadoban> Right. The effect is the same really
23:07:17 <Blizzy> if so, what exactly difference between . and $?
23:07:33 <pharpend_> Blizzy: yes. "show $ map even [1..10]" does the same thing as "(show . map even) [1..10]"
23:07:38 <pharpend_> Blizzy: the types
23:07:41 <pharpend_> :t (.)
23:07:42 <lambdabot> (b -> c) -> (a -> b) -> a -> c
23:07:45 <pharpend_> :t ($)
23:07:46 <lambdabot> (a -> b) -> a -> b
23:07:51 <merijn> "f $ x = f (x)" where as "f . g = \x -> f (g x)"
23:08:06 <ioanna> pharpend_ aha, so i must install haddock via cabal you mean?
23:08:10 <pharpend_> ioanna: no no
23:08:12 <merijn> Blizzy: So "f . g" returns a function
23:08:18 <pharpend_> ioanna: well, yes
23:08:23 <merijn> Whereas "f $ x" applies 'f' to 'x'
23:08:29 <pharpend_> ioanna: but, you should use cabal to manage the list of modules
23:08:52 <pharpend_> you would want to create a .cabal file, which cabal can parse and use to build your package, along with the documentation
23:09:00 <ioanna> pharpend_ oh... ok, I'm not sure how I'll do that but I better search first before I ask more ;)
23:09:06 <pharpend_> you can run "cabal init" which will generate one
23:09:18 <pharpend_> I don't know of anyone who would actually write a cabal file by hand
23:09:22 <pharpend_> they are pretty easy to read, though
23:09:32 <pharpend_> vaguely reminiscient of YAML
23:09:47 <Blizzy> (show . map even) [1..10] returns a function that maps an array, then shows it. this is then passed to [1..10]
23:09:54 <Blizzy> *maps even.
23:10:00 <pharpend_> Blizzy: yes
23:10:16 <Blizzy> so basically, . returns a function, $ returns arguments.
23:10:24 <pharpend_> (show . map even) is a function that maps an array then shows it. The argument [1..10] is then passed to this array
23:10:27 <pharpend_> *this function
23:10:28 <kadoban> $ applies a function
23:10:36 <Blizzy> OH.
23:10:43 <Blizzy> .makes the function, $ applies the function.
23:11:05 <kadoban> It's the same as...just using spacing, except the precedence is way lower. So you can use it instead of parenthesis essentially.
23:11:13 <ioanna> pharpend_+ cabal init seems to be doing something, thanks,  I'm really new to (practical) programming in general, so I have no idea what YAML is :)
23:11:18 <ioanna> thanks for the help
23:11:30 <pharpend_> Blizzy: ($) says "run the function, I'm too much of a lazy a**hole to put the parentheses in myself" (.) says "smush the functions to make a new function"
23:11:35 <benzrf> bye
23:11:39 <kadoban> f x    binds really tightly    f $ b    binds really loosely
23:11:48 <pharpend_> ioanna: check out https://github.com/bitemyapp/learnhaskell
23:11:48 <Blizzy> oh ok, that basically explains it, pharpend_.
23:12:05 <Blizzy> thanks everyone. I'll be back more often, lol. It's 2am here, so I'm out.
23:12:08 * hackagebot hspec-test-framework 0.0.0 - Run test-framework tests with Hspec  http://hackage.haskell.org/package/hspec-test-framework-0.0.0 (SimonHengel)
23:12:12 <kadoban> Cya later
23:12:20 <pharpend_> Blizzy: alright, monads - they're just monoids over the category of endofunctors
23:12:28 <Blizzy> oh, btw,thxs, kadoban and pharpend_.
23:12:29 <pharpend_> Blizzy: those are what everyone has trouble with
23:12:34 <kadoban> 'welcome
23:12:37 <Blizzy> thxs again. bye.
23:12:38 <pharpend_> welcome
23:12:41 <ioanna> pharpend_ thanks, I guess I better join the haskell-beginners room i guess! :)
23:12:46 <pharpend_> ioanna: sure
23:12:46 <kadoban> pharpend_: Trying to give him nightmares? XD
23:12:52 <pharpend_> kadoban: yes
23:12:56 * pharpend_ cackles
23:12:59 <Blizzy> lol.
23:12:59 <kadoban> Haha
23:13:00 <Blizzy> :L
23:13:12 <Blizzy> k though I'm out.
23:13:22 * pharpend_ forgets he has respiratory disease and starts caughing wildly
23:13:32 <merijn> pharpend_: Please don't tell beginners that
23:13:45 <merijn> pharpend_: They won't appreciate the "running joke" and it's utterly unhelpful
23:13:54 <pharpend_> merijn: but, but, it's fun to torture the beginners :p. alright
23:14:02 <merijn> In fact, even harmful in that it perpetuates the "haskell is ivory tower nonsense"
23:14:07 <sgronblo> i thought it was fun
23:14:10 <merijn> pharpend_: Then I recommend joining ##c and ##c++
23:14:17 <merijn> They love torturing everyone
23:14:29 <merijn> #haskell was started with the goal of welcoming beginners
23:14:31 <pharpend_> I love that stereotype, because my friends think I'm actually smart because I program in Haskell
23:14:46 <merijn> sgronblo: The joke fades quickly when you see it for the 1500th time
23:14:50 <pharpend_> what are they going to think when they realize that Haskell isn't actually all that hard
23:15:04 <merijn> sgronblo: Especially when it *once again* needlessly intimidates some confused beginner
23:15:04 <pharpend_> merijn: it's only funny when you tell it to beginners
23:15:10 <sgronblo> in a way it's like if you get scared of haskell when you hear that maybe you aint tough enough to leanr about monads! :)
23:15:40 <merijn> sgronblo: Haskell shouldn't be an elite club, it should be a club that welcomes anyone willing to learn
23:16:17 <sgronblo> i totally agree. i am not even part of the haskell elite.
23:16:17 <merijn> pharpend_: "it's only funny if you tell it to beginners" and "it's not funny to tell beginners", logical conclusion it's never funny :)
23:16:19 <pharpend_> merijn: I agree, but it's fun to joke around
23:16:43 <pharpend_> Oh I don't agree that it's not funny to tell beginners, as long as the beginner understands that it's a joke
23:16:48 <merijn> pharpend_: You're welcome to joke around with people who are not asking beginner questions and obviously confused
23:17:08 * hackagebot rethinkdb-client-driver 0.0.6 - Client driver for RethinkDB  http://hackage.haskell.org/package/rethinkdb-client-driver-0.0.6 (wereHamster)
23:17:09 <pharpend_> merijn: well if he was asking about monads, I wouldn't have said that, obviously
23:17:23 <merijn> pharpend_: And why was it helpful now?
23:17:47 <pharpend_> merijn: I wasn't claiming it was helpful, I was claiming it was funny, and not harmful. The newbie seemed to think it was funny
23:19:15 <merijn> Anyway, I made my point. I would just like #haskell to remain as helpful (or become more so) as it was when I started, rather than stranding in a sea of in-jokes and elitism :)
23:19:24 <pharpend_> definitely
23:20:25 <pharpend_> jesus i've been using haskell for two years
23:20:31 <pharpend_> i should find a new language
23:20:37 <merijn> Time flies when you're having fun ;)
23:20:39 <pharpend_> I've never stayed with one language for this long
23:20:42 <merijn> pharpend_: Idris ;)
23:20:47 <pharpend_> I've looked at Idris
23:20:49 <merijn> Or Coq, if you like videogame programming
23:20:55 <pharpend_> I don't have time to learn another language right now
23:21:00 <pharpend_> but Idris is on the short list
23:21:06 <pharpend_> behind ocaml and erlang
23:21:18 <merijn> ocaml is not very interesting if you know haskell
23:21:21 <pharpend_> yeah
23:21:22 <MP2E> Coq is good for video game programming? What makes it more suitable versus Agda and Idris?
23:21:35 <MP2E> I don't know too much about any of them, just curious
23:21:39 <merijn> MP2E: By "video game programming" I mean "programming is a game"
23:21:40 <Hijiri> I thought it was a joke
23:21:43 <Hijiri> oh
23:21:44 <MP2E> ah
23:21:44 <pharpend_> yeah
23:21:56 <merijn> MP2E: i.e. "I'm just randomly trying things and when it magically works I shout 'whoo!'"
23:22:00 <MP2E> haha
23:22:03 <pharpend_> MP2E: Coq and Agda aren't turing complete, so I don't think you'd be able to make a video game with it.
23:22:08 <pharpend_> *either one of them
23:22:31 <MP2E> i'm learning Agda right now actually, it's pretty neat but i do sometimes feel like i have no idea what I'm doing
23:22:41 <MP2E> when learned about indexed sets I felt that way at first, for instance :P
23:22:45 <MP2E> learning*
23:23:23 <kadoban> pharpend_: I don't think it's necessary to be turing complete to write a video game.
23:23:35 * pharpend_ sighs
23:27:09 * hackagebot jobqueue 0.1.4 - A job queue library  http://hackage.haskell.org/package/jobqueue-0.1.4 (ikehara)
23:29:55 <Arahael> kadoban: especially a *modern* game.
23:30:06 <kadoban> Heh
23:34:01 <pharpend_> I can't wait until modern games become analogous to modern art
23:36:56 <srenatus> aren't we there yet?
23:37:07 <pharpend_> I don't game, so idk
23:38:06 <srenatus> neither do I, but https://en.wikipedia.org/wiki/Art_game
23:40:06 <bergmark> that page lists two really cool ones, Dear Esther and Okami
23:42:05 <calvinx> I am running into a cabal install error with regex-tdfa — http://lpaste.net/114080 — any idea why?
23:42:26 <merijn> calvinx: Rerun with -v3
23:42:33 <pharpend_> exitfailure-9
23:42:42 <pharpend_> can't say I've seen that one before
23:45:32 <calvinx> verbose mode gives me this - http://lpaste.net/114081
23:46:04 <mauke> anything before that?
23:48:25 <calvinx> just a chain of CPSZ
23:48:53 <calvinx> I found some one else with exitfailure -9 compiling pandoc - http://stackoverflow.com/questions/19045380/failed-to-compile-pandoc-with-cabal
23:48:57 <calvinx> out of memory?
23:49:26 <calvinx> I have got 1 GB free memory on this machine I am compiling on.
23:50:35 <mauke> that's 9, not -9
23:50:42 <mauke> and it's from ghc, not gcc
23:51:01 <calvinx> right
23:51:35 <mauke> ah, no
23:51:41 <mauke> your status is also from ghc
23:52:31 <mauke> I wonder why gcc is involved at all
23:52:59 <Hijiri> rip
23:57:10 * hackagebot rethinkdb-client-driver 0.0.7 - Client driver for RethinkDB  http://hackage.haskell.org/package/rethinkdb-client-driver-0.0.7 (wereHamster)
23:58:29 <merijn> mauke: A bunch of the regex libraries use the FFI
23:59:17 <mauke> merijn: I thought ghc handled FFI itself
23:59:51 <merijn> mauke: Sure, but if they write C wrappers
23:59:59 <merijn> Although this one doesn't appear to use those
