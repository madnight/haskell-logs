00:04:29 <bmuk> Hello everyone, I don't know if this is the best place to ask (since it isn't necessarily limited to haskell), but I am looking for programming videos that are not tutorials. I would like to watch someone work through a problem and explain what they are doing throughout, but focus much more on the design rather than the syntax of the language. Jekor has several videos like this - one that sticks out in my mind is his series implementing
00:04:29 <bmuk> djb's redo in haskell. I'm sure he can't be the only one making videos like this, I think the reason I am unable to find them is because I don't really know what to call this type of video so I can google it. "Live coding" seems right but doesn't return much
00:10:02 * hackagebot FirstOrderTheory 0.1.0.6 - Grammar and typeclass for first order theories  http://hackage.haskell.org/package/FirstOrderTheory-0.1.0.6 (dillonhuff)
00:10:02 * hackagebot DifferenceLogic 0.1.0.4 - A theory solver for conjunctions of literals in difference logic  http://hackage.haskell.org/package/DifferenceLogic-0.1.0.4 (dillonhuff)
00:11:12 <jack_rabbit> xtAx/xtx
00:13:17 <bmuk> jack_rabbit: what is xtAx/xtx?
00:16:04 <jack_rabbit> bmuk, sorry...
00:16:13 <jack_rabbit> bmuk, accidental raleigh's theorem.
00:16:42 <jack_rabbit> Rayleigh*
00:17:08 <bmuk> jack_rabbit: No worries, just thought it may have been a cryptic answer to my question lol
00:20:28 <jack_rabbit> bmuk, no, sorry. :) What was your question?
00:21:01 <jack_rabbit> Ah, I see.
00:21:12 <jack_rabbit> bmuk, what are you looking for? Like data structures?
00:21:47 <bmuk> data structures, algorithms, but mainly structuring programs.
00:22:07 <jack_rabbit> bmuk, yeah, I wouldn't know what to call that either. :)
00:22:38 <jack_rabbit> bmuk, I think you'll have more success just reading articles and reading through code. Unfortunately, I have nothing for you in the way of videos.
00:22:40 <bmuk> I grok data structures and algorithms, but I would like some guidance as far as how to structure the whole program is concerned
00:23:17 <jack_rabbit> bmuk, The structure of a program really depends on the language you're implementing it in. Not necessarily, but practically.
00:23:20 <bmuk> I figured as much. Reading through code definitely helps a lot. Videos are just nice for more passive learning
00:23:57 <jack_rabbit> Different languages give you different tools, so it's only really practical to structure a program in a handful of ways given a language, often times.
00:24:13 <bmuk> jack_rabbit: I'm feeling that pretty keenly now - I have been living and breathing haskell for about half a year and I have to make a roguelike in python for a class project.
00:24:51 <jack_rabbit> bmuk, The best suggestion I can give you is to try to build something in a bunch of different languages, and see how it comes out.
00:24:57 * hackagebot accelerate-utility 0.1 - Utility functions for the Accelerate framework  http://hackage.haskell.org/package/accelerate-utility-0.1 (HenningThielemann)
00:25:02 <merijn> bmuk: Python is really hard for me after a lot of haskell :p
00:25:11 <bmuk> Deciding whether to use classes or functions is probably the hardest part for me :p
00:25:17 <jack_rabbit> merijn, that's because python is actually terrible. :)
00:25:42 <jack_rabbit> bmuk, yeah, it really depends on the language facilities, for me.
00:26:13 <jack_rabbit> bmuk, Again, I can only suggest giving it a try, and re-doing it if you find you've worked yourself into a corner, or if you find you think it would've been better solved another way.
00:26:32 <jack_rabbit> Eventually you'll learn the patterns.
00:26:54 <merijn> bmuk: Screw class projects, hack on GHC instead! :p
00:28:08 <bmuk> Someone I was helping had a bug in their homework like this "if string[0].isupper: print("is upper")" and it would always print... because he didn't have parentheses indicating calling the function, and a function object is truthy in python... what on earth.
00:28:32 <bmuk> merijn: good idea :p
00:28:56 <merijn> bmuk: Or just help audit other people's code!
00:30:06 <jack_rabbit> bmuk, yeah, that's just part of python's semantics.
00:30:23 <jack_rabbit> bmuk, ruby has another interpretation, but it's not without problems...
00:30:35 <jack_rabbit> bmuk, that is, how do you pass a function in ruby?
00:30:55 <bmuk> jack_rabbit: not sure, I don't know ruby
00:31:50 <jack_rabbit> bmuk, you can call a method in ruby without parens.
00:32:05 <jack_rabbit> Makes it hard to pass a method rather than passing the result of calling the method.
00:32:48 <jack_rabbit> Have to deal with procs or some such nonsense.
00:33:21 <jack_rabbit> I'm really waiting for perl6. Between python, ruby, perl5, and perl6, perl6 is the only one that gets this right.
00:33:39 <bmuk> I learned to program using python, but I honestly have no idea how so much software is built and runs the world using languages without strong, static typing
00:34:14 <merijn> bmuk: Good, that means you've truly joined the haskell side ;)
00:34:34 <tdammers> bmuk: the proponents call it "pragmatic". I call it "anti-intellectualist", or just plain out sloppy.
00:34:40 <jack_rabbit> I hate python so much.
00:34:52 <jack_rabbit> It's so easy to code in. That's why it's popular.
00:34:58 <tdammers> bmuk: this may shock you, but this kind of sloppiness / minimum viable quality approach is not limited to programming
00:35:00 <jack_rabbit> But it's a terrible language.
00:35:10 <tdammers> jack_rabbit: it's not easy to code in at all
00:35:22 <jack_rabbit> tdammers, it's easy for newbies.
00:35:22 <tdammers> jack_rabbit: not at any nontrivial scale, at least
00:35:28 <jack_rabbit> tdammers, right.
00:35:28 <bmuk> tdammers: do you mean life in general?
00:35:31 <merijn> It *seems* easy to code in :p
00:35:33 <tdammers> python optimizes for small projects
00:35:37 <jack_rabbit> yes.
00:35:46 <tdammers> a 10-line python script is easier than a Haskell program that does roughly the same
00:35:47 <jack_rabbit> That's what makes it appealing.
00:35:56 <tdammers> at 100 lines, they're roughly on par
00:36:05 <jack_rabbit> As much as I hate python, I can complete a small project in it faster than just about any other language.
00:36:05 <tdammers> at 1000 lines, Haskell starts showing its benefits
00:36:05 <merijn> I disagree, I use haskell for my 10 line shellscripts too :p
00:36:33 <tdammers> and at 10,000 lines, Haskell starts to shine, and your Python project has turned into nightmare material
00:36:40 <bmuk> merijn: now you can even use shell-conduit
00:36:42 <bmuk> :p
00:36:51 <tdammers> merijn: you're biased
00:37:00 <merijn> tdammers: Maybe :p
00:37:38 <tdammers> for me, the biggest benefit of strong static typing is that you don't rely on conventions
00:37:52 <tdammers> because conventions only work when you remember them
00:38:02 <merijn> Or the ability to jump into code you don't know and have some lifelines to figure out what's going on
00:38:07 <tdammers> static checks you don't need to remember - violate them, and the compiler reminds you
00:38:11 <tdammers> that, too
00:38:29 <bmuk> tdammers: on some level it now just bothers me that I can literally pass anything into a function expecting a list and it will be a run time error
00:38:50 <jack_rabbit> It's really shitty when a program can run for minutes or hours before running into an error that static-typing would've caught...
00:38:58 <tdammers> yeah
00:39:05 <jack_rabbit> That's how python screws you.
00:39:11 <tdammers> also, manually tracing function call chains
00:39:18 <wei2912> jack_rabbit: heh
00:39:24 <bmuk> there could be hundreds of little bugs like that which never see the light of day because they just haven't happened to be executed
00:39:37 <tdammers> "why is this function being called, and from where?"
00:39:39 <wei2912> python isn't particularly good for large projects
00:39:45 <merijn> bmuk: Now imagine people wanting to write complex software in javascript
00:39:49 <wei2912> oh god
00:39:58 <tdammers> merijn: javascript does a better job at these things than Python
00:39:58 * hackagebot accelerate-arithmetic 0.0.1 - Linear algebra and interpolation using the Accelerate framework  http://hackage.haskell.org/package/accelerate-arithmetic-0.0.1 (HenningThielemann)
00:40:12 <jack_rabbit> tdammers, indeed.
00:40:23 <tdammers> merijn: javascript has real closures, real local variables (albeit function-scoped rather than block-scoped)
00:40:31 <jack_rabbit> python is probably the worst at type-checking of any language I've used.
00:40:36 <merijn> tdammers: python has real closures
00:41:00 <tdammers> merijn: in my experience, using python closures is *way* messier than javascript closures
00:41:04 <bmuk> merijn: I think of javascript like the JVM
00:41:09 <jack_rabbit> tdammers, I mentioned python, ruby, perl5, and perl6. Of those perl6 and javascript are the only ones that do closures right.
00:41:10 <r444> tdammers: python has closures and it's strongly typed, js is weakly typed
00:41:22 <jack_rabbit> tdammers, python doesn't really have closures.
00:41:25 <tdammers> r444: "strongly typed" is not really a thing anyway
00:41:26 <jack_rabbit> not *really*
00:41:43 <merijn> bmuk: Some of my colleagues are doing some really cool stuff on the JVM :)
00:41:43 <tdammers> jack_rabbit: python can close over variables. It's just a bit more fucked up than in JS
00:41:46 <wei2912> guess what "5" + "8" does in JS
00:41:48 <r444> tdammers: it depends on standard libraries
00:41:49 <tdammers> jack_rabbit: the rules are less intuitive
00:42:04 <r444> ruby kinda messes strong typing with its library, python isn't
00:42:11 <merijn> bmuk: Write a simple, naive AST rewriting interpreter -> get Google V8 levels of performance :)
00:42:15 <bmuk> merijn: I mean that they are the assembly to which better languages compile :)
00:42:33 <merijn> The only downside is that you have to write your interpreter in java :\
00:42:39 <tdammers> r444: what exactly is "strong typing" according to you, anyway?
00:42:45 <bmuk> merijn: i.e Clojure and Scala for JVM, Fay and Purescript for javascript
00:42:57 <jack_rabbit> tdammers, yes, so I guess it does have true closures, they're just stupidly constructed syntactically.
00:43:18 <tdammers> jack_rabbit: the syntax isn't broken. The semantics are.
00:43:27 <r444> tdammers: Oh, not again.
00:43:27 <jack_rabbit> tdammers, I'd argue the opposite.
00:43:44 <jack_rabbit> tdammers, The semantics exist, the syntax is just stupid.
00:43:49 <tdammers> jack_rabbit: the syntax is pretty much exactly the same as in JS. Create a variable, declare a function that uses it
00:44:00 <tdammers> jack_rabbit: lambda syntax is stupid, but that's not what I'm talking about.
00:44:14 <tdammers> jack_rabbit: I'm talking about closures. Closing over a variable.
00:44:30 <jack_rabbit> I'm missing in-line closures.
00:44:34 <jack_rabbit> I don't want a def.
00:44:48 <tdammers> jack_rabbit: lambda expressions can close, too.
00:44:58 <jack_rabbit> tdammers, yeah, but lambdas are horrible.
00:44:58 * hackagebot accelerate-cublas 0.0 - Basic Linear Algebra using native CUBLAS library  http://hackage.haskell.org/package/accelerate-cublas-0.0 (HenningThielemann)
00:45:05 <tdammers> jack_rabbit: I agree on that one
00:45:10 <jack_rabbit> Ruby has procs, but they're super ugly.
00:45:20 <jack_rabbit> and you have to do myproc.call
00:45:26 <jack_rabbit> which is incredibly stupid.
00:45:31 <tdammers> in a way, the only thing that bothers me about JS anonymous functions is the length of the 'function' keyword
00:45:49 <jack_rabbit> tdammers, yeah, I don't even mind that.
00:45:53 <tdammers> that, and that there are two ways of declaring a named function that are subtly different
00:46:03 <r444> jack_rabbit: you can call procs and lambdas in ruby with square brackets, which is even worse
00:46:04 <jack_rabbit> tdammers, you should take a look at perl6 closures. They're beautiful.
00:46:20 <tdammers> nothing in perl is beautiful
00:46:22 <jack_rabbit> r444, not familiar with that syntax, but it sounds horrible.
00:46:25 <tdammers> not at the syntax level, anyway
00:46:31 <jack_rabbit> tdammers, nothing in perl*5* is beautiful.
00:46:36 <tdammers> heh
00:46:37 <jack_rabbit> tdammers, perl6 is much different.
00:47:10 <jack_rabbit> Seriously. I'd never do anything but the odd one-liner in perl5. Perl6 actually looks awesome.
00:50:07 <merijn> Doesn't perl6 look like vaporware? :p
00:51:58 <tdammers> maybe they'll pull a PHP
00:52:02 <tdammers> skip version 6
00:52:18 <tdammers> all the cool kids do it
00:52:23 <tdammers> PHP6... Windows 9...
00:52:33 <bmuk> I was about to say that lol
00:52:56 <merijn> To be fair, MS probably has a better reason than PHP :p
00:53:06 <tdammers> "better"... pff....
00:53:14 <tdammers> MS has a *technical* reason
00:53:20 <tdammers> PHP has a *social* reason
00:54:20 <jack_rabbit> tdammers, actually, perl6 is almost completely functional.
00:54:32 <jack_rabbit> tdammers, it's only missing a few things now. It's taken them long enough...
00:54:49 <jack_rabbit> But it's been a better payoff already than waiting for Diablo III.
00:55:13 * merijn waits for GHC releases instead :p
00:55:15 <jack_rabbit> I've been writing perl6 for a few months now. Only found a few things that I miss.
00:55:36 <jack_rabbit> No Async IO, and no concurrency. Huge barriers to large programs, but for small scripts, it's fine.
00:56:39 <tdammers> well, honestly I think perl has similar problems wrt scaling as all the other dynamic languages do
00:56:46 <tdammers> maybe not as bad as Python, but still
00:57:01 <jack_rabbit> Sure. I'm not suggesting you write distributed systems in perl.
00:57:22 <jack_rabbit> I'm simply suggesting that if you hate python but find it useful, you give perl6 a look.
00:57:31 <merijn> I wish erlang had a nice type system, then I could write distributed systems in that :p
00:57:37 <tdammers> merijn: lol
00:57:44 <jack_rabbit> merijn, I've tried that... the horror.
00:57:52 <jack_rabbit> actors everywhere...
00:58:22 <merijn> tdammers: I like Joe Armstrong's honesty
00:58:42 <merijn> "Why is erlang dynamically typed?" 'Because I didn't know about type systems when I started implementing it'
00:59:04 <jack_rabbit> Worked well enough for the telephone companies.
00:59:13 <bmuk> other than the fact that haskell has to be compiled, what benefits does python have over it (or when would it be more appropriate to use python)?
00:59:29 <jack_rabbit> What would be really nice is an erlang-style actor model in haskell.
01:00:05 <bmuk> jack_rabbit: I'm pretty sure Scala has that
01:00:06 <jack_rabbit> bmuk, it really comes down to preference. Python is probably better for several-line scripts.
01:00:16 <jack_rabbit> bmuk, yeah, but Scala sucks...
01:01:01 <bmuk> jack_rabbit: I realize it's a preference, I was just thinking there might be room for a lightweight functional scripting language to fill the void.
01:01:07 <tdammers> in my experience, the decision to use python is usually a compromise between "let's use a programming language that sucks less than PHP" and "let's use a programming language for which a job opening will yield an average of more than 0.8 applications"
01:01:14 <lefant> jack_rabbit: an erlang-style actor library for haskell actually exist: http://haskell-distributed.github.io/ ;)
01:01:56 <tdammers> bmuk: javascript is lightweight and somewhat *cough* functional
01:02:05 <jack_rabbit> lefant, I began building one myself. :) https://github.com/knusbaum/Distributed-Haskell
01:02:21 <jack_rabbit> tdammers, javascript is functional in many senses of the term.
01:02:44 <tdammers> jack_rabbit: yes; it's functional in the sense that it provides the usual building blocks - first-class functions, closures, etc.
01:02:47 <jack_rabbit> It would really be helpful if we could, as a species, arrive at some concrete definition of a functional language.
01:03:16 <tdammers> jack_rabbit: but it relies heavily on mutable state, which clashes with a proper FP style
01:03:29 <jack_rabbit> Although, I'm afraid that if the haskellers had their way, the set of functional languages might contain only the Haskell language.
01:03:31 <bmuk> would you consider scheme or clojure functional?
01:03:56 <tdammers> "functional language", to me, means "a language that supports a functional programming style"
01:04:02 <jack_rabbit> bmuk, I'd consider clojure functional, although its often used with Java BS that takes away from that.
01:04:11 <tdammers> or, depending on context, "a language that was designed to support a functional programming style"
01:04:32 <jack_rabbit> bmuk, scheme I've never tried, but I know CL, which you *can* program functionally in.
01:04:51 <tdammers> scheme is pretty close, actually
01:04:56 <tdammers> closer than CL IMO
01:05:08 <merijn> bah
01:05:11 <tdammers> lisp-1 vs. lisp-2, for starters
01:05:30 <merijn> 30 minutes to run validate and it complains about tests I broke way in the end >.>
01:06:36 <bmuk> I really want to like lisp, but the lack of typing makes me hesitant.
01:07:05 <bmuk> I think if I could write haskell in s-expressions I would be set
01:07:50 <Kneiva> you can use types in clojure if you want to
01:08:46 <bmuk> Kneiva: I will have to look into that, I have only briefly dabbled with clojure
01:09:20 <Kneiva> bmuk: "Clojure now has a project (core.typed) that allows you to annotate your code with type checks, and the compiler issues warnings on those checks. even if you don't use core.typed, you can use pre and post assertions on your functions which will give you run-time data-type checking" http://www.smashcompany.com/technology/object-oriented-programming-is-an-expensive-disaster-which-must-end#Static type checking
01:10:01 <Kneiva> oops, the stuff after # is just my own "bookmark"
01:10:59 <tdammers> bmuk: you can at least write lisp with non-s-expression syntax already... it's called "javascript" :x
01:11:43 <bmuk> tdammers: :p
01:11:57 <jack_rabbit> bmuk, I know. I so much love lisp syntax. If only it had strong typing it'd be the perfect language.
01:12:08 <tdammers> hmm
01:12:27 <jack_rabbit> bmuk, CL was what got me into functional programming. I only picked up LYAH after I read PCL.
01:12:27 <tdammers> jack_rabbit: you mean *static* typing, right?
01:12:33 <kadoban> I never really miss strong typing in languages that don't have it. I sure love it in haskell, but like I can deal with python and it doesn't drive me crazy.
01:12:37 <jack_rabbit> tdammers, yes, excuse me.
01:13:14 <tdammers> the trick with Python is to dumb things down
01:13:27 <tdammers> write code as if you were stupid
01:13:53 <kadoban> That sounds like a weird intuition for python, heh...
01:13:59 <bmuk> kadoban: I think I miss type signatures most of all. It's so easy to know what a library does just by reading the type signatures
01:14:16 <kadoban> bmuk: Yeah, that part is a huge loss.
01:14:59 <kadoban> I think probably that if I'd learned haskell earlier I'd probably be pretty annoyed by most other languages in a lot of ways, most of them having to do with the type system.
01:15:09 <kadoban> But since I learned it so late, maybe I just don't mind going without as much.
01:15:11 <tdammers> well, Python lacks the abstractive power to do nontrivial FP
01:15:31 <tdammers> so going crazy on higher-order functions and such tends to end not-so-well
01:15:33 <kadoban> Yeah, you really can't do much in functional style in python...it's pretty hostile to it.
01:15:46 <tdammers> same for most other abstraction strategies, really
01:16:11 <tdammers> except for duck typing, but I wouldn't call that "abstraction" really
01:16:29 <kadoban> OO is fine in python, you can easily use that for abstraction
01:17:15 <kadoban> You don't have the "strong" encapsulation you get in some other languages...but if you're coding with jerks who break through your interfaces, you're screwed anyway.
01:17:19 <bmuk> tdammers: so I shouldn't write a monad library in python :p
01:18:28 <tdammers> python OO is quirky and feels bolted-on
01:19:07 <kadoban> Really? I like it. It's like C++'s, except it's not a pain in the ass to deal with.
01:19:19 <tdammers> C++'s OOP is kinda bolted-on, too
01:19:39 <tdammers> but at least C++ has some compile-time type checks
01:19:55 <kadoban> Well, unless you go to like...smalltalk or something, I'm not sure what OO you'd actually like then :)
01:20:09 <tdammers> fair point... I kind of dislike OOP in general
01:20:22 <tdammers> smalltalk sounds somewhat reasonable, but I've never actually used it
01:20:44 <kadoban> Yeah I've never used it for anything serious. It does sound like a pretty neat language though
01:21:06 <free_beard> bmuk: i might be late to the party, but i found https://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program#Structure_of_a_simple_project useful for getting started with haskell projects
01:21:23 <tdammers> JS's "OOP" isn't too bad either... remove the part where it tries to do inheritance, and you have a useful abstraction tool
01:21:35 <tdammers> but then, if you do that, might as well use Haskell records with first-class methods
01:21:48 <tdammers> idk, lens the shit out of it and all that
01:21:50 <kadoban> JS's OO is pretty similar to python's though, isn't it?
01:21:59 <tdammers> no
01:22:06 <tdammers> JS doesn't have classes
01:22:11 <tdammers> just objects
01:22:28 <tdammers> well, there's a similarity in how it implements methods as properties that happen to be functions
01:22:30 <Maxdamantus> I think JS's OO is reasonable as long as you don't try to use anything specifically OO-designed.
01:22:35 <tdammers> yep
01:22:54 <bmuk> free_beard: I meant structure as in which classes/functions should I make for a particular problem, but thank you for that link - it is a useful bookmark
01:23:12 <tdammers> if you ignore the protoype stuff, it's really just dictionaries where some properties happen to be functions, and some sugar to provide a magic `this` variable
01:23:31 <Maxdamantus> 'this' is one of those things you shouldn't use.
01:23:36 <kadoban> tdammers: That sounds a lot like python's to me, except no magic 'this', heh.
01:23:44 <Maxdamantus> Python handles that properly, JS doesn't.
01:23:44 <tdammers> 'this' is fine, if you know how it works
01:24:14 <tdammers> it just doesn't behave anything like 'this' in any other language that I know of
01:24:22 <kadoban> I don't really know javascript well though, it's one of those languages that I never really formally learned, I just code in it and it happens to work okay.
01:24:33 <tdammers> and Python doesn't handle it properly, it doesn't handle it at all
01:25:04 <Maxdamantus> the Python/Go way.
01:25:37 <tdammers> but really, they both do mostly the same thing, except Python passes `self` explicitly (on the callee side; the calling is still implicit)
01:25:50 <Maxdamantus> where the method takes the target as a normal binding, and accessing the method produces a function bound to that target.
01:26:18 <tdammers> does it?
01:26:20 <Maxdamantus> rather than the target being specified by a conceptual ternary function call.
01:26:38 <tdammers> ahem
01:26:48 <Maxdamantus> Yes. In Python/Go you can write: tmp = foo.bar; tmp(baz)
01:27:15 <tdammers> isn't that even more broken than JS?
01:27:27 <Maxdamantus> to do the same thing as: foo.bar(baz) (just without creating the 'tmp' variable)
01:27:37 <Maxdamantus> no, it's more broken in JS.
01:27:55 <tdammers> in JS, it's just a property that happens to be a function
01:28:02 <Maxdamantus> in JS it just accesses the function, which doesn't necessarily know anything about 'foo'
01:28:04 <tdammers> no magic whatsoever is applied to the arguments
01:28:19 <Maxdamantus> the magic happens in the call syntax,
01:28:22 <tdammers> yes
01:28:30 <tdammers> but it leaves the arguments alone
01:28:53 <tdammers> the function is just the function; if you ignore `this`, absolutely no magic happens
01:29:11 <tdammers> if you pre-bind it, `this` is always going to point to the same thing, which is also totally not magical
01:29:12 <nshepperd> in python, <object>.method = functools.partial(<class>.method, <object>)
01:29:27 <tdammers> ^ yes
01:29:41 <kadoban> Which is a bit of magic, but it's pretty logical magic really.
01:29:46 <nshepperd> there's actually no magic happening when you call something in python
01:29:54 <tdammers> and JS does the same, except on call instead of on lookup, and not by messing with the argument list, but by setting a special-purpose "variable"
01:29:57 <nshepperd> <object>.method is just a function
01:30:32 <tdammers> nshepperd: but it behaves differntly than <object>.field
01:30:58 <tdammers> iow, the . operator does different things for fields and for methods
01:31:06 <nshepperd> tdammers: no, they are both just values set at object creation time
01:31:16 <nshepperd> there is no difference
01:31:23 <tdammers> huh
01:31:48 <nshepperd> getattr(<object>, 'method') works just as well
01:32:01 <nshepperd> for example
01:32:28 <tdammers> right
01:32:47 <Maxdamantus> tdammers: in JS, it's the call operator that decides the 'this' value, based on the function expression.
01:32:55 <tdammers> yes, it is
01:33:21 <Maxdamantus> it's weird that it behaves differently based on that expression.
01:33:25 <tdammers> which means getting and setting fields is totally value-agnostic
01:33:33 <tdammers> it's a tradeoff
01:33:59 <Maxdamantus> it means meh encapsulation
01:34:09 <tdammers> uhm, no?
01:34:17 <tdammers> how does that violate encapsulation?
01:34:58 <Maxdamantus> this.bar = that.bar
01:34:58 <tdammers> object fields are public in JS
01:35:08 <tdammers> there's no encapsulation on those anyway
01:35:16 <tdammers> if you want "private fields", use closures
01:35:24 <Maxdamantus> and this.bar() behaves differently to that.bar()
01:35:40 <tdammers> yes, sure
01:36:06 <tdammers> but 1) this is often desirable (polymorphism etc.), and 2) you can easily change that by explicitly binding methods to whatever object you like
01:36:13 <Maxdamantus> how does that.bar behave when given an object like this, instead of that?
01:36:42 <tdammers> the baffling usually occurs when you do something like this:
01:36:50 <tdammers> var tmp = foo.bar; tmp();
01:37:08 <Maxdamantus> which is very similar to my example
01:37:12 <tdammers> now `this` inside `tmp` points to the global scope instead of `foo`
01:37:23 <tdammers> no
01:37:43 <tdammers> your example shows two objects, one of them happens to be bound to `this`, and they both have a method `bar`
01:37:53 <Maxdamantus> assuming the tmp function is defined outside of strict mode.
01:37:59 <tdammers> but you call both on their owning objects, so the binding works as expected
01:38:04 <tdammers> yes
01:38:05 <tdammers> ofc
01:38:24 <Maxdamantus> this.tmp = bar; this.tmp();
01:38:30 <tdammers> yes
01:38:31 <Maxdamantus> er
01:38:36 <tdammers> but this doesn't violate encapsulation
01:38:36 <Maxdamantus> this.tmp = foo.bar; this.tmp();
01:38:43 <tdammers> because, again, object fields are public
01:39:23 <tdammers> anyway, it's not very intuitive for JS to behave that way
01:39:28 <tdammers> but there's hardly any magic
01:39:43 <tdammers> understand that `this` gets bound on method call, and that's about it
01:40:08 <tdammers> methods don't know which object they belong to until you bind explicitly, that's what it boils down to
01:44:45 <Maxdamantus> re the encapsulation thing: unless you use fairly explicitly reflective features like Object.defineProperty, you can't tell for example, that some function reads properties `foo` and `bar` off the `this` object.
01:45:13 <Maxdamantus> or rather, that it does is irrelevant to a user.
01:46:26 <Maxdamantus> as a user, you're specifying the `this` object of the method.
01:48:07 <nshepperd> I like the way python does it, because you can do things like connectSignalHandler("mouse", object.handleMouse)
01:48:31 <tdammers> nshepperd: you can do the same in JS. Just need to bind explicitly.
01:48:33 <Maxdamantus> it's also the way Go does it.
01:48:38 <nshepperd> connectSignalHandler doesn't need to know anything about methods, because they are just regular functions
01:49:04 <tdammers> connectSignalHandler("mouse", object.handleMouse.bind(object))
01:49:11 <tdammers> bit more boilerplate though
01:49:35 <Maxdamantus> because it's up to the user to specify the `this` object.
01:50:01 * hackagebot hindent 3.9.1 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-3.9.1 (ChrisDone)
01:50:40 <tdammers> what I like about the JS way, inconvenient as it is when you try to program in a truly OO style, is that there is absolutely no difference between methods and functions
01:51:17 <nshepperd> that doesn't sound right
01:51:26 <trap_exit> yeah
01:51:29 <tdammers> as I said, I don't particularly like OOP
01:51:36 <nshepperd> the python way has no difference between methods and functions
01:51:36 <trap_exit> why am I hearing the words 'js' in #haskell, without mention of ghcjs, haste, or fay ?
01:51:54 <Maxdamantus> There is a difference. The difference is apparent in the function call syntax.
01:52:05 <Maxdamantus> in Python the difference is apparent in the class.
01:52:16 <tdammers> Maxdamantus: write a function. Assign it as a property field. Call it through the object. No surprises.
01:52:28 <tdammers> s/property field/object field/
01:53:06 <nshepperd> so what kind of value is <object>.method in JS?
01:53:19 <tdammers> I'd argue that JS doesn't even *have* methods
01:53:33 <tdammers> <object>.method is a function
01:53:59 <nshepperd> or do ordinary functions get access to a context-dependent 'this' object as well?
01:54:05 <tdammers> yes, they do
01:54:06 <Maxdamantus> Something I wrote earlier: If a function call is of the form `a.b()`, `this` will be the object you accessed the "b" property from. Otherwise, if it's of the form `a()`, `this` will be `undefined`, which is turned into the global object if the function isn't in strict mode.
01:54:14 <Maxdamantus> That's the complete description of what happens in JS.
01:54:15 <tdammers> methods *are* ordinary functions
01:54:21 <Maxdamantus> It's purely to do with the syntax of the call.
01:54:26 <tdammers> yes
01:54:38 <tdammers> if you call it as a method, then there will be a `this` object
01:54:52 <tdammers> the only exception is explicit binding
01:55:42 <tdammers> object.foo.bind(object) is pretty much the same as function() { var a = arguments; return object.foo(a); } though
01:55:50 <Maxdamantus> Yes. That could technically be described as an exception.
01:56:01 <tdammers> so it's not even an exception, really
01:56:05 <Maxdamantus> but you'd usually just imagine .bind to create a new function that ignores `this`
01:56:16 <Maxdamantus> (though that's not quite the case)
01:56:17 <tdammers> well, yeah, what I described above
01:56:36 <Maxdamantus> because of `new` crap.
01:56:48 <tdammers> new is a whole other can of worms, yes
01:56:51 <tdammers> prototypes and all that
01:57:07 <Maxdamantus> (new (function(){ this.foo = "bar"; }.bind({}))()).foo
01:57:07 <tdammers> prototypes are truly weird
01:57:14 <Maxdamantus> that should be "bar" iirc, not `undefined`.
01:57:21 <prinsen> Is it possible to make a synonyme for a Constuctor, that starts with a upper case?
01:57:28 <Maxdamantus> Indeed.
01:57:50 <tdammers> prinsen: uppercase is reserved for constructors (at the value level, that is)
01:58:09 <Maxdamantus> (that detail with `new` also makes it impossible to write a shim for Function.prototype.bind)
01:58:51 <prinsen> say we have JSMaybe a = Either a Undefined, I can pattern match on this using Left and Right, but it would be nicer with a JSJust and JSNothing
01:59:11 <Iceland_jack> prinsen: Yes, using PatternSynonyms
01:59:20 <prinsen> Haskell has it all
01:59:28 <Iceland_jack> It's a recent extension in GHC 7.8
01:59:44 <Iceland_jack>     pattern JSJust a = Left a
01:59:44 <Iceland_jack>     pattern JSNoting = Right Undefined
02:06:41 <Insanity133> How would I call Haskell code over HTTP?
02:07:15 <Benzi-Junior> hey I'm a bit rusty over here and GHC can't find Data.String.Utils (I need the split function)
02:07:32 <Benzi-Junior> I guess my question is cabal install ?
02:09:03 <jack_rabbit> Benzi-Junior, looks like it's in the MissingH package.
02:09:04 <jack_rabbit> http://hackage.haskell.org/package/MissingH-1.0.0/docs/Data-String-Utils.html
02:09:19 <ClaudiusMaximus> Benzi-Junior: use hayoo to find which package provides the module, then cabal install the package
02:09:25 <dcoutts_> Benzi-Junior: but I'd recommend the split package instead
02:12:52 <Benzi-Junior> ok
02:12:54 <Benzi-Junior> thanks
02:15:46 <Benzi-Junior> ok I'm getting a compile error telling me the spliton is expecting an IO but that is not its type what's going on here ?
02:17:33 <prinsen> I have a transformer stack ExceptT e (StateT s m) a. I read a comment somewhere that the order of this stack matters, and if its wrong we will loose state on exceptons. Can someone explain this further?
02:20:04 <Benzi-Junior> nvm solved it
02:20:28 <nshepperd> prinsen: monad transformers sort of apply "inside out", most of the time
02:21:30 <nshepperd> prinsen: so `ExceptT e (StateT s m) a` is secretly a `StateT s m (Either e a)` iirc
02:22:26 <nshepperd> prinsen: while `StateT s (ExceptT e m) a` is secretly a `s -> ExceptT e m (a, s)`
02:23:00 <hyPiRion> prinsen: `ExceptT e (StateT s m) a` returns `m (Either e a, s)` after a run, whereas `StateT s (ExceptT e m) a` returns `m (Either e (a, s))`
02:24:03 <nshepperd> yes, that
02:25:02 * hackagebot bsparse 0.0.5 - A simple unassuming parser for bytestring  http://hackage.haskell.org/package/bsparse-0.0.5 (VincentHanquez)
02:26:28 <prinsen> Ok, so in the latter case (StateT s (Exc...), what causes it to lose state?
02:30:39 <hyPiRion> prinsen: not sure if I understand the question, but the ordering of StateT and ExceptT. The state is returned as part of the either.
02:30:49 <prinsen> hyPiRion: I guess its because the handler in catchE gets the wrong state
02:31:45 <oskiv> Hello. I'm having trouble with a large LBS that is accumulating in memory instead of being consumed in constant space. I suspect lambda bindings are holding references to the outermost cons (or the LBS equivalent), preventing collection. Is that possible?
02:32:01 <prinsen> hyPiRion: As the state is a part of the Either, its lost on a throE
02:33:13 <prinsen> hyPiRion: while it sits safely in the StateT if you use EitherT (StateT ..)
02:33:16 <hyPiRion> right
02:34:45 <oskiv> ...alternatively, is it necessary to consume a large LBS in a tail-recursive manner for it to be consumed in constant space?
03:00:57 <santiago> Is there a reason why it is a horrible idea to instantiate the Num class like this: http://pastebin.com/7AndcHkC ?
03:02:40 <santiago> Other that you don't like it. Will this have any effect on existing code?
03:04:39 <santiago> I ask, because the syntax you get is very natural for vector stuff
03:05:20 <prophile> santiago: yes
03:05:32 <santiago> how?
03:05:38 <prophile> because there's another perfectly valid instance for (Num a) => Num [a]
03:06:03 <prophile> also your fromInteger is a bit broken
03:06:15 <prophile> [1, 4] + 0 should be [1, 4] not [1]
03:06:40 <prophile> you could replace zipWith with liftA2 and it would still be valid
03:06:51 <santiago> yes, the behavior is weird, I'm not talking about the particular implementation
03:07:08 <prophile> the usual rule of thumb with Haskell is when there's ambiguity, use a newtype with instances
03:07:21 <santiago> I'm asking about how it affects other code
03:07:30 <santiago> Ok
03:07:41 <prophile> santiago: in general you can create (Num a) => Num (f a) for any applicative f
03:07:46 <santiago> But then I loose the syntax, right?
03:08:02 <prophile> but it's pretty contentious _which_ applicative is the correct choice in case of [] because there are two
03:08:08 <oskiv> 'unsafePerformIO' has lots of warnings in the haddocks that are very clear, but why is 'unsafeInterleaveIO' unsafe?
03:08:52 <prophile> oskiv: http://stackoverflow.com/questions/13263692/when-is-unsafeinterleaveio-unsafe may be an interesting read
03:09:08 <oskiv> Thanks.
03:15:04 * hackagebot dynamic-graph 0.1.0.2 - Draw and update graphs in real time with OpenGL  http://hackage.haskell.org/package/dynamic-graph-0.1.0.2 (adamwalker)
03:15:51 <zos> QUIT
03:15:59 <zos> :[
03:16:00 <zos> sorry
03:17:55 <supki> santiago: another problem is that suddenly incorrect programs type check
03:18:08 <supki> I'd like [1, 4] + 0 to be an error more often than not
03:19:02 <supki> and especially not some weird thing like [1] =)
03:19:08 <oskiv> prophile: http://stackoverflow.com/questions/13263692/when-is-unsafeinterleaveio-unsafe is indeed an excellent read.
03:19:28 <santiago> supki: I agree. I'm very new to Haskell, this is the first thing I came up with. What I am trying to find out is a good way to overload + for matrix operations.
03:19:57 <santiago> Because I noticed most of the libraries use very weird operators
03:20:04 * hackagebot dynamic-graph 0.1.0.3 - Draw and update graphs in real time with OpenGL  http://hackage.haskell.org/package/dynamic-graph-0.1.0.3 (adamwalker)
03:20:10 <prophile> oskiv: I'm hoping it wins a Pulitzer Prize next year
03:20:42 <santiago> Can't this be done? Or do people think it's just a bad idea?
03:22:55 <halvorg> in scotty, what does the stream function do?
03:23:07 <halvorg> http://hackage.haskell.org/package/scotty-0.9.0/docs/Web-Scotty-Trans.html it's documented there.
03:23:15 <halvorg> can i use it to serve streaming video?
03:26:12 <t7> @pl circle r = map(\y ->map(\x->if sqrt(x*x+y*y)<=r then '*' else ' ')[-r..r])[-r..r]
03:26:12 <lambdabot> (line 1, column 11):
03:26:13 <lambdabot> unexpected " "
03:26:13 <lambdabot> expecting operator
03:26:50 <t7> > let circle r = map(\y ->map(\x->if sqrt(x*x+y*y)<=r then '*' else ' ')[-r..r])[-r..r] in circle 2
03:26:52 <lambdabot>  ["  *  "," *** ","*****"," *** ","  *  "]
03:26:57 <oskiv> prophile: This is related to my earlier question. When I put an LBS together from chunks like as read with 'hGet', I find the lot is accumulating in memory instead of being processed in constant space. So I looked up how 'Data.ByteString.Lazy.hGetContents' is implemented, hence 'unsafeInterleaveIO', but now I see that the whole LBS-from-IO pattern is "not considered good style".
03:27:04 <t7> how do i use pl again?
03:27:10 <oskiv> prophile: Time to look at alternatives.
03:27:17 <BoR0> @pl \y ->map(\x->if sqrt(x*x+y*y)<=r then '*' else ' '
03:27:18 <lambdabot> (line 1, column 51):
03:27:18 <lambdabot> unexpected end of input
03:27:18 <lambdabot> expecting variable, "(", operator or ")"
03:27:27 <prophile> oskiv: standard answer is to use either pipes or conduit
03:27:40 <zipper> I couldn't parse JSON yesterday.
03:27:40 <BoR0> @pl \y ->map(\x->if sqrt(x*x+y*y)<=r then '*' else ' ')
03:27:41 <lambdabot> map . flip flip ' ' . flip flip '*' . (if' .) . flip flip r . (((<=) . sqrt) .) . (. join (*)) . (+) . join (*)
03:27:47 <zipper> Goddamnit haskell.
03:27:50 <prophile> https://www.haskell.org/haskellwiki/Pipes
03:28:02 <prophile> https://www.haskell.org/haskellwiki/Conduit
03:29:04 <zipper> Haskell must hate me.
03:29:12 <oskiv> prophile: Thanks. It is now stating to become clear why pipes and conduit exist.
03:35:05 * hackagebot test-framework-sandbox 0.0.2.5 - test-sandbox support for the test-framework package  http://hackage.haskell.org/package/test-framework-sandbox-0.0.2.5 (junjihashimoto)
03:44:18 <srenatus> I don't get it. How does Test.Sandbox work?  I.e. is it sandboxing IO actions?
04:00:11 <srenatus> doesn't look like that from the flare-test example... what does it use? namespaces? LXC?
04:04:39 <torpet> Hi, I am trying to find out whether there is an occurance of multiple zeros in a row in an Integer array of 1s and 0s
04:05:02 <torpet> My idea was to do it recursively, and to put the previous value in a variable, but that is not really functional.
04:06:27 <hpc> group it and measure the length of sublists
04:06:45 <hpc> > group [1,0,0,0,1,1,1,0,1,0,0]
04:06:47 <lambdabot>  [[1],[0,0,0],[1,1,1],[0],[1],[0,0]]
04:14:45 <Kneiva> > any ((>1) . length) $ group [1,0,0,0,1,1,1,0,1,0,0]
04:14:48 <lambdabot>  True
04:27:21 <torpet> Kneiva: http://lpaste.net/865801076853440512
04:29:04 <Kneiva> ah, I missed that zero requirement
04:29:49 <torpet> good solution or could it be shorter?
04:34:46 <Kneiva> torpet: seems a bit verbose, but my Haskell is also a bit rusty
04:34:59 <prinsen> With type a + b = Either a b, the + operator is right associative meaning it builds up like (Either (Either a b) c). Is there any way to make it left associative?
04:35:31 <srenatus> > filter (notElem 0) [[0], [1], [0,1]]
04:35:33 <lambdabot>  [[1]]
04:39:11 <prinsen> or rather right associative, as it is left associative
04:40:35 <Kneiva> torpet: building on srenatus's filter: http://lpaste.net/113804
04:40:47 <lpaste> SwashBuckla_ pasted “Help creating an `instance Arbitrary (JoinList m a)`” at http://lpaste.net/6373783492202856448
04:41:22 <SwashBuckla_> any ideas?
04:41:40 <SwashBuckla_> a JoinList is much like that defined in `sample`
04:42:32 <SwashBuckla_> but not necessarily using the Product Monoid
04:45:12 <SwashBuckla_> I would have thought that QC could infer that from the datatype, but then again I have not pinned down what m or a are
04:46:14 <aleneumann> hallo
04:46:27 <aleneumann> quit
04:50:41 <rydgel> @pl \(_,x) -> x
04:50:42 <lambdabot> snd
04:53:37 <fProgrammer> I have a noob doubt, how do you execute mutliple statements in haskell? like this http://lpaste.net/113806
04:54:37 <pharpend> fProgrammer: you don't
04:54:46 <pharpend> fProgrammer: everything should be contained in one expression
04:54:51 <pharpend> fProgrammer: how fp works
04:54:52 <mekeor> fProgrammer: there are no statements in haskell :D
04:54:56 <y> there are no statements in haskell..
04:55:14 <rom1504> there are no haskell in statements..
04:55:16 <lpaste> pharpend pasted “cabal error” at http://lpaste.net/113807
04:55:23 <pharpend> oh
04:55:23 <fProgrammer> pharpend: so basically put all statements in a function and call that function in if?
04:55:25 <pharpend> i see how it is
04:55:55 <mekeor> fProgrammer: there are still no statements in haskell.
04:55:58 <pharpend> fProgrammer: you shouldn't be using `if` unless you are deep inside a monad, and it doesn't sound like you are. Instead, you should use guards
04:56:28 <pharpend> fProgrammer: How about this, what program are you writing, and what is it supposed to accomplish
04:56:33 <novns> fProgrammer, read this first http://learnyouahaskell.com/chapters
04:56:39 <y> fProgrammer: what are you trying to do? trying to "naively" port a program won't work
04:56:57 <pharpend> fProgrammer: also, be prepeared, people in this channel will barrage you with advanced information. You might try #haskell-beginners
04:57:03 <fProgrammer> y: yeah, lemme read again
04:57:17 <y> read?
04:57:23 <wei2912> fProgrammer: you should probably go to #haskell-beginners
04:57:26 <fProgrammer> y: read text
04:57:26 <rom1504> y: n
04:57:38 <fProgrammer> thanks
04:57:42 <wei2912> fProgrammer: and ask your question there
04:57:45 <pharpend> fProgrammer: porting between haskell and imperative languages doesn't quite work that way
04:58:31 <t7> pharpend: you are not using enough IORefs
04:58:31 <pharpend> anyway, could someone help me with that error lpaste posted?
04:58:42 <pharpend> t7: That's someone else's package, not mine
04:58:52 <pharpend> haskell-src-exts, i believe it's core
04:58:53 <t7> "porting between haskell and imperative languages doesn't quite work that way"
04:58:59 <pharpend> hahaha
04:59:06 <pharpend> one sec
05:00:29 <pharpend> back
05:01:10 <pharpend> okay, trying to build hindent
05:01:18 <pharpend> (works perfectly on my other computer)
05:01:33 <pharpend> and I'm getting that error from haskell-src-exts
05:03:09 <pharpend> alright, comon portage
05:03:13 <pharpend> I know you can rebuild it
05:10:36 <rgr> "there are no statements in haskell" ... lol.
05:12:34 <tdammers> rgr: data Statement = NullStatement | ExpressionStatement Expression | AssignmentStatement VariableName Expression | ...
05:17:18 <wei2912> @src map
05:17:19 <lambdabot> map _ []     = []
05:17:19 <lambdabot> map f (x:xs) = f x : map f xs
05:18:03 <wei2912> @src foldl
05:18:04 <lambdabot> foldl f z []     = z
05:18:04 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
05:18:14 <wei2912> @src foldr
05:18:14 <lambdabot> foldr f z []     = z
05:18:14 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:19:15 <wei2912> i should probably do this in PM, sorry
05:57:45 <artemshitov> I have a noob question. Imagine I have a counter and a server in Scotty. Every time a user visits a page, the counter is incremented and the value is shown to the user. The counter is persisted only in memory, nothing fancy. I just don't know how to do it. State monad? TVar?
05:58:29 <tdammers> STM works
05:58:45 <tdammers> state monad doesn't, I think
05:58:55 <tdammers> IORef would work too
05:59:25 <artemshitov> How do I get the value from TVar to STM (ok, readTVar perhaps) and then to Scotty?
05:59:46 <tdammers> ScottyT :D
05:59:47 <clrnd> doesn't scotty provide a monad trans with some kind of state?
05:59:51 <tdammers> yeah
05:59:54 <tdammers> ScottyT
06:00:02 <artemshitov> Oh no
06:00:03 <tdammers> you can stack that on top of anything you like
06:00:46 <artemshitov> Looks like it's time to grok those transformers then
06:01:32 <artemshitov> Thanks!
06:01:38 <tdammers> well, regular (non-transformer) Scotty sits on top of IO
06:02:01 <tdammers> so you could create an IORef on startup, close over it, and the just liftIO any actions on it into your Scotty monad
06:03:52 <artemshitov> Ok, I'll try that too
06:04:39 <clrnd> artemshitov, I recommend to learn transformers, it's really not that big deal!
06:04:46 <hhjkghkarj> is there a map function that applies a list of functions in order to a list?
06:05:10 <prophile> hhjkghkarj: sounds like <*>
06:05:11 * hackagebot generic-deriving 1.7.0 - Generic programming library for generalised deriving.  http://hackage.haskell.org/package/generic-deriving-1.7.0 (JosePedroMagalhaes)
06:05:13 * hackagebot data-interval 1.1.1 - Interval arithmetic for both open and closed intervals  http://hackage.haskell.org/package/data-interval-1.1.1 (MasahiroSakai)
06:05:27 <hhjkghkarj> prophile: how do i use it?
06:05:45 <prophile> > [(+ 3), (* 2), (- 12)] <*> [0, 100]
06:05:47 <lambdabot>  No instance for (GHC.Show.Show b0)
06:05:47 <lambdabot>    arising from a use of ‘M91504928361818074709075.show_M91504928361818074709...
06:05:47 <lambdabot>  The type variable ‘b0’ is ambiguous
06:05:47 <lambdabot>  Note: there are several potential instances:
06:05:47 <lambdabot>    instance [safe] GHC.Show.Show
06:05:56 <prophile> what
06:06:01 <prophile> > [(+ 3), (* 2), (- 12)] <*> [0, 100 :: Int]
06:06:03 <Iceland_jack> hhjkghkarj: You can use 'zipWith ($)' or 'zipWith id'
06:06:03 <lambdabot>  No instance for (GHC.Num.Num (GHC.Types.Int -> GHC.Types.Int))
06:06:03 <lambdabot>    arising from a use of syntactic negation
06:06:21 <prophile> oh
06:06:22 <Iceland_jack> prophile: you want "subtract", but that's the cartesian product
06:06:28 <SwashBuckla_> Iceland_jack: !
06:06:32 <Iceland_jack> SwashBuckla_: !
06:06:35 <prophile> bah for that bit of syntactic horror
06:06:48 <SwashBuckla_> any idea how to get an instance Arbitrary JoinList? (http://lpaste.net/raw/6373783492202856448)
06:07:06 <prophile> Iceland_jack: cartesian product sounded like what was described?
06:07:21 <Iceland_jack> <hhjkghkarj> is there a map function that applies a list of functions in order to a list?
06:07:21 <Iceland_jack> Sounded like applying it elementwise
06:07:24 <hhjkghkarj> thanks
06:07:26 <Iceland_jack> To me at least
06:07:41 <Iceland_jack> SwashBuckla_: If you know how to generate trees using QuickCheck you can use that
06:07:44 <prophile> hm, ok
06:07:55 <SwashBuckla_> hmm ok
06:07:56 <Iceland_jack> SwashBuckla_: (hint, it was discussed in the Chalmers recordings)
06:08:00 <SwashBuckla_> :O
06:08:06 <SwashBuckla_> he knows
06:08:08 <SwashBuckla_> he knows I know
06:08:12 <Iceland_jack> SwashBuckla_: http://www.cse.chalmers.se/~rjmh/QuickCheck/manual.html
06:08:23 <Iceland_jack> Go to "Generating Recursive Data Types"
06:11:10 <SwashBuckla_> Iceland_jack: thanks :)
06:11:48 <Iceland_jack> No prob :)
06:21:10 <clrnd> @source zipWith
06:21:11 <lambdabot> Unknown command, try @list
06:21:18 <clrnd> @src zipWith
06:21:18 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
06:21:19 <lambdabot> zipWith _ _      _      = []
06:22:12 <Iceland_jack> > zipWith ($) [f, g, h] [a, b, c] :: [Expr]
06:22:14 <lambdabot>  [f a,g b,h c]
06:22:35 <Fuco> when I forkIO, how can I wait on the main thread until the spawned one ends? This is sometimes called "join" (e.g. in Java/C#)
06:22:50 <zipper> does this have a name --> <*>
06:22:56 <prophile> paul
06:22:57 <Iceland_jack> zipper: "ap"
06:23:02 <Iceland_jack> Paul also works
06:23:17 <zipper> Iceland_jack: You're kidding.
06:23:23 <Iceland_jack> Never.
06:23:58 <Iceland_jack> Fuco: Check this link out http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Concurrent.html#g:12
06:24:14 <mbuffett1> What would be an easy way to convert a list like this : ["1" "2" "3" "4"] into a string like this : "1 2\n3 4"?
06:24:39 <prophile> mbuffett1: try const "1 2\n3 4"
06:24:51 <Iceland_jack> > unlines (map unwords (chunksOf 2 ["1", "2", "3", "4"]))
06:24:53 <lambdabot>  "1 2\n3 4\n"
06:25:01 <Iceland_jack> There is an extra newline at the end but otherwise it's what you asked for
06:25:03 <prophile> so you're looking to insert a comma between each group of two of elements?
06:25:11 * hackagebot snaplet-redis 0.1.4.1 - Redis support for Snap Framework  http://hackage.haskell.org/package/snaplet-redis-0.1.4.1 (DmitryDzhus)
06:25:13 <prophile> s/comma/newline/
06:25:13 <mbuffett1> Oh that's cool, I didn't know about the chunksOf thing
06:25:22 <Iceland_jack> It's from the "split" package
06:25:45 <mbuffett1> prophile: Yeah that's what I'm trying to do
06:25:51 <mbuffett1> Do I have to import that then?
06:26:04 <Iceland_jack> mbuffett1: It resides in "Data.List.Split"
06:26:17 <Iceland_jack> and you'll have to install the split package using "cabal install split"
06:26:54 <Iceland_jack> If you want to insert commas between elements you should use the (awkwardly named) function 'intercalate :: [a] -> [[a]] -> [a]' from Data.List
06:26:59 <bernalex> if I upload a foo-version.tar.gz to hackage, and foo-version is already uploaded, will it merely replace the existing one?
06:27:06 <Iceland_jack> > intercalate ", " ["1", "4", "10"]
06:27:08 <lambdabot>  "1, 4, 10"
06:27:18 <Fuco> Iceland_jack: I don't understand what in that example causes the main thread to wait... is 'return mvar' checking what is written inside the mvar?
06:27:30 <Fuco> return is just normal IO return there, hm?
06:27:42 <Iceland_jack> That's right Fuco
06:27:52 <mbuffett1> Great, I'll try that out, thanks!
06:28:16 <Iceland_jack> Fuco: That example effectively creates a variable that can either be empty or full (and contain a single value)
06:28:28 <Iceland_jack> if it's empty, accessing the variable will block
06:28:33 <Fuco> I see
06:28:49 <joe9> anyone tried eff-lang?
06:29:12 <mbuffett1> Iceland_jack: Would you mind giving me a quick explanation of how your example works? It works great I'm just trying to understand how
06:30:05 <Iceland_jack> 1. It creates a variable (newEmptyMVar)
06:30:05 <Iceland_jack> 2. It forks a thread with some action "io" and says "when the thread dies, put some junk () into the box)
06:30:05 <Iceland_jack> 3. Then if you try to use "takeMVar" it will block until the thread is dead
06:30:55 <Iceland_jack> mbuffett1: If I understand the requirements correctly, first step is splitting the list into chunks of length 2:
06:30:55 <Iceland_jack> > chunksOf 2 (map show [1..10])
06:30:58 <lambdabot>  [["1","2"],["3","4"],["5","6"],["7","8"],["9","10"]]
06:31:43 <Iceland_jack> Then you want to turn sublists ["3", "4"] into something like "3 4"
06:32:02 <Iceland_jack> For that you 'map' 'unwords':
06:32:02 <Iceland_jack> > unwords ["3", "4"]
06:32:04 <lambdabot>  "3 4"
06:32:18 <Iceland_jack> > map unwords (chunksOf 2 (map show [1..10]))
06:32:20 <lambdabot>  ["1 2","3 4","5 6","7 8","9 10"]
06:32:46 <oleo> unwords ?
06:32:48 <oleo> wth
06:32:56 <wei2912> oleo: ?
06:33:02 <Iceland_jack> 'words' splits a string by spaces
06:33:06 <Iceland_jack> > words "this is a quick test"
06:33:09 <lambdabot>  ["this","is","a","quick","test"]
06:33:12 <oleo> why are so many things named so funnily in haskell ?
06:33:16 <oleo> lol
06:33:19 <Iceland_jack> 'unwords' reverse that
06:33:27 <Iceland_jack> > unwords ["this","is","a","quick","test"]
06:33:29 <lambdabot>  "this is a quick test"
06:33:29 <wei2912> bc naming is the hardest thing to do for programmers
06:33:31 <Kinnison> Iceland_jack: words splits by "whitespace"
06:33:44 <Iceland_jack> Kinnison: Yes, thanks for the correction
06:33:54 <oleo> unwords == sentence
06:34:07 <prophile> @check \x -> unwords (words x) == x
06:34:10 <lambdabot>  *** Failed! Falsifiable (after 11 tests and 4 shrinks):
06:34:10 <lambdabot>  " "
06:34:18 <prophile> @check \x -> words (unwords x) == x
06:34:20 <lambdabot>  *** Failed! Falsifiable (after 4 tests and 2 shrinks):
06:34:20 <lambdabot>  [""]
06:34:23 <prophile> interesting
06:34:35 <wei2912> wait, what
06:34:52 <Iceland_jack> I didn't name the Haskell functions :) but 'un'words and 'un'lines is at least consistent
06:35:11 <wei2912> oh wait, that explains
06:35:30 <wei2912> > words (unwords ["a", "b", "c", "d"])
06:35:32 <lambdabot>  ["a","b","c","d"]
06:35:36 <wei2912> > words (unwords [""])
06:35:38 <lambdabot>  []
06:35:43 <clrnd> ohhh
06:35:50 <Iceland_jack> They're not inverses except for a somewhat restricted subset
06:36:04 <Iceland_jack> Since "words" loses information
06:36:09 <wei2912> i never knew lambdabot could do that
06:36:14 <Iceland_jack> > words "a  b"
06:36:16 <Iceland_jack> > words "a b"
06:36:16 <lambdabot>  ["a","b"]
06:36:18 <lambdabot>  ["a","b"]
06:36:27 <wei2912> Iceland_jack++ thanks for the info
06:36:38 <prophile> losing information isn't always a problem if your "inverse" is only a left- or right- inverse if I recall correctly
06:37:00 <prophile> read . show = id but show . read ≠ id being the usual example
06:38:26 <y> > (words . unwords) ["a b c", "d e f"]
06:38:28 <lambdabot>  ["a","b","c","d","e","f"]
06:40:19 <tdammers> prophile: read . show isn't id either
06:40:50 <prophile> I think it's "meant" to be
06:40:55 <prophile> for some sufficiently flimsy definition of meant
06:41:19 <clrnd> jaja
06:41:39 <Iceland_jack> Yeah identities of encoding and decoding (XML, Unicode, ...) are flimsy at best
06:43:21 <tdammers> prophile: I think the intention is to make it "reasonably close to identity"
06:43:28 <tdammers> prophile: but not actually id
06:50:12 * hackagebot spatial-math 0.2.1.0 - 3d math including quaternions/euler angles/dcms and utility functions  http://hackage.haskell.org/package/spatial-math-0.2.1.0 (GregHorn)
06:50:34 <ddellacosta> what do folks think of this? https://github.com/fujimura/hi
06:54:31 <bernalex> is there a toString such that toString s = id if s is a String?
06:54:53 <Iceland_jack> Not really, except 'id :: String -> String'? :)
06:54:57 <bernalex> id s
06:55:05 <tdammers> bernalex: my string-convert library has one
06:55:19 <tdammers> http://hackage.haskell.org/package/string-convert
06:55:19 <bernalex> there's nothing in base?
06:55:27 <tdammers> don't think so, no
06:57:24 <bernalex> looks like Data.Stringable is useful.
06:58:16 <Fuco> ghc: panic! (the 'impossible' happened) ... awesome error message
06:58:25 <Fuco> clearly not impossible
06:59:40 <geekosaur> thta'd be why impossible is in scare quotes :p
07:04:32 <torpet> I'm trying to solve a bit of strange problem
07:05:34 <torpet> I want to create all permutations of 0s and 1s of length 0
07:05:42 <Iceland_jack> length 0?
07:05:47 <torpet> length n
07:05:47 <torpet> sorry
07:05:49 <tdammers> hehe
07:05:53 <Iceland_jack> > replicateM 5 "01"
07:05:55 <lambdabot>  ["00000","00001","00010","00011","00100","00101","00110","00111","01000","01...
07:06:07 <torpet> wow, that basically solves all my problems :D
07:06:16 <ddellacosta> so, I'm trying to figure out basic package management stuff
07:06:38 <ddellacosta> or rather, how to load up a package in a cabal sandbox, open up ghci, and play with it
07:06:44 <beaky> hello
07:06:54 <johnw> heya
07:07:04 <torpet> Iceland_jack: Is there a way to do that without importing a package thats not from Data.List or Prelude?
07:07:21 <ddellacosta> I thought I could create a .cabal file with the package as a dependency, then do cabal install --only-dependencies, and then ghci would let me do :m Some.Module
07:07:24 <Iceland_jack>  
07:07:24 <Iceland_jack> torpet: You can write the definition yourself, 'replicateM' is from Control.Monad
07:07:24 <ddellacosta> but apparently not?
07:07:38 <Iceland_jack> ddellacosta: Did you open a repl using 'cabal repl'?
07:07:49 <ddellacosta> Iceland_jack: ah, no, didn't realize that that was the magic sauce
07:08:16 <ddellacosta> Iceland_jack: ah, but that expects there's an executable I guess?
07:08:25 <Iceland_jack> not really
07:08:36 <ddellacosta> let me restate the question then--what's the best way to play with a lib in ghci without installing stuff all over the place?
07:08:51 <ddellacosta> is it appropriate to start with a sandbox, or do folks have another way?
07:08:59 <Kinnison> sandboxes are excellent for this kind of thing
07:08:59 <ddellacosta> Iceland_jack: ah okay, maybe I read that wrong
07:09:03 <Iceland_jack> Starting with a sandbox is fine
07:09:25 <ddellacosta> okay, so maybe I'm just confused by "cabal: can't find source for site in ."
07:09:58 <ddellacosta> ah, wait, I guess I need to have something that actually matches the source I've listed in the .cabal file, huh? d'oh
07:10:07 <Kinnison> :-)
07:10:13 * ddellacosta goes to read up on .cabal files
07:10:18 <ddellacosta> thanks Kinnison and Iceland_jack :-)
07:10:36 <Iceland_jack> ddellacosta: You don't need a .cabal file just to try out a library
07:10:48 <ddellacosta> Iceland_jack: oh, no?  I would love to know how to do that
07:10:53 <Kinnison> If you just want to play with a lib then: mkdir /tmp/bleh && cd /tmp/bleh && cabal sandbox init && cabal install somelib && cabal repl
07:11:06 <Iceland_jack> something like:
07:11:06 <Iceland_jack>     cd /tmp/foo && cabal sandbox init && cabal install split && cabal repl
07:11:27 <ddellacosta> ah, okay, I didn't realize that you could do cabal install and it would stick to the sandbox
07:11:36 <ddellacosta> wow, thanks again you two
07:11:38 <Iceland_jack> ddellacosta: Then try doing 'import Data.List.Split' and see if that works
07:11:46 <Kinnison> :-)
07:11:52 <ddellacosta> Iceland_jack: btw, how did you know I wanted to play with split??  psychic
07:11:58 <torpet> Iceland_jack: Is there a way to convert the Strings created by replicateM to Integers?
07:11:58 <beaky> how do i refactor this function: let f n xs = case xs of { [] -> []; _ -> [take n xs] ++ f n (drop n xs);}
07:11:59 <Iceland_jack> :)
07:12:13 <beaky> (to group every n elems of a list)
07:12:36 <Iceland_jack> beaky: You can use "splitAt" if you want to implement it yourself
07:12:43 <Iceland_jack> > splitAt 4 "hello world"
07:12:45 <lambdabot>  ("hell","o world")
07:12:46 <Kinnison> torpet: Just map a conversion function over the result
07:12:52 <torpet> ok
07:13:03 <torpet> that will turn 01 to 1 though right?
07:13:25 <Kinnison> if that's what your conversion function does, then yes :-)
07:14:11 <Iceland_jack> torpet: If you're going to convert binary numbers from 0 to an n-bit 111...11 into decimal numbers why not just
07:14:11 <Iceland_jack> > [0..2^5-1]
07:14:14 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
07:15:10 <torpet> Iceland_jack: all of them need to be of length n though
07:15:21 <torpet> so 0 -> 00000 if n=5
07:15:40 <Iceland_jack> torpet: So you want Strings back?
07:15:48 <Iceland_jack> Because you asked:
07:15:48 <Iceland_jack> <torpet> Iceland_jack: Is there a way to convert the Strings created by replicateM to Integers?
07:15:58 <torpet> [Integer] ideally
07:16:02 <Iceland_jack> And '0 == 000000'
07:16:13 <lpaste> artemshitov pasted “Counter with Scotty” at http://lpaste.net/113813
07:16:34 <artemshitov> So, I'm trying to make that counter with transformers
07:16:48 <torpet> [1,0,0,0] for 8
07:16:54 <torpet> and so on
07:17:03 <artemshitov> And it goes "No instance for (MonadTrans (ActionT T.Text)) arising from a use of ‘lift’"
07:17:08 <Iceland_jack> aah, you just want to convert "1000" to [1,0,0,0]
07:17:17 <artemshitov> Line 13
07:17:44 <Iceland_jack> > map digitToInt "1000"
07:17:46 <lambdabot>  [1,0,0,0]
07:17:52 <artemshitov> Although there must be suck an instance, according to Scotty docs at http://hackage.haskell.org/package/scotty-0.9.0/docs/Web-Scotty-Trans.html
07:17:57 <artemshitov> *such
07:18:16 <Iceland_jack> > map (map digitToInt) (replicateM 4 "01")
07:18:18 <lambdabot>  [[0,0,0,0],[0,0,0,1],[0,0,1,0],[0,0,1,1],[0,1,0,0],[0,1,0,1],[0,1,1,0],[0,1,...
07:18:32 <albeit> Is there a way to view what the -H and -A garbage collection values are set to for a running program?
07:18:45 <Iceland_jack> That gives you a [[Int]] rather than [[Integer]], but you can use 'fromIntegral' to fix that
07:19:32 <y> @type map (fromIntegral . digitToInt)
07:19:33 <lambdabot> Num b => [Char] -> [b]
07:19:51 <clrnd> artemshitov, interesting it says (ActionT Text)
07:19:58 <clrnd> data ActionT e m a Source
07:20:03 <clrnd> data ActionT e m a*
07:20:52 <artemshitov> clrnd: ScottyError e => MonadTrans (ActionT e) where e is Text
07:20:56 <clrnd> there is an instance of MonadTrans for ActionT e with e :: ScottyError e ... wiat it's Text
07:21:02 <michaelt> Is there some problem with the new hackage and user names +passwords?
07:24:00 <supki> artemshitov: what's T?
07:24:21 <artemshitov> supki: import qualified Data.Text.Lazy as T
07:24:57 <clrnd> he gave a paste ^
07:25:15 <supki> oh, sorry
07:25:26 <supki> artemshitov: do you have multiple transformers versions installed?
07:25:46 <artemshitov> supki: how do I check that?
07:26:12 <supki> cabal exec -- ghc-pkg list transformers
07:27:47 <artemshitov> Looks like I do. 0.3.0.0 and 0.4.1.0. Default available version: 0.4.1.0
07:28:45 <supki> OK, so I think the version scotty is built against is different from the one cabal uses to build your app
07:29:30 <supki> the usual solution is to unregister the version that didn't come with GHC and to rebuild the offending package (i.e. scotty) against the one that did
07:30:39 <torpet_> is there a difference between fromIntegral and toInteger?
07:30:55 <artemshitov> supki: I'll try that, thanks
07:31:29 <prophile> :t fromIntegral
07:31:30 <michaelt> @type fromInteger
07:31:31 <Adeon> toInteger turns intergrals specifically into the Integer type
07:31:31 <lambdabot> (Num b, Integral a) => a -> b
07:31:33 <lambdabot> Num a => Integer -> a
07:31:35 <prophile> :t toInteger
07:31:36 <lambdabot> Integral a => a -> Integer
07:31:37 <Adeon> and fromIntegral...does what lambdabot says
07:32:55 <michaelt> fromIntegral converts from either-Int-or-Integer to any Num type
07:35:00 <albeit> How can I make the GC run less frequently by letting more garbage be accumulated beform GC is run?
07:35:25 <EvanR> fromIntegral converts any Integral type to any Num type
07:35:34 <Adeon> there are some RTS options you can pass to ghc to control the gc behaviour
07:35:47 <Adeon> https://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-options-gc
07:35:52 <EvanR> :t fromIntegral (9 :: Word8)
07:35:54 <lambdabot> Num b => b
07:35:56 <albeit> Adeon: Yeah, I'm looking at the guide, but to be honest I'm a little confused
07:35:58 <mbuffett1> Hey guys, can anyone give me some style tips on writing cleaner haskell code? I always end up with either really long incomprehensible lines like this : http://lpaste.net/113816, or I have a lot of nested "where"s, which looks pretty ugly : http://lpaste.net/113814. How do I keep my code readable?
07:36:29 <Kinnison> You don't need to keep nesting the wheres
07:36:36 <Kinnison> you could pull them all up to the top where
07:36:39 <EvanR> often i use one big where clause
07:36:52 <mbuffett1> Even though the top one references the lower ones?
07:37:03 <EvanR> thats the point of the where clause, its recursive
07:37:05 <tdammers> mbuffett1: yes
07:37:13 <tdammers> it works much like top-level declarations
07:37:37 <mbuffett1> Oh cool, I didn't know that, that helps a lot actually
07:38:20 <Iceland_jack> Also this:
07:38:20 <Iceland_jack>     map pieceRep [pieceAtPosition position game | position <- positions]
07:38:20 <Iceland_jack> can be rewritten as:
07:38:20 <Iceland_jack>     [ pieceRep (pieceAtPosition position game) | position <- positions ] or
07:38:23 <Iceland_jack>     map (pieceRep . pieceAtPosition position) positions
07:38:46 <Kinnison> I think the second is a little confusing
07:39:05 <Kinnison> map (pieceRep . (`pieceAtPosition` game)) positions
07:39:05 <Kinnison> perhaps
07:39:23 <Iceland_jack> Ah oops, yeah it should be flipped
07:42:38 <artemshitov> supki: It works! Thank you!
07:45:08 <hugomg> I have a question about ADTs.  Right now I have an ADT with 3 cases (data Expr = N Int | Add Expr Expr | If Int Expr Expr) and a function that gets rid of all the If nodes and returns an Expr that only uses N and Add. Is there a way to encode this in the type system? I currently have a bunch of functions that just call "error" on the If case, which is kind of unfortunate.
07:45:14 * hackagebot accelerate-fourier 0.0 - Fast Fourier transform and convolution using the Accelerate framework  http://hackage.haskell.org/package/accelerate-fourier-0.0 (HenningThielemann)
07:45:16 * hackagebot hsay 1.0.0 - (ab)Use Google Translate as a speech synthesiser  http://hackage.haskell.org/package/hsay-1.0.0 (alexander)
07:45:45 <Iceland_jack> hugomg: It is possible, you can look into "Data Types a la Carte" to get started
07:46:32 <Fuco> Iceland_jack: hmm, seems like "return mvar" is not enough, I had to do "_ <- readMVar mvar" for it to actually sync
07:46:40 <Fuco> mvars are lazy I guess
07:49:01 <Iceland_jack> Fuco: yes you needed to readMVar/takeMVar after you fork the thread
07:50:15 * hackagebot accelerate-fftw 0.0 - Accelerate frontend to the FFTW library (Fourier transform)  http://hackage.haskell.org/package/accelerate-fftw-0.0 (HenningThielemann)
07:50:17 * hackagebot accelerate-cufft 0.0 - Accelerate frontend to the CUFFT library (Fourier transform)  http://hackage.haskell.org/package/accelerate-cufft-0.0 (HenningThielemann)
07:52:05 <Fuco> Iceland_jack: then are the docs misleading or did it change and wasn't updated, or am I just not understanding it?
07:52:41 <Iceland_jack> Are you refering to http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Concurrent.html#g:12?
07:52:55 <Fuco> Iceland_jack: https://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Concurrent.html#g:13
07:53:03 <Fuco> oh, I have 4.6...
07:53:16 <hugomg> @Iceland_jack: Those datatypes a la carte look very verbose to use. I don't need to make Expr extensible though - just restrict it. Maybe there is a simpler way using GADTs?
07:53:16 <lambdabot> Unknown command, try @list
07:53:17 <Fuco> yes, what you linked
07:54:27 <Iceland_jack> Fuco: I guess it isn't mentioned in the docs but you need to use it something like this:
07:54:27 <Iceland_jack>     mvar <- myForkIO (... some complicated thing ...)
07:54:27 <Iceland_jack>     takeMVar mvar
07:54:52 <Fuco> aaah, I see
07:55:01 <Fuco> yes, this way it makes sense :)
07:55:13 <Fuco> anyway, work time's over, gotta go home \o/
07:55:15 * hackagebot accelerate-fourier-benchmark 0.0 - Compare different implementations of the Fast Fourier Transform  http://hackage.haskell.org/package/accelerate-fourier-benchmark-0.0 (HenningThielemann)
07:55:15 <mbuffett1> What would be a cleaner way to check that two ints, x and y, are both between a and b, right now I have four if statements and there's probably a better way to do it
07:56:13 <Iceland_jack> > all (inRange (2, 10)) [2, 5]
07:56:15 <lambdabot>  True
07:57:02 <chrisdone> Fuco: what are you doing in here, get back to #emacs!
07:59:06 <mbuffett1> Iceland_jack: Man I'm impressed haha, three questions today and you've had the right answer within minutes each time, thanks again
07:59:30 <Iceland_jack> I should be doing something productive :)
08:00:23 <Jello_Raptor> Quick Question: I have a function that is (String -> [Tokens]) that can throw an error, HSpec requires an (a -> IO b) function to use error checking :/ fmap doesn't do that
08:00:34 <EvanR> :t inRange
08:00:35 <lambdabot> Ix a => (a, a) -> a -> Bool
08:00:53 <rhexpl> Am I right in using <++ for precedence rules in ReadP? So that expr1 <++ expr2 favors expr1?
08:01:53 <EvanR> Jello_Raptor: yes
08:02:20 <Jello_Raptor> I'm not sure how to get the result I want
08:02:45 <EvanR> Jello_Raptor: how does String -> [Tokens] throw an error
08:02:54 <Jello_Raptor> something like a "return IO () myFunc"
08:03:11 <EvanR> huh
08:03:59 <EvanR> String -> [Tokens] cant return an IO anything, directly
08:04:05 <EvanR> it must return a list
08:04:38 <Jello_Raptor> EvanR: yes, it's a parser, and it can call `error "parse error"` if the input is broken
08:05:05 <EvanR> ok dont use error to signal parse error
08:05:45 <EvanR> in this case you could use String -> Maybe [Tokens] or a proper parser type would be Parser [Tokens] which serves the same purpose
08:06:14 <Jello_Raptor> EvanR: it's the standard idiom for the simplest form of a Happy parser
08:06:16 <EvanR> error "msg" isn't really expected to be caught by anything, though you could
08:06:56 <Jello_Raptor> EvanR: HSpec is capable of catching those error calls, and I'm using that in a few places to make sure the parser doesn't parse incorrect sequences
08:06:58 <EvanR> i dont know about Happy, but thats a bad type for something that could fail, unless empty list is the failure
08:09:02 <Jello_Raptor> EvanR: I know, I can't change it for a while for time reasons. Creating a proper error handling system is difficult, and for now I need to test basic syntax and semantics of the language.
08:09:16 <EvanR> any reason youre using happy rather than parsec?
08:12:44 <EvanR> Jello_Raptor: looks like hspec can expect errors from pure code, it doesnt need to be IO
08:12:53 <phaazon> hey, I have a type with existentially quantified variables names
08:12:54 <orbital> how would one troubleshoot "hoogle --color" not being colorful?
08:12:56 <Jello_Raptor> EvanR: it's YACC alike, and I've used other YACC alike parsers before
08:13:00 <phaazon> I’d like to avoid that
08:13:08 <phaazon> is there a simple way to do so?
08:13:37 <EvanR> Jello_Raptor: me too but parsec is much easier to use for many parsing tasks
08:13:48 <EvanR> than yacc
08:15:09 <qsuscs> why does "./bootstrap.sh" for cabal fail? Error during cabal-install bootstrap:\nBuilding the Cabal package failed.\n./bootstrap.sh  231,51s user 6,56s system 97% cpu 4:04,48 total
08:15:13 <EvanR> Jello_Raptor: http://hspec.github.io/expectations.html Both error and undefined throw exceptions of type ErrorCall.
08:15:26 <qsuscs> the last thing i get before that is [55 of 78] Compiling Distribution.Simple.LHC ( Distribution/Simple/LHC.hs, dist/build/Distribution/Simple/LHC.o )
08:15:59 <Jello_Raptor> EvanR: huh, then why am I getting a type error asking for an a -> IO b :/
08:16:13 <EvanR> cant see your code
08:16:18 <Jello_Raptor> I couldn't find shouldTHrow in the hackage docs for hspec
08:16:45 <Jello_Raptor> shouldThrow :: Exception e => IO a -> Selector e -> Expectation
08:16:50 <Jello_Raptor> according to the HSpec docs
08:17:26 <Jello_Raptor> ahh, they're using 'evaluate' to wrap things
08:17:32 <EvanR> shouldThrow is for IO actions
08:18:06 <EvanR> evaluate is for pure code, which can throw exceptions too, of various kinds
08:19:35 <EvanR> but ill say exceptions from pure code should be considered errors, bugs only, rather than control mechanisms
08:20:16 * hackagebot git-annex 5.20141125 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20141125 (JoeyHess)
08:22:15 <michaelt> Are there any hackage administrators around? I can't seem to upgrade for the new hackage...
08:22:25 <Fuco> chrisdone: I'm writing pulseaudio bindings in order to control volume levels from xmonad :D
08:22:44 <Fuco> chrisdone: because I'm insane, I guess
08:24:49 <bernalex> is there a less obscure way to do 'foo *** foo'?
08:25:20 <bernalex> the reason for doing foo *** foo is because the first foo takes a different type to the second (i.e. it takes Bar a, and there's a different Bar on both sides)
08:25:30 <bernalex> this requires you to think for a second, so it's a bit obscure.
08:25:33 <Fuco> lift2M (,) foo foo ? :D
08:26:06 <Fuco> ofcourse M2 I mean...
08:26:21 <bernalex> that doesn't exactly look less obscure. what I mean by obscure is that you have foo *** foo, which looks like join (***) foo, and it's at first non-obvious that it's because they operate on different types.
08:27:01 <bernalex> you might be tempted to just go "oh, that's a bit of a snafu", and rewrite it as join (***) foo, and get a somewhat obscure type error.
08:31:49 <bernalex> if I have a function that takes a, b, c, can I say that they need to inherit the same typeclass, but IDK which?
08:31:52 <Iceland_jack> bernalex: Can you give me the types?
08:31:59 <Iceland_jack> Yes that is possible
08:32:25 <supki> qsuscs: this is usually a sign of OOM-killer
08:32:29 <bernalex> Iceland_jack: a, b & c. like. forall a b c
08:32:32 <Iceland_jack>     foo :: (Show x, Show y) => (forall a. Show a => a -> b) -> (x, y) -> (b, b)
08:32:32 <Iceland_jack>     foo f (x, y) = (f x, f y)
08:33:00 <bernalex> I mean that the function should take any a b c as long as they all inherit typeclass Foo
08:33:02 <qsuscs> supki: sounds reasonable, as i only have ~500MiB allowed per process
08:33:08 <qsuscs> supki: can I limit GHC somehow?
08:34:09 <Iceland_jack> bernalex: You can do that by making the constraint polymorphic
08:34:21 <bernalex> Iceland_jack: yes! how do you do this? :-]
08:34:36 <bernalex> Iceland_jack: it's in my brain somewhere via some GHC extension I think, but I don't recall it.
08:35:35 <Iceland_jack> So it's possible to write something like this:
08:35:36 <Iceland_jack>     foo :: (k x, k y) => (forall a. k a => a -> b) -> (x, y) -> (b, b)
08:35:41 <Iceland_jack> But it's tricky to invoke
08:35:49 <bernalex> w/o any extensions?
08:35:55 <Iceland_jack> You'll need ConstraintKinds
08:35:58 <bernalex> ah that's the one
08:36:05 <Iceland_jack> and RankN types
08:36:05 <supki> qsuscs: I'm not sure but that would be a painful experience
08:36:10 <bernalex> yeah for forall
08:37:07 <RchrdB> qsuscs: you can tune the GC to collect more aggressively, but it might not help. If there are 600MB of real data structures that need to exist for the current computation then GHC doesn't have any way of using less than 600MB to represent them...
08:37:25 <qsuscs> hrm.
08:37:32 <Iceland_jack> bernalex:
08:37:33 <Iceland_jack> ghci> (foo :: (Show x, Show y) => (∀a. Show a => a -> b) -> (x, y) -> (b, b)) show ((), 'a')
08:37:33 <Iceland_jack> ("()","'a'")
08:37:44 <RchrdB> qsuscs: making the garbage collector more aggressive about reclaiming space also commonly leads to sadness such as having the GC kick in over and over and over again when you're near the limit.
08:38:04 <davean> qsuscs: You *can* limit GHC is now much memory it WILL allocate
08:38:07 <bernalex> Iceland_jack: I'm having some trouble
08:38:09 <davean> qsuscs: it is an RTS option
08:38:26 <bernalex> f :: (k a, k b, k c) => forall a. k a => (a -> d) -> (b, c) -> (d, d) ; f w ts = (w ts, w ts)
08:38:52 <RchrdB> What davean said, though if GHC needs to allocate more than you let it with the RTS option, it'll just throw an error inside the RTS instead of getting hit by OOM.
08:38:55 <bernalex> Could not deduce (k0 a0, k0 b, k0 c, k0 a1) arising from the ambiguity check for 'f' from the context (k a, k b, k c, k a1) bound by the type signature for f :: (k a, k b, k c, k a1) => (a1 -> d) -> (b, c) -> (d, d)
08:38:59 <Iceland_jack> bernalex: it needs to be rank-2
08:39:19 <nclarke> type Bar a b c = forall (d :: Constraint). (d a, d b, d c);; foo :: Bar a b c => a -> b -> c -> ... - something like that?
08:39:22 <Iceland_jack> Since the function must be able to accept *any* type that is an instance of the class
08:39:53 <RchrdB> qsuscs: why do you have a 500MB per-process memory ulimit? I'm slightly doubtful that that would actually be limiting your total RAM use in any meaningful way unless you restrict the number of processes sharply, too.
08:40:16 <qsuscs> RchrdB: because, in this case, i’m a user on a shared hosting server, and that’s just what they enforce
08:40:30 <bernalex> Iceland_jack: I'm not sure I understand
08:40:33 <RchrdB> Per *process*? Really?
08:40:35 <Iceland_jack>     foo :: (k x, k y) => (forall a. k a => a -> b) -> (x, y) -> (b, b)
08:40:35 <Iceland_jack>     foo f (x, y) = (f x, f y)
08:40:37 <RchrdB> How weird.
08:40:38 <qsuscs> or was it per user? not sure
08:40:57 <RchrdB> Per user would be sensible; you can configure container systems like jails and LXC to do that.
08:41:08 <Iceland_jack> (forall a. k a => a -> b) means that 'f' can have type 'Int -> String' and 'Bool -> String'
08:41:13 <bernalex> Iceland_jack: hmmm
08:41:47 <RchrdB> qsuscs: "export GHCRTS=-M450M" btw
08:42:01 <Iceland_jack> bernalex: Given a extension coming soon you should be able to apply types
08:42:10 <bernalex> Iceland_jack: I'm still getting an error
08:42:12 <qsuscs> RchrdB: indeed, they write "500M per process"
08:42:15 <bernalex> Iceland_jack: both :: (k b, k c) => forall a. k a => (a -> d) -> (b, c) -> (d, d)
08:42:33 <Iceland_jack> bernalex: You need to write it like I did
08:42:41 <Iceland_jack> what you wrote is not rank-2
08:42:42 <bernalex> but it's the same, no? what am I missing?
08:42:49 <Iceland_jack> foo ∷ (ĸ x, ĸ y) ⇒ (∀a. ĸ a ⇒ a → b) → (x, y) → (b, b)
08:42:49 <Iceland_jack> foo f (x, y) = (f x, f y)
08:42:49 <qsuscs> ok, now i get this: http://pastie.org/private/jbtqpal0ljffbd1ddj5ka
08:42:57 <qsuscs> (with GHCRTS="-M480M")
08:43:05 <bernalex> Iceland_jack: oh!
08:43:09 <uberwach> How can I type the bot's @src command in ghci?
08:43:13 <bernalex> Iceland_jack: I just realised my mistake -- thanks, I'll try that.
08:43:33 <beaky> hello
08:43:44 <nclarke> bernalex: With ConstraintKinds, KindSignatures and Rank2Types you can write "type Bar a b c = forall (d :: Constraint). (d a, d b, d c)", which I think expresses the idea that a,b and c all share a common typeclass
08:43:52 <nclarke> But I'm not sure what you can do with such a thing
08:43:54 <Iceland_jack> bernalex: With a future extension you should be able to apply types:
08:43:54 <Iceland_jack>     foo       :: (k x, k y) => (forall a. k a => a -> b) -> (x, y) -> (b, b)
08:43:54 <Iceland_jack>     foo @Show :: (Show x, Show y) => (forall a. Show a => a -> b) -> (x, y) -> (b, b)
08:44:39 <Iceland_jack> nclarke: (d :: * -> Constraint)
08:44:45 <nclarke> Sorry, type Bar a b c = forall (d :: * -> Constraint). (d a, d b, d c)
08:44:52 <nclarke> What Iceland_jack said :-)
08:44:56 <lpaste> beaky pasted “avg” at http://lpaste.net/113817
08:45:06 <beaky> how do i refactor this avg function
08:45:15 <joshc> Iceland_jack: is that extension documented?
08:45:27 <Iceland_jack> But it's a bit useless since 'd' is existential
08:45:29 <joshc> or, is it still in work? (I'm curious about it)
08:45:47 <Iceland_jack> joshc: https://ghc.haskell.org/trac/ghc/wiki/ExplicitTypeApplication
08:45:55 <bernalex> Iceland_jack: f :: (k b, k c) => (forall a. k a => a -> d) => (b, c) -> (d, d)
08:45:55 <joshc> Iceland_jack: great, thanks!
08:45:57 <bernalex> Iceland_jack: ?
08:46:23 <nclarke> Iceland_jack: Yeah, but isn't that the question? If all you're expressing is that they share *a* typeclass, what could you ever do with it?
08:46:42 <Iceland_jack> nclarke: You can put constraints on them like in the foo function
08:46:44 <Iceland_jack> bernalex: yes
08:46:58 <bernalex> Iceland_jack: that still doesn't work
08:47:06 <bernalex> Expected a constraint, but ‘forall a. k a => a -> d’ has kind ‘*’
08:48:44 <Iceland_jack> bernalex: You haev an extra => there
08:48:55 <Iceland_jack>     f :: (k b, k c) => (forall a. k a => a -> d) => (b, c) -> (d, d)
08:48:55 <Iceland_jack>     -->
08:48:55 <Iceland_jack>     f :: (k b, k c) => (forall a. k a => a -> d) -> (b, c) -> (d, d)
08:49:11 <Iceland_jack> *have
08:49:33 <bernalex> oh derp
08:50:25 <bernalex> Iceland_jack: OK but then I get a brand new problem :-D
08:50:26 <Iceland_jack> nclarke: In bernalex's type signature you refer to the 'k :: * -> Constraint' in the (k b, k c) context
08:50:28 <Iceland_jack> Yay
08:50:40 <bernalex> Iceland_jack: the body is just f w ts = (w ts, w ts)
08:50:48 <Iceland_jack> (this if overkill mind you) :)
08:50:51 <Iceland_jack> *this is
08:50:54 <bernalex> Iceland_jack:  Could not deduce (k (b, c)) arising from a use of ‘w’ from the context (k b, k c)
08:51:10 <Iceland_jack> bernalex: You need to pattern match on the tuple
08:51:13 <bernalex> omg yejs
08:51:16 <Iceland_jack> :)
08:51:38 * bernalex mumbles something about forests and trees
08:51:40 <bernalex> Iceland_jack: thanks a lot!
08:52:21 <Iceland_jack> You're welcome bernalex
08:52:37 <Iceland_jack> Your mistake actually made me wonder about a different problem
08:53:18 <Iceland_jack> Being able to type:
08:53:19 <Iceland_jack>     foo f (x, y) = f (x, y)
08:53:19 <Iceland_jack> when (k x, k y) => k (x, y)
08:53:28 <bernalex> Iceland_jack: I'm wondering. how do I add arrow to this mix? lol
08:53:48 <Iceland_jack> Why do you need to add arrow?
08:54:01 <bernalex> not convinced I *need* to
08:54:06 <nclarke> Iceland_jack: I see - I was missing the (forall a. k a => a -> b) part
08:54:13 <bernalex> but for fun & becoming more comfortable with this stuff mostly
08:54:47 <Iceland_jack> Arrows and join aren't rank-2 so you can't use something like 'join (***)' to type foo/f
08:54:49 <nclarke> Which is what makes it potentially useful
08:55:01 <bernalex> Iceland_jack: that's true I guess
08:59:03 <bernalex> Iceland_jack: hmmm it does fail spectacularly though
08:59:20 <bernalex> @let both :: (k b, k c) => (forall a. k a => a -> d) -> (b, c) -> (d, d); both w (a, b) = (w a, w b)
08:59:20 <lambdabot>  Parse failed: Illegal class assertion
08:59:26 <bernalex> aw oh well
08:59:45 <Iceland_jack> That works for me :)
08:59:45 <bernalex> Iceland_jack: if you add that to your ghci, and try both show (1, 2.0) -- it will fail with a *very* long error
09:00:03 <Iceland_jack> yes, that's why I mentioned ExplicitTypeApplication
09:00:18 <bernalex> wait so uh this isn't actually usable yet?
09:00:21 <Iceland_jack> It is
09:00:42 <bernalex> how do I use it then?
09:00:46 <bernalex> Some flags have not been recognized: -XExplicitTypeApplication
09:01:07 <Iceland_jack> Currently you'd have to write
09:01:07 <Iceland_jack>     bothShow :: (Show x, Show y) => (forall a. Show a => a -> b) -> (x, y) -> (b, b)
09:01:07 <Iceland_jack>     bothShow = both
09:01:21 <bernalex> uh right
09:01:34 <bernalex> so I can't both show (1.0, 2) and have it magically work things out?
09:01:43 <Iceland_jack> or:
09:01:44 <Iceland_jack>     (both :: (Show x, Show y) => (forall a. Show a => a -> b) -> (x, y) -> (b, b)) show (1.0, 2)
09:01:57 <Iceland_jack> Since GHC can't infer rank-2 types in general
09:01:59 <bernalex> like show *** show $ (1.0, 2) works
09:02:02 <Iceland_jack> yes
09:02:18 <bernalex> what is the yes for?
09:02:21 <bernalex> oh
09:02:23 <bernalex> I see
09:02:33 <Iceland_jack> With type application you can do:
09:02:34 <Iceland_jack>     both @Show (1.0, 2)
09:02:51 <bernalex> wait so to sum up
09:03:07 <bernalex> I need my both as defined before, and then I need to implement both :: (Show x, Show y) ... -- and then I can use both magically?
09:03:42 <Iceland_jack> bernalex: You need tell GHC what "k" is
09:03:53 <bernalex> so there's no way for GHC to figure out k on its own?
09:04:01 <bernalex> i.e. to choose a k
09:04:01 <Iceland_jack> No
09:04:26 <bernalex> can I write only both :: (k b, k c) => (forall a. k a => a -> b) => (b, c) -> (d, d)
09:04:30 <bernalex> and then when using it specify k?
09:04:49 <bernalex> both show (1, 2.0) -- somehow say that k here is Show?
09:04:49 <Iceland_jack> Currently only in an ugly way
09:04:56 <bernalex> how?
09:05:03 <Iceland_jack> <Iceland_jack>     (both :: (Show x, Show y) => (forall a. Show a => a -> b) -> (x, y) -> (b, b)) show (1.0, 2)
09:05:03 <Iceland_jack>  
09:05:14 <bernalex> ah then I see
09:05:18 * hackagebot pipes-text 0.0.0.13 - Text pipes.  http://hackage.haskell.org/package/pipes-text-0.0.0.13 (MichaelThompson)
09:06:07 <Iceland_jack> When you pass arguments to 'both' GHC has the types of the function and the tuple
09:06:47 <bernalex> shouldn't (both :: Show x, Show y) => (forall a. Show a => a -> d) -> (x, y) -> (d, d)) show $ (2, 2.0) -- work?
09:07:13 <Iceland_jack> No that's a syntax error
09:07:26 <bernalex> (both :: Show x, Show y) => (forall a. Show a => a -> d) => (x, y) -> (d, d)) show $ (2, 2.0) -- ?
09:07:37 <bernalex> I mean ghci says that's a syntax error too so I guess I have something wrong lol
09:07:44 <bernalex> oh wait
09:07:44 <Iceland_jack> <Iceland_jack>     (both :: (Show x, Show y) => (forall a. Show a => a -> b) -> (x, y) -> (b, b)) show (1.0, 2)
09:07:45 <Iceland_jack>  
09:07:46 <Iceland_jack> This works
09:07:46 <bernalex> parens
09:08:05 <Iceland_jack> The tuple (x, y) doesn't tell you what "k" is, you just know that the types of x and y are instances of "k"
09:08:23 <bernalex> OK thanks
09:08:29 <Iceland_jack> If it's (Int, Float) k could be Show or Num
09:09:08 <Iceland_jack> or Eq, or Ord, or...
09:10:10 <Iceland_jack> Rank-2 types are tricky
09:11:19 <bernalex> Iceland_jack: is there work to let people uh say "use Show" in a less obnoxious manner?
09:11:35 <Iceland_jack> Yes, ExplicitTypeApplication
09:11:45 <bernalex> right. I'll look up that then.
09:11:55 <Iceland_jack> https://ghc.haskell.org/trac/ghc/wiki/ExplicitTypeApplication
09:12:06 <Iceland_jack> That should allow you to do something like:
09:12:06 <Iceland_jack>     both @Show (1.0, 2)
09:12:06 <Iceland_jack>  
09:13:19 <bernalex> Iceland_jack: OK BRB going to write that pragma. (for some value of "right". :-P)
09:13:31 <zipper> How can I pattern match on JSON Value type because the value constructors aren't clear to me. Here is my code https://gist.github.com/urbanslug/60c4e6cf82feac099d2f
09:13:33 <zipper> I am trying to turn all the "Y" and "N" in this JSON file into True and False. Here is the JSON http://www.seas.upenn.edu/~cis194/extras/06-monoid-io/markets.json
09:14:01 <zipper> How to implement ynToBool in the above.
09:14:37 <zipper> I am looking at the type Value and it has different value constructors which don't even seem to be value constructors as far as I can tell.
09:16:13 <bam365_> zipper: did you look at the ynToBool that I put in lpaste yesterday?
09:16:13 <jfischoff> what is ynToBool supposed to do?
09:16:23 <bernalex> Iceland_jack: isn't XTypeApplication enough?
09:16:44 <jfischoff> zipper: There are a few issues with the code that show confusion
09:16:45 <bernalex> oh wait
09:16:48 <zipper> jfischoff: Turn all Y and N to True and False
09:16:54 <bernalex> -XExplicitTypeApplication enables XTypeApplication apparently
09:17:01 <zipper> jfischoff: With today's code? Really?
09:17:08 <zipper> bam365_: I missed it :(
09:17:28 <zipper> jfischoff: What shows confusion?
09:17:29 <bam365_> zipper: http://lpaste.net/113767
09:17:42 <bam365_> there are some errors with that code, but they're simple
09:19:14 <jfischoff> zipper: you probably don’t want to return the value in main
09:19:28 <jfischoff> that will do want you want when interpreted but not when compiled
09:19:38 <jfischoff> Just print it out
09:19:52 <zipper> jfischoff: Yes I don't that's just for code to typecheck for the time being.
09:20:07 <chrisdone> anybody got a simple implementation of a HM type checker in haskell?
09:20:21 <zipper> jfischoff: Ignore the value that main returns for now. I just don't want to flood emacs with red error lines.
09:20:44 <zipper> Eventually it shall return IO ()
09:20:52 <jfischoff> sure
09:21:05 <monochrom> chrisdone: look for "typing haskell in haskell". it may be simple.
09:21:07 <chrisdone> one in the ST monad, for example
09:21:21 <jfischoff> So you want to switch all Bool from True to False correct?
09:21:22 <zipper> bam365_: I have some issue with your code.
09:21:56 <zipper> bam365_: For Array and Object
09:21:59 <zipper> jfischoff: yes
09:22:06 <jfischoff> and this is homework?
09:22:23 <jfischoff> HW06?
09:22:25 <chrisdone> monochrom: eh, it's all split up into a long paper, but maybe i can reconstruct it straight-forwardly
09:22:35 <bam365_> zipper: yeah, fmap ynToBool o should be Object (fmap ynToBool o)
09:22:41 <jfischoff> chrisdone: yeah you can
09:22:44 <bam365_> and the analogue for Array
09:22:53 <jfischoff> I made one from that paper
09:22:54 <zipper> jfischoff: lol it's from http://www.seas.upenn.edu/~cis194/lectures.html and I don't go to upenn
09:23:00 <jfischoff> oh okay
09:23:11 <bam365_> zipper: do you understand the spirit of that code though?
09:23:21 <chrisdone> jfischoff: do you have it? i just want to see a page or two of code
09:23:27 <monochrom> chrisdone: the HTML version http://web.cecs.pdx.edu/~mpj/thih/TypingHaskellInHaskell.html may be most friendly to extracting code (or least hostile)
09:23:36 <jfischoff> chrisdone: somewhere, I’m at work, I don’t know if it is online
09:23:38 <chrisdone> jfischoff: if it's a PITA i won't bother, just curious as i might play with it if it's simple
09:23:45 <zipper> bam365_: My issue is I don't get how Object and Array work.
09:24:03 <chrisdone> monochrom: thanks, certainly easier than pdf
09:24:05 <bernalex> Iceland_jack: hm. I don't fully get why it's not possible to infer Show in "both show (1, 2.0)". can it not merely look at thet type of show?
09:24:23 <jfischoff> chrisdone: I think the easiest way ultimately is to use something like unification-fd of ekmetts unification thingy
09:24:24 <bam365_> zipper: Objects and Arrays are "functors" in a sense, they contain multiple values, so ynToBool has to be fmapped over each of those individual values
09:24:24 <zipper> bam365_: Wait I think I have it
09:24:33 <chrisdone> i was thinking in the shower that there should be tonnes of implementations on lpaste
09:24:45 <bernalex> I mean, if I do "show 2", it understands it, why wouldn't it understand it with both show (2,2) or whatever?
09:24:51 <bernalex> Iceland_jack: ^
09:25:14 <monochrom> data mining on lpaste :)
09:25:31 <chrisdone> there're tonnes of unifiers and datalog things, why not type checkers =)
09:25:37 <monochrom> now we know why chrisdone runs lpaste :)
09:25:42 <Iceland_jack> bernalex: No because you're quantifying over every context
09:25:49 <bernalex> Iceland_jack: explain? :-]
09:26:01 <chrisdone> like this http://lpaste.net/57031
09:26:13 <zipper> bam365_: I see there's a functor instance for Array and Object but I don't see how I will fmap them in a pattern match.
09:26:14 <Iceland_jack> If you pass 'both' some function with type:
09:26:14 <Iceland_jack>     f :: (Show a, Ord a) => a -> Int
09:26:14 <Iceland_jack> does k equal Show or Ord?
09:26:20 <bernalex> that's OK
09:26:27 <chrisdone> monochrom: =3
09:26:28 <bernalex> I mean specifically in both show (2,2)
09:26:52 <bam365_> zipper: well the code I posted is very close, I just forgot to wrap it with the value constructor
09:27:12 <chrisdone> more: http://lpaste.net/41043/hindley_milner_type_inference
09:27:20 <jfischoff> zipper: I think that will work
09:27:23 <bam365_> so "fmap ynToBool o" should be "Object (fmap ynToBool o)"
09:27:34 <chrisdone> by our very own camio http://ircbrowse.net/browse/haskell/?id=10552526&timestamp=1288645762#t1288645762 =)
09:27:39 <jfischoff> yeah fmap will also work
09:28:28 <chrisdone> alright, so you can do it in a page or two of code. that's good enough
09:28:40 <zipper> bam365_: Give me a few. I have a few chores to do.
09:28:54 <zipper> bam365_: What's your timezone? I'm gmt+3
09:29:08 <bam365_> gmt-5, I think?
09:29:12 <bam365_> US central time
09:29:35 <zipper> Oh I hope you'll be around when I come back.
09:29:46 <bam365_> I probably will :)
09:29:55 <chrisdone> jfischoff: unification-fd is by wren
09:30:07 <jfischoff> chrisdone: I found one version but it is not the one I was looking. I have a clearer version at home. This was basically copied from a paper: https://github.com/jfischoff/kydo/blob/master/src/Language/Kydo/TypeInference.hs
09:30:12 <jfischoff> chrisdone: yeah
09:30:25 <jfischoff> and edward has his own version
09:30:34 <jfischoff> of the same things
09:31:34 <zipper> bam365_: Ok I have procrastinated the chore. Where was I. I see the wrapping the value constructor Object or Array working if I look at it like a Tree of sorts but...
09:31:35 <jfischoff> chrisdone: Honestly I have no idea what state that code is in, I’ll send you something later if your still looking
09:31:36 <Iceland_jack> bernalex: I'm not familiar enough with how GHC infers Rank-2 constraints to say
09:31:36 <Iceland_jack>  
09:31:53 <chrisdone> jfischoff: yep, looks pretty straight-forward
09:31:54 * zipper will go hungry trying to parse JSON
09:32:06 <chrisdone> jfischoff: if you remember, please drop me a mail, would appreciate it =)
09:32:18 <jfischoff> chrisdone: The nice thing about the typing haskell in haskell paper is it shows how easy it is to extend the algo to type classes
09:32:22 <jfischoff> chrisdone: will do
09:32:40 <chrisdone> right
09:33:07 <chrisdone> been pondering making a simple typed lisp with statically typed quotation, just for fun
09:33:28 <jfischoff> sounds cool
09:33:47 <chrisdone> e.g. '1 :: Quoted Symbol, ~1 :: Quoted Int, eval :: Quoted a -> a
09:33:48 <jfischoff> maybe hard idk
09:34:00 <simpson> chrisdone: Nice.
09:36:46 <chrisdone> bbl
09:38:21 <athan> This ones's a longshot, but... anyone know if there is a way to force HXT to _not_ mess with DTD tags? :(
09:38:31 <zipper> What does "!" mean in front of a type e.g !Bool?
09:38:53 <Iceland_jack> zipper: Strictness annotation
09:38:59 <zipper> bam365_: I think I get it but wow. This thing is minf blowing.
09:39:08 <Iceland_jack> "BangPatterns" https://www.haskell.org/ghc/docs/7.4.2/html/users_guide/bang-patterns.html
09:39:17 <zipper> Iceland_jack: So don't store a thunk. Evaluate it.
09:39:37 <zipper> Iceland_jack: How far deep does it go? e.g !Tree
09:39:48 <athan> zipper: Outermost, I believe
09:39:53 <athan> you can do deepseq though
09:39:53 <zipper> or !String on an infinite list of Chars
09:39:59 <Iceland_jack> Just a single pattern (Weak head normal form)
09:40:10 <zipper> Iceland_jack: Thanks
09:40:14 <zipper> athan: Thanks
09:40:16 <Iceland_jack> zipper: If you match against a string "hello" it only forces "_ : _"
09:40:18 <athan> ;)
09:41:41 <merijn> Iceland_jack: It's only BangPatterns in function pattern matches
09:41:56 <merijn> Iceland_jack: ! in data declarations for strictness is Haskell98/Haskell2010
09:42:37 <Iceland_jack> Yes, and the example of "!Bool" indicates that they weren't looking for bang patterns
09:43:39 <Iceland_jack> zipper: http://stackoverflow.com/questions/993112/what-does-the-exclamation-mark-mean-in-a-haskell-declaration ignore my original answer, this is a better resource
09:45:19 * hackagebot yesod-mangopay 1.9.2 - Yesod library for MangoPay API access  http://hackage.haskell.org/package/yesod-mangopay-1.9.2 (FelipeLessa)
09:45:59 <fragamus> :t map
09:45:59 <fragamus> :t fmap
09:46:01 <lambdabot> (a -> b) -> [a] -> [b]
09:46:01 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:47:01 <fragamus> why do we have both of these
09:47:53 <Iceland_jack> fragamus: Why do we have both (.) and "fmap"? :)
09:48:03 <Iceland_jack> More serious answer, historical reasons
09:48:16 <monochrom> because a committee decided this, and since it was a committee, there was much negotiation and trading.
09:48:32 <johnw> funny thing, fmap used to be map, long ago
09:48:35 <fragamus> there should have been more fighting and killing
09:49:02 <fragamus> :t (.)
09:49:04 <lambdabot> (b -> c) -> (a -> b) -> a -> c
09:49:14 <monochrom> well yeah we were unlucky to have non-violent profs as committee members.
09:50:04 <zipper> Iceland_jack: They are from --> http://hackage.haskell.org/package/aeson-0.8.0.2/docs/Data-Aeson.html#t:Value
09:50:36 <Iceland_jack> "map" can make your intentions more clear, I often give a new name to monomorphised version of some function to make it clearer
09:50:52 <fragamus> Iceland_jack: did you imply that how is it that we don't need both (.) and fmap
09:51:12 <fragamus> ugh lets try that again
09:51:15 <Iceland_jack> fragamus: "fmap" is the same thing as (.)
09:51:20 <fragamus> Iceland_jack: did you imply that we don't need both (.) and fmap
09:51:24 <Iceland_jack> "given the right instance"
09:51:27 <fragamus> :t fmap
09:51:28 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:51:34 <fragamus> :t (.)
09:51:35 <lambdabot> (b -> c) -> (a -> b) -> a -> c
09:51:45 <Iceland_jack> :t fmap :: (b -> c) -> (a -> b) -> a -> c
09:51:47 <lambdabot> (b -> c) -> (a -> b) -> a -> c
09:51:56 <merijn> :t fmap `asAppliedTo` even
09:51:58 <lambdabot> (Functor f, Integral a) => (a -> Bool) -> f a -> f Bool
09:52:02 <Iceland_jack>     times :: Int -> IO a -> IO ()
09:52:02 <Iceland_jack>     times = replicateM_
09:52:05 <success> how small can you make haskell?
09:52:16 <Iceland_jack> success: Search for "Haskell Core"
09:52:21 <monochrom> as small as a usb flash thumb drive
09:52:26 <johnw> success: System F
09:52:51 <Iceland_jack> 'times' is a simple example of giving a ‘redundant’ name for the sake of clarity
09:53:26 <silver1> Hey guys... awkward question that probably never asked, but... how much of Haskell would I need to learn in order to become proficient at configuring XMonad?
09:53:41 <qsuscs> hxt-8.5.4 failed during the building phase. The exception was: ExitFailure 1
09:53:46 <qsuscs> what could cause that?
09:54:10 <qsuscs> (i already limited the ram usage)
09:55:54 <monochrom> sssilver_: I think if you are comfortable with do-notation and record syntax you're pretty good
09:56:11 <Iceland_jack> XMonad has some pretty hair code though
09:56:35 <Iceland_jack> ghci> :t defaultConfig
09:56:35 <Iceland_jack> defaultConfig :: XConfig (Choose Tall (Choose (Mirror Tall) Full))
09:57:27 <saep> sssilver_: It entirely depends on how crazy you want to be. ;-) And you can always ask for help on #xmonad in case you're stuck.
09:57:45 <fizbin> @pl \x -> f x <|> g x
09:57:45 <lambdabot> liftM2 (<|>) f g
09:57:48 <ReinH> monochrom: To be fair, there are 1TB thumb drives now...
09:58:08 <Iceland_jack> It uses monad transformers and functional dependencies and non-standard monoid stuff and higher-rank types
10:00:20 * hackagebot Unique 0.2 - It provides the functionality like unix "uniq" utility  http://hackage.haskell.org/package/Unique-0.2 (kapral)
10:05:31 <clrnd> sssilver_, nothing at all I'd say, my workmate here to my left uses XMonad with KDE4 and doesn't know what a data type is
10:08:01 <NemesisD> conduit question: i need to do a fold over a conduit and produce a list, but all the combinators for folds create Consumers and i need a Conduit, even though its kind of cheating because its consuming all values
10:08:28 <mbuffett1> Does Haskell cache results of a pure function? I'm not sure if that makes sense, but say I call "someFunctionThatTakesALongTime x" and then later call it again with the same x, would it take the same amount of time?
10:08:59 <periodic> mbuffett1: if your expression has no free variables, e.g. all the arguments are bound to values, then it is a thunk.
10:09:09 <periodic> that thunk will get evaluated every time it is forced.
10:09:14 <periodic> er, once
10:09:14 <NemesisD> i.e. Conduit a m b, using something like [a] -> [b]
10:09:22 <sshine> mbuffett1, memoization? yes, but I can't tell you exactly when
10:09:31 <periodic> But each time you create a new one it will get forced separately.
10:09:43 <sshine> mbuffett1, actually, no. http://stackoverflow.com/questions/3951012/when-is-memoization-automatic-in-ghc-haskell
10:10:20 * hackagebot module-management 0.20.3 - Clean up module imports, split and merge modules  http://hackage.haskell.org/package/module-management-0.20.3 (DavidFox)
10:10:34 <athan> mbuffett1: Memoization, yo!
10:10:53 <mbuffett1> Okay, so if I pass a value into a function it won't memoize it?
10:10:58 <periodic> forced = evaluated to a usable value.
10:11:09 <sshine> mbuffett1, when you pass a value into a function, it won't necessarily even compute it!
10:11:24 <periodic> Right.  "foo x + foo x" would calculate "foo x" twice.
10:11:40 <periodic> "let x' = foo x in x' + x'" obviously should do it only once.
10:11:57 <mbuffett1> That seems strange, any reason it wouldn't use memoization for 'foo x + foo x'?
10:12:18 <periodic> How would it know what you want to memoize and what you don't?
10:12:20 <Iceland_jack> mbuffett1: The compiler *may* perform that optimization, but it's not always beneficial
10:12:31 <periodic> It's a space/time tradeoff.
10:12:31 <bitonic> so, I do I work around this wonderful bug: <https://ghc.haskell.org/trac/ghc/ticket/9583>?
10:12:37 <periodic> memoization isn't entirely free.
10:12:41 <sssilver_> clrnd: So I sat down yesterday to try and configure my XMonad, and was basically forced to write the following https://bpaste.net/show/ef59f5da77b4
10:12:52 <sssilver_> please don't hit me too harshly
10:12:59 <bitonic> is there something that prevents GHC from specializing?
10:13:11 <mbuffett1> Oh okay, thanks for the answers guys
10:13:28 <sssilver_> but I feel like perhaps configuring a WM shouldn't get to that point >.<
10:13:40 <bitonic> is there some pragma
10:13:43 <pyrtsa> Is there (does anybody have) a ghci command that would dig out and print the source code for a given function if available?
10:15:16 <clrnd> sssilver_, well, it's always about what you need to accomplish, GNOME2 configuration doesn't allow you to spawn child processes anyway
10:16:15 <clrnd> :P
10:16:44 <clrnd> and that's a pretty nifty config
10:19:48 <vermeille> What do you do when you want to `read` something not guaranteed to be a valid string? I can't find anything returning a Mybe or something (context: parsing Happstack query params)
10:20:21 <Iceland_jack> :t Text.Read.readMaybe
10:20:23 <lambdabot> Read a => String -> Maybe a
10:21:02 <vermeille> Iceland_jack: ok thaks. Hoogle never gave me that result.
10:21:20 <vermeille> https://www.haskell.org/hoogle/?hoogle=Read+a+%3D%3E+String+-%3E+Maybe+a
10:21:47 <Iceland_jack> Yeah, Hoogle doesn't index everything
10:22:46 <vermeille> So, where's the best place to search?
10:23:46 <Cale> vermeille: see also "reads"
10:24:11 <Cale> > reads "232apple" :: [(Integer, String)]
10:24:12 <lambdabot>  [(232,"apple")]
10:24:17 <Cale> > reads "232" :: [(Integer, String)]
10:24:19 <lambdabot>  [(232,"")]
10:24:23 <Cale> > reads "x232" :: [(Integer, String)]
10:24:25 <lambdabot>  []
10:24:34 <vermeille> Hum, that's less interesting for my use case. thanks ::)
10:25:21 <y> > let readMaybe' (reads → [(x,_)]) = Just x; readMaybe' _ = Nothing in readMaybe' "123" ∷ Int
10:25:23 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
10:25:23 <lambdabot>              with actual type ‘Data.Maybe.Maybe a0’
10:25:34 <y> > let readMaybe' (reads → [(x,_)]) = Just x; readMaybe' _ = Nothing in readMaybe' "123" ∷ Maybe Int
10:25:36 <lambdabot>  Just 123
10:25:38 <Cale> That's in the Prelude and can tell you whether the parse failed (you get an empty list), or the ways in which it succeeded (usually in a unique way, at least with ordinary instances of Read), along with trailing string fragments
10:25:39 <y> \o/
10:26:01 <Fuco> do I need to free TVars?
10:26:09 <Cale> You can match against ((x,[]):_) to tell if your parse was completely successful
10:26:39 <Cale> Fuco: free?
10:26:55 <Fuco> well, when I newTVarIO ... do I need to freeTVar when I don't need it anymore?
10:27:01 <Fuco> as I understand it it's kind of a pointer
10:27:15 <Fuco> and I can't find any "freeTVar" or similar
10:27:30 <Cale> Oh, no, there's no need for that
10:27:38 <Cale> It's garbage collected like anything else.
10:27:46 <Fuco> awesome
10:32:00 <vermeille> :t [a] -> (a -> b) -> [b]
10:32:01 <lambdabot> parse error on input ‘->’
10:32:31 <vermeille> @search [a] -> (a -> b) -> [b]
10:32:32 <lambdabot> Unknown command, try @list
10:32:41 <Iceland_jack> :t flip map
10:32:42 <lambdabot> [a] -> (a -> b) -> [b]
10:33:52 <phaazon> vermeille: @hoogle
10:34:00 <phaazon> @hoogle [a] -> (a -> b) -> [b]
10:34:01 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
10:34:01 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
10:34:01 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
10:34:16 <phaazon> and in your case:
10:34:27 <phaazon> it’s flip map, yeah
10:34:55 <phaazon> :t for
10:34:57 <lambdabot>     Not in scope: ‘for’
10:34:57 <lambdabot>     Perhaps you meant one of these:
10:34:57 <lambdabot>       ‘T.for’ (imported from Data.Traversable),
10:35:02 <phaazon> :t T.for
10:35:03 <lambdabot> (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
10:35:30 <joe9> Can I add my custom (pause) monad to MonadCont by defining callCC? or, is it not that simple?
10:35:36 <phaazon> > _ + 3 :: Int
10:35:38 <lambdabot>  Found hole ‘_’ with type: GHC.Types.Int
10:35:41 <phaazon> oh nice
10:35:44 <phaazon> lambdabot has holes
10:36:14 <joe9> I understand how callCC works but am not sure how to explain the type definition. Could anyone please try to explain it? callCC :: MonadCont m => ((a -> m b) -> m a) -> m a
10:36:47 <phaazon> joe9: I tried to understand continuations
10:36:59 <phaazon> I understant the idea, but I’ve never used them
10:38:01 <vanila> joe9,  consider "callCC f :: m a" The function  f :: (a -> m b) -> m a  takes the current continuation respresented as a -> m b, to produce an m a - and callCC is what proves that continuation to f and makes an action of all that
10:38:05 <joe9> phaazon: check out https://www.fpcomplete.com/user/jwiegley/understanding-continuations
10:38:42 <phaazon> oh
10:38:49 <phaazon> is there a way to have a blog on fpcomplete ?
10:39:08 <joe9> vanila: can I define callCC for any monad?
10:39:21 <joe9> vanila: something not a Cont monad?
10:39:27 <vanila> no you can't have to for any monad
10:39:44 <vanila> but you can implement any monad in terms of cont
10:40:10 <vanila> basically cont is the ultimate monad
10:40:48 <joe9> vanila, Why not just have it as ContT or Cont instead of MonadCont typeclass?
10:43:25 <clrnd> Cont: The Ultimate Monad, more monad than any monad
10:44:00 <clrnd> and what's the ultimate applicative?
10:50:13 <tomejaguar> Is there some preferred package to use for non-empty lists?
10:50:49 <joe9> vanila: Have you tried eff-lang? I did not like the ";;" at the end.
10:51:00 <joe9> and, it is still too young.
10:51:46 <vanila> it's research
10:51:56 <vanila> i've used it a bit, I think it's fantastic
10:52:16 <joe9> mind sharing your sample code, please? vanila?
10:52:50 <vanila> there's a lot of sample code in the tutorial i linked and the repo - I think they are better than my attempts :p
10:55:27 <joe9> vanila: the syntax that I tried felt more verbose than haskell/idris to me. It seemed more of a step-down. I am not questioning effects, just the syntax.
10:55:52 <vanila> yeah syntax isnt important
10:56:03 <vanila> ujst the ideas behind it
10:57:55 <cojy> joe9: why not do it in Idris then?
10:58:08 <cojy> it has an effect system similar enough
10:58:18 <joe9> cojy: yes, I like the effects of Idris.
10:58:36 <joe9> I personally think it is a step-up from the transformers.
10:58:38 <cojy> you can easily implement the examples from the paper in idris
10:59:16 <joe9> cojy: that is a good idea. I should try that. I inferred that Idris effects is a subset of eff-lang effects.
10:59:49 <merijn> I think transformers and effects are orthogonal
11:00:10 <merijn> i.e. transformers are still useful in a language with effects
11:01:04 <NemesisD> anyone use conduits here?
11:04:02 <joe9> on a different note, What is the use of the MonadCont typeclass? Other monads (reader, writer..) do not have associated typeclasses?
11:04:12 <mauke> yes, they do
11:04:17 <mauke> :t get
11:04:18 <lambdabot> MonadState s m => m s
11:04:22 <mauke> :t ask
11:04:23 <lambdabot> MonadReader r m => m r
11:05:22 * hackagebot generic-aeson 0.2.0.2 - Derivation of Aeson instances using GHC generics.  http://hackage.haskell.org/package/generic-aeson-0.2.0.2 (AdamBergmark)
11:05:24 * hackagebot json-schema 0.7.1.1 - Types and type classes for defining JSON schemas.  http://hackage.haskell.org/package/json-schema-0.7.1.1 (AdamBergmark)
11:05:31 <joe9> mauke: thanks for clarifying that. I understand how the monad or monad transformer is used. What is the need for the associated typeclass such as MonadState, MonadReader, etc.
11:05:47 <NemesisD> i'm trying to figure out if there's a way to convert a conduit consumer into a conduit
11:06:39 <mauke> joe9: being able to use e.g. 'put' directly in ContT State without having to 'lift' inner operations explicitly
11:06:59 <joe9> oh, ok.
11:07:05 <joe9> mauke. thanks.
11:07:37 <mauke> or lift (lift (put 42)) in FooT BarT State
11:07:39 <joe9> mauke: so, the MonadState instance is created for (ContT State), correct?
11:08:17 <mauke> yes
11:08:19 <mauke> http://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Cont.html#v:ContT
11:14:17 <joe9> mauke: quick question, If I want callCC functionality in this monad, I would have to rewrite this monad to use continuations, correct?
11:14:31 <joe9> http://codepad.org/gKxsAg6q   mauke.
11:16:06 <mauke> I've never used callCC, but can't you just use ContT?
11:16:42 <joe9> mauke: ok, thanks.
11:21:10 <zipper> Is there another way to produce a value Either String Value when parsing JSON except the one in this function parseData https://gist.github.com/urbanslug/60c4e6cf82feac099d2f
11:21:21 <zipper> a type not a value
11:25:04 <bam365_> zipper: well, it's frustrating because the function that you want, fromJSON, returns a Result a, not an Either String a
11:25:50 <bam365_> so you can either return a Result a, or you can transform Result a to Either String a yourself
11:26:36 <clrnd> omg parallelism is so nasty in python :(
11:27:33 <simpson> clrnd: Parallelism is nearly always nasty, since so few systems are designed for it.
11:27:56 <clrnd> I'd say haskell's is quite nice ...
11:28:26 <simpson> Hm. Do you mean parallel strategies, Cloud Haskell, the async package, ...?
11:28:52 <simpson> That's the same problem as Python: Many options, some of which are unambiguously bad, some of which are non-obvious in their utility.
11:29:15 <simpson> I think that Erlang got it right but that nearly nobody uses Erlang.
11:29:41 <zipper> bam365_: Have you seen my solution?
11:29:59 <bam365_> zipper: yes
11:30:23 * hackagebot hasql-postgres 0.1.2 - A "PostgreSQL" backend for the "hasql" library  http://hackage.haskell.org/package/hasql-postgres-0.1.2 (NikitaVolkov)
11:30:24 <bam365_> zipper: you don't want to re-encode and then re-decode, which is what you're doing in that parseJSON, right?
11:30:27 <monochrom> parallel strategies, Cloud Haskell, and the async package are not 3 options for the same thing. they are each one option for their respective own things.
11:30:34 <zipper> bam365_: It does return Either String a but in a very hacky and way.
11:30:54 <zipper> bam365_: I don't really know. The question didn't forbid it.
11:30:54 <monochrom> it would be similar to saying "cars, usb, and loudspeakers are 3 options"
11:31:16 <zipper> bam365_: http://www.seas.upenn.edu/~cis194/hw/06-monoid-io.pdf exercise 3
11:31:30 <simpson> monochrom: Yes, they are three options for electronics. :3
11:31:32 <zipper> exercise 2 of that.
11:31:49 <zipper> bam365_: I wrote 3 by mistake.
11:33:42 <bam365_> zipper: in your case, using the Monad instance of Either would be really helpful
11:34:20 <zipper> bam365_: Could you show me how to do that. I have gone as far as applicative functors and monoids
11:34:51 <bam365_> zipper: oh, Applicative might make more sense in this case anyway...
11:35:23 <zipper> bam365_: I don't see how I can handle the error if it occurs or not.
11:35:24 <orbital> "hoogle --color" not producing color is a small but extremely annoying thing. Where does one start digging?
11:35:44 <zipper> I would however like to play more with applicatives
11:35:51 <zipper> bam365_: I would however like to play more with applicatives
11:36:14 <sm> orbital: you could debug hoogle, eg by adding a few trace statements
11:36:29 <JonReed> Hi haskellers. Is "forall" even needed in the following case or it can be omitted? Are those two statements mean/do the same thing? "type Lens' s a = forall f. Functor f => (a -> f a) -> s -> f s" and "type Lens' s a = Functor f => (a -> f a) -> s -> f s"
11:36:31 <kadoban> orbital: I assume other command line tools consistently use color, right?
11:36:37 <bam365_> zipper: yeah, give me a sec to try this
11:36:37 <orbital> kadoban: yes
11:36:48 <Iceland_jack> JonReed: It's needed
11:37:00 <Iceland_jack> Since "f" doesn't appear as an argument to Lens'
11:37:05 <orbital> kadoban: and hoogle produces the monochrome versions of the colors, with brights and bolds
11:37:56 <orbital> sm: not a bad idea
11:38:16 <Fuco> I got a warning "A do-notation statement discarded a result of type IO ()."  ... would it ever be useful to "get" the result ()? :O
11:38:49 <bam365_> zipper: eitherDecode returns an Either String Value in your case
11:39:40 <bam365_> zipper: since Either is an applicative, you could use liftA to compose your pure ynToBool function with eitherDecode
11:40:17 <kadoban> Fuco: I'm not sure, but I don't think that's what it's warning you about.
11:40:29 <sm> orbital: or (maybe) by trying out bits of it in ghci
11:40:31 <Cale> Fuco: It means you executed something of type IO (IO ())
11:40:37 <kadoban> Fuco: It probably means you have a... IO (IO ()) and you're discarding that.
11:40:39 <Cale> Fuco: and discarded the result of type IO ()
11:40:43 <Fuco> aha
11:41:36 <Fuco> right, I did "action `liftM` foo" whre it should be "foo >>= action"
11:41:54 <bam365_> zipper: alternatively, you could use pure to wrap your ynToBool function, and then apply it to the return value of eitherDecode with <*>
11:41:57 <arianvp_> Hey
11:42:54 <arianvp_> I need to convince myself that `map (f x:) (map (map f) (subs xs))`  equals `map (map f) (map (x:) (subs xs))
11:42:58 <arianvp_> for a proof
11:43:02 <arianvp_> but I kinda get stuck
11:43:17 <clrnd> simpson, I mean everythin, haskell options are all good, that's why it's difficult to choose
11:43:24 <arianvp_> subs (x:xs) = subs  ++ map (x:) (subs xs)  by the way
11:43:26 <clrnd> python's are all bad, hence the same issue
11:43:42 <simpson> clrnd: There are some wonderful Python options that nobody uses. But let's talk Haskell. What are you thinking of building?
11:43:47 <clrnd> using threading and Queues I just broke the interpreter 5 times
11:44:10 <clrnd> simpson, oh it's a simple test, I need to throw a million request to my server
11:44:17 <clrnd> ofc, many in parallel
11:45:11 <simpson> Ah, so you want concurrent I/O. The forkIO option isn't a bad place to start, then.
11:45:23 <edwardk> JonReed: only on versions of the compiler that permit the latter. otherwise 'f' isn't well scoped and it should complain
11:45:48 <clrnd> simpson, I already have it with forkIO and TVars :P
11:45:59 <simpson> clrnd: Sounds like you're set!
11:46:33 <clrnd> it's just that I need to translate it into python ... because this particular boss is not fond of anything not Bash or Python
11:46:56 <simpson> Oh. The best option is Twisted. You'll probably want to ask your particular boss what he wants you to do, though.
11:47:11 <clrnd> I'm really thinking of using this excersise as an example of WHY I'm using haskell
11:47:16 <JonReed> edwardk: So if it compiles, then it means the same thing?
11:47:35 <edwardk> JonReed: yes. what version of ghc are you on though?
11:47:56 <JonReed> edwardk: 7.8.3
11:48:58 <edwardk> it won't work without the quantifier on all versions, so be careful
11:50:43 <JonReed> edwardk: Ok. Thx
11:53:06 <vermeille> what means the error "Constraint is no smaller than the instance head" when I write `instance ToJSON a => ToMessage a where`? (ToMessage is from Happstack and ToJSON from Aeson)
11:54:56 <Iceland_jack> vermeille: Have you tried searching for the error message?
11:55:22 <vermeille> Iceland_jack: yes, I don't really understand
11:55:40 <int-e> vermeille: if you count the type variables (including duplicates, in general) in "ToJSON a" (that's the instance head), you get 1, the same as the number of type variables in "ToMessage a".
11:55:50 <int-e> huh
11:56:09 <vermeille> int-e: well okay, and how do I solve it?
11:56:35 <mauke> vermeille: this is one of the checks to protect against infinite loops in instance resolution
11:56:50 <mauke> enabling undecidable instances would "solve" it
11:57:08 <vermeille> I read it's "bad" to use this flag
11:57:10 <mauke> except it probably wouldn't
11:57:19 <int-e> vermeille: This is a constraint that ensures that type checking terminates. It can be disabled by enabling the UndecidableInstances extension, {-# LANGUAGE UndecidableInstances #-}, which has the disadvantage that type checking may not terminate if one is careless.
11:57:25 <mauke> because that instance would overlap with every other ToMessage instance
11:57:57 <int-e> vermeille: It's not a bad flag, it does not threaten the soundness of the type system in any way. If the program compiles, it'll be fine.
11:58:05 <mauke> so basically, this is fine if you only have one ToMessage instance ever
11:58:19 <mauke> (if you don't, you'll get another error)
11:58:27 <vermeille> mauke: Happstack already defines many instances
11:59:01 <orbital> sm: in ghci it's doing the right thing. It's almost like the executable is being confused about the proper termcap, or something.
11:59:34 <vermeille> So what's the best way to write a ToMessage instance for any `ToJSON`able type?
12:00:02 <mauke> you can't do it directly
12:00:04 <vermeille> Ooooooooh no, there's no, there would be "collisions", riiiight.
12:01:33 <mauke> newtype X a = X a; instance (ToJSON a) => ToMessage (X a) where ...
12:02:32 <vermeille> thanks !
12:11:04 <suiojgsriojg> is there another way to write 'map foo . map bar . map baz [someList]'?
12:11:49 <y> if you mean (map foo . map bar . map baz) list, then it is the same as map (foo . bar . baz)
12:12:01 <orbital> suiojgsriojg: map (foo . bar . baz) ?
12:12:22 <y> > map (+2) . map (*3) $ [1,2,3]
12:12:25 <lambdabot>  [5,8,11]
12:12:28 <y> > map ((+2) . (*3)) $ [1,2,3]
12:12:30 <lambdabot>  [5,8,11]
12:12:56 <xandaros> the latter should be more efficient, too, shouldn't it?
12:13:33 <suiojgsriojg> thank you
12:13:50 <y> list fusion probably takes care of it with optimizations enabled, I guess :P
12:13:51 <orbital> xandaros: i would think they are the same
12:14:18 <orbital> but that's just intuition
12:15:19 <orbital> because of laziness
12:16:40 <__monty__> Does '<=<' (monadic function composition) have a name? (Like '>>=' is bind.)
12:16:46 <Iceland_jack> __monty__: Fish operator
12:16:54 <nh2> "left fish"
12:19:06 <__monty__> nh2: Is there a right fish?
12:19:25 <JonReed> :t (>=>)
12:19:27 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
12:19:30 <johnw> others call it "Kleisli composition"
12:19:56 <dmj`> :t (<=<)
12:19:57 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
12:20:50 <__monty__> Iceland_j, nh2, JonReed and johnw: Thank you. I really miss the names of operators in lYAH, that simple addition would make it a lot more 'comfortable' to read.
12:31:05 <nh2> __monty__: most people don't think about "fish" when reading it, this is only when you read some code out loud to a coworker
12:33:09 <adamse> is there an analogue to foldM as forM is to mapM?
12:33:18 <adamse> (ie with the monadic action last)
12:33:55 <albeit> :t foldM
12:33:57 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
12:34:49 <__monty__> nh2: I wouldn't read it as fish, if I think it to myself I'd use after but as you say it's nice to know for verbal communication.
12:35:26 * hackagebot hasql-postgres 0.1.3 - A "PostgreSQL" backend for the "hasql" library  http://hackage.haskell.org/package/hasql-postgres-0.1.3 (NikitaVolkov)
13:04:40 <zomg> lol, bitemyapp arguing with Zed Shaw on twitter.. good times =)
13:12:42 <arianvp_> I need to prove that :  map (f x:) (map (map f) [xs]) == map (map f) (map (x:) [xs])
13:12:50 <arianvp_> but im kind of stuk
13:13:57 <mauke> that looks like a complicatified version of f x : map f xs == map f (x : xs)
13:16:07 <xandaros> You can probably start by simplifying it. Like "map (x:) [xs]" is just x:xs
13:16:24 <mauke> it's [x : xs]
13:16:27 <zomg> oh god this is getting better and better
13:16:38 <zomg> now they're both RT'ing their followers comments defending their arguments
13:16:43 <zomg> and they are all so similar
13:16:44 <zomg> lol
13:16:47 <xandaros> mauke: true, sorry
13:18:52 <sbrg> zomg: link?
13:19:02 <sbrg> nevermind
13:20:16 <zomg> yeah zed's account is hidden, won't be able to see his comments sadly... I was following him before he made his account hidden so I get to enjoy both sides =)
13:20:17 <torpet> can i create [[5],[6]] to [5,6]?
13:20:21 <torpet> what function would i use?
13:20:36 <sbrg> i see. zomg: what is zed saying?
13:20:44 <sbrg> because I can glean some of the info from bitemyapp's side
13:20:52 <mauke> torpet: map head, map last, concat
13:21:04 <torpet> what if the list is longer?
13:21:07 <zomg> sbrg: pretty much the same things.. it's like it's the same person talking on both accounts :p
13:21:10 <mauke> torpet: const [5,6]
13:21:55 <zomg> sbrg: I saw where it started from, a slightly snarky comment from Zed and then an equally snarky response dismissing his question entirely
13:22:17 <zomg> then they both basically just kept throwing shit at each other :D
13:23:05 <sbrg> zomg: snarky comment about what?
13:23:47 <zomg> from Zed's comment on "Learning Haskell *should*..." https://pbs.twimg.com/media/B1tPLfuCMAEAX7v.png
13:23:56 <zomg> (this screenshot was posted by him)
13:24:09 <orbital> torpet: join
13:25:52 <sinelaw> let's all get offended by random internet people
13:26:05 * indiagreen is offended by sinelaw
13:26:24 * sinelaw is offended by sinelaw
13:26:43 <orbital> sinelaw: that was not very random
13:26:49 * indiagreen offends orbital
13:26:54 <silver> zed's dead baby. zed's dead
13:26:56 * orbital is offended
13:27:20 <joe9> johnw: you around?
13:30:38 <joe9> quick question on structuring monads: I have the need for callCC for one purpose (basically, one function). I use a pause monad for the rest http://stackoverflow.com/questions/10236953/the-pause-monad . Should I have ContT r Pause a or PauseT r Cont a? With the second approach, I avoid having to use a lift for all pause functions, correct?
13:32:23 <zomg> To my surprise it seems Zed is taking this much better
13:32:35 <zomg> He's not the one bragging about how he's blocking all these people :p
13:33:48 <sinelaw> what's all this about, anyway
13:34:19 <zomg> This started it, it doesn't seem to be about anything after that other than them raging at each other https://pbs.twimg.com/media/B1tPLfuCMAEAX7v.png
13:34:26 <chrisdone> both bitemyapp and zed thrive in internet drama/conflict
13:34:51 <clrnd> zomg, it started with bitemyapp tweeting to zed? that's weird
13:35:04 <zomg> clrnd: nono the 2nd tweet
13:35:09 <zomg> in that
13:35:27 <clrnd> lol my screen has shitty contrast, didn't see the light-white on light-grey division
13:35:38 <zomg> frankly I tend to side with Zed on this, that was a BS response even if Zed's comment was a bit snarky
13:35:42 <vanila> I think that bitemyapp runs a search for "haskell" on twitter and jumpsin to argue with everyone that mentions it
13:35:49 <zomg> but it got out of hand pretty fast from both of them :D
13:35:57 <sinelaw> haskell sucks! shitheads.
13:36:07 <vanila> people have said things like just mention haskell and "A wild condescender appears"
13:36:17 <zomg> yeah, he linked a wiki article about reign of terror, even though he's the one terrorizing anyone
13:36:33 <zomg> I wanted to comment on this to him on twitter but I don't want to get rage-blocked =)
13:36:59 <silver> zomg, http://instantsite.ru/gallery/image.php?mode=medium&album_id=17&image_id=564
13:37:13 <zomg> haha
13:37:19 <zomg> pretty much
13:37:30 <zomg> I see Zed doing this from time to time but at least he's funny =)
13:38:13 <chrisdone> i once had a pleasant exchange with zed shaw, but it took effort to break any egg shells
13:38:22 <vanila> overall it's really unwanted and just gives haskell programmers a terrible name/image
13:38:23 <chrisdone> some people are just contentious by nature
13:38:36 <zomg> vanila: yeah my thoughts exactly :P
13:39:38 <mekeor> hello, my friends. why does this parsec-snippet not work?:
13:39:40 <lpaste> mekeor pasted “i never got parsec working in my life” at http://lpaste.net/113831
13:40:23 <sinelaw> nice paste title
13:40:47 <lpaste> mekeor annotated “i never got parsec working in my life” with “i never got parsec working in my life (annotation)” at http://lpaste.net/113831#a113832
13:41:18 <mekeor> i added the error message.
13:42:14 <sinelaw> mekeor, i don't know parsec but apparently commaSep is expecting a value, but integer is a function.
13:42:32 <mekeor> sinelaw: exactly. :(
13:42:35 <mauke> integer looks like a record accessor or something
13:42:36 <chrisdone> commaSep takes two arguments
13:43:01 <mekeor> chrisdone: and the first one is not a function, right?
13:43:16 <mekeor> i guess i have the wrong integer-function or so.
13:43:31 <mauke> mekeor: what's the right one?
13:43:32 <chrisdone> GenTokenParser s u m -> ParsecT s u m a -> ParsecT s u m [a]
13:43:46 <chrisdone> i expect commaSep is not the API you want to be using
13:43:55 <mekeor> integer :: GenTokenParser s u m -> ParsecT s u m Integer
13:44:43 <chrisdone> Text.Parsec.Token is for defining your own token parser
13:45:28 * hackagebot process-streaming 0.6.2.2 - Streaming interface to system processes.  http://hackage.haskell.org/package/process-streaming-0.6.2.2 (DanielDiazCarrete)
13:45:39 <chrisdone> these are for a stream of chars http://hackage.haskell.org/package/parsec-3.0.0/docs/Text-Parsec-Char.html
13:46:02 <kadoban> mekeor: What is it you're trying to parse?
13:46:18 <chrisdone> and these are combinators http://hackage.haskell.org/package/parsec-3.0.0/docs/Text-Parsec-Combinator.html
13:46:22 <mekeor> kadoban: i want to parse a String.
13:46:45 <chrisdone> so i'd use: many1 digit `sepBy` (symbol ",")
13:46:48 <chrisdone> or something similar
13:47:18 <mekeor> chrisdone: the weird thing is that the example given at the documentation of the function "parse" on http://hackage.haskell.org/package/parsec-3.1.7/docs/Text-Parsec.html doesn't work, too. because of the same issue.
13:48:22 <chrisdone> mekeor: it's probably easier to just use attoparsec and parse from text
13:48:47 <lpaste> mekeor annotated “i never got parsec working in my life” with “i never got parsec working in my life (annotation)” at http://lpaste.net/113831#a113833
13:49:51 <chrisdone> hang about, i'll paste you an attoparsec example. it's much easier
13:49:57 <mekeor> chrisdone: i want to parse a text-file which is meant as a configuration. AFAIK, parsec is better for giving error messages, isn't it?
13:50:30 <chrisdone> mekeor: it's alright
13:50:39 <mekeor> i dunno.... :(
13:50:46 <mekeor> okay.
13:54:12 <chrisdone> i've no idea why parsec doesn't just export an integer parser without having to construct a PITA token parser
13:54:42 <chrisdone> the classic is: read <$> many1 digit, but that's code smell imo
13:55:09 <mekeor> hmm.
13:55:42 <mekeor> chrisdone: so attoparsec is simpler?
13:57:22 <mekeor> i think, i'm gonna use attoparsec. #fuckparsec O:]
13:57:47 <EvanR> theres a package with the missing obvious parsers for parsec
13:58:02 <EvanR> but attoparsec rox
13:58:04 <kadoban> I've never found attoparsec to be any easier than parsec...they seemed pretty much the same difficulty to me.
13:58:47 <chrisdone> {-# LANGUAGE OverloadedStrings #-}
13:58:47 <chrisdone> import Data.Attoparsec.Text
13:58:47 <chrisdone> main = print (parseOnly (sepBy decimal (string ",")) "123,23,4")
13:58:52 <chrisdone> λ> main
13:58:52 <chrisdone> Right [123,23,4]
13:58:58 <chrisdone> done
13:59:03 <EvanR> the default consume on failure policy made more sense to me in attoparsec
13:59:47 <mekeor> chrisdone: thank you. :)
14:02:16 <chrisdone> mekeor: welcome. use Data.Text.IO.readFile to read text from a file
14:02:40 <mekeor> sure ;)
14:03:45 <mbuffett1> I'm trying to make a Go game in Haskell, and as part of that I have to find out where all the "strings" are on the board (groups of pieces connected by adjacent squares). I thought I could do a recursive function that checks for adjacent pieces, then runs itself on those pieces until it can't find any more, but then it's an infinite loop because piece A will see piece B is beside it and then piece B wil
14:03:51 <mbuffett1> l see piece A is beside it. Anyone have an idea of how to do this?
14:04:16 <EvanR> to traverse graphs you gotta remember where you been already
14:04:35 <mbuffett1> So pass a second argument to the function that contains the pieces already found?
14:04:44 <EvanR> could work
14:04:57 <mbuffett1> Sounds good, I'll try it
14:05:12 <jxv> mbuffetl, I used bytestrings
14:05:19 <mbuffett1> bytestrings?
14:05:23 <mbuffett1> What's that?
14:05:55 <jxv> Itś a dynamic buffer of byte
14:06:02 <jxv> github.com/jxv/go
14:06:18 <jxv> bytes*
14:06:37 <EvanR> in haskell, bytestrings are not a dynamic buffer of bytes
14:06:49 <EvanR> they cant really be modified
14:08:10 <EvanR> mbuffett1: passing around a set of seen locations is probably easier than trying to encode this information in bits somehow
14:08:32 <EvanR> alternatively you can do the algorithm in the context of a state that you update as you go
14:08:50 <mbuffett1> Sorry, could you explain that alternative a bit more?
14:09:57 <EvanR> if your state was the set of positions seen, then as you go you would add things to this set
14:10:10 <chrisdone> you could be evil and use loeb =p
14:10:13 <EvanR> im not sure if it would make it easier to write the algorithm or not
14:11:39 <JonReed> How can I match between two strings with parsec/attoparsec?
14:12:14 <EvanR> string "(" >> something >> string ")"
14:12:53 <chrisdone> :t Text.Parsec.between
14:12:54 <lambdabot> Text.Parsec.Prim.Stream s m t => Text.Parsec.Prim.ParsecT s u m open -> Text.Parsec.Prim.ParsecT s u m close -> Text.Parsec.Prim.ParsecT s u m a -> Text.Parsec.Prim.ParsecT s u m a
14:13:11 <EvanR> thought there was something like that ;)
14:13:46 <EvanR> Parser open -> Parser close -> Parser a -> Parser a
14:14:55 <johnw> joe9: I'm here
14:15:19 <JonReed> EvanR: thx
14:20:08 <torpet> i need to divide a number recursively by 200,100,50 and so on
14:20:19 <torpet> i know i need to use quotRem
14:22:33 <EvanR> torpet: maybe fold over (quotient so far, divisor so far)
14:23:12 <EvanR> ah nvm
14:23:23 <EvanR> unfoldr over that
14:23:29 <EvanR> ah
14:23:44 <EvanR> write a general recursive function ;)
14:23:47 <albeit> :t unfoldr
14:23:48 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
14:24:40 <EvanR> fold and unfold deal with lists
14:24:51 <torpet> :t unfoldr
14:24:53 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
14:26:20 <monochrom> it is completely unclear to me what the question means. for one, is it to recurse over the quotient or over the remainder? for another, what is the terminating condition? and most importantly, what should the function return eventually? is it ()?
14:30:14 <HugoDaniel> is there any implementation of the "read" syscall in haskell ?
14:30:34 <albeit> HugoDaniel: "read"ing what?
14:30:43 <HugoDaniel> a filedescriptor
14:30:46 <HugoDaniel> fd
14:30:53 <HugoDaniel> as in man -s2 read
14:31:01 <JonReed> In parsec, when I use this between function "let betw = between (string "(") anyChar (string ")"), it throws an error saying that "unexpected "t", expecting "(". http://lpaste.net/113834     I want to match text between two other strings. E.g. "some random text and (the only value I want to extract) and ending noise" should extract "the only value I want to extract"
14:31:08 <t7> posix thing? HugoDaniel
14:31:13 <t7> there is a posix lib
14:31:17 <albeit> :t fdRead
14:31:18 <lambdabot> Not in scope: ‘fdRead’
14:31:27 <albeit> HugoDaniel: Well, System.Posix.IO looks like it has it
14:32:15 <HugoDaniel> cool
14:32:22 <HugoDaniel> any way to do scatter/gather in haskell ?
14:32:31 <HugoDaniel> as in man -s2 readv
14:33:16 <simpson> HugoDaniel: What are you looking to build?
14:33:21 <monochrom> that one I haven't seen
14:33:34 <orbital> chrisdone: is it ok to ask a haskell-mode question?
14:33:48 <albeit> That same package has a fdReadvBuf, but for XPG4.2
14:34:29 <JonReed> Is there any eas way to extract a string between two other strings? "random next (value to extract) ending" I found this example in parsec, but it's too confusing. https://www.haskell.org/pipermail/haskell-cafe/2011-September/095275.html
14:34:33 <torpet> Not sure if unfoldr does what i want, so basically given this snippet: http://lpaste.net/4422906082460958720
14:34:59 <torpet> it'S fine, except i want to make the divisor=divisor/2
14:35:01 <torpet> is that possible?
14:35:32 <HugoDaniel> cool thanks
14:35:33 <monochrom> is 200 the current divisor?
14:36:08 <JonReed> With regex I could do (?<=\()(.*)(?=\)) or (?<=Before(.*)(?=After). How would I do it with parsec, attoparsec?
14:36:09 <monochrom> do you want to say "let b = quotRem (abs n) 200 in b + minNumOfCoins a"?
14:36:13 <torpet> 200 is the firist divisor
14:36:21 <torpet> the next one would be 100, 50, 20, 10, 2, 1
14:36:36 <monochrom> wait a second, 10/2 = 2?
14:36:46 <albeit> Are the divisors pre-specified?
14:36:57 <torpet> yes they are, i amended my statement above.
14:37:10 <hpc> monochrom: what, you don't use base 4?
14:37:37 <monochrom> you write a helper function and recurse there.
14:37:55 <t7> hpc: or working modulo 4
14:39:31 <juanpablo_> Is there a good reason why Value from Aeson isn't a functor?
14:40:19 <jfischoff> wrong ‘kind’ for one
14:40:21 <barrucadu> juanpablo_: Value is a concrete type
14:40:23 <bam365_> juanpablo_: because it's not the right kind?
14:41:42 <monochrom> it does not make sense to consider Value to be a functor.
14:42:12 <benzrf> why does returnA exist when id is a thing
14:42:21 <benzrf> :t returnA
14:42:23 <lambdabot> Arrow a => a b b
14:42:25 <benzrf> :t C.id
14:42:27 <lambdabot> Category cat => cat a a
14:42:36 <monochrom> returnA was born before C.id
14:42:59 <benzrf> oh
14:43:02 <monochrom> in fact the whole Control.Arrow was born before the whole Control.Category
14:43:42 <monochrom> therefore, in fact, (<<<) and (>>>) started out as Arrow things, not Category things
14:45:40 <benzrf> :t (>>>)
14:45:41 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
14:46:12 <monochrom> it was moved to Category one day, yeah.
14:46:21 <benzrf> @src (&&&)
14:46:21 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
14:46:27 <benzrf> ah
14:46:55 <benzrf> :t \f g -> (\b -> (b, b)) >>> bimap f g
14:46:57 <lambdabot> (a -> b) -> (a -> d) -> a -> (b, d)
14:47:02 <benzrf> oh
14:47:02 <benzrf> derp
14:47:16 <benzrf> lol
14:47:17 <monochrom> do you believe in "software is evolved"? as opposed to "software is intelligently designed"?
14:47:20 <vjeranc> how would I write a specialized algorithm depending on the specific numeric type, if I have a data Matrix a = (Num a) => ..., I can write a general algorithm but depending on the type of 'a', I could specialize, is there a way to do that?
14:47:39 * [swift] ponders whether there's any looping technique similar to the forever/EitherT combo that supports passing state from one iteration of the loop to the next
14:47:48 <[swift]> i suppose that ends up being a fold
14:47:53 <jfischoff> vjeranc: You want a typeclass
14:48:06 <simpson> [swift]: Heh, I thought that I was the only person that did forever with EitherT.
14:48:23 <simpson> But yeah, sounds like a foldM in StateT or something like that.
14:48:26 <[swift]> simpson: tekmo has a blog post about the technique, in fact!
14:48:31 <vjeranc> jfischoff: i'm aware of that, the problem is I cannot figure out how would I do, instance TypClas (Matrix Int)...
14:48:41 <vjeranc> jfischoff: or something along those lines...
14:49:05 <bitonic> `getLabelBc: Ran out of labels` ahah
14:49:08 <jfischoff> I might be confused
14:49:15 <bitonic> I've crashed GHC more in this last week than in the past 5 years I think
14:49:21 <simpson> [swift]: Ah, I see. Nifty.
14:49:57 <[swift]> simpson: well, hopefully it wouldn't require StateT. i considered combining EitherT and StateT to make forever work but it seems like there should be a simpler way
14:49:58 <bitonic> ghc: panic! (the 'impossible' happened)
14:49:58 <bitonic>   (GHC version 7.8.3 for x86_64-unknown-linux):
14:49:58 <bitonic> 	getLabelBc: Ran out of labels
14:50:12 <bitonic> I'm wondering if I should actually report it together with the 2.5MB file I'm trying to load
14:50:26 * [swift] considers foldM in EitherT
14:51:07 <simpson> [swift]: There's a control-monad-loops package on Hackage that might help.
14:51:14 <johnw> why would you want to use foldM and EitherT?
14:51:18 <vjeranc> jfischoff: the problem is that I don't want to make MatrixInt, MatrixDouble and similar data types, I just want a Matrix a, and then do the typeclass which can implement the general behaviour, but some algorithms don't work well on doubles, so I'd like to do the instance for Matrix Double
14:51:27 <benzrf> :t foldM
14:51:28 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
14:51:37 <solirc> Jello_Raptor: Using exceptions in pure code is not only considered bad design it also may behave different from what you think in some corner cases (esp. if you enable -O2).  If you still want to do it, http://hspec.github.io/expectations.html should explain everything you need to know (section "Expecting exceptions from pure code").
14:51:39 <johnw> that sounds strongly to me like you really want something else
14:51:50 <[swift]> johnw: i'm sure there's a better way! not sure what it is, though
14:51:57 <johnw> [swift]: describe what you want to achieve
14:52:02 <orbital> so i was thinking... there is IRC and there are narrated coding sessions on youtube, but there is no good way to pair-program within the community
14:52:22 <orbital> and Haskell is proving to be a formiddable challenge to self-teach
14:52:27 <monochrom> generalize pair-programming to IRC-programming :)
14:52:27 <johnw> orbital: find a friend, invite them to a Hangout. done
14:52:47 <johnw> orbital: I'd be happy to pair program with you sometime next week
14:53:04 <Hijiri> is hangout the google one?
14:53:08 <johnw> yes
14:53:19 <Hijiri> why not just use tox or something?
14:53:20 <[swift]> johnw: so my concrete problem is that i want to call a function 'foo' that the user provides, which returns Either Result FooArgs. if we have Left, then we terminate the loop and return a Result value. if we have Right, then we loop again, calling 'foo' with the FooArgs value as the argument
14:53:22 <benzrf> :t foldrM
14:53:24 <lambdabot>     Not in scope: ‘foldrM’
14:53:24 <lambdabot>     Perhaps you meant one of these:
14:53:24 <lambdabot>       ‘F.foldrM’ (imported from Data.Foldable),
14:53:29 <benzrf> lame!!
14:53:30 <jfischoff> vjeranc: you can provide a default implementation that works for Num a => Matrix a or whatever, but you will have to still make the instances
14:53:31 <[swift]> johnw: i have working code to do this, it's just uglier than i expected
14:53:44 <orbital> johnw: thanks! I may take you up on this soon
14:53:44 <[swift]> johnw: i'm trying to figure out how to do this as cleanly as possible
14:53:44 <johnw> [swift]: let me play for a moment
14:53:59 <monochrom> @type F.foldrM
14:54:01 <lambdabot> (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
14:54:16 <torpet> monochrom: http://lpaste.net/719230928420864000
14:54:22 <torpet> that's how i did it, thanks for your help
14:54:42 <monochrom> you're welcome. congrats.
14:54:54 <benzrf> :t foldr
14:54:56 <lambdabot> (a -> b -> b) -> b -> [a] -> b
14:54:56 <benzrf> :t foldl
14:54:57 <lambdabot> (b -> a -> b) -> b -> [a] -> b
14:54:58 <benzrf> oups
14:55:20 <benzrf> :t F.foldlM
14:55:21 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
14:55:23 <benzrf> cool
14:55:44 <vjeranc> jfischoff: i'm aware of that, but the problem is I just can't... it doesn't compile, for example "class AlgOne (Matrix a) where" doesn't compile......
14:56:04 <albeit> Why is there fold*M but not fold*A?
14:56:25 <jfischoff> vjeranc: you can’t put a type there
14:56:38 <jfischoff> you would need like class AlgOne a
14:57:29 <johnw> [swift]: so, here's one version: https://gist.github.com/00577e4e6926d58ed3cb
14:57:42 <johnw> but I'm sure there is cleaner
14:57:47 <johnw> still chewing...
14:57:53 <orbital> in Hangouts, can one control remote inputs?
14:58:03 <johnw> I don't think so
14:58:08 <johnw> one person "drives"
14:58:22 <vjeranc> jfischoff: well, ok, that's a first step, now it seems I cannot do an instance AlgOne (Matrix Int)
14:58:33 <jfischoff> why not?
14:58:53 <vjeranc> jfischoff: it seems I have to use flexible types
14:58:58 <orbital> screenhero can do that
14:59:03 <jfischoff> then use them
15:00:03 <vjeranc> well, it works nice, that is nice, is this static, during compile time?
15:00:10 <vjeranc> or is it runtime polymorphism?
15:00:17 <orbital> but screenhero is not entirely free
15:00:43 <orbital> and no group sharing yet
15:01:05 <jfischoff> vjeranc: probably static
15:01:11 <[swift]> johnw: hmm, iterateM_, huh? i'll take a look
15:01:47 <[swift]> johnw: that's already much shorter than what i have =)
15:01:53 <jfischoff> it’s an implementation detail not in the spec IIRC
15:01:59 <johnw> I just never like calling error
15:03:42 <stefan_1> does haskell have case fallthrough?
15:04:02 <monochrom> no
15:04:16 <benzrf> stefan_1: what would that even mean?
15:04:17 <Gurkenglas> https://www.fpcomplete.com/user/Gurkenglas/hoogle <- Did I do that wrong? There's an error.
15:04:19 <johnw> [swift]: I like this one more: https://gist.github.com/dce60e65e1f7919b1852
15:04:36 <Gurkenglas> (Downloaded VisualWget to copy code.haskell.org/hoogle/src after some google-fu to figure out how to only copy that subdirectory, downloaded the GitHub client and made that folder a repos on github, made a project on fpcomplete that connects to github.)
15:04:53 <Welkin> yesod-auth doesn't have sane defaults and it looks like there is no way to change them.
15:05:01 <Welkin> how is yesod-auth-account?
15:05:08 <Welkin> I couldn't seem to get that working though
15:05:09 <stefan_1> case random [1..4] of 1; 2; 3 -> doSomething; 4 -> doSomethingElse
15:05:32 <stefan_1> is something like that possible?
15:05:45 <Gurkenglas> random is IO, as should be clear
15:06:00 <stefan_1> yeah, lets say we are in a magic world where a function like that exists
15:07:22 <JonReed> Isn't this appropriate? [ IO (), IO(), IO(), IO()] and then just choose the action from the list
15:07:24 <Gurkenglas> http://zvon.org/other/haskell/Outputsyntax/caseQexpressions_reference.html
15:07:26 <Iceland_jack> You can do:
15:07:27 <Iceland_jack>     case random [1..4] of
15:07:27 <Iceland_jack>        n | n `elem` [1..3] -> doSomething
15:07:30 <Iceland_jack>        4                   -> doSomethingElse
15:07:57 <stefan_1> Iceland_jack, that looks like it could work, thanks
15:09:06 <vjeranc> jfischoff: thanks, works for now, the problem is that now, the AlgOne a, can only work on 'a', I cannot from Matrix 'a', return just 'a'... i'll play around and see if I can think of something
15:10:07 <jfischoff> vjeranc: yes it will take something tweaking, but if find yourself saying, “I want a function to something way for a type, and other for a different type” you probably want a typeclass
15:10:14 <[swift]> johnw: heh! that's actually more or less what i already have
15:10:31 <johnw> it's clear, it's safe, it should optimize well
15:12:51 <[swift]> johnw: yeah, it's not really that bad, i've just come to view manually implementing something that smells like it might be an existing higher-order function as a code smell. but in this case it doesn't seem like there's a clean higher-order function for this in base
15:12:51 <vjeranc> jfischoff: yep, it works as similar as generics, but in java i cannot condition on type, i would have to make an additional class MatrixInt and override the method from the abstract one... thanks!
15:13:39 <jfischoff> np
15:16:54 <felixn> does anyone like to use parsec for anything but text parsing?  I'm folding some AST, but now I'm thinking I could just use parsec on my data!
15:17:33 <johnw> [swift]: you could generalize this to all monads capable of "short-circuiting with a value", which would be Either, Cont, ErrorT, and a few others, and maybe call it MonadCut or something
15:17:47 <johnw> but I doubt it's worth the trouble
15:18:01 <[swift]> yup, agreed
15:21:25 <merijn> felixn: I haven't, but I've heard of people who do that, yes
15:21:26 <absence> i'm writing a bunch of Binary.Get decoders, can stuff like this be made shorter? Note3 length <$> getOptParam <*> getOptParam <*> getOptParam <|> Note2 length <$> getOptParam <*> getOptParam <|> Note1 length <$> getOptParam <|> pure (Note0 length)
15:22:25 <merijn> absence: Not significantly, I think
15:22:53 <merijn> Well, you could have "date Note = Note Int [OptParam]" instead of your current datatype
15:23:25 <johnw> you could factor out getting the first param, since that's common to them all
15:24:02 <johnw> oh, not for Note0
15:24:03 <johnw> n/m
15:25:18 <absence> johnw: how would it have looked though?
15:25:41 <johnw> it would have looked like the type errors that GHC prints out
15:25:49 <johnw> if Note0 were gone:
15:25:52 <johnw> x <- getOptParam ; Note3 length x <$> getOptParam ... <|> Note2 length x <$> getOptParam <|> Note1 length x
15:26:24 <johnw> so, you could also do this... (one sec)
15:32:43 <johnw> absence: maybe not better, and I haven't tested it: https://gist.github.com/21e4d3d333aae96f5af4
15:33:45 <acowley> Won't that just take the first Note0 option?
15:33:59 <johnw> very probably
15:36:56 <absence> johnw: i see what you mean, and i started out with a similar solution using an alternative version of getOptParam that uses Maybe instead of Alternative
15:46:33 <monochrom> felixn: I use parsec on a list of XML nodes
15:48:43 <monochrom> it parses [ <r/>, <d/>, "hello", <d/>, "hi", <r/>, <d/>, "foo", <d/>, "bar" ] into <tr><td>hello</td><td>hi</td></tr> <tr><td>foo</td><td>bar</td></tr>
15:51:53 <Welkin> has anyone ever gotten yesod-auth-account working?
15:51:57 <Welkin> I just get endless errors
15:52:00 <Welkin> it look broken
15:52:05 <Welkin> looks*
15:56:11 <EvanR> > fix error
15:56:13 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
15:56:39 <FireFly> Not a good fix, that
16:10:35 <EvanR> > 1 : 2 : 3 : undefined : 5 : []
16:10:37 <lambdabot>  [1,2,3,*Exception: Prelude.undefined
16:10:54 <EvanR> > take 3 (1 : 2 : 3 : undefined : 5 : [])
16:10:56 <lambdabot>  [1,2,3]
16:11:02 <phaazon> hey, imagine a language with expressions ; is "x" (a variable) an open expression?
16:11:25 <phaazon> for instance, \x -> x + 1
16:11:34 <phaazon> in the body of the lambda, x is closed
16:11:47 <phaazon> but is it in the definition of the parameter of the lambda?
16:12:05 <EvanR> i say x in the parameter is a different kind of expression
16:12:17 <EvanR> bounded has no bearing on that one
16:12:57 <phaazon> yeah
16:13:04 <EvanR> it introduces a variable and shadows others if they happen to exist outside
16:13:26 <EvanR> its always valid (unless you have another one in the same pattern)
16:16:19 <mekeor`> would you choose "(T,Bool)" or "Either T T" if you'd need some sort of 'flag'? (let T be some type.)
16:16:57 <mekeor`> or something different?
16:17:35 <EvanR> or Flag T Bool, or Flagged T | Unflagged T
16:18:14 <EvanR> i was warned not to use Bool for this stuff
16:18:16 <mekeor`> EvanR: is there already such a Flag datatype on hackage?
16:18:30 <mekeor`> why?
16:18:39 <EvanR> doubt it because literally Flagged has the same issues as Bool
16:18:54 <EvanR> Flagged by itself isnt evident what it means
16:19:55 <EvanR> theres a basic difference between {active: true} and "active"
16:20:45 <mekeor`> hmmeh.
16:21:10 <mekeor`> not really?
16:21:59 <EvanR> i see a bunch of blog posts about "boolean blindness"
16:22:07 <chirpsalot> Uh... What? http://lpaste.net/8960669984237813760
16:22:51 <phaazon> chirpsalot: you missed a ++
16:23:00 <chirpsalot> Oh, damn, just noticed that.
16:23:05 <phaazon> :)
16:23:09 * mekeor` takes a look at http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
16:23:33 <chirpsalot> phaazon: thanks for pointing out my mistakes :P
16:24:38 <phaazon> you’re welcome :D
16:31:28 <EvanR> mekeor`: so a lot of this mentality seems to be coming from a direction of trying to use your types more like propositions, and values of the type are proofs of the proposition. but because a lot of this stuff is lost on basic haskell because it doesnt have dependent types
16:31:55 <EvanR> remove the first because
16:32:24 <EvanR> either way i have found it easier to remember what my flags mean when they are spelled out, rather than true or false one way or the other
16:32:46 <EvanR> especially once those bools go into a big compound && and || nest
16:32:50 <thirtyp> "spelled out"?
16:33:05 <EvanR> Active Inactive, Hired Fired, Ok Error
16:33:39 <EvanR> you can also add a third case if it ever happened to exist
16:34:29 <EvanR> for basic bool fields, you often rely on spelling the variable right at each step it gets propogated around your code
16:35:01 <mekeor`> *nod*
16:35:18 <EvanR> this definitely helps me in javascript where you dont have a lot of type info staring you in the face everywhere
16:35:45 <EvanR> and i have to ignore  alot of flak for not using the "faster" bool
16:36:07 <mekeor`> :D
16:36:19 <EvanR> or in the case of database, smaller
16:36:32 <josephle> boolean blindness hurts even more when you're theorem proving with dependent types
16:37:00 <josephle> never again shall I use booleans in the context of theorem proving
16:37:53 <mekeor`> #hatebooleans
16:38:05 <vanila> josephle, Im curious what this was, can you show it ro did you post about it?
16:38:24 <josephle> vanila, it was a simple proof that a merge sort using binary trees actually sorts
16:38:36 <josephle> but to boil it down to its essence
16:39:02 <josephle> (pred x == True) is a terrible type to work with in comparison to (IsPred x)
16:39:24 <merijn> josephle: "pred x == True" is redundant
16:39:38 <vanila> ah I see
16:39:38 <EvanR> (pred x = True) this type
16:39:41 <josephle> merijn: ah I meant (==) to mean propositional equality
16:39:42 <josephle> yeah
16:39:44 <vanila> because you can't get the info out of it
16:39:47 <vanila> (Easily)
16:39:49 <josephle> yep
16:40:02 <josephle> but IsPred probably has a nice elimination rule
16:40:56 <merijn> I tried to avoid boolean blindness, but SPJ told me to just add an extra boolean to replace my triple valued setup >.>
16:41:26 * EvanR imagines an app as just a huge array of levers
16:41:27 <wswiss> @pl \c -> (p c + q c)
16:41:27 <lambdabot> liftM2 (+) p q
16:43:14 <EvanR> merijn: True False and FileNotFound?
16:43:50 <monochrom> :)
16:44:50 <merijn> EvanR: Exactly!
16:45:23 <merijn> Although I will probably indeed go with multiple booleans as it makes the guards nicer
16:45:38 <merijn> And I can't find a convincing encoding for a datatype using non-booleans
16:54:31 * EvanR wonders how to represent a triple-valued setup with two bools
16:57:39 <phaazon> hm
16:57:41 <phaazon> Cale: are you there?
16:59:02 <phaazon> I have a trouble with applying an expression to another with my AST
16:59:04 <phaazon> https://github.com/phaazon/ash/blob/master/src/Ash.hs#L28
16:59:26 <phaazon> I’d like to build a type in which I have the history of applied values
16:59:32 <phaazon> so that they don’t get existentially qualified
16:59:43 <phaazon> (the current implementation is)
16:59:49 <merijn> EvanR: Well, now it's more expressive!
16:59:56 <phaazon> (Lam is pretty great, for instance)
17:00:03 <merijn> EvanR: Actually, I'm using three booleans *hide*
17:00:19 <EvanR> ah the old 100 010 001 trick
17:04:35 * [swift] wonders if ghc packs booleans if a constructor has several booleans in a row
17:04:45 <[swift]> i suppose they'd have to be strict
17:14:41 <Darwin226> hey guys. I'm playing with types. If I have an instance "instance Add (Zero -> a -> a)" why would i get errors like "No instance for (Add (Zero -> Zero -> a0))"
17:15:03 <Darwin226> Why don't a and a0 just become Zero?
17:15:55 <vanila> Darwin226, to do that you would need multiparameter typeclasses with functional dependencies
17:16:12 <vanila> like  class Add x y z | x y -> z , with instance Add Zero a a
17:16:27 <vanila> so that it can compute 'z' from the types 'x' and 'y'
17:16:56 <Darwin226> I'm still in the "this functional dependajiggles look complicated. Lets try to force what I want to do with stuff I'm already familiar with" stage
17:19:07 <Iceland_jack> Darwin226: If you want add numbers together on the type-level you should use type familiers, if you're new to this and want to do things you're familiar with this is a strange thing to learn
17:19:45 <Darwin226> Iceland_jack: It's haskell. Everything I learn is a strange thing to learn
17:19:53 <Iceland_jack> That's not true
17:20:31 <Darwin226> Iceland_jack: How come?
17:20:45 <EvanR> ... a data type with one constructor with one argument is the same as a newtype?
17:21:08 <benzrf> EvanR: no
17:21:26 <benzrf> @let data Foo = Foo Int
17:21:27 <Iceland_jack> EvanR: Essentially yes, there are some distinctions that have to do with strictness and efficiency
17:21:28 <lambdabot>  Defined.
17:21:28 <benzrf> er wait
17:21:34 <benzrf> @let data Bar = Bar Int deriving Show
17:21:36 <lambdabot>  Defined.
17:21:43 <benzrf> @let newtype Bar' = Bar' Int deriving Show
17:21:45 <lambdabot>  Defined.
17:21:46 <benzrf> EvanR:
17:21:57 <benzrf> > case undefined of Bar _ -> "works!"
17:22:00 <lambdabot>  "*Exception: Prelude.undefined
17:22:01 <benzrf> > case undefined of Bar' _ -> "works!"
17:22:03 <lambdabot>  "works!"
17:22:16 <lpsmith> Everything you didn't want to know about dates:  http://blog.melding-monads.com/2014/11/05/a-brief-history-of-timekeeping-part-1-dates-on-the-western-calendars/
17:22:27 <EvanR> so
17:22:46 <EvanR> frege dropped support for newtype
17:22:54 <EvanR> i guess it doesnt matter
17:23:12 <Iceland_jack> There are some cool things you get from having newtypes
17:23:27 <Iceland_jack> but they also complicate the programming language and the type system
17:24:26 <Darwin226> Iceland_jack: Anyways. I've read about type level numerals in haskell before and it seemed too advanced. Then I managed to implement them in F# because it allows you to overload functions for different types. I guess I hoped it would be that easy in haskell
17:25:06 <Iceland_jack> Darwin226:
17:25:07 <Iceland_jack>     data Nat = Zero | Succ Nat
17:25:07 <Iceland_jack>     type family (a :: Nat) + (b :: Nat) where
17:25:07 <Iceland_jack>       Zero   + m = a
17:25:10 <Iceland_jack>       Succ n + m = Succ (n + m)
17:25:37 <Iceland_jack> This is a nice way of defining it, you can also define it as normal Haskell code and lift it to the type level using the "singletons" library
17:26:03 <Darwin226> Iceland_jack: WHAT!?
17:26:13 <Darwin226> Iceland_jack: I've got to read up on this stuff
17:27:52 <Iceland_jack> This is somewhat advanced Haskell so there are a lot of things one would want to understand well before
17:28:06 <Iceland_jack> But it is doable
17:28:38 <EvanR> type level naturals in f# ...
17:28:59 <EvanR> is f# more or less crufty than scala
17:29:45 <Darwin226> EvanR: I wouldn't know. It did require taking a machete at the type system to make it work though
17:30:08 <Darwin226> Iceland_jack: Any topics in particular I should know before?
17:30:42 <Iceland_jack> You mean to understand (closed) type families?
17:31:07 <Darwin226> Iceland_jack: Yeah. The stuff I need to understand well
17:31:41 <EvanR> where does that m come from
17:31:49 <EvanR> Darwin226:
17:31:55 <EvanR> or Iceland_jack
17:31:57 <Iceland_jack> EvanR: it should be "Zero + m = m"
17:32:18 <EvanR> m is implicitly quantifier or something?
17:32:21 <EvanR> phantom?
17:32:36 <Iceland_jack> EvanR: It's an argument to the type family
17:32:41 <EvanR> oh
17:32:47 <EvanR> n and m
17:32:48 <Iceland_jack> Solid knowledge of types and kinds, understanding the extension datakinds, understand GADTs well, ...
17:33:17 <Iceland_jack> I think you should also understand type classes very well even thought they're not strictly necessary to understand closed type families
17:33:33 <Iceland_jack> Then you can learn about open and closed type families
17:34:06 <Darwin226> Iceland_jack: Ok. Thank you
17:35:27 <Iceland_jack> I would probably recommend understanding LYAH and trying to make a small project first even though it doesn't directly factor into it
17:35:37 * hackagebot hsebaysdk 0.2.0.0 - Haskell eBay SDK  http://hackage.haskell.org/package/hsebaysdk-0.2.0.0 (ChristopherReichert)
17:36:47 <EvanR> Darwin226: this is pretty easy in idris ;)
17:37:44 <Iceland_jack> Darwin226: Yes :) Haskell was not designed with these kinds of computations in mind, it's been "bolted" on in a sense (quite nicely, but it's not as nice as in languages like Idris or Agda)
17:37:54 <lpaste> EmmanuelOga pasted “YesNo TypeClass” at http://lpaste.net/113837
17:38:19 <batchm> 'join #C#
17:38:28 <EvanR> nah
17:38:35 <batchm> damn,I blew my cover
17:38:39 <Darwin226> Iceland_jack: Not that novice. I'm somewhere around the level where I can almost convince myself I understand monads
17:38:48 <MP2E> batched up!
17:38:56 <MP2E> :P
17:39:18 <emmanueloga> ah, that's what the irc channel select box does :). Anybody knows why the instance of YesNo chokes on my typeclass constraint? (Num a)
17:39:31 <Hijiri> How can I install something so that the ghc package registration is in a sandbox, but the actual binaries get put in my .cabal/bin?
17:39:58 <Hijiri> and anything that has to go in /share gets put it .cabal/share and linked that way
17:40:00 <Fuuzetsu> Hijiri: AFAIK people cp/ln into sandboxes
17:40:26 <Hijiri> will it find things in .cabal/share properly?
17:40:38 <Fuuzetsu> emmanueloga: not sure how you expect the same expression to evaluate to different result
17:40:45 <Hijiri> I've done that before for simple things, but not sure if it would for xmonad
17:40:48 <Iceland_jack> Darwin226: At that point you can go into many directions, you can look at extensions to the type systems (I recommend reading relevant papers), learn about "origami" programming and recursion patterns, go into making projects, ...
17:41:12 <emmanueloga> Fuuzetsu: typo, last line should say 1 :)
17:41:15 <Fuuzetsu> Hijiri: maybe start looking into nix ;)
17:41:25 <Fuuzetsu> emmanueloga: what's the actual error message?
17:41:27 <Iceland_jack> Darwin226: Try to search for "closed type families" and read relevant material, if you don't understand then you can search for that until you hit something you do understand
17:41:31 <Fuuzetsu> better load up GHCi…
17:41:34 <Hijiri> I'd like to install nixos but I don't have a free computer to install it on
17:42:09 <Fuuzetsu> you can install nix on alongside your existing distro; why not install NixOS on your current box? ;)
17:42:11 <Darwin226> Iceland_jack: I'm currently going through a book about concurency and paralelism but these type families look more interesting
17:42:11 <emmanueloga> Fuuzetsu: it says Illegal instance declaration for `YesNo a` (All instance types must be of the form (T a1 ... an)
17:43:13 <Hijiri> Is there a good guide on installing just nix?
17:43:37 <Darwin226> Iceland_jack: Anyways. Thanks for the help
17:43:39 <Hijiri> I'm just trying to uninstall xmonad globally so it doesn't register a bunch of packages with ghc
17:43:52 <emmanueloga> Fuuzetsu: if I change the instance to, say, YesNo Char, then it works fine. I want to make instance of YesNo for all Num types then.
17:44:01 <Hijiri> but I've been thinking about just trying nix on here until I have the chance to use nixos fully
17:44:04 <Fuuzetsu> emmanueloga: see second post on http://stackoverflow.com/questions/8633470/illegal-instance-declaration-when-declaring-instance-of-isstring , it's not your Num that's the problem here
17:45:03 <Fuuzetsu> Hijiri: I think http://nixos.org/nix/manual/#chap-installation is up to date? Asking a ton of questions in #nixos is good
17:45:19 <Hijiri> ok, thanks
17:51:53 <emmanueloga> Fuuzetsu: are you suggesting FlexibleInstances may help? If yes, it did not, I updated the gist: http://lpaste.net/113837
17:52:55 <emmanueloga> I guess my question could be generalized to: can you really make a typeclass instance to a generic type a, such that a is constrained as (Num a)? Maybe the problem is that I need to defined YesNo for each and every possible Num concrete type...
17:53:27 <batchm> I haven't yet used sandboxed cabal.. are downloads of libraries cashed? or do you have to download the same libraries for every project, even if you' have already downloaded that version of the library in a prior project
17:53:39 <Fuuzetsu> your problem is that you don't satisfy rule 1 in the link I given you
17:53:45 <batchm> downloaded, installed, etc
17:54:07 <Fuuzetsu> i.e. you need a type constructor which is then (optionally) followed by type variables; you don't have the type constructor
17:54:14 <batchm> what part is cached, if any?
17:54:27 <Fuuzetsu> batchm: no caching
17:54:29 <felixn> status update, parsec parsing for non-char streams is great
17:54:46 <Fuuzetsu> batchm: well, sources won't be re-downloaded, that's cached
17:54:54 <Fuuzetsu> but they will be rebuild each time; hope you have a lot of time
17:54:58 <Fuuzetsu> rebuilt*
17:55:48 <batchm> Fuuzetsu, you're not a fan of it, if I sense right? or you are, despite that
17:56:05 <batchm> (the whole cabal sandbox thing)
17:56:47 <Guest-6430> great
17:56:49 <Guest-6430> fast and fun
17:57:24 <batchm> I like the idea of avoiding sandbox hell.. but rebuilding lens, gtk etc.. for each project.. hmmm
17:57:28 <batchm> cabal hell :)
17:57:34 <Fuuzetsu> batchm: sandboxes are a lot better than what we had before (cabal-dev &c) but I have since moved onto using nix which does cache build results as well as getting you binary caches from elsewhere
17:57:55 <batchm> nix OS? interesting
17:58:27 <Fuuzetsu> well, there's nix and then there's NixOS
18:08:02 <edwardk> batchm: to be fair rebuilding gtk for every project would give me pause too ;)
18:08:11 <edwardk> heck i can't get it to build the first !*@#'ing time
18:09:29 <Iceland_jack> Darwin226: I hope it was helpful :) these may be a nice papers to read http://research.microsoft.com/en-us/people/dimitris/fc-kind-poly.pdf and http://www.cis.upenn.edu/~eir/papers/2014/axioms/axioms-extended.pdf
18:09:58 <batchm> edwardk I know what you mean :). took me quite a while to get it working
18:10:40 <emmanueloga> so what's is a valid type constructor for a literal number?
18:11:01 <Iceland_jack> emmanueloga: Depends on the type of the literal
18:11:28 <Iceland_jack> When you type:
18:11:29 <Iceland_jack>     4 :: Int
18:11:29 <Iceland_jack> It's really:
18:11:32 <Iceland_jack>     I# 4#
18:11:56 <Iceland_jack> When you type:
18:11:56 <Iceland_jack>     4 :: Complex Double
18:11:56 <Iceland_jack> It's really:
18:11:56 <Iceland_jack>     4.0 :+ 0.0
18:12:46 <Iceland_jack> emmanueloga: Or did I just completely misunderstand your question..
18:13:09 <emmanueloga> hmmm I need something that I can use on the instance declaration of my typeclass
18:13:10 <Iceland_jack> You did mean data constructor rather than type?
18:13:33 <emmanueloga> I need to do: instance MyTypeClass ConstructorOfIntegerLiteral where ...
18:14:00 <Iceland_jack> Do you mean?
18:14:00 <Iceland_jack>     instance Num n => MyTypeClass n where
18:14:00 <Iceland_jack>       ...
18:14:21 <emmanueloga> that doesn't work.
18:14:58 <emmanueloga> I think that's the first thing I tried :)
18:16:45 <Fuuzetsu> emmanueloga: you could just wrap it in whatever you want
18:16:46 <Iceland_jack> What integer literals mean is defined as a method in "Num" so if you create a newtype Foo and write 'instance Num n => MyTypeClass (Foo n) where' it ought to work
18:16:47 <Fuuzetsu> http://lpaste.net/113840
18:21:49 <emmanueloga> Fuuzetsu: cool, but that requires I wrap the num in the type I
18:22:15 <emmanueloga> is there a way to make it work w/o doing that? I can make it work with Int for instance, if I yesno (3::Int)
18:24:06 <emmanueloga> it is also confusing that ghci> tells me :t 2 is: Num a => a, but it doesn't tell me a! Shouldn't a be a concrete type since we are talking about a concrete number? (3)
18:24:27 <Iceland_jack> emmanueloga: it defaults to "Integer"
18:24:43 <Fuuzetsu> 3 is whatever Num it needs to be
18:24:54 <Fuuzetsu> or rather, it is whatever you need it to be, as long as it's Num
18:25:04 <MaestroBones> Hi, I'm reading the book "Learn you a haskell for great good", and I'm following along. There's a part where it tells me to run doubleSmallNumber' x = (if x > 100 then x else x*2) + 1
18:25:27 <MaestroBones> but when I put that into ghci, I get the error "parse error on input ="
18:25:34 <Iceland_jack> MaestroBones: add a "let"
18:25:37 <Fuuzetsu> MaestroBones: precede with let
18:25:39 <MaestroBones> Ah
18:25:47 <Iceland_jack>     ghci> let doubleSmallNumber' x = ...
18:25:50 <MaestroBones> Thanks
18:25:53 <Iceland_jack> no prob
18:29:17 <Iceland_jack> Fuuzetsu: You can get close with this:
18:29:18 <Iceland_jack> ghci> data I a = I a deriving Show
18:29:18 <Iceland_jack> ghci> instance Num n => Num (I n) where fromInteger = I . fromInteger
18:29:18 <Iceland_jack> ghci|
18:29:21 <Iceland_jack> ghci> 15 :: I Integer
18:29:24 <Iceland_jack> I 15
18:29:34 <Iceland_jack> ghci> 15 :: I Float
18:29:34 <Iceland_jack> I 15.0
18:30:40 * hackagebot gl 0.5 - Complete OpenGL raw bindings  http://hackage.haskell.org/package/gl-0.5 (EdwardKmett)
18:31:35 <emmanueloga> btw, in class you did not know: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#a-yes-no-typeclass
18:31:57 <emmanueloga> I gues there's a reason the example doesn't show how to make it work for any integer literal :/
18:32:51 <emmanueloga> -yesno 2 doesn't work but yesno (2 :: Int) does-
18:33:27 <Iceland_jack> emmanueloga: "yesno 2" would work in GHCi if you define a YesNo Integer instance
18:34:46 <Iceland_jack> ghci> class YesNo a where yesno :: a -> Bool
18:34:46 <Iceland_jack> ghci> instance YesNo Integer where yesno 0 = False; yesno _ = True
18:34:46 <Iceland_jack> ghci> yesno 15
18:34:46 <Iceland_jack> True
18:34:50 <emmanueloga> in ghci? Maybe, but if you put it on a script it doesn't (at least not with 7.6.3)
18:34:59 <Iceland_jack> Yes
18:46:02 <phao> Hi. Is this a good haskell book? http://www.amazon.com/Haskell-Functional-Programming-International-Computer/dp/0201882957/
18:47:46 <athan> phao: what kind of material were you looking for?
18:48:22 <phao> I want to learn haskell. I'm already a programmer and I"ve done functional programming in scheme and some sml before.
18:51:27 <merijn> phao: Ah
18:51:33 <merijn> phao: Maybe you're interested in
18:51:37 <merijn> @where gentle
18:51:37 <lambdabot> http://www.haskell.org/tutorial/
18:51:41 <phao> Ok.
18:51:43 <phao> Thanks =)
18:52:06 <phao> merijn, Is it still relevant?
18:52:26 <merijn> phao: For the language, yeah, Haskell2010 isn't very different from 98
18:52:33 <phao> Ok.
18:52:35 <merijn> For the library ecosystem you need to dive into other books anyway
18:52:41 <zwer> phaazon lyah is also frequently recommended
18:52:44 <zwer> @where lyah
18:52:44 <lambdabot> http://www.learnyouahaskell.com/
18:52:59 <phao> ok
18:53:03 <merijn> LYAH is really beginner intro, the Gentle Intro is aimed at people with ocaml/sml experience
18:53:18 <merijn> Like, LYAH spends an entire chapter on pattern matching, that sorta thing
18:53:31 <phao> I'd not say I have sml experience. I've read a book on it (that one by ullman). I have way more experience in scheme.
18:53:54 <phao> But yeah, I remember how pattern matching works. I've also read a book on ocaml, but it was like 3 years ago.
18:54:00 <merijn> phao: Well, can you read basic SML and make sense of what goes on? If so, you're probably ahead :p
18:54:06 <phao> =D
18:54:14 <phao> Thanks.
19:27:04 <MP2E> hmm say I have a list of unique elements a list can contain and a length, is there a way I can calculate every possible list of that length with said elements?
19:27:23 <MP2E> feel like I'm missing something easy :p
19:28:15 <Iceland_jack> Something like:
19:28:15 <Iceland_jack> > replicateM 3 "abcd"
19:28:17 <lambdabot>  ["aaa","aab","aac","aad","aba","abb","abc","abd","aca","acb","acc","acd","ad...
19:28:23 <MP2E> ah perfect thanks
19:28:29 <MP2E> replicateM is what I needed
19:28:37 <Iceland_jack> (from Control.Monad)
19:34:23 <emmanueloga> q, I was expecting ghc to complain about fun not matching every Int here: http://lpaste.net/7160462226262851584 any idea why the code compiles? (Fails at runtime with "Non-exhaustive patterns in function fun", which I was expecting to be the error at compile time)
19:35:39 <merijn> emmanueloga: Compile with -Wall
19:35:45 <Iceland_jack> emmanueloga: If you enable "-Wall" it is a warning
19:36:04 <merijn> Or "-Wall -Werror" to make it an error :p
19:36:16 <merijn> Anyway, you should always use -Wall with GHC anyway
19:36:18 <Iceland_jack> '-fwarn-incomplete-patterns' is a flag that specifically enables that
19:36:21 <emmanueloga> could it be that  doesn't work on 7.6.3?
19:36:24 <merijn> Selectively disable warnings you don't want
19:36:40 <merijn> emmanueloga: That has worked since time beyond rememberance
19:36:57 <merijn> emmanueloga: Make sure to clean before recompiling!
19:37:04 <merijn> Or use -fforce-recomp
19:37:12 <emmanueloga> hahah ok
19:37:16 <Iceland_jack> Prelude> let fun :: Int -> Int; fun 2 = 2
19:37:17 <Iceland_jack> Prelude> :set -Wall
19:37:17 <Iceland_jack> Prelude> let fun :: Int -> Int; fun 2 = 2
19:37:19 <merijn> GHC only rebuilds that have changes
19:37:20 <Iceland_jack> ...
19:37:27 <Iceland_jack> <interactive>:4:24: Warning:
19:37:27 <Iceland_jack>     Pattern match(es) are non-exhaustive
19:37:27 <Iceland_jack>     In an equation for ‘fun’:
19:37:31 <Iceland_jack>         Patterns not matched: GHC.Types.I# #x with #x `notElem` [2#]
19:38:14 <emmanueloga> txs! -fforce-recomp made it work
19:42:14 <emmanueloga> the error report is a bit hard to read... I wonder if it could be changed to report like ocaml does: "Here is an example of a value that is not matched: 0".
19:43:06 <merijn> emmanueloga: The problem here is overloading of numerical literals
19:43:19 <merijn> emmanueloga: Which makes analysis like that tricky
19:43:28 <merijn> ocaml doesn't have that
19:45:26 <emmanueloga> ah makese sense. If I change it to Char and I only cover 'a', the message returns something like "Fails for anything not in ['a']", much more readable.
19:46:02 <merijn> emmanueloga: Right, if you have standard enum style constructors it will just list the missing ones
19:46:14 <emmanueloga> cool
19:49:19 <trap_exit> > 1 + 2
19:49:21 <lambdabot>  3
19:49:26 <trap_exit> :t (1 + 2)
19:49:27 <lambdabot> Num a => a
19:50:27 <Total_1mmersion> Does anyone know how to get cabal to use the library that I gave it with the add-source command, instead of the user package of the same name?
19:50:43 * hackagebot atomic-primops 0.6.1 - A safe approach to CAS and other atomic ops in Haskell.  http://hackage.haskell.org/package/atomic-primops-0.6.1 (RyanNewton)
20:02:55 <chirpsalot> Is there a convenient way to split a generator for mapping over a list?
20:03:28 <merijn> chirpsalot: A StdGen you mean?
20:03:36 <merijn> Or what?
20:03:36 <chirpsalot> merijn: yep!
20:03:56 <merijn> chirpsalot: Probably you want to use randoms and some form of zipWith instead?
20:04:06 <merijn> :t randoms
20:04:08 <lambdabot> (Random a, RandomGen g) => g -> [a]
20:04:18 <chirpsalot> merijn: list of lists.
20:04:56 <merijn> :t randoms :: (Random a, RandomGen g) => g -> [[a]]
20:04:59 <lambdabot>     Could not deduce (Random [a1]) arising from a use of ‘randoms’
20:04:59 <lambdabot>     from the context (Random a, RandomGen g)
20:04:59 <lambdabot>       bound by the inferred type of
20:05:01 <merijn> aww
20:05:46 <chirpsalot> merijn: basically I need to map a function over each element in a list, and each function uses randoms?
20:06:18 <merijn> tbh, I'm to lazy to summon the mental power to figure out the right way to do this, sorry :)
20:06:38 <chirpsalot> merijn: fair enough! I'll do it the dumb way :).
20:07:09 <chirpsalot> I guess I can make a "randoms" like function with "split" instead?
20:08:12 <merijn> You can use something like MonadRandom or State to generate multiple randoms, or something along those lines
20:10:57 <nshepperd> :t first randoms . split
20:10:59 <lambdabot>     Couldn't match type ‘[a1] -> [[a1]]’ with ‘(b0, d)’
20:10:59 <lambdabot>     Expected type: ([a1] -> [[a1]]) -> ([a], d)
20:10:59 <lambdabot>       Actual type: (b0, d) -> ([a], d)
20:11:06 <nshepperd> ehhh
20:11:46 <nshepperd> :t split
20:11:47 <lambdabot> Splitter a -> [a] -> [[a]]
20:11:55 <nshepperd> oh, it's the wrong 'split'
20:12:54 <nshepperd> :t first randoms . System.Random.split
20:12:57 <lambdabot> (Random a1, RandomGen a) => a -> ([a1], a)
20:17:30 <dfeuer_> :t yomama
20:17:32 <lambdabot>     Not in scope: ‘yomama’
20:17:32 <lambdabot>     Perhaps you meant ‘comma’ (imported from Text.PrettyPrint.HughesPJ)
20:17:38 <dfeuer_> :t comma
20:17:39 <lambdabot> Doc
20:17:45 <dfeuer_> > comma
20:17:47 <lambdabot>  ,
20:18:04 <Fuuzetsu> not sure what you expected
20:24:06 <codygman-> If I wanted to get a code review, where would the best place to put it be? haskell codereview stackexchange?
20:25:43 <codygman-> My previous post there never got reviewed: http://codereview.stackexchange.com/questions/57273/website-using-persistent-blaze-html-and-scotty
20:26:58 <Fuuzetsu> if you look at the tag, there are not many answers to the questions
20:34:07 <Welkin> does anyone in here use Mozilla Persona?
20:36:59 <td123> is there a way to list outdated libraries from a cabal freeze operation?
20:37:22 <Welkin> ?
20:37:38 <Welkin> just `cabal install --only-dependencies`
20:37:50 <Welkin> it should grab the latest packages within the specified bounds
20:38:09 <td123> I guess I also want it to check outside the bounds :)
20:38:19 <td123> so that you know which libraries to look into updating
20:45:45 * hackagebot persistent 2.1.1 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-2.1.1 (GregWeber)
20:45:47 * hackagebot persistent-mongoDB 2.1.1 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-2.1.1 (GregWeber)
20:48:13 <merijn> td123: There were some tools for automatic bounds testing, but I forget the name
20:49:02 <Welkin> does anyone else have a favorite font?
20:50:43 <merijn> Monaco :p
20:52:22 <johnw> Welkin: Adobe Source Sans
20:52:35 <johnw> no, I mean, Source Pro Mono
20:54:23 <Welkin> oh, I meant for print
20:54:26 <Welkin> not for programming
20:54:52 <johnw> oh, then definitely Adobe Garamond Premier Pro
20:54:58 <johnw> I _love_ that font in print
20:55:27 <johnw> but this really isn't relevant to Haskell in any way
20:55:33 <johnw> i shouldn't have answered here
20:56:18 <Welkin> we'll take it to #haskell-blah then
20:56:24 <johnw> thx!
21:08:31 <merijn> Can someone test something for me?
21:08:41 <johnw> yes, the moon is still in the sky
21:09:05 <lpaste> merijn pasted “Simple test” at http://lpaste.net/113843
21:09:38 <merijn> If you compile and run that program with -threaded and without, do they both terminate with 5 seconds, as they should?
21:10:07 <merijn> For me the threaded case works fine, but the single threaded runtime hangs indefinitely?
21:10:56 <johnw> it wants to read a file that doesn't exist
21:11:11 <johnw> more instructions needed
21:11:51 <merijn> heh
21:12:03 <merijn> oh, duh
21:12:10 <merijn> Yeah, name the file T8089.hs
21:12:20 <merijn> It's supposed to call itself
21:12:28 <johnw> did that, but it says invalid argument
21:12:34 <johnw> should I be passing something to run it?
21:12:46 <merijn> No
21:12:55 <johnw> ok, then no workie
21:13:17 <merijn> So you named the file T8089.hs and compiled and when you run "./T8089" it says... what?
21:13:31 <johnw> ghc783:[johnw@Hermes:~/dl]$ ./T8089
21:13:31 <johnw> T8089: select: Invalid argument
21:13:39 <merijn> oh, duh
21:14:02 <merijn> That's the bug I'm testing for :p
21:14:19 <merijn> And silly me forgot that you don't have a fix for that :p
21:14:49 <merijn> Try replacing maxBound with 20000000
21:16:29 <johnw> with and without -threaded, it takes 20s to run
21:16:51 <merijn> -fforce-recomp in between?
21:16:57 <johnw> i think we've reached my limit
21:17:02 <johnw> i've got work to get back to
21:17:27 <merijn> ok
21:43:37 <dfeuer_> Am I thinking stupid, or is listToMaybe $ map fst $ filter (null . snd)  just the same as fmap fst . find (null . snd) ?
21:44:55 <Cale> dfeuer_: apart from the fact that the first one is a type error because of the $'s, yeah
21:45:06 <dfeuer_> er ...
21:45:17 <dfeuer_> Sorry, Cale, there's something else that comes after that.
21:45:33 <dfeuer_> So it's not a type error in context.
21:46:15 <Cale> I knew what you meant anyway :)
21:46:49 <Cale> (I'm just still a bit salty about $ having the wrong associativity ;)
21:47:02 <dfeuer_> Wrong, Cale?
21:48:40 <dfeuer_> Waaaaat.
21:48:48 <Cale> dfeuer_: Yeah, function application normally associates to the left, i.e. f x y z is ((f x) y) z
21:48:53 <dfeuer_> By which I mean WAAAAAT.
21:49:03 <dfeuer_> Cale, look at the definition of "find".
21:49:16 <Cale> So it would make sense for ($) and ($!) to also associate to the left, despite their low precedence
21:49:52 <dfeuer_> Cale, but people use $ to get things associating the other way, right?
21:51:43 <Cale> dfeuer_: When they chain it
21:52:28 <Cale> dfeuer_: I mostly avoid chaining it like that, because I like seeing the function composition anyway, and function composition is associative, so it makes editing the code later a little easier, since you can chop parts out and they'll still typecheck and mean what they ought to
21:52:48 <dfeuer_> Hmm.
21:53:00 <Cale> Having it be left associative would mean that you could get rid of all the parens in  f (g x) (h y) (k z)
21:53:01 <dfeuer_> So how would you take advantage of it associating the other way?
21:53:08 <dfeuer_> Oh.
21:53:14 <dfeuer_> Hmm.
21:53:16 <dfeuer_> Interesting.
21:53:39 <Cale> It would also be less annoying to use in conjunction with $! with multi-argument functions
21:54:33 <dfeuer_> Now that is a good point.
21:55:02 <dfeuer_> (a $! b) c is kind of yucky.
21:55:06 <Cale> yeah
21:55:45 <dfeuer_> Is it just me, or is using listToMaybe kind of ... sloppy?
21:56:07 <Cale> Some people really like just being able to stick  "foo $ " on the start of something without thinking about the rest of the expression though, and I can kind of understand that
21:56:07 <dfeuer_> Or distasteful?
21:56:28 <Cale> I dunno, it mostly just has a rather awkward name
21:56:58 <Cale> The concept it embodies feels like it should take fewer characters to express somehow :D
21:57:01 <dfeuer_> To my mind, it's not nice because it creates the idea of a data structure that isn't ever actually needed.
21:57:26 <Cale> Well, that can be totally fine
21:57:28 <dfeuer_> Or to put it better, a data structure that's better thought of as something else.
21:57:57 <nshepperd> isn't listToMaybe just safeHead?
21:58:02 <Cale> Often you might have a complete solution to a problem which gives a whole list of possibilities, but you only need at most one
21:58:03 <dfeuer_> Yes.
21:58:34 <Cale> Frequently I'll skip the listToMaybe and just case on [] and (x:_)
21:58:43 <dfeuer_> Yes, Cale, but other times you don't.
21:58:51 <dfeuer_> Well, I guess you do.
21:58:54 <dfeuer_> But ...
21:59:14 <Cale> Laziness is all about compositionality and taking advantage of situations where a library can already give you more than what you need
21:59:22 <Cale> and not having to pay for it all
21:59:30 <dfeuer_> You know what the problem is?
21:59:35 <dfeuer_> One second....
22:00:49 <nshepperd> well, arguably we should have 'the :: [a] -> Maybe a' as well
22:01:16 <nshepperd> that one verifies that all results are identical, then returns that result
22:01:34 <dfeuer_> Yeah, Cale, the problem is that Data.Maybe doesn't have a nice function (that I think does exist somewhere)  foo p x = if p x then Just x else Nothing
22:02:45 <dfeuer_> OK, yeah, I knew it. I asked about this myself on SO: http://stackoverflow.com/questions/24644032/does-this-bool-producer-to-maybe-producer-function-appear-in-any-common-library
22:04:34 <BMeph> :t (return . ).when
22:04:34 <lambdabot> (Monad m1, Monad m) => Bool -> m1 () -> m (m1 ())
22:05:53 <dfeuer_> Cale, with partial :: (a -> Bool) -> a -> Maybe a, find p = getFirst . foldMap (First . partial p)
22:10:49 * hackagebot github-post-receive 1.0.2.0 - Github post-receive server library  http://hackage.haskell.org/package/github-post-receive-1.0.2.0 (ShoheiYasutake)
22:11:24 <southp> Hi. I clone quine https://github.com/ekmett/quine down and run cabal install --only-dependencies in its directory. It popped up an error:
22:11:27 <southp> cabal: Could not resolve dependencies:
22:11:27 <southp> trying: quine-0.1 (user goal)
22:11:27 <southp> next goal: gl (dependency of quine-0.1)
22:11:29 <southp> rejecting: gl-0.3, 0.2, 0.1 (conflict: quine => gl>=0.5)
22:11:31 <southp> Dependency tree exhaustively searched.
22:11:46 <southp> How can I resolve this?
22:13:09 <johnw> surely there is more output
22:13:17 <dfeuer_> southp, I don't actually have a clue, but what version of GHC are you running? I would guess maybe the very bleeding edge quine needs more recent stufff?
22:13:30 <johnw> I'm missing the line that tells me which package is constraining gl < 0.4
22:14:09 <southp> dfeuer_:  ghc --version show 7.8.3
22:14:21 <johnw> southp: did you see my comments?
22:14:38 <dfeuer_> johnw knows a lot more about this than I do.
22:15:13 <johnw> the paste the whole output from cabal
22:15:36 <southp> johnw: Yes, but that's all the output I see. Is there a verbose option I should use?
22:15:48 <johnw> oh, nothing more than that?
22:15:49 * hackagebot conduit 1.2.2 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.2.2 (MichaelSnoyman)
22:15:51 * hackagebot conduit-combinators 0.3.0 - Commonly used conduit functions, for both chunked and unchunked data  http://hackage.haskell.org/package/conduit-combinators-0.3.0 (MichaelSnoyman)
22:16:01 <liyang> southp: quine is in quite a lot of flux. You'd be better off asking in #haskell-lens where edwardk lives.
22:16:13 <southp> Yes. Only those lines.
22:16:21 <johnw> southp: what does "cabal install gl" do?
22:16:32 <edwardk> southp: gl 0.5 was released this evening
22:16:37 <edwardk> southp: you need to cabal update
22:16:38 <johnw> ah
22:16:40 <edwardk> then you can cabal install
22:16:41 <johnw> thanks edw
22:16:42 <johnw> ardk
22:16:59 <southp> Ah
22:17:05 <southp> I didn't do cabal update
22:17:12 <edwardk> southp: thats the culprit =)
22:17:32 <edwardk> southp: gl 0.5 was released to enable us to support windows for gl. i haven't tried building quine there yet
22:18:05 <edwardk> southp: not sure what platform you are on
22:18:21 <southp> edwardk: Thanks a lot : ) I'll try it now.
22:18:30 <edwardk> it has been successfully loaded on linux and mac so far
22:18:40 <southp> edwardk: Ah. I'm on OSX, though. So I should me fine.
22:19:36 <edwardk> southp: not too much to see other than some simple shader toys in there yet. i've been focused on 'setting my house in order' with regards to getting a more productive opengl set up sofar
22:20:08 <edwardk> once i know what the gl API i want to use when i grow up will look like, then quine can proceed apace ;)
22:20:48 <southp> edwardk: I think that's already tons of things I want to study for : )
22:20:55 <dfeuer_> Ooh, that's not good....
22:22:13 <southp> edwardk: I'm a long term C/C++ programmer and want to discover possibilities of developing high performance native programs via haskell. Especially graphics.
22:23:41 <merijn> Out of curiousity, does anyone know if there's an easy way to build the runtime system with debug symbols?
22:23:53 <sujeet> C and C++ programmers don't like writing "C/C++" ;)
22:23:53 <edwardk> not sure the style there is something to copy yet, but it is developing fairly quickly
22:24:56 <edwardk> absolutely. c / c++ -- is undefined behavior. did the c post-increment happen before or after you divided by c? who knows!
22:25:32 <edwardk> (i should have avoided the haskell -- comment there, that makes that much more terrifying looking)
22:25:54 <southp> lol
22:27:39 <southp> Nice points. C and C++ are getting far and far away both in culture and in the language itself these days.
22:30:10 <dfeuer_> southp, one thing to know is that playing with bitwise operations is a lot easier in Haskell than in C.
22:30:47 <dfeuer_> But you can't play pointer games as much if you want to stay sane.
22:31:43 <merijn> dfeuer_: I don't suppose you know how to build the RTS with debug symbols? :>
22:31:50 <southp> dfeuer_: Is there a sample of bitwise operations in action in Haskell? I'm a super curios about it : )
22:32:26 <dfeuer_> merijn, no, no idea.
22:32:34 <dfeuer_> southp, just look up Data.Bits.
22:33:11 <dfeuer_> But also note that countLeadingZeros and countTrailingZeros (however they're spelled) are on their way in the next version.
22:34:45 <southp> dfeuer_: Ok. I'll look up for it : )
22:34:50 <Enigmagic> merijn: ghc -debug will use an RTS with debug symbols
22:35:14 <merijn> Enigmagic: Yes, but how do I compile an RTS with debug symbols? :)
22:35:37 <dfeuer_> southp, two particularly pleasant things: 1. Haskell counts in bits, not in bytes. 2. Haskell doesn't have C's utterly baffling automatic promotion rules.
22:35:47 <Enigmagic> merijn: any rts, or the regular rts? the debug rts has debug symbols in it..
22:36:25 <merijn> Enigmagic: The debug rts has debug symbols, but that doesn't tell me how to compile the debug rts after changing the code :)
22:36:39 <Enigmagic> merijn: make?
22:37:32 <southp> dfeuer_: These two are solid enough to make the point :D
22:38:55 <merijn> Enigmagic: Ah, looks like it may "Just Work" :)
22:39:35 <Enigmagic> merijn: yep. if you want to enable debug symbols for the non-debug build (it doesn't hurt anything really) just take a peek at rts/ghc.mk
22:40:47 <merijn> Right, now onto the grizzly work...
22:52:31 <maybefbi> what are the type of objects in a category?
22:52:58 <maybefbi> should all the objects in a category be of the same type?
22:57:13 <Cale> maybefbi: Is that, like, a pure category theory question?
22:57:38 <maybefbi> Cale, yeah. and also how are things different in haskell
22:57:45 <Cale> maybefbi: If you're working in a type theory, perhaps you'd want the objects in a category to form a type
22:58:17 <maybefbi> Cale, so in pure category theory the objects can be of different types?
22:58:35 <Cale> It kind of doesn't matter what the objects in a category are
22:58:39 <Cale> they're just labels
22:58:53 <Cale> To help you know which arrows can be composed
22:59:32 <Cale> It's the arrows (and how they compose) which matters
22:59:50 <Cale> and even the arrows need not have any internal structure
22:59:54 <maybefbi> Cale, but surely arrows need objects as inputs to become other objects don't they? why aren't we talking about the objects
23:00:16 <Cale> "inputs"?
23:00:22 <Cale> The arrows need not be functions
23:00:26 <Cale> They often are
23:00:39 <maybefbi> what else can they be?
23:01:15 <Cale> Well, okay, here's a good class of example categories to keep in mind:
23:01:46 <Cale> A preorder on a set S is a relation <= such that the following is true:
23:01:55 <Cale> for any a in S, we have a <= a
23:02:17 <Cale> and for any a, b, c in S, whenever a <= b and b <= c, then a <= c
23:03:00 <Cale> (Note that we are allowed by this definition to have distinct a and b for which a <= b and b <= a)
23:03:16 <Cale> So, if we have a preordered set, we can turn it into a category
23:03:23 <Cale> whose objects are the elements of S
23:03:47 <Cale> and where we put a single arrow a -> b whenever a <= b and no other arrows
23:04:44 <Cale> Note that because of the rule which says that for every a, we have a <= a, we're guaranteed there's an arrow a -> a which can serve as the identity arrow on a
23:05:30 <Cale> and because of the rule that says whenever we have a <= b and b <= c, we must have a <= c, we're guaranteed that whenever there's an arrow a -> b and b -> c, there will be an arrow a -> c to serve as the composite
23:06:00 <Cale> (and because there's exactly one such arrow by definition, we have no choice about what it is)
23:06:43 <maybefbi> Cale, i can think of <= as a function of the type :: t -> t -> Bool
23:06:48 <Cale> and the equational laws for a category (the identity and associativity) hold also because of the uniqueness of arrows between any given pair of objects when they exist
23:07:03 <Cale> maybefbi: You can think of lots of stuff as functions
23:07:24 <Cale> But an arrow a -> b in this category is pretty hard to think of as a function in a non-contrived way
23:08:24 <Cale> After all, it's just telling you that a <= b is true. That piece of information isn't easily regarded as a function, is it?
23:09:44 <Cale> Certainly not as a function whose domain is a and whose codomain is b -- we're not even supposed to really be thinking of a and b as sets here (even though in a set theoretical presentation they would be, this fact is irrelevant)
23:10:42 <Cale> So, as a concrete example, I can define a category with objects {Apple, Blueberry, Cherry}
23:11:29 <maybefbi> Cale, what are the morphisms (or arrows) in that category
23:11:39 <Cale> and arrows id_X: X -> X for each object X, as well, say, as f: Apple -> Blueberry, g: Blueberry -> Cherry and h: Apple -> Cherry
23:11:49 <Cale> and such that g . f = h
23:12:02 <Cale> and the identity arrows compose as identity arrows ought to
23:12:27 <Cale> So, this is just a commutative triangle that I've put some labels on
23:12:45 <Cale> The labels don't really matter, what matters is the shape, and how the arrows compose
23:13:38 <maybefbi> Cale, hmm ok as a mere mortal, i cannot come up with a definition for how f, g, and h works. they just are, well arrows.
23:13:56 <maybefbi> Cale, but as harry potter, perhaps i can think of f, g, and h as spells
23:14:02 <dfeuer_> Och. I wish I were properly awake and focused when Cale was talking about category theory.
23:14:29 <Cale> http://tartarus.org/simon/2008-olympics-hasse/ -- as another example, here's a partially ordered set derived from the 2008 Olympic results
23:14:33 <maybefbi> Cale, the spells can in turn be thought of as functions
23:14:57 <nshepperd> "f = France, g = Italy, h = Barack Obama" is perfectly consistent
23:15:00 <Cale> and a diagram which looks quite a bit like the diagram for the corresponding category, only it misses out all the composite arrows
23:15:17 <Cale> (and the identities)
23:15:43 <nshepperd> Barack Obama doesn't turn Apple into Cherry, in any sense, but you can still assign him as an arrow in the category
23:15:46 <Cale> (also the arrows are kind of pointing in the "wrong" direction, but we don't really care about which direction they point)
23:16:37 <Cale> It's conventional that the arrows usually head in the direction of larger things when considering orderings as categories, but you can reverse all the arrows in a category to obtain another one
23:16:55 <Cale> (and similarly you can reverse an ordering)
23:18:49 <Cale> So another example: A monoid is a set M together with an operation called multiplication *: M x M -> M, subject to the conditions that:
23:19:09 <Cale> There is an element 1 in M so that for any a in M we have a * 1 = 1 * a = a
23:19:25 <Cale> For any a, b, c in M, we have a * (b * c) = (a * b) * c
23:20:15 <Cale> Kind of like how we turned a preorder into a category with many objects, but at most one arrow between any pair of objects, we can turn a monoid into another sort of edge case of the definition of a category
23:20:39 <Cale> Where we have just one object, it actually doesn't matter what we call it, but I'll call it O
23:21:03 <Cale> and the arrows O -> O are the elements of the monoid M
23:21:21 <Cale> and composition of arrows is defined as multiplication in the monoid
23:21:49 <Cale> So, for example, the natural numbers are a monoid under their usual multiplication
23:22:11 <Cale> So we can form a category with a single object, and where the arrows from that object to itself are natural numbers
23:22:47 <Cale> and composition is given by multiplication, so e.g. 2 . 3 = 6
23:23:02 <Cale> There is an identity arrow, which is simply 1 :)
23:23:30 <Cale> maybefbi: Does all of that make sense? Any confusion?
23:24:21 <maybefbi> Cale, as a personal preference, i still tend to think of arrows in a partially ordered set as functions of type :: t -> t -> Bool, but  a category with objects {Apple, Blueberry, Cherry} in which arrows id_X: X -> X for each object X, as well, say, as f: Apple -> Blueberry, g: Blueberry -> Cherry and h: Apple -> Cherry makes the idea of a category more clear for me. it doesnt matter if the arrows refer to processes which transform an
23:24:21 <maybefbi> Apple to a Cherry. the arrows can be anything arbitrary, in other words we dont care about what the arrows are, only where they begin and where they end.
23:24:49 <maybefbi> and whether the arrows compose
23:25:03 <Cale> maybefbi: Yeah, and we do need to be able to tell apart arrows which have the same source and target
23:25:30 <Cale> But aside from the need to tell them apart, the names or internal structure is not category theory's concern
23:26:08 <maybefbi> Cale, so in a way category theory is more abstract than type theory, where we worry about the types of objects and arrows
23:26:38 <Cale> Well, when we look at a type theory in a categorical sort of way, to a first approximation, the types become objects, and the functions between those types become arrows
23:26:39 <maybefbi> we just care about the topology of the network of arrows and what they point to
23:27:27 <Cale> and how the arrows compose
23:27:42 <maybefbi> yeah they have to compose or else it is not a category
23:27:59 <maybefbi> and in a monoid there is always an arrow from an object to itself
23:28:06 <Cale> Given f: A -> B, g: B -> C, and h: A -> C, we can ask whether or not g . f = h
23:28:22 <maybefbi> Cale, yes
23:28:40 <Cale> In the preorder example, this was automatic, because the way we built our category had at most one arrow between any pair of objects
23:29:07 <Cale> but in a category whose objects are sets and whose arrows are functions between those sets, there will be many different functions in general between any pair of sets
23:29:10 <maybefbi> yeah but the {Apple, Blueberry, Cherry} it was not automatic
23:29:21 <Cale> Actually, it was sort of automatic there too
23:29:44 <Cale> because I only defined one arrow Apple -> Cherry, so if my list was exhaustive, then that would have to be the composite
23:29:48 <maybefbi> because you called it a category and there was only three objeccts
23:29:50 <maybefbi> yeah
23:30:21 <Cale> But I could have put in another arrow there somewhat arbitrarily
23:30:56 <Cale> and then we'd want to know which of the two arrows Apple -> Cherry was the composite of f: Apple -> Blueberry and g: Blueberry -> Cherry
23:32:01 <maybefbi> hmm real category theory is not like haskell category theory
23:32:16 <Cale> Sometimes we're only concerned with whether or not there's an arrow X -> Y in a category, and sometimes we're very concerned about which arrow it is
23:32:35 <Cale> Well, it's an abstraction which flattens out into Haskell in a peculiar way
23:33:13 <Cale> If you only look at category theory concepts through the lens of Haskell, they'll be distorted in a way which makes certain features clearer, but hides others altogether
23:33:50 <Cale> But that's sort of true of all the places where category theory gets applied
23:34:10 <maybefbi> Cale, ok
