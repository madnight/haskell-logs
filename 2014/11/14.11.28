00:01:27 <peropaal> fine
00:28:20 <codygman> Anyone know of a good snap/heist splices tutorial?
00:49:17 <CARAM_> i have a `m a` and want to turn it into `m [a]`
00:49:57 <CARAM_> singleton list
00:50:10 <CARAM_> I want something like `fmap return ma` ?
00:50:44 <capisce> yep
00:51:29 <sgronblo> isnt it sequence?
00:51:35 <sgronblo> no
00:51:46 <capisce> fmap (return :: a -> [a]) ma
00:51:51 <CARAM_> oh, I was missing a parenthesis, that's why it wasn't working
00:51:55 <sgronblo> you just wanna fmap
00:52:07 <CARAM_> thanks!!
00:53:03 <capisce> does Haskell have another way of specifying the instance?
00:53:19 <capisce> if I want to refer to the return in the List monad, or in the Maybe monad for instance
00:53:29 <capisce> without mentioning the entire function signature
00:53:39 <CARAM_> caspice fwiw I didn't have to specify
00:53:52 <CARAM_> it just knew, ~magically~
00:53:53 <capisce> sure
00:54:10 <ThreeOfEight> capisce: well you can do fmap return ma :: [a]
00:54:17 <ThreeOfEight> er
00:54:18 <capisce> true
00:54:29 <ThreeOfEight> fmap return ma :: f [ma]
00:54:49 <ThreeOfEight> I sometimes wish Haskell had dummy patterns in types
00:54:59 <ThreeOfEight> i.e. (+) :: Int -> _
00:56:00 <capisce> if ma is some complicated type it's still verbose though
00:56:18 <capisce> fmap return (Just 2) :: Maybe [Int]
00:56:43 <ThreeOfEight> well the best solution is to have a type context that forces it to be specific
00:56:51 <ThreeOfEight> or to leave it polymorphic if there isn't
00:57:01 <ThreeOfEight> but occasionally, this /is/ a pain and you /have/ to annotate a type
00:57:01 <sgronblo> fmap (:[])
00:57:26 <ThreeOfEight> I don't think there is a better solution though
00:57:44 <ThreeOfEight> in Scala, you can do this, because their ‘typeclasses’ are based on implicit parameters
00:57:55 <sgronblo> cons not good enough?
00:58:06 <ThreeOfEight> so you can just ‘tell’ the return what instance to use, and when you don't, it tries to find one automatically
00:58:16 <ThreeOfEight> I've missed this functionality in Haskell occasionally
00:58:26 <capisce> sgronblo: I'm talking about the generic case
00:58:56 <sivteck> you can reduce 2 characters with pure ;d
00:59:11 <capisce> would be nice if you could partially specify the type too
00:59:22 <sgronblo> but cons is generic?
01:00:35 <capisce> sgronblo: cons is the specific instance of return for the List monad
01:01:22 <sgronblo> but he wanted to turn a to [a]?
01:01:58 <capisce> sgronblo: sure, I thought you were replying to the discussion between me and ThreeOfEight
01:03:24 <sgronblo> ah no, i was trying to help CARAM_
01:04:47 * hackagebot objective 0.5.2.1 - Extensible objects  http://hackage.haskell.org/package/objective-0.5.2.1 (FumiakiKinoshita)
01:19:47 * hackagebot extensible-effects 1.8.0.0 - An Alternative to Monad Transformers  http://hackage.haskell.org/package/extensible-effects-1.8.0.0 (shergill)
02:08:59 <narendraj9> > let n = 12; [n | n > 0]
02:09:00 <lambdabot>  <hint>:1:24:
02:09:01 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
02:09:42 <sivteck> > let n = 12 in [n | n > 0]
02:09:44 <lambdabot>  [12]
02:10:43 <narendraj9> I don't know how to think about list comprehensions with no generators. I thought this won't generate anything.
02:11:06 <narendraj9> Can someone desugar it please?
02:12:20 <narendraj9> *I thought it would generating [], i.e Nothing
02:12:55 <CindyLinz> > [10 |]
02:12:56 <jaspervdj> narendraj9: let n = 12 in guard (n > 0) >> return n
02:12:56 <lambdabot>  <hint>:1:6: parse error on input ‘]’
02:13:03 <CindyLinz> > [10 | True ]
02:13:04 <lambdabot>  [10]
02:13:14 <CindyLinz> > [10 | False ]
02:13:15 <lambdabot>  []
02:14:09 <supki_> @undo let n = 12 in [n | n > 0]
02:14:09 <lambdabot> let { n = 12} in if n > 0 then [n] else []
02:15:22 <narendraj9> do { if n > 0 then [n] else [] }; Okay I see.
02:15:25 <sivteck> > let n = 12 in return (n > 0) >>= \r -> case r of True -> return n
02:15:27 <lambdabot>  No instance for (GHC.Show.Show (m0 b0))
02:15:27 <lambdabot>    arising from a use of ‘M145201553683664724814252.show_M1452015536836647248...
02:15:27 <lambdabot>  The type variables ‘m0’, ‘b0’ are ambiguous
02:15:27 <lambdabot>  Note: there are several potential instances:
02:15:27 <lambdabot>    instance [safe] GHC.Show.Show a =>
02:15:30 <sivteck> ;o
02:15:50 <shachaf> narendraj9: do { guard (n > 0); return n }
02:16:35 <sivteck> > let n = 12 in return (n > 0) >>= \r -> case r of True -> return n :: [Int] -- horrible way
02:16:38 <lambdabot>  [12]
02:17:19 <narendraj9> guard is not in scope. I think I should google this. :-D
02:17:41 <shachaf> You can get it from Control.Monad.
02:18:02 <narendraj9> shachaf: Thanks.
02:18:15 <shachaf> guard False = []; guard True = [()]
02:18:23 <shachaf> (In the case of lists.)
02:19:39 <narendraj9> Okay. I see. It's the failure that must pass down the >>= if it happens. Else we just move one.
02:19:46 <narendraj9> *move on
02:21:08 <narendraj9> [] ==> failure . Pardon the strange sentence.
02:21:21 <narendraj9> I got it. Thanks.
02:22:17 <narendraj9> I don't know if pardon can be a transitive verb. I guess I used it like that for the first time.
02:22:18 <narendraj9> :-D
02:24:44 <narendraj9> Correction: Pardon me for the strange sentence.
02:39:50 * hackagebot check-email 1.0 - Confirm whether an email is valid and probably existant.  http://hackage.haskell.org/package/check-email-1.0 (ChrisDone)
02:44:50 * hackagebot pdfinfo 1.5.1 - Wrapper around the pdfinfo command.  http://hackage.haskell.org/package/pdfinfo-1.5.1 (ChrisDone)
02:49:51 * hackagebot shell-conduit 4.5 - Write shell scripts with Conduit  http://hackage.haskell.org/package/shell-conduit-4.5 (ChrisDone)
02:59:51 * hackagebot alarmclock 0.2.0.3 - Wake up and perform an action at a certain time.  http://hackage.haskell.org/package/alarmclock-0.2.0.3 (dcturner)
03:09:51 * hackagebot gitcache 0.1 - Simple git utility to use and manage clone cache  http://hackage.haskell.org/package/gitcache-0.1 (VincentHanquez)
03:19:52 * hackagebot call 0.1.1.1 - The call game engine  http://hackage.haskell.org/package/call-0.1.1.1 (FumiakiKinoshita)
03:37:52 <Zol_> Yes! I finally managed to type (.)(.) manually!
03:38:44 <Zol_> It worked MUCH easier if I converted it from (.)(.) to (\g x -> (\g2 x2 -> g x (g2 x2))) and then tried to type that.
03:42:28 <egoldsten> you know what it looks like ...
03:51:48 <haskell197> Hey, how can I download the channel logs?
03:52:15 <indiagreen> haskell197: http://tunes.org/~nef/logs/haskell/?C=M;O=D
03:52:35 <haskell197> Sick, thaks
03:52:38 <haskell197> *thanks
04:04:53 * hackagebot ace 0.6 - Attempto Controlled English parser and printer  http://hackage.haskell.org/package/ace-0.6 (ChrisDone)
04:06:43 <egoldsten> I found that on hacker news https://gist.github.com/quchen/5280339
04:09:08 <egoldsten> "C is difficult in a non-rewarding way while Haskell is difficult in very rewarding ways, imo. " I think it is true.
04:09:54 * hackagebot amazonka-core 0.0.6 - Core functionality and data types for Amazonka libraries.  http://hackage.haskell.org/package/amazonka-core-0.0.6 (BrendanHay)
04:09:56 * hackagebot amazonka 0.0.6 - Comprehensive Amazon Web Services SDK  http://hackage.haskell.org/package/amazonka-0.0.6 (BrendanHay)
04:09:58 * hackagebot amazonka-autoscaling 0.0.6 - Amazon Auto Scaling SDK.  http://hackage.haskell.org/package/amazonka-autoscaling-0.0.6 (BrendanHay)
04:10:00 * hackagebot amazonka-cloudformation 0.0.6 - Amazon CloudFormation SDK.  http://hackage.haskell.org/package/amazonka-cloudformation-0.0.6 (BrendanHay)
04:10:02 * hackagebot amazonka-cloudfront 0.0.6 - Amazon CloudFront SDK.  http://hackage.haskell.org/package/amazonka-cloudfront-0.0.6 (BrendanHay)
04:15:04 * hackagebot amazonka-cloudsearch 0.0.6 - Amazon CloudSearch SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-0.0.6 (BrendanHay)
04:15:06 * hackagebot amazonka-cloudsearch-domains 0.0.6 - Amazon CloudSearch Domain SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-domains-0.0.6 (BrendanHay)
04:15:08 * hackagebot amazonka-cloudtrail 0.0.6 - Amazon CloudTrail SDK.  http://hackage.haskell.org/package/amazonka-cloudtrail-0.0.6 (BrendanHay)
04:15:10 * hackagebot amazonka-cloudwatch 0.0.6 - Amazon CloudWatch SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-0.0.6 (BrendanHay)
04:15:12 * hackagebot amazonka-cloudwatch-logs 0.0.6 - Amazon CloudWatch Logs SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-logs-0.0.6 (BrendanHay)
04:20:14 * hackagebot amazonka-codedeploy 0.0.6 - Amazon CodeDeploy SDK.  http://hackage.haskell.org/package/amazonka-codedeploy-0.0.6 (BrendanHay)
04:20:16 * hackagebot amazonka-cognito-identity 0.0.6 - Amazon Cognito Identity SDK.  http://hackage.haskell.org/package/amazonka-cognito-identity-0.0.6 (BrendanHay)
04:20:18 * hackagebot amazonka-cognito-sync 0.0.6 - Amazon Cognito Sync SDK.  http://hackage.haskell.org/package/amazonka-cognito-sync-0.0.6 (BrendanHay)
04:20:20 * hackagebot amazonka-config 0.0.6 - Amazon Config SDK.  http://hackage.haskell.org/package/amazonka-config-0.0.6 (BrendanHay)
04:20:22 * hackagebot amazonka-datapipeline 0.0.6 - Amazon Data Pipeline SDK.  http://hackage.haskell.org/package/amazonka-datapipeline-0.0.6 (BrendanHay)
04:23:12 <thungsten> egoldsten: that was awesome
04:24:18 <egoldsten> yes funny!
04:25:20 <egoldsten> you some people feel haskell or fp as an aggression against them I felt that also at a time
04:25:24 * hackagebot amazonka-directconnect 0.0.6 - Amazon Direct Connect SDK.  http://hackage.haskell.org/package/amazonka-directconnect-0.0.6 (BrendanHay)
04:25:25 <egoldsten> know
04:25:26 * hackagebot amazonka-emr 0.0.6 - Amazon Elastic MapReduce SDK.  http://hackage.haskell.org/package/amazonka-emr-0.0.6 (BrendanHay)
04:25:28 * hackagebot amazonka-iam 0.0.6 - Amazon Identity and Access Management SDK.  http://hackage.haskell.org/package/amazonka-iam-0.0.6 (BrendanHay)
04:25:30 * hackagebot amazonka-importexport 0.0.6 - Amazon Import/Export SDK.  http://hackage.haskell.org/package/amazonka-importexport-0.0.6 (BrendanHay)
04:25:32 * hackagebot amazonka-kinesis 0.0.6 - Amazon Kinesis SDK.  http://hackage.haskell.org/package/amazonka-kinesis-0.0.6 (BrendanHay)
04:29:12 <Zol_> I'm trying to convert (($)$($)) into a lambda notation, so I got let f3 = \x -> (\f1 x1 -> f1 x1) x, for example. The type is (a -> b) -> a -> b, but I wonder, does that mean that x is of type (a -> b) or is it f1? I am not sure if I should start from the inner most lambda or the outer most lambda when trying to do the typing.
04:29:53 <Zol_> When I did (.)(.), it seemed to me that the outer most way was the correct choice.
04:30:34 * hackagebot amazonka-kms 0.0.6 - Amazon Key Management Service SDK.  http://hackage.haskell.org/package/amazonka-kms-0.0.6 (BrendanHay)
04:30:36 * hackagebot amazonka-lambda 0.0.6 - Amazon Lambda SDK.  http://hackage.haskell.org/package/amazonka-lambda-0.0.6 (BrendanHay)
04:30:38 * hackagebot amazonka-opsworks 0.0.6 - Amazon OpsWorks SDK.  http://hackage.haskell.org/package/amazonka-opsworks-0.0.6 (BrendanHay)
04:30:40 * hackagebot amazonka-rds 0.0.6 - Amazon Relational Database Service SDK.  http://hackage.haskell.org/package/amazonka-rds-0.0.6 (BrendanHay)
04:30:42 * hackagebot amazonka-redshift 0.0.6 - Amazon Redshift SDK.  http://hackage.haskell.org/package/amazonka-redshift-0.0.6 (BrendanHay)
04:30:54 * Zol_ peers at hackagebot suspisciously.
04:31:09 <brnhy> Sorry :)
04:31:23 * Zol_ grins.
04:34:54 <Haskellfant> Zol_: isn't ($) $ ($) just $
04:35:16 <shiona_> :t ($) $ ($)
04:35:17 <lambdabot> (a -> b) -> a -> b
04:35:39 <Haskellfant> in lambdas \f a -> f a
04:35:41 <Zol_> Haskellfant: Sure, but I find it hard to tell just by looking. Part of my exam is to figure out types for different stuff.
04:35:44 * hackagebot amazonka-route53 0.0.6 - Amazon Route 53 SDK.  http://hackage.haskell.org/package/amazonka-route53-0.0.6 (BrendanHay)
04:35:46 * hackagebot amazonka-route53-domains 0.0.6 - Amazon Route 53 Domains SDK.  http://hackage.haskell.org/package/amazonka-route53-domains-0.0.6 (BrendanHay)
04:35:48 * hackagebot amazonka-s3 0.0.6 - Amazon Simple Storage Service SDK.  http://hackage.haskell.org/package/amazonka-s3-0.0.6 (BrendanHay)
04:35:50 * hackagebot amazonka-sdb 0.0.6 - Amazon SimpleDB SDK.  http://hackage.haskell.org/package/amazonka-sdb-0.0.6 (BrendanHay)
04:35:52 * hackagebot amazonka-ses 0.0.6 - Amazon Simple Email Service SDK.  http://hackage.haskell.org/package/amazonka-ses-0.0.6 (BrendanHay)
04:36:04 <Haskellfant> Zol_: ah so you want to convert it to lambdas to undertand the type?
04:36:14 <Zol_> Haskellfant: Yeah, so far that has been my best approach
04:37:50 <Zol_> Haskellfant: Aha, looks like my lambda conversion was wrong.
04:38:07 <Haskellfant> just substitute one argument after the other
04:38:12 <Haskellfant> start with $
04:38:13 <Haskellfant> :t ($)
04:38:14 <lambdabot> (a -> b) -> a -> b
04:38:20 <Haskellfant> so in lambdas thats \f a -> f a
04:38:27 <Haskellfant> now you apply ($) to it
04:38:35 <Haskellfant> so you get \a -> f a
04:38:59 <Haskellfant> a is the first argument ($) takes
04:39:05 <Haskellfant> so it has type (a->b)
04:39:13 <Haskellfant> so \a -> f a has type (a->b)->a->b
04:39:20 <Haskellfant> now substitute the last ($)
04:39:29 <Haskellfant> need to go, good luck :)
04:39:34 <Zol_> Haskellfant: Thanks
04:40:54 * hackagebot amazonka-sns 0.0.6 - Amazon Simple Notification Service SDK.  http://hackage.haskell.org/package/amazonka-sns-0.0.6 (BrendanHay)
04:40:56 * hackagebot amazonka-sqs 0.0.6 - Amazon Simple Queue Service SDK.  http://hackage.haskell.org/package/amazonka-sqs-0.0.6 (BrendanHay)
04:40:58 * hackagebot amazonka-storagegateway 0.0.6 - Amazon Storage Gateway SDK.  http://hackage.haskell.org/package/amazonka-storagegateway-0.0.6 (BrendanHay)
04:41:00 * hackagebot amazonka-sts 0.0.6 - Amazon Security Token Service SDK.  http://hackage.haskell.org/package/amazonka-sts-0.0.6 (BrendanHay)
04:41:02 * hackagebot amazonka-support 0.0.6 - Amazon Support SDK.  http://hackage.haskell.org/package/amazonka-support-0.0.6 (BrendanHay)
04:46:04 * hackagebot amazonka-swf 0.0.6 - Amazon Simple Workflow Service SDK.  http://hackage.haskell.org/package/amazonka-swf-0.0.6 (BrendanHay)
04:47:19 <AleksejsHome> hmm, is it possible to tell bot to import Math. Statistics?
05:07:57 <wz1000> I'm not really familiar with comonads, but can't extract be used like join? And if so, isn't an applicative comonad also a monad?
05:09:17 <clrnd> :t join
05:09:18 <lambdabot> Monad m => m (m a) -> m a
05:09:28 <wz1000> Is it that extract doesn't preserve the structure of the outer monad?
05:10:10 <wz1000> preserve is the wrong word, would 'consider' work?
05:10:21 <wz1000> :t extract
05:10:22 <lambdabot> Not in scope: ‘extract’
05:10:35 <wz1000> :t Comonad.extract
05:10:36 <lambdabot> Not in scope: ‘Comonad.extract’
05:10:46 <thungsten> :t (=>>)
05:10:47 <lambdabot>     Not in scope: ‘=>>’
05:10:47 <lambdabot>     Perhaps you meant one of these:
05:10:47 <lambdabot>       ‘>>’ (imported from Control.Monad.Writer),
05:10:55 <jaspervdj> Silly question: what does ACME refer to? As in the bunch of "joke" packages on Hackage under that category.
05:11:38 <bergmark> i think it's a looney tunes thing :-)
05:11:38 <shachaf> jaspervdj: Probably named after https://en.wikipedia.org/wiki/Perl#CPAN_Acme
05:12:12 <shachaf> (which is in turn named after Acme Corporation.)
05:12:24 <clrnd> http://fistfuloftalent.com/wp-content/uploads/2012/03/ACME-movie.jpg
05:12:38 <jaspervdj> shachaf: Right, I knew about the corporation but the Perl thing was the missing link for me, thanks :-)
05:19:20 <egoldsten> it's the text editor of Plan 9 Rob Pike likes to talk about it
05:25:11 <wz1000> Is join like going 'splat' and collapsing the structure while extract is like taking a slice?
05:26:38 <clrnd> wz1000, http://www.cl.cam.ac.uk/~dao29/drafts/monad-or-comonad-orchard11-draft.pdf
05:28:00 <Gurkenglas> http://lpaste.net/115281 <- gives "parse error on input '". What's wrong?
05:29:06 <AltaUni> Hey I know this code is wrong but I'm not sure how to go about it. I was tasked with using a higher order function to create a function that determines whether or not all elements of a list are even. I tried using a partial function that that didn't really work. Any ideas? http://pastebin.com/taePkcwb
05:29:13 <clrnd> wz1000, I like your question, I've never used Comonads but it sounds intriguing
05:29:18 <bergmark> Gurkenglas: you need a newline before the makeLenses call and you need to put {-# LANGUAGE TemplateHaskell #-} at the top of the file or compile with -XTemplateHaskell
05:29:42 <Raydiation> in lambda calculus is there a difference between \x.\y.x (y) and \x.\y.x y ?
05:30:08 <nshepperd> :t join . extend
05:30:09 <lambdabot> Not in scope: ‘extend’
05:30:29 <Gurkenglas> Thanks. (I tried that but apparently didnt give fpcomplete the seconds to say that it compiles before I gave up)
05:33:25 <clrnd> AltaUni, mmm that looks like it's missing some parens
05:33:33 <clrnd> :t foldr
05:33:34 <lambdabot> (a -> b -> b) -> b -> [a] -> b
05:33:57 <clrnd> foldr will take a function of 2 arguments, an initial value and the list
05:34:32 <AltaUni> Okay.
05:35:18 <belst> whats up with @pl
05:35:33 <clrnd> try something like: `foldr myFunction True`
05:35:43 <clrnd> and work out how myFunction looks like
05:35:49 <belst> @pl \x -> (head $ fst x, sum $ snd x)
05:35:49 <lambdabot> ap ((,) . head . fst) (sum . snd)
05:36:06 <belst> or @pl \(a,b) -> (head a, sum b)
05:36:12 <belst> @pl \(a,b) -> (head a, sum b)
05:36:12 <lambdabot> head *** sum
05:36:17 <clrnd> woah
05:36:28 <clrnd> that's okay, what's the problem?
05:36:37 <clrnd> :t (***)
05:36:37 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
05:36:41 <ferada> hi, i've rewritten a program using hxt here (http://lpaste.net/115278) and i'm wondering if that last function (coordinate) can be refactored into something smaller by applying the "field" function over a list/tuple of strings?
05:36:52 <belst> twice the same lambda, just once with patternmatching and once without
05:38:18 <clrnd> mmmm I think patter matching changes the semantics of the expresion a little ... maybe
05:38:37 <clrnd> :t let (a, b) = 5 in a
05:38:38 <lambdabot>     Could not deduce (Num (t, t0))
05:38:38 <lambdabot>       arising from the ambiguity check for ‘a’
05:38:38 <lambdabot>     from the context (Num (t, t1))
05:39:41 <belst> well
05:39:58 <belst> :t (\a -> (head $ fst a, sum $ snd a)
05:39:59 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
05:40:03 <belst> :t (\a -> (head $ fst a, sum $ snd a))
05:40:04 <lambdabot> Num t1 => ([t], [t1]) -> (t, t1)
05:40:20 <belst> :t (\(a,b) -> (head a, sum b))
05:40:21 <lambdabot> Num t1 => ([t], [t1]) -> (t, t1)
05:40:29 <alpounet> belst: you can leave out the outermost parens here
05:40:38 <alpounet> :t \(a, b) -> (head a, sum b)
05:40:39 <lambdabot> Num t1 => ([t], [t1]) -> (t, t1)
05:41:32 <exio4> :t head *** sum
05:41:33 <lambdabot> Num c' => ([a], [c']) -> (a, c')
05:41:42 <bergmark> ferada: just because of the keywords i feel obligated to mention our hxt list arrow package, not sure if it actually answers your question though! https://github.com/silkapp/xml-arrow
05:43:15 <ferada> bergmark: the example looks a bit nicer indeed, thanks
06:17:27 <angerman> how do I mark on executable to be an "example" in a cabal file. so that one needs to use a flag to get the example as well?
06:19:28 <ClaudiusMaximus> angerman: something like this iirc: if (exampleflag) buildable: True else buildable: False
06:20:30 <angerman> ClaudiusMaximus: buildable. Thanks.  No idea what I had to look for.
06:20:32 <zmbmartin> I see this patch for mkWeakTMVar for milestone 7.10, but how could I implement this now? https://ghc.haskell.org/trac/ghc/attachment/ticket/9169/0001-Add-mkWeakTMVar-to-Control.Concurrent.STM.TMVar.patch
06:21:44 <zmbmartin> I am getting an error about TMVar and TVar data const not in scope when I try to just use that code in the patch in my code.
06:24:59 * hackagebot iso639 0.1.0.2 - ISO-639-1 language codes  http://hackage.haskell.org/package/iso639-0.1.0.2 (HugoGomes)
06:26:42 <bitonic> zmbmartin: well, because that constructor is not in scope.  you'd have to copy the whole TMVar module
06:27:12 <bitonic> and maybe TVar too
06:29:42 <zmbmartin> bitonic: Bummer…
06:32:28 <zmbmartin> bitonic: I was hoping there was another way.
06:35:00 * hackagebot engine-io 1.2.3 - A Haskell implementation of Engine.IO  http://hackage.haskell.org/package/engine-io-1.2.3 (OliverCharles)
06:37:00 <wz1000> When I read books on algorithms written for languages like c and c++ I get very pissed off when they use global state. Are there any good books using a functional style?
06:37:40 <bergmark> @google purely functional data structures
06:37:42 <egoldsten> you cannot really avoid that
06:37:44 <lambdabot> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
06:37:53 <egoldsten> the stack is small
06:38:14 <wz1000> bergmark: I've read parts of it.
06:38:22 <dfeuer> Working on Data.Sequence is like wading through a swamp.
06:38:40 <dfeuer> A swamp full of alligators.
06:40:49 <dfeuer> Does edwardk have a package similar to `rope` but for non-bytestring stuff?
06:45:17 <osa1> can I send a signal to a process using ProcessHandle from `process` package?
06:45:30 <osa1> as far as I can see it doesn't provide any ways to get pid
06:48:13 <bitonic> osa1: without using `System.Process.Internals', I suppose
06:48:48 <osa1> bitonic: yeah
06:49:00 <osa1> bitonic: even if I use internals there isn't a function that returns PID
06:49:31 <osa1> I don't need pid, I just want to send signals to a process spawned using `process` package
06:50:29 <bitonic> osa1: you can get the Pid by opening ProcessHandle
06:50:38 <bitonic> or so it seems anyway, `type PHANDLE = CPid'
06:50:51 <osa1> bitonic: what do you mean by openning ProcessHandle?
06:51:16 <bitonic> osa1: <http://git.haskell.org/packages/process.git/blob/HEAD:/System/Process/Internals.hs#l111>.  but don't do that
06:51:31 <bitonic> the thing is that `process' is supposed to be OS indipendent, I'm not sure it should support unix facilities
06:51:54 <osa1> bitonic: any OS-dependant versions of `process`?
06:52:14 <bitonic> osa1: <http://hackage.haskell.org/package/unix-2.7.0.1/docs/System-Posix-Process.html>
06:53:43 <bitonic> osa1: <http://hackage.haskell.org/package/unix-2.7.0.1/docs/System-Posix-Signals.html#v:signalProcess>
06:59:52 <osa1> bitonic: yeah, lower level but that should work, thanks
07:00:30 <osa1> bitonic: hm how do I get input/output streams?
07:08:18 <bitonic> osa1: don't know off the top of my head.  but there probably is a way :P
07:08:39 <dmwit> osa1: Same way as in C, I would guess.
07:08:43 <dmwit> osa1: Redirect an fd.
07:08:46 <dmwit> before forking
07:10:59 <dmwit> https://downloads.haskell.org/~ghc/7.0.2/docs/html/libraries/unix-2.4.2.0/System-Posix-IO.html#v:createPipe and #v:dupTo
07:13:52 <bitonic> wow, I haven't done that kind of stuff in a while
07:14:24 <bitonic> that is very low level
07:14:48 <bitonic> maybe we need a higher level `unix' lib, osa1 already hit his head on the current one :)
07:17:52 <bitonic> bizarrely, `System.Posix.IO.ByteString' seems to work with `String's?
07:19:10 <dmwit> What do you mean?
07:19:28 <dmwit> Oh, like, the functions that write and read files or something?
07:19:41 <dmwit> It's probably still using the whole encoding mechanism for that.
07:19:43 <bitonic> dmwit: `fdRead' returns a `String', for example
07:19:58 <dmwit> Per the docs, only file names and environment strings use ByteString.
07:20:13 <dmwit> Which are the bits you can't fix by choosing the appropriate encoding.
07:20:17 <bitonic> right
07:20:43 <dmwit> But yeah, that is a bit funny, I agree. =)
07:24:29 <dwat3r> hi guys, how can I make a null pointer in haskell? i'm using c2hs, and a String needs to be set to NULL
07:24:54 <dmwit> nullPtr
07:25:29 <dwat3r> is it compatible with String?
07:25:34 <dmwit> No. String is not a pointer.
07:25:43 <dmwit> CString is a pointer, though.
07:25:59 <dwat3r> and CString can be nullPtr<
07:26:01 <dwat3r> ?
07:26:04 <dmwit> And CStringLen has a pointer inside. Not sure if it's sensible to stuff nullPtr into one of those, though.
07:26:38 <dmwit> nullPtr :: Ptr a; type CString = Ptr CChar
07:27:22 <dwat3r> so it should work
07:28:18 <EvanR> if you do strlen on NULL, doesn't it segfault
07:28:43 <dmwit> Probably. Is somebody planning to do strlen on NULL?
07:29:08 <EvanR> oh CStringLen is a type
07:30:10 <EvanR> empty CStringLen is a (whatever, 0), that works?
07:30:44 <dmwit> It probably depends on exactly what function you're handing that off to.
07:34:59 <bananagram> can anyone tell me why `div` is expecting a Float here? http://lpaste.net/115292
07:35:02 * hackagebot socket-io 1.2.0 -   http://hackage.haskell.org/package/socket-io-1.2.0 (OliverCharles)
07:35:27 <malllle> @undo do s <- get; modify (+1); return s
07:35:27 <lambdabot> get >>= \ s -> modify (+ 1) >> return s
07:36:00 <dmwit> bananagram: It isn't. (/) is
07:36:05 <EvanR> :t div
07:36:06 <lambdabot> Integral a => a -> a -> a
07:36:44 <bananagram> hm, I should keep x' and y' as floats
07:37:18 <dmwit> Well, actually, more to the point: (+) is.
07:37:42 <illabout> > mempty "hello" "bye" :: [Int]
07:37:43 <lambdabot>  []
07:37:50 <dmwit> I wonder if anybody has thought about how to make "type checker traces".
07:38:08 <bitonic> dmwit: yes, lennart augusstson has
07:38:23 <bananagram> Ints and Floats are so annoying...
07:38:23 <bitonic> maybe not a detailed "stack trace" but something like that
07:38:29 <bitonic> I have that in my type checker for dependent types
07:38:35 <dmwit> bananagram: Use Rational. =)
07:38:35 <bitonic> it gives a stack trace of type checking
07:38:52 <EvanR> bananagram: its easier if you can agree on a numeric type across the board, if you can
07:38:57 <dmwit> bitonic: Cool! Do you find it helpful?
07:39:04 <bitonic> dmwit: tremendously
07:39:21 <EvanR> bananagram: there are lots of number types available out there, but you might have performance or API restrictions
07:39:34 <bitonic> dmwit: <https://www.youtube.com/watch?v=rdVqQUOvxSU>
07:39:49 <dmwit> thanks, watching
07:40:00 <bitonic> 5 minutes
07:40:22 <EvanR> bananagram: on the other hand i really appreciate that floating point operations like floor return an integral type, that really helps keep things straight
07:41:06 <bananagram> yeah
07:42:36 <dmwit> Oh, well. Code locations is pretty nice, but not really what I was thinking.
07:42:48 <dmwit> The unification step in this is still completely opaque.
07:44:25 <EvanR> i wonder if its too hard to give good debug info because of a lot of special tricks and hacks in the current state of the typechecker, to get it to work better at the expense of being understandable from the outside
07:44:54 <EvanR> in which case a straightforward strategy which admits a listing of "reasoning" steps might be better, or it might be worse
07:44:57 <dmwit> This is like... just the last stack frame of the type checking trace. =P
07:45:14 <bitonic> well, this is just with the location, and I mean it's a bit imprecise
07:45:19 <bitonic> but I think good enough for most cases
07:46:29 <dmwit> I dunno. I often find myself wondering "why the heck does the type checker think that x is a Bool in this unification?".
07:46:42 <dmwit> This thing would help me identify that it was "x" that it thought was a Bool. But not why.
07:46:51 <bitonic> I agree that a stack trace is better.  but requires much more work and good taste
07:46:58 <bitonic> I manually mark type checking "sections"
07:47:04 <dmwit> yes, which is why I was asking whether anybody had thought about it =P
07:47:09 <bitonic> I also use them to print kinda derivation trees
07:47:19 <bitonic> and record timings on how much time is spent on each section, and stuff like that.
07:47:37 <bitonic> the problem is that it requires a lot of maintenance on the developers, I think
07:48:25 <dmwit> Yeah, the problem is troubling but fairly rare, so I can see how a maintenance price might be a bad trade.
07:48:36 <EvanR> is there something like type providers in haskell, template haskell?
07:48:41 <benzrf> :t cata
07:48:42 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
07:48:49 <benzrf> :t cata join
07:48:50 <lambdabot> (Functor f, Monad f) => Mu f -> f a
07:48:53 <bitonic> while keeping track of location is something which is easier to enforce, at least
07:49:06 <benzrf> hm
07:49:07 <bitonic> it's going to be some field to fill in in a datatype, so if the code changes the developer is faced with the problem
07:49:21 <benzrf> > cata join (fix (In . Just))
07:49:25 <lambdabot>  mueval-core: Time limit exceeded
07:49:31 <benzrf> i dont know what i was expecting
07:50:38 <dmwit> EvanR: What's a type provider?
07:51:10 <EvanR> in f# its a thing where some IO action generates source code at compile time, before type checking
07:51:11 <bitonic> is it that F# stuff?
07:51:36 <EvanR> for the purpose of building types against a database schema, or something
07:51:39 <bitonic> the ones I've seen would like pull data from the internet and let you use it
07:51:41 <dmwit> EvanR: No. Work on type-safe Template Haskell is ongoing.
07:51:50 <dmwit> Well.
07:52:02 <dmwit> Current Template Haskell is type-safe in the sense that the resulting code is type-checked.
07:52:10 <dmwit> So if that's all you want, then yeah, TH is it.
07:53:17 <EvanR> i guess its not much different from writing a program to generate or regenerate the relevant haskell module
07:53:31 <bitonic> EvanR: I've seen one of those shiny F# demos on type providers, where things would get pulled in and then visual studio let you work with it on the fly, and you can't really do *that* with current Haskell tooling
07:53:37 <EvanR> though integration into a compiler workflow is a big difference
07:54:05 <EvanR> bitonic: right... which is another story anyway. haskell IDE "tech"
07:54:29 <dmwit> I think you can ask GHC to report the code it generated with -ddump-splices.
07:55:14 <EvanR> some schemas or type-relevant information is very extensive and complex, not generally feasible to hand copy as regular source code
07:55:59 <EvanR> which also means fully regenerating a module would slow things down too much, and so youd need "lazy loading"
07:56:01 <bennofs> dmwit: I thought type-safe TH is already in some GHC?
07:56:53 <dmwit> Maybe! I admit I don't keep as up-to-date with GHC as some.
07:58:16 <bitonic> yeah, in 7.8 some of it came out
08:30:05 * hackagebot acme-cofunctor 0.1.0.0 - A Cofunctor is a structure from category theory dual to Functor  http://hackage.haskell.org/package/acme-cofunctor-0.1.0.0 (JasperVanDerJeugt)
08:32:09 <magicman> Cofunctor XD
08:32:43 <mauketwork> coprofunctor
08:34:02 <EvanR> lol
08:34:35 <EvanR> :t cofmap
08:34:35 <lambdabot>     Not in scope: ‘cofmap’
08:34:36 <lambdabot>     Perhaps you meant one of these:
08:34:36 <lambdabot>       ‘fmap’ (imported from Control.Monad.Writer),
08:34:39 <EvanR> should exist
08:34:51 <bennofs> :t contramap
08:34:52 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
08:35:03 <EvanR> not the same!!!!!
08:35:05 <bennofs> ik
08:35:23 <HeladoDeBrownie> What is cofmap? Retrieve a -> b from f a -> f b?
08:35:25 <bennofs> was about to say that it's not really a Cofunctor though, but rather a different kind of functor
08:35:56 <EvanR> HeladoDeBrownie: (b -> a) -> f b -> f a
08:35:57 <jaspervdj> type of cofmap is: Cofunctor f => (b -> a) -> f b -> f a
08:36:15 <bennofs> EvanR: that's just fmap with renamed type variables
08:36:22 <HeladoDeBrownie> I was about to say that
08:36:33 <Bubblegum> hello, how do I, for an example, execute accumArray from Data.Array in GHCi?. Somehow I have trouble what Haskell wants and what I understand. Just a little example, that's all.
08:36:38 <EvanR> tell me another one
08:36:47 <bennofs> :t fmap :: Functor f => (b -> a) -> f b -> f a
08:36:48 <lambdabot> Functor f => (b -> a) -> f b -> f a
08:36:59 <mauketwork> @hoogle accumArray
08:36:59 <lambdabot> Data.Array.IArray accumArray :: (IArray a e, Ix i) => (e -> e' -> e) -> e -> (i, i) -> [(i, e')] -> a i e
08:36:59 <lambdabot> Data.Array accumArray :: Ix i => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
08:37:18 <lengzai> hello, did anyone see the lpaste I just posted? http://lpaste.net/6295508731140505600
08:37:32 <mauketwork> ok, so it takes a combiner, a seed, a size, and a list of index/values
08:37:56 <lengzai> I'm having difficulty understanding why the output makes no sense when the input is mostly the same
08:38:16 <lengzai> the difference is that instead of passing around snakes, now I'm trying to pass around GameStates
08:38:36 <mauketwork> lengzai: what output?
08:39:18 <lengzai> inside the main function, the foldM is simulating a run of the game
08:39:32 <lengzai> it's passing in a list of directions and then rendering out the snake
08:39:56 <lengzai> in the first one i'm just rendering the snake directly on clear screens
08:40:26 <lengzai> in the second one, i'm trying to render the fruit alongside the snake so instead of just rendering snakes, now i'm rendeering GameStates, which contain references to both the snake and the current fruitc
08:40:53 <lengzai> the output is erratic and doesn't really make sense
08:41:48 <lengzai> essentially the output of the first run and the second run should be the same but the fruit should be rendered in the second one
08:48:08 <magicman> For debugging purposes, what happens when you change "paintGame game" to "paintSnake (snake game) screen"?
08:49:19 <latk> I'm dealing with a large matrix of data (5k x 5k). I don't need matrix operations, just to be able to look up values at given indices, and submatrices given indicies. What is my best option ?
08:49:54 <EvanR> you can use Array
08:50:33 <latk> Cool cool
08:50:34 <latk> sounds good.
08:50:54 <latk> the one in base ?
08:51:04 <EvanR> Data.Array yeah
08:53:39 <magicman> lengzai: Oh, I see. "updateGameSnake game (moveSnake snake dir)" That last 'snake' refers to the variable defined on line 69, you want the 'snake' field of 'game' there.
08:54:34 <lengzai> yes yes!
08:54:43 <lengzai> i was milliseconds from posting that
08:54:50 <lengzai> i was using the wrong snake
08:55:43 <lengzai> thanks magicman
08:57:34 <ChristianS> the hlint manual says i can use `{-# ANN myFunction "HLint: ignore" #-}` to suppress warnings, but that doesn't work for me
08:58:05 <ChristianS> i get "No instance for (Data.String.IsString a0) arising from the literal `"HLint: ignore"' The type variable `a0' is ambiguous"
08:58:43 <ChristianS> i suspect that's because i use {-# LANGUAGE OverloadedStrings #-} . anyone knows how/whether to fix that?
08:59:00 <mauketwork> heh
08:59:24 <mauketwork> does it accept ("HLint: ignore" :: String)?
09:00:52 <ChristianS> mauketwork: that works, thanks for for saving me!
09:01:10 <ChristianS> i had tried :: String already, but without the parens
09:09:36 <Aruro> What :^: means in following declaration --- data Tree a =  Leaf a  |  Tree a :^: Tree a ?
09:11:26 <mauketwork> Aruro: it's the name of the constructor in that branch
09:11:42 <mauketwork> that line defines three names, 'Tree', 'Leaf', and ':^:'
09:12:04 <mauketwork> you could also write it as ... = Leaf a | (:^:) (Tree a) (Tree a)
09:12:27 <Aruro> ty
09:12:48 <TallerGhostWalt> Anyone done any cross compiling to iOS?
09:13:15 <TallerGhostWalt> looks like w/o arm64 being supported you can't really make app libs
09:13:29 <Aruro> so later on i can write something like Leaf 5 :^: Leaf 6 ?
09:13:31 <TallerGhostWalt> which is a bummer
09:15:27 <mauketwork> Aruro: yes
09:15:44 <mauketwork> btw, lists have the same general shape
09:15:57 <mauketwork> data [] a = [] | a : [] a
09:16:21 <mauketwork> slightly more confusing because [] is the name of both the type and (unrelated) one of its constructors
09:16:21 <EvanR> confusing!
09:16:39 <Aruro> yes  confusing :)
09:16:42 <Aruro> but close indeed
09:16:48 <mauketwork> data List a = Nil | a : List a
09:16:56 <Aruro> ty! a valuable comment :)
09:17:09 <Aruro> yes thats better
09:17:38 <EvanR> data Hmm a = End a | Then a (Hmm a)
09:18:04 <Aruro> operator missing
09:18:06 <Aruro> no?
09:18:22 <Aruro> or in this case Then is : ?
09:18:25 <EvanR> I used Then
09:18:30 <Aruro> k
09:18:42 <EvanR> in here the End has an a like Leaf so this list cant be empty
09:19:19 <EvanR> which is isomorphic to (a, [a])
09:19:25 <EvanR> ignoring bottoms, im sure
09:20:53 <Aruro> ty
09:21:00 <Aruro> now completely clear
09:21:56 <EvanR> data Stream a = Cons a (Stream a)
09:22:03 <EvanR> and now it cant end at all ;)
09:24:07 <malllle> and my mom always told me that lazyness won't bring me far...
09:26:48 <arianvp___> yo
09:27:04 <arianvp___> I'm trying to install category-extras in a cabal sandbox but I get dependency problems
09:27:06 <arianvp___> .-.
09:27:40 <dmwit> What do you plan to use from category-extras?
09:27:48 <arianvp___> Cata, Algebra, Fix
09:28:31 <dmwit> Can you use recursion-schemes instead?
09:29:39 <arianvp___> What is Base?
09:29:55 <benmachine> insufficient information for a meaningful response
09:30:01 <benmachine> which Base, where?
09:30:03 <arianvp___> https://hackage.haskell.org/package/recursion-schemes-4.1/docs/Data-Functor-Foldable.html
09:30:09 <arianvp___> That  Base :)
09:30:17 <arianvp___> I'm not very familiar with type families
09:30:26 <benmachine> sorry, insufficient data for a meaningful answer
09:30:29 <benmachine> that is what I meant
09:30:29 <mauketwork> that is Base
09:31:10 <dmwit> You are responsible for defining Base for any types you want to use with Foldable from that package.
09:31:51 <arianvp___> .-.
09:31:54 <benmachine> that doesn't tell you what it *is* though
09:32:01 <dmwit> True.
09:32:10 <benmachine> I'm trying to find a type signature in those docs I can decode enough to be helpful
09:32:16 <benmachine> so far have not succeeded :P
09:32:28 <dmwit> Does it help to say "Base (Mu f)" = f?
09:32:40 <dmwit> It's generalizing that pattern to foldable things that are not Mu.
09:33:07 <arianvp___> Nope! Today my teacher dropped the word F-algebra and Fold for the first time
09:33:13 <arianvp___> so that's where I'm at.
09:33:21 <benmachine> oh well I know F-algebras
09:33:22 <dmwit> Base is the F of an F-algebra.
09:33:35 <benmachine> oh!
09:34:00 <benmachine> so like, Base for lists is Nil | Cons a b, or something like that?
09:34:03 <arianvp___> but in category-extras f is just a functor
09:34:12 <dmwit> benmachine: right
09:34:16 <arianvp___> say      data ExprF a  = Const Int  | Add a a deriving Functor
09:34:54 <dmwit> arianvp___: Bases are also only required to be Functors.
09:34:57 <benmachine> arianvp___: right, so ExprF Integer is an expression that might add integers
09:35:07 * hackagebot ot 0.1.2.2 - Real-time collaborative editing with Operational Transformation  http://hackage.haskell.org/package/ot-0.1.2.2 (TimBaumann)
09:35:18 <benmachine> ExprF Double is an expression that might add doubles
09:35:20 <megahaxor> http://bit.ly/1pw80IO
09:35:29 <benmachine> Fix ExprF is an expression that might add expressions
09:35:35 <arianvp___> But okay. how would I make an instance of base? it's a type .-.
09:35:47 <arianvp___> type instance Base (Expr F) = ??
09:36:00 <benmachine> well, no
09:36:02 <benmachine> hm
09:36:04 <benmachine> wait what
09:36:07 <benmachine> what's Expr, there?
09:36:15 <arianvp___> I accidentally a space
09:36:20 <benmachine> oh, no
09:36:25 <dmwit> ExprF is the ??
09:36:26 <benmachine> ExprF *is* the Base of an expression time
09:36:28 <benmachine> er
09:36:28 <benmachine> type
09:37:02 <dmwit> data Expr = Lit Int | Add Expr Expr; type instance Base Expr = ExprF
09:37:11 <arianvp___> ah
09:39:31 <arianvp___> okay but Control.Morphisms.Cata had   cata :: Algebra ExprF Int -> Fix (ExprF Int) -> Int
09:40:02 <arianvp___> or ugh this stuff is confusing hehe
09:40:34 <arianvp___> is there a #weird-category-theory-haskell-stuff  channel where I can geth help without spamming #haskell with dumb questions?
09:41:10 <benmachine> right, Algebra ExprF Int is like, how to reduce one layer of expressions
09:41:48 <dmwit> #haskell is that channel
09:41:50 <benmachine> and then cata is applying that at every layer
09:42:01 <arianvp___> ok but cata in recursi-n-schemes is
09:42:06 <arianvp___> (Base t a -> a) -> t -> a
09:42:07 <benmachine> there are other channels but no-one else is asking questions
09:42:07 <benzrf> arianvp___: #haskell-blah
09:42:10 <arianvp___> I can't really relate the type
09:42:17 <benmachine> benzrf: no, these are haskell questions
09:42:25 <arianvp___> to the one in category-extras
09:42:27 <benzrf> benmachine: pfft
09:42:47 <dmwit> arianvp___: (Base t a -> a) -- this is an algebra
09:42:48 <geekosaur> #haskel-overflow but I'd only bother if it's getting in the way of other stuff in channel
09:42:55 <geekosaur> er #haskell-overflow
09:42:56 <dmwit> arianvp___: t -- this is the fixpoint
09:43:03 <dmwit> arianvp___: a -- this is the result of the fold
09:43:36 <benmachine> 'Base t' is the functor of which 't' is a fixed point
09:43:55 <benmachine> in the case of simple recursive types, Base t a = t, but with recursive occurrences replaced by a
09:44:01 <arianvp___> but how do I get a value of  type "Base  t a"
09:44:21 <benmachine> that depends on what t is
09:44:34 <benmachine> if t is Expr, then you use the cosntructors for ExprF
09:44:36 <arianvp___> or wait. Expr is a   "Base (Fix (ExprF Int)) Int " ?
09:44:47 <dmwit> arianvp___: In our example before, when type instance Expr = ExprF, that is the same as asking "how do I get a value of type ExprF?".
09:44:56 <benmachine> no, Expr is (isomorphic to) Fix ExprF
09:45:15 <benmachine> and ExprF is Base Expr
09:45:17 <latk> What are the associations found in Data.Array?
09:45:36 <dmwit> latk: Are you asking about the "assocs" function?
09:46:13 <dmwit> latk: If so, the returned values are pairs of an index and the element at that index.
09:47:18 <latk> Ahh
09:47:31 <latk> Makes sense, thanks :)
09:51:14 <latk> Are there built in functions in Data.Array for returning the association list from within a certain range of indicies?
09:52:09 <EvanR> it looks like you have to use ixmap
09:52:24 <EvanR> to get the range, then you can use assoc
09:52:57 <latk> Right, okay.
09:53:00 <dmwit> You could use ixmap, or just a list comprehension.
09:53:14 <dmwit> [(i, arr ! i) | i <- mySmallerRange]
09:54:09 <EvanR> whats mySmallerRange, two indexes, or a list of indexes
09:54:20 <benmachine> there's a 'range' function
09:54:27 <benmachine> range (index1, index2)
09:54:27 <arianvp___> In our lecture notes an Algebra is a tuple of a function and a neutral element for your non-recursive parts of your datatype.  How do I represent those neutral elements in an algebra with recursion-schemes?
09:54:33 <dmwit> It's Haskell, a general-purpose programming language.
09:54:39 <dmwit> Input is what you like, output is any computable value.
09:54:40 <dmwit> ;-)
09:54:55 <benmachine> arianvp___: that presentation sounds weird
09:55:02 <EvanR> Dynamic -> IO Dynamic
09:55:17 <benmachine> arianvp___: to my knowledge an algebra is simply a function
09:55:22 <arianvp___> like   data Parens = Match Parens Parens | Empty =>   type ParensAlgebra = (m -> m -> m, m)
09:55:29 <dmwit> An algebra has a neutral element?
09:55:33 <benmachine> an algebra for f is a function f T -> T for some type T
09:55:57 <arianvp___> foldParens :: ParensAlgebra m -> Parens -> m
09:56:05 <benmachine> hmm, interesting
09:56:17 <dmwit> arianvp___: Yes, that's quite right.
09:56:29 <dmwit> arianvp___: But you can also represent that algebra as:
09:56:35 <arianvp___> foldParens (match, empty) = fold  where fold Empty = empty; fold (Match l r) = match (fold l) (fold r)
09:56:39 <benmachine> Base Parens a = BMatch a a | Empty
09:56:59 <dmwit> data ParensF a = Match a a | Empty; type ParensAlgebra a = ParensAlgebraF Parens -> a
09:57:17 <dmwit> I mean type ParensAlgebra a = ParensAlgebraF a -> a, sorry
09:57:31 <dmwit> arianvp___: Beacuse (a + b) -> c === (a -> c, b -> c)
09:58:01 <dmwit> arianvp___: So your pair of a function and a value can also be seen as just a function that takes a sum.
09:58:08 <benmachine> then a function k :: Base Parens a -> a (an algebra in my sense) is precisely an element of a (i.e. k Empty) and a function a -> a -> a (that is, \x y -> k (BMatch x y))
09:58:22 <benmachine> I meant to call Empty BEmpty but whatever
09:59:07 <dmwit> arianvp___: (Also, there's no good reason to call the second element in your algebra "neutral". It doesn't have to satisfy any properties relative to the binary function.)
10:00:51 * benmachine vaguely tries to work out what Parens has to do with parens
10:02:04 <arianvp___> benmachine: Parens is an abstract datatype of a parser that parses matching parens
10:02:23 <benmachine> arianvp___: I guessed that from the name but don't immediately see how it works
10:02:31 <dmwit> show (Match a b) = "(" ++ show a ++ show b ++ ")"; show Empty = ""
10:02:41 <dmwit> perhaps
10:02:51 <dmwit> Or maybe "(" ++ show a ++ ")" ++ show b
10:02:51 <arianvp___> the language accepts ()(), (()),  (), etc
10:02:52 <benmachine> perhaps, but "()()"?
10:02:52 <dmwit> not sure
10:02:56 <arianvp___> but not  (()
10:03:07 <dmwit> I think with my latter clause for Match it works better.
10:03:15 <benmachine> oh, yes, I think that does make sense
10:03:18 <dmwit> "()()" is Match Empty (Match Empty).
10:03:29 <benmachine> I think I came up with something similar, but it was parens in a context of other strings
10:03:49 <benmachine> so it was like, Match String Parens Parens
10:03:52 <benmachine> before, during, after
10:07:20 <codygman> I read a few places that Groundhog doesn't support joins, is that true?
10:11:59 <wjlroe> I'm getting a type error trying to use Test.Framework with Cabal's detailed-0.9 test suite thingy, details in this gist: https://gist.github.com/wjlroe/6262c5c773be7b82cbaf Does any one have any suggstions?
10:14:08 <dmwit> I was under the impression that cabal doesn't actually support the detailed test suite stuff.
10:14:24 <dmwit> (And that the docs are just wrong about this.)
10:14:53 <wjlroe> That might explain it. Is the only option exitcode-stdio-1.0 for tests then?
10:15:18 <dcoutts_> wjlroe: detailed-0.9 exists (1.0 does not), but it uses its own types, not the ones from the Test.Framework library
10:15:40 <wjlroe> dcoutts_ are they basically incompatible then?
10:15:43 <dcoutts_> wjlroe: so the reason you're getting that type error is because they are indeed totally different types
10:16:11 <dcoutts_> wjlroe: the goal with the detailed interface is to have libs like test framework/tasty provide convenient support
10:16:15 <clrnd> http://thisotplife.tumblr.com/post/90043196627/when-i-was-introduced-to-gos-error-handling-as-an
10:16:28 <dcoutts_> the api Cabal expects is not designed to be convenient for end users, but for intermediate frameworks
10:16:56 <arianvp___> Okay I'm at a point where I need to make an instance of Foldable for Expr. but not sure how to proceed
10:16:58 <arianvp___> http://lpaste.net/115295
10:17:05 <arianvp___> s/Expr/Parens
10:20:02 <dmwit> cata f Empty = f EmptyF
10:20:08 <dmwit> See if you can do the other case.
10:20:26 <dmwit> (It's the tricky one, of course.)
10:20:31 <arianvp___> :)
10:20:45 <dmwit> If you can't, show us what you tried and tell us why you thought it would work.
10:24:54 <arianvp___> hmm
10:25:01 <arianvp___> think I got it.
10:25:08 <arianvp___> compiler complaining I need to implement project as well
10:25:47 <arianvp___> but it's working anyway
10:26:15 <arianvp___> cata f (Match a b) = f (MatchF (cata f a) (cata f b))
10:29:09 <dmwit> arianvp___: looks good to me
10:29:34 <arianvp___> :)
10:30:12 <arianvp___> well that was fun. Now of course the question arrives. why can't we automatically deduce a ParensF for a Parens?
10:30:37 <arianvp___> perhaps with some template haskell?
10:30:42 <dmwit> exactly =)
10:30:55 <dmwit> In fact, you can derive Data which I think does something similar.
10:31:08 <dmwit> There's a handful of other generic programming approaches out there, too.
10:31:37 <dmwit> Do note that Haskell supports recursion on *different* types, which can be a bit awkward.
10:31:59 <dmwit> e.g. the canonical example is data BalancedTree a = Leaf a | Branch (BalancedTree (a, a))
10:35:10 * hackagebot hindent 4.0 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-4.0 (ChrisDone)
10:35:49 <chrisdone> more subtle example: data AltList a b = Cons a (AltList b a) | Nil
10:37:29 <FreeFull> chrisdone: That's a neat type
10:37:39 <lpaste> chrisdone pasted “AltList” at http://lpaste.net/115298
10:37:51 <chrisdone> yeah, i always liked it
10:37:59 <mauketwork> data T a = C a (T (T a))
10:38:54 <FreeFull> chrisdone: fromLists doesn't seem to support creation of an altlist of an odd length
10:39:12 <FreeFull> Which could be done by adding one more clause
10:39:21 <EvanR> "stupid ADT tricks" ;)
10:39:28 <chrisdone> i modeled it from `zip'
10:39:33 <FreeFull> fromLists [a] [] = Cons a Nil
10:39:37 <dmwit> fromLists (a:as) bs = Cons a (fromLists bs); fromLists [] _ = Nil -- no extra clauses needed
10:39:54 <dmwit> whoops, the recursive call should of course be fromLists bs as
10:40:03 <FreeFull> dmwit: You're right
10:40:27 <FreeFull> I wonder if it's missing a case though
10:40:37 <mauketwork> can't be
10:40:38 <mauketwork> it's exhaustive
10:41:05 <FreeFull> Hmm
10:41:07 <chrisdone> good point, fromLists (a:as) bs = Cons a (fromLists bs as) is more elegant
10:41:11 <arianvp___> dwmit: http://hackage.haskell.org/package/regular :D
10:41:15 <chrisdone> matches up with the type nicely
10:41:17 <FreeFull> Yeah, it is
10:46:23 <T_S_> maybe a little off topic, but does anyone here love their irc client for mac or linux?
10:48:19 <arianvp___> T_S: I use Polari. it's good enough
10:49:35 <tb01110100> what book/guide to y'all reccomend for learning haskell?
10:49:42 <tb01110100> s/to/do
10:50:56 <cite-reader> Learn You A Haskell for Great Good is the most common recommendation.
10:51:04 <cite-reader> @where lyah
10:51:09 <lambdabot> http://www.learnyouahaskell.com/
10:51:21 <tb01110100> ok, thanks!
10:51:55 <dmwit> ?where gentle
10:51:55 <dv-> @where gentle
10:51:58 <lambdabot> http://www.haskell.org/tutorial/
10:51:58 <lambdabot> http://www.haskell.org/tutorial/
10:52:01 * dmwit high-fives dv-
10:52:16 <dv-> that's how i learned it and that's how everyone should learn it
10:53:07 <tb01110100> isn't haskell 98 an older standard?
10:53:28 <dv-> well, not by much
10:53:40 <bitonic> dv-: "that's how everyone should learn it"?
10:54:10 <benzrf> lyah is pedagogically unsound!!!
10:54:22 <dv-> bitonic: the guide above
10:54:26 <benzrf> tb01110100: i recommend https://github.com/bitemyapp/learnhaskell
10:55:04 <benzrf> tb01110100: lyah is not bad as an guide to the language features, but it is not great about teaching the actual ideas
10:55:26 <benzrf> tb01110100: if you use lyah you will probably come out the other end somewhat confused about how to think about the thing it taught you
10:56:23 <dmwit> I don't know that I'm on board with "That's how everyone should learn it.". But it was effective for me.
10:56:33 <dmwit> And I'm happy to recommend it to other folks for that reason.
10:56:40 <tb01110100> yeah, I was always a little bit confused last time I tried lyah
10:58:33 <bitonic> dv-: yeah, I don't understand why would that be -- plenty of people manage without that
10:58:44 <benzrf> tb01110100: seriously i strongly recommend https://github.com/bitemyapp/learnhaskell as yr guide
10:59:05 <benzrf> tb01110100: it is put together with true-understanding-of-ideas as its primary goal
10:59:22 <dmwit> ?where tutorials
10:59:24 <lambdabot> http://haskell.org/haskellwiki/Tutorials
11:00:13 <tb01110100> benzrf: I'll take a look at it, thanks a bunch
11:01:09 <benzrf> np
11:02:40 <myfreeweb> any warp experts here? warp doesn't work on a unix domain socket on freebsd :( truss shows accept4 syscall returning error 22 "Invalid argument"
11:03:17 <mmachenry> I'm writing a couple of programs that are TCP servers but not web servers. I'd like to use an existing library to take all of the line buffering, partial message, which bytestring to uses issues off of my plate. Is there a recommended one? scalable-server looks pretty good.
11:07:48 <Beyaz21> hey guyz!!
11:08:57 <Beyaz21> i want to write a project!
11:09:20 <cite-reader> Good for you!
11:09:45 <Beyaz21> and i only know c# and vb.net
11:10:01 <Beyaz21> so i was asking which on is good?
11:10:44 <cite-reader> I'm not sure I understand the question.
11:10:47 <dmwit> I recommend Haskell.
11:11:18 <Beyaz21> Haskell is not a programming language
11:12:08 <simpson> Sure it is.
11:12:11 <chpatrick> what is it?
11:12:24 <mmachenry> Haskell is a town in Texas, chpatrick
11:12:37 <chpatrick> the more you know
11:12:52 <benzrf> Beyaz21: i'm pretty sure it is
11:12:53 <mmachenry> Beyaz21: They are all three programming languages.
11:12:56 <dmwit> They see me trollin'.
11:12:58 <dmwit> They hatin'.
11:13:13 <dmwit> Remember the most effective strategy for trolls is starve them. ;-)
11:13:22 <simpson> They tryin' to catch me cachin' dirty?
11:13:23 <benzrf> i try to starve whilst engaging
11:13:25 <exio4> benzrf: I wouldn't be sure, where is the formal proof that it is a programming language?!
11:13:38 <piskrist> how does ghc know which library gmp to links against?
11:13:39 <benzrf> exio4: define PL for me
11:14:06 <exio4> there isn't a nice definition, that is the idea \o/
11:14:33 <simpson> :t i x = x
11:14:33 <lambdabot> parse error on input ‘=’
11:14:38 <Beyaz21> ok! i got u!
11:14:44 <simpson> :t \x -> x -- i
11:14:44 <lambdabot> t -> t
11:14:52 <simpson> :t x y -> x -- k
11:14:52 <lambdabot> parse error on input ‘->’
11:15:01 <simpson> :t \x y -> x -- k, cannot type this morning
11:15:02 <lambdabot> t1 -> t -> t1
11:15:21 <simpson> :t \x y z -> x z (y z) -- s
11:15:22 <lambdabot> (t2 -> t1 -> t) -> (t2 -> t1) -> t2 -> t
11:15:32 <simpson> So it's a programming language.
11:15:56 <serses> why square''' = (^2) main = print (square 2) says not in scope?
11:16:11 <dmwit> > "square'''" == "square"
11:16:15 <lambdabot>  False
11:16:47 <mmachenry> simpson: I think the existence of S and K in Haskell doesn't not actually make it Turing Complete since it's statically typed.
11:17:06 <serses> dmwit: ??
11:17:11 <EvanR> define S and K for a "universal" monotype
11:17:17 <EvanR> to forget the type system
11:17:23 <FireFly> simpson: cannot "type" this morning--that's why you have lambdabot do the typing for you?
11:17:27 <dmwit> serses: The primes in the name make it a different name.
11:17:51 <simpson> FireFly: You got it.
11:17:57 <serses> so i need to call it with square'''?
11:18:05 <piskrist> oh, the dist tarball already contains a binary which is linked against libgmp.so.10
11:18:08 <dmwit> serses: yes
11:18:27 <dmwit> EvanR: I liked that argument a lot less once I realized you can't observe anything about the usual monotype.
11:18:41 <simpson> mmachenry: Well, you have to encode S, K, and a reduction method. I didn't think that the static typing took away from that.
11:19:37 <mmachenry> If you use S and K with Haskells reduction and just define them like you did, it's a problem.
11:19:55 <mmachenry> EvanR's idea might fix it
11:20:27 <EvanR> data SK = S | K is probably better
11:20:51 <EvanR> Tree SK ;)
11:20:59 <exio4> a proof of turing completeness?
11:22:00 <simpson> exio4: I went for a sucker punch; SKI combinator calculus is Turing-equivalent. But apparently I did it wrong somehow.
11:23:47 <EvanR> data T = S | K | A T T, reduce :: T -> T
11:44:12 <mmachenry> simpson:  It's wrong only because Haskell is not untyped like combinatory logic. It's statically typed.
11:45:10 <EvanR> if you can implement a TC system, youre TC, thats like.. the definition
11:45:44 <mmachenry> EvanR: Yes I know.
11:46:13 <mmachenry> EvanR: But writing out S and K as Haskell functions and using Haskell's evaluation without doing something with the types breaks.
11:46:27 <EvanR> ok
11:47:56 <EvanR> after reading about combinatory logic, it seems that its not really related to logic per se?
11:48:02 <EvanR> its more like a lambda calculus
11:48:40 <EvanR> its not in the same class as intuitionistic logic, classical logic, first order logic?
11:50:05 <mmachenry> EvanR:  true
11:50:18 <mmachenry> EvanR: I mean \x.\y.x
11:51:39 <ReinH> mmachenry: how does it break?
11:53:01 <mmachenry> I haven't tried it but I'm pretty sure it'd try to form an infinite type if you did anything recursive.
11:53:32 <ReinH> s = (<*>); k = const; i = id
11:53:45 <ReinH> It doesn't break at all
11:54:36 <mmachenry> What if you write Y and try to apply it to something like a factorial function? Doesn't that have an infinite type?
11:54:44 <ReinH> :t let s = (<*>); k = const; i = id; b = s (k s) k in b
11:54:50 <lambdabot> (a -> b) -> (b1 -> a) -> b1 -> b
11:55:24 <ReinH> Y is just a fixed point combinator
11:55:59 <mmachenry> I know.
11:56:36 <ReinH> http://r6.ca/blog/20060919T084800Z.html
11:57:04 <mmachenry> Right that's a solution.
11:57:11 <bitonic> (and that inliner bug is gone)
11:57:20 <mmachenry> But you need to do something funny with the types, like I said.
11:57:24 <bitonic> I... think.
11:57:39 <EvanR> yes its not as simple as combining combinators
11:57:46 <mmachenry> Agreed.
11:58:10 <carette> anyone here with expertise with Haskell on Windows, specifically createProcess?
11:59:18 <ReinH> EvanR: but logic is related to lambda calculus
11:59:51 <EvanR> untyped?
12:00:14 <EvanR> typed lambda calculus and typed combinatory logic, thats one thing but
12:00:38 <ReinH> Curry Howard correspondence
12:01:09 <mmachenry> Untyped Lambda Calculus was was original created to unify logic.
12:01:26 <mmachenry> Before we had programming languages.
12:02:25 <EvanR> postulate: untyped lambda calculus is logically inconsistent
12:03:38 <ReinH> EvanR: I don't think so?
12:03:58 <ReinH> Kleene-Rosser paradox does not apply to Church's λ-calculus
12:04:20 <EvanR> do you have a reference where i can read about the correspondence between untyped LC and some sort of logic?
12:04:30 <ReinH> Specifically the untyped λ-calculus
12:05:14 * hackagebot list-remote-forwards 0.0.1 - List all remote forwards for mail accounts stored in a SQL database.  http://hackage.haskell.org/package/list-remote-forwards-0.0.1 (MichaelOrlitzky)
12:05:16 <ReinH> Curry's original combinatoric logic and Church's original λ-calculus were inconsistent
12:05:38 <ReinH> EvanR: http://en.wikipedia.org/wiki/Curry%E2%80%93Howardcorrespondence#Correspondencebetweennaturaldeductionₐndlambdacalculus
12:05:43 <ReinH> woops
12:05:47 <ReinH> http://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence#Correspondence_between_natural_deduction_and_lambda_calculus
12:05:50 <ReinH> Sorry
12:06:18 <mmachenry> ReinH: Are you sure the Kleene-Rosser Paradox doesn't apply to untyped lc?
12:06:55 <ReinH> mmachenry: Church's 1936 untyped lc was a response to the 1935 Kleene-Rosser paradox
12:07:19 <EvanR> this section seems to be discussing simply typed LC
12:07:34 <mmachenry> huh. I thought KRP was Richard's paradox in the original LC
12:08:28 <mmachenry> And then typed LC was created to avoid KRP
12:09:53 <mmachenry> Yeah wait a sec, ReinH I think this is on wikipedia is what I thought.
12:11:02 <mmachenry> Curry Combinatory logic 1930, Church Untyped LC 1932, Kleene-Rosser Paradox applies to both in 1935, Simply typed LC response by Church in 1940
12:11:32 <ReinH> mmachenry: I thought simply typed LC was a response to Church's paradox
12:11:46 <mmachenry> I don't think so.
12:11:49 <ReinH> Which doesn't change the fact that untyped LC is inconsistent as EvanR originally said
12:12:07 <mmachenry> LC is inconsistent just like set theory but simply typed LC is not turing complete.
12:12:58 <mmachenry> Also I don't know Church's Paradox
12:14:04 <mmachenry> Yeah I reread the Wikipedia page on Kleene-Rosser Paradox. It applies to untyped LC and Combinatory Logic for sure.
12:14:12 <EvanR> "Curry's paradox may be expressed in Lambda calculus."
12:14:46 <mmachenry> ReinH: Are you the Haskell Cast guy?
12:20:14 * hackagebot monad-gen 0.3.0.0 - A simple monad for generating fresh integers  http://hackage.haskell.org/package/monad-gen-0.3.0.0 (jozefg)
12:20:17 <ReinH> mmachenry: yeah
12:20:29 <ReinH> EvanR: You were right about untyped lc, sorry
12:23:11 <EvanR> my confusion was with unfamiliarity with combinatory logic, which despite its name, (unless simply typed is assumed) is very "logical"
12:23:11 <EvanR> is not very
12:23:48 <mmachenry> ReinH: Awesome. I love it. Are there going to be more?
12:27:07 <ReinH> mmachenry: We recorded one last weekend, should be released after the holidays
12:27:10 <ReinH> mmachenry: thanks!
12:27:26 <mmachenry>  Awesome!
12:27:31 <mmachenry> Who's the guest?
12:27:41 <ReinH> mmachenry: Conal Eliott
12:27:49 <ReinH> EvanR: why don't you think it's "logical"?
12:28:18 <EvanR> that is to say, logically inconsistent
12:31:06 <mmachenry> EvanR: They're formal systems of logic.
12:31:32 <mmachenry> Just a little closer to programming languages because that's where a lot of PLs have come from.
12:31:49 <ReinH> This is a decent writeup http://plato.stanford.edu/entries/paradoxes-contemporary-logic/#IncCerForLog
12:34:16 <EvanR> i was about to point this part out
12:34:40 <EvanR> identifying combinations with propositions
12:34:57 <EvanR> if you do, you can get paradoxes or "proving anything"
12:34:58 <arianvp___> Say I have:   data ExprF a = Val Int | Add a a  ;  data StatF a = E (ExprF a) | Next a;  How would I fold over this with a catamorphism
12:35:07 <EvanR> so you can get out by not having all combinations be propositions
12:37:15 <ReinH> Over StatF?
12:38:07 <smdiehl> Is anyone an expert on ghc 7.8 linker?
12:38:23 <ReinH> arianvp___: by combining a fold over ExprF with a fold over StatF
12:38:32 <ReinH> smdiehl: hi
12:38:50 <smdiehl> ReinH: hi
12:38:54 <dmwit> smdiehl: Don't ask to ask, just ask.
12:39:30 <ReinH> arianvp___: you aren't tying the knot so these are the usual church encodings
12:39:32 <glguy> Dwmit: can I ask to ask?
12:39:40 <ReinH> Can I ask if glguy can ask to ask?
12:39:57 <smdiehl> If I precompiled an archive file from C in 7.6 and the symbols are not explicitly imported via the FFI, ghci would still link them. In 7.8 unless they're imported only if they appear in the Haskell source.
12:40:01 <glguy> Reinh: you may.
12:40:15 <dmwit> There's a joke in here about bids, but I don't know enough finance to make it.
12:40:20 <ReinH> hah
12:41:09 <smdiehl> Any idea about the changes in the static linker between 7.6 and 7.8?
12:41:29 <arianvp___> ReinH: Yeh I wanna fold over StatF
12:42:50 <ReinH> \f (StatF a) = f a is a fold over StatF
12:44:43 <EvanR> ReinH: this article is really cool
12:45:06 <sivteck> smdiehl, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/release-7-8-1.html#idp5474192 "On Linux, the static GHCi linker now supports weak symbols."
12:45:13 <ReinH> EvanR: yeah, it's rather nice
12:46:26 <smdiehl> sivteck: ok, thanks for the lead on that
12:46:48 <smdiehl> sivteck: looks like that may be difference
12:47:26 <sivteck> smdiehl, i am post-7.8.3 haskeller, i just remembered reading it in the guid :D
12:47:33 <sivteck> s/guid/guide/
12:49:23 <angerman> how do I teach cabal to build documentaion when installing stuff in the sandbox? Documentation: True, seems to not have done the trick :-/ in ~/.cabal/config
12:52:23 <malllle> angerman: You can do this by creating a cabal.config file in the same directory with your cabal.sandbox.config (which was created by sandbox init). This file has the same syntax as the main Cabal config file.
12:52:59 <angerman> malllle, so I can just copy it over? I though it would consult the *global* cabal config, but it does not?
12:53:11 <malllle> but normally documentation: True should be inherited
12:53:25 <EvanR> "unfounded chains are regarded as generalized fixed points"
12:53:50 <malllle> angerman: did you write Documentation or documentation?
12:54:23 <angerman> malllle: uncommented the line: documentation: True
12:55:24 <malllle> have you reinstalled the sandbox afterwards?
12:55:42 <ReinH> Did you try turning it off and back on again?
12:55:43 <angerman> malllle: the sandbox? no, just the package with --reinstall
12:56:15 <angerman> ReinH: PEBCAK? :)
12:57:11 <malllle> --reinstall afaik only afaiks the target not the dependencies
12:57:19 <malllle> *affects
12:59:09 <angerman> malllle: hmm so to fix the dependencies I would need to reinstall the sandbox?
12:59:30 <malllle> angerman: i think so
13:06:10 <ReinH> try cabal install --force-reinstalls --dependencies-only ?
13:18:42 <dmwit> don't --force-reinstalls =(
13:20:16 * hackagebot purescript 0.6.2 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.6.2 (PhilFreeman)
13:29:57 <ReinH> dmwit: it's in a sandbox
13:30:45 <ReinH> worst case scenerio, you have to reinstall your dependencies, which you have to do anyway
13:43:12 <trap_exit> let A = average # of people in a software project, B = average # of people on a math paper. We know that A >> B. Why is it taht for most haskell projects, the # of contriburtors is closer to A than to B ?
13:44:25 <ReinH> trap_exit: what?
13:44:45 <trap_exit> why is it that writing haskell is more like software development rather than like writing maht proofs?
13:45:00 <exio4> because it is a general purpose programming language
13:45:11 <codygman> Anyone know how to get the id of a persistent entity?
13:45:17 <xplat> trap_exit: most math papers don't accept patch requests on github?
13:45:43 <ReinH> Um. Because Haskell is a programming language?
13:45:52 <ReinH> What a strange question.
13:46:18 <chrisdone> codygman: remove the entry from your model and delete the table in the db?
13:46:19 <trap_exit> I expect codingin Haskell to be closer to writing math proofs
13:46:22 <trap_exit> than coding in C.
13:46:27 <exio4> that is Coq/Adga
13:46:32 <chrisdone> adjust your expectations
13:46:44 <ReinH> Well, it's closer than C. That doesn't mean it's very close.
13:46:51 <codygman> chrisdone: I mean, I have a model defined called Dog and I thought I could just access it with DogId but apparently that doesn't work.
13:47:57 <chrisdone> codygman: https://hackage.haskell.org/package/persistent-2.1.1/docs/Database-Persist-Class.html#v:delete
13:48:15 <chrisdone> codygman: oh, i read it as "get rid of"
13:48:25 <agibiansky> It looks like Hoogle no longer supports HTTP, only HTTPS. I was previously using Network.HTTP to query Hoogle, but it seems like Network.HTTP doesn't do HTTPS. Is the only solution to switch to a different library, e.g. Network.HTTP.Conduit?
13:48:41 <codygman> I'm trying to link to a dog I've created by id, so need to get that entities Id
13:48:48 <codygman> get?
13:48:50 <codygman> hm
13:49:32 <chrisdone> codygman: if you have the Entity you can just pattern match on it as (Entity key value)
13:49:38 <tac_> agibiansky: Network.HTTP is awful. Use http://hackage.haskell.org/package/wreq
13:49:44 <chrisdone> https://hackage.haskell.org/package/persistent-2.1.1/docs/Database-Persist-Types.html#t:Entity
13:49:51 <mauke> agibiansky: why not run a local hoogle?
13:50:05 <codygman> chrisdone: Thanks, I was being silly ;) That's what no sleep does I guess.
13:50:19 <agibiansky> tac_: Thanks, will look at it. Why is Network.HTTP so awful?
13:50:20 <codygman> entityKey is what I was looking for
13:50:44 <tac_> agibiansky: Probably because no one claims full responsibility for the standard libraries
13:50:45 <agibiansky> mauke: I looked into that, but it seems a little bit heavy to require anyone who wants to use my application to run their own hoogle database
13:50:52 <tac_> although I guess there's a GHC lib committee now
13:50:58 <tac_> but older libraries are whatever they are
13:51:03 <chrisdone> http-conduit is pretty easy to use, i'd just use that. HTTP is a dinosaur
13:51:16 <tac_> and the Network.HTTP one doesn't support HTTPS despite how vital it is to do anything on the internet
13:51:28 <tac_> wreq is a more lightweight way of doing things
13:51:54 <tac_> Although I think I was using conduit for a while. It seems annoying to need conduit depends if you don't want to use the conduit paradigm though
13:52:06 <agibiansky> Yeah, it looks smaller in API, as long as you don't mind pulling in `lens`
13:52:35 <tac_> oh god
13:52:38 <tac_> yeah. I forgot about that
13:52:39 <chrisdone> you don't have to know what a conduit is to use http-conduit
13:52:45 <tac_> So yeah
13:52:49 <tac_> Choose your poison
13:52:50 <chrisdone> there's also http-client upon which both wreq and http-conduit are based
13:52:55 <tac_> Lens hell or conduit hell.
13:53:08 <chrisdone> http://hackage.haskell.org/package/http-client-0.4.6/docs/Network-HTTP-Client.html#v:httpLbs
13:54:08 <chrisdone> do req <- parseUrl "https://www.example.com/path"
13:54:09 <chrisdone>    bytes <- withManager defaultManagerSettings (httpLbs req)
13:54:09 <chrisdone>    L.putstrLn bytes
13:54:11 <chrisdone> done
13:54:15 <agibiansky> Yeah, http-client looks good to me, I think I'll try that
13:55:42 <darthdeus> anyone tried installing ghc and cabal via homebrew recently?
13:56:17 <darthdeus> i'm getting the following
13:56:17 <darthdeus> https://gist.github.com/darthdeus/45f285550996a660993e
13:56:28 <darthdeus> (after installing ghc and cabal-install via brew)
13:57:00 <officialxian> Heya.
13:57:39 <officialxian> I've got a kindof random question. Doing some research a bunch of people recommended this channel for misc questions.
13:58:48 <Darkwing_> Hey guys, is there someone willing to help me privately (via another chat window?) with fixing out some errors on my code? I won't be pasting them all here because that would be a bit "spam-ish"... Would certainly appreciate help. Thanks
13:59:16 <officialxian> Darkwing_: throw the code into pastebin? then you don't have to worry about spamming chat?
13:59:49 <Darkwing_> the problem is: whenever I fix an error, it immediately comes up with another, which would cause spam due to pasting multiple pastebins...
14:00:03 <officialxian> ohh
14:00:06 <officialxian> good point
14:00:06 <chrisdone> agibiansky: tac_: made a trivial example https://www.fpcomplete.com/user/chrisdone/http-client-demo
14:00:08 <Darkwing_> Hence the request for private help :P
14:00:09 <darthdeus> nvm, i had an old ~/.ghc :\ everything works after removing :)
14:00:11 <darthdeus> hehe
14:00:58 <agibiansky> chrisdone: yup, got it, seems to be working, thanks
14:01:13 <chrisdone> ( ͡° ͜ʖ ͡°)
14:01:34 <chrisdone> agibiansky: we were chatting about ihaskell at an fpco meeting recently :3
14:01:52 <athan> Is there a way to force all string syntaxes to a particular Text instance? OverloadedStrings is just making things too general, and I just need Data.Text.Text :/
14:02:22 <agibiansky> chrisdone: :D cool! IHaskell needs some maintenance love lately... school doesn't leave so much time for it, though :(
14:02:38 <Darkwing_> Any kind soul to help me out? My code's composed by recursive functions only
14:02:43 <Black-Heaven> Hello, is there a way, in ghci, to print the raw type? (ie. without the type function application) Thanks by advance for your help
14:02:45 <officialxian> So, this isn't related to Haskell at all, but people at HN say this chat is good for general discussion. I just got the new 2014 Moto X, and I've noticed some extra WiFi networks. I got pretty paranoid at first because they were showing up everywhere I was. They were titled "FBI_VAN_A4" "HawksNest" and "Windows PowerShell" but my phone seems to be the only thing to pick up these networks. Refreshing Wifi doesn't help, is there 
14:02:50 <officialxian> just stick around on my list?
14:03:04 <indigo945> is there a cleverer way of writing \_ a -> a
14:03:22 <athan> flip const?
14:03:27 <chrisdone> agibiansky: yeah, it was broughht up with regards to doing bio analysis and a handy way to share analyses. we *might* end up investing in it if our clients take to it
14:03:27 <indigo945> ^
14:03:30 <indigo945> :)
14:03:30 <athan> :t flip const
14:03:33 <athan> :)
14:03:33 <lambdabot> b -> c -> c
14:03:56 <supki_> :t const id
14:04:00 <lambdabot> b -> a -> a
14:04:11 <Ahahaha> hi
14:04:21 <Ahahaha> I want to print a list to IO ()
14:04:41 <Ahahaha> but the command "map putStrLn [1,2,3]" results in a type error
14:04:54 <chrisdone> indeed
14:05:04 <chrisdone> do you want the right function or an explanation why that fails?
14:05:05 <Ahahaha> Couldn't match expected type ‘IO ()’ with actual type ‘[IO ()]’
14:05:13 <Ahahaha> both, ideally
14:05:14 <Darkwing_> Oh well, I'll go with it anyways. http://lpaste.net/8882391293280387072 what's wrong in here? I don't seem to figure it out
14:05:44 <chrisdone> Ahahaha: do you have GHCi running?
14:05:56 <Ahahaha> yes
14:06:02 <Ahahaha> always :)
14:06:29 <chrisdone> okay, in there you can type :t map putStrLn [1,2,3] and you see the type
14:06:49 <agibiansky> chrisdone: cool. well, file issues if you need anything i guess, should have some time in the next month or so to do a lot of clean up, and hopefully some packaging for Macs at least. cool to hear that you guys are maybe doing some bio, bio is fun :) if you happen to know of any bio places that use haskell, i'd love to hear about those, wasn't aware there was much comp bio haskell going on (the libraries for it are pretty skimpy...)
14:06:55 <chrisdone> Ahahaha: hm, i suppose you meant map print [1,2,3]?
14:07:07 <chrisdone> (from above)
14:07:18 <Ahahaha> map print doesn't work either
14:07:28 <Ahahaha> certainly not in ghci
14:07:30 <chrisdone> right, that's expected
14:07:41 <chrisdone> GHCi expects something of type IO a
14:07:45 <Ahahaha> and gives the same type error when i load the file
14:07:56 <chrisdone> you currently have an [IO ()]
14:08:10 <chrisdone> you just have a list of actions
14:08:22 <malllle> Darkwing_: o y and x have to be under the x in xs
14:08:23 <Ahahaha> yes, that's what I have
14:08:39 <chrisdone> Ahahaha: what's the type for this? head (map print [1,2,3])
14:09:10 <Ahahaha> IO ()
14:09:11 <Darkwing_> mallle: sooo... the variables are the ones who need to be aligned, not the equals?
14:09:14 <malllle> Darkwing_: http://lpaste.net/7797421295192244224
14:09:22 <Darkwing_> oh, they both need
14:09:26 <Darkwing_> alright, thanks. fixing that
14:09:26 <chrisdone> Ahahaha: right =) what does it do when you run it?
14:09:40 <agibiansky> Darkwing_: only the variables, aligning the = signs is a choice
14:09:48 <malllle> Darkwing_: and see the given warnings :)
14:09:59 <Ahahaha> it prints the head of the list to stdout
14:10:24 <harlan_> :t ($)
14:10:25 <lambdabot> (a -> b) -> a -> b
14:10:25 <chrisdone> Ahahaha: good stuff. so we need a way to run two IO ()'s in sequence, right?
14:10:46 <Ahahaha> well, we need to run "length xs" IO ()'s in sequence
14:11:13 <chrisdone> Ahahaha: right. do you know how to do just two? print 1 and print 2. how do you run them in sequence in ghci?
14:11:35 <Ahahaha> I'm kind of guessing. is it >>= ?
14:11:47 <chrisdone> close. check the type of (>>=) in ghci
14:12:06 <Ahahaha> monad
14:12:24 <Ahahaha> Monad m => m a -> (a -> m b) -> m b
14:12:37 <chrisdone> you could use that function with print 1 and print 2. want to try?
14:12:52 <chrisdone> in our case, to be clear
14:13:21 <chrisdone> the 'm' in that type, in our case,  will be IO. so the clearer type would be:
14:13:29 <chrisdone> IO a -> (a -> IO b) -> IO b
14:13:36 <chrisdone> does that help in using it?
14:14:09 <Black-Heaven> The base case is: data A; type B = A; :k B and I want to see A :: * instead of B :: *
14:15:06 <chrisdone> Ahahaha: if you get sick of figuring it out i can just tell you the function you need, just let me know. it should be a pretty decent learning experience to figure this example out, tho
14:16:02 <chrisdone> or i can tell you how to use >>= to combine two IO values, but only if you want me to spoil it =)
14:16:10 <FireFly> chrisdone: they got killed apparently
14:16:16 <FireFly> "(Killed (idoru (Spam is off topic on freenode.)))"
14:16:20 <chrisdone> damn
14:17:19 <chrisdone> that's a pity. for once in #haskell i managed to ask a newbie trivial questions without the choir of answers from experts
14:17:23 <chrisdone> =)
14:18:40 <Darkwing_> hey guys, I'm back with another question (sorry, but I'll be hitting you up with a few questions, as my brain is far too tired to realise what's wrong...). What's causing the error in here? http://lpaste.net/2407906249803825152
14:19:00 <relrod> FireFly: They got killed for typing the type signature of bind?
14:19:12 <chrisdone> relrod: presumably pasted some code and got klined?
14:19:24 <relrod> :/
14:19:30 * chrisdone just guessing
14:21:54 <vixlur> Darkwing_: proximaPos signature looks like (a -> (b,c,d) -> e)?
14:22:15 <FireFly> No idea, I guess they might've spammed in another channel
14:23:14 <Darkwing_> vixlur: proximaPos is defined as [String] -> (Int, Int, Char) -> Int -> Int -> Char -> [String]
14:23:41 <chrisdone> i like the idea of an evil spammer doing some spamming, and on the side learning a little haskell
14:25:37 <malllle> Darkwing_: so b is of type Int -> Int -> Char and proximaPos wants be to be (Int, Int, Char)
14:25:58 <vixlur> Darkwing_: ok, i see now. you calling function recebePosicao with only one argument, and getting back function (Int -> Int -> Char), and binding this new function to name 'b'. Then you passing that 'b' as argument to proximaPos function, wich excepts type (Int, Int, Char)
14:26:18 <vixlur> expects*
14:27:46 <Darkwing_> vixlur: exactly
14:29:18 <arianvp___> Is it possible to define catamorphisms for mutually recursive datatypes?
14:29:55 <EvanR> @faq can haskell define catamorphisms for mutually recursive datatypes
14:29:56 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
14:30:32 <arianvp___> Is that a FAQ? .-.
14:30:38 <mauke> no
14:37:35 <arianvp___> Okay. is there something like a Fixpoint for mutually recursive datatypes?
14:41:47 <darthdeus> should I use gcc or clang with ghc 7.8.3?
14:42:00 <mmmm> arianvp___: There is a discussion here http://stackoverflow.com/a/27158837/3710751
14:42:03 <mmmm> in the comments
14:46:27 <arianvp___> Lol. trying to find libraries that solve my problem facing an exercise which needs this stuff, find papers of my teacher
14:47:19 <arianvp___> https://hackage.haskell.org/package/multirec
14:49:25 <Denommus> is there some function like if, with type Bool -> a -> a -> a?
14:49:52 <chrisdone> yeah, somewhere in base
14:49:56 <chrisdone> bool
14:50:14 <chrisdone> http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Bool.html#v:bool
14:50:41 <chrisdone> although arguments are reversed to match the typical partial application use-case
14:50:44 <Denommus> :t bool
14:50:45 <lambdabot> a -> a -> Bool -> a
14:50:48 <Denommus> ok, thanks
14:52:10 <kolossen> playing around with micropython (python for MCUs) after mostly using statically typed languages for a while.  really miss static typing. stupid deploying your code and then have a runtime error when you could have caught it at compilation.7
14:52:36 <kolossen> It would be great with some lightweight version of haskell that could be run on  a 16 or 32 bit mcu
14:52:44 <kolossen> is there something like that?
14:53:07 <luite> jhc / ajhc could work
14:53:39 <agibiansky> Yeah, it would definitely have to be jhc, not ghc
14:56:05 * mmmm now has a working nixos vm
14:56:11 <mmmm> this feels like an achievment
14:56:51 <monochrom> achievement unlocked: nixos vm. next achievement to be unlocked: nixos vm in nixos vm
14:58:28 <jumbi_> (New to Haskell) - Is there a monad like Either that can hold multiple left values (Ex. failing on validation it returns all the errors, and not just the first one)?
14:59:34 <t4nk252> does haskell have a hard exit function for me to terminate a program?
15:00:00 <mauke> @hoogle ExitStatus -> IO a
15:00:02 <lambdabot> Warning: Unknown type ExitStatus
15:00:02 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
15:00:02 <lambdabot> Control.Exception evaluate :: a -> IO a
15:00:05 <mauke> aww
15:00:19 <mauke> @hoogle ExitCode -> IO a
15:00:19 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
15:00:19 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
15:00:19 <lambdabot> Control.Exception evaluate :: a -> IO a
15:01:28 <chrisdone> jumbi_: digestive functors does that, but it may be overkill for what you want
15:02:35 <arianvp___> how can I let cabal dump splices?
15:02:44 <chrisdone> --ghc-options=-ddump-splices
15:03:05 <arianvp___> but where does it dump them?
15:03:17 <dcoutts> arianvp___: same as ghc -ddump-splices
15:03:41 <dcoutts> it's just a generic passthrough to ghc options
15:04:19 <dcoutts> arianvp___: I think all the ghc -d  flags dump to stderr
15:04:32 <chrisdone> arianvp_: are you using `cabal build' or `cabal install'?
15:04:35 <arianvp___> build
15:04:41 <dcoutts> but I may be misremembering
15:04:59 <mmmm> jumbi_: I think there is an applicative which does that
15:05:36 <arianvp___> ah
15:05:39 <arianvp___> I forgot to cabal clean
15:05:42 <arianvp___> :)
15:06:31 <monochrom> you can add -ddump-to-file
15:08:07 <mmmm> jumbi_: here, https://hackage.haskell.org/package/transformers-0.3.0.0/docs/Control-Applicative-Lift.html
15:08:45 <jumbi_> mmmm: Thanks! - I'll see if I can figure it out :)
15:09:23 <chrisdone> i suppose you could also use Writer
15:12:30 <chrisdone> > let throw x = tell [x]; in case execWriter (throw "Oh noes") of [] -> "OK"; errs -> ("Boo! " ++ show errs)
15:12:32 <lambdabot>  "Boo! [\"Oh noes\"]"
15:12:38 <chrisdone> λ> let throw x = tell [x]; in case execWriter (return ()) of [] -> "OK"; errs -> ("Boo! " ++ show errs)
15:12:46 <chrisdone> "OK"
15:13:49 <chrisdone> given that the throw doesn't actually affect the continuation of the computation you're effectively doing the above, i think
15:34:09 <chrisdone> no wonder APl never took off. it has monads and dyads https://www.youtube.com/watch?v=_DTpQ4Kk2wA&t=4m50s
15:34:46 <arianvp___> chrisdone: wow the sound that TTY makes gives me the chills
15:35:01 * arianvp___ now wants to connect a TTY to   my VTTY
15:35:17 <arianvp___> where do you buy this stuff? there must be some "1970s tech junkyard"
15:36:05 <chrisdone> yeah, it's gorgeous and so satisfying to listen to
15:36:53 <basedsiren> hello
15:38:28 <arianvp___> I dyad is just a dyoid in the category of endofunctors
15:39:19 <chrisdone> lol
15:39:24 <chrisdone> endovectors
15:39:36 <agibiansky> a vector from itself to itself?
15:43:37 <arianvp___> this language is so esoteric. amazing :D
15:44:27 <joe9> error: http://codepad.org/fejVQWWr , source:  http://codepad.org/thDlNXQM , I am trying out DataTypeAlaCarte.pdf and am getting these errors.
15:44:31 <joe9> Can anyone please help?
15:44:36 <agibiansky> arianvp_:  it feels kinda like matlab would be like, if MATLAB programmers invented their own unicode operators with the same fervor that haskellers invent ascii ones
15:45:10 <arianvp___> joe9: By any chance an UU Student as well ? As I was just reading that paper.
15:45:20 <arianvp___> like 10 minutes ag o
15:45:26 <joe9> arianvp___: no, I am not.
15:45:44 <eriksensei> arianvp_: i used to live in a place that had these things standing around
15:46:02 <joe9> arianvp___: the "BeautyInTheBeast.pdf" is also a good paper if you are interested.
15:46:04 <eriksensei> they weren't for sale though
15:47:32 <arianvp___> I need some sleep. I can only hear the words "catamorphism, algebra, functor, fixpoint, recursion schemes" in my head. good sign i've been haskelling for too long for today
15:47:34 <arianvp___> cya guys
15:47:53 <chrisdone> ciao
16:03:50 <joe9> error: http://codepad.org/Ehb8Bb3M , source:  http://codepad.org/IhODXCtC . Any help on how to fix it, please?
16:10:22 * hackagebot Deadpan-DDP 0.3.0.2 - Write clients for Meteor's DDP Protocol  http://hackage.haskell.org/package/Deadpan-DDP-0.3.0.2 (LyndonMaydwell)
16:21:36 <EvanR> SICP was ported to python ?? oO
16:22:01 <EvanR> that magician with the lambda spell on the cover seems wildly inappropriate now
16:22:59 <apo_> Oo
16:25:08 <marchelzo_> EvanR: What do you mean by "ported"? I heard python is taught at MIT now, do they use this book?
16:25:48 <EvanR> maybe i read wrong, i guess they switched books
16:25:55 <EvanR> http://chrisdone.com/posts/dijkstra-haskell-java
16:28:13 <bananagram> is there an operator for comparing a variable with multiple numbers?
16:28:23 <bananagram> like 0<x<10
16:28:24 <ReinH> bananagram: like what?
16:28:28 <ReinH> Oh. No.
16:28:37 <bananagram> oh, okay
16:28:40 <ReinH> 0 < x && x < 10
16:36:58 <chrisdone> > inRange (0,10) x
16:37:00 <lambdabot>  No instance for (GHC.Arr.Ix Debug.SimpleReflect.Expr.Expr)
16:37:00 <lambdabot>    arising from a use of ‘GHC.Arr.inRange’
16:37:05 <chrisdone> > inRange (0,10) 5
16:37:06 <lambdabot>  True
16:37:10 <chrisdone> > inRange (0,10) 666
16:37:12 <lambdabot>  False
16:41:13 <EvanR> :t inRange
16:41:14 <lambdabot> Ix a => (a, a) -> a -> Bool
16:42:49 <EvanR> so a haskell program can use java libraries, via the ffi, via the jni, by statically linking the jvm
16:43:05 <hpc> that sounds about right
16:43:42 <EvanR> HMMMMMM
16:43:45 <hpc> or dynamic-linking
16:44:19 <EvanR> so the result would be two runtimes at once, one haskell, one java
16:44:28 <hpc> yeah
16:44:29 <EvanR> two garbage collectors
16:44:46 <EvanR> get your peanut butter out of my jelly
16:44:56 <dibblego> @type and . sequence [(0<), (<10)]
16:44:56 <hpc> the jvm is more taking the role of a framework in this scenario
16:44:57 <lambdabot> (Ord a, Num a) => a -> Bool
16:45:35 <EvanR> i wonder what the profiling prospects are for this setup
16:46:08 <hpc> you'll want to see if you can pass debugging options to the jvm from haskell
16:48:31 <EvanR> i spy a package java-bridge
16:55:24 * hackagebot lucid 2.2 - Clear to write, read and edit DSL for HTML  http://hackage.haskell.org/package/lucid-2.2 (ChrisDone)
17:20:25 * hackagebot hakyll-contrib-hyphenation 0.1.0.0 - Automatic hyphenation for Hakyll  http://hackage.haskell.org/package/hakyll-contrib-hyphenation-0.1.0.0 (firegurafiku)
17:34:12 <indiagreen> chrisdone: um, thank you for the video, my girlfriend has just watched it and it helped nem get rid of an anxiety attack
17:34:25 <chrisdone> huh?
17:34:40 <indiagreen> “it's gorgeous and so satisfying to listen to”
17:34:43 <chrisdone> oh, the teletype
17:34:51 <chrisdone> =)
17:35:25 * hackagebot hakyll-contrib-hyphenation 0.1.0.1 - Automatic hyphenation for Hakyll  http://hackage.haskell.org/package/hakyll-contrib-hyphenation-0.1.0.1 (firegurafiku)
17:38:33 <FireFly> I wish I had an APL teletype
17:42:39 <chrisdone> FireFly: Christmmas is coming up
17:42:51 <chrisdone> FireFly: maybe you can keep the one you were going to give to Tiny Tim
17:45:29 <EvanR> wingdings keyboard
17:47:24 <FireFly> APL isn't *that* weird
17:48:22 <FireFly> http://i.imgur.com/I0smJ8F.jpg
17:50:39 <EvanR> voynich manuscript keyboard
17:51:08 <chrisdone> i'm currently writing
17:51:13 <chrisdone> woops
17:52:05 <chrisdone> currently writing a program to generate a report of my typing statistics
17:52:25 <FireFly> That sounds useful, mind sharing it?
17:53:47 <chrisdone> currently a WIP here https://github.com/chrisdone/keyboard-stats
17:54:04 <chrisdone> requires linux
17:54:19 <Rufflewind> I'm looking the implementation of De Bruijin indices (abstract + instantiate) in this article https://www.fpcomplete.com/user/edwardk/bound#de-bruijn-indices and it seems that the lambda case is missing a Lam constructor for the right-hand side
17:54:51 <chrisdone> you run xinput-keylogger to log all your keys. stick it in screen or w/e, and then you can run keyboard-stats on the resulting file. but it doesn't display anything interesting yet
17:56:34 <chrisdone> current output is simply:
17:56:35 <chrisdone> During this 3 day reporting period, there were 99,979 key presses with an average typing speed of 25wpm (min/max: 0/350).
17:57:09 <chrisdone> i intend to add some charts and display bad habbits
17:57:26 <chrisdone> like one-handed chording and holding down a key (like arrows) instead of using jump commands. common mistakes, etc
17:57:58 <chrisdone> also i want to figure out some possible recommended daily quota for myself
18:00:22 <chrisdone> i have a month's worth of typing data, aproxx 79MB. takes about 2 minutes for my proggie to churn through it, although i didn't do any optimization so far
18:02:26 <chrisdone> During this 36 day reporting period, there were 1,955,467 key presses with an average typing speed of 28wpm (min/max: 0/411).
18:02:33 <chrisdone> ^ that's the output for the full data file =)
18:03:17 <OlegYch> that sounds O(n^2)
18:04:15 <codygman> What is the const doing in this code? My intuition is telling me it helps the types match up.... no wait const is just a "pretend" function that gives you what you pass in right? https://github.com/Soostone/snaplet-persistent/blob/master/src/Snap/Snaplet/Persistent.hs#L174
18:05:14 <Rufflewind> codygman: yep, const x is just \ _ -> x
18:05:33 <codygman> Rufflewind: In that case it isn't needed though is it?
18:05:41 <chrisdone> the odd thing is that the cherry mx blue key switches claim "Long life 50 million operations"
18:06:01 <chrisdone> but if i've done almost 2 million presses in one month, and i've had this for four years
18:06:21 <chrisdone> my keyboard must be FUBAR'd
18:06:29 <flux> chrisdone, you have probably pressed more than just one key, though
18:06:40 <apo_> chrisdone: does it just do keys/time, or filter out periods of inactivity?
18:06:43 <chrisdone> ah true true
18:06:52 <codygman> unevenly distributed though ;)
18:06:54 <flux> 50 megabytes in text is a lot, but maybe not inachievable
18:06:54 <chrisdone> flux: i was thinking of making a keyboard heatmap
18:07:09 <flux> 50 megabytes per key.. that sounds quite alot.
18:07:11 <chrisdone> so i can see how much punishment each key switch is taking
18:07:18 <Rufflewind> codygman: I think const (error ...) is semantically equivalent to just error, but I may be wrong :)
18:07:18 <flux> even with just with 10 keys..
18:07:24 <flux> and you probably use close to 30
18:07:51 <Rufflewind> codygman: actually, more precisely, it's equivalent if the result is not used strictly
18:08:01 <flux> in any case, 2 million presses/month as well sounds a lot
18:08:06 <chrisdone> apo_: it filters out inactivity. i count a "cluster" as being any keys which occur within one second of eachother
18:08:06 <flux> are you sure it's counting them properly :)
18:08:34 <apo_> Hmm
18:08:37 <apo_> One second should be fine
18:08:39 <chrisdone> flux: it's definitely accurate. try it yourself
18:08:52 <chrisdone> it counts pressing ctrl, shift, etc.
18:09:02 <chrisdone> not just "letter" or "symbol"
18:09:11 <apo_> Depending on if you want to count little thinking pauses as being part of typing or not
18:09:14 <flux> the space key probably gets hit the most?
18:09:24 <flux> it's the biggest key :)
18:09:32 <flux> though shift might be a big contender
18:09:48 <chrisdone> apo_: yeah, i was thinking i'd make the pause adjustable, but one second feels like a good starting estimate
18:09:57 <chrisdone> flux: also Ctrl, for emacs users =p
18:10:18 <apo_> flux: Eh, pretty much every word has a space after it, but at least in English not that many words get a space. It changes when you start typing special characters, but I don't think it's anywhere close
18:11:01 <chrisdone> i'll have to make a HashMap histogram of keys to find out =)
18:11:40 <EvanR> :t const
18:11:41 <lambdabot> a -> b -> a
18:11:56 <EvanR> :t const x
18:11:57 <lambdabot> b -> Expr
18:12:20 <jle`> > const x "hello"
18:12:21 <lambdabot>  x
18:13:13 <chrisdone> flux: fwiw the file contains "timestamp,event,code" where event is either press or release
18:13:18 <EvanR> codygman: another "useless" function is id, which returns its argument. and mempty "does nothing" when mappended to something ;)
18:13:33 <chrisdone> i'll be able to use the press/release information to know how long i hold down a key, and detect chording,  etc
18:13:36 <EvanR> what do you expect from a lazy language
18:13:46 <apo_> chrisdone: Not sure I'd want all that data in a file
18:14:18 <chrisdone> apo_: i write to it in a log file that the xinput user only has read/write access to
18:14:27 <apo_> still ;)
18:14:58 <apo_> saving plaintext passwords is bad
18:16:41 <chrisdone> no special user privs are required to record your keyboard
18:16:55 <chrisdone> a program doesn't need to find your password files, it can just do what i'm doing
18:16:56 <EvanR> codygman: at one point people had no use for the number zero!
18:18:19 <apo_> chrisdone: this enables offline attacks as well, though
18:18:31 <chrisdone> apo_: you mean like having hold of my laptop?
18:18:34 <apo_> yes
18:18:46 <chrisdone> i don't encrypt my drive, they can just boot it up and login to gmail with the cookies
18:19:14 <apo_> and you store all your passwords on it too. Nice :p
18:19:29 <chrisdone> who needs passwords when you have access to someone's email?
18:19:37 <chrisdone> all the passwords are accessible from there
18:19:50 <apo_> what
18:20:01 <apo_> My mails don't contain passwords
18:20:11 <chrisdone> of course not
18:20:39 <chrisdone> but the way to reset your password on any service,  or request new information always goes via your email
18:20:41 <apo_> and you won't be able to read my mails without a password, either, even if you get a hold of my PC and manage to use it :p
18:21:00 <chrisdone> unless you're fortunate enough to have setup two-stage authentication ;)
18:21:29 <apo_> or just use a password
18:22:37 <chrisdone> apo_: so you always shut down your laptop when you're done with it?
18:23:36 <apo_> I lock it
18:24:15 <chrisdone> should be safe then =)
18:24:33 <apo_> well, somebody could open it and get at the RAM :p
18:25:18 * EvanR sends apo_ an email with a password in it
18:25:54 <apo_> EvanR: Here's another password, GEGPkusPcIk/nmQzyioI2w==
18:26:44 <heatsink> Why is array getBounds monadic?
18:26:49 <EvanR> base64, thats uncrackable
18:27:30 <apo_> EvanR: Hm? This is the actual password I would use.
18:28:31 <apo_> it's a hash of some stuff (in this case nonsense), and to make it human-readable but shorter than hexadecimal (plus I get symbols!) I use b64
18:28:49 <chrisdone> apo_: does your healthy paranoia extend towards plain storage of private keys, as in ~/.ssh/?
18:29:27 <apo_> chrisdone: they're password protected, if that's what you meant
18:30:06 <chrisdone> apo_: i see, so you type the password at the prompt each time you do an ssh/scp thing?
18:30:47 <apo_> chrisdone: ssh-agent
18:32:47 <chrisdone> apo_: =)
18:33:09 <EvanR> after seeing a erlang go error handling gif, i started reading about go, and found pointers and gotos.. and realized why i never looked into this
18:33:11 <apo_> this stuff really isn't much additional effort
18:33:48 <apo_> plus eventually your passwords go into muscle memory :p
18:37:24 <chrisdone> apo_: ja. i could encrypt the log file, but like you said earlier, offline attacks make that pointless
18:38:27 <apo_> I'd simply not log it like that
18:38:40 <apo_> You lose the flexibility of being able to change your statistics afterwards, though
18:38:46 <chrisdone> i could lot 'letter' instead of the actual letters
18:38:52 <chrisdone> ja
18:38:56 <apo_> just write out the statistics you need
18:40:01 <chrisdone> yeah  that's the ideal scenario
18:40:11 <chrisdone> you have to actually know what you want to generate
18:40:27 <apo_> of course
18:40:28 <chrisdone> i don't know what data is interesting yet
18:40:32 <apo_> It'll be an incremental process ;)
18:40:45 <chrisdone> it won't =p
18:41:03 <apo_> difference between left and right hand might be interesting
18:41:06 <apo_> in speed, I mean
18:42:25 <apo_> not sure how to measure, maybe just do a histogram of the delay after hitting any key to hitting a key with <hand>
18:42:46 <apo_> possibly even subdivide into <hand 1> -> <hand 2> combinations
18:46:18 <codygman> EvanR: I didn't say id or const was useless did I? If so, I certainly didn't mean to!
18:47:52 <apo_> Oh well, gotta learn how to USB tomorrow, so it's time to go horizontal for a bit ;) Good night
18:47:56 <chrisdone> apo_: i think i could store a given cluster in memory until the cluster is over and then do a calculation on it
18:48:33 <apo_> chrisdone: That's a nice idea
18:50:13 <chrisdone> apo_: eh, you're right. i've collected data and proved that it can be reliable and interesting stuff can be garnered from it. merging it into one process instead of the two step log and parse will simplify it and make it faster, and safe
18:50:37 <TallerGhostWalt> so arm64 is going to be in 7.10 right? I saw the patch
18:50:41 <chrisdone> reasonably safe, anyway
18:51:00 <chrisdone> (as safe as a program staring at your key presses can be =)
18:51:21 <zrl> sorry for the newbie question, but what's the recommended way to debug applications in haskell? i'm currently using the repl and print statements, but i'd like to print a debug value in a procedure that's not an IO procedure
18:52:04 <chrisdone> apo_: this way i can also do live alerts about quotas =)
18:52:09 <shachaf> zrl: There is Debug.Trace
18:53:04 <chrisdone> trace "some message" <some expression>
18:54:31 <chrisdone> did anyone ever write a simple transformation with HSE or whatnot to add Debug.Trace.trace calls around every expression in a declaration or module?
18:55:12 <chrisdone> i suppose you can achieve similar with ghci's debugger
18:56:53 <zrl> shachaf, chrisdone: thank you so much!
19:00:07 <zrl> if i don't want to run an expression and just trace something, can i just do `trace "msg" ()` ?
19:00:39 <shachaf> Yes, assuming that that whole thing is evaluated.
19:01:27 <zrl> hmm, i'm getting a type error when i do that and i'm not super sure how to understand it
19:01:32 <zrl>                                                                                                
19:01:32 <zrl> Main.hs:59:37:
19:01:32 <zrl>     Couldn't match expected type ‘Process a0’ with actual type ‘()’
19:01:32 <zrl>     In the second argument of ‘trace’, namely ‘()’
19:01:32 <zrl>     In a stmt of a 'do' block: trace "Hi!" ()
19:03:28 <zrl> here's a gist of the function https://gist.github.com/zachlatta/fec3f406bfc59f42859a
19:04:10 <silasm> zrl: trace's return type is the same as the type of its second argument.
19:05:10 <silasm> so if you use it with () as its second argument where Haskell expects some other type T, you'll get a type error like the one you got.
19:05:12 <shachaf> zrl: Your trace expression has to be of type "Process something" to fit in in that do block.
19:05:18 <shachaf> But () :: ()
19:05:27 <shachaf> Maybe you want trace ... (return ())
19:09:02 <zrl> ohh, got it
19:09:04 <zrl> thank you!
19:10:29 * hackagebot string-class 0.1.6.1 - String class library  http://hackage.haskell.org/package/string-class-0.1.6.1 (ByronJohnson)
19:26:30 <slack1256> what's the current solution to instances that don't obey typeclass laws?
19:32:07 <CARAM_> I'm using parsec and am looking for a certain string, but want to return with a different value if it's found... is (string "look" >> return "return val") the correct way to do this?
19:32:44 <shachaf> It works.
19:32:57 <shachaf> There's a utility function for doing that, $> (and also <$ )
19:33:14 <shachaf> x $> y = x >> return y , more or less
19:33:27 <shachaf> And x <$ y = y >> return x
19:33:50 <CARAM_> okay, thanks! I'm new so just wanted to make sure I was doing things the correct way
19:46:49 <zrl> i'd like to somehow create an instance of Binary for https://hackage.haskell.org/package/github-0.13/docs/Github-Data-Definitions.html#t:Error so i can serialize and send it over the network with Cloud Haskell. the implementation in the github package doesn
19:46:56 <egoldsten_> hello
19:47:11 <zrl> *doesn't derive from GHC.Generic, so i'm unable to create an instance of it
19:47:43 <zrl> how can i send the Error type in the github package over the network? also, please correct me if i'm using incorrect terminology. still super new to haskell :p
19:48:45 <wei2912> zrl: you might want to join #haskell-beginners, btw
19:48:59 <zrl> wei2912: will do, did not know about the channel!
19:49:26 <zrl> joined, thank you!
20:01:40 <bryanedds> Is the IO monad is implemented in terms of unsafePerformIO?
20:03:45 <EvanR> bryanedds: i dont think so, it is at least partially implemented with primitives
20:03:58 <EvanR> and the >>= operation is primitive
20:04:14 <bryanedds> ah hm
20:04:35 <bryanedds> ya, the monad itself doesn't need unsafePerformIO, ya
20:04:47 <bryanedds> it's argument might tho, I suppose
20:04:52 <EvanR> some standard functions do use unsafePerformIO, but thats not the IO monad in general
20:08:12 <EvanR> bryanedds: btw you can go read the implementations of various IO actions in the docs https://hackage.haskell.org/package/base-4.3.1.0/docs/src/GHC-IO-Handle-Text.html#hGetLine
20:08:25 <bryanedds> ah cool, thanks!
20:28:37 <sccrstud92> @pl f a = a
20:28:37 <lambdabot> f = id
20:29:12 <sccrstud92> @pl f ftb btb =  (fmap join . join . (fmap . traverse) btb) . ftb
20:29:12 <lambdabot> f = flip ((.) . ((fmap join . join) .) . fmap . traverse)
20:29:22 <sccrstud92> @pl f btb ftb =  (fmap join . join . (fmap . traverse) btb) . ftb
20:29:22 <lambdabot> f = (.) . ((fmap join . join) .) . fmap . traverse
20:30:21 <slack1256> anybody getting core dump from haskellmode-vim?
20:30:22 <sccrstud92> @pl f btb = sequence . fmap btb
20:30:22 <lambdabot> f = (sequence .) . fmap
20:31:46 <sccrstud92> @pl f btb ftb =  (fmap join . join . (fmap (traverse btb))) . ftb
20:31:46 <lambdabot> f = (.) . ((fmap join . join) .) . fmap . traverse
20:33:36 <trap_exit> why has haskell not taken over the world yet?
20:34:58 <dmj`> trap_exit: the real world still thinks you have to know category theory to use haskell
20:35:21 <trap_exit> that's necessary but not sufficient
20:35:29 <trap_exit> you need a phd in category theory to use haskell
20:35:33 <trap_exit> no wonder people give up so soon
20:35:41 <dmj`> trap_exit: that's completely untrue
20:40:15 <wei2912> trap_exit: no you don't
20:40:25 <wei2912> i don't know a single bit of category theory
20:40:37 <trap_exit> gentlemen
20:40:42 <trap_exit> you're missing the <humor> tag :-)
20:40:55 <trap_exit> I mysef have never read a book / taken a course on category theory.
20:41:22 <simpson> trap_exit: Why hasn't anything else taken over the world?
20:41:34 <trap_exit> oh, because theyr'e not 10x better
20:41:40 <trap_exit> or becuase theyre not free
20:41:45 <wei2912> trap_exit: get out of here with your xml! >:
20:41:52 <trap_exit> or because, being non-software, they're not free to replicate
20:42:24 <trap_exit> wei2912: xml is basically lisp sexps for people who donm't know lisp
20:42:35 <wei2912> trap_exit: haha
20:42:41 <trap_exit> it's like "lisp is too concise, we need to make it as verbose as java" -- oh, let's invent XML
20:42:58 <simpson> trap_exit: That's...really not how XML works.
20:43:15 <wei2912> heresy!
20:43:23 <simpson> XML has schemata, for starters.
20:43:52 <trap_exit> it's totaly how XML was invented, guy 1: let's use lisp to store our data, manager: ARGh, too many ()'s ; guy 2: what if we used < > 's to make it look more like HTML, manager: that's brilliant!
20:44:01 <wei2912> no wait
20:44:13 <wei2912> you got it reversed
20:51:22 <danlamanna> can anyone tell me the (hopefully) obvious mistake here:
20:51:23 <danlamanna> removeDotAndDotDot paths = [path | path <- paths, path `notElem` [".", ".."]]
20:52:37 <shachaf> You tell us.
20:53:58 <danlamanna> shachaf: let
20:54:10 <shachaf> ?
20:54:27 <danlamanna> shachaf: i was using the repl, forgot to put let before it. putting let before and it worked correctly
20:54:46 <shachaf> Ah. There you go. :-)
21:01:06 <rhollor> If I were to put this:
21:01:06 * rhollor test 1 = "one"
21:01:06 <rhollor> test 2 = "two"
21:01:12 <rhollor> test x = "dont't know the number"
21:01:36 <rhollor> well, you know what it would do?
21:02:03 <rhollor> I was just wondering if it's possible to filter function definitions like that by type
21:05:55 <rhollor> like test Int = "an integer!!" or something
21:06:56 <wei2912> rhollor: hmm?
21:07:45 <wei2912> > let test 1 = "one"; test 2 = "two"; test x = "don't know the number" in test 1
21:07:47 <lambdabot>  "one"
21:07:48 <wei2912> > let test 1 = "one"; test 2 = "two"; test x = "don't know the number" in test 2
21:07:50 <lambdabot>  "two"
21:07:51 <wei2912> > let test 1 = "one"; test 2 = "two"; test x = "don't know the number" in test 10
21:07:53 <lambdabot>  "don't know the number"
21:07:55 <wei2912> ^^
21:08:30 <wei2912> @let test 1 = "one"; test 2 = "two"; test x = "don't know the number"
21:08:32 <lambdabot>  Defined.
21:08:34 <wei2912> :t test
21:08:35 <lambdabot> (Num a, Eq a) => a -> [Char]
21:09:11 <wei2912> if you're asking about how to test for an integer or float, i'm not sure about that
21:10:12 <rhollor> wei2912: is there any way to do, like, pattern matching, similar to above, except that it evaluates by the type of input rather than the value of the input itself
21:10:44 <wei2912> ah, i see
21:10:45 <rhollor> like it could look something like: let test x :: Int = "I'm an integer!!"; let test x :: Float = "I'm a float!!";
21:11:01 <rhollor> or something
21:11:25 <DrPinkHack_> rhollor: what is the use case?
21:12:03 <rhollor> I don't have any special use case. I'm just learning Haskell and I was wondering if it was possible.
21:17:25 <DrPinkHack_> > isInt x = typeOf x == typeof (undefined :: Int); print $ isInt (5 :: Float)
21:17:26 <lambdabot>  <hint>:1:9: parse error on input ‘=’
21:17:43 <DrPinkHack_> > let isInt x = typeOf x == typeof (undefined :: Int); print $ isInt (5 :: Float)
21:17:44 <lambdabot>  <hint>:1:80:
21:17:44 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
21:18:15 <DrPinkHack_> @let isInt x = typeOf x == typeOf (undefined :: Int)
21:18:16 <lambdabot>  Defined.
21:18:20 <DrPinkHack_> :t isInt
21:18:20 <lambdabot> Typeable a => a -> Bool
21:18:30 <DrPinkHack_> > isInt (5 :: Float)
21:18:31 <lambdabot>  False
21:18:40 <DrPinkHack_> rhollor: something like that?
21:23:25 <dmwit> DrPinkHack_: Type classes are somewhat like a type-level case statement.
21:23:28 <dmwit> err
21:23:31 <rhollor> DrPinkHack_: I was looking for a way to simply define functions by matching input types, and not values. What you're function does is check if the input is an Int.
21:23:32 <dmwit> rhollor: @ you I mean
21:24:05 <rhollor> dmwit: I'm sorry. I'm new to this. I don't know what that means
21:24:37 <dmwit> You are asking how to "pattern match" (i.e. do a case statement) on types.
21:24:37 <DrPinkHack_> rhollor: my code could be easily extended to test for other types
21:24:42 <dmwit> Type classes are essentially that.
21:24:52 <dmwit> You declare a separate instance for each type you're interested in.
21:25:08 <wei2912> > typeOf 3
21:25:10 <lambdabot>  Integer
21:25:18 <dmwit> gotta run, but if you come up with something more concrete let me know and I'll give a shot at helping you when I get back (roughly 45 minutes)
21:25:29 <rhollor> yes
21:28:32 <rhollor> I'm going to write my expected output for what I'm looking for. Just give me a sec
21:37:17 <lpaste> rhollor pasted “type test” at http://lpaste.net/115317
21:39:59 <lpaste> DrPinkHack_ pasted “type test” at http://lpaste.net/115318
21:40:14 <DrPinkHack_> rhollor: see ^^^
21:42:56 <rhollor> DrPinkHack_ That's pretty much what I was looking for
21:43:24 <rhollor> I was kind of hoping it wouldn't take up so much space though
21:44:30 <rhollor> DrPinkHack_ when I type 'typeOf' into my prompt, it says "Not in scope: ‘typeOf’"
21:44:45 <DrPinkHack_> :m +Data.Typeable
21:45:34 * hackagebot samtools 0.2.4 - Binding to the C samtools library  http://hackage.haskell.org/package/samtools-0.2.4 (NicholasIngolia)
21:58:21 <dmwit> rhollor: class Testable a where test :: a -> String; instance Testable Integer where test _ = "integer"; instance Testable Float where test _ = "float"; etc.
22:00:53 <DrPinkHack_> dmwit: doh
22:25:36 * hackagebot monad-state 0.2.0.1 - Utility library for monads, particularly those involving state  http://hackage.haskell.org/package/monad-state-0.2.0.1 (ByronJohnson)
22:55:36 * hackagebot samtools 0.2.4.1 - Binding to the C samtools library  http://hackage.haskell.org/package/samtools-0.2.4.1 (NicholasIngolia)
22:55:39 * hackagebot meta-misc 0.1.0.2 - Utility library providing miscellaneous meta-programming utilities.  http://hackage.haskell.org/package/meta-misc-0.1.0.2 (ByronJohnson)
23:15:37 * hackagebot bindings-libstemmer 0.1.0.0 - Binding for libstemmer with low level binding.  http://hackage.haskell.org/package/bindings-libstemmer-0.1.0.0 (cosmo0920)
23:35:38 * hackagebot samtools-conduit 0.1.0.0 - Conduit interface to SAM/BAM format files through samtools  http://hackage.haskell.org/package/samtools-conduit-0.1.0.0 (NicholasIngolia)
