00:00:25 <droidboi> a bit of a squeeze to fit all the operators in?
00:00:30 <ChristianS> hmm, hoogle is sometimes disappointing for finding modules, e.g. if i type "Data.HashMap" or "Data.HashMap.Strict" it doesn't find it. anyone knows whether there is a trick to fix that?
00:01:49 <Haskellfant> it does find the hashmap package for me
00:02:06 <Haskellfant> you could try hayoo
00:02:10 <Lutin> droidboi: Yeah kind of
00:03:07 <Haskellfant> I'm not sure it would be a good idea if you need to remember 256 precedences or something like that
00:03:14 <ChristianS> Haskellfant: i want the version in unordered-containers, hashmap is deprecated. and hoogle doesn't about the unordered-containers package, it just doesn't show it.
00:03:43 <Haskellfant> ChristianS: fpcomplete hoogle does https://www.fpcomplete.com/hoogle?q=Data.HashMap&env=ghc-7.8-stable-14.09
00:03:58 <Haskellfant> hayoo does too http://hayoo.fh-wedel.de/?query=Data.HashMap
00:04:19 * hackagebot logging-facade 0.0.0 - Simple logging abstraction that allows multiple backends  http://hackage.haskell.org/package/logging-facade-0.0.0 (SoenkeHahn)
00:04:57 <ChristianS> Haskellfant: ah, i'll try fpcomplete then, thanks
00:05:16 <Haskellfant> fpcomplete hoogle indexes a lot more packages than standard hoogle does
00:05:40 <redtricycle> Prelude Data.List> let a=["one","two","three"]
00:05:41 <redtricycle> Prelude Data.List> a !! ((elemIndex "two" a) + 1)
00:05:56 <redtricycle> I get this error...Couldn't match expected type ‘Int’ with actual type ‘Maybe Int’
00:06:12 <Lutin> :t elemIndex
00:06:13 <lambdabot> Eq a => a -> [a] -> Maybe Int
00:06:21 <redtricycle> How do I turn Maybe Int into INt?
00:07:39 <sivteck> fromMaybe
00:07:39 <Haskellfant> redtricycle: pattern matching
00:08:00 <redtricycle> got it, fromJust also worked
00:08:01 <sivteck> > fromMaybe 23 (Just 100)
00:08:03 <lambdabot>  100
00:08:09 <Haskellfant> redtricycle: fromJust is bad in most cases.
00:08:18 <Haskellfant> if you are using a maybe there is probably a reason for it
00:08:25 <Haskellfant> with fromJust you just ignore this
00:08:28 <Lutin> Pattern matching or using Functor instance of Maybe would be better
00:08:50 <Haskellfant> yeah functor instance until the point where you can handle the Nothing
00:09:04 <jle`> redtricycle: what do you eventually want to do with it?
00:09:19 <redtricycle> jle` parsing a giant hxt list
00:09:20 * hackagebot brainfuck-tut 0.6.0.0 - A simple BF interpreter.  http://hackage.haskell.org/package/brainfuck-tut-0.6.0.0 (alcabrera)
00:09:26 <Lutin> map (\i -> a !! (i + 1)) (elemIndex "two" a)
00:09:27 <redtricycle> so, i'm doing
00:09:36 <redtricycle> elemIndex "points" giantlist
00:09:44 <Lutin> sorry, fmap
00:09:50 <redtricycle> and doing (1) + . fromJust $ elemIndex "points" giantlist
00:09:51 <redtricycle> seems to work
00:09:51 <redtricycle> er
00:09:56 <redtricycle> (+) 1 . etc
00:10:16 <jle`> is there a meaningful situation where it would fail to look it up?
00:10:31 <dmj`> can anyone recommend a good xml library for haskell
00:10:33 <jle`> if you want your entire function to return Nothing if there is a fail, you can use `fmap`
00:10:52 <redtricycle> ok, let me check out fmap
00:10:56 <redtricycle> that's what Lutin put up there?
00:10:58 <jle`> if you want to "squash" the Nothing right there, you can just use fromMaybe
00:11:21 <Lutin> @let a = ["one","two","three"]
00:11:24 <lambdabot>  Defined.
00:11:47 <Lutin> ugh can't paste in PuTTY
00:11:53 <Lutin> > fmap (\i -> a !! (i + 1)) (elemIndex "two" a)
00:11:55 <lambdabot>  Ambiguous occurrence ‘a’
00:11:55 <lambdabot>  It could refer to either ‘L.a’, defined at L.hs:156:1
00:11:55 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.a’,
00:11:55 <lambdabot>                           imported from ‘Debug.SimpleReflect’ at L.hs:118:1-26
00:11:55 <lambdabot>                           (and originally defined in ‘simple-reflect-0.3.2:De...
00:12:09 <Lutin> lol
00:12:12 <Erstarrung> :D
00:12:13 <Lutin> @undefine
00:12:13 <lambdabot> Undefined.
00:12:20 <Lutin> @let mylist = ["one","two","three"]
00:12:21 <lambdabot>  Defined.
00:12:33 <Lutin> > fmap (\i -> mylist !! (i + 1)) (elemIndex "two" mylist)
00:12:34 <lambdabot>  Just "three"
00:12:47 <Lutin> > fmap (\i -> mylist !! (i + 1)) (elemIndex "four" mylist)
00:12:49 <lambdabot>  Nothing
00:13:14 <Lutin> Though in this case I probably wouldn't write it that way
00:14:20 * hackagebot brainfuck-tut 0.6.0.1 - A simple BF interpreter.  http://hackage.haskell.org/package/brainfuck-tut-0.6.0.1 (alcabrera)
00:17:15 <Lutin> Since I don't think elemIndex and (!!) would fuse
00:17:22 <Lutin> but not sure
00:21:33 <redtricycle> I like the fmap case
00:21:37 <redtricycle> thought in my record structure
00:21:43 <redtricycle> i need to use "Maybe String" instead of String
00:21:45 <redtricycle> but it works for me
00:25:17 <Lutin> I'd probably do something like
00:26:18 <Lutin> @def elemAfter a (x:y:xs) | a == x = Just y | otherwise = elemAfter a (y:xs); elemAfter _ _ = Nothing
00:26:19 <lambdabot>  Defined.
00:26:30 <Lutin> ugh one-line guards are ugly
00:28:01 <Zemyla> :t elemAfter
00:28:02 <lambdabot> Eq a => a -> [a] -> Maybe a
00:28:08 <Lutin> or you could write it as a fold
00:28:35 <Lutin> But I have better things to do lol
00:28:51 <Zemyla> @pl elemAfter
00:28:51 <lambdabot> elemAfter
00:30:19 <tdammers> guys, does anyone know the magic incantation for getting a Persist key from a Scotty route?
00:30:35 <tdammers> persistent docs are all a bit biased towards yesod
00:33:09 <tsotf> hello everybody :)
00:48:03 <ape_> @help
00:48:04 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:48:13 <ape_> @help list
00:48:13 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
00:48:51 <ape_> @pl f g x y = f (g x y)
00:48:51 <lambdabot> f = fix ((.) . (.))
00:50:56 <ape_> @pl f1 xs = map (\x -> x + 1) xs
00:50:57 <lambdabot> f1 = map (1 +)
00:52:28 <ape_> f2 xs = map (\x ->  2 * x) (map (\x -> x + 1) xs) 
00:52:35 <ape_> @pl f2 xs = map (\x ->  2 * x) (map (\x -> x + 1) xs) 
00:52:35 <lambdabot> (line 1, column 51):
00:52:35 <lambdabot> unexpected '\128'
00:52:35 <lambdabot> expecting variable, "(", operator or end of input
00:54:21 * hackagebot seqloc-datafiles 0.4 - Read and write BED and GTF format genome annotations  http://hackage.haskell.org/package/seqloc-datafiles-0.4 (NicholasIngolia)
00:54:37 <ape_> @pl f7 f g h x = g (h (f x))
00:54:37 <lambdabot> f7 = flip ((.) . (.)) . flip (.)
00:54:50 <ape_> @pointless f7 f g h x = g (h (f x))
00:54:50 <lambdabot> f7 = flip ((.) . (.)) . flip (.)
00:55:35 <ape_> @pl f6 f g x y z = f (g x y z)
00:55:35 <lambdabot> f6 = (.) . (.) . (.)
00:56:02 <ape_> @pl f4 f g x = f (g x)
00:56:02 <lambdabot> f4 = (.)
00:57:01 <Zemyla> @pl f4 f g x = g (x f)
00:57:01 <lambdabot> f4 = flip (.) . flip id
00:57:14 <ape_> @pl f3 xs = filter (\x -> x > 1) (map (\x -> x + 1) xs)
00:57:14 <lambdabot> f3 = filter (> 1) . map (1 +)
00:57:58 <ape_> @pl f2 xs = map (\x ->  2 * x) (map (\x -> x + 1) xs)
00:57:58 <lambdabot> f2 = map ((2 *) . (1 +))
01:04:22 * hackagebot seqloc 0.6 - Handle sequence locations for bioinformatics  http://hackage.haskell.org/package/seqloc-0.6 (NicholasIngolia)
01:31:29 <jarlg> How long should f.ex. "cabal install mtl" take? I've had it running for hours on "Configuring transformers-0.4.2.0...", nothing seems to happen.
01:33:09 <jarlg> It's a slow cpu (ARM) but I didn't expect that slow..! (I've left cabal installs over night before without them finishing, wondering if something's wrong..)
01:37:35 <osa1> is there a way to tell doctest to "recursively walk through dirs and run all doctests" ?
01:39:10 <ChristianS> jarlg: no idea but it seems like it hangs?
01:39:23 * hackagebot logging-facade-journald 0.0.0 - Journald back-end for logging-facade  http://hackage.haskell.org/package/logging-facade-journald-0.0.0 (SoenkeHahn)
01:43:23 <jarlg> ChristianS: Yeah, seems to me. with -v it never goes past "redirecting build log to {handle : "..."}" and the build log is always empty.
01:52:44 <Lutin> jarlg: You could run it with gdb and see where it's hanging
01:52:57 <Lutin> but there might be a more haskelly way to do that
01:53:09 <Lutin> as I'm ghc backtraces are...fun
01:53:16 <Lutin> s/I'm//
02:06:43 <prinsen> merijn: My JS interpreter "works"!
02:07:51 <L8D> :D
02:08:19 <prinsen> its a single file
02:08:27 <L8D> is it readable?
02:08:32 <L8D> does it use appropriate abstractions?
02:10:21 <prinsen> L8D: I think so
02:10:32 <prinsen> L8D: Its about 4k lines
02:10:41 <prinsen> which isn't very much
02:10:46 <prinsen> mabye?
02:14:18 <gfixler> prinsen: does it automatically add semicolons?
02:14:24 * hackagebot linear 1.15.4 - Linear Algebra  http://hackage.haskell.org/package/linear-1.15.4 (EdwardKmett)
02:16:04 <prinsen> gfixler: yes
02:16:21 <prinsen> gfixler: It was a pretty simple additition to the parser
02:18:38 <favetelinguis> Over at the Edx Haskell course Erik Meijer repeatedly says thet useing the Maybe type for faild computations is not something we should do, insted we should use the empty list. It has been my understanding that the Maybe type is something good and that we should use it. How much of this is his personal opinion and what is the opinion of the larger Haskell community?
02:19:27 <gfixler> favetelinguis: also doing the course, and have been wondering the same thing
02:19:51 <gfixler> there are a lot of nice functions built up around Maybe types
02:20:05 <gfixler> like catMaybes and mapMaybe
02:20:43 <gfixler> Maybe a also makes things more obvious immediately what you're doing, whereas lists have a lot of other uses
02:21:24 <favetelinguis> and we can use Maybe as a applicative and apply any regular function on it
02:21:32 <favetelinguis> so dont really see what the problem is
02:21:39 <gfixler> yeah, and there are a lot of functions that expect Maybe types
02:21:46 <gfixler> and return them
02:21:59 <gfixler> I got the sense that he was talking about certain, small areas
02:22:23 <gfixler> e.g. if he's just writing a small function to do something that might fail, he'll just use a list
02:22:39 <gfixler> but as part of a larger system with a lot of interactions, I would guess that Maybes hold sway
02:22:58 <favetelinguis> and since we want to try to make are functions as general as possible maybe type is better, if you use [] we can only use lists with that function
02:23:06 <gfixler> otherwise you're losing out on all the library code built around failure
02:23:26 <gfixler> well, both are polymorphic contexts
02:23:32 <masse> Also you could make the distinction between a computation that can fail (Some error type, Either?) and computations that might or might return a value (maybe) and of course computations that might return n values (List)
02:23:32 <gfixler> [a] and Maybe a
02:23:54 <gfixler> masse: that was one of his arguments, especially with parsers
02:23:58 <gfixler> they can return multiple results
02:24:23 <masse> Then a list is probably the best
02:26:20 <gfixler> it makes me wonder if Maybe is just a subtype of lists
02:26:33 <gfixler> i.e. that lists can model everything a Maybe can model, and then some
02:27:45 <vanila> Nothing -> [] ; Just x -> [x
02:27:46 <vanila> ]
02:28:36 <MasseR> If you're interested check xml-conduits cursor interface. It uses standard monadic operators in list monad to provide an xpath-like syntax
02:28:47 <MasseR> A query can return n results (a list)
02:28:57 <MasseR> Which can then be further examined with monads
02:29:03 <MasseR> s/examined/queried/
02:30:44 <gfixler> MasseR: nice
02:36:04 <HewloThere> Hi guys! Would you mind filling out a very quick multiple choice survey about development and programming? http://goo.gl/forms/R7NtyuVkBD Thanks to anyone who does!
02:36:17 <MP2E> lol
02:36:28 <kqr> how does the Ord instance for Data.Set work?
02:38:42 <int-e> compare s1 s2 = compare (toAscList s1) (toAscList s2)
02:44:04 <wz1000> Is there any nice way to take the cartesian product of an arbitary number of lists? eg 'cart [[1,2],[1,2]]' ==> [[1,1],[1,2],[2,1],[2,2]]
02:44:23 <vanila> > replicateM 2 [1,2]
02:44:25 <lambdabot>  [[1,1],[1,2],[2,1],[2,2]]
02:44:44 <wz1000> The lists may be different
02:44:52 <wz1000> @src replicateM
02:44:53 <lambdabot> replicateM n x = sequence (replicate n x)
02:45:21 <wz1000> > sequent [[1,2],[3,4]]
02:45:22 <lambdabot>  Not in scope: ‘sequent’
02:45:22 <lambdabot>  Perhaps you meant one of these:
02:45:22 <lambdabot>    ‘sequence’ (imported from Control.Monad.Writer),
02:45:22 <lambdabot>    ‘T.sequence’ (imported from Data.Traversable)
02:45:26 <wz1000> > sequence [[1,2],[3,4]]
02:45:27 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
02:45:53 <wz1000> Thanks, that was what I was looking for
02:51:14 <joneshf-laptop> how can i bend parsec to my will? it seems everytime i try to use parsec, it laughs at me for wanting to do simple things
02:51:43 <wz1000> Can sequence be expressed as a fold?
02:51:50 <RchrdB> wz1000: yes
02:51:59 <RchrdB> joneshf-laptop: IME it's easiest if you write our your grammar as an LL(1) grammar.
02:52:10 <wz1000> RchrdB: How?
02:52:18 <RchrdB> :t sequence
02:52:19 <lambdabot> Monad m => [m a] -> m [a]
02:52:56 <RchrdB> :t foldr (liftM2 (:)) (return [])
02:52:56 <lambdabot> Monad m => [m a1] -> m [a1]
02:53:10 <RchrdB> wz1000: iirc that definition is correct. ^
02:54:52 <RchrdB> joneshf-laptop: and the other thing to be carefully aware of is that you can't have straightforward left-recursion in Parsec (though there's a combinator for it). It's usually easiest to start with grammars that only recurse on the right, for example.
02:55:52 <RchrdB> joneshf-laptop: and use https://hackage.haskell.org/package/parsec-3.1.0/docs/Text-Parsec-Expr.html if you want to parse expressions with infix, left and right associative operators with different precedences, because writing out an LL(1) grammar for that is a little tedious.
02:56:27 <wz1000> RchrdB: Yes, I just came up with the same thing.
02:56:41 <wz1000> RchrdB: It's so easy using typeholes
02:57:02 <wz1000> > foldr _ _ [Just 1, Nothing] :: Maybe [Int]
02:57:04 <lambdabot>  Found hole ‘_’
02:57:04 <lambdabot>    with type: Data.Maybe.Maybe a0
02:57:04 <lambdabot>               -> Data.Maybe.Maybe [GHC.Types.Int]
02:57:04 <lambdabot>               -> Data.Maybe.Maybe [GHC.Types.Int]
02:57:04 <lambdabot>  Where: ‘a0’ is an ambiguous type variableFound hole ‘_’ with type: Data.Mayb...
02:57:18 <wz1000> > foldr _f _x [Just 1, Nothing] :: Maybe [Int]
02:57:19 <lambdabot>  Found hole ‘_f’
02:57:20 <lambdabot>    with type: Data.Maybe.Maybe a0
02:57:20 <lambdabot>               -> Data.Maybe.Maybe [GHC.Types.Int]
02:57:20 <lambdabot>               -> Data.Maybe.Maybe [GHC.Types.Int]
02:57:20 <lambdabot>  Where: ‘a0’ is an ambiguous type variableFound hole ‘_x’ with type: Data.May...
02:57:40 <RchrdB> That's rather nice.
03:02:10 <joneshf-laptop> RchrdB, and whenthat fails
03:02:27 <joneshf-laptop> RchrdB, the LL(1) bit, what do you do?
03:03:00 <RchrdB> joneshf-laptop: make a frowny face.
03:04:40 <RchrdB> joneshf-laptop: you can model unlimited lookahead LL(inf) in Parsec using the `try` combinator.
03:08:05 <RchrdB> joneshf-laptop: I'm not sure if the examples are up-to-date or not (it might be version 2 or 3 of Parsec, not sure which) but RWH has a chapter which is still accurate for its description of the basic ideas. http://book.realworldhaskell.org/read/using-parsec.html#parsec.lookahead
03:18:38 <schluri> @pl f1xs=map(\x->x+1)xs
03:18:38 <lambdabot> f1xs = map (1 +) xs
03:19:25 <schluri> @pl f3 xs=filter(\x->x>1)(map(\x->x+1)xs)
03:19:25 <lambdabot> f3 = filter (> 1) . map (1 +)
03:21:04 <iLike> isn't that the same as filter (> 0)?
03:21:30 <vanila> it's not quite the same
03:21:43 <vanila> since 1 isn't added
03:21:59 <iLike> semantically though?
03:22:38 <iLike> Nope, never mind.
03:44:28 * hackagebot ekg-bosun 1.0.0 - Send ekg metrics to a Bosun instance  http://hackage.haskell.org/package/ekg-bosun-1.0.0 (OliverCharles)
03:49:22 <schluri> @pl  f4 f g x = f(g x)
03:49:22 <lambdabot> f4 = (.)
03:49:35 <schluri> @pl f3 xs=filter(\x->x>1)(map(\x->x+1)xs)
03:49:35 <lambdabot> f3 = filter (> 1) . map (1 +)
03:49:38 <schluri> @pl f1xs=map(\x->x+1)xs
03:49:38 <lambdabot> f1xs = map (1 +) xs
03:51:18 <sasd> @pl f7 f g h x=g(h(f x))
03:51:18 <lambdabot> f7 = flip ((.) . (.)) . flip (.)
03:51:35 <Phillemann> Downloading a package via cabal failed because of a 500 HTTP error. Now cabal seems to not retry the download. What can I do?
03:53:15 <sasd> @pl f6 f g x y z =(f(g x y z))
03:53:15 <lambdabot> f6 = (.) . (.) . (.)
03:53:29 <sasd> @pl f6 f g x y z t=(f(g x y z t))
03:53:29 <lambdabot> f6 = (.) . (.) . (.) . (.)
03:53:36 <sasd> @pl f6 f g x y z t u=(f(g x y z t u))
03:53:36 <lambdabot> f6 = (.) . (.) . (.) . (.) . (.)
03:59:28 * hackagebot genifunctors 0.2.1.0 - Generate generalized fmap, foldMap and traverse  http://hackage.haskell.org/package/genifunctors-0.2.1.0 (DanRosen)
04:04:28 * hackagebot plailude 0.4.1 - plaimi's prelude  http://hackage.haskell.org/package/plailude-0.4.1 (alexander)
04:04:30 * hackagebot plailude 0.4.0 - plaimi's prelude  http://hackage.haskell.org/package/plailude-0.4.0 (alexander)
04:04:41 <bitonic> I vaguely remember having the possibility of having a lambda in a do block and then continue working with the lambda-argument in scope at the same indentation as before -- this is really useful if you have a lot of `bracket's one after the other
04:04:46 <bitonic> is it some syntactic extension?
04:06:43 <bitonic> there, `NondecreasingIndentation'.
04:07:15 <bitonic> I... think
04:07:51 <bitonic> yep.  so it used to be the standard in Haskell98
04:21:30 <Guest18835> @pl -- | Main entry point to the application. module Main where  data Fraction = Over Integer Integer instance Num Fraction where     (+) (Over a b) (Over c d)  = Over (a*d + c*b) (d*b)     (-) (Over a b) (Over c d)  = Over (a*d- c*b) (b*d)     (*) (Over a b) (Over c d)  = Over (a*c) (b*d)     negate (Over a b)   = Over (-a)  b     fromInteger i = Over i 1     abs (Over a b) = Over (abs a )(abs b)     signum (Over a b) = Over (
04:21:30 <lambdabot> (line 1, column 1):
04:21:31 <lambdabot> unexpected "-"
04:21:31 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
04:32:29 <BoR0> why does haskell have the keywords if, then, and else? isn't it kind of redundant once we have pattern matching?
04:33:03 <tutor1> @pl f7 = flip ((.).(.)) . flip (.)
04:33:03 <lambdabot> f7 = flip ((.) . (.)) . flip (.)
04:33:23 <tutor1> @unpl  f7 = flip ((.) . (.)) . flip (.)
04:33:23 <lambdabot> f7 r c f i = c (f (r i));
04:33:24 <Haskellfant> BoR0: you can't really pattern match on all number greater than 3
04:33:30 <Haskellfant> guards can replace ifs
04:33:41 <Haskellfant> but sometimes it's just more convenient to use it inline as an expression
04:34:10 <tutor1> @pl f7 = ((.).(.)) . flip (.)
04:34:11 <lambdabot> f7 = (.) . (.) . flip (.)
04:34:17 <tutor1> @unpl f7 = ((.).(.)) . flip (.)
04:34:17 <lambdabot> f7 o b c f l = b c f (o l);
04:34:21 <tutor1> mondays...
04:34:21 <BoR0> what I meant is: if' True a _ = a ; if' False _ b = b
04:35:11 <kqr> int-e, ah, thank you. is that what one expects from comparing sets? I find it a slightly odd notion to begin with
04:37:01 <BoR0> > let { if' False _ b = b; if' True a _ = a } in (if' (3 > 0) "greater" "less", if' (3 < 0) "less" "greater")
04:37:03 <lambdabot>  ("greater","greater")
04:38:02 <BoR0> Haskellfant, there we go :)
04:39:38 <Haskellfant> BoR0: right, we could do this
04:39:44 <Haskellfant> I don't think we need if
04:39:59 <BoR0> Haskellfant, so in that case we have 3 redundant keywords: if, then, else
04:40:02 <Haskellfant> maybe it was added because it's easier to see what's going on because you separate with then and else?
04:41:22 <chpatrick> heya
04:42:24 <chpatrick> is there some nice typeclass that has something like mzero :: m a but with no monad requirement?
04:43:13 <ij> monoid and mempty?
04:44:57 <chpatrick> unfortunately that's mempty :: m
04:45:39 <chpatrick> currently I can make a Const m a for any given a
04:45:44 <chpatrick> and I'm looking to generalize it
04:46:41 <chpatrick> I can't write (Applicative f, Monoid f whatever)
04:46:51 <chpatrick> sorry Monoid (f whatever)
04:49:30 * hackagebot genifunctors 0.2.2.0 - Generate generalized fmap, foldMap and traverse  http://hackage.haskell.org/package/genifunctors-0.2.2.0 (DanRosen)
04:49:44 <kaiko> I have node addon written in haskell. Works well but I have compiling issue. When I compile, I get: /usr/bin/ld: .cabal-sandbox/lib/x86_64-linux-ghc-7.8.3/yaml-0.8.10/libHSyaml-0.8.10.a(Yaml.o): relocation R_X86_64_32S against `stg_upd_frame_info' can not be used when making a shared object; recompile with -fPIC
04:50:45 <chpatrick> Alternative almost fits the bill but I'm not sure
04:51:46 <kaiko> To build libraries I used: cabal install --dependencies-only --enable-shared -f-fPIC
04:54:21 <ClaudiusMaximus> kaiko: that -f-fPIC is a cabal flag, it isn't automatically passed to the compiler
04:54:45 <kaiko> Can't find how to pass to compiler
04:54:56 <ClaudiusMaximus> kaiko: maybe you can add ghc-options: to your ~/.cabal/config
04:56:46 <cchalmers> chpatrick: maybe Data.Functor.Plus from semigroupoids?
04:56:47 <kaiko> Warning: cabal.config: Unrecognized field ghc-options on
04:57:08 <kaiko> cabal-install version 1.20.0.3
04:57:32 <dcoutts> it lives in a special program options section, see the config file
04:57:36 <chpatrick> ah awesome, thanks
04:58:15 <dcoutts> kaiko: -f-fPIC probably does not do what you think it does
04:58:31 <chpatrick> hang on, isn't that just Alternative?
04:58:39 <dcoutts> kaiko: --enable-shared should be enough to build shared libs
04:58:41 <chpatrick> since it has an Alt superclas
04:59:09 <kaiko> Well, I tried that also
04:59:10 <dcoutts> kaiko: and --enable-executable-dynamic for progs
05:00:14 <dcoutts> kaiko: your yaml problem is that you didn't build it with --enable-shared, so there's no .so lib version, just the static .a
05:01:15 <cchalmers> chpatrick: kinda, but only needs Functor, not Applicative
05:04:31 * hackagebot np-linear 0.3 - Linear algebra for the numeric-prelude framework  http://hackage.haskell.org/package/np-linear-0.3 (AriePeterson)
05:04:57 <chpatrick> hmm, I have an applicative constraint anyway
05:05:15 <chpatrick> it just feels weird to use Alternative when I'm not really doing this-or-this
05:09:31 * hackagebot np-linear 0.3.0.1 - Linear algebra for the numeric-prelude framework  http://hackage.haskell.org/package/np-linear-0.3.0.1 (AriePeterson)
05:15:00 <int-e> kqr: Maybe. Mathematically, the natural order on sets is the subset relation, but it's not total in general. Ord requires a total order, so something lexicographic is to be expected. From a programmer's perspective, since we want sets with equal elements to be equal, even if they are represented differently, converting to a list first is also quite natural.
05:19:31 * hackagebot np-linear 0.3.0.2 - Linear algebra for the numeric-prelude framework  http://hackage.haskell.org/package/np-linear-0.3.0.2 (AriePeterson)
05:19:33 * hackagebot engine-io 1.2.2 - A Haskell implementation of Engine.IO  http://hackage.haskell.org/package/engine-io-1.2.2 (OliverCharles)
05:23:13 <kaiko> Hmm, now I have: /usr/bin/ld: /usr/lib/ghc-7.8.3/binary-0.7.1.0/libHSbinary-0.7.1.0.a(Get__14.o): relocation R_X86_64_32S against `.text' can not be used when making a shared object; recompile with -fPIC
05:24:24 <kaiko> Haa, ok. Understood
05:24:38 <kaiko> (this wasn't in sandbox)
05:36:46 <steffen> is there a neat way to change a list of complex elements by only modifiying one element of it?
05:38:40 <steffen> the ugly way is: search the element that should be changed, get the position of it, remove it from the list, add a changed version of that element and add it at the right position back in
05:38:47 <steffen> there has to be a better way?!
05:39:13 <supki_> yeah, with lens
05:39:18 <supki_> > [1..10] & ix 3 *~ 2
05:39:20 <lambdabot>  [1,2,3,8,5,6,7,8,9,10]
05:39:45 <byorgey> steffen: no, there isn't, unless you want to use a complex (but fantastic) library like supki_ suggests. That is a fairly unnatural operation to do on lists.
05:39:59 <byorgey> If you find yourself wanting to do that operation on lists frequently, you are probably using the wrong data structure.
05:40:31 <byorgey> you might consider Data.Map or Data.Sequence instead.
05:40:52 <byorgey> e.g. Data.Sequence has a function 'update :: Int -> a -> Seq a -> Seq a'  which does exactly this.
05:41:11 <steffen> okay, thank you byorgey, Ill do it the guly way... with foldl' its doable
05:41:21 <byorgey> =P
06:04:50 * hackagebot engine-io 1.2.2 - A Haskell implementation of Engine.IO  http://hackage.haskell.org/package/engine-io-1.2.2 (OliverCharles)
06:04:50 * hackagebot rest-types 1.11.1.1 - Silk Rest Framework Types  http://hackage.haskell.org/package/rest-types-1.11.1.1 (AdamBergmark)
06:15:01 <kaiko> wait, I have error message: /usr/bin/ld: /usr/lib/ghc-7.8.3/process-1.2.0.0/libHSprocess-1.2.0.0.a(Process__37.o): relocation R_X86_64_32S against `stg_bh_upd_frame_info' can not be used when making a shared object; recompile with -fPIC /usr/lib/ghc-7.8.3/process-1.2.0.0/libHSprocess-1.2.0.0.a: error adding symbols: Bad value
06:15:15 <kaiko> but there is file /usr/lib/ghc-7.8.3/process-1.2.0.0/libHSprocess-1.2.0.0-ghc7.8.3.so what could be used...
06:24:45 * hackagebot haxr 3000.10.3.1 - XML-RPC client and server library.  http://hackage.haskell.org/package/haxr-3000.10.3.1 (BrentYorgey)
06:29:45 * hackagebot MonadRandom 0.3.0.1 - Random-number generation monad.  http://hackage.haskell.org/package/MonadRandom-0.3.0.1 (BrentYorgey)
06:31:16 <fds4345>  take (length l - 1) l
06:31:24 <ChristianS> is there a predefine function somewhere that's equivalent to nub but more efficient?
06:31:24 <fds4345> any more spiffy way to drop the last element of a list?
06:31:36 <ChristianS> fds4345: init
06:32:00 <ChristianS> fds4345: from Data.List
06:32:10 <fds4345> ChristianS: Excellent
06:32:27 <kadoban> ChristianS: map head . group . sort  I believe. Not exactly equivalent though.
06:32:28 <bergmark> fds4345: note that init is partial, so i wouldn't recommend using it
06:32:55 <bergmark> fds4345: but the safe package has initMay
06:33:27 <fds4345> what about applying a function to the first element of a list?
06:33:38 <supki_> @where sneaky
06:33:39 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
06:33:55 <ChristianS> kadoban: it must be equivalent, i.e. it must preserve the original order. i can implement that with the help of a Set, just thought that maybe it exists already...
06:34:29 <kadoban> ChristianS: Not as far as I know.
06:34:38 <ChristianS> fds4345: head gives you the first element (partial as well)
06:34:46 * hackagebot elevator 0.1.1.1 - Immediately lifts to a desired level  http://hackage.haskell.org/package/elevator-0.1.1.1 (FumiakiKinoshita)
06:34:56 <ChristianS> kadoban: i see, thanks
06:37:12 <ChristianS> kadoban: third answer from http://stackoverflow.com/questions/16108714/haskell-removing-duplicates-from-a-list is what i need, i think
06:38:12 <nh2_work> ChristianS: yes, Haskell can do that! There's a whole repository just benchmarking and dealing with nub: https://github.com/nh2/haskell-ordnub
06:39:17 <kadoban> ChristianS: Yeah, that loos like what you were saying. nh2_work's link has a much more idiomatic looking one though.
06:39:46 * hackagebot BlogLiterately 0.7.1.7 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.7.1.7 (BrentYorgey)
06:39:56 <ChristianS> nh2_work, kadoban yeah, nice, i'll copy ordNub
06:49:23 <tdammers> anyone experienced with hsmagick here?
06:49:35 <tdammers> I'm getting coredumps in combination with scotty
06:49:47 <tdammers> I'm trying to use hsmagick to create thumbnails
06:49:53 <nh2_work> tdammers: tried gdb?
06:50:09 <tdammers> ugh, I'd rather avoid that, but I'll give it a shot
06:57:22 <kqr> int-e, ah, very nice rationale. thanks
06:57:53 <nh2_work> tdammers: if it breaks in c code, then gdb will very quickly tell you
06:58:36 <nh2_work> (as long as you have the corresponding -dev/-dbg packages or equivalents installed)
07:01:35 <tdammers> yeah, gotta figure out how to rig that up with cabal I guess
07:01:47 <tdammers> I'm only making like 3 calls into magick anyway
07:01:54 <SvenskFisk> Hey guys, is there any way to avoid using the lambda here? http://lpaste.net/114914 It doesn't read very well and I'd prefer to avoid having to give a name to the result of the function. Is there a cleaner way to write this without lambda?
07:02:00 <tdammers> readImage, thumbnailImage, writeImage
07:02:32 <tdammers> hmm, or maybe I'm not supposed to call initializeMagick more than once?
07:03:54 <alpounet> tdammers: that wouldn't be surprising. imagemagick is a C library right?
07:04:27 <kqr> int-e, may I ask how the subset relation is not total? I've read the three requirements on wikipedia and I can't quite come up with a counter-example
07:04:27 <tdammers> yes, it is
07:04:53 <tdammers> just wondering how it'd fit into Haskell's thread model and the way Scotty and Warp use it
07:05:06 <lpsmith> hmm,  I wonder if forkSTM :: STM () -> STM ThreadId  would be sensible and useful
07:05:22 <flux> @pl f bools = return $ True `elem` bools
07:05:22 <lambdabot> f = return . (True `elem`)
07:06:25 <lpsmith> perhaps more like  forkSTM :: STM () -> STM (STMThreadId)
07:06:30 <alpounet> tdammers: hrm, not very well I guess? :p
07:06:49 <nh2_work> SvenskFisk: see flux's "pl" output
07:07:08 <tdammers> alpounet: yeah, that's what I'm afraid of
07:07:34 <SvenskFisk> flux: That makes sense, should have thought of that haha, thanks! What's the @pl thing you did?
07:07:50 <flux> svenskfisk, it's a 'pointless' or 'point-free' feature old lambdabot
07:07:53 <tdammers> I'm seriously contemplating just ditching the library altogether and integrating with imagemagick at the process level instead
07:08:21 <tdammers> i.e., call the imagemagick program externally and then just serving the thumbnail from the filesystem
07:08:21 <flux> svenskfisk, overusing it may result in violent death implemented by someone reading the code ;-)
07:08:32 <nh2_work> tdammers: you can only figure out if its forbidden by looking at magick's docs and they'll hopefully say something about it - if it says only once, you could easily get around it with an atomicModifyIORef to init it only once
07:08:35 <SvenskFisk> Very cool, any way to use that without going on here and spamming the chat?
07:08:58 <SvenskFisk> flux: Haha yeah I'll try not to abuse it
07:09:05 <tdammers> nh2_work: oh, I could just init it at program startup I guess, but I don't know what would happen then if I switch from Warp to, say, FastCGI
07:10:18 <nh2_work> tdammers: even in fastcgi, wouldn't you be able to do it at startup time?
07:10:47 <tdammers> nh2_work: yes, I guess... after all, a process is a process, right
07:10:54 <tdammers> let me try that
07:11:19 <kqr> SvenskFisk, you can send it in query to lambdabot
07:11:32 <kqr> SvenskFisk, so like /msg lambdabot @pl \x -> x + x
07:11:49 <alpounet> tdammers: the trick here is to avoid having 2 threads using it at the same time right? so, an MVar?
07:11:52 <wei2912> @pl \ x -> x + x
07:11:52 <lambdabot> join (+)
07:12:05 <saep> SvenskFisk: or <$> [shouldQuizCard card | card <- cards]
07:12:18 <chpatrick> ha
07:12:28 <fryguybob> lpsmith: What sort of semantics would you want with forkSTM?
07:12:35 <cin> how did haskellers survive without RankNTypes all those years? =)
07:12:58 <kqr> cin, rake types what? ;)
07:13:07 <tdammers> alpounet: could be
07:13:26 <nh2_work> alpounet, tdammers: whether the other magick functions are threadsafe is probably an orthogonal question to initialisation, isn't it?
07:13:52 <alpounet> nh2_work: yeah, but libraries like that usually don't like multithreaded environments do they?
07:14:10 <saep> SvenskFisk: Oh, i forgot the sequence before the list comprehension.
07:14:31 <alpounet> so maybe it'd be better to have one thread focusing on doing the thumbnail generation, and having all the request handlers call out to it? would probably be a bit cumbersome to use
07:14:35 <chpatrick> > ((++)<*>show)"((++)<*>show)"
07:14:37 <lambdabot>  "((++)<*>show)\"((++)<*>show)\""
07:14:55 <tdammers> I'm more and more tempted to just go with calling the imagemagick binaries through the OS
07:15:00 <nh2_work> alpounet: it depends - there are some that do support it once you have init'd their context, but those still often fail to allow threadsafe error reporting (e.g. when they are using errno)
07:15:07 <tdammers> I'm gonna cache stuff anyway, so performance is not a huge show stopper
07:16:04 <nh2_work> if you don't know how threadsafe they are, yes it is safest to make it single threaded and send work to it via a chan, for example
07:16:14 <alpounet> nh2_work: right. well tbh I don't really know imagemagick and its multithreaded-friendliness
07:16:23 <nh2_work> me neither :)
07:16:52 <alpounet> calling the binaries directly may indeed actually be simpler =)
07:17:46 <nh2_work> tdammers: also keep in mind that there are *some* libraries out there that only want to be called from the very same OS thread; if you just forkIO then the runtime can pick an OS thread to run the Haskell thread, so the OS thread might vary
07:18:05 <tdammers> nh2_work: yeah, that's another thing I'm worried about
07:18:46 <nh2_work> tdammers: if you don't know that either, you can just use `forkOS` to be safe
07:19:01 <cin> use forkProcess, what's the worst that can happen?
07:19:09 * cin ducks
07:19:24 <tdammers> thing is, I don't know what the server framework does - it might forkIO, or it might forkWhatever, or who knows what it does
07:19:31 <tdammers> unsafeLaunchMissiles
07:19:32 <gigabytes> hi
07:19:41 <tdammers> I think with WAI you can't be sure, really
07:19:52 <bernalex> tdammers: not sure there is a "safeLaunchMissiles" so it's a bit of a misnomer really
07:20:17 <nh2_work> tdammers: then you can just launch your "thumbnail thread" with forkOS at server startup, and have the web server communicate with it via a chan - then it doesn't matter what the web server does
07:21:24 <cin> unsafeLaunchBarbieSkyDancers
07:21:33 <benzrf> uwot
07:21:35 <nh2_work> regarding cin's suggestion about `forkProcess`, that gives even more isolation but then you have to do Inter Process Communication, for which Haskell doesn't provide immediate tools, you'd have to handle serialisation etc.
07:21:37 <tdammers> yeah, but then I might just shell out and lock at the filesystem level
07:21:50 <cin> http://stream1.gifsoup.com/view7/3891947/sky-dancers-o.gif
07:22:12 <tdammers> or not even lock at all, just write to a temp file and use atomic moves to update the cache
07:22:13 <cin> (these toys were recalled after enough children went to the hospital with damaged eyes and such)
07:22:34 <tdammers> cin: would somebody please think of the children!
07:23:48 <cin> for what it's worth i was joking about forkProcess. it's known to be risky business
07:24:24 <nh2_work> tdammers: you can do that as well - it depends on whether you want one external process per request being forked, and whether and how you have to communicate information - if you want to communicate information at the Haskell level, then forkOS gets you around having to deal with serialisation
07:26:19 <tdammers> don't think I need to communicate much
07:26:41 <tdammers> basically what I do is first I scan a directory for images, hash them, extract EXIF data and so on, and add them to a database
07:26:57 <tdammers> and then thumbnails are generated per hash
07:27:18 <tdammers> which means once a file has been thumbnailed, I never have to touch the thumbnail again
07:27:22 <tdammers> I can cache it indefinitely
07:28:54 <nh2_work> tdammers: in this case, might it be easier / more robust to just separate that on the process level, making the thumbnailer and the web server independent programs? The thumbnailer could talk directly to the database; it could be invoked from the server via Popen
07:31:34 <lpsmith> fryguybob, I honestly don't know, it's a very whimsical thought
07:32:19 <fryguybob> lpsmith: Sometimes those are the best one :D
07:32:53 <xplat> bernalex: presumably 'safeLaunchMissiles' would launch nanotech missiles that would disassemble their target but save the information necessary to reassemble it
07:33:38 <lpsmith> hahaha, now that sounds like a plausible idea for (at least part of) a sci-fi story line
07:35:37 <lpsmith> xplat, certainly seems like the basis for a sci-fi short story at least
07:36:19 <tdammers> nh2_work: yeah, probably
07:36:39 <tdammers> nh2_work: I was thinking to invoke the suitable imagemagick libraries as needed
07:37:00 <tdammers> nh2_work: no need to generate thumbs for images that you never look at
07:37:25 <xplat> tdammers: increases your latency the first time you look at an image though
07:37:53 <tdammers> xplat: yes, I am aware of that
07:38:02 <tdammers> xplat: but then, there's not really a way around that, is there?
07:38:18 <tdammers> I mean, other than fail hard or serve a fake thumbnail while the thumbnailer is busy
07:39:02 <xplat> hm, the fake thumbnail idea actually has merit
07:39:38 <robstewartuk> hi folks, I'm hoping someone can provide guidence here http://goo.gl/9w1b4r . We're not sure how best to package unit tests for rdf4h. We've got 6Mb of unit test data that we'd rather not have downloaded when someone does `cabal install rdf4h`. I've suggested two approaches http://goo.gl/AtMH7u .
07:39:54 <tdammers> xplat: it's called shedding ;)
07:40:33 <tdammers> and I'd do that if this were a high-traffic site
07:40:37 <robstewartuk> Either we separate it out into rdf4h and rdf4h-tests , or we add code in our Test main function that downloads the 6Mb of data if it does not exist locally, before runnning the HUnit tests.
07:40:41 <robstewartuk> Ideas?
07:41:01 <tdammers> pretty much just "is the thumbnail there? yes -> serve it, no -> serve placeholder" at the web server level
07:41:11 <tdammers> and then the thumbnailer would happily churn along in the background
07:41:17 <tdammers> possibly even on a separate machine
07:41:42 <tdammers> but this isn't high-load, so I'll go with a solution that always serves the correct data, at the expense of latency, I guess
07:42:40 <lpsmith> robstewartuk, I can definitely see a case for not putting it on hackage,  especially if the tests are going to change much
07:43:10 <tdammers> hmm, interesting... now that I've moved the initializeMagick call into the startup section, it *always* crashes
07:43:12 <lpsmith> I download every package version on hackage I don't have every couple of months :D
07:43:19 <robstewartuk> lpsmith: Can you suggest an alernative?
07:43:21 <tdammers> so I guess it wants to be in the same thread
07:43:36 <tdammers> alright, I give up, I'll go with the shellout
07:43:38 <lpsmith> robstewartuk, amazon s3 maybe?
07:44:01 <robstewartuk> Ah, there already exists a web server that hosts the 6Mb unit test data.
07:44:34 <robstewartuk> There is though this idea that good tests should rely on no foreign resource (e.g. an internet connection).
07:44:48 * hackagebot semi-iso 0.4.1.0 - Weakened partial isomorphisms that work with lenses.  http://hackage.haskell.org/package/semi-iso-0.4.1.0 (pawel834)
07:44:50 * hackagebot syntax 0.2.1.0 - Syntax descriptions for unified parsing and pretty-printing.  http://hackage.haskell.org/package/syntax-0.2.1.0 (pawel834)
07:58:23 <kaiko> posted my problem to stackoverflow http://stackoverflow.com/questions/27108855/ghc-shared-binary-compiling-gives-fpic-error-for-standard-libraries
08:01:20 <wei2912> quick poll
08:01:25 <wei2912> x - 1 vs succ x
08:01:31 <wei2912> err, prev*
08:01:35 <wei2912> wait
08:01:37 <wei2912> i forgot what it's called
08:01:39 <alpounet> pred
08:01:39 <EvanR> > pred x
08:01:41 <lambdabot>  pred x
08:01:42 <wei2912> ah, yes
08:01:51 <EvanR> > pred 0
08:01:53 <lambdabot>  -1
08:02:11 <wei2912> x - 1 vs pred x*
08:02:48 <lucs> ... vs terminator
08:02:51 <EvanR> pred is easier to write by itself than (subtract 1)
08:03:50 <tdammers> Hah! subprocess approach works like a charm!
08:04:35 <HeladoDeBrownie> wei2912, depends, are you writing an abstraction over Num or Enum? If not, use what reads best to you. Also, the way to remember what it's called is that succ stands for successor, and the opposite of that is *pred*ecessor.
08:05:06 <wei2912> HeladoDeBrownie: it's more of a quick poll
08:05:19 <wei2912> and thanks for the tip
08:05:25 <EvanR> pred and subtract 1 both probably require some reasoning to make sure its used in the right place
08:05:30 <EvanR> like head
08:09:04 <gigabytes> guys
08:09:14 <gigabytes> any particular reason why Data.MultiMap is not instance of anything?
08:09:17 <gigabytes> Functor, for example
08:09:34 <gigabytes> broken laws?
08:10:03 <indiagreen> same reason Data.Map isn't an instance of Functor
08:10:26 <indiagreen> no, wait
08:10:29 <indiagreen> ouch
08:10:31 <indiagreen> Data.Set
08:10:32 <indiagreen> hm
08:10:37 <EvanR> Data.Map is a Functor
08:10:44 <indiagreen> right, right, sorry
08:10:45 <EvanR> and the map function for multimap seems to have the right type
08:11:40 <EvanR> the Data instance may be the excuse
08:11:45 <chpatrick> gigabytes: https://hackage.haskell.org/package/mono-traversable-0.6.3/docs/Data-MonoTraversable.html#t:MonoFunctor
08:11:47 <chpatrick> here you go
08:12:24 <gigabytes> chpatrick: MultiMap is not monomorphic
08:12:24 <chpatrick> ah actually Set isn't a MonoFunctor either
08:12:25 <chpatrick> that's weird
08:12:49 <gigabytes> Set is not a functor for a fundamental reason
08:12:56 <gigabytes> although I've still have to understand this reason :P
08:12:59 <RchrdB> chpatrick: because of the (Ord a) constraint on its content, I think?
08:13:03 <gigabytes> the same applies to do MultiMap?
08:13:05 <chpatrick> yes
08:13:12 <EvanR> the ord constraint isnt on the content, its on the lookup operation
08:13:15 <EvanR> and insert
08:13:17 <chpatrick> fmap :: (a -> b) -> f a -> f b
08:13:20 <chpatrick> has to work for all a
08:13:36 <gigabytes> got it
08:13:37 <chpatrick> in Set everything needs to have an Ord instance
08:13:51 <gigabytes> but why is Map a functor then?
08:13:58 <RchrdB> EvanR: right, but the only operations exposed all have the Ord constraint, so there's no way to use them without imposing an Ord constraint.
08:13:59 <chpatrick> because there's no constraint on the values
08:14:03 <chpatrick> just the keys
08:14:17 <chpatrick> you don't have to be monomorphic to be monotraversable though
08:14:38 <EvanR> RchrdB: i think the relevant point is that the map operation for set cant satisfy the Functor type
08:14:43 <chpatrick> it just means that the element is a type family instead of a parameter to f
08:14:49 <chpatrick> which means you can give it a constraint
08:14:55 <gigabytes> but the Ord constraint in Map is on the keys not no values
08:14:56 <EvanR> for example the empty operation (make an empty set) does not care about Ord
08:15:01 <gigabytes> so (Map k) is a Functor
08:15:09 <gigabytes> why not (MultiMap k) ?
08:15:30 <chpatrick> the author hasn't made it one?
08:15:37 <chpatrick> can't see why it shouldn't be
08:15:39 <HeladoDeBrownie> MultiMap is basically a map one way and another back, so Ord on both
08:15:56 <EvanR> MultiMap k v is Map k [v]
08:16:06 <HeladoDeBrownie> Ohh, I was thinking BiMap, sorry
08:16:25 <chpatrick> I guess it's an oversight?
08:16:30 <HeladoDeBrownie> Seems like
08:16:58 <chpatrick> instance U.Unbox a => MonoFunctor (U.Vector a) where omap = U.map
08:17:22 <EvanR> multimap package doesnt seem to have much love
08:17:30 <chpatrick> unboxed Vector can't be a functor because it only works for unboxed values
08:17:47 <chpatrick> but it can be a monofunctor
08:19:54 <cdk> is there any way to carry a value level proof of a constraint like (a ~ b) without using GADTs? ie. If I had a GADT `data T a where A :: T ()`, then pattern matching on A brings the constraint (a ~ ()) into scope. Can this be done without GADTs?
08:21:57 <Jello_Raptor> hmm, why do lenses need the functor type? i.e. why "(a -> f a) -> b -> f b" rather than "(a -> a) -> b -> b" ?
08:22:05 <hiptobecubic> Does anyone have any idea why this *one* website seems to not work with http-client-tls? httpbin.org works and the site in question works via curl (correctly responding that it was an invalid request): http://lpaste.net/114895#a114900
08:22:18 * Jello_Raptor is unclear on what addition abilities that gets you 
08:22:20 <chpatrick> Jello_Raptor: so you can use them for getting and setting
08:22:52 <chpatrick> Jello_Raptor: f = Const you can extract a value, if f = Identity you can set a value
08:23:06 <cdk> Jello_Raptor: it's not just a functor f. It's `forall Functor f => f`, this lets the lens library choose which functor it uses (Identity for set, Const for get) and a valid lens must work for both
08:23:19 <Jello_Raptor> chpatrick: ahh I see, cool.
08:23:25 <cdk> `forall f. Functor f => f` rather
08:23:32 <Jello_Raptor> that makes sense
08:24:15 <Jello_Raptor> and what about the complex lenses where "(a -> f s) -> b -> f t" ? that seems to allow you to change the type of a structure with a functor, no?
08:25:04 <Jello_Raptor> but that would only really work if record types are simple syntax sugar over tuples.
08:25:14 <cdk> Jello_Raptor: not sure what you mean. You can always change the contents of a functor with fmap
08:28:58 <HeladoDeBrownie> Jello_Raptor, that allows for polymorphic update, e.g., changing a "field" in some structure to a different type, and even with a different type for the overall structure.
08:29:50 * hackagebot ekg-bosun 1.0.1 - Send ekg metrics to a Bosun instance  http://hackage.haskell.org/package/ekg-bosun-1.0.1 (OliverCharles)
08:30:22 <Jello_Raptor> HeladoDeBrownie: I suppose then the question is if I use a Lens to update " data Foo = Foo { a :: int, b :: int } " to turn 'a' into a float, what would the type of final object be? or is that illegal?
08:30:59 <HeladoDeBrownie> Jello_Raptor, you would need to have a type variable of some sort involved. I'm guessing by "int" you meant "Int", since that would be a confusing variable name.
08:31:05 <Jello_Raptor> is that just a bunch of syntax sugar on top of "newtype Foo = Foo (int,int)" ?
08:31:08 <monochrom> that is illegal. but consider "data NotFoo t = NotFoo { a :: t, b :: Int }"
08:31:10 <Jello_Raptor> ahh yes,
08:31:24 <HeladoDeBrownie> Jello_Raptor, say you have data T a = T a and the value T 'a', for a simple example. With the "simple" lens you cannot take the Char onto Integer, but with the non-simple one you can.
08:31:31 <Jello_Raptor> ahh okay
08:32:37 <HeladoDeBrownie> Jello_Raptor, the lens's input would be Char -> f Integer and its output would be T Char -> f (T Integer)
08:34:28 <Jello_Raptor> HeladoDeBrownie: ahh okay
08:35:17 <Jello_Raptor> :t (->)
08:35:18 <lambdabot> parse error on input ‘->’
08:35:35 <HeladoDeBrownie> :k (->)
08:35:36 <lambdabot> * -> * -> *
08:35:48 <HeladoDeBrownie> (Values have types, types have kinds)
08:35:58 <Jello_Raptor> ahh
08:36:02 * Jello_Raptor goes to read about kinds
08:36:42 <Jello_Raptor> oh okay
08:36:51 <lengzai> aren't kinds just like 'levels' of parameterization?
08:37:23 <monochrom> yes until you meet ((* -> *) -> *) -> *
08:37:38 <HeladoDeBrownie> lengzai, kinds are analogous to types. Some programming languages don't even separate the two, kinds are just types of types.
08:38:21 <lengzai> so... how would something like ((* -> *) -> *) -> * be useful in real life?
08:38:25 <HeladoDeBrownie> * is the kind containing all concrete types, i.e., those which can (and in Haskell do) have values.
08:39:15 <EvanR> kinds help you get instances straight, Functor for example can only be implemented by a type with kind * -> *
08:39:27 <HeladoDeBrownie> * -> * means "give me a concrete type and I'll give you a concrete type"
08:40:00 <HeladoDeBrownie> Maybe :: * -> *. So you give it Integer and get Maybe Integer, a concrete type containing, e.g., Nothing, Just 10, Just 0, etc.
08:40:10 <monochrom> I don't know yet. but it's inspired by "callCC :: MonadCont m => ((a -> m b) -> m a) -> m a", which is useful in real life. at least my real life, if not a manager's.
08:40:32 <lengzai> ((* -> *) -> *) "Give me a thing that takes concrete types and spits out concrete types, and i'll give you a concrete type"
08:40:45 <HeladoDeBrownie> You can't say Maybe Maybe though. Maybe :: * -> *, so it cannot accept * -> * as its parameter, only *.
08:40:49 <chpatrick> yep
08:41:41 <HeladoDeBrownie> Monad transformers :: (* -> *) -> * -> *. This makes sense, as they take something of the same kind a Monad can be and give you something of the same kind.
08:42:04 <monochrom> at any rate, ((* -> *) -> *) -> * is a legal kind, useful or not. therefore it is hard to fit "level of parameterization" into kinds.
08:42:27 <lengzai> ok
08:42:31 <lengzai> fair enough
08:43:46 <monochrom> and it is impractical to outlaw ((* -> *) -> *) -> * just because no one uses it. if you want to allow the like of * -> (* -> *) -> *, it is simpler to simply allow "<kind here> -> <kind here>" to be a kind unconditionally.
08:43:59 <Peaker> I'm pretty sure ((* -> *) -> *) -> *  is useful in practice, too
08:44:22 <lengzai> sure
08:44:46 <lengzai> I saw the example where you can sort a list just in types
08:45:24 <lengzai> so then the type of some function could in theory be a sorted list of types... or something mindboggling like that
08:45:41 <albeit_> \JOIN #ubuntu
08:46:09 <Rarrikins> albeit_: But I don't want to join it.
08:47:24 <EvanR> lengzai: can you give a link to this
08:48:03 * lengzai scours the interwebz
08:48:23 <Peaker> Hoogle doesn't index kinds, does it? only types? :)
08:49:04 <HeladoDeBrownie> The means of defining your own kinds are rather restricted, so I don't imagine it would be necessary
08:49:59 <HeladoDeBrownie> Let's see, there's *, (->), # (GHC only?), Constraint (with ConstraintKinds), and I think some others that other extensions define
08:50:03 <lengzai> https://www.haskell.org/haskellwiki/Type_arithmetic#An_Advanced_Example_:_Type-Level_Quicksort
08:50:16 <chpatrick> you can make your own with DataKinds
08:50:26 <HeladoDeBrownie> chpatrick, that's what I was trying to think of, thanks
08:50:32 <lengzai> EvanR: https://www.haskell.org/haskellwiki/Type_arithmetic#An_Advanced_Example_:_Type-Level_Quicksort
08:52:15 <Jello_Raptor> What is that thing at the top of a file when can enable quasiquotation or template haskell called?
08:52:34 <monochrom> LANGUAGE pragma
08:54:43 <Jello_Raptor> monochrom: I need either the templateHaskell pragma, or the compiler flag to use template haskell with GHC right?
08:56:03 <monochrom> yes
08:56:32 <EvanR> lengzai: looks like it just translates normal quicksort from value level to typeclasses with functional dependencies. for more fun, look for a way to do the same thing but with a static guarantee that the result is actually sorted ;)
08:57:26 <HeladoDeBrownie> EvanR, hmm, so you would encode some sort of x ≥ y predicate in the type?
08:58:44 <EvanR> i dont know about predicate, but ive heard you can do dependent types (like a type representing x <= y) with typeclass abuse ;)
08:59:38 <EvanR> HeladoDeBrownie: heres a pdf where this is apparently done http://eb.host.cs.st-andrews.ac.uk/drafts/tfp08.pdf
08:59:51 * hackagebot yesod-recaptcha 1.4 - Dead simple support for reCAPTCHA on Yesod applications.  http://hackage.haskell.org/package/yesod-recaptcha-1.4 (FelipeLessa)
09:00:28 <EvanR> doesnt look like it uses fundeps
09:01:06 <HeladoDeBrownie> Neat.
09:01:33 <EvanR> wait yeah it does
09:01:54 <EvanR> the gadt might just be convenience over the style in lengzai's link
09:02:20 <EvanR> it also has a version using type families instead
09:02:52 <HeladoDeBrownie> Type families are basically type level functions less restricted than "type" declarations, right?
09:04:42 <EvanR> it appears to be a limited form of type level functions
09:04:51 * hackagebot clientsession 0.9.1.1 - Securely store session data in a client-side cookie.  http://hackage.haskell.org/package/clientsession-0.9.1.1 (FelipeLessa)
09:04:53 * hackagebot skein 1.0.9.1 - Skein, a family of cryptographic hash functions. Includes Skein-MAC as well.  http://hackage.haskell.org/package/skein-1.0.9.1 (FelipeLessa)
09:06:37 <Jello_Raptor> huh :/ adding "makeLenses ''DataStruct" breaks my Happy parser
09:06:53 <HeladoDeBrownie> Jello_Raptor, what are the field names in DataStruct?
09:07:06 <HeladoDeBrownie> Jello_Raptor, what error do you get?
09:07:48 <DogPolice> A/win 2
09:07:52 <DogPolice> whups, sorry.
09:08:55 <Jello_Raptor> HeladoDeBrownie: it happens when the fields are as normal 'rules','actAssign' etc, as well as when I add underscores. I was expecting a few type errors. but I get a bunch of itnernal Happy structures marked as "not in scope"
09:09:46 <HeladoDeBrownie> Jello_Raptor, using makeLenses or not makes the difference between those things being mentioned as out of scope and not?
09:09:46 <Jello_Raptor> yes when i look at Parser.hs those structures seem to be defined.
09:09:51 <Jello_Raptor> mhmm
09:09:51 * hackagebot esqueleto 2.1.2.1 - Type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-2.1.2.1 (FelipeLessa)
09:09:56 <HeladoDeBrownie> Jello_Raptor, might need to post code
09:12:05 <Jello_Raptor> HeladoDeBrownie: parser.y http://hastebin.com/wudajocoyo.hs ; Errors http://hastebin.com/fokisovufu.vbs ; parser.hs http://hastebin.com/dedulerupa.hs
09:12:42 <Jello_Raptor> ignore the hacky pseudo-lenses that I was using before I learnt that lenses exist :p
09:15:18 <HeladoDeBrownie> Sorry, I'm drawing a blank on how to troubleshoot this
09:15:43 <HeladoDeBrownie> I guess make sure you're importing the module containing those things, if there is one
09:17:15 <HeladoDeBrownie> Jello_Raptor, actually, do you notice a difference in those bindings being present or absent depending on whether you had the makeLenses in there?
09:17:20 <HeladoDeBrownie> from the file
09:17:24 <HeladoDeBrownie> the generated file
09:24:14 <Jello_Raptor> HeladoDeBrownie: I can search and find them, so no.
09:24:24 <Jello_Raptor> HeladoDeBrownie: at least the few that I bothered to test.
09:26:11 <Jello_Raptor> HeladoDeBrownie: the only obvious thing is that all the errors are towards the beginning of the file, and the definitions towards the end.
09:28:13 <Jello_Raptor> HeladoDeBrownie: and all of the definitions fall *after* the makeLenses directive shows up in Parser.hs :/
09:28:57 <HeladoDeBrownie> Jello_Raptor, try putting the makeLenses last. Order does matter with TH
09:29:15 <HeladoDeBrownie> In fact I can't believe that didn't occur to me before
09:29:33 <_2_> Hi everyone
09:29:38 <Jello_Raptor> I can't, at least not in parser.y :/ the block is added to the code before the static Happy template code.
09:29:51 <HeladoDeBrownie> Jello_Raptor, you can't place a block after the generated code?
09:30:22 <HeladoDeBrownie> Jello_Raptor, try what I just suggested with the output code, see if it's at least the answer.
09:30:27 <_2_> Hi dark tiger
09:32:07 <Jello_Raptor> HeladoDeBrownie: then it works
09:32:36 <Jello_Raptor> HeladoDeBrownie: but that's not a solution I can carry over without redoing a chunk of my build system.
09:32:43 <JordiGH> Hey, so if we have (t) :: Num a => a -> a -> a, why do we need to define (:+) for Complex?
09:32:50 <JordiGH> Isn't Complex also Num?
09:33:11 <JordiGH> (+), sorry, not (t)
09:33:27 <Jello_Raptor> JordiGH: Num might imply Ord  which Complex doesn't have? my first guess
09:33:35 <JordiGH> Ah.
09:33:50 <JordiGH> Well, why not just give Complex some arbitrary ordering?
09:34:03 <Hijiri> JordiGH: :+ is a constructo
09:34:05 <Hijiri> r
09:34:16 <Hijiri> at least I think it is, it starts with a colon
09:34:31 <JordiGH> It's not as if Haskell tries to ensure that Num is an ordered field, does it?
09:34:39 <Hijiri> it doesn't
09:34:52 * hackagebot purescript 0.6.1.2 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.6.1.2 (PhilFreeman)
09:35:02 <Hijiri> it does need equality and showability though
09:35:16 <JordiGH> Hijiri: Oh, you're right, I'm confused, :+ creates a complex from real and imaginary parts, duh.
09:35:17 <glguy__> JordiGH: (:+) is the constructor for the Complex type. It has two fields: the imaginary and real parts of the number
09:36:19 <JordiGH> Oh, great, Complex only works on float types...
09:37:12 <edwardk> JordiGH: :+ is the constructor that connects the real and imaginary parts
09:37:56 <JordiGH> Blegh, why does 1 :+ 2 even work if it's going to create a type that I can't add to itself with + ?
09:38:04 <edwardk> so when we define Num for Complex, we have instance RealFloat a => Num (Complex a) where ... -- and notably realFloat is used when you go to do sqrt for abs/signum
09:38:24 <edwardk> (1 :+ 3) --  is 1 + 3i
09:38:30 <HeladoDeBrownie> Jello_Raptor, you have at least two options as I see it: (1) Don't use that piece of TH. Write your lenses manually. (2) Find some way to insert code after that Happy block and put it there.
09:38:38 <JordiGH> edwardk: What's the point of that if I can't add it to itself?
09:38:42 <edwardk> you could write let i = 0 :+ 1     -- and write that as 1 + 2*i
09:38:55 <edwardk> > (1 :+ 3) + (1 :+ 3)
09:39:07 <Jello_Raptor> HeladoDeBrownie: 1 would be a good exercise, but how do I go about doing that?
09:39:15 * edwardk kicks lambdabot
09:39:22 <JordiGH> You killed it with type errors.
09:39:24 <HeladoDeBrownie> Jello_Raptor, not sure, edwardk will know though
09:39:45 <edwardk> >>> (1 :+ 3) + (1 :+ 3)   => 2.0 :+ 6.0
09:40:04 <hiptobecubic> but in that case those were never integers :)
09:40:12 <hiptobecubic> well... Integers
09:40:26 <JordiGH> > let x = 1:+3; x+x
09:40:28 <edwardk> Num (Complex a) defines (a :+ b) + (c :+ d) = (a + c) :+ (b :+ d)
09:40:53 <edwardk> you're getting hung up on the fact that :+ 'looks like +'
09:41:00 <edwardk> we have + on those things
09:41:28 <JordiGH> No, I'm getting hung up on the fact that I'm allowed to create Complex Integer.
09:41:52 <HeladoDeBrownie> Jello_Raptor, one way might be to use the "lens" binding from the lens package.
09:41:53 <servius> exit
09:41:56 <edwardk> gaussian integers sadly don't work so long as we have abs/signum inside the Num class
09:41:57 <servius> exit
09:42:01 <JordiGH> I guess with (1 :+ 3) + (1 :+ 3) the float type was deduced, but it won't be if you do let x = 1 :+ 3.
09:42:01 <vanila> lol
09:42:02 <yukko> http://lpaste.net/114926 can someone help me with this, for some reason I'm getting "No instance for (Equal c0 Int Int)" on equal (1 :: Int) (2 :: Int)
09:42:03 <JordiGH> lol
09:42:05 <HeladoDeBrownie> @type lens
09:42:13 <HeladoDeBrownie> Oh, no lambdabot
09:42:18 <HeladoDeBrownie> Also that might not have been in it anyway
09:42:29 <hiptobecubic> HeladoDeBrownie, lambdabot has gone home for the day
09:42:35 <JordiGH> edwardk: If they don't work, why don't get I a type error earlier?
09:42:40 <edwardk> but note 1 :+ 3   -- is the same as saying fromInteger 1 :+ fromInteger 3  --    so writing 1 :+ 3   isn't writing something you can't use
09:42:48 <HeladoDeBrownie> hiptobecubic, I'm surprised it doesn't take a break more often, it's a hard worker
09:42:57 <edwardk> because of what i just said
09:43:06 <Jello_Raptor> HeladoDeBrownie, edwardk: Yeah, I'm having trouble finding things about writing Control.Lens lenses from scratch. Everything seems to just like using the template haskell
09:43:06 <edwardk> > 3 / 4
09:43:21 <HeladoDeBrownie> Jello_Raptor, this maybe? http://hackage.haskell.org/package/lens-4.6/docs/Control-Lens-Lens.html#v:lens
09:43:24 <edwardk> ^- that works in haskell 3 isn't just 'an int' in haskell
09:43:28 <JordiGH> edwardk: It's.... something I can't use... Complex Integer is just a pointless ordered pair.
09:43:38 <edwardk> Jello_Raptor: i write a fair chunk of them froms cratch
09:43:44 <glguy> Jello_Raptor: https://gist.github.com/glguy/74960a3f1531b64a201b
09:43:46 <edwardk> JordiGH: absolutely
09:43:47 <bitonic> JordiGH: the expression "1" doesn't have type Integer
09:43:54 <bitonic> it' more general
09:43:58 <vanila> JordiGH, haskells number heierarchy is kinda bad
09:44:04 <edwardk> but there is no way it can be anything but so long as we have the numeric tower we do
09:44:12 <JordiGH> bitonic: x = 1 :+ 3 gets deduced to Complex Integer if I don't annotate it.
09:44:29 <edwardk> bitonic: lemme guess older ghc and you are sitting at the repl?
09:44:30 <JordiGH> This really seems like a bug in the type system and probably a bug that we have to keep because whoever first came up with the number system didn't think complex numbers were important enough to be treated with respect. :-(
09:44:36 <tromp_> Complex Integer is Gaussian integers
09:44:47 <Jello_Raptor> thank you :)
09:44:48 <edwardk> er jordigh
09:44:55 <JordiGH> tromp_: Well, then...
09:44:55 <vanila> it's just too hard to make a good number system with the tools haskell gives us
09:44:58 <JordiGH>     No instance for (RealFloat Integer)
09:44:58 <JordiGH>       arising from a use of `+'
09:44:58 <edwardk> tromp_: they would be, if we could have them
09:45:04 <vanila> you don't have proper object orientation
09:45:18 <vanila> and shoehorning that into typeclasses results in code littered with 'fromIntegral' etc.
09:45:43 <edwardk> JordiGH: older GHCs used to turn on MonomorphismRestriction (as it is the default for the language) currently if you work at the repl you have NoMonomorphismRestriction
09:45:49 <edwardk> so when you type let x = 1 :+ 3
09:46:04 <JordiGH> It's especially frustrating when this language gets promoted as being "for mathematicians" without having proper built-in complex types.
09:46:05 <edwardk> you'd get Num a => Complex a
09:46:36 <edwardk> Jordi: you can define a perfectly cromulent numerical tower in haskell. Num ain't it.
09:46:42 <vanila> haskell is NOT for mathematicians
09:46:54 <JordiGH> edwardk: I don't want to define it, I want to have it built-in like in Sage and Mathematica.
09:47:07 <JordiGH> But I suppose I'll have to define it if I really want to keep using Haskell...
09:47:10 <JordiGH> Anyways, lunch, ttyl.
09:47:12 <hiptobecubic> JordiGH, well other people have defined it. It's just not the default.
09:47:26 <hiptobecubic> JordiGH, there are several other Prelude implementations
09:47:34 <edwardk> JordiGH: there are things like numeric-prelude, algebra, etc. that do a lot of work to make a more refined accurate numerical tower
09:47:41 <edwardk> they aren't the default
09:48:16 <edwardk> Num is 'all the things the folks who came up with the language could extract in common about all the concrete number types they had to support'
09:48:23 <monochrom> who said that Haskell is for mathematicians? someone on the internet?
09:48:31 <edwardk> and one of them thought it was clever to include abs/signum in that class
09:48:55 <edwardk> that has proven to be a bad idea, but my time machine is broken
09:49:06 <bitonic> in any case, without the monomorphism restriction (the default recently), `let x = 1 :+ 3 in x + x' is valid
09:50:08 <vanila> why not just add an Integral instance of Complex though?
09:50:20 <hiptobecubic> Or define abs as id and signum as const 1 for Integer and Int?
09:50:28 <hiptobecubic> err
09:50:40 <hiptobecubic> signum as the appropriate result rather :)
09:50:47 <hiptobecubic> was thinking of N
09:51:27 <bitonic> JordiGH: btw, nobody would claim that Haskell works in the same space as Sage or Mathematica (which I think is what you mean by "for mathematicians")
09:51:33 <bitonic> or at least I hope so.
09:53:08 <hiptobecubic> Actually no this is pretty confusiong
09:53:25 <hiptobecubic> Why does Complex require RealFrac for Num at all?
09:53:52 <glguy> for signum and abs
09:54:28 <hiptobecubic> oh right, I forgot those do things to complex numbers
09:54:37 <hiptobecubic> That's sad :(
09:54:49 <bitonic> Num is sad yes
09:55:04 <glguy> Prelude Data.Complex> signum (1 :+ 1)
09:55:05 <glguy> 0.7071067811865475 :+ 0.7071067811865475
09:55:07 * hiptobecubic is sad
09:55:44 <hiptobecubic> glguy, yes I see. I wasn't thinking about "the complex numbers", just things put together with :+   :)
10:02:44 <favetelinguis> im trying to use QC to generate lists with only uniqe elements with   l <- elements $ permutations [0..num]  however this is to slow to be a reseonable sulution, any other way of doing this?
10:03:36 <vanila> favetelinguis, I guess this generates all the permutations and then chooses one - it could be more efficient to randomly shuffle a list
10:05:40 <andrea__> why does this work "let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)"   ? fibs is undefined
10:06:12 <RchrdB> andrea__: laziness!
10:06:25 <vanila> andrea__, the first part of it is defined
10:06:31 <vanila> and then the rest of it is made from that
10:06:39 <andrea__> i thought, its not possible to use undefined values
10:06:43 <vanila>   0 : 1 : ???
10:06:47 <vanila> + 1 : ???
10:06:49 <vanila> comes out as
10:06:54 <RchrdB> andrea__: the first two elements of fibs are defines, and the third element refers only to the definitions of the first two, and the fourth element refers only to the definitions of the second and third, and so on...
10:06:58 <RchrdB> *defined
10:07:07 <kadoban> andrea__: It's not undefined though, it's just recursively defined.
10:07:17 <vanila> means you'll get 0 : 1 : 1 : ??? and you can work it out from there
10:07:32 <vanila>   0 : 1 : 1 : ???
10:07:36 <vanila> + 1 : 1 : ???
10:07:42 <vanila> 1 : 2 : ???
10:09:13 <andrea__> ok 0 : 1 : 1  (+) = [0, 1,2] ?
10:10:39 <ReinH> andrea__: make sure you understand what zipWith (+) fibs (tail fibs) is doing there
10:11:01 <ReinH> compare to, e.g.,
10:11:03 <andrea__> 0 : 1  + 1 : ?? = 1 : 1+???
10:11:13 <ReinH> > let x = 1 : x
10:11:15 <lambdabot>  not an expression: ‘let x = 1 : x’
10:11:19 <ReinH> > let x = 1 : x in x
10:11:20 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
10:11:39 <andrea__> zipWith (+) adds the elemnts of two lists
10:12:36 <andrea__> but one of the two list is undefines on the first call
10:13:06 <andrea__> lazyness, or not lazyness
10:13:23 <ReinH> andrea__: fibs is defined everywhere
10:14:12 <ReinH> so we have 0 : 1 : zipWith (+) (0 : ...) (1 : ...) = 0 : 1 : 1 : zipWith (+) (1 : ...) (1 : ...) = 0 : 1 : 1 : 2 : zipWith (+) ...
10:16:04 <benzrf> andrea__: you can think of ReinH's recent example in terms of how it'd be imperatively:
10:16:07 <benzrf> def x():
10:16:12 <benzrf>   return cons(1, x())
10:16:25 <exio4> that doesn't look imperatively
10:16:33 <recursion-ninja> Hey I have a question! How can I best use monadic computation to define `f :: Map a [b] -> [Map a b]` where in the input Map, `a` is a key and `[b]` is a list of possible values for the key `a`. The output is the list of all Maps where `a` has a value `b` in `[b]`, and `b` is not the mapped value for any other `a` in that Map.
10:17:18 <recursion-ninja> the constraint part of `b` not being mapped to any other `a` is what is tripping me up...
10:17:21 <ReinH> recursion-ninja: why do you want to do this?
10:18:24 <recursion-ninja> ReinH: To solve a constraint problem, I need to map all the `a`s uniquely to a `b`, but only certain `b`s are applicable to certain `a`s
10:18:48 <andrea__> thanks for help
10:18:52 <benzrf> recursion-ninja: sequenceA
10:18:56 <benzrf> possible
10:19:00 <benzrf> that's the right type, anyway
10:19:07 <recursion-ninja> :t sequenceA
10:19:08 <lambdabot>     Not in scope: ‘sequenceA’
10:19:08 <lambdabot>     Perhaps you meant one of these:
10:19:08 <lambdabot>       ‘T.sequenceA’ (imported from Data.Traversable),
10:19:15 <recursion-ninja> :t T.sequenceA
10:19:16 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
10:19:25 <benzrf> > T.sequenceA (fromList [("key1", [1, 2]), ("key2", [3])])
10:19:27 <lambdabot>  Not in scope: ‘fromList’
10:19:27 <lambdabot>  Perhaps you meant one of these:
10:19:27 <lambdabot>    ‘IM.fromList’ (imported from Data.IntMap),
10:19:27 <lambdabot>    ‘M.fromList’ (imported from Data.Map),
10:19:27 <lambdabot>    ‘S.fromList’ (imported from Data.Set)
10:19:31 <benzrf> > T.sequenceA (M.fromList [("key1", [1, 2]), ("key2", [3])])
10:19:33 <lambdabot>  [fromList [("key1",1),("key2",3)],fromList [("key1",2),("key2",3)]]
10:19:58 <benzrf> recursion-ninja: Traversable is a class for types that can be sequenced
10:20:03 <benzrf> Map implements it :-)
10:20:21 <ReinH> But that doesn't meet the specification
10:20:24 <benzrf> oh right
10:20:28 <benzrf> fug, i didnt fully read it :|
10:20:33 <benzrf> you could just filter the output >.>
10:20:48 <recursion-ninja> > T.sequenceA (M.fromList [("key1", [1, 2]), ("key2", [2,3]), ("key3",[1,3])])
10:20:49 <lambdabot>  [fromList [("key1",1),("key2",2),("key3",1)],fromList [("key1",1),("key2",2)...
10:21:00 <ReinH> recursion-ninja: what kind of constraint problem?
10:21:15 <andrea__> > let a=1
10:21:16 <lambdabot>  not an expression: ‘let a=1’
10:21:44 <ReinH> recursion-ninja: I believe you can do this in O(a*b) by keeping a set of seen values
10:21:49 <recursion-ninja> ReinH: Automated Secret Santa drawing with participant relationship constraints
10:22:30 <recursion-ninja> ReinH: Enough constraints that a "by hand" draing isn't terribly feasible
10:23:49 <recursion-ninja> benzrf: Thanks for this pointer to sequenceA. I'll investigate how applicative it is (pun intended)
10:24:10 <ReinH> recursion-ninja: you want to generate every possible solution?
10:24:29 <recursion-ninja> ReinH: Yes, every solution that meets the constraints
10:24:43 <benzrf> recursion-ninja: that'd be applicable, sorry
10:24:46 <benzrf> recursion-ninja: pun denied
10:24:59 <recursion-ninja> benzrf: :( I tried
10:25:10 <ReinH> recursion-ninja: my first step would be to generate every possible value and then prune the generated values
10:25:16 <benzrf> recursion-ninja: what's the use case
10:25:25 <ReinH> if that pruning can be fused nicely, it may result in a nice algorithm
10:25:42 <recursion-ninja> benzrf:  Automated Secret Santa drawing with participant relationship constraints
10:26:11 <recursion-ninja> ReinH: Perhaps generating everything and then filtering with a "Seen-Set" will work
10:26:12 <benzrf> heh
10:26:24 <benzrf> recursion-ninja: so you're doing something like
10:26:32 <benzrf> recursion-ninja: a map of participants to potential recipients?
10:26:38 <benzrf> then turning that into a list of possible assignments?
10:26:40 <recursion-ninja> benzrf: Yes
10:26:45 <benzrf> interesting
10:27:32 <benzrf> recursion-ninja: what if
10:27:34 <recursion-ninja> benzrf: Constraints are grandparents cannot gift to grand children, no one gifts to someone in thier nuclear family, no one gifts to someone they have previously gifted to
10:27:36 <ReinH> recursion-ninja: filter satisfiesConstraint . sequenceA
10:27:52 <benzrf> ReinH: seems inefficient
10:27:55 <benzrf> recursion-ninja: what if
10:28:00 <ReinH> recursion-ninja: that will give poor asymptotics; the next step is to see if you can derive a better algorithm via equational reasoning
10:28:09 <andrea__> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs); in take 7 fibs
10:28:10 <lambdabot>  [0,1,1,2,3,5,8]
10:28:16 <Denommus> I wish to know how could I have multiple events in a single stepWire iteration
10:28:18 <benzrf> recursion-ninja: in the step where you build the candidates-for-recipient for each participant
10:28:23 <ReinH> recursion-ninja: a la http://www.cs.tufts.edu/~nr/cs257/archive/richard-bird/sudoku.pdf
10:28:24 <lpaste> cdk pasted “variadic HTML combinators with GADTs and TypeFamilies” at http://lpaste.net/114933
10:28:42 <benzrf> recursion-ninja: instead of building a list for each, just pick the first possible working one, then remove it from a persistent set of possible recipients for everyone
10:28:54 <ReinH> benzrf: yes, that will provide *a* solution
10:29:06 <benzrf> recursion-ninja: then continue searching the remaining-set instead of the full participant list
10:29:08 <ReinH> but the goal is to provide *all* solutions
10:29:16 <benzrf> ReinH: you could list monad or somethin
10:29:18 <benzrf> huh
10:29:21 <recursion-ninja> ReinH, benzrf: I'd like all possible solutions so I can choose one randomly
10:29:24 <ReinH> Generally the Bird approach works well for this
10:29:28 <ReinH> recursion-ninja: give it a shot
10:29:52 <ReinH> recursion-ninja: check out that Sudoku Pearl and Bird's Pearls of Functional Algorithm Design for more examples. This is exactly that sort of problem.
10:30:01 <benzrf> ReinH: lol
10:30:01 <benzrf> * recursion-ninja
10:30:17 <recursion-ninja> ReinH: I've noted the paper, which ironically I had stated reading earlier today on an unrelated note
10:30:18 <benzrf> i hate it when 2 ppl who are talking and their names start with the first 2 letters q.q
10:30:29 <ReinH> recursion-ninja: the sudoku solution is very similar to this
10:31:03 <ReinH> so filter . satisfiesConstraint . sequenceA is a reasonable model
10:31:11 <ReinH> er filter satisfiesConstraint . sequenceA
10:31:13 <recursion-ninja> ReinH, benzrf: Thanks both for your input, my class is starting now so I have to go
10:31:21 <Denommus> benzrf: hello, what's up?
10:31:25 <ReinH> recursion-ninja: np
10:31:34 <benzrf> Denommus: my level of knowledge
10:31:35 <benzrf> B)
10:31:59 <andrea__> > let fact =  1 : (zipWith ( * ) fact [1..] );  in take 7 fact
10:32:00 <lambdabot>  [1,1,2,6,24,120,720]
10:32:18 <Denommus> benzrf: how much do you know about FRP? XD
10:32:36 <andrea__> perhaps this example is easier to understand
10:33:09 <Jello_Raptor> just to check "(%%=) :: MonadState a m => LensLike ((,) e) a a c d -> (c -> (e, d)) -> m e" will take a lens into the state in a State monad, and a function that will turn the value that the lens extracts into a tuple of a return value and a modified value within the state, and give you a monad with the return value
10:33:24 <edwardk> yes
10:33:28 <benzrf> Denommus: enough to write a little bit of banana
10:33:40 <ReinH> edwardk: o/
10:33:40 <benzrf> edwardk: FUCK
10:33:40 <edwardk> and if fed a 'traversal' instead it'll give you the monoidal reduction of all your answers
10:33:44 <benzrf> edwardk: i needed that the other day
10:33:59 <benzrf> q_q
10:34:17 <Jello_Raptor> so "(%%=) :: MonadState a m => Lens' a c -> (c -> (e,c)) -> m e" being the type of my intended use case
10:34:22 <Jello_Raptor> s/being/is/
10:34:30 <Jello_Raptor> edwardk: i .. what?
10:34:43 <cdk> edwardk: is there any way to carry a value level proof of a constraint like (a ~ b) without using GADTs? ie. If I had a GADT `data T a where A :: T ()`, then pattern matching on A brings the constraint (a ~ ()) into scope. Can this be done without GADTs?
10:34:47 <edwardk> Jello_Raptor: i mention that in case you ever try to use it with a 'Traversal'
10:35:24 <edwardk> cdk: you can build 'leibnizian' equality as a data type without GADTs, but its not as strong in a world where GADTs don't exist.
10:35:54 <benzrf> what IS leibniz equality anyway
10:35:58 <Jello_Raptor> edwardk: presumably when I need ot use it with a traversal I'll understand what you mean :P
10:36:18 <andrea__> is only the lazy evaluation the rason that this "let fact =  1 : (zipWith ( * ) fact [1..] );  in take 7 fact" works ?
10:36:20 <benzrf> is that ast equality
10:36:33 <edwardk> newtype Leibniz a b = Leibniz { subst :: forall p. p a -> p b }
10:37:08 <edwardk> andrea__: you need laziness in full or in part, that case works with just 'generators', it doesn't need real laziness, though generators are a limited form
10:37:34 <edwardk> leibnizian equality between a and b says that P(a) implies P(b) for all propositions P.
10:37:52 <benzrf> edwardk: huh...
10:38:01 <edwardk> its not immediately obvious but you can work out that it is symmetric, transitive, etc.
10:38:08 <edwardk> symmetry is a bit fun
10:38:13 <cdk> edwardk: hmm, I think I've seen that type before. How does it carry constraints though?
10:38:36 <edwardk> cdk: it doesn't. but you can set constraints through it and get out modified ones
10:39:20 <benzrf> ah, i see
10:39:20 <benzrf> edwardk: so the only reasonable Leibniz is `Leibniz id'
10:40:04 <edwardk> given data a == b where Refl :: a == a then you can send it through Leibniz b c   to get a == c -- so you can use Leibniz to map over the start/end of (==)
10:40:09 <benzrf> edwardk: so a function like
10:40:10 <Denommus> benzrf: meh, I want to know about Netwire
10:40:19 <benzrf> Leibniz a b -> Leibniz b a
10:40:26 <Denommus> benzrf: reactive-banana doesn't allow recursive definitions, it's not very useful for games
10:40:30 <edwardk> it doesn't 'give you equality' ultimately, having GADTs is equivalent in expressive power to just having that (==) GADT in your language anywhere.
10:40:41 <edwardk> benzrf: that one is fun to write
10:40:44 <benzrf> (forall p. p a -> p b) -> q b -> q a
10:40:48 <benzrf> huuh
10:40:58 <edwardk> you have to pick 'p' very carefully
10:41:19 <benzrf> damn
10:41:36 <edwardk> you'll need a newtype in there
10:41:53 <benzrf> edwardk: hmm?
10:42:05 <edwardk> to make the 'predicate' you need.
10:42:43 <edwardk> but as a hint you get to know a and b and they can be used as part of 'p'
10:45:03 <benzrf> oh hmmmm
10:46:48 <benzrf> hhhmmmmmmmmmmmmmmmmmmmmm
10:47:11 <ReinH> edwardk: So I'm thinking that exploring [Hask,Hask] in terms of Compose might be nice for explaining monads, monad transformers, composition of natural transformations, etc
10:47:27 <edwardk> its a nice place to think
10:47:31 <ReinH> yeah
10:47:41 <edwardk> another good one to explore it in terms of is covariant Day convolution
10:47:52 * ReinH makes a note
10:48:18 <edwardk> the monoids of day convolution from products to products are Applicatives
10:48:19 <ReinH> edwardk: I want to use a type operator for Compose though, and ~> for Nat...
10:50:21 <edwardk> there is a little risk of the audience not being able to connect it back to practice that way though
10:50:27 <edwardk> (~>) for Nat is pretty easy though
10:50:40 <benzrf> i think i have an idea :-o
10:51:21 <ReinH> I think join :: Monad m => (m ⋅ m) a -> m a would be nice...
10:51:48 <benzrf> join :: Monad m => (m ⋅ m) ~> m
10:51:49 <benzrf> =D
10:51:58 <benzrf> :k (~>)
10:51:59 <lambdabot> Not in scope: type constructor or class ‘~>’
10:51:59 <ReinH> Or m ∘ m
10:52:10 <benzrf> \cir
10:52:11 <ReinH> benzrf: also that :)
10:52:11 <benzrf> ◦
10:52:55 <benzrf> @let type f ~> g = forall a. f a -> g a
10:52:57 <lambdabot>  Defined.
10:53:22 <benzrf> @let join' (Compose m) = join m
10:53:23 <lambdabot>  .L.hs:170:8: Not in scope: data constructor ‘Compose’
10:53:45 <ReinH> Yeah, that's the presentation I was thinking of for monads
10:53:47 <benzrf> @let newtype Compose f g a = Compose {decompose :: f (g a)} deriving Show
10:53:49 <lambdabot>  Defined.
10:53:51 <benzrf> @let join' (Compose m) = join m
10:53:52 <lambdabot>  Defined.
10:54:06 <Jello_Raptor> huh? does '^=' from Control.Lens require an instance of Num? or am I reading the error wrong? http://hastebin.com/dataqubiqe.hs
10:54:13 <benzrf> @let type f ◦ g = Compose f g
10:54:14 <lambdabot>  Defined.
10:54:27 <benzrf> :t join' :: (m ◦ m) ~> m
10:54:28 <lambdabot>     No instance for (Monad m1) arising from a use of ‘join'’
10:54:28 <lambdabot>     Possible fix:
10:54:28 <lambdabot>       add (Monad m1) to the context of
10:54:33 <benzrf> :t join' :: Monad m => (m ◦ m) ~> m
10:54:34 <edwardk> you can use type (◦) = Compose
10:54:34 <lambdabot> Monad m => () m m a -> m a
10:54:37 <edwardk> no need for args
10:54:40 <benzrf> edwardk: ah yes
10:54:58 <benzrf> mfw lambdabot prints ◦ as æ
10:55:12 <ReinH> edwardk: yeah
10:55:29 <ReinH> Nice.
10:56:45 <benzrf> @let List' a = Eta () | Cons (a, List' a)
10:56:45 <lambdabot>  Parse failed: Parse error: |
10:56:49 <benzrf> @let data List' a = Eta () | Cons (a, List' a)
10:56:50 <lambdabot>  Defined.
10:57:15 <Jello_Raptor> what? "a . b ^= c" doesn't work but "a . b %= const c" does? I'm confused >_<
10:57:32 <benzrf> @let data Free' a t = Eta2 (Identity t) | Cons2 ((a ◦ Free' a) t)
10:57:33 <lambdabot>  Defined.
10:57:39 <benzrf> shit that should be Mu
10:57:42 <benzrf> not Cons
10:58:08 <benzrf> ^anyway what i note is that those look like the same definition but im forced to be pointful
10:58:25 <fgs90> #haskell-freenode
10:58:30 <fgs90> hello
10:58:37 <benzrf> hello fgs90
10:59:14 <fgs90> how to write a random a function
11:01:24 <fgs90> anyone ?
11:01:48 <ChristianS> fgs90: you want to get random number?
11:02:28 <fgs90> yes I've got a pair of numbers and I want a function to choose from it randomly
11:02:58 <ChristianS> fgs90: check out the System.Random module
11:03:43 <ReinH> fgs90: does the pair represent bounds or a choice?
11:04:42 <AleksejsHome> is there some function that checks if a <= x <= b ?
11:04:56 <glguy> a <= x && x <= b
11:05:02 <AleksejsHome> :)
11:05:29 <solarus> :t inRange
11:05:30 <lambdabot> Ix a => (a, a) -> a -> Bool
11:05:32 <glguy> > map (inRange (1,4)) [0..5]
11:05:33 <lambdabot>  [False,True,True,True,True,False]
11:05:39 <benzrf> yo edwardk
11:05:43 <glguy> You could hijack array's range test, but it only works on Ix instances
11:05:49 <benzrf> im thinking about leibniz equality symmetry
11:05:54 <AleksejsHome> thanks!
11:06:11 * ReinH shrugs
11:06:18 <ReinH> I would just use a <= x && x <= b
11:06:31 <benzrf> i'm thinkin i need to create a newtype T such that a `T p a' contains a `p b' and a `T p b' contains a `p a'
11:06:51 <vanila> @pl \min max n -> (==)`ap`sort [min,n,max]
11:06:51 <lambdabot> (((((==) `ap`) . sort) .) .) . (. (flip (:) . return)) . (.) . (:)
11:06:57 <benzrf> then i can throw my q b into the T, apply my argument, then pull out a q b
11:07:04 <ReinH> vanila: Yeah I'll stick with mine thanks ;)
11:07:28 <benzrf> but given that i dont think you can make such a type w/o existing notions of equality and stuff
11:07:31 <benzrf> idk
11:07:37 <benzrf> edwardk: am i on the rght trck
11:08:15 <glguy> In a world where everything needs disclaimers and warnings I'm surprised that @pl doesn't remind users that its output is "not approved for human consumption"
11:09:38 <fgs90> does it have something to do with the IO() ??
11:09:56 * hackagebot lhs2html 0.99 - Compile lhs in bird style to md, html, hs.  http://hackage.haskell.org/package/lhs2html-0.99 (JulianFleischer)
11:10:01 <vanila> fgs90, yeah, you can use randomRIO in IO()
11:10:23 <vanila> n <- randomRIO (2, 5)
11:10:29 <vanila> this will give you a random number n
11:11:19 <ionum> hi does anyone here has experience with haskell and raspberry pi?
11:11:55 <WraithM> ionum: A little bit. What's up?
11:12:59 <ReinH> I like to think that lhs2html's version will slowly approach 0.999...
11:13:19 <SvenskFi1k> What's the best 2d game engine for Haskell right now? I found a page with a bunch of them, but most seem pretty incomplete. Helm looked interesting, but I've spent the last 2 hours trying to get it to install on Yosemite and it's throwing errors all over the place. Any good options or is this just not something I should use Haskell for?
11:13:22 <ionum> i want to track a laser pointer with opencv and haskell, but i just found out the pi camera is not supported directly, there is a python library but nothing for haskell - as i know, so what can i do?
11:13:49 <ReinH> SvenskFi1k: Helm might be the best maintained right now.
11:13:53 <ReinH> SvenskFi1k: Are you using a sandbox?
11:14:12 <SvenskFi1k> ReinH: Not using a sandbox, could that be the problem with installing it?
11:14:14 <ReinH> SvenskFi1k: Haskell is a good language for it. The ecosystem is a bit lacking.
11:14:23 <ReinH> SvenskFi1k: A sandbox might make it easier.
11:15:40 <SvenskFi1k> ReinH: Yeah that's what I meant, loving the language, just can't seem to get the (seemingly) only good 2d game engine to install. So I just run cabal sandbox init then try again?
11:16:51 <ReinH> SvenskFi1k: yeah, that'd be a good first step at least
11:17:18 <ReinH> SvenskFi1k: less package dependency related errors, at least
11:18:15 <sm> SvenskFilk: FunGEn is the oldest and easiest install. http://hackage.haskell.org/package/ActionKid is the newest and should be pretty easy too. See also #haskell-game
11:18:33 <SvenskFi1k> Same error:/ It's always cairo that fails to install because glib has a syntax error, and I don't have a package xcb-shm. I've seen 4 or 5 fixes for it and nothing has worked so far, any suggestions?
11:22:16 <SvenskFi1k> sm: Thanks, I'll check it out, just a bit frustrated because Helm seemed like a really cool engine, and I'd love to try it out, but I guess I'll go for FunGEn if I can't get Helm working
11:22:53 <sm> there's a learning curve for installing things with cabal. Definitely use a sandbox
11:32:13 <karolis> Sorry if I sound like a complete noob, but  I want to learn me some haskell. I tried downloading "haskell platform" and compile the source, it says I need to have GHC.. I go to GHC it says "STOP!" "Haskell platform already has GHC..". I download GHC source anyway - try to compile it says "GHC not found". What is going on here?
11:33:03 <glguy> You're meant to install one of the binary packages for Haskell Platform
11:33:04 <Ferdirand> which platform (OS) are you using ?
11:33:17 <glguy> If you want to compile from sources you will have to install GHC yourself, first
11:33:22 <karolis> ZenWalk (which is a spin-off of slackware)
11:33:26 <karolis> no binary for me
11:33:51 <karolis> newest version of GHC itself asked for GHC for some reason
11:34:12 <glguy> You'll have to install a binary version first. The compiler itself is written in Haskel
11:34:57 * hackagebot lhs2html 0.999 - Compile lhs in bird style to md, html, hs.  http://hackage.haskell.org/package/lhs2html-0.999 (JulianFleischer)
11:36:11 <otulp> karolis: Sure, there's no binary for ZenWalk, but there are binaries for Centos and Debian. Have you tried them?
11:38:16 <karolis> otulp, no, not yet. browsing through "downloads.haskell" now. Going to try some more. Maybe earlier versions of GHC were not written in Haskel. Will try cenots-build packages as well
11:45:41 <chirpsalot> Is there a way to make Attoparsec fail on a partial result?
11:46:35 <nh2_work> chirpsalot: https://hackage.haskell.org/package/attoparsec-0.12.1.2/docs/Data-Attoparsec-ByteString.html#v:parseOnly ?
11:47:22 <chirpsalot> nh2_work: trying to get... blah <|> meh to work, I don't think I can use parseOnly for that? The types don't match up anyway.
11:48:24 <nh2_work> chirpsalot: I think the only thing that can "forbid" a parser to continue with a Partial is `endOfInput`
11:49:03 <nh2_work> chirpsalot: I don't understand yet though what you're trying to achieve
11:53:18 <EvanR> :t splitOn
11:53:19 <lambdabot> Eq a => [a] -> [a] -> [[a]]
11:53:36 <EvanR> > splitOn "-" ""
11:53:37 <lambdabot>  [""]
11:53:53 <chirpsalot> nh2_work: apparently endOfInput was exactly what I needed. Thanks!
11:54:04 <nh2_work> welcome :)
11:54:58 * hackagebot expiring-cache-map 0.0.5.0 - General purpose simple caching.  http://hackage.haskell.org/package/expiring-cache-map-0.0.5.0 (elblake)
11:58:43 <lpsmith> hmm,  with the ffi,  how do I get the offset of a member of a struct?
11:59:01 <glguy> Are you using hsc2hs?
11:59:05 <lpsmith> yes
11:59:16 <glguy> #offset struct_type, field
11:59:19 <lpsmith> thanks
11:59:22 <glguy> cheat sheet: https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/hsc2hs.html
11:59:58 * hackagebot ghc-pkg-lib 0.2 - Provide library support for ghc-pkg information  http://hackage.haskell.org/package/ghc-pkg-lib-0.2 (JeanPhilippeMoresmau)
12:00:11 <lpsmith> thanks again, glguy :)
12:02:06 <mauris> hi, is `hInteract` defined anywhere (`interact` for a ReadWriteMode opened handle)?
12:05:05 <EvanR> shouldnt splitOn x "" be [] ?
12:05:26 <EvanR> @src splitOn
12:05:26 <lambdabot> Source not found. Where did you learn to type?
12:05:53 <glguy> mauris: Not that I know of, but interact f = do x <- getContents; putStr (f x)
12:06:44 <glguy> so you'd have something like:   hInteract hIn hOut f = do x <- hGetContents hIn; hPutStr hOut x
12:07:36 <recursion-ninja> ReinH: You there?
12:07:40 <ReinH> recursion-ninja: hi
12:07:53 <mauris> glguy: i want to modify a single file in read-write mode
12:08:07 <mauris> like "run the file through this filter"
12:08:54 <EvanR> normally youd write a temp file and then move at the end
12:09:10 <recursion-ninja> ReinH: I tried to just directly apply the `sequenceA` solution you and benzfs suggested, but GHC wines that one of my types isn't a Monoid. Where does the Monoid requirement stem from? Foldable being a requirement for traversable?
12:09:26 <EvanR> :t fold
12:09:27 <lambdabot> (Monoid m, Foldable t) => t m -> m
12:09:45 <recursion-ninja> ReinH: but Foldable doesn't appaer to require a Monoid instance...
12:09:57 <ReinH> recursion-ninja: unsure... this works for me:
12:09:58 <recursion-ninja> :t foldr
12:09:59 <lambdabot> (a -> b -> b) -> b -> [a] -> b
12:10:00 <ReinH> > T.sequenceA (IM.fromList [(1, "hello"),(2,"world")])
12:10:01 <lambdabot>  [fromList [(1,'h'),(2,'w')],fromList [(1,'h'),(2,'o')],fromList [(1,'h'),(2,...
12:11:10 <Denommus> I have a function foo :: a -> IO Bar
12:11:13 <recursion-ninja> ReinH: hmmm, probably because the String ([Char]) is a Monoid... but I had a list of types too...
12:11:23 <recursion-ninja> ReinH: hold on a moment
12:11:28 <Denommus> now, I want to generate a foo' :: Functor f => f a -> IO Bar from it
12:11:30 <Denommus> is it possible?
12:11:40 <Denommus> wait
12:11:41 <Denommus> hurr
12:11:57 <ReinH> :t T.sequenceA (IM.fromList [(1, "hello"),(2,"world")])
12:11:58 <lambdabot> [IM.IntMap Char]
12:12:04 <ReinH> recursion-ninja: No Monoid constraint involved
12:12:20 <Denommus> no, I still don't know
12:12:52 <mauris> Denommus: what would that function do?
12:13:27 <mauris> Denommus: sure you don't want IO (f Bar)?
12:13:32 <Denommus> mauris: the function in question is a Wire. The function would take the value from the wire and draw something on the screen based on it
12:13:34 <EvanR> a -> IO Bar looks like it ignores its argment?
12:14:00 <Denommus> EvanR: uh, why would it ignore the argument
12:14:15 <EvanR> forall a. a -> IO Bar
12:14:23 <mauris> i imagine it's actually SomethingElse -> IO Bar
12:14:27 <EvanR> ok
12:14:42 <Denommus> mauris: it's really a -> IO Bar
12:15:52 <mauris> huh, with no restrictions whatsoever on the type `a`?
12:15:54 <EvanR> since a doesnt appear in the result, and nothing is known about the capabilities of the argument value (its any type) you cant do anything with it
12:16:10 <Denommus> mauris: no restriction
12:16:29 <recursion-ninja> ReinH: I was dumb. I forgot to convert the list to a Map. I was just missing a `fromList`
12:16:35 <mauris> i'm thinking what EvanR said. i'm interested to see the code, now!
12:16:42 <Denommus> ...
12:16:59 <Denommus> so the function null also totally ignores the parameter, right? :P
12:17:09 <EvanR> const does
12:17:11 <EvanR> :t const
12:17:12 <lambdabot> a -> b -> a
12:17:17 <ReinH> recursion-ninja: heh :)
12:17:21 <EvanR> (ignores second argument)
12:17:27 <Denommus> since it's [a] -> Bool and the type parameter a is ignored in the result
12:17:36 <akurilin> Do you guys know if there's a resource anywhere out there to understand how to make the most out of classy-prelude? It seems that the author had a specific workflow in mind so I'd love to see examples of that
12:17:38 <mauris> Denommus: no, it doesn't use the a values in the list
12:17:49 <recursion-ninja> ReinH: Now I just get to filter over 147456 records.
12:18:06 <mauris> but you have *only* and a value that you don't know anything about
12:18:09 <mauris> *an
12:18:32 <Denommus> mauris: I'm receiving the function as a parameter. The implementor needs to care about the type, not me
12:18:48 <EvanR> ok its part of a larger type
12:19:12 <ReinH> recursion-ninja: well, the idea is that you can start to improve the asymptotics of this model to arrive at a real algorithm
12:19:25 <ReinH> recursion-ninja: look at the Sudoku solution, it does exactly this
12:19:47 <ReinH> Denommus: what is the type of the function you want?
12:19:52 <Denommus> EvanR: yes, the Functor is actually a Wire
12:20:05 <ReinH> Functor f => (a -> IO Bar) -> f a -> IO Bar ?
12:20:56 <Denommus> ReinH: I want to get a (world -> IO Picture) function as parameter, but since I'm working with wires internally, I need to pass a (Wire s e m a world -> IO Picture) to Gloss
12:21:03 <ReinH> Because that one is impossible. It requires a Functor f => f a -> a that can't exist. What about (a -> IO Bar) -> f a -> IO (f Bar)?
12:21:20 <recursion-ninja> ReinH: Reading the pearl now ;)
12:21:25 <ReinH> recursion-ninja: :)
12:23:19 <EvanR> so with f world, you cant get a world, you can only apply a (world -> foo) to get a f foo
12:23:22 <mauris> (ReinH: that needs Traversable f, right?)
12:23:36 <Denommus> okay, this is my code: https://gist.github.com/Denommus/24fd2f195ef3d26d297b
12:23:53 <Denommus> the thing that is wrong, of course, is "drawFn"
12:24:09 <ReinH> mauris: I believe so
12:24:32 <ReinH> I believe it's literally traverse
12:24:43 <ReinH> which is why I was steering towards it
12:24:50 <ReinH> :t traverse
12:24:51 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
12:25:06 <ReinH> :t traverse `asAppliedTo` putStRLn
12:25:07 <lambdabot>     Not in scope: ‘putStRLn’
12:25:07 <lambdabot>     Perhaps you meant one of these:
12:25:08 <lambdabot>       ‘putStrLn’ (imported from Prelude),
12:25:08 <Denommus> :i traverse
12:25:12 <ReinH> :t traverse `asAppliedTo` putStrLn
12:25:13 <lambdabot> Traversable t => (String -> IO ()) -> t String -> IO (t ())
12:25:30 <ReinH> where Bar ~ (), a ~ String, t ~ f
12:26:23 <ReinH> A bit more clear:
12:26:25 <ReinH> :t traverse `asAppliedTo` (undefined :: a -> IO b)
12:26:26 <lambdabot> Traversable t => (a -> IO b) -> t a -> IO (t b)
12:27:29 <Denommus> ReinH: this will put my IO G.Picture inside a Wire, though, won't it?
12:27:36 <greymalkin> Does hGetContents have a haskell implementation? I'm trying to switch to a getContents like lazy string in the midst of a program, but it keeps closing stdin on me.
12:27:50 <Denommus> ReinH: like IO (Wire s e m a G.Picture)
12:28:03 <Denommus> ReinH: Gloss won't accept that :-/
12:28:37 <ReinH> Denommus: For specific choices of `f' that provide a funciton extract : f a -> a, you can map extract
12:28:41 <ReinH> But not for all Functor f
12:28:55 <EvanR> :t extract
12:28:56 <lambdabot> Not in scope: ‘extract’
12:29:08 <ReinH> extract doesn't exist, it's a name I borrowed from Comonad to describe the desired function
12:29:09 <EvanR> comonad?
12:29:28 <recursion-ninja> ReinH: I want to use a `nodups` method as mentioned in the Sudoku paper (except for Map values), but I'm not sure how to structure a fold that can examine the intermediary structure
12:29:41 <EvanR> ok so not "cofunctor" ;)
12:29:45 <EvanR> or copointed
12:29:56 <ReinH> EvanR: a cofunctor is a functor, and functor doesn't provide a -> f a in any case
12:30:08 <JonReed> It seems almost impossible to find a freelance gig for haskell? Am I right or am I missing something? I browsed freelance sites and haskell jobs seem all dead. I did freelance gigs for C# on sites like freelancer before, but it seems that doing freelance gigs in haskell will be impossible, unless you choose a language-agnostic project.
12:30:17 <EvanR> copure
12:30:48 <ReinH> EvanR: Algebra ;)
12:31:08 <ReinH> a function f a \to a is an f-Algebra
12:31:09 <ReinH> er
12:31:10 <EvanR> JonReed: you might have to settle for someone flying you to sweden or something and paying you six figures instead
12:31:14 <ReinH> a function f a → a is an f-Algebra
12:32:05 <recursion-ninja> JonReed: Haskell is becoming more mainstream, but I had trouble (failed) to find a job out of college that valued functional programming. You might have less freedom freelancing because you client will want to beable to maintain your code themselves and Haskell has about the steepest learning curve (second to Malborage?).
12:32:33 <EvanR> malbolge?
12:32:46 <zguy> So, I'm currently a c++ dev, and interested in haskell.
12:32:47 <recursion-ninja> EvanR: google that cursed language
12:32:52 <EvanR> 5 years experience in malbolge required
12:33:04 <zguy> Was anyone else in the same position and want to give me some pointers starting out?
12:33:27 <Ferdirand> i'd say unlambda is steeper than Haskell too
12:33:57 <simpson> Haskell's learning curve is no steeper than any other uncommon language.
12:34:00 <funrep> @lyah
12:34:00 <lambdabot> Unknown command, try @list
12:34:09 <funrep> @LYAH
12:34:09 <lambdabot> Unknown command, try @list
12:34:09 <recursion-ninja> zguy: I'm no C++ pro, but coming from a strong C background, you need to learn a lot of new aproaches to problems that aren't iterative
12:34:13 <funrep> @list
12:34:13 <lambdabot> What module?  Try @listmodules for some ideas.
12:34:21 <barrucadu> @where lyah
12:34:21 <lambdabot> http://www.learnyouahaskell.com/
12:34:22 <funrep> @which LYAH
12:34:22 <lambdabot> Unknown command, try @list
12:34:37 <funrep> zguy: that book is very good elementary introduction to the language
12:34:38 <Denommus> ReinH: wait
12:34:46 <Denommus> ReinH: Wire s e m a b is a Monad m
12:34:56 <Denommus> ReinH: what if I have a Wire s e IO a b?
12:35:01 <zguy> funrep: thanks!
12:35:10 <funrep> zguy: after that i suggest reading "Write yourself a scheme in 48 hours", it will walk you through some practical code and have a lot of good exercises
12:35:25 <funrep> after that you should be ready to learn whatever library you want and/or build something of your own
12:35:29 <zguy> recursion-ninja: I'm definitely not a recursion ninja.
12:35:49 <zguy> thanks for the great starting point
12:35:50 <EvanR> Denommus: if you have a m a, and thats it, you cant get an a. you can only apply a (a -> m b) to get a m b
12:36:02 <EvanR> bad variable naming
12:36:24 <zguy> I went through an online demo of haskell, and it made my head hurt little. Functional programming is...very different for me.
12:37:01 <funrep> zguy: most important (imo) advice is if you dont quite get something, simply move on as long as you understand how to use it, intuition will come with use
12:37:11 <S11001001> @hoogle asAppliedTo
12:37:11 <lambdabot> No results found
12:37:12 <Denommus> EvanR: I'm wrong. The instance is Monad m => Arrow (Wire s e m)
12:38:01 <zguy> funrep: Hmm that's some sound advice. I'm used to having to dig in and fully understand something when I use it.
12:38:12 <zguy> funrep: You probably just saved me many headaches!
12:38:22 <EvanR> Denommus: maybe you shouldnt try to write very polymorphic functions in this situation and make it work for the specific case only. sounds like you might be using things not supposed by the general type classes
12:38:34 <osa1> I have a Pipe Word8 Word32 m () and I want to make a Pipe Word8 Word64 m () using this, how can I do that? I can't use monadic bind to `await` from other pipes ...
12:39:02 <EvanR> not supported*
12:39:16 <cdk> osa1: Pipes.map fromIntegral?
12:39:30 <recursion-ninja> zguy: functional programming (FP) is very different from the traditional imparative aproach. That's why I said you'll have to learn some new ways to think about problems
12:39:45 <osa1> cdk: no, I want to generate two Word32s and combine them to make a Word64
12:39:50 <EvanR> zguy: start writing programs, then write more programs
12:40:14 <JonReed> zguy: I followed approach described in http://stackoverflow.com/questions/1012573/getting-started-with-haskel  There are learnyouahaskell and 99 problems references. Also I have found that wikibooks ( http://en.wikibooks.org/wiki/Haskell ) has surprisingly good haskell pages, which I found myself looking into more and more.
12:40:27 <cdk> osa1: you'll probably have to write your own recursive loop with await/yield
12:40:34 <hiptobearcub> +1 wikibooks
12:41:14 <recursion-ninja> zguy: Once you get through LYAH, work through the following exercises. They are written by a world class Haskeller, Brett Yorgey for one of his undergraduate classes at Stanford: http://www.cis.upenn.edu/~cis194/lectures.html
12:41:21 <osa1> cdk: but await will return a Word8 because of type of this thing.. I need to be able to use a Pipe that consumes a Word8
12:41:46 <recursion-ninja> zguy: I can't stress enough how much I learned doing Yorgey's exercises
12:42:29 <zguy> Thanks, guys. I'm sitting here copying this stuff into Evernote so I don't lose these links/pieces of advice
12:42:31 <recursion-ninja> zguy: I actually did the older version of his exercises: http://www.cis.upenn.edu/~cis194/spring13/index.html
12:42:38 <ajcoppa> just a note since a few people are suggesting many different ways to learn haskell: there is a #haskell-beginners channel here on freenode. it includes an extremely helpful guide that suggests recommended resources and their ordering
12:42:40 <cdk> osa1: write a Pipe Word32 Word64 m () then use (>->) to combine them into Pipe Word8 Word64 m ()
12:42:44 <recursion-ninja> zguy: He had newer ones for this semester
12:43:14 <recursion-ninja> zguy: I don't know if the newer ones are better but I can vouch for the older set
12:44:15 <recursion-ninja> ReinH: I got it to work :) `I can haz secret santaz`
12:44:27 <osa1> cdk: yep. thanks.
12:45:19 <sooheon> ajcoppa: thanks for the learners resource
12:45:24 <Denommus> EvanR: even if I used only the specific stuff, I'd have no idea how to provide Gloss with the correct output
12:45:32 <recursion-ninja> peace
12:45:46 <ajcoppa> sooheon: you're welcome. happy learning!
12:46:17 <EvanR> Denommus: what is the type that gloss is wanting
12:46:23 <ajcoppa> #haskell-beginners also has lower traffic, which makes learning and teaching a bit more reasonable
12:47:37 <Denommus> EvanR: ([G.Event], Wire s e m a world) -> IO G.Picture
12:48:26 <EvanR> Denommus: eh, is this inside a larger function type
12:58:12 <Denommus> EvanR: I think I found out
12:59:02 <Denommus> EvanR: the thing is that stepWire GIVES me a value of type Either a b
13:00:54 <Denommus> EvanR: but I was ignoring it because it's somewhere else
13:02:34 <EvanR> Denommus: so you know what type you need, and you have some type, all thats left is the type error message ;)
13:03:33 <zguy> Is it common to mute connect/disconnect messages?
13:03:45 <osa1> I'm confused about how to get values out of Pipes
13:03:57 <osa1> I'm combined several pipes and I'm initializing a Producer
13:04:05 <StoneToad> zguy: in a large channel? yes
13:04:38 <osa1> now I want to get some Maybe value depending on whether my pipe produced something or not(e.g. when producer run out of stuff)
13:05:35 <zguy> StoneToad: Thanks.
13:06:22 <ReinH> RevJohnnyHealey: :)
13:06:27 <ReinH> woops
13:06:35 <RevJohnnyHealey> huh?
13:08:13 <osa1> ok, found it
13:08:15 <osa1> pipes are cool
13:09:46 <osa1> I'm wondering if I can run a producer in one thread and use it in a pipe in some other thread ...
13:10:48 <EvanR> theres a package called pipes-concurrency
13:14:52 <seangrove> https://www.refheap.com/93890
13:15:03 <merijn> osa1: No
13:15:13 <seangrove> Is there a way to sort with `-` so that the list doesn't have to be reversed on line 4?
13:15:17 <merijn> ah, someone already mentioned pipes-concurrency
13:15:21 <osa1> merijn: why?
13:15:34 <seangrove> `sortBy - [10,100,99,4,1,24]` doesn't seem to work
13:15:53 <merijn> "sortBy -" is a type error
13:16:05 <merijn> :t sortBy
13:16:06 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
13:16:16 <merijn> Presumably you mean
13:16:18 <merijn> :t comparing
13:16:19 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
13:16:25 <merijn> :t sortBy (comparing negate)
13:16:27 <lambdabot> (Ord a, Num a) => [a] -> [a]
13:16:44 <merijn> > sortBy (comparing negate) [1..10]
13:16:45 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
13:16:52 <seangrove> Where does comparing come from?
13:16:59 <sinelaw> @where comparing
13:16:59 <lambdabot> I know nothing about comparing.
13:17:02 <merijn> @hoogle comparing
13:17:03 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
13:17:10 <merijn> Data.Ord
13:17:23 <merijn> osa1: pipes are essentially CPS-ified loops
13:17:30 <merijn> osa1: Therefore they must be single threaded
13:17:42 <merijn> osa1: pipes-concurrency lets you use concurrency as EvanR pointed out
13:17:43 <seangrove> merijn: That's right, thank you!
13:19:03 <EvanR> coinduit, pipes, iteratee, wires, channels, all we need now is tubes
13:20:18 <simpson> EvanR: In Python and Monte, tubes are the name of an abstraction inspired partially by conduits and pipes.
13:20:43 <EvanR> monte?
13:20:52 <simpson> It's like E.
13:22:20 <benzrf> what's E
13:22:39 <simpson> http://erights.org/
13:22:47 <greymalkin> Is there a way to generate repeated, lazy calls, to `getChar` -- without using getContents?
13:23:14 <simpson> In ten words: E is for secure distributed computation between mutually untrusting systems.
13:23:33 <simpson> But it uses objects, so you probably wouldn't like it.
13:23:44 <EvanR> objects in what sense
13:24:10 <simpson> In the "bundle of state and behavior which communicates with other objects by passing messages" sense.
13:24:28 <EvanR> thats one of the better interpretations
13:24:38 <EvanR> with better names available
13:25:47 <simpson> I'm afraid that I've never heard any other definition of object which isn't language-specific.
13:26:55 <EvanR> that definition is smalltalk specific
13:27:24 <benzrf> simpson: something something subtype polymorphism
13:29:46 <simpson> EvanR: I'm not so sure about that. It fits the definition which Erlang, Ruby, E, etc. use. Maybe I'm just not well-educated on the subject.
13:29:58 <osa1> I realized that pipes are exactly what I need in my app but I'm too lazy to do the refactoring ...
13:30:01 * hackagebot vty 5.2.6 - A simple terminal UI library  http://hackage.haskell.org/package/vty-5.2.6 (CoreyOConnor)
13:31:37 <sinelaw> E's main feature (AFAIK) is good syntax for promises
13:32:15 <EvanR> simpson: yeah theres the whole family of "innovative" languages of the 90s which dont use this language, c++ java c# carrying over to ocaml, scala which seem to be on the other side of a schism of some sort.
13:32:32 <simpson> There's also :guards and json`{"embeddable": $languages, @too}`
13:32:45 <EvanR> also theory of objects
13:32:59 <EvanR> concerned mainly with inheritance issues
13:33:02 <simpson> Oh, objects in categories? Sure. That's definitely different terminology.
13:33:29 <simpson> Although you *can* define a category Obj if you're adventurous.
13:33:32 <FireFly> JS is stealing the fn`template string` syntax, by the way
13:33:34 <EvanR> im not familiar with objects in categories, what that
13:34:12 <sinelaw> FireFly, what do you mean?
13:34:14 <simpson> Oh, the values in categories are called the objects.
13:34:33 <EvanR> you think that is the basis for that family of "object models" ?
13:34:41 <sinelaw> The icky thing is subtyping, not "objects"
13:34:50 <sinelaw> various forms of inheritance
13:34:55 <simpson> Dunno. The word "object" is pretty old.
13:35:00 <josephle> EvanR: the theory of objects is basically the debate of inheritance vs composition
13:35:01 * hackagebot hmatrix-banded 0.0 - HMatrix interface to LAPACK functions for banded matrices  http://hackage.haskell.org/package/hmatrix-banded-0.0 (HenningThielemann)
13:35:34 <sinelaw> objects could mean just records (as they do in  javascript if you don't use 'this')
13:35:41 <EvanR> i should go get a history book and figure out where the hell c++ came from
13:35:46 <FireFly> sinelaw: E has template string syntax like  fn`string content here`  like simpson demonstrated above; ES6 is borrowing that feature.  Basically, it's sugar over a string literal and function call
13:35:57 <FireFly> Anyway, offtopic~ :p
13:36:06 <simpson> Yeah, I'll shut up about E now.
13:36:21 <sinelaw> thanks though.
13:36:34 <EvanR> message passing objects to me immediately makes me think of concurrent communicating processes
13:36:38 <josephle> just take it to #haskell-blah if you want to continue the conversation
13:36:39 <merijn> greymalkin: Yes, there is but you probably shouldn't as lazy IO is considered rather tricky to get right
13:36:56 <merijn> EvanR: C++ was basically "let's bolt some macros onto C" as origin
13:37:12 <benzrf> and then it Grew Organically™
13:37:14 <merijn> greymalkin: If you want to do streaming IO you may wanna look into libraries like pipes/conduits
13:37:36 <benzrf> sinelaw: i like eevee's post about what constitutes OOP
13:37:39 <EvanR> before/at the same time of templates was the whole class inheritance thing
13:37:53 <EvanR> whats the origin of that, id like to know
13:37:58 <benzrf> http://eev.ee/blog/2013/03/03/the-controller-pattern-is-awful-and-other-oo-heresy/
13:38:08 <benzrf> subclassing is just terrible
13:38:23 <benzrf> there are a couple of times when it makes sense
13:38:31 <merijn> inheritance is terrible
13:38:37 <merijn> subclassing can be neat if done right
13:38:39 <sinelaw> subTYPING in general complicates a lot of stuff
13:38:40 <benzrf> merijn: thats what i meant to say, sorry
13:38:42 <EvanR> when a horse and a unicorn are instances of quadrpeds?
13:38:44 <merijn> i.e. structural subtyping with row types
13:39:02 <merijn> I would love to have structural subtyping with row types in haskell :)
13:39:08 <favetelinguis> which function in quickcheck is it i can use to get statistics about the data generated for my property?
13:39:09 <sinelaw> my main conclusion from the subtyping chapter in TAPL is that "it's so complicated"
13:40:17 <merijn> sinelaw: Yeah, I dislike "invisible" subclassing
13:40:21 <sinelaw> merijn, I'm just about to implement that in my type checker :)
13:40:29 <sinelaw> (row type variables)
13:40:34 <merijn> sinelaw: Take a look at Ur? it implements row types
13:40:45 <sinelaw> thanks, so does Peaker's lamdu
13:40:49 <merijn> Ur in general looks pretty neat, if you can look past the HORRIFIC syntax
13:41:06 <merijn> sinelaw: Ur has a working compiler, unlike lambdu ;)
13:41:18 <EvanR> syntactic vegetables ;)
13:41:19 <merijn> sinelaw: http://www.impredicative.com/ur/
13:41:26 <seangrove> Does this look idiomatic, and is there a cleaner/clearer/faster/etc way of writing it? https://www.refheap.com/93897
13:41:30 <benzrf> lamdu gets rid of currying though :-(
13:41:40 <merijn> sinelaw: Haskell/Ocaml mix with dependent rowtypes :)
13:41:45 <sinelaw> lamdu has an interpreter or whatever you call something that runs the code directly from the AST
13:41:58 <sinelaw> benzrf, it does?
13:42:01 <sinelaw> not sure about that
13:42:10 <benzrf> peaker claims that currying is only good for haskell because it allows syntactically simple partial application
13:42:31 <benzrf> and that partial application can be done just as easily at an editor level in lamdu
13:42:36 <benzrf> which i dont like :[
13:43:27 <sinelaw> hmm
13:43:36 <sinelaw> I'll need to see that to understand what that means
13:44:48 <sinelaw> merijn, the horrible syntax is similar to ML/ocaml
13:45:15 <sinelaw> Ur looks cool
13:45:40 <merijn> sinelaw: Statically verified JS/SQL builtin too :)
13:45:51 <sinelaw> no kidding!
13:46:05 <sinelaw> reading right now.
13:46:17 <merijn> sinelaw: It's specifically designed for writing webapps
13:47:08 <sinelaw> is this a one-man team?
13:48:06 <merijn> sinelaw: I think so, not sure
13:49:35 <sinelaw> looks serious
13:49:40 <Denommus> EvanR: I'm starting to think I can't do what I want to do
13:49:51 <Denommus> EvanR: maybe I really should use SDL instead of Gloss
13:49:56 <EvanR> oo-heresy blog post, i love that he suggested "oo is about vtables" as a strawman, because that comes up so much, thats what i was wondering, that the inheritance paradigm from c++ is somehow about performance, like vtables are high performance... when even in old c++ youd hear that vtables were the SLOWEST thing available
13:49:57 <merijn> sinelaw: I heard it has pretty decent performance
13:50:04 <EvanR> Denommus: or glfw-b
13:50:52 <merijn> sinelaw: It's what you get when people who actually look at PL developments of the past 40 years write a new language, as opposed to these amateurs working on node.js :p
13:51:08 <sinelaw> merijn, oh yes indeed :)
13:51:58 <sinelaw> merijn, I used ML-style value restriction to overcome effectual stuff in my checker, but maybe I should be going the IO way
13:51:58 <EvanR> amateurs are doing something right when they can get people to actually use node.js for stuff
13:52:08 <EvanR> not saying its the technology
13:52:31 <merijn> EvanR: I'm pretty sure node.js isn't doing *anything* right, other than their "marketing to clueless people"
13:52:35 <sinelaw> EvanR, that's true too. it is the technology also - people can "just use it" without wrapping their brains around 40 years of stuff that hasn't been taught to them earlier on
13:53:17 <sinelaw> problem is that there's a big advantage to anything that "has been proven on production"
13:53:20 <Jello_Raptor> huh, how can the same type have two separate kinds?
13:53:21 <Jello_Raptor> http://hastebin.com/ovorawuwoc.hs
13:53:26 <EvanR> merijn: clueless people running startups ... who have themselves marketed to rich people...
13:54:08 <merijn> EvanR: Sure, even rich people can be clueless
13:54:31 <merijn> If the goal is to scam rich people out of money, I'm okay with that. Just don't pretend you've achieved anything technical
13:54:58 <EvanR> youd think something like js has an advantage in the business environment, when something is due in 7 hours out of nowhere, and you cant figure out the type theory for it, you should be able to just "hack" something
13:55:01 <sinelaw> nah, it's not the whole story. you can very easily START writing code that begins to do something with node.js and the sort
13:55:06 <EvanR> but you cant even do that in node.js due to limitations
13:55:31 <merijn> sinelaw: Only for some simple problems
13:56:26 <sinelaw> I've noticed that a lot of dynamically typed code looks like haskell (when you ignore the optional type annotations)
13:56:47 <Zorg> OOP was coined by smalltalk iirc, which emphasized on messages
13:56:54 <sinelaw> so basically people are writing correctly but without safety
13:57:14 <sinelaw> i.e. shoot themselves in the foot
13:57:44 <EvanR> it could be like haskell, and it could break out at any moment and do a big switch on runtime type info
13:57:44 <vanila> there's a typechecker for javascript
13:57:48 <vanila> seems interesting
13:57:53 <vanila> `flow'
13:58:05 <EvanR> flow is a good try at gradual typing
13:58:32 <sinelaw> the 'flow' hype is not fair. google closure compiler does the same and has been doing it for over 5 years
13:58:34 <EvanR> it doesnt support incorrect usage of object field getting and array indexing
14:00:28 <EvanR> detection of (detection of) types at runtime with if statements is really good, more dynamic systems should have some basic safety like this bolted on
14:00:56 <EvanR> since this is the literally what you have to do in those languages to get it right
14:04:36 <pharpend___> Is it now just the standard for eveyone's nick to be FirstL in the context of the full name being "First Last"?
14:04:52 <glguy> nope!
14:04:59 <PeterH> too late
14:05:11 <PeterH> also EdwardK
14:05:16 <sinelaw> flow supports the following:
14:05:16 <sinelaw> var y = null;
14:05:17 <sinelaw> y = y + 1;
14:05:17 <sinelaw> var x = y.length;
14:05:41 <sinelaw> three types in three lines, and it compiles.
14:05:41 <PeterH> edwardk: time to hop on the CamelCase bandwagon
14:06:01 <sinelaw> same problem with google closure.
14:06:30 <PeterH> sinelaw: well I think it says more about you that you are trying to make sense out of Javascript. This sort of seems like it's your fault
14:06:36 <vanila> its not supposed to be hindly milnor
14:06:46 <sinelaw> I know it isn't
14:06:46 <vanila> hindley milner*
14:06:51 <sinelaw> it's supposed to be usable for existing JS
14:07:05 <DICCON> ciao
14:07:30 <sinelaw> PeterH,  you can make sense out of JS by not writing such garbage code.
14:07:36 <sinelaw> and flow doesn't prevent it.
14:08:04 <PeterH> sinelaw: > not writing garbage code
14:08:04 <EvanR> sinelaw: isnt that particular thing intentional, some uses of null are defined as promoting (to zero, empty), however other uses of null are "outlawed" by flow
14:08:07 <PeterH> sinelaw: > js
14:08:13 <vanila> :/
14:08:16 <PeterH> sinelaw: I think you are missing the point of JS.
14:08:22 <vanila> this is low quality
14:08:48 <PeterH> sinelaw: JS exists so script kiddies who can't do actual programming have something to talk about amongst themselves
14:09:03 * ReinH sighs
14:09:06 <zguy> sinelaw: what do you think about angular?
14:09:06 <sinelaw> PeterH, that isn't the case anymore. real applications need to be written in JS
14:09:15 <EvanR> huge applications are not running on javascript
14:09:16 <zguy> PeterH: XD
14:09:19 <EvanR> s/not/now/
14:09:19 <monochrom> that is a tad too extreme
14:09:42 <sinelaw> zguy, it's a pretty good framework given the environment one is forced to live in
14:10:07 <zguy> sinelaw: are you familiar with laravel?
14:10:11 <sinelaw> nope
14:10:21 <sinelaw> eww php
14:10:24 <PeterH> vanila: we're at that sweet time of the day where the Americans are tipsy enough to be less inhibited, but sober enough that we can still type
14:10:33 <EvanR> you can write good composable javascript, no body does, and no framework lets your or encourages you to
14:10:41 <PeterH> that's true
14:10:49 <vanila> haha
14:10:59 <ReinH> Can this channel please be #haskell instead of #shitonjavascript now?
14:10:59 <EvanR> example, the missing reusable calendar widget for some purpose
14:11:01 <PeterH> I was under the impression that everybody understood that my javascript thing was a joke, but apparently not
14:11:02 <zguy> Just told a coworker about Malbolge. His response: William ZindaLol
14:11:10 <EvanR> the interfaces to all the libraries and widgets are just not good
14:11:17 <zguy> Apparently pasting doens't work
14:11:39 <zguy> I love how it dropped his name, too. <sarcasm>
14:11:50 <PeterH> ReinH: you shouldn't have gotten me so excited. #shitonjavascript doesn't exist, and I feel like you just made that up only to disappoint me
14:12:09 <ReinH> PeterH: Maybe you should create it and take this there.
14:12:10 <sinelaw> #shitmyjavascriptdoes
14:12:15 <ReinH> I don't want it here.
14:12:16 <zguy> Anyway, his response: Difference between php and malbolge: malbolge was intended to be impossible, php wasn't.
14:12:19 <PeterH> I did create it
14:13:33 <sinelaw> #haskell-blah is also ok.
14:14:02 <PeterH> sinelaw: tbf, 90% of the discussion in #-blah is just people talking about category theory
14:14:15 <PeterH> In fact, I think #-blah tends to be more on-topic than the main channel
14:14:17 <sinelaw> on a good day
14:14:35 <sinelaw> other times it's homotype theory
14:14:43 <sinelaw> oops
14:14:56 <sinelaw> homotopy type theory :)
14:14:58 <PeterH> sinelaw: that sounds like C+=, but possibly more hilarious
14:21:53 <FireFly> PeterH: huh, when I look it tends to be about Israeli politics or food or other stuff
14:23:05 <PeterH> hmm
14:23:36 <PeterH> I would like to discuss israeli politics
14:27:08 <batchm> you can if you solve the halting problem first.
14:28:04 <lcf80> hi. I am trying to think about simplest possible case of using list as Monad, with double bind and return
14:28:46 <lcf80> that wouldn't be possible using with using list just as functor
14:28:50 <Thooms> hey guys
14:29:24 <Thooms> I am looking for a cool summer internship these times, do you know some nice firms where they use haskell ?
14:30:11 <lcf80> any hints for that?
14:30:18 <ReinH> lcf80: what do you mean by "with double bind and return"?
14:30:19 <vanila> lcf80, [1,2,3] >>= \x -> "xy" >>= \y -> return (x,y)  maybe?a
14:30:34 <lcf80> well, let's take something simple like
14:30:38 <lcf80> [1..4] >>= \x -> [x^2] >>= \y -> return (x,y)
14:31:04 <lcf80> can be replaced by
14:31:06 <lcf80> map (\x -> (x, x^2)) [1..4]
14:31:55 <merijn> lcf80: You can't replace >>= with map, because >>= is strictly more powerful
14:32:00 <merijn> lcf80: >>= is concatMap
14:32:02 <merijn> :t concatMap
14:32:03 <lambdabot> (a -> [b]) -> [a] -> [b]
14:32:23 <lcf80> well output of my sample is the same
14:32:26 <Denommus> :t (>>=)
14:32:27 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:32:37 <Denommus> :t (=<<)
14:32:38 <lambdabot> Monad m => (a -> m b) -> m a -> m b
14:32:46 <lcf80> so that's why I am looking for something showing power of monad, in context of []
14:32:48 <Denommus> :t flip concatMap
14:32:48 <alrunner4> bind.return == fmap
14:32:49 <lambdabot> [a] -> (a -> [b]) -> [b]
14:33:07 <merijn> lcf80: Use a function that returns a list
14:33:21 <sams_> [1, 2, 3] >>= \x -> [x, x] can't be done with map, as least if you want to get a single continuous list as a result.
14:33:28 <merijn> > [1..10] >>= \x -> [1..x]
14:33:29 <lambdabot>  [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5,1,2,3,4,5,6,1,2,3,4,5,6,7,1,2,3,4,5,6,7,8,1,2...
14:33:49 <merijn> > [1..10] >>= \x -> if even x then [1..x] else []
14:33:51 <lambdabot>  [1,2,1,2,3,4,1,2,3,4,5,6,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,9,10]
14:33:54 <sams_> does lambdabot evaluate expressions?
14:34:00 <merijn> sams_: Yes
14:34:08 <merijn> Clearly :p
14:34:10 <sams_> > [1, 2, 3] >>= \x -> [x, x]
14:34:11 <lambdabot>  [1,1,2,2,3,3]
14:34:27 <sams_> awesome
14:34:58 <lcf80> ok, seems that alrunner4 pointed problem with my case
14:38:13 <alrunner4> i just say things at randome and sometimes they're not wrong
14:42:21 <merijn> :)
14:42:25 <merijn> alrunner4: Story of my life
14:42:44 <merijn> It's how it looks like I know anything about math :p
14:45:41 <alrunner4> :) :P
14:46:32 <lcf80> hm, still think my example should be possible :P
14:46:36 <lcf80> even if bind and return could be replaced with fmap
14:47:02 <lcf80> i should be able to perform something funny at stage of first bind
14:47:33 <lcf80> (hopefully)
14:48:55 <monochrom> do you mean: xs >>= (\x -> return (f x)) = fmap f xs
14:49:08 <merijn> lcf80: I just showed you what it can do that fmap can't
14:49:10 <lcf80> funny == unreplacable with single fmap over []
14:49:17 <merijn> > [1..10] >>= \x -> if even x then [1..x] else []
14:49:19 <lambdabot>  [1,2,1,2,3,4,1,2,3,4,5,6,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,9,10]
14:49:20 <lcf80> but I want ot keep return on the end
14:49:56 <merijn> lcf80: Then it will never do anything other than fmap
14:50:03 <ReinH> lcf80: you can replace bind with fmap and return.... and *join*.
14:50:05 <merijn> Because what you're doing *is* fmap
14:50:06 <monochrom> you can always add a return at the end.
14:50:14 <ReinH> er, with fmap and join
14:50:15 <lcf80> because I also wanted to show that list comprehension might be implemented as monad
14:50:20 <monochrom> [1..10] >>= \x -> if even x then [1..x] else [] >>= \y -> return y
14:50:53 <ReinH> without join in the case of lists, you will always take an [a] to an [[b]] when using fmap
14:51:26 <Luke> Guys i need some help. I'm writing a FromJSON (Aeson) instance for a JSON Object that has a string in it. that string is more escaped JSON. What's the best way to write that parser?
14:51:58 <lcf80> I guess I just need to do something like merijin just show, but on the first stage
14:52:18 <merijn> What does "the first stage" mean?
14:53:17 <lcf80> some kind of transromation that would need all the date as single []
14:53:37 <lcf80> data*
14:53:59 <ReinH> er, when replacing bind with fmap that is
14:57:17 <lcf80> sigh, to sum it up, what I am looking for: example of using [] as Monad, with bind and return, that could be also presented as list comprehension, but not when using [] as Functor
14:58:13 <lcf80> single bind and return are the same as fmap, if I get it right, so probably I would need more than one bind inside
14:58:32 <lcf80> still learning FP and Haskell, though, so I am not sure
14:58:50 <merijn> lcf80: Or just leave out return...
14:58:51 <Ralith> > do { a <- [1,2]; b <- [3,4]; return (a,b); }
14:58:52 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
14:59:18 <lcf80> but list comprehension is sugar always using return, isn't it?
14:59:44 <lcf80> (output expression)
15:00:04 * hackagebot postgresql-simple 0.4.8.0 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.4.8.0 (LeonSmith)
15:01:11 <Denommus> ok
15:02:17 <monochrom> lcf80, translation between comprehension and bind-return is already in Wadler's "comprehending monads", http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#monads
15:02:32 <Denommus> now I have a function stepWire :: Monad m => Wire s e m a b -> s -> Either e a -> (Either e b, Wire s e m a b) and a list of type [a]
15:03:41 <Denommus> for every element of the list, I want to run stepWire once, acummulate with the previous wire (like foldr or foldl), and, when it finish, I want to take the last result and get the final tuple
15:03:48 <monochrom> for an example of a thing doable monadically but not functorially: concat
15:03:55 <Denommus> is there a function that does something similar, or do I have to make my own recursive function?
15:04:25 <merijn> lcf80: list comprehensions don't desugar into bind/return at all
15:04:44 <merijn> You could, theoretically, but it's not what happens in practice
15:04:53 <lcf80> merijn I have my sample here https://gist.github.com/anonymous/46043ace084347120b50
15:06:54 <lcf80> I am making presentation for java user groups, where many folks will look at FP first time
15:07:02 <lcf80> so it's just basics of haskell
15:07:12 <lcf80> (learning myself in the process)
15:08:00 <mmachenry> Is there a way to check the warnings for one file in my project that is managed by cabal? Normally I'd just do ghc -Wall <file> but I can't directly call ghc on my files because I'm in a cabal sandbox so the libraries are not found.
15:09:01 <merijn> "cabal exec <ghc command here>"?
15:09:46 <lcf80> and that's why I wanted very consise example, easy to understand example, showing both binds and return in single line
15:11:14 <mmachenry> merijn: Doesn't seem to work.
15:12:48 <merijn> mmachenry: There was a way to run ghc in the sandbox via cabal, but I don't remember the details, consult the sandbox help
15:12:50 <EvanR> lcf80: you can show the definition of fmap for a monad
15:13:22 <lcf80> evanr should be the same as in functor?
15:13:45 <lcf80> so something like fmap :: (a -> b) -> f a -> f b, I guess
15:13:56 <lcf80> with (f :: * -> *)
15:14:27 <lcf80> (with f being [] in my case)
15:14:36 <EvanR> with f being an instance of Monad
15:14:41 <lcf80> y
15:15:22 <EvanR> fmap f ma = ma >>= \a -> return (f a)
15:15:34 <EvanR> it has >>= and return on one line
15:15:53 <lcf80> that's why I wanted one more bind
15:15:56 <EvanR> normally you wouldnt have this, youd be using fmap instead ;)
15:20:05 * hackagebot cql-io 0.12.0 - Cassandra CQL client.  http://hackage.haskell.org/package/cql-io-0.12.0 (ToralfWittner)
15:21:13 <Johnny_> hey guys i am trying to make first program to actually recover lost password on windows 8.1 can some one help me please?
15:21:29 <Johnny_> What I am trying to do is making a password guesser for windows 8.1 or newer with user made settings, for example if you remember partial of your password or letters etc. used in your password
15:21:41 <Johnny_> I tried ophcrack but making tables to it was too difficult for me, I am too new to pretty much everything in coding. if someone could guide me please how to make custom tables or such please do, I am even willing to pay for effort
15:22:38 <Rembane> Johnny_: If you want to crack passwords, get a program that does it for you. If you want to learn Haskell LYAH is a good start.
15:22:39 <HeladoDeBrownie> Johnny_, unfortunately, cracking is off-topic on Freenode.
15:22:54 <Rembane> Johnny_: http://learnyouahaskell.com/
15:23:48 <Johnny_> I dont care about haskell I am sorry for that, I am looking for someone who could help me . I have lost my own password and need to crack it by remembering pieces of it? if anyone is so kind and willing to help me please contact me on PM here, I am willing even to pay for effort.. I am not going to spam channel furthermore.
15:24:13 <HeladoDeBrownie> Johnny_, Freenode is not the medium for that.
15:24:16 <Johnny_>  I have even tried microsoft support and every single possible way and no one has been able to help
15:24:45 <HeladoDeBrownie> Johnny_, the best suggestion I can make is to keep trying Microsoft.
15:24:50 <Johnny_> not ken boot not ophcrack not any other tricks to try to open cmd... even if someone could guide me to open cmd through login screen on windows 8.1 or newer it would be a great help..
15:25:22 <lcf80> well, theoretically passowrd generation hinted by some pattern(s) might be a problem to solve in haskell ;)
15:25:28 <Johnny_> They dont know what to do,  I know it. Because its windows 8.1 local account its basically made so that only possible way to figure it out is to either remember password or bypass it with 3rd party program
15:26:00 <lcf80> but Johnny, you look more like you need regular IT support, I am afraid
15:26:03 <Johnny_> lcf80 I really like where you're going with that, you explained my intentions very well
15:26:03 <lcf80> not this channel
15:26:34 <lcf80> because there are tools for that already on the market, I think
15:26:39 <Rembane> lcf80: Sounds like an interesting topic for a paper.
15:26:49 <Johnny_> Seriously regular it support can only format my computer.. Its very random. I am going university where is computer sci students and I am myself not bad at cracking nor coding on cmd
15:27:22 <Johnny_> I really wish we could do together a bootable usb files that generate password using some custom patterns
15:28:01 <Freemason> https://www.youtube.com/watch?v=NUuhPFFIc60#t=45
15:28:02 <Johnny_> or well the .bats or .xmls or .whatever boot batch files it is possible to use at login screen of windows 8.1, I am here to test 24/7 atm every possible solution you guys can come up with
15:28:37 <koala_man> Johnny_: can't you just reset it?
15:28:58 <Johnny_> you mean format my computer?
15:29:04 <Johnny_> I could but I really want my files
15:29:07 <koala_man> no, reset the local account's password
15:29:09 <Johnny_> I really remember 70% of the password
15:29:20 <Johnny_> no I cant, not at all. I cant access cmd to do net user trick
15:29:36 <Johnny_> neither I can access cmd to enable hidden administrator account
15:29:47 <HeladoDeBrownie> Johnny_, a LiveCD will allow you to access your files if they are unencrypted.
15:29:48 <Johnny_> neither I have proves there is hidden admin on my computer
15:29:54 <koala_man> Johnny_: why not?
15:30:12 <Johnny_> ophcrack live cd? I have about 16 keys long password with special marks like , . - and number and big and small letters
15:30:16 <monochrom> why are we recovering passwords in #haskell?
15:30:20 <Johnny_> but I remember 70% of password ......
15:30:29 <Adeon> shoo shoo
15:30:34 <Adeon> this is #haskell
15:30:35 <HeladoDeBrownie> Johnny_, I was thinking more of a Linux distro. Anyway, as I've mentioned, cracking is off-topic on this network.
15:30:46 <HeladoDeBrownie> (And this channel in particular)
15:30:59 <Johnny_> :(
15:31:24 <Johnny_> passowrd generation hinted by some pattern(s) might be a problem to solve in haskell
15:32:22 <dibblego> Johnny_: this channel is not appropriate for this discussion.
15:32:38 <Johnny_> okay I am leaving :(
15:32:47 <dibblego> thanks
15:38:16 <recursion-ninja> Hey guys, I posted my implementation of a fixed length queue on codereview.SE to get some feedback but I have had poor reception. Would some of you mind looking at it and giving me feedback, either here on the IRC channel or over on codereview.SE? Link: http://codereview.stackexchange.com/questions/70371/haskell-pure-fixed-length-queue
15:45:58 <recursio1-ninja> ReinH: you there?
15:46:04 <trap_exit> I need to write a 'config language' for my Haskell app. Am I better off doing the config langauge in scheme, or in ahskell ?
15:46:56 <lcf80> and what do you mean by "config language"?
15:47:14 <recursio1-ninja> trap_exit: probably haskell for direct integration with your existing code and haskell is pretty decent at defining domain specific languages (DSL)s.
15:47:34 <trap_exit> the config langauge is parsed at _run time_
15:47:35 <recursio1-ninja> trap_exit: plus you'll get to learn something new
15:47:38 <trap_exit> so I'd have to parse whatever language I choose
15:48:21 <recursio1-ninja> trap_exit: what exactly are you parsing? text into a data structure?
15:48:53 <spine> wow, big room
15:48:55 <ReinH> recursio1-ninja: hi
15:49:13 <recursio1-ninja> ReinH: I got the secret santa thing to work!
15:50:04 <recursio1-ninja> ReinH: `filter correct . sequenceA myList` works wonderfully.
15:50:06 * hackagebot rosa 0.1.2.0 - Query the namecoin blockchain  http://hackage.haskell.org/package/rosa-0.1.2.0 (rnhmjoj)
15:50:18 <recursio1-ninja> ReinH:  hurray for lazy evaluation
15:52:01 <recursio1-ninja> ReinH: Would you mind looking at this and giving me some feedback? http://codereview.stackexchange.com/questions/70371/haskell-pure-fixed-length-queue
15:53:04 <merijn> hmm, Codensity == monadic CPS?
16:00:57 <glguy> Is there a cabal command that builds a particular executable from a .cabal file that has multiple executables?
16:01:43 <recursio1-ninja> ReinH: I read through that Sudoku paper. It was quite fascinating. I'm going to read through it again tomorrow after work to see if I can use any ideas to optemize my constraint problem
16:05:10 <hexagoxel> glguy: `cabal build` should do
16:05:22 <hexagoxel> (even if the help does not mention it)
16:06:16 <hexagoxel> i.e. `cabal build my-executable`
16:09:32 <t4nk229> I find myself composing monads in applicative style like x <$> y <*> z and then running Control.Monad.join on the result to remove the nesting... is there a better way to do this?
16:12:15 <merijn> t4nk229: Not really
16:12:26 <merijn> You could use liftM variants, but it's not much better
16:12:32 <merijn> :t liftM2
16:12:33 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
16:12:35 <merijn> :t liftM5
16:12:36 <lambdabot> Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
16:12:44 <merijn> Actually, no
16:12:48 <merijn> That still requires join
16:13:43 <t4nk229> ok, thanks.
16:13:51 <t4nk229> is this a common pattern?
16:13:55 <S11001001> t4nk229: yeah
16:14:37 <S11001001> if you had an infix op Monad f => f (a -> f b) -> f a -> f b that would be enough
16:15:13 <merijn> t4nk229: It's not uncommon
16:16:11 <hexagoxel> :exf (Applicative m, Monad m) => (a2 -> a1 -> m a) -> m a2 -> m a1 -> m a
16:16:11 <exferenceBot> \ b c d -> c >>= (\ h -> d >>= b h)
16:16:11 <exferenceBot> \ b c d -> d >>= (\ h -> c >>= (\ l -> b l h))
16:17:23 <S11001001> @ty \f a -> liftM (a >>=) f
16:17:24 <lambdabot> (Monad m1, Monad m) => m (a -> m1 b) -> m1 a -> m (m1 b)
16:18:19 <S11001001> @ty \f a -> ap (a >>=) f
16:18:20 <lambdabot> ((a1 -> a -> b) -> a) -> (a -> a1) -> (a1 -> a -> b) -> b
16:18:24 <S11001001> meh
16:21:58 <tc22> hey all, quick question for you. If I have a list of tuples in Haskell, and I want to check if a tuple exists within the list with the first element equal to some specific value, how would I go about that?
16:23:48 <recursio1-ninja>  > any ((==2).snd) [(1,1),(2,2),(3,3)]
16:23:48 <kadoban> tc22: Perhaps 'lookup' from Prelude
16:23:51 <merijn> tc22: Do you just want to check it's presence or also the value it has?
16:23:53 <recursio1-ninja> > any ((==2).snd) [(1,1),(2,2),(3,3)]
16:23:54 <lambdabot>  True
16:24:01 <ReinH> recursio1-ninja: Yep, the idea now is to rewrite the program so that the filtering happens earlier, during the generation process, so you produce less potential solutions if you can guarantee them to be non-solutions
16:24:23 <AleksejsHome> any ((== 3) . fst) $ zip [1..3] [4..6]
16:24:30 <recursio1-ninja> ReinH: That is what I will do tomorrow
16:24:43 <AleksejsHome> > any ((== 3) . fst) $ zip [1..3] [4..6]
16:24:45 <lambdabot>  True
16:25:51 <S11001001> t4nk229: pretty close...
16:26:00 <S11001001> @ty \f a -> f >>= (`liftM` a)
16:26:01 <lambdabot> Monad m => m (a1 -> b) -> m a1 -> m b
16:26:12 <S11001001> wait, no
16:27:52 <S11001001> t4nk229: if you're pulling in Lens you could always just stick '& join' at the end.
16:29:24 <ReinH> Cale: ping
16:29:42 <Cale> pong
16:29:44 <codehero> pong
16:29:51 <tsani> pung
16:29:51 <Cale> ?
16:30:08 <ReinH> Cale: would you have time for me to ask a somewhat involved question?
16:30:36 <Cale> Ask away
16:30:56 <Denommus> there's something I could do quite easily in reactive-banana, but I'm not getting my head around it in Netwire
16:31:21 <Denommus> I want a Wire to emit "True" while a button is pressed, and "False" while it isn't
16:31:26 <ReinH> Cale: So I'm using a Moore machine to model a command-and-control system: receive inputs, update your state-of-the-world, take transitions to attempt to recover from states considered bad
16:31:58 <ReinH> Cale: e.g. inputs might be "instance of service died", transitions might be "add instance", state might be (desired instances: 2, current instances: 2)
16:32:33 <Cale> okay
16:32:51 <ReinH> Cale: so there's a result from cybernetics known as requisite variety, which in this case implies that in order for the system to be self-regulating, the machine needs a transition from every possible "bad" state into a "good" state.
16:33:11 <ReinH> Cale: so what I'm trying to do is use some order theory to reduce the number of system states by considering some to be equivalent
16:33:55 <ReinH> For instance, I can define an ordering a <= b if the recovery transition for state a will also successfully recover from state b
16:34:53 <ReinH> So what I have now is that these states form a forest, where rootOf gives me the "most general state that will recover the given state correctly", which means I only need to consider the set of roots
16:34:59 <Cale> Well, wait a minute, the transitions are labelled with input symbols too? So is this an ordering on transitions for the same input?
16:35:18 <ReinH> Cale: Moore machine
16:35:28 <ReinH> I think I skipped a step
16:35:43 <ReinH> "instance of service dies" transitions from (desired: 2, current: 2) to (desired: 2, current: 2)
16:35:47 <ReinH> "instance of service dies" transitions from (desired: 2, current: 2) to (desired: 2, current: 1)
16:35:56 <Cale> Er, a Moore machine has transitions labelled by input, and output determined by the state alone.
16:36:08 <Cale> At least, if I understand it correctly
16:36:25 <ReinH> right
16:36:28 <ReinH> so inputs here are system events
16:36:36 <ReinH> outputs are actions to be performed on the system
16:36:56 <ReinH> so inputs update the state via the transition function
16:37:27 <ReinH> then the output function for a state attempts to find an output event that will update the system state to a "good" state
16:38:00 <Cale> oh, that's interesting
16:38:43 <ReinH> Cale: so what I'm basically wondering is: have you seen this sort of "state reduction graph" before anywhere?
16:38:54 <Cale> So if you have something else fiddling with the state other than transitions, can you really call it a Moore machine?
16:38:58 <ReinH> the idea is that I only need to consider the roots of the forest as machine states for requisite variety
16:39:13 <ReinH> Cale: well, the transitions trigger new observations
16:39:33 <ReinH> it's a moore machine with some restrictions on use that I'm not sure how to classify
16:41:43 <ReinH> Cale: Ah, I see. The state is solely determined by the transitions.
16:41:52 <Cale> yes, usually
16:42:09 <ReinH> The output is, say, an IO action that will produce new input symbols via system observation
16:42:33 <ReinH> I may cheat and introduce some state that I manage separately, but that would be trading correctness for performance and we can ignore it for now
16:42:54 <levi> ReinH: Hierarchical State Machines seems a bit like what you're describing.
16:43:43 <ReinH> levi: Yes, similar, but this is not an inheritance pattern
16:44:23 <ReinH> Cale: the only state I would need to manage would be things like "time an action was taken to help determine if retry is a viable recovery strategy"
16:44:38 <ReinH> or "number of times an action has been taken", etc
16:44:58 <ReinH> this complicates the model somewhat, but it's nonessential if I just ignore retry
16:45:26 <levi> ReinH: Your ordering sounds a lot like a subtyping relation.
16:45:33 <ReinH> levi: yes...
16:47:12 <ReinH> It's a poset because the graph structure is restricted to forests, which is nice
16:47:44 <ReinH> so you get antisymmetry back
16:48:05 <ReinH> levi: well, it's an inheritance relationship where the child's behavior is completely subsumed by the parent
16:48:20 <ReinH> so it's in some way simpler than hierarchical state machines
16:49:21 <levi> Well, I don't have any deep insights for you then.
16:49:28 <ReinH> (also the poset structure gives a nice way to introduce concurrency later)
16:51:45 <ReinH> Cale: oh btw, I also realized something nice about requisite variety in general: it's equivalent to totality on the output function, which means it can be compile-time checkable.
16:52:12 <ReinH> up to bottoms, in fact, which has a useful meaning: you may attempt state transitions that never converge
16:53:02 <Cale> Er, isn't the output function already required to be total?
16:55:23 <ReinH> Cale: required by what?
16:56:40 <Cale> By the definition of a Moore machine
16:57:31 <Cale> I guess you can consider the output alphabet to be a type which contains _|_ or something
16:57:53 <Cale> and then it wouldn't necessarily be total in that sense
16:59:29 <ReinH> Cale: yes, so requisite variety is implied by totality, which is required for it to be a moore machine
17:03:38 <ReinH> Cale: btw Moore machine might not be the best abstraction here...
17:04:02 <Cale> Yeah, it seems that way? I don't really know exactly what's going on :)
17:04:06 <ReinH> But the idea is to have the states form a forest structure that is used to do the "state reduction" via graph walking
17:04:12 <ReinH> rootOf, essentially
17:04:53 <ReinH> Cale: the Moore machine has a nice property here: we can't guarantee that taking an action will achieve the desired state transition, so we can't have our actions be s -> (s,o)
17:05:06 <ReinH> What we do instead is take the actions and then observe the system afterward
17:05:59 <ReinH> but either way, we are intereted in minimizing the number of actions that need to be defined
17:10:09 * hackagebot graph-core 0.2.1.0 - Fast, memory efficient and persistent graph implementation  http://hackage.haskell.org/package/graph-core-0.2.1.0 (AlexanderThiemann)
17:15:09 * hackagebot reroute 0.2.2.0 - abstract implementation of typed and untyped web routing  http://hackage.haskell.org/package/reroute-0.2.2.0 (AlexanderThiemann)
17:24:20 <marchelzo_> Does something like this exist in and standard modules: [a] -> [(a,Int)]? It would give the number of occurrences of each item in the list.
17:24:25 <marchelzo_> s/and/any/
17:24:48 <Cale> marchelzo_: No, but it's relatively easy to implement using Data.Map
17:27:32 <Cale> :t (\xs -> M.toList . M.fromListWith (+) $ zip xs (repeat 1))
17:27:33 <lambdabot> (Ord k, Num a) => [k] -> [(k, a)]
17:28:11 <marchelzo_> That is pure wizardry
17:28:38 <marchelzo_> A lot better than [(x,k) | x <- xs, let k = (length . filter (==x)) xs]
17:29:26 <ReinH> I'm fond of this version with lens:
17:29:29 <ReinH> > foldl' (\m c -> m & at c . non 0 +~ 1) M.empty "hello"
17:29:31 <lambdabot>  fromList [('e',1),('h',1),('l',2),('o',1)]
17:30:15 <Cale> marchelzo_: You might want to use the fromListWith in Data.List.Strict for this purpose if the lists are potentially very long with many of the same element.
17:30:45 <marchelzo_> Cale: they are both very long and contain many of the same element. thanks for the tip :)
17:31:05 <marchelzo_> ReinH: Maybe I would be too if I could parse it T_T
17:31:26 <Cale> (note that the functions in Data.List.Strict act on the same datatype as those in Data.List.Lazy, they're just stricter in the elements of the map in cases where it's important not to build up large unevaluated expressions)
17:32:41 <Cale> (and it really sucks to have to evaluate an expression like (((...((1 + 1) + 1)...) + 1) + 1) + 1
17:32:44 <Cale> )
17:35:18 <Cale> > foldl' (\m c -> M.insertWith (+) c 1 m) M.empty "hello" -- I think this is clearer than the lens shenanigans myself
17:35:20 <lambdabot>  fromList [('e',1),('h',1),('l',2),('o',1)]
17:36:38 <Cale> But that's what fromListWith is for
17:37:58 <marchelzo_> Yeah, I use Data.Map from time to time but had never bothered to look at fromListWith. It seems extremely useful. Thanks for the help.
17:38:41 <Cale> Oh, another thing to note that it's possible to do:
17:39:03 <Cale> > map (\x -> (head x, length x)) . group . sort $ "mississippi"
17:39:05 <lambdabot>  [('i',4),('m',1),('p',2),('s',4)]
17:39:54 <Cale> This might actually be quicker in many cases
17:40:31 <ReinH> Cale: I've always been disappointed that this pattern involves an implicit guarantee that the usage of head is total
17:40:50 <codehero> what is the easiest way to define a descending list with a variable?
17:40:50 <Cale> Well, it's easy to check in this case
17:40:56 <ReinH> Cale: it is easy to check
17:40:57 <codehero> [n..1] doesn't seem to work
17:41:00 <Cale> Because it's immediately following a group :)
17:41:19 <Cale> So this is one of the few times I think it's probably genuinely okay to use head.
17:41:19 <ReinH> but still, it's a (trivial) proof obligation
17:41:39 <Cale> codehero: You can use [n,n-1..1]
17:42:28 <codehero> Cale: thank you :)
17:42:44 <codehero> found out that I had a typo in my function :/
17:43:02 <codehero> i shouldn't have two functions called factor and factors...
17:43:42 * codehero should probably learn how to fold
17:46:22 <codehero> oh wait. a foldl won't help me there... well
17:54:01 <red_> i have a book by bird .. and he talks a lot about calculating a function definition from its specification. where can i learn more about this?
17:56:51 <sm> red_: perhaps the book How To Design Programs
18:04:30 <sgronblo> https://www.haskell.org/haskellwiki/Monad in "ability of computation to implicitly carry extra data" what exactly is this extra data?
18:10:39 <HeladoDeBrownie> sgronblo, could be a variety of things, and it doesn't generalize over all Monads. For example, IO has access to other features of the computer the program is running on, such as network ports and other running programs. State s carries an implicit value s that can be viewed and changed. Writer carries a value that is being appended to at various steps of the computation.
18:20:12 * hackagebot cron 0.2.2 - Cron datatypes and Attoparsec parser  http://hackage.haskell.org/package/cron-0.2.2 (MichaelXavier)
18:34:24 <PCChris> hello, in what ways are HKTs more powerful than generics?
18:39:46 <lwm> Hey guys, I asked this question on SO the other day: http://bit.ly/1rlDJZ0
18:40:20 <lwm> I managed to solve it, but I noticed the last comment, and I don't really know how to define a type to fit in the result
18:40:45 <lwm> I am vaguely familiar with 'data' type declarations ... but if anyone could point me in the right direction here
18:41:58 <lwm> Actually, the 'fromRow' instance gets me stuck. I don't really know where to start
18:45:20 <chadrs> is there anything I can do to make ghc not send build-id options to gcc? Getting this: /usr/bin/ld: unrecognized option '--build-id=none'
19:07:05 <gcganley> hey #haskell is almost 8 years old
19:17:12 <int-e> gcganley: hmm? the channel was registered in 2001.
19:18:15 <gcganley> int-e: it says for me 2006-11-26 01:42:48
19:18:41 <macalimlim> hello :) could anyone suggest a good couchdb library?
19:19:03 <L8D> macalimlim: couchdb?
19:19:13 <macalimlim> yes :)
19:19:22 <L8D> no I mean, couchd
19:19:25 <L8D> couchdb the library
19:19:41 <L8D> Database.CouchDB
19:19:47 <L8D> there's also couchdb-conduit
19:19:48 <macalimlim> a couchdb library for doing cruds
19:20:00 <macalimlim> oh thanks :)
19:20:00 <L8D> you'll want conduit then
19:21:22 <jfeltz> anyone want to help make this go viral?: http://www.reddit.com/r/programmingcirclejerk/comments/2n5f6d/you_need_to_be_more_object_oriented/
19:23:07 <vanila> jfeltz, please don't link reddit
19:23:28 <solatis> especially something from /r/programmingcirclejerk
19:23:50 <jfeltz> ok ;)
19:24:07 <Welkin> ?
19:24:17 <Welkin> that exists?
19:24:30 <davidthomas> So, fold is sort of morally equivalent to maybe on an entire list... does the equivalent for a single cons have a name?
19:24:36 <jfeltz> yah, nsfw / certain ages, my bad
19:24:46 <Welkin> sounds terrible
19:25:20 <Welkin> programmers are some of the worst people I have had the displeasure of meeting
19:25:29 <Welkin> in other cases, they are great to be around
19:27:28 <PCChris> hello, is there functionality that HKTs offer that is not offered by, e.g., traits in Rust?
19:27:58 <Welkin> hkt?
19:28:09 <PCChris> Higher-Kinded Types
19:28:55 <vanila> PCChris, mostly Higher-Kinded Types are just natural - it would be a strange restriction to disallow them
19:29:31 <vanila> i couldn't compare against rust
19:31:40 <Welkin> has anyone used pandoc to parse markdown into a haskell data structure?
19:33:43 <Welkin> for example: convert the chapters from a markdown file into Map Int [Paragraph] where type Paragraph = Text?
19:35:19 <kadoban> Welkin: Pandoc has an internal document format, maybe you could look at what it allows to access that, if you haven't?
19:36:49 <davidthomas> Welkin: nope, just to html here
19:52:10 <codygman> haskell-mode keeps trying to restart and failing every time I type. How can I tell it to go away? I keep hitting "n" to the restart attempt.
19:54:16 <PCChris> where can I find info on the implementation of type classes internally?
19:55:07 <Welkin> PCChris: look at the source
19:55:23 <Welkin> or do you mean how are they implemented by ghc during compilation?
19:56:50 <PCChris> Welkin: how they are implemented by ghc I think
19:57:01 <PCChris> Welkin: is it basically virtual method tables?
19:58:28 <Welkin> I don't know
19:58:31 <Welkin> ask in #ghc
19:58:37 <Welkin> or go to the ghc website and look up the docs
20:01:05 <lwm> anyone know what is wrong with this code: http://lpaste.net/98916
20:01:34 <bb010g> How performant is DiffArray right now?
20:02:00 <dibblego> lwm: do this at GHCi, :info FromRow
20:04:21 <AfC> I've been playing with Neil Mitchell's ghcid and it's pretty amazingly fast. But it doesn't help you _run_ anything, which is a shame. Anyone know a correspondingly cool way to run test snippet programs or are we still stuck adding a full section to the .cabal file for every last little thing
20:05:35 <bb010g> AfC: Link to ghcid
20:05:36 <bb010g> ?
20:05:43 <lwm> dibblego: Oh cool, but still lost ...
20:06:12 <AfC> bb010g: yeah, I'm actually tempted to do that
20:06:23 <dibblego> lwm: is fromRow listed as a method on FromRow?
20:07:14 <lwm> dibbelgo: yes, from what I think I see
20:07:21 <bb010g> AfC: I meant to ask for a link for ghicd.
20:07:43 <bb010g> AfC: I did a quick search on GitHub and didn't see anything.
20:07:48 <spopejoy> any tips on "reshaping" Aeson with lens?
20:07:49 <dibblego> lwm: then, what is giving you that error (since it cannot be GHCi)?
20:08:21 <ecstaticpessimst> any good video lectures on haskell that someone could recommend?
20:09:17 <jle`> ecstaticpessimst: there is that chalmers series
20:09:44 <lwm> dibblego: nope, it is GHCi
20:09:53 <lwm> dibblego: I am following docs from http://bit.ly/1tqHR9I
20:10:01 <spopejoy> i need to flatten Aeson objects in a list ...
20:10:08 <jle`> ecstaticpessimst: http://www.cse.chalmers.se/edu/year/2013/course/TDA452/FPLectures/Vid/
20:10:22 <Denommus> I... did it
20:10:23 <ecstaticpessimst> jle': looks good, thanks
20:10:33 <Denommus> SDL2 and Netwire are working together
20:11:17 <spopejoy> how do I join, say, (values . key "name") with (values . key "job" . key "role") such that "name" and "role" are at the same level?
20:11:28 <spopejoy> under toListOf that is
20:12:12 <jle`> Denommus: :D
20:13:01 <Denommus> jle`: an interesting about Netwire is that it does A LOT using just existing typeclasses instances
20:13:15 <Denommus> honestly, if I could use Netwire everywhere, I would
20:13:27 <Denommus> but it requires me to have the main loop, and sometimes I just don't
20:13:43 <Denommus> so, in this cases, reactive-banana to the rescue!
20:14:11 <jle`> :D
20:15:17 * hackagebot tighttp 0.0.0.4 - Tiny and Incrementally-Growing HTTP library  http://hackage.haskell.org/package/tighttp-0.0.0.4 (YoshikuniJujo)
20:16:06 <Denommus> I just need to think of a good abstraction for drawing, now
20:17:57 <kadoban> Anyone have a vim config using syntastic and ghc-mod with cabal sandboxes that works well?
20:35:18 * hackagebot snap 0.13.3.2 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.13.3.2 (DougBeardsley)
20:44:52 <texasmynsted> anybody know where the correct slides are for this https://vimeo.com/73648150 ?  Tony Morris's / dibblego's Monad Transformers presentation….  I downloaded some slides, but they seem to be for something else… heh
20:45:44 <dibblego> texasmynsted: I will build them, sec.
20:46:09 <texasmynsted> :-D
20:46:57 <Denommus> anyone understands about arrow notation?
20:47:05 <Denommus> I want to rewrite this function using arrows: velocity = vel' <$> (holdKey SDL.KeycodeA <+> holdKey SDL.KeycodeD) <|> 0
20:47:18 <Denommus> I'm having trouble with the <|> 0 part
20:50:03 <cdk> Does GHC have constraint synonyms? Like type T a b = (a ~ b)
20:51:18 <dibblego> texasmynsted: https://dl.dropboxusercontent.com/u/7810909/talks/monad-transformers/cbaa991e0eb49224eb286c1e418e2b9828e1fb21/monad-transformers.pdf
20:51:43 <bb010g> cdk: You should be fine with type and ConstraintKinds.
20:52:24 <bb010g> Has there been much progress recently with type level lambdas? I remember seeing some discussion about them on the GHC Trac a couple of months ago, but I haven't seen much since then.
20:53:01 <wnoise> @pl \d f l -> maybe d (uncurry f) $ uncons l
20:53:01 <lambdabot> flip flip uncons . ((.) .) . (. uncurry) . maybe
20:53:26 <wnoise> @pl \d f l -> maybe d (uncurry f) . uncons
20:53:26 <lambdabot> (const .) . flip flip uncons . ((.) .) . (. uncurry) . maybe
20:53:39 <wnoise> @pl \d f -> maybe d (uncurry f) . uncons
20:53:39 <lambdabot> flip flip uncons . ((.) .) . (. uncurry) . maybe
20:54:10 <centrinia> :t (.) . (.)
20:54:11 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
20:54:38 <wnoise> @pl \f d -> maybe d (uncurry f) . uncons
20:54:38 <lambdabot> flip flip uncons . ((.) .) . flip maybe . uncurry
20:54:43 <centrinia> @pl \x y z -> if x then y else z
20:54:44 <lambdabot> if'
20:54:47 <centrinia> :t if'
20:54:48 <lambdabot>     Not in scope: ‘if'’
20:54:48 <lambdabot>     Perhaps you meant ‘f'’ (imported from Debug.SimpleReflect)
20:55:47 <wnoise> @pl \l f d -> maybe d (uncurry f) $ uncons l
20:55:47 <lambdabot> flip (flip . flip maybe . uncurry) . uncons
20:56:02 <wnoise> @pl \l d f -> maybe d (uncurry f) $ uncons l
20:56:02 <lambdabot> flip (flip . (. uncurry) . maybe) . uncons
20:56:15 <wnoise> @pl \f l d -> maybe d (uncurry f) $ uncons l
20:56:15 <lambdabot> (. uncons) . flip . flip maybe . uncurry
20:58:22 <texasmynsted> Thank you dibblego!
21:17:36 <AfC> bb010g: ghcid https://github.com/ndmitchell/ghcid
21:19:23 <Zemyla> @pl \x f -> concat (map f x)
21:19:23 <lambdabot> (join .) . flip map
21:21:53 <bb010g> :t concat
21:21:54 <lambdabot> [[a]] -> [a]
21:39:28 <int-e> @pl \f x -> concat (map f x)
21:39:29 <lambdabot> (=<<)
21:40:03 <favetelinguis> reading this haskell example about quickcheck where they use a function ordered that checks if  a list is ordered but i cant find anything like this on hoogle. is there a prelude function that does this or do i need to make it myselfe?
21:40:29 <int-e> apparently the "flip" gets in the way of discovering (>>=) for \x f -> concat (map f x). Oh well.
21:41:11 <solrize> hmm i did apt-get install ghc on a debian 7 system and it didn't install Text.ParserCombinators.Parsec   is there something i have to do to get those standard packages?
21:41:41 <int-e> @hoohle isSorted
21:41:42 <lambdabot> No results found
21:44:12 <solrize> aha, haskell-platform
22:08:11 <ReinH> probably just sorted xs = xs == sort xs ?
22:09:44 <benzrf> i sleep now
22:09:45 <benzrf> bye
22:11:34 <zenguine> why not sorted xs = all (uncurry (<=)) $ zip xs (tail xs)
22:11:49 <zenguine> just jumping into the conversation here haha.. but that seems faster
22:11:53 <zenguine> though I don't know the original question
22:15:41 <ReinH> zipWith (<=) perhaps, but an extra log n probably doesn't matter too much in a quickcheck property
22:16:13 <ReinH> also if the sort is lazy, it may take less than n log n
22:16:50 <zenguine> ah yeah sorted xs = all $ zipWith (<=) xs (tail xs) looks better
22:16:55 <zenguine> always forgetting about zipWith
22:17:25 <zenguine> is there a live log of this channel somewhere?
22:17:36 <ReinH> zenguine: /topic
22:17:38 <zenguine> i hate when I log in and an interesting conversation is happening, but I can't join because I can't find where it started
22:19:38 <zenguine> ReinH: ah very cool.. thanks
22:35:22 * hackagebot taffybar 0.4.4 - A desktop bar similar to xmobar, but with more GUI  http://hackage.haskell.org/package/taffybar-0.4.4 (TristanRavitch)
23:00:36 <Zemyla> @pl
23:00:36 <lambdabot> (line 1, column 1):
23:00:36 <lambdabot> unexpected end of input
23:00:36 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
23:01:00 <Zemyla> @pl \((x, y), z) -> (x, y, z)
23:01:00 <lambdabot> uncurry (uncurry (,,))
23:01:40 <davidthomas> @pl \(x, (y, z)) -> (x, y, z)
23:01:40 <lambdabot> uncurry ((`ap` snd) . (. fst) . (,,))
23:02:35 <davidthomas> heh, some things are much clearer than others, point-free...
23:02:49 <vanila> @pl \(x,y,z) -> x
23:02:50 <lambdabot> (line 1, column 7):
23:02:50 <lambdabot> unexpected "z"
23:02:50 <lambdabot> ambiguous use of a non associative operator
23:02:51 <trap_exit> I need to do a distributed commit log in haskell. Shuld I just get a haskell binding for apache kafka, or is there something better?
23:04:37 <Zemyla> @pl \a b -> b / a
23:04:37 <lambdabot> flip (/)
23:04:57 <nitrix> Is there a reason why lambdas in haskell support multiple arguments?
23:05:11 <davidthomas> nitrix: convenience, I presume
23:05:41 <nitrix> Functions can be explained because of currying, but lamdas, I don't see the reasoning.
23:05:47 <nitrix> Other than it magically works.
23:05:49 <davidthomas> I believe anywhere you could write
23:06:01 <davidthomas> err
23:06:06 <davidthomas> I believe anywhere you *can* write
23:06:12 <vanila> nitrix, \x y z -> .. is just the same thing as  \x -> \y -> \z -> ... its shorter to write
23:06:12 <davidthomas> \ a b ->
23:06:16 <davidthomas> you could write
23:06:23 <davidthomas> \a -> \b ->
23:06:26 <wei2912> wait, you can't partially apply a lambda?
23:06:35 <kadoban> Sure you can
23:06:47 <dibblego> wei2912: All Haskell functions take exactly one argument.
23:06:48 <wei2912> then that explains why lambdas have multiple arguments, i guess
23:06:48 <davidthomas> and the former is certainly much less verbose
23:07:00 <wei2912> ^^
23:07:21 <nitrix> So the verdict? \x y z -> is sugar for \x -> \y -> \z -> ?
23:07:30 <nitrix> That's fine by me.
23:07:30 <jle`> yes
23:07:36 <dibblego> nitrix: Yes.
23:07:37 <jle`> same as foo x y z = ...
23:07:45 <jle`> is syntactic sugar for foo = \x -> \y -> \z -> ...
23:07:53 <davidthomas> I'm not 100% sure it's *implemented* that way
23:08:05 <davidthomas> but I don't think there's a theoretical difference
23:08:22 <silasm> you could look at GHC core output if you really care.
23:08:34 <nitrix> Not really.
23:08:54 <Zemyla> Since you can type 'map head ["foo", "bar", "baz"]', you can also type "let hmap = map head" and then later type 'hmap ["foo", "bar", "baz"]'.
23:08:54 <nitrix> The semantics are more interesting than the implementations.
23:09:02 <silasm> but semantically they're exactly the same, so it hardly matters, yeah.
23:10:41 <Zemyla> @pl \x y -> x
23:10:41 <lambdabot> const
23:10:55 <Zemyla> @pl \x y z -> ((x z) (y z))
23:10:55 <lambdabot> ap
23:12:01 <jle`> Zemyla: ya
23:12:06 <Zemyla> @pl \x -> x * x + 2 * x + 1
23:12:06 <lambdabot> (1 +) . ap ((+) . join (*)) (2 *)
23:12:38 <Zemyla> @pl \f x -> f x x
23:12:38 <lambdabot> join
23:12:46 <Zemyla> Oh, that's what join is.
23:13:08 <kadoban> :t join
23:13:09 <lambdabot> Monad m => m (m a) -> m a
23:13:32 <jle`> Zemyla: well, that's join for the Monad instance of (r ->)
23:13:46 <jle`> remember, join is different for every instance
23:14:00 <jle`> just like `fmap` is different for every Functor instance
23:15:25 <trap_exit> what is easier to parse, haskell or scheme?
23:16:13 <davidthomas> trap_exit: What libraries do you get to use, and what language are you writing this in?
23:16:25 <trap_exit> you get to use parsec
23:16:28 <trap_exit> and you're writing the parser in Haskell
23:16:52 <davidthomas> If you don't get to use haskell-src-exts, then probably Scheme
23:17:49 <davidthomas> lisp syntax almost isn't a syntax :-P
23:18:12 <davidthomas> it's typically "1) write your scanner, 2) you're done"
23:25:59 <Zemyla> Hmm, how do I load a module that has dependencies in the same folder?
23:34:43 <ocfx> >?
23:35:03 <t4nk810> hi,there
23:42:25 <dedgrant__> Hmm.. where can I go to learn how to be a better cabal hacker? ;)
23:42:47 <dedgrant__> As in, hacking on cabal. I can't figure out how the setup bootstrapper works.
23:50:25 * hackagebot cql-io 0.12.1 - Cassandra CQL client.  http://hackage.haskell.org/package/cql-io-0.12.1 (ToralfWittner)
23:51:19 <Zemyla> @pl \x -> if x == 0 then 1 else 0
23:51:19 <lambdabot> flip (flip if' 1 . (0 ==)) 0
23:51:32 <Zemyla> :type if'
23:51:38 <Zemyla> @type if'
23:51:39 <lambdabot>     Not in scope: ‘if'’
23:51:39 <lambdabot>     Perhaps you meant ‘f'’ (imported from Debug.SimpleReflect)
23:53:35 <Zemyla> @pl \f x -> if x == 0 then 1 else (x * (f (x - 1)))
23:53:35 <lambdabot> ap (flip if' 1 . (0 ==)) . ap (*) . (. subtract 1)
