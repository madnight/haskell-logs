00:00:09 <edwardk> i have a bunch of similar things in the old version of hask: https://github.com/ekmett/hask/blob/master/old/src/Hask/Core.hs#L337
00:17:54 <mrenaud> Thanks, I'm still pretty new so some of that likely went over my head :P I'm playing around with Lens now, it's pretty neat
00:49:19 <osa1> does that really return picoseconds http://hackage.haskell.org/package/base-4.7.0.1/docs/System-CPUTime.html ?
00:51:08 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org'
00:51:08 --- topic: set by glguy on [Thu Sep 25 17:55:19 2014]
00:51:08 --- names: list (clog jkarni1 msgodf Argue fujimura arenz martianboy clauswitt takuan pa3ce jle` AfC jkarni folone dysinger elfenlaid seveg tinyblak_ ventonegro osa1 vlatkoB srenatus royadav centrinia zorg24 biglama calvinx gratimax_ slomo psy_ Reite jutaro hebz0rl rshetty caumeslasal milessabin_ insitu raichoo banister anttih spwhitt nerium NikolajK Total_1mmersion MoALTz L8D stephenprobe terlar MrWoohoo SuneAlkaersig Beetny free_beard arj laar ht__th ninzine fragamus)
00:51:08 --- names: list (umbriel mkaesz Qfwfq phyrex1an myk__ ioanel ahihi danvet rejuvyes- phreedom alenn Rufflewind ifesdjeen aartamonau tommyliu MaximLacrima augur HugoDaniel NightRa ndrei robotbrain tolt thetallguy silat otulp y_gagar1n ThomasLocke fumieval sivteck Geekingfrog jedws wei2912 tvorog inr shintah imsc linduxed govg OlegYch Yarou sakiriou1 DTSCode Shin-LaC glosoli Plasmastar Rutger` hualet erikd adas solatis angerman samrat barx fraytorment-8368 amatsu jedai)
00:51:08 --- names: list (lightquake krgn_ vili mauke kcj dsantiago zinfandel darkbolt thomas glguy mitchty kadoban kyb3r_ otto_s_ zanchoPansa rtpg effy deevus_ shanse jordanl merijn ruuns_ wagle Guest83282 blizzy stefan_1_ jfischoff Kobata Guest34189 Draconx Haswell eisbehr lritter echo-area thunderrd rekahsoft FreeFull codygman beckyconning_ mceier nshepperd srhb channel_t Hermit meandi_1 dibblego Rastus_Vernon infinity0 tobik ddellacosta reizuki__ nonks athan Cale MP2E mrenaud)
00:51:08 --- names: list (ortmage Guest30206 amiri_ renzhi gienah sm desophos tg LordBrain plutoniix tvh predator217 tomboy64 ksf_ jdegoes dr__ rmorgan suls pyon morvkala oish klarrt kmicu Oksana XC flux s00pcan AbiBuccaneer Sgeo_ dpwright ryu91835 horlicks_ __jim__` troposol amosr moy coeus agumonkey SmileyKeith jamesf Denommus ivan\ intrados zenguine lifenoodles Church- Baluser DrCode segmond stojic Pamelloes crazydiamond r444 Tarbl anders0 stefan_1_|Work rufs pavonia cjenkin1)
00:51:08 --- names: list (Eagle_Erwin ThatOtherPerson __jim__ ruukasu conehead jnoah brunor kvitebjorn isomorphic byorgey jo__ swook nominolo shesek fiatjaf whaletechno gx^ dario greeny_ serge bgamari_ bgamari mithsv Philonous derekv Matrixman_217 cursork mcbonz julienXX Iceland_jack wires gniourf MitchW sinopeus nemesit|znc liuw andbroby jdiez lericson rudi_s itsmonktastic SoupEvil My_Hearing chpatrick kungp kakos cosmicexplorer bergey _ashbreeze_ Internet13 Khisanth micrypt)
00:51:08 --- names: list (only_the_bear jakutis bel3atar sdx23 mikeplus64 renekooi Stratege_ vjeranc etandel Reiser melter idoru skrio _flow_ o0oo0o_ zos haroldwu delhage martintrojer Polarina SwashBuckla elcheckito nkar Nickeeh Jaxan zwer apo MK_FG srcerer woky petermw Paks LnL luigy cdidd pyrtsa sea-gull yumike hackagebot alanz suvash_away wjlroe Svedrin fergusnoble himikof greymalkin orbital Boreeas usr pnielsen javex sohum mimi_vx codehero Edoxile drdo ]OLI[ theanalyst thirsteh)
00:51:08 --- names: list (Guest17603 gws BrianHV sellout jameseb Haskellfant christia` milli` eyck ToRA liyang_ Walther_ nilg eristic hmax_ mankyKitty saep casual korpse___ MMuse_____ Jaak nwf pharpend shelf zxtx dropdrive MrScout cbou chrisdotcode lambdabot tumdedum etabot juhp hiratara henrikhodne ForNeVeR PCChris carlosgaldino xinming Ralith apaku KitC profil naiyte joneshf-laptop Quackmatic Floyd_ lamilami joneshf butyoudonot CADD mrowe_away henk Arahael albeit dj_ryan)
00:51:08 --- names: list (SquareBracket d3lxa AntiSpamMeta _rgn Jello_Raptor integral shennyg____ biscarch johnw_ bjornars1 Saizan bcarrell raphie arun nmashton cojy rom1504 dkua aloiscochard Blkt rola flebron Preyer sh1ken_ ircbrows- RchrdB dlackty AleXoundOS Hijiri Guest20047 ellipsis_ paintcan shintahW DarkCthulhu yaopo k00mi ZsoL dolio YayMe gseitz nyuszika7h xpika kshannon tismith cjheath czaks vladan angelicstrike toors joe9 Oxyd stepcut klarh dabradley Dykam Zekka Vorpal)
00:51:08 --- names: list (goldfire Soft norcalli drbean krgn RayNbow`TU albel727 burp cscorley felixsch mecalopo1 juri_ janmuffino zyla bananagram Kabaka Boney Lindrian eamelink marvimias yogsototh dreixel lieven liamgoodacre Jonno_FTW ens taktoa lycide fikusz CindyLinz macalimlim gfixler_ dmead isenmann codeburg Rakkin jlyndon sweeney jabbslad_______ ReinH jonrh AlainODea_ Xarian ninegrid tomku Quashie Forkk_ Draggor Artpicre codyopel OceanSpray Nimatek thetallguy1 bydo janne)
00:51:08 --- names: list (stephenmac7 keltvek zmthy Axman6 davidthomas statusbot bbloom jedavis bb010g pjdelport miasma drewdavis Nivim lpaste mgaare phaskell tristero Meeh dodgems nomnomnomnomnom earthy def- gds exlevan fall_ diprosopus catsup kfish moop comboy nakal seangrove Talryn C4Cypher vsayer_ flyingfisch japesinator happy0 unsymbol Fistful_of_Coins keko-2 ludamad Maxdamantus Fullma sw1nn werdna uber BeardedCoder Cr8 estewei_off neptunepink davidfetter Bigcheese shiona)
00:51:08 --- names: list (LeaChim peterhil Adeon Chousuke andreass aleator iteratee shouya_ m4farrel redtricycle petercommand Fusxfaranto bsmt opqdonut mads- ciaranm c74d Kruppe ad Sornaensis Sonderblade dispersed Wamanuz Nik05 Farow ob Riviera orion dav1d chriswk____ _d3f akahn aristid_ blindscreen superjudge aristid ybit3 anry kloplop321 danking thamz ma82 ckw jrp6 belst andyt theshadow bkolera rfw caasihuang joshsz tarcwynne__ jdeeburke ZucchiniZe n1ftyn8 texasmynsted nathanic)
00:51:08 --- names: list (ibid Jellydog zph gregburd etrepum jonsterling alethea lohkey Sorella bgyss Taneb osfameron gfixler keaml qsuscs d-snp waynr hc znutar ft bmuk somenick_ tov wollw ccasin seagreen- Tene maurer zoglesby jlewis koninkje1away carter blenny periodic frogpunc_ WzC iross xeno falafel justin_smith brixen skarn cjwelborn mawuli vmesons akurilin lnostdal finnrobi canta brandonw Natch cmn Fuuzetsu perrier quaestor1 tromp_ ttuegel bolmar Brando753 ezrios hape01)
00:51:08 --- names: list (martingale boris`` sofancy_ dyreshark Eliel wormphlegm Cathy McManiaC si14 Plastefuchs monochrom seliopou mornfall zxq9 lenstr kalz marko ps-auxw fuziontech____ kjanosz dmbaturin mlh_ Excureo joeytwiddle StoneToad Gothmog_ rossberg V3ct0r larsen jrslepak noddy estulticia hamishmack monsieurp ByronJohnson qzzx yorick ValicekB antinode masse ananna Vbitz cschneid k4r1m sujeet mrpantoufle Nshag raek adamse heaumer Enigmagic charlie marvin-hh mach xandaros)
00:51:08 --- names: list (sross07 jayne przembot sssilver_ lucs laktech parallel21 agatam Profpatsch Keel rabisg luz1e avdi joedevivo myfreeweb aseidl Starfire ousado cfloare tv LordDeath helgar mak` __main__ Benzi-Junior acharles Spaceghost bjorkintosh _aegis_ ben__ cdk paz jlewis_ ChongLi ljhms felixn ormaaj zerokarmaleft silasm Xack mephx kipras`away edwardk tnks glowcoil FireFly xaimus vikraman thoughtpolice pp^ vobi dlundy jchia hpc mindCrime_ funrep_ mendez_ dowski__ julmac)
00:51:08 --- names: list (JamesJRH `0660 CosmicRay dmwit_ wto Lacriatch anders^^ Deewiant oberstein Nanar jmcarthur ernst Cerise SLi Aquana eazar001 ski tsani seubert David raid Kinnison amontez stbuehler yano dagle brisbin33 haasn int-e obiwahn zeroskillor cin alang tero- mattp_ _5kg shelling fvt jorj ilias jstolarek \q metaf5 teeteewhy Igloo rs0 divyanshu lurker6 jcp statusfailed Rembane Darkflux tdammers geal joelteon jpierre03 tawm relrod iron_houzi Twey ThePhoeron bitraten)
00:51:08 --- names: list (heurist capisce Yawgmoth vital jzl adimit gratimax TrafficMan tessier alinab Intensity jaffachief matthew- theorbtwo rak[1] flori eevar stomp l3kn ClaudiusMaximus l3dx npcomp Tesseraction chirpsalot sunfun Desoxy totte lattenwald marienz neena pqmodn_ xplat tridactyla pingu fling spacebug_ sshine Zariel Mokosha lahwran Tiktalik mgomezch sipa bjobjo nisstyre Scorchin Mortomes_ Transfusion Athas bcoppens Liskni_si ziman JPohlmann mgomes FCatalan` defanor)
00:51:08 --- names: list (yukonjack rbocquet troydm rhodesd rieper jrib srbaker bind sivoais ephemeron HylianSavior TDJACR NikolaiToryzin hongminhee ixian qwandor SegFaultAX Klumben sprang MiracleBlue cstrahan ocharles CARAM_ platinuum ehamberg jzelinskie m_george hellschreiber oldmanstanley___ lyxia mikeizbicki numberten jang andrewsw ldcn cyphase dqd smart_ptr stelleg badi` wtw callumacrae stass prinsen joehh jaspervdj naudiz elfangor betawaffle sleepynate robertm1 vukcrni)
00:51:08 --- names: list (gbarboza enomies timpani TakSuyu rmunroe petantik agrif wjm jasu0 Ornedan `bps CoverSlide bonobo andreypopp_ emmanueloga peder ggherdov Guest5708 asabil S11001001 supki Phillemann zq qz emaphis shepheb Fuco PierreM DanToml cryon yusukesuzuki KorriX adadad sbrg diginet Hodapp dsfox1 joeyh sordina3 vincom2 zymurgy Kneiva JRoberts_ levi slobo emma edk ryanakca jmct _ikke_ alphonse23_ kalail_ bra teehemkay sorind connerb tekacs DarkFox frawgie_ lpsmith)
00:51:08 --- names: list (dehflingus_ alpounet liif aupo pii zeiris_ Ferdirand benmachine krakrjak_ tazjin vlopez mike4 hbar tm512 mirsal SHODAN Willis petterw inuoppai fyolnish_ edran billymeter hpd Baughn _dyrim ilmig antoniy johnw PHO mountaingoat SaBer kav eikke mortberg gandr kandinski saurik pieter machineslearn asm89 Reyu annulus cowtown c-rog bergmark karls kini tromp eyenx joehillen Adios koala_man TallerGhostWalt stianhj AshyIsMe Watcher7 eyem sunnavy ahf lb5tr malglim)
00:51:08 --- names: list (oconnore barrucadu fall` newsham theDon adlan plhk michaelpj thorkilnaur knyppeldynan howard_ jackhill dju Dtgr nulpunkt dh spion yam tomprince davean dflemstr posco robbert kosmikus iulian zenzike arrdem abh Rylee coconnor xnyhps bbastian- Razz agundry elgot ndeine DustyDin1o mietek joefiorini mrkishi tlevine igniting Belgarion0 cods dhrosa elij bentley obcode kaol Drezil cinimod mgregson td123 rblackwe MagBo tippenein acfoltzer pygospa dv- yukko)
00:51:08 --- names: list (ChristianS deavid Na6hu7Ud dmilith ij zpconn__________ kirjs______ Logiar magicman cyanoacry ion bernalex dschoepe spaceships fryguybob noidi klugez dp_wiz_ hyPiRion eagleflo okic monty piskrist nitrix jonathanj dpn` pi8029 majoh geekosaur schlumpi iota_ s_e dilinger pmarreck dunj3 zomg froztbyte saati heyj Th0mas arch_ jroesch s4msung shapr mjrosenb Someguy123 franka Fubar^ Vq masak photex dan64 go|dfish indigo arianvp Laquendi heikkih shutdown_-h_now)
00:51:08 --- names: list (stiell jcurbo muricula Phlogistique honkfestival zrl dixie bartavelle u-ou Bane^ Hugglesworth joe_k nafis davesilva benzrf|offline deni noctux @ChanServ tomaw cpa_ Ke noplamodo gridaphobe mrd hsc mechairo` lolocaust abc56889 Hafydd bitemyapp kloeri zebr tych0 opto DigitalKiwi kgadek henrixh honza aleator_ swen ivan` phadej peddie qr42 solarus drone| absence mero knyon Harbinger Hardolaf SuperTux88 owa joachifm GaveUp hvr harski1 jlouis wting yeltzooo tstc)
00:51:08 --- names: list (so banyan Pad^ sclv saiam_ tassmjau phaazon Licenser mlen ggreg mrshoe benbangert claudiyoh irssi asjo mp roo natte clementd lispy DanZimm fds4345 cow-orke1 cynick [swift] sajith danneu stvc twopoint718 seanparsons _br_ wjt RevJohnnyHealey bvad kragniz shmookey btc_ amiller pikhq grohne serjeem_____ simpson GGMethos mitu qrada poucet Clint Cryovat Xorlev gargawel_ Laney pharaun idnar Ulrar lokydor Freundlich cross ThreeOfEight brackets mandu ephess)
00:51:08 --- names: list (scopedTV comma8 Martty nexion vermeille BlastHardcheese nick1234abcd adarc therealklanni Antoine59 XMunkki_ ParahSailin_ wayne joefiori_ joefiorini_ SethTisue_______ wizonesolutions mno2 eL_Bart0 chasecal1 senseibaka thebnq `micro sgronblo sddhrthrt M-ou-se mixi Raynos notdan hmot futureperfect edwtjo fold larrytheliquid__ Ezku joshc hiredman sviterok mathu Tehnix frontendloader mmaruseacph2 ido drewr ozzymcduff taruti luite mami dawik boegel|work Lutin`)
00:51:08 --- names: list (c9sould_ hguux lacrosse__ kwantam tomejaguar_away Dashkal hegge Gracenotes pdxleif hopnotch averell otterdam pm5 myme jrw bens TheMoonMaster puzza007 dstockwell LQDHelium mrb_bk T_X_ leifw mokus nesqi_ owlglass2 blast_hardcheese dogmaT_ bbee lassulus bastian__ Kaini pfoetchen jix kaiza ivoscc dustinswan solirc zalami staffehn bcap_zZz friden qtplatypus Dodek JZTech101 ajcoppa ktosiek funrep runde cjay Ptival spindas gidogeek)
00:51:52 <Arahael> It's remarkably imprecise on linux, it seems. :/ System.CPUTime.cpuTimePrecision -> 10000000000
00:54:30 <Arahael> Equal to 1 nanosecond, so not bad.
00:54:45 <Arahael> osa1: One trap: CPUTime is not user time.
00:58:40 <Walter_> Am I right in saying that these two snippets are relatively the same? http://lpaste.net/114151
01:00:47 <dibblego> Walter_: no, the second one reuses the name (xs) to mean the entire list, while the first uses (x) and (xs) to mean the first element and the rest of the list.
01:01:01 <Walter_> Oh okay
01:01:26 <Walter_> But they both match the pattern of an empty list, yeah?
01:01:51 <merijn> Walter_: the first cases, yes
01:02:09 <merijn> Walter_: They would be the same if you replace line 6 with "(x:xs) -> --stuff"
01:02:19 <Walter_> That makes sense
01:02:35 <Walter_> Is it possible to rewrite the equivalent statement using guards?
01:02:58 <merijn> Walter_: Yes, but it'd be awful
01:03:25 <Walter_> Could you show me just as an educational exercise?
01:04:32 <merijn> Actually, not quite identical
01:04:55 <Walter_> Oh?
01:05:05 <Walther_> Huh?
01:05:05 <merijn> Walter_: http://lpaste.net/114151
01:05:22 <merijn> Walter_: You need to rename "xs" to "xs'" in --stuff
01:05:37 <merijn> The naive "xs = tail xs" actually does something else entirely
01:06:02 <merijn> > let xs = [1..5] in let xs = tail xs in xs -- whoo! confusing!
01:06:06 <lambdabot>  mueval-core: Time limit exceeded
01:06:40 <merijn> Walter_: 'xs' is the infinite loop of "taking the tail"
01:06:54 <merijn> Basically, the same thing as happens with
01:07:00 <merijn> > let ones = 1 : ones in ones
01:07:01 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
01:07:15 <merijn> Renaming xs to xs' in my example avoids that sna
01:07:17 <merijn> *snag
01:07:27 <Walter_> That makes sense
01:17:45 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org'
01:17:45 --- topic: set by glguy on [Thu Sep 25 17:55:19 2014]
01:17:45 --- names: list (clog tommyliu Gurkenglas vlatkoB pantsman exio4 michaelneale etehtsea tommyliu_ nerium ollef NikolajK felixn JamesJRH petersr eatman jTT_ Swizec mattyw rgr t7 Dolphr darthdeus oliverz mthvedt {AS} tinyblak fujimura detrumi redeemed structuralist Walter_ Lethalman jkarni1 msgodf Argue arenz martianboy clauswitt takuan pa3ce jle` AfC folone elfenlaid seveg ventonegro osa1 srenatus royadav centrinia zorg24 biglama calvinx gratimax_ slomo Reite jutaro hebz0rl)
01:17:45 --- names: list (rshetty caumeslasal insitu raichoo banister anttih spwhitt MoALTz L8D stephenprobe terlar MrWoohoo SuneAlkaersig Beetny free_beard ht__th ninzine fragamus umbriel mkaesz Qfwfq phyrex1an myk__ ioanel ahihi danvet rejuvyes- phreedom alenn Rufflewind ifesdjeen aartamonau MaximLacrima augur HugoDaniel NightRa ndrei robotbrain tolt thetallguy otulp y_gagar1n ThomasLocke fumieval sivteck Geekingfrog jedws wei2912 tvorog inr shintah imsc linduxed govg OlegYch)
01:17:45 --- names: list (Yarou sakiriou1 DTSCode Shin-LaC glosoli Plasmastar Rutger` hualet erikd adas solatis angerman samrat barx fraytorment-8368 amatsu jedai lightquake krgn_ vili mauke kcj dsantiago zinfandel darkbolt thomas glguy mitchty kadoban kyb3r_ otto_s_ zanchoPansa rtpg effy deevus_ shanse jordanl merijn ruuns_ wagle Guest83282 blizzy stefan_1_ jfischoff Kobata Guest34189 Draconx Haswell eisbehr lritter echo-area thunderrd rekahsoft FreeFull codygman beckyconning_)
01:17:45 --- names: list (mceier nshepperd srhb channel_t Hermit meandi_1 dibblego Rastus_Vernon infinity0 tobik ddellacosta reizuki__ athan Cale MP2E ortmage Guest30206 amiri_ renzhi gienah sm desophos tg LordBrain plutoniix tvh predator217 tomboy64 ksf_ jdegoes dr__ rmorgan suls pyon morvkala oish klarrt kmicu Oksana XC flux s00pcan AbiBuccaneer Sgeo_ dpwright ryu91835 horlicks_ __jim__` troposol amosr moy coeus agumonkey SmileyKeith jamesf Denommus ivan\ intrados zenguine)
01:17:45 --- names: list (lifenoodles Church- Baluser DrCode segmond stojic Pamelloes crazydiamond r444 Tarbl anders0 stefan_1_|Work rufs pavonia cjenkin1 Eagle_Erwin ThatOtherPerson __jim__ ruukasu conehead jnoah brunor kvitebjorn isomorphic byorgey jo__ swook nominolo shesek fiatjaf whaletechno gx^ dario greeny_ serge bgamari_ bgamari mithsv Philonous derekv Matrixman_217 cursork mcbonz julienXX Iceland_jack wires gniourf MitchW sinopeus nemesit|znc liuw andbroby jdiez lericson)
01:17:45 --- names: list (rudi_s itsmonktastic SoupEvil My_Hearing chpatrick kungp kakos cosmicexplorer bergey _ashbreeze_ Internet13 Khisanth micrypt only_the_bear jakutis bel3atar sdx23 mikeplus64 renekooi Stratege_ vjeranc etandel Reiser melter idoru skrio _flow_ o0oo0o_ zos haroldwu delhage martintrojer Polarina SwashBuckla elcheckito nkar Nickeeh Jaxan zwer apo MK_FG srcerer woky petermw Paks LnL luigy cdidd pyrtsa sea-gull yumike hackagebot alanz suvash_away wjlroe Svedrin)
01:17:45 --- names: list (fergusnoble himikof greymalkin orbital Boreeas usr pnielsen javex sohum mimi_vx codehero Edoxile drdo ]OLI[ theanalyst thirsteh Guest17603 gws BrianHV sellout jameseb Haskellfant christia` milli` eyck ToRA liyang_ Walther nilg eristic hmax_ mankyKitty saep casual korpse___ MMuse_____ Jaak nwf pharpend shelf zxtx dropdrive MrScout cbou chrisdotcode lambdabot tumdedum etabot juhp hiratara henrikhodne ForNeVeR PCChris carlosgaldino xinming Ralith apaku KitC)
01:17:45 --- names: list (profil naiyte joneshf-laptop Quackmatic Floyd_ lamilami joneshf butyoudonot CADD mrowe_away henk Arahael albeit dj_ryan SquareBracket d3lxa AntiSpamMeta _rgn Jello_Raptor integral shennyg____ biscarch johnw_ bjornars1 Saizan bcarrell raphie arun nmashton cojy rom1504 dkua aloiscochard Blkt rola flebron Preyer sh1ken_ ircbrows- RchrdB dlackty AleXoundOS Hijiri Guest20047 ellipsis_ paintcan shintahW DarkCthulhu yaopo k00mi ZsoL dolio YayMe gseitz nyuszika7h)
01:17:45 --- names: list (xpika kshannon tismith cjheath czaks vladan angelicstrike toors joe9 Oxyd stepcut klarh dabradley Dykam Zekka Vorpal goldfire Soft norcalli drbean krgn RayNbow`TU albel727 burp cscorley felixsch mecalopo1 juri_ janmuffino zyla bananagram Kabaka Boney Lindrian eamelink marvimias yogsototh dreixel lieven liamgoodacre Jonno_FTW ens taktoa lycide fikusz CindyLinz macalimlim gfixler_ dmead isenmann codeburg Rakkin jlyndon sweeney jabbslad_______ ReinH jonrh)
01:17:45 --- names: list (AlainODea_ Xarian ninegrid tomku Quashie Forkk_ Draggor Artpicre codyopel OceanSpray Nimatek thetallguy1 bydo janne stephenmac7 keltvek zmthy Axman6 davidthomas statusbot bbloom jedavis bb010g pjdelport miasma drewdavis Nivim lpaste mgaare phaskell tristero Meeh dodgems nomnomnomnomnom earthy def- gds exlevan fall_ diprosopus catsup kfish moop comboy nakal seangrove Talryn C4Cypher vsayer_ flyingfisch japesinator happy0 unsymbol Fistful_of_Coins keko-2)
01:17:45 --- names: list (ludamad Maxdamantus Fullma sw1nn werdna uber BeardedCoder Cr8 estewei_off neptunepink davidfetter Bigcheese shiona LeaChim peterhil Adeon Chousuke andreass aleator iteratee shouya_ m4farrel redtricycle petercommand Fusxfaranto bsmt opqdonut mads- ciaranm c74d Kruppe ad Sornaensis Sonderblade dispersed Wamanuz Nik05 Farow ob Riviera orion dav1d chriswk____ _d3f akahn aristid_ blindscreen superjudge aristid ybit3 anry kloplop321 danking thamz ma82 ckw jrp6)
01:17:45 --- names: list (belst andyt theshadow bkolera rfw caasihuang joshsz tarcwynne__ jdeeburke ZucchiniZe n1ftyn8 texasmynsted nathanic ibid Jellydog zph gregburd etrepum jonsterling alethea lohkey Sorella bgyss Taneb osfameron gfixler keaml qsuscs d-snp waynr hc znutar ft bmuk somenick_ tov wollw ccasin seagreen- Tene maurer zoglesby jlewis koninkje1away carter blenny periodic frogpunc WzC iross xeno falafel justin_smith brixen skarn cjwelborn mawuli vmesons akurilin lnostdal)
01:17:45 --- names: list (finnrobi canta brandonw Natch cmn Fuuzetsu perrier quaestor1 tromp_ ttuegel bolmar Brando753 ezrios hape01 martingale boris`` sofancy_ dyreshark Eliel wormphlegm Cathy McManiaC si14 Plastefuchs monochrom seliopou mornfall zxq9 lenstr kalz marko ps-auxw fuziontech____ kjanosz dmbaturin mlh_ Excureo joeytwiddle StoneToad Gothmog_ rossberg V3ct0r larsen jrslepak noddy estulticia hamishmack monsieurp ByronJohnson qzzx yorick ValicekB antinode masse ananna)
01:17:45 --- names: list (Vbitz cschneid k4r1m sujeet mrpantoufle Nshag raek adamse heaumer Enigmagic charlie marvin-hh mach xandaros sross07 jayne przembot sssilver_ lucs laktech parallel21 agatam Profpatsch Keel rabisg luz1e avdi joedevivo myfreeweb aseidl Starfire ousado cfloare tv LordDeath helgar mak` __main__ Benzi-Junior acharles Spaceghost bjorkintosh _aegis_ ben__ cdk paz jlewis_ ChongLi ljhms ormaaj zerokarmaleft silasm Xack mephx kipras`away edwardk tnks glowcoil FireFly)
01:17:45 --- names: list (xaimus vikraman thoughtpolice pp^ vobi dlundy jchia hpc mindCrime_ funrep_ mendez_ dowski__ julmac `0660 CosmicRay dmwit_ wto Lacriatch anders^^ Deewiant oberstein Nanar jmcarthur ernst Cerise SLi Aquana eazar001 ski tsani seubert David raid Kinnison amontez stbuehler yano dagle brisbin33 haasn int-e obiwahn zeroskillor cin alang tero- mattp_ shelling fvt jorj jstolarek \q metaf5 teeteewhy Igloo rs0 divyanshu lurker6 jcp statusfailed Rembane Darkflux)
01:17:45 --- names: list (tdammers geal joelteon jpierre03 tawm relrod iron_houzi Twey ThePhoeron bitraten heurist capisce Yawgmoth vital jzl adimit gratimax TrafficMan tessier alinab Intensity jaffachief matthew- theorbtwo rak[1] flori eevar stomp l3kn ClaudiusMaximus l3dx npcomp Tesseraction chirpsalot sunfun Desoxy totte lattenwald marienz neena pqmodn_ xplat tridactyla pingu fling spacebug_ sshine Zariel Mokosha lahwran Tiktalik mgomezch sipa bjobjo nisstyre Scorchin Mortomes_)
01:17:45 --- names: list (Transfusion Athas bcoppens Liskni_si ziman JPohlmann mgomes FCatalan` defanor yukonjack rbocquet troydm rhodesd rieper jrib srbaker bind sivoais ephemeron HylianSavior TDJACR NikolaiToryzin hongminhee ixian qwandor SegFaultAX Klumben sprang MiracleBlue cstrahan ocharles CARAM_ platinuum ehamberg jzelinskie m_george hellschreiber oldmanstanley___ lyxia mikeizbicki numberten jang andrewsw ldcn cyphase dqd smart_ptr stelleg badi` wtw callumacrae stass prinsen)
01:17:45 --- names: list (joehh jaspervdj naudiz elfangor betawaffle sleepynate robertm1 vukcrni gbarboza enomies timpani TakSuyu rmunroe petantik agrif wjm jasu0 Ornedan `bps CoverSlide bonobo andreypopp_ emmanueloga peder ggherdov Guest5708 asabil S11001001 supki Phillemann zq qz emaphis shepheb Fuco PierreM DanToml cryon yusukesuzuki KorriX adadad sbrg diginet Hodapp dsfox1 joeyh sordina3 vincom2 zymurgy Kneiva JRoberts_ levi slobo emma edk ryanakca jmct _ikke_ alphonse23_)
01:17:45 --- names: list (kalail_ bra teehemkay sorind connerb tekacs DarkFox frawgie_ lpsmith dehflingus_ alpounet liif aupo pii zeiris_ Ferdirand benmachine krakrjak_ tazjin vlopez mike4 hbar tm512 mirsal SHODAN Willis petterw inuoppai fyolnish_ edran billymeter hpd Baughn _dyrim ilmig antoniy johnw PHO mountaingoat SaBer kav eikke mortberg gandr kandinski saurik pieter machineslearn asm89 Reyu annulus cowtown c-rog bergmark karls kini tromp eyenx joehillen Adios koala_man)
01:17:45 --- names: list (TallerGhostWalt stianhj AshyIsMe Watcher7 eyem sunnavy ahf lb5tr malglim oconnore barrucadu fall` newsham theDon adlan plhk michaelpj thorkilnaur knyppeldynan howard_ jackhill dju Dtgr nulpunkt dh spion yam tomprince davean dflemstr posco robbert kosmikus iulian zenzike arrdem abh Rylee coconnor xnyhps bbastian- Razz agundry elgot ndeine DustyDin1o mietek joefiorini mrkishi tlevine igniting Belgarion0 cods dhrosa elij bentley obcode kaol Drezil cinimod)
01:17:45 --- names: list (mgregson td123 rblackwe MagBo tippenein acfoltzer pygospa dv- yukko ChristianS deavid Na6hu7Ud dmilith ij zpconn__________ kirjs______ Logiar magicman cyanoacry ion bernalex dschoepe spaceships fryguybob noidi klugez dp_wiz_ hyPiRion eagleflo okic monty piskrist nitrix jonathanj dpn` pi8029 majoh geekosaur schlumpi iota_ s_e dilinger pmarreck dunj3 zomg froztbyte saati heyj Th0mas arch_ jroesch s4msung shapr mjrosenb Someguy123 franka Fubar^ Vq masak)
01:17:45 --- names: list (photex dan64 go|dfish indigo arianvp Laquendi heikkih shutdown_-h_now stiell jcurbo muricula Phlogistique honkfestival zrl dixie bartavelle u-ou Bane^ Hugglesworth joe_k nafis davesilva benzrf|offline deni noctux @ChanServ tomaw cpa_ Ke noplamodo gridaphobe mrd hsc mechairo` lolocaust abc56889 Hafydd bitemyapp kloeri zebr tych0 opto DigitalKiwi kgadek henrixh honza aleator_ swen ivan` phadej peddie qr42 solarus drone| absence mero knyon Harbinger Hardolaf)
01:17:45 --- names: list (SuperTux88 owa joachifm GaveUp hvr harski1 jlouis wting yeltzooo tstc so banyan Pad^ sclv saiam_ tassmjau phaazon Licenser mlen ggreg mrshoe benbangert claudiyoh irssi asjo mp roo natte clementd lispy DanZimm fds4345 cow-orke1 cynick [swift] sajith danneu stvc twopoint718 seanparsons _br_ wjt RevJohnnyHealey bvad kragniz shmookey btc_ amiller pikhq grohne serjeem_____ simpson GGMethos mitu qrada poucet Clint Cryovat Xorlev gargawel_ Laney pharaun idnar)
01:17:45 --- names: list (Ulrar lokydor Freundlich cross ThreeOfEight brackets mandu ephess scopedTV comma8 Martty nexion vermeille BlastHardcheese nick1234abcd adarc therealklanni Antoine59 XMunkki_ ParahSailin_ wayne joefiori_ joefiorini_ SethTisue_______ wizonesolutions mno2 eL_Bart0 chasecal1 senseibaka thebnq `micro sgronblo sddhrthrt M-ou-se mixi Raynos notdan hmot futureperfect edwtjo fold larrytheliquid__ Ezku joshc hiredman sviterok mathu Tehnix frontendloader mmaruseacph2)
01:17:45 --- names: list (ido drewr ozzymcduff taruti luite mami dawik boegel|work Lutin` c9sould_ hguux lacrosse__ kwantam tomejaguar_away Dashkal hegge Gracenotes pdxleif hopnotch averell otterdam pm5 myme jrw bens TheMoonMaster puzza007 dstockwell LQDHelium mrb_bk T_X_ leifw mokus nesqi_ owlglass2 blast_hardcheese dogmaT_ bbee lassulus bastian__ Kaini pfoetchen jix kaiza ivoscc dustinswan solirc zalami staffehn bcap_zZz friden qtplatypus Dodek JZTech101 ajcoppa ktosiek funrep)
01:17:45 --- names: list (runde cjay Ptival spindas gidogeek)
03:21:37 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org'
03:21:37 --- topic: set by glguy on [Thu Sep 25 17:55:19 2014]
03:21:37 --- names: list (clog johtso YurasS adas1 jkarni2 Johannes13 flyhigh jkarni pppp2 jetho deevus bb6xt michael-k slogsdon mjs2600 ikkebr wei2912 anttih samrat agjacome bjz michaelneale nerium bitonic jfischoff jlamothe_ Swizec ollef zwer_l matilak tonbo mkster tinyblak silver dcoutts dcoutts_ nilg Nizumzen ioanel Tokenizer dreixel netogallo pdpi Thhethssmuz bezirg umbriel caumeslasal1 folone lsix Rutger` oish_ komarov dr_ justanr Pucilowski marr c74d C4Cypher tech2_ banister)
03:21:37 --- names: list (Mortomes_ joe9 vijaykiran Sebastien-L vietnguyen sbjorn PragCypher vixlur eisbehr LeoTal cognominal tlbakh rodlogic code_pod eatman aarvar yfeldblum Swenn sinelaw sopvop nshepperd BoR0 SoupE killerswan djcoin arnihr_ Gurkenglas pantsman exio4 NikolajK felixn JamesJRH petersr mattyw rgr t7 {AS} detrumi redeemed Lethalman msgodf Argue arenz martianboy clauswitt takuan pa3ce jle` elfenlaid seveg ventonegro srenatus royadav centrinia biglama gratimax_ slomo Reite)
03:21:37 --- names: list (jutaro hebz0rl rshetty raichoo spwhitt MoALTz L8D terlar MrWoohoo Beetny free_beard ht__th ninzine fragamus mkaesz Qfwfq phyrex1an myk__ ahihi danvet rejuvyes- phreedom alenn Rufflewind MaximLacrima augur HugoDaniel NightRa ndrei robotbrain tolt thetallguy otulp ThomasLocke sivteck tvorog inr shintah linduxed govg OlegYch Yarou sakiriou1 DTSCode Shin-LaC Plasmastar hualet erikd adas angerman barx fraytorment-8368 amatsu jedai lightquake vili mauke dsantiago)
03:21:37 --- names: list (zinfandel darkbolt thomas glguy mitchty kadoban otto_s_ zanchoPansa effy shanse jordanl ruuns_ wagle Guest83282 blizzy stefan_1_ Kobata Guest34189 Draconx Haswell lritter thunderrd FreeFull codygman mceier srhb channel_t Hermit meandi_1 dibblego infinity0 tobik ddellacosta reizuki__ athan Cale MP2E ortmage amiri_ renzhi gienah sm desophos tg LordBrain tvh predator217 tomboy64 ksf_ jdegoes dr__ rmorgan pyon morvkala oish klarrt kmicu Oksana XC flux s00pcan)
03:21:37 --- names: list (AbigailBuccaneer Sgeo_ ryu91835 horlicks_ __jim__` troposol moy coeus agumonkey SmileyKeith jamesf Denommus ivan\ intrados zenguine lifenoodles Church- Baluser DrCode segmond stojic Pamelloes crazydiamond r444 anders0 stefan_1_|Work rufs pavonia cjenkin1 Eagle_Erwin ThatOtherPerson __jim__ ruukasu conehead jnoah brunor kvitebjorn isomorphic byorgey jo__ swook nominolo shesek fiatjaf whaletechno gx^ dario greeny_ bgamari_ bgamari mithsv Philonous derekv)
03:21:37 --- names: list (Matrixman_217 cursork mcbonz julienXX Iceland_jack wires gniourf MitchW sinopeus nemesit|znc liuw andbroby jdiez lericson rudi_s itsmonktastic My_Hearing chpatrick kungp kakos cosmicexplorer bergey _ashbreeze_ Internet13 Khisanth micrypt only_the_bear jakutis bel3atar sdx23 mikeplus64 renekooi Stratege_ vjeranc etandel Reiser melter idoru skrio _flow_ o0oo0o_ zos haroldwu delhage martintrojer Polarina SwashBuckla elcheckito nkar Nickeeh Jaxan apo MK_FG srcerer)
03:21:37 --- names: list (woky petermw Paks LnL luigy cdidd pyrtsa sea-gull yumike hackagebot alanz suvash_away wjlroe Svedrin fergusnoble himikof greymalkin orbital Boreeas usr pnielsen javex sohum mimi_vx codehero Edoxile drdo ]OLI[ theanalyst thirsteh Guest17603 gws BrianHV sellout jameseb Haskellfant christia` milli` eyck ToRA liyang_ Walther eristic hmax_ mankyKitty saep casual korpse___ MMuse_____ Jaak nwf pharpend shelf zxtx dropdrive MrScout cbou chrisdotcode lambdabot tumdedum)
03:21:37 --- names: list (etabot juhp hiratara henrikhodne ForNeVeR PCChris carlosgaldino xinming Ralith apaku KitC profil naiyte joneshf-laptop Quackmatic Floyd_ lamilami joneshf butyoudonot CADD mrowe_away henk Arahael albeit dj_ryan SquareBracket d3lxa AntiSpamMeta _rgn Jello_Raptor integral shennyg____ biscarch johnw_ bjornars1 Saizan bcarrell raphie arun nmashton cojy rom1504 dkua aloiscochard Blkt rola flebron Preyer sh1ken_ ircbrows- RchrdB dlackty AleXoundOS Hijiri Guest20047)
03:21:37 --- names: list (ellipsis_ paintcan shintahW DarkCthulhu yaopo k00mi ZsoL dolio YayMe gseitz nyuszika7h xpika kshannon tismith cjheath vladan angelicstrike toors Oxyd stepcut klarh dabradley Dykam Zekka Vorpal goldfire Soft norcalli drbean krgn RayNbow`TU albel727 burp cscorley felixsch mecalopo1 juri_ janmuffino zyla bananagram Kabaka Boney Lindrian eamelink marvimias yogsototh lieven liamgoodacre Jonno_FTW ens taktoa lycide fikusz CindyLinz macalimlim gfixler_ dmead isenmann)
03:21:37 --- names: list (codeburg Rakkin jlyndon sweeney jabbslad_______ ReinH jonrh AlainODea_ Xarian ninegrid tomku Quashie Forkk_ Draggor Artpicre OceanSpray Nimatek thetallguy1 bydo janne stephenmac7 keltvek zmthy Axman6 davidthomas statusbot bbloom jedavis bb010g pjdelport miasma drewdavis Nivim lpaste mgaare phaskell tristero Meeh dodgems nomnomnomnomnom earthy def- gds exlevan fall_ diprosopus catsup kfish moop comboy nakal seangrove Talryn vsayer_ flyingfisch japesinator)
03:21:37 --- names: list (happy0 unsymbol Fistful_of_Coins keko-2 ludamad Maxdamantus Fullma sw1nn werdna uber BeardedCoder Cr8 estewei_off neptunepink davidfetter Bigcheese shiona LeaChim peterhil Adeon Chousuke andreass aleator iteratee shouya_ m4farrel redtricycle petercommand Fusxfaranto bsmt opqdonut mads- ciaranm Kruppe ad Sornaensis Sonderblade dispersed Wamanuz Nik05 Farow ob Riviera orion dav1d chriswk____ _d3f akahn aristid_ blindscreen superjudge aristid ybit3 anry)
03:21:37 --- names: list (kloplop321 danking thamz ma82 ckw jrp6 belst andyt theshadow bkolera rfw caasihuang joshsz tarcwynne__ jdeeburke ZucchiniZe n1ftyn8 texasmynsted nathanic ibid Jellydog zph gregburd etrepum jonsterling alethea lohkey Sorella bgyss Taneb osfameron gfixler keaml qsuscs d-snp waynr hc znutar ft bmuk somenick_ tov wollw ccasin seagreen- Tene maurer zoglesby jlewis koninkje1away carter blenny periodic frogpunc WzC iross xeno falafel justin_smith brixen skarn)
03:21:37 --- names: list (cjwelborn mawuli vmesons akurilin lnostdal finnrobi canta brandonw Natch cmn Fuuzetsu perrier quaestor1 tromp_ ttuegel bolmar Brando753 ezrios hape01 martingale boris`` sofancy_ dyreshark Eliel wormphlegm Cathy McManiaC si14 Plastefuchs monochrom seliopou mornfall zxq9 lenstr kalz marko ps-auxw fuziontech____ kjanosz dmbaturin mlh_ Excureo joeytwiddle StoneToad Gothmog_ rossberg V3ct0r larsen jrslepak noddy estulticia hamishmack monsieurp ByronJohnson qzzx)
03:21:37 --- names: list (yorick ValicekB antinode masse ananna Vbitz cschneid k4r1m sujeet mrpantoufle Nshag raek adamse heaumer Enigmagic charlie marvin-hh mach xandaros sross07 jayne przembot sssilver_ lucs laktech parallel21 agatam Profpatsch Keel rabisg luz1e avdi joedevivo myfreeweb aseidl Starfire ousado cfloare tv LordDeath helgar mak` __main__ Benzi-Junior acharles Spaceghost bjorkintosh _aegis_ ben__ cdk paz jlewis_ ChongLi ljhms ormaaj zerokarmaleft silasm Xack mephx)
03:21:37 --- names: list (kipras`away edwardk tnks glowcoil FireFly xaimus vikraman thoughtpolice pp^ vobi dlundy jchia hpc mindCrime_ funrep_ mendez_ dowski__ julmac `0660 CosmicRay dmwit_ wto Lacriatch anders^^ Deewiant oberstein Nanar jmcarthur ernst Cerise SLi Aquana eazar001 ski tsani seubert David raid Kinnison amontez stbuehler yano dagle brisbin33 haasn int-e obiwahn zeroskillor cin alang tero- mattp_ shelling fvt jorj jstolarek \q metaf5 teeteewhy Igloo rs0 divyanshu lurker6)
03:21:37 --- names: list (jcp statusfailed Rembane Darkflux tdammers geal joelteon jpierre03 tawm relrod iron_houzi Twey ThePhoeron bitraten heurist capisce Yawgmoth vital jzl adimit gratimax TrafficMan tessier alinab Intensity jaffachief matthew- theorbtwo rak[1] flori eevar stomp l3kn ClaudiusMaximus l3dx npcomp Tesseraction chirpsalot sunfun Desoxy totte lattenwald marienz neena pqmodn_ xplat tridactyla pingu fling spacebug_ sshine Zariel Mokosha lahwran Tiktalik mgomezch sipa)
03:21:37 --- names: list (bjobjo nisstyre Scorchin Transfusion Athas bcoppens Liskni_si ziman JPohlmann mgomes FCatalan` defanor yukonjack rbocquet troydm rhodesd rieper jrib srbaker bind sivoais ephemeron HylianSavior TDJACR NikolaiToryzin hongminhee ixian qwandor SegFaultAX Klumben sprang MiracleBlue cstrahan ocharles CARAM_ platinuum ehamberg jzelinskie m_george hellschreiber oldmanstanley___ lyxia mikeizbicki numberten jang andrewsw ldcn dqd smart_ptr stelleg badi` wtw callumacrae)
03:21:37 --- names: list (stass prinsen joehh jaspervdj naudiz elfangor betawaffle sleepynate robertm1 vukcrni gbarboza enomies timpani TakSuyu rmunroe petantik agrif wjm jasu0 Ornedan `bps CoverSlide bonobo andreypopp_ emmanueloga peder ggherdov Guest5708 asabil S11001001 supki Phillemann zq qz emaphis shepheb Fuco PierreM DanToml cryon yusukesuzuki KorriX adadad sbrg diginet Hodapp dsfox1 joeyh sordina3 vincom2 zymurgy Kneiva JRoberts_ levi slobo emma edk ryanakca jmct _ikke_)
03:21:37 --- names: list (alphonse23_ kalail_ bra teehemkay sorind connerb tekacs DarkFox frawgie_ lpsmith dehflingus_ alpounet liif aupo pii zeiris_ Ferdirand benmachine krakrjak_ tazjin vlopez mike4 hbar tm512 mirsal SHODAN Willis petterw inuoppai fyolnish_ edran billymeter hpd Baughn _dyrim ilmig antoniy johnw PHO mountaingoat SaBer kav eikke mortberg gandr kandinski saurik pieter machineslearn asm89 Reyu annulus cowtown c-rog bergmark karls kini tromp eyenx joehillen Adios)
03:21:37 --- names: list (koala_man TallerGhostWalt stianhj AshyIsMe Watcher7 eyem sunnavy ahf lb5tr malglim oconnore barrucadu fall` newsham theDon coconnor xnyhps bbastian- Razz agundry elgot ndeine DustyDin1o mietek joefiorini mrkishi tlevine igniting Belgarion0 cods dhrosa elij bentley obcode kaol Drezil cinimod mgregson td123 rblackwe MagBo tippenein acfoltzer pygospa dv- yukko ChristianS deavid Na6hu7Ud dmilith ij zpconn__________ kirjs______ Logiar magicman cyanoacry ion)
03:21:37 --- names: list (bernalex dschoepe spaceships fryguybob noidi klugez dp_wiz_ hyPiRion eagleflo okic monty piskrist nitrix jonathanj dpn` pi8029 majoh geekosaur schlumpi iota_ s_e dilinger pmarreck dunj3 zomg froztbyte saati heyj Th0mas arch_ jroesch s4msung shapr mjrosenb Someguy123 franka Fubar^ Vq masak photex dan64 go|dfish indigo arianvp Laquendi heikkih shutdown_-h_now stiell jcurbo muricula Phlogistique honkfestival zrl dixie bartavelle u-ou Bane^ Hugglesworth joe_k)
03:21:37 --- names: list (nafis davesilva benzrf|offline deni noctux gidogeek spindas Ptival cjay runde funrep ktosiek ajcoppa JZTech101 Dodek qtplatypus friden bcap_zZz staffehn zalami solirc dustinswan ivoscc kaiza jix pfoetchen Kaini bastian__ lassulus bbee dogmaT_ owlglass2 nesqi_ mokus leifw T_X_ mrb_bk LQDHelium dstockwell puzza007 TheMoonMaster bens jrw myme pm5 otterdam averell hopnotch pdxleif Gracenotes hegge Dashkal tomejaguar_away kwantam lacrosse__ hguux c9sould_ Lutin`)
03:21:37 --- names: list (boegel|work dawik mami luite taruti ozzymcduff drewr ido mmaruseacph2 frontendloader Tehnix mathu sviterok hiredman joshc Ezku larrytheliquid__ fold edwtjo futureperfect hmot notdan Raynos mixi M-ou-se sddhrthrt sgronblo `micro thebnq senseibaka chasecal1 eL_Bart0 mno2 wizonesolutions SethTisue_______ joefiorini_ joefiori_ wayne ParahSailin_ XMunkki_ Antoine59 therealklanni adarc nick1234abcd BlastHardcheese vermeille nexion Martty comma8 scopedTV ephess mandu)
03:21:37 --- names: list (brackets ThreeOfEight cross Freundlich lokydor Ulrar idnar pharaun Laney gargawel_ Xorlev Cryovat Clint poucet qrada mitu GGMethos simpson serjeem_____ grohne pikhq amiller btc_ shmookey kragniz bvad RevJohnnyHealey wjt _br_ seanparsons twopoint718 stvc danneu sajith [swift] cynick cow-orke1 fds4345 DanZimm lispy clementd natte roo mp asjo irssi claudiyoh benbangert mrshoe ggreg mlen Licenser phaazon tassmjau saiam_ sclv Pad^ banyan so tstc yeltzooo wting)
03:21:37 --- names: list (jlouis harski1 hvr GaveUp joachifm owa SuperTux88 Hardolaf Harbinger knyon mero absence drone| solarus qr42 peddie phadej ivan` swen aleator_ honza henrixh kgadek DigitalKiwi opto tych0 zebr kloeri bitemyapp Hafydd abc56889 lolocaust mechairo` hsc mrd gridaphobe noplamodo Ke cpa_ tomaw @ChanServ Rylee abh arrdem zenzike iulian kosmikus robbert posco dflemstr davean tomprince yam spion dh nulpunkt Dtgr dju jackhill howard_ knyppeldynan thorkilnaur michaelpj)
03:21:37 --- names: list (plhk adlan)
03:26:46 * hackagebot parsek 1.0.1 - Parallel Parsing Processes  http://hackage.haskell.org/package/parsek-1.0.1 (JeanPhilippeBernardy)
03:44:40 <zipper> How do I maintain the spacing in a JSON file after I am done parsing? Like when I parse and write to a file it doesn't look neat.
03:45:15 <zipper> How do I make my JSON files look neat? I read in a neat file but when I write there are no newlines spaces etc.
03:45:28 <Kinnison> JSON, YAML, etc are typically not easy to read/process/write in a way that maintains whitespace and layout
03:45:29 <osa1> any ideas about this http://lpaste.net/114161 ?
03:45:45 <zipper> Kinnison: :(
03:45:45 <tdammers> Kinnison: not maintain, but pretty-printing is possible
03:46:12 <zipper> tdammers: How?
03:48:14 <tdammers> I think there's a pretty-printer somewhere on hackage, can't remember though
03:48:26 <tdammers> lunchtime... ping me in maybe 45 minutes or so and I might take a look
03:49:34 <Kinnison> http://hackage.haskell.org/package/aeson-pretty maybe
04:02:42 <prinsen> Is there any way to express that two type variables cant tbe the same in an class instantiation?
04:04:41 <osa1> hm, we have hex notation but not binary notation...
04:09:53 <urbanslug> Does vim have an inbuilt shell like emacs? I doubt it. Take that feeble vi* users.
04:13:00 <lericson> re vim shell: no, and it's intended to be that way. a terminal and a shell already exist and they work perfectly well, why reimplement this?
04:14:23 <lericson> can vim interact with processes via pipes? sure, and very conveniently! :r !uname -a to read the output into the current buffer, :%!xxd to put the current buffer into stdin of xxd and replace the buffer with the processes' stdout, :w !pbcopy to write the current buffer contents to a process
04:14:41 <lericson> there are selection-based variants of all the relevant commands
04:26:49 * hackagebot envparse 0.1.0 - Parse environment variables  http://hackage.haskell.org/package/envparse-0.1.0 (MatveyAksenov)
04:29:29 <prinsen> Haskell complains about Overlapping instances, but there are none. One of the instances has a constraint but this does not seem to be regarded
04:30:51 <tdammers> prinsen: paste some code?
04:33:03 <lpaste> prinsen pasted “No title” at http://lpaste.net/114165
04:33:46 <prinsen> tdammers: The error I get is
04:34:11 <lpaste> prinsen pasted “No title” at http://lpaste.net/114166
04:35:46 <prinsen> In that case a = Number, b = (String + Bool), c = String, d = Bool. Obviously there is no instance SubType b d so why cant it just choose the SubType a a instnace?
04:36:09 <tdammers> maybe it's because "there is no instance" isn't obvious?
04:36:18 <tdammers> instances can be added from the outside later on, remember?
04:36:53 <prinsen> tdammers: yes ok
04:37:19 <prinsen> tdammers: Is there any solution to get it to choose the right one?
04:37:25 <prinsen> Incoherent instances dont work
04:38:22 <tdammers> idk... rethink the design?
04:38:33 <tdammers> maybe some of the brainier people here has a better idea
04:42:10 <ThreeOfEight> don't have the time to look at it
04:42:16 <ThreeOfEight> but it sounds like functional dependencies could perhaps help
04:42:33 <prinsen> tdammers: is there any way of saying b not equal c + d?
04:42:46 <tdammers> prinsen: don't know, don't think so
04:42:50 <prinsen> ThreeOfEight: pls expand :)
04:42:59 <tdammers> but as ThreeOfEight said, functional deps might work
04:43:26 <tdammers> basically, you can add a constraint of the form a -> b to your typeclass
04:43:59 <tdammers> which means that for any instance, the type substituted for a determines the type substituted for b
04:44:14 <tdammers> and this rules out any other instance involving the same a
04:44:57 <prinsen> Its like the opposite of my case :p
04:45:20 <tdammers> haha, use b -> a then :P
04:45:33 <prinsen> sub can be "injected" into any chain just as it contains a sub
04:45:49 <tdammers> hum
04:46:15 <tdammers> I have no idea what you're modeling here, but maybe it can be done without a typeclass even?
04:46:16 <prinsen> what I want to end up with and alsmost works is
04:47:13 <prinsen> a + b can be injected into a x + a+ b, or a a + x + b, or a a + y+ b+ z
04:47:13 <prinsen> etc
04:47:27 <schoppenhauer> hello. how can I see the source code line of an error (in my case, array index is out of bounds) that has been thrown, with ghci?
04:52:25 <prinsen> etc
04:52:38 <tero-> why Data.Aeson.decode (Data.Aeson.encode $ Bool True) :: Maybe Value evaluates to Nothing?
04:54:13 <prinsen> tero-: Because JSON cant be bool top level
04:54:25 <prinsen> tero-: Its all in the docs
04:54:28 <tdammers> pet peeve here: asking questions in a form that isn't a question
04:54:35 <tdammers> "why verb nouns?"
04:54:48 <tdammers> no wait, that's a proper question, lol
04:54:52 <Bubblegum> If my Type of my function is [City] -> Integer and I want to get the distance inbetween my tourlength(permutation), do I just subtract one of my city from a list?
04:55:01 <tero-> prinsen: ok, thanks. I have to handle it as a special case then
04:55:05 <Bubblegum> sorry, the total length
04:55:10 <Bubblegum> i meant
04:55:33 <prinsen> tero-: Just be aware that you wont be outputting JSON
05:01:13 <schoppenhauer> is there a possibility?
05:02:20 <absence> is there a common operation that combines nub and sort? i know sets have unique values, but are they sorted?
05:03:35 <tero-> prinsen: I'm only receiving JSON(ish apparently) messages
05:04:05 <Fuuzetsu> > nub [3, 2, 1]
05:04:06 <lambdabot>  [3,2,1]
05:04:10 <Fuuzetsu> hm, thought nub already sorted
05:04:17 <tdammers> nope
05:04:22 <tdammers> nub just nubs
05:05:21 <McManiaC> nub nub
05:06:54 <jkarni> Fuuzetsu: nub doesn't have have an Ord constraint
05:07:11 <jkarni> Fuuzetsu: which makes it kind of slow, I guess
05:07:26 <absence> nub is O(n^2)
05:07:27 <Fuuzetsu> :t nub
05:07:28 <lambdabot> Eq a => [a] -> [a]
05:07:36 <Fuuzetsu> I thought the complaint was that it *did* have Ord
05:07:48 <Fuuzetsu> guess I confused the situation
05:07:53 <Fuuzetsu> doesn't matter
05:09:34 <absence> :t Set.toAscList . Set.fromList
05:09:35 <lambdabot>     Not in scope: ‘Set.toAscList’
05:09:35 <lambdabot>     Perhaps you meant one of these:
05:09:36 <lambdabot>       ‘S.toAscList’ (imported from Data.Set),
05:09:42 <absence> :t S.toAscList . S.fromList
05:09:43 <lambdabot> Ord a => [a] -> [a]
05:15:54 <clrnd> guys what does this mean:
05:15:56 <clrnd> (~ (* -> *) b IO, MonadBaseControl b m) => Applicative (Concurrently b m)
05:16:16 <clrnd> it's in the list of instances of Concurrently from Async.Lifted
05:16:30 <clrnd> the "* -> * b IO" part
05:16:51 * hackagebot shuffle 0.1.3.1 - Shuffle tool for UHC  http://hackage.haskell.org/package/shuffle-0.1.3.1 (AtzeDijkstra)
05:17:05 <clrnd> I know * -> * means somethings has that kind, just not sure what something
05:19:40 <bernalex> any haskell.org guys here atm? I'd like a wiki account, please
05:20:01 <bitonic> is there an accepted name for “flip (.)” – I don’t mean as an operator, but as an English word
05:20:16 <bernalex> bitonic: reverse composition
05:20:33 <bitonic> bernalex: a single English word
05:20:36 <tdammers> "cocomposition?"
05:20:42 <tdammers> "mposition"?
05:20:53 <sinelaw> chain?
05:20:57 <bernalex> bitonic: why would it have to be a single word? that's not a useful goal in itself.
05:21:11 <AshyIsMe> chain reads nicely
05:21:12 <bitonic> bernalex: …because I need a good function name.
05:21:18 <AshyIsMe> whaht symbol are you going to use?
05:21:19 <bitonic> sinelaw: I like chain!  thanks.
05:21:38 <bitonic> sinelaw: do other people use it or did you just make it up?
05:21:45 <sinelaw> bitonic, another name is Control.Category.(>>>)
05:21:47 <Qfwfq> How about (>>>)?
05:21:57 <tdammers> I think it's a pretty common name for the concept
05:22:01 <sinelaw> or just (>>>), but instead of defining you can import it
05:22:12 <bitonic> sinelaw, Qfwfq: I need a word, I don’t want to define it as an operator
05:22:17 <bernalex> using a named function for composition is a bit weird. co & coco? lol
05:22:28 <bitonic> “sequence” I also like, but it’s a bit long and you can confuse it with the data structure
05:22:43 <tdammers> and with the function from Control.Monad
05:22:45 <AshyIsMe> & is already pipe-forward
05:22:55 <AshyIsMe> flip ($)
05:23:05 <bernalex> & is the same as F#'s |>
05:23:06 <detrumi> clrnd: I guess it just means that "b IO" has kind * -> *, though I'm not sure why that couldn't be inferred by the compiler
05:23:11 <bernalex> $ is <|
05:23:13 <tdammers> we need non-ASCII Haskell
05:23:21 <bitonic> I like ASCII
05:23:25 <sinelaw> bitonic, I made it up, but subconsciously may have heard it somewhere
05:23:25 <bernalex> and . and flip (.) is << and >>
05:23:25 <tdammers> more symbols to abuse as operators
05:23:38 <sinelaw> bitonic, why not the standard one from Control.Category?
05:23:41 <AshyIsMe> i like the symmetry of the f# operators for that
05:23:45 <clrnd> that means b is a something wich is kind * -> * -> * but has to have IO in the first slot
05:23:47 <AshyIsMe> shame haskell is $ and &
05:23:50 <bitonic> sinelaw: I like it, I think I’m going to go for it.  in my case I’m composing term substitutions, and they’re not a category
05:24:08 <bernalex> AshyIsMe: the best thing about them is the mnemonics. < and > give away what direction things are going in. $ and & is needlessly opaque.
05:24:10 <bitonic> sinelaw: and I’m defining the constructor name anyhow
05:24:14 <sinelaw> they have compositions but no identity?
05:24:15 <detrumi> Yeah, that would make sense
05:24:21 <clrnd> detrumi, thanks
05:24:30 <bernalex> AshyIsMe: we actually have |> and <| defined deep in compilerland (GHC) and use it there.
05:24:35 <AshyIsMe> bernalex: yeah i agree
05:24:37 <AshyIsMe> oh really
05:24:40 <bitonic> sinelaw: they have identity but you they’re not polymorphic.  they form a category but they’re not an instance of Category
05:24:42 <triliyn> clrnd: Wouldn't b have kind (* -> *) -> * -> *, since IO has kind * -> *?
05:24:59 <bernalex> AshyIsMe: Data.Sequence also defines |> and <| for sequences.
05:25:18 <AshyIsMe> oh haskell.org is down currently
05:25:18 <clrnd> you are triliyn yeah, then, should I provide a "b (IO a) c"
05:25:19 <sinelaw> bitonic, hmm. i wonder if there's a class for that
05:25:24 <AshyIsMe> i wanted to hoogle for "&"
05:25:25 <clrnd> or just a "b IO a"
05:25:27 <bitonic> sinelaw: monoid
05:25:29 <sinelaw> err...monoid
05:25:32 <sinelaw> exactly :)
05:25:35 <clrnd> you are right*
05:25:51 <bitonic> sinelaw: yeah but my composition is monadic too.  and in any case I want to name the constructor well
05:25:54 <sinelaw> so you're doing flip mappend?
05:26:06 <sinelaw> ok, just out of interest
05:26:06 <bitonic> just mappend
05:26:13 <sinelaw> oh right
05:26:14 <triliyn> clrnd: if b :: * -> * -> *, then you'd do the former
05:26:25 <triliyn> If b :: (* -> *) -> * -> *, then the latter
05:26:37 <triliyn> (Kind signatures are a little annoying to type)
05:26:45 <bernalex> triliyn: hm. why?
05:26:50 <bernalex> out of curiosity heh
05:26:55 <sinelaw> I agree with using domain specific namings
05:27:02 <clrnd> but I don't know it's kind :P
05:27:25 <vulume> Hi, does haskell have anonymous types or something? I want a key value store with signature "insert :: valueType -> Store valueType id -> (Ref id valueType, Store valueType id). So the ref can only be used on the store.
05:27:26 <triliyn> Why are they annoying to type? 8 is just in an awkward position and there's lots of toggling shift
05:27:43 <triliyn> clrnd: hmmm, do you get an error with one or the other? And where does b come from?
05:27:56 <bernalex> triliyn: ah. gotcha. I'd only need shift for > there myself.
05:28:26 <triliyn> I need shift for *, no shift for -, and shift for >
05:28:26 <clrnd> triliyn, no, I'm still trying to decide where it goes in the code
05:28:36 <sinelaw> vulume, sounds like the ST monad
05:28:49 <Bubblegum> Just a question, does the function ! has a substitute?
05:29:01 <bernalex> triliyn: interesting that you need it for * but not ()s, heh.
05:29:19 <sinelaw> Bubblegum, what do you mean?
05:29:31 <triliyn> oh, I also need it for ()s, and kind signatures with those are even more annoying :P
05:30:15 <vulume> sinelaw, so it's not something I can enforce on the type level? I'd probably be okay with putting it in a monad to prevent leaking refs.
05:30:24 <prinsen> Question. I have a overlapping problem because Open world assumption. But it assumes "impossible" instances. Is there any way to close the class?
05:31:22 <sinelaw> vulume, I think you can do it with existentials, but I don't know enough to answer you
05:31:23 <Bubblegum> disregard the question, how do I load a module?
05:31:30 <sinelaw> import?
05:32:10 <vulume> sinelaw: aight. i've got some research to do. it does sound a bit like dependent types.
05:32:32 <sinelaw> vulume, look at how ST is implemented. I'm pretty sure it uses existentials
05:32:58 <vulume> sinelaw: oh, you meant ST already does that? that's even better :)
05:34:24 <sinelaw> vulume, I would definitely look at ST
05:34:32 <vulume> thanks!
05:35:23 <sinelaw> with pleasure
05:35:37 <indiagreen> Bubblegum: “import Module” in GHCi (for package imports), “:l path/to/module” for your own files
05:35:53 <Bubblegum> thanks
05:36:56 <pjdelport> vulume: Have you read https://www.haskell.org/haskellwiki/Monad/ST ?
05:37:38 <pjdelport> vulume: That has a little bit of explanation of how ST encapsulates state threads.
05:38:30 <pjdelport> And you can read the paper that introduces them fully: http://research.microsoft.com/en-us/um/people/simonpj/papers/lazy-functional-state-threads.ps.Z
05:38:55 <pjdelport> (or http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.144.2237&rep=rep1&type=pdf for something you can read as PDF in your browser)
05:39:14 <vulume> pjdelport: I'm on it :) right now I have a store with a generic Map with Typeable values and typesafety - but only when you use refs returned by that store for lookup.
05:40:08 <vulume> it's hidden in a library, so it's okay, but maybe not the most kosher thing to do
05:41:16 <vulume> pjdelport: thanks for the links
05:44:51 <indiagreen> vulume: vault?
05:46:04 <prinsen> Im stuck, http://lpaste.net/114168 . The two first instances are overlapping (b ~ (c + d)), but then the constraint SubType b d is "impossible". Any brainy person that has an idea?
05:46:52 * hackagebot PastePipe 1.7 - CLI for pasting to lpaste.net  http://hackage.haskell.org/package/PastePipe-1.7 (MateuszKowalczyk)
05:47:00 <vulume> indiagreen: nice. Data.Vault looks good. i hope i can use ST
05:47:11 <indiagreen> Data.Vault.ST then
05:47:19 <indiagreen> no, ST.Lazy
05:47:23 <indiagreen> well, or ST.Strict
05:49:04 <blizzyschool> may someone explain what 'depriving (Show)' means?
05:49:18 <blizzyschool> *deriving
05:49:34 <opqdonut> it means "give me an automatic instance of the Show type class for this type"
05:49:52 <BoR0> it's like writing "instance Show YourDataType where", but it's auto-instantiated
05:49:57 <insitu> blizzyschool it means that you require the compiler to automatically derive an instance of the class Show
05:50:20 <opqdonut> basically it means that you can call the show function on the type, and that GHCi knows how to print values of that type
05:50:25 <insitu> blizzyschool based on the structure of your type, instead of having to supply your own
05:50:45 <blizzyschool> oh ok. thank you opqdonut, BoR0, and insitu.
05:57:30 <vulume> indiagreen: dunno whether ST will work for my project is what i meant ;) i'm pretty restricted for research reasons
06:00:35 <phool1> !search
06:01:01 <insitu> prinsen do you have a test case?
06:01:52 * hackagebot cgrep 6.4.7 - Command line tool  http://hackage.haskell.org/package/cgrep-6.4.7 (NicolaBonelli)
06:02:45 <prinsen> insitu: Yes
06:03:50 <prinsen> let type Base = Number + String + Bool
06:04:18 <prinsen> let a = inj Number :: Base
06:04:41 <prinsen> then the expression inj a yields a overlapping instance error
06:04:51 <wei2912> is there an automated way of getting lambdabot to join a channel, or must i ask the owner?
06:05:03 <wei2912> #fp101x wants to use lambdabot :)
06:05:14 <c_wraith> @join #fp101x
06:05:14 <lambdabot> Not enough privileges
06:05:20 <c_wraith> you'll have to ask int-e
06:05:21 <wei2912> :(
06:05:22 <c_wraith> :)
06:05:24 <mada> :<
06:05:26 <wei2912> thanks c_wraith
06:06:32 <prinsen> insitu: The problem is that Haskell uses an Oen World assumption, so constraints arent a part of the overlapping check
06:09:50 <insitu> Ah, you mean an Open World assumption...
06:10:05 <insitu> I was wondering who that Oen person was
06:10:24 <sipa> it's dutch for idiot
06:10:29 <dramforever> Hmm...
06:10:54 <dramforever> fundeps could make it closer
06:11:40 <tdammers> sipa: "oen world" sounds legit
06:11:50 <prinsen> haha sorry about that
06:12:50 <prinsen> If one could express negative ~ it would be easy
06:13:19 <dramforever> Does fundeps work?
06:14:20 <dramforever> oh, Do fundeps work/
06:14:21 <dramforever> ?
06:14:26 <prinsen> dramforever: I cant see how
06:14:57 <dramforever> prinsen: I'm not sure what are you talking about. Can you show me some relevant code?
06:15:39 <prinsen> dramforever: http://lpaste.net/114169
06:16:11 <prinsen> dramforever: Ill post a runnable example
06:17:25 <fizbin> Anyone know if cabal-dev is still supported/being worked on?
06:17:56 <fizbin> (I've got to compile on Ubuntu 12.04, which has an ancient version of ghc and cabal-install)
06:18:00 <prinsen> dramforever: http://lpaste.net/114170
06:21:47 <prinsen> dramforever: any idea?
06:22:04 <dramforever> prinsen: no...
06:22:22 <dramforever> fundeps won't work here
06:32:36 <ParahSailin_> i would have expected this to be a low-cost abstraction: http://lpaste.net/8459770290925207552
06:36:54 * hackagebot hspec2 0.6.1 - Alpha version of Hspec 2.0  http://hackage.haskell.org/package/hspec2-0.6.1 (SimonHengel)
06:39:31 <xandaros> On the wiki it says that GHC doesn't work on ARM, but that that will be remedied with GHC 7.8. Current version is 7.8.3, is ARM an option now or is the wiki just outdated?
06:39:56 <ParahSailin_> people build stuff for ios with ghc 7.8
06:40:15 <michaelt> ParahSailin_: did you try it with both versions of StateT  -- I mean lazy and strict?
06:40:32 <ParahSailin_> michaelt: hm no, just did lazy
06:41:12 <ParahSailin_> michaelt: just got a speedup from taking mconcat out
06:41:35 <michaelt> ParahSailin_: it was just a thought. I'm not seeing anything dreadful here, but dunno
06:41:45 <michaelt> ah, I wonder why
06:42:07 <xandaros> So, I can just cross-compile ghc for ARM and it should work?
06:43:31 <ParahSailin_> added a third one http://lpaste.net/8459770290925207552
06:43:56 <ParahSailin_> renderSheet'' is a bit faster than renderSheet'
06:44:57 <ParahSailin_> i guess mconcat is part of the monoid definition, so i might as well override the default
06:49:24 <michaelt> ParahSailin_: what is this Row/ ToRow business?
06:49:56 <ParahSailin_> its just part of the xml format i'm generating
06:50:24 <ParahSailin_> those are constant factors so i simplified the benchmarks
06:50:35 <michaelt> ah, i was looking around hackage...
06:50:48 <michaelt> didnt seem like Sql was in question ....
06:51:54 <ParahSailin_> its actually for excel file generation
06:53:54 <ParahSailin_> even this cut significant time off http://lpaste.net/8459770290925207552
06:56:11 <ParahSailin_> and added the defintion of the Row and ToRows stuff
07:05:44 <ParahSailin_> and yeah, StateT from Strict is slower
07:11:55 * hackagebot crypto-conduit 0.5.5 - Conduit interface for cryptographic operations (from crypto-api).  http://hackage.haskell.org/package/crypto-conduit-0.5.5 (FelipeLessa)
07:17:38 <EvanR> it is interesting that the STG machine applies functions to multiple arguments, with special treatment of partial application, after all the language-level stuff in haskell eschewing uncurried functions ;)
07:18:08 <clrnd> how can I run IO acitons in my transformer concurrently?
07:18:19 <clrnd> this is a vage question I know
07:18:33 <EvanR> liftIO ?
07:19:05 <clrnd> sorry, I mean run the transformers concurrently?
07:19:26 <EvanR> forkIO ?
07:20:13 <clrnd> type Something a = EitherT blah (ReaderT blah IO) a
07:20:51 <hexagoxel> ParahSailin_: what about [(x,x)|x<-[0..999999]] ?
07:20:54 <cdk> clrnd: take a look at lifted-base, particularly Control.Concurrent.Lifted.fork
07:21:05 <clrnd> let c = (,) <$> a <*> b with :: a, b :: Something a
07:21:31 <clrnd> cdk, I have read hackage's docs on that package at least 5 times now
07:21:35 <clrnd> :P
07:21:39 <clrnd> and can't make sense of it
07:21:49 <ParahSailin_> hexagoxel: well, that less-elegant list is the same in both cases
07:22:12 <ParahSailin_> hexagoxel: its really the difference between renderSheet and renderSheet' that i want to fix
07:22:54 <hexagoxel> ah, i thought you were generally trying to improve performance
07:22:56 <clrnd> I want my example up there to have the "a and b" run in parallel
07:23:10 <EvanR> ah, parallel
07:23:17 <clrnd> I can run my transformer (since it's IO a) every time manually in parallel
07:23:30 <clrnd> but I want to take advantage of something I don't know that exists
07:23:43 <dagle> Is hackage really slow at sending emails?
07:26:17 <EvanR> clrnd: whats the type of the thing you are trying to run in parallel
07:26:26 <joshc> clrnd: perhaps you're looking for something like async's Concurrently
07:26:31 <cdk> clrnd: you should be able to use fork on your "Something a" since it is an instance of MonadBaseControl
07:27:10 <clrnd> joshc, I considerably suspect that's what I should use, but I don't know why
07:27:25 <michaelt> Oh, I was about to suggest Async like joshc
07:27:25 <clrnd> let me rephrase
07:27:43 <clrnd> (also no idea how to use Async.Lifted)
07:27:47 <michaelt>  EitherT blah (ReaderT blah Async) a
07:27:52 <EvanR> how does it make sense to run Something a "in parallel" dont you need at least two things to do before you can try that
07:27:58 <michaelt> oh
07:28:00 <clrnd> I have my stack, and I combine things of my stack with Applicative
07:28:28 <clrnd> michaelt, I'll try that, tried writing Concurrently almost everywhere in my types :P
07:28:58 <michaelt> Concurrently doesn't have a monad instance though, so there might be trouble
07:28:58 <clrnd> wait I can show you
07:29:21 <clrnd> I have almost the same structure this project has https://github.com/dmjio/hackernews/
07:29:36 <clrnd> https://github.com/dmjio/hackernews/blob/master/src/Web/HackerNews/Client.hs
07:29:51 <nkar> is there a succinct way of transforming (a, Maybe b) to Maybe (a, b)?  that is, if Maybe b is Nothing, return Nothing, unwrap otherwise.
07:30:04 <clrnd> nkar, fmap
07:30:27 <michaelt> oh, sorry I was thinking something stupid, clrnd.
07:30:29 <clrnd> > (,) <$> (Just 1) <*> pure 5
07:30:31 <lambdabot>  Just (1,5)
07:30:44 <clrnd> no problem
07:31:20 <hseg> @pl \(x,y) -> fmap (\y -> (x,y)) y
07:31:20 <lambdabot> uncurry (fmap . (,))
07:31:21 <clrnd> I've literally tried writing runConcurrently randomly trough my code and seeing if GHC outputted usable info
07:31:23 <michaelt> \(a,m) -> fmap ((,)a) m
07:31:36 <hseg> Does lamdabot lack TupleSections?
07:32:16 <EvanR> > (1,) 2
07:32:18 <lambdabot>  (1,2)
07:33:28 <hseg> So why does this not work?
07:33:32 <clrnd> Control.Concurrent.CHP also looks related
07:33:36 <hseg> @pl \(x,y) -> fmap (x,) y
07:33:36 <lambdabot> (line 1, column 18):
07:33:36 <lambdabot> unexpected ","
07:33:36 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
07:33:38 <michaelt> oh, hseg @pl doesnt have tuple sections, clearly
07:33:43 <Faucelme> clrnd: You could consider also this small variant of Concurrently: https://hackage.haskell.org/package/conceit
07:33:46 <hseg> Apparently.
07:34:07 <nkar> clrnd: but your solution doesn't operate on the tuple, you've destructed it.
07:34:46 <PDani_> hi
07:35:23 <clrnd> > let (a, b) = (5, Just 7) in (,) <$> pure a <*> b
07:35:25 <lambdabot>  Just (5,7)
07:35:56 <cchalmers> > Data.Traversable.sequence (1, Just 2)
07:35:58 <lambdabot>  Not in scope: ‘Data.Traversable.sequence’
07:36:22 <clrnd> Faucelme, looks nice, but doesn't seem to interface MonadTrans
07:36:56 * hackagebot sdl2 1.3.0 - Low-level bindings to SDL2  http://hackage.haskell.org/package/sdl2-1.3.0 (Polarina)
07:40:01 <PDani_> I'm beginner in Haskell, and I have a conceptual problem: I use a piece of objective C code which captures the screen as a screencast. I have two functions, startCapture and stopCapture accessible through FFI. startCapture starts a thread in objC and once a new captured frame is ready for consommation, calls back a Haskell function from objC called "captureFrame". So this callback Haskell function "captureFrame" returns IO (), and gets a sessio
07:40:52 <PDani_> any better idea?
07:41:12 <bolmar> @pl \f a -> f a a
07:41:12 <lambdabot> join
07:42:19 <cdk> bolmar: join :: (r -> r -> a) -> r -> a
07:42:30 <EvanR> PDani_: your message was cut off at and gets a sessi
07:42:49 <cdk> specialized to the ((->) r) monad
07:43:42 <PDani_> and gets a sessionID and the frame itself as a parameter. Now, if I'd like to count the frames per sessionID, and the only thing I can think of is some kind of "singleton map", where I can look up the state of a counter for the sessionID n.
07:43:47 <PDani_> EvanR: thx :)
07:44:23 <EvanR> PDani_: sounds very complex
07:46:57 * hackagebot hspec-snap 0.3.2.0 - A library for testing with Hspec and the Snap Web Framework  http://hackage.haskell.org/package/hspec-snap-0.3.2.0 (DanielPatterson)
07:48:36 <detrumi> PDani_: Sounds like a solution, what problems do you see with it?
07:50:44 <detrumi> You'll need some global state which maps sessionIDs to frames, unless you change the flow of control
07:52:25 <bolmar> cdk: thanks
07:53:25 <clrnd> I need like a Concurrent MonadTrans
07:56:59 <PDani_> detrumi: so how can I create something in Haskell which is mutable and has a global "handle"? technically I'd like to have a map-like singleton value with a global name
07:57:38 <clrnd> PDani_, you usually use the State Monad
07:58:03 <EvanR> ive never really used the state monad by itself
07:58:08 <EvanR> and it wont work in PDani_'s case
07:58:13 <EvanR> he wants global variables
07:58:15 <detrumi> Don't you need IORefs?
07:58:27 <EvanR> IORefs wont be concurrent
07:58:35 <PDani_> clrnd: so, my callback function, which is already an IO, should be made a IO + State with StateT?
07:59:04 <EvanR> PDani_: theres this package to make a global storage location https://hackage.haskell.org/package/safe-globals-0.1.1/docs/Data-Global.html
07:59:07 <clrnd> maybe he doesn't really need global state, but yeah. maybe MVars?
07:59:16 <clrnd> oh thtas nice
07:59:21 <EvanR> i dont think he does either, but thats what his plan entails
07:59:33 <clrnd> jaja
07:59:48 <EvanR> the package gives you a global IORef, MVar, TVar, Chan, etc
08:00:27 <PDani_> clrnd, EvanR: how could I avoid the global state?
08:00:38 <PDani_> you've mentioned that probably I don't need it
08:00:55 <PDani_> this thing feels nasty
08:01:22 <EvanR> with objective c bindings, do you have to use a top level haskell function as your callback?
08:01:32 <exio4> does anyone know a syntatic sugar for something like this view pattern "f (cond → True) = ..."?
08:01:43 <exio4> s/a syntatic sugar/some syntatic sugar/
08:02:05 <detrumi> exio4: Guards?
08:02:14 <PDani_> EvanR: it's simple FFI, I wrapped around my objc stuff with C functions (startCapture and stopCapture)
08:02:17 <detrumi> f | cond = ...
08:02:26 <PDani_> ah I get it
08:02:36 <PDani_> EvanR: I think, yes
08:02:45 <exio4> detrumi: it would be ≡alent to "f x | cond x ="
08:02:54 <PDani_> foreign export ccall captureFrame :: CInt -> CInt -> CInt -> Ptr CUChar -> IO ()
08:03:17 <PDani_> EvanR: this is how I export my Haskell top-level function to objc
08:03:30 <EvanR> PDani_: also do you need a callback, because if its possible, i think a better interface would be to put the frames into a MVar, and read that from haskell
08:03:52 <EvanR> but i dont think you can do directly that
08:05:20 <PDani_> EvanR: you're saying, instead of pushing the data from objc to haskell, I should rather poll for it? Woulnd't that be less efficient? (because of the polling)
08:05:41 <EvanR> PDani_: a common way to avoid global state when doing low level routines is to pass a context pointer around, sometimes called "userdata", which is where you keep whatever mutable variables you are using
08:05:55 <EvanR> PDani_: no i wasnt suggesting polling anything
08:07:10 <PDani_> then, I have to check out this MVar thingy
08:07:49 <EvanR> thats an interface detail
08:08:26 <EvanR> in order to get a mutable context into your callback (if thats what you really need), look into passing a pointer to a haskell object to the ffi and then back in
08:08:48 <EvanR> in such a way that it doesnt get moved by the gc
08:09:11 <EvanR> that would avoid a global variable hack
08:11:57 * hackagebot csound-expression-dynamic 0.1.0 - dynamic core for csound-expression library  http://hackage.haskell.org/package/csound-expression-dynamic-0.1.0 (AntonKholomiov)
08:11:59 * hackagebot csound-expression-typed 0.0.6.0 - typed core for the library csound-expression  http://hackage.haskell.org/package/csound-expression-typed-0.0.6.0 (AntonKholomiov)
08:12:02 * hackagebot not-gloss 0.7.0.0 - Painless 3D graphics, no affiliation with gloss  http://hackage.haskell.org/package/not-gloss-0.7.0.0 (GregHorn)
08:12:03 * hackagebot csound-expression 4.2.0 - library to make electronic music  http://hackage.haskell.org/package/csound-expression-4.2.0 (AntonKholomiov)
08:12:06 * hackagebot csound-sampler 0.0.3 - A musical sampler based on Csound  http://hackage.haskell.org/package/csound-sampler-0.0.3 (AntonKholomiov)
08:12:09 <PDani_> of course, I could put this whole counter stuff into the objc code... but the original idea was to keep that code as thin as possible. but it would simplify my life a lot...
08:12:37 <bananagram> I need help troubleshooting my Haskell installation on my netbook
08:12:37 <Gurkenglas> Why is toList not a minimally complete definition for Foldable?
08:12:54 <bananagram> I'm getting this error a lot: http://lpaste.net/8300312350091640832 anyone recognize it?
08:12:56 <EvanR> PDani_: what would that mean, putting the global var in the obj C code instead?
08:13:06 <bananagram> I'm not sure what's causing it, but recompiling everything didn't help
08:14:35 <EvanR> PDani_: what about implementing this thing as an obj C object, the haskell side gets a pointer to this object, and this object passes a reference to itself to the callback, which can then use the reference in more ffi calls to get at the functionality you want
08:14:52 <PDani_> EvanR: no, it comes more naturally, as the screencast capture "session" is an object, it could have the "frameNo" field as a member field of the object, atomically increased, and passed to the haskell code
08:15:20 <EvanR> expose the counts to haskell through more ffi calls (which need an object reference rather than a global)
08:15:43 <EvanR> you can wrap the low level ffi crap with nice haskell stuff later
08:17:08 * hackagebot not-gloss-examples 0.5.0 - examples for not-gloss  http://hackage.haskell.org/package/not-gloss-examples-0.5.0 (GregHorn)
08:17:10 * hackagebot threadscope 0.2.5 - A graphical tool for profiling parallel Haskell programs.  http://hackage.haskell.org/package/threadscope-0.2.5 (MikolajKonarski)
08:18:45 <EvanR> PDani_: or do that
08:28:11 <fds4345> I have a type: `newtype StateNode n a m = StateNode Int`, and it keeps wanting an argument to `m` when I use it in a type signature. Any way to stop it doing that?
08:37:07 <Gurkenglas> Can Foldable a do anything any faster than the [a] produced by toList?
08:44:01 <absence> Gurkenglas: what do you mean?
08:44:43 <Gurkenglas> Why have functions of the form Foldable a => a -> b when we could just have functions of the form [a] -> b?
08:45:36 <Gurkenglas> (Both can be converted between one another seemingly without any real overhead)
08:46:08 <Gurkenglas> Meaning, what can Foldable do that [] can't?
08:48:05 <Gurkenglas> On another note, compiler says "Module `Data.List.Lens' does not export `_head'"
08:48:13 <Gurkenglas> http://hackage.haskell.org/package/lens-3.2/docs/Data-List-Lens.html says elsewise
08:48:32 <Darwin226> Hey guys. I've got an easy one for you. Playing with the State monad and I have this code https://gist.github.com/eb15b867c958833e5d9d
08:48:48 <Darwin226> Can someone tell me what's wrong with it? I can provide the error but it's lengthy
08:49:16 <HeladoDeBrownie> Gurkenglas, there is no free conversion from a list to an arbitrary Foldable. If you required a list instead of a Foldable, you'd be asking the user of your API to do the conversion manually.
08:49:23 <Gurkenglas> Using lpaste.net/new/haskell takes that problem from you.
08:49:49 <Darwin226> The error is this https://gist.github.com/389c5e9cbfe69d1149b0
08:49:58 <HeladoDeBrownie> Gurkenglas, (Those were two different answers to two different things you said, not cause and effect.)
08:50:29 <Gurkenglas> HeladoDeBrownie, there is a free conversion from any (Foldable a => a -> b) to a ([a] -> b) and vice versa.
08:51:37 <Gurkenglas> HeladoDeBrownie,
08:51:40 <Gurkenglas> Whoops.
08:51:43 <int-e> Gurkenglas: For example, Foldable can efficiently (i.e. in logarithmic time) extract the last element of a balanced tree.
08:52:00 <Gurkenglas> HeladoDeBrownie, that wouldn't be a problem if everything that produces a foldable produced a list instead.
08:52:15 <Gurkenglas> int-e, ah. Nevermind then everyone.
08:53:20 <HeladoDeBrownie> Gurkenglas, out of curiosity, what are those? One is obviously applying toList to the input; what's the other?
08:54:02 <HeladoDeBrownie> I.e., define (Foldable a') => ([a] -> b) -> (a' -> b)
08:54:07 <int-e> HeladoDeBrownie: the other just specialises Foldabla a.
08:55:12 <int-e> well, the type is wrong. it should be  Foldable t => t a -> b, and then one can take t = [].
08:55:21 <HeladoDeBrownie> Ah, right
08:55:55 <Gurkenglas> Right @ *"t "
08:56:01 <HeladoDeBrownie> In that case, (Foldable f) => ([a] -> b) -> (f a -> b)
08:56:06 <HeladoDeBrownie> I read what Gurkenglas read as saying that exists
08:56:26 <HeladoDeBrownie> s/read/said/
08:57:23 <Gurkenglas> Well, sure. It's ((. toList) :: Foldable f => ([a] -> b) -> (f a -> b))
08:58:00 <Gurkenglas> As you said.
08:58:51 <HeladoDeBrownie> Woops, I meant the other way then. Sorry, I guess I'm not thinking very straight right now.
08:59:13 <Gurkenglas> Well, sure. It's (id :: Foldable f => (f a -> b) -> ([a] -> b))
08:59:33 <Gurkenglas> As int said.
09:00:14 <HeladoDeBrownie> That's not a way you can instantiate id, but I get what you mean now.
09:00:21 <Gurkenglas> It's not?
09:00:27 <Gurkenglas> :t (id :: Foldable f => (f a -> b) -> ([a] -> b))
09:00:28 <lambdabot>     Could not deduce (f1 ~ [])
09:00:28 <lambdabot>     from the context (Foldable f)
09:00:28 <lambdabot>       bound by the inferred type of
09:00:30 <HeladoDeBrownie> id :: forall a. a -> a
09:01:27 <Gurkenglas> How do you write it right then? Haven't seen through the forall stuff yet except that foralls in the very beginning do nothing
09:01:31 <dagle> So, hackage said it sent an email 3 hours ago and still nothing. :S
09:02:03 <HeladoDeBrownie> Gurkenglas, the problem is that you can't write that a is two different things. You can have multiple constraints on a but you have to substitute the same thing for both occurrences.
09:03:03 <HeladoDeBrownie> Gurkenglas, in this case I'd say it's easier to understand if you just write f ~ [] in the original function
09:03:19 <Gurkenglas> ???
09:03:27 <HeladoDeBrownie> f ~ [] means "f unifies with []"
09:03:27 <Gurkenglas> (On your last line)
09:03:34 <Gurkenglas> Yes, where would one write that?
09:03:52 <HeladoDeBrownie> It's a constraint, not usually written in Haskell code, but good for talking about things
09:04:31 <HeladoDeBrownie> I actually can't think of an instance where using a constraint like that is useful, but I've been told there are cases where it is
09:04:54 <HeladoDeBrownie> (With the general senses of "instance" and "case", not the language-specific ones :P)
09:06:02 <Gurkenglas> How would I generally, given Instance C i, observe (C c => (c -> a) -> (i -> a))?
09:08:04 <HeladoDeBrownie> Come to think of it, you can write id :: ([a] -> b) -> [a] -> b for the other direction
09:10:11 <HeladoDeBrownie> Gurkenglas, I don't understand the question. Are some of the variables there supposed to be specific types? If so, can you write those starting with capital letters?
09:10:32 <HeladoDeBrownie> Gurkenglas, or otherwise write out explicit foralls
09:11:05 <Gurkenglas> Not supposed to be specific types. Supposed to be nonspecific types, even :D. I was trying to crystallize the question you answered in your third to last line
09:11:37 <HeladoDeBrownie> Specific hypothetical types would also work :P I was just wondering which variables were free, basically
09:11:45 <HeladoDeBrownie> But did I answer your question already?
09:12:00 <Gurkenglas> If writing the same signature in both is usual then yes
09:13:39 <HeladoDeBrownie> Well, like I said, if you substitute something for a variable, you have to do that substitution uniformly. And since one type is strictly a specialization of the other in this circumstance, id serves perfectly fine as the "translation"
09:19:17 <fizbin> I can't seem to install snap-core cleanly using cabal-dev on ghc 7.4.1. Could someone look at http://lpaste.net/114180 and tell me whether this is a cabal bug, a cabal-dev bug, a snap-core bug, or user error?
09:27:59 <supki> fizbin: looks like cabal-dev can't handle .cabal files changed via hackage web interface
09:28:19 <supki> which isn't that surprising
09:29:24 <fizbin> So it seems to me that what's happening then is that the cabal file actually in the .tar.gz that you download says "text < 1.2", but somehow what the website says is "text < 1.3"
09:29:41 <supki> yep
09:30:31 <fizbin> Where does cabal keep its idea of the latest packages? That is, where's the file that's updated when you do a "cabal update"?
09:32:00 * hackagebot csound-sampler 0.0.3.1 - A musical sampler based on Csound  http://hackage.haskell.org/package/csound-sampler-0.0.3.1 (AntonKholomiov)
09:32:36 <npasco> Is GHC able to optimize ranges away? For example does "forM_ [1..10] print" actually construct a list?
09:33:00 <supki> fizbin: ~/.cabal/packages/$remote/00-index.tar.gz
09:33:07 <jedai> That's normally optimized to a tight loop in the compiled binary
09:34:14 <jedai> npasco: though for some code, the list has to be built
09:35:12 <npasco> I wish code transformations were more user-level understandable. I'd like to see the inspector that looks for ranges and transforms the code.
09:36:01 <npasco> Can GHC optimize away the list here? forM_ (zip [1..5] [6..10]) print
09:36:12 <npasco> *lists
09:36:39 <glguy> npasco: You can look at the generated core to answer that question
09:36:54 <glguy> One tool for making that output easier to get to is "ghc-core"
09:37:06 <npasco> glguy: ok thanks
09:38:58 <npasco> Is this function commonly known by another name? mapFilter :: (a -> b) -> (a -> Bool) -> [a] -> [b] ; mapFilter f p xs = foldr g [] xs where g x acc = if p x then (f x):acc else acc
09:39:32 <glguy> :t mapMaybe
09:39:33 <lambdabot> (a -> Maybe b) -> [a] -> [b]
09:40:02 <glguy> But rather than reimplementing it, use:    map f . filter p
09:40:33 <lpaste> ToTheInternet pasted “No title” at http://lpaste.net/2502512971901566976
09:41:22 <ToTheInternet> Starting out in Haskell. The above paste is a function that splits a string into a list of words
09:41:48 <Iceland_jack> > words "Would this work?"
09:41:49 <lambdabot>  ["Would","this","work?"]
09:41:56 <ToTheInternet> i'm getting a type error, expected type [String], actual type [Char]
09:42:01 * hackagebot log-domain 0.9.3 - Log-domain arithmetic  http://hackage.haskell.org/package/log-domain-0.9.3 (EdwardKmett)
09:42:09 <glguy> Presumably the point is to understand how to implement the function, not to use a library implementation
09:42:17 <Iceland_jack> I see
09:42:40 <ToTheInternet> glguy: yes exactly, but still a great answer, Iceland_jack, since i didn't know about that function
09:42:58 <glguy> ToTheInternet: try adding the completed word to your "lst" with   : instead of ++
09:42:58 <ToTheInternet> any pointers what i am doing wrong in my code are appreciated :)
09:43:17 <josephle> ToTheInternet, I presume alphabet == ['a'...'z']?
09:43:25 <glguy> x : xs     adds x to the beginning of xs,    xs ++ ys    concatenates the two lists together
09:43:26 <ToTheInternet> josephle: yes
09:43:38 <ToTheInternet> glguy: right.. i wonder why i didn't do that
09:44:15 <Iceland_jack> ToTheInternet: You might want to look at 'span':
09:44:15 <Iceland_jack> > span isAlpha "testing just a test"
09:44:17 <lambdabot>  ("testing"," just a test")
09:44:31 <coin> hi there
09:44:36 <Iceland_jack> Hey coin
09:44:53 <josephle> ToTheInternet: okay, let's go through your code
09:45:04 <josephle> ToTheInternet: what's the type of (tmp ++ [a])?
09:45:11 <ToTheInternet> Iceland_jack: interesting, thanks :)
09:45:12 <josephle> in the context of recstr
09:45:46 <ToTheInternet> josephle: [cHAR]
09:45:51 <ToTheInternet> [Char]
09:46:17 <josephle> what's the type of (lst ++ tmp)?
09:46:37 <npasco> glguy: do you expect that map f . filter p will be just as efficient as a single fold?
09:46:56 <ToTheInternet> josephle: [Char] :/
09:47:13 <josephle> ToTheInternet: fortunately, you only have to change that line :)
09:47:30 <josephle> well, you might need to also reverse the list, but one step at a time
09:47:32 <ToTheInternet> josephle: so i'll to do ([tmp] : lst)
09:47:41 <josephle> hmm
09:47:45 <josephle> what type would that be?
09:48:11 <glguy> npasco: 1) there are fusion rules that are likely to kick in,  2) you should write clear code first and only go back to obfuscate it when profiling shows that that code in particular is a problem
09:48:14 <ToTheInternet> no wait... tmp : lst should do it
09:48:18 <josephle> yep :)
09:48:28 <ToTheInternet> but my code still fails
09:48:37 <josephle> what's the new error?
09:49:03 <ToTheInternet> expected type [[char]] actual type [char]
09:49:24 <lpaste> ToTheInternet pasted “No title” at http://lpaste.net/812742794635378688
09:49:47 <ToTheInternet> oh no, sorry
09:49:56 <ToTheInternet> i need to change it at both occurences, obviously
09:51:14 <josephle> yep
09:51:20 <josephle> now, there's still one bug
09:51:37 <josephle> but I think you figure it out :)
09:51:48 <ToTheInternet> at least it compiles
09:51:56 <ToTheInternet> you mean, a logical flaw?
09:51:59 <josephle> yep
09:52:01 * hackagebot libarchive-conduit 0.1.0.0 - Read many archive formats with libarchive and conduit  http://hackage.haskell.org/package/libarchive-conduit-0.1.0.0 (ThomasTuegel)
09:52:06 <josephle> just run some tests, and you'll see it
09:53:28 <josephle> I think you can just change your (tmp : lst) to (lst ++ [tmp]) to get your code to work
09:55:06 <clrnd> I found this: http://lpaste.net/94185
09:55:08 <npasco> Is this function commonly known by another name? downto :: Integral a => a -> a -> [a] ; x `downto` y = [x, (x-1)..y]
09:55:13 <npasco> I found that useful
09:55:18 <clrnd> it has what I think I need, I managed to type check my program (almost)
09:55:47 <clrnd> I'm just left with a lot of undecidable instances
09:55:57 <clrnd> 'could not deduce ..."
09:56:36 <HeladoDeBrownie> @type enumFromTo
09:56:37 <lambdabot> Enum a => a -> a -> [a]
09:56:39 <HeladoDeBrownie> npasco, ^
09:56:57 <HeladoDeBrownie> Wait that's wrong
09:57:06 <npasco> HeladoDeBrownie: right, wrong direction
09:57:09 <HeladoDeBrownie> @type enumFromThenTo
09:57:10 <lambdabot> Enum a => a -> a -> a -> [a]
09:57:12 <HeladoDeBrownie> That one
09:57:20 <HeladoDeBrownie> You have to specify a step below the first thing
09:57:20 <npasco> HeladoDeBrownie: of course, but that's clunky
09:57:29 <HeladoDeBrownie> Sure, that's partly why the syntactic sugar exists
09:57:36 <HeladoDeBrownie> >> [10, 9, ..., 0]
09:57:40 <HeladoDeBrownie> > [10, 9, ..., 0]
09:57:42 <lambdabot>  <hint>:1:12: parse error on input ‘,’
09:57:47 <HeladoDeBrownie> I forgot the syntax actually
09:57:49 <HeladoDeBrownie> > [10, 9 .. 0]
09:57:51 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0]
09:57:52 <HeladoDeBrownie> THere
09:58:17 <ToTheInternet> josephle: the order is not important in my case. but for some reason, the first letter of each word is omitted
09:58:25 <npasco> HeladoDeBrownie: that's what `downto` does, but more conveniently. I was just asking if this is canonical somewhere.
09:58:40 <josephle> ToTheInternet, interesting. can you update your code?
09:58:44 <josephle> I mean your lpaste
09:59:11 <npasco> The purpose is to avoid writing [x, (x-1)..y] every time
09:59:26 <lpaste> ToTheInternet pasted “No title” at http://lpaste.net/3605453010076958720
09:59:34 <HeladoDeBrownie> npasco, I think you'd have to write that specific function yourself, perhaps in terms of one of the things I mentioned
09:59:43 <ToTheInternet> getWords "Hello World"
09:59:44 <ToTheInternet> ["orld","","ello",""]
10:00:13 <ToTheInternet> oh, because of alphabet
10:00:13 <npasco> HeladoDeBrownie: maybe you missed it? Above I wrote downto :: Integral a => a -> a -> [a] ; x `downto` y = [x, (x-1)..y]
10:00:19 <josephle> ToTheInternet: does alphabet contain capital letters?
10:00:36 <ToTheInternet> yes. stupid mistake
10:00:36 <josephle> in the future, you can use this function instead
10:00:41 <josephle> :t isAlpha
10:00:42 <lambdabot> Char -> Bool
10:00:49 <ToTheInternet> ok great
10:00:57 <josephle> you'll need to import Data.Char
10:01:00 <HeladoDeBrownie> npasco, I did miss that, sorry. I think that's about the best you'll get.
10:01:11 <clrnd> I can't believe I did it ... guys, that paste should be a library
10:01:56 <npasco> Just surprised something like `downto` never became canonical, but no big deal.
10:02:17 <HeladoDeBrownie> npasco, however I would test your function for corner cases like descending from n down to n
10:02:19 <ToTheInternet> thanks josephle. haskell is so much fun. i hope one day thinking in a functional way comes natural to me. must be the greated feeling ever.
10:02:22 <clrnd> npasco, I'dd generalize it for Enum
10:02:42 <josephle> ToTheInternet: all it takes is practice :)
10:02:56 <adarc> anyone here ever read Software Foundations by Benjamin Pierce and others? http://www.cis.upenn.edu/~bcpierce/sf/current/index.html
10:03:05 <adarc> just wondering, book looks sexy
10:03:47 <npasco> clrnd: ah right, pred instead of -1, that's better
10:04:18 <josephle> adarc: there are definitely people who have, but I'm not sure if they're here right now
10:04:20 <ToTheInternet> josephle: took me 5 years of full time PHP programming to get to a place where i can just sit down and type code for hours. being able to do that in haskell is way more powerful. there's a lifetime goal right there :D
10:05:01 <benzrf> @src enumFromThenTo
10:05:01 <lambdabot> Source not found. You speak an infinite deal of nothing.
10:05:03 <adarc> cool josephle. i have no questions, was just curious.. i'd love to be able to understand everything in that book
10:05:06 <adarc> 8|
10:05:17 <adarc> and books like it.. oo
10:05:18 <HeladoDeBrownie> benzrf, it's a method
10:05:21 <merijn> ToTheInternet: Haskell is usually: 1 hour of pondering -> write 50 lines -> think 30 minutes -> delete 40 lines -> still have the same functionality :p
10:05:28 <adarc> hah
10:05:45 <clrnd> yeah that's my official workflow
10:05:48 <josephle> I'm not as familiar with the calculus of constructions as others on this channel
10:05:50 <ToTheInternet> merijn: hehe nice
10:05:58 <clrnd> pondering includes hoogling and random web searches
10:06:35 <ToTheInternet> i found out about hoogle earlier today, love it
10:09:46 <fds4345> What does (t m) do in a type signature?
10:10:06 <geekosaur> depends on the type signature; as written, it's two undefined type variables
10:11:29 <fds4345> geekosaur: Kind of on the edge of my understanding of these things, but I'm putting in (t, n) into my program and it seems to be saving more headache than its causing
10:12:02 * hackagebot autonix-deps 0.1.0.0 - Library for Nix expression dependency generation  http://hackage.haskell.org/package/autonix-deps-0.1.0.0 (ThomasTuegel)
10:13:50 <Gurkenglas> Does some IDE automatically import the code you use?
10:16:20 <goglosh> guys, why can't I install nanocurses or hscurses?
10:16:20 <fds4345> Trying to express runStateT in terms of MonadState, anyone know if theres a way to do this?
10:16:23 <fds4345> runStateNode :: MonadState NodesById (t m) => t m a -> NodesById -> m (a, NodesById)
10:16:32 <stian> My first ever Haskell pull request :) https://github.com/Eelis/boxes/pull/5
10:16:42 <goglosh> I always get an error called "ExitFailure 1"
10:17:02 * hackagebot autonix-deps-kf5 0.1.0.0 - Generate dependencies for KDE 5 Nix expressions  http://hackage.haskell.org/package/autonix-deps-kf5-0.1.0.0 (ThomasTuegel)
10:17:25 <clrnd> stian, congrats :)
10:17:55 <merijn> goglosh: Rerun with -v3
10:18:38 <HeladoDeBrownie> fds4345, MonadState doesn't give you the ability to run it
10:18:47 <HeladoDeBrownie> fds4345, you need to pick a specific state type in order to run
10:19:20 <goglosh> merijn: k I'll give it a shot
10:19:35 <npasco> Does this function already have a name? apply :: Int -> (a -> a) -> a -> a ; apply n f = foldr (.) id (replicate n f)
10:19:49 <HeladoDeBrownie> @type iterate
10:19:50 <lambdabot> (a -> a) -> a -> [a]
10:19:52 <HeladoDeBrownie> Woops
10:19:57 <HeladoDeBrownie> Wrong one. It does exist though
10:20:03 <npasco> apply 3 (* 2) 1 => 8
10:20:06 <ReinH> you can write it with iterate :)
10:20:35 <goglosh> merijn: didn't work, same error
10:20:40 <npasco> Yes, but we don't need to track the intermediates
10:20:51 <ReinH> goglosh: -v3 doesn't fix it, it gives you more debug information
10:20:56 <goglosh> oh I see
10:21:00 <merijn> goglosh: Yes, but -v3 should tell you what it's doing
10:21:11 <merijn> "ExitFailure 1" is just "an error"
10:21:30 <merijn> No one can debug that, lpasting the result of -v3 maybe someone can see what's going on
10:21:33 <ReinH> Probably some dependency failed to install and there will be output to that effect at some point
10:21:46 <ReinH> We will need to see the output of the command to help
10:21:55 <int-e> npasco: right, apply n f x = iterate f x !! n  is a shorter way to write that
10:22:12 <goglosh> I think I'll read the cabal user guide
10:22:15 <npasco> int-e: yes but yuck, list indexing
10:22:20 <goglosh> though it looks rather scarce
10:22:23 <int-e> npasco: replicate is just as bad
10:22:23 <ReinH> npasco: the foldr version is pretty nice :)
10:22:28 <HeladoDeBrownie> npasco, this is a case where indexing is safe, because the list is always infinite
10:22:38 <ReinH> :t ala Endo foldMap . replicate n
10:22:39 <lambdabot>     Couldn't match expected type ‘Int’ with actual type ‘Expr’
10:22:39 <lambdabot>     In the first argument of ‘replicate’, namely ‘n’
10:22:39 <lambdabot>     In the second argument of ‘(.)’, namely ‘replicate n’
10:23:02 <Iceland_jack> > repeat 'a' !! (-1)
10:23:03 <lambdabot>  *Exception: Prelude.(!!): negative index
10:23:06 <glguy>  iterate f x !! n   doesn't actually do list indexing
10:23:15 <goglosh> cannot find module Control.Monad.Trans
10:23:25 <goglosh> try running ghc-pkg check
10:23:29 <goglosh> but I did already
10:23:50 <HeladoDeBrownie> Apparently Hoogle just went down
10:23:54 <assia_t> Hey guys
10:23:58 <ReinH> :t \n -> ala Endo foldMap . replicate n
10:24:00 <lambdabot> Int -> (a -> a) -> a -> a
10:24:01 <ReinH> not bad
10:24:13 <glguy>  iterate f x !! n    ends up being efficient
10:24:22 <assia_t> What's the difference between a TBChan and a TBQueue?
10:24:39 <ReinH> HeladoDeBrownie: https://www.fpcomplete.com/hoogle
10:24:59 <ReinH> handy endomorphism monoid is handy
10:25:10 <HeladoDeBrownie> It's back, but I'll keep that in mind
10:25:23 <ReinH> HeladoDeBrownie: fpcomplete's is a bit more... complete as well
10:27:11 <merijn> glguy: It *does* do list indexing, it's just that that's not always bad
10:27:23 <HeladoDeBrownie> assia_t, afaik, the same difference mentioned here: http://haddocks.fpcomplete.com/fp/7.8/20140916-162/stm/Control-Concurrent-STM-TQueue.html
10:27:27 <glguy> It counts, it just doesn't make the list
10:27:32 <merijn> assia_t: Same as between TQueue and TChan :)
10:27:46 <merijn> assia_t: TQueue is more efficient but has higher variance for operations
10:28:09 <int-e> glguy: I guess there's a risk of the 'iterate f x' list being floated out and retained.
10:28:18 <merijn> i.e. TQueue is amortised O(1), where TChan is slightly less efficient, but should have more consistent timings
10:28:31 <int-e> glguy: that chance is smaller with the foldr/replicate version
10:29:29 <assia_t> Thanks! I had seen that comment, but I had forgotten about it
10:33:20 <npasco> Yeah, using iterate is orders of magnitude slower compared to the fold
10:33:43 <npasco> just benched
10:33:59 <glguy> which with optimizations?
10:34:06 <npasco> -O2
10:35:01 <npasco> http://lpaste.net/114187
10:35:57 <glguy> That's a regression, then
10:37:02 <ReinH> Huh.
10:37:45 <merijn> glguy: How do you know that's a regression?
10:38:06 <npasco> GHC is smart, but I would be surprised if it was ever smart enough to look at the whole function and decide that iterate doesn't need to build a list.
10:38:09 <merijn> Do you have any old benchmarks that show this used to optimise the same?
10:38:12 <glguy> Because I've benchmarked this pattern in the past and iterate + !! would generate the faster code
10:38:19 <glguy> fusion the list away
10:38:21 <glguy> fusing*
10:38:28 <HeladoDeBrownie> Check the core output
10:38:43 <merijn> npasco: Due to laziness building the list doesn't matter
10:38:58 <merijn> npasco: It only builds the part it needs anyway
10:39:23 <merijn> glguy: I'm skeptical of that benchmark, I would expect fold to be faster and optimise better
10:39:32 <glguy> OK
10:39:38 <merijn> The iterate version suffers from lack of strictness
10:39:58 <npasco> merijn: fold is the faster one
10:40:11 <npasco> orders of magnitude; instant versus 10 seconds
10:40:15 <merijn> npasco: Right, I was just confirming that your observation is what I would expect :)
10:40:32 <npasco> merijn: ok but you said 'skeptical'
10:40:50 <merijn> npasco: I meant of glguy's initial benchmark where iterate was faster
10:41:05 <npasco> oh ok
10:41:15 <merijn> npasco: For funsies, can you try another one for me?
10:41:15 <HairyDude> Is it possible for threads sparked with forkIO to get gc'd before they finish?
10:41:20 <merijn> (1 sec, need to write it)
10:43:35 <merijn> dfeuer_: You're fusion guru!
10:43:43 <merijn> dfeuer_: Where is "build" from Data.List defined?
10:44:02 <dfeuer_> Not exactly. build is defined in GHC.Base.
10:44:12 <dfeuer_> It's not exported from Data.List.
10:44:33 <dfeuer_> merijn, what do you want with it? Also, you should check out its twin sister, augment.
10:44:55 <merijn> dfeuer_: ok
10:45:08 <merijn> dfeuer_: I'm trying to quickly hack together strict iterate for npasco to test
10:45:37 * dfeuer_ is looking through GHC.Arr and seeing some seriously *nasty* stuff.
10:45:48 <merijn> But that's pointless if I don't add the same rules for iterate' as iterate
10:46:14 <npasco> top google hit, https://ghc.haskell.org/trac/ghc/ticket/3474
10:47:44 <merijn> npasco: Can you try this version to settle my curiosity? http://lpaste.net/114187
10:47:48 <favetelinguis> if i have a recursive datastructure like this (A(B(C))) and then another (D(E(F))) and i want to make this into one such as (A(B(C(D(E(F)))))) using only recursion how would i do that?
10:48:06 <goglosh> I'm getting frustrated
10:48:07 <merijn> oh, wait
10:48:17 <goglosh> I kinda like my software to 'just werk'
10:48:19 <merijn> npasco: 1 sec, I screwed it up >.>
10:48:49 <goglosh> though I can't get to even understand why cabal won't install hscurses
10:49:09 <merijn> npasco: http://lpaste.net/114188 this one
10:49:15 <goglosh> tried installing the allegedly missing dependency "transformers" with no result
10:49:20 <merijn> goglosh: Did you paste the log from cabal with -v3 yet?
10:49:25 <HeladoDeBrownie> favetelinguis, this sounds like a misleading approximation of your actual problem.
10:49:37 <goglosh> I'll paste it here, though it's pretty verbose
10:49:43 <npasco> merijn: apply' and apply'' give the same benchmark for me
10:49:47 <goglosh> well in lpaste
10:49:55 <favetelinguis> it for a class in haskell so we are only allowed to use basic recursion
10:50:06 <HeladoDeBrownie> favetelinguis, what does the actual problem say?
10:50:08 <merijn> npasco: Odd
10:50:25 <merijn> goglosh: Also, I'd recommend against hscurses anyway, ncurses is a horribly designed libraries and it's bindings are thus pretty ugly
10:50:27 <npasco> GHC 7.8.2 on 32-bit linux
10:50:31 <merijn> goglosh: Take a look at vty and vty-ui
10:50:33 <dfeuer_> Gawd, what is it *doing*? I *think* this is basically foldM in ST, but the ST is taken apart by hand and the foldM is written as foldr.
10:51:06 <merijn> goglosh: vty is a pure haskell library for curses like screen drawing and vty-ui provides high level widgets like buttons and text fields on top of vty
10:51:10 <favetelinguis> HeladoDeBrownie: We have data Hand = Empty | Add Card Hand  and then we want to make a function (<++) :: Hand -> Hand -> Hand that puts hand1 ontop of hand2
10:51:34 <HeladoDeBrownie> favetelinguis, ah, now it makes sense. Okay, what are your thoughts on the problem so far?
10:51:34 <yrlnry> I want to define a type that has no values.  I found Kmett's Data.Void module, which claims to be what I want, but I am puzzled, because it has:  newtype Void = Void Void   which does not appear to me to be uninhabited.
10:51:50 <favetelinguis> i can put hand1 ontop of hand2 but hand1 is in reversed order
10:51:58 <HeladoDeBrownie> favetelinguis, okay, how did you do that then?
10:51:59 <favetelinguis> i was thinking i need to reverse hand1 before
10:52:03 * hackagebot HandsomeSoup 0.3.5 - Work with HTML more easily in HXT  http://hackage.haskell.org/package/HandsomeSoup-0.3.5 (AdityaBhargava)
10:52:07 <HeladoDeBrownie> favetelinguis, use lpaste to show your attempt
10:52:12 <merijn> yrlnry: It is uninhabited
10:52:12 <HeladoDeBrownie> (see the topic)
10:52:25 <merijn> yrlnry: Consider the following question, how would you construct a value of type Void?
10:52:31 <goglosh> merijn lemme check that library because the log doesn't really look useful
10:52:39 <yrlnry> merijn: But I can   v = fix Void  and then v has type Void.
10:52:50 <merijn> yrlnry: infinite recursion == bottom
10:52:56 <merijn> yrlnry: bottom inhabits every type in haskell
10:52:59 <favetelinguis> HeladoDeBrownie: http://lpaste.net/114190
10:53:23 <merijn> yrlnry: "fix Void" is identical to "v = undefined :: Void"
10:53:42 <yrlnry> merijn: Consider the type   data Nat = Z | S Nat;     Doesn't this type contain a value (fix S) which is different from bottom?
10:54:01 <goglosh> anyway I did consider library bindings as a hacky patchy approach, which I donit like
10:54:59 <merijn> yrlnry: That's a tricky question, because laziness means you can have bottoms that you can avoid
10:55:15 <yrlnry> The construction of the Void value seems entirely analogous to me.
10:55:20 <merijn> yrlnry: I don't consider myself enlightened enough to answer whether "fix S" is bottom
10:55:26 <merijn> yrlnry: Is void's constructor exposed?
10:55:47 <merijn> yrlnry: Anyway, ask edwardk when he's around :)
10:55:50 <yrlnry> I could for example have case (fix Void) of Void _ => ....   and it would appear that my value, which you say is bottom, is matchable.
10:56:11 <yrlnry> Anyway, my real question is what's a good way to define an empty type?
10:56:20 <merijn> yrlnry: That's only matchable if void's constructors are exported
10:56:21 <benzrf> fix S is not b ottom
10:56:25 <merijn> yrlnry: "data Foo"
10:56:28 <merijn> yrlnry: Done :)
10:56:44 <yrlnry> awesome, thanks!
10:56:48 <lpaste> ToTheInternet pasted “No title” at http://lpaste.net/7488832181352005632
10:56:54 <yrlnry> I tried "data Foo = " for some reason and of course it didn't work.
10:57:04 * hackagebot hoist-error 0.1.0.1 - Some convenience facilities for hoisting errors into a monad  http://hackage.haskell.org/package/hoist-error-0.1.0.1 (JonSterling)
10:57:12 <HeladoDeBrownie> favetelinguis, okay, here's a hint: There's another methodology you can try, and it doesn't involve reversing any Hand.
10:57:12 <HugoDaniel> i hate having to maintain code that was written way before stackage or cabal freeze :S
10:57:18 <HeladoDeBrownie> favetelinguis, what have you been going over in class?
10:57:36 <ToTheInternet> this seems into an endless loop, i don't understand why. the code seems perfectly logical to me
10:57:46 <favetelinguis> no higher order functions and no typeclasses
10:57:50 <goglosh> merijn: vty failed too, I ran ghc-pkg check and this is the log: http://lpaste.net/1608383351620632576
10:57:56 <ReinH> merijn: is repeat () bottom?
10:58:00 <HeladoDeBrownie> favetelinguis, sure, you don't need either of those things to solve this problem. What have you been learning?
10:59:02 <josephle> ToTheInternet, I have a case that will cause your infinite loop
10:59:15 <josephle> > span isAlpha " hello"
10:59:17 <lambdabot>  (""," hello")
10:59:19 <mietek> Any IHaskell users?
10:59:29 <mietek> #ihaskell is empty.
10:59:41 <favetelinguis> The way i see it is that <+ is the exact same thing as ++ is for lists, but when i look at the source for ++ it uses : which cinda reminds me of Add but i cant get it to work, that is cinda what we have been going throgh what is relevant here i guess?
11:00:24 <HeladoDeBrownie> favetelinguis, your intuition about that is correct.
11:01:04 <HeladoDeBrownie> favetelinguis, it's entirely possible you're confused because of the syntactic differences between prefix and infix application. x:xs is just like (:) x xs
11:01:29 <ToTheInternet> josephle: ah. so i add this pattern: func ([],xs) lst = func (span isAlpha xs) lst
11:01:34 <merijn> goglosh: uh, I don't know what you did, but that looks suspiciously like "oh god, everything is broken"
11:01:38 <HeladoDeBrownie> favetelinguis, when you tried to approximate (++), what did your code look like (even if it was erroneous)?
11:01:47 <favetelinguis> 1 sec
11:02:06 <josephle> ToTheInternet, the problem is that xs never "gets smaller"
11:02:20 <ReinH> benzrf: what is your reasoning that fix S is not bottom?
11:02:50 <HeladoDeBrownie> @src (++)
11:02:51 <lambdabot> []     ++ ys = ys
11:02:51 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
11:02:51 <lambdabot> -- OR
11:02:51 <lambdabot> xs ++ ys = foldr (:) ys xs
11:02:51 <goglosh> merijn: yeah, and all I ever did was 'sudo apt-get install ghc'
11:03:06 <goglosh> merijn: pinky promise
11:03:24 <benzrf> ReinH: oh
11:03:26 <josephle> > " hello" == snd (span isAlpha " hello")
11:03:27 <benzrf> how is bottom defined
11:03:27 <lambdabot>  True
11:03:33 <benzrf> isnt bottom 'nonterminating
11:03:34 <benzrf> '
11:03:52 <ReinH> nontermination is bottom
11:03:58 <ToTheInternet> josephle: i see... hm
11:04:25 <ReinH> the function fix S has an approximating function f n = f (S n), which in the limit is bottom.
11:04:38 <ToTheInternet> josephle: func ([],x:xs) lst = func (span isAlpha xs) lst
11:04:47 <texasmynsted> Don Stewart is talking about a light-weight xen based vm for haskell at about 53:00 here http://www.youtube.com/watch?feature=player_detailpage&v=4YfkwfZ7AV4#t=3127
11:05:09 <texasmynsted> what is this?  I can't quite hear what he is saying Hallvm Hellvm, something else?
11:05:23 <ReinH> texasmynsted: https://github.com/GaloisInc/HaLVM
11:05:50 <ReinH> Oh from the Haskell Cast. Nice.
11:05:56 <texasmynsted> ReinH++
11:06:04 <texasmynsted> Thank you :-D
11:06:05 <goglosh> merijn: I actually uninstalled ghc and re-installed it, several times already, maybe it's debian's fault? :P
11:06:13 <ReinH> HaLVM is cool. We haven't been able to use it yet but it's very interesting.
11:06:39 <npasco> Does this function already have a name? splatComma :: ((a, b) -> c) -> (a -> b -> c) ; splatComma f = \x y -> f (x, y)
11:06:49 <ReinH> @src fix
11:06:49 <lambdabot> fix f = let x = f x in x
11:07:08 <HeladoDeBrownie> @type curry
11:07:09 <lambdabot> ((a, b) -> c) -> a -> b -> c
11:07:14 <HeladoDeBrownie> npasco, ^
11:07:26 <ReinH> Er, what I should say is, the approximating function for fix S is f_0 = _|_, f_1 = _|_, ..., which in the limit is _|_
11:07:27 <texasmynsted> Been enjoying the Haskell Casts.  As you can see I just started them. Hehe
11:07:27 <josephle> ToTheInternet: that should give you termination at least
11:07:36 <ReinH> texasmynsted: great :D
11:07:43 <ToTheInternet> josephle: seems to give correct results as well
11:08:06 <koala_man> @hoogle ((a, b) -> c) -> (a -> b -> c)
11:08:08 <lambdabot> Prelude curry :: ((a, b) -> c) -> a -> b -> c
11:08:08 <lambdabot> Data.Tuple curry :: ((a, b) -> c) -> a -> b -> c
11:08:09 <favetelinguis> HeladoDeBrownie: This is what i did to make it exactly as ++ http://lpaste.net/114193
11:08:25 <favetelinguis> and i do think it look wierd and returns bottom
11:08:28 <josephle> ToTheInternet: yep, should be fine in the common case. you might get strange results when you have more spaces between words
11:08:44 <npasco> HeladoDeBrownie: thanks. though the name is confusing because it's like the opposite of currying?
11:09:03 <npasco> i dunno
11:09:26 <HeladoDeBrownie> favetelinguis, it looks like you have the right idea, but you might be having trouble writing it down in Haskell
11:09:35 <HeladoDeBrownie> So let's look at the source of (++) again
11:09:37 <HeladoDeBrownie> @src (++)
11:09:38 <lambdabot> []     ++ ys = ys
11:09:38 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
11:09:38 <lambdabot> -- OR
11:09:38 <lambdabot> xs ++ ys = foldr (:) ys xs
11:09:52 <HeladoDeBrownie> favetelinguis, so you know what (:) and (++) would be equivalent to, right?
11:12:20 <npasco> Is there any practical dfference between ((a, b) -> c) -> a -> b -> c and ((a, b) -> c) -> (a -> b -> c) ?
11:12:36 <HeladoDeBrownie> npasco, none, (->) right-associates
11:12:42 <ToTheInternet> josephle: getWords2 "test " returns ["","test"]
11:12:45 <favetelinguis> HeladoDeBrownie: yes but they operate on different types only
11:12:54 <npasco> HeladoDeBrownie: ok thanks
11:13:04 <HeladoDeBrownie> favetelinguis, right
11:13:22 <ToTheInternet> span isAlpha "test "
11:13:35 <josephle> > span isAlpha "test " -- remember the >
11:13:37 <lambdabot>  ("test"," ")
11:13:47 <HeladoDeBrownie> npasco, by the way, curry is so named sort of because it turns an "uncurried" function into a curried one. There's also uncurry which goes the other way
11:13:50 <HeladoDeBrownie> @type uncurry
11:13:52 <lambdabot> (a -> b -> c) -> (a, b) -> c
11:14:31 <josephle> ToTheInternet: the list returned by getWords2 will have some empty strings if you have dangling whitespace or more than once space between words
11:14:37 <HeladoDeBrownie> favetelinguis, I can tell you you're close to figuring it out. I'm trying to help you step through to figure out what you missed.
11:15:04 <ReinH> merijn: I motivate this morally by pointing out that if fix S were a defined element of Nat then Nat would not represent the natural numbers ;)
11:15:22 <favetelinguis> yes good to know im close, i and to tired now to crack it but i prob get it in the morning, now i know i dont have to revere anyways :)
11:15:26 <favetelinguis> thanks for the help man
11:15:45 <HeladoDeBrownie> favetelinguis, all right, have fun.
11:16:03 <HeladoDeBrownie> favetelinguis, before you go, let me show you an alternative way to write the second clause of (++)
11:16:23 <HeladoDeBrownie> (x:xs) ++ ys = (:) x (xs ++ ys)
11:16:32 <HeladoDeBrownie> favetelinguis, that's slightly closer to your other type
11:17:21 <ToTheInternet> josephle: more than one space doesn't cause empty strings, dangling whitespace does though
11:17:47 <josephle> oh, interesting
11:18:53 <josephle> > filter (not null) ["hello","world",""]
11:18:54 <lambdabot>  Couldn't match expected type ‘[GHC.Types.Char] -> GHC.Types.Bool’
11:18:55 <lambdabot>              with actual type ‘GHC.Types.Bool’Couldn't match expected type ‘G...
11:18:55 <lambdabot>              with actual type ‘[a0] -> GHC.Types.Bool’
11:19:14 <josephle> oops
11:19:41 <josephle> > filter (not . null) ["hello","world",""]
11:19:43 <lambdabot>  ["hello","world"]
11:19:58 <josephle> ToTheInternet: you can use something like that to clean up the empty strings
11:20:09 <ToTheInternet> josephle: i added this pattern: func (x," ") = x:lst
11:20:37 <ToTheInternet> since there is only one case where a dangling space can occur, and that's at the very end of the string
11:20:37 <favetelinguis> HeladoDeBrownie: (Add c1 h1) <++ h2 = Add c1 (h1 <+ h2) , guess this just comes with practice, getting used to thinking recursivly and to see types
11:20:51 <sinelaw> isn't there join for Set? Set (Set a) -> Set a
11:21:13 <sinelaw> should be the same as union of all sets
11:21:29 <sinelaw> I can do it with from/to list but that doesn't seem efficient
11:21:48 <HeladoDeBrownie> favetelinguis, good job. See, you were just missing some parens.
11:22:20 <favetelinguis> yes :)
11:22:27 <favetelinguis> how long have you been doing haskell
11:22:39 <josephle> sinelaw: could you do a set fold with intersection?
11:22:46 <HeladoDeBrownie> I haven't bothered keeping track, but it must be more than a year by now, maybe more than two
11:22:51 <ToTheInternet> josephle: ok... now, the problem is not only strings, but any type of dangling non-alphanumeric chars.
11:23:19 <sinelaw> josephle, with union, no?
11:23:27 <josephle> sinelaw: oops, you're right
11:23:40 <sinelaw> I could, but it seems natural that set would have this
11:24:42 <josephle> ToTheInternet, that's the weakness of isAlpha/isAlphaNum. You can also use (\x -> not (isSpace x))
11:24:48 <josephle> or more elegantly, (not . isSpace)
11:25:23 <L8D> or even more elegantly, (invert isSpace)
11:25:44 <L8D> @hoogle (a -> Bool) -> a -> Bool
11:25:45 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
11:25:45 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
11:25:45 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
11:25:51 <HeladoDeBrownie> I would have had to look up invert but for the context
11:26:08 <ToTheInternet> josephle: func (x, y:[]) lst = x:lst
11:26:17 <Gurkenglas> :t invert
11:26:18 <lambdabot>     Not in scope: ‘invert’
11:26:18 <lambdabot>     Perhaps you meant one of these:
11:26:18 <lambdabot>       ‘IM.insert’ (imported from Data.IntMap),
11:26:19 <ToTheInternet> josephle: since a single char is never a word
11:26:27 <y> L8D: that sounds like ($)?
11:26:47 <L8D> y: what?
11:26:53 <L8D> ($) is function application
11:26:53 <HeladoDeBrownie> y, no, because you can pick whatever members of Bool you want
11:27:02 <josephle> ToTheInternet: you mean single non-alphanumeric char?
11:27:06 <L8D> :t ($)
11:27:07 <lambdabot> (a -> b) -> a -> b
11:27:18 <HeladoDeBrownie> y, you would be right if you didn't know that the type were Bool or any other specific type, though
11:27:44 <L8D> ($) = id
11:27:47 <ToTheInternet> josephle: no, any single char. at least in german. i don't think there is a german word consisting of a single char.
11:28:02 <josephle> ok
11:28:19 <y> HeladoDeBrownie: er, pick members of bool?
11:28:35 <y> apply the function, and then do something to the result is the only thing I can think
11:28:43 <HeladoDeBrownie> y, you can look at what the output of the original function is, see it's False or True, and decide to return False or True based on that.
11:29:14 <ToTheInternet> josephle: but then again, the function would place single chars in the list if they occur in the middle of the input string
11:29:23 <HeladoDeBrownie> y, as such there are several values of (a -> Bool) -> a -> Bool; there's const (const True) and const (const False), for example
11:29:39 <HeladoDeBrownie> @type const (const True)
11:29:40 <lambdabot> b -> b1 -> Bool
11:30:03 <L8D> what's the defacto library for parsing ECMAScript?
11:30:17 <y> @type (not .) . ($)
11:30:18 <lambdabot> (a -> Bool) -> a -> Bool
11:30:29 <L8D> :t (not .)
11:30:30 <lambdabot> (a -> Bool) -> a -> Bool
11:30:37 <HeladoDeBrownie> Note that ($) is just specialized id, so you can omit it in a composition chain
11:30:40 <y> oh well
11:31:06 <y> that works too :)
11:32:10 <L8D> :t (.) not
11:32:11 <lambdabot> (a -> Bool) -> a -> Bool
11:33:35 <ToTheInternet> josephle: it works now as intended i think. thanks for your help, i have to get going. bye :)
11:34:02 <Denommus> :t (not.)
11:34:04 <lambdabot> (a -> Bool) -> a -> Bool
11:34:37 <Denommus> :t (.not)
11:34:38 <lambdabot> (Bool -> c) -> Bool -> c
11:37:30 <L8D> :t unsafeCoerce
11:37:31 <lambdabot> Not in scope: ‘unsafeCoerce’
11:38:02 <y> a → b
11:38:45 <L8D> > unsafeCoerce (1 :: Int) :: Integer
11:38:46 <lambdabot>  Not in scope: ‘unsafeCoerce’
11:42:57 <clrnd> any library to ouput tabular-like text?
11:42:59 <clrnd> tables
11:44:58 <clrnd> clrnd, boxes looks nice
11:51:34 <joshkirklin> I have a simple problem that the extensible-effects library demonstrates well
11:51:50 <joshkirklin> say I'm testing things in ghci, and I want to use https://hackage.haskell.org/package/random-eff
11:53:14 <joshkirklin> I want to get a random Int, so I try something like "(runLift $ evalRandIO getRandom) :: IO Int" and that works fine
11:53:38 <joshkirklin> If I wanted to move that type annotation next to getRandom, what would I type?
11:54:03 <joshkirklin> obviously it will be of the form Eff r Int
11:54:34 <joshkirklin> but how can I make it flexible enough so that I won't need to change it frequently
11:54:35 <joshkirklin> ?
11:57:01 <Denommus> meh, Qt recommends QML even when working in other languages
11:57:01 <Denommus> Gtk3 breaks all the time
11:57:11 <Denommus> where are the good GUI toolkits that I can use in Haskell? -.-
11:57:26 <Denommus> maybe I should make a Gtk2 DSL for Haskell
11:57:30 <y> wx?
11:57:41 <dmj`> jle`: ping
11:57:51 <Denommus> oh, yeah, Gtk2 is not cross-platform
11:57:58 <Denommus> is wx even worth my effort, though?
12:01:36 <HairyDude> been trying with wx myself, been having much more success than with gtk3
12:02:13 <jle`> dmj`: sup?
12:04:37 <HairyDude> I have a toy gui program with a list on the left and an image on the right, which is supposed to change depending on what's selected
12:04:55 <HairyDude> however, the image is downloaded on demand, so there's a delay
12:05:32 <HairyDude> I have the "download, update and repaint" code run in a separate thread, but when I build the thing with cabal only the first one actually works
12:06:49 <HairyDude> it's all very responsive running from ghci but building it breaks it :/
12:08:32 <Denommus> HairyDude: how verbose is it to create a GUI in wx?
12:08:45 <HairyDude> Denommus: much less than gtk3
12:09:01 <Denommus> a DSL would be nice, nevertheless
12:09:54 <kadoban> I wonder if HsQML is worth considering. It sounds useful...not many downloads though, wonder if it's just a toy or useful.
12:10:03 <HairyDude> Denommus: the wx devs deliberately avoided a DSL because their aim was just to have something that works, rather than a proper high level declarative interface which is "very much a research area"
12:11:58 <HairyDude> Denommus: btw GUI programming is something new for me, I'm learning as I go
12:14:18 <L8D> @hoogle Num a => [a] -> a
12:14:18 <lambdabot> Prelude product :: Num a => [a] -> a
12:14:18 <lambdabot> Data.List product :: Num a => [a] -> a
12:14:18 <lambdabot> Prelude sum :: Num a => [a] -> a
12:15:35 <L8D> > sum . map read $ ["1", "2", "3"]
12:15:37 <lambdabot>  6
12:15:49 <L8D> > sum . map read $ ["1", "2", "3", "3"]
12:15:51 <lambdabot>  9
12:15:54 <L8D> > sum . map read $ ["1", "2", "3", "foo"]
12:15:55 <lambdabot>  *Exception: Prelude.read: no parse
12:15:58 <sinelaw> L8D, /msg lambdabot
12:16:01 <L8D> sry
12:18:23 <sinelaw> I have some stuff in EitherT that verifies constraints but doesn't return meaningful results. My problem is that apparently the thing is never evaluated because the result isn't used. Am I doing something wrong? I expected the evaluation to happen anyway because the EitherT needs to know if to fail or not
12:19:34 <S11001001> just encountered pattern guards for the first time; this is crazy
12:20:01 <simpson> Yes.
12:20:11 <simpson> Although I always feel like pattern guards must be so expensive...
12:20:50 <Saizan> sinelaw: the binds are going to check, yep
12:21:43 <Javran> @hoogle Word8 -> Char
12:21:43 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
12:21:44 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
12:21:44 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
12:22:04 <Javran> @hoogle [Word8] -> String
12:22:04 <lambdabot> Language.Haskell.TH.Ppr bytesToString :: [Word8] -> String
12:22:05 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
12:22:05 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
12:23:26 <jle`> Javran: the problem is that Char is not necessarily representable in a Word8
12:23:57 <jle`> *a char
12:23:59 <nitrix> Is there a maybe variant where I could have the second and last argument be an `IO x` ?
12:24:07 <jle`> nitrix: hm?
12:24:14 <jle`> types pls :)
12:24:45 <nitrix> jle`: https://github.com/nitrix/udfs/blob/develop/fs-haskell/main.hs#L51
12:25:14 <jle`> looks like fmap
12:25:21 <nitrix> jle`: Originally had the case, then commented that out to write a more terse version using maybe, but I can't simplify it :(
12:25:24 <jle`> hm
12:25:31 <jle`> oh i see
12:25:35 <jle`> looks like bind
12:25:52 <nitrix> :t bind
12:25:53 <lambdabot>     Not in scope: ‘bind’
12:25:53 <lambdabot>     Perhaps you meant one of these:
12:25:53 <lambdabot>       ‘BS.find’ (imported from Data.ByteString),
12:26:00 <nitrix> What's bind?
12:26:01 <jle`> :t \x f i -> maybe x f =<< i
12:26:02 <lambdabot> Monad m => m b -> (a -> m b) -> m (Maybe a) -> m b
12:26:23 <jle`> bind is (=<<) ( or (>>=) )
12:26:28 <jle`> it's contested
12:26:43 <jle`> or...both have been called bind
12:27:09 <orbital> what do people call (>>)?
12:27:21 <jle`> i've heard it called `then`
12:27:34 <jle`> or andThen
12:27:39 <orbital> cool
12:27:49 <jle`> putStrLn "hello" >> putStrLn "world"
12:27:52 <jle`> print hello then print world
12:28:12 <sinelaw> Saizan, for some reason it's not evaluating. the computation is in a forM. could that be a problem?
12:28:29 <sinelaw> doesn't make sense. it needs to evaluate to know if the forM succeeds
12:28:48 <Saizan> how are you checking whether (and what) gets evaluated?
12:28:56 <jle`> nitrix: oh, but for your specific code
12:29:00 <sinelaw> Saizan, traceShowId
12:29:11 <jle`> i think case is fine
12:29:37 <jle`> do you ever use the result of obtainBlock.../
12:29:39 <jle`> ?
12:29:58 <nitrix> jle`: Yeah.
12:30:01 <Saizan> sinelaw: and on what?
12:30:18 <nitrix> jle`: That's what I've been told, it's very explicit, but I was curious how terse it could get if it was an actual haskell dev writing idomatic code.
12:30:19 <jle`> where?
12:30:30 <Saizan> not the EitherT action, i presume
12:30:31 <jle`> it looks like you just use whether or not it's Just or Nothing
12:30:47 <sinelaw> Saizan, like this: forM stuff $ \x -> do ... return . traceShowId result
12:30:47 <jle`> idiomatic code doesn't necessarily mean terse code
12:31:01 <nitrix> jle`: Almost, the Nothing actually calls the same function again, recursively, but with the xs of the list.
12:31:13 <jle`> many times the idiomatic way is less terse way
12:31:28 <jle`> nitrix: but where do you use the value inside the Just?
12:31:32 <sinelaw> Saizan, oh, maybe it evaluates everything but the actual result, because it already determines that it succeeds
12:31:39 <Saizan> sinelaw: right
12:31:42 <sinelaw> ok
12:31:43 <sinelaw> thanks
12:32:06 <jle`> oh
12:32:09 <jle`> you return the value as-is
12:32:21 <jle`> so it's just a search
12:32:24 <nitrix> jle`: Oh I do not then. The purpose of the obtainAnyBlock is to run a bunch of obtainBlock on a list of Resource and return the first Just it gets.
12:32:25 <jle`> a `find`
12:32:31 <jle`> looks like a findM
12:33:38 <jle`> hm
12:33:43 <jle`> nothing quite in monad-loops
12:34:25 <nitrix> findM f = runMaybeT . msum . map (MaybeT . f)  ?
12:34:57 <nitrix> That's becoming quite complicated from my original recursive function with a case x]
12:35:17 <jle`> i'm pretty sure case is probably the best way to do this
12:35:31 <jle`> maybe you could even use if/then on isJust/isNothing
12:35:43 <sinelaw> thanks
12:36:29 <jle`> hm
12:36:46 <y> view patterns? pattern guards?
12:37:44 <jle`> nitrix: perhaps you can use the Alternative instance of MaybeT
12:37:54 <jle`> oh that's what you did.
12:37:56 <nitrix> jle`: what about a recursive fromMaybe ?
12:38:25 <nitrix> Since I already have the [] edge case.
12:38:51 <dementorr> Hello, Is there a way for me to change the value of a list in haskell? I mean I have a function f that takes an array and returns 3 consecutive items. Now I want to remove the second item in the set and reapply f. The problem is that I need the answer for f to compute the remaining list resulting in a deadlock: http://pastebin.com/g9ZHyHsB I see there is infinite loop in lista. How can I remove it?
12:39:21 <jle`> nitrix: fromMaybe then you'd have to deal with re-wrapping and stuff anyway
12:39:22 <dementorr> What am I trying to is: having a list xs i want to remove some element then for the new list, remove some other element etc.
12:39:25 <jle`> unless i'm misunderstanding you
12:40:00 <jle`> dementorr: if `f` is a function, then it should have a return type :)
12:40:39 <dementorr> um.. it has : (Int, Int, Int) its a constant function I guess
12:40:44 <dmj`> dementor: y is not defined in lista
12:40:46 <dementorr> anyway its defined in where
12:40:58 <dmj`> dementor: (Int, Int, Int) is a value, not a function
12:41:10 <dementorr> all my code from there is defined in a where clause
12:41:19 <jle`> oh i see
12:41:23 <dementorr> so mylist has access to y
12:41:26 <jle`> i see what you are trying to do now
12:41:28 <jle`> sry :)
12:42:08 * hackagebot rethinkdb-client-driver 0.0.8 - Client driver for RethinkDB  http://hackage.haskell.org/package/rethinkdb-client-driver-0.0.8 (wereHamster)
12:45:10 <dementorr> So I have a big list xs. And I got some function f that returns some element in xs. After that I want to delete the element that f returned from list xs, then reapply f. Something like [1, 2, 3, 4, 5] and i apply f ([1,2,3,4,5]) = 3 => new list should become [1, 2, 4, 5], now apply again f => f ([1, 2, 4, 5]) =1,delete 1 from old list, now list is [2, 4, 5] etc.
12:46:06 <dmj`> dementor: it sounds like an IntMap might be a better data structure for you
12:46:11 <dmj`> than a linked list
12:46:34 <mietek> refold: hi!
12:46:42 <refold> mietek: hi!
12:47:52 <mietek> refold: I've been inviting interested people to #HaskellOnHeroku, but I just started #haskell-deployment in order to emphasise the general nature of the solution
12:49:23 <refold> mietek: does your work make it possible to release packages with git deps? or is it more like 'sandbox add-source git://..'?
12:50:13 <jle`> hey isn't there someone on the heroku dev team on here
12:50:18 <Gurkenglas> dementorr, what do you want to return in the end? A list of the elements of the list in the order they were extracted?
12:50:25 <mietek> refold: release packages: no, that would make sense as a modification to Cabal.
12:50:44 <mietek> refold: my work is about helping Cabal become a package manager.
12:51:08 <Gurkenglas> Does the order of the list matter for the result of f?
12:51:09 <mietek> refold: in other words, making it possible to deploy (install) an app with a single command
12:51:15 <luite> mietek: have you given any thought to what kind of deployment things you'd want from Cabal/cabal-install for client side JavaScript apps? I'm going to finish the initial patch for GHCJS support in Cabal soon (after I fix the last issue with GHCJS on GHC 7.9)
12:51:31 <refold> mietek: understood
12:52:05 <mietek> refold: the goal is also to make it easy to do iterative development/deployment
12:52:08 * hackagebot trace 0.1.0.1 - A monad transformer for tracing provenience of errors  http://hackage.haskell.org/package/trace-0.1.0.1 (JonSterling)
12:52:11 <luite> mietek: I'm adding a new js-sources field to include JS libraries and glue code in package, similar to c-sources, they're run through the preprocessor, so deployment-specific things can be configured through cpp-options
12:52:39 <mietek> refold: so that you can iterate on your app, committing and pushing changes, and seeing results in seconds, without having to wait for stuff to compile
12:52:54 <dementorr> Gurkenglas: yes it does
12:53:10 <dementorr> Gurkenglas: based on that order it will return different values
12:53:10 <mietek> refold: that's all done. I'm currently working on examples and documentation.
12:53:28 <Gurkenglas> dementorr, and what do you want returned by the whole thing?
12:53:52 <mietek> luite: I don't have any specific thoughts about this. Perhaps paf31 (#purescript) would be the one to ask.
12:54:04 <mietek> luite: or #idris
12:54:07 <luite> mietek: the other changes are more internal, and a new impl(ghcjs) flag, and ghcjs-options fields. if you have any ideas of "it would be nice if it could do X" then now would be the easiest time to change things
12:54:35 <Gurkenglas> dementorr, can the list contain duplicates?
12:54:50 <luite> mietek: oh one other thing, the data-files of a package are available through some web directory to the client
12:55:02 <luite> so library packages can include static assets
12:55:03 <dementorr> Gurkenglas: So I don't know how to explain. It's for a triangulation. If I got [p1, p2, p3, p4 .. ] i would like to remove p2 for example, then get p5 prehaps..
12:55:09 <dementorr> No duplicates in the list
12:55:12 <mietek> luite: some web directory?
12:55:59 <Gurkenglas> The algorithm you want takes a ([a]) and a ([a]->a). What is it supposed to return?
12:57:09 * hackagebot postgresql-binary 0.2.2 - Encoders and decoders for the PostgreSQL's binary format  http://hackage.haskell.org/package/postgresql-binary-0.2.2 (NikitaVolkov)
12:57:35 <dementorr> So it takes a list, returns a lists of lists containing triples of points in the list, so for ints: [Int] -> [(Int, Int, Int)], where the triple is made using consecutive items from the first [Int]
12:57:46 <dementorr> a list of triples*
12:58:16 <Gurkenglas> Well that's easy.
12:58:22 <luite> mietek: yeah i need to work out the details, but say you write a package named 'somelib', and you have allIcons.svg listed in the data-files, then it should be loadable from the URL ("./data" </> Paths_someLib.packageKey </> "myIcons.css") relative to the index.html that GHCJS generates
12:58:25 <Gurkenglas> And has nothing to do with your first question :D
12:58:34 <dementorr> For example: f ([1, 2, 3, 4]) = [(1, 2, 3), (1, 3, 4) (since 2 was gone in the first round)]
12:58:46 <luite> mietek: err. .svg obviously
12:58:47 <Gurkenglas> Wait, what
12:59:15 <Gurkenglas> Oh, you want the first three each time. Okay.
12:59:21 <dementorr> the thing is that after the first round I find lets say 2, the old list ([1,2,3,4]) becomes ([1,3,4])
13:00:28 <dementorr> not necesairy the first (it may be random for example: f [(1,2,3,4)] = [ (1, 3, 4), (1, 2, 4)(since I removed 3 in first run)] I got a function that tells me what I should remove next given a [Int[
13:00:33 <mietek> luite: well, there is already the notion of a datadir, right?
13:00:34 <Gurkenglas> Lets just extract the "take first three" out of the problem and generate simply the lists
13:00:42 <Gurkenglas> You can turn that into the first three elements afterwards
13:00:55 <luite> mietek: yes but that is a filesystem path, and absolute
13:01:08 <luite> mietek: client side code obviously doesn't have access to the filesystem
13:01:32 <dementorr> but that is something like f (x : y : z: xs) = (x, y, z) : f (y, z, xs)
13:01:37 <mietek> luite: Yes.  What I mean is, I'm not sure if it's cabal's job to declare how URLs will look like.
13:01:52 <Gurkenglas> Why did you take out x
13:02:27 <mietek> luite: but I have to confess, I haven't used GHCJS yet, so perhaps it does fit with the overall strategy.
13:02:31 <dementorr> At each iteration I chouse a random item (lets say first for example) and in the next run I should not use it again
13:02:44 <mietek> luite: I've been focusing on getting things to install correctly; not so much on the actual front-end development.
13:02:49 <luite> mietek: Cabal doesn't have to do much. the only change it needs is that it records the data location in the package registration info. it's then up to the compiler to actually make it available when linking an app
13:03:57 <Gurkenglas> Well you solved your problem already right there...
13:04:17 <luite> mietek: so to be able to use it, the only requirement is that the location is consistent and somehow derivable from the information available when compiling the lib
13:04:30 <Gurkenglas> If you only want to take out the first then all is well
13:07:09 <dementorr> Yes, but if I have a function g that says I should remove element 5, then the next list should contain elements 0-4, 6 - ..., and then apply f to the new list
13:07:44 <luite> mietek: the use case for this is haskell bindings for libraries like jquery-ui, yui, closure library. those contain static assets, images, css files, html templates, that should be available to code that uses the lib. the goal is that compiling any app, even with complex (data) dependencies, always results in an index.html that works immediately when loaded into a browser
13:08:16 <Gurkenglas> You can try "iterate (\list -> delete (g list) list)" on your list to get a list of the successively reduced lists.
13:08:32 <Cale> dementorr: You might find this function helpful:
13:09:04 <Cale> select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
13:09:42 <Cale> (I haven't been following the whole conversation though, so I might be confused about what you're looking for)
13:09:49 <luite> mietek: for development that should be a good starting point, for deployment, users can then write their own scripts and optimize asset locations. but it should work out of the box, without any configuration
13:09:59 <Cale> @let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
13:10:00 <mietek> luite: I can certainly subscribe to this goal.
13:10:01 <lambdabot>  Defined.
13:10:04 <Cale> > select [1,2,3,4]
13:10:06 <lambdabot>  [(1,[2,3,4]),(2,[1,3,4]),(3,[1,2,4]),(4,[1,2,3])]
13:10:33 <dementorr> Cale: yes .. thx now I should only check for fst and if its equal just select the list
13:10:39 <dementorr> Ill try thtat
13:11:02 <Gurkenglas> > delete 8 [2,4,67,7,3,8,7,5]
13:11:04 <lambdabot>  [2,4,67,7,3,7,5]
13:11:13 <dfeuer_> Why aren't IOArrays Functors?
13:11:42 <Cale> dfeuer_: Because all the operations on IOArray require IO
13:12:00 <dfeuer_> So ....
13:12:16 <Cale> So how do you write fmap?
13:13:01 <Cale> Or perhaps first: what's the type of fmap?
13:13:04 <Gurkenglas> dfeuer_, because i should be Ix and only specific e are supported?
13:13:13 <Gurkenglas> -?+maybe
13:13:15 <dfeuer_> Gurkenglas, that's not it.
13:13:26 <dfeuer_> I think Cale must be right somehow.
13:13:43 <dfeuer_> Yeah.
13:14:11 <Cale> For IOUArray, things are even harder, and Gurkenglas is right in that case.
13:14:18 <dfeuer_> Yes.
13:14:22 <Gurkenglas> Why not (a->b) -> (IOArray i a -> IOArray i b)?
13:14:36 <vanila> ,(a->b) -> (IOArray i a -> IO (IOArray i b)) maaybe possible
13:14:41 <Cale> Yes, that would be the type of fmap
13:14:41 <luite> mietek: it's been the strategy for ghcjs in general, i don't want to give up too much compatibility with existing haskell packages. for example Data.Text isn't ideal for performance and code, but supporting the text package makes it possible to compile and run many other packages.
13:14:43 <Gurkenglas> Ah, didnt see that U above where it restricts the e.
13:14:46 <luite> mietek: then you have a baseline version, and hopefully GHC 7.10 will make it easier to improve from there, for example replacing a hardcoded Data.Text dependency with a backpack signature, which could be implemented with a Data.JSString under the hood.
13:15:22 <Cale> The problem is that it's very hard to write a function of this type, because you have almost no operations to construct IOArrays which don't involve executing IO actions.
13:15:24 <dfeuer_> Gurkenglas, it doesn't. IOUArray does.
13:15:40 <dfeuer_> The problem is that these aren't really arrays; they're actually references to ararys.
13:15:46 <dfeuer_> Which I didn't realize.
13:16:01 <Gurkenglas> Yes, I knew that and there is misunderstanding between us, but not between me and Cale
13:16:13 <Gurkenglas> (Maybe even (i->j) -> (IOArray j e -> IOArray i e)?)
13:16:24 <dfeuer_> Gurkenglas, there is no restriction on what elements can be in an IOArray, so that's not related.
13:16:41 <Gurkenglas> Yes, that is what I just tried to say I knew
13:16:48 <dfeuer_> Oh, changing the index type... that might be possible.
13:16:54 <Cale> You *do* have mapArray and mapIndices
13:17:12 <Cale> Which are part of the MArray interface
13:17:17 <Cale> mapArray :: (MArray a e' m, MArray a e m, Ix i) => (e' -> e) -> a i e' -> m (a i e)
13:17:21 <Cale> mapIndices :: (MArray a e m, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> m (a i e)
13:17:22 <luite> mietek: i sure hope it will become usable for these things soon, since i spent more than enough time making ghcjs support the backpack PackageKey things over the past two weeks :)
13:17:30 <clrnd> infix operators can be your best friend or your best Enemy
13:18:21 <dfeuer_> It's rather unfortunate that the array stuff relies deeply on list fusion.
13:19:04 <Denommus> can GHCJS be used instead of Julius in Yesod?
13:19:21 <jp_rider> hi
13:19:37 <jp_rider> is there a way to define a function like this: http://lpaste.net/4798079567484944384 ??
13:20:04 <Cale> dfeuer_: hm?
13:20:45 <dfeuer_> Cale, I went into GHC.Arr to implement amap/coerce to match the map/coerce rule in GHC.Base. And I found I had to rewrite amap first:
13:20:53 <luite> Denommus: not really instead of. you can write a package that can be compiled either with GHC or GHCJS, or write multiple packages that share some code. Cabal does not support multiple compilers for a single build at the moment
13:21:22 <dfeuer_> amap/coerce needs to delay inlining amap until phase 1, but list fusion doesn't really work that late.
13:21:27 <Denommus> luite: ah, that's a shame
13:21:27 <Cale> jp_rider: I'm not sure I understand the question :)
13:21:32 <benzrf> what's amap
13:21:42 <Cale> jp_rider: Does this code typecheck?
13:21:46 <Denommus> luite: I wanted to test FRP in Yesod, just to show my brother
13:21:47 <dfeuer_> benzrf, it's fmap for Array.
13:21:59 <benzrf> o
13:22:02 <luite> Denommus: snoyberg has some example of a web app with yesod and GHCJS where the client and server part are built from the same data structure and communication is type safe
13:22:04 <dfeuer_> It's also a function on IArray, but that's a different amap.
13:22:07 <jp_rider> so I guess WidgetT is basically a writer monad
13:22:12 <Cale> oh, there's a hole in it
13:22:25 <Denommus> luite: ah, that would be cool!
13:22:44 <Denommus> luite: is the client part a SOA?
13:22:56 <Denommus> luite: sorry
13:22:56 <jp_rider> yea, i guess I want to extract the right side of the tuple, but return the left side of the writer monad
13:23:08 <Cale> jp_rider: It looks like some combination of a reader and writer
13:23:10 <Denommus> luite: single-page application
13:23:12 <luite> Denommus: http://www.yesodweb.com/blog/2014/10/slides-conduit-ghcjs
13:23:17 <Cale> newtype WidgetT site m a = WidgetT
13:23:17 <Cale>     { unWidgetT :: HandlerData site (MonadRoute m) -> m (a, GWData (Route site))
13:23:17 <Cale>     }
13:23:37 <Cale> ^^ and there's an instance of Monoid (GWData a)
13:24:32 <Denommus> luite: using Elm could also be a nice option, don't you think?
13:24:54 <jp_rider> Cale: right.. i guess i could mappend somethings together?
13:25:15 <luite> Denommus: yeah, I think it just uses a single API route and loads the app from static files (so it's probably easy to port it to other web frameworks)
13:25:44 <assia_t> What's haskell's equivalent of an EventEmitter?
13:26:24 <Denommus> luite: oh! So yeah, probably single-page application, on the fashion of AngularJS
13:26:27 <Cale> jp_rider: Well, it's not entirely clear what the goal is here -- you want to produce a WidgetT action as the first part of the result of this WidgetT action that you're writing -- what should that action do?
13:26:42 <Denommus> assia_t: what is an EventEmitter?
13:26:45 <Cale> jp_rider: You could obviously just have it be  return (), but that's really boring
13:26:47 <luite> Denommus: yeah with Elm you can't really actually share code, but you could take the template haskell route and a similar web service API ADT, and write an Elm code generator for that
13:27:14 <assia_t> Denommus: The observer pattern
13:27:32 <assia_t> (in JavaScript)
13:27:47 <Denommus> assia_t: I'm experimenting using Functional Reactive Programming for events and behaviors instead of the usual observer or callback approach
13:27:49 <jp_rider> the WidgetT action should preserve the state of the initial WidgetT argument, but also extract the right side of the tuple
13:28:04 <Cale> It's possible to think of FRP as being a better version of the Observer pattern.
13:28:29 <Cale> I'm not sure an answer like that is helpful to a beginner though...
13:28:54 <assia_t> Can you show me how you'd add logging to a function with FRP?
13:29:00 <Cale> It's probably possible to just express what you would have expressed in an OO setting in much the same way.
13:29:16 <Denommus> assia_t: well, that would depend on the library
13:29:22 <Cale> Taking on a whole FRP system just to add logging to something isn't really appropriate
13:29:35 <luite> Denommus: doesn't really have to be Template Haskell either, but that might be the easiest way. GHC.Generics can be used instead, but you'd need to figure out a way to run the API generator as part of the Elm build process, or before. I'm not too familiar with that
13:29:36 <Denommus> assia_t: but let's say you're using reactive-banana
13:30:05 <Denommus> assia_t: one minute
13:30:14 <luite> Denommus: also i'm not 100% sold on FRP yet, many things that Elm uses FRP for are easier done with Haskell and GHCJS in plain old threads :)
13:30:36 <assia_t> Cale: That's why I asked the question.
13:30:53 <Cale> assia_t: So is the goal to add logging to something? Can we see what it is?
13:31:01 <Denommus> luite: I want to experiment with FRP for a number of reasons. I'm not sure if it is a GOOD approach for anything, but it's definitely interesting and I want to experiment with it
13:31:20 <Denommus> assia_t: ok. I'll try to give you a briefing
13:31:54 <Denommus> assia_t: say you have a behavior called `fooValue` (a behavior is a value that varies through time)
13:32:08 <assia_t> Cale: I'm writing a bitorrent client and am stuck on managing state and plugging things together. https://github.com/yamadapc/butter-core
13:32:26 <Denommus> assia_t: in reactive-banana, you could produce an event for all the time fooValue changes with changes fooValue
13:32:34 <Cale> assia_t: Cool, where should I look?
13:32:47 <assia_t> Cale: I'm not asking because I need to ask to add logging, just to try to understand stuff
13:33:05 <assia_t> Cale: Plus, the code on github is quite different from what I have on my machine
13:33:10 <Cale> assia_t: Are the things which need to do logging mostly IO actions?
13:33:28 <assia_t> Cale: Possibly
13:33:53 <Cale> assia_t: If so, one relatively flexible thing you can do is pass to them an argument of type (String -> IO ())
13:33:56 <Denommus> assia_t: now that you have an event, you can produce a IO event from it with fmap (or (<$>), which is the same thing as fmap), and pass this event to the reactimate' function
13:34:12 <Cale> and then supply an argument which does logging as you see fit
13:34:38 <luite> Denommus: yeah it's interesting, but not quite a solved problem. and i wonder if it would've been the go-to solution for many client side problems if JavaScript had had lightweight threads from the start
13:34:46 <Denommus> assia_t: in code, that would be: reactimate' $ fmap (print <$>) $ changes fooValue
13:36:08 <Denommus> assia_t: there's both fmap and <$> there because changes produces a Future (Event t a), so you must unbox the value from both the Event and the Future. The type of the value is the "a", "t" is just an additional parameter used for optimization in reactive-banana
13:36:42 <Denommus> luite: I don't see FRP as equivalent to threading. It's an approach on event handling
13:36:52 <Denommus> luite: it may be either synchronous or asynchronous
13:37:12 <Denommus> assia_t: sorry, I was wrong, changes produces an Event t (Future a)
13:37:15 <mmachenry1> Does anyone have experience with Oracle libraries. There are a few of them out.
13:37:34 <Denommus> luite: event handling AND time-varying values
13:37:36 <Cale> assia_t: In general, one nice trick to mediating access to state is to split up the ends of something like an IORef by creating the IORef, and then pre-applying readIORef and writeIORef to it, and passing the resulting IO action and function to the things which need read and write access to that state.
13:37:47 <Cale> assia_t: Then it becomes easy to log changes to the state
13:38:02 <Cale> because you just modify those so that they also write to the log
13:38:28 <Cale> Or you can change how those things behave in the face of concurrency by replacing the IORef with an MVar for instance
13:38:29 <luite> Denommus: no it's not an alternative for threading, but for example XMLHttpRequest or other async things are typically done with FRP in Elm, while I think that just blocking IO with a lightweight thread is more convenient (especially if you factor in exceptions, timeouts, retries, fallbacks)
13:38:33 <Cale> Or with a Chan
13:39:39 <Cale> assia_t: I don't know how much sense that makes in your particular situation, but in the past, I've used it for logging quite effectively.
13:40:05 <Cale> (Well, for a recording/playback sort of logging of changes)
13:41:31 <Denommus> luite: XMLHttpRequest is done with FRP because FRP is a nice way to abstract that the value that will be taken depends on the event of it arriving
13:42:13 <assia_t> Okay. I'll try things out. Thanks.
13:42:15 <Denommus> luite: I think FRP is nice because it's a great way to encode mutability in an apparently pure way
13:42:58 <Denommus> luite: and when I say great, it's GREAT
13:44:15 <luite> Denommus: nah i think that's just rationalizing after the fact. a single XHR is not a time-varying value, the only change is from no result to a result. and there's only one event. so it's not really using FRP very much at all, it's just use because the infrastructure is there and there's no convenient alternative
13:44:22 <Denommus> luite: because it not only encodes mutability: it makes all the changes of the time-dependent value explicit on declaration, it makes it easier to work with IO operations on higher levels of abstraction, and it makes asynchronicity a choice of the runtime
13:44:50 <Denommus> luite: that's a perfectly reasonable time-varying value
13:44:54 <Cale> assia_t: You might also take some inspiration from the way that Combinatorrent does things. I can't really speak to the quality of its code, but it looks pretty reasonable :)
13:45:34 <merijn> Denommus: I agree with luite that that's not really FRP at all
13:45:39 <assia_t> Cale: There's a pretty well written library https://github.com/pxqr/bittorrent/ as well
13:45:40 <Denommus> luite: in fact, in most FRP libraries you'll find functions to provide just that: a const value that only exists after an event has happened
13:45:56 <merijn> Denommus: Most libraries claiming to be FRP are not FRP at all
13:46:13 <Denommus> merijn: what is "not FRP" about that?
13:46:15 <merijn> Although I recognise conal has mostly lost the terminology fight,
13:46:23 <Denommus> merijn: (not that I think Elm is FRP)
13:46:30 <merijn> Denommus: FRP is about denotational semantics and continuous time
13:46:40 <merijn> Denommus: Most "FRP" libraries toss out both facts
13:46:43 <luite> Denommus: if it's many XHR responses coming in, each updating some data in the FRP network, then I'd say you have a point. but then the clean mapping only works nicely if you see the respons really as independent from teh request. for example timeouts and fallbacks, cancelling an earlier request if a user does something new, make the mapping to FRP a lot less clean
13:47:02 <assia_t> Cale: I can't say anything about code quality in haskell. But combinatorrent doesn't fit what I'm aiming at.
13:47:06 <merijn> FRP nowadays seems to just mean "event driven", which is sad, because event driven already perfectly describes that
13:47:11 * hackagebot help-esb 0.1.3 - A Haskell client for the Help.com team's ESB.  http://hackage.haskell.org/package/help-esb-0.1.3 (suitupalex)
13:47:31 <Denommus> merijn: ok, and what is thrown away when you abstract a value taken from a XmlHttpRequest as a Maybe behavior that becomes a Just after the event has happened?
13:47:31 <Cale> merijn: I sort of agree and sort of disagree :D
13:47:59 <Cale> merijn: Yes, there's too much event focus in the current set of popular implementations, because events are the easier side of things to implement
13:48:05 <luite> Denommus: so my point is not that FRP is wrong here, but that i think normal threads are more convenient for the low-level XHR stuff, then when your thread has actually received and processed some data update from the server, it can still post this to the FRP network
13:48:05 <Denommus> luite: well, I agree
13:48:07 <merijn> Denommus: I'm not saying you can't model XHR using FRP
13:48:17 <merijn> I'm saying that FRP is *more* than what most libraries implement
13:48:28 <dutchie> i'm confused why i'm getting a "file name does not match module name" error. I have src/ModName.hs, src/ModName/Sub.hs and I get "Saw: Sub Expected ModName.Sub". I've got "hs-source-dirs: src" in my cabal file
13:48:32 <Denommus> merijn: ok, but that was not my point at all
13:48:36 <dutchie> what've i missed?
13:48:36 <Denommus> luite: ok
13:48:44 <Denommus> luite: and I don't disagree with you
13:48:52 <merijn> Cale: Conal came up with a new name for FRP, something like "denotational continuous time programming", I forget what
13:49:03 <Denommus> luite: again, I'm not intending to claim that FRP is the ultimate solution for this kind of problem
13:49:32 <merijn> dutchie: What's the first line in "Sub.hs"?
13:49:42 * merijn is betting on "left out the prefix"
13:49:46 <Cale> But when people say "continuous time" I'm not exactly sure I agree that this is what FRP *should* be about. Behaviours aren't necessarily "continuous time" -- it just has to be impossible to determine when they change.
13:49:57 <dutchie> "module ModName.Sub where"
13:50:25 <merijn> Cale: The *semantics* should be in terms of continuous time, you can easily implement discrete time on top of continuous time
13:50:43 <merijn> dutchie: hmm, looks good. How are you importing?
13:50:49 <Cale> Well, maybe
13:51:15 <dutchie> merijn: in ModName.hs? "import ModName.Sub"
13:51:33 <Cale> I'm not sure I like the idea of behaviours as functions of time exactly. There are too many "bad" operations you can perform on a function of time.
13:51:36 <Denommus> luite: it's just an interesting approach for high-level events and behaviors
13:52:01 <Cale> Bad in the sense that if you did them in a real world program, you would slaughter your performance.
13:52:16 <merijn> Cale: btw, since conal isn't around and you're interested in this...any good pointers on literature related to denotational semantics for concurrency, especially with shared discrete events?
13:52:31 <Cale> I have no idea :)
13:52:36 <merijn> Blegh
13:52:47 <merijn> I'll just shoot conal an email then
13:53:19 <merijn> Or look in a mirror and say "functional reactive programming" three times to summon him into the channel ;)
13:53:27 <Cale> I spent a bunch of time with iPwn studios implementing an FRP system (which is not publically available still, someday Ryan and I will have to go through it and release it)
13:53:41 <luite> Denommus: sure, i was only saying that if lightweight threads were available, FRP would probably be used less from the start for these async things, and more in situations where you actually benefit from time-varying values
13:54:04 <merijn> Cale: So, my actual interest is in designing a proper concurrent language
13:54:22 <johnw> merijn: that sounds like a neat project
13:54:46 <merijn> johnw: It's part of my "ultimate lazy systems language" blue skies ideas
13:55:08 <merijn> Of course I don't nearly have the time to get any real progress, unless someone offers to fund a 2nd phd for me... >.>
13:55:17 <Cale> But some of the experiences we had seem to indicate that if you're not really careful about what sorts of operations you provide with respect to behaviours, you can end up making it really easy to write programs which perform horribly. In particular, one of the worst things for performance for us was a behaviour for the current time.
13:55:22 <merijn> Cale: Haskell's async exceptions are a mess and Erlang lacks strong typing and any static guarantees progress
13:55:33 <Cale> Which is funny, because that's semantically the identity function.
13:56:01 <merijn> So clearly I need some denotational semantics for asynchronous concurrent communication and "concurrent FRP" seems like the sanest starting point
13:56:20 <Denommus> luite: I wouldn't trust only FRP for doing async, honestly
13:56:29 <merijn> Although I don't know if anyone has looked at concurrent FRP at all
13:56:41 <Denommus> luite: when working with FRP, I tend to think everything is happening synchronously
13:56:52 <merijn> Most things seems to look at concurrent input, but boil down to a central event loop
13:56:54 <Denommus> luite: if the runtime decides to make things concurrent, that's just a bonus
13:57:14 <merijn> johnw: Tell you work to fund me and I'll make it happen ;)
13:57:31 <Cale> merijn: Yeah, we didn't really get to the point of trying to take advantage of concurrency or parallelism
13:57:59 <Cale> merijn: Our FRP system was essentially a pure function
13:58:01 <Denommus> merijn: have you tried OCaml + React?
13:58:06 <Denommus> merijn: no, wait
13:58:12 <Denommus> merijn: OCaml is terrible for concurrency
13:58:20 <Denommus> merijn: forget what I just said
13:58:53 <Denommus> Cale: which library do you use?
13:59:08 <luite> Denommus: well, I'm just saying that FRP actually works well once you're to the point of varying values, or events coming in from the outside world. but as long as you have to care about why a specific value changed (or doesn't change, for example an XHR that doesn't respond in time) it's a sign that FRP might not quite be the right abstraction for that part of the program
13:59:09 <Cale> Denommus: ?
13:59:13 <merijn> johnw: My goals are: proper concurrent primitives (just fork and async exceptions are way to primitive), ideally with some way to verify/guarantee progress/deadlock free ness (or at least simplify manual proofs), proper memory management primitives (should be able to write low level systems primitve in the language)
13:59:17 <Denommus> Cale: for FRP
13:59:46 <Cale> Denommus: I'm talking about the FRP system which we implemented internally at iPwn while we were working on our action roleplaying game.
13:59:48 <Denommus> luite: ok
13:59:54 <Denommus> Cale: ah!
14:00:07 <merijn> johnw: The ability to dynamically load/update code and no untracked bottoms
14:00:15 <luite> Denommus: but i might only be saying that because I spent quite a bit of time implementing threads for GHCJS ;)
14:00:35 <Cale> Denommus: It was an arrowy FRP system slightly like Yampa, but we actually replaced the Arrow class, and the implementation was completely different from Yampa.
14:00:44 <merijn> johnw: I don't want to necessarily enforce totality, but it should be possible to stay with in the total fragment and have the compiler check that you didn't introduce bottoms
14:01:02 <merijn> johnw: So non of this "head :: [a] -> a" nonsense
14:01:31 <merijn> @quote Cale beware
14:01:31 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
14:02:02 <Cale> lol, that quote
14:02:08 <merijn> Cale: I love it :)
14:02:30 <dutchie> oh lol
14:02:34 <dutchie> there's my problem
14:02:46 <dutchie> my text editor says "module ModName.Sub where"
14:02:55 <merijn> dutchie: You didn't save? :)
14:02:57 <dutchie> but i haven't actually written that to disk yet
14:03:45 <Denommus> Cale: why the decision of making a library from scratch?
14:03:47 <merijn> johnw: I'm thinking a language like this needs to abandon haskell's forkIO approach to concurrency as this whole IO based fork/run approach implying a thread of control is way limiting. I think concurrent components should be more first-class/builtin allowing for higher level operations/communication
14:04:03 <merijn> Denommus: Because Cale is super-smart :p
14:04:29 <Arahael> merijn: like par and pseq?
14:04:30 <Cale> Denommus: At the time, most of the FRP libraries people currently use didn't exist
14:04:55 <merijn> Arahael: No, par and pseq are for fine-grained parallelism
14:05:02 <merijn> Arahael: Par and pseq have zero concurrency
14:05:11 <Denommus> Cale: did your library become inspiration for one of the modern libraries?
14:05:19 <merijn> Arahael: Also, they're even more stupidly limited than forkIO
14:05:20 <Cale> Denommus: But also, our FRP system went a lot farther in terms of trying to improve the way in which the computations would be carried out than the current offerings do
14:05:40 <merijn> Arahael: I don't think this kind of thing can be done in haskell without a fundamental rethinking of the runtime system and threading
14:06:08 <Cale> You might look at sodium as slightly inspired by it -- it was done by Stephen Blackheath who was working with us. But it's really quite different.
14:06:17 <luite> merijn: you can express async exceptions in a lazy lang if you have a strict language with call/cc, blocking behaviour is a bit tricky though (as you've probably found out by now :) )
14:06:41 <merijn> luite: The problem is not "expressing async exceptions"
14:06:45 <Cale> Denommus: Our library formed a typed heterogeneous graph of the computation and did a bunch of runtime optimisation of that graph.
14:06:58 <Denommus> Cale: which modern library would you recommend? The recommendations I often hear are reactive-banana and netwire. Are they worth it?
14:07:04 <merijn> luite: The problem is "async exceptions as existing in haskell right now are fucking dumb and unusable"
14:07:09 <Arahael> merijn: i'm still new to haskell, but you mean in a way vaguely like par and seq? ah, a fundamental rethink,  you focusing on pure code, or code that may potentially contain io and st monads?
14:07:24 <Cale> Denommus: To be honest, I haven't extensively used any of them
14:07:29 <Cale> So, I can't really say what'
14:07:34 <Cale> what would be best
14:08:11 <luite> merijn: well i disagree, but it does need some attention to improve the problem of masking
14:08:18 <merijn> Arahael: I mean designing a proper concurrent programming language that lets you express properties of the behaviour of concurrent components
14:08:32 <Arahael> merijn: i've yet to see the point of exceptions, except to massively error out. (Been doing maybe and either everywhere instead)
14:08:52 <merijn> Arahael: We're not talking exceptions here, but asynchronous exceptions
14:09:11 <merijn> Arahael: Asynchronous exceptions are ones that are raised from "outside" a thread, think of posix signals
14:09:41 <merijn> luite: I think you may have missed the initial part of this discussion
14:09:43 <Denommus> Cale: ok. It was an interesting conversation, nevertheless
14:09:52 <Cale> Those libraries do focus on the easier side of the game though. If you restrict FRP to discrete time, or events only, everything becomes quite easy to implement, but your library is comparatively inexpressive.
14:09:58 <merijn> luite: I'm not saying "the design of asynchronous exceptions design of haskell is dumb"
14:10:12 <Denommus> Cale: FRP seems like a really interesting approach that I'd like to become more popular
14:10:23 <merijn> luite: I'm saying "haskell fundamental approach to concurrency is unusably complex and untenable in a many core future"
14:10:37 <merijn> luite: That's not haskell's fault, I haven't seen anyone else do anything better
14:10:38 <Arahael> i haven't covered those yet, then, not in haskell. :( in other languages i have generally done my darnest neer to interact wth other threads (except using worker thread pool, locks, or some sort of communications channel)
14:11:15 <EvanR> Arahael: an async exception may be the only way to communicate with a thread, depending on what its doing
14:11:27 <Cale> Well, I really shouldn't say that, reactive-banana has behaviours in some reasonable form.
14:11:50 <merijn> luite: So my discussion was originating from the premise "if we want to design a new language to, from the ground up, support the building of reliable concurrent programs, what would we do"
14:11:59 <Arahael> EvanR: i detest those types of threads.
14:12:33 <merijn> luite: I hope you'll agree that asynchronous exceptions are woefully inadequate if the goal is to have a language that allows easy reasoning about the interaction of concurrent components
14:12:39 <luite> merijn: right, and in that context, "async exceptions as existing in haskell right now are fucking dumb and unusable" suddenly makes sense?
14:12:52 <EvanR> Arahael: in order to keep threads simple, and avoid writing an entire concurrent manager for each little thing, it can be easier to just throw an exception
14:13:44 <EvanR> Arahael: for example, a thread which does nothing but block on recv from a socket
14:13:48 <merijn> luite: It's the only async exception design I'm familiar with, and it's clearly a "suboptimal" design for concurrent reasonability
14:13:56 <EvanR> you can either disconnect the socket, or you can throw an exception
14:14:24 <dagle> "An email has been sent" but no mail is sent from hackage. Tried for 6 hours now to get hackage to send me an email but nothing seem to happen. Is this common?
14:14:38 <luite> merijn: "suboptimal", in other words, "fucking dumb and unusable"
14:14:56 <merijn> luite: It was perhaps a bit strongly worded :)
14:15:08 <merijn> Although suboptimal is pretty strong euphemism there
14:15:10 <Arahael> EvanR: maybe it's better in haskell but that sort of thing has always given me pain.
14:15:46 <merijn> luite: I will stand by unusable
14:15:55 <EvanR> Arahael: right, pthreads-like systems are really bad. in haskell is not a pain for simple scenarios, so thats why you should KISS. ;) and then theres merijn's current rant
14:15:58 <merijn> luite: I have yet to see async exception code that I actually trust to be correct
14:16:12 <luite> merijn: well i don't know where the optimum is :)
14:16:54 <merijn> luite: I like to consider myself somewhat expert when it comes to designing concurrent systems, so if I have *no* way to believe async exception code is *actually* safe, I consider the abstraction unusable
14:17:06 <Denommus> I think the problem about threading an concurrency in general is an ownership problem
14:17:17 <Arahael> EvanR: i also have experience with windows threads. ugh.
14:17:22 <Denommus> and Haskell will invariably suck unless they extend the type system to describe ownership
14:17:42 <merijn> I mean, I still use them for lack of a better approach in haskell, but that's the reason I've been thinking on how to design a "proper" language
14:17:57 <merijn> Anyway, I have to get back to coding :)
14:18:01 <EvanR> Arahael: you can cheaply spawn simple threads to do your bidding, and the primitives MVar and STM are a lot easier to use than pthreads synchronization.
14:18:13 <Denommus> it's nice to see how Rust handles concurrency
14:18:34 <luite> merijn: me too
14:18:48 <Arahael> EvanR: the problem is messin with a thread's state while not knowing if it is safe to do so/
14:18:58 <Cale> Denommus: Ownership of what?
14:19:22 <jp_rider> hey i have another question
14:19:30 <EvanR> Arahael: well, a thread with no state doesnt have that issue. a thread which only acts by doing transactions also does not have that issue, even if it has internal state
14:19:35 <jp_rider> i now have two versions of the function: http://lpaste.net/6088246442797826048
14:20:00 <josephle> Cale: in rust, ownership is about references
14:20:21 <Arahael> EvanR: right, but merijn is talkin about true concurrency.  not just a completely stateless thread.
14:20:31 <jmct> merijn: Do you think you're language/semantics will make a distinction between deterministic parallelism and concurrency?
14:20:34 <EvanR> im talking about true concurrency too
14:20:39 <EvanR> whatever that is
14:20:52 <jp_rider> the writer monad uses continuation passing style? so would the argument to the functions stay the same?
14:21:26 <Arahael> EvanR: lets assume multicore and stateful threads. (at the very least, they would need to interact on something)
14:21:28 <jmct> merijn: I ask because my PhD is on parallelism in lazy languages and I too have found them a bit lacking, but don't really know the solution.
14:21:31 <jp_rider> and if so, then it is safe to use the second version of `f` then?
14:21:41 <Cale> josephle: Yeah, I'm just not sure how that translates into Haskell. It seems pretty tied to the notion of manual memory management
14:21:54 <EvanR> Arahael: yes, think of the interactions as transactions
14:21:58 <luite> merijn: i just take issue with strongly worded statements like this, and i'm not convinced that it's a fundamentally flawed system, rather than something where the way it interacts with threads just needs to be made more explicit (like through the type system or, passing/masking specific exception types instead of general mask state)
14:22:14 <josephle> Cale, that was my thought too
14:22:26 <EvanR> Arahael: now whatever it was doing can be interrupted, it will try again later whatever was not completed
14:22:34 <merijn> jmct: Definitely
14:22:50 <josephle> it's a useful idea if you want to combine manual memory management with concurrency
14:23:49 <merijn> jmct: I'm not too concerned with implementing parallelism, though
14:23:57 <Denommus> luite: the slides got me excited
14:24:14 <Arahael> EvanR: we keep getting back to the notion of wanting to interrupt what's in a thread.  we also seem to be usig stm terms, so we should assume that the threads are using he st monad at the very least.
14:24:16 <merijn> jmct: It's something I don't find all that interesting. Systems code generally has little data parallelism
14:24:19 <Denommus> luite: but I didn't understand how to setup a GHCJS project to be the client and share the same datatypes as the GHC server
14:24:32 <luite> Denommus: it has a code example
14:24:44 <Denommus> luite: this one? https://github.com/snoyberg/polyconf-2014-haskell-webapp
14:24:54 <EvanR> Arahael: well, they would use IO. which is required to execute STM actions
14:25:06 <jmct> merijn: Fair point. I won't take more of your time, maybe another day we can chat more about this, thanks for your response :)
14:25:12 <luite> Denommus: yeah, although i think it uses a bit of a hack to call GHCJS, not sure though
14:25:24 <Arahael> EvanR: how do you know when it is safe to interript an IO operation?
14:25:33 <merijn> jmct: Where are you doing your phd?
14:26:13 <EvanR> Arahael: for the sake of argument imagine the only things a thread can be doing are waiting for a signal and doing a transaction. then its always safe
14:26:27 <Denommus> luite: he also mentions Haste. Maybe it's easier to use?
14:26:31 <jmct> merijn: York, in the UK
14:26:35 <Arahael> EvanR: that's boring.
14:26:44 <EvanR> lol
14:26:59 <EvanR> yeah Monoid is boring, Functor is boring
14:27:04 <EvanR> and awesome
14:27:05 <blizzy> I love how in Haskell, you can just make 2+2=5 without any errors.
14:27:50 <merijn> jmct: Feel free to message me on here, depending on how long my compilation/regressions take I spent quite some time here during work :p
14:27:53 <Arahael> EvanR: without IO, interrupting would be easy. jut abort the transaction, even.
14:27:54 <Cale> blizzy: Well, you're shadowing the definition of (+) if you write that though.
14:28:15 <Cale> blizzy: Unless you do something like define a new datatype and implement Num differently for it :)
14:28:37 <EvanR> Arahael: oh are you talking about external effects? i thought we were just talking about which monad
14:28:37 <monochrom> freedom is the freedom to user-define operators
14:28:39 <Arahael> Cale: or shadowing =
14:28:47 <Cale> Arahael: Uh, no.
14:29:00 <Arahael> EvanR: i was talking about the effects.
14:29:04 <monochrom> = is where you don't actually have freedom
14:29:06 <Cale> It's definitely (+) that you're shadowing. = is syntax and can't be shadowed.
14:29:14 <jmct> merijn: Sounds good! I'll have to think more deply about what I find lacking in the way we currently express these things and then get back to you. Cheers :)
14:29:15 <Schluri> @pl bs x y=sum(map snd x )< sum(map snd y)
14:29:15 <lambdabot> bs = (. (sum . map snd)) . (<) . sum . map snd
14:29:18 <blizzy> may I ask if any, what api the haskellbot is using?
14:29:34 <blizzy> I want to use it in my bot for a website called PokemonShowdown. *lambdabot
14:29:39 <Cale> blizzy: It's using mueval
14:30:04 <Cale> http://hackage.haskell.org/package/mueval
14:30:07 <EvanR> Arahael: yeah so for threads that are waiting to recv from a socket, you only want to interrupt them in order to kill them. that way they can dump the events directly to the system that behaves better. theres no issue using a lot of threads for this purpose
14:30:10 <Arahael> Cale: i'm going to have to play with 2+2=5 :)
14:30:10 <blizzy> well there goes using it in ruby.
14:30:22 <Cale> > let 2 + 2 = 5 in 2 + 2
14:30:23 <lambdabot>  5
14:30:27 <blizzy> >2+2
14:30:32 <blizzy> oh k.
14:30:37 <Cale> > let 2 + 2 = 5 in 2 + 4
14:30:38 <lambdabot>  *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function +
14:30:46 <Arahael> EvanR: well, would you loose data if you interrupted in mid-recv?
14:31:01 <EvanR> like, if youre disconnecting that channel
14:31:04 <EvanR> you dont care
14:31:09 <luite> Denommus: it used to be easier to setup, and it still generates smaller code, but ghcjs supports more of haskell (like threads and stm) and infrastructure (template haskell, js things in cabal).
14:31:13 <Arahael> EvanR: if!
14:31:13 <EvanR> but you wont get a half-event, and thats good
14:31:16 <Schluri> @pl sp x= gr $ sortBy (comparing snd) x
14:31:16 <lambdabot> sp = gr . sortBy (comparing snd)
14:31:26 <EvanR> Arahael: yeah see what i said about interrupt to kill that kind of thread
14:31:29 <Cale> > let 2 + 2 = 5; x + y = x Prelude.+ y in 2 + 4
14:31:30 <lambdabot>  6
14:31:38 <Cale> > let 2 + 2 = 5; x + y = x Prelude.+ y in map (2+) [1..5]
14:31:39 <lambdabot>  [3,5,5,6,7]
14:32:05 <Arahael> EvanR: what if i want to restart the thread? (because i am an idiot and someone said it was safe)
14:32:36 <Arahael> EvanR: and thus, reconnect to the same channel.
14:32:51 <Schluri> @pl sp x= gr ( sortBy (comparing snd) x) ([],[])
14:32:51 <lambdabot> sp = flip gr ([], []) . sortBy (comparing snd)
14:32:57 <EvanR> Arahael: for this kind of thread, you cant just restart. presumably the finalizer also closes that socket for simplicity. so reconnect and spawn a new thread
14:33:16 <EvanR> keeping it simple
14:33:22 <Arahael> EvanR: now you are adding complexity.
14:33:26 <Cale> merijn: Oh, have you looked at Cloud Haskell / distributed-process at all?
14:33:45 <merijn> Cale: I read the paper
14:34:03 <EvanR> Arahael: actually i didnt, my suggestion for a lister thread remains unchanged, even though you decided you want to restart a connection
14:34:12 <merijn> It looks neat, but not fundamental enough to interest me
14:34:20 <Arahael> Cale: thanks - obvious in retrospect :)
14:34:45 <EvanR> Arahael: the idea is not to engineer one huge thread that can do anything, you try to form a working system from many simpler pieces
14:34:49 <merijn> Cale: It doesn't solve any of haskells fundamental single machine issues :)
14:35:16 <Cale> merijn: Well, sure. I just remember they had some sort of semantics attached to that.
14:35:18 <luite> Denommus: code size has been their focus point, so they took the part of haskell that's relatively easy to support and use a forked base lib optimized for that.
14:35:22 <Arahael> EvanR: restarting was merely an example.  if it is completely safe to interrpt in any state, regardless of any io computation, then it should be safe to do anything you like such as restarting.
14:35:24 <Cale> It might've just been operational
14:35:36 <merijn> Cale: I'll check that out again, but I suspect it'll mostly be operational
14:35:47 <EvanR> Arahael: in this case it is safe to interrupt this simple thread on the very outside of the system, you just kill it, simple
14:36:05 <EvanR> cloud haskell looks interesting, they borrowed a lot from erlang
14:36:17 <Arahael> EvanR: "in this case"?
14:36:18 <Cale> merijn: It seems hard to usefully give denotational semantics to mostly-unrestricted concurrent programs.
14:36:27 <athan> Would it be wise to have gulp call `npm install` from the current directory of the gulpfile?
14:36:31 <EvanR> Arahael: the fd listener thread scenario
14:36:37 <blizzy> anyone know any modules for connecting to a websocket?
14:36:39 <athan> ...sorry :(
14:36:43 <athan> wrong channel
14:36:57 <merijn> Cale: I'm not even sure it makes sense, I've haven't though hard enough about it :)
14:36:58 <Cale> merijn: You can just do something where you consider the set of all possible states that the system could be in, but the usefulness of doing so often seems questionable.
14:37:16 <Arahael> EvanR: that's a specific case. anyway, i must getnready for work. thanks for the chat :)
14:37:22 <EvanR> Arahael: for this kind of thread you just kill it. theres no other reason to "interrupt" it because its not doing very much
14:37:27 <EvanR> alright
14:38:07 <Arahael> EvanR: I remain unconvinced, exceot that it is easier to make 'safe' threads in haskell, but i am not convinced that an arbituary hread is safe to mess with.
14:38:28 <EvanR> i doubt youd want to mess with arbitrary threads arbitrarily
14:38:46 <EvanR> except to kill them all, which is easy, ctrl C ;)
14:38:56 <EvanR> even thats not arbitrary
14:38:58 <Cale> blizzy: Anything wrong with http://hackage.haskell.org/package/websockets ?
14:39:30 <Arahael> EvanR: would love to continue this discussion...
14:39:43 <Cale> blizzy: (I haven't used any such libraries before, so I have no idea which of them are better than others, but this looks reasonable...)
14:39:58 <EvanR> Arahael: another example is an email send, you can spawn a thread dedicated to sending one email (or dump an error somewhere) and go away immediately. youd not want to mess with that thread while it exists
14:40:10 <blizzy> oh ok. thxs Cale.
14:40:17 <EvanR> to merijn's points, i dont know how to safety spawn that thread "transactionally"
14:40:43 <EvanR> but a huge system with lots of complex rules might not be the answer
14:44:28 <Arahael> EvanR: would love to continue this discussion...? later?
14:52:30 <Denommus> luite: ok, I'd prefer to use GHCJS, but I'm still in doubt on how feasible that is
14:53:05 <Denommus> luite: the infrastructure I want, at the end of the day, is very similar to what OCaml already has with Eliom
14:53:12 <Denommus> luite: but Eliom is... ugly
14:54:26 <Peaker> merijn: yo: don't forget the proposal is about many more functions besides "bracket"
14:54:41 <sinelaw> Peaker: yo.
14:54:55 <sinelaw> just got the algo we talked about to work. type inference looks correct!
14:55:38 <Darwin226> Hey guys. So I was wondering. Since the nature of a monad restricts all computation to be sequential, how come that the compiler doesn't optimize the State monad to do in-place mutation? I'm aware of the ST monad, but State seems much nicer to work with and as far as I can tell it imposes the same restrictions.
14:55:54 <luite> Denommus: hehe I can't really claim it's finished or usable for everything yet, it's taking a more scenic route than most others :p
14:57:08 <monochrom> Darwin226: sequential is not enough. you need "old states can never be used again". unfortunately, in State, old states can always be used again.
14:57:20 <EvanR> Darwin226: well, State gives you access to a single location to replace with different values. you dont mutate the values in place even if you are using a mutable location
14:57:45 <EvanR> im not sure there would be much difference
14:59:10 <Darwin226> monochrom: Oh. Right. So ST gets around that by only allowing refs and arrays as it's state, right?
14:59:46 <EvanR> is the distinction between rebinding and mutating object parts
14:59:47 <monochrom> yes, plus runST's rank-2 type "(forall s. ST s a) -> a"
15:00:38 <Aruro> is it possible to define a list pattern match for general N like x:xs, x:y:xs,x:y:z:xs, ..... , x:y..:xn:xs ??
15:00:47 <vanila> no
15:00:52 <fragamus> why is cabal update taking forever
15:01:21 <Aruro> no to what?
15:01:38 <Darwin226> I see. Well, it certainly seems like it wouldn't take much to introduce some mechanism where the user can annotate that the gotten state will only be used once, before modification. Am I missing something here?
15:02:09 <monochrom> it takes linear types. see Wadler's "linear types can change the world!"
15:03:03 <Darwin226> monochrom: Yeah, I've read about them before. Something about it being more complicated to implement than it seems, comes to mind
15:03:43 <benmachine> Darwin226: besides, we already have ST, why would we want to make State the same as it?
15:03:46 <EvanR> more importantly, would it be more or less complicated to use than languages that already let you modify objects
15:03:51 <Schluri> @pl greedySecond  b (x:xs) (y,z)
15:03:51 <Schluri>                         |b <= 0   = greedySecond (b + snd x) xs (x:y , z)
15:03:51 <Schluri>                         |otherwise   = greedySecond (b-snd x) xs (y, x:z)
15:03:51 <lambdabot> greedySecond b (x : xs) (y, z)
15:03:55 <Schluri> :(
15:04:02 <josephle> my alma mater had some people investigating practical forms of linear types in different paradigms
15:04:43 <EvanR> i need to read on linear types, because without context it sounds like "types to manually manage memory"
15:05:21 <emmanueloga> anybody knows of a shell script or small program to lpaste form the command line?
15:05:34 <Darwin226> benmachine: ST only allows refs and arrays so the programmer is restricted. If state somehow did in-place mutation it would be the compiler responsibility to figure out how to do it for any data type.
15:05:44 <josephle> EvanR: there's also a concept called Typestate, which I understand is extremely related to linear types
15:05:47 <benmachine> Darwin226: but you can put anything you like in a ref
15:06:08 <Darwin226> benmachine: Yeah, but I can only change the ref itself in-place, right?
15:06:23 <benmachine> Darwin226: um, what else would you want to do?
15:07:03 <josephle> EvanR: typestate is being researched by OOP people, and linear types are being researched by FP people
15:07:09 <Darwin226> benmachine: I know this is a long shot, but maybe [1,2,3] ++ [4,5,6] could just change the last pointer in the left list to point to the head of the right list
15:07:20 <josephle> I think it's safe to say that linear types may one day be more popular :)
15:07:38 <NemesisD> this is weird. newtype Snap a = ..., i've got some code that uses its unsaturated type (i.e. just Snap), i can do type SnapAlias = Snap, and s/Snap/SnapAlias and everything works, but if i don't partially apply and do type SnapAlias a = Snap a, s/Snap/SnapAlias/, i get compaints about SnapAlias missing args. what's up with that?
15:07:41 <benmachine> Darwin226: that's an interesting idea, but I don't see the connection with State
15:08:01 <merijn> Darwin226: It can only do that if it can proof that no one has a pointer to "[1,2,3]"
15:08:53 <NemesisD> example, ReaderT Whatever Snap (), if i replace that with ReaderT Whatever SnapAlias () its a compile error
15:08:57 <Darwin226> benmachine: It requires the left list to be actually modified. State, being a monad, gives us some guarantees about linearity, but as monochrom said it isn't enough to ensure that the same list won't be used after modification.
15:09:28 <Darwin226> benmachine: It might not have a strict connection with State but monads in general.
15:10:02 <benmachine> Darwin226: you could imagine a data MutableList s a = Empty | Cons a (STRef s (MutableList s a)) which would admit that kind of thing
15:10:06 <benmachine> awkward to use though
15:10:38 <Darwin226> benmachine: What I'm asking is how hard would it be to implement some mechanism where I can do a thing like "val <!- get" and then have the compiler yell at me if val is used more than once after that, or if it's used after a call to put
15:10:55 <benmachine> Darwin226: I guess that sounds like linear types, yeah
15:11:41 <benmachine> EvanR: because no-one ever explained it, linear types: a variable with a linear type has the additional constraint that you can't duplicate it, and you have to use it
15:11:41 <Darwin226> benmachine: Maybe I'm wrong but linear types seem like a much larger undertaking than this.
15:11:48 <benmachine> i.e. it has to be used exactly once
15:12:14 * hackagebot include-file 0.1.0.0 - Inclusion of files in executables at compile-time.  http://hackage.haskell.org/package/include-file-0.1.0.0 (DanielDiaz)
15:12:14 <EvanR> in the entire program?
15:12:18 <benmachine> EvanR: yes
15:13:06 <EvanR> how would you issue a command to update two parts of the same array
15:13:17 <EvanR> without two commands
15:13:53 <benmachine> EvanR: you mean, supposing the array had a linear type? you'd pass the array to the first update, and then it would return a new thing, which you could then pass to the second update
15:14:11 <benmachine> you wouldn't be able to pass the original thing to both updates, you'd be forced to pass the new one
15:14:58 <merijn> How do linear types differ from uniqueness types?
15:15:09 <EvanR> benmachine: with the goal in this case being a performance increase
15:15:27 <benmachine> merijn: I don't know, it's entirely possible I've accidentally described uniqueness types instead
15:15:39 <josephle> merijn: well according to wiki, it's all about whether or not you can cast nonlinear types to linear types
15:15:41 <benmachine> merijn: there might be a distinction in whether or not you're forced to use the value
15:15:55 <benmachine> i.e. a distinction between "at most one" and "exactly one" use site
15:16:03 <Denommus> AFAIK, uniqueness types enforce that a unique type will FOREVER be unique, during the whole duration of the program
15:16:05 <EvanR> whats the point of forcing the variable to be used
15:16:06 <benmachine> but I'm very vague on this and probably confused
15:16:10 <monochrom> merijn: one of them is "use 0 or 1 time" and the other is "use 1 time". I forgot which is which.
15:16:18 <Denommus> while a linear type can only enforce that after the value became linear
15:16:31 <benmachine> EvanR: sometimes that just makes sense, like withFile might want to do that with the file handle
15:16:32 <Denommus> so, Clean's type system is linear. Rust's is unique
15:16:36 <monochrom> I only memorize that Wadler's paper talks linear and Clean talks uniqueness
15:16:59 <EvanR> idris is talking uniqueness now
15:17:04 <Denommus> monochrom: Clean is unique? Really?
15:17:19 <Darwin226> EvanR: If I'm reading the paper correctly, it allows you to not have a garbage collector because the introduction and the freeing of the value has to be explicitly written in code
15:17:27 <monochrom> yes, that's what they said, but I didn't investigate what they do
15:17:34 <EvanR> Darwin226: therefor, performance
15:17:55 <EvanR> visible spelling changes for invisible performance differences annoy me
15:17:58 <EvanR> javascript
15:18:39 <monochrom> I only know that where Haskell goes IO a, Clean goes World -> (World, a) and mark the "World" there as a uniqueness type
15:19:32 <EvanR> in clean, evaluating a function of that sort would cause IO effects?
15:19:37 <monochrom> the Haskell Wiki article "Inside IO" would be perfect for Clean :)
15:20:29 <Darwin226> Man, Clean has an unfortunate name seeing how "clean language" already means something else
15:20:39 <Darwin226> Completely ungooglable
15:20:55 <josephle> if only I had my ATTPL Pierce book on hand
15:21:05 <benmachine> EvanR: it's not only for performance, it's just another way of expressing things
15:21:19 <monochrom> try "clean functional language" :)
15:21:21 <EvanR> benmachine: it seems very operational to me so far
15:21:26 <Denommus> Darwin226: you can have deterministic memory management with ownership/affine types. They don't need to be linear
15:21:26 <Denommus> Darwin226: in fact, that's precisely what Rust does
15:21:34 <benmachine> if you informally have the constraint that a variable should not be used multiple times in multiple places, it seems like you might want to encode that in its type
15:21:43 <benmachine> it's another property of the way you use values that the compiler can check for you
15:21:49 <benmachine> just like any other type
15:21:58 <EvanR> that would make sense
15:22:42 <EvanR> but i have not realized that "this variable should be *used*" only once, only things like i need to close a handle
15:22:48 <EvanR> which seems different
15:23:01 <EvanR> unless the type is also describing what you could possibly use it for
15:23:04 <EvanR> and its only one thing
15:23:08 <benmachine> what about things like, I should not be able to use a handle after I've closed it?
15:23:34 <EvanR> that would make sense if "handle" means "closable thing" and the only thing you can do is close it
15:23:41 <EvanR> but then you cant use it anyway
15:23:45 <EvanR> except to close it twice
15:23:49 <Darwin226> Denommus: Any chance of seeing something like that in haskell any time soon?
15:23:50 <benmachine> well no, it's more like, most IO operations take a handle and return a handle
15:23:56 <Welkin> you cannot close it if it was not opened
15:23:56 <benmachine> but close takes a handle and doesn't return one
15:24:08 <monochrom> you cannot separate optimizations (which sounds so pragmatic and dirty) from safety (which sounds so theoretical and elegant). every optimization is justified by a safety.
15:24:10 <benmachine> while open returns one without taking one
15:24:30 <benmachine> so you have a guarantee that things go open -> operation -> operation -> operation -> close
15:24:36 <benmachine> nothing else is allowed
15:24:46 <EvanR> monochrom: but if an optimization had no effect on your programming language, that seems separate enough
15:24:56 <benmachine> it ought to be explcitly stated that I'm coming up with this on the spot and it might be wrong
15:25:02 <benmachine> not an expert in this field
15:25:18 <benmachine> but just talking about the kind of things I might find exciting about linear types from my position of limited knowledge
15:26:38 <EvanR> from talking with people exciting about uniqueness types, it seems they are excited about 1) better performance and 2) having to write code to use it, which seems more exciting to people than just having the 1) by itself
15:26:46 <EvanR> excited*
15:27:02 <monochrom> benmachine: I think you're doing good. we started out with "how to use types to say 'old state will not be used again', so that the compiler can go ahead use mutation".
15:27:10 <josephle> http://lambda-the-ultimate.org/node/1548 -- a link to a paper that describes the differences between uniqueness and linear types
15:27:20 <EvanR> the "stale" filehandle makes sense
15:27:25 <josephle> well, a link to a ltu post that has a wayback machine link >_>
15:28:13 <EvanR> updating an array as if you were writing C code seems like another situation
15:28:18 <monochrom> after all, even Wadler's paper was way way back :)
15:28:20 <Darwin226> EvanR: What's the problem with being excited about better performance?
15:28:32 <EvanR> Darwin226: thats not the point i was making
15:29:20 <Darwin226> EvanR: Sorry then. I think I've gotten that impression somewhere in the middle of this conversation
15:29:59 <Aruro> how to insert an element into a list on every nth place using similar pattern matching recursion which is used in definition of take?
15:30:13 <EvanR> one confusing part for me is that this seems to be based on variables, so probably local variables. in which case wouldnt a withFile wrapper work better, and having no close?
15:30:20 <emmanueloga> Trying to compare two strings against a [(String -> String -> Ordering)] list, like [compare.length, compare]. http://paste.ubuntu.com/8973672/ Is this doable? Maybe type constraints disallow this kind of thing. Or maybe I lack imagination :p
15:30:34 <Denommus> Darwin226: I highly doubt it
15:30:44 <emmanueloga> (needless to say that paste doesn't work)
15:30:47 <EvanR> smuggling a handle away somewhre else in the program, and then expecting it to be caught by the type system seems extraordinary
15:31:38 <josephle> well, the linearity is tracked across function calls
15:31:58 <josephle> since it's now a type thing
15:32:57 <EvanR> so a function taking such a variable could "use" it, but it is being used again and again
15:33:04 <EvanR> whats unique about it
15:34:35 <josephle> once a function uses it
15:34:39 <josephle> no other function can
15:34:46 <benmachine> EvanR: withFile isn't always a great pattern, e.g. when you want open file A, open file B, close file A, close file B
15:35:22 <juri_> I don't suppose someone wants to help me debug implicitcad?
15:36:16 <benmachine> or when you can't easily link the lifetime of a filehandle to a lexical scope for other reasons, say you've got a stream processor that sometimes wants to close a file handle and open a different one and start processing that one instead
15:36:25 <Aruro> wrap2 el (x:y:xs) = el:x:y:wrap2 el xs; is it possible to generalize this definition easily to N? getting wrapN?
15:36:47 <benmachine> I'm imagining some loop that you go through repeatedly, with a "current filehandle" being passed as an argument, only sometimes you don't pass the same filehandle but close it and open a new one to pass
15:37:25 <benmachine> Aruro: consider using Data.List splitAt
15:37:30 <Aruro> yes
15:37:39 <Aruro> that uses just take n
15:37:54 <Aruro> which is accidentally possible to generalise easily to N by recursion
15:37:59 <Aruro> lucky take
15:38:30 <benmachine> Aruro: I completely didn't follow anything you just said, but I'm going to go and sleep instead of worrying about it
15:38:42 <EvanR> i guess im getting caught up on the notion of "use", i.e. appears exactly once in a function body, alternatively appears as an argument to a (betterly typed) close call
15:38:49 <Aruro> :D
15:39:27 <EvanR> both make sense but not at the same time
15:39:43 <Welkin> does anyone know about SSL certificates?
15:39:52 <Welkin> which is the good option? Just the cheapest?
15:40:10 <EvanR> the cheapest is free
15:40:22 <Welkin> well, besides self-signing
15:40:27 <Welkin> the cheapest I found is $9
15:40:34 <Aruro> take n effectively has general pattern of n x:y:...:xn which is achieved through linear recursion call of take (n-1)
15:40:43 <EvanR> you dont have to self sign
15:41:23 <Welkin> I'm looking for the easiest solution
15:41:43 <Welkin> notthe lowest cost, neccessarily
15:42:47 <absence> Data.Function.on feels kinda lensy. is there a similar mechanism in the lens package?
15:44:14 <geekosaur> :t over
15:44:15 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
15:44:25 <geekosaur> hm, maybe not
15:46:43 <EvanR> Welkin: for example https://konklone.com/post/switch-to-https-now-for-free
15:47:47 <absence> geekosaur: i think "on" is more like a getter
15:47:47 <Welkin> it's for commercial purposes
15:47:54 <Welkin> so it won't be free anyway
15:48:16 <geekosaur> right, "hm, maybe not" :p
15:48:37 <EvanR> then use whatever, like your existing domain name provider
15:49:02 <Welkin> I'm using my domain name provider, but there are lots of options
15:49:13 <Welkin> I wondered if the sll provider made a difference
15:49:19 <Welkin> ssl*
16:02:05 <gioia33> ciaoa tutti
16:02:16 <gioia33> list please
16:06:33 <geekosaur> one of these days I'm going to do a dummy login to freenode and see if that actually does anything
16:06:54 <geekosaur> (imagining a bit that responds in /msg)
16:07:29 <trap_exit> in OSX, what is the best way to print a bunch of *.hs files? I have a black & white laser printer; no color;
16:07:36 <trap_exit> I do not have a2ps
16:08:00 <trap_exit> In OSX (without nix, without brew, without macports, but with cabal + ghc) what is the best way to print a bunch of *.hs files? I have a BW (no color) laser printer.
16:10:16 <sm> open in your browser and print from there ?
16:10:34 <trap_exit> I have a bunch of *.hs files
16:10:38 <trap_exit> I prefer command line tool
16:10:41 <sm> lpr ?
16:10:44 <geekosaur> there probably isn't a "good" way, if by that you mean nicely formatted and stuff
16:10:45 <ij> Why would you print hs files?
16:10:53 <trap_exit> to read them
16:10:55 <trap_exit> on paper
16:11:03 <geekosaur> pr *.hs | lp
16:11:04 <trap_exit> and draw comments on them
16:11:06 <trap_exit> I can't draw on my screen
16:11:09 <sm> I have wanted to do this before.. it's not too easy
16:11:25 <ij> trap_exit, Sounds like a legit reason, carry on.
16:11:37 <trap_exit> ij: are you mocking me?
16:13:03 <ij> trap_exit, No, I am serious. I was just jokingly saying that you can carry on, while it's not like you can't if I wouldn't «allow» you to.
16:13:29 <trap_exit> ij: phew, I was about to banish you to the IO monad
16:13:58 <geekosaur> am not sure that that will be entirely sane for text, though, it may depend on the printert (although in theory cups should determine that from the ppd and convert as needed). I've always used a2ps but that has to be installed
16:14:05 <sm> keep calm and carry on
16:14:17 <int-e> trap_exit: and how would that keep ij away from your printing problems?
16:14:19 <DTSCode> keep calm and grab a towel
16:14:48 <geekosaur> (I say "in theory" because I do not entirely trust Apple to support text printing >.> )
16:14:54 <trap_exit> int-e: I dunno, but "banish to the IO monad" sounds cool
16:15:00 <int-e> trap_exit: it does
16:15:16 <trap_exit> alright
16:15:23 <int-e> trap_exit: all I was saying that printing would also happen there
16:15:23 <trap_exit> maybe I use *.hs -> LaTeX -> pdflatex -> print
16:15:27 <trap_exit> damn
16:15:36 <geekosaur> so, basically, test it with a text file and then if it works then pr *.hs | lp
16:15:37 <trap_exit> which monad would we have to banish him to instead?
16:15:42 <trap_exit> yeah
16:15:45 <trap_exit> lp Main.hs <-- ugly output
16:16:16 <geekosaur> not sure I expect LaTeX to format random text files properly either :)
16:16:30 <trap_exit> what?
16:16:34 <trap_exit> what's a good *.hs -> LaTex converter?
16:16:59 <sm> this may a case for The Mighty Pandoc
16:17:40 <sm> umm.. for no particular reason. Never mind
16:17:41 <geekosaur> LaTeX expects LaTeX source. with an appropriate stylesheet, all you might need is to wrap the files in \documentclass{stylesheet here}\begin{code} and \end{code}
16:17:50 <geekosaur> but you would have to wrap all the files that way
16:18:10 <geekosaur> and find an appropriate stylesheet
16:18:50 <trap_exit> ick
16:18:50 <trap_exit> I was hoping to do osmethi glike
16:18:54 <trap_exit> cabal install print-my-haskell-source
16:19:02 <trap_exit> then do print-my-haskell-source **/*.hs
16:19:04 <trap_exit> and everything just works
16:19:06 <geekosaur> closest we have to that is pandoc, I think
16:19:13 <geekosaur> and that's not very close tbh
16:19:27 <sm> trap_exit: ha ha. This is *printing* we are talking about, remember
16:19:30 <geekosaur> printing haskell source is not a very high priority
16:20:07 <sm> printing and just works are conflicting forces of nature
16:20:28 <trap_exit> damn it
16:20:29 <trap_exit> I need to install pdflatex
16:20:37 <geekosaur> dunno, I've printed text files on OS X without too much trouble --- but I use a2ps
16:20:52 <trap_exit> how did you instapp a2ps?
16:20:56 <geekosaur> maybe you can find enscript downloadable, it's not as good but it'll do
16:20:58 <trap_exit> is there a decent *.hs -> HTML converter ?
16:21:08 <geekosaur> and might not require you to installa  package system
16:21:13 <geekosaur> (I use macports)
16:22:52 <geekosaur> bleh. looks like apple used to ship enscript but stopped as of 10.8
16:23:02 <P4Titan> Hello all, I have question about how to use the where, is the following possible? http://lpaste.net/114210
16:23:33 <texasmynsted> is anybody using cloud haskell in production?
16:23:33 <geekosaur> as long as you can assign consonant types, sure
16:23:42 <trap_exit> if it compiles it is possible
16:23:46 <geekosaur> in this case I would expect it to work
16:23:46 <trap_exit> if it does not compile, it is not possible
16:24:00 <trap_exit> I trust geekosaur, but I trust ghc more.
16:24:03 <P4Titan> does it look good
16:25:14 <P4Titan> It seems to work, I just thought it wouldn't and asked here to get any sugestions
16:25:17 <juri_> i still have -Wall failing to compile, while without Wall, my program compiles.
16:25:18 <P4Titan> Thanks
16:27:17 * hackagebot help-esb 0.1.4 - A Haskell client for the Help.com team's ESB.  http://hackage.haskell.org/package/help-esb-0.1.4 (suitupalex)
16:32:17 * hackagebot help-esb 0.1.5 - A Haskell client for the Help.com team's ESB.  http://hackage.haskell.org/package/help-esb-0.1.5 (suitupalex)
16:42:17 * hackagebot include-file 0.1.0.1 - Inclusion of files in executables at compile-time.  http://hackage.haskell.org/package/include-file-0.1.0.1 (DanielDiaz)
16:53:00 <batchm> can someone explain behavior of this IO action?
16:53:04 <batchm> do print "start"; quickCheck (\x -> x == x); print "end"
16:53:54 <batchm> it is executed like this:  <two seconds delay> <start and quickCheck both printed instantly>  and not <start printed><delay><quick check info printed> as I expected
16:54:38 <pavonia> Output buffering probably
16:54:52 <Welkin> you can turn buffering off
16:55:05 <geekosaur> it should be defaulting to line buffering, unless it's being redirected to a file / pipe
16:55:08 <Welkin> set the buffer mode using hPrint
16:55:11 <batchm> \n flushes the buffer does it not?
16:55:26 <pavonia> @src print
16:55:26 <lambdabot> print x = putStrLn (show x)
16:55:28 <batchm> I don't think this is it at all
16:55:28 <Welkin> er
16:56:14 <batchm> do print "start"; threadDelay 2000000; print "end"
16:56:17 <batchm> this does the expected
16:56:22 <batchm> start printed. 2 seconds delay. end printed
16:56:22 <Welkin> is hoogle down?
16:56:28 <Welkin> @hoogle setbuffering
16:56:29 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
16:56:29 <lambdabot> GHC.IO.Handle hSetBuffering :: Handle -> BufferMode -> IO ()
16:56:32 <batchm> so why is it different with quickCheck ?
16:57:06 <batchm> as additional info, I have noticed this when I wrote my time function, which times the duration of an IO action. so yeah, nothing to do with buffering
16:58:57 <batchm> can anyone else replicate this?
17:01:03 <indiagreen> batchm: are you doing it in GHCi?
17:01:32 <batchm> yes
17:01:39 <Welkin> that may be your problem
17:01:43 <Welkin> try compiling it
17:01:54 <batchm> I will. but why would it be a problem only for quickCheck?
17:02:03 <Welkin> ghci works differently
17:02:08 <indiagreen> I have “start” printed immediately, followed by a changing counter, followed by “+++ OK, passed 100 tests.” and “end”
17:02:10 <indiagreen> in GHCi
17:02:21 <batchm> hmm
17:02:21 <indiagreen> in particular, GHC 7.8.3 on Linux
17:02:37 <batchm> 7.6.3 here
17:02:58 <Clint> i have to up it to 100000 tests to get a meaningful delay
17:03:14 <batchm> ok this is super odd
17:03:26 <batchm> it is done instantly in ghci in a terminal
17:03:46 <batchm> but there is a several seconds delay in emac's *haskell* buffer
17:04:05 <indiagreen> it might be because QuickCheck does weird things to the terminal
17:04:10 <indiagreen> to change the counter
17:04:10 <batchm> possible
17:04:15 <indiagreen> I'll try in Emacs now
17:05:29 <indiagreen> nope, it just doesn't display the counter
17:05:36 <indiagreen> “start” is still printed instantly
17:05:37 <batchm> good that it is not haskell related.. i started to think I'm back at not understanding how IO works
17:07:58 <Arahael> batchm: stdout tends to be line buffered in most  envuronments.
17:08:31 <indiagreen> Arahael: but “print” does output a newline
17:09:38 <Arahael> indiagreen: hmm, not sure then. there is probably another buffer somewhere then.
17:10:55 <batchm> it is not line buffering related, or even stdout related (I got the same thing when I was timing quickCheck duration, two seconds delay but measured duration was 0.001.  it looks to be some weird interaction between ghci and my current version of emacs/haskell-mode (both of which are very outdated)
17:11:20 <Arahael> batchm: ah, i think emacs has block buffering.
17:12:04 <batchm> I think the character quickCheck prints trips *haskell* buffer
17:13:23 <P4Titan> I have a function call in a do and when I do ghc -Wall, it warns about that, should I just not use -Wall or do the recomended _ <- ..
17:13:36 <batchm> what is the warning?
17:14:43 <P4Titan> main.hs:102:3: Warning:
17:14:43 <P4Titan>     A do-notation statement discarded a result of type Char.
17:14:43 <P4Titan>     Suppress this warning by saying "_ <- ($) try char '#'",
17:14:43 <P4Titan>     or by using the flag -fno-warn-unused-do-bind
17:14:46 <P4Titan>  
17:16:13 <geekosaur> there is also Control.Monad.void
17:16:51 <P4Titan> oh, so I simply do void $ char "#"
17:16:56 <P4Titan> or something similar
17:18:30 <Welkin> it tells you what to do
17:18:45 <Welkin> if you don't want the result of a computation, use _
17:19:01 <Welkin> _ <- try char '#'
17:19:03 <batchm> or void.. or  -fno-warn-unused-do-bind :)
17:19:07 <benzrf> P4Titan: that warning is bogus
17:19:12 <benzrf> that's an absurd thing to warn about
17:19:15 <P4Titan> Is that actually used because it looks funny, or is void used more often
17:19:17 <batchm> I don't think any of the choices are wrong
17:19:45 <Welkin> for values you don't care about, I always use _
17:20:05 <Welkin> it's up to you
17:22:45 <batchm> > quickCheck (\x -> xs == reverse xs)
17:22:46 <lambdabot>  Not in scope: ‘xs’
17:22:46 <lambdabot>  Perhaps you meant one of these:
17:22:46 <lambdabot>    ‘x’ (line 1), ‘x’ (imported from Debug.SimpleReflect),
17:22:46 <lambdabot>    ‘s’ (imported from Debug.SimpleReflect)Not in scope: ‘xs’
17:22:46 <lambdabot>  Perhaps you meant one of these:
17:22:55 <batchm> @check (\x -> xs == reverse xs)
17:22:57 <lambdabot>  Not in scope: ‘xs’
17:22:57 <lambdabot>  Perhaps you meant one of these: ‘x’ (line 1), ‘x’ (imported from Debug.Simpl...
17:23:29 <pavonia> @check (\xs -> xs == reverse xs)
17:23:30 <lambdabot>  +++ OK, passed 100 tests.
17:23:34 <batchm> yeah thanks
17:23:44 <pavonia> What? O.o
17:23:46 <batchm> why does this pass? I recall someone asking that the other day but I didn't see anyone answer
17:23:55 <batchm> indeed :)
17:24:09 <pavonia> Maybe it defaults to [()]
17:24:24 <pavonia> @check (\xs -> xs == reverse xs :: [Int])
17:24:26 <lambdabot>  Couldn't match expected type ‘[GHC.Types.Int]’
17:24:26 <lambdabot>  with actual type ‘GHC.Types.Bool’
17:24:33 <pavonia> @check (\xs -> xs == (reverse xs :: [Int]))
17:24:34 <lambdabot>  *** Failed! Falsifiable (after 7 tests and 6 shrinks):
17:24:34 <lambdabot>  [0,1]
17:24:39 <batchm> good call
17:25:11 * DanC_ tries to build something in haskell again...
17:25:21 <batchm> why does it default to [()] though and not throw ambiguius error?
17:25:25 <batchm> ghci thing?
17:25:40 <batchm> ambiguous
17:26:31 <Enigmagic> unit is the best.
17:26:48 <DanC_> is `cabal init` the recommended way to start a project
17:26:49 <DanC_> ?
17:27:44 * DanC_ wonders which link from https://www.haskell.org/haskellwiki/Haskell to follow
17:29:24 <DanC_> best place to start is "CIS 194: Introduction to Haskell (Spring 2013)"?
17:32:00 <DanC_> I usually use emacs, but intellij idea is growing on me; I'll try that...
17:33:51 <merijn> DanC_: CIS 194 is pretty good
17:34:00 <merijn> DanC_: Learn You a Haskell is also popular
17:34:21 <DanC_> I'm somewhat familiar with haskell as a language; I'm trying to find the community consensus on how to make a new project
17:34:36 <merijn> DanC_: "cabal init", pretty much
17:34:37 <DanC_> or perhaps best practices
17:34:47 <merijn> Then start coding :p
17:34:48 <sm> sure, why not cabal init
17:34:49 <ReinH> DanC_: CIS 194 is good. #haskell-beginners uses it, so you could ask questions about it there as well.
17:35:03 <DanC_> is there a short path from haskell.org to "cabal init" that I missed?
17:35:24 <ReinH> DanC_: mkdir project-name; cd project-name; touch Main.hs; cabal init
17:35:29 <Arahael> DanC_: I've found that adding -Wall, and using the amazingly-good hslint to be fantastic.
17:35:31 <ReinH> Pretty much all you need to get started
17:35:56 <DanC_> but suppose I didn't know about #haskell; how would I be expected to discover "cabal init"?
17:36:19 <ReinH> DanC_: e.g., https://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
17:36:49 <DanC_> how did you find that? I don't see it when I follow the "tutorials" link
17:37:01 <ReinH> Yeah, it should probably be added somewhere
17:37:12 <Arahael> DanC_: I hang in these channels :(
17:37:15 <DanC_> nor "learning resources"
17:40:02 <xuinkrbin> Given http://pastebin.com/DnE3nDwT, would Anyone point Me in the direction of how to make sense of the `case` expression in `precomputeDisksFor`? I know what the commentary says but I don't understand how it does what is claimed.
17:40:04 <DanC_> "cabal init" is in section 2 of How_to_write_a_Haskell_program, *after* section 1 sends you down the rabbit hole with "You should read at least the start of section 2 of the Cabal User's Guide," which doesn't mention "cabal init" anywhere
17:40:45 * DanC_ heads to #haskell-beginners
17:40:47 <P4Titan> does anyone know some about parsec?
17:41:56 <sm> DanC_: you're in a good place to see weaknesses in the docs, any improvements will be welcomed
17:41:58 <goglosh> hmph, I'm gonna give this another shot
17:42:22 <DanC_> should I edit the wiki? or is there a "welcoming committee" that I should talk with?
17:42:42 <goglosh> say, I ran 'ghc-pkg check' and it seems everything was broken out of nowhere
17:42:45 <sm> I think you are already talking to it.. go for it
17:42:53 <goglosh> do you think building ghc from source would correct that?
17:43:08 <P4Titan> does oneOf "bdox" consume input if it does not match
17:43:34 <DanC_> parsec is cool; at least: I presume it's roughly the same as the parser combinators stuff that I learned from Odersky's scala book
17:44:51 <marchelzo_> P4Titan: no
17:45:38 <P4Titan> So, if I did try (char '#') >> oneOf "bdox" and had #f to parse, effectivly the input would remain untouched
17:46:28 <marchelzo_> P4Titan: I believe the input would be "f". try (char '#') would succeed
17:46:51 <P4Titan> ohh, true, I forgot about that thanks!
17:47:04 <marchelzo_> try (char '#' >> oneOf "bdox") would leave it unchanged
17:47:11 <P4Titan> Yes
17:50:15 <DanC_> intellij is installing haskell-mod; I'm not familiar with that...
17:52:43 <DanC_> or is it gjc-mod ...
17:52:55 <texasmynsted> anybody know if vim-haskellmode and vim-hdevtools plugins conflict?
17:58:47 <DanC_> Error:(1, 1) ghc: The function `main' is not defined in module `Main'
18:04:15 <DanC_> ok... now to get the database password out of gnomekeyring
18:04:46 <DanC_> yay... http://hackage.haskell.org/package/gnome-keyring
18:08:45 <benzrf> guhnoam
18:12:03 <bananagram> I'm getting this error a lot: http://lpaste.net/8300312350091640832 anyone recognize it?
18:12:15 <bananagram> I'm not sure what's causing it, but recompiling everything didn't help
18:13:57 <mongoose> alright, here come the noob questions. what resource would you think is the best for learning haskell if I'm a semi-experienced programmer?
18:14:30 <bananagram> mongoose: https://github.com/bitemyapp/learnhaskell and join #haskell-beginners
18:14:36 <mongoose> ah, tyty
18:14:39 <mongoose> sorry for the trouble
18:14:42 <texasmynsted> https://github.com/bitemyapp/learnhaskell
18:14:47 <texasmynsted> ooops
18:14:50 <texasmynsted> you beat me too it
18:14:54 <texasmynsted> or to it rather
18:14:55 <bananagram> it's what we're for
18:15:23 <bananagram> he should've stayed in this channel though
18:15:30 <texasmynsted> it is more active
18:15:51 <DanC_> gnome-keyring-0.3.1 failed during the configure step. The exception was:
18:15:51 <DanC_> ExitFailure 1
18:16:12 <DanC_> oh...
18:16:14 <DanC_> cabal: The program 'c2hs' version >=0.16 is required but it could not be
18:16:14 <DanC_> found.
18:18:17 <DanC_> "you should add the following line to your Cabal file:
18:18:17 <DanC_> Build-tools: c2hs"
18:18:18 <DanC_> no joy
18:19:10 <Welkin> hsc2hs?
18:20:02 <DanC_> what about it?
18:20:22 <Welkin> hsc2hs or c2hs?
18:20:33 <Welkin> are they different?
18:20:41 <DanC_> you're asking me?
18:23:59 <DanC_> `cabal install c2hs` seems to be working... but shouldn't that be triggered by the .cabal file somehow?
18:24:11 <mietek_> DanC_: ha
18:24:28 * DanC_ didn't realize he was making a joke
18:24:31 <mietek_> DanC_: you've ran into a limitation of Cabal which has been outstanding since at least 2008
18:24:37 <Welkin> how much of a load can an ec2 t2.micro instance support when running a yesod CRUD app?
18:25:02 <DanC_> I expect the database would be the rate-limiting factor, Welkin
18:25:40 <Welkin> well, the database will be on RDS
18:25:45 <Welkin> so it won't be on the micro instance
18:25:48 <mietek_> DanC_: https://github.com/haskell/cabal/issues/220
18:26:08 <mietek_> Welkin: how are you going to deploy your app to the instance?
18:26:21 <Welkin> as a binary
18:27:26 <mietek> Welkin: I'm asking because I'm working on a system for making this part easier.
18:27:49 <Welkin> I've never deployed before
18:27:52 <mietek> If you're interested, join #haskell-deployment.
18:27:55 <Welkin> so I don't know what it entails
18:28:17 <DanC_> familar problems now... $ sudo apt-get install libgnome-keyring-dev
18:29:20 <DanC_> whee! 1st gnome-keyring API call worked
18:35:38 <npasco> Here's a trivia quesion. Given 1 and [1..3], tell me the short one-liner that produces [1,4,3,6,2,5,4,7].
18:36:32 <Axman6> I don't see the relationship between the inputs and output
18:36:34 <Axman6> but
18:36:41 <cdk> npasco: what's the algorithm it's supposed to implement, otherwise I could write: const (const [1,4,3,6,2,5,4,7])
18:36:51 <Axman6> > let f 1 [1,2,3] = [1,4,3,6,2,5,4,7] in f 1 [1..3]
18:36:53 <lambdabot>  [1,4,3,6,2,5,4,7]
18:37:14 <npasco> cheating! you can only use 1 and [1..3] as inputs
18:37:37 <cdk> npasco: neither I nor Axman6 used anything but 1 and [1..3] as input :)
18:38:01 <npasco> I've been experimenting with the list monad
18:38:08 <Axman6> in fact, that's _all_ I can use as input!
18:38:37 <npasco> foldM f 1 [1..3]  for some f
18:38:54 <Axman6> you're doing a very poor job of explaining yourself
18:39:25 <npasco> ok the answer is foldM (\a b -> [a, a + b]) 1 [1..3]
18:39:33 <npasco> just learning the list monad today
18:40:11 <Axman6> well you didn't explain wht the pattern is supposed to be at all, so it was impossible to help
18:40:29 <indiagreen> Axman6: aw c'mon, it was supposed to be a puzzle
18:40:47 <indiagreen> and you all immediately started searching for loopholes instead
18:40:48 <indiagreen> tsk
18:40:53 <Axman6> right, a puzzle that has a trivial answer, which cdk and I both gave
18:41:14 <npasco> good grief
18:41:25 <Axman6> there was no clear pattern, so it wasn't possible to tell how the algorithm should operate
18:41:32 <cdk> indiagreen: there are a combinatorial explosion of possible answers that would give that output for those inputs. Almost none of them would be what npasco would have intended.
18:41:56 <indiagreen> cdk: almost all of them would've been contrived beyond measure
18:42:04 <cdk> indiagreen: i agree :)
18:42:11 <cdk> that's why the question was ill-formed
18:42:21 <indiagreen> npasco: next time put the word “elegant” there
18:42:30 <zwer_l> npasco did you really want that result or were just shoving things into foldM and observed what came out? :)
18:42:34 <indiagreen> then you can dismiss all answers you don't like as inelegant
18:42:51 <cdk> whats a function that takes 1 as input and returns 2?
18:43:10 <indiagreen> zwer_l: I guess ne observed what came out, got amused and decided to share it with us
18:45:02 <batchm> i am actually having trouble figuring out how that foldM works
18:45:14 <batchm> @src foldM
18:45:14 <lambdabot> foldM _ a []     = return a
18:45:14 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
18:45:24 <npasco> it seemed possible that someone could come up foldM (\a b -> [a, a + b]) 1 [1..3]. It was supposed to be fun. Never mind. Good grief.
18:45:34 <cdk> batchm: remember that (>>=) for the list monad is concatMap
18:45:43 <batchm> I know that
18:45:59 <cdk> okay, that should help understand whats going on
18:46:34 <Axman6> npasco: I would argue it's almost impossible to come up with that solution without some kind of explanation of the desired pattern
18:47:33 <npasco> Axman6: I think it's possible, but in any case I said foldM f 1 [1..3] for some f
18:48:48 <npasco> batchm: It helps to trace the steps 1 => 1,2 => 1,3,2,4 => 1,4,3,6,2,5,4,7
18:51:49 <Axman6> you didn't say foldM though
18:52:08 <Axman6> "Here's a trivia quesion. Given 1 and [1..3], tell me the short one-liner that produces  [1,4,3,6,2,5,4,7].
18:52:11 <Axman6> "
18:52:33 <npasco> "foldM f 1 [1..3]  for some f"
18:54:22 <geoffrey`> :t foldM
18:54:23 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
18:54:47 <npasco> Axman6: the sequence does have patterns; every pair differs by 3, and so forth. I think a smart guy could work backwards, given some time, which is why I didn't immediately mention foldM.
18:55:17 <batchm> you should have left us hanging a bit after mentioning foldM
18:55:53 <npasco> yeah, I was reacting to Axman6 too soon
18:57:02 <Axman6> based on the initial question, there are infinite answers, but with the foldM hint there are certainly more obvious answers
18:57:13 <batchm> here's another trivia (that I could not solve)
18:58:10 <batchm> so actually a question, but I will try to pass it as a trivia :)
18:59:04 * Axman6 doesn't thing "a trivia" makes sense
18:59:46 <batchm> how would rewrite this using fold? http://lpaste.net/114217
19:01:47 <cdk> :t S.toList . foldr (\x s -> if S.memebr x s then s else S.insert x s) S.empty
19:01:48 <lambdabot>     Not in scope: ‘S.memebr’
19:01:48 <lambdabot>     Perhaps you meant one of these:
19:01:48 <lambdabot>       ‘S.member’ (imported from Data.Set),
19:01:54 <cdk> :t S.toList . foldr (\x s -> if S.member x s then s else S.insert x s) S.empty
19:01:55 <lambdabot> Ord a => [a] -> [a]
19:02:18 <cdk> actually, it's simpler
19:02:20 <batchm> gotcha
19:02:23 <batchm> I did the same
19:02:29 <batchm> > (S.toList . foldr (\x s -> if S.member x s then s else S.insert x s) S.empty) [1..]
19:02:34 <lambdabot>  mueval-core: Time limit exceeded
19:02:35 <lambdabot>  mueval: ExitFailure 1
19:02:36 <cdk> S.toList . foldr S.insert S.empty
19:02:37 <batchm> it does not handle infinite lists, for some reason
19:02:39 <batchm> my function does
19:02:46 <batchm> why? and how to make it handle infinite lists?
19:02:48 <cdk> you don't need to check for inclusion in the set
19:03:00 <cdk> if x is already in the set, insert is idempotent
19:03:10 <batchm> > (S.toList . foldr S.insert S.empty) "baccc"
19:03:12 <lambdabot>  "abc"
19:03:14 <batchm> changes order
19:03:15 <cdk> idx about infinite lists
19:03:19 <batchm> > (S.toList . foldr S.insert S.empty) [1..]
19:03:25 <lambdabot>  mueval: ExitFailure 1
19:03:45 <batchm> I thought it was just a right fold too, but for some reason it can't handle infinite lists
19:03:46 <Axman6> batchm: that doesn't maintain order
19:03:58 <Axman6> bleh, you already said that
19:04:18 <indiagreen> batchm: cdk's function is just “S.toList . foldl insertIfNotThere S.empty $ [1..]”
19:04:24 <indiagreen> it's not the same
19:04:31 <cdk> well using Set at all is gonna mess around with the order of elements
19:04:32 <indiagreen> *foldr
19:04:39 <Axman6> insert and insertIfNotthere are the same function...
19:04:42 <indiagreen> exactly
19:04:53 <Axman6> cdk: no it's not
19:05:19 <indiagreen> while batchm's original function uses “emitAnElementIfNotThere”
19:05:33 <cdk> Axman6: yes it will, set maintains its own ordering which is probably different than the order they occur in the list
19:05:57 <Axman6> right
19:06:02 <batchm> http://lpaste.net/114217
19:06:04 <cdk> > S.toList . S.fromList $ [3,2,1]
19:06:05 <lambdabot>  [1,2,3]
19:06:07 <batchm> that was my attempt at using foldr
19:06:22 <batchm> and, like cdk's, it doesn't handle infinite lists
19:06:23 <Axman6> the point is just to remove duplicates but maintain ordering, you just need to use the set to find known values and filter based on them
19:07:16 <Axman6> > reverse . fst . foldl (\(xs,s) x -> if S.member x s then (xs, s) else (x:xs, S.insert x s)) ([],S.empty) $ [1,2,3,4,3,2,1]
19:07:17 <lambdabot>  [1,2,3,4]
19:07:33 <Axman6> > reverse . fst . foldl (\(xs,s) x -> if S.member x s then (xs, s) else (x:xs, S.insert x s)) ([],S.empty) $ [1,2,3,4,3,2,1] ++ [1..]
19:07:38 <lambdabot>  mueval: ExitFailure 1
19:07:43 <Axman6> uh right
19:07:48 <batchm> reversing infinite list will take long :)
19:08:08 <Axman6> :t scanl
19:08:09 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
19:10:53 <Welkin> what about a circular list?
19:10:59 <Welkin> I suppose that is still infinite
19:11:10 <Welkin> but what if you just wanted to reverse the pattern?
19:11:10 <Axman6> yeah, not possible to tell if it's circular
19:16:28 <Welkin> If I want to store my credentials/keys in the system environment, should I getEnvironment each time I want to access them? Or should I get it once and thread it through the program?
19:16:48 <cdk> Welkin: get it once and use Reader/State
19:20:27 <Luke_Rubcic> i'm selling comics 1$ each please check out my store http://www.ebay.com/cln/luke_rubcics_comics/comics/133704481010
19:36:50 <HeladoDeBrownie> I have a datatype with an existential variable in some of its cases, but for which the Functor definition is defined rather mechanically. Is there any proposal to allow deriving Functor for cases like this, or is it not possible for some reason?
19:37:41 <HeladoDeBrownie> data F b = forall a. Foo a (a -> b) -- as an example
19:38:32 <kadoban> HeladoDeBrownie: Maybe this? http://byorgey.wordpress.com/2010/03/03/deriving-pleasure-from-ghc-6-12-1/
19:39:16 <HeladoDeBrownie> kadoban, sure, that makes reference to the language extension I was alluding to
19:39:49 <HeladoDeBrownie> However that extension doesn't allow deriving Functor when the data type has existential type variables
19:40:09 <HeladoDeBrownie> I'm wondering if it's still possible, but just that there isn't an algorithm in GHC for it yet
19:40:16 <kadoban> Ah
19:44:33 <HeladoDeBrownie> kadoban, actually that Derive tool looks interesting, thanks for linking that
19:44:57 <kadoban> 'welcome, glad I accidentally helped :)
20:03:26 <Pamelloes> Is there a way to use HUnit with an infinite list?
20:06:40 <gcganley> edwardk: i noticed halfway through your lens talk at NY that the subtitles dropped off. would you like someone to subtitle your videos?
20:08:19 <jayunit100> any xmonad users ?
20:08:25 <jayunit100> #xmonad seems empty
20:09:28 <pharaun> jayunit100: normal, its quiet
20:09:30 <gcganley> jayunit100: i tried using it but it didnt run on my system at all
20:09:39 <pharaun> jayunit100: but ask your question folks will answer if you hang around
20:09:43 <pharaun> also i'm a heavy xmonad user
20:09:54 <jayunit100> okay great
20:09:58 <gcganley> i really want to use xmonad but I dont grok it
20:10:08 <gcganley> im using i3
20:10:19 <pharaun> gcganley: in what way?
20:10:29 <pharaun> i haven't tried i3 but i'm pretty happy with xmonad so i stick with it :)
20:10:32 <MP2E> i use xmonad and like it quite a lot
20:11:06 <HeladoDeBrownie> Can I get a cherry on top of my net split?
20:11:54 <gcganley> pharaun: i try and use xmonad but i just get so easily lost with commands, I guess the only thing thats REALLY holding me back is the fact that i havent sat down with a cup of coffee and read wiki's and read the cheat sheets and read the docs
20:14:43 <pharaun> ahhh np :)
20:15:04 <pharaun> yeah its a bit much to start but i suspect its somewhat similar with switching to a tiling paradigm
20:15:18 <pharaun> when i first switched i tried ion3 and a few others a little much then i got a handle of it all
20:17:26 * hackagebot markdown 0.1.12 - Convert Markdown to HTML, with XSS protection  http://hackage.haskell.org/package/markdown-0.1.12 (MichaelSnoyman)
20:17:40 <Welkin> this is tricky
20:17:49 <Welkin> with all the conversions between Text and ByteString
20:18:00 <Welkin> how can I convert Text -> ByteString ?
20:18:08 <Welkin> I tried encodeUtf8
20:18:50 <Axman6> Welkin: what went wrong?
20:19:11 <Welkin> Couldn't match expected type ‘Data.ByteString.Internal.ByteString’ with actual type ‘[a0]’
20:19:41 <Welkin> I am converting Text to a ByteString, then appending a string literal to it
20:20:02 <Axman6> how are you trying to append the string literal?
20:20:09 <Axman6> that doesn't sound right at all
20:20:17 <Welkin> using (++)
20:20:27 <Axman6> ByteStrings aren't lists
20:20:36 <Welkin> ah
20:20:38 <Welkin> I forgot
20:21:54 <gcganley> isnt there a ghc language pragma for that sort of conversion
20:22:15 <Iceland_jack> OverloadedStrings?
20:22:26 * hackagebot shakespeare 2.0.1.2 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-2.0.1.2 (MichaelSnoyman)
20:22:35 <gcganley> yup thats the one
20:23:54 <Welkin> how can I get it to interpret the string literal as Text when applying (++)
20:23:58 <Welkin> explicit type annotation?
20:24:03 <Welkin> or T.pack?
20:24:16 <kadoban> :t (++)
20:24:17 <lambdabot> [a] -> [a] -> [a]
20:24:33 <comerijn> Welkin: You can't apply ++ to Text
20:24:35 <kadoban> Welkin: I don't think you can use (++) on Text at all...
20:24:38 <comerijn> Welkin: That's a type error
20:24:40 <Welkin> hm, okay
20:24:50 <merijn> Use <> from Data.Monoid
20:25:18 <gcganley> is there a instance of Text for monooid?
20:26:10 <prinsen> Im playing with DataKinds, is there a way to write a class C a b (c :: Bool) where fun :: c -> a -> b?
20:27:19 <Axman6> gcganley: yes, of course
20:27:21 <prinsen>  I get Expected a type, but ‘c’ has kind ‘Bool’
20:28:03 <merijn> prinsen: No
20:28:10 <merijn> You can't write fun
20:28:19 <gcganley> Axman6: i've never used the Text library
20:28:22 <codygman> How can I pipe a bytestring or Text to a command such as head (or lynx) via stdin with conduit-shell?
20:28:23 <merijn> Because function can't have types with kind Bool
20:28:45 <merijn> prinsen: What would an implementation of that function look like?
20:28:48 <prinsen> merijn: I want c as aparameters to specify which class instance I want
20:29:19 <merijn> prinsen: Then use it as a constraint
20:29:36 <merijn> "fun :: (c ~ True) => a -> b" or something along those line
20:30:00 <merijn> prinsen: Or use Proxy
20:30:06 <merijn> "fun :: Proxy c -> a -> b"
20:30:28 <merijn> Or, more general "fun :: proxy c -> a -> b"
20:33:12 <prinsen> merijn: Couldn't match kind ‘*’ with ‘SubTypeKind’
20:33:12 <prinsen>     Expected type: Proxy kind0
20:33:12 <prinsen>       Actual type: Proxy kind1
20:33:13 <prinsen>     In the first argument of ‘inj'’, namely ‘(undefined :: Proxy kind)’
20:33:27 <prinsen> to translate
20:33:39 <prinsen> fun (undefined :: Proxy c)
20:36:47 <dfeuer_> Is there a function like cycle but that cycles a fixed number of times? Or just concat . replicate n ?
20:37:14 <unfoldable> hi #haskell. i'm looking around a hxt + lens things; i found this - https://gist.github.com/fizbin/7195271 - but it's kind of unpleasant. does anyone know of anything else?
20:37:36 <unfoldable> i'm trying to clean up all this "uncurryN, xNTuple" that becomes necessary ...
20:38:14 <unfoldable> say here - https://www.haskell.org/haskellwiki/HXT/Conversion_of_Haskell_data_from/to_XML#The_predefined_picklers
20:40:14 <unfoldable> i'd be happy with just avoiding the "xpWrap" definition, and replacing it with some fancy lens thing that provides the (a -> b, b -> a) for arbitrary data creation/destructuring
20:40:34 <unfoldable> but i don't know how quite to express the tupling in the form of a lnes
20:41:00 <lispy> unfoldable: ask in #haskell-lens
20:41:05 <unfoldable> i.e. replace \thing -> (thing ^. foo1, thing ^. foo2, ...) with \thing -> magic ...
20:41:12 <unfoldable> ah, cheers @lispy
20:42:45 <DanC_> I've got some functions in IO and others in Either and I'm struggling to mix them. I'd like to factor out the left parts...
20:42:45 <DanC_> check :: Either GK.KeyringError [GK.NetworkPassword] -> Either Problem DB.ConnectInfo
20:43:59 * DanC_ suspects this is what lift is for
20:44:09 <DanC_> I have yet to grok lift fully
20:44:29 <Welkin> :t lift
20:44:30 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
20:44:31 <Welkin> :t liftIO
20:44:32 <lambdabot> MonadIO m => IO a -> m a
20:45:39 <DanC_> I see the puzzle pieces. I don't see how they fit
20:45:45 <lispy> DanC_: isn't that a weird type for check?
20:45:51 <Welkin> I don't exactly understand it either
20:46:00 <Welkin> I'm getting more used to it with time, though
20:46:04 <lispy> DanC_: I would expect check :: [GK.NetworkPassword] -> Either Problem DB.ConnectInfo
20:46:23 <DanC_> yeah, but the function I call before check returns an Either
20:46:33 <DanC_> and I can't figure out how to factor out the left part
20:46:53 <Welkin> compute the action and pattern match the result?
20:47:15 <lispy> > fmap (+1) (Right 1)
20:47:17 <lambdabot>  Right 2
20:47:26 <lispy> > fmap (+1) (Left "Oh no!")
20:47:28 <lambdabot>  Left "Oh no!"
20:48:21 <DanC_> fmap looks handy...
20:48:38 <DanC_> but I think my left types don't line up either. still pondering...
20:50:43 <lispy> actually, seems like check probably has to do IO
20:51:02 <lispy> So more like check :: [GK.NetworkPassword] -> IO (Either Problem DB.ConnectInfo)
20:54:54 <DanC_> but I don't have (Right 1); I have (Right 1) inside IO
20:55:14 <HeladoDeBrownie> fmap . fmap
20:55:48 <jayunit100> what does =<< do?
20:55:59 * DanC_ gets yet another 15 line error message
20:56:01 <jayunit100> very hard to google for ^ Im hacking in xmonad
20:56:05 <merijn> jayunit100: "flip (=<<)"
20:56:11 <merijn> jayunit100: Also, see Hoogle
20:56:14 <merijn> eh
20:56:19 <merijn> "flip (>>=)" >.>
20:56:23 <merijn> :t (>>=)
20:56:24 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:56:27 <merijn> :t (=<<)
20:56:28 <lambdabot> Monad m => (a -> m b) -> m a -> m b
20:56:39 <merijn> @where hoogle
20:56:39 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
20:58:24 <DanC_> I have IO (Either Problem DB.ConnectInfo) and I want to use dbJob :: DB.Connection -> IO Int
20:58:51 <DanC_> I have maybeAccess :: IO (Either Problem DB.ConnectInfo) and I want to use dbJob :: DB.Connection -> IO Int
20:59:04 <DanC_> (fmap . fmap) dbJob maybAccess
20:59:08 <DanC_> ^ didn't typecheck
20:59:41 <merijn> DanC_: Look into ExceptT
20:59:48 <merijn> From transformers
21:00:46 <DanC_> whimper. no examples. http://hackage.haskell.org/package/transformers-0.4.1.0/docs/Control-Monad-Trans-Except.html
21:03:12 <merijn> :t ExceptT
21:03:13 <lambdabot> Not in scope: data constructor ‘ExceptT’
21:03:15 <merijn> hmm
21:03:36 <L8D> @let 1 + 2 = 1
21:03:38 <lambdabot>  Defined.
21:03:41 <L8D> > 1 + 2
21:03:44 <lambdabot>  Ambiguous occurrence ‘+’
21:03:44 <lambdabot>  It could refer to either ‘L.+’, defined at L.hs:176:3
21:03:44 <lambdabot>                        or ‘GHC.Num.+’,
21:03:44 <lambdabot>                           imported from ‘Prelude’ at L.hs:40:8
21:03:44 <lambdabot>                           (and originally defined in ‘base:GHC.Num’)
21:03:53 <L8D> @unlet (+)
21:03:53 <lambdabot>  Parse failed: TemplateHaskell is not enabled
21:03:59 <merijn> DanC_: "ExceptT :: m (Either e a) -> ExceptT e m a"
21:03:59 <L8D> -.-
21:04:02 <L8D> whoops
21:04:17 <L8D> > 1 L.+ 2
21:04:17 <merijn> DanC_: So in your case "ExceptT Problem IO a"
21:04:18 <lambdabot>  1
21:04:22 <L8D> > 1 L.+ 3
21:04:24 <lambdabot>  *Exception: L.hs:176:1-9: Non-exhaustive patterns in function +
21:04:41 <merijn> DanC_: Whether it makes sense depends on how many times you run into errors
21:04:51 <merijn> DanC_: Alternatively, just pattern match
21:05:23 <DanC_> I've been pattern matching... but it seems repetitive
21:05:27 <merijn> DanC_: "do { result <- maybeAccess; case result of Left err -> doStuffWithErr err; Right conn -> dbJob conn"
21:06:05 <merijn> DanC_: Right, the alternative is to turn everything into "ExceptT Problem IO a" and >>= and fmap and then "runExceptT" at the end to get the final Either
21:06:07 <DanC_> I was using where rather than case; I'll try case...
21:06:15 <merijn> But that means all the intermediate stuff should be lifted
21:07:25 <Welkin> okay
21:07:27 * hackagebot shared-buffer 0.2 - A circular buffer built on shared memory  http://hackage.haskell.org/package/shared-buffer-0.2 (JohnLato)
21:07:41 <Welkin> I have a ByteString that, for some reason, has quotes surrounding it
21:07:49 <Welkin> and when I cal "show" they get escaped
21:07:54 <Welkin> which is not what I want
21:08:14 <Welkin> > show "hello"
21:08:16 <lambdabot>  "\"hello\""
21:08:20 <Welkin> hm
21:08:32 <Welkin> I wonder why the bytestring has quotes around it in the first place...
21:08:54 <Welkin> could it be that I appended onto it a string literal using <>?
21:09:22 <L8D> > (show . show) "hello"
21:09:24 <lambdabot>  "\"\\\"hello\\\"\""
21:09:37 <Welkin> > show $ T.encodeUtf8 "hello" <> " there"
21:09:39 <lambdabot>  Not in scope: ‘T.encodeUtf8’
21:09:44 <Welkin> > show $ encodeUtf8 "hello" <> " there"
21:09:46 <lambdabot>  Not in scope: ‘encodeUtf8’
21:09:56 <Welkin> > show $ Data.Text.Encoding.encodeUtf8 "hello" <> " there"
21:09:57 <lambdabot>  Not in scope: ‘Data.Text.Encoding.encodeUtf8’
21:10:09 <L8D> :t (<>)
21:10:10 <lambdabot> Monoid m => m -> m -> m
21:10:13 <DanC_> aha! I'm winning with case. here's hoping for time to puzzle through ExceptT
21:10:35 <L8D> is (<>) = mappend ?
21:10:55 <kadoban> L8D: Yeah.
21:11:05 <L8D> all this typing wasted...
21:11:10 <kadoban> Hehe
21:12:35 <Welkin> I want to show the ByteString without escaping any characters
21:12:44 <Welkin> > print "hello"
21:12:45 <L8D> :t liftIO
21:12:46 <lambdabot>  <IO ()>
21:12:46 <lambdabot> MonadIO m => IO a -> m a
21:12:49 <Welkin> er
21:12:59 <Welkin> print works then?
21:13:31 <prinsen> https://www.google.se/webhp?sourceid=chrome-instant&ion=1&espv=2&ie=UTF-8#q=haskell%20advanced%20oerlap
21:14:06 <prinsen> That paper is crap. They says it can be solved with closed type families, but the pieces they present dont fit and wont compile
21:14:18 <prinsen> https://www.haskell.org/haskellwiki/GHC/AdvancedOverlap
21:14:49 <HeladoDeBrownie> Welkin, nah, print tends to show the way you'd write it in a Haskell file. You want Data.ByteString.putStr or the like
21:15:06 <Welkin> HeladoDeBrownie: or convert it to Text?
21:15:08 <Welkin> T.pack
21:15:52 <HeladoDeBrownie> Welkin, if it's textual data whose encoding you know, sure
21:16:28 <HeladoDeBrownie> Welkin, I don't think there's a pack :: ByteString -> Text
21:16:33 <HeladoDeBrownie> Welkin, however there are decoding functions
21:16:36 <Welkin> thanks for the tip
21:16:44 <Welkin> BS.putStr works great
21:16:52 <HeladoDeBrownie> Cool
21:17:22 <Welkin> ahg
21:17:24 <Welkin> never mind
21:17:30 <Welkin> it is still escaping the quotes
21:17:45 <HeladoDeBrownie> That's odd
21:17:46 <Welkin> something to do with the toHtml renderer
21:17:54 <Welkin> in my hamlet template
21:18:02 <Welkin> it escapes it to html
21:18:09 <Welkin> &quot;
21:18:12 <HeladoDeBrownie> Ah, yeah, if there are actually quotes preceded by backslashes in the input, that'd explain it :P
21:18:25 <Welkin> well, I need it to be literal quotes
21:18:30 <Welkin> since it is inside of a <script> tage
21:18:53 <Welkin> or no quotes at all, so I can wrap it in quotes inside my template
21:19:07 <HeladoDeBrownie> Is your script actually dynamically generated?
21:19:17 <Welkin> yes
21:19:18 <DanC_> hmm... how do I import a newtype?
21:19:21 <Welkin> these variables are
21:19:26 <HeladoDeBrownie> DanC_, same way as with data
21:19:45 <DanC_> Only(..)
21:19:45 <Welkin> they are URLs
21:19:47 <DanC_> got it. thanks
21:20:24 <HeladoDeBrownie> Welkin, probably the converter isn't aware of the behavior of script elements. Unfortunate.
21:21:09 <Welkin> I think it can hadle rendering of Text properly
21:21:12 <Welkin> I'll try that
21:22:58 <prinsen> merijn: Im reading https://www.haskell.org/haskellwiki/GHC/AdvancedOverlap and tried to implement the solution no. 4 and came up with http://lpaste.net/114223, but it wont compile. Is the paper wrong or am I missing something?
21:24:59 <Welkin> HeladoDeBrownie: this seems to works
21:25:02 <Welkin> work*
21:25:13 <Welkin> just using T.decodeUtf8
21:25:25 <benzrf> bye
21:26:51 <HeladoDeBrownie> Welkin, careful with that one, if you want to handle errors it may be better to use decodeUtf8'
21:27:34 <merijn> prinsen: Ick, overlapping instances...
21:28:15 <merijn> prinsen: Since you're already programming with -XKitchenSink, why not just switch to ConstraintKinds?
21:29:26 <merijn> prinsen: Here's an example using closed type families and ConstraintKinds instead of typeclasses: https://gist.github.com/merijn/6130082
21:29:48 <merijn> prinsen: Probably you wanna use constraintkinds to control instances of the typeclass or something along those lines?
21:31:07 <SrPx> Is there an algorithm to test if 2 combinators define a turing-complete system, as well as the corresponding mapping between lambda calculus and that system?
21:31:53 <DanC_> intellij lost its marbles when I tried to rename a module
21:33:20 <DanC_> 8 seconds to compile this code... it's like 100 lines. is that intellij, or is ghc that slow? let's see...
21:33:37 <Welkin> not ghc
21:33:46 <prinsen> merijn: Dont know what KitchenSink is :)
21:33:54 <merijn> prinsen: A joke :p
21:33:57 <carter> DanC_: @lpaste it
21:33:58 <DanC_> ghc takes 3 seconds
21:34:01 <carter> @lpaste
21:34:01 <lambdabot> Haskell pastebin: http://lpaste.net/
21:34:07 <carter> DanC_: what GHC flags
21:34:10 <carter> also
21:34:15 <DanC_> just `cabal build`
21:34:20 <carter> what code :)
21:34:40 <carter> DanC_: i can show you code that takes .... more time than the universe to compile
21:34:43 <DanC_> I'll push it to github or something presently
21:34:44 <carter> but is like 7 lines
21:34:45 <carter> :)
21:34:47 <Axman6> GHC isn't particularly fast
21:34:50 <carter> that too
21:34:59 <carter> Axman6: wanna help profile it and stuff for making it faster in 7.12?
21:35:05 <Axman6> no
21:35:10 <Axman6> sorry, no time
21:35:12 <carter> we dont have anyone owning perf engineering on making ghc fasterrr
21:35:13 <carter> fine
21:35:19 <carter> help us find someone plz :)
21:35:22 <DanC_> what are typical compile times and code sizes for anything anybody here is working on?
21:35:26 <carter> DanC_: depends
21:35:33 <Axman6> I would like to, but other work is more important for work at the moment =)
21:35:42 <DanC_> I know it depends. I'm interested in anecdotal evidence
21:35:50 <carter> Axman6: fair, but if you can get someone else excited, that'd be nearly as good
21:35:54 <merijn> prinsen: See https://en.wiktionary.org/wiki/everything_but_the_kitchen_sink and the related https://en.wiktionary.org/wiki/kitchen-sinky
21:35:58 <carter> DanC_: 1 second to 10 mintues
21:36:00 <Axman6> if it incl;udes lens or yesod, the average time is "long"
21:36:06 <Welkin> haha
21:36:14 <carter> Axman6: you mean lots of TH == yesod
21:36:15 <prinsen> merijn: This example is really cool, not sure if I can use it but still
21:36:18 <Axman6> yeah
21:36:21 <Welkin> yesod libraries take a while
21:36:24 <Welkin> like, half an hour
21:36:38 <Welkin> but compiling a yesod application takes only a few seconds
21:36:43 <Welkin> but it is still slow for development
21:36:44 <Axman6> yeah
21:36:59 <Axman6> Chris Done has some cool stuff for quick development using yesod
21:38:40 <bryanedds> Is there an unfold that has a nicer signature for threading through state?
21:39:09 <bryanedds> I have an immutable rng data value that I want to 'thread' through it
21:40:06 <Welkin> argh
21:40:14 <Welkin> this toHtml rendering function is a pain
21:40:17 <Axman6> :t unfoldl
21:40:18 <lambdabot>     Not in scope: ‘unfoldl’
21:40:18 <lambdabot>     Perhaps you meant one of these:
21:40:18 <lambdabot>       ‘Seq.unfoldl’ (imported from Data.Sequence),
21:40:21 <Welkin> it is messing up my aws s3 urls
21:40:23 <Axman6> :t unfoldr
21:40:24 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
21:40:30 <Welkin> now it is escaping the &'s
21:40:52 <Welkin> into html &amp;
21:40:54 <Axman6> bryanedds: what's the problem? the b is clearly supposed to be some kind of state parameter
21:41:03 <Welkin> damn it
21:41:08 <Welkin> how can I have it not escape anything
21:41:09 <Axman6> Welkin: then toHtml is the wrong thing to be using
21:41:14 <Welkin> and just show the text as-is?
21:41:18 <kadoban> Welkin: Are you sure you're using whatever API correctly? It sounds a lot like you're fighting too much with it...
21:41:22 <Welkin> I am not using it by choice
21:41:26 <Welkin> it is how the templates render
21:41:38 <Welkin> I am embedding this url in a script tag in the html template
21:42:25 <Welkin> kadoban: I am getting the urls signed properly, bt they are not displaying properly in the template -- it keeps escaping characters into html
21:42:49 <bryanedds> maybe I'm just using it awkwardly
21:43:03 <kadoban> No idea what template you're talking about... Whatever it is though, it seems like it's not designed for what you're doing, or there's a separate way to accomplish it.
21:43:57 <Welkin> it's possible it wouldn't escape them if I were to put it in a .julius template instead of embedding the javascript in a script tag inside the .hamlet template
21:45:09 <DanC_> enough for tonight, I think. Tonight's task was actually some family budget work, but I wanted to put a web interface on the python scripts I use, and I figured I would port them to haskell while I'm at it. Slow going so far; I hope it gets quicker in due course.
21:45:54 <bryanedds> nah, it's the signature that's weird for threading state
21:45:57 <Welkin> DanC_: what framework/server are you using?
21:46:01 <DanC_> I was able to (a) get credentials out of the gnome keyring, and (b) run a mysql query. I think developing that bit in python took quite a while, actually.
21:46:22 <DanC_> I expect to use scotty, I think
21:47:56 <merijn> DanC_: It gets significantly easier with time
21:48:31 <merijn> DanC_: When I started something like the ExceptT docs took me days to grok, now I scan them over in a few mins and go "oh, that's obvious"
21:48:37 <Welkin> I've been learning/using yesod for about 2.5 weeks now
21:48:53 <Welkin> I'm often fighting with it
21:49:02 <Welkin> but it has been getting easier
21:49:10 <Welkin> except this julius template won't compile now...
21:49:25 <DanC_> yesod looks like way more than I need. it's certainly more than I want ;-)
21:49:43 <pharpend> Hey, question
21:49:51 <pharpend> I'm trying to use quickCheck
21:50:29 <DanC_> fwiw, the python I'm sort of porting: https://bitbucket.org/DanC/quacken/src/4228246b5e66fc4b80d53fc50c753b8cfc0c9359/budget_sync.py?at=default
21:50:36 <pharpend> QuickCheck is giving me compile errors like this - http://lpaste.net/114224
21:50:47 <pharpend> Can quickCheck not choose an arbitrary type
21:51:03 <pharpend> So, I have a function like this
21:51:04 <pharpend> prop_fmapIdId :: Eq a => ArgumentResult a -> Bool
21:51:12 <pharpend> and quickcheck can't choose some a to satisfy that
21:51:28 <pharpend> doesn't that drastically limit quickcheck's power?
21:51:45 <Welkin> okay... what is with this?
21:51:54 <Welkin> I cannot use variable inside the .julius template
21:52:00 <pharpend> yes
21:58:53 <Welkin> well
21:59:16 <Welkin> it turns out you need to call `toJSON` on any interpolated variable inside of a julius template
21:59:22 <Welkin> something not mentioned anywhere in the docs
21:59:31 <Welkin> the yesod docs need *a lot* of work
21:59:56 <Axman6> pharpend: you need to specify a concrete type, or it will usually default to (), which is pretty useless
22:00:03 <pharpend> well yeah
22:00:26 <Axman6> Welkin: that doesn't sound right...
22:01:19 <pharpend> Axman6: well shit
22:01:59 <prinsen> merijn: You seem to know this stuff. Is there any way to use that tecnique to make the instances: instance a a where ... and instance (Either a b) (Either a (Either c d)) Not overlapping by restricting b from unifying with Either c d
22:02:14 <pharpend> Axman6: here's what I'm doing now
22:02:16 <pharpend>                        , testProperty "fmap id == id" (prop_fmapIdId :: AR Entry -> Bool)
22:02:28 <pharpend> sorry about the whitespace, it's deep inside a test suite
22:02:30 <pharpend> ow
22:02:35 <pharpend> holy shit it passed
22:04:18 <Welkin> Axman6: eithe toJSON or rawJs
22:04:28 <merijn> prinsen: Not in any obvious way
22:04:55 <merijn> prinsen: You could pile on a ton of hacks and probably get it to work, but that requires more intellectual activity than I'm capable of right now :p
22:05:47 <prinsen> merijn: I think im going to skip this SubType class. It would be nice to have but isn't really nesessary
22:06:12 <dfeuer_> prinsen, all I know about overlapping instances is that they have way too many complicated rules to be trusted, and they seem to be hard to use in practice.
22:06:24 <Welkin> wow
22:06:30 <Welkin> that took a while
22:06:32 <Welkin> but it works
22:07:01 <Welkin> I tend to have only a few small victories each night with yesod lately
22:07:56 <Axman6> Welkin: you can't use $(value) or whatever it is?
22:08:43 <Welkin> #{value}
22:08:44 <Welkin> no
22:09:00 <Welkin> there is no instance of ToJavaScript for Text or String
22:09:22 <Welkin> ToJavascript
22:09:26 <Axman6> what are there instances for?
22:09:35 <Welkin> I don't even know
22:09:38 <Axman6> have you looked at the ToJavascript class?
22:10:37 <Welkin> Bool, Val, RawJavascript
22:10:51 <Welkin> Value (which is a JS type)
22:10:59 <Welkin> http://hackage.haskell.org/package/shakespeare-2.0.1.1/docs/Text-Julius.html
22:11:22 <JamesJRH> Hi.
22:12:42 <JamesJRH> At some point I want to write everything in Haskell or other pure-functional language.
22:13:39 <JamesJRH> But I had an idea for a web browser. Not really sure if that would be remotely acheivable in Haskell.
22:15:08 <JamesJRH> How challenging would it be to write a TUI web browser in Haskell?
22:17:58 <DanC_> TUI?
22:18:06 <DanC_> tonight's code: https://github.com/dckc/facct
22:18:15 <unfoldable> depends; who gets to decide what TUI means?
22:18:28 <JamesJRH> TUI = text user interface
22:18:28 <Welkin> well, it is still broken
22:19:19 <JamesJRH> Or what about a Haskell email client?
22:19:24 <Fuuzetsu> JamesJRH: Haskell is not a a problem here
22:19:25 <Fuuzetsu> why would it be
22:19:44 <Fuuzetsu> both are as doable as in whatever other language you might be thinking of
22:19:59 <JamesJRH> You miss my point.
22:20:31 <Welkin> ... this is horrible
22:20:42 <Welkin> a slow connection can break otherwise correct code
22:20:43 <Welkin> wow
22:20:56 <pharpend> I'm getting this error from quickcheck that I can't figure out http://ix.io/f9U
22:21:00 <merijn> JamesJRH: Once you get over the initial "oh god, haskell's ecosystem is very different from everything I'm used to!"-hump, it should be relatively easy
22:21:01 <Welkin> ajax is such a pain
22:21:04 <pharpend> or, rather, ghc error
22:22:12 <pharpend> http://lpaste.net/114226 <-- there's the test.hs
22:22:22 <Welkin> javascript makes me want to rip my hair out
22:22:51 <pharpend> lpaste is really friggin slow right now
22:23:01 <pharpend> Welkin: this is why I say away from web development
22:23:49 <Welkin> I use the smallest amount of javascript necessary, not a character more
22:24:04 <Welkin> I don't even have 100 lines
22:24:08 <Welkin> and it still breaks
22:24:47 <pharpend> JS for you
22:24:54 <pharpend> TypeScript is apparently JS with Haskell's type sysetm
22:24:55 <pharpend> system
22:25:04 <pharpend> You could also use GHCjs, I don't know if that's any good
22:25:07 <merijn> pharpend: At the point, why not use ghcjs?
22:25:26 <pharpend> it might suck
22:25:30 <merijn> pharpend: ghcjs supports all of GHC's haskell extensions, lightweight threads and STM, so...
22:26:50 <Haskellfant> I'm not yet convinced that avoiding writing js by compiling some other language to js is the right way
22:27:13 <merijn> I'm convinced that it is the right way to get interpreters for other languages into browsers
22:27:19 <merijn> Which is the first step to killing JS
22:27:27 <JamesJRH> Fuuzetsu, merijn: I want to modify my software, make it better, decide how I want my web browser to be. Or my email client. But I want to do it in Haskell. I don't want to delve into the maze of Firefox, Chromium, Thunderbird, etc. Of course it can be written in Haskell in theory, but can it be written in Haskell in practice? It seems like such a collosal task to write a web browser.
22:27:35 <luite> yeah ghcjs probably sucks, and i heard that its author is really grumpy because he's lost way too much sleep making it compatible with the upcoming ghc 7.10, so better steer clear for now ;)
22:28:00 <Haskellfant> lol
22:28:36 <Welkin> good timing
22:28:36 <merijn> luite: Also, I hear it contributes nothing useful back to the ecosystem and it's solution to making TH is completely unusable to other cross-compilation efforts!
22:28:37 <pharpend> How the hell do people use computers at night without redshift
22:28:44 <merijn> pharpend: Easily?
22:28:55 <pharpend> my eyes explod
22:28:56 <pharpend> *e
22:29:09 <Welkin> pharpend: I accept the painful eye strain and blood vessels that burst in my eyes
22:29:11 <merijn> JamesJRH: It *is* a collosal task to write a web browser
22:29:27 <Welkin> the web is a mess
22:29:27 <pharpend> merijn: which is why all web browsers suck
22:29:29 * merijn just uses a dark terminal background and brightness control...
22:29:49 <luite> merijn: not in 7.10 anyway... at least no one else seems to have stepped up to continue the work :/ and i only just got the test suite passing on ghc 7.10 earlier today
22:30:05 <JamesJRH> merijn: How big is the entire Haskell community compared to say the Firefox development community?
22:30:07 <merijn> luite: "not yet" ;)
22:30:36 <merijn> JamesJRH: Probably signifcantly bigger, but most of them probably don't care about writing web browsers :p
22:30:37 <JamesJRH> Welkin: Heh, I totally agree!
22:30:54 <pharpend> I use the solarized themes
22:30:56 <pharpend> they are ugly as hell
22:31:01 <Welkin> solarized is great
22:31:03 <pharpend> but boy do they help with eye strain
22:31:07 <Welkin> I use it everywhere
22:31:47 <JamesJRH> merijn: Well at least it's good that it's bigger. :-)
22:31:47 <Welkin> white webpages burn my eyes
22:31:50 <pharpend> yeah
22:31:57 <Welkin> unfortunately, that is what I have to look at most of the time
22:31:57 <pharpend> Welkin: redshift will help with that
22:32:25 <pharpend> anyway, anywone know hwo to deal with my issue?
22:33:30 <JamesJRH> Welkin: It is actually the mess of the Web that makes me want a better browser. I want a different browser, one that has a totally different mentality to that of Mozilla and Google altogether.
22:33:43 <pharpend> Chrome is the least shitty browser
22:33:51 <pharpend> JamesJRH: dwb is okay, but it crashes like crazy
22:33:57 <pharpend> JamesJRH: but you should definitely take a look
22:34:02 <JamesJRH> Chrome is nonfree.
22:34:04 <luite> <- sleep, or i'll actually get grumpy, and you wouldn't like me when i'm grumpy
22:34:09 <pharpend> Chromium
22:34:25 <pharpend> luite: I don't know of anyone who is likeable when grumpy
22:34:43 <JamesJRH> But could I like augment dwb with Haskell code?
22:34:51 <pharpend> idk
22:35:06 <pharpend> I know you can with python and perl
22:35:09 <Welkin> how can half of a javascript function execute ad then fail halfway through??
22:35:19 <Welkin> and the side effects still remain
22:35:20 <pharpend> Welkin: by not being haskell
22:35:27 <luite> pharpend: why would i care about who you know! ;)
22:36:06 <pharpend> I have a persistent problem with my cat, whenever I start to work at my desk, she comes and sits on my arms, preventing me from working
22:36:11 <pharpend> then she gets pissy if I try to type
22:36:23 <pharpend> I've found a novel solution - put a basket next to the keyboard
22:36:28 <pharpend> the cat will never bother you again
22:36:34 <Welkin> ...I may have to implement a "wait" animation to show the user that the audio file is loading
22:36:44 <Welkin> otherwise, when they click the buttons the entire page gets fucked up
22:37:09 <pharpend> Welkin: I initially read that as a "Walt" animation, and was thinking you would have a breaking bad reference
22:37:19 <pharpend> you might get into some trouble with the copyright police, though
22:37:30 <Welkin> I may have a bigger problem
22:37:43 <Welkin> when I read "persistent" in your message above, I thought of the haskell database ORM
22:37:52 <pharpend> eh
22:37:54 <JamesJRH> pharpend: Pissy? Urgh, wet arms.
22:37:54 <pharpend> yeah
22:37:59 <pharpend> haha
22:38:18 <pharpend> no, cat screaming at you and scratching you can be annoying though
22:39:32 <Welkin> why is it so slow to seek a file hosted remotely?
22:39:37 <Welkin> is it partially downloaded?
22:39:45 <Welkin> or does it download to a tmp directory?
22:40:51 <Axman6> persistent isn't an OTM btw
22:41:48 <JamesJRH> pharpend: I've heard of dwb before but I can't find the WP page for it now.
22:42:04 <pharpend> wp?
22:42:17 <JamesJRH> Wikipedia
22:42:22 <pharpend> ah
22:42:23 <JamesJRH> article*
22:42:28 <Welkin> the guy that robbed a 727?
22:42:44 <Welkin> oh
22:42:48 <Welkin> that is DB Cooper
22:44:53 <pharpend> no
22:44:55 <pharpend> yeah
22:45:09 <pharpend> It turns out that when you have 900 unit tests, even in Haskell, that takes a while
22:45:12 <Welkin> well, something that was *not* a problem when I tested my application with local files is now a problem because of the latency of the web
22:50:19 <zipper> I've been writing haskell that works. I however have a good feeling that it's the ugliest haskell code ever written and in the worst style. How do I fix this?
22:50:54 <MP2E> hlint often makes good stylistic suggestions
22:51:10 <MP2E> also you can lpaste it and post here if you want general advise
22:52:55 <adas> is there a library to make HTTP requests in haskell? something like the "requests" library in python?
22:53:41 <merijn> http-conduit, wreq or one of 1500 others?
22:53:57 <merijn> zipper: refactor, refactor and then refactor some more
22:54:12 <adas> sory.
22:54:34 <adas> i thought about network.HTTP. glad i asked
22:54:45 <merijn> zipper: My first attempts tend to be hundreds of monstrous lines of ugly horrors. Then I start aggressively simplifying, splitting of into local helper functions/where clauses, etc.
22:55:07 <merijn> zipper: After the 2nd or 3rd cleanup it tends to have evaporated and mostly leave clean code
22:55:55 <zipper> merijn: Wow thanks
22:56:09 <zipper> merijn: I assumed people just write awesome code at the first attempt.
22:56:23 <dfeuer_> zipper, also, as you work with the code, you will often notice structure in it that you didn't see before.
22:56:32 <zipper> hmmm yeah because at the first attempt you think you understand the matter at hand but you really don't
22:56:41 <zipper> dfeuer_: I see
22:56:44 <dfeuer_> You may even set out to write code that does things one way, and discover later that you've actually done something else.
22:57:05 <dfeuer_> And you may have left behind all sorts of ugly traces of what you *thought* you wanted to do.
22:57:15 <merijn> zipper: Mostly it ends up looking really clean because haskell is pretty easy to refactor
22:57:33 <merijn> zipper: No side-effects or implicit state to worry, so simple rewriting "just works"
22:57:45 <dfeuer_> Except the code in the guts of the compiler, which is completely unreadable except to gurus who think it's extremely clear.
22:58:30 <zipper> dfeuer_: Ha I know that. A lot of useless functions.
22:59:59 <zipper> dfeuer_: That seemed super useful at the time
23:00:06 <zipper> merijn: dfeuer_ Thanks
23:00:25 <dfeuer_> zipper, I ran into a function in GHC's CSE system (as I recall) that was a huge recursive mess called merge...something. When I dug through it trying to figure out what it was about, I realized it was just a completely hand-written zipWith form.
23:00:46 <dfeuer_> Probably because someone didn't realize that it was going to end up having that structure, and then didn't realize that it had ended up with that structure.
23:01:19 <zipper> CSE meaning?
23:01:28 <zipper> lol
23:02:02 <dfeuer_> Common subexpression elimination.
23:02:35 <zipper> hahaha
23:02:37 <dfeuer_> The compiler makes a lot of messes and then tries to clean them up by merging together copies it's made of things.
23:02:55 <trap_exit> first world problem: what's the best tool fof reading haskell code on an surface 3 pro?
23:03:02 <zipper> Ok I don't get everything you're saying but I do get the general point.
23:03:18 <zipper> trap_exit: Stop making us Kenyans feel bad.
23:03:47 <zipper> btw does anyone know if there are haskell programming jobs in Germany? and does one require to know German to move there?
23:03:52 <trap_exit> alright; what's the best tool for reading haskell code on a OLPC ?
23:04:02 <trap_exit> zipper: yes, no
23:04:06 <dfeuer_> zipper, you should ask nomeata or someone else who lives there.
23:04:15 <zipper> trap_exit: You're German?
23:04:25 <trap_exit> zipper: from kenya to german, it'll be a nice jump in quality of life
23:04:25 <dfeuer_> trap_exit, you keep naming things that I don't know anything about.
23:04:41 <zipper> trap_exit: Tell me about it. Would be a dream come true.
23:04:43 <trap_exit> olpc = one laptop for child, a $100 laptop from MIT a few years ago
23:04:47 <zipper> trap_exit: I'm still in school
23:04:50 <Fuuzetsu> per child*
23:04:54 <trap_exit> zipper: you can turn a knob, and you get fresh water
23:05:07 <dfeuer_> Isn't Kenya a relatively sane sort of place, unlike, say, Nigeria?
23:05:08 <trap_exit> zipper: you get so much of it, people use it to wash themselves in the morning
23:05:19 <zipper> trap_exit: We have taps here haha notice I'm on irc and writing haskell. The media lies.
23:05:29 <trap_exit> zipper: you also get stable electricity
23:05:29 <zipper> Also aid companies want you to donate.
23:05:39 <trap_exit> zipper: oh, ar eyou really from kenya? I thought you were joking / playing a role
23:05:46 <zipper> The places lacking are mainly health and infrastructure
23:06:05 <trap_exit> where is kenya? are you on the same continent as the ebola outbreak ?
23:06:13 <zipper> trap_exit: No I am not joking. I am being very serious. I'd love to move for obvious reasons.
23:06:18 <dfeuer_> trap_exit, (most) continents are big.
23:06:44 <zipper> trap_exit: Yes same continent but with a functioning health system so ebola got to America and didn't get here.
23:06:46 <trap_exit> zipper: apologies of my jokes were offensive; I thought we were kidding around; I'm sure there are parts of kenya that are very nice :-)
23:06:52 <trap_exit> zipper: ouch
23:07:28 <zipper> trap_exit: lol sorry. WHat did I do?
23:07:40 <pharpend> Ebola got to Kenya, it was just contained & eradicated
23:07:45 <pharpend> same as in america
23:07:51 <zipper> pharpend: lol who said so?
23:08:10 <pharpend> You literally just said ebola didn't get to Kenya
23:08:13 <Rufflewind> Does anyone know what the status is of this project? https://ghc.haskell.org/trac/ghc/wiki/Commentary/GSoCMultipleInstances
23:08:21 <glguy> The quality of healthcare in the countries of the world certainly isn't on topic here
23:08:29 <zipper> pharpend: Yes not a single case.
23:08:52 <trap_exit> guys we should listen to glguy, he's an op :-)
23:08:56 <pharpend> Oh yeah, you are right. I was thinking nigeria. but, glguy is right, this is off-topic
23:08:57 <trap_exit> he's also very helpful with haskell questions
23:09:08 <glguy> You should listen to anyone who tries to keep the channel on topic :)
23:09:33 <trap_exit> yeah, but particularly those with the power to kick ban :-)
23:09:41 <zipper> last offtopic thing: haskell nairobi would be nice. If any other Kenyans join the channel let me know if you can.
23:09:44 * zipper is done
23:10:03 <dfeuer_> *That* was pretty close to on-topic.
23:10:10 <trap_exit> glguy: I'm trying to figure out wher e I know you from
23:10:22 <trap_exit> I think it was you helping me with GHC.Generics for something
23:10:49 <zipper> trap_exit: The Generics in aeson?
23:10:56 <glguy> You probably know me from #haskell. Yes, I sent some generics code your way at one point ^_^
23:11:07 <trap_exit> no, as in (deriving GFenerics) then getting lots of things for free
23:11:25 <zipper> I've been through hell with JSON and Data.Aeson lately but I fixed it. I was just without knowledge.
23:11:57 <zipper> trap_exit: Uh okay
23:12:33 * hackagebot sws 0.1.0.1 - A simple web server for serving directories, similar to weborf.  http://hackage.haskell.org/package/sws-0.1.0.1 (DerekElkins)
23:14:55 <bitemyapp> is there anyone here that uses Nix with Haskell builds that could help me?
23:15:01 <bitemyapp> the #nixos channel is quiet.
23:15:10 <solatis> bitemyapp: a lot
23:15:17 <trap_exit> we should help bitemyapp, he's helpmed me in the past too
23:15:31 <solatis> me included, but Fuuzetsu is the Nix god in this channel
23:15:31 <trap_exit> though I think from #erlang; either way we should help him
23:15:35 <bitemyapp> I'm building haskell-awk, getting "stringsearch-0.3.6.5-42e4e358ee1e7c1b181789539187bcf7" doesn't exist   on nix-build
23:15:40 <trap_exit> what issue are you running into?
23:15:56 <bitemyapp> it's suggesting that I could force it, but I don't understand the implications of doing so.
23:15:58 <trap_exit> is this with cabal or with nix ?
23:16:07 <trap_exit> I'm assuming nix given the package name
23:16:16 <bitemyapp> nix-build
23:16:22 <trap_exit> with nix, can't you just rollback if you forced it and bad things happened?
23:16:22 <solatis> bitemyapp: is that a custom build you're running, or just a package?
23:16:39 <bitemyapp> custom build, but using jwiegley's scripts.
23:16:43 <bitemyapp> I'll paste the expression
23:16:54 <solatis> ok
23:17:15 <solatis> what channel you're running? nixos-stable or nixos-unstable?
23:17:16 <bitemyapp> lpaste needs Nix support :)
23:18:00 <bitemyapp> http://lpaste.net/114229
23:18:10 <bitemyapp> scripts here: https://github.com/jwiegley/nix-config
23:18:22 <bitemyapp> nix-cabal-build generated the default.nix
23:18:28 <bitemyapp> solatis: unstable AFAIK
23:18:38 <bitemyapp> yeah, unstable.
23:18:46 <bitemyapp> nixpkgs http://nixos.org/channels/nixpkgs-unstable
23:18:50 <bitemyapp> but nixpkgs, not NixOS.
23:19:39 <solatis> ah right
23:19:45 <solatis> shouldn't make a difference
23:19:49 <bitemyapp> so uh...what's going on?
23:20:00 <zipper> bitemyapp: Reading http://nixos.org/ and wow.
23:20:03 <bitemyapp> I mean, I get that the package name + version + hash doesn't exist, but I don't know why that would be the case
23:20:08 <bitemyapp> why it's my problem
23:20:13 <bitemyapp> if I should force it, what'll happen if I force it
23:20:17 <bitemyapp> whatever "force" means
23:20:28 <bitemyapp> weirder still, it seems to have built one of the other executables fine.
23:20:36 <bitemyapp> so I don't really know what's going on.
23:20:41 <bitemyapp> well that's a given anyway.
23:20:46 <solatis> bitemyapp: hold on, i'm trying to reproduce your problem
23:20:49 <bitemyapp> Sure.
23:20:53 <solatis> and eating a hamburger at the same time
23:20:55 <bitemyapp> nixpkgs http://nixos.org/channels/nixpkgs-unstable
23:20:58 <solatis> priorities...
23:20:58 <bitemyapp> woops
23:21:00 <bitemyapp> https://github.com/gelisam/hawk
23:21:06 <bitemyapp> I'm using HEAD of that.
23:21:12 <bitemyapp> maybe I shouldn't use HEAD of that?
23:21:19 <bitemyapp> let me unpack latest on hackage and try that.
23:21:48 <bitemyapp> hrm. fascinating new error instead.
23:22:42 <solatis> i'm entering a new-shell now with your expression
23:22:44 <solatis> downloading lots of packages
23:22:47 <solatis> this can take a while
23:23:30 <solatis> (especially since i'm on a 384kbit connection...)
23:23:33 <bitemyapp> solatis: understood.
23:24:03 <bitemyapp> thank you for helping me out :)
23:24:15 <bitemyapp> yeah it builds hawk but fails on something else. hrm.
23:24:16 <solatis> i'm only a nix noob too
23:24:39 <solatis> the error to me sounds like it cannot build stringsearch, and then hawk fails on that dependency
23:24:58 * bitemyapp steeples fingers
23:25:03 <bitemyapp> ...hrm...yes.
23:25:19 <solatis> ah
23:25:19 <solatis> well
23:25:22 <solatis> i can enter the shell
23:25:30 <solatis> now lets see if i can build the actual package
23:25:39 <bitemyapp> I'm able to enter the shell, but how do you plan to build the package?
23:25:46 <bitemyapp> cabal2nix + nix-build?
23:26:13 <solatis> where's the source?
23:26:23 <bitemyapp> source to what?
23:26:34 <bitemyapp> the expression johnw's script generated?
23:26:37 <bitemyapp> I linked his scripts
23:26:52 <solatis> hmm no rather the actual haskell code for haskell-awk
23:27:15 <bitemyapp> it's in src in my copy of the repo.
23:27:33 <solatis> src = builtins.filterSource (path: type: type != "unknown") ./.;
23:27:51 <solatis> which implies src = ./.;
23:28:07 <solatis> so i need actual code to try to build this
23:28:33 <bitemyapp> solatis: https://github.com/gelisam/hawk ?
23:28:52 <solatis> right, that
23:30:59 <solatis> well, it's compiling
23:31:17 <bitemyapp> maybe I should just installing stringsearch
23:31:19 <bitemyapp> see what happens
23:32:35 <solatis> ah
23:32:38 <solatis> reproduced
23:33:00 <bitemyapp> when I went to install stringsearch
23:33:02 <bitemyapp> it had it cached
23:33:05 <solatis> "stringsearch-0.3.6.5-42e4e358ee1e7c1b181789539187bcf7" doesn't exist
23:33:06 <bitemyapp> and it just added 400 something symlinks
23:33:16 <bitemyapp> so how does one fix that?
23:33:19 <bitemyapp> and what does "force" mean?
23:33:44 <bitemyapp> solatis: it has occurred to me that it doesn't fail on the build, it fails on the test run.
23:33:52 <solatis> yes
23:33:54 <bitemyapp> yeah. hawk built.
23:33:55 <bitemyapp> I can use it.
23:33:57 <bitemyapp> bugger all.
23:34:11 <bitemyapp> w/e I want to understand this.
23:34:17 <solatis> the easy solution: doCheck = false; in your nixexpr
23:34:30 <solatis> yeah i'm looking further
23:34:54 <bitemyapp> what does that make it not check?
23:35:32 <solatis> perform the tests
23:35:47 <bitemyapp> oh
23:35:51 <solatis> https://nixos.org/wiki/Haskell#Package_expressions
23:36:01 <bitemyapp> thank you
23:36:04 <solatis> especially 'jailbreak' and 'doCheck' can come in handy sometimes
23:36:20 <solatis> i'm rebuilding now with jailbreak = true;
23:36:28 <solatis> to see if it's a version issue
23:36:45 <bitemyapp> the hawk copy I had in my .cabal might not've come from Nix
23:36:54 <bitemyapp> so I'm re-running build and checking path
23:37:01 <bitemyapp> yeah uh
23:37:09 <bitemyapp> solatis: how do I get Nix to add what it just built to my path?
23:38:12 <solatis> nix-env -i
23:38:35 <bitemyapp> solatis: that uh
23:38:41 <bitemyapp> solatis: tried to install everything on the planet and then broke
23:38:42 <solatis> and you use -f to specify your nixexpr
23:38:45 <Welkin> @hoogle encodeutf8
23:38:46 <bitemyapp> ...
23:38:47 <bitemyapp> yes
23:38:47 <lambdabot> Data.Text.Lazy.Encoding encodeUtf8 :: Text -> ByteString
23:38:47 <lambdabot> Data.Text.Encoding encodeUtf8 :: Text -> ByteString
23:38:50 <Welkin> I really need local hoogle...
23:39:07 <solatis> Welkin: or emacs ;)
23:39:07 <Welkin> @hoogle pack
23:39:07 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
23:39:07 <lambdabot> Data.Text.Lazy pack :: String -> Text
23:39:07 <lambdabot> Data.Text pack :: String -> Text
23:39:13 <Welkin> I use emacs
23:39:22 <solatis> then why aren't you using the hoogle emacs integration
23:39:22 <Welkin> haskell-doc only works for prelude
23:40:10 <Welkin> is it a package?
23:40:16 <Welkin> on melpa/marmalade?
23:40:39 <solatis> https://www.haskell.org/haskellwiki/Hoogle#Emacs_Integration
23:40:44 <bitemyapp> [callen@cumae ~/work/hawk]$ which hawk
23:40:44 <bitemyapp> /home/callen/.nix-profile/bin/hawk
23:40:47 * bitemyapp beams
23:40:50 <bitemyapp> solatis: thank you!
23:40:56 <bitemyapp> now I can finally go to bed!
23:41:02 <solatis> bitemyapp: doCheck = false; worked?
23:41:11 <bitemyapp> solatis: doCheck = false; worked, did jailbreak work?
23:41:17 <bitemyapp> for making the tests pass.
23:41:17 <solatis> jailbreak didn't :)
23:41:19 <bitemyapp> nuts.
23:41:23 <bitemyapp> that's no good.
23:41:37 <solatis> don't feel bad
23:41:50 <solatis> https://github.com/NixOS/nixpkgs/search?utf8=%E2%9C%93&q=doCheck+%3D+false%3B
23:41:51 <bitemyapp> doing a vanilla sandboxed cabal build to see if I can get the tests to pass outside of the nix-verse.
23:42:01 <bitemyapp> solatis: egads.
23:42:12 <solatis> 292 packages in the nix rep have doCheck = false; ;)
23:44:30 <ReinH> lulz nix amirite
23:44:50 <solatis> well sometimes it's not nix' fault
23:45:03 <solatis> sometimes package maintainers ship with broken tests
23:45:24 <solatis> golang for example fails some edge cases
23:45:33 <solatis> so 'make test' fails
23:46:15 <solatis> (i believe it's because golang makes some assumptions about timezones)
23:46:45 <bitemyapp> solatis: test-cases fail for entirely different reasons.
23:46:58 <bitemyapp> it's possible it's something weird with my nix-ified GHC install tho.
23:47:04 <bitemyapp> Could not find module ‘Network’
23:47:10 <bitemyapp> sigh.
23:47:12 <solatis> no, because it fails on my machine too
23:48:36 <ReinH> solatis: time zones are the worst thing ever
23:49:27 <kadoban> Time in general is a pain in the ass when you get down to any details.
23:49:49 <solatis> ReinH: i keep having to explain time and timezones to people
23:50:01 <solatis> people, especially programmers, just don't understand it
23:50:53 <bitemyapp> solatis: time zones are a political construct of the bourgeois
23:51:01 <bitemyapp> and should be resisted at every opportunity
23:51:10 <solatis> mwah
23:51:12 <nshepperd> the worst thing about time is people getting clocks mixed up with calendars
23:51:37 <solatis> if you consider timezones to be a view of the actual time, it becomes a lot easier to understand
23:52:33 <nshepperd> these days, the only timekeeping you should need is an atomic clock, and a chart saying when the sun rises
23:52:57 <solatis> so when you need to, say, display a time in CET, it's very similar to say, transcoding an image
23:53:16 <solatis> anyway, /offtopic
23:53:34 <voutasaurus_> The Problem with Time & Timezones - Computerphile: http://youtu.be/-5wpm-gesOY
23:54:10 <voutasaurus_> a pretty good summary of why you should get somebody else should worry about time
23:54:32 <Welkin> I am so damn lazy
23:54:40 <Welkin> I love that the compiler does most of the work for me
23:55:12 <bergmark> this is a nice/terrifying video about DST https://www.youtube.com/watch?v=84aWtseb2-4
23:55:14 <solatis> just like you use a library to handle your image transcoding and are not going to write your own image transcoding library, you shouldn't roll out your own time handling library
23:55:42 <Welkin> people from outside the community may believe that people using haskell have something to prove, but the reason is that we are just lazy
23:55:46 <solatis> DST is incredibly easy, once you realise that DST is nothing more than a *view* of the actual time
23:55:51 <solatis> the time doesn't change with DST
23:55:57 <solatis> the representation to the end-user changes
23:56:07 <bitemyapp> this is basically the trick
23:56:09 <solatis> and your code should not rely on such repreentations
23:56:17 <bitemyapp> you just track everything in epoch time (UTC)
23:56:25 <bitemyapp> and project outward into specific TZs/etc.
23:56:30 * solatis slaps bitemyapp around
23:56:33 <solatis> UTC != epoch
23:56:48 <solatis> UTC is a representation, just like GMT is
23:57:28 <solatis> but agreed, you should 'transcode' everything from one internal base format
23:57:33 <Welkin> house your own cesium atom and run measurements on it to calculate the time
23:58:06 <ReinH> still though, DST is terrible
23:58:08 <bitemyapp> goodnight all
23:58:12 <bitemyapp> solatis: thanks for the help :)
23:58:33 <solatis> Welkin: that's like the apotheosis of the NIH syndrome
23:58:57 <Welkin> bitemyapp: may you dream of monads
23:59:19 <bitemyapp> Welkin: comonadic convolution pls
23:59:22 <solatis> i think he will dream about nix expressions, tho
23:59:36 <MP2E> may your dreams be evaluated lazily
