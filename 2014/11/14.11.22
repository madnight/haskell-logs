00:24:05 * hackagebot traverse-with-class 0.2.0.3 - Generic applicative traversals  http://hackage.haskell.org/package/traverse-with-class-0.2.0.3 (RomanCheplyaka)
00:49:05 * hackagebot elerea 2.8.0 - A minimalistic FRP library  http://hackage.haskell.org/package/elerea-2.8.0 (GergelyPatai)
01:04:06 * hackagebot packunused 0.1.1.3 - Tool for detecting redundant Cabal package dependencies  http://hackage.haskell.org/package/packunused-0.1.1.3 (HerbertValerioRiedel)
01:09:06 * hackagebot freetype-simple 0.1.0.0 - Single line text rendering for OpenGL ES  http://hackage.haskell.org/package/freetype-simple-0.1.0.0 (capsjac)
01:10:38 <kqr> if I want to make a simple program that draws a few characters on screen in a small window and lets you type into it, is it recommended to write directly against X11 or is there a better library for that kind of thing?
01:14:06 * hackagebot Sonnex 0.1.0.2 - Sonnex is an alternative to Soundex for french language  http://hackage.haskell.org/package/Sonnex-0.1.0.2 (zigazou)
01:17:25 <kqr> one requirement is that it should be *really* fast
01:17:41 <kqr> i'm planning to write this because the thing I currently use takes too many milliseconds to start :>
02:03:19 <spacekitteh> is it possible to have type operator variables like "~>" or something similar?
02:03:41 <Zol_> Hi! How can I turn [1,2,3,4] -> "1,2,3,4" ? I was looking at Hoogle but didn't find anything good for [a] -> String
02:04:04 <spacekitteh> Zol_: show
02:04:40 <Zol_> spacekitteh: Nah, that will give me "[1,2,3,4]", sorry, I actually want "1, 2, 3, 4"
02:05:24 <spacekitteh> Zol_: map (show x ++ ", ") [1,2,3,4]
02:05:41 <spacekitteh> hmm but that'd leave the end one with 4,
02:05:41 <Zol_> spacekitteh: Ooh, cool - I didn't realize I could do that. Thanks!
02:05:50 <spacekitteh> Zol_: look up pretty printing libraries
02:05:55 <Zol_> spacekitteh: Thanks
02:06:06 <alpounet> > intercalate ", " . map show $ [1, 2, 3, 4]
02:06:09 <lambdabot>  "1, 2, 3, 4"
02:06:14 <spacekitteh> heh, or that
02:06:25 <Zol_> <3 ! alpounet, spacekitteh
02:06:40 <alpounet> Zol_: intercalate comes from Data.List.
02:07:45 <spacekitteh> if you're using a big list though, try using Data.List.Stream for an optimised implementation
02:08:04 <spacekitteh> which comes from the package stream-fusion
02:09:21 <Zol_> Thanks again
02:20:26 <adas> if "op" is  a binary fucntion .. is there a way to do '3 op 4'?
02:21:35 <bitonic> adas: 3 `op` 4
02:21:47 <adas> bitonic: without the backticks?
02:21:51 <kqr> with backticks
02:22:02 <kqr> backticks turn functions into operators
02:22:04 <adas> i tried defining a function with infixl.. didn't work
02:22:14 <kqr> you can only define operators with infixl
02:22:27 <adas> ah okay
02:22:36 <adas> no wonder it was not working
02:22:38 <kqr> (where "operators" means functions whose names consist only of symbols)
02:23:59 <adas> cool. thanks for the clarification
02:24:16 <chrisdone> you can define fixity for `backtick` functions, but who'd want to
02:28:49 <benmachine> chrisdone: it's done for `seq`
02:29:05 <benmachine> so, someone :P doesn't necessarily mean it's a good idea, admittedly
02:31:17 <dmwit> adas: infixl doesn't define things, it only gives their precedence.
02:31:33 <dmwit> You can give the precedence for any identifier, whether it's spelled with symbols or not.
02:31:45 <dmwit> And it will apply when that identifier is used infix.
02:35:12 <dmwit> > let infixl 5 `f`; f = (*) in 2 + 3 `f` 4
02:35:13 <lambdabot>  20
02:35:23 <dmwit> > let infixl 7 `f`; f = (*) in 2 + 3 `f` 4
02:35:24 <lambdabot>  14
02:54:37 <sivteck> > "test"
02:54:38 <lambdabot>  "test"
03:00:04 <spacekitteh> is there a sort for a fully saturated type application?
03:00:41 <spacekitteh> hvr: you seem like you'd know
03:02:20 <Haskellfant> spacekitteh: what exactly do you mean by „sort for a fully saturated type application“
03:02:53 <spacekitteh> well, every type has a kind, and every kind has a sort
03:03:26 <spacekitteh> and arbitrary type variables can be either partially applied or fully saturated
03:03:34 <spacekitteh> but everything seems to live in the sort BOX
03:03:54 <spacekitteh> so i can't figure out how to specify that a type variable is fully applied
03:04:08 <bitonic> spacekitteh: their kind
03:04:28 <bitonic> if they're an arrow kind they can be applied
03:04:34 <bitonic> just like normal functions
03:05:19 <spacekitteh> this is what ghc is inferring, bitonic: class SmallCategory (catKind :: BOX) (cat :: catKind) where ...
03:05:42 <spacekitteh> so it looks like catKind can be either an arrow kind or not
03:05:53 <spacekitteh> and i can't figure out how to say "no arrow kinds allowed please"
03:06:39 <spacekitteh> (that's with -fprint-explicit-kinds turned on so the catKind::BOX isn't actually a type variable in the class)
03:07:27 <bitonic> spacekitteh: then you shouldn't be polymorphic on the kind
03:07:32 <bitonic> I can't remember the kind subtyping thing
03:07:43 <spacekitteh> but i want to allow other kinds than *
03:07:48 <spacekitteh> but not arrow kinds
03:07:59 <bitonic> but presumably there is a kind which is a "superkind" of all the non-arrow kinds
03:08:18 <spacekitteh> thus my question: is there a sort which is fully saturated type application
03:08:33 <bitonic> spacekitteh: you're not looking for a sort here, but for a kind
03:08:43 <bitonic> and it seems to be called `OpenKind'
03:08:46 <bitonic> <https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/Kinds>
03:09:11 <bitonic> so you'd have `SmallCategory (cat :: OpenKind) where ...'.  no idea if that's valid haskell.
03:09:16 <spacekitteh> that's a weird "set-of-all-sets" type paradox
03:09:29 <bitonic> I didn't even know you could have kind signatures like that
03:09:33 <bitonic> spacekitteh: why?
03:09:59 <spacekitteh> because a universe of kinds should be a sort, not another kind
03:10:22 <bitonic> but it's not the case that `* :: OpenKind'
03:10:42 <bitonic> rather `* <= OpenKind', there is this subtyping in place
03:10:42 <spacekitteh> is it not? that's what it looks like by the diagram
03:10:53 <bitonic> no
03:10:57 <spacekitteh> oh subtyping, right
03:11:09 <bitonic> the strange bit is that we have two kinds for types -- # and *
03:11:19 <bitonic> you'd expect to have one
03:11:23 <bitonic> and then you could simply use *
03:11:41 <bitonic> but since you have those unboxed types you have # as well
03:11:53 <bitonic> but then as you noticed you want to represent non-arrow kinds
03:12:10 <bitonic> so they use this subtyping thing
03:12:16 <spacekitteh> bitonic: i don't find that strange at all tbh, considering how the handling between boxed and unboxed types is radically different in the code generator
03:12:32 <bitonic> spacekitteh: I think it should be hidden from the user
03:12:59 <bitonic> but I've never looked closely at these issues, I'm just saying it's annoying to think about kinds this way
03:13:17 <spacekitteh> but then it would make polymorphism MUCH more complicated
03:13:35 <spacekitteh> because yuo'd have to generate different data structures: one for boxed types, and one for each unboxed type
03:13:42 <bitonic> spacekitteh: I don't seem to be the only one who dislikes this stuff <https://ghc.haskell.org/trac/ghc/wiki/NoSubKinds>
03:14:20 <bitonic> but they're proposing to just have * :: *
03:14:33 <bitonic> then it'd be the "paradox" that you say, but who cares in Haskell really
03:14:41 <spacekitteh> i do :(
03:14:46 <bitonic> oh, and apparently `BOX :: BOX'
03:14:51 <bitonic> spacekitteh: why?
03:15:08 <bitonic> `Set : Set' is so much nicer from a user perspective, I think
03:15:12 <spacekitteh> because i like things being /correct/
03:15:15 <bitonic> the hierarchy is such a kludge
03:15:28 <bitonic> spacekitteh: I'm curious to know what you think about general recursion
03:15:32 <bitonic> is that not /correct/ :P?
03:15:41 <spacekitteh> as in non-termination?
03:15:48 <bitonic> right
03:16:03 <spacekitteh> total recursion + corecursion > general recursion tbh
03:16:45 <bitonic> I don't remember the exact terminology.  I meant, what do you think about being able to type-check `let x = x in x'
03:16:55 <bitonic> or `undefined :: a; undefined = undefined'
03:17:14 <spacekitteh> i dislike that in haskell, top = bottom
03:17:36 <bitonic> what's top?
03:18:07 <spacekitteh> a terminal object
03:18:49 <bitonic> I don't understand what you mean that in Haskell `top = bottom'
03:19:04 <bitonic> in any case, my point was that having an inconsistent hierarchy in Haskell is the least of your problems
03:19:25 <bitonic> I'm not even sure what the consequences of `* :: *' would be in Haskell
03:19:55 <spacekitteh> honestly i might just end up doing all my coding in Coq and then generating executable code from that
03:19:58 <bitonic> since Haskell's type system is very weak, I don't know if you can encode paradoxes using that
03:20:27 <bitonic> spacekitteh: sure, if you really want to prove things correct Coq is a much better tool
03:21:14 <spacekitteh> originally i started writing this library i'm working on to make haskell a semi-decent tool for science+engineering applications but just so much of it is getting in the way :\
03:21:28 <notdan> top is () in Haskell, IIRC
03:21:35 <spacekitteh> notdan: no, it's not
03:21:44 <spacekitteh> notdan: www.haskell.org/haskellwiki/Hask
03:22:05 <bitonic> spacekitteh: in my experience programmers in "science and engineering" don't really like to work with sophisticated type systems that let them have machine checked proofs of their code :P
03:22:12 <alpounet> spacekitteh: hmm? what's your library about?
03:22:20 <bitonic> spacekitteh: people usually call () top
03:22:21 <bitonic> or unit
03:22:40 <notdan> spacekitteh: well it is almost a terminal object
03:22:51 <spacekitteh> bitonic: i'm an avionics engineer and various other sorts of engineers are like me as well e.g. nuclear engineers
03:23:19 <spacekitteh> alpounet: category theory based numerics, differential equations, state machines, etc
03:23:41 <alpounet> link?
03:23:56 <bitonic> spacekitteh: I'm not saying you don't care.  I'm saying that that doesn't seem to be a big concern in a lot of the science and engineering programming I see
03:24:26 <spacekitteh> at the moment it's only about 100 lines of code 'cus i keep rewriting it to make it more principled and coming across limitations in ghc lol
03:24:48 <spacekitteh> i am trying to keep it as typesafe as possible
03:25:15 <bitonic> well, good luck ehe
03:25:21 <spacekitteh> ty :V
03:25:40 <spacekitteh> but yeah
03:25:57 <spacekitteh> is there a way to specify a non-arrow-kind
03:26:08 <notdan> DataKinds?
03:26:14 <latk> I'm working on a relativley large project, and operating in a tdd style. I'm finding using cabal test is very slow due to compilation now - could any one point me to some guides to speed this up ?
03:26:30 <spacekitteh> notdan: ?
03:26:37 <latk> (This is my first largeish haskell project)
03:26:57 <notdan> Would something like this work, spacekitteh https://downloads.haskell.org/~ghc/7.8.1/docs/html/users_guide/promotion.html ?
03:27:01 <alpounet> latk: cabal configure --enable-tests && cabal build && dist/build/your-test-suite-bin/your-test-suite-bin
03:27:06 <alpounet> ?
03:27:06 <bitonic> spacekitteh: I told you, you want the supertype of * and #
03:27:32 <latk> alpounet: Is this faster than just using test-suite and cabal test?
03:27:36 <latk> If so, why? :P
03:27:49 <spacekitteh> bitonic: but i want other kinds than * and #
03:28:22 <bitonic> spacekitteh: like what?
03:28:32 <alpounet> latk: i think cabal test checks if it needs to reconfigure and what not. i'm pretty sure that this line does the minimal amount of work. also, you only need the configure command once. after that, just use the 2 others
03:28:57 <latk> alpounet: Ok, cool. I'll try it now
03:29:05 <spacekitteh> bitonic: e.g. types that are defined in a kind created by datakinds
03:29:52 <bitonic> spacekitteh: oh god, right.  I'm pretending I'm in Agda but we're not.  then I don't know
03:30:05 <spacekitteh> :(
03:30:12 <bitonic> I'd *imagine* that there should be a supertype of all non-arrow kinds
03:30:19 <alpounet> latk: and even faster feedback loop would be to load your test suite in ghci, and just do :r then call your test suite's main function from there
03:31:13 <alpounet> (do :r once you've modified your library's or test-suite's code, obviously)
03:31:49 <latk> alpounet: You are quite right, this is incredibly fast!
03:32:06 <latk> many thanks :)
03:32:22 <alpounet> happy hacking!
03:33:13 <bitonic> spacekitteh: oh, I fould this <http://www.cis.upenn.edu/~eir/papers/2013/fckinds/fckinds.pdf>
03:33:19 <bitonic> probably interesting for you
03:34:06 <alpounet> spacekitteh: i'd still be interested in seeing you approach, in case the code is somewhere public
03:34:11 * hackagebot cgrep 6.4.8 - Command line tool  http://hackage.haskell.org/package/cgrep-6.4.8 (NicolaBonelli)
03:35:11 <spacekitteh> alpounet: basically it's going to be an encoding of synthetic differential geometry into haskell
03:36:28 <alpounet> so... no public code yet? :(
03:37:00 <spacekitteh> with granular category types such as monoidal/rigid/autonomous/dagger/closed/compact/cartesian/cocartesian/bicartesian and then on top of that building scalars out of endomorphisms of identity objects from noncommutative monoidal categories and then rings and then modules and then etc
03:37:07 <spacekitteh> alpounet: there's not much to show tbh
03:37:19 <spacekitteh> i'm having trouble finding a good category encoding
03:38:22 <spacekitteh> i originally built it on the plain old Control.Category.Category class but that wasn't good because there were no object constraints etc
03:39:21 <bitonic> doing this stuff with Haskell (at least today) doesn't seem too appropriate.  you might want to look into Agda/Coq, yes
03:39:57 <alpounet> not if you actually want to run complex/heavy computations =)
03:39:57 <bitonic> then again, if you want your library to be practical and not to just study those structures, I don't know if that's possible in any system :P
03:40:12 <bitonic> alpounet: right
03:40:16 <spacekitteh> exactly
03:40:16 <alpounet> (which may be implied by the engineering aspect mentionned above)
03:40:36 <spacekitteh> i'm certainly pushing the boundaries of ghc
03:40:49 <alpounet> spacekitteh: yeah but if there's a repo, i could follow it. i'm interested in the various approaches people come up with to encode anything i've studied during my math curriculum =)
03:41:23 <spacekitteh> oh ok. well www.github.com/spacekitteh/catcon
03:42:01 <spacekitteh> new repo after i ragequit and purged the repo from github lol
03:44:03 <alpounet> spacekitteh: btw i suppose you've seen ekmett/hask
03:44:07 <spacekitteh> yeah
03:45:39 <spacekitteh> i've been trying to come up with a design which allows a simple newtype wrapper over the existing Category class for backwards compatabiility but fuck it
03:47:02 <latk> alpounet: Hm, so when using cabal repl tests, if I do :r it only reloads the test suite. Is there some way to also reload the underlying code that has changed /
03:47:03 <latk> ?
03:48:24 <bitonic> latk: if the tests are a simple file, you can `cabal repl' and then `:l test.hs'
03:48:38 <latk> bitonic: Sadly, they are relativley complicated :(
03:48:47 <latk> I guess I could just load the specific file I'm working on, though
03:48:49 <latk> tests wise
03:49:01 <bitonic> latk: then I'd advise you to put all the source in the same tree so that `cabal repl' pulls it all in
03:49:09 <bitonic> then `cabal test' just compiles a shim that imports whatever needs to import
03:49:33 <latk> Yeah, I'm still not sure of best practices for this stuff. I followed some example, but it was ages ago..
03:49:39 <bitonic> or, if you can, define a `.ghci' that let's you `ghci src/whatever.hs' easily
03:49:49 <bitonic> if your cabal builds are simple it's usually very easy
03:49:57 <alpounet> solirc: around?
03:50:04 <latk> I'll try the .ghci
03:50:05 <bitonic> if you have generated files, c source, and stuff like this; it's not
03:50:17 <latk> No, should be ok at this point
03:50:30 <bitonic> latk: it's usually a matter of putting `:set -isrc' or whatever in a ghci file at the top level
03:50:34 <latk> Although there is some template haskell - would this be an issue ?
03:50:40 <bitonic> latk: no, that's fine
03:50:52 <latk> bitonic: Ok, cool, thanks :)
03:51:10 <bitonic> latk: my best practice is to just have one big source tree.  it's just easier that way
03:51:33 <bitonic> (assuming that you're building an executable)
03:52:20 <bitonic> then the tests executables are all very simple files that pull in a couple of modules and do whatever they need to do
03:52:45 <bitonic> but with no module structure whatsoever in the tests
03:52:50 <latk> I currently have a lib and test executable
03:53:07 <alpounet> that's what i usually do too (lib + test + executable)
03:53:18 <latk> well, by test executable i mean the test-suite
03:53:21 <alpounet> so that you don't build things twice, and don't list all deps of the lib twice
03:53:25 <latk> Right right
03:53:34 <bitonic> yeah, that too
03:53:44 <latk> I actually have my test module structure reflecting the lib module structure at the moment
03:53:45 <bitonic> but the test and executable target should be super small
03:53:50 <bitonic> the build step for those should be trivial
03:53:57 <alpounet> latk: yeah, that works especially well with hspec. is that what you're using?
03:54:11 <latk> Actually no
03:54:24 <latk> Hunit and test-frtamework
03:54:53 <latk> Are there any significant advantages to hspec  ?
03:55:09 <alpounet> latk: a nice thing with hspec is that you don't even need to write the code that ties the test suite for each module together in one big test suite
03:55:18 <alpounet> it has a "discover" trick
03:55:30 <latk> ohh
03:55:33 <alpounet> as long as you follow the same structure of your library, in the tests dir
03:55:41 <latk> that sounds nice..
03:55:55 <latk> but is it nice enough to rewrite everything, that is the question :P
03:56:06 <alpounet> latk: hspec.github.io has nice docs, in case you want to take a look and decide for yourself :)
03:56:13 <latk> will do
03:56:42 <bitonic> I usually use `Module' and then `Module.Tests' or whatever
03:56:55 <bitonic> never used hspec though
03:57:12 <alpounet> well, i've worked with the author so maybe I'm not 100% objective =)
03:57:18 <alpounet> but it's really dead simple to use
03:57:24 <latk> heh
03:57:27 <latk> it does look nice
03:57:35 <bitonic> my point was that you don't need to split the source code to have tooling that discovers tests
03:59:52 <bitonic> right, so in the example for hspec he sets up an appropriate .ghci file <https://github.com/hspec/hspec-example/blob/master/.ghci>
04:00:09 <bitonic> latk: if doing so is as simple as it is above, that's probably the best way to go
04:00:30 <bitonic> my problem is that if you need to do some fancy linking it's messy and I gave up on ghci
04:01:11 <latk> That looks like it will work for me
04:28:55 <kqr> newtype XEvent = XEvent XEventPtr; type XEventPtr = Ptr XEvent
04:29:00 <kqr> isn't that a circular definition?
04:32:01 <Cale> kqr: Yes, but that's the standard thing to do for pointers to foreign types of data with no specific Haskell representation. Note that the type parameter to Ptr is phantom.
04:32:13 <int-e> kqr: it's not really circular, because the type argument of 'Ptr' is a phantom type; data Ptr a = GHC.Ptr.Ptr GHC.Prim.Addr#. It's an idiom for defining opaque pointer types.
04:32:45 <int-e> I'm just too slow.
04:36:07 <kqr> int-e, Cale: ah, thank you. that makes a bit more sense now :)
04:37:20 <int-e> kqr: I suppose it started out as  data XEventContents; newtype XEvent = XEvent (Ptr XEventContents), followed by the realization that XEvent itself can take the place of the phantom type for Ptr, whose only purpose is to avoid mixing pointers to X events with other pointers by accident.
04:42:14 <Xenasis> Is there any way to do list comprehensions on sets? (From Data.Set)
04:42:49 <Xenasis> It feels inefficient to have to turn my set into a list every time I want to perform a function on it
04:44:04 <kqr> Xenasis, data.set supports map, no
04:44:05 <kvanb_> Xenasis: sets do not effeciently provide append
04:44:06 <kqr> Xenasis, ?
04:44:23 <Xenasis> It does provide map
04:44:44 <kqr> it's not very efficient though
04:44:45 <Xenasis> but that doesn't help me much
04:44:48 <kqr> O(n*log n) apparently
04:44:52 <kqr> Xenasis, how does it not help you?
04:45:03 <Xenasis> I was looking into doing it with a fold but I couldn't find the right lambda
04:45:08 <trap_exit> anyone wind that having a smaller monitor increases productivity as it forces intense single tasking?
04:45:10 <kqr> what are you trying to do?
04:45:18 <trap_exit> i'm considering switching from a 27" monitor to a 11" mbp
04:45:21 <trap_exit> to see if this increases productivity
04:45:40 <Xenasis> I need to return a list which comes from a set
04:45:57 <Xenasis> the way I've been doing it so far is converting it to a list then using list comprehensions
04:46:44 <kqr> what does it mean to "return a list which comes from a set"?
04:46:45 <Xenasis> But I'm trying to optimise my program, and converting it into a list a lot may not be very good for it
04:46:56 <wei2912> Xenasis: show us your code
04:47:01 <int-e> Xenasis: You're too vague to help you.
04:47:52 <nkar> trap_exit: this is for -blah really, but anyway: it'll certainly affect your posture and probably cause pain in the shoulders, neck, etc.
04:48:14 <Xenasis> Ah, never mind then - it's for an assignment, and I'm worried that if I put my code online it'll get got by plagiarism checking
04:48:42 <Xenasis> I guess I'll just try and think of an appropriate lambda for the fold
04:48:43 <nkar> moreover, I don't think it'll increase your productivity becuase you won't be able to keep multiple buffers open at the same time.
04:48:58 <kqr> nkar, have you ever heard of workspaces/virtual desktops?
04:49:01 <int-e> Xenasis: toList isn't bad, it's a good way to iterate over a set; there are rules in place to make the list fuse.
04:49:23 <darthdeus__> hey guys, this isn't really a haskell specific question, but let's say I'm writing a lazy evaluator, where expressions can depend on other expressions and thus forcing their evaluation ... how can I easily prevent cycles?
04:49:23 <Xenasis> Yeah, but my program will do it a *lot*
04:49:26 <kqr> int-e, does ghc/data.list really do list fusion? I seem to recall it doesn't (yet, at least)
04:49:28 <darthdeus__> or more like detect cycles
04:50:16 <nkar> kqr: hi :)  sure, but switching between workspaces is annoying, at least for me.
04:50:16 <Xenasis> (and the problem we have is marked on efficiency)
04:50:36 <darthdeus__> because when I do something like    map eval (expr subexpressions) ... then i'd like to know if one of the subexpressions depends on the original expr (even transitively)
04:50:38 <int-e> kqr: toList = toAscList, and there's this rule: {-# RULES "Set.toAscList" [~1] forall s . toAscList s = build (\c n -> foldrFB c n s) #-}
04:50:51 <kqr> int-e, ah cool
04:51:13 <int-e> (I'm looking at containers-0.5.5.1 as shipped with ghc 7.8.3)
04:51:16 <darthdeus__> hm basically I guess I need to be able to detect cycles in a dependency graph
04:51:22 <kqr> nkar, I guess it's personal. I find it easier to switch between workspaces rather than navigate a giant screen
04:51:31 <darthdeus__> though I'm curious if I can do that while evaluating a particula expression, and not up front
04:51:38 <darthdeus__> or maybe I can just walk the graph when I start evaluating?
04:52:53 <nkar> kqr: definitely, I usually have ~4 buffers opened in emacs.
04:53:43 <kqr> darthdeus__, that sounds like a stackoverflow question
04:54:14 * hackagebot amazonka-autoscaling 0.0.0 - Amazon Auto Scaling SDK.  http://hackage.haskell.org/package/amazonka-autoscaling-0.0.0 (BrendanHay)
04:54:16 * hackagebot amazonka-cloudformation 0.0.0 - Amazon CloudFormation SDK.  http://hackage.haskell.org/package/amazonka-cloudformation-0.0.0 (BrendanHay)
04:54:18 * hackagebot amazonka-cloudfront 0.0.0 - Amazon CloudFront SDK.  http://hackage.haskell.org/package/amazonka-cloudfront-0.0.0 (BrendanHay)
04:54:20 * hackagebot amazonka-cloudsearch 0.0.0 - Amazon CloudSearch SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-0.0.0 (BrendanHay)
04:54:22 * hackagebot amazonka-cloudsearch-domains 0.0.0 - Amazon CloudSearch Domain SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-domains-0.0.0 (BrendanHay)
04:59:24 * hackagebot amazonka-cloudtrail 0.0.0 - Amazon CloudTrail SDK.  http://hackage.haskell.org/package/amazonka-cloudtrail-0.0.0 (BrendanHay)
04:59:26 * hackagebot amazonka-cloudwatch 0.0.0 - Amazon CloudWatch SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-0.0.0 (BrendanHay)
04:59:28 * hackagebot amazonka-cloudwatch-logs 0.0.0 - Amazon CloudWatch Logs SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-logs-0.0.0 (BrendanHay)
04:59:30 * hackagebot amazonka-codedeploy 0.0.0 - Amazon CodeDeploy SDK.  http://hackage.haskell.org/package/amazonka-codedeploy-0.0.0 (BrendanHay)
04:59:32 * hackagebot amazonka-cognito-identity 0.0.0 - Amazon Cognito Identity SDK.  http://hackage.haskell.org/package/amazonka-cognito-identity-0.0.0 (BrendanHay)
05:00:27 <quxbam``> i've written a emacs-mode, which auto profiles haskell code while editing, it highlights the most cpu and ram intensive subexpressions, writes beside toplevel functions the share on ressources and plots in the buffer the used ressources over each saving of the buffer for optimizing stuff.  is anyone interested?
05:00:41 <bitonic> darthdeus__: so you're describing the problem that "call by need" solves
05:01:01 <bitonic> also known as lazy evaluation :)
05:01:04 <darthdeus__> bitonic: yeah, i guess that what i'm implementing is basically lazy evaluation :D
05:01:36 <darthdeus__> bitonic: is this like a widely known pattern with naming conventions and stuff?
05:01:39 <bitonic> how you actually implement it in practice is that each expression is some mutable reference, that stores the thing to evaluate at the beginning, and when you do evaluate it you destructively update the reference
05:01:46 <bitonic> with the value
05:01:50 <darthdeus__> yes!
05:02:13 <darthdeus__> bitonic: how do i call the thing? i think haskell calls it thunks?
05:02:19 <bitonic> in this way all the expressions that were pointing to that reference will automatically point to the updated version
05:02:39 <quxbam```> anyone interested?
05:02:42 <bitonic> darthdeus__: thunk is the stage at which the expression is not evaluated yet
05:02:58 <bitonic> quxbam```: definitely, put that stuff on reddit!
05:03:01 <darthdeus__> quxbam```: does it work? :)
05:03:06 <quxbam```> yep
05:03:13 <quxbam```> at least for project-euler stuff
05:03:36 <quxbam```> it uses visual-prof from hackage and parses the output to put overlays in the buffer
05:03:48 <darthdeus__> bitonic: how's it called in the other stages?
05:04:16 <quxbam```> furthermore it uses GNU R to plot the stuff
05:04:34 * hackagebot amazonka-cognito-sync 0.0.0 - Amazon Cognito Sync SDK.  http://hackage.haskell.org/package/amazonka-cognito-sync-0.0.0 (BrendanHay)
05:04:36 * hackagebot amazonka-config 0.0.0 - Amazon Config SDK.  http://hackage.haskell.org/package/amazonka-config-0.0.0 (BrendanHay)
05:04:38 * hackagebot amazonka-datapipeline 0.0.0 - Amazon Data Pipeline SDK.  http://hackage.haskell.org/package/amazonka-datapipeline-0.0.0 (BrendanHay)
05:04:40 * hackagebot amazonka-directconnect 0.0.0 - Amazon Direct Connect SDK.  http://hackage.haskell.org/package/amazonka-directconnect-0.0.0 (BrendanHay)
05:04:42 * hackagebot amazonka-dynamodb 0.0.0 - Amazon DynamoDB SDK.  http://hackage.haskell.org/package/amazonka-dynamodb-0.0.0 (BrendanHay)
05:04:52 <darthdeus__> quxbam```: hmm that sounds really interesting
05:04:56 <bitonic> darthdeus__: you how is what called?
05:05:05 <bitonic> by the way, I think SICP has a chapter on lazy evaluation
05:05:14 <bitonic> if you like lisp, and if I remember correctly
05:05:16 <bitonic> where they do exactly that
05:06:04 <darthdeus__> bitonic: what i meant is to ask .. how is the "expression-to-be-evaluated-when-evaluating" called, if "thunk" is something that is "not-yet-evaluated" state :)
05:06:05 <bitonic> or some list book anyway... mhm
05:06:09 <darthdeus__> bitonic: I'll take a look
05:06:10 <darthdeus__> hmm
05:07:10 <bitonic> darthdeus__: oh, I'm not sure... I'm not too strong in terminology :P.  but I'd say that the "thunk" indicates something which is waiting to be evaluated
05:07:22 <bitonic> not sure if I have a term for the expression that is waiting to be evaluated itself
05:08:31 <kqr> does anyone have experience with X11 programming in haskell? i'd like to know how you typically do to react differently to different events. i've found one (1) tutorial, which completely disregards the whole distinguishing between events thing
05:08:53 <quxbam> have a look: https://imgur.com/5NFlGWf
05:09:18 <quxbam> i lost my connection, so if anyone wrote anything, please repeat
05:09:35 <darthdeus__> quxbam: :O I must have that
05:09:41 <quxbam> :)
05:09:45 * hackagebot amazonka-ec2 0.0.0 - Amazon Elastic Compute Cloud SDK.  http://hackage.haskell.org/package/amazonka-ec2-0.0.0 (BrendanHay)
05:09:46 * hackagebot amazonka-elasticache 0.0.0 - Amazon ElastiCache SDK.  http://hackage.haskell.org/package/amazonka-elasticache-0.0.0 (BrendanHay)
05:09:49 * hackagebot amazonka-elasticbeanstalk 0.0.0 - Amazon Elastic Beanstalk SDK.  http://hackage.haskell.org/package/amazonka-elasticbeanstalk-0.0.0 (BrendanHay)
05:09:50 <darthdeus__> can't wait to shove this in the face of all my c++ friends
05:09:51 * hackagebot amazonka-elastictranscoder 0.0.0 - Amazon Elastic Transcoder SDK.  http://hackage.haskell.org/package/amazonka-elastictranscoder-0.0.0 (BrendanHay)
05:09:53 * hackagebot amazonka-iam 0.0.0 - Amazon Identity and Access Management SDK.  http://hackage.haskell.org/package/amazonka-iam-0.0.0 (BrendanHay)
05:10:09 <quxbam> it's on https://github.com/knupfer/hs-profile
05:10:24 <bitonic> quxbam: yeah neat!  I don't know how useful it is for big projects but it looks nice
05:10:32 <darthdeus__> what are the dependencies?
05:10:44 <quxbam> visual-prof from hackage and GNU R
05:10:48 <quxbam> thats all
05:10:51 <bitonic> quxbam: you might be also interested in this <http://jaspervdj.be/posts/2014-02-25-profiteur-ghc-prof-visualiser.html>
05:10:53 <marchdown> j python
05:11:05 <bitonic> for bigger stuff I find that quite nice
05:11:06 <quxbam> and the modules must be installed with profiling enabled
05:11:12 <darthdeus__> cool :) I just reinstalled my laptop from scratch, so gonan try immediately when I got my haskell setup up :P
05:11:42 <quxbam> bitonic: thats nice
05:12:12 <quxbam> but my idea was, to show stuff constantly while developing to get an impression on what is effective etc
05:13:06 <quxbam> darthdeus__: be aware, i've written that stuff in two days, so there might be a lot issues...
05:13:22 <darthdeus__> btw guys, what is the preferred way to install haskell on OS X now? a few months ago haskell platform wasn't so good
05:13:40 <JannisLimperg> Hi everyone. Nix question: I'm using the template from http://www.cse.chalmers.se/~bernardy/nix.html for two local projects, one library and one executable. For the library, nix-shell works fine, but for the executable, it refuses to load any libraries. The problem disappears when I delete "isLibrary = false" and "isExecutable = true" from default.nix, but then of course nix-build doesn't do anything useful any more. Any idea why th
05:14:06 <darthdeus__> oh nice, haskell platfrom now has 7.8.3 :O
05:14:55 * hackagebot amazonka-importexport 0.0.0 - Amazon Import/Export SDK.  http://hackage.haskell.org/package/amazonka-importexport-0.0.0 (BrendanHay)
05:14:57 * hackagebot amazonka-kinesis 0.0.0 - Amazon Kinesis SDK.  http://hackage.haskell.org/package/amazonka-kinesis-0.0.0 (BrendanHay)
05:14:59 * hackagebot amazonka-kms 0.0.0 - Amazon Key Management Service SDK.  http://hackage.haskell.org/package/amazonka-kms-0.0.0 (BrendanHay)
05:15:01 * hackagebot amazonka-lambda 0.0.0 - Amazon Lambda SDK.  http://hackage.haskell.org/package/amazonka-lambda-0.0.0 (BrendanHay)
05:15:03 * hackagebot amazonka-opsworks 0.0.0 - Amazon OpsWorks SDK.  http://hackage.haskell.org/package/amazonka-opsworks-0.0.0 (BrendanHay)
05:20:05 * hackagebot amazonka-rds 0.0.0 - Amazon Relational Database Service SDK.  http://hackage.haskell.org/package/amazonka-rds-0.0.0 (BrendanHay)
05:20:07 * hackagebot amazonka-redshift 0.0.0 - Amazon Redshift SDK.  http://hackage.haskell.org/package/amazonka-redshift-0.0.0 (BrendanHay)
05:20:09 * hackagebot amazonka-route53 0.0.0 - Amazon Route 53 SDK.  http://hackage.haskell.org/package/amazonka-route53-0.0.0 (BrendanHay)
05:20:11 * hackagebot amazonka-route53-domains 0.0.0 - Amazon Route 53 Domains SDK.  http://hackage.haskell.org/package/amazonka-route53-domains-0.0.0 (BrendanHay)
05:20:13 * hackagebot amazonka-s3 0.0.0 - Amazon Simple Storage Service SDK.  http://hackage.haskell.org/package/amazonka-s3-0.0.0 (BrendanHay)
05:25:15 * hackagebot amazonka-sdb 0.0.0 - Amazon SimpleDB SDK.  http://hackage.haskell.org/package/amazonka-sdb-0.0.0 (BrendanHay)
05:25:17 * hackagebot amazonka-ses 0.0.0 - Amazon Simple Email Service SDK.  http://hackage.haskell.org/package/amazonka-ses-0.0.0 (BrendanHay)
05:25:19 * hackagebot amazonka-sns 0.0.0 - Amazon Simple Notification Service SDK.  http://hackage.haskell.org/package/amazonka-sns-0.0.0 (BrendanHay)
05:25:21 * hackagebot amazonka-sqs 0.0.0 - Amazon Simple Queue Service SDK.  http://hackage.haskell.org/package/amazonka-sqs-0.0.0 (BrendanHay)
05:25:23 * hackagebot amazonka-storagegateway 0.0.0 - Amazon Storage Gateway SDK.  http://hackage.haskell.org/package/amazonka-storagegateway-0.0.0 (BrendanHay)
05:29:59 <k00mi> JannisLimperg: try asking in #nixos
05:30:25 * hackagebot amazonka-sts 0.0.0 - Amazon Security Token Service SDK.  http://hackage.haskell.org/package/amazonka-sts-0.0.0 (BrendanHay)
05:30:27 * hackagebot amazonka-support 0.0.0 - Amazon Support SDK.  http://hackage.haskell.org/package/amazonka-support-0.0.0 (BrendanHay)
05:30:29 * hackagebot amazonka-swf 0.0.0 - Amazon Simple Workflow Service SDK.  http://hackage.haskell.org/package/amazonka-swf-0.0.0 (BrendanHay)
05:30:31 * hackagebot amazonka 0.0.0 - Comprehensive Amazon Web Services SDK  http://hackage.haskell.org/package/amazonka-0.0.0 (BrendanHay)
05:30:33 * hackagebot amazonka-core 0.0.0 - Core functionality, serialisation primitives, and data types for the amazonka Amazon Web Services SDKs.  http://hackage.haskell.org/package/amazonka-core-0.0.0 (BrendanHay)
05:30:55 <alpounet> @google ghc for mac os x github
05:30:56 <lambdabot> https://ghcformacosx.github.io/
05:31:00 <alpounet> darthdeus__: ^^^
05:31:22 <darthdeus__> alpounet: :O
05:32:29 <JannisLimperg> k00ml: Already done. Thanks for the suggestion. :)
05:35:25 <quxbam``> does anyone use yi? it seems that even the yi devs use emacs...
05:39:04 <marchelzo_> quxbam``: I've tried it... I think it's a really cool project but I couldn't see myself switching over to it
05:40:14 <nkar> quxbam``: looks cool, I'd like to try it soon.  thanks for sharing.  consider sending a note to the mailing list
05:41:45 <quxbam``> nkar: to which mailing list? haskell-cafe? there a quite a few
05:43:36 <nkar> yep, the cafe
05:44:00 <quxbam``> ok, i'll do that in perhaps two days, so it'll mature a bit until then
05:46:16 <JannisLimperg> nkar quxbam``: I believe there was some sort of update notice for Yi on haskell-café quite recently.
05:47:34 <quxbam``> ok, on github it seems that it's getting more traction
05:48:13 <orion> http://hackage.haskell.org/package/base-4.7.0.1/docs/Prelude.html#v:ceiling
05:48:17 <quxbam``> i'd really like to switch to yi, because i've learned quite a lot elisp with emacs and with yi, i'd become automatically proficient with haskell
05:48:18 <orion> "ceiling x returns the least integer not less than x"
05:48:27 <orion> That sounds like floor to me, not ceiling.
05:48:30 <orion> Am I mistaken?
05:48:31 <bennofs> quxbam``: there are still some quite serious issues with yi IMO. First, if you open more than 2 tabes, yi hangs. Second, yi doesn't have something like ghc-mod yet
05:48:44 <bennofs> s/tabes/tabs
05:49:09 <quxbam``> and it lacks gnus etc.  it's quite hard to replace emacs
05:49:43 <quxbam``> but the real showstopper for me is the lack of documentation
05:51:45 <nkar> anyone tried to replace elisp with haskell in emacs?
05:51:58 <quxbam``> that sounds awesome!!
05:53:31 <ClaudiusMaximus> orion: you're mistaken - "not less than" = "greater than or equal"
05:54:36 <quxbam``> at least for editing the buffer synchronously, that should be not difficult
05:55:08 <quxbam```> you could easily write elisp code which would wrap around a plethora of haskell functions which could be called with M-x and which will receive a buffer and return a new one...
05:55:16 <JannisLimperg> orion: Let n := ceiling x. Then either (1) n == x, trivial. Or (2) n > x, then n should be the least integer with that property.
05:55:18 <quxbam```> it would be entirely pure
05:56:08 <ClaudiusMaximus> quxbam``: your profiling thing remind me of my experiments http://hackage.haskell.org/package/prof2pretty
05:56:24 <quxbam```> i'll have a look into it
05:56:37 <orion> ClaudiusMaximus: ok, thank you
05:57:55 <quxbam```> oh, that's quite cool
05:58:23 <quxbam```> does it display the source code in the same way than the source code is put, or does it prettyprint?
05:59:10 <ClaudiusMaximus> quxbam```: i don't recall, wrote it 2 years ago and haven't looked at the source since..
06:00:43 <quxbam```> it was quite nasty to put the overlays into the buffer, because visual-prof does pretty-print the source code (the same reason for the different style in hlint), so i needed to fuzzy search the buffer for the pretty printed result
06:01:05 <quxbam```> parse it, and apply to the buffer...
06:02:06 <quxbam```> probably, there exist more elegant solution, i started with haskell before two weeks and with emacs (and anything programming related) before a half a year
06:02:45 <ClaudiusMaximus> quxbam```: just took a look - seems i don't parse/prettyprint, instead i seem to have encoded source spans into the SCC names with the sccpragmabomb preprocessor, so the prof2pretty postprocessor can work with those
06:04:04 <quxbam```> ah ok, i'll look this week a bit into your source code...
06:06:52 <mauris> hey, i wrote a useful little module: https://bpaste.net/raw/6a1ed6638d41
06:07:12 <mauris> but now I'm stuck thinking how to make it more flexible
06:07:58 <mauris> suppose i want output like "2h" instead of "2 hours", or want to support more languages
06:08:53 <mauris> in other programming languages i know, for the former I'd pass optional arguments, and for the latter i'd set some kind of global option
06:09:17 * hackagebot cabal-lenses 0.4.2 - Lenses and traversals for the Cabal library.  http://hackage.haskell.org/package/cabal-lenses-0.4.2 (DanielTrstenjak)
06:09:19 * hackagebot hsimport 0.6.4 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.6.4 (DanielTrstenjak)
06:09:37 <mauris> (although i guess i18n is a deeper issue that i have no idea how to handle nicely...)
06:10:27 <ClaudiusMaximus> mauris: pass a record with the options and define a defaultOptions value with the defaults filled in, and maybe a top level function variant that uses the default options -- seems to be fairly standard practice
06:10:34 <Cale> Probably by defining some sort of data structure to serve as a dictionary for the string constants involved, and then providing some default values to use for English (both abbreviated and not)
06:10:44 <gansteed> where can I find Prelude.hs in ubuntu?
06:10:58 <bergmark> mauris: the way i usually go about things like this is 1) add arguments for each option 2) if that becomes cumbersome, make a datatype for all the options, 3) if i need other kinds of state switch to ReaderT
06:11:16 <Cale> gansteed: Probably nowhere... it'll be part of the base package source code that comes with GHC's source.
06:13:51 <mauris> i see
06:13:53 <Cale> gansteed: But if you just have GHC installed normally, it'll be in already-compiled binary form only. The easiest way to read the Prelude definitions is probably to go here: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.7.0.1/Prelude.html
06:14:00 <gansteed> Cale: all right, I think I can pull down the source code of ghc
06:14:01 <Cale> gansteed: and click the source links on the right edge of the page
06:14:38 <Cale> (at least, if you want to read the real source and not just a fake but easier to read version of it which you'll find in the Report)
06:15:10 <mauris> i guess one of my issues is, http://localization-guide.readthedocs.org/en/latest/l10n/pluralforms.html this :)
06:16:18 <Cale> mauris: Oh, well yeah. That sort of thing might be solved by having the record consist of functions for producing the appropriate word based on the number.
06:16:31 <mauris> i considered that for a second yeah
06:16:34 <Cale> (Should be sufficiently general at least!)
06:16:37 <gansteed> Cale: thanks ;-) but some times I'm offline, I think I'd better download the source code
06:17:03 <mauris> just return something like (4, Minute) and let the user pass a (Int, TimeUnit) -> String
06:17:45 <Cale> Oh, well, that's also possible.
06:19:17 * hackagebot cabal-cargs 0.7.5 - A command line program for extracting compiler arguments from a cabal file.  http://hackage.haskell.org/package/cabal-cargs-0.7.5 (DanielTrstenjak)
06:29:18 * hackagebot cabal-bounds 0.8.9 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.8.9 (DanielTrstenjak)
06:48:56 <zq> recommended matrix library
06:49:31 <zq> @hoogle matrix
06:49:33 <lambdabot> Graphics.Rendering.OpenGL.GL.CoordTrans matrix :: (Matrix m, MatrixComponent c) => Maybe MatrixMode -> StateVar (m c)
06:49:33 <lambdabot> package matrix
06:49:33 <lambdabot> package matrix-market
06:53:29 <ClaudiusMaximus> zq: linear seems popular lately
06:55:55 <zq> ClaudiusMaximus: danke schon
06:57:01 <nshepperd> I've been using hmatrix so far
06:57:14 <zq> oh my god no lens dependency no
06:58:43 <nshepperd> is lens dependency bad
06:59:19 * hackagebot continuum-client 0.1.0.0 -   http://hackage.haskell.org/package/continuum-client-0.1.0.0 (ifesdjeen)
06:59:50 <c_wraith> hmm.  StandaloneDeriving doesn't really work with GADTs
07:02:27 <Cale> nshepperd: It's not so bad if you're making good use of it, but lens itself has a fairly sizeable number of dependencies.
07:07:32 <zq> @hoogle Eq a => [a] -> Bool
07:07:34 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
07:07:34 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
07:07:34 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
07:07:42 <trap_exit> wtf
07:07:44 <trap_exit> whatis this magic
07:07:50 <trap_exit> oh, it's lambdabot
07:08:53 <Cale> trap_exit: well, it's really https://www.haskell.org/hoogle/
07:09:57 <torpet> Hi, I am given a Tree data type with an "integrated" function
07:10:01 <trap_exit> but in commandline form
07:10:09 <trap_exit> Cale: whihc is faster to use
07:10:10 <torpet> http://lpaste.net/3568040164141826048
07:10:30 <torpet> How would I create a simple Node? "Node (\x -> x=x+3) 7" ?
07:10:47 <Cale> torpet: What is Label?
07:10:56 <torpet> just an Int typedef
07:11:22 <Cale> Then yeah, you'd give a function of type Int -> Int, an Int, and then a list of Trees
07:11:25 <Cale> (which may be empty)
07:11:38 <torpet> so lambda functions are fine?
07:11:39 <Cale> So, Node (\x -> x^2) 7 []
07:12:08 <Cale> (\x -> x=x+3) would be a syntax error because of the spurious = sign
07:12:29 <Cale> (= is part of the syntax of declarations and is reserved, so it can't be an infix operator symbol)
07:14:20 * hackagebot colors 0.2.0.1 - A type for colors  http://hackage.haskell.org/package/colors-0.2.0.1 (FumiakiKinoshita)
07:21:37 <torpet> Cale: thanks
07:41:17 <jaspervdj> chrisdone: I like lucid
07:41:49 <wswiss> @pl \a b c d -> (a + b, c + d)
07:41:49 <lambdabot> flip flip (+) . (((.) . (.) . (,)) .) . (+)
07:44:21 * hackagebot elevator 0.1.1 - Immediately lifts to a desired level  http://hackage.haskell.org/package/elevator-0.1.1 (FumiakiKinoshita)
07:45:19 <benzrf> lol
08:02:02 <Hafydd> @pl \a b c d -> a+b+c+d
08:02:02 <lambdabot> ((((+) .) . (+)) .) . (+)
08:02:58 <chrisdone> jaspervdj: cool =)
08:04:22 * hackagebot lucid 1.0 - Clear to write, read and edit DSL for HTML  http://hackage.haskell.org/package/lucid-1.0 (ChrisDone)
08:15:15 <athan> Is higher-kinded thinking included in system-F, or does haskell make two system-F's with types & kinds?
08:15:27 <athan> because (->) is just an instance of *->*->*
08:16:29 <hughfdjackson> hey :) i asked the same Q before, but i've been wracking my brain and not making much progress since
08:16:47 <hughfdjackson> is there any existing library/approach that would help me take a non-tail-recursive recursive call, and 'step through it'
08:17:07 <athan> hughfdjackson: How do you mean "step"?
08:17:07 <hughfdjackson> such that I could take one step at a time
08:17:12 <athan> ohh
08:17:23 <athan> well, you could do the algorithm lazilly
08:17:25 <athan> with a list
08:17:37 <athan> and just pull one additional element with `head` each step
08:17:38 <hughfdjackson> athan: i worked out how to do that with tail recursive calls
08:17:44 <athan> that's how I usually do that
08:17:51 <hughfdjackson> .. maybe i'm overcomplicating this
08:17:54 <wei2912> it's the same for head recursive calls, i believe
08:17:55 <athan> oohhhh
08:18:00 <athan> you could use GHC.Debug
08:18:01 <wei2912> unless i'm wrong
08:18:02 <athan> (I think)
08:18:05 <hughfdjackson> let me whip up an attempt with that :)
08:18:34 <hughfdjackson> the motivation, btw, is to make a lambda calculus repl with 'step through evaluation' functionality
08:18:40 <athan> I think your right wei2912
08:18:48 <athan> nice!!
08:19:03 <hughfdjackson> wei2912: I'm going to take a stab at that approach :) will report back shortly with some code !
08:19:06 <athan> Why not just use a list? Haha
08:19:13 <athan> right on :)
08:19:20 <sivteck> @hackage traced
08:19:20 <lambdabot> http://hackage.haskell.org/package/traced
08:19:23 * hackagebot objective 0.5.1 - Extensible objects  http://hackage.haskell.org/package/objective-0.5.1 (FumiakiKinoshita)
08:19:32 <wei2912> tbf i'm still not certain about head & tail recursion
08:19:38 <wei2912> but something like:
08:19:38 <athan> Same :P
08:19:44 <wei2912> @let fib n = fib (n - 1) + fib (n - 2)
08:19:47 <lambdabot>  Defined.
08:19:51 <wei2912> whoops
08:19:59 <wei2912> @let fib 0 = 0; fib 1 = 1; fib n = fib (n - 1) + fib (n - 2)
08:20:00 <lambdabot>  .L.hs:157:1: Warning:
08:20:00 <lambdabot>      Pattern match(es) are overlapped
08:20:00 <lambdabot>      In an equation for ‘fib’:
08:20:00 <lambdabot>          fib 0 = ...
08:20:00 <lambdabot>          fib 1 = ...
08:20:03 <athan> you need an accumulator, right?
08:20:12 <wei2912> in tail recursion, yes
08:20:25 <athan> hmm, sorry keep going :)
08:20:31 <wei2912> let fib 0 = 0; fib 1 = 1; fib n = fib (n - 1) + fib (n - 2) in fib 10
08:20:42 <wei2912> > let fib 0 = 0; fib 1 = 1; fib n = fib (n - 1) + fib (n - 2) in fib 10
08:20:44 <lambdabot>  55
08:21:03 <hughfdjackson> sivteck: hrm, looks interesting :D thanks for the suggestion
08:21:17 <sivteck> :)
08:21:30 <wei2912> hmm, hughfdjackson is right
08:21:37 <wei2912> it's harder to do so with a list
08:22:25 <athan> it's easier in cryptol :P
08:23:35 <Denommus> Hi
08:24:16 <wei2912> how do we force strict evaluation?
08:24:17 <wei2912> hi Denommus
08:24:31 <wei2912> https://www.haskell.org/haskellwiki/Seq - no idea how this works
08:24:33 <Denommus> How to step a wire with lots of events happening at the same time spot in Netwire
08:24:41 <Denommus> ?
08:25:31 <Denommus> wei2912: IIRC, you use a GHC extension that allows exclamation marks on the type signatures
08:29:17 <athan> wei2912: BangPatterns helps
08:29:36 <athan> you can also force normal form with deepseq
08:30:42 <athan> ( I think that's the right word. Fully evaluated might be a better term. )
08:33:15 <woky_> Hi. Say I've 'foo a b c = a+b+c'. Is there some shorthand to make a new function that only takes 'a' and 'c' with constant b = 5? Something like 'foo _ 5 _' (i.e. not \a c -> foo a 5 c).
08:34:07 <bennofs> @pl \a c -> foo a 5 c
08:34:07 <lambdabot> flip foo 5
08:34:21 <alpounet> :t foo ?? 5
08:34:22 <mauris> not really woky_
08:34:22 <lambdabot>     Not in scope: ‘foo’
08:34:22 <lambdabot>     Perhaps you meant ‘T.for’ (imported from Data.Traversable)
08:34:32 <mauris> "\a c -> foo a 5 c" is pretty good
08:34:36 <bennofs> @let foo a b c = a + b + c
08:34:37 <lambdabot>  Defined.
08:34:39 <alpounet> :t maybe ?? 5
08:34:40 <lambdabot> Num (a -> b) => b -> Maybe a -> b
08:34:47 <alpounet> :t maybe ?? id -- rather
08:34:48 <lambdabot> a -> Maybe a -> a
08:34:51 <woky_> yeah it is, i was just curious ^^
08:34:52 <bennofs> :t (`foo` 5)  -- this doesn't generlize to other arguments though
08:34:54 <lambdabot> Num a => a -> a -> a
08:34:55 <alpounet> but that's not really readable :p
08:35:20 <bennofs> alpounet: it is not? I find ?? looks a lot like _ ("hole" here)
08:35:56 <alpounet> bennofs: yeah but for woky_ you'd need two of them, and one in terminal position, so this can become a mess quite quickly. i do use it every now and then though :)
08:36:07 <bennofs> :t foo ?? 5
08:36:08 <lambdabot> Num a => a -> a -> a
08:36:28 <bennofs> > (foo ?? 5) a b
08:36:29 <lambdabot>  a + 5 + b
08:36:33 <bennofs> alpounet: seems fine
08:37:04 <alpounet> oh right you can just omit the last argument
08:37:43 <alpounet> bennofs: but if woky_ wanted to specify only the last argument, this is more annoying i think
08:37:49 <bennofs> alpounet: yes
08:37:51 <alpounet> you can't juxtapose two ??'s
08:38:30 <athan> Is there a `runArrow` function I'm missing? To turn an arrow back into a function?
08:38:42 <bennofs> athan: not all arrows are functions
08:39:09 <athan> bennofs: Ahh okay, that would have to be up to the instance, right?
08:39:21 <athan> thank you :)
08:39:32 <bennofs> athan: yes. For example, what would runArrow :: Kleisli m a b -> a -> b   do ?
08:39:37 <woky_> i meant the general case like 'foo a b c d = ...; bar = foo _ 1 _ 2' but i can live happy without it, thank you
08:40:38 * athan finally understands Kleisli
08:40:44 <athan> bennofs: Thank you so much :)
08:54:04 <SvenskFisk> How do I convert from a list of [IO SomeType] to [SomeType]? I thought this would work : x <- listOfIO, but it throws an error
08:55:27 <simpson> SvenskFisk: You probably want something like sequence.
08:55:28 <simpson> :t sequence
08:55:29 <lambdabot> Monad m => [m a] -> m [a]
08:55:43 <simpson> This can be used as sequence :: [IO a] -> IO [a]
08:57:15 <SvenskFisk> Oh cool, thanks simpson!
09:03:20 <hughfdjackson> hrm, so the writer monad gives me what I want in terms of intermediate results
09:03:42 <hughfdjackson> :/ just wondering if there's some way I can just take the head of each of the logs without forcing evaluation of the rest of it
09:14:25 * hackagebot hsbencher 1.20 - Launch and gather data from Haskell and non-Haskell benchmarks.  http://hackage.haskell.org/package/hsbencher-1.20 (RyanNewton)
09:19:25 * hackagebot hsbencher 1.20.0.1 - Launch and gather data from Haskell and non-Haskell benchmarks.  http://hackage.haskell.org/package/hsbencher-1.20.0.1 (RyanNewton)
09:19:40 <hughfdjackson> http://hackage.haskell.org/package/stepwise-1.0.2/docs/Control-Monad-Stepwise-Core.html <- this looks like (maybe) what'd be needed
09:19:52 <hughfdjackson> :/ but lacking in the examples that would allow me to understand it
09:19:53 <hughfdjackson> bah !
09:24:56 <fds4345> how do you do `(,) <$> m a <*> mb ` etc with a list?
09:25:13 <fds4345> oh. sequence.
09:25:18 <fds4345> thx
09:31:31 <spopejoy> any tips on diagnosing memory leaks? I wrote a FIX market data server + REST api which runs like a champ but slowly grows in size over the course of the day.
09:32:31 <spopejoy> a dumb question: does GHC GC aggressively? the JRE has "Xmx" to set a maximum heap size. Conceivably, if it didn't, the JVM would be happy to leave garbage around until it was running out.
09:33:13 <ThreeOfEight> Does anybody know of a good Haskell library for image manipulation?
09:33:19 <spopejoy> I'm assuming I have a non-tail-recursive loop somewhere, but I want to rule out that GHC is just choosing not to GC everything because it doesn't have to.
09:33:25 <ThreeOfEight> I need something to draw onto images and/or copy one  image into another one and save stuff as animated GIFs
09:33:31 <nkar> spopejoy: there's a chapter on using the profile in the real world haskell if you're not familiar with it
09:33:38 <nkar> profiler*
09:35:12 <bennofs> spopejoy: there are some RTS flags for changing GC behaviour. See https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime-control.html#rts-options-gc
09:36:04 <bennofs> spopejoy: GHC has an idle GC i think
09:37:39 <ClaudiusMaximus> ThreeOfEight: maybe Rasterific for drawing and JuicyPixels for i/o
09:39:38 <spopejoy> bennofs: idle GC as in "I'll collect when I have to"?
09:40:07 <bennofs> spopejoy: GHC collects both when it has to and when the program is idle for a defined period of time
09:40:34 <ThreeOfEight> ClaudiusMaximus: ah, thanks
09:40:45 <ThreeOfEight> I never considered the possibility of using two different packages
09:40:52 <spopejoy> bennofs: interesting. Mine is not idle pretty much ever, and doesn't use a ton of memory so isn't in danger of running out anytime soon
09:41:05 <ClaudiusMaximus> ThreeOfEight: they're both by the same author so should be interoperable
09:42:08 <indiagreen> spopejoy: you can use “+RTS -H<memory amount>” to limit heap, I think
09:42:29 <indiagreen> or is it “+RTS -M”... a sec, I'll find out
09:42:51 <spopejoy> -M
09:43:22 <spopejoy> -H is bizarre. Just when I thought I had escaped obscure GC params by leaving Java :P
09:43:25 <ClaudiusMaximus> spopejoy: GHC has a generational collector, so shortlived objects get GC'd quite aggressively, with longer-lived objects not being considered for GC so often
09:44:22 <spopejoy> ClaudiusMaximums: that's what I figured ... and I have only very short-lived + a small long-living cache, so I would think the memory shouldn't go anywhere.
09:45:30 <spopejoy> I'll start running the GC output stuff to analyze
09:45:47 <spopejoy> -s[file] looks like the ticket
09:47:40 <bennofs> spopejoy: GHC also has heap profiling if you run with -h
09:51:55 <miromir> hi, please I need some ghc cross-platform help,...anybody?
09:52:24 <Gurkenglas> Any tips on theory, superior language, style, etc. on this thing I just coded up cause I had the idea? https://www.fpcomplete.com/user/Gurkenglas/game-of-life
09:54:26 * hackagebot mangopay 1.10.1 - Bindings to the MangoPay API  http://hackage.haskell.org/package/mangopay-1.10.1 (FelipeLessa)
09:58:15 <haskellquestions> hey i have a question about the "search needle haystack" function on lyah (http://learnyouahaskell.com/modules). with these fold operations searching through lists, when something returns true does it still evaluate teh rest of the list?
09:59:53 <Xenasis> What tools could I use to see which parts of my program are taking the longest?
10:00:21 <sinelaw> Peaker, yo
10:01:26 <ReinH> @google haskell profiling
10:01:27 <lambdabot> https://www.haskell.org/ghc/docs/7.8.1/html/users_guide/profiling.html
10:01:28 <ReinH> Xenasis: ^
10:01:29 <jmcarthur> Xenasis: check out the ghc profiling options. they're built in. you just have to build everything with profiling.
10:01:35 <jmcarthur> yes, that ^^
10:02:09 <Xenasis> Ah, okidoke
10:02:23 <Xenasis> Time to try and add a main I guess
10:04:27 * hackagebot mangopay 1.10.2 - Bindings to the MangoPay API  http://hackage.haskell.org/package/mangopay-1.10.2 (FelipeLessa)
10:09:24 <fds4345> Are there any faster plaintext alternates to Show that arent Aeson
10:09:44 <fds4345> ie bytestring output serialization
10:13:33 <Gurkenglas> Rewrote some, comments still welcome: https://www.fpcomplete.com/user/Gurkenglas/game-of-life
10:14:27 * hackagebot rosa 0.1.0.0 - Query the namecoin blockchain  http://hackage.haskell.org/package/rosa-0.1.0.0 (rnhmjoj)
10:14:37 <vanila> Gurkenglas, my advice is change the let to a where in conwayLife
10:18:13 <vanila> conwayLife [a, b, c, d, e, f, g, h, i] =    (e && (neighbours == 2 || neighbours == 3))
10:18:13 <vanila>                                          || (not e && neighbours == 3)
10:18:13 <vanila>   where neighbours = length (filter id [a, b, c, d, f, g, h, i])
10:18:22 <vanila> this could be more easy to read on first look
10:18:45 <vanila> better put || on the previous line, what i wrote i s weird but anyway
10:18:55 <Gurkenglas> Hmm.
10:19:09 <Gurkenglas> Ya I guess the boolean formula is more important
10:19:50 <Gurkenglas> Does F5 show the changes or does one have to reinput the link?
10:23:07 <Fuuzetsu> @pl f x = x /= y && x /= z
10:23:07 <lambdabot> f = liftM2 (&&) (y /=) (z /=)
10:23:15 <Gurkenglas> That thing with using lists where I mean 9-tuples is fine?
10:23:39 <Fuuzetsu> :t (&&) <$> (undefined /=) <*> (undefined /=)
10:23:40 <lambdabot> Eq a => a -> Bool
10:23:43 <Gurkenglas> > elem 2 [3,5]
10:23:44 <lambdabot>  False
10:27:35 <JonReed> Hi. Is there a shortcut for a constructor? So instead of, "let p = Person { _id = 1, _name = "Brad" }", you could "let p = Person { 1, "Brad" }"
10:27:58 <ReinH> JonReed: records are just normal constructors: Person 1 "Brad"
10:28:28 <JonReed> ReinH: Oh... right. Now I remember. Thx!
10:30:56 <athan> Is it possible to easily lift a command's stdin & stdout to conduit?
10:32:35 <athan> s/possible to/
11:11:11 <apo_> Plastefuchs: nope, I don't either. and lol.
11:12:32 <haskellquestions> hey i have a question about the "search needle haystack" function on lyah (http://learnyouahaskell.com/modules). with these fold operations searching through lists, when something returns true does it still evaluate the rest of the list?
11:13:42 <merijn> haskellquestions: No, due to laziness
11:13:55 <haskellquestions> ok thanks
11:13:58 <merijn> haskellquestions: Evaluation only happens when you try to pattern match
11:14:20 <merijn> > let foo () = 1 in foo undefined
11:14:21 <lambdabot>  *Exception: Prelude.undefined
11:14:27 <merijn> > let foo x = 1 in foo undefined
11:14:28 <lambdabot>  1
11:14:37 <merijn> No pattern match, no evaluation :)
11:14:52 <haskellquestions> hmm ok
11:15:58 <apo_> Plastefuchs: oh, wrong channel. right person, though. :D
11:30:59 <houshuang> I want to use criterion on a function that operates on a list, and see how the speed compares for different lengths, however I don't want to measure the time to construct the list?
11:34:55 <chrisdone> houshuang: force the list ahead of time
11:58:18 <Denommus> It would be nice if there was a FRP channel
11:58:25 <Denommus> I still don't know how to step a single wire in a single frame passing multiple events
11:58:38 <Denommus> Does anyone know?
12:19:00 <johannesbodannes> Is Haskell a very appropriate (or possible) language to be implementing plugin architectures for?
12:20:27 <hpc> it's possible, but annoying
12:20:41 <hpc> you'll do it the same way you would in C
12:20:52 <hpc> with dlls and such
12:20:55 <texasmynsted> How many modules are in Hackage?  I thought there were about 500K.  Is this correct?
12:21:01 <johannesbodannes> is there a better approach to writing extensible programs in Haskell?
12:21:33 <hpc> texasmynsted: you should be counting packages - http://hackage.haskell.org/packages/
12:21:45 <Denommus> hpc: couldn't you call the interpreter instead?
12:21:47 <texasmynsted> manually counting?
12:22:08 <Denommus> johannesbodannes: better than what?
12:22:21 <hpc> 500k is too high though, definitely
12:22:32 <hpc> i'd put it closer to a couple thousand
12:22:39 <pata> Is there a reason why it doesn't seem to be possible to mix pointfree and pointful styles in a function declaration (example: http://lpaste.net/114797 ) ?
12:23:07 <hpc> pata: the standard doesn't let you do it
12:23:13 <hpc> even though it's "obvious" what is meant
12:24:02 <texasmynsted> There must be at least 8ki
12:24:07 <texasmynsted> I mean 8k
12:24:23 <johannesbodannes> Denommus: sorry, I mean better than the plugin architecture approach. say for instance, to use an incredibly simple example, i had a file transferring agent that took and understood URIs but initially only understood a limited set of schemas defined by a limited initial pool of composable plugins
12:24:59 <johannesbodannes> but which might eventually be extended with plugins that define the behaviour for new schemas like ftp:// etc
12:25:49 <Denommus> johannesbodannes: ah. I'd probably use a Lisp for such a task, so I don't know how to help you
12:27:15 <texasmynsted> 7281
12:27:23 <texasmynsted> Did an actual could
12:27:26 <texasmynsted> or count rather
12:30:17 <johannesbodannes> can anyone recommend reading material on effective (purely) functional software architecture?
12:32:24 <sivteck> texasmynsted, http://best-haskell.herokuapp.com/#/
12:32:24 <johannesbodannes> i think maybe the problem i have is that i'm too readily matching OO architectural practices to functional programming, but i honestly haven't ever seen any sort of canon on the subject for functional programming
12:33:06 <mreh> why is it that lens composition is read in the opposite direction to function comp?
12:33:07 <johannesbodannes> is functional programming architecture even as well-fleshed-out a subject matter as OO architecture?
12:33:26 <edwardk> mreh: because you are composing 'functions that take functions'
12:33:30 <edwardk> :t map.map
12:33:31 <lambdabot> (a -> b) -> [[a]] -> [[b]]
12:33:39 <edwardk> that is the same kind of thing that lens does
12:33:40 <mreh> edwardk: the man himself :)
12:33:46 <edwardk> its not obvious that that is 'reversed' but
12:33:48 <edwardk> :t map.fmap
12:33:49 <lambdabot> Functor f => (a -> b) -> [f a] -> [f b]
12:33:59 <edwardk> notice the 'f' from fmap is 'on the inside'
12:34:03 <edwardk> because you are composing functions
12:34:11 <edwardk> map (fmap f) ...
12:34:14 <edwardk> does what you'd expect
12:34:32 <edwardk> but if you drop the f and compose the things that take functions: map.fmap
12:34:36 <edwardk> it 'looks backwards'
12:34:53 <edwardk> and folks get confused
12:34:59 <edwardk> but its just that their reference frame is wrong
12:35:26 <edwardk> so lenses compose like functions like map, foldMap, traverse, etc. not like simple functions
12:36:13 <[swift]> johannesbodannes: i am hoping someone has a good answer for you, because while i've found lots of useful ideas on blogs and so forth, it's pretty scattered. i'm not aware of a definitive book on the subject or anything like that
12:36:16 <mreh> okay
12:36:28 <vanila> johannesbodannes: program derivation like Huttons papers
12:36:29 <[swift]> (on the other hand, a lot of books on Haskell have been published recently which i haven't had a chance to read...)
12:37:21 <bennofs> mreh: Another way to view this is that lenses compose like the "setter" part, not like the get part: set l1 . set l2 is also backwards in that sense as it doesn't set the field l1 inside l2
12:37:22 <edwardk> johannesbodannes: in some sense a lot of us feel there is a lot less need for architecture and design patterns in this space. sure there are idioms we repeat, but in general a design pattern is just a name for something your language can't express as a library.
12:37:28 <edwardk> i find i have a lot fewer of those in haskell
12:38:03 * mreh thinks about this a bit
12:38:20 <bennofs> mreh: oops, sorry, I meant to use over: over l1 . over l2, otherwise this doesn't typecheck
12:38:35 <johannesbodannes> hm, I see! i'll look around at some of Hutton's stuff. i'm mostly a bit worried about how to keep haskell code I write maintainable when it gets legitimagely big
12:38:40 <johannesbodannes> legitimately*
12:38:46 <edwardk> then you have the weird side effect that if you build bottom up with parametricity that things tend to just fit together in ways that they don't in other languages
12:38:49 <mreh> awesome typo
12:38:59 <edwardk> johannesbodannes: i manage to juggle a fair bit of haskell code without much difficulty
12:39:09 <vanila> johannesbodannes, try to make it into units that can be understood on their own,  one way to do that is using DSLs
12:40:25 <[swift]> johannesbodannes: the basics are the same in Haskell that they are in any OO language - divide things into modules, avoid unnecessary coupling between modules, etc
12:40:47 <[swift]> johannesbodannes: in practice i find that's usually so easy in haskell that it doesn't take much discipline
12:42:49 <johannesbodannes> OO offers some things that I'm not sure Haskell does as readily though. Like the dependency inversion principle which I've found immensely valuable for testability and code reuse
12:43:10 <johannesbodannes> OK testability isn't going to be an issue in haskell <_<
12:43:20 <jfischoff> johannesbodannes: I’ve heard this line before, can you explaing in more detail what it is?
12:43:26 <jfischoff> dependency inversion
12:43:47 <johannesbodannes> basically any of your code only ever directly depends on abstractions
12:44:07 <johannesbodannes> no unit ever perceives a concretion of an abstraction
12:44:18 <jfischoff> so only use interfaces?
12:44:27 <johannesbodannes> yeah essentially
12:44:27 <vanila> testing is not hard in haskell
12:44:39 <Gurkenglas> vanila, he just said that
12:44:41 <jfischoff> johannesbodannes: You can do this in haskell
12:44:46 <vanila> i misread
12:45:05 <texasmynsted> interesting.  I wonder how best-haskell got a different count.  I counted by name from hackage
12:45:20 <johannesbodannes> what's the proper haskell approach to that, jfischoff?
12:45:20 <jfischoff> johannesbodannes: There are basically two ways, build up and expression and evaluate it, use typeclasses
12:45:35 <jfischoff> there mutually exclusive either
12:45:43 <jfischoff> at work we use typeclasses
12:45:53 <mreh> testability isn't necessarily an advantage when you have nice semantics
12:45:56 <jfischoff> so we can write tests using fakes
12:46:11 <Kaidelong> mreh: ????
12:46:23 <johannesbodannes> mreh, i'm confused too, what do you mean by that?
12:46:50 <mreh> easy to comprehend semantics are more valuable
12:46:52 <Kaidelong> besides haskell's semantics lends itself well to testing because pure functions are simpler to test
12:46:52 <vanila> testing is good
12:47:07 <vanila> you can't prove code correct
12:47:21 <johannesbodannes> i legitimately can't imagine writing a large program without testing : |
12:47:22 <Kaidelong> vanila: ????
12:47:27 <texasmynsted> wat?
12:47:34 <texasmynsted> what do you mean you can't prove code correct
12:47:38 <vanila> it takes too much work
12:47:44 <vanila> so it's better to test
12:47:49 <Kaidelong> that's why we do it with automated tools
12:47:50 <texasmynsted> o_O
12:47:56 <Kaidelong> we also do testing with automated tools, btw
12:48:04 <jfischoff> even os kernels that are proven correct, tend to have assembly that is not
12:48:06 <Kaidelong> if you had to do everything by hand, the proofs would probably be easier
12:48:16 <jfischoff> the problem is that you can
12:48:28 <jfischoff> can’t control the outside world
12:48:39 <jfischoff> so if your program depends on a thirdparty service
12:48:46 <jfischoff> you need tests, there is nothing to prove
12:48:58 <jfischoff> and this the case with anything that uses the OS
12:49:01 <Kaidelong> it's probably smart to have tests anyway
12:49:05 <bennofs> jfischoff: I think sel4 has been proven correct at the assembly level though
12:50:00 <texasmynsted> In the absence of side effects, I think it is fairly simple to show code correctness
12:50:06 <Gurkenglas> What do you mean by "build up and expression and evaluate it"?
12:50:12 <Gurkenglas> *jfischoff
12:52:45 <mreh> @hoogle a -> Lens b c
12:52:46 <lambdabot> Warning: Unknown type Lens
12:52:47 <lambdabot> Data.Graph.Inductive.Graph delNode :: Graph gr => Node -> gr a b -> gr a b
12:52:47 <lambdabot> Control.Monad.Trans.Class lift :: (MonadTrans t, Monad m) => m a -> t m a
12:52:58 <bennofs> mreh: eh? what should that do
12:53:15 <mreh> I was just wondering if there was a function to make a Lens from a getter and setter
12:53:20 <bennofs> :t lens
12:53:21 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
12:53:24 <mreh> I was going to try to make the identity lens
12:53:25 <mreh> ah
12:53:47 <bennofs> mreh: the identity lens is just id though
12:53:52 <bennofs> > view id 3
12:53:54 <lambdabot>  3
12:54:02 <mreh> :t id
12:54:03 <lambdabot> a -> a
12:54:16 <johannesbodannes> I reckon that helps a lot texasmynsted, and I don't want to give the impression that I don't think functional purity is amazing for testability, but what about duplication of test logic? If I have a function A that calls B and C, and B and C are tested, how do I test A without essentially creating the same test logic as I did for B and C since I can't just trivially swap out B and C for fakes?
12:54:38 <johannesbodannes> what if the layers go much deepeer? Bs and Cs which call Ds Es and Fs and so on
12:54:39 <mreh> that's the function id, not the category
12:54:55 <johannesbodannes> integration testing, super easy
12:54:57 <Gurkenglas> How can id fit Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t?
12:55:02 <bennofs> mreh: yes, the function id is also a
12:55:05 <johannesbodannes> unit testing feels realy difficult though
12:55:07 <bennofs> identity lens
12:55:33 <Gurkenglas> It would mean (s -> a) -> (s -> b -> t) -> (a -> f b) -> s == f t
12:55:39 <jfischoff> bennofs: The only paper I could find on sel4 said they assumed the assembly was correct
12:55:40 <bennofs> Gurkenglas: the identity lens has type Lens' a a, which is just Functor f => (a -> f a) -> a -> f a, which is just id
12:55:47 <jfischoff> bennofs: maybe there is a newer paper
12:56:13 <bennofs> @google sel4 assembly
12:56:13 <spopejoy> unit-testing has been developed around OO, so there's some re-adjustment that has to happen vis a vis TDD
12:56:16 <lambdabot> http://www.nicta.com.au/pub?doc=5857
12:56:16 <lambdabot> Title: Microkernel Verification Down To Assembly
12:56:20 <jfischoff> Gurkenglas: Something like a free monad approach to mocking IO
12:56:41 <jfischoff> there are other examples, it is common approach
12:56:46 <johannesbodannes> do any major haskell projects use TDD?
12:56:53 <johannesbodannes> is there something i can look at?
12:57:04 <spopejoy> TDD is more about applications to my mind
12:57:45 <mreh> :t lens
12:57:45 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
12:57:48 <spopejoy> libraries are more purposeful, i don't think you need to approach them unittest first
12:57:49 <mreh> which bit is the lens?
12:58:01 <spopejoy> applications on the other hand are requirements-driven
12:58:14 <mreh> lenses I am familiar with are wrapped up in a type
12:58:24 <spopejoy> there was a talk in NYC recently about TDD
12:58:39 <johannesbodannes> oh?
12:58:46 <bennofs> mreh: the (a -> f b) -> s -> f t  + the Functor f constraint
12:58:49 <spopejoy> let me see if there's slides
12:59:17 <Phillemann> Is there a Middleware for WAI that really prints every request with all the gory details? RequestLogger doesn't export all the necessary functions it seems.
13:01:20 <spopejoy> https://dbp.io/static/types-testing-haskell-meetup-2014.pdf
13:01:20 <bernalex> hm. I forget. how do I make a module that just imports a bunch of crap and reexports it?
13:01:42 <bernalex> module Foo.ImportThis where ... import Foo.Bar; import Foo.Baz; import Foo.Quix
13:01:55 <bennofs> bernalex: put 'module Foo.Bar' in the export list
13:01:58 <bernalex> what's the "..." part that makes it export all of Foo.{Bar,Baz,Quix}?
13:01:59 <johannesbodannes> thanks spopejoy
13:02:09 <edwardk> mreh: the lens package doesn't do the wrapping thing. which causes some folks a great deal of consternation
13:02:11 <bernalex> bennofs: ah, so there's no way to have it autoexport everything I import?
13:02:19 <texasmynsted> I will have to catch up later…  I would love to learn more about good testing for haskell code
13:02:19 <edwardk> mreh: the " (a -> f b) -> s -> f t " part is the lens
13:02:30 <bennofs> bernalex: you can do import A as X, import B as X and then export 'module X'
13:02:44 <bennofs> bernalex: worth reading: http://www.vex.net/~trebla/haskell/module.xhtml
13:02:50 <bernalex> bennofs: interesting
13:02:54 <bernalex> bennofs: thanks for the link -- I'll have a look
13:03:01 <mreh> why should the setter be more generic than (s -> b -> s)?
13:03:10 <mreh> oh, I know why
13:03:52 <ClaudiusMaximus> bennofs, bernalex: unless it's been fixed, that breaks haddock
13:04:03 <bernalex> bennofs: so if I import all those three as X, then people can just import Foo.ImportThis to get everything imported for free?
13:04:06 <bernalex> ClaudiusMaximus: in what manner?
13:04:12 <bernalex> ClaudiusMaximus: like, Foo.ImportThis will not have docstrings?
13:04:20 <ClaudiusMaximus> bernalex: no links to the re-exported modules
13:04:21 <bennofs> bernalex: I think haddock will not show what is reexported
13:04:33 <bernalex> I'll just run cabal haddock and see for myself
13:04:42 <bennofs> bernalex: yes, it should work like that
13:04:46 <bernalex> ah
13:04:51 <bernalex> 400 "could not find link destinations" messages lol
13:05:00 <bernalex> Could not find documentation for exported module: X
13:05:26 <mreh> edwardk: just so you can use (.) from Prelude?
13:05:39 <bernalex> that's really bad! since one of the main reasons to do this is to have that one file that serves as an entry point.
13:05:40 <mreh> do you recommend this?
13:05:44 <edwardk> mreh: not 'just so' but that happens to be a nice side effect
13:05:56 <mreh> ok
13:06:07 <edwardk> mreh: in this case it works well, because there are literally dozens of refinements of this type around that all vary in constraints on 'f'
13:06:11 <edwardk> and slightly different shape
13:06:48 <ClaudiusMaximus> bernalex: http://trac.haskell.org/haddock/ticket/225
13:07:06 <mreh> I don't think it's that important that I understand why, but it would be better if the type errors were clearer
13:07:39 <mreh> but GHC uses type synonyms in it's type error reporting now doesn't it
13:08:02 <bernalex> ClaudiusMaximus: thank you, I will look into it in more detail at work, Monday.
13:10:47 <danilo2> Hello! I'm writing a compiler in haskell. This compilar has got passes - just functions which consume data and privide other data to toher passes. Users can affect the order and which of these passes are executed in runtime (command line args). I want to ask you if it is possible to somehow allow user to run pass "ssa" which consumes (AST a) but somehow know if the currently
13:11:36 <vanila> danilo2, currently?
13:11:41 <vanila> I think your message was cut off
13:11:52 <danilo2> produced AST is AST String or AST Expr. I mean - some passes before the "ssa" may change the type of AST. I want just to keep the data in memory and run the pass on it. It would not be a problem if we do it statically, but hwen we order the passes in runtime, the problem exist
13:12:15 <danilo2> vanila: Sorry, the irc client cut out the rest of the sentence. I pasted it above :)
13:12:18 <vanila> one way might be to create a data type like
13:12:30 <vanila> data TaggedAST where
13:12:38 <vanila>  StringAST :: AST String -> TaggedAST
13:12:45 <vanila>  ExprAST :: AST Expr -> TaggedAST
13:12:54 <mreh> it's too easy for me to get lost in category theory and not do any work when I come on here
13:12:56 <vanila> then you can find out which type it has by pattern matching
13:13:18 <vanila> if you know your pass only takes Expr for example, you could throw an exception
13:15:10 <danilo2> vanila: Yes, that is the idea I've got right now. It is a pretty good solution hrere, but it limits AST ot AST String and AST Expr. What if user wants to write custom pass (as a plugin to the compiler - loaded dynamically form .o file) and he wants to provide AST Foo ? My "ssa" pass works on (AST a)
13:16:00 <bennofs> danilo2: you could use make AST Typeable and then use Dynamic
13:16:02 <bennofs> :t Dynamic
13:16:03 <lambdabot> Not in scope: data constructor ‘Dynamic’
13:16:05 <danilo2> vanila: Throwing exception is not a good way here also. If a pass needs AST Expr and I've got AST Stirng the compiler would automatically find a pass that converts one to another
13:16:29 <bennofs> :t Dynamic
13:16:30 <lambdabot> Not in scope: data constructor ‘Dynamic’
13:16:40 <bennofs> :t toDyn
13:16:41 <lambdabot> Typeable a => a -> Dynamic
13:16:42 <bennofs> :t fromDyn
13:16:43 <lambdabot> Typeable a => Dynamic -> a -> a
13:17:12 <danilo2> bennofs: I was thinking about it. But look - User enables passes A, B and C - they produces AST Expr (I can convert it to Dynamic) but tthen I want to run "ssa" pass, which works for AST a - how can I know that it was AST Expr
13:17:13 <danilo2> ?
13:17:34 <Adeon> what happens if I throw an exception in a haskell function that was called from C code and don't catch it myself
13:19:06 <vanila> danilo2, If you add a new compiler pass that uses a new type index you could just add a new constructor to the GADT
13:19:33 <vanila> It will require to recompile the whole program
13:20:31 <danilo2> vanila: I cannot add a new constructor to GADTs when writing compiler pass,can I? User does not have the sources of the compiler - he has got only API that he can use to write passes
13:20:38 <ClaudiusMaximus> Adeon: If an evaluation triggered by an external invocation of an exported Haskell value returns with an exception, the system behaviour is undefined. Thus, Haskell exceptions have to be caught within Haskell and explicitly marshalled to the foreign code.  -- https://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1600008.4.4
13:21:14 <vanila> I thought it was a good idea that the programmer should have access to the full source code
13:21:55 <vanila> Maybe you could make the GADT cover enough types that no one will need to create a new one
13:22:07 <danilo2> vanila: Unless your product is a commercial one. And If you want to install 2 plugins from 2 sources - you should not merge the commits but just insert two .o files in a folder
13:22:28 <Adeon> ClaudiusMaximus: thanks; I didn't think the report would have a say on that
13:22:37 <danilo2> vanila: that is the solution I'm thinking of, but it is a little limited and because of that I'm asking here if there is something more general
13:22:40 <danilo2> :(
13:22:54 <vanila> sorry
13:23:43 <bennofs> danilo2: I think data Dynamic where Dynamic :: Typeable a => a -> Dynamic should allow you to do (if f :: forall a. Dynamic b => a -> b and d :: Dynamic): case d of Dynamic x -> Dynamic $ f x
13:23:44 <vanila> maybe you could use open records
13:24:11 <vanila> in that case a pass would accept any index which contains all the fields it needs
13:24:22 <vanila> and then you would bge able to add more information (that a pass can safely ignore)
13:25:26 <danilo2> bennofs: brb, I'm thinking aobut it
13:26:45 <danilo2> bennofs: That sounds very interesting. I just does not know how to use the second part. Woudl you be so nice and help me a little further with it? Of course If you've got free 2 minutes :)
13:27:32 <bennofs> @let data AST a = AST a deriving Typeable     -- for demonstration
13:27:34 <lambdabot>  Defined.
13:28:12 <bennofs> @let data DynamicAST where DynamicAST :: Typeable a => AST a -> DynamicAST
13:28:14 <lambdabot>  Defined.
13:29:23 <bennofs> @let applyGenericPass :: (forall a. AST a -> AST a) -> DynamicAST -> DynamicAST; applyGenericPass f (DynamicAST a) = DynamicAST (f a)
13:29:24 <lambdabot>  Defined.
13:30:19 <danilo2> bennofs: oh!
13:30:38 <danilo2> bennofs: brb, thank you very much. I'm going to test it right now. This can be something so simple I was looking for
13:31:01 <bennofs> @let applySpecifcPass :: (Typeable b => AST String -> AST b) -> DynamicAST -> Maybe DynamicAST; applySpecificPass f (DynamicAST a) = fmap (DynamicAST . f) $ cast a
13:31:02 <lambdabot>  .L.hs:165:1:
13:31:02 <lambdabot>      The type signature for ‘applySpecifcPass’
13:31:02 <lambdabot>        lacks an accompanying binding
13:31:12 <bennofs> @let applySpecificPass :: (Typeable b => AST String -> AST b) -> DynamicAST -> Maybe DynamicAST; applySpecificPass f (DynamicAST a) = fmap (DynamicAST . f) $ cast a
13:31:13 <lambdabot>  .L.hs:169:44:
13:31:13 <lambdabot>      Could not deduce (Typeable b) arising from a use of ‘DynamicAST’
13:31:13 <lambdabot>      from the context (Typeable a)
13:31:13 <lambdabot>        bound by a pattern with constructor
13:31:13 <lambdabot>                   DynamicAST :: forall a. Typeable a => AST a -> DynamicAST,
13:31:28 <bennofs> @let applySpecificPass :: Typeable b => (AST String -> AST b) -> DynamicAST -> Maybe DynamicAST; applySpecificPass f (DynamicAST a) = fmap (DynamicAST . f) $ cast a
13:31:29 <lambdabot>  Defined.
13:32:09 <agocorona> that user lambdabot is ever complaining
13:32:36 <bennofs> danilo2: the problem with this approach is that you can not use 'show' or similar as a pass (or any other function which doesn't work for all AST a, but requires some additional type-class constraints on a)
13:34:09 <danilo2> bennofs: I was exactly about asking about it. What If I got a pass that needs AST Expr ? Am I somehow able to discover that current AST is not AST Expr and execute additional pass ? I'm sorry if this is easy question, I just not yet fully dig into your example
13:34:13 <bennofs> You can of course provide a set of fixed typeclass constraints that a pass may assume, but you have to specify them in the definition of DynamicAST and then you cannot write "truly" generic passes (all passes need to ensure that their return value also satisfies all these constraints)
13:34:34 * hackagebot hspec-webdriver 1.0.0 - Write end2end web application tests using webdriver and hspec  http://hackage.haskell.org/package/hspec-webdriver-1.0.0 (JohnLenz)
13:34:39 <bennofs> :t applySpecificPass -- danilo2: is this what you mean?
13:34:40 <lambdabot> Typeable b => (AST String -> AST b) -> DynamicAST -> Maybe DynamicAST
13:35:03 <bennofs> oops, why did I put a string there?
13:35:25 <bennofs> @let applySpecificPass' :: (Typeable b, Typeable e) => (AST e -> AST b) -> DynamicAST -> Maybe DynamicAST; applySpecificPass f (DynamicAST a) = fmap (DynamicAST . f) $ cast a
13:35:26 <lambdabot>  .L.hs:169:1:
13:35:26 <lambdabot>      The type signature for ‘applySpecificPass'’
13:35:26 <lambdabot>        lacks an accompanying binding
13:35:32 <bennofs> @let applySpecificPass' :: (Typeable b, Typeable e) => (AST e -> AST b) -> DynamicAST -> Maybe DynamicAST; applySpecificPass' f (DynamicAST a) = fmap (DynamicAST . f) $ cast a
13:35:33 <lambdabot>  Defined.
13:36:50 <danilo2> bennofs: Not exaclty, but its close. Lets say after some passes we got AST String. Now we want to run a pass ,that works only on AST Expr. In such case I want just to lookup for a pass that converts AST String to AST Expr
13:37:03 <dmj`> any nix osx users here?
13:37:07 <danilo2> (before running this pass) - but I think It is doable using your method.
13:37:48 <bennofs> danilo2: yeah, that might be doable if you also explicitely store the TypeRep's of the passes
13:37:50 <bennofs> :t typeOf
13:37:51 <lambdabot> Typeable a => a -> TypeRep
13:38:54 <bennofs> @let dynamicASTTypeRep (DynamicAST a) = typeRep a
13:38:55 <lambdabot>  Defined.
13:39:38 <danilo2> bennofs: I cannot sotre TypeReps of passes because they could be polymorphic. Anyway I can wrote some additional datatypes connected to these types between passes. Anyway thank you very much for this example! I will now test it and try to do exactly what I want. If I will have any other problems than I will write to you If you agree :) Thank you once again! :)
13:40:20 <bennofs> danilo2: hmm right, with polymorphic types it could in fact be impossible
13:41:52 <bennofs> danilo2: I don't know of a way to store a function at runtime in a way that it's possible to check if it accepts a value of a given type / TypeRep
13:43:03 <danilo2> bennofs: I think it is impossible in Haskell. Anyway I can just write a "solver" for it and cast dynamically the passes.
13:43:08 <bennofs> danilo2: maybe you can just give the pass the DynamicAST value and let the pass itself decide if it can handle this type or not? (by returning a Maybe or similar from the pass)
13:43:12 <danilo2> bennofs: Or at last im thinking of it
13:43:42 <ClaudiusMaximus> danilo2, bennofs: http://hackage.haskell.org/package/polytypeable might be useful (not tried it myself)
13:43:44 <danilo2> bennofs: Of course - but then I would need the information whatr the pass was lacking and provide it to the pass
13:44:25 <jle`> :t [()]
13:44:26 <lambdabot> [()]
13:44:40 <jle`> :t Identity ()
13:44:41 <lambdabot> Identity ()
13:44:58 <danilo2> ClaudiusMaximus: hmm, it could indeed but it does not compile :(
13:45:22 <bennofs> danilo2: I think the problem is that it's not possible to check if a given type is an instance of some class at runtime
13:46:05 <bennofs> danilo2: so if you have a pass :: Show a => AST a -> AST String, you cannot figure out if a type 'X' is an instance of 'Show' (which it would need to be if you can apply this pass)
13:46:36 <danilo2> bennofs: definitively! I didnt wirte it because it has some long story to tell why it is so, but I got the same ocnclusion when looking how the polymorphic passes are owrking
13:46:51 <bennofs> danilo2: do you really need fully polymorphic passes? it makes the whole thing a lot more complex
13:46:55 <danilo2> bennofs: but hmm
13:47:45 <ClaudiusMaximus> danilo2: what about making your compiler into a library and letting your user write their pass compositions in haskell, so you get compiler type support - maybe hint could work too?
13:48:16 <danilo2> bennofs: I think we missunderstand here. I've got pass AST a -> AST a - with some ocntext on a but I assume this ocntext is always met. I've got just some passes like AST String -> AST Expr or AST a -> AST a and I want give user to completely control the execution order etc
13:48:46 <danilo2> ClaudiusMaximus: The execution order has to be provided by command line args - like in clang
13:49:28 <danilo2> ClaudiusMaximus: if you use clang you can compile some cpp code using clang -ssa -scc ... and then you execute ssa and scc passes next to each other (OR with other passes inbetween which provide additional needed data)
13:49:51 <bennofs> danilo2: ah, so you got some "global" constraints a which are met by all valid AST a 's? (you never have AST x with x not an instance of these "global" constraints)
13:50:29 <ClaudiusMaximus> could use command line flags to write a haskell program and get that compiled at runtime (or interpreted), but its a messy problem whichever way you do it i think
13:50:41 <danilo2> bennofs: yes. I;ve got just instances which know what to do with specific x's and if the x ois other, they just omit it there
13:51:16 <ClaudiusMaximus> the "adding extra passes depending on types" is particularly awkward i think
13:51:17 <danilo2> bennofs: (using OverlappingInstances)
13:52:33 <bennofs> danilo2: ah, then all polymorphic passes are of the same input type?
13:53:45 <danilo2> bennofs: no, because (sorry I mention it now but I was thinking it does not matter) AST is parametrized with more than one type
13:54:01 <danilo2> bennofs: So it coudl be AST String a or AST a b
13:54:46 <danilo2> but maybe I can geralize it to this idea you've got now
13:54:53 <danilo2> What are you thinking about ?
13:55:39 <bennofs> danilo2: ok, so a pass is either: a generic pass from forall a, AST a b to AST a c for some b, c with some constraints on a (always the same) ?
13:56:10 <bennofs> or a concrete pass from AST a b to AST c d for concrete types a,b,c,d ?
13:58:04 <danilo2> bennofs: exactly. I'm just not sure if the constrains are always the same - but it is so, that If a pass is generic then it works forall a.  - so if the a is something it does not know, it just works providing less infomration. The passes that are not geneeric are working on specific types
13:58:59 <danilo2> bennofs: Ideally the generic passes can transform (forall a. AST a b -> AST a c) for a specific b and c
13:59:22 <bennofs> danilo2: and some constraints on a, I guess? (but those are fixed)
13:59:34 * hackagebot tuple-morph 0.1.0.0 - Morph between tuples with the same "flattened" representation  http://hackage.haskell.org/package/tuple-morph-0.1.0.0 (pawel834)
14:00:46 <danilo2> bennofs: of course - like in SSA pass (where we do some custom traversals over AST) - if AST is not completely parsed (after first parsing stage), the alias analysis pass is done without anlysing the strings. So we gon constraint like Traversable a - but if a is String, then we do not traverse it
14:01:05 <danilo2> bennofs: Traversable etc are our custom type classes, dont think of lenses here
14:02:01 <favetelinguis> need help with some list magic, http://lpaste.net/114808 lost on this one how i can transform this into something else, wold be cool using foldr but donk know where to start
14:02:19 <favetelinguis> any sugestions
14:03:48 <Peaker> glguy: still here? I read the backlog about withMVar being OK if you don't put something into the MVar in the bracket body
14:04:02 <glguy_> yup
14:04:37 <Peaker> glguy: I disagree -- I think it should be entirely legitimate to have two threads that do something like: A) bracket takeMVar (..putMVar..) B) bracket (putMVar..) (takeMVar..)
14:04:57 <glguy_> You disagree with what?
14:05:15 <Peaker> that withMVar is async-exception safe unless you have a bug
14:05:16 <bennofs> danilo2: ok, so for a pass type similar to this: data Pass where { GenericPass :: forall b c. (Typeable b, Typeable c) => (forall a. (C1 a, C2 a, ...) => AST a b -> AST a c) -> Pass; ConcretePass :: forall a b c d. (C1 a, C2 a, ..., C1 c, C2 c, ..., Typeable c, Typeable d) => (AST a b -> AST c d) -> Pass }   using a Dynamic-like type with the some constraints should work
14:05:42 <glguy_> Peaker: well, given that what I described is the documented behavior and it is how 'withMVar' is intended to be used
14:05:46 <Peaker> glguy_: I think it's not a bug to put into the MVar during a "withMVar" (in a different concurrent thread)
14:05:56 <glguy_> you can disagree with how it should be
14:05:59 <glguy_> but my statement wasn't wrong
14:06:33 <danilo2> bennofs: That sound great. I do not know how to thank you for your help. Thank you very much!
14:06:36 <bennofs> danilo2: hmm, I guess you also need Typeable a,b in the concrete pass case so you can check if any concrete pass accepts the given input (a generic pass should accept every input type, right?)
14:06:41 <Peaker> well, it's a consequence of cleanups being interruptible which has virtually no benefit here.. if they're uninterruptible then this will Just Work
14:06:52 <vanila> danilo2, is the compiler on github or something? I would be interested in folllowing its development
14:06:56 <Peaker> Cleanups being interruptible has virtually no benefit anywhere, actually...
14:07:19 <danilo2> bennofs: oh! could you just tell me one last think? How can I get the data from the dynamic pass? I know that the resutl is AST String for examplke, but GHC does nto allow for function like: fromDynamicAST :: DynamicAST -> a; fromDynamicAST (DynamicAST a) = cast a
14:08:03 <bennofs> danilo2: cast returns a Maybe. So if you're sure you've got a AST String, you can just fromJust that maybe
14:08:05 <danilo2> vanila: We are thinking aobut open sourcing it in few weeks. We have created a language with 2 representations - visual and textual and we are using this language to develop special effects toolkit
14:08:50 <bennofs> danilo2: (probably better to use fromMaybe (error "internal compiler error <some descriptive message>") though=
14:09:00 <danilo2> bennofs: Oh, sorry - I was confused by the error that a variable would escape its scope. Of course, thank you :)
14:09:13 <danilo2> bennofs: of course better! :)
14:09:25 <danilo2> bennofs: anyway - thank you so much!
14:09:51 <glguy_> Peaker: If you want this specialized behavior you can always wrap your blocking cleanup function in uninterruptibleMask
14:10:02 <glguy_> but withMVar is async safe when used as documented
14:12:52 <dmj`> any reason why nix-env -i cabal-install would fail?
14:13:12 <dmj`> http://lpaste.net/114810
14:13:33 <Peaker> glguy_: is there any conceivable benefit in not wrapping all cleanup actions in uninterruptibleMask_ ?
14:15:13 <merijn> glguy_: I would argue "if you want the (current) uncommon behaviour, use interruptibleBracket" (although interruptibleBracket doesn't exist yet)
14:15:18 <glguy_> sure, to avoid deadlock in threads in some contexts
14:15:33 <glguy_> not all cleanup cases are simple calls to "putMVar"
14:15:44 <glguy_> people put more code than that in a finally handler, for example
14:16:00 <merijn> glguy_: People keep saying that, yet NO ONE has been able to point to a single hackage package that does this
14:16:21 <merijn> glguy_: Meanwhile, the cases where it goes wrong with the current approach litter all of hackage
14:16:26 <glguy_> and the people asking to change it haven't done the analysis that it isn't the case
14:16:28 <merijn> Even GHC has bugs caused by this
14:16:31 <glguy_> I'm not arguing that we can't change it
14:16:44 <glguy_> just answering questions as asked
14:17:15 <glguy_> I wasn't asked "is it the right default"
14:17:27 <glguy_> I was asked "is there any conceivable benefit"
14:17:31 <merijn> glguy_: Ah, I missed the start :)
14:17:52 <Peaker> merijn: btw: I don't understand why everybody wants "hClose" to guarantee its effect happens even in case of exception.. What if I have an opposite bracket?  bracket hClose (openFile..)?  I really don't want hClose being async-interrupted to cause a close there!
14:18:22 <Peaker> glguy_: I don't know if the deadlock avoidance is an actual conceivable benefit as I think all cases I've seen where a deadlock would actually be avoided, some other bug would happen instead
14:19:09 <Peaker> merijn: (and it seems entirely legitimate to me to want to have a bracket in which the file is closed, because the file being open has various visible effects I might want to temporarily disable)
14:19:20 <glguy_> I'm not motivated by people wanting to leak resources out of a scope as defined by bracket or finally to have the cleanup handlers wait for the remote thread to return the resource, but the argument that does make sense to me is that killThread becomes quite confusing with the current behavior
14:19:41 <glguy_> if KillThread is received in the bracket "body" then you still run a potentially blocking cleanup handler
14:19:48 <glguy_> but if it's received in the cleanup handler
14:19:53 <glguy_> then you can interrupt it
14:19:58 <glguy_> feels inconsistent
14:20:06 <Peaker> glguy_: I think the most convincing argument is that bracket is supposed to guarantee stuff, not "try" and easily give up
14:20:33 <glguy_> Yeah, that one seems to resonate more iwth other people
14:20:38 <glguy_> I like the idea of killthread always either transitioning into the clenaup handler
14:20:40 <glguy_> or doing nothing
14:20:50 <glguy_> rather than sometimes killing the body, sometimes kiling the cleanup
14:21:27 <Peaker> well, it always does "something", but something might be deferred for a while :)
14:22:14 <glguy_> yeah, still able to kill the thread, but is only about interrupting the "body" in a normal use
14:22:32 <Peaker> if you kill a thread during blocking cleanup, it'll just wait until cleanup is complete and then kill it
14:22:36 <glguy_> yup
14:22:58 <Peaker> I had one deadlock due to 2 threads trying to kill each other in their cleanups
14:23:00 <glguy_> Now if killThread in the body would cause the cleanup handler to interrupt as soon as it tried to block, I might be ok with the current default
14:23:06 <Peaker> made one side asynchronous (kill via forkIO)
14:23:31 <Peaker> glguy_: that would be so hard to get any bracket correct :(
14:24:02 <Peaker> it would effectively ban blocking cleanups, which may sound good but actually makes "bracket" much much less useful
14:24:19 <glguy_> No, you'd just need to write your cleanup handler to uninterruptibleMask things that needed to block even in the case that the thread was being forcibly killed
14:24:43 <glguy_> That's a design that would work better if it was from the start. I'm not proposing we change to it now
14:25:58 <Peaker> but then you'd still want to wrap all blocking cleanups that way in practice, and then you'd have the "surprise" of blocking kill-threads.. I don't think you'd gain anything
14:31:50 <dfeuer> Ping Cale.
14:44:30 <piko> Hi, how do I convert a Data.ByteString.Lazy.Char8 to a Integer ?
14:44:47 <Guest51529> Nick changed, just saying.
14:46:03 <haskellquestions> can someone telll me why this is throwing me an error?
14:46:14 <haskellquestions> execCode n ts (x:xs) =
14:46:16 <haskellquestions>     | x == '+' = execCode n 5 xs
14:46:27 <haskellquestions> error: parse error on input `|'
14:46:32 <haasn> Guest51529: Data.ByteString.Lazy.Char8 is a module, not a data type. The .Char8 in particular is just a module for a collection of unsafe functions that pretend ByteStrings are ASCII data
14:46:34 <merijn> haskellquestions: Oh, easy :)
14:46:38 <vanila> delete  =  on the first line
14:46:38 <Fuuzetsu> haskellquestions: you have an extra =
14:46:39 <codehero> haskellquestions: remove the '='
14:46:44 <haasn> Guest51529: For parsing binary data, try a parsing library like binary or cereal
14:46:45 <merijn> haskellquestions: Don't write = after your pattern when you use guards
14:46:46 <haskellquestions> oh woops. ok thanks lol
14:46:54 <marchelzo_> Guest51529: readInteger
14:47:25 <merijn> Guest51529: Also, don't use Char8, it makes baby jesus cry and causes kittens to go to hell :<
14:49:02 <droidboi> I import :m +Data.Bool, then try Prelude Data.Bool> bool 1 2 True, but I get "<interactive>:3:1: Not in scope: `bool'". Why is that?
14:49:19 <merijn> droidboi: What's your GHC version?
14:49:20 <jle`> droidboi: what version do you have?
14:49:32 <jle`> try :browse Data.Bool to see if it's in there
14:49:41 <droidboi> 7.6.3
14:49:57 <merijn> droidboi: bool is new in GHC 7.8
14:50:24 <droidboi> merijn: OK
14:50:26 <droidboi> thanks
14:57:02 <Peaker> merijn: when handling Unix paths, I used some Char8 to work with '/', '.', etc -- I'm not sure if there's a nicer way..
14:57:43 <merijn> Peaker: Sure, there's some case where Char8 is convenient IF you know what you're doing and if you feel properly bad for using it
14:57:59 <merijn> But the first step is making people feel properly bad for using it :)
14:58:40 <ARCAEDOC> hello there?
14:58:52 <droidboi> yo
14:59:11 <Peaker> merijn: :)
14:59:14 <ARCAEDOC> hows it gooing ?
15:00:06 <ARCAEDOC> Im quite the beginner to HAskell
15:00:13 <merijn> Peaker: I mean, I'm using it for IsString and ASCII strings in networking protocols so I can just write convenient literals
15:00:57 <ARCAEDOC> Can somebody tell me what commerciql projects haskell is used in
15:00:59 <ARCAEDOC> ?
15:01:29 <Guest51529> How would I iterate though a list of items, to compare each element to <= a constant value and yield only the most recently successful?
15:01:29 <merijn> @google haskell in industry
15:01:30 <lambdabot> https://www.haskell.org/haskellwiki/Haskell_in_industry
15:02:03 <Guest51529> Example, demo 6 [1,2,4,8,16,32] would yield 4.
15:02:30 <Guest51529> I keep trying to wrap my head around it, but it all seems to be pretty involved or like, 3 functions :(
15:03:27 <haskellquestions> why is this throwing me an error? tape = fromList $ take 300 $ repeat 0
15:03:40 <haskellquestions>     No instance for (Num Char) arising from the literal `0'
15:03:46 <merijn> > let test x = listToMaybe . filterBy (<=x) . reverse in test 6 [1,2,4,8,16,32]
15:03:48 <lambdabot>  Not in scope: ‘filterBy’
15:03:48 <lambdabot>  Perhaps you meant one of these:
15:03:48 <lambdabot>    ‘filter’ (imported from Data.List),
15:03:48 <lambdabot>    ‘BSC.filter’ (imported from Data.ByteString.Char8),
15:03:48 <lambdabot>    ‘BSLC.filter’ (imported from Data.ByteString.Lazy.Char8)
15:03:52 <merijn> awww
15:03:53 <marchelzo_> :t fromList
15:03:54 <lambdabot>     Not in scope: ‘fromList’
15:03:54 <lambdabot>     Perhaps you meant one of these:
15:03:54 <lambdabot>       ‘IM.fromList’ (imported from Data.IntMap),
15:03:57 <merijn> oh, duh
15:04:05 <merijn> > let test x = listToMaybe . filter (<=x) . reverse in test 6 [1,2,4,8,16,32]
15:04:06 <lambdabot>  Just 4
15:04:11 <merijn> whoo!
15:04:38 <merijn> haskellquestions: Depends n the type of tape
15:04:45 * Guest51529 sribbles and do run intense tests on merijn's spoon feeding D:
15:04:59 <haskellquestions> merijn: i'm trying to make it a sequence
15:05:17 <merijn> Guest51529: More generally, try and decompose your problem into smaller steps
15:05:27 <haskellquestions> i have this at the top: import Data.Sequence (fromList, index, update)
15:06:16 <merijn> Guest51529: The way I came up with this is: I want the last element that matches a condition -> the first element that matches a condition in the reversed list (getting the first X is usually easier)
15:06:54 <merijn> Guest51529: Next step, after reversing I wanna get rid of everything that DOESN'T match my condition, so I use filter (or dropWhile or something similar)
15:07:02 <marchelzo_> haskellquestions: is tape a top level definition>
15:07:07 <marchelzo_> s/>/?/
15:07:12 <haskellquestions> yeah
15:07:26 <marchelzo_> haskellquestions: did you write a type signature for it?
15:07:27 <merijn> Guest51529: Last step: the first item in the list must now be the last item matching my condition, so use listToMaybe (in case the list is empty!) to grab it
15:07:38 <haskellquestions> oh no i didn't
15:07:39 <merijn> :t repeat
15:07:40 <lambdabot> a -> [a]
15:07:46 <marchelzo_> that's fine you don't need one
15:07:48 <merijn> :t replicate
15:07:50 <lambdabot> Int -> a -> [a]
15:07:53 <merijn> haskellquestions: FYI
15:07:57 <torpet> could someone help me with that error? http://lpaste.net/34780662342877184
15:08:07 <merijn> "take 300 $ repeat 0" == "replicate 300 0"
15:08:15 <torpet> Found hole ‘_’ with type: Label
15:08:22 <haskellquestions> oh yeah i'll change that goo idea
15:08:33 <merijn> torpet: You can't use _ in expressions
15:08:38 <marchelzo_> you need to more from Data.Sequence
15:08:38 <merijn> torpet: It's not a valid variable name
15:08:39 <haskellquestions> alright same error still heh
15:08:44 <marchelzo_> to import*
15:08:57 <haskellquestions> i figured i needed more imports but i wasn't sure which ones. if i import entire thing i get too many conflicts
15:09:14 <marchelzo_> Try this: import qualified Data.Sequence as S
15:09:21 <marchelzo_> change S to whatever you find convenient
15:09:25 <haskellquestions> oh yeah good idea
15:09:30 <marchelzo_> and then prefix anything from that module with S.
15:09:33 <merijn> torpet: If GHC finds a _ (or any variable starting with a _ that is not in scope) it will print a "typed hole" error, that is, it will report a missing expression and tell you what it's type should be
15:10:14 <haskellquestions> ok i did all those changes marchelzo_ and i still have " No instance for (Num Char) arising from the literal `0'"
15:10:33 <merijn> You appear to be creating a Sequence of Char, even though you used 'o'
15:10:37 <merijn> eh, '0'
15:10:46 <haskellquestions> yeah i want 0 and not '0'
15:11:08 <marchelzo_> what exactly do you have in your program?
15:11:10 <torpet> merijn: And how would i fix that?
15:11:14 <merijn> Since 0 is polymorphic (it can be any type that is an instance of Num) and GHC infers that you're trying to use it as Char it complains that Char is not an instance of Num
15:11:14 <torpet> I honestly have no idea?
15:11:19 <merijn> torpet: Give it a proper variable name?
15:11:26 <haskellquestions> i'll just paste my entire program one sec
15:11:33 <merijn> torpet: Call it 'l', 'x' or 'foo' instead of '_'? :)
15:11:58 <torpet> Then I get a not in scope error
15:12:00 <haskellquestions> here you go merijn torpet http://pastebin.com/UesRqEze
15:12:14 <merijn> torpet: Well, you need to use the same variable in your pattern match, obviously
15:12:25 <marchelzo_> haskellquestions: in main, you use it as if it's a Sequence Char
15:12:30 <merijn> torpet: What are you expecing GHC to put in the place where you use '_'?
15:12:55 <haskellquestions> oh ok i got it
15:12:59 <haskellquestions> just needed a $ show in there
15:13:06 <marchelzo_> that works
15:13:16 <merijn> haskellquestions: "putStrLn . show" == "print" :)
15:13:17 <torpet> merijn: well it works if i use the get/set function outside the tcm-method im trying to write
15:13:18 <merijn> :t print
15:13:20 <lambdabot> Show a => a -> IO ()
15:13:24 <haskellquestions> oh ok thanks
15:13:45 <merijn> torpet: '_' is a valid *pattern*, but not a valid *variable*
15:14:00 <merijn> torpet: Writing '_' in a pattern says "I don't care about this value"
15:14:05 <merijn> As a result, you can't refer to it
15:14:21 <merijn> torpet: Your getters/setters are fine since you never try and use '_' on the right hand side
15:14:27 <torpet> wow
15:14:29 <merijn> Which is exactly what _ is for
15:14:30 <torpet> i feel like such an idiot
15:14:31 <haskellquestions> omg i got something to show up ohhh boy
15:14:35 <torpet> it works fine
15:14:38 <merijn> torpet: It's ok :)
15:14:43 <torpet> double facepalm territories
15:14:56 <torpet> thank you!
15:15:12 <merijn> torpet: At least you learned a useful trick if you ever wanna know what type you need to use in a complex expression!
15:16:31 <SvenskFisk> How do I convert from something like IO String to IO Int with read? I tried searching hoogle for something like (m a -> m b) -> m a -> m b, but couldn't find anything, is there something like this?
15:16:51 <marchelzo_> SvenskFisk: IO is a functor
15:17:48 <a3gis> SvenskFisk: your type signature wouldn't make sense though; (m a -> m b) -> m a -> m b would just be applying the function passed as first argument
15:17:49 <torpet> merijn: I guess so. :) So basically the function I've written works, but I want to apply it recursively to a tree data structure "data Tree  = Node (Label -> Label) Label [Tree]"
15:18:00 <merijn> :t fmap read `asAppliedTo` (undefined :: IO String)
15:18:01 <lambdabot> Read b => IO String -> IO b
15:18:07 <jle`> SvenskFisk: looks like you should be looking for an (a -> b) -> (m a -> m b) :)
15:18:17 <torpet> Can you give ma a hint on what to look for to apply it from the leafs up to root?
15:18:24 <jle`> because (m a -> m b) -> (m a -> m b) looks a lot like id ;)
15:18:30 <a3gis> what you want is something like (a -> m b) -> m a -> m b
15:18:39 <SvenskFisk> jle`: Yeah that's what I meant, thanks, still getting used to types haha
15:18:43 <a3gis> https://www.haskell.org/hoogle/?hoogle=%28a+-%3E+m+b%29+-%3E+m+a+-%3E+m+b
15:18:47 <merijn> torpet: You're thinking in the wrong direction :)
15:18:56 <jle`> :t fmap
15:18:56 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:19:04 <jle`> fmap :: (a -> b) -> (f a -> f b)
15:19:23 <merijn> torpet: You'll always start to recurse from the root
15:19:25 <jle`> :t fmap (read :: String -> Int)
15:19:26 <lambdabot> Functor f => f String -> f Int
15:19:28 <a3gis> also you have the "bind" operation on monads
15:19:36 <a3gis> >>= : Monad m => m a -> (a -> m b) -> m b
15:19:37 * hackagebot rainbow 0.20.0.0 - Print text to terminal with colors and effects  http://hackage.haskell.org/package/rainbow-0.20.0.0 (OmariNorman)
15:19:37 <jle`> i'm not sure bind is too useful here
15:19:39 * hackagebot rainbow-tests 0.20.0.0 - Tests and QuickCheck generators to accompany rainbow.  http://hackage.haskell.org/package/rainbow-tests-0.20.0.0 (OmariNorman)
15:19:45 <merijn> torpet: So your root case should first recurse and then return based on the result of your recursion
15:19:47 <jle`> bind can be used but it's a bit overkill
15:19:52 <jle`> and a bit against the spirit of bind i think
15:19:57 <a3gis> jle`: I guess it depends on the function he has to go form IO String to IO Int
15:20:05 <jle`> he has a String -> Int
15:20:07 <a3gis> oh ok
15:20:11 <a3gis> yeah, fmap, sorry
15:20:23 <jle`> if he had a String -> IO Int then, yeah :)
15:20:31 <SvenskFisk> Great, thanks a3gis and jle`!
15:20:41 <merijn> SvenskFisk: Let me also point out that read is evil and if you're using GHC 7.8 (or maybe 7.6?) you should use Text.Read.readMaybe
15:20:50 <merijn> > read "1" :: ()
15:20:51 <lambdabot>  *Exception: Prelude.read: no parse
15:21:02 <merijn> > Text.Read.readMaybe "1" :: Maybe ()
15:21:04 <lambdabot>  Not in scope: ‘Text.Read.readMaybe’
15:21:04 <torpet> merijn: So basically I should always take one Node "away" until I reached the bottom?
15:21:07 <merijn> aww
15:21:10 <merijn> :t readMaybe
15:21:11 <lambdabot> Not in scope: ‘readMaybe’
15:21:19 <merijn> I'm failing hard today :)
15:21:22 <merijn> :t Text.Read.readMaybe
15:21:23 <lambdabot> Read a => String -> Maybe a
15:21:40 <jle`> oh lambdabot you
15:21:41 <merijn> SvenskFisk: read throws an exception if your input is wrong, readMaybe will just return Nothing
15:21:45 <a3gis> > fmap ((*2) . read) ((return "23") :: IO String)
15:21:47 <lambdabot>  <IO Integer>
15:22:18 <merijn> torpet: What exactly are you trying to do?
15:22:30 <merijn> torpet: You wanna apply "Label -> Label" to the leaves first, and then?
15:22:36 <torpet> Apply a function to the labels of a tree
15:22:44 <torpet> to each node
15:23:01 <merijn> torpet: Why do you wanna apply it to the nodes *after* the leaves?
15:23:25 <torpet> no not after
15:23:30 <torpet> just to each node of a tree
15:23:38 <merijn> Well, then it's even easier
15:23:45 <a3gis> torpet: not sure what your problem is, but when working with trees think about the symmetry of the problem
15:23:45 <merijn> torpet: Just recurse from the root
15:23:48 <torpet> but i wrote a function to apply it to leaves because that's basically the end of the recursion
15:24:07 <a3gis> let's say for each node you have (left_tree, value, right_tree)
15:24:23 <merijn> a3gis: He has a rose tree, not a binary tree
15:24:29 <a3gis> oh, ok
15:24:40 <torpet> yup that makes it a bit weirder
15:25:10 <merijn> torpet: It's a fairly consistent problem though, I don't think you even need to distinguish leaves and nodes
15:25:43 <merijn> torpet: To apply it to a node, apply 'f' to the current node's label and replace all children of the current node with children who've had 'f' applied to them
15:26:29 <merijn> torpet: Can you lpaste your current code?
15:26:46 <merijn> I would probably get rid of the getters/setters, btw
15:26:52 <merijn> They just make your code more complex
15:27:03 <merijn> But let's start with what you have
15:27:25 <haskellquestions> is it possible to debug haskell code? i'm getting this infinite loop and i'm not sure why.. here's my code so far http://pastebin.com/fmk2CM2m
15:27:41 <merijn> haskellquestions: Check out the Debug.Trace module
15:27:49 <merijn> haskellquestions: Also, ghci has a debugger, consult the GHC user guide
15:28:15 <ion> execCode n ts (x:xs) | otherwise = execCode n ts (x:xs)
15:28:47 <haskellquestions> ohhhhh
15:28:54 <haskellquestions> i'm doing x:xs instead of xs
15:28:56 <haskellquestions> that'll do it
15:29:06 <haskellquestions> hooray it works now
15:30:02 <marchelzo_> haskellquestions: now add support for , . [ ] :)
15:30:12 <haskellquestions> haha yeah i'm trying to think about how to do looping now..
15:31:50 <marchelzo_> haskellquestions: it complicates things considerably, that's for sure
15:32:00 <haskellquestions> i have an idea for how to do it but it's not gonna be pretty
15:33:47 <torpet> merijn: Sure, http://lpaste.net/3432186676372307968
15:35:06 <merijn> torpet: Ok, so style note first: on line 26 why you first build a new Node and then use getNodeLabel to get its label?
15:35:23 <torpet> wow
15:35:25 <merijn> torpet: You can just use the 'l' you pattern matched on line 25
15:35:45 <torpet> yeah haha
15:35:55 <merijn> Second note "x == True" is identical to "x" :)
15:36:40 <torpet> Thanks lpaste told me that :S
15:36:41 <torpet> :D
15:36:45 <torpet> already fixed
15:36:51 <jle`> @check \x -> (x == True) == x
15:36:53 <lambdabot>  +++ OK, passed 100 tests.
15:36:56 <jle`> well would you look at that
15:37:04 <merijn> torpet: Third one, one line 26 you construct a new Node and proceed to apply setNodeLabel to it?
15:37:09 <vanila> > (\x -> (x == True) == x) False
15:37:10 <lambdabot>  True
15:37:48 <torpet> Basically i modify an existing Node
15:37:59 <torpet> you mean I could just create a new one and return it instead?
15:38:19 <merijn> torpet: You can't modify existing nodes
15:38:23 <jle`> @check \x -> (x == True) ==> x
15:38:24 <lambdabot>  +++ OK, passed 100 tests.
15:38:25 <merijn> torpet: Everything is immutable in haskell
15:38:41 <merijn> torpet: You're constructing a new node and then using "setNodeLabel" to create yet another node :)
15:39:01 <merijn> torpet: setNodeLabel is just taking a node as input and returning a new node
15:40:35 <lpaste> merijn annotated “No title” with “Simplified rose tree” at http://lpaste.net/3432186676372307968#a114822
15:40:48 <merijn> torpet: So that code is basically identical to your old code
15:41:02 <merijn> btw, did you mean to apply 'f' to 'l' on line 10?
15:41:23 <torpet> http://lpaste.net/4901464631505059840
15:41:27 <heliochrome> Anybody here familiar with leksah? Seems the #leksah channel is dead
15:41:56 <merijn> ok, so you didn't mean to apply 'f' to 'l' on line 10 :)
15:42:02 <torpet> yup, either or
15:42:11 <torpet> its a "conditional tree" or something like that?
15:42:15 <haskellquestions> heliochrome: i tried it and it seemed too heavy so i'm using notepad++ instead now heh
15:42:53 <merijn> torpet: Right, so starting with http://lpaste.net/114822 we have to tackle the following: Suppose the list is not empty, we need to perform this substitution on every node in it, right?
15:43:11 <heliochrome> haskellquestions: Yeah, I was trying sublime, but I was sort of hoping leksah would just work and let me avoid tooling questions to actually figure out the language instead
15:43:13 <athan> Hey folks, can someone tell me why lines 11 and 14 have conflicting instances with my functional dependency? http://lpaste.net/114821 Thank you!!
15:43:13 <merijn> torpet: So ponder what sort of function would help here :)
15:43:26 <torpet> map? ^^^
15:43:32 <merijn> torpet: Right
15:43:42 <heliochrome> haskellquestions: but the "Package -> New" thing that their welcome instructions tell me to do doesn't even work, so not sure what gives
15:43:44 <torpet> oh so i map f2 or f to each node?
15:44:21 <haskellquestions> heliochrome: yeah i was having so much trouble with sublime and leksah now i'm just using notepad++ and it works really well. just hit control+f6 and it actually runs the haskell program in the output console of notepad++ so no separate windows and such
15:44:26 <merijn> torpet: Well, you still need the logic to decide when to apply f and when to apply f2, right?
15:44:35 <merijn> torpet: Also, what if the nodes in the list also have children?
15:45:19 <heliochrome> haskellquestions: does it let you use stuff like getLine? My problem with haskell was that its "build" feature doesn't deal with asking for input
15:45:38 <haskellquestions> hmmm i haven't tried getLine let me check for you
15:45:51 <merijn> torpet: If only there was a function that would check whether to apply f2 or not and knew how to deal with the children of a node...
15:46:23 <heliochrome> haskellquestions: (on the other hand, I might just be using getline wrong... but IIRC it was the same deal with python's raw_input in sublimetext)
15:46:37 <haskellquestions> heliochrome: yeah getLine works just fine!
15:46:49 <heliochrome> haskellquestions: Thanks, you're awesome!
15:47:08 <haskellquestions> if you want to use notepad++ just download nppexec and drag the plugin to the plugs folder heliochrome
15:47:12 <heliochrome> haskellquestions: One more question, does it do bird style .lhs files? I couldn't make sublimetext syntax highlight those right
15:47:37 <haskellquestions> oh i don't know i've just been using default syntax highlighting
15:47:44 <heliochrome> w/e I'll try it out and see
15:47:46 <haskellquestions> notepad++ has a haskell template by default and you can customize it
15:47:48 <heliochrome> thanks a bunch!
15:48:23 <haskellquestions> heliochrome: once you have it installed you go to plugins -> nppexec -> execute and type "runhaskell test.hs" (fill in test.hs with filename)
15:48:25 <torpet> merijn: Sorry, was afk for few mins. So yeah you are right, decision logic is missing, and unlimited nodes are possible.
15:48:31 <haskellquestions> then after that control + f6 runs it automatically
15:48:45 <merijn> torpet: Think a bit on whether a function like the one I described exists :)
15:49:33 <dfeuer> Cale++
15:50:18 <dfeuer> That's where I let lambdabot know that I'm starting to see just how good Cale's idea yesterday was.
15:50:27 <torpet> filter and map together probably
15:50:35 <heliochrome> Haha, notepad++ has an option in the installer to "Use the old, obsolete and monstrous icon"
15:50:42 <heliochrome> "I won't blame you if you want to get the old icon bacK"
15:50:52 <merijn> torpet: Stare at your paste :)
15:52:15 <torpet> guards?
15:52:24 <merijn> torpet: What's tcm doing?
15:52:33 <torpet> exactly that
15:52:34 <torpet> :D
15:52:48 <torpet> map tcm to Nodes
15:52:49 <merijn> torpet: Right, so you just want to apply tcm to all children in your list
15:54:38 * hackagebot hyperloglog 0.3 - An approximate streaming (constant space) unique object counter  http://hackage.haskell.org/package/hyperloglog-0.3 (EdwardKmett)
16:00:26 <zuserm> Hello, folks. Does anyone know if data T = T {-# UNPACK #-} !Int {-# UNPACK #-} !Int takes up two words or three in memory?
16:00:44 <merijn> Probably more
16:00:52 <merijn> It depends on how it compiles
16:01:10 <merijn> There's an info table and struct layout data which may or may not be optimised away
16:02:34 <dfeuer> Fffff
16:02:46 <heatsink> Usually that's static and slared for all Ts
16:03:14 <heatsink> 3 + ε words
16:03:15 <merijn> heatsink: Ah, true
16:03:50 <heatsink> Oh, you mentioned you've used embedded gpu languages?
16:04:01 <merijn> heatsink: Not a lot
16:04:17 <merijn> heatsink: Well, depends what you mean by "embedded gpu languages"
16:04:30 <merijn> Do you mean "(E)DSL for GPU languages" or "OpenCL/CUDA"
16:04:32 <zuserm> thanks
16:04:49 <heatsink> Like Delite with GPU backends, or Accelerate, or Nikola
16:04:56 <merijn> A little
16:05:10 <merijn> Cursory glance at the literature suggests the performance of all of them sucks
16:06:41 <merijn> If you're looking for raw throughput I would recommend just using CUDA
16:07:20 <heatsink> How can you tell?  A lot of papers compare to a reference implementation that doesn't tell you much about efficiency.
16:07:35 <heatsink> Like GPU versus sequential Scala
16:08:33 <merijn> Just by comparing theoretical peak performance to obtained performance
16:08:40 <heatsink> Oh, I see
16:08:51 <merijn> But yes, most papers are lousy and use terrible baselines
16:09:06 <heatsink> I might be looking into functional GPU programming for HPC in a few months
16:09:33 <merijn> tbh, I don't think functional (especially lazy) will work on GPU
16:09:50 <merijn> And by that I mean "I'm about 90% sure"
16:10:18 <heatsink> How come?
16:10:45 <merijn> The fundamental design of GPUs fits very poorly with the evaluation model of functional languages
16:11:15 <Adamant> the lots of vectors part, or what?
16:11:23 <merijn> to become a good fit for the GPU the GPU would have to change so substantially they're no longer GPUs
16:11:36 <merijn> Adamant: No, also the way the cores are pipelined and memory accesses work
16:11:39 <heatsink> EDSLs have typically incoporated their own evaluation rules though
16:11:56 <Adamant> ah
16:12:11 <merijn> heatsink: I'm not saying you can write a good DSL for the GPU, but it'll most likely be data parallel/dataflow rather than functional
16:12:21 <heatsink> Sure
16:12:27 <merijn> Those are pure too, but hardly functional
16:12:52 <heatsink> The functional part is for programming abstractions on top of the data parallel constructs
16:13:07 <merijn> I think GPUs are a dead end anyway for anything other than straight up embarassingly parallel problems
16:13:48 <merijn> I think accelerators like the Xeon Phi are more promising
16:14:20 <Adamant> is it like the SPU’s for the Cells?
16:15:03 <heatsink> It's hard to tell, since most research looks at individual data-parallel algorithms
16:15:32 <heatsink> So there just isn't much attention on highly parallel algorithms outside of what GPUs are good at
16:15:40 <merijn> Sure there is
16:15:49 <merijn> All those wankers publishing graph processing on GPU
16:16:07 <merijn> It's all basically useless to the point of bordering on fraud, but hey...
16:17:06 <heliochrome> haskellquestions, giving up on NppExec I think
16:17:19 <heliochrome> it's putting things in the wrong order :\
16:17:24 <haskellquestions> really?
16:17:25 <heliochrome> When they work fine with runhaskell
16:17:26 <heliochrome> Yeah
16:17:42 <haskellquestions> you're not using runhaskell to run it?
16:17:53 <heliochrome> The "What is 2+2" function from here https://www.haskell.org/haskellwiki/Learn_Haskell_in_10_minutes
16:18:03 <haskellquestions> in the execute window "runhaskell test.hs"
16:18:05 <heliochrome> Yeah
16:18:17 <heliochrome> It should print "What is 2+2?" then ask for input
16:18:28 <heliochrome> but instead it waits for input, then only prints after I've given it something
16:19:15 <heliochrome> haskellquestions http://i.imgur.com/2d47lyA.png
16:19:16 <haskellquestions> hmm lemme check
16:20:02 <haskellquestions> which code example on the page are you using?
16:20:08 <haskellquestions> there's a couple of them that do the 2+2 thing
16:20:27 <heliochrome> haskellquestions but if I just use runhaskell from cmd it works fine http://i.imgur.com/tGsMLOg.png
16:20:38 <haskellquestions> oh nevermind they're both the same
16:20:45 <haskellquestions> ok i'll try it on my end and see what happens one sec
16:21:06 <heliochrome> Copied and pasted it from below "6 Function definitions"
16:23:21 <haskellquestions> heliochrome i think i might know why.. one sec
16:23:24 <haskellquestions> should be easy fix
16:26:18 <haskellquestions> hooray!
16:26:22 <haskellquestions> i figuerd it out heliochrome
16:26:26 <haskellquestions> i'll pastebin it for you
16:26:47 <haskellquestions> http://pastebin.com/SsM7cm9K
16:27:41 <heliochrome> hm, could you explain what that's doing?
16:28:47 <heliochrome> is NppExec running it with a different buffermode by default or something?
16:29:12 <haskellquestions> haha i'm not sure i'm a noob really i just googled and that came up. but yeah probably a different buffermode by default yea
16:29:34 <heliochrome> I might just stick with using runhaskell manually anyway
16:29:50 <heliochrome> rather than worry about whether NppExec is running something differently than it should
16:29:57 <heliochrome> until I have a better grip on what I'm doing here
16:30:00 <heliochrome> But thanks for the help!
16:30:05 <haskellquestions> yeah whatever works for you np have fun
16:30:08 <marchelzo_> When you run it in np++, does it open a terminal, or is there an output window built in to the notepad?
16:30:17 <heliochrome> Output built in to the nodepad
16:30:50 <heliochrome> For whatever reason it's waiting for me to give it input before it gets to asking me for the input
16:31:09 <heliochrome> unless I set LineBuffering first like haskellquestions suggests
16:41:05 <joejev> I am trying to get some code to run concurrently; however, when timing my program, it feels like it must not all be running at the same time as it is no faster.
16:41:48 <joejev> I am using Control.Concurrent.Async.mapConcurrently to map a function that creates a process over a list of filenames and returns a list of their stdout/stderr/exitstatus
16:42:09 <merijn> joejev: Are you compiling with the threaded runtime and specifying more than 1 thread? :)
16:42:44 <joejev> I compiled with -threaded (in the .cabal); however, where do I specify more than 1 thread
16:42:54 <haskellquestions> hmmmm i have no idea why this isn't working..
16:43:04 <dmj`> joejev: dist/build/app/app +RTS -N -RTS
16:43:13 <dmj`> -N means use all available cores
16:43:18 <haskellquestions> am i missing something in this guard? "| codePos >= length xs = ts"
16:43:19 <dmj`> rts == runtime system
16:43:25 <haskellquestions>   Couldn't match expected type `[Char]' with actual type `Int'
16:43:38 <haskellquestions> codePos is just a number and xs is just a list
16:43:48 <joejev> dmj`: Thanks, is there a way to make this default at compile time?
16:44:10 <merijn> joejev: Yeah, there's a GHC_OPTIONS pragma
16:44:20 <dmj`> joejev: yes you can specify in your cabal file, under ghc-options: -threaded -rtsopts
16:44:21 <merijn> joejev: Consult GHC user guide :)
16:44:46 <dmj`> you'll always have to do -N though when running to get it to take advantage of multi core
16:44:51 <joejev> merijn, dmj`: Thannks!
16:44:52 <dmj`> IIRC
16:45:07 <merijn> joejev: See also: http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Concurrent.html#v:setNumCapabilities
16:45:10 <merijn> dmj`: No
16:45:13 <dmj`> joejev: it allocates threads round robin
16:45:31 <merijn> dmj`: You can use GHC_OPTIONS to make -N the default at compile time and/or use setNumCapabilities
16:45:52 <dmj`> merijn: cool
16:48:47 <torpet> merijn: http://lpaste.net/8294229241881427968
16:48:56 <torpet> Line 5 tells me I need Tree instead of [Tree]
16:49:10 <torpet> Which i don't understand because t is of type [Tree], right?
16:49:36 <merijn> torpet: What does "map (tcm f1 f2) t" return?
16:49:49 <haskellquestions> anyone ever gotten this error? "Prelude.(!!): index too large" not sure what to do that's all it tells me
16:49:51 <torpet> Multiple trees
16:49:59 <merijn> torpet: [Tree]
16:50:02 <haskellquestions> how would it even know that.. it didn't even compile lol
16:50:09 <merijn> torpet: And what is "tcm f1 f2 (Node f l t) = map (tcm f1 f2) t" supposed to return?
16:50:17 <torpet> Oh ok...
16:50:26 <merijn> haskellquestions: It means you're using !! with an index that's too large?
16:50:29 <torpet> Tree instead of [Tree]
16:50:47 <merijn> torpet: Note that you also didn't update the label of your input node on line 5
16:50:50 <haskellquestions> it lies!
16:52:36 <haskellquestions> the index i'm using is probably 0.. how is that too large
16:52:49 <merijn> "probably"?
16:53:02 <marchelzo_> and 0 could be too large if your list is []
16:53:03 <haskellquestions> well it's not compiling.. here i'll pastebin what i have maybe you can decipher it
16:53:26 <haskellquestions> http://pastebin.com/93Q2ia2U
16:53:40 <merijn> torpet: Figured out how to solve it yet? :)
16:53:43 <haskellquestions> line 19 is throwing the error
16:54:40 * hackagebot kdt 0.2.2 - Fast and flexible k-d trees for various types of point queries.  http://hackage.haskell.org/package/kdt-0.2.2 (giogadi)
16:56:35 <RchrdB> haskellquestions: the code that you pastebinned there *does* load in ghci for me.
16:56:47 <haskellquestions> !
16:56:48 <marchelzo_> haskellquestions: move the case where codePos >= lenth xs to the top
16:57:06 <haskellquestions> oh there we go that worked why is that?
16:57:14 <haskellquestions> oh wait
16:57:19 <haskellquestions> yeah that does make sense on second thought
16:57:21 <haskellquestions> good catch thanks
17:03:08 <bgamari> Anyone know what is going on here?
17:03:09 <bgamari> Test.hs:66:14:
17:03:09 <bgamari>     No instance for (Data.Functor.Classes.Show1 LifetimeParams)
17:03:09 <bgamari>       arising from a use of ‘print’
17:03:28 * Clint squints.
17:03:35 <bgamari> Looking at the definition of `Show` (which is what `print` uses) I don't see any constraint requiring Show1
17:03:53 <merijn> bgamari: Show1 sounds like something Genericsy
17:03:56 <glguy_> Presumably one of the Show instances you're trying to use requires a Show1 constraint
17:04:11 <bgamari> glguy_, I guess so, I just have no idea why
17:04:28 <bgamari> now that I think of it, I have no idea what sort of code `deriving (Show)` produces
17:04:45 <merijn> bgamari: Easy enough to check using one of the -ddump flags :)
17:04:57 <bgamari> yep, I guess it's time to find out
17:05:11 <glguy_> None of the "deriving Show" instances will use Show1 directly
17:05:21 <glguy_> What's the type?
17:06:39 <houshuang> Is Template Haskell supposed to work in ghci? If I do makeLenses ''Person, I get cannot show etc. If I do let k = makeLenses... I get a variable of type Language.Haskell.TH.Lib.DecsQ ... but I guess what I want is to execute this value, not store it?
17:06:41 <bgamari> data Type a = Type a a deriving (Show, ..., Generic1)
17:06:44 <bgamari> glguy_, ^
17:06:50 <houshuang> (I enabled :set -XTemplateHaskell)
17:07:05 <haskellquestions> what's a good way, given a list and a starting index, to find the closest index that is a certain element?
17:07:12 <glguy_> houshuang: No, you can't use TemplateHaskell to generate code in GHCi afaik
17:07:13 <bgamari> houshuang, you may need to use $(makeLenses ''Person)
17:07:19 <bgamari> alright, or that
17:07:35 <vanila> haskellquestions, you could 'zip' to that index then search both lists in parallel
17:07:47 <haskellquestions> both lists? just one
17:07:50 <haskellquestions> oh wait
17:07:51 <haskellquestions> with zip
17:08:04 <vanila> by zip to an index I mean, given "abcoxyz" zip to 3 would give ("oxyz","cba")
17:08:08 <haskellquestions> oh sorry my question was wrong. i only want to serach in one direciton
17:08:12 <vanila> oh okay
17:08:25 <vanila> in that case you can do the same thing but only search one of those two lists
17:08:34 <glguy_> bgamari: Could you put a paste of some code that doesn't quite work? Prelude GHC.Generics> data Type a = Type a a deriving (Show, Generic1)
17:08:35 <glguy_> Prelude GHC.Generics> show (Type True False)  ===>  "Type True False"
17:09:01 <houshuang> bgamari: glguy_: OK, that's useful to know, although it is quite sad.
17:09:52 <bgamari> glguy, yeah, trying to get it down to a minimal case right now
17:11:06 <glguy> http://hackage.haskell.org/package/transformers-0.4.2.0/docs/Data-Functor-Classes.html
17:12:41 <glguy> The Show instances for things like Product require Show1 constraints on the functor arguments
17:13:24 <bgamari> glguy, ahh, that would likely do it
17:13:28 <bgamari> Indeed I have a Product
17:13:33 <bgamari> I should have caught that
17:13:37 <bgamari> glguy, thanks!
17:14:11 <bgamari> I do wish that GHC would tell you a bit more about where constraints come from
17:14:43 <torpet> merijn: Yup
17:15:07 <torpet> Just needed to use a constructor with function and label
17:15:10 <merijn> torpet: Now, there's one more simplification to make :)
17:15:26 <torpet> I'm all ears
17:15:31 <merijn> torpet: You can actually handle the case of a leaf node and a non-leaf node with a single clause
17:15:32 <metamp> what's the best editor for haskell
17:15:42 <merijn> metamp: The one you're already comfortable with
17:16:03 <bgamari> metamp, lots of folks use emacs, I used to use vim before switching to emacs, notepad would work I suppose ;)
17:16:09 <glguy> Unless the one you're comfortable with is Notepad
17:16:31 <torpet> merijn: Any hints on how to achieve that?
17:16:34 <merijn> torpet: Right now your first clause matches on an empty list in the Node, can you see how you could remove that distinction?
17:17:07 <merijn> torpet: i.e. what if you had "tcm f1 f2 (Node f l children) = ??"
17:17:08 <metamp> I tried emacs
17:17:17 <metamp> the learning curve is too long
17:17:36 <metamp> I gues I'll use vim
17:17:54 <glguy> because you want to experience a longer learning curve?
17:17:56 <merijn> metamp: If you're already comfortable with vim, then yes. Plenty of people use vim
17:18:32 <glguy> I use vim for everything which just happens to included haskell (agda excluded)
17:18:45 <metamp> I like IDEs
17:18:50 <metamp> like eclipse
17:19:53 <glguy> This exists: http://eclipsefp.github.io I don't know anyone who uses eclipse for Haskell dev, though
17:20:00 <dmj`> metamp: fpcomplete has a web based ide, like http://c9.io
17:20:20 <dmj`> https://www.fpcomplete.com/business/haskell-center/overview/
17:20:27 <torpet> merijn: I'd still need to check somehow when to end the recursion right?
17:20:58 <merijn> torpet: Well, what does "map f []" return?
17:21:00 <marchelzo_> bgamari: do you use evil mode?
17:21:08 <bgamari> marchelzo_, I do
17:21:30 <marchelzo_> bgamari: what drew you to emacs?
17:21:39 <bgamari> marchelzo_, Although I've gradually picked up emacs-isms as well
17:21:54 <bgamari> marchelzo_, vimscript is just a disaster
17:21:58 <torpet> merijn: Empty list
17:22:07 <bgamari> marchelzo_, indentation of haskell in particular was quite painful
17:22:11 <marchelzo_> I really don't see how elips is any better
17:22:15 <marchelzo_> elisp*
17:22:18 <merijn> torpet: Right, so what does "map (tcm f1 f2) []" end up doing?
17:22:18 <metamp> thx dmj
17:22:39 <torpet> Oh it doesn't recurse further
17:22:41 <torpet> :D
17:22:52 <bgamari> marchelzo_, meh, I've frankly not written very much elisp; that being said other people seem to do quite nice things with it
17:23:02 <bgamari> marchelzo_, helm and projectile are nice examples
17:23:07 <marchelzo_> I mean I like the idea of extending emacs with lisp, but where are you supposed to learn all of builtin functions? The elisp part of manual is just a guide to lisp in general (goes on and on about different data types, etc.)
17:23:58 <marchelzo_> If I had a solid grasp of elisp, I'd definitely use emacs, but I can't stand its defaults and I don't know enough to change them.
17:23:59 <bgamari> marchelzo_, I had also used emacs for notmuch for several years so it seemed natural to try switching entirely
17:24:56 <bgamari> marchelzo_, You can do a lot with the customization interface
17:25:28 <bgamari> marchelzo_, and there are enough examples of mostly sane emacs online that it's pretty easy to piece together your own in time
17:25:39 <bgamari> s/emacs/emacs configurations/
17:29:15 <Welkin> marchelzo_: it is really easy to customize emacs; you don't need to know emacslisp
17:29:34 <Welkin> just search for what you want to do on the emacs wiki
17:29:40 <Welkin> they have guides on everything
17:32:15 <haskellquestions> how do i get rid of maybe stuff
17:32:24 <Welkin> ?
17:32:34 <Welkin> how do you extract a value from a maybe?
17:32:34 <haskellquestions> i wrote this function but it says i can't do math with a maybe int and a regular int
17:32:34 <haskellquestions> findPrevIndex index xs = index - (elemIndex '[' . reverse . take (index + 1) $ xs)
17:32:37 <haskellquestions> yeah that's it
17:32:45 <Welkin> pattern match on it
17:33:07 <haskellquestions> how would i do that in the code i pasted?
17:33:09 <benmachine> haskellquestions: you gotta work out what to do when there isn't an '[' in there
17:33:23 <haskellquestions> can't i just assume it's found?
17:33:33 <benmachine> you *can*
17:33:44 <benmachine> but it's kind of bad style
17:33:49 <haskellquestions> because if it isn't found the program is in an undetermined state so it's broken anyway
17:34:09 <benmachine> right, ideally you'd write the program in such a way that that was obviously impossible
17:34:21 <benmachine> are you writing a brainfuck interpreter by any chance
17:34:24 <haskellquestions> yeah
17:34:38 <benmachine> what happens when I use a program that looks like ">>++]"
17:34:45 <haskellquestions> if it doesn't find the previous bracket then the input code isn't correct so i don't mind if it crashes or whatever
17:34:46 <Welkin> haskellquestions: break down what you want to do into a pipeline of functions
17:35:02 <haskellquestions> i'm not sure what you mean
17:35:15 <Welkin> haskellquestions: avoid writing tightly coupled (deeply nested) function definitions
17:35:25 <haskellquestions> oh lol don't worry about that
17:35:42 <Welkin> haskellquestions: think of it like a factory: what needs to happen each step of the way during the processing?
17:35:46 <haskellquestions> i'm not writing this code to be clean or well-architectured i just started learning haskell a couple days ago
17:35:52 <haskellquestions> just trying to get stuff working atm
17:36:00 <Welkin> haskellquestions: that is not how you approach haskell
17:36:09 <benmachine> Welkin: don't be prescriptive about this
17:36:33 <benmachine> it's one thing to say "you could do this another way" but saying "you can't do it this way" is both false and not too helpful
17:36:49 <Welkin> haskellquestions: you need to understand the types in order to write functioning programs
17:36:54 <haskellquestions> i'm sure there's much better ways to do it but i'm not at that level yet
17:37:41 <benmachine> haskellquestions: the very simple and slightly icky way to do it would be to write a function like elemIndex only instead of returning Just ix it returns ix and instead of returning Nothing it calls the error function
17:37:51 <benmachine> with some helpful message, if possible
17:37:59 <haskellquestions> yeah that's exactly what i want
17:38:20 <haskellquestions> oh that's a good idea i'll write a wrapper for elemindex
17:40:30 <jmcarthur> haskellquestions: i'll give you the direct answer to your question, but i also want to echo the advice that this isn't great style
17:40:33 <jmcarthur> :t fromJust
17:40:34 <lambdabot> Maybe a -> a
17:40:37 <jmcarthur> ^^
17:40:39 <haskellquestions> o there we go
17:40:42 <haskellquestions> that's even better
17:40:47 <jmcarthur> s/better/worse/
17:41:19 <vanila> You could do a first pass over the code to mark each ']' character with an index to jump back to
17:41:28 <merijn> argh
17:41:39 <merijn> fromJust is awful
17:41:42 <merijn> Don't use it >.<
17:41:50 <merijn> Use maybe or fromMaybe
17:41:57 <haskellquestions> i don't knwo any better help
17:42:02 <merijn> :t maybe
17:42:03 <lambdabot> b -> (a -> b) -> Maybe a -> b
17:42:06 <merijn> :t fromMaybe
17:42:07 <lambdabot> a -> Maybe a -> a
17:42:13 <glguy> Or even just a partial pattern match so you get a helpful exception ^_^
17:42:36 <jmcarthur> yeah, everybody has already suggested all the good stuff
17:42:37 <haskellquestions> how would i do a partial pattern match for this? findPrevIndex index xs = index - (elemIndex '[' . reverse . take (index + 1) $ xs)
17:42:45 <haasn> ... = index - foo where Just foo = ..calculation..
17:42:54 <haasn> ^
17:42:56 <vanila> another way is to make an abstract syntax tree like:  type BFT = [BFN] ; data BFN = BFTree BFT | BFOp Char
17:42:56 <haskellquestions> ah the where
17:43:08 <haasn> haskellquestions: alternatively (let Just foo = calc in foo)
17:43:19 <vanila> then parse the string into that data type and interpret it more easily than jumping around with list indices
17:43:37 <jmcarthur> i personally would convert the Maybe to an Either Error and use fmap, bind, etc., but i don't think i have the patience for explaining how that works right now
17:44:05 <haskellquestions> oh yeah don't worry about it i'll just use the let for now
17:44:08 <haasn> https://github.com/ekmett/zippers/blob/master/examples/BrainfuckFinal.hs here's how I would write brainfuck! :)
17:44:23 <jmcarthur> ugh, not me
17:44:41 <jmcarthur> but i just opened an editor to implement a brainfuck interpreter, so we'll see how this goes
17:45:19 <Cale> dfeuer: Did it work out well?
17:45:24 <Welkin> vanila's suggestion is the proper way to do it, if this is for a parser
17:45:26 <dfeuer> Cale, not yet.
17:45:32 <dfeuer> I'm still struggling.
17:45:34 <vanila> i could post mine bit its in brainfuck hnot haskell
17:45:46 <marchelzo_> jmcarthur: which editor? :)
17:46:13 <jmcarthur> marchelzo_: is this on topic somehow?
17:46:26 <dfeuer> Cale, I'm actually thinking about it right now, so you're welcome to help.
17:46:52 <marchelzo_> jmcarthur: not strictly, no. But we were discussing editors a little while ago for Haskell
17:47:23 <Welkin> marchelzo_: religious wars? or text editors *written* in haskell?
17:48:53 <marchelzo_> Fortunately not the former, but unfortunately not the latter, either.
18:00:03 <haskellquestions> oh boy got looping working
18:00:40 <NemesisD> have you folks worked with the various FRP libraries? I have it on my list to look into them for general purpose FRP (i.e. non gui) and theres a lot of choices
18:00:58 <haskellquestions> pick one named after a fruit is all i know
18:00:59 <merijn> NemesisD: I would recommend netwire for non-gui work
18:01:18 <NemesisD> how does it compare with sodium and reactive-banan
18:01:22 <NemesisD> banana*
18:01:33 <merijn> Well, at least the old netwire was pretty convenient and I think netwire 5 finally is "proper FRP"
18:01:54 <houshuang> In this example -- x = hLens' (Label :: Label "x") -- is there a way to get the "x" in label from a string variable without using Template Haskell?
18:02:09 <merijn> NemesisD: sodium/reactive-banana were designed for GUI/existing framework interaction, netwire more for networking/game engines
18:02:30 <haskellquestions> merijn: i got 6 of the 8 commands working. any advice for the last 2? here's what i got so far: http://pastebin.com/hpmgMxw0
18:03:01 <NemesisD> merijn: so is it a performance thing or maybe they are too specific? the thing I'm interested in working on is for processing timeseries-like data efficiently with all the nice composition of FRP
18:03:30 <merijn> NemesisD: It's an API design thing
18:05:03 <dfeuer> Cale, I think it did pan out, actually.
18:05:20 <dfeuer> I'm not entirely sure though, because I haven't actually analyzed it.
18:05:43 <dfeuer> Actually I think I did something wrong. Let me see if i can fix that real quick.
18:08:28 <marchelzo_> haskellquestions: the last 2 being ',' and '.'?
18:08:35 <haskellquestions> yeah
18:08:52 <haskellquestions> not sure how to do that part..
18:09:07 <marchelzo_> you could wrap the whole thing in IO or use something unsafe
18:09:22 <hughfdjackson> is there a way to append to a list-like construct *without* forcing the evaluation of all of the elements?
18:09:45 * mauris sings the don't-tell-beginners-about-unsafePerformIO song
18:11:15 <merijn> The problem I have is that GHC upstream deleted the libraries/haskell2010 submodule and when I check out an older revision I can't build due to a missing submodule >.<
18:11:37 <heatsink> You can use append-lists, which have type [a] -> [a]
18:11:56 <hughfdjackson> heatsink: great :) I'll have a little looksee
18:11:57 <hughfdjackson> thanks
18:12:12 <heatsink> append xs x = xs . (x:)
18:13:05 <centrinia> :t \xs x -> xs . (x:)
18:13:06 <lambdabot> ([a] -> c) -> a -> [a] -> c
18:15:49 <heatsink> > let appl xs x = xs . (x:) in let toList xs = xs [] in toList $ appl ([1,2] ++) 5
18:15:51 <lambdabot>  [1,2,5]
18:22:25 <Hijiri> when you derive Enum for an ADT, is it guaranteed to start with 0 at the first constructor?
18:22:51 <Hijiri> @let data Foo = Foo | Bar | Baz deriving (Enum)
18:22:52 <lambdabot>  .L.hs:173:1:
18:22:52 <lambdabot>      Multiple declarations of ‘Foo’
18:22:52 <lambdabot>      Declared at: .L.hs:154:1
18:22:52 <lambdabot>                   .L.hs:173:1
18:22:52 <lambdabot>  
18:22:55 <Hijiri> @undefine
18:22:56 <lambdabot> Undefined.
18:22:57 <Hijiri> @let data Foo = Foo | Bar | Baz deriving (Enum)
18:22:59 <lambdabot>  Defined.
18:23:07 <Hijiri> fromEnum Foo
18:23:09 <Hijiri> > fromEnum Foo
18:23:11 <lambdabot>  0
18:23:22 <Hijiri> well I have one data point, that's good enough
18:24:04 <HeladoDeBrownie> Hijiri, yes https://www.haskell.org/onlinereport/haskell2010/haskellch11.html#x18-18400011.2
18:24:30 <dfeuer> Cale, I think I'm having a laziness problem-- mappend for Seq is a little too strict for what I need. I *think* that can be fixed.
18:24:34 <Hijiri> HeladoDeBrownie: thanks
18:25:29 <dfeuer> But I'm not sure.
18:26:33 <heatsink> mappend should depend on how elements were put into the input sequences, but not the elements' values.
18:31:27 <dfeuer> heatsink, no, I misidentified the problem.
18:33:36 <Hijiri> do I need to add Setup.hs to version control?
18:38:28 <bitraten> I have a problem, where the same Exception sometimes gets caught and sometimes not (see ghci output): https://gist.github.com/bitraten/e0ef766955b59bf462e3
18:38:39 <heatsink> Everything that you need to make a working copy of a project's source code should be in the repository, Hijiri
18:39:19 <heatsink> the cabal program expects Setup.hs to be there
18:43:13 <Hijiri> alright
18:43:24 <Hijiri> just wasn't sure if it will generate a default one or somethign
18:45:45 <merijn> Right, I promised some people here a minimal "how to hack GHC" quick start guide, if anyone's interested in proofreading: https://gist.github.com/merijn/f79fd37f8197fc05f088 lemme know if there's any problems or places where it needs clarification
18:51:16 <solatis> ehrm
18:51:20 <solatis> this might sound stupid
18:51:25 <solatis> but i have an MVar ()
18:51:48 <solatis> and a function signature of MVar a
18:51:51 <solatis> what is the type of a ?
18:51:53 <solatis> () ?
18:52:01 <heatsink> merijn: I suggest describing how to speed up the cycle of editing source, rebuilding, and testing.  How to rebuild only the last phase of the compiler and how to run the in-place compiler.
18:52:05 <solatis> specificlaly, look at this:
18:52:07 <solatis> thMVar :: MVar a -> (a -> IO b) -> IO b
18:52:16 <solatis> what is a ?
18:52:27 <solatis> when my MVar is of type MVar () ?
18:52:48 <solatis> sorry i'll move to #haskell-beginners, it's more appropriate there
18:52:49 <merijn> solatis: ()
18:53:07 <merijn> heatsink: Wait, there's a way to only rebuild the last phase? :p
18:53:08 <solatis> merijn: so my function signature would look like () -> IO () ?
18:53:21 <heatsink> Yeah, it's on the GHC wiki somewhere
18:53:21 <merijn> solatis: Well, "() -> IO whatever", but yes
18:53:31 <merijn> heatsink: I just run "make -j" each time
18:53:32 <solatis> didn't expect that to be legal
18:53:34 <merijn> >.>
18:53:35 <solatis> thanks
18:54:08 <merijn> heatsink: Ah, good idea about how to run the in-place compiler, personally I just run make install and run it from $HOME/ghc-head
18:54:49 <dfeuer> heatsink, no, I didn't misidentify the problem. I have a laziness problem, and fixing it will probably be hard.
18:54:54 <heatsink> merijn: How to make stage 2 https://ghc.haskell.org/trac/ghc/wiki/Building/Using#RebuildingtheGHCbinaryaftermakingchanges
18:55:34 <heatsink> Admitting it is the first step.
18:58:09 <dfeuer> heatsink, the trouble, I think, is that  s1 >< undefined >< s2 = undefined, even though it could be otherwise. This causes a substantial efficiency problem. Fixing it probably requires digging deep into the FingerTree type, which I don't understand deeply enough and which is tricky.
18:59:30 <heatsink> dfeuer, Seq operations examines the length of subsequences to maintain its data structures.
19:00:17 <heatsink> If you need to support sequences with undefined subsequences, I would make a new data structure
19:00:24 <dfeuer> heatsink, the thing is, I actually have enough length information from the start to be able to build the FingerTree "from the top down".
19:01:09 <dfeuer> So I should be able to make this work. But I can't do it by appending.
19:02:43 <heatsink> ok
19:02:52 <dfeuer> heatsink, my ultimate goal here is an implementation of (<*>) that offers O(log(min{i,n-i})) access to an arbitrary element when "fresh" (nothing forced), but that can also be forced completely in O(|fs|*|xs|) time.
19:03:04 <dfeuer> I'm not 100% sure it's possible, but I *think* it is.
19:03:52 <heatsink> I don't know how finger trees work.
19:04:11 <heatsink> so I can't suggest things.
19:04:54 <dfeuer> Yeah, I only half-understand them.
19:05:15 <dfeuer> They're full of crazy nested types.
19:21:08 <hughfdjackson> for those that were interested, you can get the 'effect' of stepping through a pure computation just by annotating it with the writer monad, then taking from head as you go
19:21:46 <dfeuer> Does anyone here understand finger trees well?
19:21:57 <hughfdjackson> :| it seems obvious now that I'm typing it
19:25:40 <dmj`> dfeuer: what about them?
19:26:22 <dmj`> http://staff.city.ac.uk/~ross/papers/FingerTree.pdf
19:27:38 <solatis> http://hackage.haskell.org/package/containers-0.5.5.1/docs/Data-Sequence.html
19:27:40 <solatis> finger tree :)
19:33:16 <dfeuer> dmj`, the thread whose last message so far is https://www.haskell.org/pipermail/haskell-cafe/2014-November/117055.html
19:33:29 <dfeuer> And solatis, same.
19:45:33 <haskellquestion> does haskell have a method like this? http://www.dotnetperls.com/lastindexof
19:47:07 <NemesisD> merijn: so far sodium seems to have a simpler API
19:47:59 <solatis> haskellquestion: that would essentially be a find (reverse (str)) ?
19:48:42 <haskellquestion> solatis: i'm looking for the index
19:49:17 <solatis> haskellquestion: http://hackage.haskell.org/package/text-1.2.0.0/docs/Data-Text.html
19:49:36 <solatis> i think there's probably a function there that does what you want
19:49:56 <haskellquestion> just control+f'd for last and didn't find anything
19:50:47 <solatis> well yeah if you're going to contrl+f on 'lastindexof' you're gonna have a bad time
19:51:00 <Kaidelong> am I right in identifying the Fischer-Yates shuffle algorithm as an example of something Haskell is pretty bad at expressing?
19:51:32 <haskellquestion> solatis: no just last
19:52:28 <dfeuer> solatis, did you look at that haskell-cafe email?
19:52:39 <dfeuer> or dmj`?
19:53:03 <solatis> dfeuer: yeah, but that discussion is way out of my league
19:53:23 <dfeuer> solatis, most of it's out of mine too :P
19:53:39 <dfeuer> Buttttt
19:53:58 <kevin1024> Hi!  If I wanted to learn haskell by doing some graphics programming, is there something similar to Processing for Haskell?
19:53:59 <solatis> haskellquestion: i think breakOnEnd will do the job for you
19:54:12 <kevin1024> Just want some simple routines to draw shapes on a canvas-type-thing.
19:54:14 <haskellquestion> ok lemme check
19:54:18 <dfeuer> heatsink, I wonder if you could write a three-Seq append that takes the total size as an argument and is lazy in the middle!
19:54:57 <Kaidelong> kevin1024: You talking like, simple graphical experiments that are rewarding to do, 3D graphics for game programming, or the use of GPU-oriented stuff like CUDA and OpenCL?
19:55:06 <haskellquestion> i need the index though?
19:55:22 <kevin1024> the first one, simple graphics experiements, 2d shapes and colors :)
19:56:50 <Kaidelong> kevin1024: there is a textbook, called "The Haskell School of Expression" that focused on this sort of thing, it also covered making music and animations
19:57:04 <Kaidelong> for a dead simple to use and set up library with quick rewards, look at "gloss"
19:57:17 <kevin1024> Awesome!  Thanks Kaidelong.
19:58:54 <Kaidelong> kevin1024: also take a look at CodeWorld, this is an effort to teach children haskell using Gloss
19:59:31 <solatis> haskellquestion: the index is just the length of the first element of the list
19:59:59 <Kaidelong> cdsmith sometimes shows up in this channel, you could ask him about it
20:00:12 <jfischoff> does anyone know what the performance of acid-state is?
20:00:31 <solatis> haskellquestion: so to answer your question, it's probably length (head (breakOnEnd (== '.') txt))
20:01:58 <kevin1024> Kaidelong: Nice, Gloss is pretty much exactly what I was looking for.
20:04:30 <haskellquestion> ok im back
20:04:33 <haskellquestion> thanks i'll try it out
20:05:10 <bananagram> is there an easy way to compose maps, where the values of one map are the keys of another?
20:05:52 <benzrf> bananagram: probably
20:06:08 <Clint> someone was talking about that a couple months ago
20:06:09 <P4Titan> Hello all, I have 2 modules that import each other causing a recursive import. Is that bad practice and should I make a thrid file
20:07:13 <solatis> P4Titan: how would using a third file make situation any better?
20:07:17 <merijn> jfischoff: Depends on your usecase
20:07:23 <solatis> also, it's called 'circular dependency', rather than 'recursive import'
20:07:25 <dfeuer> bananagram, that's an interesting question. I think you'll have trouble getting a Map out, because you can't really modify it.
20:07:54 <P4Titan> I am not too sure, but is curcular dependency normal in haskell
20:08:05 <jfischoff> merijn: I got some numbers. It was what I expected (microseconds for small amounts of data)
20:08:06 <bananagram> dfeuer, just an a -> b or a -> Maybe b would work
20:08:21 <merijn> P4Titan: Officially implementations have to support it, but I don't think any existing implement that part of the report
20:08:42 <solatis> https://www.haskell.org/haskellwiki/Mutually_recursive_modules
20:08:43 <merijn> P4Titan: I find myself wanting recursive imports all the time, you can use a hs-boot file to break the cycle, see the GHC user guide
20:08:45 <dfeuer> bananagram, I'm not sure what you're saying.
20:09:07 <solatis> P4Titan: https://www.haskell.org/haskellwiki/Mutually_recursive_modules#GHC
20:09:09 <bananagram> hm, I'll try to craft one
20:09:32 <merijn> jfischoff: For things that are not table like, but more just data structures I would expect it to not be more expensive that normal data structures, yeah
20:09:41 <P4Titan> But I know that in other languages, paritcularily C, it is impossible to fix and was wondering if it was incredibly bad practice in Haskell or not
20:09:46 <Clint> :t \i -> lookup i map1 >>= flip lookup map2
20:09:47 <lambdabot>     Not in scope: ‘map1’
20:09:47 <lambdabot>     Perhaps you meant one of these:
20:09:47 <lambdabot>       ‘mapM’ (imported from Control.Monad.Writer),
20:09:51 <Clint> er
20:10:06 <solatis> P4Titan: it is possible to fix in C -- that's why declaration and definition of functions are separated there
20:10:08 <merijn> P4Titan: They're not good, but a lot of sane code groupings run into them anyway
20:11:06 <P4Titan> I will explain my situation then. I have a function that calls a function in another modules. In that module, a function calls a function in the other modules. How would be best to fix this?
20:11:30 <solatis> P4Titan: another module! now you've got 2 problems!
20:11:33 <solatis> :)
20:11:54 <P4Titan> What exactly do you mean by that?
20:12:03 <solatis> it was a bad joke
20:12:15 <P4Titan> oh
20:12:30 <solatis> ehrm, i'm not sure if this problem is fixable at all
20:12:36 <solatis> it's kind of the chicken-or-the-egg problem
20:12:53 <solatis> and you will probably need to give your compiler very specific instructions on how to handle it
20:12:57 <solatis> hence https://www.haskell.org/haskellwiki/Mutually_recursive_modules#GHC
20:13:04 <P4Titan> But isnt that bad
20:13:17 <solatis> well yes, but it's like that in any language
20:13:20 <heatsink> Sometimes it makes sense to break the cycle by passing function 2 as an argument to function 1
20:13:24 <solatis> to go back to C, think about it this way:
20:13:40 <solatis> upon compiling your code, the compiler needs to know the (stack) size of all your objects
20:13:52 <P4Titan> yes
20:14:07 <solatis> if A depends upon B, and if B depends upon A, what is sizeof(A) or sizeof(B) ?
20:14:16 <solatis> that could be anything
20:14:27 <solatis> the compiler simply is unable to figure that out
20:14:43 <solatis> that's where the separation between headers and implementation came from
20:14:45 <P4Titan> assuming A and B are structs of some sort
20:14:52 <solatis> yeah exactly
20:14:53 <P4Titan> Yes, header files
20:15:00 <P4Titan> but haskell does not have that
20:15:02 <solatis> header files solve a *part* of that problem
20:15:03 <jmcarthur> bananagram: what happens if the one map doesn't have a key corresponding to a value of the other?
20:15:07 <solatis> the signature of the function
20:15:23 <solatis> but if it's two structs both having each other as member objects, you still cannot do that in C/C++
20:15:23 <jmcarthur> bananagram: should it fail or do something like leave that value out of the result?
20:15:24 <merijn> P4Titan: They do, hs-boot files solve this, I just said that
20:15:29 <merijn> P4Titan: Read the GHC user guide
20:15:31 <heatsink> You can't have recursively nested structures in C because a data structure has to be fully defined before it is used to declare a variable.
20:15:51 <heatsink> So the compiler doesn't actually have to detect this problem
20:16:17 <P4Titan> solatis: true, because it would take up infinate memory as B will be in A and in that B there will be another A, etc. hence pointers
20:16:20 <P4Titan> Anyway
20:16:32 <solatis> P4Titan: infinite, or none at all -- 'undefined' is a better way
20:16:34 <solatis> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/separate-compilation.html#mutual-recursion
20:16:41 <solatis> that's probably what you're looking for
20:16:46 <c74d> Is there a standard GNU Emacs plug-in for Haskell completion?
20:16:46 <P4Titan> So that best way to solve my problem is with hs-boot
20:16:50 <P4Titan> I will check it out
20:16:50 <bananagram> jmcarthur: it should fail, I guess, and that would be a major problem anyway
20:16:55 <solatis> it ain't pretty tho
20:17:10 <P4Titan> c74d: autocompletion?
20:17:14 <solatis> but a design where two pieces of code depends upon each other ain't pretty in the first place, imho :)
20:17:41 <solatis> but i'm unable to say anything about your specific scenario
20:17:50 <c74d> P4Titan: I suppose, though I’m okay with pressing Tab.
20:18:03 <jmcarthur> :t traverse . flip M.lookup :: (Ord a, Ord b) => Map b c -> Map a b -> Maybe (Map a c)    -- bananagram
20:18:04 <lambdabot>     Not in scope: type constructor or class ‘Map’
20:18:04 <lambdabot>     Perhaps you meant ‘M.Map’ (imported from Data.Map)
20:18:04 <lambdabot>     Not in scope: type constructor or class ‘Map’
20:18:09 <jmcarthur> :t traverse . flip Map.lookup :: (Ord a, Ord b) => Map b c -> Map a b -> Maybe (Map a c)    -- bananagram
20:18:10 <lambdabot>     Not in scope: ‘Map.lookup’
20:18:10 <lambdabot>     Perhaps you meant one of these:
20:18:10 <lambdabot>       ‘M.lookup’ (imported from Data.Map),
20:18:15 <jmcarthur> oh
20:18:27 <jmcarthur> :t traverse . flip M.lookup :: (Ord a, Ord b) => Map.Map b c -> Map.Map a b -> Maybe (Map.Map a c)    -- bananagram
20:18:28 <lambdabot>     Not in scope: type constructor or class ‘Map.Map’
20:18:28 <lambdabot>     Perhaps you meant ‘M.Map’ (imported from Data.Map)
20:18:28 <lambdabot>     Not in scope: type constructor or class ‘Map.Map’
20:18:32 <jmcarthur> man i stink
20:18:42 <jmcarthur> :t traverse . flip M.lookup :: (Ord a, Ord b) => M.Map b c -> M.Map a b -> Maybe (M.Map a c)    -- bananagram
20:18:43 <lambdabot> (Ord a, Ord b) => M.Map b c -> M.Map a b -> Maybe (M.Map a c)
20:18:44 <P4Titan> I mean what exactly do you mean. I know that auto-complete-mode does my autocompletion and suggestions when I type
20:18:52 <jmcarthur> would be nice if Map was in scope unqualified
20:18:57 <jmcarthur> the type, that is
20:19:18 <c74d> Primarily, I’m interested in something that would complete identifiers from any installed (or at least any standard-library) module, rather than only identifiers already in the file.
20:19:39 <P4Titan> ohh
20:19:42 <k-u> In GHCi, what is the preferred method of storing data read from a file in to a variable without outputting it?  I'm currently doing 'let dat = unsafePerformIO $ readFile "file"'
20:19:42 <P4Titan> IDK about that
20:19:57 <heatsink> dat <- readFile "file"
20:20:06 <bananagram> jmcarthur: nice, I'll try that
20:20:34 <jmcarthur> :t fmap . (M.!) :: (Ord a, Ord b) => M.Map b c -> M.Map a b -> M.Map a c    -- if an exception on failure is okay... but it shouldn't be
20:20:35 <lambdabot> (Ord a, Ord b) => M.Map b c -> M.Map a b -> M.Map a c
20:21:40 <merijn> k-u: The preferred way to do anything is never "unsafePerformIO"
20:22:10 <solatis> merijn: unless it's the only way :)
20:22:13 <jmcarthur> k-u: treat a ghci session kind of like do notation. you can say 'dat <- readFile "file"'
20:22:20 <k-u> heatsink: Cool!  I didn't know you could use <- outside of dos
20:22:37 <jmcarthur> k-u: you can't, officially. ghci is special
20:24:17 <dfeuer> merijn, that's why the advice in the Haddocks for some basic Concurrent Haskell recommending that for some basic cleanup tasks is kind of yucky.
20:24:35 <k-u> merijn: That was along my gut instinct, hence why I asked :)
20:25:12 <dfeuer> k-u, I think the GHCi command line is kind of sort of pretend like you're in a do block, except when that's inconvenient.
20:30:48 <dfeuer> Ping Cale
20:32:28 <altmattr> can anyone explain why `let bar = map (\a -> if (a < a) then a else a)` get the type `[()] -> [()]` in ghc(i)
20:32:43 <altmattr> I was expecting `Ord a => [a] -> [a]`
20:33:13 <dfeuer> altmattr, what version?
20:33:27 <merijn> Dreaded monomorphism restriction
20:33:27 <solatis> :t map (\a -> if (a < a) then a else a)
20:33:29 <lambdabot> Ord b => [b] -> [b]
20:33:32 <altmattr> 7.6.3 on this computer
20:33:35 <k-u> I looked it up in the ghc docs, "The syntax of a statement accepted at the GHCi prompt is exactly the same as the syntax of a statement in a Haskell do expression.However, there’s no monad overloading here: statements typed at the prompt must be in the IO monad."
20:33:38 <merijn> @where dmr
20:33:38 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
20:34:04 <dfeuer> altmattr, you can either  :set -XNoMonomorphismRestriction or upgrade to GHC 7.8.3.
20:34:12 <altmattr> merjin: thanks, of course
20:34:30 <solatis> k-u: so GHCi is essentially main in a big do block
20:34:33 <merijn> Or the best solution
20:34:39 <merijn> Just write down a signature :>
20:34:49 <altmattr> merjin: why does it choose the unit type?
20:34:55 <dfeuer> solatis, except you can declare types and instances and things...
20:35:09 <dfeuer> GHCi is ~magic.
20:35:26 <solatis> now if only lambdabot would be ~magic :)
20:35:40 <solatis> it already is pretty magic, tho
20:35:53 <shaykha> :t magic
20:35:54 <lambdabot> Not in scope: ‘magic’
20:36:01 <dfeuer> solatis, I've been meaning to file a bug report against it for failing to actually be intelligent.
20:36:09 <dfeuer> But things have been busy.
20:36:20 <merijn> altmattr: Extending defaulting
20:36:47 <merijn> altmattr: Dread monomorphism restriction (see wiki page for details) forces it to be monomorphic and in the absence of other type info ghci defaults to()
20:37:18 <solatis> dfeuer: please let it violate at least one law of robotics
20:37:40 <dfeuer> solatis, why would it obey any "laws of robotics"?
20:38:16 <solatis> because if would like to build a lamdarobot
20:38:22 <solatis> /if/i/
20:38:34 <solatis> if it was actually intelligent
20:39:10 <solatis> otoh, being written in haskell, it would probably be a very lazy robot
20:40:09 <dfeuer> solatis++
20:41:12 <solatis> "make me a sandwich" -- "no!" -- "unsafePerformIO $ make me a sandwich" -- "okay..."
20:52:10 <danilo2> Hello! I want to "hide" a type of a member of a datatype and I'm using existential datatypes. I want to ask you if it is possible to implement somehow the function addToList from the following smalle example: http://lpaste.net/114833 .. The "list" is in fact tuple of tuples and this datatype will contain functions, that can optain values from this nested tuple and modify this tuple itself
20:54:10 <benzrf> shaykha: your doing it wrong
20:54:17 <benzrf> * solatis
20:54:21 <benzrf> oh
20:59:51 <jle`> sounds a lot more like unsafeCoerce
21:01:19 <michaelt> danilo2: this is a bit of a nightmare, instance GetData k lst out => GetData k (a,lst) out where getData k (a,lst) = getData k lst  works with enough extensions .... but I can't see where this is going, myself
21:06:13 <boxrick> zZzzzz its 5AM here…. why am I still up?
21:07:56 <danilo2> michaelt: Right, here is more advanced example, which does not work: http://lpaste.net/114835 . So where it is going? I'm trying to write something funny - namely a set of compiler passes - each pass can take some data of some types from this list of tuples and put modified data back. The problem is, that the order of the passes is definied at runtime and the passes are polymorphic functions.
21:08:19 <danilo2> michaelt: I'm just testing, i do not know if this approach would result in anything working
21:09:56 <michaelt> danilo2: oh I see ... sort of. Maybe a type level list for the second argument of GetData?
21:10:31 <michaelt> GetData :: * -> '[(*,*)] -> * -> Constraint, or something like that
21:12:10 <danilo2> michaelt: it does not matter - nested tuples work as well as type level list. Look, if you remove the function "addToList" everything wokrs - I just want it to compile. With type level lists I will get exactly the same problem there
21:14:49 <Kaidelong> https://www.fpcomplete.com/user/jwiegley/understanding-continuations <- I reached "Coming back again" and it kind of blew my mind, is it that the <- for ContT is more about what might be demanded in the future, and it isn't so much about enforcing a strict ordering like in IO?
21:15:20 <torpet> I am trying to map a function to a zipped list: http://lpaste.net/457906520923832320
21:15:40 <torpet> But the problem is that the function doesnt take a tuple as input, but rather the 2 values separated
21:15:46 <torpet> How should I solve thi issue?
21:17:14 <Javran> has anyone experienced the problem that flycheck with hdevtools keeps bugging "could not find module" while the module is in the same directory as the editing source file?
21:17:28 <michaelt> torpet you want to zipWith (tzp f)
21:17:47 <michaelt> torpet: or map (uncurry (tzp f))
21:18:44 <danilo2> Hello! Is it possible in Haskell to hide a tuple inside a datatype using existentials in such way, that I will add there elements and remove them using typclasses? I do not want to get these elements out - rather I want this datatype to have a list of functions that can operate on the tuple. The scratch implementation is here: http://lpaste.net/114835
21:19:07 <benzrf> bye
21:19:39 <michaelt> torpet: that is, zipWith (tzp f)  t1 t2 -- t1 and t2 are evidently lists of trees?
21:19:50 * hackagebot brainfuck-tut 0.5.1.0 - A simple BF interpreter.  http://hackage.haskell.org/package/brainfuck-tut-0.5.1.0 (alcabrera)
21:19:51 <torpet> michaelt: yup, exactly
21:21:19 <torpet> worked a treat
21:21:26 <torpet> and zipWith makes totally sense now
21:26:36 <jle`> why is (cycle []) undefined
21:26:52 <merijn> jle`: What would you expect it to do?
21:26:59 <jle`> []?
21:27:04 <jle`> @src cycle
21:27:04 <lambdabot> cycle [] = undefined
21:27:04 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
21:27:06 <merijn> Why ?
21:27:23 <vanila> [] ++ [] ++ ...
21:27:28 <jle`> hm
21:27:28 <vanila> it never gets to the first element
21:27:32 <jle`> ah i see
21:27:44 <jle`> so it's bottom...so that makes sense
21:27:57 <jle`> it was just that 0 length seemed to be a reasonable degenerate case for 0 initial elements
21:29:25 <vanila> oh you want to define cycle [] = []?
21:30:45 <jle`> yeah but i see why it makes sense the way it is now
21:30:51 <Hafydd> That would remove the important invariant of cycle xs never being a finite list.
21:31:24 <jle`> > fix ([] ++)
21:31:28 <lambdabot>  mueval-core: Time limit exceeded
21:34:50 * hackagebot brainfuck-tut 0.5.1.1 - A simple BF interpreter.  http://hackage.haskell.org/package/brainfuck-tut-0.5.1.1 (alcabrera)
21:35:17 <danilo2> Hello! Is it possible in Haskell to hide a tuple inside a datatype using existentials in such way, that I will add there elements and remove them using typclasses? I do not want to get these elements out - rather I want this datatype to have a list of functions that can operate on the tuple. The scratch implementation is here: http://lpaste.net/114835
21:36:40 <vanila> danilo2, what about  data Stuff x y where Thing :: a -> (a -> x) -> (a -> y) -> Stuff x y
21:39:50 * hackagebot brainfuck-tut 0.5.1.2 - A simple BF interpreter.  http://hackage.haskell.org/package/brainfuck-tut-0.5.1.2 (alcabrera)
21:40:28 <danilo2> vanila: Hmm, I do not see how to use it in my situation, would you be so nice and tell al itle more aobut it? :)
21:41:17 <vanila> it lets you hold a value that has any type, but also two functions that let you elim it into some known type
21:43:10 <danilo2> vanila: I think this is something I started with. Now I need to hold there many functions of type (x->a) , where x is one of elements of a. Using typeclasses we can assume that this is list of functions (a->a). The problem is, that I would like also to be able to add elements to a in runtime
21:44:51 * hackagebot brainfuck-tut 0.5.1.3 - A simple BF interpreter.  http://hackage.haskell.org/package/brainfuck-tut-0.5.1.3 (alcabrera)
21:47:08 <centrinia> It doesn't optimize. :(
21:56:01 <codygman> How would I use lookup on something like: fromList [(Name {nameLocalName = "class", nameNamespace = Nothing, namePrefix = Nothing},"hide")]
21:58:07 <hnoob> I guess you have to construct the whole Name record to look up "hide".  have you tried that?
22:01:53 <hnoob> ah, name has to implement Ord
22:04:57 <pavonia> :t fromList
22:04:58 <lambdabot>     Not in scope: ‘fromList’
22:04:58 <lambdabot>     Perhaps you meant one of these:
22:04:58 <lambdabot>       ‘IM.fromList’ (imported from Data.IntMap),
22:09:24 <bananagram> cabal update uses way too much memory sometimes
22:11:40 <codygman> hnoob: I figured it out: M.lookup (XML.Name "class" Nothing Nothing) (M.fromList [(XML.Name {XML.nameLocalName = "class", XML.nameNamespace = Nothing, XML.namePrefix = Nothing},"hide")])
22:11:52 <codygman> How would I not care about the two nothing values though?
22:12:09 <codygman> I thought this would work:
22:12:10 <codygman> M.lookup (XML.Name "class" _ _) (M.fromList [(XML.Name {XML.nameLocalName = "class", XML.nameNamespace = Nothing, XML.namePrefix = Nothing},"hide")])
22:22:42 <jle`> codygman: lookup uses (==)
22:23:23 <codygman> jle`: Ah, so I need something... else
22:24:22 <codygman> This defeats the purpose of a map kind of: map (\n@(XML.Name "class" _ _) -> n) (M.keys myMap)
22:26:57 <codygman> So you can't look for keys with only a certain part of a pattern match then. All I'm trying to do is find out if an xml elements attribute list contains a class called hide. Well I guess at a higher level, I'm trying to filter all hidden elements out of a Text.XML.Cursor
22:27:56 <jle`> yeah, such a lookup isn't really what Map was designed for
22:28:50 <codygman> jle`: Alright. Would it be a good idea to have a structure like that?
22:29:24 <jle`> you can still do this with Data.Map
22:29:30 <jle`> i think
22:29:41 <jle`> but the runtime costs aren't really optimized for this sort o operation
22:30:01 <codygman> jle`: Yeah, I know that at least. At this point though, I'm just trying to find a working solution lol
22:30:02 <jle`> it's optimized for quick lookups based on key equality
22:30:14 <jle`> i believe you can filter a map by key properties
22:32:12 <haskellquestion> any way to make trace print without a newline? or any other method that allows printing during a function call
22:32:37 <Hijiri> unsafePerformIO $ putStrLn string?
22:32:52 <Hijiri> unsafePerformIO $ putStrLn string? `seq` foo
22:32:58 <int-e> Hijiri: there's Debug.Trace.trace
22:33:32 <haskellquestion> ok i'll try it
22:33:41 <Hijiri> whoops, meant putStr, putStrLn
22:33:58 <int-e> oh, without newline, hmm. no, Debug.Trace doesn't do that
22:34:14 <Hijiri> s/putStrLn/not putStrLn/
22:36:07 <jle`> myTrace str x = (unsafePerformIO (putStr str)) `seq` x
22:39:07 <haskellquestion> hey hijiri i'm still new to the io thing.. do i need to use a do wrap or something here? how do i call the function after the print? here's my code: | x == '.' = unsafePerformIO $ putStr "Z" execCode tapePos ts nextPos xs
22:39:08 <jle`> seq . unsafePerformIO . putStr
22:39:10 <jle`> what a lovely function
22:39:19 <haskellquestion> i'm not sure what to put between "Z" and execCode
22:39:30 <jle`> haskellquestion: see `myTrace`
22:39:47 <haskellquestion> what is myTrace?
22:40:15 <jle`> i posted it up a few lines back
22:40:21 <jle`> it's like Debug.Trace.trace, except it doesn't have the newline
22:40:28 <haskellquestion> oh ok thanks
22:41:01 <jle`> don't use it in real production code before understanding it though :)  just for debugging an infinite loop should be fine
22:41:05 <haskellquestion> hooray it worked
22:41:15 <haskellquestion> it's not for debugging.. lol i'm just bad at haskell and don't know how to do it properly
22:41:22 <haskellquestion> writing a bf interpreter
22:41:29 <jle`> oh
22:41:50 <haskellquestion> lol sorry
22:41:53 <jle`> then maybe another way of going about this is better ;)
22:41:59 <jle`> just for your own sake :)
22:42:12 <haskellquestion> well do you want to see what i have so far? maybe you can suggest a refactoring
22:42:16 <vanila> you shouldn't use unsafePerformIO is haskell programming
22:42:25 <haskellquestion> yeah i know but i'm not sure how else to do this
22:42:36 <vanila> yes you could show the code and people will give comments/improvements
22:42:47 <vanila> put it on lpaste.net if you liek
22:42:48 <dhrosa> there's a reason it says "unsafe" :p
22:42:50 <haskellquestion> ok just give me like 5-10 minutes
22:42:56 <haskellquestion> i almost have this one part working
22:44:09 <codygman> How would I avoid using fromJust here? Thinking about how to make M.lookup take a maybe Key makes my head hurt and I'm not sure it's possible. I also don't think there is a sensible default I could have with fromMaybe that wouldn't match any keys. Code: http://lpaste.net/114837
22:44:42 <vanila> codygman, maybe fmap?
22:44:54 <merijn> codygman: I'm assuming you want Nothing if your key is Nothing?
22:45:11 <vanila> > fmap (+1) (Just 3)
22:45:12 <lambdabot>  Just 4
22:45:13 <vanila> > fmap (+1) Nothing
22:45:14 <lambdabot>  Nothing
22:45:17 <codygman> merijn: yes
22:45:18 <vanila> like that, is that the situation?
22:45:19 <merijn> Not fmap
22:45:23 <merijn> codygman: >>= :)
22:45:30 <codygman> merijn: lol
22:46:03 <merijn> > Nothing >>= \k -> M.lookup k M.empty
22:46:05 <lambdabot>  Nothing
22:46:24 <merijn> > Nothing >>= \k -> M.lookup k (M.fromList [(1, 'a')])
22:46:26 <lambdabot>  Nothing
22:46:32 <merijn> > Just 1 >>= \k -> M.lookup k (M.fromList [(1, 'a')])
22:46:34 <lambdabot>  Just 'a'
22:46:36 <merijn> > Just 2 >>= \k -> M.lookup k (M.fromList [(1, 'a')])
22:46:38 <lambdabot>  Nothing
22:46:39 <codygman> merijn: so obvious... thanks!
22:46:57 <codygman> elusive obvious is the bane of my existence
22:47:19 <merijn> Maybe monad to the rescue \o/
22:47:24 <Yaah> hey
22:47:40 <vanila> I feel ignored
22:47:55 <codygman> vanila: Sorry, thanks for the suggestion though.
22:47:56 <Yaah> how are you?
22:47:58 <Yaah> how is everyone
22:48:02 <Yaah> <?>
22:48:20 <nitrix> merijn: How long does it make to become fluent in haskell? I really enjoy the type system so far, but monads are still tricky and while I'm able to write programs, they are extremely simple, like cases, recursive functions, bit of pattern matching and Data.Either, Data.Maybe, Data.List really.
22:48:29 <nitrix> s/make/takes/
22:49:18 <nitrix> I still take very long pauses to understand the type transformations and parse code in my head.
22:49:55 <Hijiri> I felt generally okay after a summer, but there's still a lot of things I'm learning
22:51:16 <nitrix> Well, monads in particuliar, I went to write my own programming language, tried to simpliy it as much as I can, it ended up functional, but then I needed IO, so I added some contexts that had to be represented with types and after couple days designing it, I realised I had exactly what Haskell was doing with monads.
22:51:34 <nitrix> So that was my eureka moment, but it's still dark magic at times.
22:51:46 <nitrix> Functors, Applicative and whatever else...
22:52:03 <haskellquestion> omg i'm having the most ridiculous problem.. feeling so dumb
22:52:08 <Hijiri> functors and applicative are pretty straightforward I think
22:52:09 <jle`> monads?
22:52:22 <haskellquestion> (chr (S.index ts tapePos))       " Couldn't match type `Char' with `[Char]'"
22:52:28 <jle`> do you mean IO?
22:52:45 <jle`> cause i'm trying to see how learning monads would be a big struggle in learning haskell
22:52:56 <haskellquestion> just trying to get the int from this index and convert it to a character.. function wants a string but i have just a character and if i call show on it i get even mroe errors?
22:52:57 <vanila> it is quite easy just use do notation
22:52:58 <jle`> i can see how working with IO is a bit unintuitive at first
22:53:17 <jle`> and it might take a while getting used to IO and binding IO operations
22:53:31 <nitrix> I think what makes it hard is parametric polymorphism.
22:54:19 <jle`> hm
22:54:42 <jle`> i can see how getting used to using various types might be tricky...State, Reader, IO, Maybe, list, etc.
22:54:50 <nitrix> Or, to put it another way, in C, your type is what it is, but you have type modifiers for the storage duration, const-correctness and such, but it's still fairly easy to guess the type when you take the keywords away.
22:55:13 <wei2912> hmm
22:55:23 <wei2912> i think most of the explanations are just crappy
22:55:43 <merijn> nitrix: I would say it probably took >6 months on my third or so try before I wrote anything non-trivial, but then again I didn't really try hard to
22:55:58 <merijn> nitrix: fwiw it's worth, don't "learn monads"
22:56:09 <vanila> haskellquestion, use chr and ord
22:56:18 <jle`> yeah, i'm trying to imagine at one point in time a haskeller would have to "learn monads" or have monads become a hinderance
22:56:20 <haskellquestion> i am using chr?
22:56:20 <vanila> to convert from Int to Char and back
22:56:25 <vanila> oh
22:56:31 <merijn> nitrix: Learn typeclasses and how to read types, then study specific implementations of Monad, such as Maybe, Either, State, Reader and more
22:56:32 <vanila> so if you want it as a string go [chr x]
22:56:35 <jle`> usually you aren't supposed to even learn monads at all
22:56:49 <nitrix> Yeah. How much will I bite my nails if I'm working on a haskell codebase while I'm learning it? My understanding is refactoring haskell code is trivial.
22:56:51 <haskellquestion> oh good idea let me try that
22:57:18 <merijn> nitrix: Monads are just an interface and the word gets blown to mythical proportions, they're not that hard. But people tend to think "they're hard and complicated, there must be more to it than what I'm seeing"
22:57:21 <merijn> But there isn't
22:57:23 <nitrix> Obviously, I'll reach milestones where I'll consider my previous work garbage and modify it.
22:57:26 <haskellquestion>     Could not deduce (a ~ Int)     from the context (Eq a, Num a)       bound by the type signature for                  execCode :: (Eq a, Num a) =>                              Int -> S.Seq a -> Int -> String -> S.Seq a
22:57:43 <merijn> nitrix: Have you implemented State yet?
22:57:50 <merijn> I always consider that good practice
22:57:58 <merijn> Very eductional :)
22:58:46 <nitrix> I've had a taste of IORef
22:58:51 <haskellquestion> lol been trying to figure out how to convert a character to a string for 20 minutes... not going so well lol
22:58:55 <nitrix> I suppose it's similar.
22:58:57 <merijn> nitrix: I think the crucial bottleneck to doing any "real" work is getting to transformers and getting a feel for them, that's the point where you can do "real" work
22:59:05 <lpaste> glguy pasted “Who has the fish? - Ersatz” at http://lpaste.net/114838
22:59:08 <merijn> nitrix: Ah, no, IORef is very different I mean "State s a"
22:59:38 <jle`> haskellquestion: usually something like that happens when you make your type signature take something for any "a", and then do something with it that requires it to be an Int
22:59:46 <nitrix> merijn: What I'm wondering is if I'll keep trying to parse expressions in my head or it'll be absolutely trivial at some point. I mean, some of them are really terse...
22:59:54 <jle`> like foo :: Int -> a, foo x = x + 3
23:00:13 <merijn> nitrix: Some you get used to, like everything applicative
23:00:14 <jle`> or foo :: Int -> a -> Int; foo x y = x + y
23:00:26 <merijn> nitrix: Other are just really obtuse
23:00:28 <nitrix> Problem is, I feel like being able to parse expressions easily heavily depends on your knowledge of the library.
23:00:40 <haskellquestion> jle` my type signature takes ints though.. hmm
23:00:49 <jle`> what do you want it to do, then?
23:00:57 <jle`> does it even make sense to make it work for all `a`'s?
23:01:09 <haskellquestion> i just want to pass it to this function that takes a string. i can convert it to a char just fine but string throws errors
23:01:09 <jle`> if it doesn't, then just make it Int instead of a
23:01:24 <merijn> nitrix: For some libraries yes. One of the crucial steps in learning haskell beyond LYAH is being familiar with the "common core" of libraries used all over. I'd say at least Applicative and transformers are key.
23:01:26 <haskellquestion> ill paste the code one sec
23:01:31 <merijn> nitrix: Have you read typeclassopedia?
23:02:03 <haskellquestion> jle` http://lpaste.net/574230045074128896 line 12
23:02:08 <codygman> @pl (\m' -> (headMay . filter (\(XML.Name "class" _ _) -> True) . M.keys $ m') >>= (\k -> M.lookup k m'))
23:02:08 <lambdabot> (line 1, column 39):
23:02:08 <lambdabot> unexpected "\""
23:02:08 <lambdabot> expecting operator or ")"
23:02:09 <codygman> awww
23:03:23 <merijn> nitrix: https://www.haskell.org/wikiupload/e/e9/Typeclassopedia.pdf
23:03:35 <nitrix> merijn: Thanks.
23:03:43 <haskellquestion> wait!
23:03:44 <haskellquestion> i got it
23:03:48 <haskellquestion> hooray it works!
23:03:51 <merijn> nitrix: Another good exercise is https://gist.github.com/merijn/098106abd45c940dab09
23:03:57 <jle`> haskellquestion: congrats :D
23:04:01 <haskellquestion> ok ok ok
23:04:04 <merijn> nitrix: Try and implement the functions and instances for MyState there
23:04:22 <haskellquestion> my brainfuck interpreter actually pritns out "Hello World" o boy
23:04:27 <nitrix> merijn: Noted.
23:04:57 <merijn> nitrix: You can try using https://www.haskell.org/haskellwiki/State_Monad#Complete_and_Concrete_Example_1 to see if your implementation works
23:04:57 <jle`> :D
23:06:09 <merijn> nitrix: The usual progress is "waste over 8 hours trying to implement MyState" -> "look back at what you've done and go 'jesus, how did I think that was difficult?!'"
23:06:30 <merijn> It's a fairly simple trick, but until you do it yourself, it'll be hard to follow
23:07:43 <glguy> codygman: This probably doesn't do what you wanted it to:  filter (\(XML.Name "class" _ _) -> True)
23:08:19 <codygman> glguy: I want to find all tags which are a class
23:08:29 <glguy> > (\"example" -> True) "failure"
23:08:31 <lambdabot>  *Exception: <interactive>:3:2-19: Non-exhaustive patterns in lambda
23:08:36 <glguy> ^
23:12:21 <codygman> filter (\(XML.Name "class" _ _) -> True) [XML.Name "" Nothing Nothing] fails, you are right.
23:12:43 <kvanb> codygman: but
23:13:37 <kvanb> try filter (\x | (XML.Name "class" _ _) <- x)
23:13:40 <kvanb> but no guarantees
23:14:26 <kvanb> I actually dont think pattern guard lets you do that
23:14:27 <kvanb> oh well.
23:14:28 <codygman> kvanb: Getting a parse error on |
23:14:34 <kvanb> yeah, blah.
23:14:53 <haskellquestion> okay so i've been working on this brainfuck interpreter all day and finally got everything working except comma but i'm not going to do that anyway probably. i just started learning haskell a week ago so i'd really appreciate a code review or some refactoring tips if anyone doesn't mind. my code is pretty terrible so i'd love to know some ways to polish it up thanks! http://lpaste.net/3339460402625904640
23:18:33 <vanila> http://lpaste.net/3339460402625904640
23:18:39 <vanila> here's how to do it withour unsafePerformIO
23:19:55 <wz1000> vanila: You just pasted the same link
23:21:13 <vanila> yyou have to reload it to see my annotation
23:21:32 <wz1000> vanila: Ah, OK
23:22:18 <wz1000> haskellquestion: Just curious, why did you roll your own trace instead of using Debug.Trace.trace?
23:23:06 <haskellquestion> i didn't want the new line when printing
23:25:54 <hiptobecubic> How do you deal with nested JSON objects using Aeson?
23:26:44 <hiptobecubic> For example if I have: {foo: {bar: 4, baz: "quuz"}, qoob: 84}
23:27:04 <hiptobecubic> and a data type `Whatever baz qoob`
23:29:07 <wz1000> I am in the process of desgining my own toy Scheme-like purely functional language. I was thinking of controling effects with an explicit 'world' baton that you have to manually pass around and update, along with 'do-notation' like syntactic sugar. I realize this limits the semantics of my language to singly threaded programs. What alternate ways are there to deal with this?
23:29:11 <hiptobecubic> And now I'd like an `instance FromJSON Whatever...`
23:29:48 <vanila> wz1000, it could be monadic
23:29:54 <merijn> wz1000: 3 approaches come to mind
23:30:13 <vanila> mercury uses the baton idea, check out the lang a bit if you're interested
23:30:27 <merijn> wz1000: Haskell originall used a "lazy infinite list of incoming IO events" to "lazy infinite list of outgoing IO events" originally
23:30:36 <merijn> wz1000: There's the monadic approach
23:30:47 <merijn> wz1000: And then there's uniqueness types like Clean uses
23:31:07 <merijn> Although I don't know enough about uniqueness typing to say how one would implement it
23:32:51 <wz1000> merijn: My language is going to be strict, so I think that rules out the first approach.
23:33:03 <wz1000> merijn: Although I can have a stream
23:33:06 <merijn> wz1000: Also, you may wanna read the "Lazy Functional State Threads" paper
23:33:19 <merijn> Despite the name, the same approach would work just fine for a strict language
23:33:34 <merijn> It's how haskell's IO and ST monads are implemented under the hood
23:41:15 <haskellquestion> vanila: do you still have the version without the unsafe io? the link you posted earlier was teh same as mine
23:41:27 <vanila> reload it
23:42:10 <haskellquestion> oh it's at the bottom ok
23:44:33 <jfeltz> i finally needed to rage about this: http://www.reddit.com/r/programmingcirclejerk/comments/2n5f6d/you_need_to_be_more_object_oriented/
23:45:43 <simpson> State and behavior.
23:45:45 <haskellquestion> oh shit i never knew there was a programmingcirclejerk subreddit
23:46:08 <sivteck> Haskal
23:46:13 <haskellquestion> lol #4 post of all time
