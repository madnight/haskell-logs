00:04:08 <emmanueloga> merijn: hmmm liquid types seem to do a lot more than checking list types their size :).
00:04:15 <macalimlim> hello what soap client library would anyone recommend? :)
00:04:22 <emmanueloga> BTW the amount of projects on alternative type systems is overwhelming.
00:05:15 <merijn> emmanueloga: That's where the papers come from ;)
00:05:37 <merijn> emmanueloga: But yeah, LiquidHaskell is quite some overkill for just list lengths :)
00:06:09 <merijn> emmanueloga: The simple answer is: It's a bunch of hassle, so most people just use list. Or, if they really wanna enforce something about the length of the list, you use newtype + smart constructor
00:09:23 <emmanueloga> Gotcha. Would you say this is something innovative about ceylon's type system? I never saw that kind of list-quantifier-thingie in other languages.
00:10:24 <merijn> emmanueloga: It sounds like it's a baby step in the direction of dependent types
00:11:03 <merijn> emmanueloga: The state of the art in type systems, is WAY farther than this. Take a peak at things like Idris, Agda and Coq
00:11:27 <merijn> Idris especially is specifically aimed at intermediate haskellers as a practical alternative language
00:11:37 <merijn> Agda and Coq are more traditional theorem provers
00:12:42 <emmanueloga> cool, people recommended it to me in several occasions, it's just that I'm already learning a couple of things at the same time so I'm putting it on the back burner :). I'm thinking getting my ground on haskell will make it easier to learn something like idris.
00:12:57 <merijn> It will
00:13:16 <merijn> If you're interested in type systems and theory, Types and Programming Languages is a good book to start with
00:13:53 <emmanueloga> cool will check it out
00:13:59 <merijn> @where tapl
00:13:59 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
00:14:31 <emmanueloga> convenient :)
00:15:05 <merijn> It covers both theory and implementation of type checkers, including runnable examples
00:15:59 <merijn> Anyhoo, bedtime
00:17:43 <emmanueloga> has anybody ported the examples of the tapl book to haskell by any chance?
00:18:16 <emmanueloga> to answer my own question, first google match :) https://code.google.com/p/tapl-haskell/
00:57:42 <favetelinguis> how can i apply the same agrumets to multiple functions. i want to apply the same 2 argumets to 3 functions and chack that they all output the same result
01:01:26 <bergmark> > map (\f -> f 1 2) [(+),(-)]
01:01:27 <lambdabot>  [3,-1]
01:03:57 <narendraj9> > group
01:03:59 <lambdabot>  <[()] -> [[()]]>
01:04:03 <sipa> > map (($) 1 2) [(+),(-)]
01:04:05 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> (a1 -> a1 -> a1) -> b))
01:04:05 <lambdabot>    arising from the ambiguity check for ‘e_112’
01:04:05 <lambdabot>  from the context (GHC.Num.Num (a -> (a2 -> a2 -> a2) -> b),
01:04:05 <lambdabot>                    GHC.Num.Num a2,
01:04:05 <lambdabot>                    GHC.Num.Num a)
01:04:45 <sipa> ugh
01:04:47 <Hijiri> > map (($) 1 2) [(+),(-)] :: [Int]
01:04:49 <lambdabot>  No instance for (GHC.Num.Num
01:04:49 <lambdabot>                     (a0 -> (a1 -> a1 -> a1) -> GHC.Types.Int))
01:04:49 <lambdabot>    arising from the literal ‘1’No instance for (GHC.Num.Num a0) arising from ...
01:04:49 <lambdabot>  The type variable ‘a0’ is ambiguous
01:04:49 <lambdabot>  Note: there are several potential instances:
01:05:03 <Hijiri> > map (\f ->f 1 2) [(+),(-)] :: [Int]
01:05:04 <lambdabot>  [3,-1]
01:05:18 <narendraj9> Hijiri: 1 isn't a function.
01:05:41 <narendraj9> > group [3,3,3]
01:05:43 <lambdabot>  [[3,3,3]]
01:05:47 <Hijiri> what?
01:05:52 <sipa> :t group
01:05:53 <lambdabot> Eq a => [a] -> [[a]]
01:06:01 <Hijiri> oh, I was just copying what sipa had
01:06:03 <sipa> > group [1,2,3,1,2,3,4]
01:06:05 <lambdabot>  [[1],[2],[3],[1],[2],[3],[4]]
01:06:09 <Hijiri> I didn't check if it was correct
01:06:11 <sipa> > group [1,2,3,3,1,2,3,4]
01:06:13 <lambdabot>  [[1],[2],[3,3],[1],[2],[3],[4]]
01:06:50 <narendraj9> > (length . group . map) (\f -> f 1 2) [(+), (-)]
01:06:51 <lambdabot>  Couldn't match expected type ‘[a3 -> a3 -> a3] -> t’
01:06:52 <lambdabot>              with actual type ‘GHC.Types.Int’Couldn't match type ‘[a1 -> a2 -...
01:06:52 <lambdabot>  Expected type: ((a1 -> a2 -> b0) -> b0) -> [a0]
01:06:52 <lambdabot>    Actual type: ((a1 -> a2 -> b0) -> b0) -> [a1 -> a2 -> b0] -> [b0]
01:07:14 <narendraj9> > (length . group . map (\f -> f 1 2)) [(+), (-)]
01:07:16 <lambdabot>  2
01:07:30 <narendraj9> > (length . group . map (\f -> f 0 0)) [(+), (-)]
01:07:31 <lambdabot>  1
01:07:43 <narendraj9> > (length . group . map (\f -> f 0 0)) [(+), (-)] == 1
01:07:45 <lambdabot>  True
01:08:24 <narendraj9> Hijiri: Sorry.
01:09:31 <Hijiri> well I was trying to correct it myself, so it's my fault for not trying to correct it when I was trying to correct it
01:10:36 <narendraj9> Hijiri: But it's fun to just talk to the lambdadot.
01:11:06 <narendraj9> :-)
01:21:53 <trap_exit> someone tell a good haskell joke
01:23:14 <trap_exit> What is just nothing?
01:23:16 <trap_exit> maybe maybe
01:23:39 <dv-> ha
01:30:41 * hackagebot classy-prelude 0.10.2 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.10.2 (MichaelSnoyman)
01:30:43 * hackagebot classy-prelude-conduit 0.10.2 - conduit instances for classy-prelude  http://hackage.haskell.org/package/classy-prelude-conduit-0.10.2 (MichaelSnoyman)
01:30:45 * hackagebot classy-prelude-yesod 0.10.2 - Provide a classy prelude including common Yesod functionality.  http://hackage.haskell.org/package/classy-prelude-yesod-0.10.2 (MichaelSnoyman)
01:31:54 <r444> trap_exit: maybe maybe what?
01:51:38 <favetelinguis> what am i doing wrong if quckcheck only generates one test?
01:52:32 <favetelinguis> here is my prop http://lpaste.net/113736
01:53:25 <pharpend> Hey, how do I go about making my own handle?
01:53:33 <trap_exit> handle?
01:53:43 <trap_exit> what handle?
01:54:13 <pharpend> I have a function that writes to a file handle. I want to make a dummy handle that function will write to, and then check the contents of that handle
01:54:20 <pharpend> (for testing)
01:55:09 <pharpend> favetelinguis: quickcheck is probably generating one "test case" or one "test suite" - can you post the output of whatever command you are running (also the command itself)
01:55:28 <favetelinguis> λ> quickCheck prop_powers
01:55:29 <favetelinguis> +++ OK, passed 1 tests.
01:55:46 <pharpend> well
01:55:49 <pharpend> hm
01:58:10 <favetelinguis> pharpend: any ideas?
01:58:57 <pharpend> someone competent might have ideas
02:08:02 <srenatus> favetelinguis: tried verboseCheck? might help to know what the 1 test was
02:08:54 <favetelinguis> hmm it fails for verboseCheck
02:09:43 <favetelinguis> lol now it works for quiccheck also i have not changed anything
02:10:26 <pharpend> hmmmmmmmmmmmmmmmm
02:10:32 <pharpend> yeah, i'm way too tired to know
02:10:46 <narendraj9> favetelinguis: Why don't you show use the code?
02:10:52 <narendraj9> *us
02:10:59 <favetelinguis> i have
02:11:06 <pharpend> narendraj9: he did
02:11:08 <favetelinguis> http://lpaste.net/113736
02:11:19 <narendraj9> favetelinguis: Oh. I got disconnected.
02:11:23 * pharpend patiently waits for comcast to decide to load the page
02:13:30 <Guest52181> Is there any way to get ghc-mod to deal with ARROW Notation? Or is there an IDE that is capable of determining type information inside proc -> do statements?
02:18:31 <pharpend> can you give an example of the notation?
02:18:36 <makalu> I think there was a master's thesis that evaluated accelerate's performance. Does anyone know where to find it?
02:20:19 <Guest52181> pharpend : https://www.haskell.org/ghc/docs/6.12.1/html/users_guide/arrow-notation.html 7.10.1 specifically
02:21:19 <Guest52181> Need to have {-# LANGUAGE Arrows #-} to access, which is a preprocessor effect afaik, which is why I imagine ghc-mod has issues
02:22:38 <pharpend> hmm
02:25:26 <makalu> found it. It was actually Trevor McDonell's PhD thesis.
02:29:37 <pharpend> good job
02:32:17 <tinyblak> http://www.cse.unsw.edu.au/~tmcdonell/site/index.html
02:32:30 <seveg> can i use guards in where clausule?
02:33:39 <lyxia> You can.
02:36:49 <seveg> then my indentation is wrong..
02:37:03 <Axman6> feel free to share your code
02:39:21 <seveg> i got it right googling this: http://stackoverflow.com/questions/13327374/haskell-defining-a-function-with-guards-inside-a-where
02:39:33 <seveg> mine looked like the 3rd example in accepted answer
02:39:42 <seveg> which doesn't work
02:50:09 <__monty__> In LYAH chap 12: A Fistful of Monads, this function is introduced: x -: f = f x. Is there a name for this '-:' or is it merely a convenient sequence of symbols that doesn't already exist?
02:51:05 <Thooms> reverse function application ?
02:51:30 <Kinnison> It looks remarkably like flip id
02:52:06 <__monty__> Kinnison: Doesn't it look like (flip $)?
02:52:19 <__monty__> (flip id) = id, no?
02:52:37 <Kinnison> :t (flip id)
02:52:39 <lambdabot> b -> (b -> c) -> c
02:53:05 <Kinnison> __monty__: $ is id, with a slightly more restrictive type
02:53:16 <__monty__> :t id
02:53:17 <lambdabot> a -> a
02:53:19 <__monty__> :t $
02:53:21 <lambdabot>     parse error on input ‘$’
02:53:21 <lambdabot>     Perhaps you intended to use TemplateHaskell
02:53:26 <hyPiRion> :t ($)
02:53:27 <lambdabot> (a -> b) -> a -> b
02:55:18 <__monty__> Kinnison: Thank you for that insight, never thought of $ as a function that takes a function and returns a function.
02:55:25 <Kinnison> :-)
02:55:44 <Kinnison> It's one of my few useful insights
02:55:50 <__monty__> :t (flip $)
02:55:51 <lambdabot> (a -> b -> c) -> b -> a -> c
03:01:17 <Gurkenglas> It's too bad I can't dispense such insights in my code by bracketing output functions without it giving the suggestion to remove the useless brackets
03:02:03 <Kinnison> heh
03:05:46 <trap_exit> tgma
03:07:29 <Gurkenglas> "tgma"?
03:08:24 <r444> Gurkenglas: you can silence hlint by inserting some special comment just above the line
03:08:43 <r444> i don't remember how it's supposed to look exactly, you have to google that
03:25:45 * hackagebot monad-logger 0.3.8 - A class of monads which can log messages.  http://hackage.haskell.org/package/monad-logger-0.3.8 (MichaelSnoyman)
03:26:51 <pharpend> anyone know how to create dummy Handles, as in System.IO.Handle?
03:27:37 <Axman6> what do you mean by dummy?
03:27:43 <pharpend> u
03:27:45 <pharpend> *um
03:27:50 <pharpend> I'm trying to test a function
03:27:56 <pharpend> which writes to a handle
03:28:06 <Axman6> use stdout?
03:28:10 <pharpend> ehh maybe
03:28:24 <Axman6> or just create a file
03:28:30 <pharpend> a temp file might work
03:28:37 <Axman6> @hoogle FileName -> IO Handle
03:28:39 <lambdabot> Warning: Unknown type FileName
03:28:40 <lambdabot> Control.Exception.Base throwIO :: Exception e => e -> IO a
03:28:40 <lambdabot> Control.Exception throwIO :: Exception e => e -> IO a
03:28:43 <Axman6> bah
03:28:50 <Kinnison> @hoogle FilePath -> IO Handle
03:28:51 <lambdabot> System.IO openBinaryFile :: FilePath -> IOMode -> IO Handle
03:28:51 <lambdabot> GHC.IO.Handle.FD openBinaryFile :: FilePath -> IOMode -> IO Handle
03:28:51 <lambdabot> System.IO openFile :: FilePath -> IOMode -> IO Handle
03:29:14 <ClaudiusMaximus> @hoogle IO (FilePath, Handle)
03:29:15 <lambdabot> System.Posix.Temp mkstemp :: String -> IO (FilePath, Handle)
03:29:15 <lambdabot> System.IO openBinaryTempFile :: FilePath -> String -> IO (FilePath, Handle)
03:29:15 <lambdabot> System.IO openBinaryTempFileWithDefaultPermissions :: FilePath -> String -> IO (FilePath, Handle)
03:29:15 <Axman6> uh right
03:29:36 <Kinnison> ClaudiusMaximus: good idea :-)
03:34:36 <agocorona> why not an openBinaryTempFileWithDefaultPermissions factory?
03:35:56 <Axman6> factory?
03:36:03 <agocorona> to get a larger name
03:36:28 <Axman6> oh right, I missed that one, it's massive
03:42:23 <fProgrammer> Quick question: doing list comprehension correctly http://pastie.org/9695167
03:43:44 <fProgrammer> anyone?
03:44:21 <srenatus> huh pastie.org banned my ip?
03:44:46 <fProgrammer> its public, do prefer any other site?
03:45:06 <Kinnison> Paste code/errors: http://lpaste.net/new/haskell
03:45:09 <Kinnison> fProgrammer: ^^
03:46:10 <fProgrammer> Kinnison: Thanks, http://lpaste.net/113742
03:46:58 <Kinnison> "charMap fst(zipped) snd(zipped)" looks odd
03:47:16 <Kinnison> you probably want charMap (fst zipped) (snd zipped)
03:47:27 <fProgrammer> Kinnison: Oh lemme try
03:47:34 <shiona_> yea, haskell doesn't use parentheses to mark function call (and parameters), but evaluation order
03:47:44 <Kinnison> or, perhaps more usefully, (uncurry charMap) zipped
03:48:03 <strawhatter> Hey guys.
03:48:17 <shiona_> you were passing charMap the parameters 'fst', 'zipped', 'snd', and 'zipped'
03:48:28 <fProgrammer> Kinnison: that works, thanks
03:48:48 <Kinnison> fProgrammer: Are you understanding shiona_'s explanation?
03:49:05 <strawhatter> From what I understand, is there any way for Haskell to randomly generate integers?
03:49:26 <fProgrammer> Kinnison: Yes I got it, thanks
03:49:28 <Kinnison> @hoogle StdRandom
03:49:29 <lambdabot> System.Random getStdRandom :: (StdGen -> (a, StdGen)) -> IO a
03:49:52 <strawhatter> stdRandom. Thank you for the help!
04:02:34 <phaazon_> hi! I’d like to write a few blog threads about graphics in Haskell (and then introduce my 3D engine), but I don’t know which platform to use. I already have a blog at blogspot but I’m not in fond of it… any idea?
04:03:51 <oconnore> hey, what is the most appropriate way to acquire real world haskell in local HTML?
04:04:58 <Kinnison> phaazon_: I like ikiwiki
04:05:31 <phaazon__> ikiwiki? I’m gonna check that
04:05:32 <phaazon__> thanks
04:07:13 <phaazon__> well
04:07:34 <phaazon__> maybe WordPress actually…
04:07:49 <phaazon__> blogspot is ugly and I really don’t like how we customize it
04:07:49 * Kinnison grins.  I have a no PHP rule :-)
04:07:55 <agocorona> do lamdabot can display HTML in a webchat?
04:07:58 <phaazon__> oh is it?
04:08:00 <phaazon__> it’s in PHP?
04:08:14 * phaazon__ runs away then
04:08:16 <Kinnison> agocorona: It seems unlikely
04:08:22 <Kinnison> phaazon_: WordPress? yeah
04:08:39 <phaazon__> isn’t there a Haskell one?
04:09:04 <Kinnison> I considered writing a simple haskell blog engine to read my ikiwiki input, but then decided to stick with ikiwiki :-)
04:09:44 <phaazon__> do you have a link?
04:09:55 <clrnd> PHP while terribly inmoral for a programming language, is not that bad for web development (?)
04:10:22 <ij> I doubt it.
04:10:38 <Kinnison> If you can afford a full-time security engineer to look after your server, it's acceptable
04:10:47 <Kinnison> however, this is not #php-bashing
04:10:50 <exio4> a single one? you need a pair of them Kinnison
04:10:53 <Kinnison> phaazon__:  a link to what?
04:10:59 <phaazon__> to your blog
04:11:08 <Kinnison> Oh, it's currently down because I'm moving hosts
04:11:11 <clrnd> that channel exists??! brb
04:11:43 <Kinnison> however if you want to see an ikiwiki based blog then jmtd.net and blog.liw.fi are friends' blogs run on ikiwiki
04:12:23 <phaazon__> I’m gonna check that, thank you
04:12:51 <Kinnison> You can also get ikiwiki sites up quickly if you use branchable.com
04:13:46 <phaazon__> I guess I could also write mine
04:19:13 <ClaudiusMaximus> phaazon__: hakyll static site generator and BlogLiterately wordpress interface might be interesting for you
04:20:18 <phaazon__> interesting ClaudiusMaximus
04:20:19 <phaazon__> thank you
04:21:49 <phaazon__> btw
04:21:55 <phaazon__> is there a way to connect hscolour to vim?
04:36:32 <lpaste> pharpend pasted “weird cabal error” at http://lpaste.net/113743
04:36:45 <pharpend> can someone help me with that ^
04:37:15 <pharpend> phaazon__: what is hscolour?
04:37:32 <pharpend> nm, googled it
04:37:43 <phaazon__> a tool to colorify haskell sources
04:38:09 <pharpend> ah okay
04:38:13 <pharpend> why do you need it in vim?
04:38:20 <pharpend> vim highlights haskell, iirc
04:38:34 <pharpend> poorly, but vim highlights everything poorly
04:38:58 <saep> pharpend: You have to put the '...Journal' module into the "exposed-modules" or "other-modules" section in your cabal file.
04:39:07 <ClaudiusMaximus> pharpend: looks like some modules are not listed in the cabal file (all modules must be listed, either in exposed-modules: or in other-modules:)
04:39:19 <pharpend> saep: you would think having gotten that error a million times, I would remember to do that by now. thank you
04:39:56 <pharpend> thak you saep, ClaudiusMaximus
05:01:30 <clrnd> pharpend, I had the exactly same error yesterday damn, cabal could communicate that better ...
05:34:31 <thomas146> @help
05:34:32 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:50:04 <clrnd> @help list
05:50:05 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
06:24:27 <zipper> Hey could someone help explain what eitherDecode decode and encode do. I get that they convert Bytestrings to a form of JSON that haskell gets or something.
06:25:21 <zipper> I want to be able to tell what is in the value part of a JSON file. Like when it's a hashmap. I read that I can use fmap on a hashmap.
06:27:46 <tdammers> Aeson converts in a two-step kind of process
06:28:00 <zipper> tdammers: I'm listening.
06:28:04 <tdammers> decoding goes ByteString -> JSON data structures -> typed data structured
06:28:05 <tdammers> *s
06:28:24 <tdammers> where your typed data structures are whatever you want them to be, they just need to implement FromJSON
06:28:30 <zipper> tdammers: I get decoding puts it in a maybe
06:28:53 <tdammers> ok, now the Maybe is just so that the decoder can fail on invalid JSON or parser errors or some such
06:29:00 <hyPiRion> Hrm. Say I want to create a function f :: StateT s IO a -> StateT t IO a. Is that possible without knowing the initial s? I would expect so, but I have a hard time figuring it out
06:29:18 <tdammers> it won't tell you *why* it failed though, there's also an Either variant for that
06:29:41 <simpson> hyPiRion: You'll have to have some sort of function from s -> t.
06:29:54 <hyPiRion> simpson: right, f :: import Control.Monad
06:29:55 <hyPiRion> import Control.Monad.Except
06:29:55 <hyPiRion> import Control.Monad.Reader
06:30:00 <hyPiRion> whoops, wrong copypaste
06:30:19 <zipper> tdammers: Where my typed data structure is still something I don't yet know. However I think I want a map. Key value pairs which I can get with `HashMap Text Value` which is being described as a JSON object.
06:30:37 <tdammers> I think you're confusing two things here
06:30:44 <hyPiRion> simpson: the actual signature I want is f :: (s -> t) -> StateT s IO a -> StateT t
06:30:49 <tdammers> the JSON Object provided by Aeson uses HashMap internally
06:30:56 <tdammers> but HashMap itself also implements FromJSON
06:31:13 <zipper> tdammers: According to ... http://www.seas.upenn.edu/~cis194/hw/06-monoid-io.pdf page 4
06:31:36 <zipper> tdammers: That is the exercise I am doing.
06:32:22 <zipper> I think that since the JSON file I have is a map of sorts I expect to use Hashmap
06:32:37 <tdammers> ah, I see where the confusion comes from
06:32:45 <zipper> tdammers: Where?
06:32:47 <tdammers> Value is a trivial instance of FromJSON
06:33:04 <zipper> tdammers: I don't even get what value really is.
06:33:15 <tdammers> Value is kind of an AST for JSON
06:33:22 <tdammers> look it up on hackage
06:33:39 <tdammers> it has constructors for Objects, Arrays, Strings, Doubles, etc.
06:33:44 <dramforever> Has anyone written a a-little-more-than-just-simple interpreter?
06:33:56 <tdammers> dramforever: interpreter for what?
06:34:05 <dramforever> some programming language
06:34:11 <tdammers> zipper: basically, Value is kind of a DOM for JSON
06:34:19 <dramforever> in haskell, of course
06:34:23 <gregnwosu> dramforever: just working on a problem in codewars, but its still fairly simple to be honest
06:34:25 <tdammers> dramforever: I'm currently writing a JavaScript interpreter. In Haskell, of course.
06:34:27 <zipper> tdammers: Do I need to know what Value is to succeed in this assignment?
06:34:48 <dramforever> tdammers: How do you take care of values?
06:34:55 <tdammers> zipper: haven't looked too deeply... but it's a good idea to know it anyway when working with Aeson
06:34:58 <gregnwosu> http://www.codewars.com/kata/543833d86f032f0942000264/train/haskell
06:35:01 <dramforever> or, how do you take care of types?
06:35:14 <tdammers> I have a sum type that can represent any valid JS value
06:35:36 <zipper> tdammers: I am really confused. I can't get an easy understanding of how JSON is being represented by decode.
06:35:52 <zipper> I don't get how JSON is being represented by decode.
06:35:54 <dramforever> hmm...Why I feel that it's a bit too much wrapping and unwrapping
06:35:57 <tdammers> zipper: decode doesn't represent anything.
06:36:00 <dramforever> it does not look like haskell
06:36:25 <tdammers> dramforever: well, I'm lifting on the existing Language.ECMAScript parser
06:36:42 <zipper> tdammers: ok it represents it in a Maybe a where I assume a is of type Value. no?
06:36:49 <zipper> tdammers: WHat does decode do/
06:36:52 <tdammers> zipper: forget the Maybe for now
06:36:53 <zipper> *?
06:37:00 <zipper> tdammers: What should I know?
06:37:07 <tdammers> just assume it's FromJSON a => ByteString -> a
06:37:10 <albeit> Why is there not an implementation of STM.TQueue using MVars instead of TVars? (Purely functional list reversal queue)
06:37:22 <tdammers> but really, it's a two-step process
06:37:28 <tdammers> the first step is ByteString -> Value
06:38:03 <dramforever> tdammers: I keep writing this:
06:38:12 <dramforever> case blah of
06:38:24 <tdammers> dramforever: ah, yeah... there's a lot of pattern matching going on
06:38:38 <tdammers> dramforever: I don't really see a better way though
06:38:47 <tdammers> dramforever: not if you want to map the semantics correctly
06:38:55 <dramforever> it's also how I realized that I need rank-n types
06:39:17 <dramforever> I have a data Value = IntVal Int | DoubleVal Double
06:39:45 <dramforever> then I have liftOrd :: (forall a. Ord a => a -> a -> Bool) -> Value -> Value -> Bool
06:40:08 <tdammers> I don't have an Ord instance for my Value
06:40:12 <dramforever> well, the (Value -> Value -> Bool) part is actually in a error handling monad
06:40:16 <zipper> tdammers: I am thinking of a proper type to stand in place of a in your example and only Hashmap Text Value comes to mind.
06:40:27 <tdammers> zipper: look up the definition of Value
06:40:29 <dramforever> and I had to lift the (>), (<) ... etc
06:40:33 <tdammers> zipper: I mean it. Look it up.
06:40:36 <dramforever> tdammers: oops
06:40:53 * hackagebot haeredes 0.4.3 - Confirm delegation of NS and MX records.  http://hackage.haskell.org/package/haeredes-0.4.3 (MichaelOrlitzky)
06:40:54 <zipper> tdammers: I am looking at http://hackage.haskell.org/package/aeson haven't found value yet but I expect to.
06:40:56 <dramforever> looks like we have two Value's together
06:41:15 <dramforever> zipper: click on the Value on a type sig
06:41:20 <dramforever> if you see any
06:41:44 <dramforever> http://hackage.haskell.org/package/aeson-0.8.0.2/docs/Data-Aeson.html#t:Value
06:41:47 <dramforever> here it is
06:42:45 <tdammers> ^ that one
06:43:36 <dramforever> tdammers: I think the biggest problem I have is about types
06:43:57 <tdammers> well, yes... you are implementing a dynamic type on top of a static type system
06:43:59 <tdammers> :)
06:44:11 <dramforever> and Dynamic never works well
06:44:20 <tdammers> but actually, my Value is pretty close to Aeson's Value
06:44:34 <tdammers> except that it has an additional constructor for object references
06:44:47 <dramforever> yes, yes
06:44:48 <tdammers> (objects themselves have a separate type that can model objects, functions, and arrays)
06:45:00 <tdammers> (I'm not quite done fleshing that one out)
06:45:47 <dramforever> and also we are implementing mutable data with immutable (well, barely-mutable) data
06:46:37 <blicero_> how to apply a tuple of functions to a tuple of values
06:47:14 <tdammers> dramforever: that, too... although StateT is probably good enough for JS
06:47:21 <dramforever> huh?
06:47:23 <albeit> @pl \(a,b) (f,g) -> (f a, g b)
06:47:24 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. flip id) . flip . (((.) . (,)) .) . flip id)
06:47:28 <albeit> Oh man
06:47:33 <blicero_> haha
06:47:40 <dramforever> no, you don't want that
06:48:11 <tdammers> zipWith $ ?
06:48:16 <dramforever> the \ -> one is better
06:48:26 <dramforever> ha
06:48:50 <dramforever> I remembered a acme package called acme-cader, iirc
06:49:03 <dramforever> but, seriously
06:49:20 <dramforever> why wouldn't you just destruct the tuple
06:49:43 <tdammers> tuples are kind of an antipattern imo
06:49:51 <blicero_> hmm
06:50:13 <tdammers> they're non-types
06:50:31 <bam365> tdammers: how so?
06:50:31 <tdammers> even data Pair a b = Pair a b is more meaningful than a tuple
06:50:49 <tdammers> (Int, Int) -- what does this mean? who knows
06:50:56 <dramforever> well
06:51:03 <tdammers> Coords Int Int -- ah, probably coordinates in a discrete 2-space
06:51:20 <bam365> tdammers: what does a single Int "mean"?
06:51:35 <tdammers> bam365: "a discrete unit-less number" :P
06:51:49 <dramforever> well
06:51:58 <dramforever> we have to stop at something
06:52:01 <tdammers> yeah
06:52:17 <dramforever> tdammers: what does Value mean
06:52:19 <dramforever> - a Value
06:52:20 <tdammers> and actually, demanding a KeyValuePair a b for things like Data.Map.fromList would be completely silly
06:52:26 <joe9> tdammers: good comparision with (x,y) vs using a Pair. I like the Pair idea better
06:52:27 <dramforever> oh my god...
06:52:27 <albeit> tdammers: Can Control.Arrow functions like (***) be used on datatypeified-tuples?
06:52:36 <dramforever> oh!
06:52:40 <dramforever> :t (***)
06:52:41 <tdammers> dramforever: Value can be quantified with a namespace - Data.Aeson.Value is more descriptive than just Value
06:52:42 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
06:53:08 <blicero_> i got
06:53:14 <blicero_> :t max *** max
06:53:15 <lambdabot> (Ord a, Ord b') => (a, b') -> (a -> a, b' -> b')
06:53:26 <blicero_> then how to apply that
06:53:41 <dramforever> :t spp
06:53:43 <lambdabot>     Not in scope: ‘spp’
06:53:43 <lambdabot>     Perhaps you meant one of these:
06:53:43 <lambdabot>       ‘app’ (imported from Control.Arrow),
06:53:45 <belst> (max *** max) (a, b)
06:53:46 <dramforever> :t app
06:53:48 <lambdabot> ArrowApply a => a (a b c, b) c
06:53:54 <dramforever> no
06:54:08 <albeit> Okay
06:54:14 <dramforever> ...
06:54:32 <dramforever> blicero_: seriously
06:54:34 <tdammers> I really should get (***) tattooed on my arm or sth
06:54:45 <albeit> Are those arrow function specific to tuples? I only see them used with tuples, but is that just because they are the most obvious use-case?
06:54:53 <dramforever> no
06:54:59 <wei2912> :t (=>)
06:55:00 <lambdabot> parse error on input ‘=>’
06:55:02 <dramforever> it's because arrow notation makes tuples
06:55:05 <wei2912> :t (->)
06:55:06 <lambdabot> parse error on input ‘->’
06:55:10 <nshepperd> :t uncurry (***)
06:55:11 <lambdabot> Arrow a => (a b c, a b' c') -> a (b, b') (c, c')
06:55:52 <dramforever> blicero_: ha! nshepperd got it
06:55:54 * hackagebot linguistic-ordinals 0.1.0.0 - Express Integral types as linguistic ordinals (1st, 2nd, 3rd, etc)  http://hackage.haskell.org/package/linguistic-ordinals-0.1.0.0 (ElliotRobinson)
06:56:01 <blicero_> nice
06:56:39 <albeit> So you can you arrows on appropriate items, but you're usually going to get some tuple form as  a result?
06:56:40 <dramforever> :t uncurry (***) :: ((a -> a'), (b -> b')) -> (a, b) -> (a', b')
06:56:42 <lambdabot> (a -> a', b -> b') -> (a, b) -> (a', b')
06:56:53 <dramforever> albeit: you know arrow notation?
06:57:00 <dramforever> proc foo -> fo
06:57:01 <dramforever> proc foo -> do
06:57:09 <dramforever> and foo <- bar -< baz
06:57:14 <albeit> dramforever: No, just very infrequent use of (***) and others
06:57:24 <gcganley> arrows are spooky, i grok them at a very small level but theyre scary
06:57:30 <zipper> tdammers: I did read on what a Value is. However I don't see a clear path on converting my JSON into a value since it's got so manyu fields I can't encode it in a type.
06:57:30 <dramforever> yep
06:57:49 <zipper> tdammers: http://www.seas.upenn.edu/~cis194/extras/06-monoid-io/markets.json
06:57:50 <dramforever> zipper: how come
06:57:56 <gcganley> :t (<<<)
06:57:57 <lambdabot> Category cat => cat b c -> cat a b -> cat a c
06:58:04 <gcganley> :t (.)
06:58:05 <lambdabot> (b -> c) -> (a -> b) -> a -> c
06:58:09 <EvanR> zipper: heh check out this https://hackage.haskell.org/package/json-autotype-0.2.1.4
06:58:15 <zipper> dramforever: Because in the docs they advise encoding of my JSON in a type
06:58:25 <gcganley> :t (>>>)
06:58:27 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
06:58:29 <nshepperd> it seems like usually the stuff in Data.Arrow is just used as a bunch of tuple / either combinators
06:58:31 <gcganley> :t swap (.)
06:58:32 <lambdabot>     Couldn't match expected type ‘(a, b)’
06:58:33 <lambdabot>                 with actual type ‘(b0 -> c0) -> (a0 -> b0) -> a0 -> c0’
06:58:33 <lambdabot>     Probable cause: ‘(.)’ is applied to too few arguments
06:58:40 <zipper> EvanR: That might confuse me even more but here goes.
06:58:46 <nshepperd> with the Arrow (->) instance
06:58:48 <gcganley> :t (swap .)
06:58:49 <lambdabot> (a -> (a1, b)) -> a -> (b, a1)
06:58:54 <EvanR> its a tool to type out the types for you
06:58:56 <nshepperd> er, Control.Arrow
06:59:04 <dramforever> :t swap
06:59:05 <lambdabot> (a, b) -> (b, a)
06:59:16 <dramforever> @info swap
06:59:17 <lambdabot> swap
06:59:27 <Fuco> after updating to libmpd 0.9 something I can no longer use Path and Value types. When I try to import the package which defines them, I get an error saying it's a "Hidden package". What does that mean?
06:59:36 <gcganley> i always think of <<< as function comp and >>> as the swap order
07:00:08 <nshepperd> :t uncurry bimap
07:00:09 <lambdabot> Bifunctor p => (a -> b, c -> d) -> p a c -> p b d
07:00:18 <gcganley> ok what are bifunctors
07:00:36 <gcganley> i understand they are a stepping stone to arrows but are there any papers on them?
07:00:37 <nshepperd> :t uncurry bimap :: (a -> b, c -> d) -> (a,c) -> (b,d)
07:00:38 <lambdabot> (a -> b, c -> d) -> (a, c) -> (b, d)
07:00:39 <gcganley> ill google
07:01:09 <gcganley> :t (&&&)
07:01:10 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
07:01:25 <nshepperd> the basic bifunctor is a pair, I never bothered learning any others
07:01:40 <EvanR> zipper: you dont have to decode json as a custom type, though it would be good if you did. you can use the json value directly
07:02:05 <dramforever> zipper: maybe decode it as a Map
07:02:09 <zipper> EvanR: I've been looking at this issue for a while now.
07:02:10 <EvanR> you just have to handle all the possible missing cases
07:02:25 <zipper> dramforever: That's what I am thinking of doing.
07:02:43 <bam365> zipper: you need to define a Haskell type called "Market" or something similar that implements FromJSON and ToJSON
07:03:02 <EvanR> or just FromJSON
07:03:02 <zipper> dramforever: A map is an Object. With constructor Hashmap Text Value
07:03:12 <gcganley> wait so a bifunctor is a just a pair of... functions or functors...
07:03:17 <tdammers> if all you need is a key-value map, just decode to Value, and pattern match on the Object constructor
07:03:31 <zipper> bam365: That type would have too many entries.
07:03:46 <EvanR> zipper: to lookup stuff from an Object, you need to import Hashmap for H.lookup, and use OverloadedStrings to use "stringLiterals" as Text
07:04:29 <zipper> EvanR: I haven't seen the need for H.lookup since it seems to be in the aeson package.
07:04:37 <EvanR> ah ok
07:04:43 <zipper> http://hackage.haskell.org/package/aeson-0.8.0.2/docs/Data-Aeson.html#t:Object
07:04:46 <zipper> EvanR: ^
07:05:09 <zipper> Oject is the type and Hashmap is a value constructor.
07:05:24 <albeit> Does deriving (Show) for a datatype affect runtime performance, or just compile>
07:06:03 <EvanR> zipper: hm. i dont see an operator for doing the lookup outside of the parsing phase
07:06:25 <EvanR> but its probably a better idea to decode to a real type anyway
07:06:25 <zipper> EvanR: fmap?
07:06:37 <nshepperd> gcganley: a bifunctor is a thing with two type parameters, where you can fmap over both of them
07:06:39 <EvanR> fmap on an object? thats not lookup
07:06:59 <zipper> EvanR: It's not a lookup but for now all I care about it the value not they key.
07:07:22 <EvanR> fine, i was just talking about general use of an Object without conversion
07:07:23 <nshepperd> gcganley: (,) and Either, for example
07:07:24 <EvanR> without parsing
07:07:46 <EvanR> youd need H.lookup
07:08:15 <zipper> EvanR: I'm gettinh way ahead of myself all I have understood is how to read the json file into a bytestring. I can't access the data in the bytestring using decode or eitherDecode
07:08:15 <gcganley> nshepperd: oh thats wicked
07:08:44 <EvanR> zipper: as a first step, decode myByteString :: Maybe Value
07:09:18 <EvanR> once you have the instances set up you can instead to, decode myByteString :: Maybe Market
07:09:50 <sbidin> I enabled Rank2Types and FlexibleContexts. Then I did (type A a = Num a => [(a, Double)]). Then, defining (test = zip "test" [1..4]) fails to typecheck *but only on runtime, when actually used*? What's happening?
07:09:57 <zipper> EvanR: hmmm I don't get it. I didn't know the type was called Value.
07:10:03 <sbidin> It typechecks fine during compile time.
07:10:18 <EvanR> zipper: Value is the type representing raw generic json data
07:10:19 <zipper> I thought stuff like Text Object etc are examples of Value
07:10:43 <sbidin> Sorry, defining (test = zip "test" [1..4] :: A Char).
07:10:43 <nshepperd> > bimap show (+2) (0, 0)
07:10:45 <lambdabot>  ("0",2)
07:11:08 <EvanR> zipper: well its a little confusing, Object is the name of a constructor for Value, its also a type synonym for HashMap Text Value, two different things
07:11:20 <dramforever> Weird...
07:11:27 <EvanR> zipper: data Value = Object !Object | Null | Bool !Bool | ...
07:11:32 <dramforever> Maybe Traversable is better called Traverse
07:11:44 <zipper> EvanR: Thanks
07:12:48 <EvanR> type names and constructor names go in two namespaces, so they can collide
07:13:04 <nshepperd> nah I think Traversable and Foldable are good descriptive names
07:13:29 <nshepperd> although you have to type three more letters
07:13:32 <sbidin> Turns out my problem had much to do with GHCi acting weird. Works fine when actually compiled.
07:13:32 <sbidin>  
07:13:34 <dramforever> well, not if you have DataKinds, but you well proabably never see one
07:13:34 <zipper> This is  rough. SMH.
07:13:44 <dramforever> nshepperd: Showable
07:13:47 <dramforever> Readable
07:14:54 <myfreeweb> hey everyone. I'm trying to make a FunctionMap for Web.Simple.Templates like this here: https://github.com/alevy/mappend/blob/master/Blog/Helpers.hs but it says Couldn't match type ‘Function’ with ‘(t0, Function)’
07:16:24 <myfreeweb> hmm, looks like a ClassyPrelude problem
07:16:35 <dramforever> myfreeweb: I assume that you have problems with helperFunctions
07:16:53 <dramforever> what's the type of fromList
07:17:02 <nshepperd> (Showable a, Readable b, Traversable f, Foldable g) =>  -- I guess it's sort of repetitive to have a bunch of constraints all ending with -able
07:17:05 <myfreeweb> IsSequence seq => [Element seq] -> seq
07:17:15 <simg> hi, hopefully simple question, how would I unpack a "Maybe Text" value
07:17:28 <dramforever> simg: what do you mean by unpack
07:17:38 <dramforever> :t T.unpack
07:17:39 <lambdabot>     Not in scope: ‘T.unpack’
07:17:39 <lambdabot>     Perhaps you meant ‘BS.unpack’ (imported from Data.ByteString)
07:17:43 <EvanR> IReadableFactoryable
07:17:53 <simg> dramforver: Data.Text.unpack
07:18:06 <dramforever> :t fmap Data.Text.unpack :: Maybe Data.Text.Text -> Maybe [Char]
07:18:07 <lambdabot> Maybe Data.Text.Internal.Text -> Maybe [Char]
07:18:29 <myfreeweb> fmap or Control.Applicative's <$>
07:18:30 <dramforever> simg: fmap Data.Text.unpack
07:18:37 <tdammers> simg: fmap, fromMaybe, maybe, <$>, liftM, ...
07:18:56 <dramforever> well, fmap is in Prelude
07:19:05 <zipper> EvanR: Don't I have to tell decode that I want Value to form a Hashmap Text Value?
07:19:15 <EvanR> zipper: no
07:19:22 <simg> thanks for all answers :). won't this make my code "clunky" since I'd have to apply it to every database value that might be null?
07:19:23 <dramforever> the types will tell it
07:19:27 <EvanR> your json data may or may not have an object at the top level
07:19:42 <dramforever> :t malloc
07:19:43 <lambdabot> Not in scope: ‘malloc’
07:19:48 <dramforever> :t Foreign.malloc
07:19:50 <lambdabot> Foreign.Storable.Storable a => IO (GHC.Ptr.Ptr a)
07:19:59 <myfreeweb> how does fromList even work in ClassyPrelude?!
07:20:02 <dramforever> see, malloc doesn't even have an argument
07:20:08 <dramforever> it mallocs one
07:20:41 <dramforever> so it's like int *ptr = new; in pseudo-C++
07:20:45 <EvanR> zipper: in your case, you will end up with Just (Object aHashMap)
07:21:03 <zipper> EvanR: Let's see how this goes.
07:21:39 <dramforever> myfreeweb: load the hs into ghci without the problematic definitions and :t fromList
07:21:56 <myfreeweb> already posted here: IsSequence seq => [Element seq] -> seq
07:22:11 <dramforever> so, :i Element
07:22:30 <dramforever> oh wait
07:22:35 <SrPx> Doesn't a formula that tests each boolean string of length N force SAT to execute at least `2^N` tests? Essentially making it unsolvable in subpoly times?
07:22:49 <SrPx> ex: http://lpaste.net/113746
07:22:50 <dramforever> is it in the new 7.8? overloaded lists?
07:23:03 <sinelaw> anyone used cabal-rpm successfully?
07:23:09 <SrPx> no idea why I asked here
07:24:50 <myfreeweb> dramforever: I have no idea... I just want to make a fscking hashmap :D
07:25:10 <dramforever> :i Element
07:25:15 <dramforever> put that into ghci
07:25:19 <dramforever> :i Function
07:25:34 <myfreeweb> well, that doesn't really help
07:25:43 <EvanR> > Data.Aeson.decode "[1,2,3]" :: Maybe [Int]
07:25:45 <lambdabot>  Not in scope: ‘Data.Aeson.decode’
07:25:45 <dramforever> what does ghci give you
07:25:46 <myfreeweb> type instance Element (Map k v) etc.
07:25:59 <dramforever> how about :i Function
07:26:09 <dramforever> maybe you can post the output on lpaste
07:26:31 <myfreeweb> forget Function, I just want fromList [(1,2)] to work
07:26:36 <nshepperd> SrPx: Are you tryng to prove that SAT ∉ P?
07:26:51 <dramforever> myfreeweb: :i fromList
07:27:12 <myfreeweb> ...where fromList :: [Element seq] -> seq
07:27:22 <myfreeweb> doesn't tell me how to construct Element
07:27:39 <dramforever> post the output on http://lpaste.new/new/haskell
07:28:09 <SrPx> nshepperd: more like, trying to understand how this doesn't imply it... what I am missing?
07:28:37 <SrPx> seems quite obvious that if you can have an arbitrary formula, then you can just come up with a formula that forces you to test each possible input
07:28:45 <myfreeweb> got it, just need to use mapFromList
07:29:32 <myfreeweb> mono-traversable and classy-prelude need real documentation with examples, not just auto-generated haddock
07:30:55 * hackagebot data-interval 1.1.0 - Interval arithmetic for both open and closed intervals  http://hackage.haskell.org/package/data-interval-1.1.0 (MasahiroSakai)
07:31:13 <nshepperd> SrPx: I think "polynomial" here means "polynomial in the length of the formula"
07:31:30 <zipper> tdammers: EvanR It says HashMap is out of scope https://gist.github.com/urbanslug/bf34afacce3f7c70baee
07:31:47 <dramforever> @info HashMap
07:31:47 <lambdabot> HashMap
07:31:55 <dramforever> @src HashMap
07:31:55 <lambdabot> Source not found. Are you on drugs?
07:31:59 <dramforever> ...
07:32:03 <zipper> dramforever: LMAO
07:32:05 <EvanR> zipper: import Data.HashMap as H ?
07:32:11 <zipper> Are you on drugs lmao
07:32:14 <dramforever> qualified??
07:32:19 <dramforever> nope abs not
07:32:30 <nshepperd> SrPx: because it goes without saying that any SAT solver at least needs to scan the whole input formula before returning an answer
07:32:40 <dramforever> zipper: http://hackage.haskell.org/package/unordered-containers
07:32:41 <EvanR> zipper: watch out there because you imported two different things as T
07:32:44 <dramforever> you'd want one
07:32:58 <zipper> EvanR: I would've expected it to come with the aeson package.
07:33:21 <dramforever> well, we can have a very very long formula with just one var
07:33:26 <EvanR> if you want to use HashMap or Scientific or whatever raw Values are made of, you need to import those libs
07:33:50 <EvanR> just like you are importing Text and ByteString
07:34:28 <dramforever> > (\x -> not . not . not . not . not . not . not . not $ x) True
07:34:29 <lambdabot>  True
07:34:32 <dramforever> > (\x -> not . not . not . not . not . not . not . not $ x) Faslse
07:34:34 <lambdabot>  Not in scope: data constructor ‘Faslse’
07:34:34 <lambdabot>  Perhaps you meant ‘False’ (imported from Data.Bool)
07:34:35 <dramforever> > (\x -> not . not . not . not . not . not . not . not $ x) False
07:34:37 <lambdabot>  False
07:35:32 <nshepperd> SrPx: I think you can see why it's sort of "cheating" to present a formula of length 2^N where N is the number of variables
07:35:55 * hackagebot tagged 0.7.3 - Haskell 98 phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-0.7.3 (EdwardKmett)
07:35:57 * hackagebot bifunctors 4.2 - Bifunctors  http://hackage.haskell.org/package/bifunctors-4.2 (EdwardKmett)
07:35:58 <EvanR> zipper: when you get around to writing a FromJSON instance, you dont need to use the hashmap directly. but for now you do
07:39:36 <srpx> nshepperd: but i just read it is on the num of vars...
07:40:36 <juanpablo_> Anybody knows of an scheduler daemon written in Haskell? Looking to avoid cron
07:41:21 <zipper> Even after an import of HashMap I get the same error https://gist.github.com/urbanslug/bf34afacce3f7c70baee
07:41:37 <EvanR> zipper: whats the error?
07:42:17 <EvanR> i see you have a mismatch in your pattern, Just (HashMap _ _) isnt a Value
07:42:56 <EvanR> and HashMap isnt a constructor
07:43:10 <zipper> EvanR: I thought HashMap is a value constructor
07:43:17 <EvanR> and what are you expecting, that you have an Object with exactly one field, which is a Y N string?
07:43:29 <EvanR> HashMap k v is a type
07:43:34 <EvanR> where k and v are types
07:43:36 <nshepperd> srpx: ah, that doesn't seem right. Because your argument is a valid counterexample to SAT running in O(Poly(number of variables))
07:44:08 <srpx> weird
07:44:10 <nshepperd> srpx: I think the proper definition would define the complexity of the input as (num. variables) + (length of formula)
07:44:10 <mbuffett1> How would I convert [30..37] to ["30".."37"]? I tried map read [30..37], but it says no instance arising for literal 30?
07:44:44 <srpx> makes more sense nshepperd
07:44:50 <nshepperd> or possibly (num. variables) * (formula length)
07:44:59 <Ferdirand> mbuffett1: don't you want map show then ?
07:45:03 <EvanR> zipper: paste the error next time
07:45:04 <simg> further clarification regarding Data.Text.unpacking a maybe value. (tried fmap / <$> / fromMaybe with no luck). What should this expression read:  ", transaction_type: " ++ T.unpack transaction_type            --transaction_type is a Maybe Text
07:46:04 <mbuffett1> Ferdirand: You're right, that's what I want, thanks
07:47:46 <srpx> nshepperd: I'm trying to find a proper definition
07:47:58 <srpx> it is hard to find the "correct stuff" on the matter
07:49:25 <aleneumann> quit
07:54:01 <nshepperd> actually, I guess you only need to consider the length of the formula
07:54:24 <nshepperd> since the solver only has to consider variables that appear in the formula
07:56:45 <vjeranc> what's the name of the thing that is the reason I can't define notElem = not . elem?
07:56:52 <zwer> > map show [30..37]
07:56:54 <lambdabot>  ["30","31","32","33","34","35","36","37"]
07:57:08 <EvanR> :t let notElem = not . elem in notElem
07:57:10 <wei2912> @help
07:57:10 <lambdabot>     Couldn't match type ‘[a1] -> Bool’ with ‘Bool’
07:57:10 <lambdabot>     Expected type: a1 -> Bool
07:57:10 <lambdabot>       Actual type: a1 -> [a1] -> Bool
07:57:10 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:57:20 <wei2912> :t not
07:57:21 <lambdabot> Bool -> Bool
07:57:26 <wei2912> :t elem
07:57:27 <lambdabot> Eq a => a -> [a] -> Bool
07:57:35 <EvanR> :t let notElem = not .: elem in notElem
07:57:36 <lambdabot>     Not in scope: ‘.:’
07:57:36 <lambdabot>     Perhaps you meant one of these:
07:57:36 <lambdabot>       ‘.’ (imported from Data.Function),
07:57:55 <wei2912> > let notElem = not . elem
07:57:57 <lambdabot>  not an expression: ‘let notElem = not . elem’
07:57:57 <nshepperd> since the solver only has to consider variables that appear in the formula
07:57:57 <fizbin> :t let notElem = (not .) . elem in notElem
07:57:59 <lambdabot> Eq a => a -> [a] -> Bool
07:58:03 <nshepperd> gah, cat
07:58:23 <EvanR> vjeranc: "type mismatch"
07:58:38 <fizbin> vjeranc: I don't know what the name is, really, but what you want is (not .) . elem
07:58:47 <wei2912> vjeranc: if i'm not mistaken, function composition only works on functions that take in and return the same types
07:58:48 <fizbin> Since elem takes two arguments.
07:58:50 <wei2912> :t (.)
07:58:51 <lambdabot> (b -> c) -> (a -> b) -> a -> c
07:58:56 <wei2912> vjeranc: oh wait, nvm
07:59:03 <srpx> nshepperd: that doesn't make sense for me though... the formula can be read and executed in linear time
07:59:35 <vjeranc> yep, it does seem like a type mismatch now when I see the type
07:59:36 <bam365> zipper: check this out: http://lpaste.net/113750
08:00:29 <fizbin> vjeranc: The pattern (f .) . g is a useful thing to remember as a way of saying \x y -> f (g x y)
08:00:59 <nshepperd> srpx: hmm? yes, that's why SAT is known to be in NP, because a proposed assignment can be *verified* in linear time by executing the formula
08:01:06 <vjeranc> fizbin: yep, thanks a lot!
08:01:35 <srpx> so if you account reading/executing the formula on the complexity then it just adds a constant factor, no?
08:02:02 <nshepperd> srpx: however, a solver doesn't have to run the formula once, but has to do it many times in order to find an assignment that satisfies
08:02:41 <srpx> true, but still at least 2^N times... the point is... I don't understand the meaning of the whole P=NP problem... so the problem is wether SAT can be solved in polynomial time, given that the formula is short? I don't get it :(
08:02:54 <srpx> I'm really curious for a proper definition, if anyone knows please link me
08:04:15 <simg> better question: How do I concatenate a Maybe Text value into a string. eg "myMaybeValue= " ++ T.unpack myMaybeValue
08:05:13 <EvanR> :t fromMaybe
08:05:14 <lambdabot> a -> Maybe a -> a
08:05:22 <EvanR> > "" (Just "foo")
08:05:23 <lambdabot>  Couldn't match expected type ‘Data.Maybe.Maybe [GHC.Types.Char]
08:05:23 <lambdabot>                                -> t’
08:05:23 <lambdabot>              with actual type ‘[GHC.Types.Char]’
08:05:31 <EvanR> > fromMaybe "" (Just "foo")
08:05:32 <lambdabot>  "foo"
08:05:38 <EvanR> > fromMaybe "" Nothing
08:05:40 <lambdabot>  ""
08:06:20 <EvanR> unpack a maybe text using fmap
08:06:43 <EvanR> then provide a default value for the nothing case (empty string) with fromMaybe
08:07:19 <nshepperd> srpx: I'm looking at the online drafts of 'Computational Complexity: A Modern Approach' and they seem to speak of "SAT = the language of satisfiable CNF formulae" as being NP complete
08:07:56 <zipper> How do I access the value of a HashMap like with pattern matching or something.
08:07:59 <zipper> *?
08:08:07 <EvanR> you cant
08:08:10 <simg> EvanR: thanks, will give that a go :)
08:08:33 <bam365> zipper: did you look at that lpaste?
08:08:41 <vanila> nshepperd, yeah, it's trivial (polynomial) to check if a claimed solution to SAT is valid - but it's very hard (nondeterministic polynomial) to actually find one
08:08:42 <godel> Hello, I'm having a problem that a where in a function is not detected. I get "not in scope <where defined function>". This error is pretty usual, how do I avoid it?
08:08:46 <zipper> bam365: Which lpaste?
08:08:52 <zipper> bam365: I didn't
08:09:01 <bam365> zipper: http://lpaste.net/113750
08:09:20 <EvanR> zipper: lookup :: k -> v -> HashMap k v -> Maybe v
08:09:29 <nshepperd> srpx: in that model you're looking for a turing machine that takes a CNF formula as input, and decides whether it is satisfiable in time polynomial in the length of its input
08:09:42 <nshepperd> srpx: that is, Poly(formula length)
08:10:24 <EvanR> zipper: note that a hashmap might have many values, not just one
08:10:27 <kadoban> godel: You'll have to show code
08:10:43 <godel> kadoban: ok
08:12:18 <godel> kadoban: http://pastebin.com/KGpMGcYU
08:12:28 <godel> wow, that highlighting sucks
08:12:52 <godel> kadoban: I get "Not in scope: ‘freshenAbs’"
08:13:09 <srpx> nshepperd: makes much more sense, thanks
08:13:11 <srpx> so That is the problem
08:13:13 <simg> EvanR: fromMaybe must be on the right lines, but how do I get the return type to be accepted by Data.Text.unpack? Unpacks accepts a "Text" type, not Any eg ---->  Couldn't match expected type `T.Text'  with actual type `a0 -> Maybe a0 -> a0'
08:13:37 <EvanR> simg: fmap unpack myMaybeText
08:13:55 <simg> EvanR;
08:14:53 <simg> EvanR: if I do that, it says that fmap expects an [], seems overkill to convert my single value to an array just so I can concatenate a "string"
08:14:58 <kadoban> godel: where only applies to the definition right before it
08:15:21 <simg> EvanR: and where does fromMaybe fit in to your last suggestion ?
08:15:28 <godel> kadoban: oh really?
08:15:40 <godel> that's a pity
08:16:09 <EvanR> simg: to convert a Maybe Text into a String, you can do fromMaybe "" (fmap T.unpack myMaybeText)
08:16:53 <biglama> hi, can someone gives me an example on how to use findWhen from Shelly ?
08:16:56 <EvanR> simg: fmap here is taking a Maybe a, not a list
08:17:06 <carter> simg: oh, i saw your thing on snap
08:17:09 <EvanR> :t fmap
08:17:11 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:17:17 <EvanR> :t T.unpack
08:17:19 <lambdabot>     Not in scope: ‘T.unpack’
08:17:19 <lambdabot>     Perhaps you meant ‘BS.unpack’ (imported from Data.ByteString)
08:17:22 <carter> simg: the many core GC issue only happens in the > 20 cores server setting
08:17:26 <EvanR> :t Data.Text.unpack
08:17:28 <lambdabot> Data.Text.Internal.Text -> String
08:17:57 <EvanR> :t fmap Data.Text.unpack
08:17:58 <lambdabot> Functor f => f Data.Text.Internal.Text -> f String
08:17:59 <simg> carter: Thanks :)
08:18:10 <EvanR> f = Maybe
08:18:11 <carter> simg: and theres lots of easy ways to mitigate
08:20:52 <simg> EvanR: fmap T.unpack myMaybeText fails compilation with ---> Couldn't match type `Maybe' with `[]'     Expected type: [T.Text]       Actual type: Maybe T.Text     In the second argument of `fmap', namely `myMaybeText'
08:21:13 <EvanR> simg: then you have a type error somewhere else
08:21:17 <simg> carter: I'll cross that bridge if I ever manage to write a working Haskell program :)
08:21:21 <carter> simg: lol
08:21:44 <asayers> godel: if you do your pattern matching using a case statement, you can share the where clause
08:21:48 <simg> EvanR: thanks, will think for a bit :)
08:22:06 <EvanR> simg: it thinks youre trying to generate a list for some reason, maybe the place where that expression is positioned
08:22:33 <EvanR> make sure you get parentheses right
08:23:13 <EvanR> note that [] (list) in this case might be referring to the type String = [Char]
08:24:18 <simg> EvanR: thanks. I must be missing something, because I thought Maybe was supposed to *uncomplicate* dealing with possible null values :/
08:25:00 <myfreeweb> it's supposed to make dealing with possible null values *safe*
08:25:03 <EvanR> simg: this situation is not that complicated. perhaps you are accidentally trying to ++ a String and a Maybe
08:25:57 * hackagebot aivika 3.0 - A multi-paradigm simulation library  http://hackage.haskell.org/package/aivika-3.0 (DavidSorokin)
08:25:59 * hackagebot aivika-experiment 3.0 - Simulation experiments for the Aivika library  http://hackage.haskell.org/package/aivika-experiment-3.0 (DavidSorokin)
08:26:01 * hackagebot aivika-experiment-chart 3.0 - Simulation experiments with charting for the Aivika library  http://hackage.haskell.org/package/aivika-experiment-chart-3.0 (DavidSorokin)
08:26:03 * hackagebot aivika-experiment-cairo 3.0 - Cairo backend for the Aivika simulation library  http://hackage.haskell.org/package/aivika-experiment-cairo-3.0 (DavidSorokin)
08:26:05 * hackagebot aivika-experiment-diagrams 3.0 - Diagrams backend for the Aivika simulation library  http://hackage.haskell.org/package/aivika-experiment-diagrams-3.0 (DavidSorokin)
08:26:26 <godel> asayers: ok, thanks
08:26:42 <aninhumer> Are there any existing libraries that use ST to simplify the creation of cyclic data structures?
08:27:17 <simg> myfreeweb: OK fair point :)
08:27:44 <EvanR> > "abc" ++ Just "123"
08:27:45 <lambdabot>  Couldn't match expected type ‘[GHC.Types.Char]’
08:27:46 <lambdabot>              with actual type ‘Data.Maybe.Maybe [GHC.Types.Char]’
08:27:52 <EvanR> > "abc" ++ Nothing
08:27:54 <lambdabot>  Couldn't match expected type ‘[GHC.Types.Char]’
08:27:54 <lambdabot>              with actual type ‘Data.Maybe.Maybe a0’
08:28:04 <hc> ("abc" ++) <$> Just "123"
08:28:09 <hc> > ("abc" ++) <$> Just "123"
08:28:10 <lambdabot>  Just "abc123"
08:28:20 <EvanR> > "abc" ++ (fromMaybe "" (Just "123"))
08:28:22 <lambdabot>  "abc123"
08:29:25 <EvanR> simg: you may come to appreciate programming with something more like legos than something more like jello ;)
08:30:47 <simg> EvanR: I hope so :)
08:30:57 * hackagebot aivika-transformers 3.0 - Transformers for the Aivika simulation library  http://hackage.haskell.org/package/aivika-transformers-3.0 (DavidSorokin)
08:30:59 * hackagebot hsay 1.0.0 - (ab)Use Google Translate as a speech synthesiser  http://hackage.haskell.org/package/hsay-1.0.0 (alexander)
08:31:51 <EvanR> or legos made of jello, which is what clojure is feeling like right now to me
08:32:19 <bergmark> simg: objective-c uncomplicates nulls by having weird defaults for it that only does what you want some of the time...
08:35:23 <Hodapp> hmm, I've still never written in ObjC
08:35:28 <Hodapp> has Swift caught on much?
08:35:37 <simg> bergmark: crazy idea. why not automatically cooerce nulls into empty string wherever it would be appropriate - eg string concatenation ?
08:36:03 <bergmark> simg: what if you don't want null to act as the empty string? it is not the empty string, after all
08:36:06 <EvanR> simg: php is over there ;)
08:36:47 <EvanR> haskell eschews automatic implicit conversion between different types
08:37:14 <godel> is there some kind of guide of how subsitution should be made on typed lambda calculus? Google is not helping me
08:37:37 <simg> bergmark: then have a way forcing nulls to be nulls if you need them to be, but most often an empty string would do.
08:37:49 <bergmark> simg: i think "Nothing" would be equally suitable when converting Nothing to astring, and indeed that's what show does
08:38:11 <EvanR> right, auto empty null is really annoying when im trying to debug
08:38:34 <simg> bergmark: I was assuming Nothing and Null were kind of the same thing?
08:38:47 <EvanR> simg: what you want is to use empty string, not Nothing, so you should really get out of the nothing as soon as possible, using fromMaybe
08:38:51 <bergmark> Maybe is more powerful than nulls
08:39:09 <EvanR> you want an empty string, so use an empty string
08:39:10 <bergmark> you can not express Just Nothing :: Maybe (Maybe a) with null
08:40:15 <simg> why do most languages fail when trying to call .toString() on a value than contains a null ? Trying to think of a single example where it wouldn't be better to return an empty string
08:40:43 <lpaste> angerman pasted “No title” at http://lpaste.net/5428798946581413888
08:40:50 <EvanR> javas tendency to crash when an unexpected null reference appears is way better than the alternative of just coming up with some random value
08:41:17 <simg> this also true of ++ in Haskell.
08:41:20 <EvanR> crashing is the best case scenario when your code is incorrect
08:41:39 <simg> a null reference isn't the same as a null value
08:41:47 <myfreeweb> not compiling is better than crashing
08:41:52 <bergmark> simg: the earlier you can get an error the better
08:42:15 <bergmark> a NullPointerException in my java log is way better than a user seing "Hello, !" in their e-amil
08:42:18 <bergmark> e-mail*
08:42:44 <t7> javascript: "just keep running"
08:42:53 <t7> everything in scope is the wrong type
08:42:58 <t7> who cares
08:43:13 <myfreeweb> erlang: "just retry"
08:43:21 <myfreeweb> which is good for networking usually
08:43:24 <simg> if I had a £ for every time I've had to write code like --> if (myVal != null) myVal.toString().  10's of thousands of times.   all could have been prevented if .toString() return empty string.  no less safe
08:43:45 <hc> 17:38 < EvanR> crashing is the best case scenario when your code is incorrect
08:43:49 <hc> offensive programming ftw ;)
08:43:51 <EvanR> simg: now you dont have to, haskell makes that often unnecessary
08:43:52 <bergmark> simg: it could also have been prevented if you had the guarantee that myVal was never null, a guarantee that haskell gives you
08:44:52 <simg> EvanR: yes, now it looks like I'll have to type fromMaybe "" (fmap T.unpack myMaybeText)  10's of thousands of times instead. (When I get it working !) :p
08:45:27 <EvanR> simg: imagine if you could write a function which wraps whatever gave you that Maybe Text, and instead gave you a Text, which operates by substituting empty text on Nothing. now you dont have to deal with it. and also you might find this isnt what you want sometimes, but if it is, no more "nulls"
08:45:40 <dolio> Why do you have Maybe Texts in tens of thousands of places in your program?
08:45:49 <simg> bergmark: good point re: exception rather than "hello, !"
08:46:14 <simg> dolio - I don't, Yet !
08:47:01 <simg> EvanR: yes, I see that :)
08:48:01 <EvanR> simg: also useful is the pattern of chaining operations that return Maybe, providing Nothing if any of them return Nothing. you can do this with do notation
08:48:12 <EvanR> instead of repeated if statements
08:48:53 <EvanR> finally you can lose the maybe by providing a default value with maybe or fromMaybe
08:49:32 <EvanR> or lose all the Nothings with catMaybes
08:49:39 <EvanR> :t catMaybes
08:49:40 <lambdabot> [Maybe a] -> [a]
08:51:43 <bergmark> > map (\a -> do { b <- a; guard (odd b); return (b + 1) }) [Just 1, Just 2, Nothing]
08:51:45 <lambdabot>  [Just 2,Nothing,Nothing]
08:52:08 <EvanR> or stay with the maybe for as long as you want by continuing to use fmap, do notation, and <*>
08:52:54 <simg> bergmark: on second thoughts, unless I've missed something, in your NullPointerException example I'd still have to explicitly check that the user name does not get translated to "" if I were using fromMaybe
08:53:32 <EvanR> if your users username is a Maybe Text then that would be an issue
08:53:51 <EvanR> would be nice if it werent, in which case theres no issue
08:54:25 <EvanR> but if it is, then you are forced to figure out what to do about it
08:55:45 <simg> EvanR: user name perhaps isn't the best example, because that should "always" be an exception if null. plenty of others values can easily be null
08:55:49 <EvanR> greeting = "Hello, " ++ fromMaybe "Valued Customer" maybeUsername ++ "!!!"
08:56:14 <EvanR> simg: every single attribute in the medical records im working with might be missing
08:56:53 <simg> EvanR: good example, you "win" :)
08:57:01 <EvanR> and it sucks
08:57:37 <myfreeweb> how do I compare Int with Int64? toInteger both of them or is there a better way?
08:57:46 <wz1000> How do I convert a String to a ByteString?
08:57:53 <EvanR> myfreeweb: fromIntegral one of them
08:58:02 <myfreeweb> wz1000: encodeUtf8
08:58:07 <myfreeweb> EvanR: thanks
08:58:12 <slomo_> wz1000: into which charset encoding?
08:58:25 <int-e> myfreeweb: fromIntegral the possibly smaller Int.
08:58:37 <simg> EvanR: *most* attributes in most records in most systems might be missing?
08:58:43 <wz1000> slomo_: UTF-8
08:59:17 <EvanR> simg: well, when designing a database you can decide that entire records must be entirely filled out or not there at all, to simplify things
08:59:31 <slomo_> wz1000: see http://hackage.haskell.org/package/utf8-string for example
08:59:40 <EvanR> simg: validation and all that
08:59:43 <EvanR> model building
08:59:59 <simg> EvanR: sure, but mostly I'd rather make things as flexible as possible.
09:00:25 <EvanR> simg: well, consider what that literally would mean ;)
09:01:16 <EvanR> being able easily modify a model is one thing, having no model is something else
09:02:27 <EvanR> simg: at my old job, they took flexibility to mean, insert data however they wanted, in a way made it harder to retrieve and report on, or impossible.
09:02:45 <EvanR> most of the time, in ways that made no sense
09:04:16 <EvanR> so when i hear about flexibility, it usually is pretaining to jello technology rather than quickly transforming one well defined model into another
09:05:30 <simg> EvanR: that makes sense, but ultimately the real world (which systems are usually trying to model) contain all sorts of "uncertainty" (at least to the extent of values being either present or null).
09:05:57 <EvanR> yeah so you can explicitly model possibly missing information, nullable and all that
09:06:00 <simg> EvanR: also, I'm very aware of my "Jello tendencies", hence why I'm trying to learn Haskell :)
09:07:22 <EvanR> sometimes missing really makes no sense, and missing is really different from empty string, zero, -1, empty list
09:07:40 <wz1000> What is the best way to copy the contents of one handle into another?
09:08:02 <EvanR> in fact missing may have lots of semantics of its own, check out this http://hl7.org/implement/standards/fhir/null-flavor.html
09:08:15 <wz1000> Would hGetContents and hPut be fine?
09:08:46 <EvanR> wz1000: do you care about possible errors?
09:09:06 <wz1000> EvanR: Yes. Also, the data may be binary
09:09:22 <EvanR> use hGetContents from ByteString then
09:10:50 <simg> EvanR: interesting link, but of those, I'd say only "NI" is truly Null. The others are different "exceptional" values.
09:11:40 <EvanR> simg: i dont know what truly null means, but all those codes are intended to be stored
09:11:48 <EvanR> representing some value for some attribute
09:11:58 <EvanR> "null flavors"
09:15:10 <athan> How does haskell coerce the values "1,2,3.4,1/7,sqrt (-1)" etc, to their respective types? Are the numbers themselves basically typeclass methods? How is the actual data type instance (like Int or Double) implied, without a type signature?
09:15:38 <EvanR> :t fromInteger
09:15:39 <lambdabot> Num a => Integer -> a
09:15:41 <geekosaur> :t 2
09:15:42 <lambdabot> Num a => a
09:15:43 <EvanR> :t fromRational
09:15:45 <lambdabot> Fractional a => Rational -> a
09:16:13 <EvanR> :t fromString
09:16:14 <lambdabot>     Not in scope: ‘fromString’
09:16:14 <lambdabot>     Perhaps you meant one of these:
09:16:14 <lambdabot>       ‘BSLC.fromStrict’ (imported from Data.ByteString.Lazy.Char8),
09:17:04 <EvanR> athan: theres a combination of numeric type defaults and type inference to figure out which kind of number you want
09:17:20 <EvanR> > 2 + 2
09:17:22 <lambdabot>  4
09:17:27 <EvanR> Integer
09:17:43 <athan> EvanR: Type defaults... hmm, I'll have to look at that. So most of it is all typeclass stuff?
09:17:49 <athan> hmm
09:17:50 <athan> okay
09:17:55 <zwer> :t 2
09:17:56 <lambdabot> Num a => a
09:18:07 <EvanR> :t 2 + 2
09:18:08 <lambdabot> Num a => a
09:18:47 <athan> And some of these methods have different typeclass constraints on either side, like (/):
09:18:49 <athan> :t (/)
09:18:51 <lambdabot> Fractional a => a -> a -> a
09:18:52 <zwer> if you do 2 + valueKnownToBeInt compiler will infer that 2 has to be int as well
09:18:52 <EvanR> athan: yes if you define a Num instance you can use integer literals to construct values
09:18:55 <athan> er, wait
09:18:58 <zwer> Int*
09:19:23 <EvanR> athan: similarly for Fractional and IsString
09:19:23 <athan> that's how there's still different types in a large expression
09:19:41 <athan> zwer: Ahh okay
09:19:49 <athan> thank you guys :)
09:20:28 <athan> what does the superclass structure look like?
09:20:28 <SlackMoehrle> Hi Guys I'm trying to specify a location to where the lib is and I'm not sure I'm doing it right: ghc -rpath='/data/home/docops/pandoc_deps/ghc/lib/ghc-7.8.20140130/ghc-7.8.20140130/' --make Setup.hs
09:20:49 <athan> that's where typeclass subtyping resides... right?
09:21:04 <EvanR> haskell doesn't have subtypes
09:21:35 <SlackMoehrle> according to a find it is here: /data/home/docops/pandoc_deps/ghc/lib/ghc-7.8.20140130/ghc-7.8.20140130/libHSghc-7.8.20140130-ghc7.8.20140130.so
09:22:10 <EvanR> but you can define instances for classes of types that satisfy other class constraints
09:22:37 <EvanR> instance (Monoid a) => Monoid (a, a) where
09:22:54 <dhil> I am looking into parallel strategies atm. But I wonder what is the implication of omitting rseq in say: runEval $ do { a <- rpar (f x); b <- rpar (g x); foobar a b; return () } vs. runEval $ do { a <- rpar (f x); b <- rpar (g x); rseq a; rseq b; foobar a b; return () } ?
09:23:29 <dhil> will the function foobar cause sequential evaluation if the arguments are not evaluated yet?
09:25:28 <horsey> hi tharr
09:28:34 <SlackMoehrle> so how can I specify the path to the library?
09:31:43 <meretrix> What's the easiest way to just run a shell process in the background, taking no input and hiding all output.
09:32:33 <josephle> dhil, here's a link for you: http://chimera.labs.oreilly.com/books/1230000000929/ch02.html#sec_par-rpar-rseq
09:32:48 <josephle> gives you a good overview of strategies
09:33:20 <Boyd16485816> What's the best program to start with to learn coding?
09:35:09 <wei2912> Boyd16485816: hello world
09:35:33 <wei2912> Boyd16485816: and since we're in #haskell, factorial
09:36:13 <wei2912> Boyd16485816: i'm certain that you actually meant a project wish you want to work on. in that case, pick whatever you want
09:36:44 <EvanR> or a program might mean like code academy
09:37:18 <Boyd16485816> I have done html and want to move up.  Does that make sense?
09:37:19 <wei2912> EvanR: true
09:37:24 <josephle> don't you dare bring in the ambiguity of english into this! :P
09:38:13 <josephle> so this isn't just an intro to haskell, but an intro to programming
09:38:23 <Boyd16485816> Went to Swift class last night but too complicated for me
09:39:27 <wei2912> Boyd16485816: sort of. i'm not sure if you want to start with haskell though
09:39:37 <wei2912> anyone has thoughts on haskell as a starter programming language?
09:39:58 <EvanR> at some point there was the idea that haskell could be a good language for learning from scratch, but no book or anything existed which presented it that way
09:40:04 <Boyd16485816> I need the lowest rung on the ladder
09:40:18 <EvanR> Boyd16485816: check this out http://tryhaskell.org/
09:40:40 <Boyd16485816> That's how I arrived here.
09:40:56 <wei2912> Boyd16485816: haskell is an interesting language to start with. you could give it a try.
09:41:28 <Boyd16485816> Thanks very much. I'll go there now.
09:42:03 <wei2912> Boyd16485816: also, join #haskell-beginners
09:43:12 <dhil> josephle, thanks. But I am still not sure what happens when returning prematurely. Does parallelism get killed?
09:44:32 <saep> @where lyah
09:44:33 <lambdabot> http://www.learnyouahaskell.com/
09:44:40 <josephle> dhil: "We see that f x and f y begin to evaluate in parallel, while the return happens immediately: It doesn’t wait for either f x or f y to complete. The rest of the program will continue to execute while f x and f y are being evaluated in parallel."
09:44:55 <josephle> dhil, if I understand that quote correctly, parallelism does not get killed
09:46:07 <dhil> josephle, thanks. Then I am left wondering why would I _not_ return immediately? My guess would be: to avoid overflowing the spark pool when running many parallel computations?
09:46:21 <Boyd16485816> The code doesn't do anything in notepad on my PC.  What kind of thing do I need to download please.  (I might already have it.)
09:46:41 <wei2912> Boyd16485816: you most likely don't have it, but it's GHC
09:47:02 <Boyd16485816> GHC.  Thanks.
09:47:16 <wei2912> Boyd16485816: look up compilers and interpreters
09:47:25 <wei2912> Boyd16485816: as well as REPL
09:48:30 <Boyd16485816> They said I should download Haskel Platform instead of GHC
09:49:44 <Boyd16485816> I should say "it" said I should download Haskell Platform
09:49:51 <EvanR> Boyd16485816: at some point, sooner or later, youre going to want to use linux or mac for general programming stuff, and resort to windows if you happen to be developing windows software
09:50:04 <josephle> dhil, if your subsequent computation is sequential, there is a case to be made of forcing all your parallel computations to finish before advancing
09:50:06 <EvanR> but haskell platform will work on windows
09:50:28 <Boyd16485816> Thanks, Evan
09:50:30 <EvanR> to type in the commands you need command prompt or power shell
09:51:02 <saep> Boyd16485816: Haskell-platform includes GHC and comes with a few more things which shouldn't bother you yet.
09:51:54 <josephle> dhil, since you might be adverse to having your program wait for a parallel computation to finish at some other time that you didn't specify
09:51:57 <Boyd16485816> I wish I were in a school
09:52:00 <wz1000> Boyd16485816: Also, I recommend you start with something like SICP instead of a haskell book like LYAH, because that assumes a bit of programming knowledge on your part
09:52:25 <dhil> josephle, I see. Thank you for your input.
09:53:27 <Boyd16485816> Thanks.  I'll google SICP.
09:56:14 <EvanR> Boyd16485816: you can also try javascripts since the browser is already installed and you said you did html
09:57:03 <EvanR> in chrome the js REPL is activated with ctrl shift J
09:57:08 <wz1000> EvanR: I don't think something like JavaScript is a good introduction to programming.
09:58:08 <kadoban> JavaScript isn't too bad, but it's easy to write bad code in...and there's lots of info out there for it that sucks.
09:58:48 <EvanR> he is not going to be forever scarred by javascript, which is semantically similar to scheme anyway, and it might get you a damn job ;)
09:59:19 <EvanR> and the repl is right there in your face
09:59:26 <EvanR> and its windows
09:59:32 <Jello_Raptor> hmm, I'm trying to get alex to error instead of recognizing "abcd/1234" as [LitID "abcd",Op Div,LitInt "1234"] :/
09:59:46 <kadoban> Yeah, I could see javascript being a good introduction to programming...if you can find a good guide or two
10:00:05 <EvanR> same could be said for haskell
10:00:06 <josephle> you have to restrict javascript's syntactic domain to get a semantics similar to scheme ;)
10:00:48 <nshepperd> I wonder what it's like learning haskell as one's first programming language
10:00:51 <kadoban> EvanR: Well...haskell is somewhat harder to go really off the rails in, IMO. JavaScript is one of those languages where you have to ignore a bunch of it, or use a really strict linter to get any kind of a reasonable language out of it.
10:01:01 * hackagebot oauthenticated 0.1.3.2 - Simple OAuth for http-client  http://hackage.haskell.org/package/oauthenticated-0.1.3.2 (JosephAbrahamson)
10:01:05 <EvanR> as far as "if a good guide existed"
10:02:17 <wz1000> JavaScript isn't a 'traditional; desktop language, so it may warp your view of how programs work. Also, its warts may come in way of your learning.
10:02:42 <nshepperd> I feel like the sensible type system is good for a first programming language
10:02:52 <DTSCode> ^
10:03:01 <dmj`> ^
10:03:06 <EvanR> assumption about whether traditional desktop programs are the point
10:03:17 <monochrom> "desktop language" is a new phrase for me
10:03:31 <josephle> Rust has a "sensible" type system, but you might be driven insane by its strictness about pointer lifetimes
10:03:33 <monochrom> will there be "netbook languages" too?
10:03:49 <DTSCode> wrong desktop i think monochrom
10:03:51 <EvanR> swift is a phone language
10:03:56 <DTSCode> o rly?
10:03:59 <EvanR> lol
10:04:10 <josephle> that's because apple is too lazy to give swift cocoa support
10:04:24 <wz1000> Well, Javascript and PHP are domain specific languages, the term I was going for would probably be 'general purpose' language
10:04:39 <DTSCode> they arent domain specific
10:04:50 <DTSCode> considering ive run them on linux and windows
10:05:09 <EvanR> the monthly person trying to get php SDL bindings to work
10:05:15 <DTSCode> heh
10:05:17 <DTSCode> php SDL
10:05:21 <josephle> well, the domain is the browser which is where your most up-to-date JS interpreter lives
10:05:22 <DTSCode> now ive heard everything
10:05:46 <myfreeweb> there's also php gtk
10:05:55 <DTSCode> josephle, its not just tied to the domain though. you can write native js apps on linux
10:05:58 <DTSCode> not sure about windows
10:06:03 <EvanR> php the next systems programming language
10:06:06 <myfreeweb> node runs on windows
10:06:07 <DTSCode> theres also server side php
10:06:17 <josephle> that's true. OS X has js bindings for gui programming things
10:06:18 <wz1000> DTSCode: They were expanded to non web use only later on. PHP is built to output HTML, and Javascript is built (badly) to manipulate html
10:06:40 <EvanR> manipulate the dom
10:06:40 <fizbin> DTSCode: Wait, what php *isn't* server side?
10:06:52 <fizbin> Isn't server-side php's main thing?
10:06:53 <EvanR> php is a normal programming language
10:07:10 <DTSCode> it was built for that yes, but c was built for unix, and now its not considered dsl
10:07:18 <DTSCode> fizbin, thats my point
10:07:21 <EvanR> you can use it to write regular programs
10:07:27 <EvanR> somehow
10:08:16 <fizbin> php is a programming language you can write arbitrary programs in, yes. It's hardly "normal" though, unless by "normal" you mean "hideously broken because our industry embraces hideously broken things"
10:09:05 <EvanR> yeah thats what normal means
10:09:19 <EvanR> nail on the head lol
10:11:02 <ReinH> There's no such thing as client side PHP.
10:11:03 <fizbin> Seriously, perl is more consistent and orthogonal in its design, and the design of perl is basically "so here's the inside of Larry Wall's head".
10:11:06 <nshepperd> in any case, beginners definitely shouldn't learn programmng starting with php
10:11:11 <ReinH> Unless you're talking about PHP-GTK... *shudder*
10:11:30 <piskrist> ReinH: php ircbots?
10:11:32 <fizbin> ReinH: I've seen people write command-line tools to query web services in php.
10:11:38 <piskrist> php web crawlers?
10:11:41 <DTSCode> well there is, its just not very efficient
10:11:43 <ReinH> piskrist: ... run on a server
10:12:13 <ReinH> fizbin: I think that's a different definition of "client"
10:12:27 <fizbin> ReinH: Also, this is written entirely in php: https://secure.phabricator.com/book/phabricator/article/arcanist/
10:12:31 <nshepperd> I've heard that SICP is thorough, but lisp is untyped, which is unfortunate
10:12:32 <myfreeweb> a lot of Alfred.app (OS X quick launch thing) plugin authors use php
10:12:37 <andbroby> hey, what would be the idiomatic way to implement warshall's algorithm for calculating transitive closures in haskell? i've implemented it here in python http://git.io/WXcTpA and tried to port it to haskell by using list comprehensions but it's a mess.
10:12:50 <jfischoff> So is Phabricator itself I think
10:12:53 <myfreeweb> nshepperd: well, there are things like typed clojure
10:12:58 <DTSCode> my point was that php is not domain specific.
10:13:06 <EvanR> yeah i wouldnt suggest SICP anymore
10:13:12 <ReinH> fizbin: I realize you can write HTTP clients in PHP. That is not what is generally meant by "client-side".
10:13:37 <ReinH> client-side in a web context generally means "runs in a browser".
10:14:00 <EvanR> myfreeweb: gradual typing : (
10:14:01 <fizbin> Ah, that. So you're saying that there's a missing php2js compiler.
10:14:07 <ReinH> In any event, it's not worth arguing over.
10:14:22 <ReinH> FSVO "client-side", PHP can be used on the client-side.
10:14:31 <fizbin> I will grant that php2js does not exist. Yet.
10:14:31 <jfischoff> andbroby: I don’t know the answer, but perhaps there is some help in here: http://www.cl.cam.ac.uk/~sd601/papers/semirings-slides.pdf
10:14:32 <wz1000> nshepperd: most lisps are monotyped. This is nice, because almost everything can be expressed in terms of conses
10:14:57 <jfischoff> andbroby: I think he has a matrix closure example
10:15:07 <EvanR> wz1000: its not nice, really
10:15:12 <wz1000> nshepperd: Although SICP does experiment with type tagging values
10:15:29 <andbroby> jfischoff: sweet, i'll take a look at it :) thanks!
10:15:37 <wz1000> nshepperd: It is not static, but it is interesting
10:15:54 <MrNosco> nshepperd, hey, I heard you clarified some stuff about that P!=NP pastebin, can I find your explanation anywhere?
10:16:34 <fizbin> andbroby: If you're doing this though because you're representing graphs, you should really look at fgl.
10:17:01 <wz1000> EvanR: I kind of like the idea of a uniform representation for everything. I find it beautiful as a concept, although it may have disadvantages in practice
10:17:23 <EvanR> one thing about dynamic systems like scheme is that you will have to think harder to get your program right, making you that much stronger as a programmer, and you will appreciate type safety when you can get it
10:17:34 <DTSCode> ^
10:17:58 <DTSCode> i used to be all about dynamic weak typing until i actually had to use it in a project
10:18:03 <luite> hmm, a php to js compiler. that could be my next project when i get bored with my current one
10:18:06 <luite> :p
10:18:31 <fizbin> luite: I guarantee you have better things to do with your time.
10:18:46 <wz1000> Also, writing macros(the whole point of a lisp) would be tediuosly hard in a statically typed language.
10:18:54 <EvanR> wz1000: the untyped lambda calculus is indeed interesting, and has theoretical and practical issues as a tool
10:19:08 <fizbin> Even if you're a php expert, and also simultaneously a "compiling to javascript" expert, there are better things to do with your time than php2js.
10:19:17 <EvanR> nonetheless i am working on "untyped haskell" based on this idea ;)
10:19:49 <EvanR> wz1000: well, template haskell is typed
10:19:58 <luite> fizbin: hmm, i might do reasonably good on the latter
10:20:11 <EvanR> missing types isnt a feature, not even in macros
10:20:18 <nshepperd> MrNosco: I can pastebin the logs if you want
10:20:34 <wz1000> EvanR: I am talking about lisp style macros. Where the entire language is extensible. Also 'eval' depends on monotypedness
10:20:48 <MrNosco> nshepperd, that would be great!
10:20:57 <Guest88949> Hello everyone! I'm quite new to Parallel Strategies, so may anyone analyze my super simple quicksort and say what might be wrong with it? On a list of 27k sortable values I don't get any difference compared to normal quicksort. Threadscope has 95% processing done on one CPU. Is it maybe because my sample size is so small? Here's the code: http://pastebin.com/QscPjknz
10:21:34 <myfreeweb> wz1000: clojure isn't monotyped, right? it has eval
10:21:44 <EvanR> i have to say that untyped, lisp, recommendations for using lisp etc dont seem on topic
10:21:49 <nshepperd> MrNosco: the key point was that "polynomial time" refers to "polynomial in the input size" which ends up being the size of the formula rather than just the number of variables
10:22:06 <fni> Hi, all.  I'm writing bindings to the CEF3 C API.  I'm getting a seg fault in a simple function that I cannot figure out.  If you think you can help, please check my forthcoming lpaste for details.
10:22:14 <EvanR> myfreeweb: clojure is dynamically typed like the other lisps
10:22:23 <lpaste> fni pasted “Seg fault when binding to CEF3 simple function” at http://lpaste.net/113763
10:22:33 <MrNosco> you can get segfaults in haskell?!
10:22:57 <lpaste> nshepperd annotated “sat” with “sat (annotation)” at http://lpaste.net/113746#a113764
10:22:58 <fni> When calling C code from haskell, sure, why not? :)
10:22:59 <EvanR> MrNosco: by using the FFI, or unsafeCoerce, etc
10:23:04 <MrNosco> ohhh
10:23:06 <fizbin> Guest88949: I think that the issue is that you want withStrategy strat (left ++ [x] ++ right)
10:23:08 <wz1000> EvanR: Also, TH isn't type safe
10:23:37 <merijn> wz1000: There's type safe TH now
10:23:43 <Cale> Guest88949: also, maybe you just want to spark the computation of right rather than left
10:23:48 <merijn> wz1000: Since either 7.6 or 7.8
10:23:54 <Guest88949> fizbin: :o Thanks! I'll check that out.
10:24:05 <merijn> wz1000: Just google for "typed template haskell" or something
10:24:17 <MrNosco> nshepperd, what do you mean by "size of the formula"
10:24:24 <Cale> Guest88949: left is the stuff which is already getting evaluated next immediately if you're at that point in the computation
10:24:46 <Cale> Guest88949: So sparking a computation to maybe try to get it done in parallel is always going to fail
10:24:54 <Guest88949> Cale: Hmm, so rpar on right?
10:25:02 <Cale> Guest88949: yeah, and leave left alone
10:25:08 <Cale> (because it's already next)
10:26:11 <nshepperd> MrNosco: either the number of terms, or its size as a string (including "∧", "∨" and variable names)
10:26:11 <Guest88949> Cale: so remove pseq from left? :)
10:26:37 <joe9> Would this be the correct type definition of applicative join for the cont monad: http://codepad.org/is7m3aBP Line 15?
10:26:44 <joe9> the line 17 is wrong.
10:26:59 <joe9> I am trying to fix it. But, just want to check if the definition in Line 15 is correct though.
10:26:59 <merijn> fni: Highly supicious thing to consider
10:27:00 <Cale> Guest88949: yeah, there's no need for that, because if you're evaluating  left ++ [x] ++ right, the pattern match in the (++) evaluates its first argument already
10:27:16 <merijn> fni: Does the C string thing null terminate your string?
10:27:17 <Guest88949> Cale: Okay, I'll try. Thank you VERY much!
10:27:18 <Cale> Guest88949: So within one or two evaluation steps, you'll be evaluating left anyhow
10:27:36 <fni> merijn: according to the hackage doc, yes it does
10:28:51 <merijn> fni: What's "sz"?
10:29:01 <merijn> i.e. how big is your input utf8 string?
10:29:06 <NemesisD> is it possible with template haskell to get all inhabitants of a typeclass that are currently in scope?
10:30:25 <fni> merijn: sometimes 0 characters, sometimes 4.  I tested with empty string "" and "test".  All pretty normal sized strings.  At one point I was printing sz and it looked correct
10:30:53 <Cale> reifyInstances :: Name -> [Type] -> Q [InstanceDec]
10:31:07 <nshepperd> MrNosco: anyway I put the logs in that annotation on lpaste
10:31:15 <fni> merijn: I also tested with "thisisatest"....sz was printed as 11.  So far all within my expectations
10:31:20 <Cale> oh, but then you'd need to know what types to ask about
10:31:44 <Cale> oh right
10:31:48 <merijn> fni: actually
10:31:56 <Cale> reify :: Name -> Q Info
10:32:10 <merijn> fni: Consider the following
10:32:14 <sinelaw> How can I make this less kludgey?
10:32:14 <sinelaw>   allocNames <- forM tvarNames $ \tvName -> do
10:32:15 <sinelaw>                                     freshName <- fresh
10:32:15 <sinelaw>                                     return (tvName, freshName)
10:32:16 <Cale> and note that Info has a constructor: ClassI Dec [InstanceDec]
10:32:26 <merijn> fni: "cef_string_utf8_to_utf16" wants a UTF-8 string, right?
10:32:27 <sinelaw> the lambda given to the forM specifically annoys me
10:32:42 <Fuco> Any user of libmpd can tell me how to import Path and Value in 0.9 version? Updating from 0.8 broke updates :(
10:33:15 <Cale> sinelaw: It's really not that terrible imo, but there are some things you could do...
10:33:21 <merijn> hmm, no, newCString should encode to UTF-8 with the right locale
10:33:21 <Cale> :t ap (,)
10:33:22 <fni> merijn: yes, utf-8 string.  newCString encodes the Haskell string into my default encoding, which I have confirmed is UTF-8
10:33:23 <lambdabot> (a -> b) -> a -> (a, b)
10:33:24 <merijn> ok, I don't know
10:33:26 <Cale> er
10:33:30 <Cale> right :)
10:33:43 <merijn> Grab gdb and inspect the core dump in the C side of things
10:33:49 <sinelaw> Cale, tried that but it comes out unreadable
10:33:57 <sinelaw> I don't like overdoing pl stuff
10:34:08 <Cale> sinelaw: Yeah, well, what bothers you about that code?
10:34:22 <fni> merijn: ok, thank you for taking a look all the same!
10:34:24 <Cale> It's perfectly normal for the second argument to a forM to be a lambda
10:34:42 <torpet> So I am having a list of n elements
10:34:44 <sinelaw> Cale, oh well I guess it's ok
10:34:50 <torpet> How could I compare one element to the n-1 other elements?
10:35:01 <merijn> sinelaw: note that there's no reason for your 2nd and 3rd line to be so far right
10:35:13 <merijn> sinelaw: They only have to be indented further than allocNames on the first line
10:35:20 <Cale> torpet: Match the list against (x:xs) and write something like map (compare x) xs ?
10:35:31 <MrNosco> nshepperd, I can' find it on lpaste
10:35:54 <sinelaw> merijn, yeah, just changed my emacs from haskell-indent to haskell-indentation-mode and now it offers that option when tabbing
10:35:56 <sinelaw> thanks
10:35:58 <Cale> I don't really mind that indentation
10:36:02 <SlackMoehrle> can anyone tell me how to specify a library location when using ghc?
10:36:03 <nshepperd> MrNosco: http://lpaste.net/113746
10:36:18 <merijn> SlackMoehrle: Why do you (think) you need to?
10:36:27 <MrNosco> nshepperd, thank you
10:36:30 <sinelaw> it does make it clear that those lines belong to the lambda...
10:36:33 <merijn> SlackMoehrle: installed libraries are registered with GHC, so it already knows how to find them
10:37:03 <SlackMoehrle> merjin: can you look at this: http://stackoverflow.com/questions/26741672/specifying-path-to-library-when-using-ghc
10:37:23 <sinelaw> is there anything simpler than quickcheck where I can just write down a few specific inputs and the expected outputs?
10:37:31 <sinelaw> a la python's doctests
10:38:16 <SlackMoehrle> merijn: can you look at this: http://stackoverflow.com/questions/26741672/specifying-path-to-library-when-using-ghc
10:38:53 <merijn> SlackMoehrle: If GHC reports that it can't find "libHSghc" you have broken something in a *bad* way
10:39:06 <myfreeweb> sinelaw: https://github.com/sol/doctest#readme
10:39:10 <merijn> I recommend nuking your install and installing from scratch to fix things
10:39:50 <SlackMoehrle> merijn: I am doing this: https://gist.github.com/stephenjbarr/9237286
10:39:56 <sinelaw> myfreeweb, thanks. should have asked google first :)
10:40:08 <SlackMoehrle> merijn: trying to get pandoc working on amazon linux and I can't find a way
10:40:26 <Cale> SlackMoehrle: Is there a particular reason why you're installing a release candidate of an old version of GHC?
10:40:40 <SlackMoehrle> Cale: I was following this: https://gist.github.com/stephenjbarr/9237286
10:40:43 <supki> Fuco: Path and Value are abstract in libmpd-0.9
10:40:55 <Cale> oh, okay, well, maybe try installing a proper ghc instead
10:40:59 <supki> Fuco: well, not really abstract, you can convert them to/from strings
10:41:06 <SlackMoehrle> cale: trying to install pandoc on amazon linux
10:41:28 <Cale> https://www.haskell.org/ghc/download_ghc_7_8_3#x86linux
10:41:32 <Fuco> supki: ah, so I can't i.e. pattern match on them?
10:41:40 <supki> no
10:41:41 <Fuco> s/i.e./e.g./ ;)
10:41:52 <Fuco> hmm... okey, I'll try to fix the code
10:42:27 <SlackMoehrle> i cant believe installing pandoc is this hard
10:42:36 <SlackMoehrle> i guess it has to do with it being amazon linux
10:42:53 <Cale> SlackMoehrle: Well, you'll need a working Haskell compiler if you want to compile it :P
10:43:20 <SlackMoehrle> i'd prefer installing a pandoc binary but I can't figure out how on amazon linux
10:43:39 <Cale> SlackMoehrle: but also, wow, wgetting things like glibc?
10:43:47 <Cale> wtf?
10:44:05 <SlackMoehrle> I know that is dumb. I actually didn't do those steps
10:44:18 <SlackMoehrle> yum for those
10:45:03 <Fuco> supki: do you have some example? I don't see where the functions are defined :(
10:47:49 <Guest88949> Cale: My code now runs hundreds of times slower too which is good for analysing, but I really have no idea whether that's the correct behaviour. With the rpar on 'right'  all I get are a few running sparks for the second core. http://lpaste.net/9062587337673801728
10:48:15 <Cale> Guest88949: heh
10:49:01 <Guest88949> Cale: I do see gazillion of GCed sparks on the second core though.
10:49:15 <Cale> Guest88949: Oh right, another problem is that rpar only forces the outermost constructor
10:49:24 <supki> Fuco: if you have  foo (Path "bar") = ...  you can rewrite it to  foo p = case toString p of "bar" -> ...  or (with ViewPatterns)  foo (toString -> "bar") = ...
10:49:34 <Cale> Guest88949: so it doesn't actually do very much work
10:49:38 <int-e> joe9: that doesn't even typecheck :/
10:49:52 <Cale> and yeah, you're going to be creating a lot of sparks in general here, and the work might not be very well balanced
10:50:44 <Fuco> supki: is there some reason for this change? Seems annoying :P I hope you're not busy :)
10:51:03 <Guest88949> Cale: Hm, well, the balancing itself isn't much of an issue, rather than to get any significant boost out of the second core.
10:51:04 <supki> Fuco: oh, I have no idea
10:51:32 <Denommus> hello
10:51:47 <Johannes13> I'm currently trying to describe mathematical expressions (like x^2 etc) in haskell. I implemented a typeclass Expr, which has a few methods, one of them is simplify.
10:51:48 <Denommus> I'm using GHCJS with webkitgtk
10:52:18 <Denommus> is there a way to get conditional compilation to produce plain HTML files instead of a webkitgtk window?
10:52:26 <int-e> joe9: Oh and your line numbers are wrong. The type on line 14 is correct, I guess that was your question.
10:52:36 <joe9> int-e: but, is that the correct type signature too.
10:52:37 <Johannes13> the problem is: how can I simplify (Add someExpr (Const 0)) to someExpr?
10:52:53 <joe9> int-e: I know that it does not type check and that is what I am trying to figure out.
10:53:05 <int-e> joe9: I was confused by the line numbers.
10:53:07 <joe9> int-e: but, just want to make sure that the type signature is good.
10:53:18 <Guest88949> Cale: So is there a way to parallelize function application instead?
10:53:27 <joe9> int-e: Is the type definition correct?
10:53:34 <joe9> int-e: is my question.
10:53:42 <joe9> int-e: thanks for taking a look.
10:53:44 <int-e> joe9: I already answered that. Yes, it's correct.
10:53:58 <joe9> int-e: oh, missed that. Thanks.
10:54:00 <natschil> Hello. Is there a function that is a kind of "inverse" to (&&&) or (***) in the sense that it allows you to combine the "parts" of an arrow using a binary function? So far uncurry works for pairs, but I don't think that will generalize to all arrows.
10:54:17 <Cale> Guest88949: Well, rpar right will cause a computation to be sparked which will evaluate right until it's determined whether right = [] or right = (x:xs)
10:54:26 <joe9> int-e: now, I will try to figure out the body. if you have any ideas, please feel free to let me know. Thanks.
10:54:34 <Cale> Guest88949: Which will involve doing a bunch of quicksort steps
10:54:46 <supki> Fuco: well, its dangerous to pattern match on bytestrings directly, because non-ASCII characters are truncated
10:54:47 <Cale> Guest88949: but will stop short
10:55:54 <natschil> I expected liftA2 to do that, but it doesn't seem to work. (i.e. I would have expected (liftA2 (+) ((+1) *** (+2))) (1,2) to return 7, but that gives a type error.
10:56:04 <Hijiri> arr (uncurry f)?
10:56:39 <Hijiri> maybe define something arr . uncurry and then you can use that
10:56:39 <Guest88949> Cale: How does this involve doing any quicksort steps? Is not [] vs (x:xs) determined by simple pattern matching? Or I am misunderstanding you...
10:57:11 <Fuco> supki: hmm, well I was just "destructuring" not pattern matching, but I guess haskell can't make a difference
10:57:11 <Cale> Guest88949: Well, you'll be pattern matching against the scrutinee:  quicksort [a | a <- xs, a > x]
10:57:25 <Hijiri> I think the A in liftA is Applicative
10:57:31 <Fuco> supki: e.g. \(Path foo) -> ... I don't even know how to do it now
10:57:32 <Guest88949> Cale: Aha, and as soon as it knows that it isn't empty, that's it?
10:57:37 <Cale> Guest88949: Oh also, why is your function called qs, but you have another function called quicksort?
10:57:54 <Cale> Guest88949: Is the goal just to do half the list in parallel?
10:57:59 <Guest88949> Cale: Oh god, you're a genius. :D
10:58:51 <supki> Fuco: there are also toText/toUtf8 in ToString
10:58:57 <Guest88949> Cale: I am embarrassed now. But still - the issue remains - how could I make the parallel evaluation go deeper?
10:59:20 <Fuco> supki: oh yes, it is an instance of ToString
11:00:06 <Cale> Guest88949: rpar (rnf right)
11:00:21 <Guest88949> Cale: I'll look into it...
11:01:03 * hackagebot oauthenticated 0.1.3.3 - Simple OAuth for http-client  http://hackage.haskell.org/package/oauthenticated-0.1.3.3 (JosephAbrahamson)
11:01:12 <Fuco> hmm, but I still can't create an "instance" of path
11:01:44 <Guest88949> Cale: But isn't rnf part of some old strategy library, not the current one?
11:02:02 <Fuco> aha, IsString provides fromString... hmm
11:02:13 <Fuco> haskell and "type casting"... I hate it :d
11:02:22 <Cale> uh, no
11:02:42 <jfischoff> fromString is like fromInteger and fromRational
11:02:48 <Cale> Guest88949: it's part of the definition of NFData
11:02:54 <jfischoff> it’s how literals are handled in Haskell
11:03:25 <Guest88949> Cale: Aha, right!
11:03:44 <Denommus> damn, I broke my GHCJS installation
11:05:20 <Fuco> jfischoff: well, that's also annoying... but I understand why it is so
11:06:02 <int-e> joe9: you started out just fine, with  Cont (\k -> runCont cf (\a ->, except that I'd call this 'a' an 'f' (it has type a -> b). After that point it gets muddled.
11:10:07 <nh2> is there a function "inSeparateProcess :: IO a -> IO a" in some library?
11:11:03 * hackagebot statgrab 0.1.3 - Collect system level metrics and statistics  http://hackage.haskell.org/package/statgrab-0.1.3 (BrendanHay)
11:11:05 <michi7x7> nh2: fork?
11:11:09 <Hijiri> there's forkIO
11:13:06 <nh2> michi7x7, Hijiri: I need in a different *process*
11:13:17 <Hijiri> forkOS?
11:13:23 <Hijiri> I don't know if that spawns a new process
11:13:47 <nh2> Hijiri: forkOS is only a new thread, not process
11:13:52 <joe9> int-e, thanks.
11:13:55 <Hijiri> ah, ok
11:14:12 <chrisdone> what's the lens package's name for "modify" again?
11:14:37 <nh2> I'm probably looking for an equivalent to python's multiprocessing library
11:15:20 <Hijiri> over, I think
11:15:32 <Hijiri> chrisdone:
11:17:04 <chrisdone> Hijiri, ah ok. thanks
11:17:53 <silver> nh2, https://hackage.haskell.org/package/process-1.0.1.1/docs/System-Process.html#v%3AcreateProcess
11:18:42 <michi7x7> nh2: what about this? https://www.haskell.org/ghc/docs/5.02.2/set/process-primitives.html ... Im really not sure how to do shared memory in Haskell though
11:20:19 <dbushenko> hi all!
11:20:29 <dbushenko> how to encode to json a list of entities with Aeson?
11:25:56 <myfreeweb> dbushenko: if you can encode a single entity already (it has a ToJSON instance), lists just work automatically
11:26:30 <dbushenko> myfreeweb, I just couldn't make an instance of ToJSON for the list...
11:26:35 <newsham> Frustrated at things you can do in a powerful language but cant do in the language you have to deal with ona daily basis?  #HigherOrderProblems
11:26:42 <newsham> https://twitter.com/newshtwit/status/529713764732391424
11:26:45 <myfreeweb>  dbushenko: you don't need to
11:27:00 <dbushenko> so how to do it then?
11:27:11 <myfreeweb> it just works automatically
11:27:20 <myfreeweb> because aeson has this: ToJSON a => ToJSON [a]
11:27:46 <EvanR> newsham: haha
11:27:47 <dbushenko> hmm.....
11:28:16 <dbushenko> myfreeweb, thanks, you are perfectly right!
11:29:03 <newsham> https://twitter.com/newshtwit/status/529713935339909121
11:29:39 <nh2> silver: createProcess is when you call an external program; it doesn't give you access to your Haskell variables (forkProcess does that, but it cannot transport values to the parent process)
11:30:40 <silver> you can do it by hand if there's no library for that
11:30:44 <myfreeweb> is there a nice way to compose fromMaybes? like, for fallback computations. fromMaybe (lastComputation x) $ fromMaybe (otherComputation x) $ someComputation x looks terrible
11:30:55 <nh2> silver: yes, I'm looking for a library in case one exists
11:31:12 <nh2> michi7x7: there's a SharedMem module in process, but one-directional (child -> parent) is enough for me, so a unix pipe probably fits better
11:31:54 <silver> can I ask why you need a process?
11:32:06 <luite> > msum [Nothing, Just 1, Just 2] -- myfreeweb
11:32:08 <lambdabot>  Just 1
11:32:30 <silver> user rights is one thing I can think of
11:32:44 <nh2> silver: sure! Because I want to protect the program from the passed IO () changing the current working directory
11:32:53 <silver> oh I see
11:33:40 <myfreeweb> luite: thanks! it's still lazy, right? (is 2 evaluated?)
11:33:53 <luite> > msum [Nothing, Just 1, error "boom"]
11:33:55 <lambdabot>  Just 1
11:33:58 <nh2> myfreeweb: `asum` is probably even nicer
11:34:45 <geekosaur> if you just forkProcess then you get a copy of the parent's memory
11:35:22 <nh2> geekosaur: yes but it's copy on write, so I can't e.g. write to the parent's mvars
11:35:51 <natschil> Hijiri: thanks!
11:37:23 <silver> nh2, there is also cloud haskell http://hackage.haskell.org/package/distributed-process , but it sounds like overkill even if it's doing what you want
11:37:45 <nh2> silver: right
11:40:26 <hugldubl> Hello, is there a way to convert a [Word8] to [Integer]?
11:40:42 <EvanR> map toInteger
11:41:31 <hugldubl> EvanR: Is it possible to get my [Word8] back from that [Integer]?
11:41:54 <zipper> Could I get help with this error I am getting when parsing JSON https://gist.github.com/urbanslug/bf34afacce3f7c70baee
11:42:01 <geekosaur> why wouldn't you hold onto the original if you need it
11:42:05 <EvanR> your word8 can come back, but not any old Integer can be flawlessly converted to Word8
11:42:16 <zipper> EvanR: Some help with https://gist.github.com/urbanslug/bf34afacce3f7c70baee
11:42:54 <EvanR> zipper: if you put that long expression on several lines, the line number might help more
11:42:57 <hugldubl> @geekosaur: It's a kind of serializing/unserializing task I have to deal with
11:42:57 <lambdabot> Unknown command, try @list
11:43:28 <EvanR> zipper: ok so your ynToBool function isnt well defined. it takes a Value, but your pattern matching on Strings
11:43:51 <hugldubl> EvanR: but they are Integers from range 0..255, aren't they? Why is converting them back a problem?
11:44:02 <EvanR> hugldubl: i didnt say it was
11:44:18 <zipper> EvanR: Because ynToBool is working on string. It is using fmap.
11:44:34 <nh2> zipper: you're fmapping over something that's not a functor (Value isn't one)
11:44:42 <zipper> EvanR: So it is on the value which is a string
11:44:43 <EvanR> thats the other problem
11:44:44 <hugldubl> EvanR: Thank you
11:45:00 <EvanR> zipper: so im still not clear what kind of json youre expecting to process
11:45:14 <EvanR> what is market supposed to be
11:45:25 <zipper> EvanR: The error is actually that fromJust isn't getting a Value from a Maybe Value.
11:45:29 <joe9> is there any way I can use the ghci type checker interactively? I have a tricky type definition that I am trying to write the function for.
11:45:30 <geekosaur> zipper: the fromJust gives you a Value, your ynToBool claims to want a Value, what is the fmap doing?
11:45:37 <geekosaur> no, it is getting a Value
11:45:48 <zipper> nh2: The functor is HashMap
11:46:00 <EvanR> this is all mixed up
11:46:02 <geekosaur> you then *fmap* a function that wants a Value, over a Value. what is fmap doing?
11:46:16 <geekosaur> (hint: probably that funtion that you claimed wants a Value, doesn't want a Value)
11:46:54 <zipper> geekosaur: I am using fmap to turn all values in the key value pair that are "Y" to "True" and "N" to False
11:47:05 <geekosaur> you believe that you are, yes
11:47:13 <geekosaur> but it's not what you are *doing* in that code
11:47:16 <EvanR> zipper: what kind of json are you trying to process. ["Y","N","Y"] or {"foo":"Y", "bar":"N"} or ?
11:47:17 <nh2> zipper: but (fromJust (decode marketfile) :: Value) isn't a HashMap, it's a Value (you say it yourself)
11:47:22 <geekosaur> because you have claimed a String is a Value
11:48:03 <zipper> EvanR: The latter
11:48:12 <geekosaur> and you are using fmap on a Value to presumably get at the String (I am not sure that works the way you hope)... but you claim on line 24 that the String is a Value
11:48:21 <zipper> This is the JSON file http://www.seas.upenn.edu/~cis194/extras/06-monoid-io/markets.json
11:48:23 <nh2> zipper: I guess you "know externally" that the Json Value is a HashMap, but for that you first have to pattern match on the `Object` constructor (http://hackage.haskell.org/package/aeson-0.6.1.0/docs/Data-Aeson.html#t:Value)
11:48:58 <EvanR> zipper: ok then. next, String, HashMap, Value are three different types. the Object version of Value is also different from the String version of Value, you need to get all your expressions to match up
11:49:24 <EvanR> currently most of them dont
11:49:39 <nh2> zipper: so you have to insert something like `fromHashMap val = case val of { Object hm -> fmap ynToBool hm; _ -> someErrorHandling }
11:50:02 <EvanR> that, and youd have to fix the ynToBool function
11:50:15 <nh2> yes
11:50:16 <EvanR> if you comment out main, and try to ghc -c the file, youll get an error on that file by itself
11:50:30 <EvanR> yourll get an error on that function by itself
11:51:55 <zipper> EvanR: I am assuming that Value I am getting from Value is HashMap k v so I am trying to get the Y and N in v
11:52:14 <EvanR> Value cant literally be a HashMap k v
11:52:39 <EvanR> and Value cant literally be "Y" or "N"
11:52:43 <zipper> nh2: Object is a type synonym for HashMap k v
11:52:54 <EvanR> the type Object is
11:52:59 <bam365> zipper: but in your case, the top-level value is Array, not Object
11:53:01 <EvanR> but Value and Object are two different types
11:53:22 <EvanR> Object myHashMap would be a Value
11:53:39 <zipper> bam365: How'd you know that?
11:53:54 <nh2> bam365: you meant "Value", not "Array"
11:53:55 <zipper> I thought Value is like
11:54:02 <bam365> zipper: because I've looked at that JSON url you gave, it starts with "[", not "{"
11:54:03 <Denommus> damn, workgroups2 still doesn't have per-workgroup buffers
11:54:07 <Denommus> why. Why.
11:54:08 <SrPx> Now seriously, how can random array read be considered O(1), if bits are stored linearly in space? For me it seems like the time to read the last element of an array will always be proportional to the maximum elements of that array as far as our physical laws allow.
11:54:11 <zipper> data Value = Object | Array| String
11:54:23 <EvanR> zipper: your json data is an array of objects
11:54:30 <EvanR> not an object
11:54:32 <SrPx> to the length of that array*
11:54:40 <bam365> zipper: in any case, they're right, in your case, you need to handle each of the Value type's data constructors, Object, Array (which will involve recursive  calls), String, etc
11:54:45 <zipper> bam365: Ok uh thanks
11:54:45 <nh2> SrPx: because RAM is not a tape
11:54:55 <SrPx> nh2: so what it is?
11:55:03 <y> it is random access memory
11:55:09 * zipper is confused.
11:55:42 <nh2> SrPx: it's a circuit that is connected to *all* memory cells with same cable length, with a "multiplexer" in the front that selects which cable is taken
11:55:51 <EvanR> zipper: you seem to have confusion on several fronts, like what json data is representing
11:56:18 <joe9> code : http://codepad.org/roaeH5JA , error: http://codepad.org/3jrW5HXs , ghci output for a similar definition: http://codepad.org/ji7lFLnN
11:56:21 <zipper> EvanR: Where will I start?
11:56:37 <joe9> any suggestions on what I might be missing, please?
11:56:51 <nh2> zipper: the first important bit is to understand the difference between Value and Object (Object == HashMap)
11:57:09 <SrPx> nh2: exactly. The point? The signal flowing from any random bit still has to travel all the way to the multiplexer. Even if you consider bits are stored massively in a sort of spherical shape, it will still take at least a polynomial time (in relation to the max number of elements of the array) for a signal to get out of the sphere. It is not constant in any way.
11:57:19 <EvanR> Value is a type, Object is a type synonym and a DIFFERENT object is a constructor for Value
11:57:52 <EvanR> data Value = Object Object | Array Array | String Text | ...
11:57:59 <EvanR> not helping the confusion ;)
11:58:03 <nh2> zipper: remember `data Maybe a = Just a | Nothing`? A thing of type `Maybe a` isn't an `a` or a `Nothing`, it's a `Just a` or a `Nothing` -- you have to match on the constructor to get the inner thing out
11:58:06 <zipper> nh2: It's like this as far as I know. Value can be an Object, String, Array etc
11:58:13 <SrPx> the fact all memory cells are interconnected doesn't mean they have instant communication..
11:58:16 <zipper> nh2: Am I right?
11:58:25 <bam365> zipper: your ynToBool should look something more like this: http://lpaste.net/113767
11:58:27 <EvanR> zipper: each different case must be enclosed by a constructor, they cant just be those types
11:58:40 <Denommus> wait, wrong channel
11:58:43 <bam365> (granted, that code is completely untested and uncompiled)
11:59:17 <nh2> zipper: so if you know that inside your Value there is a `{...}`, then it is not a `HashMap`, but an `Object HashMap` (HashMap with constructor around that makes it a Value, just like `Just` makes something a `Maybe`)
12:00:37 <hugldubl> given the function 'joiner = read . concatMap show' with 'joiner :: [Integer] -> Integer', how is the argument applied? I want to inline it and don't know where to put my parameter in 'read . concatMap show'
12:00:39 <nh2> SrPx: the terminology "constant memory access" is always meant as constant in respect to the total memory you have - accessing one memory doesn't take longer than accessing another memory cell
12:01:11 <nh2> SrPx: if you consider memory as infinite, then you are right, since you need at least logarithmically growing addresses
12:01:33 <geekosaur> hugldubl, at the end. joiner xs = (read . concatMap show) xs
12:01:47 <nh2> SrPx: but for most discussions, terminology is relative to the arbitrarily bounded, but bounded memory you have
12:02:02 <hugldubl> geekosaur: ah, I tried without parentheses and had no luck. Thank you!
12:02:07 <geekosaur> the parentheses are important there, "read . concatMap show xs" means something different
12:02:22 <hugldubl> yeah, I noticed... :)
12:02:22 <cebewee> > data P a = P (Q a) (Q a)
12:02:24 <lambdabot>  <hint>:1:1: parse error on input ‘data’
12:03:22 <SrPx> nh2: but doesn't it make theoretical complexity analysis meaningless if it assumes random array access? I was looking through the algorithms to solve SAT in less than 2^N steps and all of them use an array somewhere.
12:03:27 <cebewee> I have a type P with data P a = P (Q a) (Q a) for Q is Foldable. Why is "foldMap f (P a b) = foldMap f a <+> foldMap f b" not a valid implementation of foldable?
12:03:35 <SrPx> nh2: O(1) random array access*
12:04:42 <cebewee> GHC complains abou: Could not deduce (a ~ P a)
12:06:20 <nh2> SrPx: in most theoretical complexity analysis, there is no O(1) memory access; for example Turing machines always assume linear memory access, and that works well because in big O doesn't care about these factors, only about the differences between polynomial and greater
12:06:49 <geekosaur> cebewee, probably because, for the type of foldMap f (P a b) to work, f is expecting a thing of type P a, but you then give it a thing of type a
12:06:53 <SrPx> nh2: ah I thought turing machines assumed O(1) random access
12:06:55 <nh2> SrPx: so for your example, an extra factor *N doesn't make the difference in an 2^N or N^x computation
12:07:04 <nh2> SrPx: no, turing machines are tapes
12:07:14 <tremon> SrPx: in engineering problems, I
12:07:22 <tremon> argh.
12:07:48 <kadoban> nh2: ? asymptotic notation definitely does include subpolynomial differences, or did I misread you?
12:07:49 <tremon> SrPx: in engineering problems, O(1) memory access refers to UMA memory layouts, i.e. no processor-bounded memory layout
12:08:57 <geekosaur> actually you aren't even doing that, yoy give it a thing of type Q a...
12:09:06 <SrPx> so all I know about hash-table access being O(1), arrays being O(1) etc etc isn't *actually* true in a theoretical sense? If someone finds different computer architectures all that becomes invalid ?
12:09:13 <cebewee> geekosaur: no, it ought to be an element of type Q a
12:09:16 <cebewee> https://gist.github.com/noschinl/2fe2a29cde5b7d8782b2
12:09:32 <cebewee> ouch. the second one is Maybe (Q a) ...
12:09:37 <cebewee> nevermind :/
12:09:39 <geekosaur> nevertheless, if it is a Q a then how is it a P a?
12:09:41 <nh2> kadoban: yes, it includes it, what I meant is that with turing machines you never care about it because already reading the problem once takes polynomial O(N) time
12:10:06 <kadoban> nh2: Ah, I see. Yeah that makes sense.
12:10:59 <kadoban> SrPx: Yeah your first sentence seems correct. It's O(1) for reasonably sized problems, but that's not really what O() does, so technically it's not true. AFAIU that is.
12:11:13 <EvanR> SrPx: ram lookup is O(1) because its a fixed size ram, which seems to be incompatible with the idea that theres unlimited ram
12:11:13 <nh2> SrPx: it being "true" all depends on the model you're working in. If your model includes "infinite memory" then yes, there is no constant-time data access
12:11:15 <Bartleby> :SrPx 'time' of an algorithm is relative to a set of primitive operations.
12:11:17 <cebewee> geekosaur: hm
12:11:21 <geekosaur> cebewee: consider the type of foldMao
12:11:25 <geekosaur> er, foldMap
12:11:50 <geekosaur> you want it to be something different than Foldable's type specification of foldMap wants it to be
12:11:54 <cebewee> geekosaur: I have a foldMap instance of Q a
12:11:59 <cebewee> s/Q/
12:12:00 <geekosaur> doesn't matter
12:12:01 <nh2> SrPx: in fact, this fit's very nicely into the #haskell channel, because: In pure haskell (algebraic data types only) you cannot define constant-access containers!
12:12:14 <nh2> SrPx: the best thing you can get is logarithmic (a tree)
12:12:22 <nh2> s/fit's/fits
12:13:02 <sinelaw> nh2, you mean for writes
12:13:05 <SrPx> isn't the whole point of `O` considering the time growth for unbounded cases, though?
12:13:05 <sinelaw> I assume
12:13:18 <cebewee> geekosaur: Considering as it works when I remove the Maybe (see the above gist), it seems to matter ;)
12:13:39 <cebewee> Functor and Traversable are still broken, but thats another matter
12:13:44 <nh2> sinelaw: for reads as well, you have to go to the leaves of the tree to read them
12:14:18 <kadoban> SrPx: Well, the whole point of it is as a useful model for analyzing algorithms...so it can make sense to abuse the notation a bit and only consider problems of some limited size. But technically, yes it's supposed to examine the behavior beyond a certain bound, up to infinity.
12:14:30 <sinelaw> nh2 you could create a flat tree at a great cost on each write, ensuring that reads are constant time
12:14:42 <SrPx> I mean, I could just say that my reference operation is picking the minimal element, wrap that concept around a "RMEP" (random minimum element getter) hardware and say I invented a O(N) sorting algorithm...?
12:14:46 <SrPx> RMEG*
12:15:03 <SrPx> kadoban: I see
12:17:20 <kadoban> SrPx: Yes, it also depends on what primitive operations you're talking about. In anything less than...very formal circles though, it usually goes unsaid and people assume a kind of a very simplistic model of a computer only.
12:17:32 <tremon> SrPx: theoretic algorithm complexity is usually independent of the realisation (hardware platform)
12:17:33 <EvanR> SrPx: that would be interesting to see, because theres a practical side to O() junk. and if you managed to show a way to sort things of size 10 100 1000 etc.. with proportional growth that would be amazing
12:17:35 <Bartleby> You could, but you would have to state it relative to your choice of operations, which would reveal it to be trivial.
12:18:16 <EvanR> SrPx: but it only worked up to like 1000 things max, then bummer not that interesting
12:18:23 <kadoban> EvanR: Not really, there's O(n) sorting, you just have to break out of the comparison sorting model.
12:18:46 <Bartleby> Quantum computers can perform certain special statistical transformations on data as primitive operations, so they have different time classes for algorithms.
12:18:47 <EvanR> hows that
12:19:06 <kadoban> EvanR: counting sort is the simplest and best known probably
12:19:13 <Hodapp> radix sort?
12:19:51 <SrPx> It would be limited to 1000 indeed, as I would wire each bit of the memory to a sorting network. I see, then. My point was to understand that random array access isn't actually O(1) in a theoretical sense, just in a practical/engineering sense.
12:20:39 <kadoban> Right. Even in a practical sense it isn't though, when you get into distributed computing or problem sets that won't fit on simple hardware, you go beyond O(1) easily
12:20:43 <SrPx> I guess that makes a further case for investing in purely functional hardwares, I'm really waiting for something like that. I'm just about to take a few processor classes and the whole way they are made feel ugly to me.
12:20:56 <tremon> I would state it the other way around, that it is O(1) in the theoretical sense, just not always in practice
12:21:18 <SrPx> kadoban: interesting!
12:21:29 <nh2> SrPx: strictly, O(..) is a set of functions that you use to classify (state something about) functions, saying that some functions grow slower than other functions. All this happens in the same model, so you can use O notation for both infinite-memory models and finite-memory models
12:22:00 <SrPx> tremon: the point is, it is O(1) if you consider "random array access" as your primitive operation. Which is an obvious result. You could consider anything as your primitive operation and claim it is O(1)...
12:22:04 <nh2> sinelaw: I don't understand what you men with a flat tree
12:22:57 <Denommus> anyone from the GHCJS community there?
12:23:14 <EvanR> SrPx: if they are take the same amount of constant time that would work
12:23:17 <EvanR> all*
12:23:18 <dmj`> Denomus: try #ghcjs
12:23:26 <dmj`> Denommus: ^
12:23:39 <Denommus> dmj`: I didn't know it existed, thanks
12:24:09 <sinelaw> nh2, I mean, to have faster than log reads you could rebuild the entire data structure when writing
12:24:32 <EvanR> counting sort, my mind is blown
12:25:15 <kadoban> EvanR: Hehe :)
12:26:25 <EvanR> kadoban: i get the idea that its intended for like Int values. but should still work for Integer right
12:26:29 <dmj`> doesn't aeson have a strict encode function?
12:26:30 <EvanR> for general key classes?
12:26:37 <dmj`> encode is lazy...
12:26:46 <nh2> sinelaw: still don't get it; in a Tree, how can you read the leaves from the root in constant time?
12:27:13 <kadoban> EvanR: It does to some extent. Simple counting sort, it's actually O(n + k), where k is the range of values you have to work with. So you could use it for Integer, but you have to restrict it to a certain set.
12:27:25 <sinelaw> nh2, I was replying to when you said "In pure haskell (algebraic data types only) you cannot define constant-access containers!"
12:27:42 <dmj`> why doesn't aeson have an enocde function that produces a strict bytestring?
12:28:13 <EvanR> you can convert a lazy bytestring into a strict bytestring if you want
12:28:21 <Hijiri> is field access O(1) or O(n)?
12:28:28 <sinelaw> nh2, so if the data structure is a hash map, (not a tree), you CAN have near-constant access by making writes slower
12:28:53 <Cale> Hijiri: For record types? Closer to O(1).
12:29:09 <Hijiri> Cale: thanks
12:29:17 <dmj`> EvanR: yea, but still
12:29:23 <sinelaw> nh2, that was supposed to be a counter example
12:30:01 <EvanR> dmj`: what do you want to do with it?
12:30:16 <hugldubl> is there a way to split the integer 101002010030100 to [10,20,30] ('100' is delimiter)?
12:30:35 <EvanR> > show 101002010030100
12:30:37 <lambdabot>  "101002010030100"
12:31:03 <Cale> > splitOn "100" . show $ 101002010030100
12:31:05 <lambdabot>  ["10","20","30",""]
12:31:14 <hugldubl> ah, that's nice! Thank you!
12:31:32 <hugldubl> i really start to like haskell :)
12:31:52 <Cale> > endBy "100" . show $ 101002010030100
12:31:53 <lambdabot>  ["10","20","30"]
12:32:06 <johnw> > map read . endBy "100" . show $ 101002010030100 :: [Int]
12:32:08 <lambdabot>  [10,20,30]
12:32:20 <Cale> Note, these functions are in Data.List.Split in the split package that you can get from Hackage
12:32:20 <joe9> Can anyone please help? I am trying to figure out the type definition of Applicative join for the Cont monad.
12:32:29 <Cale> Applicative join?
12:32:31 <johnw> joe9: hello!
12:32:33 <joe9> http://codepad.org/IzyPSr2I is my source.
12:32:38 <josephle> Applicative...join?
12:32:38 <joe9> Cale, Hello.
12:32:53 <nh2> joe9:  just figured out your solution
12:32:58 <Cale> Oh, you mean ap/(<*>)
12:32:58 <joe9> johnw, one minute. I have been trying to find you for for some days.
12:32:59 <dmj`> EvanR: I don't like having too many conversion functions, stuff gets ugly
12:33:04 <johnw> joe9: yeah, I know! :)
12:33:25 <joe9> Cale, the <$> function.
12:33:33 <nh2> joe9: give me a moment to let me try describe what you do wrong
12:33:33 <Cale> <$> is fmap
12:33:34 <mauke> <$> is fmap
12:33:34 <josephle> <$> is fmap. <*> is what you want
12:33:49 <EvanR> dmj`: i am curious why is lazy bytestring not good enough
12:33:50 <hugldubl> Cale: Are they all from split? I mustn't use it :(
12:33:53 * josephle defers to Cale :)
12:33:56 <joe9> josephle: oh, ok. thanks. got confused between idris and haskell.
12:34:05 <Cale> @djinn (((a -> b) -> r) -> r) -> ((a -> r) -> r) -> ((b -> r) -> r)
12:34:06 <lambdabot> f a b c = b (\ d -> a (\ e -> c (e d)))
12:34:52 <Cale> hugldubl: Well, you could always peek at how those things are implemented
12:35:01 <nh2> joe9: ok. Would you agree that your function must be of this shape: applicativeJoin cf ca = Cont (\b2r -> )
12:35:09 <nh2> ?
12:35:14 <nh2> applicativeJoin cf ca = Cont (\b2r -> ...)
12:35:24 <joe9> nh2, yes, it has to be.
12:35:33 <Cale> hugldubl: Though Data.List.Split is really clever about how it constructs splitting functions, so if this is homework, you'll surely be given away :D
12:36:07 * hackagebot HaTeX 3.15.0.0 - The Haskell LaTeX library.  http://hackage.haskell.org/package/HaTeX-3.15.0.0 (DanielDiaz)
12:36:09 <nh2> joe9: ok, so in there you have a function that takes a `b` and makes an `r`. You have to get this `b` from somewhere. Where can you get it from?
12:36:57 <hugldubl> Cale: Of course. But there is no simple existing solution without split? It's homework, but It's a competition task about a short solution.
12:37:24 <joe9> nh2 I liked your usage of b2r, makes a lot more sense than my k.
12:37:29 <EvanR> short solution without the short solution function
12:37:35 <Cale> hugldubl: Well, you might instead try to use just stuff from Data.List...
12:37:37 <joe9> a2b has to come from the cf.
12:38:02 <joe9> nh2: I thought "runCont cf (b2r .)" could do it.
12:38:07 <Ouyang> can anyone reccomend me a source on  completely reinstsalling cabal?  I get Error 1's all the time and no clue on whats going wrong
12:38:09 <joe9> nh2: let me give this more thought.
12:38:10 <hugldubl> Cale: Yeah, I guess I have to do this. Thank you
12:38:50 <sebastiankg> How is list comprehension a monad when its return type has no monadic portion? I thought that with monads, you can never get "out of" the monad
12:39:17 <mauke> list comprehension is not "a monad"
12:39:18 <nh2> joe9: that's right, a2b comes from the cf. So now you have a2b and b2r, so to get an r the only thing you need to create an r is ...?
12:39:33 <sebastiankg> but I read that it was syntactic sugar for "the list monad"
12:39:49 <sebastiankg> I'm pretty new at this and I'm trying to understand why this doesn't make sense
12:40:10 <mauke> sebastiankg: list comprehensions don't have an arbitrary result type. they must return a list.
12:40:30 <nh2> sebastiankg: your assumption "its return type has no monadic portion" is false: [] is a monad, it is the `m` that you often see in monadic function
12:40:30 <jle`> you can't "get out of" a Monad instance in general (that is, if all you know about a type is that it's a Monad, you can't "get out" of it), and in general, not all Monads have a way out
12:40:47 <jle`> however, when you are working with a specific type, then you can do whatever you want with that type
12:40:50 <Cale> "get out of" is such a terrible way of speaking
12:40:55 <jle`> because the type is...the type
12:40:57 <nh2> sebastiankg: you can understand [a] as syntactic sugar for `[] a`, which matches nicely with `m a`
12:41:10 <Entroacceptor> if I want to cross compile my program to run on a rasperry pi, what's the best way to do it? Do I still have to build my own ghc?
12:41:18 <jle`> [a] is [a], anything you can do with [a], you can do with [a]
12:41:23 <jle`> tautology much
12:41:29 <mbuffett1> Hey guys, I've got a few data types, Game, Piece, and Coord, and I'm trying to get the piece at a specified position, or Nothing if there is no piece there, but I'm stumped. The code is here if anyone wants to help me out : http://lpaste.net/113771
12:41:33 <y> w a → a? comonad? :P
12:41:56 <mitchty> maybe i'm missing something, but what is the way to pass CFLAGS/LDFLAGS to ghc via cabal
12:42:26 <sebastiankg> ah okay, so it's simply that the List monad applies [] to a and is therefore a useful type anyways... while "IO" with regards to the IO Monad is not a useful return type and has to be worked around
12:42:34 <Cale> > let (xs,ys) = break (isPrefixOf "100") (tails "101002010030100") in (concatMap (take 1) xs, concatMap (take 1) (drop 3 ys))
12:42:36 <lambdabot>  ("10","2010030100")
12:42:44 <Cale> hugldubl: ^^ might be useful
12:43:05 <jle`> sebastiankg: i don't hink it's too useful to think about list comprehension as an application of the list monad instance
12:43:07 <hugldubl> thank you
12:43:14 <jle`> just think about it as combinations of concatMaps
12:43:16 <dfeuer> Cale, whact are you doing?
12:43:17 <jle`> and guards
12:43:23 <Hijiri> oh wow, the w is an upside-down m
12:43:27 <Hijiri> how did I not notice that
12:43:33 <dmj`> jle`: ahoy
12:43:34 <Cale> dfeuer: one step of endBy "100"
12:44:17 <EvanR> you couldnt fight yours way out of a paper monad
12:44:17 <Cale> dfeuer: hugldubl wants to implement endBy "100" without using Data.List.Split
12:44:37 <EvanR> get out of the burrito
12:44:40 <jle`> dmj`: ahoy
12:44:43 <Cale> sebastiankg: That seems like sort of a ridiculous way of looking at it
12:44:44 <jle`> congrats on your release
12:44:44 <hugldubl> I want? I have to ;)
12:44:56 <Cale> sebastiankg: A value of type (IO t) is nothing at all like a value of type t
12:45:06 <nh2> jle`, sebastiankg: I don't find it un-useful to think of list comprehensions as the list monad - that's what they desugar to, and with MonadComprehensions they are precisely the same
12:45:08 <Cale> sebastiankg: Instead, it's a program which if executed, will produce a result of type t
12:45:36 <dfeuer> nh2, that's not what they desugar to, and I recently realized that the monadic stuff isn't even implemented to fuse properly.
12:45:56 <jle`> nh2: but, "list comprehensions as the list monad" doesn't even make sense.
12:45:59 <jle`> it's not even a meaningful thing to say
12:46:05 <sebastiankg> hmm, I clearly have a lot to learn about Monads still. From what I had understood, the application of a monadic function always leaves behind a trace type that wouldn't be found in pure functions
12:46:07 <sebastiankg> such as IO
12:46:07 <dfeuer> And I'm trying to get that fixed, but I'm dealing with a lot of little changes to the same files, which is leading to trouble getting things accepted.
12:46:12 <Cale> sebastiankg: Just like you wouldn't usually speak of "unwrapping" /bin/ls to get a list of files, it doesn't make much sense to think that way when discussing IO actions
12:46:34 <jle`> sebastiankg: on specific types, Monad methods are just normal ol' helper functions
12:46:46 <Cale> sebastiankg: There are many different examples of the monad interface, but all that saying that something is a monad implies is that its API conforms to a particular shape
12:46:48 <jle`> sebastiankg: using (>>=) and return on a list monad is basically a sugary way to use concatMap and (:[])
12:46:54 <Cale> sebastiankg: It really doesn't say much at all
12:47:11 <jle`> sebastiankg: there's nothing inherently special about concatMap and (:[]) on the list type.  they're just normal functions
12:47:11 <Cale> sebastiankg: It's better just to consider what the values really are. Different monads are different.
12:47:13 <dfeuer> sebastiankg, yeah, there's nothing special about Monad instances. For IO, (>>=) is actually defined as the function bindIO.
12:47:15 <sebastiankg> so here's a simple question then, can I apply a monadic function in a pure function?
12:47:25 <Cale> Maybe?
12:47:26 <jle`> what is a monadic function, what is a pure function?
12:47:27 <dfeuer> Yes, sebastiankg.
12:47:30 <Cale> What's a "monadic function"?
12:47:31 <nh2> dfeuer: things you find somehow always make me uncomfortable. What do they desugar to?
12:48:02 <sebastiankg> My understanding was that monadic == has side effects, pure == no side effects
12:48:03 <nhjk> why is haskell so slow here http://www.techempower.com/benchmarks/ ?
12:48:04 <mauke> > let x = putStr "hello\n" in length [x, x, x]
12:48:06 <lambdabot>  3
12:48:10 <Cale> Let's *just* focus on IO for a moment, because you seem to be confusing IO with other monads a whole lot
12:48:11 <mauke> sebastiankg: all functions are pure
12:48:25 <EvanR> monadic front effects would be better
12:48:36 <Cale> So, in Haskell, we have this (parametric) data type called IO
12:48:47 <dfeuer> nh2, they desugar directly to foldr/build forms. Except I think there's some weird option that makes them use concatMap. Or there used to be one, anyway.
12:49:01 <Cale> Values of type (IO t) are descriptions of things which could be performed (and which may have effects) in order to produce a value of type t.
12:49:14 <Cale> IO actions are capable of describing pretty much anything your computer can do
12:49:15 <jle`> sebastiankg: for specific monad instances, the monad functions are just normal, useful helper functions that you can just use on their own.  you can do concatMap and (:[]) for lists normally.  and the result is still just a list.  a normal list that you can do whatever you want with
12:49:32 <nh2> dfeuer: if you enable MonadComprehensions, do they desugar do something different then?
12:49:40 <dfeuer> I have no idea.
12:49:45 <dfeuer> Could be?
12:49:51 <Cale> Some simple examples:
12:50:15 <dfeuer> nh2, I'm trying to make the monadic things match the comprehension things, for a 53% allocation reduction in one nofib test.
12:50:21 <nh2> nhjk: that's a very difficult question, the best way to get an answer is to ask the snap and yesod people (e.g. snoyberg) what they think why their servers are slow in this benchmark
12:50:23 <Cale> getLine :: IO String  is the action which asks the user for a line of text on the terminal, and its String result is the user's response
12:50:51 <Cale> putStrLn :: String -> IO ()  is a function which given some String, produces the action which when executed will print that string on the terminal
12:51:05 <Cale> and the result of that action will be an empty tuple
12:51:08 <nh2> dfeuer: please do it, and please also make all the other things fast! :) If you come to Munich I buy you a beer or equivalent other beverage btw.
12:51:32 <Cale> sebastiankg: It's very important to understand that execution of IO actions is a separate process from evaluation of expressions
12:51:43 <EvanR> bring your own equivalent other beverage
12:52:08 <Splike> hey guys, just wondering if anyone knows of an stock trading backtest framework written in haskell? I'm trying to use quantopian/python but its annoying the hell out of me
12:52:12 <dfeuer> Thanks, nh2.
12:52:16 <Cale> Evaluation is the process of converting expressions into values for pattern matching. Evaluating an expression will never (barring some low-level hooks normal users wouldn't use) cause execution of IO actions.
12:52:50 <Cale> Execution of IO actions means carrying out the described effects.
12:53:08 <dfeuer> I like to think of IO actions as recipes.
12:53:09 <Cale> In a compiled Haskell program, the IO action called main gets executed.
12:53:26 <Cale> and in turn, it may request that other IO actions are executed
12:53:28 <zwer> print 10 `seq` 10 <- does this force evaluation of print 10? can we use this as a p
12:53:30 <dfeuer> A recipe for chocolate cake is not a chocolate cake.
12:53:42 <dfeuer> It's a piece of paper with some words on it telling you how to make a chocolate cake.
12:53:45 <zwer> as a demonstration that evaluating IO action does not result in execution of that action
12:53:51 <johnw> it's a chocolate thunk
12:53:54 <Cale> zwer: Yeah, that will *evaluate* print 10, but it won't actually cause the effect of printing 10 to occur
12:54:04 <sebastiankg> okay that makes sense, so basically the IO type just marks where IO side effects will occur after the code has been evaluated?
12:54:11 <dfeuer> No.
12:54:13 <Cale> NO
12:54:14 <zwer> Cale ok
12:54:32 <EvanR> the specific details of a given IO a value, if you have one, arent readily apparent without knowing where you got it, that is annoying and reminds me of dynamically typed programming. if there was a way to inspect a given IO a value without even executing it that would be cool
12:54:36 <dfeuer> sebastiankg, it's simpler than that.
12:54:38 <Cale> sebastiankg: Think of an IO action as consisting, say, of source code for a C program which could be executed.
12:55:00 <Cale> sebastiankg: That's not true, but it's closer to the truth than thinking of it as a type-level tag
12:55:06 <nh2> sebastiankg: although it may seem convenient to strictly differentiate between "monadic" and "non-monadic" functions, there is no such thing. "Side-effect" is a term that's always relative to the computational context you're talking about. For example, Maybe is a monad, and you could say that it's side-effect is that "a value of type a could be nonexistent". But of course a `Maybe a` is also a very pure value. Being "monadic" is less about "what 
12:55:22 <Cale> sebastiankg: IO t values are descriptions of things which could be done to produce a value of type t
12:55:26 <sbrg> I look forward to explaining the IO monad to my students. x.x
12:55:45 <Cale> sebastiankg: You wouldn't think of /bin/ls as a list of files which has some kind of effectful tag on it
12:55:48 <dfeuer> nh2, is less about "what ----- broken off
12:55:51 <merijn> sbrg: tbh, I've not had much trouble explaining it to people
12:56:01 <EvanR> the word "effect" got thrown around with monadic style, but means something very different from effects in context of IO
12:56:04 <Cale> sebastiankg: So don't think of an IO String as some kind of effectful String
12:56:15 <Cale> sebastiankg: It's a program which if you were to run it, would produce a String
12:56:19 <merijn> sbrg: The trick is to drive home the point of "evaluation != execution" immediately when you introduce IO
12:56:21 <nh2> dfeuer: my client show's it all fine; the remaining content was:
12:56:23 <nh2> ... less about "what something is", but more "what you can do with it" - namely that values that are Monads have a natural way of "binding values" together, or "chaining" them
12:56:29 <Cale> sebastiankg: Any clearer? :)
12:56:38 <sbrg> merijn: Hmm, well. It is one of those issues that people frequently have problems with.
12:56:44 <sbrg> Along with monads in general
12:56:53 <sebastiankg> Okay so let me try to summarize my current understanding again :p you guys are helping tons, but I'm going to try to show that I understand
12:56:55 <sbrg> I'm just the TA, though, so I'm hoping the professor drives that home @ merijn
12:56:58 <Cale> sebastiankg: An IO String "contains" a String in exactly the same way that /bin/ls "contains" a list of files
12:57:10 <EvanR> Cale: i.e. it doesnt
12:57:13 <Cale> (which is to say, that it doesn't really)
12:57:52 <sebastiankg> The IO Type describes the action to do to produce a String in IO String?
12:58:21 <Cale> A value of type IO String, is a description of an action which could be carried out to produce a String
12:58:28 <Cale> (assuming that the action completes)
12:58:39 <nh2> sebastiankg: like Cale said, you can think of an IO action (thing of type `IO a`) as a piece of paper, a recipe that has written on it what to do to get a value of type a from the real world. You can give the Haskell runtime this paper, and it will go out to the real world, do what it says on the paper, and bring you back the a.
12:58:53 <EvanR> the effects might not have anything to do with that String though, that just happens to be the response type
12:59:16 <Cale> Even nh2's description is more metaphorical than I want to be, but if it makes sense to you, then great :)
12:59:18 <sebastiankg> okay, I think I understand that now
13:00:11 <merijn> sebastiankg: This should also explains why (despite sloppy writers implying differently) IO is still pure
13:00:32 <Cale> Okay, so this IO type *happens* to be a monad. But monads really have nothing to do with effects in general, except in a very abstract way which is not what ordinary people mean when they say "effects".
13:01:03 <merijn> sebastiankg: "putStrLn :: String -> IO ()" is a pure function, why? Well, pure means "same result for same input" and "putStrLn" applied to the same String will return the exact same "description of an action to print a String"
13:01:05 <EvanR> "programming with effects" is confusing terminology, in practice
13:01:05 <sebastiankg> so, but if we were to apply a function that returns IO String within another function, how would I use the IO String value as a String?
13:01:07 <Cale> They are really just a pattern which occurs in many different libraries
13:01:15 <nh2> joe9: solved your problem?
13:01:15 <sebastiankg> Because an "IO String" value isn't very useful
13:01:26 <Cale> sebastiankg: Well, you can't use an IO String as a String
13:01:36 <Cale> It's a program which when you run it will give you a String
13:01:44 <Cale> So you have to execute it if you want the result.
13:01:52 <merijn> sebastiankg: Well, our abstract IO type comes with a composition function that glues "an IO action" and "a function producing an IO action" into a bigger IO action
13:01:58 <Cale> IO actions are allowed to execute other IO actions.
13:02:05 <merijn> sebastiankg: It looks like this "IO a -> (a -> IO b) -> IO b"
13:02:09 <Cale> You can use do-notation to indicate this
13:02:16 <Cale> do v <- x; ...
13:02:33 <mbuffett1> I have a data type Piece which has a color, white or black. I have a function with the signature printPiece :: Maybe Piece -> IO ()
13:02:33 <sebastiankg> And that a -> IO b function is "bind", right?
13:02:39 <Cale> This means "execute the action x, and call its result v"
13:02:41 <Cale> If x :: IO t, then v :: t
13:02:53 <Cale> v will be available throughout the remainder of the do-block
13:02:55 <merijn> sebastiankg: Secretly the type I just wrote is the type of (>>=), yes :)
13:03:07 <Cale> and the do-block as a whole is then an expression denoting an IO action
13:03:07 <mbuffett1> Oops, didn't mean to send that, how do I check the color and that it's "Just" a piece?
13:03:28 <sebastiankg> okay okay. So now for some reason I thought that >>= was a function that I could only use inside "monadic" functions
13:03:29 <merijn> mbuffett1: Depends on what the Piece datatype looks like
13:03:39 <mbuffett1> pieceColor piece doesn't work because it's of type Maybe Piece, not Piece
13:03:40 <Cale> sebastiankg: (>>=) is part of the definition of a monad
13:03:49 <merijn> sebastiankg: No, >>= is "just another function"
13:03:51 <Cale> sebastiankg: but again, let's not worry about that yet
13:03:55 <EvanR> sebastiankg: you can use it anywhere.
13:04:03 <Cale> We'll worry about monads in general once you have a few examples
13:04:16 <sebastiankg> okay sure
13:04:22 <merijn> mbuffett1: What's the definition of Piece?
13:04:32 <Cale> Well, maybe I can explain what it is that makes IO a monad
13:04:45 <EvanR> > Just 1 >>= \n -> Just (n + 1)
13:04:47 <lambdabot>  Just 2
13:04:52 <merijn> sebastiankg: We might as well have had a built-in "firstAndThen :: IO a -> (a -> IO b) -> IO b"
13:04:52 <EvanR> > Nothing >>= \n -> Just (n + 1)
13:04:54 <lambdabot>  Nothing
13:04:55 <Cale> A monad consists of three things:
13:05:25 <Cale> 1) A type constructor M (such as IO, Maybe, the type constructor for lists, ...)
13:05:37 <Cale> 2) A definition of a function  return :: a -> M a
13:05:52 <Cale> 3) A definition of a function  (>>=) :: M a -> (a -> M b) -> M b
13:06:10 <Cale> and these have to satisfy a few conditions which we'll ignore for the time being
13:06:24 <michi7x7> > replicateM 3 [True, False]
13:06:25 <lambdabot>  [[True,True,True],[True,True,False],[True,False,True],[True,False,False],[Fa...
13:06:40 <joe9> nh2, sorry queried you. I got sidetracked.
13:06:47 <joe9> nh2 I am getting to it now.
13:06:52 <joe9> nh2 sorry for the delay.
13:07:07 <sebastiankg> ah okay,, that makes sense. I watched the Brian Beckman "Don't Fear the Monad" talk on YouTube, for context
13:07:12 <Cale> sebastiankg: Functional programmers doing their normal thing run into this pattern on a regular basis
13:07:21 <Cale> I hate that Brian Beckman video
13:07:35 <Cale> He wastes like 90 minutes not explaining what monads are
13:07:42 <sebastiankg> I was thinking you might! Because it is very hard to apply it to using anything
13:07:44 <Cale> and not really providing any examples
13:07:49 <EvanR> instance Monad Burrito where
13:08:21 <johnw> does the join mean my tortillas keep getting more dense?
13:08:38 <Cale> sebastiankg: So, as another example, you might have a parsing library
13:08:46 <dmj`> if your burrito shell breaks, join will rewrap it :)
13:08:53 <josephle> or your tortillas keep consuming the outer tortillas...
13:08:59 <josephle> that's a weird image
13:09:16 <Cale> which perhaps defines among other things a datatype  Parser t  of parsers which eat some initial portion of their input in order to attempt to produce a value of type t
13:09:36 <merijn> @google You Could Have Invented Monads (and Maybe You Already Have!)
13:09:38 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
13:09:38 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Al...
13:09:41 <EvanR> you know what sucks about monads? the whole tutorial fallacy and rejection that there is any substantial explaining to do about them, and so they remain just as confusing as ever to non-functional community, and this obscures stuff in haskell that is actually interesting and has nothing to do with monads
13:09:59 <michi7x7> fail _ = ChipotleExtraHot ?
13:10:12 <johnw> EvanR: are you asking for more tutorials?
13:10:18 <Cale> alongside a function  return  which constructs a parser that "does nothing" except to succeed in parsing produce a given value as its result
13:10:19 <sinelaw> hi! what's a good example of why types are not equivalent to sets?
13:10:23 <Cale> *and
13:10:35 <merijn> sinelaw: "it depends"
13:10:37 <nh2> joe9: no worries; just that I have to go soon. In case you need a compiling solution and don't want to figure it out, click on this one http://codepad.org/7LmJVZll (but I think you'll get it soon)
13:10:44 <EvanR> johnw: no if anything just MIB mind wipe any knowledge of monads from the blogosphere would help
13:10:52 <merijn> sinelaw: Some type theory models involve treating types as sets
13:10:54 <Cale> i.e. return v will be the parser which eats none of the input and simply succeeds with result v
13:11:15 <joe9> monads clicked for me after reading this: http://stackoverflow.com/questions/44965/what-is-a-monad
13:11:16 <josephle> merijn: that's ETT, right?
13:11:42 <joe9> nh2, thanks let me try it and if I cannot figure it out, I will use the info pasted.
13:11:46 <johnw> sinelaw: https://www.andrew.cmu.edu/user/awodey/preprints/stcsFinal.pdf
13:11:47 <joe9> Thanks a lot, nh2.
13:11:55 <nh2> joe9: welcome!
13:11:58 <Cale> sebastiankg: and then lastly, an operation (>>=) :: Parser a -> (a -> Parser b) -> Parser b  such that p >>= f will be the parser that parses the initial portion of its input with parser p, getting some result v of type a, and then parses the remainder of its input with f v
13:12:00 <nh2> EvanR: I think LYAH takes a good approach at explaining monads and doesn't overhype things
13:12:21 <johnw> nh2: except that I found it a rather poor explanation, as a beginner
13:12:35 <Cale> sebastiankg: i.e. it's sort of like concatenation of parsers, except that we're using the result of the first parser to determine which parser to use on the remainder of the input
13:12:58 <Cale> sebastiankg: Of course, any parsing library will define more than just this stuff, but this is just the stuff required to make an instance of Monad
13:13:14 <EvanR> i just ignore any semi-serious question about monads and redirect to Functor first
13:13:18 <sebastiankg> hmm okay. That's fairly abstract but I think I understand
13:13:24 <codygman> Can you run ghci with the -s option of ghc that outputs memory and garbage collector performance?
13:13:25 <Cale> sebastiankg: and the only value in recognising something as a monad is that there's a bunch of stuff people have written to work whenever we have a definition of return and (>>=)
13:13:27 <johnw> EvanR: I approve of that plan
13:13:28 <EvanR> way more useful
13:14:16 <nh2> codygman: what would you want to achieve with this? The evaluation of a program in ghc is entirely different than that of compiled code, so you would get little information about what's going on in the binary
13:14:27 <sebastiankg> Do all monads have an equivalent of what we were talking about with IO
13:14:33 <EvanR> do you think a tutorial culture about Functor could be supported? probably not
13:14:34 <nh2> codygman: except if you really care about what's going on in ghci evaluations themselves
13:14:36 <sebastiankg> where their type is a recipe to get a simpler type?
13:14:38 <sebastiankg> or no?
13:14:48 <sinelaw> johnw, thanks
13:14:54 <Cale> sebastiankg: Well, would you think of a list of integers as a recipe to get an Integer?
13:15:25 <sebastiankg> No, I suppose not
13:15:35 <Cale> Because we certainly can define  return :: a -> [a]  and  (>>=) :: [a] -> (a -> [b]) -> [b]  to turn the list type constructor into a monad
13:15:58 <EvanR> sebastiankg: it sounds like youre talking about a parameterized type in general, rather than monads
13:16:13 <Cale> There is a sense in which a list of integers can behave a bit like a program which emits integer results though
13:16:23 <merijn> josephle: ETT?
13:16:25 <sinelaw> but is there a simplistic example of something about types that doesn't work with sets or vice versa? I understand there are different models, just want to show why it isn't straightforward to say "oh, types are just sets"
13:16:28 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
13:16:30 <lambdabot>  [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2,...
13:16:37 <merijn> josephle: Oh, right, I lost context :)
13:16:48 <merijn> josephle: tbh, I'm not sure which ones are like that
13:16:48 <Cale> ^^ you can think of "running" a list as meaning selecting a value from it (in all possible ways)
13:16:51 <nh2> sebastiankg: my "recipe" analogy was only for IO specifically; if you're looking for the thing that is common among all monads, it is the "binding operation" (>>=) :: m a -> (a -> m b) -> m b
13:17:29 <sebastiankg> yeah, and also there's this whole concept I'm running into in Haskell where a -> b -> c is a lot like a -> b -> (a,b)
13:17:43 <Cale> sebastiankg: er...
13:17:49 <EvanR> a -> b -> c is a lot like a -> (b -> c)
13:17:56 <sebastiankg> just that there is no defined way that the two types amalgomate, so they are tupled together instead
13:17:58 <Cale> sebastiankg: Do you mean a -> b -> c is like (a,b) -> c ?
13:18:38 <Cale> (because you'd be right in that case)
13:18:42 <Cale> :t curry
13:18:44 <lambdabot> ((a, b) -> c) -> a -> b -> c
13:18:47 <Cale> :t uncurry
13:18:48 <lambdabot> (a -> b -> c) -> (a, b) -> c
13:18:52 <sebastiankg> no, I'm thinking like... IO String is a type which still labels what its components are, whereas [a] may have come from [] and a but it has a new name, a List
13:19:21 <EvanR> sebastiankg: see no, you are thinking of parameterized types. like Set String is the type for sets of strings
13:19:22 <josephle> sinelaw: if you want to go further into that question, Homotopy Type Theory models sets as the 0th level of the type hierarchy
13:19:26 <Cale> I'm not sure what you mean by "labels what its components are"
13:19:29 <EvanR> which isnt a monad
13:20:07 <joe9>  nh2 "a2b comes from the cf. So now you have a2b and b2r," -- In this line, cf does not have a2b, it has the values a and b, and given this function (a -> b -> r) can give r, correct?
13:20:07 <Cale> sebastiankg: What do you mean by "components" here?
13:20:23 <EvanR> the type parameters dont necessarily mean containers, or recipes, it might mean nothing at all except to check types
13:20:28 <josephle> sinelaw: some notes on HoTT http://www.cs.cmu.edu/~rwh/courses/hott/
13:20:36 <Cale> sebastiankg: Oh, are you just referring to the fact that [a] is special syntax?
13:20:42 <Cale> sebastiankg: We could write List a instead
13:20:42 <sebastiankg> yeah, basically
13:20:45 <sinelaw> josephle, thanks. I have the book too. not enough time though :)
13:21:03 <quazifarhan1> hello, just a quick question. boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]    line is giving the error  "parse error on input ‘=’ ".. Can someone give any tip. thanks a lot.  I am copy-pasting from http://learnyouahaskell.com/starting-out, still getting the error
13:21:04 <Cale> sebastiankg: If Haskell didn't have this special syntax for the list type, we might define the type of lists like:
13:21:11 <Cale> data List a = Nil | Cons a (List a)
13:21:16 <Cale> and then List would be a monad
13:21:23 <Cale> and we'd have  return :: a -> List a
13:21:29 <josephle> sinelaw: In the context of ITT and HoTT, types as sets depends on how you treat propositional equality
13:21:31 <Cale> and  (>>=) :: List a -> (a -> List b) -> List b
13:21:43 <sebastiankg> right! See now that makes sense to me
13:22:06 <zwer> > return 10 :: [] Int
13:22:07 <Cale> The type constructor for lists on its own can be written []
13:22:08 <lambdabot>  [10]
13:22:19 <Cale> But it's just a little weird to write it like that
13:22:42 <Cale> (apart from in cases where you really have to)
13:22:48 <EvanR> data [a] = [] | a : [a]
13:22:55 <sebastiankg> yeah, but it makes it so much easier to understand for me, because the combination of types into a new type with a new name obfuscates the magic a little bit
13:22:56 <Cale> Similarly, it's possible to make the function type constructor prefix
13:23:04 <Cale> and write (->) a b instead of a -> b
13:23:21 <Cale> It turns out that for any type e, the type constructor (->) e is a monad too
13:23:53 <shapr> Cale: why is that?
13:23:55 <sebastiankg> how does (->) e make sense though?
13:24:02 <sebastiankg> isn't that kind of incomplete?
13:24:06 <sebastiankg> e -> ?
13:24:10 <EvanR> partial application
13:24:15 <joe9> nh2, you around?
13:24:20 <Cale> :k (->)
13:24:21 <lambdabot> * -> * -> *
13:24:25 <Cale> :k (->) Integer
13:24:27 <lambdabot> * -> *
13:24:28 <johnw> shapr: the reader monad
13:24:29 <Cale> :k (->) Integer String
13:24:30 <lambdabot> *
13:24:40 <shapr> hm
13:24:40 <nh2> joe9: I should have said: If you run `runCont cf`, you have to give it a function a function that takes an \(a2b :: (a->b)), so you have something that can turn `a`s to `b`s (let's keep calling it a2b)
13:24:41 <Cale> Let's look at the kinds :)
13:24:51 <josephle> sinelaw: if you believe that propositionally equality should be equivalent to definitional equality, then types are sets :)
13:24:54 <Cale> Kinds are like types of types
13:25:04 <Cale> Or types of type-level things
13:25:16 <Cale> * is the kind of all the ordinary types which have values in them
13:25:35 <shapr> right
13:25:39 <Cale> * -> * is the kind of type constructors (like IO, List, Maybe, etc.) which accept a type argument and produce a type
13:25:43 <shapr> ok
13:25:45 <EvanR> :k Void
13:25:46 <lambdabot> Not in scope: type constructor or class ‘Void’
13:25:53 <nh2> joe9: so if you have a2b::(a -> b) and b2r::(b -> r), and you want to create an r, you need?
13:26:37 <Cale> * -> * -> * is the same as * -> (* -> *), and it's the kind of type constructors which accept a type argument, and produce a type constructor which accepts yet another type argument in order to produce a type
13:26:57 <Cale> (->) is an example of that
13:27:05 <shapr> right
13:27:34 <joe9> nh2, I need a. and that comes from ca.
13:27:34 <Cale> String -> Integer is the same as (->) String Integer which is the same as ((->) String) Integer
13:27:38 <sinelaw> josephle, that was my guess. so if one set is defined by specifying the elements literally while another uses a predicate that results in the same elements, they would or would not be considered equal with propositional equality?
13:27:45 <sinelaw> I mean definitional equality
13:27:49 <joe9> nh2, let me try this through again..
13:27:52 <Cale> sebastiankg: Is that gibberish, or does it make sense?
13:28:07 <Cale> So, in the case of M = (->) e, we get
13:28:12 <Cale> return :: a -> (e -> a)
13:28:14 <sebastiankg> That totally makes sense :)
13:28:17 <nh2> joe9: right. If you have an `a`, you can stuff int into a2b, then you get a `b`. This `b` you can stuff into `b2r` and you get an `r`.
13:28:24 <michi7x7> > let boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x] in boomBangs [1,5,19,4,22]
13:28:25 <Cale> (>>=) :: (e -> a) -> (a -> (e -> b)) -> (e -> b)
13:28:26 <lambdabot>  ["BOOM!","BOOM!","BANG!"]
13:28:46 <michi7x7> quazifarhan ^
13:28:47 <Cale> Basically, M x = e -> x  here
13:28:55 <josephle> sinelaw: if you can write a proof of their equality, then they are propositionally equal.
13:29:13 <joe9> nh2, it seems so simple when you explain it.
13:29:24 <josephle> sinelaw: in this case, a proof means you can show the type S1 == S2 is inhabited (where S1 was your first type and S2 was your second type)
13:29:25 <joe9> nh2, i feel brain-less.
13:29:45 <Cale> So, what does this monad give us? What does it mean to "run" a function in the context of do-notation? Well, it means to apply it to the same argument that the whole function has been applied to, an example or two will help:
13:30:00 <josephle> sinelaw: the key question is if you've proven that S1 == S2, do you think you can use S1 and S2 interchangeably?
13:30:02 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
13:30:04 <lambdabot>  ("hello","olleh","HELLO")
13:30:17 <josephle> sinelaw: if yes, then types are sets. If no, then types are not sets :)
13:30:23 <Cale> This is using the (->) String monad
13:30:43 <sinelaw> josephle, that's a nice way to put it
13:31:20 <Cale> sebastiankg: Monad is just an abstraction for this particular shape which appears all over the place in various libraries once you know to look for it
13:31:22 <nh2> joe9: this is Cont. Will always feel like this. When it compiles it is so simple, but before you spend long times figuring. I also needed 5 minutes to make it compile
13:31:41 <sebastiankg> huh, okay, makes sense!
13:31:52 <sebastiankg> in (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello", though
13:31:52 <Cale> sebastiankg: There would be no real value in abstracting over this if we couldn't write functions which work using an arbitrary choice of monad, but thankfully we can :)
13:31:54 <quazifarhan> michi7x7 thanks a lot, was scratching the head for a while
13:32:06 <joe9> nh2: the bigger take-away for me is how you used the variable names a2b and b2r. That is so much more descriptive than f or k.
13:32:12 <sebastiankg> return (x,y,z) is a little confusing to me
13:32:15 <sinelaw> gnight
13:32:30 <sebastiankg> I understand return
13:32:34 <joe9> nh2, where did you pick that from? Any hints.
13:32:36 <Cale> Well, we should really look at how two things work to make that example make sense
13:32:37 <josephle> sinelaw, in the context of dependent types, note that S1 and S2 don't necessarily need to be types
13:32:39 <EvanR> :t return (1,2,3)
13:32:40 <lambdabot> (Num t2, Num t1, Num t, Monad m) => m (t, t1, t2)
13:32:44 <Cale> First, I never really explained what do-notation was
13:32:50 <joe9> nh2, any more hints like that.
13:32:59 <zwer> sebastiankg is it any more confusing than: return x?
13:33:01 <Cale> and secondly, we didn't look at how return and (>>=) were really implemented for this function instance
13:33:03 <sebastiankg> Do notation is just a sequence of binds, right?
13:33:04 <EvanR> :t return (x,y,z)
13:33:05 <lambdabot> Monad m => m (Expr, Expr, Expr)
13:33:06 <joe9> nh2, do you have any github repo or some such code. so, I can check out your code to learn.
13:33:08 <Cale> More or less, yes
13:33:10 <josephle> sinelaw, but the fundamental thing is if you can prove that x == y, then can you use y wherever x is used?
13:33:13 <sebastiankg> well the problem I have with return (x,y,z)
13:33:18 <sebastiankg> is how does it know x, y and z?
13:33:23 <Cale> do { x } = x  -- the base case with just a single action
13:33:25 <nh2> joe9: I think giving names like that helps a lot, to be always clear about what functions in scope can do for you
13:33:36 <EvanR> :t return x
13:33:37 <lambdabot> Monad m => m Expr
13:33:44 <Cale> do { v <- x ; <stmts> } = x >>= (\v -> do { <stmts> })
13:33:52 <EvanR> :t pure x
13:33:54 <lambdabot> Applicative f => f Expr
13:34:10 <Cale> do { x ; <stmts> } = x >> do { <stmts> } -- where x >> y = x >>= (\k -> y) is defined in the Prelude
13:34:32 <Cale> do { let { <decls> } ; <stmts> } = let { <decls> } in do { <stmts> }
13:34:34 <merijn> @undo do { x <- foo; y <- bar; z <- baz; return (x, y, z) }
13:34:34 <lambdabot> foo >>= \ x -> bar >>= \ y -> baz >>= \ z -> return (x, y, z)
13:34:36 <josephle> sinelaw: HoTT has the mindblowing idea that sets are all types T where if x,y : T and i,j: x == y, then i == j
13:35:23 <Cale> sebastiankg: So, once we translate away the do-notation, we see that x, y, and z are in scope because they're the variables bound by the lambdas
13:35:29 <michi7x7> sebastiankg: see that return :: a -> (e -> a) ... so it discards e (it just "returns" a)...
13:35:37 <Cale> @undo do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)
13:35:38 <lambdabot> id >>= \ x -> reverse >>= \ y -> map toUpper >>= \ z -> return (x, y, z)
13:35:48 <sebastiankg> so each subsequent statement is wrapped in the anonymous functions from all the previous lines, which have as arguments everything that was on the left of (<-)
13:35:49 <josephle> sinelaw: sorry for the infodump, but hopefully that gives you some insight into your question
13:35:51 <crobbins> wow, didn't know about undo
13:35:52 <sebastiankg> right?
13:36:00 <nh2> joe9: most of my code is practical, not so much abstract things like dealing with types like Cont. https://github.com/nh2 if you're interested anyway
13:36:01 <merijn> sebastiankg: Yes
13:36:02 <Cale> yes
13:36:03 <AleksejsHome> Hi, if I compile with -dynamic flag and get an error like "perhaps you haven't installed the dyn libraries for ...", what should I do?
13:36:14 <sebastiankg> okay, that makes a ton of sense
13:36:42 <joe9> nh2, thanks.
13:36:54 <Cale> AleksejsHome: First, have a good cry. Then start reinstalling cabal packages with --enable-shared
13:36:55 <sebastiankg> thanks so much guys, I'm going to have to go off to a class, but you are awesome. Thanks Cale especially!
13:37:14 <Cale> sebastiankg: I didn't really get to the whole point of the abstraction yet
13:37:21 <merijn> sebastiankg: Before do-notation you'd manually line wrap the lambda's like so: http://lpaste.net/113774
13:37:24 <Cale> but when you get back, ping me and I'll let you in on that :)
13:37:27 <ReinH> sebastiankg: A nice reference for this and other "desugarings" in Haskell: http://www.haskellforall.com/2014/10/how-to-desugar-haskell-code.html
13:37:38 <sebastiankg> okay awesome, thanks Cale!
13:38:07 <merijn> sebastiankg: I usually recommend avoiding do notation for this reason, it causes people to think it's "magic", rather than some pretty trivial syntactic sugar for stuff you can write in normal pure haskell
13:38:24 <merijn> sebastiankg: (well, avoid do notation for beginners, once you get it, it's much nicer to use :))
13:38:55 <benzrf> @karma+ merijn
13:38:55 <lambdabot> merijn's karma raised to 31.
13:38:58 <sebastiankg> makes sense! Okay, talk to you all later
13:39:02 <benzrf> for correctly paranethaseizing your smiley
13:39:28 <EvanR> do notation could be its own primitive, if it wasnt for the fact that its called "do" notation
13:39:54 <EvanR> i dont see me doing anything except for maybe IO, Writer, State
13:40:05 <nh2> joe9: the approach that usually helps me when dealing with control flow things like this is: (a) Work from the outside: What do I have to construct? Like you did correctly, seeing that for constructing a `Cont r b` you have to write the outer structure `Cont (\b2r -> ...)`.
13:40:10 <nh2> joe9: (b) Keep in mind what things can do for you, or what they force you to do. E.g. that using `cf` forces you to write something of shape `runCont cf (\a2b -> ...)` which will give you a new value `a2b` with which you can work.
13:40:24 <merijn> EvanR: It can be nice for Maybe and list and transformer stacks
13:40:39 <EvanR> i use it, but it doesnt make a lot of sense to be labeled "do"
13:40:40 <AleksejsHome> Cale: thanks! And if I break everything while doing so, should I wipe ~/.ghc ?
13:41:13 <EvanR> the notation itself makes a lot of sense in its own right, to me
13:41:28 <ReinH> EvanR: can you think of a better name?
13:41:36 <EvanR> no
13:41:39 <ReinH> Me neither.
13:41:50 <ReinH> return is a poor name too
13:41:55 <EvanR> return = pure
13:42:01 <ReinH> That is true.
13:42:03 <dmj`> any http-streams users here?
13:42:06 <joe9> nh2, I still do not understand "If you run `runCont cf`, you have to give it a function that takes an \(a2b :: (a->b)), so you have something that can turn `a`s to `b`s (let's keep calling it a2b)". From what I understand, 'runCont cf' takes a function of a -> b -> r and not a -> b.
13:42:16 <ReinH> Or at least it's morally true. It will be actually true in 7.10.
13:42:33 <EvanR> propositional equality, moral equality
13:44:03 <joe9> nh2, runCont cf takes a function of f : a -> b -> r and then returns r. to make it a -> b -> b seems easier?
13:44:33 <joe9> nh2, runCont cf (\f a b -> b)?
13:44:34 <nh2> joe9: you're missing a bracket: `runCont cf` takes a function of (a -> b) -> r. That means you have to give it that function (a -> b) -> r as a parameter. What must such a parameter look like? (\(a2b :: a->b) -> ... :: r)
13:45:09 <Cale> AleksejsHome: Well, that's a last resort way to go about it, but it should work :)
13:45:58 <__monty__> Does '>>' have a name? Like '>>=' is called bind.
13:46:03 <benzrf> __monty__: then
13:47:49 <__monty__> benzrf: Thank you. Is there a way to find out such things without having to ask people who already know? I can't seem to find the "names" of most operators.
13:48:02 <benzrf> __monty__: a lot of them dont really have names
13:48:06 <benzrf> and idk :|
13:48:32 <hugldubl> can i import a function using another name?
13:48:48 <simpson> __monty__: The name I've heard most often for (>>) is "then", but it's not supported by the literature.
13:48:50 <nh2> hugldubl: no
13:49:04 <hugldubl> well, how to handle conflicts?
13:49:07 <nh2> hugldubl: but qualified
13:49:11 <simpson> hugldubl: Qualify the name.
13:49:24 <augur> is there no renaming?
13:49:24 <__monty__> benzrf, simpson: Ok, thank you.
13:49:29 <nh2> hugldubl: search for "import qualified"
13:49:31 <nh2> augur: no
13:49:39 <augur> import Control.Monad renaming ((>>) to then)
13:49:50 <merijn> augur: Nope
13:49:54 <augur> shame
13:49:58 <augur> i guess agda has spoiled me
13:50:14 <michi7x7> augur: then = (>>) ?
13:50:28 <__monty__> agda ftw
13:50:30 <augur> michi7x7: yeah you can do that
13:50:39 <augur> qualified import + local definitions
13:50:42 <michi7x7> doesn't cover infixr though
13:51:22 <Fuuzetsu> michi7x7: you can define fixity for ‘then’ if you want to
13:51:29 <Fuuzetsu> just like you can define it for `then` in Haskell
13:51:36 <Fuuzetsu> mixfix ftw
13:52:13 <michi7x7> Fuuzetsu: yeah, but manually
13:52:14 <Fuuzetsu> augur: don't forget opening modules wherever, including inside records and ‘where’; and parametrisation…
13:52:25 <Fuuzetsu> wish we had Agda modules
13:53:36 <__monty__> Is haskell the dependently typed programmers language for 'real' code?
13:53:55 <silver> maybe with extensions
13:53:59 <simpson> Haskell is generally viewed as not dependently-typed.
13:54:05 <silver> yep
13:54:19 <nh2> __monty__: no, it's their scripting language
13:55:02 <__monty__> simpson: I know, just surprised by the amount of people who know about dependent types.
13:55:33 <nh2> people in #haskell tend to be well versed in the things that'll become cool in 20 years!
13:56:02 <ReinH> And lots of things that won't ;)
13:56:07 <joe9> nh2: I am thinking that there must be a program that can build this body using this type definition. Atleast in this particular case.
13:56:45 <joe9> In 20 years, we will probably just writing proofs.
13:56:53 <Evilsparza> hey guys, where would I have to look if I wanted to change the order of a function that is a->b->c->d->e to a->b->d->c->e ? without defining a function that is called with parameters in this order and then just forwards them
13:57:09 <nh2> joe9: that's right. The Agda that people around here are talking about can auto-fill such things, as can the similar language Idris. There's even a Haskell program to do it for some functions
13:57:12 <Evilsparza> with order of the function I actually mean order of the parameters of the function, sorry
13:57:13 <joe9> Evilsparza: check out flip.
13:57:40 <joe9> nh2: what is that haskell program?
13:57:41 <ReinH> Evilsparza: you can't do that trivially with flip
13:58:16 <nh2> joe9: Djinn: http://lambda-the-ultimate.org/node/1178
13:58:27 <Fuuzetsu> djinn is rather limited
13:58:40 <nh2> Fuuzetsu: is there a newer thing that can do it?
13:58:45 <nh2> oh also apparently: "Don Stewart wrote a lambdabot plugin for Djinn a few hours later."
13:58:48 <Fuuzetsu> not that I know of
13:58:57 <Fuuzetsu> nh2: @djin
13:58:57 <nh2> @djinn a -> b -> a
13:58:58 <lambdabot> f a _ = a
13:59:02 <Fuuzetsu> n
13:59:09 <ReinH> :t  ((flip .) .)
13:59:10 <lambdabot> (a -> a1 -> a2 -> b -> c) -> a -> a1 -> b -> a2 -> c
13:59:45 <nh2> joe9: one moment let me inline Cont into your type definitino
13:59:49 <ReinH> @unpl ((flip .) .)
13:59:50 <lambdabot> (\ e h k b c -> e h k c b)
13:59:59 <ReinH> oh that's not quite right even
14:00:03 <ReinH> oh, yes it is
14:00:05 <ReinH> partial application
14:00:53 <nh2> @djinn: (((a -> b) -> r) -> r) -> ((a -> r) -> r) -> ((b -> r) -> r)
14:00:53 <lambdabot> f a b c = b (\ d -> a (\ e -> c (e d)))
14:01:13 <nh2> joe9: now there you go!
14:01:16 <joe9> nh2, that is cool. Thanks.
14:02:31 <ReinH> From the "Why Not?" department:
14:02:32 <ReinH> @. pl djinn (((a -> b) -> r) -> r) -> ((a -> r) -> r) -> ((b -> r) -> r)
14:02:33 <lambdabot> f = flip (.) . (. ((. flip id) . (.))) . (.)
14:02:36 <ReinH> easy
14:03:46 <nh2> what obscenity
14:04:03 <oleo> lol
14:05:25 <jfischoff> ha
14:06:53 * SwashBuckla barfs
14:06:55 <phaazon> ahah
14:07:07 <phaazon> I’m using three types in a module
14:07:12 <phaazon> ar, some kind of arrow
14:07:14 <phaazon> a
14:07:15 <phaazon> and b
14:07:20 <phaazon> that ends up with ar a b
14:07:22 <phaazon> :––––’)
14:07:31 <phaazon> I feel terrible about that
14:07:40 <ReinH> Sometimes it's a bit nicer:
14:07:42 <ReinH> @. pl djinn (a -> b -> c) -> (a -> b) -> (a -> c)
14:07:42 <lambdabot> f = ap
14:08:02 <phaazon> ahah
14:08:04 <ReinH> Djinn can give (<*> )for Reader :)
14:08:33 <SwashBuckla> ReinH: are you composing pl and djinn there?
14:08:37 <ReinH> yes
14:08:41 <SwashBuckla> nice
14:14:08 <hugldubl> What does infixr 5 mean? http://hackage.haskell.org/package/text-1.2.0.0/docs/Data-Text-Lazy.html#v:pack at cons
14:14:19 <EvanR> TVars are so awesome, i want them to be the default in everything
14:15:46 <merijn> hugldubl: Associativity
14:15:56 <merijn> hugldubl: It means it's right associative with precedence 5
14:16:04 <merijn> hugldubl: 0 being lowest and 9 being highest
14:16:19 <hugldubl> Ok thank you
14:16:49 <etandel> infix/r/5: infix -> an infix operator; r-> right associative (theres also infixl); 5 -> precedence 5
14:17:05 <benzrf> what's plain infix
14:17:07 <benzrf> with no l or or
14:17:07 <benzrf> r
14:17:13 <hexagoxel> hugldubl: you can see associativity for other operators by using :i in ghci: `:i ($)`
14:17:15 <joe9> @djinn ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
14:17:15 <lambdabot> f a b c = a (\ d -> b d c)
14:17:51 <etandel> benzrf: i've never seen it
14:17:54 <hugldubl> I was just confused because I never saw such a note before
14:18:31 <hexagoxel> hugldubl: yeah, the documentation started including them just recently i think
14:20:27 <hugldubl> hexagoxel: I'm rather new to Haskell. Maybe they are there for years, maybe they got added recently. Doesn't matter ;)
14:20:38 <ReinH> Ugh, I am not very happy with cabal right now.
14:21:11 * hackagebot pugixml 0.1.0 - pugixml binding.  http://hackage.haskell.org/package/pugixml-0.1.0 (HirotomoMoriwaki)
14:21:50 <SwashBuckla> ReinH: cabal install happy :P
14:21:55 <SwashBuckla> (sorry)
14:21:59 <ReinH> happy is already installed :p
14:22:37 <EvanR> infix notation is awesome
14:22:43 <EvanR> you dont know what you got till its gone
14:22:49 <EvanR> (using clojure)
14:23:00 <etandel> lisp
14:23:07 <etandel> lisps gonna lisp
14:25:04 <Denommus> EvanR: having an exposed AST, on the other hand, is something that I miss on Lisp
14:25:06 <hugldubl> Any smart ideas to get a Text to [Word8]? text looks like this "0,0,0,0,0,0,0,3,0,0,0,0,1,1,1,0,0,0,0,0,0,0,6,0,64,229,156,48,18,0,0,0,0,3"
14:25:33 <EvanR> im not smart enough to be rearranging my AST
14:25:41 <Fuuzetsu> neither are Lisp users
14:26:16 <Denommus> paredit makes that easy :P
14:26:26 <EvanR> hugldubl: you must encode your Text as a bytestring somehow first, how you do that is up to you
14:26:39 <Denommus> there's even an equivalent mode for Haskell, but it's still very experimental
14:26:51 <EvanR> Denommus: its definitely easier than not having paredit, but i wouldnt say its easy
14:26:54 <Denommus> structured-haskell-mode
14:26:56 <hugldubl> Well, the plan was to get a bytestring out of that [Word8]^^
14:27:13 <Denommus> EvanR: well, I personally think it is
14:27:24 <EvanR> hugldubl: well you can consider text an abstract type, its not 1 to 1 with a string of bytes
14:27:38 <Fuuzetsu> hugldubl: split on , and read :: String -> Word8 what's left?
14:27:59 <EvanR> Denommus: par edit itself is still useful in haskell even if its not haskell aware, because personally i use parentheses in haskell
14:28:01 <Fuuzetsu> :t map (read :: String -> Word8) . splitOn ","
14:28:01 <hugldubl> no splitOn
14:28:02 <lambdabot> [Char] -> [Word8]
14:28:30 <hugldubl> I'm not allowed to use splitOn Fuuzetsu
14:28:35 <Fuuzetsu> you didn't say that
14:28:38 <EvanR> hugldubl: if you want a bytestring from text, then you dont need to go through word8, you just use an encoder like utf8 encode
14:29:04 <Fuuzetsu> hugldubl: just implement your own splitOn although seems silly to me
14:29:06 <EvanR> in fact going through word8 is just wrong
14:29:22 <Johannes13> I want to play arround with Text.ParserCombinators.Parsec and Control.Applicaticve in GHCi (mostly :t), but one expression I want to write uses many
14:29:34 <Fuuzetsu> EvanR: pretty sure he wants to parse out the data rather than just encode that string to ByteString
14:29:39 <EvanR> oh
14:29:41 <Johannes13> how can I hide imports with ghci?
14:29:47 <EvanR> splitOn
14:29:57 <Fuuzetsu> Johannes13: import Foo.Bar hiding (functionIdontwant)
14:30:08 <hugldubl> ah, nice. At the end, I'm planning to end up with a list of integers. the stuff inside the text is something that fell out of ByteString.Lazy.unpack
14:30:27 <Fuuzetsu> hugldubl: it'd be better if you told us the actual problem
14:30:52 <EvanR> hugldubl: then it sounds like you want to go through from bytestring instead
14:30:59 <EvanR> straight from bytestring
14:31:41 <Johannes13> Fuuzetsu, thanks. I always used :m +Text.ParserCombinators.Parsec
14:31:59 <hugldubl> Fuuzetsu: It's a competition task. I want to get the solution mostly on my own, but I'm really new to haskell and need help sometimes. The task is to write a function that encodes a list of integers to one integer and the one integer back to a list of integers
14:33:08 <EvanR> bonus points if you can encode a countably infinite list of integers as one integer and back
14:33:32 <EvanR> oh no, you cant
14:33:55 <Fuuzetsu> are you just planning to encode each digit as Word8 in a section of your one int and then turn it to string, split on Word8-looking-sized-chunks and parse that?
14:34:22 <joe9> nh2 http://codepad.org/FFWnRHwy did this myself following your technique.
14:34:30 <joe9> feels good.
14:34:55 <hugldubl> i encode, intersperse with 256 and return that integer
14:35:19 <Johannes13> how can I remove the braces here: length <$> (char '"' *> many (noneOf "\"")) <* char '"')
14:35:42 <Johannes13> ehh, 1 brace too much, please ignore that.
14:35:47 <Fuuzetsu> probably easier to pad to 3 places with leading 0s because you can split every 3
14:36:07 <Johannes13> @pl length <$> (char '"' *> many (noneOf "\"") <* char '"')
14:36:08 <lambdabot> length <$> (char '"' *> many (noneOf "\"") <* char '"')
14:36:30 <hugldubl> Fuuzetsu: I don't understand?
14:36:31 <Fuuzetsu> fmap length $ …
14:36:37 <Johannes13> fmap length $ char '"' *> many (noneOf "\"") <* char '"'
14:36:45 <Johannes13> yeah
14:36:48 <Fuuzetsu> hugldubl: doesn't matter, just alternative way to encode
14:37:26 <hugldubl> I have to deal with negative numbers, too. This is why I did not want to think of my "own" encoding and use the stuff that's in Haskell
14:38:11 <EvanR> representing lists of numbers this way reminds me of non-haskell type systems ;)
14:38:36 <Fuuzetsu> I hear PHP has bigints but no type to expose them so it uses strings…
14:38:50 <Johannes13> haha, yeah
14:38:56 <EvanR> o_O
14:39:00 <Fuuzetsu> well, ``type''
14:39:15 <EvanR> class
14:39:23 <Johannes13> but PHP is great software. It's very consistent /sarcasm
14:39:35 <Fuuzetsu> it's consistent in how broken it is throughout
14:39:41 <EvanR> in 5.3 you can put annotations on your arguments
14:39:49 <EvanR> im not sure if they do anything
14:40:15 <hugldubl> So, Text -> ByteString. Can I use anything from http://hackage.haskell.org/package/text-0.11.0.7/docs/Data-Text-Lazy-Encoding.html without messing everything up? The encoder used Word8
14:40:30 <Johannes13> probably not. Annotations have mostly only 2 uses: Compile time (if you do meta programming), or Reflection
14:40:39 <EvanR> hugldubl: it doesnt sound like you should be using Text at all here
14:40:39 <Fuuzetsu> hugldubl: the functions to what you want don't exist
14:40:50 * Fuuzetsu afk
14:41:14 <hugldubl> text is the only thing I am allowed to use having replace
14:41:19 <EvanR> Johannes13: these are for the purpose of stopping people from using arguments of the wrong type
14:41:27 <EvanR> hugldubl: wtf?
14:41:40 <EvanR> annoying
14:42:06 <hugldubl> It seems I have to get dirty to learn something
14:42:19 <EvanR> you can easily write a character replace function on String if you need one
14:42:30 <hugldubl> i need a string replace function
14:42:43 <EvanR> why?
14:42:55 <hugldubl> because i want to replace strings?
14:42:58 <EvanR> ok
14:43:03 <EvanR> didnt think of that
14:43:10 <hugldubl> no problem
14:43:16 <johnw> lol
14:43:28 <johnw> I think it's called "replace" even
14:43:29 <johnw> :t replace
14:43:30 <lambdabot>     Not in scope: ‘replace’
14:43:31 <lambdabot>     Perhaps you meant ‘replay’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
14:43:48 <hugldubl> johnw: Yes
14:46:15 <AleksejsHome> hugldubl: do you need to replace substring with other in a string?
14:48:19 <hugldubl> AleksejsHome: Substring with character
14:49:07 <Axman6> :t replay
14:49:08 <lambdabot> Args -> Maybe (Test.QuickCheck.Random.QCGen, Int)
14:49:18 <EvanR> a rule that says you cant use String replace but you can use Text replace is just stupid
14:50:18 <EvanR> sounds like a hoop jumping contest
14:52:12 <pharpend> It occur to me that like half the people you talk to in this channel are bigshots in the community
14:55:08 <hugldubl> String replace?
14:55:13 <AleksejsHome> hugldubl: when I needed that kind of function I couldn't find one so I wrote it myself http://vpaste.net/MWlc5
14:55:38 <Axman6> pharpend: read that as 'biggots', was confused and angered :P
14:55:48 <pharpend> hvr, bos, edwardk, ReinH, chrisdone, byorgey, bitemyapp
14:56:00 <pharpend> I'm sure I'm missing some people
14:56:33 <ReinH> I don't know why I'm in that list...
14:56:51 <hugldubl> EvanR: AFAIK is the only string replace in MissingH - I'm not allowed to use MissingH
14:56:53 <edwardk> ReinH: haskellcast ;)
14:56:54 <pharpend> ReinH: you're the Haskell cast guy, right?
14:56:56 <ReinH> Cale should be on the list well before me
14:57:05 <ReinH> Ah. So it isn't merit based. God it.
14:57:07 <ReinH> *Got it.
14:57:09 <ReinH> ;)
14:57:34 <johnw> ReinH: you're famous!
14:57:39 <ReinH> I suppose...
14:57:46 <Axman6> A freudian slip is when you say one thing but mean your mother; that seemed quite freudian to me :P
14:57:57 <pharpend> johnw: you're someone important at FP Complete, aren't you?
14:58:17 <pharpend> Also apparently a very active haskeller
14:58:32 <johnw> I was at FP Complete, I helped create their IDE
14:58:53 <johnw> now they aren't really working on the IDE much, so I am elsewhere, doing language research
14:59:04 <pharpend> I wish snoyberg would hang out in irc. He's very helpful elsewhere on the internet
14:59:17 <pharpend> (On GitHub, namely)
14:59:23 <ReinH> johnw is very important :)
14:59:35 <ReinH> pharpend: He's in #yesod but not super active
14:59:36 <ReinH> iirc
14:59:48 <jfischoff> pharpend: all haskellers are important!
14:59:52 <pharpend> jfischoff: true
14:59:58 <ReinH> jfischoff: ... but some are more important than others! ;)
15:00:09 <pharpend> jfischoff: we just have to remember that we are intrinsically better than the Ruby people
15:00:16 <ReinH> doesn't work quite as well as the Animal Farm version
15:00:26 <ReinH> pharpend: I don't like that attitude at all, actually.
15:00:27 <jfischoff> I liked it
15:00:27 <wswiss> @pl \mf mx -> mf >>= \f -> mx >>= \x -> return (f x)
15:00:28 <lambdabot> (. ((. (return .)) . (>>=))) . (>>=)
15:00:47 <pharpend> ReinH: weechat tab-complete says you are wrong about snoyberg, unless his nick isn't snoyberg
15:00:47 <ReinH> I realize it was probably meant as a joke.
15:00:51 <sbrg> Axman6: ha! I had to read that twice
15:01:12 <ReinH> But I don't think it's a healthy way to treat people who use other languages.
15:01:24 <ReinH> I know some very smart Rubyists.
15:01:30 <Denommus> I still don't understand how Shakespeare directs a route to the correspondent template
15:01:41 <pharpend> ReinH: Oh, I think a little playful inter-language jabbing can't hurt.
15:01:51 <ReinH> I think it *can* hurt, which is why I don't like it.
15:01:52 <pharpend> Denommus: template haskell, nobody understands it
15:02:31 <pharpend> anyway, it looks like Denommus has an actual question, so let's stop talking about offtopic stuf
15:02:37 <mbuffett1> Hey guys, how would I output colored text in a terminal? I know there are ANSI escape codes, and I tried putStrLn "\x1b[32m Text", which should color "Text" and everything after it, but it doesn't work, any ideas?
15:03:00 <Denommus> pharpend: I don't need to understand how it's implemented
15:03:03 <joelteon> mbuffett1: you should use the ansi-terminal packge
15:03:06 <joelteon> or whatever it's called
15:03:08 <pharpend> mbuffett1: https://hackage.haskell.org/package/rainbow-0.14.0.0/docs/System-Console-Rainbow.html
15:03:08 <joelteon> hang on a second
15:03:10 <mbuffett1> I've tried the System.Console.Ansi module, but I can only get it to work for printing text colored, not getting a string and then using it later (which is what I'm trying to do)
15:03:19 <Denommus> pharpend: I'm just going through the guide, and I don't see how routes are related to templates at all
15:03:23 <pharpend> mbuffett1: there are two packages, rainbow and ansi-terminal
15:03:31 <joelteon> mbuffett1: so you want to have a string that has color attached to it?
15:03:37 <joelteon> mbuffett1: why not create a new datatype?
15:03:40 <pharpend> joelteon: you are also important, right?
15:03:42 <Denommus> pharpend: what if my Home route is associated with a template, and my Dashboard route is associated with a different one?
15:03:55 <joelteon> pharpend: not to the Haskell community in general, no
15:03:57 <joelteon> my mother likes me, though
15:04:00 <joelteon> why?
15:04:05 <pharpend> i recognize your nick
15:04:12 <pharpend> we might have commented on the same issue on github or something
15:04:17 <joelteon> that's possible
15:04:27 <ReinH> mbuffett1: where did you try that putStrLn?
15:04:32 <Denommus> maybe I should try to use Yesod itself before trying to venture into GHCJS
15:04:32 <ReinH> A terminal? ghci?
15:04:32 <joelteon> i'd go looking but I'm on starbucks wifi
15:04:40 <pharpend> oh you do the printf library
15:04:43 <mbuffett1> I'll look into the rainbow thing, thanks!
15:05:20 <joelteon> I did *a* printf library
15:05:23 <ReinH> mbuffett1: if you just `echo' it instead (in your shell), is it colored?
15:06:06 <pharpend> Denommus: can you maybe restate your question?
15:06:14 <pharpend> mbuffett1: try ReinH's suggestion
15:06:45 <Denommus> pharpend: I'm going through this guide: http://www.yesodweb.com/book/shakespearean-templates
15:06:55 <Denommus> pharpend: and the author defines some routes, and a single template
15:07:13 <ReinH> Denommus: Have you asked in #yesod as well?
15:07:21 <pharpend> ReinH: there's never anyone there
15:07:24 <ReinH> :/
15:07:49 <Denommus> pharpend: I have no idea how routes are associated with templates. For instance, Stylesheet doesn't seem associated with anything in the Quasiquoter example, and yet it's being used
15:07:54 <joelteon> oh, I probably saw you in #yesod, pharpend
15:08:01 <joe9> johnw: What is the MonadCont class?
15:08:05 <Denommus> ReinH: I'm not actually using yesod, in fact
15:08:13 <pharpend> joelteon: maybe
15:08:20 <ReinH> Denommus: you're just using yesod routes and yesod templating? ;)
15:08:34 <joelteon> yesod does have excellent routes and templating
15:08:39 <Denommus> ReinH: shakespeare is used by yesod, but it's independent from it, isn't it?
15:08:48 <Denommus> I'm using it in GHCJS
15:08:50 <joelteon> yes
15:08:51 <pharpend> Denommus: technically, but for all intents and purposes, no
15:08:55 <ReinH> Yes, but #yesod folks are probably more familiar with it than your random #haskeller :)
15:09:05 <pharpend> all 5 #yesod folks
15:09:11 <ReinH> Yeah, well, that's another issue ;)
15:09:19 <Denommus> pharpend: so... I shouldn't use yesod with webkitgtk + GHCJS?
15:09:35 <pharpend> Denommus: well, really depends on what you are trying to do
15:09:38 <Denommus> I mean, not yesod. Shakespeare. Damn
15:09:45 <pharpend> one sec
15:09:45 <lifter> Anyone know if it's faster to cons some Chars onto the head of a String, then pack the whole String into Text, or to pack each Char, and "<>" it onto a Text?
15:10:02 <ReinH> lifter: criterion is your friend
15:10:02 <Denommus> pharpend: I just want to make a desktop application on top of HTML (because using Gtk2Hs sucks balls)
15:10:40 <lifter> ReinH: Ok, thanks. Hey when is the next episode of HC coming out?? :)
15:10:54 <joe9> runCont is useless, Is it? callCC definition seems to be only for runContT.
15:11:14 <luite> Denommus: routes are a somewhat yesod-specific thing. you could also use a single 'web service' route with an RPC ADT on top, like snoyberg showed in a recent talk
15:11:21 <ReinH> lifter: Not sure yet, we need to schedule it with Conal. Chris and I have been taking some time off for real life stuff but hopefully we'll be ready to start up again soon.
15:11:23 <Axman6> Cont is just ContT Identity
15:11:39 <Axman6> so runCont is runIdentity . runContT
15:11:39 <lifter> ReinH: cool, looking forward to it
15:11:40 <johnw> joe9: runCont should = runIdentity . runContT or something like it
15:12:39 <Denommus> luite: ah
15:12:48 <pharpend> ReinH: who's it with?
15:13:15 <Denommus> luite: so, for my actual desktop interface, I should just use a single HTML, and transform it in my event loop?
15:13:36 <ReinH> pharpend: My cohost is Chris Forno.
15:13:51 <pharpend> ReinH: no no, who will you interview next?
15:13:59 <folsen> anyone know how to make an executable using optparse-applicative accept input from a unix pipe? (cat txt | myapp)
15:14:03 <luite> Denommus: I'd probably just use requests to retrieve new data from the server, no html, in this kind of app
15:14:30 <Denommus> luite: all the HTML will do is the UI
15:14:37 <pharpend> ReinH: this guy? http://conal.net/blog/
15:14:39 <jfischoff> folsen: well you can run the parser on any string
15:14:42 <Denommus> luite: I'm worried about UI transition, though
15:14:46 <ReinH> Oh. The guest. Yes, that guy.
15:14:54 <ReinH> He's our next guest.
15:15:01 <Denommus> luite: but I guess I can work with multiple hamlet files, yes
15:15:08 <joe9> johnw, thanks.
15:15:41 <folsen> jfischoff: right, but while still maintaining being able to parse flags and such.. could you do like a catch-all unnamed last argument?
15:15:41 <luite> Denommus: you can use any method you want. even calling out to JS and replacing a window.document node directly is possible
15:16:14 <jfischoff> folsen: actually I think I am confused :(
15:16:22 <Axman6> folsen: would myapp `cat txt` work?
15:16:38 <Denommus> well, thanks for the help, I know the direction I'm going now
15:16:46 <folsen> Axman6: no it’s a specific requirement to be piped
15:16:47 <Axman6> ot myapp $(cat txt)
15:16:55 <Axman6> fair enough
15:16:59 <ReinH> folsen: you can just from the stdin handle
15:17:00 <hugldubl> can i transform a bytestring into a lazy bytestring?
15:17:02 <Axman6> use Xargs!
15:17:12 <Axman6> hugldubl: see fromChunks
15:17:12 <ReinH> folsen: this is independent of options parsing
15:17:18 <Axman6> @hoolge fromChunks
15:17:21 <lambdabot> Data.ByteString.Lazy fromChunks :: [ByteString] -> ByteString
15:17:21 <hugldubl> Axman6 thank you
15:17:21 <lambdabot> Data.ByteString.Lazy.Char8 fromChunks :: [ByteString] -> ByteString
15:17:21 <lambdabot> Data.Text.Lazy fromChunks :: [Text] -> Text
15:17:27 <ReinH> hGetContents stdin or some other means, like Conduit, etc
15:17:31 <Axman6> fromChunks [bs]
15:17:32 <ReinH> folsen: ^
15:17:54 <ReinH> Er...
15:17:55 <Fuuzetsu> hugldubl: fromStrict
15:18:10 <ReinH> hugldubl: you want http://hackage.haskell.org/package/bytestring-0.10.4.0/docs/Data-ByteString-Lazy.html#v:fromStrict
15:18:22 <Axman6> @hoogle fromStrict
15:18:23 <lambdabot> Data.ByteString.Lazy fromStrict :: ByteString -> ByteString
15:18:23 <lambdabot> Data.ByteString.Lazy.Char8 fromStrict :: ByteString -> ByteString
15:18:23 <lambdabot> Data.Text.Lazy fromStrict :: Text -> Text
15:18:25 <folsen> ReinH: yeah.. i think I may have to go down that route somehow, the app needs to be able to be used piped _or_ by accepting a filename, so i need to try to do some sort of detection of which it’s trying to do
15:18:44 <Axman6> huh, that's new. been a while since I've needed to do that I guess
15:18:58 <ReinH> folsen: abstract over a handle and then choose the handle based on the options
15:19:13 <folsen> ReinH: yeah, sounds like a good plan!
15:21:19 <ReinH> folsen: Could be as simple as: case (_filename opts) of { Just fn -> withFile fn ReadOnly go; Nothing -> go stdin }
15:21:45 <ReinH> also those parens are unnecessary... force of habit
15:21:51 <folsen> hehe
15:22:11 <Fuuzetsu> where did you develop such a terrible habit
15:22:16 <ReinH> I don't even know.
15:22:27 <Fuuzetsu> have you been using those bad languages again?
15:22:36 <ReinH> hahaha
15:22:47 <ReinH> Actually not as much now that I do haskell at work
15:22:54 <ReinH> Although I have been writing some bash...
15:23:05 <Fuuzetsu> probably want more parens for bash
15:23:11 <Fuuzetsu> ((((amisafeyet))))
15:23:11 <y> probably too much lisp
15:23:28 <ReinH> Fuuzetsu: I am writing a Scheme...
15:23:39 <ReinH> er y
15:23:55 <y> oh well, the same family :P
15:24:21 * Fuuzetsu doesn't remember being in y's family
15:24:24 <AleksejsHome> I have 2 versions of mtl installed, how to remove one?
15:24:31 <ReinH> I'm writing an R5RS interpreter because the Write Yourself a Scheme tutorial is extremely out of date.
15:24:44 <ReinH> And because I wanted to learn how to use trifecta and bound
15:24:58 <ReinH> In other news, trifecta is awesome.
15:25:00 <y> Fuuzetsu: we're haskellers! that counts... doesn't it?
15:25:30 <joe9> Can I write something like this:  *Main> :t Cont (\a2r -> runCont (f undefined) a2r) , and ask ghci for the type definition of undefined?
15:25:45 <Fuuzetsu> y: sure, but there are levels of acquaintance. If all Haskellers are family then what are those of them that also send me patches?
15:26:09 <Axman6> you can probably use type holes joe9
15:26:13 * hackagebot Extra 1.46.2 - A grab bag of modules.  http://hackage.haskell.org/package/Extra-1.46.2 (DavidFox)
15:26:17 <Jazon> im a girl
15:26:20 <joe9> Axman6: thanks.
15:26:40 <Axman6> joe9: I think that's the right extension anyway
15:27:01 <johnw> joe9: if you are using GHC 7.8, just put '_' instead of undefined
15:27:07 <Axman6> you used to be able to use implicit parameters, but I thin that got removed
15:27:12 <johnw> and it will give you an error with the type, and a lot of contextual information
15:27:12 <Axman6> think*
15:27:13 <joe9> https://www.haskell.org/haskellwiki/GHC/Typed_holes Axman6, found this .
15:27:18 <joe9> Axman6: thanks.
15:27:22 <Fuuzetsu> you can enable implicit params
15:27:25 <Fuuzetsu> but holes are nicer
15:27:27 <joe9> johnw: thanks.
15:28:08 <joe9> johnw: Axman6, that is cool. very helpful when working with continuations.
15:29:02 <Fuuzetsu> I haven't used Cont even once yet
15:30:09 <Fuuzetsu> :t catch
15:30:11 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
15:30:32 <johnw> aka, IO a -> Cont (IO a) e  ;)
15:30:52 <Fuuzetsu> more importantly, I wonder if I can catch a GHC panic…
15:31:10 <Fuuzetsu> error rather
15:36:14 * hackagebot Extra 1.46.3 - A grab bag of modules.  http://hackage.haskell.org/package/Extra-1.46.3 (DavidFox)
15:37:45 <joelteon> oh good, we need more of those packages
15:38:49 <Fuuzetsu> joelteon: don't you want to pull in half of Hackage when you want to use one function?
15:39:04 <Fuuzetsu> although I guess lens already does that, hm
15:39:27 <joelteon> once backpack gets here lens will have like 2 dependencies
15:39:31 <edwardk> =P
15:39:46 <edwardk> joelteon: backpack does almost nothing to help lens in that regard
15:40:07 <EvanR> grab bag, backpack, supply depot
15:40:10 <joelteon> well, make a liar out of me then
15:40:22 <Hafydd> pylon
15:40:24 <dfeuer> Well, y'all know what *I* want to do about that dep problem, but nobody else seems too excited about that idea.
15:40:28 <kadoban> Anyone know what packages/modules are available for use on SPOJ (sphere online judge)? I'm not finding a list anywhere.
15:40:34 <EvanR> insufficient vespene gas
15:40:35 <dfeuer> edwardk, you think you can look over my Foldable Array code?
15:40:37 <edwardk> joelteon: will do
15:40:57 <joelteon> i like dfeuer's idea, whatever it is
15:41:02 <indiagreen> kadoban: I think they only provide what's bundled with GHC
15:41:15 <kadoban> indiagreen: Oh really? Oh noes :-/
15:41:17 <indiagreen> so, look at GHC docs
15:41:30 <dfeuer> Joel = יואל‎
15:41:40 <joelteon> exactly
15:41:42 <kadoban> indiagreen: Probably like "haskell platform" then I guess?
15:41:46 <indiagreen> no, GHC
15:41:50 <kadoban> hmm
15:41:52 <indiagreen> pro tip: you can use ReadP instead of Parsec, it saved me a couple of times
15:42:21 <indiagreen> well, not on SPOJ, not many parsing-relevant tasks there
15:42:26 <indiagreen> but on other contests, yeah
15:42:40 <joelteon> spodge!
15:42:51 <kadoban> Oh yeah? Cool. Yeah, actually parsing is what I'm doing now...except it's not very hard so I suppose I could do it manually.
15:43:12 <edwardk> we have 3 different Read-style parsers in GHC: ReadP, ReadS, and ReadPrec. None of them seems to offer an out of the box way to run the stupid thing without going through Read.
15:43:49 <edwardk> dfeuer: i can, not at the moment
15:43:55 <dfeuer> OK.
15:44:19 <dfeuer> Ha. I just misread "inactivity" as "injectivity".
15:44:33 <eitan_chatav> I wish there was a way to search for a type up to isomorphism on Hoogle. Is there?
15:45:26 <Fuuzetsu> http://lpaste.net/113780 can't I get this automatically nowadays? I think this has been written way before GeneralisedNewtypeDeriving
15:50:23 <edwardk> dcoutts: with the deprecation of versionTags and its ultimate removal in 7.12 how does one actually correctly construct a Version ?
15:50:37 <edwardk> dcoutts: CPP around the code?
15:50:47 <mbuffett1> Anybody know how to use the rainbow package? I can't seem to get it to give me a colored string
15:51:05 <benzrf> hey edwardk have you seen keybase
15:51:07 <benzrf> .io
15:51:19 <edwardk> i think i have an invite somewhere
15:52:01 <benzrf> yea ive basically been pestering the channel with offers to invite
15:52:13 * edwardk is good.
15:53:03 <dcoutts_> edwardk: Version { versionBranch = ... }  :-)
15:53:28 <edwardk> dcoutts_: : leaving undefineds dangerously around
15:53:37 * dcoutts_ is joking
15:53:45 <kadoban> benzrf: Can I get an invite?
15:53:56 <edwardk> dcoutts_: if we had an emptyVersion or something we could differentiate ;)
15:54:09 <edwardk> mostly just noticing its lack
15:54:15 <dcoutts_> aye
15:54:17 <edwardk> and that there wasn't a good story for construction without tags
15:54:19 <joelteon> benzrf: what does it do
15:54:22 <Gurkenglas> Is the hoogle database available for download? Maybe someone can set up a project on fpcomplete to expand its functionality by things like what eitan suggested.
15:54:27 <dcoutts_> edwardk: of course we only discover that now
15:54:44 <indiagreen> Gurkenglas: the hoogle database can be generated
15:54:48 <indiagreen> by the hoogle executable
15:54:50 <dcoutts_> Gurkenglas: hackage provides a complete hoogle index for everthing on hackage
15:55:00 <edwardk> dcoutts: decided i wanted to use Version to hold the version and shader langauge version stuff in the gl package, and consciously thought about what that meant just now
15:55:16 <edwardk> i'll patch around it when 7.12 comes due, but it was worth thinking about
15:55:19 <benzrf> kadoban: email?
15:55:30 <joelteon> benzrf: give me one
15:55:31 <kadoban> benzrf: joshua.simmons@emptypath.com
15:55:41 <EvanR> me too
15:55:49 <Fuuzetsu> I want to use ErrorT but don't want warnings for transformers 0.4.1.0 users, how do I proceed?
15:55:56 <dcoutts_> Gurkenglas: http://hackage.haskell.org/packages/hoogle.tar.gz
15:56:21 <Gurkenglas> yaythx
15:56:28 <dcoutts_> Gurkenglas: it's the file that the hoogle command line client gets already
15:56:42 <Gurkenglas> command line client?
15:56:45 <benzrf> joelteon: basically its supposed to be: 1. a directory of linked, signed, proofs-of-identity for several major websites (reddit, twitter, github, hn) and dns
15:56:53 <dcoutts_> Gurkenglas: the hoogle command line program
15:57:05 <benzrf> 2. a program or system for auto-verifying the proofs and working with the keys
15:57:13 <Gurkenglas> Didn't know there was one. Is its source available? (Is it in Haskell?)
15:57:22 <Fuuzetsu> yes yes
15:57:25 <dcoutts_> Gurkenglas: of course, it's on hackage
15:57:42 <benzrf> so ideally you can type like 'keybase encrypt reddit://benzrf -m "hi"' and it will look up on keybase.io if anybody has submitted a signed proof of being reddit user benzrf
15:57:52 <benzrf> then it will check the proof, then encrypt the message against the associated key
15:57:53 <dcoutts_> @hackage hoogle
15:57:54 <lambdabot> http://hackage.haskell.org/package/hoogle
15:57:58 <benzrf> joelteon, EvanR: emails?
15:57:59 <joelteon> oh ok
15:58:01 <joelteon> i'll take one of those
15:58:08 <Fuuzetsu> benzrf literally offtopic
15:58:11 <benzrf> Fuuzetsu: :)
15:58:20 <Fuuzetsu> what's more on topic is signing for Hackage; dcoutts_ how is that going?
15:58:32 <mbuffett1> So I tried this : print "\x1b[32m hey \x1b[0m" to print a colored string and it failed, then I tried : printf "\x1b[32m hey \x1b[0m" and it worked, why is that?
15:58:32 <EvanR> benzrf: when finally identity technology arrives that makes all this so easy... people might realize they were benefiting from how difficulty it was for secret service to pinpoint them ;)
15:58:34 <benzrf> crap, i thought this was #haskell-blah
15:58:37 <benzrf> sorry :{
15:58:39 <dcoutts_> Fuuzetsu: thoughtpolice and I are making progress
15:58:56 <Fuuzetsu> awesome, I look forward
15:59:14 <benzrf> tfw not getting paid for shilling
15:59:20 <Fuuzetsu> I also look forward to some resolution on that update-cabal-files-on-hackage discussion eventually ;;
16:00:48 <kadoban> benzrf: Thanks, got it
16:01:41 <benzrf> kadoban: np
16:02:11 <Axman6> anyone have any experience with postgresql-simple? Or know where where to go for some help? it doesn't seem to match what the docs say it should do
16:03:03 <AleksejsHome> I have a problem: Failed to install hslogger-1.2.4
16:04:08 <AleksejsHome> http://vpaste.net/K6jtE
16:05:37 <Fuuzetsu> edwardk: docs for transformers-compat are broken, the modules don't lead anywhere meaningful
16:06:24 <Axman6> lpsmith: Hey, are you about? I'm having some issues with postgresql-simple where it seems to not follow what the docs say. I
16:07:08 <Gurkenglas> Can you recommend a way to turn a code.haskell.org folder into a git repository?
16:07:24 <Gurkenglas> (Does this belong in #blah?)
16:07:53 <Axman6> lpsmith: I'm trying to add some columns to a table, abd I can't seem to get the column name nor the type to be spliced in without quotes, despite using both the Identifier wrapper and the EscapeIdentifier Action explicitly.
16:09:49 <goglosh> hey
16:10:19 <edwardk> Fuuzetsu: not a thing i can fix with hackage building its index the way it does
16:10:37 <goglosh> is there some kind of library that does interactive graphics like pygame or something?
16:10:41 <edwardk> Fuuzetsu: i'd rather have the package than not have it, and it isn't a fixable thing ;)
16:10:58 <Axman6> goglosh: Gloss might be a place to start, though IIRC it's 2D only
16:12:09 <goglosh> Axman6 I'll check it out, yeah, I don't really need 3D, at all
16:13:00 <AleksejsHome> could anyone tell me the reaon of this? http://vpaste.net/K6jtE
16:13:00 <merijn> edwardk: How is it not fixable? Couldn't you manually upload docs to overwrite the broken ones?
16:13:30 <merijn> AleksejsHome: You're accidentally mixing multiple versions of the time package
16:13:50 <edwardk> merijn: that doesn't change the top level index
16:14:02 <merijn> AleksejsHome: If you see package version numbers in module names like here, that's pretty much always what's wrong
16:14:02 <edwardk> merijn: the thing is if the version of transformers is new enough those modules do not exist
16:14:16 <merijn> edwardk: hmm
16:15:02 <AleksejsHome> merijn: I have Installed versions: 1.4.0.1, 1.5
16:15:06 <merijn> edwardk: oh, the problem is that hackage is building with new versions of transformers?
16:15:07 <danilo2> Hello! I've got a traversal-like question to you today! :D Lets assume we've got data A = A B C (where these datatypes are recursive and have many constructors). I want to traverse this datatype and apply appriopriate functions to appriopriate types (like fA :: A -> m A, going on: A <$> fB B <*> fC C). Is there any support for something like that in lenses?
16:15:11 <AleksejsHome> of time package
16:15:17 <danilo2> Additional - I would love to apply only these functions that I need - sometimes I will need to use fA and fB, sometimes only fC - othercase (if function is not provided) it should traverse further
16:15:18 <AleksejsHome> is there any way to remove one?
16:15:31 <merijn> AleksejsHome: "ghc-pkg unregister time-1.4.0.1"
16:16:27 <edwardk> its stuff like that why i view {-# OPTIONS_haddock hide #-} as an unusable feature
16:16:32 <vermeille> is there a way to make cabal update the dependencies list in a cabal file?
16:16:46 <edwardk> they use it on Data.ByteString.Internal for instance, but the result is just that the haddocks for the website have dead links
16:16:46 <edwardk> it looks unprofessional
16:16:50 <edwardk> so i just don't use it
16:17:06 <agibiansky> @pharpend: hey there
16:17:07 <lambdabot> Unknown command, try @list
16:17:13 <edwardk> here i kinda have no choice
16:17:33 <edwardk> merijn: yeah
16:17:41 <vermeille> cabal init does it the first time, but then?
16:18:28 <edwardk> merijn: 0.3.3.4 builds with transformers 0.4, 0.3.3.2 builds with transformers 0.2: http://hackage.haskell.org/package/transformers-compat-0.3.3.2/docs/Control-Applicative-Backwards.html
16:18:28 <edwardk> that link works
16:18:56 <node8js144> hi
16:18:57 <edwardk> the three version 0.3.3.2, 0.3.3.3 and 0.3.3.4 have to exist to convince the cabal backtracker to find the right version
16:19:02 <AleksejsHome> merijn: now I have only 1.5 version, and I'm getting the same error while trying to install missingh
16:19:11 <edwardk> otherwise it'll skip scenarios for users
16:23:45 <merijn> edwardk: Does setting a preferred version work for the hackage main page? Or does that break the backtracking?
16:25:42 <Johannes13> How can I write this: oneOf letter <*> many (letter <|> digit)
16:25:50 <Johannes13> ehh..
16:26:06 <Johannes13> letter <*> many (letter <|> digit)
16:26:26 <Johannes13> letter :: Parser Char, many :: Parser [Char]
16:26:40 <Axman6> you probably want something like (:) <$> letter <*> many (letter <|> digit)
16:26:52 <Axman6> that'll take the single letter and stick it on the front
16:26:56 <Johannes13> mhh, yeah-
16:27:00 <goglosh> damn I can't install the ncurses bindings
16:27:07 <goglosh> I just get FatalError 1
16:27:08 <Johannes13> I should probably go to bed..
16:27:12 <goglosh> no
16:27:14 <goglosh> ExitFailure 1
16:28:08 <vermeille> so? I hardly can believe that no one *knows* if cabal can update cabal files' dependencies
16:28:24 <vermeille> please
16:28:53 <Cale> vermeille: I don't understand the question
16:29:10 <Cale> vermeille: I don't think cabal-install will ever edit .cabal files for you
16:29:16 <athan> Is there a standard method to enabling implict packing & unpacking, like in Text, but for arbitrary data types?
16:29:24 <Cale> (if that's what you're asking)
16:29:48 <Cale> athan: Can you give an example of what you mean?
16:29:56 <Cale> athan: What implicit packing and unpacking?
16:29:56 <Fuuzetsu> @pl \f -> HaddockT . fmap (fmap f) . _runHaddockT
16:29:57 <lambdabot> (line 1, column 34):
16:29:57 <lambdabot> unexpected "_"
16:29:57 <lambdabot> expecting space or simple term
16:30:01 <vermeille> Cale: when you execute cabal init in a haskell project, it automagically detects dependencies. Is there a way to make cabal *update* this list of dependencies after the init?
16:30:07 <Fuuzetsu> @pl \f -> HaddockT . fmap (fmap f) . runHaddockT
16:30:08 <lambdabot> (HaddockT .) . (. runHaddockT) . fmap . fmap
16:31:15 <vermeille> (in order to fill in `build-depends`)
16:31:27 <Cale> hmm
16:31:48 <conal> Fuuzetsu: in SEC form, "inHaddockT . fmap . fmap"
16:32:04 <Cale> That's probably a good idea, but I don't know if it's there. You can of course do cabal init again
16:32:04 <athan> Cale: with the OverloadedStrings extension, `pack` and `unpack` are slipped in only _when needed_. Is there a way to add this functionality for a `Foo -> Bar` function, slipping it in only when needed?
16:32:17 <Cale> athan: Only pack is put in when needed
16:32:18 <athan> Or does typechecking not fuel that?
16:32:22 <conal> Fuuzetsu: I use that style often.
16:32:23 <Cale> athan: and only for string literals
16:32:52 <Cale> athan: Really, what happens is that string literals are translated so as to apply fromString to an ordinary String value
16:32:55 <Cale> :t fromString
16:32:56 <lambdabot>     Not in scope: ‘fromString’
16:32:56 <lambdabot>     Perhaps you meant one of these:
16:32:56 <lambdabot>       ‘BSLC.fromStrict’ (imported from Data.ByteString.Lazy.Char8),
16:33:00 <Cale> :t Data.String.fromString
16:33:01 <lambdabot> Data.String.IsString a => String -> a
16:33:22 <Cale> and then there's an instance of IsString for Text which defines fromString to be pack
16:33:36 <Axman6> There's some work on a liost version of IsString I believe, to allow [1,2,3] to be used for Array, Vector etc
16:34:18 <vermeille> Okay, if you don't know, how do you proceed when you need another dep, Cale?
16:34:21 <Axman6> but there's no implicit conversion bacl to String/list in those classes (it'll make type inference very annoying)
16:34:27 <Cale> vermeille: I just put it in by hand
16:36:24 <vermeille> Well, okay. A bit disappointing, but it works. Thanks.
16:39:45 <benzrf> :t even
16:39:45 <dncr> For a 1-bit image (0s and 1s), what's a good way to find all the different clusters of contiguous 1s?
16:39:46 <lambdabot> Integral a => a -> Bool
16:39:52 <benzrf> :t count
16:39:54 <lambdabot>     Not in scope: ‘count’
16:39:54 <lambdabot>     Perhaps you meant one of these:
16:39:54 <lambdabot>       ‘BS.count’ (imported from Data.ByteString),
16:40:15 <AleksejsHome> I'm starting to think that the only way to fix that cabal hell is to purge/reinstall haskell platform
16:40:18 <danilo2> Hello! I've got a traversal-like question to you today! :D Lets assume we've got data A = A B C (where these datatypes are recursive and have many constructors). I want to traverse this datatype and apply appriopriate functions to appriopriate types (like fA :: A -> m A would be applied as: A <$> fB B <*> fC C). Is there any support for something like that in lenses?
16:40:52 <AleksejsHome> I wiped ~/.ghc and even that didn't help
16:41:07 <trap_exit> I still do not understand
16:41:31 <trap_exit> why having easy infinite data structures (hard, but possible with strictness) is a worthwhile tradeoff for "you don't have stack frames during debugging; and reasoning about running time / space gets harder"
16:41:54 <trap_exit> it seems like we can have all the benefits of strictness, if we just introduced a new operator, say @, which creates a thunk in the background
16:42:05 <benzrf> danilo2: hmmmmm
16:42:14 <trap_exit> like "infinite x = x : @(infinite x)"
16:42:33 <trap_exit> boom, we now have infinite data structures, bu thaskell can be default strict, we can have stack frames, and easy ability to reason about time
16:42:36 <trap_exit> and it's obvious what's lazy and what's not
16:42:45 <benzrf> trap_exit: it's easier to strictify lazy code that you imported than make strict code you imported become lazy
16:42:48 <benzrf> or so ive heard
16:42:52 <benzrf> danilo2: can you elaborate a bit
16:42:58 <trap_exit> benzrf: I think that's a lie
16:43:02 <trap_exit> that's what I have heard too
16:43:28 <danilo2> benzrf: of course :) So I will try to describe it with other words :)
16:43:49 <merijn> trap_exit: The problem is that it's hard to anticipate which functions you'll benefit from making lazy
16:44:08 <merijn> trap_exit: Therefore if strict is the default you will run into "oh, I wish this was lazy :("
16:44:31 <merijn> trap_exit: Retro-actively making a computation lazy is almost undoable without modifying the code
16:44:44 <merijn> However, retroactively forcing a lazy computation to make it strict is pretty easy
16:44:56 <merijn> Therefore lazy is an easier default to work with
16:45:13 <AleksejsHome> ok, even reinstalling haskell-platform didn't help
16:45:18 <trap_exit> so modify the code
16:45:41 <merijn> trap_exit: What if the code is a library you don't control?
16:45:55 <AleksejsHome> so, probably to make it work I need to reinstall my PC? Or even that won't help?
16:46:01 <merijn> trap_exit: Should I reimplement every library that doesn't happen to be lazy when I need it to?
16:46:17 <merijn> trap_exit: Making a lazy library strict is easy, just seq/deepseq
16:47:23 <trap_exit> yeah
16:47:28 <trap_exit> but it screws up stack frames
16:47:33 <trap_exit> and ability to reasona bout time
16:47:39 <trap_exit> deepseq also is not constant time op
16:48:04 <Cale> Of course not!
16:48:08 <merijn> Of course deepseq isn't constant time, but that's not relevant
16:48:08 <Cale> Why would it be?
16:48:14 <danilo2> benzrf: Lets assume we've got: data A = A1 B C | A2, data B = B1 A C | B2, data C = C1 A B | C2. Now I've got instance of A and function (fB :: B -> m B). I want to traverse the instance of A in such way, that fB would be applied to all B's (even inside of C). It should be applied as:  applyA = \case A1 b c -> A1 <$> fB b <*> applyC fB c. The trick is, that If I provifde more functions like fB and fC and fD - they will behave the s
16:48:15 <phaskell> B2: Diff 88 - https://phabricator.haskell.org/B2
16:48:15 <phaskell> B1: Diff 8 - https://phabricator.haskell.org/B1
16:48:18 <danilo2> appripriate trypes
16:48:24 <merijn> trap_exit: stack frames aren't all the valuable in my experience
16:48:27 <trap_exit> so lazy -> strict is not the same as sprinkle deepseq everywhere
16:48:30 <Cale> It's obviously not constant time even for Integer
16:48:44 <Cale> Evaluating something can take any amount of time
16:48:45 <trap_exit> since doing so would increase running time
16:48:53 <merijn> I didn't say "sprinkle deepseq everywhere"
16:48:55 <Cale> ...yes
16:49:03 <merijn> I said "use deepseq when you want strict"
16:49:11 <Cale> Laziness is often good, you don't just want to spoil it for nothing
16:49:40 <Cale> Evaluating programs which were written for a lazy evaluator in a strict fashion will typically result in horrible performance
16:49:59 <Cale> (including but not limited to nontermination)
16:50:11 <merijn> trap_exit: I don't really see what you hope to accomplish by complaining about laziness, so you think stack frames are crucial and laziness sucks. That's fine, but then use ocaml/SML/F#
16:50:37 <Cale> Vice versa, if you write programs for a strict evaluator and then just evaluate them lazily, you're also not going to always have the best time with it.
16:51:06 <benzrf> danilo2: hmmmm
16:51:27 <dfeuer> Getting rid of laziness doesn't get you stack frames; tail calls will hose them up too.
16:51:35 <Cale> Lazy evaluation is a good default because the benefits of lazy evaluation are easy to spoil if you make things strict when you didn't think it would matter, and it later does.
16:51:37 <benzrf> danilo2: tbh im not 100% sure
16:52:58 <Cale> Most of the benefit of lazy evaluation comes from how programs can be composed, and conversely how problems can be decomposed in additional ways
16:53:31 <Cale> and if your libraries are full of strict functions which are only strict because that was the default, you lose most of the benefit of that greater compositionality
16:54:04 <danilo2> benzrf: right now I've got a datatype data Conf = Conf {fA :: A -> m A, fB :: B -> m B, ...} and a class Traversal cfg a b | a -> b where traverseM :: cfg -> a -> b and some instances. I'm using it like "traverse (def {fA = myfA}) instanceOfA" and it works - I'm just wondering if there is something more beautifull :)
16:54:35 <AleksejsHome> the solution of my problem was to install hslogger 1.2.6 https://github.com/jgoerzen/hslogger/issues/27
16:54:45 <dncr> I find that I almost always want laziness for any sort of control flow programming and almost never want it for any "normal" programming (manipulate an image etc).
16:55:25 <dncr> And by admitting defeat more and just making the latter type of things more strict from the get-go, I've been having more fun programming in Haskell lately.
16:56:16 <dncr> Before I started doing that, I would get to a "I feel like I need a PhD to fix this" about daily.
16:56:22 <Cale> The places where you want strict evaluation are the places where you're taking a large number of separately evaluable pieces of data and summarising them in some way into a piece of data with few separately-evaluable parts (as opposed to searching through them or transforming them)
16:57:13 <dncr> Yeah but you have to be so aware of the implications to make that work.
16:57:15 <Cale> (this includes things like "accumulators")
16:57:37 <dncr> And it can get really opaque really fast for mortals.
16:57:49 <Cale> But yeah, once you know what to look for, it's not such a big deal
17:01:05 <dncr> I still feel like memory leak laziness debugging is not well-solved for Haskell.
17:02:02 <sm> dncr: do you profile much ?
17:03:12 <dncr> sm: So many times I've followed along with the Real World Haskell chapter on profiling for problems I've had, and just gotten nowhere with them.
17:03:23 <Cale> There's an extent to which memory leaks are not easy to fix in any language, but at this point, I don't really see lazy evaluation as a particular impediment.
17:04:10 <Cale> Yes, you can leak memory in the form of thunks, but those memory leaks are pretty obvious to spot if you're worried at all about your memory use.
17:04:21 <Cale> (typically, anyhow)
17:04:42 <Cale> Well, "obvious" is relative
17:07:52 <dfeuer> Cale, one challenge is that optimization breaks profiling, but optimization also removes certain kinds of memory leaks. Catch-22.
17:07:54 <sm> my sense is that once you get comfortable with profiling, fixing leaks becomes somewhat routine, but profiling is currently a tough hurdle for many folks, could be improved, will be sooner or later
17:10:09 <Cale> dfeuer: Yes, this *is* a tooling problem
17:10:11 <AleksejsHome> ok, new problem: Cabal-1.16.0-c6e09e008cd04cf255c1ce0c59aba905 is unusable due to missing or recursive dependencies
17:10:41 <Cale> and the profiling tools, while they're pretty good in a lot of ways, could also be a lot better
17:10:49 <AleksejsHome> I think cabal author is the most cursed person in the history of mankind
17:10:57 <sm> far from it
17:11:04 <dfeuer> People traditionally throw rice at weddings in some cultures. I wonder if any throw fish....
17:11:05 <Cale> The "more realistic cost centre stacks" that got added a while back can make profiling large programs horrible
17:11:30 <dfeuer> 'Orrible 'ow?
17:11:34 <Cale> -rw-r--r-- 1 cale cale 18004261 Dec  9  2011 pcGame.prof
17:11:37 <Cale> ^^ like that
17:11:44 <dfeuer> Ewww.
17:11:47 <sm> heh
17:12:03 <dfeuer> 18 megabuds. That's too much.
17:12:17 <Cale> Yeah, it's pretty difficult
17:12:46 <Cale> the old way that cost centres were handled was actually more useful in a lot of cases
17:12:53 <sm> not as bad as my -rw-rw-r-- 1 simon     www-data 126522211 Sep 17 17:11 trace.1410999101.xt
17:13:16 <Cale> because you often don't really care from which path something got called in order to be expensive, you just want to know what the expensive things are
17:13:37 <dfeuer> OK, time to go buy milk!
17:13:47 <tommd> Can Haskell do that?
17:14:03 <Cale> tommd: sorry, do what?
17:14:10 <tommd> ... buy milk.
17:14:13 <Cale> hah
17:14:18 <tommd> @faq Can Haskell by my milk?
17:14:19 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
17:14:21 <tommd> Damn
17:14:45 <tommd> What happened to the overly evangelical lambdabot response?
17:16:28 <agibiansky> How can I implement readMay without using unsafePerformIO and without incurring any dependencies?
17:16:33 <agibiansky> Is that possible?
17:16:40 <agibiansky> I want to only be using `base`.
17:17:50 <HeladoDeBrownie> agibiansky, you mean like (Read a) => String -> Maybe a ?
17:18:00 <HeladoDeBrownie> agibiansky, that already exists in base afaik
17:18:12 <agibiansky> HeladoDeBrownie: Oh, sweet, you're right; as of base-4.6
17:18:16 <agibiansky> in Text.Read
17:18:17 <agibiansky> cool
17:18:33 <agibiansky> As an aside, I'm still curious
17:18:51 <agibiansky> Is it possible to implement it without unsafePerformIO given only read? You have to use IO to catch the exception, yeah?
17:18:52 <HeladoDeBrownie> agibiansky, it can be done in terms of reads
17:18:54 <sm> Cale: if you don't care about the call paths, can't you simply just always look at the summary at top ?
17:18:55 <HeladoDeBrownie> @type reads
17:18:56 <lambdabot> Read a => ReadS a
17:19:01 <agibiansky> Oh, I see
17:19:05 <agibiansky> That makes sense
17:19:08 <HeladoDeBrownie> That probably isn't a very helpful type in this context
17:19:26 <agibiansky> Yeah, makes sense, got it
17:20:24 <Cale> sm: Yes, though it's pretty incomplete
17:20:32 <Cale> sm: That summary only goes so deep
17:21:09 <Cale> sm: It would be nice to be able to have summaries of everything, and to be able to query based on things which occur in the path
17:21:28 <Cale> (which pretty much means not just having a static text file)
17:21:32 <sm> there's probably a lot that could be done to make the current profiler more practical, even without deep GHC changes
17:21:37 <sm> we should try to get the next GSOC'ers working on it
17:22:12 <Cale> agibiansky: What are you... why would you use unsafePerformIO for that?
17:22:27 <Cale> agibiansky: have a look at the reads function
17:22:29 <Cale> :t reads
17:22:30 <lambdabot> Read a => ReadS a
17:22:47 <Cale> > reads "356apple" :: ReadS Integer
17:22:49 <lambdabot>  Couldn't match type ‘[(a0, GHC.Base.String)]’
17:22:49 <lambdabot>                with ‘GHC.Base.String
17:22:49 <lambdabot>                      -> [(GHC.Integer.Type.Integer, GHC.Base.String)]’
17:22:49 <lambdabot>  Expected type: Text.ParserCombinators.ReadP.ReadS
17:22:49 <lambdabot>                   GHC.Integer.Type.Integer
17:23:06 <Cale> er
17:23:08 <sm> *smack*
17:24:02 <Cale> oh, derp, right
17:24:09 <Cale> > reads "356apple" :: [(Integer, String)]
17:24:11 <lambdabot>  [(356,"apple")]
17:24:19 <Cale> ReadS Integer is a function type :)
17:24:37 <agibiansky> Cale: My first approach was to catch the exception, because I forgot about ReadS :)
17:24:57 <agibiansky> but yes, that is silly
17:34:19 <Gurkenglas> https://www.fpcomplete.com/user/Gurkenglas/hoogle <- Did I do that wrong? There's an error.
17:36:45 <Gurkenglas> (Downloaded VisualWget to copy code.haskell.org/hoogle/src after some google-fu to figure out how to only copy that subdirectory, downloaded the GitHub client and made that folder a repos on github, made a project on fpcomplete that connects to github.)
17:42:18 <solatis> is there some equivalent of a 'haskell cookbook' already?
17:42:34 <solatis> i am interested in creating a website dedicated to that
17:42:52 <solatis> something more in the lines of 'beautiful haskell code samples'
17:43:42 <indiagreen> solatis: you'd better have ideas about how to attract people to it, then
17:43:50 <solatis> i know
17:44:36 <Gurkenglas> https://www.google.de/webhp?sourceid=chrome-instant&ion=1&espv=2&ie=UTF-8#q=beautiful+haskell+code+samples
17:44:47 <solatis> but a lot of the 'knowledge' or code samples of how to use certain libraries are currently spread out accross the internet in blogs
17:45:17 <solatis> and those can be pretty outdated
17:46:29 <yunxing> Just found that Magma are such a nice beautiful structure in the client server side architecture since it supports incremental updates
17:46:35 <yunxing> is *
17:46:58 <ratzes> Hello, does anyone know how haskell-cafe posts are filtered? I've tried to ask a few questions and nothing ever gets posted
17:47:24 <tommd> ratzes: How are you checking?
17:47:39 <tommd> You have to be subscribed, iirc, but I know of no other filtering.
17:48:19 <ratzes> I never see it posted or replied to or anything, just get an acknowledged from a haskell-cafe-bounces
17:48:27 <tommd> And if you want to ask questions then also consider asking them interactively here on IRC, via a programmer web site (ex: stackoverflow) or on the beginners list if that is appropriate (and still exists).
17:48:33 <ratzes> im subscribed
17:49:08 <ratzes> well my question was about the behaviour of inlinable vs inline and what can be specialized at the call site
17:49:45 <ratzes> especially, what happens if an exported function is inlinable, but its helper function are inline and for some reason the compiler ignores the inline
17:49:59 <ratzes> does that mean that the helper functions will not be able to be specialized?
17:50:55 <tommd> ratzes: Yeah, cafe sounds like a good venue here.  I don't know the answer to your question and it appears few people are here right now.
17:51:17 <tommd> In short: No filtering should be done - I've not experienced any in the past.
17:51:32 <edwardk> merijn: 'preferred versions' are window dressing, there is no effect
17:51:38 <ratzes> haven't spent much time on #haskell, have you found any best times for more involved questions?
18:10:06 <batchm> we have IO random functions, manually pass the seed around random functions, but no State random functions. why? wouldn't that be the most idiomatic way of implementing pseudo random functions in haskell?
18:10:50 <dfeuer> batchm, you don't need anything special for that. Just do it.
18:11:18 <indiagreen> batchm: we do, in MonadRandom package
18:11:28 <Iceland_jack> batchm: MonadRandom
18:11:32 <Iceland_jack> oh, indiagreen has pointed it out
18:12:16 <indiagreen> also, mwc-random has instances for both IO and ST
18:16:41 <batchm> dfeuer I have to do all the plumbing myself though, instead of just doing replicateM 10 random. but MonadRandom does seems nice
18:17:25 <Iceland_jack> batchm: There is "randoms"
18:17:26 <indiagreen> batchm: no you don't
18:17:30 <Iceland_jack> :t randoms
18:17:31 <indiagreen> use random-fu
18:17:32 <lambdabot> (Random a, RandomGen g) => g -> [a]
18:17:51 <indiagreen> it has exactly this thing, e.g. replicateM 10 stdUniform
18:18:01 <batchm> indiagreen I meant if i was to use prelude random functions
18:18:09 <indiagreen> ah, we-e-ell
18:18:21 <Iceland_jack> batchm: 'randoms' works if you restrict yourself to base
18:18:26 <batchm> Iceland_jack that works only in the simplest case, when that is all you need
18:18:35 <Iceland_jack> Exactly
18:18:39 <dfeuer> Prelude is really not enough for most things.
18:18:46 <Iceland_jack> If you want something more complicated you use what was preciously suggested
18:19:10 <batchm> random-fu or MonadRandom?
18:19:43 <Iceland_jack> MonadRandom if you want a monad for generating random numbers (threading the generator around)
18:19:58 <Iceland_jack> random-fu is more geared towards statistical use
18:26:33 <batchm> this is disheartening for someone new to the language though. four ways (at least?) of doing something as simple as generating a random number, and having to download a library for it
18:27:51 <Iceland_jack> batchm: The counting the libraries against it seems weird since every medium-sized language has a package for statistical random generation
18:28:47 <Iceland_jack> It's no problem generating a random number in Haskell but there are just more ways of using them (same with mutable references)
18:28:53 <batchm> I did not ask for statistical random generation. i asked for a non-messy way of handling seed threading
18:29:02 <batchm> which does not exist in prelude
18:29:10 <Iceland_jack> It does
18:29:11 <Iceland_jack> :t randomIO
18:29:13 <lambdabot> Random a => IO a
18:29:26 <batchm> unnecessary use of IO is messy
18:29:45 <Iceland_jack> MonadRandom should be in base in my opinion, but that's how other languages do it
18:30:42 <joe9> source : http://codepad.org/sYnE02f9, error: http://codepad.org/SXCOGmdU . Any thoughts on how I can fix it, please?
18:30:45 <batchm> most other languages don't have anything like IO, so that is not setting a very high bar
18:31:33 <Iceland_jack> base includes two ways of generating random numbers and if you want more they are available as libraries
18:35:17 <joe9> source: http://codepad.org/HnVvB6Kh , error: http://codepad.org/8gqYbz3d
18:35:28 <joe9> I seem to be missing something simple. Can anyone please help?
18:36:03 <Iceland_jack> joe9: Don't you need to indent 'f num' in line 64?
18:36:16 <Iceland_jack> by a single space
18:36:46 <CrazyM4n> So, my haskell's read function is completely broken.
18:36:50 <CrazyM4n> Should I reinstall haskell?
18:39:23 <CrazyM4n> > read "1"
18:39:25 <lambdabot>  *Exception: Prelude.read: no parse
18:39:33 <johnw> CrazyM4n: I think you may need to be a bit more specific
18:39:55 <CrazyM4n> Wait, what? Is read "1" really an error?
18:40:00 <Iceland_jack> > read "1" :: Int
18:40:02 <lambdabot>  1
18:40:05 <CrazyM4n> aaand I'm an idiot
18:40:22 <CrazyM4n> sorry for wasting your guys' time, haha
18:40:33 <zwer> > read "()"
18:40:33 <johnw> it's a mistake I think every one of us has made at least once
18:40:33 <Iceland_jack> No problem, my time is worthless
18:40:34 <lambdabot>  ()
18:40:47 <Iceland_jack> > read "3.1415" :: Double
18:40:49 <lambdabot>  3.1415
18:41:00 <zwer> that is what GHCI defaults to. if you were to write that in a file you would get an error if the type couldn't be inferred
18:41:12 <Welkin> time is worthless
18:41:19 <Welkin> it has no value
18:41:24 <Welkin> you cannot control it
18:41:30 <Welkin> it just happens
18:42:11 <Welkin> "time management" is an odd enterprise
18:42:25 <johnw> Welkin: this channel isn't really for general chatter
18:43:02 <joe9> Iceland_jack: got it, thanks.
18:43:07 <joe9> now, I get this error. http://codepad.org/JXWjBMAQ
18:43:33 <CrazyM4n> I can't even understand how I'm making these errors... I'm doing code golf and tried to check if a number in a list was odd...
18:43:40 <CrazyM4n> (\x -> x`mod`1==1)
18:43:44 <CrazyM4n> ;-;
18:44:14 <johnw> joe9: what is the type of f?
18:44:20 <johnw> i have a feeling you meant return $ f num
18:44:47 <MP2E> CrazyM4n: don't you mean x`mod`2==1 ?
18:44:57 <MP2E> everything integer is divisible by 1 evenly :V
18:45:06 <CrazyM4n> Yes, that's exactly what I mean. First, the whole problem with my read, and now this
18:45:10 <CrazyM4n> Today is just not my day
18:45:14 <johnw> forall n. n `mod` 1 == 0 :)
18:45:24 <MP2E> ^ summed up quite nicely :P
18:45:31 <johnw> CrazyM4n: at least your questions are not hard to answer!
18:45:38 <CrazyM4n> hah
18:46:34 <joe9> source: http://codepad.org/aYJcUnv2 , error: http://codepad.org/ssjjv97y . I seem to miss something simple.
18:48:05 <CrazyM4n> Is there anything like concatMap that automatically "show"s values?
18:48:08 <joe9> johnw: I seem to be missing something simple.
18:48:12 <CrazyM4n> Or do I have to do it manually
18:48:18 <johnw> joe9: I'm trying it here
18:48:24 <joe9> johnw, thanks.
18:48:33 <Iceland_jack> CrazyM4n: What to you mean "show"ing values automatically?
18:48:38 <joe9> I am not sure if it is because I am using Cont and ContT, johnw.
18:48:41 <CrazyM4n> Ah, nevermind
18:49:00 <joe9> CrazyM4n: check out groom to show data structures. It is pretty cool.
18:49:31 <johnw> joe9:
18:49:37 <johnw> Cont $ \f -> ...
18:49:41 <johnw> that "..." is not in the Cont monad
18:49:48 <CrazyM4n> That's cool, but all I needed was concatMap (++ "," . show)
18:49:49 <johnw> it's just a regular Haskell expression
18:50:11 <johnw> this works: example = do { num <- callCC (\k -> k (10)); return num }
18:51:02 <johnw> you don't get direct access to the outermost continuation like that in Cont, not without using callCC
18:51:07 <johnw> i.e., this would work:
18:51:22 <johnw> example = callCC $ \f -> do { num <- callCC (\k -> k 10); f num }
18:51:53 <johnw> so your original example was simply using Cont where you needed to use callCC again
18:52:30 <joe9> oh, ok. that's interesting. I did not even notice that.
18:53:05 <johnw> somehow it had inferred that your inner "do" block in the original example was in the list monad
18:53:10 <johnw> ah, because of the String type
18:56:05 <joe9> If I have a different monad that I am using. Can I get the callCC functionality by just adding that monad to the MonadCont typeclass?
18:56:25 <joe9> I want to use the continuation feature (green threads) with the Pause monad.
18:56:42 <joe9> For green threads, I just need the callCC and not the Cont monad, correct? johnw.
18:56:56 <johnw> right
18:57:04 <johnw> Cont is just a type wrapper to give you a Monad instance
18:57:19 <johnw> it's the CPS-transformed nature of the function that is doing the work
18:57:32 <johnw> (functions, plural)
18:57:42 <johnw> and I think yes, for the MonadCont question
18:58:25 <johnw> I love the way you're diving into understanding Cont
18:58:34 <johnw> this will be very fruitful in the end
18:59:48 <joe9> I am learning/learnt a lot.
19:00:07 <johnw> another interesting task down the line will be to prove the applicative and monad laws for Cont using equational reasoning
19:00:12 <vanila> learned*
19:04:30 <joe9> johnw: I tried coq once and learnt inductive proving. But, could not translate that knowledge to Agda or Idris. Now, I have given up on my ability to write proofs easily.
19:04:49 <joe9> I want to get used to programming in Idris with the hope that I will be able to write proofs at some point later.
19:05:25 <johnw> joe9: https://github.com/jwiegley/coq-haskell/blob/master/Cont.v
19:05:37 <joe9> All the Cont monad stuff that I am bothering you about is to write a cont monad in Idris.
19:05:43 <johnw> ahh
19:06:18 <joe9> vanila was kind enough to write me a cont monad in Idris. But, I want to learn/write it myself to understand vanila's code and also to understand to use it.
19:06:59 <joe9> johnw: Is your background in Math, by any chance? How did you learn proofs, etc?
19:07:05 <johnw> no, not at all
19:07:13 <johnw> i just learned through interest, reading and practice
19:07:32 <joe9> wow, I am very impressed. Are you a Comp-sci person?
19:07:39 <johnw> I am now :)
19:08:00 <joe9> studying comp-sci, I meant. comp-sci student or grad?
19:08:11 <vanila> hey joe9 did you catch my question in #idris yesterday?
19:08:14 <johnw> no, I've been in industry for a long time
19:08:20 <vanila> (if its too long to explain no worries)
19:08:38 <joe9> vanila: what was your question? I did not catch it.
19:09:00 <vanila> I was wondering what your idris project is, what is the bigger picture and such
19:09:09 <vanila> feel free to msg if you want?
19:09:17 <joe9> johnw: I have been in the industry for a while too. But, good to know that you kept your spark in good shape.
19:09:31 <johnw> yes, I still get fascinated pretty easily
19:09:34 <johnw> I love this stuff
19:18:51 <joe9> johnw: It is people like you that are responsible for our civilization's progress. good job.
19:19:40 <johnw> wow, I don't know about that, but thanks for encouragement, joe9
19:21:11 <cojy> oh did you also miss my thing yesterday then joe9 ?
19:21:40 <joe9>  I think monad transformers affect code comprehensibility. Any thoughts, please?
19:21:51 <joe9> cojy: what was it, sorry, did not catch it.
19:22:21 <joe9> just want to check about what is the general opinion on monad transformers usage.
19:22:23 <johnw> joe9: that's true, except when not using them affects it even more
19:22:35 <johnw> it's one of those trade-off type decisions
19:23:25 <joe9> johnw: vanila  just pointed to me eff-lang.org. Have you tried it?
19:23:28 <cojy> joe9: http://i.imgur.com/hxwwM8d.png
19:23:39 <joe9> cojy: yes, read that.
19:23:43 <johnw> no, but I've been curious
19:23:56 <benzrf> is that like whats in ps
19:24:11 <joe9> cojy: sorry, I did not respond as I did not know about eff.
19:24:29 <joe9> cojy: I am just reading up on eff. I think I will have a better opinion after reading.
19:24:45 <cojy> joe9: idris effect system is fairly similar to that the translation shouldnt be too much effort
19:25:12 <joe9> cojy: Pause monad: http://codepad.org/aEfYavHo Scheduler.idr: http://codepad.org/0jgmqHyj
19:25:15 <cojy> and it does all the cont stuff under the hood and exposes it to you
19:25:18 <cojy> for free
19:25:27 <joe9> cojy: if I can add callCC there, I should be able to get fork to work.
19:25:41 <joe9> cojy: So, I think I am looking at similar functionality though.
19:26:55 <joe9> cojy: thanks for pointing it out. the line 56 (fork) in Scheduler.idr is where I need callCC.
19:27:28 <joe9> cojy: I like the Idris effect system. I think it is a step-up to monad transformers.
19:27:40 <joe9> cojy: I think there is effects for haskell too.
20:12:05 <prinsen> Is there any way to make type "functions". I want to write 'A | B | C' which should stand for Either A (Either B (Either C ()))
20:13:04 <Iceland_jack> prinsen: Something like this?
20:13:04 <Iceland_jack>     type Either3 a b c = Either a (Either b (Either c ()))
20:13:22 <Iceland_jack> You can also do:
20:13:22 <Iceland_jack>     type a + b = Either a b
20:13:22 <Iceland_jack> and write:
20:13:25 <Iceland_jack>     a + b + c + ()
20:16:12 <vanila> you can't use +
20:16:17 <vanila> :+: may work though
20:16:27 <merijn> Yes you can, just requires TypeOperators
20:16:28 <Iceland_jack> You can
20:16:28 <Iceland_jack> ghci> type a + b = Either a b
20:16:29 <Iceland_jack> ghci>
20:16:37 <prinsen> Iceland_jack: the + things looks cool
20:16:39 <vanila> wow!
20:16:44 <prinsen> and docs?
20:16:48 <vanila> nice trick, thank you!
20:17:03 <prinsen> or is it plain haskell?
20:17:18 <Iceland_jack> prinsen: You need to enable the TypeOperators extension as merijn said
20:17:31 <kadoban> That looks so bizarre
20:17:47 <prinsen> ok
20:27:31 <merijn> Naming question
20:28:32 <merijn> If I have an internal "general" function and two specialisations, what's a good way to indicate the name is just a specialisation from a more general function?
20:30:18 <Iceland_jack> merijn: base has a 'strictGenericLength' which is an optimized version of length producing Int or Integer
20:32:13 <Iceland_jack> so if you specialised the functions because they make use of some property of the type (like how length can be computed strictly for Int and Integer) you could use that as a prefix
20:33:29 <Iceland_jack> same with maximum/minimum: http://hackage.haskell.org/package/base-4.7.0.1/docs/src/Data-List.html
20:47:39 <karina4> hi
20:48:13 <karina4> ay alguin con pueda platixar
20:48:21 <karina4> :(
20:48:53 <karina4> holaaa
20:58:57 <orbital> hmm... hoogle --color sometimes shows color and sometimes monochrome
20:58:59 <orbital> how odd
21:04:00 <orbital> what would do that?
21:04:05 <benzrf> bye
21:04:18 <kadoban> Well, monochrome is a color too :-/
21:06:36 <orbital> kadoban: yes, but not the color i want... plus, the erraticism a discomforting mystery
21:07:33 <kadoban> Yeah, I'm not sure why it does that. All I have is lame semi-jokes for you, unfortunately.
21:10:00 <orbital> kadoban: they help a little, so thanks
21:10:26 <kadoban> :)
21:10:39 <orbital> now, if they were real jokes...
21:11:05 <orbital> is it possible for cabal to be nondeterministally picking up different package versions?
21:11:16 <orbital> that would explain it
21:13:36 <jle`> it's pretty easy to upgrade semi-jokes to real jokes, you just need to add an external identity element
21:14:53 <orbital> jle`: this just made my evening :)
21:15:42 <kadoban> Haha, nice
21:33:33 <vermeille> What's the best choice today for client/server web development with heavy ajax communication?
21:34:10 <structuralist> is IntMap (IntMap a) much faster than Map (Int, Int) a ?
21:34:44 <jle`> sounds like a job for profiling! :D
21:35:13 <structuralist> hoping someone has a cached answer :P
21:37:38 <jle`> what sort of operations were you hoping on optimizing for?
21:38:07 <jle`> lookups, merges?
21:38:10 <jle`> adds?
21:40:02 <prinsen> If you want a partial Default instance for a data type, would you make the instance for (A -> B -> T) instead, where A and B are non-default field?
21:43:00 <fluffynukeit> hi all.  When I am using the FFI and I malloc, does the underlying memory get initialized to 0?  If not, how do I do that?
21:43:59 <vermeille> fluffynukeit: use the poke function to initialize the memory, I don't think (and I don't hope) it's initialized
21:46:16 <fluffynukeit> vermeille: ok, I will give it a try.  I was hoping that there was some way to initialize to 0 without needing to make a dummy 0 initialization record
21:49:32 <vermeille> fluffynukeit: you can also look at `with` from Foreign.Marshal.Utils, but I'm not sure that's what you're looking for
21:54:39 <fluffynukeit> vermeille: poke worked for me! issue solved it seems
21:58:32 <jle`> prinsen: partial?
22:01:34 * hackagebot judy 0.2.3 - Fast, scalable, mutable dynamic arrays, maps and hashes  http://hackage.haskell.org/package/judy-0.2.3 (MarkWotton)
22:06:08 <pig_wick> Hello I was wondering if there was anyway to capture and read the output of a process bar (every time something is written to it)  executed by readProcessWithExitCode form System.Process ?
22:09:22 <AfC> I have various builds fighting over text-1.1 vs text-1.2 {sigh}
22:11:53 <pig_wick> AFC: various builds?
22:12:53 <AfC> pig_wick: oh, I do my actual app building in sandboxes, but for documentation I like to have as much as possible installed normally locally so I can carry the haddock with me. And then I get the dreaded "the following packages will be broken by..."
22:13:56 <pig_wick> AfC : carry the haddock with me ... I guess it will be more time before I can use that in a conversation
22:14:24 <AfC> heh
22:14:40 <AfC> Try spending an hour a day on a boat commuting to work. :)
22:15:15 <AfC> Speaking of which, /me runs to catch the ferry
22:17:54 <orbital> hey, i spend 2 hours a day on a boat commuting to work
22:18:17 <orbital> those are mighty fine hours
22:20:04 <pig_wick> I was wondering if someone could tell me how continously capture output from a progress bar from a process spawned by readProcessWithExitCode?
22:21:18 <kadoban> pig_wick: That's not going to be easy. Is there another way to accomplish what you want?
22:21:57 <pig_wick> kadoban : Haha I had a feeling it was going to come down to this ... why is it difficult ?
22:22:06 <agibiansky> Hey all. Question: Is Data.HashMap spine-strict? It looks like it uses Array# internally, which stores boxed values, so to me it looks like it isn't. Is that right? If so, is there a corresponding spine-strict version?
22:23:24 <monochrom> an array is spine-strict
22:23:59 <dfeuer> pig_wick, how about you explain exactly what you're trying to capture?
22:24:04 <kadoban> pig_wick: Because progress bars that are output in terminals are a mess of control codes, basically. That's what I'm assuming you're trying to parse. What does it look like in practice?
22:24:36 <agibiansky> monochrom: According to the haskellwiki on arrays, "The Array# type is used inside the Array type which represents boxed immutable arrays. ", and ""Boxed" means that array elements are just ordinary Haskell (lazy) values, which are evaluated on demand, and can even contain bottom (undefined) values.". Is one of those wrong? It seems like together they mean that it's not spine-strict.
22:25:20 <pig_wick> kadoban: Your assumption is correct. I'm not not sure I understood your question as to what it looks like ..
22:25:26 <dfeuer> pig_wick, you probably also have to use some OS-specific technique to make believe that the process's stdin is a terminal.
22:25:39 <pig_wick> dfeurer: I should explain myself
22:25:41 <dfeuer> er.. stdout, I mean.
22:25:55 <dfeuer> THat's also not my name.
22:27:02 <pig_wick> dfeuer : my apologies. I like writing code to 'simplify' youtube-dl (python program to download videos) ... no api of any sort so  ..
22:27:04 <dfeuer> agibiansky, I don't know what you're getting at, but the *structure* of an array (i.e., its size) is all known at once.
22:27:15 <monochrom> ok, I am too lazy to completely read the source code to find out what is actually stored in the cells and what happens to them.
22:28:00 <agibiansky> monochrom: What I mean is that Array# does not force it's contents to NF, they are lazy. Since HashMap uses Array# to store branches, it means that HashMap is *not* spine-strict.
22:29:09 <pig_wick> dfeuer: ATm I have this (https://github.com/nerorevenge/haskell-covering-for-youtube-dl/blob/master/oggy.hs) .. atm it is trying to capture the percentage via rgex from the stdout ..
22:29:33 <dfeuer> Best of luck.
22:29:35 <dfeuer> *barf*
22:29:59 <pig_wick> dfeuer : Code too ugly huh?
22:30:43 <dfeuer> Functions with names like "doSomething" and "act" and "checkValidness" are maybe not so clear. But mostly what you're trying to do is pretty ugly.
22:31:15 <pig_wick> dfeuer : I keep forgetting to change those names ...so how I change my style?
22:32:03 <dfeuer> Style? I'm not complaining about your style. It's just trying to scrape a progress bar out of some other program's output seems shady.
22:32:33 <dfeuer> pig_wick, do you even know if it *makes*  the progress bar if its stdin/out isn't a terminal?
22:33:00 <kadoban> pig_wick: Can you edit the python code instead so it outputs something nicer? Also, yeah what dfeuer mentions is a good point, check what output you're actually getting first.
22:34:06 <pig_wick> em not sure how to irc two people at once : THe ocode normally outputs a progress bar to a terminal . The stdout captured throught the function (haskell) is the complete stdout with the progress bar filled ..
22:34:41 <kadoban> pig_wick: Does thing program you're wrapping have a python API? Maybe you can use that instead of wrapping it like that on the command line
22:34:52 <kadoban> s/thing/the/
22:35:07 <pig_wick> kadoban : It does not have a Python API ..haha
22:35:59 <dfeuer> pig_wick, I think kadoban's approach, of editing the Python to make its output friendlier, is a very sensible one.
22:36:13 <kadoban> pig_wick: Add one? It looks like you're just calling 'python blahblah.py', so edit blahblah.py, or add a python wrapper around it, depending on how friendly the code is.
22:37:28 <pig_wick> I was wondering, if say there were easier ways to it , would it not be considered challenging (hence interesting ) to try to solve this via this route? I seem to have gotten the same replies elsewhere. PLease, this question (this one not the stdout question) is out of curiosity
22:37:39 <kadoban> pig_wick: The thing is apparently open source anyway. Maybe write a better interface for it, if that's what you're doing, and submit the code upstream? :)
22:37:55 <pig_wick> kadoban: Hmm that's an idea
22:37:56 <dfeuer> I did that to a FORTRAN program back in high school just to add some nice markers a Perl script could latch onto. (I wanted to replace the FORTRAN program, but it was utterly incomprehensible, with floating point constants scattered throughout and no meaningful comments).
22:37:59 <kadoban> pig_wick: Well, if you just want to do it because, write the output you're getting to a file, and examine it like that, you'll probably see the problem.
22:38:36 <dfeuer> Use a hex editor.
22:38:40 <dfeuer> Or hex dump program.
22:38:57 <kadoban> Yeah, good point. There's at least going to be bunches of '\r's in there.
22:39:44 <pig_wick> attempting to do that in real-time is going to be a pain ?
22:39:59 <dfeuer> Don't do it in real time then.
22:40:07 <dfeuer> Redirect to a file and examine the file.
22:40:07 <kadoban> You mean will it be impossible to do it quickly enough? It probably won't be that bad.
22:40:23 <kadoban> The hard part is going to be writing the code to do that, since it's probably a big mess.
22:40:43 <kadoban> It's also almost guaranteed to be pretty fragile, I'd think.
22:41:06 <pig_wick> not sure if I forgot to mention the following out of fear people will think I'm wasting their time ...I want to capture the ouput so as to display my own version of a progress bar ..hehe (shrinks away)
22:41:31 <kadoban> Well, I figured, otherwise I'm not sure why you'd be doing that.
22:41:54 <Hijiri> It seems like a better long-term solution would be making a youtube-downloader entirely in haskell, but I don't know enough about the youtube API to know how long that would take
22:42:19 <pig_wick> Hijiri: I don't think it uses the youtube api
22:42:33 <Hijiri> can you tell what it does?
22:43:40 <pig_wick> Hijiri: from what I understand and the little of the source code I went through ...it somehow manages to capture the media file directly from the link
22:43:52 <kadoban> It's probably not a trivial problem...the python thing he's wrapping has 6k commits, and is quite a few thousand lines of python. Not sure how much of that is really necessary, but I wouldn't be surprised if a decent fraction was.
22:44:30 <Hijiri> that doesn't seem much more detailed than just the description of the program
22:45:07 <Hijiri> I guess if it's that big rewriting it could take a while
22:45:39 <Hijiri> but the solution is already done in python, you probably wouldn't have to solve any new problems
22:46:49 <pig_wick> IO'm technically still a Haskell newbie who still has yet to cover chapter 14 and 15 of lyah ....soooo you think it;'' still possible?
22:47:19 <pig_wick> oh wait nevermind that question
22:47:24 <Fuuzetsu> biggest problem with doing anything like a rewrite of youtube-dl is the maintenance effort
22:47:40 <kadoban> I'm sure it's possible. It's probably not a weekend project to do it at all correctly, though I wouldn't be surprised if you can get...a hacky, kinda crap version working over a weekend.
22:47:56 <Fuuzetsu> kadoban: you can probably get just YouTube working pretty easily
22:48:11 <pig_wick> Oh you mean the other websites huh?
22:48:38 <Hijiri> yeah, I guess you would need people to update things each time a site changed the way they stream videos
22:48:57 * Fuuzetsu just had this very discussion about rewriting youtube-dl the other day
22:49:17 <kadoban> Fuuzetsu: Probably to some extent, sure. I'm looking at even just the youtube part though, and there seem to be quite a few details. Not sure how many are really necessary for daily use.
22:49:18 <pig_wick> Wonder if it's possible to write AI programs to do that .. wishfull thinking of a fool
22:49:52 <Hijiri> why AI?
22:50:02 <Fuuzetsu> if you have an AI which will write programs as APIs change you will be a very rich person
22:50:23 <pig_wick> tso that people don't have to bother with the way the site reqires the way it gives out media files
22:50:31 <kadoban> You'll also be 80% of the way towards writing skynet
22:50:35 <pig_wick> eh gosh my language is all over the place
22:50:40 <Hijiri> it just seems like "AI" isn't very well defined the way you used it
22:50:56 <agibiansky> Does anyone know whether there is a spine-strict fast HashMap similar to Data.HashMap somewhere?
22:51:01 <Fuuzetsu> it also seems like a much harder task either way ;P
22:51:09 <kadoban> Hehe
22:51:27 <pig_wick> well I can dream till I hide hard reality ..
22:51:31 <pig_wick> hit*
22:52:04 <Hijiri> you can go into academia and keep on dreaming
22:53:01 <pig_wick> Hijir: I've always wondered aren't there people outside academia who attack these problems on their own?
22:53:39 <kadoban> pig_wick: What problems? Movie AI? Sure, lots of people are working on it. It's a /hard/ problem though.
22:54:55 <Hijiri> I'm just talking about the ivory tower people like to talk about
22:55:03 <pig_wick> kodoban: nevermind .. I guess I don't much to ask the right questions.
22:55:26 <pig_wick> so all in all the reading from stdout is pretty difficult .
22:55:39 <merijn> pig_wick: People do attack them on their own, but these are hard problems and if you can't devote hours each day you're probably going make very slow progress
22:55:58 <kadoban> pig_wick: Reading from stdout is going to be tedious, but by no means impossible.
22:56:07 <merijn> pig_wick: The reason why academia dominates these fields is the fact that academics can devote work time to tackling these issues
22:56:30 <kadoban> pig_wick: Write the output to a file and take a peak, that should give you a much better idea of what you're working with.
22:56:40 <Hijiri> I was going more for the angle that depending on your field you might not need to make more than a proof of concept, but it's true that it's easier to work on higher-risk issues in academia
22:56:54 <Hijiri> because being able to research something isn't directly linked to it being profitable
22:57:37 <pig_wick> Hijiri: I understand. I suppose I was refering to those people who ere in just for the fun of it because they don't really have anything else to do
22:58:13 <pig_wick> kadoban: I'll keep that in mind
23:00:11 <kadoban> pig_wick: The reason I suggest so much the other ways to go about this is...stdout for programs like that isn't meant to be read by a program. There will be little thought put in about making it easy to robustly parse. Anything exceptional that happens will probably break your parsing, unless you handle a bunch of special cases well, at a guess. And new versions are almost guaranteed to break your parsing too.
23:00:54 <kadoban> pig_wick: Also, you might have fun problems like localization issues. If you start parsing messages, what happens when someone else runs your thing in a different language, and all the messages you're parsing are different? Fun.
23:00:55 <merijn> kadoban: What? The golden rule of unix is that output on stdout should be parsable
23:01:16 <merijn> kadoban: The fact that people develop tools now that aren't is an ugly heresy
23:01:37 <kadoban> merijn: He's trying to wrap something that very much doesn't follow that principle (youtube-dl)
23:02:07 <adas> if there is one fundamental, ultrabasic .. atomic, self-contained fact to know about haskell.. what would that be?
23:02:07 <pig_wick> kadoban: I just wanted to this to be a creative excercise of sorts ..not a long term solution ..not sure if short term solution is fit here. Um I'm allowed to that right?
23:02:24 <merijn> adas: types are awesome? :p
23:03:05 <kadoban> Sure, you're certainly free to do whatever you want. Just pointing out the problems you might run into. If it's just a personal project, then a lot of that won't matter at all.
23:03:07 <adas> merijn: perhaps.. but is there something more fundamental? like "everything is a function" (not sure if that true or not)
23:03:24 <Iceland_jack> adas: That's not true
23:03:27 <kadoban> adas: It's not, but it's a widely held belief for some reason.
23:03:42 <adas> merijn: or perhaps "types are just values in another domain" (not sure if that is true or not either)
23:03:44 <merijn> adas: Not every is a function
23:03:53 <merijn> @google Conal Elliot everything is a function
23:03:56 <lambdabot> http://conal.net/blog/
23:03:56 <lambdabot> Title: Conal Elliott
23:03:59 <merijn> hmm
23:04:02 <merijn> right blog, wrong link
23:04:19 <merijn> See http://conal.net/blog/posts/everything-is-a-function-in-haskell
23:04:42 <adas> so .. now I know that everything is not a function..
23:06:23 <kadoban> adas: Boiling a programming language down to one fundamental fact is kind of a lost cause anyway. Just asking out of curiosity, or is there some reason you want one?
23:09:01 <adas> kadoban: i agree.. lost cause, maybe. but i was wondering if there was some universal truth about haskell .. that applied to everything that had to do with haskell
23:09:11 <adas> maybe there is no such thing
23:09:34 <adas> i think thats too philosophy.. no place for that here..?
23:09:39 <kadoban> There's probably...none or several, depending on how picky you get.
23:10:47 <adas> people asking these kinds of questions tend to be folks that "love/like" the language but don't why... i think im implicating myself : )
23:11:37 * hackagebot Smooth 0.1.0.1 - A tiny, lazy SMT solver  http://hackage.haskell.org/package/Smooth-0.1.0.1 (dillonhuff)
23:11:39 * hackagebot FirstOrderTheory 0.1.0.6 - Grammar and typeclass for first order theories  http://hackage.haskell.org/package/FirstOrderTheory-0.1.0.6 (dillonhuff)
23:16:37 * hackagebot DifferenceLogic 0.1.0.4 - A theory solver for conjunctions of literals in difference logic  http://hackage.haskell.org/package/DifferenceLogic-0.1.0.4 (dillonhuff)
23:30:24 <wei2912> @let derp 1 = ["0", "1"]
23:30:27 <lambdabot>  Defined.
23:30:41 <wei2912> @let derp n = concat [["0" ++ x, "1" ++ x] | x <- derp (n - 1)]
23:30:43 <lambdabot>  Defined.
23:30:45 <wei2912> > derp 3
23:30:48 <lambdabot>  ["000","100","010","110","001","101","011","111"]
23:32:14 <Iceland_jack> > replicateM 3 "01"
23:32:16 <lambdabot>  ["000","001","010","011","100","101","110","111"]
