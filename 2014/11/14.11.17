00:01:50 * hackagebot keter 1.3.6 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-1.3.6 (MichaelSnoyman)
00:06:49 <mrsElectron> the hell is a matrix in haskell?
00:06:50 * hackagebot yesod-bin 1.4.0.8 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.0.8 (MichaelSnoyman)
00:07:22 <mrsElectron> [[a]] ... damn, I'm so tired that I barely can think. That's so simple, but I just can't..
00:07:39 <mrsElectron> I don't know my name soon.
00:08:33 <mrsElectron> [[a],[b]] <--- what's the row and what's the column?  is a and b row 1&2 or are they column 1&2?
00:09:12 <dv-> that's your choice
00:09:22 <kadoban> mrsElectron: You can pick how you like. [[]] isn't a matrix until you give it meaning and define operations on it.
00:09:47 <mrsElectron> kthnx
00:09:53 <ReinH> mrsElectron: maybe take a rest and try it again fresh tomorrow
00:09:56 <dv-> also, immediately when i said that i received spam from fustirge
00:10:12 <jle`> goodbye hackagebot
00:10:22 * hackagebot yesod-bin 1.4.0.8 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.0.8 (MichaelSnoyman)
00:10:22 * hackagebot open-typerep 0.2 - Open type representations and dynamic types  http://hackage.haskell.org/package/open-typerep-0.2 (EmilAxelsson)
00:10:24 <ReinH> hackagebot is tired
00:10:33 <jle`> welcome back hackagebot
00:10:38 <mrsElectron> ReinH: I'd like to, but I can't. Been awake for 24h now, and it's the middle of the day, and I've got work today. If I could, I'd sleep 3 hours and then go to work, but I just can't sleep.
00:10:48 <mrsElectron> dv-: me too
00:11:38 <zerkms> guys, is haskell a good tool for implementing short living command line tools?
00:12:37 <zerkms> and what is more important - how big is the memory footprint for a tiny application compared in scala/clojure/haskell?
00:12:52 <johnw> scala and clojure both require the JVM
00:13:11 <zerkms> I'm asking such a weird question because I've just implemented a command line tool which is just 60 lines of code but it consumes 130Mb of ram
00:13:13 --- mode: ChanServ set +o johnw
00:13:13 --- mode: johnw set +b *!~fustirge@84.78.23.189
00:13:13 --- kick: fustirge was kicked by johnw (off-channel)
00:13:13 --- mode: johnw set -o johnw
00:14:43 <kadoban> zerkms: What's it do? And does 130 MB really matter, if it lives for very little time like you say?
00:15:15 <zerkms> in short - its purpose is for read from 1..N log files, process and put into another log files
00:15:17 <dv-> haskell's memory use varies wildly
00:15:27 <zerkms> little to no logic or algorithms
00:15:42 <johnw> zerkms: most command-line tools which are not memory intensive should take less than 1 MB of
00:15:51 <johnw> (written in Haskell, that is)
00:16:01 <johnw> if you're seeing more than that, you have inefficiency in your code
00:16:09 <indiagreen> zerkms: are you using strict Text or ByteString?
00:16:23 <indiagreen> and what kind of processing are you doing?
00:16:24 <zerkms> I'm talking about clojure above ^ ^ ^
00:16:36 <zerkms> it's clojure app that consumes 130Mb :-)
00:16:36 <indiagreen> ...ouch, right, sorry
00:16:41 <indiagreen> nevermind
00:16:58 <zerkms> and at the moment it just reads files from continuously growing files and outputs to the screen
00:17:06 <kadoban> zerkms: ...probably would have been a good idea to mention that
00:17:09 <zerkms> so I don't accumulate literally no data in the app
00:17:15 <johnw> zerkms: if you write a Haskell CLI tool and it balloons out to 16G of RAM, just remember not to blame Haskell immediately; poorly written Haskell programs can use huge amounts of memory unintentionally
00:17:30 <johnw> (and I'm taking that 16G number from a recent experience)
00:17:41 <zerkms> johnw: I understand that, that's why I cannot find a way to ask a question in an answerable way
00:17:41 <johnw> (after some profiling, it came down to 4 MB)
00:17:51 <ReinH> hah
00:17:59 <johnw> the fix was even a one-liner
00:18:08 <zerkms> the thing is that hello world app in clojure takes 65Mb, which I cannot accept
00:18:23 <johnw> I imagine that 65Mb is the size of the JVM, zerkms
00:18:38 <zerkms> Java hello world takes 11
00:18:42 <zerkms> so it's JVM + clojure
00:18:47 <johnw> I once tried to use JVM languages for CLI scripting, but gave up
00:18:51 <johnw> the startup is too slow
00:19:07 <zerkms> so in short you would say that I won't suffer from this kind of issues if I do that in haskell?
00:19:17 <johnw> Haskell can startup at C-like speeds
00:19:19 <zerkms> (I understand that I might suffer from something else though)
00:19:40 <osa1> any idea about speeds of testBit on Word8, Word32 and Word64?
00:19:54 <johnw> osa1: yes
00:20:02 <kadoban> Haskell runs pretty quick in general, the startup isn't slow by any means, and you can tune things down to small multiples of C speed in most cases if you go through the effort.
00:20:04 <johnw> osa1: testBIt in Word64 should be fairly decent
00:20:05 <platz> there are thing like 'drip' to reuse a running jvm, but i hear it's not widely used by experienced folks
00:20:27 <johnw> platz: yeah, I tried using 'nailgun', sort of the same thing
00:20:33 <zerkms> platz: yep, that would be the case, but I need to run it in a number of containers
00:20:33 <johnw> it can have weird state issues
00:20:40 <zerkms> which run in isolated memory
00:20:53 <zerkms> I just cannot afford running 100+Mb app 100+ times
00:21:02 <zerkms> well, I can, but I don't want
00:21:20 <zerkms> so, haskell. m'kay
00:21:29 <johnw> just to be sure, are you talking about memory use, or the size of the executable?
00:21:38 <zerkms> It's memory usage
00:21:41 <johnw> k
00:21:46 <zerkms> the size of executable is 6.5Mb
00:21:50 <zerkms> and 3Mb for hello world
00:22:01 <johnw> Haskell executables can be fat, just to warn you
00:22:33 <zerkms> If it doesn't start for 2 seconds and doesn't chew 150mb I can live with it
00:22:40 <johnw> than you'll be happy
00:22:48 <kadoban> Yeah, you should be good then
00:22:49 <johnw> until you face your first space leak, that is
00:22:52 * zerkms puts clojure book back to shelf
00:23:01 <johnw> then just come back here before self-imploding
00:23:10 <ReinH> I can't imagine trying to use a JVM language for scripting tasks...
00:23:11 <zerkms> you shouldn't say so when you do a language marketing
00:23:25 <johnw> I believe in honesty, not marketing
00:23:28 <ReinH> Well I can in fact imagine it. And I imagine it to be terrible.
00:23:34 <zerkms> ReinH: I would do that in python if it wasn't that simple
00:23:55 <zerkms> we all need some challenges in our lives
00:24:13 <ReinH> Haskell is plenty challenging...
00:24:25 <ReinH> But also very rewarding.
00:24:42 <johnw> you can even write programs with it
00:25:26 <zerkms> I know haskell basics, which I find very helpful reading a book that uses standard ml as the language for code
00:25:54 <zerkms> so I more or less can imagine what I should expect from coding perspective, know nothing about runtime aspects (hence asked it)
00:26:15 <ReinH> (Haskell and SML have rather different evaluation models)
00:26:15 <zerkms> okay guys, thanks
00:26:41 <zerkms> but at least understanding pattern matching and other stuff helps read code
00:27:01 <zerkms> or may be I confuse it with erlang :-S
00:27:20 <ReinH> No you're right
00:27:59 <zerkms> I've read about both haskell and erlang long time ago in bed before sleeping, so you can imagine that my knowledge is very limited by tired and sleepy brain
00:28:19 <zerkms> (sorry for flooding that much, now getting silent)
00:28:35 <ReinH> It's already pretty quiet, no worries
00:29:37 <zerkms> and I understand it's pretty offtopic here - but for my task (trivial log analyzing) - what would be a better choice: erlang or haskell?
00:29:38 <platz> :-S <- looks a bit like joe armstrong w/ his mustache
00:30:00 <zerkms> so - no network, very few threads job, regular expressions and file IO
00:30:22 <ReinH> zerkms: Haskell is poor in regular expressions but makes up for it with excellent parsing
00:30:58 <zerkms> if it supports something that may just test PCRE for matching - it's enough
00:31:02 <ReinH> Haskell also has sophisticated options for streaming IO that will help minimize memory use and ensure that resources are released promptly
00:31:45 <ReinH> It supports regular expressions. There are various libraries. It's just that the parsing tooling is much better.
00:32:19 <zerkms> Okay. In my case regexes will be a part of app configuration, so I just have to use it
00:32:27 <ReinH> I don't consider Erlang a scripting / general purpose language. i consider it a DSL for concurrent/distributed systems.
00:32:44 <ReinH> Certainly you could write such a script, but that's not really Erlang's focus.
00:32:52 <zerkms> and summarize: application will read a log file, and join lines in case if it (not) matches a regex
00:33:26 <zerkms> to be even more precise: I need to do that to join multi-line slow logs from postgresql logs to be single lines
00:33:42 <zerkms> so that it was possible for other tools that expect one line queries to process it
00:34:31 <ReinH> That would be pretty simple to write in Haskell. Or Perl. ;)
00:34:47 <zerkms> or python. but it's boring
00:36:11 <zerkms> Is there anything better than "Learn You a Haskell for Great Good!" for a newbie?
00:37:55 <michel_slm> Real World Haskell is quite good. Haskell School of Expression is excellent but hard to get and pricy
00:37:57 <michel_slm> pricey
00:38:38 <shelf> zerkms: thanks for the book!
00:38:39 <_rgn> zerkms: i'm almost through with LYAH and i'm mostly missing practical examples and explanation why some of the concepts are useful
00:38:46 <_rgn> but i can still recommend it
00:38:47 <platz> brent yorgey's haskell classes are nice too..
00:39:02 <michel_slm> platz: ah, need to try that, thanks
00:39:07 <_rgn> also, https://www.edx.org/course/delftx/delftx-fp101x-introduction-functional-2126
00:39:28 <michel_slm> _rgn: for practical examples try RWH or, say, the Yesod book to write web apps
00:39:48 <zerkms> I'm choosing LYAH - it has less pages and nice elephant on the cover
00:39:57 <zerkms> what else a good book need to have
00:40:21 <michel_slm> _rgn: drats, do they have deadlines in that class? as in , if I join now
00:40:41 <_rgn> they do have some
00:41:08 <ReinH> zerkms: I have some recommendations here http://reinh.com/notes/posts/2014-07-25-recommended-reading-material.html
00:41:19 <ReinH> But right now Richard Bird's new book is by far my favorite
00:41:46 <ReinH> It's a complete update of what I used to consider to be the best book on functional programming ever written.
00:42:23 <_rgn> Thinking Functionally with Haskell
00:42:32 <ReinH> I'm not a big fan of LYAH, personally
00:43:07 <_rgn> how much of that book is redundant after LYAH?
00:43:16 <MP2E> ReinH: good to know :) I'll have to get it
00:43:23 <ReinH> _rgn: almost none of it
00:44:07 <ReinH> LYAH is a very shallow introduction to Haskell
00:44:26 <_rgn> should I get that or RWH next?
00:44:36 <MP2E> yeah, LYAH was a good introduction but afterwards I remember thinking 'wait.. what? was that it? I'm not ready yet :('
00:44:50 <ReinH> That's exactly why I *don't* think it's a good introduction
00:44:57 <ReinH> _rgn: Bird's book, absolutely
00:45:09 <_rgn> ok, i'll consider it. thanks
00:45:14 <ReinH> Like I said, this is an improved version of *my favorite FP book of all time*
00:45:25 <zerkms> what is the complete title?
00:45:34 <ReinH> Thinking Functionally with Haskell
00:47:56 <mrenaud__> Hey, I was wondering what a more efficient way of sorting a list of something is, Data.List.sort is quite slow.
00:48:01 <zq> ReinH: i'm curious about what you find lacking in the existing regex libs
00:48:16 <ReinH> LYAH also tries to affect a friendly tone but just ends up seeming overly patronizing to me.
00:48:43 <ReinH> zq: The Haskell regexp libraries are decent, but they're still regexp libraries ;)
00:48:57 <ReinH> So mostly what is lacking is that they're not *not* regexp libraries.
00:49:09 <kadoban> Hehe
00:49:19 <_rgn> i don't think it's really patronizing
00:49:39 <ReinH> _rgn: I'm sure people will react to it differently
00:50:07 <ReinH> It seems affectatious to me
00:50:13 <kadoban> mrenaud__: Is there anything special about what you're sorting? How slow is it? Are you sure that that's the problem?
00:50:37 <kadoban> The tone of LYAH put me off a bit too, although I eventually did read it.
00:50:53 <zq> ReinH: i'm not sure that i comprehend. there are situations where, for instance, parsers are less efficient in space than regexes.
00:51:17 <ReinH> zq: Like what?
00:52:29 <zq> ReinH: pattern matching in strings? the very usecases that regexes were originally conceived for
00:53:07 <ReinH> Why would a parser be less efficient?
00:53:10 <mrenaud__> Nope, just Ints. I was just playing around with some stuff and noticed that sorting a list is really slow, which I expected. I was just wondering what a more efficient alternative is.
00:53:27 <johnw> regexps are a way of writing code in strings to match strings; so, if you can just write code to match strings, it is the same, provided it gives you the same level of expressiveness
00:53:49 <ReinH> A regexp is just a DSL for a search pattern
00:53:53 <johnw> yep
00:54:02 <zq> johnw: it does, but the code you write will likelier to be far less compact and to-the-point than the equivalent regex
00:54:15 <ReinH> zq: That is a different argument
00:54:17 <johnw> and a Haskell parser doesn't need to first parse the regexp to determine the parser to build; it can optimize the particular parser you are building immediately
00:54:31 <johnw> (hence the "optimize" and "match" split found in many regexp libraries)
00:54:44 <ReinH> I could counter that the regexp is arcane, obtuse, and far more difficult to read than it is to write
00:54:48 <kadoban> zq: Regexes tend to be the least readable or understandable part of anything they're used in. Some verbosity is generally a good idea.
00:54:48 <zq> johnw: well that's just idiosynchratic to runtime-compiled regexes
00:54:55 <ReinH> *the regexp syntax
00:55:06 <zq> kadoban: for very large expressions, yes
00:55:28 <kadoban> zq: s/very large/anything more than trivial/
00:55:52 <zq> hold on
00:56:00 <zq> i ran into this problem while writing my segmenter
00:56:03 <ReinH> The argument that regexp are *more readable* than the specification of a parser is... rather surprising.
00:56:49 <mrenaud__> kadoban: It may also be the reading from stdin, I have something akin to: do { ns <- replicate 100000 (readLn :: IO Int); print $ f $ sort ns }
00:56:52 <ReinH> I am struggling to think of a regexp that would be more readable than, say, its parsec counterpart
00:57:05 <johnw> it's impossible to determine what other people will think is readable :(
00:57:06 <ReinH> mrenaud__: step 1 determine where the slow is
00:57:11 <ReinH> step 2: try to make it less slow
00:57:17 <ReinH> mrenaud__: doing this out of order leads to poor results
00:57:29 <NikolajK> ReinH: I found the introductionary chapters to "Topoi: The categorical analysis of logic" to be the clearest exposition of category theory. Though he introduces functors very very late.
00:57:36 <ReinH> johnw: true enough
00:57:36 <platz> c.f. easy vs simple
00:57:55 <NikolajK> http://bookzz.org/book/2072887/cdd3f5
00:57:59 <mrenaud__> ReinH: I'm familiar with the falls of premature optimization, but the only two operations that I'm really doing are read from stdin, sort, then perform linear time algorithm on sorted list.
00:58:00 <ReinH> NikolajK: That requires a bit of mathematical maturity, though, doesn't it?
00:58:05 <NikolajK> no
00:58:09 <mrenaud__> Three*
00:58:17 <ReinH> mrenaud__: among the operations that I am performing...
00:58:21 <kadoban> mrenaud__: I doubt that sorting is the slowest part of that
00:58:29 <platz> regexes are familiar, but can get complicated
00:58:31 <kadoban> ReinH: XD
00:58:35 <ReinH> mrenaud__: still, it's best not to guess...
00:58:53 <ReinH> mrenaud__: GHC has some profiling tools that can be enabled
00:59:09 <ReinH> NikolajK: I'll check it out, thanks
00:59:14 <zq> ReinH: splitting on "(\s+|-{2,}|\.{2,})"
00:59:27 <ReinH> what does that even do
00:59:31 <mrenaud__> I'll look into that, I was more asking just to know if there is something more efficient :)
00:59:38 <NikolajK> ReinH: It's written for ct application in logic instead of algebra. Other than that the introductory chapters are just an introduction and a clear one at that. But again, it comes up with functors very later, so it's different than other books in that regard.
00:59:54 <zq> ReinH, johnw: the equivalent atto-/parsec is gonna be so puffier than that
01:00:16 * hackagebot fpco-api 1.2.0.2 - Simple interface to the FP Complete IDE API.  http://hackage.haskell.org/package/fpco-api-1.2.0.2 (MichaelSnoyman)
01:00:17 <ReinH> zq: brevity might be the soul of wit, but it is *not* the soul of readability
01:00:18 <kadoban> mrenaud__: More efficient is avoiding sorting when you can, hehe...but there's not really an answer for how to sort faster than Data.List.sort on lists in general, I don't think.
01:00:18 * hackagebot yesod-test 1.4.1.1 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-1.4.1.1 (MichaelSnoyman)
01:00:26 <wei2912> ReinH++
01:00:29 <wei2912> excellent point
01:00:42 <ReinH> brevity and readability are often in tension, in fact
01:00:48 <ReinH> a point that regexp makes quite nicely
01:00:52 <zq> it's not an excellent point at all because the heart of that is equivalent to saying "X sucks because I don't understand X"
01:01:36 <ReinH> So your argument is that everything is equally easy to understand?
01:01:44 <mrenaud__> kadoban: Doesn't have to be restricted to lists, I've seen IArray and IntSet, was just wondering what the recomended alternative is
01:02:19 <zq> ReinH: that's not it at all. moving on, though: how would you go about splitting a string on a pattern with, say, parsec?
01:02:32 <kadoban> mrenaud__: Well, it's going to depend a lot on what you're doing with it...which doesn't really make much sense to answer when you're just toying with stuff probably.
01:02:37 <osfameron> otoh, brevity can be more readable (map versus a c-style for loop and pushing onto a temporary array)
01:02:56 <chrisdone> i just had an idea about how to show single reduction steps for haskell (for teaching/equational reasoning)
01:03:11 <johnw> chrisdone: what?
01:03:15 <tdammers> zq: manySepBy?
01:03:15 <chrisdone> you take the module they want to run and the specific expression you want to reduce
01:03:18 <jle`> osfameron: yeah, but that's nto because of brevity
01:03:20 <zq> chrisdone: {alpha, beta, eta}-{reduction,reduction,conversion}?
01:03:35 <chrisdone> and then you do a transformation on that expression like the SimpleReflect library, but also for functions and lambdas
01:03:52 <osfameron> jle`: it's reduction of incidental complexity.  which leads to brevity (among other things)
01:03:55 <ReinH> zq: sepBy
01:03:59 <zq> tdammers: that doesn't work. consider: blob0 ++ match0 ++ match1 ++ blob1
01:04:29 <tdammers> zq: so? that'd give you [ blob0, "", blob1 ]
01:04:35 <jle`> osfameron: well yeah, the point is that brevity is a side effect, not the reason
01:04:42 <chrisdone> maybe via some HOAS conversion that retains name info. and then you just run the function but in such a way that it only peels off one step and produces new, valid code to continue with, like simple reflect
01:04:48 <zq> tdammers: uh i don't think that's what happens
01:04:54 <chrisdone> gotta try this some time. just woke up and had the idea =p
01:05:07 <tdammers> depends on your subparsers
01:05:18 <zq> tdammers: the one i just mentioned
01:05:18 <jle`> not the cause but the effect
01:05:51 <ReinH> zq: You started by arguing that regexp are "more efficient" than parsers. I suppose you've given that one up?
01:06:02 <ReinH> We could argue about readability all night without making any headway.
01:06:17 <mrenaud__> kadoban: fair enough.
01:06:44 <tdammers> zq: you'll need a bit of trickery to avoid overly greedy matches on the blobs
01:06:56 <zq> tdammers: yeah. trickery.
01:07:24 <ReinH> chrisdone: doesn't simple reflect already have something vaguely similar?
01:08:02 <zq> i actually tried going down this road with parsec while writing a project; it's doable but puffy and, as you said, requires trickery
01:08:28 * osfameron suspects that the advantage of parsers isn't readability (which is in the eye of the beholder, I quite like regexps myself) but in composability
01:08:30 <ReinH> chrisdone: https://hackage.haskell.org/package/simple-reflect-0.3.2/docs/Debug-SimpleReflect-Expr.html#v:reduction
01:08:48 <ReinH> osfameron: modularity is a big win for parser *combinators*, yes.
01:09:20 <NikolajK> ReinH: So is this a new blog where you gonna post things? Because I don't see much content
01:09:36 <ReinH> NikolajK: I post very sporadically...
01:09:37 <chrisdone> ReinH: similar to what?
01:09:46 <osfameron> that may be a historical difference, mind -- perl6's regexps are rather more like composable rules, aiui
01:09:56 <ReinH> osfameron: If you can't argue about objective things like "efficiency", try "readability" as a fallback position.
01:10:35 <ReinH> chrisdone: er... reduction of an expression? Oh, you want to do equational reasoning stuff too...
01:11:08 <ReinH> My fault for being so easily derailed, I guess.
01:11:20 <Arahael> What is '>>' called? (Especially in the monad context)
01:11:25 <ReinH> Arahael: "then"
01:11:36 <Arahael> ReinH: Sweet - thanks :)
01:11:48 <ReinH> np :)
01:11:57 <chrisdone> ReinH: no, the reduction part is what i had in mind, yeah -- but you'd have a a transformer that would also convert your lambdas into nested fun's, perhaps
01:12:18 <Arahael> ReinH: I've been looking at implementing these in C#, just to see how it works and ensure I understand the concepts.  Working nicely so far.
01:12:21 <kadoban> What's () called verbally? As in ```main :: IO ()```
01:12:31 <ReinH> kadoban: "unit"
01:12:40 <kadoban> Ah, thanks
01:12:44 <ReinH> np
01:12:52 <chrisdone> ReinH: otherwise it can only reduce the small subset of operations like + and such. but it could do any, i think
01:12:56 <Fuuzetsu> surely it's openingparanthesisfollowedbyclosingparenthesis
01:13:11 <chrisdone> > foldr (+) f [a,b,c,d]
01:13:13 <lambdabot>  a + (b + (c + (d + f)))
01:13:19 <chrisdone> ^ this knows about +, but
01:13:25 <kadoban> Hehe, I almost came down to calling it that Fuuzetsu :-/
01:13:55 <ReinH> Fuuzetsu: (foo) would also qualify
01:14:01 <chrisdone> > foldr even f [a,b,c,d]
01:14:03 <lambdabot>  Couldn't match type ‘GHC.Types.Bool’ with ‘b -> b’
01:14:03 <lambdabot>  Expected type: Debug.SimpleReflect.Expr.Expr -> b -> b
01:14:03 <lambdabot>    Actual type: Debug.SimpleReflect.Expr.Expr -> GHC.Types.Bool
01:14:06 <chrisdone> oops
01:14:23 <Fuuzetsu> ReinH: Make that ‘openingparanthesisimmediatellyfollowedbyclosingparenthesis’
01:14:29 <chrisdone> > foldr (\x y -> if even x then x else y) f [a,b,c,d]
01:14:31 <lambdabot>  f
01:14:33 <ReinH> chrisdone: I wrote an ad hoc thing for producing foldl and foldr evaluation steps once
01:14:35 <chrisdone> ^ no useful reduction
01:15:10 <ReinH> But I didn't like it because it was so ad hoc
01:15:46 <NikolajK> ReinH: >newtype Nat f g…
01:15:46 <NikolajK> great choice of name...
01:15:47 <osfameron> ReinH: I didn't mention efficiency I don't think?  Again that might be a historical difference with implementations (e.g. in Perl, the regexp engine is highly optimized, while parser combinators would have to go through Perl's relatively slugging subroutine calls)
01:16:00 <chrisdone> so my idea is you take HSE and parse the source and then transform code into
01:16:01 <chrisdone> \x -> x  =  Fun "x" (var "x")
01:16:16 <ReinH> osfameron: zq did
01:16:33 <osfameron> ok
01:16:45 <ReinH> osfameron: that was their first attempt before this readability tarpit
01:19:13 <NikolajK> ReinH: Do you know if there is a category of functors where the arrows aren't Nat or a subset of these?
01:19:50 <ReinH> NikolajK: I suppose there are trivila categories like a discrete category of functors
01:19:59 <ReinH> I'm not sure if there are any interesting ones
01:20:03 <ReinH> *trivial
01:20:29 <ReinH> Although you might look at that as a sub-category
01:20:33 <NikolajK> right, I was gonna say you can drop the arrows, or make a poset of functors by measuring cardinalities of their codomains — all these silly ideas.. I ments something in use
01:20:58 <ReinH> NikolajK: none that I'm aware of, but I'm not aware of much...
01:21:47 <NikolajK> Like, there is a category of cats and functors - but e.g. I know people also consider categories and adjunctions
01:23:02 <NikolajK> You say you only post sporadically - as far as I can see you only posted in July 3 times and that's it.
01:23:31 <ReinH> I said *very* sporadically
01:28:26 <NikolajK> I've an online notebook which sometimes reads like a blog. Here I make a case for Univalence (though I'm not actually a strong proponent - I have other problems): http://axiomsofchoice.org/univalence_axiom
01:34:30 <phischu> Hi, i am trying to register a hackage account but after clicking on "Request account" i do not receive any e-mail. Does anyone have similar problems?
01:45:35 <absence> has anyone tried the haskforce plugin for intellij? the quickstart guide refers to "Project Settings > Compiler > Haskell Compiler", but there's no compiler section in my project settings window
01:53:42 <absence> oh, never mind. things have moved around since the quickstart guide was written
01:55:39 <sbrg> It is not possible to use pattern guards in conjunction with pattern synonyms?
01:57:09 <kadoban> sbrg: Example?
01:57:24 <sbrg> kadoban: sec
01:58:23 <sbrg> kadoban: https://gist.github.com/f6b4e76936332f5a5e4c
01:58:59 <sbrg> Error is: "Right-hand side of bidirectional pattern synonym cannot be used as an expression"
02:00:15 <kadoban> sbrg: Oh, sorry I don't really know much of anything about that syntax. Someone else probably will.
02:00:49 <sbrg> no problem
02:02:46 <lpsmith> Does unpacking a ForeignPtr actually remove a layer of indirection?
02:03:20 <sbrg> Ah, the solution was to use unidrectional Pattern Synonyms.
02:03:27 <lpsmith> Or is it like unpacking an IORef/MVar,  which only removes a conditional branch?
02:05:17 * hackagebot pyfi 0.4.0.4 - Call python inline from haskell  http://hackage.haskell.org/package/pyfi-0.4.0.4 (russell91)
02:17:04 <chrisdone> back
02:17:18 <chrisdone> preflex: seen evanr
02:17:25 <chrisdone> mauke: where's preflex?
02:17:29 <chrisdone> @seen preflex
02:17:29 <lambdabot> PrEf1ex
02:19:05 <chrisdone> :t a
02:19:06 <chrisdone> :t f
02:19:06 <lambdabot> Expr
02:19:07 <lambdabot> FromExpr a => a
02:19:53 <chrisdone> hmm we need an additional Expr thing
02:19:56 <chrisdone> > f
02:19:57 <lambdabot>  No instance for (GHC.Show.Show a0)
02:19:57 <lambdabot>    arising from a use of ‘M140619657697416917512899.show_M1406196576974169175...
02:19:57 <lambdabot>  The type variable ‘a0’ is ambiguous
02:19:57 <lambdabot>  Note: there are several potential instances:
02:19:57 <lambdabot>    instance [safe] GHC.Show.Show
02:21:09 <chrisdone> you want:
02:21:49 <chrisdone> @src even
02:21:49 <lambdabot> even n = n `rem` 2 == 0
02:23:19 <chrisdone> even 1 => even 1
02:23:20 <chrisdone>        => ((\n -> n `rem` 2 == 0) 1)
02:23:20 <chrisdone>        => 1 `rem` 2 == 0
02:23:23 <chrisdone>        => 1 == 0
02:23:26 <chrisdone>        => False
02:23:37 <chrisdone> so the `even` should be expandable into a further Expr somehow …
02:24:27 <chrisdone> hmm
02:29:39 <Heather> hi
02:29:51 <chrisdone> hey heather =)
02:30:20 <Heather> chrisdone: hello
02:30:45 <chrisdone> haskelling?
02:31:50 <Heather> chrisdone: yes, in relax time :)
02:32:01 <chrisdone> =)
02:32:46 <Heather> chrisdone: why ghci fails on `:t E` if I declare E as `data E = A C;;`
02:33:39 <chrisdone> :t works for values only, E is only a type
02:33:40 <lambdabot> parse error on input ‘,’
02:33:43 <chrisdone> you can use :i E
02:33:48 <chrisdone> to get info about the type E =)
02:33:55 <chrisdone> orrr :t A
02:34:17 <chrisdone> for the value A
02:34:20 <Heather> chrisdone: ah, thanks
02:34:42 <Heather> christians how to match pattern of such type?
02:35:02 <Heather> chrisdone: if I've got foo :: E -> IO()
02:35:08 <chrisdone> @let data E = A C
02:35:09 <lambdabot>  .L.hs:155:12: Not in scope: type constructor or class ‘C’
02:35:12 <chrisdone> ah, uh
02:35:14 <chrisdone> @let data E = A ()
02:35:16 <lambdabot>  Defined.
02:35:23 <chrisdone> > case A () of A () -> "Yay"
02:35:25 <lambdabot>  "Yay"
02:35:32 <chrisdone> ^ you can use a case like that
02:35:51 <Heather> just like two arguments?
02:36:06 <chrisdone> > let foo (A ()) = "yay" in foo (A ())
02:36:07 <lambdabot>  "yay"
02:36:20 <chrisdone> in case, yeah, you just put spaces
02:36:31 <chrisdone> @undef E
02:36:31 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
02:36:35 <chrisdone> oh
02:36:36 <chrisdone> @undefine
02:36:36 <lambdabot> Undefined.
02:36:46 <jle`> goodbye L.hs
02:36:47 <chrisdone> @let data E = Cons1 Int | Cons2 String
02:36:48 <lambdabot>  Defined.
02:37:03 <chrisdone> then you can write
02:37:40 <chrisdone> @let f e = case e of Cons1 i -> "An int: " ++ show i; Cons2 str -> str
02:37:41 <lambdabot>  Defined.
02:37:47 <chrisdone> > f (Cons1 123)
02:37:48 <lambdabot>  Ambiguous occurrence ‘f’
02:37:48 <lambdabot>  It could refer to either ‘L.f’, defined at L.hs:158:1
02:37:48 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.f’,
02:37:48 <lambdabot>                           imported from ‘Debug.SimpleReflect’ at L.hs:118:1-26
02:37:48 <lambdabot>                           (and originally defined in ‘simple-reflect-0.3.2:De...
02:37:52 <chrisdone> bahhh =p
02:37:55 <chrisdone> @let myfun e = case e of Cons1 i -> "An int: " ++ show i; Cons2 str -> str
02:37:56 <lambdabot>  Defined.
02:38:00 <chrisdone> > myfun (Cons1 123)
02:38:02 <lambdabot>  "An int: 123"
02:38:09 <chrisdone> > myfun (Cons2 "=)")
02:38:10 <lambdabot>  "=)"
02:38:53 <Tordek> hi
02:39:01 <chrisdone> hey
02:39:04 <Tordek> if I do: main = foldl
02:39:12 <Tordek> oops premature enter
02:39:27 <Heather> chrisdone: so ot
02:39:58 <Tordek> if I do: main = foldl' (+) 0 [1..100000000], even with -O2, it takes a very long time because it generates the list while it folds it
02:40:46 <Tordek> I can do an explicit accumulator a la sum 0 a = a; sum n a = sum (n-1) (a+n), and the time goes down enormously (from 10s to 0.6)
02:41:10 <MP2E> Lists are slow for number crunching :)
02:41:11 <Tordek> is there a way to optimize the former without being so explicit as to the way to calculate?
02:41:19 <jle`> out of curiousity, how does `sum [1..100000etc]` perform?
02:41:25 <MP2E> generally they aren't recommended for performance intensive things
02:41:32 <Heather> chrisdone: so type passed to fun is one of two, not both
02:41:34 <Tordek> jle`: good question, lemme see
02:41:53 <MP2E> I'd try the bytestring library as a comparison too :P
02:42:09 <chrisdone> Heather: example?
02:42:16 <MP2E> I remember converting a prime number summer that summed all primes up to 2 million and using bytestring sped it up 12x
02:42:20 <Tordek> jle`: memory hoggingly
02:42:27 <jle`> hm
02:43:18 <Heather> christians I'm trying to understand optparse argument parsing : https://github.com/pcapriotti/optparse-applicative/blob/master/tests/Examples/Cabal.hs#L13
02:43:23 <Heather> chrisdone: ^
02:43:46 <Tordek> MP2E: hmm, I've never used BS, let's see
02:43:53 <Heather> chrisdone: so there Args are arguments and commands both...
02:44:07 <Heather> chrisdone: and I've got run :: Args -> IO ()
02:44:31 <Heather> chrisdone: so I want to guard / match only one command there
02:45:16 <Heather> chrisdone: like here in another example: https://github.com/pcapriotti/optparse-applicative/blob/master/tests/Examples/Commands.hs#L31
02:45:32 <Heather> chrisdone: the only difference is Args including two types
02:47:10 <Heather> chrisdone: I even failed in descripting problem for myself ) it's not data E = A B, it's data E = E A B
02:48:12 <Heather> chrisdone: and for that type :t will work...
02:49:03 <nshepperd> eh, shouldn't foldl' (+) 0 [1..n] be fused?
02:50:18 <osa1> any reasons why dist directory has to be created when using a sandbox?
02:50:59 <johnw> the sandbox is where things are installed
02:51:04 <johnw> 'dist/' is where they get built
02:51:32 <johnw> "cabal copy" is what moves things from dist into the install dirs
02:52:32 <Guest346> @pl fromAnyOf' mailList = (\email -> sender	email `elem` mailList)
02:52:32 <lambdabot> fromAnyOf' = flip (elem . sender)
02:52:37 <tdammers> zq: "trickery" is relative... you do win a lot of other highly desirable things
02:52:49 <tdammers> compile-time guarantees, composability, etc
02:53:03 <chrisdone> Heather: sorry, was distracted…
02:53:36 <Heather> chrisdone: so in nutshell I mistaken and it's data E = E A C
02:53:53 <Heather> chrisdone: and I've got foo :: E -> IO ()
02:54:08 <Heather> chrisdone: and I want to match A and C types there
02:55:21 <chrisdone> so then: data E = E A C; data A = A String; data C = C string
02:55:21 <chrisdone> yuo can write: f (E (A str) (C str)) = …
02:56:06 <chrisdone> or f x = case x of E (A str) (C str) -> …
02:56:10 <chrisdone> (they are the same)
02:56:14 <Tordek> uh, ok, I'm doubting my sanity now... somehow, my code used to work correctly and extremely fast... but now that I've read the code, it shouldn't have... because I was doing `sumto' n a = sumto' (n - 1) (a + n)`, which, due to laziness, would still just blow up in memory
02:56:34 <Tordek> and now that's the behavior I'm seeing...
02:57:46 <Heather> chrisdone: seems like run (Args(_)(_)) = sync works :D
02:57:56 <chrisdone> yeah
02:58:00 <Heather> chrisdone: never saw such syntax before, thank you
02:58:16 <chrisdone> run (Args opts Install) = …
02:58:16 <chrisdone> run (Args opts Update) = …
02:58:25 <Fuuzetsu> http://www.google.com/trends/explore#q=dependent%20types%2C%20type%20theory&cmpt=q what's with these trends ;P Students looking material up at start of the year but not doing searches during summer and Christmas?
02:58:36 <chrisdone> or
02:58:37 <chrisdone> run (Args opts cmd) = case cmd of
02:58:37 <chrisdone>   Install -> …
02:58:37 <chrisdone>   Update -> …
02:58:57 <chrisdone> oh, well, Install has more arguments. so it would be "Install copts iopts" or w/e
02:59:32 <Heather> :t opts
02:59:33 <lambdabot> Not in scope: ‘opts’
03:00:05 <Heather> oh )
03:00:06 <chrisdone> opts is a free variable in the pattern
03:00:06 <Heather> got it
03:00:11 <chrisdone> ))
03:00:17 * hackagebot nats-queue 0.1.0.1 - Haskell API for NATS messaging system  http://hackage.haskell.org/package/nats-queue-0.1.0.1 (ondrap)
03:00:20 <Heather> chrisdone: yes its same w/o brackets
03:01:23 <Heather> chrisdone: I think I even knew it before but forgot :D
03:01:53 <Tordek> ok, `ghc` is not deterministic or what? I compile the same exact code and randomly I get code that runs in 0.65s with barely any memory usage, and other times I have to kill the process because it hogs all of my ram
03:03:25 <kadoban> Tordek: That doesn't sound like it makes much sense. I've certainly never noticed anything like that happening.
03:03:52 <Tordek> kadoban: it really doesn't, that's why I'm so confused
03:10:07 <Tordek> https://gist.github.com/Tordek/b75a18de20ef75a8851d this is the source; I've alternated using either of the main functions, and using Int and Int64
03:10:53 <Tordek> sometimes it runs in 0.65s, sometimes it just blows up my memory usage; no clear pattern (ie, sometimes I'm using sumto and Int, and it'll blow up; other times it won't)
03:12:29 <Tordek> (blowing up the memory _should_ be the correct behavior due to laziness not evaluating (n-1) and (a+n) immediately
03:14:03 <kadoban> Tordek: It probably just depneds on what GHC figures out it can optimize. I'm really not familiar with what would make it do that or not... Probably not worth worrying about too much though, right? Just fix it and move on I'd say...
03:15:06 <kadoban> Tordek: In other words, it's probably free to optimize away the error, but not required to, so...not much of a mystery that it sometimes does and sometimes doesn't, depending on what changes you make.
03:16:13 <Tordek> kadoban: but that's kind of the thing. If, say, it always optimized when using :: Int, and not when using ::Int64, then OK, it's finding an optimization
03:16:29 <Tordek> however, with the same code it sometimes does it and sometimes not?
03:17:20 <kadoban> Tordek: I would suggest that that's probably not true. Maybe you're confusing yourself with what version is currently compiled/built? Seems like the most likely explanation.
03:17:27 <nshepperd> Tordek: make sure to recompile with -fforce-recomp
03:17:42 <nshepperd> Tordek: otherwise ghc mght not actually recompile the code when you change flags
03:18:15 <nshepperd> I noticed this when messing around with your code snippet, trying it with various -O flags
03:20:17 * hackagebot air 2014.11.17 - air  http://hackage.haskell.org/package/air-2014.11.17 (JinjingWang)
03:20:19 * hackagebot air-th 2014.11.17 - air  http://hackage.haskell.org/package/air-th-2014.11.17 (JinjingWang)
03:20:21 * hackagebot hack2 2014.11.17 - a Haskell Webserver Interface (V2)  http://hackage.haskell.org/package/hack2-2014.11.17 (JinjingWang)
03:20:23 * hackagebot hack2-contrib 2014.11.17 - Hack2 contrib  http://hackage.haskell.org/package/hack2-contrib-2014.11.17 (JinjingWang)
03:20:25 * hackagebot hasql-postgres 0.6.0 - A "PostgreSQL" backend for the "hasql" library  http://hackage.haskell.org/package/hasql-postgres-0.6.0 (NikitaVolkov)
03:21:37 <nshepperd> sumto' (10000000 :: Int) reliably takes about 2.7 seconds for with with -O0
03:21:54 <nshepperd> and 0.004 seconds for me with -O
03:22:25 <kristian_> :t []
03:22:25 <shakira32> hello
03:22:26 <lambdabot> [t]
03:22:43 <Heather> what is common way to import files from dist/build/autogen/ ?
03:22:58 <Heather> is it sane to use them during build process
03:23:00 <Tordek> nshepperd: seems to have been that, indeed; apparently -O2 does the strictness optimization, but -O0 doesn't, and it wasn't recompiling with O2 after -O0
03:23:09 <kadoban> Ahh
03:23:24 <MP2E> aha! good to hear
03:23:50 <Tordek> I guess doing the ... = a `seq` ... is the safe way to force strictness?
03:24:31 <sbrg> Haskell.org down? it's timing out and cloudfare is taking over
03:24:32 <nshepperd> I think it's easiest to use BangPatterns and write "sumto' !n !a ... = ..."
03:24:43 <kadoban> Tordek: Bang patterns are cute, but yeah you can use seq if you want.
03:24:58 <shakira32> moviespornxxx.tk
03:25:18 <Tordek> do I have to enable something to use bang patterns? I tried to use them before seq
03:25:27 * hackagebot hack2-handler-snap-server 2014.11.17 - Hack2 Snap server handler  http://hackage.haskell.org/package/hack2-handler-snap-server-2014.11.17 (JinjingWang)
03:25:29 * hackagebot miku 2014.11.17 - A minimum web dev DSL in Haskell  http://hackage.haskell.org/package/miku-2014.11.17 (JinjingWang)
03:25:47 <nshepperd> {-# LANGUAGE BangPatterns #-} at the top of your source
03:25:54 <supki_> Heather: what files exactly?
03:26:14 <nshepperd> it's just syntactic sugar, so it should be safe to enable that extension
03:27:57 <mrsElectron>  the heck does union do?
03:28:11 <mrsElectron> it makes no sense
03:28:23 <kadoban> mrsElectron: union?
03:28:53 <shiona> > union [1,2,3] [1,3,5]
03:28:54 <kadoban> Oh sorry, I was in C++ mode for a second, heh...disregard that
03:28:55 <lambdabot>  [1,2,3,5]
03:29:03 <mrsElectron> > union [1,2,2] [2,2,1]
03:29:05 <lambdabot>  [1,2,2]
03:29:24 <kadoban> mrsElectron: It's treating lists as sets, I believe.
03:29:48 <mrsElectron> > union [1,2,3] [3,2,1,0]
03:29:50 <lambdabot>  [1,2,3,0]
03:30:44 <mrsElectron> > union [1,2,3] [3,2,1,0,2]
03:30:46 <lambdabot>  [1,2,3,0]
03:30:54 <mrsElectron> > union [1,2,2,3] [3,2,1,0]
03:30:55 <lambdabot>  [1,2,2,3,0]
03:30:56 <kadoban> mrsElectron: So it's just set union...but if you're using it more than tangentially you should probably just use an actual set data structure I'd think.
03:31:30 <dv-> :t S.union
03:31:30 <lambdabot> Ord a => S.Set a -> S.Set a -> S.Set a
03:31:32 <Heather> supki_: version
03:31:35 <mrsElectron> see the last two inputs I made to the bot. Two 2 in the latter case but not the first: makes no sense
03:31:57 <shiona> kadoban: it is not
03:32:13 <dv-> mrsElectron: i think union assumes that the elements in the list only appear once
03:32:15 <shiona> doc says it removes duplicates from the second list, but not the first one
03:32:30 <kadoban> shiona: It's not? The docs put it under "Set" operations.
03:32:36 <mrsElectron> dv-: if it assumes that, why are there two 2 in the latter case?
03:32:44 <mrsElectron> shiona: k thanks
03:32:44 <shiona> kadoban: there is union for set, but also for list
03:33:01 <supki_> Heather: you can just import Paths_$packagename and cabal should pick it up when building the project
03:33:03 <shiona> http://hackage.haskell.org/package/base-4.7.0.1/docs/src/Data-List.html#union just a few lines up are some clarifying comments
03:33:08 <kadoban> shiona: I don't understand your point.
03:33:09 <nshepperd> union a b = a ++ (b with all elements of a deleted)
03:33:13 <nshepperd> I would guess
03:33:51 <mrsElectron> nshepperd: that seems to make sense, given tests
03:33:57 <shiona> nshepperd: almost, b is also nub'd
03:34:07 <shiona> union [1] [2,2]
03:34:10 <shiona> > union [1] [2,2]
03:34:12 <lambdabot>  [1,2]
03:34:15 <nshepperd> ah
03:34:29 <nshepperd> so 'union a b = a ++ (nub b \\ a)'
03:34:50 <mrsElectron> really, what's up with that?
03:34:53 <shiona> that sounds correct to me, but I'm no expert
03:35:13 <nshepperd> but anyway, doing set operations on lists strikes me as weird anyway
03:35:18 <kadoban> mrsElectron: In short, it's not something you should probably use, pretty much ever.
03:35:32 <nshepperd> when you can just use Data.Set
03:35:56 <Heather> supki_: so no additional tricks for it, cool!
03:35:57 <sbrg> nshepperd: it's just xs ++ (ys \\ xs)
03:36:34 <kadoban> shiona: Oh, as to the above...I wasn't talking about the one from Data.Set. In the docs for Data.List.union, it's under "Set" operations. It's for treating lists as a set data structure.
03:36:53 <sbrg> @check (\xs ys -> xs ++ (ys \\ xs)) == union xs ys
03:36:54 <lambdabot>  Not in scope: ‘xs’
03:36:54 <lambdabot>  Perhaps you meant one of these: ‘x’ (imported from Debug.SimpleReflect), ‘s’...
03:37:06 <sbrg> eh
03:37:24 <sbrg> @check \xs ys -> xs ++ (ys \\ xs)  == union xs ys
03:37:26 <lambdabot>  *** Failed! Falsifiable (after 7 tests and 3 shrinks):
03:37:26 <lambdabot>  [] [(),()]
03:37:46 <nshepperd> \\ doesn't nub the thing being deleted from
03:38:07 <sbrg> @src (\\)
03:38:07 <lambdabot> (\\) = foldl (flip delete)
03:38:11 <sbrg> @src delete
03:38:11 <lambdabot> delete = deleteBy (==)
03:38:24 <sbrg> @src union
03:38:24 <lambdabot> union = unionBy (==)
03:38:28 <sbrg> @src unionBy
03:38:28 <lambdabot> unionBy eq xs ys = xs ++ foldl (flip (deleteBy eq)) (nubBy eq ys) xs
03:38:33 <sbrg> huh.
03:38:47 <sbrg> you're right.
03:39:03 <nshepperd> @check (\xs ys -> xs ++ (nub ys \\ xs) == union xs ys) :: [Int] -> [Int] -> Bool
03:39:05 <lambdabot>  +++ OK, passed 100 tests.
03:40:17 * hackagebot moe 2014.11.17 - html with style  http://hackage.haskell.org/package/moe-2014.11.17 (JinjingWang)
03:40:19 * hackagebot bindings-saga-cmd 0.1.0.0 - Wrapping saga_cmd  http://hackage.haskell.org/package/bindings-saga-cmd-0.1.0.0 (michelk)
03:40:34 <exio4> that sounds a bit expensive
03:41:17 <nshepperd> I guess it would be okay to use lists as a kind of set if they're less than about 10 elements
03:41:33 <mrsElectron> what is \x in haskell?
03:41:39 <nshepperd> the constant factor speedup
03:41:45 <mrsElectron> (\x -> () )
03:41:50 <BoR0> mrsElectron, lambda abstraction
03:41:57 <mrsElectron> oh snap.. the heck is that?
03:42:00 <exio4> an anonymous function
03:42:08 <mrsElectron> hokay
03:42:09 <jeltsch> @fix error
03:42:09 <lambdabot> Maybe you meant: thx id faq bid
03:42:19 <exio4> > (\x → x+2) 4
03:42:21 <lambdabot>  6
03:42:25 <exio4> > (\x → x*2) 4
03:42:26 <BoR0> (\x y z -> x + y + z) is a function that takes three inputs and returns their sum
03:42:27 <lambdabot>  8
03:42:36 <jeltsch> > fix error
03:42:37 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
03:42:48 <mrsElectron> I seem thanks
03:44:00 <Tordek> hmm, even when forcing strict evaluation of a and n, it still takes a _very_ long time (on the order of 100 times longer) if I don't use -O2
03:44:22 <Tordek> it also does loads of allocations
03:44:56 <kadoban> Tordek: With what exact code?
03:45:30 <Tordek> https://gist.github.com/Tordek/b75a18de20ef75a8851d
03:45:48 <Tordek> no -O2:    1,840,068,464 bytes allocated in the heap
03:45:55 <Tordek> -O2           67,872 bytes allocated in the heap
03:46:18 <mrsElectron> (succ . (\x -> 1))
03:46:20 <mrsElectron> > (succ . (\x -> 1))
03:46:21 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
03:46:21 <lambdabot>    arising from a use of ‘M318065150331726546214487.show_M3180651503317265462...
03:46:21 <lambdabot>  The type variable ‘a0’ is ambiguous
03:46:21 <lambdabot>  Note: there are several potential instances:
03:46:21 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
03:46:33 <mrsElectron> > ( (\x -> 1) . succ)
03:46:34 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
03:46:35 <lambdabot>    arising from a use of ‘M167720157822057894214499.show_M1677201578220578942...
03:46:35 <lambdabot>  The type variable ‘b0’ is ambiguous
03:46:35 <lambdabot>  Note: there are several potential instances:
03:46:35 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
03:46:47 <nshepperd> Tordek: there's a lot of boxing/unboxing of values with -O0
03:47:24 <BoR0> > (succ . (\x -> 1)) 123
03:47:25 <lambdabot>  2
03:47:35 <sbrg> Out of curiosity, would: sumto' !(n - 1) !(a + n) make a difference, if it is even valid?
03:48:12 <mrsElectron> BoR0: ty. In what order are they performed? Succ first, then that thing after ., or  first that (\x->1) then succ?
03:48:20 <mrsElectron> >"a"
03:48:28 <BoR0> @src (.)
03:48:28 <lambdabot> (f . g) x = f (g x)
03:48:42 <BoR0> I assume laziness would perform g first, which in this case is (\x -> 1)
03:49:06 <exio4> wouldn't it be the opposite?
03:49:23 <BoR0> to perform f, you must first know g x, no?
03:49:29 <nshepperd> and calling 'fromInteger 0' every loop cycle...
03:49:30 <wei2912> laziness? wouldn't it be due to precendence?
03:50:08 <Tordek> BoR0: due to laziness, you attempt to execute the outermost function first; when it requires evaluating its arguments, it does so
03:50:28 <BoR0> right
03:50:28 <wei2912> Tordek++
03:51:35 <mrsElectron> > (\x ->) . succ 1
03:51:36 <nshepperd> but with -O2, the whole recursive function gets compiled into a C-like loop with 7 asm instructions
03:51:37 <lambdabot>  <hint>:1:7: parse error on input ‘)’
03:51:40 <mrsElectron> > (\x ->x) . succ 1
03:51:41 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
03:51:41 <lambdabot>    arising from a use of ‘M320236141187585087214605.show_M3202361411875850872...
03:51:41 <lambdabot>  The type variable ‘a0’ is ambiguous
03:51:41 <lambdabot>  Note: there are several potential instances:
03:51:41 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
03:51:44 <nshepperd> ghc sure is amazing
03:51:54 <Tordek> nshepperd: was that RE -O0? :t sumto' (n::Int) is Int -> Int, so the 0 would be an Int since the start, right?
03:52:11 <mrsElectron> > (\x ->x) . succ 1 5
03:52:12 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> a -> c))
03:52:12 <lambdabot>    arising from the ambiguity check for ‘e_115’
03:52:12 <lambdabot>  from the context (GHC.Num.Num (a1 -> a -> c),
03:52:12 <lambdabot>                    GHC.Num.Num a1,
03:52:12 <lambdabot>                    GHC.Enum.Enum (a1 -> a -> c))
03:52:24 <mrsElectron> > ((\x ->x) . (succ 1)) 5
03:52:25 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> c))
03:52:25 <lambdabot>    arising from the ambiguity check for ‘e_115’
03:52:25 <lambdabot>  from the context (GHC.Num.Num (a -> c),
03:52:25 <lambdabot>                    GHC.Num.Num a,
03:52:25 <lambdabot>                    GHC.Enum.Enum (a -> c))
03:53:21 <nshepperd> Tordek: I think under the hood, numerical constants in your source code are compiled in as Integers, and converted to the relevant type with fromInteger
03:53:23 <mrsElectron> what sense does it make to (\x -> something) . sort ?  Where is X inputted?
03:55:31 <kadoban> mrsElectron: (\x -> something) is just a function. It's the same as...    f x = something, except you're not naming it, just using it.
03:55:48 <kadoban> mrsElectron: So the input comes from calling the function, which (.) eventually does
03:56:42 <nshepperd> Tordek: I think specializing the function for (n::Int) (and therefore building in a 0::Int instead of 0::Integer) would be one of the optimisations disabled at -O0
03:57:09 <mrsElectron> kadoban: won't . just mean that what the output of what comes after . is used as input in the function?
03:57:25 <mrsElectron> > (\x -> x) . (succ 1)
03:57:26 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
03:57:26 <lambdabot>    arising from a use of ‘M266825459460762711714725.show_M2668254594607627117...
03:57:26 <lambdabot>  The type variable ‘a0’ is ambiguous
03:57:26 <lambdabot>  Note: there are several potential instances:
03:57:26 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
03:57:29 <kadoban> :t (.)
03:57:30 <lambdabot> (b -> c) -> (a -> b) -> a -> c
03:57:31 <mrsElectron> should return 2, but doesn't
03:57:46 <kadoban> mrsElectron: That doesn't return anything, it's not valid.
03:57:55 <nshepperd> (succ 1) isn't a function, it's a number
03:58:08 <nshepperd> > ((\x -> x) . succ) 1
03:58:09 <lambdabot>  2
03:59:12 <Tordek> nshepperd: :/ I expected declaring sumto' :: Int64 -> ... would have an effect, but it didn't
04:00:09 <nshepperd> Tordek: really? I added "sumto' :: Int -> Int -> Int" and it cut down the running time by 2/5
04:00:17 <nshepperd> Tordek: and eliminated the fromInteger call
04:00:21 <exio4> I don't know why the code being ultra-fast in -O2 which basically performs optimization that make the code faster than -O0 where it "naively compiles" code is that weird?
04:01:00 <mrsElectron> > (\x -> x) 1
04:01:02 <lambdabot>  1
04:01:19 <mrsElectron> > (\x -> x) . succ 1
04:01:20 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
04:01:20 <lambdabot>    arising from a use of ‘M426221874710957418014820.show_M4262218747109574180...
04:01:20 <lambdabot>  The type variable ‘a0’ is ambiguous
04:01:20 <lambdabot>  Note: there are several potential instances:
04:01:20 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
04:01:23 <mrsElectron> > ((\x -> x) . succ) 1
04:01:24 <lambdabot>  2
04:01:26 <mrsElectron> k, I get it now, thanks :p
04:01:29 <Tordek> nshepperd: I used Int64; it does improve slightl with Int, as you say
04:01:41 <mrsElectron> > ((\x -> succ x) . succ) 1
04:01:43 <lambdabot>  3
04:03:30 <Tordek> exio4: haha it's not weird; but since I hear so many complaints of "haskell is slow" from naysayers, I'd like to understand what's going on and how to optimize stuff without completely relying on -O2
04:04:22 <dramforever> hmm...I feel that -O2 is quite important and useful
04:05:17 <kadoban> Tordek: Well, any serious optimizations are going to require sometihng more than -O0 I'd think. Haskell is a high level language, so it's not like you can manually optimize stuff away, unless you get down to writing in Core or something.
04:05:28 <nshepperd> anyway, I think the only thing really worth worrying about is getting the right strictness annotations
04:05:33 <exio4> I do not think inlining function and doing list fusion by hand are things that nice to do
04:05:34 <nshepperd> and type signatures
04:05:41 <nshepperd> if you need blazing speed
04:05:57 <dramforever> I think that if you really need speed, go down and write important parts in C
04:06:19 <exio4> or ugly Haskell code that is basically what you would do in C but inside the IO monad
04:06:30 <sbrg> not necessarily, but sure, sometimes
04:06:40 <sbrg> Tordek: but you may want to read a few articles on reading core, in that case
04:06:49 <kadoban> dramforever: As a general rule, that's probably at least premature. Might as well exhaust easier/safer opportunities first.
04:07:15 <dramforever> kadoban: well, you saw that I meant if you *really* need speed
04:07:57 <Tordek> dramforever: well, I just did this thing to see how close I could get to C speed without actually going to C
04:08:10 <Tordek> and I get nearlythe exact same runtime
04:08:16 <dramforever> actually haskell could be faster
04:08:20 <kadoban> dramforever: Well, stating that in a useful way seems like it needs lots of caveats that I don't see attached :)
04:08:25 <dramforever> but that would require even uglier code
04:08:46 <Tordek> I did read that "wc in Haskell" presentation that shows a faster wc in haskell than C
04:08:51 <kadoban> Like, if you really need the speed, and you've tried everything else, and you've profiled and found out which parts are slow and found out that it actually matters...
04:09:06 <dramforever> kadoban: yep
04:09:31 <nshepperd> Tordek: heh, if you look at ghc-core, with -O2 it gets reduced to pretty much the smallest possible asm loop
04:10:13 <kadoban> Pedantic I know, but...you see a lot of people skip all of those steps and caveats and just go "Well, this needs to be fast, better write it in C!" When their idea of needs to be fast is like...a GUI which spends all its time waiting on the user anyway.
04:10:13 <dramforever> Tordek: could it be because wc isn't heavily optimized?
04:10:15 <nshepperd> testq, jl, addq, decq, jmp
04:10:27 <nshepperd> I doubt C could do better than that
04:10:33 <Tordek> nshepperd: I'm looking at the core, too bad I have no clue how to read it (err, that's the one generated with -fext-core, right?)
04:11:18 <nshepperd> Tordek: oh, the ghc-core utility (cabal install ghc-core) displays the generated asm with syntax highlighting as well
04:11:22 <Tordek> dramforever: I don't remember the details; but I doubt that `wc` isn't well optimized
04:11:22 <dramforever> kadoban: well, I got a 20x speedup by mutating rather than rebuilding, and in C
04:11:30 <nshepperd> I'm not sure how to do that with a plain ghc flag
04:12:11 <dramforever> kadoban: It's amazing how easy the ffi is
04:12:39 <dramforever> no pain at all
04:12:47 <kadoban> dramforever: Sure, but you're still writing C at that point, with all of the Fun of that.
04:13:05 <nshepperd> Tordek: ah, ghc -ddump-asm is the direct way
04:14:03 <dramforever> kadoban: actually I was a bit frightened when I saw that it was so fast
04:14:14 <dramforever> I thought it didn't do the work
04:14:22 <Tordek> nshepperd: -S, too, generates a .s file; but ghc-core's coloring is purdy
04:15:09 <kadoban> dramforever: Haha, that's a nice sign.
04:16:47 <kadoban> ghc-core sounds kinda neat, I'll have to look at that sometime.
04:18:28 <dramforever> hmm...why reinstalls are dangerous?
04:19:21 <kadoban> dramforever: I think because A could be depending on B, then you reinstall a different version of B, or B with different options.
04:19:41 <dramforever> actually, whenever I install lens and after some time I end up reinstalling one of it's dependency
04:19:48 <dramforever> well, more than one
04:20:51 <dramforever> and I can't even uninstall it with cabal! all I can do is ghc-pkg unregister
04:21:05 <sbrg> Anyone know if it's possible to use view patterns(and possibly combine them with pattern synonyms) to match on something like: LessThan a b -- which would only match if a is less than b?
04:21:40 <sbrg> basically something like: pattern LessThan a b <- (compare a b -> LT)
04:22:15 <mauke> sbrg: yeah, that looks good
04:22:29 <mauke> or (a < b -> True)
04:22:34 <sbrg> hmm, well
04:23:30 <dramforever> but that's not how it works
04:23:44 <dramforever> where are we supposed to get *two* values?
04:23:46 <Tordek> I'm out; thank you all for your help!
04:25:38 <sbrg> mauke: That does not seem to work. It tells me neither a nor b are in scope
04:25:50 <dramforever> sbrg: yep, see this:
04:25:55 <mauke> aww :-(
04:26:01 <dramforever> > let f ( (+1) -> x ) = x in f 2
04:26:03 <lambdabot>  3
04:26:34 <sbrg> dramforever: heh, nifty
04:26:42 <dramforever> so the one before is a function that takes one arg, which is the thing to pattern match on
04:26:46 <dramforever> hmm...
04:26:56 <dramforever> > let ((+1) -> x) = 1 in x
04:26:58 <lambdabot>  2
04:27:28 <sbrg> wait..
04:27:30 <sbrg> that was ..
04:27:32 <sbrg> huh.
04:27:36 <dramforever> oops, "before is" -> "before -> is"
04:28:31 <sbrg> At any rate, I wanted to do some fancy pattern matching stuff to do a search through a binary tree
04:29:45 <sbrg> now that I think a bit harder on it I'm not it makes sense for it to be possible
04:30:02 <sbrg> or well
04:30:17 * hackagebot gl 0.6 - Complete OpenGL raw bindings  http://hackage.haskell.org/package/gl-0.6 (EdwardKmett)
04:30:57 <sbrg> it would have to be something like .. let a = 3 in ... | LessThan a b <- returns_b = ..
04:35:59 <ski> sbrg : what would be the type of the pattern `LessThan a b' ?
04:37:29 <sbrg> ski: Yeah, I don't know. I don't think it makes sense. I was just playing around with pattern synonyms and view patterns, trying to do some fancy stuff.
04:43:48 <chrisdone> i wonder whether you could make a nice Eq pattern
04:44:10 <chrisdone> to avoid guards
04:49:55 <chrisdone> benmachine: idea: implement stepeval as a basic expand/reduce, but anything not accessible in source modules, it stops expanding further. even (+) or foldl
04:50:17 * hackagebot cf 0.1 - Infinite precision arithmetic using continued fractions  http://hackage.haskell.org/package/cf-0.1 (mvr)
04:50:19 <ski> > let eq a ((a ==) -> True) = True; eq _ _ = False in zipWith eq [0,0,1,1] [0,1,0,1]  -- chrisdone, i suppose there's this ..
04:50:20 <lambdabot>  [True,False,False,True]
04:50:21 <chrisdone> benmachine: then, if you want foldl to be expandable, you have to import Prelude hiding (foldl) and define your own
04:50:49 <ski> chrisdone : also evaluating under lambda ?
04:52:12 <chrisdone> benmachine: and for anything else, e.g. (+) you actually use the GHC API to compile via dynCompileExpr "(+) :: Int -> Int -> Int", and you get the concrete types from the GHC API too. these external functions can be considered opaque. but it means it might work for basically any library you don't care to re-implement
04:53:15 <chrisdone> ski: that's ok…
04:54:46 <chrisdone> ski: evaluating under lambda?
04:57:42 <chrisdone> actually wait
04:57:47 <chrisdone> no need for dynCompileExpr
04:57:54 <chrisdone> as every stage of stepeval should be printable
04:58:02 <chrisdone> so you'd just run in ghci "1 + 2" or w/e
04:58:25 <chrisdone> yeahhhh
05:02:36 <chrisdone> i guess you still have the problem of strictness, though
05:02:54 <chrisdone> blast
05:07:12 <ski> chrisdone : hmm ?
05:11:21 <chrisdone> ski: i mean passing something to ghci is fine if the function is strict, but passing "<expr1> : <expr2>" where expr1 e.g. contains functions that are unprintable and unparseable breaks things
05:11:27 <chrisdone> > id : repeat id
05:11:29 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
05:11:29 <lambdabot>    arising from a use of ‘M376661802578426300515945.show_M3766618025784263005...
05:11:29 <lambdabot>  The type variable ‘a0’ is ambiguous
05:11:29 <lambdabot>  Note: there are several potential instances:
05:11:29 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
05:12:39 <chrisdone> same goes for the dynCompileExpr. darn
05:13:15 <chrisdone> looks like this kind of stepping is pervasive
05:16:14 <ski> chrisdone : could you use something like `:print' at <https://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html> .. or did i misunderstand what you're wanting to do ?
05:17:22 <Fuuzetsu> http://afp.sourceforge.net/entries/Show.shtml it's over, now even other languages think Show is for pretty printing ;(
05:23:55 <shiona> any idea why paste.hskll.org returns 502 Bad Gateway?
05:27:20 <trap_exit> are there any good 17" laptops left these days, given that the 17" mbp no longer exists
05:27:49 <winobes> does anyone know what might cause a haskell program to hang when its terminal looses focus?
05:28:20 <kadoban> Loses focus? Uhm, that sounds pretty unbelievable.
05:28:37 <winobes> yeah i am totally at a loss
05:28:51 <kadoban> It runs totally fine otherwise?
05:28:52 <ClaudiusMaximus> shiona: don't know, but it's down here too
05:28:58 <trap_exit> probably something related to IO and laziness
05:29:01 <winobes> i'm processing some lines of a file and if i switch to another window for too long it just hangs
05:29:13 <trap_exit> lol
05:29:20 <trap_exit> I think your haskell program is just needy and wants your attention
05:29:23 <winobes> yeah otherwise it's doing what i expect -- and when i switch back to the window and click around it starts up again
05:29:26 <trap_exit> why do you not spend more time with your haskell code ?
05:29:34 <winobes> lol yes it feels like a needy child
05:29:53 <kadoban> winobes: What terminal program? Is it doing something weird possibly?
05:29:53 <trap_exit> can you stick it in a VM so it feels like it's getting all the attention it needs?
05:31:48 <winobes> kadoban: i'm using gnome terminal in the xmonad window manager if that matters
05:33:02 <kadoban> Hmm, yeah...I'm not sure where to start with that one. Maybe check for /anything/ else that's different when you're working in other windows?
05:33:03 <clrnd> winobes, does the haskell program read anything from stdin?
05:33:51 <winobes> clrnd: it gets the filename with getArgs at the begininng but that's it
05:34:32 <clrnd> winobes, and how do you know it "hangs"
05:35:18 <winobes> clrnd: ah two reasons: 1. because it prints the line number it's currently working on and that stops going up
05:35:27 <kadoban> Oh if nothing else, maybe try profiling it with and without losing focus, try to see what the hell it's doing when it's hung?
05:35:34 <winobes> and 2. because the cpu activity drops down nothing
05:36:23 <winobes> kadaban good idea... i should learn how to do that in haskell at some point anyway... heh
05:36:54 <clrnd> mm, so it's printing to stdout ... maybe the terminal goes stupid? try another one first
05:37:00 <kadoban> Even though gnome-terminal would almost have to be relatively sane, I kinda think it has to be a shell problem...
05:37:04 <clrnd> I also use gnome-term on xmonad, but whatever
05:37:08 <kadoban> terminal problem*
05:37:18 <clrnd> winobes, try urxvt and zsh or whatever
05:37:27 <clrnd> something more hipstar
05:37:41 <winobes> hah -- yes I will try that
05:37:49 <trap_exit> oh man
05:37:50 <kadoban> winobes: Does it hang right away when you change focus?
05:37:51 <trap_exit> you're using xm onad?
05:38:03 <winobes> trap_exit yeah it's great
05:38:13 <trap_exit> xmoand is totally telling your other program
05:38:23 <trap_exit> it's like "shh, winobes is not paying attention to you and watching youtube"
05:38:46 <winobes> kadoban yeah no it waits for a bit until i'm not paying attention and then stops
05:38:57 <kadoban> Hah, great :-/
05:39:20 <kadoban> winobes: You're sure sure it doesn't happen if you keep focus the whole time, right? And it's not just like random slowdown?
05:39:46 <kadoban> Remember that we're really really good at seeing patterns, even when there isn't one.
05:39:50 <winobes> i'm _pretty_ sure because i ran last night and it was still going when i got up this morning
05:40:12 <trap_exit> wait
05:40:17 <winobes> yeah i'm not ruling out that i'm just being crazy -- i'm just out of explainations
05:40:19 <trap_exit> we're basing this on a smaple point of 1?
05:40:32 <trap_exit> i.e. "swtiching away" = letting it run over night?
05:40:37 <trap_exit> alot of things can go on overnight
05:40:43 <trap_exit> that cause hte program to fail
05:40:52 <trap_exit> does the program output ot the terminal?
05:40:57 <kadoban> winobes: Welll....if you ran it overnight, it may have slowed way down for certain points and you'd never know as long as it eventually sped back up, right?
05:40:58 <trap_exit> does the terminal buffer?
05:40:59 <winobes> no no it's now during the day that its hanging
05:41:02 <trap_exit> does the buffering behavior change whether you have it focused or not?
05:41:14 <winobes> kadoban that's totally true it might have
05:41:15 <trap_exit> how long
05:41:16 <trap_exit> is this delay when you switch away
05:41:33 <winobes> i haven't timed it, but i would say 10 minutes
05:41:35 <trap_exit> winobes: is the delay 1 second, 10 seconds, 1 minute, 10 minutes, 1 hour, 10 hours, or what?
05:42:05 <winobes> the thing that i can't explain away is that it starts right back up where it left off when i click on it
05:42:11 <Fuuzetsu> http://hackage.haskell.org/package/unagi-chan how was this graph generated? Does criterion not suck with wide time ranges now?
05:42:22 <kadoban> winobes: Hmm, yeah that part is suggestively weird.
05:43:02 <chrisdone> ski: i don't think that can handle the case that stepeval handles
05:43:19 <winobes> when it finishes this file i'll try another terminal and see how it goes
05:43:21 <chrisdone> Fuuzetsu: probably they re-generated the benchmarks with only the first n ones
05:43:44 <Fuuzetsu> zz
05:43:53 <Fuuzetsu> someone give me time and I'll write diagrams frontend for criterion
05:44:47 <kadoban> winobes: If it's easy, maybe have it output a timestamp when it outputs its status message or whatever it is? Then you can tell basically how smooth it is, or at least notice pauses when you're not watching.
05:44:51 * alpounet hands Fuuzetsu a handful of time
05:44:57 <Fuuzetsu> it's not reaching me!
05:45:18 * hackagebot snap-cors 1.2.6 - Add CORS headers to Snap applications  http://hackage.haskell.org/package/snap-cors-1.2.6 (OliverCharles)
05:47:38 <kadoban> winobes: Or maybe even get fancy and have it log something special if there's too long of a pause between ticks
05:48:36 <mietek> Has anyone set up mighttpd2?
05:48:55 <mietek> I'm trying a bare-bones basic config, and I keep getting "Precondition failed"
05:50:18 * hackagebot hasql-postgres 0.6.1 - A "PostgreSQL" backend for the "hasql" library  http://hackage.haskell.org/package/hasql-postgres-0.6.1 (NikitaVolkov)
05:54:47 <orion> Hi. I am writing a library which can contain multiple key derivation functions. I want to standardize the interface by which KDFs are accessed. In particular, all KDFs must have two functions which return constant integers representing some cryptographic properties, and finally the KDF itself. Is it best to use a class/instance here?
05:56:23 <xandaros> Trying to cross-compile GHC for ARM. Wiki is telling me to run ./configure, but that script doesn't seem to exist...
05:57:38 <Yuras> xandaros: it is created by ./boot IIRC
05:58:14 <xandaros> ah, thanks
05:58:15 <Yuras> but I'm not sure you need ./boot manually
05:58:35 <Yuras> unless you are using sources from git
05:58:39 <tdammers> orion: I'd prefer a record type that contains those two functions
05:58:44 <xandaros> I am using sources from git...
05:59:12 <Yuras> xandaros: oh, then yes, you need to ./boot
05:59:58 <xandaros> Wiki just says to acquire the sources and links to a page that gives git as an option. Git is a lot easier than getting an archive imo :P
06:00:13 <ambrozyk> Hi, do you know of any limitations of GHCi when it comes to FFI? Specifically, can it load foreign exports/imports from a file?
06:01:24 <winobes> kadoban, trap_exit, clrnd: got through a whole file with no hangs with urxvt... i'm tentatively going to declare the terminal as the problem
06:01:48 <clrnd> winobes, sure, or xmonad
06:02:00 <winobes> true or some combination
06:02:03 <winobes> getting a distinct feeling that someone was trying to protect me from myself heh
06:02:06 <clrnd> now try in KDE3.5 with gnome-terminal
06:02:12 <ocramz> hullo room!
06:02:16 <trap_exit> have u tried using xterm?
06:02:22 <winobes> didn't try xterm
06:02:24 <kadoban> winobes: Interesting
06:02:51 <winobes> also my process monitor (asside from not going to 0 now and again) looks a bit different
06:03:11 <winobes> on gnome-terminal, the core working on the script would be bouncing around between 95 and 100
06:03:12 <alpounet> ambrozyk: yes it can. just make sure you pass any necessary -l option and the likes to link the C code, so that ghci can find it when you'll call it
06:03:17 <winobes> and now it's just at 100 the whole time
06:03:24 <clrnd> well that's scary
06:03:27 <alpounet> ambrozyk: see for instance the options passed around in http://stackoverflow.com/questions/15677323/testing-ffi-code-with-ghci
06:03:59 <Chris_the_sheep> Hey guys
06:04:02 <winobes> yeah
06:04:04 <Chris_the_sheep> quick question :P
06:04:05 <ambrozyk> alpounet: Thanks!
06:04:16 <Chris_the_sheep> how can I apply a function on all ellements of a list
06:04:16 <Chris_the_sheep> ?
06:04:25 <exio4> map?
06:04:27 <exio4> :t map
06:04:28 <lambdabot> (a -> b) -> [a] -> [b]
06:04:29 <Chris_the_sheep> yes!!
06:04:33 <Chris_the_sheep> but how can I use it?
06:04:33 <Chris_the_sheep> :(
06:04:34 <exio4> > map (\x → x*2) [1..50]
06:04:36 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
06:04:36 <Chris_the_sheep> i have the following code
06:04:45 <Chris_the_sheep> isInList :: Int -> [Int] -> Bool  isInList x l 	| x `elem` l = True 	| otherwise = False 	 isInList x l = map isInList x
06:04:47 <Yuras> ambrozyk: I think it can't handle Prim foreign convention
06:04:52 <Yuras> https://ghc.haskell.org/trac/ghc/ticket/1257
06:05:02 <Chris_the_sheep> but it says map uses 3 parameters??
06:05:03 <Yuras> but I don't think you'll need it L)
06:05:14 <BoR0> Chris_the_sheep, in that case you need filter instead of map
06:05:14 <winobes> Chris_the_sheep: that looks like a job for foldr actually
06:05:26 <exio4> I think "any" :P
06:05:27 <ocramz> :t foldr
06:05:28 <lambdabot> (a -> b -> b) -> b -> [a] -> b
06:05:42 <ocramz> binary function, starting element, list
06:06:24 <Chris_the_sheep> oh.. a binary tree,,,, sweet
06:06:25 <Chris_the_sheep> :P
06:06:27 <ambrozyk> Yuras: yeah, I don't need it :) thanks anyway!
06:07:50 <hs__> Trying to understand monads, i came accross category theory. According to wikipedia, a monad is a functor F o G for adjoint functors F and G. In say, the Maybe monnad, what are F and G
06:08:01 <mrsElectron> (MakeMytype 1 2) .. how do I extract 1 and 2 from that object?
06:08:23 <Chris_the_sheep> isInList x l = any (isInList x l) l <-?
06:08:24 <kadoban> mrsElectron: Pattern matching
06:08:31 <Chris_the_sheep> something like that?
06:08:46 <Yuras> @tell carter now I think I did failed actually
06:08:46 <lambdabot> Consider it noted.
06:09:36 <Yuras> @tell carter at least I found the source of missunderstanding: http://www.reddit.com/r/haskell/comments/2mfxka/handling_async_exceptions_in_haskell_the_right_way/cm4x2xt
06:09:36 <lambdabot> Consider it noted.
06:11:00 <Yuras> @tell carter typo. s/did fail/didn't fail
06:11:00 <lambdabot> Consider it noted.
06:12:46 <clrnd> hs__, no idea. en.wikipedia actually says it's a functor C -> C with 2 natural transformations
06:14:46 <Fuuzetsu> hs__: that's not a good way to try to understand monads
06:15:17 * hackagebot engine-io 1.2.1 - A Haskell implementation of Engine.IO  http://hackage.haskell.org/package/engine-io-1.2.1 (OliverCharles)
06:15:41 <Fuuzetsu> if you want to understand monads then you'll have to understand all the prerequisites too. If you just want to know how to use Monad then you should forget the abstract nonsense on wiki.
06:15:49 <clrnd> also that ^, I did try to get the categorical definition but in the end I got them by using them in real code
06:16:02 <kadoban> hs__: AFAIU, most of the haskell things based on category theory are only loosely inspired by anyway.
06:16:04 <hs__> i'm trying to get a better defininion than "thingy that obeys the monad laws when implemented as a monad"
06:16:29 <hs__> so is there?
06:16:33 <clrnd> hs__, you don't need a formal definition for using Factory pattern in OOP, same here
06:16:33 <Fuuzetsu> hs__: in category theory everything is a thingy that obeys some laws ;)
06:16:34 <MP2E> It's a monoid in the category of endofunctors. That's a better definition, but does it help you much?
06:16:38 <MP2E> I wouldn't think it would :P
06:16:45 <kadoban> hs__: That's about all you need I think, and some practice/experience until you get intuition for it.
06:17:00 <hs__> still learning category theory, but yes
06:17:08 <Fuuzetsu> MP2E: that's also not a good explanation because it goes into 2-category teritory
06:17:09 <clrnd> it's just some abstraction pattern that's really useful when dealing with pure code
06:17:13 <hs__> i can already use it, just want to understand it better
06:17:30 <Fuuzetsu> hs__: well, if you're learning CT then keep learning and don't skip ahead
06:18:01 <hs__> i tried learning it to understand the haskell type system better
06:18:07 <winobes> hs__: if you haven't seet it already, this is a good place to start with category theory in haskell http://en.wikibooks.org/wiki/Haskell/Category_theory
06:18:20 <hs__> thank you
06:18:41 <Fuuzetsu> hs__: you're learning the wrong thing if you want to understand Haskell's type system
06:18:52 <Fuuzetsu> you should be learning type theory instead
06:19:07 <clrnd> something like System-F
06:19:15 <Fuuzetsu> no skipping ahead ;P
06:19:32 <hs__> awh
06:19:53 <Poep> aww poor hs__
06:21:58 <winobes> category theory is all things; no one understands all things |- no one understands category theory
06:22:50 <ocramz> regarding more down to earth matters: I’d like to configure emacs to see a specific cabal sandbox, is there a way? specifically, to ignore the global haskell pkg database
06:23:02 <exio4> that looks like "(p → q) ∧ (r → q) ⇒ (p → r)", which is a logical fallacy!
06:23:33 <winobes> exio4: caught me :$
06:24:22 <mrsElectron> Z (MakeMytype 1 2) .. what should Z be for that to evaluate to 1 or 2 or (1 2)?
06:25:18 * hackagebot digestive-functors-aeson 1.1.12 - Run digestive-functors forms against JSON  http://hackage.haskell.org/package/digestive-functors-aeson-1.1.12 (OliverCharles)
06:28:28 <Denommus> is there a short syntax for \x -> x-1?
06:28:44 <Denommus> (-1) makes the parser think I'm trying to use negative one
06:28:51 <Denommus> wait, (+-1) may work
06:29:10 <Denommus> (+(-1))
06:29:17 * osfameron is surprised this particular syntax wart hasn't been cauterized yet
06:30:06 <Fuuzetsu> Denommus: (`subtract` 1)
06:30:18 * hackagebot digestive-functors-aeson 1.1.12.1 - Run digestive-functors forms against JSON  http://hackage.haskell.org/package/digestive-functors-aeson-1.1.12.1 (OliverCharles)
06:30:27 <Denommus> :t subtract
06:30:28 <lambdabot> Num a => a -> a -> a
06:30:40 <Zorg> Denommus: Possibly pred
06:30:56 <Denommus> maybe flip (1-) also works
06:30:56 <Fuuzetsu> pred is good if 1 is what you actually want to use ;)
06:31:07 <biinui> hi :) in https://hackage.haskell.org/package/libvorbis-0.1.0.0/docs/Codec-Audio-Vorbis-File.html , what is the data block returned by read? is it just binary representation of vorbis file?
06:31:11 <Fuuzetsu> :t flip (1-)
06:31:12 <lambdabot> Num (b -> c) => b -> (b -> c) -> c
06:31:26 <Fuuzetsu> doesn't seem like what you want ;)
06:31:32 <Denommus> hm, yeah
06:31:41 <Fuuzetsu> :t flip (-) 1
06:31:42 <lambdabot> Num c => c -> c
06:31:49 <ocramz> I thought of modifying the inferior haskell call with e.g. ghci -no-user-package-db -package-db .cabal-sandbox/*-packages.conf.d
06:32:00 <ocramz> how do you guys do it?
06:32:05 <ocramz> thanks for any help
06:32:29 <Fuuzetsu> ocramz: pretty sure there's a var somewhere where you can set extra args to pass in
06:33:42 <Chris_the_sheep> why do I get constant error in this? :( the logic bahind it is r8
06:33:43 <Chris_the_sheep> removeLastFromList :: [Int] -> [Int] removeLastFromList list = init list  removeList :: [Int] -> [Int] removeList list  	| null list = list 	| otherwise = removeLastFromList list.removeList
06:34:24 <Fuuzetsu> Chris_the_sheep: use lpaste.net
06:34:41 <Fuuzetsu> make sure to post the error there too
06:34:43 <ThreeOfEight> I am playing around with the functional graph library in Haskell and I'm wondering whether there is a graph type that instantiates Arbitrary
06:34:44 <Fuuzetsu> we don't read minds
06:34:49 <ocramz> Fuuzetsu: I’m looking into it
06:35:01 <ocramz> Fuuzetsu: thanks
06:35:03 <Chris_the_sheep> i'm trying to remove the entire list, so I check if it's empty, if yes then return the list, otherwise remove last element and use the obtained new list as input to the removeList method again
06:35:09 <mads-> I have made a small compiler and interpreter for a small calculator language, including plus, times and literal values. If I have the expression Times (Lit 5) (Lit 4) how would I go about parsing that?
06:35:52 <Chris_the_sheep> http://lpaste.net/114444
06:35:55 <kadoban> mads-: Isn't that already parsed into haskell types? Do you mean how would you evaluate that?
06:36:36 <Chris_the_sheep> I can't see what'swrong with my code
06:37:07 <Fuuzetsu> Chris_the_sheep: You didn't post the error like I asked (even though I know what the problem is).
06:37:13 <Fuuzetsu> Please include it, it's there for your aid.
06:38:11 <mads-> kadoban: If I was given that expression as a string, I'm sorry
06:38:33 <mads-> I mean, if I want to read that from a file and interpret it to a value
06:39:22 <clrnd> mads-, see Parsec
06:39:42 <kadoban> mads-: Oh, that's your language? Yeah I mean I guess you can parse that if you want...it's basically already haskell though, heh.
06:39:43 <clrnd> although I think deriving Read could work
06:40:18 * hackagebot hspec-wai 0.6.2 - Experimental Hspec support for testing WAI applications  http://hackage.haskell.org/package/hspec-wai-0.6.2 (SimonHengel)
06:40:35 <mads-> clrnd: thanks. I will give that a look-see
06:40:53 <Chris_the_sheep> Fuuzetsu: http://lpaste.net/114444
06:41:15 <Fuuzetsu> Chris_the_sheep: Alright thanks. Can you tell me what you think the error means?
06:41:27 <Chris_the_sheep> that error message doesn't help me a lot :/
06:41:28 <clrnd> Chris_the_sheep, `list.removeList` ??
06:41:37 <Fuuzetsu> clrnd: Now now, let him figure it out
06:41:49 <clrnd> oh, sorry
06:42:13 <Chris_the_sheep> I have no idea, I just learned the dot operator to join 2 functions and using output fomr 1st as input in 2nd :/
06:42:30 <Chris_the_sheep> am I using the dot operator worng?
06:43:06 <Fuuzetsu> Chris_the_sheep: Well, you're joining two functions so the thing on the right of ‘.’ must be a function, right? I.e. it has to have a type like ‘a -> b’ for some ‘a’ and ‘b’, correct?
06:43:25 <Chris_the_sheep> yes, two integers
06:43:33 <Chris_the_sheep> actually two lists of type Int
06:44:20 <Fuuzetsu> Ok, let's assume that's right. Why would your ‘null list = list’ case work then? After all, ‘list :: [Int]’.
06:44:31 <Fuuzetsu> You say so yourself in the type signature.
06:45:30 <wei2912> is there an upside down character for ^?
06:45:31 <Chris_the_sheep> I want to return the list which will be an empty list once the list I'm working with is emptyh
06:45:47 <Fuuzetsu> wei2912: ∨ v \/ ;P
06:45:52 <wei2912> whoops, wrong channel
06:45:55 <wei2912> Fuuzetsu: thanks
06:46:12 <Chris_the_sheep> I found on google that null checks if the list is empty and returns Bool value, which I use in the check
06:46:33 <Fuuzetsu> Yep, so it seems that ‘null list = list’ is just fine.
06:46:42 <Fuuzetsu> In fact, you need to return [Int], right?
06:46:50 <Chris_the_sheep> yes
06:46:57 <Chris_the_sheep> to use it as input in the second function
06:47:18 <Fuuzetsu> Don't skip ahead.
06:47:28 <Fuuzetsu> let's look at type of .
06:47:30 <Fuuzetsu> :t (.)
06:47:31 <lambdabot> (b -> c) -> (a -> b) -> a -> c
06:47:45 <Fuuzetsu> we can rewrite this to (b -> c) -> (a -> b) -> (a -> c)
06:48:03 <Fuuzetsu> or specialise to ([Int] -> [Int]) -> ([Int] -> [Int]) -> ([Int] -> [Int])
06:48:07 <Fuuzetsu> are you following so far?
06:48:20 <Chris_the_sheep> yes
06:48:40 <Fuuzetsu> OK, so it takes 2 functions, each of one argument, and returns another function (of one argument), correct?
06:49:06 <Chris_the_sheep> yes
06:49:53 <Fuuzetsu> OK. So it returns a function. But you said in your type signature that you will return [Int]. So GHC complains: expected type [Int] but the actual type it got is (a0 -> c0), i.e. a function
06:50:46 <Fuuzetsu> So clearly the ‘.’ is the wrong thing to use because it returns a function.
06:51:06 <Chris_the_sheep> I don't get it :( How am I returning a function? I specified in both
06:51:15 <Chris_the_sheep> that I want as return, a list of integers
06:51:17 <yitz> wei2912: also ⋎ ⋁
06:51:57 <Fuuzetsu> Chris_the_sheep: Yes, you say you want [Int] but your code doesn't give [Int]. No matter what, expression such as ‘f . g’ will *always* be a function.
06:51:58 <Denommus> Chris_the_sheep: ([Int] -> [Int]) is a function from a list of Int to a list of Int
06:52:46 <Fuuzetsu> The solution is very simple, just tell me in your words what you want to achieve in that case and it should be very easy to translate into Haskell
06:52:48 <Chris_the_sheep> okay, so how can I fix this>?#
06:52:59 <Chris_the_sheep> this?*
06:54:46 <Chris_the_sheep> I mean what should I use instead of the dot operator
06:55:18 * hackagebot oauthenticated 0.1.3.4 - Simple OAuth for http-client  http://hackage.haskell.org/package/oauthenticated-0.1.3.4 (ibotty)
06:55:31 <Fuuzetsu> You don't need an operator at all so stop thinking you do.
06:55:53 <kadoban> Chris_the_sheep: It seems like on line 7... you should just remove the whole ".removeList" part. That doesn't seem to belong there at all.
06:56:09 <Fuuzetsu> kadoban: that won't do what he wants to do
06:56:18 <Fuuzetsu> also it's pointless to just tell him the solution
06:56:39 <kadoban> Oh, no? Well, not sure how else to point him in the right direction with this one.
06:57:39 <Fuuzetsu> kadoban: the only ‘reasonable’ thing you can achieve with these two functions together is either infinite loop or const [] anyway ;P
06:58:05 <clrnd> Chris_the_sheep, whats is the function supposed to do?
06:58:35 <kadoban> Fuuzetsu: I'm not seeing why, but then again I've been up all night, so... :-/
06:58:44 <clrnd> Chris_the_sheep, in plain english
06:58:53 <kadoban> I'll abandon ship so I stop embarassing myself.
06:59:05 <tattsun`> is there any good tutorial for the current version of parsec?
06:59:27 <Fuuzetsu> kadoban: all it does (once it compiles) is drop last element until the list is empty at which point it returns the list
06:59:51 <tattsun`> real world haskell seems to be too old.
06:59:52 <Fuuzetsu> it's just dropWhile (not . null) which is just const []
07:00:19 <Fuuzetsu> uh, dropWhile (not . null) . reverse
07:00:24 <Fuuzetsu> either way same thing
07:00:51 <Chris_the_sheep> Accept a list, remove last element (im using init to take all elements except last and return that as new list), check if list is empty (thus the null list line) if yes return the empty list, otherwise remove the last element and use the new list as input to the entire function itself again (recursion) so we start with say 4 elements prior to 5
07:00:57 <kadoban> Oh I see...I didn't realize that I have no idea what his actual goal is, so my suggested change would be to just totally remove what he was probably trying to do.
07:01:20 <Fuuzetsu> Yes, that's also my suggestion *after* he gets this to compile
07:02:01 <Fuuzetsu> Chris_the_sheep: OK so in the second case you want to “remove the last element and use the new list as input to the entire function itself again”
07:02:28 <yitz> Chris_the_sheep: that procedure will always result in an empty list, won't it?
07:02:29 <Fuuzetsu> So why not just ‘removeList (removeLastFromList list)’? This does what you just described in straight forward way.
07:02:29 <clrnd> Chris_the_sheep, so in the end it will always return an empty list?
07:02:29 <Chris_the_sheep> yes
07:02:45 <Chris_the_sheep> yitz: yes it will :P
07:03:21 <Chris_the_sheep> I'm just practicing doing random functions I come up with, not necesairly useful, but jsut want to get used to the syntax
07:03:37 <clrnd> ohhh
07:03:37 * Fuuzetsu just realised that dropWhile takes predicate on element, disregard that bit
07:04:09 <Fuuzetsu> apparently I'm also low on sleep like kadoban ;)
07:04:30 <kadoban> Yay, we can have an exhaustion party together
07:04:58 <Chris_the_sheep> i have no idea of how to proceed with this, I'm trying to google how to take output of one function as input to another
07:05:05 <Chris_the_sheep> yet nothing interesting comes up :/
07:05:08 <yitz> Chris_the_sheep: in Haskell we usually think only about the result of applying a function for a given input, not about a function "doing" something. so your function can be written: removeFromList _ = []
07:05:20 <Chris_the_sheep> a keyword would be helpful
07:05:23 <jergason> haskell friends, can someone help me understand how this function memoizes its recursive calls? http://lpaste.net/114446
07:06:07 <tomberek> Anyone familiar with how to use ekmett's Data.Constraint.Forall     I'd like to have a constraint where I don't care about one of the parameters, eg:  class (forall n. Counter a ~ CycleOf n) => Cyclic a where ...
07:06:14 <clrnd> Chris_the_sheep, can you give an example of what you mean by that last statement in python/C ?
07:06:21 <yitz> Chris_the_sheep: you mean how to take the *output* of one function as the *input* of another? then yes, you were right to begin with, it's called "composition", and in Haskell it is written as a dot.
07:06:52 <Fuuzetsu> Chris_the_sheep: I gave you the solution
07:07:25 <SvenskFisk> What's the equivalent of if/elif/else in haskell?
07:07:32 <kadoban> jergason: It memoizes it fairly directly. It simply indexes into the list to find the answer for smaller n, right?
07:07:42 <Fuuzetsu> tomberek: the answer to things starting with “Anyone familiar with how to use ekmett's” is usually ‘No.’.
07:07:45 <kadoban> SvenskFisk: A 'case' probably.
07:07:56 <Fuuzetsu> MultiWayIf
07:07:57 <kristian_> SvenskFisk, if/then/else, case of, pattern matching, guards
07:08:01 <SvenskFisk> That just does pattern matching though, right?
07:08:11 <Fuuzetsu> you can do case () _ | …
07:08:12 <tomberek> Fuuzetsu: ha! okay then, how about any other way of doing something like that?
07:08:18 <Fuuzetsu> case () of _ | …
07:09:01 <Fuuzetsu> tomberek: Well, someone might know, I'm half-joking.
07:09:02 <jergason> kadoban: a few follow-up questions then: does (map [0..] fib !!) partially apply the !! operator?
07:09:02 <SvenskFisk> Fuuzetsu: So using that I can just use equations instead of pattern matching?
07:09:15 <Fuuzetsu> SvenskFisk: It's just regular pattern guards
07:09:21 <kadoban> jergason: Think about what it has to do to compute a certain n, for example. Run it through in your head, pick like n == 3 and work it out, if that helps?
07:09:23 <Fuuzetsu> MultiWayIf is a sugar for this
07:09:36 <jergason> and how does it avoid recreating the list for every recursive call? wouldn't the calls to get the previous values of the seq recreate a new list by passing it through map?
07:09:36 <kadoban> jergason: Yes
07:09:45 <jergason> this is good advice, i shall try it
07:09:55 <Fuuzetsu> https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/basic-syntax-extensions
07:10:06 <kadoban> (the yes was to your previous question re: partial application)
07:10:15 <tomberek> class (forall n. Counter a ~ CycleOf n) => Cyclic a where ... I can just use "Cyclic a n" but then that forces instances to manually input the n::Nat parameter, when I have a way to calculate it using the Counter a type family
07:11:32 <Fuuzetsu> yitz: ‘.’ was only right there if he flipped the sides and used $ or parens
07:11:41 <Fuuzetsu> he didn't need composition at alll there
07:11:41 <Chris_the_sheep> tht's the psudo code
07:11:45 <Chris_the_sheep> for what i want to do in
07:11:46 <Chris_the_sheep> haskell
07:11:46 <Chris_the_sheep> http://pastebin.com/Ky2yw27q
07:12:08 <Fuuzetsu> Chris_the_sheep: you can translate line 4 pretty literally
07:12:09 <yitz> Fuuzetsu: yes. but i think it is indeed the concept he is trying to learn about in this exercise.
07:12:20 <Fuuzetsu> <Fuuzetsu> So why not just ‘removeList (removeLastFromList list)’? This does what you just described in straight forward way.
07:13:04 <Fuuzetsu> yitz: Well, then he should ask about how to use composition instead ;P
07:13:21 <wei2912> Chris_the_sheep: what're you trying to do with that function?
07:13:30 <wei2912> Chris_the_sheep: why do you need to remove all elements?
07:13:43 <yitz> Fuuzetsu: i think he was trying to say that. he said he didn't know the right words. i think the word he is looking for is "composition".
07:13:44 <clrnd> Chris_the_sheep, did you try using parenthesis? like in math, they just indicate precedence
07:13:44 <Fuuzetsu> He said he's just trying syntax out and stuff
07:13:50 <wei2912> ah, okay
07:14:13 <wei2912> > let f [] = []; f xs = f (init xs) in f [1, 2, 3, 4, 5]
07:14:15 <lambdabot>  []
07:14:19 <wei2912> :t init
07:14:20 <lambdabot> [a] -> [a]
07:14:24 <wei2912> > init [1, 2, 3]
07:14:26 <lambdabot>  [1,2]
07:14:35 <Fuuzetsu> > const [] [1, 2, 3]
07:14:36 <lambdabot>  []
07:14:39 <wei2912> that returns a list that doesn't contain the last element
07:14:59 <yitz>  <Chris_the_sheep> i have no idea of how to proceed with this, I'm trying to google how to take output of one function as input to another. yet nothing interesting comes up :/
07:15:17 <Fuuzetsu> I suspect he's just looking for f (g x)
07:15:20 <wei2912> Chris_the_sheep: for that, it's actually quite easy
07:15:24 <clrnd> I love this one http://s3.amazonaws.com/lyah/listmonster.png
07:15:28 <wei2912> Chris_the_sheep: just put your input into the function as a parameter
07:15:36 <wei2912> as what Fuuzetsu describes
07:15:48 <wei2912> (you may want to join #haskell-beginners too, seeing that you're new to haskell)
07:17:36 <Fuuzetsu> unrelated: looking for Haddock contributors ;)
07:17:39 <yitz> clrnd: that's a great graphic!
07:19:06 <kadoban> Chris_the_sheep: If you're very new, make sure you're reading through some kind of haskell book or guide or whatever. It's not really something you can do well in just playing around, although there's nothing wrong with you trying really.
07:19:48 <ski> chrisdone : elaborate ?
07:21:08 <tomberek> ski: this might be something you're familiar with.  I'd like to have a constraint where I don't care about one of the parameters, eg psuedo:  class (forall n. Counter a ~ CycleOf n) => Cyclic a where ...
07:23:09 <ski> tomberek : it would be nice if there was an extension for universal constraints
07:23:36 <tomberek> ski: yes.... is kmett's Data.Constraint.Forall applicable here?
07:24:03 <ski> tomberek : .. however, i'm not sure whether what you asked for is the same as the code you typed
07:24:49 <tomberek> no, that's illegal Haskell right now, i'm not sure how to use https://hackage.haskell.org/package/constraints-0.3.2/docs/Data-Constraint-Forall.html
07:24:56 <ski> `class (forall n. Counter a ~ CycleOf n) => Cyclic a where ...' would express that to be able to make a type `a' an instance of `Cyclic', it must already be that for *every* type `b', `Counter a' is equal to `CycleOf n'
07:25:27 <ski> perhaps instead of "for *every* type `b'" you wanted "for *some* type `b'" -- i'm not sure
07:26:26 <ski> but if your "I don't care about one of the parameters" referred to `n', they that sounds to me like you possibly meant `class (exists n. Counter a ~ CycleOf n) => Cyclic a where ...'
07:26:53 <ski> (where that would be equivalent to `class Counter a ~ CycleOf n => Cyclic a where ...')
07:26:59 <tomberek> ski, yes... exists is better
07:27:13 <Denommus> for those who know how to use reactive-banana
07:27:18 <Denommus> is this a good definition of integral?
07:27:26 <Denommus> integral x dt = accumB 0 $ (+) <$> x <@ dt
07:27:41 <ski> tomberek : so, would `class Counter a ~ CycleOf n => Cyclic a where ...' work, then ?
07:27:55 <ski> i suspect it would complain about `n' not being in the class head
07:28:02 <tomberek> ski... no,, because then n is not present in the class declaration
07:28:46 <ski> (and in terms of implementation, this would involve some kind of search for such an `n' which satisfies `Counter a ~ CycleOf n', for a given `a'
07:29:55 <tomberek> ski... yes, Counter a is a type family that resolves to either Void, or CycleOf (n::Nat)
07:30:18 * hackagebot equal-files 0.0.5 - Shell command for finding equal files  http://hackage.haskell.org/package/equal-files-0.0.5 (HenningThielemann)
07:31:11 <tomberek> ski: I just want the class constraint to express that the "Counter a" type family is "not Void" for all instances of the Cyclic class
07:32:03 <chrisdone> ski: i don't think you can get this kind of expansion using sprint http://bm380.user.srcf.net/cgi-bin/stepeval.cgi?expr=foldr+%28%5Cx+z+-%3E+if+x+%3E+4+then+1+*+z+else+2+*+z%29+1+%5B5%2C4%2C6%2C2%2C6%2C3%5D
07:33:39 <tomberek> ski, with no 'n' in the class head GHC complains with: " Not in scope: type variable `n' "
07:35:18 * hackagebot equal-files 0.0.5.1 - Shell command for finding equal files  http://hackage.haskell.org/package/equal-files-0.0.5.1 (HenningThielemann)
07:36:11 <ski> tomberek : perhaps one could make an `Exists :: (* -> Constraint) -> Constraint' in analogy of that `Forall'
07:36:33 <ski> tomberek : i'm not sure how much further that'd take us
07:36:38 <chrisdone> ski: for example…
07:37:47 <tomberek> ski: ok, i'll try that, though I just thought of another way,  I can use type level equality like this:   Equal (Counter a) (Void) ~ False
07:38:04 <tomberek> That way I avoid mention of "n"
07:39:41 <ski> chrisdone : hm. i think i see. i think `:print' only prints constructors and (underscored) variables, where the latter represent unforced thunks
07:39:46 <chrisdone> ski: say i'm reducing this: 1 : (if True then 123 else 23) : []
07:39:48 <chrisdone> right
07:40:11 <chrisdone> i want the code to be preserved, so the `if True …` or e.g. (\x -> foo) is not reduced or becomes opaque
07:40:25 <Taneb> What are the use cases for using Parsec as a monad transformer?
07:40:38 <chrisdone> Taneb: i used it once to implement a language with reader macros
07:40:58 <Chris_the_sheep> OH MY GOD!!! I just saw it!! Thank you Fuuzetsu!!! It worked! :D
07:40:59 <chrisdone> the language could extend its own parser so parsec was a transformer over the interpreter
07:41:24 <Taneb> Oh wow
07:41:37 <Taneb> chrisdone, do you have a link?
07:41:49 <miguelnegrao> hi, anyone here familiar with scotty ?
07:41:54 <ski> hm, possibly it can print functions as well. .. at least <https://hackage.haskell.org/package/hood> can do that
07:42:23 <alpounet> miguelnegrao: yup, shoot your question
07:42:47 <chrisdone> Taneb: https://github.com/chrisdone/z
07:43:06 <tdammers> miguelnegrao: just ask your question :D
07:43:09 <miguelnegrao> alpounet, I was trying to have state that is kept in between requests. I tried using StateT and ScottyT and ActionT
07:43:46 <miguelnegrao> it seems thought that I have to run 'runStateT' with every request, which means I wouldn't be able to keep state in between requests, right ?
07:44:33 <Taneb> chrisdone, thanks
07:44:36 <chrisdone> ski: right that seems like you have to put "observe" around expressions and it does basically a Debug.Trace
07:44:51 <chrisdone> Taneb: the implementation isn't that great but it's… an example =)
07:44:57 <miguelnegrao> I have 'type RScottyM = ScottyT TL.Text (S.StateT Int IO)'
07:45:03 <Taneb> chrisdone, :P
07:45:18 * hackagebot xmltv 0.0.1 - Show tv channels in the terminal  http://hackage.haskell.org/package/xmltv-0.0.1 (dagle)
07:45:31 <chrisdone> Taneb: perhaps simpler is https://github.com/chrisdone/ace/blob/master/src/ACE/Parsers.hs
07:45:42 <L8D> what's that language extension that let's you write in UTF-8 characters?
07:45:57 <L8D> and why doesn't it support set operations?!
07:46:20 <chrisdone> Taneb: hmm, maybe not. i thought i was using a state monad but actually i'm using parsec's built in state support. ignore that
07:46:21 <exio4> L8D: do you mean UnicodeSyntax?
07:46:27 <L8D> exio4: I think so
07:46:36 <chrisdone> ski: perhaps that might be a way to go, though
07:47:19 <chrisdone> ski: maybe replacing every expression “e” with “trace "e" e” might print out a useful traceback
07:47:28 <chrisdone> @src foldl
07:47:28 <lambdabot> foldl f z []     = z
07:47:28 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
07:47:30 <L8D> exio4: where's the documentation on it?
07:47:47 <L8D> found it
07:48:00 <chrisdone> foldl f z []     = z    would become:  foldl f z []     = trace "\f z -> z" z
07:48:07 <chrisdone> er
07:48:14 <chrisdone> foldl f z []     = z    would become:  foldl f z []     = trace "\f z [] -> z" z  (ish)
07:48:43 <alpounet> miguelnegrao: given that each request is processed in itw own thread, how would you update that Int?
07:48:47 <chrisdone> mmm, i dunno actually
07:48:49 <alpounet> s/itw/its/
07:49:08 <Fuuzetsu> Chris_the_sheep: no problem, next time just take your time to think carefully about the type of everything, in this case ‘.’
07:50:00 <miguelnegrao> alpounet: ok, I wasn't aware of that. So in short, each request can only share data through IO ?
07:50:08 <chrisdone> ski: that's interesting, though. i like the idea of doing a simple transform over some code and then just running it, rather than having to implement a complete new interpreter. it would be less flexible but definitely easier
07:50:45 <alpounet> miguelnegrao: well, we certainly don't want any shared state between requests. that'd the best thing to do if you wanted your app to be fragile under heavy (simultaneous) concurrent loads
07:51:12 <alpounet> miguelnegrao: if there's some information that must persist and be accessible from any request handler, yeah, i'd really suggest a DB
07:51:37 <tdammers> I use STM for a few things
07:51:55 <tdammers> but this is a conscious decision, and it means that I can't easily scale the app horizontally
07:52:04 <miguelnegrao> alpounet: ok, I understand. I was just making a very simple test to see if I understood how this works and was trying to avoid using databases.
07:52:28 <alpounet> miguelnegrao: if you want a light solution, you can use an in-memory DB like acid-state, which can still offer ACID guarantees
07:52:32 <chrisdone> \x -> if p x then 123 else 23
07:52:32 <chrisdone> could become
07:52:32 <chrisdone> trace "\x -> if p x then 123 else 23" (\x -> trace ("if p " ++ show p ++ " then 123 else 23") (if p x then 123 else 23))
07:52:34 <ski> chrisdone : that Z reminds me of "Scheme Request for Implementation 45: Indentation-sensitive syntax" by Egil Möller in 2003 at <http://srfi.schemers.org/srfi-49/srfi-49.html>
07:52:38 <vanila> hi
07:53:40 <miguelnegrao> alpounet: ok, I'll check acid-state. I just wanted to increment  a counter on every hit to a url... :-)
07:54:39 <ski> chrisdone : well, `observe' can also observe functions, which is cool (it shows which arguments it has ever been applied to, and the corresponding answers. now that we have `\case', one could imagine writing out the data in that format)
07:54:48 <alpounet> miguelnegrao: oh then maybe you can just use a lock-protected "mutable var", like TVar (which is from STM), as tdammers mentionned above
07:55:55 <chrisdone> ski: yeah, that SRFI differs in: (1) grouping: "f x y" in that groups as "(f x y)", in z the grouping is "f (x y)", (2) it allows parentheses which negates the purpose of z which is arbitrary reader macros
07:55:57 <miguelnegrao> alpounet: ok, I'm familiar with TVar, so that might be a good option for a dead simple example.
07:56:19 <miguelnegrao> thanks
07:56:26 <chrisdone> ski: can you show an example of observing functions?
07:56:28 <ski> chrisdone : s/show p/showsPrec 11 x/, no ?
07:57:34 <chrisdone> ski: well i'm not sure show even makes sense because p could be more code, but sure
07:58:06 <ski> chrisdone : yeah .. i was wondering how if `f x y z' groups as `f (x (y z))', then how can `defun ap x y\n...' define a curried `ap' ?
07:58:43 <tomberek> ski: this seems to work: type a /=/ b = ((a == b) ~ False)        class (Counter a /=/ Void) => Cyclic a where
07:58:43 <carter> Yuras: yay
07:58:59 <ski> chrisdone : perhaps one could use NbE, somehow ..
07:58:59 <Yuras> hello carter
07:59:00 <chrisdone> ski: that's because `defun' is a special operator, and thanks to the previous rules, it interprets everything on its right-hand-side as it wishes
07:59:34 <ski> tomberek : fine. (where's that `(==)' defined ?)
07:59:46 <tomberek> base:  Data.Type.Equality
07:59:50 <chrisdone> ski: NbE?
07:59:57 <ski> Normalization-by-Evaluation
08:00:05 <tomberek> ski: http://hackage.haskell.org/package/base-4.7.0.1/docs/src/Data-Type-Equality.html#%3D%3D
08:00:35 <tomberek> type family (a :: k) == (b :: k) :: Bool
08:01:14 <tomberek> then they have instances for a wide-range of types
08:02:15 <Yuras> carter: now I don't know what to do. there is no sense in write yet another article about exception handling in general
08:02:24 <Yuras> there are 100s of then already
08:02:33 <carter> why?
08:02:57 <Yuras> I will not write is better then David Abrahams :)
08:03:16 <Yuras> it is simply not haskell specific
08:03:23 <Yuras> do I have nothing new to add
08:03:43 <avaritia> hey can someone tell me why this little script is raking up to 1gb in resources? http://lpaste.net/6704179306056122368
08:03:59 <Denommus> my integral definition was wrong
08:04:06 <Denommus> this is a correct definition: integral x dt = accumB 0 $ fmap (+) $ (*) <$> x <@> dt
08:04:13 <Yuras> carter: but looks like the community just don't see a value in David Abrahams' approach
08:04:23 <carter> i've enver hear dof that appraoch
08:05:14 <Yuras> there are few links in the article, but I'm sure nobody follow them
08:05:21 <Yuras> and will not
08:05:27 <ski> chrisdone : the idea is that given an opaque term that you only can execute, and it's type as a traversible structure, you define, by induction on the type, a way to lift the value into an AST representing it
08:07:10 <Yuras> carter: his approach is so widely adapted, so I didn't expected anyone will disagree here or even don't know about it :)
08:08:02 <Yuras> that is my fault, but anyway...
08:08:37 <alpounet> Yuras: is that the boost guy?
08:08:46 <Yuras> alpounet: yes
08:10:18 * hackagebot fpco-api 1.2.0.3 - Simple interface to the FP Complete IDE API.  http://hackage.haskell.org/package/fpco-api-1.2.0.3 (ChrisDone)
08:10:38 <chrisdone> ski: i get the feeling that would lead to loss of the names used in the original source representation?
08:10:59 <shock_one> Hi. How would I fill a line with one character in Text.PrettyPrint? More precisely, I want a line like --------------------------.
08:13:29 <clrnd> shock_one, mmm if you know the length:
08:13:39 <shock_one> I do not.
08:13:49 <clrnd> > hcat . replicate 5 $ char '-'
08:13:51 <lambdabot>  -----
08:14:56 <clrnd> shock_one, but actually when you render you give it a length, default is 100
08:15:12 <shock_one> Ah, that length.
08:15:12 <clrnd> http://hackage.haskell.org/package/pretty-1.0.1.1/docs/Text-PrettyPrint-HughesPJ.html#v:render
08:15:43 <yitz> Yuras: david abraham - you mean about the ability to reason about exception?
08:15:53 <Yuras> yitz: yes
08:16:09 <Yuras> note: I'm not an expert here
08:16:35 <Yuras> but I see nobody who cares, so I start caring :)
08:17:03 <batchm> @src filter
08:17:03 <lambdabot> filter _ []     = []
08:17:03 <lambdabot> filter p (x:xs)
08:17:03 <lambdabot>     | p x       = x : filter p xs
08:17:03 <lambdabot>     | otherwise = filter p xs
08:17:42 <Yuras> err I start worrying
08:18:37 <alpounet> Yuras: is that all related to the bracket discussion on libraries@ ?
08:19:05 <Yuras> alpounet: it was, but now it is much wider I think. at least for me
08:19:07 <yitz> Yuras: oh ok yeah i see now your reddit link to that article.
08:19:52 <yitz> Yuras: just curious - why does there seem to be no mention of ResourceT in this discussion, whose whole purpose is to make it easy to provide those guarantees?
08:21:03 <alpounet> yitz: have you seen the length of the discussion? it's only about a single function. and you want to bring in a whole package? :p
08:21:04 <Yuras> because ResourceT is a just tool that simplifies exception handling
08:21:31 <Yuras> you can't use it correctly if you don't know what is exception safety
08:21:58 <Yuras> yitz: also https://github.com/Yuras/io-region/wiki/Overview-of-resource-management-in-Haskell
08:22:13 <yitz> Yuras: it is a monad that allows you to provide the guarantee that resources will be released in the presence of exceptions. isn't that what we're talking about?
08:22:41 <yitz> Yuras: ResourceT was invented precisely because bracket does not provide that guarantee.
08:23:04 <Yuras> yitz: it is that in 90% cases, but there are harder cases
08:23:29 <yitz> alpounet: a "whole package"? it's very simple. but yes, it's in a package. should it not have been placed in a package?
08:24:06 <Yuras> resourcet doesn't solve the issue with async exception magically
08:24:16 <alpounet> yitz: i meant that a single function caused a very lengthy bikeshedding, let alone what that would be if you bring many more in the scope of the discussion
08:25:18 * hackagebot fswatcher 0.1.2 - Watch a file/directory and run a command when it's modified  http://hackage.haskell.org/package/fswatcher-0.1.2 (ErlendHamberg)
08:25:55 <yitz> alpounet: ok i see. it's not "many more". it's just a simple monad, where you run a calculation, and provide a function to clean up in case there is an exception.
08:26:57 <ski> chrisdone : hm, perhaps not with an annotating preprocessing pass
08:27:48 <alpounet> yeah I know, i've used resourcet. it's just that the chances of the discussion converging to a solution would be even smaller. and people will just argue that since resourcet is not in base, that'll still leave bracket broken etc
08:29:12 <carter> alpounet: the discussion seems to have converted on making bracket fixed though right/
08:29:14 <yitz> Yuras: i don't know about magic. but that's the problem it intends to solve.
08:29:22 <carter> alpounet: did you see that we can add compex-storable to base now :)
08:30:28 <Yuras> yitz: IIRC it resourcet doesn't use uninterruptibleMask, so it doesn't solve the issue the proposal is trying to solve
08:30:33 <yitz> alpounet: it might lower the volume of people
08:31:18 <Yuras> but if resourcet uses it, then that is bad idea
08:31:19 <orion> tdammers: Why is a type class inappropriate for my intended usage?
08:31:30 <tdammers> orion: not inappropriate, but overkill
08:31:36 <Yuras> (IMO everything)
08:34:54 <chrisdone> ski: that could be cool
08:35:15 <chrisdone> ski: probably easy to do an annotation generically with some syb
08:35:44 <phaazon> hm, ghc-mod causes my gvim buffer to be REALLY slow; is this a well known issue?
08:36:38 <mads-> Can anyone recommend a good tutorial to learn parsec?
08:36:41 <clrnd> phaazon, when exactly?
08:37:10 <phaazon> clrnd: when scrolling up/down huge load of code
08:37:20 <orion> tdammers: I see. I noticed that type classes usually require all its functions to have a unary argument (the type class parameter). Why is this so?
08:37:22 <phaazon> if I remove the ghcmod-vim
08:37:29 <phaazon> it gets fast back
08:37:31 <alpounet> carter: i'm not sure we can say the discussion has converged on anything yet :p and yeah i've seen complex-storable. that's good news for numerical right?
08:37:48 <tdammers> orion: they don't, really, but the parameter needs to be part of all function sigs IIRC
08:37:58 <clrnd> mads-, sorry, saw you question before and forgot about it: https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/attoparsec and http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing
08:38:00 <orion> tdammers: I see.
08:38:10 <tdammers> and it has to because otherwise the type checker cannot determine the correct instance for any given call
08:38:24 <tdammers> e.g., suppose you have class Foobar a where foo :: Int
08:38:33 <orion> That makes sense. If type classes are inappropriate for my intended usage, when *are* type classes recommended?
08:38:34 <phaazon> hm, I guess it’s not linked to that actually
08:38:41 <clrnd> phaazon, I thought ghc-mod only provided some commands to be run, it shouldn't slow down anything
08:38:42 <phaazon> my gvim is still slow
08:38:46 <phaazon> yeah
08:38:50 <phaazon> that’s weird
08:38:58 <clrnd> :P
08:39:21 <clrnd> try console vim or disabling some plugins
08:39:34 <phaazon> console vim is awful
08:39:44 <phaazon> gvim is usually faster
08:39:53 <tdammers> orion: when you need things to be polymorphic at compile time
08:39:54 <clrnd> phaazon, that's just, like, you opinion :P
08:40:00 <tdammers> phaazon: lolwut?
08:40:00 <clrnd> your*
08:40:06 <yitz> Yuras: you're right, i just checked. resourcet uses mask, not uninteruptibleMask.
08:40:09 <tdammers> gvim is terrible
08:40:12 <phaazon> clrnd: I used vim -nw for a while
08:40:29 <tdammers> of course, vim is slow if your terminal is slow
08:40:35 <phaazon> yeah
08:40:38 <phaazon> I use urxvt
08:40:43 <chrisdone> urxvt is fast
08:40:47 <Yuras> yitz: hmm, that is the first time someone agreed with me in this discussion lol
08:40:49 <tdammers> should be, yeah
08:41:02 <chrisdone> i once did a wee benchmark of urxvt, gnome-terminal and xterm
08:41:13 <chrisdone> the only slow one was xterm. gnome-terminal and urxvt are competitive on speed
08:41:23 <tdammers> chrisdone: should have included CoolOldTerm in the comparison
08:41:25 <orion> tdammers: Ok, cool. Thank you very much for your assistance!
08:41:28 <tdammers> orion: np
08:41:48 <mads-> clrnd: don't worry about it :) attoparsec instead of parsec - is that just fine enough? :)
08:41:55 <phaazon> ok
08:41:59 <yitz> Yuras, alpounet: so the point of resourcet is to help manage multiple resources that need to live in various scopes. but the actual logic of cleaning them up is just using the haskell default and not addressing this issue.
08:42:03 <phaazon> I’m gonna try urxvt+vim back then
08:42:31 <L8D> omg
08:42:34 <alpounet> yitz: and would hence benefit from any improvement to the matter at hand in that discussion?
08:42:42 <L8D> someone needs to build a terminal emulator in Haskell
08:42:47 <L8D> to replace urxvt
08:42:48 <phaazon> god no
08:42:51 <phaazon> still awfullà slow
08:42:57 <phaazon> awfully
08:43:00 <L8D> phaazon: why would it be slow?
08:43:07 <phaazon> I have no idea
08:43:10 <chrisdone> mark jones is working on a webkit terminal
08:43:12 <phaazon> when I scroll instances
08:43:15 <chrisdone> well, it's a browser terminal
08:43:16 <phaazon> it’s getting very slow
08:43:17 <yitz> alpounet: um well it doesn't use bracket. in fact, it defines its own bracket. the primitive it is based upon is mask.
08:43:25 <L8D> phaazon: urxvt?
08:43:29 <chrisdone> but i think you could just use webkit and skip the JS
08:43:33 <phaazon> L8D: yes
08:43:38 <phaazon> maybe it’s because of my haskell.vim
08:43:41 <phaazon> from vim2hs
08:44:03 <L8D> phaazon: why is this urxvt
08:44:08 <L8D> urxvt's fault?
08:44:16 <phaazon> I don’t think so now
08:44:20 <phaazon> since gvim is slow as well
08:44:20 <L8D> and why would writing a term emulator in Haskell be so much slower?
08:44:21 <chrisdone> oh, not mark jones, mark leczner (can't spell his name)
08:44:33 <alpounet> yitz: oh ok so any improvement would have to be ported to resourcet too
08:44:51 <L8D> if someone writes a term emulator in Haskell then my entire work environment would be haskell-powered
08:44:57 <chrisdone> terminal speed is all about the cleverness of the update algorithm
08:44:59 <yitz> L8D: urxvt certainly has plently of ways to be improved. it's flexible, it provides unicode support. but configuring it is very very arcane.
08:45:17 <L8D> I guess I'd need an IRC client in Haskell too
08:45:20 <chrisdone> yitz: in what way is unicode support notable for urxvt?
08:45:28 <chrisdone> i don't know a terminal that doesn't do that
08:45:33 <L8D> but otherwise I'd be using xmonad + haskell-term + yi
08:45:45 <L8D> chrisdone: xterm?
08:45:47 <L8D> chrisdone: rxvt?
08:45:50 <yitz> alpounet: yeah i guess so. and that could only be done by hunting down everything that uses it and re-thinking the semantics
08:45:56 <yitz> alpounet: like for bracket.
08:46:01 <chrisdone> xterm supports unicode
08:46:06 <chrisdone> and antialiasing
08:46:10 <phaazon> who else uses haskell.vim from vim2hs here?
08:46:11 <L8D> that's uxterm hunny
08:46:29 <yitz> chrisdone: could be not notable anymore. when it was invented, rxvt was 8-bit.
08:46:33 * davidfetter wonders how low in the stack haskell could be in a linux distro
08:46:51 <chrisdone> mmk
08:46:55 <L8D> davidfetter: pretty low
08:46:58 <chrisdone> well i'm using emacs which supports multiplexing
08:47:01 <chrisdone> two windows at once!
08:47:02 <L8D> davidfetter: like as low as systemd
08:47:02 <alpounet> yitz: uh... well, i guess that won't happen before a long time :p
08:47:13 <davidfetter> L8D, has anybody done a linux distro on this basis?
08:47:30 <alpounet> davidfetter: did you read about the driver written in haskell?
08:47:34 <L8D> davidfetter: no but I believe nixos is going to be the target platform for haskell dev
08:47:41 <davidfetter> alpounet, i had not
08:47:46 <L8D> because with nixos you can replace anything with anything else
08:47:47 <davidfetter> nixos?
08:47:51 <L8D> NixOS
08:47:54 <chrisdone> i think johnw was rewriting nix in haskell
08:47:56 * davidfetter googles
08:48:10 <yitz> chrisdone: but it does define multiple input methods besides those of your OS (from the days when there weren't very many good input methods), and it does provide ways of mapping arbitrary key combinations to arbitrary unicode sequences.
08:48:19 <alpounet> davidfetter: http://www.reddit.com/r/haskell/comments/1y9el0/rewrite_netbsd_kernel_driver_using_ajhc_haskell/
08:48:22 <L8D> so you could build your own Haskell-based init system and swap out systemd (or whatever nixos uses by default) with it
08:48:29 <alpounet> davidfetter: this links to a video that explains it all
08:48:42 <alpounet> that was for a netbsd kernel though
08:48:52 <phaazon> ok, I really don’t get why is that so slow
08:49:01 <davidfetter> just wow
08:49:18 <L8D> phaazon: probably because it is trying to do some crazy shit with ghc everytime you make a change
08:49:47 <phaazon> I don’t make any change
08:49:48 <davidfetter> at scale, systemd has issues i'd rather not deal with. haven't run into any on my desktop, but that's not where they'd manifest
08:49:51 <phaazon> I’m just scrolling
08:49:56 <yitz> chrisdone: emacs has ^X 8 RET which is nice
08:50:07 <L8D> davidfetter: I was just saying that was how low you could practically go
08:50:16 <L8D> davidfetter: not that there exists a haskell init system
08:50:38 <davidfetter> L8D, understood
08:50:46 <chrisdone> yitz: and describe-char, etc. <3
08:50:52 <yitz> chrisdone: right :)
08:51:01 <phaazon> I’m pretty sure it’s because of the syntax coloration
08:51:34 <phaazon> yeah…
08:51:39 <phaazon> :set syntax=
08:51:46 <phaazon> everything gets fast again
08:51:47 <phaazon> :(
08:52:01 <chrisdone> phaazon: you're just delying your transfer to emacs. why wait?
08:52:16 <L8D> nonono
08:52:18 <davidfetter> i thought there was an editor written in haskell
08:52:18 * chrisdone puts on his salesman hat
08:52:20 <L8D> don't use emacs
08:52:22 <L8D> use yi
08:52:23 <phaazon> I already transfered from emacs to vim ;)
08:52:28 <phaazon> ahah yi
08:52:30 <phaazon> I tried it
08:52:31 <L8D> for the love of all things sacred
08:52:36 <phaazon> I opened a huge file
08:52:44 <phaazon> it actually never opened :D
08:52:48 <L8D> yi might be very uncomfortable at first
08:52:52 <chrisdone> i opened a normal file and yi was sluggish and didn't do anything
08:52:57 <phaazon> yeah ahah
08:53:03 <L8D> but the more you use it, the more you'll get used to it and the further you will advance the project
08:53:09 <chrisdone> i support the effort but it's hard to encourage people to use it atm
08:53:28 <L8D> yi won't ever get close to emacs or vim unless more people go through the pain of using it
08:53:38 <phaazon> ok, I have my answer
08:53:39 <phaazon> http://nochair.net/posts/2013/03-01-hasksyn-haskell-syntax-for-vim.html
08:53:50 <chrisdone> L8D: it won't get close to emacs
08:53:52 <L8D> phaazon: how large of a file did you open?
08:54:00 <phaazon> not that large actually
08:54:03 <phaazon> 500 lines?
08:54:14 <L8D> phaazon: I can open 2000 line haskell files just fine
08:54:26 <L8D> and I'm using the cheapest hardware available from 2007
08:54:32 <f-a> longshot, some time ago I read a paper (it was an old paper) which, among other things, stated that synctactically significant whitespace was a must for a modern functional language. Any idea which one was it (or other papers/articles dealing with similar matters)?
08:54:33 <L8D> :s/from/in
08:54:58 <chrisdone> f-a: syntactically significant whitespace makes it a PITA to make editor support for
08:55:38 <f-a> chrisdone: yeah, I was puzzled a bit too, that's why I wanted to reread it to get *why* it was a must in the opinion of the writer
08:55:45 <f-a> maybe he got tired of typing ()
08:58:03 <yitz> chrisdone: but urxvt has "feedback mode" which is kind of like dynamic describe-character as you move the mouse around
09:01:12 <chrisdone> yitz: cool
09:04:46 <EvanR> f-a: im not tired of writing ( ) because the editor does it for me, now im tired of reading them ;)
09:05:18 * hackagebot sequent-core 0.1.0.0 - Alternative Core language for GHC plugins  http://hackage.haskell.org/package/sequent-core-0.1.0.0 (pdownen)
09:05:58 <f-a> haha EvanR
09:06:07 <carter> alpounet: it doesn't matter per se, but it just makes for a better UX for new users
09:07:35 <carter> woaaaaa
09:10:08 <red__> is there something essentially wrong with the following?
09:10:14 <red__> getsquares rs = (take 3 rs) ++ (getsquares $ drop 3 rs)
09:10:28 <red__> even if i cover getsquares [] = [] ?
09:10:30 <thungsten> is haskell.org down?
09:10:48 <red__> i'm trying (roughly) to grab chunks of a list 3 at a time
09:11:24 <EvanR> :t chunkBy
09:11:24 <lambdabot>     Not in scope: ‘chunkBy’
09:11:24 <lambdabot>     Perhaps you meant ‘chunk’ (imported from Data.List.Split)
09:11:28 <ChristianS> thungsten: either down or veeery slow...
09:11:29 <EvanR> :t chunk
09:11:30 <lambdabot> Int -> [e] -> [[e]]
09:11:43 <alpounet> that's from the 'split' package
09:11:58 <thungsten> ChristianS: ahw man :(
09:12:17 <red__> aha! i even used the word 'chunks' . great stuff
09:12:36 <red__> the split package?
09:12:38 <yitz> f-a: maybe this, from 1965? see section 6. http://www.math.bas.bg/bantchev/place/iswim/next700.pdf
09:13:18 <phaazon> hm
09:13:27 <phaazon> I guess my issue might be related to my graphic card
09:13:31 <phaazon> that’s weird
09:13:48 <phaazon> I’m gonna try on the GPU, not the iGPU
09:15:28 <f-a> mhhh not it, but nontheless a nice read yitz
09:16:50 <dutchie> poor haskell.org "Can't contact the database server: Too many connections (localhost)"
09:17:02 <SpaghettiCat> Good evening, I was wondering why, even though Haskell is 17 years older than Clojure, Clojars has 50% more modules than Hackage. Does anyone have any theories?
09:17:33 <EvanR> clojure has java momentum behind it
09:18:09 <SpaghettiCat> EvanR:  Do you mean to say it's easier to write clojure libs because of all the existing Java libs?
09:18:36 <EvanR> no theres more people who became interested in clojure because they were using java and hated it that much
09:18:37 <alpounet> SpaghettiCat: i'd say the exposure is greater when you run on the jvm
09:18:54 <alpounet> scala benefitted from that too
09:20:13 <EvanR> maybe haskell has benefited from clojure and scala exposing "industrial" programmers to functional programming
09:20:18 * hackagebot clash-prelude 0.6 - CAES Language for Synchronous Hardware - Prelude library  http://hackage.haskell.org/package/clash-prelude-0.6 (ChristiaanBaaij)
09:20:20 * hackagebot clash-lib 0.4 - CAES Language for Synchronous Hardware - As a Library  http://hackage.haskell.org/package/clash-lib-0.4 (ChristiaanBaaij)
09:20:22 <simpson> SpaghettiCat: Clojure wants users. Haskell doesn't want users. We're talking about "simple made easy" vs. "avoid success at all costs."
09:20:41 <SpaghettiCat> Ahh I see, so Clojure is more popular then? Hmm yet #haskell has twice the users of #clojure. And on the TIOBE index Haskell is significantly ahead of Clojure
09:21:20 <alpounet> SpaghettiCat: well, a lot of people are intrigued by haskell. the number of actual, regular users is however probably lower
09:21:30 <SpaghettiCat> simpson:  "avoid success at all costs". You mean haskell is actively trying to stay obscure?
09:21:44 <EvanR> it was at one point
09:21:44 <alpounet> SpaghettiCat: no. avoid (success at all costs)
09:22:18 <SpaghettiCat> alpounet:  umm Haskell is trying to avoid being successful?
09:22:25 <marchelzo_> Could it also be that haskellers tend to use what is already available rather than create their own version of some library?
09:22:34 <phaazon> ok, I guess I’ll just use the default vim syntax hilighting
09:22:36 <alpounet> SpaghettiCat: no, it avoids doing that at any price
09:22:38 <simpson> SpaghettiCat: It's an unofficial slogan of SPJ.
09:22:40 <phaazon> vim2hs, hasksyn
09:22:44 <phaazon> they’re all pretty bad
09:22:57 <SpaghettiCat> ahh I see
09:23:04 <simpson> It means that Haskell is not trying to attract users if it means bending what the language does.
09:23:34 <simpson> Clojure, on the other hand, inherits from Lisp and has (among other things) the philsophy that bending the language is appropriate and should be done any time that one feels like it.
09:23:58 <alpounet> SpaghettiCat: the idea being that things are not done because they'll seduce potential enterprisey consumers. they're done because they're right
09:25:04 <SpaghettiCat> Hmm I see. I didn't know Lisp tried to make itself more user-friendly and become more attractive for enterprise
09:25:18 * hackagebot clash-ghc 0.4 - CAES Language for Synchronous Hardware  http://hackage.haskell.org/package/clash-ghc-0.4 (ChristiaanBaaij)
09:25:31 <EvanR> everything on jvm is this way
09:25:42 <simpson> SpaghettiCat: It doesn't have anything to do with the enterprise.
09:25:44 <clrnd> mads-, I don't remember anything atto-specific in FP's complete article
09:25:46 <yitz> EvanR: haskell was never actually trying to avoid success intentionally. that was a joke.
09:26:02 <clrnd> mads-, I recommend reading the original paper too, it's really friendly
09:26:22 <Denommus> SpaghettiCat: Lisp is not meant to be user-friendly. It's meant to be reprogramable
09:26:44 <simpson> yitz: "When a language becomes too well known, or too widely used and too successful suddenly you can’t change anything anymore. You get caught and spend ages talking about things that have nothing to do with the research side of things. Success is great, but it comes at a price." ~ SPJ
09:26:44 <Denommus> also, I don't think Clojure's FP is equivalent to Haskell's
09:27:04 <yitz> simpson: ah, so that's why they use so many of those curved brackets. to hint that you should bend the language.
09:27:28 <simpson> yitz: Historical typesetting choice, just like the colors on red-black trees and the lambda in lambda calculus.
09:28:02 <simpson> Anyway, none of this is good or bad. It just is.
09:28:25 <SpaghettiCat> You make it sound like haskell language updates are prone to badly break code
09:28:45 <clrnd> that SPJ's is really accurate, I think that's one of Haskell's maine features
09:28:55 <clrnd> main*
09:29:08 <EvanR> being able to break backwards compatibility is good
09:29:12 <Denommus> SpaghettiCat: no, but it may happen
09:29:13 <clrnd> I'd prefer if the do!
09:29:24 <Denommus> SpaghettiCat: the next GHC won't be retrocompatible
09:29:46 <clrnd> didn't know that, because of Applicative => Monad?
09:29:55 <Denommus> clrnd: yes
09:29:59 <SpaghettiCat> That won't help with the module-count numbers in Hackage because of how much has to be ported to the new GHC
09:29:59 <clrnd> nice :D
09:30:10 <Denommus> clrnd: for now, if you create a Monad that isn't an Applicative, you just get a warning
09:30:17 <Denommus> clrnd: the next version will throw an error
09:30:33 <Denommus> SpaghettiCat: nah, most things are already compatible
09:30:50 <EvanR> SpaghettiCat: that was one possible reason i was going to give for package numbers being lower, because of historically frequent non backwards compatible changes. but im not sure if any are removed for that reason, they just break
09:30:51 <clrnd> SpaghettiCat, I prefer a handful of awesome modules to a billon of not-so-good modules
09:30:52 <k00mi> SpaghettiCat: it's a rather minor change and there has been a warning for a while
09:30:52 <Denommus> SpaghettiCat: the "monad must be an  applicative" issue is known for a long time now
09:31:30 <yitz> simpson: spj was remarking about a somewhat humorous paradox about his research. the point was to demonstrate that a purely functionaly language could be made practical enough to be successful. but he realized that the success itself would make it harder to do the research.
09:31:35 <Denommus> and it's quite easy to adapt
09:32:16 <SpaghettiCat> clrnd:  TWisted is an awesome module for Python, but it's been like 5+ years and it's still not ported to Py3
09:32:40 <simpson> yitz: He was also professing his choice to approach the problem by avoiding situations which would hurt the language while improving its adoption.
09:32:59 <clrnd> SpaghettiCat, I've been bit by that, and I think that's related to the mutabile aspect of python
09:33:02 <simpson> SpaghettiCat: The package is ported. Come to #python or #twisted if you want to talk about it.
09:33:13 <clrnd> mutable*
09:33:46 <clrnd> but his case stands, a lot of python2 modules aren't ported yet, and the work for porting a package is still pretty big
09:34:15 <Denommus> fmap can be written as fmap f foo = foo >>= return . f anyway
09:34:47 <red__> i have a [[Int]] which represents a 9x9 grid by ROWS and want a [[Int]] which is a list of 3x3 blocks (ie sudoku) and am having trouble. anyone have any ideas for a list problem like this? i've dabbled with using splt and drop with recursion and using chunkBy
09:34:52 <SpaghettiCat> simpson:  I don't think it's done just yet: https://twistedmatrix.com/trac/milestone/Python-3.x
09:35:18 * hackagebot clash-prelude 0.6.0.1 - CAES Language for Synchronous Hardware - Prelude library  http://hackage.haskell.org/package/clash-prelude-0.6.0.1 (ChristiaanBaaij)
09:35:23 <yitz> red__: you want the output to be [[Int]] or [[[Int]]] ?
09:35:42 <EvanR> red__: curiously theres an entire library of examples https://www.haskell.org/haskellwiki/Sudoku
09:36:03 <red__> yitz: [[Int]]
09:36:17 <clrnd> I bet that porting packages between GHC releases is considerably easier than between py2 and py3
09:36:35 <simpson> SpaghettiCat: #python or #twisted please.
09:37:13 <carter> alpounet: you should do an email to my numerical list aking others for their experiences using AD + NN
09:38:05 <red__> EvanR: thanks .. i was avoiding that page and trying to go ground up .. but i just found a nice list comprehension for the same problem which will take me a few years to understand .. thanks
09:39:18 <yitz> > map (map concat . transpose) . chunksOf 3 . map (chunksOf 3) $ chunksOf 9 [1..81] -- red__
09:39:19 <lambdabot>  [[[1,2,3,10,11,12,19,20,21],[4,5,6,13,14,15,22,23,24],[7,8,9,16,17,18,25,26,...
09:39:43 <red__> oh wow
09:40:05 <red__> :t transpose
09:40:06 <lambdabot> [[a]] -> [[a]]
09:40:21 <vanila> > let p n = concat . transpose . chunksOf n in p 5 . p 3 $ [1..30]
09:40:23 <lambdabot>  [1,16,2,17,3,18,4,19,5,20,6,21,7,22,8,23,9,24,10,25,11,26,12,27,13,28,14,29,...
09:42:00 <red__> > chunksOf 9 [1..81]
09:42:01 <lambdabot>  [[1,2,3,4,5,6,7,8,9],[10,11,12,13,14,15,16,17,18],[19,20,21,22,23,24,25,26,2...
09:42:56 <red__> ok those are my rows .. then i get a 3 lists containing 3 rows each ([[Int]]) ..
09:44:48 <red__> > map (chunksOf 3) $ chunksOf 9 [1..81]
09:44:50 <lambdabot>  [[[1,2,3],[4,5,6],[7,8,9]],[[10,11,12],[13,14,15],[16,17,18]],[[19,20,21],[2...
09:44:56 <yitz> red__: the second step is 9 rows of 3 groups of 3.
09:45:13 <red__> yeah i was off
09:52:26 <yitz> red__: so my function doesn't quite do what you asked. i think this fixes the problem:
09:52:29 <yitz> > concatMap (map concat . transpose) . chunksOf 3 . map (chunksOf 3) $ chunksOf 9 [1..81]
09:52:30 <lambdabot>  [[1,2,3,10,11,12,19,20,21],[4,5,6,13,14,15,22,23,24],[7,8,9,16,17,18,25,26,2...
09:52:54 <tolt> bitemyapp: I liked your how I start article but have you seen https://hackage.haskell.org/package/hi ?
09:52:54 <yitz> red__: i changed the map at the beginning to concatMap. now the type is correct
09:53:08 <yitz> @type concatMap (map concat . transpose) . chunksOf 3 . map (chunksOf 3)
09:53:09 <lambdabot> [[a]] -> [[a]]
09:54:06 <red__> yitz: thanks .. i added a concat at the end of your original composition and got .. i believe .. what i was looking for
09:54:21 <bitemyapp> tolt: yes I have.
09:54:28 <yitz> red__: yeah, sorry about that.
09:54:28 <red__> is that equivalent to this new jazz?
09:54:31 <bitemyapp> tolt: it's neat, but people need to know the what/why/where of things.
09:54:55 <tolt> Alright. I just always feel like it's incredibly unused.
09:55:06 <bitemyapp> I think you're probably right
09:55:10 <red__> i like your solution a lot .. especially the map (map concat . transpose) part .. thanks for the help
09:55:16 <bitemyapp> one problem is I wasn't sure if it had full templating.
09:55:16 <yitz> red__: could be. interesting question. does it give the right answer?
09:56:00 <tolt> Yeah. It does. You can make your own templates and change where it pulls the template from
09:56:25 <tolt> It has things like $packageName, $moduleName, etc
09:56:49 <Darwin226> Hey guys, what's wrong with this piece of code? https://gist.github.com/adad6d9b8641f288ebbd
09:57:08 <Darwin226> It says it expects Int -> b but the actual type is Int -> Int
09:57:12 <Darwin226> on the hash = id line
09:57:15 <tolt> and now that I think about it using hi would be a bad way to start.
09:57:21 <red__> yitz: yeah it looks pretty good
10:01:51 <bitemyapp> tolt: yeah :)
10:02:00 <bitemyapp> tolt: it's a good suggestion though for killing unnecessary work.
10:02:47 <amf> are there official hackage upload guidelines?
10:04:13 <askdjaskld> Hi could someone let me know how to get rid of the parenthesis from line 3 of this snippet? http://ideone.com/guY7fN
10:05:49 <crobbins> askdjaskld: i don't think there is a good way
10:06:05 <askdjaskld> ok thanks was just wondering.. going through learn you a haskell atm
10:06:08 <linduxed> askdjaskld: without having ghci to test it in i guess you could do it like this:
10:06:12 <crobbins> askdjaskld: what about a reimplementation
10:06:30 <linduxed> askdjaskld: length' x = (+) 1 $ length' $ tail x
10:06:39 <linduxed> but that didn't improve readability, i think
10:06:46 <yitz> @pl length' x = 1 + (length' $ tail x) -- askdjaskld
10:06:46 <lambdabot> length' = fix (((1 +) .) . (. tail))
10:07:33 <yitz> askdjaskld: oh. did you really mean for length' to be recursive like that?
10:07:53 <askdjaskld> don't really mean for anything. just exploring stuff and trying to learn heh
10:07:56 <crobbins> askdjaskld: sum . map (const 1)
10:08:03 <crobbins> but you still have parens :)
10:08:05 <Denommus> whoa, that syntax highlight is really, really bad
10:08:18 <yitz> @pl sum . map (const 1)
10:08:18 <lambdabot> sum . map (const 1)
10:09:06 <crobbins> askdjaskld: how about: succ . length . tail
10:09:42 <crobbins> or rather: succ . length' . tail
10:09:52 <Denommus> crobbins: I would suggest just that
10:09:59 <Denommus> length' = succ . length' . tail
10:10:02 <askdjaskld> oh yeah i meant to ask that too. how can i get it so that it doesn't need an x parameter. i'm trying to curry it but because of the previous line it says argument count mismatch
10:10:05 <Denommus> nice and readable
10:10:20 <askdjaskld> i guess i could remove the previous line now but what if i couldn't? is there any way around that?
10:10:42 <L8D> @hoogle MonadIO
10:10:42 <lambdabot> Network.CGI class Monad m => MonadIO (m :: * -> *)
10:10:42 <lambdabot> Control.Monad.IO.Class class Monad m => MonadIO m
10:10:42 <lambdabot> package monadIO
10:11:17 <crobbins> > let length' [] = 0 ; length' xs = succ . length' . tail $ xs in length' [1..10]
10:11:19 <lambdabot>  10
10:11:41 <crobbins> > let length' [] = 0 ; length' = succ . length' . tail in length' [1..10]
10:11:43 <lambdabot>  Equations for ‘length'’ have different numbers of arguments
10:11:43 <lambdabot>    <interactive>:1:5-18
10:11:43 <lambdabot>    <interactive>:1:22-52
10:11:45 <Denommus> let length' [] = 0; length' = succ . length' . tail in length' [1..10]
10:11:47 <crobbins> yeah, figured that'd happen
10:11:48 <Denommus> > let length' [] = 0; length' = succ . length' . tail in length' [1..10]
10:11:50 <lambdabot>  Equations for ‘length'’ have different numbers of arguments
10:11:50 <lambdabot>    <interactive>:1:5-18
10:11:50 <lambdabot>    <interactive>:1:21-51
10:11:58 <Denommus> hm
10:12:02 <crobbins> yep, you can't do it point free since you have to pattern match
10:12:24 <askdjaskld> oh ok that's good to know
10:12:35 <Denommus> there's... other approach
10:14:32 <novick> test msg
10:15:21 <Denommus> askdjaskld: let length' = foldr (+) 0 . map (\_ -> 1)
10:15:52 <askdjaskld> lol so many ways to do something
10:15:55 <askdjaskld> not sure if that's good or bad
10:16:00 <Industrial> Hi. Is there a known well way to support haskell in vim? A setup that a majority of haskell users that use vim use?
10:16:12 <Industrial> (besides just syntax highlighting support)
10:16:21 <yitz> @pl let f g x = if null x then 0 else succ . g $ tail x in fix f [1..3]
10:16:21 <lambdabot> fix (ap (flip if' 0 . null) . (. tail) . (succ .)) [1..3]
10:16:37 <Denommus> askdjaskld: oh, I know!
10:16:39 <yitz> @pl let f g x = if null x then 0 else succ . g $ tail x in fix f
10:16:39 <lambdabot> fix (ap (flip if' 0 . null) . (. tail) . (succ .))
10:16:48 <clrnd> Industrial, personally I just use ghc-mod, and manually run GhcModCheck from time to time
10:16:50 <Denommus> askdjaskld: no, wait, it wouldn't work
10:16:50 <yitz> > let f g x = if null x then 0 else succ . g $ tail x in fix f [1..3]
10:16:52 <lambdabot>  3
10:16:58 <clrnd> but there are cooler things you can do
10:18:02 <Industrial> clrnd: okay
10:18:59 <ReinH> Industrial: This was my setup when I used vim http://haskelllive.com/environment.html
10:19:21 <Industrial> thanks!
10:19:27 <ReinH> Industrial: you might also look at https://github.com/begriffs/haskell-vim-now and http://www.stephendiehl.com/posts/vim_haskell.html
10:19:41 <Industrial> I've yet to start writing any substantial haskell beyond examples but being prepared is always nice
10:20:13 <ReinH> Never too early to start!
10:21:23 <Industrial> I'm looking for alternatives to eventually replace Node.JS backend TCP/HTTP/Websocket services :)
10:22:35 <athan> Are doubly-linked BTrees ever useful for parsing?
10:22:48 <ReinH> Industrial: Haskell is pretty good at that
10:23:08 <athan> Industrial: I've been hitting project euler, that's been helping me
10:24:48 <mads-> ReinH: Wow, looking at your episode one makes me realize how much vim I still need to learn :O
10:24:59 <ReinH> mads-: I've been using vim for a while :)
10:25:37 <Industrial> ReinH, athan; I also just found http://chimera.labs.oreilly.com/books/1230000000929/index.html :)
10:25:52 <ReinH> Industrial: that's a great book :)
10:28:18 <sinelaw> hi. is there in logic or type theory a concept of quantor variables, for example "variable X is quantified by  quantor Q" where Q may turn out to be universal or some other quantifier?
10:28:20 <athan> Industrial: I still need to read that haha. Bird & Wadler's intro to functional programming is really helpful for me to get the abstract concepts (if you need the help :P)
10:30:44 <benzrf> sinelaw: oh that's interesting
10:31:10 <benzrf> sinelaw: well, i'd assume that anything that models predicate logic has to model quantifiers somehow
10:31:47 * benzrf considers coq
10:32:01 <sinelaw> benzrf, the idea is from some kind of  type inference, where a type variable may be quanitfied but it isn't yet known if it is or isn't
10:32:10 <benzrf> huh
10:33:10 <sinelaw> benzrf, but i'm interested in finding out if this is really a studied concept in some field
10:35:13 <benzrf> sinelaw: interesting
10:36:06 <sinelaw> Peaker's idea really
10:39:06 <sinelaw> you can call it quantification over quantifiers
10:39:59 <sinelaw> maybe it's just second order logic
10:55:18 * hackagebot takusen-oracle 0.9.1 - Database library with left-fold interface for Oracle.  http://hackage.haskell.org/package/takusen-oracle-0.9.1 (PavelRyzhov)
10:55:36 <red__> confusion : i have a [(Int,Maybe Int)] and want [Int] s.t. all the result integers were the fst of a tuple that was 'Nothing' ..
10:55:55 <red__> trying to use filter with (snd == Nothing) but ghci is exploding
10:56:03 <vanila> map fst . filter isNothing
10:56:09 <red__> :t isNothing
10:56:10 <vanila> where isNothing = not . isJust
10:56:10 <lambdabot> Maybe a -> Bool
10:56:16 <vanila> oh
10:56:21 <vanila> filter (isNothing . snd)
10:56:30 <red__> woah
10:56:33 <red__> thx
10:57:00 <red__> in Data.Maybe ?
11:10:18 * hackagebot parsek 1.0.1.1 - Parallel Parsing Processes  http://hackage.haskell.org/package/parsek-1.0.1.1 (JeanPhilippeBernardy)
11:10:20 * hackagebot parsek 1.0.1.2 - Parallel Parsing Processes  http://hackage.haskell.org/package/parsek-1.0.1.2 (JeanPhilippeBernardy)
11:11:16 <Taneb> http://lpaste.net/114454 I am an evil evil person
11:13:24 <EvanR> evolution of a haskell programmer
11:14:02 <Taneb> EvanR, pretty much :)
11:14:24 <EvanR> so type families basically give you a total functional language? or no because UndecidableInstances
11:15:09 <clrnd> why is it you have both I and O?
11:15:38 <Taneb> clrnd, it's binary
11:15:45 <Taneb> I = 1 digit, O = 0 digit
11:16:04 <clrnd> oh I though of peano numbers first
11:16:06 <clrnd> that makes sense
11:16:15 <Taneb> Peano numbers are soooo much slower
11:16:28 <EvanR> how does print work on these, automatic deriving Show?
11:16:38 <Taneb> EvanR, I have a Proxy n -> Int function
11:16:39 <clrnd> optimized type level programming lol
11:16:50 <Taneb> See the Untype class
11:16:51 <EvanR> ah
11:17:01 <EvanR> use trinary, its even faster
11:17:04 <EvanR> jk
11:17:07 <Taneb> Don't tempt me
11:17:11 <clrnd> they say decimal is fast too
11:17:29 <EvanR> base-omega
11:18:45 <Taneb> I had one that used Peano numbers, but GHC gave up trying to do 6!
11:18:58 <Taneb> Fiddling with options and after a while it managed it
11:19:03 <Taneb> I wasn't patient enough for 7!
11:19:33 <NikolajK> sinelaw: You say "quantified or not", but before you seemed to have meant that you just don't know which quantier your dealing with
11:19:39 <vanila> it should be calculated in binary
11:19:46 <vanila> unary isn't good for large numbers
11:20:13 <Taneb> vanila, did you see my program?
11:20:38 <vanila> no
11:20:50 <Taneb> http://lpaste.net/114454
11:20:52 <Taneb> It uses binary
11:21:37 <sinelaw> NikolajK, true, including the "null quantifier"
11:22:03 <NikolajK> that doesn't make any sense, because then the two expressions have different amount of bound variables
11:22:18 <NikolajK> either it's closed and it's a proposition, or it's just a well formed expression
11:23:08 <NikolajK> Aslo, \forall x. P(x) classically implies \exists x. P(x),
11:23:09 <NikolajK> so you can write what you say as
11:23:09 <NikolajK> (\exists x. P(x))\land\Box\forall. P(x),
11:23:09 <NikolajK> where \Box is the possibly-modailty
11:23:42 <NikolajK> as in
11:23:42 <NikolajK> http://en.wikipedia.org/wiki/Modal_logic
11:24:06 <jfischoff> Want is the state of the art in the Haskell world in terms of hot-swappable components?
11:25:09 <sinelaw> NikolajK, what do you mean by "two expressions"
11:26:18 <statusfailed> jfischoff: you mean like plugin code?
11:27:13 <jfischoff> yeah pretty much, but there is also support code for pausing execution, serialziing the state and resource and restarting the new version
11:27:25 <NikolajK> the one where the term is bound and the other where it isn't
11:27:26 <Denommus> is there another way of writting foo <$> bar <*> baz?
11:27:42 <jfischoff> liftA2 foo bar baz
11:27:51 <jfischoff> :t liftA2
11:27:52 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
11:27:54 <EvanR> [[foo bar baz]]
11:28:02 <NikolajK> You want Qx.P(x), where Q might be \forall, \exists, or (and that doesn't make sense) no quantifier
11:28:02 <NikolajK> with no quantifier, the expression is …?.xP
11:28:03 <EvanR> maybe
11:28:05 <clrnd> Denommus, fmap foo $ ap bar baz (I think)
11:28:11 <NikolajK> ?.P(x)
11:28:11 <lambdabot> Unknown command, try @list
11:28:12 <statusfailed> jfischoff: hm, good question- not sure I've heard of any packages to do pausing / serializing. Certainly there are plugin libraries and ways to load code at runtime
11:28:17 <sinelaw> NikolajK, basically the idea is to describe what an embedded language means (e.g. what the binding of variables are)
11:28:30 <Denommus> meh, I just noticed that I'm using <@>, not <*>
11:28:41 <jfischoff> statusfailed: Yeah that is at lower level than what I am looking for, but still cool
11:28:58 <jfischoff> I have some ideas of my own
11:29:06 <NikolajK> sinelaw: there are semantics for quantifiers
11:30:27 <clrnd> :t <@>
11:30:28 <lambdabot> parse error on input ‘<@>’
11:30:32 <clrnd> :t (<@>)
11:30:33 <lambdabot>     Not in scope: ‘<@>’
11:30:33 <lambdabot>     Perhaps you meant one of these:
11:30:33 <lambdabot>       ‘<*>’ (imported from Control.Applicative),
11:30:36 <sinelaw> NikolajK, you can say "for some quanitifer Q, t =  Q a . something". then, depending on what Q is, t can either or not contain free variables
11:31:43 <Denommus> clrnd: (<@>) is reactive-banana's apply
11:32:31 <monochrom> sinelaw: in HOL4 (hol.sf.net), "forall" has type "(a -> Bool) -> Bool". "forall a. a>0" is syntax sugar for "forall (\a -> a>0)".
11:32:37 <Denommus> clrnd: it's similar to (<*>), but it is Behavior t (a -> b) -> Event t a -> Event t b
11:32:49 <ski> NikolajK : "\forall x. P(x) classically implies \exists x. P(x)" -- only if you insist on every domain being nonempty
11:33:01 <sinelaw> monochrom, luckily someone in #logic just explained that to me, so I understand what you said :)
11:33:10 <monochrom> :)
11:33:48 <NikolajK> ski: there is always THAT guy
11:33:49 <NikolajK> :)
11:34:17 <monochrom> this opens up the possibility of Hilbert's choice quantifier. epsilon :: (a -> Bool) -> a, epsilon (\a -> a>0) is an arbitrary number bigger than 0
11:34:39 <monochrom> and with syntax sugar "epsilon a. a>0"
11:35:05 <benzrf> is lambda considered a quantifier?
11:35:11 <benzrf> given that it introduces a variable
11:35:12 <monochrom> lambda is builtin
11:35:16 <benzrf> i mean in math
11:35:19 * hackagebot mime-mail-ses 0.3.2 - Send mime-mail messages via Amazon SES  http://hackage.haskell.org/package/mime-mail-ses-0.3.2 (MichaelSnoyman)
11:35:19 <monochrom> I think yes
11:35:22 <benzrf> hmm
11:35:29 <benzrf> neat never thought of it that way
11:35:33 <sinelaw> lambda is universal quantification over values, no?
11:35:58 <vanila> lambda can be used to prove an implication
11:36:12 <benzrf> sinelaw: is it?
11:36:14 <monochrom> I think you take lambda as the God-given builtin quantifier, and then all other quantifiers can be user-defined.
11:36:46 <monochrom> or sometimes s/quantifier/binder/
11:36:57 <vanila> binder makes more sense to me
11:37:34 <monochrom> yeah, "binder" is probably the proper word for {lambda, forall, hilbert choice, sum, product, ..."
11:37:50 <NikolajK> sure, lambdas bind a term. I wouldn't give it previllage over logical quantifier - although computation should come before some other concepts
11:38:26 <monochrom> I would. because given lambda I can define (or axiomatize) the rest.
11:38:31 <ski> benzrf : lambda is a binder, just like ⌜∀⌝,⌜∃⌝,⌜∑⌝,⌜∏⌝,⌜∫⌝
11:38:33 <NikolajK> you can also use lambda terms to express proopsitions (as opposed to Curry-Howard, where the props are the types)
11:38:36 <monochrom> given "forall" I can't define lambda.
11:39:10 <ski> monochrom : *nod*, ⌜P x ⊢ P (ε P)⌝ and ⌜P (τ P) ⊢ P x⌝
11:39:31 <sinelaw> so does it make sense to talk about "variable binders"?
11:39:32 <ski> (that doesn't assume every domain is non-empty)
11:40:05 <NikolajK> what do you mean "does it make sense"?
11:40:06 <ski> sinelaw : yes
11:40:15 <sinelaw> as in "Q x. P" where Q could be one of many binders
11:40:26 <ski> sinelaw : "lambda is universal quantification over values, no?" -- no
11:40:39 <monochrom> ski: how do I google for tau?
11:40:46 <sinelaw> ski, double negation, "yes" would mean the same :) but why?
11:40:49 <benzrf> how do you define forall from lambda
11:41:07 <NikolajK> http://plato.stanford.edu/entries/epsilon-calculus/
11:41:08 <monochrom> P (τ P) ⊢ P x looks really evil :)
11:42:22 <NikolajK> funfact: There is a thing, so that if it's a bird, everything is a bird.
11:42:32 <vanila> What is that thing?
11:43:11 <NikolajK> the denotation of a term in first order logic, which I take to be objects in the world
11:43:13 <NikolajK> tables, etc.
11:43:13 <ski> monochrom : Hilbert provided this analogy for ⌜τ⌝ : assume the domain is people in a particular put, and ⌜P x⌝ expresses that ⌜x⌝ drinks this night there. then ⌜τ P⌝ is an individual at the pub of such high moral fiber that if ⌜τ P⌝ turned out to drink (iow ⌜P (τ P)⌝), then the only way that could be is if *everybody* (at the pub) drinks (tonight) : ⌜P x⌝
11:43:18 <monochrom> I guess it is just as tame as Smullyan's drinking theorem
11:43:21 <benzrf> vanila: the thing that is not a bird
11:43:30 <benzrf> vanila: it being a bird would be a contradiction
11:43:38 <benzrf> therefore, you may derive that everything is a bird
11:43:52 <ski> monochrom : using this, we define ⌜∀ x. P x⌝ to mean ⌜P (τ P)⌝
11:43:57 <L8D> so when you're using parsec
11:44:00 <L8D> how do you skip something?
11:44:10 <benzrf> monochrom: how do you define forall from lambda
11:44:12 <vanila> haha that tau is really neat
11:44:13 <L8D> like you can do skipMany and sepBy
11:44:13 <benzrf> L8D: just dont use the result
11:44:23 <L8D> benzrf: I mean... I'm trying to define a comment
11:44:28 <benzrf> L8D: explain
11:44:51 <L8D> skipMany $ between (char ';') (char '\n') (many $ noneOf "\n")
11:44:55 <L8D> comment = ^
11:45:13 <sinelaw> my brain just melted.
11:45:22 <ski> monochrom : if we instead use ⌜P x ⊢ P (ε P)⌝, then ⌜ε P⌝ is a person of such low moral fiber that as soon as anyone drinks ⌜P x⌝, they also drink ⌜P (ε P)⌝. using this, we can define ⌜∃ x. P x⌝ to mean ⌜P (ε P)⌝
11:45:24 <benzrf> L8D: WHY NOT JUST PUT COMMENT INTO WHITEPACE
11:45:26 <NikolajK> benzrf: Right, classical logic proves \exists x.(P(x)\implies \forall x.P(x)), (@ski: for non-empty domains)
11:45:27 <benzrf> oops
11:45:43 <L8D> and then I have something that looks like p = comment <|> pstring <|> pnumber ...
11:45:49 <L8D> benzrf: how does I do that?
11:45:54 <ski> NikolajK : hehe, intuitionistic logic also proves it (for non-empty domains)
11:46:01 <L8D> I'm writing a LISP parser btw'
11:46:09 <benzrf> L8D: what's your current whitespace parser
11:46:16 <NikolajK> ski: okay, then material implication is at fault
11:46:37 <ski> NikolajK : however, when you switch to multi-sorted/typed logic, it makes sense not to presuppose that every domain is known to be non-empty
11:47:11 <NikolajK> you have the situation immediatenly if you want empty types, I guess
11:47:12 <clrnd> I know +RTS -N uses N processors, but how many does  a binary uses by default?
11:47:23 <ski> NikolajK : so, what is at fault is presupposing every domain (e.g. the domain of odd perfect numbers) to be non-empty :)
11:47:31 <L8D> benzrf: the only part of the code that recognizes whitespace is when I'm parsing a list
11:47:40 <L8D> benzrf: and using 'pexpr `sepBy` spaces'
11:48:02 <lispy> clrnd: I think the default is one, but binaries can be customized
11:48:05 <L8D> where pexpr is the expression parser
11:48:14 <L8D> sorry I'm a newb to parsec
11:48:15 <ski> monochrom : ⌜ε⌝ and ⌜τ⌝ was in some of Hilbert's and Bernay's papers
11:48:25 <lispy> clrnd: My information might be dated. I wonder if we can find this in the ghc user guide
11:48:30 <benzrf> L8D: ok, so instead of spaces use a custom one that recognizes spaces and comments
11:48:34 <clrnd> lispy, I'll check
11:48:35 <NikolajK> ski: I read Bourbaki 1 and came across it
11:48:47 <benzrf> L8D: then allow whitespace anywhere whitespace may go, instead of just in a list
11:48:49 <NikolajK> in fact, I asked about it here
11:48:49 <NikolajK> http://math.stackexchange.com/questions/177494/what-is-the-tau-symbol-in-the-bourbaki-text
11:49:28 <ski> NikolajK : ok
11:49:36 <lispy> clrnd: https://www.haskell.org/ghc/docs/latest/html/users_guide/using-smp.html#parallel-options
11:49:55 <clrnd> lispy, oh thanks
11:50:23 <lispy> clrnd: it looks like you can get it and set it via Control.Concurrent.getNumCapabilities and Control.Concurrent.setNumCapabilities
11:51:06 <clrnd> lispy, yes indeed, I'll be using that
11:52:19 <benmachine> chrisdone: those are cool ideas but I've not worked on stepeval for months, maybe more than a year
11:52:32 <benmachine> chrisdone: if all you do with your cool ideas is tell me, that is where they will stop
11:52:48 <ski> monochrom : Martín Escardó proves interesting stuff about ⌜ε⌝ and ⌜τ⌝ constructively, for particular (especially infinite) domains that happed to admit them, at <http://www.cs.bham.ac.uk/~mhe/papers/>
11:54:13 <ski> monochrom : see e.g. "Searchable Sets, Dubuc-Penon Compactness, Omniscience Principles, and the Drinker Paradox" by Martín Escardó,Paulo Oliva in 2010 at <http://www.cs.bham.ac.uk/~mhe/papers/dp.pdf>
11:54:41 <ski> monochrom : or "Infinite sets that satisfy the principle of omniscience in any variety of constructive mathematics" by Martín H. Escardó in 2013-09 at <http://www.cs.bham.ac.uk/~mhe/papers/omniscient-journal-revised.pdf>
11:56:07 <sinelaw> ski, so what's a good book to start learning logic?
11:57:18 <ski> monochrom : "Selection functions, bar recursion, and backward induction" by Martín Escardó,Paulo Oliva in 2010-04 at <http://www.cs.bham.ac.uk/~mhe/papers/selection-escardo-oliva.pdf> is also pretty cool, but more advanced
11:57:58 <ski> sinelaw : good question. i don't have a good answer, i learned bits and pieces for all over the place, including various papers i looked at
11:59:09 <NikolajK> is there any dependently typed language being worked on atm., which has the chance of being used?
11:59:38 <johnw> NikolajK: have you seen Idris?
11:59:45 <srhb> NikolajK: Idris? Agda? There are plenty of dependently typed languages that are being used actively.
11:59:47 <johnw> it's raison d'etre is to be used
12:00:55 <NikolajK> I don't know what to do
12:01:01 <NikolajK> now that Grothendieck is dead
12:01:19 <johnw> pass through the stages of grief one by one?
12:03:22 <ski> monochrom : "The intrinsic topology of a Martin-Löf universe" by Martín H. Escardó in 2012-05-15 at <http://www.cs.bham.ac.uk/~mhe/papers/universe-indiscrete-and-rice.pdf> and "The universe is indiscrete" by Martín H. Escardó,Thomas Streicher in 2013-11-16 at <http://www.cs.bham.ac.uk/~mhe/papers/universe-indiscrete.pdf> are also pretty cool
12:04:40 <Denommus> is there any function in Gloss to exit the program?
12:05:23 <ski> they show that the universe (of types) has intrinsically an indiscrete topology (corresponding to that the only opens are the empty and the full one)
12:05:35 <srhb> Denommus: It's been a while since I used gloss, but generally I think there were some runFoo functions, and the program exits when that function exits.
12:06:51 <Denommus> srhb: yeah, but I don't know how to interrupt the function
12:07:20 <EvanR> you can use System.Exit
12:07:50 <ski> this has as a consequence that every extensional decidable predicate on the universe is trivial (constant)
12:09:08 <NikolajK> ski: what is the point of that topology (no pun intended)
12:09:43 <ski> this is a form of <https://en.wikipedia.org/wiki/Rice's_theorem>, which says that for any non-trivial property of partial computable functions, there is no general method to decide whether an algorithm computes an example of such a partial computable function having that property
12:09:54 <ski> NikolajK : of the discrete topology ?
12:10:10 <NikolajK> I though it's another topology than the discrete one
12:10:19 * hackagebot matrices 0.2.0 - native matrix based on vector  http://hackage.haskell.org/package/matrices-0.2.0 (kaizhang)
12:10:24 <ski> er, i meant indiscrete, sorry
12:10:31 <EvanR> "indiscrete" topology means "not discrete" ?
12:10:37 <NikolajK> also, related, is there any agument against univalence, if you want to implement general math (doing math) on a computer?
12:10:41 <ski> EvanR : no, it means more
12:11:04 <ski> the indiscrete topology is basically a kind of dual to the discrete topology
12:11:41 <johnw> NikolajK: for doing math?  I haven't heard any yet, but it may too new to tell.  Have you seen the UniMath project? https://github.com/UniMath/UniMath
12:11:45 <NikolajK> it appears to me that having "equivalence ==> substitution allowed" is the most desirable thing you would wish for, e.g. when working with groups
12:11:52 <ski> given any set, the discrete topology on it is the free functor (the left adjoint) to the underlying functor that for any topological space forgets the topology and only yields the base set
12:12:17 <ski> given any set, the indiscrete topology on it is the cofree function (the right adjoint) to the same underlying functor as above
12:13:39 <EvanR> left/right adjoint functor, got it
12:14:20 <ski> in an indiscrete topology (such as in the topology of a universe of types), all points (types in that case) are "lumped together", and can't be distinguished by topological means, by continuous/computable functions from this space
12:15:05 <ski> EvanR : left adjoints to "underlying/forgetful functors" are usually called "free". right adjoints are usually called "cofree"
12:15:34 <ski> EvanR : e.g. the naturals is the free monoid on a singleton set. and the integers is the free group on a singleton set
12:15:37 <EvanR> ok so the empty set and the set of all types
12:16:22 <ski> EvanR : the free *abelian* group on a dupleton set is the set of pairs of integers (a "discrete coordinate system", like the gaussian integers, if you like)
12:16:25 <johnw> "Every empty set is alike; even non-empty set is non-empty is its own way."
12:16:33 <johnw> s/is/in
12:16:48 <ski> there's only one empty set, yea :)
12:17:01 <johnw> I was paraphrasing the opening line of Anna Karenina :)
12:17:12 <johnw> just s/empty/happy
12:17:36 <EvanR> ski: whats monoid in this context?
12:18:05 <ski> NikolajK : what do you mean by "equivalence ==> substitution allowed" ?
12:19:36 <EvanR> ok free monoid translates to list
12:21:34 <ski> EvanR : a monoid is consists of a set ⌜A⌝, equipped with two operations ⌜u : 1 → A⌝ and ⌜m : A × A → A⌝, satisfying the three laws ⌜∀ y : M. m(u(),y) = y⌝, ⌜∀ x : M. x = m(x,u())⌝, and ⌜∀ x,y,z : M. m(m(x,y),z) = m(x,m(y,z))⌝. ⌜u ()⌝ and ⌜m(x,y)⌝ are usually written like ⌜1⌝,⌜x · y⌝ (or ⌜x y⌝), or sometimes like ⌜0⌝,⌜x + y⌝
12:21:44 <ski> s/is consists/consists/
12:22:21 <ski> the laws are the left unit/identity/neutral element law, the corresponding right law, and the associative law
12:22:23 <clrnd> what would make the best haskell tshirt ever ever?
12:22:44 <athan> What's the proper way to manually make a Read instance of a data type?
12:22:52 <ski> (er, s/M/A/)
12:23:04 <EvanR> ski: whats the underlying forgetful functor associated with the free monoid nat example
12:23:26 <athan> I'm not sure I understand what readList and readsPrec accomplish
12:23:42 <clrnd> athan, http://hackage.haskell.org/package/base-4.7.0.1/docs/Prelude.html#t:Read
12:23:45 <clrnd> oh
12:24:11 <ski> EvanR : a group ⌜A⌝ is a monoid ⌜A⌝ which also has an operation ⌜i : A → A⌝, satisfying ⌜∀ x,y : A. m(i(x),x) = u()⌝ (left inverse law) and ⌜∀ x,y : A. u() = m(x,i(x))⌝ (right inverse law)
12:24:24 <clrnd> readList is what it says, a way to read lists of your datatype
12:24:35 <athan> clrnd: Thanks, I'll dig a bit more :)
12:24:43 <ski> (s/x,y/x/)
12:24:50 <clrnd> think ['h','e','l','l'] == "hell"
12:25:18 * hackagebot hoist-error 0.1.0.2 - Some convenience facilities for hoisting errors into a monad  http://hackage.haskell.org/package/hoist-error-0.1.0.2 (JonSterling)
12:25:34 <clrnd> you want readPrec
12:25:55 <clrnd> (or readsPrec if you feel lazy)
12:27:24 <ski> (in case the neutral element operation ⌜u⌝ is dropped, then the inverse laws are usually stated like ⌜∀ x,y : A. m(i(x),m(x,y)) = y⌝ and ⌜∀ x,y : A. x = m(m(x,y),i(y))⌝. see also <https://en.wikipedia.org/wiki/Inverse_property_loop#Inverse_properties>)
12:28:08 <athan> clrnd: I'm not sure I understand the operator prescedence of the enclosing context dealio, it's a bit confusing
12:28:15 <ski> EvanR : the forgetful functor here is just the functor that given any monoid forgets that it is a monoid, and only retains the underlying carrier set of elements of the monoid
12:28:28 <ski> EvanR : so, the operations (and laws) are forgotten
12:29:16 <ski> EvanR : there's similarly a forgetful functor from abelian groups to sets that forgets all the operations and laws
12:29:45 <ski> EvanR : and one from abelian groups to abelian monoids which forgets the inverse operation, and the inverse laws
12:30:19 <ski> EvanR : and one from abelian groups to groups which forgets no operation at all, only the commutative law ! (so forgetting laws is significant, not only forgetting operations)
12:30:31 <clrnd> athan, you can always use parsec ... I don't think I ever manually wrote a Read instance like this
12:31:10 <ski> EvanR : so, the underlying set of the free monoid on a singleton set (i.e. the natural numbers) is just the set of natural numbers, with the monoid operations and laws forgotten
12:31:14 <EvanR> ok so you took the free monoid on a singleton set, which is sequences of a single thing, and forgot that its a monoid, and left with a bunch of elements with no relation to each other
12:31:26 <ski> it's the countably infinite set
12:31:37 <luciano888> hi, i have a proble with xmonad, someone can help me please?
12:31:53 <ski> EvanR : yep
12:31:55 <athan> clrnd: I already have my parser in bnfc/happy & alex, I'd just really like the read instnace
12:32:02 <athan> just for claenliness
12:32:32 <athan> I need new fingers
12:33:13 <ski> EvanR : another example : the free (reflexive multi-) graph on a set is the graph that has that set as its set of nodes, and only adds one identity edge on each node
12:33:15 <EvanR> looking up what adjoint is
12:33:42 <ski> EvanR : this is the left adjoint to the underlying functor that forgets the edges in a graph, returning the set of nodes
12:33:49 <clrnd> athan, I just looked at the source, it uses readPrec which doesn't have precedence
12:33:49 <luciano888> please...
12:34:04 <clrnd> I guess you can use the same parser
12:34:10 <athan> oh woah
12:34:15 <clrnd> luciano888, what's your problem?
12:34:26 <athan> clrnd: That's perfect, thank you dearly :)
12:34:37 <EvanR> ski: seems like "free" leads to a "boring example" of an object ;)
12:34:53 <ski> EvanR : now, this free functor (left adjoint of underlying functor in opposite direction) that generates graphs from sets in *turn* has a left adjoint : this is the functor that for any graph gives the set of its connected components
12:34:55 <Jello_Raptor> hmm
12:34:55 <luciano888> i try to config the xmonad.hs file
12:35:05 <ski> EvanR : is that a boring example ? :)
12:35:44 <monochrom> English composition question: "the best thing is free".
12:35:50 <luciano888> ind when i try to import Xmonad.Hooks.DynamicLog or anyother module, xmonad dont' reconized it
12:35:57 <athan> Is there a way to make hoogle tell you the source file of matches?
12:36:04 <monochrom> I did not know math at that time. if I did, I would consider turning that into a math essay :)
12:36:14 <clrnd> luciano888, how doid you install xmonad?
12:36:23 <EvanR> ski: the connected components of that graph, its just all the elements alone?
12:36:24 <Jello_Raptor> if I've got a module 'Foo.Bar.Fib' in 'Foo/Bar/Fib.hs' and want to export some subset of those components in a module 'Foo.Bar' what's the canonical way of doing that?
12:36:29 <monochrom> I would consider inflicting category theory on English teachers :)
12:36:34 <luciano888> form package manager, iam in crunchbang linux
12:36:55 <success> How can you send money to someone in another country without them having a bank account? Can you do that with western union? Just send and the person taking it out needs a passsword?
12:37:00 <clrnd> luciano888, try installing xmonad extras
12:37:03 <ski> EvanR : no. each element of the set of connected components consist of all the original nodes of the graph that were connected to each other via edges
12:37:30 <clrnd> luciano888, xmonad-contrib sorry
12:37:34 <ski> EvanR : so, if your graph is connected, then you get the singleton set. if your graph consists of two disjoint connected components, then you get a dupleton set, &c.
12:37:42 <luciano888> i instali the libghc-xmonad-contrib
12:37:54 <luciano888> yea, but, nothing
12:38:19 <EvanR> ski: yeah so the free graph is all the elements connected to itself
12:38:30 <clrnd> luciano888, try running ghci, and doing the import there
12:38:35 <ski> EvanR : "of that graph, its just all the elements alone" -- that would be the underlying set of nodes of a graph .. while being a functor in the same direction, between the same two categories, it's still not the same functor as the connected components one
12:39:15 <ski> EvanR : yeah, the connected components of the free graph on a set is just that set (up to bijection)
12:40:12 <luciano888> it did it!! but, why don't do in xmonad.hs file?
12:40:58 <plczk> Dear Haskell community! I know I am missing something obvious, but no way i am able to find a function which "moves" monad outside of a tuple. Like this ## (m a, b) -> m (a, b) ## (In my case its). ## Map String IO Float -> IO Map String Float ## Feel like i am a moment from enlightement, but not sure how far that moment is. Thanks in advance!
12:41:15 <ski> EvanR : generally, a free functor (i.e. a left adjoint of an forgetful/underlying functor) is boring in a way, yes
12:41:33 <vanila> ;t \(ma, b) -> do a <- ma ; return (a, b)
12:41:34 <ski> EvanR : the free vector space on a set is the vector space having that set as basis
12:41:58 <vanila> :t \(ma, b) -> do a <- ma ; return (a, b)
12:41:59 <ski> EvanR : the free subgroup on a subset (of a group) is the subgroup generated by that subset of elements
12:42:00 <lambdabot> Monad m => (m t, t1) -> m (t, t1)
12:42:00 <clrnd> luciano888, what does manually running `xmonad --recompile` complain about?
12:42:02 <ski> &c.
12:42:13 <Jello_Raptor> I can do stuff like "module Boo (module Bar,module Foo) where ..."  but I'm nto sure what that is called or where to find documentation for it
12:42:15 <vanila> plczk,  ther's how to write it
12:43:14 <clrnd> Jello_Raptor, I thinks it's called "exporting modules"
12:43:17 <ski> @type uncurry (fmap . (,))  -- plczk
12:43:18 <lambdabot> Functor f => (a, f a1) -> f (a, a1)
12:43:52 <luciano888> xmonad.hs:7:12:
12:43:52 <ski> plczk : this operation is often called `strength'
12:44:17 <luciano888> could not find module `XMonad.Hooks.DynamicLig`
12:44:24 <ski> (every functor (from `*' to `*') in Haskell is strong. not every functor in category theory is strong)
12:44:43 <luciano888> use -v to see list of the files searched for
12:44:51 <plczk> @vanilla, @ski - Thank you very much! This is high-level sorcery ;) Thanks again!
12:44:56 <lambdabot> Unknown command, try @list
12:45:10 <success> > Just 5 >>= \a -> return a*2
12:45:11 <lambdabot>  No instance for (GHC.Show.Show b0)
12:45:12 <lambdabot>    arising from a use of ‘M783651404207772018423007.show_M7836514042077720184...
12:45:12 <lambdabot>  The type variable ‘b0’ is ambiguous
12:45:12 <lambdabot>  Note: there are several potential instances:
12:45:12 <lambdabot>    instance [safe] GHC.Show.Show
12:45:20 <success> > Just 5 >>= \a -> return $ a*2
12:45:21 <ski> plczk : also note that it's not according to IRC custom to address people by prefixing their nickname with a `@' :)
12:45:22 <lambdabot>  Just 10
12:45:25 <clrnd> luciano888, DynamicLig?
12:45:57 <Jello_Raptor> bah, i need something like this http://stackoverflow.com/questions/17241491/haskell-hide-specific-functions-in-module-exports :/ has GHC added that sort of thing in the past year?
12:45:57 <luciano888> Dynamic.Log, sorry, i typed, beacose can't copy paste now
12:46:01 <plczk> ski: Roger that. its been a while since i have used irc.
12:46:02 <clrnd> oh ok
12:46:11 <ski> plczk : also, every monad is a functor, so don't let the fact that my operator is defined for functors stop you. if you prefer, you can replace `fmap' by `liftM', which does the same thing (but only for monads)
12:46:12 <EvanR> #hashtag
12:46:47 <luciano888> its like xmonad don't know where are the modules..
12:46:58 <clrnd> luciano888, mmm weird weird
12:47:08 <clrnd> you are not using a sandbox at all right?
12:47:12 <JagaJaga> > Just (2*) <*> Just 5
12:47:14 <lambdabot>  Just 10
12:47:16 <JagaJaga> success: ^
12:47:39 <luciano888> sandbox? i dont thing so..
12:47:48 <success> > let (<>>=) (a,b) = a >>= return (a,b)
12:47:50 <lambdabot>  not an expression: ‘let (<>>=) (a,b) = a >>= return (a,b)’
12:48:15 <success> > let (<>>=) (a,b) = a >>= return (a,b) in (<>==) (Just 5, 6)
12:48:16 <lambdabot>  Not in scope: ‘<>==’
12:48:16 <lambdabot>  Perhaps you meant one of these:
12:48:16 <lambdabot>    ‘<>>=’ (line 1), ‘<>=’ (imported from Control.Lens)
12:48:25 <Hijiri> Should I be safe if I uninstall xmonad from my package manager and then install it with cabal?
12:48:32 <Hijiri> I'm trying to get rid of some global packages
12:48:44 <JagaJaga> Hijiri: if it is in $PATH then it's OK
12:48:46 <success> > let tupleBah (a,b) = a >>= return (a,b) in tupleBah (Just 5, 6)
12:48:48 <lambdabot>  Occurs check: cannot construct the infinite type: m ~ (,) (m a)
12:48:48 <lambdabot>  Expected type: a -> m t1
12:48:48 <lambdabot>    Actual type: a -> (m a, t1)
12:48:48 <lambdabot>  Relevant bindings include
12:48:48 <lambdabot>    a :: m a (bound at <interactive>:1:15)
12:48:49 <Hijiri> alright
12:49:06 <clrnd> Hijiri, well I could never do that because when Xmonad recompiles itself it isn't in the sandbox
12:49:06 * ski peers quizzingly at success
12:49:09 <success> > let tupleBah (a,b) = a >>= \ c -> return (c,b) in tupleBah (Just 5, 6)
12:49:11 <lambdabot>  Just (5,6)
12:49:13 <JagaJaga> success: you can do `/query lambdabot` and have fun
12:49:14 <clrnd> you can always compile it by hand every time ofc
12:49:17 <Hijiri> actually, I'm not sure if this would help get rid of global packages, because I'd still need them installed to compile xmonad, right?
12:49:20 <Hijiri> yeah
12:49:48 <ski> @type a <>>= b = a >>= \c -> return (c,b) in (<>>=)
12:49:49 <lambdabot> parse error on input ‘=’
12:49:50 <clrnd> Hijiri, but you can in theory `cabal build` it and run it from there, Mod-q just won't work
12:49:57 <Hijiri> but my issue is that the packages from my distro don't have profiling
12:49:59 <ski> @type let a <>>= b = a >>= \c -> return (c,b) in (<>>=)  -- oops
12:50:00 <lambdabot> Monad m => m t -> t1 -> m (t, t1)
12:50:07 <Hijiri> so this would solve that issue at least
12:50:21 <clrnd> Hijiri, mmm why not use a sandbox with profiling where you need it?
12:50:25 <success> > let tupleBah (a,b) = a >>= \ c -> return (c,b) in tupleBah (Left , 6)
12:50:26 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
12:50:27 <lambdabot>    arising from a use of ‘M758242542732222028423172.show_M7582425427322220284...
12:50:27 <lambdabot>  The type variable ‘b0’ is ambiguous
12:50:27 <lambdabot>  Note: there are several potential instances:
12:50:27 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
12:50:28 <success> > let tupleBah (a,b) = a >>= \ c -> return (c,b) in tupleBah (Left 8, 6)
12:50:28 <clrnd> luciano888, sorry but I;m out of ideas
12:50:29 <lambdabot>  Left 8
12:50:33 <Hijiri> I'm not sure how to hide global packages from my sandboxes
12:50:37 <ski> JagaJaga : .. any reference to Baba Yaga ?
12:50:40 <Hijiri> I guess I could have just asked the channel
12:50:48 <success> > let tupleBah (a,b) = a >>= \ c -> return (c,b) in tupleBah (Just 8, 6)
12:50:49 <lambdabot>  Just (8,6)
12:51:00 <JagaJaga> ski: what? :)
12:51:03 <luciano888> clrnd thanks!
12:51:20 <luciano888> i gonna tray compile from source
12:51:34 <luciano888> try*
12:51:36 <ski> JagaJaga : <https://en.wikipedia.org/wiki/Baba_Yaga>
12:51:53 <luciano888> bye
12:51:59 <Hijiri> so how do I hide global packages from my cabal sandboxes?
12:52:01 <success> > let f (x,y) = \(ma, b) -> do a <- ma ; return (a, b) in f (Just 5,6)
12:52:03 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t1)
12:52:03 <lambdabot>    arising from a use of ‘M264400099578652747223236.show_M2644000995786527472...
12:52:03 <lambdabot>  The type variable ‘t1’ is ambiguous
12:52:03 <lambdabot>  Note: there are several potential instances:
12:52:03 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
12:52:09 <JagaJaga> ski: I know what's that. But did you mention?
12:52:19 <clrnd> Hijiri, I thought global pkgs where always hidden ... in sandboxes
12:52:38 <success> > let tupleBah (a,b) = a >>= \ c -> return (c,b) in tupleBah (Just 5, 6)
12:52:40 <lambdabot>  Just (5,6)
12:52:40 <plczk> ski: Thank you. It helps a lot.
12:52:44 <ski> JagaJaga : your nick sounded like it perhaps had a connection :)
12:53:17 <JagaJaga> ski: hah :D I'm russian, but didn't thougth it sounds like that.
12:53:26 <ski> plczk : success is also playing with it
12:53:35 <Hijiri> no, global packages are visible when I use sandboxes
12:53:56 <Hijiri> which gives me issues because I have cabal set to compile with profiling, but none of the global packages are
12:54:30 <Hijiri> the global packages that are a problem are installed through my distro's package manager
12:54:32 <Hijiri> not cabal
12:55:19 * hackagebot cpsa 2.4.0 - Symbolic cryptographic protocol analyzer  http://hackage.haskell.org/package/cpsa-2.4.0 (JohnRamsdell)
12:55:44 <plczk> ski: Precisely. Learning haskell mostly for those "a-ha" moments :)
12:57:01 <clrnd> Hijiri, are you sure? that isn't the case here, I'm using `cabal sandbox`
12:57:15 <Hijiri> I was too, when I was having the issue
12:57:17 <Hijiri> s
12:57:47 <clrnd> Hijiri, maybe you are still installing pkgs without profiling in the sandbox?
12:58:24 <clrnd> if ghc was installed form apt/yum/whatever remember to install the -prof version too
12:58:26 <Hijiri> No - when I try installing quickcheck in a fresh sandbox, it says it's already installed
12:58:59 <Hijiri> I didn't know about that one though, thanks
12:59:21 <Hijiri> wait, it was already installed
12:59:23 <Hijiri> ghc-prof, I mean
12:59:44 <Tordek> huh, so, nshepperd, that snipped I was optimizing yesterday; turns out "sum [0..10000...]" ends up compiling to the fastest version I got manually anyway
13:01:33 <clrnd> Hijiri, weird! here that works as if there was no global pkg :/
13:02:02 <Hijiri> quickcheck for me is installed as part of a distro package, I think
13:02:12 <Hijiri> it's not in .ghc
13:02:32 <clrnd> Hijiri, ohhh, ohhhhhh, I have no distro pkgs
13:02:38 <Tordek> nshepperd: nevermind, dumb me against compiler flags
13:02:54 <clrnd> Hijiri, I only installed GHC from a ppa and then globally installed xmonad trough cabal
13:03:12 <Hijiri> yeah, xmonad is installed through my distro
13:03:24 <Hijiri> that's why I wanted to uninstall then reinstall through cabal
13:03:56 <Hijiri> I will do that and hope my session doesn't die while I do it
13:04:02 <WigglesMcMuffin> What is the common replacement for comprehensions in Haskell? I come from Python, so comprehensions are familiar to me, though I've heard tell that there are typically better constructs for them
13:04:03 <clrnd> jajaj, mine didn't I remember
13:04:23 <clrnd> WigglesMcMuffin, well what about map, filter and reduce?
13:04:24 <L8D> if I'm writing a REPL for something, how should I go about counting the number of parenthases in a statement that are not inside a string?
13:04:39 <L8D> so I know when a statement is finished
13:04:53 <WigglesMcMuffin> clrnd: I know map, filter, and reduce. Is that all there is to it?
13:05:10 <athan> So I've been thinking about how types can be compared and equated for a while, without much research into the HM invention itself. From observation, I've come up with two type-equality ideas: coercion and satisfaction. Coersion, in my eyes, takes a larger, more general type and converts it to a smaller one, ie: `a -> b` to `Int -> Int`. Satisfaction takes a smaller, more concrete type and sees whether it satisfies a more general one, ie:
13:05:11 <athan> "does `Int -> Int` satisfy `a -> b`?". Now I'm getting kinda mixed up in the actual implementation... are these two ideas actually the same thing? Namely, _unification_?
13:05:11 <clrnd> WigglesMcMuffin, there is https://hackage.haskell.org/package/base-4.7.0.0/docs/Data-List.html
13:05:38 <Hijiri> that's odd, I uninstalled xmonad and it still says it's installed
13:05:49 <clrnd> lol
13:07:11 <Hijiri> I am just going to uninstall libghc-*
13:07:58 <WigglesMcMuffin> clrnd: For example, I have a function: sortList f xs = [y | x <- uniq . mySort $ map f xs, y <- xs, f y == x] and I'm not sure how I'd rewrite that one, it looks like a filter . map, but I just don't see how to write it?
13:08:34 <ski> athan : that's not (quite) unification, it's "being an instance of" (wrt type schemes)
13:08:42 <WigglesMcMuffin> clrnd: (and yes, I know these a poor rewrites of existing modules, but I'm just trying to get a feel of the language itself)
13:09:01 <ski> athan : and yes, it sounds like your two "coercion" and "satisfaction" there are just converses of each other
13:09:07 <athan> ski: Thank you :)
13:09:15 <athan> ski: My type system is _really_ simple
13:09:21 <ski> athan : however .. i would usually mean something else by "coercion"
13:09:26 <athan> only one unit type, functions, and polymorphic variables
13:09:37 <athan> ski: same here, I couldn't come up with a better name
13:09:48 <ski> athan : note that "being an instance of" is a case of unification
13:09:58 <fragamus> I am doing this:      (\_->return ()) <=< bar <=< foo               is there some cleaner way
13:09:59 <clrnd> WigglesMcMuffin, well lists are a monad: https://www.haskell.org/haskellwiki/List_comprehension
13:10:05 <athan> hmm, that makes a lot of sense
13:10:36 <EvanR> athan: sounds like system F
13:10:51 <ski> athan : to unify two terms `t0' and `t1', you find bindings for free variables in them, that makes them equal. a set of bindings is called a substitution. a substitution that make two terms equal is called a unifier
13:10:51 <athan> EvanR: It's more HM, I think
13:12:16 <ski> athan : so, if we have `a -> IO a' and `Maybe b -> c', then one unifier of these two types is `[a := Maybe Int,b := Int,c := IO Int], because this makes the two types both become `Maybe Int -> IO Int'
13:12:51 <ski> athan : however. this is not the *most* *general* unifier. the most general unifier is a unifier which every other unifier is an instance / special case of
13:12:52 <EvanR> athan: thats a type inference concept for stuff like system f
13:13:30 <athan> ski: !!!
13:13:38 <ski> athan : in this case, the most general unifier is `[a := Maybe b,c := IO b]', which unifies the two types to become the common `Maybe b -> IO b', where `b' is still a free variable
13:13:45 <athan> EvanR: I'm still really uneducated :/ hopefully I'll get it soon haha
13:14:04 <athan> I just don't think it's truly polymorphic :S
13:14:09 <EvanR> athan: your thing is simple enough that you have "nicer" properties than haskell, like all programs reduce to a normal form
13:14:15 <EvanR> im mostly guessing though
13:14:20 <athan> ski: Oh wow!!
13:14:42 <athan> EvanR: I think so, I have no idea lol
13:14:52 <athan> ski++
13:14:54 <ski> athan : now, a term `t0' is an instance of a term `t1' (or `t1' is a generalization of `t0'), if `t0' and `t1' unify with a unifier that *doesn't* bind any free variable in `t0' !
13:14:55 <athan> EvanR++
13:14:55 <sshine> @pl flip when
13:14:55 <lambdabot> flip when
13:15:02 <Tordek> nshepperd: Data.Vector.Unboxed was pointed out to me, and `main = print $ V.sum (V.enumFromN (1 :: Int) 1000000000)` yields the same as my hand unrolled version
13:15:36 <athan> ski: That makes perfect sense holy toledo
13:15:39 <ski> athan : so, `a -> IO a' is not an instance of `Maybe b -> c' (nor vice versa), but e.g. `Maybe b -> IO a' is an instance of `Maybe b -> c'
13:15:39 <sshine> @hoogle Monad m => m () -> Bool -> m ()
13:15:40 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
13:15:40 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
13:15:40 <lambdabot> Data.Generics.Aliases extR :: (Monad m, Typeable a, Typeable b) => m a -> m b -> m a
13:16:17 <fragamus> @hoogle a -> m ()
13:16:17 <lambdabot> Control.Monad.Trans.Reader runReaderT :: ReaderT r m a -> r -> m a
13:16:17 <lambdabot> Control.Monad.Reader runReaderT :: ReaderT r a -> r -> m a
13:16:17 <lambdabot> Data.Generics.Aliases unGM :: GenericM' m -> forall a. Data a => a -> m a
13:17:11 <athan> I'm going to have to ponder about this for a while. Do you have a good reference website or material for this magic, ski? (that's algorithm W, too, correct?)
13:17:12 <fragamus> it might seem like my hoogle above is in some way related to the previous one by sshine but actually it is related to my question above
13:17:38 <ski> athan : now, note that `a -> Bool' is already equal to `a -> Bool', but is not equal to `b -> Bool' (but you can unify them with `[a = b]') -- this means that when comparing two type schemes (types with *holes* in then, signified by (free) type variables), it not only matters what the patterns of holes in each type is, but also whether we used the same (free) variable *name* in both or not
13:18:06 <EvanR> athan: make sure you dont confuse free type variables with universally quantified type variables, i think the difference is significant if youre trying to reason about a type inference
13:18:29 <ski> athan : you could try starting with "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/TYPE/typeinf.p(s|df)>
13:18:39 <athan> ski: that makes perfect sense, because `a -> b` is more general than `a -> a`, right?
13:18:45 <ski> (that's one the the earliest papers on types and type inference i read)
13:18:50 <ski> athan : right
13:19:04 <athan> ski: That is perfect :) Thank you so much
13:19:06 <athan> this is like candy
13:20:04 <ski> athan : so, because whether we use common names across the two comparands here matter, we immediately see that "is an instance of" and "is a generalization of", as applying to type schemes, is *different* from subtyping as in Object-oriented programming
13:20:13 <fragamus> @hoogle (Monad m)=> a -> m ()
13:20:14 <lambdabot> Prelude return :: Monad m => a -> m a
13:20:14 <lambdabot> Control.Monad return :: Monad m => a -> m a
13:20:14 <lambdabot> Control.Monad.Instances return :: Monad m => a -> m a
13:20:28 <apriori> hello guys. I struggle a bit with Data.HList, but maybe one you has an idea. gist is here: https://gist.github.com/apriori/0ee9fa567b3184f1abf7
13:20:53 <ski> athan : as EvanR says, a type scheme is not the same as a universal type (the type of a polymorphic operation)
13:21:37 <apriori> goal is to write a function which combines two functions which work on a type indexed list (Tip a/Tip b) using a binary function and return a function that works on Tip (HAppendList a b) and returns the value of the both executed functions combined via the given binary function.
13:21:37 <EvanR> just to make sure what i said, whats a type scheme? a type containing type variables?
13:21:51 <athan> ski: Thank you, I think I've got a lot on my plate now :).
13:21:56 <ski> athan : a type scheme `[a] -> [b] -> [(a,b)]' refers to *free* variables `a' and `b', which are important how they're named (insofar as whether we use or not use the same names `a' and `b' in other type schemes we consider)
13:22:03 <apriori> the gist gives an idea on how far (or not) I got
13:22:31 <EvanR> you cant rename free variables
13:22:40 <athan> O_O
13:23:08 <ski> athan : otoh, a universal type, like the type `forall a b. [a] -> [b] -> [(a,b)]' of `zip' represents a "closure" of the (formerly) free type variables. so that we no longer care about the names of them, because they're now bound. we can now rename them at will (as long as we do it consistently)
13:23:14 <EvanR> without possibly colliding with something you compose it with
13:23:42 <athan> ski: ahh yeah, that makes sense
13:24:01 <athan> EvanR: That makes perfect sense - it's actually using the symbolism and not the term names
13:24:07 <ski> athan : `forall a b. [a] -> [b] -> [(a,b)]' is the same type as `forall c b. [b] -> [c] -> [(b,c)]', while `[a] -> [b] -> [(a,b)]' is not the same as `[b] -> [c] -> [(b,c)]'
13:24:27 <athan> Variable renaming is traditionally just appending numbers to the variable, right?
13:24:41 <athan> ski: That makes perfect sense
13:24:50 <ski> athan : in Haskell, if you don't explicitly `forall' your type variables in a type *signature*, they're implicitly `forall'ed at the "toplevel" of the type signature
13:25:06 <sshine> @hoogle Monad m => (a -> Bool) -> m a -> m [a]
13:25:07 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
13:25:07 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
13:25:07 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
13:25:25 <sshine> is there a generic takeWhile?
13:25:38 <ski> athan : so `zip :: [a] -> [b] -> [(a,b)]' is then short for `zip :: forall a b. [a] -> [b] -> [(a,b)]' (as opposed to e.g. `zip :: forall a. [a] -> (forall b. [b] -> [(a,b)])' .. though these two still *behave* the same)
13:26:08 <athan> ski: AH!!!
13:26:15 * athan finally is starting to get rank-n
13:26:59 <athan> so rank-n polymorphism let's you symbolically mess with nested type signatures?
13:27:08 <EvanR> rank-n is like a burrito
13:27:12 <athan> instead of term reference
13:27:13 <athan> hahaha
13:27:30 <EvanR> it lets you put foralls where you want
13:27:38 <sshine> EvanR, ah, like burritos.
13:27:45 <ski> athan : also, given e.g. `([a],[a] -> [b]) -> [b]', if we place this (alone) in a type signature, it would be sugar for `forall a b. ([a],[a] -> [b]) -> [b]' (which is clearly *different* from e.g. `forall b. (forall a. ([a],[a] -> [b])) -> [b]' .. but different in *structure*, and, this time, also different in *behaviour*)
13:28:36 <ski> athan : well, i should say that free type variables in a type signature are *usually* implicitly universally quantified with `forall' at the "toplevel" of the type -- there are a few exceptions
13:28:46 <ski> @src Functor
13:28:46 <lambdabot> class  Functor f  where
13:28:46 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
13:30:31 <athan> ski: How is Functor an exception?
13:30:34 <ski> athan : in this case, `fmap :: (a -> b) -> (f a -> f b)' is desugared to `fmap :: forall a b. (a -> b) -> (f a -> f b)', *not* to `fmap :: forall f a b. (a -> b) -> (f a -> f b)' -- because in this case, the type variable `f' is already in *scope* outside the type signature (it is in scope inside the whole `class' declaration, because `f' is here bound by `Functor f')
13:30:41 <ski> it's not an exception
13:31:00 <athan> Oh!
13:31:02 <athan> wow
13:31:11 <ski> the exception is that `f' is here bound in the whole class, not (by an implicit `forall') in the type signature of `fmap'
13:31:13 <jeltsch> EvanR, athan: RankNTypes actually does *not* let you put foralls where you want. You still cannot put them around an argument of a type constructor other than (->).
13:31:45 <jeltsch> EvanR, athan: For example, [forall a . a] will still not work. You need ImpredicativeTypes for this.
13:31:50 <ski> jeltsch : `ImpredicativeTypes'
13:31:55 * ski nods
13:32:23 <EvanR> does impredicative in this case mean "not functions"
13:32:29 <athan> This is incredible
13:32:40 <ski> athan : rank-`n+1' polymorphism means that you're allowed to place `forall' "to the left" of `n' `->' arrows
13:32:47 <athan> EvanR: Does it have something to do with the universal mapping on products / exponents?
13:33:00 <athan> ahhh okay
13:33:08 <ski> so `[] :: forall a. [a]' is rank-1, and so's `length :: forall a. [a] -> Int'
13:33:32 <ski> `runST :: forall a. (forall s. ST s a) -> a' is rank-2, because the `forall s' is to the left of one `->'
13:34:20 <lifter> Why doesn't this function exist in Prelude or Data.List? "singletonList a = [a] "
13:34:34 <athan> that makes sense, I'll have to ponder about the binding to really understand the quantification inference
13:34:39 <exio4> that is the same as return
13:34:48 <lifter> oh right
13:34:49 <athan> lifter: because [a] is shorter :P
13:34:49 <kadoban> lifter: It does. It's called []
13:34:55 <exio4> oh, well, that too
13:35:02 <jeltsch> lifter, exio4: On the other hand, there is also Data.Sequence.singleton.
13:35:06 <lifter> > [] 10
13:35:08 <lambdabot>  Couldn't match expected type ‘a0 -> t’ with actual type ‘[t0]’
13:35:13 <exio4> > (:[]) 10
13:35:15 <lambdabot>  [10]
13:35:17 <jeltsch> But return works as well, of course. At least, for list.
13:35:17 <athan> :)
13:35:20 <lifter> oh my
13:35:23 <lifter> yes, thx
13:35:23 <benzrf> pure
13:35:25 <benzrf> > pure 3
13:35:26 <lambdabot>  No instance for (GHC.Show.Show (f0 a0))
13:35:26 <lambdabot>    arising from a use of ‘M794578216451267243023931.show_M7945782164512672430...
13:35:26 <lambdabot>  The type variables ‘f0’, ‘a0’ are ambiguous
13:35:26 <lambdabot>  Note: there are several potential instances:
13:35:26 <lambdabot>    instance [safe] GHC.Show.Show a =>
13:35:29 <benzrf> > pure 3 :: [Int]
13:35:31 <lambdabot>  [3]
13:36:37 <ski> athan : a `callCC :: forall m a. MonadCont m => ((forall b. a -> m b) -> m a) -> m a' would be rank-3, because the `forall b.' is to the left of two `->'s (the `->' in `forall b. a -> m b' doesn't count, since the `forall' is "outside" it : `forall b. (a -> m b)')
13:37:22 <L8D> is there a standardized category for mapping over the left side of binary sum types?
13:37:51 <ski> athan : also, i think as far as GHC is concerned, `... =>' counts the same as `forall's, when computing the rank
13:38:35 <jeltsch> ski, athan: Yes, the => implicitly introduces a forall, I think. Otherwise, it wouldn’t make sense.
13:39:30 <ski> athan : so `give :: forall a r. a -> (Given a => r) -> r' in edwardk's `reflection' package counts as rank `2', even if there's no `forall' in an argument type, since there's still an `Given a =>' there
13:39:38 <apriori> I guess nobody has an idea about my "problem", yet.. or no interest? :)
13:39:42 <ski> jeltsch : "the => implicitly introduces a forall" -- no, it doesn't
13:40:02 <ski> jeltsch : if it did, then that `give' wouldn't work as expected
13:40:04 <Denommus> I have an "acceleration" behavior
13:40:11 <Denommus> and I want to integrate it to get a velocity
13:40:12 <Denommus> BUT
13:40:18 <Denommus> I want the velocity to have a maximum
13:40:33 <ski> @hackage reflection  -- it's this package
13:40:33 <lambdabot> http://hackage.haskell.org/package/reflection  -- it's this package
13:40:48 <EvanR> did not know you could put constraints in that position
13:40:58 <ski> it's not that common, but it happens
13:41:02 <jeltsch> ski: Hmm, I didn’t know about this feature. That’s interesting. So you can have “local dictionaries”.
13:41:30 <Denommus> if I just use max (-200) . min 200 <$> integral (acceleration <*> movementKeys) dt, the integral of acceleration will keep increasing while the velocity is at the ceiling
13:42:01 <gcganley> are there any papers on monad transformers? i only found 'monad transformers- step by step'
13:42:13 <dmj`> gcganley: that's a good one
13:42:28 <ski> this is also a good reason for not writing e.g. `[exists s. Show s => ([s],s -> Int)]' in pseudocode
13:42:35 <kadoban> gcganley: typeclassopedia had at least one or two more links about that I think
13:42:40 <ReinH> gcganley: (You have an existence proof, so yes.) ;)
13:42:40 <dmj`> gcganley: I think the key to monad transformers is understanding kinds
13:42:51 <EvanR> Denommus: maybe switch between two accelerations (one is zero) depending on the velocity? (this makes your definition recursive, but id hope thats not an issue)
13:43:02 <gcganley> ReinH: quit sassing me!
13:43:08 <ReinH> gcganley: :)
13:43:10 <ski> at least not if you mean that each element of a list of this type is supposed to *provide* an instance `Show s' for some hidden type `s', together with a pair of type `([s],s -> Int)'
13:43:46 <EvanR> Denommus: a similar idea would be needed for velocity-dependent force laws, like air friction
13:43:47 <shachaf> ski++
13:43:48 <ski> if that's what you mean, then you should write something like `[exists s. Show s *> ([s],s -> Int)]', where `*>' is meant to be read as "provides", as opposed to `=>' which is "requires"
13:44:04 <ski> shachaf ?
13:44:11 <gcganley> dmj': why do you mention kinds? how are they im portant?
13:44:42 <shachaf> ski: Just for talking about *>
13:44:47 <ski> hehe
13:44:55 <dmj`> gcganley: when you want to make monad transformer stacks, understanding higher kinded types is important
13:44:58 <dmj`> :k StateT
13:45:00 <lambdabot> * -> (* -> *) -> * -> *
13:45:01 <dmj`> :k ReaderT
13:45:02 <lambdabot> * -> (* -> *) -> * -> *
13:45:03 <EvanR> what is *> ?
13:45:06 <dmj`> :k WriterT
13:45:06 <EvanR> what do i google
13:45:07 <lambdabot> * -> (* -> *) -> * -> *
13:45:08 <dmj`> there is a pattern
13:45:22 <ski> i invented the symbol `*>' here .. not that i claim it's necessarily very good. but i had to invent *some* notation to be able to talk effectively about this
13:45:28 <dmj`> so you can keep stackin' with the higher kinded type
13:45:56 <dmj`> :k StateT Int (StateT Int (StateT Int IO)) Int
13:45:57 <lambdabot> *
13:46:05 <athan> ski: I'm going to need to take a breather for a little while, this is some really heavy stuff for me right now. Thank you so much though, this is redicuously enlightening
13:46:20 <ski> if we ever get `exists' as a more common extension (i think UHC or LHC provides support for `exists' in negative positions), then we'd also want a notation for `*>' (not necessarily the one i used)
13:46:30 <ski> athan : ok, have fun :)
13:46:50 <ReinH> gcganley: A story about David Hilbert that I'm quite fond of goes... Hilbert was meeting with an old acquaintance and he asked if a fellow mathematician that he hadn't heard from in many years was still alive. His friend said that he was and began telling Hilbert how he had gotten married, how they had just had their second child, and so on. Meanwhile,
13:46:50 <ReinH> Hilbert started making small, slightly frantic gestures and saying "Wait... wait...". When his friend finally quieted down, Hilbert said "I don't care about all that. I just asked if he still exists."
13:47:01 <ReinH> And he left :/
13:47:10 <shachaf> "data k *> a = k => Foo a" is valid in GHC.
13:47:25 <shachaf> Of course it's not automatic like the real *> would be.
13:47:52 <ski> ReinH : hehe
13:47:52 <shachaf> But it's something, and I imagine that first-class exists is easier to implement without *>
13:48:43 <ski> (providing support for `exists' in negative positions isn't that hard. the hard part is allowing it in positive positions)
13:49:16 <ski> (because `forall a. (..a.. -> ...)' is logically equivalent to `(exists a. ..a..) -> ...'
13:49:19 <ski> )
13:50:31 <ski> however .. i wonder if it would be useful to infer types like `fst :: forall a. (exists b. (a,b)) -> a' (and treat `fst :: (a,b) -> a' as sugar for that instead)
13:51:13 <ski> @type compare `on` fst
13:51:14 <lambdabot> Ord b => (b, b1) -> (b, b1) -> Ordering
13:51:16 <ski> @type comparing fst
13:51:17 <lambdabot> Ord a => (a, b) -> (a, b) -> Ordering
13:51:53 <Denommus> EvanR: I could test that, though I'm not sure if reactive-banana would be any good on that
13:51:55 <ski> if so, then those would possibly get types `(a,b0) -> (a,b1) -> Ordering', instead of `(a,b) -> (a,b) -> Ordering'
13:51:59 <ski> so, it'd be more general
13:52:59 <ski> perhaps one could also special case stuff like `forall a. (..a.. -> ..a.. -> ...)' to treat it more like it had been `(exists a. (..a..,..a..)) -> ...', i'm not sure
13:54:03 <EvanR> Denommus: would be nice if you could encode these dynamic behaviors essentially as the differential equations they came from
13:57:39 <adrien`> oklm
13:58:16 <hsk8> Is it valid to think about Monads as concrete things that can be passed in and out of functions? For example: Can I take an IO monad that reads one line from a file, pass it into a function that does something with that line and returns a tuple: (result, a new monad that reads the next line in the file) ?
13:58:22 <hsk8> Or is this total bullcrap?
13:58:56 <ski> hsk8 : no, a monad is not a concrete thing that can be passed around
13:59:15 <Ralith> hsk8: replace 'monad' with 'value in a monad' and you'll be closer
13:59:21 <ski> a monad ia a type (function) (together with two operations implementing an interface/signature in terms of it)
13:59:23 <saep> It's a type class with two functions in it.
13:59:43 <ski> saep : `Monad' is, yes. "a monad" isn't quite the same
13:59:44 <lifter> hsk8: Strictly speaking, in your example you would not get "a new monad"
13:59:58 <EvanR> hehe "a monad"
14:00:00 <hsk8> hmm
14:00:16 <exio4> a wild monad appears
14:00:20 <EvanR> fistful of monads
14:00:23 <EvanR> for a few monads more
14:00:33 <hsk8> the good, that bad, and the monad
14:00:38 <EvanR> official currency of haskell land
14:00:48 <ski> hsk8 : i'd say "monadic computation" or "monadic action" or "`IO'-action" or "monadic value". Ralith's "value in a monad" is also ok
14:00:51 <NikolajK> are you implying monad\simeq ugly?
14:00:55 <EvanR> everyone is armed with a functor
14:01:59 <kadoban> EvanR: Based on the classic japanese Yojimbonad
14:02:02 <hsk8> So does the whole thing have to be in a single do block (or a single series of >>= binds), or can I separate them somehow?
14:02:11 <hsk8> Hmmmmmmm
14:02:39 <hsk8> Just wondering how i loop through the whole file, without the IO being within my main entry point....
14:02:52 <hsk8> fuck I don't even know where to begin!
14:02:56 <simpson> Hm. I prefer the modern animated stuff, like Samurai Champlonad.
14:02:57 <ski> hsk8 : so, your function is passed an `IO'-action that, when (later) executed, will read one line from a file (presumably yielding that line as monadic result from the action), and the function will attach a "post-processing" part to the action, that calls some extra function on the line and computes a pair of some result and a new monadic action that reads the next line
14:03:00 * simpson is late
14:03:21 <kadoban> Never too late for bad puns
14:03:23 <ski> hsk8 : so, taken together, the type of your function would be something like `IO String -> IO (Result,IO String)', i think
14:03:31 <ski> hsk8 : do you agree ?
14:03:34 <NikolajK> I like that song from the Matrix soundtrack, Monad Lisa Overdrive
14:04:02 * adrien` q
14:04:11 <hsk8> ski: yeah that sounds right
14:04:14 <ski> hsk8 : "does the whole thing have to be in a single do block (or a single series of >>= binds)" -- not necessarily. "or can I separate them somehow?" -- it depends on what exactly you want to do
14:04:51 <hsk8> i can't think about my program sequentially in haskell so i'm totally lost, heh
14:05:19 * hackagebot haste-perch 0.1.0.5 - Create, navigate and modify the DOM tree with composable syntax, with the haste compiler  http://hackage.haskell.org/package/haste-perch-0.1.0.5 (AlbertoCorona)
14:05:28 <kadoban> hsk8: Note that a lot of the things you use in monadic context /are/ separated out monadic code themselves. So they can be taken as a guide in how to do it...or at least the type of them can guide you, even without knowing how they're implemented.
14:05:30 <ski> hsk8 : note that a function of my type returns a monadic action that, whenever (later) executed, will produce a `String' as monadic result, together with a *new* `IO'-action (deferred, as every such action is), which *yet* later will be executed to yield a `String'
14:05:59 <EvanR> to get a feel for IO you dont have to worry about monads
14:06:19 <vanila> think about meaning of each piece rather than the execution
14:06:23 <fragamus> I have a question: my function gets a string constant and then internally there is another function defined with several different input patterns and corresponding implementations.  CAN I USE the string constant parameter of the outer function in the pattern without symbol shadowing
14:06:43 <fragamus> the string constant is a parameter to the outer function
14:06:57 <fragamus> does this make any sense
14:07:04 * ski . o O ( "You face 1 wild monad(s). What will your stalwart party do ? (R)un. (G)reet. (A)ttack." )
14:07:32 <fragamus> does anybody really know what time it is
14:07:42 <ski> @time lambdabot
14:07:42 <lambdabot> I live on the internet, do you expect me to have a local time?
14:08:37 <fragamus> @ lambdabot do you care
14:08:47 <fragamus> @lambdabot do you care
14:08:47 <lambdabot> Unknown command, try @list
14:08:47 <benmachine> ...evidently not
14:09:07 <hsk8> ski: how do I loop through the lines in a file?
14:09:20 <ski> hsk8 : what, more precisely, are you trying to do ?
14:09:32 <fragamus> I have a question: my function gets a string constant and then internally there is another function defined with several different input patterns and corresponding implementations.  CAN I USE the string constant parameter of the outer function in the pattern without symbol shadowing
14:10:15 <exio4> fragamus: can you give us an "example" of what you exactly mean?
14:10:19 <byorgey> fragamus: no, you have to use e.g. a guard with an equality test
14:10:29 <fragamus> thanx
14:10:36 <ski> hsk8 : well, usually either through recursion, or some combinator like `forever'
14:10:59 <byorgey> if you have a pattern consisting of a variable name, it always matches anything, and shadows anything else with that name which might happen to be in scope
14:11:06 <ski> fragamus : no, unfortunately not (Prolog and Erlang support such things)
14:11:17 <hsk8> ski: read a line. take the line, take an initial state, put both into a function that returns data that i want to insert into a given list for later retrieval and a new state. Repeat with the next line in the file and the new state. Until EOF.
14:11:33 <ski> fragamus : you have to use a guard with an equality, or something equivalent
14:11:42 <fragamus> thanx
14:12:16 <hsk8> ski: so i could construct that function. just not sure how to actually do anything with it..
14:12:23 <sshine> I came up with 'takeWhileM f m = do { a <- m; if f a then fmap (a:) $ takeWhileM f m else return [] }', but I'm afraid this combinator is a little too greedy as it does whatever with m once too many. (the intended use is for stateless parser generators in which I think it's okay, but generally for monads, this is perhaps not so good.)
14:12:23 <hsk8> looping through the lines, that is
14:12:38 <ski> fragamus : e.g. `f s0 = ... where g s1 | s0 == s1 = ... | otherwise = ...' or `f s0 = ... where g ((s0 ==) -> True) = ...; g s1 = ...'
14:12:52 <ski> (the latter using a view pattern)
14:13:01 <hsk8> ski: would the IO String have to be a part of the state?
14:13:40 <yitz> sshine: but how could you possible check the condition without running the action?
14:13:45 <yitz> *possibly
14:14:29 <sshine> yitz, I couldn't. but I'm thinking that before it's really useful in a general sense, I'd want to be able to undo whatever side-effect. maybe not!
14:14:31 <ski> hsk8 : hm, does `function :: String -> YourState -> (YourData,YourState)' sound right ?
14:14:51 <hsk8> ski: hell yeah
14:14:54 <hsk8> indeed
14:15:00 <ski> hsk8 : have you used any state monad yet ?
14:15:12 <hsk8> I just read about the one in LYAH
14:15:20 <hsk8> are there many of them?
14:15:23 <ski> hsk8 : "would the IO String have to be a part of the state?" -- i dunno, it depends on what you need in your state
14:15:40 <hsk8> well I just need IO to read those lines
14:16:04 <hsk8> so i probably don't need it in the state
14:16:33 <yitz> sshine: oh. there was some discussion in the past about reversible monads, but i don't think it ever caught on.
14:16:50 <ski> for each (concrete) type `s', `State s' is a state monad. also for each (concrete) `s' and (monad) `m', `StateT s m' is a state monad. also if `m' is a state monad, then stuff like `ReaderT r m',`WriterT o m',`ContT o m',&c. inherit being state monads
14:17:11 <ski> hsk8 : but the basic idea is `State s', and it's monad transformer version `StateT s m'
14:17:39 <ski> hsk8 : using `State', we could rewrite the signature of your function to `function :: String -> State YourState YourData'
14:17:57 <ski> thereby *hiding* the passage/threading of the state values
14:18:52 <sshine> yitz, I actually want to include the first return value that fails, but thanks for making me think of the "undo" monad. :)
14:19:04 <hsk8> hmok..
14:19:18 <hsk8> so if I constructed that function
14:19:22 <hsk8> how would i loop thorugh the file?
14:19:24 <hsk8> until EOF
14:19:46 <ski> sshine : hm .. so you want to revert the state to just before the last `m' ..
14:20:19 * hackagebot diagrams-core 1.2.0.3 - Core libraries for diagrams EDSL  http://hackage.haskell.org/package/diagrams-core-1.2.0.3 (bergey)
14:20:21 * hackagebot network-conduit-tls 1.1.0.2 - Create TLS-aware network code with conduits  http://hackage.haskell.org/package/network-conduit-tls-1.1.0.2 (MichaelSnoyman)
14:20:23 * hackagebot streaming-commons 0.1.6 - Common lower-level functions needed by various streaming data libraries  http://hackage.haskell.org/package/streaming-commons-0.1.6 (MichaelSnoyman)
14:21:10 <ski> sshine : possibly you could use a failure/exception monad, and catch the failure/exception, if any, and then stop the recursion .. if the failure/exception monad is correctly built, it will revert any present state (may not work with state in `IO')
14:21:16 <EvanR> LIT = local internet time
14:24:09 <Denommus> EvanR: my recursive definition didn't work :-/
14:24:14 <EvanR> what happened
14:25:11 <Denommus> EvanR: it... doesn't change the velocity value
14:25:16 <Denommus> EvanR: let me gist it
14:25:19 * hackagebot diagrams-lib 1.2.0.5 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-1.2.0.5 (bergey)
14:25:21 * hackagebot force-layout 0.3.0.8 - Simple force-directed layout  http://hackage.haskell.org/package/force-layout-0.3.0.8 (bergey)
14:25:48 <johnw> I wonder if that's the sort of layout that Yoda would choose...
14:25:48 <Rufflewind_> does anyone know how to do token pasting in CPP?  (i.e. things like "tok ## en")
14:26:45 <Denommus> EvanR: here: https://gist.github.com/Denommus/2e128fe465c7fb6e5eaa
14:27:01 <Denommus> EvanR: nothing impossibly difficult to understand
14:28:15 <EvanR> Denommus: in this code, it looks like you check the value of v only once
14:28:28 <EvanR> at the beginning
14:28:54 <EvanR> i was thinking you had some kind of switcher or combinator for this
14:29:04 <Denommus> EvanR: ... oh
14:29:12 <Denommus> EvanR: you're right
14:29:17 <EvanR> but i dont know reactive banana
14:29:36 <Denommus> EvanR: no, wait
14:29:50 <Denommus> EvanR: reactive-banana uses liftAN as combinators
14:30:21 <EvanR> yeah so rather than pure an if statement, <*> a function, somehow
14:31:26 <hsk8> ski: but how can i possibly write the function `function :: String -> State YourState YourData'? Don't I have to know the input state?
14:31:49 <EvanR> :t get
14:31:50 <lambdabot> MonadState s m => m s
14:31:57 <Denommus> EvanR: I was lifting before, it also did not work
14:31:59 <johnw> you can ignore the input state
14:32:05 <Xenasis> Can someone confirm whether sortBy puts LT elements at the front or back?
14:32:06 <shachaf> hsk8: "State YourState YourData" is a fancy way of writing "YouState -> (YourState, YourData"
14:32:10 <johnw> function :: String -> State s a
14:32:14 <Xenasis> I'm assuming front but getting odd behaviour
14:32:17 <Denommus> EvanR: I think the problem is that reactive-banana doesn't support recursive definitions on its network
14:32:19 <hsk8> oh of course
14:32:19 <Xenasis> can't find it in the documentation
14:32:31 <shachaf> hsk8: So that's really a function that takes a String and an old state, and returns yourdata along with a new state.
14:32:39 <EvanR> Denommus: maybe. maybe integral is a special case, but seems like thats a little limiting
14:32:40 <johnw> although, it's odd to have a function which completely ignores the state
14:32:40 <hsk8> shachaf: interesting
14:32:58 <Denommus> EvanR: http://stackoverflow.com/questions/7850389/can-reactive-banana-handle-cycles-in-the-network
14:32:59 <johnw> if you just write function :: String -> a, then the user can call 'function' like any other
14:33:27 <hsk8> shachaf: now the question is this: how can I call this successively on the lines of a file, line after line (the line goes into the String parameter), until the end of file?
14:33:41 <hsk8> shachaf: while also throwing each YourData output into a list
14:33:58 <hsk8> (so i can output that list later, or perhaps even write that into a file)
14:34:02 <hsk8> (another file)
14:34:41 <ski>   hGetAndProcessLines :: (String -> s -> (a,s)) -> Handle -> s -> IO ([a],s)
14:34:46 <shachaf> You should ask the channel, not a someone who answered an unrelated question. :-)
14:34:51 <sshine> ski, what's the h stand for?
14:34:56 <ski>   hGetAndProcessLines step handle = loop
14:35:01 <ski>     where
14:35:07 <EvanR> Denommus: maybe, instead, theres a way to trigger an event when the velocity reaches a max, in which case you change the behavior
14:35:13 <ski>     loop state = do
14:35:13 <shachaf> sshine: Handle
14:35:19 * hackagebot diagrams-contrib 1.1.2.3 - Collection of user contributions to diagrams EDSL  http://hackage.haskell.org/package/diagrams-contrib-1.1.2.3 (bergey)
14:35:21 * hackagebot diagrams-svg 1.1.0.2 - SVG backend for diagrams drawing EDSL.  http://hackage.haskell.org/package/diagrams-svg-1.1.0.2 (bergey)
14:35:23 * hackagebot diagrams-cairo 1.2.0.4 - Cairo backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-cairo-1.2.0.4 (bergey)
14:35:25 * hackagebot diagrams-postscript 1.1.0.2 - Postscript backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-postscript-1.1.0.2 (bergey)
14:35:27 <sshine> shachaf, ah!
14:35:27 * hackagebot diagrams-rasterific 0.1.0.4 - Rasterific backend for diagrams.  http://hackage.haskell.org/package/diagrams-rasterific-0.1.0.4 (bergey)
14:35:51 <ski>       result <- tryJust (guard . isEOFError) $
14:36:01 <ski>         hGetLine handle
14:36:10 <ski>       case result of
14:36:26 <ski>         Left  ()   -> return ([],state)
14:36:54 <ski>         Right line -> let (a,newState) = step line state in
14:37:16 <ski>           liftM (first (a :)) (loop newState)
14:37:29 <ski> hsk8 : if you don't care for the final state, it becomes slightly easier
14:38:54 <ski> hsk8 : "but how can i possibly write the function `function :: String -> State YourState YourData'? Don't I have to know the input state?" -- no. you provide that in the initial call of `function'
14:39:07 <ski> it's hidden in this `function'
14:39:19 <hsk8> interesting....
14:40:18 <EvanR> you do?
14:40:29 * hackagebot diagrams-canvas 0.3.0.2 - HTML5 canvas backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-canvas-0.3.0.2 (bergey)
14:40:35 <ski> hsk8 : now, i made `hGetAndProcessLines' take your stepping function as argument. if you're only interested in a particular stepping function, you could inline that into the definition of `hGetAndProcessLines', and remove the first argument
14:40:41 <EvanR> you only provide a String in any call to function
14:41:12 <ski> EvanR : "the input state" being the implicit input of type `YourState'
14:41:17 <EvanR> though in some cases State a b is itself a synonym for another function that does take the state
14:41:18 <Denommus> EvanR: I changed my definition, but even after the fact it didn't work
14:41:25 <hsk8> ok I gotta read about the liftM function i guess. it's later in the LYAH chapter
14:41:39 <hsk8> that's where you do the looping, correct?
14:41:46 <Denommus> EvanR: I guess it's the problem with reactive-banana's recursive definitions, indeed. Maybe I should try my hand at Netwire again
14:42:06 <EvanR> Denommus: maybe the event + modify behavior route
14:42:35 <ski> hsk8 : now, this is the plain version of `hGetAndProcessLines'. a state-monadic version would be either `hGetAndProcessLines :: (String -> s -> (a,s)) -> Handle -> StateT s IO [a]' or `hGetAndProcessLines :: (String -> State s a) -> Handle -> StateT s IO [a]' (though changing to the same thing, if you inline the stepping function)
14:43:12 <ski> hsk8 : such a version of `hGetAndProcessLines' could be useful if you want to continue implicitly threading the state along, after you've called `hGetAndProcessLines'
14:43:33 <hsk8> ok..
14:43:42 <Denommus> EvanR: well, if every time I need a recursive definition I get into this, that won't be a lot practical for, say, a physics engine (which needs a lot of those)
14:44:00 <Denommus> EvanR: so I guess I'll just return to Netwire, indeed
14:44:16 <EvanR> Denommus: yeah i havent been able to make sense of any of these libs so far
14:44:24 <ski> hsk8 : so, there's a plain version, which is fine, and then there's a few more advanced versions, which may look nicer in code, since they hide more annoying detail
14:44:46 <hsk8> ski: so i gotta study liftM and StateT (i only know plain State)
14:45:12 <ski> sshine : .. would an exception monad work in your case, do you think ?
14:45:20 <Denommus> EvanR: Netwire is a lot more difficult
14:45:35 <Denommus> EvanR: reactive-banana is quite easy, but that is one huge limitation
14:45:59 <ski> hsk8 : `liftM' is the same as `fmap', but only works for monads (every monad is a functor, though possibly not every Haskell instance of `Monad' is an instance of `Functor')
14:46:06 <ski> hsk8 : do you know `fmap' ?
14:46:18 <EvanR> Denommus: perhaps reactive banana is geared towards GUIs which arent described with physics equations
14:46:27 <Denommus> EvanR: most likely
14:46:58 <hsk8> ski: yeah i know fmap
14:47:17 <ski> hsk8 : instead of `first (a :)', i could just as well have said `\(as,aState) -> (a : as,aState)' in there. it's just a shorthand (if you don't care for the final state, then this part of the could could be simplified to just `(a :)'
14:47:38 <ski> s/the could could/the code could/
14:48:21 <EvanR> Denommus: as an exercise, implement an applicative style "time varying value" thing yourself which can do recursive definitions, integral for example. i did this but then couldnt figure out how to make it dynamic, like react to events
14:48:40 <ski> hsk8 : for `IO', `liftM'/`fmap' adds a "postprocessing function" to the "end" of an `IO'-action, to be used to transform the monadic result value, whenever the action is executed
14:48:52 <EvanR> Denommus: my version was only i.e. pure
14:49:33 <Denommus> EvanR: I believe you
14:49:50 <ski> hsk8 : in this case, the recursive call will yield `(as,finalState)' as monadic result, and we wanted to add `a' to this, i.e. `(a : as,finalState)', before we return from the current recursive call to `loop'
14:51:15 <hsk8> ski: this is a lot to take in. i'm gonna have to save this conversation for future studying. first i'll try to implement the simpler function
14:51:22 <hsk8> thanks for the info!
14:51:32 <ski> hsk8 : we could just as well have said `do let {(a,nextState) = step line state}; (as,finalState) <- loop nextState; return (a : as,finalState)' instead, but that's more wordy than `let (a,nextState) = step line in liftM (\(as,finalState) -> (a : as,finalState)) (loop nextState)'
14:52:18 <ski> hsk8 : sounds like good idea (starting with the simpler version first, making sure you understand it before you pass to the next level of sophistication or abstraction)
14:52:28 <hsk8> yeah
14:52:30 <ski> hsk8 : yw
14:54:53 <ski> hsk8 : i used `tryJust' to catch the end-of-file condition .. in some cases it's more convenient to use the variant `catchJust' instead
14:55:19 * hackagebot hailgun 0.4.0.0 - Mailgun REST api interface for Haskell.  http://hackage.haskell.org/package/hailgun-0.4.0.0 (RobertMassaioli)
14:56:07 <ski> hsk8 : however, one thing to look out for here, and avoid, is to include the recursive call by mistake under the exception handler installed by `catchJust' or `tryJust' .. that would mean nesting of exception handlers, which is suboptimal for applications like this
14:56:28 <ski> (and sometimes it might give wrong behaviour, i think)
14:56:35 <hsk8> ok
14:57:00 <ski> you want the exception handler to only catch exceptions from `hGetLine' (in this case). the recursive call which continues shouldn't be covered under it
14:57:45 <ski> the recursive call could in some cases perhaps also generate the same set of exceptions which is caught in this handler (say because you also read from another file handle)
14:58:10 <ski> and in that case, you may not want to catch those end-of-file conditions here, instead letting the caller of this function handle that
14:59:58 <ski> "Catching exceptions only where needed: let try _name_ = _expr1_ in _expr2_ with _exception-handler_" <http://mjambon.com/extend-ocaml-syntax.html#lettry> is about a syntax extension in OCaml, to be able to express this idiom more naturally
15:00:01 <EvanR> need a function which is maybeHGetLine :: Handle -> IO (Maybe String)
15:00:23 <ion> maybeLaunchMissiles
15:00:38 <EvanR> hGetMaybeLine
15:01:02 <ski> "Exceptional Syntax" by Nick Benton,Andrew Kennedy in 2001-07 at <http://research.microsoft.com/en-us/um/people/akenn/sml/exceptionalsyntax.pdf> is the corresponding paper for this idea
15:01:18 <ski> (they also have semantic reasons for wanting such a construct, not just pragmatic ones)
15:01:27 <hsk8> i'll keep that in mind thx
15:01:28 <benmachine> ski: I think OCaml actually recently added match expr with | pat -> blah | exception ex -> blah
15:02:17 <ski> .. so, i'd like a
15:05:11 <ski>   catchBind :: Exception e => IO a -> (e -> IO b) -> (a -> IO b) -> IO a
15:05:14 <ski> and a
15:05:15 <ski>   catchBindJust :: Exception e => (e -> Maybe b) -> IO a -> (b -> IO c) -> (a -> IO c) -> IO c
15:05:18 <ski> operation
15:05:29 <ski> .. and corresponding versions for `handle' and `handleJust'
15:05:34 <L8D> @pl \e -> f >>= \_ -> return e
15:05:34 <lambdabot> (f >>=) . const . return
15:05:46 <L8D> @pl \e -> f >> return e
15:05:46 <lambdabot> (f >>) . return
15:06:06 <L8D> I think pl is broken
15:06:22 <benmachine> L8D: output looks reasonable to me?
15:08:08 <ski> benmachine : ok, that's new to me. i've actually earlier thought that `match expr with pat -> blah | raise ex -> blah' would be a nice syntax for this
15:08:42 <benmachine> ski: it's only a few months old, I think
15:08:52 <ski> benmachine : because then it's obvious what `match raise SomeExn with <pat> -> ... | raise SomeExn -> ...' will do :)
15:08:54 <benmachine> new in 4.01 or 4.02, I forget which
15:09:04 <benmachine> ski: yeah, I get it, it's cute :P a little too cute, perhaps
15:09:14 <ski> hehe, i don't think so :)
15:09:33 <ski> the more corresponding pieces of pattern and expression syntax agree, the better, imo
15:09:44 <ski> it enables using equational reasoning better
15:09:45 <benmachine> you will get people trying to do match let x = 3 in x + 5 with | let x = 7 in x + 1 -> ...
15:10:16 <ski> hehe, i've actually earlier thought about what would be a sensible semantics for such `let' patterns
15:10:20 <benmachine> :P
15:10:25 <benmachine> I can sort of imagine how it might work?
15:10:27 <tomberek> ski: that trick using /=/ Void worked fine.  But now I've got another issue.  How does one recurse using type-level Nats? How does one write a function like: Do n -> D (n-1)  and express a base case?
15:10:28 <ski> the syntax would be like `let <expr> = <pat> in <pat>'
15:10:39 <benmachine> mm
15:10:59 <benmachine> wait, <expr>? interesting
15:11:28 <ski> to match a value with a pattern `let <expr> = <pat 0> in <pat 1>', you match it with `<pat 1>', possibly binding variables. then you compute `<expr>' and match *its* result with `<pat 0>', and also add the bound variables from that match to your binding set
15:11:44 <L8D> @pl \e -> print e >> return foo
15:11:44 <lambdabot> (>> return foo) . print
15:12:47 <EvanR> (>> return foo) . print is a good way to disuade people who think java-like notation is better ;)
15:13:34 <L8D> @pl \e -> print e >> return foo
15:13:34 <lambdabot> (>> return foo) . print
15:13:36 <L8D> whoops
15:13:46 <ski> benmachine : so, if you match `let (xs,ys) = p in [xs,ys]' with a dupleton list `[[0,1],[2,3,4]]' of lists, `xs' would be bound to `[0,1]',`ys' to `[2,3,4]', and `p' to `([0,1],[2,3,4])' -- probably `xs' and `ys' would also be *local* variables to this `let' pattern, so that the whole pattern *only* binds `p'
15:13:46 <L8D> EvanR: yeah I'm not doing that
15:14:13 <L8D> I only use @pl to see if there is a better function to do what I'm looking for
15:14:17 <L8D> single hoogle is broken
15:14:34 <ski> benmachine : this accords directly with *evaluating* an expression `let (xs,ys) = p in [xs,ys]' (assuming `p' is bound to `([0,1],[2,3,4])') -- this would then evaluate to `[[0,1],[2,3,4]]'
15:14:36 <dfeuer> HOOGLE
15:14:56 <ski> benmachine : see what i mean by "the more corresponding pieces of pattern and expression syntax agree, the better" ? :)
15:15:19 <ski> benmachine : the pattern-matching process here is a reversal of the corresponding evaluation/reduction process
15:15:32 <benmachine> ski: that does make a lot of sense
15:16:15 <ski> and the restriction that variables bound in `<pat 1>' would only be visible in `<expr>' but wouldn't be bound (exported) by the whole of `let <expr> = <pat 0> in <pat 1>' isn't an onerous restriction
15:16:53 <ski> benmachine : one could always write e.g. `let ((xs,ys),xs,ys) = (p,xs,ys) in [xs,ys]', if one wanted this pattern to also export bindings for `xs' and `ys'
15:17:04 <ski> (so, a little more to type, but it's not hard to write or read)
15:17:24 * benmachine vaguely wonders whether there's any sense in having a construct to delete a variable from a scope
15:17:43 <ski> (hm, on second thought, either set of `xs',`ys' ought to be renamed. otherwise this `((xs,ys),xs,ys) = (p,xs,ys)' would confusingly look like a *recursive* binding)
15:17:52 <yukko> I don't think so, shadowing works just as fine
15:17:57 <ski> so, say `let ((xs0,ys0),xs,ys) = (p,xs,ys) in [xs0,ys0]' or something
15:17:57 <benmachine> `let ((xs,ys),xs,ys) = (p,xs,ys) in unlet xs ys in ...
15:18:01 <ski> er
15:18:05 <ski> so, say `let ((xs0,ys0),xs0,ys0) = (p,xs,ys) in [xs0,ys0]' or something
15:18:31 <ski> benmachine : sometimes i've wanted such an `unlet'/`forget' unscoping operation :)
15:18:34 <benmachine> ski: you're binding the same variable multiple times there?
15:18:54 <ski> (and it's mentioned e.g. in Paul Taylor's nice book "Practical Foundations of Mathematics")
15:18:58 <bryanedds> Is there a general function for converting a newtype'd value back to the old type?
15:19:21 <benmachine> bryanedds: no, sometimes such a function is deliberately not exported
15:19:23 <joelteon> no, that would break type safety
15:19:29 <joelteon> it defeats the purpose of newtypes
15:19:36 <benmachine> well
15:19:43 <benmachine> another answer is "yes, unsafeCoerce"
15:19:44 <tomberek> it seems the built-in type Lits cannot perform induction, is this accurate?
15:19:52 <ski> benmachine : yes, i realize `let ((xs0,ys0),xs0,ys0) = (p,xs,ys) in [xs0,ys0]' can't directly be interpreted as an expression (only as a pattern), because of the linear variables in patterns restriction
15:20:03 <tomberek> https://ghc.haskell.org/trac/ghc/wiki/TypeNats/MatchingOnNats
15:20:09 <benmachine> ski: oh right, I was a bit confused as to what exactly you were doing
15:20:17 <bryanedds> how would the manual invocation of a converter function break type-safety in any way?
15:20:20 * hackagebot hailgun-send 0.1.1.1 - A program to send emails throught the Mailgun api.  http://hackage.haskell.org/package/hailgun-send-0.1.1.1 (RobertMassaioli)
15:20:22 <ski> benmachine : however, a correct evaluation of an expression `let ((xs0,ys0),xs0,ys0) = (p,xs,ys) in [xs0,ys0]' would have to match the components of `p' with `xs' and `ys' anyway
15:21:03 <ski> so, the closest corresponding expression we can make is `let (xs0,ys0) | xs0 == xs && ys0 == ys = p in [xs0,ys0]'
15:21:07 <benmachine> ski: I think I missed a single line you said five minutes ago and it all makes way more sense now
15:21:33 <ski> but now this can't be interpreted as a pattern (well, i *think*, i'm not completely sure :), since `xs' and and `ys' aren't bound yet
15:22:31 <ski> hmmm
15:22:41 <ski> no, it can't
15:22:41 <bryanedds> so there is no automatic exporting of a converter function from newType to oldType, or vice-versa?
15:22:53 <bryanedds> this seems like something that could be added to haskell
15:23:05 <ski> benmachine : it can't really be fixed, because `xs0 == xs' is different syntactically from `xs0 = xs'
15:23:14 <bryanedds> presuming, of course, noone can show how it would actually break type safety
15:23:22 <ski> benmachine : in something like Prolog, Mercury, or Erlang, this could work, though
15:24:04 <red__> i am trying to finish up a simple backtracking sudoku solver ... for the solve function, i find the first blank and fill in an Int from [1..] .. for each one i try and solve the resulting board that has that Int <- [1..9] in place . how do i apply my update function to a [1..9]? I'm brainfarting here
15:24:17 <ski> so, if you don't want/need `xs' and `ys' outside the local scope of the `let', then `let (xs,ys) = p in [xs,ys]' works just fine as either a pattern or an expression
15:24:24 <EvanR> bryanedds the default is to export everything
15:24:34 <red__> i don't want to map solve over [1..9] .. right?
15:24:57 <bryanedds> I'm sorry, I mean _generate_, not export
15:25:07 <ski> but if you want `xs' and `ys' outside, then as a pattern you need `let ((xs0,ys0),xs0,ys0) = (p,xs,ys) in [xs0,ys0]', while as an expression you need `let (xs0,ys0) | xs0 == xs && ys0 == ys = p in [xs0,ys0]'
15:25:09 <kolossen> > \x -> x*x
15:25:10 <lambdabot>  <Integer -> Integer>
15:25:12 <kolossen> > \x -> x*x 5
15:25:13 <lambdabot>  Occurs check: cannot construct the infinite type: t ~ a -> t
15:25:13 <lambdabot>  Relevant bindings include x :: a -> t (bound at <interactive>:1:2)
15:25:17 <ski> benmachine : it can't really be helped in this case, afaics
15:25:20 <kolossen> > (\x -> x*x) 5
15:25:21 <lambdabot>  25
15:25:23 <bryanedds> such a function painr could be automatically generated with each newtype declaration
15:25:24 <EvanR> ryanakca: newtype generates the conversion function, i.e. the constructor
15:25:33 <EvanR> bryanedds:
15:25:54 <bryanedds> right, the conr is generated, my bad
15:26:08 <kolossen> > let f a = (\y -> y * ((\x -> x*y) 5)) in f 6
15:26:09 <lambdabot>  <Integer -> Integer>
15:26:13 <bryanedds> but what about a destructuring function that goes the other?
15:26:16 <bryanedds> *way
15:26:25 <mauke> newtype T1 = In{ out :: T2 }
15:26:25 <kolossen> > let f a = (\y -> y * ((\x -> x*7) 5)) in f 6
15:26:26 <phaskell> T2: Move wiki to rackspace vm - https://phabricator.haskell.org/T2
15:26:26 <phaskell> T1: SSL for monitor.haskell.org/nagios - https://phabricator.haskell.org/T1
15:26:27 <lambdabot>  <Integer -> Integer>
15:26:42 <mauke> wait, what?
15:26:51 <kolossen> > let f a = (\y -> y * ((\x -> x*7) 5)) a in f 6
15:26:52 <lambdabot>  210
15:27:03 <kolossen> > let f a = (\y -> y * ((\x -> x*y) 5)) a in f 6
15:27:04 <lambdabot>  180
15:27:06 <mauke> AT2X
15:27:11 <mauke> A T2 X
15:27:24 <ski> benmachine : i've also experimented with allowing `case' in definienda ..
15:27:55 <ski> benmachine : and obviously also `case' (and `if') (and `let', like SML has) in declarations -- all these would be quite useful, i think
15:28:06 <ski> `case' in definienda would be more experimental
15:28:30 <ski> imagine being able to say
15:28:32 <ski>   foo = ...
15:28:34 <ski>     where
15:28:38 <ski>     if ...
15:28:49 <ski>       then x = ...
15:28:55 <ski>            f y = ...
15:29:10 <ski>       else f t v = ...
15:29:20 <ski>             x | ... = ...
15:29:26 <ski>               | ... = ...
15:30:12 <ski> or
15:30:16 <ski>   local
15:30:23 <ski>     private0 x = ...
15:30:30 <ski>     private1 x y = ...
15:30:31 <ski>   in
15:30:39 <ski>     public z = ...
15:30:50 <ski>     public' (t0,t1) = ...
15:31:38 <JagaJaga> ski: please, use paste services for morethan3linescode... (IMO:) )
15:31:53 <ski> (the difference to using `where' or `let' is (a) `private0' and `private1' are in scope in both the public definitions; and (b), they're in scope in all the (possibly) multiple separate defining *equations* of those public/exported definitions)
15:33:00 <ski> (currently, if you want to do something like that, you have to do ugly stuff like pass the public stuff all though a single tuple)
15:33:18 <yitz> red__: think about the monad StateT s []. it does backtracking for you. there is another more complicated monad called LogicT you can also look at.
15:36:00 <benmachine> ski: passing stuff through a tuple interacts badly with polymorphism, too
15:36:47 <benmachine> ski: you should definitely use `let' instead of `local' so that `let let let in let in in x = 4 in x' becomes a valid expression
15:37:01 <benmachine> haskell with a stammer
15:37:19 <red__> yitz: would you mind taking a look at my mess-o-code?
15:37:30 <benmachine> > let in "hello"
15:37:31 <lambdabot>  "hello"
15:37:45 <ski> benmachine : well, i used `local' here only because that's what it's named in SML
15:38:15 <ski> (obviously we should think twice before messing with `local' in `MonadReader')
15:38:25 <benmachine> heh
15:38:51 <benmachine> ...when I first saw your if expr then bindings else bindings I thought, that's weird
15:38:55 <yitz> red__: i would love to but right now i have to run. take a look at some of the many sample sudoko solvers on the wiki at http://haskel.org/
15:39:00 <benmachine> but now I'm increasingly starting to think of it as sensible
15:39:12 <benmachine> the alternative being lots of repeated guards, basically
15:39:50 <johnw> given a file of Haskell code, is there any way to output the "simplified code", after some amount of rewriting and optimization transforms, but as something that is still Haskell?  I don't want to see the core, but rather the effect of unused arguments being removed, etc.
15:39:51 <yitz> benmachine: it's just syntactic sugar really. but i dunno, seems to me we have enoght syntax there already.
15:40:33 <pharpend> Is there a way to make cabal automatically rebuild my package every time I change one of the files?
15:41:17 <yitz> pharpend: if you're doing yesod development, running yesod devel does that
15:41:24 <pharpend> I'm not, unfortunately
15:41:29 <pharpend> well
15:41:33 * ski . o O ( `let  let in;  let in  do ()' )
15:41:38 <kadoban> pharpend: That sounds like it'd be horrible...every time you saved a file, it'd sit there recompiling?
15:41:43 * ski . o O ( <http://static.fjcdn.com/pictures/If+rammstein+did+code_8be9e2_5286124.png> )
15:41:45 <pharpend> kadoban: hmm
15:41:56 <indiagreen> what's the best choice for unit tests in Haskell? HUnit or hspec?
15:41:59 <vanila> lol
15:42:18 <yitz> kadoban: no it's actually really really efficient. it does feel weird at first though/
15:42:21 <indiagreen> and tasty or test-framework or something else?
15:42:32 <ski> "but now I'm increasingly starting to think of it as sensible" -- haha, i'm beginning to succeed in brainwashing you !
15:42:33 <yitz> indiagreen: tasty
15:42:43 <ski> (did i say that aloud ?)
15:42:44 <dcoutts_> pharpend: something similar is to use cabal repl, and :r
15:43:03 <yitz> indiagreen: tasty includes both hspec and hunit, and also quickcheck, smallcheck, golden...
15:43:12 <pharpend> indiagreen: For strict unit tests, hspec. (hspec is more declarative). If you don't need strict unit tests, quickcheck is great.
15:43:20 <pharpend> indiagreen: do you know what QuickCheck is?
15:43:33 <sshine> ski, funny.
15:43:50 <indiagreen> pharpend: I do, but I also do need strict unit tests here
15:43:54 <kadoban> yitz: cabal always seems to take ~forever whenever I build a package, even a simple one. Seems like it'd be confusing at best.
15:43:55 <pharpend> I haven't seen tasty
15:43:58 <pharpend> indiagreen: hspec then
15:44:02 <indiagreen> 'kay, thanks
15:44:12 <ski> benmachine : i think `if' and `case' should also allow the corresponding to happen in a `do', so that you can have a sequence of commands instead the branches (that are allowed to end with `<pat> <- <expr>'), and where the intersection of the set of bindings from all the branches would be available in the `do' "after" the `if' and `case' command
15:44:13 <pharpend> tasty doesn't look too bad. Test-framework is a royal pain in the ass
15:44:40 <ski> benmachine : btw, `if',`case',`receive' in Erlang already support this kind of thing :)
15:45:14 <benmachine> ski: "intersection" sounds like the most sensible thing, but still makes me feel a bit anxious
15:45:29 <ski> benmachine : why ?
15:45:37 <benmachine> that I'm going to have some binding accidentally created or go missing because I'm messing with another branch
15:46:01 <benmachine> I guess it makes the property of "what things does this code bind" non-local to some extent
15:46:03 <ski> well, it couldn't possibly work if one of the branches doesn't bind the variable
15:46:09 <benmachine> sure
15:46:15 <ski> so you want the implementation to yell at you then
15:46:23 <benmachine> like I said, it's the most sensible thing, that doesn't mean it's sensible :)
15:47:59 <ski> benmachine : i've also been pondering how i could have `do'-bindings automagically export through something like `blah $ do ...', provided `blah' is sufficiently polymorphic (so that the implementation can implicitly insert returning a tuple of the needed bindings, and implicitly destructure / pattern-match on it again on the outside)
15:48:17 <ski> benmachine : the "SQL-like" extensions to list comprehensions have some similar stuff
15:48:31 <benmachine> oh, I've never really touched those
15:48:42 <ski> "Generalised (SQL-Like) List Comprehensions" <https://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#generalised-list-comprehensions>
15:48:48 <ski> it's quite interesting, actually
15:48:57 <benmachine> yeah, I've heard about them, but I've never touched them
15:49:03 <benmachine> they sounded a bit... baroque?
15:49:10 <ski> (though unfortunately the description in the docs there isn't explicit enough about what happens)
15:49:32 <ski> benmachine : well, they're less baroque than one would at first thing
15:49:35 <ski> s/thing/think/
15:50:20 * hackagebot RSA 2.1.0 - Implementation of RSA, using the padding schemes of PKCS#1 v2.1.  http://hackage.haskell.org/package/RSA-2.1.0 (AdamWick)
15:50:31 <ski> (however, i'm don't quite like their use of `the' there)
15:51:03 <benmachine> ski: `then'?
15:52:49 <ski> no, `the'
15:52:54 <ski>   the :: [a] -> a
15:52:58 <ski>   the [a] = a
15:53:03 <athan> Can you put conditions for a guard on multiple lines? Something like `foo x | x == "boo" \n    <indents> x /= "bar"`?
15:53:09 <Denommus> how do I pass a GHC flag to a library?
15:53:20 <athan> (with the `=` after "bar" of course)
15:53:33 <athan> Denommus: There should be a cabal flag
15:53:47 <geekosaur> athan: yes and no? it won't infer the && there
15:53:54 <athan> GHC-Options: <- Denommus
15:54:10 <athan> geekosaur: Ooop, forgot that haha. Thanks!
15:56:02 <ski> they use it when grouping by a component, since instead of transforming from `[("a",0),("a",1),("b",2)]' to the sensible `[("a",[0,1]),("b",[2])]', they transform to `[[("a",0),("a",1)],[("b",2)]]' so when you (implicitly) map `fst' on the first list (corresponding to using `x' after a pattern `(x,y)'), you get `["a","a"]' (hence you need `the'), while when you (implicitly) map `snd' on that list (corresponding to using `y'), you get `[0,1]' as expec
15:56:28 <ski> (hrm, possible cutoff near ".., while when you (implicitly) map `snd' on that list (corresponding to using `y'), you get `[0,1]' as expected")
15:58:22 <ReinH> ski: you can do that nicely with a lot of monoids
15:58:42 <ReinH> probably a nice lensy traversal as well
15:59:12 <ski> ReinH : do what ?
16:00:47 <hiptobecubic> i would expect just a fold would be enough
16:05:23 <mrsElectron> map (map fromIntegral.(\x-> snd x)) [[('a',1)]]   <----- that makes sense to me, but it's wrong apparently. I want to make a list [[1.0]] out of that
16:06:10 <mrsElectron> Apply    (map snd x) on each [('a',1)]   seems sensible to me
16:06:20 <glguy_> map f.g   parses as:  (map f) . g
16:06:27 <glguy_> you wanted:   map (f.g)
16:06:38 <glguy_> also, \x -> snd x   -- is just   snd
16:07:08 <glguy_> > map (map (fromIntegral . snd)) [[('a',1)]] :: [[Double]]
16:07:09 <lambdabot>  [[1.0]]
16:07:54 <shachaf> (\x -> (\y -> snd y) x)
16:09:01 <mrsElectron> looks like the logic was good so far, and the syntax messed up. thanks a lot
16:10:20 * hackagebot messagepack-rpc 0.1.0.2 - Message Pack RPC over TCP  http://hackage.haskell.org/package/messagepack-rpc-0.1.0.2 (rodrigosetti)
16:11:14 <mrsElectron> how do I convert [[Int]] to [[Double]] ?
16:11:32 <Hafydd> map (map fromIntegral)
16:11:33 <sshine> map (map fromIntegral)
16:11:51 <dfeuer> foxik
16:12:33 <azert> hello
16:15:24 <ski> or
16:15:30 <ski>   (map . map) fromIntegral
16:20:20 * hackagebot messagepack-rpc 0.1.0.3 - Message Pack RPC over TCP  http://hackage.haskell.org/package/messagepack-rpc-0.1.0.3 (rodrigosetti)
16:21:01 <YAMAMOTO> hello
16:21:43 <YAMAMOTO> anyone here
16:21:55 <ReinH> ski: e.g.:
16:21:56 <ReinH> > fold [(First (Just "a"), [0]), (First (Just "A"), [1])]
16:21:57 <lambdabot>  (First {getFirst = Just "a"},[0,1])
16:22:09 <sshine> > map (map fromIntegral) ([[1,2,3],[4,5,6]] :: [[Int]]) :: [[Double]]
16:22:11 <lambdabot>  [[1.0,2.0,3.0],[4.0,5.0,6.0]]
16:22:23 <YAMAMOTO> i did not understand whar did you say
16:22:27 <Frivillig> Frivillig I fornuftig diskusjon og når du ønsker å tilbakevise et standpunkt, eksempelvis kristendom, så skylder du som et debattant med vitenskapsteoretisk dannelse å imøtegå din opponent, ikke på hva han skriver, men på hva som nødvendigvis må være hans beste argument. I motsatt fall demonstrerer du bare at du ikke har satt deg tilstrekkelig inn i tema til å være i besittelse
16:22:27 <Frivillig> av meningsberettigelse.
16:22:35 <vanila> Hi YAMAMOTO
16:22:37 <ReinH> Er, that's not quite right
16:22:39 <vanila> Welcome to #haskell
16:22:48 <YAMAMOTO> how are you vanila
16:22:51 <vanila> Fine, thank you
16:22:53 <YAMAMOTO> are you ok
16:22:55 <vanila> how are you
16:23:02 <Frivillig> sorry wrong window
16:23:06 <YAMAMOTO> fine thanks
16:23:13 <sshine> Frivillig, it didn't type-check anyway.
16:23:24 <YAMAMOTO> whrere are you from
16:23:43 <vanila> im from UK
16:23:59 <YAMAMOTO> good
16:24:31 <YAMAMOTO> how is that place i wish him well be fine
16:25:20 * hackagebot messagepack-rpc 0.1.0.1 - Message Pack RPC over TCP  http://hackage.haskell.org/package/messagepack-rpc-0.1.0.1 (rodrigosetti)
16:25:22 * hackagebot messagepack-rpc 0.1.0.0 - Message Pack RPC over TCP  http://hackage.haskell.org/package/messagepack-rpc-0.1.0.0 (rodrigosetti)
16:30:20 * hackagebot tidal 0.4.19 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.4.19 (AlexMcLean)
16:35:20 * hackagebot tidal 0.4.20 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.4.20 (AlexMcLean)
16:43:17 <Fylwind> Seems like Identity a essentially equivalent to ((), a) as a Functor, right?
16:43:47 <Fylwind> s/a essentially/a is essentially/
16:43:58 <shachaf> Yes, modulo _|_.
16:44:32 <Fylwind> ah, thanks
16:44:54 <shachaf> If you mean e.g. newtype Id' a = Id' ((),a)
16:45:48 <shachaf> () -> a works too!
16:46:38 <Fylwind> shachaf: well I'm just being stingy and I need an Identity Functor without depending on mtl
16:47:32 <shachaf> You just need transformers, not mtl.
16:47:44 <shachaf> Or maybe even less, I'm not sure anymore.
16:48:06 <sshine> what about... newtype Id' a = Id' a, where fmap f (Id' a) = (Id' (f a))?
16:48:26 <Fylwind> shachaf: one of those hehe, i always get mtl and transformers mixed up ^^
16:49:35 <Fylwind> sshine: yeah I can do that, just trying to see if I can avoid writing the instance altogether
16:49:59 <sshine> Fylwind, ah :)
16:50:20 * hackagebot purescript 0.6.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.6.1 (PhilFreeman)
16:55:20 * hackagebot linear 1.15 - Linear Algebra  http://hackage.haskell.org/package/linear-1.15 (EdwardKmett)
17:02:05 <sbrg> The new HCAR is a goldmine of interesting stuff
17:04:54 <mrsElectron> how do I find out what element number a first occurrence of something in a list has?
17:05:08 <ReinH> :t indexOf
17:05:09 <lambdabot>     Not in scope: ‘indexOf’
17:05:09 <lambdabot>     Perhaps you meant one of these:
17:05:09 <lambdabot>       ‘Control.Lens.index’ (imported from Control.Lens),
17:05:22 <mrsElectron> thanks
17:05:50 <ReinH> :t elemIndex
17:05:51 <lambdabot> Eq a => a -> [a] -> Maybe Int
17:05:58 <ReinH> mrsElectron: The actual name is elemIndex
17:06:20 <ReinH> > elemIndex 3 [0..]
17:06:21 <lambdabot>  Just 3
17:06:45 <mmmm> What are some good things to implement to get to grips with concurrent haskell?
17:06:52 <mrsElectron> about that.. "just 3" ? That's not an int
17:07:07 <mrsElectron> I cant index with "just 3"
17:08:02 <ReinH> mrsElectron: Yes, you'll need to handle the Nothing case. It's possible for the indexing to fail.
17:08:33 <ReinH> possibleIndex = elemIndex n xs; case possibleIndex of { Nothing -> handle failure; Just idx -> use the index; }
17:08:49 <mrsElectron> it's impossible for it to fail in my case since I've got a logical proof that the index will exist
17:09:00 <ReinH> mrsElectron: then use fromJust on the result
17:09:06 <ReinH> :t fromJust
17:09:06 <lambdabot> Maybe a -> a
17:10:53 <mrsElectron> :t fromJust.elemIndex
17:10:54 <lambdabot>     Couldn't match type ‘[a] -> Maybe Int’ with ‘Maybe c’
17:10:54 <lambdabot>     Expected type: a -> Maybe c
17:10:54 <lambdabot>       Actual type: a -> [a] -> Maybe Int
17:11:03 <ReinH> mrsElectron: although I will point out that lists are not a good data structure to use for random access
17:11:23 <ReinH> you can't compose them like that. The types don't match up properly.
17:11:31 <mrsElectron> I know, this is just for some throw away code
17:11:37 <ReinH> :t \x xs -> fromJust (elemIndex x xs)
17:11:37 <lambdabot> Eq a => a -> [a] -> Int
17:11:41 <ReinH> @pl \x xs -> fromJust (elemIndex x xs)
17:11:41 <lambdabot> (fromJust .) . elemIndex
17:11:52 <ReinH> @pl \xs -> fromJust (elemIndex x xs)
17:11:52 <lambdabot> fromJust . elemIndex x
17:12:06 <ReinH> removing all the points is ugly. Leaving one in is a bit better.
17:12:51 <mrsElectron> I just want the element number of char X ..
17:13:24 <mrsElectron> and I know it exists (logical proof with data models)
17:14:08 <Zorg> I want to simplify the logic of these two functions / reduce code, but am not really sure how to due to different action types: https://gist.github.com/zorgiepoo/5d7169fcf2768bd13750
17:14:10 <mrsElectron> since I'm throwing away the code, and it's just for some tests for some small dataset, I have no reason to not use a list
17:14:23 <mrsElectron> since the rest of the code uses lists
17:17:58 <sshine> Zorg, as far as simplification goes, I guess   makeSocket2 = fmap (either (const Nothing) Just) . tryIOError  (I think)
17:19:15 <sshine> Zorg, but I'm guessing you want to generalize the two functions?
17:21:59 <benzrf> is there a comma kind
17:22:04 <benzrf> i feel like ive seen it b4
17:25:05 <sshine> Zorg, I have an idea, one sec.
17:26:35 <shachaf> I keep reading your sentences as exclamations.
17:26:55 <sshine> whose?
17:26:55 <shachaf> "by Zorg, I have an idea!"
17:27:02 <sshine> ah :)
17:27:08 <sshine> Boink, narf!
17:27:17 <Zorg> sshine: yeah, but I didn't think about simplifying it like that.. still trying to understand the line you wrote =)
17:27:25 <sshine> Zorg, sorry :)
17:28:06 <Zorg> I think I understand your line, though
17:29:40 <ski> ReinH : m, it didn't group
17:36:29 <sshine> Zorg, here's my idea... https://gist.github.com/sshine/396df7674bf6270dc7f6 -- I didn't test it, so there could be errors, but that's the general idea I had.
17:36:35 <Welkin> haskell on centOS should be the same as Fedora, right?
17:37:50 <sshine> Zorg, whoops, that's not entirely equivalent to what you did.
17:38:28 <red_> can the following be done without state/monadz ? i'm choosing some value [1..9] .. so i start with one .. do some recursive calls .. and come back .. now i want to start choose 2 and do more recursive calls
17:38:57 <red_> this is backtracking and i'm finding it hard in haskell
17:39:03 <sshine> red_, yes. anything you can do with pure monads you can do with recursive functions.
17:39:47 <sshine> red_, sounds like a job for foldr.
17:41:07 <sshine> e.g. the sum of fibonacci numbers 1..9: foldr (\n result -> fib n + result) 0 [1..9] -- the recursive work is being carried out in fib, and whatever fib returns is being accumulated in the anonymous function given to foldr.
17:42:04 <red_> sshine: thanks a lot .. i'll give it some thought
17:42:45 <sshine> red_, or, depending on the task, maybe map is enough. i.e. map fib [1..9] does recursive work for each of the elements in the list, but does no accumulation afterwards, but simply produces the list of results (which you can subsequently reduce to something else)
17:43:17 <sshine> red_, if fib had some kind of 'state', map is not sufficient.
17:44:39 <Welkin> how can I get haskell-platform for centOS?
17:44:57 <Welkin> the debian-base binaries won't work
17:45:11 <Welkin> if I build it from source, I already need to have ghc installed?
17:45:52 <sshine> Zorg, I updated my gist. I still don't know if it type-checks, but the idea is there.
17:46:23 <Zorg> sshine: I sorta liked your first idea =p, https://gist.github.com/zorgiepoo/942dac0e92cc47f194b9
17:47:32 <sshine> Zorg, the second idea is trying to find what the two functions have in common and write a more general version.
17:47:49 <sshine> Zorg, hmm :) neat
17:49:11 <mrsElectron> I really don't find haskell code intuitive. Well, I've only known haskell for about 48 hours now.. but still.. I don't find it beautiful :p
17:49:30 <edwardk> I seem to recall that Stephen Blackheath lurked around here. Does anyone remember his nick?
17:49:37 <mrsElectron> question: if you wrote an operating system in haskell, would it be elegant or just too messy?
17:49:44 <sshine> Zorg, combine f = fmap (blarg) . tryIOError   =   combine f x = (fmap (blarg) . tryIOError) x   = combine f x = fmap (blarg) (tryIOError x)
17:49:49 <Zorg> :t (<|>)
17:49:50 <lambdabot> Alternative f => f a -> f a -> f a
17:49:51 <Axman6> edwardk: blackh IIRC
17:49:54 <mrsElectron> edwardk: yes, he nicks as benzrf
17:49:55 <sshine> mrsElectron, depends on who'd write it (:
17:50:23 <edwardk> mrsElectron: benzrf is i think a third of blackh's age ;)
17:50:23 <Axman6> mrsElectron: you sure?
17:50:25 * ski suggests sshine uses `<=>' inbetween equations like this :)
17:50:31 <sshine> ski, thanks. :)
17:52:45 <sshine> mrsElectron, I'm sure you've seen messy Java code, messy C++ code. actually, those are probably worse once it gets really messy!
17:53:32 <sshine> mrsElectron, the only way to make clean code is through abstraction, and Haskell has plenty of that =)
17:56:31 <Axman6> edwardk: haven't seen him around for a while sadly
17:56:39 <edwardk> Axman6: shucks
17:56:54 <edwardk> had some questions on sodium internals
17:57:04 <edwardk> and they go faster over IRC than email
17:57:11 <johnw> edwardk: mostly protons and neutrons
17:57:20 <hiptobecubic> har har har
17:57:23 <Axman6> might be able to find his email if you're interested (though you can probably get that from -cafe or something too)
17:57:26 <ReinH> ski: The think I forgot to do was sort and group by and then apply the fold to the inner lists
17:57:29 <ReinH> *thing
17:57:33 <mrsElectron> can you apply some operation on two matrices element wise without writing your own recursive function for it?
17:57:35 <ReinH> so it's really map $ fold ...
17:58:01 <Axman6> mrsElectron: probably? that's a bit of an odd question
17:58:26 <mrsElectron> I mean, is there something like map but for two matrices
17:58:33 <ReinH> ski: the example should have been with both keys the same to be accurate
17:58:40 <mrsElectron> or.. I could use zip
17:58:40 <Axman6> most matrix libraries will usually provide some kind of zipWith type function
17:58:46 <Axman6> :t zipWith
17:58:47 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
17:58:52 <ReinH> mrsElectron: what is a matrix here? [[a]]?
17:59:19 <Axman6> for matrices, that might be: zipWith :: (a -> b -> c) -> Matrix a -> Matrix b -> Matrix c
17:59:41 <mrsElectron> ReinH: no, just [a][a]. I want to get their element wise sum in one matrix
17:59:53 <ReinH> mrsElectron: what is [a][a]? That's not a valid type.
17:59:55 <mrsElectron> I want to sum two matrices, simply
18:00:06 <sshine> mrsElectron, that'd be possible with zipWith (for some matrix type, depending on which one you choose)
18:00:11 <ReinH> mrsElectron: Are your "matrices" just lists?
18:00:18 <ReinH> If they are lists of lists:
18:00:21 <ReinH> > zipWith (zipWith (,)) [[1,2],[3,4]] ["ab","cd"]
18:00:22 <lambdabot>  [[(1,'a'),(2,'b')],[(3,'c'),(4,'d')]]
18:00:34 <ReinH> if they are just lists, only one zipWith is needed
18:01:22 <mrsElectron> thanks
18:03:55 <Axman6> mrsElectron: it's a somewhat difficult question to answer, because there's no notion of "a matrix" in haskell; there are several packages that provide matrix like things (see hmatrix, Repa, Accellerate [for working with GPUs] and more)
18:04:43 <mrsElectron> Axman6: I see what you mean there! Confusing you all. I meant lists :p
18:06:50 <solirc> indiagreen: (disclaimer: I'm the main author of Hspec) There are different testing approaches (HUnit, QuickCheck, SmallCheck) and testing frameworks that allow you to freely mix those testing approaches in a single test suite.
18:07:18 <Zorg> sshine: ok first thing I don't understand about your Foo gist, in foo sock's type is IO (Maybe Socket) but in performSocketAction2 you pass type Maybe Socket
18:09:07 <solirc> indiagreen: You really want to use a testing framework.  Both Hspec and Tasty are testing frameworks, both come with support for QuickCheck and SmallCheck.
18:10:20 * hackagebot kdt 0.2.0 - Fast and flexible k-d trees for various types of point queries.  http://hackage.haskell.org/package/kdt-0.2.0 (giogadi)
18:11:11 <orion> Is using two spaces to indent in Haskell usually acceptable?
18:11:20 <solirc> indiagreen: Tasty ships it's own version of HUint.  This has the advantage of viewer dependencies (tasty-hunit does not depend on HUnit).  The disadvantage is that you can not use libraries that build on top of HUnit.
18:11:28 <solirc> orion: I do it all the time ;)
18:12:49 <Zorg> orion: I could be wrong but I've a feeling that is not very haskell related =p
18:13:25 <solirc> indiagreen: Hspec supports HUnit.  In addition it provides it's own expectation language (hspec-expectations) that is build on top of HUnit.  You can use hspec-expectations with any testing framework that supports HUnit (but not with Tasty, for the reason that I mentioned above).
18:13:52 <solirc> Zorg, orion: Both 4 and 2 spaces are common conventions
18:14:46 <Zorg> *grumbles*
18:15:21 * hackagebot twitter-conduit 0.1.0 - Twitter API package with conduit interface and Streaming API support.  http://hackage.haskell.org/package/twitter-conduit-0.1.0 (TakahiroHimura)
18:15:31 <solirc> indiagreen: In general I think both Tasty and Hspec can be viable options for testing.
18:16:19 <ski> ReinH : yes
18:17:25 <solirc> indiagreen: If you want to specify your tests with plain old Haskell lists and are happy to write your own test driver, use Tasty.
18:18:21 <solirc> indiagreen: If you like Hspec declarative approach and want to use automatic spec discovery us Hspec.
18:22:00 <sshine> Zorg, oops, sorry. that was clearly an error.
18:23:28 <solirc> indiagreen: I would refrain from using test-framework, Tasty is basically a better version of it.  I would also not recommend tasty-hspec: It does not support the latest version of Hspec, does not support automatic spec discovery and gives you worse error messages.
18:23:31 <ReinH> solirc: Er... no?
18:23:42 <ReinH> solirc: you can write either hunit or hspec style tests with tasty
18:24:01 <ReinH> and you definitely don't need to "write your own test driver". That's what tasty *is*.
18:24:03 <ryan__> > read "abc" :: String
18:24:04 <lambdabot>  "*Exception: Prelude.read: no parse
18:24:08 <ryan__> why?
18:24:20 <ReinH> ryan__: because strings are surrounded with ""
18:24:30 <ReinH> > read "\"abc\"" :: String
18:24:31 <lambdabot>  "abc"
18:24:34 <sshine> Zorg, I can't really decide, but it seems that the Socket that performSocketAction2 receives as argument and the Socket that 'action' generates in makeSocket are somewhat related.
18:24:40 <ryan__> > got it, thanks
18:24:41 <lambdabot>  <hint>:1:7: parse error on input ‘,’
18:24:58 <sshine> > reverse "got it, thanks"
18:25:00 <lambdabot>  "sknaht ,ti tog"
18:25:03 <solirc> ReinH: I'm referring to automatic test discovery
18:25:20 <ReinH> solirc: Ok, but you don't need to "specify your tests with plain old Haskell lists" either
18:25:28 <ReinH> you can write either hunit or hspec tests with Tasy
18:25:32 <ReinH> *Tasty
18:26:09 <Zorg> ^ that zorg must hate me =p
18:26:48 <solirc> ReinH: You build up a test tree by using Haskell lists, no?
18:27:00 <solirc> That is not necessarily a bad thing.
18:27:07 <ReinH> solirc: no, you don't.
18:27:19 <solirc> So?
18:27:25 <ReinH> If you're writing hspec tests with tasty, you write them in hspec style
18:27:34 <ReinH> if you're writing hunit tests, you write them in hunit style
18:27:44 <solirc> ReinH: I was refering to Tasty, not to Hspec
18:28:09 <ReinH> " If you want to specify your tests with plain old Haskell lists and are happy to write your own test driver, use Tasty."
18:28:32 <ReinH> Tasty is a test driver
18:28:55 <ReinH> It doesn't change the way you write hspec, hunit, etc tests
18:29:29 <solirc> ReinH: But you build the test tree with lists, Hspec uses a writer monad.  Both approaches work, none is necessarily better or worse.
18:30:01 <mrsElectron> wowowowowoow... so if I put some spaces in front of a function def .. I get errors?
18:30:13 <ReinH> mrsElectron: Haskell is a whitespace aware language.
18:30:31 <Zorg> sshine: the action passed in makeSocket is socket along with its aguments, which creates a Socket. following performSocketAction calls then call IO functions (bind, reuse), on the Socket.. I convert the return values to MaybeT's and bind them
18:30:33 <red_> can the following be done without state/monadz ? i'm choosing some value [1..9] .. so i start with one .. do some recursive calls .. and come back .. now i want to start choose 2 and do more recursive calls. a foldr was suggested earlier but i'm having trouble guessing at how that would help? anyone?
18:30:44 <mrsElectron> lol, I like the way you put it. I'd call it whitespace delicate
18:30:58 <mrsElectron> whitespace frail
18:31:02 <MP2E> you can use ugly braces to get around that I believe
18:31:04 <ReinH> solirc: Ah, I see what you're saying now.
18:31:13 * ReinH shrugs
18:31:16 <MP2E> i'd rather just make it look nice
18:31:28 <MP2E> i like that haskell enforces a whitespace style
18:31:30 <red_> so if all recursive calls fail ... i need to backtrack and try 2 ... etc
18:31:37 <MP2E> means i don't have to look at 5 programmers styles every time i look in a large project :P
18:31:38 <ReinH> I'll take "whitespace frail" over "death by a thousand braces" any day, thanks
18:31:58 <johnw> ReinH: same here
18:32:00 <shachaf> wowowowowoow, indeed
18:32:30 <sshine> braces are for teenagers!
18:32:50 <shachaf> Let's not have that argument in here.
18:32:57 <shachaf> Not even as a joke.
18:33:11 <MP2E> haha
18:33:47 <sshine> sorry. anyone can have teeth problem.
18:33:53 <indiagreen> solirc: thanks for explaining! I've already started using Hspec (in fact, you caught me in the middle of writing a test); it's for a small project, so I'm not using anything even remotely advanced, and my question was more along the lines of “how do I avoid accidentally choosing something bad/unmaintained/buggy/etc.”
18:34:30 <ReinH> indiagreen: by choosing tasty instead of test-framework ;)
18:35:12 <ryan__> so red_ you have a list, you want to do something to each element in succession until one succeeds?
18:35:51 <solirc> ReinH: I would choose anything over test-framework anytime ;)
18:37:05 <red_> ryan__: i have a 'structure' and i want to do something in succession, and then given that something i want to all the other things to see if the whole structure succeeds (some constraint) ... if not .. roll on back to the first something, and try the next possibility. for concreteness, the possiblilites are n <- [1..9]
18:37:27 * indiagreen wonders whether test-framework could be made deprecated on Hackage or something
18:37:50 <johnw> that would be up to the author/maintainer
18:38:21 <red_> this is backtracking for some sudoku ... given the first blank space, try a 1 then recursively try all the other blank spaces. if you get nowhere, go back to the first try and try a 2
18:38:51 <solirc> indiagreen: It has a lot of reverse dependencies http://packdeps.haskellers.com/reverse
18:39:29 <ryan__> yeah, sounds like a foldl where your accumulator indicates whether you've found a solution yet
18:39:35 <ReinH> red_: have you considered a solution that doesn't need to backtrack?
18:39:38 <ryan__> and maybe also contains the solution
18:40:08 <ReinH> You *can* write a sudoku solver this way, but it's not a very idiomatic way in a functional language imo
18:40:42 <ReinH> You can leverage laziness instead of backtracking
18:40:47 <red_> ReinH: not yet .. now i'm just trying to understand why backtracking is so hard for me in haskell .. it's a pretty standard computation pattern
18:40:58 <indiagreen> solirc: well, at the very least there could be a note in the package description. Given that the maintainer is libraries@haskell.org, should I try making a proposal -to add such a note to the description- on the libraries mailing list?
18:41:58 <ReinH> red_: which doesn't imply that it works well in *haskell* ;)
18:42:22 <ReinH> You might be interested in a backtracking monad like LogicT (https://hackage.haskell.org/package/logict)
18:42:34 <ReinH> but really, backtracking is not needed here. There are much cleaner (and faster) solutions without it.
18:42:49 <red_> will you help me pin down why backtracking is not so easy for me?
18:43:03 <red_> is it the lack of state?
18:43:29 <sshine> red_, IMO, it's keeping track of complicated return values all the time.
18:43:29 <ReinH> Haskell has some properties that make backtracking easier: purely functional data structures are persistent, for example/
18:43:41 <ReinH> But a fold doesn't expose that to you in a nice way
18:44:33 <ReinH> So you have to manually manage your own search tree in a totally ad hoc way
18:44:59 <ReinH> what you're probably finding difficult is constructing this search tree in an ad hoc way via foldl and threading it through your computation correctly
18:45:31 <red_> i'll agree to that
18:46:59 <ReinH> red_: you might like http://eprints.nottingham.ac.uk/226/1/countdown.pdf
18:47:46 <ReinH> In a lazy language like Haskell, you can do something very similar to backtracking:
18:47:58 <ReinH> you can generate all possible solutions lazily, and then try each of them until you find one
18:48:21 <ReinH> If you add a pruning step, you can get very efficient algorithms
18:48:51 <ReinH> Like Richard Bird's sudoku solver: http://www.cs.tufts.edu/~nr/cs257/archive/richard-bird/sudoku.pdf
18:49:18 <red_> ok thanks a lot .. will probably abandon this route
18:49:44 <ReinH> red_: it's worth learning how backtracking works in Haskell... if for no other reason that to see *why* we often prefer other solutions ;)
18:51:03 <solirc> indiagreen: I'm not opinionated on that, I neither use test-farmework nor Tasty.  If I would prefer this style of testing I would probably choose Tasty.  But there are also drawbacks to Tasty, e.g. it does not work with older versions of base (hence you can not use it if you want to support GHC < 7.4).  In addition Tasty's choice of shipping its own copy of HUnit is controversial.  I'm not sure what the
18:51:04 <solirc> outcome of such a proposal would be.
18:51:34 <ReinH> red_: various attempts have been made to bridge the gap between functional programming and logic programming, e.g., http://www-ps.informatik.uni-kiel.de/~sebf/data/pub/atps09.pdf
18:52:32 <Guest29239> oh nice, I didn't know there was a white paper on the countdown problem.  Hutton presented it himself at the end of Meijer's old haskell lectures
18:52:36 <ReinH> red_:  so the lazy approach is: don't backtrack, just move on to the next choice, and focus on generating choices in an efficient way
18:52:47 <Guest29239> I was pretty amazed at it's structure
18:53:07 <ReinH> Guest29239: It's a nice solution. Also check out Bird's Pearls book if you haven't yet.
18:53:17 <mrsElectron> is there a quick function to "flatten" [[a]]?   I want [[1,2,3],[4,5,6]] to become [1,2,3,4,5,6]
18:53:21 <ReinH> I think there's a video of Hutton doing the countdown problem somewhere
18:53:22 <ReinH> :t concat
18:53:23 <lambdabot> [[a]] -> [a]
18:53:31 <ReinH> mrsElectron: you can use Hoogle to find functions if you know their type:
18:53:35 <ReinH> @hoogle [[a]] -> [a]
18:53:36 <lambdabot> Prelude concat :: [[a]] -> [a]
18:53:36 <lambdabot> Data.List concat :: [[a]] -> [a]
18:53:36 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
18:53:43 <ReinH> (And knowing what type you want is pretty important!)
18:53:45 <Guest29239> I thought, how does one come up with this on their own?  I'll definitely be giving that paper alook over
18:53:59 <ReinH> Guest29239: Richard Bird's book explains that in some detail :)
18:54:01 <Gentmen> is `data Foo a = Bar` a `* -> *` invalid Functor since it can't be `fmap`'d ?
18:54:11 <Guest29239> C9 Lectures: Dr. Graham Hutton - Functional Programming Fundamentals Chapter 11 of 13
18:54:25 <shachaf> Gentmen: It's perfectly valid.
18:54:38 <ReinH> Gentmen: data Foo a = Bar a is a Functor
18:54:39 <shachaf> Gentmen: fmap _ Bar = Bar
18:54:46 <ReinH> oh, data Foo a = Bar
18:54:53 <Gentmen> yes
18:54:57 <Guest29239> ReinH: The book is kind of on my list, but slightly afraid ;)  Hope to tackle it soon
18:55:01 <johnw> it's still a functor
18:55:05 <Gentmen> ah
18:55:05 <johnw> it's the Const functor
18:55:09 <ReinH> Yep
18:55:14 <shachaf> No, it's Proxy.
18:55:22 <Gentmen> I'm trying to write an invalid Functor that has a kind * -> * per Typeclassopedia's exercises
18:55:23 <ReinH> Guest29239: try his new Thinking Functionally with Haskell book
18:55:25 <Gentmen> can you please give me a hint?
18:55:32 <johnw> data Foo a = Foo (a -> ())
18:55:33 <ReinH> Guest29239: it's a wonderful introduction to equational reasoning and program construction
18:55:54 <shachaf> An answer isn't really a hint...
18:55:56 <Guest29239>  sounds like what I need
18:56:10 <shachaf> But fortunately that isn't an answer, I guess.
18:56:12 <mrsElectron> thanks
18:56:19 <shachaf> It's a functor, modulo bottom.
18:56:41 <mrsElectron> haskell.org is real slow, is it just for me?
18:56:55 <Gentmen> : mrsElectron - it was slow for me too
18:58:01 <benzrf> johnw: are you sure that's not a functor
18:58:28 <ReinH> benzrf: it's a contravariant functor
18:58:36 <ReinH> a is in contravariant position
18:58:40 <benzrf> ReinH: yes, but
18:58:43 <athan> What does it mean for a type variable to be "rigid", specifically?
18:58:46 <benzrf> @let data Foo a = Foo (a -> ())
18:58:47 <lambdabot>  Defined.
18:59:03 <benzrf> @let instance Functor Foo where fmap _ _ = Foo (const ())
18:59:04 <lambdabot>  Defined.
18:59:12 <shachaf> Foo a = a -> () is covariant too, modulo bottom. :-)
18:59:33 <Saizan> athan: that it's a type argument to what you are defining, so it's only equal to itself
18:59:40 <johnw> ah
18:59:45 <johnw> I shouldn't have chosen (), should I have
18:59:49 <johnw> data Foo a = Foo (a -> a)
18:59:50 <benzrf> johnw: definitely not :-)
18:59:51 <ReinH> shachaf: *backs away slowly*
18:59:52 <johnw> good catch, benzrf
19:00:24 <Saizan> athan: non-rigid ones are instead unification variables, they get solved by stuff as appropriate
19:00:28 <benzrf> thx
19:00:32 <johnw> i ended up picking something also isomorphic to the Const functor :)
19:01:04 <shachaf> To Proxy.
19:01:16 <Gentmen> and what's the reason that `data Foo a = Foo (a -> a)` is *not* a Functor?
19:01:49 <shachaf> I said the same thing earlier. Maybe johnw has me on /ignore again.
19:01:54 <shachaf> I should go.
19:01:57 <athan> Saizan: Thank you, do you have any more verbose examples? Sorry :S. I'm trying to understand unification right now
19:02:29 <johnw> Gentmen: you just wanted a hint ;)
19:02:33 <johnw> try writing a Functor instance for it
19:02:43 <mrsElectron> this is confusing.. check this out
19:02:45 <Gentmen> ok thanks :) you're right
19:02:53 <johnw> like how benzrf just proved that my other suggestion WAS a functor
19:02:53 <mrsElectron> > ((-).abs) 1 (4)
19:02:55 <lambdabot>  -3
19:03:01 <mrsElectron> > ((-).abs) 1 (-4)
19:03:02 <lambdabot>  5
19:03:13 <mrsElectron> > (abs.(-)) 1 (-4)
19:03:14 <lambdabot>  No instance for (GHC.Show.Show a0)
19:03:14 <lambdabot>    arising from a use of ‘M670967329550916206729875.show_M6709673295509162067...
19:03:15 <lambdabot>  The type variable ‘a0’ is ambiguous
19:03:15 <lambdabot>  Note: there are several potential instances:
19:03:15 <lambdabot>    instance [safe] GHC.Show.Show
19:04:19 <mrsElectron> so case 1 and 2, can either mean |a|-|b| or |a-b|. But the output suggests it means neither.
19:04:54 <athan> :t (-).abs
19:04:55 <lambdabot> Num b => b -> b -> b
19:05:01 <athan> :t abs
19:05:02 <lambdabot> Num a => a -> a
19:05:35 <exio4> (-).abs is \x → (-) (abs x)
19:05:40 <athan> :t \x y -> (-) (abs x) y
19:05:41 <lambdabot> Num a => a -> a -> a
19:05:54 <exio4> == \x y → abs x - y
19:06:11 <mrsElectron> a -> a -> a  does not tell us what's args or ret
19:06:19 <exio4> "args or ret"
19:06:21 <mrsElectron> or, nvm
19:06:36 <athan> mrsElectron: You've got to see both types and definitions
19:06:42 <athan> the lambdas make it easier for me to see
19:08:54 <Saizan> athan: mh, i didn't see the original example, but for example if you give a type signature to your function, id :: a -> a, then in the body of id you'll have 'a' as a rigid variable, because the type promises to work for any 'a'
19:09:11 <Saizan> athan: so here the only definition is id x = x
19:09:38 <athan> Saizan: Ahh! Now I think I see!
19:09:44 <athan> Here's what I was toying with:
19:09:52 <athan> @let foo = undefined :: Int -> a -> a
19:09:53 <lambdabot>  Defined.
19:09:58 <athan> foo :: a -> b -> b
19:10:02 <athan> > foo :: a -> b -> b
19:10:03 <lambdabot>  Couldn't match type ‘a1’ with ‘GHC.Types.Int’
19:10:03 <lambdabot>    ‘a1’ is a rigid type variable bound by
19:10:03 <lambdabot>         an expression type signature: a1 -> b1 -> b1 at <interactive>:1:1
19:10:03 <lambdabot>  Expected type: a1 -> b1 -> b1
19:10:03 <lambdabot>    Actual type: GHC.Types.Int -> b1 -> b1
19:10:14 <Saizan> right
19:10:23 <mrsElectron> > (\x \y -> x+y) 1 2
19:10:24 <lambdabot>  <hint>:1:5: parse error on input ‘\’
19:10:31 <mrsElectron> how do you do that? :3
19:10:36 <exio4> (\x → \y → x+y)
19:10:41 <exio4> > (\x → \y → x+y) 1 2
19:10:43 <lambdabot>  3
19:10:45 <exio4> > (\x y → x+y) 1 2
19:10:46 <lambdabot>  3
19:10:47 <mrsElectron> ow, ty
19:10:52 <athan> @let bar = undefined :: a -> b -> b
19:10:53 <lambdabot>  Defined.
19:10:58 <exio4> (\x → \y → ...) is the same as (\x y → ...)
19:11:03 <athan> > bar :: b -> b -> c
19:11:04 <lambdabot>  Couldn't match type ‘b1’ with ‘c1’
19:11:04 <lambdabot>    ‘b1’ is a rigid type variable bound by
19:11:04 <lambdabot>         an expression type signature: b1 -> b1 -> c1 at <interactive>:1:1
19:11:04 <lambdabot>    ‘c1’ is a rigid type variable bound by
19:11:04 <lambdabot>         an expression type signature: b1 -> b1 -> c1 at <interactive>:1:1
19:11:12 <athan> muahahaha okay I think I get it
19:11:17 <athan> thank you Saizan :)
19:12:10 <Saizan> cheers
19:13:46 * ski thinks `↦' ought to be allowed in lambdas, with `UnicodeSyntax'
19:14:37 <gcganley> is unicode syntax a ghc pragma?
19:14:54 <gcganley> or just something you made up so you could have fancy char's
19:15:23 <ski> platz : "countdown problem" being ?
19:15:26 <athan> gcganley: I wish all unicode was supported :(
19:15:29 <athan> ...kinda
19:15:34 <exio4> athan: "all unicode"?
19:15:48 <sshine> ski, yeah!
19:15:49 <athan> exio4: Like crazy foreign language symbols
19:16:05 <exio4> I don't know what you mean, you can use it in functions with ghc
19:16:12 <athan> lol
19:16:19 <gcganley> unlike swift
19:16:27 <gcganley> where you can name variables with emojis
19:16:31 <sshine> heh
19:16:35 <sshine> that is swift.
19:16:55 <johnw> define 💩 := my program.
19:16:56 <athan> how big of a computer are you running on, exio4? :P
19:17:05 <xpika> how can i add an import to a ghc one liner using ghc -e ?
19:17:27 <johnw> ghc -e 'import Foo; ...'
19:18:40 <ski> gcganley : it's a language extension
19:19:51 <xpika> johnw: now im getting no result
19:19:55 <indiagreen> johnw: it doesn't work for me either
19:20:07 <orion> thoughtpolice: Hey, you around?
19:20:11 <johnw> hmmm
19:20:15 <johnw> guess I'm wrong?
19:20:50 <platz> ski: it's from hutton's book Programming in Haskell www.cs.nott.ac.uk/~gmh/book.html
19:20:59 <xpika> ghc -e 'import Data.List;print (intersperse 0 [1,2,3])'
19:21:03 <mrsElectron> > (\a->\b->a+b)
19:21:04 <lambdabot>  <hint>:1:4: parse error on input ‘->\’
19:21:14 <indiagreen> xpika: nope, still no output
19:21:38 <mrsElectron> > (\a \b->a+b)
19:21:39 <lambdabot>  <hint>:1:5: parse error on input ‘\’
19:21:54 <thoughtpolice> orion: yes, somewhat
19:22:04 <ski> platz : but what does it mean ?
19:22:09 <mrsElectron> > (\a -Z \b -> a+b) -- what am I doing wrong?
19:22:10 <lambdabot>  <hint>:1:5: parse error on input ‘-’
19:22:23 <mrsElectron> > (\a -> \b -> a+b) 1 1
19:22:24 <lambdabot>  2
19:22:31 <mrsElectron> oh, space
19:22:51 <orion> thoughtpolice: Hi. :) I just realized that in the NaCl library, the HMAC-SHA512 code (https://github.com/thoughtpolice/hs-nacl/blob/master/src/Crypto/HMAC/SHA512.hs) only keeps the first 256 bits.
19:23:06 <orion> Whereas the Noise protocol calls for all 512 bits.
19:23:47 <platz> ski: "given a sequence of source numbers and a single target number, attempt to construct an aritmetic expression using each of the source numbers at most once, and such that the result of evaluating the expression is the target number"
19:24:47 <platz> so give [1,3,7,10,25,50] and target 765, the expr (1+50)*(25-10) solves the problem
19:25:32 <platz> and 780 more solutions
19:25:37 <thoughtpolice> orion: oh, I see. yes, the NaCl code actually specifies the KEYBYTES to be 32 bytes. http://nacl.cr.yp.to/auth.html - hence the lack of a 512 bit output. a reasonable thing to fix
19:26:16 <mrsElectron>  (abs.(-)) 1 2  <-- how?
19:26:19 <ski> hm, a ring expression ? or field ?
19:26:40 <mrsElectron> oh right, abs.(-) returns a function.. it isn't a function!
19:26:55 <mrsElectron> right?
19:27:12 <ski> mrsElectron : `((abs .) . (-)) 1 2'
19:27:27 <mrsElectron> ski, why (abs .) ?
19:28:34 <merijn> mrsElectron: Question: What's the difference between "returns a function" and "is a function"?
19:28:40 <ski> @let infixr 9 .:; (.:) :: (c0 -> c1) -> (a -> b -> c0) -> (a -> b -> c1); (.:) = (.) . (.)
19:28:41 <lambdabot>  Defined.
19:28:49 <ski> > (abs .: (-)) 1 2
19:28:50 <merijn> oh, I see the problem :)
19:28:51 <lambdabot>  1
19:29:00 <ski> mrsElectron : because :
19:29:08 <ski>      abs (1 - 2)
19:29:16 <ski>   =  abs ((-) 1 2)
19:29:24 <ski>   =  abs (((-) 1) 2)
19:29:39 <ski>   =  (abs . (-) 1) 2
19:29:49 <ski>   =  ((abs .) (-) 1) 2
19:29:56 <ski>   =  ((abs .) . (-)) 1 2
19:30:04 <mrsElectron> :/
19:30:07 <ski> alternatively, you can continue as
19:30:11 <ski>   =  (abs . (-) 1) 2
19:30:16 <benzrf> johnw: shouldnt that be Define
19:30:17 <ski>   =  ((.) abs ((-) 1)) 2
19:30:27 <ski>   =  ((.) abs . (-)) 1 2
19:30:34 <ski>   =  ((abs .) . (-)) 1 2
19:30:40 <mdietz94> I think you can also do (abs . ((-) 1)) 2
19:30:41 <mrsElectron> ill just use (\a -> \b)
19:30:42 <ski> @src (.)
19:30:42 <lambdabot> (f . g) x = f (g x)
19:30:53 <ski> mrsElectron : i used that equation several times here
19:31:18 <ski> mrsElectron : yeah, but presumably the idea was to abstract out `1' and `2' as separate parameters
19:31:28 <ski> er
19:31:31 <ski> mdietz94 ^
19:31:44 <mdietz94> Oh i see, sorry
19:31:46 <ski> mrsElectron : that's fine
19:32:10 <ski> mrsElectron : the `(.:)' above can also be used
19:32:17 <ski>   (.:) = (.) . (.)
19:32:22 <ski>   (.::) = (.) . (.) . (.)
19:32:27 <ski>   (.:::) = (.) . (.) . (.) . (.)
19:32:29 <ski>   &c.
19:32:36 <ski>   (f . g) x = f (g x)
19:32:45 <ski>   (f .: g) x y = f (g x y)
19:32:52 <ski>   (f .:: g) x y z = f (g x y z)
19:32:53 <ski>   &c.
19:33:10 * Axman6 would love to se ., .., .:, .:., .::, .::. etc.
19:33:38 <merijn> Axman6: .. is reserved syntax
19:33:42 <ski> what would the ones (except the first) ending with a `.' do ?
19:33:46 <Axman6> yeah, I know
19:34:03 <mrsElectron> dat syntacks
19:34:10 <Axman6> four arguments
19:34:25 <Axman6> . = 1, .. = 2, .: = 3, .:. = 4
19:34:27 <ski> (also, the number of dots on the left of the definitions above is the same as the number of dots on the right)
19:34:47 <Axman6> but the definition is irrelevant
19:34:52 <Axman6> anyway
19:35:17 <gcganley> :t (..)
19:35:18 <lambdabot> parse error on input ‘..’
19:35:46 <merijn> gcganley: .. is reserved
19:35:54 <mdietz94> because of lists
19:35:54 <ski> the number of `.'s not enclosed within brackets in those definitions correspond to the number of arguments that are passed on to the right function `g'
19:36:08 <mdietz94> i think you can do 3 and you'll be okay though
19:36:12 <ski> and that also happens to be the same as the number of character in the operators i chose on the left
19:36:39 <augur> skarn: each dot would count a (.) rather than a .
19:36:43 <augur> er, ski ^
19:36:53 * ski was today thinking `[x | ..]' should be valid syntax (in special circumstances)
19:37:04 <augur> what would it mean?
19:37:12 <gcganley> :t (.) . (.)
19:37:12 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
19:37:22 <gcganley> :t . .
19:37:23 <lambdabot> parse error on input ‘.’
19:37:25 <hiptobecubic> :t (.)(.)
19:37:26 <lambdabot> (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
19:37:29 <gcganley> :t (.) (.)
19:37:30 <lambdabot> (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
19:37:47 <gcganley> :t fmap fmap fmap
19:37:47 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
19:38:00 <gcganley> yay weird combinators
19:38:28 <ski> augur : see "Generalised (SQL-Like) List Comprehensions" (language extension `TransformListComp') <https://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#generalised-list-comprehensions>
19:38:47 <augur> ski: you cant just explain? :P
19:38:53 * bananagram snickers
19:39:13 <ski> augur : i think it's strange that (some) variables change type (from `t' to `[t]') in the middle of a generalized list comprehension
19:39:28 <augur> do they?
19:40:09 <ski> augur : i would prefer it if after the grouping operation, a generator-bound `x' would be illegal, and you'd have to type `[x | ..]' instead, since you anyway get type `[t]' for it
19:40:58 <ski> so `[x | ..]' would suggest that you get a hold of the list of `x's from the current group, wrt the grouping operation that was performed earlier
19:41:46 <augur> i see
19:42:20 <ski> (also, i'm not that happy about their use of `the :: [a] -> a; the [a] = a' there. imo if you group on a variable, then it should be factored out automatically from the groups, instead of you getting a list of the same value repeated, for each group)
19:43:25 <xandaros> Trying to compile ghc for arm. Finishes stage 0, but in stage 1 it complains about curses lib missing. /usr/include/ncurses.h does exist, though
19:43:55 <ski> (grouping on a particular property, like e.g. `length', is more tricky. this is probably why they didn't factor. but it would be nice if one could factor (more or less automatically) in the non-quotient case)
19:45:28 <gcganley> what are the pros and cons of using yesod or snap
19:47:52 <orion> What is this sorcery?: https://hackage.haskell.org/package/crypto-api-0.13.2/docs/src/Crypto-Classes.html
19:48:04 <orion> class (Serialize d, Eq d, Ord d) => Hash ctx d | d -> ctx, ctx -> d where
19:49:14 <merijn> gcganley: Yesod has a more complicated set of dependencies, which can make it hard to built, also it's reliance on TH is not popular among some people
19:49:33 <gcganley> merijn: whats wrong with TH?
19:49:40 <merijn> orion: Which part of it confuses you?
19:50:16 <merijn> gcganley: GHC can't cross-compile TH yet, it doesn't work with ghcjs or the other haskell->javascript compilers and makes compile times slower
19:50:21 <orion> merijn: The pipe symbol.
19:50:26 <orion> and comma
19:50:35 <gcganley> :k (|)
19:50:36 <lambdabot> parse error on input ‘|’
19:50:46 <merijn> orion: The pipe symbol indicates that "d -> ctx, ctx -> d" is a set of Functional Dependencies
19:50:52 <solatis> merijn: cross compiling yesod to javascript.. now that would be something :)
19:51:05 <merijn> solatis: That's just compiling, not cross-compiling
19:51:14 <solatis> ehr, sorry
19:51:22 <solatis> you are right
19:51:31 <gcganley> cross compiling would be compiling for the raspberry pi
19:51:35 <merijn> solatis: The lack of cross compilation means you can't use TH on ARM (RPi, android, iOS)
19:51:51 <mrsElectron> :t abs
19:51:51 <lambdabot> Num a => a -> a
19:52:07 <mrsElectron> What do the Num a =>   part explain?
19:52:08 <gcganley> merijn: i wanted to run a haskell webserver on my RPi
19:52:26 <merijn> orion: The GHC user guide has some basic explanation of fundeps, it also links to a bunch of papers explaining the idea in more detail, iirc
19:52:42 <orion> merijn: thank you
19:52:47 <dmj`> mrsElectron: Num is a typeclass
19:55:05 <gcganley> dmj`: hey I had to hop off the IRC channel but why do i have to worry about the kinds when dealing with monad transformers
19:56:22 <lwm> gcganley: I remember thinking this was a gem when I found it: http://aosabook.org//en/yesod.html
19:56:28 <lwm> gcganley: kinda related ... :|
19:59:27 <merijn> gcganley: Right, if the goal is RPi, then Yesod is not an option
19:59:45 <dmj`> gcganley: in order to nest them, you have to see how the kinds align.
20:00:50 <merijn> luite has done some work on improving the TH situation for cross-compilation, but it's not finished yet and I doubt it will land in 7.10
20:01:01 <gcganley> :k StateT
20:01:02 <lambdabot> * -> (* -> *) -> * -> *
20:01:21 <merijn> Although, volunteers to help fix TH for ARM are always welcome, of course ;)
20:01:29 <phatle> meretrix:
20:01:48 <gcganley> merijn: dude i WISH i could, I'm still learning
20:02:15 <xandaros> I'd be happy with GHC on my Pi :(
20:02:33 <MP2E> I'd like to help with that, as well. I just don't know what to do or where to start.
20:03:09 <merijn> MP2E: Hang out in #ghc and read https://ghc.haskell.org/trac/ghc/wiki/Newcomers
20:03:53 <MP2E> wow, this article looks nice thanks!
20:04:00 <merijn> MP2E: I plan to write a "Fischer Price(tm): My First Patch Landing" post as an abridged quickstart in the next month or so
20:04:13 <merijn> Depending on how dead/unmotivated I am after work
20:04:47 <merijn> MP2E: You could also help review code on phabricator to see other people's work and see what's going on
20:06:26 <MP2E> oh cool, i thought you had to have write access to review code
20:06:43 <merijn> MP2E: No, anyone can sign up for phabricator and comment
20:06:44 <MP2E> err push access
20:06:51 <MP2E> ah
20:08:12 <luite> merijn: yeah it's getting pretty close to the deadline now, and i have enough trouble keeping ghcjs working :/
20:08:27 <merijn> MP2E: The basic workflow for people without push access is to develop locally with git, use arcanist to create/update a differential (phabricator code review) and committers take accepted differentials and land them in ghc master
20:10:18 <MP2E> ok so i've got to get arcanist
20:10:29 <MP2E> yay nixos has it
20:12:22 <L8D> >nixos
20:12:23 <L8D> >ftw
20:15:46 <mrsElectron> typeclass and datatype, what's the differnece?
20:16:29 <MP2E> datatypes are used to define new types of data, typeclasses are used to give a common set of properties and functions to a group of datatypes
20:17:07 <MP2E> for instance, a datatype would be Int, a typeclass would be Num, would defines things you can do to datatypes that are numeric
20:17:14 <MP2E> also most typeclasses come with laws
20:17:29 <MP2E> s/would/which
20:17:43 <mrsElectron> thanks
20:34:27 <merijn> Is there a convenient way to get a "proxy a" from type "Foo a b"?
20:42:12 <merijn> No one?
20:43:11 <ski> i suppose perhaps a `Flip' type ?
20:44:05 <merijn> Right, but is there a type like that? Or a more general way? I can just hardcode what I want, but I'm not sure that's very nice
20:45:22 * hackagebot kdt 0.2.1 - Fast and flexible k-d trees for various types of point queries.  http://hackage.haskell.org/package/kdt-0.2.1 (giogadi)
20:45:48 <merijn> Semi-relatedly
20:46:07 <merijn> I have "$(genSingletons [''AuthMode])" and:
20:46:09 <merijn> authToAuthMode :: forall (mode :: AuthMode) . Auth mode -> AuthMode
20:46:09 <merijn> authToAuthMode _ = fromSing (sing :: Sing mode)
20:46:29 <merijn> But GHC complains "No instance for (SingI mode)"
20:47:01 <merijn> So GHC's instance resolution is still braindead when it comes to DataKinds?
20:49:35 <merijn> Oh well, I guess I can simply add a SingI constraint..
20:51:48 <rouopea> hi
20:52:27 <mrsElectron> what's the difference between class and instance?
20:52:45 <Axman6> class defines what a class is, instance makes a type a member of the class
20:53:18 <Axman6> Class Num a where (+) :: a -> a -> a; (-) :: a -> a -> a; negate :: a -> a;
20:53:40 <Axman6> instance Num Integer where (+) = ...; (-) = ...; etc.
20:54:57 <Axman6> mrsElectron: do you know any other programming languages?
20:56:31 <vanila> class makes an empty container for instances
20:57:07 <vanila> when you go class Num a, say.. your ejust saying what it means to be a Num,    when you go  instance Num X  then you're creating a real instance of Num for X
20:57:33 <merijn> Naming bikeshed: I have an ADT that indicates whether something is a Client or Server, what is a sensible name for the type?
20:58:26 <Axman6> PeerType?
20:59:22 <merijn> hmmm
21:01:17 <peddie> "Role"?
21:02:38 <merijn> hmm, I think I like PeerType
21:02:55 <peddie> Role is extremely generic
21:03:08 <peddie> (i.e. me too :)
21:03:15 <merijn> peddie: Yeah, especially confusing with GHC's new "role" infrastructure
21:03:37 <merijn> I've got more bikeshedding topics, though! :)
21:03:50 * Axman6 wins
21:04:06 * peddie offers high-five
21:04:16 <exio4> Axman6: are you becoming Axman7?
21:04:27 <MP2E> Axman6 isn't mutable!
21:04:31 <lpaste> merijn pasted “Linewrapping GADTs” at http://lpaste.net/114471
21:04:48 <merijn> How would people linewrap line 2?
21:04:48 <exio4> a new Axman7 and Axman6 gets garbage collected
21:04:59 <solatis> MP2E: no, we're just storing him in a new variable
21:05:11 <Axman6> If someone kills me, they become Axman7
21:05:17 <Axman6> I killed the other 5
21:05:26 <solatis> exio4: i think axman7 and axman6 refer to the same data
21:05:50 <solatis> so no gc will be necessary
21:07:04 <Axman6> merijn: annotated
21:07:18 <Axman6> maybe a little more indent
21:07:45 <merijn> Axman6: It makes me sad that AuthRequest doesn't line up with the others >.>
21:09:43 <Axman6> you can out some space after the open bracket
21:10:40 <mrsElectron> if I do     instance Eq MyType where ....         is MyType now automatically an instance of Eq, or do I have to specify that in data MyType =     as well?
21:10:40 <Axman6> put*
21:10:45 <merijn> hmmm, peerType is a bit long to type, but 'role' loses on account of being a parse error since 7.8...(although that should probably be fixed...)
21:11:13 <merijn> mrsElectron: You don't need to specify it in your type
21:11:40 <liyang> merijn: how about 'prole'?
21:11:47 <Axman6> Peering?
21:11:58 <Axman6> data Peering = Client | Server
21:22:55 * merijn sighs
21:23:19 <merijn> I hope 7.10 improves GHC's handling of GADT inference
21:30:37 <merijn> lens doesn't build with 7.9?
21:30:56 <MP2E> it doesn't? :(
21:31:00 * MP2E tries
21:31:17 <MP2E> oh wait i couldn't get one of the dependencies to build on the latest HEAD
21:31:25 <MP2E> might be able to with some hacking though
21:31:32 <merijn> 4.6 depends on split, which depends on base<4.7
21:32:04 <MP2E> oh :(
21:32:09 <merijn> eh, base<4.8
21:32:16 <merijn> byorgey: Ping?
21:34:17 <Kaidelong> I'm sorry that this isn't strictly haskell related, but does anyone here reside around Portland State University? I'm looking to get involved writing some haskell code again because I haven't had the chance for almost a year now
21:34:45 <merijn> oh, bollocks
21:41:32 <shergill> i requested a password reset for my account on hackage, but in the last 15-20 minutes i've received no email. whom should i followup with?
21:43:03 <mrsElectron> http://lpaste.net/114473  . Let's say that I have a Duck.  How do I make it print "duck"?
21:43:24 <pharpend> shergill: hmm. Hackage is generally terrible, so it's entirely possible that the request just failed
21:43:58 <pharpend> mrsElectron: putStrLn (species myDuck)
21:44:35 <mrsElectron> so species is a global function now?
21:44:45 <mrsElectron> oh, nvm
21:44:45 <pharpend> if you import it, yes
21:45:08 <mrsElectron> species is "global for duck" so to speak. But the function species does not exist for other data types.
21:45:09 <pharpend> so, if that class / instance is sitting in a module, and you import that module, you'll be able to use it
21:45:19 <shergill> pharpend: any idea who might be able to help?
21:46:02 <pharpend> shergill: no, sorry. You might go on /r/haskell on Reddit, there's usually someone bitching about Hackage. If someone says they are a hackage maintainer, you could message them.
21:46:27 <shergill> oh there's a #hackage channel
21:47:28 <mrsElectron> http://lpaste.net/114473    where there's a __________, what do you write there to print the Duck's string?
21:48:56 <mrsElectron> species Duck   is the way to invoke it I suppose. But how do I extract that string in the Duck?
21:54:41 <pavonia> mrsElectron: You can use pattern matching on the lefthand side
21:55:15 <mrsElectron> just realized :D
21:55:21 <Axman6> species (Duck str) = "Duck type: " ++ str
21:55:58 <pharpend> Axman6: duck type heh
21:56:04 * pharpend goes back into hiding
21:56:05 <mrsElectron> so if something is an instance of a class, does that mean that the instance HAS to support all the members of the class?
21:56:11 <Axman6> pharpend: heh
21:56:29 <mrsElectron> brb
21:56:45 <Axman6> mrsElectron: not necessarilly, when defining the class, you can make default implementations based on other functions
21:56:49 <Axman6> @src Eq
21:56:50 <lambdabot> class Eq a where
21:56:50 <lambdabot>     (==), (/=) :: a -> a -> Bool
21:56:54 <Axman6> bleh
21:56:58 <Axman6> @src (==)
21:56:58 <lambdabot> x == y = not (x /= y)
21:57:01 <Axman6> @src (/=)
21:57:01 <lambdabot> x /= y = not (x == y)
21:57:33 <Axman6> to make a type an instance of Eq, you only need to define (==) or (/=) (but you can define both)
21:58:06 <jle`> Axman6: in that case though, that instance still supports both
21:58:09 <jle`> even if you only deifne one
21:58:45 <Axman6> I'm not sure I follow, isn't that what I said?
22:00:01 <ddellacosta> is there any way to get that @src functionality inside of ghci?  I think I may have asked but I forget
22:00:35 <merijn> ddellacosta: "download the text file"
22:00:36 <Axman6>  @src is sort of a hack in lambdabot
22:00:44 <jle`> ddellacosta: it's just a CTRL+F on a text file
22:00:47 <merijn> ddellacosta: @src has no relation to the actual source
22:00:57 <jle`> so you can download it and then read it and maybe do a string find
22:01:07 <ddellacosta> merijn, jle`: yeah, that's what I resort to now...would be nice if it had something integrated. Ah well.
22:01:38 <jle`> Axman6: ah, well, mrsElectron asked if it has to support all the members, and it sounded like you were saying no, because of default implementations
22:01:55 <jle`> but with default implementations, it means that it does support all the members
22:07:23 <ski> mrsElectron : "does that mean that the instance HAS to support all the members of the class?" -- i'd say so (though people sin sometimes). however, as Axman6 said, you can sometimes rely on default implementations to not have to *explicitly* define all of them
22:08:59 <jle`> nothing is stopping someone from defining a method as `undefined`, or `let x = x in x`, or `error "hey"` of course
22:09:08 <ski> mrsElectron : normally, if a type is a member of a typeclass, people are going to assume it supports all the operations in the class, and be disappointed if it isn't
22:09:10 <jle`> a lot of instances in Prelude/base are unfortunately defined this way though :|
22:09:49 <ski> if a typeclass is badly designed, people may get tempted to not define all members, though
22:10:01 <jle`> but yeah, the *idea* is that it's supposed to represent something with all the members defined.
22:10:17 <Rufflewind> so, in attempt to have exactly one case expression, I have something that's akin to: let (chosenLens, someNumber) = case something of { A -> (lens1, 1); B -> (lens2, 2); C -> (lens3, 3); }, but somehow it looks like this is not going to type check -- is it because it requires impredicativity or something?  I'm using van Laarhoven lenses
22:10:50 <ski> Rufflewind : what are the types of `lens1',`lens2',`lens3' ?
22:11:37 <ski> hm .. i suppose there could perhaps be trouble with polymorphism there ..
22:12:08 <Rufflewind> Functor f => (a -> f a) -> b -> f b
22:12:35 <Rufflewind> now I'm trying to keep it polymorphic in "f", because I'm using it as a setter and a getter later on
22:12:56 <jle`> what's the error?
22:13:18 <Rufflewind> well, if I don't specify a type signature, it claims that "f" is ambiguous
22:13:42 <ski> > let f,g :: [a] -> [a]; (f,g) = if 2 > 3 then (reverse,id) else (id,reverse) in ((f . g) . map (g . f)) [[0,1,2],[3,4],[5],[]]
22:13:43 <lambdabot>  [[],[5],[4,3],[2,1,0]]
22:13:52 <ski> hm, looks like polymorphism would work
22:13:53 <Rufflewind> if I do, then it doesn't type check (my attempted type signature is: chosenLens :: Functor f => (a -> f a) -> b -> f b; someNumber :: Int
22:14:04 <Rufflewind> )
22:14:55 <Rufflewind> > let (lens, n) = (undefined :: Functor f => (a -> f a) -> b -> f b, undefined :: Int)
22:14:56 <lambdabot>  not an expression: ‘let (lens, n) = (undefined :: Functor f => (a -> f a) ->...
22:15:06 <ski> Rufflewind : are `a' and `b' already in scope ?
22:15:21 <Rufflewind> Oh right so a and b are not supposed to be polymorphic
22:15:25 <Rufflewind> they are fixed and known
22:15:26 <jle`> what does "doesn't typecheck" mean?
22:15:30 <jle`> what's the error?
22:15:36 <Rufflewind> jle`: let me try to show you with lambdabot
22:15:50 <Rufflewind> @type let (lens, n) = (undefined :: Functor f => (a -> f a) -> b -> f b, undefined :: Int) in undefined
22:15:51 <lambdabot>     No instance for (Functor f0)
22:15:51 <lambdabot>       arising from the ambiguity check for ‘n’
22:15:51 <lambdabot>     The type variable ‘f0’ is ambiguous
22:16:03 <jle`> ah
22:16:25 <Rufflewind> so that's what happens if I don't give an explicit signature
22:16:26 <jle`> taht sounds suspiciously like a DMR error
22:16:55 <Rufflewind> @type let (lens :: Functor f => (a -> f a) -> b -> f , n :: Int) = (undefined, undefined) in undefined
22:16:56 <lambdabot>     Expecting one more argument to ‘f’
22:16:56 <lambdabot>     Expected a type, but ‘f’ has kind ‘* -> *’
22:16:56 <lambdabot>     In the type ‘Functor f => (a -> f a) -> b -> f’
22:17:03 <ski> @type let lens :: Functor f => (a -> f a) -> b -> f b; n :: Int; (lens,n) = (undefined,undefined) in lens
22:17:04 <lambdabot> Functor f => (a -> f a) -> b -> f b
22:17:11 <Rufflewind> @type let (lens :: Functor f => (a -> f a) -> b -> f b, n :: Int) = (undefined, undefined) in undefined
22:17:12 <lambdabot>     You cannot bind scoped type variables ‘f’, ‘a’, ‘b’
22:17:12 <lambdabot>       in a pattern binding signature
22:17:12 <lambdabot>     In the pattern: lens :: Functor f => (a -> f a) -> b -> f b
22:17:19 <ski> Rufflewind : try using a type signature, instead of a type ascription ?
22:17:41 <jle`> i'm going to call it as DMR.
22:17:44 <Rufflewind> ski: will try that but i'm not entirely sure how to fit on one line :P
22:18:03 <ski> why on one line ?
22:18:18 <Rufflewind> @type let { lens :: Functor f => (a -> f a) -> b -> f b; n :: Int; (lens, n :: Int) = (undefined, undefined); } in undefined
22:18:19 <lambdabot> t
22:18:31 <Rufflewind> I don't know, does lambdabot accept multiline?
22:18:55 <ski> you can use `{',`;',`}', instead of layout
22:19:10 <ski> (though only `;' was needed here)
22:20:18 <jle`> see if you get the same error with {-# LANGUAGE NoMonomorphismRestriction #-} perhaps
22:25:53 <Rufflewind> @type let { trivialLens = id :: Functor f => (Int -> f Int) -> Int -> f Int; lens :: forall f. Functor f => (Int -> f Int) -> Int -> f Int; (lens, n) = (trivialLens, 1 :: Int); } in lens
22:25:53 <lambdabot>     No instance for (Functor f0)
22:25:54 <lambdabot>       arising from the ambiguity check for ‘n’
22:25:54 <lambdabot>     The type variable ‘f0’ is ambiguous
22:26:01 <Rufflewind> I guess that's the minimal example I can cook up
22:28:30 <Rufflewind> But the weird thing is that this works:
22:28:31 <Rufflewind> @type let { id' :: a -> a; (id', n) = (id, 1 :: Int); } in (id' 0, id' [])
22:28:32 <lambdabot> Num t => (t, [t1])
22:29:00 <ski> did you try jle`s suggestion yet ?
22:29:12 <jle`> upon closer inspection i'm not totally sure anymore but
22:29:18 <Rufflewind> I did beforehand
22:30:07 <merijn> That type doesn't seem right
22:30:43 <jle`> it's a little weird that the error is on `n`
22:31:00 <merijn> Shouldn't it be "id :: Functor f => (forall g . Functor g => Int -> g Int) -> Int -> f Int"?
22:32:31 <Rufflewind> This is how edward defines it: type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
22:33:36 <shachaf> merijn: No, it's the same f.
22:34:25 <shachaf> Rufflewind's type is a lens, if a very specific one.
22:34:30 <shachaf> A lens lens, I mean.
22:34:54 <merijn> hmm
22:34:55 <shachaf> I didn't see the beginning of the discussion.
22:34:56 <merijn> uhoh
22:35:15 <merijn> Data.Functor.Identity was found in multiple packages, that can't be right...
22:35:21 <shachaf> (forall g. Functor g => Int -> g Int) is a very boring type.
22:35:22 * hackagebot free-game 1.1.80 - Create games for free  http://hackage.haskell.org/package/free-game-1.1.80 (FumiakiKinoshita)
22:36:31 <Rufflewind> I'm not even sure you can define a valid "forall g. Functor g => Int -> g Int"
22:36:53 <Rufflewind> but in any case, so this works:
22:36:54 <Rufflewind> @type let { somelens = undefined; mylens :: forall f. Functor f => (Int -> f Int) -> Int -> f Int; (mylens, n) = (somelens, 1 :: Int); } in ()
22:36:55 <lambdabot> ()
22:36:57 <Rufflewind> but this one does not:
22:37:02 <Rufflewind> @type let { somelens :: forall f. Functor f => (Int -> f Int) -> Int -> f Int; somelens = undefined; mylens :: forall f. Functor f => (Int -> f Int) -> Int -> f Int; (mylens, n) = (somelens, 1 :: Int); } in ()
22:37:03 <lambdabot>     No instance for (Functor f0)
22:37:03 <lambdabot>       arising from the ambiguity check for ‘n’
22:37:03 <lambdabot>     The type variable ‘f0’ is ambiguous
22:37:09 <Rufflewind> I don't understand why
22:37:52 <jle`> hm
22:37:57 <Rufflewind> is there a way to figure out what GHC expects "somelens" to be?
22:38:01 <jle`> maybe it's struggling to find a type for (somelens, 1 :: Int)
22:38:11 <jle`> the tuple
22:38:14 <Rufflewind> @type let { somelens = undefined; mylens :: forall f. Functor f => (Int -> f Int) -> Int -> f Int; (mylens, n) = (somelens, 1 :: Int); } in somelens
22:38:15 <lambdabot> t
22:40:05 <jle`> maybe ... in order to pattern match on (somelens, 1 :: Int), it has to give it a type
22:40:12 <jle`> try adding a type signature to the tuple
22:40:45 <ski> hmm
22:41:04 <ski> i think the problem might be that `n :: Functor f => Int' is ambiguous
22:42:15 <ski> presumably it goes from `(somelens, 1 :: Int)' having type `Functor f => ((Int -> f Int) -> Int -> f Int,Int)' to `(mylens,n)' having that type, to `n' having type `Functor f => Int'
22:42:37 <Rufflewind> @type let { somelens :: forall f. Functor f => (Int -> f Int) -> Int -> f Int; somelens = undefined; mylens_n :: forall f. Functor f => ((Int -> f Int) -> Int -> f Int, Int); mylens_n = (somelens, 1 :: Int); } in ()
22:42:38 <lambdabot> ()
22:42:45 <ski> and if you would try to use `n', it wouldn't know which `f' to use, since `f' isn't mentioned in the main of the type of `n'
22:43:01 <jle`> ah, yeah.
22:43:24 <L8D> Why must the Y Combinator in LC look like \f -> (\x -> f (x x)) (\x -> f (x x))
22:43:31 <L8D> instead of \f -> f f
22:43:36 <ski> (that `n' actually doesn't depend on `f' here is another matter. it acts as if `n' could depend on it, because it had `Functor f =>' on the common pair type)
22:43:43 <L8D> oh wait
22:43:51 <L8D> I see
22:43:51 <ski> `\f -> f f' has the wrong type
22:43:55 <L8D> yeah
22:44:02 <L8D> well no but yeah
22:44:27 <Rufflewind> welp, it almost worked ... :(
22:44:32 <Rufflewind> @type let { somelens :: forall f. Functor f => (Int -> f Int) -> Int -> f Int; somelens = undefined; mylens_n :: forall f. Functor f => ((Int -> f Int) -> Int -> f Int, Int); mylens_n = (somelens, 1 :: Int); } in fst mylens_n
22:44:33 <lambdabot> Functor f => (Int -> f Int) -> Int -> f Int
22:44:42 <Rufflewind> but this one fails:
22:44:42 <Rufflewind> @type let { somelens :: forall f. Functor f => (Int -> f Int) -> Int -> f Int; somelens = undefined; mylens_n :: forall f. Functor f => ((Int -> f Int) -> Int -> f Int, Int); mylens_n = (somelens, 1 :: Int); } in snd mylens_n
22:44:43 <lambdabot>     No instance for (Functor f0) arising from a use of ‘mylens_n’
22:44:43 <lambdabot>     The type variable ‘f0’ is ambiguous
22:44:43 <lambdabot>     Note: there are several potential instances:
22:44:48 <Rufflewind> presumably for the reason you stated
22:44:53 <jle`> nice
22:45:11 <L8D> \f -> (\x -> x x) \x -> f (x x)
22:45:19 <Rufflewind> so is there no way to do this then?
22:45:25 <shachaf> What are you trying to do?
22:45:29 <L8D> \f -> (\x -> f (x x)) (\x -> f (x x)
22:46:08 <Rufflewind> I'm trying to use a single case expression and obtain two values, one of which is some lens, and the other is just some ordinary value (e.g. Int)
22:46:47 <Rufflewind> e.g. let (chosenLens, chosenNumber) = case something of { Something -> (mylens, mynumber); }
22:47:01 <shachaf> And you want the lens to be polymorphic?
22:47:06 <Rufflewind> yep
22:47:10 <shachaf> Sounds like trouble.
22:47:14 <Rufflewind> it does seem like it
22:48:16 <jle`> sounds like you're in an impredicament
22:48:34 <Rufflewind> ha. ha.
22:49:15 <ski> L8D : also, that's the Curry fixpoint combinator. there's also the Turing one `(\g -> \f -> f (g g f)) (\g -> \f -> f (g g f))'
22:50:17 <ski> @type let { somelens :: forall f. Functor f => (Int -> f Int) -> Int -> f Int; somelens = undefined; mylens_n :: forall f. (Functor f => (Int -> f Int) -> Int -> f Int, Int); mylens_n = (somelens, 1 :: Int); } in fst mylens_n
22:50:18 <lambdabot>     Illegal polymorphic or qualified type:
22:50:18 <lambdabot>       Functor f => (Int -> f Int) -> Int -> f Int
22:50:18 <lambdabot>     Perhaps you intended to use ImpredicativeTypes
22:50:23 <Rufflewind> ImpredicativeTypes sounds like a scary extension :\
22:50:35 <jle`> it is considered harmful(tm)
22:50:59 <ski> why ?
22:50:59 <merijn> jle`: No
22:51:10 <merijn> jle`: Harmful would be if it worked but was dangerous
22:51:15 <merijn> ImpredicativeTypes is broken
22:51:22 <jle`> ah i see
22:51:23 <merijn> ski: Because it shouldn't be used
22:52:00 <merijn> ski: I've filed tickets to remove the suggestion AND mark the extension deprecated, but neither has happened. I should just submit a commit for that myself...
22:52:13 <ski> in what way is it broken ?
22:52:19 <ski> how should it be fixed ?
22:52:38 <merijn> ski: It's not known how it should be fixed
22:52:58 <merijn> ski: I asked SPJ about the status and the status is: bit-rotted with theoretical flaws that no one knows how to fix
22:53:05 <ski> what is the particular problem ?
22:53:16 <merijn> ski: Ask SPJ, I dunno the theoretical problems
22:53:46 <Rufflewind> is there a way to explicitly specify a which instance of Functor is to be used if it doesn't appear at all in the actual type? ("phantom class constraint"? :P)
22:54:35 <ski> Rufflewind : one can often fix it with a type ascription
22:55:22 * hackagebot rot13 0.1.0.1 - Fast ROT13 cipher for Haskell.  http://hackage.haskell.org/package/rot13-0.1.0.1 (KyleVanBerendonck)
22:55:47 <Rufflewind> Maybe I should just give up ..
22:56:41 <jle`> if you made it Applicative you could make it work but it wouldn't be as general
22:57:24 <Rufflewind> I don't understand -- how does making it Applicative remedy the type ambiguity?
22:57:37 <jle`> you could have your second field be (f Int)
22:57:43 <jle`> and when you want to use it, take f to be Identity
22:57:50 <jle`> >____>
22:58:01 <jle`> and use pure (1 :: Int)
22:58:22 <shachaf> Does it?
23:00:40 <jle`> @type let { something :: forall f. Applicative f => (Int -> f Int) -> Int -> f Int; something = undefined; thingtuple :: forall f. Applicative f => ((Int -> f Int) -> Int -> f Int, f Int); thingtuple = (something, pure (1 :: Int)) in runIdentity (snd thingtuple)
23:00:41 <lambdabot> parse error on input ‘in’
23:00:43 <Rufflewind> wow, that's quite a hack hehe
23:00:49 <Rufflewind> but I see what you mean
23:01:22 <jle`> @type let { something :: forall f. Applicative f => (Int -> f Int) -> Int -> f Int; something = undefined; thingtuple :: forall f. Applicative f => ((Int -> f Int) -> Int -> f Int, f Int); thingtuple = (something, pure (1 :: Int)) } in runIdentity (snd thingtuple)
23:01:23 <lambdabot> Int
23:01:30 <jle`> ta da
23:01:51 <Rufflewind> that's very clever
23:02:35 <shachaf> Wait, you said you wanted it to be polymorphic.
23:02:36 <jle`> i don't think you can throw any lens in general in there anymore though
23:02:38 <shachaf> The lens, I mean.
23:02:52 <jle`> well, any `lens` in the actual meaning of the word
23:03:03 <jle`> so yeah it's probably useless
23:03:30 <jle`> hm
23:04:45 <jle`> @type let { something :: forall f. Functor f => (Int -> f Int) -> Int -> f Int; something = undefined; thingtuple :: forall f. Functor f => ((Int -> f Int) -> Int -> f Int, f () -> Int); thingtuple = (something, const (1 :: Int)) } in snd thingtuple (Identity ())
23:04:45 <lambdabot> Int
23:04:49 <jle`> heh
23:04:59 <Rufflewind> that worked?
23:05:07 <jle`> i think this one actually works, but it might be a bit inconvenient to use
23:05:19 <gfixler> covariance and contravariance are hurting my head a bit
23:05:25 <jle`> actually you can just use Nothing or [] there....
23:05:34 <jle`> @type let { something :: forall f. Functor f => (Int -> f Int) -> Int -> f Int; something = undefined; thingtuple :: forall f. Functor f => ((Int -> f Int) -> Int -> f Int, f () -> Int); thingtuple = (something, const (1 :: Int)) } in snd thingtuple Nothing
23:05:35 <lambdabot> Int
23:05:58 <jle`> :O
23:06:08 <Rufflewind> nice!
23:06:34 <shachaf> I don't even know what Rufflewind wanted anymore.
23:06:41 <shachaf> I thought the whole point was to get a polymorphic lens.
23:07:04 <jle`> the point was to provide a polymorphic lens along with a monomorphic value in a tuple
23:07:09 <jle`> and be able to use the value separate from the lens
23:07:14 <Rufflewind> it is polymorphic:
23:07:15 <Rufflewind> @type let { something :: forall f. Functor f => (Int -> f Int) -> Int -> f Int; something = undefined; thingtuple :: forall f. Functor f => ((Int -> f Int) -> Int -> f Int, f () -> Int); thingtuple = (something, const (1 :: Int)) } in fst thingtuple
23:07:16 <lambdabot> Functor f => (Int -> f Int) -> Int -> f Int
23:07:53 <jle`> the issue was that if you had Functor f => (blah, Int), using `snd` gives you Functor f => Int
23:08:14 <jle`> as in forall f. Functor f => Int
23:08:36 <jle`> so you can't ever access the actual naked Int without specifying the Functor instance...but you have no way to
23:10:09 <Rufflewind> yeah, would've been nice if there was a way to do that
23:11:46 <jle`> or at least to have the type system be okay with having f be ambiguous...somehow
23:11:52 <jle`> not sure how much that would break things
23:12:15 <jle`> :t snd `asAppliedTo` (undefined :: forall f. (f Int, Int))
23:12:16 <lambdabot> (f Int, Int) -> Int
23:12:43 <jle`> :t (snd `asAppliedTo` (undefined :: forall f. Functor f => (f Int, Int))) (Nothing, 2)
23:12:44 <lambdabot> Int
23:12:56 <jle`> wait er
23:18:19 <Rufflewind> So to avoid this problem, I'm going to try to use a different definition of lenses: type LensR f s a = ((a -> s) -> f a -> f s) -> (a -> f a) -> s -> f s
23:18:19 <Rufflewind> So now the Functor constraint is gone and but it's otherwise "equivalent"
23:21:53 <shachaf> You're missing the polymorphism. And compatibility with other lens types. Among other things.
23:21:56 <shachaf> What's the point?
23:23:27 <swgillespie> Is haskell.org down right now?
23:23:51 <shachaf> Yes.
23:23:59 <relrod> grr
23:24:00 * relrod looks
23:24:43 <swgillespie> :(
23:25:56 <Rufflewind> shachaf: compatibility is a concern, but it's easy to convert to the conventional kind of lens; and it is polymorphic, I just didn't put the forall a. in the type alias
23:26:43 <shachaf> forall a.?
23:26:57 <Rufflewind> oops I mean forall f.
23:27:12 <reactormonk> Let's say I construct a new function that only takes types which have `foo` defined - what is the `has foo defined` called? From languages, I'd call it an interface, but you don't have to explicitly define it on the source of the other types, so it's not really that.
23:27:14 <shachaf> And presumably also forall a s. inside the "fmap" argument?
23:27:16 <shachaf> What's the point?
23:27:24 <shachaf> You also lost type-changing.
23:27:59 <shachaf> reactormonk: What is foo?
23:28:20 <mrenaud__> Hey, I was wondering if someone could take a look at some code that I wrote and let me know if there is a more elegant way of doing it.
23:28:20 <reactormonk> shachaf, a function
23:28:27 <shachaf> reactormonk: A name of a function?
23:28:33 <reactormonk> yup, just wanted to correc that
23:28:45 <Rufflewind> shachaf: I can certainly write it as (forall a s. (a -> s) -> f a -> f s) instead but I don't know if that's needed for the simple lenses that I work with
23:28:51 <shachaf> reactormonk: Maybe the closest thing in Haskell to what you said is a type class. But I don't really know what you're getting at.
23:28:53 <relrod> swgillespie: waiting for the VM to reboot, should be back soon
23:29:09 <shachaf> Rufflewind: What's the point?
23:29:13 <shachaf> Or the goal, if you prefer.
23:29:38 <Rufflewind> shachaf: trying to avoid the issue I encountered earlier with the ambiguous Functor instance
23:29:57 <relrod> swgillespie: ok, it's back
23:30:12 <shachaf> Why not use type YourLens s a = s -> (s, a -> s) or some other lens definition?
23:30:27 <relrod> not sure for how long. It keeps going weird, and we really need to move that www VM to another datacenter soon.
23:30:57 <gfixler> reactormonk: it sort of sounds like you're talking about type constraints
23:31:02 <Rufflewind> shachaf: I guess so that it still bears some resemblance to the van Laarhoven lenses?
23:31:08 <shachaf> Why?
23:31:15 <reactormonk> shachaf, as an example, a function MapEvery2, which maps over any type that implements map, except it skips every second element
23:31:39 <shachaf> The type is now way too big. You need to convert it to the other sort of lenses manually anyway to use it.
23:31:41 <Rufflewind> shachaf: so that if I wanted to get a conventional lens I can just apply it to fmap
23:32:03 <shachaf> convertLens :: AnyLens s t a b -> Lens s t a b
23:32:15 <shachaf> Now you can convert AnyLens into a Lens just by applying convertLens to it.
23:32:22 <swgillespie> relrod: nice! thanks!
23:32:36 <jle`> reactormonk: there's a somewhat analogous (but not completely) concept called typeclasses
23:33:07 <reactormonk> jle`, is `Show` a typeclass?
23:33:23 <Rufflewind> shachaf: is that an actual function or are you just giving a hypothetical example?
23:33:39 <shachaf> It's a hypothetical example.
23:33:47 <jle`> reactormonk: a typeclass is a collection of functions (usually) involving a given type.  if we define such functions for our type, then our type is an instance
23:33:50 <shachaf> :t uncurry lens -- now it's an actual function
23:33:50 <jle`> :t lens
23:33:51 <lambdabot> Functor f => (s -> a, s -> b -> t) -> (a -> f b) -> s -> f t
23:33:51 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
23:34:04 <jle`> oops, redundant, sorry
23:34:05 <lpaste> mrenaud pasted “ReplicateAndReduce” at http://lpaste.net/114476
23:34:11 <jle`> reactormonk: Show is a typeclass
23:34:19 <mrenaud__> Could someone take a quick look at my code?
23:34:25 <jle`> reactormonk: you can say "this function only works on type sthat has `show` defined" by saying foo :: Show s => ...
23:34:41 <jle`> and wherever you use `s` in your type signature, you can assume that `s` has `show` defined
23:34:50 <shachaf> mrenaud__: That's the way to do it. Much better than waiting for someone to volunteer blind.
23:35:10 <reactormonk> jle`, can I project a type class onto something that didn't annotate it in the source, if I defined my own type class?
23:35:25 <jle`> i'm not totally sure what you mean
23:35:36 <Hijiri> you can
23:35:36 <jle`> you can't make an arbitrary already-defined function a part of your typeclass
23:35:44 <mrenaud__> shachaf: Haha, I'll keep that in mind, I kinda assumed that was what was happening :P
23:35:50 <jle`> well, you can, with hiding the names and stuff
23:35:55 <lightquake> what's the best data structure to represent a two-dimensional array whose bounds are known at compile time?
23:36:01 <Rufflewind> shachaf: the way I see it, all I'm trying to do is to make the instance passing explicit, I don't see the harm in that .. ? (a bit more tedious I suppose)
23:36:03 <Hijiri> I think reactor wants to make a new typeclass with new functions and make an instance for an existing type
23:36:13 <jle`> ah, yeah.  that is possible
23:36:15 <lightquake> if i'm going to need to be doing a lot of random access
23:36:17 <shachaf> lightquake: An array?
23:37:02 <reactormonk> Hijiri, also, is it possible to say "all data objects which implement function foo are members of this typeclass?"
23:37:07 <johnw> lightquake: a Vector
23:37:08 <shachaf> reactormonk: Please note -- and I don't know what the specific details of your application are -- that beginners tend to use type classes way too much when they learn Haskell.
23:37:42 <reactormonk> shachaf, ah don't worry, I'm not there yet. I'm writing stuff and I kinda touch functional programming and I wanna make sure I get it right
23:37:43 <shachaf> reactormonk: So you should be at least slightly biased toward not using them for things that you might use interfaces for in other languages. There are other approaches.
23:38:10 <Hijiri> Well when you write a typeclass, you are basically saying that everything that is in this typeclass has those functions
23:38:12 <reactormonk> shachaf, got me a few names of other approaches so I can read up?
23:38:18 <Hijiri> I don't really understand what you're asking though
23:38:22 <shachaf> @where faq talks about it a bit, I think.
23:38:22 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
23:38:26 <reactormonk> Hijiri, ok, cool, should do
23:38:31 <Hijiri> You can make a different typeclass a prerequisite for another typeclass
23:38:38 <shachaf> mrenaud__: The answer is yes.
23:39:02 <gfixler> reactormonk mentioned a MapEver2 function - that should just be a function, the end
23:39:06 <mrenaud__> Haha, can my next question be "Can you elaborate on the 'yes'?"
23:39:29 <lightquake> johnw: how's vector different from array?
23:39:40 <gfixler> mapEvery2 doesn't need to be part of anything - it just works on any list it's given
23:39:51 <reactormonk> gfixler, perfect
23:39:54 <johnw> lightquake: that's something I've wondered myself
23:40:05 <johnw> but I recall Vector being recommended to me
23:40:07 <shachaf> mrenaud__: I'm not exactly sure what you're doing, so it's hard to say.
23:40:18 <shachaf> mrenaud__: But it looks like you're doing three different steps in one go or something.
23:40:43 <shachaf> lightquake: Among other things, Array supports lots of things (such as tuples of Ints) for coördinates, but Vector just supports Ints.
23:41:00 <lightquake> ooh, look at you all fancy with your diaresis
23:41:39 <mrenaud__> Yes, I was originally doing something like: sum $ dedup $ sort $ forM (someOp :: Int -> [Int]) 0 [1..n], but the list returned from forM was massive and I don't care about duplicates.
23:41:43 <gfixler> In Python I've used tuples of (x,y) as keys in a map - anything similar in Haskell, or is that just craziness?
23:41:57 <mrenaud__> So to optimize I wanted to apply a reduction between calls to someOp
23:42:21 <reactormonk> My initial problem were two data types, which are of similar nature (both containing data about sentence borders), but the type is defined in two independent libraries. Is there a way to code a function in one library in such a way that it can accept sentence borders from both libraries without prior knowledge of the other? Or simply write a converter once you encouter the other?
23:42:24 <mrenaud__> Oops, someOp :: Int -> Int -> [Int]
23:43:47 <lightquake> gfixler: you can have a map whose keys are tuples, sure
23:44:05 <gfixler> lightquake: I've heard not-so-great things about maps in haskell, though
23:44:11 * lightquake shrugs
23:44:21 <lightquake> can't really say
23:44:23 <Hijiri> what not-so-great things?
23:44:32 <gfixler> Hijiri: very slow
23:44:44 <johnw> gfixler: that's pretty inspecific
23:44:52 <Hijiri> I wouldn't call it "very slow"
23:45:05 <gfixler> johnw: agreed - it wasn't very specific when I heard it, but I've heard it a few times
23:45:19 <shachaf> mrenaud__: More context might make it easier to come up with what you really want.
23:45:19 <Hijiri> a C array would be faster
23:45:22 <gfixler> not actually implemented with hashes, kinda slow, not all that great, few use them, etc
23:45:33 <Hijiri> Map is used all the time
23:45:43 <Hijiri> It doesn't use hashes, it's a binary tree
23:45:51 <Hijiri> but it's still fast enough for its applications
23:46:17 <lightquake> unordered-containers has a hashmap implementation
23:47:05 <mrenaud__> shachaf: https://www.hackerrank.com/challenges/manasa-and-stones
23:47:06 <lightquake> argh
23:47:16 <shachaf> mrenaud__: Here's a function similar to yours: let rAR :: Monad m => (m a -> m a) -> (a -> m a) -> Int -> m a -> m a; rAR red f = go where go 0 a = a; go n a = go (n-1) (red (a >>= f))
23:47:19 <lightquake> I hate it when I search for some package on google, and click the link
23:47:40 <Hijiri> HashMap is better than Map when the keys are expensive to compare
23:47:41 <lightquake> and I read the docs and don't notice it's for the initial v0.0.0.0.0.1 release :|
23:47:46 <Hijiri> but it still uses a binary tree
23:47:50 <shachaf> mrenaud__: If you combine f and reduce, you could get something like let rAR :: (a -> a) -> Int -> a -> a; rAR red = go where go 0 a = a; go n a = go (n-1) (red a)
23:47:54 <Hijiri> There are other maps for special use cases
23:48:09 <Hijiri> like IntMap, which sort of takes the role of arrays
23:48:21 <gfixler> Hijiri: http://ircbrowse.net/browse/haskell?id=18633231&timestamp=1405997767#t1405997767
23:48:26 <gfixler> lightquake: ^^
23:48:28 <gfixler> johnw: ^^
23:48:30 <shachaf> mrenaud__: I.e. just applying a function to a value n times.
23:48:43 <gfixler> little discussion from awhile back on maps, inefficiences, etc
23:49:31 <Hijiri> It was just inefficient because you don't have access to the underlying implementation of Map
23:49:38 <shachaf> What inefficiencies?
23:49:55 <Hijiri> If you use the map function provided by Map it will be plenty fast
23:50:04 <mrenaud__> shachaf: That is much simpler :P
23:50:10 <gfixler> well then I need to stop thinking of maps as inefficient, I guess
23:50:15 <Hijiri> That conversation was in the specific context of your exercise
23:50:22 * hackagebot dvorak 0.1.0.0 - Dvorak encoding for Haskell.  http://hackage.haskell.org/package/dvorak-0.1.0.0 (KyleVanBerendonck)
23:50:32 <shachaf> mrenaud__: Well, it also doesn't do the same thing. Of course you can also simplify that function further.
23:50:56 * lightquake knows next to nothing about performance in Haskell, so will bow out
23:50:59 <shachaf> But I think you asked the wrong question. You should've started by posting the real code that you wanted to improve, not a hypothetical attempt at abstracting it.
23:51:00 <gfixler> Hijiri: understood - I took things in wrong in my state of newb confusion
23:51:14 <shachaf> Things aren't inefficient in a vacuüm.
23:51:21 <shachaf> (That was for you, lightquake.)
23:51:32 <mrenaud__> I'm pretty sure it does do the same thing actually. It actually appers to be the same thing that I had, but more succinctly
23:51:48 <shachaf> mrenaud__: Well, you can simplify the last thing I wrote a lot more.
23:53:12 <mrenaud__> Oh, I was referring to the first one. And yes, I can see that, you could write it with a fold pretty easily as well
23:55:31 * gfixler just noticed sentence 1 of haskell.org's Data.Map page: "An efficient implementation of maps from keys to values."
23:56:09 <shachaf> The first step to making anything efficient.
23:57:27 <gfixler> ...is to start by making it really slow, a la this guy: https://www.youtube.com/watch?v=e08kOj2kISU
