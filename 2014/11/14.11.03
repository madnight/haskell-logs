00:00:15 <DTSCode> so any suggestions then?
00:00:40 <Cale> DTSCode: oh, uh
00:00:53 <Cale> DTSCode: Right, I already fixed this problem for someone else, as it happens
00:01:05 <DTSCode> o rly?
00:01:07 <Cale> DTSCode: There's no good reason for geordi to require such an old GHC
00:01:10 <DTSCode> thats awesome
00:01:14 <DTSCode> so how do i fix it?
00:01:59 <Cale> DTSCode: The modification to make it work with a newer GHC is like a 2 or 3 line change to fix a bug which a bug in the old GHC typechecker let pass.
00:02:07 <DTSCode> should i post the code then?
00:02:12 <DTSCode> ** the errors?
00:02:15 <Cale> Yeah, can you?
00:02:20 <DTSCode> btw this is different than the filters thing
00:02:38 <Cale> It's the bad instances thing?
00:02:52 <Cale> (That's what I'm assuming it is)
00:03:24 <DTSCode> it could be
00:03:24 <Cale> There were some really derpy instances which violated a functional dependency which was specified on a type class
00:03:47 <DTSCode> hold on im doing cabal install
00:06:20 <DTSCode> Cale, http://paste.ubuntu.com/8799784/
00:06:45 <Cale> oh, all right, that's a little different now
00:07:27 <Cale> Wait, can you post the definition of bits that you have?
00:07:40 <Cale> The version which I got to work off of github doesn't have this problem
00:08:16 <Cale> From the source file I have:  bits :: (Num t, Bits.Bits t) ⇒ t → [Bool]
00:08:17 <DTSCode> sure
00:08:22 <Cale> unbits :: (Num t, Bits.Bits t) ⇒ [Bool] → t
00:08:34 <DTSCode> where would i find the version
00:09:12 <fread2282> DTSCode: maybe skip the tests? cabal configure -f-testsuite
00:09:45 * hackagebot fixtime 1.5 - Some fixes to the time package  http://hackage.haskell.org/package/fixtime-1.5 (pharpend)
00:09:45 * hackagebot fixtime 1.5.0.1 - Some fixes to the time package  http://hackage.haskell.org/package/fixtime-1.5.0.1 (pharpend)
00:09:54 <Cale> I forget whose github repo it was that I grabbed
00:09:54 <DTSCode> ok thanks fread2282
00:09:59 <DTSCode> eelis?
00:10:03 <Cale> But this is a trivial fix
00:10:13 <Cale> Just add Num t to the constraints in those type signatures
00:10:32 <DTSCode> that didnt work fread2282
00:10:35 <Cale> I don't know how that definition ever would have worked
00:10:46 <Cale> If it didn't have a Num constraint
00:10:59 <DTSCode> Cale, im sorry i dont know what that means. im still much a noob to haskell
00:11:19 <Cale> Do you see a line: bits :: Bits t => t -> [Bool]
00:12:02 <DTSCode> in which file?
00:12:08 <Cale> Or perhaps   bits :: Bits.Bits t => t -> [Bool]
00:12:10 <DTSCode> or the error output?
00:12:28 <Cale> In the file mentioned in the error, src/MemoTrie.hs  line 52 or so
00:13:15 <DTSCode> how do i jump to a specific line in less again?
00:13:30 <Cale> Don't use less, use your text editor, we're going to change it
00:13:44 <DTSCode> oh ok
00:14:17 <Cale> (also, it's ":52", I believe)
00:14:47 <DTSCode> ok
00:14:51 <DTSCode> hold on installing nano
00:15:04 <DTSCode> normally im more prepared, but this is a fresh server install
00:15:35 <DTSCode> bits :: Bits.Bits t �^�^� t �^�^� [Bool]
00:15:39 <DTSCode> thats line 51
00:15:43 <Cale> okay
00:15:50 <Cale> modulo the unicode weirdness
00:15:58 <DTSCode> ?
00:16:01 <DTSCode> modulo it?
00:16:19 <Cale> Well, probably your IRC client mangled the unicode characters
00:16:26 <DTSCode> no that was nano tbh
00:16:29 <DTSCode> ill try vi
00:17:18 <DTSCode> bits :: Bits.Bits t ~G~R t ~F~R [Bool]
00:17:20 <DTSCode> thats vi
00:17:23 <Cale> lol
00:17:26 <Cale> uh
00:17:44 <DTSCode> hmmm hold on
00:18:20 <DTSCode> bits :: Bits.Bits t ⇒ t → [Bool]
00:18:23 <Cale> yes
00:18:24 <DTSCode> there thats the line
00:18:25 <Cale> okay
00:18:33 <Cale> bits :: (Num t, Bits.Bits t) ⇒ t → [Bool]
00:18:38 <Cale> Do that to it
00:18:51 <Cale> Similarly with unbits
00:19:39 <DTSCode> line 55?
00:19:42 <Cale> (I have no idea how that ever compiled)
00:19:54 <Cale> I don't know which line exactly
00:20:02 <Cale> The compiler error said 60
00:20:08 <Cale> or 59 rather
00:20:24 <Cale> 51 and 59
00:20:28 <DTSCode> ok and replace that with the line you said?
00:20:41 <Cale> The second one you want to do a similar thing
00:20:51 <DTSCode> oh. what would it be there?
00:20:57 <Cale> Replace Bits.Bits t with (Num t, Bits.Bits t)
00:21:40 <Cale> and then try to build again
00:21:54 <Cale> and you'll probably eventually run into the problem which I thought you'd run into
00:22:07 <DTSCode> unbits :: Bits.Bits t ⇒ [Bool] → t to unbits :: (Num t, Bits.Bits t) ⇒ [Bool] → t ? alright ill try that real quick
00:22:13 <Cale> yes, that's right
00:22:33 <Cale> Or I suppose you could just delete the type signature line altogether :P
00:22:46 <Cale> But whatever, better to have the correct signature than none at all
00:23:50 <DTSCode> ok here you go
00:23:51 <DTSCode> http://paste.ubuntu.com/8799966/
00:24:01 <DTSCode> also, thanks so much for the help
00:24:44 <Cale> That's interesting
00:24:47 <Cale> ghc --version
00:25:08 <DTSCode> The Glorious Glasgow Haskell Compilation System, version 7.6.3
00:25:17 <DTSCode> i got it with apt-get install ghc
00:25:22 <dario> hi, i'm trying to create "annotations" for data constructors, so that i can see which constructor a value must be constructed with from the type already
00:25:24 <dario> http://lpaste.net/113676
00:25:29 <DTSCode> the server is running ubuntu 14.04
00:26:21 <dario> the functor instance derivation fails, however, and there's a ghc bug that makes me think i can't change that behaviour unless upgrading (which is not an option)
00:26:43 <dario> so i'm not sure if there's a method similar to what's in my paste that would achieve similar functionality
00:26:54 <Cale> dario: Just write the Functor instance by hand?
00:27:02 <Cale> DTSCode: hmm
00:29:23 <Cale> okay, can you do:  locate HsUnix.h  and see if you can find that?
00:29:45 <Cale> It'll probably be /usr/lib/ghc-7.6.3/unix-2.6.0.1/include/HsUnix.h
00:30:04 <DTSCode> locate: can not stat () `/var/lib/mlocate/mlocate.db': No such file or directory
00:30:10 <Cale> great, lol
00:30:26 <Cale> because who needs a locate database anyway? :)
00:30:37 <DTSCode> not DTSCode thats for sure
00:30:54 <fread2282> find /usr/lib/ -name "9HBW4"
00:30:57 <Cale> Well, see if that path I mentioned exists
00:31:05 <fread2282> find /usr/lib/ -name "HsUnix.h"
00:31:11 * fread2282 oops
00:31:17 <Cale> It might be exactly that path :)
00:31:53 <Cale> (on my system it's the same but under /usr/local because I always install GHC by hand)
00:32:20 <Cale> If you find /usr/lib/ghc-7.6.3 but there's no unix-* directory under it
00:32:41 <DTSCode> hold on im going to connect with a file manager
00:32:49 <DTSCode> cause cd is not being helpful
00:33:16 <fread2282> DTSCode: use find! find /usr/lib/ -name "HsUnix.h"
00:33:58 <DTSCode> /usr/lib/ghc/unix-2.6.0.1/include/HsUnix.h
00:34:14 <Cale> okay, have a quick look at that file...
00:34:24 <Cale> int __hsunix_wifexited   (int stat);
00:34:27 <Cale> is that in it?
00:34:41 <Cale> (Should be!)
00:35:17 <DTSCode> yep its in there
00:35:25 <Cale> huh, so that's not the issue
00:36:33 <Cale> oh!
00:37:07 <Cale> look in sys/Sys.hsc
00:37:20 <Cale> There should be a line where it's importing Foreign.C
00:38:09 <Cale> (near the top)
00:38:14 <DTSCode> uhh /sys/Sys.hsc doesnt exist
00:38:21 <Cale> er
00:38:25 <Cale> src/Sys.hsc
00:38:26 <Cale> sorry
00:38:36 <Cale> In the project directory
00:38:41 <DTSCode> ah
00:39:22 <Cale> I think you'll see something like  import Foreign.C (CInt, ... other stuff)
00:39:31 <DTSCode> dtscode@dragontoothsoftware:~/geordi/src$ cat Sys.hsc | grep Foreign.c returned nothing
00:39:40 <Cale> Capital letter C
00:40:00 <DTSCode> ah
00:40:02 <DTSCode> my bad
00:40:20 <DTSCode> import Foreign.C is the only line it turned up
00:40:41 <Cale> okay, is there anything on the immediately following line?
00:41:17 <DTSCode> yeah (CInt, CUInt, CLong, CString, getErrno, eCHILD, throwErrno, withCString, throwErrnoIfMinus1_, eWOULDBLOCK, peekCString, peekCStringLen, Errno)
00:41:23 <Cale> yes, delete that
00:41:32 <DTSCode> ok
00:42:09 <Cale> We could also painstakingly add (..) to each of the type imports, but we're not going to do that, there's no harm in just importing that whole module
00:42:16 <DTSCode> ok done
00:42:20 <Cale> That should clear up the current set of errors
00:43:05 <Cale> (For anyone following along, it's because old GHCs would let you see through newtypes when doing foreign imports, even if their data constructors weren't in scope)
00:43:22 <Cale> more errors?
00:43:32 <DTSCode> ok that worked
00:43:35 <DTSCode> new errors: http://paste.ubuntu.com/8800159/
00:44:59 <Cale> Is there a similar line where it imports System.Posix.Types?
00:45:31 <Cale> (This is a little confusing for me, because my copy of geordi doesn't use CPid there)
00:45:43 <DTSCode> in the Sys.hsc file?
00:46:01 <Cale> yes
00:46:36 <Cale> Or maybe just System.Posix -- look for an import line which mentions CPid
00:47:04 <Cale> It's probably just the same problem but with a different type, they need to import the data constructor and they're not doing it
00:47:20 <Cale> So, we can just remove the explicit list and import everything which should fix it
00:47:23 <DTSCode> import System.Posix (Fd(..), CPid, ByteCount, Signal)
00:47:26 <Cale> yes
00:47:43 <Cale> You could change that to  CPid(..)
00:47:55 <Cale> or just delete the whole  (Fd(..), CPid, ByteCount, Signal)
00:49:08 <Cale> I'm always amazed when people have the patience to deal with explicit import lists on every dang module
00:49:12 <DTSCode> ok new errors http://paste.ubuntu.com/8800217/
00:49:22 <Cale> okay, fun
00:49:28 <DTSCode> i could never do that in python
00:49:54 <Cale> make that  import System.Posix hiding (sleep)
00:50:16 <Cale> (shouldn't be too many things that need hiding, I hope!)
00:51:13 <DTSCode> http://paste.ubuntu.com/8800240/
00:52:45 <Cale> all right
00:53:08 <Cale> add   import Control.Exception   to  src/Util.hs  somewhere near the top
00:53:37 <dario> Cale: hm, that didn't work either at first, but it brought me to the solution.. the a that i am referring to in "Decl VarDeclType a" is nowhere explicitly given, and if i add it to the constructors, things are working a lot better :)
00:53:56 <DTSCode> Cale, does it matter specifically which?
00:54:24 <Cale> DTSCode: Just anywhere along with the other imports there
00:55:01 <DTSCode> ok building again
00:55:27 <DTSCode> http://paste.ubuntu.com/8800294/
00:56:04 <Cale> Okay, this is slightly more annoying
00:56:13 <DTSCode> uhhmmm btw
00:56:23 <Cale> You know what, let's just find you an updated repo :P
00:56:30 <DTSCode> ok that will work
00:56:31 <Cale> this is dumb :)
00:56:37 <DTSCode> i agree
00:56:48 <Cale> for example, the one which is sitting in my downloads directory works
00:56:54 <Cale> So I'll just package it up
00:57:03 <DTSCode> so just rm the whole thing?
00:57:24 <Cale> yeah :P
00:57:48 <DTSCode> ok ty
00:58:10 <DTSCode> also, this means ill be able to build the clang branch rightt?
00:58:12 <Cale> cale.yi.org/geordi-0.1.tar.gz
00:58:31 <Cale> I honestly have no idea what geordi even is. It's some kind of IRC bot, right?
00:58:40 <DTSCode> yeah for c++
00:59:32 <Cale> I don't really know anything about it apart from the fact that someone else came here a while ago and had trouble building it, so I cranked through the mostly trivial compiler errors which were happening in GHC 7.8.3
00:59:51 <Cale> but I didn't have to deal with any of the errors you're getting
00:59:58 <Cale> so probably the version you have is older
01:00:51 <DTSCode> yeah thats the clang build
01:00:53 <DTSCode> oh well
01:01:13 <DTSCode> even that gave errors
01:01:16 <DTSCode> but oh well
01:01:23 <DTSCode> ill figure this out in the morning
01:01:36 <DTSCode> im too tired to do anything tonite
01:01:46 <DTSCode> thanks for the help Cale!!!]
01:01:52 <Cale> That one builds for me using GHC 7.8.3
01:02:02 <Cale> er, 7.8.2 actually
01:02:11 <Cale> (but 7.8.3 ought to also work)
01:02:17 <Cale> I haven't tried it with 7.6
01:02:25 <DTSCode> i have .6, so im guessing thats the issue
01:02:46 <DTSCode> maybe if i bug eelis enough hell update it to docker
01:02:57 <Cale> So if all else fails, you could just grab the generic linux binary package of ghc-7.8.3 from the ghc website
01:03:03 <DTSCode> yeah that too
01:06:25 <L8D> DTSCode: you on OS X?
01:06:48 <DTSCode> L8D, no its this linux distro called Manjaro
01:06:53 <DTSCode> by far the nicest ive seen
01:06:56 <L8D> ah
01:07:18 <L8D> there've been several OS X users having trouble migrating to 7.8
01:07:24 <DTSCode> very lite weight, because its new (still version 0.8) so it doesnt have fucking useless crap
01:07:28 <L8D> isn't majaro arch-based?
01:07:35 <DTSCode> yes it is
01:07:39 <L8D> manjaro*
01:07:50 <L8D> Why would you use it over arch?
01:08:02 <DTSCode> also, im sure i can get to 7.8, i just didnt try it cause reddit told me to use 7.4
01:08:26 <DTSCode> because its like arch except i dont have to go through the whole process of manually setting it up
01:09:11 <L8D> I guess I've installed arch in way too many weird places for me to justify using an automated installer :/
01:09:46 <DTSCode> im not such a huge linux guy anymore so the less i have to deal the underlying belly the better
01:10:09 <L8D> like I'll try putting ubuntu on it because I'm lazy but I run in to so many problems in setting up/configuring boot loaders and init systems that I save time when installing it manually
01:10:32 <L8D> and plus arch has all those amazing other features
01:10:35 <DTSCode> really? i never had issues with installing bootloaders on ubuntu
01:10:38 <L8D> I wonder what happened to the community
01:10:46 <DTSCode> yeah arch is very cool
01:10:48 <L8D> with the systemd fiasco
01:11:00 <L8D> did it split into a flame war or no?
01:11:26 <DTSCode> ummm im not sure. i parted #arch a while ago
01:11:40 <DTSCode> cause #manjaro is a lot more helpful
01:11:48 <L8D> is manjaro still on systemd?
01:12:01 <DTSCode> ummm idk. i think so
01:12:02 <DTSCode> ill ask
01:15:57 <DTSCode> well no one responded, but ill have to look in the morning cause im off to bed
01:16:30 <L8D> you could just type "which systemctl" :/
01:16:39 <dTSCode> o rly?
01:16:45 <dTSCode> /facepalm
01:16:51 <dTSCode> sorry kind of a noob in that area
01:17:11 <L8D> does it give you anything?
01:17:13 <dTSCode> /usr/bin/systemctl
01:17:27 <L8D> yeah then your installation is using systemd
01:17:30 <L8D> much dissapoint
01:17:38 <dolio> This is not the place for that.
01:18:09 <Hijiri> #leavepoetteringalone
01:22:22 <edricgarran> why is there a flamewar about systemd? never had any problems with it
01:22:46 <dolio> systemd flamewars are off topic.
01:29:04 <osa1> it looks like cabal doesn't use ~/.cabal/lib to search for looking for native libs. any ideas how can I fix this?
01:29:18 <structuralist> I'm having trouble cabal-installing the network package
01:29:23 <structuralist> http://lpaste.net/113678
01:29:38 <osa1> for example, it can't install async because of /usr/lib64/gcc/x86_64-suse-linux/4.8/../../../../x86_64-suse-linux/bin/ld: cannot find -lHSstm-2.4.3-ghc7.8.3 even though I have it installed in .cabal/lib
01:29:40 <structuralist> doesn't seem to be finding it, or something
01:30:10 <structuralist> am I doing something wrong here?
01:30:32 <osa1> structuralist: just tried here and it worked. maybe try to update your Cabal, cabal-install and run cabal update
01:35:37 <danilo2> Hello! I've got a traversal-like question to you today! :D Lets assume we've got data A = A B C (where these datatypes are recursive and have many constructors). I want to traverse this datatype and apply appriopriate functions to appriopriate types (like fA :: A -> m A, going on: A <$> fB B <*> fC C). Is there any support for something like that in lenses?
01:36:29 <danilo2> Additional - I would love to apply only these functions that I need - sometimes I will need to use fA and fB, sometimes only fC - othercase (if function is not provided) it should traverse further
01:36:40 <dcoutts> osa1: cabal uses ghc-pkg to tell it where libs are installed. So in a sense it doesn't matter what is in ~/.cabal/lib, it's what ghc-pkg says that's important
01:36:52 <structuralist> osa1: yeah, updating cabal worked for some reason. thanks for the suggestion
01:37:22 <osa1> dcoutts: should I configure ghc-pkg somehow?
01:38:06 <osa1> is extra-lib-dirs in cabal config file relevant?
01:38:28 <osa1> oh, why everything is commented out in my cabal config
01:44:19 <osa1> nope, looks like it's not related with my cabal config
01:46:57 <L8D> cabal has been building haskell-src-exts for the past 15 minutes
01:57:04 <dcoutts> osa1: -lHSstm-2.4.3-ghc7.8.3 is very much an ordinary Haskell lib, not a C lib, so if ghc cannot find it then it's either because it does not exist, or ghc-pkg does not know about that package
01:57:33 <dcoutts> osa1: extra-lib-dirs is about finding C libs that do not live on the system linker path
01:58:04 <osa1> dcoutts: the point is that it's still linked using standard ld tool so maybe arguments that are passed to ld may make it working
01:58:07 <osa1> but I failed to do that
01:58:33 <romildo> I am using the latest haskell-mode for emacs on linux. Every time I start emacs and open a haskell source file and load it into GHCi, I am prompt if I want to start a new project? Is it possible to have this set up so that I do not asks again after an affirmative answer?
01:58:59 <dcoutts> no that's not a sensible workaround, if ghc cannot find that file it's because the package registration or installation is borked
01:59:36 <dcoutts> osa1: are you sure it exists? are you trying to do dynamic linking but have not built libs for dynamic linking?
02:00:23 <osa1> dcoutts: do I need to do anything for that? I'm using cabal for years and it was handling dynamic linking all the time
02:00:42 <L8D> killall happy && killall ghc
02:01:05 <L8D> -.-
02:01:23 <dcoutts> osa1: as a first step, check where ghc-pkg thinks stm is installed, then look there and see what .a and .so files it has
02:02:13 <dcoutts> osa1: as in, ghc-pkg field stm library-dirs
02:02:55 <osa1> it's pointing to correct dir
02:03:35 <osa1> and I have .a and .o in the dir
02:03:41 <osa1> versions etc. all correct
02:03:50 <dcoutts> so it's not built for dynamic linking
02:03:53 <magthe> there are at least 3 ByteString builders: Data.Binary.Builder, Data.ByteString.Build, and Blaze.ByteString.Builder... is there one I absolutely should use over the others?
02:04:09 <dcoutts> magthe: yes, Data.ByteString.Builder
02:04:13 <osa1> dcoutts: interesting. why all of a sudden I started to get this error? it was handling dynamic linking before
02:04:46 <magthe> dcoutts: thanks, that was quick and clear :)
02:06:18 <dcoutts> osa1: perhaps you didn't have shared: True in your ~/.cabal/config when you originally installed the stm package
02:07:50 <osa1> that may be true
02:08:13 <osa1> dcoutts: thanks for the help. is there a way to see if .a or .o is compiled for dynamic linking?
02:08:29 <dcoutts> osa1: it's the .so that's the one for dynamic linking
02:08:41 <dcoutts> osa1: .a for static, .so for dynamic
02:08:51 <dcoutts> .o is not used anymore by modern ghc/cabal
02:09:06 <dcoutts> older ghc versions used the .o for ghci
02:13:02 <magthe> I feel there ought to be a standard function for (Enum a, Enum b) => a -> b already (i.e. toEnum . fromEnum) but can't work out the Hayoo-fu to find it... is there one?
02:13:02 <magthe> or maybe I'm thinking about it the wrong way... I have a few types from Foreign.C.Types that I want to pass into ByteString.Builder
02:19:45 * hackagebot hpqtypes 1.2.3 - Haskell bindings to libpqtypes  http://hackage.haskell.org/package/hpqtypes-1.2.3 (arybczak)
02:23:12 <andrewmchen> quit
02:35:57 <remdezx> Hello! Can you look at my question on stackoverflow? I'm struggling with memory management in ghci http://stackoverflow.com/questions/26712188/how-can-i-make-ghci-release-memory
02:57:46 <prinsen> Is there any chance anyone want to help with a ECMA-262 interpreter? The parser is now complete but pretty slow and I would love if someone with more experience of parsing would like to look at it
02:59:54 <troydm> prinsen: what parsing library are you using?
03:02:12 <myfreeweb> hey, speaking of parsing, how do I parse a string with escaping in attoparsec? I need to parse "hello \"world\"" correctly
03:02:31 <prinsen> troydm: parsec
03:06:34 <prinsen> troydm: It parses a 400 line file in about 0.4 sec
03:06:48 <prinsen> But really has problems with deeply nested code
03:06:49 <troydm> prinsen: try using attoparsec instead
03:06:58 <prinsen> is it a drop in replacement?
03:07:05 <troydm> prinsen: almost
03:07:46 <dramforever> nope
03:07:56 <dramforever> attoparsec = parsec sans sugar
03:08:28 <dramforever> but sure, it's faster
03:09:17 <L8D> what is the "!" type constructor thing?
03:10:28 <prinsen> Ok, as I am implementing the interpreter, someone wanting to help with the parser would be highly appreciated! Its really clean code and translates directly to the spec grammars
03:10:52 <L8D> prinsen: sure
03:11:16 <benzrf> L8D: huh?
03:11:25 <dramforever> L8D: I think you mean data Foo = Foo !Bar
03:11:34 <L8D> dramforever: yeah that
03:11:40 <L8D> I never knew what that meant
03:11:59 <dramforever> that makes that field unable to be a thunk
03:11:59 <L8D> does it mean unboxed or something?
03:12:03 <prinsen> L8D: awesome, ill create a git repo
03:12:09 <dramforever> L8D, nope
03:12:17 <prinsen> no its a bang patern, meaning that the data is strict
03:12:26 <dramforever> so it cannot be a thunk
03:12:36 <dramforever> however the data itself may contain thunks
03:12:37 <L8D> what's a "thunk" again?
03:12:47 <dramforever> unevaluated thingy
03:13:27 <L8D> so is it more for performance purposes or eliminating infinitely generated data structures or something?
03:13:40 <L8D> recursively generated*
03:13:42 <dramforever> nope
03:13:53 <dramforever> well, more for performance in *some* cases
03:14:00 <L8D> what differences does it make that I should care about?
03:14:17 <dramforever> you know what does seq do?
03:14:20 <L8D> it can't be something like "undefined" or "error" ?
03:14:25 <dramforever> yeah
03:14:31 <L8D> ah
03:14:36 <dramforever> but it *can* be [undefined]
03:14:49 <dramforever> because <thunk> : <thunk> is not a thunk
03:15:00 <L8D> and I'm assuming it's mostly used on records then?
03:15:09 <dramforever> well...
03:15:19 <L8D> to guarentee that their fields are not undefined?
03:15:27 <dramforever> no
03:15:48 <dramforever> guarentee that their fields are evaluted at least some-ly
03:16:04 <dramforever> so no big thunk building for simple stuff like Int's
03:16:16 <dramforever> @src Data.ByteString.Internal.ByteString
03:16:16 <lambdabot> Source not found. Just what do you think you're doing Dave?
03:16:26 <dramforever> @src Data.ByteString.Internal.PS
03:16:26 <lambdabot> Source not found. Just what do you think you're doing Dave?
03:16:32 <benzrf> L8D: learn about whnf already!
03:16:37 <dramforever> @type Data.ByteString.Internal.PS
03:16:39 <lambdabot> GHC.ForeignPtr.ForeignPtr Word8 -> Int -> Int -> BSC.ByteString
03:17:09 <benzrf> L8D: a thunk can be thought of as an unevaluated expression
03:17:33 <benzrf> like, in a naive haskell interpreter that just operates on an AST and reduces expressions, a thunk would look like an unreduced expression
03:17:56 <benzrf> haskell's non-strictness is implemented through thunks (in ghc at least)
03:18:20 <benzrf> in my naive example, you'd see things like unreduced expressions being passed into a function as arguments without being reduced first
03:20:50 <chrisdone> benzrf: i wouldn't've thunk it!
03:21:15 <benzrf> (☞ﾟ∀ﾟ)☞
03:21:56 <L8D> where do people even get these characters?
03:22:03 <benzrf> useful websites
03:22:17 <L8D> for some reason that seems sad to me.
03:22:32 <L8D> entire websites dedicated to copy-pastable unicode characters
03:22:44 <benzrf> L8D: 'whnf' or 'weak head normal form' is a particular kind of state of being partially reduced
03:23:25 <L8D> benzrf: if I'm teaching a Java/C++ programmer Haskell, should I start with the "Haskell for C programmers" approach, or with the LYAHFGG approach?
03:23:32 <benzrf> L8D: iirc, a partially-reduced expression is in WHNF if the outermost expression is either a lambda expression or application of a constructor to (not necessarily reduced) arguments
03:23:37 <benzrf> L8D: i dunno
03:24:00 <L8D> jle`: you there?
03:24:08 <benzrf> @src cycle
03:24:08 <lambdabot> cycle [] = undefined
03:24:09 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
03:25:01 <benzrf> L8D: like for example, "cycle [3]" is not whnf. reducing it yields "[3] ++ cycle [3]" (more or less) which is not whnf. reducing that yields 3:cycle [3], which IS whnf
03:25:13 <benzrf> generally speaking, things like seq (in ghc) are strict "up to whnf"
03:25:20 <benzrf> they will not cause deep evaluation
03:25:28 <benzrf> > cycle [3] `seq` True
03:25:30 <lambdabot>  True
03:25:59 <L8D> does whnf only apply to the heads of data types?
03:26:13 <L8D> heads of their constructors*
03:26:19 <benzrf> 06:21 < benzrf> L8D: iirc, a partially-reduced expression is in WHNF if the outermost expression is either a lambda  expression or application of a constructor to (not necessarily reduced) arguments
03:26:32 <L8D> thank you
03:27:48 <benzrf> hmm... would recursion be possible in haskell if it didnt have recursive let bindings already?
03:29:47 * hackagebot hsfilt 0.1.0.0 - Z-decoder.  http://hackage.haskell.org/package/hsfilt-0.1.0.0 (OmerAgacan)
03:29:49 * hackagebot pipes-shell 0.1.3 - Create proper Pipes from System.Process  http://hackage.haskell.org/package/pipes-shell-0.1.3 (kbrei)
03:30:17 <exio4> benzrf: can we use unsafeCoerce? (also, yes, with datatypes)
03:31:06 <benzrf> exio4: no we cant
03:31:17 <benzrf> how with types thou
03:31:22 <benzrf> gh
03:33:43 <shiona_> any help with aligning this to a neat square: http://paste.hskll.org/get/1685
03:40:24 <remdezx> is there a method that will give me memory footprint of an object?
03:40:41 <benzrf> remdezx: is this the right channel
03:41:22 <remdezx> benzrf: sorry
03:41:50 <Aleksejs> Hi, is there any benefit of using docker for projects written in haskell?
03:42:23 <remdezx> benzrf: oh, it is! I thought I wrote it on #ghc
03:42:37 <remdezx> I'm looking for memory footprint of haskell objects
03:43:27 <remdezx> I know that I could compute it like this https://www.haskell.org/haskellwiki/GHC/Memory_Footprint , but maybe there is a method to do it
03:53:04 <benzrf> well given that you said "method" and "object" i thought maybe you were trying for #java :p
04:20:51 <belst> hey what does if' mean? lambdabot @pl creates me a statement where if' is sth. but its always not in scope
04:21:34 <ClaudiusMaximus> @pl if x then y else z
04:21:34 <lambdabot> if' x y z
04:22:04 <belst> yes and if i try to use this, its always if' out of scope
04:22:30 <ClaudiusMaximus> you can define if' x y z = if x then y else z
04:22:43 <belst> ah k thx
04:32:53 <clrnd> lispy
04:39:50 * hackagebot ghc-mod 5.2.1.1 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-5.2.1.1 (DanielG)
05:12:48 <wz1000> Is it possible to force execution of code at compile time? I have a large text file that I want to parse into a Map at compile time, which would then be used (purely) in my code. What should I do?
05:17:39 <sshine> wz1000, sounds like a job for Template Haskell.
05:19:32 <Blizzy> Haskell is so confusing. *^*
05:19:51 <sshine> Blizzy, *^* would be a cool name for an operator.
05:20:10 <Blizzy> lol.
05:21:08 <sshine> wz1000, one way I can think of: load your dictionary from file using a StringTemplate at compile-time, convert it into a dictionary - I'm not sure if GHC compiles the dict itself at runtime or compile-time, though.
05:21:41 <mauketwork> > let (*^*) = (<>) in "hello" *^* " world"
05:21:43 <lambdabot>  "hello world"
05:21:53 <Blizzy> I'm going to force myself to learn Haskell.
05:22:04 <mauketwork> what languages do you know?
05:22:29 <Blizzy> Python, Ruby, Javascript, PHP, learning Go and Java.
05:22:41 <Blizzy> I plan to be a Full Stack Dev.
05:22:46 <mauketwork> hmm, not very applicable
05:22:55 <Blizzy> oh. :L
05:22:56 <mathk> Does someone have an idea why when using cabal repl I have this error: ghc.exe: ...\HSgtk-0.13.0.3.o: unknown symbol `__imp___fmode'
05:23:00 <mathk> with GTK
05:23:07 <exio4> Haskell isn't confusing, it is just that you are used to different languages
05:23:10 <mauketwork> javascript may be helpful in parts
05:23:12 <Blizzy> what do you recommend learning then, mauketwork, other than Haskell. :P
05:23:19 <mathk> but it work fine with cabal run
05:23:27 <mauketwork> I recommend starting with Haskell ;-)
05:23:43 <Blizzy> wow, I never would of expected that answer from a Haskell channel.
05:23:45 <Blizzy> lol.
05:24:01 <mauketwork> ocaml has a few very similar concepts
05:24:06 <Blizzy> I am trying to learn Haskell because it seems to have a great future, like Go, and like Go, are very popular atm.
05:24:12 <mauketwork> but it doesn't help with the whole laziness/purity thing
05:24:25 <Blizzy> Go and Haskell seem like they will be very useful in the future.
05:24:32 <mauketwork> perl (of all things) has evaluation contexts
05:25:10 <exio4> Blizzy: if you like programming, you'll probably find learning Haskell an amazing experience, it is like learning to program again
05:25:26 <Blizzy> yeah, I love programming.
05:25:29 <nclarke> Anyone familiar with the internals of optparse-applicative?
05:25:41 <Blizzy> so yeah, I'm trying to learn Haskell again for like the nth time, except this time, I won't give up.
05:25:43 <mauketwork> main = putStr "Hello, world!\n"  -- your first Haskell program
05:25:58 <mauketwork> hah, sounds familiar
05:26:21 <mauketwork> I also gave up the first time, and I already knew ocaml then
05:27:06 <ajcoppa> Blizzy: there's a #haskell-beginners channel with lots of people going through a similar experience, along with a fantastic guide to getting started
05:27:39 <Blizzy> thanks, ajcoppa. also, question. <mauketwork> > let (*^*) = (<>) in "hello" *^* " world"
05:27:42 <Blizzy> what does that do?
05:27:44 <sshine> I didn't give up with Haskell the first time, but I did give up with O'Caml once or twice as it was my first functional language.
05:27:59 <Blizzy> I know let can change the way it evals, like 'let 2+2=5 in 2+2'
05:28:10 <joe9> Could anyone please be kind enough to write a few examples of "delimited continuations" in this theme: https://www.fpcomplete.com/user/jwiegley/understanding-continuations
05:28:13 <sshine> Blizzy, it binds *^* to the already existing <> operator and then uses *^* on two strings.
05:28:16 <mauketwork> Blizzy: 'let' defines local variables
05:28:25 <Blizzy> oh ok.
05:28:27 <mauketwork> the 2+2=5 thing locally redefines the + operator
05:28:35 <joe9> I think I understand the theory of what the "delimited continuations" do but, not how they work from a haskell perspective.
05:28:37 <Blizzy> thank you, mauketwork and sshine.
05:28:41 <exio4> > let 2+2=5 in 1+1
05:28:43 <lambdabot>  *Exception: <interactive>:3:5-9: Non-exhaustive patterns in function +
05:28:50 <mauketwork> > let x = 42 in "x is " ++ show x
05:28:52 <lambdabot>  "x is 42"
05:29:00 <mauketwork> > let x = 42 in x + 1
05:29:02 <lambdabot>  43
05:29:03 <bernalex> my brain is too tired. ideas on how to deduplicate this: http://lpaste.net/9010544394314448896 ?
05:30:01 <Freundlich> Given [a_1, ..., a_n] and a. Is there any terse way to generate [[a, a_1, ..., a_n], [a_1, a, a_2, ..., a_n], ..., [a_1, ..., a_n, a]] (a list of lists such that 'a' is inserted at every possible place)?
05:30:15 <Blizzy> learning already. ++ is used to combine strings and for variables, it's "Hello " + show foo
05:30:16 <sshine> bernalex, why do you mix your parse function with IO?
05:30:25 <sshine> :t (++)
05:30:27 <lambdabot> [a] -> [a] -> [a]
05:30:40 <sshine> Blizzy, actually, (++) works for concatenating any kind of lists, not just strings.
05:30:41 <mauketwork> Blizzy: ++ concatenates lists. String is a list of Chars
05:30:46 <Blizzy> oh.
05:30:49 <Blizzy> thanks again guys.
05:30:53 <mauketwork> Blizzy: 'show' converts values to strings
05:30:57 <mauketwork> usually to strings in haskell syntax
05:31:08 <gcganley> :t String
05:31:10 <lambdabot> Not in scope: data constructor ‘String’
05:31:11 <mauketwork> > show ([1] ++ [2])
05:31:13 <lambdabot>  "[1,2]"
05:31:20 <mauketwork> (haskell syntax for a list)
05:31:27 <exio4> > [1,2,3] ++ [4,5,6] ++ [7,8,9]
05:31:28 <narendraj9> :info String
05:31:29 <lambdabot>  [1,2,3,4,5,6,7,8,9]
05:31:44 <bernalex> sshine: fair point. I should deduplicate parsing/deciding what to do a bit more.
05:32:05 <Blizzy> atm, I'm looking at example Haskell code on rosettacode.
05:37:30 <Blizzy> Learn You a Haskell is also helpful atm. :P
05:37:40 <Blizzy> I think I'll put off Go and Java for a while.
05:37:54 <gcganley> Blizzy: have you tried Real World Haskell?
05:38:01 <Blizzy> no.
05:38:35 <gcganley> i keep forgetting how to link to articles using lambda bot but its a orielly book, quality stuff
05:38:36 <exio4> I really liked LYAH, it was a fun way to get used to haskell
05:38:42 <exio4> @where rwh
05:38:43 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
05:39:06 <Blizzy> thank you, exio4 and gcganley.
05:40:00 <narendraj9> Blizzy: There's also a MOOC on edX -- Introduction to Functional Programming.
05:40:19 <Blizzy> thank you, narendraj9.
05:41:13 <sshine> narendraj9, "MOOC"?
05:41:25 <exio4> a nice programming language course is https://www.coursera.org/course/proglang too
05:41:33 <exio4> sshine: masive open online course
05:42:12 <joe9> Blizzy: http://adit.io/index.html love this too.
05:42:28 <Blizzy> thanks, joe9. :P
05:43:05 <exio4> also, https://github.com/bitemyapp/learnhaskell
05:43:08 <narendraj9> Blizzy: You can always go to class-central.com and search for MOOCs related to a topic.
05:43:33 <Blizzy> well, wow, thxs for all the help everyone. seems like I'm getting thrown a lot of stuff at once.
05:43:45 <narendraj9> Blizzy: Here's the one on edx -- https://www.edx.org/course/delftx/delftx-fp101x-introduction-functional-2126
05:44:01 <exio4> check what link seems "nicer" for you, Blizzy
05:44:14 <Blizzy> atm I'm going through Learn Yourself a Haskell.
05:44:59 <gcganley> Blizzy: thats a good start for almost everyone
05:51:29 <pyon> Hello again.
05:51:42 <pyon> Oops, wrong channel.
05:52:26 <gcganley> pyon: HI
05:52:38 <pyon> gcganley: Hi.
05:52:39 <pyon> I wanted to a question nevertheless: If I want to model a sequential reduction relation for a CBV lambda calculus, I could use a function "eval :: Term -> Maybe Term".
05:53:03 <pyon> How should I model a parallel reduction relation (still for a CBV lambda calculus)?
05:55:54 <zennist> How do I save my :set options in ghci so that next time I start it up it is in the same condition?
05:56:53 <pyon> I am guessing I could do something like "eval (Pair t1 t2) = case (eval t1, eval t2) of { (Just t1, Just t2) -> Just (Pair t1, t2) ; (Just t1, Nothing) -> Just (Pair t1 t2) ; (Nothing, Just t2) -> Just (Pair t1 t2) ; (Nothing, Nothing) -> Nothing }", but this commits me to performing the parallel evaluation of t1 and t2 "at the same speed".
05:57:40 <pyon> zennist: Put all the commands you want to run by default when you start ghci in your ~/.ghci
05:58:37 <pyon> zennist: e.g., if you always want to use type families, your ~/.ghci should contain the like ":set -XTypeFamilies".
05:58:59 <pyon> the line*
05:59:03 <zennist> pyon: cool, it works. thanks
05:59:05 <pyon> :-)
06:04:05 <nclarke> optparse-applicative question: I have a functor f, and am using the `free` package to get a free alternative functor over f. I also have a nat. transformation from f to `Optparse-applicative`'s Parser, and would like to use `runAlt` to transform from `Alt f` to `Parser`
06:05:10 <nclarke> But this fails in the transformation of alternatives, because `optparse-applicative` looks to be cheating in its `Alternative` definition: http://hackage.haskell.org/package/optparse-applicative-0.11.0.1/docs/src/Options-Applicative-Types.html#manyM
06:06:16 <nclarke> Am I right in this analysis, or missing something? I don't see that I can transform, because optparse is using more than Alternative laws there
06:09:39 <sshine> pyon, I'm not sure I understand exactly what you're doing (I don't know what a parallel reduction relation is). are you trying to actually parallelize the evaluation, or are you simulating parallel execution?
06:11:22 <sshine> pyon, the large case-of you provided was a little confusing - do you mean to shadow the old t1, t2 whenever something evaluates and use the pre-eval versions of t1, t2 whenever they evaluate to Nothing?
06:16:00 <MrPopinjay> Hello all. I have "type Hand = [Char]" in my script, and HLint wants me to use String. Is there a way to suppress just this warning? I can't find a pragma that looks correct in the man page
06:16:04 <MrPopinjay> Thanks, Louis
06:16:32 <MrPopinjay> http://community.haskell.org/~ndm/darcs/hlint/hlint.htm
06:18:38 <hellertime> @pl f = (return . toList) =<< (readTVarIO . _thingy)
06:18:38 <lambdabot> (line 1, column 4):
06:18:39 <lambdabot> unexpected " "
06:18:39 <lambdabot> expecting operator
06:20:22 <hyPiRion> @pl (return . toList) =<< (readTVarIO . _thingy)
06:20:22 <lambdabot> (line 1, column 38):
06:20:23 <lambdabot> unexpected '_'
06:20:23 <lambdabot> expecting simple term
06:20:33 <hexagoxel> @pl f = (return . toList) =<< (readTVarIO . thingy)
06:20:34 <lambdabot> f = toList `fmap` (readTVarIO . thingy)
06:21:00 <hexagoxel> (somebody fix that parser, pls :D)
06:21:20 <hellertime> always falling into those type holds
06:21:21 <hellertime> holes
06:24:54 * hackagebot json-schema 0.7.1.0 - Types and type classes for defining JSON schemas.  http://hackage.haskell.org/package/json-schema-0.7.1.0 (AdamBergmark)
06:25:58 <macalimlim> hello :) what soap client lib would anyone recommend? :)
06:26:45 <myfreeweb> is soap still a thing? wow
06:27:06 <MrPopinjay> Innit.
06:28:06 <macalimlim> yeah unfortunately
06:28:10 <macalimlim> :D
06:28:44 <macalimlim> what soap client lib would you recommend?
06:33:02 <codygman> > filter isSpace "	test"
06:33:04 <lambdabot>  <hint>:1:17:
06:33:04 <lambdabot>      lexical error in string/character literal at character '\t'
06:33:11 <codygman> You can't put tabs in strings?
06:34:21 <macalimlim> hello :) what soap client library would anyone recommend?
06:34:54 * hackagebot esqueleto 2.1.2 - Type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-2.1.2 (FelipeLessa)
06:44:48 <hexagoxel> > filter isSpace "\ttest"
06:44:50 <lambdabot>  "\t"
06:46:00 <hexagoxel> codygman: must be escaped
06:54:55 * hackagebot ghc-datasize 0.1.2 - Determine the size of data structures in GHC's memory  http://hackage.haskell.org/package/ghc-datasize-0.1.2 (DennisFelsing)
06:56:50 <chirpsalot> So... You can create a set with non-ordered members... But that's kind of useless because then it has to be a singleton?
06:57:23 <phaazon> oh my
06:57:39 <phaazon> just discovered that my ~/dev was almost 7 Go big
06:57:46 <phaazon> because of cabal sandboxes
06:57:55 <chirpsalot> No, wait, you can make a set with unordered elements with fromAscList.
06:58:01 <phaazon> removed them all, gained 4 go back :D
06:58:29 <chirpsalot> http://hackage.haskell.org/package/containers-0.4.1.0/docs/Data-Set.html#g:9 <--- Shouldn't these have an Ord a constraint?
07:00:07 <chirpsalot> Nevermind, I guess you wouldn't be following the preconditions. Seems a bit awkward, though.
07:03:14 <k00mi> chirpsalot: those find* etc. functions don't need an Ord constraint because the internal structure determines which element is the largest/smallest, so no comparisons have to be performed
07:18:56 <albeit> The docs say "-T", measuring GC stats, incurs some overhead (and I would presume calling getGCStats does as well). How can I measure that overhead?
07:23:22 <chirpsalot> k00mi: I do understand that, but it just feels awkward not having the constraint when min / max isn't even defined unless you have an ordered type.
07:23:54 <chirpsalot> k00mi: it seems like putting the Ord constraint would help avoid any awkward super bad situations.
07:29:57 * hackagebot hblas 0.3.2.1 - Human friendly BLAS and Lapack bindings for Haskell.  http://hackage.haskell.org/package/hblas-0.3.2.1 (CarterSchonwald)
07:31:17 <nclarke> Is it possible to define a functor instance for a GADT with a constructor like Foo :: a -> Foo [a]?
07:31:23 <nclarke> As in this example: http://lpaste.net/113684
07:31:45 <nclarke> I feel it should be (e.g. it satisfies all the laws), but struggling to get it to work
07:33:09 <vanila> what goes wrong with that?
07:33:10 <mauketwork> I don't think it should be possible
07:33:25 <mauketwork> consider f :: [A] -> B
07:33:49 <nclarke> @vanila E.g. Could not deduce (a1 ~ [a1])
07:33:50 <lambdabot> Unknown command, try @list
07:34:01 <nclarke> vanila E.g. Could not deduce (a1 ~ [a1])
07:34:07 <mauketwork> then fmap f :: Foo [A] -> Foo B
07:34:28 <vanila> okay, so it's a type error
07:34:29 <mauketwork> a value of type Foo [A] would be Foo a with a :: A
07:34:48 <mauketwork> and then you can't apply f to a because f takes [A], not A
07:35:04 <vanila> would this typecheck? fmap f (Foo a) = Foo $ head (f [a])
07:35:07 <mauketwork> and the result type doesn't match either: Foo (f a) has type Foo [B], not Foo B
07:35:25 <vanila> this isn't a good implementation of functor but it might be interesting to try
07:35:27 <nclarke> mauketwork: Ah, indeed
07:35:40 <mauketwork> vanila: I don't think so; your implementation requires f to return a list
07:35:46 <mauketwork> and Functor needs to work for all result types
07:36:01 <nclarke> Thanks
07:36:04 <nshepperd> well, there's no point trying to define a functor instance unless the GADT's constructors cover all types
07:36:55 <prophile> nshepperd: is it possible if the GADT isn't inhabited?
07:37:04 <nclarke> nshepperd: In the actual case I care about, they do, just not in this toy example
07:37:44 <nshepperd> but in particular it seems like there's no natural behaviour for 'fmap (\[x] -> [x, x])' here
07:38:19 <nshepperd> taking (Foo . head) type checks but I feel like it probably breaks some law or other
07:39:34 <nclarke> No. Well, I mean, the real problem is that fmap :: Functor f => (a -> b) -> f a -> f b, whereas this would be (a -> b) -> f [a] -> f [b]
07:39:49 <nclarke> So in conclusion I don't know why I thought it should work :-)
07:40:08 <exio4> that soulds like fmap . fmap
07:40:36 <exio4> @type fmap . fmap
07:40:38 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
07:42:29 <nshepperd> prophile: good point. an uninhabited type can certainly have a functor instance since fmap only ever gets called on ⊥
07:44:29 <nshepperd> or is an "empty function" or something like that
07:45:31 <prophile> mysterious special cases
07:47:18 <nclarke> This is all related to my question earlier about optparse-applicative
07:47:53 <nclarke> I don't think it's possible to go from `Alt f` (the free alternative functor on f) to `Parser f`, because of the cheating that optparse does with many and some
07:48:03 <nclarke> So I think I need to delimit the many and some cases somehow
07:55:06 <chrisdone> codygman: ping
07:55:07 <gcganley> i was wondering what do you guys think haskell is NOT good for. What domains would another language be better suited for the job
07:56:05 <chrisdone> writing a kernel
07:56:29 <mmachenry> gcganley: One simple answer, which holds true for any high-level language, is that it's not possible to directly manipulate memory. So if you need to do real low-level stuff that perhaps manipluates video memory or CPU registers directly either for performance or for OS stuff it's not possible.
07:56:57 <mmachenry> gcganley: I basically just elaborately said what chrisdone said. :) I agree with him.
07:57:47 <nshepperd> demonstrating objected oriented programming :p
07:58:18 <mmachenry> nshepperd: Demonstrating Java. :)
07:58:32 <etandel> well, one could actually write a Java compiler in haskell
07:58:49 <gcganley> are there any java compilers in haskell?
07:59:41 <etandel> And one could write kernel in haskell by creating a haskell program that itself creates the kernel program
08:00:00 <chrisdone> that's not writing a kernel in haskell
08:00:15 <etandel> though it may not count as "good for".
08:00:38 <vanila> gcganley, I don't think so
08:00:39 <nshepperd> I'm not sure we're counting using haskell as an elaborate template language
08:00:43 <mmachenry> gcganley: You might argue that Haskell loses to bash in terms of writing one liners that compose several command-line tools together.
08:01:27 <etandel> nothing beats good ol' turing tarpit
08:02:07 <mmachenry> gcganley: For that matter, really short programs is niche that really open to languages grabbing a small portion of. Hard to beat Perl for a three-liner to grep and sed something.
08:03:04 <ddiaz> gcganley: exploratory data analysis, like Python's "pandas" library
08:03:56 <dbushenko> Hi all!
08:04:06 <dbushenko> can anyone explain me this kind of record: EHash <$> field <*> field
08:04:46 <dbushenko> I understand what is <$> and <*>, I just can't understand how they can be applied to something that does not implement Functor and Applicative functor
08:04:51 <albeit> When two infix operators have the same precedence in the same expression, why hasn't Haskell adopted some rule life the left-most takes precedence?
08:05:05 <nshepperd> lisp is arguably the best for programs eating other programs as input
08:05:45 <nshepperd> such as prisoner's dilemma or roshambo contestants
08:06:16 <S11001001> albeit: you mean, for infix ops that aren't infixl?
08:06:21 <nshepperd> (the "with visible source code" variants of the games)
08:06:47 <S11001001> albeit: I feel like that would defeat the purpose of the 'infix' fixity
08:07:36 <albeit> S11001001: Ah I didn't notice the error message said it was mixing infixl and infix... gotta learn more about that difference.
08:08:49 <S11001001> albeit: that is, if there should be a sensible application order of b and d in a `b` c `d` e, where b and d are infix n for some n, the problem is that b is included in the set of possible d, which would defeat the purpose of infix
08:09:29 <albeit> S11001001: What do you mean by "in the set of possible d"?
08:09:30 <S11001001> albeit: now, where a `b` c `d` e where b and d are infixl n for some n, always (a `b` c) `d` e.  And our rules include the case where b = d
08:09:36 <S11001001> albeit: which is why 1 + 2 + 3 works.
08:10:23 <S11001001> albeit: the set of possible d is all operators also declared infix with a precedence matching b's
08:10:30 <S11001001> albeit: or infixl in my second statement
08:10:42 <albeit> Ah okay I think I get it, because infix is non-associative and b and d are the same level (in the first example), it simply can't know how to proceed
08:10:50 <S11001001> albeit: aye
08:10:54 <albeit> Awesome thanks
08:13:03 <Ferdirand> couldn't the language be tweaked so that, for instance, infixr n figuratively means infixr (n - 0.5)
08:19:59 * hackagebot shell-conduit 4.4 - Write shell scripts with Conduit  http://hackage.haskell.org/package/shell-conduit-4.4 (ChrisDone)
08:21:52 <ptcek> how can I have non-exhaustive patterns with otherwise at the end?
08:23:07 <S11001001> ptcek: otherwise is a guard attached to a particular pattern, the one immediately preceding it as it happens, not a fallback pattern itself
08:23:19 <S11001001> ptcek: lpaste.net your code and I'll point out what your matches mean
08:24:35 <lpaste> ptcek pasted “non-exhaustive pattern” at http://lpaste.net/113690
08:25:51 <ptcek> sorry for not asking in #haskell-beginners (did not know about it until pasting)
08:26:39 <S11001001> ptcek: choose the first matching of: 1. if the second arg is a cons and tau == 0, do line 8; 2. if the second arg is a cons and tau <= tn, do line 9; 3. if the second arg is a cons, do line 10+11; 4. fail
08:27:10 <S11001001> ptcek: the immediately preceding pattern is the one that destructures the 2nd arg into (x:xs); the guards are associated with this pattern.
08:27:16 <fizbin> Hey, all, a silly preference question: If I have a module that performs string matching-related things, should I call it Foo.Stringmatch or Foo.StringMatch ?
08:27:32 <S11001001> ptcek: That way, your guards have access to the variables you got from pattern bindings, which makes the most sense lexically.
08:28:04 <albeit> fizbin: I'd personally prefer StringMatch
08:28:07 <kadoban> ptcek: Line 7 is a pattern that matches any list with a cons (:) in it. Aka, a list with at least one element. So those guards only apply to that, you have no pattern to match an empty list
08:28:15 <S11001001> ptcek: e.g. and [] = True; and (x:xs) | x == False = False; | otherwise = and xs
08:28:29 <S11001001> ptcek: this is a silly definition of and, but it makes sense that x is accessible in that guard, yes?
08:28:54 <ptcek> kadoban, S11001001: oh I see, thanks you
08:29:03 <ptcek> my second day :)
08:29:20 <kadoban> 'welcome. Have fun, haskell is good stuff :)
08:30:03 <fizbin> albeit: That is what I was leaning towards slightly.
08:39:16 <apo> S11001001: I still love " | True = False" :D
08:45:00 * hackagebot http-link-header 0.1.0 - A parser and writer for the HTTP Link header as specified in RFC 5988 "Web Linking".  http://hackage.haskell.org/package/http-link-header-0.1.0 (myfreeweb)
08:45:02 * hackagebot keter 1.3.5.1 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-1.3.5.1 (MichaelSnoyman)
08:45:26 <myfreeweb> yay, second library release ^^
08:47:51 <HugoDaniel> myfreeweb: congrats :)
08:50:00 * hackagebot parsestar 1.5 - NMR-STAR file format parser.  http://hackage.haskell.org/package/parsestar-1.5 (MichalGajda)
08:57:25 <Dongyancai> Hello, I'm trying to use ghc-vis, but I got the following error as: http://lpaste.net/113692, and the graphic output doesn't change. According to the error messange, an executable is missing, but how to find it out? I am using Gentoo Linux and ghc-vis is installed via portage.
08:59:37 <geekosaur> portage should have registered a dependency on graphviz
09:00:39 <geekosaur> if graphviz is installed then something may have a PATH issue, but again that points to portage having done something wrong
09:02:38 <Dongyancai> geekosaur: graphviz is already installed but there seems to be no executable belongs to this package. Is this expected?
09:03:11 <def-> Dongyancai: media-gfx/graphviz needs to be installed as well
09:03:12 <geekosaur> I have no idea, I don't use gentoo. maybe they split the executables out
09:04:38 <johnw> joe9: hi
09:07:36 <lericson> Dongyancai: i use gentoo and my graphviz package provides like 20 executables
09:07:37 <Dongyancai> def-: thank you very much! It is working now.
09:07:52 <Dongyancai> geekosaur: thank you
09:08:42 <Dongyancai> lericson: when I emerge -p graphviz and equry f, it gives me dev-haskell/graphviz instead of media-gfx/ one, so I saw no executable.
09:09:04 <Dongyancai> I'm reporting it to gentoo.
09:12:18 <lericson> well, mine certainly doesn't and it should warn you if it found ambiguous names
09:25:54 <gigabytes> hi all
09:26:03 <gigabytes> I'm trying to install ghc and cabal locally in my home directory
09:26:19 <gigabytes> on a linux system that I do not own, so I don't have root access to install anything systemwide
09:26:31 <ParahSailin_> i have lots of experience with that...
09:26:37 <gigabytes> the platform binary distribution seems to be only a tarball that unpacks into /
09:26:43 <gigabytes> and has a lot of hardcoded paths
09:26:53 <gigabytes> ParahSailin_: any help?
09:27:05 <gigabytes> I've installed ghc from the binary distribution from its website
09:27:08 <gigabytes> but know I miss cabal
09:27:25 <gigabytes> on the website there are only binaries for linux x86, but I'm on x86_64
09:32:34 <gigabytes> anybody?
09:33:52 <Rarrikins> gigabytes: Did you get the Haskell Platform (https://www.haskell.org/platform/)?
09:36:58 <ddiaz> gigabytes: Install it from source
09:37:03 <ddiaz>  curl -O http://www.haskell.org/cabal/release/cabal-install-1.20.0.3/cabal-install-1.20.0.3.tar.gz
09:37:15 <gigabytes> Rarrikins: yes, the binary package is not suitable for a local installation
09:37:27 <Rarrikins> Ahh, OK.
09:37:29 <gigabytes> ddiaz: but it requires cabal itself
09:37:36 <gigabytes> from what I've read, at least
09:38:57 <merijn> gigabytes: Are you referring to the GHC binary distribution?
09:39:19 <gigabytes> merijn: yes
09:39:26 <gigabytes> the binrary ghc distribution is working
09:39:27 <merijn> Because the GHC binary distribution works perfectly fine for local installs
09:39:32 <wz1000> Why doesn't liftM (take 1) $ sequence (repeat getLine) not stop after taking one line?
09:39:40 <gigabytes> merijn: no I was talking about haskell platform
09:39:43 <gigabytes> ghc works, yes
09:39:46 <gigabytes> but now I need cabal
09:39:58 <gigabytes> and the binary distribution is only for linux x86
09:40:03 <gigabytes> I'm on x86_64
09:40:11 <merijn> gigabytes: You can simply build cabal from source
09:40:20 <merijn> gigabytes: It's pretty easy, instructions are in the readme
09:40:24 <ddiaz> gigabytes: I have this script that compiles GHC and Cabal from source: https://gist.github.com/danidiaz/09b5120d6cbe36187805
09:40:28 <ddiaz> Among other things.
09:40:30 <merijn> It's like 2 or so commands
09:40:30 <gigabytes> merijn: yes, I'll try
09:40:35 <ddiaz> Perhaps you could adapt it.
09:40:45 <gigabytes> I've read somewhere that cabal needs another version of cabal to bootstrap itself
09:40:51 <merijn> gigabytes: Nope
09:40:58 <gigabytes> but it seems it's not true
09:40:59 <gigabytes> ok
09:41:03 <merijn> gigabytes: It just means you can't use "cabal install cabal-install"
09:41:32 <merijn> gigabytes: But cabal ships with a Setup.hs that links against the Cabal library (which ships with GHC)
09:41:50 <Hijiri> wz1000, IO isn't lazy (except when it is)
09:42:09 <merijn> afaik you should be able to just to "ghc Setup.hs && ./Setup install", but check README for details
09:42:22 <gigabytes> merijn: so how do I tell the cabal installation where to find the cabal library provided by ghc?
09:42:23 <wz1000> Hijiri: So what should I do instead?
09:42:41 <gigabytes> anyway, I'm stuck with gmp lacking
09:42:46 <merijn> gigabytes: You don't have to, cabal doesn't track installed libraries, ghc does. Cabal just queries GHC for which libraries are installed
09:42:55 <gigabytes> merijn: ok
09:42:57 <gigabytes> I'll have to install that locally first
09:43:03 <gigabytes> or ask the admin to install that at least
09:43:24 <Hijiri> Explicitly just get the first line and the first character of that, or use some stream processing library like pipes or conduit
09:43:29 <wz1000> Hijiri: It was actually supposed to be a takeWhile, but I simplified it a bit
09:43:58 <Hijiri> Explicitly just get the first line and the first character of that, or use some stream processing library like pipes or conduit
09:44:00 <Hijiri> sorry, lost connection
09:44:34 <wz1000> Hijiri: It was actually supposed to be a takeWhile, but I simplified it a bit
09:45:03 <Hijiri> The two options I see is doing an explicit loop or using a stream processing library then
09:45:09 <Hijiri> another option is lazy IO with getContents
09:45:18 <Hijiri> but that leads to bad things sometimes
09:45:37 <Hijiri> If you use lazy IO you can get IO exceptions in "pure" code, which makes it not pure anymore
09:46:12 <wz1000> With getContents, if I only read the first n lines of input, will I normally be able to read the rest?
09:46:50 <wz1000> s/normally be able to/be able to normally/g
09:46:54 <Hijiri> I think so, but I don't know for sure
09:47:25 <albeit> What's the best way to empty a Control.Concurrent.Chan? I'm currently doing readChan until isEmptyChan, but isEmptyChan is deprecated
09:49:14 <dcoutts_> albeit: you can use an STM channel
09:49:54 <albeit> dcoutts_: Is an STM channel any slower? I only need to empty it when testing, not in production, so I don't want to slow it down just for testing
09:49:57 <sclv> albeit: if you're using your chan in a single-threaded context at the point yr emptying it, it should be ok
09:49:57 <dcoutts_> albeit: I don't recall for sure, but I think the isEmptyChan deprecation issue is only about a problem that can happen when you also use dupChan
09:50:21 <sclv> @remember barsoap There's no place for half measures in overkill.
09:50:21 <lambdabot> I will never forget.
09:50:25 <dcoutts_> albeit: STM is not actually slow, surprisingly
09:50:29 <albeit> sclv: Ah yes I am, good
09:50:55 <johnw> albeit: it really depends on your usage patterns, but the general case seems to be well performing
09:51:38 <albeit> johnw: Using chan's for message passing between modules running on their own threads
09:51:43 <dcoutts_> albeit: and there's more perf differences in other aspects of channels, like whether you've got a single reader, multiple writers, or single writer etc
09:51:52 <dcoutts_> albeit: or don't need the dup feature
09:52:02 <johnw> albeit: STM degrades if you have many readers and one or more really active writers
09:52:05 <dcoutts_> there are more specialised and higher performance ones for those cases
09:52:09 <albeit> dcoutts_: All single reader, single writer, no need for dup
09:52:14 <dcoutts_> that make much more difference than MVar vs STM
09:52:24 <merijn> dcoutts_: No, isEmptyChan is due to TOCTOU races
09:52:38 <albeit> dcoutts_: Actually that's wrong... all single reader, some are multiple writers
09:52:51 <dcoutts_> merijn: I don't think so
09:53:08 <dcoutts_> merijn: that issue is obvious from the api, that's always been there
09:53:29 <dcoutts_> it was an actual failure, like deadlock or something in some corner case
09:53:32 <merijn> dcoutts_: Well, regardless of the reason, it IS susceptible to TOCTOU races, so people probably shouldn't use it :)
09:53:53 <dcoutts_> sure, but as you say it's fine for single reader in principle
09:54:03 <merijn> albeit: It depends on the frequency of writing
09:54:22 <merijn> albeit: Basically, STM becomes more expensive as the likelihood of aborted transactions increases
09:54:55 <albeit> merijn: Well, the vast majority of the chans will be written very infrequently, but one is going to be written potentially thousands of times a second
09:55:01 <merijn> albeit: Which is correlated to how often updates happen during a transaction. Therefore longer transactions and more frequent updates are expensive, but short transactions and rare updates are cheap
09:55:03 <albeit> (By the same writer)
09:55:07 <dcoutts_> albeit: iirc, then you want the two vars, queue reversal style
09:55:19 <gigabytes> hijacking your conversation: is there some monad alternative to STM and IO which provides thread-safe multable vars by simply locking them appropriately?
09:55:30 <dcoutts_> albeit: if you really really care about the performance at that level
09:55:30 <merijn> gigabytes: Yes, IO
09:55:43 <gigabytes> merijn: IO MVars are thread-safe?
09:55:50 <merijn> gigabytes: Yes
09:55:54 <merijn> gigabytes: IORef too
09:56:10 <gigabytes> merijn: oh good, didn't know that (never did anything concurrent in haskell)
09:56:11 <merijn> gigabytes: Well, threadsafe in the "all updates happen atomically", sense
09:56:17 <gigabytes> merijn: yes
09:56:18 <albeit> dcoutts_: Queue reversal style? Ie for A writing to B have one Chan, and for B writing to A have another Chan?
09:56:41 <merijn> gigabytes: You just can't do "atomic composite operations"
09:57:03 <dcoutts_> albeit: no, a queue based on the classic list reversal queue data structure, but with the list front and end in different vars (MVar or STVar)
09:57:23 <dcoutts_> albeit: but you don't want to write your own
09:58:11 <albeit> dcoutts_: Okay. Are there any pre-existing Haskell libraries that implement that?
09:58:17 <merijn> gigabytes: It's one of the reasons why basic concurrency is fairly easy in haskell :)
09:58:22 <monochrom> TChan is the classic list reversal queue :)
09:58:29 <merijn> monochrom: *bzzt*
09:58:41 <merijn> The classic list reversal queue is TQueue
09:58:49 <merijn> TChan is a direct reimplementation of Chan using TVar
09:58:49 <monochrom> oh oops, TQueue
09:58:52 <merijn> :)
09:59:02 <dreams> I have a function foo f x y = f x y. I want to pass it (:) 1 2 then the do : [] to the returned function but failed. so (foo (:) 1 2) : []  isn't working. any suggestion?
09:59:22 <gigabytes> merijn: yes :P is there something similar to atomic data types?
09:59:29 <merijn> dreams: Well, of course it doesn't work
09:59:37 <merijn> dreams: (:) needs a list as second argument
09:59:39 <gigabytes> merijn: I come from C++ and there are a lot of uses for std::atomic<int>, for example, in lock-free datastructures
09:59:41 <dcoutts_> albeit: ah nice, the stm package has it now
09:59:42 <dcoutts_> http://hackage.haskell.org/package/stm-2.4.3/docs/Control-Concurrent-STM-TQueue.html
09:59:44 <dreams> merijn: oh
09:59:47 <merijn> dreams: 2 is not a list
09:59:57 <dreams> merijn: ah ok. let me try something.
10:00:17 <albeit> So looking at TQueue, I should use it over Chan/TChan when there are many writes/reads? But for infrequent writes/reads, TChan may be better?
10:00:25 <dreams> merijn: got it thanks.
10:00:43 <merijn> gigabytes: Well, it depends on how performance critical, the naive way would be "IORef Int", but that's still rather costly, since it IORef's lock, etc.
10:01:24 <albeit> It says TQueue "throughput is faster than TChan [but the costs are amortised]"... what does that mean exactly?
10:01:27 <johnw> albeit: if you don't need "dup", don't use TChan
10:01:36 <gigabytes> merijn: yes, the point of std::atomic<> in C++ is to not use locks, but nativ atomic CPU instructions.That's why it works only on integer types of course
10:01:39 <merijn> gigabytes: GHC recently got CAS primops and we're starting to get libraries that simplify using them, so you can in fact use true machine level CAS if you're willing to suffer through the low level pain :)
10:01:40 <albeit> (I get amortised, but how does that affect throughput?)
10:01:59 <gigabytes> merijn: interesting, can you point me to a link?
10:02:12 <monochrom> TQueue has lower overhead than TChan
10:02:48 <merijn> gigabytes: See for example http://hackage.haskell.org/package/atomic-primops
10:02:59 <gigabytes> thanks
10:03:46 <monochrom> hmm, what is throughput? you measure throughput by observing a sample time window and how much data is processed during that window, right?
10:04:14 <merijn> gigabytes: This stuff is fairly new, so right now you end up needing to use some fairly low level GHC specific stuff to be able to use, so documentation is a bit limited, but that will improve with time
10:05:30 <monochrom> amortization will mean that if your sample window is short, then you can be unlucky and see an instance of little data processed because you hit upon a time-consuming operation
10:05:57 <ParahSailin_> gigabytes: do ./configure --prefix=$HOME
10:06:12 <albeit> monochrom: Ah okay, so over a long enough time period, the throughput for TQueue should exceed TChan
10:06:33 <gigabytes> ParahSailin_: that's for ghc, I've already done that. The Haskell Platform distribution was the one that I was complaining about
10:06:34 <merijn> gigabytes: Additionally, you can check out the ghc-prim documentation (not on hackage, you'll need to check the local documentation installed by GHC)
10:06:50 <ParahSailin_> gigabytes: ah, dont bother with platform
10:07:09 <merijn> gigabytes: FYI, once you have cabal + ghc platform isn't strictly necessary. You can just install individual libraries you need for your user local install
10:07:11 <ParahSailin_> just install ghc, then install cabal-install from source
10:07:44 <gigabytes> merijn: ok
10:07:52 <ParahSailin_> the platform is primarily there for windows where it is hard to build shit
10:07:54 <merijn> gigabytes: GHC.Prim (in addition to atomics) also exposes SIMD vector operation and prefetching intrinsics, for all your masochistic low level needs :)
10:08:15 <gigabytes> merijn: eheh
10:08:21 <ParahSailin_> merijn: carter did all that?
10:08:23 <gigabytes> merijn: does GHC do autovectorization?
10:08:38 <carter> gigabytes: SIMD is useless
10:08:40 <carter> i didn't do the simd
10:08:42 <gigabytes> on Vectors for example
10:08:44 <merijn> gigabytes: I don't think so, although the LLVM backend might
10:08:54 <carter> dnot use the simd ops till ~ 7.12
10:08:56 <carter> they're uselss
10:09:05 <carter> as is
10:09:12 <merijn> carter: How come?
10:09:14 <int-e> carter: oh you mean the primops?
10:09:16 <carter> yeah
10:09:22 <carter> merijn: try using them in NCG :)
10:09:24 <carter> you'll see
10:09:24 <int-e> I guess there's too much overhead around to make them worthwhile
10:09:26 <carter> merijn: also no shuffles
10:09:32 <gigabytes> merijn: yes, LLVM has a good vectorizer, but the front-end has to let the vectorizer go, and generate the bytecode in the right way
10:09:52 <gigabytes> merijn: but I'm wondering how could ghc do that at all with, e.g. lists
10:10:01 <gigabytes> zipWith (+) list1 list2
10:10:09 <gigabytes> should be vectorized
10:10:14 <merijn> carter: Ok, rephrase: Is there any reason beyond "the implementation isn't ready yet"?
10:10:15 <gigabytes> but lists are not arrays
10:10:17 <albeit> Is the proper way to write multiple values to a TQueue to collect the multiple writeTQueue calls into a single STM () and then call atomically on it?
10:10:23 <carter> merijn: the design is wrong
10:10:26 <carter> no shuffles
10:10:37 <merijn> gigabytes: I don't think that'll get vectorised for a number of reasons
10:10:54 <carter> lists will  never get  vectorized
10:10:57 <gigabytes> merijn: I'm afraid you're right
10:11:01 <carter> unless you mean memory buffers instead of lists
10:11:06 <carter> liek unboxed/storable vectors
10:11:23 <merijn> gigabytes: But haskell offers quite extensive tools for libraries to influence how GHC generates code for them, so writing a library like vector in a way that it'll use vectorisation internally should be possible
10:12:30 <gigabytes> merijn: so it's too early to see Haskell vs Fortran debates :P
10:13:05 <gigabytes> I'm having difficulty convincing people at the electrical engineering department to use C++ instead of Fortran
10:13:07 <int-e> are peple still using fortran because "it's faster than C"?
10:13:07 <gigabytes> oh my
10:13:07 <merijn> gigabytes: Anyway, this stuff is still rather experimental, but there's plenty of interest to add this sort of thing to GHC so we can use haskell for even more performance critical code ;)
10:13:16 <merijn> int-e: Yes
10:13:18 <merijn> int-e: Because it is
10:13:29 <merijn> C is a terrible high performance language
10:13:34 <gigabytes> merijn: it's faster than C
10:13:43 <gigabytes> but C++ can be faster than both if used correctly
10:13:46 <gigabytes> with the right compiler
10:14:16 <merijn> int-e: Aliasing is an impossibly hard problem and without solving that it's insanely hard to auto vectorise/parallelise code
10:14:17 <gigabytes> I'm in the business of eradicating fortran from the earth
10:14:40 <gigabytes> </utopy>
10:15:47 <vanila> what's wrong with fortran?
10:16:16 <int-e> merijn: hmm, 'restrict' was supposed to help with that...
10:16:38 <carter> merijn: int-e  gigabytes  you're all wong, the real answer will be adding inline asm support to ghc
10:16:47 <carter> i've plans
10:16:49 <carter> mwahahahahahhah
10:17:01 <carter> merijn: aliasin isn't hard for haskell
10:17:04 <int-e> carter: I won't hold my breath
10:17:07 <carter> int-e: lol
10:17:15 <gigabytes> carter: and raw pointers, and classes and inheritance :P
10:17:16 <carter> int-e: i've actually worked out a design for it
10:17:19 <gigabytes> ahah
10:17:20 <carter> gigabytes: we have pointers
10:17:26 <gigabytes> I know
10:17:40 <carter> for blas DGEMM, you NEED asm to hit peak flops
10:17:48 <carter> though ffi wrapping it should be easy to do too
10:17:49 <carter> :)
10:18:06 <carter> anyways, g2g
10:18:11 <int-e> carter: inline CMM would be a good start.
10:18:55 <gigabytes> thanks guys
10:18:57 <gigabytes> bye
10:18:59 <int-e> just imagine using that for all primops with <5 lines that are currently defined externally (in PrimOps.cmm)
10:20:32 <joe9> With the pause monad here, http://stackoverflow.com/questions/10236953/the-pause-monad, any suggestions on how to implement a fork there?
10:21:10 <merijn> carter: When did I say it was hard for haskell?
10:21:23 <merijn> carter: I was just pointing out that C is terrible for high performance due to aliasing
10:21:25 <albeit> How much overhead is there when compiled with "+RTS -T" and then calling getGCStats?
10:25:58 <dv-> you can tell gcc that two pointers don't alias
10:27:52 <SlackMoehrle> Hello All, I'm trying to compile haskell platform on Amazon AWS and I'm getting a compiler error in haskell-src that I cannot figure out. Can anyone take a look?
10:28:29 <SlackMoehrle> Here is the error: http://stackoverflow.com/questions/26717507/error-compiling-haskell-src-1-0-1-4-on-aws#26717507
10:28:59 <merijn> dv-: Yes, but that means you as a programmer have to verify that they don't, figure out where to annotate, etc.
10:29:10 <merijn> dv-: How many people can do that without messing up?
10:29:32 <tommd> SlackMoehrle: That package is four years old.  How about you try the new version (1.0.1.6)?
10:29:57 <tommd> @hackage haskell-src
10:29:57 <tommd> Darn bots.
10:29:57 <lambdabot> http://hackage.haskell.org/package/haskell-src
10:30:00 <geekosaur> they're installing an older version of the platform, presumably they need that version for some reason
10:30:40 <tommd> Possible.  I find that people who install the platform don't usually have a particular need, they just don't know better.
10:31:02 <SlackMoehrle> ok, let me try. I was following this: http://jpmoresmau.blogspot.com/2011/04/install-ghc7-and-yesod-on-amazon-linux.html
10:31:43 <SlackMoehrle> I was following it because it was only the resources I could find that talked about AWS as there are no other ways to get it in binary for Pandoc
10:34:21 <tommd> SlackMoehrle: Either way, that module has been incorrectly mutilated.  All those numbers at the end are purely junk - the package on hackage certainly doesn't have such a line.
10:34:57 <SlackMoehrle> where is the latest haskell-platform?
10:37:13 <SlackMoehrle> ok, I think I found it
10:43:28 <myfreeweb> the freebsd port for ghc still has a hard dependency on gcc and llvm isn't even on by default? is llvm support in ghc not ready yet?
10:43:41 <SlackMoehrle> so I downloaded the source and run ./platform.sh and it needs cabal. This was the whole reson I was copiling from source as AWS doesn't have cabal. If I had cabal I could install Pandoc I think.
10:44:19 <schell> how do you check for NaN?
10:44:34 <schell> nvm!
10:44:36 <jhance> myfreeweb: llvm support in ghc is ready.
10:44:37 <schell> isNaN
10:45:04 <MagneticDuck> I'm trying to figure out how to make a cabal package that compiles with haste
10:45:19 <MagneticDuck> for some reason it seems like haste-inst is failing with an error from cabal, to begin my list of problems
10:45:37 <MagneticDuck> "unrecognized command: --with-compiler:..."
10:45:46 <MagneticDuck> anybody here use haste?
10:50:46 <egasimus> let's try over here as well -- http://lpaste.net/113699
10:52:49 <lpaste> egasimus revised “how do i shot web^W^Wmodify layout”: “updated” at http://lpaste.net/113699
10:53:15 <egasimus> added an actual description of my question, so, uh, yeah
11:12:16 <Kaini> egasimus: I guess you want "forall b. EqualSpacing a -> Maybe (Stack b) -> Int" and enable RankNTypes
11:12:22 <Kaini> (Or add b as type parameter to the type itself)
11:13:22 <geekosaur> won't work here
11:13:34 <Kaini> Huh?
11:13:57 <geekosaur> we're discussing it in #xmonad, while that will "fix" *that* error it just renders the Stack b inaccessible/unusable
11:14:48 <geekosaur> the only thing you can do with it is take its length, in which case the caller should do that and pass the length. (which is what the original code did...)
11:14:51 <Kaini> Yeah, I guess thats true, but you could still use Stack functions that do not operate on it's elements
11:14:59 <Kaini> ah ok
11:15:01 <geekosaur> there aren't any
11:15:05 <Kaini> I see
11:15:06 * hackagebot extra 0.7 - Extra functions I use.  http://hackage.haskell.org/package/extra-0.7 (NeilMitchell)
11:16:13 <geekosaur> basically the only way to get something useful is to have access to the type of which Stack is a component (a StackSet), and there's no way to get at the StackSet in question from there
11:16:23 <geekosaur> which is also why there's no way to assign a useful type to b
11:24:00 <pdxleif> Could someone make a kids book I could read to my daughter that teaches Haskell? Maybe along the lines of lambdacats, e.g. http://spl.smugmug.com/Humor/Lambdacats/i-4TGvqCj
11:24:16 <pdxleif> Like there could be a rabbit that keeps cons'ing a carrot onto everyone's lists...
11:25:28 <ReinH> pdxleif: that would be awesome
11:25:41 <xyh> pdxleif: the little schemer is that book
11:25:59 <kini> I'm wondering, how impossible would it be to write something like gdb in haskell?
11:26:17 <mauke> see also: to mock a mockingbird, alligator calculus
11:26:30 <ReinH> To mock a mockingbird is great
11:26:57 <kini> or, to make things simpler, a program that can step through a binary, break at breakpoints, and read registers and/or memory values
11:26:59 <pdxleif> oh yeah, thanks!
11:27:03 <kini> (doesn't need to know anything about C in particular)
11:27:19 <kini> is Haskell "not low level enough" to do something like that directly?
11:27:20 <mauke> probably 100% possible but super annoying
11:27:34 <mauke> because ptrace() sucks
11:27:36 <xyh> pdxleif: you mean ``the little schemer'' ?
11:28:10 <kini> thanks for the keyword "ptrace" :)
11:28:35 <clrnd> /helojito/dist/build/libHShelojito-0.2.a(Helojito.o):(.text+0x203): undefined reference to `helojitozm0zi2_WebziHelojitoziTaskType_zdfEndpointTaskTypeListIdTaskTypeList1_closure'
11:28:36 <josephle> xyh: or the more obscure "the little MLer"" :)
11:28:48 <pdxleif> xyh: I wasn't famliar w/ that - I'll look into it though - thanks!  Was reminded of "to mock a mockingbird" and the alligator calculus, which I'd forgotten about
11:28:59 <clrnd> never seen that error before, it's thrown by the linker after cabal build, what the hell!
11:29:55 <pdxleif> Was reading my daughter a book last night and the rabbit kept adding a carrot something (e.g. carrot sandwich to a collection of sanwiches) to everyone else's collection of stuff for some reason
11:30:08 <pdxleif> Had me thinking of lambdacats stuff
11:30:57 <pdxleif> Maybe I should write something, myself.  Perhaps I could even learn some illustration, or find someone who can
11:30:58 <kini> clrnd: sounds like possible a question for #ghc, I don't think linker errors are supposed to happen regardless of how wrong your own code may be
11:31:30 <kini> hm, on the other hand the channel topic in #ghc says "user questions go in #haskell", so I'm not sure...
11:33:57 <ClaudiusMaximus> clrnd: make sure all the modules are listed in the cabal file, either in exposed-modules: or other-modules: - nonlisted modules give that kind of linker error
11:34:10 <benzrf> #ghc is more like #ghc-dev, i think
11:34:30 <clrnd> ClaudiusMaximus, yeah I can't find any, if this works as I suppose it does :P
11:34:53 <clrnd> I'm exposing a module that import and exports inner modules that the executable uses
11:35:01 <clrnd> but I'm always referencing the exposed module ...
11:36:59 <clrnd> GRR DAMN it seems all modules need to be in other-modules
11:37:31 <pdxleif> clrnd: Someone had a linker error installing idris the other day; think they said it was a bad GHC install or something. It was on the mailing list
11:37:56 <clrnd> I fixed it, notice tht the lib is complaining about itself
11:38:07 <clrnd> thanks
11:38:32 <clrnd> tl;dr; the lib had modules not listed in other-modules
11:39:10 <Cale> kini: No, linker errors absolutely can happen if you forget to specify package dependencies
11:39:21 <kini> Cale: oh :o
11:39:46 <Cale> It's unfortunate that they're quite unreadable
11:39:52 <kini> yes...
11:46:13 <pharpend> Hey, guys
11:46:26 <pharpend> I have some software that I'm publishing under the AGPL
11:46:55 <benzrf> cooool
11:47:00 <pharpend> since it's a well-known license, is it sufficent to just put "License: AGPL-3" in the haddock header? Or should I do the thing the AGPL says
11:47:12 <dfeuer> pharaun, what is AGPL-3?
11:47:15 <pharpend> and print out the whole "This is free software blah blah" thing
11:47:22 <dfeuer> er .... pharpend, I mean.
11:47:24 <pharpend> dfeuer: it's the GPL with one additional clause
11:47:32 <dfeuer> What's the extra clause?
11:47:38 <pharpend> dfeuer: you can't serve the program and not give the source code out
11:47:57 <pharpend> so, someone couldn't make my program into an IRC bot and then refuse to divulge the source
11:48:09 <pharpend> It's a loophole in the normal GPL
11:48:31 <pharpend> You can link AGPL code with GPL code
11:48:34 <pharpend> they are compatible
11:48:46 <dfeuer> Ah.
11:48:47 <Cale> Is that kind of restriction even possible to apply via copyright?
11:48:47 <pharpend> but you can't take an AGPL program and relicense it
11:48:58 <dfeuer> Cale, yes.
11:49:00 <pharpend> Cale: yes, supposedly
11:49:13 <Cale> It seems weird
11:49:17 <danking_> Has it been argued in court before?
11:50:10 <Cale> It's like one of those things which EULAs ask for, but which probably wouldn't stand up to scrutiny
11:50:17 <pharpend> good point
11:50:20 <pharpend> hmm
11:50:34 <qsuscs> unregisterised GHC is … funny.
11:50:38 <pharpend> You know, I'm not really gung-ho about the whole "software freedom" schtick the FSF has
11:50:45 <qsuscs> input: main = putStrLn "Hello."; output: http://pastie.org/private/2vaudvnqh3wcqdgp2fsxjg
11:50:47 <pharpend> I see their point, I just think they are crazy
11:50:54 <qsuscs> (after a bit of indentation post processing)
11:51:09 <benmachine> I don't think they are crazy but I don't care about my software enough to protect it :P
11:51:13 <dfeuer> I agree that they're crazy, and their licenses are incompatible with most other projects, which is a practical PITA.
11:51:17 <monochrom> there is also a lot of "IANAL but I think" in these conversations
11:51:21 <benmachine> yes
11:51:31 <pharpend> HMM, maybe I should just stick to the BSD license
11:51:32 <benmachine> it sounds to me like pharpend's question is not a Haskell question
11:51:36 <pharpend> yeah
11:51:40 <pharpend> well, it is, sort of
11:51:45 <benmachine> which is fine except that it means there's no specific expertise here
11:51:59 <benmachine> unless you get lucky and someone's secretly a licensing expert
11:51:59 <pharpend> Haddock has a header thing that you are supposed to put at the top of library files
11:52:19 <pharpend> i'm wondering if that's sufficient for the GPL requirement
11:52:20 <monochrom> to a large extent, I think even the lawyers haven't figured it out, but IANAL :)
11:52:25 <pharpend> haha
11:52:38 <dfeuer> BSD, MIT, and CC-SA generally seem reasonably compatible with other things.
11:52:47 <qsuscs> (why do i read this as “I ANAL” … Q_Q)
11:53:01 <benmachine> I'd ask my friend but she'd probably say I am a lawyer but not that sort of lawyer
11:53:02 <nkar> pharpend: try #fsf
11:53:03 <monochrom> "I am not a lawyer"
11:53:05 <benmachine> IAALBNTSOL
11:53:07 <pharpend> nkar: sure
11:53:15 <pharpend> benmachine: i give up, what is that
11:53:26 <benmachine> pharpend: foreshadowed by my previous remark
11:53:41 <monochrom> "I am a lawyer but not that sort of lawyer"
11:53:44 <pharpend> ah
11:53:57 <monochrom> . o O ( why are my fingers trying to type "layer"? )
11:54:51 <Clint> pharpend: it is never legitimate to just use a license abbreviation and expect other people to know exactly which license you mean
11:55:41 <pharpend> Clint: ah, okay
11:56:34 <Clint> even moreso if it's a fill-in-the-blank license like bsd-alikes
11:57:39 <pharpend> ah okay
11:57:56 <pharpend> the BSD license is somewhat of a joke, so I don't really care if people infringe upon it
11:59:30 <qsuscs> i use ISC for my stuff
11:59:45 <qsuscs> because i’m still too lazy to read a ton of lawyer’s english aka GPL
12:02:32 <pharpend> MIT license, BSD2, ISC, all pretty much the same
12:02:45 <pharpend> Apache is (I'm told) similar to BSD, but in legalese
12:03:41 <qsuscs> ISC is MIT in readable english
12:09:36 <qsuscs> why do these fail to build? http://pastie.org/private/y5usc0vbf2fydsjhn3xlww
12:09:38 <kadoban> qsuscs: Da hell? Isn't MIT license like 50 words long and not even legalese?
12:09:51 <qsuscs> kadoban: and ISC is even simpler
12:10:01 <qsuscs> (a bit)
12:10:27 <kadoban> I see
12:10:50 <EvanR> need a license, forbidden to use this code except to exploit the authors work for monetary gain without compensating him
12:11:59 <pharpend> um
12:12:19 <pharpend> write your own
12:12:28 <pharpend> a lawyer will probably use it against you
12:12:57 <qsuscs> i’m trying to build this http://sourceforge.net/p/parallelweb/code/
12:13:03 <EvanR> need a license, forbidden to be analyzed and used in any way by any lawyer
12:13:16 <qsuscs> (the “saksell” program in that project)
12:13:24 <EvanR> laymen only
12:13:33 <pharpend> haha
12:13:41 <pharpend> you might have to have a lawyer write that
12:14:14 <benmachine> they can write it, they just can't read it
12:14:31 <benmachine> an append-only licence
12:14:53 <EvanR> lawyer > /dev/null
12:15:08 * hackagebot hscope 0.4.1 - cscope like browser for Haskell code  http://hackage.haskell.org/package/hscope-0.4.1 (BorisSukholitko)
12:15:10 * hackagebot fixtime 1.5.0.2 - Some fixes to the time package  http://hackage.haskell.org/package/fixtime-1.5.0.2 (pharpend)
12:17:01 <seveg> hey guys, can someone explain to me why there are parenthesis in 'in' line of the first solution https://www.haskell.org/haskellwiki/99_questions/Solutions/9 ?
12:17:33 <pharpend> seveg: readability
12:17:42 <seveg> i asume parenthesis on the 'let' line are there because span returns tuple
12:17:52 <benmachine> seveg: (x:first) : pack rest is different from x:first : pack rest
12:17:59 <benmachine> the latter is x:(first : pack rest)
12:18:23 <benmachine> (x:first) : pack rest is the list 'pack rest' with one element, 'x:first', put on the beginning
12:18:42 <benmachine> whereas x:(first : pack rest) is 'pack rest' with two elements, 'x' and 'first', on the beginning
12:19:12 <seveg> benmachine: thanks .)
12:23:07 <seveg> benmachine: since first is a list, shouldn't this also work: (1:[2,3]):[4,5] ?
12:25:10 <benmachine> seveg: no, pack rest must be a list of lists
12:25:35 <seveg> oh, right
12:25:36 <benmachine> if you are putting (1:[2,3]) into a list, you must be putting it into a list of lists
12:25:48 <seveg> benmachine: yeah i got it
12:25:53 <seveg> benmachine: thanks again
12:25:59 <seveg> benmachine: .)
12:26:15 <benmachine> are you winking at me
12:26:20 <benmachine> because that's kind of weird
12:26:35 <seveg> benmachine: looks like i am
12:26:41 <seveg> benmachine: sorry
12:26:43 <seveg> benmachine: .)
12:26:53 <pharpend> haha
12:28:11 <dbushenko> I have a cabal sandbox and want to start an interpreter inside it
12:28:25 <dbushenko> but when I import a module, the interpreter can't find it
12:28:32 <malllle> cabal repl?
12:28:39 <dbushenko> ahem.. no...
12:28:44 <dbushenko> let me try..
12:29:44 <dbushenko> malllle, thanks, it was helpful!
12:38:19 <osa1> is there a way to remove a package from hackage?
12:40:09 <benmachine> osa1: you can deprecate them
12:40:17 <benmachine> but they aren't typically removed
12:41:03 <osa1> what happens when I deprecate them? there is a package of mine which confuses people.
12:41:56 <benmachine> osa1: sec, I'll find an example
12:42:13 <benmachine> osa1: http://hackage.haskell.org/package/MaybeT-monads-tf
12:42:30 <benmachine> I think there are other effects, like cabal avoids it or something, but I forget the details
12:42:43 <osa1> thanks
12:49:45 <pharaun> that was the first time i got an errant ping in here :)
12:51:26 * edwardk pings pharaun.
12:51:59 * edwardk sets up a bot to do it regularly lest pharaun get lonely.
12:52:50 <pharaun> XD thanks edwardk
12:52:58 <guest123> Does anyone understand Cabal? I'm trying to compile rounded, and something changed 1.18 => 1.20, so that it now expects LocalBuildInfo instead of ConfiguredProgram in createArLibArchive. What are those?
12:53:12 <edwardk> on the other hand its too easy to retaliate. i made the mistake of setting up 'lens' to ping my client years ago when they weren't popular
12:53:47 <edwardk> guest123: i'm not sure if rounded will build all that well on anything at the moment
12:54:20 <edwardk> guest123: we're kinda waiting until hvr can rewrite all the GMP bindings for GHC to avoid needing the custom GC hook, when we get that rounded can go from nigh impossible to easy to install
12:56:07 <guest123> edwardk: I got hmpfr set up already with a separate ghc version, but then I noticed rounded. Are you saying it's definitely *not* possible to build it?
12:57:27 <albeit> Is this a correct interpretation of how a TQueue works? Write values by append to a "write" list. Read values from the start of the "read" list. If "read" list is null, make "read" list the reversed "write" list.
13:00:21 <kadoban> albeit: I'm not sure what you mean by TQueue, but that's pretty close to a well known purely functional data queue implementation. You "append" by using cons though (:)
13:00:33 <kadoban> Which is probably what you meant, but just making sure.
13:01:07 <albeit> kadoban: Ah great, yeah I was referring to Control.Concurrent.STM.TQueue
13:02:23 <kadoban> albeit: Certainly sounds like it from the small blurb at the top of the docs
13:03:49 <albeit> And just hoping for an answer, but is TQueue considered higher throughput than TChan/Chan because while it will occasionally needs to reverse a list, it doesnt suffer the overhead of reading/writing multiple M/TVars for every read/write?
13:04:43 <cdk> Can monad/functor laws simplify this function: \f -> fmap sequence . sequence . fmap f
13:05:11 <cdk> :t \f -> liftM sequence . sequence . liftM f
13:05:12 <lambdabot> (Monad m1, Monad m) => (a1 -> m (m1 a)) -> [a1] -> m (m1 [a])
13:05:45 <edwardk> guest123: well, i'm saying we got it to build earlier this year on a mac, post 7.8 but before cabal updated, and haven't been actively working on it since
13:06:13 <edwardk> guest123: because hvr started working on better GMP bindings, and we decided it was much less pain to just wait until those didn't sucks
13:06:14 <edwardk> er suck
13:06:27 <edwardk> because right now we have to bury in a copy of mpfr into the executable
13:06:50 <edwardk> hmpfr requires integer-simple, which is a collossal pain in the neck and not viable for most real world scenarios
13:09:21 <Cale> cdk: Well, I don't think so, but sequence . map f is the same as mapM f
13:10:12 <guest123> edwardk: Okay, thank you.
13:12:00 <albeit> If I insert a value into TVar that is still thunked, is it evaluated when inserted, or only when something later pulls it out and evaluates it?
13:13:39 <Cale> albeit: The latter
13:14:15 <EvanR> is there a strict TVar
13:14:29 <Cale> You can just use strict application $!
13:16:05 <pharpend> friggin cabal
13:16:35 <pharpend> getting this - http://lpaste.net/113709
13:16:53 <pharpend> it lies!
13:17:01 <pharpend> aeson does not depend on time ==1.5
13:17:07 <pharpend> http://hackage.haskell.org/package/aeson
13:17:28 <merijn> pharpend: Maybe not directly
13:17:39 <merijn> pharpend: But one of aeson's dependencies might
13:17:41 <pharpend> look at the page
13:17:48 <pharpend> it explicitly depends on time<1.5
13:17:50 <pharpend> it LIES
13:18:08 <merijn> The second option specifies >=1.5
13:18:12 <pharpend> i know
13:18:19 <merijn> Which means one of your dependencies is not allowing the first one to be picked
13:18:24 <pharpend> but cabal should be smart enough to figure out that I want the first option
13:18:39 <pharpend> oh
13:19:09 <monochrom> what is in your mittens.cabal file?
13:20:00 <pharpend> one sec
13:20:00 <monochrom> every computer behaviour looks like unpredictable, irreproducible side effects when taken out of context
13:20:10 * hackagebot bifunctors 0.1.1.3 - Haskell 98 bifunctors  http://hackage.haskell.org/package/bifunctors-0.1.1.3 (HerbertValerioRiedel)
13:20:26 <johnw> so does that mean that every unpredictable, irreproducible side effect looks completely sane in the right context?
13:20:32 <pharpend> http://lpaste.net/113710
13:20:47 <nisstyre> monochrom: unless you use nixOS
13:22:21 <pharpend> here's the new errors - http://lpaste.net/113711
13:25:11 * hackagebot bifunctors 0.1.2 - Haskell 98 bifunctors  http://hackage.haskell.org/package/bifunctors-0.1.2 (HerbertValerioRiedel)
13:25:13 * hackagebot bifunctors 0.1.3 - Haskell 98 bifunctors  http://hackage.haskell.org/package/bifunctors-0.1.3 (HerbertValerioRiedel)
13:25:15 * hackagebot bifunctors 0.1.3.1 - Haskell 98 bifunctors  http://hackage.haskell.org/package/bifunctors-0.1.3.1 (HerbertValerioRiedel)
13:25:17 * hackagebot bifunctors 0.1.3.3 - Haskell 98 bifunctors  http://hackage.haskell.org/package/bifunctors-0.1.3.3 (HerbertValerioRiedel)
13:25:19 * hackagebot bifunctors 3.0 - Haskell 98 bifunctors  http://hackage.haskell.org/package/bifunctors-3.0 (HerbertValerioRiedel)
13:25:29 <pharpend> someone is having some fun
13:26:12 <hvr> yeah... should have written a script for that ;)
13:26:48 <pharpend> why on earth were you pushing 5 versions at once?
13:27:05 <hvr> I'm not pushing new versions, I'm editing the .cabal meta-data only
13:27:21 <hvr> (but it looks as if I was uploading a new release to the ircbot)
13:28:08 <hvr> and to be more specific, I'm adding 'base<4.8' constraints because the old version won't build w/ base-4.8 anymore
13:28:57 <pharpend> base 4.8 is published?
13:28:59 <pharpend> https://hackage.haskell.org/package/base
13:29:43 <hvr> no it's not yet, but it's 99% sure that very aspect that breaks existing bifunctors package versions is going to be part of the base-4.8 rls
13:30:10 <pharpend> when are y'all publishing it?
13:30:21 * hackagebot bifunctors 3.0.1 - Haskell 98 bifunctors  http://hackage.haskell.org/package/bifunctors-3.0.1 (HerbertValerioRiedel)
13:30:21 <hvr> here's the candidate btw http://hackage.haskell.org/package/base-4.8.0.0/candidate
13:30:23 * hackagebot bifunctors 3.0.2 - Haskell 98 bifunctors  http://hackage.haskell.org/package/bifunctors-3.0.2 (HerbertValerioRiedel)
13:30:25 * hackagebot bifunctors 3.0.3 - Haskell 98 bifunctors  http://hackage.haskell.org/package/bifunctors-3.0.3 (HerbertValerioRiedel)
13:30:26 <wswiss> @pl \(t:ts) -> return $ Right (t,ts)
13:30:27 * hackagebot bifunctors 3.0.4 - Haskell 98 bifunctors  http://hackage.haskell.org/package/bifunctors-3.0.4 (HerbertValerioRiedel)
13:30:27 <lambdabot> ap (((return . Right) .) . (,) . head) tail
13:30:29 * hackagebot bifunctors 3.1 - Haskell 98 bifunctors  http://hackage.haskell.org/package/bifunctors-3.1 (HerbertValerioRiedel)
13:30:37 <hvr> pharpend: w/ GHC 7.10.1 sometime around feb 2015
13:30:47 <pharpend> hvr: ah, okay, cool
13:31:04 <pharpend> wasn't aware you could have candidates with cabal
13:31:48 <hvr> pharpend: it's rather a Hackage feature than a cabal feature
13:32:12 <pharpend> ah
13:33:04 <pharpend> it'd be nice if we could have full branching capabilities
13:33:13 <pharpend> but I imagine that would slam the hackage servers
13:34:01 <merijn> pharpend: Well, hackage is open source and contributions are welcome ;)
13:34:24 <pharpend> i suppose
13:34:25 <merijn> pharpend: As for building, afaik a company is donating build time to hackage now?
13:35:01 <pharpend> does anyone have anything to say about my dependency conflicts?
13:35:18 <bennofs> merijn: iirc, hackage runs on rackspace-sponsered servers
13:35:31 * hackagebot bifunctors 3.2 - Haskell 98 bifunctors  http://hackage.haskell.org/package/bifunctors-3.2 (HerbertValerioRiedel)
13:35:33 * hackagebot bifunctors 3.2.0.1 - Haskell 98 bifunctors  http://hackage.haskell.org/package/bifunctors-3.2.0.1 (HerbertValerioRiedel)
13:35:35 * hackagebot bifunctors 4.0 - Haskell 98 bifunctors  http://hackage.haskell.org/package/bifunctors-4.0 (HerbertValerioRiedel)
13:35:37 * hackagebot bifunctors 4.1 - Haskell 98 bifunctors  http://hackage.haskell.org/package/bifunctors-4.1 (HerbertValerioRiedel)
13:35:39 * hackagebot bifunctors 4.1.0.1 - Bifunctors  http://hackage.haskell.org/package/bifunctors-4.1.0.1 (HerbertValerioRiedel)
13:36:30 <merijn> bennofs: Yes, but build time for docs was sponsored by someone else too
13:36:35 <Xenasis> I updated my Emacs's haskell-mode a while ago - and am getting an error when I C-c C-l (its suggested solution isn't helping) - anybody know how to get the GHCI back?
13:36:54 <merijn> pharpend: Not without more investigation than I have time for. Try asking in #hackage where all the cabal experts are?
13:40:41 * hackagebot bifunctors 4.1.1 - Bifunctors  http://hackage.haskell.org/package/bifunctors-4.1.1 (HerbertValerioRiedel)
13:40:43 * hackagebot bifunctors 4.1.1.1 - Bifunctors  http://hackage.haskell.org/package/bifunctors-4.1.1.1 (HerbertValerioRiedel)
13:45:38 <burp> wow, super bifunctors spam
13:46:44 <Jello_Raptor> huh, this is probably a noobish question
13:47:36 <Jello_Raptor> but I'm trying to create a for each loop, and I'm wondering if there's a canonical way to do it.
13:47:47 <merijn> Jello_Raptor: It depends on the loops intent
13:48:06 <merijn> Jello_Raptor: Usually you'd use either: map, fold or hand-written recursion
13:48:10 <Jello_Raptor> I've got a list of tuples [(a.b)] , and an idiom  f a_1 b_1 >> f a_2 b_2 ...
13:48:26 <Jello_Raptor> I want to turn that list into a sequence of operations
13:49:06 <merijn> Jello_Raptor: Decompose your problem
13:49:11 <albeit> @pl \(a,b) -> f (g a) (h b)
13:49:12 <lambdabot> uncurry ((. h) . f . g)
13:49:19 <merijn> Jello_Raptor: First, map over the tuples to obtain a list of operations
13:49:29 <merijn> Jello_Raptor: Then sequence the list of operations
13:49:37 <albeit> @pl \(a,b) -> (g a, h b)
13:49:37 <lambdabot> g *** h
13:49:42 <merijn> :t sequence -- guess what sequencing operations is called
13:49:44 <lambdabot> Monad m => [m a] -> m [a]
13:49:48 <benzrf> :t \f -> sequence_ . map (uncurry f)
13:49:49 <lambdabot> Monad m => (a1 -> b -> m a) -> [(a1, b)] -> m ()
13:50:01 <merijn> Man...spoiler :\
13:50:13 <benzrf> soory!
13:50:15 <merijn> No one here lets newbies arrive at their own conclusions any more
13:50:22 <benzrf> :|
13:50:30 <benzrf> i only intended to check my own solution
13:50:33 <benzrf> i forgot they'd read it -_-
13:50:50 <merijn> I wish more people appreciated that helping someone achieve the insight on how to proceed is more helpful than just handing them the direct solution
13:50:58 <merijn> benzrf: That's what /msg lambdabot is for :p
13:51:34 <merijn> Jello_Raptor: Even further simplifying the code we can find that "mapM f = sequence . map f"
13:51:36 <Jello_Raptor> merijn: cool, I didn't know sequence was thing. thank you. :) and I figured it out before benzrf queried lambdabot
13:51:36 <merijn> So you can do
13:51:49 <merijn> :t \f -> mapM (uncurry f)
13:51:50 <lambdabot> Monad m => (a -> b1 -> m b) -> [(a, b1)] -> m [b]
13:52:06 <merijn> And if you don't care about the result value, there's the more efficient
13:52:08 <merijn> :t sequence_
13:52:09 <lambdabot> Monad m => [m a] -> m ()
13:52:13 <merijn> :t mapM_
13:52:14 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
13:52:21 <merijn> Which discard the results, instead of building a list
13:52:29 <monochrom> IMO more often than not the direction solution is the fastest way to achieve insight. Piaget's theory, concrete before abstract.
13:52:41 <Jello_Raptor> merijn: I don't, the monad sequences tests for a test suite
13:52:56 <Jello_Raptor> merijn: it prints as sideeffects, and the results values are useless
13:53:15 <merijn> Right, then use sequence_/mapM_, saves memory
13:53:24 <Jello_Raptor> cool
13:53:26 <EvanR> would you say that functions are not data types?
13:53:47 <monochrom> a function is a value, not a type. a function type is a type.
13:53:47 <merijn> I would
13:54:05 <EvanR> a function type is not a data type?
13:54:10 <merijn> monochrom: I think he meant in the ADT sense of datatype
13:54:15 <t4nk765> Hello! Is this the right place to ask newb questions (possibly about Parallel.Strategies usage)?
13:54:31 <EvanR> yeah, the data keyword
13:54:42 <merijn> t4nk765: Yes, although I'm not sure whether I would consider Parallel.Strategies to still be a newb question :)
13:54:49 <monochrom> that will depend on what the reader thinks "data" includes. but it is always safe to say that a function type is a type.
13:55:12 * hackagebot json 0.8 - Support for serialising Haskell to and from JSON  http://hackage.haskell.org/package/json-0.8 (IavorDiatchki)
13:55:39 <t4nk765> merijn: Well, I have done some basic Haskell, but I'm new to monadic Haskell and I need to write a report-ish thing on Strategies. :)
13:56:56 <monochrom> a function value is data in the sense that it is a value, you pass it in parameters and put it in records. a function value is not data in the sense that you can't ask "what's inside". then again you don't ask "what's inside a bit" anyway, it's a value of a primitive abstract type.
13:59:33 <EvanR> you can ask about a data types constructors, if they are exposed
14:00:17 <monochrom> it is perhaps more useful describing directly what you can and can't do to functions than looking for a false dichotomy based on subjective, malleable English.
14:00:49 <EvanR> whoa i didnt know i was doing dichotomies
14:01:04 <monochrom> 10 people will have 12 different notions of what is and is not "data"
14:01:20 <johnw> then based on the dirichlet principle, someone will have multiple notions
14:01:42 <merijn> johnw: That sounds like a boring name for that
14:01:48 <benzrf> 04:48 < merijn> I wish more people appreciated that helping someone achieve the insight on how to proceed is more helpful  than just handing them the direct solution
14:01:50 <johnw> i was going for "more mathy"
14:01:54 <johnw> fine, pigeonhole
14:01:54 <merijn> johnw: I've always heard that referred to as "the pigeon hole principle"
14:01:58 <benzrf> yeah i typically agree with that
14:02:03 <merijn> I love that term :)
14:02:08 <johnw> it was a tough proof
14:02:55 <EvanR> we definitely have function types and non function types though, right
14:03:06 <monochrom> yes
14:03:47 <EvanR> and no middle
14:04:32 <merijn> EvanR: No middle, only isomorphisms
14:04:33 <monochrom> is Char a data type? using the criterion "data exposes constructors", Char is not a data type. yet try going out announcing "Char values are not data".
14:04:53 <asfp> plus.google.com loads 10MB of javascript. ghcjs has a 1MB of "bloat" (rts etc).  I wonder how ghcjs scales for larger code bases, because the bloat overhead would just be 10% on a page like plus.google.com.
14:05:01 <EvanR> i wasnt trying to imply data types must export constructors
14:05:12 <merijn> EvanR: i.e. there are non-function types that we can convert to functions, but it's not ambiguous what it is
14:05:18 <EvanR> but you can pattern match on Char none the less
14:05:56 <merijn> asfp: Now realise that "bloat" includes lightweight threading and STM and realise how much more functionality that is than most JS frameworks ;)
14:06:09 <monochrom> the pattern-matching on Char values is desugared into calling up ==
14:06:33 <cdk> @hoogle [Maybe a] -> [a]
14:06:33 <monochrom> in contrast, pattern-matching against [] is not desugared into calling up ==
14:06:36 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
14:06:36 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
14:06:36 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
14:06:39 <EvanR> and then theres criteria, if you can use view patterns or equivalent on values of the type
14:06:46 <merijn> Same thing for numbers and IsString/IsList
14:06:54 <EvanR> i cant offhand think of anyway meaningful way to view a function value
14:07:10 <EvanR> (a -> b) -> V
14:08:46 <monochrom> mono :: (Int -> Int) -> Bool; mono (($ 0) -> 5) = True; mono _ = False
14:09:08 <monochrom> this view pattern matches functions that map 0 to 5
14:10:11 * EvanR hmms
14:11:11 <EvanR> could come in handy
14:11:20 <EvanR> bottoms be damned
14:11:41 <Xenasis> Anybody know how to get C-c C-l loading haskell in a GHCI buffer back in haskell-mode for Emacs?
14:14:00 <sshine> Xenasis, I don't understand what you're saying. the GHCi buffer shouldn't be in the haskell major mode, AFAIU.
14:14:24 <Xenasis> Hmm o.o
14:14:51 <Xenasis> I did an update to my Haskell mode recently - C-c C-l used to open a GHCI buffer if one wasn't open and load the file into it
14:14:57 <Xenasis> but now it doesn't
14:15:04 <Hijiri> mine loads hugs for some reason
14:15:14 <Hijiri> I guess I need to change it
14:15:31 <monochrom> which version?
14:16:10 <monochrom> sorry to say that there are enough different versions from different repos such that even "updated today" contains no information.
14:16:30 <Xenasis> hmm o.o
14:16:32 <Xenasis> I shall check
14:16:52 <monochrom> well, perhaps 1 bit of information "not before year 2006" but that is still not enough
14:18:36 <Xenasis> 20141023.746
14:18:39 <Xenasis> is the version I have
14:19:25 <monochrom> then I know what it is. it has a bug mistaking that you are always doing a cabalized project, therefore it tries "cabal repl" rather than "ghci"
14:20:37 <Xenasis> Alright o.o
14:20:47 <monochrom> it is exactly the version I'm using, afterall
14:21:04 <Xenasis> There's an update to haskell-mode available
14:21:08 <Xenasis> I guess I'll give it an update
14:21:29 <monochrom> no, all newer versions still have the same bug
14:21:34 <Xenasis> ah!
14:22:44 <merijn> That'll teach people to not skip cabalising their projects :p
14:23:11 <Xenasis> yeah, same problem
14:23:19 <monochrom> find haskell-process.el, find "defun haskell-process-type", find inside the string literal "\\.cabal\\'", change it to ".\\.cabal\\'", i.e., prepend a period. M-x byte-compile
14:23:52 <monochrom> I wrote an email to chrisdone 7 days ago.
14:23:59 <Xenasis> ah, fantastic
14:25:13 * hackagebot snap-server 0.9.4.5 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.9.4.5 (DougBeardsley)
14:25:22 <Xenasis> Hmm, that didn't seem to work
14:25:36 <monochrom> here is what happened. to auto-guess whether to use "cabal repl" or "ghci", it looks at the current directory, then its parent directory, then its parent, etc, for a *.cabal file. unfortunately, the string literal only cares to say, "suffix is .cabal"
14:26:22 <monochrom> but now you get a tautology. everyone has .cabal in $HOME, it satisfies "has suffix .cabal".
14:26:28 <monochrom> you will have to restart emacs
14:26:42 <Xenasis> I did
14:27:15 <monochrom> did you make sure that it's recompiled? i.e., haskell-process.elc has newer timestamp than haskell-process.el
14:27:50 <Xenasis> I did get
14:27:51 <Xenasis> Wrote /home/andrew/.emacs.d/elpa/haskell-mode-20141031.557/haskell-process.elc
14:27:54 <Xenasis> but I shall check
14:28:04 <Xenasis> (I just tried again)
14:28:30 <fds4345> anyone got a fun way to do groupByFirst :: Eq a => [(a, b)] -> [(a, [b])]
14:28:43 <Xenasis> -rw-r--r--  1 andrew users 70062 Nov  3 22:17 haskell-process.el
14:28:45 <Xenasis> -rw-r--r--  1 andrew users 60735 Nov  3 22:20 haskell-process.elc
14:29:18 <Xenasis> But yeah, even after M-x kill-emacs and a restart, same error
14:30:09 <monochrom> there is also the customization variable "haskell-process-type" you may like to take a look and possibly change
14:30:29 <cdk> :t groupBy fst -- fds4345
14:30:31 <lambdabot>     Occurs check: cannot construct the infinite type:
14:30:31 <lambdabot>       a ~ (a, b) -> Bool
14:30:31 <lambdabot>     Expected type: (a, b) -> (a, b) -> Bool
14:30:43 <cdk> :t groupBy ((==) `on` fst) -- fds4345
14:30:45 <lambdabot> Eq b => [(b, b1)] -> [[(b, b1)]]
14:30:49 <cdk> hmm
14:31:14 <Xenasis> customize-apropos: No customizable group, face, or option matching (haskell-process-type)
14:31:35 <monochrom> you have to somehow cause haskell-mode to full load first, e.g., open a *.hs file
14:31:48 <Xenasis> I have one open
14:31:55 <cdk> :t M.toList . M.fromListWith (++)
14:31:56 <lambdabot> Ord k => [(k, [a])] -> [(k, [a])]
14:32:11 <cdk> :t M.toList . M.fromListWith ((++) . return)
14:32:14 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ [a]
14:32:18 <lambdabot>     Expected type: [a] -> [a]
14:32:20 <lambdabot>       Actual type: [a] -> [[a]]
14:32:30 <monochrom> then that's really strange and I don't know
14:32:36 <Xenasis> Thanks for trying, at least
14:33:16 <Xenasis> I think you're right about it being something cabal related
14:33:35 <Xenasis> if I try "start interpreter" from the menu bar, it prompts me for a "project name" then something about cabal
14:33:45 <Ptival> does anyone know of an example Happy file parsing multi-line nested comments? :\
14:33:53 <fds4345> cdk: Map is cheating :p the list is sorted tho
14:34:40 <cdk> fds4345: Map is probably the easiest, but it requires Ord
14:34:53 <cdk> :t M.toList . M.fromListWith (++) . map (fmap return)
14:34:55 <lambdabot> Ord k => [(k, a)] -> [(k, [a])]
14:35:00 <monochrom> all sorting requires Ord
14:35:09 <Xenasis> Which is frustrating, and I guess I may just start a seperate terminal at this point, which is annoying, but whatever
14:35:32 <Xenasis> better than copy-pasting into a run-haskell buffer
14:35:44 <cdk> monochrom: the signature fds4345 asked for only had Eq, but you're right of course, if the list is sorted then it must be Ord as well
14:36:32 <daniel-s_> Hi
14:37:32 <daniel-s_> http://lpaste.net/3692830945733246976
14:37:45 <daniel-s_> I get an error and I don't know why.
14:38:13 <cdk> daniel-s_: (_:[xs]) matches 2-element lists only
14:38:40 <cdk> you want (_:xs) which matches lists with at least (possibly more) 1 element
14:38:53 <daniel-s_> OK. Thanks
14:39:11 <seveg> daniel-s_: also mylen [xs] should be just mylen xs
14:39:58 <cdk> daniel-s_: [xs] is sugar for (x : []), so your pattern is (_ : x : []). Do you see how that is a 2 element list?
14:40:39 <cdk> i mean [xs] is sugar for (xs : []) where xs is a single element
14:40:48 <daniel-s_> If you're doing something recursive, is it better to put the function at the beginning or end of the expression. For example, (mylen xs) + 1 or 1 + mylen xs ?
14:41:15 <daniel-s_> cdk: I get it (about the 2 element list).
14:41:39 <monochrom> neither is better than the other
14:41:58 <monochrom> that is, when you do have a choice.
14:46:37 <ezyang> Straw poll: do you use 'cabal info'?
14:47:37 <HairyDude> @hoogle Int -> [a] -> Maybe a
14:47:40 <lambdabot> Prelude (!!) :: [a] -> Int -> a
14:47:41 <lambdabot> Data.List (!!) :: [a] -> Int -> a
14:47:41 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
14:48:04 <dcoutts_> ezyang: I guess I'm not a typical user :-)
14:48:09 <HairyDude> surprised such a function isn't in base
14:48:21 <ezyang> dcoutts_: Well, would you be sad if the list of modules from 'cabal info' went away?
14:48:27 <ezyang> What do you use it for?
14:48:28 <acowley> ezyang: No
14:49:21 <dcoutts_> ezyang: you want to make the output shorter?
14:49:42 <ezyang> No, I want to get rid of the list of modules because I don't feel like reimplementing effectively what is done in ./Setup
14:49:52 * dcoutts_ wants a proper cabal search to replace the cabal list feature
14:49:52 <ezyang> this is pursuant to https://github.com/haskell/cabal/pull/2197#issuecomment-61471034
14:51:47 <dcoutts_> ezyang: I don't see why it's difficult. We would still have a list of exposed modules from the InstalledPackageInfo
14:52:32 <ezyang> dcoutts_: 'cabal info' seems to do some sort of "merging"
14:52:37 <ezyang> That's the annoying part
14:52:42 <joe9>  this is my bad attempt at fork in the pause monad: http://codepad.org/fZJ5vUbg . Just want to check if anyone has any thoughts on how do it properly.
14:52:48 <dcoutts_> ezyang: it's taking info from the source package, or the installed package
14:52:52 <ezyang> "* We're building info about a various versions of a single named package so the input package info records are all supposed to refer to the same package name."
14:53:02 <ezyang> nope, not true
14:53:08 <ezyang> c.f. mergePackageInfo
14:53:14 <dcoutts_> ezyang: since not all installed packages have corresponding source versions, and vica versa
14:55:50 <dcoutts_> ezyang: whether or not cabal info is used much, it needs to be possible to do what it's doing. Which is: find the exported modules of an installed package; find the exported modules of a source package
14:56:16 <dcoutts_> ezyang: the former must be easy enough, and e.g. we need to do the latter in hackage
14:56:33 <ezyang> OK, that's fine, but why does the code merge the installed and source package information together?
14:56:50 <dcoutts_> ezyang: because we might only have one, or only the other
14:57:27 <ezyang> OK, let me put it differently: wouldn't it make more sense to have two code paths, one for installed and another for source?
14:58:45 <dcoutts_> ezyang: no, because there's three cases: only installed, only source, both
14:58:56 <dcoutts_> and the code is a lot shorter to deal with them together
14:59:27 <ezyang> wait, but why do we want to merge it together if their both installed and source?
14:59:57 <ezyang> like, if I have somehow managed to install a version of package p that exposes module A, while the source package on B has module B, why does it make sense for cabal info to report that A and B are exposed?
15:00:08 <ezyang> *they're
15:00:09 <dcoutts_> ezyang: because there is different info available for source vs installed
15:00:14 * hackagebot yi-rope 0.7.0.0 - A rope data structure used by Yi  http://hackage.haskell.org/package/yi-rope-0.7.0.0 (MateuszKowalczyk)
15:01:10 <ezyang> Sorry, am I misunderstanding what the code today does?
15:01:33 <dcoutts_> ezyang: for each thing it's interested in it picks preferentially from one source
15:01:48 <dcoutts_> ezyang: though certain things are only available from source
15:02:00 <dcoutts_> sorry, overloading
15:02:12 <dcoutts_> for each thing it's interested in it picks preferentially from one data source
15:02:47 <dcoutts_> ezyang: look at the combine function, it's using `mplus` on Maybes
15:02:56 <ezyang> ah, OK, I misinterpreted the type of mplus
15:03:41 <ezyang> OK, so, when we add reexported modules ad signatures, how do you want them to show up in cabal info
15:03:46 <dcoutts_> ezyang: but e.g. flags info is only available from the source versions, and installed versions and available source versions are obviously only available from one data source
15:03:59 <dcoutts_> ezyang: we consider those to be modules exported from a package right? so yes.
15:04:10 <ezyang> no, I mean, *how*
15:04:16 <ezyang> do you want them all dumped in modules
15:04:29 <dcoutts_> ezyang: as a first start yes. We might refine later.
15:04:37 <ezyang> ok I can do that easy
15:04:39 <dcoutts_> ezyang: similar issue for presentation on hackage
15:04:55 <dcoutts_> and haddocks
15:07:04 <dcoutts_> ezyang: the one I think would want some presentation difference is signatures and holes
15:07:43 <ezyang> cabal info really doesn't make a lot of sense when you can instantiate packages
15:08:04 <ezyang> Like, you want to say, "Here is what is required, and by the way, it's been instantiated in these ways"
15:08:40 <joe9> Is there a way to capture the continuation without using the Cont monad?
15:08:48 <dcoutts_> ezyang: yes it's mainly set up for talking about source packages
15:09:07 <ezyang> joe9: No, although SPJ and I have chatted about this and it probably wouldn't be too hard to implement
15:10:09 <joe9> ezyang: oh, really. Any thoughts on how please?
15:10:20 <ezyang> joe9: It needs runtime support
15:10:27 <ezyang> basically we'd copy the stack
15:10:31 <joe9> oh, ok.
15:10:42 <merijn> joe9: Doesn't cloud haskell support a limited set of closure capturing?
15:10:55 <ezyang> It's not put in because we don't have any good motivating use-cases for it
15:10:56 <merijn> It's very limited though, but I don't see any conceptual problems
15:11:11 <merijn> Just a "Small Matter of Programming"
15:11:25 <joe9> ezyang, http://codepad.org/fqRRuLwR  http://codepad.org/VCXmCJvc  in lines 30-40, I am trying to implement fork.
15:11:33 <belst> hey guys, is there an easy way to split a string say on "a" but not on "aa" ?
15:11:36 <joe9> ezyang: Just want to check if you have any ideas.
15:11:55 <joe9> ezyang: I know that you are one of the gurus when it comes to concurrency or haskell.
15:12:10 <sshine> belst, you can use a parser.
15:12:17 <joe9> ezyang: The code is idris code. but, I guess you can easily follow the logic.
15:12:26 <ezyang> you have a monad, why not just add Cont to it ;)
15:12:51 <ezyang> This also forces you to think about all of the gory problems associated with unrestricted continuations
15:12:56 <joe9> ezyang: brilliant idea. Let me figure that out.
15:13:01 <ezyang> like unwind-protect
15:14:14 <joe9> ezyang: Do you think the approach that I am using in lines 31-40 is workable?
15:14:24 <ezyang> I don't know
15:23:49 <Fuuzetsu> this is 2014, why is whenM still not in base
15:28:37 <orbital_> you have baffled me enough, weird bug! Why would `Web.PathPieces.fromPathPiece $ Data.Text.pack "asdf"` evaluate to Nothing?
15:28:47 <orbital_> this is with path-pieces 0.1.4
15:30:54 <acowley> orbital_: What's the type?
15:31:11 <acowley> You've got something that's overloaded on the return type, so context matters
15:33:02 <amatsu> @version
15:33:02 <lambdabot> lambdabot 5.0-int-e
15:33:03 <lambdabot> git clone git://github.com/int-e/lambdabot.git
15:34:30 <orbital_> acowley: the type of the whole thing?
15:34:39 <acowley> orbital_: Yes
15:34:57 <orbital_>  PathPiece s => Maybe s
15:35:16 * hackagebot tidal 0.4.16 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.4.16 (AlexMcLean)
15:35:27 <geekosaur> the type of the place where you are using it
15:35:28 <acowley> orbital_: No, the type that you are trying to use it at
15:35:54 <acowley> orbital_: If you try to get a Maybe Int from "asdf", you will get Nothing, for example
15:36:17 <geekosaur> ...and, if it's in ghci, you may be getting an inferred type ypu don
15:36:19 <geekosaur> t want
15:37:40 <orbital_> hm!
15:37:44 <orbital_> this is the context: https://github.com/agrafix/Spock/blob/master/src/Web/Spock/Internal/CoreAction.hs#L118
15:38:23 <orbital_> ... and i'm not entirely sure how to answer that question
15:39:31 <orbital_> all i can see is that sticking "traceShow" before and after the fromPathPiece shows the value going from Just "blah" to Nothing
15:40:21 <mmmm_> Is there a function "Producer a -> Producer b -> Producer (a,b)" in pipes or am I asking the wrong question?
15:40:51 <sshine> belst, easiest way I can think of, though, is:
15:40:54 <monochrom> is Producer an Applicative? if so, liftA2 (,)
15:41:01 <sshine> belst, whoops, just a sec :)
15:41:05 <merijn> monochrom: Only if he wants result values
15:41:19 <merijn> monochrom: Producer outputs are not in the right position for applicative
15:41:46 <acowley> orbital_: The next step is identifying where param or param' is called
15:41:47 <merijn> The full type is "Producer a m r" <- 'a' is the streaming output and 'r' the completion type
15:42:10 <monochrom> then perhaps it was a wrong question :)
15:42:15 <mmmm_> yes I think so
15:42:20 <merijn> monochrom: Most likely, yes :)
15:42:21 <mmmm_> I don't really understand what I am doing
15:42:36 <monochrom> something about "doesn't kind-check" :)
15:42:45 <orbital_> acowley: that's easy: https://github.com/agrafix/Spock/issues/14
15:42:53 <merijn> mmmm_: I don't think "Producer a m r -> Producer b m r -> Producer (a, b) m r" <- this is not a sensible type, given what pipes does
15:42:54 <acowley> orbital_: Oh, and just to be sure, you're sure that "lookup k  qp" is returning a Just?
15:42:59 <mietek> Does anyone know what is the problem with mueval vs ShowFun?
15:43:08 <mietek> chrisdone: ping
15:43:09 <mietek> https://github.com/chrisdone/tryhaskell/issues/21
15:43:22 <merijn> mmmm_: Possibly you want something like pipes-concurrency?
15:43:24 <mietek> bitemyapp: pong
15:43:29 <mmmm_> The real question is, what is the idiomatic way (pipes or no-pipes) to read two files line by line in lock step
15:43:51 <merijn> mmmm_: Actually, I'm full of shit
15:44:08 <orbital_> @hoogle lookup
15:44:08 <merijn> mmmm_: Pipes.Prelude.zip and Pipes.Prelude.zipWith >.>
15:44:10 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
15:44:10 <lambdabot> Data.List lookup :: Eq a => a -> [(a, b)] -> Maybe b
15:44:10 <lambdabot> Data.HashTable lookup :: HashTable key val -> key -> IO (Maybe val)
15:44:28 <acowley> orbital_: Even in that issue report, which instance of PathPieces is being used isn't clear. How is username used subsequent to the lookup?
15:44:31 <orbital_> acowley: oh, you mean am I sure it's not returning a Nothing - yes
15:44:54 <L8D> is it possible to import something under a different name rather than hiding it?
15:45:08 <L8D> like import Foo (bar as bar')
15:45:11 <geekosaur> no
15:45:21 <monochrom> no. I wished for it. but no.
15:45:32 <simpson> You can import multiple times from the same module to alter qualification.
15:45:39 <orbital_> acowley: username is used in "liftIO $ putStrLn username"
15:45:44 <bitemyapp> mietek: hiiiii
15:45:51 <simpson> import Foo hiding (bar); import qualified Foo as F (bar)
15:45:51 <bitemyapp> mietek: we're in #haskell-infrastructure discussing it.
15:46:01 <L8D> simpson: oh thanks
15:46:04 <L8D> that works for me
15:46:08 <simpson> Or something like that; I'm not in Haskell mindset ATM.
15:46:22 <mietek> bitemyapp: awsome
15:46:28 <acowley> orbital_: Well, that should lock it down to String
15:46:30 <L8D> simpson: you have to be in a mindset to write haskell?
15:46:31 <monochrom> simpson's syntax is right
15:46:54 <simpson> L8D: I develop graphics drivers for a living and I tend to "page in" a lot of information at work.
15:47:13 <simpson> I am not a bright man and I can only work on one thing at a time. :3
15:47:23 <L8D> ah
15:47:41 <acowley> orbital_: To start unwinding the issue report, you can verify that fromPathPiece works as expected at GHCi by giving an explicit type annotation
15:47:59 <acowley> orbital_: e.g., fromPathPiece $ pack "asdf" :: Maybe String
15:48:29 <L8D> @pl a >>= const n
15:48:29 <lambdabot> a >> n
15:48:56 <L8D> where's the source code behind @pl ?
15:49:08 <acowley> orbital_: Then I'd probably print out ri_queryParams myself before calling param' to make sure "username" is there.
15:49:11 <orbital_> acowley: thanks. That evaluated to Just "asdf"
15:49:28 <c_wraith> @hackage pointfree -- L8D
15:49:28 <acowley> orbital_: Great, so we have a grip on sanity!
15:49:29 <lambdabot> http://hackage.haskell.org/package/pointfree -- L8D
15:51:32 <jb55> can anyone here build the texmath package on osx? I'm pretty sure it's putting clang in an infinite loop somehow (I'm on mavericks using apple's clang)
15:52:01 <orbital_> acowley: some kind of grip, yes :)
15:52:24 <L8D> @pl fmap (const a) b
15:52:25 <lambdabot> fmap (const a) b
15:52:28 <acowley> orbital_: :D
15:52:31 <L8D> -.-
15:53:06 <jb55> hmm it might just take a really long time...
15:53:59 <orbital_> acowley: whoa. It just started working.
15:54:10 <orbital_> and i'm not even sure what did it :)
15:55:15 <geekosaur> I dont see any C in there so I don't quite see where clang would be looping
15:55:54 <acowley> orbital_: I would suspect commenting out a usage of username if it were my code. I can't see anything obviously wrong with the lookup logic. Do you compile with -Wall or use ghc-mod?
15:56:47 <orbital_> acowley: this probably means that I was using "username" in some inappropriate way. I had no idea that would have this kind of effect.
15:57:01 <orbital_> in that i would have expected the compiler to stop me...
15:57:09 <acowley> orbital_: It's a feature that's unique-ish to Haskell
15:58:10 <acowley> orbital_: When it works, the overloaded function gives you what you need without you having to work for it. When it doesn't work, the answer is just to add a type signature at a call site.
15:59:35 <jb55> geekosaur: clang compiles llvm stuff generated by ghc, must just have lots to munch on. Been munching on it for a couple hours though :|
15:59:47 <orbital_> acowley: thanks!
16:00:05 * orbital_ learns many Haskell today
16:00:15 <jb55> sounds like a good day
16:00:34 <acowley> orbital_: Prototypical example here is the Read type class
16:00:35 <orbital_> and ghc-mod is next on my list. Just got haskell-mode working well with ghci.
16:00:37 <acowley> > (read***read) ("1", "True") :: (Int,Bool)
16:00:39 <lambdabot>  (1,True)
16:01:05 <sshine> @pl \e def -> either (const (return def)) return $ e
16:01:06 <lambdabot> flip (flip either return . const . return)
16:01:15 <acowley> > (read***read) ("1", "True") :: (Double,Bool)
16:01:16 <lambdabot>  (1.0,True)
16:01:18 <sshine> @pl \def e -> either (const (return def)) return $ e
16:01:19 <lambdabot> flip either return . const . return
16:02:07 <acowley> > read "1"
16:02:09 <lambdabot>  *Exception: Prelude.read: no parse
16:02:16 <acowley> And that's when it falls over on you
16:02:24 <EvanR> > read "1"
16:02:26 <lambdabot>  *Exception: Prelude.read: no parse
16:02:28 <EvanR> wurt
16:03:02 <FireFly> > read "1" :: Int
16:03:04 <lambdabot>  1
16:03:06 <EvanR> shouldnt that be a ambiguous type error
16:03:08 <simpson> > read "
16:03:10 <lambdabot>  <hint>:1:7:
16:03:10 <lambdabot>      lexical error in string/character literal at end of input
16:03:16 <simpson> >read "-1" :: Int
16:03:17 <HairyDude> wow, wxHaskell is so much easier to grok than gtk2hs
16:03:26 <sshine> HairyDude, good to know.
16:03:27 <Wingsorc> lets assume I have a list replicate n [True, False], with n some natural number. Is there a function which list all possibilites picking either True or False in each entry of the list
16:03:30 <orbital_> acowley: ah yes, read I remember
16:03:31 <acowley> EvanR: It expects Unit
16:03:36 <acowley> > read "()"
16:03:38 <lambdabot>  ()
16:04:06 <EvanR> > fromIntegral 3
16:04:07 <lambdabot>  3
16:04:08 <Kaidelong> http://codepad.org/eJE2mI05 does someone know why (++) is so much better than (:) here?
16:05:08 <sshine> is there a nicer way to provide a default Right value regardless of the Left value, than to use 'either (const (return ...)) return'?
16:05:23 <monochrom> I am not convinced that the difference can be fairly summed up as just (:) vs (++)
16:05:45 <johnw> yeah, it's the use of guards vs. unknown values
16:05:52 <orbital_> jb55: yes indeed
16:05:53 <L8D> :t ap
16:05:55 <lambdabot> Monad m => m (a -> b) -> m a -> m b
16:06:04 <johnw> the latter example is able to be lazy in every value, so it starts producing results right away
16:06:10 <monochrom> for example, why did you not ask "why n*6+1 is faster than n+2"?
16:06:15 <johnw> the guard-using example needs to do a lot more computation tno check the guard
16:06:28 <L8D> ap [(+ 1), (+ 2)] repeat 1
16:06:31 <johnw> um, maybe not *every* value
16:06:36 <L8D> > ap [(+ 1), (+ 2)] (repeat 1)
16:06:38 <lambdabot>  [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2...
16:06:49 <L8D> > ap [(+ 1), (+ 2)] [1]
16:06:51 <johnw> I could be wrong in that analysis though
16:06:51 <lambdabot>  [2,3]
16:06:52 <Kaidelong> how would laziness work with a prime sieve?
16:07:03 <Kaidelong> it needs to know every prime smaller than the candidate
16:07:21 <johnw> hmm
16:07:24 <johnw> ok, I retract
16:07:31 <Kaidelong> I guess the one is testing smaller primes first
16:07:45 <Kaidelong> while the other appends new primes to the end, rather than consing them to the start
16:07:57 <L8D> > return 0 :: [Int]
16:07:59 <lambdabot>  [0]
16:08:12 <Kaidelong> in which case maybe using ++ for the accumulator, but not for the overall computation, would work the best
16:10:20 * hackagebot thyme 0.3.5.4 - A faster time library  http://hackage.haskell.org/package/thyme-0.3.5.4 (LiyangHu)
16:11:24 <L8D> [1, 2, 3, 4] >> [5, 6, 7, 8]
16:11:28 <L8D> > [1, 2, 3, 4] >> [5, 6, 7, 8]
16:11:30 <lambdabot>  [5,6,7,8,5,6,7,8,5,6,7,8,5,6,7,8]
16:11:58 <L8D> > [1, 2, 3, 4] `mconcat` [5, 6, 7, 8]
16:12:00 <lambdabot>  Could not deduce (GHC.Num.Num ([t0] -> t1))
16:12:00 <lambdabot>    arising from the ambiguity check for ‘e_112345678’
16:12:00 <lambdabot>  from the context (Data.Monoid.Monoid t1,
16:12:00 <lambdabot>                    GHC.Num.Num ([t] -> t1),
16:12:00 <lambdabot>                    GHC.Num.Num t)
16:12:19 <indiagreen> > [1, 2, 3, 4] `mappend` [5, 6, 7, 8]
16:12:20 <lambdabot>  [1,2,3,4,5,6,7,8]
16:12:51 <L8D> > mconcat [[1, 2, 3, 4], [5, 6, 7, 8]]
16:12:53 <lambdabot>  [1,2,3,4,5,6,7,8]
16:12:54 <EvanR> by what mechanism does read default to String -> ()
16:13:19 <L8D> EvanR: when the type you're returning is something like IO ()
16:13:30 <int-e> EvanR: extended defaulting (ExtendedDefaultRules)
16:13:49 <EvanR> extended default
16:14:19 <bb010g> If a monad is a monoid over endofunctors with natural transformations, what is a comonad?
16:15:17 <benzrf> bb010g: a comonoid probably
16:15:39 <benzrf> bb010g: i aint got time to verify that though!
16:15:51 <benzrf> bb010g: the standart definition is just to flip the triple-based definition of monad
16:15:54 <benzrf> as i understand it
16:17:04 <bb010g> benzrf: Thanks. I'll look into it; I haven't heard of a comonoid/cosemigroup before. Wouldn't a cosemigroup require a comagma, though? What would that be like?
16:17:15 <lpaste> pharpend pasted “QuickCheck failure” at http://lpaste.net/113721
16:18:12 <pharpend> Hey, I'm getting some odd issues with quickCheck
16:18:16 <pharpend> Just pasted my file
16:18:53 <pharpend> http://ix.io/f21 <-- there's the quickcheck log
16:18:59 <pharpend> would someone care to tell me what's wrong
16:19:09 <pharpend> is decode . encode not an identity (in Aeson)?
16:20:01 <EvanR> decode returns Maybe a, encode takes a
16:20:22 <pharpend> or rather
16:21:00 <pharpend> (encode . decode) a should return (Just a)
16:21:32 <EvanR> what value does that not work for
16:21:33 <benzrf> bb010g: uh... cothings are easy to figure out from things
16:21:38 <benzrf> bb010g: just look at the opposite category
16:21:41 <pharpend> see the log i posted, EvanR
16:22:04 <EvanR> i mean what json text
16:22:14 <pharpend> lemme try
16:22:21 <pharpend> you know what
16:22:27 <pharpend> my aeson instances might be wrong, lemme check
16:23:37 <lpaste> pharpend pasted “The file in question” at http://lpaste.net/113722
16:24:26 <EvanR> it really is amazing how these encoder decoder instances mirror each other without being at all similar in functionality ;)
16:26:01 <Renan_> Hey, i need to use semicolon to finish my lines of code ?
16:26:11 <benzrf> no Renan_
16:26:14 <pharpend> Renan_: no
16:26:18 <pharpend> Renan_: you can, but it's not needed
16:27:12 <pharpend> You know what, lemme try something
16:27:24 <EvanR> pharpend: idea 1, do a test to make sure UTCTimes can be round-tripped through aeson "alone", idea 2, somehow get at the offending intermediate json text
16:27:30 <pharpend> yeah
16:27:40 <Renan_> Right, i'm doing a function like it: doubleMe x = x + x and in another line doubleUs x y = x*2 + y*2, but the ghci say: Perharps you meant 'doubleMe'
16:27:48 <bb010g> Comonoids are weird. http://stackoverflow.com/questions/23855070/what-does-a-nontrivial-comonoid-look-like
16:27:50 <Renan_> I have no idea what is that. :/
16:27:58 <Renan_> I new in function language.
16:28:16 <Renan_> i'm*
16:29:03 <bb010g> Renan_: Are you making sure to say let before definitions?
16:29:05 <pharpend> i can get you ugly json
16:29:38 <bb010g> Renan_: Or are you loading a file?
16:29:51 <EvanR> pharpend: http://jsonprettyprint.com/
16:30:01 <Renan_> bb010g i'm loading a file.
16:30:53 <bb010g> Renan_: What line is erroring?
16:31:14 <Renan_> first, have just two lines. :')
16:31:26 <Renan_> How i have said before i'm new in functional languages. :/
16:31:42 <Renan_> Do you want to see the code ?
16:31:48 <bb010g> It shouldn't error...could you paste the code?
16:32:09 <bb010g> Use lpaste (see the topic)
16:32:18 <Renan_> http://pastebin.com/qPeJ461d
16:32:43 <Renan_> Oh, sorry lpaste i will remember.
16:32:43 <Iceland_jack> Renan_: That looks fine
16:32:53 <Renan_> Weird.
16:33:00 <Renan_> I will try again. :)
16:33:02 <Renan_> Thank-you all.
16:33:36 <yukko> Renan_ it runs fine for me - how are you loading your code?
16:34:11 <Renan_> Now it's working, i have no idea what is this. haha
16:34:13 <bb010g> Renan_: How are you loading it into ghci?
16:34:21 <Renan_> doubleUs 4 8
16:34:23 <Iceland_jack> baldur@Skuld ~ % runghc =(curl -s 'http://pastebin.com/raw.php?i=qPeJ461d'; echo; echo 'main = print (doubleUs 2 4)')
16:34:23 <Iceland_jack> 12
16:34:32 <Renan_> the function and the parameters.
16:34:51 <Renan_> Thank-you all.
16:34:53 <athan> Hi everyone, I have some questions regarding HXT. So, a filter in it's eyes is a function with a type `a -> [a]`, and we perform queries by composing filters. Now my question is, wouldn't it be possible to get the opposite given a filter and a document as it's input? That is, an XML _template_ (or record type) that you could simply apply the results to, one for one, and get the origional document back?
16:35:40 <Iceland_jack> Renan_: If you have those two definitions in a file (ending with .hs), try running the following
16:35:40 <Iceland_jack>     $ ghci file.hs
16:36:15 <Iceland_jack> Then you should get a prompt like this:
16:36:15 <Iceland_jack>     ghci>
16:36:15 <Iceland_jack> and you should be able to run:
16:36:15 <Iceland_jack>     ghci> doubleUs 2 4
16:36:18 <Iceland_jack>     12
16:36:30 <Iceland_jack> Renan_: You're also free to join #haskell-beginners
16:37:24 <lpaste> pharpend pasted “the offending json” at http://lpaste.net/113723
16:38:29 <Renan_> Iceland_jack i will
16:38:30 <Renan_> thank-you
16:40:00 <EvanR> pharpend: did you try to apply the decoder to this json manually
16:40:50 <pharpend> no
16:41:05 <EvanR> curious to see what the problem is
16:41:20 <EvanR> itll either be Nothing or Just something different from what you think it is
16:42:01 <pharpend> λ: decode q :: Maybe Journal
16:42:03 <pharpend> Just (Journal {journalTitle = "", journalLastEdited = 2014-11-04 00:28:00.58 UTC, journalCreated = 2014-11-04 00:28:00.58 UTC, journalDescription = Nothing, journalEntries = fromList []})
16:43:23 <EvanR> and what test fails
16:44:22 <monochrom> is "2014-11-04 00:28:00.58 UTC" supposed to be parsable? does JSON even have a time format?
16:44:30 <pharpend> ah
16:44:36 <EvanR> the UTCTime instance of JSON
16:44:52 <EvanR> FromJson
16:44:52 <pharpend> let me try again
16:45:22 <EvanR> "2014-11-04T00:28:00.580Z" parses
16:45:30 <piskrist> maybe UTCTime has defined JSON but I don't think JSON has defined any Time
16:46:01 <pharpend> it's some iso standard
16:46:06 <EvanR> but it encoded and decoded apparently correct
16:46:13 <EvanR> so thats not the issue
16:46:24 <EvanR> oh
16:46:24 <EvanR> oh
16:46:25 <monochrom> I see
16:46:44 <EvanR> your arbitrary UTCTime (right now) has a Pico-or-something fraction of seconds
16:46:52 <pharpend> Okay, here's the starting journal - Journal {journalTitle = "\NAKfv)\218i\201&vdE\DLEw`\DC3", journalLastEdited = 2014-11-04 00:28:00.58006 UTC, journalCreated = 2014-11-04 00:28:00.58006 UTC, journalDescription = Just "\214I", journalEntries = fromList []}
16:46:53 <EvanR> this gets trucated to the nearest thousanth
16:46:56 <EvanR> so they are not equal
16:47:18 <pharpend> okay
16:47:18 <EvanR> .58006 /= .580
16:47:23 <EvanR> thas my theory
16:47:24 <pharpend> hmmm
16:47:28 <pharpend> what should I do
16:47:53 <EvanR> pick a different arbitrary instance or abandon your encode decode law ;)
16:48:12 <Arahael_Twin> so, where can i read about how runst is implemented? from what i can tell, the st monad is very similar to the io monad, except that pure code is allowed to create instances of it?
16:48:27 <EvanR> or change the UTCTime ToJSON instance
16:48:49 <pharpend> Yep, you were right - Journal {journalTitle = "\NAKfv)\218i\201&vdE\DLEw`\DC3", journalLastEdited = 2014-11-04 00:28:00.58 UTC, journalCreated = 2014-11-04 00:28:00.58 UTC, journalDescription = Just "\214I", journalEntries = fromList []}
16:48:54 <hpc> Arahael_Twin: you should use capitalization or people will be very confused about what each identifier is
16:48:54 <pharpend> that's what ends up with
16:49:24 <hpc> Arahael_Twin: also, use the source for this; the implementation isn't specified so you'll have to look at what ghc does
16:49:59 <hpc> which is indeed very similar to IO
16:50:18 <pharpend> okay, what should I do?
16:50:35 <hpc> start here: http://hackage.haskell.org/package/base-4.7.0.1/docs/Control-Monad-ST.html
16:50:37 <EvanR> pharpend: so it would appear to work if more than 3 digits were used in the output
16:50:42 <hpc> look at the source of various things
16:50:58 <pharpend> EvanR: I think I'll submit a bug to aeson, because this should not be the default behavior
16:50:59 <Arahael_Twin> hpc: My understanding is that the ghc implementation of the IO monad is fairly hairy. But i a, willing to see he implementation of the ST monad - i saw one in 'pure haskell', except it used map.
16:51:55 <merijn> Arahael_Twin: THe implementation of IO and ST is the same :)
16:51:57 <hpc> it's not terribly hard to follow at the level you need
16:52:08 <EvanR> pharpend: yeah. the current implementation for the time part is Pico and so has 12 digits of precision.
16:52:38 <hpc> also runST is similar to unsafePerformIO, whichever one is easier for you to understand
16:52:43 <Arahael_Twin> merijn: Heh, so the difference is indeed w.r.t. the meaning of the types.  enlightening - thanks. :)
16:53:19 <Arahael_Twin> hpc: good to know. thanks.
16:53:19 <EvanR> pharpend: and in aeson, its formatTime defaultTimeLocale "%FT%T%Q" t
16:53:42 <Arahael_Twin> gtg
16:54:08 <merijn> Arahael_Twin: Not just the meaning of the types, also the operations provided for it
16:54:44 <EvanR> pharpend: also, you might want to consider what is supposed to happen for other ToJSON types which cant necessarily make it through, like Rational
16:54:54 <merijn> Arahael_Twin: i.e. there's a single underlying ST/IO implementation in GHC, which gets wrapped by ST or IO (both of which are essentially newtypes), but for IO operations, like file access/FFI only versions wrapped by IO are provided
16:56:02 <Arahael_Twin> merijn: it is beginning to make sencse - trying to understand mutatiin. i have to go, back in maybe 30min
16:56:07 <EvanR> so, your round-trip law makes sense for some implementations of ToFromJSON but not all
16:58:00 <EvanR> actually the json implementations for base types now use generics :S
17:01:22 <piskrist> yeah, I've used that to parse yaml configs
17:01:25 <piskrist> it's awesome
17:01:35 <piskrist> fucking magic
17:01:37 <liyang> pharpend: you can do a newtype like DotNetTime that wraps UTCTime (or ZonedTime), and just copy and modify the ZonedTime To/FromJSON instances for your botched timestamps.
17:02:46 <pharpend> liyang: alright, i might consider that
17:03:02 <pharpend> I'm having trouble understanding basic english right now, so imma go to sleep
17:03:04 <pharpend> night
17:03:06 <pharpend> probably
17:03:17 <EvanR> liyang: well, they are behind genericToJSON
17:03:44 <EvanR> but yeah a custom impl shouldnt be hard
17:05:43 <liyang> pharpend: well, save this for later but, here's how to QuickCheck things involving JSON timestamps: https://github.com/liyang/thyme/issues/12
17:06:07 <pharpend> liyang: thanks
17:06:50 <liyang> (Basically, don't test Haskell->JSON->Haskell round-trips; test JSON->Haskell->JSON instead.)
17:07:34 <joelteon> liyang: you need to put that diagram on the thyme docs sometime
17:08:07 <liyang> joelteon: yeah, I've been tingering with diagrams… but other things keep getting in the way.
17:08:17 <joelteon> no worries
17:08:20 <EvanR> json -> haskell -> json doesnt have a nice equation like (decode . encode) a = Just a ;)
17:09:13 <joelteon> ;(
17:10:12 <EvanR> alas it was a bogus law in the end anyway
17:12:00 <liyang> joelteon: http://i.imgur.com/INrvHQm.png
17:12:09 <piskrist> I have an antisocial personality and I'm looking for attention right now because I have no friends
17:12:12 <joelteon> is that generated by diagrams?
17:12:38 <liyang> joelteon: I haven't figured out how to font size properly. diagrams isn't really aware of such a concept. :(
17:12:42 <liyang> joelteon: yup. :)
17:13:05 <piskrist> and I can tell you this because I have abused a substance
17:13:21 <liyang> (I'm just making it difficult for myself instead of just using create.ly.)
17:13:38 <EvanR> i remember making a diagram like this for Data.Time because yeah
17:13:50 <EvanR> the docs are good to a point
17:13:56 <joelteon> diagrams is a nice library
17:14:23 <liyang> It'll be easier once I get the hang of diagrams, so I keep telling myself.
17:14:40 <liyang> Need to investigate SVG fonts…
17:15:22 * hackagebot json-autotype 0.2.1.4 - Automatic type declaration for JSON input data  http://hackage.haskell.org/package/json-autotype-0.2.1.4 (MichalGajda)
17:15:35 <carter> liyang: fontyfruity might be a better substrate
17:18:16 <EvanR> json autotype looks cool
17:19:38 <liyang> carter: thanks, I'll have a look!
17:19:56 <CrazyM4n> http://lpaste.net/7564794635101405184 I can't figure out how I could parse things to a Number here
17:19:57 <carter> liyang: for fonts mind you
17:20:42 <CrazyM4n> I'm trying to make a math expression parser, and I'm trying to figure out how to get the numbers out of the expression string
17:20:50 <EvanR> CrazyM4n: literal numbers?
17:21:03 <EvanR> you would get those directly right
17:21:07 <CrazyM4n> It's my own data, it's Number Double
17:21:14 <CrazyM4n> I could call it something else to avoid confusion
17:21:30 <liyang> joelteon: the nice thing about using diagrams is that I can name the boxes and arrows after actual things (well, their TH Names at least), so if I change the API at least the hierarchy-drawing code will complain at me: https://gist.github.com/liyang/854dd760a49dc830e4de
17:22:20 <EvanR> CrazyM4n: ok, its not a parser there, its the evaluator for the expressions
17:22:20 <joelteon> that IS nice
17:22:27 <joelteon> So are you working on laying out the entire diagram I made
17:22:29 <joelteon> or just a subset of it
17:22:38 <EvanR> CrazyM4n: just do case analyses on the kinds of expressions
17:22:41 <liyang> joelteon: the entire library. :)
17:22:53 <liyang> joelteon: although I haven't looked at it for a couple of weeks now…
17:23:02 <CrazyM4n> That's what I'm doing. I don't know how to get the numbers though.
17:23:36 <EvanR> a expr is a String ok. So you really need a parser library here
17:24:22 <CrazyM4n> Yes, that's what I'm trying to write, but I guess I'll go look at preexisting expression parsers to get a handle on what I'm doing
17:24:26 <CrazyM4n> err
17:24:27 <EvanR> and to get the precedence for + * - / right you can use the expression language parser
17:25:15 <EvanR> check out anything you can read on "monadic parsing"
17:26:26 <CrazyM4n> okay
17:27:24 <CrazyM4n> So I'm looking for something like parsec?
17:27:40 <EvanR> thatll work
17:30:38 <CrazyM4n> I could also do it the cheap way and just convert digits to their respective doubles
17:30:45 <CrazyM4n> And combine the doubles afterward
17:31:48 <EvanR> what you want is a function which takes a String and gives Maybe (Double, String) which is Nothing if it fails to parse a valid double, or Just (x, rest) where x is the number and rest is the remaining unparsed characters
17:31:57 <EvanR> that way you can continue with the parsing
17:32:21 <EvanR> parsec has a function for that, and it will let you combine parsers so you dont have to deal with the Maybe
17:32:59 <CrazyM4n> I'll try to learn parsec then
17:33:00 <CrazyM4n> I guess
17:33:52 <EvanR> alternatively you can use reads to do it, but the get any nested expression you will want to learn this technique
17:34:01 <acowley> If you have a few extra hours, writing your own mini-parsec is hugely valuable
17:35:33 <EvanR> > reads "3.14+9" :: [(Double, String)]
17:35:36 <lambdabot>  [(3.14,"+9")]
17:36:54 <CrazyM4n> Eh, parsec seems easy enough
17:37:04 <sshine> famous last words!
17:37:38 <CrazyM4n> Hah
17:37:48 <benmachine> no parsec is actually quite easy
17:37:52 <CrazyM4n> There's this though, http://hackage.haskell.org/package/parsec-numbers-0.1.0/docs/Text-ParserCombinators-Parsec-Number.html , which I think is what I need
17:38:03 <benmachine> it has some gotchas but mostly it's pretty awesome
17:38:18 <EvanR> i guess theres no dumb Double parser in there, but it is part of the token parser. or theres that parsec-numbers package
17:38:30 <EvanR> float :: ParsecT s u m Double
17:38:46 <CrazyM4n> yeah, there's nothing in there that looks like I could use
17:38:52 <EvanR> haskell :: TokenParser st
17:38:55 <acowley> branches and backtracking can be tricky
17:39:28 <EvanR> CrazyM4n: well, from what your language looks like, you would want to use this premade token language, since + and * have precedence
17:39:44 <EvanR> or do it yourself!
17:40:18 <CrazyM4n> Hm, I think I'll try to figure this out myself
17:40:31 <CrazyM4n> The solution will most likely be terrible but hey
17:40:50 <CrazyM4n> myself as in without a library
17:42:32 <piskrist> … The last words before death
17:42:49 <CrazyM4n> D:
17:43:15 <EvanR> being able to do the monadic parsing yourself is good, because you can use it in javascript or a system which has no good alternative
17:43:16 <acowley> The death of confusion, the birth of enlightenment
17:43:47 <CrazyM4n> The only other thing like this that I've done was writing a stupid little language where every command was one character
17:43:54 <CrazyM4n> So I didn't have to deal with parsing too much
17:46:37 <EvanR> maybe check out how read works
17:47:13 <EvanR> > read "(3.14, False)" :: (Double, Bool)
17:47:14 <lambdabot>  (3.14,False)
17:47:51 <EvanR> > read "(3.14, Nothing)" :: (Double, Bool)
17:47:53 <lambdabot>  *Exception: Prelude.read: no parse
17:48:43 <EvanR> > reads "(3.14, Nothing)" :: [((Double, Bool), String)]
17:48:44 <lambdabot>  []
17:57:44 <CrazyM4n> Oh hey, a tutorial on exactly what I want to do http://kunigami.wordpress.com/2014/01/21/an-introduction-to-the-parsec-library/
17:57:47 <CrazyM4n> Seems interesting
18:00:24 * hackagebot gl 0.4 - Complete OpenGL raw bindings  http://hackage.haskell.org/package/gl-0.4 (EdwardKmett)
18:15:00 <luite> edwardk: is there a reasonable chance that your gl package will be usable to bind WebGL? (currently OpenGL ES 2.0 spec with an object oriented API, no fixed function pipeline or GLU/GLUT)
18:15:34 <edwardk> luite: it has all the right corners of the spec you could modify the OpenGL ES 2.0 machinery to talk to WebGL
18:15:52 <edwardk> OpenGL ES 2.0 has no fixed function pipeline already
18:16:37 <edwardk> the differences are fairly minor beyond that, other than the fact that all the shader extensions have different names ;)
18:17:13 <edwardk> we could see about adding "WebGL" support directly somehow by hacking up the OpenGL ES 2.0 specification and making a separate WebGL corner of the Profile
18:17:21 <luite> yeah i know, that was just a general remark
18:17:22 <edwardk> but we'd need to work with you pretty closely
18:19:02 <luite> i haven't read your code yet since i'd have to annoy people if i was too late for the ghc 7.10 freeze with my cabal/ghc patches
18:19:39 <luite> and then i lost a few hours on your lens Template Haskell hack too ;p
18:19:53 <edwardk> luite: its pretty clean and generates all the haddocks from the api specfication now
18:20:14 <edwardk> http://hackage.haskell.org/package/gl-0.4/docs/Graphics-GL-Raw-Extension-EXT-Convolution.html
18:20:35 <edwardk> (we just patched it to figure out PixelInternalFormat, so those will also get the 'one of' list in the next release
18:21:47 <edwardk> anyways ping me when you can breathe and we can make the WebGL part work
18:30:37 <luite> edwardk: ah many of the Ptr things might not be optimal in JS since creating the buffer is rather expensive. for copying a pixel data buffer or lut it wouldn't be a problem, but for retrieving a few uniform scalars or vec3 it's not ideal
18:31:06 <edwardk> i'm happy to talk about nicer ways to call stuff
18:32:55 <luite> edwardk: yeah i'll think about this too. if it's mostly done with alloca, i can introduce a new thread local alloca stack and replace the default newPinnedByteArray# implementation and get rid of most of the overhead
18:33:15 <luite> (surely that can't be a terribly efficient way to handle alloca in native code either)
18:37:28 <simpson> Should I use simple-atom or intern for string interning?
18:47:29 <RyanGlScott> Is there a way I can get GHCi 7.8 to always show type role information with :info?
18:51:25 <RyanGlScott> For example, typing ":i Ptr" will not reveal the type role information, even though it's been set to type role Ptr representational.
18:53:39 <Welkin> can I `cabal build` only the newly added dependencies instead of recompiling everything?
18:54:06 <Welkin> or will it automatically recognize that?
18:59:24 <vanila> How would I run a subprocess from haskell and get two streams - one that I can put lines (strings) into for its stdin and one I can read the programs output from?
19:01:00 <Hafydd> vanila: System.Process.createProcess, and such.
19:04:42 <geekosaur> note that you can deadlock doing that; at minimum, use separate threads for read and write
19:07:42 <thinker_> identify via /msg NickServ idenity test
19:08:22 <Fuuzetsu> @tell thoughtpolice is there a date for 7.8.4? I may want to slide in a hardcoded version string in whatever Haddock ships (for the nix Hydra bug on darwin) with that so I'd rather not miss the chance if it comes to it
19:08:22 <lambdabot> Consider it noted.
19:08:59 <merijn> Does base have a way to spawn new processes?
19:09:21 <Fuuzetsu> doesn't ‘process’ ship with GHC?
19:09:39 <merijn> oh, does it? If so, problem solved :p
19:09:58 <Fuuzetsu> don't quote me on that
19:10:30 <merijn> Fuuzetsu: oh, looks like it
19:10:38 <vanila> I'm having some rouble with it, http://lpaste.net/113728
19:10:44 <vanila> it just prints:  Run: fd:5: hGetLine: end of file
19:11:34 <Fuuzetsu> vanila: runInteractiveProcess seems more like what you'd want
19:11:47 <vanila> same with /bin/cat
19:18:12 <Dongyancai> Hello, is there any method to see the process of reduction? I'm trying to make some demos about this.
19:18:37 <trap_exit> yes
19:19:09 <trap_exit> how many dogecoins would you pay for such a tool?
19:19:24 <godel> \infty
19:19:30 <trap_exit> http://chrisuehlinger.com/LambdaBubblePop/
19:20:21 <godel> so you can reduce in applicative order?
19:20:23 <godel> nice
19:20:38 <kadoban> Dongyancai: Maybe you can do something with ghc-vis?
19:22:15 <Dongyancai> kadoban: I managed to use ghc-vis in a ghci session, but when at a breakpoint, I just saw "blackhole"s.
19:22:57 <benzrf> fun fact: lambda bubble pop is not correct
19:23:04 <benzrf> you can get wrong results from it :v(
19:26:23 <Dongyancai> Maybe I may need to look into the operational semantics.
19:27:15 <godel> benzrf: do you have a concrete example?
19:29:26 <orbital_> to all you people who host on github instead of darcs, I raise this glass
19:30:09 <benzrf> godel: yeah
19:30:15 <benzrf> try putting "take 2 [9, 3, 4, 5, 6]" in as a thing
19:30:19 <benzrf> then keep expanding the take bubbles
19:30:23 <benzrf> don't reduce the subtraction bubble
19:30:35 <benzrf> you'll get back more than 2 because it incorrectly tries matching against the term without reducing it
19:30:59 <benzrf> i.e. it sees '2 - 1 - 1' as different from 0
19:31:06 <benzrf> because it doesnt understand that matching forces eval
19:31:41 <godel> nice
19:32:37 <godel> but benzrf: doesnt haskell do that?
19:32:47 <godel> I mean, beta reducing
19:33:10 <benzrf> ?
19:33:24 <godel> it reduces the outermost expression
19:33:33 <godel> that is what I did
19:34:13 <benzrf> yes, but when it needs to match it forces reduction until it can match
19:34:18 <godel> ah
19:34:20 <godel> nice
19:34:35 <benzrf> since this doesnt, it fails to match 2 - 1 - 1 against 0
19:34:35 <godel> it is reasonable
19:34:42 <godel> yes, nice
19:37:10 <benzrf> bye
19:38:40 <merijn> hmm
19:38:51 <merijn> How do I figure out where an error is being thrown? :\
19:40:37 <Axman6> painfully!
19:41:01 <Axman6> Debug.Trace is a good place to start
19:41:22 <lifter> Is there clever way to rewrite "\f x -> f x" ?
19:41:29 <merijn> Axman6: That's a terrible place to start
19:41:34 <Iceland_jack> lifter: id or ($)?
19:41:46 <Iceland_jack> @pl \f x -> f x
19:41:47 <merijn> Axman6: Unless you're suggesting I randomly sprinkle trace all over base...
19:41:47 <lambdabot> id
19:42:00 <lifter> Iceland_jack: oh right, what does that @pl do?
19:42:13 <Iceland_jack> Finds the pointfree (-less) version of an expression
19:42:34 <lifter> Iceland_jack: Is there a way to do that without using lambdabot?
19:43:01 <Iceland_jack> Well you have to know about "id" beforehand
19:43:08 <lifter> ok, thx
19:43:10 <lifter> that's cool
19:43:17 <Iceland_jack> But if you have some function (same function you gave):
19:43:18 <Iceland_jack>     foo f x = f x
19:43:28 <Iceland_jack> You can reduce it to:
19:43:28 <Iceland_jack>     foo f = f
19:43:33 <lifter> right
19:43:35 <Iceland_jack> and that's the identity function
19:43:38 <lifter> nice!
19:43:42 <Iceland_jack> @src $
19:43:43 <lambdabot> f $ x = f x
19:43:52 <Iceland_jack> Also compare the definition of ($) to your function
19:44:07 <lifter> oh yes
19:44:17 <lifter> I think "id" might be more readable
19:44:20 <Iceland_jack> If ($) were not writte infix it would be:
19:44:20 <Iceland_jack>     ($) f x = f x
19:44:20 <Iceland_jack> Yes
19:45:18 <lifter> I'm using that lambda in a fold
19:46:20 <lifter> it looks like this: let fs = map (flip T.replace "" . T.pack) [ "a", "b", "d" ] in foldr id txt fs
19:46:54 <lifter> where T = Text
19:47:06 <lifter> qualified import
19:59:18 <merijn> Is there a way to get a stacktrace for an exception without using "errorWithStackTrace"?
20:08:04 <carter> merijn: travel to the future and use 7.10 ?
20:08:09 <carter> or 7.12
20:08:12 <carter> or whatever
20:09:03 <Iceland_jack> If I had the power to travel to the future I might use it for something other than using slightly newer software versions :)
20:09:46 <merijn> carter: Is that a convoluted way of saying "haha" or "it's in the works in head"?
20:09:51 <carter> nope
20:09:58 <carter> merijn: i'd say those if i meant those
20:10:00 <carter> Iceland_jack: yo
20:10:07 <Iceland_jack> hey carter \o
20:10:15 <carter> Iceland_jack: you should chat with xplat on haskell-lens about pattern synonsyms
20:10:34 <carter> Iceland_jack: y u no on numerical channel
20:11:04 <Iceland_jack> I've been taking a break from IRC, let me rejoin
20:11:14 <carter> kk
20:11:38 <merijn> carter: Lemme rephrase: Does that mean I *can* do that with 7.10 or not
20:11:46 <carter> i hope so
20:11:56 <carter> merijn: i know dwarf support is landing
20:11:59 <carter> at mininum
20:12:17 <merijn> carter: I'm working on HEAD now, but base is throwing an exception from god knows where in the runtime :\
20:12:27 <carter> merijn: well, i cant see your code
20:12:35 <carter> so i assume its a bug on your side :)
20:12:52 <carter> i kid
20:14:08 <merijn> carter: No, because I didn't touch anything. (Or rather I fixed a bug in the threaded runtime system only to be confused why my test answers were wrong and figuring out the non-threaded runtime is broken too >.>)
20:14:09 <solatis> dwarf support is interesting -- does that mean you will be able to debug haskell programs with gdb?
20:14:34 <carter> merijn: link to the code that can trip the bug?
20:14:48 <carter> solatis: ask Enigmagic  and others
20:15:20 <merijn> carter: "main = threadDelay maxBound"
20:15:28 <merijn> carter: Try on OSX with 64bit ghc
20:15:37 <carter> merijn: seems like it'd take a while
20:15:39 <merijn> linux doesn't crash, but is silently wrong
20:15:50 <carter> what happens on mac
20:15:54 <merijn> carter: If by take awhile you mean "brutally crash immediately"
20:16:09 <merijn> linux isn't posix compliant and therefore silently does the wrong thing
20:16:27 <carter> what should happen
20:16:46 <merijn> It should wait maxBound seconds
20:16:50 <merijn> linux waits forever
20:16:58 <carter> same ahppen as maxbound -1?
20:17:07 <carter> what should hapepn
20:17:23 <merijn> -1 should be infinite wait, but linux treats every negative value as infinity
20:17:26 <carter> no
20:17:26 <Fuuzetsu> merijn: is that fixed now
20:17:28 <merijn> Thus silently hiding overflows
20:17:30 <Fuuzetsu> we hit it in Yi…
20:17:32 <carter> (maxBound -1)
20:17:39 <carter> merijn: read closer
20:17:40 <carter> :)
20:17:57 <merijn> carter: Yes
20:18:06 <Fuuzetsu> maxBound `subtract` 1
20:18:15 <carter> yes that
20:18:46 <merijn> Fuuzetsu: My patch was accepted on phabricator (this is my third attempt at fixing, so if you've hit this bug too, please verify that third time's the charm)
20:18:58 <merijn> Fuuzetsu: But I just figured out I only fixed the bug in -threaded
20:19:07 <merijn> Fuuzetsu: https://phabricator.haskell.org/D407
20:19:17 <Fuuzetsu> well I personally haven't got access to OSX, just know we hit it in UI code and now have CPP around it
20:20:20 <Fuuzetsu> what's this (#type nfds_t) thing
20:20:21 <carter> merijn: what do you want me to do?
20:21:10 <merijn> carter: I didn't expect you to do anything, you asked "link to the code that can trip the bug", hence my answer?
20:21:16 <carter> oh ok
20:21:17 <Fuuzetsu> I wish Phabricator didn't want me to log in for the smallest things like viewing a file
20:21:20 <merijn> Fuuzetsu: FFI to get the right type
20:21:30 <merijn> Fuuzetsu: Just have it remember your login?
20:22:04 <Fuuzetsu> nah, I click on login with GitHub and that seems to work, just annoying
20:24:28 <merijn> oh, bingo, I think I have the non-threaded culprit
20:26:00 <merijn> Now I just need to figure out how the hell to fix it >.>
20:27:13 <carter> merijn: whats the bug?
20:28:15 <merijn> carter: Same issue as with the threaded one I fixed in the phabricator link, but different code path
20:28:18 <Welkin> it's not a "bug"
20:28:23 <merijn> Welkin: It is
20:28:24 <Welkin> it's a programming error
20:28:37 <merijn> carter: Someone assumed that GHC word size == C word size
20:28:45 <carter> merijn: lame
20:29:03 <Welkin> "bug" implies an external force
20:29:05 <merijn> carter: 64bit GHC has word size 8, the OSX 64 bit C implementation uses 4
20:29:10 <Welkin> wheres it is the fault of the programmer
20:29:11 <merijn> Or rather
20:29:18 <merijn> *int* is 4
20:29:24 <merijn> And poll/select want int
20:29:45 <merijn> Welkin: bug implies no such thing
20:30:15 <merijn> bug: noun. "An unwanted and unintended property of a program or piece of hardware, esp. one that causes it to malfunction."
20:30:53 <Welkin> the origin is an actual bug causing a fauly connection
20:30:55 <Welkin> faulty*
20:31:05 <merijn> No
20:31:34 <Welkin> calling programming errors "bugs" takes the blame off of the programmer
20:31:53 <Welkin> if they make a faulty product, it is their fault
20:31:58 <merijn> Welkin: the term bug predates programming by decades, it was already in widespread use in the 1800s
20:32:11 <dmj`> merijn++
20:32:12 <merijn> Welkin: Anyway, I don't really see how you're being constructive here
20:32:48 <merijn> Also, taking blame away is one of the best ways to produce accurate, useful and actionable post-mortems
20:33:39 <merijn> Post-mortems on high-reliability fields focus on finding faults in process that allow mistakes to be made, rather than playing the blame game
20:33:45 <zwer_z> actually, according to wiki, that is the origin of a "software bug": Operators traced an error in the Mark II to a moth trapped in a relay, coining the term bug. This bug was carefully removed and taped to the log book. Stemming from the first bug, today we call errors or glitches in a program a bug.
20:33:47 <merijn> The blame game is counter-productive for fixing issues
20:34:01 <merijn> zwer_z: That's wrong
20:34:19 <Welkin> it has nothing to do with blame, but of realizing that you are the source of your errors
20:34:30 <merijn> zwer_z: In fact, the actual log entry of that event (on exhibit in the Smithsonian) reads "First reported case of actual bug being found"
20:34:37 <Welkin> so you must improve yourself by changing the way you approach the problem
20:34:44 <merijn> zwer_z: That remark makes no sense if the term "bug" was not already in use
20:34:55 <merijn> zwer_z: See http://www.catb.org/jargon/html/B/bug.html for more etymology
20:35:05 <kadoban> Welkin: You're about 50 years too late to change the term... A bit of a lost cause.
20:35:57 <merijn> Welkin: "must improve yourself" why do I need to improve myself? You're labouring under the illusion that people only ever tackle bugs they cause
20:36:41 <Welkin> if the person who caused it doesn't fix it, how will they improve?
20:36:46 <merijn> Anyway, off-topic for long enough
20:36:59 <merijn> Does anyone know what the acronym TSO stands for in the runtime?
20:37:55 <Iceland_jack> Thread state object
20:37:56 <Iceland_jack> ?
20:38:10 <Iceland_jack> (good night #haskell)
20:40:24 <merijn> Iceland_jack: Ah, that makes sense!
20:40:46 <L8D> why can't I see the module documentation for this? http://hackage.haskell.org/package/haste-compiler
20:41:13 <Welkin> it wasn't compiled for some reason probably
20:41:17 <Welkin> it's annoying...
20:41:17 <L8D> I have to clone it and cabal haddock in order to use it
20:41:33 <dmj`> L8D: can you use an earlier version? http://hackage.haskell.org/package/haste-compiler-0.4.2
20:41:40 <godel> I have "type Variable = (String, Int)", how can I do some kind of "instance Show Variable where"?
20:41:53 <L8D> dmj`: that works thanks
20:42:25 <Welkin> godel: just do pattern matching and yield a String
20:42:45 <godel> Welking but why is that illegal?
20:42:49 <merijn> godel: That's already an instance of Show
20:42:58 <godel> I mean, after all I am defining a type
20:43:01 <merijn> > show ("blah", 5)
20:43:03 <lambdabot>  "(\"blah\",5)"
20:43:08 <nshepperd> godel: an instance for Variable is an instance of (String,Int), which already exists
20:43:18 <liyang> godel: you're defining a type *synonym*.
20:43:18 <nshepperd> godel: you need newtype if you want to define your own instances
20:43:27 <merijn> godel: No, you're not. "type" creates a type alias, "Variable" is *exactly* identical to (String, Int)
20:43:53 <godel> and that is preferable to do uglier things like "data Variable = V (String, Int)" right?
20:43:57 <godel> I mean, coding style
20:44:11 <Welkin> that is not uglier
20:44:14 <Welkin> it is entirely different
20:44:24 <Welkin> "type" creates a type synonym
20:44:30 <liyang> Well, you might as well write data Variable = V String Int there…
20:44:30 <Welkin> "data" creates a new type
20:44:52 <liyang> newtype creates a new name for the same type.
20:45:03 <liyang> (are we confused yet?)
20:45:10 <godel> no, I understand that
20:45:20 <godel> I think that it is actually the same thing
20:45:50 <godel> I'd like to override the show function
20:45:50 <Welkin> newtype wraps a single constructor with a single field
20:45:56 <merijn> godel: newtype is basically a single constructor that (at runtime) has the exact same representation as the original type (but separate for typechecking)
20:46:01 <godel> given that I am creating a new type after all
20:46:03 <L8D> what Welkin said
20:46:04 <nshepperd> newtype creates a new type that wraps an old type (without runtiime overhead)
20:46:28 <Welkin> godel: but you are not creating a new type, after all
20:46:37 <nshepperd> "type Variable = (String, Int)" does nothing but a find-and-replace "Variable -> (String,Int)" throughout your code
20:46:38 <godel> hahaha you are right
20:46:41 <Welkin> you are creating a type synonym
20:46:44 <lifter> godel: If you want to "override show", what you probably want is a pretty print typeclass
20:46:50 <dmj`> godel: you'd need to use type syonym instances to do that, but then you'd need flexible instances, and overlapping instances
20:46:53 <L8D> @pl newTextElem "Hello!" >>= setChildren documentBody . return
20:46:53 <lambdabot> setChildren documentBody . return =<< newTextElem "Hello!"
20:46:55 <godel> lifter: yes
20:47:35 <godel> dmj` so you say I better declare some "shw :: Variable -> String" and live happily?
20:47:57 <nshepperd> anyway, it's true that Show is for representing, not pretty printing...
20:48:11 <godel> mhhh
20:48:21 <dmj`> godel: why do you want a different Show instance then what the default Show instance for (String,Int) gives you
20:48:31 <nshepperd> in that Show and Read are expected to be inverses
20:48:50 <nshepperd> most of the time...
20:48:58 <godel> becasue I'd like to do something like "show (str, k) = str ++ "_" ++ (show k)"
20:49:11 <godel> or something like that dmj`
20:49:30 <godel> I am actually being a bit anal here, but whatever :P
20:50:12 <dmj`> I'd say use a newtype then
20:50:23 <L8D> can you do erlang-style pattern matching in haskell such that I can do something like a=(Foo b)
20:51:06 <Welkin> ?
20:51:12 <L8D> derp...
20:51:28 <L8D> I mean like instead of: foo (Foo b) = let a = Foo b in ...
20:51:37 <liyang> But a newtype around a boxed tuple is just awkward… you may as well go full data Variable = V Int String.
20:51:44 <L8D> I can do something along the lines of: foo (a=Foo b) = ...
20:51:59 <L8D> is there a language extension for that?
20:52:04 <merijn> L8D: "foo a@(Foo b) = ..."?
20:52:20 <merijn> L8D: That doesn't even need an extension, that's just normal haskell98
20:52:21 <L8D> merijn: is that an extension or part of regular haskell?
20:52:26 <L8D> oh cool
20:52:26 <Welkin> as-patterns?
20:52:27 <L8D> thanks
20:52:31 <Welkin> they are built-in
20:52:34 <dmj`> L8D: you can do 'let Right (Just x) = eitherMaybeValue'
20:53:04 <merijn> dmj`: Look closer, that's not what he wanted :)
20:54:13 <Welkin> when I realized you can perform pattern matching inside do-notation when executing a computation using (<-) I was overjoyed
20:54:49 <Fuuzetsu> LambdaCase is where it's at
20:55:16 <Welkin> and also in let statement, such as ([title], content) = splitAt ...
20:55:35 <lifter> Fuuzetsu: I also like MultiWayIf
20:55:51 <Fuuzetsu> I never use that
20:55:58 <lifter> oh
20:55:58 <Fuuzetsu> I just case () of _ | …
20:56:25 <Welkin> what is a multiway if?
20:56:38 <Welkin> why would you use if statements at all?
20:56:42 <liyang> Welkin: have you ever abused pattern matching to the left <- and Monad (fail)?
20:56:49 <Welkin> I think they should not be included in the language
20:57:00 <Welkin> the if-then-else construct is not useful
20:57:11 <lifter> Welkin: I find it to be quite useful
20:57:42 <Welkin> liyang: yes I use pattern matching on the left of (<-) constantly in yesod
20:57:47 <lifter> Welkin: anyway MWI if like "if .. else if .. else"
20:58:17 <Welkin> that is too procedural
20:58:37 <lifter> it's just branching...
20:58:52 <dmj`> multi way if example: f x = if | x == 1 -> print "one"
20:59:50 <dmj`> you can do it all inline too
20:59:50 <dmj`> k x = if | x == 1 -> print "one" | otherwise -> print "hmm.."
21:00:44 <Welkin> k x | x == 1 = print "one" | otherwise = print "hmm..."
21:00:47 <Welkin> it's the same thing
21:01:04 <merijn> Except that you now need to define a function and find a name for it
21:01:49 <Welkin> if it requires branching cases, it should have a name
21:01:55 <Welkin> rather than a lambda
21:02:13 <xMer> hi guys im currently doing some research on functional programming
21:02:15 <Welkin> even if it is a locally defind function (in let or where)
21:02:37 <merijn> ugh, fun time
21:02:47 <Welkin> fun time?
21:02:56 <merijn> apparently select() has a maximum time out, but the man page doesn't specify what it is
21:03:04 <Welkin> dense code is not good
21:03:37 <lifter> xMer: hi
21:06:56 <nshepperd> ah, implementation defined behaviour, so great
21:07:31 <xMer_Alpha> sorry guys dc a moment ago
21:07:54 <xMer_Alpha> anyone got any paper on impredicative type paper for haskell??
21:12:17 <rshetty> Hey
21:13:20 <rshetty> Recently I had been going through Lazy Evaluation embraced by Haskell, I tried mapping into Ruby and found Lambdas and Procs for deferring evaluation.
21:13:57 <rshetty> What are some of the advantages of Lazy Evaluation over Strict ?
21:14:28 <rshetty> One of them being values wont be evaluated eagerly and will be evaluated when needed, Does this have performance aspects as well ?
21:15:00 <MP2E> it does, both good and bad
21:15:12 <MP2E> for the good, you can deal with infinite structures without infinite memory and only use it as you need it
21:15:38 <MP2E> sometimes though you can accumulate a huge amount of thunks, usually via foldl
21:16:00 <rshetty> Hmm MP2E Agree, Is there performance aspect to it ?
21:16:12 <BMeph> rshetty: For the bad, it interferes with control-freaks' efforts to pin-point exactly when and where expressions are evaluated. ;)
21:16:16 <MP2E> foldl' will evaluate the thunks strictly though! so you gain anything you would have lost :P
21:16:37 <MP2E> And you can annotate your own functions via the language extension BangPatterns to make them strict, or use seq/deepseq
21:16:52 <MP2E> laziness has a ton of benefits though, it allows us to define a lot of operators as regular functions
21:16:58 <MP2E> || doesnt' need to be special for instance
21:17:35 <MP2E> also it allows you to do debugging by writing out code and replacing function calls with the bodies, while reducing
21:17:38 <MP2E> it's rather like math
21:18:20 <solatis> in my previous c++ experience, it was often all about choosing the right data structure for the job -- use a stack, use a queue, use a vector or use a list. in haskell, all these are just available in a generic list structure, right?
21:18:43 <__jim__> MP2E: for (||) you mean it doesnt need a special construct for short circuiting, correct?
21:18:43 <solatis> as in, if in c++ i would like to use a stack, i would just use a list for that in haskell, right?
21:18:57 <MP2E> __jim__: exactly
21:19:20 <__jim__> Can that not be done in a strict language with pattern matching? I thought ML did that as well
21:19:38 <__jim__> *disclaimer, I haven't used ML in some time
21:19:44 <MP2E> solatis : a list would work, but it has performance implications.. Lists are generally not what you want in Haskell, actually. I'd look for a library
21:19:47 <MP2E> what kind of stack are you looking for?
21:20:06 <MP2E> i'm actually not familiar with how ML does things, that's an interesting point though, I'll look it up :P
21:20:20 <__jim__> fair enough :)
21:20:30 <MP2E> I know Idris can actually traverse infinite structures despite being strict by default because it's a total language
21:20:31 * hackagebot test-sandbox 0.0.1.9 - Sandbox for system tests  http://hackage.haskell.org/package/test-sandbox-0.0.1.9 (junjihashimoto)
21:20:33 * hackagebot test-framework-sandbox 0.0.2.4 - test-sandbox support for the test-framework package  http://hackage.haskell.org/package/test-framework-sandbox-0.0.2.4 (junjihashimoto)
21:20:35 * hackagebot test-sandbox-quickcheck 0.0.1.6 - QuickCheck convenience functions for use with test-sandbox  http://hackage.haskell.org/package/test-sandbox-quickcheck-0.0.1.6 (junjihashimoto)
21:20:37 * hackagebot test-sandbox-hunit 0.0.1.6 - HUnit convenience functions for use with test-sandbox  http://hackage.haskell.org/package/test-sandbox-hunit-0.0.1.6 (junjihashimoto)
21:20:42 <MP2E> So there are all sorts of neat tricks that push the boundaries
21:20:54 <solatis> MP2E: i need to build a HTML DOM out of incoming events, so i'd naturally use a stack to keep track of my current 'location' within the DOM
21:21:30 <MP2E> solatis: sounds like you want a zipper! https://www.haskell.org/haskellwiki/Zipper
21:21:43 <solatis> never looked into those
21:21:52 <__jim__> does anyone have some recommended reading for arrows? I feel like I get the idea until I start needing recursion
21:22:03 <solatis> i always associated that with a kind of fold?
21:22:25 <solatis> woa
21:22:33 <solatis> it looks like i need a zipper indeed
21:23:07 <solatis> i don't want to keep the entire tree in memory tho
21:23:16 <solatis> i just want to know my current position
21:23:45 <MP2E> GHC's garbage collector is quite smart
21:23:53 <MP2E> I'd be surprised if it did keep the whole tree in memory
21:24:03 <MP2E> not sure though
21:24:06 * MP2E reads more about zippers
21:24:50 <MP2E> yeah this won't keep the whole thing in memory
21:25:13 <MP2E> just has references to positions relative to the current node
21:25:15 <solatis> i just need to know that my current position, for example, is 'html.body.div.table.tr.td', if you understand what i mean
21:25:20 <MP2E> yeah
21:25:47 <solatis> i'll fiddle around with the zipper monad
21:26:56 <__jim__> MP2E: .. I don't suppose you're familiar with arrows, eh?
21:27:40 <MP2E> I'm familiar with them, they confuse me a bit still but I think I get the general idea :P
21:27:43 <pig_wick> Hello I have a doubt. I intend to make something that displays a prompt and then gets input from the user and then displays it . (main =  forever $  putStr ">> ">>getLine >>= putStrLn) but it keeps delaying printing the prompt, is it due to LAZINESS ?..so this what I came up with
21:28:32 <__jim__> so it always echos?
21:28:39 <__jim__> or, that is the goal?
21:28:56 <Hijiri> you need to hSetBufferingMode to NoBuffering
21:29:14 <Hijiri> normally a terminal buffers by line, but you want to output something before there is a full line
21:29:19 <Hijiri> actually
21:29:24 <Hijiri> it's probably better to hFlush manually
21:29:39 <__jim__> MP2E: I thought I'd try, thanks anyway :)
21:29:50 <Hijiri> it will perform slightly better than just setting NoBuffering
21:30:17 <Hijiri> so that would be forever $ putStr ">> " >> hFlush stdin >> getLine >>=...
21:30:35 <Hijiri> stdin and hFlush are in System.IO, I think
21:30:44 <Hijiri> sorry
21:30:47 <Hijiri> I meant stdout
21:30:49 <pig_wick> Hijiri: hmm ... thinking about what you stated and possibly googling things
21:30:52 <Hijiri> use stdout, that's the file handle of the output
21:31:41 <Hijiri> normally the write buffer doesn't get "flushed" until you hit a newline
21:32:01 <Hijiri> but calling the flush early with hFlush stdout does it before
21:33:00 <pig_wick> Hijiri: obby: <stdin>: hFlush: illegal operation (handle is not open for writing
21:33:26 <Hijiri> yeah, I mistyped
21:33:28 <Hijiri> it's stdout
21:33:46 <pig_wick> Hijiri: my bad as well , should have looked it a bit more carefully
21:35:00 <pig_wick> Hijiri : ah works well , so the write buffer isn't flushed until it reaches a newline ...that's a system rule right? hence language agnostic yep?
21:36:11 <Hijiri> It's the default
21:36:35 <Hijiri> you can change it with hSetBuffering in Haskell, other languages have similar operations
21:36:36 <pig_wick> Hijiri: noted and many thanks.
21:38:46 <Hijiri> hSetBufferMode*
21:39:07 <Hijiri> that's wrong too, but it's something like that
21:39:45 <Hijiri> oh, hSetBuffering was right
21:55:57 <jfeltz> shouldn't cabal repl start on a library target, even if some of the modules in that target fail to build?
22:06:44 <narendraj9> T
22:07:18 <relrod> ⊥
22:36:57 <lpaste> simpson pasted “Why have you forsaken me, ST!?” at http://lpaste.net/113732
22:37:25 <simpson> Anybody who happens to know anything about ST know why something like `runST . runEitherT` doesn't type-check?
22:37:31 <simpson> :t runST . runEitherT
22:37:33 <lambdabot>     Not in scope: ‘runEitherT’
22:37:33 <lambdabot>     Perhaps you meant ‘runWriterT’ (imported from Control.Monad.Writer)
22:43:14 <johnw> simpson: skolems
22:43:46 <johnw> the forall s in your composed type won't unify with the forall s that would be your input argument to the composition
22:44:15 <simpson> But...but they're both forall s. s! All the s! Forever! Every s that ever could be or ever will!
22:44:54 <dv-> :t runST $ runWriterT undefined
22:44:55 <lambdabot> (a, w)
22:44:55 <johnw> this is a special "forall s", it's treated as data, so regard as "some unique thing"
22:45:05 <johnw> that's what I meant by skolem
22:45:41 <simpson> Hm. The undefined worked correctly.
22:45:57 <simpson> :t runST $ runWriterT _ -- lambdabot has holes, right?
22:45:58 <lambdabot>     Found hole ‘_’ with type: WriterT w (ST s) a
22:45:58 <johnw> thats' because you're not dealing with a composition anymore
22:45:58 <lambdabot>     Where: ‘s’ is a rigid type variable bound by
22:45:58 <lambdabot>                a type expected by the context: ST s (a, w) at <interactive>:1:1
22:46:11 <johnw> I've run into this in other places before
22:46:20 <johnw> where foo = f . g wouldn't type check, but foo x = f (g x) will
22:46:23 <johnw> for exactly the same reason
22:46:28 <trap_exit> does anything in prelude require laziness ?
22:46:39 <trap_exit> if not, how hard is it to define a strict haskell ?
22:47:05 <trap_exit> is the only thign that break things like (gen_infinite_list :: Int -> [Int]), gen_infinite_list x = x : (gen_infinite_list (x+1))
22:47:08 <johnw> trap_exit: there are strict haskells
22:47:17 <merijn> trap_exit: Not very hard, Lennart implemented one :)
22:47:26 <simpson> johnw: Oooooh! I found the problem! My type is fancy-recursive-like and it tried to sneak an (ST s) out.
22:47:28 <merijn> trap_exit: And so did the Habit guys at PSU
22:47:32 <trap_exit> merijn: is this that in-house non-public ?
22:47:37 <merijn> trap_exit: Yeah
22:47:43 <trap_exit> merijn: how is that useful to me?
22:47:47 <merijn> Not sure whether Habit is vaporware or not
22:47:49 <trap_exit> I guess proof of existnece is better than nothing
22:48:01 <trap_exit> johnw: names please
22:48:26 <trap_exit> merijn: http://hasp.cs.pdx.edu/ ?
22:48:31 <merijn> trap_exit: You didn't ask for one, you asked "is it hard to define a strict haskell?", my answer is "multiple people have done so with fairly little effort"
22:48:35 <merijn> trap_exit: That one, yeah
22:48:56 <trap_exit> merijn: you're the type of person who goes "do you have the time?" "yes, I have the time" :-)
22:48:58 <merijn> trap_exit: The biggest problem is *implementing* it, especially if you wanna compete with GHC
22:49:20 <trap_exit> i'm trying to understand what breaks
22:49:23 <trap_exit> if everything just went strict
22:49:31 <merijn> trap_exit: infinite data structures
22:49:32 <trap_exit> and besides cute defs of cycle / fib / primes, I'm not sure what breaks
22:49:58 <trap_exit> so I think infinite data structures can be made to work
22:50:01 <trap_exit> if laziness was made explicit
22:50:05 <trap_exit> rather than strictness made explicit
22:50:06 <merijn> trap_exit: Any terminating strict program corresponds to a terminating lazy program (modulo memory/time consumption differens)
22:50:25 <merijn> Not all terminating lazy programs have a corresponding strict program
22:50:40 <trap_exit> sure they do
22:50:41 <trap_exit> both are turing complete
22:50:55 <merijn> trap_exit: That's not what I said
22:51:15 <merijn> trap_exit: I'm saying "if you *only* change the evaluation semantics"
22:51:21 <merijn> trap_exit: You're not allowed to reimplement
22:51:39 <trap_exit> corresponding strict program
22:51:45 <merijn> If you made strict Haskell any terminating strict haskell program would be terminating lazy haskell
22:51:45 <trap_exit> that just means I need ot provide a function f :: Lazy Program -> Strict Program
22:52:00 <merijn> Also, turing completeness is overrated
22:52:03 <trap_exit> anyway
22:52:07 <merijn> Don't get stuck in the Turing tarpit
22:52:12 <trap_exit> is there any practical
22:52:17 <trap_exit> is there any practical strict haskell I cna use
22:52:21 <trap_exit> without selling my soul to a bank ?
22:52:50 <merijn> trap_exit: SML/ocaml/F# are probably the closest you can get
22:52:54 <merijn> trap_exit: Example of my point
22:52:58 <merijn> > foldr const undefined [1..10]
22:53:00 <lambdabot>  1
22:53:05 <merijn> That would be a crash with strict semantics
22:53:28 <johnw> simpson: https://gist.github.com/9bddd5c9b44c2e188540
22:53:39 <trap_exit> those langauges
22:53:39 <johnw> simpson: same deal here; the composition version fails, the one with points works
22:53:42 <trap_exit> have type systems that are too weak
22:54:03 <simpson> johnw: Hm. Thanks.
22:54:07 <trap_exit> merijn: I see, your example makes sense
22:54:15 <johnw> simpson: does it make sense why?
22:54:18 <merijn> trap_exit: There's other smaller languages
22:54:32 <merijn> trap_exit: Clean is strict, afaik
22:54:44 <simpson> johnw: Yeah.
22:54:47 <johnw> cool
22:54:48 <merijn> And still purely functional
22:54:54 <dolio> Clean is not strict.
22:54:58 <merijn> dolio: no?
22:55:01 <trap_exit> wtf
22:55:03 <trap_exit> how do I google for it
22:55:05 <merijn> Ok, I stand correct
22:55:08 <merijn> *corrected
22:55:15 <trap_exit> damn it,
22:55:21 <trap_exit> damn it, google 'clean langauge' = how not to say fuck
22:55:37 <merijn> Oh, duckduckgo links me to wikipedia for Clean
22:55:43 <trap_exit> http://wiki.clean.cs.ru.nl/Clean
22:55:58 <merijn> Yeah
22:55:58 <trap_exit> Clean is a general purpose, state-of-the-art, pure and lazy functional programming language designed for making real-world applications
22:56:00 <trap_exit> what?
22:56:02 <trap_exit> what about not being lazy ?
22:56:14 <merijn> trap_exit: I was wrong, as dolio corrected
22:56:20 <trap_exit> Miranda is a non-strict purely functional programming language designed by David Turner as a successor to his earlier programming languages SASL and KRC, using some concepts from ML and Hope.
22:56:24 <trap_exit> damn it, mirandan is non-strict too
22:56:30 <merijn> Ur/Web is strict and has a more expressive type system than haskell
22:56:49 <kadoban> trap_exit: Why the search for a strict language anyway?
22:56:56 <merijn> Of course the syntax of Ur is god awful ugly and I don't think you can do anything but web programming with it
22:56:57 <trap_exit> I like strict
22:56:58 <trap_exit> I don't like lazy
22:57:28 <trap_exit> what is mozart http://mozart.github.io/ like?
22:57:35 <kadoban> trap_exit: That's...not much of an answer. If you're the person I'm thinking of, aren't you just learning haskell? Give it a chance first
22:57:37 <trap_exit> does it provide more theory or is it just a kitchen sink of features?
22:57:56 <trap_exit> kadoban: I've used haskell since about june, and hacked on it for about 4 hrs / day
22:58:12 <kadoban> I see
23:18:44 <Anastasia->  www.taxiathouston.com  www.houston-cab.com  www.24hriahairport.com  www.tophoustonlimo.com  www.houstontexaslimo.com
23:23:57 <brianpWins> in ghci I keep getting “factors” is not in scope.
23:24:06 <brianpWins> How can I bring in / load the factors module
23:24:10 <brianpWins> assuming the stdlib has one
23:25:04 <matematikaadit> brianpWins: import Module.Name
23:25:07 <kadoban> brianpWins: Never heard of it...what would it do? Regardless, you'll have to find what module/package it's supposed to come from first.
23:26:41 <brianpWins> oh I was assuming it might have one. Maybe i’m expected to implement that method as well.
23:28:16 <salamanderpie> In Windows 7, how do I save an .hs file to my current directory?  Where/what is my directory?
23:31:41 <Hijiri> well that depends where you're saving it from
23:38:44 <sebastiankg> I can't get Syntax Highlighting to work in EclipseFP
23:39:04 <sebastiankg> it's just plain, un-highlighted text
23:39:42 <sebastiankg> has anyone else had this problem?
23:40:31 <salamanderpie> 	In Windows 7, how do I save an .hs file to my current directory? Where/what is my directory?
23:41:19 <sebastiankg> A directory is just a folder, so just save the .hs file to the folder you're currently in
23:41:23 <sipa> the 'current directory' is a per-process property
23:42:22 <salamanderpie> Thanks
23:45:35 <grohne> the Yesod book says "their usage requires either quasiquotation or Template Haskell". Is quasiquotation available on platforms without ghci? (TemplateHaskell clearly is not)
23:47:20 <merijn> grohne: Quasiquotation is a form of TemplateHaskell, so presumably not
23:49:08 <grohne> merijn: that's what I thought as well, so I was only slightly confused about the way the yesod book put it. thanks for clarifying
23:49:54 <Polarina> When I Ctrl+C my program, which thread will receive the signal?
23:51:13 <merijn> Polarina: Mu
23:51:26 <merijn> Polarina: That's the wrong question :)
23:51:46 <macalimlim> hello what soap client library would anyone recommend? :)
23:52:10 <merijn> Polarina: I'm not entirely sure what the RTS does, but my educated guess is that it blocks them in all threads except for a dedicated blocking one
23:52:29 <merijn> Polarina: But since haskell threads don't correspond to OS threads anyway, this is all rather irrelevant
23:52:56 <Polarina> merijn, I'm not interested in which OS thread gets the signal, but in which Haskell thread the exception is thrown to.
23:53:26 <merijn> I don't know if it even throws an exception, the most reliable way to gain control would be to just install your own handler
23:53:37 <salamanderpie> I created a function as baby.hs, saved it in the bin folder of GHCi and when I type | :1 baby | I keep getting an error message of | unknown command `1`
23:54:02 <merijn> salamanderpie: Are you perhaps confused and misreading the ":l" in tutorials?
23:54:14 <merijn> salamanderpie: ":l" is short for ":load"
23:54:35 <merijn> There is no ":1"
23:54:55 <merijn> salamanderpie: Also, you'll want ":l baby.hs", rather than ":l baby"
23:55:09 <salamanderpie> The "|" isn't in the command, I just used it to separate the example from the rest of my text.
23:55:48 <macalimlim> hello what soap client library would anyone recommend? :)
23:55:51 <merijn> Polarina: Anyway, in the past I just installed a handler that wrote to a TVar and had my own code haskell code block on that
23:56:17 <merijn> Polarina: Alternatively, you can install a handler the explicitly throws to a specific thread
23:57:56 <emmanueloga> Hi. Ceylon has types that allow specifying a list of one or more elems (e.g. {Integer+} list = {1,2,3}; vs zero or more elems {Integer*} list = {}; as seen here: http://ceylon-lang.org/documentation/1.1/tour/sequences/). I was wondering how one would do this in haskell (encode a type for lists that have at least one elem). My first answer is a custom data
23:57:56 <emmanueloga> type... but then you could not use any of the handy std lib stuff for lists.
23:58:30 <Polarina> merijn, I don't think I'll need any fine grained control as to which thread gets the exception. I'm simply trying to narrow down a bug in my program that happens when I do a Ctrl+C. I'm trying to map the flow of all the cleanup handlers.
23:58:31 <emmanueloga> Maybe the answer is you don't really need that if your relevant functions return Maybe values...
23:58:42 <Polarina> merijn, for some reason, they seem to be running in the incorrect order.
23:58:49 <macalimlim> hello what soap client library would anyone recommend? :)
23:58:58 <merijn> Polarina: I would guess that it throws an exception to either main or an arbitrary thread
23:59:29 <merijn> emmanueloga: Check out Liquid Haskell :)
23:59:59 <macalimlim> hello what soap client library would anyone recommend? :)
