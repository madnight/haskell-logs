00:25:34 <RayNbow> > sequence []
00:25:35 <lambdabot>  No instance for (GHC.Show.Show (m0 [a0]))
00:25:35 <lambdabot>    arising from a use of ‘M786516773776861369426421.show_M7865167737768613694...
00:25:35 <lambdabot>  The type variables ‘m0’, ‘a0’ are ambiguous
00:25:35 <lambdabot>  Note: there are several potential instances:
00:25:35 <lambdabot>    instance [safe] GHC.Show.Show a =>
00:27:05 <RayNbow> hmm, if I type `sequence []` in GHCi, I get back []?
00:28:11 <RayNbow> does anyone have a clue how GHCi got to that answer?
00:28:18 <trap_exit> is the surface pro 3 useful at all for ocding in haskell? i.e. does having a touch screen make coding in haskell easier / better ?
00:29:11 <dfeuer_> :t sequence []
00:29:12 <lambdabot> Monad m => m [a]
00:29:29 <chaosmasttter> RayNBow: I think ghci uses IO as the monad.
00:29:33 <dfeuer_> RayNbow, I would guess that it's guessing your Monad is IO.
00:39:17 <RayNbow> chaosmasttter, dfeuer_: ah, right... I was already wondering which m GHCi was using
00:39:25 <RayNbow> completely forgot about IO :p
00:40:53 <dfeuer_> It seems a bit of a strange default, but maybe not so strange in context?
00:41:46 <dfeuer_> If you type   return 3   at the prompt, it'll execute that as IO and then print the result.
00:47:48 <chaosmasttter> yeah in ghci you are really working in the IO monad so you can do 'content <- readFile filepath'
00:49:01 <jle`> s/really/kinda maybe sorta :)
00:50:42 <comerijn> jle`: What's kinda maybe sorta about it?
00:51:12 <jle`> it's very much unlike the IO monad except in isolated circumstances
00:51:50 <jle`> defining data types...instances...importing modules... :t, :b, :k...
00:52:10 <jle`> i think it's more unlike an IO do block than like it
00:53:19 <comerijn> That's all new nonsense :p
00:53:30 <jle`> :p
00:53:42 <comerijn> until very recently you couldn't define data, instances or imports, etc.
00:53:52 <comerijn> Anyhoo, bed time
00:53:56 <jle`> night :)
00:57:39 <chaosmasttter> I've got a question about the free monad: is there a better way to deconstructing a 'Free f a' to some 'b', than 'iter f . fmap g'?
00:58:29 <chaosmasttter> i only have a function :: f b -> b but not of f a -> a
01:21:08 <tinyblak_> :t curry
01:21:09 <lambdabot> ((a, b) -> c) -> a -> b -> c
01:21:19 <tinyblak_> :t uncurryM
01:21:20 <lambdabot>     Not in scope: ‘uncurryM’
01:21:20 <lambdabot>     Perhaps you meant ‘uncurry’ (imported from Data.Tuple)
01:21:23 <tinyblak_> :t uncurry
01:21:24 <lambdabot> (a -> b -> c) -> (a, b) -> c
01:42:59 <u-ou> what does this mean: {-# INLINE forever #-}
01:43:39 <RayNbow> u-ou: that's a compiler directive to inline the definition of forever
01:43:40 <RayNbow> https://www.haskell.org/ghc/docs/7.0.2/html/users_guide/pragmas.html
01:46:27 <u-ou> what is inlining?
01:48:04 <MP2E> if a function is inlined, then whenever it is applied the compiler will copy and paste the whole function body in to the code where it is used
01:48:36 <MP2E> the compiler automatically inlines small functions but big ones can have bad results, so the compiler generally leaves those alone
01:48:48 <MP2E> but if you have a function you know can be inlined, but maybe doesn't trigger the inline all the time
01:48:48 <u-ou> ahhh
01:48:51 <MP2E> you can use that pragma
01:49:00 <MP2E> I believe INLINEABLE is the one you should generally use though
01:49:03 <MP2E> it suggests to the compiler to inline
01:49:05 <MP2E> but doesn't force it
01:49:09 <MP2E> INLINE forces
01:50:31 <u-ou> is this why the name 'forever' isn't used in its own definition?
01:50:44 <u-ou> i.e. forever a = a >> forever a
01:52:31 <MP2E> I'm actually not 100% sure. I think GHC can handle recursive code in inlines
01:52:47 <MP2E> if I had to guess I think that writing it in a fix style like that allows ghc to optimize more aggressively
01:52:50 <MP2E> but now i'm curious
01:52:51 * MP2E tests
01:52:55 <u-ou> forever a   = let a' = a >> a' in a'
01:56:39 <MP2E> yeah it looks like recursion can get in the way if it isn't written in a mix style like that
01:56:43 <MP2E> i.e. GHC just won't inline your code
01:56:49 <MP2E> fix* not mix
01:57:10 <MP2E> https://www.haskell.org/ghc/docs/7.8.3/html/users_guide/pragmas.html
01:57:18 <MP2E> lots of good info here :)
01:58:14 <u-ou> ahh :)
02:09:20 <jj_> hi folks
02:10:13 <MP2E> hi
02:10:16 <jj_> can someone help me with a cabal problem?
02:11:51 <augur> are there any good tutorials for doing prolog-style logic programming in haskell?
02:12:08 <augur> like, tutorials on implementing it (not necessarily efficiently)?
02:12:30 <jj_> maybe "minikanren"
02:22:45 <vlatkoB> I have a sum type with many constructors (T a = A a | B a | ...) and function that tuples values and matches only the same constructors. Is there a way to specify that arguments must be the same constructor and avoid writing all pattern matches f (A x) (A y) = A (x,y), f (B x) (B y) = B (x,y)?
02:51:20 <hexagoxel> vlatkoB: how about `data TType = A | B | ...` and `data T a = T TType a`
02:56:54 <hexagoxel> (because then f is easy to write)
03:08:51 <vlatkoB> hexagoxel: Indeed, thanks.
03:21:09 * hackagebot scion-browser 0.3.5 - Command-line interface for browsing and searching packages documentation  http://hackage.haskell.org/package/scion-browser-0.3.5 (JeanPhilippeMoresmau)
03:36:10 * hackagebot bullet 0.2.4 - A wrapper for the Bullet physics engine.  http://hackage.haskell.org/package/bullet-0.2.4 (CsabaHruska)
04:11:25 <vlatkoB> Would this solution for checking constructor equality be considered an ugly hack:
04:11:25 <vlatkoB> f a b = if (const () <$> a) == (const () <$> b) then Just $ (val a,) <$> b else Nothing
04:32:26 <Guest-3315> kk
04:40:39 <osa1> can anyone help me with this http://stackoverflow.com/questions/26803443/haskell-network-sockaddrinet-which-endianness-to-use ?
04:52:40 <chrisdone> i converted Typing Haskell in Haskell to markdown https://gist.github.com/chrisdone/0075a16b32bfd4f62b7b added syntax highlighting =)
05:21:19 * hackagebot cql-io 0.10.1 - Cassandra CQL client.  http://hackage.haskell.org/package/cql-io-0.10.1 (ToralfWittner)
05:31:38 <tryuntildeadthen> Hello, is it okay if I ask questions about haskore-vintage or euterpea here?
05:35:11 <sivteck> trydietryagain, just ask ;)
05:38:53 <trydietryagain> okay, I finished a homework by translating music notes into haskell and playing them. I am finished with that. Now they want a code implemented which counts the music's beat. Specifically 1/4 beats. I could compose someone a new symphony, but this question has stumped me. Are there any functions beside length that I could use without too many tears?
05:40:24 <wei2912> trydietryagain: counts the music's beat, as in tempo?
05:40:34 <wei2912> trydietryagain: wait nvm
05:42:12 <trydietryagain> uh... there's this music sign, then a certain beat (here 4/4) to set the notes, specifically, there are 4 whole notes per full beat. Wait, let me draw a pic and show you
05:50:09 <trydietryagain> just a moment, it's uploading
05:51:42 <freeman42> anyone knows if there is any documentation/tutorial for using the Eclipse FP GUI test runner?
05:53:25 <trydietryagain> http://www.directupload.net/file/d/3800/qegvydga_jpg.htm and http://lpaste.net/113934
05:53:55 <trydietryagain> please use adblock while viewing the imageviewing page
06:08:21 <n9490> Why is Haskell so cool？
06:09:10 <banister> n9490 cos it makes the girls go w00
06:10:29 <n9490> What？
06:11:15 <dpn`> it's a good question to google
06:11:32 <dpn`> there's lots of good things about haskell
06:11:41 <dpn`> lots of people have written those things down
06:12:35 <trydietryagain> what dpn said. Actually the best thing would be to start programming right away and see if it suits your fancy.
06:15:08 <n9490> So…try die try again？:)
06:15:19 <capisce> Haskell isn't cool, you know what's cool? A thousand Haskells
06:21:20 <n9490> What are you guys use Haskell for？
06:24:29 <rola> What types can't quickcheck check?
06:24:43 <saep> n9490: It is a general purpose language. You can use it for almost anything.
06:24:57 <benzrf> rola: ones without a proper instance
06:25:13 <ClaudiusMaximus> n9490: i mostly seem to use it for exploring maths and graphics (see http://mathr.co.uk/blog/haskell.html )
06:25:15 <saep> rola: Types that do not hava a `Gen` typeclass.
06:25:31 <saep> s/typeclass/instance
06:27:13 <rola> saep, thanks
06:27:18 <saep> Oh, wait `Arbitrary` that. (I'm too confused)
06:28:09 <saep> rola: It is not really difficult to create those instances, see e.g. https://github.com/saep/saeplog/blob/master/test-suite/Web/Saeplog/Crawler/MetaCombinerSpec.hs
06:29:34 <n9490> saep,ClaudiusMaximus,thx:)
06:30:59 <ClaudiusMaximus> n9490: for a broader picture of what people use haskell for, see http://planet.haskell.org/
06:31:14 <osa1> I can
06:32:05 <osa1> I can't load my project's test suite to cabal repl because it's also trying to load library and it's failing to do so, any ideas how to load only the test suite to cabal repl?
06:32:41 <osa1> to be more specific: it's trying to load "library" part too, but it's not doing that using dependencies. e.g. it's using test suite's dependencies to load library part
06:33:30 <n9490> ClaudiusMaximus :THANK YOU.
06:37:19 <t-l-o> Hi, I'm playing around with Data.Aeson.Lens. Can someone help me understand this error: http://lpaste.net/113937
06:48:34 <roconnor_> t-l-o: I can help
06:51:15 <t-l-o> roconnor_: Thanks, any hint appreciated
06:52:41 <roconnor_> also try (j ^. key "noObject" . key "attr_str" . _String) and (j ^. key "noObject" . key "attr_str" . _Integer).  Try that and I will then explain.
06:53:03 <roconnor_> but first tell me what you get
06:53:07 <SvenskFisk> How do I make a data type that is either one thing or the other? I have Piece as one data type, and I want a data type Move that is either Piece or Pass, I tried 'data Move = Piece | Pass', but then it says multiple declarations of Piece?
06:53:32 <benzrf> SvenskFisk: you need constructors
06:53:46 <benzrf> SvenskFisk: but you could just use Either
06:54:00 <roconnor_> SvenskFisk: all your constructor names have to be unqiue per module.
06:54:50 <t-l-o> roconnor_: first one gives "", and second one gives same error as in my paste
06:55:06 <saep> > mempty :: String
06:55:07 <lambdabot>  ""
06:55:14 <saep> > mempty :: Integer
06:55:16 <lambdabot>  No instance for (Data.Monoid.Monoid GHC.Integer.Type.Integer)
06:55:16 <lambdabot>    arising from a use of ‘Data.Monoid.mempty’
06:56:14 <hyPiRion> SvenskFisk: You can use 'data Move = Move Piece | Pass'. To "convert" a Piece to a Move, do 'Move (construct my piece)'
06:56:18 <roconnor_> t-l-o: good.  So this is what is going on:  (key "someObject" . key "attr_str" . _String) is what is known as a prism.  It is a reference to 0 or 1 values.  In otherwords it is a reference to a value that may not exist (like in the "noObject" case).
06:57:06 <roconnor_> t-l-o: when you use ^? on a prism you get back a Maybe value that either Just holds the value, in the case that the reference exists, or Nothing is case the reference doesn't exist.
06:57:22 <SvenskFisk> hyPiRion: Cool, how do I get the piece back out of the move after that?
06:57:56 <roconnor_> t-l-o: when you use ^. on a prism, it tries to use a Monoid instance to get a default value (using memtpy) in the Nothing case.
06:58:21 <biinui> hello i'm a newbie, do i just ask a question right away even though there's a back and forth going on? :)
06:58:23 <roconnor_> tlevine: as saep noted above, for Strings the empty string is the value for mempty so that works for strings.
06:58:31 <roconnor_> er sorry that was for t-l-o
06:58:49 <SvenskFisk> biinui: Fellow newbie here, that's what I've been doing
06:58:58 <t-l-o> roconnor_: oh... and with integer it's quite difficult to have a default value
06:59:04 <hyPiRion> SvenskFisk: Use pattern matching, like 'case move of (Move p) -> do-something with p; Pass -> do-something when pass'
06:59:06 <roconnor_> t-l-o: but Integers do not have a default Monoid instance.
06:59:35 <SvenskFisk> hyPiRion: Great, I'll try that out, thanks!
06:59:41 <biinui> @SvenskFisk thanks :)
06:59:42 <lambdabot> Unknown command, try @list
06:59:58 <hyPiRion> SvenskFisk: see http://learnyouahaskell.com/syntax-in-functions for more info on pattern matching, and np :)
07:00:38 <roconnor_> t-l-o: you could try something like (sumOf (key "someObject" . key "attr_str" . _String) j) to get a default value of 0 I think.
07:01:14 <t-l-o> roconnor_: ok, got it! thanks very much for this explanation! saep, thanks, too!
07:01:31 <roconnor_> productOf would give you a default value of 1.
07:02:45 <t-l-o> roconnor_: ok, or probably just use maybe
07:04:02 <hsk8> Some of you remember this Monad example in LYAH (the tightrope walker Pierre):
07:04:03 <hsk8> return (0,0) >>= landLeft 1 >>= landRight 4 >>= landLeft (-1) >>= landRight (-2)
07:04:04 <hsk8> My question: If one of these returns Nothing, why does the computation stop? It seems to me the computation would continue anyway and would have to continue, because >>= is infixl
07:04:44 <hsk8> In other words, even if we get one Nothing, the other >>= would still have to be executed, right?
07:04:53 <hsk8> it doesn't "short circuit" on Nothing
07:04:55 <roconnor_> er of course I mean with _Integer not _String
07:04:58 <hsk8> does it?
07:05:10 <biinui> why does
07:05:20 <rai> hsk8: it is executed, but Nothing "bubbles" through
07:05:32 <rai> i'm going through that same chapter at the moment
07:05:40 <biinui> why does "example xs = abs . minimum xs" cause an error?
07:05:54 <biinui> but "example = abs . minimum" works?
07:06:00 <hsk8> rai: yes i imagine it would execute fast, but it would have to be executed though
07:06:04 <biinui> is it with precedence or associativity?
07:06:30 <biinui> i looked up the source of function composition and tried to trace but couldn't figure out
07:06:40 <hsk8> rai: so it's inaccurate to compare this with the case statements isn't it? The case example stops at Nothing
07:07:28 <SvenskFisk> biinui: example xs = abs . minimum $ xs will work, example xs = (abs . minimum) xs will also work
07:07:49 <biinui> does "abs . minimum xs" turn to "\x -> abs (minimum xs x)"?
07:07:50 <rai> hsk8: instance  Monad Maybe  where
07:07:57 <rai>     (Just x) >>= k      = k x
07:07:59 <rai>     Nothing  >>= _      = Nothing
07:08:12 <sohum> is there a nice way to use monad comprehensions to do [ y | x <- returnsLists, y <- returnsMaybe x ] ?
07:08:36 <rai> that's what Maybe instance is like for Monad
07:08:48 <saep> > return (0,1) >> Nothing >> Nothing >> error "Yikes!" >>= return
07:08:50 <lambdabot>  Nothing
07:09:50 <SvenskFisk> I think it's more like "abs . (minimum xs)", and it wouldn't make sense to compose abs with (minimum xs), so you have to make it clear to compose abs and minimum, not abs and (minimum xs)
07:10:07 <hsk8> ok...
07:10:09 <mr_rm> > :t [(/),div]
07:10:10 <lambdabot>  <hint>:1:1: parse error on input ‘:’
07:10:29 <wei2912> :t minimum
07:10:30 <lambdabot> Ord a => [a] -> a
07:10:39 <wei2912> when you type (minimum xs), you don't get back a function
07:10:41 <mr_rm> :t [(/),div]
07:10:43 <lambdabot> (Integral a, Fractional a) => [a -> a -> a]
07:10:47 <wei2912> you get whatever xs is a list of
07:11:13 <mr_rm> can anyone tell me how i would use one of the functions from that list? what sort of value is both Integral and Fractional?
07:11:23 * hackagebot twitter-conduit 0.0.8 - Twitter API package with conduit interface and Streaming API support.  http://hackage.haskell.org/package/twitter-conduit-0.0.8 (TakahiroHimura)
07:11:27 <rai> hsk8: do you see it?
07:11:38 <wei2912> biinui: if you must compose the functions, (abs . minimum) xs, i think
07:11:46 <wei2912> biinui: but you should probably use abs $ minimum xs
07:11:49 <hsk8> rai: yes, but it's still computed. the parameter is just ignored. but it's still computed. Do you have the paper version of LYAH?
07:11:55 <wei2912> > (abs . minimum) [1, 2, 3, 4, 5, -1, -2, -3]
07:11:56 <lambdabot>  3
07:12:01 <rai> hsk8: yep
07:12:05 <wei2912> > abs $ minimum [1, 2, 3, 4, 5, -1, -2, -3]
07:12:06 <lambdabot>  3
07:12:22 <hsk8> rai: okay do you see the "case" example at the bottom of page 279?
07:12:29 <hsk8> where he does the same thing with case expressions
07:12:43 <hsk8> or, supposedly the same thing
07:12:53 <rai> yea
07:13:05 <SvenskFisk> When you do example = abs . minimum, and call example x, it's essentially the same as (abs . minimum) x
07:13:06 <hsk8> rai: but there, it stops completely at Nothing and doesn't continue
07:13:11 <hsk8> so it's not the same
07:13:19 <rai> yea it's not the same, but the result is
07:13:23 <hsk8> ok, i see
07:16:06 <rai> i've got the idea that it's one of the properties in monadic use of maybe that makes it useful
07:16:16 <mr_rm> > (head [(/), div]) 4 3
07:16:17 <lambdabot>  No instance for (GHC.Show.Show a0)
07:16:18 <lambdabot>    arising from a use of ‘M1005111081984379108471.show_M1005111081984379108471’
07:16:18 <lambdabot>  The type variable ‘a0’ is ambiguous
07:16:18 <lambdabot>  Note: there are several potential instances:
07:16:18 <lambdabot>    instance [safe] GHC.Show.Show
07:16:36 <rai> that if one of the computations fail when using bind, you'll just end up with Nothing
07:18:19 <hsk8> rai: what do you mean
07:19:23 <_2_karen17> ola
07:21:23 <biinui> wei2912 sorry i skimmed some beginner commands for irc, is it right to prepend "/notice" to a nickname?
07:21:50 <wei2912> biinui: no
07:22:21 <centromere> thoughtpolice: Hi.
07:22:24 <biinui> wei2912: i just type the nickname and it'll notify you?
07:22:37 <wei2912> biinui: firstly, /notice is usually for bots (or to make announcements in channels). you will want /msg. secondly, freenode IRC etiquette says that you should ask a person if you can PM him bf you do.
07:23:02 <Guest32717>  
07:23:22 <wei2912> biinui: if you're new to #haskell, you should join #haskell-beginners
07:24:08 <rai> hsk8: check this out http://en.wikibooks.org/wiki/Haskell/Understanding_monads
07:24:10 <centromere> thoughtpolice: How's hs-nacl coming?
07:24:14 <rai> hsk8: helped me a lot in understanding monads
07:24:59 <dav1d> hey, I am getting this error "ERROR - Garbage collection fails to reclaim sufficient space" for the code http://vp.dav1d.de/Ijvs?lhs - (getBinaryLen 4) and every number > 4 - why? and how can I fix it?
07:25:02 <hsk8> ok thx
07:25:35 <biinui> wei2912: thanks! i'll read up on etiquette and join beginners channel :)
07:26:26 <dav1d> the code basically creates all binary numbers to a certain length (e.g. [[0,0],[1,0],[0,1],[1,1]]) by adding 0 and 1 to each result of the last recursion
07:26:45 <SvenskFisk> hyPiRion: I tried the pattern matching thing, in a guard I had : " | (Move piece) = someFunction piece", and it said "not in scope : piece"?
07:30:18 <hyPiRion> SvenskFisk: You cannot use pattern matching in guards that way. Guards are just like expressions
07:30:46 <hyPiRion> SvenskFisk: you can use 'foo (Move piece) = someFunction piece' though
07:31:08 <hyPiRion> and then, for completeness, also include 'foo Pass = doNothing' or something like that
07:31:16 <MindIsAVortex> Hi I'm trying to work out the definition of a Monad for an assignment. I kind of get the Monad conceptually but I'm not sure what to do in this particular case as I have to define a Monad that is itself a data type which takes an argument. Look here to see what I mean https://gist.github.com/MindIsAVortex/0a7400a453cd34b20de2 The way I've implemented it doesn't work. I get a parse error in the second definition, like 7 here. Can somebody gi
07:31:33 <SvenskFisk> Oh okay, thanks again!
07:32:08 <vanila>  State' s a >>= k = k a
07:32:10 <vanila> try that
07:33:35 <MindIsAVortex> vanila: now it's saying that Im applying two arguments to State' while it should have one
07:33:59 <EvanR> MindIsAVortex: yeah, any type which is an instance of Monad must be kind * -> *
07:34:10 <EvanR> :k State
07:34:11 <lambdabot> * -> * -> *
07:34:18 <EvanR> :k State Int
07:34:19 <lambdabot> * -> *
07:34:42 <EvanR> :k Maybe
07:34:43 <lambdabot> * -> *
07:35:16 <MindIsAVortex> EvanR, could you further elaborate. I'm not sure what you mean
07:35:33 <saep> MindIsAVortex: What is the definition of `State'` in your gist?
07:35:49 <MindIsAVortex> saep: I'll include it, wait
07:36:23 <MindIsAVortex> saep: https://gist.github.com/MindIsAVortex/0a7400a453cd34b20de2
07:37:06 <EvanR> you said "in this case... data type that takes an argument" im just saying thats every case, with Monad
07:38:28 <MindIsAVortex> Ah rigth
07:42:17 <pjdelport> MindIsAVortex: Note that there are *two* things called State' here: the type-level constructor, and the data (value) constructor.
07:42:34 <pjdelport> "State' s a" is the type
07:42:52 <pjdelport> "State' :: ((s, Counts) -> (a, s, Counts)) -> State' s a" is the value constructor.
07:43:13 <pjdelport> When you pattern-match against values, you're matching against the latter
07:43:43 <pjdelport> So that's why the "(State' s) a" pattern is an error: it's trying to match s and a as two pattern variables, when the constructor only has one.
07:44:28 <pjdelport> Instead, you might want: State' x >>= f = ...
07:44:54 <pjdelport> or: x >>= f = ... and then use runState' against the x value.
07:45:32 <pjdelport> (I'm only using the variable name "x" here to emphasize that it has nothing to do with the "s" and "a" type variables in the type.)
07:53:11 <t7> @hoogle Bool -> a -> [a]
07:53:13 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
07:53:14 <lambdabot> Control.Exception assert :: Bool -> a -> a
07:53:14 <lambdabot> Control.OldException assert :: Bool -> a -> a
07:53:23 <t7> @hoogle Bool -> a -> m a
07:53:23 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
07:53:23 <lambdabot> Control.Exception assert :: Bool -> a -> a
07:53:23 <lambdabot> Control.OldException assert :: Bool -> a -> a
07:53:34 <t7> ah i can filter
07:53:34 <MindIsAVortex> pjdelport: ok, I tried changed it like so then: https://gist.github.com/MindIsAVortex/0a7400a453cd34b20de2 and I'm getting the error that its actual type: (s, Counts) -> (a, s, Counts) cannot be pattern matched with what it's expecting: 'a' Should I pattern match on the whole State' ((s, Counts) -> (a, s, Counts)) then?
07:54:17 <EvanR> @unmtl State
07:54:17 <lambdabot> Plugin `unmtl' failed with: `State' is not applied to enough arguments, giving `/\A B. A -> (B, A)'
07:54:30 <EvanR> @unmtl State Int Char
07:54:31 <lambdabot> Int -> (Char, Int)
07:54:53 <EvanR> @unmtl State a b
07:54:54 <lambdabot> a -> (b, a)
07:58:00 <joneshf-laptop> if i want to use aeson to grab all of the field names in an object, how do i go about that?
07:59:15 <pjdelport> MindIsAVortex: Well, now it's actually more of a semantic question: you have to implement the methods correctly.
07:59:38 <pjdelport> "State' . return . return" isn't a valid implementation of return for State'
07:59:39 <EvanR> joneshf-laptop: do you have the json text, or the Object, or
07:59:54 <joneshf-laptop> EvanR, i want a function :: Value -> [String]
08:00:00 <joneshf-laptop> err
08:00:05 <joneshf-laptop> EvanR, i want a function :: Value -> [Text]
08:00:12 <EvanR> joneshf-laptop: ok, then you just need to deconstruct the Value
08:00:36 <EvanR> pattern match to get the Object hashMap, then use H.keys on the hashMap
08:00:42 <pjdelport> MindIsAVortex: Have you worked through the Functor / Applicative / Monad instances for other types yet?
08:01:34 <EvanR> joneshf-laptop: keys :: HashMap k v -> [k]
08:02:03 <joneshf-laptop> EvanR, i see, so there's nothing premade for this?
08:02:44 <EvanR> you usually dont want to get all the keys from an object by themselves, if its representing a record
08:03:15 <EvanR> your instance would restore a record whole from the object field by field
08:03:45 <EvanR> but really, the Value is really simple to get the stuff you want in raw form if you want
08:04:34 <EvanR> joneshf-laptop: note that your function signature as you wrote it requires that you write a partial function, because Value is not gauranteed by the type system to be a json object
08:04:39 <EvanR> it could be an Array for instance
08:05:04 <joneshf-laptop> right
08:05:09 <EvanR> you can make it total by making it Value -> Maybe [Text]
08:05:16 <EvanR> (actually no you can just return an empty list)
08:05:35 <MindIsAVortex>  pjdelport: I've had a bit of practice but lately it's been real chaotic. Right now this thing needs to get done so I was hoping I could trial/error my way through this assignment :S I have an intuitive understanding of what a state and a monad represent but I could honestly do with more basic practice in this language
08:05:40 <EvanR> but as far as validation goes this is where you would write a better FromJSON instance
08:10:02 <EvanR> :t ffmap
08:10:03 <lambdabot>     Not in scope: ‘ffmap’
08:10:03 <lambdabot>     Perhaps you meant ‘fmap’ (imported from Control.Monad.Writer)
08:11:02 <EvanR> @hoogle (a -> b) -> f g a -> f g b
08:11:02 <lambdabot> Data.Graph.Inductive.Graph emap :: DynGraph gr => (b -> c) -> gr a b -> gr a c
08:11:02 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
08:11:02 <lambdabot> Control.Arrow (>>^) :: Arrow a => a b c -> (c -> d) -> a b d
08:11:12 <pjdelport> MindIsAVortex: I have to run for a bit, i'm afraid, but maybe try #haskell-beginners too, if you stay stuck.
08:11:13 <wei2912> is there some function that runs a function till a condition is satisfied, like a while loop?
08:11:33 <EvanR> untilM
08:11:39 <wei2912> thanks
08:11:41 <wei2912> :t untilM
08:11:42 <lambdabot>     Not in scope: ‘untilM’
08:11:43 <lambdabot>     Perhaps you meant ‘until’ (imported from Prelude)
08:12:00 <pjdelport> MindIsAVortex: For implementing return, maybe avoid point-free style, and just consider how you would implement return x = State' ...
08:12:02 <MindIsAVortex>  pjdelport: ok, thanks for your help
08:12:05 <ClaudiusMaximus> :t unfoldr
08:12:05 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
08:12:18 <EvanR> wei2912: maybe in the monad loops package
08:12:21 <ClaudiusMaximus> wei2912: ^ collects the results too
08:12:23 <pjdelport> MindIsAVortex: For return, you want it to construct a state action that always yields the given value as its result.
08:13:02 <wei2912> EvanR: ClaudiusMaximus okay, thanks
08:13:17 <EvanR> you can always write your own
08:13:29 <MindIsAVortex>  pjdelport: Ok, I'll think about that
08:14:02 <pjdelport> MindIsAVortex: And then for x >>= f, you have a state action x that you have to run to get a value to apply f to, which in turn yields a final state action.
08:14:12 * EvanR wonders how to use unfoldr with a monad to implement an untilM
08:15:23 <pjdelport> MindIsAVortex: Another way of thinking about that is that for x >>= f you'll be building a _combined_ state action that, when it is run, will run both the x action and the action returned by f.
08:15:49 <EvanR> how do i sum over a list of Maybe numbers to get a Maybe number
08:17:15 <notdan> @ty foldM
08:17:16 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
08:17:47 <bitonic_> defanor: there <https://gist.github.com/bitonic/1fd6630f00c6cf1a20e6>.  seems to work.
08:18:03 <defanor> bitonic_: wrong channel?
08:18:05 <EvanR> cant somehow combine sum and fmap/<*> ?
08:18:11 <bitonic_> defanor: indeed ehe
08:18:13 <saep> case catMaybes mns of [] -> Nothing ; ns -> Just $ sum ns
08:18:44 <EvanR> if any are Nothing the result should be Nothing
08:18:57 <pjdelport> EvanR: sum . sequence (or sequenceA, to be more generic)
08:19:08 <EvanR> ah
08:20:00 <EvanR> fmap sum . sequence
08:20:04 <EvanR> :t fmap sum . sequence
08:20:05 <lambdabot> (Num b, Functor f, Monad f) => [f b] -> f b
08:20:09 <EvanR> hot damn
08:20:14 <pjdelport> Right, sorry; fmap sum :)
08:20:31 <notdan> @ty Prelude.foldr1 (liftM2 (+))
08:20:32 <lambdabot> (Num a1, Monad m) => [m a1] -> m a1
08:20:41 <pjdelport> :t fmap sum . sequenceA
08:20:42 <lambdabot>     Not in scope: ‘sequenceA’
08:20:42 <lambdabot>     Perhaps you meant one of these:
08:20:42 <lambdabot>       ‘T.sequenceA’ (imported from Data.Traversable),
08:20:46 <pjdelport> :t fmap sum . T.sequenceA
08:20:47 <lambdabot> (Applicative f, Num b) => [f b] -> f b
08:20:48 <notdan> oh yeah, sequence is a nice one
08:21:03 <EvanR> :t T.sequenceA
08:21:04 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
08:21:24 <pjdelport> EvanR: It's just like sequence, but not specialized to lists and Monad only.
08:21:50 <EvanR> is there one which is just lists and applicative?
08:22:05 <pjdelport> You can just specialize sequenceA to lists if you want. :)
08:22:28 <EvanR> so sequence doesnt have anything to do with monads?
08:22:40 <EvanR> specifically
08:22:41 <pjdelport> Well, Monad is just a specialization of Applicative.
08:23:06 <pjdelport> Applicative is the minimum you need for sequence to work; it doesn't need Monad's joining functionality.
08:23:09 <pjdelport> Hence sequenceA
08:23:17 <EvanR> thats awesome
08:23:24 <pjdelport> (sequence itself just predates Applicative, historically)
08:23:42 <EvanR> @src sequence
08:23:42 <lambdabot> sequence []     = return []
08:23:42 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
08:23:42 <lambdabot> --OR
08:23:42 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
08:24:01 <pjdelport> sequence = sequenceA :: Monad m => [m a] -> m [a]
08:24:17 <EvanR> trying to understand how the top version can work without >>=
08:24:20 <pjdelport>  (modulo some AMP :)
08:25:15 <pjdelport> EvanR: That's actually a really nice presentation of sequence: you know how "foldr (:) []" is the identity function for lists?
08:25:55 <pjdelport> That is, it replaces each (:) with (:), and each [] with []
08:26:13 <EvanR> yeah
08:26:16 <bitonic> pjdelport: sequence and sequenceA do different things though -- one uses ap and the other uses >>=
08:26:17 <pjdelport> Now, consider what happens if you just happen to lift each of those constructors: foldr (liftA2 (:)) (pure [])
08:26:38 <bitonic> well, could do different things anyway
08:26:43 <pjdelport> (bitonic: Right; that's why i said "modulo some AMP")
08:26:45 <bitonic> for many monads/applicatives it matters
08:26:51 <bitonic> pjdelport: oh, ok :)
08:26:55 <EvanR> whats AMP
08:27:09 <pjdelport> https://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
08:27:15 <bitonic> I just wish the monadic sequence and sequence-like functions would die
08:27:23 <osa1> can I share a socket with different threads and call recvFrom and send listed here http://hackage.haskell.org/package/network-2.6.0.2/docs/Network-Socket-ByteString.html ?
08:27:54 <EvanR> osa1: yes
08:28:04 <osa1> thanks
08:28:35 * pjdelport aways for real; be back in a bit!
08:28:47 <EvanR> :t (>>=)
08:28:48 <lambdabot> Monad m => m a -> (a -> m b) -> m b
08:28:51 <EvanR> :t ap
08:28:52 <lambdabot> Monad m => m (a -> b) -> m a -> m b
08:29:25 <exio4> :t (<*>)
08:29:26 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
08:29:40 <EvanR> :t liftA2
08:29:41 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
08:31:04 <EvanR> > liftA2 (:) (Just 3) [Just 4, Just 5]
08:31:05 <lambdabot>  Couldn't match type ‘[]’ with ‘Data.Maybe.Maybe’
08:31:06 <lambdabot>  Expected type: Data.Maybe.Maybe [a]
08:31:06 <lambdabot>    Actual type: [[a]]Couldn't match expected type ‘[a]’
08:31:06 <lambdabot>              with actual type ‘Data.Maybe.Maybe a0’Couldn't match expected ty...
08:31:06 <lambdabot>              with actual type ‘Data.Maybe.Maybe a1’
08:32:00 <EvanR> > (:) <$> (Just 3) <*> [Just 4, Just 5]
08:32:02 <lambdabot>  Couldn't match type ‘[]’ with ‘Data.Maybe.Maybe’
08:32:02 <lambdabot>  Expected type: Data.Maybe.Maybe [a]
08:32:02 <lambdabot>    Actual type: [[a]]Couldn't match expected type ‘[a]’
08:32:02 <lambdabot>              with actual type ‘Data.Maybe.Maybe a0’Couldn't match expected ty...
08:32:02 <lambdabot>              with actual type ‘Data.Maybe.Maybe a1’
08:32:07 * EvanR gives up
08:32:29 <joneshf-laptop> EvanR, what are you trying to do?
08:32:44 <EvanR> prepend the maybe value to that list
08:33:08 <EvanR> the types dont make sense so nevermind
08:33:14 <notdan> > (:) <$> Just 3 <*> Just [1,2]
08:33:16 <lambdabot>  Just [3,1,2]
08:33:30 <benzrf> :t (<**>)
08:33:31 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
08:33:33 <EvanR> good call
08:33:51 <notdan> > (:) <$> Just 3 <*> sequence ([Just 1, Just 2])
08:33:52 <lambdabot>  Just [3,1,2]
08:34:13 <EvanR> just list is what i wanted
08:34:27 <EvanR> not list just
08:35:02 <notdan> ok :)
08:37:06 <t7> @hoogle [Maybe a] -> Maybe [a]
08:37:06 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
08:37:06 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
08:37:06 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
08:37:24 <JonReed> How can I put something inside the specific monad? E.g., let's say for the same of an experiment I want to put String inside IO monad. I can do "(return "hello world")" and that will put string inside a monad, but how can I specifically put it inside the IO monad
08:37:46 <JonReed> :t (return "hello")
08:37:47 <lambdabot> Monad m => m [Char]
08:38:06 <JonReed> And the goal is IO String
08:38:33 <EvanR> not that a monad is not like a burrito
08:38:51 <geekosaur> specifically for IO you "can't" --- there's a hidden thing that can do so, but IO is designed to *not* allow you to just create an IO context for yourself randomly
08:39:05 <t7> @hoogle [Maybe a] -> [a]
08:39:05 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
08:39:05 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
08:39:05 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
08:39:08 <geekosaur> because for it to work correctly it needs to sequence all IO operations, so they must all be linked
08:39:29 <exio4> @type return ∷ String → IO String
08:39:30 <lambdabot> String -> IO String
08:39:51 <EvanR> JonReed: you didnt explain why return "foo" is not good enough
08:40:01 <exio4> the best I can think of, is just using return?
08:40:14 <geekosaur> yes, which requires being in IO in the first place. if this is not acceptable (they already rejected return) then they're trying to create an IO out of nothing
08:40:29 <EvanR> no, you can do return "foo" anywhere
08:40:42 <EvanR> > return "string" :: IO String
08:40:44 <lambdabot>  <IO [Char]>
08:41:06 <EvanR> he can use that action eventually if it ever makes it to IO
08:42:12 <JonReed> EvanR: Ok. I can do it with a type signature. But let's say I want to do it in one line in ghci
08:42:28 <JonReed> without separate signature like toIO :: String -> IO String
08:42:47 <EvanR> i only used one line
08:43:26 <EvanR> by "put it inside" do you mean print it out? or store it somewhere?
08:43:48 <JonReed> EvarR: Oh ok. It works
08:44:15 <JonReed> EvanR: I meant just making it an IO monad by "putting it inside"
08:44:43 <EvanR> theres other ways this is just the simplest
08:45:07 <EvanR> another way would be to compose two IO actions with >>=, one that writes to a file, then reads it back ;)
08:45:57 <indiagreen> EvanR: why files? I think there should be a service for it
08:46:11 * indiagreen contemplates buying return.io
08:46:28 <EvanR> a key value store!
08:46:48 <EvanR> key, $1.99, value $3.99 while supplies last
08:47:07 <EvanR> _|_ where prohibited
08:51:05 <EvanR> :t (<**>)
08:51:06 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
08:52:03 <osa1> what happens if recvFrom fails because of timeout in Network.Socket?
08:52:11 <EvanR> > Just [1] <**> pure (++) <*> Just [2,3]
08:52:13 <lambdabot>  Just [1,2,3]
08:52:20 <EvanR> osa1: and exception will be raised
08:52:34 <osa1> EvanR: I can't see any exceptions defined in the package
08:52:37 <osa1> EvanR: how do I catch it?
08:52:57 <EvanR> you catch exceptions in IO with Control.Exception catch
08:53:07 <EvanR> which exceptions is a good question
08:53:42 <nvp> in comparison to erlang, in practice, how robust is haskell's strength in concurrency?
08:54:03 <EvanR> haskells concurrency has power level over 2 million
08:54:45 <EvanR> nvp: the thread situation is really good, but out of box monitoring and restarting, killing of "child threads" thats not there
08:54:48 <EvanR> but theres libraries
08:55:05 <EvanR> if the main thread dies, everything dies
08:55:30 <osa1> EvanR: so how do I distinguis socket timeout exceptions from other IOExceptions?
08:55:58 <EvanR> osa1: you just need to know what its called
08:56:39 <quxbam> why does hlint complain about following function:
08:56:44 <EvanR> osa1: what kind of timeout are you talking about, waiting to connect?
08:56:52 <quxbam> number :: Int
08:56:54 <quxbam> number = 2^2
08:57:13 <osa1> EvanR: waiting for server to send my response using UDP
08:57:19 <osa1> there are no connections
08:57:27 <EvanR> osa1: oh, then no timeout will ever happen there
08:57:35 <EvanR> but you can add one
08:57:40 <osa1> EvanR: I'm setting timeout to 1 sec
08:57:44 <osa1> EvanR: to be able to handle other events
08:57:54 <quxbam> it says, defaulting constraints to Integer, but how can i fix this?
08:57:57 <EvanR> wait, setting timeout to 1 where?
08:58:12 <osa1> setSocketOption sock RecvTimeOut
08:58:24 <EvanR> theres a better way to do that
08:58:28 <osa1> what's that?
08:59:22 <EvanR> forkIO a thread dedicated to waiting to recvFrom on that socket, in which case it sends a message to another thread, then repeats until you kill it or it crashes
08:59:25 <geekosaur> quxbam, it's complaining because the :: Int only fixes one of the types. most people just disable the warning about defaulting of numeric literals, because it's generally just noise
08:59:31 <geekosaur> :t (^)
08:59:32 <lambdabot> (Num a, Integral b) => a -> b -> a
08:59:44 <EvanR> then you can "handle other events" without worrying about that
08:59:47 <osa1> EvanR: I really don't like the idea of crashing threads to terminate them
09:00:03 <osa1> EvanR: the problem is that then I can
09:00:12 <silver> nvp, check out clod haskell
09:00:16 <silver> cloud haskell*
09:00:17 <osa1> I can't know whether the thread normally terminated or not
09:00:31 <osa1> because it'll crash in all cases
09:00:36 <quxbam> geekosaur: ah ok, thanks
09:00:51 <geekosaur> so the type of b is not fixed; you could say 2^(2::Int) or you could just compile with -fno-warn-type-defaults
09:01:06 <EvanR> osa1: to more specifically end the thread, you can catch a specific exception dedicated to this purpose
09:01:10 <nvp> EvanR: for eg, in a production environment, can haskell reliably support over 2 million concurrent TCP connections on a server?
09:01:18 <EvanR> osa1: with connected sockets its pretty easy, just close the connection but here you dont have that
09:01:42 <quxbam> interesting
09:01:50 <EvanR> nvp: i didnt know you could have more than ~ 60000 connections due to port space
09:01:58 <osa1> EvanR: also, as far as I know sockets have some default value for timeouts, right? so recvFrom will fail if I don't get any responses for long enough time
09:02:05 <EvanR> osa1: no
09:02:11 <EvanR> that would suck
09:02:15 <osa1> EvanR: so it just waits forever?
09:02:23 <EvanR> i hope so
09:02:39 <EvanR> same as the select system call
09:05:15 <EvanR> osa1: generally in haskell you want to do very little IO interleaving yourself, and instead use threads because its way easier
09:05:30 <nvp> EvanR: yes, there are only some 60000 ports, but Erlang has been used by WhatsApp to obtain > 1 million concurrent TCP connections. I don't understand how they were able to do that.
09:06:27 * hackagebot json-autotype 0.2.2.0 - Automatic type declaration for JSON input data  http://hackage.haskell.org/package/json-autotype-0.2.2.0 (MichalGajda)
09:06:33 <EvanR> nvp: many server programs interleave connections within a given connection, though thats not transparent for direct peers, you can just "connect over" somebody
09:06:43 <EvanR> you cant*
09:07:45 <exio4> I don't get what you are saying, you can have "any" amount of connections per port
09:08:03 <nvp> EvanR: so can Haskell achieve this same result?
09:08:11 <EvanR> ah right, listening port thats different
09:08:31 <osa1> does readChan block when chan is empty?
09:08:37 <EvanR> nvp: i dont think the OS network layer has much to do with haskells IO
09:08:44 <EvanR> osa1: yeah
09:10:02 <hpc> what would it do if it didn't block?
09:10:04 <EvanR> nvp: http://stackoverflow.com/questions/2332741/what-is-the-theoretical-maximum-number-of-open-tcp-connections-that-a-modern-lin
09:10:05 <hpc> :t readChan
09:10:06 <lambdabot> Not in scope: ‘readChan’
09:10:16 <EvanR> hpc: crash !
09:13:08 <osa1> hpc: exceptions
09:13:43 <osa1> even though that doesn't make much sense, you can't be sure since docs don't say anything
09:14:30 <EvanR> the docs explain how Chans work
09:15:04 <nvp> EvanR: thanks for the link; the last line of the stackoverflow link says "The realistic limits being boasted about for normal boxes are around 80K". How then was Erlang used to achieve > 1 million connections?
09:16:35 <EvanR> nvp: well, a single box can be configured with however many IP addresses, which is included in the key criteria describe in that post
09:16:57 <EvanR> and the limit on file descriptors can be configured to go higher
09:17:04 <JonReed> I'll just leave it here https://www.youtube.com/watch?v=73XNtI0w7jA
09:17:05 <EvanR> and that explains the theoretical aspects
09:17:35 <JonReed> The video explains connectios and how linux can have 10 million connections
09:18:36 <EvanR> my poor old bitcoin mining machine would probably crumble under that load
09:19:08 <JonReed> So many connections is only possible without using the kernel, because how linux kernel handles connections is not scalable.
09:20:00 <JonReed> is not possible using kernel*
09:20:58 <EvanR> "without using the kernel"
09:21:07 <EvanR> mkay
09:22:03 <JonReed> EvanR: I had a brain glitch
09:22:34 <EvanR> nvp: so anyway yeah the threads are really fast and ghc io manager is really good, throw what you want at it and see what happens ;)
09:22:35 <benzrf> how do i output haskore music to speakers
09:22:43 <benzrf> and do i need hackages other than haskore to do so
09:23:25 <EvanR> nvp: and i saw this lib https://hackage.haskell.org/package/unagi-chan
09:26:27 <hsk8> Can someone explain when I should use
09:26:27 <hsk8> monadicValue >>= func1 >>= func2 >>= func3 >>= func4
09:26:29 <hsk8> (which is the same as
09:26:30 <hsk8> (((monadicValue >>= func1) >>= func2) >>= func3) >>= func4
09:26:32 <hsk8> and when I should use
09:26:33 <hsk8> monadicValue >>= (func1 >>= (func2 >>= (func3 >>= func4)))
09:26:33 <hsk8> ?
09:27:11 <hsk8> s/(which/which
09:27:44 <benzrf> hsk8: the latter isn't well-typed
09:27:54 <benzrf> (if the former is)
09:28:03 <benzrf> unless i am greatly mistaken
09:28:30 <wei2912> when should i omit type signatures?
09:28:38 <wei2912> and let the compiler infer the type
09:28:49 <vanila> yes
09:28:54 <EvanR> hsk8: if f is a function you usually dont do f >>= g
09:29:08 <nvp> thanks for all the information. Does anyone know of any resources (which shows actual numerical results) comparing haskell concurrency & fault tolerance vs erlang concurrency & fault tolerance?
09:29:40 <hsk8> oh
09:29:45 <hsk8> ok thanks
09:33:13 <JonReed> Is it possible to get the result of a monadic action inside a where clause? Something like the following "print content where content <- readFile "lines.txt", instead of "print =<< content where content = readFile "lines.txt""
09:34:31 <dfeuer_> JonReed, not so much like that, no.
09:35:13 <aristid> JonReed: no, but where print =<< content where content = readFile "lines.txt"
09:35:29 <aristid> oh you mentioned that yourself, lol
09:39:27 <EvanR> you can put parts of your do syntax code in a where clause, it just has to type check. but i found it easier to put stuff in lets in the do block
09:40:25 <wz1000> Has scheme style automatic late binding ever been discussed in the Haskell community? I'm thinking of something like treating functions like modules, with dependencies which satisfy properties enforced be the type system. Type classes are a really unwieldy and inflexible way of achieving similar effects.
09:40:34 <nschoe> hi, fellow haskellers :-)
09:41:03 <EvanR> typeclasses are often not the right answer to stuff youd think it would be in another language
09:41:49 <EvanR> and isnt late binding taken care of by lazy evaluation? at least when it would make sense to care in haskell
09:43:04 <EvanR> wz1000: you also can use a closure to return a record, containing recursive references to that closure, which would simulate oop style
09:43:29 <EvanR> "totally works"
09:44:03 <piranha> I've got a [Maybe Integer], what's the best way to get Maybe [Integer]? (newbie here)
09:44:21 <vanila> catMaybes
09:44:33 <wz1000> :t sequence
09:44:34 <lambdabot> Monad m => [m a] -> m [a]
09:44:58 <piranha> but catMaybes is [Maybe a] -> [a], isn't that not what I need?
09:45:14 <vanila> you can use it to build a function
09:45:25 <piranha> aha, but sequence seems to be what I need...
09:46:34 <piranha> thanks, it works exactly how I wanted
09:46:36 <wz1000> piranha: What do you want to do? There can be many reasonable functions of type ([Maybe Integer] -> Maybe [Integer]). sequence is just one of them that uses Maybe's monadic nature.
09:46:56 <piranha> well, I've got a list of strings which I need to parse in a list of integers
09:47:04 <piranha> and I need to fail if any of them is Nothing
09:47:13 <piranha> and it seems sequence is exactly that
09:47:17 <EvanR> sequenceA ;)
09:47:36 <ReinH> wz1000: what other reasonable functions are there with that type?
09:47:51 <vanila> case catMaybes l of [] -> Nothing ; xs -> Just xs
09:48:03 <ReinH> vanila: that's not how catMaybes works
09:48:11 <ReinH> > sequence [Just 1, Nothing]
09:48:13 <lambdabot>  Nothing
09:48:17 <vanila> :t \l -> case catMaybes l of [] -> Nothing ; xs -> Just xs
09:48:18 <ReinH> > catMaybes [Just 1, Nothing]
09:48:19 <lambdabot> [Maybe a] -> Maybe [a]
09:48:20 <lambdabot>  [1]
09:48:33 <EvanR> "reasonable"
09:48:36 <ReinH> Ah.
09:48:46 <ReinH> Yes. And what others?
09:49:27 <EvanR> representing [] as Nothing or nil in other systems, no end to the pain
09:49:30 <ReinH> (I don't think there are many such functions. I think there are closer to 2 such functions ;)
09:49:48 <JonReed> piranha: You can also use hoogle. E.g. writing "[Maybe a] -> Maybe a" would give you sequence as the first answer.
09:49:53 <vanila> do you have an argument that there aren't more than two?
09:50:02 <piranha> JonReed: oh, thanks!
09:50:15 <piranha> I'm really just starting learning haskell after years of neglecting that :)
09:50:25 <ReinH> vanila: I think it's possible to construct an argument from parametricity, but I'm not sure *I* could do so...
09:51:15 <monochrom> which type?
09:51:20 <EvanR> [Maybe a] -> Maybe [a], this has a huge number of possibilities, most seem useless
09:51:49 <vanila> I guess there are exactly two when you're linear in a - and reject permutations of the list
09:51:51 <ReinH> EvanR: not if we restrict ourselves to total functions
09:52:17 <EvanR> eh
09:52:31 <EvanR> i can replace the Just values any number of times
09:52:35 <EvanR> i can replicate*
09:52:55 <ReinH> EvanR: FSVO "reasonable"? ;)
09:53:03 <EvanR> well yeah
09:53:30 <vanila> I think linearity and keep list elements in order is a sensible restriction
09:53:48 <EvanR> i can Nothing on lists of even length
09:53:55 <EvanR> or prime length
09:54:32 <wz1000> What about sequential failures transform into non inclusion, rather than complete failure? There are an infinite permutations of this.
09:55:05 <ReinH> wz1000: I think there are roughy two interesting functions [Maybe a] -> Maybe [a]
09:55:23 <EvanR> hehe, at least two nothings in a row means the next just is dropped
09:55:23 <ReinH> There are a lot of other functions that you would probably never use.
09:55:58 <vanila> If you restrict the functions to not throw away any list elements or reorder them there will be two functions
09:56:07 <vanila> not throw away or duplicate*
09:56:32 <wz1000> vanila: You are throwing all the nothings away.
09:56:35 <EvanR> is that really different from just saying, these two are the only two we allow
09:56:47 <vanila> wz1000, yeah I mean linear on the 'a's
09:57:04 <ReinH> EvanR: Well, I'm "allowing" all the rest, but it's unlikely someone would ask for one of them. ;)
09:57:39 <ReinH> "Can someone give me a function [Maybe a] -> Maybe [a]?" "You mean sequence?" "No I mean the one that gives Nothing if the list length is a multiple of 13"
09:57:51 <benzrf> ReinH: lol
09:57:57 <vanila> ReinH, It took a lot of work to come up with a reasonable critera and argument for why therre are only two such functions
09:57:57 <Zekka> ReinH: That's a pretty impotant primitive
09:58:09 <benzrf> oops i accidentally pm'd you sorry
09:58:10 <ReinH> vanila: yes, that's because I was wrong :)
09:58:41 <monochrom> the condition "length is a multiple of 13" leads to a partial function
09:58:50 <benzrf> ReinH: what was your interesting choice besides sequence
09:59:00 <monochrom> similarly "even length", "length is a prime number"
09:59:15 <Zekka> monochrom: Because they aren't defined on infinite lists?
09:59:20 <monochrom> right
09:59:23 <wz1000> Ah, for lists of infinite length
09:59:30 <ReinH> benzrf: vanila's: case (catMaybes xs) of [] -> Nothing; xs -> Just xs
09:59:38 <Zekka> You'll never return the *wrong* value!
09:59:38 <wz1000> what about length < 6
09:59:39 <ReinH> monochrom: good point
09:59:45 <EvanR> it would give you bottom
10:00:16 <benzrf> :t even
10:00:17 <lambdabot> Integral a => a -> Bool
10:00:25 <ReinH> Although vanila's is isomorphic to catMaybes
10:00:28 <EvanR> > const (Just []) :: [Maybe a] -> Maybe [a]
10:00:29 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
10:00:30 <lambdabot>    arising from a use of ‘M53677257099190713963553.show_M53677257099190713963...
10:00:30 <lambdabot>  The type variable ‘a0’ is ambiguous
10:00:30 <lambdabot>  Note: there are several potential instances:
10:00:30 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
10:00:31 <benzrf> > even infinity
10:00:35 <lambdabot>  mueval-core: Time limit exceeded
10:00:36 <EvanR> :t const (Just []) :: [Maybe a] -> Maybe [a]
10:00:37 <lambdabot> [Maybe a] -> Maybe [a]
10:01:04 <EvanR> zero is even so by symmetry, infinity is even ;)
10:01:05 <wz1000> :t const Nothing
10:01:06 <lambdabot> b -> Maybe a
10:01:19 <monochrom> literally "length xs < 6" will still lead to a partial function. but you can write a lot of pattern matching to test "length is less than 6" totally
10:01:20 <ReinH> EvanR: infinity is not a number
10:01:47 <yukko> infinity is just a theory
10:01:48 <exio4> monochrom: lets get a lazy length using peano numbers? ;P
10:01:53 <wz1000> ReinH: You can treat it like one in many cases.
10:01:53 <ReinH> yukko: numbers are just a theory
10:01:54 <EvanR> > (1/0) == (0/0)
10:01:56 <lambdabot>  False
10:01:59 <EvanR> ReinH: ^
10:02:01 <ReinH> wz1000: no, you cannot
10:02:11 <ReinH> EvanR: That is not infinity.
10:02:14 <vanila> sequence is a general function for any monad, the catMaybes one only exists for this particular type
10:02:20 <EvanR> > (1/0)
10:02:21 <lambdabot>  Infinity
10:02:23 <Zekka> In what cases is it alright to treat it as one?
10:02:26 <vanila> so you can forgive me for mistakenly thinking this is what they wanted
10:02:29 <ReinH> I realize it's *called* infinity.
10:02:32 <wz1000> ReinH: You can order it with respect to numbers and you can check for equality.
10:02:37 <ReinH> It is not infinity
10:02:40 <monochrom> yeah, genericLength with peano number works too
10:02:59 * ReinH sighs
10:03:04 <ReinH> No. Yoi cannot.
10:03:06 <ReinH> *you
10:03:32 <exio4> > (1/0) == (1/0)
10:03:33 <ReinH> Well, you can in some number systems
10:03:34 <lambdabot>  True
10:03:40 <exio4> > (1/0) == (2/0)
10:03:42 <lambdabot>  True
10:03:44 <ReinH> like the extended reals
10:03:59 <wz1000> ReinH: Would you accept that [()] is a valid representation for natural numbers?
10:04:01 <monochrom> Int is clearly not extended integers
10:04:23 <EvanR> data Nat = Z | S Nat, no need for the ()
10:04:29 <vanila> wz1000, that's a tricky question: you can certainly embed natural numbers in it -- but there's the infinte number
10:04:33 <vanila> same problem applies to EvanRs definition of course
10:04:34 <monochrom> whereas IEEE754 is clearly extended rounded numbers
10:04:39 <vanila> omega = () : omega
10:04:39 <vanila> or
10:04:41 <ReinH> But all that is *really* doing is adjoining a value to the set, giving it the properties of top wrt max, and calling it infinity
10:04:41 <vanila> omega = S omega
10:05:02 <vanila> and of course if you want to get technical there are undefineds lurking, but let's not think about that..
10:05:06 <wz1000> EvanR: They are isomorphic and [()] is more concise.
10:05:23 <Zekka> ReinH: How is that different from infinity?
10:05:33 <vanila> The key thing about the natural numbers is that each one of them is finite
10:05:40 <EvanR> ReinH: yeah so elements of this or that space called infinity, you are saying, should be kept distinct from some other concept
10:05:55 <EvanR> wz1000: and [((),())]
10:06:23 <ReinH> division by zero does not *really* give infinity.
10:06:26 <ReinH> It is undefined
10:06:35 <ReinH> 1/0 in Haskell is a hack
10:06:46 <Zekka> ReinH: In the sense that giving Infinity breaks the laws relating division and multipliation?
10:06:51 <exio4> > 1 `div` 0
10:06:52 <lambdabot>  *Exception: divide by zero
10:06:52 <vanila> yeah, there's no way to make divison by zero work
10:06:58 <EvanR> in idris, 0 `div` 0 is 1 ;)
10:06:58 <exio4> the ✔ answer ^
10:06:59 <Zekka> i.e. if 1/0 is Infinity, Infinity * 0 ought to be 1?
10:07:04 <vanila> the problem is that x*0 = y*0 doesnt imply that x = y
10:07:15 <vanila> it's the only real number with this property
10:08:04 <ReinH> Zekka: Basically, yes
10:08:18 <monochrom> clearly, 0 and extended real infinity are exempted from the reciprocal law
10:08:29 <vanila> and (2/0)*0 = 2? Impossible to have both
10:09:13 <Zekka> Can't you find a similar one for infinity and +/-?
10:09:25 <Zekka> if 1 + Infinity is Infinity, then Infinity - Infinity should be 1?
10:09:32 <SvenskFi1k> How do I do a 'catch-all' case in haskell? If I use otherwise it says I'm overshadowing the binding
10:09:41 <Zekka> with the exception that +/- don't have a case like (/0) to tempt people into introducing infinity
10:09:47 <Zekka> SvenskFi1k: otherwise and _ are correct, I thought
10:09:53 <EvanR> not otherwise
10:09:54 <Zekka> er, wait
10:09:54 <EvanR> _
10:09:58 <Zekka> otherwise is only for guards, isn't it?
10:09:59 <EvanR> > otherwise
10:10:01 <lambdabot>  True
10:10:11 <Zekka> Oh, really? I thought it was syntax!
10:10:20 <EvanR> no, its True
10:10:20 <ReinH> The extended reals are a rather strange thing: The reals plus two elements (called +inf and -inf) that *are not real numbers*.
10:10:21 <wz1000> SvenskFi1k: use _ if you don't care about the value, <some variable name> in case you do.
10:10:40 <Zekka> ReinH: What are they good for?
10:10:41 <biglama> hi guys, can someone explain me the pros of stackage ?
10:10:46 <SvenskFi1k> Oh got it, I used _ and that works, thanks!
10:10:48 <wz1000> SvenskFi1k: I'm assuming you are talking in the context of pattern matchings.
10:10:51 <EvanR> ReinH: and then theres one point compatification of the reals
10:10:53 <biglama> does "stable" means there are no dependencies conflicts ?
10:10:58 <EvanR> so you dont have two add two things ;)
10:11:17 <wz1000> @src const
10:11:17 <lambdabot> const x _ = x
10:11:26 <wz1000> SvenskFi1k: ^
10:12:12 <wz1000> @src sum
10:12:12 <lambdabot> sum = foldl (+) 0
10:12:19 <wz1000> @src map
10:12:19 <lambdabot> map _ []     = []
10:12:19 <lambdabot> map f (x:xs) = f x : map f xs
10:12:29 <EvanR> foldl <_<
10:12:37 <EvanR> wtf
10:12:51 <wz1000> SvenskFi1k: ^^^
10:13:29 <EvanR> > foldl (+) 0 [1..1000]
10:13:30 <lambdabot>  500500
10:13:33 <EvanR> > foldl (+) 0 [1..100000]
10:13:35 <lambdabot>  5000050000
10:13:40 <EvanR> nevermind works great
10:13:45 <monochrom>  @src is handwritten by a hobbyist and is neither authoritative nor practical
10:13:54 <zikome> My Agda has broken, can anyone help me fix it?
10:14:20 <Zekka> zikome: Is this the opening to a joke or do you have an actual problem with Agda? Because if it's the opening to a joke I have a feeling it's a funny one
10:14:26 <ReinH> Zekka: the arithmetic operations on the extended reals are extended with special rules for +inf and -inf and yes, you don' t have the peano axioms.
10:15:19 <zikome> I'm trying to load any file in emacs (C-c C-l) and it says '/usr/share/agda-9999/ghc-7.8.3/lib/prim/Agda/Primitive.agdai: removeLink: permission denied (Permission denied)'
10:15:33 <zikome> Zekka, actual problem :(
10:15:55 <zikome> I even don't have any ideas what have gone wrong
10:15:59 <Zekka> zikome: I don't know either, sorry
10:16:04 <wz1000> Why does error exist? It just serves to promote bad practices.
10:16:44 <sivteck> computers are fallible being
10:16:47 <sivteck> ss
10:16:58 <ReinH> But 1/0 does not give +inf on the extended rules. AFAIK, it's a meaningless statement in every commonly used axiomatic system, much like exists P, forall x. P(x) v ~P(x)
10:16:59 <Zekka> I think he means "why not something that puts the errors in the type?"
10:17:11 <Zekka> ReinH: Yeah, I just looked it up and 1/0 is still undefined
10:17:27 <SvenskFi1k> wz1000: Great, thanks for the help!
10:17:41 <EvanR> wz1000: you dont have to use it if your function is total, but
10:18:11 <EvanR> if it isnt its better to have a message rather than "non exhaustic pattern match"
10:18:12 <monochrom> error exists because there were people on the committee who accept partial functions and you were not there to fight them
10:18:32 <SvenskFi1k> How do I debug an infinite loop in Haskell? In python it would give me a trace of where it's getting stuck, but haskell doesn't give me anything after I terminate, any advice?
10:18:34 <int-e> > cycle [] -- I much prefer this result to non-termination
10:18:36 <lambdabot>  *Exception: Prelude.cycle: empty list
10:18:44 <wz1000> monochrom: I have no problem with undefined as it currently exists.
10:18:59 <EvanR> undefined is even worse to use in practice
10:19:05 <Zekka> wz1000: Shouldn't you? It has the same semantics as "error "nope!!!""
10:19:37 <int-e> wz1000: then you should accept "error" as well, which improves undefined so that one can attach useful information to it.
10:19:41 <monochrom> more generally, a language does a thing you disagree with because the language was made by a different person
10:19:44 <EvanR> SvenskFi1k: ouch. do you at least know the function that is looping
10:19:51 <ReinH> Zekka: Losing the peano axioms and such means that {-inf,+inf} is no longer a field or a ring, or even a group or semigroup ;)
10:20:00 <dbushenko> does anyone have experience with Scotty?
10:20:11 <Zekka> monochrom: That's a given, but I think he wants to know why anyone thought it was a good idea at all
10:20:12 <Phillemann> What's a concise way to convert [(a,b)] to ([a],[b])?
10:20:15 <Zekka> because surely someone must have
10:20:22 <wz1000> Zekka: But it doesn't let you output arbitary messages to the top level. Undefined is a way of proving to the compiler that the code will not terminate.
10:20:24 <dbushenko> I'm just curious how to add session to scotty web-app
10:20:37 <Zekka> wz1000: Wait, how does it prove that to the compiler?
10:20:49 <supki> Phillemann: unzip
10:20:50 <EvanR> haskell had a lot of things to establish without also establishing the end of all partial functions
10:20:53 <Zekka> It says to the compiler "Hey, I'm a real value of type a" and then at runtime throws up instead of evaluating
10:21:16 <Phillemann> supki: Ah, thanks. Didn't think there was a "direct" function.
10:21:23 <Zekka> wz1000: I'm in danger of projecting if I keep trying to interpret your point, so what do you think error should have been replaced by?
10:21:30 * hackagebot linear 1.12.1 - Linear Algebra  http://hackage.haskell.org/package/linear-1.12.1 (EdwardKmett)
10:21:34 <int-e> undefined =  error "Prelude.undefined"
10:21:44 <Zekka> I tend to think a lot of partials should have been rewritten in a way that moves the error to the type, but not all of them
10:21:53 <exio4> error x = unsafePerformIO (putStrLn x >> let x = x in x)
10:21:55 <Zekka> (i.e. head)
10:21:55 <SvenskFi1k> EvanR: I know where it's getting stuck, but that function calls another function, which calls another couple functions, etc. you get the idea. And it only gets stuck after like 5 or 6 calls where it doesn't get stuck, so I can't just put breakpoints in and see if they're reached (if haskell has breakpoints)
10:22:29 <EvanR> SvenskFi1k: you can put printouts, with Debug.Trace
10:22:46 <SvenskFi1k> Oh okay, I'll look into that
10:23:03 <ReinH> Zekka: you can reduce the number of partial functions, but you can't actually do totality checking
10:23:12 <EvanR> look at your system of functions and think really hard why you think it should not loop infinitely ;)
10:23:19 <Zekka> ReinH: Can you clarify what kind of things you acn't do?
10:23:28 <ReinH> Zekka: solve the halting problem
10:23:45 <Zekka> Yeah, I follow
10:23:51 <monochrom> a total function that asks about the length of an input list :)
10:24:10 <exio4> well, you can always throw away turing completeness...
10:24:16 <EvanR> SvenskFi1k: sometimes ghc will give you a <<loop>> error, but it cant always detect it. this kind of failure mode is bad enough that you really need to be careful (in any language) not to go into an infinite loop
10:24:26 <ReinH> exio4: "... in Haskell"
10:24:29 <Zekka> Although, trying to argue wz1000's point, those aren't the cases where 'error' is used, either
10:24:38 <ReinH> exio4: I can definitely write a total programming language.
10:24:58 <Zekka> 'error' is for ases where the programmer explicitly wants to signal a failure and doesn't want to denote it in type
10:25:00 <ReinH> Zekka: all bottoms are equal ;)
10:25:04 <benzrf> how do you define a 'programming lanuage'
10:25:29 <Zekka> ReinH: Nobody defined 'length' to nonterminate! But people defined 'head' to throw up everywhere.
10:25:40 <monochrom> a programming language is a PDF file describing the programming language :)
10:25:43 <wz1000> Zekka: undefined should ideally be defined as 'let x = x in x', which encodes the idea of non termination. But now that you have a standardized value in the namespace that encodes this, why go through all the work of computing the loop, and not just terminate as soon as you see undefined. For a arbitary function, the compiler cannot know when to stop recursing, as to do this you have to solve the halting
10:25:45 <wz1000> problem. But when you use undefined, the compiler 'knows' that what follows is non terminating, and it can safely stop without affecting the semantics of the program.
10:25:59 <benzrf> monochrom: so any self-referential pdf?
10:26:00 <ReinH> Zekka: Yes. We can separate "functions that cannot be total without bottom" from "functions that are unnecessarily partial" ;)
10:26:23 <EvanR> wz1000: an infinite loop is the worst possible to practical "fail to terminate"
10:26:25 <Zekka> ReinH: I though that was what wz was getting at, but let me read his note right here
10:26:51 <Zekka> I feel like he just made a case for "error"
10:27:23 <EvanR> wz1000: and crashing, which sometimes happens, with <<loop>> is the same as error "sorry, the impossible happened because"
10:27:37 <EvanR> as far as your semantics go
10:28:03 <Zekka> I don't understand why you wouldn't support error based on that argument
10:29:13 <ReinH> Zekka: (Any function [a] -> a will be partial, no matter what you call it. head could instead be [a] -> Maybe a, which is total.)
10:29:26 <monochrom> benzrf: I don't think anyone has bothered to define mathematically. would you like a practical definition?
10:29:33 <benzrf> sure
10:29:44 <Zekka> ReinH: Yeah, that's about what I meant, said more generally
10:29:56 <monochrom> a programming language consists of a syntax and a semantics.
10:30:32 <wz1000> Zekka: Because people use it to define partial functions that shouldn't be partial. It actually encourages the process by allowing you to reflect strings to the top level.
10:31:07 <monochrom> I think Landin's "the next 700 programming languages" is a good read for this.
10:31:52 <EvanR> you think people are encouraged to put an expression in their code that unambiguously crashes the entire program?
10:32:07 <EvanR> i think people would try to avoid that
10:32:23 <Zekka> I usually tend to avoid it because I like being able to handle errors
10:32:55 <wz1000> Zekka: My rant over there was in response to your question on how undefined 'proves' to the compiler
10:33:53 <Zekka> wz1000: I tend to think 'prove' is the wrong word but I think I understand you
10:34:16 <wz1000> Zekka: How is it not a proof?
10:34:26 <EvanR> its a missing proof
10:35:28 <Zekka> wz1000: It declares to the runtime system that any implementation would nonterminate
10:35:51 <EvanR> undefined does?
10:35:53 <wz1000> Zekka: Which is what a proof is.
10:35:57 <biglama> hmm strict-concurrency fails to install on my system with "    Could not find module ‘GHC.IOBase’
10:36:06 <biglama> I'm using a custom GHC + stackage
10:36:08 <Zekka> I suppose it would be trivial to prove that a function of the form "error x" would not terminate
10:36:13 <biglama> can anyone help me ?
10:36:13 <EvanR> Zekka: i dont think thats what undefined means
10:36:24 <Zekka> EvanR: It's what wz1000 thinks it means
10:36:54 <vanila> i don't thinkt picking on the word usage to this depth is productive
10:37:44 <EvanR> undefined bypasses the type checker, letting you not have to put a correct term in. there may be a correct term or not
10:38:37 <EvanR> runtime could get stuck there, or better, crash
10:38:51 <wz1000> EvanR: It does not bypass the type checker any more than an arbitary infinite recursion does.
10:39:19 <vanila> curry-howard isomorphism lets us think this way:  proof :: Theorem
10:39:29 <vanila> in that respect undefined can prove any theorem
10:39:46 <vanila> all this tells us is that haskells "logic" is inconsistent (you can prove false for example)
10:39:55 <EvanR> yeah let x = x in x is the same way
10:40:09 <exio4> f x = 1 + f x
10:40:31 <monochrom> a prof once taught me an important lesson on intended use. he asked: "what do people use home phone voice message systems for?" I knew the answer he wanted, and gave it: "to screen calls".
10:40:57 <wz1000> Zekka: The compiler can only halt a program when it knows it to be nonterminating. Knowledge implies proof. usage of undefined proves non termination to the compiler.
10:41:59 <wz1000> Zekka: You can only 'know' something if it has been proven to you.
10:42:09 <monochrom> the idea is that some authority thought up undefined and error for some purpose, but people used it for that purpose and then also some other purposes. after a while, it is futile to disagree on "the" purpose.
10:42:10 <Zekka> wz1000: FYI, I'm still reading but I'm more interested in what other people say in response here than what I have to say
10:42:59 <EvanR> i wish error gave more information than it did
10:43:09 <EvanR> a backtrace or something
10:43:24 <Twey> exio4: That might be fine, for sufficiently lazy (+) ☺
10:43:28 <Twey> (and 1)
10:44:32 <Zekka> Twey: I feel like a Peano player.
10:44:40 <wgh_> Has anyone here used Shelly?
10:44:42 <wz1000> monochrom: We can argue that a particular purpose is something that is not good for some definition of good.
10:45:00 <Zekka> wgh_: No, is it any good?
10:45:22 <Zekka> er, obviously there are probably people here who have used it but I haven't
10:46:21 <exio4> Twey: S (f x)? but then you have g = S g, which ... doesn't make sense
10:46:38 <Zekka> exio4: Aw, what doesn't make sense about it?
10:46:38 <wgh_> Well, I don't really have much experience with it... I'm trying to hack something that uses it, but I haven't used haskell for a couple of years, and was never very good with it.  I'm stuck and I wanted to see if someone could help elucidate something for me.
10:46:43 <wz1000> exio4: It does make sense.
10:47:04 <Zekka> It's just a thing that you can uncons as many Ses as you want off of
10:47:07 <Twey> exio4: Sure.
10:47:10 <monochrom> g = S g makes the same sense as h = 0 : h
10:47:12 <wz1000> exio4: It makes as much sense as cycle [()]
10:47:28 <Zekka> We could always use more S!
10:47:39 <begriffs> Has anyone tried mixing postgresql-simple with hdbc? I want to use the sql COPY command but hdbc doesn't provide it.
10:48:07 <Twey> exio4: You can define an instance Num [()], for example, where the value of the numeral is represented by the number of ()s in the list.  That's a simple implementation of lazy naturals
10:48:13 <EvanR> use postgres-simple
10:48:32 <exio4> Twey: that is the same as data Nat = S Nat | Z; ∞ = S ∞
10:48:43 <Twey> exio4: And then your ‘f x’ represents infinity (for any x: you didn't actually use it)
10:48:43 <Zekka> Twey: Minding the whole cycle [()] issue Rein got into earlier
10:48:45 <Twey> exio4: That's right
10:49:10 <Zekka> if you don't want an infinity then you may run into problems!
10:49:19 <Twey> exio4: You can calculate that 3 < ∞, for example, in finite time
10:49:25 <wz1000> Twey: Funny, ReinH was just arguing that it is not an infinity.
10:49:33 <begriffs> EvanR: the rest of my code uses hdbc because I have to build some extremely dynamic queries and postgresql-simple won't allow it.
10:49:34 <monochrom> if you don't want an infinity, "data Nat = S !Nat | Z" may help
10:49:54 <Twey> Z < Z = False; Z < S n = True; S m < Z = False; S m < S n = m < n
10:50:01 <Twey> wz1000: Oh?  *scrolls up*
10:50:01 <EvanR> begriffs: well, you can use another connection im sure but
10:50:10 <begriffs> Ohh, true
10:50:36 <EvanR> begriffs: really, i dropped hdbc a while back, maybe its better now, but it was hurting badly
10:50:53 <begriffs> Do you remember the problems you ran into?
10:51:08 <EvanR> bugs, memory usage issues
10:51:12 <EvanR> workingness
10:51:41 <EvanR> are you sure you cant convert a string into a query in *-simple?
10:52:44 <Twey> wz1000: I think he was arguing that those aren't the naturals.  Which is fair.
10:52:50 <Twey> (without the bang)
10:53:27 <begriffs> EvanR: simple tries really hard to stop you http://hackage.haskell.org/package/postgresql-simple-0.4.7.0/docs/Database-PostgreSQL-Simple.html#t:Query
10:54:15 <begriffs> I couldn't figure it out. And my problem is that the schemas, tables, and columns of the database are known only at runtime so it's hard for me to use predefined types and queries to access them.
10:55:00 <EvanR> begriffs: what about read?
10:56:04 <begriffs> Query does not derive Read.
10:56:15 <ReinH> n = S n is not a Nu
10:56:21 <ReinH> number :)
10:56:46 <EvanR> its an instance of Read
10:56:56 <begriffs> Oh right there it is
10:57:08 <supki> begriffs: I think you can use the Monoid instance to concatenate a bunch of query fragments
10:57:22 <EvanR> begriffs: and looks like they export the constructor for query, so Query mySQLBS should work?
10:57:52 <EvanR> or that
10:58:15 <EvanR> which means you dont have to remember to escape anything
10:58:26 <begriffs> The monoid thing worked fine, but it was when I tried to use a variable (rather than a string literal) to construct a Query that it had problems
10:58:47 <begriffs> But I could use `read` on a variable maybe to convert it
10:58:55 <EvanR> nah
10:59:12 <EvanR> did you try ? in the table name position?
11:03:48 <begriffs> EvanR: I'll try to make a tiny demo to recreate the problem I remembered with simple.
11:06:32 * hackagebot cabal-lenses 0.4.1 - Lenses and traversals for the Cabal library.  http://hackage.haskell.org/package/cabal-lenses-0.4.1 (DanielTrstenjak)
11:21:32 * hackagebot cabal-cargs 0.7.4 - A command line program for extracting compiler arguments from a cabal file.  http://hackage.haskell.org/package/cabal-cargs-0.7.4 (DanielTrstenjak)
11:21:34 * hackagebot hsimport 0.6.3 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.6.3 (DanielTrstenjak)
11:22:44 <t4nk639> I'm new here. Can I make questions about haskell here?
11:22:47 <vanila> yes
11:22:52 <t4nk639> Cool
11:22:52 <recursion-ninja> please do
11:23:02 <t4nk639> If I have a funcion
11:23:14 <t4nk639> (+++) a b = a + b
11:23:22 <t4nk639> I can write a +++ b
11:23:25 <t4nk639> ?
11:23:27 <Cale> yes
11:23:27 <benzrf> yes
11:23:31 <benzrf> in fact, you can define it as
11:23:34 <benzrf> a +++ b = a  +b
11:23:36 <recursion-ninja> if a & b are of typeclass Num
11:23:37 <benzrf> er, a + b
11:24:05 <recursion-ninja> (+++) Num a => a -> a -> a
11:24:06 <t4nk639> that's better
11:24:08 <kadoban> Or even (+++) = (+)
11:24:27 <t4nk639> And is there a way to ignore one variable?
11:24:40 <t4nk639> for example, i enter +++ 5, and I get 5?
11:24:46 <t4nk639> With thta function?
11:25:25 <t4nk639> Can i give less parameters that the ones needed to a function?
11:25:34 <recursion-ninja> (+++) = const id
11:25:38 <Cale> Yeah, but you'll get a function which will take the remaining parameter
11:26:13 <Cale> > let x +++ y = x + y in map (+++ 10) [1,2,3,4,5]
11:26:14 <lambdabot>  [11,12,13,14,15]
11:26:37 <Cale> (note, when using this "section syntax", the parens are not optional)
11:27:36 <t4nk639> I can write here like in a terminal?
11:27:36 <Cale> > (+ 10) 5
11:27:38 <lambdabot>  15
11:27:40 <t4nk639> let x = 3
11:27:44 <t4nk639> x
11:27:46 <t4nk639> nop
11:28:01 <t4nk639> I'm really new
11:28:09 <Cale> You need to prefix your message with "> " for the bot to recognise it
11:28:23 <Cale> Also, it's expecting an expression, so "let x = 3" won't work on its own
11:28:30 <Cale> > let x = 3 in x
11:28:31 <recursion-ninja> > putStr "hello t4nk639"
11:28:31 <lambdabot>  mueval-core: NotAllowed "These modules have not been loaded:\nL\n"
11:28:32 <lambdabot>  <IO ()>
11:28:35 <Cale> > let x = 3 in x
11:28:37 <lambdabot>  3
11:28:41 <recursion-ninja> > "hello t4nk639"
11:28:43 <lambdabot>  "hello t4nk639"
11:28:50 <t4nk639> In the function you writed there, you are giving to map two parameters, one being a function?
11:29:12 <Cale> yes
11:29:26 <Cale> map takes a function and a list and applies the function to each of the elements of the list
11:29:39 <Cale> > map (\x -> x^2) [1,2,3,4,5]
11:29:41 <lambdabot>  [1,4,9,16,25]
11:30:10 <recursion-ninja> > map (62) [1..5]
11:30:12 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> b))
11:30:12 <lambdabot>    arising from the ambiguity check for ‘e_16215’
11:30:12 <lambdabot>  from the context (GHC.Num.Num (a -> b),
11:30:12 <lambdabot>                    GHC.Num.Num a,
11:30:12 <lambdabot>                    GHC.Enum.Enum a)
11:30:14 <recursion-ninja> > map (^2) [1..5]
11:30:15 <lambdabot>  [1,4,9,16,25]
11:30:27 <monochrom> oh, 6 is meant to be ^ :)
11:30:30 <Cale> yeah, that's using section syntax again :)
11:30:33 <t4nk639> > let x +++ y = x + y in 5+++3
11:30:35 <lambdabot>  8
11:30:48 <begriffs> EvanR_: Hmm, I can't reproduce the postgresql-simple problem that I thought I had. This gist compiles fine https://gist.github.com/begriffs/cfe078606b5821017d95
11:31:07 <t4nk639> let x +++ y = x+y  in map (+++ 10 ) [1,2,3]
11:31:12 <t4nk639> >let x +++ y = x+y  in map (+++ 10 ) [1,2,3]
11:31:20 <benzrf> u need a space
11:31:25 <benzrf> > let x +++ y = x+y  in map (+++ 10 ) [1,2,3]
11:31:27 <lambdabot>  [11,12,13]
11:31:36 <t4nk639> > let x +++ y = x+y  in map (+++ 10 ) [1,2,3]
11:31:38 <lambdabot>  [11,12,13]
11:31:42 <t4nk639> Thanks
11:32:31 <int-e> > let x+++y=x+y in map(+++10)[1,2,3] -- which space?
11:32:33 <lambdabot>  [11,12,13]
11:33:31 <int-e> let x +++ y = x + y in map (+++ 10) [1,2,3] <-- of course, spaces can improve readability quite a bit.
11:33:49 <t4nk639> the one between > and let. I writed >let when  should have written > let
11:34:00 <int-e> ah.
11:43:32 <begriffs> Anybody in the bay area want to meet at a cafe for weekend haskell hacking?
11:45:34 <rkazak> where?
11:49:28 <t7> how do i force a (Float, Float) to be strict?
11:49:37 <t7> or is it already?
11:50:39 <t7> i might rewrite this in rust when its done :D
11:50:51 <t7> (after i learn rust)
11:51:05 <begriffs> rkazak: workshop cafe in downtown sf is nice and good for productivity
11:51:20 <rkazak> Hmm, I am in Fremont…
11:51:33 <begriffs> Is that south or east?
11:51:46 <rkazak> east bay.
11:52:48 <chrisdone> am i the only one that dislikes type synonyms?
11:53:05 <Figaro> I have a newbie question: Say I have my function (+++) a b = a + b   . I can then make 5 +++ 2 and I get 7
11:53:20 <Figaro> But what if (+++) has 3 parameters?
11:53:27 <muzzle> chrisdone: but they make type signatures more readable, i think
11:54:00 <chrisdone> muzzle: for me they make things less readable by obscuring the structure of the thing
11:54:19 <comerijn> chrisdone: It depends
11:54:29 <Figaro> If  I have  (+++) a b c = (a + b) / c
11:54:41 <comerijn> chrisdone: In some case the real structure is just to unreadably long
11:54:56 <Figaro> Could I write a +++ b c or  a b +++ c?
11:55:05 <chrisdone> e.g. http://lpaste.net/41043
11:55:15 <chrisdone> type Substitution = [(String,Type)]  -- why not simply Map String Type
11:55:31 <chrisdone> type UVars = [String] -- why not just [String]
11:55:32 <comerijn> chrisdone: Those are fairly useless, yes
11:56:01 <comerijn> chrisdone: But imagine using this type without synonym: http://lpaste.net/113948
11:56:22 <chrisdone> i'd put that as a newtype
11:56:26 <dv-> Figaro: you can only have two arguments for operators
11:56:37 <comerijn> chrisdone: What's the advantage of a newtype?
11:56:39 <chrisdone> because as soon as you get a compile error you'll see that massive type anyway
11:56:49 <chrisdone> thereby losing any advantage you thought had
11:56:51 <k00mi> I think some libraries such as lens, pipes or conduit benefit massively from type synonyms
11:56:53 <comerijn> chrisdone: newtyping means none of my library code works
11:57:08 <mdeland> Does anyone have experience using the hyperloglog package? https://github.com/ekmett/hyperloglog
11:57:18 <comerijn> chrisdone: I use tons of pipes library code directly with this type. Any newtype requires me to manually lift all that to my newtype
11:57:19 <chrisdone> comerijn: well that's because you wrote it assuming that type already?
11:57:59 <chrisdone> k00mi: even lenses and conduit confuse me
11:58:02 <comerijn> chrisdone: No, it's because pipes-parse code works on a StateT
11:58:15 <edwardk> k00mi: to the point where nobody has been able to write lens in an untyped language, despite a few dozen attempts =)
11:58:16 <chrisdone> i'd rather just see Conduit i o m r than the six different type aliases i have to remember argument order for
11:58:22 <begriffs> OK I figured out the problem I had with postgresql-simple: I get values from the outside world as ByteStrings and I can't coerce them into Query to concatenate them. Here's a gist https://gist.github.com/begriffs/cfe078606b5821017d95
11:58:36 <comerijn> chrisdone: pipes-parse's Parser type is just a synonym for StateT so you can use all existing StateT and lens code out there
11:58:44 <benzrf> how do i get haskore to write to speakers
11:59:07 <mdeland> I'm having issues inserting Doubles into a HyperLogLog data structure
11:59:09 <Figaro> dv-: operators are when I define the function with (+++) for example?
11:59:11 <chrisdone> comerijn: but there's MonadState for re-use. what code out there mandates StateT specifically?
11:59:23 <chrisdone> oh, read your other message
11:59:37 <chrisdone> that's gross =)
11:59:54 <comerijn> Why? It means you can trivially leverage several libraries worth of combinators
12:00:05 <comerijn> Instead of reimplementing stuff from scratch
12:00:21 <chrisdone> that's what MonadState is for?
12:00:28 <chrisdone> and Monad and MonadIO and …
12:00:29 <comerijn> MonadState is ugly
12:00:44 <chrisdone> fair enough, i can't argue with that =)
12:00:50 <dv-> Figaro: yes
12:01:15 <Figaro> Tanks
12:01:21 <Figaro> *th
12:01:24 <benzrf> is a comerijn the dual of a merijn
12:01:25 <chrisdone> in that case you have no choice but to use type synonyms
12:01:52 <comerijn> benzrf: Yes, he asks questions in #haskell, other than answering them ;)
12:01:58 <chrisdone> generally, though, type synonymous save the author at the expensive of the reader =(
12:02:04 <t7> if i draw two colours over each other with alpha 0.5, the new alpha will be 0.75?
12:03:25 <benzrf> merijn: so is the category in question the category of #haskell users, where morphisms represent transfer of knowledge?
12:03:58 <benzrf> wait, it seems to me that that isn't necessarily a category... composition might not be associative
12:05:30 <monochrom> transfer of knowledge is not transitive, as far as I know. this means you will have trouble with the law (f.g).h = f.(g.h)
12:06:27 <monochrom> it is simpler to just use a graph
12:07:42 <benzrf> hmm
12:07:56 <benzrf> so this is at best a magmaoid
12:08:23 <monochrom> facebook is successful because it settles with graph theory and not try to shoehorn category theory :)
12:09:06 <piskrist> why couldn't you have categories of graphs?
12:09:19 <piskrist> they seem like orthogonal concepts
12:09:38 <monochrom> I could. but I haven't needed it. nor has facebook.
12:10:05 <monochrom> I could always have discrete categories and discrete topologies. and flat CPOs.
12:12:01 <NikolajK> some time ago I made this pic elaborating the one-line definition of all graphs within category theory
12:12:02 <NikolajK> http://axiomsofchoice.org/_media/topoiiiix.jpg?t=1408608611&w=500&h=500&tok=b3e497
12:15:52 <mdeland> any reason that inserting a list of doubles into a HyperLogLog structure would be different than inserting a list of Ints?
12:16:34 * hackagebot propellor 0.9.2 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-0.9.2 (JoeyHess)
12:16:37 * hackagebot cabal-bounds 0.8.8 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.8.8 (DanielTrstenjak)
12:28:39 <lpsmith> begriffs,  you can always import Database.PostgreSQL.Simple.Types
12:28:51 <lpsmith> that has the Query constructor that's exported
12:29:18 <lpsmith> but regarding the specific case of parameterized table names,  postgresql-simple handles that already
12:29:36 <monochrom> parameterized table names?!
12:30:02 <monochrom> that is a pretty powerful notion :)
12:31:30 <lpsmith> begriffs, monochrom:  http://hackage.haskell.org/package/postgresql-simple-0.4.7.0/docs/Database-PostgreSQL-Simple-Types.html#t:QualifiedIdentifier
12:31:59 <lpsmith> well, you can't use protocol-level parameters with parameterized table names,  they have to be interpolated
12:33:05 <lpsmith> not that protocol-level parameters are supported at all by postgresql-simple,  yet.   Everything's interpolated
12:35:53 <MaestroBones> Hi, I tried to install a package, and when I run "sudo runhaskell Setup configure" , I get "Setup: at least the following dependencies are missing: Extra >=1.33 && <1.50, haskell-src any"
12:36:37 <myfreeweb> ghc docs say ImplicitParams bindings are not recursive. does that mean what I think it means? because it says "unbound implicit parameter" when I call a function with implicit params indirectly :(
12:36:58 <lpsmith> MaestroBones, you'll probably find cabal-install useful, which will automatically fetch missing dependencies that are on hackage or a local hackage-like server
12:37:10 <lpsmith> cabal install --only-dependencies
12:37:26 <MaestroBones> Ah
12:37:27 <lpsmith> then runhaskell Setup configure
12:37:38 <lpsmith> or just "cabal configure"
12:37:44 <giogadi> It looks like the user account system for Hackage is down.... does this tend to happen?
12:38:11 <merijn> myfreeweb: You need to explicitly specify a value for implicit parameters when executing code with them
12:39:07 <merijn> giogadi: Down in what way?
12:39:29 <myfreeweb> merijn: I'm trying to do this: let ?x = something in someFunction -- where someFunction is not the one that takes ?x, but it *calls* a function which takes ?x
12:39:49 <merijn> myfreeweb: lpaste the full code + error
12:39:56 <giogadi> merijn: I'm trying to register a new account and getting an error: Server error: fd:63: hClose: resource vanished (Broken pipe)
12:40:45 <merijn> giogadi: hmm, that doesn't look right. Can you report that in either #haskell-infrastructure of #hackage?
12:40:54 <giogadi> will do! thanks
12:41:59 <merijn> giogadi: Looks like there's a ticket already on github from 1 day ago
12:42:13 <giogadi> ah ok, I should've checked that first. thanks!
12:42:16 <merijn> But dcoutts tends to be rather swamped, so I dunno if anyone has looked into it yet
12:42:18 <joshsz_> hey, is there a function on lists that's equivalent to this lambda? \[a,b] -> a /= b
12:42:47 <merijn> joshsz_: That seems like an oddly specific function, so I'm betting "no"
12:43:00 <joshsz_> yeah, figured I'd ask :)
12:43:44 <myfreeweb> merijn: http://lpaste.net/113951
12:43:58 <myfreeweb> looks like it doesn't work even without the outer function
12:44:34 <myfreeweb> ah nope it works without it
12:44:51 <myfreeweb> looks like ImplicitParams are useless
12:45:01 <merijn> myfreeweb: Your type for outer is wrong
12:45:31 <merijn> Should be "outer :: (?x :: String) => String -> String"
12:45:41 <merijn> You're not allowed to magically hide implicitparameters
12:45:47 <myfreeweb> merijn: thanks!
12:46:00 <myfreeweb> I thought "implicit" implies you can hide them
12:46:12 <myfreeweb> I think they worked like that in Scala
12:46:27 <merijn> Scala loves letting you hide things from the programmer >.>
12:46:58 <davean> supki: implicit means they're passed for you
12:47:04 <davean> er, myfreeweb
12:47:24 <davean> myfreeweb: Its a really bad idea in so many ways ...
12:47:38 <myfreeweb> but I don't really need to see my HTTP request manager mentioned everywhere!
12:48:39 <davean> myfreeweb: so don't mention it. use, for example, a monad
12:48:55 <davean> myfreeweb: you already have to have a monad to do IO
12:49:03 <davean> just make it also include your HTTP request manager
12:50:09 <myfreeweb> yeah, I guess I can, but I'm still not confident with monad transformers
12:51:01 <benzrf> hey, i think i saw some kind of music lib previously
12:51:04 <benzrf> i dont think it was haskore
12:51:10 <benzrf> it had a 'book' or something
12:51:18 <benzrf> i believe it used a (</>) combinator
12:54:32 <davean> myfreeweb: I tihnk you'll find it FAR more trivial to get comfortable with them then work out the kinks in implicit parameters
12:55:09 <myfreeweb> nah, implicit parameters turned out to be perfect for my use case
12:55:18 <davean> hehe
12:55:23 <davean> I expect that is your ignorance talking
12:55:41 <ion> That’s a slippery slope. Soon: “nah, PHP turned out to be perfect for my use case”
12:56:20 <merijn> davean: Even if true, you could put that more diplomatically
12:56:36 * hackagebot zip-archive 0.2.3.5 - Library for creating and modifying zip archives.  http://hackage.haskell.org/package/zip-archive-0.2.3.5 (JohnMacFarlane)
12:57:00 <merijn> Calling people ignorant does not set the atmosphere people generally like about #haskell
12:58:06 <benzrf> @hoogle (</>)
12:58:07 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
12:58:08 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
12:58:15 <benzrf> h m
13:00:26 <monochrom> hoogle likely doesn't know about that music library
13:00:35 <monochrom> hoogle knows very little
13:08:34 <bananagram> what do you have to import to get <*>?
13:08:44 <merijn> Control.Applicative
13:08:55 <merijn> Although I think it'll finally be in Prelude as of 7.10
13:09:43 <bananagram> good
13:11:26 <rai> which book you would recommend after LYAH, just curious
13:11:43 <rai> perhaps more practical one
13:12:05 <kadoban> rai: RWH maybe?
13:12:25 <bananagram> rai: try https://github.com/bitemyapp/learnhaskell
13:12:58 <osa1__> can anyone point me an example use of getAddrInfo(from `network`) ? I can't make it working
13:13:03 <osa1__> it always throws exception
13:13:18 <rai> bananagram: cool. thanks
13:13:22 <merijn> osa1__: Which exception?
13:13:31 <merijn> osa1__: Also, linux by any chance?
13:13:34 <osa1__> merijn: Exception: getAddrInfo: does not exist
13:13:36 <osa1__> merijn: yes
13:13:41 <rai> kadoban: thanks
13:14:02 <merijn> hmm, that's not the linux error I've seen before :)
13:14:55 <osa1__> merijn: you managed to use it? do you keep the code?
13:15:00 <merijn> actually it might still be
13:15:06 <merijn> What's the code you have?
13:15:10 <merijn> Yeah, it works for me
13:15:26 <osa1__> merijn: can you paste the working expression?
13:16:01 <merijn> I've seen it break on 2 different distro's due to distro maintainer stupidity, though
13:16:33 <merijn> osa1__: http://lpaste.net/113952
13:17:17 <merijn> osa1__: What's "file /etc/services" tell you?
13:19:00 <osa1__> I'm wondering if I'm passing unexpected string to it
13:19:08 <osa1__> merijn: it's 16k lines long, which part are you interested in
13:20:06 <merijn> I meant the result of the command, but anyway if there's a 16k line file, that's good
13:20:26 <merijn> I've seen someone who didn't have that file, breaking the C code for getaddrinfo :p
13:20:34 <merijn> osa1__: What string are you passing in?
13:21:12 <osa1__> uhh, I think it has http:// part in it
13:23:46 <merijn> Yeah, that's not gonna fly
13:24:07 <merijn> This is a thin (as in, paper thin) wrapper around C's getaddrinfo
13:24:25 <merijn> It expects either a domain name or IP adress in string format
13:25:02 <merijn> getaddrinfo man page (I'm pretty sure the network docs mention this): "An acceptable value for hostname is either a valid host name or a numeric host address string consisting of a dotted decimal IPv4 address or an IPv6 address."
13:25:28 <simpson> Several times, I have seen attestations that ghci produces bytecode which it then interprets. However, Google does not tell me much about this feature.
13:25:37 <simpson> Is the GHC bytecode documented anywhere?
13:27:22 <osa1__> merijn: thanks
13:27:23 <chrisdone> is there a type Stream a = Stream a (Stream a) type in base somewhere?
13:27:28 <chrisdone> er, data
13:27:45 <osa1__> merijn: you have any ideas about this http://stackoverflow.com/questions/26803443/haskell-network-sockaddrinet-which-endianness-to-use ?
13:30:48 <merijn> simpson: The wiki maybe, if you're lucky
13:31:37 * hackagebot purescript 0.6.0 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.6.0 (PhilFreeman)
13:31:53 <merijn> osa1__: Don't do that
13:31:57 <benzrf> question
13:32:02 <merijn> osa1__: Just pass "127.0.0.1
13:32:10 <benzrf> does anybody know of a music lib that uses a (</>) combinator
13:32:10 <benzrf> "
13:32:12 <merijn> osa1__: Just pass "127.0.0.1" as string to getAddrInfo
13:32:41 <osa1__> merijn: why? I don't want to do that becuase this is part of a parser and I want to keep the parser pure(e.g. non-IO)
13:33:22 <osa1__> merijn: I can just pass it as little-endian
13:33:31 <merijn> osa1__: What is your parser doing? Trying to turn a hostname into an IP or...?
13:33:48 <SvenskFisk> Is there a way to do breakpoints in haskell?
13:34:13 <osa1__> It's parsing `ip:port` strings and returning SockAddr. maybe I should return a pair.
13:34:33 <osa1__> merijn: that package is confusing. if I'm not supposed to use the constructor then it should be hidden
13:35:16 <merijn> osa1__: You can use the constructor, but doing so is about as painful as it is in C, maybe more so, due to the lack of a convenient host-to-network function
13:35:46 <osa1__> SvenskFisk: https://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html#breakpoints
13:36:30 <SvenskFisk> I was looking at this question on SO : http://stackoverflow.com/questions/6724434/how-to-debug-haskell-code. Almost everyone seems to be saying not to use head, one guy even said he'd remove it, tail, and !! if he could, what are the better alternatives to head and why is using it bad?
13:36:36 <SvenskFisk> osa1__: thanks!
13:37:26 <myfreeweb> SvenskFisk: Safe.headMay is pretty good http://hackage.haskell.org/package/safe-0.3.8/docs/Safe.html
13:37:28 <hakujin> SvenskFisk: head, et al. are not total functions
13:37:54 <hakujin> if you try to apply head to an empty list it explodes
13:43:44 <jaseemabid> I have a `data Foo` which can be constructed with a bunch of constructors. What would be a good way to write a function that takes 2 arguments made of the same constructor or otherwise error out? I don't to list each and every type in the pattern match.
13:44:06 <jaseemabid> * I don't want to..
13:46:26 <merijn> jaseemabid: Use a wildcard pattern, although this is probably a bad idea
13:46:51 <indiagreen> merijn: can you elaborate?
13:47:08 <jaseemabid> More like patterns which depend on each other...
13:47:18 <merijn> "myFun Foo Foo = myResult; myFun _ _ = error "whoopsydaisy""
13:47:29 <jaseemabid> I mean fragments in  a pattern that depend on each other.
13:47:42 <merijn> You're outta luck
13:48:14 <jaseemabid> :(
13:48:39 <indiagreen> well, unless you're willing to use something like Typeable
13:48:52 <indiagreen> but better just spell them out explicitly
13:49:19 <barrucadu> I was about to say, if you can use Data, you can compare constructors directly
13:49:24 <barrucadu> using `toConstr`
13:50:23 <jaseemabid> indiagreen: I'm working on the lisp interpreter example. I have a lispVal that can be made with Integer, Bool, String etc. I'm writing a booleanBinop, which takes 2 args, and if they are of the same type, defaults to (==), else error out.
13:50:33 <hakujin> what about singleton types? DataKinds, TypeFamilies, GADTs
13:51:38 * hackagebot growler 0.3.1 - A revised version of the scotty library that attempts to be simpler and more performant.  http://hackage.haskell.org/package/growler-0.3.1 (IanDuncan)
14:10:34 <slack1256> is there an integration of local haddocks and vim on any plugin?
14:12:47 <etaoinshrdlu> Have you tried haskellmode?
14:13:06 <jaseemabid> Why wouldn't this 2 liner compile? http://lpaste.net/113954
14:14:34 <slack1256> etaoinshrdlu: it hasn't been update since 2012, is still working?
14:14:48 <ion> jaseemabid: The compiler will tell you.
14:15:24 <jaseemabid> indiagreen, merijn, This is what I was trying to do. Number, Bool and String are constructors for `data LispVal`. I'm trying to define a `==` that will work on both (Number 4, Number 4) as well as (String "A", String "B")
14:15:30 <ion> jaseemabid: Just a guess which may or may not be correct: it might have to be (forall a. a -> a -> Bool) -> [LispVal] -> LispVal.
14:16:07 <ion> As it is now, the caller of boolBinop dictates the type “a” instead of the caller of “op”.
14:16:32 <slack1256> jaseemabid: Tell me, what is the type of "one" on your code
14:17:26 <jaseemabid> slack1256: one and two can be either Number, Boolean or a String. But `op one two` will always be a Boolean, which is kind of what I want.
14:17:46 <etaoinshrdlu> slask1256: If I remember correctly there is a repo still being maintained on github
14:18:35 <jaseemabid> ion: That sounds like what I want to do. I didn't knew you could put a forall in type definition.
14:19:05 <ion> With {-# LANGUAGE Rank2Types #-} you can.
14:19:28 <slack1256> jaseemabid: what stop you to pass as 'op' a function of type "op :: IntSet -> IntSet -> Bool"
14:22:25 <jaseemabid> slack1256: I don't know about IntSets. LispVal kind of wraps a haskell value. I'm just trying to compare 2 wrapped values.
14:22:34 <derekv> help me with my stupid: I have a list of associated values, eg (x,y), and I want a Map x [y] ... hoogle isn't helping, tried [(x,y)] -> Map x [y]
14:23:05 <derekv> Seems like a very basic thing.
14:25:13 <supki> :t M.fromListWith (++) . map (second (:[]))
14:25:14 <lambdabot> Ord k => [(k, a)] -> M.Map k [a]
14:25:30 <slack1256> jaseemabid: use Rank2Types as suggested above
14:25:32 <jaseemabid> ion: Worked fine with the forall and {-# LANGUAGE Rank2Types #-}. I dont understand what I'm doing though ;)
14:27:17 <derekv> supki, thanks
14:28:25 <indiagreen> jaseemabid: be aware that if you did something like “(forall a . a -> a -> Bool) -> [LispVal] -> LispVal”, it won't get you what you want
14:30:36 <jaseemabid> indiagreen: Means?
14:31:01 <indiagreen> in fact, I can't even say I know what you want. E.g. what should “boolBinop (++)” do if subsequently passed a list with 2 Numbers?
14:31:11 <indiagreen> ouch, not (++)
14:31:45 <indiagreen> let's say... (\x y -> length x < length y), something like this
14:31:47 <jaseemabid> let comp = boolBinop (==); comp [Number 4, Number 5] => False
14:31:53 <jaseemabid> This is what I wanted ^
14:32:51 <indiagreen> okay, let's take (==). What behavior do you want if you later add a LispVal for functions?
14:33:21 <jaseemabid> indiagreen: I can see it getting weird in certain cases. Yep!
14:34:23 <jaseemabid> comp = boolBinop (\x y -> length x < length y); comp [Number 4, Number 5] => False  would crash! I think I get why I cant do it.
14:36:19 <David> hey guys
14:36:25 <David> I'm having trouble understanding this error
14:36:25 <David> http://hastebin.com/moxocitapu.hs
14:36:43 <indiagreen> jaseemabid: I think people usually use GADTs in these cases – i.e. instead of “data LispVal = Number Int | Bool Bool | ...” you would have “data LispVal a where Number :: Int -> LispVal Int; Bool :: Bool -> LispVal Bool; ...”
14:36:53 <David> seems like some sort of type issue with frac/integers, but I can't figure out how to fix it
14:37:45 <indiagreen> and then your boolBinop would be “boolBinop :: (a -> a -> Bool) -> [LispVal a] -> LispVal Bool”
14:41:42 <joelteon> how do I make GHC show me preprocessed files
14:44:06 <slack1256> joelteon: it seem to be 'ghc -E' what you want
14:45:23 <slack1256> David: use `div` instead of /
14:45:32 <slack1256> @type div
14:45:33 <lambdabot> Integral a => a -> a -> a
14:45:39 <slack1256> @type (/)
14:45:40 <lambdabot> Fractional a => a -> a -> a
14:45:58 <slack1256> Integer is an Integral but not a Fractional
14:46:10 <David> slack1256: thanks!
14:46:17 <merijn> In fact, no type should ever be both Integral and Fractional
14:46:40 * hackagebot purescript 0.6.0.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.6.0.1 (PhilFreeman)
14:46:49 <jaseemabid> indiagreen: `data LispVal a where...` or `type LispVal a where ..` ?
14:46:54 <indiagreen> the former
14:47:53 <Fuco> when I have exposed-modules: in cabal, do I also need to add modules this module re-exports?
14:48:03 <merijn> No
14:48:07 <Fuco> I'm getting an error where I can't use a data constructor in code which uses the package
14:48:26 <merijn> Are you sure you're exporting/importing the constructor?
14:48:28 <Fuco> I 'cabal install'-ed it, looks fine, and I can include it without problems... but data constructors aren't available
14:49:12 <Fuco> I do... "module Foo ( module Foo, module Bar ) where ..."
14:49:19 <Fuco> does that export everything Bar exports?
14:49:34 <Fuco> or do I need some (..)?
14:49:36 <merijn> It exports everything you imported from Bar
14:49:51 <Fuco> which definitely are the constructors because I use them in Foo
14:50:09 <Fuco> I "import Bar" with no hiding or selecting
14:50:29 <merijn> Make a minimal example?
14:51:28 <Fuco> hm... it imports functions but not constructors.
14:51:34 <Fuco> let me check once more ~_~
14:52:32 <jaseemabid> indiagreen:  Invalid type signature error :|
14:52:38 <Fuco> this expords the constructors, right?: module Pulse.Monad.Data ( SinkInput(..) ) where
14:52:45 <merijn> Yeah
14:53:38 <jaseemabid> indiagreen: And `Illegal generalised algebraic data declaration for ‘LispVal1’`.
14:54:27 <indiagreen> jaseemabid: have you enabled {-# LANGUAGE GADTs #-}?
14:56:02 <indiagreen> also, um, I should admit at this point that I've only now realised that you're doing something similar to what Write Yourself a Scheme in 48 Hours describes (which I haven't previously read) and it's likely that what I'm proposing is actually not helpful
14:56:21 <jaseemabid> Invalid type signature error again.
14:56:25 <indiagreen> so you might want to ask -somebody who has read it- instead
14:56:55 <jaseemabid> indiagreen: No problem. I'm trying to experiment around the idea.
14:57:07 <Fuco> weird, when I put the Data module in the exposed modules it loads correctly
14:57:23 <Fuco> so there's probably some misconfiguration in my cabal file... I'll read on that tomorrow
14:57:26 <merijn> The problem is that what indiagreen wants require Rank2Types and I don't have time to explain those right now :)
14:57:28 <Fuco> thanks so far ;)
14:58:18 <jaseemabid> merijn: The perks of this being a side project. I can take all the time and eventually learn it well.
14:58:50 <jaseemabid> Cant imagine doing this with a deadline ;)
14:59:10 <indiagreen> merijn: I'm starting to suspect that – given how WYAS goes on to define numBoolBinop, strBoolBinop and boolBoolBinop – the “proper” way is to define something like eqBoolBinop
15:00:07 <jaseemabid> The WYAS way wont let me have a == that works on Number as well as String. Which is kind of sad.
15:01:07 <indiagreen> jaseemabid: can you paste the full code you have so far? so that I wouldn't have to copypaste it from WYAS
15:01:26 <jaseemabid> indiagreen, merijn Good that you both understood what I'm trying to do. Let me know if you ever come across a simple way to define a `eqBoolBinop`
15:01:36 <jaseemabid> indiagreen: https://github.com/jaseemabid/lisper
15:06:40 * hackagebot configuration-tools 0.2.6 - Tools for specifying and parsing configurations  http://hackage.haskell.org/package/configuration-tools-0.2.6 (larsk)
15:09:43 <etaoinshrdlu> Stackage, is that basically a collection of packages that is known to work with each other? Like if you have a build and you would do `cabal freeze` to export the exact constraints?
15:12:13 <Cksda> Why would I use Haskell over Scala?
15:13:14 <vanila> it's simpler
15:13:20 <bmuk> Cksda: there are different reasons to use language X over language Y for any given project
15:13:40 <bmuk> Unless you mean why should I learn haskell instead of learning Scala?
15:14:59 <Cksda> Yeah that's what I meant
15:15:10 <Cksda> Sorry for weak wording
15:15:18 <k00mi> Cksda: purer, simpler, cleaner design, no JVM, higher quality implementation
15:15:27 <exio4> Haskell is a _pure_ FP, it forces you to learn "the concepts"
15:15:37 <Cksda> Why would no JVM be a plus?
15:15:48 <exio4> the JVM doesn't like FP much
15:16:16 <Cksda> Can Haskell interface with C as Python does?
15:16:29 <vanila> yes
15:16:32 <exio4> yup, and it has a lovely FFI
15:16:36 <exio4> it is really easy to use
15:17:17 <k00mi> Cksda: there is no need for it so why have it in the first place?
15:17:29 <dfeuer_> Cksda, the JVM sucks. That's pretty much its main problem.
15:18:20 <etaoinshrdlu> I think that interfacing with C in Haskell is much easier than in Python.
15:19:16 <exio4> a small exmaple I have around, calling a void function in Haskell, http://dpaste.com/26TFEW5 :P
15:24:01 <jaseemabid> dfeuer_: Why would you say that? Java the lang, yes surely suck but its quite a good vm.
15:24:18 <dfeuer_> jaseemabid, as someone else said, it's not so great for functional languages.
15:24:33 <lpaste> chrisdone pasted “Type checker” at http://lpaste.net/113957
15:24:42 <lpaste> chrisdone revised “Type checker”: “Implementation” at http://lpaste.net/113957
15:25:38 <lpaste> chrisdone revised “Type checker”: “Add examples” at http://lpaste.net/113957
15:25:45 <chrisdone> \o/
15:26:38 <vanila> chrisdone, cool! whats this for?
15:27:03 <chrisdone> vanila: a simple typed lisp with statically typed quotation. that's the plan, anyway
15:27:18 <greymalkin> Having a heck of a time here... need a FileType to fit into a String function, but not finding a 'fromFileType'
15:27:51 <vanila> chrisdone, will you use staged lambda calculus for typing quote?
15:28:46 <chrisdone> vanila: what's staged lambda calculus?
15:29:47 <chrisdone> @ops
15:29:47 <lambdabot> Maybe you meant: pl oeis docs
15:30:05 <vanila> ill post some typerules for it
15:31:07 <vanila> http://lpaste.net/113960
15:31:24 <vanila> like this for quasiquote and unquote
15:32:52 <k00mi> greymalkin: where is FileType from?
15:33:06 <greymalkin> Nevermind ... 'read' worked.
15:33:25 <greymalkin> But... System.FilePath for the curious
15:34:24 <jaseemabid> indiagreen: If you have any comments on the code, or if you find a simpler eqBoolOp please let me know. Leaving now
15:36:35 <chrisdone> vanila: i don't speak freaky deaky type rule notation =(
15:37:19 <chrisdone> vanila: 'a :: Symbol, ~a :: Quoted a, ~1 :: Quoted Int, etc.
15:39:02 <chrisdone> vanila: https://www.youtube.com/watch?v=exCYSfQod14&t=0m43s =p
15:40:47 <etaoinshrdlu> Haha
15:44:44 <chrisdone> vanila: oops, i meant 'a :: Quoted Symbol. 'foo will be normal symbolic quotation, and ~foo will be typed which will require all things quoted to be in scope and well-typed. that's the plan, anyway. implemented the Quoted part now
15:47:17 <chrisdone> but 'T for short-hand. ideally it means i can provide a well-typed eval :: 'a -> a
15:49:33 <chrisdone> λ> typeOf (Quote (Fun "x" (VarTy "a") Unit))
15:49:33 <chrisdone> '(a -> ())
15:49:41 <chrisdone> ^ like this
15:51:03 <chrisdone> hm, maybe i should print as ~(a -> ()) to match the planned ~(fn x ()) syntax
15:51:25 <chrisdone> not sure
15:51:44 <chrisdone> i like the idea of '1 :: 'Symbol and ~1 :: 'Int
15:52:22 * chrisdone goes with that
16:11:18 <chrisdone> vanila: so what does that paste mean?
16:12:47 <vanila> it's very similar to what you're saying except each type judgement (::) has a level
16:13:11 <vanila> when you quasiquote something you go up a level and unquote goes down
16:13:30 <vanila> the reason for this is that you can make sure variables references don't get extruded across levels
16:13:33 <dreams> > (\ x -> let x = 5 in x + x) 1
16:13:35 <lambdabot>  10
16:13:37 <chrisdone> ah this is specifically referring to quasiquotation like `(,x)
16:13:42 <dreams> why is that not 6?
16:14:21 <dreams> > (\ x -> (let x = 5 in x) + x) 1
16:14:23 <lambdabot>  6
16:14:36 <triliyn> dreams: the scope of a "let" extends as far as it can
16:14:45 <chrisdone> vanila: can you show an example of such extrusion?
16:16:28 <vanila> a really simple example would be (lambda (x) `x)
16:16:30 <chrisdone> so far i'd end up with ~pi :: 'Int vs pi :: Int, so you could write an interpreter (cond ((eq x ~pi) pi)) but you couldn't conflate the quoted thing with the actual thing. is that what you mean?
16:17:03 <vanila> the x variable ony exists at level 0, but level 1 refers to it
16:17:05 <chrisdone> so in that example what *is* the `x?
16:17:13 <vanila> it's a type error
16:17:43 <chrisdone> ahh. so the quote can only do e.g. (lambda (x) `(lambda (x) x))
16:18:00 <chrisdone> and the inner x will refer to the quoted lambda's x?
16:18:19 <vanila> yeah
16:18:50 <chrisdone> right. that behaviour's in fact how i expected haskell's TH to behave when i first saw
16:19:14 <chrisdone> i was rather confused when SPJ said \x -> [|x|] would mean the inner x refers to the outer x
16:19:53 <chrisdone> i thought about having that behaviour. i'm not sure which i prefer
16:20:40 <chrisdone> the staging is cleaner, but unstaged means you can have a function eval :: 't -> t, which lets you do e.g. ((eval ~+) 1 2) and it be type-safe, unlike normal eval
16:21:59 <chrisdone> although perhaps that's not worth much =)
16:23:14 <chrisdone> ah, that was my thinking:
16:24:46 <chrisdone> let's say you define a DSL function like (defun sql (exp) …) and then (sql '(select :from 'foo :where …)) like in typical lisp
16:25:42 <chrisdone> (and (sql-macro foo bar) is basically just compile-time syntactic sugar for (eval (sql '(foo bar))) …)
16:26:29 <chrisdone> with a staged macro, you can *only* refer to things within your quote, which is fine and nice. but if you want to be able to resolve things outside of the scope in a type-safe way, like table or field names, then you're gonna have a bad time, i think
16:27:49 <chrisdone> e.g. (sql `(select :from ,~foo :where (= ,~bar 123))) -- or so
16:29:16 <chrisdone> or as in the EVAL case you can only eval e.g. (eval '(lambda (x) x)), but you can't (eval '(lambda (x) (* x x))) because where does `*` come from?
16:29:37 <chrisdone> or are some things presumed to be in scope?
16:30:12 <vanila> yeah i think eval should occur in the top level scope
16:31:42 <chrisdone> i mean separate from eval itself, why is '(lambda (x) (* x x)) okay but (lambda (%) '(lambda (% x x))) not okay?
16:31:43 * hackagebot conduit-combinators 0.3.0.1 - Commonly used conduit functions, for both chunked and unchunked data  http://hackage.haskell.org/package/conduit-combinators-0.3.0.1 (MichaelSloan)
16:32:11 <chrisdone> (where the % comes from scope outside of the quote, as in the * case)
16:32:14 <vanila> % is bound on level 0, then used on level 1
16:32:24 <chrisdone> where is * bound?
16:32:24 <vanila> (lambda (%) `(lambda (,% x x))) would typecheck
16:33:13 <chrisdone> right, but would mean something different
16:33:40 <vanila> yeah you're raising a really good point
16:33:55 <vanila> i think one solution is to have top level definitions exposed to all levels
16:34:38 <simpson> chrisdone: Oh my. You're familar with E, right? sql`select from $foo where $bar=123`
16:34:40 <chrisdone> seems like a reasonable solution -- to assume top-level scope is okay to mix and not as likely to be confused
16:34:52 <vanila> there might be another way to look at it
16:34:53 <chrisdone> simpson: no, what's that?
16:35:07 <chrisdone> vanila: oh?
16:35:18 <simpson> chrisdone: The E language has very similar QQ/QL techniques. The names are always static. I guess that here, your types are also static. Interesting stuff.
16:35:40 <vanila> the rule for variables is that if   x ::n T  and  n <= m   then   x ::m T
16:36:35 <vanila> when you bind a variable it exists at every higher level (unquote takes you one level higher)
16:38:01 <vanila> but I can't think what something like (lambda (x) ,x) would mean, apparenty it's well typed
16:38:50 <vanila> ah  `(lambda (x) ,x)  : < < A > -> A >
16:39:17 <chrisdone> so to check i understand: * -- level 0, '(lambda (x) x) -- x is level 1, '(lambda (x) ,x) -- x is level 0. that makes sense so far
16:39:26 <chrisdone> hm
16:39:38 <chrisdone> so the < > syntax means "go up a level"?
16:39:54 <chrisdone> simpson: ah, interesting. is that similar to TH's staticness? name-safe but not type-safe?
16:40:45 <vanila> if T is a type then <T> is the type of codes of that type
16:40:53 <vanila> like a data type representation of a "T"
16:41:04 <vanila> it could be anything though
16:41:24 <vanila> an AST is the basic way to implement it
16:41:25 <chrisdone> ahh
16:41:29 <simpson> chrisdone: Yes. E's dynamically typed; think Smalltalk or Self. (Or JS/ES.)
16:41:39 <chrisdone> '(* 2 3) :: <Int>
16:41:51 <simpson> chrisdone: The interesting thing here is that, without macros, there's still pattern-matching here.
16:41:55 <chrisdone> but (car '(* 2 3)) :: <Int -> Int -> Int>
16:42:27 <vanila> haha, that seems crazy
16:42:39 <simpson> def html`<img src=@url />` := incomingTag # Assigns to the `url` name!
16:42:41 <chrisdone> simpson: still pattern matching?
16:42:42 <vanila> imnot sure you should be allowed to take piece of code apart
16:42:54 <vanila> generative staging seems less dangerous
16:43:30 <chrisdone> hmm. how would you implement an EVAL function then? e.g. the eval. here: http://ep.yimg.com/ty/cdn/paulgraham/jmc.lisp
16:43:46 <lynnard> How can I convert this pseudo procedural code into haskell..?
16:43:50 <pyon> What exactly is the relationship between free monads (cofree comonads) and the least (greatest) fixpoint of a functor? It is clear to me that "Free f Void" ("Cofree f ()") is the same as "Mu f" ("Nu f"), but it seems to me that there is "something more" that I cannot quite pinpoint.
16:45:12 <lynnard> for arg in args: if meetsCondition(arg): return processArg(arg): elif meetsAnotherCondition(arg): return anotherProcessArg(arg): fi: endfor
16:45:48 <lynnard> I'm considering a fold, but the problem is that fold can't prematurely return
16:46:14 <lynnard> i.e. the result will still need to pass down the list, so consider the case when 'args' is an infinite list
16:47:11 <pyon> lynnard: Does meetsCondition have any effects?
16:47:28 <lynnard> pyon: no, just checking for the condition
16:47:53 <lynnard> the entire procedure can be considered pure i.e. I'm only interested in the return value of processAr
16:47:56 <lynnard> processArg
16:48:07 <chrisdone> vanila: i was wondering if perhaps: if f='(lambda (x y) (* x y)), then f :: <Int -> Int -> Int>, (car f) :: Symbol ('lambda), cadr f :: (<Int>,<Int>) (x,y), (* x y) :: <Int>, etc.
16:48:47 <chrisdone> vanila: probably it's easier if functions are curried and decomposed into 1-ary, then it's easier to handle arguments of different types without needing existential lists
16:49:01 <vanila> i dont think that kind of destructuring can work nicely
16:49:18 <pyon> lynnard: You can begin like this: fooOrBar x | mustFoo x = foo x | mustBar x = bar x | otherwise = return ()
16:49:41 <chrisdone> vanila: that's basically how we do it in haskell when implementing a trivial lambda-calculus interpreter, no?
16:49:43 <pyon> lynnard: Then mapM_ fooOrBar xs
16:50:03 <vanila> you can operate on an AST data type
16:50:10 <chrisdone> https://gist.githubusercontent.com/chrisdone/24e47c2952e4ad78c246/raw/313b4710ee0bf7c1c70f172899d37ae9c9b7d125/000HOAS.hs
16:50:11 <vanila> but that's a different thing than staged code
16:50:33 <pyon> lynnard: Where "foo, bar :: X -> ()", "mustFoo, mustBar :: X -> Bool" and "xs :: [T]".
16:50:59 <chrisdone> vanila: in my case i want a well-typed AST. what's staged code, compared to an AST?
16:51:32 <vanila> it should be opaque (imo), you can generate it by quotations but things like "car" can't operate on it
16:51:41 <chrisdone> if you can't destructure it you might as well just use a lambda?
16:51:49 <chrisdone> what's the point in quoting if you can't look inside?
16:51:49 <lynnard> pyon: my original procedure checks for the args one by one and stops when any of mustFoo or mustBar returns true... I'm afraid 'map' is not going to be the solution
16:52:32 <vanila> you can still do a bunch of stuff with staging like partial evaluation by specializing some code with some of its inputs
16:52:45 <pyon> lynnard: Oh, I missed the "return"s, sorry!
16:53:03 <t7> how do i sort by some map function again? for example  `snd`
16:53:11 <chrisdone> vanila: so this is more like "mixins" or so?
16:53:24 <t7> sortWith?
16:53:28 <exio4> t7: sortBy (compare `on` snd)?
16:53:53 <pyon> lynnard: Then "fooOrBar x | mustFoo x = Just <$> foo x | mustBar x = Just <$> bar x | otherwise = return Nothing"
16:53:54 <exio4> @type sortBy (compare `on` snd)
16:53:54 <chrisdone> > sortBy (comparing snd) (zip [1..4] [7..10])
16:53:54 <t7> @hoogle on
16:53:55 <vanila> i dont really know about mixins
16:53:55 <lambdabot> Ord b => [(a, b)] -> [(a, b)]
16:53:55 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
16:53:55 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
16:53:55 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
16:53:56 <lambdabot>  [(1,7),(2,8),(3,9),(4,10)]
16:55:12 <pyon> lynnard: No idea if there is a combinator that iterates a "Monad m => [m (Maybe a)]" until it finds a (wrapped) Just, though, but writing your own should not be too hard.
16:55:22 <pyon> s/too//
16:56:07 <t7> @hoogle [a] -> Maybe a
16:56:08 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
16:56:08 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
16:56:08 <lambdabot> Prelude head :: [a] -> a
16:56:12 <lynnard> pyon: cool
16:56:28 <chrisdone> vanila: i have to go now but i have some more things to think about now. nice talking to you =)
16:56:46 <vanila> cheers!
16:57:00 <lpsmith> t7:  Data.List in GHC HEAD implements sortOn,  as does data-ordlist:   http://hackage.haskell.org/package/data-ordlist-0.4.6.1/docs/Data-List-Ordered.html#v:sortOn
16:57:33 <t7> not my version, unfortunately
16:57:45 <lpsmith> sortOn' in data-ordlist a syntactically more convenient sortBy (compare `on` snd)
16:57:58 <pyon> @hoogle Monad m => [m (Maybe a)] -> m (Maybe a)
16:57:58 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
16:57:59 <lambdabot> Data.Typeable gcast1 :: (Typeable1 t, Typeable1 t') => c (t a) -> Maybe (c (t' a))
16:57:59 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
16:58:13 <pyon> Oh, right.
16:58:16 <exio4> @check \xs -> (find (const True) xs) ==  (listToMaybe xs)
16:58:17 <lambdabot>  +++ OK, passed 100 tests.
16:58:29 <lpsmith> t7,  yeah the version with sortOn hasn't been released,  and in any case for something like snd you really don't want to store the result, you want to recompute it each time
17:06:39 <gxcp> hi
17:17:01 <lynnard> have a question here to ask: say I have one case guard clause like this _ | predicateFunc $ expensiveFun val -> operation $ expensiveFun val
17:17:17 <lynnard> how can I capture the result of the expensiveFun so I don't have to recalculate?
17:25:08 <lynnard> I see expressions like: func | Just (ValueConstructor v) <- someAction = do ...
17:25:42 <lynnard> so can the guard actually be a 'assign' kind of matching?
17:26:15 <lynnard> if someone can exaplain the syntax and use of such construct it will be great
17:26:21 <darkf> Is there any way to traverse a Repa array with monadic effects? e.g. I wish to traverse the array with a function taking the current index and value and produce an IO (). There seems to be no mapM_-style equivalent.
17:27:30 <nitrix> pyon: <3
17:27:52 <geekosaur> lynnard, https://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#pattern-guards
17:28:15 <nitrix> pyon: There's something satisfying with seeing you on #haskell
17:28:17 <t7> @hoogle [Maybe a] -> (a -> b) -> [b]
17:28:17 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
17:28:17 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
17:28:17 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
17:31:33 <t7> how silly is this: map (drawPath maxPower) (catMaybes [lowPath w])
17:31:38 <t7> @pl map (drawPath maxPower) (catMaybes [lowPath w])
17:31:38 <lambdabot> map (drawPath maxPower) (catMaybes [lowPath w])
17:31:39 <lynnard> geekosaur: cool, thanks
17:32:30 <vanila> catMaybes [lowPath w] ?
17:32:36 <vanila> :t \x -> catMaybes [x]
17:32:37 <lambdabot> Maybe a -> [a]
17:32:56 <Fuuzetsu> :t catMaybes . return
17:32:57 <lambdabot> Maybe a -> [a]
17:33:46 <nitrix> I'm not sure I understand monadic lifting. Someone feel like breifing me?
17:34:07 <Fuuzetsu> depends what you're referring to as monadic lifting
17:34:15 <nitrix> liftM
17:34:20 <Fuuzetsu> liftM = fmap
17:34:20 <exio4> it is fmap
17:34:43 <nitrix> And isn't fmap   sequence . map ?
17:34:57 <Fuuzetsu> sequence is a Monad thing so it can't be
17:35:04 <Fuuzetsu> :t sequence
17:35:05 <lambdabot> Monad m => [m a] -> m [a]
17:35:22 <exio4> @check \x -> ((catMaybes . return) x) == ((maybe [] return) x)
17:35:24 <lambdabot>  +++ OK, passed 100 tests.
17:36:40 <exio4> @type \f -> sequence . map f
17:36:42 <lambdabot> Monad m => (a1 -> m a) -> [a1] -> m [a]
17:36:42 <exio4> @type fmap
17:36:43 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:36:55 <exio4> they seem different... :P
17:37:20 * nitrix nods
17:39:30 <gcxcp> hi
17:40:38 <gcxcp> @help
17:40:38 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:43:02 <pharpend> gcxcp: need something?
17:43:42 <gcxcp> trying to learn irssi. Not at the moment
17:44:36 <pharpend> weechat is a bit nicer IMHO
17:52:27 <meditans> where is filterM for generic structures (like sets)? Shouldn't it be in Traversable?
17:56:19 <indiagreen> meditans: filterM can't be in Traversable since it changes the number of elements
17:57:29 <dfeuer_> Are addition and multiplication in Num generally expected to be commutative?
17:57:56 <meditans> indiagreen: you're right.. so what is the customary method to write a (a -> m Bool) -> Set a -> Set a?
17:59:00 <Pamelloes> Hello!
17:59:01 <yukko> dfeuer_ I wouldn't put it in Num if it wasn't commutative, I think that would make things pretty confusing
17:59:20 <yukko> but I don't know of anything that would behave badly with that
18:00:25 <dfeuer_> yukko, I'm just looking at the Foldable instance for Data.Sequence.Seq, and it doesn't give a specialized implementation for sum or product. It certainly *could*, but it would have to assume commutativity.
18:12:17 <indiagreen> meditans: I'd like to know the answer too, but I suspect there isn't a simple way. The closest thing I know to general filterM is contained in mono-traversable, but it's only for sequences (e.g. ByteString, Vector, etc.)
18:12:30 <zennist> some more question regarding pattern guards
18:12:57 <meditans> indiagreen: thanks anyway, I'll keep you posted if I find a simple solution
18:12:59 <zennist> say I have pattern1, pattern2 | guard
18:13:03 <indiagreen> thanks!
18:13:13 <zennist> does guard bind to pattern2 or to both pattern
18:14:11 <benzrf> what
18:15:16 <zennist> also, I know I can write pattern | predicate1 && predicate2, can I actually write pattern | predicate1, predicate2 instead?
18:16:41 <Pamelloes> Is this the right place to ask for help with Cabal, or is there a dedicated channel somewhere?
18:17:07 <nisstyre> this is the right place
18:17:21 <nisstyre> also, you should probably be using cabal sandboxes
18:17:24 <nisstyre> before you ask anything
18:18:57 <Pamelloes> I've been working on a Haskell project for a while, and I've stumbled across some problems that installing an extra library would help with.
18:19:37 <Pamelloes> I've set up a basic Cabal file to manage dependencies via "cabal init" and am now looking at the existing dependencies
18:20:09 <Pamelloes> I see it automatically added "base", "containers", and "HUnit" with some version constraints.
18:20:38 <Pamelloes> I'm unsure as to what base or containers are, and where the versions come from.
18:21:19 <Pamelloes> What are they, and how would I determine what the correct version is?
18:35:29 <v> pl \x y -> x y
18:35:46 <indiagreen> @pl \x y -> x y
18:35:46 <lambdabot> id
18:36:03 <v> tnx
18:36:06 <indiagreen> well, also ($)
18:36:26 <v> @cycleMap fs = map (\(f, x) -> f x) . zip (cycle fs)
18:36:26 <lambdabot> Unknown command, try @list
18:36:35 <v> @pl cycleMap fs = map (\(f, x) -> f x) . zip (cycle fs)
18:36:35 <lambdabot> cycleMap = (map (ap fst snd) .) . zip . cycle
18:38:52 <exio4> (\(f,x) → f x) looks like 'uncurry ($)'
18:39:44 <exio4> cycleMap = map (uncurry ($)) . zip . cycle
18:39:59 <indiagreen> exio4: nope, “fmap (map (uncurry ($))) . zip . cycle
18:40:02 <indiagreen> * ”
18:41:11 <v> @pl g a = zip (cycle a)
18:41:11 <lambdabot> g = zip . cycle
18:41:19 <exio4> close enough :P
18:42:36 <indiagreen> somehow I wish @pl would have some way to measure obscurity of answers, and actually give an answer only if it was either “too obscure” or “nice and elegant”
18:43:31 <indiagreen> because “(map (ap fst snd) .) . zip . cycle” doesn't look like something you *shouldn't* use in your code, and yet it is (or at least I think it is)
18:47:52 <v> @pl reduce1 f (x:xs) = reduce f x xs
18:47:52 <lambdabot> reduce1 = (`ap` tail) . (. head) . reduce
18:54:05 <benzrf> cripes
18:54:10 <joneshf-laptop> is there a haskell98 alternative to fundeps?
18:54:31 <benzrf> joneshf-laptop: haskell98 doesnt have multi param tcs
18:56:16 <joneshf-laptop> benzrf, so there's no way to get the same semantics with just haskell98?
18:56:59 <Tek45> Hello yall
18:57:10 <Tek45> How goes it here in H-town
18:57:19 <adarc> are there any other 'popular' pure programming languages
18:57:34 <Tek45> A broad question
18:57:46 <adarc> started playing with some ocaml today.. felt so weird being able to do i/o from anywhere
18:58:11 <benzrf> adarc: it has loop!
18:58:15 <benzrf> loopsss!!
18:58:16 <benzrf> wat
18:58:18 <adarc> dem for loops
18:58:26 <benzrf> idk joneshf-laptop
18:58:27 <adarc> i mean i like ocaml.. just felt weird going from haskell -> ocaml
19:31:50 <codygman> A friend of mine is looking for example programs/example situations where Haskell would be a huge win over Java, or even impossible in Java. Any help? :)
19:32:13 <benzrf> map (+1) [1, 2, 3]
19:35:00 <dfeuer_> :t foldMap . foldMap
19:35:01 <lambdabot> (Monoid m, Foldable t1, Foldable t) => (a -> m) -> t (t1 a) -> m
19:37:14 <benzrf> oh woot i fonud the music thing https://music-suite.github.io/docs/ref/
19:37:38 <benzrf> :t foldMap
19:37:39 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
19:37:44 <benzrf> hm hm
19:46:50 * hackagebot pipes-text 0.0.0.14 - Text pipes.  http://hackage.haskell.org/package/pipes-text-0.0.0.14 (MichaelThompson)
19:51:51 * hackagebot pipes-text 0.0.0.15 - Text pipes.  http://hackage.haskell.org/package/pipes-text-0.0.0.15 (MichaelThompson)
20:10:50 <u-ou> how are haskell compilers implemented so that recursion is always stack-safe?
20:12:07 <Pamelloes> How would I apply a function a -> Int on IO a?
20:12:48 <u-ou> fmap
20:13:07 <Pamelloes> Thanks :)
20:13:10 <u-ou> np
20:15:52 <stephenmac7> How would I go about switching monads?
20:16:39 <stephenmac7> So, take (Just (getLine)) and perform the io action but don't take it out of the Just
20:17:14 <simpson> u-ou: Generally, Haskell implementations are graph reducers.
20:17:22 <simpson> They don't have call stacks.
20:19:15 <benzrf> stephenmac7: huh?
20:19:46 <u-ou> hmm, I looked up graph reducer on wiki but there was no such page. is it part of graph theory?
20:20:40 <simpson> If you look under "g machine" you'll find some stuff.
20:20:49 <stephenmac7> benzrf: Something like (Monad m1, Monad m2) => m1 (m2 a) -> (m1 a -> m2 b) -> m2 b
20:20:53 <Arahael> u-ou: Probably.  Haskell pretty much works on the notion that you have expressed your code as a graph, from what I understand. (Ie, entirely of functions taking one argument)
20:21:16 <Arahael> u-ou: It looks at the graph and determines what it needs to know and what could be simplified, and reduces those points.
20:21:24 <u-ou> yeah
20:21:34 <u-ou> where can I read about how that's done?
20:21:47 <stephenmac7> It's hard to explain, "switching" probably wasn't the best term
20:21:52 <u-ou> not that I /need/ to know, I'm just interested.
20:22:25 <Arahael> stephenmac7: Why not take it out of the monad?
20:23:43 <stephenmac7> Arahael: Probably not a good idea. I should probably just explain the specific issue I'm having.
20:23:58 <michaelt> u-ou: maybe look around here and the links in it? https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/GeneratedCode
20:24:46 <stephenmac7> I have the line (widget, enctype) <- generateFormPost madLibForm inside a Handler monad in Yesod but would like to instead generate a maybe value based on whether another value is already maybe
20:25:32 <u-ou> michaelt: thanks, will do
20:25:41 <stephenmac7> So, if myValue is a maybe, I would like the resulting value to be Just (widget, enctype) if it's a Just or Nothing if it's Nothing
20:26:08 <Pamelloes> How do I compare an IO Int with a regular Int to get a Bool? I've tried using fmap and (==) but that gets me an IO Bool...
20:26:21 <stephenmac7> Arahael: Do you follow?
20:27:09 <Arahael> stephenmac7: Yes.  I'm very much a newbie in Haskell though, but it sounds like you want to merge two maybes instead.
20:27:11 <michaelt> Pamelloes: fmap (== 17) ioint will be an IO Bool if ioint:: IO Int
20:27:38 <Arahael> stephenmac7: This is beyond my skillset, but you want to go from Maybe Maybe a -> Maybe a?
20:27:50 <stephenmac7> Not quite
20:28:09 <geekosaur> Pamelloes, you can never remove something from IO, you can only work inside of IO. look at do notation or the >>= operator
20:28:33 <michaelt> Pamelloes: oh, that was dumb. The correct answer is there's no hope.
20:28:47 <Pamelloes> Can I use an IO Bool in an if statement?
20:28:58 <geekosaur> not directly. again, please look at do notation
20:29:32 <simpson> Pamelloes: No, but you can draw from it to get a Bool and then use that.
20:29:40 <michaelt> Pamelloes: in do notation you would write do { n <- ioint ; if n == 17 then .... else ...}
20:30:14 <Pamelloes> Huh. Thanks :)
20:30:24 <geekosaur> note that you must go back into IO at the end
20:30:50 <geekosaur> something in IO stays in IO; do notation lets you pretend for a bit that you can "unwrap" it (but there is no actual unwrapping)
20:30:56 <geekosaur> @quote /bin/ls
20:30:56 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
20:31:42 <Pamelloes> I'm already in a do block, so that is exactly what I was looking for
20:32:11 <michaelt> Pamelloes: right, in do { n <- ioint ; if n == 17 then .... else ...} the ... things must be of the same type, and it must be an IO type, e.g. IO Int
20:32:49 <michaelt> Pamelloes: then the whole 'do block' has the type :: IO Int  , or whatever
20:33:01 <Pamelloes> yep :) My code works now
20:33:32 <michaelt> Pamelloes: ah good!
20:41:47 <stephenmac7> benzrf: Arahael: Okay, I got it to work. Now that I have working code, I can actually ask. http://lpaste.net/113965
20:41:58 <stephenmac7> Is there a way to get a more generalized version of the above?
20:44:42 <Arahael> stephenmac7: Totally behond my capabilities at the moment... Maybe applicative *>, orElse, or perhaps even liftM2?
20:44:53 <stephenmac7> Okay, thanks
20:45:19 <Arahael> *beyond.
20:46:53 * hackagebot github 0.12 - Access to the Github API, v3.  http://hackage.haskell.org/package/github-0.12 (cesar_nataren)
20:49:20 <michaelt> @type orElse
20:49:21 <lambdabot> Not in scope: ‘orElse’
20:51:03 <michaelt> stephenmac7: if you were in MaybeT IO blah it would be do { mauth; liftIO (generateFormPost form)}
20:52:01 <stephenmac7> michaelt: Don't think it's MaybeT
20:53:38 <michaelt> no you would have to wrap it.  but this would be right, even given these materials :  runMaybeT $  do { MaybeT mauth; liftIO (generateFormPost form)}
20:54:40 <michaelt> this was just supposed to show a 'more generalized version' ...  maybe not too successfully...
20:56:02 <stephenmac7> Okay, thanks
21:01:00 <Arahael> readMaybe is in network.cgi?
21:01:26 <Arahael> Why not in prelude or something?
21:01:45 <Arahael> (I'm not doing CGI, wondering why to pull in CGI...)
21:04:45 <michaelt> isn't it in Text.Read now, or something like that.... in base
21:05:12 <vrdhn0> hi. How to do composition of getRealUserID , getUserEntryForID and userName ( from System.Posix.User) ?
21:05:35 <michaelt> Arahael: readMaybe :: Read a => String -> Maybe a in Text.Read
21:06:43 <Pamelloes> If I catch an exception, is there a way to log the exception as if it wasn't caught?
21:06:53 * hackagebot hps 0.15 - Haskell Postscript  http://hackage.haskell.org/package/hps-0.15 (RohanDrape)
21:07:20 <michaelt> vrdhn0: well getReadUserID >>= getUserEntryForID  :: IO IO UserEntry
21:07:22 <Arahael> michaelt: How did you find that? I was using hoogle.
21:07:42 <michaelt> Arahael: I just remembered. It's a recent addition.
21:07:53 <Arahael> Ah.
21:08:12 <michaelt> Arahael: I think it had been defined in several places in the past, since its obviously a winner
21:08:40 <Arahael> Yep, that works, I think.
21:09:56 <michaelt> vrdhn0: or do { rui <-  getReadUserId; uefi <- getUserEntryForID; return (userName uefi)} :: IO String
21:11:28 <vrdhn0> michaelt: thx ... i was searching for do-less way
21:11:51 <Arahael> Hmm.  So I have something like: trans :: [String] -> Maybe Foo; trans x = do ...(many lines of a <- readMaybe's)... return $ Foo a b c d e f
21:11:57 <Arahael> Is there a more elegant way of doing that?
21:11:57 <michaelt> fmap userName (getReadUserId >>= getUserEntryForID)
21:12:55 <Arahael> Maybe I should merely desugar it. Hmm.
21:14:28 <vrdhn> michaelt: fmap soln. rocks!
21:15:18 <michaelt> ah good.
21:18:25 <greymalkin> Okay, I'm getting something that seems odd behaviour.
21:18:40 <greymalkin> Can a function defined in 'let' be used with more than one type?
21:21:52 <greymalkin> I'm having to wrap the results in 'fromIntegral' when it's downcast to an Int, but the function is inspecific.
21:22:40 <michaelt> you can put a signature in the let ... let x :: Int; x = fromIntegral x
21:22:44 <michaelt> you can put a signature in the let ... let x :: Int; x = fromIntegral z
21:22:49 <michaelt> rather
21:23:05 <michaelt> or the like
21:24:12 <greymalkin> It's a little more complicated; I'm trying to read a string using break, mapFst, and readMaybe -- the three values are Integer Int Int (a date, but can be followed by arbitrary data)
21:24:22 <u-ou> oh, btw, there is a wikipedia article on graph recuders after all, Graph_reduction :P
21:25:01 <greymalkin> this might be easier: http://pastebin.com/SeRJgVHg
21:25:45 <greymalkin> the Year part of each constructor is an integer, the Month and Day constructors take an Integer first, and Int's after.
21:26:51 <greymalkin> If I remove the 'fromIntegral' calls, it fails to compile, but that it contrary to what I know about polymorphic functions in haskell
21:28:13 <Pamelloes> How do I put a constraint on a lambda function's parameter?
21:28:36 <Welkin> Pamelloes: make it a top level function
21:29:16 <michaelt> greymalkin: is it that readMaybe is asked to give an Int in some cases and an Integer in others
21:29:27 <Pamelloes> Welkin: Is there really no other option?
21:29:31 * Arahael does a little dance: Applicative is a powerfull tool!
21:30:03 <greymalkin> michaelt: Yes, but it has a clear path towards which it should be providing in what context... doesn't it?
21:30:22 <Arahael> Though, it's bogglign my mind how haskell manages to infer so many types.
21:30:42 <michaelt> yeah I see, it's the third use of yank that yields (Maybe Integer, ...)
21:30:45 <Welkin> Pamelloes: you could define it in a let statement or a where clause with a type signature as well
21:31:06 <Welkin> if your function is that complex, it should have a proper type signature
21:31:33 <michaelt> if yank was given the type Num a => String -> (Maybe Int, String) would it work?
21:31:34 <Arahael> Welkin: Who are you talking to?
21:31:54 <Pamelloes> My function is incredibly simple: \e -> failure. I need to type "e" as an Exception for it to work as a parameter in "handle"
21:32:01 <michaelt> sorry, greymalkin I meant  yank :: Num a => String -> (Maybe a, String)
21:33:15 <michaelt> Pamelloes: there is a swanker way of doing it, but \(e::SomeException) -> failure ... works with ScopedTypeVariables
21:34:11 <Pamelloes> Hm... I created a top level function, yet I still can't get my handle statement to work.
21:34:22 <greymalkin> michaelt: Hmm...
21:34:36 <michaelt> greymalkin: it might also work (I mean the code you wanted to write) with NoMonomorphismRestriction
21:34:39 <greymalkin> It has to be (Read a, Num a) => String -> (Maybe a, String) -- but that does work.
21:34:42 <Pamelloes> Does any one have any experience with writing a function for the first parameter in Control.Exception.handle? I can't for the life of me get it to compile...
21:35:19 <michaelt> greymalkin: right, I forgot Num of course doesnt include Read
21:35:19 <benzrf> bye
21:35:20 <greymalkin> AH!!!
21:35:21 <wei2912> when should i omit the type signatures and let ghc infer?
21:35:41 <greymalkin> It's the monomorphism -- I usually work from GHCi to make sure it works first, and that's what's doing it.
21:35:54 <michaelt> greymalkin: right ghci doesn't have it, but the module will
21:36:51 <greymalkin> Ah, even better: (Read a) => String -> (Maybe a, String) -- more generic.
21:37:04 <michaelt> right, of course
21:40:13 <derekv> after working with python for several hours today, I'm further than ever from seeing an advantage to dynamic typing
21:40:31 <simpson> derekv: Which languages are you used to?
21:41:05 <Yxven> I'd still take python over java/c++
21:41:34 <derekv> c/c++/java, javascript some common lisp, some haskell
21:41:54 <simpson> Yeah, after Haskell, it might be hard to see any advantage in the Python way.
21:42:36 <derekv> mostly, not having types on function parameters and returns
21:42:36 <simpson> The big advantage, in my opinion, is that Python types aren't closed in the constructors; you can always add a new subclass or constructor to a given type.
21:43:21 <simpson> Haskell has type classes and type families, but they aren't quite the same. The expression problem stings in Haskell and Python alike, but Python can attack it without a recompile.
21:44:17 <derekv> I think where it gets all wonky is, for example, this API call, which returns a "result", then unless the error handler part of the code doesn't recognize the error, in which case it returns "False"
21:44:39 <derekv> so the way I find out if I hit the API rate limit is ".notes not found on bool"
21:45:03 <simpson> Ah, that's always exciting.
21:46:30 <derekv> python is better overall than c++ or java, certainly
21:47:40 <Arahael> derekv: "certainly"?  Not even as a python fan can I agree with that.
21:48:00 <derekv> but throw a static type checker on method parameters and return values and I think you'd have an improvement
21:48:17 <Arahael> derekv: You wouldn't have python, then.  (But... there are linters available)
21:49:11 <simpson> But a type checker on values is very different from actual type inference.
21:49:31 <Arahael> Well, if you want a python-like language with type inferrence, check out Boo.
21:49:43 <Arahael> But it ends up being a different language, despite nearly the same syntax.]
21:52:46 <Arahael> So what is it called if I want the bash equivalent of: foo | bar | baz
21:53:04 <Arahael> Ie, take the output of foo, feed it through bar, then the result through baz, in the IO monad.
21:53:10 <derekv> I don't really want a python-like language that bad.  It's ok.  I just would like to understand the advantage of dynamic typing, I've never lived with it for a long time, the only thing I can see it buying you is the ability to do smelly stuff and impose a runtime performance penalty
21:53:36 <Arahael> derekv: Well, I can make my python programs almost as fast as C++ apps.
21:54:09 <Arahael> derekv: (By leveraging the modules that happen to be implemented in C).   But you won't understand the advantage of dynamic typing, until you realise that they have so many different notions of 'type'.
21:54:13 <shelf> Arahael: some streams implementation, like Pipes or Conduit?
21:54:42 <derekv> Arahael: Yea I think there is still a lot for me to learn.
21:54:44 <Arahael> derekv: Consider Javascript and Python.  The former has very few types (and loves coercion even then), while the latter has dynamic types, but only the values know what type they are.
21:55:36 <Arahael> shelf: As an absolute newbie, which should I look into first?  To put it in concrete terms, I have a list of values. I want to process that list using multiple filters and then finally achieve the small set of values that have survived the filters.
21:56:54 <michaelt> bazfilter . barfilter
21:57:14 <simpson> derekv: I recommend reading up on "the expression problem" for a good example of why dynamic typing can be useful.
21:57:20 <shelf> Arahael: might be worth waiting for a more experienced person, but if the data set is small and finite then you could avoid use of streaming libraries :)
21:57:52 <shelf> i mean, if oyu have filtering functions you could just connect them together with foo >>= bar >>= baz
21:58:09 <michaelt> with a pipe it would be fooproducer >-> barpipe >-> bazpipe
22:00:03 <Arahael> shelf: I'm going to play with the >>=.
22:00:06 <Hijiri> well there's the Dynamic dynamic type, and also Generic things
22:00:15 <Hijiri> I don't really know how the latter work that well though
22:00:35 <Arahael> Hijiri: Dynamic types still have a type, don't they?  As do Generics.
22:00:51 <Arahael> Some dynamic languages say that "everything is either: number, string, null, or dictionary".
22:01:02 <shelf> Arahael: have fun!
22:01:44 <Hijiri> well sure, but you can pass Dynamic into whatever function that accepts it, regardless of what it was before
22:02:48 <Hijiri> I think if you want to be able to do something to a type without even checking what it is, Generic does some things with that, but I have no idea how Generic works, I've just heard about it
22:03:43 <derekv> simpson, thanks for the link
22:03:55 <derekv> or search term rather
22:06:55 * hackagebot hzulip 1.1.0.0 - A haskell wrapper for the Zulip API.  http://hackage.haskell.org/package/hzulip-1.1.0.0 (yamadapc)
22:12:47 <Arahael> Hijiri: My point is...  In some/many dynamic languages, there is no type to check.
22:13:08 <Arahael> Hijiri: It's not a matter of checking the type if you want or choosing not to check it... You literally can't check it.
22:23:55 <shelf> Arahael: you might like to look at transducers as an example of something ostensibly useful that happens to be hard/impossible to type
22:24:48 <shelf> (all i know about them is A) useful B) untypable in the Haskell sense as far as anyone knows so far)
22:25:56 <simpson> shelf: The objective package might provide suitable transducers. It's still young though.
22:26:01 <Arahael> shelf: I don't understand what that means.
22:27:05 <shelf> simpson: oh, that's interesting! some weekend reading for me
22:27:55 <shelf> Arahael: disregard :) was trying to illustrate that some objectively-good things are currently only possible in dynamically typed languages
22:31:46 <Arahael> shelf: I think dynamic languages are especially good where you want to get part of a solution.
22:32:35 <Arahael> Anyway.  I've gotten >>= working, but I now have many lines of the form: >>= return.liftM myTransformOrFilter
22:32:45 <Arahael> Do I need to have that return.liftM all the time?
22:40:01 <shelf> Arahael: are you able to post the function on lpaste?
22:40:30 <Arahael> shelf: To what end? It's just a part of main.
22:41:06 <shelf> I'm just curious how you're using liftM and don't want to give misleading advice :)
22:41:26 <Arahael> shelf: Literally: main = dosomething >>= return.liftM somethingElse >>= return.liftM somethingElse2 >>= putStrLn
22:42:41 <jle`> does that actually typecheck?
22:43:19 <jle`> what are the types of somethingElse ?
22:43:43 <Arahael> jle`: Some to think of it, there is an extra monad in there. (dosomething :: Either ParseError csv)
22:43:59 <jle`> oh
22:44:12 <jle`> then that just looks like a bunch of fmaps
22:44:53 <jle`> putStrLn . fmap (somethingElse2 . somethingElse) =<< dosomething
22:45:53 <Arahael> jle`: You've reversed everything there. Hmm, perhaps when I get some time (I have only 5 minutes now before I must leave), I'll paste the function and properly discuss it.
22:45:54 <jle`> er, wait, if doSomething is an Either, then your whole thing is Either, and not IO?
22:46:09 <jle`> if you put the types of stuff, i'll be able to give a better answer :P
22:46:15 <jle`> Arahael: i just un-reversed your reversal ;)
22:46:25 <jle`> i like applying and composing functions in normal order :P
22:46:38 <Arahael> jle`: Sounds like we definitely have at least 30 minutes to discuss this, so I'll have to find that time later.
22:46:49 <Arahael> jle`: Thanks for the tip. :)
22:47:01 <jle`> np :)
22:47:15 <jle`> using "return" is actually sometimes a smell
22:47:22 <jle`> actually it's often a smell, i've found
22:47:33 <Arahael> jle`: Good to know - glad I picked up on it.
22:47:44 <jle`> and if you aren't writing polymorphic code, `fmap` is preferred usually over liftM :)
22:48:01 <jle`> liftM only exists when you have code over foo :: (Monad m) => ..., and you don't want to add an additional Functor constraint
22:48:03 <Arahael> Anyway, later!  Thanks again.
22:48:05 <jle`> but taht reason is going to go away in 7.10
22:48:11 <jle`> take care!
23:24:15 <Mokosha_> hi -- can someone explain to me why I'm getting this compiler error: https://gist.github.com/Mokosha/996923a92d6a7e196e17
23:26:58 * hackagebot hspec-meta 1.12.4 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.12.4 (SimonHengel)
23:31:58 * hackagebot hspec 1.12.4 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-1.12.4 (SimonHengel)
23:34:56 <favetelinguis> How do i do an infinit loop in a main function given that the last call has to be an IO action but i want it to be a recursive call?
23:35:38 <etaoinshrdlu> favetelinguis: You can call main within itself
23:35:52 <MP2E> Mokosha_: try giving 'doThing foo' an explicit type signature
23:37:01 <MP2E> at first glance it looks to me like an instance of the Monomorphism Restriction
23:37:02 <MP2E> https://www.haskell.org/haskellwiki/Monomorphism_restriction
23:43:11 <thebnq> it might be the opposite, isn't it just unable to uify a0 with V2?
23:46:47 <favetelinguis> I have two questions with the following code: http://lpaste.net/113968
23:47:28 <favetelinguis> 1: How can this work when the last action in a do block must be an IO action, here it is either a rucursive call or undefined.
23:47:52 <Cale> The type of that case expression is the same as the type of main, which is an IO action
23:48:11 <tempeh> I'm trying my best to install scion with cabal, having used neither before. Can anyone point me in the right direction?
23:48:42 <tempeh> Lots of dependency problems
23:48:42 <favetelinguis> 2: Why is not Enter number printed before a getLine is required. When i start the program i get to input a number before the text is printed
23:49:17 <Cale> favetelinguis: That one is because of line buffering.
23:49:30 <etaoinshrdlu> It think it has to do with buffering
23:49:35 <etaoinshrdlu> There you go
23:49:50 <favetelinguis> how would i change the code to guarantee the order of execution?
23:49:57 <etaoinshrdlu> There are 3 types of buffering, right? Block, line and none?
23:49:58 <Cale> favetelinguis: If you import System.IO and do hFlush stdout after the putStr "Enter number: ", you'll see it printed
23:50:07 <Cale> The order of execution is as you'd expect
23:50:36 <Cale> the problem is simply that the terminal I/O is buffered, so it waits until it has a complete line before printing anything.
23:50:49 <favetelinguis> aa ok
23:51:02 <Cale> You could also switch this off by doing  hSetBuffering stdout NoBuffering  at the start of the program
23:51:28 <favetelinguis> getting to advanced but at least i know what is up
23:51:45 <thebnq> putStrLn will force the print at least
23:52:28 <favetelinguis> so in question 1, if i did use an if statement instead the program would break since the return type of an if is not the same as a case right?
23:53:01 <favetelinguis> of sorry wait, the if would return a tyep of IO () since is is calling main?
23:53:22 <thebnq> yes
23:54:54 <thebnq> if is kind of just a case on bool
23:56:41 <favetelinguis> is there a way to use the n variable from line 3 outside of the do statement but not just in a function call. That is could i have moved the case statment outside of do and put it directly under the main function?
23:58:52 <etaoinshrdlu> I guess you could do something like `read n >>= \n' -> case 'n of`
