00:00:36 <numberten> is there a ghci command to get the fully qualified path of a function in scope?
00:01:17 <numberten> something like..
00:02:03 <numberten> > :path mappend => Data.Monoid.mappend
00:02:04 <lambdabot>  <hint>:1:1: parse error on input ‘:’
00:06:44 <sivteck> you can use :info mappend to see where the function is defined
00:07:15 <numberten> thanks :D
00:07:34 <sivteck> (or :i)
00:11:11 * hackagebot stripe-haskell 0.1.1.0 - Stripe API for Haskell  http://hackage.haskell.org/package/stripe-haskell-0.1.1.0 (DavidJohnson)
00:11:11 * hackagebot netwire-input 0.0.3 - Input handling abstractions for netwire  http://hackage.haskell.org/package/netwire-input-0.0.3 (Mokosha)
00:31:06 * hackagebot rethinkdb-client-driver 0.0.10 - Client driver for RethinkDB  http://hackage.haskell.org/package/rethinkdb-client-driver-0.0.10 (wereHamster)
00:41:06 * hackagebot alarmclock 0.1.0.2 - Wake up and perform an action at a certain time.  http://hackage.haskell.org/package/alarmclock-0.1.0.2 (dcturner)
01:46:43 <trap_exit> asdf
01:46:55 <trap_exit> why is #haskell so quiet
01:47:09 <kafi> we're lazy
01:47:16 <kafi> :p
01:47:34 <trap_exit> right, no one does work unless a quewstion is asked
01:48:02 <Kinnison> ssssh, some of us are hoping our weak heads will cease being our normal form
01:55:42 <wz1000> Why is 'type I a = a -> I a' illegal while 'newtype I a = I ( a -> I a)' legal?
01:58:00 <jle`> wz1000: type is just a type synonym
01:58:11 <jle`> like a typedef
01:58:15 <jle`> what would "I a" compile to?
01:59:36 <jle`> (they disappear/are resoved at compile time)
02:00:18 <biinui> hi :) i'm trying to convert ogg to a buffer that OpenAL can play but there's error that says "createBuffer: Unsupported file type". please check code http://lpaste.net/114338
02:01:03 <wz1000> Is there any way to define 'fix' or 'y' in haskell without any recursion?
02:01:32 <bitonic> wz1000: do recursive types count as recursion?
02:02:16 <wz1000> bitonic: Maybe. What is your solution?
02:03:36 <bitonic> wz1000: you can write pretty much y with ‘data Fix f = Fix (f (Fix f))’
02:04:41 <wz1000> How about without any recursion at all, even at the type level.
02:05:29 <bitonic> wz1000: well you could if you had some anonymous recursive types – but recursion is a pretty key point in ‘fix‘ :P
02:06:17 <bitonic> I mean if you look at why ‘y‘ doesn’t type check, it’s because you’d need an infinite type to type check it
02:06:43 <bitonic> that Fix type let’s you manually fix that error
02:07:09 <wz1000> Isn't fix supposed to embody the idea of recursion? It is nonsensical, yet strangely fitting that it requires recursion to be present in order to be expressed
02:09:15 <bitonic> wz1000: well fix in the lambda calculus sense is nice because is’t sort of surprising that you can write such a function in such a limited language
02:09:27 <bitonic> wz1000: but with simple types you can’t, which is also nice
02:10:47 <bitonic> so the fact that you need a special recursive type to write fix in Haskell is not an accident
02:21:55 <josephleon> how do i have Wall set as a default in ghci?
02:24:42 <bitonic> josephleon: put ‘:set -Wall‘ in your .ghci
02:25:19 <josephleon> @bitonic yea i found that in a stackoverflow article but I dont have a .ghci file
02:25:19 <lambdabot> Unknown command, try @list
02:25:58 <bitonic> josephleon: ‘echo ":set -Wall" > ~/.ghci’
02:26:16 <josephleon> oh, so if I make one it will just start working and picking it up?
02:26:36 <bitonic> correct, like most config files
02:26:50 <josephleon> ah noted, thank you
02:27:20 <ClaudiusMaximus> biinui: looks like you're decoding the ogg to raw data, but I'm guessing FileImage wants a header in front (eg WAV or whatever)
02:29:10 <ClaudiusMaximus> biinui: you might be better off using bufferData directly, with [buffer] <- genObjectNames 1  http://hackage.haskell.org/package/OpenAL-1.6.0.0/docs/Sound-OpenAL-AL-Buffer.html
02:31:19 <ClaudiusMaximus> biinui: also unsafeForeignPtrToPtr is unsafe, better use withForeignPtr
02:35:51 <ocharles> chrisdone: shower revelation!
02:36:00 <ocharles> I have an alternative alternative interface :P
02:36:33 <ocharles> I have an alternative alternative interface :P
02:36:43 <ocharles> ahem, this is not my terminal. excuse me
02:40:28 <biinui> ClaudiusMaximus: thanks! i'll check the it out :)
02:45:08 <chrisdone> ocharles: hey =)
02:46:22 <ocharles> chrisdone: I may have been prematurely excited... but I'm thinking something like https://gist.github.com/ocharles/82617eaf1a4a0b448af4
02:46:36 <ocharles> The thought was "why do we have a separate way to access attributes vs children. What if we merge them?"
02:46:51 <ocharles> So I take the same approach I was playing with using lens, but do the modifications in a state action now
02:47:13 <ocharles> the next thought was that `div` and other HTML elements could implicitly be a call to append a child element to the currently focused element
02:47:19 <ocharles> but I got stuck there :)
02:49:26 * chrisdone peeks
02:53:17 <ocharles> Anyway, better get on with this mornings math degree Pomodoros :)
02:53:19 <chrisdone> ocharles: this is similar to the api we're playing with for ghcjs-react. build "div" (do attr "class" "row"; text "hi")
02:53:26 <ocharles> oh, cool
02:53:37 <chrisdone> ocharles: so those nested states, i'm trying to figure out what type it will be
02:53:53 <ocharles> I was just trying to avoid forcing `div` et al to *always* take an argument
02:54:19 <ocharles> (&!) works if you know what the left hand side is. but if `div` nests itself in the parent, then div :: MonadState HTML m => m HTML, so (&!) becomes a bit weirder...
02:59:18 <chrisdone> ocharles: interesting… i'd be interested to see it fleshed out =)
02:59:59 <ocharles> yea, i'll see where it goes
03:24:29 <trap_exit> what's the best haskell ide to use on a surface pro 3 ?
03:24:32 <trap_exit> what's the best haskell ide to use on a surface pro 3 ?
03:36:13 * hackagebot json-autotype 0.2.5.0 - Automatic type declaration for JSON input data  http://hackage.haskell.org/package/json-autotype-0.2.5.0 (MichalGajda)
03:42:09 <nerium> I’m trying to comple the follwing code, but I*m getting an error https://gist.github.com/oleander/0bba1ff3a81e929af13f
03:42:20 <nerium> I’m not really sure what it means
03:42:23 <nerium> … and how to fix it
03:43:18 <bitonic> nerium: have you read up on Haskell’s syntax?
03:43:47 <nerium> bitonic: Yes, but it was a while
03:43:51 <bitonic> nerium: because you’re calling functions wrong – in Haskell you have ‘f arg1 arg2 …‘
03:44:48 <bitonic> not ‘f(arg1, arg2, …)‘
03:45:18 <nerium> bitonic: Okay, so how does it then know how to priority the different args?
03:45:32 <thungsten> nerium: https://gist.github.com/niilohlin/f34fefba3da06bb6ab6b
03:45:37 <nerium> e (x - 1), rec (x - 1) , d, e
03:45:37 <nerium> that doesn’t make much sense :)
03:45:48 <bitonic> nerium: what do you mean with “priority”?
03:46:14 * hackagebot json-autotype 0.2.5.1 - Automatic type declaration for JSON input data  http://hackage.haskell.org/package/json-autotype-0.2.5.1 (MichalGajda)
03:46:39 <bitonic> nerium: no commas, just ‘e (x - 1) (rec (x - 1) d e)’.  you pharentesise the arguments if needed
03:46:54 <nerium> thungsten: That looks like the exact same code as mine :)
03:47:04 <thungsten> oops, updated it now
03:48:02 <nerium> thungsten: bitonic Aha, that makes sense
04:27:41 <koniiiik> Is it possible to make a type definition where a certain constructor would be applicable only to arguments in a specific form?
04:29:32 <koniiiik> For example, if you want to define integers and want to only allow Succ x if x is either Zero, or Succ y for some y, and Pred x if x is either Zero or Pred y?
04:29:42 <koniiiik> Is that possible in Haskell at all?
04:31:04 <funrep> i dont quite understand what you try to do, care to maybe give example code?
04:31:36 <thungsten> data N = Z | S N
04:31:38 <thungsten> like so?
04:32:07 <exio4> he wants then, something like "data P = Z | S P", which wouldn't work
04:34:38 <koniiiik> Okay, I'll try again. Basically, what I want is to write the following definition of a set as a Haskell data type: Zero \in Z, Succ Zero \in Z, Pred Zero \in Z, if Succ x \in Z then Succ Succ x \in Z, if Pred x \in Z then Pred Pred x \in Z.
04:35:35 <koniiiik> It looks like I'd need some kind of guards in the type definition, but it looks like I can't do that in Haskell.
04:36:16 * hackagebot fluent-logger 0.2.0.0 - A structured logger for Fluentd (Haskell)  http://hackage.haskell.org/package/fluent-logger-0.2.0.0 (NoriyukiOhkawa)
04:36:36 <koniiiik> The intention is to give each integer only one valid representation in the data type.
04:36:38 <thungsten> if you need guards ini the type definition. The most common solution is to make a module and not expose the type constructor
04:36:45 <ClaudiusMaximus> you could use smart constructors to ensure the invariant "no mix of succ/pred" - something like succ Zero = Succ Zero, succ (Succ n) = Succ (Succ n), succ (Pred n) = n
04:39:41 <ski> koniiiik : perhaps something like `data Integer n where Zero :: Integer n; Pred :: Integer NonPos -> Integer NonPos; Succ :: Integer NonNeg -> Integer NonNeg' ?
04:41:00 <koniiiik> ski: Uh, I'm not familiar with those constructs, can you provide a link to a documentation for that?
04:41:29 <ski> koniiiik : i'm using the GADT syntax for defining a datatype
04:41:37 <ski> heard about that before ?
04:42:04 <koniiiik> ski: Nope, reading up on that right now.
04:42:32 <ski> one option here is to first define two dummy types `data NonPos; data NonNeg' that act as tags for the `Integer' type above
04:43:21 <ski> in the GADT syntax, one explicitly specifies the type signature of all the constructors, instead of just mentioning the argument types of them
04:43:52 <ClaudiusMaximus> ski: i don't see how to type 'add' with those tags
04:44:54 <ski> note that in the ordinary Algebraic Data Type syntax, e.g. `data Maybe a = Nothing | Just a', the corresponding Generalized Algebraic Data Type syntax is `data Maybe a where Nothing :: Maybe a; Just a -> Maybe a'
04:45:51 <ski> but for a parameterized data type like this, the eventual return type of each constructor will always be the type constructor that is being defined, applied to an "argument list" of *distinct* type *variables*
04:46:19 <ski> koniiiik : what the GADT syntax allows is you deviating from those two last restrictions
04:46:43 <ski> so that i have `Succ :: ... -> Integer NonNeg' rather than `Succ :: ... -> Integer n'
04:47:26 <ski> so, once i've applied `Succ' to `Zero', i can no longer apply `Pred' to it, but only `Succ' again, and vice versa, since i used different tags for `Pred' and `Succ'
04:47:42 <ski> ClaudiusMaximus : yes, i hadn't gotten that far yet :)
04:47:52 <ski> koniiiik : makes any sense at all ?
04:49:32 <ski> ClaudiusMaximus : i suppose one'd need an existential .. a bit irritating
04:50:48 <koniiiik> ski: Yeah, at a high level, but I don't really see how the definition you gave allows you to apply, for example, Pred to Zero.
04:52:22 <ski> koniiiik : `Zero :: Integer n', for any `n' (iow `Zero :: forall n. Integer n'), so in particular `Zero :: Integer NonPos'. now since `Pred :: Integer NonPos -> Integer NonPos', we get `Pred Zero :: Integer NonPos'
04:53:15 <ski> of course the tags `NonPos' and `NonNeg' must be defined as well, somehow. e.g. like `data NonPos' and `data NonNeg', since we probably don't care about values of those types
04:53:58 <koniiiik> ski: Oh, I see, so the `n' argument is for `NonNeg' and `NonPos'.
04:54:03 <deni> is anyone using vim syntastic?
04:54:08 <ski> koniiiik : yes
04:54:09 <koniiiik> That's what I was missing.
04:54:13 <ski> it's for the tag
04:54:46 <thungsten> deni: I do
04:55:22 <deni> thungsten: for some reason it list a syntax error in the status line on every file...even though there is no syntax error
04:55:26 <deni> thungsten: you don't have that?
04:55:43 <ski> or if you prefer, you could define `data NonPos = NP' and `data NonNeg = NN', or even `data NonPos = NPZero | NPPred NonPos' and `data NonNeg = NNZero | NNSucc NonNeg', should you prefer `NonPos' and `NonNeg' themselves to behave like two copies of the natural numbers
04:56:03 <ski> but if you're only going to use `NonPos' and `NonNeg' as tags for `Integer', it doesn't matter much
04:56:17 * hackagebot fluent-logger-conduit 0.3.0.0 - Conduit interface for fluent-logger  http://hackage.haskell.org/package/fluent-logger-conduit-0.3.0.0 (NoriyukiOhkawa)
04:56:17 <thungsten> deni: no, if the syntax is correct. It does not list a syntax error. What does it say?
04:56:39 <deni> thungsten: http://pixbin.us/wntpiy
04:56:52 <deni> nothing fancy just that there is some sort of syntax error on that line
04:56:59 <ski> koniiiik : now, two things. instead of saying `data Integer n where ...' you can say `data Integer :: * -> * where ...', which i prefer here. but that also requires the extension `KindSignatures'
04:57:05 <deni> thungsten: but when i go to that line (3) there's no marker there
04:57:37 <thungsten> deni: Are you sure? can you post the code?
04:57:43 <ski> koniiiik : the other thing. `n' in `Integer n' is allowed to be any type (so e.g. `Integer Bool' is a valid type), even though we only intend to concretely use `NonPos' or `NonNeg' there
04:57:57 <deni> thungsten: I'm sure cause it happens on every file like ever :)
04:58:05 <deni> thungsten: the code compiles...ghc doesn't complain
04:58:49 <thungsten> deni: maybe the syntax error is in some plugin? I have never seen this error
04:58:50 <osa1> is there a way to ask cabal dependencies of an installed package? I want to know with which packages is ghc package linked(including version numbers)
04:59:09 <ski> koniiiik : if you instead enable the newish extension `DataKinds', then you can instead define `NonPos' and `NonNeg' as `data Sign = NonPos | NonNeg'. and then with `KindSignatures' you could (if you want to) say `data Integer :: Sign -> * where ...'
04:59:55 <deni> thungsten: I have no idea.....perhaps i have configured it wrongly...can you share your vimrc?
05:00:31 <ski> koniiiik : btw, i'm assuming you know that `*' is the kind of concrete types, `* -> *' is the kind of type functions mapping a concrete type to a concrete type (so e.g. `Maybe' has that kind). here `Sign -> *' is the kind of type functions mapping a tag of *type* `Sign' into a type of kind `*' (iow a concrete type)
05:01:12 <Gurkenglas> If I have a tree and for each leaf a lens that points to it, will applying a function to each lens in turn generate a new tree on each iteration or only one?
05:01:53 <Gurkenglas> ("applying each lens to a function in turn" is more accurate right?)
05:02:28 <ski> koniiiik : btw, another representation for integers is `data Integer = Minus Natural Natural' .. but you have to make sure here that you don't distinguish between e.g. `2 - 5' and `4 - 7' here (so, the intended type you want here is really a "quotient type" of the representation type that this definition gives you)
05:02:32 <koniiiik> ski: Uh, to be honest, I got lost.
05:03:24 <ski> koniiiik : otoh, with a plain `data Integer = Zero | Pred Integer | Succ Integer', what you asked for was a "subtype" of this representation type, not allowing `Succ' and `Pred' to be mixed in one value
05:03:30 <ski> koniiiik : .. ok, np
05:04:49 <ski> koniiiik : sometimes people call this approach with type tags "phantom types", though that terminology was invented before GADTs were, and is perhaps slightly inappropriate for what GADTs do
05:05:50 <ski> @wiki Phantom type
05:05:50 <lambdabot> http://www.haskell.org/haskellwiki/Phantom_type
05:06:59 <deni> thunderrd: also is there any way to get syntastic to work async? it quite lags on every buffer write?
05:07:19 <ski> @wiki Generalised algebraic datatype
05:07:20 <lambdabot> http://www.haskell.org/haskellwiki/Generalised_algebraic_datatype
05:07:41 <ski> koniiiik : see those two links. e.g. see the empty/nonempty list example in the latter
05:12:04 <koniiiik> ski: Thanks for the links, although I'm afraid I don't have the time to go through all that right now, I think I'll go with smart constructors on this one. Seems much simpler for this task.
05:12:17 <koniiiik> I'll definitely keep that in my to-read list, though.
05:16:09 <ski> koniiiik : that's fine
05:17:19 <ski> (so, you're then really implementing a subtype by (presumably) an abstract data type boundary (iow not exporting the constructors `Pred' and `Succ' themselves))
05:21:17 <nerium> I’m trying to define the natrual numbers using data type, but I can’t get it to comple
05:21:18 <nerium> https://gist.github.com/oleander/0ab02eb7f9be8918265f
05:21:24 <nerium> What I’m I doing wrong?+
05:22:33 <ski> nerium : try `data N = Zero | Succ N' ?
05:23:27 <nerium> ski: That seams to work. Why didn’t mine?
05:23:28 <ski> (Haskell has no subtypes, so you can't make existing values `0' and `n - 1' of some type to be values of your new type)
05:23:51 <nerium> ski: Aha, okay
05:23:58 <nerium> ski: How would you do it for Z?
05:24:36 <ski> hehe, koniiiik just asked about that, a short while ago
05:24:58 <nerium> ski: lol, I can only imagain why :)
05:25:16 <nerium> *imagine
05:25:49 <nerium> ski: I can show you how I would do it on paper
05:26:00 <ski> go on
05:26:33 <nerium> hold on
05:27:21 <osa1> do we have this defined is some widely used lib: \a b -> fmap a . b ?
05:27:48 <Cale> osa1: no
05:28:01 <nerium> ski: https://gist.github.com/oleander/38ab53ba148d528a44a9
05:28:31 <nerium> ski: I’ve updated the gist, I missed a thing on line 3
05:28:31 <fommil> hi all. Is it possible to install a cabal package, building from its master branch on github? (without having to clone, etc)
05:30:17 <Cale> fommil: You can just run "cabal install" from a source directory containing a .cabal file
05:30:34 <nerium> ski: Did you read it ? :)
05:30:38 <ski> @type \a b -> fmap a . b
05:30:39 <lambdabot> Functor f => (a1 -> b) -> (a -> f a1) -> a -> f b
05:30:42 <ski> nerium : not yet
05:30:56 <damncabbage> So I'm trying to compile music-suite again. (Inside a cabal sandbox.)
05:31:02 <damncabbage> I eventually get to the end only to be faced with "Using 'build-type: Custom' but there is no Setup.hs or Setup.lhs" from the music-suite metapackage Configuring... step. (Which is confusing as hell because it /has/ a Setup.lhs)
05:31:08 <damncabbage> https://gist.github.com/damncabbage/f026739d795621049295 <--- log
05:31:18 * hackagebot puzzle-draw 0.1.0.4 - Creating graphics for pencil puzzles.  http://hackage.haskell.org/package/puzzle-draw-0.1.0.4 (vollmert)
05:31:19 <Gurkenglas> Should I use Data.Function.Memoize or Data.MemoTrie
05:31:20 <Gurkenglas> ?
05:31:46 <ski> nerium : well, you can't mention (ordinary value) variables in type definitions like that
05:32:22 <ski> nerium : also, if you type `data N n = ...' you're defining a type `N n', not a type `N', where `n' is to be a typical element of that type
05:32:23 <nerium> ski: Okay, any hint on how it can be done? I can’t come up with anyting else :(
05:32:35 <fommil> Cale: yeah, but that means going through the git clone dance. I was hoping to shortcut that. OK, well thanks anyway.
05:32:40 <ski> nerium : it still seems you're thinking in terms of subtypes
05:33:45 <Cale> fommil: If you don't have git, you can download a zip of the repo from its page on github
05:33:53 <ski> nerium : also, which number would `N Zero' represent ? (also, it might be better here, at least while discussing the code, to name the type constructor `N' and the data constructor `N' differently, to avoid possible confusion between them)
05:33:57 <nerium> ski: Yeah, that might be it. How would you define it? It would be nice to get some hints b/c I
05:34:04 <nerium> I’m stuck
05:34:25 <ski> nerium : the simplest idea is simply to have one `Succ' and one `Pred' constructor
05:34:33 <fommil> Cale: that's not the problem, I just want to be lazy ;-)
05:34:36 <Gurkenglas> When memoizing a function with either, I apparently need 3 names for the untried and tried version and the implementation. What are the naming conventions?
05:34:39 <nerium> ski: So what would you match on?
05:35:04 <ski> nerium : match on, how do you mean ? match on, where ? in which definition ?
05:35:28 <saep> fommil: You can download a zip.
05:35:37 <saep> Oh, nevermind.
05:35:56 * saep should read the backlog before pressing enter.
05:36:10 <fommil> heh
05:36:17 <nerium> ski: I see it as a linked list. We start at some value ”n” and increment it or decrement it until we hit zero, if we don’t then ”n” isn’t in Z (for example)
05:37:59 <ski> nerium : by your "linked list" analogy, are you thinking of single-linked or doubly-linked lists ?
05:38:35 <chrisdone> Fuuzetsu: what do you think about adding syntax highlighting to haddock?
05:39:48 <nerium> ski: Single. We should only be able to walk ”one way”. 5 -> 4 -> 3 -> 2 -> 1 -> 0, -3 -> -2 -> -1 -> 0
05:45:09 <nerium> ski: Any how, you mean that this would work? data N = Zero | Succ N | Pred N deriving(Show)
05:46:18 <koniiiik> nerium: Yes, that's valid.
05:46:58 <ski> nerium : well, it would allow you to write stuff like `Succ (Pred Zero)', in addition to `Succ (Succ Zero)'
05:47:15 <ski> nerium : so, you might want to define "smart constructors" for `Succ' and `Pred'
05:47:24 <ski>   succ :: N -> N
05:47:30 <ski>   succ (Pred n) = n
05:47:38 <ski>   succ       n  = Succ n
05:48:06 <ski> and similarly for `Pred', so then `succ (pred Zero)' will compute to `Zero', but `succ (succ Zero)' will be `Succ (Succ Zero)'
05:48:34 <ski> (and then you might consider not exporting at least `Succ' and `Pred')
05:49:48 <nerium> ski: Okay. How would you force N to be part of Num? I tried using deriving(Num), but that didn’t work
05:50:32 <Gurkenglas> Oh, Data.Function.Memoize has no tried step, so I only need 2 names there, so I'm gonna use that.
05:54:13 <zipper> ski: Hi
05:54:45 <ski> zipper : Lo
05:54:57 <ski> nerium : make an explicit `instance' declaration for it
05:55:06 <ski>   instance Num N
05:55:07 <nerium> Num =>, like that?
05:55:08 <ski>     where
05:55:28 <ski>     Zero   + n = n
05:55:39 <ski>     Pred m + n = Pred (m + n)
05:55:48 <ski>     Succ m + n = Succ (m + n)
05:55:51 <ski>     ...
05:55:55 <ski> or something like that
05:56:17 <ski> .. on second thought, you may want `(+)' to cancel `Pred's and `Succ's with each other
05:57:14 <nerium> ski: The problem right now is that I can’t preform + operations on N, it just complains that isn’t not part of Num
05:57:55 <nerium> I was hopinh to fix this by running
05:57:56 <nerium> func :: Num => N -> N -> N
05:57:57 <nerium> but that didin’t work
05:58:30 <ski> nerium : so define `(+)' for it
05:58:35 <nerium> ski: aha
05:58:43 <ski> as i sketched above
05:59:00 <ski> also, you want to define `(*)' and `fromInteger'
05:59:29 <ski> oh, and `(-)' and `negate', of course
05:59:47 <ski> and while you're at it, you can just as well define `abs' and `signum'
06:00:05 <ski> nerium : though i think you only need to define one of `negate' and `(-)'
06:00:28 <ski> (the other being defined by the default implementation)
06:01:20 <ski> nerium : defining `fromInteger' will allow you to write `0',`1',`2',... and so on for values of type `N', instead of having to type `Zero',`Succ Zero' (or `succ Zero'),&c.
06:01:38 <ski> and i think you need `negate' to be able to type `-n' and `-2',&c.
06:02:00 <ski> (but, as said, defining `(-)' should define `negate' automatically as well)
06:03:21 <nerium> ski: Shouldt this work?
06:03:22 <nerium> instance Num N where
06:03:22 <nerium>   N a + N b = N (a + b)
06:05:35 <ski> nerium : no. `N' is a type constructor, not a data constructor
06:05:48 <ski> it belongs on the type level, not on the value/data level
06:05:57 <ski> `N a' is nonsense
06:06:21 <nerium> darn
06:06:37 <ski> you have to use the data constructors of `N', which by the definition `data N = Zero | Succ N | Pred N deriving Show' is `Zero',`Succ',`Pred'
06:07:09 <ski> so, adding zero to anything doesn't change it
06:07:28 <ski> adding a `Succ m' and a `Pred n', you can cancel and continue adding
06:07:43 <ski> otherwise accumulate the `Succ's or the `Pred's
06:07:46 <ski> nerium : ok ?
06:08:21 <ski> (if you don't care about having your integers in canonical form, it suffices with the simpler definition of `(+)' i suggested above)
06:09:03 <nerium> ski: I tried what to wrote above, but I’m getting ”Not in scope: data constructor ‘Pred’"
06:09:17 <nerium> ski: N is defined as data N = Zero | Succ N deriving(Show, Eq)
06:09:49 <dramforever> huh? then where's that "| Pred N" coming from
06:10:44 <ski> <nerium> ski: Any how, you mean that this would work? data N = Zero | Succ N | Pred N deriving(Show)
06:10:45 <nerium> dramforever: I don’t have that
06:10:52 <dramforever> hmm..
06:10:57 <ski> nerium : i was assuming you worked with that ^ definition of `N'
06:11:19 * hackagebot liblastfm 0.5.0 - Lastfm API interface  http://hackage.haskell.org/package/liblastfm-0.5.0 (MatveyAksenov)
06:11:28 <dramforever> forget about Succ, then
06:11:57 <nerium> ski: I’m working with this one: http://i.imgur.com/ajnohl4.png
06:12:18 <nerium> I trought that Pred wasn’t int it
06:12:48 <ski> nerium : that's natural numbers. i thought you were trying to code up integers (including negative ones)
06:13:08 <nerium> ski: N as in natrual number :)
06:13:18 <nerium> *natrual number
06:13:25 <nerium> Let’s start with that one
06:13:47 <dramforever> then do it like this:
06:13:59 <dramforever> Zero + n = undefined -- blah
06:14:05 <dramforever> Succ n + m = undefined -- blah
06:14:34 <dramforever> well, replace "undefined -- blah" with real code
06:14:58 <blume> hi, im building a rose tree by shifting elements of my data structure back and forth. the problem is that i get duplicates, so the whole process is repeated inside of the tree. now how do i remove those? i'd have to access all previous elements and see whether the new element is already there. i have no idea how to access the whole tree while building it recursively
06:15:31 <dramforever> blume: let tree = {- you can actually use tree here -}
06:15:31 <nerium> dramforever: Succ m + n would be m + n + 1?
06:15:40 <dramforever> hmmm
06:15:49 <dramforever> Why not Succ (m + n)
06:16:09 <nerium> What’s the difference ?
06:16:19 <nerium> Succ (m + n) == Succ m + n
06:16:33 <benzrf> blume: can u be more detailed, please?
06:16:45 <blume> alright, i'll try
06:17:04 <ski> nerium : "N as in natural number :)" -- well, in <https://gist.github.com/oleander/38ab53ba148d528a44a9>, you used `N', for what you intended to be the integers, no ?
06:17:12 <dramforever> hmm...forget about it
06:17:15 <dramforever> nerium: ^
06:17:36 <nerium> ski: That was suppose to be Z, but now I’m trying to just to N
06:18:11 <ski> ok
06:19:12 <dramforever> blume: how was it going? and can you be more detailed? we can help more in that way
06:19:12 <nerium> ski: I dont’ really get what I’m trying to define for N using ”instance Num N where”
06:19:13 <nerium> What does  Succ m + n =  Succ (m + n) mean for example?
06:19:50 <benzrf> https://gist.github.com/oleander/38ab53ba148d528a44a9 this code is pretty confused o_O
06:20:03 <dramforever> nerium: 1. we are defining (+)
06:20:21 <nerium> dramforever: Yes, that I understand, but what does that exact line do?
06:20:34 <nerium> For me thoes line are equal
06:20:38 <blume> i'm trying to find a way of filling liquid in bottles so that in the end, a special configuration occurs. so the first step fills liquid of bottle A into bottles B,C,D and B into A,C,D and so on. but the second step will fill bottle B back into bottle A, so it's the original configuration again. in the end, i want to do a breadth-first search on the whole tree
06:20:42 <nerium> You have just removed the ()
06:20:47 <dramforever> nerium: ?
06:20:55 <dramforever> oh
06:21:02 <dramforever> Succ m + n is (Succ m) + n
06:21:18 <nerium> aha, that makes a bit more sense
06:21:28 <dramforever> function application by putting spaces in between has the highest precedence
06:21:58 <dramforever> In fact, I learned ruby before haskell, and was very confused about that too
06:22:08 <dramforever> in fact, more confused
06:22:27 <dramforever> a b c d in ruby means a(b(c(d)))
06:22:28 <nerium> I’m a ruby dev my self and havent used haskell in maybe 6 years
06:22:40 <nerium> okay, makes sense
06:23:26 <benzrf> nerium: do you know pattern matching :|
06:23:47 <benzrf> blume: i think i follow
06:24:39 <benzrf> blume: would you rather eliminate duplicates while building the tree or while scanning it
06:25:22 <blume> benzrf: the tree is infinite, so rather while building it i guess
06:25:33 <benzrf> blume: how are you generating it
06:25:50 <blume> with unfoldTree from Data.Tree
06:25:55 <benzrf> hm
06:25:56 <ski> nerium : `Succ m + n = Succ (m + n)' means `(Succ m) + n = Succ (m + n)' means `(+) (Succ m) n = Succ ((+) m n)' -- defining `(+)' recursively
06:26:03 <benzrf> :t unfoldTree
06:26:04 <lambdabot> (b -> (a, [b])) -> b -> Tree a
06:26:18 <dramforever> @info Tree
06:26:18 <lambdabot> Tree
06:26:20 * hackagebot continuum 0.1.0.0 -   http://hackage.haskell.org/package/continuum-0.1.0.0 (ifesdjeen)
06:26:22 <nerium> ski: Now I’m getting ”No instance nor default method for class operation GHC.Num.fromInteger"
06:26:37 <ski> nerium : defining it by cases. this case says how to compute the sum in case the addend is of the shape `Succ m'
06:26:48 <dramforever> nerium: that means you didn't define fromInteger
06:26:52 <blume> its Tree a = (Noda a) [Tree a]
06:27:09 <dramforever> hmm...does @info even gives *any* information?
06:27:15 <benzrf> @info corrects to @undo
06:27:15 <lambdabot> <unknown>.hs: 1: 18:Parse error in expression: to@undo
06:27:18 <dramforever> gives -> give
06:27:23 <benzrf> @info do x <- y; z
06:27:23 <lambdabot> y >>= \ x -> z
06:27:30 <benzrf> @undo do x <- y; z
06:27:30 <lambdabot> y >>= \ x -> z
06:27:31 <blume> or something like that. theres a root element and a list of subtrees
06:27:32 <dramforever> hmm.
06:27:41 <dramforever> okay, makes sense
06:28:13 <benzrf> alright i see the unfold
06:28:25 <ski> dramforever : there is no `@info'
06:28:38 <ski> @help info
06:28:38 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:28:40 <ski> @help undo
06:28:40 <lambdabot> undo <expr>
06:28:40 <lambdabot> Translate do notation to Monad operators.
06:28:45 <benzrf> blume: what you *could* do is just recurse primitively and carry along a Set of what states you've been in along this particular brancj
06:28:48 <benzrf> *branch
06:28:57 <ski> > undo [ 3 | False ]
06:28:58 <lambdabot>  Not in scope: ‘undo’
06:28:58 <lambdabot>  Perhaps you meant ‘unto’ (imported from Control.Lens)
06:29:01 <dramforever> > iterate (concatMap (\x -> [x^5, x^9])) 1
06:29:03 <lambdabot>  No instance for (GHC.Show.Show a0)
06:29:03 <lambdabot>    arising from a use of ‘M895653109710718211430325.show_M8956531097107182114...
06:29:03 <lambdabot>  The type variable ‘a0’ is ambiguous
06:29:03 <lambdabot>  Note: there are several potential instances:
06:29:03 <lambdabot>    instance [safe] GHC.Show.Show
06:29:04 <ski> @undo [ 3 | False ]  -- er
06:29:05 <lambdabot> if False then [3] else []
06:29:09 <dramforever> > iterate (concatMap (\x -> [x^5, x^9])) (1 :: Int)
06:29:11 <lambdabot>  Couldn't match expected type ‘[a]’ with actual type ‘GHC.Types.Int’
06:29:17 <benzrf> blume: then at each step, stop if/when your state has a duplicate
06:29:30 <dramforever> > iterate (concatMap (\x -> [x^5, x^9])) ([1] :: [Int])
06:29:32 <lambdabot>  [[1],[1,1],[1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,...
06:29:47 <dramforever> > concat $ iterate (concatMap (\x -> [x^5, x^9])) ([2] :: [Int])
06:29:49 <lambdabot>  [2,32,512,33554432,35184372088832,35184372088832,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
06:29:55 <dramforever> > concat $ iterate (concatMap (\x -> [x^5, x^9])) ([2] :: [Integer])
06:29:57 <lambdabot>  [2,32,512,33554432,35184372088832,35184372088832,2417851639229258349412352,4...
06:30:03 <blume> benzrf: oh, of course. thanks.
06:30:07 <dramforever> blume: ^
06:30:09 <benzrf> > [1]^5
06:30:10 <lambdabot>  No instance for (GHC.Show.Show t0)
06:30:11 <lambdabot>    arising from a use of ‘M11289502260679040630445.show_M11289502260679040630...
06:30:11 <lambdabot>  The type variable ‘t0’ is ambiguous
06:30:11 <lambdabot>  Note: there are several potential instances:
06:30:11 <lambdabot>    instance [safe] GHC.Show.Show
06:30:14 <benzrf> wat
06:30:27 <benzrf> oh i see
06:30:44 <nerium> ski: Like this? https://gist.github.com/oleander/c5b8ada208129b41e622
06:30:52 <benzrf> blume: there may be a more elegant solution, but idk what
06:31:40 <benzrf> blume: if you use a StateT (Set Int) [] a, you could 1. not need to manually pass along the set, and 2. get back a flat list of end states
06:31:48 <benzrf> no, wait... nvm
06:31:51 <blume> dramforever: sorry, i don't really see what you're doing
06:32:15 <dramforever> well, forget about it
06:32:55 <ski> nerium : no, define `fromInteger' inside your `instance Num N' (or `Z') declaration, just like for `(+)'
06:33:27 <ski> nerium : and you'll need to correct the definition. you're given an `Integer' and should compute the corresponding value in `N' (or `Z')
06:33:55 <blume> ultimately, i want to search the tree for some element and return the steps that led to it. unfoldTreeM_BF looks perfect for that, if i'm not mistaken. but i cant even get it to work with the Identity monad
06:34:04 <blume> > liftM levels $ unfoldTreeM_BF (\n -> Identity (n, [n-1, n+1])) 0
06:34:05 <lambdabot>  Ambiguous occurrence ‘levels’
06:34:06 <lambdabot>  It could refer to either ‘Control.Lens.Level.levels’,
06:34:06 <lambdabot>                           imported from ‘Control.Lens’ at L.hs:47:1-43
06:34:06 <lambdabot>                           (and originally defined in ‘lens-4.1.2:Control.Lens...
06:34:06 <lambdabot>                        or ‘Data.Tree.levels’,
06:34:17 <blume> > liftM Data.Tree.levels $ unfoldTreeM_BF (\n -> Identity (n, [n-1, n+1])) 0
06:34:23 <lambdabot>  mueval-core: Time limit exceeded
06:34:23 <lambdabot>  mueval: ExitFailure 1
06:34:45 <osa1_> does forcing(using deepseq) a strict ByteString make sense?
06:35:05 <benmachine> osa1_: deepxeq for strict bytstring is probably just seq
06:35:08 <benmachine> er, deepseq
06:35:14 <nerium> ski: https://gist.github.com/oleander/802dbec1131fe47ee3f1 Like that?
06:35:16 <dramforever> osa1_: yes, but the same as seq
06:35:30 <dramforever> @src Data.ByteString.ByteString
06:35:31 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
06:35:36 <dramforever> @src Data.ByteString.Internal.ByteString
06:35:36 <lambdabot> Source not found. stty: unknown mode: doofus
06:35:44 <dramforever> uh oh
06:35:48 <dramforever> @src Data.ByteString.Internal.PS
06:35:48 <lambdabot> Source not found. :(
06:36:01 <osa1_> dramforever: got it, thanks
06:36:03 <benmachine> dramforever: @src is full of lies and omissions
06:36:10 <dramforever> yep
06:37:14 <ski> nerium : `(Succ m) + n = Succ (m + n)' can be simplified to `Succ m + n = Succ (m + n)' -- if you really like the former better, who'm i to object ?
06:37:37 <ski> nerium : `(Succ n) = (Succ n) + 1' doesn't make sense. what did you intend to express by it
06:38:06 <nerium> ski: That it would decrement until zero and add 1 for each step
06:39:15 <ski> nerium : is it supposed to be for `(+)' or for `fromInteger' (or for something else) ?
06:39:32 <ski> nerium : if for `fromInteger', then you need to say so (in the code)
06:40:25 <nerium> ski: I’ll start with fromInteger, i missread what you wrote
06:40:56 <nerium> ski: What should I write?
06:40:56 <nerium> Succ a = a ?
06:41:09 <titusg> how do I do something like mapM_ over the contents of a Map?
06:41:21 * hackagebot continuum 0.1.0.1 -   http://hackage.haskell.org/package/continuum-0.1.0.1 (ifesdjeen)
06:41:34 <ski> nerium : you need something like `fromInteger ... = ...'
06:42:25 <titusg> using mapWithKey I end up with the actions in a Map a (IO ())
06:42:39 <titusg> but I wanto to perform them
06:43:03 <dramforever> titusg: Data.Foldable, maybe
06:43:05 <ski> do you need the keys as well ?
06:43:09 <titusg> yep
06:43:15 <ski> `Data.Foldable.mapM_' only gets you the values
06:43:33 <dramforever> ski: I think mapWithKey passes keys to functions
06:43:45 <ski> @type M.mapWithKey
06:43:46 <lambdabot> (k -> a -> b) -> M.Map k a -> M.Map k b
06:43:49 <dramforever> so the IO () 's contain keys
06:43:51 <nerium> ski: fromInteger a = a ?
06:43:59 <dramforever> gosh...
06:44:16 <ski> nerium : the left `a' would have type `Integer', but the right would be expected to have type `N', so that doesn't work
06:44:31 <dramforever> nerium: how do you do integer -> nat, by hand?
06:44:49 <nerium> dramforever: What’s nat?
06:44:54 <dramforever> nerium: N
06:44:58 <ski> titusg : you could `(forM_ . assocs) m $ \(k,v) -> ...'
06:45:02 <dramforever> nat is short for natural
06:45:20 <nerium> dramforever: I’m not sure how that would look
06:45:28 <ski> nerium : anyway, you're on the right track
06:45:32 <dramforever> nerium: how would you do it
06:45:44 <nerium> dramforever: fromInteger a = N a
06:45:49 <nerium> maybe like that?
06:45:56 <titusg> ski thx I'll have a go
06:46:18 <dramforever> hmm... I mean 5 -> Succ (Succ (Succ (Succ (Succ Zero))))
06:47:49 <ski> nerium : unfortunately, again `N' belongs on the type level, not on the value level. `N a' is nonsense :/
06:48:03 <nerium> ski: darn, i dont get this
06:48:07 <ski> nerium : what do you expect `fromInteger 0' to return ?
06:48:17 <ski> nerium : what do you expect `fromInteger 1' to return ?
06:48:22 <ski> nerium : what do you expect `fromInteger (-1)' to return ?
06:48:38 <nerium> ski: fromInteger 0 = Zero
06:48:42 <ski> all should return elements of the type `N' (or `Z', if you've renamed it)
06:48:47 <ski> but which elements ?
06:48:53 <nerium> fromInteger 1 = Succ ( Zero )
06:48:55 <ski> that's right
06:49:02 <ski> (and you can type that simply as `Succ Zero')
06:49:12 <nerium> Yeah, that’s right
06:49:21 <ski> now, obviously you can't enumerate every integer in the definition
06:49:30 <ski> so, you'll need to find another way to get all of them
06:49:34 <ski> .. perhaps by recursion
06:51:21 * hackagebot continuum 0.1.0.2 -   http://hackage.haskell.org/package/continuum-0.1.0.2 (ifesdjeen)
06:51:23 * hackagebot continuum 0.1.0.3 -   http://hackage.haskell.org/package/continuum-0.1.0.3 (ifesdjeen)
06:51:45 <dramforever> huh? two releases within one minute
06:52:16 <ski> mistake or just trigger happy ?
06:52:32 <nerium> ski: Like this? https://gist.github.com/oleander/7030722c7e8228dc0d18
06:52:59 <ski> the type of `ll' is wrong
06:53:08 <ski> it should be `Integer -> N'
06:53:37 <ski> (it should mention `N', otherwise you can't use `Zero' and `Succ' in its definition)
06:54:40 <nerium> ski: Hehe, that compiled but filled the whole screen with (Succ (Succ (Succ (Succ (Succ (Succ (Succ :)
06:54:47 <nerium> when trying to use it
06:54:56 <ski> (i suppose the type could also be `(Num a,Eq a) => a -> N', if you want to go for more generality, for some reason)
06:55:26 <dramforever> nerium: it seems that you stuck into a infinite loop Succ'ing
06:55:36 <ski> nerium : and you can't use `Zero' in the pattern since the input is an `Integer', not an `N'
06:56:12 <nerium> ski: this worked https://gist.github.com/oleander/ae1a03be77afe1e1ec4f
06:56:18 <ski> nerium : also, while you *can* move the definition out to a separate function `ll' like this, you could just as well define it directly for `fromInteger', by cases
06:56:45 <ski> nerium : *nod*
06:57:07 <ski> so, if you want to, you can now rename `ll' to `fromInteger' and move it into the `instance' declaration
06:57:22 <nerium> ski: Is there a way to make it printable? Currently 1 + 1 = Succ (Succ Zero)
06:57:33 <ski> (unfortunately one can't write type signatures in instance declarations (i've no idea why), so you'll have to remove it, or comment it out :/)
06:57:57 <ski> nerium : define `instance Show N' yourself, instead of `deriving Show'
06:59:58 <nerium> ski: I think I’ll stick with the already implemented version
07:00:23 <ski> fine
07:00:44 <nerium> ski: Do I’ve to define (-) as well in instance Num N where ?
07:00:49 <ski> yes
07:00:56 <ski> and `(*)', in case you want it
07:01:15 <nerium> I need -, but not * atm
07:01:32 <ski> (and you might as well define `abs' and `signum' while you're having a go)
07:01:39 <dramforever> huh? foo (f -> a) = a where f x = {- blah -} doesn't work
07:01:55 <dramforever> well, specifically, f is not in scope
07:02:00 <dramforever> I wonder why is that
07:02:11 <nerium> ski: Right not it never temrinates when using (-), I guess that’ b/c (-) isn’t implemented
07:02:13 <ski> @type let foo (f -> a) = a where f = not in foo
07:02:14 <lambdabot> (FromExpr t1, Show t) => t -> t1
07:02:39 <dramforever> ski: this:
07:02:39 <ski> dramforever : .. strange
07:02:41 <dramforever> @type f
07:02:42 <lambdabot> FromExpr a => a
07:02:45 <ski> (i know)
07:03:50 <ski> nerium : yes. `(-)' and `negate' have default definitions in terms of each other, so that if you define one, the other will automatically be defined. but if you define none of them, they loop around
07:04:14 <ski> @type let foo (f -> a) = a; f = not in foo
07:04:16 <lambdabot> Bool -> Bool
07:04:39 <ski> oh, dramforever disappeared
07:05:06 <nerium> ski: I tried doing this https://gist.github.com/oleander/fe6860acb1df84856454 How do I handle the case when it’s below zero. It should be defined for thoes values
07:06:31 <ski> nerium : defined to be what ?
07:06:49 <ski> (also, remind me, are you currently talking about naturals or integers ?)
07:06:49 <nerium> ski: In the case of N, no negative values are defined
07:07:06 <nerium> ski: ^
07:07:13 <ski> so either `2 - 5' will be undefined, or it will be defined to be something
07:07:15 <ski> perhaps `0'
07:08:33 <ski> that is called "truncating/saturating subtraction", or "monus". sometimes written with a ⌜∸⌝ sign instead of the usual ⌜-⌝ sign
07:08:50 <nerium> ski: The porblem is that  1 - 1 returns undefined using the above def
07:09:13 <ski> because you said
07:09:14 <ski>   Zero - n = undefined
07:09:21 <ski> try instead first with
07:09:24 <ski>   m - Zero = m
07:10:05 <ski> also, the `Succ' case should really cancel `Succ's, no ?
07:10:41 <ski> otherwise, how's `Succ (Succ (Succ Zero)) - Succ Zero' going to compute `Succ (Succ Zero)' ?
07:11:22 * hackagebot continuum 0.1.0.4 -   http://hackage.haskell.org/package/continuum-0.1.0.4 (ifesdjeen)
07:14:29 <nerium> ski: I’m not following :(
07:15:41 <ski>      1 - 1
07:15:51 <ski>   =  fromInteger 1 - fromInteger 1
07:16:00 <ski>   =  ll 1 - ll 1
07:16:26 <ski>   =  Succ (ll (1 - 1)) - Succ (ll (1 - 1))  -- since `1' isn't `0'
07:16:38 <ski>   =  Succ (ll 0) - Succ (ll 0)
07:16:48 <ski>   =  Succ Zero - Succ Zero
07:17:07 <ChristianS> ski: urg, what are you doing?
07:17:16 <ski>   =  Succ (Zero - Succ Zero)  -- because of the equation `Succ m - n = Succ (m - n)'
07:17:33 <ski>   =  Succ undefined  -- because of the equation `Zero - n = undefined'
07:17:48 <ski> nerium : that's a rough trace of how `1 - 1' evaluaes
07:18:14 <ski> ChristianS : explaining what went wrong with nerium's current definition of `(-)'
07:19:07 <ski> nerium : you must admit that `Zero - n = undefined' is wrong, in case `n' turns out to be `Zero', right ?
07:19:37 <ski> nerium : so, you must then make sure that `Zero - Zero' doesn't use this equation to compute
07:19:37 <nerium> ski: Yeah, I tried adding Zero - Zero = Zero, but no luck
07:20:09 <ski> yeah, because `Zero - Zero' doesn't match the problematic case `Zero - Succ Zero' above
07:20:35 <Enzoray> Hey, could someone help me out with my list problem?
07:20:47 <joe9> http://codepad.org/Jsc1NVol I am trying to figure out if my functor definition is similar to what deriving Functor builds. How do I check what deriving Functor builds?
07:20:50 <ski> the point about `Zero - n = undefined' i made here isn't directly related to the above erring example (though fixing it will help)
07:20:56 <nerium> ski: But Zero - Succ Zero should be undefined, or I’m I wrong?
07:21:07 <ski> nerium : i'm just saying that you need to fix `Zero - Zero' somehow, as well
07:21:14 <ski> do you agree ?
07:21:27 <nerium> ski: Using ”Zero - Zero = Zero” ?
07:22:35 <nerium> koniiiik: Is this how you did it?
07:23:09 <nerium> koniiiik: are we really suppse to define Num for N and Z?
07:26:22 * hackagebot continuum 0.1.0.5 -   http://hackage.haskell.org/package/continuum-0.1.0.5 (ifesdjeen)
07:28:35 <nerium> ski: Shouldnt this work then ? https://gist.github.com/oleander/6f238a810983ed1edd62
07:30:03 <ski> joe9 : hm, does `-ddump-simpl -dsuppress-module-prefixes -dsuppress-uniques' help ?
07:30:49 <ski> joe9 : anyway, it should generate the same as your `fmapThreadF'
07:31:12 <ski> nerium : do you agree that `Zero - Zero' shouldn't be undefined ?
07:31:21 <nerium> ski: Yes
07:31:22 * hackagebot continuum 0.1.0.6 -   http://hackage.haskell.org/package/continuum-0.1.0.6 (ifesdjeen)
07:31:25 <ski> nerium : do you agree that `m - Zero' should evaluate to the same as `m' ?
07:31:32 <nerium> ski: Yes
07:32:08 <ski> nerium : then your `n - Zero' case seems buggy, in your last paste
07:32:42 <nerium> ski: What else should I write? Removing it wont work
07:32:56 <augur> is there a conventional FP version of notifications/callbacks?
07:33:32 <nerium> ski: If Zero  -n must be undefined as n can’t be zero
07:33:37 <augur> like, if you have a sub-component of your program that wants to say to a super-component "please do XYZ when certain conditions are met"
07:34:55 <augur> i guess one solution would be to have functions that return some appropriately wrapped actions-as-functions?
07:35:42 <augur> which then go into some task set, i guess?
07:37:44 <ski> nerium : i'm saying that if you want `m - Zero' to evaluate to `m', then your `n - Zero = Succ n' seems incorrect
07:38:53 <ski> (nerium : also, i didn't understand your "If Zero  -n must be undefined as n can’t be zero" comment .. why can't `n' be `Zero' here ?)
07:39:15 <nerium> ski: b/c it matched highter up the chain?
07:39:27 <nerium> Zero - Zero is matched before Zero - n
07:40:07 <nerium> Don’t I want m - Zero to be evaluated to Succ m ?
07:43:57 <nerium> ski: Or I’m I wrong?
07:44:44 <kadoban> nerium: I don't understand why 'm - Zero' shouldn't be m ?
07:45:08 <nerium> kadoban: - 0 = m ?
07:45:08 <exio4> x-0 = ??
07:45:16 <nerium> m - 0 = m
07:47:35 <kadoban> Isn't that how (-) works?
07:47:46 <augur> :t (-)
07:47:47 <lambdabot> Num a => a -> a -> a
07:47:56 <kadoban> 5 - 0 is 5, not (Succ 5 === 6)
07:47:59 <Zekka> nerium: Are you sure you want it to evaluate as Succ m?
07:48:13 <Zekka> Kadoban's argument seems to be a pretty good reason for it not to do that
07:48:38 <nerium> Hmm, that’s true
07:48:51 <exio4> replace Succ with (1+) and Zero with 0, and try to do the math in paper
07:48:57 <Zekka> I think it ought to evaluate to m.
07:49:55 <ski> nerium : do you want `2 - 0' to evaluate to `3' ?
07:50:09 <nerium> ski: No, that a valid point
07:50:25 <Zekka> In general, doesn't a thing minus zero evaluate to that thing and not that thing plus one?
07:50:38 <Zekka> given that zero and negative one are slightly different things?
07:51:17 <ski> nerium : as for `Zero - n = undefined', it's fine if you catch the `Zero - Zero' case before. alternatively you could say `Zero - Succ n = undefined', and then the order doesn't matter anymore
07:51:42 <ski> nerium : .. or you could just remove this equation completely
07:52:09 <ski> nerium : now, `(Succ m) - n = Succ (m - n)' still need to be fixed
07:52:56 <ski> nerium : you're saying that e.g. `Succ Zero - Succ Zero' must start with a `Succ' -- probably you don't want to do this
07:55:17 <nerium> ski: I’ve no idea how do define it :/
07:56:35 <ski> nerium : do you agree that in case both `m' and `n' contain a `Succ', then you want to cancel them against each other ?
07:57:04 <ski> so that `Succ (Succ (Succ Zero)) - Succ (Succ Zero)' (eventually) evaluates to `Succ Zero'
07:57:57 <ski> so, if you could cancel the first `Succ' on the left with the first `Succ' on the right, and then the next two `Succ's, &c., until you don't have any matching ones anymore, you'd be more or less done, i think
07:58:07 <ski> nerium : do you understand what i mean ?
07:58:16 <nerium> *reading*
07:58:28 <Zekka> You'll slap yourself when you see it
07:58:44 <Zekka> if it helps to mention that
08:01:03 <joe9> ski, thanks.
08:01:03 <nerium> ski: Yes, the first two sentenses I understood
08:02:22 <nerium> ski: Like this? (Succ m) - (Succ n) = Succ (m - n)
08:03:46 <nerium> ski: now it compiled and ran, but 2 - 1 became Succ (Succ Zero)
08:03:51 <nerium> Which is 2
08:03:56 <ski> nerium : no, since that means `Succ Zero - Succ Zero = Succ (Zero - Zero)', which, regardless of how `Zero - Zero' evaluates, will always start with a `Succ'
08:04:11 <ski> nerium : the problem is the `Succ' on the right hand side of your defining equation
08:04:33 <Zekka> nerium: It's pretty close! But there's something you haven't accounted for
08:04:39 <Zekka> although it sounds like Ski's just going to tell you
08:05:12 * ski is trying hard not to
08:05:52 <Zekka> Definitely  consider the (Succ Zero) - (Succ Zero) case
08:07:13 <ski> nerium : you're getting closer, anyway
08:07:24 <nerium> ski: I understand the problem but I can’t seam to fix it
08:07:37 <Zekka> nerium: What's the problem, in general?
08:07:49 <Zekka> For x, y greater than zero, how's the answer wrong?
08:08:21 <nerium> Zekka: What do you mean?
08:08:31 <dean_> help
08:08:34 <Zekka> nerium: Can you say what the problem is?
08:09:08 <joe9> augur: free monad?
08:09:08 <nerium> Zekka: Not in writning
08:09:46 <kadoban> nerium: Maybe start with an Integer -> YourType converter, some printing things, and just play with it? Start with one operation at a time, and try to nail down the corner cases.
08:10:25 <nerium> kadoban: I can see whats wrong with it and why it doesn’t work, but I can’t figure out how to fit it
08:10:28 <augur> joe9: theres something monadic going on, definitely, but its not quite the free monad as such
08:10:43 <kadoban> nerium: Ah okay
08:12:01 <augur> i mean, i can think of an implementation, right -- data Task = Task { shouldRun :: S -> Bool, runTask :: S -> [Task] }
08:12:15 <augur> but I dont know that this is an established idiom with lots of discussion
08:15:08 <nerium> ski: Any more hints?
08:20:27 <nerium> ski: What I dont understand is this. If we’ve 2 - 1, which is Succ(1) - Succ(0), which means that that in case of Succ(n) - Succ(m), Succ(n - m) should work
08:21:03 <nerium> Hmm, Succ(0) should work
08:21:12 <haasn> You can't generalize from a specific case to a general case
08:21:18 <haasn> Via example
08:21:24 * hackagebot continuum 0.1.0.7 -   http://hackage.haskell.org/package/continuum-0.1.0.7 (ifesdjeen)
08:21:53 <haasn> But generally, if you have (1+n) - (1+m) that's the same as 1+n-1-m = n-m
08:21:53 <nerium> Which is Succ(n - m - 1)
08:22:04 <nerium> haasn: Any other idea how to do it?
08:22:20 <haasn> So clearly we can see that Succ n - Succ m = n - m
08:22:37 <vanila> nerium, do what?
08:23:47 <meretrix> As my application grows, I find that I am passing a single large state data structure with many TVars around.  It feels like bad design.  What's the typical Haskell solution to shared state?
08:23:47 <nerium> haasn: Yes, which would be the same as Succ(n - m - 1), but that returns Zero in the case of 2 - 1
08:23:53 <mungojelly> what's with all this "succ" business? is that just a haskell thing? oh and pascal? i take it it just means the next one, like with numbers the next number, with lists the next item, something like that? :/
08:24:07 <ski> nerium : "should work" -- spell it out, and you'll see why it doesn't
08:24:08 <nerium> haasn: Sorry, but bad
08:24:14 <osfameron> meretrix: stick the state in a Reader monad maybe?
08:24:18 <nerium> *my bad
08:24:21 <haasn> nerium: No, Succ(n-m-1) is not the same as n-m
08:24:32 <haasn> 1-1 = 0  but Succ (1-1-1) is undefined
08:24:38 <ski> nerium : iow, spell out `2 - 1' in detail, with your `Succ m - Succ n = Succ (m - n)' defining equation
08:25:23 <haasn> I don't know what's so complicated about this. (-) is just subtraction
08:25:37 <ski> nerium : `n - m - 1' doesn't exist if `n' is equal to, or less than, `m'
08:25:39 <haasn> Subtraction isn't that complicated. Maybe you're overcomplicating things
08:26:11 <ski> nerium : so in that case `Succ(n - m - 1)' won't work for `(1+n) - (1+m)'
08:26:32 <ski> nerium : do you want to spell out `2 - 1', or should i ?
08:26:36 <nerium> ski: Yeah, that makes sense
08:26:41 <meretrix> osfameron: So basically just continue passing state around, but shove it in a Monad?  I guess if the state must be shared, there's no alternative.
08:26:59 <nerium> ski: I can try it, hold on
08:27:03 <haasn> > (1+n) - (1+m)
08:27:04 <lambdabot>  1 + n - (1 + m)
08:27:29 <haasn> How boring
08:28:11 <benzrf> haasn: use coq instead o3o
08:28:21 <benzrf> then it can simplify
08:29:25 <ski> nerium : anyway, the most interesting case of "`n' is equal to, or less than, `m'" here is the equal case, since otherwise `(1+n) - (1+m)' isn't defined either
08:30:28 <nerium>  ski https://gist.github.com/oleander/50dbfa5172e28c642ef1
08:32:15 <mungojelly> nerium: do you know why you're saying "succ"? i've never heard this "succ" business before, this paper ski linked me to is also full of "succ"s
08:33:05 <benzrf> succ = S
08:33:15 <benzrf> S is for Succ
08:33:21 <benzrf> the S is for Succs
08:33:25 <exio4> sucessor = (1+)
08:33:27 <mungojelly> i guess maybe the usual way of saying it is like "adding one" which is more an imperative way of looking at it, vs "looking at the successor"
08:33:27 <nerium> successor
08:33:48 <nerium> ski: That was correct, right?
08:34:23 <ski> mungojelly : it's the Peano representation of natural numbers. "succ" is short for "successor", so `Succ n' (or `S(n)', or some other spelling) is meant to signify `n + 1' (but `+' isn't defined yet, so we can't use it. nor is `1' defined yet)
08:35:19 <ski> nerium : what you typed in your paste is what we'd *like* to get. however, you didn't follow the *actual* definition you made for `(-)', when writing that reduction/evaluation trace
08:35:39 <ski> nerium : in particular, you didn't follow your computation rule `(Succ m) - n = Succ (m - n)'
08:36:04 <nerium> ski: Aha, I’ll try doing it again
08:36:10 <ski> nerium : here's what *actually* happens, if you follow it (prepended with a `fromInteger' translation from `2' and `1') :
08:36:14 <ski>      2 - 1
08:36:32 <ski>   =  fromInteger 2 - fromInteger 1  -- desugaring
08:37:04 <ski>   =  ll 2 - ll 1  -- by your definition of `fromInteger'
08:37:35 <ski>   =  Succ (ll (2-1)) - Succ (ll (1-1))  -- neither `2' nor `1' is `0'
08:37:47 <ski>   =  Succ (ll 1) - Succ (ll 0)  -- decrement
08:38:13 <ski>   =  Succ (Succ (ll (1-1))) - Succ Zero  -- `1' is not zero, but `0' is
08:38:30 <ski>   =  Succ (Succ (ll 0)) - Succ Zero  -- decrement
08:38:50 <ski>   =  Succ (Succ Zero) - Succ Zero  -- and `0' is zero, so `ll' yields `Zero'
08:39:38 <ski> that's the initial stage of translating from the numerals `2' and `1' to the type `N', using `fromInteger' desugaring, operating on `Integers' -- i included this for completeness, but will omit it in the future
08:40:29 <nerium> ski: That makes sense. I’ll try to remeber it, thanks!
08:40:47 <ski> nerium : are you currently using `(Succ m) - n = Succ (m - n)', or `(Succ m) - (Succ n) = Succ (m - n)' ?
08:40:47 <benzrf> is there an embeddable, interruptable, toy haskell implementation written in haskell
08:41:20 <benzrf> basically im looking for something that lets me easily and conveniently use haskell to parse & run haskell, but also view expressions and thunks and structure
08:41:36 <benzrf> in the process of being reduced
08:41:39 <benzrf> also types
08:42:07 <chrisdone> benzrf: sort of like :print/:sprint with more?
08:42:14 <ski> nerium : which ?
08:42:16 <benzrf> and programatic
08:42:22 <benzrf> chrisdone: 2 example uses
08:42:56 <benzrf> 1. write (in haskell) some kind of thing like lambda bubble pop but that works for almost any real code and actually ends up with correct results
08:43:33 <benzrf> 2. write a toy theorem prover with haskell as the underlying language; would require the ability to work with expression trees and programmatically typecheck & get expression types
08:45:17 <jayunit100> Is IO a type that we can capture and send around ? It seems funny to me.
08:45:18 <chrisdone> yeah, i think expression expanding would help with writing out equational reasoning
08:45:44 <chrisdone> jayunit100: yeah, it's just a value
08:46:13 <jayunit100> How do we create an IO ?  i.e. i have a function which i want to read input from a user , if necessary.
08:46:13 <chrisdone> benzrf: have you looked at :print/:sprint in ghci? i believe there's *some* potential to use ghci's debugger to do this
08:46:28 <benzrf> but i want a programmatic and easy-to-use interface
08:46:50 <chrisdone> in fact i once implemented an inventing-on-principle "code expander" that given an expression in your editor it would list 10 steps of reduction. but it used lots of memory and ghc would eventually die =)
08:46:50 <benzrf> the problem is that such a thing doesnt play well with efficiency and optimization
08:47:02 <benzrf> so i cant imagine that ghc would be good for these principles
08:47:18 <benzrf> chrisdone: yes, see, i want something that would allow you to make that kind of thing
08:47:27 <benzrf> *practically*
08:47:36 <benzrf> 11:43 < benzrf> so i cant imagine that ghc would be good for these principles
08:47:40 <benzrf> *not principles, use cases
08:47:46 <chrisdone> i also considered that you could interpret Core/STG from haskell
08:48:08 <ski> jomg : we can pass around `IO'-actions, just like one can commonly pass around callbacks and closures in strict (e.g. side-effectful) languages
08:48:11 <chrisdone> and for code defined outside the source module, you could use compileExpr or something from the ghc api. but that'd make that part of the code opaque
08:48:15 <ski> er
08:48:20 <ski> jayunit100 ^
08:48:44 <jayunit100> ah ok ... looking ski
08:48:54 <ski> jayunit100 : "How do we create an IO ?" -- use one of the operations that yield `IO'-actions
08:49:15 <ski> e.g. `putStr',`getLine',`readFile',`openFile',...
08:49:19 <chrisdone> if it's acceptable that code for which source (-> core) isn't available would be seen like "FFI", then my idea *could* work
08:49:27 <jayunit100> ski, doesnt getLine take IO as input ?
08:49:44 <jayunit100>  (readMay (getLine)) :: Maybe Integer -- this fails
08:49:50 <ski> nerium : .. still waiting for an answer
08:50:23 <nerium> ski: The second one
08:50:28 <chrisdone> benzrf: like err Core is obviously very simple to interpret and if you enable -fbyte-code you can source location information in the AST… BUT
08:50:52 <ski> jayunit100 : `getLine' is an `IO'-action (a "recipe") describing some I/O-operations to do : read an input line from standard input, then yield that as the result of executing the action
08:51:00 <ski> nerium : ok
08:51:04 <ski> here goes the rest
08:51:10 <ski>      Succ (Succ Zero) - Succ Zero  -- continuing from above
08:51:18 <chrisdone> benzrf: if the code is (\x y -> x + y), perhaps the engine should recognize "okay, + comes from GHC.Int.+ (or whatever)" and then do compileExpr "(GHC.Int.+)" and then use that
08:51:19 <ski>   =  Succ (Succ Zero - Zero)  -- according to your *actual* rule `(Succ m) - (Succ n) = Succ (m - n)' with `m' here being `Succ Zero', and `n' being `Zero'
08:51:27 <benzrf> cripes
08:51:58 <ski>   =  Succ (Succ Zero)  -- assuming you had `m - Zero = m', rather than `m - Zero = Succ m'
08:52:27 <ski> nerium : this isn't right, we want to get `Succ Zero' (iow `1'), not `2' as a result of computing `2 - 1'
08:52:35 <chrisdone> benzrf: otherwise you'll have to re-implement the whole of the standard ghc lib? like ghcjs does
08:53:09 <ski> jayunit100 : `readMay' wants a `String' as argument, not an `IO'-action that, when later executed, will yield a `String' result
08:53:12 <chrisdone> unless you just want to evaluate haskell 2010 pure expressions where all types and definitions are in source scope. that seems much easier
08:53:21 <phaazon> hm
08:53:31 <chrisdone> (i want a similar thing myself)
08:53:33 <benzrf> chrisdone: yeah, that's why asked about an implementation rather than a ghc interface
08:53:38 <jayunit100> ski okay i see the
08:53:50 <benzrf> chrisdone: isnt this basically the notion of an "educational implementation"
08:53:55 <ski> jayunit100 : you have to "attach" the `readMay' to the `IO'-action, to make it also get run later, whenever the action is executed : `liftM readMay getLine'
08:54:09 <phaazon> I could I lift a regular haskell lambda into my EDSL? cc edwardk
08:54:17 <joe9> augur: Does the pause monad help?
08:54:20 <phaazon> I can do: (Expr a -> Expr b) -> Expr (a -> b)
08:54:23 <jayunit100> ski cool !@
08:54:27 <phaazon> so that I can do
08:54:31 <ski> jayunit100 : `liftM :: (a -> b) -> IO a -> IO b' here. it "appends" a post-processing function to the result of an `IO'-action (also works for other monads)
08:54:33 <phaazon> fun $ \x -> x + LitF 1)
08:54:34 <phaazon> for instance
08:54:35 <nerium> ski: So you mean that its wrong?
08:54:40 <phaazon> but I’d like to be able to write this:
08:54:45 <chrisdone> benzrf: i do think that you could still use GHC to type-check and desugar for you into core, and then go off and interpret yourself
08:54:45 <phaazon> fun $ \x y z -> x + y * z
08:54:51 <jayunit100> is that a functorr ski
08:55:00 <phaazon> I guess it becomes (Expr a -> b) -> Expr ?
08:55:07 <jayunit100> looks like i finally see why people use functors
08:55:10 <ski> jayunit100 : and then this `liftM readMay getLine' will be an `IO'-action as well, of type `IO (Maybe Integer)', that, when later executed, will yield a `Maybe Integer' result
08:55:14 <benzrf> chrisdone: eek
08:55:27 <ReinH> jayunit100: liftM is equivalent to fmap, yes
08:55:29 <chrisdone> possibly…
08:55:30 <jayunit100> ski, i think this is a "real world" use of a functor, correct ?
08:55:32 <jayunit100> thanks !!!!!!
08:55:41 <chrisdone> assuming you can map a case back to a pattern match or view pattern or w/e
08:55:50 <phaazon> ReinH: do you know whether it’s going to be deprecated?
08:55:55 <phaazon> just as return
08:55:57 <benzrf> jayunit100: functors are for any parameterized type that has functions on it that 'correspond' to ones with the plain types
08:56:01 <phaazon> (in my mind it should be)
08:56:12 <benzrf> jayunit100: any time you have an f a -> f b for any a -> b that actually corresponds in a particular sense
08:56:26 * hackagebot hledger-diff 0.2.0 - Compares the transactions in two ledger files.  http://hackage.haskell.org/package/hledger-diff-0.2.0 (gebner)
08:56:53 <ski> jayunit100 : you can't just have an expression of type `Maybe Integer' here. the `IO' is "contagious", you don't get rid of it. the only way to actually execute an `IO'-action is to define `main' to be it (or to type it interactively e.g. in GHCi) -- every `IO'-action that gets executed gets executed because it's in one way or another been made part of the `main' `IO'-action (iow, `main' invokes it, either directly or indirectly)
08:56:57 <ReinH> phaazon: The AMP doesn't deprecate anything afaik
08:57:06 <phaazon> ReinH: hm
08:57:14 <phaazon> at least make a default implementation to return
08:57:17 <phaazon> (return = pure)
08:57:17 <ski> jayunit100 : yes, `liftM' here is the same as `fmap', and this is just using the fact that `IO' is a functor, correct
08:57:23 <ReinH> phaazon: yes
08:57:40 <chrisdone> benzrf: if you don't care about type-classes you could take fay as a base and delete the codegen and put something else in there. it seems if you're not going to use ghc or uhc for core, you'll be implementing all that stuff i did in fay for desugaring pattern matches into cases and tracking type definitions and record wild cards and … and …
08:57:41 <ski> nerium : yes, i mean that your rule `(Succ m) - (Succ n) = Succ (m - n)' is wrong ! :)
08:57:50 <phaazon> if things have been correctly done, return shouldn’t even exist
08:57:58 <benzrf> chrisdone: huh
08:57:58 <phaazon> only bind
08:58:08 <nerium> ski: Sorry, mine looks like this: (Succ m) - (Succ n) = m - n
08:58:15 <benzrf> chrisdone: typeclasses do tend to be out of scope for most applications for such a lib, i think
08:58:15 <nerium> Which should work
08:58:26 <ski> nerium : well, that's the correct one, so then you should be fine ;)
08:58:28 <ReinH> nerium: that's better :)
08:58:30 <benzrf> chrisdone: i think typeclasses are almost entirely a practical thing
08:58:35 <benzrf> at least, in haskell '10
08:58:46 <ski> nerium : .. assuming the rest of your definition is also ok
08:58:52 <chrisdone> benzrf: for proofs and education? perhaps so given that they have a human-mechanical translation
08:58:52 <benzrf> unless youre doing type hackery there's not a ton you need them to talk about
08:59:39 <nerium> ski: It seams to work :)
08:59:39 <chrisdone> benzrf: you're aware of stepeval obviously?
08:59:44 <nerium> ski: Thanks again!
08:59:47 <benzrf> not exactly :{
08:59:51 <jayunit100> ski thanks again ditto :)
09:00:00 <chrisdone> benzrf: https://github.com/bmillwood/stepeval
09:00:18 <chrisdone> it's basically a prototype of this concept but only for a very limited prelude and just enough syntax support to demonstrate
09:00:41 <chrisdone> at one point it was available on lpaste, but most code didn't work so i rm'd it
09:00:41 <benzrf> ooh
09:03:26 <ski> nerium : yw
09:04:40 <ski> jayunit100 : for more complicated examples of "post-processing" `IO'-actions (including sequences ones together, and making some new I/O-operations depending on the result of the previous one), you may need to use `(>>)',`(>>=)', or alternatively the `do'-notation sugar for those
09:04:58 <chrisdone> benzrf: i'd be interested in collab'ing or at least following future work in that area
09:04:58 <ski> jayunit100 : `return' also sometimes comes in handy there
09:05:26 <chrisdone> benzrf: fwiw dealing with core programmatically might be easier than you expect https://www.haskell.org/platform/doc/2013.2.0.0/ghc-api/CoreSyn.html
09:07:31 <chrisdone> and the https://hackage.haskell.org/package/thih project seems kind of usable actually
09:07:45 <benzrf> hmm
09:08:04 <benzrf> chrisdone: id love to work on such a project but i lack any relevant experience :\
09:08:08 <chrisdone> though i haven't actually tried it yet, just read through the paper and saw that this hackage code has been updated to work with haskell2010
09:08:30 <benzrf> damn this looks neat
09:10:00 <chrisdone> i markdownified the paper fwiw https://gist.github.com/chrisdone/0075a16b32bfd4f62b7b
09:10:09 <|Lupin|> hello huys
09:10:18 <chrisdone> allo allo
09:10:19 <|Lupin|> coming just for a demonstration
09:10:56 <|Lupin|> and low batteries
09:10:59 <|Lupin|> so won't stay very long
09:11:17 <|Lupin|> chrisdone: hey!! It's Sherab, we exchanged by e-mail,you remember?
09:11:44 <chrisdone> no way!
09:11:52 <|Lupin|> chrisdone: a blin guy
09:12:01 <chrisdone> i remember you. how are you?
09:12:03 <|Lupin|> chrisdone: we talked about hierarchical editors and so on
09:12:19 <|Lupin|> chrisdone: also about a web brower presenting a hierarchical view of pages
09:12:27 <chrisdone> right :)
09:12:47 <|Lupin|> chrisdone: many things happen and I couldn't work on it
09:12:52 <|Lupin|> chrisdone: but still interested
09:13:10 <ReinH> |Lupin|: that is the way of things
09:13:45 <chrisdone> i think it's actually become eaier to do these days what we discussed in the past
09:13:52 <|Lupin|> ReinH: what do you mean?
09:14:14 <ReinH> chrisdone: getting too busy to do a thing is pretty common :)
09:14:16 <|Lupin|> chrisdone: I think we should re-deiscuss it at some point
09:14:21 <|Lupin|> chrisdone: not now, not possible
09:14:42 <|Lupin|> okay
09:14:46 <|Lupin|> I'll leave
09:14:52 <chrisdone> the Chrome browser for example can be remote controlled, so you could totally make an awesome screen reader
09:14:53 <|Lupin|> the computer will shut down soon
09:15:05 <chrisdone> au revoir ;)
09:15:16 <|Lupin|> bye bye
09:15:24 <|Lupin|> take care all
09:15:57 <chrisdone> timing on that was crazy, haha
09:17:22 <chrisdone> we spoke by email a couple years back about how there's poor support for a braille-based screenreader for browsers
09:18:16 <chrisdone> but with a bit of jquery these days you can inspect a page trivially and send that off to a braille display
09:18:24 <ski> @tell |Lupin| perhaps you should also ask Peaker about bottle, if you're interested in editors and IDEs
09:18:24 <lambdabot> Consider it noted.
09:18:44 <chrisdone> ski: i think he would be. we were discussing how it's really hard to edit haskell if you can't see it
09:19:14 <ski> (|Lupin| is blind or sight impaired ?)
09:19:17 <chrisdone> lamdu definitely removes that from the picture
09:19:29 <chrisdone> blind
09:19:44 <ski> oh, `lamdu' is possibly the latest name for `bottle' (?)
09:19:44 <chrisdone> he uses a braille display for everything
09:19:48 <ski> ok
09:20:16 <ski> i wonder if that's the blind person i remember talking^Wtyping a little bit with in the past, then
09:20:44 <chrisdone> i know him via eric kow
09:21:26 <ski> (istr the nick "Lupin", but perhaps from another user)
09:21:48 <dav> is there a way to send a phrase/expression/selection to the repl in emacs?
09:23:00 <chrisdone> and do what with the result?
09:23:05 <osa1> why threaded runtime is not default?
09:23:23 <chrisdone> osa1: so that you can run your program and be confused when forkIO blocks
09:23:33 <dav> chrisdone: display it either in the repl buffer or in the code buffer
09:23:46 <chrisdone> dav: do you know any elisp?
09:23:47 <osa1> forkIO blocks in non-threaded RTS :O
09:24:01 <dav> chrisdone: not specifically
09:24:40 <chrisdone> dav: i can write a simple thing to do that in a few lines, i think. um
09:25:16 <dav> chrisdone: I'm sure it's not rocket science, but someone must have needed this before no? I would assume one of the modes should be able to do that..
09:25:36 <dav> in haskell mode you can ask for the type of an expression, but why not its value?
09:26:33 <chrisdone> i think inf-haskell mode has this
09:26:41 <chrisdone> i just type in the repl…
09:27:34 <nerium> ski: Would you consider these two equal? https://gist.github.com/oleander/9aa5c83cf8aad90f720a
09:27:47 <Yuras> osa1: probably because it is slower in 1-core setup
09:27:49 <koniiiik> nerium: I stopped following the discussion quite early on, I don't actually have to do the assignment (I'm not even a student), but reading the statement, I don't think you're supposed to implement anything more than the primitive recursion functor and use it to implement add. No subtraction or anything else.
09:28:35 <dav> so, if I'm writing a small function and I want to see if it works, the work flow is: 1) make a modification, 2) C-c C-l (reload file in repl), 3) switch to repl window, 4) invoke function by hand and specify arguments by hand. feels like there should be a way to tighten this loop to a single step
09:28:36 <Yuras> osa1: but how forkIO blocks? what do you mean?
09:28:56 <nerium> koniiiik: In the first assignment we’re suppose to implement N as a data type and then use it in add
09:28:58 <Yuras> it can be desheduled, but the same in threaded rts IIRC
09:29:14 <nerium> koniiiik: So we still need more the just a recursion
09:29:30 <osa1> Yuras: I haven't tried that myself.  maybe chrisdone can elaborate.
09:29:48 <chrisdone> dav: https://gist.github.com/acowley/f9692e646acecf10e248
09:30:21 <Yuras> or, I did noticed his reply
09:30:26 <Yuras> *didn't
09:31:42 <koniiiik> nerium: Yes, that's what I tried to investigate here and actually the reason I joined this channel. As it turns out, enforcing that kind of constraint in the type definition itself would require generalized algebraic data types, and I seriously doubt your lecturer expects you to use those.
09:31:54 <chrisdone> dav: however i prefer my function
09:32:00 <Yuras> osa1: anyway, threaded runtime does a lot of work that is unnecessary even in -N1 case
09:32:04 <chrisdone> dav: http://lpaste.net/4838370067278200832
09:33:56 <nerium> koniiiik: Yeah, it took 4 hours to implement with not much prio Haskell knowage, but how else are we suppose to do?
09:34:06 <ski> nerium : which two ?
09:34:43 <nerium> ski: The implementation of Z and the def of Z below (according to the gist)
09:34:44 <osa1> Yuras: that makes sense, thanks.
09:35:26 <ski> nerium : oh .. i missed the text
09:35:29 <chrisdone> dav: i think the idea of sending stuff to the repl doesn't really save much work
09:35:52 <ski> nerium : more or less equivalent, yes. though `N' should perhaps be renamed to `Z' here :)
09:35:56 <chrisdone> dav: but perhaps the idea of "watch expressions" could close down this gap more nicely
09:36:13 <nerium> ski: Apparently, the def of Z below is not correct (according to the paper from our teacher)
09:36:25 * chrisdone -> shopping
09:37:41 <ski> nerium : well, as a definition of the *integers*, i'd agree it's not correct -- but you latest paste above didn't say that `Z' (both in the code and ther picture) was required to correspond to the integers :)
09:37:56 <ski> s/you latest/your latest/
09:38:49 <dav> chrisdone: I'm open to any and all productivity improvement :)
09:38:55 <nerium> ski: Sorry, N should be Z
09:39:10 <chrisdone> dav: i'll be back in 40 mins if you'll be about then to discuss more
09:39:11 <ski> nerium : yes, i already assumed (and mentally applied) that fix :)
09:39:32 <ski> nerium : still, the paste didn't say that `Z' had to be the integers :)
09:39:42 <nerium> ski: The problem is apparently that s(x) might requal p(x), which isn’t okay
09:39:56 <ski> not quite
09:40:12 <nerium> s(5) == p(7)
09:40:12 <ski> `s(x)' might equal `p(y)', for some particular `x's and `y's
09:40:33 <ski> `s(x)' can't equal `p(x)' for the same `x', if we're talking integers
09:40:39 <nerium> Yes, and according to the def (in the paper) that’s not valid. So; is there another way of doing it?
09:41:06 <dav> chrisdone: unfortunately am heading to a wedding.. but I'll try to be back this week
09:41:25 <ski> of course, just looking at the math, it neither says that `p(x)' must always be different from `s(y)' nor says that it can sometimes be equal
09:41:37 <ski> nerium : however, in the Haskell, it's assumed that if things aren'
09:41:47 <ski> t "obviously" equal, then they're different
09:42:04 <ski> where "obviously" here means "structurally"
09:42:27 <nerium> ski: I’m not really following. So this isn’t a problem in haskell?
09:43:08 <ski> so, assuming an element of `Z' has been reduced to an expression only involving `Zero',`Succ',`Pred', then two such fully reduced exoressions are equal if and only if they're spelled the same way (ignoring whitespace, and possible extraneous bracketting)
09:43:50 <ski> and two expressions that aren't necessarily reduces are defined to be equal if and only if the corresponding fully reduced (aka canonical (form)) expressions are equal
09:44:12 <ski> nerium : i didn't say anything about that
09:44:19 <nerium> ski: What prevents haskell from producing Succ(Pred(Succ(Pred(0))) instead of just 0
09:44:35 <ski> i'm just saying that the math picture there, on its own, doesn't pin down the integers
09:44:47 <koniiiik> ski: The problem is that the assignment requires that their definition only allows normalized values.
09:45:38 <ski> you could well imagine that `Z' is the set `{0}', and that `s' and `p' are defined on `{0}' such that `s(0) = 0' and `p(0) = 0' (which is the only possibility, after all), and then the three conditions in the picture are *satisfied*
09:45:52 <ski> so, clearly those three conditions aren't enough for a set `Z' to behave as the integers
09:46:19 <nerium> koniiiik: Any input?
09:46:53 <ski> nerium : "What prevents haskell from producing Succ(Pred(Succ(Pred(0))) instead of just 0" -- nothing. to haskell, those are different things, given the definition `data Z = Zero | Succ Z | Pred Z deriving (Show,Eq)'
09:47:29 <nerium> ski: Exactly, and apparently that wasn’t okay according to the def of Z (in the paper)
09:47:41 <ski> nerium : so, since to Haskell, those are different, it can't obviously give `Succ(Pred(Succ(Pred(0)))' as result instead of `0', if that's what you meant
09:47:57 <ski> nerium : "that" referring to ?
09:49:19 <nerium> It should not be possible to create the array if integers in any other way then one. you could for example create any integer in a number of ways using Pred and Succ, which isn’t valid accordint to the def
09:51:08 <nerium> ski: So, how do we create a data type which prevents this?
09:53:22 <ski> nerium : ok
09:53:40 <ski> nerium : so they want to prohibit `Succ (Pred m)' and `Pred (Succ m)'
09:53:49 <nerium> ski: Exactly
09:53:49 <ski> one approach is smart constructors
09:54:21 <ski> another is to split off the positive and the negative integers into separate types (perhaps coupled with "smart" constructors, for convenience)
09:54:37 <ski> nerium : do you know what is meant by "smart constructor" ?
09:54:59 <nerium> Yeah, one that appies the correct Pred or Succ depending on the the value
09:56:03 <ski> yeah, you make replacement operations for (some or all) of the constructors, that additionally either check some extra conditions on the data (for encoding a quotient type), or normalize the data to a desired normal form (for encoding a subtype), or both
09:56:28 <ski> and usually you then don't export the constructors which were "replaced" by smart constructors
09:56:54 <ski> (though you may need then to export some operation replacing pattern-matching on the non-exported constructors)
09:57:49 <ski> nerium : er, sorry, swap "quotient type" and "subtype" in what i said. i managed to state it backwards
09:58:29 <nerium> ski: Any idea how do to that?
09:58:40 <ski> nerium : "subtype" means that only some of the actually expressible values in your representation type are intended as real elements of the type/set you want to encode
09:59:03 <ski> in your case, `Succ (Pred Zero)' is simple an unwanted, invalid, term that you got but don't want
09:59:40 <ReinH> ski: why is it in valid? Is this intended to be the natural numbers?
09:59:50 <ReinH> *invalid
10:00:20 <ski> ReinH : integers -- see also :
10:00:26 <ski> <nerium> It should not be possible to create the array if integers in any other way then one. you could for example create any integer in a number of ways using Pred and Succ, which isn’t valid accordint to the def
10:00:48 <ReinH> this is a definition of the integers up to equivalence
10:01:27 <koniiiik> ReinH: nerium is working on an assignment which specifically asks for a definition in Haskell which only makes it possible to express normalized values.
10:01:32 <ReinH> where term are equivalent if they reduce to the same canonical form
10:01:39 <ReinH> Ah...
10:02:49 <ski> nerium : "quotient type" means that some of the expressible values are to be *considered* as equal .. so e.g. the rational number `6 / 14' is considered to be equal to be equal to `15 / 21', despite being spelled differently (being structurally different)
10:03:50 <nerium> ski: But’ve are only talking about Z, not R
10:03:54 <ski> nerium : often (not always), if you have several alternative representations for the same ideal value, like the rational example just above, there's one canonical representation, in this case `3 / 7'
10:04:26 <ski> nerium : so, in that case, the canonical representations are conceptually a subtype of all the possible representations
10:04:36 <ski> nerium : now, you *could* make a smart constructor like :
10:04:43 <ski>   succ :: Z -> Z
10:04:50 <ski>   succ (Pred _) = undefined
10:04:58 <ski>   succ n       = Succ n
10:05:03 <ReinH> nerium: (a quotient type is one that is "partitioned" by just such an equivalence relationship)
10:05:32 <ski> nerium : doing that means that you simply prohibit anyone from typing `succ (pred Zero)' (or rather, if they try, the'll get an error)
10:06:17 <ski> nerium : but, since in this case `Succ (Pred Zero)' can be seen as an *alternative* (more complicated) representation for `Zero', it would here be nicer to *convert* automatically from the former to the latter, in the smart constructor :
10:06:23 <ski>   succ (Pred n) = n
10:06:28 <ski>   succ n        = Succ n
10:06:32 <ski> nerium : ok ?
10:07:15 <nerium> *reading*
10:07:37 <nerium> ski: Okay, I think I get it
10:08:06 <ski> nerium : that way you both (a) get canonical representations as answers (provided you call the smart constructors instead of `Succ' and `Pred' directly)
10:09:00 <ski> nerium : *and* (b) you still allow the user to type `succ (pred n)', so they can safely write `succ m' without checking first whether `m' is non-negative (or we'd get an error, with the previous definition of `succ' above)
10:10:02 <nerium> ski: I really need to eat something. I’ll be back in 45 min. I’ll do some reading on the smart constructors subject
10:10:12 <zipper> What does inlining mean? In this context --> "GHC does quite aggressive cross-module inlining"
10:10:41 <ReinH> ski: unfortunately we can't construct the equivalence relation in haskell :(
10:10:45 <ski> nerium : anyway, for our purposes here, subtypes and subsets are basically the same thing
10:11:29 <nerium> ski: Okay, I guess https://www.haskell.org/haskellwiki/Smart_constructors where I should read
10:11:49 <ReinH> zipper: inlining is replacing a name with its definition
10:12:03 <ski> nerium : also quotient types and quotient sets are also the same, though you have possibly not heard about quotient sets before. the idea is the same as the idea of partitioning a set into "sections" (equivalence classes, by using an equivalence relation). then we can more or less treat the elements sharing a common "section" (equivalence class) as "the same", insofar as they share the same property we're currently interested in
10:13:15 <ski> nerium : in math, one formally often say than one passes from one representant to the (equivalence) class of all represents that are equivalent to it, according to the equivence relation in question
10:13:18 <osa1> is this library published http://code.haskell.org/~duncan/binary-experiment/binary.pdf ?
10:13:26 <ReinH> (Both are quotient categories)
10:13:31 <nerium> ski: brb
10:14:27 <zipper> ReinH: So that makes it not refer to the code in another module? Wow uh thanks.
10:14:30 <ski> nerium : however, it's often more convenient to just continue operator on the representant, while *remembering* to take care to not accidentally distinguish between representant that are supposed to be treated as equivalent
10:14:52 <InfusoElAmbulant> hey, is there any programming languages theory especific discussion channel here?
10:15:20 <ski> nerium : but, if you can find a canonical form, you can avoid that worry, by just converting all representants to canonical representants (though that might be less efficient in some cases)
10:19:47 <Zorg> Is there a select() type call for sockets somewhere? Can't seem to be finding one. Found a timeout function though.
10:21:19 <geekosaur> typically you use threads instead of select, which is buried inside the runtime (and usually uses something better than select() anyway)
10:23:09 <ski> nerium : to clarify. your representation of the integers can be seen as either a subtype of the actual Haskell type `data Z = Zero | Succ Z | Pred Z' (namely the subtype in which you can't mix `Succ' and `Pred' in the same value)
10:23:17 <ionum> which library would you guys recommend for logging in a web site (written in php) and scanning it for updates?
10:24:30 <ionum> i would be able to do it really quick in python, but i want to get into haskell and do future stuff in i
10:24:31 <ionum> t
10:24:43 <ski> nerium : or it can be seen as a quotient type of that Haskell representation type, wrt the condition that `Succ (Pred n)', `m' and `Pred (Succ n)' are to be regarded as being equivalent to each other (iow being merely different representations of the same ideal value `m')
10:25:25 <ski> nerium : combining these, we get that we can convert each reprentant in the latter view into an equivalent one, that is allowed by the former
10:25:51 <ski> s/reprentant/representant/
10:26:13 <ReinH> ski: except for infinite values.
10:26:21 <ReinH> :(
10:26:37 <ReinH> And partial values
10:27:27 <ReinH> Actually partial values are fine
10:27:59 <ReinH> They all evaluate to bottom
10:28:11 <Zorg> geekosaur: I see, one more thing to learn. I should start with forkIO I presume?
10:28:29 <ski> ReinH : yeah, but i was naively only considering the inductively generated representatives
10:28:52 <geekosaur> Zorg, yes
10:29:02 <ReinH> Zorg: yes, but keep the async package in mind. And consider reading SimonM's free concurrency book
10:29:49 <ski> Zorg : you'll probably also have use of `MVar' or `Chan'. or you could use `STM's `TVar',`TMVar',`TChan',`atomically'
10:30:17 <ski> (there's also semaphores, i think)
10:31:01 <ReinH> (All of this is in Simon's book)
10:31:27 <Zorg> *nods* thanks guys, will look into it
10:31:37 <ReinH> ski: laziness breaks our pretty abstractions sometimes :(
10:32:56 <ski> well, one could blame it on infinity
10:33:10 <ski> though it's sortof the same thing here
10:40:12 <lifter> How do I get lambdabot to tell me the point free version of  function?
10:42:45 <FireFly> @pl \x y -> x + y + x
10:42:45 <lambdabot> flip =<< ((+) .) . (+)
10:42:59 <lifter> thx
10:43:01 <FireFly> disclaimer: results may not be readable
10:43:10 <FireFly> it's a rather pointless feature, actually
10:43:20 <lifter> @pl \f -> f x y
10:43:20 <lambdabot> flip ($ x) y
10:43:38 <lifter> hehe yeah
10:44:12 <lifter> @pl f = \g -> g x y
10:44:13 <lambdabot> f = flip ($ x) y
10:44:31 <lifter> yeah not very readable
10:45:00 <FireFly> @pl \f g h y -> g y `f` h y
10:45:01 <lambdabot> liftM2
10:45:26 <FireFly> You can also use the bot in a /query, by the way (as in /msg lambdabot @pl foo)
10:45:48 <lifter> ah ok
10:46:30 * hackagebot yesod-core 1.4.4 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.4.4 (MichaelSnoyman)
10:47:25 <joe9> source code:  http://codepad.org/LSShIJbZ I cannot figure out how to fill the hole. error: http://codepad.org/Vs7bONCa . Can anyone please help on how to go about it, please?
10:54:45 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org'
10:54:45 --- topic: set by glguy on [Thu Sep 25 17:55:19 2014]
10:54:45 --- names: list (clog_ Revenrof Arahael_Twin emma_ 14WAANZMI xinming_ raek_ tawm_ dmbaturin_ neena mjs2600 Hemamorphy mgomezch_ jaspervd1 zerokarm1left taktoa_ ToRA_ godel_ themattchan Miciah_ moy Martty_ S11001001 Guest8900 PierreM_ disperse1 DanToml_ beanmachine koninkje1away lattenwa1 ij badi`` ormaaj_ SegFaultAX Fusxfaranto_ dsantiag_ sithrak Jellydog oldmanstanley___ yusukesuzuki jabbslad_______ mthvedt_ mike4 haskelln1obie pikhq rodlogic_ sea-gull ReinH eristic_)
10:54:45 --- names: list (Guest64833 arianvp__ srcerer_ asmyers Plasmastar mrb_bk dixie_ _Vi pjdelport werdna_ Blkt_ zph TDJACR Guest729 rufs hegge heyj creichert wto cfricke_ Mateon1 arianvp_ sweeney stiell_ aupo_ johtso_ expo873_ suvashz osa1_ bgamari- puzza007 MMuse_____ joe9 cwraith Durz0 ddellacosta j4cknewt jaffachief thsig_ OscarZ_ s00pcan jumblerg caumeslasal1 hamid MitchellSalad winobes sinelaw agjacome pheaver phreedom eb4890 jasonjckn seschwar Netpilgrim josephleon tech2_)
10:54:45 --- names: list (tommd edlinde_ emanuelz hiroakip vjeranc athan tomboy64 Mon_Ouie wikikiwi rozgo Eagle_Erwin MoALTz_ tsani Klumben blicero trism InfusoElAmbulant nexion Zorg zcd hauzer Involuntary kazimir42 folone doomlord_1 eikonos jetho lennartl dhil martintrojer stefan_1_|Work j201 ionum ceii vanila ndrei sritchie univerz mornfall umbriel Zekka john_not_jenny n0n3such Rutger` darkbolt rshetty bcap_zZz ulfdoz takuan XniX23 ZioCrocifisso Rakkin petersr Yxven Guest59645)
10:54:45 --- names: list (myfreeweb edon godel mystor Polarina indiagreen Javran torpet it0a Betal netj charlie laar Nervkind Darkflux doodlehaus nschoe nominolo xahry jomg cfricke MuffinMan` spopejoy Guest7213 netogallo Takle twanvl_ banister Yuras _ashbreeze_ govg mitochon vrdhn ro6 bjz autochthon jdegoes chef__ jedai umib0zu ixti fizbin marchelzo_ samrat kidnapped_robot eacameron2 Paprikachu drbean Platyp seveg Discovery IlNominePatre LeoTal kadoban hnoob dgpratt Church- obb klao)
10:54:45 --- names: list (aarvar titusg bennofs saep tattsun ioanel germ13 cognominal Kaidelong reizuki__ ompaul Noldorin heurist Jackneill oleo sivteck exlevan blume RaceCondition ttuegel damncabbage lritter Khisanth raichoo t7 Philonous jchmrt snoopybbt psii pharpend Gurkenglas Fubar^ Vq Stratege__ nerium jpll manfoo7` glaebhoerl sxn lecoeus Zeitgeist_ koniiiik renekooi vlatkoB_ agumonkey pantsman- foreignFunction Reite komarov wilfredh madjestic conrad__ krobelus_ dmwit___ dmwit__)
10:54:45 --- names: list (thunderrd NightRa Frivillig mthvedt zwer Boney_ lukaraamu malllle shesek darthdeus silver mkster marr brushbox bitonic phyrex1an ChristianS SoupEvil barx irrequietus fyolnish Shin-LaC ht__th angerman shepheb whaletechno xificurC hackagebot joneshf-laptop besenwesen SCHAAP137 lykkin amiri_ shigosei purefn qrada Pip ZettaBlade jordanl rhodesd deevus vimpire hiratara orbital maaku PatrickRobotham mauke gseitz myk267 Guest64632 otto_s_ eisbehr vili Glavata pa3ce)
10:54:45 --- names: list (stefan_1 cyphase shanse zorg24 Blizzy xplat dcoutts Ralith conal mceier chrisdotcode apaku meandi_1 Rufflewind pks ToTheInternet tobik reddodgem bam365 xinming MitchW kiniry mgsloan seliopou predator117 GGMethos SamuraiMark anannie seafood cleamoon_ kafi mungojelly Azel Longlius Hijiri etabot ezrios maxcan solrize seangrov` isomorphic heaumer_ bbloom knyppeldynan Mortomes RchrdB plutoniix listrophy FreeFull kwantam nakal marens Brando753 Oxyd vmeson chrisdone)
10:54:45 --- names: list (haasn amf WraithM Zenith77 OlegYch fabe thetallguy SparkySparkyBoom jzl ikke zyla mountaingoat noam so dabradley fxr wtw albeit Plastefuchs krgn_ junmin brandonw zanchoPansa da-x _5kg billymeter ens farnsworth_ mecalopo1 BlastHardcheese Kobata Gonzih Cale Ranis haskellnoobie cbou Livadi0 jle` eevar eyck petermw milessabin clog stepcut dh stephenmac7 stepkut sbauer322 fqsxr magicman Oksana amatsu Soft joelteon magicflakes zmthy dgonyeo lnostdal stomp brixen)
10:54:45 --- names: list (bananagram Belgarion0 vladan ortmage caasihuang_ spion Ornedan ajcoppa numberten haroldwu wormphlegm shiona joefiorini andreass ljhms vlopez nesqi jcurbo keaml JRoberts ryu91835 eazar001 sbahra ForNeVeR oldmanmike exio4 effy_ himikof Draggor o0oo0o zinfandel Sgeo tismith infinity0 Mokosha orion zxq9 Freemason sssilver_ fnordbert boot13 srcerer ThatOtherPerson davidfetter oliffea_ gienah renzhi fiatjaf laktech codeburg LeaChim manfoo7 blenny phaskell dgvncsz0f)
10:54:45 --- names: list (Enigmagic zomg byorgey tv jophish enomies heikkih cdk psy_ pp^ tyconnell dsantiago paperManu bonobo mjo gal_bolle pantsman meretrix Kabaka ludamad sinopeus vital gx^ sunfun simonnn jchia1 Riviera Lacriatch saati_ wchun tomku neptunepink _rgn Nik05 d-snp Floyd_ sipa Number2 theshadow apo MrWoohoo zariuq juhp ashnur RevJohnnyHealey piskrist dibblego slobo SuperTux88 LordDeath raid Cerise l3kn nwf angelicstrike xandaros vermeille tristero Lutin` sviterok)
10:54:45 --- names: list (rossberg connerb _ikke_ andbroby tg bjornars1 TrafficMan BrianHV Talryn mietek teeteewhy banyan Svedrin eL_Bart0 TheMoonMaster ion cmn peddie conehead vobi hpd sleepynate somenick dmilith Jaxan Draconx pdxleif notdan mathu kjanosz ktosiek peder Nickeeh mami vsayer_ `micro twopoint818 acharles drdo Edoxile Jo-haN Vorpal petterw_ usr ayako drone- Rembane HylianSavior saiam paz__ jstolarek kakos_ matthew-_ taruti s4msung_ ozzymcdu1f tero-_ frontend1oader)
10:54:45 --- names: list (butyoudonot gargawel KitC_ funrep XMunkki brackets senseibaka_ tnks noidi hc jlouis_ wizonesolutions mitu Desoxy_ T_X Xorlev cjheath Raynos gregburd hguux_ osfameron leifw spacebug1 wting_ bgyss koninkje_away seanparsons neena_ nmashton xaimus_ divyanshu tawm Guest53095 ilmig_ ixian8 mjrosenb teehemkay btc_ ehamberg n1ftyn8 cyanoacry SLi shelling_ blindscreen c9sould_ edwardk bkolera LQDHelium sclv cstrahan lacrosse__ sross07 nick1234abcd shouya mno2)
10:54:45 --- names: list (kirjs______ akahn si14 serjeem_____ dutchie drewdavis_ dstockwell l3dx Sorella joefiori_ joefiorini_ wjt larrytheliquid__ jroesch___ flux L8D Benzi-Junior ma82 ocfx Sornaensis oconnore Miciah David sujeet mach dagle dropdrive DanC_ zeiris coeus_ C4Cypher seanaway augur def- Peaker fikusz imalsogreg Na6hu7Ud boris`` Th0mas kkh robotbrain Martty ahihi blast_hardcheese DrCode joneshf chelfi juri_ dr__ inr Guest36631 MagBo thoughtpolice Meeh harski1 u_)
10:54:45 --- names: list (Matrixman_217 Tiktalik gnomnain` frogpunc javex jmcarthur tdammers louisjb __jim__` jlamothe dreixel Pucilowski c74d rodlogic felixn JamesJRH royadav spwhitt ninzine rejuvyes- HugoDaniel tolt otulp linduxed Yarou thomas mitchty wagle srhb channel_t sm klarrt kmicu horlicks_ Denommus intrados lifenoodles segmond stojic r444 anders0 jnoah swook dario greeny_ bgamari derekv cursork mcbonz wires gniourf nemesit|znc liuw jdiez lericson rudi_s itsmonktastic)
10:54:45 --- names: list (cosmicexplorer Internet13 only_the_bear jakutis bel3atar sdx23 mikeplus64 Reiser melter idoru _flow_ delhage SwashBuckla MK_FG LnL luigy pyrtsa alanz wjlroe fergusnoble greymalkin Boreeas pnielsen sohum codehero ]OLI[ theanalyst thirsteh Guest17603 gws sellout jameseb Haskellfant christia` milli` ToRA liyang Walther eristic hmax_ mankyKitty korpse___ Jaak shelf zxtx lambdabot tumdedum henrikhodne profil naiyte Elite6809 lamilami mrowe_away henk Arahael)
10:54:45 --- names: list (dj_ryan d3lxa AntiSpamMeta Jello_Raptor integral shennyg____ biscarch Saizan bcarrell raphie arun rom1504 dkua aloiscochard rola flebron Preyer ircbrows- dlackty paintcan DarkCthulhu yaopo k00mi ZsoL dolio YayMe nyuszika7h xpika kshannon klarh Dykam goldfire RayNbow`TU albel727 burp felixsch Lindrian eamelink lieven Jonno_FTW taktoa lycide CindyLinz dmead jlyndon jonrh AlainODea_ ninegrid Quashie Forkk_ Artpicre Nimatek thetallguy1 bydo janne keltvek Axman6)
10:54:45 --- names: list (davidthomas statusbot jedavis miasma Nivim lpaste mgaare nomnomnomnomnom earthy gds fall_ diprosopus catsup comboy flyingfisch japesinator happy0 unsymbol keko-2 Maxdamantus Fullma sw1nn uber Cr8 estewei_off Bigcheese Adeon Chousuke aleator iteratee m4farrel petercommand Fusxfaranto bsmt opqdonut mads- ciaranm Kruppe ad Sonderblade dispersed Wamanuz Farow ob chriswk____ _d3f aristid_ superjudge aristid ybit3 anry kloplop321 danking thamz ckw jrp6 belst andyt)
10:54:45 --- names: list (rfw joshsz tarcwynne__ jdeeburke ZucchiniZe texasmynsted nathanic ibid etrepum jonsterling alethea lohkey Taneb qsuscs waynr znutar ft bmuk tov wollw ccasin seagreen- Tene maurer zoglesby jlewis carter WzC iross xeno falafel skarn cjwelborn mawuli akurilin finnrobi canta Natch Fuuzetsu perrier quaestor1 tromp_ bolmar martingale sofancy_ dyreshark Eliel Cathy McManiaC monochrom lenstr kalz marko ps-auxw fuziontech____ dmbaturin Excureo joeytwiddle StoneToad)
10:54:45 --- names: list (Gothmog_ V3ct0r larsen jrslepak noddy hamishmack monsieurp ByronJohnson qzzx yorick ValicekB antinode masse Vbitz cschneid k4r1m mrpantoufle Nshag raek adamse marvin-hh jayne przembot lucs parallel21 agatam Profpatsch Keel zz_rabisg luz1e avdi joedevivo aseidl Starfire ousado cfloare helgar mak` __main__ Spaceghost bjorkintosh _aegis_ ben__ jlewis_ ChongLi ormaaj zerokarmaleft silasm Xack mephx kipras glowcoil FireFly vikraman dlundy hpc mindCrime_ funrep_)
10:54:45 --- names: list (mendez_ dowski__ julmac `0660 CosmicRay anders^^ Deewiant Nanar ernst Aquana ski seubert Kinnison amontez stbuehler yano brisbin int-e obiwahn zeroskillor cin alang mattp_ fvt jorj \q metaf5 Igloo lurker6 jcp statusfailed geal relrod iron_houzi Twey ThePhoeron bitraten capisce Yawgmoth adimit gratimax tessier alinab Intensity theorbtwo rak[1] flori ClaudiusMaximus npcomp Tesseraction chirpsalot totte lattenwald marienz pqmodn_ tridactyla pingu fling sshine)
10:54:45 --- names: list (Zariel mgomezch bjobjo nisstyre Scorchin Transfusion Athas bcoppens Liskni_si ziman JPohlmann mgomes defanor yukonjack rbocquet troydm rieper jrib srbaker bind sivoais ephemeron NikolaiToryzin hongminhee qwandor sprang MiracleBlue ocharles CARAM_ platinuum jzelinskie m_george hellschreiber lyxia mikeizbicki jang andrewsw ldcn dqd smart_ptr stelleg badi` callumacrae stass prinsen joehh jaspervdj naudiz elfangor betawaffle vukcrni gbarboza timpani TakSuyu)
10:54:45 --- names: list (rmunroe petantik agrif wjm jasu0 `bps CoverSlide andreypopp_ emmanueloga ggherdov mbrcknl asabil supki Phillemann zq qz Fuco PierreM DanToml cryon KorriX adadad sbrg diginet Hodapp dsfox1 joeyh sordina3 vincom2 zymurgy Kneiva levi emma edk ryanakca jmct kalail_ bra sorind tekacs DarkFox frawgie_ lpsmith dehflingus alpounet liif pii Ferdirand benmachine krakrjak_ tazjin hbar tm512 mirsal SHODAN Willis inuoppai edran Baughn _dyrim antoniy johnw PHO SaBer kav)
10:54:45 --- names: list (eikke mortberg gandr kandinski saurik pieter machineslearn asm89 Reyu annulus cowtown c-rog bergmark karls kini tromp eyenx joehillen koala_man TallerGhostWalt AshyIsMe Watcher7 eyem sunnavy ahf lb5tr malglim barrucadu fall` newsham theDon coconnor xnyhps bbastian- Razz agundry elgot ndeine DustyDingo mrkishi tlevine igniting cods dhrosa elij bentley obcode kaol Drezil cinimod mgregson td123 rblackwe tippenein acfoltzer pygospa dv- yukko deavid)
10:54:45 --- names: list (zpconn__________ Logiar bernalex dschoepe spaceships fryguybob klugez dp_wiz_ hyPiRion eagleflo okic monty nitrix jonathanj dpn` pi8029 majoh geekosaur schlumpi iota_ s_e dilinger pmarreck dunj3 froztbyte arch_ shapr Someguy123 franka photex dan64 go|dfish indigo Laquendi shutdown_-h_now Phlogistique honkfestival zrl dixie bartavelle Bane^ Hugglesworth joe_k nafis davesilva benzrf deni noctux gidogeek spindas Ptival cjay runde JZTech101 Dodek qtplatypus)
10:54:45 --- names: list (friden staffehn zalami solirc dustinswan ivoscc kaiza jix pfoetchen Kaini bastian__ lassulus bbee dogmaT_ owlglass2 bens jrw myme otterdam averell hopnotch Gracenotes Dashkal tomejaguar_away boegel|work|afk dawik luite drewr ido mmaruseacph2 Tehnix hiredman joshc Ezku fold edwtjo futureperfect mixi M-ou-se sddhrthrt sgronblo chasecal1 wayne ParahSailin_ Antoine59 therealklanni adarc scopedTV ephess mandu ThreeOfEight cross Freundlich lokydor Ulrar pharaun)
10:54:45 --- names: list (Laney Clint poucet simpson grohne amiller shmookey kragniz bvad _br_ stvc danneu sajith [swift] cynick cow-orke1 fds4345 DanZimm lispy clementd natte roo mp asjo irssi claudiyoh benbangert mrshoe ggreg mlen Licenser phaazon tassmjau Pad^ tstc yeltzooo hvr GaveUp joachifm owa Hardolaf Harbinger knyon mero absence solarus qr42 phadej ivan` swen aleator_ honza henrixh kgadek DigitalKiwi opto tych0 zebr kloeri bitemyapp Hafydd abc56889 lolocaust mechairo` hsc mrd)
10:54:45 --- names: list (gridaphobe noplamodo Ke cpa_ tomaw @ChanServ Rylee abh arrdem zenzike iulian kosmikus robbert posco dflemstr davean tomprince yam nulpunkt Dtgr jackhill howard_ thorkilnaur plhk adlan)
11:11:14 <blume> so i want to use the function unfoldTreeM_BF :: Monad m => (b -> m (a, [b])) -> b -> m (Tree a) to build up a tree. and then, i want to search that tree for one specific element and give back the steps that led to it. can i use the Writer monad for that? im not sure whether the type is correct, and i havent really done anything useful with monads yet.
11:11:38 <vanila> writer monad is a good idea for that
11:12:37 <ski> joe9 : `return . Free $ _' is already a (slight) step in the wrong direction (iow, you can't fix it just by plugging the hole)
11:13:24 <joe9> ski, any suggestions on how to fix it, please? http://hackage.haskell.org/package/free-4.2/docs/src/Control-Monad-Trans-Free.html#FreeF seems to use fmap (fmap f) -- I am still trying to understand how that works though.
11:13:29 <blume> vanila: and the type for that is fine? i would think the returning type should be Tree (m a) so that every element has the steps accompanying it. but it's just a guess
11:13:54 <vanila> blume, I thought you would build the tree, then later on use that result
11:14:07 <vanila> so thr type of unfoldTreeM_BF shouldn't have anything to do with the search
11:14:27 <vanila> I guess I misunderstood
11:14:31 <blume> oh i thought i had to write the steps while building the steps
11:14:39 <blume> no i just dont know what my possibilities are
11:14:55 <vanila> well i thought you would write out the steps as you walk down the tree
11:15:06 <blume> if that's possible, i'll try.
11:15:10 <vanila> of course you could put them into it too producing  m (Tree (Path, a))
11:17:46 <ski> joe9 : consider the case
11:17:50 <ski>   Free fx -> ...
11:17:55 <ski> what do you know ?
11:17:58 <ski> you know here
11:18:11 <ski>   Functor f
11:18:13 <ski>   Monad m
11:18:20 <ski>   f :: a -> b
11:18:22 <joe9> ski, yes.
11:18:30 <ski>   fta :: FreeF f m a
11:18:34 <joe9> fta :: FreeT f m a
11:18:47 <joe9> fx :: f (FreeT f m a)
11:18:55 <ski>   ffa :: FreeF f a (FreeT f m a)
11:19:17 <ski>   fx :: f (FreeT f m a)
11:19:18 <ski> yes
11:19:32 <ski> next, is to determine what the type of `...' here is meant to be
11:19:54 <ski> can you figure out that ?
11:20:01 <joe9> ski: http://codepad.org/36MSYXnf
11:20:15 <joe9>  m (FreeF f b (FreeT f m b)) ski
11:20:32 <ski> yep
11:20:36 <joe9> ski, I could write return . Free to take care of the m and FreeF
11:20:54 <ski> you've already used `fta' (to get `ffa') so you'll probably not need it again
11:21:31 <ski> and similarly with `ffa' (to get `fx')
11:21:32 * hackagebot apiary 1.1.2 - Simple and type safe web framework that can be automatically generate API documentation.  http://hackage.haskell.org/package/apiary-1.1.2 (HirotomoMoriwaki)
11:21:43 <joe9> ski, yes, make sense.
11:22:54 <ski> so the question then is how to piece together `f :: a -> b',`fx :: f (FreeT f m a)', together with the knowledge that `Functor f' and `Monad m', into `... :: m (FreeF f b (FreeT f m b))'
11:23:15 <ski> you'll probably also somewhere need a recursive call to `fmapFreeT :: (a -> b) -> FreeT f m a -> FreeT f m b'
11:24:07 <joe9> ski, I cannot figure out how to separate the `fx :: f (FreeT f m a)' into  the f and the FreeT portion.
11:24:18 <joe9> ski, I think fmap can help with that.
11:24:26 <ski> joe9 : that's what `fmap' does, yes
11:24:31 <joe9> ski, it should be some kind of fmap (fmapFreeT ..)
11:25:25 <joe9> fmap (fmapFreeT f fx)?
11:25:25 <ski>   fmap :: (x -> y) -> (f a -> f b)
11:25:25 <ski> so, setting `x = FreeT f m a', we would have
11:26:19 <ski>   fmap :: (FreeT f m a -> y) -> (f (FreeT f m a) -> f b)
11:26:19 <ski> so we can fill
11:26:19 <ski>   _0 :: m (FreeF f b (FreeT f m b))
11:26:19 <ski> with
11:26:19 <ski>   fmap _1 fx :: f y
11:28:59 <joe9>  fmap _ fx
11:29:00 <ski> hm
11:29:02 <ski> (s/b/y/)
11:29:03 <FreeFull> I'm wondering if I should make FreeF* stop highlighting me
11:29:13 <FreeFull> Or at least require an extra letter
11:29:14 <ski> you don't like being the highlight of the action ?
11:29:17 <FreeFull> =P
11:29:19 <joe9> ski, thanks. let me figure that.
11:29:19 <ski> joe9 : hm, i think you're right to want to use `return' here to get rid of the `m' in `_0 :: m (FreeF f b (FreeT f m b))'
11:29:20 <ski> so, restart
11:29:22 <ski>   _0 :: m (FreeF f b (FreeT f m b))
11:29:22 <ski> is filled by
11:29:22 <ski>   return _1 :: m (FreeF f b (FreeT f m b))
11:29:23 <ski> so
11:29:23 <ski>   _1 :: FreeF f b (FreeT f m b)
11:29:23 <joe9> ski: http://codepad.org/JV1P3Mjj  http://codepad.org/Z9tSbP4g
11:29:34 <joe9> ski, thanks. I think I get it.
11:29:34 <joe9> ski, let me try it from now on.
11:29:34 <ski> this now looks closer to
11:29:34 <ski>   fx :: f (FreeT f m a)
11:29:34 <ski> joe9 : ok
11:29:45 <t7> @hoogle [Maybe a] -> [a]
11:29:46 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
11:29:46 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
11:29:46 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
11:29:58 <ski> ok, continuing as you have indicated, we fill `_1' by
11:29:58 <joe9> ski, got it: http://codepad.org/kZ9o0Ge7
11:30:38 <joe9> ski, thanks a lot.
11:30:38 <ski>   Free _2 :: FreeF f b (FreeT f m b)
11:30:38 <ski> so
11:30:38 <FreeFull> Bah
11:30:38 <FreeFull> That's it
11:32:49 <ski>   _2 :: f (FreeT f m b)
11:32:50 <ski> surely ?
11:32:54 <Jefffrey> Hello
11:32:54 <ski> helllo Jefffrey
11:32:54 <joe9> ski, I got it: http://codepad.org/RMOSQgxo
11:32:54 <semigroup> I'm looking for a pretty printer that will let me align text against the right-hand side of a fixed width area. Can anyone point me to one?
11:33:05 <joe9> ski, did I do something wrong?
11:33:05 <bajtek> damn that's a long user list
11:33:29 <Jefffrey> here
11:39:29 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org'
11:39:29 --- topic: set by glguy on [Thu Sep 25 17:55:19 2014]
11:39:29 --- names: list (clog antoniy falafel merijn Philonous hexagoxel esteweig SwashBuckla Guest27506 d_k agumonkey npcomp_ sordina3 callumacrae KorriX rs0 mjrosenb infinity0 hiptobecubic nulpunkt povman slashus2 seveg Rutger` ValicekB plhk abh Longlius davean bajtek Cathy thorkilnaur adlan robbert semigroup Jefffrey MuffinMan` heurist coiler3 zenzike alethea JagaJaga sebhoss ionum` jackhill dflemstr peder DrSkyLizard milessabin defanor tessier gseitz cognominal `micro_ koniiiik)
11:39:29 --- names: list (kosmikus_ ybit Zekka krakrjak Fuco numberten PDani__ bcoppens angerman JPohlmann arrdem neena kav Phillemann cfloare howard Guest792 rak[1] frogpunc seangrove stbuehler marchelzo_ japesinator florent_ totemizer sm_ ldcn_ osa1__ yqt kafi pantsman- ioanel Platyp Frivillig hauzer RchrdB narendraj9 Total_1mmersion eikonos zanchoPa1sa OlegYch noctux umib0zu Javran xenog Joefish anders0 altphi HugoDaniel mp_ chaosmasttter _Vi vili Hijiri paperManu solrize lnostdal)
11:39:29 --- names: list (rossberg Th0mas mada felixsch Guest46818 mawuli Starfire zrl mietek torpet BrianHV peddie rohitvarkey sithrak belst conehead comma8 otterdam totte fall_ aarvar Tiktalik dario Haskellfant oberste1n blast_hardcheese aseidl Ferdirand Floyd_ sritchie codehero hopnotch ephemeron yaopo Boreeas AlainODea_ lpaste dmilith edlinde__ kjanosz spion ij- l3dx joshsz Hugglesworth greymalkin bcarrell dyreshark liuw averell Spaceghost alanz ikkebr ggherdov mimi_vx idnar segmond)
11:39:29 --- names: list (wto_ Nickeeh shelling_ SaBer_ pii ps-auxw blicero hegge pjdelport PHO joefiorini_ lahwran casual_ stephenmac7_ dino_joel pmarreck zorg24 pimlu_ lambdabot mithsv dkua teeteewhy_ hellschreiber_ int-e_ Ruffwind Bigcheese_ tismith_ seanparsons joedevivo hyPiRion liff MitchellSalad dispersed jonrh KitC javex_ ayertienna supki_ tawm SLii ndrei_ Igloo_ farnsworth_ dlackty_ integral_ pfoetche1 T_X_ def- rblackwe_ S11001001 edran_ Vbitz_ m_george sshine_ michaelpj)
11:39:29 --- names: list (Jaxan_ mirsal Raynos anders^^_ kiniry1 bgyss zalami_ irrequietus_ Guest6003 Kobata_ fergusnoble staffehn_ wjt tattsun` eazar001 pavonia spopejoy Stratege___ bernalex tov mecalopo1 McManiaC thunderrd marienz it0a univerz kshannon ckw sofancy_ alpounet Gurkenglas_ jxm_ C4Cypher happy0 ocharles_ yumike meandi_2 etabot waynr srbaker sxn tobik derekv ampharmex gratimax_ VBlizzard Guest6058 vincom2_ pharpend_ s00pcan_ BeardedCoder dnkndnts cojy `0660_ dju jstolare1)
11:39:29 --- names: list (alphonse23_ Excurio franka_ okic_ pyon julienXX Kron jlamothe_ clog_ Revenrof Arahael_Twin emma_ xinming_ raek_ dmbaturin_ mjs2600 Hemamorphy mgomezch_ jaspervd1 zerokarm1left taktoa_ ToRA_ godel mach Miciah moy Martty_ Guest8900 PierreM_ DanToml_ benmachine koninkje1away lattenwa1 badi`` ormaaj_ SegFaultAX Fusxfaranto_ dsantiag_ Jellydog oldmanstanley___ yusukesuzuki jabbslad_______ mthvedt mike4 haskelln1obie pikhq rodlogic_ sea-gull ReinH eristic arianvp__)
11:39:29 --- names: list (srcerer_ asmyers Plasmastar mrb_bk dixie_ werdna_ Blkt_ zph TDJACR Guest729 rufs heyj creichert cfricke_ Mateon1 arianvp_ sweeney stiell_ aupo_ johtso_ expo873_ suvashz bgamari- puzza007 MMuse_____ joe9 cwraith Durz0 ddellacosta jaffachief OscarZ_ jumblerg caumeslasal1 sinelaw agjacome phreedom eb4890 jasonjckn seschwar Netpilgrim tech2_ emanuelz hiroakip vjeranc athan tomboy64 Mon_Ouie wikikiwi Eagle_Erwin MoALTz_ tsani Klumben trism nexion Zorg Involuntary)
11:39:29 --- names: list (kazimir42 folone jetho lennartl dhil martintrojer stefan_1_|Work j201 ceii vanila mornfall umbriel john_not_jenny n0n3such darkbolt bcap_zZz ulfdoz XniX23 ZioCrocifisso Rakkin petersr Yxven myfreeweb edon mystor Polarina indiagreen Betal netj charlie laar Darkflux nschoe nominolo xahry jomg netogallo Takle twanvl_ banister Yuras _ashbreeze_ govg mitochon vrdhn bjz autochthon jdegoes chef__ jedai ixti fizbin kidnapped_robot eacameron2 Paprikachu drbean)
11:39:29 --- names: list (IlNominePatre Discovery LeoTal kadoban dgpratt Church- obb klao titusg bennofs saep germ13 Kaidelong reizuki__ ompaul Noldorin Jackneill oleo sivteck exlevan blume RaceCondition ttuegel damncabbage Khisanth raichoo psii Fubar^ Vq nerium jpll manfoo7` glaebhoerl lecoeus Zeitgeist_ renekooi vlatkoB_ foreignFunction Reite komarov wilfredh madjestic conrad__ krobelus_ dmwit___ dmwit__ NightRa zwer Boney_ lukaraamu malllle shesek darthdeus silver marr brushbox)
11:39:29 --- names: list (bitonic phyrex1an ChristianS SoupEvil fyolnish Shin-LaC ht__th shepheb whaletechno xificurC hackagebot joneshf-laptop besenwesen SCHAAP137 lykkin amiri_ shigosei purefn qrada Pip ZettaBlade jordanl rhodesd deevus vimpire hiratara orbital maaku PatrickRobotham mauke myk267 otto_s_ eisbehr Glavata pa3ce stefan_1 cyphase shanse xplat dcoutts Ralith conal mceier chrisdotcode apaku pks ToTheInternet reddodgem bam365 MitchW mgsloan seliopou predator117 GGMethos)
11:39:29 --- names: list (SamuraiMark anannie seafood cleamoon_ mungojelly Azel ezrios maxcan isomorphic heaumer_ bbloom knyppeldynan Mortomes plutoniix listrophy FreeFull kwantam nakal marens Brando753 Oxyd vmeson chrisdone haasn amf WraithM Zenith77 fabe thetallguy SparkySparkyBoom jzl zyla mountaingoat noam so wtw albeit Plastefuchs krgn_ junmin brandonw da-x _5kg billymeter ens BlastHardcheese Gonzih Cale Ranis cbou Livadi0 jle` eevar eyck stepcut dh stepkut sbauer322 fqsxr magicman)
11:39:29 --- names: list (Oksana amatsu Soft joelteon magicflakes zmthy dgonyeo stomp brixen bananagram Belgarion0 vladan ortmage caasihuang_ Ornedan ajcoppa haroldwu wormphlegm shiona joefiorini andreass ljhms vlopez nesqi jcurbo keaml JRoberts ryu91835 sbahra exio4 himikof Draggor o0oo0o zinfandel Sgeo Mokosha orion zxq9 Freemason sssilver_ fnordbert boot13 ThatOtherPerson davidfetter oliffea_ gienah renzhi fiatjaf laktech codeburg LeaChim blenny phaskell dgvncsz0f Enigmagic zomg)
11:39:29 --- names: list (byorgey tv jophish enomies heikkih cdk pp^ tyconnell bonobo mjo pantsman meretrix Kabaka ludamad sinopeus vital gx^ sunfun simonnn jchia1 Riviera Lacriatch saati_ wchun neptunepink _rgn Nik05 d-snp sipa Number2 theshadow apo MrWoohoo zariuq juhp RevJohnnyHealey piskrist dibblego slobo SuperTux88 LordDeath raid Cerise l3kn nwf xandaros vermeille tristero Lutin` sviterok connerb _ikke_ andbroby tg bjornars1 TrafficMan Talryn banyan Svedrin eL_Bart0 TheMoonMaster)
11:39:29 --- names: list (ion cmn vobi hpd sleepynate somenick Draconx pdxleif notdan mathu ktosiek mami vsayer_ twopoint818 acharles drdo Edoxile Jo-haN Vorpal petterw_ usr ayako Rembane HylianSavior saiam paz__ kakos_ matthew-_ taruti s4msung_ ozzymcdu1f tero-_ frontend1oader butyoudonot gargawel funrep XMunkki brackets senseibaka_ tnks noidi hc jlouis_ wizonesolutions mitu Desoxy_ Xorlev cjheath gregburd hguux_ osfameron leifw spacebug1 wting_ nmashton xaimus_ divyanshu Guest53095)
11:39:29 --- names: list (ilmig_ ixian8 teehemkay btc_ ehamberg cyanoacry n1ftyn8 blindscreen c9sould_ edwardk bkolera LQDHelium sclv cstrahan lacrosse__ sross07 nick1234abcd shouya mno2 kirjs______ akahn si14 serjeem_____ dutchie drewdavis_ dstockwell Sorella joefiori_ larrytheliquid__ jroesch___ flux L8D Benzi-Junior ma82 ocfx Sornaensis oconnore David sujeet dagle dropdrive DanC_ zeiris coeus_ seanaway augur fikusz imalsogreg Na6hu7Ud boris`` kkh robotbrain ahihi DrCode joneshf)
11:39:29 --- names: list (chelfi juri_ dr__ inr MagBo thoughtpolice Meeh harski1 u_ Matrixman_217 gnomnain` jmcarthur tdammers louisjb __jim__` dreixel Pucilowski c74d felixn JamesJRH royadav spwhitt ninzine rejuvyes- tolt otulp linduxed Yarou thomas mitchty wagle srhb channel_t klarrt kmicu horlicks_ Denommus intrados lifenoodles stojic r444 jnoah swook bgamari cursork mcbonz wires gniourf nemesit|znc lericson rudi_s itsmonktastic cosmicexplorer Internet13 only_the_bear jakutis)
11:39:29 --- names: list (bel3atar sdx23 mikeplus64 Reiser melter idoru _flow_ delhage MK_FG LnL luigy pyrtsa wjlroe pnielsen sohum ]OLI[ theanalyst thirsteh Guest17603 gws sellout jameseb christia` milli` liyang Walther hmax_ mankyKitty korpse___ Jaak shelf zxtx tumdedum henrikhodne profil naiyte Elite6809 lamilami mrowe_away henk dj_ryan d3lxa AntiSpamMeta Jello_Raptor shennyg____ biscarch Saizan raphie arun rom1504 aloiscochard rola flebron Preyer ircbrows- paintcan DarkCthulhu k00mi)
11:39:29 --- names: list (ZsoL dolio YayMe nyuszika7h xpika klarh Dykam goldfire RayNbow`TU albel727 burp Lindrian eamelink lieven Jonno_FTW lycide CindyLinz dmead jlyndon ninegrid Quashie Forkk_ Artpicre Nimatek thetallguy1 bydo janne keltvek Axman6 davidthomas statusbot jedavis miasma Nivim mgaare otherchas earthy gds diprosopus catsup comboy flyingfisch unsymbol keko-2 Maxdamantus Fullma sw1nn uber Cr8 estewei_off Adeon Chousuke aleator iteratee m4farrel petercommand bsmt opqdonut)
11:39:29 --- names: list (mads- ciaranm Kruppe ad Sonderblade Wamanuz Farow ob chriswk____ _d3f aristid_ superjudge aristid anry kloplop321 danking thamz jrp6 andyt rfw tarcwynne__ jdeeburke ZucchiniZe texasmynsted nathanic ibid etrepum jonsterling lohkey Taneb qsuscs ft bmuk wollw ccasin seagreen- Tene maurer zoglesby jlewis carter WzC iross xeno skarn cjwelborn akurilin finnrobi canta Natch Fuuzetsu perrier quaestor1 tromp_ bolmar martingale Eliel monochrom lenstr kalz marko)
11:39:29 --- names: list (fuziontech____ joeytwiddle StoneToad Gothmog_ V3ct0r larsen jrslepak noddy hamishmack monsieurp ByronJohnson qzzx yorick antinode masse cschneid k4r1m mrpantoufle Nshag adamse marvin-hh jayne przembot lucs parallel21 Profpatsch Keel zz_rabisg luz1e avdi ousado helgar mak` __main__ bjorkintosh _aegis_ ben__ jlewis_ ChongLi silasm Xack mephx kipras glowcoil FireFly vikraman dlundy hpc mindCrime_ funrep_ mendez_ dowski__ julmac CosmicRay Deewiant Nanar ernst)
11:39:29 --- names: list (Aquana ski seubert Kinnison amontez yano brisbin obiwahn zeroskillor cin alang mattp_ fvt \q metaf5 lurker6 jcp statusfailed geal relrod iron_houzi Twey ThePhoeron capisce Yawgmoth adimit alinab Intensity theorbtwo flori ClaudiusMaximus npcomp Tesseraction chirpsalot pqmodn_ tridactyla pingu Zariel bjobjo nisstyre Scorchin Transfusion Athas Liskni_si ziman mgomes yukonjack rbocquet troydm rieper jrib bind sivoais NikolaiToryzin hongminhee qwandor sprang)
11:39:29 --- names: list (MiracleBlue CARAM_ platinuum jzelinskie lyxia mikeizbicki jang andrewsw dqd smart_ptr stelleg stass prinsen joehh naudiz elfangor betawaffle vukcrni gbarboza timpani TakSuyu rmunroe petantik agrif wjm jasu0 `bps CoverSlide andreypopp_ emmanueloga mbrcknl asabil zq qz cryon adadad sbrg diginet Hodapp dsfox1 joeyh zymurgy Kneiva levi edk ryanakca jmct kalail_ bra sorind tekacs DarkFox frawgie_ lpsmith dehflingus tazjin tm512 SHODAN Willis inuoppai Baughn _dyrim)
11:39:29 --- names: list (johnw eikke mortberg gandr kandinski saurik pieter machineslearn asm89 Reyu annulus cowtown c-rog bergmark karls kini tromp eyenx joehillen koala_man TallerGhostWalt AshyIsMe Watcher7 eyem sunnavy ahf lb5tr malglim barrucadu fall` newsham theDon Rylee coconnor xnyhps bbastian- Razz agundry elgot ndeine DustyDingo mrkishi tlevine igniting cods dhrosa elij bentley obcode kaol Drezil cinimod @ChanServ tomaw cpa_ Ke noplamodo gridaphobe mrd hsc mechairo` lolocaust)
11:39:29 --- names: list (abc56889 Hafydd bitemyapp kloeri zebr tych0 opto DigitalKiwi kgadek henrixh honza aleator_ swen ivan` phadej qr42 solarus absence mero knyon Harbinger Hardolaf owa joachifm GaveUp hvr yeltzooo tstc Pad^ tassmjau phaazon Licenser mlen ggreg mrshoe benbangert claudiyoh irssi asjo mp roo natte clementd lispy DanZimm fds4345 cow-orke1 cynick [swift] sajith danneu stvc _br_ bvad kragniz shmookey amiller grohne simpson poucet Clint Laney pharaun Ulrar lokydor)
11:39:29 --- names: list (Freundlich cross ThreeOfEight mandu ephess scopedTV adarc therealklanni Antoine59 ParahSailin_ wayne chasecal1 sgronblo sddhrthrt M-ou-se mixi futureperfect edwtjo fold Ezku joshc hiredman Tehnix mmaruseacph2 ido drewr luite dawik boegel|work|afk tomejaguar_away Dashkal Gracenotes myme jrw bens owlglass2 dogmaT_ bbee lassulus bastian__ Kaini jix kaiza ivoscc dustinswan solirc friden qtplatypus Dodek JZTech101 runde cjay Ptival spindas gidogeek deni benzrf)
11:39:29 --- names: list (davesilva nafis joe_k Bane^ bartavelle honkfestival Phlogistique shutdown_-h_now Laquendi indigo go|dfish dan64 photex Someguy123 shapr arch_ froztbyte dunj3 dilinger s_e iota_ schlumpi geekosaur majoh pi8029 dpn` jonathanj monty eagleflo dp_wiz_ klugez fryguybob spaceships Logiar zpconn__________ deavid yukko dv- pygospa acfoltzer tippenein td123 mgregson)
11:40:23 <spaceships> i've taken a Semiring declaration, and made it monadic. So roughly: Monad m => Semiring m s where .. [monadic semiring functions]. what should I call it? I know it's not properly a semiring anymore ;)
11:41:06 <davean> spaceships: uh, whats its properties?
11:41:42 <spaceships> ... where; zero :: m s; one :: m s; add :: s -> s -> m s; mul :: s -> s -> m s
11:42:41 <ski> spaceships : perhaps it's a semiring in a Kleisli category ?
11:43:39 <joe9> ski, I cannot seem to factor out return . These were the different versions I tried: http://codepad.org/fgIv42hp
11:46:08 <joe9> ski, this is the best I can come up with: t
11:46:18 <ski> joe9 : oh .. i just mean to factor it out of the `case', nothing more
11:46:20 <joe9> http://codepad.org/3Eycwuk4 ski.
11:46:51 <ski> joe9 : `case ... of X -> return ...; Y -> ...' is equal to `return (case ... of X -> ...; Y -> ...)'
11:47:09 <joe9> ok, thanks. ski.
11:47:15 <ski> (at least ignoring some partial issues)
11:48:17 <joe9> ski: http://codepad.org/gtzv3UcZ better?
11:48:17 <ski> (where by "issues" i mean in case the first `...' doesn't terminate)
11:48:45 <ski> (but presumably you're not that interested in preserving behaviour for that case)
11:49:21 <ski> joe9 : yes
11:49:33 <ski> now, do you see what further simplification you could do ?
11:50:13 <ski> joe9 : aside, you can just as well say `Pure a -> ...' instead of `(Pure a) -> ...'. ditto for `Free'
11:50:24 <joe9> ski, ok, thanks.
11:50:24 <jonthn> hello, I was wondering if "./configure ; make binary-dist" basically is the steps to build bindist (such as 'https://www.haskell.org/ghc/dist/7.8.3/ghc-7.8.3-i386-unknown-linux-deb7.tar.xz') or is there a special to build such bindist ?
11:50:40 <ski> (there's no rule that says that patterns always have to be enclosed in brackets)
11:50:58 <jonthn> also would a "stage1" suffice for building a final working ghc ?
11:51:11 <joe9> ski: http://codepad.org/mOTiUapP
11:51:41 <ski> joe9 : well ?
11:52:01 <joe9> ski, can I simplify even more?
11:52:10 <ski> yes
11:52:29 <ski> (FSVO "simplify" .. but i would consider it an improvement in readability)
11:52:35 <joe9> ski, really? oh, ok.
11:52:50 <joe9> ski, then I would skip on further simplification.
11:53:10 <ski> the code would become shorter, and easier to read
11:53:23 <ski> (not just the latter, i.e.)
11:53:51 <joe9> http://codepad.org/ULa5NqSC is how the Control.Monad.Trans.Free does it.
11:54:17 <ski> yeah, i hadn't quite that in mind (yet, at least :)
11:54:30 <joe9> but, I guess my version is more understanble to me. so, I will leave it at this.
11:54:39 <ski> just a version somewhat shorter (and imho, more readable) than your current one
11:55:06 <ski> it's fine if you want to stay at one version, which you feel is more readable to you
11:55:19 <ski> i just want to show you the options and the possible refactorings
11:56:38 <joe9> ski, What is the further simplification? I would love to learn.
11:56:55 <ski> do you want a (rather large, in comparision) hint ?
11:57:00 <ski> or a smaller one ?
11:57:06 <ski> or should i just tell you ?
11:57:41 <joe9> ski, whatever is easy for you. I will try if you could hint.
11:58:28 <ski> @pl fta >>= \ffa -> return $ blah ffa
11:58:28 <lambdabot> blah `fmap` fta
11:58:31 <ski> there's the hint
11:59:17 <ski> (not sure why it decided to use infix `fmap', but ok)
11:59:20 <joe9> ok, thanks.
12:00:12 <ski> generally, it's a good idea to learn to spot the above pattern (or in its corresponding `do'-syntax form)
12:00:49 <ski> @. pl undo do {ffa <- fta; return $ blah ffa}
12:00:50 <lambdabot> blah `fmap` fta
12:01:37 <joe9> ski: http://codepad.org/3PNv6qq4
12:01:44 <joe9> ski, will use fmap thanks.
12:07:38 <bajtek> can I somehow disable those "logged in/logged out" things from the web client?
12:08:52 <ski> bajtek : i dunno. i think several standalone IRC clients can, though
12:10:41 <Frivillig> What is wrong with people unable to keep up a server with only 100 k users?
12:11:13 <sivteck> ask in #freenode
12:11:55 <ski> Frivillig : possibly DDoS, not sure
12:15:20 <joe9> ski: http://codepad.org/4RzoTc75 For using fmap, I had to add Functor m to the definitions. Is it safe to assume that all monads (Monad m) are functors too?
12:15:34 <joe9> ski, on line 32 is the Functor m
12:17:52 <bajtek> joe9 : yes, and 7.10 should enforce that
12:18:07 <ski> joe9 : oh, i forgot to say that before
12:18:16 <bajtek> IOW if you encounter a Monad that's not a Functor, you're entitled to bash its author with an fmap stick
12:18:18 <joe9> http://codepad.org/JsMIQvVO renamed fmapFreeT' to fmapFreeF
12:18:31 <joe9> ski ^^
12:18:52 <ski> joe9 : `liftM' would possibly be better to use here than `fmap'. though they are required to be the same, in cases both exist
12:21:06 <ski> joe9 : if you use `liftM' instead of `fmap' (for the thing you replaced `(>>=)' and `return' by), then you can avoid the `Functor m' constraint
12:21:34 * hackagebot stm-containers 0.2.2 - Containers for STM  http://hackage.haskell.org/package/stm-containers-0.2.2 (NikitaVolkov)
12:22:22 <ski> joe9 : oh, and i'd expect `fmapFreeF :: Functor f => (x -> y) -> (Free f a x -> Free f a y)', so seeing a different signature for something named `fmapFreeF' looks strange
12:22:27 <joe9> ski, makes sense.
12:23:27 <ski> joe9 : though .. what you called `fmapFreeF' could be *composed* out of what i would call `fmapFreeF', together with another operation you already have
12:24:53 <joe9> ski, agreed. fmapFreeF is a wrong name. probably, rename it to fmapFreeTF
12:25:35 <joe9> or, FreeFFreeT or something like that.
12:28:05 <joe9> ski: http://codepad.org/G3IGBE8m
12:30:42 <ski> joe9 : `FreeFT' or `FreeFFreeT' sounds reasonable
12:31:01 <joe9> ski, ok, thanks.
12:31:34 * hackagebot cases 0.1.2 - A converter for spinal, snake and camel cases  http://hackage.haskell.org/package/cases-0.1.2 (NikitaVolkov)
12:31:39 <ski> or even
12:31:46 <ski>   fmapFreeT'
12:36:20 <joe9> ski, thanks.
12:36:34 * hackagebot neat-interpolation 0.2.2 - A quasiquoter for neat and simple multiline text interpolation  http://hackage.haskell.org/package/neat-interpolation-0.2.2 (NikitaVolkov)
12:36:36 * hackagebot process-streaming 0.6.5.0 - Streaming interface to system processes.  http://hackage.haskell.org/package/process-streaming-0.6.5.0 (DanielDiazCarrete)
12:37:01 <sinelaw> I need a set with O(1) extraction of an arbitrary element - a la List head
12:37:12 <sinelaw> arbitrary = i don't care which
12:37:40 <Polarina> sinelaw, a list?
12:37:56 <sinelaw> Polarina, a list allows repeating elements
12:38:05 <sinelaw> I need a set
12:38:46 <kadoban> sinelaw: Can you be more specific about what operations you need to do, and what bounds they need to have? I don't understand what you mean about an arbitrary element.
12:40:27 <nerium> ski: I’m back :) I did some reading regardning the smart constructor. Would it be possible to maybe use the InBounds example they have provided in the code?
12:40:29 <sinelaw> kadoban, operation like someElem :: Set a -> Maybe a but unlike Data.Set.findMin O(log n), it should be O(1)
12:41:49 <sinelaw> kadoban, arbitrary was a bad choice for a word. I mean that I don't care which  element you get
12:41:55 <sinelaw> it could be any element of the set
12:41:59 <kadoban> sinelaw: Just a set based on any balanced binary tree will get you that, you can just take the head of the tree if you want.
12:42:19 <sinelaw> kadoban, right, so which package/type provides such a tree?
12:42:29 <kadoban> sinelaw: Pretty much any implementation really...just most don't expose something like that, because it doesn't sound too useful in general.
12:42:50 <kadoban> sinelaw: Well...I don't know of one that exposes that really, let me look I guess, maybe there's one you can trick into it.
12:42:56 <sinelaw> that's the problem. I would like to use one of the standard ones
12:43:58 <sinelaw> hmm I think I can simplify that algorithm to not require the set at all, just remember some element. thanks though.
12:44:47 <kadoban> sinelaw: Alright. I mean yeah, it's just a quite strange thing to require from a set I think, so I'm not seeing one. /maybe/ you can do like safeHead . toList on Data.Set? That's probably not guaranteed to be O(1) though.
12:44:53 <ski> joe9 : yw
12:49:14 <chrisdone> ski: https://github.com/chrisdone/lucid \o/
12:51:25 <ski> nerium : use it for what ?
12:51:29 <benzrf> just import the axiom of choice :-)
12:51:46 * benzrf hides from mathematicians who know how it actually works
12:51:48 <nerium> ski: Prevent the mixed usage of Succ and Pred
12:52:00 <nerium> ski: I only want to allow the use of eather Succ or Pred
12:52:19 <nerium> would it be possible to use the InBounds example for that?
12:52:20 <ski> chrisdone : for a short while i was thinking that was related to the dataflow language Lucid :)
12:53:23 <chrisdone> ski: nope, this is just lucid the small haskell package =p
12:53:44 * chrisdone shakes fist at world for stealing all the good names
12:54:38 <ski> sinelaw : hm, perhaps a heap-based representation of a set ? -- also, i think it's possible to make a wrapper around an implementation of `Set' that caches (or stores separately) the min element, so you get `O(1)' access (but not necessarily removal)
12:55:44 <ski> nerium : well, that was more or less the point of my earlier suggestion of using a GADT. or was it koniiiik i suggested it to ?
12:55:45 <sinelaw> ski, any reasonable set implementation could do this. anyway I just got rid of this set and replaced it with a Maybe
12:56:03 <ski> nerium : perhaps you want to check out that discussion
12:56:07 <sinelaw> heh, Maybe a is a set of at most one element - that has this feature too!
12:56:26 <ski> yeah, but now `removeMin' is impossible
12:56:27 <nerium> ski: I’m not sure. I can’t check the log in my current client for some reason :/
12:57:11 <ski> nerium : try <http://tunes.org/~nef/logs/haskell/14.11.15> ?
12:58:06 <chrisdone> http://ircbrowse.net/day/haskell/today =p
12:59:55 <sinelaw> :)
13:00:30 <ski> chrisdone : yeah, but i haven't that URL memorized :)
13:00:43 <sinelaw> chrisdone, cool http://ircbrowse.net/nick/sinelaw
13:02:38 <billy_> if i am defining a function, i am having trouble determing the different between 'aFunction [x] =' and 'aFunction (x:xs) =' why cant eht second function be 'aFunction [x:xs]' ?
13:03:01 <mauke> because [x] is a list of a single element
13:03:10 <chrisdone> sinelaw: what happened in 2011? ;)
13:03:11 <mauke> and [x:xs] is a list of a single element, which is a list itself
13:03:18 <mauke> (whose head is x and tail is xs)
13:03:19 <sinelaw> chrisdone, haha
13:03:39 <mauke> in fact, [x] is sugar for (x : [])
13:03:49 <mauke> so [x:xs] is syntactic sugar for ((x : xs) : [])
13:03:51 <billy_> ohh, so [x:xs] gives me the head of xs, but (x:xs) gives what?
13:04:00 <mauke> huh?
13:04:12 <sinelaw> chrisdone, I guess second year of electrical engineering
13:04:17 <kadoban> billy_: That question doesn't seem to make sense, look again?
13:04:43 <billy_> if i want a list from xs made of the head of xs, i would do [x:xs], right?
13:04:59 <chrisdone> =)
13:04:59 <mauke> what?
13:05:02 <ski> billy_ : `[x:xs]' matches only singleton lists containing one non-empty list. otoh `x:xs' matches any non-empty list
13:05:19 <sinelaw> chrisdone, oh wait, that's off by five years! I'm getting senile
13:05:19 <mauke> "a list from xs made of the head of xs"? what does that mean?
13:05:27 <spaceshi1s> :t \[x:xs] -> x
13:05:28 <lambdabot> [[t]] -> t
13:05:37 <chrisdone> [x] = x : []
13:05:37 <chrisdone> [x:xs] = (x : xs) : []
13:05:42 * ski . o O ( "Off with their heads!" )
13:06:01 <mauke> a list is either [] or a pair (of an element and another list)
13:06:08 <billy_> if xs is [1, 2, 3], then x:xs gives 1, thats what i meant
13:06:13 <sinelaw> you got me wondering now...
13:06:13 <chrisdone> oops actually
13:06:18 <mauke> billy_: what
13:06:19 <chrisdone> [x:xs] = (x : xs : []) : []
13:06:21 <chrisdone> there we go
13:06:28 <chrisdone> sinelaw: hm =)
13:06:29 <ski> > let testing (x:xs) = x in testing [1,2,3]
13:06:30 <lambdabot>  1
13:06:39 <kadoban> billy_: No.  Maybe you're misusing 'xs' in that sentence though.-
13:06:52 <mauke> billy_: if you match [1,2,3] against x:xs, then xs is bound to [2,3]
13:06:58 <billy_> oh man, i've just realized what i was saying
13:07:25 <Igloo> Note that [1,2,3] is the same as 1:(2:(3:[]))
13:07:49 <chrisdone> there should be an @unsugar like @undo
13:07:55 <mauke> [1,2,3] is a pair of 1 and (a pair of 2 and (a pair of 3 and []))
13:07:56 <chrisdone> that'd be cool
13:09:17 <kadoban> mauke: Using the word 'pair' in there seems a bit confusing :-/
13:09:29 <mauke> tuple?
13:09:32 * ski suggests s/pair/pare/
13:09:53 <kadoban> Tuple seems even worse, heh.  Cons? But if they know that word, they probably already understand, so I dunno.
13:10:10 <mauke> that's literally how lisp builds the trees it calls lists
13:10:16 <ski> "non-empty list" also works
13:10:18 <chrisdone> filthy lisper!
13:10:31 <mauke> in haskell, the difference between (:) and (,) is spelling. and that annoying type system
13:10:35 <kadoban> Right, but haskell tuples don't work like that, so it just looks kinda wrong
13:10:37 <mauke> :-)
13:10:37 * chrisdone fetches mauke's coat
13:10:53 <mauke> but it really is a pair underneath
13:11:09 <mauke> (:) a b
13:11:12 <mauke> a constructor with two fields
13:11:23 <ski> mauke : ZP^H^Hmaterial-set-hugger :)
13:11:25 <sinelaw> you know what I like about ruby?
13:11:36 * hackagebot postgresql-binary 0.3.0 - Encoders and decoders for the PostgreSQL's binary format  http://hackage.haskell.org/package/postgresql-binary-0.3.0 (NikitaVolkov)
13:11:40 <chrisdone> in before 'nothing'
13:11:45 <ski> (um, i suppose s/ZP/ZF/)
13:11:47 <sinelaw> the empty string
13:11:59 <kadoban> Yeah, maybe it's not that wrong, nevermind, heh.
13:12:15 <sinelaw> chrisdone, ;)
13:12:40 <chrisdone> sometimes i feel weird using single quotes on a whole word
13:12:49 <mauke> does ruby detect undeclared variables at compile time?
13:12:50 <ski> (the point being that claiming `a : b' is a pair, you now have to claim that a pair is not an empty list, as opposed to a pair not being comparable to an empty list)
13:12:59 <chrisdone> programming syntax hath wrought wrongness unto me
13:13:18 <mauke> chrisdone: use more perl or javascript or sh or something
13:13:18 <chrisdone> mauke: ruby has a compiler?
13:13:28 <mauke> chrisdone: what language doesn't?
13:13:32 <chrisdone> ruby?
13:13:36 <mauke> no
13:13:36 <sinelaw> mauke, it has an interpreter
13:13:39 <sinelaw> with dynamic binding
13:14:02 <sinelaw> so just as it's about to evaluate something, it figures out what it might be, unlike python
13:14:03 <mauke> sinelaw: I'm pretty sure the interpreter doesn't work on program text
13:14:11 <sinelaw> mauke, that's true
13:14:16 <sinelaw> but it isn't "compilation"
13:14:26 <mauke> why not?
13:14:29 <merijn> Yes it is
13:14:31 <chrisdone> oh-oh, we're getting into a pornography discussion
13:14:32 <sinelaw> it can't even tell if a variable refers to this or that
13:14:35 <merijn> ghci compiles to bytecode
13:14:52 <mauke> it converts the source code into an internal form (that is then interpreted or whatever)
13:14:52 <merijn> or wait, are we in some off topic language? :p
13:15:05 <mauke> converting from one language to another is my definition of "compiling"
13:15:05 <sinelaw> anyway, whatever. it sucks regardless
13:15:07 <chrisdone> http://en.wikipedia.org/wiki/I_know_it_when_I_see_it ← this discussion
13:15:17 <merijn> mauke: Word
13:15:30 <merijn> mauke: The term "transpiler" pisses me off to no end...
13:15:36 <mauke> merijn: ^5
13:15:41 <merijn> Who the hell comes up with this BS >.<
13:16:06 <spopejoy> Wondering about idiomatic thread mgmt in Haskell. In my code, like 'forever $ do', in place of 'forever' I have a function that takes Either String (), such that Left will exit with message, Right will recurse. Better, more idiomatic way?
13:16:07 <mauke> I know that in python a syntax error in the last line of a program will prevent any of it from being run
13:16:12 <mauke> but an undeclared variable won't
13:16:20 <mauke> but I don't know how ruby does it
13:16:20 * ski . o O ( "A compiler is a tool that analyzes the meaning of programs and generates programs in another language with equivalent meaning." -- Riastradh )
13:16:25 <merijn> spopejoy: monad-loops?
13:16:29 <merijn> @hackage monad-loops
13:16:29 <lambdabot> http://hackage.haskell.org/package/monad-loops
13:16:41 <chrisdone> this is what the french call “enculer des mouches”
13:17:15 <spopejoy> merijn: good stuff
13:17:47 <chrisdone> everyone knows a compiler tends to mean generating code for the OS or VM to work with, possibly aided by some runtime calls
13:17:57 <merijn> I have always been taught "compilers do language to language translation of source text", not even necessarily different source and target language. And all books I know use that same definition
13:18:13 <chrisdone> and that an interpter is generally some user-land software that interpets some code (be it text, ast or bytes)
13:18:15 <merijn> chrisdone: Define "generating code"
13:18:15 <vanila> a compiler can be source to source
13:18:22 <sinelaw> merijn, transpiler = compiler that targets a non-assembly, human-readable programming language
13:18:26 <ski> (and also "/Compilation/ is the analysis of a program's meaning, rendering the same semantics into another language.  A /compiler/ is a total function from programs to meanings.")
13:18:27 <merijn> vanila: Name one compiler that isn't source to source
13:18:32 <ski> (and "/Interpretation/ is the execution of a program given the state of the machine, either diverging or yielding a final answer.  An /interpreter/ is a partial function from programs and machine states (or simply machine states, if the program is a part of the machine state) to answers.")
13:18:35 <athan> The pile piler
13:18:37 <merijn> sinelaw: I know that, hence why it's a bullshit term >.>
13:18:42 <chrisdone> merijn: i'm trying to make a point about enculer des mouches here, you're making a strong case for it =)
13:18:55 <sinelaw> merijn, it's a short word for that long sentence.
13:19:00 <athan> It's piles piles on piles
13:19:07 <chrisdone> source code tends to mean something you can reasonably edit in your editor or write on a whiteboard
13:19:09 <merijn> sinelaw: A long sentence that has almost 0 content :)
13:19:20 <vanila> e.g. scheme macros are compilers that change scheme code (+ some macros) to scheme code without it
13:19:23 <merijn> chrisdone: I disagree with almost all of that sentence :)
13:19:27 <chrisdone> not assembly or bytecode that you would need a hex editor and familiarity with a compiler's internals
13:19:42 <merijn> Since when does assembly require a hex editor?
13:19:49 <chrisdone> merijn: that's okay, the programming community at large disagrees
13:19:56 <sinelaw> I agree with chrisdone
13:19:58 <Schluri> @pl kkp1 (x:y:xs) z = kkp1 (sortBy (comparing Down) (xs++[x-y])) ([x,y,x-y]:z)
13:19:58 * ski was channeling the 2007-06-19 entry "Concerning compilation and interpretation, and an interpretation of the compilation of confusion surrounding their meaning and execution" on Riastradh's blah at <https://mumble.net/~campbell/blag.txt>,<http://home.ccil.org/~cowan/blag.xml>
13:20:01 <lambdabot> kkp1 = fix (flip ap tail . (. head) . flip flip tail . (ap .) . flip flip head . ((.) .) . flip ap (((:) .) . liftM2 (.) (:) (ap (:) . flip flip [] . ((:) .) . (-))) . (liftM2 (flip . ((.) .)) .) . (. ((((sortBy (comparing Down) .) . flip (++)) .) . flip flip [] . ((:) .) . (-))) . (.) . (.))
13:20:01 <lambdabot> optimization suspended, use @pl-resume to continue.
13:20:05 <mauke> sorry, your C compiler generates readable asm, so it's not a real compiler
13:20:05 <merijn> chrisdone: There's plenty of sources that you can't "reasonably edit or write" :)
13:20:12 <merijn> chrisdone: Exhibit 1: XSLT :p
13:20:14 <Schluri> @pl-resume
13:20:17 <lambdabot> kkp1 = fix ((`ap` tail) . (. head) . flip flip tail . (ap .) . flip flip head . ((.) .) . (`ap` (((:) .) . liftM2 (.) (:) (ap (:) . flip flip [] . ((:) .) . (-)))) . (liftM2 (flip . ((.) .)) .) . (. ((((sortBy (comparing Down) .) . flip (++)) .) . flip flip [] . ((:) .) . (-))) . (.) . (.))
13:20:26 <sinelaw> mauke, qualify it by saying "not assembly or bytecode"
13:20:29 <nerium> I’m trying to get this code to run, but no luck
13:20:30 <nerium> https://gist.github.com/oleander/73f8e7f678eac6a2cf60
13:20:39 <nerium> What I’m I missing?
13:20:42 <sinelaw> lambda bot has a point
13:20:43 <sinelaw> or two
13:20:50 <kadoban> Or 50
13:21:09 <mauke> nerium: "In the expression: print (add - 1 - 1)"
13:21:09 <chrisdone> merijn: sure, that just adds to me point, of course
13:21:12 <merijn> nerium: Weird ass edge case of -1 :)
13:21:29 <chrisdone> the difference between a compiler and a "transpiler" depends on how human-consumable the output is
13:21:40 <mauke> chrisdone: I don't think that's true
13:21:42 <merijn> nerium: Note the space in the error message
13:21:46 <chrisdone> while you can go and read the tens of thousands of ASM lines that C generates
13:21:51 <chrisdone> you probably won't unless GCC is buggy
13:21:54 <joe9> I understand that fmap :: (a -> b) -> f a -> f b. Is there a function to do: f (a -> b) -> a -> f b?
13:22:00 <chrisdone> (which it rarely is)
13:22:03 <merijn> chrisdone: GCC *is* buggy, so :)
13:22:04 <nerium> merijn: There are not spaces in my code
13:22:06 <merijn> chrisdone: ahahahahaha
13:22:07 <sinelaw> I think it's more that a transpiler is "you usually write your code directly in language X, but this thing lets you write it in Y and generate X"
13:22:10 <vanila> transpiler is a nonsense term made up to avoid getting chastised when you're in bad company for saying that you've written a compiler, when you've written a compiler but it doesn't emit assembly code
13:22:15 <merijn> chrisdone: Please, gcc is buggy as hell
13:22:19 <adarc> ok this is ugly code but, can i cause ghc to error out if i have a partial function
13:22:22 <adarc> tFromList [] = TEmpty
13:22:24 <adarc> tFomList ((x,y):xs) = TNode (tFromList $ takeWhile (\(x',y') -> x' < x) xs) (x,y) (tFromList $ takeWhile (\(x',y') -> x' > x) xs)
13:22:27 <adarc> that typo tho.
13:22:30 <chrisdone> merijn: i'd qualify your statements with a relativity
13:22:33 <mauke> chrisdone: I've seen compilers targetting javascript that generate an unholy mess. definitely not "human consumable"
13:22:33 <geekosaur> nerium: yes, it's telling you how it read your code. think about it
13:22:44 <mauke> chrisdone: yet they're called "transpilers" by some people
13:22:48 <chrisdone> merijn: "i know some gcc bugs" vs "this software is unusable" (the latter is what you make it sound like)
13:22:52 <adarc> i'd rather that typo cause my compile/reload in ghci to fail
13:22:55 <spaceshi1s> joe9: you could use Applicative and pure or return from Monad
13:23:03 <adarc> must be a language pragma or something
13:23:08 <merijn> chrisdone: GCC is borderline unusable on any non-x86 platform
13:23:11 <supki_> :t (??)
13:23:12 <lambdabot> Functor f => f (a -> b) -> a -> f b
13:23:14 <kadoban> nerium: It seems to be kind of a bug in the parser...throw parens around your -1s ?
13:23:15 <supki_> joe9: ^
13:23:15 <spaceshi1s> joe9: assuming f has an Applicative instance
13:23:32 <merijn> chrisdone: And on x86 any of the higher optimisation levels tend to be wonky
13:23:40 <nerium> kadoban: lol
13:23:41 <mauke> kadoban: no bug. the grammar simply doesn't have negative literals
13:23:53 <nerium> Yeah, that worked. Thanks
13:24:04 <spaceshi1s> joe9: nevermind i misread your question
13:24:04 <kadoban> mauke: Bug in the grammar then
13:24:09 <benmachine> joe9: it's a generalisation of "flip", for what it's worth
13:24:10 <merijn> nerium: Negative literals are a bit of an ugly edge condition in haskell
13:24:10 <chrisdone> mauke: actually i'd agree there -- fay, for example, could be called "transpiler" because it generates code you're supposed to be able to read as it's just normal JS with thunks wrapped around things. whereas ghcjs generates code i can't even begin to grok because it's doing stack emulation and threads and everything inside javascript. it's just thousands of lines of $a=$a2 etc
13:24:17 <merijn> kadoban: There's not good solution
13:24:19 <ionum`> which library would you guys recommend for logging in a web site (written in php) and scanning it for updates?
13:24:23 <adarc> -Wrror
13:24:25 <adarc> -Werror
13:24:27 <adarc> cool
13:24:43 <merijn> kadoban: It's ambiguous and the only way to make it unambiguous is either use something other than - for negation of something other than - for subtraction
13:24:59 <chrisdone> merijn: "border-line unusuable on any non-x86 platform" you know how straw graspy that sounds right? =p
13:25:13 <kadoban> Yeah, I think I understand why. It's still kinda ugly, but doesn't seem to hurt anything except in weird cases.
13:25:20 <joe9> benmachine: thanks.
13:25:32 <chrisdone> merijn: gcc is a damn fine compiler and an excellent piece of work. the presence of some bugs in certain conditions doesn't make it "buggy as hell"
13:25:35 <merijn> chrisdone: You say "straw graspy", I say, "I've had to switch compilers since my code doesn't run"
13:25:49 <benmachine> joe9: for a while lambdabot had it in her prelude-type thing, but I think that's been reverted nowadays
13:26:31 <joe9> supki, benmachine: sorry, I do not get it. What is the function's name? I cannot find (??) in Data.Functor.
13:26:41 <chrisdone> merijn: it's ok -- i think developers tend to make inflated statements like that about stable software when they encounter issues personally affecting them. it's not obvious that millions of other people are using it to compile thousands of software packages daily without issue
13:26:43 <merijn> chrisdone: Just because you don't use non-x86, doesn't magically make gcc better. The only reason x86 is fairly robust is because it's massively crowd-tested and patched, not because of solid design and engineering
13:26:43 <benmachine> joe9: I am not really helping :P
13:27:16 <chrisdone> merijn: ok =)
13:27:20 <vanila> gcc is a transpiler, not a compiler :)
13:27:22 <merijn> chrisdone: Oh, it works for those millions of people, because the common cases have been fixed due to millions of people testing them
13:27:27 <ski> spopejoy : use an `Either'-based monad together with `forever' ?
13:27:28 <ski> @type \ff a -> fmap ($ a) ff  -- joe9
13:27:29 <lambdabot> Functor f => f (a -> b) -> a -> f b
13:27:46 <joe9> ski, cool. thanks.
13:28:05 <ski> joe9 : you can plug particular `a's and `ff's if you like
13:28:21 <merijn> chrisdone: If you're doing nothing more adventuruous than "simple C/C++ on x86 without any low level optimisations", gcc is fine. However, that doesn't make it magically better software, it just means it's been patched up to working condition :)
13:29:11 <merijn> chrisdone: I've shared an office with people that had to hack gcc internals for their work, Lovecraftian horror stories every day :)
13:29:14 <ski> joe9 : alas, it used to be that `flip' in lambdabot had that type
13:29:26 <merijn> Anyway, back on topic :)
13:29:34 <mauke> did you know gcc has asm injection bugs?
13:29:53 <merijn> mauke: There is no statement of the form "did you know gcc has X bugs?" that will surprise me :)
13:30:12 <kadoban> let X = Ebola in ...
13:30:12 <chrisdone> the surprising thing in all this is that complex software has bugs
13:30:24 <chrisdone> i hadn't realised it until merijn lectured me ;)
13:30:33 <sinelaw> I have overlapping instances, when I remove it I have a missing instance.
13:30:37 <sinelaw> does this make sense?
13:30:50 <Yxven1> http://lpaste.net/114360
13:30:59 <benmachine> sinelaw: sure, if the instances are partially polymorphic
13:31:02 <kadoban> sinelaw: Heh, that sounds ridiculous, but I can imagine it'd be possible... Can you give more info?
13:31:24 <sinelaw> I have an instance given Functor & Foldable
13:31:32 <sinelaw> and another for a specific type (that is also Functor and Foldable)
13:31:33 <merijn> chrisdone: The problem is not "gcc is complex software and thus has bugs", but "gcc's bugginess/complexity is not warranted by what it's actually doing"
13:31:50 <chrisdone> merijn: ok
13:32:02 <benmachine> sinelaw: say you have an instance for ([a], Int) and an instance for (String, Char), then these are overlapping, but not redundant
13:32:02 <merijn> suncc and icc are arguably more complex than GCC (on account of them doing way more insane optimisations) and I never seem to run into these issues with them
13:32:30 <merijn> Anyway, I should stop ranting at harmless haskellers :D
13:32:37 <mauke> also, imagine writing a compiler. under what circumstances would you allow injection of target language fragments?
13:32:37 <sinelaw> harmless you say
13:32:53 <merijn> Ok, armed and dangerous haskellers :p
13:32:57 <sinelaw> benmachine, ok
13:32:59 <merijn> Whichever you prefer
13:35:24 <sinelaw> benmachine, yeah the problem is that I have one polymorphic and one non-polymorphic instance
13:35:44 <sinelaw> the polymorphic one has more strict type class constraints
13:35:57 <rs0> Yxven1: the issue here is non-strict evaluation as much as it is "purity," whatever that is
13:37:28 <sinelaw> Is there any way around this?
13:37:40 <sinelaw> like make the non-polymorphic instance take precedence for the specific type?
13:39:01 <Armel`> Hi! How to "postWith" cookies using the wreq library? Thank you!
13:41:15 <joe9> ski, http://codepad.org/R6s3IWBP Line 61, though it compiles. I find using "flip" affects readability.
13:41:46 <joe9> ski, any comments on if I can avoid using flip there, please?
13:42:21 <kadoban> joe9: (`applicativeJoin` fta) ?
13:43:27 <joe9> kadoban: yes, that is an option too.
13:45:21 <mads-> I am getting an error doing "Data Stack = [Int] deriving Show". parse error in constructor in data/newtype declaration: [Int]. Why is this?
13:45:54 <sinelaw> i wish I could say "type X can never implement type class T"
13:46:12 <shachaf> mads-: You need a data constructor, e.g. "data Stack = MkStack [Int]"
13:46:18 <simpson> mads-: You need a data constructor.
13:46:23 <simpson> Dammit, sniped.
13:46:27 <chrisdone> sinelaw: every time someone says that i spend a few minutes wondering whether it can be expressed
13:46:31 <mads-> I see. Thanks
13:46:38 <chrisdone> sinelaw: summarily decide: "no". but still
13:46:53 <sinelaw> notinstance T X
13:47:07 <Yxven1> rs0 What do you mean by non-strict evaluation? Meaning it won't be lazy?
13:47:32 <chrisdone> i excitedly thought there could be some way to implement an instance which would block another instance by contradiction. but it's not possible
13:47:33 <sinelaw> chrisdone, it's just a hint to the compiler, not something users should care about
13:48:10 <sinelaw> it will solve this polymorphic vs. monotype instance problem
13:48:16 <chrisdone> sinelaw: i suppose… you could use kinds
13:48:36 <chrisdone> like "type (x :: *) can never implement type class T, but type (a :: Foo) totally can!"
13:48:56 <sinelaw> not only "can", but here is an implementation
13:49:07 <povman> If I were to implement a binary protocol, should I be using Data.Binary, or is there something better in the Haskell Platform?
13:49:23 <chrisdone> binary, cereal and attoparsec are the main choices
13:49:28 <sinelaw> chrisdone, so only the first part of your statement is required
13:49:44 <sinelaw> the "can" part is implicitly stated when you give an implementation.
13:50:36 <chrisdone> sinelaw: i mean if you do class X (a :: MyRestrictedKind) where … then the set of types that can implement X is closed… but i guess you want it to be open except one class
13:51:05 <Armel`> Does anyone uses the "wreq" library?
13:51:19 <rs0> Yxven1: well, Haskell uses non-strict evaluation by default. this means that there needs to be some way for the language to track effects and ordering constraints, and that's largely what requires the use of monads for many types of sequencing and IO and so forth
13:51:21 <chrisdone> armel`: i don't, sorry
13:52:06 <sinelaw> chrisdone, right
13:52:43 <povman> chrisdone: Thanks
13:52:51 <sinelaw> like class Functor f => MyClass f where ... and then somewhere: not-an-instance Functor MyType
13:53:07 <Yxven1> rs0 I guess I don't understand what I'm losing by forcing strict evaluation
13:53:12 <sinelaw> so that you can then write instance MyCalss MyType without instances overlapping
13:53:50 <joe9> ski, Do you prefer using monad classes or monad transformers?
13:54:25 <merijn> joe9: What's a monadclass?
13:54:36 <chrisdone> MonadState, etc.
13:54:47 <Haskellfant> Hey, I'm playing around with pipes, but I'm a bit confused. I intend to use pipes-csv and thought that it would surely give me a pipe but instead the main function decode http://hackage.haskell.org/package/pipes-csv-1.4.0/docs/Pipes-Csv.html is a function from one producer to another one. Could this not be done as a pipe and if so why, and if it could be done as a pipe what could be the reason for using this
13:54:49 <joe9> yes, MonadState, MonadTrans, etc.
13:54:49 <Haskellfant> function here?
13:54:49 <merijn> I don't see how those are really competing options?
13:55:06 <merijn> MonadState and friends are convenience wrappers around transformers
13:55:22 <merijn> Haskellfant: It cannot be done as a pipe
13:55:23 <chrisdone> i think the choice is always "do i use lift everywhere or implement MonadFoo"
13:55:34 <phaazon> hey, who is @GabrielG439 on twitter?
13:55:39 <phaazon> (they nickname)
13:55:43 <phaazon> (his, actually :D)
13:55:44 <merijn> Haskellfant: The problem is that parses usually want to detect early termination
13:55:47 <merijn> phaazon: Tekmo
13:55:52 <merijn> phaazon: He's not in here that often
13:55:59 <Haskellfant> the author of pipes :)
13:56:05 <joe9> merijn: chrisdone: thanks
13:56:09 <phaazon> ok, because he wrote a tweet about me, that’s nice from him :)
13:56:15 <phaazon> thanks
13:56:19 <Haskellfant> merijn: isn't that what pipes-parse is for?
13:56:24 <jfischoff> Is hackage building documentation currently?
13:56:27 <chrisdone> phaazon: now kiss!
13:56:34 <chrisdone> jfischoff: hmm
13:56:37 * hackagebot hasql-postgres 0.5.0 - A "PostgreSQL" backend for the "hasql" library  http://hackage.haskell.org/package/hasql-postgres-0.5.0 (NikitaVolkov)
13:56:37 * chrisdone rolls dice
13:56:38 <rs0> Yxven1: to be honest, neither do i
13:56:39 * hackagebot liblastfm 0.5.1 - Lastfm API interface  http://hackage.haskell.org/package/liblastfm-0.5.1 (MatveyAksenov)
13:56:42 <merijn> Haskellfant: Right, but pipes-parse does it by using Producer to Producer functions :)
13:56:44 <jfischoff> haha
13:57:07 <Haskellfant> merijn: hehe, ok thx
13:57:13 <merijn> Haskellfant: Hold on, I have an example usage in my code, lemme check if I can simplify it
13:57:26 <merijn> (well, not if pipes-csv, but I assume it's similar to pipes-binary)
13:57:29 <Yxven1> rs0 fair enough. I appreciate the help
13:58:02 <phaazon> chrisdone: :P
13:58:14 <jle`> Haskellfant: remember that pipe composition, (a <-<), is already a transformation from one pipe to another.  just a little les powerful
13:58:34 <jle`> (a <-<) :: pipe -> pipe
13:59:24 <Haskellfant> well yeah I wanted to use input >-> decode
13:59:31 <merijn> Haskellfant: ok
13:59:37 <merijn> Haskellfant: So, what you want is the following
13:59:45 <merijn> jle`: It's not really relevant for his problem
13:59:51 <mads-> Can't I just make a new type which is just an "alias" for [Int]? Do I really need a constructor?
13:59:52 <Haskellfant> now I just do decode input
14:00:01 <Haskellfant> which works but I don't find it very intuitive
14:00:05 <merijn> Haskellfant: So, if you look at the pipes-parse tutorial you'll see it discusses lenses
14:00:10 <simpson> mads-: You can use the `type` keyword to create a type alias.
14:00:10 <jle`> oh, i was saying that, pipe-to-pipe transformers aren't really that uncommon
14:00:21 <simpson> mads-: type Stack = [Int]
14:00:30 <chrisdone> merijn: did you try out ghci-ng yet? =p
14:00:35 <jle`> but making a free "transformer" out of another pipe using composition is in general less powerful
14:00:45 <merijn> Haskellfant: Actually, you may not need a lens
14:00:55 <jle`> because if you use (>-> p), you only have some aspects of the original untransformed pipe you can manipulate
14:01:08 <jle`> it only gives you access to a certain "api" from your pipe you are trasnforming
14:01:15 <jle`> sometimes it's just not powerful enough
14:01:22 <jle`> the most motivating example is leftover support
14:01:23 <merijn> Haskellfant: ok, the function I figured existed doesn't, so I'll tell you how mine works
14:01:34 <chrisdone> merijn: D:
14:01:52 <merijn> chrisdone: Not yet, I was to busy meeting friends to code :p
14:02:17 <jle`> the transformer pt = (>-> p) doesn't have any way to access leftovers from the pipe you are going to be using it on.  `p2 x` doesn't semantically have any access to it
14:02:24 <jle`> it doesn't even make sense
14:02:29 <merijn> Haskellfant: Basically, you see " zoom :: Lens' (Producer a m x) (Producer b m y) -> Parser b m r -> Parser a m r"
14:02:35 <chrisdone> merijn: nice!
14:03:12 <jle`> s/p2/pt
14:03:17 <merijn> Haskellfant: Which is probably your end goal (converting a ByteString Parser to an (Either String a) Parser
14:03:36 <merijn> Haskellfant: So, how to get a Lens' from Producer to Producer? One simple way is
14:03:39 <merijn> :t iso
14:03:40 <lambdabot> (Profunctor p, Functor f) => (s -> a) -> (b -> t) -> p a (f b) -> p s (f t)
14:03:46 <merijn> ok, unhelpful type
14:04:03 <merijn> Haskellfant: See: http://hackage.haskell.org/package/pipes-parse-3.0.2/docs/Pipes-Parse-Tutorial.html#g:5
14:04:29 <Haskellfant> merijn: thx, I'll take a look. I haven't actually looked at pipes parse very detailed
14:05:22 <merijn> Haskellfant: I'm not too comfortable with it yet, it works *really* well, but wrapping your head around fitting all the pieces together can be really frustrating
14:05:48 <merijn> Haskellfant: I recommend asking the pipes mailing list if you get stuck, Tekmo is pretty responsive on there and gives really clear examples
14:06:02 <Haskellfant> merijn: will do, thx for your help
14:06:07 <jle`> Haskellfant: your question was why it couldn't be done as a pipe?
14:06:15 <jle`> er, as pipe composition?
14:07:04 <Haskellfant> jle`: my idea was that a pipe takes some input and returns some output, so I thought that it could just take the unparsed bytestring as an input and return the parsed csv as output
14:07:27 <Haskellfant> I should probably add that I've only just finished reading the pipes tutorial and never used it
14:08:42 <merijn> Haskellfant: The main problem is that pipes don't signal upstream termination
14:08:47 <jle`> yeah, the idea is that using the api exposed by (>->), a downstream pipe can't properly react to the termination of a stream and branch on what to do next, or continue somehow.
14:08:58 <Haskellfant> yeah I thik I got it now
14:09:00 <merijn> Haskellfant: Suppose your parser is half finished, but your Producer terminates due to lack of further input?
14:09:46 <mads-> One last question. I have data Bytecode = Push Int | Add | Mul. My function accepts [Bytecode] so I can do function [Push 4, Push 3, Mul]. But (Push 4) : (Push 3) : (Mul) doesn't work. How would I do that list notation?
14:10:59 <jle`> but it feels a bit less strange of a thing when you realize that all pipe composition is just pipe-to-pipe trasnformation in the first place...we just need to "lift" it with (>->).  so it's sort of like saying, "why can't i use `map (f :: a -> b_`) to change the numbr of items in my list?
14:11:07 <simpson> mads-: You forgot the [] at the end.
14:11:18 <jle`> well, `map` makes guaruntees and limits what `f` can do.
14:11:44 <jle`> so if you want to change the numbe rofitems on a list, mapping an `f :: a -> b` won't do.  you'd need a g :: [a] -> [b]
14:12:03 <jle`> remembering of course that `map f` is still [a] -> [b], just like g.
14:13:31 <nerium> How do I first print a line and then return a value in haskell?
14:13:57 <monochrom> putStrLn "hello" >> return False
14:14:19 <Haskellfant> jle`: that's a very good comparision, thx
14:14:33 <monochrom> have you read my http://www.vex.net/~trebla/haskell/IO.xhtml ? it has this kind of stuff and more
14:14:35 <mads-> simpson: aha, now I see. Thanks again
14:15:00 <athan> The state monad isn't very good for parsing text into an AST, is it? :(
14:15:25 <monochrom> the state monad lacks "what if parse error"
14:15:29 <jle`> np!
14:15:42 <monochrom> but actually, is good otherwise
14:16:04 <nerium> monochrom: Did i miss something? https://gist.github.com/oleander/e0233e7a7146e304a88c
14:16:14 <athan> monochrom: I'm having trouble imagining it... if ST = s -> (a, s), would s be the string I'm parsing? :S
14:16:33 <monochrom> yes, use s for the String.
14:16:48 <nerium> monochrom: What?
14:16:54 <athan> monochrom: Holy petunias, now I get it. Perfect, thank you
14:17:11 <athan> Would `forever` work with it, too?
14:17:13 <athan> @src forever
14:17:13 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
14:17:23 <exio4> forever x = x >> forever x
14:17:24 <ski> Yxven1 : you might perhaps "Functional Programming in C++" in 2012-04-26 at <https://web.archive.org/web/20140719080947/http://www.altdev.co/2012/04/26/functional-programming-in-c/> (not sure why direct link didn't work here) interesting ..
14:17:38 <athan> ahh, awesome. Thanks exio4
14:17:39 <monochrom> if you have parse errors, it's String -> Either ParseError (a, String).
14:17:43 <ski> Yxven1 : also "QuakeCon Keynote (part 4)" in 2013 at <https://www.youtube.com/watch?feature=player_detailpage&v=1PhArSujR_A#t=125>,"QuakeCon Keynote" in 2011 at <https://www.youtube.com/watch?feature=player_detailpage&v=4zgYG-_ha28#t=3234>. all these by John Carmack
14:17:57 <athan> monochrom: thank you :)
14:18:01 <QF-MichaelK> Is there a handy way to solve something like this in the repl?  lim f log f / g > 0, lim f log g / g = 0, f < g, g >= n log n, I want 2 functions f and g such that this is true.
14:18:06 <nerium> monochrom: I’m not following
14:18:10 <exio4> :t fix . (>>)
14:18:11 <lambdabot> Monad m => m a -> m b
14:18:21 <athan> exio4: I knew it!!
14:18:24 <monochrom> nerium, you are not supposed to print anything in that context.
14:18:57 <Yxven1> I will check them out. Thanks ski
14:19:29 <monochrom> the same reason in C++ you would not have a constructor to "ask for user input", even though the language allows it.
14:20:40 <nerium> monochrom: So how do I debug?
14:21:00 <rs0> ski: I wonder if anyone has implemented persistent collections in C++. i'm wondering if there's something more clever than naive refcounting
14:21:23 <rs0> ski: there's a Rust library that implements persistent collections but it uses refcounting
14:21:33 <monochrom> that depends on what you debug.
14:22:11 <ski> Yxven1 : you could also check out the slides (there's both PPT and PDF) from Tim Sweeney (of Unreal)'s "The Next Mainstream Programming Languages" in 2006 at <http://lambda-the-ultimate.org/node/1277>
14:23:30 <solrize> rs0 there's a gc api in c++11 i don't know what implementations exist though
14:26:11 <ezyang> @djinn  (a1 -> b -> c -> d) -> (a2 -> a) -> (a2 -> b -> c -> d)
14:26:11 <lambdabot> -- f cannot be realized.
14:26:19 <ezyang> @djinn  (a1 -> b -> c -> d) -> (a2 -> a1) -> (a2 -> b -> c -> d)
14:26:19 <lambdabot> f a b c = a (b c)
14:26:23 <rs0> solrize: yeah, that always seemed like vaporware. C++ culture strikes me as enormously biased against garbage collection
14:26:43 <rs0> solrize: which is funny, because refcounting is vastly more expensive, particularly once concurrency is introduced
14:27:07 <solrize> the c++ faction willing to use refcounting probably doesn't mind gc :)
14:29:07 <rs0> yes, and they would probably mind a managed language even less
14:29:10 <rs0> or at least Rust
14:29:25 <rs0> i don't know if there's enough demand for GC for legacy C++ applications to drive a production-quality implementation
14:31:08 <texasmynsted> anybody doing a static site with cheapskate?
14:31:23 <texasmynsted> https://github.com/jgm/cheapskate
14:32:21 <solrize> is there a good ffi between rust and c++?  seems like a lot of c++ culture is about maximizing speed.  so it has macro-like templates, move constructors, etc
14:32:31 <solrize> that don't fit in with rust
14:32:52 <tolt> texasmynsted: That's interesting. I was just about to start a static site with hakyll
14:33:55 <solrize> http://bitquabit.com/post/c++-programming-and-brain-ram/ nice rnat
14:33:56 <solrize> rant
14:35:47 <rs0> solrize: nothing will ever dethrone http://yosefk.com/c++fqa/fqa.html as the greatest C++ rant of all time
14:35:57 <solrize> hehe yeah
14:36:33 <rs0> solrize: I've always thought that extremely awkward, nonsensical, borderline aphasic acronyms like RAII and SFINAE should be a warning sign that the architects of C++ can't think clearly
14:39:28 <texasmynsted> toit, hakyll is really interesting and what I will use if I do not use cheapskate.  hakyll is a full solution, cheapskate is a parser
14:40:50 <mkscrg> been playing with datakinds et al, find myself needing Typeable instances for promoted lists
14:40:57 <mkscrg> this works: deriving instance Typeable '[]
14:41:19 <mkscrg> but i haven't found a variant of this that compiles: deriving instance Typeable (':)
14:41:29 <jle`> :t \f g x -> f (g x)
14:41:29 <mkscrg> seems like a syntax issue
14:41:30 <lambdabot> (t1 -> t) -> (t2 -> t1) -> t2 -> t
14:46:18 <slack1256> any package with a function that randomize a list?
14:46:38 <slack1256> ie given a seed g and a list xs will return a list xss with all the elements in random order?
14:51:18 <jle`> > map fst . sortBy (comparing snd) . zip "hello world" $ randoms (mkStdGen 3845792)
14:51:19 <lambdabot>  " rwoholdlel"
14:52:03 <chrisdone> i think that's valid danish
14:52:28 <merijn> Looks more like Gaelic :p
14:52:37 <slack1256> that works sufficiently well !
14:52:46 <thinker341A> Hi there, how can i get :  [(0,0), (0,1), (1,0), (1,1)] from : x=[0..1] y=[0..1]
14:52:49 <Cale> That won't give all possibilities with equal probability though
14:53:26 <slack1256> yes, but for my (little) problems will work well
14:53:34 <Cale> There's http://hackage.haskell.org/package/random-shuffle
14:53:49 <Cale> Which is a little awkward API-wise, but it contains a perfect shuffle
14:54:15 <slack1256> Oleg always a step ahead
14:54:28 <slack1256> will use that instead
14:54:36 <slack1256> thanks Cale, jle`
14:55:27 <mrsElectron> test
14:55:43 <chrisdone> while god was working on the heaven and the earth, oleg was developing an algebra for light
14:56:06 <mrsElectron> who's oleg?
14:56:08 <chrisdone> god turned round on the 6th and sighed
14:56:09 <vanila> didnt go created light first though...
14:56:15 <monochrom> are you sure it's an algebra not a type class? :)
14:56:28 <vanila> o h I get it
14:56:55 <chrisdone> god created the heaven and earth and then said 'let there be light!', all dramatic, like
14:57:07 <chrisdone> but oleg already had LEDs working
14:57:12 <monochrom> haha
14:57:16 <ezyang> @hoogle (a -> m b) -> (b -> c) -> (a -> m c)
14:57:18 <lambdabot> Control.Parallel.Strategies ($|) :: (a -> b) -> Strategy a -> a -> b
14:57:18 <lambdabot> Control.Parallel.Strategies ($||) :: (a -> b) -> Strategy a -> a -> b
14:57:18 <lambdabot> Control.Parallel.Strategies (-|) :: (a -> b) -> Strategy b -> (b -> c) -> (a -> c)
14:57:27 <dmj`> Fuuzetsu: ping
14:57:35 <Cale> chrisdone: In the type system
14:58:25 <mrsElectron> so in an if statement, you press return as follow? if condition [return] then statement [return] else statement [return] ?
14:59:33 <glguy> mrsElectron: Oleg Kiselyov is a very highly regarded computer scientist: http://okmij.org/ftp/
14:59:51 <chrisdone> Cale: haha =)
14:59:51 <Cale> mrsElectron: By return, you mean like a new line?
15:00:14 <Cale> mrsElectron: The usual way to lay out an if expression when you want to span multiple lines is like:
15:00:18 <Cale> if condition
15:00:26 <Cale>    then result1
15:00:29 <Cale>    else result2
15:00:33 <mrsElectron> but is it necessary?
15:00:39 <Cale> It's not necessary
15:00:57 <mrsElectron> it's either that, or in parenthesis?
15:00:59 <Cale> You can put it all on one line, and really, there's no layout sensitivity (though I sort of feel that there ought to be)
15:01:36 <Cale> Really, you can extend *any* expression onto multiple lines so long as you ensure that the following lines start in a deeper column than the first
15:01:45 <dmj`> glguy: my oleg shirt came in the mail yesterday... http://haskell.spreadshirt.com/oleg-already-did-it-A6499531
15:04:38 <dmj`> glguy: http://haskell.spreadshirt.com/oleg-already-did-it-A6499531
15:22:21 <stephenmac7_> Would sbv be the right tool to use if I'm planning on using sat/smt to solve package dependencies?
15:24:19 <benzrf> dmj`: heh heh
15:24:38 <dav1d> hey, I am kinda confused I have this data-type: `data Nat = Z | S Nat deriving Show` now simply trying `(Z)` gives me a Undefined data constructor "Z", why?
15:24:52 <stephenmac7_> About that... anyone seen such a monstrous haddock page as this one? http://hackage.haskell.org/package/sbv-2.10/docs/Data-SBV.html
15:25:11 <benzrf> dav1d: that's valid, so you must be doing something wrong in putting those pieces of code together
15:25:12 <monochrom> stephenmac7_: yes. but that's meta. to install sbv, first you have to solve package dependencies... :)
15:25:16 <benzrf> dav1d: are they in separate files?
15:25:22 <vanila> dav1d, it should work, your code is correct
15:25:26 <dav1d> holy shit
15:25:28 <dav1d> it is hugs
15:25:30 <dav1d> it works in ghci
15:25:32 <benzrf> >hugs
15:25:35 <benzrf> dude
15:25:36 <benzrf> don't use hugs
15:25:37 <dav1d> benzrf: I have to use it
15:25:38 <benzrf> that's oooooold
15:25:39 <stephenmac7_> monochrom: Yes, but that work has been done for me already by the cabal team
15:25:43 <dav1d> benzrf: I have to, for university
15:25:45 <monochrom> :)
15:25:53 <dav1d> benzrf: the code I just posted is from my university as well
15:25:55 <benzrf> dav1d: wat
15:25:56 <monochrom> anyway, yes, sbv is suitable
15:25:57 <dav1d> what is wrong with them
15:25:57 <benzrf> ew
15:26:01 <dav1d> benzrf: yeah :/
15:26:30 <stephenmac7_> monochrom: Is there any good non-haddock info on it?
15:26:35 <monochrom> I don't know
15:27:15 <tolt> I'd use hugs if I got to use haskell at school.
15:27:15 <begriffs> Monad question...I'm setting up a Hasql database session, then inside launching (and liftIO'ing) a web listener in Warp. But when I'm in the listener I am not able to call database functions because I'm in the IO monad rather than the "Tx" monad. How do I pop out of IO for a moment?
15:27:43 <dfeuer_> Would anyone who knows something about pipes care to improve the haskell-pipes tag wiki on Stack Overflow? It's currently pretty awful.
15:28:16 <stephenmac7_> monochrom: Any idea why it has to redefine prelude?
15:28:24 <monochrom> I don't know
15:30:34 <begriffs> Looks like the library uses MonadBaseControl, does this give me a way to unwind the monads and call functions in outside ones?
15:31:00 <monochrom> yes to a large extent
15:33:14 <dav1d> benzrf: strange on their server (also with hugs) it works, just locally not, guess I will use ghci then
15:42:35 <Haskellfant> I'm trying to debug a space leak that I get when trying to parse a csv with pipes and count for each column how many rows are non empty http://lpaste.net/114372 -hy shows that a lot of ram is used in Integer, so I thought just throwing in seq should solve this but sadly it doesn't
15:42:49 <dmj`> benzrf: :)
15:43:22 <Dbohling> hey does anyone have experience getting Haskell / Yesod framework going on a Mac? I'm getting an error saying it can't find the regex-base-0.93.2 package when I try to build my project.
15:44:55 <hiptobecubic> Has anyone tried to work through a book/project like this using haskell/ocaml? http://www.amazon.com/The-Elements-Computing-Systems-Principles/dp/0262640686/ref=pd_bxgy_b_text_z
15:49:06 <begriffs> What is the opposite of liftIO? That is, rather than going from IO to m, it goes from m to IO?
15:49:16 <dmj`> hiptobecubic: I wrote the Jack language parser with parsec
15:49:28 <geekosaur> return?
15:49:31 <monochrom> that depends on m.
15:50:05 <dmj`> hiptobecubic: it's not pretty code
15:50:45 <begriffs> monochrom: in this case m is MonadBaseControl IO m   [ http://hackage.haskell.org/package/hasql-0.1.5/docs/Hasql.html#v:session ]
15:51:24 <monochrom> that is a type class constraint, not a type.
15:52:10 <monochrom> it may not have enough methods for m a -> IO a
15:53:29 <monochrom> the closest thing is liftBaseWith
15:54:47 <monochrom> you may have to think a different way
15:58:25 <begriffs> monochrom: The context is that my Warp app mixes handling requests and generating responses with calls to the database. However once I get inside "runSettings :: Settings -> Application -> IO ()" to start the request-response loop the database seems out of my grasp. And I can't create the db session inside there because that would be very inefficient.
15:58:51 <merijn> Haskellfant: Have you read the RWH chapter on debugging space leaks?
15:59:55 <Haskellfant> merijn: I had a look at it, but couldn't find anything other than looking at the heap profile and then trying to force evaluation where it makes sense which is what I tried :)
16:01:12 <Haskellfant> I'll try a bit more
16:01:27 <merijn> Haskellfant: Well, step one is figuring out what is actually allocating said memory
16:01:48 <merijn> Randomly annotating strictness is not a very efficient approach before you know why you're doing it
16:02:27 <Haskellfant> according to the heap profile it's mostly used up by Integers so my thought was that the addition was causing thunks to stack up, so I tried forcing evaluation there
16:03:09 <merijn> Haskellfant: Also, may want to annotate types on your lpaste, because I have no idea what "parse" is
16:03:13 <numberten> is rwh still a good source for learning to use databases with haskell?
16:03:24 <numberten> i'm looking to use mysql
16:04:40 <merijn> Haskellfant: Also, may wanna split parse into more local things in where clauses annotated with types
16:04:49 <begriffs> numberten: rwh will cover hdbc which is an oldish db access library
16:04:54 <merijn> Haskellfant: Right now it's hard to see what each part is doing exactly
16:05:01 <Haskellfant> merijn: ok, give me a minute
16:05:12 <begriffs> numberten: you might like http://hackage.haskell.org/package/mysql-simple more
16:05:16 <merijn> Haskellfant: Also, FYI
16:05:21 <merijn> Haskellfant: "seq z z" does nothing
16:05:43 <Haskellfant> oh that might explain why it's not working as I expect it to :)
16:06:40 <numberten> begriffs: i'll take a look, thanks :)
16:06:52 <merijn> Haskellfant: "seq x y" says "IFF neither x nor y are bottom THEN at the end of evaluating 'seq x y' to WHNF, both 'x' AND 'y' are evaluated to WHNF"
16:07:10 <merijn> Haskellfant: So "seq z z" says "if you evaluate 'z' to WHNF, then evaluate 'z' to WHNF"
16:07:28 <Haskellfant> ah ok
16:08:52 <merijn> You probably wanna force the accumulator in 'f', -XBangPatterns and changing it to "!acc" on line 13 seems like it might help
16:09:08 <merijn> But I'm lazy to figure out exactly which part is too lazy, so I'm not sure !acc is what you need
16:10:48 <Haskellfant> merijn: updated the lpaste
16:10:56 <Haskellfant> hopefully it's a bit more clear now
16:12:08 <Haskellfant> this is the heap profile https://i.imgur.com/S8sDxak.png
16:12:28 <Haskellfant> it sorta looks like it's trying to read everything in and stars folding only after that
16:19:23 <codygman> How can something of type string cause an infinite loop when it is evaluated?
16:19:43 <hpc> > cycle "yes no "
16:19:44 <lambdabot>  "yes no yes no yes no yes no yes no yes no yes no yes no yes no yes no yes n...
16:19:50 <vanila> it could be an infinite loop to compute the first char
16:19:59 <vanila> > let omega = omega in  omega : "foobar"
16:20:02 <hpc> > length (cycle "yes no ")
16:20:02 <lambdabot>  mueval-core: Time limit exceeded
16:20:07 <lambdabot>  mueval: ExitFailure 1
16:20:50 <codygman> vanila: I think that is the problem I'm facing, I just have to understand it better. Actually I now it is, in debugger it gave me the 'h' : beginning a url
16:20:59 <codygman> s/now/know
16:30:42 <Dbohling> I'm trying to get Yesod working on my Mac, but I'm getting an error (<command line>: can't load .so/.DLL for: /Library/Haskell/ghc-7.8.3-x86_64/lib/regex-base-0.93.2/libHSregex-base-0.93.2-ghc7.8.3.dylib ... Reason: image not found) - does that look familiar to anyone, and/or can anyone point me in the direction of how to resolve it?
16:31:32 <Haskellfant> what is the whnf of vector?
16:31:42 * hackagebot twitch 0.1.2.0 - A high level file watcher DSL  http://hackage.haskell.org/package/twitch-0.1.2.0 (JonathanFischoff)
16:36:29 <orion> Hi. I blew away my ~/.cabal directory, ran `cabal update' and then ran `cabal install ghc-mod'. I received the following errors:
16:36:30 <codygman> I found the infinite loop problem: http://lpaste.net/114377 Are there cases where this code would work? It's in a codebase I found and am trying to get working on ghc 7.8.
16:36:31 <orion> http://pastebin.com/iB9p3Gur
16:36:39 <orion> Does anyone know what could be going wrong here?
16:36:42 * hackagebot twitch 0.1.2.1 - A high level file watcher DSL  http://hackage.haskell.org/package/twitch-0.1.2.1 (JonathanFischoff)
16:36:51 <orion> I am using haskell platform 2014.2 on FreeBSD 10.1.
16:37:20 <codygman> orion: Did you run ghc-pkg check ?
16:37:49 <codygman> Not sure if you can run it without args, might have to run it on both hashtable and random like: ghc-pkg check hashtable
16:37:51 <monochrom> ~/.cabal is almost the wrong thing to erase. look what's in ~/.ghc
16:38:01 <orion> codygman: Lot of errors. :/
16:38:09 <orion> "cannot find any of ..."
16:38:31 <codygman> orion: monochrom's idea is probably better
16:41:09 <Haskellfant> yeah >50mb to 250k
16:42:12 <orion> codygman: I blew both away just now and the same problem occurs.
16:42:36 <mads-> I just wrote my first haskell program. A small interpreter and compiler using arithmetic expression with Literals, addition and multiplication. Haskell is really a pleasure to work with. :)
16:42:59 <codygman> orion: This is the first time I've had this problem, but I would start out by running ghc-pkg check hashtable and then posting the output.
16:43:04 <monochrom> yes, Haskell keeps your interpreter high-level
16:46:58 <codygman> Even when using 'cabal install --ghc-options="-fforce-recomp"', my external libraries aren't being updated. Do I have to force reinstall specific libraries manually?
16:47:57 <monochrom> yes. if cabal decides to not even rebuild, then all your ghc-options are not going to happen, because ghc is not even called up.
16:48:49 <codygman> monochrom: Basically I have a local package i've used cabal add-path on I'm using from another project. How best can I make sure it is recompiled along with the project using it?
16:49:03 <monochrom> I don't know cabal add-path
16:49:28 <monochrom> or anything related to cabal sandbox
16:49:41 <codygman> Oh, well thanks anyway
16:52:24 <lillian> Isn't there something like python's zip() where you can take two lists in and produce something like [(from_list1, fromlist_2), (from_list1, fromlist_2)]
16:53:06 <BMeph> :t zip
16:53:07 <lambdabot> [a] -> [b] -> [(a, b)]
16:53:17 * BMeph waits for it...
16:53:25 <lillian> oh really lol
16:53:52 <lillian> jeez i don't even know what that's saying i'll have to read up on that x.x
16:54:18 <chrisdone> lillian: it's like what you wrote
16:54:32 <chrisdone> :t zip :: [list1] -> [list2] -> [(list1,list2)]
16:54:33 <lambdabot> [list1] -> [list2] -> [(list1, list2)]
16:54:45 <lillian> OH WOW THAT'S GREAT
16:54:47 <chrisdone> > zip [1..5] [6..10]
16:54:48 <lillian> nice
16:54:48 <lambdabot>  [(1,6),(2,7),(3,8),(4,9),(5,10)]
16:54:50 <lillian> <3
16:54:54 <lillian> TY
16:54:58 <chrisdone> welcome =)
16:57:39 <povman> I’m (attempting) writing a network protocol library for OrientDB
17:03:18 <mads-> When I have a function Expr -> [Int] -> Int and another function Expr -> Int, what is it then called when I "pack" the first into another such that the new function and the second has the same signature and I can use them interchangably? Like this: http://ideone.com/zxSdEO
17:03:58 <lpaste> povman pasted “Xtreme type exportion” at http://lpaste.net/114381
17:04:39 <povman> On that code I get     Could not deduce (Xtreme d) arising from a use of ‘xt’
17:04:49 <lwm> anyone any good with postgresql-simple? I am getting stuck trying to make a simple query: lpaste.net/114379
17:05:26 <povman> Am I trying something futile here? I want to describe messages by normal data types
17:05:46 <povman> And have them automatically serialised based on having serialisable data elements
17:06:14 <lassulus> mads-: you can use them interchangably, if that was your question
17:07:47 <mads-> lassulus: Sorry, no. The question was, what do I call it (does it have a name?) now that I have packed first into thirs such that I can use them interchangably?
17:08:24 <mads-> Because if I wanted to give a function one of these functions, I have to pack first into third in order to be able to give it first and second
17:08:55 <lassulus> mads-: ah yeah, now i get it, but i dont really know how its called
17:09:17 <mads-> lassulus: thanks anyways :)
17:16:24 <Cale> mads-: I would just say that you used first to define third?
17:16:40 <Cale> I don't understand what you mean by "pack"
17:19:36 <numberten> does aeson have an encode function that returns strict bytestrings?
17:22:28 <Cale> If not, then it's really easy to convert
17:22:54 <Cale> Just use LB.toStrict on it
17:23:49 <Cale> (which is of course an expensive operation in some sense, but that is an unavoidable expense to working with strict bytestrings)
17:23:59 <numberten> Cale: yep, thanks :) just trying to see if I could get away without importing another thing
17:34:57 <josiah14> is there a way to guarantee that if I make a new typeclass, say, class A, that it is also going to be a Functor and a Monoid (or some other typeclass, but just picking those 2 arbitrarily)?
17:35:37 <josiah14> in otherwords, things of class A are also, necessarily, Monoids and Functors by definition
17:38:05 <numberten> something like class (Functor a, Monoid a) => A a where
17:38:05 <numberten> ?
17:38:16 <int-e> josiah14: not with those particular classes (their kinds don't fit), but yes.
17:39:15 <josiah14> wait, technically a data item cannot be both a functor and a monoid at the same time?
17:39:22 <shachaf> Right.
17:39:22 <josiah14> What about Maybe?
17:39:25 <shachaf> They have different kinds.
17:39:28 <int-e> @kind Functor
17:39:29 <lambdabot> (* -> *) -> Constraint
17:39:30 <shachaf> Maybe isn't a Monoid.
17:39:32 <int-e> @kind Monoid
17:39:33 <lambdabot> * -> Constraint
17:39:36 <shachaf> (Maybe a) can be a Monoid.
17:40:04 <josiah14> oh, okay, I see, yah
17:40:11 <hyPiRion> :t First
17:40:12 <lambdabot> Maybe a -> First a
17:40:13 <josiah14> I would have figured that out when GHC yelled at me
17:40:21 <int-e> josiah14: you can have   class (Functor f, Monoid (f a)) => Foo f a where ...
17:40:37 <josiah14> sweet, that's what I needed
17:41:06 <int-e> (with MultiParamTypeclasses, FlexibleContexts and UndecidableInstances, I suppose)
17:41:07 <josiah14> I'm really enjoying this language - makes me 'sweat' to really understand what I'm doing
17:42:14 <int-e> it's MultiParamTypeClasses, I usually copy that from the compiler's error messages.
17:42:51 <josiah14> I need to bake that into the build command?  something like ghc -XMultiparamTypeClasses ?
17:43:34 <Welkin> josiah14: or include it in the code as a language pragma
17:43:34 <int-e> use a  {-# LANGUAGE ListOf ExtensionsHere #-} pragma
17:43:43 <hyPiRion> josiah14: You can do `{-# LANGUAGE MultiParamTypeclasses #-}` at the top of the file
17:43:50 <Welkin> {-# LANGUAGE MultiparamTypeClasses #-}
17:43:51 <int-e> you can also list extensions in a .cabal file
17:44:14 <dfeuer> Hmm... Why is it that GHC can't find Data.Vector?
17:44:29 <Welkin> dfeuer: install it?
17:44:41 <dfeuer> Welkin, it *looks* like it's installed.
17:44:43 <josiah14> i already have a bulid script, so I'll just add it in there, and then decide later what I want to do when I'm ready for distributing the first release of the software
17:45:36 <josiah14> but as I'm taking the XMonad approach of having the user define the main function to configure the program, I doubt I'll want to use a language pragma statement in the code
17:46:31 <josiah14> Shelly suffers from that, I have to add those pragma at the top of ever Shelly script i write
17:47:32 <mungojelly> As an end user XMonad works great. I hardly speak a word of Haskell and I had no trouble setting it up and configuring it.
17:48:05 <josiah14> I use XMonad as my window manager on my personal development laptop.  It's fantastic
17:48:20 <josiah14> lightweight, fast, gets out of my way and just lets me write code
17:48:49 <josiah14> mungojelly: ^
17:49:35 <mungojelly> Yeah the first thing I did was to set it up so I can just have it totally blank, like an empty canvas, then I feel productive. I had to learn how to make it cooperate with unclutter so there wasn't a cursor disrupting my thoughtful emptiness. :)
17:49:50 <josiah14> only complaint I have about XMonad is if I open a program and switch spaces or monitors before it loads, it opens on the currently active space instead of the one I called it on
17:50:23 <josiah14> so I can't just boot the system and open a bunch of apps or write a script to start everything automatically as easily
17:50:44 <mungojelly> Hmm yeah interesting. It doesn't put new programs how I want in general, they just sorta blonk into place randomly and then I have to rearrange shit how I want it. We could figure out a sensible interface for telling things where to go to smooth it out, hmm.
17:51:37 <josiah14> mungojelly: I'm not familiar with unclutter, but the mouse pointer doesn't bother me too much
17:52:42 <josiah14> but, I also really don't have a full graphical desktop installed.  I use parts of LXDE under the hood to manage the session, but once I'm logged in, it's pretty much GTK, X11, and XMonad
17:53:27 <mungojelly> josiah14: It's certainly not rational that a couple of pixels left on the screen when I move the mouse most of the way off seem distracting to me. But it's nice to have programs flexible enough to accomodate my irrationalities. :D
17:54:05 <josiah14> mungojelly: +1
17:54:19 <bjz> solrize: there is not a good ffi in Rust for C++ - you need to write a C wrapper for the C++ functionality you want. Unfortunately the only way to make a good C++ ffi is to basically re-implement C++. D is the only language that really has a shot at it.
17:54:29 <josiah14> it's not rational for me to want to do everything except web browsing from the console, but there you have it
17:54:52 <dav1d> wohooooo I DID IT
17:54:53 <dav1d> Main> neqPR (S (S Z),Z) (S Z,S (S Z))
17:54:54 <dav1d> [1]    2011 segmentation fault (core dumped)  hugs
17:57:00 <bjz> solrize: RAII is in incredibly useful feature, with a horrible name (Stroustrup freely admits this). SFINAE on the other hand is just more C++ ridiculousnous.
17:57:33 <josiah14> C++ gets no love these days
17:57:49 <josiah14> I didn't terribly dislike the language when I used it
17:58:16 <josiah14> I must admit, though, I enjoy haskell and lisp much more
17:58:19 <bjz> josiah14: it has plenty of great, novel ideas, but it's embedded in a ton of crap
17:58:23 <bjz> :(
17:58:32 <johnw> this channel isn't for discussion of other languages we don't like
17:59:04 <bjz> johnw: apologies, it was in the context of a previous question about Rust
17:59:11 <johnw> n/p, thanks :)
17:59:25 <bjz> johnw: but I will stop :)
18:27:36 <lwm> if anyone is bored, they figure this out: http://stackoverflow.com/questions/26952685/postgresql-simple-query-error
18:27:39 <lwm> ;)
18:38:06 <Arahael> lwm: Looks like a bug. Do you still get the error with manually-specified columns? (Don't use * anyway, it's a bit of a bad practice)
18:42:20 <Arahael> (But you probably already have considered that)
18:44:00 <lpaste> povman pasted “SYB error” at http://lpaste.net/7093222597688557568
18:44:10 <povman> I’ve been looking at SYB examples but can’t work this one out. Anyone have ideas?
18:44:46 <povman> I expect the ‘steal’ function to collect up the Bool inside A
18:45:25 <BMeph> lwm: Looks more like a list of a list of strings, or possibly, a list of a triple of strings. Just my first impression.
19:01:46 <lpaste> povman revised “SYB error”: “No title” at http://lpaste.net/7093222597688557568
19:01:56 <povman> Fixed it :)
19:02:49 <povman> It needed an mkQ instance, which casts from any (Data a=>a) to the type expected by gmapQ
19:12:00 <lwm> :Arahael I will try that now
19:12:13 <lwm> @Arahael I was just using the '*' for testing
19:12:13 <lambdabot> Unknown command, try @list
19:12:25 <lwm> damnit Lambdabot, work with me here
19:12:59 <lwm> BMeph: OK, I'll play around with that
19:16:43 * hackagebot haskakafka 0.5.0 - Kafka bindings for Haskell  http://hackage.haskell.org/package/haskakafka-0.5.0 (tdimson)
19:21:43 * hackagebot hls 0.15 - Haskell Lindenmayer Systems  http://hackage.haskell.org/package/hls-0.15 (RohanDrape)
19:52:16 <Yuras> carter: are you there?
19:58:44 <carter> Yuras: sometimes!
19:59:24 <Yuras> carter: I have a writeup, but I'm not ready to show it publically. could you please read it?
19:59:28 <carter> sure
20:02:57 <trap_exit> what are the best pants to wear when codin gin haskell? I find jeans vrather uncomforatgable for > 8 hours / day
20:05:20 <numberten> trap_exit: pajamas
20:05:58 <simpson> Jimmies.
20:09:33 <gamegoblin> If one wanted to make a function which only operated on non-empty lists (such as head), what do you folks think of doing something like Data NonNullList a = NonNullList a [a] and then having your function definition be something like NonNullList a -> a, as opposed to [a] -> Maybe a (returning Nothing if passed []). Not actually doing this for anything (no need), but curious what peoples opinions are.
20:09:59 <joseph07> Gamegoblin: its been done
20:10:08 <gamegoblin> joseph07: What’s it called?
20:11:05 <joseph07> Gamegoblin: data.list.nonempty
20:11:43 <gamegoblin> joseph07: cool, thanks
20:22:25 <athan> gamegoblin: You could use datakinds :x
20:56:23 <Yuras> carter: I decided to post it to anyway :)
20:56:31 <Yuras> it is on /r/haskell already
20:57:20 <carter> heh
20:58:30 <Yuras> carter: it is hard for me to write in English. I'm simple not able to finish the article
20:58:38 <carter> fair
20:58:51 <carter> i'm a bit tired or i'd have offerted to help edit ;)
20:59:12 <carter> Yuras: either way, its a good start!
20:59:49 <Yuras> thank you
20:59:56 <carter> no, thank YOU
21:00:00 <cecietcela> you're welcome
21:00:35 <carter> except you :P
21:00:53 <cecietcela> sunuva >:C
21:18:52 <David> Is there a built-in operator that is equivalent to flip ($)?
21:19:47 <benzrf> David: if you import lens, yes!
21:19:55 <benzrf> David: but no
21:20:18 <johnw> it's one of the most asked-for not-in-base operators
21:20:23 <jle`> there will be in 7.10
21:20:28 <benzrf> oh hella
21:20:28 <johnw> ah, finally
21:20:29 <jle`> so get ready
21:20:31 <johnw> as &
21:20:36 <jle`> yeah in Data.Function
21:20:43 <johnw> ?
21:20:43 <benzrf> >not parenthesizing your operators
21:20:43 <johnw> *sweet*
21:20:45 <benzrf> disgusting
21:20:48 <jle`> i am one of the people against it
21:20:52 <jle`> but oh well
21:20:53 <benzrf> jle`: why?
21:21:16 <jle`> cause i like keeping things in normal order :|
21:21:26 <jle`> :|
21:21:46 <shachaf> sigh
21:22:15 <jle`> when said that way it doesn't really sound like that good of a reason anymore but i remember having more eloquently stated reasons in the past...oh well
21:22:44 <jle`> i guess one thing keeping everyone from switching over to reverse function application is the lack of a nice flip (.)
21:23:03 <jle`> there's (>>>) but it's not really pleasant to use
21:23:21 <hunt> is there a way to write a conditioned anonymous function using pipes (|)?
21:23:28 <hunt> for the sake of saving space, as in a regular function
21:23:41 <jle`> you mean guards with lambdas
21:23:42 <jle`> ?
21:23:45 <hunt> yea guards
21:23:48 <hunt> sorry i forgot the term
21:23:54 <jle`> its ok
21:23:58 <Cale> (\x -> case x of ...)
21:24:19 <hunt> Cale: yea i was aware of case notation but i was hoping to use guards because its considerably shorter i think
21:24:28 <hunt> if not simpler in this case
21:24:38 <hunt> but theres no way eh?
21:24:47 <jle`> can you show an example
21:24:50 <jle`> of what you would want to do
21:25:16 <hunt> \(a:as) (b:bs) | a == b = operation | otherwise = otherwise
21:25:21 <hunt> it might not actually be shorter
21:25:27 <Yuras> @google lambdacase
21:25:28 <lambdabot> https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/basic-syntax-extensions
21:25:29 <hunt> but it seems easier to read, which i desire
21:25:58 <hunt> Yuras: im aware of case notation, it was already suggested
21:26:33 <jle`> you can use `bool` i guess
21:26:41 <jle`> but yeah
21:26:45 <Cale> You could use an if expression
21:26:51 <Cale> especially as you only have two cases
21:27:06 <hunt> Cale: i suppose i will
21:27:13 <Cale> (\(a:as) (b:bs) -> if a == b then x else y)
21:27:26 <Cale> If you had more, you could use the MultiWayIf extension
21:27:32 <Cale> which sort of gives you guards anywhere
21:27:42 <Cale> https://www.haskell.org/ghc/docs/7.8.3/html/users_guide/syntax-extns.html see 7.3.20 here
21:27:51 <Cale> also see 7.3.18
21:28:22 <Cale> It still kind of bothers me that they went with "\case" rather than "case of"
21:29:09 <Yuras> hunt: lambdacase is a bit different
21:29:28 <hunt> Yuras: oh alright, i presumed it wasnt cause of the name, ill check it out
21:31:43 * hackagebot linear 1.14 - Linear Algebra  http://hackage.haskell.org/package/linear-1.14 (EdwardKmett)
21:39:53 <hunt> sorry about the basic question but i have to ask because i cant find an answer elsewhere, can you have multiple pattern matches in anonymous functions?
21:40:03 <hunt> or lambdas as theyre sometimes called
21:44:18 <Yuras> hunt: map (\case {1 -> 100; a -> a;}) [1..10]
21:44:38 <Yuras> you need LambdaCase extension enabled here
21:45:01 <Yuras> if it is not what you need, then please clarity
21:45:01 <hunt> Yuras: thats a very neat little extension, thanks for showing it to me
21:45:12 <hunt> Yuras: i did resort to using case,
21:45:39 <Yuras> and it is not a basic question, I never use it because I fail to remember it :)
21:46:43 * hackagebot twitch 0.1.2.2 - A high level file watcher DSL  http://hackage.haskell.org/package/twitch-0.1.2.2 (JonathanFischoff)
21:56:43 * hackagebot tighttp 0.0.0.3 - Tiny and Incrementally-Growing HTTP library  http://hackage.haskell.org/package/tighttp-0.0.0.3 (YoshikuniJujo)
21:56:45 * hackagebot linear 1.14.0.1 - Linear Algebra  http://hackage.haskell.org/package/linear-1.14.0.1 (EdwardKmett)
21:57:18 <gcganley> anyone have a starter book for linear algebra?
21:57:54 <johnw> maybe http://mathoverflow.net/questions/16994/linear-algebra-texts?
21:58:33 <Yuras> gcganley: I like this one: http://en.wikibooks.org/wiki/Linear_Algebra
22:00:29 <hunt> how does one indicate the lean of an infix function?
22:00:35 <hunt> i cant remember the proper term for lean
22:00:58 <Yuras> hunt: fixity?
22:01:19 <kadoban> associativity? (left or right?)
22:01:39 <hunt> Yuras: i believe fixity, kadoban is that different from fixity?
22:01:56 <kadoban> Yes
22:02:25 <kadoban> Fixity is like the...priority? That's not right...how strongly it binds? That's not really right either, haha...I don't know another correct term for it.
22:02:50 <hunt> kadoban: well in the doc i just found fixity is the measure of left right and non associativity
22:02:50 <gcganley> i like to think of it like grade school math
22:03:06 <gcganley> how parens have greater presedence than addition
22:03:17 <gcganley> function application has the highest presedence
22:03:23 <gcganley> and so on and so forth
22:03:36 <hunt> it seems pretty difficult to determine what fixity number to give a function
22:04:27 <geekosaur> precedence is often the hardest part of any language
22:04:31 <kadoban> Oh hmm, maybe fixity does mean the left/right/non. I assumed it was the other part.
22:04:33 <hunt> in general the system seems oddly... limited? somethings weird about having to determine fixity priority on a 1-9 scale
22:04:49 <kadoban> The haskell report calls the other part the "binding precedence"
22:05:19 <hunt> kadoban: binding preference == the fixity number?
22:05:20 <geekosaur> the other is associativity normally. fixity, technically, is prefix/infix/postfix
22:05:30 <kadoban> hunt: The number, yeah.
22:05:55 <kadoban> Ah. Yeah, the HR seems to call it fixity...now I'm not sure what that technically means.
22:06:06 <hunt> i find myself with nothing to use my haskell abilities for
22:06:08 <kadoban> And yeah, the 1-9 scale used to bother me too...
22:06:11 <hunt> i cant think of anything i want to make
22:06:33 <gcganley> well lets look at some examples
22:06:34 <gcganley> :t ($)
22:06:34 <gcganley> :t (.)
22:06:34 <gcganley> (.) has the highest possible presidence
22:06:34 <gcganley> while ($) has the lowest possible
22:06:34 <lambdabot> (a -> b) -> a -> b
22:06:34 <lambdabot> (b -> c) -> (a -> b) -> a -> c
22:06:58 <kadoban> hunt: Make a program that will tell you what kind of program to make.
22:07:17 <hunt> kadoban: maybe once we get dependant types that will be doable
22:07:29 <hunt> honestly though if i could i would
22:07:36 <hunt> because thats such a critical problem fo rme
22:07:46 <hunt> like clearly thats what im passionate about
22:07:46 <L8D> wait...
22:07:50 <kadoban> Yeah, I often have no idea what to program...I'm awful at thinking up ideas.
22:08:02 <L8D> wasn't there some place on reddit for ideas for programs?
22:08:07 <hunt> kadoban: i love programming but i have nothing i need for myself so... :/
22:08:08 <kadoban> Is there?
22:08:27 <hunt> L8D: for me its hard to get motivated about making something unless i think it will be valuable for me or someone i know personally
22:08:37 <hunt> L8D: or someone i can interface with at least
22:08:54 <Fuuzetsu> @tell dmj` we don't allow embedding HTML in Haddock so you can't do it that way. You could change the generated page to include what you want manually and upload it to Hackage yourself.
22:08:54 <lambdabot> Consider it noted.
22:08:57 <hunt> L8D: so i could make something from a sbreddit if it was something that would actually be useful to people
22:09:20 <Yuras> L8D: http://www.reddit.com/r/haskell_proposals/
22:09:22 <hunt> Fuuzetsu: lambdabot thats a really clever feature
22:09:36 <L8D> @tell hunt yes
22:09:36 <lambdabot> Consider it noted.
22:10:01 <gcganley> what cant lambdabot do?
22:10:18 <hunt> gcganley: have emotions
22:10:20 <L8D> make a phone call
22:10:22 <L8D> wait...
22:10:24 <L8D> nvm
22:10:43 <gcganley> hunt: im pretty sure lambdabot is selfaware
22:10:51 <hunt> gcganley understand why kids love the taste of cinnamon toast crunch
22:10:51 <MP2E> @botsnack
22:10:51 <lambdabot> :)
22:10:58 <hunt> Lol
22:11:04 <hunt> @botsnack
22:11:04 <lambdabot> :)
22:11:09 <Yuras> @lol
22:11:09 <lambdabot> Maybe you meant: yow url roll pl let do
22:11:10 <gcganley> @botsnack
22:11:10 <lambdabot> :)
22:11:15 <Yuras> :(
22:11:26 <hunt> @yow url roll pl let do
22:11:26 <lambdabot> Actually, what I'd like is a little toy spaceship!!
22:11:35 <gcganley> @yow
22:11:35 <lambdabot> I have accepted Provolone into my life!
22:11:41 <Yuras> oh, much better now
22:11:41 <hunt> hahaha wtf
22:11:43 <gcganley> @yow
22:11:43 <lambdabot> I'm sitting on my SPEED QUEEN ... To me, it's ENJOYABLE ... I'm WARM
22:11:43 <lambdabot> ... I'm VIBRATORY ...
22:11:51 <numberten> o.O
22:11:52 <hunt> what the fuck is this
22:11:58 <hunt> lambdabot is kinky
22:11:59 <hunt> @yow
22:11:59 <lambdabot> I KAISER ROLL?!  What good is a Kaiser Roll without a little COLE SLAW
22:11:59 <lambdabot> on the SIDE?
22:12:06 <L8D> @quote <hunt> what the fuck is this
22:12:06 <lambdabot> No quotes for this person. I don't think I can be your friend on Facebook anymore.
22:12:14 <L8D> @quote hunt what the fuck is this
22:12:15 <lambdabot> No quotes for this person. Where did you learn to type?
22:12:19 <gcganley> @yow
22:12:19 <lambdabot> Inside, I'm already SOBBING!
22:12:22 <L8D> @note hunt what the fuck is this
22:12:22 <lambdabot> usage: @vote <poll> <choice>
22:12:23 <codygman> I've been looking through this code for where a POST request gets offloaded to the curl library for a couple hours and am baffled. I even stepped through everything in the debugger. I must have missed something.  Can anyone help? https://github.com/codygman/shpider/blob/master/Network/Shpider.hs
22:12:31 <L8D> @remember hunt what the fuck is this
22:12:31 <lambdabot> It is stored.
22:12:35 <L8D> @quote hunt
22:12:35 <lambdabot> hunt says: what the fuck is this
22:12:49 <hunt> im glad to be remembered for something so unique
22:13:01 <MP2E> heh
22:13:07 <gcganley> hue
22:13:16 <gcganley> alright goodnight
22:13:28 <L8D> codygman: there was someone with a similar problem just the other day
22:13:33 <Yuras> there is probably no way to unremember
22:13:33 <L8D> codygman: I think with the same code
22:13:41 <L8D> codygman: there's an infinite loop or something in it
22:13:41 <Yuras> that is the answer ^
22:13:57 <L8D> @quote L8D
22:13:57 <lambdabot> No quotes match. My pet ferret can type better than you!
22:14:07 <L8D> @quote jle1
22:14:08 <lambdabot> No quotes match. Maybe you made a typo?
22:14:09 <L8D> @quote jle`
22:14:09 <lambdabot> jle` says: php can't use json.org's json because its license says it must be used for good, not evil
22:14:30 <codygman> L8D: that was me also, I found the infinite loop actually. Now there is a problem with the post parameters being mutated somewhere.... so I tried finding where the actual request is being sent to the server... and have failed.
22:14:52 <codygman> Any libraries to make a call graph of haskell progams? Perhaps I'll find one searching graphviz on hackage.
22:14:52 <L8D> codygman: that sucks
22:15:17 <L8D> @quote jle`
22:15:17 <lambdabot> jle` says: php can't use json.org's json because its license says it must be used for good, not evil
22:15:19 <hunt> L8D: i feel bad about being sarcastic, i dont mind really
22:15:23 <L8D> -.-
22:15:29 <hunt> L8D: you probably dont care but i felt bad
22:15:36 <L8D> hunt: for being quoted?
22:16:01 <hunt> L8D: no the thing i said about being remembered for something unique, i felt like that was kind of mean maybe
22:16:24 <L8D> hunt: oh no, I was just being curios
22:16:32 <L8D> hunt: I probably should've /msg'd
22:16:51 <hunt> L8D: no lol i mean my reaction to the quoting felt mean
22:16:55 <hunt> L8D: not the quoting
22:17:03 <hunt> L8D: it wasnt meant to be though
22:17:08 <L8D> ok
22:17:20 <hunt> L8D: this is all nonsense i know
22:17:37 <hunt> L8D: i just worry about this stuff irrationally
22:17:45 <L8D> ah ok
22:18:04 <L8D> hunt: here's something to write:
22:18:15 <L8D> hunt: a language that is truly simple but usable
22:18:26 <hunt> simple a la whitespace?
22:18:35 <hunt> i was thinking about writing a bit torrent client actually
22:18:38 <L8D> simple a la conceptually
22:18:40 <hunt> since thats something that i would find useful
22:18:50 <L8D> actually do that
22:19:01 <hunt> like i pretty much hate all the unix bit torrent clients
22:19:01 <L8D> I'd be very interested in a bit torrent client written in Haskell
22:19:15 <codygman> As would I
22:19:15 <L8D> too bad my computer is too slow to compile any Haskell :)
22:19:19 <L8D> :(*
22:19:20 <hunt> i think i remember reading that one exists, but its not on arches pacman, so i'd write one none the less
22:19:33 <hunt> L8D: lol really? so do you not write any haskell either?
22:19:36 <L8D> like I was really excited about 'yi' but then I tried to compile it
22:19:36 <codygman> L8D: Tried using the gold linker yet?
22:19:54 <L8D> hunt: I write Haskell, but I don't ever finish compiling
22:20:02 <L8D> codygman: ooh what's that?
22:20:02 <hunt> L8D: if you were excited about yi for its vim mode, dont worry because i didnt find it vim=like enough
22:20:25 * L8D cries
22:20:43 <codygman> L8D: http://stackoverflow.com/questions/6952396/why-does-ghc-take-so-long-to-link
22:21:26 <hunt> codygman: any specific features youd want out of the bit torrent client or is it being haskell enough?
22:21:53 <codygman> hunt: I like rtorrent. If I had a haskell version I'd like it more and hack on it ;)
22:22:42 <Fuuzetsu> for all of you folks with time there's #haskell-bittorrent
22:23:03 <L8D> codygman: but there's no gold linker for OS X :(
22:23:03 <hunt> codygman: ok could you tell me the specific features from rtorrent youd like? i like simple software so im trying to implement only the simple features
22:23:05 <Fuuzetsu> and even a project started you can hack on
22:23:09 * L8D continues to cry
22:23:43 <L8D> codygman: no but my problem actually lies in the time it takes to compile everything
22:24:02 <hunt> L8D: old computer? how long does it take?
22:24:12 <hunt> Fuuzetsu: link to the project?
22:24:29 <Fuuzetsu> github.com/hstorrent
22:24:32 <Fuuzetsu> there's very little there
22:24:51 <Fuuzetsu> everyone involved has limited amount of time so it's stalled on the starting stage ;P
22:25:06 <L8D> hunt: wait no, apparently already half of the stuff has been compiled, just I keep running into installation errors
22:25:09 <L8D> "* Missing C libraries: icuuc, icui18n, icudata"
22:25:22 <hunt> Fuuzetsu: lots of people involved? I dig how structured it is
22:25:37 <Fuuzetsu> there are like 8 people in the org
22:25:39 <hunt> L8D: looks like you need to download some C libraries
22:25:47 <Fuuzetsu> but it is not ``active''
22:25:50 <hunt> Fuuzetsu: do you guys have a process for contributing for non org members
22:25:55 <hunt> Fuuzetsu: fork pullrequest?
22:25:56 <Fuuzetsu> L8D: Sounds like you want a package manager
22:25:57 <L8D> actually it's all because cabal doesn't go to /opt/local/include properly
22:26:05 <Fuuzetsu> hunt: just give me your GitHub username and I'll add you
22:26:10 <L8D> no wait it's because of how homebrew does stuff
22:26:18 <hunt> L8D: maybe you should add it to your path? im not sure how cabal looks for libs
22:26:42 <hunt> could everyone see that
22:26:44 * hackagebot twitch 0.1.3.0 - A high level file watcher DSL  http://hackage.haskell.org/package/twitch-0.1.3.0 (JonathanFischoff)
22:26:56 <hunt> my username
22:26:59 <Fuuzetsu> no
22:27:01 <Fuuzetsu> just me
22:27:12 <L8D> hunt: I mean, for every c-related Haskell library I install I have to go through the tedious process of using --extra-include-dirs=...
22:28:34 <luite> L8D: add them to your cabal config file
22:29:24 <codygman> Fuuzetsu: I'll have to check it out
22:30:31 <Fuuzetsu> The goal is to end up with fully-featured, fast bittorrent library in native Haskell
22:30:38 <luite> L8D: unless it's for libs that aren't linked
22:31:02 <hunt> Fuuzetsu: so this is not a client but a library?
22:31:05 <luite> L8D: in which case i don't know what to do, does homebrew support linking to a different location?
22:32:02 <L8D> luite: homebrew puts things in /usr/local/opt/package-name/{include,lib}
22:32:15 <L8D> luite: so for every homebrew package I'd need to add that to my cabal config
22:32:36 <Fuuzetsu> hunt: correct
22:32:41 <L8D> luite: unless I could do --extra-include-dirs=/usr/local/opt/*/lib
22:33:24 <Fuuzetsu> hunt: writing clients should be easy once library is in place
22:33:45 <Fuuzetsu> clients that can actually talk to the world properly even if the client itself is simple
22:34:52 <L8D> hunt: be sure to not make a ncurses-based GUI
22:35:04 <hunt> L8D: ofc
22:35:11 <L8D> hunt: make it a daemon with a command that interfaces to it
22:35:11 <hunt> L8D: thats exactly why i wanted to write a client
22:35:25 <L8D> yay!
22:35:29 <hunt> L8D: i think the client I write might be synchronous
22:35:39 <hunt> L8D: that seems the most scriptable to me
22:35:49 <hunt> L8D: maybe there could be a daemon mode too
22:35:56 <hunt> L8D: like curl or wget
22:36:03 <L8D> would it be prompt-based?
22:36:08 <luite> L8D: is that a custom config? mine links them in /usr/local/include with symlinks
22:36:21 <hunt> L8D: not sure what prompt-based means
22:36:26 <L8D> luite: it's what the new version of homebrew does
22:36:46 <L8D> hunt: would it be a prompt, like a shell or something where you type different commands?
22:36:58 <L8D> the client
22:37:18 <hunt> L8D: i dont know, i mean ideally i want it to be basically curl for torrents, although i not sure if that makes sense since torrents are usually used for larger files
22:37:31 <hunt> L8D: if theres a daemon i suppose some kind of prompt might be useful
22:37:33 <luite> L8D: how new? i installed my laptop 3 days ago, probably just grabbed the stable version
22:37:45 <hunt> L8D: although generally i prefer just simple one off commands
22:38:18 <L8D> luite: like when you do brew install icu you get /usr/local/opts/include?
22:38:35 <L8D> luite: what does your /usr/local/opt look like?
22:38:48 <luite> L8D: at least something where you don't have a single dir where all includes are linked
22:40:17 <luite> L8D: my /usr/local/opt contains symlinks to /usr/local/Cellar where the packages are installed
22:40:23 <Fuuzetsu> L8D: there is often a throughput problem with daemon approach
22:40:29 <Fuuzetsu> example: an rtorrent interface
22:40:35 <Fuuzetsu> once you have more than 5 torrents, it falls apart
22:40:40 <Fuuzetsu> any*
22:41:36 <luite> L8D: the include symlinks are from /usr/local/include/someinclude.h -> /usr/local/Cellar/somepackage/someversion/include/someinclude.h
22:42:11 <luite> L8D: unless it's a package that's potentially conflicting, then it's not linked until i run "brew link" explicitly for that package
22:43:43 <luite> L8D: but it has done this for years
22:44:00 <L8D> then something weird is going on
22:47:21 <luite> L8D: i'd expect icu to be not linked by default since apple provides it too (i think)
22:48:04 <luite> but if it happens for everything, then i don't know what's going on
22:49:13 <Fuuzetsu> L8D: install nix ;)
22:49:46 <luite> L8D: yeah tht one is not linked by default, see brew info icu4c
23:20:32 <mrsElectron> Hi! making a module without exports, what does that mean? Will all functions be exported?   export modulename where ..  note, no parenthesis
23:20:47 <indiagreen> yes, everything will be exported
23:20:56 <indiagreen> no, wait
23:20:57 <mrsElectron> okay :)
23:21:12 <indiagreen> did you mean “import modulename where”?
23:21:36 <indiagreen> ouch
23:21:52 <indiagreen> * did you mean “module modulename where”
23:22:05 <mrsElectron> yeah!
23:22:22 <indiagreen> aha, good then, I thought “export” was something I hadn't known about
23:31:44 * hackagebot twitch 0.1.4.0 - A high level file watcher DSL  http://hackage.haskell.org/package/twitch-0.1.4.0 (JonathanFischoff)
23:39:07 <Sir_Biscuit> o
23:39:11 <codygman> It seems that a curl request is being fired when this state monad value is appended to, can anyone explain how that is happening? https://github.com/codygman/shpider/blob/master/Network/Shpider.hs#L345
23:39:51 <Fuuzetsu> a type signature would sure help there
23:43:40 <codygman> Fuuzetsu: Let me get it for you
23:44:09 <Fuuzetsu> not sure what your problem is there though, is the request being sent twice?
23:47:59 <codygman> Fuuzetsu: Actually my problem is that the CurlPostFields inside of curlOpts aren't being parsed right or are being mutated somewhere. So I'm trying to find exactly how/where the curl request is being sent so I can inspect the value of the current ShpiderState's curlOpts.
23:48:05 <codygman> btw, postURL :: String -> [(String, String)] -> Shpider (ShpiderCode, Page)
23:49:58 <codygman> all I know is while debugging, after the debugger evaluates CurlPost True the request is sent. I expected a curlPost request or something, but this program works different and takes advantage of monad transformers more than ones I've worked with before I guess.
23:54:27 <mrsElectron> is there a difference between myfunc :: [a] -> [a] and  myfunc :: [b] -> [b] ?
23:54:34 <Fuuzetsu> no
23:56:04 <mrsElectron> why do fuz a b c = a+b+c have type a->a->a->a->? That makes no sense. How do you interpret that?
23:56:12 <mrsElectron> type signature*
23:56:35 <hunt> people who have jobs in haskell: how stable is the company you work at/ is haskell the primary language of your company?
23:57:26 <indiagreen> mrsElectron: “a -> a -> a -> a”, perhaps?
23:58:24 <MP2E> mrsElectron: that's quite clear to me, I think you're mixing up a b c with the type. a b c in the function body are merely bindings to the arguments
23:58:56 <MP2E> it could have been 'foo bar baz quux = bar+baz+quux :: a -> a -> a -> a'
